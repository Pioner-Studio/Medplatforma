    1: from datetime import timedelta
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas._libs import index as libindex
    8: from pandas.errors import (
    9:     InvalidIndexError,
   10:     PerformanceWarning,
   11: )
   12: 
   13: import pandas as pd
   14: from pandas import (
   15:     Categorical,
   16:     DataFrame,
   17:     Index,
   18:     MultiIndex,
   19:     date_range,
   20: )
   21: import pandas._testing as tm
   22: 
   23: 
   24: class TestSliceLocs:
   25:     def test_slice_locs_partial(self, idx):
   26:         sorted_idx, _ = idx.sortlevel(0)
   27: 
   28:         result = sorted_idx.slice_locs(("foo", "two"), ("qux", "one"))
   29:         assert result == (1, 5)
   30: 
   31:         result = sorted_idx.slice_locs(None, ("qux", "one"))
   32:         assert result == (0, 5)
   33: 
   34:         result = sorted_idx.slice_locs(("foo", "two"), None)
   35:         assert result == (1, len(sorted_idx))
   36: 
   37:         result = sorted_idx.slice_locs("bar", "baz")
   38:         assert result == (2, 4)
   39: 
   40:     def test_slice_locs(self):
   41:         df = DataFrame(
   42:             np.random.default_rng(2).standard_normal((50, 4)),
   43:             columns=Index(list("ABCD"), dtype=object),
   44:             index=date_range("2000-01-01", periods=50, freq="B"),
   45:         )
   46:         stacked = df.stack(future_stack=True)
   47:         idx = stacked.index
   48: 
   49:         slob = slice(*idx.slice_locs(df.index[5], df.index[15]))
   50:         sliced = stacked[slob]
   51:         expected = df[5:16].stack(future_stack=True)
   52:         tm.assert_almost_equal(sliced.values, expected.values)
   53: 
   54:         slob = slice(
   55:             *idx.slice_locs(
   56:                 df.index[5] + timedelta(seconds=30),
   57:                 df.index[15] - timedelta(seconds=30),
   58:             )
   59:         )
   60:         sliced = stacked[slob]
   61:         expected = df[6:15].stack(future_stack=True)
   62:         tm.assert_almost_equal(sliced.values, expected.values)
   63: 
   64:     def test_slice_locs_with_type_mismatch(self):
   65:         df = DataFrame(
   66:             np.random.default_rng(2).standard_normal((10, 4)),
   67:             columns=Index(list("ABCD"), dtype=object),
   68:             index=date_range("2000-01-01", periods=10, freq="B"),
   69:         )
   70:         stacked = df.stack(future_stack=True)
   71:         idx = stacked.index
   72:         with pytest.raises(TypeError, match="^Level type mismatch"):
   73:             idx.slice_locs((1, 3))
   74:         with pytest.raises(TypeError, match="^Level type mismatch"):
   75:             idx.slice_locs(df.index[5] + timedelta(seconds=30), (5, 2))
   76:         df = DataFrame(
   77:             np.ones((5, 5)),
   78:             index=Index([f"i-{i}" for i in range(5)], name="a"),
   79:             columns=Index([f"i-{i}" for i in range(5)], name="a"),
   80:         )
   81:         stacked = df.stack(future_stack=True)
   82:         idx = stacked.index
   83:         with pytest.raises(TypeError, match="^Level type mismatch"):
   84:             idx.slice_locs(timedelta(seconds=30))
   85:         # TODO: Try creating a UnicodeDecodeError in exception message
   86:         with pytest.raises(TypeError, match="^Level type mismatch"):
   87:             idx.slice_locs(df.index[1], (16, "a"))
   88: 
   89:     def test_slice_locs_not_sorted(self):
   90:         index = MultiIndex(
   91:             levels=[Index(np.arange(4)), Index(np.arange(4)), Index(np.arange(4))],
   92:             codes=[
   93:                 np.array([0, 0, 1, 2, 2, 2, 3, 3]),
   94:                 np.array([0, 1, 0, 0, 0, 1, 0, 1]),
   95:                 np.array([1, 0, 1, 1, 0, 0, 1, 0]),
   96:             ],
   97:         )
   98:         msg = "[Kk]ey length.*greater than MultiIndex lexsort depth"
   99:         with pytest.raises(KeyError, match=msg):
  100:             index.slice_locs((1, 0, 1), (2, 1, 0))
  101: 
  102:         # works
  103:         sorted_index, _ = index.sortlevel(0)
  104:         # should there be a test case here???
  105:         sorted_index.slice_locs((1, 0, 1), (2, 1, 0))
  106: 
  107:     def test_slice_locs_not_contained(self):
  108:         # some searchsorted action
  109: 
  110:         index = MultiIndex(
  111:             levels=[[0, 2, 4, 6], [0, 2, 4]],
  112:             codes=[[0, 0, 0, 1, 1, 2, 3, 3, 3], [0, 1, 2, 1, 2, 2, 0, 1, 2]],
  113:         )
  114: 
  115:         result = index.slice_locs((1, 0), (5, 2))
  116:         assert result == (3, 6)
  117: 
  118:         result = index.slice_locs(1, 5)
  119:         assert result == (3, 6)
  120: 
  121:         result = index.slice_locs((2, 2), (5, 2))
  122:         assert result == (3, 6)
  123: 
  124:         result = index.slice_locs(2, 5)
  125:         assert result == (3, 6)
  126: 
  127:         result = index.slice_locs((1, 0), (6, 3))
  128:         assert result == (3, 8)
  129: 
  130:         result = index.slice_locs(-1, 10)
  131:         assert result == (0, len(index))
  132: 
  133:     @pytest.mark.parametrize(
  134:         "index_arr,expected,start_idx,end_idx",
  135:         [
  136:             ([[np.nan, "a", "b"], ["c", "d", "e"]], (0, 3), np.nan, None),
  137:             ([[np.nan, "a", "b"], ["c", "d", "e"]], (0, 3), np.nan, "b"),
  138:             ([[np.nan, "a", "b"], ["c", "d", "e"]], (0, 3), np.nan, ("b", "e")),
  139:             ([["a", "b", "c"], ["d", np.nan, "e"]], (1, 3), ("b", np.nan), None),
  140:             ([["a", "b", "c"], ["d", np.nan, "e"]], (1, 3), ("b", np.nan), "c"),
  141:             ([["a", "b", "c"], ["d", np.nan, "e"]], (1, 3), ("b", np.nan), ("c", "e")),
  142:         ],
  143:     )
  144:     def test_slice_locs_with_missing_value(
  145:         self, index_arr, expected, start_idx, end_idx
  146:     ):
  147:         # issue 19132
  148:         idx = MultiIndex.from_arrays(index_arr)
  149:         result = idx.slice_locs(start=start_idx, end=end_idx)
  150:         assert result == expected
  151: 
  152: 
  153: class TestPutmask:
  154:     def test_putmask_with_wrong_mask(self, idx):
  155:         # GH18368
  156: 
  157:         msg = "putmask: mask and data must be the same size"
  158:         with pytest.raises(ValueError, match=msg):
  159:             idx.putmask(np.ones(len(idx) + 1, np.bool_), 1)
  160: 
  161:         with pytest.raises(ValueError, match=msg):
  162:             idx.putmask(np.ones(len(idx) - 1, np.bool_), 1)
  163: 
  164:         with pytest.raises(ValueError, match=msg):
  165:             idx.putmask("foo", 1)
  166: 
  167:     def test_putmask_multiindex_other(self):
  168:         # GH#43212 `value` is also a MultiIndex
  169: 
  170:         left = MultiIndex.from_tuples([(np.nan, 6), (np.nan, 6), ("a", 4)])
  171:         right = MultiIndex.from_tuples([("a", 1), ("a", 1), ("d", 1)])
  172:         mask = np.array([True, True, False])
  173: 
  174:         result = left.putmask(mask, right)
  175: 
  176:         expected = MultiIndex.from_tuples([right[0], right[1], left[2]])
  177:         tm.assert_index_equal(result, expected)
  178: 
  179:     def test_putmask_keep_dtype(self, any_numeric_ea_dtype):
  180:         # GH#49830
  181:         midx = MultiIndex.from_arrays(
  182:             [pd.Series([1, 2, 3], dtype=any_numeric_ea_dtype), [10, 11, 12]]
  183:         )
  184:         midx2 = MultiIndex.from_arrays(
  185:             [pd.Series([5, 6, 7], dtype=any_numeric_ea_dtype), [-1, -2, -3]]
  186:         )
  187:         result = midx.putmask([True, False, False], midx2)
  188:         expected = MultiIndex.from_arrays(
  189:             [pd.Series([5, 2, 3], dtype=any_numeric_ea_dtype), [-1, 11, 12]]
  190:         )
  191:         tm.assert_index_equal(result, expected)
  192: 
  193:     def test_putmask_keep_dtype_shorter_value(self, any_numeric_ea_dtype):
  194:         # GH#49830
  195:         midx = MultiIndex.from_arrays(
  196:             [pd.Series([1, 2, 3], dtype=any_numeric_ea_dtype), [10, 11, 12]]
  197:         )
  198:         midx2 = MultiIndex.from_arrays(
  199:             [pd.Series([5], dtype=any_numeric_ea_dtype), [-1]]
  200:         )
  201:         result = midx.putmask([True, False, False], midx2)
  202:         expected = MultiIndex.from_arrays(
  203:             [pd.Series([5, 2, 3], dtype=any_numeric_ea_dtype), [-1, 11, 12]]
  204:         )
  205:         tm.assert_index_equal(result, expected)
  206: 
  207: 
  208: class TestGetIndexer:
  209:     def test_get_indexer(self):
  210:         major_axis = Index(np.arange(4))
  211:         minor_axis = Index(np.arange(2))
  212: 
  213:         major_codes = np.array([0, 0, 1, 2, 2, 3, 3], dtype=np.intp)
  214:         minor_codes = np.array([0, 1, 0, 0, 1, 0, 1], dtype=np.intp)
  215: 
  216:         index = MultiIndex(
  217:             levels=[major_axis, minor_axis], codes=[major_codes, minor_codes]
  218:         )
  219:         idx1 = index[:5]
  220:         idx2 = index[[1, 3, 5]]
  221: 
  222:         r1 = idx1.get_indexer(idx2)
  223:         tm.assert_almost_equal(r1, np.array([1, 3, -1], dtype=np.intp))
  224: 
  225:         r1 = idx2.get_indexer(idx1, method="pad")
  226:         e1 = np.array([-1, 0, 0, 1, 1], dtype=np.intp)
  227:         tm.assert_almost_equal(r1, e1)
  228: 
  229:         r2 = idx2.get_indexer(idx1[::-1], method="pad")
  230:         tm.assert_almost_equal(r2, e1[::-1])
  231: 
  232:         rffill1 = idx2.get_indexer(idx1, method="ffill")
  233:         tm.assert_almost_equal(r1, rffill1)
  234: 
  235:         r1 = idx2.get_indexer(idx1, method="backfill")
  236:         e1 = np.array([0, 0, 1, 1, 2], dtype=np.intp)
  237:         tm.assert_almost_equal(r1, e1)
  238: 
  239:         r2 = idx2.get_indexer(idx1[::-1], method="backfill")
  240:         tm.assert_almost_equal(r2, e1[::-1])
  241: 
  242:         rbfill1 = idx2.get_indexer(idx1, method="bfill")
  243:         tm.assert_almost_equal(r1, rbfill1)
  244: 
  245:         # pass non-MultiIndex
  246:         r1 = idx1.get_indexer(idx2.values)
  247:         rexp1 = idx1.get_indexer(idx2)
  248:         tm.assert_almost_equal(r1, rexp1)
  249: 
  250:         r1 = idx1.get_indexer([1, 2, 3])
  251:         assert (r1 == [-1, -1, -1]).all()
  252: 
  253:         # create index with duplicates
  254:         idx1 = Index(list(range(10)) + list(range(10)))
  255:         idx2 = Index(list(range(20)))
  256: 
  257:         msg = "Reindexing only valid with uniquely valued Index objects"
  258:         with pytest.raises(InvalidIndexError, match=msg):
  259:             idx1.get_indexer(idx2)
  260: 
  261:     def test_get_indexer_nearest(self):
  262:         midx = MultiIndex.from_tuples([("a", 1), ("b", 2)])
  263:         msg = (
  264:             "method='nearest' not implemented yet for MultiIndex; "
  265:             "see GitHub issue 9365"
  266:         )
  267:         with pytest.raises(NotImplementedError, match=msg):
  268:             midx.get_indexer(["a"], method="nearest")
  269:         msg = "tolerance not implemented yet for MultiIndex"
  270:         with pytest.raises(NotImplementedError, match=msg):
  271:             midx.get_indexer(["a"], method="pad", tolerance=2)
  272: 
  273:     def test_get_indexer_categorical_time(self):
  274:         # https://github.com/pandas-dev/pandas/issues/21390
  275:         midx = MultiIndex.from_product(
  276:             [
  277:                 Categorical(["a", "b", "c"]),
  278:                 Categorical(date_range("2012-01-01", periods=3, freq="h")),
  279:             ]
  280:         )
  281:         result = midx.get_indexer(midx)
  282:         tm.assert_numpy_array_equal(result, np.arange(9, dtype=np.intp))
  283: 
  284:     @pytest.mark.parametrize(
  285:         "index_arr,labels,expected",
  286:         [
  287:             (
  288:                 [[1, np.nan, 2], [3, 4, 5]],
  289:                 [1, np.nan, 2],
  290:                 np.array([-1, -1, -1], dtype=np.intp),
  291:             ),
  292:             ([[1, np.nan, 2], [3, 4, 5]], [(np.nan, 4)], np.array([1], dtype=np.intp)),
  293:             ([[1, 2, 3], [np.nan, 4, 5]], [(1, np.nan)], np.array([0], dtype=np.intp)),
  294:             (
  295:                 [[1, 2, 3], [np.nan, 4, 5]],
  296:                 [np.nan, 4, 5],
  297:                 np.array([-1, -1, -1], dtype=np.intp),
  298:             ),
  299:         ],
  300:     )
  301:     def test_get_indexer_with_missing_value(self, index_arr, labels, expected):
  302:         # issue 19132
  303:         idx = MultiIndex.from_arrays(index_arr)
  304:         result = idx.get_indexer(labels)
  305:         tm.assert_numpy_array_equal(result, expected)
  306: 
  307:     def test_get_indexer_methods(self):
  308:         # https://github.com/pandas-dev/pandas/issues/29896
  309:         # test getting an indexer for another index with different methods
  310:         # confirms that getting an indexer without a filling method, getting an
  311:         # indexer and backfilling, and getting an indexer and padding all behave
  312:         # correctly in the case where all of the target values fall in between
  313:         # several levels in the MultiIndex into which they are getting an indexer
  314:         #
  315:         # visually, the MultiIndexes used in this test are:
  316:         # mult_idx_1:
  317:         #  0: -1 0
  318:         #  1:    2
  319:         #  2:    3
  320:         #  3:    4
  321:         #  4:  0 0
  322:         #  5:    2
  323:         #  6:    3
  324:         #  7:    4
  325:         #  8:  1 0
  326:         #  9:    2
  327:         # 10:    3
  328:         # 11:    4
  329:         #
  330:         # mult_idx_2:
  331:         #  0: 0 1
  332:         #  1:   3
  333:         #  2:   4
  334:         mult_idx_1 = MultiIndex.from_product([[-1, 0, 1], [0, 2, 3, 4]])
  335:         mult_idx_2 = MultiIndex.from_product([[0], [1, 3, 4]])
  336: 
  337:         indexer = mult_idx_1.get_indexer(mult_idx_2)
  338:         expected = np.array([-1, 6, 7], dtype=indexer.dtype)
  339:         tm.assert_almost_equal(expected, indexer)
  340: 
  341:         backfill_indexer = mult_idx_1.get_indexer(mult_idx_2, method="backfill")
  342:         expected = np.array([5, 6, 7], dtype=backfill_indexer.dtype)
  343:         tm.assert_almost_equal(expected, backfill_indexer)
  344: 
  345:         # ensure the legacy "bfill" option functions identically to "backfill"
  346:         backfill_indexer = mult_idx_1.get_indexer(mult_idx_2, method="bfill")
  347:         expected = np.array([5, 6, 7], dtype=backfill_indexer.dtype)
  348:         tm.assert_almost_equal(expected, backfill_indexer)
  349: 
  350:         pad_indexer = mult_idx_1.get_indexer(mult_idx_2, method="pad")
  351:         expected = np.array([4, 6, 7], dtype=pad_indexer.dtype)
  352:         tm.assert_almost_equal(expected, pad_indexer)
  353: 
  354:         # ensure the legacy "ffill" option functions identically to "pad"
  355:         pad_indexer = mult_idx_1.get_indexer(mult_idx_2, method="ffill")
  356:         expected = np.array([4, 6, 7], dtype=pad_indexer.dtype)
  357:         tm.assert_almost_equal(expected, pad_indexer)
  358: 
  359:     @pytest.mark.parametrize("method", ["pad", "ffill", "backfill", "bfill", "nearest"])
  360:     def test_get_indexer_methods_raise_for_non_monotonic(self, method):
  361:         # 53452
  362:         mi = MultiIndex.from_arrays([[0, 4, 2], [0, 4, 2]])
  363:         if method == "nearest":
  364:             err = NotImplementedError
  365:             msg = "not implemented yet for MultiIndex"
  366:         else:
  367:             err = ValueError
  368:             msg = "index must be monotonic increasing or decreasing"
  369:         with pytest.raises(err, match=msg):
  370:             mi.get_indexer([(1, 1)], method=method)
  371: 
  372:     def test_get_indexer_three_or_more_levels(self):
  373:         # https://github.com/pandas-dev/pandas/issues/29896
  374:         # tests get_indexer() on MultiIndexes with 3+ levels
  375:         # visually, these are
  376:         # mult_idx_1:
  377:         #  0: 1 2 5
  378:         #  1:     7
  379:         #  2:   4 5
  380:         #  3:     7
  381:         #  4:   6 5
  382:         #  5:     7
  383:         #  6: 3 2 5
  384:         #  7:     7
  385:         #  8:   4 5
  386:         #  9:     7
  387:         # 10:   6 5
  388:         # 11:     7
  389:         #
  390:         # mult_idx_2:
  391:         #  0: 1 1 8
  392:         #  1: 1 5 9
  393:         #  2: 1 6 7
  394:         #  3: 2 1 6
  395:         #  4: 2 7 6
  396:         #  5: 2 7 8
  397:         #  6: 3 6 8
  398:         mult_idx_1 = MultiIndex.from_product([[1, 3], [2, 4, 6], [5, 7]])
  399:         mult_idx_2 = MultiIndex.from_tuples(
  400:             [
  401:                 (1, 1, 8),
  402:                 (1, 5, 9),
  403:                 (1, 6, 7),
  404:                 (2, 1, 6),
  405:                 (2, 7, 7),
  406:                 (2, 7, 8),
  407:                 (3, 6, 8),
  408:             ]
  409:         )
  410:         # sanity check
  411:         assert mult_idx_1.is_monotonic_increasing
  412:         assert mult_idx_1.is_unique
  413:         assert mult_idx_2.is_monotonic_increasing
  414:         assert mult_idx_2.is_unique
  415: 
  416:         # show the relationships between the two
  417:         assert mult_idx_2[0] < mult_idx_1[0]
  418:         assert mult_idx_1[3] < mult_idx_2[1] < mult_idx_1[4]
  419:         assert mult_idx_1[5] == mult_idx_2[2]
  420:         assert mult_idx_1[5] < mult_idx_2[3] < mult_idx_1[6]
  421:         assert mult_idx_1[5] < mult_idx_2[4] < mult_idx_1[6]
  422:         assert mult_idx_1[5] < mult_idx_2[5] < mult_idx_1[6]
  423:         assert mult_idx_1[-1] < mult_idx_2[6]
  424: 
  425:         indexer_no_fill = mult_idx_1.get_indexer(mult_idx_2)
  426:         expected = np.array([-1, -1, 5, -1, -1, -1, -1], dtype=indexer_no_fill.dtype)
  427:         tm.assert_almost_equal(expected, indexer_no_fill)
  428: 
  429:         # test with backfilling
  430:         indexer_backfilled = mult_idx_1.get_indexer(mult_idx_2, method="backfill")
  431:         expected = np.array([0, 4, 5, 6, 6, 6, -1], dtype=indexer_backfilled.dtype)
  432:         tm.assert_almost_equal(expected, indexer_backfilled)
  433: 
  434:         # now, the same thing, but forward-filled (aka "padded")
  435:         indexer_padded = mult_idx_1.get_indexer(mult_idx_2, method="pad")
  436:         expected = np.array([-1, 3, 5, 5, 5, 5, 11], dtype=indexer_padded.dtype)
  437:         tm.assert_almost_equal(expected, indexer_padded)
  438: 
  439:         # now, do the indexing in the other direction
  440:         assert mult_idx_2[0] < mult_idx_1[0] < mult_idx_2[1]
  441:         assert mult_idx_2[0] < mult_idx_1[1] < mult_idx_2[1]
  442:         assert mult_idx_2[0] < mult_idx_1[2] < mult_idx_2[1]
  443:         assert mult_idx_2[0] < mult_idx_1[3] < mult_idx_2[1]
  444:         assert mult_idx_2[1] < mult_idx_1[4] < mult_idx_2[2]
  445:         assert mult_idx_2[2] == mult_idx_1[5]
  446:         assert mult_idx_2[5] < mult_idx_1[6] < mult_idx_2[6]
  447:         assert mult_idx_2[5] < mult_idx_1[7] < mult_idx_2[6]
  448:         assert mult_idx_2[5] < mult_idx_1[8] < mult_idx_2[6]
  449:         assert mult_idx_2[5] < mult_idx_1[9] < mult_idx_2[6]
  450:         assert mult_idx_2[5] < mult_idx_1[10] < mult_idx_2[6]
  451:         assert mult_idx_2[5] < mult_idx_1[11] < mult_idx_2[6]
  452: 
  453:         indexer = mult_idx_2.get_indexer(mult_idx_1)
  454:         expected = np.array(
  455:             [-1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1], dtype=indexer.dtype
  456:         )
  457:         tm.assert_almost_equal(expected, indexer)
  458: 
  459:         backfill_indexer = mult_idx_2.get_indexer(mult_idx_1, method="bfill")
  460:         expected = np.array(
  461:             [1, 1, 1, 1, 2, 2, 6, 6, 6, 6, 6, 6], dtype=backfill_indexer.dtype
  462:         )
  463:         tm.assert_almost_equal(expected, backfill_indexer)
  464: 
  465:         pad_indexer = mult_idx_2.get_indexer(mult_idx_1, method="pad")
  466:         expected = np.array(
  467:             [0, 0, 0, 0, 1, 2, 5, 5, 5, 5, 5, 5], dtype=pad_indexer.dtype
  468:         )
  469:         tm.assert_almost_equal(expected, pad_indexer)
  470: 
  471:     def test_get_indexer_crossing_levels(self):
  472:         # https://github.com/pandas-dev/pandas/issues/29896
  473:         # tests a corner case with get_indexer() with MultiIndexes where, when we
  474:         # need to "carry" across levels, proper tuple ordering is respected
  475:         #
  476:         # the MultiIndexes used in this test, visually, are:
  477:         # mult_idx_1:
  478:         #  0: 1 1 1 1
  479:         #  1:       2
  480:         #  2:     2 1
  481:         #  3:       2
  482:         #  4: 1 2 1 1
  483:         #  5:       2
  484:         #  6:     2 1
  485:         #  7:       2
  486:         #  8: 2 1 1 1
  487:         #  9:       2
  488:         # 10:     2 1
  489:         # 11:       2
  490:         # 12: 2 2 1 1
  491:         # 13:       2
  492:         # 14:     2 1
  493:         # 15:       2
  494:         #
  495:         # mult_idx_2:
  496:         #  0: 1 3 2 2
  497:         #  1: 2 3 2 2
  498:         mult_idx_1 = MultiIndex.from_product([[1, 2]] * 4)
  499:         mult_idx_2 = MultiIndex.from_tuples([(1, 3, 2, 2), (2, 3, 2, 2)])
  500: 
  501:         # show the tuple orderings, which get_indexer() should respect
  502:         assert mult_idx_1[7] < mult_idx_2[0] < mult_idx_1[8]
  503:         assert mult_idx_1[-1] < mult_idx_2[1]
  504: 
  505:         indexer = mult_idx_1.get_indexer(mult_idx_2)
  506:         expected = np.array([-1, -1], dtype=indexer.dtype)
  507:         tm.assert_almost_equal(expected, indexer)
  508: 
  509:         backfill_indexer = mult_idx_1.get_indexer(mult_idx_2, method="bfill")
  510:         expected = np.array([8, -1], dtype=backfill_indexer.dtype)
  511:         tm.assert_almost_equal(expected, backfill_indexer)
  512: 
  513:         pad_indexer = mult_idx_1.get_indexer(mult_idx_2, method="ffill")
  514:         expected = np.array([7, 15], dtype=pad_indexer.dtype)
  515:         tm.assert_almost_equal(expected, pad_indexer)
  516: 
  517:     def test_get_indexer_kwarg_validation(self):
  518:         # GH#41918
  519:         mi = MultiIndex.from_product([range(3), ["A", "B"]])
  520: 
  521:         msg = "limit argument only valid if doing pad, backfill or nearest"
  522:         with pytest.raises(ValueError, match=msg):
  523:             mi.get_indexer(mi[:-1], limit=4)
  524: 
  525:         msg = "tolerance argument only valid if doing pad, backfill or nearest"
  526:         with pytest.raises(ValueError, match=msg):
  527:             mi.get_indexer(mi[:-1], tolerance="piano")
  528: 
  529:     def test_get_indexer_nan(self):
  530:         # GH#37222
  531:         idx1 = MultiIndex.from_product([["A"], [1.0, 2.0]], names=["id1", "id2"])
  532:         idx2 = MultiIndex.from_product([["A"], [np.nan, 2.0]], names=["id1", "id2"])
  533:         expected = np.array([-1, 1])
  534:         result = idx2.get_indexer(idx1)
  535:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  536:         result = idx1.get_indexer(idx2)
  537:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  538: 
  539: 
  540: def test_getitem(idx):
  541:     # scalar
  542:     assert idx[2] == ("bar", "one")
  543: 
  544:     # slice
  545:     result = idx[2:5]
  546:     expected = idx[[2, 3, 4]]
  547:     assert result.equals(expected)
  548: 
  549:     # boolean
  550:     result = idx[[True, False, True, False, True, True]]
  551:     result2 = idx[np.array([True, False, True, False, True, True])]
  552:     expected = idx[[0, 2, 4, 5]]
  553:     assert result.equals(expected)
  554:     assert result2.equals(expected)
  555: 
  556: 
  557: def test_getitem_group_select(idx):
  558:     sorted_idx, _ = idx.sortlevel(0)
  559:     assert sorted_idx.get_loc("baz") == slice(3, 4)
  560:     assert sorted_idx.get_loc("foo") == slice(0, 2)
  561: 
  562: 
  563: @pytest.mark.parametrize("ind1", [[True] * 5, Index([True] * 5)])
  564: @pytest.mark.parametrize(
  565:     "ind2",
  566:     [[True, False, True, False, False], Index([True, False, True, False, False])],
  567: )
  568: def test_getitem_bool_index_all(ind1, ind2):
  569:     # GH#22533
  570:     idx = MultiIndex.from_tuples([(10, 1), (20, 2), (30, 3), (40, 4), (50, 5)])
  571:     tm.assert_index_equal(idx[ind1], idx)
  572: 
  573:     expected = MultiIndex.from_tuples([(10, 1), (30, 3)])
  574:     tm.assert_index_equal(idx[ind2], expected)
  575: 
  576: 
  577: @pytest.mark.parametrize("ind1", [[True], Index([True])])
  578: @pytest.mark.parametrize("ind2", [[False], Index([False])])
  579: def test_getitem_bool_index_single(ind1, ind2):
  580:     # GH#22533
  581:     idx = MultiIndex.from_tuples([(10, 1)])
  582:     tm.assert_index_equal(idx[ind1], idx)
  583: 
  584:     expected = MultiIndex(
  585:         levels=[np.array([], dtype=np.int64), np.array([], dtype=np.int64)],
  586:         codes=[[], []],
  587:     )
  588:     tm.assert_index_equal(idx[ind2], expected)
  589: 
  590: 
  591: class TestGetLoc:
  592:     def test_get_loc(self, idx):
  593:         assert idx.get_loc(("foo", "two")) == 1
  594:         assert idx.get_loc(("baz", "two")) == 3
  595:         with pytest.raises(KeyError, match=r"^\('bar', 'two'\)$"):
  596:             idx.get_loc(("bar", "two"))
  597:         with pytest.raises(KeyError, match=r"^'quux'$"):
  598:             idx.get_loc("quux")
  599: 
  600:         # 3 levels
  601:         index = MultiIndex(
  602:             levels=[Index(np.arange(4)), Index(np.arange(4)), Index(np.arange(4))],
  603:             codes=[
  604:                 np.array([0, 0, 1, 2, 2, 2, 3, 3]),
  605:                 np.array([0, 1, 0, 0, 0, 1, 0, 1]),
  606:                 np.array([1, 0, 1, 1, 0, 0, 1, 0]),
  607:             ],
  608:         )
  609:         with pytest.raises(KeyError, match=r"^\(1, 1\)$"):
  610:             index.get_loc((1, 1))
  611:         assert index.get_loc((2, 0)) == slice(3, 5)
  612: 
  613:     def test_get_loc_duplicates(self):
  614:         index = Index([2, 2, 2, 2])
  615:         result = index.get_loc(2)
  616:         expected = slice(0, 4)
  617:         assert result == expected
  618: 
  619:         index = Index(["c", "a", "a", "b", "b"])
  620:         rs = index.get_loc("c")
  621:         xp = 0
  622:         assert rs == xp
  623: 
  624:         with pytest.raises(KeyError, match="2"):
  625:             index.get_loc(2)
  626: 
  627:     def test_get_loc_level(self):
  628:         index = MultiIndex(
  629:             levels=[Index(np.arange(4)), Index(np.arange(4)), Index(np.arange(4))],
  630:             codes=[
  631:                 np.array([0, 0, 1, 2, 2, 2, 3, 3]),
  632:                 np.array([0, 1, 0, 0, 0, 1, 0, 1]),
  633:                 np.array([1, 0, 1, 1, 0, 0, 1, 0]),
  634:             ],
  635:         )
  636:         loc, new_index = index.get_loc_level((0, 1))
  637:         expected = slice(1, 2)
  638:         exp_index = index[expected].droplevel(0).droplevel(0)
  639:         assert loc == expected
  640:         assert new_index.equals(exp_index)
  641: 
  642:         loc, new_index = index.get_loc_level((0, 1, 0))
  643:         expected = 1
  644:         assert loc == expected
  645:         assert new_index is None
  646: 
  647:         with pytest.raises(KeyError, match=r"^\(2, 2\)$"):
  648:             index.get_loc_level((2, 2))
  649:         # GH 22221: unused label
  650:         with pytest.raises(KeyError, match=r"^2$"):
  651:             index.drop(2).get_loc_level(2)
  652:         # Unused label on unsorted level:
  653:         with pytest.raises(KeyError, match=r"^2$"):
  654:             index.drop(1, level=2).get_loc_level(2, level=2)
  655: 
  656:         index = MultiIndex(
  657:             levels=[[2000], list(range(4))],
  658:             codes=[np.array([0, 0, 0, 0]), np.array([0, 1, 2, 3])],
  659:         )
  660:         result, new_index = index.get_loc_level((2000, slice(None, None)))
  661:         expected = slice(None, None)
  662:         assert result == expected
  663:         assert new_index.equals(index.droplevel(0))
  664: 
  665:     @pytest.mark.parametrize("dtype1", [int, float, bool, str])
  666:     @pytest.mark.parametrize("dtype2", [int, float, bool, str])
  667:     def test_get_loc_multiple_dtypes(self, dtype1, dtype2):
  668:         # GH 18520
  669:         levels = [np.array([0, 1]).astype(dtype1), np.array([0, 1]).astype(dtype2)]
  670:         idx = MultiIndex.from_product(levels)
  671:         assert idx.get_loc(idx[2]) == 2
  672: 
  673:     @pytest.mark.parametrize("level", [0, 1])
  674:     @pytest.mark.parametrize("dtypes", [[int, float], [float, int]])
  675:     def test_get_loc_implicit_cast(self, level, dtypes):
  676:         # GH 18818, GH 15994 : as flat index, cast int to float and vice-versa
  677:         levels = [["a", "b"], ["c", "d"]]
  678:         key = ["b", "d"]
  679:         lev_dtype, key_dtype = dtypes
  680:         levels[level] = np.array([0, 1], dtype=lev_dtype)
  681:         key[level] = key_dtype(1)
  682:         idx = MultiIndex.from_product(levels)
  683:         assert idx.get_loc(tuple(key)) == 3
  684: 
  685:     @pytest.mark.parametrize("dtype", [bool, object])
  686:     def test_get_loc_cast_bool(self, dtype):
  687:         # GH 19086 : int is casted to bool, but not vice-versa (for object dtype)
  688:         #  With bool dtype, we don't cast in either direction.
  689:         levels = [Index([False, True], dtype=dtype), np.arange(2, dtype="int64")]
  690:         idx = MultiIndex.from_product(levels)
  691: 
  692:         if dtype is bool:
  693:             with pytest.raises(KeyError, match=r"^\(0, 1\)$"):
  694:                 assert idx.get_loc((0, 1)) == 1
  695:             with pytest.raises(KeyError, match=r"^\(1, 0\)$"):
  696:                 assert idx.get_loc((1, 0)) == 2
  697:         else:
  698:             # We use python object comparisons, which treat 0 == False and 1 == True
  699:             assert idx.get_loc((0, 1)) == 1
  700:             assert idx.get_loc((1, 0)) == 2
  701: 
  702:         with pytest.raises(KeyError, match=r"^\(False, True\)$"):
  703:             idx.get_loc((False, True))
  704:         with pytest.raises(KeyError, match=r"^\(True, False\)$"):
  705:             idx.get_loc((True, False))
  706: 
  707:     @pytest.mark.parametrize("level", [0, 1])
  708:     def test_get_loc_nan(self, level, nulls_fixture):
  709:         # GH 18485 : NaN in MultiIndex
  710:         levels = [["a", "b"], ["c", "d"]]
  711:         key = ["b", "d"]
  712:         levels[level] = np.array([0, nulls_fixture], dtype=type(nulls_fixture))
  713:         key[level] = nulls_fixture
  714:         idx = MultiIndex.from_product(levels)
  715:         assert idx.get_loc(tuple(key)) == 3
  716: 
  717:     def test_get_loc_missing_nan(self):
  718:         # GH 8569
  719:         idx = MultiIndex.from_arrays([[1.0, 2.0], [3.0, 4.0]])
  720:         assert isinstance(idx.get_loc(1), slice)
  721:         with pytest.raises(KeyError, match=r"^3$"):
  722:             idx.get_loc(3)
  723:         with pytest.raises(KeyError, match=r"^nan$"):
  724:             idx.get_loc(np.nan)
  725:         with pytest.raises(InvalidIndexError, match=r"\[nan\]"):
  726:             # listlike/non-hashable raises TypeError
  727:             idx.get_loc([np.nan])
  728: 
  729:     def test_get_loc_with_values_including_missing_values(self):
  730:         # issue 19132
  731:         idx = MultiIndex.from_product([[np.nan, 1]] * 2)
  732:         expected = slice(0, 2, None)
  733:         assert idx.get_loc(np.nan) == expected
  734: 
  735:         idx = MultiIndex.from_arrays([[np.nan, 1, 2, np.nan]])
  736:         expected = np.array([True, False, False, True])
  737:         tm.assert_numpy_array_equal(idx.get_loc(np.nan), expected)
  738: 
  739:         idx = MultiIndex.from_product([[np.nan, 1]] * 3)
  740:         expected = slice(2, 4, None)
  741:         assert idx.get_loc((np.nan, 1)) == expected
  742: 
  743:     def test_get_loc_duplicates2(self):
  744:         # TODO: de-duplicate with test_get_loc_duplicates above?
  745:         index = MultiIndex(
  746:             levels=[["D", "B", "C"], [0, 26, 27, 37, 57, 67, 75, 82]],
  747:             codes=[[0, 0, 0, 1, 2, 2, 2, 2, 2, 2], [1, 3, 4, 6, 0, 2, 2, 3, 5, 7]],
  748:             names=["tag", "day"],
  749:         )
  750: 
  751:         assert index.get_loc("D") == slice(0, 3)
  752: 
  753:     def test_get_loc_past_lexsort_depth(self):
  754:         # GH#30053
  755:         idx = MultiIndex(
  756:             levels=[["a"], [0, 7], [1]],
  757:             codes=[[0, 0], [1, 0], [0, 0]],
  758:             names=["x", "y", "z"],
  759:             sortorder=0,
  760:         )
  761:         key = ("a", 7)
  762: 
  763:         with tm.assert_produces_warning(PerformanceWarning):
  764:             # PerformanceWarning: indexing past lexsort depth may impact performance
  765:             result = idx.get_loc(key)
  766: 
  767:         assert result == slice(0, 1, None)
  768: 
  769:     def test_multiindex_get_loc_list_raises(self):
  770:         # GH#35878
  771:         idx = MultiIndex.from_tuples([("a", 1), ("b", 2)])
  772:         msg = r"\[\]"
  773:         with pytest.raises(InvalidIndexError, match=msg):
  774:             idx.get_loc([])
  775: 
  776:     def test_get_loc_nested_tuple_raises_keyerror(self):
  777:         # raise KeyError, not TypeError
  778:         mi = MultiIndex.from_product([range(3), range(4), range(5), range(6)])
  779:         key = ((2, 3, 4), "foo")
  780: 
  781:         with pytest.raises(KeyError, match=re.escape(str(key))):
  782:             mi.get_loc(key)
  783: 
  784: 
  785: class TestWhere:
  786:     def test_where(self):
  787:         i = MultiIndex.from_tuples([("A", 1), ("A", 2)])
  788: 
  789:         msg = r"\.where is not supported for MultiIndex operations"
  790:         with pytest.raises(NotImplementedError, match=msg):
  791:             i.where(True)
  792: 
  793:     def test_where_array_like(self, listlike_box):
  794:         mi = MultiIndex.from_tuples([("A", 1), ("A", 2)])
  795:         cond = [False, True]
  796:         msg = r"\.where is not supported for MultiIndex operations"
  797:         with pytest.raises(NotImplementedError, match=msg):
  798:             mi.where(listlike_box(cond))
  799: 
  800: 
  801: class TestContains:
  802:     def test_contains_top_level(self):
  803:         midx = MultiIndex.from_product([["A", "B"], [1, 2]])
  804:         assert "A" in midx
  805:         assert "A" not in midx._engine
  806: 
  807:     def test_contains_with_nat(self):
  808:         # MI with a NaT
  809:         mi = MultiIndex(
  810:             levels=[["C"], date_range("2012-01-01", periods=5)],
  811:             codes=[[0, 0, 0, 0, 0, 0], [-1, 0, 1, 2, 3, 4]],
  812:             names=[None, "B"],
  813:         )
  814:         assert ("C", pd.Timestamp("2012-01-01")) in mi
  815:         for val in mi.values:
  816:             assert val in mi
  817: 
  818:     def test_contains(self, idx):
  819:         assert ("foo", "two") in idx
  820:         assert ("bar", "two") not in idx
  821:         assert None not in idx
  822: 
  823:     def test_contains_with_missing_value(self):
  824:         # GH#19132
  825:         idx = MultiIndex.from_arrays([[1, np.nan, 2]])
  826:         assert np.nan in idx
  827: 
  828:         idx = MultiIndex.from_arrays([[1, 2], [np.nan, 3]])
  829:         assert np.nan not in idx
  830:         assert (1, np.nan) in idx
  831: 
  832:     def test_multiindex_contains_dropped(self):
  833:         # GH#19027
  834:         # test that dropped MultiIndex levels are not in the MultiIndex
  835:         # despite continuing to be in the MultiIndex's levels
  836:         idx = MultiIndex.from_product([[1, 2], [3, 4]])
  837:         assert 2 in idx
  838:         idx = idx.drop(2)
  839: 
  840:         # drop implementation keeps 2 in the levels
  841:         assert 2 in idx.levels[0]
  842:         # but it should no longer be in the index itself
  843:         assert 2 not in idx
  844: 
  845:         # also applies to strings
  846:         idx = MultiIndex.from_product([["a", "b"], ["c", "d"]])
  847:         assert "a" in idx
  848:         idx = idx.drop("a")
  849:         assert "a" in idx.levels[0]
  850:         assert "a" not in idx
  851: 
  852:     def test_contains_td64_level(self):
  853:         # GH#24570
  854:         tx = pd.timedelta_range("09:30:00", "16:00:00", freq="30 min")
  855:         idx = MultiIndex.from_arrays([tx, np.arange(len(tx))])
  856:         assert tx[0] in idx
  857:         assert "element_not_exit" not in idx
  858:         assert "0 day 09:30:00" in idx
  859: 
  860:     def test_large_mi_contains(self, monkeypatch):
  861:         # GH#10645
  862:         with monkeypatch.context():
  863:             monkeypatch.setattr(libindex, "_SIZE_CUTOFF", 10)
  864:             result = MultiIndex.from_arrays([range(10), range(10)])
  865:             assert (10, 0) not in result
  866: 
  867: 
  868: def test_timestamp_multiindex_indexer():
  869:     # https://github.com/pandas-dev/pandas/issues/26944
  870:     idx = MultiIndex.from_product(
  871:         [
  872:             date_range("2019-01-01T00:15:33", periods=100, freq="h", name="date"),
  873:             ["x"],
  874:             [3],
  875:         ]
  876:     )
  877:     df = DataFrame({"foo": np.arange(len(idx))}, idx)
  878:     result = df.loc[pd.IndexSlice["2019-1-2":, "x", :], "foo"]
  879:     qidx = MultiIndex.from_product(
  880:         [
  881:             date_range(
  882:                 start="2019-01-02T00:15:33",
  883:                 end="2019-01-05T03:15:33",
  884:                 freq="h",
  885:                 name="date",
  886:             ),
  887:             ["x"],
  888:             [3],
  889:         ]
  890:     )
  891:     should_be = pd.Series(data=np.arange(24, len(qidx) + 24), index=qidx, name="foo")
  892:     tm.assert_series_equal(result, should_be)
  893: 
  894: 
  895: @pytest.mark.parametrize(
  896:     "index_arr,expected,target,algo",
  897:     [
  898:         ([[np.nan, "a", "b"], ["c", "d", "e"]], 0, np.nan, "left"),
  899:         ([[np.nan, "a", "b"], ["c", "d", "e"]], 1, (np.nan, "c"), "right"),
  900:         ([["a", "b", "c"], ["d", np.nan, "d"]], 1, ("b", np.nan), "left"),
  901:     ],
  902: )
  903: def test_get_slice_bound_with_missing_value(index_arr, expected, target, algo):
  904:     # issue 19132
  905:     idx = MultiIndex.from_arrays(index_arr)
  906:     result = idx.get_slice_bound(target, side=algo)
  907:     assert result == expected
  908: 
  909: 
  910: @pytest.mark.parametrize(
  911:     "index_arr,expected,start_idx,end_idx",
  912:     [
  913:         ([[np.nan, 1, 2], [3, 4, 5]], slice(0, 2, None), np.nan, 1),
  914:         ([[np.nan, 1, 2], [3, 4, 5]], slice(0, 3, None), np.nan, (2, 5)),
  915:         ([[1, 2, 3], [4, np.nan, 5]], slice(1, 3, None), (2, np.nan), 3),
  916:         ([[1, 2, 3], [4, np.nan, 5]], slice(1, 3, None), (2, np.nan), (3, 5)),
  917:     ],
  918: )
  919: def test_slice_indexer_with_missing_value(index_arr, expected, start_idx, end_idx):
  920:     # issue 19132
  921:     idx = MultiIndex.from_arrays(index_arr)
  922:     result = idx.slice_indexer(start=start_idx, end=end_idx)
  923:     assert result == expected
  924: 
  925: 
  926: def test_pyint_engine():
  927:     # GH#18519 : when combinations of codes cannot be represented in 64
  928:     # bits, the index underlying the MultiIndex engine works with Python
  929:     # integers, rather than uint64.
  930:     N = 5
  931:     keys = [
  932:         tuple(arr)
  933:         for arr in [
  934:             [0] * 10 * N,
  935:             [1] * 10 * N,
  936:             [2] * 10 * N,
  937:             [np.nan] * N + [2] * 9 * N,
  938:             [0] * N + [2] * 9 * N,
  939:             [np.nan] * N + [2] * 8 * N + [0] * N,
  940:         ]
  941:     ]
  942:     # Each level contains 4 elements (including NaN), so it is represented
  943:     # in 2 bits, for a total of 2*N*10 = 100 > 64 bits. If we were using a
  944:     # 64 bit engine and truncating the first levels, the fourth and fifth
  945:     # keys would collide; if truncating the last levels, the fifth and
  946:     # sixth; if rotating bits rather than shifting, the third and fifth.
  947: 
  948:     for idx, key_value in enumerate(keys):
  949:         index = MultiIndex.from_tuples(keys)
  950:         assert index.get_loc(key_value) == idx
  951: 
  952:         expected = np.arange(idx + 1, dtype=np.intp)
  953:         result = index.get_indexer([keys[i] for i in expected])
  954:         tm.assert_numpy_array_equal(result, expected)
  955: 
  956:     # With missing key:
  957:     idces = range(len(keys))
  958:     expected = np.array([-1] + list(idces), dtype=np.intp)
  959:     missing = tuple([0, 1] * 5 * N)
  960:     result = index.get_indexer([missing] + [keys[i] for i in idces])
  961:     tm.assert_numpy_array_equal(result, expected)
  962: 
  963: 
  964: @pytest.mark.parametrize(
  965:     "keys,expected",
  966:     [
  967:         ((slice(None), [5, 4]), [1, 0]),
  968:         ((slice(None), [4, 5]), [0, 1]),
  969:         (([True, False, True], [4, 6]), [0, 2]),
  970:         (([True, False, True], [6, 4]), [0, 2]),
  971:         ((2, [4, 5]), [0, 1]),
  972:         ((2, [5, 4]), [1, 0]),
  973:         (([2], [4, 5]), [0, 1]),
  974:         (([2], [5, 4]), [1, 0]),
  975:     ],
  976: )
  977: def test_get_locs_reordering(keys, expected):
  978:     # GH48384
  979:     idx = MultiIndex.from_arrays(
  980:         [
  981:             [2, 2, 1],
  982:             [4, 5, 6],
  983:         ]
  984:     )
  985:     result = idx.get_locs(keys)
  986:     expected = np.array(expected, dtype=np.intp)
  987:     tm.assert_numpy_array_equal(result, expected)
  988: 
  989: 
  990: def test_get_indexer_for_multiindex_with_nans(nulls_fixture):
  991:     # GH37222
  992:     idx1 = MultiIndex.from_product([["A"], [1.0, 2.0]], names=["id1", "id2"])
  993:     idx2 = MultiIndex.from_product([["A"], [nulls_fixture, 2.0]], names=["id1", "id2"])
  994: 
  995:     result = idx2.get_indexer(idx1)
  996:     expected = np.array([-1, 1], dtype=np.intp)
  997:     tm.assert_numpy_array_equal(result, expected)
  998: 
  999:     result = idx1.get_indexer(idx2)
 1000:     expected = np.array([-1, 1], dtype=np.intp)
 1001:     tm.assert_numpy_array_equal(result, expected)
