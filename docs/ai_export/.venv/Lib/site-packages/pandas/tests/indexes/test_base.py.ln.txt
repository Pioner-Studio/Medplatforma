    1: from collections import defaultdict
    2: from datetime import datetime
    3: from functools import partial
    4: import math
    5: import operator
    6: import re
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas.compat import IS64
   12: from pandas.errors import InvalidIndexError
   13: import pandas.util._test_decorators as td
   14: 
   15: from pandas.core.dtypes.common import (
   16:     is_any_real_numeric_dtype,
   17:     is_numeric_dtype,
   18:     is_object_dtype,
   19: )
   20: 
   21: import pandas as pd
   22: from pandas import (
   23:     CategoricalIndex,
   24:     DataFrame,
   25:     DatetimeIndex,
   26:     IntervalIndex,
   27:     PeriodIndex,
   28:     RangeIndex,
   29:     Series,
   30:     TimedeltaIndex,
   31:     date_range,
   32:     period_range,
   33:     timedelta_range,
   34: )
   35: import pandas._testing as tm
   36: from pandas.core.indexes.api import (
   37:     Index,
   38:     MultiIndex,
   39:     _get_combined_index,
   40:     ensure_index,
   41:     ensure_index_from_sequences,
   42: )
   43: 
   44: 
   45: class TestIndex:
   46:     @pytest.fixture
   47:     def simple_index(self) -> Index:
   48:         return Index(list("abcde"))
   49: 
   50:     def test_can_hold_identifiers(self, simple_index):
   51:         index = simple_index
   52:         key = index[0]
   53:         assert index._can_hold_identifiers_and_holds_name(key) is True
   54: 
   55:     @pytest.mark.parametrize("index", ["datetime"], indirect=True)
   56:     def test_new_axis(self, index):
   57:         # TODO: a bunch of scattered tests check this deprecation is enforced.
   58:         #  de-duplicate/centralize them.
   59:         with pytest.raises(ValueError, match="Multi-dimensional indexing"):
   60:             # GH#30588 multi-dimensional indexing deprecated
   61:             index[None, :]
   62: 
   63:     def test_constructor_regular(self, index):
   64:         tm.assert_contains_all(index, index)
   65: 
   66:     @pytest.mark.parametrize("index", ["string"], indirect=True)
   67:     def test_constructor_casting(self, index):
   68:         # casting
   69:         arr = np.array(index)
   70:         new_index = Index(arr)
   71:         tm.assert_contains_all(arr, new_index)
   72:         tm.assert_index_equal(index, new_index)
   73: 
   74:     @pytest.mark.parametrize("index", ["string"], indirect=True)
   75:     def test_constructor_copy(self, index, using_infer_string):
   76:         arr = np.array(index)
   77:         new_index = Index(arr, copy=True, name="name")
   78:         assert isinstance(new_index, Index)
   79:         assert new_index.name == "name"
   80:         if using_infer_string:
   81:             tm.assert_extension_array_equal(
   82:                 new_index.values, pd.array(arr, dtype="string[pyarrow_numpy]")
   83:             )
   84:         else:
   85:             tm.assert_numpy_array_equal(arr, new_index.values)
   86:         arr[0] = "SOMEBIGLONGSTRING"
   87:         assert new_index[0] != "SOMEBIGLONGSTRING"
   88: 
   89:     @pytest.mark.parametrize("cast_as_obj", [True, False])
   90:     @pytest.mark.parametrize(
   91:         "index",
   92:         [
   93:             date_range(
   94:                 "2015-01-01 10:00",
   95:                 freq="D",
   96:                 periods=3,
   97:                 tz="US/Eastern",
   98:                 name="Green Eggs & Ham",
   99:             ),  # DTI with tz
  100:             date_range("2015-01-01 10:00", freq="D", periods=3),  # DTI no tz
  101:             timedelta_range("1 days", freq="D", periods=3),  # td
  102:             period_range("2015-01-01", freq="D", periods=3),  # period
  103:         ],
  104:     )
  105:     def test_constructor_from_index_dtlike(self, cast_as_obj, index):
  106:         if cast_as_obj:
  107:             with tm.assert_produces_warning(FutureWarning, match="Dtype inference"):
  108:                 result = Index(index.astype(object))
  109:         else:
  110:             result = Index(index)
  111: 
  112:         tm.assert_index_equal(result, index)
  113: 
  114:         if isinstance(index, DatetimeIndex):
  115:             assert result.tz == index.tz
  116:             if cast_as_obj:
  117:                 # GH#23524 check that Index(dti, dtype=object) does not
  118:                 #  incorrectly raise ValueError, and that nanoseconds are not
  119:                 #  dropped
  120:                 index += pd.Timedelta(nanoseconds=50)
  121:                 result = Index(index, dtype=object)
  122:                 assert result.dtype == np.object_
  123:                 assert list(result) == list(index)
  124: 
  125:     @pytest.mark.parametrize(
  126:         "index,has_tz",
  127:         [
  128:             (
  129:                 date_range("2015-01-01 10:00", freq="D", periods=3, tz="US/Eastern"),
  130:                 True,
  131:             ),  # datetimetz
  132:             (timedelta_range("1 days", freq="D", periods=3), False),  # td
  133:             (period_range("2015-01-01", freq="D", periods=3), False),  # period
  134:         ],
  135:     )
  136:     def test_constructor_from_series_dtlike(self, index, has_tz):
  137:         result = Index(Series(index))
  138:         tm.assert_index_equal(result, index)
  139: 
  140:         if has_tz:
  141:             assert result.tz == index.tz
  142: 
  143:     def test_constructor_from_series_freq(self):
  144:         # GH 6273
  145:         # create from a series, passing a freq
  146:         dts = ["1-1-1990", "2-1-1990", "3-1-1990", "4-1-1990", "5-1-1990"]
  147:         expected = DatetimeIndex(dts, freq="MS")
  148: 
  149:         s = Series(pd.to_datetime(dts))
  150:         result = DatetimeIndex(s, freq="MS")
  151: 
  152:         tm.assert_index_equal(result, expected)
  153: 
  154:     def test_constructor_from_frame_series_freq(self, using_infer_string):
  155:         # GH 6273
  156:         # create from a series, passing a freq
  157:         dts = ["1-1-1990", "2-1-1990", "3-1-1990", "4-1-1990", "5-1-1990"]
  158:         expected = DatetimeIndex(dts, freq="MS")
  159: 
  160:         df = DataFrame(np.random.default_rng(2).random((5, 3)))
  161:         df["date"] = dts
  162:         result = DatetimeIndex(df["date"], freq="MS")
  163:         dtype = object if not using_infer_string else "string"
  164:         assert df["date"].dtype == dtype
  165:         expected.name = "date"
  166:         tm.assert_index_equal(result, expected)
  167: 
  168:         expected = Series(dts, name="date")
  169:         tm.assert_series_equal(df["date"], expected)
  170: 
  171:         # GH 6274
  172:         # infer freq of same
  173:         if not using_infer_string:
  174:             # Doesn't work with arrow strings
  175:             freq = pd.infer_freq(df["date"])
  176:             assert freq == "MS"
  177: 
  178:     def test_constructor_int_dtype_nan(self):
  179:         # see gh-15187
  180:         data = [np.nan]
  181:         expected = Index(data, dtype=np.float64)
  182:         result = Index(data, dtype="float")
  183:         tm.assert_index_equal(result, expected)
  184: 
  185:     @pytest.mark.parametrize(
  186:         "klass,dtype,na_val",
  187:         [
  188:             (Index, np.float64, np.nan),
  189:             (DatetimeIndex, "datetime64[ns]", pd.NaT),
  190:         ],
  191:     )
  192:     def test_index_ctor_infer_nan_nat(self, klass, dtype, na_val):
  193:         # GH 13467
  194:         na_list = [na_val, na_val]
  195:         expected = klass(na_list)
  196:         assert expected.dtype == dtype
  197: 
  198:         result = Index(na_list)
  199:         tm.assert_index_equal(result, expected)
  200: 
  201:         result = Index(np.array(na_list))
  202:         tm.assert_index_equal(result, expected)
  203: 
  204:     @pytest.mark.parametrize(
  205:         "vals,dtype",
  206:         [
  207:             ([1, 2, 3, 4, 5], "int"),
  208:             ([1.1, np.nan, 2.2, 3.0], "float"),
  209:             (["A", "B", "C", np.nan], "obj"),
  210:         ],
  211:     )
  212:     def test_constructor_simple_new(self, vals, dtype):
  213:         index = Index(vals, name=dtype)
  214:         result = index._simple_new(index.values, dtype)
  215:         tm.assert_index_equal(result, index)
  216: 
  217:     @pytest.mark.parametrize("attr", ["values", "asi8"])
  218:     @pytest.mark.parametrize("klass", [Index, DatetimeIndex])
  219:     def test_constructor_dtypes_datetime(self, tz_naive_fixture, attr, klass):
  220:         # Test constructing with a datetimetz dtype
  221:         # .values produces numpy datetimes, so these are considered naive
  222:         # .asi8 produces integers, so these are considered epoch timestamps
  223:         # ^the above will be true in a later version. Right now we `.view`
  224:         # the i8 values as NS_DTYPE, effectively treating them as wall times.
  225:         index = date_range("2011-01-01", periods=5)
  226:         arg = getattr(index, attr)
  227:         index = index.tz_localize(tz_naive_fixture)
  228:         dtype = index.dtype
  229: 
  230:         # As of 2.0 astype raises on dt64.astype(dt64tz)
  231:         err = tz_naive_fixture is not None
  232:         msg = "Cannot use .astype to convert from timezone-naive dtype to"
  233: 
  234:         if attr == "asi8":
  235:             result = DatetimeIndex(arg).tz_localize(tz_naive_fixture)
  236:             tm.assert_index_equal(result, index)
  237:         elif klass is Index:
  238:             with pytest.raises(TypeError, match="unexpected keyword"):
  239:                 klass(arg, tz=tz_naive_fixture)
  240:         else:
  241:             result = klass(arg, tz=tz_naive_fixture)
  242:             tm.assert_index_equal(result, index)
  243: 
  244:         if attr == "asi8":
  245:             if err:
  246:                 with pytest.raises(TypeError, match=msg):
  247:                     DatetimeIndex(arg).astype(dtype)
  248:             else:
  249:                 result = DatetimeIndex(arg).astype(dtype)
  250:                 tm.assert_index_equal(result, index)
  251:         else:
  252:             result = klass(arg, dtype=dtype)
  253:             tm.assert_index_equal(result, index)
  254: 
  255:         if attr == "asi8":
  256:             result = DatetimeIndex(list(arg)).tz_localize(tz_naive_fixture)
  257:             tm.assert_index_equal(result, index)
  258:         elif klass is Index:
  259:             with pytest.raises(TypeError, match="unexpected keyword"):
  260:                 klass(arg, tz=tz_naive_fixture)
  261:         else:
  262:             result = klass(list(arg), tz=tz_naive_fixture)
  263:             tm.assert_index_equal(result, index)
  264: 
  265:         if attr == "asi8":
  266:             if err:
  267:                 with pytest.raises(TypeError, match=msg):
  268:                     DatetimeIndex(list(arg)).astype(dtype)
  269:             else:
  270:                 result = DatetimeIndex(list(arg)).astype(dtype)
  271:                 tm.assert_index_equal(result, index)
  272:         else:
  273:             result = klass(list(arg), dtype=dtype)
  274:             tm.assert_index_equal(result, index)
  275: 
  276:     @pytest.mark.parametrize("attr", ["values", "asi8"])
  277:     @pytest.mark.parametrize("klass", [Index, TimedeltaIndex])
  278:     def test_constructor_dtypes_timedelta(self, attr, klass):
  279:         index = timedelta_range("1 days", periods=5)
  280:         index = index._with_freq(None)  # won't be preserved by constructors
  281:         dtype = index.dtype
  282: 
  283:         values = getattr(index, attr)
  284: 
  285:         result = klass(values, dtype=dtype)
  286:         tm.assert_index_equal(result, index)
  287: 
  288:         result = klass(list(values), dtype=dtype)
  289:         tm.assert_index_equal(result, index)
  290: 
  291:     @pytest.mark.parametrize("value", [[], iter([]), (_ for _ in [])])
  292:     @pytest.mark.parametrize(
  293:         "klass",
  294:         [
  295:             Index,
  296:             CategoricalIndex,
  297:             DatetimeIndex,
  298:             TimedeltaIndex,
  299:         ],
  300:     )
  301:     def test_constructor_empty(self, value, klass):
  302:         empty = klass(value)
  303:         assert isinstance(empty, klass)
  304:         assert not len(empty)
  305: 
  306:     @pytest.mark.parametrize(
  307:         "empty,klass",
  308:         [
  309:             (PeriodIndex([], freq="D"), PeriodIndex),
  310:             (PeriodIndex(iter([]), freq="D"), PeriodIndex),
  311:             (PeriodIndex((_ for _ in []), freq="D"), PeriodIndex),
  312:             (RangeIndex(step=1), RangeIndex),
  313:             (MultiIndex(levels=[[1, 2], ["blue", "red"]], codes=[[], []]), MultiIndex),
  314:         ],
  315:     )
  316:     def test_constructor_empty_special(self, empty, klass):
  317:         assert isinstance(empty, klass)
  318:         assert not len(empty)
  319: 
  320:     @pytest.mark.parametrize(
  321:         "index",
  322:         [
  323:             "datetime",
  324:             "float64",
  325:             "float32",
  326:             "int64",
  327:             "int32",
  328:             "period",
  329:             "range",
  330:             "repeats",
  331:             "timedelta",
  332:             "tuples",
  333:             "uint64",
  334:             "uint32",
  335:         ],
  336:         indirect=True,
  337:     )
  338:     def test_view_with_args(self, index):
  339:         index.view("i8")
  340: 
  341:     @pytest.mark.parametrize(
  342:         "index",
  343:         [
  344:             "string",
  345:             pytest.param("categorical", marks=pytest.mark.xfail(reason="gh-25464")),
  346:             "bool-object",
  347:             "bool-dtype",
  348:             "empty",
  349:         ],
  350:         indirect=True,
  351:     )
  352:     def test_view_with_args_object_array_raises(self, index):
  353:         if index.dtype == bool:
  354:             msg = "When changing to a larger dtype"
  355:             with pytest.raises(ValueError, match=msg):
  356:                 index.view("i8")
  357:         elif index.dtype == "string":
  358:             with pytest.raises(NotImplementedError, match="i8"):
  359:                 index.view("i8")
  360:         else:
  361:             msg = (
  362:                 "Cannot change data-type for array of references|"
  363:                 "Cannot change data-type for object array|"
  364:             )
  365:             with pytest.raises(TypeError, match=msg):
  366:                 index.view("i8")
  367: 
  368:     @pytest.mark.parametrize(
  369:         "index",
  370:         ["int64", "int32", "range"],
  371:         indirect=True,
  372:     )
  373:     def test_astype(self, index):
  374:         casted = index.astype("i8")
  375: 
  376:         # it works!
  377:         casted.get_loc(5)
  378: 
  379:         # pass on name
  380:         index.name = "foobar"
  381:         casted = index.astype("i8")
  382:         assert casted.name == "foobar"
  383: 
  384:     def test_equals_object(self):
  385:         # same
  386:         assert Index(["a", "b", "c"]).equals(Index(["a", "b", "c"]))
  387: 
  388:     @pytest.mark.parametrize(
  389:         "comp", [Index(["a", "b"]), Index(["a", "b", "d"]), ["a", "b", "c"]]
  390:     )
  391:     def test_not_equals_object(self, comp):
  392:         assert not Index(["a", "b", "c"]).equals(comp)
  393: 
  394:     def test_identical(self):
  395:         # index
  396:         i1 = Index(["a", "b", "c"])
  397:         i2 = Index(["a", "b", "c"])
  398: 
  399:         assert i1.identical(i2)
  400: 
  401:         i1 = i1.rename("foo")
  402:         assert i1.equals(i2)
  403:         assert not i1.identical(i2)
  404: 
  405:         i2 = i2.rename("foo")
  406:         assert i1.identical(i2)
  407: 
  408:         i3 = Index([("a", "a"), ("a", "b"), ("b", "a")])
  409:         i4 = Index([("a", "a"), ("a", "b"), ("b", "a")], tupleize_cols=False)
  410:         assert not i3.identical(i4)
  411: 
  412:     def test_is_(self):
  413:         ind = Index(range(10))
  414:         assert ind.is_(ind)
  415:         assert ind.is_(ind.view().view().view().view())
  416:         assert not ind.is_(Index(range(10)))
  417:         assert not ind.is_(ind.copy())
  418:         assert not ind.is_(ind.copy(deep=False))
  419:         assert not ind.is_(ind[:])
  420:         assert not ind.is_(np.array(range(10)))
  421: 
  422:         # quasi-implementation dependent
  423:         assert ind.is_(ind.view())
  424:         ind2 = ind.view()
  425:         ind2.name = "bob"
  426:         assert ind.is_(ind2)
  427:         assert ind2.is_(ind)
  428:         # doesn't matter if Indices are *actually* views of underlying data,
  429:         assert not ind.is_(Index(ind.values))
  430:         arr = np.array(range(1, 11))
  431:         ind1 = Index(arr, copy=False)
  432:         ind2 = Index(arr, copy=False)
  433:         assert not ind1.is_(ind2)
  434: 
  435:     def test_asof_numeric_vs_bool_raises(self):
  436:         left = Index([1, 2, 3])
  437:         right = Index([True, False], dtype=object)
  438: 
  439:         msg = "Cannot compare dtypes int64 and bool"
  440:         with pytest.raises(TypeError, match=msg):
  441:             left.asof(right[0])
  442:         # TODO: should right.asof(left[0]) also raise?
  443: 
  444:         with pytest.raises(InvalidIndexError, match=re.escape(str(right))):
  445:             left.asof(right)
  446: 
  447:         with pytest.raises(InvalidIndexError, match=re.escape(str(left))):
  448:             right.asof(left)
  449: 
  450:     @pytest.mark.parametrize("index", ["string"], indirect=True)
  451:     def test_booleanindex(self, index):
  452:         bool_index = np.ones(len(index), dtype=bool)
  453:         bool_index[5:30:2] = False
  454: 
  455:         sub_index = index[bool_index]
  456: 
  457:         for i, val in enumerate(sub_index):
  458:             assert sub_index.get_loc(val) == i
  459: 
  460:         sub_index = index[list(bool_index)]
  461:         for i, val in enumerate(sub_index):
  462:             assert sub_index.get_loc(val) == i
  463: 
  464:     def test_fancy(self, simple_index):
  465:         index = simple_index
  466:         sl = index[[1, 2, 3]]
  467:         for i in sl:
  468:             assert i == sl[sl.get_loc(i)]
  469: 
  470:     @pytest.mark.parametrize(
  471:         "index",
  472:         ["string", "int64", "int32", "uint64", "uint32", "float64", "float32"],
  473:         indirect=True,
  474:     )
  475:     @pytest.mark.parametrize("dtype", [int, np.bool_])
  476:     def test_empty_fancy(self, index, dtype, request, using_infer_string):
  477:         if dtype is np.bool_ and using_infer_string and index.dtype == "string":
  478:             request.applymarker(pytest.mark.xfail(reason="numpy behavior is buggy"))
  479:         empty_arr = np.array([], dtype=dtype)
  480:         empty_index = type(index)([], dtype=index.dtype)
  481: 
  482:         assert index[[]].identical(empty_index)
  483:         if dtype == np.bool_:
  484:             with tm.assert_produces_warning(FutureWarning, match="is deprecated"):
  485:                 assert index[empty_arr].identical(empty_index)
  486:         else:
  487:             assert index[empty_arr].identical(empty_index)
  488: 
  489:     @pytest.mark.parametrize(
  490:         "index",
  491:         ["string", "int64", "int32", "uint64", "uint32", "float64", "float32"],
  492:         indirect=True,
  493:     )
  494:     def test_empty_fancy_raises(self, index):
  495:         # DatetimeIndex is excluded, because it overrides getitem and should
  496:         # be tested separately.
  497:         empty_farr = np.array([], dtype=np.float64)
  498:         empty_index = type(index)([], dtype=index.dtype)
  499: 
  500:         assert index[[]].identical(empty_index)
  501:         # np.ndarray only accepts ndarray of int & bool dtypes, so should Index
  502:         msg = r"arrays used as indices must be of integer"
  503:         with pytest.raises(IndexError, match=msg):
  504:             index[empty_farr]
  505: 
  506:     def test_union_dt_as_obj(self, simple_index):
  507:         # TODO: Replace with fixturesult
  508:         index = simple_index
  509:         date_index = date_range("2019-01-01", periods=10)
  510:         first_cat = index.union(date_index)
  511:         second_cat = index.union(index)
  512: 
  513:         appended = Index(np.append(index, date_index.astype("O")))
  514: 
  515:         tm.assert_index_equal(first_cat, appended)
  516:         tm.assert_index_equal(second_cat, index)
  517:         tm.assert_contains_all(index, first_cat)
  518:         tm.assert_contains_all(index, second_cat)
  519:         tm.assert_contains_all(date_index, first_cat)
  520: 
  521:     def test_map_with_tuples(self):
  522:         # GH 12766
  523: 
  524:         # Test that returning a single tuple from an Index
  525:         #   returns an Index.
  526:         index = Index(np.arange(3), dtype=np.int64)
  527:         result = index.map(lambda x: (x,))
  528:         expected = Index([(i,) for i in index])
  529:         tm.assert_index_equal(result, expected)
  530: 
  531:         # Test that returning a tuple from a map of a single index
  532:         #   returns a MultiIndex object.
  533:         result = index.map(lambda x: (x, x == 1))
  534:         expected = MultiIndex.from_tuples([(i, i == 1) for i in index])
  535:         tm.assert_index_equal(result, expected)
  536: 
  537:     def test_map_with_tuples_mi(self):
  538:         # Test that returning a single object from a MultiIndex
  539:         #   returns an Index.
  540:         first_level = ["foo", "bar", "baz"]
  541:         multi_index = MultiIndex.from_tuples(zip(first_level, [1, 2, 3]))
  542:         reduced_index = multi_index.map(lambda x: x[0])
  543:         tm.assert_index_equal(reduced_index, Index(first_level))
  544: 
  545:     @pytest.mark.parametrize(
  546:         "index",
  547:         [
  548:             date_range("2020-01-01", freq="D", periods=10),
  549:             period_range("2020-01-01", freq="D", periods=10),
  550:             timedelta_range("1 day", periods=10),
  551:         ],
  552:     )
  553:     def test_map_tseries_indices_return_index(self, index):
  554:         expected = Index([1] * 10)
  555:         result = index.map(lambda x: 1)
  556:         tm.assert_index_equal(expected, result)
  557: 
  558:     def test_map_tseries_indices_accsr_return_index(self):
  559:         date_index = DatetimeIndex(
  560:             date_range("2020-01-01", periods=24, freq="h"), name="hourly"
  561:         )
  562:         result = date_index.map(lambda x: x.hour)
  563:         expected = Index(np.arange(24, dtype="int64"), name="hourly")
  564:         tm.assert_index_equal(result, expected, exact=True)
  565: 
  566:     @pytest.mark.parametrize(
  567:         "mapper",
  568:         [
  569:             lambda values, index: {i: e for e, i in zip(values, index)},
  570:             lambda values, index: Series(values, index),
  571:         ],
  572:     )
  573:     def test_map_dictlike_simple(self, mapper):
  574:         # GH 12756
  575:         expected = Index(["foo", "bar", "baz"])
  576:         index = Index(np.arange(3), dtype=np.int64)
  577:         result = index.map(mapper(expected.values, index))
  578:         tm.assert_index_equal(result, expected)
  579: 
  580:     @pytest.mark.parametrize(
  581:         "mapper",
  582:         [
  583:             lambda values, index: {i: e for e, i in zip(values, index)},
  584:             lambda values, index: Series(values, index),
  585:         ],
  586:     )
  587:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  588:     def test_map_dictlike(self, index, mapper, request):
  589:         # GH 12756
  590:         if isinstance(index, CategoricalIndex):
  591:             pytest.skip("Tested in test_categorical")
  592:         elif not index.is_unique:
  593:             pytest.skip("Cannot map duplicated index")
  594: 
  595:         rng = np.arange(len(index), 0, -1, dtype=np.int64)
  596: 
  597:         if index.empty:
  598:             # to match proper result coercion for uints
  599:             expected = Index([])
  600:         elif is_numeric_dtype(index.dtype):
  601:             expected = index._constructor(rng, dtype=index.dtype)
  602:         elif type(index) is Index and index.dtype != object:
  603:             # i.e. EA-backed, for now just Nullable
  604:             expected = Index(rng, dtype=index.dtype)
  605:         else:
  606:             expected = Index(rng)
  607: 
  608:         result = index.map(mapper(expected, index))
  609:         tm.assert_index_equal(result, expected)
  610: 
  611:     @pytest.mark.parametrize(
  612:         "mapper",
  613:         [Series(["foo", 2.0, "baz"], index=[0, 2, -1]), {0: "foo", 2: 2.0, -1: "baz"}],
  614:     )
  615:     def test_map_with_non_function_missing_values(self, mapper):
  616:         # GH 12756
  617:         expected = Index([2.0, np.nan, "foo"])
  618:         result = Index([2, 1, 0]).map(mapper)
  619: 
  620:         tm.assert_index_equal(expected, result)
  621: 
  622:     def test_map_na_exclusion(self):
  623:         index = Index([1.5, np.nan, 3, np.nan, 5])
  624: 
  625:         result = index.map(lambda x: x * 2, na_action="ignore")
  626:         expected = index * 2
  627:         tm.assert_index_equal(result, expected)
  628: 
  629:     def test_map_defaultdict(self):
  630:         index = Index([1, 2, 3])
  631:         default_dict = defaultdict(lambda: "blank")
  632:         default_dict[1] = "stuff"
  633:         result = index.map(default_dict)
  634:         expected = Index(["stuff", "blank", "blank"])
  635:         tm.assert_index_equal(result, expected)
  636: 
  637:     @pytest.mark.parametrize("name,expected", [("foo", "foo"), ("bar", None)])
  638:     def test_append_empty_preserve_name(self, name, expected):
  639:         left = Index([], name="foo")
  640:         right = Index([1, 2, 3], name=name)
  641: 
  642:         msg = "The behavior of array concatenation with empty entries is deprecated"
  643:         with tm.assert_produces_warning(FutureWarning, match=msg):
  644:             result = left.append(right)
  645:         assert result.name == expected
  646: 
  647:     @pytest.mark.parametrize(
  648:         "index, expected",
  649:         [
  650:             ("string", False),
  651:             ("bool-object", False),
  652:             ("bool-dtype", False),
  653:             ("categorical", False),
  654:             ("int64", True),
  655:             ("int32", True),
  656:             ("uint64", True),
  657:             ("uint32", True),
  658:             ("datetime", False),
  659:             ("float64", True),
  660:             ("float32", True),
  661:         ],
  662:         indirect=["index"],
  663:     )
  664:     def test_is_numeric(self, index, expected):
  665:         assert is_any_real_numeric_dtype(index) is expected
  666: 
  667:     @pytest.mark.parametrize(
  668:         "index, expected",
  669:         [
  670:             ("string", True),
  671:             ("bool-object", True),
  672:             ("bool-dtype", False),
  673:             ("categorical", False),
  674:             ("int64", False),
  675:             ("int32", False),
  676:             ("uint64", False),
  677:             ("uint32", False),
  678:             ("datetime", False),
  679:             ("float64", False),
  680:             ("float32", False),
  681:         ],
  682:         indirect=["index"],
  683:     )
  684:     def test_is_object(self, index, expected, using_infer_string):
  685:         if using_infer_string and index.dtype == "string" and expected:
  686:             expected = False
  687:         assert is_object_dtype(index) is expected
  688: 
  689:     def test_summary(self, index):
  690:         index._summary()
  691: 
  692:     def test_format_bug(self):
  693:         # GH 14626
  694:         # windows has different precision on datetime.datetime.now (it doesn't
  695:         # include us since the default for Timestamp shows these but Index
  696:         # formatting does not we are skipping)
  697:         now = datetime.now()
  698:         msg = r"Index\.format is deprecated"
  699: 
  700:         if not str(now).endswith("000"):
  701:             index = Index([now])
  702:             with tm.assert_produces_warning(FutureWarning, match=msg):
  703:                 formatted = index.format()
  704:             expected = [str(index[0])]
  705:             assert formatted == expected
  706: 
  707:         with tm.assert_produces_warning(FutureWarning, match=msg):
  708:             Index([]).format()
  709: 
  710:     @pytest.mark.parametrize("vals", [[1, 2.0 + 3.0j, 4.0], ["a", "b", "c"]])
  711:     def test_format_missing(self, vals, nulls_fixture):
  712:         # 2845
  713:         vals = list(vals)  # Copy for each iteration
  714:         vals.append(nulls_fixture)
  715:         index = Index(vals, dtype=object)
  716:         # TODO: case with complex dtype?
  717: 
  718:         msg = r"Index\.format is deprecated"
  719:         with tm.assert_produces_warning(FutureWarning, match=msg):
  720:             formatted = index.format()
  721:         null_repr = "NaN" if isinstance(nulls_fixture, float) else str(nulls_fixture)
  722:         expected = [str(index[0]), str(index[1]), str(index[2]), null_repr]
  723: 
  724:         assert formatted == expected
  725:         assert index[3] is nulls_fixture
  726: 
  727:     @pytest.mark.parametrize("op", ["any", "all"])
  728:     def test_logical_compat(self, op, simple_index):
  729:         index = simple_index
  730:         left = getattr(index, op)()
  731:         assert left == getattr(index.values, op)()
  732:         right = getattr(index.to_series(), op)()
  733:         # left might not match right exactly in e.g. string cases where the
  734:         # because we use np.any/all instead of .any/all
  735:         assert bool(left) == bool(right)
  736: 
  737:     @pytest.mark.parametrize(
  738:         "index", ["string", "int64", "int32", "float64", "float32"], indirect=True
  739:     )
  740:     def test_drop_by_str_label(self, index):
  741:         n = len(index)
  742:         drop = index[list(range(5, 10))]
  743:         dropped = index.drop(drop)
  744: 
  745:         expected = index[list(range(5)) + list(range(10, n))]
  746:         tm.assert_index_equal(dropped, expected)
  747: 
  748:         dropped = index.drop(index[0])
  749:         expected = index[1:]
  750:         tm.assert_index_equal(dropped, expected)
  751: 
  752:     @pytest.mark.parametrize(
  753:         "index", ["string", "int64", "int32", "float64", "float32"], indirect=True
  754:     )
  755:     @pytest.mark.parametrize("keys", [["foo", "bar"], ["1", "bar"]])
  756:     def test_drop_by_str_label_raises_missing_keys(self, index, keys):
  757:         with pytest.raises(KeyError, match=""):
  758:             index.drop(keys)
  759: 
  760:     @pytest.mark.parametrize(
  761:         "index", ["string", "int64", "int32", "float64", "float32"], indirect=True
  762:     )
  763:     def test_drop_by_str_label_errors_ignore(self, index):
  764:         n = len(index)
  765:         drop = index[list(range(5, 10))]
  766:         mixed = drop.tolist() + ["foo"]
  767:         dropped = index.drop(mixed, errors="ignore")
  768: 
  769:         expected = index[list(range(5)) + list(range(10, n))]
  770:         tm.assert_index_equal(dropped, expected)
  771: 
  772:         dropped = index.drop(["foo", "bar"], errors="ignore")
  773:         expected = index[list(range(n))]
  774:         tm.assert_index_equal(dropped, expected)
  775: 
  776:     def test_drop_by_numeric_label_loc(self):
  777:         # TODO: Parametrize numeric and str tests after self.strIndex fixture
  778:         index = Index([1, 2, 3])
  779:         dropped = index.drop(1)
  780:         expected = Index([2, 3])
  781: 
  782:         tm.assert_index_equal(dropped, expected)
  783: 
  784:     def test_drop_by_numeric_label_raises_missing_keys(self):
  785:         index = Index([1, 2, 3])
  786:         with pytest.raises(KeyError, match=""):
  787:             index.drop([3, 4])
  788: 
  789:     @pytest.mark.parametrize(
  790:         "key,expected", [(4, Index([1, 2, 3])), ([3, 4, 5], Index([1, 2]))]
  791:     )
  792:     def test_drop_by_numeric_label_errors_ignore(self, key, expected):
  793:         index = Index([1, 2, 3])
  794:         dropped = index.drop(key, errors="ignore")
  795: 
  796:         tm.assert_index_equal(dropped, expected)
  797: 
  798:     @pytest.mark.parametrize(
  799:         "values",
  800:         [["a", "b", ("c", "d")], ["a", ("c", "d"), "b"], [("c", "d"), "a", "b"]],
  801:     )
  802:     @pytest.mark.parametrize("to_drop", [[("c", "d"), "a"], ["a", ("c", "d")]])
  803:     def test_drop_tuple(self, values, to_drop):
  804:         # GH 18304
  805:         index = Index(values)
  806:         expected = Index(["b"], dtype=object)
  807: 
  808:         result = index.drop(to_drop)
  809:         tm.assert_index_equal(result, expected)
  810: 
  811:         removed = index.drop(to_drop[0])
  812:         for drop_me in to_drop[1], [to_drop[1]]:
  813:             result = removed.drop(drop_me)
  814:             tm.assert_index_equal(result, expected)
  815: 
  816:         removed = index.drop(to_drop[1])
  817:         msg = rf"\"\[{re.escape(to_drop[1].__repr__())}\] not found in axis\""
  818:         for drop_me in to_drop[1], [to_drop[1]]:
  819:             with pytest.raises(KeyError, match=msg):
  820:                 removed.drop(drop_me)
  821: 
  822:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  823:     def test_drop_with_duplicates_in_index(self, index):
  824:         # GH38051
  825:         if len(index) == 0 or isinstance(index, MultiIndex):
  826:             pytest.skip("Test doesn't make sense for empty MultiIndex")
  827:         if isinstance(index, IntervalIndex) and not IS64:
  828:             pytest.skip("Cannot test IntervalIndex with int64 dtype on 32 bit platform")
  829:         index = index.unique().repeat(2)
  830:         expected = index[2:]
  831:         result = index.drop(index[0])
  832:         tm.assert_index_equal(result, expected)
  833: 
  834:     @pytest.mark.parametrize(
  835:         "attr",
  836:         [
  837:             "is_monotonic_increasing",
  838:             "is_monotonic_decreasing",
  839:             "_is_strictly_monotonic_increasing",
  840:             "_is_strictly_monotonic_decreasing",
  841:         ],
  842:     )
  843:     def test_is_monotonic_incomparable(self, attr):
  844:         index = Index([5, datetime.now(), 7])
  845:         assert not getattr(index, attr)
  846: 
  847:     @pytest.mark.parametrize("values", [["foo", "bar", "quux"], {"foo", "bar", "quux"}])
  848:     @pytest.mark.parametrize(
  849:         "index,expected",
  850:         [
  851:             (Index(["qux", "baz", "foo", "bar"]), np.array([False, False, True, True])),
  852:             (Index([]), np.array([], dtype=bool)),  # empty
  853:         ],
  854:     )
  855:     def test_isin(self, values, index, expected):
  856:         result = index.isin(values)
  857:         tm.assert_numpy_array_equal(result, expected)
  858: 
  859:     def test_isin_nan_common_object(
  860:         self, nulls_fixture, nulls_fixture2, using_infer_string
  861:     ):
  862:         # Test cartesian product of null fixtures and ensure that we don't
  863:         # mangle the various types (save a corner case with PyPy)
  864:         idx = Index(["a", nulls_fixture])
  865: 
  866:         # all nans are the same
  867:         if (
  868:             isinstance(nulls_fixture, float)
  869:             and isinstance(nulls_fixture2, float)
  870:             and math.isnan(nulls_fixture)
  871:             and math.isnan(nulls_fixture2)
  872:         ):
  873:             tm.assert_numpy_array_equal(
  874:                 idx.isin([nulls_fixture2]),
  875:                 np.array([False, True]),
  876:             )
  877: 
  878:         elif nulls_fixture is nulls_fixture2:  # should preserve NA type
  879:             tm.assert_numpy_array_equal(
  880:                 idx.isin([nulls_fixture2]),
  881:                 np.array([False, True]),
  882:             )
  883: 
  884:         elif using_infer_string and idx.dtype == "string":
  885:             tm.assert_numpy_array_equal(
  886:                 idx.isin([nulls_fixture2]),
  887:                 np.array([False, True]),
  888:             )
  889: 
  890:         else:
  891:             tm.assert_numpy_array_equal(
  892:                 idx.isin([nulls_fixture2]),
  893:                 np.array([False, False]),
  894:             )
  895: 
  896:     def test_isin_nan_common_float64(self, nulls_fixture, float_numpy_dtype):
  897:         dtype = float_numpy_dtype
  898: 
  899:         if nulls_fixture is pd.NaT or nulls_fixture is pd.NA:
  900:             # Check 1) that we cannot construct a float64 Index with this value
  901:             #  and 2) that with an NaN we do not have .isin(nulls_fixture)
  902:             msg = (
  903:                 r"float\(\) argument must be a string or a (real )?number, "
  904:                 f"not {repr(type(nulls_fixture).__name__)}"
  905:             )
  906:             with pytest.raises(TypeError, match=msg):
  907:                 Index([1.0, nulls_fixture], dtype=dtype)
  908: 
  909:             idx = Index([1.0, np.nan], dtype=dtype)
  910:             assert not idx.isin([nulls_fixture]).any()
  911:             return
  912: 
  913:         idx = Index([1.0, nulls_fixture], dtype=dtype)
  914:         res = idx.isin([np.nan])
  915:         tm.assert_numpy_array_equal(res, np.array([False, True]))
  916: 
  917:         # we cannot compare NaT with NaN
  918:         res = idx.isin([pd.NaT])
  919:         tm.assert_numpy_array_equal(res, np.array([False, False]))
  920: 
  921:     @pytest.mark.parametrize("level", [0, -1])
  922:     @pytest.mark.parametrize(
  923:         "index",
  924:         [
  925:             Index(["qux", "baz", "foo", "bar"]),
  926:             Index([1.0, 2.0, 3.0, 4.0], dtype=np.float64),
  927:         ],
  928:     )
  929:     def test_isin_level_kwarg(self, level, index):
  930:         values = index.tolist()[-2:] + ["nonexisting"]
  931: 
  932:         expected = np.array([False, False, True, True])
  933:         tm.assert_numpy_array_equal(expected, index.isin(values, level=level))
  934: 
  935:         index.name = "foobar"
  936:         tm.assert_numpy_array_equal(expected, index.isin(values, level="foobar"))
  937: 
  938:     def test_isin_level_kwarg_bad_level_raises(self, index):
  939:         for level in [10, index.nlevels, -(index.nlevels + 1)]:
  940:             with pytest.raises(IndexError, match="Too many levels"):
  941:                 index.isin([], level=level)
  942: 
  943:     @pytest.mark.parametrize("label", [1.0, "foobar", "xyzzy", np.nan])
  944:     def test_isin_level_kwarg_bad_label_raises(self, label, index):
  945:         if isinstance(index, MultiIndex):
  946:             index = index.rename(["foo", "bar"] + index.names[2:])
  947:             msg = f"'Level {label} not found'"
  948:         else:
  949:             index = index.rename("foo")
  950:             msg = rf"Requested level \({label}\) does not match index name \(foo\)"
  951:         with pytest.raises(KeyError, match=msg):
  952:             index.isin([], level=label)
  953: 
  954:     @pytest.mark.parametrize("empty", [[], Series(dtype=object), np.array([])])
  955:     def test_isin_empty(self, empty):
  956:         # see gh-16991
  957:         index = Index(["a", "b"])
  958:         expected = np.array([False, False])
  959: 
  960:         result = index.isin(empty)
  961:         tm.assert_numpy_array_equal(expected, result)
  962: 
  963:     @td.skip_if_no("pyarrow")
  964:     def test_isin_arrow_string_null(self):
  965:         # GH#55821
  966:         index = Index(["a", "b"], dtype="string[pyarrow_numpy]")
  967:         result = index.isin([None])
  968:         expected = np.array([False, False])
  969:         tm.assert_numpy_array_equal(result, expected)
  970: 
  971:     @pytest.mark.parametrize(
  972:         "values",
  973:         [
  974:             [1, 2, 3, 4],
  975:             [1.0, 2.0, 3.0, 4.0],
  976:             [True, True, True, True],
  977:             ["foo", "bar", "baz", "qux"],
  978:             date_range("2018-01-01", freq="D", periods=4),
  979:         ],
  980:     )
  981:     def test_boolean_cmp(self, values):
  982:         index = Index(values)
  983:         result = index == values
  984:         expected = np.array([True, True, True, True], dtype=bool)
  985: 
  986:         tm.assert_numpy_array_equal(result, expected)
  987: 
  988:     @pytest.mark.parametrize("index", ["string"], indirect=True)
  989:     @pytest.mark.parametrize("name,level", [(None, 0), ("a", "a")])
  990:     def test_get_level_values(self, index, name, level):
  991:         expected = index.copy()
  992:         if name:
  993:             expected.name = name
  994: 
  995:         result = expected.get_level_values(level)
  996:         tm.assert_index_equal(result, expected)
  997: 
  998:     def test_slice_keep_name(self):
  999:         index = Index(["a", "b"], name="asdf")
 1000:         assert index.name == index[1:].name
 1001: 
 1002:     @pytest.mark.parametrize(
 1003:         "index",
 1004:         [
 1005:             "string",
 1006:             "datetime",
 1007:             "int64",
 1008:             "int32",
 1009:             "uint64",
 1010:             "uint32",
 1011:             "float64",
 1012:             "float32",
 1013:         ],
 1014:         indirect=True,
 1015:     )
 1016:     def test_join_self(self, index, join_type):
 1017:         result = index.join(index, how=join_type)
 1018:         expected = index
 1019:         if join_type == "outer":
 1020:             expected = expected.sort_values()
 1021:         tm.assert_index_equal(result, expected)
 1022: 
 1023:     @pytest.mark.parametrize("method", ["strip", "rstrip", "lstrip"])
 1024:     def test_str_attribute(self, method):
 1025:         # GH9068
 1026:         index = Index([" jack", "jill ", " jesse ", "frank"])
 1027:         expected = Index([getattr(str, method)(x) for x in index.values])
 1028: 
 1029:         result = getattr(index.str, method)()
 1030:         tm.assert_index_equal(result, expected)
 1031: 
 1032:     @pytest.mark.parametrize(
 1033:         "index",
 1034:         [
 1035:             Index(range(5)),
 1036:             date_range("2020-01-01", periods=10),
 1037:             MultiIndex.from_tuples([("foo", "1"), ("bar", "3")]),
 1038:             period_range(start="2000", end="2010", freq="Y"),
 1039:         ],
 1040:     )
 1041:     def test_str_attribute_raises(self, index):
 1042:         with pytest.raises(AttributeError, match="only use .str accessor"):
 1043:             index.str.repeat(2)
 1044: 
 1045:     @pytest.mark.parametrize(
 1046:         "expand,expected",
 1047:         [
 1048:             (None, Index([["a", "b", "c"], ["d", "e"], ["f"]])),
 1049:             (False, Index([["a", "b", "c"], ["d", "e"], ["f"]])),
 1050:             (
 1051:                 True,
 1052:                 MultiIndex.from_tuples(
 1053:                     [("a", "b", "c"), ("d", "e", np.nan), ("f", np.nan, np.nan)]
 1054:                 ),
 1055:             ),
 1056:         ],
 1057:     )
 1058:     def test_str_split(self, expand, expected):
 1059:         index = Index(["a b c", "d e", "f"])
 1060:         if expand is not None:
 1061:             result = index.str.split(expand=expand)
 1062:         else:
 1063:             result = index.str.split()
 1064: 
 1065:         tm.assert_index_equal(result, expected)
 1066: 
 1067:     def test_str_bool_return(self):
 1068:         # test boolean case, should return np.array instead of boolean Index
 1069:         index = Index(["a1", "a2", "b1", "b2"])
 1070:         result = index.str.startswith("a")
 1071:         expected = np.array([True, True, False, False])
 1072: 
 1073:         tm.assert_numpy_array_equal(result, expected)
 1074:         assert isinstance(result, np.ndarray)
 1075: 
 1076:     def test_str_bool_series_indexing(self):
 1077:         index = Index(["a1", "a2", "b1", "b2"])
 1078:         s = Series(range(4), index=index)
 1079: 
 1080:         result = s[s.index.str.startswith("a")]
 1081:         expected = Series(range(2), index=["a1", "a2"])
 1082:         tm.assert_series_equal(result, expected)
 1083: 
 1084:     @pytest.mark.parametrize(
 1085:         "index,expected", [(Index(list("abcd")), True), (Index(range(4)), False)]
 1086:     )
 1087:     def test_tab_completion(self, index, expected):
 1088:         # GH 9910
 1089:         result = "str" in dir(index)
 1090:         assert result == expected
 1091: 
 1092:     def test_indexing_doesnt_change_class(self):
 1093:         index = Index([1, 2, 3, "a", "b", "c"])
 1094: 
 1095:         assert index[1:3].identical(Index([2, 3], dtype=np.object_))
 1096:         assert index[[0, 1]].identical(Index([1, 2], dtype=np.object_))
 1097: 
 1098:     def test_outer_join_sort(self):
 1099:         left_index = Index(np.random.default_rng(2).permutation(15))
 1100:         right_index = date_range("2020-01-01", periods=10)
 1101: 
 1102:         with tm.assert_produces_warning(RuntimeWarning):
 1103:             result = left_index.join(right_index, how="outer")
 1104: 
 1105:         with tm.assert_produces_warning(RuntimeWarning):
 1106:             expected = left_index.astype(object).union(right_index.astype(object))
 1107: 
 1108:         tm.assert_index_equal(result, expected)
 1109: 
 1110:     def test_take_fill_value(self):
 1111:         # GH 12631
 1112:         index = Index(list("ABC"), name="xxx")
 1113:         result = index.take(np.array([1, 0, -1]))
 1114:         expected = Index(list("BAC"), name="xxx")
 1115:         tm.assert_index_equal(result, expected)
 1116: 
 1117:         # fill_value
 1118:         result = index.take(np.array([1, 0, -1]), fill_value=True)
 1119:         expected = Index(["B", "A", np.nan], name="xxx")
 1120:         tm.assert_index_equal(result, expected)
 1121: 
 1122:         # allow_fill=False
 1123:         result = index.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
 1124:         expected = Index(["B", "A", "C"], name="xxx")
 1125:         tm.assert_index_equal(result, expected)
 1126: 
 1127:     def test_take_fill_value_none_raises(self):
 1128:         index = Index(list("ABC"), name="xxx")
 1129:         msg = (
 1130:             "When allow_fill=True and fill_value is not None, "
 1131:             "all indices must be >= -1"
 1132:         )
 1133: 
 1134:         with pytest.raises(ValueError, match=msg):
 1135:             index.take(np.array([1, 0, -2]), fill_value=True)
 1136:         with pytest.raises(ValueError, match=msg):
 1137:             index.take(np.array([1, 0, -5]), fill_value=True)
 1138: 
 1139:     def test_take_bad_bounds_raises(self):
 1140:         index = Index(list("ABC"), name="xxx")
 1141:         with pytest.raises(IndexError, match="out of bounds"):
 1142:             index.take(np.array([1, -5]))
 1143: 
 1144:     @pytest.mark.parametrize("name", [None, "foobar"])
 1145:     @pytest.mark.parametrize(
 1146:         "labels",
 1147:         [
 1148:             [],
 1149:             np.array([]),
 1150:             ["A", "B", "C"],
 1151:             ["C", "B", "A"],
 1152:             np.array(["A", "B", "C"]),
 1153:             np.array(["C", "B", "A"]),
 1154:             # Must preserve name even if dtype changes
 1155:             date_range("20130101", periods=3).values,
 1156:             date_range("20130101", periods=3).tolist(),
 1157:         ],
 1158:     )
 1159:     def test_reindex_preserves_name_if_target_is_list_or_ndarray(self, name, labels):
 1160:         # GH6552
 1161:         index = Index([0, 1, 2])
 1162:         index.name = name
 1163:         assert index.reindex(labels)[0].name == name
 1164: 
 1165:     @pytest.mark.parametrize("labels", [[], np.array([]), np.array([], dtype=np.int64)])
 1166:     def test_reindex_preserves_type_if_target_is_empty_list_or_array(self, labels):
 1167:         # GH7774
 1168:         index = Index(list("abc"))
 1169:         assert index.reindex(labels)[0].dtype.type == index.dtype.type
 1170: 
 1171:     @pytest.mark.parametrize(
 1172:         "labels,dtype",
 1173:         [
 1174:             (DatetimeIndex([]), np.datetime64),
 1175:         ],
 1176:     )
 1177:     def test_reindex_doesnt_preserve_type_if_target_is_empty_index(self, labels, dtype):
 1178:         # GH7774
 1179:         index = Index(list("abc"))
 1180:         assert index.reindex(labels)[0].dtype.type == dtype
 1181: 
 1182:     def test_reindex_doesnt_preserve_type_if_target_is_empty_index_numeric(
 1183:         self, any_real_numpy_dtype
 1184:     ):
 1185:         # GH7774
 1186:         dtype = any_real_numpy_dtype
 1187:         index = Index(list("abc"))
 1188:         labels = Index([], dtype=dtype)
 1189:         assert index.reindex(labels)[0].dtype == dtype
 1190: 
 1191:     def test_reindex_no_type_preserve_target_empty_mi(self):
 1192:         index = Index(list("abc"))
 1193:         result = index.reindex(
 1194:             MultiIndex([Index([], np.int64), Index([], np.float64)], [[], []])
 1195:         )[0]
 1196:         assert result.levels[0].dtype.type == np.int64
 1197:         assert result.levels[1].dtype.type == np.float64
 1198: 
 1199:     def test_reindex_ignoring_level(self):
 1200:         # GH#35132
 1201:         idx = Index([1, 2, 3], name="x")
 1202:         idx2 = Index([1, 2, 3, 4], name="x")
 1203:         expected = Index([1, 2, 3, 4], name="x")
 1204:         result, _ = idx.reindex(idx2, level="x")
 1205:         tm.assert_index_equal(result, expected)
 1206: 
 1207:     def test_groupby(self):
 1208:         index = Index(range(5))
 1209:         result = index.groupby(np.array([1, 1, 2, 2, 2]))
 1210:         expected = {1: Index([0, 1]), 2: Index([2, 3, 4])}
 1211: 
 1212:         tm.assert_dict_equal(result, expected)
 1213: 
 1214:     @pytest.mark.parametrize(
 1215:         "mi,expected",
 1216:         [
 1217:             (MultiIndex.from_tuples([(1, 2), (4, 5)]), np.array([True, True])),
 1218:             (MultiIndex.from_tuples([(1, 2), (4, 6)]), np.array([True, False])),
 1219:         ],
 1220:     )
 1221:     def test_equals_op_multiindex(self, mi, expected):
 1222:         # GH9785
 1223:         # test comparisons of multiindex
 1224:         df = DataFrame(
 1225:             [3, 6],
 1226:             columns=["c"],
 1227:             index=MultiIndex.from_arrays([[1, 4], [2, 5]], names=["a", "b"]),
 1228:         )
 1229: 
 1230:         result = df.index == mi
 1231:         tm.assert_numpy_array_equal(result, expected)
 1232: 
 1233:     def test_equals_op_multiindex_identify(self):
 1234:         df = DataFrame(
 1235:             [3, 6],
 1236:             columns=["c"],
 1237:             index=MultiIndex.from_arrays([[1, 4], [2, 5]], names=["a", "b"]),
 1238:         )
 1239: 
 1240:         result = df.index == df.index
 1241:         expected = np.array([True, True])
 1242:         tm.assert_numpy_array_equal(result, expected)
 1243: 
 1244:     @pytest.mark.parametrize(
 1245:         "index",
 1246:         [
 1247:             MultiIndex.from_tuples([(1, 2), (4, 5), (8, 9)]),
 1248:             Index(["foo", "bar", "baz"]),
 1249:         ],
 1250:     )
 1251:     def test_equals_op_mismatched_multiindex_raises(self, index):
 1252:         df = DataFrame(
 1253:             [3, 6],
 1254:             columns=["c"],
 1255:             index=MultiIndex.from_arrays([[1, 4], [2, 5]], names=["a", "b"]),
 1256:         )
 1257: 
 1258:         with pytest.raises(ValueError, match="Lengths must match"):
 1259:             df.index == index
 1260: 
 1261:     def test_equals_op_index_vs_mi_same_length(self, using_infer_string):
 1262:         mi = MultiIndex.from_tuples([(1, 2), (4, 5), (8, 9)])
 1263:         index = Index(["foo", "bar", "baz"])
 1264: 
 1265:         result = mi == index
 1266:         expected = np.array([False, False, False])
 1267:         tm.assert_numpy_array_equal(result, expected)
 1268: 
 1269:     @pytest.mark.parametrize(
 1270:         "dt_conv, arg",
 1271:         [
 1272:             (pd.to_datetime, ["2000-01-01", "2000-01-02"]),
 1273:             (pd.to_timedelta, ["01:02:03", "01:02:04"]),
 1274:         ],
 1275:     )
 1276:     def test_dt_conversion_preserves_name(self, dt_conv, arg):
 1277:         # GH 10875
 1278:         index = Index(arg, name="label")
 1279:         assert index.name == dt_conv(index).name
 1280: 
 1281:     def test_cached_properties_not_settable(self):
 1282:         index = Index([1, 2, 3])
 1283:         with pytest.raises(AttributeError, match="Can't set attribute"):
 1284:             index.is_unique = False
 1285: 
 1286:     def test_tab_complete_warning(self, ip):
 1287:         # https://github.com/pandas-dev/pandas/issues/16409
 1288:         pytest.importorskip("IPython", minversion="6.0.0")
 1289:         from IPython.core.completer import provisionalcompleter
 1290: 
 1291:         code = "import pandas as pd; idx = pd.Index([1, 2])"
 1292:         ip.run_cell(code)
 1293: 
 1294:         # GH 31324 newer jedi version raises Deprecation warning;
 1295:         #  appears resolved 2021-02-02
 1296:         with tm.assert_produces_warning(None, raise_on_extra_warnings=False):
 1297:             with provisionalcompleter("ignore"):
 1298:                 list(ip.Completer.completions("idx.", 4))
 1299: 
 1300:     def test_contains_method_removed(self, index):
 1301:         # GH#30103 method removed for all types except IntervalIndex
 1302:         if isinstance(index, IntervalIndex):
 1303:             index.contains(1)
 1304:         else:
 1305:             msg = f"'{type(index).__name__}' object has no attribute 'contains'"
 1306:             with pytest.raises(AttributeError, match=msg):
 1307:                 index.contains(1)
 1308: 
 1309:     def test_sortlevel(self):
 1310:         index = Index([5, 4, 3, 2, 1])
 1311:         with pytest.raises(Exception, match="ascending must be a single bool value or"):
 1312:             index.sortlevel(ascending="True")
 1313: 
 1314:         with pytest.raises(
 1315:             Exception, match="ascending must be a list of bool values of length 1"
 1316:         ):
 1317:             index.sortlevel(ascending=[True, True])
 1318: 
 1319:         with pytest.raises(Exception, match="ascending must be a bool value"):
 1320:             index.sortlevel(ascending=["True"])
 1321: 
 1322:         expected = Index([1, 2, 3, 4, 5])
 1323:         result = index.sortlevel(ascending=[True])
 1324:         tm.assert_index_equal(result[0], expected)
 1325: 
 1326:         expected = Index([1, 2, 3, 4, 5])
 1327:         result = index.sortlevel(ascending=True)
 1328:         tm.assert_index_equal(result[0], expected)
 1329: 
 1330:         expected = Index([5, 4, 3, 2, 1])
 1331:         result = index.sortlevel(ascending=False)
 1332:         tm.assert_index_equal(result[0], expected)
 1333: 
 1334:     def test_sortlevel_na_position(self):
 1335:         # GH#51612
 1336:         idx = Index([1, np.nan])
 1337:         result = idx.sortlevel(na_position="first")[0]
 1338:         expected = Index([np.nan, 1])
 1339:         tm.assert_index_equal(result, expected)
 1340: 
 1341:     @pytest.mark.parametrize(
 1342:         "periods, expected_results",
 1343:         [
 1344:             (1, [np.nan, 10, 10, 10, 10]),
 1345:             (2, [np.nan, np.nan, 20, 20, 20]),
 1346:             (3, [np.nan, np.nan, np.nan, 30, 30]),
 1347:         ],
 1348:     )
 1349:     def test_index_diff(self, periods, expected_results):
 1350:         # GH#19708
 1351:         idx = Index([10, 20, 30, 40, 50])
 1352:         result = idx.diff(periods)
 1353:         expected = Index(expected_results)
 1354: 
 1355:         tm.assert_index_equal(result, expected)
 1356: 
 1357:     @pytest.mark.parametrize(
 1358:         "decimals, expected_results",
 1359:         [
 1360:             (0, [1.0, 2.0, 3.0]),
 1361:             (1, [1.2, 2.3, 3.5]),
 1362:             (2, [1.23, 2.35, 3.46]),
 1363:         ],
 1364:     )
 1365:     def test_index_round(self, decimals, expected_results):
 1366:         # GH#19708
 1367:         idx = Index([1.234, 2.345, 3.456])
 1368:         result = idx.round(decimals)
 1369:         expected = Index(expected_results)
 1370: 
 1371:         tm.assert_index_equal(result, expected)
 1372: 
 1373: 
 1374: class TestMixedIntIndex:
 1375:     # Mostly the tests from common.py for which the results differ
 1376:     # in py2 and py3 because ints and strings are uncomparable in py3
 1377:     # (GH 13514)
 1378:     @pytest.fixture
 1379:     def simple_index(self) -> Index:
 1380:         return Index([0, "a", 1, "b", 2, "c"])
 1381: 
 1382:     def test_argsort(self, simple_index):
 1383:         index = simple_index
 1384:         with pytest.raises(TypeError, match="'>|<' not supported"):
 1385:             index.argsort()
 1386: 
 1387:     def test_numpy_argsort(self, simple_index):
 1388:         index = simple_index
 1389:         with pytest.raises(TypeError, match="'>|<' not supported"):
 1390:             np.argsort(index)
 1391: 
 1392:     def test_copy_name(self, simple_index):
 1393:         # Check that "name" argument passed at initialization is honoured
 1394:         # GH12309
 1395:         index = simple_index
 1396: 
 1397:         first = type(index)(index, copy=True, name="mario")
 1398:         second = type(first)(first, copy=False)
 1399: 
 1400:         # Even though "copy=False", we want a new object.
 1401:         assert first is not second
 1402:         tm.assert_index_equal(first, second)
 1403: 
 1404:         assert first.name == "mario"
 1405:         assert second.name == "mario"
 1406: 
 1407:         s1 = Series(2, index=first)
 1408:         s2 = Series(3, index=second[:-1])
 1409: 
 1410:         s3 = s1 * s2
 1411: 
 1412:         assert s3.index.name == "mario"
 1413: 
 1414:     def test_copy_name2(self):
 1415:         # Check that adding a "name" parameter to the copy is honored
 1416:         # GH14302
 1417:         index = Index([1, 2], name="MyName")
 1418:         index1 = index.copy()
 1419: 
 1420:         tm.assert_index_equal(index, index1)
 1421: 
 1422:         index2 = index.copy(name="NewName")
 1423:         tm.assert_index_equal(index, index2, check_names=False)
 1424:         assert index.name == "MyName"
 1425:         assert index2.name == "NewName"
 1426: 
 1427:     def test_unique_na(self):
 1428:         idx = Index([2, np.nan, 2, 1], name="my_index")
 1429:         expected = Index([2, np.nan, 1], name="my_index")
 1430:         result = idx.unique()
 1431:         tm.assert_index_equal(result, expected)
 1432: 
 1433:     def test_logical_compat(self, simple_index):
 1434:         index = simple_index
 1435:         assert index.all() == index.values.all()
 1436:         assert index.any() == index.values.any()
 1437: 
 1438:     @pytest.mark.parametrize("how", ["any", "all"])
 1439:     @pytest.mark.parametrize("dtype", [None, object, "category"])
 1440:     @pytest.mark.parametrize(
 1441:         "vals,expected",
 1442:         [
 1443:             ([1, 2, 3], [1, 2, 3]),
 1444:             ([1.0, 2.0, 3.0], [1.0, 2.0, 3.0]),
 1445:             ([1.0, 2.0, np.nan, 3.0], [1.0, 2.0, 3.0]),
 1446:             (["A", "B", "C"], ["A", "B", "C"]),
 1447:             (["A", np.nan, "B", "C"], ["A", "B", "C"]),
 1448:         ],
 1449:     )
 1450:     def test_dropna(self, how, dtype, vals, expected):
 1451:         # GH 6194
 1452:         index = Index(vals, dtype=dtype)
 1453:         result = index.dropna(how=how)
 1454:         expected = Index(expected, dtype=dtype)
 1455:         tm.assert_index_equal(result, expected)
 1456: 
 1457:     @pytest.mark.parametrize("how", ["any", "all"])
 1458:     @pytest.mark.parametrize(
 1459:         "index,expected",
 1460:         [
 1461:             (
 1462:                 DatetimeIndex(["2011-01-01", "2011-01-02", "2011-01-03"]),
 1463:                 DatetimeIndex(["2011-01-01", "2011-01-02", "2011-01-03"]),
 1464:             ),
 1465:             (
 1466:                 DatetimeIndex(["2011-01-01", "2011-01-02", "2011-01-03", pd.NaT]),
 1467:                 DatetimeIndex(["2011-01-01", "2011-01-02", "2011-01-03"]),
 1468:             ),
 1469:             (
 1470:                 TimedeltaIndex(["1 days", "2 days", "3 days"]),
 1471:                 TimedeltaIndex(["1 days", "2 days", "3 days"]),
 1472:             ),
 1473:             (
 1474:                 TimedeltaIndex([pd.NaT, "1 days", "2 days", "3 days", pd.NaT]),
 1475:                 TimedeltaIndex(["1 days", "2 days", "3 days"]),
 1476:             ),
 1477:             (
 1478:                 PeriodIndex(["2012-02", "2012-04", "2012-05"], freq="M"),
 1479:                 PeriodIndex(["2012-02", "2012-04", "2012-05"], freq="M"),
 1480:             ),
 1481:             (
 1482:                 PeriodIndex(["2012-02", "2012-04", "NaT", "2012-05"], freq="M"),
 1483:                 PeriodIndex(["2012-02", "2012-04", "2012-05"], freq="M"),
 1484:             ),
 1485:         ],
 1486:     )
 1487:     def test_dropna_dt_like(self, how, index, expected):
 1488:         result = index.dropna(how=how)
 1489:         tm.assert_index_equal(result, expected)
 1490: 
 1491:     def test_dropna_invalid_how_raises(self):
 1492:         msg = "invalid how option: xxx"
 1493:         with pytest.raises(ValueError, match=msg):
 1494:             Index([1, 2, 3]).dropna(how="xxx")
 1495: 
 1496:     @pytest.mark.parametrize(
 1497:         "index",
 1498:         [
 1499:             Index([np.nan]),
 1500:             Index([np.nan, 1]),
 1501:             Index([1, 2, np.nan]),
 1502:             Index(["a", "b", np.nan]),
 1503:             pd.to_datetime(["NaT"]),
 1504:             pd.to_datetime(["NaT", "2000-01-01"]),
 1505:             pd.to_datetime(["2000-01-01", "NaT", "2000-01-02"]),
 1506:             pd.to_timedelta(["1 day", "NaT"]),
 1507:         ],
 1508:     )
 1509:     def test_is_monotonic_na(self, index):
 1510:         assert index.is_monotonic_increasing is False
 1511:         assert index.is_monotonic_decreasing is False
 1512:         assert index._is_strictly_monotonic_increasing is False
 1513:         assert index._is_strictly_monotonic_decreasing is False
 1514: 
 1515:     @pytest.mark.parametrize("dtype", ["f8", "m8[ns]", "M8[us]"])
 1516:     @pytest.mark.parametrize("unique_first", [True, False])
 1517:     def test_is_monotonic_unique_na(self, dtype, unique_first):
 1518:         # GH 55755
 1519:         index = Index([None, 1, 1], dtype=dtype)
 1520:         if unique_first:
 1521:             assert index.is_unique is False
 1522:             assert index.is_monotonic_increasing is False
 1523:             assert index.is_monotonic_decreasing is False
 1524:         else:
 1525:             assert index.is_monotonic_increasing is False
 1526:             assert index.is_monotonic_decreasing is False
 1527:             assert index.is_unique is False
 1528: 
 1529:     def test_int_name_format(self, frame_or_series):
 1530:         index = Index(["a", "b", "c"], name=0)
 1531:         result = frame_or_series(list(range(3)), index=index)
 1532:         assert "0" in repr(result)
 1533: 
 1534:     def test_str_to_bytes_raises(self):
 1535:         # GH 26447
 1536:         index = Index([str(x) for x in range(10)])
 1537:         msg = "^'str' object cannot be interpreted as an integer$"
 1538:         with pytest.raises(TypeError, match=msg):
 1539:             bytes(index)
 1540: 
 1541:     @pytest.mark.filterwarnings("ignore:elementwise comparison failed:FutureWarning")
 1542:     def test_index_with_tuple_bool(self):
 1543:         # GH34123
 1544:         # TODO: also this op right now produces FutureWarning from numpy
 1545:         #  https://github.com/numpy/numpy/issues/11521
 1546:         idx = Index([("a", "b"), ("b", "c"), ("c", "a")])
 1547:         result = idx == ("c", "a")
 1548:         expected = np.array([False, False, True])
 1549:         tm.assert_numpy_array_equal(result, expected)
 1550: 
 1551: 
 1552: class TestIndexUtils:
 1553:     @pytest.mark.parametrize(
 1554:         "data, names, expected",
 1555:         [
 1556:             ([[1, 2, 3]], None, Index([1, 2, 3])),
 1557:             ([[1, 2, 3]], ["name"], Index([1, 2, 3], name="name")),
 1558:             (
 1559:                 [["a", "a"], ["c", "d"]],
 1560:                 None,
 1561:                 MultiIndex([["a"], ["c", "d"]], [[0, 0], [0, 1]]),
 1562:             ),
 1563:             (
 1564:                 [["a", "a"], ["c", "d"]],
 1565:                 ["L1", "L2"],
 1566:                 MultiIndex([["a"], ["c", "d"]], [[0, 0], [0, 1]], names=["L1", "L2"]),
 1567:             ),
 1568:         ],
 1569:     )
 1570:     def test_ensure_index_from_sequences(self, data, names, expected):
 1571:         result = ensure_index_from_sequences(data, names)
 1572:         tm.assert_index_equal(result, expected)
 1573: 
 1574:     def test_ensure_index_mixed_closed_intervals(self):
 1575:         # GH27172
 1576:         intervals = [
 1577:             pd.Interval(0, 1, closed="left"),
 1578:             pd.Interval(1, 2, closed="right"),
 1579:             pd.Interval(2, 3, closed="neither"),
 1580:             pd.Interval(3, 4, closed="both"),
 1581:         ]
 1582:         result = ensure_index(intervals)
 1583:         expected = Index(intervals, dtype=object)
 1584:         tm.assert_index_equal(result, expected)
 1585: 
 1586:     def test_ensure_index_uint64(self):
 1587:         # with both 0 and a large-uint64, np.array will infer to float64
 1588:         #  https://github.com/numpy/numpy/issues/19146
 1589:         #  but a more accurate choice would be uint64
 1590:         values = [0, np.iinfo(np.uint64).max]
 1591: 
 1592:         result = ensure_index(values)
 1593:         assert list(result) == values
 1594: 
 1595:         expected = Index(values, dtype="uint64")
 1596:         tm.assert_index_equal(result, expected)
 1597: 
 1598:     def test_get_combined_index(self):
 1599:         result = _get_combined_index([])
 1600:         expected = Index([])
 1601:         tm.assert_index_equal(result, expected)
 1602: 
 1603: 
 1604: @pytest.mark.parametrize(
 1605:     "opname",
 1606:     [
 1607:         "eq",
 1608:         "ne",
 1609:         "le",
 1610:         "lt",
 1611:         "ge",
 1612:         "gt",
 1613:         "add",
 1614:         "radd",
 1615:         "sub",
 1616:         "rsub",
 1617:         "mul",
 1618:         "rmul",
 1619:         "truediv",
 1620:         "rtruediv",
 1621:         "floordiv",
 1622:         "rfloordiv",
 1623:         "pow",
 1624:         "rpow",
 1625:         "mod",
 1626:         "divmod",
 1627:     ],
 1628: )
 1629: def test_generated_op_names(opname, index):
 1630:     opname = f"__{opname}__"
 1631:     method = getattr(index, opname)
 1632:     assert method.__name__ == opname
 1633: 
 1634: 
 1635: @pytest.mark.parametrize(
 1636:     "klass",
 1637:     [
 1638:         partial(CategoricalIndex, data=[1]),
 1639:         partial(DatetimeIndex, data=["2020-01-01"]),
 1640:         partial(PeriodIndex, data=["2020-01-01"]),
 1641:         partial(TimedeltaIndex, data=["1 day"]),
 1642:         partial(RangeIndex, data=range(1)),
 1643:         partial(IntervalIndex, data=[pd.Interval(0, 1)]),
 1644:         partial(Index, data=["a"], dtype=object),
 1645:         partial(MultiIndex, levels=[1], codes=[0]),
 1646:     ],
 1647: )
 1648: def test_index_subclass_constructor_wrong_kwargs(klass):
 1649:     # GH #19348
 1650:     with pytest.raises(TypeError, match="unexpected keyword argument"):
 1651:         klass(foo="bar")
 1652: 
 1653: 
 1654: def test_deprecated_fastpath():
 1655:     msg = "[Uu]nexpected keyword argument"
 1656:     with pytest.raises(TypeError, match=msg):
 1657:         Index(np.array(["a", "b"], dtype=object), name="test", fastpath=True)
 1658: 
 1659:     with pytest.raises(TypeError, match=msg):
 1660:         Index(np.array([1, 2, 3], dtype="int64"), name="test", fastpath=True)
 1661: 
 1662:     with pytest.raises(TypeError, match=msg):
 1663:         RangeIndex(0, 5, 2, name="test", fastpath=True)
 1664: 
 1665:     with pytest.raises(TypeError, match=msg):
 1666:         CategoricalIndex(["a", "b", "c"], name="test", fastpath=True)
 1667: 
 1668: 
 1669: def test_shape_of_invalid_index():
 1670:     # Pre-2.0, it was possible to create "invalid" index objects backed by
 1671:     # a multi-dimensional array (see https://github.com/pandas-dev/pandas/issues/27125
 1672:     # about this). However, as long as this is not solved in general,this test ensures
 1673:     # that the returned shape is consistent with this underlying array for
 1674:     # compat with matplotlib (see https://github.com/pandas-dev/pandas/issues/27775)
 1675:     idx = Index([0, 1, 2, 3])
 1676:     with pytest.raises(ValueError, match="Multi-dimensional indexing"):
 1677:         # GH#30588 multi-dimensional indexing deprecated
 1678:         idx[:, None]
 1679: 
 1680: 
 1681: @pytest.mark.parametrize("dtype", [None, np.int64, np.uint64, np.float64])
 1682: def test_validate_1d_input(dtype):
 1683:     # GH#27125 check that we do not have >1-dimensional input
 1684:     msg = "Index data must be 1-dimensional"
 1685: 
 1686:     arr = np.arange(8).reshape(2, 2, 2)
 1687:     with pytest.raises(ValueError, match=msg):
 1688:         Index(arr, dtype=dtype)
 1689: 
 1690:     df = DataFrame(arr.reshape(4, 2))
 1691:     with pytest.raises(ValueError, match=msg):
 1692:         Index(df, dtype=dtype)
 1693: 
 1694:     # GH#13601 trying to assign a multi-dimensional array to an index is not allowed
 1695:     ser = Series(0, range(4))
 1696:     with pytest.raises(ValueError, match=msg):
 1697:         ser.index = np.array([[2, 3]] * 4, dtype=dtype)
 1698: 
 1699: 
 1700: @pytest.mark.parametrize(
 1701:     "klass, extra_kwargs",
 1702:     [
 1703:         [Index, {}],
 1704:         *[[lambda x: Index(x, dtype=dtyp), {}] for dtyp in tm.ALL_REAL_NUMPY_DTYPES],
 1705:         [DatetimeIndex, {}],
 1706:         [TimedeltaIndex, {}],
 1707:         [PeriodIndex, {"freq": "Y"}],
 1708:     ],
 1709: )
 1710: def test_construct_from_memoryview(klass, extra_kwargs):
 1711:     # GH 13120
 1712:     result = klass(memoryview(np.arange(2000, 2005)), **extra_kwargs)
 1713:     expected = klass(list(range(2000, 2005)), **extra_kwargs)
 1714:     tm.assert_index_equal(result, expected, exact=True)
 1715: 
 1716: 
 1717: @pytest.mark.parametrize("op", [operator.lt, operator.gt])
 1718: def test_nan_comparison_same_object(op):
 1719:     # GH#47105
 1720:     idx = Index([np.nan])
 1721:     expected = np.array([False])
 1722: 
 1723:     result = op(idx, idx)
 1724:     tm.assert_numpy_array_equal(result, expected)
 1725: 
 1726:     result = op(idx, idx.copy())
 1727:     tm.assert_numpy_array_equal(result, expected)
 1728: 
 1729: 
 1730: @td.skip_if_no("pyarrow")
 1731: def test_is_monotonic_pyarrow_list_type():
 1732:     # GH 57333
 1733:     import pyarrow as pa
 1734: 
 1735:     idx = Index([[1], [2, 3]], dtype=pd.ArrowDtype(pa.list_(pa.int64())))
 1736:     assert not idx.is_monotonic_increasing
 1737:     assert not idx.is_monotonic_decreasing
