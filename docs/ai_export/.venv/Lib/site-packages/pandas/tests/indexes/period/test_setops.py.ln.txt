    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     PeriodIndex,
    7:     date_range,
    8:     period_range,
    9: )
   10: import pandas._testing as tm
   11: 
   12: 
   13: def _permute(obj):
   14:     return obj.take(np.random.default_rng(2).permutation(len(obj)))
   15: 
   16: 
   17: class TestPeriodIndex:
   18:     def test_union(self, sort):
   19:         # union
   20:         other1 = period_range("1/1/2000", freq="D", periods=5)
   21:         rng1 = period_range("1/6/2000", freq="D", periods=5)
   22:         expected1 = PeriodIndex(
   23:             [
   24:                 "2000-01-06",
   25:                 "2000-01-07",
   26:                 "2000-01-08",
   27:                 "2000-01-09",
   28:                 "2000-01-10",
   29:                 "2000-01-01",
   30:                 "2000-01-02",
   31:                 "2000-01-03",
   32:                 "2000-01-04",
   33:                 "2000-01-05",
   34:             ],
   35:             freq="D",
   36:         )
   37: 
   38:         rng2 = period_range("1/1/2000", freq="D", periods=5)
   39:         other2 = period_range("1/4/2000", freq="D", periods=5)
   40:         expected2 = period_range("1/1/2000", freq="D", periods=8)
   41: 
   42:         rng3 = period_range("1/1/2000", freq="D", periods=5)
   43:         other3 = PeriodIndex([], freq="D")
   44:         expected3 = period_range("1/1/2000", freq="D", periods=5)
   45: 
   46:         rng4 = period_range("2000-01-01 09:00", freq="h", periods=5)
   47:         other4 = period_range("2000-01-02 09:00", freq="h", periods=5)
   48:         expected4 = PeriodIndex(
   49:             [
   50:                 "2000-01-01 09:00",
   51:                 "2000-01-01 10:00",
   52:                 "2000-01-01 11:00",
   53:                 "2000-01-01 12:00",
   54:                 "2000-01-01 13:00",
   55:                 "2000-01-02 09:00",
   56:                 "2000-01-02 10:00",
   57:                 "2000-01-02 11:00",
   58:                 "2000-01-02 12:00",
   59:                 "2000-01-02 13:00",
   60:             ],
   61:             freq="h",
   62:         )
   63: 
   64:         rng5 = PeriodIndex(
   65:             ["2000-01-01 09:01", "2000-01-01 09:03", "2000-01-01 09:05"], freq="min"
   66:         )
   67:         other5 = PeriodIndex(
   68:             ["2000-01-01 09:01", "2000-01-01 09:05", "2000-01-01 09:08"], freq="min"
   69:         )
   70:         expected5 = PeriodIndex(
   71:             [
   72:                 "2000-01-01 09:01",
   73:                 "2000-01-01 09:03",
   74:                 "2000-01-01 09:05",
   75:                 "2000-01-01 09:08",
   76:             ],
   77:             freq="min",
   78:         )
   79: 
   80:         rng6 = period_range("2000-01-01", freq="M", periods=7)
   81:         other6 = period_range("2000-04-01", freq="M", periods=7)
   82:         expected6 = period_range("2000-01-01", freq="M", periods=10)
   83: 
   84:         rng7 = period_range("2003-01-01", freq="Y", periods=5)
   85:         other7 = period_range("1998-01-01", freq="Y", periods=8)
   86:         expected7 = PeriodIndex(
   87:             [
   88:                 "2003",
   89:                 "2004",
   90:                 "2005",
   91:                 "2006",
   92:                 "2007",
   93:                 "1998",
   94:                 "1999",
   95:                 "2000",
   96:                 "2001",
   97:                 "2002",
   98:             ],
   99:             freq="Y",
  100:         )
  101: 
  102:         rng8 = PeriodIndex(
  103:             ["1/3/2000", "1/2/2000", "1/1/2000", "1/5/2000", "1/4/2000"], freq="D"
  104:         )
  105:         other8 = period_range("1/6/2000", freq="D", periods=5)
  106:         expected8 = PeriodIndex(
  107:             [
  108:                 "1/3/2000",
  109:                 "1/2/2000",
  110:                 "1/1/2000",
  111:                 "1/5/2000",
  112:                 "1/4/2000",
  113:                 "1/6/2000",
  114:                 "1/7/2000",
  115:                 "1/8/2000",
  116:                 "1/9/2000",
  117:                 "1/10/2000",
  118:             ],
  119:             freq="D",
  120:         )
  121: 
  122:         for rng, other, expected in [
  123:             (rng1, other1, expected1),
  124:             (rng2, other2, expected2),
  125:             (rng3, other3, expected3),
  126:             (rng4, other4, expected4),
  127:             (rng5, other5, expected5),
  128:             (rng6, other6, expected6),
  129:             (rng7, other7, expected7),
  130:             (rng8, other8, expected8),
  131:         ]:
  132:             result_union = rng.union(other, sort=sort)
  133:             if sort is None:
  134:                 expected = expected.sort_values()
  135:             tm.assert_index_equal(result_union, expected)
  136: 
  137:     def test_union_misc(self, sort):
  138:         index = period_range("1/1/2000", "1/20/2000", freq="D")
  139: 
  140:         result = index[:-5].union(index[10:], sort=sort)
  141:         tm.assert_index_equal(result, index)
  142: 
  143:         # not in order
  144:         result = _permute(index[:-5]).union(_permute(index[10:]), sort=sort)
  145:         if sort is False:
  146:             tm.assert_index_equal(result.sort_values(), index)
  147:         else:
  148:             tm.assert_index_equal(result, index)
  149: 
  150:         # cast if different frequencies
  151:         index = period_range("1/1/2000", "1/20/2000", freq="D")
  152:         index2 = period_range("1/1/2000", "1/20/2000", freq="W-WED")
  153:         result = index.union(index2, sort=sort)
  154:         expected = index.astype(object).union(index2.astype(object), sort=sort)
  155:         tm.assert_index_equal(result, expected)
  156: 
  157:     def test_intersection(self, sort):
  158:         index = period_range("1/1/2000", "1/20/2000", freq="D")
  159: 
  160:         result = index[:-5].intersection(index[10:], sort=sort)
  161:         tm.assert_index_equal(result, index[10:-5])
  162: 
  163:         # not in order
  164:         left = _permute(index[:-5])
  165:         right = _permute(index[10:])
  166:         result = left.intersection(right, sort=sort)
  167:         if sort is False:
  168:             tm.assert_index_equal(result.sort_values(), index[10:-5])
  169:         else:
  170:             tm.assert_index_equal(result, index[10:-5])
  171: 
  172:         # cast if different frequencies
  173:         index = period_range("1/1/2000", "1/20/2000", freq="D")
  174:         index2 = period_range("1/1/2000", "1/20/2000", freq="W-WED")
  175: 
  176:         result = index.intersection(index2, sort=sort)
  177:         expected = pd.Index([], dtype=object)
  178:         tm.assert_index_equal(result, expected)
  179: 
  180:         index3 = period_range("1/1/2000", "1/20/2000", freq="2D")
  181:         result = index.intersection(index3, sort=sort)
  182:         tm.assert_index_equal(result, expected)
  183: 
  184:     def test_intersection_cases(self, sort):
  185:         base = period_range("6/1/2000", "6/30/2000", freq="D", name="idx")
  186: 
  187:         # if target has the same name, it is preserved
  188:         rng2 = period_range("5/15/2000", "6/20/2000", freq="D", name="idx")
  189:         expected2 = period_range("6/1/2000", "6/20/2000", freq="D", name="idx")
  190: 
  191:         # if target name is different, it will be reset
  192:         rng3 = period_range("5/15/2000", "6/20/2000", freq="D", name="other")
  193:         expected3 = period_range("6/1/2000", "6/20/2000", freq="D", name=None)
  194: 
  195:         rng4 = period_range("7/1/2000", "7/31/2000", freq="D", name="idx")
  196:         expected4 = PeriodIndex([], name="idx", freq="D")
  197: 
  198:         for rng, expected in [
  199:             (rng2, expected2),
  200:             (rng3, expected3),
  201:             (rng4, expected4),
  202:         ]:
  203:             result = base.intersection(rng, sort=sort)
  204:             tm.assert_index_equal(result, expected)
  205:             assert result.name == expected.name
  206:             assert result.freq == expected.freq
  207: 
  208:         # non-monotonic
  209:         base = PeriodIndex(
  210:             ["2011-01-05", "2011-01-04", "2011-01-02", "2011-01-03"],
  211:             freq="D",
  212:             name="idx",
  213:         )
  214: 
  215:         rng2 = PeriodIndex(
  216:             ["2011-01-04", "2011-01-02", "2011-02-02", "2011-02-03"],
  217:             freq="D",
  218:             name="idx",
  219:         )
  220:         expected2 = PeriodIndex(["2011-01-04", "2011-01-02"], freq="D", name="idx")
  221: 
  222:         rng3 = PeriodIndex(
  223:             ["2011-01-04", "2011-01-02", "2011-02-02", "2011-02-03"],
  224:             freq="D",
  225:             name="other",
  226:         )
  227:         expected3 = PeriodIndex(["2011-01-04", "2011-01-02"], freq="D", name=None)
  228: 
  229:         rng4 = period_range("7/1/2000", "7/31/2000", freq="D", name="idx")
  230:         expected4 = PeriodIndex([], freq="D", name="idx")
  231: 
  232:         for rng, expected in [
  233:             (rng2, expected2),
  234:             (rng3, expected3),
  235:             (rng4, expected4),
  236:         ]:
  237:             result = base.intersection(rng, sort=sort)
  238:             if sort is None:
  239:                 expected = expected.sort_values()
  240:             tm.assert_index_equal(result, expected)
  241:             assert result.name == expected.name
  242:             assert result.freq == "D"
  243: 
  244:         # empty same freq
  245:         rng = date_range("6/1/2000", "6/15/2000", freq="min")
  246:         result = rng[0:0].intersection(rng)
  247:         assert len(result) == 0
  248: 
  249:         result = rng.intersection(rng[0:0])
  250:         assert len(result) == 0
  251: 
  252:     def test_difference(self, sort):
  253:         # diff
  254:         period_rng = ["1/3/2000", "1/2/2000", "1/1/2000", "1/5/2000", "1/4/2000"]
  255:         rng1 = PeriodIndex(period_rng, freq="D")
  256:         other1 = period_range("1/6/2000", freq="D", periods=5)
  257:         expected1 = rng1
  258: 
  259:         rng2 = PeriodIndex(period_rng, freq="D")
  260:         other2 = period_range("1/4/2000", freq="D", periods=5)
  261:         expected2 = PeriodIndex(["1/3/2000", "1/2/2000", "1/1/2000"], freq="D")
  262: 
  263:         rng3 = PeriodIndex(period_rng, freq="D")
  264:         other3 = PeriodIndex([], freq="D")
  265:         expected3 = rng3
  266: 
  267:         period_rng = [
  268:             "2000-01-01 10:00",
  269:             "2000-01-01 09:00",
  270:             "2000-01-01 12:00",
  271:             "2000-01-01 11:00",
  272:             "2000-01-01 13:00",
  273:         ]
  274:         rng4 = PeriodIndex(period_rng, freq="h")
  275:         other4 = period_range("2000-01-02 09:00", freq="h", periods=5)
  276:         expected4 = rng4
  277: 
  278:         rng5 = PeriodIndex(
  279:             ["2000-01-01 09:03", "2000-01-01 09:01", "2000-01-01 09:05"], freq="min"
  280:         )
  281:         other5 = PeriodIndex(["2000-01-01 09:01", "2000-01-01 09:05"], freq="min")
  282:         expected5 = PeriodIndex(["2000-01-01 09:03"], freq="min")
  283: 
  284:         period_rng = [
  285:             "2000-02-01",
  286:             "2000-01-01",
  287:             "2000-06-01",
  288:             "2000-07-01",
  289:             "2000-05-01",
  290:             "2000-03-01",
  291:             "2000-04-01",
  292:         ]
  293:         rng6 = PeriodIndex(period_rng, freq="M")
  294:         other6 = period_range("2000-04-01", freq="M", periods=7)
  295:         expected6 = PeriodIndex(["2000-02-01", "2000-01-01", "2000-03-01"], freq="M")
  296: 
  297:         period_rng = ["2003", "2007", "2006", "2005", "2004"]
  298:         rng7 = PeriodIndex(period_rng, freq="Y")
  299:         other7 = period_range("1998-01-01", freq="Y", periods=8)
  300:         expected7 = PeriodIndex(["2007", "2006"], freq="Y")
  301: 
  302:         for rng, other, expected in [
  303:             (rng1, other1, expected1),
  304:             (rng2, other2, expected2),
  305:             (rng3, other3, expected3),
  306:             (rng4, other4, expected4),
  307:             (rng5, other5, expected5),
  308:             (rng6, other6, expected6),
  309:             (rng7, other7, expected7),
  310:         ]:
  311:             result_difference = rng.difference(other, sort=sort)
  312:             if sort is None and len(other):
  313:                 # We dont sort (yet?) when empty GH#24959
  314:                 expected = expected.sort_values()
  315:             tm.assert_index_equal(result_difference, expected)
  316: 
  317:     def test_difference_freq(self, sort):
  318:         # GH14323: difference of Period MUST preserve frequency
  319:         # but the ability to union results must be preserved
  320: 
  321:         index = period_range("20160920", "20160925", freq="D")
  322: 
  323:         other = period_range("20160921", "20160924", freq="D")
  324:         expected = PeriodIndex(["20160920", "20160925"], freq="D")
  325:         idx_diff = index.difference(other, sort)
  326:         tm.assert_index_equal(idx_diff, expected)
  327:         tm.assert_attr_equal("freq", idx_diff, expected)
  328: 
  329:         other = period_range("20160922", "20160925", freq="D")
  330:         idx_diff = index.difference(other, sort)
  331:         expected = PeriodIndex(["20160920", "20160921"], freq="D")
  332:         tm.assert_index_equal(idx_diff, expected)
  333:         tm.assert_attr_equal("freq", idx_diff, expected)
  334: 
  335:     def test_intersection_equal_duplicates(self):
  336:         # GH#38302
  337:         idx = period_range("2011-01-01", periods=2)
  338:         idx_dup = idx.append(idx)
  339:         result = idx_dup.intersection(idx_dup)
  340:         tm.assert_index_equal(result, idx)
  341: 
  342:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  343:     def test_union_duplicates(self):
  344:         # GH#36289
  345:         idx = period_range("2011-01-01", periods=2)
  346:         idx_dup = idx.append(idx)
  347: 
  348:         idx2 = period_range("2011-01-02", periods=2)
  349:         idx2_dup = idx2.append(idx2)
  350:         result = idx_dup.union(idx2_dup)
  351: 
  352:         expected = PeriodIndex(
  353:             [
  354:                 "2011-01-01",
  355:                 "2011-01-01",
  356:                 "2011-01-02",
  357:                 "2011-01-02",
  358:                 "2011-01-03",
  359:                 "2011-01-03",
  360:             ],
  361:             freq="D",
  362:         )
  363:         tm.assert_index_equal(result, expected)
