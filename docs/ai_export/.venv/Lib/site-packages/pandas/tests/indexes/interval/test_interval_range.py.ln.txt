    1: from datetime import timedelta
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.core.dtypes.common import is_integer
    7: 
    8: from pandas import (
    9:     DateOffset,
   10:     Interval,
   11:     IntervalIndex,
   12:     Timedelta,
   13:     Timestamp,
   14:     date_range,
   15:     interval_range,
   16:     timedelta_range,
   17: )
   18: import pandas._testing as tm
   19: 
   20: from pandas.tseries.offsets import Day
   21: 
   22: 
   23: @pytest.fixture(params=[None, "foo"])
   24: def name(request):
   25:     return request.param
   26: 
   27: 
   28: class TestIntervalRange:
   29:     @pytest.mark.parametrize("freq, periods", [(1, 100), (2.5, 40), (5, 20), (25, 4)])
   30:     def test_constructor_numeric(self, closed, name, freq, periods):
   31:         start, end = 0, 100
   32:         breaks = np.arange(101, step=freq)
   33:         expected = IntervalIndex.from_breaks(breaks, name=name, closed=closed)
   34: 
   35:         # defined from start/end/freq
   36:         result = interval_range(
   37:             start=start, end=end, freq=freq, name=name, closed=closed
   38:         )
   39:         tm.assert_index_equal(result, expected)
   40: 
   41:         # defined from start/periods/freq
   42:         result = interval_range(
   43:             start=start, periods=periods, freq=freq, name=name, closed=closed
   44:         )
   45:         tm.assert_index_equal(result, expected)
   46: 
   47:         # defined from end/periods/freq
   48:         result = interval_range(
   49:             end=end, periods=periods, freq=freq, name=name, closed=closed
   50:         )
   51:         tm.assert_index_equal(result, expected)
   52: 
   53:         # GH 20976: linspace behavior defined from start/end/periods
   54:         result = interval_range(
   55:             start=start, end=end, periods=periods, name=name, closed=closed
   56:         )
   57:         tm.assert_index_equal(result, expected)
   58: 
   59:     @pytest.mark.parametrize("tz", [None, "US/Eastern"])
   60:     @pytest.mark.parametrize(
   61:         "freq, periods", [("D", 364), ("2D", 182), ("22D18h", 16), ("ME", 11)]
   62:     )
   63:     def test_constructor_timestamp(self, closed, name, freq, periods, tz):
   64:         start, end = Timestamp("20180101", tz=tz), Timestamp("20181231", tz=tz)
   65:         breaks = date_range(start=start, end=end, freq=freq)
   66:         expected = IntervalIndex.from_breaks(breaks, name=name, closed=closed)
   67: 
   68:         # defined from start/end/freq
   69:         result = interval_range(
   70:             start=start, end=end, freq=freq, name=name, closed=closed
   71:         )
   72:         tm.assert_index_equal(result, expected)
   73: 
   74:         # defined from start/periods/freq
   75:         result = interval_range(
   76:             start=start, periods=periods, freq=freq, name=name, closed=closed
   77:         )
   78:         tm.assert_index_equal(result, expected)
   79: 
   80:         # defined from end/periods/freq
   81:         result = interval_range(
   82:             end=end, periods=periods, freq=freq, name=name, closed=closed
   83:         )
   84:         tm.assert_index_equal(result, expected)
   85: 
   86:         # GH 20976: linspace behavior defined from start/end/periods
   87:         if not breaks.freq.n == 1 and tz is None:
   88:             result = interval_range(
   89:                 start=start, end=end, periods=periods, name=name, closed=closed
   90:             )
   91:             tm.assert_index_equal(result, expected)
   92: 
   93:     @pytest.mark.parametrize(
   94:         "freq, periods", [("D", 100), ("2D12h", 40), ("5D", 20), ("25D", 4)]
   95:     )
   96:     def test_constructor_timedelta(self, closed, name, freq, periods):
   97:         start, end = Timedelta("0 days"), Timedelta("100 days")
   98:         breaks = timedelta_range(start=start, end=end, freq=freq)
   99:         expected = IntervalIndex.from_breaks(breaks, name=name, closed=closed)
  100: 
  101:         # defined from start/end/freq
  102:         result = interval_range(
  103:             start=start, end=end, freq=freq, name=name, closed=closed
  104:         )
  105:         tm.assert_index_equal(result, expected)
  106: 
  107:         # defined from start/periods/freq
  108:         result = interval_range(
  109:             start=start, periods=periods, freq=freq, name=name, closed=closed
  110:         )
  111:         tm.assert_index_equal(result, expected)
  112: 
  113:         # defined from end/periods/freq
  114:         result = interval_range(
  115:             end=end, periods=periods, freq=freq, name=name, closed=closed
  116:         )
  117:         tm.assert_index_equal(result, expected)
  118: 
  119:         # GH 20976: linspace behavior defined from start/end/periods
  120:         result = interval_range(
  121:             start=start, end=end, periods=periods, name=name, closed=closed
  122:         )
  123:         tm.assert_index_equal(result, expected)
  124: 
  125:     @pytest.mark.parametrize(
  126:         "start, end, freq, expected_endpoint",
  127:         [
  128:             (0, 10, 3, 9),
  129:             (0, 10, 1.5, 9),
  130:             (0.5, 10, 3, 9.5),
  131:             (Timedelta("0D"), Timedelta("10D"), "2D4h", Timedelta("8D16h")),
  132:             (
  133:                 Timestamp("2018-01-01"),
  134:                 Timestamp("2018-02-09"),
  135:                 "MS",
  136:                 Timestamp("2018-02-01"),
  137:             ),
  138:             (
  139:                 Timestamp("2018-01-01", tz="US/Eastern"),
  140:                 Timestamp("2018-01-20", tz="US/Eastern"),
  141:                 "5D12h",
  142:                 Timestamp("2018-01-17 12:00:00", tz="US/Eastern"),
  143:             ),
  144:         ],
  145:     )
  146:     def test_early_truncation(self, start, end, freq, expected_endpoint):
  147:         # index truncates early if freq causes end to be skipped
  148:         result = interval_range(start=start, end=end, freq=freq)
  149:         result_endpoint = result.right[-1]
  150:         assert result_endpoint == expected_endpoint
  151: 
  152:     @pytest.mark.parametrize(
  153:         "start, end, freq",
  154:         [(0.5, None, None), (None, 4.5, None), (0.5, None, 1.5), (None, 6.5, 1.5)],
  155:     )
  156:     def test_no_invalid_float_truncation(self, start, end, freq):
  157:         # GH 21161
  158:         if freq is None:
  159:             breaks = [0.5, 1.5, 2.5, 3.5, 4.5]
  160:         else:
  161:             breaks = [0.5, 2.0, 3.5, 5.0, 6.5]
  162:         expected = IntervalIndex.from_breaks(breaks)
  163: 
  164:         result = interval_range(start=start, end=end, periods=4, freq=freq)
  165:         tm.assert_index_equal(result, expected)
  166: 
  167:     @pytest.mark.parametrize(
  168:         "start, mid, end",
  169:         [
  170:             (
  171:                 Timestamp("2018-03-10", tz="US/Eastern"),
  172:                 Timestamp("2018-03-10 23:30:00", tz="US/Eastern"),
  173:                 Timestamp("2018-03-12", tz="US/Eastern"),
  174:             ),
  175:             (
  176:                 Timestamp("2018-11-03", tz="US/Eastern"),
  177:                 Timestamp("2018-11-04 00:30:00", tz="US/Eastern"),
  178:                 Timestamp("2018-11-05", tz="US/Eastern"),
  179:             ),
  180:         ],
  181:     )
  182:     def test_linspace_dst_transition(self, start, mid, end):
  183:         # GH 20976: linspace behavior defined from start/end/periods
  184:         # accounts for the hour gained/lost during DST transition
  185:         start = start.as_unit("ns")
  186:         mid = mid.as_unit("ns")
  187:         end = end.as_unit("ns")
  188:         result = interval_range(start=start, end=end, periods=2)
  189:         expected = IntervalIndex.from_breaks([start, mid, end])
  190:         tm.assert_index_equal(result, expected)
  191: 
  192:     @pytest.mark.parametrize("freq", [2, 2.0])
  193:     @pytest.mark.parametrize("end", [10, 10.0])
  194:     @pytest.mark.parametrize("start", [0, 0.0])
  195:     def test_float_subtype(self, start, end, freq):
  196:         # Has float subtype if any of start/end/freq are float, even if all
  197:         # resulting endpoints can safely be upcast to integers
  198: 
  199:         # defined from start/end/freq
  200:         index = interval_range(start=start, end=end, freq=freq)
  201:         result = index.dtype.subtype
  202:         expected = "int64" if is_integer(start + end + freq) else "float64"
  203:         assert result == expected
  204: 
  205:         # defined from start/periods/freq
  206:         index = interval_range(start=start, periods=5, freq=freq)
  207:         result = index.dtype.subtype
  208:         expected = "int64" if is_integer(start + freq) else "float64"
  209:         assert result == expected
  210: 
  211:         # defined from end/periods/freq
  212:         index = interval_range(end=end, periods=5, freq=freq)
  213:         result = index.dtype.subtype
  214:         expected = "int64" if is_integer(end + freq) else "float64"
  215:         assert result == expected
  216: 
  217:         # GH 20976: linspace behavior defined from start/end/periods
  218:         index = interval_range(start=start, end=end, periods=5)
  219:         result = index.dtype.subtype
  220:         expected = "int64" if is_integer(start + end) else "float64"
  221:         assert result == expected
  222: 
  223:     def test_interval_range_fractional_period(self):
  224:         # float value for periods
  225:         expected = interval_range(start=0, periods=10)
  226:         msg = "Non-integer 'periods' in pd.date_range, .* pd.interval_range"
  227:         with tm.assert_produces_warning(FutureWarning, match=msg):
  228:             result = interval_range(start=0, periods=10.5)
  229:         tm.assert_index_equal(result, expected)
  230: 
  231:     def test_constructor_coverage(self):
  232:         # equivalent timestamp-like start/end
  233:         start, end = Timestamp("2017-01-01"), Timestamp("2017-01-15")
  234:         expected = interval_range(start=start, end=end)
  235: 
  236:         result = interval_range(start=start.to_pydatetime(), end=end.to_pydatetime())
  237:         tm.assert_index_equal(result, expected)
  238: 
  239:         result = interval_range(start=start.asm8, end=end.asm8)
  240:         tm.assert_index_equal(result, expected)
  241: 
  242:         # equivalent freq with timestamp
  243:         equiv_freq = [
  244:             "D",
  245:             Day(),
  246:             Timedelta(days=1),
  247:             timedelta(days=1),
  248:             DateOffset(days=1),
  249:         ]
  250:         for freq in equiv_freq:
  251:             result = interval_range(start=start, end=end, freq=freq)
  252:             tm.assert_index_equal(result, expected)
  253: 
  254:         # equivalent timedelta-like start/end
  255:         start, end = Timedelta(days=1), Timedelta(days=10)
  256:         expected = interval_range(start=start, end=end)
  257: 
  258:         result = interval_range(start=start.to_pytimedelta(), end=end.to_pytimedelta())
  259:         tm.assert_index_equal(result, expected)
  260: 
  261:         result = interval_range(start=start.asm8, end=end.asm8)
  262:         tm.assert_index_equal(result, expected)
  263: 
  264:         # equivalent freq with timedelta
  265:         equiv_freq = ["D", Day(), Timedelta(days=1), timedelta(days=1)]
  266:         for freq in equiv_freq:
  267:             result = interval_range(start=start, end=end, freq=freq)
  268:             tm.assert_index_equal(result, expected)
  269: 
  270:     def test_errors(self):
  271:         # not enough params
  272:         msg = (
  273:             "Of the four parameters: start, end, periods, and freq, "
  274:             "exactly three must be specified"
  275:         )
  276: 
  277:         with pytest.raises(ValueError, match=msg):
  278:             interval_range(start=0)
  279: 
  280:         with pytest.raises(ValueError, match=msg):
  281:             interval_range(end=5)
  282: 
  283:         with pytest.raises(ValueError, match=msg):
  284:             interval_range(periods=2)
  285: 
  286:         with pytest.raises(ValueError, match=msg):
  287:             interval_range()
  288: 
  289:         # too many params
  290:         with pytest.raises(ValueError, match=msg):
  291:             interval_range(start=0, end=5, periods=6, freq=1.5)
  292: 
  293:         # mixed units
  294:         msg = "start, end, freq need to be type compatible"
  295:         with pytest.raises(TypeError, match=msg):
  296:             interval_range(start=0, end=Timestamp("20130101"), freq=2)
  297: 
  298:         with pytest.raises(TypeError, match=msg):
  299:             interval_range(start=0, end=Timedelta("1 day"), freq=2)
  300: 
  301:         with pytest.raises(TypeError, match=msg):
  302:             interval_range(start=0, end=10, freq="D")
  303: 
  304:         with pytest.raises(TypeError, match=msg):
  305:             interval_range(start=Timestamp("20130101"), end=10, freq="D")
  306: 
  307:         with pytest.raises(TypeError, match=msg):
  308:             interval_range(
  309:                 start=Timestamp("20130101"), end=Timedelta("1 day"), freq="D"
  310:             )
  311: 
  312:         with pytest.raises(TypeError, match=msg):
  313:             interval_range(
  314:                 start=Timestamp("20130101"), end=Timestamp("20130110"), freq=2
  315:             )
  316: 
  317:         with pytest.raises(TypeError, match=msg):
  318:             interval_range(start=Timedelta("1 day"), end=10, freq="D")
  319: 
  320:         with pytest.raises(TypeError, match=msg):
  321:             interval_range(
  322:                 start=Timedelta("1 day"), end=Timestamp("20130110"), freq="D"
  323:             )
  324: 
  325:         with pytest.raises(TypeError, match=msg):
  326:             interval_range(start=Timedelta("1 day"), end=Timedelta("10 days"), freq=2)
  327: 
  328:         # invalid periods
  329:         msg = "periods must be a number, got foo"
  330:         with pytest.raises(TypeError, match=msg):
  331:             interval_range(start=0, periods="foo")
  332: 
  333:         # invalid start
  334:         msg = "start must be numeric or datetime-like, got foo"
  335:         with pytest.raises(ValueError, match=msg):
  336:             interval_range(start="foo", periods=10)
  337: 
  338:         # invalid end
  339:         msg = r"end must be numeric or datetime-like, got \(0, 1\]"
  340:         with pytest.raises(ValueError, match=msg):
  341:             interval_range(end=Interval(0, 1), periods=10)
  342: 
  343:         # invalid freq for datetime-like
  344:         msg = "freq must be numeric or convertible to DateOffset, got foo"
  345:         with pytest.raises(ValueError, match=msg):
  346:             interval_range(start=0, end=10, freq="foo")
  347: 
  348:         with pytest.raises(ValueError, match=msg):
  349:             interval_range(start=Timestamp("20130101"), periods=10, freq="foo")
  350: 
  351:         with pytest.raises(ValueError, match=msg):
  352:             interval_range(end=Timedelta("1 day"), periods=10, freq="foo")
  353: 
  354:         # mixed tz
  355:         start = Timestamp("2017-01-01", tz="US/Eastern")
  356:         end = Timestamp("2017-01-07", tz="US/Pacific")
  357:         msg = "Start and end cannot both be tz-aware with different timezones"
  358:         with pytest.raises(TypeError, match=msg):
  359:             interval_range(start=start, end=end)
  360: 
  361:     def test_float_freq(self):
  362:         # GH 54477
  363:         result = interval_range(0, 1, freq=0.1)
  364:         expected = IntervalIndex.from_breaks([0 + 0.1 * n for n in range(11)])
  365:         tm.assert_index_equal(result, expected)
  366: 
  367:         result = interval_range(0, 1, freq=0.6)
  368:         expected = IntervalIndex.from_breaks([0, 0.6])
  369:         tm.assert_index_equal(result, expected)
