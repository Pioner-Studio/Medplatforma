    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.compat import PY311
    5: 
    6: from pandas.core.dtypes.dtypes import DatetimeTZDtype
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     CategoricalIndex,
   11:     MultiIndex,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: def assert_matching(actual, expected, check_dtype=False):
   17:     # avoid specifying internal representation
   18:     # as much as possible
   19:     assert len(actual) == len(expected)
   20:     for act, exp in zip(actual, expected):
   21:         act = np.asarray(act)
   22:         exp = np.asarray(exp)
   23:         tm.assert_numpy_array_equal(act, exp, check_dtype=check_dtype)
   24: 
   25: 
   26: def test_get_level_number_integer(idx):
   27:     idx.names = [1, 0]
   28:     assert idx._get_level_number(1) == 0
   29:     assert idx._get_level_number(0) == 1
   30:     msg = "Too many levels: Index has only 2 levels, not 3"
   31:     with pytest.raises(IndexError, match=msg):
   32:         idx._get_level_number(2)
   33:     with pytest.raises(KeyError, match="Level fourth not found"):
   34:         idx._get_level_number("fourth")
   35: 
   36: 
   37: def test_get_dtypes(using_infer_string):
   38:     # Test MultiIndex.dtypes (# Gh37062)
   39:     idx_multitype = MultiIndex.from_product(
   40:         [[1, 2, 3], ["a", "b", "c"], pd.date_range("20200101", periods=2, tz="UTC")],
   41:         names=["int", "string", "dt"],
   42:     )
   43: 
   44:     exp = "object" if not using_infer_string else "string"
   45:     expected = pd.Series(
   46:         {
   47:             "int": np.dtype("int64"),
   48:             "string": exp,
   49:             "dt": DatetimeTZDtype(tz="utc"),
   50:         }
   51:     )
   52:     tm.assert_series_equal(expected, idx_multitype.dtypes)
   53: 
   54: 
   55: def test_get_dtypes_no_level_name(using_infer_string):
   56:     # Test MultiIndex.dtypes (# GH38580 )
   57:     idx_multitype = MultiIndex.from_product(
   58:         [
   59:             [1, 2, 3],
   60:             ["a", "b", "c"],
   61:             pd.date_range("20200101", periods=2, tz="UTC"),
   62:         ],
   63:     )
   64:     exp = "object" if not using_infer_string else "string"
   65:     expected = pd.Series(
   66:         {
   67:             "level_0": np.dtype("int64"),
   68:             "level_1": exp,
   69:             "level_2": DatetimeTZDtype(tz="utc"),
   70:         }
   71:     )
   72:     tm.assert_series_equal(expected, idx_multitype.dtypes)
   73: 
   74: 
   75: def test_get_dtypes_duplicate_level_names(using_infer_string):
   76:     # Test MultiIndex.dtypes with non-unique level names (# GH45174)
   77:     result = MultiIndex.from_product(
   78:         [
   79:             [1, 2, 3],
   80:             ["a", "b", "c"],
   81:             pd.date_range("20200101", periods=2, tz="UTC"),
   82:         ],
   83:         names=["A", "A", "A"],
   84:     ).dtypes
   85:     exp = "object" if not using_infer_string else "string"
   86:     expected = pd.Series(
   87:         [np.dtype("int64"), exp, DatetimeTZDtype(tz="utc")],
   88:         index=["A", "A", "A"],
   89:     )
   90:     tm.assert_series_equal(result, expected)
   91: 
   92: 
   93: def test_get_level_number_out_of_bounds(multiindex_dataframe_random_data):
   94:     frame = multiindex_dataframe_random_data
   95: 
   96:     with pytest.raises(IndexError, match="Too many levels"):
   97:         frame.index._get_level_number(2)
   98:     with pytest.raises(IndexError, match="not a valid level number"):
   99:         frame.index._get_level_number(-3)
  100: 
  101: 
  102: def test_set_name_methods(idx):
  103:     # so long as these are synonyms, we don't need to test set_names
  104:     index_names = ["first", "second"]
  105:     assert idx.rename == idx.set_names
  106:     new_names = [name + "SUFFIX" for name in index_names]
  107:     ind = idx.set_names(new_names)
  108:     assert idx.names == index_names
  109:     assert ind.names == new_names
  110:     msg = "Length of names must match number of levels in MultiIndex"
  111:     with pytest.raises(ValueError, match=msg):
  112:         ind.set_names(new_names + new_names)
  113:     new_names2 = [name + "SUFFIX2" for name in new_names]
  114:     res = ind.set_names(new_names2, inplace=True)
  115:     assert res is None
  116:     assert ind.names == new_names2
  117: 
  118:     # set names for specific level (# GH7792)
  119:     ind = idx.set_names(new_names[0], level=0)
  120:     assert idx.names == index_names
  121:     assert ind.names == [new_names[0], index_names[1]]
  122: 
  123:     res = ind.set_names(new_names2[0], level=0, inplace=True)
  124:     assert res is None
  125:     assert ind.names == [new_names2[0], index_names[1]]
  126: 
  127:     # set names for multiple levels
  128:     ind = idx.set_names(new_names, level=[0, 1])
  129:     assert idx.names == index_names
  130:     assert ind.names == new_names
  131: 
  132:     res = ind.set_names(new_names2, level=[0, 1], inplace=True)
  133:     assert res is None
  134:     assert ind.names == new_names2
  135: 
  136: 
  137: def test_set_levels_codes_directly(idx):
  138:     # setting levels/codes directly raises AttributeError
  139: 
  140:     levels = idx.levels
  141:     new_levels = [[lev + "a" for lev in level] for level in levels]
  142: 
  143:     codes = idx.codes
  144:     major_codes, minor_codes = codes
  145:     major_codes = [(x + 1) % 3 for x in major_codes]
  146:     minor_codes = [(x + 1) % 1 for x in minor_codes]
  147:     new_codes = [major_codes, minor_codes]
  148: 
  149:     msg = "Can't set attribute"
  150:     with pytest.raises(AttributeError, match=msg):
  151:         idx.levels = new_levels
  152: 
  153:     msg = (
  154:         "property 'codes' of 'MultiIndex' object has no setter"
  155:         if PY311
  156:         else "can't set attribute"
  157:     )
  158:     with pytest.raises(AttributeError, match=msg):
  159:         idx.codes = new_codes
  160: 
  161: 
  162: def test_set_levels(idx):
  163:     # side note - you probably wouldn't want to use levels and codes
  164:     # directly like this - but it is possible.
  165:     levels = idx.levels
  166:     new_levels = [[lev + "a" for lev in level] for level in levels]
  167: 
  168:     # level changing [w/o mutation]
  169:     ind2 = idx.set_levels(new_levels)
  170:     assert_matching(ind2.levels, new_levels)
  171:     assert_matching(idx.levels, levels)
  172: 
  173:     # level changing specific level [w/o mutation]
  174:     ind2 = idx.set_levels(new_levels[0], level=0)
  175:     assert_matching(ind2.levels, [new_levels[0], levels[1]])
  176:     assert_matching(idx.levels, levels)
  177: 
  178:     ind2 = idx.set_levels(new_levels[1], level=1)
  179:     assert_matching(ind2.levels, [levels[0], new_levels[1]])
  180:     assert_matching(idx.levels, levels)
  181: 
  182:     # level changing multiple levels [w/o mutation]
  183:     ind2 = idx.set_levels(new_levels, level=[0, 1])
  184:     assert_matching(ind2.levels, new_levels)
  185:     assert_matching(idx.levels, levels)
  186: 
  187:     # illegal level changing should not change levels
  188:     # GH 13754
  189:     original_index = idx.copy()
  190:     with pytest.raises(ValueError, match="^On"):
  191:         idx.set_levels(["c"], level=0)
  192:     assert_matching(idx.levels, original_index.levels, check_dtype=True)
  193: 
  194:     with pytest.raises(ValueError, match="^On"):
  195:         idx.set_codes([0, 1, 2, 3, 4, 5], level=0)
  196:     assert_matching(idx.codes, original_index.codes, check_dtype=True)
  197: 
  198:     with pytest.raises(TypeError, match="^Levels"):
  199:         idx.set_levels("c", level=0)
  200:     assert_matching(idx.levels, original_index.levels, check_dtype=True)
  201: 
  202:     with pytest.raises(TypeError, match="^Codes"):
  203:         idx.set_codes(1, level=0)
  204:     assert_matching(idx.codes, original_index.codes, check_dtype=True)
  205: 
  206: 
  207: def test_set_codes(idx):
  208:     # side note - you probably wouldn't want to use levels and codes
  209:     # directly like this - but it is possible.
  210:     codes = idx.codes
  211:     major_codes, minor_codes = codes
  212:     major_codes = [(x + 1) % 3 for x in major_codes]
  213:     minor_codes = [(x + 1) % 1 for x in minor_codes]
  214:     new_codes = [major_codes, minor_codes]
  215: 
  216:     # changing codes w/o mutation
  217:     ind2 = idx.set_codes(new_codes)
  218:     assert_matching(ind2.codes, new_codes)
  219:     assert_matching(idx.codes, codes)
  220: 
  221:     # codes changing specific level w/o mutation
  222:     ind2 = idx.set_codes(new_codes[0], level=0)
  223:     assert_matching(ind2.codes, [new_codes[0], codes[1]])
  224:     assert_matching(idx.codes, codes)
  225: 
  226:     ind2 = idx.set_codes(new_codes[1], level=1)
  227:     assert_matching(ind2.codes, [codes[0], new_codes[1]])
  228:     assert_matching(idx.codes, codes)
  229: 
  230:     # codes changing multiple levels w/o mutation
  231:     ind2 = idx.set_codes(new_codes, level=[0, 1])
  232:     assert_matching(ind2.codes, new_codes)
  233:     assert_matching(idx.codes, codes)
  234: 
  235:     # label changing for levels of different magnitude of categories
  236:     ind = MultiIndex.from_tuples([(0, i) for i in range(130)])
  237:     new_codes = range(129, -1, -1)
  238:     expected = MultiIndex.from_tuples([(0, i) for i in new_codes])
  239: 
  240:     # [w/o mutation]
  241:     result = ind.set_codes(codes=new_codes, level=1)
  242:     assert result.equals(expected)
  243: 
  244: 
  245: def test_set_levels_codes_names_bad_input(idx):
  246:     levels, codes = idx.levels, idx.codes
  247:     names = idx.names
  248: 
  249:     with pytest.raises(ValueError, match="Length of levels"):
  250:         idx.set_levels([levels[0]])
  251: 
  252:     with pytest.raises(ValueError, match="Length of codes"):
  253:         idx.set_codes([codes[0]])
  254: 
  255:     with pytest.raises(ValueError, match="Length of names"):
  256:         idx.set_names([names[0]])
  257: 
  258:     # shouldn't scalar data error, instead should demand list-like
  259:     with pytest.raises(TypeError, match="list of lists-like"):
  260:         idx.set_levels(levels[0])
  261: 
  262:     # shouldn't scalar data error, instead should demand list-like
  263:     with pytest.raises(TypeError, match="list of lists-like"):
  264:         idx.set_codes(codes[0])
  265: 
  266:     # shouldn't scalar data error, instead should demand list-like
  267:     with pytest.raises(TypeError, match="list-like"):
  268:         idx.set_names(names[0])
  269: 
  270:     # should have equal lengths
  271:     with pytest.raises(TypeError, match="list of lists-like"):
  272:         idx.set_levels(levels[0], level=[0, 1])
  273: 
  274:     with pytest.raises(TypeError, match="list-like"):
  275:         idx.set_levels(levels, level=0)
  276: 
  277:     # should have equal lengths
  278:     with pytest.raises(TypeError, match="list of lists-like"):
  279:         idx.set_codes(codes[0], level=[0, 1])
  280: 
  281:     with pytest.raises(TypeError, match="list-like"):
  282:         idx.set_codes(codes, level=0)
  283: 
  284:     # should have equal lengths
  285:     with pytest.raises(ValueError, match="Length of names"):
  286:         idx.set_names(names[0], level=[0, 1])
  287: 
  288:     with pytest.raises(TypeError, match="Names must be a"):
  289:         idx.set_names(names, level=0)
  290: 
  291: 
  292: @pytest.mark.parametrize("inplace", [True, False])
  293: def test_set_names_with_nlevel_1(inplace):
  294:     # GH 21149
  295:     # Ensure that .set_names for MultiIndex with
  296:     # nlevels == 1 does not raise any errors
  297:     expected = MultiIndex(levels=[[0, 1]], codes=[[0, 1]], names=["first"])
  298:     m = MultiIndex.from_product([[0, 1]])
  299:     result = m.set_names("first", level=0, inplace=inplace)
  300: 
  301:     if inplace:
  302:         result = m
  303: 
  304:     tm.assert_index_equal(result, expected)
  305: 
  306: 
  307: @pytest.mark.parametrize("ordered", [True, False])
  308: def test_set_levels_categorical(ordered):
  309:     # GH13854
  310:     index = MultiIndex.from_arrays([list("xyzx"), [0, 1, 2, 3]])
  311: 
  312:     cidx = CategoricalIndex(list("bac"), ordered=ordered)
  313:     result = index.set_levels(cidx, level=0)
  314:     expected = MultiIndex(levels=[cidx, [0, 1, 2, 3]], codes=index.codes)
  315:     tm.assert_index_equal(result, expected)
  316: 
  317:     result_lvl = result.get_level_values(0)
  318:     expected_lvl = CategoricalIndex(
  319:         list("bacb"), categories=cidx.categories, ordered=cidx.ordered
  320:     )
  321:     tm.assert_index_equal(result_lvl, expected_lvl)
  322: 
  323: 
  324: def test_set_value_keeps_names():
  325:     # motivating example from #3742
  326:     lev1 = ["hans", "hans", "hans", "grethe", "grethe", "grethe"]
  327:     lev2 = ["1", "2", "3"] * 2
  328:     idx = MultiIndex.from_arrays([lev1, lev2], names=["Name", "Number"])
  329:     df = pd.DataFrame(
  330:         np.random.default_rng(2).standard_normal((6, 4)),
  331:         columns=["one", "two", "three", "four"],
  332:         index=idx,
  333:     )
  334:     df = df.sort_index()
  335:     assert df._is_copy is None
  336:     assert df.index.names == ("Name", "Number")
  337:     df.at[("grethe", "4"), "one"] = 99.34
  338:     assert df._is_copy is None
  339:     assert df.index.names == ("Name", "Number")
  340: 
  341: 
  342: def test_set_levels_with_iterable():
  343:     # GH23273
  344:     sizes = [1, 2, 3]
  345:     colors = ["black"] * 3
  346:     index = MultiIndex.from_arrays([sizes, colors], names=["size", "color"])
  347: 
  348:     result = index.set_levels(map(int, ["3", "2", "1"]), level="size")
  349: 
  350:     expected_sizes = [3, 2, 1]
  351:     expected = MultiIndex.from_arrays([expected_sizes, colors], names=["size", "color"])
  352:     tm.assert_index_equal(result, expected)
  353: 
  354: 
  355: def test_set_empty_level():
  356:     # GH#48636
  357:     midx = MultiIndex.from_arrays([[]], names=["A"])
  358:     result = midx.set_levels(pd.DatetimeIndex([]), level=0)
  359:     expected = MultiIndex.from_arrays([pd.DatetimeIndex([])], names=["A"])
  360:     tm.assert_index_equal(result, expected)
  361: 
  362: 
  363: def test_set_levels_pos_args_removal():
  364:     # https://github.com/pandas-dev/pandas/issues/41485
  365:     idx = MultiIndex.from_tuples(
  366:         [
  367:             (1, "one"),
  368:             (3, "one"),
  369:         ],
  370:         names=["foo", "bar"],
  371:     )
  372:     with pytest.raises(TypeError, match="positional arguments"):
  373:         idx.set_levels(["a", "b", "c"], 0)
  374: 
  375:     with pytest.raises(TypeError, match="positional arguments"):
  376:         idx.set_codes([[0, 1], [1, 0]], 0)
  377: 
  378: 
  379: def test_set_levels_categorical_keep_dtype():
  380:     # GH#52125
  381:     midx = MultiIndex.from_arrays([[5, 6]])
  382:     result = midx.set_levels(levels=pd.Categorical([1, 2]), level=0)
  383:     expected = MultiIndex.from_arrays([pd.Categorical([1, 2])])
  384:     tm.assert_index_equal(result, expected)
