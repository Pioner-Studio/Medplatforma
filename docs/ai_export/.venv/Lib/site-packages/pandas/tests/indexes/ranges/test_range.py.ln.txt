    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.core.dtypes.common import ensure_platform_int
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     Index,
    9:     RangeIndex,
   10: )
   11: import pandas._testing as tm
   12: 
   13: 
   14: class TestRangeIndex:
   15:     @pytest.fixture
   16:     def simple_index(self):
   17:         return RangeIndex(start=0, stop=20, step=2)
   18: 
   19:     def test_constructor_unwraps_index(self):
   20:         result = RangeIndex(1, 3)
   21:         expected = np.array([1, 2], dtype=np.int64)
   22:         tm.assert_numpy_array_equal(result._data, expected)
   23: 
   24:     def test_can_hold_identifiers(self, simple_index):
   25:         idx = simple_index
   26:         key = idx[0]
   27:         assert idx._can_hold_identifiers_and_holds_name(key) is False
   28: 
   29:     def test_too_many_names(self, simple_index):
   30:         index = simple_index
   31:         with pytest.raises(ValueError, match="^Length"):
   32:             index.names = ["roger", "harold"]
   33: 
   34:     @pytest.mark.parametrize(
   35:         "index, start, stop, step",
   36:         [
   37:             (RangeIndex(5), 0, 5, 1),
   38:             (RangeIndex(0, 5), 0, 5, 1),
   39:             (RangeIndex(5, step=2), 0, 5, 2),
   40:             (RangeIndex(1, 5, 2), 1, 5, 2),
   41:         ],
   42:     )
   43:     def test_start_stop_step_attrs(self, index, start, stop, step):
   44:         # GH 25710
   45:         assert index.start == start
   46:         assert index.stop == stop
   47:         assert index.step == step
   48: 
   49:     def test_copy(self):
   50:         i = RangeIndex(5, name="Foo")
   51:         i_copy = i.copy()
   52:         assert i_copy is not i
   53:         assert i_copy.identical(i)
   54:         assert i_copy._range == range(0, 5, 1)
   55:         assert i_copy.name == "Foo"
   56: 
   57:     def test_repr(self):
   58:         i = RangeIndex(5, name="Foo")
   59:         result = repr(i)
   60:         expected = "RangeIndex(start=0, stop=5, step=1, name='Foo')"
   61:         assert result == expected
   62: 
   63:         result = eval(result)
   64:         tm.assert_index_equal(result, i, exact=True)
   65: 
   66:         i = RangeIndex(5, 0, -1)
   67:         result = repr(i)
   68:         expected = "RangeIndex(start=5, stop=0, step=-1)"
   69:         assert result == expected
   70: 
   71:         result = eval(result)
   72:         tm.assert_index_equal(result, i, exact=True)
   73: 
   74:     def test_insert(self):
   75:         idx = RangeIndex(5, name="Foo")
   76:         result = idx[1:4]
   77: 
   78:         # test 0th element
   79:         tm.assert_index_equal(idx[0:4], result.insert(0, idx[0]), exact="equiv")
   80: 
   81:         # GH 18295 (test missing)
   82:         expected = Index([0, np.nan, 1, 2, 3, 4], dtype=np.float64)
   83:         for na in [np.nan, None, pd.NA]:
   84:             result = RangeIndex(5).insert(1, na)
   85:             tm.assert_index_equal(result, expected)
   86: 
   87:         result = RangeIndex(5).insert(1, pd.NaT)
   88:         expected = Index([0, pd.NaT, 1, 2, 3, 4], dtype=object)
   89:         tm.assert_index_equal(result, expected)
   90: 
   91:     def test_insert_edges_preserves_rangeindex(self):
   92:         idx = Index(range(4, 9, 2))
   93: 
   94:         result = idx.insert(0, 2)
   95:         expected = Index(range(2, 9, 2))
   96:         tm.assert_index_equal(result, expected, exact=True)
   97: 
   98:         result = idx.insert(3, 10)
   99:         expected = Index(range(4, 11, 2))
  100:         tm.assert_index_equal(result, expected, exact=True)
  101: 
  102:     def test_insert_middle_preserves_rangeindex(self):
  103:         # insert in the middle
  104:         idx = Index(range(0, 3, 2))
  105:         result = idx.insert(1, 1)
  106:         expected = Index(range(3))
  107:         tm.assert_index_equal(result, expected, exact=True)
  108: 
  109:         idx = idx * 2
  110:         result = idx.insert(1, 2)
  111:         expected = expected * 2
  112:         tm.assert_index_equal(result, expected, exact=True)
  113: 
  114:     def test_delete(self):
  115:         idx = RangeIndex(5, name="Foo")
  116:         expected = idx[1:]
  117:         result = idx.delete(0)
  118:         tm.assert_index_equal(result, expected, exact=True)
  119:         assert result.name == expected.name
  120: 
  121:         expected = idx[:-1]
  122:         result = idx.delete(-1)
  123:         tm.assert_index_equal(result, expected, exact=True)
  124:         assert result.name == expected.name
  125: 
  126:         msg = "index 5 is out of bounds for axis 0 with size 5"
  127:         with pytest.raises((IndexError, ValueError), match=msg):
  128:             # either depending on numpy version
  129:             result = idx.delete(len(idx))
  130: 
  131:     def test_delete_preserves_rangeindex(self):
  132:         idx = Index(range(2), name="foo")
  133: 
  134:         result = idx.delete([1])
  135:         expected = Index(range(1), name="foo")
  136:         tm.assert_index_equal(result, expected, exact=True)
  137: 
  138:         result = idx.delete(1)
  139:         tm.assert_index_equal(result, expected, exact=True)
  140: 
  141:     def test_delete_preserves_rangeindex_middle(self):
  142:         idx = Index(range(3), name="foo")
  143:         result = idx.delete(1)
  144:         expected = idx[::2]
  145:         tm.assert_index_equal(result, expected, exact=True)
  146: 
  147:         result = idx.delete(-2)
  148:         tm.assert_index_equal(result, expected, exact=True)
  149: 
  150:     def test_delete_preserves_rangeindex_list_at_end(self):
  151:         idx = RangeIndex(0, 6, 1)
  152: 
  153:         loc = [2, 3, 4, 5]
  154:         result = idx.delete(loc)
  155:         expected = idx[:2]
  156:         tm.assert_index_equal(result, expected, exact=True)
  157: 
  158:         result = idx.delete(loc[::-1])
  159:         tm.assert_index_equal(result, expected, exact=True)
  160: 
  161:     def test_delete_preserves_rangeindex_list_middle(self):
  162:         idx = RangeIndex(0, 6, 1)
  163: 
  164:         loc = [1, 2, 3, 4]
  165:         result = idx.delete(loc)
  166:         expected = RangeIndex(0, 6, 5)
  167:         tm.assert_index_equal(result, expected, exact=True)
  168: 
  169:         result = idx.delete(loc[::-1])
  170:         tm.assert_index_equal(result, expected, exact=True)
  171: 
  172:     def test_delete_all_preserves_rangeindex(self):
  173:         idx = RangeIndex(0, 6, 1)
  174: 
  175:         loc = [0, 1, 2, 3, 4, 5]
  176:         result = idx.delete(loc)
  177:         expected = idx[:0]
  178:         tm.assert_index_equal(result, expected, exact=True)
  179: 
  180:         result = idx.delete(loc[::-1])
  181:         tm.assert_index_equal(result, expected, exact=True)
  182: 
  183:     def test_delete_not_preserving_rangeindex(self):
  184:         idx = RangeIndex(0, 6, 1)
  185: 
  186:         loc = [0, 3, 5]
  187:         result = idx.delete(loc)
  188:         expected = Index([1, 2, 4])
  189:         tm.assert_index_equal(result, expected, exact=True)
  190: 
  191:         result = idx.delete(loc[::-1])
  192:         tm.assert_index_equal(result, expected, exact=True)
  193: 
  194:     def test_view(self):
  195:         i = RangeIndex(0, name="Foo")
  196:         i_view = i.view()
  197:         assert i_view.name == "Foo"
  198: 
  199:         i_view = i.view("i8")
  200:         tm.assert_numpy_array_equal(i.values, i_view)
  201: 
  202:         msg = "Passing a type in RangeIndex.view is deprecated"
  203:         with tm.assert_produces_warning(FutureWarning, match=msg):
  204:             i_view = i.view(RangeIndex)
  205:         tm.assert_index_equal(i, i_view)
  206: 
  207:     def test_dtype(self, simple_index):
  208:         index = simple_index
  209:         assert index.dtype == np.int64
  210: 
  211:     def test_cache(self):
  212:         # GH 26565, GH26617, GH35432, GH53387
  213:         # This test checks whether _cache has been set.
  214:         # Calling RangeIndex._cache["_data"] creates an int64 array of the same length
  215:         # as the RangeIndex and stores it in _cache.
  216:         idx = RangeIndex(0, 100, 10)
  217: 
  218:         assert idx._cache == {}
  219: 
  220:         repr(idx)
  221:         assert idx._cache == {}
  222: 
  223:         str(idx)
  224:         assert idx._cache == {}
  225: 
  226:         idx.get_loc(20)
  227:         assert idx._cache == {}
  228: 
  229:         90 in idx  # True
  230:         assert idx._cache == {}
  231: 
  232:         91 in idx  # False
  233:         assert idx._cache == {}
  234: 
  235:         idx.all()
  236:         assert idx._cache == {}
  237: 
  238:         idx.any()
  239:         assert idx._cache == {}
  240: 
  241:         for _ in idx:
  242:             pass
  243:         assert idx._cache == {}
  244: 
  245:         msg = "RangeIndex.format is deprecated"
  246:         with tm.assert_produces_warning(FutureWarning, match=msg):
  247:             idx.format()
  248:         assert idx._cache == {}
  249: 
  250:         df = pd.DataFrame({"a": range(10)}, index=idx)
  251: 
  252:         # df.__repr__ should not populate index cache
  253:         str(df)
  254:         assert idx._cache == {}
  255: 
  256:         df.loc[50]
  257:         assert idx._cache == {}
  258: 
  259:         with pytest.raises(KeyError, match="51"):
  260:             df.loc[51]
  261:         assert idx._cache == {}
  262: 
  263:         df.loc[10:50]
  264:         assert idx._cache == {}
  265: 
  266:         df.iloc[5:10]
  267:         assert idx._cache == {}
  268: 
  269:         # after calling take, _cache may contain other keys, but not "_data"
  270:         idx.take([3, 0, 1])
  271:         assert "_data" not in idx._cache
  272: 
  273:         df.loc[[50]]
  274:         assert "_data" not in idx._cache
  275: 
  276:         df.iloc[[5, 6, 7, 8, 9]]
  277:         assert "_data" not in idx._cache
  278: 
  279:         # idx._cache should contain a _data entry after call to idx._data
  280:         idx._data
  281:         assert isinstance(idx._data, np.ndarray)
  282:         assert idx._data is idx._data  # check cached value is reused
  283:         assert "_data" in idx._cache
  284:         expected = np.arange(0, 100, 10, dtype="int64")
  285:         tm.assert_numpy_array_equal(idx._cache["_data"], expected)
  286: 
  287:     def test_is_monotonic(self):
  288:         index = RangeIndex(0, 20, 2)
  289:         assert index.is_monotonic_increasing is True
  290:         assert index.is_monotonic_increasing is True
  291:         assert index.is_monotonic_decreasing is False
  292:         assert index._is_strictly_monotonic_increasing is True
  293:         assert index._is_strictly_monotonic_decreasing is False
  294: 
  295:         index = RangeIndex(4, 0, -1)
  296:         assert index.is_monotonic_increasing is False
  297:         assert index._is_strictly_monotonic_increasing is False
  298:         assert index.is_monotonic_decreasing is True
  299:         assert index._is_strictly_monotonic_decreasing is True
  300: 
  301:         index = RangeIndex(1, 2)
  302:         assert index.is_monotonic_increasing is True
  303:         assert index.is_monotonic_increasing is True
  304:         assert index.is_monotonic_decreasing is True
  305:         assert index._is_strictly_monotonic_increasing is True
  306:         assert index._is_strictly_monotonic_decreasing is True
  307: 
  308:         index = RangeIndex(2, 1)
  309:         assert index.is_monotonic_increasing is True
  310:         assert index.is_monotonic_increasing is True
  311:         assert index.is_monotonic_decreasing is True
  312:         assert index._is_strictly_monotonic_increasing is True
  313:         assert index._is_strictly_monotonic_decreasing is True
  314: 
  315:         index = RangeIndex(1, 1)
  316:         assert index.is_monotonic_increasing is True
  317:         assert index.is_monotonic_increasing is True
  318:         assert index.is_monotonic_decreasing is True
  319:         assert index._is_strictly_monotonic_increasing is True
  320:         assert index._is_strictly_monotonic_decreasing is True
  321: 
  322:     @pytest.mark.parametrize(
  323:         "left,right",
  324:         [
  325:             (RangeIndex(0, 9, 2), RangeIndex(0, 10, 2)),
  326:             (RangeIndex(0), RangeIndex(1, -1, 3)),
  327:             (RangeIndex(1, 2, 3), RangeIndex(1, 3, 4)),
  328:             (RangeIndex(0, -9, -2), RangeIndex(0, -10, -2)),
  329:         ],
  330:     )
  331:     def test_equals_range(self, left, right):
  332:         assert left.equals(right)
  333:         assert right.equals(left)
  334: 
  335:     def test_logical_compat(self, simple_index):
  336:         idx = simple_index
  337:         assert idx.all() == idx.values.all()
  338:         assert idx.any() == idx.values.any()
  339: 
  340:     def test_identical(self, simple_index):
  341:         index = simple_index
  342:         i = Index(index.copy())
  343:         assert i.identical(index)
  344: 
  345:         # we don't allow object dtype for RangeIndex
  346:         if isinstance(index, RangeIndex):
  347:             return
  348: 
  349:         same_values_different_type = Index(i, dtype=object)
  350:         assert not i.identical(same_values_different_type)
  351: 
  352:         i = index.copy(dtype=object)
  353:         i = i.rename("foo")
  354:         same_values = Index(i, dtype=object)
  355:         assert same_values.identical(index.copy(dtype=object))
  356: 
  357:         assert not i.identical(index)
  358:         assert Index(same_values, name="foo", dtype=object).identical(i)
  359: 
  360:         assert not index.copy(dtype=object).identical(index.copy(dtype="int64"))
  361: 
  362:     def test_nbytes(self):
  363:         # memory savings vs int index
  364:         idx = RangeIndex(0, 1000)
  365:         assert idx.nbytes < Index(idx._values).nbytes / 10
  366: 
  367:         # constant memory usage
  368:         i2 = RangeIndex(0, 10)
  369:         assert idx.nbytes == i2.nbytes
  370: 
  371:     @pytest.mark.parametrize(
  372:         "start,stop,step",
  373:         [
  374:             # can't
  375:             ("foo", "bar", "baz"),
  376:             # shouldn't
  377:             ("0", "1", "2"),
  378:         ],
  379:     )
  380:     def test_cant_or_shouldnt_cast(self, start, stop, step):
  381:         msg = f"Wrong type {type(start)} for value {start}"
  382:         with pytest.raises(TypeError, match=msg):
  383:             RangeIndex(start, stop, step)
  384: 
  385:     def test_view_index(self, simple_index):
  386:         index = simple_index
  387:         msg = "Passing a type in RangeIndex.view is deprecated"
  388:         with tm.assert_produces_warning(FutureWarning, match=msg):
  389:             index.view(Index)
  390: 
  391:     def test_prevent_casting(self, simple_index):
  392:         index = simple_index
  393:         result = index.astype("O")
  394:         assert result.dtype == np.object_
  395: 
  396:     def test_repr_roundtrip(self, simple_index):
  397:         index = simple_index
  398:         tm.assert_index_equal(eval(repr(index)), index)
  399: 
  400:     def test_slice_keep_name(self):
  401:         idx = RangeIndex(1, 2, name="asdf")
  402:         assert idx.name == idx[1:].name
  403: 
  404:     @pytest.mark.parametrize(
  405:         "index",
  406:         [
  407:             RangeIndex(start=0, stop=20, step=2, name="foo"),
  408:             RangeIndex(start=18, stop=-1, step=-2, name="bar"),
  409:         ],
  410:         ids=["index_inc", "index_dec"],
  411:     )
  412:     def test_has_duplicates(self, index):
  413:         assert index.is_unique
  414:         assert not index.has_duplicates
  415: 
  416:     def test_extended_gcd(self, simple_index):
  417:         index = simple_index
  418:         result = index._extended_gcd(6, 10)
  419:         assert result[0] == result[1] * 6 + result[2] * 10
  420:         assert 2 == result[0]
  421: 
  422:         result = index._extended_gcd(10, 6)
  423:         assert 2 == result[1] * 10 + result[2] * 6
  424:         assert 2 == result[0]
  425: 
  426:     def test_min_fitting_element(self):
  427:         result = RangeIndex(0, 20, 2)._min_fitting_element(1)
  428:         assert 2 == result
  429: 
  430:         result = RangeIndex(1, 6)._min_fitting_element(1)
  431:         assert 1 == result
  432: 
  433:         result = RangeIndex(18, -2, -2)._min_fitting_element(1)
  434:         assert 2 == result
  435: 
  436:         result = RangeIndex(5, 0, -1)._min_fitting_element(1)
  437:         assert 1 == result
  438: 
  439:         big_num = 500000000000000000000000
  440: 
  441:         result = RangeIndex(5, big_num * 2, 1)._min_fitting_element(big_num)
  442:         assert big_num == result
  443: 
  444:     def test_slice_specialised(self, simple_index):
  445:         index = simple_index
  446:         index.name = "foo"
  447: 
  448:         # scalar indexing
  449:         res = index[1]
  450:         expected = 2
  451:         assert res == expected
  452: 
  453:         res = index[-1]
  454:         expected = 18
  455:         assert res == expected
  456: 
  457:         # slicing
  458:         # slice value completion
  459:         index_slice = index[:]
  460:         expected = index
  461:         tm.assert_index_equal(index_slice, expected)
  462: 
  463:         # positive slice values
  464:         index_slice = index[7:10:2]
  465:         expected = Index([14, 18], name="foo")
  466:         tm.assert_index_equal(index_slice, expected, exact="equiv")
  467: 
  468:         # negative slice values
  469:         index_slice = index[-1:-5:-2]
  470:         expected = Index([18, 14], name="foo")
  471:         tm.assert_index_equal(index_slice, expected, exact="equiv")
  472: 
  473:         # stop overshoot
  474:         index_slice = index[2:100:4]
  475:         expected = Index([4, 12], name="foo")
  476:         tm.assert_index_equal(index_slice, expected, exact="equiv")
  477: 
  478:         # reverse
  479:         index_slice = index[::-1]
  480:         expected = Index(index.values[::-1], name="foo")
  481:         tm.assert_index_equal(index_slice, expected, exact="equiv")
  482: 
  483:         index_slice = index[-8::-1]
  484:         expected = Index([4, 2, 0], name="foo")
  485:         tm.assert_index_equal(index_slice, expected, exact="equiv")
  486: 
  487:         index_slice = index[-40::-1]
  488:         expected = Index(np.array([], dtype=np.int64), name="foo")
  489:         tm.assert_index_equal(index_slice, expected, exact="equiv")
  490: 
  491:         index_slice = index[40::-1]
  492:         expected = Index(index.values[40::-1], name="foo")
  493:         tm.assert_index_equal(index_slice, expected, exact="equiv")
  494: 
  495:         index_slice = index[10::-1]
  496:         expected = Index(index.values[::-1], name="foo")
  497:         tm.assert_index_equal(index_slice, expected, exact="equiv")
  498: 
  499:     @pytest.mark.parametrize("step", set(range(-5, 6)) - {0})
  500:     def test_len_specialised(self, step):
  501:         # make sure that our len is the same as np.arange calc
  502:         start, stop = (0, 5) if step > 0 else (5, 0)
  503: 
  504:         arr = np.arange(start, stop, step)
  505:         index = RangeIndex(start, stop, step)
  506:         assert len(index) == len(arr)
  507: 
  508:         index = RangeIndex(stop, start, step)
  509:         assert len(index) == 0
  510: 
  511:     @pytest.mark.parametrize(
  512:         "indices, expected",
  513:         [
  514:             ([RangeIndex(1, 12, 5)], RangeIndex(1, 12, 5)),
  515:             ([RangeIndex(0, 6, 4)], RangeIndex(0, 6, 4)),
  516:             ([RangeIndex(1, 3), RangeIndex(3, 7)], RangeIndex(1, 7)),
  517:             ([RangeIndex(1, 5, 2), RangeIndex(5, 6)], RangeIndex(1, 6, 2)),
  518:             ([RangeIndex(1, 3, 2), RangeIndex(4, 7, 3)], RangeIndex(1, 7, 3)),
  519:             ([RangeIndex(-4, 3, 2), RangeIndex(4, 7, 2)], RangeIndex(-4, 7, 2)),
  520:             ([RangeIndex(-4, -8), RangeIndex(-8, -12)], RangeIndex(0, 0)),
  521:             ([RangeIndex(-4, -8), RangeIndex(3, -4)], RangeIndex(0, 0)),
  522:             ([RangeIndex(-4, -8), RangeIndex(3, 5)], RangeIndex(3, 5)),
  523:             ([RangeIndex(-4, -2), RangeIndex(3, 5)], Index([-4, -3, 3, 4])),
  524:             ([RangeIndex(-2), RangeIndex(3, 5)], RangeIndex(3, 5)),
  525:             ([RangeIndex(2), RangeIndex(2)], Index([0, 1, 0, 1])),
  526:             ([RangeIndex(2), RangeIndex(2, 5), RangeIndex(5, 8, 4)], RangeIndex(0, 6)),
  527:             (
  528:                 [RangeIndex(2), RangeIndex(3, 5), RangeIndex(5, 8, 4)],
  529:                 Index([0, 1, 3, 4, 5]),
  530:             ),
  531:             (
  532:                 [RangeIndex(-2, 2), RangeIndex(2, 5), RangeIndex(5, 8, 4)],
  533:                 RangeIndex(-2, 6),
  534:             ),
  535:             ([RangeIndex(3), Index([-1, 3, 15])], Index([0, 1, 2, -1, 3, 15])),
  536:             ([RangeIndex(3), Index([-1, 3.1, 15.0])], Index([0, 1, 2, -1, 3.1, 15.0])),
  537:             ([RangeIndex(3), Index(["a", None, 14])], Index([0, 1, 2, "a", None, 14])),
  538:             ([RangeIndex(3, 1), Index(["a", None, 14])], Index(["a", None, 14])),
  539:         ],
  540:     )
  541:     def test_append(self, indices, expected):
  542:         # GH16212
  543:         result = indices[0].append(indices[1:])
  544:         tm.assert_index_equal(result, expected, exact=True)
  545: 
  546:         if len(indices) == 2:
  547:             # Append single item rather than list
  548:             result2 = indices[0].append(indices[1])
  549:             tm.assert_index_equal(result2, expected, exact=True)
  550: 
  551:     def test_engineless_lookup(self):
  552:         # GH 16685
  553:         # Standard lookup on RangeIndex should not require the engine to be
  554:         # created
  555:         idx = RangeIndex(2, 10, 3)
  556: 
  557:         assert idx.get_loc(5) == 1
  558:         tm.assert_numpy_array_equal(
  559:             idx.get_indexer([2, 8]), ensure_platform_int(np.array([0, 2]))
  560:         )
  561:         with pytest.raises(KeyError, match="3"):
  562:             idx.get_loc(3)
  563: 
  564:         assert "_engine" not in idx._cache
  565: 
  566:         # Different types of scalars can be excluded immediately, no need to
  567:         #  use the _engine
  568:         with pytest.raises(KeyError, match="'a'"):
  569:             idx.get_loc("a")
  570: 
  571:         assert "_engine" not in idx._cache
  572: 
  573:     def test_format_empty(self):
  574:         # GH35712
  575:         empty_idx = RangeIndex(0)
  576:         msg = r"RangeIndex\.format is deprecated"
  577:         with tm.assert_produces_warning(FutureWarning, match=msg):
  578:             assert empty_idx.format() == []
  579:         with tm.assert_produces_warning(FutureWarning, match=msg):
  580:             assert empty_idx.format(name=True) == [""]
  581: 
  582:     @pytest.mark.parametrize(
  583:         "ri",
  584:         [
  585:             RangeIndex(0, -1, -1),
  586:             RangeIndex(0, 1, 1),
  587:             RangeIndex(1, 3, 2),
  588:             RangeIndex(0, -1, -2),
  589:             RangeIndex(-3, -5, -2),
  590:         ],
  591:     )
  592:     def test_append_len_one(self, ri):
  593:         # GH39401
  594:         result = ri.append([])
  595:         tm.assert_index_equal(result, ri, exact=True)
  596: 
  597:     @pytest.mark.parametrize("base", [RangeIndex(0, 2), Index([0, 1])])
  598:     def test_isin_range(self, base):
  599:         # GH#41151
  600:         values = RangeIndex(0, 1)
  601:         result = base.isin(values)
  602:         expected = np.array([True, False])
  603:         tm.assert_numpy_array_equal(result, expected)
  604: 
  605:     def test_sort_values_key(self):
  606:         # GH#43666, GH#52764
  607:         sort_order = {8: 2, 6: 0, 4: 8, 2: 10, 0: 12}
  608:         values = RangeIndex(0, 10, 2)
  609:         result = values.sort_values(key=lambda x: x.map(sort_order))
  610:         expected = Index([6, 8, 4, 2, 0], dtype="int64")
  611:         tm.assert_index_equal(result, expected, check_exact=True)
  612: 
  613:         # check this matches the Series.sort_values behavior
  614:         ser = values.to_series()
  615:         result2 = ser.sort_values(key=lambda x: x.map(sort_order))
  616:         tm.assert_series_equal(result2, expected.to_series(), check_exact=True)
  617: 
  618:     def test_range_index_rsub_by_const(self):
  619:         # GH#53255
  620:         result = 3 - RangeIndex(0, 4, 1)
  621:         expected = RangeIndex(3, -1, -1)
  622:         tm.assert_index_equal(result, expected)
