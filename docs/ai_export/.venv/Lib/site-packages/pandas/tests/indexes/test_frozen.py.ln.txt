    1: import re
    2: 
    3: import pytest
    4: 
    5: from pandas.core.indexes.frozen import FrozenList
    6: 
    7: 
    8: @pytest.fixture
    9: def lst():
   10:     return [1, 2, 3, 4, 5]
   11: 
   12: 
   13: @pytest.fixture
   14: def container(lst):
   15:     return FrozenList(lst)
   16: 
   17: 
   18: @pytest.fixture
   19: def unicode_container():
   20:     return FrozenList(["\u05d0", "\u05d1", "c"])
   21: 
   22: 
   23: class TestFrozenList:
   24:     def check_mutable_error(self, *args, **kwargs):
   25:         # Pass whatever function you normally would to pytest.raises
   26:         # (after the Exception kind).
   27:         mutable_regex = re.compile("does not support mutable operations")
   28:         msg = "'(_s)?re.(SRE_)?Pattern' object is not callable"
   29:         with pytest.raises(TypeError, match=msg):
   30:             mutable_regex(*args, **kwargs)
   31: 
   32:     def test_no_mutable_funcs(self, container):
   33:         def setitem():
   34:             container[0] = 5
   35: 
   36:         self.check_mutable_error(setitem)
   37: 
   38:         def setslice():
   39:             container[1:2] = 3
   40: 
   41:         self.check_mutable_error(setslice)
   42: 
   43:         def delitem():
   44:             del container[0]
   45: 
   46:         self.check_mutable_error(delitem)
   47: 
   48:         def delslice():
   49:             del container[0:3]
   50: 
   51:         self.check_mutable_error(delslice)
   52: 
   53:         mutable_methods = ("extend", "pop", "remove", "insert")
   54: 
   55:         for meth in mutable_methods:
   56:             self.check_mutable_error(getattr(container, meth))
   57: 
   58:     def test_slicing_maintains_type(self, container, lst):
   59:         result = container[1:2]
   60:         expected = lst[1:2]
   61:         self.check_result(result, expected)
   62: 
   63:     def check_result(self, result, expected):
   64:         assert isinstance(result, FrozenList)
   65:         assert result == expected
   66: 
   67:     def test_string_methods_dont_fail(self, container):
   68:         repr(container)
   69:         str(container)
   70:         bytes(container)
   71: 
   72:     def test_tricky_container(self, unicode_container):
   73:         repr(unicode_container)
   74:         str(unicode_container)
   75: 
   76:     def test_add(self, container, lst):
   77:         result = container + (1, 2, 3)
   78:         expected = FrozenList(lst + [1, 2, 3])
   79:         self.check_result(result, expected)
   80: 
   81:         result = (1, 2, 3) + container
   82:         expected = FrozenList([1, 2, 3] + lst)
   83:         self.check_result(result, expected)
   84: 
   85:     def test_iadd(self, container, lst):
   86:         q = r = container
   87: 
   88:         q += [5]
   89:         self.check_result(q, lst + [5])
   90: 
   91:         # Other shouldn't be mutated.
   92:         self.check_result(r, lst)
   93: 
   94:     def test_union(self, container, lst):
   95:         result = container.union((1, 2, 3))
   96:         expected = FrozenList(lst + [1, 2, 3])
   97:         self.check_result(result, expected)
   98: 
   99:     def test_difference(self, container):
  100:         result = container.difference([2])
  101:         expected = FrozenList([1, 3, 4, 5])
  102:         self.check_result(result, expected)
  103: 
  104:     def test_difference_dupe(self):
  105:         result = FrozenList([1, 2, 3, 2]).difference([2])
  106:         expected = FrozenList([1, 3])
  107:         self.check_result(result, expected)
  108: 
  109:     def test_tricky_container_to_bytes_raises(self, unicode_container):
  110:         # GH 26447
  111:         msg = "^'str' object cannot be interpreted as an integer$"
  112:         with pytest.raises(TypeError, match=msg):
  113:             bytes(unicode_container)
