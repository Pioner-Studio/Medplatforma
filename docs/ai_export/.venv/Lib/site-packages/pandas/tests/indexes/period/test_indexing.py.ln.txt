    1: from datetime import datetime
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas._libs.tslibs import period as libperiod
    8: from pandas.errors import InvalidIndexError
    9: 
   10: import pandas as pd
   11: from pandas import (
   12:     DatetimeIndex,
   13:     NaT,
   14:     Period,
   15:     PeriodIndex,
   16:     Series,
   17:     Timedelta,
   18:     date_range,
   19:     notna,
   20:     period_range,
   21: )
   22: import pandas._testing as tm
   23: 
   24: dti4 = date_range("2016-01-01", periods=4)
   25: dti = dti4[:-1]
   26: rng = pd.Index(range(3))
   27: 
   28: 
   29: @pytest.fixture(
   30:     params=[
   31:         dti,
   32:         dti.tz_localize("UTC"),
   33:         dti.to_period("W"),
   34:         dti - dti[0],
   35:         rng,
   36:         pd.Index([1, 2, 3]),
   37:         pd.Index([2.0, 3.0, 4.0]),
   38:         pd.Index([4, 5, 6], dtype="u8"),
   39:         pd.IntervalIndex.from_breaks(dti4),
   40:     ]
   41: )
   42: def non_comparable_idx(request):
   43:     # All have length 3
   44:     return request.param
   45: 
   46: 
   47: class TestGetItem:
   48:     def test_getitem_slice_keeps_name(self):
   49:         idx = period_range("20010101", periods=10, freq="D", name="bob")
   50:         assert idx.name == idx[1:].name
   51: 
   52:     def test_getitem(self):
   53:         idx1 = period_range("2011-01-01", "2011-01-31", freq="D", name="idx")
   54: 
   55:         for idx in [idx1]:
   56:             result = idx[0]
   57:             assert result == Period("2011-01-01", freq="D")
   58: 
   59:             result = idx[-1]
   60:             assert result == Period("2011-01-31", freq="D")
   61: 
   62:             result = idx[0:5]
   63:             expected = period_range("2011-01-01", "2011-01-05", freq="D", name="idx")
   64:             tm.assert_index_equal(result, expected)
   65:             assert result.freq == expected.freq
   66:             assert result.freq == "D"
   67: 
   68:             result = idx[0:10:2]
   69:             expected = PeriodIndex(
   70:                 ["2011-01-01", "2011-01-03", "2011-01-05", "2011-01-07", "2011-01-09"],
   71:                 freq="D",
   72:                 name="idx",
   73:             )
   74:             tm.assert_index_equal(result, expected)
   75:             assert result.freq == expected.freq
   76:             assert result.freq == "D"
   77: 
   78:             result = idx[-20:-5:3]
   79:             expected = PeriodIndex(
   80:                 ["2011-01-12", "2011-01-15", "2011-01-18", "2011-01-21", "2011-01-24"],
   81:                 freq="D",
   82:                 name="idx",
   83:             )
   84:             tm.assert_index_equal(result, expected)
   85:             assert result.freq == expected.freq
   86:             assert result.freq == "D"
   87: 
   88:             result = idx[4::-1]
   89:             expected = PeriodIndex(
   90:                 ["2011-01-05", "2011-01-04", "2011-01-03", "2011-01-02", "2011-01-01"],
   91:                 freq="D",
   92:                 name="idx",
   93:             )
   94:             tm.assert_index_equal(result, expected)
   95:             assert result.freq == expected.freq
   96:             assert result.freq == "D"
   97: 
   98:     def test_getitem_index(self):
   99:         idx = period_range("2007-01", periods=10, freq="M", name="x")
  100: 
  101:         result = idx[[1, 3, 5]]
  102:         exp = PeriodIndex(["2007-02", "2007-04", "2007-06"], freq="M", name="x")
  103:         tm.assert_index_equal(result, exp)
  104: 
  105:         result = idx[[True, True, False, False, False, True, True, False, False, False]]
  106:         exp = PeriodIndex(
  107:             ["2007-01", "2007-02", "2007-06", "2007-07"], freq="M", name="x"
  108:         )
  109:         tm.assert_index_equal(result, exp)
  110: 
  111:     def test_getitem_partial(self):
  112:         rng = period_range("2007-01", periods=50, freq="M")
  113:         ts = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  114: 
  115:         with pytest.raises(KeyError, match=r"^'2006'$"):
  116:             ts["2006"]
  117: 
  118:         result = ts["2008"]
  119:         assert (result.index.year == 2008).all()
  120: 
  121:         result = ts["2008":"2009"]
  122:         assert len(result) == 24
  123: 
  124:         result = ts["2008-1":"2009-12"]
  125:         assert len(result) == 24
  126: 
  127:         result = ts["2008Q1":"2009Q4"]
  128:         assert len(result) == 24
  129: 
  130:         result = ts[:"2009"]
  131:         assert len(result) == 36
  132: 
  133:         result = ts["2009":]
  134:         assert len(result) == 50 - 24
  135: 
  136:         exp = result
  137:         result = ts[24:]
  138:         tm.assert_series_equal(exp, result)
  139: 
  140:         ts = pd.concat([ts[10:], ts[10:]])
  141:         msg = "left slice bound for non-unique label: '2008'"
  142:         with pytest.raises(KeyError, match=msg):
  143:             ts[slice("2008", "2009")]
  144: 
  145:     def test_getitem_datetime(self):
  146:         rng = period_range(start="2012-01-01", periods=10, freq="W-MON")
  147:         ts = Series(range(len(rng)), index=rng)
  148: 
  149:         dt1 = datetime(2011, 10, 2)
  150:         dt4 = datetime(2012, 4, 20)
  151: 
  152:         rs = ts[dt1:dt4]
  153:         tm.assert_series_equal(rs, ts)
  154: 
  155:     def test_getitem_nat(self):
  156:         idx = PeriodIndex(["2011-01", "NaT", "2011-02"], freq="M")
  157:         assert idx[0] == Period("2011-01", freq="M")
  158:         assert idx[1] is NaT
  159: 
  160:         s = Series([0, 1, 2], index=idx)
  161:         assert s[NaT] == 1
  162: 
  163:         s = Series(idx, index=idx)
  164:         assert s[Period("2011-01", freq="M")] == Period("2011-01", freq="M")
  165:         assert s[NaT] is NaT
  166: 
  167:     def test_getitem_list_periods(self):
  168:         # GH 7710
  169:         rng = period_range(start="2012-01-01", periods=10, freq="D")
  170:         ts = Series(range(len(rng)), index=rng)
  171:         exp = ts.iloc[[1]]
  172:         tm.assert_series_equal(ts[[Period("2012-01-02", freq="D")]], exp)
  173: 
  174:     @pytest.mark.arm_slow
  175:     def test_getitem_seconds(self):
  176:         # GH#6716
  177:         didx = date_range(start="2013/01/01 09:00:00", freq="s", periods=4000)
  178:         pidx = period_range(start="2013/01/01 09:00:00", freq="s", periods=4000)
  179: 
  180:         for idx in [didx, pidx]:
  181:             # getitem against index should raise ValueError
  182:             values = [
  183:                 "2014",
  184:                 "2013/02",
  185:                 "2013/01/02",
  186:                 "2013/02/01 9h",
  187:                 "2013/02/01 09:00",
  188:             ]
  189:             for val in values:
  190:                 # GH7116
  191:                 # these show deprecations as we are trying
  192:                 # to slice with non-integer indexers
  193:                 with pytest.raises(IndexError, match="only integers, slices"):
  194:                     idx[val]
  195: 
  196:             ser = Series(np.random.default_rng(2).random(len(idx)), index=idx)
  197:             tm.assert_series_equal(ser["2013/01/01 10:00"], ser[3600:3660])
  198:             tm.assert_series_equal(ser["2013/01/01 9h"], ser[:3600])
  199:             for d in ["2013/01/01", "2013/01", "2013"]:
  200:                 tm.assert_series_equal(ser[d], ser)
  201: 
  202:     @pytest.mark.parametrize(
  203:         "idx_range",
  204:         [
  205:             date_range,
  206:             period_range,
  207:         ],
  208:     )
  209:     def test_getitem_day(self, idx_range):
  210:         # GH#6716
  211:         # Confirm DatetimeIndex and PeriodIndex works identically
  212:         # getitem against index should raise ValueError
  213:         idx = idx_range(start="2013/01/01", freq="D", periods=400)
  214:         values = [
  215:             "2014",
  216:             "2013/02",
  217:             "2013/01/02",
  218:             "2013/02/01 9h",
  219:             "2013/02/01 09:00",
  220:         ]
  221:         for val in values:
  222:             # GH7116
  223:             # these show deprecations as we are trying
  224:             # to slice with non-integer indexers
  225:             with pytest.raises(IndexError, match="only integers, slices"):
  226:                 idx[val]
  227: 
  228:         ser = Series(np.random.default_rng(2).random(len(idx)), index=idx)
  229:         tm.assert_series_equal(ser["2013/01"], ser[0:31])
  230:         tm.assert_series_equal(ser["2013/02"], ser[31:59])
  231:         tm.assert_series_equal(ser["2014"], ser[365:])
  232: 
  233:         invalid = ["2013/02/01 9h", "2013/02/01 09:00"]
  234:         for val in invalid:
  235:             with pytest.raises(KeyError, match=val):
  236:                 ser[val]
  237: 
  238: 
  239: class TestGetLoc:
  240:     def test_get_loc_msg(self):
  241:         idx = period_range("2000-1-1", freq="Y", periods=10)
  242:         bad_period = Period("2012", "Y")
  243:         with pytest.raises(KeyError, match=r"^Period\('2012', 'Y-DEC'\)$"):
  244:             idx.get_loc(bad_period)
  245: 
  246:         try:
  247:             idx.get_loc(bad_period)
  248:         except KeyError as inst:
  249:             assert inst.args[0] == bad_period
  250: 
  251:     def test_get_loc_nat(self):
  252:         didx = DatetimeIndex(["2011-01-01", "NaT", "2011-01-03"])
  253:         pidx = PeriodIndex(["2011-01-01", "NaT", "2011-01-03"], freq="M")
  254: 
  255:         # check DatetimeIndex compat
  256:         for idx in [didx, pidx]:
  257:             assert idx.get_loc(NaT) == 1
  258:             assert idx.get_loc(None) == 1
  259:             assert idx.get_loc(float("nan")) == 1
  260:             assert idx.get_loc(np.nan) == 1
  261: 
  262:     def test_get_loc(self):
  263:         # GH 17717
  264:         p0 = Period("2017-09-01")
  265:         p1 = Period("2017-09-02")
  266:         p2 = Period("2017-09-03")
  267: 
  268:         # get the location of p1/p2 from
  269:         # monotonic increasing PeriodIndex with non-duplicate
  270:         idx0 = PeriodIndex([p0, p1, p2])
  271:         expected_idx1_p1 = 1
  272:         expected_idx1_p2 = 2
  273: 
  274:         assert idx0.get_loc(p1) == expected_idx1_p1
  275:         assert idx0.get_loc(str(p1)) == expected_idx1_p1
  276:         assert idx0.get_loc(p2) == expected_idx1_p2
  277:         assert idx0.get_loc(str(p2)) == expected_idx1_p2
  278: 
  279:         msg = "Cannot interpret 'foo' as period"
  280:         with pytest.raises(KeyError, match=msg):
  281:             idx0.get_loc("foo")
  282:         with pytest.raises(KeyError, match=r"^1\.1$"):
  283:             idx0.get_loc(1.1)
  284: 
  285:         with pytest.raises(InvalidIndexError, match=re.escape(str(idx0))):
  286:             idx0.get_loc(idx0)
  287: 
  288:         # get the location of p1/p2 from
  289:         # monotonic increasing PeriodIndex with duplicate
  290:         idx1 = PeriodIndex([p1, p1, p2])
  291:         expected_idx1_p1 = slice(0, 2)
  292:         expected_idx1_p2 = 2
  293: 
  294:         assert idx1.get_loc(p1) == expected_idx1_p1
  295:         assert idx1.get_loc(str(p1)) == expected_idx1_p1
  296:         assert idx1.get_loc(p2) == expected_idx1_p2
  297:         assert idx1.get_loc(str(p2)) == expected_idx1_p2
  298: 
  299:         msg = "Cannot interpret 'foo' as period"
  300:         with pytest.raises(KeyError, match=msg):
  301:             idx1.get_loc("foo")
  302: 
  303:         with pytest.raises(KeyError, match=r"^1\.1$"):
  304:             idx1.get_loc(1.1)
  305: 
  306:         with pytest.raises(InvalidIndexError, match=re.escape(str(idx1))):
  307:             idx1.get_loc(idx1)
  308: 
  309:         # get the location of p1/p2 from
  310:         # non-monotonic increasing/decreasing PeriodIndex with duplicate
  311:         idx2 = PeriodIndex([p2, p1, p2])
  312:         expected_idx2_p1 = 1
  313:         expected_idx2_p2 = np.array([True, False, True])
  314: 
  315:         assert idx2.get_loc(p1) == expected_idx2_p1
  316:         assert idx2.get_loc(str(p1)) == expected_idx2_p1
  317:         tm.assert_numpy_array_equal(idx2.get_loc(p2), expected_idx2_p2)
  318:         tm.assert_numpy_array_equal(idx2.get_loc(str(p2)), expected_idx2_p2)
  319: 
  320:     def test_get_loc_integer(self):
  321:         dti = date_range("2016-01-01", periods=3)
  322:         pi = dti.to_period("D")
  323:         with pytest.raises(KeyError, match="16801"):
  324:             pi.get_loc(16801)
  325: 
  326:         pi2 = dti.to_period("Y")  # duplicates, ordinals are all 46
  327:         with pytest.raises(KeyError, match="46"):
  328:             pi2.get_loc(46)
  329: 
  330:     def test_get_loc_invalid_string_raises_keyerror(self):
  331:         # GH#34240
  332:         pi = period_range("2000", periods=3, name="A")
  333:         with pytest.raises(KeyError, match="A"):
  334:             pi.get_loc("A")
  335: 
  336:         ser = Series([1, 2, 3], index=pi)
  337:         with pytest.raises(KeyError, match="A"):
  338:             ser.loc["A"]
  339: 
  340:         with pytest.raises(KeyError, match="A"):
  341:             ser["A"]
  342: 
  343:         assert "A" not in ser
  344:         assert "A" not in pi
  345: 
  346:     def test_get_loc_mismatched_freq(self):
  347:         # see also test_get_indexer_mismatched_dtype testing we get analogous
  348:         # behavior for get_loc
  349:         dti = date_range("2016-01-01", periods=3)
  350:         pi = dti.to_period("D")
  351:         pi2 = dti.to_period("W")
  352:         pi3 = pi.view(pi2.dtype)  # i.e. matching i8 representations
  353: 
  354:         with pytest.raises(KeyError, match="W-SUN"):
  355:             pi.get_loc(pi2[0])
  356: 
  357:         with pytest.raises(KeyError, match="W-SUN"):
  358:             # even though we have matching i8 values
  359:             pi.get_loc(pi3[0])
  360: 
  361: 
  362: class TestGetIndexer:
  363:     def test_get_indexer(self):
  364:         # GH 17717
  365:         p1 = Period("2017-09-01")
  366:         p2 = Period("2017-09-04")
  367:         p3 = Period("2017-09-07")
  368: 
  369:         tp0 = Period("2017-08-31")
  370:         tp1 = Period("2017-09-02")
  371:         tp2 = Period("2017-09-05")
  372:         tp3 = Period("2017-09-09")
  373: 
  374:         idx = PeriodIndex([p1, p2, p3])
  375: 
  376:         tm.assert_numpy_array_equal(
  377:             idx.get_indexer(idx), np.array([0, 1, 2], dtype=np.intp)
  378:         )
  379: 
  380:         target = PeriodIndex([tp0, tp1, tp2, tp3])
  381:         tm.assert_numpy_array_equal(
  382:             idx.get_indexer(target, "pad"), np.array([-1, 0, 1, 2], dtype=np.intp)
  383:         )
  384:         tm.assert_numpy_array_equal(
  385:             idx.get_indexer(target, "backfill"), np.array([0, 1, 2, -1], dtype=np.intp)
  386:         )
  387:         tm.assert_numpy_array_equal(
  388:             idx.get_indexer(target, "nearest"), np.array([0, 0, 1, 2], dtype=np.intp)
  389:         )
  390: 
  391:         res = idx.get_indexer(target, "nearest", tolerance=Timedelta("1 day"))
  392:         tm.assert_numpy_array_equal(res, np.array([0, 0, 1, -1], dtype=np.intp))
  393: 
  394:     def test_get_indexer_mismatched_dtype(self):
  395:         # Check that we return all -1s and do not raise or cast incorrectly
  396: 
  397:         dti = date_range("2016-01-01", periods=3)
  398:         pi = dti.to_period("D")
  399:         pi2 = dti.to_period("W")
  400: 
  401:         expected = np.array([-1, -1, -1], dtype=np.intp)
  402: 
  403:         result = pi.get_indexer(dti)
  404:         tm.assert_numpy_array_equal(result, expected)
  405: 
  406:         # This should work in both directions
  407:         result = dti.get_indexer(pi)
  408:         tm.assert_numpy_array_equal(result, expected)
  409: 
  410:         result = pi.get_indexer(pi2)
  411:         tm.assert_numpy_array_equal(result, expected)
  412: 
  413:         # We expect the same from get_indexer_non_unique
  414:         result = pi.get_indexer_non_unique(dti)[0]
  415:         tm.assert_numpy_array_equal(result, expected)
  416: 
  417:         result = dti.get_indexer_non_unique(pi)[0]
  418:         tm.assert_numpy_array_equal(result, expected)
  419: 
  420:         result = pi.get_indexer_non_unique(pi2)[0]
  421:         tm.assert_numpy_array_equal(result, expected)
  422: 
  423:     def test_get_indexer_mismatched_dtype_different_length(self, non_comparable_idx):
  424:         # without method we aren't checking inequalities, so get all-missing
  425:         #  but do not raise
  426:         dti = date_range("2016-01-01", periods=3)
  427:         pi = dti.to_period("D")
  428: 
  429:         other = non_comparable_idx
  430: 
  431:         res = pi[:-1].get_indexer(other)
  432:         expected = -np.ones(other.shape, dtype=np.intp)
  433:         tm.assert_numpy_array_equal(res, expected)
  434: 
  435:     @pytest.mark.parametrize("method", ["pad", "backfill", "nearest"])
  436:     def test_get_indexer_mismatched_dtype_with_method(self, non_comparable_idx, method):
  437:         dti = date_range("2016-01-01", periods=3)
  438:         pi = dti.to_period("D")
  439: 
  440:         other = non_comparable_idx
  441: 
  442:         msg = re.escape(f"Cannot compare dtypes {pi.dtype} and {other.dtype}")
  443:         with pytest.raises(TypeError, match=msg):
  444:             pi.get_indexer(other, method=method)
  445: 
  446:         for dtype in ["object", "category"]:
  447:             other2 = other.astype(dtype)
  448:             if dtype == "object" and isinstance(other, PeriodIndex):
  449:                 continue
  450:             # Two different error message patterns depending on dtypes
  451:             msg = "|".join(
  452:                 [
  453:                     re.escape(msg)
  454:                     for msg in (
  455:                         f"Cannot compare dtypes {pi.dtype} and {other.dtype}",
  456:                         " not supported between instances of ",
  457:                     )
  458:                 ]
  459:             )
  460:             with pytest.raises(TypeError, match=msg):
  461:                 pi.get_indexer(other2, method=method)
  462: 
  463:     def test_get_indexer_non_unique(self):
  464:         # GH 17717
  465:         p1 = Period("2017-09-02")
  466:         p2 = Period("2017-09-03")
  467:         p3 = Period("2017-09-04")
  468:         p4 = Period("2017-09-05")
  469: 
  470:         idx1 = PeriodIndex([p1, p2, p1])
  471:         idx2 = PeriodIndex([p2, p1, p3, p4])
  472: 
  473:         result = idx1.get_indexer_non_unique(idx2)
  474:         expected_indexer = np.array([1, 0, 2, -1, -1], dtype=np.intp)
  475:         expected_missing = np.array([2, 3], dtype=np.intp)
  476: 
  477:         tm.assert_numpy_array_equal(result[0], expected_indexer)
  478:         tm.assert_numpy_array_equal(result[1], expected_missing)
  479: 
  480:     # TODO: This method came from test_period; de-dup with version above
  481:     def test_get_indexer2(self):
  482:         idx = period_range("2000-01-01", periods=3).asfreq("h", how="start")
  483:         tm.assert_numpy_array_equal(
  484:             idx.get_indexer(idx), np.array([0, 1, 2], dtype=np.intp)
  485:         )
  486: 
  487:         target = PeriodIndex(
  488:             ["1999-12-31T23", "2000-01-01T12", "2000-01-02T01"], freq="h"
  489:         )
  490:         tm.assert_numpy_array_equal(
  491:             idx.get_indexer(target, "pad"), np.array([-1, 0, 1], dtype=np.intp)
  492:         )
  493:         tm.assert_numpy_array_equal(
  494:             idx.get_indexer(target, "backfill"), np.array([0, 1, 2], dtype=np.intp)
  495:         )
  496:         tm.assert_numpy_array_equal(
  497:             idx.get_indexer(target, "nearest"), np.array([0, 1, 1], dtype=np.intp)
  498:         )
  499:         tm.assert_numpy_array_equal(
  500:             idx.get_indexer(target, "nearest", tolerance="1 hour"),
  501:             np.array([0, -1, 1], dtype=np.intp),
  502:         )
  503: 
  504:         msg = "Input has different freq=None from PeriodArray\\(freq=h\\)"
  505:         with pytest.raises(ValueError, match=msg):
  506:             idx.get_indexer(target, "nearest", tolerance="1 minute")
  507: 
  508:         tm.assert_numpy_array_equal(
  509:             idx.get_indexer(target, "nearest", tolerance="1 day"),
  510:             np.array([0, 1, 1], dtype=np.intp),
  511:         )
  512:         tol_raw = [
  513:             Timedelta("1 hour"),
  514:             Timedelta("1 hour"),
  515:             np.timedelta64(1, "D"),
  516:         ]
  517:         tm.assert_numpy_array_equal(
  518:             idx.get_indexer(
  519:                 target, "nearest", tolerance=[np.timedelta64(x) for x in tol_raw]
  520:             ),
  521:             np.array([0, -1, 1], dtype=np.intp),
  522:         )
  523:         tol_bad = [
  524:             Timedelta("2 hour").to_timedelta64(),
  525:             Timedelta("1 hour").to_timedelta64(),
  526:             np.timedelta64(1, "M"),
  527:         ]
  528:         with pytest.raises(
  529:             libperiod.IncompatibleFrequency, match="Input has different freq=None from"
  530:         ):
  531:             idx.get_indexer(target, "nearest", tolerance=tol_bad)
  532: 
  533: 
  534: class TestWhere:
  535:     def test_where(self, listlike_box):
  536:         i = period_range("20130101", periods=5, freq="D")
  537:         cond = [True] * len(i)
  538:         expected = i
  539:         result = i.where(listlike_box(cond))
  540:         tm.assert_index_equal(result, expected)
  541: 
  542:         cond = [False] + [True] * (len(i) - 1)
  543:         expected = PeriodIndex([NaT] + i[1:].tolist(), freq="D")
  544:         result = i.where(listlike_box(cond))
  545:         tm.assert_index_equal(result, expected)
  546: 
  547:     def test_where_other(self):
  548:         i = period_range("20130101", periods=5, freq="D")
  549:         for arr in [np.nan, NaT]:
  550:             result = i.where(notna(i), other=arr)
  551:             expected = i
  552:             tm.assert_index_equal(result, expected)
  553: 
  554:         i2 = i.copy()
  555:         i2 = PeriodIndex([NaT, NaT] + i[2:].tolist(), freq="D")
  556:         result = i.where(notna(i2), i2)
  557:         tm.assert_index_equal(result, i2)
  558: 
  559:         i2 = i.copy()
  560:         i2 = PeriodIndex([NaT, NaT] + i[2:].tolist(), freq="D")
  561:         result = i.where(notna(i2), i2.values)
  562:         tm.assert_index_equal(result, i2)
  563: 
  564:     def test_where_invalid_dtypes(self):
  565:         pi = period_range("20130101", periods=5, freq="D")
  566: 
  567:         tail = pi[2:].tolist()
  568:         i2 = PeriodIndex([NaT, NaT] + tail, freq="D")
  569:         mask = notna(i2)
  570: 
  571:         result = pi.where(mask, i2.asi8)
  572:         expected = pd.Index([NaT._value, NaT._value] + tail, dtype=object)
  573:         assert isinstance(expected[0], int)
  574:         tm.assert_index_equal(result, expected)
  575: 
  576:         tdi = i2.asi8.view("timedelta64[ns]")
  577:         expected = pd.Index([tdi[0], tdi[1]] + tail, dtype=object)
  578:         assert isinstance(expected[0], np.timedelta64)
  579:         result = pi.where(mask, tdi)
  580:         tm.assert_index_equal(result, expected)
  581: 
  582:         dti = i2.to_timestamp("s")
  583:         expected = pd.Index([dti[0], dti[1]] + tail, dtype=object)
  584:         assert expected[0] is NaT
  585:         result = pi.where(mask, dti)
  586:         tm.assert_index_equal(result, expected)
  587: 
  588:         td = Timedelta(days=4)
  589:         expected = pd.Index([td, td] + tail, dtype=object)
  590:         assert expected[0] == td
  591:         result = pi.where(mask, td)
  592:         tm.assert_index_equal(result, expected)
  593: 
  594:     def test_where_mismatched_nat(self):
  595:         pi = period_range("20130101", periods=5, freq="D")
  596:         cond = np.array([True, False, True, True, False])
  597: 
  598:         tdnat = np.timedelta64("NaT", "ns")
  599:         expected = pd.Index([pi[0], tdnat, pi[2], pi[3], tdnat], dtype=object)
  600:         assert expected[1] is tdnat
  601:         result = pi.where(cond, tdnat)
  602:         tm.assert_index_equal(result, expected)
  603: 
  604: 
  605: class TestTake:
  606:     def test_take(self):
  607:         # GH#10295
  608:         idx1 = period_range("2011-01-01", "2011-01-31", freq="D", name="idx")
  609: 
  610:         for idx in [idx1]:
  611:             result = idx.take([0])
  612:             assert result == Period("2011-01-01", freq="D")
  613: 
  614:             result = idx.take([5])
  615:             assert result == Period("2011-01-06", freq="D")
  616: 
  617:             result = idx.take([0, 1, 2])
  618:             expected = period_range("2011-01-01", "2011-01-03", freq="D", name="idx")
  619:             tm.assert_index_equal(result, expected)
  620:             assert result.freq == "D"
  621:             assert result.freq == expected.freq
  622: 
  623:             result = idx.take([0, 2, 4])
  624:             expected = PeriodIndex(
  625:                 ["2011-01-01", "2011-01-03", "2011-01-05"], freq="D", name="idx"
  626:             )
  627:             tm.assert_index_equal(result, expected)
  628:             assert result.freq == expected.freq
  629:             assert result.freq == "D"
  630: 
  631:             result = idx.take([7, 4, 1])
  632:             expected = PeriodIndex(
  633:                 ["2011-01-08", "2011-01-05", "2011-01-02"], freq="D", name="idx"
  634:             )
  635:             tm.assert_index_equal(result, expected)
  636:             assert result.freq == expected.freq
  637:             assert result.freq == "D"
  638: 
  639:             result = idx.take([3, 2, 5])
  640:             expected = PeriodIndex(
  641:                 ["2011-01-04", "2011-01-03", "2011-01-06"], freq="D", name="idx"
  642:             )
  643:             tm.assert_index_equal(result, expected)
  644:             assert result.freq == expected.freq
  645:             assert result.freq == "D"
  646: 
  647:             result = idx.take([-3, 2, 5])
  648:             expected = PeriodIndex(
  649:                 ["2011-01-29", "2011-01-03", "2011-01-06"], freq="D", name="idx"
  650:             )
  651:             tm.assert_index_equal(result, expected)
  652:             assert result.freq == expected.freq
  653:             assert result.freq == "D"
  654: 
  655:     def test_take_misc(self):
  656:         index = period_range(start="1/1/10", end="12/31/12", freq="D", name="idx")
  657:         expected = PeriodIndex(
  658:             [
  659:                 datetime(2010, 1, 6),
  660:                 datetime(2010, 1, 7),
  661:                 datetime(2010, 1, 9),
  662:                 datetime(2010, 1, 13),
  663:             ],
  664:             freq="D",
  665:             name="idx",
  666:         )
  667: 
  668:         taken1 = index.take([5, 6, 8, 12])
  669:         taken2 = index[[5, 6, 8, 12]]
  670: 
  671:         for taken in [taken1, taken2]:
  672:             tm.assert_index_equal(taken, expected)
  673:             assert isinstance(taken, PeriodIndex)
  674:             assert taken.freq == index.freq
  675:             assert taken.name == expected.name
  676: 
  677:     def test_take_fill_value(self):
  678:         # GH#12631
  679:         idx = PeriodIndex(
  680:             ["2011-01-01", "2011-02-01", "2011-03-01"], name="xxx", freq="D"
  681:         )
  682:         result = idx.take(np.array([1, 0, -1]))
  683:         expected = PeriodIndex(
  684:             ["2011-02-01", "2011-01-01", "2011-03-01"], name="xxx", freq="D"
  685:         )
  686:         tm.assert_index_equal(result, expected)
  687: 
  688:         # fill_value
  689:         result = idx.take(np.array([1, 0, -1]), fill_value=True)
  690:         expected = PeriodIndex(
  691:             ["2011-02-01", "2011-01-01", "NaT"], name="xxx", freq="D"
  692:         )
  693:         tm.assert_index_equal(result, expected)
  694: 
  695:         # allow_fill=False
  696:         result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
  697:         expected = PeriodIndex(
  698:             ["2011-02-01", "2011-01-01", "2011-03-01"], name="xxx", freq="D"
  699:         )
  700:         tm.assert_index_equal(result, expected)
  701: 
  702:         msg = (
  703:             "When allow_fill=True and fill_value is not None, "
  704:             "all indices must be >= -1"
  705:         )
  706:         with pytest.raises(ValueError, match=msg):
  707:             idx.take(np.array([1, 0, -2]), fill_value=True)
  708:         with pytest.raises(ValueError, match=msg):
  709:             idx.take(np.array([1, 0, -5]), fill_value=True)
  710: 
  711:         msg = "index -5 is out of bounds for( axis 0 with)? size 3"
  712:         with pytest.raises(IndexError, match=msg):
  713:             idx.take(np.array([1, -5]))
  714: 
  715: 
  716: class TestGetValue:
  717:     @pytest.mark.parametrize("freq", ["h", "D"])
  718:     def test_get_value_datetime_hourly(self, freq):
  719:         # get_loc and get_value should treat datetime objects symmetrically
  720:         # TODO: this test used to test get_value, which is removed in 2.0.
  721:         #  should this test be moved somewhere, or is what's left redundant?
  722:         dti = date_range("2016-01-01", periods=3, freq="MS")
  723:         pi = dti.to_period(freq)
  724:         ser = Series(range(7, 10), index=pi)
  725: 
  726:         ts = dti[0]
  727: 
  728:         assert pi.get_loc(ts) == 0
  729:         assert ser[ts] == 7
  730:         assert ser.loc[ts] == 7
  731: 
  732:         ts2 = ts + Timedelta(hours=3)
  733:         if freq == "h":
  734:             with pytest.raises(KeyError, match="2016-01-01 03:00"):
  735:                 pi.get_loc(ts2)
  736:             with pytest.raises(KeyError, match="2016-01-01 03:00"):
  737:                 ser[ts2]
  738:             with pytest.raises(KeyError, match="2016-01-01 03:00"):
  739:                 ser.loc[ts2]
  740:         else:
  741:             assert pi.get_loc(ts2) == 0
  742:             assert ser[ts2] == 7
  743:             assert ser.loc[ts2] == 7
  744: 
  745: 
  746: class TestContains:
  747:     def test_contains(self):
  748:         # GH 17717
  749:         p0 = Period("2017-09-01")
  750:         p1 = Period("2017-09-02")
  751:         p2 = Period("2017-09-03")
  752:         p3 = Period("2017-09-04")
  753: 
  754:         ps0 = [p0, p1, p2]
  755:         idx0 = PeriodIndex(ps0)
  756: 
  757:         for p in ps0:
  758:             assert p in idx0
  759:             assert str(p) in idx0
  760: 
  761:         # GH#31172
  762:         # Higher-resolution period-like are _not_ considered as contained
  763:         key = "2017-09-01 00:00:01"
  764:         assert key not in idx0
  765:         with pytest.raises(KeyError, match=key):
  766:             idx0.get_loc(key)
  767: 
  768:         assert "2017-09" in idx0
  769: 
  770:         assert p3 not in idx0
  771: 
  772:     def test_contains_freq_mismatch(self):
  773:         rng = period_range("2007-01", freq="M", periods=10)
  774: 
  775:         assert Period("2007-01", freq="M") in rng
  776:         assert Period("2007-01", freq="D") not in rng
  777:         assert Period("2007-01", freq="2M") not in rng
  778: 
  779:     def test_contains_nat(self):
  780:         # see gh-13582
  781:         idx = period_range("2007-01", freq="M", periods=10)
  782:         assert NaT not in idx
  783:         assert None not in idx
  784:         assert float("nan") not in idx
  785:         assert np.nan not in idx
  786: 
  787:         idx = PeriodIndex(["2011-01", "NaT", "2011-02"], freq="M")
  788:         assert NaT in idx
  789:         assert None in idx
  790:         assert float("nan") in idx
  791:         assert np.nan in idx
  792: 
  793: 
  794: class TestAsOfLocs:
  795:     def test_asof_locs_mismatched_type(self):
  796:         dti = date_range("2016-01-01", periods=3)
  797:         pi = dti.to_period("D")
  798:         pi2 = dti.to_period("h")
  799: 
  800:         mask = np.array([0, 1, 0], dtype=bool)
  801: 
  802:         msg = "must be DatetimeIndex or PeriodIndex"
  803:         with pytest.raises(TypeError, match=msg):
  804:             pi.asof_locs(pd.Index(pi.asi8, dtype=np.int64), mask)
  805: 
  806:         with pytest.raises(TypeError, match=msg):
  807:             pi.asof_locs(pd.Index(pi.asi8, dtype=np.float64), mask)
  808: 
  809:         with pytest.raises(TypeError, match=msg):
  810:             # TimedeltaIndex
  811:             pi.asof_locs(dti - dti, mask)
  812: 
  813:         msg = "Input has different freq=h"
  814:         with pytest.raises(libperiod.IncompatibleFrequency, match=msg):
  815:             pi.asof_locs(pi2, mask)
