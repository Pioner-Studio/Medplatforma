    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._config import using_pyarrow_string_dtype
    5: 
    6: from pandas._libs import index as libindex
    7: from pandas._libs.arrays import NDArrayBacked
    8: 
    9: import pandas as pd
   10: from pandas import (
   11:     Categorical,
   12:     CategoricalDtype,
   13: )
   14: import pandas._testing as tm
   15: from pandas.core.indexes.api import (
   16:     CategoricalIndex,
   17:     Index,
   18: )
   19: 
   20: 
   21: class TestCategoricalIndex:
   22:     @pytest.fixture
   23:     def simple_index(self) -> CategoricalIndex:
   24:         return CategoricalIndex(list("aabbca"), categories=list("cab"), ordered=False)
   25: 
   26:     def test_can_hold_identifiers(self):
   27:         idx = CategoricalIndex(list("aabbca"), categories=None, ordered=False)
   28:         key = idx[0]
   29:         assert idx._can_hold_identifiers_and_holds_name(key) is True
   30: 
   31:     def test_insert(self, simple_index):
   32:         ci = simple_index
   33:         categories = ci.categories
   34: 
   35:         # test 0th element
   36:         result = ci.insert(0, "a")
   37:         expected = CategoricalIndex(list("aaabbca"), categories=categories)
   38:         tm.assert_index_equal(result, expected, exact=True)
   39: 
   40:         # test Nth element that follows Python list behavior
   41:         result = ci.insert(-1, "a")
   42:         expected = CategoricalIndex(list("aabbcaa"), categories=categories)
   43:         tm.assert_index_equal(result, expected, exact=True)
   44: 
   45:         # test empty
   46:         result = CategoricalIndex([], categories=categories).insert(0, "a")
   47:         expected = CategoricalIndex(["a"], categories=categories)
   48:         tm.assert_index_equal(result, expected, exact=True)
   49: 
   50:         # invalid -> cast to object
   51:         expected = ci.astype(object).insert(0, "d")
   52:         result = ci.insert(0, "d").astype(object)
   53:         tm.assert_index_equal(result, expected, exact=True)
   54: 
   55:         # GH 18295 (test missing)
   56:         expected = CategoricalIndex(["a", np.nan, "a", "b", "c", "b"])
   57:         for na in (np.nan, pd.NaT, None):
   58:             result = CategoricalIndex(list("aabcb")).insert(1, na)
   59:             tm.assert_index_equal(result, expected)
   60: 
   61:     def test_insert_na_mismatched_dtype(self):
   62:         ci = CategoricalIndex([0, 1, 1])
   63:         result = ci.insert(0, pd.NaT)
   64:         expected = Index([pd.NaT, 0, 1, 1], dtype=object)
   65:         tm.assert_index_equal(result, expected)
   66: 
   67:     def test_delete(self, simple_index):
   68:         ci = simple_index
   69:         categories = ci.categories
   70: 
   71:         result = ci.delete(0)
   72:         expected = CategoricalIndex(list("abbca"), categories=categories)
   73:         tm.assert_index_equal(result, expected, exact=True)
   74: 
   75:         result = ci.delete(-1)
   76:         expected = CategoricalIndex(list("aabbc"), categories=categories)
   77:         tm.assert_index_equal(result, expected, exact=True)
   78: 
   79:         with tm.external_error_raised((IndexError, ValueError)):
   80:             # Either depending on NumPy version
   81:             ci.delete(10)
   82: 
   83:     @pytest.mark.parametrize(
   84:         "data, non_lexsorted_data",
   85:         [[[1, 2, 3], [9, 0, 1, 2, 3]], [list("abc"), list("fabcd")]],
   86:     )
   87:     def test_is_monotonic(self, data, non_lexsorted_data):
   88:         c = CategoricalIndex(data)
   89:         assert c.is_monotonic_increasing is True
   90:         assert c.is_monotonic_decreasing is False
   91: 
   92:         c = CategoricalIndex(data, ordered=True)
   93:         assert c.is_monotonic_increasing is True
   94:         assert c.is_monotonic_decreasing is False
   95: 
   96:         c = CategoricalIndex(data, categories=reversed(data))
   97:         assert c.is_monotonic_increasing is False
   98:         assert c.is_monotonic_decreasing is True
   99: 
  100:         c = CategoricalIndex(data, categories=reversed(data), ordered=True)
  101:         assert c.is_monotonic_increasing is False
  102:         assert c.is_monotonic_decreasing is True
  103: 
  104:         # test when data is neither monotonic increasing nor decreasing
  105:         reordered_data = [data[0], data[2], data[1]]
  106:         c = CategoricalIndex(reordered_data, categories=reversed(data))
  107:         assert c.is_monotonic_increasing is False
  108:         assert c.is_monotonic_decreasing is False
  109: 
  110:         # non lexsorted categories
  111:         categories = non_lexsorted_data
  112: 
  113:         c = CategoricalIndex(categories[:2], categories=categories)
  114:         assert c.is_monotonic_increasing is True
  115:         assert c.is_monotonic_decreasing is False
  116: 
  117:         c = CategoricalIndex(categories[1:3], categories=categories)
  118:         assert c.is_monotonic_increasing is True
  119:         assert c.is_monotonic_decreasing is False
  120: 
  121:     def test_has_duplicates(self):
  122:         idx = CategoricalIndex([0, 0, 0], name="foo")
  123:         assert idx.is_unique is False
  124:         assert idx.has_duplicates is True
  125: 
  126:         idx = CategoricalIndex([0, 1], categories=[2, 3], name="foo")
  127:         assert idx.is_unique is False
  128:         assert idx.has_duplicates is True
  129: 
  130:         idx = CategoricalIndex([0, 1, 2, 3], categories=[1, 2, 3], name="foo")
  131:         assert idx.is_unique is True
  132:         assert idx.has_duplicates is False
  133: 
  134:     @pytest.mark.parametrize(
  135:         "data, categories, expected",
  136:         [
  137:             (
  138:                 [1, 1, 1],
  139:                 [1, 2, 3],
  140:                 {
  141:                     "first": np.array([False, True, True]),
  142:                     "last": np.array([True, True, False]),
  143:                     False: np.array([True, True, True]),
  144:                 },
  145:             ),
  146:             (
  147:                 [1, 1, 1],
  148:                 list("abc"),
  149:                 {
  150:                     "first": np.array([False, True, True]),
  151:                     "last": np.array([True, True, False]),
  152:                     False: np.array([True, True, True]),
  153:                 },
  154:             ),
  155:             (
  156:                 [2, "a", "b"],
  157:                 list("abc"),
  158:                 {
  159:                     "first": np.zeros(shape=(3), dtype=np.bool_),
  160:                     "last": np.zeros(shape=(3), dtype=np.bool_),
  161:                     False: np.zeros(shape=(3), dtype=np.bool_),
  162:                 },
  163:             ),
  164:             (
  165:                 list("abb"),
  166:                 list("abc"),
  167:                 {
  168:                     "first": np.array([False, False, True]),
  169:                     "last": np.array([False, True, False]),
  170:                     False: np.array([False, True, True]),
  171:                 },
  172:             ),
  173:         ],
  174:     )
  175:     def test_drop_duplicates(self, data, categories, expected):
  176:         idx = CategoricalIndex(data, categories=categories, name="foo")
  177:         for keep, e in expected.items():
  178:             tm.assert_numpy_array_equal(idx.duplicated(keep=keep), e)
  179:             e = idx[~e]
  180:             result = idx.drop_duplicates(keep=keep)
  181:             tm.assert_index_equal(result, e)
  182: 
  183:     @pytest.mark.parametrize(
  184:         "data, categories, expected_data",
  185:         [
  186:             ([1, 1, 1], [1, 2, 3], [1]),
  187:             ([1, 1, 1], list("abc"), [np.nan]),
  188:             ([1, 2, "a"], [1, 2, 3], [1, 2, np.nan]),
  189:             ([2, "a", "b"], list("abc"), [np.nan, "a", "b"]),
  190:         ],
  191:     )
  192:     def test_unique(self, data, categories, expected_data, ordered):
  193:         dtype = CategoricalDtype(categories, ordered=ordered)
  194: 
  195:         idx = CategoricalIndex(data, dtype=dtype)
  196:         expected = CategoricalIndex(expected_data, dtype=dtype)
  197:         tm.assert_index_equal(idx.unique(), expected)
  198: 
  199:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="repr doesn't roundtrip")
  200:     def test_repr_roundtrip(self):
  201:         ci = CategoricalIndex(["a", "b"], categories=["a", "b"], ordered=True)
  202:         str(ci)
  203:         tm.assert_index_equal(eval(repr(ci)), ci, exact=True)
  204: 
  205:         # formatting
  206:         str(ci)
  207: 
  208:         # long format
  209:         # this is not reprable
  210:         ci = CategoricalIndex(np.random.default_rng(2).integers(0, 5, size=100))
  211:         str(ci)
  212: 
  213:     def test_isin(self):
  214:         ci = CategoricalIndex(list("aabca") + [np.nan], categories=["c", "a", "b"])
  215:         tm.assert_numpy_array_equal(
  216:             ci.isin(["c"]), np.array([False, False, False, True, False, False])
  217:         )
  218:         tm.assert_numpy_array_equal(
  219:             ci.isin(["c", "a", "b"]), np.array([True] * 5 + [False])
  220:         )
  221:         tm.assert_numpy_array_equal(
  222:             ci.isin(["c", "a", "b", np.nan]), np.array([True] * 6)
  223:         )
  224: 
  225:         # mismatched categorical -> coerced to ndarray so doesn't matter
  226:         result = ci.isin(ci.set_categories(list("abcdefghi")))
  227:         expected = np.array([True] * 6)
  228:         tm.assert_numpy_array_equal(result, expected)
  229: 
  230:         result = ci.isin(ci.set_categories(list("defghi")))
  231:         expected = np.array([False] * 5 + [True])
  232:         tm.assert_numpy_array_equal(result, expected)
  233: 
  234:     def test_isin_overlapping_intervals(self):
  235:         # GH 34974
  236:         idx = pd.IntervalIndex([pd.Interval(0, 2), pd.Interval(0, 1)])
  237:         result = CategoricalIndex(idx).isin(idx)
  238:         expected = np.array([True, True])
  239:         tm.assert_numpy_array_equal(result, expected)
  240: 
  241:     def test_identical(self):
  242:         ci1 = CategoricalIndex(["a", "b"], categories=["a", "b"], ordered=True)
  243:         ci2 = CategoricalIndex(["a", "b"], categories=["a", "b", "c"], ordered=True)
  244:         assert ci1.identical(ci1)
  245:         assert ci1.identical(ci1.copy())
  246:         assert not ci1.identical(ci2)
  247: 
  248:     def test_ensure_copied_data(self):
  249:         # gh-12309: Check the "copy" argument of each
  250:         # Index.__new__ is honored.
  251:         #
  252:         # Must be tested separately from other indexes because
  253:         # self.values is not an ndarray.
  254:         index = CategoricalIndex(list("ab") * 5)
  255: 
  256:         result = CategoricalIndex(index.values, copy=True)
  257:         tm.assert_index_equal(index, result)
  258:         assert not np.shares_memory(result._data._codes, index._data._codes)
  259: 
  260:         result = CategoricalIndex(index.values, copy=False)
  261:         assert result._data._codes is index._data._codes
  262: 
  263: 
  264: class TestCategoricalIndex2:
  265:     def test_view_i8(self):
  266:         # GH#25464
  267:         ci = CategoricalIndex(list("ab") * 50)
  268:         msg = "When changing to a larger dtype, its size must be a divisor"
  269:         with pytest.raises(ValueError, match=msg):
  270:             ci.view("i8")
  271:         with pytest.raises(ValueError, match=msg):
  272:             ci._data.view("i8")
  273: 
  274:         ci = ci[:-4]  # length divisible by 8
  275: 
  276:         res = ci.view("i8")
  277:         expected = ci._data.codes.view("i8")
  278:         tm.assert_numpy_array_equal(res, expected)
  279: 
  280:         cat = ci._data
  281:         tm.assert_numpy_array_equal(cat.view("i8"), expected)
  282: 
  283:     @pytest.mark.parametrize(
  284:         "dtype, engine_type",
  285:         [
  286:             (np.int8, libindex.Int8Engine),
  287:             (np.int16, libindex.Int16Engine),
  288:             (np.int32, libindex.Int32Engine),
  289:             (np.int64, libindex.Int64Engine),
  290:         ],
  291:     )
  292:     def test_engine_type(self, dtype, engine_type):
  293:         if dtype != np.int64:
  294:             # num. of uniques required to push CategoricalIndex.codes to a
  295:             # dtype (128 categories required for .codes dtype to be int16 etc.)
  296:             num_uniques = {np.int8: 1, np.int16: 128, np.int32: 32768}[dtype]
  297:             ci = CategoricalIndex(range(num_uniques))
  298:         else:
  299:             # having 2**32 - 2**31 categories would be very memory-intensive,
  300:             # so we cheat a bit with the dtype
  301:             ci = CategoricalIndex(range(32768))  # == 2**16 - 2**(16 - 1)
  302:             arr = ci.values._ndarray.astype("int64")
  303:             NDArrayBacked.__init__(ci._data, arr, ci.dtype)
  304:         assert np.issubdtype(ci.codes.dtype, dtype)
  305:         assert isinstance(ci._engine, engine_type)
  306: 
  307:     @pytest.mark.parametrize(
  308:         "func,op_name",
  309:         [
  310:             (lambda idx: idx - idx, "__sub__"),
  311:             (lambda idx: idx + idx, "__add__"),
  312:             (lambda idx: idx - ["a", "b"], "__sub__"),
  313:             (lambda idx: idx + ["a", "b"], "__add__"),
  314:             (lambda idx: ["a", "b"] - idx, "__rsub__"),
  315:             (lambda idx: ["a", "b"] + idx, "__radd__"),
  316:         ],
  317:     )
  318:     def test_disallow_addsub_ops(self, func, op_name):
  319:         # GH 10039
  320:         # set ops (+/-) raise TypeError
  321:         idx = Index(Categorical(["a", "b"]))
  322:         cat_or_list = "'(Categorical|list)' and '(Categorical|list)'"
  323:         msg = "|".join(
  324:             [
  325:                 f"cannot perform {op_name} with this index type: CategoricalIndex",
  326:                 "can only concatenate list",
  327:                 rf"unsupported operand type\(s\) for [\+-]: {cat_or_list}",
  328:             ]
  329:         )
  330:         with pytest.raises(TypeError, match=msg):
  331:             func(idx)
  332: 
  333:     def test_method_delegation(self):
  334:         ci = CategoricalIndex(list("aabbca"), categories=list("cabdef"))
  335:         result = ci.set_categories(list("cab"))
  336:         tm.assert_index_equal(
  337:             result, CategoricalIndex(list("aabbca"), categories=list("cab"))
  338:         )
  339: 
  340:         ci = CategoricalIndex(list("aabbca"), categories=list("cab"))
  341:         result = ci.rename_categories(list("efg"))
  342:         tm.assert_index_equal(
  343:             result, CategoricalIndex(list("ffggef"), categories=list("efg"))
  344:         )
  345: 
  346:         # GH18862 (let rename_categories take callables)
  347:         result = ci.rename_categories(lambda x: x.upper())
  348:         tm.assert_index_equal(
  349:             result, CategoricalIndex(list("AABBCA"), categories=list("CAB"))
  350:         )
  351: 
  352:         ci = CategoricalIndex(list("aabbca"), categories=list("cab"))
  353:         result = ci.add_categories(["d"])
  354:         tm.assert_index_equal(
  355:             result, CategoricalIndex(list("aabbca"), categories=list("cabd"))
  356:         )
  357: 
  358:         ci = CategoricalIndex(list("aabbca"), categories=list("cab"))
  359:         result = ci.remove_categories(["c"])
  360:         tm.assert_index_equal(
  361:             result,
  362:             CategoricalIndex(list("aabb") + [np.nan] + ["a"], categories=list("ab")),
  363:         )
  364: 
  365:         ci = CategoricalIndex(list("aabbca"), categories=list("cabdef"))
  366:         result = ci.as_unordered()
  367:         tm.assert_index_equal(result, ci)
  368: 
  369:         ci = CategoricalIndex(list("aabbca"), categories=list("cabdef"))
  370:         result = ci.as_ordered()
  371:         tm.assert_index_equal(
  372:             result,
  373:             CategoricalIndex(list("aabbca"), categories=list("cabdef"), ordered=True),
  374:         )
  375: 
  376:         # invalid
  377:         msg = "cannot use inplace with CategoricalIndex"
  378:         with pytest.raises(ValueError, match=msg):
  379:             ci.set_categories(list("cab"), inplace=True)
  380: 
  381:     def test_remove_maintains_order(self):
  382:         ci = CategoricalIndex(list("abcdda"), categories=list("abcd"))
  383:         result = ci.reorder_categories(["d", "c", "b", "a"], ordered=True)
  384:         tm.assert_index_equal(
  385:             result,
  386:             CategoricalIndex(list("abcdda"), categories=list("dcba"), ordered=True),
  387:         )
  388:         result = result.remove_categories(["c"])
  389:         tm.assert_index_equal(
  390:             result,
  391:             CategoricalIndex(
  392:                 ["a", "b", np.nan, "d", "d", "a"], categories=list("dba"), ordered=True
  393:             ),
  394:         )
