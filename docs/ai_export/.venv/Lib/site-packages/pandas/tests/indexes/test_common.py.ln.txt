    1: """
    2: Collection of tests asserting things that should be true for
    3: any index subclass except for MultiIndex. Makes use of the `index_flat`
    4: fixture defined in pandas/conftest.py.
    5: """
    6: from copy import (
    7:     copy,
    8:     deepcopy,
    9: )
   10: import re
   11: 
   12: import numpy as np
   13: import pytest
   14: 
   15: from pandas.compat import IS64
   16: from pandas.compat.numpy import np_version_gte1p25
   17: 
   18: from pandas.core.dtypes.common import (
   19:     is_integer_dtype,
   20:     is_numeric_dtype,
   21: )
   22: 
   23: import pandas as pd
   24: from pandas import (
   25:     CategoricalIndex,
   26:     MultiIndex,
   27:     PeriodIndex,
   28:     RangeIndex,
   29: )
   30: import pandas._testing as tm
   31: 
   32: 
   33: class TestCommon:
   34:     @pytest.mark.parametrize("name", [None, "new_name"])
   35:     def test_to_frame(self, name, index_flat, using_copy_on_write):
   36:         # see GH#15230, GH#22580
   37:         idx = index_flat
   38: 
   39:         if name:
   40:             idx_name = name
   41:         else:
   42:             idx_name = idx.name or 0
   43: 
   44:         df = idx.to_frame(name=idx_name)
   45: 
   46:         assert df.index is idx
   47:         assert len(df.columns) == 1
   48:         assert df.columns[0] == idx_name
   49:         if not using_copy_on_write:
   50:             assert df[idx_name].values is not idx.values
   51: 
   52:         df = idx.to_frame(index=False, name=idx_name)
   53:         assert df.index is not idx
   54: 
   55:     def test_droplevel(self, index_flat):
   56:         # GH 21115
   57:         # MultiIndex is tested separately in test_multi.py
   58:         index = index_flat
   59: 
   60:         assert index.droplevel([]).equals(index)
   61: 
   62:         for level in [index.name, [index.name]]:
   63:             if isinstance(index.name, tuple) and level is index.name:
   64:                 # GH 21121 : droplevel with tuple name
   65:                 continue
   66:             msg = (
   67:                 "Cannot remove 1 levels from an index with 1 levels: at least one "
   68:                 "level must be left."
   69:             )
   70:             with pytest.raises(ValueError, match=msg):
   71:                 index.droplevel(level)
   72: 
   73:         for level in "wrong", ["wrong"]:
   74:             with pytest.raises(
   75:                 KeyError,
   76:                 match=r"'Requested level \(wrong\) does not match index name \(None\)'",
   77:             ):
   78:                 index.droplevel(level)
   79: 
   80:     def test_constructor_non_hashable_name(self, index_flat):
   81:         # GH 20527
   82:         index = index_flat
   83: 
   84:         message = "Index.name must be a hashable type"
   85:         renamed = [["1"]]
   86: 
   87:         # With .rename()
   88:         with pytest.raises(TypeError, match=message):
   89:             index.rename(name=renamed)
   90: 
   91:         # With .set_names()
   92:         with pytest.raises(TypeError, match=message):
   93:             index.set_names(names=renamed)
   94: 
   95:     def test_constructor_unwraps_index(self, index_flat):
   96:         a = index_flat
   97:         # Passing dtype is necessary for Index([True, False], dtype=object)
   98:         #  case.
   99:         b = type(a)(a, dtype=a.dtype)
  100:         tm.assert_equal(a._data, b._data)
  101: 
  102:     def test_to_flat_index(self, index_flat):
  103:         # 22866
  104:         index = index_flat
  105: 
  106:         result = index.to_flat_index()
  107:         tm.assert_index_equal(result, index)
  108: 
  109:     def test_set_name_methods(self, index_flat):
  110:         # MultiIndex tested separately
  111:         index = index_flat
  112:         new_name = "This is the new name for this index"
  113: 
  114:         original_name = index.name
  115:         new_ind = index.set_names([new_name])
  116:         assert new_ind.name == new_name
  117:         assert index.name == original_name
  118:         res = index.rename(new_name, inplace=True)
  119: 
  120:         # should return None
  121:         assert res is None
  122:         assert index.name == new_name
  123:         assert index.names == [new_name]
  124:         with pytest.raises(ValueError, match="Level must be None"):
  125:             index.set_names("a", level=0)
  126: 
  127:         # rename in place just leaves tuples and other containers alone
  128:         name = ("A", "B")
  129:         index.rename(name, inplace=True)
  130:         assert index.name == name
  131:         assert index.names == [name]
  132: 
  133:     @pytest.mark.xfail
  134:     def test_set_names_single_label_no_level(self, index_flat):
  135:         with pytest.raises(TypeError, match="list-like"):
  136:             # should still fail even if it would be the right length
  137:             index_flat.set_names("a")
  138: 
  139:     def test_copy_and_deepcopy(self, index_flat):
  140:         index = index_flat
  141: 
  142:         for func in (copy, deepcopy):
  143:             idx_copy = func(index)
  144:             assert idx_copy is not index
  145:             assert idx_copy.equals(index)
  146: 
  147:         new_copy = index.copy(deep=True, name="banana")
  148:         assert new_copy.name == "banana"
  149: 
  150:     def test_copy_name(self, index_flat):
  151:         # GH#12309: Check that the "name" argument
  152:         # passed at initialization is honored.
  153:         index = index_flat
  154: 
  155:         first = type(index)(index, copy=True, name="mario")
  156:         second = type(first)(first, copy=False)
  157: 
  158:         # Even though "copy=False", we want a new object.
  159:         assert first is not second
  160:         tm.assert_index_equal(first, second)
  161: 
  162:         # Not using tm.assert_index_equal() since names differ.
  163:         assert index.equals(first)
  164: 
  165:         assert first.name == "mario"
  166:         assert second.name == "mario"
  167: 
  168:         # TODO: belongs in series arithmetic tests?
  169:         s1 = pd.Series(2, index=first)
  170:         s2 = pd.Series(3, index=second[:-1])
  171:         # See GH#13365
  172:         s3 = s1 * s2
  173:         assert s3.index.name == "mario"
  174: 
  175:     def test_copy_name2(self, index_flat):
  176:         # GH#35592
  177:         index = index_flat
  178: 
  179:         assert index.copy(name="mario").name == "mario"
  180: 
  181:         with pytest.raises(ValueError, match="Length of new names must be 1, got 2"):
  182:             index.copy(name=["mario", "luigi"])
  183: 
  184:         msg = f"{type(index).__name__}.name must be a hashable type"
  185:         with pytest.raises(TypeError, match=msg):
  186:             index.copy(name=[["mario"]])
  187: 
  188:     def test_unique_level(self, index_flat):
  189:         # don't test a MultiIndex here (as its tested separated)
  190:         index = index_flat
  191: 
  192:         # GH 17896
  193:         expected = index.drop_duplicates()
  194:         for level in [0, index.name, None]:
  195:             result = index.unique(level=level)
  196:             tm.assert_index_equal(result, expected)
  197: 
  198:         msg = "Too many levels: Index has only 1 level, not 4"
  199:         with pytest.raises(IndexError, match=msg):
  200:             index.unique(level=3)
  201: 
  202:         msg = (
  203:             rf"Requested level \(wrong\) does not match index name "
  204:             rf"\({re.escape(index.name.__repr__())}\)"
  205:         )
  206:         with pytest.raises(KeyError, match=msg):
  207:             index.unique(level="wrong")
  208: 
  209:     def test_unique(self, index_flat):
  210:         # MultiIndex tested separately
  211:         index = index_flat
  212:         if not len(index):
  213:             pytest.skip("Skip check for empty Index and MultiIndex")
  214: 
  215:         idx = index[[0] * 5]
  216:         idx_unique = index[[0]]
  217: 
  218:         # We test against `idx_unique`, so first we make sure it's unique
  219:         # and doesn't contain nans.
  220:         assert idx_unique.is_unique is True
  221:         try:
  222:             assert idx_unique.hasnans is False
  223:         except NotImplementedError:
  224:             pass
  225: 
  226:         result = idx.unique()
  227:         tm.assert_index_equal(result, idx_unique)
  228: 
  229:         # nans:
  230:         if not index._can_hold_na:
  231:             pytest.skip("Skip na-check if index cannot hold na")
  232: 
  233:         vals = index._values[[0] * 5]
  234:         vals[0] = np.nan
  235: 
  236:         vals_unique = vals[:2]
  237:         idx_nan = index._shallow_copy(vals)
  238:         idx_unique_nan = index._shallow_copy(vals_unique)
  239:         assert idx_unique_nan.is_unique is True
  240: 
  241:         assert idx_nan.dtype == index.dtype
  242:         assert idx_unique_nan.dtype == index.dtype
  243: 
  244:         expected = idx_unique_nan
  245:         for pos, i in enumerate([idx_nan, idx_unique_nan]):
  246:             result = i.unique()
  247:             tm.assert_index_equal(result, expected)
  248: 
  249:     @pytest.mark.filterwarnings("ignore:Period with BDay freq:FutureWarning")
  250:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  251:     def test_searchsorted_monotonic(self, index_flat, request):
  252:         # GH17271
  253:         index = index_flat
  254:         # not implemented for tuple searches in MultiIndex
  255:         # or Intervals searches in IntervalIndex
  256:         if isinstance(index, pd.IntervalIndex):
  257:             mark = pytest.mark.xfail(
  258:                 reason="IntervalIndex.searchsorted does not support Interval arg",
  259:                 raises=NotImplementedError,
  260:             )
  261:             request.applymarker(mark)
  262: 
  263:         # nothing to test if the index is empty
  264:         if index.empty:
  265:             pytest.skip("Skip check for empty Index")
  266:         value = index[0]
  267: 
  268:         # determine the expected results (handle dupes for 'right')
  269:         expected_left, expected_right = 0, (index == value).argmin()
  270:         if expected_right == 0:
  271:             # all values are the same, expected_right should be length
  272:             expected_right = len(index)
  273: 
  274:         # test _searchsorted_monotonic in all cases
  275:         # test searchsorted only for increasing
  276:         if index.is_monotonic_increasing:
  277:             ssm_left = index._searchsorted_monotonic(value, side="left")
  278:             assert expected_left == ssm_left
  279: 
  280:             ssm_right = index._searchsorted_monotonic(value, side="right")
  281:             assert expected_right == ssm_right
  282: 
  283:             ss_left = index.searchsorted(value, side="left")
  284:             assert expected_left == ss_left
  285: 
  286:             ss_right = index.searchsorted(value, side="right")
  287:             assert expected_right == ss_right
  288: 
  289:         elif index.is_monotonic_decreasing:
  290:             ssm_left = index._searchsorted_monotonic(value, side="left")
  291:             assert expected_left == ssm_left
  292: 
  293:             ssm_right = index._searchsorted_monotonic(value, side="right")
  294:             assert expected_right == ssm_right
  295:         else:
  296:             # non-monotonic should raise.
  297:             msg = "index must be monotonic increasing or decreasing"
  298:             with pytest.raises(ValueError, match=msg):
  299:                 index._searchsorted_monotonic(value, side="left")
  300: 
  301:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  302:     def test_drop_duplicates(self, index_flat, keep):
  303:         # MultiIndex is tested separately
  304:         index = index_flat
  305:         if isinstance(index, RangeIndex):
  306:             pytest.skip(
  307:                 "RangeIndex is tested in test_drop_duplicates_no_duplicates "
  308:                 "as it cannot hold duplicates"
  309:             )
  310:         if len(index) == 0:
  311:             pytest.skip(
  312:                 "empty index is tested in test_drop_duplicates_no_duplicates "
  313:                 "as it cannot hold duplicates"
  314:             )
  315: 
  316:         # make unique index
  317:         holder = type(index)
  318:         unique_values = list(set(index))
  319:         dtype = index.dtype if is_numeric_dtype(index) else None
  320:         unique_idx = holder(unique_values, dtype=dtype)
  321: 
  322:         # make duplicated index
  323:         n = len(unique_idx)
  324:         duplicated_selection = np.random.default_rng(2).choice(n, int(n * 1.5))
  325:         idx = holder(unique_idx.values[duplicated_selection])
  326: 
  327:         # Series.duplicated is tested separately
  328:         expected_duplicated = (
  329:             pd.Series(duplicated_selection).duplicated(keep=keep).values
  330:         )
  331:         tm.assert_numpy_array_equal(idx.duplicated(keep=keep), expected_duplicated)
  332: 
  333:         # Series.drop_duplicates is tested separately
  334:         expected_dropped = holder(pd.Series(idx).drop_duplicates(keep=keep))
  335:         tm.assert_index_equal(idx.drop_duplicates(keep=keep), expected_dropped)
  336: 
  337:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  338:     def test_drop_duplicates_no_duplicates(self, index_flat):
  339:         # MultiIndex is tested separately
  340:         index = index_flat
  341: 
  342:         # make unique index
  343:         if isinstance(index, RangeIndex):
  344:             # RangeIndex cannot have duplicates
  345:             unique_idx = index
  346:         else:
  347:             holder = type(index)
  348:             unique_values = list(set(index))
  349:             dtype = index.dtype if is_numeric_dtype(index) else None
  350:             unique_idx = holder(unique_values, dtype=dtype)
  351: 
  352:         # check on unique index
  353:         expected_duplicated = np.array([False] * len(unique_idx), dtype="bool")
  354:         tm.assert_numpy_array_equal(unique_idx.duplicated(), expected_duplicated)
  355:         result_dropped = unique_idx.drop_duplicates()
  356:         tm.assert_index_equal(result_dropped, unique_idx)
  357:         # validate shallow copy
  358:         assert result_dropped is not unique_idx
  359: 
  360:     def test_drop_duplicates_inplace(self, index):
  361:         msg = r"drop_duplicates\(\) got an unexpected keyword argument"
  362:         with pytest.raises(TypeError, match=msg):
  363:             index.drop_duplicates(inplace=True)
  364: 
  365:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  366:     def test_has_duplicates(self, index_flat):
  367:         # MultiIndex tested separately in:
  368:         #   tests/indexes/multi/test_unique_and_duplicates.
  369:         index = index_flat
  370:         holder = type(index)
  371:         if not len(index) or isinstance(index, RangeIndex):
  372:             # MultiIndex tested separately in:
  373:             #   tests/indexes/multi/test_unique_and_duplicates.
  374:             # RangeIndex is unique by definition.
  375:             pytest.skip("Skip check for empty Index, MultiIndex, and RangeIndex")
  376: 
  377:         idx = holder([index[0]] * 5)
  378:         assert idx.is_unique is False
  379:         assert idx.has_duplicates is True
  380: 
  381:     @pytest.mark.parametrize(
  382:         "dtype",
  383:         ["int64", "uint64", "float64", "category", "datetime64[ns]", "timedelta64[ns]"],
  384:     )
  385:     def test_astype_preserves_name(self, index, dtype):
  386:         # https://github.com/pandas-dev/pandas/issues/32013
  387:         if isinstance(index, MultiIndex):
  388:             index.names = ["idx" + str(i) for i in range(index.nlevels)]
  389:         else:
  390:             index.name = "idx"
  391: 
  392:         warn = None
  393:         if index.dtype.kind == "c" and dtype in ["float64", "int64", "uint64"]:
  394:             # imaginary components discarded
  395:             if np_version_gte1p25:
  396:                 warn = np.exceptions.ComplexWarning
  397:             else:
  398:                 warn = np.ComplexWarning
  399: 
  400:         is_pyarrow_str = str(index.dtype) == "string[pyarrow]" and dtype == "category"
  401:         try:
  402:             # Some of these conversions cannot succeed so we use a try / except
  403:             with tm.assert_produces_warning(
  404:                 warn,
  405:                 raise_on_extra_warnings=is_pyarrow_str,
  406:                 check_stacklevel=False,
  407:             ):
  408:                 result = index.astype(dtype)
  409:         except (ValueError, TypeError, NotImplementedError, SystemError):
  410:             return
  411: 
  412:         if isinstance(index, MultiIndex):
  413:             assert result.names == index.names
  414:         else:
  415:             assert result.name == index.name
  416: 
  417:     def test_hasnans_isnans(self, index_flat):
  418:         # GH#11343, added tests for hasnans / isnans
  419:         index = index_flat
  420: 
  421:         # cases in indices doesn't include NaN
  422:         idx = index.copy(deep=True)
  423:         expected = np.array([False] * len(idx), dtype=bool)
  424:         tm.assert_numpy_array_equal(idx._isnan, expected)
  425:         assert idx.hasnans is False
  426: 
  427:         idx = index.copy(deep=True)
  428:         values = idx._values
  429: 
  430:         if len(index) == 0:
  431:             return
  432:         elif is_integer_dtype(index.dtype):
  433:             return
  434:         elif index.dtype == bool:
  435:             # values[1] = np.nan below casts to True!
  436:             return
  437: 
  438:         values[1] = np.nan
  439: 
  440:         idx = type(index)(values)
  441: 
  442:         expected = np.array([False] * len(idx), dtype=bool)
  443:         expected[1] = True
  444:         tm.assert_numpy_array_equal(idx._isnan, expected)
  445:         assert idx.hasnans is True
  446: 
  447: 
  448: @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  449: @pytest.mark.parametrize("na_position", [None, "middle"])
  450: def test_sort_values_invalid_na_position(index_with_missing, na_position):
  451:     with pytest.raises(ValueError, match=f"invalid na_position: {na_position}"):
  452:         index_with_missing.sort_values(na_position=na_position)
  453: 
  454: 
  455: @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  456: @pytest.mark.parametrize("na_position", ["first", "last"])
  457: def test_sort_values_with_missing(index_with_missing, na_position, request):
  458:     # GH 35584. Test that sort_values works with missing values,
  459:     # sort non-missing and place missing according to na_position
  460: 
  461:     if isinstance(index_with_missing, CategoricalIndex):
  462:         request.applymarker(
  463:             pytest.mark.xfail(
  464:                 reason="missing value sorting order not well-defined", strict=False
  465:             )
  466:         )
  467: 
  468:     missing_count = np.sum(index_with_missing.isna())
  469:     not_na_vals = index_with_missing[index_with_missing.notna()].values
  470:     sorted_values = np.sort(not_na_vals)
  471:     if na_position == "first":
  472:         sorted_values = np.concatenate([[None] * missing_count, sorted_values])
  473:     else:
  474:         sorted_values = np.concatenate([sorted_values, [None] * missing_count])
  475: 
  476:     # Explicitly pass dtype needed for Index backed by EA e.g. IntegerArray
  477:     expected = type(index_with_missing)(sorted_values, dtype=index_with_missing.dtype)
  478: 
  479:     result = index_with_missing.sort_values(na_position=na_position)
  480:     tm.assert_index_equal(result, expected)
  481: 
  482: 
  483: def test_ndarray_compat_properties(index):
  484:     if isinstance(index, PeriodIndex) and not IS64:
  485:         pytest.skip("Overflow")
  486:     idx = index
  487:     assert idx.T.equals(idx)
  488:     assert idx.transpose().equals(idx)
  489: 
  490:     values = idx.values
  491: 
  492:     assert idx.shape == values.shape
  493:     assert idx.ndim == values.ndim
  494:     assert idx.size == values.size
  495: 
  496:     if not isinstance(index, (RangeIndex, MultiIndex)):
  497:         # These two are not backed by an ndarray
  498:         assert idx.nbytes == values.nbytes
  499: 
  500:     # test for validity
  501:     idx.nbytes
  502:     idx.values.nbytes
  503: 
  504: 
  505: def test_compare_read_only_array():
  506:     # GH#57130
  507:     arr = np.array([], dtype=object)
  508:     arr.flags.writeable = False
  509:     idx = pd.Index(arr)
  510:     result = idx > 69
  511:     assert result.dtype == bool
