    1: from decimal import Decimal
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas._libs.missing import (
    7:     NA,
    8:     is_matching_na,
    9: )
   10: from pandas.compat import pa_version_under16p0
   11: import pandas.util._test_decorators as td
   12: 
   13: import pandas as pd
   14: from pandas import Index
   15: import pandas._testing as tm
   16: 
   17: 
   18: class TestGetIndexer:
   19:     @pytest.mark.parametrize(
   20:         "method,expected",
   21:         [
   22:             ("pad", np.array([-1, 0, 1, 1], dtype=np.intp)),
   23:             ("backfill", np.array([0, 0, 1, -1], dtype=np.intp)),
   24:         ],
   25:     )
   26:     def test_get_indexer_strings(self, method, expected):
   27:         index = Index(["b", "c"])
   28:         actual = index.get_indexer(["a", "b", "c", "d"], method=method)
   29: 
   30:         tm.assert_numpy_array_equal(actual, expected)
   31: 
   32:     def test_get_indexer_strings_raises(self, using_infer_string):
   33:         index = Index(["b", "c"])
   34: 
   35:         if using_infer_string:
   36:             import pyarrow as pa
   37: 
   38:             msg = "has no kernel"
   39:             with pytest.raises(pa.lib.ArrowNotImplementedError, match=msg):
   40:                 index.get_indexer(["a", "b", "c", "d"], method="nearest")
   41: 
   42:             with pytest.raises(pa.lib.ArrowNotImplementedError, match=msg):
   43:                 index.get_indexer(["a", "b", "c", "d"], method="pad", tolerance=2)
   44: 
   45:             with pytest.raises(pa.lib.ArrowNotImplementedError, match=msg):
   46:                 index.get_indexer(
   47:                     ["a", "b", "c", "d"], method="pad", tolerance=[2, 2, 2, 2]
   48:                 )
   49: 
   50:         else:
   51:             msg = r"unsupported operand type\(s\) for -: 'str' and 'str'"
   52:             with pytest.raises(TypeError, match=msg):
   53:                 index.get_indexer(["a", "b", "c", "d"], method="nearest")
   54: 
   55:             with pytest.raises(TypeError, match=msg):
   56:                 index.get_indexer(["a", "b", "c", "d"], method="pad", tolerance=2)
   57: 
   58:             with pytest.raises(TypeError, match=msg):
   59:                 index.get_indexer(
   60:                     ["a", "b", "c", "d"], method="pad", tolerance=[2, 2, 2, 2]
   61:                 )
   62: 
   63:     def test_get_indexer_with_NA_values(
   64:         self, unique_nulls_fixture, unique_nulls_fixture2
   65:     ):
   66:         # GH#22332
   67:         # check pairwise, that no pair of na values
   68:         # is mangled
   69:         if unique_nulls_fixture is unique_nulls_fixture2:
   70:             return  # skip it, values are not unique
   71:         arr = np.array([unique_nulls_fixture, unique_nulls_fixture2], dtype=object)
   72:         index = Index(arr, dtype=object)
   73:         result = index.get_indexer(
   74:             Index(
   75:                 [unique_nulls_fixture, unique_nulls_fixture2, "Unknown"], dtype=object
   76:             )
   77:         )
   78:         expected = np.array([0, 1, -1], dtype=np.intp)
   79:         tm.assert_numpy_array_equal(result, expected)
   80: 
   81: 
   82: class TestGetIndexerNonUnique:
   83:     def test_get_indexer_non_unique_nas(
   84:         self, nulls_fixture, request, using_infer_string
   85:     ):
   86:         # even though this isn't non-unique, this should still work
   87:         if using_infer_string and (nulls_fixture is None or nulls_fixture is NA):
   88:             request.applymarker(pytest.mark.xfail(reason="NAs are cast to NaN"))
   89:         index = Index(["a", "b", nulls_fixture])
   90:         indexer, missing = index.get_indexer_non_unique([nulls_fixture])
   91: 
   92:         expected_indexer = np.array([2], dtype=np.intp)
   93:         expected_missing = np.array([], dtype=np.intp)
   94:         tm.assert_numpy_array_equal(indexer, expected_indexer)
   95:         tm.assert_numpy_array_equal(missing, expected_missing)
   96: 
   97:         # actually non-unique
   98:         index = Index(["a", nulls_fixture, "b", nulls_fixture])
   99:         indexer, missing = index.get_indexer_non_unique([nulls_fixture])
  100: 
  101:         expected_indexer = np.array([1, 3], dtype=np.intp)
  102:         tm.assert_numpy_array_equal(indexer, expected_indexer)
  103:         tm.assert_numpy_array_equal(missing, expected_missing)
  104: 
  105:         # matching-but-not-identical nans
  106:         if is_matching_na(nulls_fixture, float("NaN")):
  107:             index = Index(["a", float("NaN"), "b", float("NaN")])
  108:             match_but_not_identical = True
  109:         elif is_matching_na(nulls_fixture, Decimal("NaN")):
  110:             index = Index(["a", Decimal("NaN"), "b", Decimal("NaN")])
  111:             match_but_not_identical = True
  112:         else:
  113:             match_but_not_identical = False
  114: 
  115:         if match_but_not_identical:
  116:             indexer, missing = index.get_indexer_non_unique([nulls_fixture])
  117: 
  118:             expected_indexer = np.array([1, 3], dtype=np.intp)
  119:             tm.assert_numpy_array_equal(indexer, expected_indexer)
  120:             tm.assert_numpy_array_equal(missing, expected_missing)
  121: 
  122:     @pytest.mark.filterwarnings("ignore:elementwise comp:DeprecationWarning")
  123:     def test_get_indexer_non_unique_np_nats(self, np_nat_fixture, np_nat_fixture2):
  124:         expected_missing = np.array([], dtype=np.intp)
  125:         # matching-but-not-identical nats
  126:         if is_matching_na(np_nat_fixture, np_nat_fixture2):
  127:             # ensure nats are different objects
  128:             index = Index(
  129:                 np.array(
  130:                     ["2021-10-02", np_nat_fixture.copy(), np_nat_fixture2.copy()],
  131:                     dtype=object,
  132:                 ),
  133:                 dtype=object,
  134:             )
  135:             # pass as index to prevent target from being casted to DatetimeIndex
  136:             indexer, missing = index.get_indexer_non_unique(
  137:                 Index([np_nat_fixture], dtype=object)
  138:             )
  139:             expected_indexer = np.array([1, 2], dtype=np.intp)
  140:             tm.assert_numpy_array_equal(indexer, expected_indexer)
  141:             tm.assert_numpy_array_equal(missing, expected_missing)
  142:         # dt64nat vs td64nat
  143:         else:
  144:             try:
  145:                 np_nat_fixture == np_nat_fixture2
  146:             except (TypeError, OverflowError):
  147:                 # Numpy will raise on uncomparable types, like
  148:                 # np.datetime64('NaT', 'Y') and np.datetime64('NaT', 'ps')
  149:                 # https://github.com/numpy/numpy/issues/22762
  150:                 return
  151:             index = Index(
  152:                 np.array(
  153:                     [
  154:                         "2021-10-02",
  155:                         np_nat_fixture,
  156:                         np_nat_fixture2,
  157:                         np_nat_fixture,
  158:                         np_nat_fixture2,
  159:                     ],
  160:                     dtype=object,
  161:                 ),
  162:                 dtype=object,
  163:             )
  164:             # pass as index to prevent target from being casted to DatetimeIndex
  165:             indexer, missing = index.get_indexer_non_unique(
  166:                 Index([np_nat_fixture], dtype=object)
  167:             )
  168:             expected_indexer = np.array([1, 3], dtype=np.intp)
  169:             tm.assert_numpy_array_equal(indexer, expected_indexer)
  170:             tm.assert_numpy_array_equal(missing, expected_missing)
  171: 
  172: 
  173: class TestSliceLocs:
  174:     @pytest.mark.parametrize(
  175:         "dtype",
  176:         [
  177:             "object",
  178:             pytest.param("string[pyarrow_numpy]", marks=td.skip_if_no("pyarrow")),
  179:         ],
  180:     )
  181:     @pytest.mark.parametrize(
  182:         "in_slice,expected",
  183:         [
  184:             # error: Slice index must be an integer or None
  185:             (pd.IndexSlice[::-1], "yxdcb"),
  186:             (pd.IndexSlice["b":"y":-1], ""),  # type: ignore[misc]
  187:             (pd.IndexSlice["b"::-1], "b"),  # type: ignore[misc]
  188:             (pd.IndexSlice[:"b":-1], "yxdcb"),  # type: ignore[misc]
  189:             (pd.IndexSlice[:"y":-1], "y"),  # type: ignore[misc]
  190:             (pd.IndexSlice["y"::-1], "yxdcb"),  # type: ignore[misc]
  191:             (pd.IndexSlice["y"::-4], "yb"),  # type: ignore[misc]
  192:             # absent labels
  193:             (pd.IndexSlice[:"a":-1], "yxdcb"),  # type: ignore[misc]
  194:             (pd.IndexSlice[:"a":-2], "ydb"),  # type: ignore[misc]
  195:             (pd.IndexSlice["z"::-1], "yxdcb"),  # type: ignore[misc]
  196:             (pd.IndexSlice["z"::-3], "yc"),  # type: ignore[misc]
  197:             (pd.IndexSlice["m"::-1], "dcb"),  # type: ignore[misc]
  198:             (pd.IndexSlice[:"m":-1], "yx"),  # type: ignore[misc]
  199:             (pd.IndexSlice["a":"a":-1], ""),  # type: ignore[misc]
  200:             (pd.IndexSlice["z":"z":-1], ""),  # type: ignore[misc]
  201:             (pd.IndexSlice["m":"m":-1], ""),  # type: ignore[misc]
  202:         ],
  203:     )
  204:     def test_slice_locs_negative_step(self, in_slice, expected, dtype, request):
  205:         if (
  206:             not pa_version_under16p0
  207:             and dtype == "string[pyarrow_numpy]"
  208:             and in_slice == slice("a", "a", -1)
  209:         ):
  210:             request.applymarker(
  211:                 pytest.mark.xfail(reason="https://github.com/apache/arrow/issues/40642")
  212:             )
  213: 
  214:         index = Index(list("bcdxy"), dtype=dtype)
  215: 
  216:         s_start, s_stop = index.slice_locs(in_slice.start, in_slice.stop, in_slice.step)
  217:         result = index[s_start : s_stop : in_slice.step]
  218:         expected = Index(list(expected), dtype=dtype)
  219:         tm.assert_index_equal(result, expected)
  220: 
  221:     @td.skip_if_no("pyarrow")
  222:     def test_slice_locs_negative_step_oob(self):
  223:         index = Index(list("bcdxy"), dtype="string[pyarrow_numpy]")
  224: 
  225:         result = index[-10:5:1]
  226:         tm.assert_index_equal(result, index)
  227: 
  228:         result = index[4:-10:-1]
  229:         expected = Index(list("yxdcb"), dtype="string[pyarrow_numpy]")
  230:         tm.assert_index_equal(result, expected)
  231: 
  232:     def test_slice_locs_dup(self):
  233:         index = Index(["a", "a", "b", "c", "d", "d"])
  234:         assert index.slice_locs("a", "d") == (0, 6)
  235:         assert index.slice_locs(end="d") == (0, 6)
  236:         assert index.slice_locs("a", "c") == (0, 4)
  237:         assert index.slice_locs("b", "d") == (2, 6)
  238: 
  239:         index2 = index[::-1]
  240:         assert index2.slice_locs("d", "a") == (0, 6)
  241:         assert index2.slice_locs(end="a") == (0, 6)
  242:         assert index2.slice_locs("d", "b") == (0, 4)
  243:         assert index2.slice_locs("c", "a") == (2, 6)
