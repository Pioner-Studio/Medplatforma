    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     IndexSlice,
    7:     MultiIndex,
    8:     date_range,
    9: )
   10: import pandas._testing as tm
   11: 
   12: 
   13: @pytest.fixture
   14: def df():
   15:     #                        c1
   16:     # 2016-01-01 00:00:00 a   0
   17:     #                     b   1
   18:     #                     c   2
   19:     # 2016-01-01 12:00:00 a   3
   20:     #                     b   4
   21:     #                     c   5
   22:     # 2016-01-02 00:00:00 a   6
   23:     #                     b   7
   24:     #                     c   8
   25:     # 2016-01-02 12:00:00 a   9
   26:     #                     b  10
   27:     #                     c  11
   28:     # 2016-01-03 00:00:00 a  12
   29:     #                     b  13
   30:     #                     c  14
   31:     dr = date_range("2016-01-01", "2016-01-03", freq="12h")
   32:     abc = ["a", "b", "c"]
   33:     mi = MultiIndex.from_product([dr, abc])
   34:     frame = DataFrame({"c1": range(15)}, index=mi)
   35:     return frame
   36: 
   37: 
   38: def test_partial_string_matching_single_index(df):
   39:     # partial string matching on a single index
   40:     for df_swap in [df.swaplevel(), df.swaplevel(0), df.swaplevel(0, 1)]:
   41:         df_swap = df_swap.sort_index()
   42:         just_a = df_swap.loc["a"]
   43:         result = just_a.loc["2016-01-01"]
   44:         expected = df.loc[IndexSlice[:, "a"], :].iloc[0:2]
   45:         expected.index = expected.index.droplevel(1)
   46:         tm.assert_frame_equal(result, expected)
   47: 
   48: 
   49: def test_get_loc_partial_timestamp_multiindex(df):
   50:     mi = df.index
   51:     key = ("2016-01-01", "a")
   52:     loc = mi.get_loc(key)
   53: 
   54:     expected = np.zeros(len(mi), dtype=bool)
   55:     expected[[0, 3]] = True
   56:     tm.assert_numpy_array_equal(loc, expected)
   57: 
   58:     key2 = ("2016-01-02", "a")
   59:     loc2 = mi.get_loc(key2)
   60:     expected2 = np.zeros(len(mi), dtype=bool)
   61:     expected2[[6, 9]] = True
   62:     tm.assert_numpy_array_equal(loc2, expected2)
   63: 
   64:     key3 = ("2016-01", "a")
   65:     loc3 = mi.get_loc(key3)
   66:     expected3 = np.zeros(len(mi), dtype=bool)
   67:     expected3[mi.get_level_values(1).get_loc("a")] = True
   68:     tm.assert_numpy_array_equal(loc3, expected3)
   69: 
   70:     key4 = ("2016", "a")
   71:     loc4 = mi.get_loc(key4)
   72:     expected4 = expected3
   73:     tm.assert_numpy_array_equal(loc4, expected4)
   74: 
   75:     # non-monotonic
   76:     taker = np.arange(len(mi), dtype=np.intp)
   77:     taker[::2] = taker[::-2]
   78:     mi2 = mi.take(taker)
   79:     loc5 = mi2.get_loc(key)
   80:     expected5 = np.zeros(len(mi2), dtype=bool)
   81:     expected5[[3, 14]] = True
   82:     tm.assert_numpy_array_equal(loc5, expected5)
   83: 
   84: 
   85: def test_partial_string_timestamp_multiindex(df):
   86:     # GH10331
   87:     df_swap = df.swaplevel(0, 1).sort_index()
   88:     SLC = IndexSlice
   89: 
   90:     # indexing with IndexSlice
   91:     result = df.loc[SLC["2016-01-01":"2016-02-01", :], :]
   92:     expected = df
   93:     tm.assert_frame_equal(result, expected)
   94: 
   95:     # match on secondary index
   96:     result = df_swap.loc[SLC[:, "2016-01-01":"2016-01-01"], :]
   97:     expected = df_swap.iloc[[0, 1, 5, 6, 10, 11]]
   98:     tm.assert_frame_equal(result, expected)
   99: 
  100:     # partial string match on year only
  101:     result = df.loc["2016"]
  102:     expected = df
  103:     tm.assert_frame_equal(result, expected)
  104: 
  105:     # partial string match on date
  106:     result = df.loc["2016-01-01"]
  107:     expected = df.iloc[0:6]
  108:     tm.assert_frame_equal(result, expected)
  109: 
  110:     # partial string match on date and hour, from middle
  111:     result = df.loc["2016-01-02 12"]
  112:     # hourly resolution, same as index.levels[0], so we are _not_ slicing on
  113:     #  that level, so that level gets dropped
  114:     expected = df.iloc[9:12].droplevel(0)
  115:     tm.assert_frame_equal(result, expected)
  116: 
  117:     # partial string match on secondary index
  118:     result = df_swap.loc[SLC[:, "2016-01-02"], :]
  119:     expected = df_swap.iloc[[2, 3, 7, 8, 12, 13]]
  120:     tm.assert_frame_equal(result, expected)
  121: 
  122:     # tuple selector with partial string match on date
  123:     # "2016-01-01" has daily resolution, so _is_ a slice on the first level.
  124:     result = df.loc[("2016-01-01", "a"), :]
  125:     expected = df.iloc[[0, 3]]
  126:     expected = df.iloc[[0, 3]].droplevel(1)
  127:     tm.assert_frame_equal(result, expected)
  128: 
  129:     # Slicing date on first level should break (of course) bc the DTI is the
  130:     #  second level on df_swap
  131:     with pytest.raises(KeyError, match="'2016-01-01'"):
  132:         df_swap.loc["2016-01-01"]
  133: 
  134: 
  135: def test_partial_string_timestamp_multiindex_str_key_raises(df):
  136:     # Even though this syntax works on a single index, this is somewhat
  137:     # ambiguous and we don't want to extend this behavior forward to work
  138:     # in multi-indexes. This would amount to selecting a scalar from a
  139:     # column.
  140:     with pytest.raises(KeyError, match="'2016-01-01'"):
  141:         df["2016-01-01"]
  142: 
  143: 
  144: def test_partial_string_timestamp_multiindex_daily_resolution(df):
  145:     # GH12685 (partial string with daily resolution or below)
  146:     result = df.loc[IndexSlice["2013-03":"2013-03", :], :]
  147:     expected = df.iloc[118:180]
  148:     tm.assert_frame_equal(result, expected)
