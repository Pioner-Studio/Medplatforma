    1: from collections import defaultdict
    2: from datetime import datetime
    3: from itertools import product
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas import (
    9:     NA,
   10:     DataFrame,
   11:     MultiIndex,
   12:     Series,
   13:     array,
   14:     concat,
   15:     merge,
   16: )
   17: import pandas._testing as tm
   18: from pandas.core.algorithms import safe_sort
   19: import pandas.core.common as com
   20: from pandas.core.sorting import (
   21:     _decons_group_index,
   22:     get_group_index,
   23:     is_int64_overflow_possible,
   24:     lexsort_indexer,
   25:     nargsort,
   26: )
   27: 
   28: 
   29: @pytest.fixture
   30: def left_right():
   31:     low, high, n = -1 << 10, 1 << 10, 1 << 20
   32:     left = DataFrame(
   33:         np.random.default_rng(2).integers(low, high, (n, 7)), columns=list("ABCDEFG")
   34:     )
   35:     left["left"] = left.sum(axis=1)
   36: 
   37:     # one-2-one match
   38:     i = np.random.default_rng(2).permutation(len(left))
   39:     right = left.iloc[i].copy()
   40:     right.columns = right.columns[:-1].tolist() + ["right"]
   41:     right.index = np.arange(len(right))
   42:     right["right"] *= -1
   43:     return left, right
   44: 
   45: 
   46: class TestSorting:
   47:     @pytest.mark.slow
   48:     def test_int64_overflow(self):
   49:         B = np.concatenate((np.arange(1000), np.arange(1000), np.arange(500)))
   50:         A = np.arange(2500)
   51:         df = DataFrame(
   52:             {
   53:                 "A": A,
   54:                 "B": B,
   55:                 "C": A,
   56:                 "D": B,
   57:                 "E": A,
   58:                 "F": B,
   59:                 "G": A,
   60:                 "H": B,
   61:                 "values": np.random.default_rng(2).standard_normal(2500),
   62:             }
   63:         )
   64: 
   65:         lg = df.groupby(["A", "B", "C", "D", "E", "F", "G", "H"])
   66:         rg = df.groupby(["H", "G", "F", "E", "D", "C", "B", "A"])
   67: 
   68:         left = lg.sum()["values"]
   69:         right = rg.sum()["values"]
   70: 
   71:         exp_index, _ = left.index.sortlevel()
   72:         tm.assert_index_equal(left.index, exp_index)
   73: 
   74:         exp_index, _ = right.index.sortlevel(0)
   75:         tm.assert_index_equal(right.index, exp_index)
   76: 
   77:         tups = list(map(tuple, df[["A", "B", "C", "D", "E", "F", "G", "H"]].values))
   78:         tups = com.asarray_tuplesafe(tups)
   79: 
   80:         expected = df.groupby(tups).sum()["values"]
   81: 
   82:         for k, v in expected.items():
   83:             assert left[k] == right[k[::-1]]
   84:             assert left[k] == v
   85:         assert len(left) == len(right)
   86: 
   87:     def test_int64_overflow_groupby_large_range(self):
   88:         # GH9096
   89:         values = range(55109)
   90:         data = DataFrame.from_dict({"a": values, "b": values, "c": values, "d": values})
   91:         grouped = data.groupby(["a", "b", "c", "d"])
   92:         assert len(grouped) == len(values)
   93: 
   94:     @pytest.mark.parametrize("agg", ["mean", "median"])
   95:     def test_int64_overflow_groupby_large_df_shuffled(self, agg):
   96:         rs = np.random.default_rng(2)
   97:         arr = rs.integers(-1 << 12, 1 << 12, (1 << 15, 5))
   98:         i = rs.choice(len(arr), len(arr) * 4)
   99:         arr = np.vstack((arr, arr[i]))  # add some duplicate rows
  100: 
  101:         i = rs.permutation(len(arr))
  102:         arr = arr[i]  # shuffle rows
  103: 
  104:         df = DataFrame(arr, columns=list("abcde"))
  105:         df["jim"], df["joe"] = np.zeros((2, len(df)))
  106:         gr = df.groupby(list("abcde"))
  107: 
  108:         # verify this is testing what it is supposed to test!
  109:         assert is_int64_overflow_possible(gr._grouper.shape)
  110: 
  111:         mi = MultiIndex.from_arrays(
  112:             [ar.ravel() for ar in np.array_split(np.unique(arr, axis=0), 5, axis=1)],
  113:             names=list("abcde"),
  114:         )
  115: 
  116:         res = DataFrame(
  117:             np.zeros((len(mi), 2)), columns=["jim", "joe"], index=mi
  118:         ).sort_index()
  119: 
  120:         tm.assert_frame_equal(getattr(gr, agg)(), res)
  121: 
  122:     @pytest.mark.parametrize(
  123:         "order, na_position, exp",
  124:         [
  125:             [
  126:                 True,
  127:                 "last",
  128:                 list(range(5, 105)) + list(range(5)) + list(range(105, 110)),
  129:             ],
  130:             [
  131:                 True,
  132:                 "first",
  133:                 list(range(5)) + list(range(105, 110)) + list(range(5, 105)),
  134:             ],
  135:             [
  136:                 False,
  137:                 "last",
  138:                 list(range(104, 4, -1)) + list(range(5)) + list(range(105, 110)),
  139:             ],
  140:             [
  141:                 False,
  142:                 "first",
  143:                 list(range(5)) + list(range(105, 110)) + list(range(104, 4, -1)),
  144:             ],
  145:         ],
  146:     )
  147:     def test_lexsort_indexer(self, order, na_position, exp):
  148:         keys = [[np.nan] * 5 + list(range(100)) + [np.nan] * 5]
  149:         result = lexsort_indexer(keys, orders=order, na_position=na_position)
  150:         tm.assert_numpy_array_equal(result, np.array(exp, dtype=np.intp))
  151: 
  152:     @pytest.mark.parametrize(
  153:         "ascending, na_position, exp",
  154:         [
  155:             [
  156:                 True,
  157:                 "last",
  158:                 list(range(5, 105)) + list(range(5)) + list(range(105, 110)),
  159:             ],
  160:             [
  161:                 True,
  162:                 "first",
  163:                 list(range(5)) + list(range(105, 110)) + list(range(5, 105)),
  164:             ],
  165:             [
  166:                 False,
  167:                 "last",
  168:                 list(range(104, 4, -1)) + list(range(5)) + list(range(105, 110)),
  169:             ],
  170:             [
  171:                 False,
  172:                 "first",
  173:                 list(range(5)) + list(range(105, 110)) + list(range(104, 4, -1)),
  174:             ],
  175:         ],
  176:     )
  177:     def test_nargsort(self, ascending, na_position, exp):
  178:         # list places NaNs last, np.array(..., dtype="O") may not place NaNs first
  179:         items = np.array([np.nan] * 5 + list(range(100)) + [np.nan] * 5, dtype="O")
  180: 
  181:         # mergesort is the most difficult to get right because we want it to be
  182:         # stable.
  183: 
  184:         # According to numpy/core/tests/test_multiarray, """The number of
  185:         # sorted items must be greater than ~50 to check the actual algorithm
  186:         # because quick and merge sort fall over to insertion sort for small
  187:         # arrays."""
  188: 
  189:         result = nargsort(
  190:             items, kind="mergesort", ascending=ascending, na_position=na_position
  191:         )
  192:         tm.assert_numpy_array_equal(result, np.array(exp), check_dtype=False)
  193: 
  194: 
  195: class TestMerge:
  196:     def test_int64_overflow_outer_merge(self):
  197:         # #2690, combinatorial explosion
  198:         df1 = DataFrame(
  199:             np.random.default_rng(2).standard_normal((1000, 7)),
  200:             columns=list("ABCDEF") + ["G1"],
  201:         )
  202:         df2 = DataFrame(
  203:             np.random.default_rng(3).standard_normal((1000, 7)),
  204:             columns=list("ABCDEF") + ["G2"],
  205:         )
  206:         result = merge(df1, df2, how="outer")
  207:         assert len(result) == 2000
  208: 
  209:     @pytest.mark.slow
  210:     def test_int64_overflow_check_sum_col(self, left_right):
  211:         left, right = left_right
  212: 
  213:         out = merge(left, right, how="outer")
  214:         assert len(out) == len(left)
  215:         tm.assert_series_equal(out["left"], -out["right"], check_names=False)
  216:         result = out.iloc[:, :-2].sum(axis=1)
  217:         tm.assert_series_equal(out["left"], result, check_names=False)
  218:         assert result.name is None
  219: 
  220:     @pytest.mark.slow
  221:     @pytest.mark.parametrize("how", ["left", "right", "outer", "inner"])
  222:     def test_int64_overflow_how_merge(self, left_right, how):
  223:         left, right = left_right
  224: 
  225:         out = merge(left, right, how="outer")
  226:         out.sort_values(out.columns.tolist(), inplace=True)
  227:         out.index = np.arange(len(out))
  228:         tm.assert_frame_equal(out, merge(left, right, how=how, sort=True))
  229: 
  230:     @pytest.mark.slow
  231:     def test_int64_overflow_sort_false_order(self, left_right):
  232:         left, right = left_right
  233: 
  234:         # check that left merge w/ sort=False maintains left frame order
  235:         out = merge(left, right, how="left", sort=False)
  236:         tm.assert_frame_equal(left, out[left.columns.tolist()])
  237: 
  238:         out = merge(right, left, how="left", sort=False)
  239:         tm.assert_frame_equal(right, out[right.columns.tolist()])
  240: 
  241:     @pytest.mark.slow
  242:     @pytest.mark.parametrize("how", ["left", "right", "outer", "inner"])
  243:     @pytest.mark.parametrize("sort", [True, False])
  244:     def test_int64_overflow_one_to_many_none_match(self, how, sort):
  245:         # one-2-many/none match
  246:         low, high, n = -1 << 10, 1 << 10, 1 << 11
  247:         left = DataFrame(
  248:             np.random.default_rng(2).integers(low, high, (n, 7)).astype("int64"),
  249:             columns=list("ABCDEFG"),
  250:         )
  251: 
  252:         # confirm that this is checking what it is supposed to check
  253:         shape = left.apply(Series.nunique).values
  254:         assert is_int64_overflow_possible(shape)
  255: 
  256:         # add duplicates to left frame
  257:         left = concat([left, left], ignore_index=True)
  258: 
  259:         right = DataFrame(
  260:             np.random.default_rng(3).integers(low, high, (n // 2, 7)).astype("int64"),
  261:             columns=list("ABCDEFG"),
  262:         )
  263: 
  264:         # add duplicates & overlap with left to the right frame
  265:         i = np.random.default_rng(4).choice(len(left), n)
  266:         right = concat([right, right, left.iloc[i]], ignore_index=True)
  267: 
  268:         left["left"] = np.random.default_rng(2).standard_normal(len(left))
  269:         right["right"] = np.random.default_rng(2).standard_normal(len(right))
  270: 
  271:         # shuffle left & right frames
  272:         i = np.random.default_rng(5).permutation(len(left))
  273:         left = left.iloc[i].copy()
  274:         left.index = np.arange(len(left))
  275: 
  276:         i = np.random.default_rng(6).permutation(len(right))
  277:         right = right.iloc[i].copy()
  278:         right.index = np.arange(len(right))
  279: 
  280:         # manually compute outer merge
  281:         ldict, rdict = defaultdict(list), defaultdict(list)
  282: 
  283:         for idx, row in left.set_index(list("ABCDEFG")).iterrows():
  284:             ldict[idx].append(row["left"])
  285: 
  286:         for idx, row in right.set_index(list("ABCDEFG")).iterrows():
  287:             rdict[idx].append(row["right"])
  288: 
  289:         vals = []
  290:         for k, lval in ldict.items():
  291:             rval = rdict.get(k, [np.nan])
  292:             for lv, rv in product(lval, rval):
  293:                 vals.append(
  294:                     k
  295:                     + (
  296:                         lv,
  297:                         rv,
  298:                     )
  299:                 )
  300: 
  301:         for k, rval in rdict.items():
  302:             if k not in ldict:
  303:                 vals.extend(
  304:                     k
  305:                     + (
  306:                         np.nan,
  307:                         rv,
  308:                     )
  309:                     for rv in rval
  310:                 )
  311: 
  312:         def align(df):
  313:             df = df.sort_values(df.columns.tolist())
  314:             df.index = np.arange(len(df))
  315:             return df
  316: 
  317:         out = DataFrame(vals, columns=list("ABCDEFG") + ["left", "right"])
  318:         out = align(out)
  319: 
  320:         jmask = {
  321:             "left": out["left"].notna(),
  322:             "right": out["right"].notna(),
  323:             "inner": out["left"].notna() & out["right"].notna(),
  324:             "outer": np.ones(len(out), dtype="bool"),
  325:         }
  326: 
  327:         mask = jmask[how]
  328:         frame = align(out[mask].copy())
  329:         assert mask.all() ^ mask.any() or how == "outer"
  330: 
  331:         res = merge(left, right, how=how, sort=sort)
  332:         if sort:
  333:             kcols = list("ABCDEFG")
  334:             tm.assert_frame_equal(
  335:                 res[kcols].copy(), res[kcols].sort_values(kcols, kind="mergesort")
  336:             )
  337: 
  338:         # as in GH9092 dtypes break with outer/right join
  339:         # 2021-12-18: dtype does not break anymore
  340:         tm.assert_frame_equal(frame, align(res))
  341: 
  342: 
  343: @pytest.mark.parametrize(
  344:     "codes_list, shape",
  345:     [
  346:         [
  347:             [
  348:                 np.tile([0, 1, 2, 3, 0, 1, 2, 3], 100).astype(np.int64),
  349:                 np.tile([0, 2, 4, 3, 0, 1, 2, 3], 100).astype(np.int64),
  350:                 np.tile([5, 1, 0, 2, 3, 0, 5, 4], 100).astype(np.int64),
  351:             ],
  352:             (4, 5, 6),
  353:         ],
  354:         [
  355:             [
  356:                 np.tile(np.arange(10000, dtype=np.int64), 5),
  357:                 np.tile(np.arange(10000, dtype=np.int64), 5),
  358:             ],
  359:             (10000, 10000),
  360:         ],
  361:     ],
  362: )
  363: def test_decons(codes_list, shape):
  364:     group_index = get_group_index(codes_list, shape, sort=True, xnull=True)
  365:     codes_list2 = _decons_group_index(group_index, shape)
  366: 
  367:     for a, b in zip(codes_list, codes_list2):
  368:         tm.assert_numpy_array_equal(a, b)
  369: 
  370: 
  371: class TestSafeSort:
  372:     @pytest.mark.parametrize(
  373:         "arg, exp",
  374:         [
  375:             [[3, 1, 2, 0, 4], [0, 1, 2, 3, 4]],
  376:             [
  377:                 np.array(list("baaacb"), dtype=object),
  378:                 np.array(list("aaabbc"), dtype=object),
  379:             ],
  380:             [[], []],
  381:         ],
  382:     )
  383:     def test_basic_sort(self, arg, exp):
  384:         result = safe_sort(np.array(arg))
  385:         expected = np.array(exp)
  386:         tm.assert_numpy_array_equal(result, expected)
  387: 
  388:     @pytest.mark.parametrize("verify", [True, False])
  389:     @pytest.mark.parametrize(
  390:         "codes, exp_codes",
  391:         [
  392:             [[0, 1, 1, 2, 3, 0, -1, 4], [3, 1, 1, 2, 0, 3, -1, 4]],
  393:             [[], []],
  394:         ],
  395:     )
  396:     def test_codes(self, verify, codes, exp_codes):
  397:         values = np.array([3, 1, 2, 0, 4])
  398:         expected = np.array([0, 1, 2, 3, 4])
  399: 
  400:         result, result_codes = safe_sort(
  401:             values, codes, use_na_sentinel=True, verify=verify
  402:         )
  403:         expected_codes = np.array(exp_codes, dtype=np.intp)
  404:         tm.assert_numpy_array_equal(result, expected)
  405:         tm.assert_numpy_array_equal(result_codes, expected_codes)
  406: 
  407:     def test_codes_out_of_bound(self):
  408:         values = np.array([3, 1, 2, 0, 4])
  409:         expected = np.array([0, 1, 2, 3, 4])
  410: 
  411:         # out of bound indices
  412:         codes = [0, 101, 102, 2, 3, 0, 99, 4]
  413:         result, result_codes = safe_sort(values, codes, use_na_sentinel=True)
  414:         expected_codes = np.array([3, -1, -1, 2, 0, 3, -1, 4], dtype=np.intp)
  415:         tm.assert_numpy_array_equal(result, expected)
  416:         tm.assert_numpy_array_equal(result_codes, expected_codes)
  417: 
  418:     def test_mixed_integer(self):
  419:         values = np.array(["b", 1, 0, "a", 0, "b"], dtype=object)
  420:         result = safe_sort(values)
  421:         expected = np.array([0, 0, 1, "a", "b", "b"], dtype=object)
  422:         tm.assert_numpy_array_equal(result, expected)
  423: 
  424:     def test_mixed_integer_with_codes(self):
  425:         values = np.array(["b", 1, 0, "a"], dtype=object)
  426:         codes = [0, 1, 2, 3, 0, -1, 1]
  427:         result, result_codes = safe_sort(values, codes)
  428:         expected = np.array([0, 1, "a", "b"], dtype=object)
  429:         expected_codes = np.array([3, 1, 0, 2, 3, -1, 1], dtype=np.intp)
  430:         tm.assert_numpy_array_equal(result, expected)
  431:         tm.assert_numpy_array_equal(result_codes, expected_codes)
  432: 
  433:     def test_unsortable(self):
  434:         # GH 13714
  435:         arr = np.array([1, 2, datetime.now(), 0, 3], dtype=object)
  436:         msg = "'[<>]' not supported between instances of .*"
  437:         with pytest.raises(TypeError, match=msg):
  438:             safe_sort(arr)
  439: 
  440:     @pytest.mark.parametrize(
  441:         "arg, codes, err, msg",
  442:         [
  443:             [1, None, TypeError, "Only np.ndarray, ExtensionArray, and Index"],
  444:             [np.array([0, 1, 2]), 1, TypeError, "Only list-like objects or None"],
  445:             [np.array([0, 1, 2, 1]), [0, 1], ValueError, "values should be unique"],
  446:         ],
  447:     )
  448:     def test_exceptions(self, arg, codes, err, msg):
  449:         with pytest.raises(err, match=msg):
  450:             safe_sort(values=arg, codes=codes)
  451: 
  452:     @pytest.mark.parametrize(
  453:         "arg, exp", [[[1, 3, 2], [1, 2, 3]], [[1, 3, np.nan, 2], [1, 2, 3, np.nan]]]
  454:     )
  455:     def test_extension_array(self, arg, exp):
  456:         a = array(arg, dtype="Int64")
  457:         result = safe_sort(a)
  458:         expected = array(exp, dtype="Int64")
  459:         tm.assert_extension_array_equal(result, expected)
  460: 
  461:     @pytest.mark.parametrize("verify", [True, False])
  462:     def test_extension_array_codes(self, verify):
  463:         a = array([1, 3, 2], dtype="Int64")
  464:         result, codes = safe_sort(a, [0, 1, -1, 2], use_na_sentinel=True, verify=verify)
  465:         expected_values = array([1, 2, 3], dtype="Int64")
  466:         expected_codes = np.array([0, 2, -1, 1], dtype=np.intp)
  467:         tm.assert_extension_array_equal(result, expected_values)
  468:         tm.assert_numpy_array_equal(codes, expected_codes)
  469: 
  470: 
  471: def test_mixed_str_null(nulls_fixture):
  472:     values = np.array(["b", nulls_fixture, "a", "b"], dtype=object)
  473:     result = safe_sort(values)
  474:     expected = np.array(["a", "b", "b", nulls_fixture], dtype=object)
  475:     tm.assert_numpy_array_equal(result, expected)
  476: 
  477: 
  478: def test_safe_sort_multiindex():
  479:     # GH#48412
  480:     arr1 = Series([2, 1, NA, NA], dtype="Int64")
  481:     arr2 = [2, 1, 3, 3]
  482:     midx = MultiIndex.from_arrays([arr1, arr2])
  483:     result = safe_sort(midx)
  484:     expected = MultiIndex.from_arrays(
  485:         [Series([1, 2, NA, NA], dtype="Int64"), [1, 2, 3, 3]]
  486:     )
  487:     tm.assert_index_equal(result, expected)
