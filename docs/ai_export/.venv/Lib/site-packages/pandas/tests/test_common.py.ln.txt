    1: import collections
    2: from functools import partial
    3: import string
    4: import subprocess
    5: import sys
    6: import textwrap
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: import pandas as pd
   12: from pandas import Series
   13: import pandas._testing as tm
   14: from pandas.core import ops
   15: import pandas.core.common as com
   16: from pandas.util.version import Version
   17: 
   18: 
   19: def test_get_callable_name():
   20:     getname = com.get_callable_name
   21: 
   22:     def fn(x):
   23:         return x
   24: 
   25:     lambda_ = lambda x: x
   26:     part1 = partial(fn)
   27:     part2 = partial(part1)
   28: 
   29:     class somecall:
   30:         def __call__(self):
   31:             # This shouldn't actually get called below; somecall.__init__
   32:             #  should.
   33:             raise NotImplementedError
   34: 
   35:     assert getname(fn) == "fn"
   36:     assert getname(lambda_)
   37:     assert getname(part1) == "fn"
   38:     assert getname(part2) == "fn"
   39:     assert getname(somecall()) == "somecall"
   40:     assert getname(1) is None
   41: 
   42: 
   43: def test_any_none():
   44:     assert com.any_none(1, 2, 3, None)
   45:     assert not com.any_none(1, 2, 3, 4)
   46: 
   47: 
   48: def test_all_not_none():
   49:     assert com.all_not_none(1, 2, 3, 4)
   50:     assert not com.all_not_none(1, 2, 3, None)
   51:     assert not com.all_not_none(None, None, None, None)
   52: 
   53: 
   54: def test_random_state():
   55:     # Check with seed
   56:     state = com.random_state(5)
   57:     assert state.uniform() == np.random.RandomState(5).uniform()
   58: 
   59:     # Check with random state object
   60:     state2 = np.random.RandomState(10)
   61:     assert com.random_state(state2).uniform() == np.random.RandomState(10).uniform()
   62: 
   63:     # check with no arg random state
   64:     assert com.random_state() is np.random
   65: 
   66:     # check array-like
   67:     # GH32503
   68:     state_arr_like = np.random.default_rng(None).integers(
   69:         0, 2**31, size=624, dtype="uint32"
   70:     )
   71:     assert (
   72:         com.random_state(state_arr_like).uniform()
   73:         == np.random.RandomState(state_arr_like).uniform()
   74:     )
   75: 
   76:     # Check BitGenerators
   77:     # GH32503
   78:     assert (
   79:         com.random_state(np.random.MT19937(3)).uniform()
   80:         == np.random.RandomState(np.random.MT19937(3)).uniform()
   81:     )
   82:     assert (
   83:         com.random_state(np.random.PCG64(11)).uniform()
   84:         == np.random.RandomState(np.random.PCG64(11)).uniform()
   85:     )
   86: 
   87:     # Error for floats or strings
   88:     msg = (
   89:         "random_state must be an integer, array-like, a BitGenerator, Generator, "
   90:         "a numpy RandomState, or None"
   91:     )
   92:     with pytest.raises(ValueError, match=msg):
   93:         com.random_state("test")
   94: 
   95:     with pytest.raises(ValueError, match=msg):
   96:         com.random_state(5.5)
   97: 
   98: 
   99: @pytest.mark.parametrize(
  100:     "left, right, expected",
  101:     [
  102:         (Series([1], name="x"), Series([2], name="x"), "x"),
  103:         (Series([1], name="x"), Series([2], name="y"), None),
  104:         (Series([1]), Series([2], name="x"), None),
  105:         (Series([1], name="x"), Series([2]), None),
  106:         (Series([1], name="x"), [2], "x"),
  107:         ([1], Series([2], name="y"), "y"),
  108:         # matching NAs
  109:         (Series([1], name=np.nan), pd.Index([], name=np.nan), np.nan),
  110:         (Series([1], name=np.nan), pd.Index([], name=pd.NaT), None),
  111:         (Series([1], name=pd.NA), pd.Index([], name=pd.NA), pd.NA),
  112:         # tuple name GH#39757
  113:         (
  114:             Series([1], name=np.int64(1)),
  115:             pd.Index([], name=(np.int64(1), np.int64(2))),
  116:             None,
  117:         ),
  118:         (
  119:             Series([1], name=(np.int64(1), np.int64(2))),
  120:             pd.Index([], name=(np.int64(1), np.int64(2))),
  121:             (np.int64(1), np.int64(2)),
  122:         ),
  123:         pytest.param(
  124:             Series([1], name=(np.float64("nan"), np.int64(2))),
  125:             pd.Index([], name=(np.float64("nan"), np.int64(2))),
  126:             (np.float64("nan"), np.int64(2)),
  127:             marks=pytest.mark.xfail(
  128:                 reason="Not checking for matching NAs inside tuples."
  129:             ),
  130:         ),
  131:     ],
  132: )
  133: def test_maybe_match_name(left, right, expected):
  134:     res = ops.common._maybe_match_name(left, right)
  135:     assert res is expected or res == expected
  136: 
  137: 
  138: def test_standardize_mapping():
  139:     # No uninitialized defaultdicts
  140:     msg = r"to_dict\(\) only accepts initialized defaultdicts"
  141:     with pytest.raises(TypeError, match=msg):
  142:         com.standardize_mapping(collections.defaultdict)
  143: 
  144:     # No non-mapping subtypes, instance
  145:     msg = "unsupported type: <class 'list'>"
  146:     with pytest.raises(TypeError, match=msg):
  147:         com.standardize_mapping([])
  148: 
  149:     # No non-mapping subtypes, class
  150:     with pytest.raises(TypeError, match=msg):
  151:         com.standardize_mapping(list)
  152: 
  153:     fill = {"bad": "data"}
  154:     assert com.standardize_mapping(fill) == dict
  155: 
  156:     # Convert instance to type
  157:     assert com.standardize_mapping({}) == dict
  158: 
  159:     dd = collections.defaultdict(list)
  160:     assert isinstance(com.standardize_mapping(dd), partial)
  161: 
  162: 
  163: def test_git_version():
  164:     # GH 21295
  165:     git_version = pd.__git_version__
  166:     assert len(git_version) == 40
  167:     assert all(c in string.hexdigits for c in git_version)
  168: 
  169: 
  170: def test_version_tag():
  171:     version = Version(pd.__version__)
  172:     try:
  173:         version > Version("0.0.1")
  174:     except TypeError:
  175:         raise ValueError(
  176:             "No git tags exist, please sync tags between upstream and your repo"
  177:         )
  178: 
  179: 
  180: @pytest.mark.parametrize(
  181:     "obj", [(obj,) for obj in pd.__dict__.values() if callable(obj)]
  182: )
  183: def test_serializable(obj):
  184:     # GH 35611
  185:     unpickled = tm.round_trip_pickle(obj)
  186:     assert type(obj) == type(unpickled)
  187: 
  188: 
  189: class TestIsBoolIndexer:
  190:     def test_non_bool_array_with_na(self):
  191:         # in particular, this should not raise
  192:         arr = np.array(["A", "B", np.nan], dtype=object)
  193:         assert not com.is_bool_indexer(arr)
  194: 
  195:     def test_list_subclass(self):
  196:         # GH#42433
  197: 
  198:         class MyList(list):
  199:             pass
  200: 
  201:         val = MyList(["a"])
  202: 
  203:         assert not com.is_bool_indexer(val)
  204: 
  205:         val = MyList([True])
  206:         assert com.is_bool_indexer(val)
  207: 
  208:     def test_frozenlist(self):
  209:         # GH#42461
  210:         data = {"col1": [1, 2], "col2": [3, 4]}
  211:         df = pd.DataFrame(data=data)
  212: 
  213:         frozen = df.index.names[1:]
  214:         assert not com.is_bool_indexer(frozen)
  215: 
  216:         result = df[frozen]
  217:         expected = df[[]]
  218:         tm.assert_frame_equal(result, expected)
  219: 
  220: 
  221: @pytest.mark.parametrize("with_exception", [True, False])
  222: def test_temp_setattr(with_exception):
  223:     # GH#45954
  224:     ser = Series(dtype=object)
  225:     ser.name = "first"
  226:     # Raise a ValueError in either case to satisfy pytest.raises
  227:     match = "Inside exception raised" if with_exception else "Outside exception raised"
  228:     with pytest.raises(ValueError, match=match):
  229:         with com.temp_setattr(ser, "name", "second"):
  230:             assert ser.name == "second"
  231:             if with_exception:
  232:                 raise ValueError("Inside exception raised")
  233:         raise ValueError("Outside exception raised")
  234:     assert ser.name == "first"
  235: 
  236: 
  237: @pytest.mark.single_cpu
  238: def test_str_size():
  239:     # GH#21758
  240:     a = "a"
  241:     expected = sys.getsizeof(a)
  242:     pyexe = sys.executable.replace("\\", "/")
  243:     call = [
  244:         pyexe,
  245:         "-c",
  246:         "a='a';import sys;sys.getsizeof(a);import pandas;print(sys.getsizeof(a));",
  247:     ]
  248:     result = subprocess.check_output(call).decode()[-4:-1].strip("\n")
  249:     assert int(result) == int(expected)
  250: 
  251: 
  252: @pytest.mark.single_cpu
  253: def test_bz2_missing_import():
  254:     # Check whether bz2 missing import is handled correctly (issue #53857)
  255:     code = """
  256:         import sys
  257:         sys.modules['bz2'] = None
  258:         import pytest
  259:         import pandas as pd
  260:         from pandas.compat import get_bz2_file
  261:         msg = 'bz2 module not available.'
  262:         with pytest.raises(RuntimeError, match=msg):
  263:             get_bz2_file()
  264:     """
  265:     code = textwrap.dedent(code)
  266:     call = [sys.executable, "-c", code]
  267:     subprocess.check_output(call)
