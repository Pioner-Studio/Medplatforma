    1: """
    2: test setting *parts* of objects both positionally and label based
    3: 
    4: TODO: these should be split among the indexer tests
    5: """
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: import pandas as pd
   11: from pandas import (
   12:     DataFrame,
   13:     Index,
   14:     Period,
   15:     Series,
   16:     Timestamp,
   17:     date_range,
   18:     period_range,
   19: )
   20: import pandas._testing as tm
   21: 
   22: 
   23: class TestEmptyFrameSetitemExpansion:
   24:     def test_empty_frame_setitem_index_name_retained(self):
   25:         # GH#31368 empty frame has non-None index.name -> retained
   26:         df = DataFrame({}, index=pd.RangeIndex(0, name="df_index"))
   27:         series = Series(1.23, index=pd.RangeIndex(4, name="series_index"))
   28: 
   29:         df["series"] = series
   30:         expected = DataFrame(
   31:             {"series": [1.23] * 4},
   32:             index=pd.RangeIndex(4, name="df_index"),
   33:             columns=Index(["series"], dtype=object),
   34:         )
   35: 
   36:         tm.assert_frame_equal(df, expected)
   37: 
   38:     def test_empty_frame_setitem_index_name_inherited(self):
   39:         # GH#36527 empty frame has None index.name -> not retained
   40:         df = DataFrame()
   41:         series = Series(1.23, index=pd.RangeIndex(4, name="series_index"))
   42:         df["series"] = series
   43:         expected = DataFrame(
   44:             {"series": [1.23] * 4},
   45:             index=pd.RangeIndex(4, name="series_index"),
   46:             columns=Index(["series"], dtype=object),
   47:         )
   48:         tm.assert_frame_equal(df, expected)
   49: 
   50:     def test_loc_setitem_zerolen_series_columns_align(self):
   51:         # columns will align
   52:         df = DataFrame(columns=["A", "B"])
   53:         df.loc[0] = Series(1, index=range(4))
   54:         expected = DataFrame(columns=["A", "B"], index=[0], dtype=np.float64)
   55:         tm.assert_frame_equal(df, expected)
   56: 
   57:         # columns will align
   58:         df = DataFrame(columns=["A", "B"])
   59:         df.loc[0] = Series(1, index=["B"])
   60: 
   61:         exp = DataFrame([[np.nan, 1]], columns=["A", "B"], index=[0], dtype="float64")
   62:         tm.assert_frame_equal(df, exp)
   63: 
   64:     def test_loc_setitem_zerolen_list_length_must_match_columns(self):
   65:         # list-like must conform
   66:         df = DataFrame(columns=["A", "B"])
   67: 
   68:         msg = "cannot set a row with mismatched columns"
   69:         with pytest.raises(ValueError, match=msg):
   70:             df.loc[0] = [1, 2, 3]
   71: 
   72:         df = DataFrame(columns=["A", "B"])
   73:         df.loc[3] = [6, 7]  # length matches len(df.columns) --> OK!
   74: 
   75:         exp = DataFrame([[6, 7]], index=[3], columns=["A", "B"], dtype=np.int64)
   76:         tm.assert_frame_equal(df, exp)
   77: 
   78:     def test_partial_set_empty_frame(self):
   79:         # partially set with an empty object
   80:         # frame
   81:         df = DataFrame()
   82: 
   83:         msg = "cannot set a frame with no defined columns"
   84: 
   85:         with pytest.raises(ValueError, match=msg):
   86:             df.loc[1] = 1
   87: 
   88:         with pytest.raises(ValueError, match=msg):
   89:             df.loc[1] = Series([1], index=["foo"])
   90: 
   91:         msg = "cannot set a frame with no defined index and a scalar"
   92:         with pytest.raises(ValueError, match=msg):
   93:             df.loc[:, 1] = 1
   94: 
   95:     def test_partial_set_empty_frame2(self):
   96:         # these work as they don't really change
   97:         # anything but the index
   98:         # GH#5632
   99:         expected = DataFrame(
  100:             columns=Index(["foo"], dtype=object), index=Index([], dtype="object")
  101:         )
  102: 
  103:         df = DataFrame(index=Index([], dtype="object"))
  104:         df["foo"] = Series([], dtype="object")
  105: 
  106:         tm.assert_frame_equal(df, expected)
  107: 
  108:         df = DataFrame(index=Index([]))
  109:         df["foo"] = Series(df.index)
  110: 
  111:         tm.assert_frame_equal(df, expected)
  112: 
  113:         df = DataFrame(index=Index([]))
  114:         df["foo"] = df.index
  115: 
  116:         tm.assert_frame_equal(df, expected)
  117: 
  118:     def test_partial_set_empty_frame3(self):
  119:         expected = DataFrame(
  120:             columns=Index(["foo"], dtype=object), index=Index([], dtype="int64")
  121:         )
  122:         expected["foo"] = expected["foo"].astype("float64")
  123: 
  124:         df = DataFrame(index=Index([], dtype="int64"))
  125:         df["foo"] = []
  126: 
  127:         tm.assert_frame_equal(df, expected)
  128: 
  129:         df = DataFrame(index=Index([], dtype="int64"))
  130:         df["foo"] = Series(np.arange(len(df)), dtype="float64")
  131: 
  132:         tm.assert_frame_equal(df, expected)
  133: 
  134:     def test_partial_set_empty_frame4(self):
  135:         df = DataFrame(index=Index([], dtype="int64"))
  136:         df["foo"] = range(len(df))
  137: 
  138:         expected = DataFrame(
  139:             columns=Index(["foo"], dtype=object), index=Index([], dtype="int64")
  140:         )
  141:         # range is int-dtype-like, so we get int64 dtype
  142:         expected["foo"] = expected["foo"].astype("int64")
  143:         tm.assert_frame_equal(df, expected)
  144: 
  145:     def test_partial_set_empty_frame5(self):
  146:         df = DataFrame()
  147:         tm.assert_index_equal(df.columns, pd.RangeIndex(0))
  148:         df2 = DataFrame()
  149:         df2[1] = Series([1], index=["foo"])
  150:         df.loc[:, 1] = Series([1], index=["foo"])
  151:         tm.assert_frame_equal(df, DataFrame([[1]], index=["foo"], columns=[1]))
  152:         tm.assert_frame_equal(df, df2)
  153: 
  154:     def test_partial_set_empty_frame_no_index(self):
  155:         # no index to start
  156:         expected = DataFrame({0: Series(1, index=range(4))}, columns=["A", "B", 0])
  157: 
  158:         df = DataFrame(columns=["A", "B"])
  159:         df[0] = Series(1, index=range(4))
  160:         tm.assert_frame_equal(df, expected)
  161: 
  162:         df = DataFrame(columns=["A", "B"])
  163:         df.loc[:, 0] = Series(1, index=range(4))
  164:         tm.assert_frame_equal(df, expected)
  165: 
  166:     def test_partial_set_empty_frame_row(self):
  167:         # GH#5720, GH#5744
  168:         # don't create rows when empty
  169:         expected = DataFrame(columns=["A", "B", "New"], index=Index([], dtype="int64"))
  170:         expected["A"] = expected["A"].astype("int64")
  171:         expected["B"] = expected["B"].astype("float64")
  172:         expected["New"] = expected["New"].astype("float64")
  173: 
  174:         df = DataFrame({"A": [1, 2, 3], "B": [1.2, 4.2, 5.2]})
  175:         y = df[df.A > 5]
  176:         y["New"] = np.nan
  177:         tm.assert_frame_equal(y, expected)
  178: 
  179:         expected = DataFrame(columns=["a", "b", "c c", "d"])
  180:         expected["d"] = expected["d"].astype("int64")
  181:         df = DataFrame(columns=["a", "b", "c c"])
  182:         df["d"] = 3
  183:         tm.assert_frame_equal(df, expected)
  184:         tm.assert_series_equal(df["c c"], Series(name="c c", dtype=object))
  185: 
  186:         # reindex columns is ok
  187:         df = DataFrame({"A": [1, 2, 3], "B": [1.2, 4.2, 5.2]})
  188:         y = df[df.A > 5]
  189:         result = y.reindex(columns=["A", "B", "C"])
  190:         expected = DataFrame(columns=["A", "B", "C"])
  191:         expected["A"] = expected["A"].astype("int64")
  192:         expected["B"] = expected["B"].astype("float64")
  193:         expected["C"] = expected["C"].astype("float64")
  194:         tm.assert_frame_equal(result, expected)
  195: 
  196:     def test_partial_set_empty_frame_set_series(self):
  197:         # GH#5756
  198:         # setting with empty Series
  199:         df = DataFrame(Series(dtype=object))
  200:         expected = DataFrame({0: Series(dtype=object)})
  201:         tm.assert_frame_equal(df, expected)
  202: 
  203:         df = DataFrame(Series(name="foo", dtype=object))
  204:         expected = DataFrame({"foo": Series(dtype=object)})
  205:         tm.assert_frame_equal(df, expected)
  206: 
  207:     def test_partial_set_empty_frame_empty_copy_assignment(self):
  208:         # GH#5932
  209:         # copy on empty with assignment fails
  210:         df = DataFrame(index=[0])
  211:         df = df.copy()
  212:         df["a"] = 0
  213:         expected = DataFrame(0, index=[0], columns=Index(["a"], dtype=object))
  214:         tm.assert_frame_equal(df, expected)
  215: 
  216:     def test_partial_set_empty_frame_empty_consistencies(self, using_infer_string):
  217:         # GH#6171
  218:         # consistency on empty frames
  219:         df = DataFrame(columns=["x", "y"])
  220:         df["x"] = [1, 2]
  221:         expected = DataFrame({"x": [1, 2], "y": [np.nan, np.nan]})
  222:         tm.assert_frame_equal(df, expected, check_dtype=False)
  223: 
  224:         df = DataFrame(columns=["x", "y"])
  225:         df["x"] = ["1", "2"]
  226:         expected = DataFrame(
  227:             {
  228:                 "x": Series(
  229:                     ["1", "2"],
  230:                     dtype=object if not using_infer_string else "string[pyarrow_numpy]",
  231:                 ),
  232:                 "y": Series([np.nan, np.nan], dtype=object),
  233:             }
  234:         )
  235:         tm.assert_frame_equal(df, expected)
  236: 
  237:         df = DataFrame(columns=["x", "y"])
  238:         df.loc[0, "x"] = 1
  239:         expected = DataFrame({"x": [1], "y": [np.nan]})
  240:         tm.assert_frame_equal(df, expected, check_dtype=False)
  241: 
  242: 
  243: class TestPartialSetting:
  244:     def test_partial_setting(self):
  245:         # GH2578, allow ix and friends to partially set
  246: 
  247:         # series
  248:         s_orig = Series([1, 2, 3])
  249: 
  250:         s = s_orig.copy()
  251:         s[5] = 5
  252:         expected = Series([1, 2, 3, 5], index=[0, 1, 2, 5])
  253:         tm.assert_series_equal(s, expected)
  254: 
  255:         s = s_orig.copy()
  256:         s.loc[5] = 5
  257:         expected = Series([1, 2, 3, 5], index=[0, 1, 2, 5])
  258:         tm.assert_series_equal(s, expected)
  259: 
  260:         s = s_orig.copy()
  261:         s[5] = 5.0
  262:         expected = Series([1, 2, 3, 5.0], index=[0, 1, 2, 5])
  263:         tm.assert_series_equal(s, expected)
  264: 
  265:         s = s_orig.copy()
  266:         s.loc[5] = 5.0
  267:         expected = Series([1, 2, 3, 5.0], index=[0, 1, 2, 5])
  268:         tm.assert_series_equal(s, expected)
  269: 
  270:         # iloc/iat raise
  271:         s = s_orig.copy()
  272: 
  273:         msg = "iloc cannot enlarge its target object"
  274:         with pytest.raises(IndexError, match=msg):
  275:             s.iloc[3] = 5.0
  276: 
  277:         msg = "index 3 is out of bounds for axis 0 with size 3"
  278:         with pytest.raises(IndexError, match=msg):
  279:             s.iat[3] = 5.0
  280: 
  281:     @pytest.mark.filterwarnings("ignore:Setting a value on a view:FutureWarning")
  282:     def test_partial_setting_frame(self, using_array_manager):
  283:         df_orig = DataFrame(
  284:             np.arange(6).reshape(3, 2), columns=["A", "B"], dtype="int64"
  285:         )
  286: 
  287:         # iloc/iat raise
  288:         df = df_orig.copy()
  289: 
  290:         msg = "iloc cannot enlarge its target object"
  291:         with pytest.raises(IndexError, match=msg):
  292:             df.iloc[4, 2] = 5.0
  293: 
  294:         msg = "index 2 is out of bounds for axis 0 with size 2"
  295:         if using_array_manager:
  296:             msg = "list index out of range"
  297:         with pytest.raises(IndexError, match=msg):
  298:             df.iat[4, 2] = 5.0
  299: 
  300:         # row setting where it exists
  301:         expected = DataFrame({"A": [0, 4, 4], "B": [1, 5, 5]})
  302:         df = df_orig.copy()
  303:         df.iloc[1] = df.iloc[2]
  304:         tm.assert_frame_equal(df, expected)
  305: 
  306:         expected = DataFrame({"A": [0, 4, 4], "B": [1, 5, 5]})
  307:         df = df_orig.copy()
  308:         df.loc[1] = df.loc[2]
  309:         tm.assert_frame_equal(df, expected)
  310: 
  311:         # like 2578, partial setting with dtype preservation
  312:         expected = DataFrame({"A": [0, 2, 4, 4], "B": [1, 3, 5, 5]})
  313:         df = df_orig.copy()
  314:         df.loc[3] = df.loc[2]
  315:         tm.assert_frame_equal(df, expected)
  316: 
  317:         # single dtype frame, overwrite
  318:         expected = DataFrame({"A": [0, 2, 4], "B": [0, 2, 4]})
  319:         df = df_orig.copy()
  320:         df.loc[:, "B"] = df.loc[:, "A"]
  321:         tm.assert_frame_equal(df, expected)
  322: 
  323:         # mixed dtype frame, overwrite
  324:         expected = DataFrame({"A": [0, 2, 4], "B": Series([0.0, 2.0, 4.0])})
  325:         df = df_orig.copy()
  326:         df["B"] = df["B"].astype(np.float64)
  327:         # as of 2.0, df.loc[:, "B"] = ... attempts (and here succeeds) at
  328:         #  setting inplace
  329:         df.loc[:, "B"] = df.loc[:, "A"]
  330:         tm.assert_frame_equal(df, expected)
  331: 
  332:         # single dtype frame, partial setting
  333:         expected = df_orig.copy()
  334:         expected["C"] = df["A"]
  335:         df = df_orig.copy()
  336:         df.loc[:, "C"] = df.loc[:, "A"]
  337:         tm.assert_frame_equal(df, expected)
  338: 
  339:         # mixed frame, partial setting
  340:         expected = df_orig.copy()
  341:         expected["C"] = df["A"]
  342:         df = df_orig.copy()
  343:         df.loc[:, "C"] = df.loc[:, "A"]
  344:         tm.assert_frame_equal(df, expected)
  345: 
  346:     def test_partial_setting2(self):
  347:         # GH 8473
  348:         dates = date_range("1/1/2000", periods=8)
  349:         df_orig = DataFrame(
  350:             np.random.default_rng(2).standard_normal((8, 4)),
  351:             index=dates,
  352:             columns=["A", "B", "C", "D"],
  353:         )
  354: 
  355:         expected = pd.concat(
  356:             [df_orig, DataFrame({"A": 7}, index=dates[-1:] + dates.freq)], sort=True
  357:         )
  358:         df = df_orig.copy()
  359:         df.loc[dates[-1] + dates.freq, "A"] = 7
  360:         tm.assert_frame_equal(df, expected)
  361:         df = df_orig.copy()
  362:         df.at[dates[-1] + dates.freq, "A"] = 7
  363:         tm.assert_frame_equal(df, expected)
  364: 
  365:         exp_other = DataFrame({0: 7}, index=dates[-1:] + dates.freq)
  366:         expected = pd.concat([df_orig, exp_other], axis=1)
  367: 
  368:         df = df_orig.copy()
  369:         df.loc[dates[-1] + dates.freq, 0] = 7
  370:         tm.assert_frame_equal(df, expected)
  371:         df = df_orig.copy()
  372:         df.at[dates[-1] + dates.freq, 0] = 7
  373:         tm.assert_frame_equal(df, expected)
  374: 
  375:     def test_partial_setting_mixed_dtype(self):
  376:         # in a mixed dtype environment, try to preserve dtypes
  377:         # by appending
  378:         df = DataFrame([[True, 1], [False, 2]], columns=["female", "fitness"])
  379: 
  380:         s = df.loc[1].copy()
  381:         s.name = 2
  382:         expected = pd.concat([df, DataFrame(s).T.infer_objects()])
  383: 
  384:         df.loc[2] = df.loc[1]
  385:         tm.assert_frame_equal(df, expected)
  386: 
  387:     def test_series_partial_set(self):
  388:         # partial set with new index
  389:         # Regression from GH4825
  390:         ser = Series([0.1, 0.2], index=[1, 2])
  391: 
  392:         # loc equiv to .reindex
  393:         expected = Series([np.nan, 0.2, np.nan], index=[3, 2, 3])
  394:         with pytest.raises(KeyError, match=r"not in index"):
  395:             ser.loc[[3, 2, 3]]
  396: 
  397:         result = ser.reindex([3, 2, 3])
  398:         tm.assert_series_equal(result, expected, check_index_type=True)
  399: 
  400:         expected = Series([np.nan, 0.2, np.nan, np.nan], index=[3, 2, 3, "x"])
  401:         with pytest.raises(KeyError, match="not in index"):
  402:             ser.loc[[3, 2, 3, "x"]]
  403: 
  404:         result = ser.reindex([3, 2, 3, "x"])
  405:         tm.assert_series_equal(result, expected, check_index_type=True)
  406: 
  407:         expected = Series([0.2, 0.2, 0.1], index=[2, 2, 1])
  408:         result = ser.loc[[2, 2, 1]]
  409:         tm.assert_series_equal(result, expected, check_index_type=True)
  410: 
  411:         expected = Series([0.2, 0.2, np.nan, 0.1], index=[2, 2, "x", 1])
  412:         with pytest.raises(KeyError, match="not in index"):
  413:             ser.loc[[2, 2, "x", 1]]
  414: 
  415:         result = ser.reindex([2, 2, "x", 1])
  416:         tm.assert_series_equal(result, expected, check_index_type=True)
  417: 
  418:         # raises as nothing is in the index
  419:         msg = (
  420:             rf"\"None of \[Index\(\[3, 3, 3\], dtype='{np.dtype(int)}'\)\] "
  421:             r"are in the \[index\]\""
  422:         )
  423:         with pytest.raises(KeyError, match=msg):
  424:             ser.loc[[3, 3, 3]]
  425: 
  426:         expected = Series([0.2, 0.2, np.nan], index=[2, 2, 3])
  427:         with pytest.raises(KeyError, match="not in index"):
  428:             ser.loc[[2, 2, 3]]
  429: 
  430:         result = ser.reindex([2, 2, 3])
  431:         tm.assert_series_equal(result, expected, check_index_type=True)
  432: 
  433:         s = Series([0.1, 0.2, 0.3], index=[1, 2, 3])
  434:         expected = Series([0.3, np.nan, np.nan], index=[3, 4, 4])
  435:         with pytest.raises(KeyError, match="not in index"):
  436:             s.loc[[3, 4, 4]]
  437: 
  438:         result = s.reindex([3, 4, 4])
  439:         tm.assert_series_equal(result, expected, check_index_type=True)
  440: 
  441:         s = Series([0.1, 0.2, 0.3, 0.4], index=[1, 2, 3, 4])
  442:         expected = Series([np.nan, 0.3, 0.3], index=[5, 3, 3])
  443:         with pytest.raises(KeyError, match="not in index"):
  444:             s.loc[[5, 3, 3]]
  445: 
  446:         result = s.reindex([5, 3, 3])
  447:         tm.assert_series_equal(result, expected, check_index_type=True)
  448: 
  449:         s = Series([0.1, 0.2, 0.3, 0.4], index=[1, 2, 3, 4])
  450:         expected = Series([np.nan, 0.4, 0.4], index=[5, 4, 4])
  451:         with pytest.raises(KeyError, match="not in index"):
  452:             s.loc[[5, 4, 4]]
  453: 
  454:         result = s.reindex([5, 4, 4])
  455:         tm.assert_series_equal(result, expected, check_index_type=True)
  456: 
  457:         s = Series([0.1, 0.2, 0.3, 0.4], index=[4, 5, 6, 7])
  458:         expected = Series([0.4, np.nan, np.nan], index=[7, 2, 2])
  459:         with pytest.raises(KeyError, match="not in index"):
  460:             s.loc[[7, 2, 2]]
  461: 
  462:         result = s.reindex([7, 2, 2])
  463:         tm.assert_series_equal(result, expected, check_index_type=True)
  464: 
  465:         s = Series([0.1, 0.2, 0.3, 0.4], index=[1, 2, 3, 4])
  466:         expected = Series([0.4, np.nan, np.nan], index=[4, 5, 5])
  467:         with pytest.raises(KeyError, match="not in index"):
  468:             s.loc[[4, 5, 5]]
  469: 
  470:         result = s.reindex([4, 5, 5])
  471:         tm.assert_series_equal(result, expected, check_index_type=True)
  472: 
  473:         # iloc
  474:         expected = Series([0.2, 0.2, 0.1, 0.1], index=[2, 2, 1, 1])
  475:         result = ser.iloc[[1, 1, 0, 0]]
  476:         tm.assert_series_equal(result, expected, check_index_type=True)
  477: 
  478:     def test_series_partial_set_with_name(self):
  479:         # GH 11497
  480: 
  481:         idx = Index([1, 2], dtype="int64", name="idx")
  482:         ser = Series([0.1, 0.2], index=idx, name="s")
  483: 
  484:         # loc
  485:         with pytest.raises(KeyError, match=r"\[3\] not in index"):
  486:             ser.loc[[3, 2, 3]]
  487: 
  488:         with pytest.raises(KeyError, match=r"not in index"):
  489:             ser.loc[[3, 2, 3, "x"]]
  490: 
  491:         exp_idx = Index([2, 2, 1], dtype="int64", name="idx")
  492:         expected = Series([0.2, 0.2, 0.1], index=exp_idx, name="s")
  493:         result = ser.loc[[2, 2, 1]]
  494:         tm.assert_series_equal(result, expected, check_index_type=True)
  495: 
  496:         with pytest.raises(KeyError, match=r"\['x'\] not in index"):
  497:             ser.loc[[2, 2, "x", 1]]
  498: 
  499:         # raises as nothing is in the index
  500:         msg = (
  501:             rf"\"None of \[Index\(\[3, 3, 3\], dtype='{np.dtype(int)}', "
  502:             r"name='idx'\)\] are in the \[index\]\""
  503:         )
  504:         with pytest.raises(KeyError, match=msg):
  505:             ser.loc[[3, 3, 3]]
  506: 
  507:         with pytest.raises(KeyError, match="not in index"):
  508:             ser.loc[[2, 2, 3]]
  509: 
  510:         idx = Index([1, 2, 3], dtype="int64", name="idx")
  511:         with pytest.raises(KeyError, match="not in index"):
  512:             Series([0.1, 0.2, 0.3], index=idx, name="s").loc[[3, 4, 4]]
  513: 
  514:         idx = Index([1, 2, 3, 4], dtype="int64", name="idx")
  515:         with pytest.raises(KeyError, match="not in index"):
  516:             Series([0.1, 0.2, 0.3, 0.4], index=idx, name="s").loc[[5, 3, 3]]
  517: 
  518:         idx = Index([1, 2, 3, 4], dtype="int64", name="idx")
  519:         with pytest.raises(KeyError, match="not in index"):
  520:             Series([0.1, 0.2, 0.3, 0.4], index=idx, name="s").loc[[5, 4, 4]]
  521: 
  522:         idx = Index([4, 5, 6, 7], dtype="int64", name="idx")
  523:         with pytest.raises(KeyError, match="not in index"):
  524:             Series([0.1, 0.2, 0.3, 0.4], index=idx, name="s").loc[[7, 2, 2]]
  525: 
  526:         idx = Index([1, 2, 3, 4], dtype="int64", name="idx")
  527:         with pytest.raises(KeyError, match="not in index"):
  528:             Series([0.1, 0.2, 0.3, 0.4], index=idx, name="s").loc[[4, 5, 5]]
  529: 
  530:         # iloc
  531:         exp_idx = Index([2, 2, 1, 1], dtype="int64", name="idx")
  532:         expected = Series([0.2, 0.2, 0.1, 0.1], index=exp_idx, name="s")
  533:         result = ser.iloc[[1, 1, 0, 0]]
  534:         tm.assert_series_equal(result, expected, check_index_type=True)
  535: 
  536:     @pytest.mark.parametrize("key", [100, 100.0])
  537:     def test_setitem_with_expansion_numeric_into_datetimeindex(self, key):
  538:         # GH#4940 inserting non-strings
  539:         orig = DataFrame(
  540:             np.random.default_rng(2).standard_normal((10, 4)),
  541:             columns=Index(list("ABCD"), dtype=object),
  542:             index=date_range("2000-01-01", periods=10, freq="B"),
  543:         )
  544:         df = orig.copy()
  545: 
  546:         df.loc[key, :] = df.iloc[0]
  547:         ex_index = Index(list(orig.index) + [key], dtype=object, name=orig.index.name)
  548:         ex_data = np.concatenate([orig.values, df.iloc[[0]].values], axis=0)
  549:         expected = DataFrame(ex_data, index=ex_index, columns=orig.columns)
  550: 
  551:         tm.assert_frame_equal(df, expected)
  552: 
  553:     def test_partial_set_invalid(self):
  554:         # GH 4940
  555:         # allow only setting of 'valid' values
  556: 
  557:         orig = DataFrame(
  558:             np.random.default_rng(2).standard_normal((10, 4)),
  559:             columns=Index(list("ABCD"), dtype=object),
  560:             index=date_range("2000-01-01", periods=10, freq="B"),
  561:         )
  562: 
  563:         # allow object conversion here
  564:         df = orig.copy()
  565:         df.loc["a", :] = df.iloc[0]
  566:         ser = Series(df.iloc[0], name="a")
  567:         exp = pd.concat([orig, DataFrame(ser).T.infer_objects()])
  568:         tm.assert_frame_equal(df, exp)
  569:         tm.assert_index_equal(df.index, Index(orig.index.tolist() + ["a"]))
  570:         assert df.index.dtype == "object"
  571: 
  572:     @pytest.mark.parametrize(
  573:         "idx,labels,expected_idx",
  574:         [
  575:             (
  576:                 period_range(start="2000", periods=20, freq="D"),
  577:                 ["2000-01-04", "2000-01-08", "2000-01-12"],
  578:                 [
  579:                     Period("2000-01-04", freq="D"),
  580:                     Period("2000-01-08", freq="D"),
  581:                     Period("2000-01-12", freq="D"),
  582:                 ],
  583:             ),
  584:             (
  585:                 date_range(start="2000", periods=20, freq="D"),
  586:                 ["2000-01-04", "2000-01-08", "2000-01-12"],
  587:                 [
  588:                     Timestamp("2000-01-04"),
  589:                     Timestamp("2000-01-08"),
  590:                     Timestamp("2000-01-12"),
  591:                 ],
  592:             ),
  593:             (
  594:                 pd.timedelta_range(start="1 day", periods=20),
  595:                 ["4D", "8D", "12D"],
  596:                 [pd.Timedelta("4 day"), pd.Timedelta("8 day"), pd.Timedelta("12 day")],
  597:             ),
  598:         ],
  599:     )
  600:     def test_loc_with_list_of_strings_representing_datetimes(
  601:         self, idx, labels, expected_idx, frame_or_series
  602:     ):
  603:         # GH 11278
  604:         obj = frame_or_series(range(20), index=idx)
  605: 
  606:         expected_value = [3, 7, 11]
  607:         expected = frame_or_series(expected_value, expected_idx)
  608: 
  609:         tm.assert_equal(expected, obj.loc[labels])
  610:         if frame_or_series is Series:
  611:             tm.assert_series_equal(expected, obj[labels])
  612: 
  613:     @pytest.mark.parametrize(
  614:         "idx,labels",
  615:         [
  616:             (
  617:                 period_range(start="2000", periods=20, freq="D"),
  618:                 ["2000-01-04", "2000-01-30"],
  619:             ),
  620:             (
  621:                 date_range(start="2000", periods=20, freq="D"),
  622:                 ["2000-01-04", "2000-01-30"],
  623:             ),
  624:             (pd.timedelta_range(start="1 day", periods=20), ["3 day", "30 day"]),
  625:         ],
  626:     )
  627:     def test_loc_with_list_of_strings_representing_datetimes_missing_value(
  628:         self, idx, labels
  629:     ):
  630:         # GH 11278
  631:         ser = Series(range(20), index=idx)
  632:         df = DataFrame(range(20), index=idx)
  633:         msg = r"not in index"
  634: 
  635:         with pytest.raises(KeyError, match=msg):
  636:             ser.loc[labels]
  637:         with pytest.raises(KeyError, match=msg):
  638:             ser[labels]
  639:         with pytest.raises(KeyError, match=msg):
  640:             df.loc[labels]
  641: 
  642:     @pytest.mark.parametrize(
  643:         "idx,labels,msg",
  644:         [
  645:             (
  646:                 period_range(start="2000", periods=20, freq="D"),
  647:                 Index(["4D", "8D"], dtype=object),
  648:                 (
  649:                     r"None of \[Index\(\['4D', '8D'\], dtype='object'\)\] "
  650:                     r"are in the \[index\]"
  651:                 ),
  652:             ),
  653:             (
  654:                 date_range(start="2000", periods=20, freq="D"),
  655:                 Index(["4D", "8D"], dtype=object),
  656:                 (
  657:                     r"None of \[Index\(\['4D', '8D'\], dtype='object'\)\] "
  658:                     r"are in the \[index\]"
  659:                 ),
  660:             ),
  661:             (
  662:                 pd.timedelta_range(start="1 day", periods=20),
  663:                 Index(["2000-01-04", "2000-01-08"], dtype=object),
  664:                 (
  665:                     r"None of \[Index\(\['2000-01-04', '2000-01-08'\], "
  666:                     r"dtype='object'\)\] are in the \[index\]"
  667:                 ),
  668:             ),
  669:         ],
  670:     )
  671:     def test_loc_with_list_of_strings_representing_datetimes_not_matched_type(
  672:         self, idx, labels, msg
  673:     ):
  674:         # GH 11278
  675:         ser = Series(range(20), index=idx)
  676:         df = DataFrame(range(20), index=idx)
  677: 
  678:         with pytest.raises(KeyError, match=msg):
  679:             ser.loc[labels]
  680:         with pytest.raises(KeyError, match=msg):
  681:             ser[labels]
  682:         with pytest.raises(KeyError, match=msg):
  683:             df.loc[labels]
  684: 
  685: 
  686: class TestStringSlicing:
  687:     def test_slice_irregular_datetime_index_with_nan(self):
  688:         # GH36953
  689:         index = pd.to_datetime(["2012-01-01", "2012-01-02", "2012-01-03", None])
  690:         df = DataFrame(range(len(index)), index=index)
  691:         expected = DataFrame(range(len(index[:3])), index=index[:3])
  692:         with pytest.raises(KeyError, match="non-existing keys is not allowed"):
  693:             # Upper bound is not in index (which is unordered)
  694:             # GH53983
  695:             # GH37819
  696:             df["2012-01-01":"2012-01-04"]
  697:         # Need this precision for right bound since the right slice
  698:         # bound is "rounded" up to the largest timepoint smaller than
  699:         # the next "resolution"-step of the provided point.
  700:         # e.g. 2012-01-03 is rounded up to 2012-01-04 - 1ns
  701:         result = df["2012-01-01":"2012-01-03 00:00:00.000000000"]
  702:         tm.assert_frame_equal(result, expected)
