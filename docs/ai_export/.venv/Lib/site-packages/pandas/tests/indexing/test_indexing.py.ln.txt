    1: """ test fancy indexing & misc """
    2: 
    3: import array
    4: from datetime import datetime
    5: import re
    6: import weakref
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas._config import using_pyarrow_string_dtype
   12: 
   13: from pandas.errors import IndexingError
   14: 
   15: from pandas.core.dtypes.common import (
   16:     is_float_dtype,
   17:     is_integer_dtype,
   18:     is_object_dtype,
   19: )
   20: 
   21: import pandas as pd
   22: from pandas import (
   23:     DataFrame,
   24:     Index,
   25:     NaT,
   26:     Series,
   27:     date_range,
   28:     offsets,
   29:     timedelta_range,
   30: )
   31: import pandas._testing as tm
   32: from pandas.tests.indexing.common import _mklbl
   33: from pandas.tests.indexing.test_floats import gen_obj
   34: 
   35: # ------------------------------------------------------------------------
   36: # Indexing test cases
   37: 
   38: 
   39: class TestFancy:
   40:     """pure get/set item & fancy indexing"""
   41: 
   42:     def test_setitem_ndarray_1d(self):
   43:         # GH5508
   44: 
   45:         # len of indexer vs length of the 1d ndarray
   46:         df = DataFrame(index=Index(np.arange(1, 11), dtype=np.int64))
   47:         df["foo"] = np.zeros(10, dtype=np.float64)
   48:         df["bar"] = np.zeros(10, dtype=complex)
   49: 
   50:         # invalid
   51:         msg = "Must have equal len keys and value when setting with an iterable"
   52:         with pytest.raises(ValueError, match=msg):
   53:             df.loc[df.index[2:5], "bar"] = np.array([2.33j, 1.23 + 0.1j, 2.2, 1.0])
   54: 
   55:         # valid
   56:         df.loc[df.index[2:6], "bar"] = np.array([2.33j, 1.23 + 0.1j, 2.2, 1.0])
   57: 
   58:         result = df.loc[df.index[2:6], "bar"]
   59:         expected = Series(
   60:             [2.33j, 1.23 + 0.1j, 2.2, 1.0], index=[3, 4, 5, 6], name="bar"
   61:         )
   62:         tm.assert_series_equal(result, expected)
   63: 
   64:     def test_setitem_ndarray_1d_2(self):
   65:         # GH5508
   66: 
   67:         # dtype getting changed?
   68:         df = DataFrame(index=Index(np.arange(1, 11)))
   69:         df["foo"] = np.zeros(10, dtype=np.float64)
   70:         df["bar"] = np.zeros(10, dtype=complex)
   71: 
   72:         msg = "Must have equal len keys and value when setting with an iterable"
   73:         with pytest.raises(ValueError, match=msg):
   74:             df[2:5] = np.arange(1, 4) * 1j
   75: 
   76:     @pytest.mark.filterwarnings(
   77:         "ignore:Series.__getitem__ treating keys as positions is deprecated:"
   78:         "FutureWarning"
   79:     )
   80:     def test_getitem_ndarray_3d(
   81:         self, index, frame_or_series, indexer_sli, using_array_manager
   82:     ):
   83:         # GH 25567
   84:         obj = gen_obj(frame_or_series, index)
   85:         idxr = indexer_sli(obj)
   86:         nd3 = np.random.default_rng(2).integers(5, size=(2, 2, 2))
   87: 
   88:         msgs = []
   89:         if frame_or_series is Series and indexer_sli in [tm.setitem, tm.iloc]:
   90:             msgs.append(r"Wrong number of dimensions. values.ndim > ndim \[3 > 1\]")
   91:             if using_array_manager:
   92:                 msgs.append("Passed array should be 1-dimensional")
   93:         if frame_or_series is Series or indexer_sli is tm.iloc:
   94:             msgs.append(r"Buffer has wrong number of dimensions \(expected 1, got 3\)")
   95:             if using_array_manager:
   96:                 msgs.append("indexer should be 1-dimensional")
   97:         if indexer_sli is tm.loc or (
   98:             frame_or_series is Series and indexer_sli is tm.setitem
   99:         ):
  100:             msgs.append("Cannot index with multidimensional key")
  101:         if frame_or_series is DataFrame and indexer_sli is tm.setitem:
  102:             msgs.append("Index data must be 1-dimensional")
  103:         if isinstance(index, pd.IntervalIndex) and indexer_sli is tm.iloc:
  104:             msgs.append("Index data must be 1-dimensional")
  105:         if isinstance(index, (pd.TimedeltaIndex, pd.DatetimeIndex, pd.PeriodIndex)):
  106:             msgs.append("Data must be 1-dimensional")
  107:         if len(index) == 0 or isinstance(index, pd.MultiIndex):
  108:             msgs.append("positional indexers are out-of-bounds")
  109:         if type(index) is Index and not isinstance(index._values, np.ndarray):
  110:             # e.g. Int64
  111:             msgs.append("values must be a 1D array")
  112: 
  113:             # string[pyarrow]
  114:             msgs.append("only handle 1-dimensional arrays")
  115: 
  116:         msg = "|".join(msgs)
  117: 
  118:         potential_errors = (IndexError, ValueError, NotImplementedError)
  119:         with pytest.raises(potential_errors, match=msg):
  120:             idxr[nd3]
  121: 
  122:     @pytest.mark.filterwarnings(
  123:         "ignore:Series.__setitem__ treating keys as positions is deprecated:"
  124:         "FutureWarning"
  125:     )
  126:     def test_setitem_ndarray_3d(self, index, frame_or_series, indexer_sli):
  127:         # GH 25567
  128:         obj = gen_obj(frame_or_series, index)
  129:         idxr = indexer_sli(obj)
  130:         nd3 = np.random.default_rng(2).integers(5, size=(2, 2, 2))
  131: 
  132:         if indexer_sli is tm.iloc:
  133:             err = ValueError
  134:             msg = f"Cannot set values with ndim > {obj.ndim}"
  135:         else:
  136:             err = ValueError
  137:             msg = "|".join(
  138:                 [
  139:                     r"Buffer has wrong number of dimensions \(expected 1, got 3\)",
  140:                     "Cannot set values with ndim > 1",
  141:                     "Index data must be 1-dimensional",
  142:                     "Data must be 1-dimensional",
  143:                     "Array conditional must be same shape as self",
  144:                 ]
  145:             )
  146: 
  147:         with pytest.raises(err, match=msg):
  148:             idxr[nd3] = 0
  149: 
  150:     def test_getitem_ndarray_0d(self):
  151:         # GH#24924
  152:         key = np.array(0)
  153: 
  154:         # dataframe __getitem__
  155:         df = DataFrame([[1, 2], [3, 4]])
  156:         result = df[key]
  157:         expected = Series([1, 3], name=0)
  158:         tm.assert_series_equal(result, expected)
  159: 
  160:         # series __getitem__
  161:         ser = Series([1, 2])
  162:         result = ser[key]
  163:         assert result == 1
  164: 
  165:     def test_inf_upcast(self):
  166:         # GH 16957
  167:         # We should be able to use np.inf as a key
  168:         # np.inf should cause an index to convert to float
  169: 
  170:         # Test with np.inf in rows
  171:         df = DataFrame(columns=[0])
  172:         df.loc[1] = 1
  173:         df.loc[2] = 2
  174:         df.loc[np.inf] = 3
  175: 
  176:         # make sure we can look up the value
  177:         assert df.loc[np.inf, 0] == 3
  178: 
  179:         result = df.index
  180:         expected = Index([1, 2, np.inf], dtype=np.float64)
  181:         tm.assert_index_equal(result, expected)
  182: 
  183:     def test_setitem_dtype_upcast(self):
  184:         # GH3216
  185:         df = DataFrame([{"a": 1}, {"a": 3, "b": 2}])
  186:         df["c"] = np.nan
  187:         assert df["c"].dtype == np.float64
  188: 
  189:         with tm.assert_produces_warning(
  190:             FutureWarning, match="item of incompatible dtype"
  191:         ):
  192:             df.loc[0, "c"] = "foo"
  193:         expected = DataFrame(
  194:             {"a": [1, 3], "b": [np.nan, 2], "c": Series(["foo", np.nan], dtype=object)}
  195:         )
  196:         tm.assert_frame_equal(df, expected)
  197: 
  198:     @pytest.mark.parametrize("val", [3.14, "wxyz"])
  199:     def test_setitem_dtype_upcast2(self, val):
  200:         # GH10280
  201:         df = DataFrame(
  202:             np.arange(6, dtype="int64").reshape(2, 3),
  203:             index=list("ab"),
  204:             columns=["foo", "bar", "baz"],
  205:         )
  206: 
  207:         left = df.copy()
  208:         with tm.assert_produces_warning(
  209:             FutureWarning, match="item of incompatible dtype"
  210:         ):
  211:             left.loc["a", "bar"] = val
  212:         right = DataFrame(
  213:             [[0, val, 2], [3, 4, 5]],
  214:             index=list("ab"),
  215:             columns=["foo", "bar", "baz"],
  216:         )
  217: 
  218:         tm.assert_frame_equal(left, right)
  219:         assert is_integer_dtype(left["foo"])
  220:         assert is_integer_dtype(left["baz"])
  221: 
  222:     def test_setitem_dtype_upcast3(self):
  223:         left = DataFrame(
  224:             np.arange(6, dtype="int64").reshape(2, 3) / 10.0,
  225:             index=list("ab"),
  226:             columns=["foo", "bar", "baz"],
  227:         )
  228:         with tm.assert_produces_warning(
  229:             FutureWarning, match="item of incompatible dtype"
  230:         ):
  231:             left.loc["a", "bar"] = "wxyz"
  232: 
  233:         right = DataFrame(
  234:             [[0, "wxyz", 0.2], [0.3, 0.4, 0.5]],
  235:             index=list("ab"),
  236:             columns=["foo", "bar", "baz"],
  237:         )
  238: 
  239:         tm.assert_frame_equal(left, right)
  240:         assert is_float_dtype(left["foo"])
  241:         assert is_float_dtype(left["baz"])
  242: 
  243:     def test_dups_fancy_indexing(self):
  244:         # GH 3455
  245: 
  246:         df = DataFrame(np.eye(3), columns=["a", "a", "b"])
  247:         result = df[["b", "a"]].columns
  248:         expected = Index(["b", "a", "a"])
  249:         tm.assert_index_equal(result, expected)
  250: 
  251:     def test_dups_fancy_indexing_across_dtypes(self):
  252:         # across dtypes
  253:         df = DataFrame([[1, 2, 1.0, 2.0, 3.0, "foo", "bar"]], columns=list("aaaaaaa"))
  254:         result = DataFrame([[1, 2, 1.0, 2.0, 3.0, "foo", "bar"]])
  255:         result.columns = list("aaaaaaa")  # GH#3468
  256: 
  257:         # GH#3509 smoke tests for indexing with duplicate columns
  258:         df.iloc[:, 4]
  259:         result.iloc[:, 4]
  260: 
  261:         tm.assert_frame_equal(df, result)
  262: 
  263:     def test_dups_fancy_indexing_not_in_order(self):
  264:         # GH 3561, dups not in selected order
  265:         df = DataFrame(
  266:             {"test": [5, 7, 9, 11], "test1": [4.0, 5, 6, 7], "other": list("abcd")},
  267:             index=["A", "A", "B", "C"],
  268:         )
  269:         rows = ["C", "B"]
  270:         expected = DataFrame(
  271:             {"test": [11, 9], "test1": [7.0, 6], "other": ["d", "c"]}, index=rows
  272:         )
  273:         result = df.loc[rows]
  274:         tm.assert_frame_equal(result, expected)
  275: 
  276:         result = df.loc[Index(rows)]
  277:         tm.assert_frame_equal(result, expected)
  278: 
  279:         rows = ["C", "B", "E"]
  280:         with pytest.raises(KeyError, match="not in index"):
  281:             df.loc[rows]
  282: 
  283:         # see GH5553, make sure we use the right indexer
  284:         rows = ["F", "G", "H", "C", "B", "E"]
  285:         with pytest.raises(KeyError, match="not in index"):
  286:             df.loc[rows]
  287: 
  288:     def test_dups_fancy_indexing_only_missing_label(self, using_infer_string):
  289:         # List containing only missing label
  290:         dfnu = DataFrame(
  291:             np.random.default_rng(2).standard_normal((5, 3)), index=list("AABCD")
  292:         )
  293:         if using_infer_string:
  294:             with pytest.raises(
  295:                 KeyError,
  296:                 match=re.escape(
  297:                     "\"None of [Index(['E'], dtype='string')] are in the [index]\""
  298:                 ),
  299:             ):
  300:                 dfnu.loc[["E"]]
  301:         else:
  302:             with pytest.raises(
  303:                 KeyError,
  304:                 match=re.escape(
  305:                     "\"None of [Index(['E'], dtype='object')] are in the [index]\""
  306:                 ),
  307:             ):
  308:                 dfnu.loc[["E"]]
  309: 
  310:     @pytest.mark.parametrize("vals", [[0, 1, 2], list("abc")])
  311:     def test_dups_fancy_indexing_missing_label(self, vals):
  312:         # GH 4619; duplicate indexer with missing label
  313:         df = DataFrame({"A": vals})
  314:         with pytest.raises(KeyError, match="not in index"):
  315:             df.loc[[0, 8, 0]]
  316: 
  317:     def test_dups_fancy_indexing_non_unique(self):
  318:         # non unique with non unique selector
  319:         df = DataFrame({"test": [5, 7, 9, 11]}, index=["A", "A", "B", "C"])
  320:         with pytest.raises(KeyError, match="not in index"):
  321:             df.loc[["A", "A", "E"]]
  322: 
  323:     def test_dups_fancy_indexing2(self):
  324:         # GH 5835
  325:         # dups on index and missing values
  326:         df = DataFrame(
  327:             np.random.default_rng(2).standard_normal((5, 5)),
  328:             columns=["A", "B", "B", "B", "A"],
  329:         )
  330: 
  331:         with pytest.raises(KeyError, match="not in index"):
  332:             df.loc[:, ["A", "B", "C"]]
  333: 
  334:     def test_dups_fancy_indexing3(self):
  335:         # GH 6504, multi-axis indexing
  336:         df = DataFrame(
  337:             np.random.default_rng(2).standard_normal((9, 2)),
  338:             index=[1, 1, 1, 2, 2, 2, 3, 3, 3],
  339:             columns=["a", "b"],
  340:         )
  341: 
  342:         expected = df.iloc[0:6]
  343:         result = df.loc[[1, 2]]
  344:         tm.assert_frame_equal(result, expected)
  345: 
  346:         expected = df
  347:         result = df.loc[:, ["a", "b"]]
  348:         tm.assert_frame_equal(result, expected)
  349: 
  350:         expected = df.iloc[0:6, :]
  351:         result = df.loc[[1, 2], ["a", "b"]]
  352:         tm.assert_frame_equal(result, expected)
  353: 
  354:     def test_duplicate_int_indexing(self, indexer_sl):
  355:         # GH 17347
  356:         ser = Series(range(3), index=[1, 1, 3])
  357:         expected = Series(range(2), index=[1, 1])
  358:         result = indexer_sl(ser)[[1]]
  359:         tm.assert_series_equal(result, expected)
  360: 
  361:     def test_indexing_mixed_frame_bug(self):
  362:         # GH3492
  363:         df = DataFrame(
  364:             {"a": {1: "aaa", 2: "bbb", 3: "ccc"}, "b": {1: 111, 2: 222, 3: 333}}
  365:         )
  366: 
  367:         # this works, new column is created correctly
  368:         df["test"] = df["a"].apply(lambda x: "_" if x == "aaa" else x)
  369: 
  370:         # this does not work, ie column test is not changed
  371:         idx = df["test"] == "_"
  372:         temp = df.loc[idx, "a"].apply(lambda x: "-----" if x == "aaa" else x)
  373:         df.loc[idx, "test"] = temp
  374:         assert df.iloc[0, 2] == "-----"
  375: 
  376:     def test_multitype_list_index_access(self):
  377:         # GH 10610
  378:         df = DataFrame(
  379:             np.random.default_rng(2).random((10, 5)), columns=["a"] + [20, 21, 22, 23]
  380:         )
  381: 
  382:         with pytest.raises(KeyError, match=re.escape("'[26, -8] not in index'")):
  383:             df[[22, 26, -8]]
  384:         assert df[21].shape[0] == df.shape[0]
  385: 
  386:     def test_set_index_nan(self):
  387:         # GH 3586
  388:         df = DataFrame(
  389:             {
  390:                 "PRuid": {
  391:                     17: "nonQC",
  392:                     18: "nonQC",
  393:                     19: "nonQC",
  394:                     20: "10",
  395:                     21: "11",
  396:                     22: "12",
  397:                     23: "13",
  398:                     24: "24",
  399:                     25: "35",
  400:                     26: "46",
  401:                     27: "47",
  402:                     28: "48",
  403:                     29: "59",
  404:                     30: "10",
  405:                 },
  406:                 "QC": {
  407:                     17: 0.0,
  408:                     18: 0.0,
  409:                     19: 0.0,
  410:                     20: np.nan,
  411:                     21: np.nan,
  412:                     22: np.nan,
  413:                     23: np.nan,
  414:                     24: 1.0,
  415:                     25: np.nan,
  416:                     26: np.nan,
  417:                     27: np.nan,
  418:                     28: np.nan,
  419:                     29: np.nan,
  420:                     30: np.nan,
  421:                 },
  422:                 "data": {
  423:                     17: 7.9544899999999998,
  424:                     18: 8.0142609999999994,
  425:                     19: 7.8591520000000008,
  426:                     20: 0.86140349999999999,
  427:                     21: 0.87853110000000001,
  428:                     22: 0.8427041999999999,
  429:                     23: 0.78587700000000005,
  430:                     24: 0.73062459999999996,
  431:                     25: 0.81668560000000001,
  432:                     26: 0.81927080000000008,
  433:                     27: 0.80705009999999999,
  434:                     28: 0.81440240000000008,
  435:                     29: 0.80140849999999997,
  436:                     30: 0.81307740000000006,
  437:                 },
  438:                 "year": {
  439:                     17: 2006,
  440:                     18: 2007,
  441:                     19: 2008,
  442:                     20: 1985,
  443:                     21: 1985,
  444:                     22: 1985,
  445:                     23: 1985,
  446:                     24: 1985,
  447:                     25: 1985,
  448:                     26: 1985,
  449:                     27: 1985,
  450:                     28: 1985,
  451:                     29: 1985,
  452:                     30: 1986,
  453:                 },
  454:             }
  455:         ).reset_index()
  456: 
  457:         result = (
  458:             df.set_index(["year", "PRuid", "QC"])
  459:             .reset_index()
  460:             .reindex(columns=df.columns)
  461:         )
  462:         tm.assert_frame_equal(result, df)
  463: 
  464:     @pytest.mark.xfail(
  465:         using_pyarrow_string_dtype(), reason="can't multiply arrow strings"
  466:     )
  467:     def test_multi_assign(self):
  468:         # GH 3626, an assignment of a sub-df to a df
  469:         # set float64 to avoid upcast when setting nan
  470:         df = DataFrame(
  471:             {
  472:                 "FC": ["a", "b", "a", "b", "a", "b"],
  473:                 "PF": [0, 0, 0, 0, 1, 1],
  474:                 "col1": list(range(6)),
  475:                 "col2": list(range(6, 12)),
  476:             }
  477:         ).astype({"col2": "float64"})
  478:         df.iloc[1, 0] = np.nan
  479:         df2 = df.copy()
  480: 
  481:         mask = ~df2.FC.isna()
  482:         cols = ["col1", "col2"]
  483: 
  484:         dft = df2 * 2
  485:         dft.iloc[3, 3] = np.nan
  486: 
  487:         expected = DataFrame(
  488:             {
  489:                 "FC": ["a", np.nan, "a", "b", "a", "b"],
  490:                 "PF": [0, 0, 0, 0, 1, 1],
  491:                 "col1": Series([0, 1, 4, 6, 8, 10]),
  492:                 "col2": [12, 7, 16, np.nan, 20, 22],
  493:             }
  494:         )
  495: 
  496:         # frame on rhs
  497:         df2.loc[mask, cols] = dft.loc[mask, cols]
  498:         tm.assert_frame_equal(df2, expected)
  499: 
  500:         # with an ndarray on rhs
  501:         # coerces to float64 because values has float64 dtype
  502:         # GH 14001
  503:         expected = DataFrame(
  504:             {
  505:                 "FC": ["a", np.nan, "a", "b", "a", "b"],
  506:                 "PF": [0, 0, 0, 0, 1, 1],
  507:                 "col1": [0, 1, 4, 6, 8, 10],
  508:                 "col2": [12, 7, 16, np.nan, 20, 22],
  509:             }
  510:         )
  511:         df2 = df.copy()
  512:         df2.loc[mask, cols] = dft.loc[mask, cols].values
  513:         tm.assert_frame_equal(df2, expected)
  514: 
  515:     def test_multi_assign_broadcasting_rhs(self):
  516:         # broadcasting on the rhs is required
  517:         df = DataFrame(
  518:             {
  519:                 "A": [1, 2, 0, 0, 0],
  520:                 "B": [0, 0, 0, 10, 11],
  521:                 "C": [0, 0, 0, 10, 11],
  522:                 "D": [3, 4, 5, 6, 7],
  523:             }
  524:         )
  525: 
  526:         expected = df.copy()
  527:         mask = expected["A"] == 0
  528:         for col in ["A", "B"]:
  529:             expected.loc[mask, col] = df["D"]
  530: 
  531:         df.loc[df["A"] == 0, ["A", "B"]] = df["D"].copy()
  532:         tm.assert_frame_equal(df, expected)
  533: 
  534:     def test_setitem_list(self):
  535:         # GH 6043
  536:         # iloc with a list
  537:         df = DataFrame(index=[0, 1], columns=[0])
  538:         df.iloc[1, 0] = [1, 2, 3]
  539:         df.iloc[1, 0] = [1, 2]
  540: 
  541:         result = DataFrame(index=[0, 1], columns=[0])
  542:         result.iloc[1, 0] = [1, 2]
  543: 
  544:         tm.assert_frame_equal(result, df)
  545: 
  546:     def test_string_slice(self):
  547:         # GH 14424
  548:         # string indexing against datetimelike with object
  549:         # dtype should properly raises KeyError
  550:         df = DataFrame([1], Index([pd.Timestamp("2011-01-01")], dtype=object))
  551:         assert df.index._is_all_dates
  552:         with pytest.raises(KeyError, match="'2011'"):
  553:             df["2011"]
  554: 
  555:         with pytest.raises(KeyError, match="'2011'"):
  556:             df.loc["2011", 0]
  557: 
  558:     def test_string_slice_empty(self):
  559:         # GH 14424
  560: 
  561:         df = DataFrame()
  562:         assert not df.index._is_all_dates
  563:         with pytest.raises(KeyError, match="'2011'"):
  564:             df["2011"]
  565: 
  566:         with pytest.raises(KeyError, match="^0$"):
  567:             df.loc["2011", 0]
  568: 
  569:     def test_astype_assignment(self, using_infer_string):
  570:         # GH4312 (iloc)
  571:         df_orig = DataFrame(
  572:             [["1", "2", "3", ".4", 5, 6.0, "foo"]], columns=list("ABCDEFG")
  573:         )
  574: 
  575:         df = df_orig.copy()
  576: 
  577:         # with the enforcement of GH#45333 in 2.0, this setting is attempted inplace,
  578:         #  so object dtype is retained
  579:         df.iloc[:, 0:2] = df.iloc[:, 0:2].astype(np.int64)
  580:         expected = DataFrame(
  581:             [[1, 2, "3", ".4", 5, 6.0, "foo"]], columns=list("ABCDEFG")
  582:         )
  583:         if not using_infer_string:
  584:             expected["A"] = expected["A"].astype(object)
  585:             expected["B"] = expected["B"].astype(object)
  586:         tm.assert_frame_equal(df, expected)
  587: 
  588:         # GH5702 (loc)
  589:         df = df_orig.copy()
  590:         df.loc[:, "A"] = df.loc[:, "A"].astype(np.int64)
  591:         expected = DataFrame(
  592:             [[1, "2", "3", ".4", 5, 6.0, "foo"]], columns=list("ABCDEFG")
  593:         )
  594:         if not using_infer_string:
  595:             expected["A"] = expected["A"].astype(object)
  596:         tm.assert_frame_equal(df, expected)
  597: 
  598:         df = df_orig.copy()
  599:         df.loc[:, ["B", "C"]] = df.loc[:, ["B", "C"]].astype(np.int64)
  600:         expected = DataFrame(
  601:             [["1", 2, 3, ".4", 5, 6.0, "foo"]], columns=list("ABCDEFG")
  602:         )
  603:         if not using_infer_string:
  604:             expected["B"] = expected["B"].astype(object)
  605:             expected["C"] = expected["C"].astype(object)
  606:         tm.assert_frame_equal(df, expected)
  607: 
  608:     def test_astype_assignment_full_replacements(self):
  609:         # full replacements / no nans
  610:         df = DataFrame({"A": [1.0, 2.0, 3.0, 4.0]})
  611: 
  612:         # With the enforcement of GH#45333 in 2.0, this assignment occurs inplace,
  613:         #  so float64 is retained
  614:         df.iloc[:, 0] = df["A"].astype(np.int64)
  615:         expected = DataFrame({"A": [1.0, 2.0, 3.0, 4.0]})
  616:         tm.assert_frame_equal(df, expected)
  617: 
  618:         df = DataFrame({"A": [1.0, 2.0, 3.0, 4.0]})
  619:         df.loc[:, "A"] = df["A"].astype(np.int64)
  620:         tm.assert_frame_equal(df, expected)
  621: 
  622:     @pytest.mark.parametrize("indexer", [tm.getitem, tm.loc])
  623:     def test_index_type_coercion(self, indexer):
  624:         # GH 11836
  625:         # if we have an index type and set it with something that looks
  626:         # to numpy like the same, but is actually, not
  627:         # (e.g. setting with a float or string '0')
  628:         # then we need to coerce to object
  629: 
  630:         # integer indexes
  631:         for s in [Series(range(5)), Series(range(5), index=range(1, 6))]:
  632:             assert is_integer_dtype(s.index)
  633: 
  634:             s2 = s.copy()
  635:             indexer(s2)[0.1] = 0
  636:             assert is_float_dtype(s2.index)
  637:             assert indexer(s2)[0.1] == 0
  638: 
  639:             s2 = s.copy()
  640:             indexer(s2)[0.0] = 0
  641:             exp = s.index
  642:             if 0 not in s:
  643:                 exp = Index(s.index.tolist() + [0])
  644:             tm.assert_index_equal(s2.index, exp)
  645: 
  646:             s2 = s.copy()
  647:             indexer(s2)["0"] = 0
  648:             assert is_object_dtype(s2.index)
  649: 
  650:         for s in [Series(range(5), index=np.arange(5.0))]:
  651:             assert is_float_dtype(s.index)
  652: 
  653:             s2 = s.copy()
  654:             indexer(s2)[0.1] = 0
  655:             assert is_float_dtype(s2.index)
  656:             assert indexer(s2)[0.1] == 0
  657: 
  658:             s2 = s.copy()
  659:             indexer(s2)[0.0] = 0
  660:             tm.assert_index_equal(s2.index, s.index)
  661: 
  662:             s2 = s.copy()
  663:             indexer(s2)["0"] = 0
  664:             assert is_object_dtype(s2.index)
  665: 
  666: 
  667: class TestMisc:
  668:     def test_float_index_to_mixed(self):
  669:         df = DataFrame(
  670:             {
  671:                 0.0: np.random.default_rng(2).random(10),
  672:                 1.0: np.random.default_rng(2).random(10),
  673:             }
  674:         )
  675:         df["a"] = 10
  676: 
  677:         expected = DataFrame({0.0: df[0.0], 1.0: df[1.0], "a": [10] * 10})
  678:         tm.assert_frame_equal(expected, df)
  679: 
  680:     def test_float_index_non_scalar_assignment(self):
  681:         df = DataFrame({"a": [1, 2, 3], "b": [3, 4, 5]}, index=[1.0, 2.0, 3.0])
  682:         df.loc[df.index[:2]] = 1
  683:         expected = DataFrame({"a": [1, 1, 3], "b": [1, 1, 5]}, index=df.index)
  684:         tm.assert_frame_equal(expected, df)
  685: 
  686:     def test_loc_setitem_fullindex_views(self):
  687:         df = DataFrame({"a": [1, 2, 3], "b": [3, 4, 5]}, index=[1.0, 2.0, 3.0])
  688:         df2 = df.copy()
  689:         df.loc[df.index] = df.loc[df.index]
  690:         tm.assert_frame_equal(df, df2)
  691: 
  692:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="can't set int into string")
  693:     def test_rhs_alignment(self):
  694:         # GH8258, tests that both rows & columns are aligned to what is
  695:         # assigned to. covers both uniform data-type & multi-type cases
  696:         def run_tests(df, rhs, right_loc, right_iloc):
  697:             # label, index, slice
  698:             lbl_one, idx_one, slice_one = list("bcd"), [1, 2, 3], slice(1, 4)
  699:             lbl_two, idx_two, slice_two = ["joe", "jolie"], [1, 2], slice(1, 3)
  700: 
  701:             left = df.copy()
  702:             left.loc[lbl_one, lbl_two] = rhs
  703:             tm.assert_frame_equal(left, right_loc)
  704: 
  705:             left = df.copy()
  706:             left.iloc[idx_one, idx_two] = rhs
  707:             tm.assert_frame_equal(left, right_iloc)
  708: 
  709:             left = df.copy()
  710:             left.iloc[slice_one, slice_two] = rhs
  711:             tm.assert_frame_equal(left, right_iloc)
  712: 
  713:         xs = np.arange(20).reshape(5, 4)
  714:         cols = ["jim", "joe", "jolie", "joline"]
  715:         df = DataFrame(xs, columns=cols, index=list("abcde"), dtype="int64")
  716: 
  717:         # right hand side; permute the indices and multiplpy by -2
  718:         rhs = -2 * df.iloc[3:0:-1, 2:0:-1]
  719: 
  720:         # expected `right` result; just multiply by -2
  721:         right_iloc = df.copy()
  722:         right_iloc["joe"] = [1, 14, 10, 6, 17]
  723:         right_iloc["jolie"] = [2, 13, 9, 5, 18]
  724:         right_iloc.iloc[1:4, 1:3] *= -2
  725:         right_loc = df.copy()
  726:         right_loc.iloc[1:4, 1:3] *= -2
  727: 
  728:         # run tests with uniform dtypes
  729:         run_tests(df, rhs, right_loc, right_iloc)
  730: 
  731:         # make frames multi-type & re-run tests
  732:         for frame in [df, rhs, right_loc, right_iloc]:
  733:             frame["joe"] = frame["joe"].astype("float64")
  734:             frame["jolie"] = frame["jolie"].map(lambda x: f"@{x}")
  735:         right_iloc["joe"] = [1.0, "@-28", "@-20", "@-12", 17.0]
  736:         right_iloc["jolie"] = ["@2", -26.0, -18.0, -10.0, "@18"]
  737:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  738:             run_tests(df, rhs, right_loc, right_iloc)
  739: 
  740:     @pytest.mark.parametrize(
  741:         "idx", [_mklbl("A", 20), np.arange(20) + 100, np.linspace(100, 150, 20)]
  742:     )
  743:     def test_str_label_slicing_with_negative_step(self, idx):
  744:         SLC = pd.IndexSlice
  745: 
  746:         idx = Index(idx)
  747:         ser = Series(np.arange(20), index=idx)
  748:         tm.assert_indexing_slices_equivalent(ser, SLC[idx[9] :: -1], SLC[9::-1])
  749:         tm.assert_indexing_slices_equivalent(ser, SLC[: idx[9] : -1], SLC[:8:-1])
  750:         tm.assert_indexing_slices_equivalent(
  751:             ser, SLC[idx[13] : idx[9] : -1], SLC[13:8:-1]
  752:         )
  753:         tm.assert_indexing_slices_equivalent(ser, SLC[idx[9] : idx[13] : -1], SLC[:0])
  754: 
  755:     def test_slice_with_zero_step_raises(self, index, indexer_sl, frame_or_series):
  756:         obj = frame_or_series(np.arange(len(index)), index=index)
  757:         with pytest.raises(ValueError, match="slice step cannot be zero"):
  758:             indexer_sl(obj)[::0]
  759: 
  760:     def test_loc_setitem_indexing_assignment_dict_already_exists(self):
  761:         index = Index([-5, 0, 5], name="z")
  762:         df = DataFrame({"x": [1, 2, 6], "y": [2, 2, 8]}, index=index)
  763:         expected = df.copy()
  764:         rhs = {"x": 9, "y": 99}
  765:         df.loc[5] = rhs
  766:         expected.loc[5] = [9, 99]
  767:         tm.assert_frame_equal(df, expected)
  768: 
  769:         # GH#38335 same thing, mixed dtypes
  770:         df = DataFrame({"x": [1, 2, 6], "y": [2.0, 2.0, 8.0]}, index=index)
  771:         df.loc[5] = rhs
  772:         expected = DataFrame({"x": [1, 2, 9], "y": [2.0, 2.0, 99.0]}, index=index)
  773:         tm.assert_frame_equal(df, expected)
  774: 
  775:     def test_iloc_getitem_indexing_dtypes_on_empty(self):
  776:         # Check that .iloc returns correct dtypes GH9983
  777:         df = DataFrame({"a": [1, 2, 3], "b": ["b", "b2", "b3"]})
  778:         df2 = df.iloc[[], :]
  779: 
  780:         assert df2.loc[:, "a"].dtype == np.int64
  781:         tm.assert_series_equal(df2.loc[:, "a"], df2.iloc[:, 0])
  782: 
  783:     @pytest.mark.parametrize("size", [5, 999999, 1000000])
  784:     def test_loc_range_in_series_indexing(self, size):
  785:         # range can cause an indexing error
  786:         # GH 11652
  787:         s = Series(index=range(size), dtype=np.float64)
  788:         s.loc[range(1)] = 42
  789:         tm.assert_series_equal(s.loc[range(1)], Series(42.0, index=[0]))
  790: 
  791:         s.loc[range(2)] = 43
  792:         tm.assert_series_equal(s.loc[range(2)], Series(43.0, index=[0, 1]))
  793: 
  794:     def test_partial_boolean_frame_indexing(self):
  795:         # GH 17170
  796:         df = DataFrame(
  797:             np.arange(9.0).reshape(3, 3), index=list("abc"), columns=list("ABC")
  798:         )
  799:         index_df = DataFrame(1, index=list("ab"), columns=list("AB"))
  800:         result = df[index_df.notnull()]
  801:         expected = DataFrame(
  802:             np.array([[0.0, 1.0, np.nan], [3.0, 4.0, np.nan], [np.nan] * 3]),
  803:             index=list("abc"),
  804:             columns=list("ABC"),
  805:         )
  806:         tm.assert_frame_equal(result, expected)
  807: 
  808:     def test_no_reference_cycle(self):
  809:         df = DataFrame({"a": [0, 1], "b": [2, 3]})
  810:         for name in ("loc", "iloc", "at", "iat"):
  811:             getattr(df, name)
  812:         wr = weakref.ref(df)
  813:         del df
  814:         assert wr() is None
  815: 
  816:     def test_label_indexing_on_nan(self, nulls_fixture):
  817:         # GH 32431
  818:         df = Series([1, "{1,2}", 1, nulls_fixture])
  819:         vc = df.value_counts(dropna=False)
  820:         result1 = vc.loc[nulls_fixture]
  821:         result2 = vc[nulls_fixture]
  822: 
  823:         expected = 1
  824:         assert result1 == expected
  825:         assert result2 == expected
  826: 
  827: 
  828: class TestDataframeNoneCoercion:
  829:     EXPECTED_SINGLE_ROW_RESULTS = [
  830:         # For numeric series, we should coerce to NaN.
  831:         ([1, 2, 3], [np.nan, 2, 3], FutureWarning),
  832:         ([1.0, 2.0, 3.0], [np.nan, 2.0, 3.0], None),
  833:         # For datetime series, we should coerce to NaT.
  834:         (
  835:             [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)],
  836:             [NaT, datetime(2000, 1, 2), datetime(2000, 1, 3)],
  837:             None,
  838:         ),
  839:         # For objects, we should preserve the None value.
  840:         (["foo", "bar", "baz"], [None, "bar", "baz"], None),
  841:     ]
  842: 
  843:     @pytest.mark.parametrize("expected", EXPECTED_SINGLE_ROW_RESULTS)
  844:     def test_coercion_with_loc(self, expected):
  845:         start_data, expected_result, warn = expected
  846: 
  847:         start_dataframe = DataFrame({"foo": start_data})
  848:         start_dataframe.loc[0, ["foo"]] = None
  849: 
  850:         expected_dataframe = DataFrame({"foo": expected_result})
  851:         tm.assert_frame_equal(start_dataframe, expected_dataframe)
  852: 
  853:     @pytest.mark.parametrize("expected", EXPECTED_SINGLE_ROW_RESULTS)
  854:     def test_coercion_with_setitem_and_dataframe(self, expected):
  855:         start_data, expected_result, warn = expected
  856: 
  857:         start_dataframe = DataFrame({"foo": start_data})
  858:         start_dataframe[start_dataframe["foo"] == start_dataframe["foo"][0]] = None
  859: 
  860:         expected_dataframe = DataFrame({"foo": expected_result})
  861:         tm.assert_frame_equal(start_dataframe, expected_dataframe)
  862: 
  863:     @pytest.mark.parametrize("expected", EXPECTED_SINGLE_ROW_RESULTS)
  864:     def test_none_coercion_loc_and_dataframe(self, expected):
  865:         start_data, expected_result, warn = expected
  866: 
  867:         start_dataframe = DataFrame({"foo": start_data})
  868:         start_dataframe.loc[start_dataframe["foo"] == start_dataframe["foo"][0]] = None
  869: 
  870:         expected_dataframe = DataFrame({"foo": expected_result})
  871:         tm.assert_frame_equal(start_dataframe, expected_dataframe)
  872: 
  873:     def test_none_coercion_mixed_dtypes(self):
  874:         start_dataframe = DataFrame(
  875:             {
  876:                 "a": [1, 2, 3],
  877:                 "b": [1.0, 2.0, 3.0],
  878:                 "c": [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)],
  879:                 "d": ["a", "b", "c"],
  880:             }
  881:         )
  882:         start_dataframe.iloc[0] = None
  883: 
  884:         exp = DataFrame(
  885:             {
  886:                 "a": [np.nan, 2, 3],
  887:                 "b": [np.nan, 2.0, 3.0],
  888:                 "c": [NaT, datetime(2000, 1, 2), datetime(2000, 1, 3)],
  889:                 "d": [None, "b", "c"],
  890:             }
  891:         )
  892:         tm.assert_frame_equal(start_dataframe, exp)
  893: 
  894: 
  895: class TestDatetimelikeCoercion:
  896:     def test_setitem_dt64_string_scalar(self, tz_naive_fixture, indexer_sli):
  897:         # dispatching _can_hold_element to underlying DatetimeArray
  898:         tz = tz_naive_fixture
  899: 
  900:         dti = date_range("2016-01-01", periods=3, tz=tz)
  901:         ser = Series(dti.copy(deep=True))
  902: 
  903:         values = ser._values
  904: 
  905:         newval = "2018-01-01"
  906:         values._validate_setitem_value(newval)
  907: 
  908:         indexer_sli(ser)[0] = newval
  909: 
  910:         if tz is None:
  911:             # TODO(EA2D): we can make this no-copy in tz-naive case too
  912:             assert ser.dtype == dti.dtype
  913:             assert ser._values._ndarray is values._ndarray
  914:         else:
  915:             assert ser._values is values
  916: 
  917:     @pytest.mark.parametrize("box", [list, np.array, pd.array, pd.Categorical, Index])
  918:     @pytest.mark.parametrize(
  919:         "key", [[0, 1], slice(0, 2), np.array([True, True, False])]
  920:     )
  921:     def test_setitem_dt64_string_values(self, tz_naive_fixture, indexer_sli, key, box):
  922:         # dispatching _can_hold_element to underling DatetimeArray
  923:         tz = tz_naive_fixture
  924: 
  925:         if isinstance(key, slice) and indexer_sli is tm.loc:
  926:             key = slice(0, 1)
  927: 
  928:         dti = date_range("2016-01-01", periods=3, tz=tz)
  929:         ser = Series(dti.copy(deep=True))
  930: 
  931:         values = ser._values
  932: 
  933:         newvals = box(["2019-01-01", "2010-01-02"])
  934:         values._validate_setitem_value(newvals)
  935: 
  936:         indexer_sli(ser)[key] = newvals
  937: 
  938:         if tz is None:
  939:             # TODO(EA2D): we can make this no-copy in tz-naive case too
  940:             assert ser.dtype == dti.dtype
  941:             assert ser._values._ndarray is values._ndarray
  942:         else:
  943:             assert ser._values is values
  944: 
  945:     @pytest.mark.parametrize("scalar", ["3 Days", offsets.Hour(4)])
  946:     def test_setitem_td64_scalar(self, indexer_sli, scalar):
  947:         # dispatching _can_hold_element to underling TimedeltaArray
  948:         tdi = timedelta_range("1 Day", periods=3)
  949:         ser = Series(tdi.copy(deep=True))
  950: 
  951:         values = ser._values
  952:         values._validate_setitem_value(scalar)
  953: 
  954:         indexer_sli(ser)[0] = scalar
  955:         assert ser._values._ndarray is values._ndarray
  956: 
  957:     @pytest.mark.parametrize("box", [list, np.array, pd.array, pd.Categorical, Index])
  958:     @pytest.mark.parametrize(
  959:         "key", [[0, 1], slice(0, 2), np.array([True, True, False])]
  960:     )
  961:     def test_setitem_td64_string_values(self, indexer_sli, key, box):
  962:         # dispatching _can_hold_element to underling TimedeltaArray
  963:         if isinstance(key, slice) and indexer_sli is tm.loc:
  964:             key = slice(0, 1)
  965: 
  966:         tdi = timedelta_range("1 Day", periods=3)
  967:         ser = Series(tdi.copy(deep=True))
  968: 
  969:         values = ser._values
  970: 
  971:         newvals = box(["10 Days", "44 hours"])
  972:         values._validate_setitem_value(newvals)
  973: 
  974:         indexer_sli(ser)[key] = newvals
  975:         assert ser._values._ndarray is values._ndarray
  976: 
  977: 
  978: def test_extension_array_cross_section():
  979:     # A cross-section of a homogeneous EA should be an EA
  980:     df = DataFrame(
  981:         {
  982:             "A": pd.array([1, 2], dtype="Int64"),
  983:             "B": pd.array([3, 4], dtype="Int64"),
  984:         },
  985:         index=["a", "b"],
  986:     )
  987:     expected = Series(pd.array([1, 3], dtype="Int64"), index=["A", "B"], name="a")
  988:     result = df.loc["a"]
  989:     tm.assert_series_equal(result, expected)
  990: 
  991:     result = df.iloc[0]
  992:     tm.assert_series_equal(result, expected)
  993: 
  994: 
  995: def test_extension_array_cross_section_converts():
  996:     # all numeric columns -> numeric series
  997:     df = DataFrame(
  998:         {
  999:             "A": pd.array([1, 2], dtype="Int64"),
 1000:             "B": np.array([1, 2], dtype="int64"),
 1001:         },
 1002:         index=["a", "b"],
 1003:     )
 1004:     result = df.loc["a"]
 1005:     expected = Series([1, 1], dtype="Int64", index=["A", "B"], name="a")
 1006:     tm.assert_series_equal(result, expected)
 1007: 
 1008:     result = df.iloc[0]
 1009:     tm.assert_series_equal(result, expected)
 1010: 
 1011:     # mixed columns -> object series
 1012:     df = DataFrame(
 1013:         {"A": pd.array([1, 2], dtype="Int64"), "B": np.array(["a", "b"])},
 1014:         index=["a", "b"],
 1015:     )
 1016:     result = df.loc["a"]
 1017:     expected = Series([1, "a"], dtype=object, index=["A", "B"], name="a")
 1018:     tm.assert_series_equal(result, expected)
 1019: 
 1020:     result = df.iloc[0]
 1021:     tm.assert_series_equal(result, expected)
 1022: 
 1023: 
 1024: @pytest.mark.parametrize(
 1025:     "ser, keys",
 1026:     [(Series([10]), (0, 0)), (Series([1, 2, 3], index=list("abc")), (0, 1))],
 1027: )
 1028: def test_ser_tup_indexer_exceeds_dimensions(ser, keys, indexer_li):
 1029:     # GH#13831
 1030:     exp_err, exp_msg = IndexingError, "Too many indexers"
 1031:     with pytest.raises(exp_err, match=exp_msg):
 1032:         indexer_li(ser)[keys]
 1033: 
 1034:     if indexer_li == tm.iloc:
 1035:         # For iloc.__setitem__ we let numpy handle the error reporting.
 1036:         exp_err, exp_msg = IndexError, "too many indices for array"
 1037: 
 1038:     with pytest.raises(exp_err, match=exp_msg):
 1039:         indexer_li(ser)[keys] = 0
 1040: 
 1041: 
 1042: def test_ser_list_indexer_exceeds_dimensions(indexer_li):
 1043:     # GH#13831
 1044:     # Make sure an exception is raised when a tuple exceeds the dimension of the series,
 1045:     # but not list when a list is used.
 1046:     ser = Series([10])
 1047:     res = indexer_li(ser)[[0, 0]]
 1048:     exp = Series([10, 10], index=Index([0, 0]))
 1049:     tm.assert_series_equal(res, exp)
 1050: 
 1051: 
 1052: @pytest.mark.parametrize(
 1053:     "value", [(0, 1), [0, 1], np.array([0, 1]), array.array("b", [0, 1])]
 1054: )
 1055: def test_scalar_setitem_with_nested_value(value):
 1056:     # For numeric data, we try to unpack and thus raise for mismatching length
 1057:     df = DataFrame({"A": [1, 2, 3]})
 1058:     msg = "|".join(
 1059:         [
 1060:             "Must have equal len keys and value",
 1061:             "setting an array element with a sequence",
 1062:         ]
 1063:     )
 1064:     with pytest.raises(ValueError, match=msg):
 1065:         df.loc[0, "B"] = value
 1066: 
 1067:     # TODO For object dtype this happens as well, but should we rather preserve
 1068:     # the nested data and set as such?
 1069:     df = DataFrame({"A": [1, 2, 3], "B": np.array([1, "a", "b"], dtype=object)})
 1070:     with pytest.raises(ValueError, match="Must have equal len keys and value"):
 1071:         df.loc[0, "B"] = value
 1072:     # if isinstance(value, np.ndarray):
 1073:     #     assert (df.loc[0, "B"] == value).all()
 1074:     # else:
 1075:     #     assert df.loc[0, "B"] == value
 1076: 
 1077: 
 1078: @pytest.mark.parametrize(
 1079:     "value", [(0, 1), [0, 1], np.array([0, 1]), array.array("b", [0, 1])]
 1080: )
 1081: def test_scalar_setitem_series_with_nested_value(value, indexer_sli):
 1082:     # For numeric data, we try to unpack and thus raise for mismatching length
 1083:     ser = Series([1, 2, 3])
 1084:     with pytest.raises(ValueError, match="setting an array element with a sequence"):
 1085:         indexer_sli(ser)[0] = value
 1086: 
 1087:     # but for object dtype we preserve the nested data and set as such
 1088:     ser = Series([1, "a", "b"], dtype=object)
 1089:     indexer_sli(ser)[0] = value
 1090:     if isinstance(value, np.ndarray):
 1091:         assert (ser.loc[0] == value).all()
 1092:     else:
 1093:         assert ser.loc[0] == value
 1094: 
 1095: 
 1096: @pytest.mark.parametrize(
 1097:     "value", [(0.0,), [0.0], np.array([0.0]), array.array("d", [0.0])]
 1098: )
 1099: def test_scalar_setitem_with_nested_value_length1(value):
 1100:     # https://github.com/pandas-dev/pandas/issues/46268
 1101: 
 1102:     # For numeric data, assigning length-1 array to scalar position gets unpacked
 1103:     df = DataFrame({"A": [1, 2, 3]})
 1104:     df.loc[0, "B"] = value
 1105:     expected = DataFrame({"A": [1, 2, 3], "B": [0.0, np.nan, np.nan]})
 1106:     tm.assert_frame_equal(df, expected)
 1107: 
 1108:     # but for object dtype we preserve the nested data
 1109:     df = DataFrame({"A": [1, 2, 3], "B": np.array([1, "a", "b"], dtype=object)})
 1110:     df.loc[0, "B"] = value
 1111:     if isinstance(value, np.ndarray):
 1112:         assert (df.loc[0, "B"] == value).all()
 1113:     else:
 1114:         assert df.loc[0, "B"] == value
 1115: 
 1116: 
 1117: @pytest.mark.parametrize(
 1118:     "value", [(0.0,), [0.0], np.array([0.0]), array.array("d", [0.0])]
 1119: )
 1120: def test_scalar_setitem_series_with_nested_value_length1(value, indexer_sli):
 1121:     # For numeric data, assigning length-1 array to scalar position gets unpacked
 1122:     # TODO this only happens in case of ndarray, should we make this consistent
 1123:     # for all list-likes? (as happens for DataFrame.(i)loc, see test above)
 1124:     ser = Series([1.0, 2.0, 3.0])
 1125:     if isinstance(value, np.ndarray):
 1126:         indexer_sli(ser)[0] = value
 1127:         expected = Series([0.0, 2.0, 3.0])
 1128:         tm.assert_series_equal(ser, expected)
 1129:     else:
 1130:         with pytest.raises(
 1131:             ValueError, match="setting an array element with a sequence"
 1132:         ):
 1133:             indexer_sli(ser)[0] = value
 1134: 
 1135:     # but for object dtype we preserve the nested data
 1136:     ser = Series([1, "a", "b"], dtype=object)
 1137:     indexer_sli(ser)[0] = value
 1138:     if isinstance(value, np.ndarray):
 1139:         assert (ser.loc[0] == value).all()
 1140:     else:
 1141:         assert ser.loc[0] == value
 1142: 
 1143: 
 1144: def test_object_dtype_series_set_series_element():
 1145:     # GH 48933
 1146:     s1 = Series(dtype="O", index=["a", "b"])
 1147: 
 1148:     s1["a"] = Series()
 1149:     s1.loc["b"] = Series()
 1150: 
 1151:     tm.assert_series_equal(s1.loc["a"], Series())
 1152:     tm.assert_series_equal(s1.loc["b"], Series())
 1153: 
 1154:     s2 = Series(dtype="O", index=["a", "b"])
 1155: 
 1156:     s2.iloc[1] = Series()
 1157:     tm.assert_series_equal(s2.iloc[1], Series())
