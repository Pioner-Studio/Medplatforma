    1: from __future__ import annotations
    2: 
    3: from datetime import (
    4:     datetime,
    5:     timedelta,
    6: )
    7: import itertools
    8: 
    9: import numpy as np
   10: import pytest
   11: 
   12: from pandas._config import using_pyarrow_string_dtype
   13: 
   14: from pandas.compat import (
   15:     IS64,
   16:     is_platform_windows,
   17: )
   18: from pandas.compat.numpy import np_version_gt2
   19: 
   20: import pandas as pd
   21: import pandas._testing as tm
   22: 
   23: ###############################################################
   24: # Index / Series common tests which may trigger dtype coercions
   25: ###############################################################
   26: 
   27: 
   28: @pytest.fixture(autouse=True, scope="class")
   29: def check_comprehensiveness(request):
   30:     # Iterate over combination of dtype, method and klass
   31:     # and ensure that each are contained within a collected test
   32:     cls = request.cls
   33:     combos = itertools.product(cls.klasses, cls.dtypes, [cls.method])
   34: 
   35:     def has_test(combo):
   36:         klass, dtype, method = combo
   37:         cls_funcs = request.node.session.items
   38:         return any(
   39:             klass in x.name and dtype in x.name and method in x.name for x in cls_funcs
   40:         )
   41: 
   42:     opts = request.config.option
   43:     if opts.lf or opts.keyword:
   44:         # If we are running with "last-failed" or -k foo, we expect to only
   45:         #  run a subset of tests.
   46:         yield
   47: 
   48:     else:
   49:         for combo in combos:
   50:             if not has_test(combo):
   51:                 raise AssertionError(
   52:                     f"test method is not defined: {cls.__name__}, {combo}"
   53:                 )
   54: 
   55:         yield
   56: 
   57: 
   58: class CoercionBase:
   59:     klasses = ["index", "series"]
   60:     dtypes = [
   61:         "object",
   62:         "int64",
   63:         "float64",
   64:         "complex128",
   65:         "bool",
   66:         "datetime64",
   67:         "datetime64tz",
   68:         "timedelta64",
   69:         "period",
   70:     ]
   71: 
   72:     @property
   73:     def method(self):
   74:         raise NotImplementedError(self)
   75: 
   76: 
   77: class TestSetitemCoercion(CoercionBase):
   78:     method = "setitem"
   79: 
   80:     # disable comprehensiveness tests, as most of these have been moved to
   81:     #  tests.series.indexing.test_setitem in SetitemCastingEquivalents subclasses.
   82:     klasses: list[str] = []
   83: 
   84:     def test_setitem_series_no_coercion_from_values_list(self):
   85:         # GH35865 - int casted to str when internally calling np.array(ser.values)
   86:         ser = pd.Series(["a", 1])
   87:         ser[:] = list(ser.values)
   88: 
   89:         expected = pd.Series(["a", 1])
   90: 
   91:         tm.assert_series_equal(ser, expected)
   92: 
   93:     def _assert_setitem_index_conversion(
   94:         self, original_series, loc_key, expected_index, expected_dtype
   95:     ):
   96:         """test index's coercion triggered by assign key"""
   97:         temp = original_series.copy()
   98:         # GH#33469 pre-2.0 with int loc_key and temp.index.dtype == np.float64
   99:         #  `temp[loc_key] = 5` treated loc_key as positional
  100:         temp[loc_key] = 5
  101:         exp = pd.Series([1, 2, 3, 4, 5], index=expected_index)
  102:         tm.assert_series_equal(temp, exp)
  103:         # check dtype explicitly for sure
  104:         assert temp.index.dtype == expected_dtype
  105: 
  106:         temp = original_series.copy()
  107:         temp.loc[loc_key] = 5
  108:         exp = pd.Series([1, 2, 3, 4, 5], index=expected_index)
  109:         tm.assert_series_equal(temp, exp)
  110:         # check dtype explicitly for sure
  111:         assert temp.index.dtype == expected_dtype
  112: 
  113:     @pytest.mark.parametrize(
  114:         "val,exp_dtype", [("x", object), (5, IndexError), (1.1, object)]
  115:     )
  116:     def test_setitem_index_object(self, val, exp_dtype):
  117:         obj = pd.Series([1, 2, 3, 4], index=pd.Index(list("abcd"), dtype=object))
  118:         assert obj.index.dtype == object
  119: 
  120:         if exp_dtype is IndexError:
  121:             temp = obj.copy()
  122:             warn_msg = "Series.__setitem__ treating keys as positions is deprecated"
  123:             msg = "index 5 is out of bounds for axis 0 with size 4"
  124:             with pytest.raises(exp_dtype, match=msg):
  125:                 with tm.assert_produces_warning(FutureWarning, match=warn_msg):
  126:                     temp[5] = 5
  127:         else:
  128:             exp_index = pd.Index(list("abcd") + [val], dtype=object)
  129:             self._assert_setitem_index_conversion(obj, val, exp_index, exp_dtype)
  130: 
  131:     @pytest.mark.parametrize(
  132:         "val,exp_dtype", [(5, np.int64), (1.1, np.float64), ("x", object)]
  133:     )
  134:     def test_setitem_index_int64(self, val, exp_dtype):
  135:         obj = pd.Series([1, 2, 3, 4])
  136:         assert obj.index.dtype == np.int64
  137: 
  138:         exp_index = pd.Index([0, 1, 2, 3, val])
  139:         self._assert_setitem_index_conversion(obj, val, exp_index, exp_dtype)
  140: 
  141:     @pytest.mark.parametrize(
  142:         "val,exp_dtype", [(5, np.float64), (5.1, np.float64), ("x", object)]
  143:     )
  144:     def test_setitem_index_float64(self, val, exp_dtype, request):
  145:         obj = pd.Series([1, 2, 3, 4], index=[1.1, 2.1, 3.1, 4.1])
  146:         assert obj.index.dtype == np.float64
  147: 
  148:         exp_index = pd.Index([1.1, 2.1, 3.1, 4.1, val])
  149:         self._assert_setitem_index_conversion(obj, val, exp_index, exp_dtype)
  150: 
  151:     @pytest.mark.xfail(reason="Test not implemented")
  152:     def test_setitem_series_period(self):
  153:         raise NotImplementedError
  154: 
  155:     @pytest.mark.xfail(reason="Test not implemented")
  156:     def test_setitem_index_complex128(self):
  157:         raise NotImplementedError
  158: 
  159:     @pytest.mark.xfail(reason="Test not implemented")
  160:     def test_setitem_index_bool(self):
  161:         raise NotImplementedError
  162: 
  163:     @pytest.mark.xfail(reason="Test not implemented")
  164:     def test_setitem_index_datetime64(self):
  165:         raise NotImplementedError
  166: 
  167:     @pytest.mark.xfail(reason="Test not implemented")
  168:     def test_setitem_index_datetime64tz(self):
  169:         raise NotImplementedError
  170: 
  171:     @pytest.mark.xfail(reason="Test not implemented")
  172:     def test_setitem_index_timedelta64(self):
  173:         raise NotImplementedError
  174: 
  175:     @pytest.mark.xfail(reason="Test not implemented")
  176:     def test_setitem_index_period(self):
  177:         raise NotImplementedError
  178: 
  179: 
  180: class TestInsertIndexCoercion(CoercionBase):
  181:     klasses = ["index"]
  182:     method = "insert"
  183: 
  184:     def _assert_insert_conversion(self, original, value, expected, expected_dtype):
  185:         """test coercion triggered by insert"""
  186:         target = original.copy()
  187:         res = target.insert(1, value)
  188:         tm.assert_index_equal(res, expected)
  189:         assert res.dtype == expected_dtype
  190: 
  191:     @pytest.mark.parametrize(
  192:         "insert, coerced_val, coerced_dtype",
  193:         [
  194:             (1, 1, object),
  195:             (1.1, 1.1, object),
  196:             (False, False, object),
  197:             ("x", "x", object),
  198:         ],
  199:     )
  200:     def test_insert_index_object(self, insert, coerced_val, coerced_dtype):
  201:         obj = pd.Index(list("abcd"), dtype=object)
  202:         assert obj.dtype == object
  203: 
  204:         exp = pd.Index(["a", coerced_val, "b", "c", "d"], dtype=object)
  205:         self._assert_insert_conversion(obj, insert, exp, coerced_dtype)
  206: 
  207:     @pytest.mark.parametrize(
  208:         "insert, coerced_val, coerced_dtype",
  209:         [
  210:             (1, 1, None),
  211:             (1.1, 1.1, np.float64),
  212:             (False, False, object),  # GH#36319
  213:             ("x", "x", object),
  214:         ],
  215:     )
  216:     def test_insert_int_index(
  217:         self, any_int_numpy_dtype, insert, coerced_val, coerced_dtype
  218:     ):
  219:         dtype = any_int_numpy_dtype
  220:         obj = pd.Index([1, 2, 3, 4], dtype=dtype)
  221:         coerced_dtype = coerced_dtype if coerced_dtype is not None else dtype
  222: 
  223:         exp = pd.Index([1, coerced_val, 2, 3, 4], dtype=coerced_dtype)
  224:         self._assert_insert_conversion(obj, insert, exp, coerced_dtype)
  225: 
  226:     @pytest.mark.parametrize(
  227:         "insert, coerced_val, coerced_dtype",
  228:         [
  229:             (1, 1.0, None),
  230:             # When float_numpy_dtype=float32, this is not the case
  231:             # see the correction below
  232:             (1.1, 1.1, np.float64),
  233:             (False, False, object),  # GH#36319
  234:             ("x", "x", object),
  235:         ],
  236:     )
  237:     def test_insert_float_index(
  238:         self, float_numpy_dtype, insert, coerced_val, coerced_dtype
  239:     ):
  240:         dtype = float_numpy_dtype
  241:         obj = pd.Index([1.0, 2.0, 3.0, 4.0], dtype=dtype)
  242:         coerced_dtype = coerced_dtype if coerced_dtype is not None else dtype
  243: 
  244:         if np_version_gt2 and dtype == "float32" and coerced_val == 1.1:
  245:             # Hack, in the 2nd test case, since 1.1 can be losslessly cast to float32
  246:             # the expected dtype will be float32 if the original dtype was float32
  247:             coerced_dtype = np.float32
  248:         exp = pd.Index([1.0, coerced_val, 2.0, 3.0, 4.0], dtype=coerced_dtype)
  249:         self._assert_insert_conversion(obj, insert, exp, coerced_dtype)
  250: 
  251:     @pytest.mark.parametrize(
  252:         "fill_val,exp_dtype",
  253:         [
  254:             (pd.Timestamp("2012-01-01"), "datetime64[ns]"),
  255:             (pd.Timestamp("2012-01-01", tz="US/Eastern"), "datetime64[ns, US/Eastern]"),
  256:         ],
  257:         ids=["datetime64", "datetime64tz"],
  258:     )
  259:     @pytest.mark.parametrize(
  260:         "insert_value",
  261:         [pd.Timestamp("2012-01-01"), pd.Timestamp("2012-01-01", tz="Asia/Tokyo"), 1],
  262:     )
  263:     def test_insert_index_datetimes(self, fill_val, exp_dtype, insert_value):
  264:         obj = pd.DatetimeIndex(
  265:             ["2011-01-01", "2011-01-02", "2011-01-03", "2011-01-04"], tz=fill_val.tz
  266:         ).as_unit("ns")
  267:         assert obj.dtype == exp_dtype
  268: 
  269:         exp = pd.DatetimeIndex(
  270:             ["2011-01-01", fill_val.date(), "2011-01-02", "2011-01-03", "2011-01-04"],
  271:             tz=fill_val.tz,
  272:         ).as_unit("ns")
  273:         self._assert_insert_conversion(obj, fill_val, exp, exp_dtype)
  274: 
  275:         if fill_val.tz:
  276:             # mismatched tzawareness
  277:             ts = pd.Timestamp("2012-01-01")
  278:             result = obj.insert(1, ts)
  279:             expected = obj.astype(object).insert(1, ts)
  280:             assert expected.dtype == object
  281:             tm.assert_index_equal(result, expected)
  282: 
  283:             ts = pd.Timestamp("2012-01-01", tz="Asia/Tokyo")
  284:             result = obj.insert(1, ts)
  285:             # once deprecation is enforced:
  286:             expected = obj.insert(1, ts.tz_convert(obj.dtype.tz))
  287:             assert expected.dtype == obj.dtype
  288:             tm.assert_index_equal(result, expected)
  289: 
  290:         else:
  291:             # mismatched tzawareness
  292:             ts = pd.Timestamp("2012-01-01", tz="Asia/Tokyo")
  293:             result = obj.insert(1, ts)
  294:             expected = obj.astype(object).insert(1, ts)
  295:             assert expected.dtype == object
  296:             tm.assert_index_equal(result, expected)
  297: 
  298:         item = 1
  299:         result = obj.insert(1, item)
  300:         expected = obj.astype(object).insert(1, item)
  301:         assert expected[1] == item
  302:         assert expected.dtype == object
  303:         tm.assert_index_equal(result, expected)
  304: 
  305:     def test_insert_index_timedelta64(self):
  306:         obj = pd.TimedeltaIndex(["1 day", "2 day", "3 day", "4 day"])
  307:         assert obj.dtype == "timedelta64[ns]"
  308: 
  309:         # timedelta64 + timedelta64 => timedelta64
  310:         exp = pd.TimedeltaIndex(["1 day", "10 day", "2 day", "3 day", "4 day"])
  311:         self._assert_insert_conversion(
  312:             obj, pd.Timedelta("10 day"), exp, "timedelta64[ns]"
  313:         )
  314: 
  315:         for item in [pd.Timestamp("2012-01-01"), 1]:
  316:             result = obj.insert(1, item)
  317:             expected = obj.astype(object).insert(1, item)
  318:             assert expected.dtype == object
  319:             tm.assert_index_equal(result, expected)
  320: 
  321:     @pytest.mark.parametrize(
  322:         "insert, coerced_val, coerced_dtype",
  323:         [
  324:             (pd.Period("2012-01", freq="M"), "2012-01", "period[M]"),
  325:             (pd.Timestamp("2012-01-01"), pd.Timestamp("2012-01-01"), object),
  326:             (1, 1, object),
  327:             ("x", "x", object),
  328:         ],
  329:     )
  330:     def test_insert_index_period(self, insert, coerced_val, coerced_dtype):
  331:         obj = pd.PeriodIndex(["2011-01", "2011-02", "2011-03", "2011-04"], freq="M")
  332:         assert obj.dtype == "period[M]"
  333: 
  334:         data = [
  335:             pd.Period("2011-01", freq="M"),
  336:             coerced_val,
  337:             pd.Period("2011-02", freq="M"),
  338:             pd.Period("2011-03", freq="M"),
  339:             pd.Period("2011-04", freq="M"),
  340:         ]
  341:         if isinstance(insert, pd.Period):
  342:             exp = pd.PeriodIndex(data, freq="M")
  343:             self._assert_insert_conversion(obj, insert, exp, coerced_dtype)
  344: 
  345:             # string that can be parsed to appropriate PeriodDtype
  346:             self._assert_insert_conversion(obj, str(insert), exp, coerced_dtype)
  347: 
  348:         else:
  349:             result = obj.insert(0, insert)
  350:             expected = obj.astype(object).insert(0, insert)
  351:             tm.assert_index_equal(result, expected)
  352: 
  353:             # TODO: ATM inserting '2012-01-01 00:00:00' when we have obj.freq=="M"
  354:             #  casts that string to Period[M], not clear that is desirable
  355:             if not isinstance(insert, pd.Timestamp):
  356:                 # non-castable string
  357:                 result = obj.insert(0, str(insert))
  358:                 expected = obj.astype(object).insert(0, str(insert))
  359:                 tm.assert_index_equal(result, expected)
  360: 
  361:     @pytest.mark.xfail(reason="Test not implemented")
  362:     def test_insert_index_complex128(self):
  363:         raise NotImplementedError
  364: 
  365:     @pytest.mark.xfail(reason="Test not implemented")
  366:     def test_insert_index_bool(self):
  367:         raise NotImplementedError
  368: 
  369: 
  370: class TestWhereCoercion(CoercionBase):
  371:     method = "where"
  372:     _cond = np.array([True, False, True, False])
  373: 
  374:     def _assert_where_conversion(
  375:         self, original, cond, values, expected, expected_dtype
  376:     ):
  377:         """test coercion triggered by where"""
  378:         target = original.copy()
  379:         res = target.where(cond, values)
  380:         tm.assert_equal(res, expected)
  381:         assert res.dtype == expected_dtype
  382: 
  383:     def _construct_exp(self, obj, klass, fill_val, exp_dtype):
  384:         if fill_val is True:
  385:             values = klass([True, False, True, True])
  386:         elif isinstance(fill_val, (datetime, np.datetime64)):
  387:             values = pd.date_range(fill_val, periods=4)
  388:         else:
  389:             values = klass(x * fill_val for x in [5, 6, 7, 8])
  390: 
  391:         exp = klass([obj[0], values[1], obj[2], values[3]], dtype=exp_dtype)
  392:         return values, exp
  393: 
  394:     def _run_test(self, obj, fill_val, klass, exp_dtype):
  395:         cond = klass(self._cond)
  396: 
  397:         exp = klass([obj[0], fill_val, obj[2], fill_val], dtype=exp_dtype)
  398:         self._assert_where_conversion(obj, cond, fill_val, exp, exp_dtype)
  399: 
  400:         values, exp = self._construct_exp(obj, klass, fill_val, exp_dtype)
  401:         self._assert_where_conversion(obj, cond, values, exp, exp_dtype)
  402: 
  403:     @pytest.mark.parametrize(
  404:         "fill_val,exp_dtype",
  405:         [(1, object), (1.1, object), (1 + 1j, object), (True, object)],
  406:     )
  407:     def test_where_object(self, index_or_series, fill_val, exp_dtype):
  408:         klass = index_or_series
  409:         obj = klass(list("abcd"), dtype=object)
  410:         assert obj.dtype == object
  411:         self._run_test(obj, fill_val, klass, exp_dtype)
  412: 
  413:     @pytest.mark.parametrize(
  414:         "fill_val,exp_dtype",
  415:         [(1, np.int64), (1.1, np.float64), (1 + 1j, np.complex128), (True, object)],
  416:     )
  417:     def test_where_int64(self, index_or_series, fill_val, exp_dtype, request):
  418:         klass = index_or_series
  419: 
  420:         obj = klass([1, 2, 3, 4])
  421:         assert obj.dtype == np.int64
  422:         self._run_test(obj, fill_val, klass, exp_dtype)
  423: 
  424:     @pytest.mark.parametrize(
  425:         "fill_val, exp_dtype",
  426:         [(1, np.float64), (1.1, np.float64), (1 + 1j, np.complex128), (True, object)],
  427:     )
  428:     def test_where_float64(self, index_or_series, fill_val, exp_dtype, request):
  429:         klass = index_or_series
  430: 
  431:         obj = klass([1.1, 2.2, 3.3, 4.4])
  432:         assert obj.dtype == np.float64
  433:         self._run_test(obj, fill_val, klass, exp_dtype)
  434: 
  435:     @pytest.mark.parametrize(
  436:         "fill_val,exp_dtype",
  437:         [
  438:             (1, np.complex128),
  439:             (1.1, np.complex128),
  440:             (1 + 1j, np.complex128),
  441:             (True, object),
  442:         ],
  443:     )
  444:     def test_where_complex128(self, index_or_series, fill_val, exp_dtype):
  445:         klass = index_or_series
  446:         obj = klass([1 + 1j, 2 + 2j, 3 + 3j, 4 + 4j], dtype=np.complex128)
  447:         assert obj.dtype == np.complex128
  448:         self._run_test(obj, fill_val, klass, exp_dtype)
  449: 
  450:     @pytest.mark.parametrize(
  451:         "fill_val,exp_dtype",
  452:         [(1, object), (1.1, object), (1 + 1j, object), (True, np.bool_)],
  453:     )
  454:     def test_where_series_bool(self, index_or_series, fill_val, exp_dtype):
  455:         klass = index_or_series
  456: 
  457:         obj = klass([True, False, True, False])
  458:         assert obj.dtype == np.bool_
  459:         self._run_test(obj, fill_val, klass, exp_dtype)
  460: 
  461:     @pytest.mark.parametrize(
  462:         "fill_val,exp_dtype",
  463:         [
  464:             (pd.Timestamp("2012-01-01"), "datetime64[ns]"),
  465:             (pd.Timestamp("2012-01-01", tz="US/Eastern"), object),
  466:         ],
  467:         ids=["datetime64", "datetime64tz"],
  468:     )
  469:     def test_where_datetime64(self, index_or_series, fill_val, exp_dtype):
  470:         klass = index_or_series
  471: 
  472:         obj = klass(pd.date_range("2011-01-01", periods=4, freq="D")._with_freq(None))
  473:         assert obj.dtype == "datetime64[ns]"
  474: 
  475:         fv = fill_val
  476:         # do the check with each of the available datetime scalars
  477:         if exp_dtype == "datetime64[ns]":
  478:             for scalar in [fv, fv.to_pydatetime(), fv.to_datetime64()]:
  479:                 self._run_test(obj, scalar, klass, exp_dtype)
  480:         else:
  481:             for scalar in [fv, fv.to_pydatetime()]:
  482:                 self._run_test(obj, fill_val, klass, exp_dtype)
  483: 
  484:     @pytest.mark.xfail(reason="Test not implemented")
  485:     def test_where_index_complex128(self):
  486:         raise NotImplementedError
  487: 
  488:     @pytest.mark.xfail(reason="Test not implemented")
  489:     def test_where_index_bool(self):
  490:         raise NotImplementedError
  491: 
  492:     @pytest.mark.xfail(reason="Test not implemented")
  493:     def test_where_series_timedelta64(self):
  494:         raise NotImplementedError
  495: 
  496:     @pytest.mark.xfail(reason="Test not implemented")
  497:     def test_where_series_period(self):
  498:         raise NotImplementedError
  499: 
  500:     @pytest.mark.parametrize(
  501:         "value", [pd.Timedelta(days=9), timedelta(days=9), np.timedelta64(9, "D")]
  502:     )
  503:     def test_where_index_timedelta64(self, value):
  504:         tdi = pd.timedelta_range("1 Day", periods=4)
  505:         cond = np.array([True, False, False, True])
  506: 
  507:         expected = pd.TimedeltaIndex(["1 Day", value, value, "4 Days"])
  508:         result = tdi.where(cond, value)
  509:         tm.assert_index_equal(result, expected)
  510: 
  511:         # wrong-dtyped NaT
  512:         dtnat = np.datetime64("NaT", "ns")
  513:         expected = pd.Index([tdi[0], dtnat, dtnat, tdi[3]], dtype=object)
  514:         assert expected[1] is dtnat
  515: 
  516:         result = tdi.where(cond, dtnat)
  517:         tm.assert_index_equal(result, expected)
  518: 
  519:     def test_where_index_period(self):
  520:         dti = pd.date_range("2016-01-01", periods=3, freq="QS")
  521:         pi = dti.to_period("Q")
  522: 
  523:         cond = np.array([False, True, False])
  524: 
  525:         # Passing a valid scalar
  526:         value = pi[-1] + pi.freq * 10
  527:         expected = pd.PeriodIndex([value, pi[1], value])
  528:         result = pi.where(cond, value)
  529:         tm.assert_index_equal(result, expected)
  530: 
  531:         # Case passing ndarray[object] of Periods
  532:         other = np.asarray(pi + pi.freq * 10, dtype=object)
  533:         result = pi.where(cond, other)
  534:         expected = pd.PeriodIndex([other[0], pi[1], other[2]])
  535:         tm.assert_index_equal(result, expected)
  536: 
  537:         # Passing a mismatched scalar -> casts to object
  538:         td = pd.Timedelta(days=4)
  539:         expected = pd.Index([td, pi[1], td], dtype=object)
  540:         result = pi.where(cond, td)
  541:         tm.assert_index_equal(result, expected)
  542: 
  543:         per = pd.Period("2020-04-21", "D")
  544:         expected = pd.Index([per, pi[1], per], dtype=object)
  545:         result = pi.where(cond, per)
  546:         tm.assert_index_equal(result, expected)
  547: 
  548: 
  549: class TestFillnaSeriesCoercion(CoercionBase):
  550:     # not indexing, but place here for consistency
  551: 
  552:     method = "fillna"
  553: 
  554:     @pytest.mark.xfail(reason="Test not implemented")
  555:     def test_has_comprehensive_tests(self):
  556:         raise NotImplementedError
  557: 
  558:     def _assert_fillna_conversion(self, original, value, expected, expected_dtype):
  559:         """test coercion triggered by fillna"""
  560:         target = original.copy()
  561:         res = target.fillna(value)
  562:         tm.assert_equal(res, expected)
  563:         assert res.dtype == expected_dtype
  564: 
  565:     @pytest.mark.parametrize(
  566:         "fill_val, fill_dtype",
  567:         [(1, object), (1.1, object), (1 + 1j, object), (True, object)],
  568:     )
  569:     def test_fillna_object(self, index_or_series, fill_val, fill_dtype):
  570:         klass = index_or_series
  571:         obj = klass(["a", np.nan, "c", "d"], dtype=object)
  572:         assert obj.dtype == object
  573: 
  574:         exp = klass(["a", fill_val, "c", "d"], dtype=object)
  575:         self._assert_fillna_conversion(obj, fill_val, exp, fill_dtype)
  576: 
  577:     @pytest.mark.parametrize(
  578:         "fill_val,fill_dtype",
  579:         [(1, np.float64), (1.1, np.float64), (1 + 1j, np.complex128), (True, object)],
  580:     )
  581:     def test_fillna_float64(self, index_or_series, fill_val, fill_dtype):
  582:         klass = index_or_series
  583:         obj = klass([1.1, np.nan, 3.3, 4.4])
  584:         assert obj.dtype == np.float64
  585: 
  586:         exp = klass([1.1, fill_val, 3.3, 4.4])
  587:         self._assert_fillna_conversion(obj, fill_val, exp, fill_dtype)
  588: 
  589:     @pytest.mark.parametrize(
  590:         "fill_val,fill_dtype",
  591:         [
  592:             (1, np.complex128),
  593:             (1.1, np.complex128),
  594:             (1 + 1j, np.complex128),
  595:             (True, object),
  596:         ],
  597:     )
  598:     def test_fillna_complex128(self, index_or_series, fill_val, fill_dtype):
  599:         klass = index_or_series
  600:         obj = klass([1 + 1j, np.nan, 3 + 3j, 4 + 4j], dtype=np.complex128)
  601:         assert obj.dtype == np.complex128
  602: 
  603:         exp = klass([1 + 1j, fill_val, 3 + 3j, 4 + 4j])
  604:         self._assert_fillna_conversion(obj, fill_val, exp, fill_dtype)
  605: 
  606:     @pytest.mark.parametrize(
  607:         "fill_val,fill_dtype",
  608:         [
  609:             (pd.Timestamp("2012-01-01"), "datetime64[ns]"),
  610:             (pd.Timestamp("2012-01-01", tz="US/Eastern"), object),
  611:             (1, object),
  612:             ("x", object),
  613:         ],
  614:         ids=["datetime64", "datetime64tz", "object", "object"],
  615:     )
  616:     def test_fillna_datetime(self, index_or_series, fill_val, fill_dtype):
  617:         klass = index_or_series
  618:         obj = klass(
  619:             [
  620:                 pd.Timestamp("2011-01-01"),
  621:                 pd.NaT,
  622:                 pd.Timestamp("2011-01-03"),
  623:                 pd.Timestamp("2011-01-04"),
  624:             ]
  625:         )
  626:         assert obj.dtype == "datetime64[ns]"
  627: 
  628:         exp = klass(
  629:             [
  630:                 pd.Timestamp("2011-01-01"),
  631:                 fill_val,
  632:                 pd.Timestamp("2011-01-03"),
  633:                 pd.Timestamp("2011-01-04"),
  634:             ]
  635:         )
  636:         self._assert_fillna_conversion(obj, fill_val, exp, fill_dtype)
  637: 
  638:     @pytest.mark.parametrize(
  639:         "fill_val,fill_dtype",
  640:         [
  641:             (pd.Timestamp("2012-01-01", tz="US/Eastern"), "datetime64[ns, US/Eastern]"),
  642:             (pd.Timestamp("2012-01-01"), object),
  643:             # pre-2.0 with a mismatched tz we would get object result
  644:             (pd.Timestamp("2012-01-01", tz="Asia/Tokyo"), "datetime64[ns, US/Eastern]"),
  645:             (1, object),
  646:             ("x", object),
  647:         ],
  648:     )
  649:     def test_fillna_datetime64tz(self, index_or_series, fill_val, fill_dtype):
  650:         klass = index_or_series
  651:         tz = "US/Eastern"
  652: 
  653:         obj = klass(
  654:             [
  655:                 pd.Timestamp("2011-01-01", tz=tz),
  656:                 pd.NaT,
  657:                 pd.Timestamp("2011-01-03", tz=tz),
  658:                 pd.Timestamp("2011-01-04", tz=tz),
  659:             ]
  660:         )
  661:         assert obj.dtype == "datetime64[ns, US/Eastern]"
  662: 
  663:         if getattr(fill_val, "tz", None) is None:
  664:             fv = fill_val
  665:         else:
  666:             fv = fill_val.tz_convert(tz)
  667:         exp = klass(
  668:             [
  669:                 pd.Timestamp("2011-01-01", tz=tz),
  670:                 fv,
  671:                 pd.Timestamp("2011-01-03", tz=tz),
  672:                 pd.Timestamp("2011-01-04", tz=tz),
  673:             ]
  674:         )
  675:         self._assert_fillna_conversion(obj, fill_val, exp, fill_dtype)
  676: 
  677:     @pytest.mark.parametrize(
  678:         "fill_val",
  679:         [
  680:             1,
  681:             1.1,
  682:             1 + 1j,
  683:             True,
  684:             pd.Interval(1, 2, closed="left"),
  685:             pd.Timestamp("2012-01-01", tz="US/Eastern"),
  686:             pd.Timestamp("2012-01-01"),
  687:             pd.Timedelta(days=1),
  688:             pd.Period("2016-01-01", "D"),
  689:         ],
  690:     )
  691:     def test_fillna_interval(self, index_or_series, fill_val):
  692:         ii = pd.interval_range(1.0, 5.0, closed="right").insert(1, np.nan)
  693:         assert isinstance(ii.dtype, pd.IntervalDtype)
  694:         obj = index_or_series(ii)
  695: 
  696:         exp = index_or_series([ii[0], fill_val, ii[2], ii[3], ii[4]], dtype=object)
  697: 
  698:         fill_dtype = object
  699:         self._assert_fillna_conversion(obj, fill_val, exp, fill_dtype)
  700: 
  701:     @pytest.mark.xfail(reason="Test not implemented")
  702:     def test_fillna_series_int64(self):
  703:         raise NotImplementedError
  704: 
  705:     @pytest.mark.xfail(reason="Test not implemented")
  706:     def test_fillna_index_int64(self):
  707:         raise NotImplementedError
  708: 
  709:     @pytest.mark.xfail(reason="Test not implemented")
  710:     def test_fillna_series_bool(self):
  711:         raise NotImplementedError
  712: 
  713:     @pytest.mark.xfail(reason="Test not implemented")
  714:     def test_fillna_index_bool(self):
  715:         raise NotImplementedError
  716: 
  717:     @pytest.mark.xfail(reason="Test not implemented")
  718:     def test_fillna_series_timedelta64(self):
  719:         raise NotImplementedError
  720: 
  721:     @pytest.mark.parametrize(
  722:         "fill_val",
  723:         [
  724:             1,
  725:             1.1,
  726:             1 + 1j,
  727:             True,
  728:             pd.Interval(1, 2, closed="left"),
  729:             pd.Timestamp("2012-01-01", tz="US/Eastern"),
  730:             pd.Timestamp("2012-01-01"),
  731:             pd.Timedelta(days=1),
  732:             pd.Period("2016-01-01", "W"),
  733:         ],
  734:     )
  735:     def test_fillna_series_period(self, index_or_series, fill_val):
  736:         pi = pd.period_range("2016-01-01", periods=4, freq="D").insert(1, pd.NaT)
  737:         assert isinstance(pi.dtype, pd.PeriodDtype)
  738:         obj = index_or_series(pi)
  739: 
  740:         exp = index_or_series([pi[0], fill_val, pi[2], pi[3], pi[4]], dtype=object)
  741: 
  742:         fill_dtype = object
  743:         self._assert_fillna_conversion(obj, fill_val, exp, fill_dtype)
  744: 
  745:     @pytest.mark.xfail(reason="Test not implemented")
  746:     def test_fillna_index_timedelta64(self):
  747:         raise NotImplementedError
  748: 
  749:     @pytest.mark.xfail(reason="Test not implemented")
  750:     def test_fillna_index_period(self):
  751:         raise NotImplementedError
  752: 
  753: 
  754: class TestReplaceSeriesCoercion(CoercionBase):
  755:     klasses = ["series"]
  756:     method = "replace"
  757: 
  758:     rep: dict[str, list] = {}
  759:     rep["object"] = ["a", "b"]
  760:     rep["int64"] = [4, 5]
  761:     rep["float64"] = [1.1, 2.2]
  762:     rep["complex128"] = [1 + 1j, 2 + 2j]
  763:     rep["bool"] = [True, False]
  764:     rep["datetime64[ns]"] = [pd.Timestamp("2011-01-01"), pd.Timestamp("2011-01-03")]
  765: 
  766:     for tz in ["UTC", "US/Eastern"]:
  767:         # to test tz => different tz replacement
  768:         key = f"datetime64[ns, {tz}]"
  769:         rep[key] = [
  770:             pd.Timestamp("2011-01-01", tz=tz),
  771:             pd.Timestamp("2011-01-03", tz=tz),
  772:         ]
  773: 
  774:     rep["timedelta64[ns]"] = [pd.Timedelta("1 day"), pd.Timedelta("2 day")]
  775: 
  776:     @pytest.fixture(params=["dict", "series"])
  777:     def how(self, request):
  778:         return request.param
  779: 
  780:     @pytest.fixture(
  781:         params=[
  782:             "object",
  783:             "int64",
  784:             "float64",
  785:             "complex128",
  786:             "bool",
  787:             "datetime64[ns]",
  788:             "datetime64[ns, UTC]",
  789:             "datetime64[ns, US/Eastern]",
  790:             "timedelta64[ns]",
  791:         ]
  792:     )
  793:     def from_key(self, request):
  794:         return request.param
  795: 
  796:     @pytest.fixture(
  797:         params=[
  798:             "object",
  799:             "int64",
  800:             "float64",
  801:             "complex128",
  802:             "bool",
  803:             "datetime64[ns]",
  804:             "datetime64[ns, UTC]",
  805:             "datetime64[ns, US/Eastern]",
  806:             "timedelta64[ns]",
  807:         ],
  808:         ids=[
  809:             "object",
  810:             "int64",
  811:             "float64",
  812:             "complex128",
  813:             "bool",
  814:             "datetime64",
  815:             "datetime64tz",
  816:             "datetime64tz",
  817:             "timedelta64",
  818:         ],
  819:     )
  820:     def to_key(self, request):
  821:         return request.param
  822: 
  823:     @pytest.fixture
  824:     def replacer(self, how, from_key, to_key):
  825:         """
  826:         Object we will pass to `Series.replace`
  827:         """
  828:         if how == "dict":
  829:             replacer = dict(zip(self.rep[from_key], self.rep[to_key]))
  830:         elif how == "series":
  831:             replacer = pd.Series(self.rep[to_key], index=self.rep[from_key])
  832:         else:
  833:             raise ValueError
  834:         return replacer
  835: 
  836:     # Expected needs adjustment for the infer string option, seems to work as expecetd
  837:     @pytest.mark.skipif(using_pyarrow_string_dtype(), reason="TODO: test is to complex")
  838:     def test_replace_series(self, how, to_key, from_key, replacer):
  839:         index = pd.Index([3, 4], name="xxx")
  840:         obj = pd.Series(self.rep[from_key], index=index, name="yyy")
  841:         assert obj.dtype == from_key
  842: 
  843:         if from_key.startswith("datetime") and to_key.startswith("datetime"):
  844:             # tested below
  845:             return
  846:         elif from_key in ["datetime64[ns, US/Eastern]", "datetime64[ns, UTC]"]:
  847:             # tested below
  848:             return
  849: 
  850:         if (from_key == "float64" and to_key in ("int64")) or (
  851:             from_key == "complex128" and to_key in ("int64", "float64")
  852:         ):
  853:             if not IS64 or is_platform_windows():
  854:                 pytest.skip(f"32-bit platform buggy: {from_key} -> {to_key}")
  855: 
  856:             # Expected: do not downcast by replacement
  857:             exp = pd.Series(self.rep[to_key], index=index, name="yyy", dtype=from_key)
  858: 
  859:         else:
  860:             exp = pd.Series(self.rep[to_key], index=index, name="yyy")
  861:             assert exp.dtype == to_key
  862: 
  863:         msg = "Downcasting behavior in `replace`"
  864:         warn = FutureWarning
  865:         if (
  866:             exp.dtype == obj.dtype
  867:             or exp.dtype == object
  868:             or (exp.dtype.kind in "iufc" and obj.dtype.kind in "iufc")
  869:         ):
  870:             warn = None
  871:         with tm.assert_produces_warning(warn, match=msg):
  872:             result = obj.replace(replacer)
  873: 
  874:         tm.assert_series_equal(result, exp)
  875: 
  876:     @pytest.mark.parametrize(
  877:         "to_key",
  878:         ["timedelta64[ns]", "bool", "object", "complex128", "float64", "int64"],
  879:         indirect=True,
  880:     )
  881:     @pytest.mark.parametrize(
  882:         "from_key", ["datetime64[ns, UTC]", "datetime64[ns, US/Eastern]"], indirect=True
  883:     )
  884:     def test_replace_series_datetime_tz(
  885:         self, how, to_key, from_key, replacer, using_infer_string
  886:     ):
  887:         index = pd.Index([3, 4], name="xyz")
  888:         obj = pd.Series(self.rep[from_key], index=index, name="yyy")
  889:         assert obj.dtype == from_key
  890: 
  891:         exp = pd.Series(self.rep[to_key], index=index, name="yyy")
  892:         if using_infer_string and to_key == "object":
  893:             assert exp.dtype == "string"
  894:         else:
  895:             assert exp.dtype == to_key
  896: 
  897:         msg = "Downcasting behavior in `replace`"
  898:         warn = FutureWarning if exp.dtype != object else None
  899:         with tm.assert_produces_warning(warn, match=msg):
  900:             result = obj.replace(replacer)
  901: 
  902:         tm.assert_series_equal(result, exp)
  903: 
  904:     @pytest.mark.parametrize(
  905:         "to_key",
  906:         ["datetime64[ns]", "datetime64[ns, UTC]", "datetime64[ns, US/Eastern]"],
  907:         indirect=True,
  908:     )
  909:     @pytest.mark.parametrize(
  910:         "from_key",
  911:         ["datetime64[ns]", "datetime64[ns, UTC]", "datetime64[ns, US/Eastern]"],
  912:         indirect=True,
  913:     )
  914:     def test_replace_series_datetime_datetime(self, how, to_key, from_key, replacer):
  915:         index = pd.Index([3, 4], name="xyz")
  916:         obj = pd.Series(self.rep[from_key], index=index, name="yyy")
  917:         assert obj.dtype == from_key
  918: 
  919:         exp = pd.Series(self.rep[to_key], index=index, name="yyy")
  920:         warn = FutureWarning
  921:         if isinstance(obj.dtype, pd.DatetimeTZDtype) and isinstance(
  922:             exp.dtype, pd.DatetimeTZDtype
  923:         ):
  924:             # with mismatched tzs, we retain the original dtype as of 2.0
  925:             exp = exp.astype(obj.dtype)
  926:             warn = None
  927:         else:
  928:             assert exp.dtype == to_key
  929:             if to_key == from_key:
  930:                 warn = None
  931: 
  932:         msg = "Downcasting behavior in `replace`"
  933:         with tm.assert_produces_warning(warn, match=msg):
  934:             result = obj.replace(replacer)
  935: 
  936:         tm.assert_series_equal(result, exp)
  937: 
  938:     @pytest.mark.xfail(reason="Test not implemented")
  939:     def test_replace_series_period(self):
  940:         raise NotImplementedError
