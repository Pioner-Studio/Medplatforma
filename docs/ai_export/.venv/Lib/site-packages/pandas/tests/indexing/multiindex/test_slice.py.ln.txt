    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas.errors import UnsortedIndexError
   10: 
   11: import pandas as pd
   12: from pandas import (
   13:     DataFrame,
   14:     Index,
   15:     MultiIndex,
   16:     Series,
   17:     Timestamp,
   18: )
   19: import pandas._testing as tm
   20: from pandas.tests.indexing.common import _mklbl
   21: 
   22: 
   23: class TestMultiIndexSlicers:
   24:     def test_per_axis_per_level_getitem(self):
   25:         # GH6134
   26:         # example test case
   27:         ix = MultiIndex.from_product(
   28:             [_mklbl("A", 5), _mklbl("B", 7), _mklbl("C", 4), _mklbl("D", 2)]
   29:         )
   30:         df = DataFrame(np.arange(len(ix.to_numpy())), index=ix)
   31: 
   32:         result = df.loc[(slice("A1", "A3"), slice(None), ["C1", "C3"]), :]
   33:         expected = df.loc[
   34:             [
   35:                 (
   36:                     a,
   37:                     b,
   38:                     c,
   39:                     d,
   40:                 )
   41:                 for a, b, c, d in df.index.values
   42:                 if a in ("A1", "A2", "A3") and c in ("C1", "C3")
   43:             ]
   44:         ]
   45:         tm.assert_frame_equal(result, expected)
   46: 
   47:         expected = df.loc[
   48:             [
   49:                 (
   50:                     a,
   51:                     b,
   52:                     c,
   53:                     d,
   54:                 )
   55:                 for a, b, c, d in df.index.values
   56:                 if a in ("A1", "A2", "A3") and c in ("C1", "C2", "C3")
   57:             ]
   58:         ]
   59:         result = df.loc[(slice("A1", "A3"), slice(None), slice("C1", "C3")), :]
   60:         tm.assert_frame_equal(result, expected)
   61: 
   62:         # test multi-index slicing with per axis and per index controls
   63:         index = MultiIndex.from_tuples(
   64:             [("A", 1), ("A", 2), ("A", 3), ("B", 1)], names=["one", "two"]
   65:         )
   66:         columns = MultiIndex.from_tuples(
   67:             [("a", "foo"), ("a", "bar"), ("b", "foo"), ("b", "bah")],
   68:             names=["lvl0", "lvl1"],
   69:         )
   70: 
   71:         df = DataFrame(
   72:             np.arange(16, dtype="int64").reshape(4, 4), index=index, columns=columns
   73:         )
   74:         df = df.sort_index(axis=0).sort_index(axis=1)
   75: 
   76:         # identity
   77:         result = df.loc[(slice(None), slice(None)), :]
   78:         tm.assert_frame_equal(result, df)
   79:         result = df.loc[(slice(None), slice(None)), (slice(None), slice(None))]
   80:         tm.assert_frame_equal(result, df)
   81:         result = df.loc[:, (slice(None), slice(None))]
   82:         tm.assert_frame_equal(result, df)
   83: 
   84:         # index
   85:         result = df.loc[(slice(None), [1]), :]
   86:         expected = df.iloc[[0, 3]]
   87:         tm.assert_frame_equal(result, expected)
   88: 
   89:         result = df.loc[(slice(None), 1), :]
   90:         expected = df.iloc[[0, 3]]
   91:         tm.assert_frame_equal(result, expected)
   92: 
   93:         # columns
   94:         result = df.loc[:, (slice(None), ["foo"])]
   95:         expected = df.iloc[:, [1, 3]]
   96:         tm.assert_frame_equal(result, expected)
   97: 
   98:         # both
   99:         result = df.loc[(slice(None), 1), (slice(None), ["foo"])]
  100:         expected = df.iloc[[0, 3], [1, 3]]
  101:         tm.assert_frame_equal(result, expected)
  102: 
  103:         result = df.loc["A", "a"]
  104:         expected = DataFrame(
  105:             {"bar": [1, 5, 9], "foo": [0, 4, 8]},
  106:             index=Index([1, 2, 3], name="two"),
  107:             columns=Index(["bar", "foo"], name="lvl1"),
  108:         )
  109:         tm.assert_frame_equal(result, expected)
  110: 
  111:         result = df.loc[(slice(None), [1, 2]), :]
  112:         expected = df.iloc[[0, 1, 3]]
  113:         tm.assert_frame_equal(result, expected)
  114: 
  115:         # multi-level series
  116:         s = Series(np.arange(len(ix.to_numpy())), index=ix)
  117:         result = s.loc["A1":"A3", :, ["C1", "C3"]]
  118:         expected = s.loc[
  119:             [
  120:                 (
  121:                     a,
  122:                     b,
  123:                     c,
  124:                     d,
  125:                 )
  126:                 for a, b, c, d in s.index.values
  127:                 if a in ("A1", "A2", "A3") and c in ("C1", "C3")
  128:             ]
  129:         ]
  130:         tm.assert_series_equal(result, expected)
  131: 
  132:         # boolean indexers
  133:         result = df.loc[(slice(None), df.loc[:, ("a", "bar")] > 5), :]
  134:         expected = df.iloc[[2, 3]]
  135:         tm.assert_frame_equal(result, expected)
  136: 
  137:         msg = (
  138:             "cannot index with a boolean indexer "
  139:             "that is not the same length as the index"
  140:         )
  141:         with pytest.raises(ValueError, match=msg):
  142:             df.loc[(slice(None), np.array([True, False])), :]
  143: 
  144:         with pytest.raises(KeyError, match=r"\[1\] not in index"):
  145:             # slice(None) is on the index, [1] is on the columns, but 1 is
  146:             #  not in the columns, so we raise
  147:             #  This used to treat [1] as positional GH#16396
  148:             df.loc[slice(None), [1]]
  149: 
  150:         # not lexsorted
  151:         assert df.index._lexsort_depth == 2
  152:         df = df.sort_index(level=1, axis=0)
  153:         assert df.index._lexsort_depth == 0
  154: 
  155:         msg = (
  156:             "MultiIndex slicing requires the index to be "
  157:             r"lexsorted: slicing on levels \[1\], lexsort depth 0"
  158:         )
  159:         with pytest.raises(UnsortedIndexError, match=msg):
  160:             df.loc[(slice(None), slice("bar")), :]
  161: 
  162:         # GH 16734: not sorted, but no real slicing
  163:         result = df.loc[(slice(None), df.loc[:, ("a", "bar")] > 5), :]
  164:         tm.assert_frame_equal(result, df.iloc[[1, 3], :])
  165: 
  166:     def test_multiindex_slicers_non_unique(self):
  167:         # GH 7106
  168:         # non-unique mi index support
  169:         df = (
  170:             DataFrame(
  171:                 {
  172:                     "A": ["foo", "foo", "foo", "foo"],
  173:                     "B": ["a", "a", "a", "a"],
  174:                     "C": [1, 2, 1, 3],
  175:                     "D": [1, 2, 3, 4],
  176:                 }
  177:             )
  178:             .set_index(["A", "B", "C"])
  179:             .sort_index()
  180:         )
  181:         assert not df.index.is_unique
  182:         expected = (
  183:             DataFrame({"A": ["foo", "foo"], "B": ["a", "a"], "C": [1, 1], "D": [1, 3]})
  184:             .set_index(["A", "B", "C"])
  185:             .sort_index()
  186:         )
  187:         result = df.loc[(slice(None), slice(None), 1), :]
  188:         tm.assert_frame_equal(result, expected)
  189: 
  190:         # this is equivalent of an xs expression
  191:         result = df.xs(1, level=2, drop_level=False)
  192:         tm.assert_frame_equal(result, expected)
  193: 
  194:         df = (
  195:             DataFrame(
  196:                 {
  197:                     "A": ["foo", "foo", "foo", "foo"],
  198:                     "B": ["a", "a", "a", "a"],
  199:                     "C": [1, 2, 1, 2],
  200:                     "D": [1, 2, 3, 4],
  201:                 }
  202:             )
  203:             .set_index(["A", "B", "C"])
  204:             .sort_index()
  205:         )
  206:         assert not df.index.is_unique
  207:         expected = (
  208:             DataFrame({"A": ["foo", "foo"], "B": ["a", "a"], "C": [1, 1], "D": [1, 3]})
  209:             .set_index(["A", "B", "C"])
  210:             .sort_index()
  211:         )
  212:         result = df.loc[(slice(None), slice(None), 1), :]
  213:         assert not result.index.is_unique
  214:         tm.assert_frame_equal(result, expected)
  215: 
  216:         # GH12896
  217:         # numpy-implementation dependent bug
  218:         ints = [
  219:             1,
  220:             2,
  221:             3,
  222:             4,
  223:             5,
  224:             6,
  225:             7,
  226:             8,
  227:             9,
  228:             10,
  229:             11,
  230:             12,
  231:             12,
  232:             13,
  233:             14,
  234:             14,
  235:             16,
  236:             17,
  237:             18,
  238:             19,
  239:             200000,
  240:             200000,
  241:         ]
  242:         n = len(ints)
  243:         idx = MultiIndex.from_arrays([["a"] * n, ints])
  244:         result = Series([1] * n, index=idx)
  245:         result = result.sort_index()
  246:         result = result.loc[(slice(None), slice(100000))]
  247:         expected = Series([1] * (n - 2), index=idx[:-2]).sort_index()
  248:         tm.assert_series_equal(result, expected)
  249: 
  250:     def test_multiindex_slicers_datetimelike(self):
  251:         # GH 7429
  252:         # buggy/inconsistent behavior when slicing with datetime-like
  253:         dates = [datetime(2012, 1, 1, 12, 12, 12) + timedelta(days=i) for i in range(6)]
  254:         freq = [1, 2]
  255:         index = MultiIndex.from_product([dates, freq], names=["date", "frequency"])
  256: 
  257:         df = DataFrame(
  258:             np.arange(6 * 2 * 4, dtype="int64").reshape(-1, 4),
  259:             index=index,
  260:             columns=list("ABCD"),
  261:         )
  262: 
  263:         # multi-axis slicing
  264:         idx = pd.IndexSlice
  265:         expected = df.iloc[[0, 2, 4], [0, 1]]
  266:         result = df.loc[
  267:             (
  268:                 slice(
  269:                     Timestamp("2012-01-01 12:12:12"), Timestamp("2012-01-03 12:12:12")
  270:                 ),
  271:                 slice(1, 1),
  272:             ),
  273:             slice("A", "B"),
  274:         ]
  275:         tm.assert_frame_equal(result, expected)
  276: 
  277:         result = df.loc[
  278:             (
  279:                 idx[
  280:                     Timestamp("2012-01-01 12:12:12") : Timestamp("2012-01-03 12:12:12")
  281:                 ],
  282:                 idx[1:1],
  283:             ),
  284:             slice("A", "B"),
  285:         ]
  286:         tm.assert_frame_equal(result, expected)
  287: 
  288:         result = df.loc[
  289:             (
  290:                 slice(
  291:                     Timestamp("2012-01-01 12:12:12"), Timestamp("2012-01-03 12:12:12")
  292:                 ),
  293:                 1,
  294:             ),
  295:             slice("A", "B"),
  296:         ]
  297:         tm.assert_frame_equal(result, expected)
  298: 
  299:         # with strings
  300:         result = df.loc[
  301:             (slice("2012-01-01 12:12:12", "2012-01-03 12:12:12"), slice(1, 1)),
  302:             slice("A", "B"),
  303:         ]
  304:         tm.assert_frame_equal(result, expected)
  305: 
  306:         result = df.loc[
  307:             (idx["2012-01-01 12:12:12":"2012-01-03 12:12:12"], 1), idx["A", "B"]
  308:         ]
  309:         tm.assert_frame_equal(result, expected)
  310: 
  311:     def test_multiindex_slicers_edges(self):
  312:         # GH 8132
  313:         # various edge cases
  314:         df = DataFrame(
  315:             {
  316:                 "A": ["A0"] * 5 + ["A1"] * 5 + ["A2"] * 5,
  317:                 "B": ["B0", "B0", "B1", "B1", "B2"] * 3,
  318:                 "DATE": [
  319:                     "2013-06-11",
  320:                     "2013-07-02",
  321:                     "2013-07-09",
  322:                     "2013-07-30",
  323:                     "2013-08-06",
  324:                     "2013-06-11",
  325:                     "2013-07-02",
  326:                     "2013-07-09",
  327:                     "2013-07-30",
  328:                     "2013-08-06",
  329:                     "2013-09-03",
  330:                     "2013-10-01",
  331:                     "2013-07-09",
  332:                     "2013-08-06",
  333:                     "2013-09-03",
  334:                 ],
  335:                 "VALUES": [22, 35, 14, 9, 4, 40, 18, 4, 2, 5, 1, 2, 3, 4, 2],
  336:             }
  337:         )
  338: 
  339:         df["DATE"] = pd.to_datetime(df["DATE"])
  340:         df1 = df.set_index(["A", "B", "DATE"])
  341:         df1 = df1.sort_index()
  342: 
  343:         # A1 - Get all values under "A0" and "A1"
  344:         result = df1.loc[(slice("A1")), :]
  345:         expected = df1.iloc[0:10]
  346:         tm.assert_frame_equal(result, expected)
  347: 
  348:         # A2 - Get all values from the start to "A2"
  349:         result = df1.loc[(slice("A2")), :]
  350:         expected = df1
  351:         tm.assert_frame_equal(result, expected)
  352: 
  353:         # A3 - Get all values under "B1" or "B2"
  354:         result = df1.loc[(slice(None), slice("B1", "B2")), :]
  355:         expected = df1.iloc[[2, 3, 4, 7, 8, 9, 12, 13, 14]]
  356:         tm.assert_frame_equal(result, expected)
  357: 
  358:         # A4 - Get all values between 2013-07-02 and 2013-07-09
  359:         result = df1.loc[(slice(None), slice(None), slice("20130702", "20130709")), :]
  360:         expected = df1.iloc[[1, 2, 6, 7, 12]]
  361:         tm.assert_frame_equal(result, expected)
  362: 
  363:         # B1 - Get all values in B0 that are also under A0, A1 and A2
  364:         result = df1.loc[(slice("A2"), slice("B0")), :]
  365:         expected = df1.iloc[[0, 1, 5, 6, 10, 11]]
  366:         tm.assert_frame_equal(result, expected)
  367: 
  368:         # B2 - Get all values in B0, B1 and B2 (similar to what #2 is doing for
  369:         # the As)
  370:         result = df1.loc[(slice(None), slice("B2")), :]
  371:         expected = df1
  372:         tm.assert_frame_equal(result, expected)
  373: 
  374:         # B3 - Get all values from B1 to B2 and up to 2013-08-06
  375:         result = df1.loc[(slice(None), slice("B1", "B2"), slice("2013-08-06")), :]
  376:         expected = df1.iloc[[2, 3, 4, 7, 8, 9, 12, 13]]
  377:         tm.assert_frame_equal(result, expected)
  378: 
  379:         # B4 - Same as A4 but the start of the date slice is not a key.
  380:         #      shows indexing on a partial selection slice
  381:         result = df1.loc[(slice(None), slice(None), slice("20130701", "20130709")), :]
  382:         expected = df1.iloc[[1, 2, 6, 7, 12]]
  383:         tm.assert_frame_equal(result, expected)
  384: 
  385:     def test_per_axis_per_level_doc_examples(self):
  386:         # test index maker
  387:         idx = pd.IndexSlice
  388: 
  389:         # from indexing.rst / advanced
  390:         index = MultiIndex.from_product(
  391:             [_mklbl("A", 4), _mklbl("B", 2), _mklbl("C", 4), _mklbl("D", 2)]
  392:         )
  393:         columns = MultiIndex.from_tuples(
  394:             [("a", "foo"), ("a", "bar"), ("b", "foo"), ("b", "bah")],
  395:             names=["lvl0", "lvl1"],
  396:         )
  397:         df = DataFrame(
  398:             np.arange(len(index) * len(columns), dtype="int64").reshape(
  399:                 (len(index), len(columns))
  400:             ),
  401:             index=index,
  402:             columns=columns,
  403:         )
  404:         result = df.loc[(slice("A1", "A3"), slice(None), ["C1", "C3"]), :]
  405:         expected = df.loc[
  406:             [
  407:                 (
  408:                     a,
  409:                     b,
  410:                     c,
  411:                     d,
  412:                 )
  413:                 for a, b, c, d in df.index.values
  414:                 if a in ("A1", "A2", "A3") and c in ("C1", "C3")
  415:             ]
  416:         ]
  417:         tm.assert_frame_equal(result, expected)
  418:         result = df.loc[idx["A1":"A3", :, ["C1", "C3"]], :]
  419:         tm.assert_frame_equal(result, expected)
  420: 
  421:         result = df.loc[(slice(None), slice(None), ["C1", "C3"]), :]
  422:         expected = df.loc[
  423:             [
  424:                 (
  425:                     a,
  426:                     b,
  427:                     c,
  428:                     d,
  429:                 )
  430:                 for a, b, c, d in df.index.values
  431:                 if c in ("C1", "C3")
  432:             ]
  433:         ]
  434:         tm.assert_frame_equal(result, expected)
  435:         result = df.loc[idx[:, :, ["C1", "C3"]], :]
  436:         tm.assert_frame_equal(result, expected)
  437: 
  438:         # not sorted
  439:         msg = (
  440:             "MultiIndex slicing requires the index to be lexsorted: "
  441:             r"slicing on levels \[1\], lexsort depth 1"
  442:         )
  443:         with pytest.raises(UnsortedIndexError, match=msg):
  444:             df.loc["A1", ("a", slice("foo"))]
  445: 
  446:         # GH 16734: not sorted, but no real slicing
  447:         tm.assert_frame_equal(
  448:             df.loc["A1", (slice(None), "foo")], df.loc["A1"].iloc[:, [0, 2]]
  449:         )
  450: 
  451:         df = df.sort_index(axis=1)
  452: 
  453:         # slicing
  454:         df.loc["A1", (slice(None), "foo")]
  455:         df.loc[(slice(None), slice(None), ["C1", "C3"]), (slice(None), "foo")]
  456: 
  457:         # setitem
  458:         df.loc(axis=0)[:, :, ["C1", "C3"]] = -10
  459: 
  460:     def test_loc_axis_arguments(self):
  461:         index = MultiIndex.from_product(
  462:             [_mklbl("A", 4), _mklbl("B", 2), _mklbl("C", 4), _mklbl("D", 2)]
  463:         )
  464:         columns = MultiIndex.from_tuples(
  465:             [("a", "foo"), ("a", "bar"), ("b", "foo"), ("b", "bah")],
  466:             names=["lvl0", "lvl1"],
  467:         )
  468:         df = (
  469:             DataFrame(
  470:                 np.arange(len(index) * len(columns), dtype="int64").reshape(
  471:                     (len(index), len(columns))
  472:                 ),
  473:                 index=index,
  474:                 columns=columns,
  475:             )
  476:             .sort_index()
  477:             .sort_index(axis=1)
  478:         )
  479: 
  480:         # axis 0
  481:         result = df.loc(axis=0)["A1":"A3", :, ["C1", "C3"]]
  482:         expected = df.loc[
  483:             [
  484:                 (
  485:                     a,
  486:                     b,
  487:                     c,
  488:                     d,
  489:                 )
  490:                 for a, b, c, d in df.index.values
  491:                 if a in ("A1", "A2", "A3") and c in ("C1", "C3")
  492:             ]
  493:         ]
  494:         tm.assert_frame_equal(result, expected)
  495: 
  496:         result = df.loc(axis="index")[:, :, ["C1", "C3"]]
  497:         expected = df.loc[
  498:             [
  499:                 (
  500:                     a,
  501:                     b,
  502:                     c,
  503:                     d,
  504:                 )
  505:                 for a, b, c, d in df.index.values
  506:                 if c in ("C1", "C3")
  507:             ]
  508:         ]
  509:         tm.assert_frame_equal(result, expected)
  510: 
  511:         # axis 1
  512:         result = df.loc(axis=1)[:, "foo"]
  513:         expected = df.loc[:, (slice(None), "foo")]
  514:         tm.assert_frame_equal(result, expected)
  515: 
  516:         result = df.loc(axis="columns")[:, "foo"]
  517:         expected = df.loc[:, (slice(None), "foo")]
  518:         tm.assert_frame_equal(result, expected)
  519: 
  520:         # invalid axis
  521:         for i in [-1, 2, "foo"]:
  522:             msg = f"No axis named {i} for object type DataFrame"
  523:             with pytest.raises(ValueError, match=msg):
  524:                 df.loc(axis=i)[:, :, ["C1", "C3"]]
  525: 
  526:     def test_loc_axis_single_level_multi_col_indexing_multiindex_col_df(self):
  527:         # GH29519
  528:         df = DataFrame(
  529:             np.arange(27).reshape(3, 9),
  530:             columns=MultiIndex.from_product([["a1", "a2", "a3"], ["b1", "b2", "b3"]]),
  531:         )
  532:         result = df.loc(axis=1)["a1":"a2"]
  533:         expected = df.iloc[:, :-3]
  534: 
  535:         tm.assert_frame_equal(result, expected)
  536: 
  537:     def test_loc_axis_single_level_single_col_indexing_multiindex_col_df(self):
  538:         # GH29519
  539:         df = DataFrame(
  540:             np.arange(27).reshape(3, 9),
  541:             columns=MultiIndex.from_product([["a1", "a2", "a3"], ["b1", "b2", "b3"]]),
  542:         )
  543:         result = df.loc(axis=1)["a1"]
  544:         expected = df.iloc[:, :3]
  545:         expected.columns = ["b1", "b2", "b3"]
  546: 
  547:         tm.assert_frame_equal(result, expected)
  548: 
  549:     def test_loc_ax_single_level_indexer_simple_df(self):
  550:         # GH29519
  551:         # test single level indexing on single index column data frame
  552:         df = DataFrame(np.arange(9).reshape(3, 3), columns=["a", "b", "c"])
  553:         result = df.loc(axis=1)["a"]
  554:         expected = Series(np.array([0, 3, 6]), name="a")
  555:         tm.assert_series_equal(result, expected)
  556: 
  557:     def test_per_axis_per_level_setitem(self):
  558:         # test index maker
  559:         idx = pd.IndexSlice
  560: 
  561:         # test multi-index slicing with per axis and per index controls
  562:         index = MultiIndex.from_tuples(
  563:             [("A", 1), ("A", 2), ("A", 3), ("B", 1)], names=["one", "two"]
  564:         )
  565:         columns = MultiIndex.from_tuples(
  566:             [("a", "foo"), ("a", "bar"), ("b", "foo"), ("b", "bah")],
  567:             names=["lvl0", "lvl1"],
  568:         )
  569: 
  570:         df_orig = DataFrame(
  571:             np.arange(16, dtype="int64").reshape(4, 4), index=index, columns=columns
  572:         )
  573:         df_orig = df_orig.sort_index(axis=0).sort_index(axis=1)
  574: 
  575:         # identity
  576:         df = df_orig.copy()
  577:         df.loc[(slice(None), slice(None)), :] = 100
  578:         expected = df_orig.copy()
  579:         expected.iloc[:, :] = 100
  580:         tm.assert_frame_equal(df, expected)
  581: 
  582:         df = df_orig.copy()
  583:         df.loc(axis=0)[:, :] = 100
  584:         expected = df_orig.copy()
  585:         expected.iloc[:, :] = 100
  586:         tm.assert_frame_equal(df, expected)
  587: 
  588:         df = df_orig.copy()
  589:         df.loc[(slice(None), slice(None)), (slice(None), slice(None))] = 100
  590:         expected = df_orig.copy()
  591:         expected.iloc[:, :] = 100
  592:         tm.assert_frame_equal(df, expected)
  593: 
  594:         df = df_orig.copy()
  595:         df.loc[:, (slice(None), slice(None))] = 100
  596:         expected = df_orig.copy()
  597:         expected.iloc[:, :] = 100
  598:         tm.assert_frame_equal(df, expected)
  599: 
  600:         # index
  601:         df = df_orig.copy()
  602:         df.loc[(slice(None), [1]), :] = 100
  603:         expected = df_orig.copy()
  604:         expected.iloc[[0, 3]] = 100
  605:         tm.assert_frame_equal(df, expected)
  606: 
  607:         df = df_orig.copy()
  608:         df.loc[(slice(None), 1), :] = 100
  609:         expected = df_orig.copy()
  610:         expected.iloc[[0, 3]] = 100
  611:         tm.assert_frame_equal(df, expected)
  612: 
  613:         df = df_orig.copy()
  614:         df.loc(axis=0)[:, 1] = 100
  615:         expected = df_orig.copy()
  616:         expected.iloc[[0, 3]] = 100
  617:         tm.assert_frame_equal(df, expected)
  618: 
  619:         # columns
  620:         df = df_orig.copy()
  621:         df.loc[:, (slice(None), ["foo"])] = 100
  622:         expected = df_orig.copy()
  623:         expected.iloc[:, [1, 3]] = 100
  624:         tm.assert_frame_equal(df, expected)
  625: 
  626:         # both
  627:         df = df_orig.copy()
  628:         df.loc[(slice(None), 1), (slice(None), ["foo"])] = 100
  629:         expected = df_orig.copy()
  630:         expected.iloc[[0, 3], [1, 3]] = 100
  631:         tm.assert_frame_equal(df, expected)
  632: 
  633:         df = df_orig.copy()
  634:         df.loc[idx[:, 1], idx[:, ["foo"]]] = 100
  635:         expected = df_orig.copy()
  636:         expected.iloc[[0, 3], [1, 3]] = 100
  637:         tm.assert_frame_equal(df, expected)
  638: 
  639:         df = df_orig.copy()
  640:         df.loc["A", "a"] = 100
  641:         expected = df_orig.copy()
  642:         expected.iloc[0:3, 0:2] = 100
  643:         tm.assert_frame_equal(df, expected)
  644: 
  645:         # setting with a list-like
  646:         df = df_orig.copy()
  647:         df.loc[(slice(None), 1), (slice(None), ["foo"])] = np.array(
  648:             [[100, 100], [100, 100]], dtype="int64"
  649:         )
  650:         expected = df_orig.copy()
  651:         expected.iloc[[0, 3], [1, 3]] = 100
  652:         tm.assert_frame_equal(df, expected)
  653: 
  654:         # not enough values
  655:         df = df_orig.copy()
  656: 
  657:         msg = "setting an array element with a sequence."
  658:         with pytest.raises(ValueError, match=msg):
  659:             df.loc[(slice(None), 1), (slice(None), ["foo"])] = np.array(
  660:                 [[100], [100, 100]], dtype="int64"
  661:             )
  662: 
  663:         msg = "Must have equal len keys and value when setting with an iterable"
  664:         with pytest.raises(ValueError, match=msg):
  665:             df.loc[(slice(None), 1), (slice(None), ["foo"])] = np.array(
  666:                 [100, 100, 100, 100], dtype="int64"
  667:             )
  668: 
  669:         # with an alignable rhs
  670:         df = df_orig.copy()
  671:         df.loc[(slice(None), 1), (slice(None), ["foo"])] = (
  672:             df.loc[(slice(None), 1), (slice(None), ["foo"])] * 5
  673:         )
  674:         expected = df_orig.copy()
  675:         expected.iloc[[0, 3], [1, 3]] = expected.iloc[[0, 3], [1, 3]] * 5
  676:         tm.assert_frame_equal(df, expected)
  677: 
  678:         df = df_orig.copy()
  679:         df.loc[(slice(None), 1), (slice(None), ["foo"])] *= df.loc[
  680:             (slice(None), 1), (slice(None), ["foo"])
  681:         ]
  682:         expected = df_orig.copy()
  683:         expected.iloc[[0, 3], [1, 3]] *= expected.iloc[[0, 3], [1, 3]]
  684:         tm.assert_frame_equal(df, expected)
  685: 
  686:         rhs = df_orig.loc[(slice(None), 1), (slice(None), ["foo"])].copy()
  687:         rhs.loc[:, ("c", "bah")] = 10
  688:         df = df_orig.copy()
  689:         df.loc[(slice(None), 1), (slice(None), ["foo"])] *= rhs
  690:         expected = df_orig.copy()
  691:         expected.iloc[[0, 3], [1, 3]] *= expected.iloc[[0, 3], [1, 3]]
  692:         tm.assert_frame_equal(df, expected)
  693: 
  694:     def test_multiindex_label_slicing_with_negative_step(self):
  695:         ser = Series(
  696:             np.arange(20), MultiIndex.from_product([list("abcde"), np.arange(4)])
  697:         )
  698:         SLC = pd.IndexSlice
  699: 
  700:         tm.assert_indexing_slices_equivalent(ser, SLC[::-1], SLC[::-1])
  701: 
  702:         tm.assert_indexing_slices_equivalent(ser, SLC["d"::-1], SLC[15::-1])
  703:         tm.assert_indexing_slices_equivalent(ser, SLC[("d",)::-1], SLC[15::-1])
  704: 
  705:         tm.assert_indexing_slices_equivalent(ser, SLC[:"d":-1], SLC[:11:-1])
  706:         tm.assert_indexing_slices_equivalent(ser, SLC[:("d",):-1], SLC[:11:-1])
  707: 
  708:         tm.assert_indexing_slices_equivalent(ser, SLC["d":"b":-1], SLC[15:3:-1])
  709:         tm.assert_indexing_slices_equivalent(ser, SLC[("d",):"b":-1], SLC[15:3:-1])
  710:         tm.assert_indexing_slices_equivalent(ser, SLC["d":("b",):-1], SLC[15:3:-1])
  711:         tm.assert_indexing_slices_equivalent(ser, SLC[("d",):("b",):-1], SLC[15:3:-1])
  712:         tm.assert_indexing_slices_equivalent(ser, SLC["b":"d":-1], SLC[:0])
  713: 
  714:         tm.assert_indexing_slices_equivalent(ser, SLC[("c", 2)::-1], SLC[10::-1])
  715:         tm.assert_indexing_slices_equivalent(ser, SLC[:("c", 2):-1], SLC[:9:-1])
  716:         tm.assert_indexing_slices_equivalent(
  717:             ser, SLC[("e", 0):("c", 2):-1], SLC[16:9:-1]
  718:         )
  719: 
  720:     def test_multiindex_slice_first_level(self):
  721:         # GH 12697
  722:         freq = ["a", "b", "c", "d"]
  723:         idx = MultiIndex.from_product([freq, range(500)])
  724:         df = DataFrame(list(range(2000)), index=idx, columns=["Test"])
  725:         df_slice = df.loc[pd.IndexSlice[:, 30:70], :]
  726:         result = df_slice.loc["a"]
  727:         expected = DataFrame(list(range(30, 71)), columns=["Test"], index=range(30, 71))
  728:         tm.assert_frame_equal(result, expected)
  729:         result = df_slice.loc["d"]
  730:         expected = DataFrame(
  731:             list(range(1530, 1571)), columns=["Test"], index=range(30, 71)
  732:         )
  733:         tm.assert_frame_equal(result, expected)
  734: 
  735:     def test_int_series_slicing(self, multiindex_year_month_day_dataframe_random_data):
  736:         ymd = multiindex_year_month_day_dataframe_random_data
  737:         s = ymd["A"]
  738:         result = s[5:]
  739:         expected = s.reindex(s.index[5:])
  740:         tm.assert_series_equal(result, expected)
  741: 
  742:         s = ymd["A"].copy()
  743:         exp = ymd["A"].copy()
  744:         s[5:] = 0
  745:         exp.iloc[5:] = 0
  746:         tm.assert_numpy_array_equal(s.values, exp.values)
  747: 
  748:         result = ymd[5:]
  749:         expected = ymd.reindex(s.index[5:])
  750:         tm.assert_frame_equal(result, expected)
  751: 
  752:     @pytest.mark.parametrize(
  753:         "dtype, loc, iloc",
  754:         [
  755:             # dtype = int, step = -1
  756:             ("int", slice(None, None, -1), slice(None, None, -1)),
  757:             ("int", slice(3, None, -1), slice(3, None, -1)),
  758:             ("int", slice(None, 1, -1), slice(None, 0, -1)),
  759:             ("int", slice(3, 1, -1), slice(3, 0, -1)),
  760:             # dtype = int, step = -2
  761:             ("int", slice(None, None, -2), slice(None, None, -2)),
  762:             ("int", slice(3, None, -2), slice(3, None, -2)),
  763:             ("int", slice(None, 1, -2), slice(None, 0, -2)),
  764:             ("int", slice(3, 1, -2), slice(3, 0, -2)),
  765:             # dtype = str, step = -1
  766:             ("str", slice(None, None, -1), slice(None, None, -1)),
  767:             ("str", slice("d", None, -1), slice(3, None, -1)),
  768:             ("str", slice(None, "b", -1), slice(None, 0, -1)),
  769:             ("str", slice("d", "b", -1), slice(3, 0, -1)),
  770:             # dtype = str, step = -2
  771:             ("str", slice(None, None, -2), slice(None, None, -2)),
  772:             ("str", slice("d", None, -2), slice(3, None, -2)),
  773:             ("str", slice(None, "b", -2), slice(None, 0, -2)),
  774:             ("str", slice("d", "b", -2), slice(3, 0, -2)),
  775:         ],
  776:     )
  777:     def test_loc_slice_negative_stepsize(self, dtype, loc, iloc):
  778:         # GH#38071
  779:         labels = {
  780:             "str": list("abcde"),
  781:             "int": range(5),
  782:         }[dtype]
  783: 
  784:         mi = MultiIndex.from_arrays([labels] * 2)
  785:         df = DataFrame(1.0, index=mi, columns=["A"])
  786: 
  787:         SLC = pd.IndexSlice
  788: 
  789:         expected = df.iloc[iloc, :]
  790:         result_get_loc = df.loc[SLC[loc], :]
  791:         result_get_locs_level_0 = df.loc[SLC[loc, :], :]
  792:         result_get_locs_level_1 = df.loc[SLC[:, loc], :]
  793: 
  794:         tm.assert_frame_equal(result_get_loc, expected)
  795:         tm.assert_frame_equal(result_get_locs_level_0, expected)
  796:         tm.assert_frame_equal(result_get_locs_level_1, expected)
