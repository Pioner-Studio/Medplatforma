    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import (
    5:     IndexingError,
    6:     PerformanceWarning,
    7: )
    8: 
    9: import pandas as pd
   10: from pandas import (
   11:     DataFrame,
   12:     Index,
   13:     MultiIndex,
   14:     Series,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: @pytest.fixture
   20: def single_level_multiindex():
   21:     """single level MultiIndex"""
   22:     return MultiIndex(
   23:         levels=[["foo", "bar", "baz", "qux"]], codes=[[0, 1, 2, 3]], names=["first"]
   24:     )
   25: 
   26: 
   27: @pytest.fixture
   28: def frame_random_data_integer_multi_index():
   29:     levels = [[0, 1], [0, 1, 2]]
   30:     codes = [[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]]
   31:     index = MultiIndex(levels=levels, codes=codes)
   32:     return DataFrame(np.random.default_rng(2).standard_normal((6, 2)), index=index)
   33: 
   34: 
   35: class TestMultiIndexLoc:
   36:     def test_loc_setitem_frame_with_multiindex(self, multiindex_dataframe_random_data):
   37:         frame = multiindex_dataframe_random_data
   38:         frame.loc[("bar", "two"), "B"] = 5
   39:         assert frame.loc[("bar", "two"), "B"] == 5
   40: 
   41:         # with integer labels
   42:         df = frame.copy()
   43:         df.columns = list(range(3))
   44:         df.loc[("bar", "two"), 1] = 7
   45:         assert df.loc[("bar", "two"), 1] == 7
   46: 
   47:     def test_loc_getitem_general(self, any_real_numpy_dtype):
   48:         # GH#2817
   49:         dtype = any_real_numpy_dtype
   50:         data = {
   51:             "amount": {0: 700, 1: 600, 2: 222, 3: 333, 4: 444},
   52:             "col": {0: 3.5, 1: 3.5, 2: 4.0, 3: 4.0, 4: 4.0},
   53:             "num": {0: 12, 1: 11, 2: 12, 3: 12, 4: 12},
   54:         }
   55:         df = DataFrame(data)
   56:         df = df.astype({"col": dtype, "num": dtype})
   57:         df = df.set_index(keys=["col", "num"])
   58:         key = 4.0, 12
   59: 
   60:         # emits a PerformanceWarning, ok
   61:         with tm.assert_produces_warning(PerformanceWarning):
   62:             tm.assert_frame_equal(df.loc[key], df.iloc[2:])
   63: 
   64:         # this is ok
   65:         return_value = df.sort_index(inplace=True)
   66:         assert return_value is None
   67:         res = df.loc[key]
   68: 
   69:         # col has float dtype, result should be float64 Index
   70:         col_arr = np.array([4.0] * 3, dtype=dtype)
   71:         year_arr = np.array([12] * 3, dtype=dtype)
   72:         index = MultiIndex.from_arrays([col_arr, year_arr], names=["col", "num"])
   73:         expected = DataFrame({"amount": [222, 333, 444]}, index=index)
   74:         tm.assert_frame_equal(res, expected)
   75: 
   76:     def test_loc_getitem_multiindex_missing_label_raises(self):
   77:         # GH#21593
   78:         df = DataFrame(
   79:             np.random.default_rng(2).standard_normal((3, 3)),
   80:             columns=[[2, 2, 4], [6, 8, 10]],
   81:             index=[[4, 4, 8], [8, 10, 12]],
   82:         )
   83: 
   84:         with pytest.raises(KeyError, match=r"^2$"):
   85:             df.loc[2]
   86: 
   87:     def test_loc_getitem_list_of_tuples_with_multiindex(
   88:         self, multiindex_year_month_day_dataframe_random_data
   89:     ):
   90:         ser = multiindex_year_month_day_dataframe_random_data["A"]
   91:         expected = ser.reindex(ser.index[49:51])
   92:         result = ser.loc[[(2000, 3, 10), (2000, 3, 13)]]
   93:         tm.assert_series_equal(result, expected)
   94: 
   95:     def test_loc_getitem_series(self):
   96:         # GH14730
   97:         # passing a series as a key with a MultiIndex
   98:         index = MultiIndex.from_product([[1, 2, 3], ["A", "B", "C"]])
   99:         x = Series(index=index, data=range(9), dtype=np.float64)
  100:         y = Series([1, 3])
  101:         expected = Series(
  102:             data=[0, 1, 2, 6, 7, 8],
  103:             index=MultiIndex.from_product([[1, 3], ["A", "B", "C"]]),
  104:             dtype=np.float64,
  105:         )
  106:         result = x.loc[y]
  107:         tm.assert_series_equal(result, expected)
  108: 
  109:         result = x.loc[[1, 3]]
  110:         tm.assert_series_equal(result, expected)
  111: 
  112:         # GH15424
  113:         y1 = Series([1, 3], index=[1, 2])
  114:         result = x.loc[y1]
  115:         tm.assert_series_equal(result, expected)
  116: 
  117:         empty = Series(data=[], dtype=np.float64)
  118:         expected = Series(
  119:             [],
  120:             index=MultiIndex(levels=index.levels, codes=[[], []], dtype=np.float64),
  121:             dtype=np.float64,
  122:         )
  123:         result = x.loc[empty]
  124:         tm.assert_series_equal(result, expected)
  125: 
  126:     def test_loc_getitem_array(self):
  127:         # GH15434
  128:         # passing an array as a key with a MultiIndex
  129:         index = MultiIndex.from_product([[1, 2, 3], ["A", "B", "C"]])
  130:         x = Series(index=index, data=range(9), dtype=np.float64)
  131:         y = np.array([1, 3])
  132:         expected = Series(
  133:             data=[0, 1, 2, 6, 7, 8],
  134:             index=MultiIndex.from_product([[1, 3], ["A", "B", "C"]]),
  135:             dtype=np.float64,
  136:         )
  137:         result = x.loc[y]
  138:         tm.assert_series_equal(result, expected)
  139: 
  140:         # empty array:
  141:         empty = np.array([])
  142:         expected = Series(
  143:             [],
  144:             index=MultiIndex(levels=index.levels, codes=[[], []], dtype=np.float64),
  145:             dtype="float64",
  146:         )
  147:         result = x.loc[empty]
  148:         tm.assert_series_equal(result, expected)
  149: 
  150:         # 0-dim array (scalar):
  151:         scalar = np.int64(1)
  152:         expected = Series(data=[0, 1, 2], index=["A", "B", "C"], dtype=np.float64)
  153:         result = x.loc[scalar]
  154:         tm.assert_series_equal(result, expected)
  155: 
  156:     def test_loc_multiindex_labels(self):
  157:         df = DataFrame(
  158:             np.random.default_rng(2).standard_normal((3, 3)),
  159:             columns=[["i", "i", "j"], ["A", "A", "B"]],
  160:             index=[["i", "i", "j"], ["X", "X", "Y"]],
  161:         )
  162: 
  163:         # the first 2 rows
  164:         expected = df.iloc[[0, 1]].droplevel(0)
  165:         result = df.loc["i"]
  166:         tm.assert_frame_equal(result, expected)
  167: 
  168:         # 2nd (last) column
  169:         expected = df.iloc[:, [2]].droplevel(0, axis=1)
  170:         result = df.loc[:, "j"]
  171:         tm.assert_frame_equal(result, expected)
  172: 
  173:         # bottom right corner
  174:         expected = df.iloc[[2], [2]].droplevel(0).droplevel(0, axis=1)
  175:         result = df.loc["j"].loc[:, "j"]
  176:         tm.assert_frame_equal(result, expected)
  177: 
  178:         # with a tuple
  179:         expected = df.iloc[[0, 1]]
  180:         result = df.loc[("i", "X")]
  181:         tm.assert_frame_equal(result, expected)
  182: 
  183:     def test_loc_multiindex_ints(self):
  184:         df = DataFrame(
  185:             np.random.default_rng(2).standard_normal((3, 3)),
  186:             columns=[[2, 2, 4], [6, 8, 10]],
  187:             index=[[4, 4, 8], [8, 10, 12]],
  188:         )
  189:         expected = df.iloc[[0, 1]].droplevel(0)
  190:         result = df.loc[4]
  191:         tm.assert_frame_equal(result, expected)
  192: 
  193:     def test_loc_multiindex_missing_label_raises(self):
  194:         df = DataFrame(
  195:             np.random.default_rng(2).standard_normal((3, 3)),
  196:             columns=[[2, 2, 4], [6, 8, 10]],
  197:             index=[[4, 4, 8], [8, 10, 12]],
  198:         )
  199: 
  200:         with pytest.raises(KeyError, match=r"^2$"):
  201:             df.loc[2]
  202: 
  203:     @pytest.mark.parametrize("key, pos", [([2, 4], [0, 1]), ([2], []), ([2, 3], [])])
  204:     def test_loc_multiindex_list_missing_label(self, key, pos):
  205:         # GH 27148 - lists with missing labels _do_ raise
  206:         df = DataFrame(
  207:             np.random.default_rng(2).standard_normal((3, 3)),
  208:             columns=[[2, 2, 4], [6, 8, 10]],
  209:             index=[[4, 4, 8], [8, 10, 12]],
  210:         )
  211: 
  212:         with pytest.raises(KeyError, match="not in index"):
  213:             df.loc[key]
  214: 
  215:     def test_loc_multiindex_too_many_dims_raises(self):
  216:         # GH 14885
  217:         s = Series(
  218:             range(8),
  219:             index=MultiIndex.from_product([["a", "b"], ["c", "d"], ["e", "f"]]),
  220:         )
  221: 
  222:         with pytest.raises(KeyError, match=r"^\('a', 'b'\)$"):
  223:             s.loc["a", "b"]
  224:         with pytest.raises(KeyError, match=r"^\('a', 'd', 'g'\)$"):
  225:             s.loc["a", "d", "g"]
  226:         with pytest.raises(IndexingError, match="Too many indexers"):
  227:             s.loc["a", "d", "g", "j"]
  228: 
  229:     def test_loc_multiindex_indexer_none(self):
  230:         # GH6788
  231:         # multi-index indexer is None (meaning take all)
  232:         attributes = ["Attribute" + str(i) for i in range(1)]
  233:         attribute_values = ["Value" + str(i) for i in range(5)]
  234: 
  235:         index = MultiIndex.from_product([attributes, attribute_values])
  236:         df = 0.1 * np.random.default_rng(2).standard_normal((10, 1 * 5)) + 0.5
  237:         df = DataFrame(df, columns=index)
  238:         result = df[attributes]
  239:         tm.assert_frame_equal(result, df)
  240: 
  241:         # GH 7349
  242:         # loc with a multi-index seems to be doing fallback
  243:         df = DataFrame(
  244:             np.arange(12).reshape(-1, 1),
  245:             index=MultiIndex.from_product([[1, 2, 3, 4], [1, 2, 3]]),
  246:         )
  247: 
  248:         expected = df.loc[([1, 2],), :]
  249:         result = df.loc[[1, 2]]
  250:         tm.assert_frame_equal(result, expected)
  251: 
  252:     def test_loc_multiindex_incomplete(self):
  253:         # GH 7399
  254:         # incomplete indexers
  255:         s = Series(
  256:             np.arange(15, dtype="int64"),
  257:             MultiIndex.from_product([range(5), ["a", "b", "c"]]),
  258:         )
  259:         expected = s.loc[:, "a":"c"]
  260: 
  261:         result = s.loc[0:4, "a":"c"]
  262:         tm.assert_series_equal(result, expected)
  263: 
  264:         result = s.loc[:4, "a":"c"]
  265:         tm.assert_series_equal(result, expected)
  266: 
  267:         result = s.loc[0:, "a":"c"]
  268:         tm.assert_series_equal(result, expected)
  269: 
  270:         # GH 7400
  271:         # multiindexer getitem with list of indexers skips wrong element
  272:         s = Series(
  273:             np.arange(15, dtype="int64"),
  274:             MultiIndex.from_product([range(5), ["a", "b", "c"]]),
  275:         )
  276:         expected = s.iloc[[6, 7, 8, 12, 13, 14]]
  277:         result = s.loc[2:4:2, "a":"c"]
  278:         tm.assert_series_equal(result, expected)
  279: 
  280:     def test_get_loc_single_level(self, single_level_multiindex):
  281:         single_level = single_level_multiindex
  282:         s = Series(
  283:             np.random.default_rng(2).standard_normal(len(single_level)),
  284:             index=single_level,
  285:         )
  286:         for k in single_level.values:
  287:             s[k]
  288: 
  289:     def test_loc_getitem_int_slice(self):
  290:         # GH 3053
  291:         # loc should treat integer slices like label slices
  292: 
  293:         index = MultiIndex.from_product([[6, 7, 8], ["a", "b"]])
  294:         df = DataFrame(np.random.default_rng(2).standard_normal((6, 6)), index, index)
  295:         result = df.loc[6:8, :]
  296:         expected = df
  297:         tm.assert_frame_equal(result, expected)
  298: 
  299:         index = MultiIndex.from_product([[10, 20, 30], ["a", "b"]])
  300:         df = DataFrame(np.random.default_rng(2).standard_normal((6, 6)), index, index)
  301:         result = df.loc[20:30, :]
  302:         expected = df.iloc[2:]
  303:         tm.assert_frame_equal(result, expected)
  304: 
  305:         # doc examples
  306:         result = df.loc[10, :]
  307:         expected = df.iloc[0:2]
  308:         expected.index = ["a", "b"]
  309:         tm.assert_frame_equal(result, expected)
  310: 
  311:         result = df.loc[:, 10]
  312:         expected = df[10]
  313:         tm.assert_frame_equal(result, expected)
  314: 
  315:     @pytest.mark.parametrize(
  316:         "indexer_type_1", (list, tuple, set, slice, np.ndarray, Series, Index)
  317:     )
  318:     @pytest.mark.parametrize(
  319:         "indexer_type_2", (list, tuple, set, slice, np.ndarray, Series, Index)
  320:     )
  321:     def test_loc_getitem_nested_indexer(self, indexer_type_1, indexer_type_2):
  322:         # GH #19686
  323:         # .loc should work with nested indexers which can be
  324:         # any list-like objects (see `is_list_like` (`pandas.api.types`)) or slices
  325: 
  326:         def convert_nested_indexer(indexer_type, keys):
  327:             if indexer_type == np.ndarray:
  328:                 return np.array(keys)
  329:             if indexer_type == slice:
  330:                 return slice(*keys)
  331:             return indexer_type(keys)
  332: 
  333:         a = [10, 20, 30]
  334:         b = [1, 2, 3]
  335:         index = MultiIndex.from_product([a, b])
  336:         df = DataFrame(
  337:             np.arange(len(index), dtype="int64"), index=index, columns=["Data"]
  338:         )
  339: 
  340:         keys = ([10, 20], [2, 3])
  341:         types = (indexer_type_1, indexer_type_2)
  342: 
  343:         # check indexers with all the combinations of nested objects
  344:         # of all the valid types
  345:         indexer = tuple(
  346:             convert_nested_indexer(indexer_type, k)
  347:             for indexer_type, k in zip(types, keys)
  348:         )
  349:         if indexer_type_1 is set or indexer_type_2 is set:
  350:             with pytest.raises(TypeError, match="as an indexer is not supported"):
  351:                 df.loc[indexer, "Data"]
  352: 
  353:             return
  354:         else:
  355:             result = df.loc[indexer, "Data"]
  356:         expected = Series(
  357:             [1, 2, 4, 5], name="Data", index=MultiIndex.from_product(keys)
  358:         )
  359: 
  360:         tm.assert_series_equal(result, expected)
  361: 
  362:     def test_multiindex_loc_one_dimensional_tuple(self, frame_or_series):
  363:         # GH#37711
  364:         mi = MultiIndex.from_tuples([("a", "A"), ("b", "A")])
  365:         obj = frame_or_series([1, 2], index=mi)
  366:         obj.loc[("a",)] = 0
  367:         expected = frame_or_series([0, 2], index=mi)
  368:         tm.assert_equal(obj, expected)
  369: 
  370:     @pytest.mark.parametrize("indexer", [("a",), ("a")])
  371:     def test_multiindex_one_dimensional_tuple_columns(self, indexer):
  372:         # GH#37711
  373:         mi = MultiIndex.from_tuples([("a", "A"), ("b", "A")])
  374:         obj = DataFrame([1, 2], index=mi)
  375:         obj.loc[indexer, :] = 0
  376:         expected = DataFrame([0, 2], index=mi)
  377:         tm.assert_frame_equal(obj, expected)
  378: 
  379:     @pytest.mark.parametrize(
  380:         "indexer, exp_value", [(slice(None), 1.0), ((1, 2), np.nan)]
  381:     )
  382:     def test_multiindex_setitem_columns_enlarging(self, indexer, exp_value):
  383:         # GH#39147
  384:         mi = MultiIndex.from_tuples([(1, 2), (3, 4)])
  385:         df = DataFrame([[1, 2], [3, 4]], index=mi, columns=["a", "b"])
  386:         df.loc[indexer, ["c", "d"]] = 1.0
  387:         expected = DataFrame(
  388:             [[1, 2, 1.0, 1.0], [3, 4, exp_value, exp_value]],
  389:             index=mi,
  390:             columns=["a", "b", "c", "d"],
  391:         )
  392:         tm.assert_frame_equal(df, expected)
  393: 
  394:     def test_sorted_multiindex_after_union(self):
  395:         # GH#44752
  396:         midx = MultiIndex.from_product(
  397:             [pd.date_range("20110101", periods=2), Index(["a", "b"])]
  398:         )
  399:         ser1 = Series(1, index=midx)
  400:         ser2 = Series(1, index=midx[:2])
  401:         df = pd.concat([ser1, ser2], axis=1)
  402:         expected = df.copy()
  403:         result = df.loc["2011-01-01":"2011-01-02"]
  404:         tm.assert_frame_equal(result, expected)
  405: 
  406:         df = DataFrame({0: ser1, 1: ser2})
  407:         result = df.loc["2011-01-01":"2011-01-02"]
  408:         tm.assert_frame_equal(result, expected)
  409: 
  410:         df = pd.concat([ser1, ser2.reindex(ser1.index)], axis=1)
  411:         result = df.loc["2011-01-01":"2011-01-02"]
  412:         tm.assert_frame_equal(result, expected)
  413: 
  414:     def test_loc_no_second_level_index(self):
  415:         # GH#43599
  416:         df = DataFrame(
  417:             index=MultiIndex.from_product([list("ab"), list("cd"), list("e")]),
  418:             columns=["Val"],
  419:         )
  420:         res = df.loc[np.s_[:, "c", :]]
  421:         expected = DataFrame(
  422:             index=MultiIndex.from_product([list("ab"), list("e")]), columns=["Val"]
  423:         )
  424:         tm.assert_frame_equal(res, expected)
  425: 
  426:     def test_loc_multi_index_key_error(self):
  427:         # GH 51892
  428:         df = DataFrame(
  429:             {
  430:                 (1, 2): ["a", "b", "c"],
  431:                 (1, 3): ["d", "e", "f"],
  432:                 (2, 2): ["g", "h", "i"],
  433:                 (2, 4): ["j", "k", "l"],
  434:             }
  435:         )
  436:         with pytest.raises(KeyError, match=r"(1, 4)"):
  437:             df.loc[0, (1, 4)]
  438: 
  439: 
  440: @pytest.mark.parametrize(
  441:     "indexer, pos",
  442:     [
  443:         ([], []),  # empty ok
  444:         (["A"], slice(3)),
  445:         (["A", "D"], []),  # "D" isn't present -> raise
  446:         (["D", "E"], []),  # no values found -> raise
  447:         (["D"], []),  # same, with single item list: GH 27148
  448:         (pd.IndexSlice[:, ["foo"]], slice(2, None, 3)),
  449:         (pd.IndexSlice[:, ["foo", "bah"]], slice(2, None, 3)),
  450:     ],
  451: )
  452: def test_loc_getitem_duplicates_multiindex_missing_indexers(indexer, pos):
  453:     # GH 7866
  454:     # multi-index slicing with missing indexers
  455:     idx = MultiIndex.from_product(
  456:         [["A", "B", "C"], ["foo", "bar", "baz"]], names=["one", "two"]
  457:     )
  458:     ser = Series(np.arange(9, dtype="int64"), index=idx).sort_index()
  459:     expected = ser.iloc[pos]
  460: 
  461:     if expected.size == 0 and indexer != []:
  462:         with pytest.raises(KeyError, match=str(indexer)):
  463:             ser.loc[indexer]
  464:     elif indexer == (slice(None), ["foo", "bah"]):
  465:         # "bah" is not in idx.levels[1], raising KeyError enforced in 2.0
  466:         with pytest.raises(KeyError, match="'bah'"):
  467:             ser.loc[indexer]
  468:     else:
  469:         result = ser.loc[indexer]
  470:         tm.assert_series_equal(result, expected)
  471: 
  472: 
  473: @pytest.mark.parametrize("columns_indexer", [([], slice(None)), (["foo"], [])])
  474: def test_loc_getitem_duplicates_multiindex_empty_indexer(columns_indexer):
  475:     # GH 8737
  476:     # empty indexer
  477:     multi_index = MultiIndex.from_product((["foo", "bar", "baz"], ["alpha", "beta"]))
  478:     df = DataFrame(
  479:         np.random.default_rng(2).standard_normal((5, 6)),
  480:         index=range(5),
  481:         columns=multi_index,
  482:     )
  483:     df = df.sort_index(level=0, axis=1)
  484: 
  485:     expected = DataFrame(index=range(5), columns=multi_index.reindex([])[0])
  486:     result = df.loc[:, columns_indexer]
  487:     tm.assert_frame_equal(result, expected)
  488: 
  489: 
  490: def test_loc_getitem_duplicates_multiindex_non_scalar_type_object():
  491:     # regression from < 0.14.0
  492:     # GH 7914
  493:     df = DataFrame(
  494:         [[np.mean, np.median], ["mean", "median"]],
  495:         columns=MultiIndex.from_tuples([("functs", "mean"), ("functs", "median")]),
  496:         index=["function", "name"],
  497:     )
  498:     result = df.loc["function", ("functs", "mean")]
  499:     expected = np.mean
  500:     assert result == expected
  501: 
  502: 
  503: def test_loc_getitem_tuple_plus_slice():
  504:     # GH 671
  505:     df = DataFrame(
  506:         {
  507:             "a": np.arange(10),
  508:             "b": np.arange(10),
  509:             "c": np.random.default_rng(2).standard_normal(10),
  510:             "d": np.random.default_rng(2).standard_normal(10),
  511:         }
  512:     ).set_index(["a", "b"])
  513:     expected = df.loc[0, 0]
  514:     result = df.loc[(0, 0), :]
  515:     tm.assert_series_equal(result, expected)
  516: 
  517: 
  518: def test_loc_getitem_int(frame_random_data_integer_multi_index):
  519:     df = frame_random_data_integer_multi_index
  520:     result = df.loc[1]
  521:     expected = df[-3:]
  522:     expected.index = expected.index.droplevel(0)
  523:     tm.assert_frame_equal(result, expected)
  524: 
  525: 
  526: def test_loc_getitem_int_raises_exception(frame_random_data_integer_multi_index):
  527:     df = frame_random_data_integer_multi_index
  528:     with pytest.raises(KeyError, match=r"^3$"):
  529:         df.loc[3]
  530: 
  531: 
  532: def test_loc_getitem_lowerdim_corner(multiindex_dataframe_random_data):
  533:     df = multiindex_dataframe_random_data
  534: 
  535:     # test setup - check key not in dataframe
  536:     with pytest.raises(KeyError, match=r"^\('bar', 'three'\)$"):
  537:         df.loc[("bar", "three"), "B"]
  538: 
  539:     # in theory should be inserting in a sorted space????
  540:     df.loc[("bar", "three"), "B"] = 0
  541:     expected = 0
  542:     result = df.sort_index().loc[("bar", "three"), "B"]
  543:     assert result == expected
  544: 
  545: 
  546: def test_loc_setitem_single_column_slice():
  547:     # case from https://github.com/pandas-dev/pandas/issues/27841
  548:     df = DataFrame(
  549:         "string",
  550:         index=list("abcd"),
  551:         columns=MultiIndex.from_product([["Main"], ("another", "one")]),
  552:     )
  553:     df["labels"] = "a"
  554:     df.loc[:, "labels"] = df.index
  555:     tm.assert_numpy_array_equal(np.asarray(df["labels"]), np.asarray(df.index))
  556: 
  557:     # test with non-object block
  558:     df = DataFrame(
  559:         np.nan,
  560:         index=range(4),
  561:         columns=MultiIndex.from_tuples([("A", "1"), ("A", "2"), ("B", "1")]),
  562:     )
  563:     expected = df.copy()
  564:     df.loc[:, "B"] = np.arange(4)
  565:     expected.iloc[:, 2] = np.arange(4)
  566:     tm.assert_frame_equal(df, expected)
  567: 
  568: 
  569: def test_loc_nan_multiindex(using_infer_string):
  570:     # GH 5286
  571:     tups = [
  572:         ("Good Things", "C", np.nan),
  573:         ("Good Things", "R", np.nan),
  574:         ("Bad Things", "C", np.nan),
  575:         ("Bad Things", "T", np.nan),
  576:         ("Okay Things", "N", "B"),
  577:         ("Okay Things", "N", "D"),
  578:         ("Okay Things", "B", np.nan),
  579:         ("Okay Things", "D", np.nan),
  580:     ]
  581:     df = DataFrame(
  582:         np.ones((8, 4)),
  583:         columns=Index(["d1", "d2", "d3", "d4"]),
  584:         index=MultiIndex.from_tuples(tups, names=["u1", "u2", "u3"]),
  585:     )
  586:     result = df.loc["Good Things"].loc["C"]
  587:     expected = DataFrame(
  588:         np.ones((1, 4)),
  589:         index=Index(
  590:             [np.nan],
  591:             dtype="object" if not using_infer_string else "string[pyarrow_numpy]",
  592:             name="u3",
  593:         ),
  594:         columns=Index(["d1", "d2", "d3", "d4"]),
  595:     )
  596:     tm.assert_frame_equal(result, expected)
  597: 
  598: 
  599: def test_loc_period_string_indexing():
  600:     # GH 9892
  601:     a = pd.period_range("2013Q1", "2013Q4", freq="Q")
  602:     i = (1111, 2222, 3333)
  603:     idx = MultiIndex.from_product((a, i), names=("Period", "CVR"))
  604:     df = DataFrame(
  605:         index=idx,
  606:         columns=(
  607:             "OMS",
  608:             "OMK",
  609:             "RES",
  610:             "DRIFT_IND",
  611:             "OEVRIG_IND",
  612:             "FIN_IND",
  613:             "VARE_UD",
  614:             "LOEN_UD",
  615:             "FIN_UD",
  616:         ),
  617:     )
  618:     result = df.loc[("2013Q1", 1111), "OMS"]
  619: 
  620:     alt = df.loc[(a[0], 1111), "OMS"]
  621:     assert np.isnan(alt)
  622: 
  623:     # Because the resolution of the string matches, it is an exact lookup,
  624:     #  not a slice
  625:     assert np.isnan(result)
  626: 
  627:     alt = df.loc[("2013Q1", 1111), "OMS"]
  628:     assert np.isnan(alt)
  629: 
  630: 
  631: def test_loc_datetime_mask_slicing():
  632:     # GH 16699
  633:     dt_idx = pd.to_datetime(["2017-05-04", "2017-05-05"])
  634:     m_idx = MultiIndex.from_product([dt_idx, dt_idx], names=["Idx1", "Idx2"])
  635:     df = DataFrame(
  636:         data=[[1, 2], [3, 4], [5, 6], [7, 6]], index=m_idx, columns=["C1", "C2"]
  637:     )
  638:     result = df.loc[(dt_idx[0], (df.index.get_level_values(1) > "2017-05-04")), "C1"]
  639:     expected = Series(
  640:         [3],
  641:         name="C1",
  642:         index=MultiIndex.from_tuples(
  643:             [(pd.Timestamp("2017-05-04"), pd.Timestamp("2017-05-05"))],
  644:             names=["Idx1", "Idx2"],
  645:         ),
  646:     )
  647:     tm.assert_series_equal(result, expected)
  648: 
  649: 
  650: def test_loc_datetime_series_tuple_slicing():
  651:     # https://github.com/pandas-dev/pandas/issues/35858
  652:     date = pd.Timestamp("2000")
  653:     ser = Series(
  654:         1,
  655:         index=MultiIndex.from_tuples([("a", date)], names=["a", "b"]),
  656:         name="c",
  657:     )
  658:     result = ser.loc[:, [date]]
  659:     tm.assert_series_equal(result, ser)
  660: 
  661: 
  662: def test_loc_with_mi_indexer():
  663:     # https://github.com/pandas-dev/pandas/issues/35351
  664:     df = DataFrame(
  665:         data=[["a", 1], ["a", 0], ["b", 1], ["c", 2]],
  666:         index=MultiIndex.from_tuples(
  667:             [(0, 1), (1, 0), (1, 1), (1, 1)], names=["index", "date"]
  668:         ),
  669:         columns=["author", "price"],
  670:     )
  671:     idx = MultiIndex.from_tuples([(0, 1), (1, 1)], names=["index", "date"])
  672:     result = df.loc[idx, :]
  673:     expected = DataFrame(
  674:         [["a", 1], ["b", 1], ["c", 2]],
  675:         index=MultiIndex.from_tuples([(0, 1), (1, 1), (1, 1)], names=["index", "date"]),
  676:         columns=["author", "price"],
  677:     )
  678:     tm.assert_frame_equal(result, expected)
  679: 
  680: 
  681: def test_loc_mi_with_level1_named_0():
  682:     # GH#37194
  683:     dti = pd.date_range("2016-01-01", periods=3, tz="US/Pacific")
  684: 
  685:     ser = Series(range(3), index=dti)
  686:     df = ser.to_frame()
  687:     df[1] = dti
  688: 
  689:     df2 = df.set_index(0, append=True)
  690:     assert df2.index.names == (None, 0)
  691:     df2.index.get_loc(dti[0])  # smoke test
  692: 
  693:     result = df2.loc[dti[0]]
  694:     expected = df2.iloc[[0]].droplevel(None)
  695:     tm.assert_frame_equal(result, expected)
  696: 
  697:     ser2 = df2[1]
  698:     assert ser2.index.names == (None, 0)
  699: 
  700:     result = ser2.loc[dti[0]]
  701:     expected = ser2.iloc[[0]].droplevel(None)
  702:     tm.assert_series_equal(result, expected)
  703: 
  704: 
  705: def test_getitem_str_slice():
  706:     # GH#15928
  707:     df = DataFrame(
  708:         [
  709:             ["20160525 13:30:00.023", "MSFT", "51.95", "51.95"],
  710:             ["20160525 13:30:00.048", "GOOG", "720.50", "720.93"],
  711:             ["20160525 13:30:00.076", "AAPL", "98.55", "98.56"],
  712:             ["20160525 13:30:00.131", "AAPL", "98.61", "98.62"],
  713:             ["20160525 13:30:00.135", "MSFT", "51.92", "51.95"],
  714:             ["20160525 13:30:00.135", "AAPL", "98.61", "98.62"],
  715:         ],
  716:         columns="time,ticker,bid,ask".split(","),
  717:     )
  718:     df2 = df.set_index(["ticker", "time"]).sort_index()
  719: 
  720:     res = df2.loc[("AAPL", slice("2016-05-25 13:30:00")), :].droplevel(0)
  721:     expected = df2.loc["AAPL"].loc[slice("2016-05-25 13:30:00"), :]
  722:     tm.assert_frame_equal(res, expected)
  723: 
  724: 
  725: def test_3levels_leading_period_index():
  726:     # GH#24091
  727:     pi = pd.PeriodIndex(
  728:         ["20181101 1100", "20181101 1200", "20181102 1300", "20181102 1400"],
  729:         name="datetime",
  730:         freq="D",
  731:     )
  732:     lev2 = ["A", "A", "Z", "W"]
  733:     lev3 = ["B", "C", "Q", "F"]
  734:     mi = MultiIndex.from_arrays([pi, lev2, lev3])
  735: 
  736:     ser = Series(range(4), index=mi, dtype=np.float64)
  737:     result = ser.loc[(pi[0], "A", "B")]
  738:     assert result == 0.0
  739: 
  740: 
  741: class TestKeyErrorsWithMultiIndex:
  742:     def test_missing_keys_raises_keyerror(self):
  743:         # GH#27420 KeyError, not TypeError
  744:         df = DataFrame(np.arange(12).reshape(4, 3), columns=["A", "B", "C"])
  745:         df2 = df.set_index(["A", "B"])
  746: 
  747:         with pytest.raises(KeyError, match="1"):
  748:             df2.loc[(1, 6)]
  749: 
  750:     def test_missing_key_raises_keyerror2(self):
  751:         # GH#21168 KeyError, not "IndexingError: Too many indexers"
  752:         ser = Series(-1, index=MultiIndex.from_product([[0, 1]] * 2))
  753: 
  754:         with pytest.raises(KeyError, match=r"\(0, 3\)"):
  755:             ser.loc[0, 3]
  756: 
  757:     def test_missing_key_combination(self):
  758:         # GH: 19556
  759:         mi = MultiIndex.from_arrays(
  760:             [
  761:                 np.array(["a", "a", "b", "b"]),
  762:                 np.array(["1", "2", "2", "3"]),
  763:                 np.array(["c", "d", "c", "d"]),
  764:             ],
  765:             names=["one", "two", "three"],
  766:         )
  767:         df = DataFrame(np.random.default_rng(2).random((4, 3)), index=mi)
  768:         msg = r"\('b', '1', slice\(None, None, None\)\)"
  769:         with pytest.raises(KeyError, match=msg):
  770:             df.loc[("b", "1", slice(None)), :]
  771:         with pytest.raises(KeyError, match=msg):
  772:             df.index.get_locs(("b", "1", slice(None)))
  773:         with pytest.raises(KeyError, match=r"\('b', '1'\)"):
  774:             df.loc[("b", "1"), :]
  775: 
  776: 
  777: def test_getitem_loc_commutability(multiindex_year_month_day_dataframe_random_data):
  778:     df = multiindex_year_month_day_dataframe_random_data
  779:     ser = df["A"]
  780:     result = ser[2000, 5]
  781:     expected = df.loc[2000, 5]["A"]
  782:     tm.assert_series_equal(result, expected)
  783: 
  784: 
  785: def test_loc_with_nan():
  786:     # GH: 27104
  787:     df = DataFrame(
  788:         {"col": [1, 2, 5], "ind1": ["a", "d", np.nan], "ind2": [1, 4, 5]}
  789:     ).set_index(["ind1", "ind2"])
  790:     result = df.loc[["a"]]
  791:     expected = DataFrame(
  792:         {"col": [1]}, index=MultiIndex.from_tuples([("a", 1)], names=["ind1", "ind2"])
  793:     )
  794:     tm.assert_frame_equal(result, expected)
  795: 
  796:     result = df.loc["a"]
  797:     expected = DataFrame({"col": [1]}, index=Index([1], name="ind2"))
  798:     tm.assert_frame_equal(result, expected)
  799: 
  800: 
  801: def test_getitem_non_found_tuple():
  802:     # GH: 25236
  803:     df = DataFrame([[1, 2, 3, 4]], columns=["a", "b", "c", "d"]).set_index(
  804:         ["a", "b", "c"]
  805:     )
  806:     with pytest.raises(KeyError, match=r"\(2\.0, 2\.0, 3\.0\)"):
  807:         df.loc[(2.0, 2.0, 3.0)]
  808: 
  809: 
  810: def test_get_loc_datetime_index():
  811:     # GH#24263
  812:     index = pd.date_range("2001-01-01", periods=100)
  813:     mi = MultiIndex.from_arrays([index])
  814:     # Check if get_loc matches for Index and MultiIndex
  815:     assert mi.get_loc("2001-01") == slice(0, 31, None)
  816:     assert index.get_loc("2001-01") == slice(0, 31, None)
  817: 
  818:     loc = mi[::2].get_loc("2001-01")
  819:     expected = index[::2].get_loc("2001-01")
  820:     assert loc == expected
  821: 
  822:     loc = mi.repeat(2).get_loc("2001-01")
  823:     expected = index.repeat(2).get_loc("2001-01")
  824:     assert loc == expected
  825: 
  826:     loc = mi.append(mi).get_loc("2001-01")
  827:     expected = index.append(index).get_loc("2001-01")
  828:     # TODO: standardize return type for MultiIndex.get_loc
  829:     tm.assert_numpy_array_equal(loc.nonzero()[0], expected)
  830: 
  831: 
  832: def test_loc_setitem_indexer_differently_ordered():
  833:     # GH#34603
  834:     mi = MultiIndex.from_product([["a", "b"], [0, 1]])
  835:     df = DataFrame([[1, 2], [3, 4], [5, 6], [7, 8]], index=mi)
  836: 
  837:     indexer = ("a", [1, 0])
  838:     df.loc[indexer, :] = np.array([[9, 10], [11, 12]])
  839:     expected = DataFrame([[11, 12], [9, 10], [5, 6], [7, 8]], index=mi)
  840:     tm.assert_frame_equal(df, expected)
  841: 
  842: 
  843: def test_loc_getitem_index_differently_ordered_slice_none():
  844:     # GH#31330
  845:     df = DataFrame(
  846:         [[1, 2], [3, 4], [5, 6], [7, 8]],
  847:         index=[["a", "a", "b", "b"], [1, 2, 1, 2]],
  848:         columns=["a", "b"],
  849:     )
  850:     result = df.loc[(slice(None), [2, 1]), :]
  851:     expected = DataFrame(
  852:         [[3, 4], [7, 8], [1, 2], [5, 6]],
  853:         index=[["a", "b", "a", "b"], [2, 2, 1, 1]],
  854:         columns=["a", "b"],
  855:     )
  856:     tm.assert_frame_equal(result, expected)
  857: 
  858: 
  859: @pytest.mark.parametrize("indexer", [[1, 2, 7, 6, 2, 3, 8, 7], [1, 2, 7, 6, 3, 8]])
  860: def test_loc_getitem_index_differently_ordered_slice_none_duplicates(indexer):
  861:     # GH#40978
  862:     df = DataFrame(
  863:         [1] * 8,
  864:         index=MultiIndex.from_tuples(
  865:             [(1, 1), (1, 2), (1, 7), (1, 6), (2, 2), (2, 3), (2, 8), (2, 7)]
  866:         ),
  867:         columns=["a"],
  868:     )
  869:     result = df.loc[(slice(None), indexer), :]
  870:     expected = DataFrame(
  871:         [1] * 8,
  872:         index=[[1, 1, 2, 1, 2, 1, 2, 2], [1, 2, 2, 7, 7, 6, 3, 8]],
  873:         columns=["a"],
  874:     )
  875:     tm.assert_frame_equal(result, expected)
  876: 
  877:     result = df.loc[df.index.isin(indexer, level=1), :]
  878:     tm.assert_frame_equal(result, df)
  879: 
  880: 
  881: def test_loc_getitem_drops_levels_for_one_row_dataframe():
  882:     # GH#10521 "x" and "z" are both scalar indexing, so those levels are dropped
  883:     mi = MultiIndex.from_arrays([["x"], ["y"], ["z"]], names=["a", "b", "c"])
  884:     df = DataFrame({"d": [0]}, index=mi)
  885:     expected = df.droplevel([0, 2])
  886:     result = df.loc["x", :, "z"]
  887:     tm.assert_frame_equal(result, expected)
  888: 
  889:     ser = Series([0], index=mi)
  890:     result = ser.loc["x", :, "z"]
  891:     expected = Series([0], index=Index(["y"], name="b"))
  892:     tm.assert_series_equal(result, expected)
  893: 
  894: 
  895: def test_mi_columns_loc_list_label_order():
  896:     # GH 10710
  897:     cols = MultiIndex.from_product([["A", "B", "C"], [1, 2]])
  898:     df = DataFrame(np.zeros((5, 6)), columns=cols)
  899:     result = df.loc[:, ["B", "A"]]
  900:     expected = DataFrame(
  901:         np.zeros((5, 4)),
  902:         columns=MultiIndex.from_tuples([("B", 1), ("B", 2), ("A", 1), ("A", 2)]),
  903:     )
  904:     tm.assert_frame_equal(result, expected)
  905: 
  906: 
  907: def test_mi_partial_indexing_list_raises():
  908:     # GH 13501
  909:     frame = DataFrame(
  910:         np.arange(12).reshape((4, 3)),
  911:         index=[["a", "a", "b", "b"], [1, 2, 1, 2]],
  912:         columns=[["Ohio", "Ohio", "Colorado"], ["Green", "Red", "Green"]],
  913:     )
  914:     frame.index.names = ["key1", "key2"]
  915:     frame.columns.names = ["state", "color"]
  916:     with pytest.raises(KeyError, match="\\[2\\] not in index"):
  917:         frame.loc[["b", 2], "Colorado"]
  918: 
  919: 
  920: def test_mi_indexing_list_nonexistent_raises():
  921:     # GH 15452
  922:     s = Series(range(4), index=MultiIndex.from_product([[1, 2], ["a", "b"]]))
  923:     with pytest.raises(KeyError, match="\\['not' 'found'\\] not in index"):
  924:         s.loc[["not", "found"]]
  925: 
  926: 
  927: def test_mi_add_cell_missing_row_non_unique():
  928:     # GH 16018
  929:     result = DataFrame(
  930:         [[1, 2, 5, 6], [3, 4, 7, 8]],
  931:         index=["a", "a"],
  932:         columns=MultiIndex.from_product([[1, 2], ["A", "B"]]),
  933:     )
  934:     result.loc["c"] = -1
  935:     result.loc["c", (1, "A")] = 3
  936:     result.loc["d", (1, "A")] = 3
  937:     expected = DataFrame(
  938:         [
  939:             [1.0, 2.0, 5.0, 6.0],
  940:             [3.0, 4.0, 7.0, 8.0],
  941:             [3.0, -1.0, -1, -1],
  942:             [3.0, np.nan, np.nan, np.nan],
  943:         ],
  944:         index=["a", "a", "c", "d"],
  945:         columns=MultiIndex.from_product([[1, 2], ["A", "B"]]),
  946:     )
  947:     tm.assert_frame_equal(result, expected)
  948: 
  949: 
  950: def test_loc_get_scalar_casting_to_float():
  951:     # GH#41369
  952:     df = DataFrame(
  953:         {"a": 1.0, "b": 2}, index=MultiIndex.from_arrays([[3], [4]], names=["c", "d"])
  954:     )
  955:     result = df.loc[(3, 4), "b"]
  956:     assert result == 2
  957:     assert isinstance(result, np.int64)
  958:     result = df.loc[[(3, 4)], "b"].iloc[0]
  959:     assert result == 2
  960:     assert isinstance(result, np.int64)
  961: 
  962: 
  963: def test_loc_empty_single_selector_with_names():
  964:     # GH 19517
  965:     idx = MultiIndex.from_product([["a", "b"], ["A", "B"]], names=[1, 0])
  966:     s2 = Series(index=idx, dtype=np.float64)
  967:     result = s2.loc["a"]
  968:     expected = Series([np.nan, np.nan], index=Index(["A", "B"], name=0))
  969:     tm.assert_series_equal(result, expected)
  970: 
  971: 
  972: def test_loc_keyerror_rightmost_key_missing():
  973:     # GH 20951
  974: 
  975:     df = DataFrame(
  976:         {
  977:             "A": [100, 100, 200, 200, 300, 300],
  978:             "B": [10, 10, 20, 21, 31, 33],
  979:             "C": range(6),
  980:         }
  981:     )
  982:     df = df.set_index(["A", "B"])
  983:     with pytest.raises(KeyError, match="^1$"):
  984:         df.loc[(100, 1)]
  985: 
  986: 
  987: def test_multindex_series_loc_with_tuple_label():
  988:     # GH#43908
  989:     mi = MultiIndex.from_tuples([(1, 2), (3, (4, 5))])
  990:     ser = Series([1, 2], index=mi)
  991:     result = ser.loc[(3, (4, 5))]
  992:     assert result == 2
