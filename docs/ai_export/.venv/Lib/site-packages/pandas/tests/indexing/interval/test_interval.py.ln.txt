    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._libs import index as libindex
    5: from pandas.compat import IS64
    6: 
    7: import pandas as pd
    8: from pandas import (
    9:     DataFrame,
   10:     IntervalIndex,
   11:     Series,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: class TestIntervalIndex:
   17:     @pytest.fixture
   18:     def series_with_interval_index(self):
   19:         return Series(np.arange(5), IntervalIndex.from_breaks(np.arange(6)))
   20: 
   21:     def test_getitem_with_scalar(self, series_with_interval_index, indexer_sl):
   22:         ser = series_with_interval_index.copy()
   23: 
   24:         expected = ser.iloc[:3]
   25:         tm.assert_series_equal(expected, indexer_sl(ser)[:3])
   26:         tm.assert_series_equal(expected, indexer_sl(ser)[:2.5])
   27:         tm.assert_series_equal(expected, indexer_sl(ser)[0.1:2.5])
   28:         if indexer_sl is tm.loc:
   29:             tm.assert_series_equal(expected, ser.loc[-1:3])
   30: 
   31:         expected = ser.iloc[1:4]
   32:         tm.assert_series_equal(expected, indexer_sl(ser)[[1.5, 2.5, 3.5]])
   33:         tm.assert_series_equal(expected, indexer_sl(ser)[[2, 3, 4]])
   34:         tm.assert_series_equal(expected, indexer_sl(ser)[[1.5, 3, 4]])
   35: 
   36:         expected = ser.iloc[2:5]
   37:         tm.assert_series_equal(expected, indexer_sl(ser)[ser >= 2])
   38: 
   39:     @pytest.mark.parametrize("direction", ["increasing", "decreasing"])
   40:     def test_getitem_nonoverlapping_monotonic(self, direction, closed, indexer_sl):
   41:         tpls = [(0, 1), (2, 3), (4, 5)]
   42:         if direction == "decreasing":
   43:             tpls = tpls[::-1]
   44: 
   45:         idx = IntervalIndex.from_tuples(tpls, closed=closed)
   46:         ser = Series(list("abc"), idx)
   47: 
   48:         for key, expected in zip(idx.left, ser):
   49:             if idx.closed_left:
   50:                 assert indexer_sl(ser)[key] == expected
   51:             else:
   52:                 with pytest.raises(KeyError, match=str(key)):
   53:                     indexer_sl(ser)[key]
   54: 
   55:         for key, expected in zip(idx.right, ser):
   56:             if idx.closed_right:
   57:                 assert indexer_sl(ser)[key] == expected
   58:             else:
   59:                 with pytest.raises(KeyError, match=str(key)):
   60:                     indexer_sl(ser)[key]
   61: 
   62:         for key, expected in zip(idx.mid, ser):
   63:             assert indexer_sl(ser)[key] == expected
   64: 
   65:     def test_getitem_non_matching(self, series_with_interval_index, indexer_sl):
   66:         ser = series_with_interval_index.copy()
   67: 
   68:         # this is a departure from our current
   69:         # indexing scheme, but simpler
   70:         with pytest.raises(KeyError, match=r"\[-1\] not in index"):
   71:             indexer_sl(ser)[[-1, 3, 4, 5]]
   72: 
   73:         with pytest.raises(KeyError, match=r"\[-1\] not in index"):
   74:             indexer_sl(ser)[[-1, 3]]
   75: 
   76:     def test_loc_getitem_large_series(self, monkeypatch):
   77:         size_cutoff = 20
   78:         with monkeypatch.context():
   79:             monkeypatch.setattr(libindex, "_SIZE_CUTOFF", size_cutoff)
   80:             ser = Series(
   81:                 np.arange(size_cutoff),
   82:                 index=IntervalIndex.from_breaks(np.arange(size_cutoff + 1)),
   83:             )
   84: 
   85:             result1 = ser.loc[:8]
   86:             result2 = ser.loc[0:8]
   87:             result3 = ser.loc[0:8:1]
   88:         tm.assert_series_equal(result1, result2)
   89:         tm.assert_series_equal(result1, result3)
   90: 
   91:     def test_loc_getitem_frame(self):
   92:         # CategoricalIndex with IntervalIndex categories
   93:         df = DataFrame({"A": range(10)})
   94:         ser = pd.cut(df.A, 5)
   95:         df["B"] = ser
   96:         df = df.set_index("B")
   97: 
   98:         result = df.loc[4]
   99:         expected = df.iloc[4:6]
  100:         tm.assert_frame_equal(result, expected)
  101: 
  102:         with pytest.raises(KeyError, match="10"):
  103:             df.loc[10]
  104: 
  105:         # single list-like
  106:         result = df.loc[[4]]
  107:         expected = df.iloc[4:6]
  108:         tm.assert_frame_equal(result, expected)
  109: 
  110:         # non-unique
  111:         result = df.loc[[4, 5]]
  112:         expected = df.take([4, 5, 4, 5])
  113:         tm.assert_frame_equal(result, expected)
  114: 
  115:         msg = (
  116:             r"None of \[Index\(\[10\], dtype='object', name='B'\)\] "
  117:             r"are in the \[index\]"
  118:         )
  119:         with pytest.raises(KeyError, match=msg):
  120:             df.loc[[10]]
  121: 
  122:         # partial missing
  123:         with pytest.raises(KeyError, match=r"\[10\] not in index"):
  124:             df.loc[[10, 4]]
  125: 
  126:     def test_getitem_interval_with_nans(self, frame_or_series, indexer_sl):
  127:         # GH#41831
  128: 
  129:         index = IntervalIndex([np.nan, np.nan])
  130:         key = index[:-1]
  131: 
  132:         obj = frame_or_series(range(2), index=index)
  133:         if frame_or_series is DataFrame and indexer_sl is tm.setitem:
  134:             obj = obj.T
  135: 
  136:         result = indexer_sl(obj)[key]
  137:         expected = obj
  138: 
  139:         tm.assert_equal(result, expected)
  140: 
  141:     def test_setitem_interval_with_slice(self):
  142:         # GH#54722
  143:         ii = IntervalIndex.from_breaks(range(4, 15))
  144:         ser = Series(range(10), index=ii)
  145: 
  146:         orig = ser.copy()
  147: 
  148:         # This should be a no-op (used to raise)
  149:         ser.loc[1:3] = 20
  150:         tm.assert_series_equal(ser, orig)
  151: 
  152:         ser.loc[6:8] = 19
  153:         orig.iloc[1:4] = 19
  154:         tm.assert_series_equal(ser, orig)
  155: 
  156:         ser2 = Series(range(5), index=ii[::2])
  157:         orig2 = ser2.copy()
  158: 
  159:         # this used to raise
  160:         ser2.loc[6:8] = 22  # <- raises on main, sets on branch
  161:         orig2.iloc[1] = 22
  162:         tm.assert_series_equal(ser2, orig2)
  163: 
  164:         ser2.loc[5:7] = 21
  165:         orig2.iloc[:2] = 21
  166:         tm.assert_series_equal(ser2, orig2)
  167: 
  168: 
  169: class TestIntervalIndexInsideMultiIndex:
  170:     def test_mi_intervalindex_slicing_with_scalar(self):
  171:         # GH#27456
  172:         ii = IntervalIndex.from_arrays(
  173:             [0, 1, 10, 11, 0, 1, 10, 11], [1, 2, 11, 12, 1, 2, 11, 12], name="MP"
  174:         )
  175:         idx = pd.MultiIndex.from_arrays(
  176:             [
  177:                 pd.Index(["FC", "FC", "FC", "FC", "OWNER", "OWNER", "OWNER", "OWNER"]),
  178:                 pd.Index(
  179:                     ["RID1", "RID1", "RID2", "RID2", "RID1", "RID1", "RID2", "RID2"]
  180:                 ),
  181:                 ii,
  182:             ]
  183:         )
  184: 
  185:         idx.names = ["Item", "RID", "MP"]
  186:         df = DataFrame({"value": [1, 2, 3, 4, 5, 6, 7, 8]})
  187:         df.index = idx
  188: 
  189:         query_df = DataFrame(
  190:             {
  191:                 "Item": ["FC", "OWNER", "FC", "OWNER", "OWNER"],
  192:                 "RID": ["RID1", "RID1", "RID1", "RID2", "RID2"],
  193:                 "MP": [0.2, 1.5, 1.6, 11.1, 10.9],
  194:             }
  195:         )
  196: 
  197:         query_df = query_df.sort_index()
  198: 
  199:         idx = pd.MultiIndex.from_arrays([query_df.Item, query_df.RID, query_df.MP])
  200:         query_df.index = idx
  201:         result = df.value.loc[query_df.index]
  202: 
  203:         # the IntervalIndex level is indexed with floats, which map to
  204:         #  the intervals containing them.  Matching the behavior we would get
  205:         #  with _only_ an IntervalIndex, we get an IntervalIndex level back.
  206:         sliced_level = ii.take([0, 1, 1, 3, 2])
  207:         expected_index = pd.MultiIndex.from_arrays(
  208:             [idx.get_level_values(0), idx.get_level_values(1), sliced_level]
  209:         )
  210:         expected = Series([1, 6, 2, 8, 7], index=expected_index, name="value")
  211:         tm.assert_series_equal(result, expected)
  212: 
  213:     @pytest.mark.xfail(not IS64, reason="GH 23440")
  214:     @pytest.mark.parametrize(
  215:         "base",
  216:         [101, 1010],
  217:     )
  218:     def test_reindex_behavior_with_interval_index(self, base):
  219:         # GH 51826
  220: 
  221:         ser = Series(
  222:             range(base),
  223:             index=IntervalIndex.from_arrays(range(base), range(1, base + 1)),
  224:         )
  225:         expected_result = Series([np.nan, 0], index=[np.nan, 1.0], dtype=float)
  226:         result = ser.reindex(index=[np.nan, 1.0])
  227:         tm.assert_series_equal(result, expected_result)
