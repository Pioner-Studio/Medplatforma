    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.compat import IS64
    7: 
    8: from pandas import (
    9:     Index,
   10:     Interval,
   11:     IntervalIndex,
   12:     Series,
   13: )
   14: import pandas._testing as tm
   15: 
   16: 
   17: class TestIntervalIndex:
   18:     @pytest.fixture
   19:     def series_with_interval_index(self):
   20:         return Series(np.arange(5), IntervalIndex.from_breaks(np.arange(6)))
   21: 
   22:     def test_loc_with_interval(self, series_with_interval_index, indexer_sl):
   23:         # loc with single label / list of labels:
   24:         #   - Intervals: only exact matches
   25:         #   - scalars: those that contain it
   26: 
   27:         ser = series_with_interval_index.copy()
   28: 
   29:         expected = 0
   30:         result = indexer_sl(ser)[Interval(0, 1)]
   31:         assert result == expected
   32: 
   33:         expected = ser.iloc[3:5]
   34:         result = indexer_sl(ser)[[Interval(3, 4), Interval(4, 5)]]
   35:         tm.assert_series_equal(expected, result)
   36: 
   37:         # missing or not exact
   38:         with pytest.raises(KeyError, match=re.escape("Interval(3, 5, closed='left')")):
   39:             indexer_sl(ser)[Interval(3, 5, closed="left")]
   40: 
   41:         with pytest.raises(KeyError, match=re.escape("Interval(3, 5, closed='right')")):
   42:             indexer_sl(ser)[Interval(3, 5)]
   43: 
   44:         with pytest.raises(
   45:             KeyError, match=re.escape("Interval(-2, 0, closed='right')")
   46:         ):
   47:             indexer_sl(ser)[Interval(-2, 0)]
   48: 
   49:         with pytest.raises(KeyError, match=re.escape("Interval(5, 6, closed='right')")):
   50:             indexer_sl(ser)[Interval(5, 6)]
   51: 
   52:     def test_loc_with_scalar(self, series_with_interval_index, indexer_sl):
   53:         # loc with single label / list of labels:
   54:         #   - Intervals: only exact matches
   55:         #   - scalars: those that contain it
   56: 
   57:         ser = series_with_interval_index.copy()
   58: 
   59:         assert indexer_sl(ser)[1] == 0
   60:         assert indexer_sl(ser)[1.5] == 1
   61:         assert indexer_sl(ser)[2] == 1
   62: 
   63:         expected = ser.iloc[1:4]
   64:         tm.assert_series_equal(expected, indexer_sl(ser)[[1.5, 2.5, 3.5]])
   65:         tm.assert_series_equal(expected, indexer_sl(ser)[[2, 3, 4]])
   66:         tm.assert_series_equal(expected, indexer_sl(ser)[[1.5, 3, 4]])
   67: 
   68:         expected = ser.iloc[[1, 1, 2, 1]]
   69:         tm.assert_series_equal(expected, indexer_sl(ser)[[1.5, 2, 2.5, 1.5]])
   70: 
   71:         expected = ser.iloc[2:5]
   72:         tm.assert_series_equal(expected, indexer_sl(ser)[ser >= 2])
   73: 
   74:     def test_loc_with_slices(self, series_with_interval_index, indexer_sl):
   75:         # loc with slices:
   76:         #   - Interval objects: only works with exact matches
   77:         #   - scalars: only works for non-overlapping, monotonic intervals,
   78:         #     and start/stop select location based on the interval that
   79:         #     contains them:
   80:         #    (slice_loc(start, stop) == (idx.get_loc(start), idx.get_loc(stop))
   81: 
   82:         ser = series_with_interval_index.copy()
   83: 
   84:         # slice of interval
   85: 
   86:         expected = ser.iloc[:3]
   87:         result = indexer_sl(ser)[Interval(0, 1) : Interval(2, 3)]
   88:         tm.assert_series_equal(expected, result)
   89: 
   90:         expected = ser.iloc[3:]
   91:         result = indexer_sl(ser)[Interval(3, 4) :]
   92:         tm.assert_series_equal(expected, result)
   93: 
   94:         msg = "Interval objects are not currently supported"
   95:         with pytest.raises(NotImplementedError, match=msg):
   96:             indexer_sl(ser)[Interval(3, 6) :]
   97: 
   98:         with pytest.raises(NotImplementedError, match=msg):
   99:             indexer_sl(ser)[Interval(3, 4, closed="left") :]
  100: 
  101:     def test_slice_step_ne1(self, series_with_interval_index):
  102:         # GH#31658 slice of scalar with step != 1
  103:         ser = series_with_interval_index.copy()
  104:         expected = ser.iloc[0:4:2]
  105: 
  106:         result = ser[0:4:2]
  107:         tm.assert_series_equal(result, expected)
  108: 
  109:         result2 = ser[0:4][::2]
  110:         tm.assert_series_equal(result2, expected)
  111: 
  112:     def test_slice_float_start_stop(self, series_with_interval_index):
  113:         # GH#31658 slicing with integers is positional, with floats is not
  114:         #  supported
  115:         ser = series_with_interval_index.copy()
  116: 
  117:         msg = "label-based slicing with step!=1 is not supported for IntervalIndex"
  118:         with pytest.raises(ValueError, match=msg):
  119:             ser[1.5:9.5:2]
  120: 
  121:     def test_slice_interval_step(self, series_with_interval_index):
  122:         # GH#31658 allows for integer step!=1, not Interval step
  123:         ser = series_with_interval_index.copy()
  124:         msg = "label-based slicing with step!=1 is not supported for IntervalIndex"
  125:         with pytest.raises(ValueError, match=msg):
  126:             ser[0 : 4 : Interval(0, 1)]
  127: 
  128:     def test_loc_with_overlap(self, indexer_sl):
  129:         idx = IntervalIndex.from_tuples([(1, 5), (3, 7)])
  130:         ser = Series(range(len(idx)), index=idx)
  131: 
  132:         # scalar
  133:         expected = ser
  134:         result = indexer_sl(ser)[4]
  135:         tm.assert_series_equal(expected, result)
  136: 
  137:         result = indexer_sl(ser)[[4]]
  138:         tm.assert_series_equal(expected, result)
  139: 
  140:         # interval
  141:         expected = 0
  142:         result = indexer_sl(ser)[Interval(1, 5)]
  143:         assert expected == result
  144: 
  145:         expected = ser
  146:         result = indexer_sl(ser)[[Interval(1, 5), Interval(3, 7)]]
  147:         tm.assert_series_equal(expected, result)
  148: 
  149:         with pytest.raises(KeyError, match=re.escape("Interval(3, 5, closed='right')")):
  150:             indexer_sl(ser)[Interval(3, 5)]
  151: 
  152:         msg = (
  153:             r"None of \[IntervalIndex\(\[\(3, 5\]\], "
  154:             r"dtype='interval\[int64, right\]'\)\] are in the \[index\]"
  155:         )
  156:         with pytest.raises(KeyError, match=msg):
  157:             indexer_sl(ser)[[Interval(3, 5)]]
  158: 
  159:         # slices with interval (only exact matches)
  160:         expected = ser
  161:         result = indexer_sl(ser)[Interval(1, 5) : Interval(3, 7)]
  162:         tm.assert_series_equal(expected, result)
  163: 
  164:         msg = (
  165:             "'can only get slices from an IntervalIndex if bounds are "
  166:             "non-overlapping and all monotonic increasing or decreasing'"
  167:         )
  168:         with pytest.raises(KeyError, match=msg):
  169:             indexer_sl(ser)[Interval(1, 6) : Interval(3, 8)]
  170: 
  171:         if indexer_sl is tm.loc:
  172:             # slices with scalar raise for overlapping intervals
  173:             # TODO KeyError is the appropriate error?
  174:             with pytest.raises(KeyError, match=msg):
  175:                 ser.loc[1:4]
  176: 
  177:     def test_non_unique(self, indexer_sl):
  178:         idx = IntervalIndex.from_tuples([(1, 3), (3, 7)])
  179:         ser = Series(range(len(idx)), index=idx)
  180: 
  181:         result = indexer_sl(ser)[Interval(1, 3)]
  182:         assert result == 0
  183: 
  184:         result = indexer_sl(ser)[[Interval(1, 3)]]
  185:         expected = ser.iloc[0:1]
  186:         tm.assert_series_equal(expected, result)
  187: 
  188:     def test_non_unique_moar(self, indexer_sl):
  189:         idx = IntervalIndex.from_tuples([(1, 3), (1, 3), (3, 7)])
  190:         ser = Series(range(len(idx)), index=idx)
  191: 
  192:         expected = ser.iloc[[0, 1]]
  193:         result = indexer_sl(ser)[Interval(1, 3)]
  194:         tm.assert_series_equal(expected, result)
  195: 
  196:         expected = ser
  197:         result = indexer_sl(ser)[Interval(1, 3) :]
  198:         tm.assert_series_equal(expected, result)
  199: 
  200:         expected = ser.iloc[[0, 1]]
  201:         result = indexer_sl(ser)[[Interval(1, 3)]]
  202:         tm.assert_series_equal(expected, result)
  203: 
  204:     def test_loc_getitem_missing_key_error_message(
  205:         self, frame_or_series, series_with_interval_index
  206:     ):
  207:         # GH#27365
  208:         ser = series_with_interval_index.copy()
  209:         obj = frame_or_series(ser)
  210:         with pytest.raises(KeyError, match=r"\[6\]"):
  211:             obj.loc[[4, 5, 6]]
  212: 
  213: 
  214: @pytest.mark.xfail(not IS64, reason="GH 23440")
  215: @pytest.mark.parametrize(
  216:     "intervals",
  217:     [
  218:         ([Interval(-np.inf, 0.0), Interval(0.0, 1.0)]),
  219:         ([Interval(-np.inf, -2.0), Interval(-2.0, -1.0)]),
  220:         ([Interval(-1.0, 0.0), Interval(0.0, np.inf)]),
  221:         ([Interval(1.0, 2.0), Interval(2.0, np.inf)]),
  222:     ],
  223: )
  224: def test_repeating_interval_index_with_infs(intervals):
  225:     # GH 46658
  226: 
  227:     interval_index = Index(intervals * 51)
  228: 
  229:     expected = np.arange(1, 102, 2, dtype=np.intp)
  230:     result = interval_index.get_indexer_for([intervals[1]])
  231: 
  232:     tm.assert_equal(result, expected)
