    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     Index,
    7:     MultiIndex,
    8:     Series,
    9: )
   10: import pandas._testing as tm
   11: from pandas.core.indexing import IndexingError
   12: 
   13: # ----------------------------------------------------------------------------
   14: # test indexing of Series with multi-level Index
   15: # ----------------------------------------------------------------------------
   16: 
   17: 
   18: @pytest.mark.parametrize(
   19:     "access_method",
   20:     [lambda s, x: s[:, x], lambda s, x: s.loc[:, x], lambda s, x: s.xs(x, level=1)],
   21: )
   22: @pytest.mark.parametrize(
   23:     "level1_value, expected",
   24:     [(0, Series([1], index=[0])), (1, Series([2, 3], index=[1, 2]))],
   25: )
   26: def test_series_getitem_multiindex(access_method, level1_value, expected):
   27:     # GH 6018
   28:     # series regression getitem with a multi-index
   29: 
   30:     mi = MultiIndex.from_tuples([(0, 0), (1, 1), (2, 1)], names=["A", "B"])
   31:     ser = Series([1, 2, 3], index=mi)
   32:     expected.index.name = "A"
   33: 
   34:     result = access_method(ser, level1_value)
   35:     tm.assert_series_equal(result, expected)
   36: 
   37: 
   38: @pytest.mark.parametrize("level0_value", ["D", "A"])
   39: def test_series_getitem_duplicates_multiindex(level0_value):
   40:     # GH 5725 the 'A' happens to be a valid Timestamp so the doesn't raise
   41:     # the appropriate error, only in PY3 of course!
   42: 
   43:     index = MultiIndex(
   44:         levels=[[level0_value, "B", "C"], [0, 26, 27, 37, 57, 67, 75, 82]],
   45:         codes=[[0, 0, 0, 1, 2, 2, 2, 2, 2, 2], [1, 3, 4, 6, 0, 2, 2, 3, 5, 7]],
   46:         names=["tag", "day"],
   47:     )
   48:     arr = np.random.default_rng(2).standard_normal((len(index), 1))
   49:     df = DataFrame(arr, index=index, columns=["val"])
   50: 
   51:     # confirm indexing on missing value raises KeyError
   52:     if level0_value != "A":
   53:         with pytest.raises(KeyError, match=r"^'A'$"):
   54:             df.val["A"]
   55: 
   56:     with pytest.raises(KeyError, match=r"^'X'$"):
   57:         df.val["X"]
   58: 
   59:     result = df.val[level0_value]
   60:     expected = Series(
   61:         arr.ravel()[0:3], name="val", index=Index([26, 37, 57], name="day")
   62:     )
   63:     tm.assert_series_equal(result, expected)
   64: 
   65: 
   66: def test_series_getitem(multiindex_year_month_day_dataframe_random_data, indexer_sl):
   67:     s = multiindex_year_month_day_dataframe_random_data["A"]
   68:     expected = s.reindex(s.index[42:65])
   69:     expected.index = expected.index.droplevel(0).droplevel(0)
   70: 
   71:     result = indexer_sl(s)[2000, 3]
   72:     tm.assert_series_equal(result, expected)
   73: 
   74: 
   75: def test_series_getitem_returns_scalar(
   76:     multiindex_year_month_day_dataframe_random_data, indexer_sl
   77: ):
   78:     s = multiindex_year_month_day_dataframe_random_data["A"]
   79:     expected = s.iloc[49]
   80: 
   81:     result = indexer_sl(s)[2000, 3, 10]
   82:     assert result == expected
   83: 
   84: 
   85: @pytest.mark.parametrize(
   86:     "indexer,expected_error,expected_error_msg",
   87:     [
   88:         (lambda s: s.__getitem__((2000, 3, 4)), KeyError, r"^\(2000, 3, 4\)$"),
   89:         (lambda s: s[(2000, 3, 4)], KeyError, r"^\(2000, 3, 4\)$"),
   90:         (lambda s: s.loc[(2000, 3, 4)], KeyError, r"^\(2000, 3, 4\)$"),
   91:         (lambda s: s.loc[(2000, 3, 4, 5)], IndexingError, "Too many indexers"),
   92:         (lambda s: s.__getitem__(len(s)), KeyError, ""),  # match should include len(s)
   93:         (lambda s: s[len(s)], KeyError, ""),  # match should include len(s)
   94:         (
   95:             lambda s: s.iloc[len(s)],
   96:             IndexError,
   97:             "single positional indexer is out-of-bounds",
   98:         ),
   99:     ],
  100: )
  101: def test_series_getitem_indexing_errors(
  102:     multiindex_year_month_day_dataframe_random_data,
  103:     indexer,
  104:     expected_error,
  105:     expected_error_msg,
  106: ):
  107:     s = multiindex_year_month_day_dataframe_random_data["A"]
  108:     with pytest.raises(expected_error, match=expected_error_msg):
  109:         indexer(s)
  110: 
  111: 
  112: def test_series_getitem_corner_generator(
  113:     multiindex_year_month_day_dataframe_random_data,
  114: ):
  115:     s = multiindex_year_month_day_dataframe_random_data["A"]
  116:     result = s[(x > 0 for x in s)]
  117:     expected = s[s > 0]
  118:     tm.assert_series_equal(result, expected)
  119: 
  120: 
  121: # ----------------------------------------------------------------------------
  122: # test indexing of DataFrame with multi-level Index
  123: # ----------------------------------------------------------------------------
  124: 
  125: 
  126: def test_getitem_simple(multiindex_dataframe_random_data):
  127:     df = multiindex_dataframe_random_data.T
  128:     expected = df.values[:, 0]
  129:     result = df["foo", "one"].values
  130:     tm.assert_almost_equal(result, expected)
  131: 
  132: 
  133: @pytest.mark.parametrize(
  134:     "indexer,expected_error_msg",
  135:     [
  136:         (lambda df: df[("foo", "four")], r"^\('foo', 'four'\)$"),
  137:         (lambda df: df["foobar"], r"^'foobar'$"),
  138:     ],
  139: )
  140: def test_frame_getitem_simple_key_error(
  141:     multiindex_dataframe_random_data, indexer, expected_error_msg
  142: ):
  143:     df = multiindex_dataframe_random_data.T
  144:     with pytest.raises(KeyError, match=expected_error_msg):
  145:         indexer(df)
  146: 
  147: 
  148: def test_tuple_string_column_names():
  149:     # GH#50372
  150:     mi = MultiIndex.from_tuples([("a", "aa"), ("a", "ab"), ("b", "ba"), ("b", "bb")])
  151:     df = DataFrame([range(4), range(1, 5), range(2, 6)], columns=mi)
  152:     df["single_index"] = 0
  153: 
  154:     df_flat = df.copy()
  155:     df_flat.columns = df_flat.columns.to_flat_index()
  156:     df_flat["new_single_index"] = 0
  157: 
  158:     result = df_flat[[("a", "aa"), "new_single_index"]]
  159:     expected = DataFrame(
  160:         [[0, 0], [1, 0], [2, 0]], columns=Index([("a", "aa"), "new_single_index"])
  161:     )
  162:     tm.assert_frame_equal(result, expected)
  163: 
  164: 
  165: def test_frame_getitem_multicolumn_empty_level():
  166:     df = DataFrame({"a": ["1", "2", "3"], "b": ["2", "3", "4"]})
  167:     df.columns = [
  168:         ["level1 item1", "level1 item2"],
  169:         ["", "level2 item2"],
  170:         ["level3 item1", "level3 item2"],
  171:     ]
  172: 
  173:     result = df["level1 item1"]
  174:     expected = DataFrame(
  175:         [["1"], ["2"], ["3"]], index=df.index, columns=["level3 item1"]
  176:     )
  177:     tm.assert_frame_equal(result, expected)
  178: 
  179: 
  180: @pytest.mark.parametrize(
  181:     "indexer,expected_slice",
  182:     [
  183:         (lambda df: df["foo"], slice(3)),
  184:         (lambda df: df["bar"], slice(3, 5)),
  185:         (lambda df: df.loc[:, "bar"], slice(3, 5)),
  186:     ],
  187: )
  188: def test_frame_getitem_toplevel(
  189:     multiindex_dataframe_random_data, indexer, expected_slice
  190: ):
  191:     df = multiindex_dataframe_random_data.T
  192:     expected = df.reindex(columns=df.columns[expected_slice])
  193:     expected.columns = expected.columns.droplevel(0)
  194:     result = indexer(df)
  195:     tm.assert_frame_equal(result, expected)
  196: 
  197: 
  198: def test_frame_mixed_depth_get():
  199:     arrays = [
  200:         ["a", "top", "top", "routine1", "routine1", "routine2"],
  201:         ["", "OD", "OD", "result1", "result2", "result1"],
  202:         ["", "wx", "wy", "", "", ""],
  203:     ]
  204: 
  205:     tuples = sorted(zip(*arrays))
  206:     index = MultiIndex.from_tuples(tuples)
  207:     df = DataFrame(np.random.default_rng(2).standard_normal((4, 6)), columns=index)
  208: 
  209:     result = df["a"]
  210:     expected = df["a", "", ""].rename("a")
  211:     tm.assert_series_equal(result, expected)
  212: 
  213:     result = df["routine1", "result1"]
  214:     expected = df["routine1", "result1", ""]
  215:     expected = expected.rename(("routine1", "result1"))
  216:     tm.assert_series_equal(result, expected)
  217: 
  218: 
  219: def test_frame_getitem_nan_multiindex(nulls_fixture):
  220:     # GH#29751
  221:     # loc on a multiindex containing nan values
  222:     n = nulls_fixture  # for code readability
  223:     cols = ["a", "b", "c"]
  224:     df = DataFrame(
  225:         [[11, n, 13], [21, n, 23], [31, n, 33], [41, n, 43]],
  226:         columns=cols,
  227:     ).set_index(["a", "b"])
  228:     df["c"] = df["c"].astype("int64")
  229: 
  230:     idx = (21, n)
  231:     result = df.loc[:idx]
  232:     expected = DataFrame([[11, n, 13], [21, n, 23]], columns=cols).set_index(["a", "b"])
  233:     expected["c"] = expected["c"].astype("int64")
  234:     tm.assert_frame_equal(result, expected)
  235: 
  236:     result = df.loc[idx:]
  237:     expected = DataFrame(
  238:         [[21, n, 23], [31, n, 33], [41, n, 43]], columns=cols
  239:     ).set_index(["a", "b"])
  240:     expected["c"] = expected["c"].astype("int64")
  241:     tm.assert_frame_equal(result, expected)
  242: 
  243:     idx1, idx2 = (21, n), (31, n)
  244:     result = df.loc[idx1:idx2]
  245:     expected = DataFrame([[21, n, 23], [31, n, 33]], columns=cols).set_index(["a", "b"])
  246:     expected["c"] = expected["c"].astype("int64")
  247:     tm.assert_frame_equal(result, expected)
  248: 
  249: 
  250: @pytest.mark.parametrize(
  251:     "indexer,expected",
  252:     [
  253:         (
  254:             (["b"], ["bar", np.nan]),
  255:             (
  256:                 DataFrame(
  257:                     [[2, 3], [5, 6]],
  258:                     columns=MultiIndex.from_tuples([("b", "bar"), ("b", np.nan)]),
  259:                     dtype="int64",
  260:                 )
  261:             ),
  262:         ),
  263:         (
  264:             (["a", "b"]),
  265:             (
  266:                 DataFrame(
  267:                     [[1, 2, 3], [4, 5, 6]],
  268:                     columns=MultiIndex.from_tuples(
  269:                         [("a", "foo"), ("b", "bar"), ("b", np.nan)]
  270:                     ),
  271:                     dtype="int64",
  272:                 )
  273:             ),
  274:         ),
  275:         (
  276:             (["b"]),
  277:             (
  278:                 DataFrame(
  279:                     [[2, 3], [5, 6]],
  280:                     columns=MultiIndex.from_tuples([("b", "bar"), ("b", np.nan)]),
  281:                     dtype="int64",
  282:                 )
  283:             ),
  284:         ),
  285:         (
  286:             (["b"], ["bar"]),
  287:             (
  288:                 DataFrame(
  289:                     [[2], [5]],
  290:                     columns=MultiIndex.from_tuples([("b", "bar")]),
  291:                     dtype="int64",
  292:                 )
  293:             ),
  294:         ),
  295:         (
  296:             (["b"], [np.nan]),
  297:             (
  298:                 DataFrame(
  299:                     [[3], [6]],
  300:                     columns=MultiIndex(
  301:                         codes=[[1], [-1]], levels=[["a", "b"], ["bar", "foo"]]
  302:                     ),
  303:                     dtype="int64",
  304:                 )
  305:             ),
  306:         ),
  307:         (("b", np.nan), Series([3, 6], dtype="int64", name=("b", np.nan))),
  308:     ],
  309: )
  310: def test_frame_getitem_nan_cols_multiindex(
  311:     indexer,
  312:     expected,
  313:     nulls_fixture,
  314: ):
  315:     # Slicing MultiIndex including levels with nan values, for more information
  316:     # see GH#25154
  317:     df = DataFrame(
  318:         [[1, 2, 3], [4, 5, 6]],
  319:         columns=MultiIndex.from_tuples(
  320:             [("a", "foo"), ("b", "bar"), ("b", nulls_fixture)]
  321:         ),
  322:         dtype="int64",
  323:     )
  324: 
  325:     result = df.loc[:, indexer]
  326:     tm.assert_equal(result, expected)
  327: 
  328: 
  329: # ----------------------------------------------------------------------------
  330: # test indexing of DataFrame with multi-level Index with duplicates
  331: # ----------------------------------------------------------------------------
  332: 
  333: 
  334: @pytest.fixture
  335: def dataframe_with_duplicate_index():
  336:     """Fixture for DataFrame used in tests for gh-4145 and gh-4146"""
  337:     data = [["a", "d", "e", "c", "f", "b"], [1, 4, 5, 3, 6, 2], [1, 4, 5, 3, 6, 2]]
  338:     index = ["h1", "h3", "h5"]
  339:     columns = MultiIndex(
  340:         levels=[["A", "B"], ["A1", "A2", "B1", "B2"]],
  341:         codes=[[0, 0, 0, 1, 1, 1], [0, 3, 3, 0, 1, 2]],
  342:         names=["main", "sub"],
  343:     )
  344:     return DataFrame(data, index=index, columns=columns)
  345: 
  346: 
  347: @pytest.mark.parametrize(
  348:     "indexer", [lambda df: df[("A", "A1")], lambda df: df.loc[:, ("A", "A1")]]
  349: )
  350: def test_frame_mi_access(dataframe_with_duplicate_index, indexer):
  351:     # GH 4145
  352:     df = dataframe_with_duplicate_index
  353:     index = Index(["h1", "h3", "h5"])
  354:     columns = MultiIndex.from_tuples([("A", "A1")], names=["main", "sub"])
  355:     expected = DataFrame([["a", 1, 1]], index=columns, columns=index).T
  356: 
  357:     result = indexer(df)
  358:     tm.assert_frame_equal(result, expected)
  359: 
  360: 
  361: def test_frame_mi_access_returns_series(dataframe_with_duplicate_index):
  362:     # GH 4146, not returning a block manager when selecting a unique index
  363:     # from a duplicate index
  364:     # as of 4879, this returns a Series (which is similar to what happens
  365:     # with a non-unique)
  366:     df = dataframe_with_duplicate_index
  367:     expected = Series(["a", 1, 1], index=["h1", "h3", "h5"], name="A1")
  368:     result = df["A"]["A1"]
  369:     tm.assert_series_equal(result, expected)
  370: 
  371: 
  372: def test_frame_mi_access_returns_frame(dataframe_with_duplicate_index):
  373:     # selecting a non_unique from the 2nd level
  374:     df = dataframe_with_duplicate_index
  375:     expected = DataFrame(
  376:         [["d", 4, 4], ["e", 5, 5]],
  377:         index=Index(["B2", "B2"], name="sub"),
  378:         columns=["h1", "h3", "h5"],
  379:     ).T
  380:     result = df["A"]["B2"]
  381:     tm.assert_frame_equal(result, expected)
  382: 
  383: 
  384: def test_frame_mi_empty_slice():
  385:     # GH 15454
  386:     df = DataFrame(0, index=range(2), columns=MultiIndex.from_product([[1], [2]]))
  387:     result = df[[]]
  388:     expected = DataFrame(
  389:         index=[0, 1], columns=MultiIndex(levels=[[1], [2]], codes=[[], []])
  390:     )
  391:     tm.assert_frame_equal(result, expected)
  392: 
  393: 
  394: def test_loc_empty_multiindex():
  395:     # GH#36936
  396:     arrays = [["a", "a", "b", "a"], ["a", "a", "b", "b"]]
  397:     index = MultiIndex.from_arrays(arrays, names=("idx1", "idx2"))
  398:     df = DataFrame([1, 2, 3, 4], index=index, columns=["value"])
  399: 
  400:     # loc on empty multiindex == loc with False mask
  401:     empty_multiindex = df.loc[df.loc[:, "value"] == 0, :].index
  402:     result = df.loc[empty_multiindex, :]
  403:     expected = df.loc[[False] * len(df.index), :]
  404:     tm.assert_frame_equal(result, expected)
  405: 
  406:     # replacing value with loc on empty multiindex
  407:     df.loc[df.loc[df.loc[:, "value"] == 0].index, "value"] = 5
  408:     result = df
  409:     expected = DataFrame([1, 2, 3, 4], index=index, columns=["value"])
  410:     tm.assert_frame_equal(result, expected)
