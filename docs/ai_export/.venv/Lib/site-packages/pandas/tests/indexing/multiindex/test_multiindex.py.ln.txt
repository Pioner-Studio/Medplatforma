    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas._libs.index as libindex
    5: from pandas.errors import PerformanceWarning
    6: 
    7: import pandas as pd
    8: from pandas import (
    9:     CategoricalDtype,
   10:     DataFrame,
   11:     Index,
   12:     MultiIndex,
   13:     Series,
   14: )
   15: import pandas._testing as tm
   16: from pandas.core.arrays.boolean import BooleanDtype
   17: 
   18: 
   19: class TestMultiIndexBasic:
   20:     def test_multiindex_perf_warn(self):
   21:         df = DataFrame(
   22:             {
   23:                 "jim": [0, 0, 1, 1],
   24:                 "joe": ["x", "x", "z", "y"],
   25:                 "jolie": np.random.default_rng(2).random(4),
   26:             }
   27:         ).set_index(["jim", "joe"])
   28: 
   29:         with tm.assert_produces_warning(PerformanceWarning):
   30:             df.loc[(1, "z")]
   31: 
   32:         df = df.iloc[[2, 1, 3, 0]]
   33:         with tm.assert_produces_warning(PerformanceWarning):
   34:             df.loc[(0,)]
   35: 
   36:     @pytest.mark.parametrize("offset", [-5, 5])
   37:     def test_indexing_over_hashtable_size_cutoff(self, monkeypatch, offset):
   38:         size_cutoff = 20
   39:         n = size_cutoff + offset
   40: 
   41:         with monkeypatch.context():
   42:             monkeypatch.setattr(libindex, "_SIZE_CUTOFF", size_cutoff)
   43:             s = Series(np.arange(n), MultiIndex.from_arrays((["a"] * n, np.arange(n))))
   44: 
   45:             # hai it works!
   46:             assert s[("a", 5)] == 5
   47:             assert s[("a", 6)] == 6
   48:             assert s[("a", 7)] == 7
   49: 
   50:     def test_multi_nan_indexing(self):
   51:         # GH 3588
   52:         df = DataFrame(
   53:             {
   54:                 "a": ["R1", "R2", np.nan, "R4"],
   55:                 "b": ["C1", "C2", "C3", "C4"],
   56:                 "c": [10, 15, np.nan, 20],
   57:             }
   58:         )
   59:         result = df.set_index(["a", "b"], drop=False)
   60:         expected = DataFrame(
   61:             {
   62:                 "a": ["R1", "R2", np.nan, "R4"],
   63:                 "b": ["C1", "C2", "C3", "C4"],
   64:                 "c": [10, 15, np.nan, 20],
   65:             },
   66:             index=[
   67:                 Index(["R1", "R2", np.nan, "R4"], name="a"),
   68:                 Index(["C1", "C2", "C3", "C4"], name="b"),
   69:             ],
   70:         )
   71:         tm.assert_frame_equal(result, expected)
   72: 
   73:     def test_exclusive_nat_column_indexing(self):
   74:         # GH 38025
   75:         # test multi indexing when one column exclusively contains NaT values
   76:         df = DataFrame(
   77:             {
   78:                 "a": [pd.NaT, pd.NaT, pd.NaT, pd.NaT],
   79:                 "b": ["C1", "C2", "C3", "C4"],
   80:                 "c": [10, 15, np.nan, 20],
   81:             }
   82:         )
   83:         df = df.set_index(["a", "b"])
   84:         expected = DataFrame(
   85:             {
   86:                 "c": [10, 15, np.nan, 20],
   87:             },
   88:             index=[
   89:                 Index([pd.NaT, pd.NaT, pd.NaT, pd.NaT], name="a"),
   90:                 Index(["C1", "C2", "C3", "C4"], name="b"),
   91:             ],
   92:         )
   93:         tm.assert_frame_equal(df, expected)
   94: 
   95:     def test_nested_tuples_duplicates(self):
   96:         # GH#30892
   97: 
   98:         dti = pd.to_datetime(["20190101", "20190101", "20190102"])
   99:         idx = Index(["a", "a", "c"])
  100:         mi = MultiIndex.from_arrays([dti, idx], names=["index1", "index2"])
  101: 
  102:         df = DataFrame({"c1": [1, 2, 3], "c2": [np.nan, np.nan, np.nan]}, index=mi)
  103: 
  104:         expected = DataFrame({"c1": df["c1"], "c2": [1.0, 1.0, np.nan]}, index=mi)
  105: 
  106:         df2 = df.copy(deep=True)
  107:         df2.loc[(dti[0], "a"), "c2"] = 1.0
  108:         tm.assert_frame_equal(df2, expected)
  109: 
  110:         df3 = df.copy(deep=True)
  111:         df3.loc[[(dti[0], "a")], "c2"] = 1.0
  112:         tm.assert_frame_equal(df3, expected)
  113: 
  114:     def test_multiindex_with_datatime_level_preserves_freq(self):
  115:         # https://github.com/pandas-dev/pandas/issues/35563
  116:         idx = Index(range(2), name="A")
  117:         dti = pd.date_range("2020-01-01", periods=7, freq="D", name="B")
  118:         mi = MultiIndex.from_product([idx, dti])
  119:         df = DataFrame(np.random.default_rng(2).standard_normal((14, 2)), index=mi)
  120:         result = df.loc[0].index
  121:         tm.assert_index_equal(result, dti)
  122:         assert result.freq == dti.freq
  123: 
  124:     def test_multiindex_complex(self):
  125:         # GH#42145
  126:         complex_data = [1 + 2j, 4 - 3j, 10 - 1j]
  127:         non_complex_data = [3, 4, 5]
  128:         result = DataFrame(
  129:             {
  130:                 "x": complex_data,
  131:                 "y": non_complex_data,
  132:                 "z": non_complex_data,
  133:             }
  134:         )
  135:         result.set_index(["x", "y"], inplace=True)
  136:         expected = DataFrame(
  137:             {"z": non_complex_data},
  138:             index=MultiIndex.from_arrays(
  139:                 [complex_data, non_complex_data],
  140:                 names=("x", "y"),
  141:             ),
  142:         )
  143:         tm.assert_frame_equal(result, expected)
  144: 
  145:     def test_rename_multiindex_with_duplicates(self):
  146:         # GH 38015
  147:         mi = MultiIndex.from_tuples([("A", "cat"), ("B", "cat"), ("B", "cat")])
  148:         df = DataFrame(index=mi)
  149:         df = df.rename(index={"A": "Apple"}, level=0)
  150: 
  151:         mi2 = MultiIndex.from_tuples([("Apple", "cat"), ("B", "cat"), ("B", "cat")])
  152:         expected = DataFrame(index=mi2)
  153:         tm.assert_frame_equal(df, expected)
  154: 
  155:     def test_series_align_multiindex_with_nan_overlap_only(self):
  156:         # GH 38439
  157:         mi1 = MultiIndex.from_arrays([[81.0, np.nan], [np.nan, np.nan]])
  158:         mi2 = MultiIndex.from_arrays([[np.nan, 82.0], [np.nan, np.nan]])
  159:         ser1 = Series([1, 2], index=mi1)
  160:         ser2 = Series([1, 2], index=mi2)
  161:         result1, result2 = ser1.align(ser2)
  162: 
  163:         mi = MultiIndex.from_arrays([[81.0, 82.0, np.nan], [np.nan, np.nan, np.nan]])
  164:         expected1 = Series([1.0, np.nan, 2.0], index=mi)
  165:         expected2 = Series([np.nan, 2.0, 1.0], index=mi)
  166: 
  167:         tm.assert_series_equal(result1, expected1)
  168:         tm.assert_series_equal(result2, expected2)
  169: 
  170:     def test_series_align_multiindex_with_nan(self):
  171:         # GH 38439
  172:         mi1 = MultiIndex.from_arrays([[81.0, np.nan], [np.nan, np.nan]])
  173:         mi2 = MultiIndex.from_arrays([[np.nan, 81.0], [np.nan, np.nan]])
  174:         ser1 = Series([1, 2], index=mi1)
  175:         ser2 = Series([1, 2], index=mi2)
  176:         result1, result2 = ser1.align(ser2)
  177: 
  178:         mi = MultiIndex.from_arrays([[81.0, np.nan], [np.nan, np.nan]])
  179:         expected1 = Series([1, 2], index=mi)
  180:         expected2 = Series([2, 1], index=mi)
  181: 
  182:         tm.assert_series_equal(result1, expected1)
  183:         tm.assert_series_equal(result2, expected2)
  184: 
  185:     def test_nunique_smoke(self):
  186:         # GH 34019
  187:         n = DataFrame([[1, 2], [1, 2]]).set_index([0, 1]).index.nunique()
  188:         assert n == 1
  189: 
  190:     def test_multiindex_repeated_keys(self):
  191:         # GH19414
  192:         tm.assert_series_equal(
  193:             Series([1, 2], MultiIndex.from_arrays([["a", "b"]])).loc[
  194:                 ["a", "a", "b", "b"]
  195:             ],
  196:             Series([1, 1, 2, 2], MultiIndex.from_arrays([["a", "a", "b", "b"]])),
  197:         )
  198: 
  199:     def test_multiindex_with_na_missing_key(self):
  200:         # GH46173
  201:         df = DataFrame.from_dict(
  202:             {
  203:                 ("foo",): [1, 2, 3],
  204:                 ("bar",): [5, 6, 7],
  205:                 (None,): [8, 9, 0],
  206:             }
  207:         )
  208:         with pytest.raises(KeyError, match="missing_key"):
  209:             df[[("missing_key",)]]
  210: 
  211:     def test_multiindex_dtype_preservation(self):
  212:         # GH51261
  213:         columns = MultiIndex.from_tuples([("A", "B")], names=["lvl1", "lvl2"])
  214:         df = DataFrame(["value"], columns=columns).astype("category")
  215:         df_no_multiindex = df["A"]
  216:         assert isinstance(df_no_multiindex["B"].dtype, CategoricalDtype)
  217: 
  218:         # geopandas 1763 analogue
  219:         df = DataFrame(
  220:             [[1, 0], [0, 1]],
  221:             columns=[
  222:                 ["foo", "foo"],
  223:                 ["location", "location"],
  224:                 ["x", "y"],
  225:             ],
  226:         ).assign(bools=Series([True, False], dtype="boolean"))
  227:         assert isinstance(df["bools"].dtype, BooleanDtype)
  228: 
  229:     def test_multiindex_from_tuples_with_nan(self):
  230:         # GH#23578
  231:         result = MultiIndex.from_tuples([("a", "b", "c"), np.nan, ("d", "", "")])
  232:         expected = MultiIndex.from_tuples(
  233:             [("a", "b", "c"), (np.nan, np.nan, np.nan), ("d", "", "")]
  234:         )
  235:         tm.assert_index_equal(result, expected)
