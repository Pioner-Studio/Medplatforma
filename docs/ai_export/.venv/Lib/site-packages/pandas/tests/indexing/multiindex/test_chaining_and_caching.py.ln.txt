    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._libs import index as libindex
    5: from pandas.errors import SettingWithCopyError
    6: import pandas.util._test_decorators as td
    7: 
    8: from pandas import (
    9:     DataFrame,
   10:     MultiIndex,
   11:     Series,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: def test_detect_chained_assignment(using_copy_on_write, warn_copy_on_write):
   17:     # Inplace ops, originally from:
   18:     # https://stackoverflow.com/questions/20508968/series-fillna-in-a-multiindex-dataframe-does-not-fill-is-this-a-bug
   19:     a = [12, 23]
   20:     b = [123, None]
   21:     c = [1234, 2345]
   22:     d = [12345, 23456]
   23:     tuples = [("eyes", "left"), ("eyes", "right"), ("ears", "left"), ("ears", "right")]
   24:     events = {
   25:         ("eyes", "left"): a,
   26:         ("eyes", "right"): b,
   27:         ("ears", "left"): c,
   28:         ("ears", "right"): d,
   29:     }
   30:     multiind = MultiIndex.from_tuples(tuples, names=["part", "side"])
   31:     zed = DataFrame(events, index=["a", "b"], columns=multiind)
   32: 
   33:     if using_copy_on_write:
   34:         with tm.raises_chained_assignment_error():
   35:             zed["eyes"]["right"].fillna(value=555, inplace=True)
   36:     elif warn_copy_on_write:
   37:         with tm.assert_produces_warning(None):
   38:             zed["eyes"]["right"].fillna(value=555, inplace=True)
   39:     else:
   40:         msg = "A value is trying to be set on a copy of a slice from a DataFrame"
   41:         with pytest.raises(SettingWithCopyError, match=msg):
   42:             with tm.assert_produces_warning(None):
   43:                 zed["eyes"]["right"].fillna(value=555, inplace=True)
   44: 
   45: 
   46: @td.skip_array_manager_invalid_test  # with ArrayManager df.loc[0] is not a view
   47: def test_cache_updating(using_copy_on_write, warn_copy_on_write):
   48:     # 5216
   49:     # make sure that we don't try to set a dead cache
   50:     a = np.random.default_rng(2).random((10, 3))
   51:     df = DataFrame(a, columns=["x", "y", "z"])
   52:     df_original = df.copy()
   53:     tuples = [(i, j) for i in range(5) for j in range(2)]
   54:     index = MultiIndex.from_tuples(tuples)
   55:     df.index = index
   56: 
   57:     # setting via chained assignment
   58:     # but actually works, since everything is a view
   59: 
   60:     with tm.raises_chained_assignment_error():
   61:         df.loc[0]["z"].iloc[0] = 1.0
   62: 
   63:     if using_copy_on_write:
   64:         assert df.loc[(0, 0), "z"] == df_original.loc[0, "z"]
   65:     else:
   66:         result = df.loc[(0, 0), "z"]
   67:         assert result == 1
   68: 
   69:     # correct setting
   70:     df.loc[(0, 0), "z"] = 2
   71:     result = df.loc[(0, 0), "z"]
   72:     assert result == 2
   73: 
   74: 
   75: def test_indexer_caching(monkeypatch):
   76:     # GH5727
   77:     # make sure that indexers are in the _internal_names_set
   78:     size_cutoff = 20
   79:     with monkeypatch.context():
   80:         monkeypatch.setattr(libindex, "_SIZE_CUTOFF", size_cutoff)
   81:         index = MultiIndex.from_arrays([np.arange(size_cutoff), np.arange(size_cutoff)])
   82:         s = Series(np.zeros(size_cutoff), index=index)
   83: 
   84:         # setitem
   85:         s[s == 0] = 1
   86:     expected = Series(np.ones(size_cutoff), index=index)
   87:     tm.assert_series_equal(s, expected)
