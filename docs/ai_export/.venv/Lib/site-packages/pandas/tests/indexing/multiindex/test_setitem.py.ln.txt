    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import SettingWithCopyError
    5: import pandas.util._test_decorators as td
    6: 
    7: import pandas as pd
    8: from pandas import (
    9:     DataFrame,
   10:     MultiIndex,
   11:     Series,
   12:     date_range,
   13:     isna,
   14:     notna,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: def assert_equal(a, b):
   20:     assert a == b
   21: 
   22: 
   23: class TestMultiIndexSetItem:
   24:     def check(self, target, indexers, value, compare_fn=assert_equal, expected=None):
   25:         target.loc[indexers] = value
   26:         result = target.loc[indexers]
   27:         if expected is None:
   28:             expected = value
   29:         compare_fn(result, expected)
   30: 
   31:     def test_setitem_multiindex(self):
   32:         # GH#7190
   33:         cols = ["A", "w", "l", "a", "x", "X", "d", "profit"]
   34:         index = MultiIndex.from_product(
   35:             [np.arange(0, 100), np.arange(0, 80)], names=["time", "firm"]
   36:         )
   37:         t, n = 0, 2
   38: 
   39:         df = DataFrame(
   40:             np.nan,
   41:             columns=cols,
   42:             index=index,
   43:         )
   44:         self.check(target=df, indexers=((t, n), "X"), value=0)
   45: 
   46:         df = DataFrame(-999, columns=cols, index=index)
   47:         self.check(target=df, indexers=((t, n), "X"), value=1)
   48: 
   49:         df = DataFrame(columns=cols, index=index)
   50:         self.check(target=df, indexers=((t, n), "X"), value=2)
   51: 
   52:         # gh-7218: assigning with 0-dim arrays
   53:         df = DataFrame(-999, columns=cols, index=index)
   54:         self.check(
   55:             target=df,
   56:             indexers=((t, n), "X"),
   57:             value=np.array(3),
   58:             expected=3,
   59:         )
   60: 
   61:     def test_setitem_multiindex2(self):
   62:         # GH#5206
   63:         df = DataFrame(
   64:             np.arange(25).reshape(5, 5), columns="A,B,C,D,E".split(","), dtype=float
   65:         )
   66:         df["F"] = 99
   67:         row_selection = df["A"] % 2 == 0
   68:         col_selection = ["B", "C"]
   69:         df.loc[row_selection, col_selection] = df["F"]
   70:         output = DataFrame(99.0, index=[0, 2, 4], columns=["B", "C"])
   71:         tm.assert_frame_equal(df.loc[row_selection, col_selection], output)
   72:         self.check(
   73:             target=df,
   74:             indexers=(row_selection, col_selection),
   75:             value=df["F"],
   76:             compare_fn=tm.assert_frame_equal,
   77:             expected=output,
   78:         )
   79: 
   80:     def test_setitem_multiindex3(self):
   81:         # GH#11372
   82:         idx = MultiIndex.from_product(
   83:             [["A", "B", "C"], date_range("2015-01-01", "2015-04-01", freq="MS")]
   84:         )
   85:         cols = MultiIndex.from_product(
   86:             [["foo", "bar"], date_range("2016-01-01", "2016-02-01", freq="MS")]
   87:         )
   88: 
   89:         df = DataFrame(
   90:             np.random.default_rng(2).random((12, 4)), index=idx, columns=cols
   91:         )
   92: 
   93:         subidx = MultiIndex.from_arrays(
   94:             [["A", "A"], date_range("2015-01-01", "2015-02-01", freq="MS")]
   95:         )
   96:         subcols = MultiIndex.from_arrays(
   97:             [["foo", "foo"], date_range("2016-01-01", "2016-02-01", freq="MS")]
   98:         )
   99: 
  100:         vals = DataFrame(
  101:             np.random.default_rng(2).random((2, 2)), index=subidx, columns=subcols
  102:         )
  103:         self.check(
  104:             target=df,
  105:             indexers=(subidx, subcols),
  106:             value=vals,
  107:             compare_fn=tm.assert_frame_equal,
  108:         )
  109:         # set all columns
  110:         vals = DataFrame(
  111:             np.random.default_rng(2).random((2, 4)), index=subidx, columns=cols
  112:         )
  113:         self.check(
  114:             target=df,
  115:             indexers=(subidx, slice(None, None, None)),
  116:             value=vals,
  117:             compare_fn=tm.assert_frame_equal,
  118:         )
  119:         # identity
  120:         copy = df.copy()
  121:         self.check(
  122:             target=df,
  123:             indexers=(df.index, df.columns),
  124:             value=df,
  125:             compare_fn=tm.assert_frame_equal,
  126:             expected=copy,
  127:         )
  128: 
  129:     # TODO(ArrayManager) df.loc["bar"] *= 2 doesn't raise an error but results in
  130:     # all NaNs -> doesn't work in the "split" path (also for BlockManager actually)
  131:     @td.skip_array_manager_not_yet_implemented
  132:     def test_multiindex_setitem(self):
  133:         # GH 3738
  134:         # setting with a multi-index right hand side
  135:         arrays = [
  136:             np.array(["bar", "bar", "baz", "qux", "qux", "bar"]),
  137:             np.array(["one", "two", "one", "one", "two", "one"]),
  138:             np.arange(0, 6, 1),
  139:         ]
  140: 
  141:         df_orig = DataFrame(
  142:             np.random.default_rng(2).standard_normal((6, 3)),
  143:             index=arrays,
  144:             columns=["A", "B", "C"],
  145:         ).sort_index()
  146: 
  147:         expected = df_orig.loc[["bar"]] * 2
  148:         df = df_orig.copy()
  149:         df.loc[["bar"]] *= 2
  150:         tm.assert_frame_equal(df.loc[["bar"]], expected)
  151: 
  152:         # raise because these have differing levels
  153:         msg = "cannot align on a multi-index with out specifying the join levels"
  154:         with pytest.raises(TypeError, match=msg):
  155:             df.loc["bar"] *= 2
  156: 
  157:     def test_multiindex_setitem2(self):
  158:         # from SO
  159:         # https://stackoverflow.com/questions/24572040/pandas-access-the-level-of-multiindex-for-inplace-operation
  160:         df_orig = DataFrame.from_dict(
  161:             {
  162:                 "price": {
  163:                     ("DE", "Coal", "Stock"): 2,
  164:                     ("DE", "Gas", "Stock"): 4,
  165:                     ("DE", "Elec", "Demand"): 1,
  166:                     ("FR", "Gas", "Stock"): 5,
  167:                     ("FR", "Solar", "SupIm"): 0,
  168:                     ("FR", "Wind", "SupIm"): 0,
  169:                 }
  170:             }
  171:         )
  172:         df_orig.index = MultiIndex.from_tuples(
  173:             df_orig.index, names=["Sit", "Com", "Type"]
  174:         )
  175: 
  176:         expected = df_orig.copy()
  177:         expected.iloc[[0, 1, 3]] *= 2
  178: 
  179:         idx = pd.IndexSlice
  180:         df = df_orig.copy()
  181:         df.loc[idx[:, :, "Stock"], :] *= 2
  182:         tm.assert_frame_equal(df, expected)
  183: 
  184:         df = df_orig.copy()
  185:         df.loc[idx[:, :, "Stock"], "price"] *= 2
  186:         tm.assert_frame_equal(df, expected)
  187: 
  188:     def test_multiindex_assignment(self):
  189:         # GH3777 part 2
  190: 
  191:         # mixed dtype
  192:         df = DataFrame(
  193:             np.random.default_rng(2).integers(5, 10, size=9).reshape(3, 3),
  194:             columns=list("abc"),
  195:             index=[[4, 4, 8], [8, 10, 12]],
  196:         )
  197:         df["d"] = np.nan
  198:         arr = np.array([0.0, 1.0])
  199: 
  200:         df.loc[4, "d"] = arr
  201:         tm.assert_series_equal(df.loc[4, "d"], Series(arr, index=[8, 10], name="d"))
  202: 
  203:     def test_multiindex_assignment_single_dtype(
  204:         self, using_copy_on_write, warn_copy_on_write
  205:     ):
  206:         # GH3777 part 2b
  207:         # single dtype
  208:         arr = np.array([0.0, 1.0])
  209: 
  210:         df = DataFrame(
  211:             np.random.default_rng(2).integers(5, 10, size=9).reshape(3, 3),
  212:             columns=list("abc"),
  213:             index=[[4, 4, 8], [8, 10, 12]],
  214:             dtype=np.int64,
  215:         )
  216:         view = df["c"].iloc[:2].values
  217: 
  218:         # arr can be losslessly cast to int, so this setitem is inplace
  219:         # INFO(CoW-warn) this does not warn because we directly took .values
  220:         # above, so no reference to a pandas object is alive for `view`
  221:         df.loc[4, "c"] = arr
  222:         exp = Series(arr, index=[8, 10], name="c", dtype="int64")
  223:         result = df.loc[4, "c"]
  224:         tm.assert_series_equal(result, exp)
  225: 
  226:         # extra check for inplace-ness
  227:         if not using_copy_on_write:
  228:             tm.assert_numpy_array_equal(view, exp.values)
  229: 
  230:         # arr + 0.5 cannot be cast losslessly to int, so we upcast
  231:         with tm.assert_produces_warning(
  232:             FutureWarning, match="item of incompatible dtype"
  233:         ):
  234:             df.loc[4, "c"] = arr + 0.5
  235:         result = df.loc[4, "c"]
  236:         exp = exp + 0.5
  237:         tm.assert_series_equal(result, exp)
  238: 
  239:         # scalar ok
  240:         with tm.assert_cow_warning(warn_copy_on_write):
  241:             df.loc[4, "c"] = 10
  242:         exp = Series(10, index=[8, 10], name="c", dtype="float64")
  243:         tm.assert_series_equal(df.loc[4, "c"], exp)
  244: 
  245:         # invalid assignments
  246:         msg = "Must have equal len keys and value when setting with an iterable"
  247:         with pytest.raises(ValueError, match=msg):
  248:             df.loc[4, "c"] = [0, 1, 2, 3]
  249: 
  250:         with pytest.raises(ValueError, match=msg):
  251:             df.loc[4, "c"] = [0]
  252: 
  253:         # But with a length-1 listlike column indexer this behaves like
  254:         #  `df.loc[4, "c"] = 0
  255:         with tm.assert_cow_warning(warn_copy_on_write):
  256:             df.loc[4, ["c"]] = [0]
  257:         assert (df.loc[4, "c"] == 0).all()
  258: 
  259:     def test_groupby_example(self):
  260:         # groupby example
  261:         NUM_ROWS = 100
  262:         NUM_COLS = 10
  263:         col_names = ["A" + num for num in map(str, np.arange(NUM_COLS).tolist())]
  264:         index_cols = col_names[:5]
  265: 
  266:         df = DataFrame(
  267:             np.random.default_rng(2).integers(5, size=(NUM_ROWS, NUM_COLS)),
  268:             dtype=np.int64,
  269:             columns=col_names,
  270:         )
  271:         df = df.set_index(index_cols).sort_index()
  272:         grp = df.groupby(level=index_cols[:4])
  273:         df["new_col"] = np.nan
  274: 
  275:         # we are actually operating on a copy here
  276:         # but in this case, that's ok
  277:         for name, df2 in grp:
  278:             new_vals = np.arange(df2.shape[0])
  279:             df.loc[name, "new_col"] = new_vals
  280: 
  281:     def test_series_setitem(
  282:         self, multiindex_year_month_day_dataframe_random_data, warn_copy_on_write
  283:     ):
  284:         ymd = multiindex_year_month_day_dataframe_random_data
  285:         s = ymd["A"]
  286: 
  287:         with tm.assert_cow_warning(warn_copy_on_write):
  288:             s[2000, 3] = np.nan
  289:         assert isna(s.values[42:65]).all()
  290:         assert notna(s.values[:42]).all()
  291:         assert notna(s.values[65:]).all()
  292: 
  293:         with tm.assert_cow_warning(warn_copy_on_write):
  294:             s[2000, 3, 10] = np.nan
  295:         assert isna(s.iloc[49])
  296: 
  297:         with pytest.raises(KeyError, match="49"):
  298:             # GH#33355 dont fall-back to positional when leading level is int
  299:             s[49]
  300: 
  301:     def test_frame_getitem_setitem_boolean(self, multiindex_dataframe_random_data):
  302:         frame = multiindex_dataframe_random_data
  303:         df = frame.T.copy()
  304:         values = df.values.copy()
  305: 
  306:         result = df[df > 0]
  307:         expected = df.where(df > 0)
  308:         tm.assert_frame_equal(result, expected)
  309: 
  310:         df[df > 0] = 5
  311:         values[values > 0] = 5
  312:         tm.assert_almost_equal(df.values, values)
  313: 
  314:         df[df == 5] = 0
  315:         values[values == 5] = 0
  316:         tm.assert_almost_equal(df.values, values)
  317: 
  318:         # a df that needs alignment first
  319:         df[df[:-1] < 0] = 2
  320:         np.putmask(values[:-1], values[:-1] < 0, 2)
  321:         tm.assert_almost_equal(df.values, values)
  322: 
  323:         with pytest.raises(TypeError, match="boolean values only"):
  324:             df[df * 0] = 2
  325: 
  326:     def test_frame_getitem_setitem_multislice(self):
  327:         levels = [["t1", "t2"], ["a", "b", "c"]]
  328:         codes = [[0, 0, 0, 1, 1], [0, 1, 2, 0, 1]]
  329:         midx = MultiIndex(codes=codes, levels=levels, names=[None, "id"])
  330:         df = DataFrame({"value": [1, 2, 3, 7, 8]}, index=midx)
  331: 
  332:         result = df.loc[:, "value"]
  333:         tm.assert_series_equal(df["value"], result)
  334: 
  335:         result = df.loc[df.index[1:3], "value"]
  336:         tm.assert_series_equal(df["value"][1:3], result)
  337: 
  338:         result = df.loc[:, :]
  339:         tm.assert_frame_equal(df, result)
  340: 
  341:         result = df
  342:         df.loc[:, "value"] = 10
  343:         result["value"] = 10
  344:         tm.assert_frame_equal(df, result)
  345: 
  346:         df.loc[:, :] = 10
  347:         tm.assert_frame_equal(df, result)
  348: 
  349:     def test_frame_setitem_multi_column(self):
  350:         df = DataFrame(
  351:             np.random.default_rng(2).standard_normal((10, 4)),
  352:             columns=[["a", "a", "b", "b"], [0, 1, 0, 1]],
  353:         )
  354: 
  355:         cp = df.copy()
  356:         cp["a"] = cp["b"]
  357:         tm.assert_frame_equal(cp["a"], cp["b"])
  358: 
  359:         # set with ndarray
  360:         cp = df.copy()
  361:         cp["a"] = cp["b"].values
  362:         tm.assert_frame_equal(cp["a"], cp["b"])
  363: 
  364:     def test_frame_setitem_multi_column2(self):
  365:         # ---------------------------------------
  366:         # GH#1803
  367:         columns = MultiIndex.from_tuples([("A", "1"), ("A", "2"), ("B", "1")])
  368:         df = DataFrame(index=[1, 3, 5], columns=columns)
  369: 
  370:         # Works, but adds a column instead of updating the two existing ones
  371:         df["A"] = 0.0  # Doesn't work
  372:         assert (df["A"].values == 0).all()
  373: 
  374:         # it broadcasts
  375:         df["B", "1"] = [1, 2, 3]
  376:         df["A"] = df["B", "1"]
  377: 
  378:         sliced_a1 = df["A", "1"]
  379:         sliced_a2 = df["A", "2"]
  380:         sliced_b1 = df["B", "1"]
  381:         tm.assert_series_equal(sliced_a1, sliced_b1, check_names=False)
  382:         tm.assert_series_equal(sliced_a2, sliced_b1, check_names=False)
  383:         assert sliced_a1.name == ("A", "1")
  384:         assert sliced_a2.name == ("A", "2")
  385:         assert sliced_b1.name == ("B", "1")
  386: 
  387:     def test_loc_getitem_tuple_plus_columns(
  388:         self, multiindex_year_month_day_dataframe_random_data
  389:     ):
  390:         # GH #1013
  391:         ymd = multiindex_year_month_day_dataframe_random_data
  392:         df = ymd[:5]
  393: 
  394:         result = df.loc[(2000, 1, 6), ["A", "B", "C"]]
  395:         expected = df.loc[2000, 1, 6][["A", "B", "C"]]
  396:         tm.assert_series_equal(result, expected)
  397: 
  398:     @pytest.mark.filterwarnings("ignore:Setting a value on a view:FutureWarning")
  399:     def test_loc_getitem_setitem_slice_integers(self, frame_or_series):
  400:         index = MultiIndex(
  401:             levels=[[0, 1, 2], [0, 2]], codes=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]]
  402:         )
  403: 
  404:         obj = DataFrame(
  405:             np.random.default_rng(2).standard_normal((len(index), 4)),
  406:             index=index,
  407:             columns=["a", "b", "c", "d"],
  408:         )
  409:         obj = tm.get_obj(obj, frame_or_series)
  410: 
  411:         res = obj.loc[1:2]
  412:         exp = obj.reindex(obj.index[2:])
  413:         tm.assert_equal(res, exp)
  414: 
  415:         obj.loc[1:2] = 7
  416:         assert (obj.loc[1:2] == 7).values.all()
  417: 
  418:     def test_setitem_change_dtype(self, multiindex_dataframe_random_data):
  419:         frame = multiindex_dataframe_random_data
  420:         dft = frame.T
  421:         s = dft["foo", "two"]
  422:         dft["foo", "two"] = s > s.median()
  423:         tm.assert_series_equal(dft["foo", "two"], s > s.median())
  424:         # assert isinstance(dft._data.blocks[1].items, MultiIndex)
  425: 
  426:         reindexed = dft.reindex(columns=[("foo", "two")])
  427:         tm.assert_series_equal(reindexed["foo", "two"], s > s.median())
  428: 
  429:     def test_set_column_scalar_with_loc(
  430:         self, multiindex_dataframe_random_data, using_copy_on_write, warn_copy_on_write
  431:     ):
  432:         frame = multiindex_dataframe_random_data
  433:         subset = frame.index[[1, 4, 5]]
  434: 
  435:         frame.loc[subset] = 99
  436:         assert (frame.loc[subset].values == 99).all()
  437: 
  438:         frame_original = frame.copy()
  439:         col = frame["B"]
  440:         with tm.assert_cow_warning(warn_copy_on_write):
  441:             col[subset] = 97
  442:         if using_copy_on_write:
  443:             # chained setitem doesn't work with CoW
  444:             tm.assert_frame_equal(frame, frame_original)
  445:         else:
  446:             assert (frame.loc[subset, "B"] == 97).all()
  447: 
  448:     def test_nonunique_assignment_1750(self):
  449:         df = DataFrame(
  450:             [[1, 1, "x", "X"], [1, 1, "y", "Y"], [1, 2, "z", "Z"]], columns=list("ABCD")
  451:         )
  452: 
  453:         df = df.set_index(["A", "B"])
  454:         mi = MultiIndex.from_tuples([(1, 1)])
  455: 
  456:         df.loc[mi, "C"] = "_"
  457: 
  458:         assert (df.xs((1, 1))["C"] == "_").all()
  459: 
  460:     def test_astype_assignment_with_dups(self):
  461:         # GH 4686
  462:         # assignment with dups that has a dtype change
  463:         cols = MultiIndex.from_tuples([("A", "1"), ("B", "1"), ("A", "2")])
  464:         df = DataFrame(np.arange(3).reshape((1, 3)), columns=cols, dtype=object)
  465:         index = df.index.copy()
  466: 
  467:         df["A"] = df["A"].astype(np.float64)
  468:         tm.assert_index_equal(df.index, index)
  469: 
  470:     def test_setitem_nonmonotonic(self):
  471:         # https://github.com/pandas-dev/pandas/issues/31449
  472:         index = MultiIndex.from_tuples(
  473:             [("a", "c"), ("b", "x"), ("a", "d")], names=["l1", "l2"]
  474:         )
  475:         df = DataFrame(data=[0, 1, 2], index=index, columns=["e"])
  476:         df.loc["a", "e"] = np.arange(99, 101, dtype="int64")
  477:         expected = DataFrame({"e": [99, 1, 100]}, index=index)
  478:         tm.assert_frame_equal(df, expected)
  479: 
  480: 
  481: class TestSetitemWithExpansionMultiIndex:
  482:     def test_setitem_new_column_mixed_depth(self):
  483:         arrays = [
  484:             ["a", "top", "top", "routine1", "routine1", "routine2"],
  485:             ["", "OD", "OD", "result1", "result2", "result1"],
  486:             ["", "wx", "wy", "", "", ""],
  487:         ]
  488: 
  489:         tuples = sorted(zip(*arrays))
  490:         index = MultiIndex.from_tuples(tuples)
  491:         df = DataFrame(np.random.default_rng(2).standard_normal((4, 6)), columns=index)
  492: 
  493:         result = df.copy()
  494:         expected = df.copy()
  495:         result["b"] = [1, 2, 3, 4]
  496:         expected["b", "", ""] = [1, 2, 3, 4]
  497:         tm.assert_frame_equal(result, expected)
  498: 
  499:     def test_setitem_new_column_all_na(self):
  500:         # GH#1534
  501:         mix = MultiIndex.from_tuples([("1a", "2a"), ("1a", "2b"), ("1a", "2c")])
  502:         df = DataFrame([[1, 2], [3, 4], [5, 6]], index=mix)
  503:         s = Series({(1, 1): 1, (1, 2): 2})
  504:         df["new"] = s
  505:         assert df["new"].isna().all()
  506: 
  507:     def test_setitem_enlargement_keep_index_names(self):
  508:         # GH#53053
  509:         mi = MultiIndex.from_tuples([(1, 2, 3)], names=["i1", "i2", "i3"])
  510:         df = DataFrame(data=[[10, 20, 30]], index=mi, columns=["A", "B", "C"])
  511:         df.loc[(0, 0, 0)] = df.loc[(1, 2, 3)]
  512:         mi_expected = MultiIndex.from_tuples(
  513:             [(1, 2, 3), (0, 0, 0)], names=["i1", "i2", "i3"]
  514:         )
  515:         expected = DataFrame(
  516:             data=[[10, 20, 30], [10, 20, 30]],
  517:             index=mi_expected,
  518:             columns=["A", "B", "C"],
  519:         )
  520:         tm.assert_frame_equal(df, expected)
  521: 
  522: 
  523: @td.skip_array_manager_invalid_test  # df["foo"] select multiple columns -> .values
  524: # is not a view
  525: def test_frame_setitem_view_direct(
  526:     multiindex_dataframe_random_data, using_copy_on_write
  527: ):
  528:     # this works because we are modifying the underlying array
  529:     # really a no-no
  530:     df = multiindex_dataframe_random_data.T
  531:     if using_copy_on_write:
  532:         with pytest.raises(ValueError, match="read-only"):
  533:             df["foo"].values[:] = 0
  534:         assert (df["foo"].values != 0).all()
  535:     else:
  536:         df["foo"].values[:] = 0
  537:         assert (df["foo"].values == 0).all()
  538: 
  539: 
  540: def test_frame_setitem_copy_raises(
  541:     multiindex_dataframe_random_data, using_copy_on_write, warn_copy_on_write
  542: ):
  543:     # will raise/warn as its chained assignment
  544:     df = multiindex_dataframe_random_data.T
  545:     if using_copy_on_write or warn_copy_on_write:
  546:         with tm.raises_chained_assignment_error():
  547:             df["foo"]["one"] = 2
  548:     else:
  549:         msg = "A value is trying to be set on a copy of a slice from a DataFrame"
  550:         with pytest.raises(SettingWithCopyError, match=msg):
  551:             with tm.raises_chained_assignment_error():
  552:                 df["foo"]["one"] = 2
  553: 
  554: 
  555: def test_frame_setitem_copy_no_write(
  556:     multiindex_dataframe_random_data, using_copy_on_write, warn_copy_on_write
  557: ):
  558:     frame = multiindex_dataframe_random_data.T
  559:     expected = frame
  560:     df = frame.copy()
  561:     if using_copy_on_write or warn_copy_on_write:
  562:         with tm.raises_chained_assignment_error():
  563:             df["foo"]["one"] = 2
  564:     else:
  565:         msg = "A value is trying to be set on a copy of a slice from a DataFrame"
  566:         with pytest.raises(SettingWithCopyError, match=msg):
  567:             with tm.raises_chained_assignment_error():
  568:                 df["foo"]["one"] = 2
  569: 
  570:     result = df
  571:     tm.assert_frame_equal(result, expected)
  572: 
  573: 
  574: def test_frame_setitem_partial_multiindex():
  575:     # GH 54875
  576:     df = DataFrame(
  577:         {
  578:             "a": [1, 2, 3],
  579:             "b": [3, 4, 5],
  580:             "c": 6,
  581:             "d": 7,
  582:         }
  583:     ).set_index(["a", "b", "c"])
  584:     ser = Series(8, index=df.index.droplevel("c"))
  585:     result = df.copy()
  586:     result["d"] = ser
  587:     expected = df.copy()
  588:     expected["d"] = 8
  589:     tm.assert_frame_equal(result, expected)
