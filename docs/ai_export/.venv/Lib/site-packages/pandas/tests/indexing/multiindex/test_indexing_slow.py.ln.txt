    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     DataFrame,
    7:     Series,
    8: )
    9: import pandas._testing as tm
   10: 
   11: 
   12: @pytest.fixture
   13: def m():
   14:     return 5
   15: 
   16: 
   17: @pytest.fixture
   18: def n():
   19:     return 100
   20: 
   21: 
   22: @pytest.fixture
   23: def cols():
   24:     return ["jim", "joe", "jolie", "joline", "jolia"]
   25: 
   26: 
   27: @pytest.fixture
   28: def vals(n):
   29:     vals = [
   30:         np.random.default_rng(2).integers(0, 10, n),
   31:         np.random.default_rng(2).choice(list("abcdefghij"), n),
   32:         np.random.default_rng(2).choice(
   33:             pd.date_range("20141009", periods=10).tolist(), n
   34:         ),
   35:         np.random.default_rng(2).choice(list("ZYXWVUTSRQ"), n),
   36:         np.random.default_rng(2).standard_normal(n),
   37:     ]
   38:     vals = list(map(tuple, zip(*vals)))
   39:     return vals
   40: 
   41: 
   42: @pytest.fixture
   43: def keys(n, m, vals):
   44:     # bunch of keys for testing
   45:     keys = [
   46:         np.random.default_rng(2).integers(0, 11, m),
   47:         np.random.default_rng(2).choice(list("abcdefghijk"), m),
   48:         np.random.default_rng(2).choice(
   49:             pd.date_range("20141009", periods=11).tolist(), m
   50:         ),
   51:         np.random.default_rng(2).choice(list("ZYXWVUTSRQP"), m),
   52:     ]
   53:     keys = list(map(tuple, zip(*keys)))
   54:     keys += [t[:-1] for t in vals[:: n // m]]
   55:     return keys
   56: 
   57: 
   58: # covers both unique index and non-unique index
   59: @pytest.fixture
   60: def df(vals, cols):
   61:     return DataFrame(vals, columns=cols)
   62: 
   63: 
   64: @pytest.fixture
   65: def a(df):
   66:     return pd.concat([df, df])
   67: 
   68: 
   69: @pytest.fixture
   70: def b(df, cols):
   71:     return df.drop_duplicates(subset=cols[:-1])
   72: 
   73: 
   74: @pytest.mark.filterwarnings("ignore::pandas.errors.PerformanceWarning")
   75: @pytest.mark.parametrize("lexsort_depth", list(range(5)))
   76: @pytest.mark.parametrize("frame_fixture", ["a", "b"])
   77: def test_multiindex_get_loc(request, lexsort_depth, keys, frame_fixture, cols):
   78:     # GH7724, GH2646
   79: 
   80:     frame = request.getfixturevalue(frame_fixture)
   81:     if lexsort_depth == 0:
   82:         df = frame.copy(deep=False)
   83:     else:
   84:         df = frame.sort_values(by=cols[:lexsort_depth])
   85: 
   86:     mi = df.set_index(cols[:-1])
   87:     assert not mi.index._lexsort_depth < lexsort_depth
   88:     for key in keys:
   89:         mask = np.ones(len(df), dtype=bool)
   90: 
   91:         # test for all partials of this key
   92:         for i, k in enumerate(key):
   93:             mask &= df.iloc[:, i] == k
   94: 
   95:             if not mask.any():
   96:                 assert key[: i + 1] not in mi.index
   97:                 continue
   98: 
   99:             assert key[: i + 1] in mi.index
  100:             right = df[mask].copy(deep=False)
  101: 
  102:             if i + 1 != len(key):  # partial key
  103:                 return_value = right.drop(cols[: i + 1], axis=1, inplace=True)
  104:                 assert return_value is None
  105:                 return_value = right.set_index(cols[i + 1 : -1], inplace=True)
  106:                 assert return_value is None
  107:                 tm.assert_frame_equal(mi.loc[key[: i + 1]], right)
  108: 
  109:             else:  # full key
  110:                 return_value = right.set_index(cols[:-1], inplace=True)
  111:                 assert return_value is None
  112:                 if len(right) == 1:  # single hit
  113:                     right = Series(
  114:                         right["jolia"].values, name=right.index[0], index=["jolia"]
  115:                     )
  116:                     tm.assert_series_equal(mi.loc[key[: i + 1]], right)
  117:                 else:  # multi hit
  118:                     tm.assert_frame_equal(mi.loc[key[: i + 1]], right)
