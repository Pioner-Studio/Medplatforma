    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas.util._test_decorators as td
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     Categorical,
   11:     CategoricalDtype,
   12:     CategoricalIndex,
   13:     DataFrame,
   14:     Index,
   15:     Interval,
   16:     Series,
   17:     Timedelta,
   18:     Timestamp,
   19:     option_context,
   20: )
   21: import pandas._testing as tm
   22: 
   23: 
   24: @pytest.fixture
   25: def df():
   26:     return DataFrame(
   27:         {
   28:             "A": np.arange(6, dtype="int64"),
   29:         },
   30:         index=CategoricalIndex(
   31:             list("aabbca"), dtype=CategoricalDtype(list("cab")), name="B"
   32:         ),
   33:     )
   34: 
   35: 
   36: @pytest.fixture
   37: def df2():
   38:     return DataFrame(
   39:         {
   40:             "A": np.arange(6, dtype="int64"),
   41:         },
   42:         index=CategoricalIndex(
   43:             list("aabbca"), dtype=CategoricalDtype(list("cabe")), name="B"
   44:         ),
   45:     )
   46: 
   47: 
   48: class TestCategoricalIndex:
   49:     def test_loc_scalar(self, df):
   50:         dtype = CategoricalDtype(list("cab"))
   51:         result = df.loc["a"]
   52:         bidx = Series(list("aaa"), name="B").astype(dtype)
   53:         assert bidx.dtype == dtype
   54: 
   55:         expected = DataFrame({"A": [0, 1, 5]}, index=Index(bidx))
   56:         tm.assert_frame_equal(result, expected)
   57: 
   58:         df = df.copy()
   59:         df.loc["a"] = 20
   60:         bidx2 = Series(list("aabbca"), name="B").astype(dtype)
   61:         assert bidx2.dtype == dtype
   62:         expected = DataFrame(
   63:             {
   64:                 "A": [20, 20, 2, 3, 4, 20],
   65:             },
   66:             index=Index(bidx2),
   67:         )
   68:         tm.assert_frame_equal(df, expected)
   69: 
   70:         # value not in the categories
   71:         with pytest.raises(KeyError, match=r"^'d'$"):
   72:             df.loc["d"]
   73: 
   74:         df2 = df.copy()
   75:         expected = df2.copy()
   76:         expected.index = expected.index.astype(object)
   77:         expected.loc["d"] = 10
   78:         df2.loc["d"] = 10
   79:         tm.assert_frame_equal(df2, expected)
   80: 
   81:     def test_loc_setitem_with_expansion_non_category(self, df):
   82:         # Setting-with-expansion with a new key "d" that is not among caegories
   83:         df.loc["a"] = 20
   84: 
   85:         # Setting a new row on an existing column
   86:         df3 = df.copy()
   87:         df3.loc["d", "A"] = 10
   88:         bidx3 = Index(list("aabbcad"), name="B")
   89:         expected3 = DataFrame(
   90:             {
   91:                 "A": [20, 20, 2, 3, 4, 20, 10.0],
   92:             },
   93:             index=Index(bidx3),
   94:         )
   95:         tm.assert_frame_equal(df3, expected3)
   96: 
   97:         # Setting a new row _and_ new column
   98:         df4 = df.copy()
   99:         df4.loc["d", "C"] = 10
  100:         expected3 = DataFrame(
  101:             {
  102:                 "A": [20, 20, 2, 3, 4, 20, np.nan],
  103:                 "C": [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, 10],
  104:             },
  105:             index=Index(bidx3),
  106:         )
  107:         tm.assert_frame_equal(df4, expected3)
  108: 
  109:     def test_loc_getitem_scalar_non_category(self, df):
  110:         with pytest.raises(KeyError, match="^1$"):
  111:             df.loc[1]
  112: 
  113:     def test_slicing(self):
  114:         cat = Series(Categorical([1, 2, 3, 4]))
  115:         reverse = cat[::-1]
  116:         exp = np.array([4, 3, 2, 1], dtype=np.int64)
  117:         tm.assert_numpy_array_equal(reverse.__array__(), exp)
  118: 
  119:         df = DataFrame({"value": (np.arange(100) + 1).astype("int64")})
  120:         df["D"] = pd.cut(df.value, bins=[0, 25, 50, 75, 100])
  121: 
  122:         expected = Series([11, Interval(0, 25)], index=["value", "D"], name=10)
  123:         result = df.iloc[10]
  124:         tm.assert_series_equal(result, expected)
  125: 
  126:         expected = DataFrame(
  127:             {"value": np.arange(11, 21).astype("int64")},
  128:             index=np.arange(10, 20).astype("int64"),
  129:         )
  130:         expected["D"] = pd.cut(expected.value, bins=[0, 25, 50, 75, 100])
  131:         result = df.iloc[10:20]
  132:         tm.assert_frame_equal(result, expected)
  133: 
  134:         expected = Series([9, Interval(0, 25)], index=["value", "D"], name=8)
  135:         result = df.loc[8]
  136:         tm.assert_series_equal(result, expected)
  137: 
  138:     def test_slicing_and_getting_ops(self):
  139:         # systematically test the slicing operations:
  140:         #  for all slicing ops:
  141:         #   - returning a dataframe
  142:         #   - returning a column
  143:         #   - returning a row
  144:         #   - returning a single value
  145: 
  146:         cats = Categorical(
  147:             ["a", "c", "b", "c", "c", "c", "c"], categories=["a", "b", "c"]
  148:         )
  149:         idx = Index(["h", "i", "j", "k", "l", "m", "n"])
  150:         values = [1, 2, 3, 4, 5, 6, 7]
  151:         df = DataFrame({"cats": cats, "values": values}, index=idx)
  152: 
  153:         # the expected values
  154:         cats2 = Categorical(["b", "c"], categories=["a", "b", "c"])
  155:         idx2 = Index(["j", "k"])
  156:         values2 = [3, 4]
  157: 
  158:         # 2:4,: | "j":"k",:
  159:         exp_df = DataFrame({"cats": cats2, "values": values2}, index=idx2)
  160: 
  161:         # :,"cats" | :,0
  162:         exp_col = Series(cats, index=idx, name="cats")
  163: 
  164:         # "j",: | 2,:
  165:         exp_row = Series(["b", 3], index=["cats", "values"], dtype="object", name="j")
  166: 
  167:         # "j","cats | 2,0
  168:         exp_val = "b"
  169: 
  170:         # iloc
  171:         # frame
  172:         res_df = df.iloc[2:4, :]
  173:         tm.assert_frame_equal(res_df, exp_df)
  174:         assert isinstance(res_df["cats"].dtype, CategoricalDtype)
  175: 
  176:         # row
  177:         res_row = df.iloc[2, :]
  178:         tm.assert_series_equal(res_row, exp_row)
  179:         assert isinstance(res_row["cats"], str)
  180: 
  181:         # col
  182:         res_col = df.iloc[:, 0]
  183:         tm.assert_series_equal(res_col, exp_col)
  184:         assert isinstance(res_col.dtype, CategoricalDtype)
  185: 
  186:         # single value
  187:         res_val = df.iloc[2, 0]
  188:         assert res_val == exp_val
  189: 
  190:         # loc
  191:         # frame
  192:         res_df = df.loc["j":"k", :]
  193:         tm.assert_frame_equal(res_df, exp_df)
  194:         assert isinstance(res_df["cats"].dtype, CategoricalDtype)
  195: 
  196:         # row
  197:         res_row = df.loc["j", :]
  198:         tm.assert_series_equal(res_row, exp_row)
  199:         assert isinstance(res_row["cats"], str)
  200: 
  201:         # col
  202:         res_col = df.loc[:, "cats"]
  203:         tm.assert_series_equal(res_col, exp_col)
  204:         assert isinstance(res_col.dtype, CategoricalDtype)
  205: 
  206:         # single value
  207:         res_val = df.loc["j", "cats"]
  208:         assert res_val == exp_val
  209: 
  210:         # single value
  211:         res_val = df.loc["j", df.columns[0]]
  212:         assert res_val == exp_val
  213: 
  214:         # iat
  215:         res_val = df.iat[2, 0]
  216:         assert res_val == exp_val
  217: 
  218:         # at
  219:         res_val = df.at["j", "cats"]
  220:         assert res_val == exp_val
  221: 
  222:         # fancy indexing
  223:         exp_fancy = df.iloc[[2]]
  224: 
  225:         res_fancy = df[df["cats"] == "b"]
  226:         tm.assert_frame_equal(res_fancy, exp_fancy)
  227:         res_fancy = df[df["values"] == 3]
  228:         tm.assert_frame_equal(res_fancy, exp_fancy)
  229: 
  230:         # get_value
  231:         res_val = df.at["j", "cats"]
  232:         assert res_val == exp_val
  233: 
  234:         # i : int, slice, or sequence of integers
  235:         res_row = df.iloc[2]
  236:         tm.assert_series_equal(res_row, exp_row)
  237:         assert isinstance(res_row["cats"], str)
  238: 
  239:         res_df = df.iloc[slice(2, 4)]
  240:         tm.assert_frame_equal(res_df, exp_df)
  241:         assert isinstance(res_df["cats"].dtype, CategoricalDtype)
  242: 
  243:         res_df = df.iloc[[2, 3]]
  244:         tm.assert_frame_equal(res_df, exp_df)
  245:         assert isinstance(res_df["cats"].dtype, CategoricalDtype)
  246: 
  247:         res_col = df.iloc[:, 0]
  248:         tm.assert_series_equal(res_col, exp_col)
  249:         assert isinstance(res_col.dtype, CategoricalDtype)
  250: 
  251:         res_df = df.iloc[:, slice(0, 2)]
  252:         tm.assert_frame_equal(res_df, df)
  253:         assert isinstance(res_df["cats"].dtype, CategoricalDtype)
  254: 
  255:         res_df = df.iloc[:, [0, 1]]
  256:         tm.assert_frame_equal(res_df, df)
  257:         assert isinstance(res_df["cats"].dtype, CategoricalDtype)
  258: 
  259:     def test_slicing_doc_examples(self):
  260:         # GH 7918
  261:         cats = Categorical(
  262:             ["a", "b", "b", "b", "c", "c", "c"], categories=["a", "b", "c"]
  263:         )
  264:         idx = Index(["h", "i", "j", "k", "l", "m", "n"])
  265:         values = [1, 2, 2, 2, 3, 4, 5]
  266:         df = DataFrame({"cats": cats, "values": values}, index=idx)
  267: 
  268:         result = df.iloc[2:4, :]
  269:         expected = DataFrame(
  270:             {
  271:                 "cats": Categorical(["b", "b"], categories=["a", "b", "c"]),
  272:                 "values": [2, 2],
  273:             },
  274:             index=["j", "k"],
  275:         )
  276:         tm.assert_frame_equal(result, expected)
  277: 
  278:         result = df.iloc[2:4, :].dtypes
  279:         expected = Series(["category", "int64"], ["cats", "values"], dtype=object)
  280:         tm.assert_series_equal(result, expected)
  281: 
  282:         result = df.loc["h":"j", "cats"]
  283:         expected = Series(
  284:             Categorical(["a", "b", "b"], categories=["a", "b", "c"]),
  285:             index=["h", "i", "j"],
  286:             name="cats",
  287:         )
  288:         tm.assert_series_equal(result, expected)
  289: 
  290:         result = df.loc["h":"j", df.columns[0:1]]
  291:         expected = DataFrame(
  292:             {"cats": Categorical(["a", "b", "b"], categories=["a", "b", "c"])},
  293:             index=["h", "i", "j"],
  294:         )
  295:         tm.assert_frame_equal(result, expected)
  296: 
  297:     def test_loc_getitem_listlike_labels(self, df):
  298:         # list of labels
  299:         result = df.loc[["c", "a"]]
  300:         expected = df.iloc[[4, 0, 1, 5]]
  301:         tm.assert_frame_equal(result, expected, check_index_type=True)
  302: 
  303:     def test_loc_getitem_listlike_unused_category(self, df2):
  304:         # GH#37901 a label that is in index.categories but not in index
  305:         # listlike containing an element in the categories but not in the values
  306:         with pytest.raises(KeyError, match=re.escape("['e'] not in index")):
  307:             df2.loc[["a", "b", "e"]]
  308: 
  309:     def test_loc_getitem_label_unused_category(self, df2):
  310:         # element in the categories but not in the values
  311:         with pytest.raises(KeyError, match=r"^'e'$"):
  312:             df2.loc["e"]
  313: 
  314:     def test_loc_getitem_non_category(self, df2):
  315:         # not all labels in the categories
  316:         with pytest.raises(KeyError, match=re.escape("['d'] not in index")):
  317:             df2.loc[["a", "d"]]
  318: 
  319:     def test_loc_setitem_expansion_label_unused_category(self, df2):
  320:         # assigning with a label that is in the categories but not in the index
  321:         df = df2.copy()
  322:         df.loc["e"] = 20
  323:         result = df.loc[["a", "b", "e"]]
  324:         exp_index = CategoricalIndex(list("aaabbe"), categories=list("cabe"), name="B")
  325:         expected = DataFrame({"A": [0, 1, 5, 2, 3, 20]}, index=exp_index)
  326:         tm.assert_frame_equal(result, expected)
  327: 
  328:     def test_loc_listlike_dtypes(self):
  329:         # GH 11586
  330: 
  331:         # unique categories and codes
  332:         index = CategoricalIndex(["a", "b", "c"])
  333:         df = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}, index=index)
  334: 
  335:         # unique slice
  336:         res = df.loc[["a", "b"]]
  337:         exp_index = CategoricalIndex(["a", "b"], categories=index.categories)
  338:         exp = DataFrame({"A": [1, 2], "B": [4, 5]}, index=exp_index)
  339:         tm.assert_frame_equal(res, exp, check_index_type=True)
  340: 
  341:         # duplicated slice
  342:         res = df.loc[["a", "a", "b"]]
  343: 
  344:         exp_index = CategoricalIndex(["a", "a", "b"], categories=index.categories)
  345:         exp = DataFrame({"A": [1, 1, 2], "B": [4, 4, 5]}, index=exp_index)
  346:         tm.assert_frame_equal(res, exp, check_index_type=True)
  347: 
  348:         with pytest.raises(KeyError, match=re.escape("['x'] not in index")):
  349:             df.loc[["a", "x"]]
  350: 
  351:     def test_loc_listlike_dtypes_duplicated_categories_and_codes(self):
  352:         # duplicated categories and codes
  353:         index = CategoricalIndex(["a", "b", "a"])
  354:         df = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}, index=index)
  355: 
  356:         # unique slice
  357:         res = df.loc[["a", "b"]]
  358:         exp = DataFrame(
  359:             {"A": [1, 3, 2], "B": [4, 6, 5]}, index=CategoricalIndex(["a", "a", "b"])
  360:         )
  361:         tm.assert_frame_equal(res, exp, check_index_type=True)
  362: 
  363:         # duplicated slice
  364:         res = df.loc[["a", "a", "b"]]
  365:         exp = DataFrame(
  366:             {"A": [1, 3, 1, 3, 2], "B": [4, 6, 4, 6, 5]},
  367:             index=CategoricalIndex(["a", "a", "a", "a", "b"]),
  368:         )
  369:         tm.assert_frame_equal(res, exp, check_index_type=True)
  370: 
  371:         with pytest.raises(KeyError, match=re.escape("['x'] not in index")):
  372:             df.loc[["a", "x"]]
  373: 
  374:     def test_loc_listlike_dtypes_unused_category(self):
  375:         # contains unused category
  376:         index = CategoricalIndex(["a", "b", "a", "c"], categories=list("abcde"))
  377:         df = DataFrame({"A": [1, 2, 3, 4], "B": [5, 6, 7, 8]}, index=index)
  378: 
  379:         res = df.loc[["a", "b"]]
  380:         exp = DataFrame(
  381:             {"A": [1, 3, 2], "B": [5, 7, 6]},
  382:             index=CategoricalIndex(["a", "a", "b"], categories=list("abcde")),
  383:         )
  384:         tm.assert_frame_equal(res, exp, check_index_type=True)
  385: 
  386:         # duplicated slice
  387:         res = df.loc[["a", "a", "b"]]
  388:         exp = DataFrame(
  389:             {"A": [1, 3, 1, 3, 2], "B": [5, 7, 5, 7, 6]},
  390:             index=CategoricalIndex(["a", "a", "a", "a", "b"], categories=list("abcde")),
  391:         )
  392:         tm.assert_frame_equal(res, exp, check_index_type=True)
  393: 
  394:         with pytest.raises(KeyError, match=re.escape("['x'] not in index")):
  395:             df.loc[["a", "x"]]
  396: 
  397:     def test_loc_getitem_listlike_unused_category_raises_keyerror(self):
  398:         # key that is an *unused* category raises
  399:         index = CategoricalIndex(["a", "b", "a", "c"], categories=list("abcde"))
  400:         df = DataFrame({"A": [1, 2, 3, 4], "B": [5, 6, 7, 8]}, index=index)
  401: 
  402:         with pytest.raises(KeyError, match="e"):
  403:             # For comparison, check the scalar behavior
  404:             df.loc["e"]
  405: 
  406:         with pytest.raises(KeyError, match=re.escape("['e'] not in index")):
  407:             df.loc[["a", "e"]]
  408: 
  409:     def test_ix_categorical_index(self):
  410:         # GH 12531
  411:         df = DataFrame(
  412:             np.random.default_rng(2).standard_normal((3, 3)),
  413:             index=list("ABC"),
  414:             columns=list("XYZ"),
  415:         )
  416:         cdf = df.copy()
  417:         cdf.index = CategoricalIndex(df.index)
  418:         cdf.columns = CategoricalIndex(df.columns)
  419: 
  420:         expect = Series(df.loc["A", :], index=cdf.columns, name="A")
  421:         tm.assert_series_equal(cdf.loc["A", :], expect)
  422: 
  423:         expect = Series(df.loc[:, "X"], index=cdf.index, name="X")
  424:         tm.assert_series_equal(cdf.loc[:, "X"], expect)
  425: 
  426:         exp_index = CategoricalIndex(list("AB"), categories=["A", "B", "C"])
  427:         expect = DataFrame(df.loc[["A", "B"], :], columns=cdf.columns, index=exp_index)
  428:         tm.assert_frame_equal(cdf.loc[["A", "B"], :], expect)
  429: 
  430:         exp_columns = CategoricalIndex(list("XY"), categories=["X", "Y", "Z"])
  431:         expect = DataFrame(df.loc[:, ["X", "Y"]], index=cdf.index, columns=exp_columns)
  432:         tm.assert_frame_equal(cdf.loc[:, ["X", "Y"]], expect)
  433: 
  434:     @pytest.mark.parametrize(
  435:         "infer_string", [False, pytest.param(True, marks=td.skip_if_no("pyarrow"))]
  436:     )
  437:     def test_ix_categorical_index_non_unique(self, infer_string):
  438:         # non-unique
  439:         with option_context("future.infer_string", infer_string):
  440:             df = DataFrame(
  441:                 np.random.default_rng(2).standard_normal((3, 3)),
  442:                 index=list("ABA"),
  443:                 columns=list("XYX"),
  444:             )
  445:             cdf = df.copy()
  446:             cdf.index = CategoricalIndex(df.index)
  447:             cdf.columns = CategoricalIndex(df.columns)
  448: 
  449:             exp_index = CategoricalIndex(list("AA"), categories=["A", "B"])
  450:             expect = DataFrame(df.loc["A", :], columns=cdf.columns, index=exp_index)
  451:             tm.assert_frame_equal(cdf.loc["A", :], expect)
  452: 
  453:             exp_columns = CategoricalIndex(list("XX"), categories=["X", "Y"])
  454:             expect = DataFrame(df.loc[:, "X"], index=cdf.index, columns=exp_columns)
  455:             tm.assert_frame_equal(cdf.loc[:, "X"], expect)
  456: 
  457:             expect = DataFrame(
  458:                 df.loc[["A", "B"], :],
  459:                 columns=cdf.columns,
  460:                 index=CategoricalIndex(list("AAB")),
  461:             )
  462:             tm.assert_frame_equal(cdf.loc[["A", "B"], :], expect)
  463: 
  464:             expect = DataFrame(
  465:                 df.loc[:, ["X", "Y"]],
  466:                 index=cdf.index,
  467:                 columns=CategoricalIndex(list("XXY")),
  468:             )
  469:             tm.assert_frame_equal(cdf.loc[:, ["X", "Y"]], expect)
  470: 
  471:     def test_loc_slice(self, df):
  472:         # GH9748
  473:         msg = (
  474:             "cannot do slice indexing on CategoricalIndex with these "
  475:             r"indexers \[1\] of type int"
  476:         )
  477:         with pytest.raises(TypeError, match=msg):
  478:             df.loc[1:5]
  479: 
  480:         result = df.loc["b":"c"]
  481:         expected = df.iloc[[2, 3, 4]]
  482:         tm.assert_frame_equal(result, expected)
  483: 
  484:     def test_loc_and_at_with_categorical_index(self):
  485:         # GH 20629
  486:         df = DataFrame(
  487:             [[1, 2], [3, 4], [5, 6]], index=CategoricalIndex(["A", "B", "C"])
  488:         )
  489: 
  490:         s = df[0]
  491:         assert s.loc["A"] == 1
  492:         assert s.at["A"] == 1
  493: 
  494:         assert df.loc["B", 1] == 4
  495:         assert df.at["B", 1] == 4
  496: 
  497:     @pytest.mark.parametrize(
  498:         "idx_values",
  499:         [
  500:             # python types
  501:             [1, 2, 3],
  502:             [-1, -2, -3],
  503:             [1.5, 2.5, 3.5],
  504:             [-1.5, -2.5, -3.5],
  505:             # numpy int/uint
  506:             *(np.array([1, 2, 3], dtype=dtype) for dtype in tm.ALL_INT_NUMPY_DTYPES),
  507:             # numpy floats
  508:             *(np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in tm.FLOAT_NUMPY_DTYPES),
  509:             # numpy object
  510:             np.array([1, "b", 3.5], dtype=object),
  511:             # pandas scalars
  512:             [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
  513:             [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
  514:             [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
  515:             # pandas Integer arrays
  516:             *(pd.array([1, 2, 3], dtype=dtype) for dtype in tm.ALL_INT_EA_DTYPES),
  517:             # other pandas arrays
  518:             pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
  519:             pd.date_range("2019-01-01", periods=3).array,
  520:             pd.timedelta_range(start="1d", periods=3).array,
  521:         ],
  522:     )
  523:     def test_loc_getitem_with_non_string_categories(self, idx_values, ordered):
  524:         # GH-17569
  525:         cat_idx = CategoricalIndex(idx_values, ordered=ordered)
  526:         df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
  527:         sl = slice(idx_values[0], idx_values[1])
  528: 
  529:         # scalar selection
  530:         result = df.loc[idx_values[0]]
  531:         expected = Series(["foo"], index=["A"], name=idx_values[0])
  532:         tm.assert_series_equal(result, expected)
  533: 
  534:         # list selection
  535:         result = df.loc[idx_values[:2]]
  536:         expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
  537:         tm.assert_frame_equal(result, expected)
  538: 
  539:         # slice selection
  540:         result = df.loc[sl]
  541:         expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
  542:         tm.assert_frame_equal(result, expected)
  543: 
  544:         # scalar assignment
  545:         result = df.copy()
  546:         result.loc[idx_values[0]] = "qux"
  547:         expected = DataFrame({"A": ["qux", "bar", "baz"]}, index=cat_idx)
  548:         tm.assert_frame_equal(result, expected)
  549: 
  550:         # list assignment
  551:         result = df.copy()
  552:         result.loc[idx_values[:2], "A"] = ["qux", "qux2"]
  553:         expected = DataFrame({"A": ["qux", "qux2", "baz"]}, index=cat_idx)
  554:         tm.assert_frame_equal(result, expected)
  555: 
  556:         # slice assignment
  557:         result = df.copy()
  558:         result.loc[sl, "A"] = ["qux", "qux2"]
  559:         expected = DataFrame({"A": ["qux", "qux2", "baz"]}, index=cat_idx)
  560:         tm.assert_frame_equal(result, expected)
  561: 
  562:     def test_getitem_categorical_with_nan(self):
  563:         # GH#41933
  564:         ci = CategoricalIndex(["A", "B", np.nan])
  565: 
  566:         ser = Series(range(3), index=ci)
  567: 
  568:         assert ser[np.nan] == 2
  569:         assert ser.loc[np.nan] == 2
  570: 
  571:         df = DataFrame(ser)
  572:         assert df.loc[np.nan, 0] == 2
  573:         assert df.loc[np.nan][0] == 2
