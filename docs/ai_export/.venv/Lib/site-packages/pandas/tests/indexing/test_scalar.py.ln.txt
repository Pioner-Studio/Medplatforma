    1: """ test scalar indexing, including at and iat """
    2: from datetime import (
    3:     datetime,
    4:     timedelta,
    5: )
    6: import itertools
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas import (
   12:     DataFrame,
   13:     Series,
   14:     Timedelta,
   15:     Timestamp,
   16:     date_range,
   17: )
   18: import pandas._testing as tm
   19: 
   20: 
   21: def generate_indices(f, values=False):
   22:     """
   23:     generate the indices
   24:     if values is True , use the axis values
   25:     is False, use the range
   26:     """
   27:     axes = f.axes
   28:     if values:
   29:         axes = (list(range(len(ax))) for ax in axes)
   30: 
   31:     return itertools.product(*axes)
   32: 
   33: 
   34: class TestScalar:
   35:     @pytest.mark.parametrize("kind", ["series", "frame"])
   36:     @pytest.mark.parametrize("col", ["ints", "uints"])
   37:     def test_iat_set_ints(self, kind, col, request):
   38:         f = request.getfixturevalue(f"{kind}_{col}")
   39:         indices = generate_indices(f, True)
   40:         for i in indices:
   41:             f.iat[i] = 1
   42:             expected = f.values[i]
   43:             tm.assert_almost_equal(expected, 1)
   44: 
   45:     @pytest.mark.parametrize("kind", ["series", "frame"])
   46:     @pytest.mark.parametrize("col", ["labels", "ts", "floats"])
   47:     def test_iat_set_other(self, kind, col, request):
   48:         f = request.getfixturevalue(f"{kind}_{col}")
   49:         msg = "iAt based indexing can only have integer indexers"
   50:         with pytest.raises(ValueError, match=msg):
   51:             idx = next(generate_indices(f, False))
   52:             f.iat[idx] = 1
   53: 
   54:     @pytest.mark.parametrize("kind", ["series", "frame"])
   55:     @pytest.mark.parametrize("col", ["ints", "uints", "labels", "ts", "floats"])
   56:     def test_at_set_ints_other(self, kind, col, request):
   57:         f = request.getfixturevalue(f"{kind}_{col}")
   58:         indices = generate_indices(f, False)
   59:         for i in indices:
   60:             f.at[i] = 1
   61:             expected = f.loc[i]
   62:             tm.assert_almost_equal(expected, 1)
   63: 
   64: 
   65: class TestAtAndiAT:
   66:     # at and iat tests that don't need Base class
   67: 
   68:     def test_float_index_at_iat(self):
   69:         ser = Series([1, 2, 3], index=[0.1, 0.2, 0.3])
   70:         for el, item in ser.items():
   71:             assert ser.at[el] == item
   72:         for i in range(len(ser)):
   73:             assert ser.iat[i] == i + 1
   74: 
   75:     def test_at_iat_coercion(self):
   76:         # as timestamp is not a tuple!
   77:         dates = date_range("1/1/2000", periods=8)
   78:         df = DataFrame(
   79:             np.random.default_rng(2).standard_normal((8, 4)),
   80:             index=dates,
   81:             columns=["A", "B", "C", "D"],
   82:         )
   83:         s = df["A"]
   84: 
   85:         result = s.at[dates[5]]
   86:         xp = s.values[5]
   87:         assert result == xp
   88: 
   89:     @pytest.mark.parametrize(
   90:         "ser, expected",
   91:         [
   92:             [
   93:                 Series(["2014-01-01", "2014-02-02"], dtype="datetime64[ns]"),
   94:                 Timestamp("2014-02-02"),
   95:             ],
   96:             [
   97:                 Series(["1 days", "2 days"], dtype="timedelta64[ns]"),
   98:                 Timedelta("2 days"),
   99:             ],
  100:         ],
  101:     )
  102:     def test_iloc_iat_coercion_datelike(self, indexer_ial, ser, expected):
  103:         # GH 7729
  104:         # make sure we are boxing the returns
  105:         result = indexer_ial(ser)[1]
  106:         assert result == expected
  107: 
  108:     def test_imethods_with_dups(self):
  109:         # GH6493
  110:         # iat/iloc with dups
  111: 
  112:         s = Series(range(5), index=[1, 1, 2, 2, 3], dtype="int64")
  113:         result = s.iloc[2]
  114:         assert result == 2
  115:         result = s.iat[2]
  116:         assert result == 2
  117: 
  118:         msg = "index 10 is out of bounds for axis 0 with size 5"
  119:         with pytest.raises(IndexError, match=msg):
  120:             s.iat[10]
  121:         msg = "index -10 is out of bounds for axis 0 with size 5"
  122:         with pytest.raises(IndexError, match=msg):
  123:             s.iat[-10]
  124: 
  125:         result = s.iloc[[2, 3]]
  126:         expected = Series([2, 3], [2, 2], dtype="int64")
  127:         tm.assert_series_equal(result, expected)
  128: 
  129:         df = s.to_frame()
  130:         result = df.iloc[2]
  131:         expected = Series(2, index=[0], name=2)
  132:         tm.assert_series_equal(result, expected)
  133: 
  134:         result = df.iat[2, 0]
  135:         assert result == 2
  136: 
  137:     def test_frame_at_with_duplicate_axes(self):
  138:         # GH#33041
  139:         arr = np.random.default_rng(2).standard_normal(6).reshape(3, 2)
  140:         df = DataFrame(arr, columns=["A", "A"])
  141: 
  142:         result = df.at[0, "A"]
  143:         expected = df.iloc[0].copy()
  144: 
  145:         tm.assert_series_equal(result, expected)
  146: 
  147:         result = df.T.at["A", 0]
  148:         tm.assert_series_equal(result, expected)
  149: 
  150:         # setter
  151:         df.at[1, "A"] = 2
  152:         expected = Series([2.0, 2.0], index=["A", "A"], name=1)
  153:         tm.assert_series_equal(df.iloc[1], expected)
  154: 
  155:     def test_at_getitem_dt64tz_values(self):
  156:         # gh-15822
  157:         df = DataFrame(
  158:             {
  159:                 "name": ["John", "Anderson"],
  160:                 "date": [
  161:                     Timestamp(2017, 3, 13, 13, 32, 56),
  162:                     Timestamp(2017, 2, 16, 12, 10, 3),
  163:                 ],
  164:             }
  165:         )
  166:         df["date"] = df["date"].dt.tz_localize("Asia/Shanghai")
  167: 
  168:         expected = Timestamp("2017-03-13 13:32:56+0800", tz="Asia/Shanghai")
  169: 
  170:         result = df.loc[0, "date"]
  171:         assert result == expected
  172: 
  173:         result = df.at[0, "date"]
  174:         assert result == expected
  175: 
  176:     def test_mixed_index_at_iat_loc_iloc_series(self):
  177:         # GH 19860
  178:         s = Series([1, 2, 3, 4, 5], index=["a", "b", "c", 1, 2])
  179:         for el, item in s.items():
  180:             assert s.at[el] == s.loc[el] == item
  181:         for i in range(len(s)):
  182:             assert s.iat[i] == s.iloc[i] == i + 1
  183: 
  184:         with pytest.raises(KeyError, match="^4$"):
  185:             s.at[4]
  186:         with pytest.raises(KeyError, match="^4$"):
  187:             s.loc[4]
  188: 
  189:     def test_mixed_index_at_iat_loc_iloc_dataframe(self):
  190:         # GH 19860
  191:         df = DataFrame(
  192:             [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]], columns=["a", "b", "c", 1, 2]
  193:         )
  194:         for rowIdx, row in df.iterrows():
  195:             for el, item in row.items():
  196:                 assert df.at[rowIdx, el] == df.loc[rowIdx, el] == item
  197: 
  198:         for row in range(2):
  199:             for i in range(5):
  200:                 assert df.iat[row, i] == df.iloc[row, i] == row * 5 + i
  201: 
  202:         with pytest.raises(KeyError, match="^3$"):
  203:             df.at[0, 3]
  204:         with pytest.raises(KeyError, match="^3$"):
  205:             df.loc[0, 3]
  206: 
  207:     def test_iat_setter_incompatible_assignment(self):
  208:         # GH 23236
  209:         result = DataFrame({"a": [0.0, 1.0], "b": [4, 5]})
  210:         result.iat[0, 0] = None
  211:         expected = DataFrame({"a": [None, 1], "b": [4, 5]})
  212:         tm.assert_frame_equal(result, expected)
  213: 
  214: 
  215: def test_iat_dont_wrap_object_datetimelike():
  216:     # GH#32809 .iat calls go through DataFrame._get_value, should not
  217:     #  call maybe_box_datetimelike
  218:     dti = date_range("2016-01-01", periods=3)
  219:     tdi = dti - dti
  220:     ser = Series(dti.to_pydatetime(), dtype=object)
  221:     ser2 = Series(tdi.to_pytimedelta(), dtype=object)
  222:     df = DataFrame({"A": ser, "B": ser2})
  223:     assert (df.dtypes == object).all()
  224: 
  225:     for result in [df.at[0, "A"], df.iat[0, 0], df.loc[0, "A"], df.iloc[0, 0]]:
  226:         assert result is ser[0]
  227:         assert isinstance(result, datetime)
  228:         assert not isinstance(result, Timestamp)
  229: 
  230:     for result in [df.at[1, "B"], df.iat[1, 1], df.loc[1, "B"], df.iloc[1, 1]]:
  231:         assert result is ser2[1]
  232:         assert isinstance(result, timedelta)
  233:         assert not isinstance(result, Timedelta)
  234: 
  235: 
  236: def test_at_with_tuple_index_get():
  237:     # GH 26989
  238:     # DataFrame.at getter works with Index of tuples
  239:     df = DataFrame({"a": [1, 2]}, index=[(1, 2), (3, 4)])
  240:     assert df.index.nlevels == 1
  241:     assert df.at[(1, 2), "a"] == 1
  242: 
  243:     # Series.at getter works with Index of tuples
  244:     series = df["a"]
  245:     assert series.index.nlevels == 1
  246:     assert series.at[(1, 2)] == 1
  247: 
  248: 
  249: @pytest.mark.filterwarnings("ignore:Setting a value on a view:FutureWarning")
  250: def test_at_with_tuple_index_set():
  251:     # GH 26989
  252:     # DataFrame.at setter works with Index of tuples
  253:     df = DataFrame({"a": [1, 2]}, index=[(1, 2), (3, 4)])
  254:     assert df.index.nlevels == 1
  255:     df.at[(1, 2), "a"] = 2
  256:     assert df.at[(1, 2), "a"] == 2
  257: 
  258:     # Series.at setter works with Index of tuples
  259:     series = df["a"]
  260:     assert series.index.nlevels == 1
  261:     series.at[1, 2] = 3
  262:     assert series.at[1, 2] == 3
  263: 
  264: 
  265: class TestMultiIndexScalar:
  266:     def test_multiindex_at_get(self):
  267:         # GH 26989
  268:         # DataFrame.at and DataFrame.loc getter works with MultiIndex
  269:         df = DataFrame({"a": [1, 2]}, index=[[1, 2], [3, 4]])
  270:         assert df.index.nlevels == 2
  271:         assert df.at[(1, 3), "a"] == 1
  272:         assert df.loc[(1, 3), "a"] == 1
  273: 
  274:         # Series.at and Series.loc getter works with MultiIndex
  275:         series = df["a"]
  276:         assert series.index.nlevels == 2
  277:         assert series.at[1, 3] == 1
  278:         assert series.loc[1, 3] == 1
  279: 
  280:     @pytest.mark.filterwarnings("ignore:Setting a value on a view:FutureWarning")
  281:     def test_multiindex_at_set(self):
  282:         # GH 26989
  283:         # DataFrame.at and DataFrame.loc setter works with MultiIndex
  284:         df = DataFrame({"a": [1, 2]}, index=[[1, 2], [3, 4]])
  285:         assert df.index.nlevels == 2
  286:         df.at[(1, 3), "a"] = 3
  287:         assert df.at[(1, 3), "a"] == 3
  288:         df.loc[(1, 3), "a"] = 4
  289:         assert df.loc[(1, 3), "a"] == 4
  290: 
  291:         # Series.at and Series.loc setter works with MultiIndex
  292:         series = df["a"]
  293:         assert series.index.nlevels == 2
  294:         series.at[1, 3] = 5
  295:         assert series.at[1, 3] == 5
  296:         series.loc[1, 3] = 6
  297:         assert series.loc[1, 3] == 6
  298: 
  299:     def test_multiindex_at_get_one_level(self):
  300:         # GH#38053
  301:         s2 = Series((0, 1), index=[[False, True]])
  302:         result = s2.at[False]
  303:         assert result == 0
