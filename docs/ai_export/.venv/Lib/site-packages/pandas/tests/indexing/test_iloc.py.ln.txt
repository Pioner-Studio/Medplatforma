    1: """ test positional based indexing with iloc """
    2: 
    3: from datetime import datetime
    4: import re
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas.errors import IndexingError
   10: import pandas.util._test_decorators as td
   11: 
   12: from pandas import (
   13:     NA,
   14:     Categorical,
   15:     CategoricalDtype,
   16:     DataFrame,
   17:     Index,
   18:     Interval,
   19:     NaT,
   20:     Series,
   21:     Timestamp,
   22:     array,
   23:     concat,
   24:     date_range,
   25:     interval_range,
   26:     isna,
   27:     to_datetime,
   28: )
   29: import pandas._testing as tm
   30: from pandas.api.types import is_scalar
   31: from pandas.tests.indexing.common import check_indexing_smoketest_or_raises
   32: 
   33: # We pass through the error message from numpy
   34: _slice_iloc_msg = re.escape(
   35:     "only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) "
   36:     "and integer or boolean arrays are valid indices"
   37: )
   38: 
   39: 
   40: class TestiLoc:
   41:     @pytest.mark.parametrize("key", [2, -1, [0, 1, 2]])
   42:     @pytest.mark.parametrize("kind", ["series", "frame"])
   43:     @pytest.mark.parametrize(
   44:         "col",
   45:         ["labels", "mixed", "ts", "floats", "empty"],
   46:     )
   47:     def test_iloc_getitem_int_and_list_int(self, key, kind, col, request):
   48:         obj = request.getfixturevalue(f"{kind}_{col}")
   49:         check_indexing_smoketest_or_raises(
   50:             obj,
   51:             "iloc",
   52:             key,
   53:             fails=IndexError,
   54:         )
   55: 
   56:         # array of ints (GH5006), make sure that a single indexer is returning
   57:         # the correct type
   58: 
   59: 
   60: class TestiLocBaseIndependent:
   61:     """Tests Independent Of Base Class"""
   62: 
   63:     @pytest.mark.parametrize(
   64:         "key",
   65:         [
   66:             slice(None),
   67:             slice(3),
   68:             range(3),
   69:             [0, 1, 2],
   70:             Index(range(3)),
   71:             np.asarray([0, 1, 2]),
   72:         ],
   73:     )
   74:     @pytest.mark.parametrize("indexer", [tm.loc, tm.iloc])
   75:     def test_iloc_setitem_fullcol_categorical(self, indexer, key, using_array_manager):
   76:         frame = DataFrame({0: range(3)}, dtype=object)
   77: 
   78:         cat = Categorical(["alpha", "beta", "gamma"])
   79: 
   80:         if not using_array_manager:
   81:             assert frame._mgr.blocks[0]._can_hold_element(cat)
   82: 
   83:         df = frame.copy()
   84:         orig_vals = df.values
   85: 
   86:         indexer(df)[key, 0] = cat
   87: 
   88:         expected = DataFrame({0: cat}).astype(object)
   89:         if not using_array_manager:
   90:             assert np.shares_memory(df[0].values, orig_vals)
   91: 
   92:         tm.assert_frame_equal(df, expected)
   93: 
   94:         # check we dont have a view on cat (may be undesired GH#39986)
   95:         df.iloc[0, 0] = "gamma"
   96:         assert cat[0] != "gamma"
   97: 
   98:         # pre-2.0 with mixed dataframe ("split" path) we always overwrote the
   99:         #  column.  as of 2.0 we correctly write "into" the column, so
  100:         #  we retain the object dtype.
  101:         frame = DataFrame({0: np.array([0, 1, 2], dtype=object), 1: range(3)})
  102:         df = frame.copy()
  103:         indexer(df)[key, 0] = cat
  104:         expected = DataFrame({0: Series(cat.astype(object), dtype=object), 1: range(3)})
  105:         tm.assert_frame_equal(df, expected)
  106: 
  107:     @pytest.mark.parametrize("box", [array, Series])
  108:     def test_iloc_setitem_ea_inplace(self, frame_or_series, box, using_copy_on_write):
  109:         # GH#38952 Case with not setting a full column
  110:         #  IntegerArray without NAs
  111:         arr = array([1, 2, 3, 4])
  112:         obj = frame_or_series(arr.to_numpy("i8"))
  113: 
  114:         if frame_or_series is Series:
  115:             values = obj.values
  116:         else:
  117:             values = obj._mgr.arrays[0]
  118: 
  119:         if frame_or_series is Series:
  120:             obj.iloc[:2] = box(arr[2:])
  121:         else:
  122:             obj.iloc[:2, 0] = box(arr[2:])
  123: 
  124:         expected = frame_or_series(np.array([3, 4, 3, 4], dtype="i8"))
  125:         tm.assert_equal(obj, expected)
  126: 
  127:         # Check that we are actually in-place
  128:         if frame_or_series is Series:
  129:             if using_copy_on_write:
  130:                 assert obj.values is not values
  131:                 assert np.shares_memory(obj.values, values)
  132:             else:
  133:                 assert obj.values is values
  134:         else:
  135:             assert np.shares_memory(obj[0].values, values)
  136: 
  137:     def test_is_scalar_access(self):
  138:         # GH#32085 index with duplicates doesn't matter for _is_scalar_access
  139:         index = Index([1, 2, 1])
  140:         ser = Series(range(3), index=index)
  141: 
  142:         assert ser.iloc._is_scalar_access((1,))
  143: 
  144:         df = ser.to_frame()
  145:         assert df.iloc._is_scalar_access((1, 0))
  146: 
  147:     def test_iloc_exceeds_bounds(self):
  148:         # GH6296
  149:         # iloc should allow indexers that exceed the bounds
  150:         df = DataFrame(np.random.default_rng(2).random((20, 5)), columns=list("ABCDE"))
  151: 
  152:         # lists of positions should raise IndexError!
  153:         msg = "positional indexers are out-of-bounds"
  154:         with pytest.raises(IndexError, match=msg):
  155:             df.iloc[:, [0, 1, 2, 3, 4, 5]]
  156:         with pytest.raises(IndexError, match=msg):
  157:             df.iloc[[1, 30]]
  158:         with pytest.raises(IndexError, match=msg):
  159:             df.iloc[[1, -30]]
  160:         with pytest.raises(IndexError, match=msg):
  161:             df.iloc[[100]]
  162: 
  163:         s = df["A"]
  164:         with pytest.raises(IndexError, match=msg):
  165:             s.iloc[[100]]
  166:         with pytest.raises(IndexError, match=msg):
  167:             s.iloc[[-100]]
  168: 
  169:         # still raise on a single indexer
  170:         msg = "single positional indexer is out-of-bounds"
  171:         with pytest.raises(IndexError, match=msg):
  172:             df.iloc[30]
  173:         with pytest.raises(IndexError, match=msg):
  174:             df.iloc[-30]
  175: 
  176:         # GH10779
  177:         # single positive/negative indexer exceeding Series bounds should raise
  178:         # an IndexError
  179:         with pytest.raises(IndexError, match=msg):
  180:             s.iloc[30]
  181:         with pytest.raises(IndexError, match=msg):
  182:             s.iloc[-30]
  183: 
  184:         # slices are ok
  185:         result = df.iloc[:, 4:10]  # 0 < start < len < stop
  186:         expected = df.iloc[:, 4:]
  187:         tm.assert_frame_equal(result, expected)
  188: 
  189:         result = df.iloc[:, -4:-10]  # stop < 0 < start < len
  190:         expected = df.iloc[:, :0]
  191:         tm.assert_frame_equal(result, expected)
  192: 
  193:         result = df.iloc[:, 10:4:-1]  # 0 < stop < len < start (down)
  194:         expected = df.iloc[:, :4:-1]
  195:         tm.assert_frame_equal(result, expected)
  196: 
  197:         result = df.iloc[:, 4:-10:-1]  # stop < 0 < start < len (down)
  198:         expected = df.iloc[:, 4::-1]
  199:         tm.assert_frame_equal(result, expected)
  200: 
  201:         result = df.iloc[:, -10:4]  # start < 0 < stop < len
  202:         expected = df.iloc[:, :4]
  203:         tm.assert_frame_equal(result, expected)
  204: 
  205:         result = df.iloc[:, 10:4]  # 0 < stop < len < start
  206:         expected = df.iloc[:, :0]
  207:         tm.assert_frame_equal(result, expected)
  208: 
  209:         result = df.iloc[:, -10:-11:-1]  # stop < start < 0 < len (down)
  210:         expected = df.iloc[:, :0]
  211:         tm.assert_frame_equal(result, expected)
  212: 
  213:         result = df.iloc[:, 10:11]  # 0 < len < start < stop
  214:         expected = df.iloc[:, :0]
  215:         tm.assert_frame_equal(result, expected)
  216: 
  217:         # slice bounds exceeding is ok
  218:         result = s.iloc[18:30]
  219:         expected = s.iloc[18:]
  220:         tm.assert_series_equal(result, expected)
  221: 
  222:         result = s.iloc[30:]
  223:         expected = s.iloc[:0]
  224:         tm.assert_series_equal(result, expected)
  225: 
  226:         result = s.iloc[30::-1]
  227:         expected = s.iloc[::-1]
  228:         tm.assert_series_equal(result, expected)
  229: 
  230:         # doc example
  231:         dfl = DataFrame(
  232:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("AB")
  233:         )
  234:         tm.assert_frame_equal(
  235:             dfl.iloc[:, 2:3],
  236:             DataFrame(index=dfl.index, columns=Index([], dtype=dfl.columns.dtype)),
  237:         )
  238:         tm.assert_frame_equal(dfl.iloc[:, 1:3], dfl.iloc[:, [1]])
  239:         tm.assert_frame_equal(dfl.iloc[4:6], dfl.iloc[[4]])
  240: 
  241:         msg = "positional indexers are out-of-bounds"
  242:         with pytest.raises(IndexError, match=msg):
  243:             dfl.iloc[[4, 5, 6]]
  244:         msg = "single positional indexer is out-of-bounds"
  245:         with pytest.raises(IndexError, match=msg):
  246:             dfl.iloc[:, 4]
  247: 
  248:     @pytest.mark.parametrize("index,columns", [(np.arange(20), list("ABCDE"))])
  249:     @pytest.mark.parametrize(
  250:         "index_vals,column_vals",
  251:         [
  252:             ([slice(None), ["A", "D"]]),
  253:             (["1", "2"], slice(None)),
  254:             ([datetime(2019, 1, 1)], slice(None)),
  255:         ],
  256:     )
  257:     def test_iloc_non_integer_raises(self, index, columns, index_vals, column_vals):
  258:         # GH 25753
  259:         df = DataFrame(
  260:             np.random.default_rng(2).standard_normal((len(index), len(columns))),
  261:             index=index,
  262:             columns=columns,
  263:         )
  264:         msg = ".iloc requires numeric indexers, got"
  265:         with pytest.raises(IndexError, match=msg):
  266:             df.iloc[index_vals, column_vals]
  267: 
  268:     def test_iloc_getitem_invalid_scalar(self, frame_or_series):
  269:         # GH 21982
  270: 
  271:         obj = DataFrame(np.arange(100).reshape(10, 10))
  272:         obj = tm.get_obj(obj, frame_or_series)
  273: 
  274:         with pytest.raises(TypeError, match="Cannot index by location index"):
  275:             obj.iloc["a"]
  276: 
  277:     def test_iloc_array_not_mutating_negative_indices(self):
  278:         # GH 21867
  279:         array_with_neg_numbers = np.array([1, 2, -1])
  280:         array_copy = array_with_neg_numbers.copy()
  281:         df = DataFrame(
  282:             {"A": [100, 101, 102], "B": [103, 104, 105], "C": [106, 107, 108]},
  283:             index=[1, 2, 3],
  284:         )
  285:         df.iloc[array_with_neg_numbers]
  286:         tm.assert_numpy_array_equal(array_with_neg_numbers, array_copy)
  287:         df.iloc[:, array_with_neg_numbers]
  288:         tm.assert_numpy_array_equal(array_with_neg_numbers, array_copy)
  289: 
  290:     def test_iloc_getitem_neg_int_can_reach_first_index(self):
  291:         # GH10547 and GH10779
  292:         # negative integers should be able to reach index 0
  293:         df = DataFrame({"A": [2, 3, 5], "B": [7, 11, 13]})
  294:         s = df["A"]
  295: 
  296:         expected = df.iloc[0]
  297:         result = df.iloc[-3]
  298:         tm.assert_series_equal(result, expected)
  299: 
  300:         expected = df.iloc[[0]]
  301:         result = df.iloc[[-3]]
  302:         tm.assert_frame_equal(result, expected)
  303: 
  304:         expected = s.iloc[0]
  305:         result = s.iloc[-3]
  306:         assert result == expected
  307: 
  308:         expected = s.iloc[[0]]
  309:         result = s.iloc[[-3]]
  310:         tm.assert_series_equal(result, expected)
  311: 
  312:         # check the length 1 Series case highlighted in GH10547
  313:         expected = Series(["a"], index=["A"])
  314:         result = expected.iloc[[-1]]
  315:         tm.assert_series_equal(result, expected)
  316: 
  317:     def test_iloc_getitem_dups(self):
  318:         # GH 6766
  319:         df1 = DataFrame([{"A": None, "B": 1}, {"A": 2, "B": 2}])
  320:         df2 = DataFrame([{"A": 3, "B": 3}, {"A": 4, "B": 4}])
  321:         df = concat([df1, df2], axis=1)
  322: 
  323:         # cross-sectional indexing
  324:         result = df.iloc[0, 0]
  325:         assert isna(result)
  326: 
  327:         result = df.iloc[0, :]
  328:         expected = Series([np.nan, 1, 3, 3], index=["A", "B", "A", "B"], name=0)
  329:         tm.assert_series_equal(result, expected)
  330: 
  331:     def test_iloc_getitem_array(self):
  332:         df = DataFrame(
  333:             [
  334:                 {"A": 1, "B": 2, "C": 3},
  335:                 {"A": 100, "B": 200, "C": 300},
  336:                 {"A": 1000, "B": 2000, "C": 3000},
  337:             ]
  338:         )
  339: 
  340:         expected = DataFrame([{"A": 1, "B": 2, "C": 3}])
  341:         tm.assert_frame_equal(df.iloc[[0]], expected)
  342: 
  343:         expected = DataFrame([{"A": 1, "B": 2, "C": 3}, {"A": 100, "B": 200, "C": 300}])
  344:         tm.assert_frame_equal(df.iloc[[0, 1]], expected)
  345: 
  346:         expected = DataFrame([{"B": 2, "C": 3}, {"B": 2000, "C": 3000}], index=[0, 2])
  347:         result = df.iloc[[0, 2], [1, 2]]
  348:         tm.assert_frame_equal(result, expected)
  349: 
  350:     def test_iloc_getitem_bool(self):
  351:         df = DataFrame(
  352:             [
  353:                 {"A": 1, "B": 2, "C": 3},
  354:                 {"A": 100, "B": 200, "C": 300},
  355:                 {"A": 1000, "B": 2000, "C": 3000},
  356:             ]
  357:         )
  358: 
  359:         expected = DataFrame([{"A": 1, "B": 2, "C": 3}, {"A": 100, "B": 200, "C": 300}])
  360:         result = df.iloc[[True, True, False]]
  361:         tm.assert_frame_equal(result, expected)
  362: 
  363:         expected = DataFrame(
  364:             [{"A": 1, "B": 2, "C": 3}, {"A": 1000, "B": 2000, "C": 3000}], index=[0, 2]
  365:         )
  366:         result = df.iloc[lambda x: x.index % 2 == 0]
  367:         tm.assert_frame_equal(result, expected)
  368: 
  369:     @pytest.mark.parametrize("index", [[True, False], [True, False, True, False]])
  370:     def test_iloc_getitem_bool_diff_len(self, index):
  371:         # GH26658
  372:         s = Series([1, 2, 3])
  373:         msg = f"Boolean index has wrong length: {len(index)} instead of {len(s)}"
  374:         with pytest.raises(IndexError, match=msg):
  375:             s.iloc[index]
  376: 
  377:     def test_iloc_getitem_slice(self):
  378:         df = DataFrame(
  379:             [
  380:                 {"A": 1, "B": 2, "C": 3},
  381:                 {"A": 100, "B": 200, "C": 300},
  382:                 {"A": 1000, "B": 2000, "C": 3000},
  383:             ]
  384:         )
  385: 
  386:         expected = DataFrame([{"A": 1, "B": 2, "C": 3}, {"A": 100, "B": 200, "C": 300}])
  387:         result = df.iloc[:2]
  388:         tm.assert_frame_equal(result, expected)
  389: 
  390:         expected = DataFrame([{"A": 100, "B": 200}], index=[1])
  391:         result = df.iloc[1:2, 0:2]
  392:         tm.assert_frame_equal(result, expected)
  393: 
  394:         expected = DataFrame(
  395:             [{"A": 1, "C": 3}, {"A": 100, "C": 300}, {"A": 1000, "C": 3000}]
  396:         )
  397:         result = df.iloc[:, lambda df: [0, 2]]
  398:         tm.assert_frame_equal(result, expected)
  399: 
  400:     def test_iloc_getitem_slice_dups(self):
  401:         df1 = DataFrame(
  402:             np.random.default_rng(2).standard_normal((10, 4)),
  403:             columns=["A", "A", "B", "B"],
  404:         )
  405:         df2 = DataFrame(
  406:             np.random.default_rng(2).integers(0, 10, size=20).reshape(10, 2),
  407:             columns=["A", "C"],
  408:         )
  409: 
  410:         # axis=1
  411:         df = concat([df1, df2], axis=1)
  412:         tm.assert_frame_equal(df.iloc[:, :4], df1)
  413:         tm.assert_frame_equal(df.iloc[:, 4:], df2)
  414: 
  415:         df = concat([df2, df1], axis=1)
  416:         tm.assert_frame_equal(df.iloc[:, :2], df2)
  417:         tm.assert_frame_equal(df.iloc[:, 2:], df1)
  418: 
  419:         exp = concat([df2, df1.iloc[:, [0]]], axis=1)
  420:         tm.assert_frame_equal(df.iloc[:, 0:3], exp)
  421: 
  422:         # axis=0
  423:         df = concat([df, df], axis=0)
  424:         tm.assert_frame_equal(df.iloc[0:10, :2], df2)
  425:         tm.assert_frame_equal(df.iloc[0:10, 2:], df1)
  426:         tm.assert_frame_equal(df.iloc[10:, :2], df2)
  427:         tm.assert_frame_equal(df.iloc[10:, 2:], df1)
  428: 
  429:     def test_iloc_setitem(self, warn_copy_on_write):
  430:         df = DataFrame(
  431:             np.random.default_rng(2).standard_normal((4, 4)),
  432:             index=np.arange(0, 8, 2),
  433:             columns=np.arange(0, 12, 3),
  434:         )
  435: 
  436:         df.iloc[1, 1] = 1
  437:         result = df.iloc[1, 1]
  438:         assert result == 1
  439: 
  440:         df.iloc[:, 2:3] = 0
  441:         expected = df.iloc[:, 2:3]
  442:         result = df.iloc[:, 2:3]
  443:         tm.assert_frame_equal(result, expected)
  444: 
  445:         # GH5771
  446:         s = Series(0, index=[4, 5, 6])
  447:         s.iloc[1:2] += 1
  448:         expected = Series([0, 1, 0], index=[4, 5, 6])
  449:         tm.assert_series_equal(s, expected)
  450: 
  451:     def test_iloc_setitem_axis_argument(self):
  452:         # GH45032
  453:         df = DataFrame([[6, "c", 10], [7, "d", 11], [8, "e", 12]])
  454:         df[1] = df[1].astype(object)
  455:         expected = DataFrame([[6, "c", 10], [7, "d", 11], [5, 5, 5]])
  456:         expected[1] = expected[1].astype(object)
  457:         df.iloc(axis=0)[2] = 5
  458:         tm.assert_frame_equal(df, expected)
  459: 
  460:         df = DataFrame([[6, "c", 10], [7, "d", 11], [8, "e", 12]])
  461:         df[1] = df[1].astype(object)
  462:         expected = DataFrame([[6, "c", 5], [7, "d", 5], [8, "e", 5]])
  463:         expected[1] = expected[1].astype(object)
  464:         df.iloc(axis=1)[2] = 5
  465:         tm.assert_frame_equal(df, expected)
  466: 
  467:     def test_iloc_setitem_list(self):
  468:         # setitem with an iloc list
  469:         df = DataFrame(
  470:             np.arange(9).reshape((3, 3)), index=["A", "B", "C"], columns=["A", "B", "C"]
  471:         )
  472:         df.iloc[[0, 1], [1, 2]]
  473:         df.iloc[[0, 1], [1, 2]] += 100
  474: 
  475:         expected = DataFrame(
  476:             np.array([0, 101, 102, 3, 104, 105, 6, 7, 8]).reshape((3, 3)),
  477:             index=["A", "B", "C"],
  478:             columns=["A", "B", "C"],
  479:         )
  480:         tm.assert_frame_equal(df, expected)
  481: 
  482:     def test_iloc_setitem_pandas_object(self):
  483:         # GH 17193
  484:         s_orig = Series([0, 1, 2, 3])
  485:         expected = Series([0, -1, -2, 3])
  486: 
  487:         s = s_orig.copy()
  488:         s.iloc[Series([1, 2])] = [-1, -2]
  489:         tm.assert_series_equal(s, expected)
  490: 
  491:         s = s_orig.copy()
  492:         s.iloc[Index([1, 2])] = [-1, -2]
  493:         tm.assert_series_equal(s, expected)
  494: 
  495:     def test_iloc_setitem_dups(self):
  496:         # GH 6766
  497:         # iloc with a mask aligning from another iloc
  498:         df1 = DataFrame([{"A": None, "B": 1}, {"A": 2, "B": 2}])
  499:         df2 = DataFrame([{"A": 3, "B": 3}, {"A": 4, "B": 4}])
  500:         df = concat([df1, df2], axis=1)
  501: 
  502:         expected = df.fillna(3)
  503:         inds = np.isnan(df.iloc[:, 0])
  504:         mask = inds[inds].index
  505:         df.iloc[mask, 0] = df.iloc[mask, 2]
  506:         tm.assert_frame_equal(df, expected)
  507: 
  508:         # del a dup column across blocks
  509:         expected = DataFrame({0: [1, 2], 1: [3, 4]})
  510:         expected.columns = ["B", "B"]
  511:         del df["A"]
  512:         tm.assert_frame_equal(df, expected)
  513: 
  514:         # assign back to self
  515:         df.iloc[[0, 1], [0, 1]] = df.iloc[[0, 1], [0, 1]]
  516:         tm.assert_frame_equal(df, expected)
  517: 
  518:         # reversed x 2
  519:         df.iloc[[1, 0], [0, 1]] = df.iloc[[1, 0], [0, 1]].reset_index(drop=True)
  520:         df.iloc[[1, 0], [0, 1]] = df.iloc[[1, 0], [0, 1]].reset_index(drop=True)
  521:         tm.assert_frame_equal(df, expected)
  522: 
  523:     def test_iloc_setitem_frame_duplicate_columns_multiple_blocks(
  524:         self, using_array_manager
  525:     ):
  526:         # Same as the "assign back to self" check in test_iloc_setitem_dups
  527:         #  but on a DataFrame with multiple blocks
  528:         df = DataFrame([[0, 1], [2, 3]], columns=["B", "B"])
  529: 
  530:         # setting float values that can be held by existing integer arrays
  531:         #  is inplace
  532:         df.iloc[:, 0] = df.iloc[:, 0].astype("f8")
  533:         if not using_array_manager:
  534:             assert len(df._mgr.blocks) == 1
  535: 
  536:         # if the assigned values cannot be held by existing integer arrays,
  537:         #  we cast
  538:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  539:             df.iloc[:, 0] = df.iloc[:, 0] + 0.5
  540:         if not using_array_manager:
  541:             assert len(df._mgr.blocks) == 2
  542: 
  543:         expected = df.copy()
  544: 
  545:         # assign back to self
  546:         df.iloc[[0, 1], [0, 1]] = df.iloc[[0, 1], [0, 1]]
  547: 
  548:         tm.assert_frame_equal(df, expected)
  549: 
  550:     # TODO: GH#27620 this test used to compare iloc against ix; check if this
  551:     #  is redundant with another test comparing iloc against loc
  552:     def test_iloc_getitem_frame(self):
  553:         df = DataFrame(
  554:             np.random.default_rng(2).standard_normal((10, 4)),
  555:             index=range(0, 20, 2),
  556:             columns=range(0, 8, 2),
  557:         )
  558: 
  559:         result = df.iloc[2]
  560:         exp = df.loc[4]
  561:         tm.assert_series_equal(result, exp)
  562: 
  563:         result = df.iloc[2, 2]
  564:         exp = df.loc[4, 4]
  565:         assert result == exp
  566: 
  567:         # slice
  568:         result = df.iloc[4:8]
  569:         expected = df.loc[8:14]
  570:         tm.assert_frame_equal(result, expected)
  571: 
  572:         result = df.iloc[:, 2:3]
  573:         expected = df.loc[:, 4:5]
  574:         tm.assert_frame_equal(result, expected)
  575: 
  576:         # list of integers
  577:         result = df.iloc[[0, 1, 3]]
  578:         expected = df.loc[[0, 2, 6]]
  579:         tm.assert_frame_equal(result, expected)
  580: 
  581:         result = df.iloc[[0, 1, 3], [0, 1]]
  582:         expected = df.loc[[0, 2, 6], [0, 2]]
  583:         tm.assert_frame_equal(result, expected)
  584: 
  585:         # neg indices
  586:         result = df.iloc[[-1, 1, 3], [-1, 1]]
  587:         expected = df.loc[[18, 2, 6], [6, 2]]
  588:         tm.assert_frame_equal(result, expected)
  589: 
  590:         # dups indices
  591:         result = df.iloc[[-1, -1, 1, 3], [-1, 1]]
  592:         expected = df.loc[[18, 18, 2, 6], [6, 2]]
  593:         tm.assert_frame_equal(result, expected)
  594: 
  595:         # with index-like
  596:         s = Series(index=range(1, 5), dtype=object)
  597:         result = df.iloc[s.index]
  598:         expected = df.loc[[2, 4, 6, 8]]
  599:         tm.assert_frame_equal(result, expected)
  600: 
  601:     def test_iloc_getitem_labelled_frame(self):
  602:         # try with labelled frame
  603:         df = DataFrame(
  604:             np.random.default_rng(2).standard_normal((10, 4)),
  605:             index=list("abcdefghij"),
  606:             columns=list("ABCD"),
  607:         )
  608: 
  609:         result = df.iloc[1, 1]
  610:         exp = df.loc["b", "B"]
  611:         assert result == exp
  612: 
  613:         result = df.iloc[:, 2:3]
  614:         expected = df.loc[:, ["C"]]
  615:         tm.assert_frame_equal(result, expected)
  616: 
  617:         # negative indexing
  618:         result = df.iloc[-1, -1]
  619:         exp = df.loc["j", "D"]
  620:         assert result == exp
  621: 
  622:         # out-of-bounds exception
  623:         msg = "index 5 is out of bounds for axis 0 with size 4|index out of bounds"
  624:         with pytest.raises(IndexError, match=msg):
  625:             df.iloc[10, 5]
  626: 
  627:         # trying to use a label
  628:         msg = (
  629:             r"Location based indexing can only have \[integer, integer "
  630:             r"slice \(START point is INCLUDED, END point is EXCLUDED\), "
  631:             r"listlike of integers, boolean array\] types"
  632:         )
  633:         with pytest.raises(ValueError, match=msg):
  634:             df.iloc["j", "D"]
  635: 
  636:     def test_iloc_getitem_doc_issue(self, using_array_manager):
  637:         # multi axis slicing issue with single block
  638:         # surfaced in GH 6059
  639: 
  640:         arr = np.random.default_rng(2).standard_normal((6, 4))
  641:         index = date_range("20130101", periods=6)
  642:         columns = list("ABCD")
  643:         df = DataFrame(arr, index=index, columns=columns)
  644: 
  645:         # defines ref_locs
  646:         df.describe()
  647: 
  648:         result = df.iloc[3:5, 0:2]
  649: 
  650:         expected = DataFrame(arr[3:5, 0:2], index=index[3:5], columns=columns[0:2])
  651:         tm.assert_frame_equal(result, expected)
  652: 
  653:         # for dups
  654:         df.columns = list("aaaa")
  655:         result = df.iloc[3:5, 0:2]
  656: 
  657:         expected = DataFrame(arr[3:5, 0:2], index=index[3:5], columns=list("aa"))
  658:         tm.assert_frame_equal(result, expected)
  659: 
  660:         # related
  661:         arr = np.random.default_rng(2).standard_normal((6, 4))
  662:         index = list(range(0, 12, 2))
  663:         columns = list(range(0, 8, 2))
  664:         df = DataFrame(arr, index=index, columns=columns)
  665: 
  666:         if not using_array_manager:
  667:             df._mgr.blocks[0].mgr_locs
  668:         result = df.iloc[1:5, 2:4]
  669:         expected = DataFrame(arr[1:5, 2:4], index=index[1:5], columns=columns[2:4])
  670:         tm.assert_frame_equal(result, expected)
  671: 
  672:     def test_iloc_setitem_series(self):
  673:         df = DataFrame(
  674:             np.random.default_rng(2).standard_normal((10, 4)),
  675:             index=list("abcdefghij"),
  676:             columns=list("ABCD"),
  677:         )
  678: 
  679:         df.iloc[1, 1] = 1
  680:         result = df.iloc[1, 1]
  681:         assert result == 1
  682: 
  683:         df.iloc[:, 2:3] = 0
  684:         expected = df.iloc[:, 2:3]
  685:         result = df.iloc[:, 2:3]
  686:         tm.assert_frame_equal(result, expected)
  687: 
  688:         s = Series(np.random.default_rng(2).standard_normal(10), index=range(0, 20, 2))
  689: 
  690:         s.iloc[1] = 1
  691:         result = s.iloc[1]
  692:         assert result == 1
  693: 
  694:         s.iloc[:4] = 0
  695:         expected = s.iloc[:4]
  696:         result = s.iloc[:4]
  697:         tm.assert_series_equal(result, expected)
  698: 
  699:         s = Series([-1] * 6)
  700:         s.iloc[0::2] = [0, 2, 4]
  701:         s.iloc[1::2] = [1, 3, 5]
  702:         result = s
  703:         expected = Series([0, 1, 2, 3, 4, 5])
  704:         tm.assert_series_equal(result, expected)
  705: 
  706:     def test_iloc_setitem_list_of_lists(self):
  707:         # GH 7551
  708:         # list-of-list is set incorrectly in mixed vs. single dtyped frames
  709:         df = DataFrame(
  710:             {"A": np.arange(5, dtype="int64"), "B": np.arange(5, 10, dtype="int64")}
  711:         )
  712:         df.iloc[2:4] = [[10, 11], [12, 13]]
  713:         expected = DataFrame({"A": [0, 1, 10, 12, 4], "B": [5, 6, 11, 13, 9]})
  714:         tm.assert_frame_equal(df, expected)
  715: 
  716:         df = DataFrame(
  717:             {"A": ["a", "b", "c", "d", "e"], "B": np.arange(5, 10, dtype="int64")}
  718:         )
  719:         df.iloc[2:4] = [["x", 11], ["y", 13]]
  720:         expected = DataFrame({"A": ["a", "b", "x", "y", "e"], "B": [5, 6, 11, 13, 9]})
  721:         tm.assert_frame_equal(df, expected)
  722: 
  723:     @pytest.mark.parametrize("indexer", [[0], slice(None, 1, None), np.array([0])])
  724:     @pytest.mark.parametrize("value", [["Z"], np.array(["Z"])])
  725:     def test_iloc_setitem_with_scalar_index(self, indexer, value):
  726:         # GH #19474
  727:         # assigning like "df.iloc[0, [0]] = ['Z']" should be evaluated
  728:         # elementwisely, not using "setter('A', ['Z'])".
  729: 
  730:         # Set object type to avoid upcast when setting "Z"
  731:         df = DataFrame([[1, 2], [3, 4]], columns=["A", "B"]).astype({"A": object})
  732:         df.iloc[0, indexer] = value
  733:         result = df.iloc[0, 0]
  734: 
  735:         assert is_scalar(result) and result == "Z"
  736: 
  737:     @pytest.mark.filterwarnings("ignore::UserWarning")
  738:     def test_iloc_mask(self):
  739:         # GH 3631, iloc with a mask (of a series) should raise
  740:         df = DataFrame(list(range(5)), index=list("ABCDE"), columns=["a"])
  741:         mask = df.a % 2 == 0
  742:         msg = "iLocation based boolean indexing cannot use an indexable as a mask"
  743:         with pytest.raises(ValueError, match=msg):
  744:             df.iloc[mask]
  745:         mask.index = range(len(mask))
  746:         msg = "iLocation based boolean indexing on an integer type is not available"
  747:         with pytest.raises(NotImplementedError, match=msg):
  748:             df.iloc[mask]
  749: 
  750:         # ndarray ok
  751:         result = df.iloc[np.array([True] * len(mask), dtype=bool)]
  752:         tm.assert_frame_equal(result, df)
  753: 
  754:         # the possibilities
  755:         locs = np.arange(4)
  756:         nums = 2**locs
  757:         reps = [bin(num) for num in nums]
  758:         df = DataFrame({"locs": locs, "nums": nums}, reps)
  759: 
  760:         expected = {
  761:             (None, ""): "0b1100",
  762:             (None, ".loc"): "0b1100",
  763:             (None, ".iloc"): "0b1100",
  764:             ("index", ""): "0b11",
  765:             ("index", ".loc"): "0b11",
  766:             ("index", ".iloc"): (
  767:                 "iLocation based boolean indexing cannot use an indexable as a mask"
  768:             ),
  769:             ("locs", ""): "Unalignable boolean Series provided as indexer "
  770:             "(index of the boolean Series and of the indexed "
  771:             "object do not match).",
  772:             ("locs", ".loc"): "Unalignable boolean Series provided as indexer "
  773:             "(index of the boolean Series and of the "
  774:             "indexed object do not match).",
  775:             ("locs", ".iloc"): (
  776:                 "iLocation based boolean indexing on an "
  777:                 "integer type is not available"
  778:             ),
  779:         }
  780: 
  781:         # UserWarnings from reindex of a boolean mask
  782:         for idx in [None, "index", "locs"]:
  783:             mask = (df.nums > 2).values
  784:             if idx:
  785:                 mask_index = getattr(df, idx)[::-1]
  786:                 mask = Series(mask, list(mask_index))
  787:             for method in ["", ".loc", ".iloc"]:
  788:                 try:
  789:                     if method:
  790:                         accessor = getattr(df, method[1:])
  791:                     else:
  792:                         accessor = df
  793:                     answer = str(bin(accessor[mask]["nums"].sum()))
  794:                 except (ValueError, IndexingError, NotImplementedError) as err:
  795:                     answer = str(err)
  796: 
  797:                 key = (
  798:                     idx,
  799:                     method,
  800:                 )
  801:                 r = expected.get(key)
  802:                 if r != answer:
  803:                     raise AssertionError(
  804:                         f"[{key}] does not match [{answer}], received [{r}]"
  805:                     )
  806: 
  807:     def test_iloc_non_unique_indexing(self):
  808:         # GH 4017, non-unique indexing (on the axis)
  809:         df = DataFrame({"A": [0.1] * 3000, "B": [1] * 3000})
  810:         idx = np.arange(30) * 99
  811:         expected = df.iloc[idx]
  812: 
  813:         df3 = concat([df, 2 * df, 3 * df])
  814:         result = df3.iloc[idx]
  815: 
  816:         tm.assert_frame_equal(result, expected)
  817: 
  818:         df2 = DataFrame({"A": [0.1] * 1000, "B": [1] * 1000})
  819:         df2 = concat([df2, 2 * df2, 3 * df2])
  820: 
  821:         with pytest.raises(KeyError, match="not in index"):
  822:             df2.loc[idx]
  823: 
  824:     def test_iloc_empty_list_indexer_is_ok(self):
  825:         df = DataFrame(
  826:             np.ones((5, 2)),
  827:             index=Index([f"i-{i}" for i in range(5)], name="a"),
  828:             columns=Index([f"i-{i}" for i in range(2)], name="a"),
  829:         )
  830:         # vertical empty
  831:         tm.assert_frame_equal(
  832:             df.iloc[:, []],
  833:             df.iloc[:, :0],
  834:             check_index_type=True,
  835:             check_column_type=True,
  836:         )
  837:         # horizontal empty
  838:         tm.assert_frame_equal(
  839:             df.iloc[[], :],
  840:             df.iloc[:0, :],
  841:             check_index_type=True,
  842:             check_column_type=True,
  843:         )
  844:         # horizontal empty
  845:         tm.assert_frame_equal(
  846:             df.iloc[[]], df.iloc[:0, :], check_index_type=True, check_column_type=True
  847:         )
  848: 
  849:     def test_identity_slice_returns_new_object(
  850:         self, using_copy_on_write, warn_copy_on_write
  851:     ):
  852:         # GH13873
  853:         original_df = DataFrame({"a": [1, 2, 3]})
  854:         sliced_df = original_df.iloc[:]
  855:         assert sliced_df is not original_df
  856: 
  857:         # should be a shallow copy
  858:         assert np.shares_memory(original_df["a"], sliced_df["a"])
  859: 
  860:         # Setting using .loc[:, "a"] sets inplace so alters both sliced and orig
  861:         # depending on CoW
  862:         with tm.assert_cow_warning(warn_copy_on_write):
  863:             original_df.loc[:, "a"] = [4, 4, 4]
  864:         if using_copy_on_write:
  865:             assert (sliced_df["a"] == [1, 2, 3]).all()
  866:         else:
  867:             assert (sliced_df["a"] == 4).all()
  868: 
  869:         original_series = Series([1, 2, 3, 4, 5, 6])
  870:         sliced_series = original_series.iloc[:]
  871:         assert sliced_series is not original_series
  872: 
  873:         # should also be a shallow copy
  874:         with tm.assert_cow_warning(warn_copy_on_write):
  875:             original_series[:3] = [7, 8, 9]
  876:         if using_copy_on_write:
  877:             # shallow copy not updated (CoW)
  878:             assert all(sliced_series[:3] == [1, 2, 3])
  879:         else:
  880:             assert all(sliced_series[:3] == [7, 8, 9])
  881: 
  882:     def test_indexing_zerodim_np_array(self):
  883:         # GH24919
  884:         df = DataFrame([[1, 2], [3, 4]])
  885:         result = df.iloc[np.array(0)]
  886:         s = Series([1, 2], name=0)
  887:         tm.assert_series_equal(result, s)
  888: 
  889:     def test_series_indexing_zerodim_np_array(self):
  890:         # GH24919
  891:         s = Series([1, 2])
  892:         result = s.iloc[np.array(0)]
  893:         assert result == 1
  894: 
  895:     def test_iloc_setitem_categorical_updates_inplace(self):
  896:         # Mixed dtype ensures we go through take_split_path in setitem_with_indexer
  897:         cat = Categorical(["A", "B", "C"])
  898:         df = DataFrame({1: cat, 2: [1, 2, 3]}, copy=False)
  899: 
  900:         assert tm.shares_memory(df[1], cat)
  901: 
  902:         # With the enforcement of GH#45333 in 2.0, this modifies original
  903:         #  values inplace
  904:         df.iloc[:, 0] = cat[::-1]
  905: 
  906:         assert tm.shares_memory(df[1], cat)
  907:         expected = Categorical(["C", "B", "A"], categories=["A", "B", "C"])
  908:         tm.assert_categorical_equal(cat, expected)
  909: 
  910:     def test_iloc_with_boolean_operation(self):
  911:         # GH 20627
  912:         result = DataFrame([[0, 1], [2, 3], [4, 5], [6, np.nan]])
  913:         result.iloc[result.index <= 2] *= 2
  914:         expected = DataFrame([[0, 2], [4, 6], [8, 10], [6, np.nan]])
  915:         tm.assert_frame_equal(result, expected)
  916: 
  917:         result.iloc[result.index > 2] *= 2
  918:         expected = DataFrame([[0, 2], [4, 6], [8, 10], [12, np.nan]])
  919:         tm.assert_frame_equal(result, expected)
  920: 
  921:         result.iloc[[True, True, False, False]] *= 2
  922:         expected = DataFrame([[0, 4], [8, 12], [8, 10], [12, np.nan]])
  923:         tm.assert_frame_equal(result, expected)
  924: 
  925:         result.iloc[[False, False, True, True]] /= 2
  926:         expected = DataFrame([[0, 4.0], [8, 12.0], [4, 5.0], [6, np.nan]])
  927:         tm.assert_frame_equal(result, expected)
  928: 
  929:     def test_iloc_getitem_singlerow_slice_categoricaldtype_gives_series(self):
  930:         # GH#29521
  931:         df = DataFrame({"x": Categorical("a b c d e".split())})
  932:         result = df.iloc[0]
  933:         raw_cat = Categorical(["a"], categories=["a", "b", "c", "d", "e"])
  934:         expected = Series(raw_cat, index=["x"], name=0, dtype="category")
  935: 
  936:         tm.assert_series_equal(result, expected)
  937: 
  938:     def test_iloc_getitem_categorical_values(self):
  939:         # GH#14580
  940:         # test iloc() on Series with Categorical data
  941: 
  942:         ser = Series([1, 2, 3]).astype("category")
  943: 
  944:         # get slice
  945:         result = ser.iloc[0:2]
  946:         expected = Series([1, 2]).astype(CategoricalDtype([1, 2, 3]))
  947:         tm.assert_series_equal(result, expected)
  948: 
  949:         # get list of indexes
  950:         result = ser.iloc[[0, 1]]
  951:         expected = Series([1, 2]).astype(CategoricalDtype([1, 2, 3]))
  952:         tm.assert_series_equal(result, expected)
  953: 
  954:         # get boolean array
  955:         result = ser.iloc[[True, False, False]]
  956:         expected = Series([1]).astype(CategoricalDtype([1, 2, 3]))
  957:         tm.assert_series_equal(result, expected)
  958: 
  959:     @pytest.mark.parametrize("value", [None, NaT, np.nan])
  960:     def test_iloc_setitem_td64_values_cast_na(self, value):
  961:         # GH#18586
  962:         series = Series([0, 1, 2], dtype="timedelta64[ns]")
  963:         series.iloc[0] = value
  964:         expected = Series([NaT, 1, 2], dtype="timedelta64[ns]")
  965:         tm.assert_series_equal(series, expected)
  966: 
  967:     @pytest.mark.parametrize("not_na", [Interval(0, 1), "a", 1.0])
  968:     def test_setitem_mix_of_nan_and_interval(self, not_na, nulls_fixture):
  969:         # GH#27937
  970:         dtype = CategoricalDtype(categories=[not_na])
  971:         ser = Series(
  972:             [nulls_fixture, nulls_fixture, nulls_fixture, nulls_fixture], dtype=dtype
  973:         )
  974:         ser.iloc[:3] = [nulls_fixture, not_na, nulls_fixture]
  975:         exp = Series([nulls_fixture, not_na, nulls_fixture, nulls_fixture], dtype=dtype)
  976:         tm.assert_series_equal(ser, exp)
  977: 
  978:     def test_iloc_setitem_empty_frame_raises_with_3d_ndarray(self):
  979:         idx = Index([])
  980:         obj = DataFrame(
  981:             np.random.default_rng(2).standard_normal((len(idx), len(idx))),
  982:             index=idx,
  983:             columns=idx,
  984:         )
  985:         nd3 = np.random.default_rng(2).integers(5, size=(2, 2, 2))
  986: 
  987:         msg = f"Cannot set values with ndim > {obj.ndim}"
  988:         with pytest.raises(ValueError, match=msg):
  989:             obj.iloc[nd3] = 0
  990: 
  991:     @pytest.mark.parametrize("indexer", [tm.loc, tm.iloc])
  992:     def test_iloc_getitem_read_only_values(self, indexer):
  993:         # GH#10043 this is fundamentally a test for iloc, but test loc while
  994:         #  we're here
  995:         rw_array = np.eye(10)
  996:         rw_df = DataFrame(rw_array)
  997: 
  998:         ro_array = np.eye(10)
  999:         ro_array.setflags(write=False)
 1000:         ro_df = DataFrame(ro_array)
 1001: 
 1002:         tm.assert_frame_equal(indexer(rw_df)[[1, 2, 3]], indexer(ro_df)[[1, 2, 3]])
 1003:         tm.assert_frame_equal(indexer(rw_df)[[1]], indexer(ro_df)[[1]])
 1004:         tm.assert_series_equal(indexer(rw_df)[1], indexer(ro_df)[1])
 1005:         tm.assert_frame_equal(indexer(rw_df)[1:3], indexer(ro_df)[1:3])
 1006: 
 1007:     def test_iloc_getitem_readonly_key(self):
 1008:         # GH#17192 iloc with read-only array raising TypeError
 1009:         df = DataFrame({"data": np.ones(100, dtype="float64")})
 1010:         indices = np.array([1, 3, 6])
 1011:         indices.flags.writeable = False
 1012: 
 1013:         result = df.iloc[indices]
 1014:         expected = df.loc[[1, 3, 6]]
 1015:         tm.assert_frame_equal(result, expected)
 1016: 
 1017:         result = df["data"].iloc[indices]
 1018:         expected = df["data"].loc[[1, 3, 6]]
 1019:         tm.assert_series_equal(result, expected)
 1020: 
 1021:     def test_iloc_assign_series_to_df_cell(self):
 1022:         # GH 37593
 1023:         df = DataFrame(columns=["a"], index=[0])
 1024:         df.iloc[0, 0] = Series([1, 2, 3])
 1025:         expected = DataFrame({"a": [Series([1, 2, 3])]}, columns=["a"], index=[0])
 1026:         tm.assert_frame_equal(df, expected)
 1027: 
 1028:     @pytest.mark.parametrize("klass", [list, np.array])
 1029:     def test_iloc_setitem_bool_indexer(self, klass):
 1030:         # GH#36741
 1031:         df = DataFrame({"flag": ["x", "y", "z"], "value": [1, 3, 4]})
 1032:         indexer = klass([True, False, False])
 1033:         df.iloc[indexer, 1] = df.iloc[indexer, 1] * 2
 1034:         expected = DataFrame({"flag": ["x", "y", "z"], "value": [2, 3, 4]})
 1035:         tm.assert_frame_equal(df, expected)
 1036: 
 1037:     @pytest.mark.parametrize("indexer", [[1], slice(1, 2)])
 1038:     def test_iloc_setitem_pure_position_based(self, indexer):
 1039:         # GH#22046
 1040:         df1 = DataFrame({"a2": [11, 12, 13], "b2": [14, 15, 16]})
 1041:         df2 = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]})
 1042:         df2.iloc[:, indexer] = df1.iloc[:, [0]]
 1043:         expected = DataFrame({"a": [1, 2, 3], "b": [11, 12, 13], "c": [7, 8, 9]})
 1044:         tm.assert_frame_equal(df2, expected)
 1045: 
 1046:     def test_iloc_setitem_dictionary_value(self):
 1047:         # GH#37728
 1048:         df = DataFrame({"x": [1, 2], "y": [2, 2]})
 1049:         rhs = {"x": 9, "y": 99}
 1050:         df.iloc[1] = rhs
 1051:         expected = DataFrame({"x": [1, 9], "y": [2, 99]})
 1052:         tm.assert_frame_equal(df, expected)
 1053: 
 1054:         # GH#38335 same thing, mixed dtypes
 1055:         df = DataFrame({"x": [1, 2], "y": [2.0, 2.0]})
 1056:         df.iloc[1] = rhs
 1057:         expected = DataFrame({"x": [1, 9], "y": [2.0, 99.0]})
 1058:         tm.assert_frame_equal(df, expected)
 1059: 
 1060:     def test_iloc_getitem_float_duplicates(self):
 1061:         df = DataFrame(
 1062:             np.random.default_rng(2).standard_normal((3, 3)),
 1063:             index=[0.1, 0.2, 0.2],
 1064:             columns=list("abc"),
 1065:         )
 1066:         expect = df.iloc[1:]
 1067:         tm.assert_frame_equal(df.loc[0.2], expect)
 1068: 
 1069:         expect = df.iloc[1:, 0]
 1070:         tm.assert_series_equal(df.loc[0.2, "a"], expect)
 1071: 
 1072:         df.index = [1, 0.2, 0.2]
 1073:         expect = df.iloc[1:]
 1074:         tm.assert_frame_equal(df.loc[0.2], expect)
 1075: 
 1076:         expect = df.iloc[1:, 0]
 1077:         tm.assert_series_equal(df.loc[0.2, "a"], expect)
 1078: 
 1079:         df = DataFrame(
 1080:             np.random.default_rng(2).standard_normal((4, 3)),
 1081:             index=[1, 0.2, 0.2, 1],
 1082:             columns=list("abc"),
 1083:         )
 1084:         expect = df.iloc[1:-1]
 1085:         tm.assert_frame_equal(df.loc[0.2], expect)
 1086: 
 1087:         expect = df.iloc[1:-1, 0]
 1088:         tm.assert_series_equal(df.loc[0.2, "a"], expect)
 1089: 
 1090:         df.index = [0.1, 0.2, 2, 0.2]
 1091:         expect = df.iloc[[1, -1]]
 1092:         tm.assert_frame_equal(df.loc[0.2], expect)
 1093: 
 1094:         expect = df.iloc[[1, -1], 0]
 1095:         tm.assert_series_equal(df.loc[0.2, "a"], expect)
 1096: 
 1097:     def test_iloc_setitem_custom_object(self):
 1098:         # iloc with an object
 1099:         class TO:
 1100:             def __init__(self, value) -> None:
 1101:                 self.value = value
 1102: 
 1103:             def __str__(self) -> str:
 1104:                 return f"[{self.value}]"
 1105: 
 1106:             __repr__ = __str__
 1107: 
 1108:             def __eq__(self, other) -> bool:
 1109:                 return self.value == other.value
 1110: 
 1111:             def view(self):
 1112:                 return self
 1113: 
 1114:         df = DataFrame(index=[0, 1], columns=[0])
 1115:         df.iloc[1, 0] = TO(1)
 1116:         df.iloc[1, 0] = TO(2)
 1117: 
 1118:         result = DataFrame(index=[0, 1], columns=[0])
 1119:         result.iloc[1, 0] = TO(2)
 1120: 
 1121:         tm.assert_frame_equal(result, df)
 1122: 
 1123:         # remains object dtype even after setting it back
 1124:         df = DataFrame(index=[0, 1], columns=[0])
 1125:         df.iloc[1, 0] = TO(1)
 1126:         df.iloc[1, 0] = np.nan
 1127:         result = DataFrame(index=[0, 1], columns=[0])
 1128: 
 1129:         tm.assert_frame_equal(result, df)
 1130: 
 1131:     def test_iloc_getitem_with_duplicates(self):
 1132:         df = DataFrame(
 1133:             np.random.default_rng(2).random((3, 3)),
 1134:             columns=list("ABC"),
 1135:             index=list("aab"),
 1136:         )
 1137: 
 1138:         result = df.iloc[0]
 1139:         assert isinstance(result, Series)
 1140:         tm.assert_almost_equal(result.values, df.values[0])
 1141: 
 1142:         result = df.T.iloc[:, 0]
 1143:         assert isinstance(result, Series)
 1144:         tm.assert_almost_equal(result.values, df.values[0])
 1145: 
 1146:     def test_iloc_getitem_with_duplicates2(self):
 1147:         # GH#2259
 1148:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=[1, 1, 2])
 1149:         result = df.iloc[:, [0]]
 1150:         expected = df.take([0], axis=1)
 1151:         tm.assert_frame_equal(result, expected)
 1152: 
 1153:     def test_iloc_interval(self):
 1154:         # GH#17130
 1155:         df = DataFrame({Interval(1, 2): [1, 2]})
 1156: 
 1157:         result = df.iloc[0]
 1158:         expected = Series({Interval(1, 2): 1}, name=0)
 1159:         tm.assert_series_equal(result, expected)
 1160: 
 1161:         result = df.iloc[:, 0]
 1162:         expected = Series([1, 2], name=Interval(1, 2))
 1163:         tm.assert_series_equal(result, expected)
 1164: 
 1165:         result = df.copy()
 1166:         result.iloc[:, 0] += 1
 1167:         expected = DataFrame({Interval(1, 2): [2, 3]})
 1168:         tm.assert_frame_equal(result, expected)
 1169: 
 1170:     @pytest.mark.parametrize("indexing_func", [list, np.array])
 1171:     @pytest.mark.parametrize("rhs_func", [list, np.array])
 1172:     def test_loc_setitem_boolean_list(self, rhs_func, indexing_func):
 1173:         # GH#20438 testing specifically list key, not arraylike
 1174:         ser = Series([0, 1, 2])
 1175:         ser.iloc[indexing_func([True, False, True])] = rhs_func([5, 10])
 1176:         expected = Series([5, 1, 10])
 1177:         tm.assert_series_equal(ser, expected)
 1178: 
 1179:         df = DataFrame({"a": [0, 1, 2]})
 1180:         df.iloc[indexing_func([True, False, True])] = rhs_func([[5], [10]])
 1181:         expected = DataFrame({"a": [5, 1, 10]})
 1182:         tm.assert_frame_equal(df, expected)
 1183: 
 1184:     def test_iloc_getitem_slice_negative_step_ea_block(self):
 1185:         # GH#44551
 1186:         df = DataFrame({"A": [1, 2, 3]}, dtype="Int64")
 1187: 
 1188:         res = df.iloc[:, ::-1]
 1189:         tm.assert_frame_equal(res, df)
 1190: 
 1191:         df["B"] = "foo"
 1192:         res = df.iloc[:, ::-1]
 1193:         expected = DataFrame({"B": df["B"], "A": df["A"]})
 1194:         tm.assert_frame_equal(res, expected)
 1195: 
 1196:     def test_iloc_setitem_2d_ndarray_into_ea_block(self):
 1197:         # GH#44703
 1198:         df = DataFrame({"status": ["a", "b", "c"]}, dtype="category")
 1199:         df.iloc[np.array([0, 1]), np.array([0])] = np.array([["a"], ["a"]])
 1200: 
 1201:         expected = DataFrame({"status": ["a", "a", "c"]}, dtype=df["status"].dtype)
 1202:         tm.assert_frame_equal(df, expected)
 1203: 
 1204:     @td.skip_array_manager_not_yet_implemented
 1205:     def test_iloc_getitem_int_single_ea_block_view(self):
 1206:         # GH#45241
 1207:         # TODO: make an extension interface test for this?
 1208:         arr = interval_range(1, 10.0)._values
 1209:         df = DataFrame(arr)
 1210: 
 1211:         # ser should be a *view* on the DataFrame data
 1212:         ser = df.iloc[2]
 1213: 
 1214:         # if we have a view, then changing arr[2] should also change ser[0]
 1215:         assert arr[2] != arr[-1]  # otherwise the rest isn't meaningful
 1216:         arr[2] = arr[-1]
 1217:         assert ser[0] == arr[-1]
 1218: 
 1219:     def test_iloc_setitem_multicolumn_to_datetime(self):
 1220:         # GH#20511
 1221:         df = DataFrame({"A": ["2022-01-01", "2022-01-02"], "B": ["2021", "2022"]})
 1222: 
 1223:         df.iloc[:, [0]] = DataFrame({"A": to_datetime(["2021", "2022"])})
 1224:         expected = DataFrame(
 1225:             {
 1226:                 "A": [
 1227:                     Timestamp("2021-01-01 00:00:00"),
 1228:                     Timestamp("2022-01-01 00:00:00"),
 1229:                 ],
 1230:                 "B": ["2021", "2022"],
 1231:             }
 1232:         )
 1233:         tm.assert_frame_equal(df, expected, check_dtype=False)
 1234: 
 1235: 
 1236: class TestILocErrors:
 1237:     # NB: this test should work for _any_ Series we can pass as
 1238:     #  series_with_simple_index
 1239:     def test_iloc_float_raises(
 1240:         self, series_with_simple_index, frame_or_series, warn_copy_on_write
 1241:     ):
 1242:         # GH#4892
 1243:         # float_indexers should raise exceptions
 1244:         # on appropriate Index types & accessors
 1245:         # this duplicates the code below
 1246:         # but is specifically testing for the error
 1247:         # message
 1248: 
 1249:         obj = series_with_simple_index
 1250:         if frame_or_series is DataFrame:
 1251:             obj = obj.to_frame()
 1252: 
 1253:         msg = "Cannot index by location index with a non-integer key"
 1254:         with pytest.raises(TypeError, match=msg):
 1255:             obj.iloc[3.0]
 1256: 
 1257:         with pytest.raises(IndexError, match=_slice_iloc_msg):
 1258:             with tm.assert_cow_warning(
 1259:                 warn_copy_on_write and frame_or_series is DataFrame
 1260:             ):
 1261:                 obj.iloc[3.0] = 0
 1262: 
 1263:     def test_iloc_getitem_setitem_fancy_exceptions(self, float_frame):
 1264:         with pytest.raises(IndexingError, match="Too many indexers"):
 1265:             float_frame.iloc[:, :, :]
 1266: 
 1267:         with pytest.raises(IndexError, match="too many indices for array"):
 1268:             # GH#32257 we let numpy do validation, get their exception
 1269:             float_frame.iloc[:, :, :] = 1
 1270: 
 1271:     def test_iloc_frame_indexer(self):
 1272:         # GH#39004
 1273:         df = DataFrame({"a": [1, 2, 3]})
 1274:         indexer = DataFrame({"a": [True, False, True]})
 1275:         msg = "DataFrame indexer for .iloc is not supported. Consider using .loc"
 1276:         with pytest.raises(TypeError, match=msg):
 1277:             df.iloc[indexer] = 1
 1278: 
 1279:         msg = (
 1280:             "DataFrame indexer is not allowed for .iloc\n"
 1281:             "Consider using .loc for automatic alignment."
 1282:         )
 1283:         with pytest.raises(IndexError, match=msg):
 1284:             df.iloc[indexer]
 1285: 
 1286: 
 1287: class TestILocSetItemDuplicateColumns:
 1288:     def test_iloc_setitem_scalar_duplicate_columns(self):
 1289:         # GH#15686, duplicate columns and mixed dtype
 1290:         df1 = DataFrame([{"A": None, "B": 1}, {"A": 2, "B": 2}])
 1291:         df2 = DataFrame([{"A": 3, "B": 3}, {"A": 4, "B": 4}])
 1292:         df = concat([df1, df2], axis=1)
 1293:         df.iloc[0, 0] = -1
 1294: 
 1295:         assert df.iloc[0, 0] == -1
 1296:         assert df.iloc[0, 2] == 3
 1297:         assert df.dtypes.iloc[2] == np.int64
 1298: 
 1299:     def test_iloc_setitem_list_duplicate_columns(self):
 1300:         # GH#22036 setting with same-sized list
 1301:         df = DataFrame([[0, "str", "str2"]], columns=["a", "b", "b"])
 1302: 
 1303:         df.iloc[:, 2] = ["str3"]
 1304: 
 1305:         expected = DataFrame([[0, "str", "str3"]], columns=["a", "b", "b"])
 1306:         tm.assert_frame_equal(df, expected)
 1307: 
 1308:     def test_iloc_setitem_series_duplicate_columns(self):
 1309:         df = DataFrame(
 1310:             np.arange(8, dtype=np.int64).reshape(2, 4), columns=["A", "B", "A", "B"]
 1311:         )
 1312:         df.iloc[:, 0] = df.iloc[:, 0].astype(np.float64)
 1313:         assert df.dtypes.iloc[2] == np.int64
 1314: 
 1315:     @pytest.mark.parametrize(
 1316:         ["dtypes", "init_value", "expected_value"],
 1317:         [("int64", "0", 0), ("float", "1.2", 1.2)],
 1318:     )
 1319:     def test_iloc_setitem_dtypes_duplicate_columns(
 1320:         self, dtypes, init_value, expected_value
 1321:     ):
 1322:         # GH#22035
 1323:         df = DataFrame(
 1324:             [[init_value, "str", "str2"]], columns=["a", "b", "b"], dtype=object
 1325:         )
 1326: 
 1327:         # with the enforcement of GH#45333 in 2.0, this sets values inplace,
 1328:         #  so we retain object dtype
 1329:         df.iloc[:, 0] = df.iloc[:, 0].astype(dtypes)
 1330: 
 1331:         expected_df = DataFrame(
 1332:             [[expected_value, "str", "str2"]],
 1333:             columns=["a", "b", "b"],
 1334:             dtype=object,
 1335:         )
 1336:         tm.assert_frame_equal(df, expected_df)
 1337: 
 1338: 
 1339: class TestILocCallable:
 1340:     def test_frame_iloc_getitem_callable(self):
 1341:         # GH#11485
 1342:         df = DataFrame({"X": [1, 2, 3, 4], "Y": list("aabb")}, index=list("ABCD"))
 1343: 
 1344:         # return location
 1345:         res = df.iloc[lambda x: [1, 3]]
 1346:         tm.assert_frame_equal(res, df.iloc[[1, 3]])
 1347: 
 1348:         res = df.iloc[lambda x: [1, 3], :]
 1349:         tm.assert_frame_equal(res, df.iloc[[1, 3], :])
 1350: 
 1351:         res = df.iloc[lambda x: [1, 3], lambda x: 0]
 1352:         tm.assert_series_equal(res, df.iloc[[1, 3], 0])
 1353: 
 1354:         res = df.iloc[lambda x: [1, 3], lambda x: [0]]
 1355:         tm.assert_frame_equal(res, df.iloc[[1, 3], [0]])
 1356: 
 1357:         # mixture
 1358:         res = df.iloc[[1, 3], lambda x: 0]
 1359:         tm.assert_series_equal(res, df.iloc[[1, 3], 0])
 1360: 
 1361:         res = df.iloc[[1, 3], lambda x: [0]]
 1362:         tm.assert_frame_equal(res, df.iloc[[1, 3], [0]])
 1363: 
 1364:         res = df.iloc[lambda x: [1, 3], 0]
 1365:         tm.assert_series_equal(res, df.iloc[[1, 3], 0])
 1366: 
 1367:         res = df.iloc[lambda x: [1, 3], [0]]
 1368:         tm.assert_frame_equal(res, df.iloc[[1, 3], [0]])
 1369: 
 1370:     def test_frame_iloc_setitem_callable(self):
 1371:         # GH#11485
 1372:         df = DataFrame(
 1373:             {"X": [1, 2, 3, 4], "Y": Series(list("aabb"), dtype=object)},
 1374:             index=list("ABCD"),
 1375:         )
 1376: 
 1377:         # return location
 1378:         res = df.copy()
 1379:         res.iloc[lambda x: [1, 3]] = 0
 1380:         exp = df.copy()
 1381:         exp.iloc[[1, 3]] = 0
 1382:         tm.assert_frame_equal(res, exp)
 1383: 
 1384:         res = df.copy()
 1385:         res.iloc[lambda x: [1, 3], :] = -1
 1386:         exp = df.copy()
 1387:         exp.iloc[[1, 3], :] = -1
 1388:         tm.assert_frame_equal(res, exp)
 1389: 
 1390:         res = df.copy()
 1391:         res.iloc[lambda x: [1, 3], lambda x: 0] = 5
 1392:         exp = df.copy()
 1393:         exp.iloc[[1, 3], 0] = 5
 1394:         tm.assert_frame_equal(res, exp)
 1395: 
 1396:         res = df.copy()
 1397:         res.iloc[lambda x: [1, 3], lambda x: [0]] = 25
 1398:         exp = df.copy()
 1399:         exp.iloc[[1, 3], [0]] = 25
 1400:         tm.assert_frame_equal(res, exp)
 1401: 
 1402:         # mixture
 1403:         res = df.copy()
 1404:         res.iloc[[1, 3], lambda x: 0] = -3
 1405:         exp = df.copy()
 1406:         exp.iloc[[1, 3], 0] = -3
 1407:         tm.assert_frame_equal(res, exp)
 1408: 
 1409:         res = df.copy()
 1410:         res.iloc[[1, 3], lambda x: [0]] = -5
 1411:         exp = df.copy()
 1412:         exp.iloc[[1, 3], [0]] = -5
 1413:         tm.assert_frame_equal(res, exp)
 1414: 
 1415:         res = df.copy()
 1416:         res.iloc[lambda x: [1, 3], 0] = 10
 1417:         exp = df.copy()
 1418:         exp.iloc[[1, 3], 0] = 10
 1419:         tm.assert_frame_equal(res, exp)
 1420: 
 1421:         res = df.copy()
 1422:         res.iloc[lambda x: [1, 3], [0]] = [-5, -5]
 1423:         exp = df.copy()
 1424:         exp.iloc[[1, 3], [0]] = [-5, -5]
 1425:         tm.assert_frame_equal(res, exp)
 1426: 
 1427: 
 1428: class TestILocSeries:
 1429:     def test_iloc(self, using_copy_on_write, warn_copy_on_write):
 1430:         ser = Series(
 1431:             np.random.default_rng(2).standard_normal(10), index=list(range(0, 20, 2))
 1432:         )
 1433:         ser_original = ser.copy()
 1434: 
 1435:         for i in range(len(ser)):
 1436:             result = ser.iloc[i]
 1437:             exp = ser[ser.index[i]]
 1438:             tm.assert_almost_equal(result, exp)
 1439: 
 1440:         # pass a slice
 1441:         result = ser.iloc[slice(1, 3)]
 1442:         expected = ser.loc[2:4]
 1443:         tm.assert_series_equal(result, expected)
 1444: 
 1445:         # test slice is a view
 1446:         with tm.assert_produces_warning(None):
 1447:             # GH#45324 make sure we aren't giving a spurious FutureWarning
 1448:             with tm.assert_cow_warning(warn_copy_on_write):
 1449:                 result[:] = 0
 1450:         if using_copy_on_write:
 1451:             tm.assert_series_equal(ser, ser_original)
 1452:         else:
 1453:             assert (ser.iloc[1:3] == 0).all()
 1454: 
 1455:         # list of integers
 1456:         result = ser.iloc[[0, 2, 3, 4, 5]]
 1457:         expected = ser.reindex(ser.index[[0, 2, 3, 4, 5]])
 1458:         tm.assert_series_equal(result, expected)
 1459: 
 1460:     def test_iloc_getitem_nonunique(self):
 1461:         ser = Series([0, 1, 2], index=[0, 1, 0])
 1462:         assert ser.iloc[2] == 2
 1463: 
 1464:     def test_iloc_setitem_pure_position_based(self):
 1465:         # GH#22046
 1466:         ser1 = Series([1, 2, 3])
 1467:         ser2 = Series([4, 5, 6], index=[1, 0, 2])
 1468:         ser1.iloc[1:3] = ser2.iloc[1:3]
 1469:         expected = Series([1, 5, 6])
 1470:         tm.assert_series_equal(ser1, expected)
 1471: 
 1472:     def test_iloc_nullable_int64_size_1_nan(self):
 1473:         # GH 31861
 1474:         result = DataFrame({"a": ["test"], "b": [np.nan]})
 1475:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1476:             result.loc[:, "b"] = result.loc[:, "b"].astype("Int64")
 1477:         expected = DataFrame({"a": ["test"], "b": array([NA], dtype="Int64")})
 1478:         tm.assert_frame_equal(result, expected)
