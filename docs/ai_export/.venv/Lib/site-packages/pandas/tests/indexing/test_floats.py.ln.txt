    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     Index,
    7:     RangeIndex,
    8:     Series,
    9:     date_range,
   10:     period_range,
   11:     timedelta_range,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: def gen_obj(klass, index):
   17:     if klass is Series:
   18:         obj = Series(np.arange(len(index)), index=index)
   19:     else:
   20:         obj = DataFrame(
   21:             np.random.default_rng(2).standard_normal((len(index), len(index))),
   22:             index=index,
   23:             columns=index,
   24:         )
   25:     return obj
   26: 
   27: 
   28: class TestFloatIndexers:
   29:     def check(self, result, original, indexer, getitem):
   30:         """
   31:         comparator for results
   32:         we need to take care if we are indexing on a
   33:         Series or a frame
   34:         """
   35:         if isinstance(original, Series):
   36:             expected = original.iloc[indexer]
   37:         elif getitem:
   38:             expected = original.iloc[:, indexer]
   39:         else:
   40:             expected = original.iloc[indexer]
   41: 
   42:         tm.assert_almost_equal(result, expected)
   43: 
   44:     @pytest.mark.parametrize(
   45:         "index",
   46:         [
   47:             Index(list("abcde")),
   48:             Index(list("abcde"), dtype="category"),
   49:             date_range("2020-01-01", periods=5),
   50:             timedelta_range("1 day", periods=5),
   51:             period_range("2020-01-01", periods=5),
   52:         ],
   53:     )
   54:     def test_scalar_non_numeric(self, index, frame_or_series, indexer_sl):
   55:         # GH 4892
   56:         # float_indexers should raise exceptions
   57:         # on appropriate Index types & accessors
   58: 
   59:         s = gen_obj(frame_or_series, index)
   60: 
   61:         # getting
   62:         with pytest.raises(KeyError, match="^3.0$"):
   63:             indexer_sl(s)[3.0]
   64: 
   65:         # contains
   66:         assert 3.0 not in s
   67: 
   68:         s2 = s.copy()
   69:         indexer_sl(s2)[3.0] = 10
   70: 
   71:         if indexer_sl is tm.setitem:
   72:             assert 3.0 in s2.axes[-1]
   73:         elif indexer_sl is tm.loc:
   74:             assert 3.0 in s2.axes[0]
   75:         else:
   76:             assert 3.0 not in s2.axes[0]
   77:             assert 3.0 not in s2.axes[-1]
   78: 
   79:     @pytest.mark.parametrize(
   80:         "index",
   81:         [
   82:             Index(list("abcde")),
   83:             Index(list("abcde"), dtype="category"),
   84:             date_range("2020-01-01", periods=5),
   85:             timedelta_range("1 day", periods=5),
   86:             period_range("2020-01-01", periods=5),
   87:         ],
   88:     )
   89:     def test_scalar_non_numeric_series_fallback(self, index):
   90:         # fallsback to position selection, series only
   91:         s = Series(np.arange(len(index)), index=index)
   92: 
   93:         msg = "Series.__getitem__ treating keys as positions is deprecated"
   94:         with tm.assert_produces_warning(FutureWarning, match=msg):
   95:             s[3]
   96:         with pytest.raises(KeyError, match="^3.0$"):
   97:             s[3.0]
   98: 
   99:     def test_scalar_with_mixed(self, indexer_sl):
  100:         s2 = Series([1, 2, 3], index=["a", "b", "c"])
  101:         s3 = Series([1, 2, 3], index=["a", "b", 1.5])
  102: 
  103:         # lookup in a pure string index with an invalid indexer
  104: 
  105:         with pytest.raises(KeyError, match="^1.0$"):
  106:             indexer_sl(s2)[1.0]
  107: 
  108:         with pytest.raises(KeyError, match=r"^1\.0$"):
  109:             indexer_sl(s2)[1.0]
  110: 
  111:         result = indexer_sl(s2)["b"]
  112:         expected = 2
  113:         assert result == expected
  114: 
  115:         # mixed index so we have label
  116:         # indexing
  117:         with pytest.raises(KeyError, match="^1.0$"):
  118:             indexer_sl(s3)[1.0]
  119: 
  120:         if indexer_sl is not tm.loc:
  121:             # __getitem__ falls back to positional
  122:             msg = "Series.__getitem__ treating keys as positions is deprecated"
  123:             with tm.assert_produces_warning(FutureWarning, match=msg):
  124:                 result = s3[1]
  125:             expected = 2
  126:             assert result == expected
  127: 
  128:         with pytest.raises(KeyError, match=r"^1\.0$"):
  129:             indexer_sl(s3)[1.0]
  130: 
  131:         result = indexer_sl(s3)[1.5]
  132:         expected = 3
  133:         assert result == expected
  134: 
  135:     @pytest.mark.parametrize(
  136:         "index", [Index(np.arange(5), dtype=np.int64), RangeIndex(5)]
  137:     )
  138:     def test_scalar_integer(self, index, frame_or_series, indexer_sl):
  139:         getitem = indexer_sl is not tm.loc
  140: 
  141:         # test how scalar float indexers work on int indexes
  142: 
  143:         # integer index
  144:         i = index
  145:         obj = gen_obj(frame_or_series, i)
  146: 
  147:         # coerce to equal int
  148: 
  149:         result = indexer_sl(obj)[3.0]
  150:         self.check(result, obj, 3, getitem)
  151: 
  152:         if isinstance(obj, Series):
  153: 
  154:             def compare(x, y):
  155:                 assert x == y
  156: 
  157:             expected = 100
  158:         else:
  159:             compare = tm.assert_series_equal
  160:             if getitem:
  161:                 expected = Series(100, index=range(len(obj)), name=3)
  162:             else:
  163:                 expected = Series(100.0, index=range(len(obj)), name=3)
  164: 
  165:         s2 = obj.copy()
  166:         indexer_sl(s2)[3.0] = 100
  167: 
  168:         result = indexer_sl(s2)[3.0]
  169:         compare(result, expected)
  170: 
  171:         result = indexer_sl(s2)[3]
  172:         compare(result, expected)
  173: 
  174:     @pytest.mark.parametrize(
  175:         "index", [Index(np.arange(5), dtype=np.int64), RangeIndex(5)]
  176:     )
  177:     def test_scalar_integer_contains_float(self, index, frame_or_series):
  178:         # contains
  179:         # integer index
  180:         obj = gen_obj(frame_or_series, index)
  181: 
  182:         # coerce to equal int
  183:         assert 3.0 in obj
  184: 
  185:     def test_scalar_float(self, frame_or_series):
  186:         # scalar float indexers work on a float index
  187:         index = Index(np.arange(5.0))
  188:         s = gen_obj(frame_or_series, index)
  189: 
  190:         # assert all operations except for iloc are ok
  191:         indexer = index[3]
  192:         for idxr in [tm.loc, tm.setitem]:
  193:             getitem = idxr is not tm.loc
  194: 
  195:             # getting
  196:             result = idxr(s)[indexer]
  197:             self.check(result, s, 3, getitem)
  198: 
  199:             # setting
  200:             s2 = s.copy()
  201: 
  202:             result = idxr(s2)[indexer]
  203:             self.check(result, s, 3, getitem)
  204: 
  205:             # random float is a KeyError
  206:             with pytest.raises(KeyError, match=r"^3\.5$"):
  207:                 idxr(s)[3.5]
  208: 
  209:         # contains
  210:         assert 3.0 in s
  211: 
  212:         # iloc succeeds with an integer
  213:         expected = s.iloc[3]
  214:         s2 = s.copy()
  215: 
  216:         s2.iloc[3] = expected
  217:         result = s2.iloc[3]
  218:         self.check(result, s, 3, False)
  219: 
  220:     @pytest.mark.parametrize(
  221:         "index",
  222:         [
  223:             Index(list("abcde"), dtype=object),
  224:             date_range("2020-01-01", periods=5),
  225:             timedelta_range("1 day", periods=5),
  226:             period_range("2020-01-01", periods=5),
  227:         ],
  228:     )
  229:     @pytest.mark.parametrize("idx", [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)])
  230:     def test_slice_non_numeric(self, index, idx, frame_or_series, indexer_sli):
  231:         # GH 4892
  232:         # float_indexers should raise exceptions
  233:         # on appropriate Index types & accessors
  234: 
  235:         s = gen_obj(frame_or_series, index)
  236: 
  237:         # getitem
  238:         if indexer_sli is tm.iloc:
  239:             msg = (
  240:                 "cannot do positional indexing "
  241:                 rf"on {type(index).__name__} with these indexers \[(3|4)\.0\] of "
  242:                 "type float"
  243:             )
  244:         else:
  245:             msg = (
  246:                 "cannot do slice indexing "
  247:                 rf"on {type(index).__name__} with these indexers "
  248:                 r"\[(3|4)(\.0)?\] "
  249:                 r"of type (float|int)"
  250:             )
  251:         with pytest.raises(TypeError, match=msg):
  252:             indexer_sli(s)[idx]
  253: 
  254:         # setitem
  255:         if indexer_sli is tm.iloc:
  256:             # otherwise we keep the same message as above
  257:             msg = "slice indices must be integers or None or have an __index__ method"
  258:         with pytest.raises(TypeError, match=msg):
  259:             indexer_sli(s)[idx] = 0
  260: 
  261:     def test_slice_integer(self):
  262:         # same as above, but for Integer based indexes
  263:         # these coerce to a like integer
  264:         # oob indicates if we are out of bounds
  265:         # of positional indexing
  266:         for index, oob in [
  267:             (Index(np.arange(5, dtype=np.int64)), False),
  268:             (RangeIndex(5), False),
  269:             (Index(np.arange(5, dtype=np.int64) + 10), True),
  270:         ]:
  271:             # s is an in-range index
  272:             s = Series(range(5), index=index)
  273: 
  274:             # getitem
  275:             for idx in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:
  276:                 result = s.loc[idx]
  277: 
  278:                 # these are all label indexing
  279:                 # except getitem which is positional
  280:                 # empty
  281:                 if oob:
  282:                     indexer = slice(0, 0)
  283:                 else:
  284:                     indexer = slice(3, 5)
  285:                 self.check(result, s, indexer, False)
  286: 
  287:             # getitem out-of-bounds
  288:             for idx in [slice(-6, 6), slice(-6.0, 6.0)]:
  289:                 result = s.loc[idx]
  290: 
  291:                 # these are all label indexing
  292:                 # except getitem which is positional
  293:                 # empty
  294:                 if oob:
  295:                     indexer = slice(0, 0)
  296:                 else:
  297:                     indexer = slice(-6, 6)
  298:                 self.check(result, s, indexer, False)
  299: 
  300:             # positional indexing
  301:             msg = (
  302:                 "cannot do slice indexing "
  303:                 rf"on {type(index).__name__} with these indexers \[-6\.0\] of "
  304:                 "type float"
  305:             )
  306:             with pytest.raises(TypeError, match=msg):
  307:                 s[slice(-6.0, 6.0)]
  308: 
  309:             # getitem odd floats
  310:             for idx, res1 in [
  311:                 (slice(2.5, 4), slice(3, 5)),
  312:                 (slice(2, 3.5), slice(2, 4)),
  313:                 (slice(2.5, 3.5), slice(3, 4)),
  314:             ]:
  315:                 result = s.loc[idx]
  316:                 if oob:
  317:                     res = slice(0, 0)
  318:                 else:
  319:                     res = res1
  320: 
  321:                 self.check(result, s, res, False)
  322: 
  323:                 # positional indexing
  324:                 msg = (
  325:                     "cannot do slice indexing "
  326:                     rf"on {type(index).__name__} with these indexers \[(2|3)\.5\] of "
  327:                     "type float"
  328:                 )
  329:                 with pytest.raises(TypeError, match=msg):
  330:                     s[idx]
  331: 
  332:     @pytest.mark.parametrize("idx", [slice(2, 4.0), slice(2.0, 4), slice(2.0, 4.0)])
  333:     def test_integer_positional_indexing(self, idx):
  334:         """make sure that we are raising on positional indexing
  335:         w.r.t. an integer index
  336:         """
  337:         s = Series(range(2, 6), index=range(2, 6))
  338: 
  339:         result = s[2:4]
  340:         expected = s.iloc[2:4]
  341:         tm.assert_series_equal(result, expected)
  342: 
  343:         klass = RangeIndex
  344:         msg = (
  345:             "cannot do (slice|positional) indexing "
  346:             rf"on {klass.__name__} with these indexers \[(2|4)\.0\] of "
  347:             "type float"
  348:         )
  349:         with pytest.raises(TypeError, match=msg):
  350:             s[idx]
  351:         with pytest.raises(TypeError, match=msg):
  352:             s.iloc[idx]
  353: 
  354:     @pytest.mark.parametrize(
  355:         "index", [Index(np.arange(5), dtype=np.int64), RangeIndex(5)]
  356:     )
  357:     def test_slice_integer_frame_getitem(self, index):
  358:         # similar to above, but on the getitem dim (of a DataFrame)
  359:         s = DataFrame(np.random.default_rng(2).standard_normal((5, 2)), index=index)
  360: 
  361:         # getitem
  362:         for idx in [slice(0.0, 1), slice(0, 1.0), slice(0.0, 1.0)]:
  363:             result = s.loc[idx]
  364:             indexer = slice(0, 2)
  365:             self.check(result, s, indexer, False)
  366: 
  367:             # positional indexing
  368:             msg = (
  369:                 "cannot do slice indexing "
  370:                 rf"on {type(index).__name__} with these indexers \[(0|1)\.0\] of "
  371:                 "type float"
  372:             )
  373:             with pytest.raises(TypeError, match=msg):
  374:                 s[idx]
  375: 
  376:         # getitem out-of-bounds
  377:         for idx in [slice(-10, 10), slice(-10.0, 10.0)]:
  378:             result = s.loc[idx]
  379:             self.check(result, s, slice(-10, 10), True)
  380: 
  381:         # positional indexing
  382:         msg = (
  383:             "cannot do slice indexing "
  384:             rf"on {type(index).__name__} with these indexers \[-10\.0\] of "
  385:             "type float"
  386:         )
  387:         with pytest.raises(TypeError, match=msg):
  388:             s[slice(-10.0, 10.0)]
  389: 
  390:         # getitem odd floats
  391:         for idx, res in [
  392:             (slice(0.5, 1), slice(1, 2)),
  393:             (slice(0, 0.5), slice(0, 1)),
  394:             (slice(0.5, 1.5), slice(1, 2)),
  395:         ]:
  396:             result = s.loc[idx]
  397:             self.check(result, s, res, False)
  398: 
  399:             # positional indexing
  400:             msg = (
  401:                 "cannot do slice indexing "
  402:                 rf"on {type(index).__name__} with these indexers \[0\.5\] of "
  403:                 "type float"
  404:             )
  405:             with pytest.raises(TypeError, match=msg):
  406:                 s[idx]
  407: 
  408:     @pytest.mark.parametrize("idx", [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)])
  409:     @pytest.mark.parametrize(
  410:         "index", [Index(np.arange(5), dtype=np.int64), RangeIndex(5)]
  411:     )
  412:     def test_float_slice_getitem_with_integer_index_raises(self, idx, index):
  413:         # similar to above, but on the getitem dim (of a DataFrame)
  414:         s = DataFrame(np.random.default_rng(2).standard_normal((5, 2)), index=index)
  415: 
  416:         # setitem
  417:         sc = s.copy()
  418:         sc.loc[idx] = 0
  419:         result = sc.loc[idx].values.ravel()
  420:         assert (result == 0).all()
  421: 
  422:         # positional indexing
  423:         msg = (
  424:             "cannot do slice indexing "
  425:             rf"on {type(index).__name__} with these indexers \[(3|4)\.0\] of "
  426:             "type float"
  427:         )
  428:         with pytest.raises(TypeError, match=msg):
  429:             s[idx] = 0
  430: 
  431:         with pytest.raises(TypeError, match=msg):
  432:             s[idx]
  433: 
  434:     @pytest.mark.parametrize("idx", [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)])
  435:     def test_slice_float(self, idx, frame_or_series, indexer_sl):
  436:         # same as above, but for floats
  437:         index = Index(np.arange(5.0)) + 0.1
  438:         s = gen_obj(frame_or_series, index)
  439: 
  440:         expected = s.iloc[3:4]
  441: 
  442:         # getitem
  443:         result = indexer_sl(s)[idx]
  444:         assert isinstance(result, type(s))
  445:         tm.assert_equal(result, expected)
  446: 
  447:         # setitem
  448:         s2 = s.copy()
  449:         indexer_sl(s2)[idx] = 0
  450:         result = indexer_sl(s2)[idx].values.ravel()
  451:         assert (result == 0).all()
  452: 
  453:     def test_floating_index_doc_example(self):
  454:         index = Index([1.5, 2, 3, 4.5, 5])
  455:         s = Series(range(5), index=index)
  456:         assert s[3] == 2
  457:         assert s.loc[3] == 2
  458:         assert s.iloc[3] == 3
  459: 
  460:     def test_floating_misc(self, indexer_sl):
  461:         # related 236
  462:         # scalar/slicing of a float index
  463:         s = Series(np.arange(5), index=np.arange(5) * 2.5, dtype=np.int64)
  464: 
  465:         # label based slicing
  466:         result = indexer_sl(s)[1.0:3.0]
  467:         expected = Series(1, index=[2.5])
  468:         tm.assert_series_equal(result, expected)
  469: 
  470:         # exact indexing when found
  471: 
  472:         result = indexer_sl(s)[5.0]
  473:         assert result == 2
  474: 
  475:         result = indexer_sl(s)[5]
  476:         assert result == 2
  477: 
  478:         # value not found (and no fallbacking at all)
  479: 
  480:         # scalar integers
  481:         with pytest.raises(KeyError, match=r"^4$"):
  482:             indexer_sl(s)[4]
  483: 
  484:         # fancy floats/integers create the correct entry (as nan)
  485:         # fancy tests
  486:         expected = Series([2, 0], index=Index([5.0, 0.0], dtype=np.float64))
  487:         for fancy_idx in [[5.0, 0.0], np.array([5.0, 0.0])]:  # float
  488:             tm.assert_series_equal(indexer_sl(s)[fancy_idx], expected)
  489: 
  490:         expected = Series([2, 0], index=Index([5, 0], dtype="float64"))
  491:         for fancy_idx in [[5, 0], np.array([5, 0])]:
  492:             tm.assert_series_equal(indexer_sl(s)[fancy_idx], expected)
  493: 
  494:         warn = FutureWarning if indexer_sl is tm.setitem else None
  495:         msg = r"The behavior of obj\[i:j\] with a float-dtype index"
  496: 
  497:         # all should return the same as we are slicing 'the same'
  498:         with tm.assert_produces_warning(warn, match=msg):
  499:             result1 = indexer_sl(s)[2:5]
  500:         result2 = indexer_sl(s)[2.0:5.0]
  501:         result3 = indexer_sl(s)[2.0:5]
  502:         result4 = indexer_sl(s)[2.1:5]
  503:         tm.assert_series_equal(result1, result2)
  504:         tm.assert_series_equal(result1, result3)
  505:         tm.assert_series_equal(result1, result4)
  506: 
  507:         expected = Series([1, 2], index=[2.5, 5.0])
  508:         with tm.assert_produces_warning(warn, match=msg):
  509:             result = indexer_sl(s)[2:5]
  510: 
  511:         tm.assert_series_equal(result, expected)
  512: 
  513:         # list selection
  514:         result1 = indexer_sl(s)[[0.0, 5, 10]]
  515:         result2 = s.iloc[[0, 2, 4]]
  516:         tm.assert_series_equal(result1, result2)
  517: 
  518:         with pytest.raises(KeyError, match="not in index"):
  519:             indexer_sl(s)[[1.6, 5, 10]]
  520: 
  521:         with pytest.raises(KeyError, match="not in index"):
  522:             indexer_sl(s)[[0, 1, 2]]
  523: 
  524:         result = indexer_sl(s)[[2.5, 5]]
  525:         tm.assert_series_equal(result, Series([1, 2], index=[2.5, 5.0]))
  526: 
  527:         result = indexer_sl(s)[[2.5]]
  528:         tm.assert_series_equal(result, Series([1], index=[2.5]))
  529: 
  530:     def test_floatindex_slicing_bug(self, float_numpy_dtype):
  531:         # GH 5557, related to slicing a float index
  532:         dtype = float_numpy_dtype
  533:         ser = {
  534:             256: 2321.0,
  535:             1: 78.0,
  536:             2: 2716.0,
  537:             3: 0.0,
  538:             4: 369.0,
  539:             5: 0.0,
  540:             6: 269.0,
  541:             7: 0.0,
  542:             8: 0.0,
  543:             9: 0.0,
  544:             10: 3536.0,
  545:             11: 0.0,
  546:             12: 24.0,
  547:             13: 0.0,
  548:             14: 931.0,
  549:             15: 0.0,
  550:             16: 101.0,
  551:             17: 78.0,
  552:             18: 9643.0,
  553:             19: 0.0,
  554:             20: 0.0,
  555:             21: 0.0,
  556:             22: 63761.0,
  557:             23: 0.0,
  558:             24: 446.0,
  559:             25: 0.0,
  560:             26: 34773.0,
  561:             27: 0.0,
  562:             28: 729.0,
  563:             29: 78.0,
  564:             30: 0.0,
  565:             31: 0.0,
  566:             32: 3374.0,
  567:             33: 0.0,
  568:             34: 1391.0,
  569:             35: 0.0,
  570:             36: 361.0,
  571:             37: 0.0,
  572:             38: 61808.0,
  573:             39: 0.0,
  574:             40: 0.0,
  575:             41: 0.0,
  576:             42: 6677.0,
  577:             43: 0.0,
  578:             44: 802.0,
  579:             45: 0.0,
  580:             46: 2691.0,
  581:             47: 0.0,
  582:             48: 3582.0,
  583:             49: 0.0,
  584:             50: 734.0,
  585:             51: 0.0,
  586:             52: 627.0,
  587:             53: 70.0,
  588:             54: 2584.0,
  589:             55: 0.0,
  590:             56: 324.0,
  591:             57: 0.0,
  592:             58: 605.0,
  593:             59: 0.0,
  594:             60: 0.0,
  595:             61: 0.0,
  596:             62: 3989.0,
  597:             63: 10.0,
  598:             64: 42.0,
  599:             65: 0.0,
  600:             66: 904.0,
  601:             67: 0.0,
  602:             68: 88.0,
  603:             69: 70.0,
  604:             70: 8172.0,
  605:             71: 0.0,
  606:             72: 0.0,
  607:             73: 0.0,
  608:             74: 64902.0,
  609:             75: 0.0,
  610:             76: 347.0,
  611:             77: 0.0,
  612:             78: 36605.0,
  613:             79: 0.0,
  614:             80: 379.0,
  615:             81: 70.0,
  616:             82: 0.0,
  617:             83: 0.0,
  618:             84: 3001.0,
  619:             85: 0.0,
  620:             86: 1630.0,
  621:             87: 7.0,
  622:             88: 364.0,
  623:             89: 0.0,
  624:             90: 67404.0,
  625:             91: 9.0,
  626:             92: 0.0,
  627:             93: 0.0,
  628:             94: 7685.0,
  629:             95: 0.0,
  630:             96: 1017.0,
  631:             97: 0.0,
  632:             98: 2831.0,
  633:             99: 0.0,
  634:             100: 2963.0,
  635:             101: 0.0,
  636:             102: 854.0,
  637:             103: 0.0,
  638:             104: 0.0,
  639:             105: 0.0,
  640:             106: 0.0,
  641:             107: 0.0,
  642:             108: 0.0,
  643:             109: 0.0,
  644:             110: 0.0,
  645:             111: 0.0,
  646:             112: 0.0,
  647:             113: 0.0,
  648:             114: 0.0,
  649:             115: 0.0,
  650:             116: 0.0,
  651:             117: 0.0,
  652:             118: 0.0,
  653:             119: 0.0,
  654:             120: 0.0,
  655:             121: 0.0,
  656:             122: 0.0,
  657:             123: 0.0,
  658:             124: 0.0,
  659:             125: 0.0,
  660:             126: 67744.0,
  661:             127: 22.0,
  662:             128: 264.0,
  663:             129: 0.0,
  664:             260: 197.0,
  665:             268: 0.0,
  666:             265: 0.0,
  667:             269: 0.0,
  668:             261: 0.0,
  669:             266: 1198.0,
  670:             267: 0.0,
  671:             262: 2629.0,
  672:             258: 775.0,
  673:             257: 0.0,
  674:             263: 0.0,
  675:             259: 0.0,
  676:             264: 163.0,
  677:             250: 10326.0,
  678:             251: 0.0,
  679:             252: 1228.0,
  680:             253: 0.0,
  681:             254: 2769.0,
  682:             255: 0.0,
  683:         }
  684: 
  685:         # smoke test for the repr
  686:         s = Series(ser, dtype=dtype)
  687:         result = s.value_counts()
  688:         assert result.index.dtype == dtype
  689:         str(result)
