    1: """ test label based indexing with loc """
    2: from collections import namedtuple
    3: from datetime import (
    4:     date,
    5:     datetime,
    6:     time,
    7:     timedelta,
    8: )
    9: import re
   10: 
   11: from dateutil.tz import gettz
   12: import numpy as np
   13: import pytest
   14: 
   15: from pandas._config import using_pyarrow_string_dtype
   16: 
   17: from pandas._libs import index as libindex
   18: from pandas.compat.numpy import np_version_gt2
   19: from pandas.errors import IndexingError
   20: import pandas.util._test_decorators as td
   21: 
   22: import pandas as pd
   23: from pandas import (
   24:     Categorical,
   25:     CategoricalDtype,
   26:     CategoricalIndex,
   27:     DataFrame,
   28:     DatetimeIndex,
   29:     Index,
   30:     IndexSlice,
   31:     MultiIndex,
   32:     Period,
   33:     PeriodIndex,
   34:     Series,
   35:     SparseDtype,
   36:     Timedelta,
   37:     Timestamp,
   38:     date_range,
   39:     timedelta_range,
   40:     to_datetime,
   41:     to_timedelta,
   42: )
   43: import pandas._testing as tm
   44: from pandas.api.types import is_scalar
   45: from pandas.core.indexing import _one_ellipsis_message
   46: from pandas.tests.indexing.common import check_indexing_smoketest_or_raises
   47: 
   48: 
   49: @pytest.mark.parametrize(
   50:     "series, new_series, expected_ser",
   51:     [
   52:         [[np.nan, np.nan, "b"], ["a", np.nan, np.nan], [False, True, True]],
   53:         [[np.nan, "b"], ["a", np.nan], [False, True]],
   54:     ],
   55: )
   56: def test_not_change_nan_loc(series, new_series, expected_ser):
   57:     # GH 28403
   58:     df = DataFrame({"A": series})
   59:     df.loc[:, "A"] = new_series
   60:     expected = DataFrame({"A": expected_ser})
   61:     tm.assert_frame_equal(df.isna(), expected)
   62:     tm.assert_frame_equal(df.notna(), ~expected)
   63: 
   64: 
   65: class TestLoc:
   66:     def test_none_values_on_string_columns(self):
   67:         # Issue #32218
   68:         df = DataFrame(["1", "2", None], columns=["a"], dtype="str")
   69: 
   70:         assert df.loc[2, "a"] is None
   71: 
   72:     @pytest.mark.parametrize("kind", ["series", "frame"])
   73:     def test_loc_getitem_int(self, kind, request):
   74:         # int label
   75:         obj = request.getfixturevalue(f"{kind}_labels")
   76:         check_indexing_smoketest_or_raises(obj, "loc", 2, fails=KeyError)
   77: 
   78:     @pytest.mark.parametrize("kind", ["series", "frame"])
   79:     def test_loc_getitem_label(self, kind, request):
   80:         # label
   81:         obj = request.getfixturevalue(f"{kind}_empty")
   82:         check_indexing_smoketest_or_raises(obj, "loc", "c", fails=KeyError)
   83: 
   84:     @pytest.mark.parametrize(
   85:         "key, typs, axes",
   86:         [
   87:             ["f", ["ints", "uints", "labels", "mixed", "ts"], None],
   88:             ["f", ["floats"], None],
   89:             [20, ["ints", "uints", "mixed"], None],
   90:             [20, ["labels"], None],
   91:             [20, ["ts"], 0],
   92:             [20, ["floats"], 0],
   93:         ],
   94:     )
   95:     @pytest.mark.parametrize("kind", ["series", "frame"])
   96:     def test_loc_getitem_label_out_of_range(self, key, typs, axes, kind, request):
   97:         for typ in typs:
   98:             obj = request.getfixturevalue(f"{kind}_{typ}")
   99:             # out of range label
  100:             check_indexing_smoketest_or_raises(
  101:                 obj, "loc", key, axes=axes, fails=KeyError
  102:             )
  103: 
  104:     @pytest.mark.parametrize(
  105:         "key, typs",
  106:         [
  107:             [[0, 1, 2], ["ints", "uints", "floats"]],
  108:             [[1, 3.0, "A"], ["ints", "uints", "floats"]],
  109:         ],
  110:     )
  111:     @pytest.mark.parametrize("kind", ["series", "frame"])
  112:     def test_loc_getitem_label_list(self, key, typs, kind, request):
  113:         for typ in typs:
  114:             obj = request.getfixturevalue(f"{kind}_{typ}")
  115:             # list of labels
  116:             check_indexing_smoketest_or_raises(obj, "loc", key, fails=KeyError)
  117: 
  118:     @pytest.mark.parametrize(
  119:         "key, typs, axes",
  120:         [
  121:             [[0, 1, 2], ["empty"], None],
  122:             [[0, 2, 10], ["ints", "uints", "floats"], 0],
  123:             [[3, 6, 7], ["ints", "uints", "floats"], 1],
  124:             # GH 17758 - MultiIndex and missing keys
  125:             [[(1, 3), (1, 4), (2, 5)], ["multi"], 0],
  126:         ],
  127:     )
  128:     @pytest.mark.parametrize("kind", ["series", "frame"])
  129:     def test_loc_getitem_label_list_with_missing(self, key, typs, axes, kind, request):
  130:         for typ in typs:
  131:             obj = request.getfixturevalue(f"{kind}_{typ}")
  132:             check_indexing_smoketest_or_raises(
  133:                 obj, "loc", key, axes=axes, fails=KeyError
  134:             )
  135: 
  136:     @pytest.mark.parametrize("typs", ["ints", "uints"])
  137:     @pytest.mark.parametrize("kind", ["series", "frame"])
  138:     def test_loc_getitem_label_list_fails(self, typs, kind, request):
  139:         # fails
  140:         obj = request.getfixturevalue(f"{kind}_{typs}")
  141:         check_indexing_smoketest_or_raises(
  142:             obj, "loc", [20, 30, 40], axes=1, fails=KeyError
  143:         )
  144: 
  145:     def test_loc_getitem_label_array_like(self):
  146:         # TODO: test something?
  147:         # array like
  148:         pass
  149: 
  150:     @pytest.mark.parametrize("kind", ["series", "frame"])
  151:     def test_loc_getitem_bool(self, kind, request):
  152:         obj = request.getfixturevalue(f"{kind}_empty")
  153:         # boolean indexers
  154:         b = [True, False, True, False]
  155: 
  156:         check_indexing_smoketest_or_raises(obj, "loc", b, fails=IndexError)
  157: 
  158:     @pytest.mark.parametrize(
  159:         "slc, typs, axes, fails",
  160:         [
  161:             [
  162:                 slice(1, 3),
  163:                 ["labels", "mixed", "empty", "ts", "floats"],
  164:                 None,
  165:                 TypeError,
  166:             ],
  167:             [slice("20130102", "20130104"), ["ts"], 1, TypeError],
  168:             [slice(2, 8), ["mixed"], 0, TypeError],
  169:             [slice(2, 8), ["mixed"], 1, KeyError],
  170:             [slice(2, 4, 2), ["mixed"], 0, TypeError],
  171:         ],
  172:     )
  173:     @pytest.mark.parametrize("kind", ["series", "frame"])
  174:     def test_loc_getitem_label_slice(self, slc, typs, axes, fails, kind, request):
  175:         # label slices (with ints)
  176: 
  177:         # real label slices
  178: 
  179:         # GH 14316
  180:         for typ in typs:
  181:             obj = request.getfixturevalue(f"{kind}_{typ}")
  182:             check_indexing_smoketest_or_raises(
  183:                 obj,
  184:                 "loc",
  185:                 slc,
  186:                 axes=axes,
  187:                 fails=fails,
  188:             )
  189: 
  190:     def test_setitem_from_duplicate_axis(self):
  191:         # GH#34034
  192:         df = DataFrame(
  193:             [[20, "a"], [200, "a"], [200, "a"]],
  194:             columns=["col1", "col2"],
  195:             index=[10, 1, 1],
  196:         )
  197:         df.loc[1, "col1"] = np.arange(2)
  198:         expected = DataFrame(
  199:             [[20, "a"], [0, "a"], [1, "a"]], columns=["col1", "col2"], index=[10, 1, 1]
  200:         )
  201:         tm.assert_frame_equal(df, expected)
  202: 
  203:     def test_column_types_consistent(self):
  204:         # GH 26779
  205:         df = DataFrame(
  206:             data={
  207:                 "channel": [1, 2, 3],
  208:                 "A": ["String 1", np.nan, "String 2"],
  209:                 "B": [
  210:                     Timestamp("2019-06-11 11:00:00"),
  211:                     pd.NaT,
  212:                     Timestamp("2019-06-11 12:00:00"),
  213:                 ],
  214:             }
  215:         )
  216:         df2 = DataFrame(
  217:             data={"A": ["String 3"], "B": [Timestamp("2019-06-11 12:00:00")]}
  218:         )
  219:         # Change Columns A and B to df2.values wherever Column A is NaN
  220:         df.loc[df["A"].isna(), ["A", "B"]] = df2.values
  221:         expected = DataFrame(
  222:             data={
  223:                 "channel": [1, 2, 3],
  224:                 "A": ["String 1", "String 3", "String 2"],
  225:                 "B": [
  226:                     Timestamp("2019-06-11 11:00:00"),
  227:                     Timestamp("2019-06-11 12:00:00"),
  228:                     Timestamp("2019-06-11 12:00:00"),
  229:                 ],
  230:             }
  231:         )
  232:         tm.assert_frame_equal(df, expected)
  233: 
  234:     @pytest.mark.parametrize(
  235:         "obj, key, exp",
  236:         [
  237:             (
  238:                 DataFrame([[1]], columns=Index([False])),
  239:                 IndexSlice[:, False],
  240:                 Series([1], name=False),
  241:             ),
  242:             (Series([1], index=Index([False])), False, [1]),
  243:             (DataFrame([[1]], index=Index([False])), False, Series([1], name=False)),
  244:         ],
  245:     )
  246:     def test_loc_getitem_single_boolean_arg(self, obj, key, exp):
  247:         # GH 44322
  248:         res = obj.loc[key]
  249:         if isinstance(exp, (DataFrame, Series)):
  250:             tm.assert_equal(res, exp)
  251:         else:
  252:             assert res == exp
  253: 
  254: 
  255: class TestLocBaseIndependent:
  256:     # Tests for loc that do not depend on subclassing Base
  257:     def test_loc_npstr(self):
  258:         # GH#45580
  259:         df = DataFrame(index=date_range("2021", "2022"))
  260:         result = df.loc[np.array(["2021/6/1"])[0] :]
  261:         expected = df.iloc[151:]
  262:         tm.assert_frame_equal(result, expected)
  263: 
  264:     @pytest.mark.parametrize(
  265:         "msg, key",
  266:         [
  267:             (r"Period\('2019', 'Y-DEC'\), 'foo', 'bar'", (Period(2019), "foo", "bar")),
  268:             (r"Period\('2019', 'Y-DEC'\), 'y1', 'bar'", (Period(2019), "y1", "bar")),
  269:             (r"Period\('2019', 'Y-DEC'\), 'foo', 'z1'", (Period(2019), "foo", "z1")),
  270:             (
  271:                 r"Period\('2018', 'Y-DEC'\), Period\('2016', 'Y-DEC'\), 'bar'",
  272:                 (Period(2018), Period(2016), "bar"),
  273:             ),
  274:             (r"Period\('2018', 'Y-DEC'\), 'foo', 'y1'", (Period(2018), "foo", "y1")),
  275:             (
  276:                 r"Period\('2017', 'Y-DEC'\), 'foo', Period\('2015', 'Y-DEC'\)",
  277:                 (Period(2017), "foo", Period(2015)),
  278:             ),
  279:             (r"Period\('2017', 'Y-DEC'\), 'z1', 'bar'", (Period(2017), "z1", "bar")),
  280:         ],
  281:     )
  282:     def test_contains_raise_error_if_period_index_is_in_multi_index(self, msg, key):
  283:         # GH#20684
  284:         """
  285:         parse_datetime_string_with_reso return parameter if type not matched.
  286:         PeriodIndex.get_loc takes returned value from parse_datetime_string_with_reso
  287:         as a tuple.
  288:         If first argument is Period and a tuple has 3 items,
  289:         process go on not raise exception
  290:         """
  291:         df = DataFrame(
  292:             {
  293:                 "A": [Period(2019), "x1", "x2"],
  294:                 "B": [Period(2018), Period(2016), "y1"],
  295:                 "C": [Period(2017), "z1", Period(2015)],
  296:                 "V1": [1, 2, 3],
  297:                 "V2": [10, 20, 30],
  298:             }
  299:         ).set_index(["A", "B", "C"])
  300:         with pytest.raises(KeyError, match=msg):
  301:             df.loc[key]
  302: 
  303:     def test_loc_getitem_missing_unicode_key(self):
  304:         df = DataFrame({"a": [1]})
  305:         with pytest.raises(KeyError, match="\u05d0"):
  306:             df.loc[:, "\u05d0"]  # should not raise UnicodeEncodeError
  307: 
  308:     def test_loc_getitem_dups(self):
  309:         # GH 5678
  310:         # repeated getitems on a dup index returning a ndarray
  311:         df = DataFrame(
  312:             np.random.default_rng(2).random((20, 5)),
  313:             index=["ABCDE"[x % 5] for x in range(20)],
  314:         )
  315:         expected = df.loc["A", 0]
  316:         result = df.loc[:, 0].loc["A"]
  317:         tm.assert_series_equal(result, expected)
  318: 
  319:     def test_loc_getitem_dups2(self):
  320:         # GH4726
  321:         # dup indexing with iloc/loc
  322:         df = DataFrame(
  323:             [[1, 2, "foo", "bar", Timestamp("20130101")]],
  324:             columns=["a", "a", "a", "a", "a"],
  325:             index=[1],
  326:         )
  327:         expected = Series(
  328:             [1, 2, "foo", "bar", Timestamp("20130101")],
  329:             index=["a", "a", "a", "a", "a"],
  330:             name=1,
  331:         )
  332: 
  333:         result = df.iloc[0]
  334:         tm.assert_series_equal(result, expected)
  335: 
  336:         result = df.loc[1]
  337:         tm.assert_series_equal(result, expected)
  338: 
  339:     def test_loc_setitem_dups(self):
  340:         # GH 6541
  341:         df_orig = DataFrame(
  342:             {
  343:                 "me": list("rttti"),
  344:                 "foo": list("aaade"),
  345:                 "bar": np.arange(5, dtype="float64") * 1.34 + 2,
  346:                 "bar2": np.arange(5, dtype="float64") * -0.34 + 2,
  347:             }
  348:         ).set_index("me")
  349: 
  350:         indexer = (
  351:             "r",
  352:             ["bar", "bar2"],
  353:         )
  354:         df = df_orig.copy()
  355:         df.loc[indexer] *= 2.0
  356:         tm.assert_series_equal(df.loc[indexer], 2.0 * df_orig.loc[indexer])
  357: 
  358:         indexer = (
  359:             "r",
  360:             "bar",
  361:         )
  362:         df = df_orig.copy()
  363:         df.loc[indexer] *= 2.0
  364:         assert df.loc[indexer] == 2.0 * df_orig.loc[indexer]
  365: 
  366:         indexer = (
  367:             "t",
  368:             ["bar", "bar2"],
  369:         )
  370:         df = df_orig.copy()
  371:         df.loc[indexer] *= 2.0
  372:         tm.assert_frame_equal(df.loc[indexer], 2.0 * df_orig.loc[indexer])
  373: 
  374:     def test_loc_setitem_slice(self):
  375:         # GH10503
  376: 
  377:         # assigning the same type should not change the type
  378:         df1 = DataFrame({"a": [0, 1, 1], "b": Series([100, 200, 300], dtype="uint32")})
  379:         ix = df1["a"] == 1
  380:         newb1 = df1.loc[ix, "b"] + 1
  381:         df1.loc[ix, "b"] = newb1
  382:         expected = DataFrame(
  383:             {"a": [0, 1, 1], "b": Series([100, 201, 301], dtype="uint32")}
  384:         )
  385:         tm.assert_frame_equal(df1, expected)
  386: 
  387:         # assigning a new type should get the inferred type
  388:         df2 = DataFrame({"a": [0, 1, 1], "b": [100, 200, 300]}, dtype="uint64")
  389:         ix = df1["a"] == 1
  390:         newb2 = df2.loc[ix, "b"]
  391:         with tm.assert_produces_warning(
  392:             FutureWarning, match="item of incompatible dtype"
  393:         ):
  394:             df1.loc[ix, "b"] = newb2
  395:         expected = DataFrame({"a": [0, 1, 1], "b": [100, 200, 300]}, dtype="uint64")
  396:         tm.assert_frame_equal(df2, expected)
  397: 
  398:     def test_loc_setitem_dtype(self):
  399:         # GH31340
  400:         df = DataFrame({"id": ["A"], "a": [1.2], "b": [0.0], "c": [-2.5]})
  401:         cols = ["a", "b", "c"]
  402:         df.loc[:, cols] = df.loc[:, cols].astype("float32")
  403: 
  404:         # pre-2.0 this setting would swap in new arrays, in 2.0 it is correctly
  405:         #  in-place, consistent with non-split-path
  406:         expected = DataFrame(
  407:             {
  408:                 "id": ["A"],
  409:                 "a": np.array([1.2], dtype="float64"),
  410:                 "b": np.array([0.0], dtype="float64"),
  411:                 "c": np.array([-2.5], dtype="float64"),
  412:             }
  413:         )  # id is inferred as object
  414: 
  415:         tm.assert_frame_equal(df, expected)
  416: 
  417:     def test_getitem_label_list_with_missing(self):
  418:         s = Series(range(3), index=["a", "b", "c"])
  419: 
  420:         # consistency
  421:         with pytest.raises(KeyError, match="not in index"):
  422:             s[["a", "d"]]
  423: 
  424:         s = Series(range(3))
  425:         with pytest.raises(KeyError, match="not in index"):
  426:             s[[0, 3]]
  427: 
  428:     @pytest.mark.parametrize("index", [[True, False], [True, False, True, False]])
  429:     def test_loc_getitem_bool_diff_len(self, index):
  430:         # GH26658
  431:         s = Series([1, 2, 3])
  432:         msg = f"Boolean index has wrong length: {len(index)} instead of {len(s)}"
  433:         with pytest.raises(IndexError, match=msg):
  434:             s.loc[index]
  435: 
  436:     def test_loc_getitem_int_slice(self):
  437:         # TODO: test something here?
  438:         pass
  439: 
  440:     def test_loc_to_fail(self):
  441:         # GH3449
  442:         df = DataFrame(
  443:             np.random.default_rng(2).random((3, 3)),
  444:             index=["a", "b", "c"],
  445:             columns=["e", "f", "g"],
  446:         )
  447: 
  448:         msg = (
  449:             rf"\"None of \[Index\(\[1, 2\], dtype='{np.dtype(int)}'\)\] are "
  450:             r"in the \[index\]\""
  451:         )
  452:         with pytest.raises(KeyError, match=msg):
  453:             df.loc[[1, 2], [1, 2]]
  454: 
  455:     def test_loc_to_fail2(self):
  456:         # GH  7496
  457:         # loc should not fallback
  458: 
  459:         s = Series(dtype=object)
  460:         s.loc[1] = 1
  461:         s.loc["a"] = 2
  462: 
  463:         with pytest.raises(KeyError, match=r"^-1$"):
  464:             s.loc[-1]
  465: 
  466:         msg = (
  467:             rf"\"None of \[Index\(\[-1, -2\], dtype='{np.dtype(int)}'\)\] are "
  468:             r"in the \[index\]\""
  469:         )
  470:         with pytest.raises(KeyError, match=msg):
  471:             s.loc[[-1, -2]]
  472: 
  473:         msg = r"\"None of \[Index\(\['4'\], dtype='object'\)\] are in the \[index\]\""
  474:         with pytest.raises(KeyError, match=msg):
  475:             s.loc[Index(["4"], dtype=object)]
  476: 
  477:         s.loc[-1] = 3
  478:         with pytest.raises(KeyError, match="not in index"):
  479:             s.loc[[-1, -2]]
  480: 
  481:         s["a"] = 2
  482:         msg = (
  483:             rf"\"None of \[Index\(\[-2\], dtype='{np.dtype(int)}'\)\] are "
  484:             r"in the \[index\]\""
  485:         )
  486:         with pytest.raises(KeyError, match=msg):
  487:             s.loc[[-2]]
  488: 
  489:         del s["a"]
  490: 
  491:         with pytest.raises(KeyError, match=msg):
  492:             s.loc[[-2]] = 0
  493: 
  494:     def test_loc_to_fail3(self):
  495:         # inconsistency between .loc[values] and .loc[values,:]
  496:         # GH 7999
  497:         df = DataFrame([["a"], ["b"]], index=[1, 2], columns=["value"])
  498: 
  499:         msg = (
  500:             rf"\"None of \[Index\(\[3\], dtype='{np.dtype(int)}'\)\] are "
  501:             r"in the \[index\]\""
  502:         )
  503:         with pytest.raises(KeyError, match=msg):
  504:             df.loc[[3], :]
  505: 
  506:         with pytest.raises(KeyError, match=msg):
  507:             df.loc[[3]]
  508: 
  509:     def test_loc_getitem_list_with_fail(self):
  510:         # 15747
  511:         # should KeyError if *any* missing labels
  512: 
  513:         s = Series([1, 2, 3])
  514: 
  515:         s.loc[[2]]
  516: 
  517:         msg = f"\"None of [Index([3], dtype='{np.dtype(int)}')] are in the [index]"
  518:         with pytest.raises(KeyError, match=re.escape(msg)):
  519:             s.loc[[3]]
  520: 
  521:         # a non-match and a match
  522:         with pytest.raises(KeyError, match="not in index"):
  523:             s.loc[[2, 3]]
  524: 
  525:     def test_loc_index(self):
  526:         # gh-17131
  527:         # a boolean index should index like a boolean numpy array
  528: 
  529:         df = DataFrame(
  530:             np.random.default_rng(2).random(size=(5, 10)),
  531:             index=["alpha_0", "alpha_1", "alpha_2", "beta_0", "beta_1"],
  532:         )
  533: 
  534:         mask = df.index.map(lambda x: "alpha" in x)
  535:         expected = df.loc[np.array(mask)]
  536: 
  537:         result = df.loc[mask]
  538:         tm.assert_frame_equal(result, expected)
  539: 
  540:         result = df.loc[mask.values]
  541:         tm.assert_frame_equal(result, expected)
  542: 
  543:         result = df.loc[pd.array(mask, dtype="boolean")]
  544:         tm.assert_frame_equal(result, expected)
  545: 
  546:     def test_loc_general(self):
  547:         df = DataFrame(
  548:             np.random.default_rng(2).random((4, 4)),
  549:             columns=["A", "B", "C", "D"],
  550:             index=["A", "B", "C", "D"],
  551:         )
  552: 
  553:         # want this to work
  554:         result = df.loc[:, "A":"B"].iloc[0:2, :]
  555:         assert (result.columns == ["A", "B"]).all()
  556:         assert (result.index == ["A", "B"]).all()
  557: 
  558:         # mixed type
  559:         result = DataFrame({"a": [Timestamp("20130101")], "b": [1]}).iloc[0]
  560:         expected = Series([Timestamp("20130101"), 1], index=["a", "b"], name=0)
  561:         tm.assert_series_equal(result, expected)
  562:         assert result.dtype == object
  563: 
  564:     @pytest.fixture
  565:     def frame_for_consistency(self):
  566:         return DataFrame(
  567:             {
  568:                 "date": date_range("2000-01-01", "2000-01-5"),
  569:                 "val": Series(range(5), dtype=np.int64),
  570:             }
  571:         )
  572: 
  573:     @pytest.mark.parametrize(
  574:         "val",
  575:         [0, np.array(0, dtype=np.int64), np.array([0, 0, 0, 0, 0], dtype=np.int64)],
  576:     )
  577:     def test_loc_setitem_consistency(self, frame_for_consistency, val):
  578:         # GH 6149
  579:         # coerce similarly for setitem and loc when rows have a null-slice
  580:         expected = DataFrame(
  581:             {
  582:                 "date": Series(0, index=range(5), dtype=np.int64),
  583:                 "val": Series(range(5), dtype=np.int64),
  584:             }
  585:         )
  586:         df = frame_for_consistency.copy()
  587:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  588:             df.loc[:, "date"] = val
  589:         tm.assert_frame_equal(df, expected)
  590: 
  591:     def test_loc_setitem_consistency_dt64_to_str(self, frame_for_consistency):
  592:         # GH 6149
  593:         # coerce similarly for setitem and loc when rows have a null-slice
  594: 
  595:         expected = DataFrame(
  596:             {
  597:                 "date": Series("foo", index=range(5)),
  598:                 "val": Series(range(5), dtype=np.int64),
  599:             }
  600:         )
  601:         df = frame_for_consistency.copy()
  602:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  603:             df.loc[:, "date"] = "foo"
  604:         tm.assert_frame_equal(df, expected)
  605: 
  606:     def test_loc_setitem_consistency_dt64_to_float(self, frame_for_consistency):
  607:         # GH 6149
  608:         # coerce similarly for setitem and loc when rows have a null-slice
  609:         expected = DataFrame(
  610:             {
  611:                 "date": Series(1.0, index=range(5)),
  612:                 "val": Series(range(5), dtype=np.int64),
  613:             }
  614:         )
  615:         df = frame_for_consistency.copy()
  616:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  617:             df.loc[:, "date"] = 1.0
  618:         tm.assert_frame_equal(df, expected)
  619: 
  620:     def test_loc_setitem_consistency_single_row(self):
  621:         # GH 15494
  622:         # setting on frame with single row
  623:         df = DataFrame({"date": Series([Timestamp("20180101")])})
  624:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  625:             df.loc[:, "date"] = "string"
  626:         expected = DataFrame({"date": Series(["string"])})
  627:         tm.assert_frame_equal(df, expected)
  628: 
  629:     def test_loc_setitem_consistency_empty(self):
  630:         # empty (essentially noops)
  631:         # before the enforcement of #45333 in 2.0, the loc.setitem here would
  632:         #  change the dtype of df.x to int64
  633:         expected = DataFrame(columns=["x", "y"])
  634:         df = DataFrame(columns=["x", "y"])
  635:         with tm.assert_produces_warning(None):
  636:             df.loc[:, "x"] = 1
  637:         tm.assert_frame_equal(df, expected)
  638: 
  639:         # setting with setitem swaps in a new array, so changes the dtype
  640:         df = DataFrame(columns=["x", "y"])
  641:         df["x"] = 1
  642:         expected["x"] = expected["x"].astype(np.int64)
  643:         tm.assert_frame_equal(df, expected)
  644: 
  645:     def test_loc_setitem_consistency_slice_column_len(self):
  646:         # .loc[:,column] setting with slice == len of the column
  647:         # GH10408
  648:         levels = [
  649:             ["Region_1"] * 4,
  650:             ["Site_1", "Site_1", "Site_2", "Site_2"],
  651:             [3987227376, 3980680971, 3977723249, 3977723089],
  652:         ]
  653:         mi = MultiIndex.from_arrays(levels, names=["Region", "Site", "RespondentID"])
  654: 
  655:         clevels = [
  656:             ["Respondent", "Respondent", "Respondent", "OtherCat", "OtherCat"],
  657:             ["Something", "StartDate", "EndDate", "Yes/No", "SomethingElse"],
  658:         ]
  659:         cols = MultiIndex.from_arrays(clevels, names=["Level_0", "Level_1"])
  660: 
  661:         values = [
  662:             ["A", "5/25/2015 10:59", "5/25/2015 11:22", "Yes", np.nan],
  663:             ["A", "5/21/2015 9:40", "5/21/2015 9:52", "Yes", "Yes"],
  664:             ["A", "5/20/2015 8:27", "5/20/2015 8:41", "Yes", np.nan],
  665:             ["A", "5/20/2015 8:33", "5/20/2015 9:09", "Yes", "No"],
  666:         ]
  667:         df = DataFrame(values, index=mi, columns=cols)
  668: 
  669:         df.loc[:, ("Respondent", "StartDate")] = to_datetime(
  670:             df.loc[:, ("Respondent", "StartDate")]
  671:         )
  672:         df.loc[:, ("Respondent", "EndDate")] = to_datetime(
  673:             df.loc[:, ("Respondent", "EndDate")]
  674:         )
  675:         df = df.infer_objects(copy=False)
  676: 
  677:         # Adding a new key
  678:         df.loc[:, ("Respondent", "Duration")] = (
  679:             df.loc[:, ("Respondent", "EndDate")]
  680:             - df.loc[:, ("Respondent", "StartDate")]
  681:         )
  682: 
  683:         # timedelta64[m] -> float, so this cannot be done inplace, so
  684:         #  no warning
  685:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  686:             df.loc[:, ("Respondent", "Duration")] = df.loc[
  687:                 :, ("Respondent", "Duration")
  688:             ] / Timedelta(60_000_000_000)
  689: 
  690:         expected = Series(
  691:             [23.0, 12.0, 14.0, 36.0], index=df.index, name=("Respondent", "Duration")
  692:         )
  693:         tm.assert_series_equal(df[("Respondent", "Duration")], expected)
  694: 
  695:     @pytest.mark.parametrize("unit", ["Y", "M", "D", "h", "m", "s", "ms", "us"])
  696:     def test_loc_assign_non_ns_datetime(self, unit):
  697:         # GH 27395, non-ns dtype assignment via .loc should work
  698:         # and return the same result when using simple assignment
  699:         df = DataFrame(
  700:             {
  701:                 "timestamp": [
  702:                     np.datetime64("2017-02-11 12:41:29"),
  703:                     np.datetime64("1991-11-07 04:22:37"),
  704:                 ]
  705:             }
  706:         )
  707: 
  708:         df.loc[:, unit] = df.loc[:, "timestamp"].values.astype(f"datetime64[{unit}]")
  709:         df["expected"] = df.loc[:, "timestamp"].values.astype(f"datetime64[{unit}]")
  710:         expected = Series(df.loc[:, "expected"], name=unit)
  711:         tm.assert_series_equal(df.loc[:, unit], expected)
  712: 
  713:     def test_loc_modify_datetime(self):
  714:         # see gh-28837
  715:         df = DataFrame.from_dict(
  716:             {"date": [1485264372711, 1485265925110, 1540215845888, 1540282121025]}
  717:         )
  718: 
  719:         df["date_dt"] = to_datetime(df["date"], unit="ms", cache=True)
  720: 
  721:         df.loc[:, "date_dt_cp"] = df.loc[:, "date_dt"]
  722:         df.loc[[2, 3], "date_dt_cp"] = df.loc[[2, 3], "date_dt"]
  723: 
  724:         expected = DataFrame(
  725:             [
  726:                 [1485264372711, "2017-01-24 13:26:12.711", "2017-01-24 13:26:12.711"],
  727:                 [1485265925110, "2017-01-24 13:52:05.110", "2017-01-24 13:52:05.110"],
  728:                 [1540215845888, "2018-10-22 13:44:05.888", "2018-10-22 13:44:05.888"],
  729:                 [1540282121025, "2018-10-23 08:08:41.025", "2018-10-23 08:08:41.025"],
  730:             ],
  731:             columns=["date", "date_dt", "date_dt_cp"],
  732:         )
  733: 
  734:         columns = ["date_dt", "date_dt_cp"]
  735:         expected[columns] = expected[columns].apply(to_datetime)
  736: 
  737:         tm.assert_frame_equal(df, expected)
  738: 
  739:     def test_loc_setitem_frame_with_reindex(self):
  740:         # GH#6254 setting issue
  741:         df = DataFrame(index=[3, 5, 4], columns=["A"], dtype=float)
  742:         df.loc[[4, 3, 5], "A"] = np.array([1, 2, 3], dtype="int64")
  743: 
  744:         # setting integer values into a float dataframe with loc is inplace,
  745:         #  so we retain float dtype
  746:         ser = Series([2, 3, 1], index=[3, 5, 4], dtype=float)
  747:         expected = DataFrame({"A": ser})
  748:         tm.assert_frame_equal(df, expected)
  749: 
  750:     def test_loc_setitem_frame_with_reindex_mixed(self):
  751:         # GH#40480
  752:         df = DataFrame(index=[3, 5, 4], columns=["A", "B"], dtype=float)
  753:         df["B"] = "string"
  754:         df.loc[[4, 3, 5], "A"] = np.array([1, 2, 3], dtype="int64")
  755:         ser = Series([2, 3, 1], index=[3, 5, 4], dtype="int64")
  756:         # pre-2.0 this setting swapped in a new array, now it is inplace
  757:         #  consistent with non-split-path
  758:         expected = DataFrame({"A": ser.astype(float)})
  759:         expected["B"] = "string"
  760:         tm.assert_frame_equal(df, expected)
  761: 
  762:     def test_loc_setitem_frame_with_inverted_slice(self):
  763:         # GH#40480
  764:         df = DataFrame(index=[1, 2, 3], columns=["A", "B"], dtype=float)
  765:         df["B"] = "string"
  766:         df.loc[slice(3, 0, -1), "A"] = np.array([1, 2, 3], dtype="int64")
  767:         # pre-2.0 this setting swapped in a new array, now it is inplace
  768:         #  consistent with non-split-path
  769:         expected = DataFrame({"A": [3.0, 2.0, 1.0], "B": "string"}, index=[1, 2, 3])
  770:         tm.assert_frame_equal(df, expected)
  771: 
  772:     def test_loc_setitem_empty_frame(self):
  773:         # GH#6252 setting with an empty frame
  774:         keys1 = ["@" + str(i) for i in range(5)]
  775:         val1 = np.arange(5, dtype="int64")
  776: 
  777:         keys2 = ["@" + str(i) for i in range(4)]
  778:         val2 = np.arange(4, dtype="int64")
  779: 
  780:         index = list(set(keys1).union(keys2))
  781:         df = DataFrame(index=index)
  782:         df["A"] = np.nan
  783:         df.loc[keys1, "A"] = val1
  784: 
  785:         df["B"] = np.nan
  786:         df.loc[keys2, "B"] = val2
  787: 
  788:         # Because df["A"] was initialized as float64, setting values into it
  789:         #  is inplace, so that dtype is retained
  790:         sera = Series(val1, index=keys1, dtype=np.float64)
  791:         serb = Series(val2, index=keys2)
  792:         expected = DataFrame(
  793:             {"A": sera, "B": serb}, columns=Index(["A", "B"], dtype=object)
  794:         ).reindex(index=index)
  795:         tm.assert_frame_equal(df, expected)
  796: 
  797:     def test_loc_setitem_frame(self):
  798:         df = DataFrame(
  799:             np.random.default_rng(2).standard_normal((4, 4)),
  800:             index=list("abcd"),
  801:             columns=list("ABCD"),
  802:         )
  803: 
  804:         result = df.iloc[0, 0]
  805: 
  806:         df.loc["a", "A"] = 1
  807:         result = df.loc["a", "A"]
  808:         assert result == 1
  809: 
  810:         result = df.iloc[0, 0]
  811:         assert result == 1
  812: 
  813:         df.loc[:, "B":"D"] = 0
  814:         expected = df.loc[:, "B":"D"]
  815:         result = df.iloc[:, 1:]
  816:         tm.assert_frame_equal(result, expected)
  817: 
  818:     def test_loc_setitem_frame_nan_int_coercion_invalid(self):
  819:         # GH 8669
  820:         # invalid coercion of nan -> int
  821:         df = DataFrame({"A": [1, 2, 3], "B": np.nan})
  822:         df.loc[df.B > df.A, "B"] = df.A
  823:         expected = DataFrame({"A": [1, 2, 3], "B": np.nan})
  824:         tm.assert_frame_equal(df, expected)
  825: 
  826:     def test_loc_setitem_frame_mixed_labels(self):
  827:         # GH 6546
  828:         # setting with mixed labels
  829:         df = DataFrame({1: [1, 2], 2: [3, 4], "a": ["a", "b"]})
  830: 
  831:         result = df.loc[0, [1, 2]]
  832:         expected = Series(
  833:             [1, 3], index=Index([1, 2], dtype=object), dtype=object, name=0
  834:         )
  835:         tm.assert_series_equal(result, expected)
  836: 
  837:         expected = DataFrame({1: [5, 2], 2: [6, 4], "a": ["a", "b"]})
  838:         df.loc[0, [1, 2]] = [5, 6]
  839:         tm.assert_frame_equal(df, expected)
  840: 
  841:     @pytest.mark.filterwarnings("ignore:Setting a value on a view:FutureWarning")
  842:     def test_loc_setitem_frame_multiples(self, warn_copy_on_write):
  843:         # multiple setting
  844:         df = DataFrame(
  845:             {"A": ["foo", "bar", "baz"], "B": Series(range(3), dtype=np.int64)}
  846:         )
  847:         rhs = df.loc[1:2]
  848:         rhs.index = df.index[0:2]
  849:         df.loc[0:1] = rhs
  850:         expected = DataFrame(
  851:             {"A": ["bar", "baz", "baz"], "B": Series([1, 2, 2], dtype=np.int64)}
  852:         )
  853:         tm.assert_frame_equal(df, expected)
  854: 
  855:         # multiple setting with frame on rhs (with M8)
  856:         df = DataFrame(
  857:             {
  858:                 "date": date_range("2000-01-01", "2000-01-5"),
  859:                 "val": Series(range(5), dtype=np.int64),
  860:             }
  861:         )
  862:         expected = DataFrame(
  863:             {
  864:                 "date": [
  865:                     Timestamp("20000101"),
  866:                     Timestamp("20000102"),
  867:                     Timestamp("20000101"),
  868:                     Timestamp("20000102"),
  869:                     Timestamp("20000103"),
  870:                 ],
  871:                 "val": Series([0, 1, 0, 1, 2], dtype=np.int64),
  872:             }
  873:         )
  874:         rhs = df.loc[0:2]
  875:         rhs.index = df.index[2:5]
  876:         df.loc[2:4] = rhs
  877:         tm.assert_frame_equal(df, expected)
  878: 
  879:     @pytest.mark.parametrize(
  880:         "indexer", [["A"], slice(None, "A", None), np.array(["A"])]
  881:     )
  882:     @pytest.mark.parametrize("value", [["Z"], np.array(["Z"])])
  883:     def test_loc_setitem_with_scalar_index(self, indexer, value):
  884:         # GH #19474
  885:         # assigning like "df.loc[0, ['A']] = ['Z']" should be evaluated
  886:         # elementwisely, not using "setter('A', ['Z'])".
  887: 
  888:         # Set object dtype to avoid upcast when setting 'Z'
  889:         df = DataFrame([[1, 2], [3, 4]], columns=["A", "B"]).astype({"A": object})
  890:         df.loc[0, indexer] = value
  891:         result = df.loc[0, "A"]
  892: 
  893:         assert is_scalar(result) and result == "Z"
  894: 
  895:     @pytest.mark.parametrize(
  896:         "index,box,expected",
  897:         [
  898:             (
  899:                 ([0, 2], ["A", "B", "C", "D"]),
  900:                 7,
  901:                 DataFrame(
  902:                     [[7, 7, 7, 7], [3, 4, np.nan, np.nan], [7, 7, 7, 7]],
  903:                     columns=["A", "B", "C", "D"],
  904:                 ),
  905:             ),
  906:             (
  907:                 (1, ["C", "D"]),
  908:                 [7, 8],
  909:                 DataFrame(
  910:                     [[1, 2, np.nan, np.nan], [3, 4, 7, 8], [5, 6, np.nan, np.nan]],
  911:                     columns=["A", "B", "C", "D"],
  912:                 ),
  913:             ),
  914:             (
  915:                 (1, ["A", "B", "C"]),
  916:                 np.array([7, 8, 9], dtype=np.int64),
  917:                 DataFrame(
  918:                     [[1, 2, np.nan], [7, 8, 9], [5, 6, np.nan]], columns=["A", "B", "C"]
  919:                 ),
  920:             ),
  921:             (
  922:                 (slice(1, 3, None), ["B", "C", "D"]),
  923:                 [[7, 8, 9], [10, 11, 12]],
  924:                 DataFrame(
  925:                     [[1, 2, np.nan, np.nan], [3, 7, 8, 9], [5, 10, 11, 12]],
  926:                     columns=["A", "B", "C", "D"],
  927:                 ),
  928:             ),
  929:             (
  930:                 (slice(1, 3, None), ["C", "A", "D"]),
  931:                 np.array([[7, 8, 9], [10, 11, 12]], dtype=np.int64),
  932:                 DataFrame(
  933:                     [[1, 2, np.nan, np.nan], [8, 4, 7, 9], [11, 6, 10, 12]],
  934:                     columns=["A", "B", "C", "D"],
  935:                 ),
  936:             ),
  937:             (
  938:                 (slice(None, None, None), ["A", "C"]),
  939:                 DataFrame([[7, 8], [9, 10], [11, 12]], columns=["A", "C"]),
  940:                 DataFrame(
  941:                     [[7, 2, 8], [9, 4, 10], [11, 6, 12]], columns=["A", "B", "C"]
  942:                 ),
  943:             ),
  944:         ],
  945:     )
  946:     def test_loc_setitem_missing_columns(self, index, box, expected):
  947:         # GH 29334
  948:         df = DataFrame([[1, 2], [3, 4], [5, 6]], columns=["A", "B"])
  949: 
  950:         df.loc[index] = box
  951:         tm.assert_frame_equal(df, expected)
  952: 
  953:     def test_loc_coercion(self):
  954:         # GH#12411
  955:         df = DataFrame({"date": [Timestamp("20130101").tz_localize("UTC"), pd.NaT]})
  956:         expected = df.dtypes
  957: 
  958:         result = df.iloc[[0]]
  959:         tm.assert_series_equal(result.dtypes, expected)
  960: 
  961:         result = df.iloc[[1]]
  962:         tm.assert_series_equal(result.dtypes, expected)
  963: 
  964:     def test_loc_coercion2(self):
  965:         # GH#12045
  966:         df = DataFrame({"date": [datetime(2012, 1, 1), datetime(1012, 1, 2)]})
  967:         expected = df.dtypes
  968: 
  969:         result = df.iloc[[0]]
  970:         tm.assert_series_equal(result.dtypes, expected)
  971: 
  972:         result = df.iloc[[1]]
  973:         tm.assert_series_equal(result.dtypes, expected)
  974: 
  975:     def test_loc_coercion3(self):
  976:         # GH#11594
  977:         df = DataFrame({"text": ["some words"] + [None] * 9})
  978:         expected = df.dtypes
  979: 
  980:         result = df.iloc[0:2]
  981:         tm.assert_series_equal(result.dtypes, expected)
  982: 
  983:         result = df.iloc[3:]
  984:         tm.assert_series_equal(result.dtypes, expected)
  985: 
  986:     def test_setitem_new_key_tz(self, indexer_sl):
  987:         # GH#12862 should not raise on assigning the second value
  988:         vals = [
  989:             to_datetime(42).tz_localize("UTC"),
  990:             to_datetime(666).tz_localize("UTC"),
  991:         ]
  992:         expected = Series(vals, index=Index(["foo", "bar"], dtype=object))
  993: 
  994:         ser = Series(dtype=object)
  995:         indexer_sl(ser)["foo"] = vals[0]
  996:         indexer_sl(ser)["bar"] = vals[1]
  997: 
  998:         tm.assert_series_equal(ser, expected)
  999: 
 1000:     def test_loc_non_unique(self):
 1001:         # GH3659
 1002:         # non-unique indexer with loc slice
 1003:         # https://groups.google.com/forum/?fromgroups#!topic/pydata/zTm2No0crYs
 1004: 
 1005:         # these are going to raise because the we are non monotonic
 1006:         df = DataFrame(
 1007:             {"A": [1, 2, 3, 4, 5, 6], "B": [3, 4, 5, 6, 7, 8]}, index=[0, 1, 0, 1, 2, 3]
 1008:         )
 1009:         msg = "'Cannot get left slice bound for non-unique label: 1'"
 1010:         with pytest.raises(KeyError, match=msg):
 1011:             df.loc[1:]
 1012:         msg = "'Cannot get left slice bound for non-unique label: 0'"
 1013:         with pytest.raises(KeyError, match=msg):
 1014:             df.loc[0:]
 1015:         msg = "'Cannot get left slice bound for non-unique label: 1'"
 1016:         with pytest.raises(KeyError, match=msg):
 1017:             df.loc[1:2]
 1018: 
 1019:         # monotonic are ok
 1020:         df = DataFrame(
 1021:             {"A": [1, 2, 3, 4, 5, 6], "B": [3, 4, 5, 6, 7, 8]}, index=[0, 1, 0, 1, 2, 3]
 1022:         ).sort_index(axis=0)
 1023:         result = df.loc[1:]
 1024:         expected = DataFrame({"A": [2, 4, 5, 6], "B": [4, 6, 7, 8]}, index=[1, 1, 2, 3])
 1025:         tm.assert_frame_equal(result, expected)
 1026: 
 1027:         result = df.loc[0:]
 1028:         tm.assert_frame_equal(result, df)
 1029: 
 1030:         result = df.loc[1:2]
 1031:         expected = DataFrame({"A": [2, 4, 5], "B": [4, 6, 7]}, index=[1, 1, 2])
 1032:         tm.assert_frame_equal(result, expected)
 1033: 
 1034:     @pytest.mark.arm_slow
 1035:     @pytest.mark.parametrize("length, l2", [[900, 100], [900000, 100000]])
 1036:     def test_loc_non_unique_memory_error(self, length, l2):
 1037:         # GH 4280
 1038:         # non_unique index with a large selection triggers a memory error
 1039: 
 1040:         columns = list("ABCDEFG")
 1041: 
 1042:         df = pd.concat(
 1043:             [
 1044:                 DataFrame(
 1045:                     np.random.default_rng(2).standard_normal((length, len(columns))),
 1046:                     index=np.arange(length),
 1047:                     columns=columns,
 1048:                 ),
 1049:                 DataFrame(np.ones((l2, len(columns))), index=[0] * l2, columns=columns),
 1050:             ]
 1051:         )
 1052: 
 1053:         assert df.index.is_unique is False
 1054: 
 1055:         mask = np.arange(l2)
 1056:         result = df.loc[mask]
 1057:         expected = pd.concat(
 1058:             [
 1059:                 df.take([0]),
 1060:                 DataFrame(
 1061:                     np.ones((len(mask), len(columns))),
 1062:                     index=[0] * len(mask),
 1063:                     columns=columns,
 1064:                 ),
 1065:                 df.take(mask[1:]),
 1066:             ]
 1067:         )
 1068:         tm.assert_frame_equal(result, expected)
 1069: 
 1070:     def test_loc_name(self):
 1071:         # GH 3880
 1072:         df = DataFrame([[1, 1], [1, 1]])
 1073:         df.index.name = "index_name"
 1074:         result = df.iloc[[0, 1]].index.name
 1075:         assert result == "index_name"
 1076: 
 1077:         result = df.loc[[0, 1]].index.name
 1078:         assert result == "index_name"
 1079: 
 1080:     def test_loc_empty_list_indexer_is_ok(self):
 1081:         df = DataFrame(
 1082:             np.ones((5, 2)),
 1083:             index=Index([f"i-{i}" for i in range(5)], name="a"),
 1084:             columns=Index([f"i-{i}" for i in range(2)], name="a"),
 1085:         )
 1086:         # vertical empty
 1087:         tm.assert_frame_equal(
 1088:             df.loc[:, []], df.iloc[:, :0], check_index_type=True, check_column_type=True
 1089:         )
 1090:         # horizontal empty
 1091:         tm.assert_frame_equal(
 1092:             df.loc[[], :], df.iloc[:0, :], check_index_type=True, check_column_type=True
 1093:         )
 1094:         # horizontal empty
 1095:         tm.assert_frame_equal(
 1096:             df.loc[[]], df.iloc[:0, :], check_index_type=True, check_column_type=True
 1097:         )
 1098: 
 1099:     def test_identity_slice_returns_new_object(
 1100:         self, using_copy_on_write, warn_copy_on_write
 1101:     ):
 1102:         # GH13873
 1103: 
 1104:         original_df = DataFrame({"a": [1, 2, 3]})
 1105:         sliced_df = original_df.loc[:]
 1106:         assert sliced_df is not original_df
 1107:         assert original_df[:] is not original_df
 1108:         assert original_df.loc[:, :] is not original_df
 1109: 
 1110:         # should be a shallow copy
 1111:         assert np.shares_memory(original_df["a"]._values, sliced_df["a"]._values)
 1112: 
 1113:         # Setting using .loc[:, "a"] sets inplace so alters both sliced and orig
 1114:         # depending on CoW
 1115:         with tm.assert_cow_warning(warn_copy_on_write):
 1116:             original_df.loc[:, "a"] = [4, 4, 4]
 1117:         if using_copy_on_write:
 1118:             assert (sliced_df["a"] == [1, 2, 3]).all()
 1119:         else:
 1120:             assert (sliced_df["a"] == 4).all()
 1121: 
 1122:         # These should not return copies
 1123:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))
 1124:         if using_copy_on_write or warn_copy_on_write:
 1125:             assert df[0] is not df.loc[:, 0]
 1126:         else:
 1127:             assert df[0] is df.loc[:, 0]
 1128: 
 1129:         # Same tests for Series
 1130:         original_series = Series([1, 2, 3, 4, 5, 6])
 1131:         sliced_series = original_series.loc[:]
 1132:         assert sliced_series is not original_series
 1133:         assert original_series[:] is not original_series
 1134: 
 1135:         with tm.assert_cow_warning(warn_copy_on_write):
 1136:             original_series[:3] = [7, 8, 9]
 1137:         if using_copy_on_write:
 1138:             assert all(sliced_series[:3] == [1, 2, 3])
 1139:         else:
 1140:             assert all(sliced_series[:3] == [7, 8, 9])
 1141: 
 1142:     def test_loc_copy_vs_view(self, request, using_copy_on_write):
 1143:         # GH 15631
 1144: 
 1145:         if not using_copy_on_write:
 1146:             mark = pytest.mark.xfail(reason="accidental fix reverted - GH37497")
 1147:             request.applymarker(mark)
 1148:         x = DataFrame(zip(range(3), range(3)), columns=["a", "b"])
 1149: 
 1150:         y = x.copy()
 1151:         q = y.loc[:, "a"]
 1152:         q += 2
 1153: 
 1154:         tm.assert_frame_equal(x, y)
 1155: 
 1156:         z = x.copy()
 1157:         q = z.loc[x.index, "a"]
 1158:         q += 2
 1159: 
 1160:         tm.assert_frame_equal(x, z)
 1161: 
 1162:     def test_loc_uint64(self):
 1163:         # GH20722
 1164:         # Test whether loc accept uint64 max value as index.
 1165:         umax = np.iinfo("uint64").max
 1166:         ser = Series([1, 2], index=[umax - 1, umax])
 1167: 
 1168:         result = ser.loc[umax - 1]
 1169:         expected = ser.iloc[0]
 1170:         assert result == expected
 1171: 
 1172:         result = ser.loc[[umax - 1]]
 1173:         expected = ser.iloc[[0]]
 1174:         tm.assert_series_equal(result, expected)
 1175: 
 1176:         result = ser.loc[[umax - 1, umax]]
 1177:         tm.assert_series_equal(result, ser)
 1178: 
 1179:     def test_loc_uint64_disallow_negative(self):
 1180:         # GH#41775
 1181:         umax = np.iinfo("uint64").max
 1182:         ser = Series([1, 2], index=[umax - 1, umax])
 1183: 
 1184:         with pytest.raises(KeyError, match="-1"):
 1185:             # don't wrap around
 1186:             ser.loc[-1]
 1187: 
 1188:         with pytest.raises(KeyError, match="-1"):
 1189:             # don't wrap around
 1190:             ser.loc[[-1]]
 1191: 
 1192:     def test_loc_setitem_empty_append_expands_rows(self):
 1193:         # GH6173, various appends to an empty dataframe
 1194: 
 1195:         data = [1, 2, 3]
 1196:         expected = DataFrame(
 1197:             {"x": data, "y": np.array([np.nan] * len(data), dtype=object)}
 1198:         )
 1199: 
 1200:         # appends to fit length of data
 1201:         df = DataFrame(columns=["x", "y"])
 1202:         df.loc[:, "x"] = data
 1203:         tm.assert_frame_equal(df, expected)
 1204: 
 1205:     def test_loc_setitem_empty_append_expands_rows_mixed_dtype(self):
 1206:         # GH#37932 same as test_loc_setitem_empty_append_expands_rows
 1207:         #  but with mixed dtype so we go through take_split_path
 1208:         data = [1, 2, 3]
 1209:         expected = DataFrame(
 1210:             {"x": data, "y": np.array([np.nan] * len(data), dtype=object)}
 1211:         )
 1212: 
 1213:         df = DataFrame(columns=["x", "y"])
 1214:         df["x"] = df["x"].astype(np.int64)
 1215:         df.loc[:, "x"] = data
 1216:         tm.assert_frame_equal(df, expected)
 1217: 
 1218:     def test_loc_setitem_empty_append_single_value(self):
 1219:         # only appends one value
 1220:         expected = DataFrame({"x": [1.0], "y": [np.nan]})
 1221:         df = DataFrame(columns=["x", "y"], dtype=float)
 1222:         df.loc[0, "x"] = expected.loc[0, "x"]
 1223:         tm.assert_frame_equal(df, expected)
 1224: 
 1225:     def test_loc_setitem_empty_append_raises(self):
 1226:         # GH6173, various appends to an empty dataframe
 1227: 
 1228:         data = [1, 2]
 1229:         df = DataFrame(columns=["x", "y"])
 1230:         df.index = df.index.astype(np.int64)
 1231:         msg = (
 1232:             rf"None of \[Index\(\[0, 1\], dtype='{np.dtype(int)}'\)\] "
 1233:             r"are in the \[index\]"
 1234:         )
 1235:         with pytest.raises(KeyError, match=msg):
 1236:             df.loc[[0, 1], "x"] = data
 1237: 
 1238:         msg = "setting an array element with a sequence."
 1239:         with pytest.raises(ValueError, match=msg):
 1240:             df.loc[0:2, "x"] = data
 1241: 
 1242:     def test_indexing_zerodim_np_array(self):
 1243:         # GH24924
 1244:         df = DataFrame([[1, 2], [3, 4]])
 1245:         result = df.loc[np.array(0)]
 1246:         s = Series([1, 2], name=0)
 1247:         tm.assert_series_equal(result, s)
 1248: 
 1249:     def test_series_indexing_zerodim_np_array(self):
 1250:         # GH24924
 1251:         s = Series([1, 2])
 1252:         result = s.loc[np.array(0)]
 1253:         assert result == 1
 1254: 
 1255:     def test_loc_reverse_assignment(self):
 1256:         # GH26939
 1257:         data = [1, 2, 3, 4, 5, 6] + [None] * 4
 1258:         expected = Series(data, index=range(2010, 2020))
 1259: 
 1260:         result = Series(index=range(2010, 2020), dtype=np.float64)
 1261:         result.loc[2015:2010:-1] = [6, 5, 4, 3, 2, 1]
 1262: 
 1263:         tm.assert_series_equal(result, expected)
 1264: 
 1265:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="can't set int into string")
 1266:     def test_loc_setitem_str_to_small_float_conversion_type(self):
 1267:         # GH#20388
 1268: 
 1269:         col_data = [str(np.random.default_rng(2).random() * 1e-12) for _ in range(5)]
 1270:         result = DataFrame(col_data, columns=["A"])
 1271:         expected = DataFrame(col_data, columns=["A"], dtype=object)
 1272:         tm.assert_frame_equal(result, expected)
 1273: 
 1274:         # assigning with loc/iloc attempts to set the values inplace, which
 1275:         #  in this case is successful
 1276:         result.loc[result.index, "A"] = [float(x) for x in col_data]
 1277:         expected = DataFrame(col_data, columns=["A"], dtype=float).astype(object)
 1278:         tm.assert_frame_equal(result, expected)
 1279: 
 1280:         # assigning the entire column using __setitem__ swaps in the new array
 1281:         # GH#???
 1282:         result["A"] = [float(x) for x in col_data]
 1283:         expected = DataFrame(col_data, columns=["A"], dtype=float)
 1284:         tm.assert_frame_equal(result, expected)
 1285: 
 1286:     def test_loc_getitem_time_object(self, frame_or_series):
 1287:         rng = date_range("1/1/2000", "1/5/2000", freq="5min")
 1288:         mask = (rng.hour == 9) & (rng.minute == 30)
 1289: 
 1290:         obj = DataFrame(
 1291:             np.random.default_rng(2).standard_normal((len(rng), 3)), index=rng
 1292:         )
 1293:         obj = tm.get_obj(obj, frame_or_series)
 1294: 
 1295:         result = obj.loc[time(9, 30)]
 1296:         exp = obj.loc[mask]
 1297:         tm.assert_equal(result, exp)
 1298: 
 1299:         chunk = obj.loc["1/4/2000":]
 1300:         result = chunk.loc[time(9, 30)]
 1301:         expected = result[-1:]
 1302: 
 1303:         # Without resetting the freqs, these are 5 min and 1440 min, respectively
 1304:         result.index = result.index._with_freq(None)
 1305:         expected.index = expected.index._with_freq(None)
 1306:         tm.assert_equal(result, expected)
 1307: 
 1308:     @pytest.mark.parametrize("spmatrix_t", ["coo_matrix", "csc_matrix", "csr_matrix"])
 1309:     @pytest.mark.parametrize("dtype", [np.int64, np.float64, complex])
 1310:     def test_loc_getitem_range_from_spmatrix(self, spmatrix_t, dtype):
 1311:         sp_sparse = pytest.importorskip("scipy.sparse")
 1312: 
 1313:         spmatrix_t = getattr(sp_sparse, spmatrix_t)
 1314: 
 1315:         # The bug is triggered by a sparse matrix with purely sparse columns.  So the
 1316:         # recipe below generates a rectangular matrix of dimension (5, 7) where all the
 1317:         # diagonal cells are ones, meaning the last two columns are purely sparse.
 1318:         rows, cols = 5, 7
 1319:         spmatrix = spmatrix_t(np.eye(rows, cols, dtype=dtype), dtype=dtype)
 1320:         df = DataFrame.sparse.from_spmatrix(spmatrix)
 1321: 
 1322:         # regression test for GH#34526
 1323:         itr_idx = range(2, rows)
 1324:         result = df.loc[itr_idx].values
 1325:         expected = spmatrix.toarray()[itr_idx]
 1326:         tm.assert_numpy_array_equal(result, expected)
 1327: 
 1328:         # regression test for GH#34540
 1329:         result = df.loc[itr_idx].dtypes.values
 1330:         expected = np.full(cols, SparseDtype(dtype, fill_value=0))
 1331:         tm.assert_numpy_array_equal(result, expected)
 1332: 
 1333:     def test_loc_getitem_listlike_all_retains_sparse(self):
 1334:         df = DataFrame({"A": pd.array([0, 0], dtype=SparseDtype("int64"))})
 1335:         result = df.loc[[0, 1]]
 1336:         tm.assert_frame_equal(result, df)
 1337: 
 1338:     def test_loc_getitem_sparse_frame(self):
 1339:         # GH34687
 1340:         sp_sparse = pytest.importorskip("scipy.sparse")
 1341: 
 1342:         df = DataFrame.sparse.from_spmatrix(sp_sparse.eye(5))
 1343:         result = df.loc[range(2)]
 1344:         expected = DataFrame(
 1345:             [[1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0]],
 1346:             dtype=SparseDtype("float64", 0.0),
 1347:         )
 1348:         tm.assert_frame_equal(result, expected)
 1349: 
 1350:         result = df.loc[range(2)].loc[range(1)]
 1351:         expected = DataFrame(
 1352:             [[1.0, 0.0, 0.0, 0.0, 0.0]], dtype=SparseDtype("float64", 0.0)
 1353:         )
 1354:         tm.assert_frame_equal(result, expected)
 1355: 
 1356:     def test_loc_getitem_sparse_series(self):
 1357:         # GH34687
 1358:         s = Series([1.0, 0.0, 0.0, 0.0, 0.0], dtype=SparseDtype("float64", 0.0))
 1359: 
 1360:         result = s.loc[range(2)]
 1361:         expected = Series([1.0, 0.0], dtype=SparseDtype("float64", 0.0))
 1362:         tm.assert_series_equal(result, expected)
 1363: 
 1364:         result = s.loc[range(3)].loc[range(2)]
 1365:         expected = Series([1.0, 0.0], dtype=SparseDtype("float64", 0.0))
 1366:         tm.assert_series_equal(result, expected)
 1367: 
 1368:     @pytest.mark.parametrize("indexer", ["loc", "iloc"])
 1369:     def test_getitem_single_row_sparse_df(self, indexer):
 1370:         # GH#46406
 1371:         df = DataFrame([[1.0, 0.0, 1.5], [0.0, 2.0, 0.0]], dtype=SparseDtype(float))
 1372:         result = getattr(df, indexer)[0]
 1373:         expected = Series([1.0, 0.0, 1.5], dtype=SparseDtype(float), name=0)
 1374:         tm.assert_series_equal(result, expected)
 1375: 
 1376:     @pytest.mark.parametrize("key_type", [iter, np.array, Series, Index])
 1377:     def test_loc_getitem_iterable(self, float_frame, key_type):
 1378:         idx = key_type(["A", "B", "C"])
 1379:         result = float_frame.loc[:, idx]
 1380:         expected = float_frame.loc[:, ["A", "B", "C"]]
 1381:         tm.assert_frame_equal(result, expected)
 1382: 
 1383:     def test_loc_getitem_timedelta_0seconds(self):
 1384:         # GH#10583
 1385:         df = DataFrame(np.random.default_rng(2).normal(size=(10, 4)))
 1386:         df.index = timedelta_range(start="0s", periods=10, freq="s")
 1387:         expected = df.loc[Timedelta("0s") :, :]
 1388:         result = df.loc["0s":, :]
 1389:         tm.assert_frame_equal(result, expected)
 1390: 
 1391:     @pytest.mark.parametrize(
 1392:         "val,expected", [(2**63 - 1, Series([1])), (2**63, Series([2]))]
 1393:     )
 1394:     def test_loc_getitem_uint64_scalar(self, val, expected):
 1395:         # see GH#19399
 1396:         df = DataFrame([1, 2], index=[2**63 - 1, 2**63])
 1397:         result = df.loc[val]
 1398: 
 1399:         expected.name = val
 1400:         tm.assert_series_equal(result, expected)
 1401: 
 1402:     def test_loc_setitem_int_label_with_float_index(self, float_numpy_dtype):
 1403:         # note labels are floats
 1404:         dtype = float_numpy_dtype
 1405:         ser = Series(["a", "b", "c"], index=Index([0, 0.5, 1], dtype=dtype))
 1406:         expected = ser.copy()
 1407: 
 1408:         ser.loc[1] = "zoo"
 1409:         expected.iloc[2] = "zoo"
 1410: 
 1411:         tm.assert_series_equal(ser, expected)
 1412: 
 1413:     @pytest.mark.parametrize(
 1414:         "indexer, expected",
 1415:         [
 1416:             # The test name is a misnomer in the 0 case as df.index[indexer]
 1417:             #  is a scalar.
 1418:             (0, [20, 1, 2, 3, 4, 5, 6, 7, 8, 9]),
 1419:             (slice(4, 8), [0, 1, 2, 3, 20, 20, 20, 20, 8, 9]),
 1420:             ([3, 5], [0, 1, 2, 20, 4, 20, 6, 7, 8, 9]),
 1421:         ],
 1422:     )
 1423:     def test_loc_setitem_listlike_with_timedelta64index(self, indexer, expected):
 1424:         # GH#16637
 1425:         tdi = to_timedelta(range(10), unit="s")
 1426:         df = DataFrame({"x": range(10)}, dtype="int64", index=tdi)
 1427: 
 1428:         df.loc[df.index[indexer], "x"] = 20
 1429: 
 1430:         expected = DataFrame(
 1431:             expected,
 1432:             index=tdi,
 1433:             columns=["x"],
 1434:             dtype="int64",
 1435:         )
 1436: 
 1437:         tm.assert_frame_equal(expected, df)
 1438: 
 1439:     def test_loc_setitem_categorical_values_partial_column_slice(self):
 1440:         # Assigning a Category to parts of a int/... column uses the values of
 1441:         # the Categorical
 1442:         df = DataFrame({"a": [1, 1, 1, 1, 1], "b": list("aaaaa")})
 1443:         exp = DataFrame({"a": [1, "b", "b", 1, 1], "b": list("aabba")})
 1444:         with tm.assert_produces_warning(
 1445:             FutureWarning, match="item of incompatible dtype"
 1446:         ):
 1447:             df.loc[1:2, "a"] = Categorical(["b", "b"], categories=["a", "b"])
 1448:             df.loc[2:3, "b"] = Categorical(["b", "b"], categories=["a", "b"])
 1449:         tm.assert_frame_equal(df, exp)
 1450: 
 1451:     def test_loc_setitem_single_row_categorical(self, using_infer_string):
 1452:         # GH#25495
 1453:         df = DataFrame({"Alpha": ["a"], "Numeric": [0]})
 1454:         categories = Categorical(df["Alpha"], categories=["a", "b", "c"])
 1455: 
 1456:         # pre-2.0 this swapped in a new array, in 2.0 it operates inplace,
 1457:         #  consistent with non-split-path
 1458:         df.loc[:, "Alpha"] = categories
 1459: 
 1460:         result = df["Alpha"]
 1461:         expected = Series(categories, index=df.index, name="Alpha").astype(
 1462:             object if not using_infer_string else "string[pyarrow_numpy]"
 1463:         )
 1464:         tm.assert_series_equal(result, expected)
 1465: 
 1466:         # double-check that the non-loc setting retains categoricalness
 1467:         df["Alpha"] = categories
 1468:         tm.assert_series_equal(df["Alpha"], Series(categories, name="Alpha"))
 1469: 
 1470:     def test_loc_setitem_datetime_coercion(self):
 1471:         # GH#1048
 1472:         df = DataFrame({"c": [Timestamp("2010-10-01")] * 3})
 1473:         df.loc[0:1, "c"] = np.datetime64("2008-08-08")
 1474:         assert Timestamp("2008-08-08") == df.loc[0, "c"]
 1475:         assert Timestamp("2008-08-08") == df.loc[1, "c"]
 1476:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1477:             df.loc[2, "c"] = date(2005, 5, 5)
 1478:         assert Timestamp("2005-05-05").date() == df.loc[2, "c"]
 1479: 
 1480:     @pytest.mark.parametrize("idxer", ["var", ["var"]])
 1481:     def test_loc_setitem_datetimeindex_tz(self, idxer, tz_naive_fixture):
 1482:         # GH#11365
 1483:         tz = tz_naive_fixture
 1484:         idx = date_range(start="2015-07-12", periods=3, freq="h", tz=tz)
 1485:         expected = DataFrame(1.2, index=idx, columns=["var"])
 1486:         # if result started off with object dtype, then the .loc.__setitem__
 1487:         #  below would retain object dtype
 1488:         result = DataFrame(index=idx, columns=["var"], dtype=np.float64)
 1489:         with tm.assert_produces_warning(
 1490:             FutureWarning if idxer == "var" else None, match="incompatible dtype"
 1491:         ):
 1492:             # See https://github.com/pandas-dev/pandas/issues/56223
 1493:             result.loc[:, idxer] = expected
 1494:         tm.assert_frame_equal(result, expected)
 1495: 
 1496:     def test_loc_setitem_time_key(self, using_array_manager):
 1497:         index = date_range("2012-01-01", "2012-01-05", freq="30min")
 1498:         df = DataFrame(
 1499:             np.random.default_rng(2).standard_normal((len(index), 5)), index=index
 1500:         )
 1501:         akey = time(12, 0, 0)
 1502:         bkey = slice(time(13, 0, 0), time(14, 0, 0))
 1503:         ainds = [24, 72, 120, 168]
 1504:         binds = [26, 27, 28, 74, 75, 76, 122, 123, 124, 170, 171, 172]
 1505: 
 1506:         result = df.copy()
 1507:         result.loc[akey] = 0
 1508:         result = result.loc[akey]
 1509:         expected = df.loc[akey].copy()
 1510:         expected.loc[:] = 0
 1511:         if using_array_manager:
 1512:             # TODO(ArrayManager) we are still overwriting columns
 1513:             expected = expected.astype(float)
 1514:         tm.assert_frame_equal(result, expected)
 1515: 
 1516:         result = df.copy()
 1517:         result.loc[akey] = 0
 1518:         result.loc[akey] = df.iloc[ainds]
 1519:         tm.assert_frame_equal(result, df)
 1520: 
 1521:         result = df.copy()
 1522:         result.loc[bkey] = 0
 1523:         result = result.loc[bkey]
 1524:         expected = df.loc[bkey].copy()
 1525:         expected.loc[:] = 0
 1526:         if using_array_manager:
 1527:             # TODO(ArrayManager) we are still overwriting columns
 1528:             expected = expected.astype(float)
 1529:         tm.assert_frame_equal(result, expected)
 1530: 
 1531:         result = df.copy()
 1532:         result.loc[bkey] = 0
 1533:         result.loc[bkey] = df.iloc[binds]
 1534:         tm.assert_frame_equal(result, df)
 1535: 
 1536:     @pytest.mark.parametrize("key", ["A", ["A"], ("A", slice(None))])
 1537:     def test_loc_setitem_unsorted_multiindex_columns(self, key):
 1538:         # GH#38601
 1539:         mi = MultiIndex.from_tuples([("A", 4), ("B", "3"), ("A", "2")])
 1540:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=mi)
 1541:         obj = df.copy()
 1542:         obj.loc[:, key] = np.zeros((2, 2), dtype="int64")
 1543:         expected = DataFrame([[0, 2, 0], [0, 5, 0]], columns=mi)
 1544:         tm.assert_frame_equal(obj, expected)
 1545: 
 1546:         df = df.sort_index(axis=1)
 1547:         df.loc[:, key] = np.zeros((2, 2), dtype="int64")
 1548:         expected = expected.sort_index(axis=1)
 1549:         tm.assert_frame_equal(df, expected)
 1550: 
 1551:     def test_loc_setitem_uint_drop(self, any_int_numpy_dtype):
 1552:         # see GH#18311
 1553:         # assigning series.loc[0] = 4 changed series.dtype to int
 1554:         series = Series([1, 2, 3], dtype=any_int_numpy_dtype)
 1555:         series.loc[0] = 4
 1556:         expected = Series([4, 2, 3], dtype=any_int_numpy_dtype)
 1557:         tm.assert_series_equal(series, expected)
 1558: 
 1559:     def test_loc_setitem_td64_non_nano(self):
 1560:         # GH#14155
 1561:         ser = Series(10 * [np.timedelta64(10, "m")])
 1562:         ser.loc[[1, 2, 3]] = np.timedelta64(20, "m")
 1563:         expected = Series(10 * [np.timedelta64(10, "m")])
 1564:         expected.loc[[1, 2, 3]] = Timedelta(np.timedelta64(20, "m"))
 1565:         tm.assert_series_equal(ser, expected)
 1566: 
 1567:     def test_loc_setitem_2d_to_1d_raises(self):
 1568:         data = np.random.default_rng(2).standard_normal((2, 2))
 1569:         # float64 dtype to avoid upcast when trying to set float data
 1570:         ser = Series(range(2), dtype="float64")
 1571: 
 1572:         msg = "setting an array element with a sequence."
 1573:         with pytest.raises(ValueError, match=msg):
 1574:             ser.loc[range(2)] = data
 1575: 
 1576:         with pytest.raises(ValueError, match=msg):
 1577:             ser.loc[:] = data
 1578: 
 1579:     def test_loc_getitem_interval_index(self):
 1580:         # GH#19977
 1581:         index = pd.interval_range(start=0, periods=3)
 1582:         df = DataFrame(
 1583:             [[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=index, columns=["A", "B", "C"]
 1584:         )
 1585: 
 1586:         expected = 1
 1587:         result = df.loc[0.5, "A"]
 1588:         tm.assert_almost_equal(result, expected)
 1589: 
 1590:     def test_loc_getitem_interval_index2(self):
 1591:         # GH#19977
 1592:         index = pd.interval_range(start=0, periods=3, closed="both")
 1593:         df = DataFrame(
 1594:             [[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=index, columns=["A", "B", "C"]
 1595:         )
 1596: 
 1597:         index_exp = pd.interval_range(start=0, periods=2, freq=1, closed="both")
 1598:         expected = Series([1, 4], index=index_exp, name="A")
 1599:         result = df.loc[1, "A"]
 1600:         tm.assert_series_equal(result, expected)
 1601: 
 1602:     @pytest.mark.parametrize("tpl", [(1,), (1, 2)])
 1603:     def test_loc_getitem_index_single_double_tuples(self, tpl):
 1604:         # GH#20991
 1605:         idx = Index(
 1606:             [(1,), (1, 2)],
 1607:             name="A",
 1608:             tupleize_cols=False,
 1609:         )
 1610:         df = DataFrame(index=idx)
 1611: 
 1612:         result = df.loc[[tpl]]
 1613:         idx = Index([tpl], name="A", tupleize_cols=False)
 1614:         expected = DataFrame(index=idx)
 1615:         tm.assert_frame_equal(result, expected)
 1616: 
 1617:     def test_loc_getitem_index_namedtuple(self):
 1618:         IndexType = namedtuple("IndexType", ["a", "b"])
 1619:         idx1 = IndexType("foo", "bar")
 1620:         idx2 = IndexType("baz", "bof")
 1621:         index = Index([idx1, idx2], name="composite_index", tupleize_cols=False)
 1622:         df = DataFrame([(1, 2), (3, 4)], index=index, columns=["A", "B"])
 1623: 
 1624:         result = df.loc[IndexType("foo", "bar")]["A"]
 1625:         assert result == 1
 1626: 
 1627:     def test_loc_setitem_single_column_mixed(self, using_infer_string):
 1628:         df = DataFrame(
 1629:             np.random.default_rng(2).standard_normal((5, 3)),
 1630:             index=["a", "b", "c", "d", "e"],
 1631:             columns=["foo", "bar", "baz"],
 1632:         )
 1633:         df["str"] = "qux"
 1634:         df.loc[df.index[::2], "str"] = np.nan
 1635:         expected = Series(
 1636:             [np.nan, "qux", np.nan, "qux", np.nan],
 1637:             dtype=object if not using_infer_string else "string[pyarrow_numpy]",
 1638:         ).values
 1639:         tm.assert_almost_equal(df["str"].values, expected)
 1640: 
 1641:     def test_loc_setitem_cast2(self):
 1642:         # GH#7704
 1643:         # dtype conversion on setting
 1644:         df = DataFrame(np.random.default_rng(2).random((30, 3)), columns=tuple("ABC"))
 1645:         df["event"] = np.nan
 1646:         with tm.assert_produces_warning(
 1647:             FutureWarning, match="item of incompatible dtype"
 1648:         ):
 1649:             df.loc[10, "event"] = "foo"
 1650:         result = df.dtypes
 1651:         expected = Series(
 1652:             [np.dtype("float64")] * 3 + [np.dtype("object")],
 1653:             index=["A", "B", "C", "event"],
 1654:         )
 1655:         tm.assert_series_equal(result, expected)
 1656: 
 1657:     def test_loc_setitem_cast3(self):
 1658:         # Test that data type is preserved . GH#5782
 1659:         df = DataFrame({"one": np.arange(6, dtype=np.int8)})
 1660:         df.loc[1, "one"] = 6
 1661:         assert df.dtypes.one == np.dtype(np.int8)
 1662:         df.one = np.int8(7)
 1663:         assert df.dtypes.one == np.dtype(np.int8)
 1664: 
 1665:     def test_loc_setitem_range_key(self, frame_or_series):
 1666:         # GH#45479 don't treat range key as positional
 1667:         obj = frame_or_series(range(5), index=[3, 4, 1, 0, 2])
 1668: 
 1669:         values = [9, 10, 11]
 1670:         if obj.ndim == 2:
 1671:             values = [[9], [10], [11]]
 1672: 
 1673:         obj.loc[range(3)] = values
 1674: 
 1675:         expected = frame_or_series([0, 1, 10, 9, 11], index=obj.index)
 1676:         tm.assert_equal(obj, expected)
 1677: 
 1678:     def test_loc_setitem_numpy_frame_categorical_value(self):
 1679:         # GH#52927
 1680:         df = DataFrame({"a": [1, 1, 1, 1, 1], "b": ["a", "a", "a", "a", "a"]})
 1681:         df.loc[1:2, "a"] = Categorical([2, 2], categories=[1, 2])
 1682: 
 1683:         expected = DataFrame({"a": [1, 2, 2, 1, 1], "b": ["a", "a", "a", "a", "a"]})
 1684:         tm.assert_frame_equal(df, expected)
 1685: 
 1686: 
 1687: class TestLocWithEllipsis:
 1688:     @pytest.fixture(params=[tm.loc, tm.iloc])
 1689:     def indexer(self, request):
 1690:         # Test iloc while we're here
 1691:         return request.param
 1692: 
 1693:     @pytest.fixture
 1694:     def obj(self, series_with_simple_index, frame_or_series):
 1695:         obj = series_with_simple_index
 1696:         if frame_or_series is not Series:
 1697:             obj = obj.to_frame()
 1698:         return obj
 1699: 
 1700:     def test_loc_iloc_getitem_ellipsis(self, obj, indexer):
 1701:         result = indexer(obj)[...]
 1702:         tm.assert_equal(result, obj)
 1703: 
 1704:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
 1705:     def test_loc_iloc_getitem_leading_ellipses(self, series_with_simple_index, indexer):
 1706:         obj = series_with_simple_index
 1707:         key = 0 if (indexer is tm.iloc or len(obj) == 0) else obj.index[0]
 1708: 
 1709:         if indexer is tm.loc and obj.index.inferred_type == "boolean":
 1710:             # passing [False] will get interpreted as a boolean mask
 1711:             # TODO: should it?  unambiguous when lengths dont match?
 1712:             return
 1713:         if indexer is tm.loc and isinstance(obj.index, MultiIndex):
 1714:             msg = "MultiIndex does not support indexing with Ellipsis"
 1715:             with pytest.raises(NotImplementedError, match=msg):
 1716:                 result = indexer(obj)[..., [key]]
 1717: 
 1718:         elif len(obj) != 0:
 1719:             result = indexer(obj)[..., [key]]
 1720:             expected = indexer(obj)[[key]]
 1721:             tm.assert_series_equal(result, expected)
 1722: 
 1723:         key2 = 0 if indexer is tm.iloc else obj.name
 1724:         df = obj.to_frame()
 1725:         result = indexer(df)[..., [key2]]
 1726:         expected = indexer(df)[:, [key2]]
 1727:         tm.assert_frame_equal(result, expected)
 1728: 
 1729:     def test_loc_iloc_getitem_ellipses_only_one_ellipsis(self, obj, indexer):
 1730:         # GH37750
 1731:         key = 0 if (indexer is tm.iloc or len(obj) == 0) else obj.index[0]
 1732: 
 1733:         with pytest.raises(IndexingError, match=_one_ellipsis_message):
 1734:             indexer(obj)[..., ...]
 1735: 
 1736:         with pytest.raises(IndexingError, match=_one_ellipsis_message):
 1737:             indexer(obj)[..., [key], ...]
 1738: 
 1739:         with pytest.raises(IndexingError, match=_one_ellipsis_message):
 1740:             indexer(obj)[..., ..., key]
 1741: 
 1742:         # one_ellipsis_message takes precedence over "Too many indexers"
 1743:         #  only when the first key is Ellipsis
 1744:         with pytest.raises(IndexingError, match="Too many indexers"):
 1745:             indexer(obj)[key, ..., ...]
 1746: 
 1747: 
 1748: class TestLocWithMultiIndex:
 1749:     @pytest.mark.parametrize(
 1750:         "keys, expected",
 1751:         [
 1752:             (["b", "a"], [["b", "b", "a", "a"], [1, 2, 1, 2]]),
 1753:             (["a", "b"], [["a", "a", "b", "b"], [1, 2, 1, 2]]),
 1754:             ((["a", "b"], [1, 2]), [["a", "a", "b", "b"], [1, 2, 1, 2]]),
 1755:             ((["a", "b"], [2, 1]), [["a", "a", "b", "b"], [2, 1, 2, 1]]),
 1756:             ((["b", "a"], [2, 1]), [["b", "b", "a", "a"], [2, 1, 2, 1]]),
 1757:             ((["b", "a"], [1, 2]), [["b", "b", "a", "a"], [1, 2, 1, 2]]),
 1758:             ((["c", "a"], [2, 1]), [["c", "a", "a"], [1, 2, 1]]),
 1759:         ],
 1760:     )
 1761:     @pytest.mark.parametrize("dim", ["index", "columns"])
 1762:     def test_loc_getitem_multilevel_index_order(self, dim, keys, expected):
 1763:         # GH#22797
 1764:         # Try to respect order of keys given for MultiIndex.loc
 1765:         kwargs = {dim: [["c", "a", "a", "b", "b"], [1, 1, 2, 1, 2]]}
 1766:         df = DataFrame(np.arange(25).reshape(5, 5), **kwargs)
 1767:         exp_index = MultiIndex.from_arrays(expected)
 1768:         if dim == "index":
 1769:             res = df.loc[keys, :]
 1770:             tm.assert_index_equal(res.index, exp_index)
 1771:         elif dim == "columns":
 1772:             res = df.loc[:, keys]
 1773:             tm.assert_index_equal(res.columns, exp_index)
 1774: 
 1775:     def test_loc_preserve_names(self, multiindex_year_month_day_dataframe_random_data):
 1776:         ymd = multiindex_year_month_day_dataframe_random_data
 1777: 
 1778:         result = ymd.loc[2000]
 1779:         result2 = ymd["A"].loc[2000]
 1780:         assert result.index.names == ymd.index.names[1:]
 1781:         assert result2.index.names == ymd.index.names[1:]
 1782: 
 1783:         result = ymd.loc[2000, 2]
 1784:         result2 = ymd["A"].loc[2000, 2]
 1785:         assert result.index.name == ymd.index.names[2]
 1786:         assert result2.index.name == ymd.index.names[2]
 1787: 
 1788:     def test_loc_getitem_multiindex_nonunique_len_zero(self):
 1789:         # GH#13691
 1790:         mi = MultiIndex.from_product([[0], [1, 1]])
 1791:         ser = Series(0, index=mi)
 1792: 
 1793:         res = ser.loc[[]]
 1794: 
 1795:         expected = ser[:0]
 1796:         tm.assert_series_equal(res, expected)
 1797: 
 1798:         res2 = ser.loc[ser.iloc[0:0]]
 1799:         tm.assert_series_equal(res2, expected)
 1800: 
 1801:     def test_loc_getitem_access_none_value_in_multiindex(self):
 1802:         # GH#34318: test that you can access a None value using .loc
 1803:         #  through a Multiindex
 1804: 
 1805:         ser = Series([None], MultiIndex.from_arrays([["Level1"], ["Level2"]]))
 1806:         result = ser.loc[("Level1", "Level2")]
 1807:         assert result is None
 1808: 
 1809:         midx = MultiIndex.from_product([["Level1"], ["Level2_a", "Level2_b"]])
 1810:         ser = Series([None] * len(midx), dtype=object, index=midx)
 1811:         result = ser.loc[("Level1", "Level2_a")]
 1812:         assert result is None
 1813: 
 1814:         ser = Series([1] * len(midx), dtype=object, index=midx)
 1815:         result = ser.loc[("Level1", "Level2_a")]
 1816:         assert result == 1
 1817: 
 1818:     def test_loc_setitem_multiindex_slice(self):
 1819:         # GH 34870
 1820: 
 1821:         index = MultiIndex.from_tuples(
 1822:             zip(
 1823:                 ["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"],
 1824:                 ["one", "two", "one", "two", "one", "two", "one", "two"],
 1825:             ),
 1826:             names=["first", "second"],
 1827:         )
 1828: 
 1829:         result = Series([1, 1, 1, 1, 1, 1, 1, 1], index=index)
 1830:         result.loc[("baz", "one"):("foo", "two")] = 100
 1831: 
 1832:         expected = Series([1, 1, 100, 100, 100, 100, 1, 1], index=index)
 1833: 
 1834:         tm.assert_series_equal(result, expected)
 1835: 
 1836:     def test_loc_getitem_slice_datetime_objs_with_datetimeindex(self):
 1837:         times = date_range("2000-01-01", freq="10min", periods=100000)
 1838:         ser = Series(range(100000), times)
 1839:         result = ser.loc[datetime(1900, 1, 1) : datetime(2100, 1, 1)]
 1840:         tm.assert_series_equal(result, ser)
 1841: 
 1842:     def test_loc_getitem_datetime_string_with_datetimeindex(self):
 1843:         # GH 16710
 1844:         df = DataFrame(
 1845:             {"a": range(10), "b": range(10)},
 1846:             index=date_range("2010-01-01", "2010-01-10"),
 1847:         )
 1848:         result = df.loc[["2010-01-01", "2010-01-05"], ["a", "b"]]
 1849:         expected = DataFrame(
 1850:             {"a": [0, 4], "b": [0, 4]},
 1851:             index=DatetimeIndex(["2010-01-01", "2010-01-05"]),
 1852:         )
 1853:         tm.assert_frame_equal(result, expected)
 1854: 
 1855:     def test_loc_getitem_sorted_index_level_with_duplicates(self):
 1856:         # GH#4516 sorting a MultiIndex with duplicates and multiple dtypes
 1857:         mi = MultiIndex.from_tuples(
 1858:             [
 1859:                 ("foo", "bar"),
 1860:                 ("foo", "bar"),
 1861:                 ("bah", "bam"),
 1862:                 ("bah", "bam"),
 1863:                 ("foo", "bar"),
 1864:                 ("bah", "bam"),
 1865:             ],
 1866:             names=["A", "B"],
 1867:         )
 1868:         df = DataFrame(
 1869:             [
 1870:                 [1.0, 1],
 1871:                 [2.0, 2],
 1872:                 [3.0, 3],
 1873:                 [4.0, 4],
 1874:                 [5.0, 5],
 1875:                 [6.0, 6],
 1876:             ],
 1877:             index=mi,
 1878:             columns=["C", "D"],
 1879:         )
 1880:         df = df.sort_index(level=0)
 1881: 
 1882:         expected = DataFrame(
 1883:             [[1.0, 1], [2.0, 2], [5.0, 5]], columns=["C", "D"], index=mi.take([0, 1, 4])
 1884:         )
 1885: 
 1886:         result = df.loc[("foo", "bar")]
 1887:         tm.assert_frame_equal(result, expected)
 1888: 
 1889:     def test_additional_element_to_categorical_series_loc(self):
 1890:         # GH#47677
 1891:         result = Series(["a", "b", "c"], dtype="category")
 1892:         result.loc[3] = 0
 1893:         expected = Series(["a", "b", "c", 0], dtype="object")
 1894:         tm.assert_series_equal(result, expected)
 1895: 
 1896:     def test_additional_categorical_element_loc(self):
 1897:         # GH#47677
 1898:         result = Series(["a", "b", "c"], dtype="category")
 1899:         result.loc[3] = "a"
 1900:         expected = Series(["a", "b", "c", "a"], dtype="category")
 1901:         tm.assert_series_equal(result, expected)
 1902: 
 1903:     def test_loc_set_nan_in_categorical_series(self, any_numeric_ea_dtype):
 1904:         # GH#47677
 1905:         srs = Series(
 1906:             [1, 2, 3],
 1907:             dtype=CategoricalDtype(Index([1, 2, 3], dtype=any_numeric_ea_dtype)),
 1908:         )
 1909:         # enlarge
 1910:         srs.loc[3] = np.nan
 1911:         expected = Series(
 1912:             [1, 2, 3, np.nan],
 1913:             dtype=CategoricalDtype(Index([1, 2, 3], dtype=any_numeric_ea_dtype)),
 1914:         )
 1915:         tm.assert_series_equal(srs, expected)
 1916:         # set into
 1917:         srs.loc[1] = np.nan
 1918:         expected = Series(
 1919:             [1, np.nan, 3, np.nan],
 1920:             dtype=CategoricalDtype(Index([1, 2, 3], dtype=any_numeric_ea_dtype)),
 1921:         )
 1922:         tm.assert_series_equal(srs, expected)
 1923: 
 1924:     @pytest.mark.parametrize("na", (np.nan, pd.NA, None, pd.NaT))
 1925:     def test_loc_consistency_series_enlarge_set_into(self, na):
 1926:         # GH#47677
 1927:         srs_enlarge = Series(["a", "b", "c"], dtype="category")
 1928:         srs_enlarge.loc[3] = na
 1929: 
 1930:         srs_setinto = Series(["a", "b", "c", "a"], dtype="category")
 1931:         srs_setinto.loc[3] = na
 1932: 
 1933:         tm.assert_series_equal(srs_enlarge, srs_setinto)
 1934:         expected = Series(["a", "b", "c", na], dtype="category")
 1935:         tm.assert_series_equal(srs_enlarge, expected)
 1936: 
 1937:     def test_loc_getitem_preserves_index_level_category_dtype(self):
 1938:         # GH#15166
 1939:         df = DataFrame(
 1940:             data=np.arange(2, 22, 2),
 1941:             index=MultiIndex(
 1942:                 levels=[CategoricalIndex(["a", "b"]), range(10)],
 1943:                 codes=[[0] * 5 + [1] * 5, range(10)],
 1944:                 names=["Index1", "Index2"],
 1945:             ),
 1946:         )
 1947: 
 1948:         expected = CategoricalIndex(
 1949:             ["a", "b"],
 1950:             categories=["a", "b"],
 1951:             ordered=False,
 1952:             name="Index1",
 1953:             dtype="category",
 1954:         )
 1955: 
 1956:         result = df.index.levels[0]
 1957:         tm.assert_index_equal(result, expected)
 1958: 
 1959:         result = df.loc[["a"]].index.levels[0]
 1960:         tm.assert_index_equal(result, expected)
 1961: 
 1962:     @pytest.mark.parametrize("lt_value", [30, 10])
 1963:     def test_loc_multiindex_levels_contain_values_not_in_index_anymore(self, lt_value):
 1964:         # GH#41170
 1965:         df = DataFrame({"a": [12, 23, 34, 45]}, index=[list("aabb"), [0, 1, 2, 3]])
 1966:         with pytest.raises(KeyError, match=r"\['b'\] not in index"):
 1967:             df.loc[df["a"] < lt_value, :].loc[["b"], :]
 1968: 
 1969:     def test_loc_multiindex_null_slice_na_level(self):
 1970:         # GH#42055
 1971:         lev1 = np.array([np.nan, np.nan])
 1972:         lev2 = ["bar", "baz"]
 1973:         mi = MultiIndex.from_arrays([lev1, lev2])
 1974:         ser = Series([0, 1], index=mi)
 1975:         result = ser.loc[:, "bar"]
 1976: 
 1977:         # TODO: should we have name="bar"?
 1978:         expected = Series([0], index=[np.nan])
 1979:         tm.assert_series_equal(result, expected)
 1980: 
 1981:     def test_loc_drops_level(self):
 1982:         # Based on test_series_varied_multiindex_alignment, where
 1983:         #  this used to fail to drop the first level
 1984:         mi = MultiIndex.from_product(
 1985:             [list("ab"), list("xy"), [1, 2]], names=["ab", "xy", "num"]
 1986:         )
 1987:         ser = Series(range(8), index=mi)
 1988: 
 1989:         loc_result = ser.loc["a", :, :]
 1990:         expected = ser.index.droplevel(0)[:4]
 1991:         tm.assert_index_equal(loc_result.index, expected)
 1992: 
 1993: 
 1994: class TestLocSetitemWithExpansion:
 1995:     def test_loc_setitem_with_expansion_large_dataframe(self, monkeypatch):
 1996:         # GH#10692
 1997:         size_cutoff = 50
 1998:         with monkeypatch.context():
 1999:             monkeypatch.setattr(libindex, "_SIZE_CUTOFF", size_cutoff)
 2000:             result = DataFrame({"x": range(size_cutoff)}, dtype="int64")
 2001:             result.loc[size_cutoff] = size_cutoff
 2002:         expected = DataFrame({"x": range(size_cutoff + 1)}, dtype="int64")
 2003:         tm.assert_frame_equal(result, expected)
 2004: 
 2005:     def test_loc_setitem_empty_series(self):
 2006:         # GH#5226
 2007: 
 2008:         # partially set with an empty object series
 2009:         ser = Series(dtype=object)
 2010:         ser.loc[1] = 1
 2011:         tm.assert_series_equal(ser, Series([1], index=[1]))
 2012:         ser.loc[3] = 3
 2013:         tm.assert_series_equal(ser, Series([1, 3], index=[1, 3]))
 2014: 
 2015:     def test_loc_setitem_empty_series_float(self):
 2016:         # GH#5226
 2017: 
 2018:         # partially set with an empty object series
 2019:         ser = Series(dtype=object)
 2020:         ser.loc[1] = 1.0
 2021:         tm.assert_series_equal(ser, Series([1.0], index=[1]))
 2022:         ser.loc[3] = 3.0
 2023:         tm.assert_series_equal(ser, Series([1.0, 3.0], index=[1, 3]))
 2024: 
 2025:     def test_loc_setitem_empty_series_str_idx(self):
 2026:         # GH#5226
 2027: 
 2028:         # partially set with an empty object series
 2029:         ser = Series(dtype=object)
 2030:         ser.loc["foo"] = 1
 2031:         tm.assert_series_equal(ser, Series([1], index=Index(["foo"], dtype=object)))
 2032:         ser.loc["bar"] = 3
 2033:         tm.assert_series_equal(
 2034:             ser, Series([1, 3], index=Index(["foo", "bar"], dtype=object))
 2035:         )
 2036:         ser.loc[3] = 4
 2037:         tm.assert_series_equal(
 2038:             ser, Series([1, 3, 4], index=Index(["foo", "bar", 3], dtype=object))
 2039:         )
 2040: 
 2041:     def test_loc_setitem_incremental_with_dst(self):
 2042:         # GH#20724
 2043:         base = datetime(2015, 11, 1, tzinfo=gettz("US/Pacific"))
 2044:         idxs = [base + timedelta(seconds=i * 900) for i in range(16)]
 2045:         result = Series([0], index=[idxs[0]])
 2046:         for ts in idxs:
 2047:             result.loc[ts] = 1
 2048:         expected = Series(1, index=idxs)
 2049:         tm.assert_series_equal(result, expected)
 2050: 
 2051:     @pytest.mark.parametrize(
 2052:         "conv",
 2053:         [
 2054:             lambda x: x,
 2055:             lambda x: x.to_datetime64(),
 2056:             lambda x: x.to_pydatetime(),
 2057:             lambda x: np.datetime64(x),
 2058:         ],
 2059:         ids=["self", "to_datetime64", "to_pydatetime", "np.datetime64"],
 2060:     )
 2061:     def test_loc_setitem_datetime_keys_cast(self, conv):
 2062:         # GH#9516
 2063:         dt1 = Timestamp("20130101 09:00:00")
 2064:         dt2 = Timestamp("20130101 10:00:00")
 2065:         df = DataFrame()
 2066:         df.loc[conv(dt1), "one"] = 100
 2067:         df.loc[conv(dt2), "one"] = 200
 2068: 
 2069:         expected = DataFrame(
 2070:             {"one": [100.0, 200.0]},
 2071:             index=[dt1, dt2],
 2072:             columns=Index(["one"], dtype=object),
 2073:         )
 2074:         tm.assert_frame_equal(df, expected)
 2075: 
 2076:     def test_loc_setitem_categorical_column_retains_dtype(self, ordered):
 2077:         # GH16360
 2078:         result = DataFrame({"A": [1]})
 2079:         result.loc[:, "B"] = Categorical(["b"], ordered=ordered)
 2080:         expected = DataFrame({"A": [1], "B": Categorical(["b"], ordered=ordered)})
 2081:         tm.assert_frame_equal(result, expected)
 2082: 
 2083:     def test_loc_setitem_with_expansion_and_existing_dst(self):
 2084:         # GH#18308
 2085:         start = Timestamp("2017-10-29 00:00:00+0200", tz="Europe/Madrid")
 2086:         end = Timestamp("2017-10-29 03:00:00+0100", tz="Europe/Madrid")
 2087:         ts = Timestamp("2016-10-10 03:00:00", tz="Europe/Madrid")
 2088:         idx = date_range(start, end, inclusive="left", freq="h")
 2089:         assert ts not in idx  # i.e. result.loc setitem is with-expansion
 2090: 
 2091:         result = DataFrame(index=idx, columns=["value"])
 2092:         result.loc[ts, "value"] = 12
 2093:         expected = DataFrame(
 2094:             [np.nan] * len(idx) + [12],
 2095:             index=idx.append(DatetimeIndex([ts])),
 2096:             columns=["value"],
 2097:             dtype=object,
 2098:         )
 2099:         tm.assert_frame_equal(result, expected)
 2100: 
 2101:     def test_setitem_with_expansion(self):
 2102:         # indexing - setting an element
 2103:         df = DataFrame(
 2104:             data=to_datetime(["2015-03-30 20:12:32", "2015-03-12 00:11:11"]),
 2105:             columns=["time"],
 2106:         )
 2107:         df["new_col"] = ["new", "old"]
 2108:         df.time = df.set_index("time").index.tz_localize("UTC")
 2109:         v = df[df.new_col == "new"].set_index("time").index.tz_convert("US/Pacific")
 2110: 
 2111:         # pre-2.0  trying to set a single element on a part of a different
 2112:         #  timezone converted to object; in 2.0 it retains dtype
 2113:         df2 = df.copy()
 2114:         df2.loc[df2.new_col == "new", "time"] = v
 2115: 
 2116:         expected = Series([v[0].tz_convert("UTC"), df.loc[1, "time"]], name="time")
 2117:         tm.assert_series_equal(df2.time, expected)
 2118: 
 2119:         v = df.loc[df.new_col == "new", "time"] + Timedelta("1s")
 2120:         df.loc[df.new_col == "new", "time"] = v
 2121:         tm.assert_series_equal(df.loc[df.new_col == "new", "time"], v)
 2122: 
 2123:     def test_loc_setitem_with_expansion_inf_upcast_empty(self):
 2124:         # Test with np.inf in columns
 2125:         df = DataFrame()
 2126:         df.loc[0, 0] = 1
 2127:         df.loc[1, 1] = 2
 2128:         df.loc[0, np.inf] = 3
 2129: 
 2130:         result = df.columns
 2131:         expected = Index([0, 1, np.inf], dtype=np.float64)
 2132:         tm.assert_index_equal(result, expected)
 2133: 
 2134:     @pytest.mark.filterwarnings("ignore:indexing past lexsort depth")
 2135:     def test_loc_setitem_with_expansion_nonunique_index(self, index):
 2136:         # GH#40096
 2137:         if not len(index):
 2138:             pytest.skip("Not relevant for empty Index")
 2139: 
 2140:         index = index.repeat(2)  # ensure non-unique
 2141:         N = len(index)
 2142:         arr = np.arange(N).astype(np.int64)
 2143: 
 2144:         orig = DataFrame(arr, index=index, columns=[0])
 2145: 
 2146:         # key that will requiring object-dtype casting in the index
 2147:         key = "kapow"
 2148:         assert key not in index  # otherwise test is invalid
 2149:         # TODO: using a tuple key breaks here in many cases
 2150: 
 2151:         exp_index = index.insert(len(index), key)
 2152:         if isinstance(index, MultiIndex):
 2153:             assert exp_index[-1][0] == key
 2154:         else:
 2155:             assert exp_index[-1] == key
 2156:         exp_data = np.arange(N + 1).astype(np.float64)
 2157:         expected = DataFrame(exp_data, index=exp_index, columns=[0])
 2158: 
 2159:         # Add new row, but no new columns
 2160:         df = orig.copy()
 2161:         df.loc[key, 0] = N
 2162:         tm.assert_frame_equal(df, expected)
 2163: 
 2164:         # add new row on a Series
 2165:         ser = orig.copy()[0]
 2166:         ser.loc[key] = N
 2167:         # the series machinery lets us preserve int dtype instead of float
 2168:         expected = expected[0].astype(np.int64)
 2169:         tm.assert_series_equal(ser, expected)
 2170: 
 2171:         # add new row and new column
 2172:         df = orig.copy()
 2173:         df.loc[key, 1] = N
 2174:         expected = DataFrame(
 2175:             {0: list(arr) + [np.nan], 1: [np.nan] * N + [float(N)]},
 2176:             index=exp_index,
 2177:         )
 2178:         tm.assert_frame_equal(df, expected)
 2179: 
 2180:     @pytest.mark.parametrize(
 2181:         "dtype", ["Int32", "Int64", "UInt32", "UInt64", "Float32", "Float64"]
 2182:     )
 2183:     def test_loc_setitem_with_expansion_preserves_nullable_int(self, dtype):
 2184:         # GH#42099
 2185:         ser = Series([0, 1, 2, 3], dtype=dtype)
 2186:         df = DataFrame({"data": ser})
 2187: 
 2188:         result = DataFrame(index=df.index)
 2189:         result.loc[df.index, "data"] = ser
 2190: 
 2191:         tm.assert_frame_equal(result, df, check_column_type=False)
 2192: 
 2193:         result = DataFrame(index=df.index)
 2194:         result.loc[df.index, "data"] = ser._values
 2195:         tm.assert_frame_equal(result, df, check_column_type=False)
 2196: 
 2197:     def test_loc_setitem_ea_not_full_column(self):
 2198:         # GH#39163
 2199:         df = DataFrame({"A": range(5)})
 2200: 
 2201:         val = date_range("2016-01-01", periods=3, tz="US/Pacific")
 2202: 
 2203:         df.loc[[0, 1, 2], "B"] = val
 2204: 
 2205:         bex = val.append(DatetimeIndex([pd.NaT, pd.NaT], dtype=val.dtype))
 2206:         expected = DataFrame({"A": range(5), "B": bex})
 2207:         assert expected.dtypes["B"] == val.dtype
 2208:         tm.assert_frame_equal(df, expected)
 2209: 
 2210: 
 2211: class TestLocCallable:
 2212:     def test_frame_loc_getitem_callable(self):
 2213:         # GH#11485
 2214:         df = DataFrame({"A": [1, 2, 3, 4], "B": list("aabb"), "C": [1, 2, 3, 4]})
 2215:         # iloc cannot use boolean Series (see GH3635)
 2216: 
 2217:         # return bool indexer
 2218:         res = df.loc[lambda x: x.A > 2]
 2219:         tm.assert_frame_equal(res, df.loc[df.A > 2])
 2220: 
 2221:         res = df.loc[lambda x: x.B == "b", :]
 2222:         tm.assert_frame_equal(res, df.loc[df.B == "b", :])
 2223: 
 2224:         res = df.loc[lambda x: x.A > 2, lambda x: x.columns == "B"]
 2225:         tm.assert_frame_equal(res, df.loc[df.A > 2, [False, True, False]])
 2226: 
 2227:         res = df.loc[lambda x: x.A > 2, lambda x: "B"]
 2228:         tm.assert_series_equal(res, df.loc[df.A > 2, "B"])
 2229: 
 2230:         res = df.loc[lambda x: x.A > 2, lambda x: ["A", "B"]]
 2231:         tm.assert_frame_equal(res, df.loc[df.A > 2, ["A", "B"]])
 2232: 
 2233:         res = df.loc[lambda x: x.A == 2, lambda x: ["A", "B"]]
 2234:         tm.assert_frame_equal(res, df.loc[df.A == 2, ["A", "B"]])
 2235: 
 2236:         # scalar
 2237:         res = df.loc[lambda x: 1, lambda x: "A"]
 2238:         assert res == df.loc[1, "A"]
 2239: 
 2240:     def test_frame_loc_getitem_callable_mixture(self):
 2241:         # GH#11485
 2242:         df = DataFrame({"A": [1, 2, 3, 4], "B": list("aabb"), "C": [1, 2, 3, 4]})
 2243: 
 2244:         res = df.loc[lambda x: x.A > 2, ["A", "B"]]
 2245:         tm.assert_frame_equal(res, df.loc[df.A > 2, ["A", "B"]])
 2246: 
 2247:         res = df.loc[[2, 3], lambda x: ["A", "B"]]
 2248:         tm.assert_frame_equal(res, df.loc[[2, 3], ["A", "B"]])
 2249: 
 2250:         res = df.loc[3, lambda x: ["A", "B"]]
 2251:         tm.assert_series_equal(res, df.loc[3, ["A", "B"]])
 2252: 
 2253:     def test_frame_loc_getitem_callable_labels(self):
 2254:         # GH#11485
 2255:         df = DataFrame({"X": [1, 2, 3, 4], "Y": list("aabb")}, index=list("ABCD"))
 2256: 
 2257:         # return label
 2258:         res = df.loc[lambda x: ["A", "C"]]
 2259:         tm.assert_frame_equal(res, df.loc[["A", "C"]])
 2260: 
 2261:         res = df.loc[lambda x: ["A", "C"], :]
 2262:         tm.assert_frame_equal(res, df.loc[["A", "C"], :])
 2263: 
 2264:         res = df.loc[lambda x: ["A", "C"], lambda x: "X"]
 2265:         tm.assert_series_equal(res, df.loc[["A", "C"], "X"])
 2266: 
 2267:         res = df.loc[lambda x: ["A", "C"], lambda x: ["X"]]
 2268:         tm.assert_frame_equal(res, df.loc[["A", "C"], ["X"]])
 2269: 
 2270:         # mixture
 2271:         res = df.loc[["A", "C"], lambda x: "X"]
 2272:         tm.assert_series_equal(res, df.loc[["A", "C"], "X"])
 2273: 
 2274:         res = df.loc[["A", "C"], lambda x: ["X"]]
 2275:         tm.assert_frame_equal(res, df.loc[["A", "C"], ["X"]])
 2276: 
 2277:         res = df.loc[lambda x: ["A", "C"], "X"]
 2278:         tm.assert_series_equal(res, df.loc[["A", "C"], "X"])
 2279: 
 2280:         res = df.loc[lambda x: ["A", "C"], ["X"]]
 2281:         tm.assert_frame_equal(res, df.loc[["A", "C"], ["X"]])
 2282: 
 2283:     def test_frame_loc_setitem_callable(self):
 2284:         # GH#11485
 2285:         df = DataFrame(
 2286:             {"X": [1, 2, 3, 4], "Y": Series(list("aabb"), dtype=object)},
 2287:             index=list("ABCD"),
 2288:         )
 2289: 
 2290:         # return label
 2291:         res = df.copy()
 2292:         res.loc[lambda x: ["A", "C"]] = -20
 2293:         exp = df.copy()
 2294:         exp.loc[["A", "C"]] = -20
 2295:         tm.assert_frame_equal(res, exp)
 2296: 
 2297:         res = df.copy()
 2298:         res.loc[lambda x: ["A", "C"], :] = 20
 2299:         exp = df.copy()
 2300:         exp.loc[["A", "C"], :] = 20
 2301:         tm.assert_frame_equal(res, exp)
 2302: 
 2303:         res = df.copy()
 2304:         res.loc[lambda x: ["A", "C"], lambda x: "X"] = -1
 2305:         exp = df.copy()
 2306:         exp.loc[["A", "C"], "X"] = -1
 2307:         tm.assert_frame_equal(res, exp)
 2308: 
 2309:         res = df.copy()
 2310:         res.loc[lambda x: ["A", "C"], lambda x: ["X"]] = [5, 10]
 2311:         exp = df.copy()
 2312:         exp.loc[["A", "C"], ["X"]] = [5, 10]
 2313:         tm.assert_frame_equal(res, exp)
 2314: 
 2315:         # mixture
 2316:         res = df.copy()
 2317:         res.loc[["A", "C"], lambda x: "X"] = np.array([-1, -2])
 2318:         exp = df.copy()
 2319:         exp.loc[["A", "C"], "X"] = np.array([-1, -2])
 2320:         tm.assert_frame_equal(res, exp)
 2321: 
 2322:         res = df.copy()
 2323:         res.loc[["A", "C"], lambda x: ["X"]] = 10
 2324:         exp = df.copy()
 2325:         exp.loc[["A", "C"], ["X"]] = 10
 2326:         tm.assert_frame_equal(res, exp)
 2327: 
 2328:         res = df.copy()
 2329:         res.loc[lambda x: ["A", "C"], "X"] = -2
 2330:         exp = df.copy()
 2331:         exp.loc[["A", "C"], "X"] = -2
 2332:         tm.assert_frame_equal(res, exp)
 2333: 
 2334:         res = df.copy()
 2335:         res.loc[lambda x: ["A", "C"], ["X"]] = -4
 2336:         exp = df.copy()
 2337:         exp.loc[["A", "C"], ["X"]] = -4
 2338:         tm.assert_frame_equal(res, exp)
 2339: 
 2340: 
 2341: class TestPartialStringSlicing:
 2342:     def test_loc_getitem_partial_string_slicing_datetimeindex(self):
 2343:         # GH#35509
 2344:         df = DataFrame(
 2345:             {"col1": ["a", "b", "c"], "col2": [1, 2, 3]},
 2346:             index=to_datetime(["2020-08-01", "2020-07-02", "2020-08-05"]),
 2347:         )
 2348:         expected = DataFrame(
 2349:             {"col1": ["a", "c"], "col2": [1, 3]},
 2350:             index=to_datetime(["2020-08-01", "2020-08-05"]),
 2351:         )
 2352:         result = df.loc["2020-08"]
 2353:         tm.assert_frame_equal(result, expected)
 2354: 
 2355:     def test_loc_getitem_partial_string_slicing_with_periodindex(self):
 2356:         pi = pd.period_range(start="2017-01-01", end="2018-01-01", freq="M")
 2357:         ser = pi.to_series()
 2358:         result = ser.loc[:"2017-12"]
 2359:         expected = ser.iloc[:-1]
 2360: 
 2361:         tm.assert_series_equal(result, expected)
 2362: 
 2363:     def test_loc_getitem_partial_string_slicing_with_timedeltaindex(self):
 2364:         ix = timedelta_range(start="1 day", end="2 days", freq="1h")
 2365:         ser = ix.to_series()
 2366:         result = ser.loc[:"1 days"]
 2367:         expected = ser.iloc[:-1]
 2368: 
 2369:         tm.assert_series_equal(result, expected)
 2370: 
 2371:     def test_loc_getitem_str_timedeltaindex(self):
 2372:         # GH#16896
 2373:         df = DataFrame({"x": range(3)}, index=to_timedelta(range(3), unit="days"))
 2374:         expected = df.iloc[0]
 2375:         sliced = df.loc["0 days"]
 2376:         tm.assert_series_equal(sliced, expected)
 2377: 
 2378:     @pytest.mark.parametrize("indexer_end", [None, "2020-01-02 23:59:59.999999999"])
 2379:     def test_loc_getitem_partial_slice_non_monotonicity(
 2380:         self, tz_aware_fixture, indexer_end, frame_or_series
 2381:     ):
 2382:         # GH#33146
 2383:         obj = frame_or_series(
 2384:             [1] * 5,
 2385:             index=DatetimeIndex(
 2386:                 [
 2387:                     Timestamp("2019-12-30"),
 2388:                     Timestamp("2020-01-01"),
 2389:                     Timestamp("2019-12-25"),
 2390:                     Timestamp("2020-01-02 23:59:59.999999999"),
 2391:                     Timestamp("2019-12-19"),
 2392:                 ],
 2393:                 tz=tz_aware_fixture,
 2394:             ),
 2395:         )
 2396:         expected = frame_or_series(
 2397:             [1] * 2,
 2398:             index=DatetimeIndex(
 2399:                 [
 2400:                     Timestamp("2020-01-01"),
 2401:                     Timestamp("2020-01-02 23:59:59.999999999"),
 2402:                 ],
 2403:                 tz=tz_aware_fixture,
 2404:             ),
 2405:         )
 2406:         indexer = slice("2020-01-01", indexer_end)
 2407: 
 2408:         result = obj[indexer]
 2409:         tm.assert_equal(result, expected)
 2410: 
 2411:         result = obj.loc[indexer]
 2412:         tm.assert_equal(result, expected)
 2413: 
 2414: 
 2415: class TestLabelSlicing:
 2416:     def test_loc_getitem_slicing_datetimes_frame(self):
 2417:         # GH#7523
 2418: 
 2419:         # unique
 2420:         df_unique = DataFrame(
 2421:             np.arange(4.0, dtype="float64"),
 2422:             index=[datetime(2001, 1, i, 10, 00) for i in [1, 2, 3, 4]],
 2423:         )
 2424: 
 2425:         # duplicates
 2426:         df_dups = DataFrame(
 2427:             np.arange(5.0, dtype="float64"),
 2428:             index=[datetime(2001, 1, i, 10, 00) for i in [1, 2, 2, 3, 4]],
 2429:         )
 2430: 
 2431:         for df in [df_unique, df_dups]:
 2432:             result = df.loc[datetime(2001, 1, 1, 10) :]
 2433:             tm.assert_frame_equal(result, df)
 2434:             result = df.loc[: datetime(2001, 1, 4, 10)]
 2435:             tm.assert_frame_equal(result, df)
 2436:             result = df.loc[datetime(2001, 1, 1, 10) : datetime(2001, 1, 4, 10)]
 2437:             tm.assert_frame_equal(result, df)
 2438: 
 2439:             result = df.loc[datetime(2001, 1, 1, 11) :]
 2440:             expected = df.iloc[1:]
 2441:             tm.assert_frame_equal(result, expected)
 2442:             result = df.loc["20010101 11":]
 2443:             tm.assert_frame_equal(result, expected)
 2444: 
 2445:     def test_loc_getitem_label_slice_across_dst(self):
 2446:         # GH#21846
 2447:         idx = date_range(
 2448:             "2017-10-29 01:30:00", tz="Europe/Berlin", periods=5, freq="30 min"
 2449:         )
 2450:         series2 = Series([0, 1, 2, 3, 4], index=idx)
 2451: 
 2452:         t_1 = Timestamp("2017-10-29 02:30:00+02:00", tz="Europe/Berlin")
 2453:         t_2 = Timestamp("2017-10-29 02:00:00+01:00", tz="Europe/Berlin")
 2454:         result = series2.loc[t_1:t_2]
 2455:         expected = Series([2, 3], index=idx[2:4])
 2456:         tm.assert_series_equal(result, expected)
 2457: 
 2458:         result = series2[t_1]
 2459:         expected = 2
 2460:         assert result == expected
 2461: 
 2462:     @pytest.mark.parametrize(
 2463:         "index",
 2464:         [
 2465:             pd.period_range(start="2017-01-01", end="2018-01-01", freq="M"),
 2466:             timedelta_range(start="1 day", end="2 days", freq="1h"),
 2467:         ],
 2468:     )
 2469:     def test_loc_getitem_label_slice_period_timedelta(self, index):
 2470:         ser = index.to_series()
 2471:         result = ser.loc[: index[-2]]
 2472:         expected = ser.iloc[:-1]
 2473: 
 2474:         tm.assert_series_equal(result, expected)
 2475: 
 2476:     def test_loc_getitem_slice_floats_inexact(self):
 2477:         index = [52195.504153, 52196.303147, 52198.369883]
 2478:         df = DataFrame(np.random.default_rng(2).random((3, 2)), index=index)
 2479: 
 2480:         s1 = df.loc[52195.1:52196.5]
 2481:         assert len(s1) == 2
 2482: 
 2483:         s1 = df.loc[52195.1:52196.6]
 2484:         assert len(s1) == 2
 2485: 
 2486:         s1 = df.loc[52195.1:52198.9]
 2487:         assert len(s1) == 3
 2488: 
 2489:     def test_loc_getitem_float_slice_floatindex(self, float_numpy_dtype):
 2490:         dtype = float_numpy_dtype
 2491:         ser = Series(
 2492:             np.random.default_rng(2).random(10), index=np.arange(10, 20, dtype=dtype)
 2493:         )
 2494: 
 2495:         assert len(ser.loc[12.0:]) == 8
 2496:         assert len(ser.loc[12.5:]) == 7
 2497: 
 2498:         idx = np.arange(10, 20, dtype=dtype)
 2499:         idx[2] = 12.2
 2500:         ser.index = idx
 2501:         assert len(ser.loc[12.0:]) == 8
 2502:         assert len(ser.loc[12.5:]) == 7
 2503: 
 2504:     @pytest.mark.parametrize(
 2505:         "start,stop, expected_slice",
 2506:         [
 2507:             [np.timedelta64(0, "ns"), None, slice(0, 11)],
 2508:             [np.timedelta64(1, "D"), np.timedelta64(6, "D"), slice(1, 7)],
 2509:             [None, np.timedelta64(4, "D"), slice(0, 5)],
 2510:         ],
 2511:     )
 2512:     def test_loc_getitem_slice_label_td64obj(self, start, stop, expected_slice):
 2513:         # GH#20393
 2514:         ser = Series(range(11), timedelta_range("0 days", "10 days"))
 2515:         result = ser.loc[slice(start, stop)]
 2516:         expected = ser.iloc[expected_slice]
 2517:         tm.assert_series_equal(result, expected)
 2518: 
 2519:     @pytest.mark.parametrize("start", ["2018", "2020"])
 2520:     def test_loc_getitem_slice_unordered_dt_index(self, frame_or_series, start):
 2521:         obj = frame_or_series(
 2522:             [1, 2, 3],
 2523:             index=[Timestamp("2016"), Timestamp("2019"), Timestamp("2017")],
 2524:         )
 2525:         with pytest.raises(
 2526:             KeyError, match="Value based partial slicing on non-monotonic"
 2527:         ):
 2528:             obj.loc[start:"2022"]
 2529: 
 2530:     @pytest.mark.parametrize("value", [1, 1.5])
 2531:     def test_loc_getitem_slice_labels_int_in_object_index(self, frame_or_series, value):
 2532:         # GH: 26491
 2533:         obj = frame_or_series(range(4), index=[value, "first", 2, "third"])
 2534:         result = obj.loc[value:"third"]
 2535:         expected = frame_or_series(range(4), index=[value, "first", 2, "third"])
 2536:         tm.assert_equal(result, expected)
 2537: 
 2538:     def test_loc_getitem_slice_columns_mixed_dtype(self):
 2539:         # GH: 20975
 2540:         df = DataFrame({"test": 1, 1: 2, 2: 3}, index=[0])
 2541:         expected = DataFrame(
 2542:             data=[[2, 3]], index=[0], columns=Index([1, 2], dtype=object)
 2543:         )
 2544:         tm.assert_frame_equal(df.loc[:, 1:], expected)
 2545: 
 2546: 
 2547: class TestLocBooleanLabelsAndSlices:
 2548:     @pytest.mark.parametrize("bool_value", [True, False])
 2549:     def test_loc_bool_incompatible_index_raises(
 2550:         self, index, frame_or_series, bool_value
 2551:     ):
 2552:         # GH20432
 2553:         message = f"{bool_value}: boolean label can not be used without a boolean index"
 2554:         if index.inferred_type != "boolean":
 2555:             obj = frame_or_series(index=index, dtype="object")
 2556:             with pytest.raises(KeyError, match=message):
 2557:                 obj.loc[bool_value]
 2558: 
 2559:     @pytest.mark.parametrize("bool_value", [True, False])
 2560:     def test_loc_bool_should_not_raise(self, frame_or_series, bool_value):
 2561:         obj = frame_or_series(
 2562:             index=Index([True, False], dtype="boolean"), dtype="object"
 2563:         )
 2564:         obj.loc[bool_value]
 2565: 
 2566:     def test_loc_bool_slice_raises(self, index, frame_or_series):
 2567:         # GH20432
 2568:         message = (
 2569:             r"slice\(True, False, None\): boolean values can not be used in a slice"
 2570:         )
 2571:         obj = frame_or_series(index=index, dtype="object")
 2572:         with pytest.raises(TypeError, match=message):
 2573:             obj.loc[True:False]
 2574: 
 2575: 
 2576: class TestLocBooleanMask:
 2577:     def test_loc_setitem_bool_mask_timedeltaindex(self):
 2578:         # GH#14946
 2579:         df = DataFrame({"x": range(10)})
 2580:         df.index = to_timedelta(range(10), unit="s")
 2581:         conditions = [df["x"] > 3, df["x"] == 3, df["x"] < 3]
 2582:         expected_data = [
 2583:             [0, 1, 2, 3, 10, 10, 10, 10, 10, 10],
 2584:             [0, 1, 2, 10, 4, 5, 6, 7, 8, 9],
 2585:             [10, 10, 10, 3, 4, 5, 6, 7, 8, 9],
 2586:         ]
 2587:         for cond, data in zip(conditions, expected_data):
 2588:             result = df.copy()
 2589:             result.loc[cond, "x"] = 10
 2590: 
 2591:             expected = DataFrame(
 2592:                 data,
 2593:                 index=to_timedelta(range(10), unit="s"),
 2594:                 columns=["x"],
 2595:                 dtype="int64",
 2596:             )
 2597:             tm.assert_frame_equal(expected, result)
 2598: 
 2599:     @pytest.mark.parametrize("tz", [None, "UTC"])
 2600:     def test_loc_setitem_mask_with_datetimeindex_tz(self, tz):
 2601:         # GH#16889
 2602:         # support .loc with alignment and tz-aware DatetimeIndex
 2603:         mask = np.array([True, False, True, False])
 2604: 
 2605:         idx = date_range("20010101", periods=4, tz=tz)
 2606:         df = DataFrame({"a": np.arange(4)}, index=idx).astype("float64")
 2607: 
 2608:         result = df.copy()
 2609:         result.loc[mask, :] = df.loc[mask, :]
 2610:         tm.assert_frame_equal(result, df)
 2611: 
 2612:         result = df.copy()
 2613:         result.loc[mask] = df.loc[mask]
 2614:         tm.assert_frame_equal(result, df)
 2615: 
 2616:     def test_loc_setitem_mask_and_label_with_datetimeindex(self):
 2617:         # GH#9478
 2618:         # a datetimeindex alignment issue with partial setting
 2619:         df = DataFrame(
 2620:             np.arange(6.0).reshape(3, 2),
 2621:             columns=list("AB"),
 2622:             index=date_range("1/1/2000", periods=3, freq="1h"),
 2623:         )
 2624:         expected = df.copy()
 2625:         expected["C"] = [expected.index[0]] + [pd.NaT, pd.NaT]
 2626: 
 2627:         mask = df.A < 1
 2628:         df.loc[mask, "C"] = df.loc[mask].index
 2629:         tm.assert_frame_equal(df, expected)
 2630: 
 2631:     def test_loc_setitem_mask_td64_series_value(self):
 2632:         # GH#23462 key list of bools, value is a Series
 2633:         td1 = Timedelta(0)
 2634:         td2 = Timedelta(28767471428571405)
 2635:         df = DataFrame({"col": Series([td1, td2])})
 2636:         df_copy = df.copy()
 2637:         ser = Series([td1])
 2638: 
 2639:         expected = df["col"].iloc[1]._value
 2640:         df.loc[[True, False]] = ser
 2641:         result = df["col"].iloc[1]._value
 2642: 
 2643:         assert expected == result
 2644:         tm.assert_frame_equal(df, df_copy)
 2645: 
 2646:     @td.skip_array_manager_invalid_test  # TODO(ArrayManager) rewrite not using .values
 2647:     def test_loc_setitem_boolean_and_column(self, float_frame):
 2648:         expected = float_frame.copy()
 2649:         mask = float_frame["A"] > 0
 2650: 
 2651:         float_frame.loc[mask, "B"] = 0
 2652: 
 2653:         values = expected.values.copy()
 2654:         values[mask.values, 1] = 0
 2655:         expected = DataFrame(values, index=expected.index, columns=expected.columns)
 2656:         tm.assert_frame_equal(float_frame, expected)
 2657: 
 2658:     def test_loc_setitem_ndframe_values_alignment(
 2659:         self, using_copy_on_write, warn_copy_on_write
 2660:     ):
 2661:         # GH#45501
 2662:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 2663:         df.loc[[False, False, True], ["a"]] = DataFrame(
 2664:             {"a": [10, 20, 30]}, index=[2, 1, 0]
 2665:         )
 2666: 
 2667:         expected = DataFrame({"a": [1, 2, 10], "b": [4, 5, 6]})
 2668:         tm.assert_frame_equal(df, expected)
 2669: 
 2670:         # same thing with Series RHS
 2671:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 2672:         df.loc[[False, False, True], ["a"]] = Series([10, 11, 12], index=[2, 1, 0])
 2673:         tm.assert_frame_equal(df, expected)
 2674: 
 2675:         # same thing but setting "a" instead of ["a"]
 2676:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 2677:         df.loc[[False, False, True], "a"] = Series([10, 11, 12], index=[2, 1, 0])
 2678:         tm.assert_frame_equal(df, expected)
 2679: 
 2680:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 2681:         df_orig = df.copy()
 2682:         ser = df["a"]
 2683:         with tm.assert_cow_warning(warn_copy_on_write):
 2684:             ser.loc[[False, False, True]] = Series([10, 11, 12], index=[2, 1, 0])
 2685:         if using_copy_on_write:
 2686:             tm.assert_frame_equal(df, df_orig)
 2687:         else:
 2688:             tm.assert_frame_equal(df, expected)
 2689: 
 2690:     def test_loc_indexer_empty_broadcast(self):
 2691:         # GH#51450
 2692:         df = DataFrame({"a": [], "b": []}, dtype=object)
 2693:         expected = df.copy()
 2694:         df.loc[np.array([], dtype=np.bool_), ["a"]] = df["a"].copy()
 2695:         tm.assert_frame_equal(df, expected)
 2696: 
 2697:     def test_loc_indexer_all_false_broadcast(self):
 2698:         # GH#51450
 2699:         df = DataFrame({"a": ["x"], "b": ["y"]}, dtype=object)
 2700:         expected = df.copy()
 2701:         df.loc[np.array([False], dtype=np.bool_), ["a"]] = df["b"].copy()
 2702:         tm.assert_frame_equal(df, expected)
 2703: 
 2704:     def test_loc_indexer_length_one(self):
 2705:         # GH#51435
 2706:         df = DataFrame({"a": ["x"], "b": ["y"]}, dtype=object)
 2707:         expected = DataFrame({"a": ["y"], "b": ["y"]}, dtype=object)
 2708:         df.loc[np.array([True], dtype=np.bool_), ["a"]] = df["b"].copy()
 2709:         tm.assert_frame_equal(df, expected)
 2710: 
 2711: 
 2712: class TestLocListlike:
 2713:     @pytest.mark.parametrize("box", [lambda x: x, np.asarray, list])
 2714:     def test_loc_getitem_list_of_labels_categoricalindex_with_na(self, box):
 2715:         # passing a list can include valid categories _or_ NA values
 2716:         ci = CategoricalIndex(["A", "B", np.nan])
 2717:         ser = Series(range(3), index=ci)
 2718: 
 2719:         result = ser.loc[box(ci)]
 2720:         tm.assert_series_equal(result, ser)
 2721: 
 2722:         result = ser[box(ci)]
 2723:         tm.assert_series_equal(result, ser)
 2724: 
 2725:         result = ser.to_frame().loc[box(ci)]
 2726:         tm.assert_frame_equal(result, ser.to_frame())
 2727: 
 2728:         ser2 = ser[:-1]
 2729:         ci2 = ci[1:]
 2730:         # but if there are no NAs present, this should raise KeyError
 2731:         msg = "not in index"
 2732:         with pytest.raises(KeyError, match=msg):
 2733:             ser2.loc[box(ci2)]
 2734: 
 2735:         with pytest.raises(KeyError, match=msg):
 2736:             ser2[box(ci2)]
 2737: 
 2738:         with pytest.raises(KeyError, match=msg):
 2739:             ser2.to_frame().loc[box(ci2)]
 2740: 
 2741:     def test_loc_getitem_series_label_list_missing_values(self):
 2742:         # gh-11428
 2743:         key = np.array(
 2744:             ["2001-01-04", "2001-01-02", "2001-01-04", "2001-01-14"], dtype="datetime64"
 2745:         )
 2746:         ser = Series([2, 5, 8, 11], date_range("2001-01-01", freq="D", periods=4))
 2747:         with pytest.raises(KeyError, match="not in index"):
 2748:             ser.loc[key]
 2749: 
 2750:     def test_loc_getitem_series_label_list_missing_integer_values(self):
 2751:         # GH: 25927
 2752:         ser = Series(
 2753:             index=np.array([9730701000001104, 10049011000001109]),
 2754:             data=np.array([999000011000001104, 999000011000001104]),
 2755:         )
 2756:         with pytest.raises(KeyError, match="not in index"):
 2757:             ser.loc[np.array([9730701000001104, 10047311000001102])]
 2758: 
 2759:     @pytest.mark.parametrize("to_period", [True, False])
 2760:     def test_loc_getitem_listlike_of_datetimelike_keys(self, to_period):
 2761:         # GH#11497
 2762: 
 2763:         idx = date_range("2011-01-01", "2011-01-02", freq="D", name="idx")
 2764:         if to_period:
 2765:             idx = idx.to_period("D")
 2766:         ser = Series([0.1, 0.2], index=idx, name="s")
 2767: 
 2768:         keys = [Timestamp("2011-01-01"), Timestamp("2011-01-02")]
 2769:         if to_period:
 2770:             keys = [x.to_period("D") for x in keys]
 2771:         result = ser.loc[keys]
 2772:         exp = Series([0.1, 0.2], index=idx, name="s")
 2773:         if not to_period:
 2774:             exp.index = exp.index._with_freq(None)
 2775:         tm.assert_series_equal(result, exp, check_index_type=True)
 2776: 
 2777:         keys = [
 2778:             Timestamp("2011-01-02"),
 2779:             Timestamp("2011-01-02"),
 2780:             Timestamp("2011-01-01"),
 2781:         ]
 2782:         if to_period:
 2783:             keys = [x.to_period("D") for x in keys]
 2784:         exp = Series(
 2785:             [0.2, 0.2, 0.1], index=Index(keys, name="idx", dtype=idx.dtype), name="s"
 2786:         )
 2787:         result = ser.loc[keys]
 2788:         tm.assert_series_equal(result, exp, check_index_type=True)
 2789: 
 2790:         keys = [
 2791:             Timestamp("2011-01-03"),
 2792:             Timestamp("2011-01-02"),
 2793:             Timestamp("2011-01-03"),
 2794:         ]
 2795:         if to_period:
 2796:             keys = [x.to_period("D") for x in keys]
 2797: 
 2798:         with pytest.raises(KeyError, match="not in index"):
 2799:             ser.loc[keys]
 2800: 
 2801:     def test_loc_named_index(self):
 2802:         # GH 42790
 2803:         df = DataFrame(
 2804:             [[1, 2], [4, 5], [7, 8]],
 2805:             index=["cobra", "viper", "sidewinder"],
 2806:             columns=["max_speed", "shield"],
 2807:         )
 2808:         expected = df.iloc[:2]
 2809:         expected.index.name = "foo"
 2810:         result = df.loc[Index(["cobra", "viper"], name="foo")]
 2811:         tm.assert_frame_equal(result, expected)
 2812: 
 2813: 
 2814: @pytest.mark.parametrize(
 2815:     "columns, column_key, expected_columns",
 2816:     [
 2817:         ([2011, 2012, 2013], [2011, 2012], [0, 1]),
 2818:         ([2011, 2012, "All"], [2011, 2012], [0, 1]),
 2819:         ([2011, 2012, "All"], [2011, "All"], [0, 2]),
 2820:     ],
 2821: )
 2822: def test_loc_getitem_label_list_integer_labels(columns, column_key, expected_columns):
 2823:     # gh-14836
 2824:     df = DataFrame(
 2825:         np.random.default_rng(2).random((3, 3)), columns=columns, index=list("ABC")
 2826:     )
 2827:     expected = df.iloc[:, expected_columns]
 2828:     result = df.loc[["A", "B", "C"], column_key]
 2829: 
 2830:     tm.assert_frame_equal(result, expected, check_column_type=True)
 2831: 
 2832: 
 2833: def test_loc_setitem_float_intindex():
 2834:     # GH 8720
 2835:     rand_data = np.random.default_rng(2).standard_normal((8, 4))
 2836:     result = DataFrame(rand_data)
 2837:     result.loc[:, 0.5] = np.nan
 2838:     expected_data = np.hstack((rand_data, np.array([np.nan] * 8).reshape(8, 1)))
 2839:     expected = DataFrame(expected_data, columns=[0.0, 1.0, 2.0, 3.0, 0.5])
 2840:     tm.assert_frame_equal(result, expected)
 2841: 
 2842:     result = DataFrame(rand_data)
 2843:     result.loc[:, 0.5] = np.nan
 2844:     tm.assert_frame_equal(result, expected)
 2845: 
 2846: 
 2847: def test_loc_axis_1_slice():
 2848:     # GH 10586
 2849:     cols = [(yr, m) for yr in [2014, 2015] for m in [7, 8, 9, 10]]
 2850:     df = DataFrame(
 2851:         np.ones((10, 8)),
 2852:         index=tuple("ABCDEFGHIJ"),
 2853:         columns=MultiIndex.from_tuples(cols),
 2854:     )
 2855:     result = df.loc(axis=1)[(2014, 9):(2015, 8)]
 2856:     expected = DataFrame(
 2857:         np.ones((10, 4)),
 2858:         index=tuple("ABCDEFGHIJ"),
 2859:         columns=MultiIndex.from_tuples([(2014, 9), (2014, 10), (2015, 7), (2015, 8)]),
 2860:     )
 2861:     tm.assert_frame_equal(result, expected)
 2862: 
 2863: 
 2864: def test_loc_set_dataframe_multiindex():
 2865:     # GH 14592
 2866:     expected = DataFrame(
 2867:         "a", index=range(2), columns=MultiIndex.from_product([range(2), range(2)])
 2868:     )
 2869:     result = expected.copy()
 2870:     result.loc[0, [(0, 1)]] = result.loc[0, [(0, 1)]]
 2871:     tm.assert_frame_equal(result, expected)
 2872: 
 2873: 
 2874: def test_loc_mixed_int_float():
 2875:     # GH#19456
 2876:     ser = Series(range(2), Index([1, 2.0], dtype=object))
 2877: 
 2878:     result = ser.loc[1]
 2879:     assert result == 0
 2880: 
 2881: 
 2882: def test_loc_with_positional_slice_raises():
 2883:     # GH#31840
 2884:     ser = Series(range(4), index=["A", "B", "C", "D"])
 2885: 
 2886:     with pytest.raises(TypeError, match="Slicing a positional slice with .loc"):
 2887:         ser.loc[:3] = 2
 2888: 
 2889: 
 2890: def test_loc_slice_disallows_positional():
 2891:     # GH#16121, GH#24612, GH#31810
 2892:     dti = date_range("2016-01-01", periods=3)
 2893:     df = DataFrame(np.random.default_rng(2).random((3, 2)), index=dti)
 2894: 
 2895:     ser = df[0]
 2896: 
 2897:     msg = (
 2898:         "cannot do slice indexing on DatetimeIndex with these "
 2899:         r"indexers \[1\] of type int"
 2900:     )
 2901: 
 2902:     for obj in [df, ser]:
 2903:         with pytest.raises(TypeError, match=msg):
 2904:             obj.loc[1:3]
 2905: 
 2906:         with pytest.raises(TypeError, match="Slicing a positional slice with .loc"):
 2907:             # GH#31840 enforce incorrect behavior
 2908:             obj.loc[1:3] = 1
 2909: 
 2910:     with pytest.raises(TypeError, match=msg):
 2911:         df.loc[1:3, 1]
 2912: 
 2913:     with pytest.raises(TypeError, match="Slicing a positional slice with .loc"):
 2914:         # GH#31840 enforce incorrect behavior
 2915:         df.loc[1:3, 1] = 2
 2916: 
 2917: 
 2918: def test_loc_datetimelike_mismatched_dtypes():
 2919:     # GH#32650 dont mix and match datetime/timedelta/period dtypes
 2920: 
 2921:     df = DataFrame(
 2922:         np.random.default_rng(2).standard_normal((5, 3)),
 2923:         columns=["a", "b", "c"],
 2924:         index=date_range("2012", freq="h", periods=5),
 2925:     )
 2926:     # create dataframe with non-unique DatetimeIndex
 2927:     df = df.iloc[[0, 2, 2, 3]].copy()
 2928: 
 2929:     dti = df.index
 2930:     tdi = pd.TimedeltaIndex(dti.asi8)  # matching i8 values
 2931: 
 2932:     msg = r"None of \[TimedeltaIndex.* are in the \[index\]"
 2933:     with pytest.raises(KeyError, match=msg):
 2934:         df.loc[tdi]
 2935: 
 2936:     with pytest.raises(KeyError, match=msg):
 2937:         df["a"].loc[tdi]
 2938: 
 2939: 
 2940: def test_loc_with_period_index_indexer():
 2941:     # GH#4125
 2942:     idx = pd.period_range("2002-01", "2003-12", freq="M")
 2943:     df = DataFrame(np.random.default_rng(2).standard_normal((24, 10)), index=idx)
 2944:     tm.assert_frame_equal(df, df.loc[idx])
 2945:     tm.assert_frame_equal(df, df.loc[list(idx)])
 2946:     tm.assert_frame_equal(df, df.loc[list(idx)])
 2947:     tm.assert_frame_equal(df.iloc[0:5], df.loc[idx[0:5]])
 2948:     tm.assert_frame_equal(df, df.loc[list(idx)])
 2949: 
 2950: 
 2951: def test_loc_setitem_multiindex_timestamp():
 2952:     # GH#13831
 2953:     vals = np.random.default_rng(2).standard_normal((8, 6))
 2954:     idx = date_range("1/1/2000", periods=8)
 2955:     cols = ["A", "B", "C", "D", "E", "F"]
 2956:     exp = DataFrame(vals, index=idx, columns=cols)
 2957:     exp.loc[exp.index[1], ("A", "B")] = np.nan
 2958:     vals[1][0:2] = np.nan
 2959:     res = DataFrame(vals, index=idx, columns=cols)
 2960:     tm.assert_frame_equal(res, exp)
 2961: 
 2962: 
 2963: def test_loc_getitem_multiindex_tuple_level():
 2964:     # GH#27591
 2965:     lev1 = ["a", "b", "c"]
 2966:     lev2 = [(0, 1), (1, 0)]
 2967:     lev3 = [0, 1]
 2968:     cols = MultiIndex.from_product([lev1, lev2, lev3], names=["x", "y", "z"])
 2969:     df = DataFrame(6, index=range(5), columns=cols)
 2970: 
 2971:     # the lev2[0] here should be treated as a single label, not as a sequence
 2972:     #  of labels
 2973:     result = df.loc[:, (lev1[0], lev2[0], lev3[0])]
 2974: 
 2975:     # TODO: i think this actually should drop levels
 2976:     expected = df.iloc[:, :1]
 2977:     tm.assert_frame_equal(result, expected)
 2978: 
 2979:     alt = df.xs((lev1[0], lev2[0], lev3[0]), level=[0, 1, 2], axis=1)
 2980:     tm.assert_frame_equal(alt, expected)
 2981: 
 2982:     # same thing on a Series
 2983:     ser = df.iloc[0]
 2984:     expected2 = ser.iloc[:1]
 2985: 
 2986:     alt2 = ser.xs((lev1[0], lev2[0], lev3[0]), level=[0, 1, 2], axis=0)
 2987:     tm.assert_series_equal(alt2, expected2)
 2988: 
 2989:     result2 = ser.loc[lev1[0], lev2[0], lev3[0]]
 2990:     assert result2 == 6
 2991: 
 2992: 
 2993: def test_loc_getitem_nullable_index_with_duplicates():
 2994:     # GH#34497
 2995:     df = DataFrame(
 2996:         data=np.array([[1, 2, 3, 4], [5, 6, 7, 8], [1, 2, np.nan, np.nan]]).T,
 2997:         columns=["a", "b", "c"],
 2998:         dtype="Int64",
 2999:     )
 3000:     df2 = df.set_index("c")
 3001:     assert df2.index.dtype == "Int64"
 3002: 
 3003:     res = df2.loc[1]
 3004:     expected = Series([1, 5], index=df2.columns, dtype="Int64", name=1)
 3005:     tm.assert_series_equal(res, expected)
 3006: 
 3007:     # pd.NA and duplicates in an object-dtype Index
 3008:     df2.index = df2.index.astype(object)
 3009:     res = df2.loc[1]
 3010:     tm.assert_series_equal(res, expected)
 3011: 
 3012: 
 3013: @pytest.mark.parametrize("value", [300, np.uint16(300), np.int16(300)])
 3014: def test_loc_setitem_uint8_upcast(value):
 3015:     # GH#26049
 3016: 
 3017:     df = DataFrame([1, 2, 3, 4], columns=["col1"], dtype="uint8")
 3018:     with tm.assert_produces_warning(FutureWarning, match="item of incompatible dtype"):
 3019:         df.loc[2, "col1"] = value  # value that can't be held in uint8
 3020: 
 3021:     if np_version_gt2 and isinstance(value, np.int16):
 3022:         # Note, result type of uint8 + int16 is int16
 3023:         # in numpy < 2, though, numpy would inspect the
 3024:         # value and see that it could fit in an uint16, resulting in a uint16
 3025:         dtype = "int16"
 3026:     else:
 3027:         dtype = "uint16"
 3028: 
 3029:     expected = DataFrame([1, 2, 300, 4], columns=["col1"], dtype=dtype)
 3030:     tm.assert_frame_equal(df, expected)
 3031: 
 3032: 
 3033: @pytest.mark.parametrize(
 3034:     "fill_val,exp_dtype",
 3035:     [
 3036:         (Timestamp("2022-01-06"), "datetime64[ns]"),
 3037:         (Timestamp("2022-01-07", tz="US/Eastern"), "datetime64[ns, US/Eastern]"),
 3038:     ],
 3039: )
 3040: def test_loc_setitem_using_datetimelike_str_as_index(fill_val, exp_dtype):
 3041:     data = ["2022-01-02", "2022-01-03", "2022-01-04", fill_val.date()]
 3042:     index = DatetimeIndex(data, tz=fill_val.tz, dtype=exp_dtype)
 3043:     df = DataFrame([10, 11, 12, 14], columns=["a"], index=index)
 3044:     # adding new row using an unexisting datetime-like str index
 3045:     df.loc["2022-01-08", "a"] = 13
 3046: 
 3047:     data.append("2022-01-08")
 3048:     expected_index = DatetimeIndex(data, dtype=exp_dtype)
 3049:     tm.assert_index_equal(df.index, expected_index, exact=True)
 3050: 
 3051: 
 3052: def test_loc_set_int_dtype():
 3053:     # GH#23326
 3054:     df = DataFrame([list("abc")])
 3055:     df.loc[:, "col1"] = 5
 3056: 
 3057:     expected = DataFrame({0: ["a"], 1: ["b"], 2: ["c"], "col1": [5]})
 3058:     tm.assert_frame_equal(df, expected)
 3059: 
 3060: 
 3061: @pytest.mark.filterwarnings(r"ignore:Period with BDay freq is deprecated:FutureWarning")
 3062: @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
 3063: def test_loc_periodindex_3_levels():
 3064:     # GH#24091
 3065:     p_index = PeriodIndex(
 3066:         ["20181101 1100", "20181101 1200", "20181102 1300", "20181102 1400"],
 3067:         name="datetime",
 3068:         freq="B",
 3069:     )
 3070:     mi_series = DataFrame(
 3071:         [["A", "B", 1.0], ["A", "C", 2.0], ["Z", "Q", 3.0], ["W", "F", 4.0]],
 3072:         index=p_index,
 3073:         columns=["ONE", "TWO", "VALUES"],
 3074:     )
 3075:     mi_series = mi_series.set_index(["ONE", "TWO"], append=True)["VALUES"]
 3076:     assert mi_series.loc[(p_index[0], "A", "B")] == 1.0
 3077: 
 3078: 
 3079: def test_loc_setitem_pyarrow_strings():
 3080:     # GH#52319
 3081:     pytest.importorskip("pyarrow")
 3082:     df = DataFrame(
 3083:         {
 3084:             "strings": Series(["A", "B", "C"], dtype="string[pyarrow]"),
 3085:             "ids": Series([True, True, False]),
 3086:         }
 3087:     )
 3088:     new_value = Series(["X", "Y"])
 3089:     df.loc[df.ids, "strings"] = new_value
 3090: 
 3091:     expected_df = DataFrame(
 3092:         {
 3093:             "strings": Series(["X", "Y", "C"], dtype="string[pyarrow]"),
 3094:             "ids": Series([True, True, False]),
 3095:         }
 3096:     )
 3097: 
 3098:     tm.assert_frame_equal(df, expected_df)
 3099: 
 3100: 
 3101: class TestLocSeries:
 3102:     @pytest.mark.parametrize("val,expected", [(2**63 - 1, 3), (2**63, 4)])
 3103:     def test_loc_uint64(self, val, expected):
 3104:         # see GH#19399
 3105:         ser = Series({2**63 - 1: 3, 2**63: 4})
 3106:         assert ser.loc[val] == expected
 3107: 
 3108:     def test_loc_getitem(self, string_series, datetime_series):
 3109:         inds = string_series.index[[3, 4, 7]]
 3110:         tm.assert_series_equal(string_series.loc[inds], string_series.reindex(inds))
 3111:         tm.assert_series_equal(string_series.iloc[5::2], string_series[5::2])
 3112: 
 3113:         # slice with indices
 3114:         d1, d2 = datetime_series.index[[5, 15]]
 3115:         result = datetime_series.loc[d1:d2]
 3116:         expected = datetime_series.truncate(d1, d2)
 3117:         tm.assert_series_equal(result, expected)
 3118: 
 3119:         # boolean
 3120:         mask = string_series > string_series.median()
 3121:         tm.assert_series_equal(string_series.loc[mask], string_series[mask])
 3122: 
 3123:         # ask for index value
 3124:         assert datetime_series.loc[d1] == datetime_series[d1]
 3125:         assert datetime_series.loc[d2] == datetime_series[d2]
 3126: 
 3127:     def test_loc_getitem_not_monotonic(self, datetime_series):
 3128:         d1, d2 = datetime_series.index[[5, 15]]
 3129: 
 3130:         ts2 = datetime_series[::2].iloc[[1, 2, 0]]
 3131: 
 3132:         msg = r"Timestamp\('2000-01-10 00:00:00'\)"
 3133:         with pytest.raises(KeyError, match=msg):
 3134:             ts2.loc[d1:d2]
 3135:         with pytest.raises(KeyError, match=msg):
 3136:             ts2.loc[d1:d2] = 0
 3137: 
 3138:     def test_loc_getitem_setitem_integer_slice_keyerrors(self):
 3139:         ser = Series(
 3140:             np.random.default_rng(2).standard_normal(10), index=list(range(0, 20, 2))
 3141:         )
 3142: 
 3143:         # this is OK
 3144:         cp = ser.copy()
 3145:         cp.iloc[4:10] = 0
 3146:         assert (cp.iloc[4:10] == 0).all()
 3147: 
 3148:         # so is this
 3149:         cp = ser.copy()
 3150:         cp.iloc[3:11] = 0
 3151:         assert (cp.iloc[3:11] == 0).values.all()
 3152: 
 3153:         result = ser.iloc[2:6]
 3154:         result2 = ser.loc[3:11]
 3155:         expected = ser.reindex([4, 6, 8, 10])
 3156: 
 3157:         tm.assert_series_equal(result, expected)
 3158:         tm.assert_series_equal(result2, expected)
 3159: 
 3160:         # non-monotonic, raise KeyError
 3161:         s2 = ser.iloc[list(range(5)) + list(range(9, 4, -1))]
 3162:         with pytest.raises(KeyError, match=r"^3$"):
 3163:             s2.loc[3:11]
 3164:         with pytest.raises(KeyError, match=r"^3$"):
 3165:             s2.loc[3:11] = 0
 3166: 
 3167:     def test_loc_getitem_iterator(self, string_series):
 3168:         idx = iter(string_series.index[:10])
 3169:         result = string_series.loc[idx]
 3170:         tm.assert_series_equal(result, string_series[:10])
 3171: 
 3172:     def test_loc_setitem_boolean(self, string_series):
 3173:         mask = string_series > string_series.median()
 3174: 
 3175:         result = string_series.copy()
 3176:         result.loc[mask] = 0
 3177:         expected = string_series
 3178:         expected[mask] = 0
 3179:         tm.assert_series_equal(result, expected)
 3180: 
 3181:     def test_loc_setitem_corner(self, string_series):
 3182:         inds = list(string_series.index[[5, 8, 12]])
 3183:         string_series.loc[inds] = 5
 3184:         msg = r"\['foo'\] not in index"
 3185:         with pytest.raises(KeyError, match=msg):
 3186:             string_series.loc[inds + ["foo"]] = 5
 3187: 
 3188:     def test_basic_setitem_with_labels(self, datetime_series):
 3189:         indices = datetime_series.index[[5, 10, 15]]
 3190: 
 3191:         cp = datetime_series.copy()
 3192:         exp = datetime_series.copy()
 3193:         cp[indices] = 0
 3194:         exp.loc[indices] = 0
 3195:         tm.assert_series_equal(cp, exp)
 3196: 
 3197:         cp = datetime_series.copy()
 3198:         exp = datetime_series.copy()
 3199:         cp[indices[0] : indices[2]] = 0
 3200:         exp.loc[indices[0] : indices[2]] = 0
 3201:         tm.assert_series_equal(cp, exp)
 3202: 
 3203:     def test_loc_setitem_listlike_of_ints(self):
 3204:         # integer indexes, be careful
 3205:         ser = Series(
 3206:             np.random.default_rng(2).standard_normal(10), index=list(range(0, 20, 2))
 3207:         )
 3208:         inds = [0, 4, 6]
 3209:         arr_inds = np.array([0, 4, 6])
 3210: 
 3211:         cp = ser.copy()
 3212:         exp = ser.copy()
 3213:         ser[inds] = 0
 3214:         ser.loc[inds] = 0
 3215:         tm.assert_series_equal(cp, exp)
 3216: 
 3217:         cp = ser.copy()
 3218:         exp = ser.copy()
 3219:         ser[arr_inds] = 0
 3220:         ser.loc[arr_inds] = 0
 3221:         tm.assert_series_equal(cp, exp)
 3222: 
 3223:         inds_notfound = [0, 4, 5, 6]
 3224:         arr_inds_notfound = np.array([0, 4, 5, 6])
 3225:         msg = r"\[5\] not in index"
 3226:         with pytest.raises(KeyError, match=msg):
 3227:             ser[inds_notfound] = 0
 3228:         with pytest.raises(Exception, match=msg):
 3229:             ser[arr_inds_notfound] = 0
 3230: 
 3231:     def test_loc_setitem_dt64tz_values(self):
 3232:         # GH#12089
 3233:         ser = Series(
 3234:             date_range("2011-01-01", periods=3, tz="US/Eastern"),
 3235:             index=["a", "b", "c"],
 3236:         )
 3237:         s2 = ser.copy()
 3238:         expected = Timestamp("2011-01-03", tz="US/Eastern")
 3239:         s2.loc["a"] = expected
 3240:         result = s2.loc["a"]
 3241:         assert result == expected
 3242: 
 3243:         s2 = ser.copy()
 3244:         s2.iloc[0] = expected
 3245:         result = s2.iloc[0]
 3246:         assert result == expected
 3247: 
 3248:         s2 = ser.copy()
 3249:         s2["a"] = expected
 3250:         result = s2["a"]
 3251:         assert result == expected
 3252: 
 3253:     @pytest.mark.parametrize("array_fn", [np.array, pd.array, list, tuple])
 3254:     @pytest.mark.parametrize("size", [0, 4, 5, 6])
 3255:     def test_loc_iloc_setitem_with_listlike(self, size, array_fn):
 3256:         # GH37748
 3257:         # testing insertion, in a Series of size N (here 5), of a listlike object
 3258:         # of size  0, N-1, N, N+1
 3259: 
 3260:         arr = array_fn([0] * size)
 3261:         expected = Series([arr, 0, 0, 0, 0], index=list("abcde"), dtype=object)
 3262: 
 3263:         ser = Series(0, index=list("abcde"), dtype=object)
 3264:         ser.loc["a"] = arr
 3265:         tm.assert_series_equal(ser, expected)
 3266: 
 3267:         ser = Series(0, index=list("abcde"), dtype=object)
 3268:         ser.iloc[0] = arr
 3269:         tm.assert_series_equal(ser, expected)
 3270: 
 3271:     @pytest.mark.parametrize("indexer", [IndexSlice["A", :], ("A", slice(None))])
 3272:     def test_loc_series_getitem_too_many_dimensions(self, indexer):
 3273:         # GH#35349
 3274:         ser = Series(
 3275:             index=MultiIndex.from_tuples([("A", "0"), ("A", "1"), ("B", "0")]),
 3276:             data=[21, 22, 23],
 3277:         )
 3278:         msg = "Too many indexers"
 3279:         with pytest.raises(IndexingError, match=msg):
 3280:             ser.loc[indexer, :]
 3281: 
 3282:         with pytest.raises(IndexingError, match=msg):
 3283:             ser.loc[indexer, :] = 1
 3284: 
 3285:     def test_loc_setitem(self, string_series):
 3286:         inds = string_series.index[[3, 4, 7]]
 3287: 
 3288:         result = string_series.copy()
 3289:         result.loc[inds] = 5
 3290: 
 3291:         expected = string_series.copy()
 3292:         expected.iloc[[3, 4, 7]] = 5
 3293:         tm.assert_series_equal(result, expected)
 3294: 
 3295:         result.iloc[5:10] = 10
 3296:         expected[5:10] = 10
 3297:         tm.assert_series_equal(result, expected)
 3298: 
 3299:         # set slice with indices
 3300:         d1, d2 = string_series.index[[5, 15]]
 3301:         result.loc[d1:d2] = 6
 3302:         expected[5:16] = 6  # because it's inclusive
 3303:         tm.assert_series_equal(result, expected)
 3304: 
 3305:         # set index value
 3306:         string_series.loc[d1] = 4
 3307:         string_series.loc[d2] = 6
 3308:         assert string_series[d1] == 4
 3309:         assert string_series[d2] == 6
 3310: 
 3311:     @pytest.mark.parametrize("dtype", ["object", "string"])
 3312:     def test_loc_assign_dict_to_row(self, dtype):
 3313:         # GH41044
 3314:         df = DataFrame({"A": ["abc", "def"], "B": ["ghi", "jkl"]}, dtype=dtype)
 3315:         df.loc[0, :] = {"A": "newA", "B": "newB"}
 3316: 
 3317:         expected = DataFrame({"A": ["newA", "def"], "B": ["newB", "jkl"]}, dtype=dtype)
 3318: 
 3319:         tm.assert_frame_equal(df, expected)
 3320: 
 3321:     @td.skip_array_manager_invalid_test
 3322:     def test_loc_setitem_dict_timedelta_multiple_set(self):
 3323:         # GH 16309
 3324:         result = DataFrame(columns=["time", "value"])
 3325:         result.loc[1] = {"time": Timedelta(6, unit="s"), "value": "foo"}
 3326:         result.loc[1] = {"time": Timedelta(6, unit="s"), "value": "foo"}
 3327:         expected = DataFrame(
 3328:             [[Timedelta(6, unit="s"), "foo"]], columns=["time", "value"], index=[1]
 3329:         )
 3330:         tm.assert_frame_equal(result, expected)
 3331: 
 3332:     def test_loc_set_multiple_items_in_multiple_new_columns(self):
 3333:         # GH 25594
 3334:         df = DataFrame(index=[1, 2], columns=["a"])
 3335:         df.loc[1, ["b", "c"]] = [6, 7]
 3336: 
 3337:         expected = DataFrame(
 3338:             {
 3339:                 "a": Series([np.nan, np.nan], dtype="object"),
 3340:                 "b": [6, np.nan],
 3341:                 "c": [7, np.nan],
 3342:             },
 3343:             index=[1, 2],
 3344:         )
 3345: 
 3346:         tm.assert_frame_equal(df, expected)
 3347: 
 3348:     def test_getitem_loc_str_periodindex(self):
 3349:         # GH#33964
 3350:         msg = "Period with BDay freq is deprecated"
 3351:         with tm.assert_produces_warning(FutureWarning, match=msg):
 3352:             index = pd.period_range(start="2000", periods=20, freq="B")
 3353:             series = Series(range(20), index=index)
 3354:             assert series.loc["2000-01-14"] == 9
 3355: 
 3356:     def test_loc_nonunique_masked_index(self):
 3357:         # GH 57027
 3358:         ids = list(range(11))
 3359:         index = Index(ids * 1000, dtype="Int64")
 3360:         df = DataFrame({"val": np.arange(len(index), dtype=np.intp)}, index=index)
 3361:         result = df.loc[ids]
 3362:         expected = DataFrame(
 3363:             {"val": index.argsort(kind="stable").astype(np.intp)},
 3364:             index=Index(np.array(ids).repeat(1000), dtype="Int64"),
 3365:         )
 3366:         tm.assert_frame_equal(result, expected)
