    1: from string import ascii_letters
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.errors import (
    7:     SettingWithCopyError,
    8:     SettingWithCopyWarning,
    9: )
   10: import pandas.util._test_decorators as td
   11: 
   12: import pandas as pd
   13: from pandas import (
   14:     DataFrame,
   15:     Index,
   16:     Series,
   17:     Timestamp,
   18:     date_range,
   19:     option_context,
   20: )
   21: import pandas._testing as tm
   22: 
   23: msg = "A value is trying to be set on a copy of a slice from a DataFrame"
   24: 
   25: 
   26: def random_text(nobs=100):
   27:     # Construct a DataFrame where each row is a random slice from 'letters'
   28:     idxs = np.random.default_rng(2).integers(len(ascii_letters), size=(nobs, 2))
   29:     idxs.sort(axis=1)
   30:     strings = [ascii_letters[x[0] : x[1]] for x in idxs]
   31: 
   32:     return DataFrame(strings, columns=["letters"])
   33: 
   34: 
   35: class TestCaching:
   36:     def test_slice_consolidate_invalidate_item_cache(self, using_copy_on_write):
   37:         # this is chained assignment, but will 'work'
   38:         with option_context("chained_assignment", None):
   39:             # #3970
   40:             df = DataFrame({"aa": np.arange(5), "bb": [2.2] * 5})
   41: 
   42:             # Creates a second float block
   43:             df["cc"] = 0.0
   44: 
   45:             # caches a reference to the 'bb' series
   46:             df["bb"]
   47: 
   48:             # Assignment to wrong series
   49:             with tm.raises_chained_assignment_error():
   50:                 df["bb"].iloc[0] = 0.17
   51:             df._clear_item_cache()
   52:             if not using_copy_on_write:
   53:                 tm.assert_almost_equal(df["bb"][0], 0.17)
   54:             else:
   55:                 # with ArrayManager, parent is not mutated with chained assignment
   56:                 tm.assert_almost_equal(df["bb"][0], 2.2)
   57: 
   58:     @pytest.mark.parametrize("do_ref", [True, False])
   59:     def test_setitem_cache_updating(self, do_ref):
   60:         # GH 5424
   61:         cont = ["one", "two", "three", "four", "five", "six", "seven"]
   62: 
   63:         df = DataFrame({"a": cont, "b": cont[3:] + cont[:3], "c": np.arange(7)})
   64: 
   65:         # ref the cache
   66:         if do_ref:
   67:             df.loc[0, "c"]
   68: 
   69:         # set it
   70:         df.loc[7, "c"] = 1
   71: 
   72:         assert df.loc[0, "c"] == 0.0
   73:         assert df.loc[7, "c"] == 1.0
   74: 
   75:     def test_setitem_cache_updating_slices(
   76:         self, using_copy_on_write, warn_copy_on_write
   77:     ):
   78:         # GH 7084
   79:         # not updating cache on series setting with slices
   80:         expected = DataFrame(
   81:             {"A": [600, 600, 600]}, index=date_range("5/7/2014", "5/9/2014")
   82:         )
   83:         out = DataFrame({"A": [0, 0, 0]}, index=date_range("5/7/2014", "5/9/2014"))
   84:         df = DataFrame({"C": ["A", "A", "A"], "D": [100, 200, 300]})
   85: 
   86:         # loop through df to update out
   87:         six = Timestamp("5/7/2014")
   88:         eix = Timestamp("5/9/2014")
   89:         for ix, row in df.iterrows():
   90:             out.loc[six:eix, row["C"]] = out.loc[six:eix, row["C"]] + row["D"]
   91: 
   92:         tm.assert_frame_equal(out, expected)
   93:         tm.assert_series_equal(out["A"], expected["A"])
   94: 
   95:         # try via a chain indexing
   96:         # this actually works
   97:         out = DataFrame({"A": [0, 0, 0]}, index=date_range("5/7/2014", "5/9/2014"))
   98:         out_original = out.copy()
   99:         for ix, row in df.iterrows():
  100:             v = out[row["C"]][six:eix] + row["D"]
  101:             with tm.raises_chained_assignment_error(
  102:                 (ix == 0) or warn_copy_on_write or using_copy_on_write
  103:             ):
  104:                 out[row["C"]][six:eix] = v
  105: 
  106:         if not using_copy_on_write:
  107:             tm.assert_frame_equal(out, expected)
  108:             tm.assert_series_equal(out["A"], expected["A"])
  109:         else:
  110:             tm.assert_frame_equal(out, out_original)
  111:             tm.assert_series_equal(out["A"], out_original["A"])
  112: 
  113:         out = DataFrame({"A": [0, 0, 0]}, index=date_range("5/7/2014", "5/9/2014"))
  114:         for ix, row in df.iterrows():
  115:             out.loc[six:eix, row["C"]] += row["D"]
  116: 
  117:         tm.assert_frame_equal(out, expected)
  118:         tm.assert_series_equal(out["A"], expected["A"])
  119: 
  120:     def test_altering_series_clears_parent_cache(
  121:         self, using_copy_on_write, warn_copy_on_write
  122:     ):
  123:         # GH #33675
  124:         df = DataFrame([[1, 2], [3, 4]], index=["a", "b"], columns=["A", "B"])
  125:         ser = df["A"]
  126: 
  127:         if using_copy_on_write or warn_copy_on_write:
  128:             assert "A" not in df._item_cache
  129:         else:
  130:             assert "A" in df._item_cache
  131: 
  132:         # Adding a new entry to ser swaps in a new array, so "A" needs to
  133:         #  be removed from df._item_cache
  134:         ser["c"] = 5
  135:         assert len(ser) == 3
  136:         assert "A" not in df._item_cache
  137:         assert df["A"] is not ser
  138:         assert len(df["A"]) == 2
  139: 
  140: 
  141: class TestChaining:
  142:     def test_setitem_chained_setfault(self, using_copy_on_write):
  143:         # GH6026
  144:         data = ["right", "left", "left", "left", "right", "left", "timeout"]
  145:         mdata = ["right", "left", "left", "left", "right", "left", "none"]
  146: 
  147:         df = DataFrame({"response": np.array(data)})
  148:         mask = df.response == "timeout"
  149:         with tm.raises_chained_assignment_error():
  150:             df.response[mask] = "none"
  151:         if using_copy_on_write:
  152:             tm.assert_frame_equal(df, DataFrame({"response": data}))
  153:         else:
  154:             tm.assert_frame_equal(df, DataFrame({"response": mdata}))
  155: 
  156:         recarray = np.rec.fromarrays([data], names=["response"])
  157:         df = DataFrame(recarray)
  158:         mask = df.response == "timeout"
  159:         with tm.raises_chained_assignment_error():
  160:             df.response[mask] = "none"
  161:         if using_copy_on_write:
  162:             tm.assert_frame_equal(df, DataFrame({"response": data}))
  163:         else:
  164:             tm.assert_frame_equal(df, DataFrame({"response": mdata}))
  165: 
  166:         df = DataFrame({"response": data, "response1": data})
  167:         df_original = df.copy()
  168:         mask = df.response == "timeout"
  169:         with tm.raises_chained_assignment_error():
  170:             df.response[mask] = "none"
  171:         if using_copy_on_write:
  172:             tm.assert_frame_equal(df, df_original)
  173:         else:
  174:             tm.assert_frame_equal(df, DataFrame({"response": mdata, "response1": data}))
  175: 
  176:         # GH 6056
  177:         expected = DataFrame({"A": [np.nan, "bar", "bah", "foo", "bar"]})
  178:         df = DataFrame({"A": np.array(["foo", "bar", "bah", "foo", "bar"])})
  179:         with tm.raises_chained_assignment_error():
  180:             df["A"].iloc[0] = np.nan
  181:         if using_copy_on_write:
  182:             expected = DataFrame({"A": ["foo", "bar", "bah", "foo", "bar"]})
  183:         else:
  184:             expected = DataFrame({"A": [np.nan, "bar", "bah", "foo", "bar"]})
  185:         result = df.head()
  186:         tm.assert_frame_equal(result, expected)
  187: 
  188:         df = DataFrame({"A": np.array(["foo", "bar", "bah", "foo", "bar"])})
  189:         with tm.raises_chained_assignment_error():
  190:             df.A.iloc[0] = np.nan
  191:         result = df.head()
  192:         tm.assert_frame_equal(result, expected)
  193: 
  194:     @pytest.mark.arm_slow
  195:     def test_detect_chained_assignment(self, using_copy_on_write):
  196:         with option_context("chained_assignment", "raise"):
  197:             # work with the chain
  198:             expected = DataFrame([[-5, 1], [-6, 3]], columns=list("AB"))
  199:             df = DataFrame(
  200:                 np.arange(4).reshape(2, 2), columns=list("AB"), dtype="int64"
  201:             )
  202:             df_original = df.copy()
  203:             assert df._is_copy is None
  204: 
  205:             with tm.raises_chained_assignment_error():
  206:                 df["A"][0] = -5
  207:             with tm.raises_chained_assignment_error():
  208:                 df["A"][1] = -6
  209:             if using_copy_on_write:
  210:                 tm.assert_frame_equal(df, df_original)
  211:             else:
  212:                 tm.assert_frame_equal(df, expected)
  213: 
  214:     @pytest.mark.arm_slow
  215:     def test_detect_chained_assignment_raises(
  216:         self, using_array_manager, using_copy_on_write, warn_copy_on_write
  217:     ):
  218:         # test with the chaining
  219:         df = DataFrame(
  220:             {
  221:                 "A": Series(range(2), dtype="int64"),
  222:                 "B": np.array(np.arange(2, 4), dtype=np.float64),
  223:             }
  224:         )
  225:         df_original = df.copy()
  226:         assert df._is_copy is None
  227: 
  228:         if using_copy_on_write:
  229:             with tm.raises_chained_assignment_error():
  230:                 df["A"][0] = -5
  231:             with tm.raises_chained_assignment_error():
  232:                 df["A"][1] = -6
  233:             tm.assert_frame_equal(df, df_original)
  234:         elif warn_copy_on_write:
  235:             with tm.raises_chained_assignment_error():
  236:                 df["A"][0] = -5
  237:             with tm.raises_chained_assignment_error():
  238:                 df["A"][1] = np.nan
  239:         elif not using_array_manager:
  240:             with pytest.raises(SettingWithCopyError, match=msg):
  241:                 with tm.raises_chained_assignment_error():
  242:                     df["A"][0] = -5
  243: 
  244:             with pytest.raises(SettingWithCopyError, match=msg):
  245:                 with tm.raises_chained_assignment_error():
  246:                     df["A"][1] = np.nan
  247: 
  248:             assert df["A"]._is_copy is None
  249:         else:
  250:             # INFO(ArrayManager) for ArrayManager it doesn't matter that it's
  251:             # a mixed dataframe
  252:             df["A"][0] = -5
  253:             df["A"][1] = -6
  254:             expected = DataFrame([[-5, 2], [-6, 3]], columns=list("AB"))
  255:             expected["B"] = expected["B"].astype("float64")
  256:             tm.assert_frame_equal(df, expected)
  257: 
  258:     @pytest.mark.arm_slow
  259:     def test_detect_chained_assignment_fails(
  260:         self, using_copy_on_write, warn_copy_on_write
  261:     ):
  262:         # Using a copy (the chain), fails
  263:         df = DataFrame(
  264:             {
  265:                 "A": Series(range(2), dtype="int64"),
  266:                 "B": np.array(np.arange(2, 4), dtype=np.float64),
  267:             }
  268:         )
  269: 
  270:         if using_copy_on_write or warn_copy_on_write:
  271:             with tm.raises_chained_assignment_error():
  272:                 df.loc[0]["A"] = -5
  273:         else:
  274:             with pytest.raises(SettingWithCopyError, match=msg):
  275:                 df.loc[0]["A"] = -5
  276: 
  277:     @pytest.mark.arm_slow
  278:     def test_detect_chained_assignment_doc_example(
  279:         self, using_copy_on_write, warn_copy_on_write
  280:     ):
  281:         # Doc example
  282:         df = DataFrame(
  283:             {
  284:                 "a": ["one", "one", "two", "three", "two", "one", "six"],
  285:                 "c": Series(range(7), dtype="int64"),
  286:             }
  287:         )
  288:         assert df._is_copy is None
  289: 
  290:         indexer = df.a.str.startswith("o")
  291:         if using_copy_on_write or warn_copy_on_write:
  292:             with tm.raises_chained_assignment_error():
  293:                 df[indexer]["c"] = 42
  294:         else:
  295:             with pytest.raises(SettingWithCopyError, match=msg):
  296:                 df[indexer]["c"] = 42
  297: 
  298:     @pytest.mark.arm_slow
  299:     def test_detect_chained_assignment_object_dtype(
  300:         self, using_array_manager, using_copy_on_write, warn_copy_on_write
  301:     ):
  302:         expected = DataFrame({"A": [111, "bbb", "ccc"], "B": [1, 2, 3]})
  303:         df = DataFrame(
  304:             {"A": Series(["aaa", "bbb", "ccc"], dtype=object), "B": [1, 2, 3]}
  305:         )
  306:         df_original = df.copy()
  307: 
  308:         if not using_copy_on_write and not warn_copy_on_write:
  309:             with pytest.raises(SettingWithCopyError, match=msg):
  310:                 df.loc[0]["A"] = 111
  311: 
  312:         if using_copy_on_write:
  313:             with tm.raises_chained_assignment_error():
  314:                 df["A"][0] = 111
  315:             tm.assert_frame_equal(df, df_original)
  316:         elif warn_copy_on_write:
  317:             with tm.raises_chained_assignment_error():
  318:                 df["A"][0] = 111
  319:             tm.assert_frame_equal(df, expected)
  320:         elif not using_array_manager:
  321:             with pytest.raises(SettingWithCopyError, match=msg):
  322:                 with tm.raises_chained_assignment_error():
  323:                     df["A"][0] = 111
  324: 
  325:             df.loc[0, "A"] = 111
  326:             tm.assert_frame_equal(df, expected)
  327:         else:
  328:             # INFO(ArrayManager) for ArrayManager it doesn't matter that it's
  329:             # a mixed dataframe
  330:             df["A"][0] = 111
  331:             tm.assert_frame_equal(df, expected)
  332: 
  333:     @pytest.mark.arm_slow
  334:     def test_detect_chained_assignment_is_copy_pickle(self):
  335:         # gh-5475: Make sure that is_copy is picked up reconstruction
  336:         df = DataFrame({"A": [1, 2]})
  337:         assert df._is_copy is None
  338: 
  339:         with tm.ensure_clean("__tmp__pickle") as path:
  340:             df.to_pickle(path)
  341:             df2 = pd.read_pickle(path)
  342:             df2["B"] = df2["A"]
  343:             df2["B"] = df2["A"]
  344: 
  345:     @pytest.mark.arm_slow
  346:     def test_detect_chained_assignment_setting_entire_column(self):
  347:         # gh-5597: a spurious raise as we are setting the entire column here
  348: 
  349:         df = random_text(100000)
  350: 
  351:         # Always a copy
  352:         x = df.iloc[[0, 1, 2]]
  353:         assert x._is_copy is not None
  354: 
  355:         x = df.iloc[[0, 1, 2, 4]]
  356:         assert x._is_copy is not None
  357: 
  358:         # Explicitly copy
  359:         indexer = df.letters.apply(lambda x: len(x) > 10)
  360:         df = df.loc[indexer].copy()
  361: 
  362:         assert df._is_copy is None
  363:         df["letters"] = df["letters"].apply(str.lower)
  364: 
  365:     @pytest.mark.arm_slow
  366:     def test_detect_chained_assignment_implicit_take(self):
  367:         # Implicitly take
  368:         df = random_text(100000)
  369:         indexer = df.letters.apply(lambda x: len(x) > 10)
  370:         df = df.loc[indexer]
  371: 
  372:         assert df._is_copy is not None
  373:         df["letters"] = df["letters"].apply(str.lower)
  374: 
  375:     @pytest.mark.arm_slow
  376:     def test_detect_chained_assignment_implicit_take2(
  377:         self, using_copy_on_write, warn_copy_on_write
  378:     ):
  379:         if using_copy_on_write or warn_copy_on_write:
  380:             pytest.skip("_is_copy is not always set for CoW")
  381:         # Implicitly take 2
  382:         df = random_text(100000)
  383:         indexer = df.letters.apply(lambda x: len(x) > 10)
  384: 
  385:         df = df.loc[indexer]
  386:         assert df._is_copy is not None
  387:         df.loc[:, "letters"] = df["letters"].apply(str.lower)
  388: 
  389:         # with the enforcement of #45333 in 2.0, the .loc[:, letters] setting
  390:         #  is inplace, so df._is_copy remains non-None.
  391:         assert df._is_copy is not None
  392: 
  393:         df["letters"] = df["letters"].apply(str.lower)
  394:         assert df._is_copy is None
  395: 
  396:     @pytest.mark.arm_slow
  397:     def test_detect_chained_assignment_str(self):
  398:         df = random_text(100000)
  399:         indexer = df.letters.apply(lambda x: len(x) > 10)
  400:         df.loc[indexer, "letters"] = df.loc[indexer, "letters"].apply(str.lower)
  401: 
  402:     @pytest.mark.arm_slow
  403:     def test_detect_chained_assignment_is_copy(self):
  404:         # an identical take, so no copy
  405:         df = DataFrame({"a": [1]}).dropna()
  406:         assert df._is_copy is None
  407:         df["a"] += 1
  408: 
  409:     @pytest.mark.arm_slow
  410:     def test_detect_chained_assignment_sorting(self):
  411:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))
  412:         ser = df.iloc[:, 0].sort_values()
  413: 
  414:         tm.assert_series_equal(ser, df.iloc[:, 0].sort_values())
  415:         tm.assert_series_equal(ser, df[0].sort_values())
  416: 
  417:     @pytest.mark.arm_slow
  418:     def test_detect_chained_assignment_false_positives(self):
  419:         # see gh-6025: false positives
  420:         df = DataFrame({"column1": ["a", "a", "a"], "column2": [4, 8, 9]})
  421:         str(df)
  422: 
  423:         df["column1"] = df["column1"] + "b"
  424:         str(df)
  425: 
  426:         df = df[df["column2"] != 8]
  427:         str(df)
  428: 
  429:         df["column1"] = df["column1"] + "c"
  430:         str(df)
  431: 
  432:     @pytest.mark.arm_slow
  433:     def test_detect_chained_assignment_undefined_column(
  434:         self, using_copy_on_write, warn_copy_on_write
  435:     ):
  436:         # from SO:
  437:         # https://stackoverflow.com/questions/24054495/potential-bug-setting-value-for-undefined-column-using-iloc
  438:         df = DataFrame(np.arange(0, 9), columns=["count"])
  439:         df["group"] = "b"
  440:         df_original = df.copy()
  441: 
  442:         if using_copy_on_write:
  443:             with tm.raises_chained_assignment_error():
  444:                 df.iloc[0:5]["group"] = "a"
  445:             tm.assert_frame_equal(df, df_original)
  446:         elif warn_copy_on_write:
  447:             with tm.raises_chained_assignment_error():
  448:                 df.iloc[0:5]["group"] = "a"
  449:         else:
  450:             with pytest.raises(SettingWithCopyError, match=msg):
  451:                 with tm.raises_chained_assignment_error():
  452:                     df.iloc[0:5]["group"] = "a"
  453: 
  454:     @pytest.mark.arm_slow
  455:     def test_detect_chained_assignment_changing_dtype(
  456:         self, using_array_manager, using_copy_on_write, warn_copy_on_write
  457:     ):
  458:         # Mixed type setting but same dtype & changing dtype
  459:         df = DataFrame(
  460:             {
  461:                 "A": date_range("20130101", periods=5),
  462:                 "B": np.random.default_rng(2).standard_normal(5),
  463:                 "C": np.arange(5, dtype="int64"),
  464:                 "D": ["a", "b", "c", "d", "e"],
  465:             }
  466:         )
  467:         df_original = df.copy()
  468: 
  469:         if using_copy_on_write or warn_copy_on_write:
  470:             with tm.raises_chained_assignment_error():
  471:                 df.loc[2]["D"] = "foo"
  472:             with tm.raises_chained_assignment_error():
  473:                 df.loc[2]["C"] = "foo"
  474:             tm.assert_frame_equal(df, df_original)
  475:             with tm.raises_chained_assignment_error(extra_warnings=(FutureWarning,)):
  476:                 df["C"][2] = "foo"
  477:             if using_copy_on_write:
  478:                 tm.assert_frame_equal(df, df_original)
  479:             else:
  480:                 assert df.loc[2, "C"] == "foo"
  481:         else:
  482:             with pytest.raises(SettingWithCopyError, match=msg):
  483:                 df.loc[2]["D"] = "foo"
  484: 
  485:             with pytest.raises(SettingWithCopyError, match=msg):
  486:                 df.loc[2]["C"] = "foo"
  487: 
  488:             if not using_array_manager:
  489:                 with pytest.raises(SettingWithCopyError, match=msg):
  490:                     with tm.raises_chained_assignment_error():
  491:                         df["C"][2] = "foo"
  492:             else:
  493:                 # INFO(ArrayManager) for ArrayManager it doesn't matter if it's
  494:                 # changing the dtype or not
  495:                 df["C"][2] = "foo"
  496:                 assert df.loc[2, "C"] == "foo"
  497: 
  498:     def test_setting_with_copy_bug(self, using_copy_on_write, warn_copy_on_write):
  499:         # operating on a copy
  500:         df = DataFrame(
  501:             {"a": list(range(4)), "b": list("ab.."), "c": ["a", "b", np.nan, "d"]}
  502:         )
  503:         df_original = df.copy()
  504:         mask = pd.isna(df.c)
  505: 
  506:         if using_copy_on_write:
  507:             with tm.raises_chained_assignment_error():
  508:                 df[["c"]][mask] = df[["b"]][mask]
  509:             tm.assert_frame_equal(df, df_original)
  510:         elif warn_copy_on_write:
  511:             with tm.raises_chained_assignment_error():
  512:                 df[["c"]][mask] = df[["b"]][mask]
  513:         else:
  514:             with pytest.raises(SettingWithCopyError, match=msg):
  515:                 df[["c"]][mask] = df[["b"]][mask]
  516: 
  517:     def test_setting_with_copy_bug_no_warning(self):
  518:         # invalid warning as we are returning a new object
  519:         # GH 8730
  520:         df1 = DataFrame({"x": Series(["a", "b", "c"]), "y": Series(["d", "e", "f"])})
  521:         df2 = df1[["x"]]
  522: 
  523:         # this should not raise
  524:         df2["y"] = ["g", "h", "i"]
  525: 
  526:     def test_detect_chained_assignment_warnings_errors(
  527:         self, using_copy_on_write, warn_copy_on_write
  528:     ):
  529:         df = DataFrame({"A": ["aaa", "bbb", "ccc"], "B": [1, 2, 3]})
  530:         if using_copy_on_write or warn_copy_on_write:
  531:             with tm.raises_chained_assignment_error():
  532:                 df.loc[0]["A"] = 111
  533:             return
  534: 
  535:         with option_context("chained_assignment", "warn"):
  536:             with tm.assert_produces_warning(SettingWithCopyWarning):
  537:                 df.loc[0]["A"] = 111
  538: 
  539:         with option_context("chained_assignment", "raise"):
  540:             with pytest.raises(SettingWithCopyError, match=msg):
  541:                 df.loc[0]["A"] = 111
  542: 
  543:     @pytest.mark.parametrize("rhs", [3, DataFrame({0: [1, 2, 3, 4]})])
  544:     def test_detect_chained_assignment_warning_stacklevel(
  545:         self, rhs, using_copy_on_write, warn_copy_on_write
  546:     ):
  547:         # GH#42570
  548:         df = DataFrame(np.arange(25).reshape(5, 5))
  549:         df_original = df.copy()
  550:         chained = df.loc[:3]
  551:         with option_context("chained_assignment", "warn"):
  552:             if not using_copy_on_write and not warn_copy_on_write:
  553:                 with tm.assert_produces_warning(SettingWithCopyWarning) as t:
  554:                     chained[2] = rhs
  555:                     assert t[0].filename == __file__
  556:             else:
  557:                 # INFO(CoW) no warning, and original dataframe not changed
  558:                 chained[2] = rhs
  559:                 tm.assert_frame_equal(df, df_original)
  560: 
  561:     # TODO(ArrayManager) fast_xs with array-like scalars is not yet working
  562:     @td.skip_array_manager_not_yet_implemented
  563:     def test_chained_getitem_with_lists(self):
  564:         # GH6394
  565:         # Regression in chained getitem indexing with embedded list-like from
  566:         # 0.12
  567: 
  568:         df = DataFrame({"A": 5 * [np.zeros(3)], "B": 5 * [np.ones(3)]})
  569:         expected = df["A"].iloc[2]
  570:         result = df.loc[2, "A"]
  571:         tm.assert_numpy_array_equal(result, expected)
  572:         result2 = df.iloc[2]["A"]
  573:         tm.assert_numpy_array_equal(result2, expected)
  574:         result3 = df["A"].loc[2]
  575:         tm.assert_numpy_array_equal(result3, expected)
  576:         result4 = df["A"].iloc[2]
  577:         tm.assert_numpy_array_equal(result4, expected)
  578: 
  579:     def test_cache_updating(self):
  580:         # GH 4939, make sure to update the cache on setitem
  581: 
  582:         df = DataFrame(
  583:             np.zeros((10, 4)),
  584:             columns=Index(list("ABCD"), dtype=object),
  585:         )
  586:         df["A"]  # cache series
  587:         df.loc["Hello Friend"] = df.iloc[0]
  588:         assert "Hello Friend" in df["A"].index
  589:         assert "Hello Friend" in df["B"].index
  590: 
  591:     def test_cache_updating2(self, using_copy_on_write):
  592:         # 10264
  593:         df = DataFrame(
  594:             np.zeros((5, 5), dtype="int64"),
  595:             columns=["a", "b", "c", "d", "e"],
  596:             index=range(5),
  597:         )
  598:         df["f"] = 0
  599:         df_orig = df.copy()
  600:         if using_copy_on_write:
  601:             with pytest.raises(ValueError, match="read-only"):
  602:                 df.f.values[3] = 1
  603:             tm.assert_frame_equal(df, df_orig)
  604:             return
  605: 
  606:         df.f.values[3] = 1
  607: 
  608:         df.f.values[3] = 2
  609:         expected = DataFrame(
  610:             np.zeros((5, 6), dtype="int64"),
  611:             columns=["a", "b", "c", "d", "e", "f"],
  612:             index=range(5),
  613:         )
  614:         expected.at[3, "f"] = 2
  615:         tm.assert_frame_equal(df, expected)
  616:         expected = Series([0, 0, 0, 2, 0], name="f")
  617:         tm.assert_series_equal(df.f, expected)
  618: 
  619:     def test_iloc_setitem_chained_assignment(self, using_copy_on_write):
  620:         # GH#3970
  621:         with option_context("chained_assignment", None):
  622:             df = DataFrame({"aa": range(5), "bb": [2.2] * 5})
  623:             df["cc"] = 0.0
  624: 
  625:             ck = [True] * len(df)
  626: 
  627:             with tm.raises_chained_assignment_error():
  628:                 df["bb"].iloc[0] = 0.13
  629: 
  630:             # GH#3970 this lookup used to break the chained setting to 0.15
  631:             df.iloc[ck]
  632: 
  633:             with tm.raises_chained_assignment_error():
  634:                 df["bb"].iloc[0] = 0.15
  635: 
  636:             if not using_copy_on_write:
  637:                 assert df["bb"].iloc[0] == 0.15
  638:             else:
  639:                 assert df["bb"].iloc[0] == 2.2
  640: 
  641:     def test_getitem_loc_assignment_slice_state(self):
  642:         # GH 13569
  643:         df = DataFrame({"a": [10, 20, 30]})
  644:         with tm.raises_chained_assignment_error():
  645:             df["a"].loc[4] = 40
  646:         tm.assert_frame_equal(df, DataFrame({"a": [10, 20, 30]}))
  647:         tm.assert_series_equal(df["a"], Series([10, 20, 30], name="a"))
