    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: from pandas import (
    7:     DataFrame,
    8:     DatetimeIndex,
    9:     MultiIndex,
   10:     date_range,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: class TestMultiIndexPartial:
   16:     def test_getitem_partial_int(self):
   17:         # GH 12416
   18:         # with single item
   19:         l1 = [10, 20]
   20:         l2 = ["a", "b"]
   21:         df = DataFrame(index=range(2), columns=MultiIndex.from_product([l1, l2]))
   22:         expected = DataFrame(index=range(2), columns=l2)
   23:         result = df[20]
   24:         tm.assert_frame_equal(result, expected)
   25: 
   26:         # with list
   27:         expected = DataFrame(
   28:             index=range(2), columns=MultiIndex.from_product([l1[1:], l2])
   29:         )
   30:         result = df[[20]]
   31:         tm.assert_frame_equal(result, expected)
   32: 
   33:         # missing item:
   34:         with pytest.raises(KeyError, match="1"):
   35:             df[1]
   36:         with pytest.raises(KeyError, match=r"'\[1\] not in index'"):
   37:             df[[1]]
   38: 
   39:     def test_series_slice_partial(self):
   40:         pass
   41: 
   42:     def test_xs_partial(
   43:         self,
   44:         multiindex_dataframe_random_data,
   45:         multiindex_year_month_day_dataframe_random_data,
   46:     ):
   47:         frame = multiindex_dataframe_random_data
   48:         ymd = multiindex_year_month_day_dataframe_random_data
   49:         result = frame.xs("foo")
   50:         result2 = frame.loc["foo"]
   51:         expected = frame.T["foo"].T
   52:         tm.assert_frame_equal(result, expected)
   53:         tm.assert_frame_equal(result, result2)
   54: 
   55:         result = ymd.xs((2000, 4))
   56:         expected = ymd.loc[2000, 4]
   57:         tm.assert_frame_equal(result, expected)
   58: 
   59:         # ex from #1796
   60:         index = MultiIndex(
   61:             levels=[["foo", "bar"], ["one", "two"], [-1, 1]],
   62:             codes=[
   63:                 [0, 0, 0, 0, 1, 1, 1, 1],
   64:                 [0, 0, 1, 1, 0, 0, 1, 1],
   65:                 [0, 1, 0, 1, 0, 1, 0, 1],
   66:             ],
   67:         )
   68:         df = DataFrame(
   69:             np.random.default_rng(2).standard_normal((8, 4)),
   70:             index=index,
   71:             columns=list("abcd"),
   72:         )
   73: 
   74:         result = df.xs(("foo", "one"))
   75:         expected = df.loc["foo", "one"]
   76:         tm.assert_frame_equal(result, expected)
   77: 
   78:     def test_getitem_partial(self, multiindex_year_month_day_dataframe_random_data):
   79:         ymd = multiindex_year_month_day_dataframe_random_data
   80:         ymd = ymd.T
   81:         result = ymd[2000, 2]
   82: 
   83:         expected = ymd.reindex(columns=ymd.columns[ymd.columns.codes[1] == 1])
   84:         expected.columns = expected.columns.droplevel(0).droplevel(0)
   85:         tm.assert_frame_equal(result, expected)
   86: 
   87:     def test_fancy_slice_partial(
   88:         self,
   89:         multiindex_dataframe_random_data,
   90:         multiindex_year_month_day_dataframe_random_data,
   91:     ):
   92:         frame = multiindex_dataframe_random_data
   93:         result = frame.loc["bar":"baz"]
   94:         expected = frame[3:7]
   95:         tm.assert_frame_equal(result, expected)
   96: 
   97:         ymd = multiindex_year_month_day_dataframe_random_data
   98:         result = ymd.loc[(2000, 2):(2000, 4)]
   99:         lev = ymd.index.codes[1]
  100:         expected = ymd[(lev >= 1) & (lev <= 3)]
  101:         tm.assert_frame_equal(result, expected)
  102: 
  103:     def test_getitem_partial_column_select(self):
  104:         idx = MultiIndex(
  105:             codes=[[0, 0, 0], [0, 1, 1], [1, 0, 1]],
  106:             levels=[["a", "b"], ["x", "y"], ["p", "q"]],
  107:         )
  108:         df = DataFrame(np.random.default_rng(2).random((3, 2)), index=idx)
  109: 
  110:         result = df.loc[("a", "y"), :]
  111:         expected = df.loc[("a", "y")]
  112:         tm.assert_frame_equal(result, expected)
  113: 
  114:         result = df.loc[("a", "y"), [1, 0]]
  115:         expected = df.loc[("a", "y")][[1, 0]]
  116:         tm.assert_frame_equal(result, expected)
  117: 
  118:         with pytest.raises(KeyError, match=r"\('a', 'foo'\)"):
  119:             df.loc[("a", "foo"), :]
  120: 
  121:     # TODO(ArrayManager) rewrite test to not use .values
  122:     # exp.loc[2000, 4].values[:] select multiple columns -> .values is not a view
  123:     @td.skip_array_manager_invalid_test
  124:     def test_partial_set(
  125:         self,
  126:         multiindex_year_month_day_dataframe_random_data,
  127:         using_copy_on_write,
  128:         warn_copy_on_write,
  129:     ):
  130:         # GH #397
  131:         ymd = multiindex_year_month_day_dataframe_random_data
  132:         df = ymd.copy()
  133:         exp = ymd.copy()
  134:         df.loc[2000, 4] = 0
  135:         exp.iloc[65:85] = 0
  136:         tm.assert_frame_equal(df, exp)
  137: 
  138:         if using_copy_on_write:
  139:             with tm.raises_chained_assignment_error():
  140:                 df["A"].loc[2000, 4] = 1
  141:             df.loc[(2000, 4), "A"] = 1
  142:         else:
  143:             with tm.raises_chained_assignment_error():
  144:                 df["A"].loc[2000, 4] = 1
  145:         exp.iloc[65:85, 0] = 1
  146:         tm.assert_frame_equal(df, exp)
  147: 
  148:         df.loc[2000] = 5
  149:         exp.iloc[:100] = 5
  150:         tm.assert_frame_equal(df, exp)
  151: 
  152:         # this works...for now
  153:         with tm.raises_chained_assignment_error():
  154:             df["A"].iloc[14] = 5
  155:         if using_copy_on_write:
  156:             assert df["A"].iloc[14] == exp["A"].iloc[14]
  157:         else:
  158:             assert df["A"].iloc[14] == 5
  159: 
  160:     @pytest.mark.parametrize("dtype", [int, float])
  161:     def test_getitem_intkey_leading_level(
  162:         self, multiindex_year_month_day_dataframe_random_data, dtype
  163:     ):
  164:         # GH#33355 dont fall-back to positional when leading level is int
  165:         ymd = multiindex_year_month_day_dataframe_random_data
  166:         levels = ymd.index.levels
  167:         ymd.index = ymd.index.set_levels([levels[0].astype(dtype)] + levels[1:])
  168:         ser = ymd["A"]
  169:         mi = ser.index
  170:         assert isinstance(mi, MultiIndex)
  171:         if dtype is int:
  172:             assert mi.levels[0].dtype == np.dtype(int)
  173:         else:
  174:             assert mi.levels[0].dtype == np.float64
  175: 
  176:         assert 14 not in mi.levels[0]
  177:         assert not mi.levels[0]._should_fallback_to_positional
  178:         assert not mi._should_fallback_to_positional
  179: 
  180:         with pytest.raises(KeyError, match="14"):
  181:             ser[14]
  182: 
  183:     # ---------------------------------------------------------------------
  184: 
  185:     def test_setitem_multiple_partial(self, multiindex_dataframe_random_data):
  186:         frame = multiindex_dataframe_random_data
  187:         expected = frame.copy()
  188:         result = frame.copy()
  189:         result.loc[["foo", "bar"]] = 0
  190:         expected.loc["foo"] = 0
  191:         expected.loc["bar"] = 0
  192:         tm.assert_frame_equal(result, expected)
  193: 
  194:         expected = frame.copy()
  195:         result = frame.copy()
  196:         result.loc["foo":"bar"] = 0
  197:         expected.loc["foo"] = 0
  198:         expected.loc["bar"] = 0
  199:         tm.assert_frame_equal(result, expected)
  200: 
  201:         expected = frame["A"].copy()
  202:         result = frame["A"].copy()
  203:         result.loc[["foo", "bar"]] = 0
  204:         expected.loc["foo"] = 0
  205:         expected.loc["bar"] = 0
  206:         tm.assert_series_equal(result, expected)
  207: 
  208:         expected = frame["A"].copy()
  209:         result = frame["A"].copy()
  210:         result.loc["foo":"bar"] = 0
  211:         expected.loc["foo"] = 0
  212:         expected.loc["bar"] = 0
  213:         tm.assert_series_equal(result, expected)
  214: 
  215:     @pytest.mark.parametrize(
  216:         "indexer, exp_idx, exp_values",
  217:         [
  218:             (
  219:                 slice("2019-2", None),
  220:                 DatetimeIndex(["2019-02-01"], dtype="M8[ns]"),
  221:                 [2, 3],
  222:             ),
  223:             (
  224:                 slice(None, "2019-2"),
  225:                 date_range("2019", periods=2, freq="MS"),
  226:                 [0, 1, 2, 3],
  227:             ),
  228:         ],
  229:     )
  230:     def test_partial_getitem_loc_datetime(self, indexer, exp_idx, exp_values):
  231:         # GH: 25165
  232:         date_idx = date_range("2019", periods=2, freq="MS")
  233:         df = DataFrame(
  234:             list(range(4)),
  235:             index=MultiIndex.from_product([date_idx, [0, 1]], names=["x", "y"]),
  236:         )
  237:         expected = DataFrame(
  238:             exp_values,
  239:             index=MultiIndex.from_product([exp_idx, [0, 1]], names=["x", "y"]),
  240:         )
  241:         result = df[indexer]
  242:         tm.assert_frame_equal(result, expected)
  243:         result = df.loc[indexer]
  244:         tm.assert_frame_equal(result, expected)
  245: 
  246:         result = df.loc(axis=0)[indexer]
  247:         tm.assert_frame_equal(result, expected)
  248: 
  249:         result = df.loc[indexer, :]
  250:         tm.assert_frame_equal(result, expected)
  251: 
  252:         df2 = df.swaplevel(0, 1).sort_index()
  253:         expected = expected.swaplevel(0, 1).sort_index()
  254: 
  255:         result = df2.loc[:, indexer, :]
  256:         tm.assert_frame_equal(result, expected)
  257: 
  258: 
  259: def test_loc_getitem_partial_both_axis():
  260:     # gh-12660
  261:     iterables = [["a", "b"], [2, 1]]
  262:     columns = MultiIndex.from_product(iterables, names=["col1", "col2"])
  263:     rows = MultiIndex.from_product(iterables, names=["row1", "row2"])
  264:     df = DataFrame(
  265:         np.random.default_rng(2).standard_normal((4, 4)), index=rows, columns=columns
  266:     )
  267:     expected = df.iloc[:2, 2:].droplevel("row1").droplevel("col1", axis=1)
  268:     result = df.loc["a", "b"]
  269:     tm.assert_frame_equal(result, expected)
