    1: from __future__ import annotations
    2: 
    3: from functools import reduce
    4: from itertools import product
    5: import operator
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: from pandas.compat import PY312
   11: from pandas.errors import (
   12:     NumExprClobberingError,
   13:     PerformanceWarning,
   14:     UndefinedVariableError,
   15: )
   16: import pandas.util._test_decorators as td
   17: 
   18: from pandas.core.dtypes.common import (
   19:     is_bool,
   20:     is_float,
   21:     is_list_like,
   22:     is_scalar,
   23: )
   24: 
   25: import pandas as pd
   26: from pandas import (
   27:     DataFrame,
   28:     Index,
   29:     Series,
   30:     date_range,
   31:     period_range,
   32:     timedelta_range,
   33: )
   34: import pandas._testing as tm
   35: from pandas.core.computation import (
   36:     expr,
   37:     pytables,
   38: )
   39: from pandas.core.computation.engines import ENGINES
   40: from pandas.core.computation.expr import (
   41:     BaseExprVisitor,
   42:     PandasExprVisitor,
   43:     PythonExprVisitor,
   44: )
   45: from pandas.core.computation.expressions import (
   46:     NUMEXPR_INSTALLED,
   47:     USE_NUMEXPR,
   48: )
   49: from pandas.core.computation.ops import (
   50:     ARITH_OPS_SYMS,
   51:     SPECIAL_CASE_ARITH_OPS_SYMS,
   52:     _binary_math_ops,
   53:     _binary_ops_dict,
   54:     _unary_math_ops,
   55: )
   56: from pandas.core.computation.scope import DEFAULT_GLOBALS
   57: 
   58: 
   59: @pytest.fixture(
   60:     params=(
   61:         pytest.param(
   62:             engine,
   63:             marks=[
   64:                 pytest.mark.skipif(
   65:                     engine == "numexpr" and not USE_NUMEXPR,
   66:                     reason=f"numexpr enabled->{USE_NUMEXPR}, "
   67:                     f"installed->{NUMEXPR_INSTALLED}",
   68:                 ),
   69:                 td.skip_if_no("numexpr"),
   70:             ],
   71:         )
   72:         for engine in ENGINES
   73:     )
   74: )
   75: def engine(request):
   76:     return request.param
   77: 
   78: 
   79: @pytest.fixture(params=expr.PARSERS)
   80: def parser(request):
   81:     return request.param
   82: 
   83: 
   84: def _eval_single_bin(lhs, cmp1, rhs, engine):
   85:     c = _binary_ops_dict[cmp1]
   86:     if ENGINES[engine].has_neg_frac:
   87:         try:
   88:             return c(lhs, rhs)
   89:         except ValueError as e:
   90:             if str(e).startswith(
   91:                 "negative number cannot be raised to a fractional power"
   92:             ):
   93:                 return np.nan
   94:             raise
   95:     return c(lhs, rhs)
   96: 
   97: 
   98: # TODO: using range(5) here is a kludge
   99: @pytest.fixture(
  100:     params=list(range(5)),
  101:     ids=["DataFrame", "Series", "SeriesNaN", "DataFrameNaN", "float"],
  102: )
  103: def lhs(request):
  104:     nan_df1 = DataFrame(np.random.default_rng(2).standard_normal((10, 5)))
  105:     nan_df1[nan_df1 > 0.5] = np.nan
  106: 
  107:     opts = (
  108:         DataFrame(np.random.default_rng(2).standard_normal((10, 5))),
  109:         Series(np.random.default_rng(2).standard_normal(5)),
  110:         Series([1, 2, np.nan, np.nan, 5]),
  111:         nan_df1,
  112:         np.random.default_rng(2).standard_normal(),
  113:     )
  114:     return opts[request.param]
  115: 
  116: 
  117: rhs = lhs
  118: midhs = lhs
  119: 
  120: 
  121: @pytest.fixture
  122: def idx_func_dict():
  123:     return {
  124:         "i": lambda n: Index(np.arange(n), dtype=np.int64),
  125:         "f": lambda n: Index(np.arange(n), dtype=np.float64),
  126:         "s": lambda n: Index([f"{i}_{chr(i)}" for i in range(97, 97 + n)]),
  127:         "dt": lambda n: date_range("2020-01-01", periods=n),
  128:         "td": lambda n: timedelta_range("1 day", periods=n),
  129:         "p": lambda n: period_range("2020-01-01", periods=n, freq="D"),
  130:     }
  131: 
  132: 
  133: class TestEval:
  134:     @pytest.mark.parametrize(
  135:         "cmp1",
  136:         ["!=", "==", "<=", ">=", "<", ">"],
  137:         ids=["ne", "eq", "le", "ge", "lt", "gt"],
  138:     )
  139:     @pytest.mark.parametrize("cmp2", [">", "<"], ids=["gt", "lt"])
  140:     @pytest.mark.parametrize("binop", expr.BOOL_OPS_SYMS)
  141:     def test_complex_cmp_ops(self, cmp1, cmp2, binop, lhs, rhs, engine, parser):
  142:         if parser == "python" and binop in ["and", "or"]:
  143:             msg = "'BoolOp' nodes are not implemented"
  144:             with pytest.raises(NotImplementedError, match=msg):
  145:                 ex = f"(lhs {cmp1} rhs) {binop} (lhs {cmp2} rhs)"
  146:                 pd.eval(ex, engine=engine, parser=parser)
  147:             return
  148: 
  149:         lhs_new = _eval_single_bin(lhs, cmp1, rhs, engine)
  150:         rhs_new = _eval_single_bin(lhs, cmp2, rhs, engine)
  151:         expected = _eval_single_bin(lhs_new, binop, rhs_new, engine)
  152: 
  153:         ex = f"(lhs {cmp1} rhs) {binop} (lhs {cmp2} rhs)"
  154:         result = pd.eval(ex, engine=engine, parser=parser)
  155:         tm.assert_equal(result, expected)
  156: 
  157:     @pytest.mark.parametrize("cmp_op", expr.CMP_OPS_SYMS)
  158:     def test_simple_cmp_ops(self, cmp_op, lhs, rhs, engine, parser):
  159:         lhs = lhs < 0
  160:         rhs = rhs < 0
  161: 
  162:         if parser == "python" and cmp_op in ["in", "not in"]:
  163:             msg = "'(In|NotIn)' nodes are not implemented"
  164: 
  165:             with pytest.raises(NotImplementedError, match=msg):
  166:                 ex = f"lhs {cmp_op} rhs"
  167:                 pd.eval(ex, engine=engine, parser=parser)
  168:             return
  169: 
  170:         ex = f"lhs {cmp_op} rhs"
  171:         msg = "|".join(
  172:             [
  173:                 r"only list-like( or dict-like)? objects are allowed to be "
  174:                 r"passed to (DataFrame\.)?isin\(\), you passed a "
  175:                 r"(`|')bool(`|')",
  176:                 "argument of type 'bool' is not iterable",
  177:             ]
  178:         )
  179:         if cmp_op in ("in", "not in") and not is_list_like(rhs):
  180:             with pytest.raises(TypeError, match=msg):
  181:                 pd.eval(
  182:                     ex,
  183:                     engine=engine,
  184:                     parser=parser,
  185:                     local_dict={"lhs": lhs, "rhs": rhs},
  186:                 )
  187:         else:
  188:             expected = _eval_single_bin(lhs, cmp_op, rhs, engine)
  189:             result = pd.eval(ex, engine=engine, parser=parser)
  190:             tm.assert_equal(result, expected)
  191: 
  192:     @pytest.mark.parametrize("op", expr.CMP_OPS_SYMS)
  193:     def test_compound_invert_op(self, op, lhs, rhs, request, engine, parser):
  194:         if parser == "python" and op in ["in", "not in"]:
  195:             msg = "'(In|NotIn)' nodes are not implemented"
  196:             with pytest.raises(NotImplementedError, match=msg):
  197:                 ex = f"~(lhs {op} rhs)"
  198:                 pd.eval(ex, engine=engine, parser=parser)
  199:             return
  200: 
  201:         if (
  202:             is_float(lhs)
  203:             and not is_float(rhs)
  204:             and op in ["in", "not in"]
  205:             and engine == "python"
  206:             and parser == "pandas"
  207:         ):
  208:             mark = pytest.mark.xfail(
  209:                 reason="Looks like expected is negative, unclear whether "
  210:                 "expected is incorrect or result is incorrect"
  211:             )
  212:             request.applymarker(mark)
  213:         skip_these = ["in", "not in"]
  214:         ex = f"~(lhs {op} rhs)"
  215: 
  216:         msg = "|".join(
  217:             [
  218:                 r"only list-like( or dict-like)? objects are allowed to be "
  219:                 r"passed to (DataFrame\.)?isin\(\), you passed a "
  220:                 r"(`|')float(`|')",
  221:                 "argument of type 'float' is not iterable",
  222:             ]
  223:         )
  224:         if is_scalar(rhs) and op in skip_these:
  225:             with pytest.raises(TypeError, match=msg):
  226:                 pd.eval(
  227:                     ex,
  228:                     engine=engine,
  229:                     parser=parser,
  230:                     local_dict={"lhs": lhs, "rhs": rhs},
  231:                 )
  232:         else:
  233:             # compound
  234:             if is_scalar(lhs) and is_scalar(rhs):
  235:                 lhs, rhs = (np.array([x]) for x in (lhs, rhs))
  236:             expected = _eval_single_bin(lhs, op, rhs, engine)
  237:             if is_scalar(expected):
  238:                 expected = not expected
  239:             else:
  240:                 expected = ~expected
  241:             result = pd.eval(ex, engine=engine, parser=parser)
  242:             tm.assert_almost_equal(expected, result)
  243: 
  244:     @pytest.mark.parametrize("cmp1", ["<", ">"])
  245:     @pytest.mark.parametrize("cmp2", ["<", ">"])
  246:     def test_chained_cmp_op(self, cmp1, cmp2, lhs, midhs, rhs, engine, parser):
  247:         mid = midhs
  248:         if parser == "python":
  249:             ex1 = f"lhs {cmp1} mid {cmp2} rhs"
  250:             msg = "'BoolOp' nodes are not implemented"
  251:             with pytest.raises(NotImplementedError, match=msg):
  252:                 pd.eval(ex1, engine=engine, parser=parser)
  253:             return
  254: 
  255:         lhs_new = _eval_single_bin(lhs, cmp1, mid, engine)
  256:         rhs_new = _eval_single_bin(mid, cmp2, rhs, engine)
  257: 
  258:         if lhs_new is not None and rhs_new is not None:
  259:             ex1 = f"lhs {cmp1} mid {cmp2} rhs"
  260:             ex2 = f"lhs {cmp1} mid and mid {cmp2} rhs"
  261:             ex3 = f"(lhs {cmp1} mid) & (mid {cmp2} rhs)"
  262:             expected = _eval_single_bin(lhs_new, "&", rhs_new, engine)
  263: 
  264:             for ex in (ex1, ex2, ex3):
  265:                 result = pd.eval(ex, engine=engine, parser=parser)
  266: 
  267:                 tm.assert_almost_equal(result, expected)
  268: 
  269:     @pytest.mark.parametrize(
  270:         "arith1", sorted(set(ARITH_OPS_SYMS).difference(SPECIAL_CASE_ARITH_OPS_SYMS))
  271:     )
  272:     def test_binary_arith_ops(self, arith1, lhs, rhs, engine, parser):
  273:         ex = f"lhs {arith1} rhs"
  274:         result = pd.eval(ex, engine=engine, parser=parser)
  275:         expected = _eval_single_bin(lhs, arith1, rhs, engine)
  276: 
  277:         tm.assert_almost_equal(result, expected)
  278:         ex = f"lhs {arith1} rhs {arith1} rhs"
  279:         result = pd.eval(ex, engine=engine, parser=parser)
  280:         nlhs = _eval_single_bin(lhs, arith1, rhs, engine)
  281:         try:
  282:             nlhs, ghs = nlhs.align(rhs)
  283:         except (ValueError, TypeError, AttributeError):
  284:             # ValueError: series frame or frame series align
  285:             # TypeError, AttributeError: series or frame with scalar align
  286:             return
  287:         else:
  288:             if engine == "numexpr":
  289:                 import numexpr as ne
  290: 
  291:                 # direct numpy comparison
  292:                 expected = ne.evaluate(f"nlhs {arith1} ghs")
  293:                 # Update assert statement due to unreliable numerical
  294:                 # precision component (GH37328)
  295:                 # TODO: update testing code so that assert_almost_equal statement
  296:                 #  can be replaced again by the assert_numpy_array_equal statement
  297:                 tm.assert_almost_equal(result.values, expected)
  298:             else:
  299:                 expected = eval(f"nlhs {arith1} ghs")
  300:                 tm.assert_almost_equal(result, expected)
  301: 
  302:     # modulus, pow, and floor division require special casing
  303: 
  304:     def test_modulus(self, lhs, rhs, engine, parser):
  305:         ex = r"lhs % rhs"
  306:         result = pd.eval(ex, engine=engine, parser=parser)
  307:         expected = lhs % rhs
  308:         tm.assert_almost_equal(result, expected)
  309: 
  310:         if engine == "numexpr":
  311:             import numexpr as ne
  312: 
  313:             expected = ne.evaluate(r"expected % rhs")
  314:             if isinstance(result, (DataFrame, Series)):
  315:                 tm.assert_almost_equal(result.values, expected)
  316:             else:
  317:                 tm.assert_almost_equal(result, expected.item())
  318:         else:
  319:             expected = _eval_single_bin(expected, "%", rhs, engine)
  320:             tm.assert_almost_equal(result, expected)
  321: 
  322:     def test_floor_division(self, lhs, rhs, engine, parser):
  323:         ex = "lhs // rhs"
  324: 
  325:         if engine == "python":
  326:             res = pd.eval(ex, engine=engine, parser=parser)
  327:             expected = lhs // rhs
  328:             tm.assert_equal(res, expected)
  329:         else:
  330:             msg = (
  331:                 r"unsupported operand type\(s\) for //: 'VariableNode' and "
  332:                 "'VariableNode'"
  333:             )
  334:             with pytest.raises(TypeError, match=msg):
  335:                 pd.eval(
  336:                     ex,
  337:                     local_dict={"lhs": lhs, "rhs": rhs},
  338:                     engine=engine,
  339:                     parser=parser,
  340:                 )
  341: 
  342:     @td.skip_if_windows
  343:     def test_pow(self, lhs, rhs, engine, parser):
  344:         # odd failure on win32 platform, so skip
  345:         ex = "lhs ** rhs"
  346:         expected = _eval_single_bin(lhs, "**", rhs, engine)
  347:         result = pd.eval(ex, engine=engine, parser=parser)
  348: 
  349:         if (
  350:             is_scalar(lhs)
  351:             and is_scalar(rhs)
  352:             and isinstance(expected, (complex, np.complexfloating))
  353:             and np.isnan(result)
  354:         ):
  355:             msg = "(DataFrame.columns|numpy array) are different"
  356:             with pytest.raises(AssertionError, match=msg):
  357:                 tm.assert_numpy_array_equal(result, expected)
  358:         else:
  359:             tm.assert_almost_equal(result, expected)
  360: 
  361:             ex = "(lhs ** rhs) ** rhs"
  362:             result = pd.eval(ex, engine=engine, parser=parser)
  363: 
  364:             middle = _eval_single_bin(lhs, "**", rhs, engine)
  365:             expected = _eval_single_bin(middle, "**", rhs, engine)
  366:             tm.assert_almost_equal(result, expected)
  367: 
  368:     def test_check_single_invert_op(self, lhs, engine, parser):
  369:         # simple
  370:         try:
  371:             elb = lhs.astype(bool)
  372:         except AttributeError:
  373:             elb = np.array([bool(lhs)])
  374:         expected = ~elb
  375:         result = pd.eval("~elb", engine=engine, parser=parser)
  376:         tm.assert_almost_equal(expected, result)
  377: 
  378:     def test_frame_invert(self, engine, parser):
  379:         expr = "~lhs"
  380: 
  381:         # ~ ##
  382:         # frame
  383:         # float always raises
  384:         lhs = DataFrame(np.random.default_rng(2).standard_normal((5, 2)))
  385:         if engine == "numexpr":
  386:             msg = "couldn't find matching opcode for 'invert_dd'"
  387:             with pytest.raises(NotImplementedError, match=msg):
  388:                 pd.eval(expr, engine=engine, parser=parser)
  389:         else:
  390:             msg = "ufunc 'invert' not supported for the input types"
  391:             with pytest.raises(TypeError, match=msg):
  392:                 pd.eval(expr, engine=engine, parser=parser)
  393: 
  394:         # int raises on numexpr
  395:         lhs = DataFrame(np.random.default_rng(2).integers(5, size=(5, 2)))
  396:         if engine == "numexpr":
  397:             msg = "couldn't find matching opcode for 'invert"
  398:             with pytest.raises(NotImplementedError, match=msg):
  399:                 pd.eval(expr, engine=engine, parser=parser)
  400:         else:
  401:             expect = ~lhs
  402:             result = pd.eval(expr, engine=engine, parser=parser)
  403:             tm.assert_frame_equal(expect, result)
  404: 
  405:         # bool always works
  406:         lhs = DataFrame(np.random.default_rng(2).standard_normal((5, 2)) > 0.5)
  407:         expect = ~lhs
  408:         result = pd.eval(expr, engine=engine, parser=parser)
  409:         tm.assert_frame_equal(expect, result)
  410: 
  411:         # object raises
  412:         lhs = DataFrame(
  413:             {"b": ["a", 1, 2.0], "c": np.random.default_rng(2).standard_normal(3) > 0.5}
  414:         )
  415:         if engine == "numexpr":
  416:             with pytest.raises(ValueError, match="unknown type object"):
  417:                 pd.eval(expr, engine=engine, parser=parser)
  418:         else:
  419:             msg = "bad operand type for unary ~: 'str'"
  420:             with pytest.raises(TypeError, match=msg):
  421:                 pd.eval(expr, engine=engine, parser=parser)
  422: 
  423:     def test_series_invert(self, engine, parser):
  424:         # ~ ####
  425:         expr = "~lhs"
  426: 
  427:         # series
  428:         # float raises
  429:         lhs = Series(np.random.default_rng(2).standard_normal(5))
  430:         if engine == "numexpr":
  431:             msg = "couldn't find matching opcode for 'invert_dd'"
  432:             with pytest.raises(NotImplementedError, match=msg):
  433:                 result = pd.eval(expr, engine=engine, parser=parser)
  434:         else:
  435:             msg = "ufunc 'invert' not supported for the input types"
  436:             with pytest.raises(TypeError, match=msg):
  437:                 pd.eval(expr, engine=engine, parser=parser)
  438: 
  439:         # int raises on numexpr
  440:         lhs = Series(np.random.default_rng(2).integers(5, size=5))
  441:         if engine == "numexpr":
  442:             msg = "couldn't find matching opcode for 'invert"
  443:             with pytest.raises(NotImplementedError, match=msg):
  444:                 pd.eval(expr, engine=engine, parser=parser)
  445:         else:
  446:             expect = ~lhs
  447:             result = pd.eval(expr, engine=engine, parser=parser)
  448:             tm.assert_series_equal(expect, result)
  449: 
  450:         # bool
  451:         lhs = Series(np.random.default_rng(2).standard_normal(5) > 0.5)
  452:         expect = ~lhs
  453:         result = pd.eval(expr, engine=engine, parser=parser)
  454:         tm.assert_series_equal(expect, result)
  455: 
  456:         # float
  457:         # int
  458:         # bool
  459: 
  460:         # object
  461:         lhs = Series(["a", 1, 2.0])
  462:         if engine == "numexpr":
  463:             with pytest.raises(ValueError, match="unknown type object"):
  464:                 pd.eval(expr, engine=engine, parser=parser)
  465:         else:
  466:             msg = "bad operand type for unary ~: 'str'"
  467:             with pytest.raises(TypeError, match=msg):
  468:                 pd.eval(expr, engine=engine, parser=parser)
  469: 
  470:     def test_frame_negate(self, engine, parser):
  471:         expr = "-lhs"
  472: 
  473:         # float
  474:         lhs = DataFrame(np.random.default_rng(2).standard_normal((5, 2)))
  475:         expect = -lhs
  476:         result = pd.eval(expr, engine=engine, parser=parser)
  477:         tm.assert_frame_equal(expect, result)
  478: 
  479:         # int
  480:         lhs = DataFrame(np.random.default_rng(2).integers(5, size=(5, 2)))
  481:         expect = -lhs
  482:         result = pd.eval(expr, engine=engine, parser=parser)
  483:         tm.assert_frame_equal(expect, result)
  484: 
  485:         # bool doesn't work with numexpr but works elsewhere
  486:         lhs = DataFrame(np.random.default_rng(2).standard_normal((5, 2)) > 0.5)
  487:         if engine == "numexpr":
  488:             msg = "couldn't find matching opcode for 'neg_bb'"
  489:             with pytest.raises(NotImplementedError, match=msg):
  490:                 pd.eval(expr, engine=engine, parser=parser)
  491:         else:
  492:             expect = -lhs
  493:             result = pd.eval(expr, engine=engine, parser=parser)
  494:             tm.assert_frame_equal(expect, result)
  495: 
  496:     def test_series_negate(self, engine, parser):
  497:         expr = "-lhs"
  498: 
  499:         # float
  500:         lhs = Series(np.random.default_rng(2).standard_normal(5))
  501:         expect = -lhs
  502:         result = pd.eval(expr, engine=engine, parser=parser)
  503:         tm.assert_series_equal(expect, result)
  504: 
  505:         # int
  506:         lhs = Series(np.random.default_rng(2).integers(5, size=5))
  507:         expect = -lhs
  508:         result = pd.eval(expr, engine=engine, parser=parser)
  509:         tm.assert_series_equal(expect, result)
  510: 
  511:         # bool doesn't work with numexpr but works elsewhere
  512:         lhs = Series(np.random.default_rng(2).standard_normal(5) > 0.5)
  513:         if engine == "numexpr":
  514:             msg = "couldn't find matching opcode for 'neg_bb'"
  515:             with pytest.raises(NotImplementedError, match=msg):
  516:                 pd.eval(expr, engine=engine, parser=parser)
  517:         else:
  518:             expect = -lhs
  519:             result = pd.eval(expr, engine=engine, parser=parser)
  520:             tm.assert_series_equal(expect, result)
  521: 
  522:     @pytest.mark.parametrize(
  523:         "lhs",
  524:         [
  525:             # Float
  526:             DataFrame(np.random.default_rng(2).standard_normal((5, 2))),
  527:             # Int
  528:             DataFrame(np.random.default_rng(2).integers(5, size=(5, 2))),
  529:             # bool doesn't work with numexpr but works elsewhere
  530:             DataFrame(np.random.default_rng(2).standard_normal((5, 2)) > 0.5),
  531:         ],
  532:     )
  533:     def test_frame_pos(self, lhs, engine, parser):
  534:         expr = "+lhs"
  535:         expect = lhs
  536: 
  537:         result = pd.eval(expr, engine=engine, parser=parser)
  538:         tm.assert_frame_equal(expect, result)
  539: 
  540:     @pytest.mark.parametrize(
  541:         "lhs",
  542:         [
  543:             # Float
  544:             Series(np.random.default_rng(2).standard_normal(5)),
  545:             # Int
  546:             Series(np.random.default_rng(2).integers(5, size=5)),
  547:             # bool doesn't work with numexpr but works elsewhere
  548:             Series(np.random.default_rng(2).standard_normal(5) > 0.5),
  549:         ],
  550:     )
  551:     def test_series_pos(self, lhs, engine, parser):
  552:         expr = "+lhs"
  553:         expect = lhs
  554: 
  555:         result = pd.eval(expr, engine=engine, parser=parser)
  556:         tm.assert_series_equal(expect, result)
  557: 
  558:     def test_scalar_unary(self, engine, parser):
  559:         msg = "bad operand type for unary ~: 'float'"
  560:         warn = None
  561:         if PY312 and not (engine == "numexpr" and parser == "pandas"):
  562:             warn = DeprecationWarning
  563:         with pytest.raises(TypeError, match=msg):
  564:             pd.eval("~1.0", engine=engine, parser=parser)
  565: 
  566:         assert pd.eval("-1.0", parser=parser, engine=engine) == -1.0
  567:         assert pd.eval("+1.0", parser=parser, engine=engine) == +1.0
  568:         assert pd.eval("~1", parser=parser, engine=engine) == ~1
  569:         assert pd.eval("-1", parser=parser, engine=engine) == -1
  570:         assert pd.eval("+1", parser=parser, engine=engine) == +1
  571:         with tm.assert_produces_warning(
  572:             warn, match="Bitwise inversion", check_stacklevel=False
  573:         ):
  574:             assert pd.eval("~True", parser=parser, engine=engine) == ~True
  575:         with tm.assert_produces_warning(
  576:             warn, match="Bitwise inversion", check_stacklevel=False
  577:         ):
  578:             assert pd.eval("~False", parser=parser, engine=engine) == ~False
  579:         assert pd.eval("-True", parser=parser, engine=engine) == -True
  580:         assert pd.eval("-False", parser=parser, engine=engine) == -False
  581:         assert pd.eval("+True", parser=parser, engine=engine) == +True
  582:         assert pd.eval("+False", parser=parser, engine=engine) == +False
  583: 
  584:     def test_unary_in_array(self):
  585:         # GH 11235
  586:         # TODO: 2022-01-29: result return list with numexpr 2.7.3 in CI
  587:         # but cannot reproduce locally
  588:         result = np.array(
  589:             pd.eval("[-True, True, +True, -False, False, +False, -37, 37, ~37, +37]"),
  590:             dtype=np.object_,
  591:         )
  592:         expected = np.array(
  593:             [
  594:                 -True,
  595:                 True,
  596:                 +True,
  597:                 -False,
  598:                 False,
  599:                 +False,
  600:                 -37,
  601:                 37,
  602:                 ~37,
  603:                 +37,
  604:             ],
  605:             dtype=np.object_,
  606:         )
  607:         tm.assert_numpy_array_equal(result, expected)
  608: 
  609:     @pytest.mark.parametrize("dtype", [np.float32, np.float64])
  610:     @pytest.mark.parametrize("expr", ["x < -0.1", "-5 > x"])
  611:     def test_float_comparison_bin_op(self, dtype, expr):
  612:         # GH 16363
  613:         df = DataFrame({"x": np.array([0], dtype=dtype)})
  614:         res = df.eval(expr)
  615:         assert res.values == np.array([False])
  616: 
  617:     def test_unary_in_function(self):
  618:         # GH 46471
  619:         df = DataFrame({"x": [0, 1, np.nan]})
  620: 
  621:         result = df.eval("x.fillna(-1)")
  622:         expected = df.x.fillna(-1)
  623:         # column name becomes None if using numexpr
  624:         # only check names when the engine is not numexpr
  625:         tm.assert_series_equal(result, expected, check_names=not USE_NUMEXPR)
  626: 
  627:         result = df.eval("x.shift(1, fill_value=-1)")
  628:         expected = df.x.shift(1, fill_value=-1)
  629:         tm.assert_series_equal(result, expected, check_names=not USE_NUMEXPR)
  630: 
  631:     @pytest.mark.parametrize(
  632:         "ex",
  633:         (
  634:             "1 or 2",
  635:             "1 and 2",
  636:             "a and b",
  637:             "a or b",
  638:             "1 or 2 and (3 + 2) > 3",
  639:             "2 * x > 2 or 1 and 2",
  640:             "2 * df > 3 and 1 or a",
  641:         ),
  642:     )
  643:     def test_disallow_scalar_bool_ops(self, ex, engine, parser):
  644:         x, a, b = np.random.default_rng(2).standard_normal(3), 1, 2  # noqa: F841
  645:         df = DataFrame(np.random.default_rng(2).standard_normal((3, 2)))  # noqa: F841
  646: 
  647:         msg = "cannot evaluate scalar only bool ops|'BoolOp' nodes are not"
  648:         with pytest.raises(NotImplementedError, match=msg):
  649:             pd.eval(ex, engine=engine, parser=parser)
  650: 
  651:     def test_identical(self, engine, parser):
  652:         # see gh-10546
  653:         x = 1
  654:         result = pd.eval("x", engine=engine, parser=parser)
  655:         assert result == 1
  656:         assert is_scalar(result)
  657: 
  658:         x = 1.5
  659:         result = pd.eval("x", engine=engine, parser=parser)
  660:         assert result == 1.5
  661:         assert is_scalar(result)
  662: 
  663:         x = False
  664:         result = pd.eval("x", engine=engine, parser=parser)
  665:         assert not result
  666:         assert is_bool(result)
  667:         assert is_scalar(result)
  668: 
  669:         x = np.array([1])
  670:         result = pd.eval("x", engine=engine, parser=parser)
  671:         tm.assert_numpy_array_equal(result, np.array([1]))
  672:         assert result.shape == (1,)
  673: 
  674:         x = np.array([1.5])
  675:         result = pd.eval("x", engine=engine, parser=parser)
  676:         tm.assert_numpy_array_equal(result, np.array([1.5]))
  677:         assert result.shape == (1,)
  678: 
  679:         x = np.array([False])  # noqa: F841
  680:         result = pd.eval("x", engine=engine, parser=parser)
  681:         tm.assert_numpy_array_equal(result, np.array([False]))
  682:         assert result.shape == (1,)
  683: 
  684:     def test_line_continuation(self, engine, parser):
  685:         # GH 11149
  686:         exp = """1 + 2 * \
  687:         5 - 1 + 2 """
  688:         result = pd.eval(exp, engine=engine, parser=parser)
  689:         assert result == 12
  690: 
  691:     def test_float_truncation(self, engine, parser):
  692:         # GH 14241
  693:         exp = "1000000000.006"
  694:         result = pd.eval(exp, engine=engine, parser=parser)
  695:         expected = np.float64(exp)
  696:         assert result == expected
  697: 
  698:         df = DataFrame({"A": [1000000000.0009, 1000000000.0011, 1000000000.0015]})
  699:         cutoff = 1000000000.0006
  700:         result = df.query(f"A < {cutoff:.4f}")
  701:         assert result.empty
  702: 
  703:         cutoff = 1000000000.0010
  704:         result = df.query(f"A > {cutoff:.4f}")
  705:         expected = df.loc[[1, 2], :]
  706:         tm.assert_frame_equal(expected, result)
  707: 
  708:         exact = 1000000000.0011
  709:         result = df.query(f"A == {exact:.4f}")
  710:         expected = df.loc[[1], :]
  711:         tm.assert_frame_equal(expected, result)
  712: 
  713:     def test_disallow_python_keywords(self):
  714:         # GH 18221
  715:         df = DataFrame([[0, 0, 0]], columns=["foo", "bar", "class"])
  716:         msg = "Python keyword not valid identifier in numexpr query"
  717:         with pytest.raises(SyntaxError, match=msg):
  718:             df.query("class == 0")
  719: 
  720:         df = DataFrame()
  721:         df.index.name = "lambda"
  722:         with pytest.raises(SyntaxError, match=msg):
  723:             df.query("lambda == 0")
  724: 
  725:     def test_true_false_logic(self):
  726:         # GH 25823
  727:         # This behavior is deprecated in Python 3.12
  728:         with tm.maybe_produces_warning(
  729:             DeprecationWarning, PY312, check_stacklevel=False
  730:         ):
  731:             assert pd.eval("not True") == -2
  732:             assert pd.eval("not False") == -1
  733:             assert pd.eval("True and not True") == 0
  734: 
  735:     def test_and_logic_string_match(self):
  736:         # GH 25823
  737:         event = Series({"a": "hello"})
  738:         assert pd.eval(f"{event.str.match('hello').a}")
  739:         assert pd.eval(f"{event.str.match('hello').a and event.str.match('hello').a}")
  740: 
  741: 
  742: # -------------------------------------
  743: # gh-12388: Typecasting rules consistency with python
  744: 
  745: 
  746: class TestTypeCasting:
  747:     @pytest.mark.parametrize("op", ["+", "-", "*", "**", "/"])
  748:     # maybe someday... numexpr has too many upcasting rules now
  749:     # chain(*(np.core.sctypes[x] for x in ['uint', 'int', 'float']))
  750:     @pytest.mark.parametrize("dt", [np.float32, np.float64])
  751:     @pytest.mark.parametrize("left_right", [("df", "3"), ("3", "df")])
  752:     def test_binop_typecasting(self, engine, parser, op, dt, left_right):
  753:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)), dtype=dt)
  754:         left, right = left_right
  755:         s = f"{left} {op} {right}"
  756:         res = pd.eval(s, engine=engine, parser=parser)
  757:         assert df.values.dtype == dt
  758:         assert res.values.dtype == dt
  759:         tm.assert_frame_equal(res, eval(s))
  760: 
  761: 
  762: # -------------------------------------
  763: # Basic and complex alignment
  764: 
  765: 
  766: def should_warn(*args):
  767:     not_mono = not any(map(operator.attrgetter("is_monotonic_increasing"), args))
  768:     only_one_dt = reduce(
  769:         operator.xor, (issubclass(x.dtype.type, np.datetime64) for x in args)
  770:     )
  771:     return not_mono and only_one_dt
  772: 
  773: 
  774: class TestAlignment:
  775:     index_types = ["i", "s", "dt"]
  776:     lhs_index_types = index_types + ["s"]  # 'p'
  777: 
  778:     def test_align_nested_unary_op(self, engine, parser):
  779:         s = "df * ~2"
  780:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
  781:         res = pd.eval(s, engine=engine, parser=parser)
  782:         tm.assert_frame_equal(res, df * ~2)
  783: 
  784:     @pytest.mark.filterwarnings("always::RuntimeWarning")
  785:     @pytest.mark.parametrize("lr_idx_type", lhs_index_types)
  786:     @pytest.mark.parametrize("rr_idx_type", index_types)
  787:     @pytest.mark.parametrize("c_idx_type", index_types)
  788:     def test_basic_frame_alignment(
  789:         self, engine, parser, lr_idx_type, rr_idx_type, c_idx_type, idx_func_dict
  790:     ):
  791:         df = DataFrame(
  792:             np.random.default_rng(2).standard_normal((10, 10)),
  793:             index=idx_func_dict[lr_idx_type](10),
  794:             columns=idx_func_dict[c_idx_type](10),
  795:         )
  796:         df2 = DataFrame(
  797:             np.random.default_rng(2).standard_normal((20, 10)),
  798:             index=idx_func_dict[rr_idx_type](20),
  799:             columns=idx_func_dict[c_idx_type](10),
  800:         )
  801:         # only warns if not monotonic and not sortable
  802:         if should_warn(df.index, df2.index):
  803:             with tm.assert_produces_warning(RuntimeWarning):
  804:                 res = pd.eval("df + df2", engine=engine, parser=parser)
  805:         else:
  806:             res = pd.eval("df + df2", engine=engine, parser=parser)
  807:         tm.assert_frame_equal(res, df + df2)
  808: 
  809:     @pytest.mark.parametrize("r_idx_type", lhs_index_types)
  810:     @pytest.mark.parametrize("c_idx_type", lhs_index_types)
  811:     def test_frame_comparison(
  812:         self, engine, parser, r_idx_type, c_idx_type, idx_func_dict
  813:     ):
  814:         df = DataFrame(
  815:             np.random.default_rng(2).standard_normal((10, 10)),
  816:             index=idx_func_dict[r_idx_type](10),
  817:             columns=idx_func_dict[c_idx_type](10),
  818:         )
  819:         res = pd.eval("df < 2", engine=engine, parser=parser)
  820:         tm.assert_frame_equal(res, df < 2)
  821: 
  822:         df3 = DataFrame(
  823:             np.random.default_rng(2).standard_normal(df.shape),
  824:             index=df.index,
  825:             columns=df.columns,
  826:         )
  827:         res = pd.eval("df < df3", engine=engine, parser=parser)
  828:         tm.assert_frame_equal(res, df < df3)
  829: 
  830:     @pytest.mark.filterwarnings("ignore::RuntimeWarning")
  831:     @pytest.mark.parametrize("r1", lhs_index_types)
  832:     @pytest.mark.parametrize("c1", index_types)
  833:     @pytest.mark.parametrize("r2", index_types)
  834:     @pytest.mark.parametrize("c2", index_types)
  835:     def test_medium_complex_frame_alignment(
  836:         self, engine, parser, r1, c1, r2, c2, idx_func_dict
  837:     ):
  838:         df = DataFrame(
  839:             np.random.default_rng(2).standard_normal((3, 2)),
  840:             index=idx_func_dict[r1](3),
  841:             columns=idx_func_dict[c1](2),
  842:         )
  843:         df2 = DataFrame(
  844:             np.random.default_rng(2).standard_normal((4, 2)),
  845:             index=idx_func_dict[r2](4),
  846:             columns=idx_func_dict[c2](2),
  847:         )
  848:         df3 = DataFrame(
  849:             np.random.default_rng(2).standard_normal((5, 2)),
  850:             index=idx_func_dict[r2](5),
  851:             columns=idx_func_dict[c2](2),
  852:         )
  853:         if should_warn(df.index, df2.index, df3.index):
  854:             with tm.assert_produces_warning(RuntimeWarning):
  855:                 res = pd.eval("df + df2 + df3", engine=engine, parser=parser)
  856:         else:
  857:             res = pd.eval("df + df2 + df3", engine=engine, parser=parser)
  858:         tm.assert_frame_equal(res, df + df2 + df3)
  859: 
  860:     @pytest.mark.filterwarnings("ignore::RuntimeWarning")
  861:     @pytest.mark.parametrize("index_name", ["index", "columns"])
  862:     @pytest.mark.parametrize("c_idx_type", index_types)
  863:     @pytest.mark.parametrize("r_idx_type", lhs_index_types)
  864:     def test_basic_frame_series_alignment(
  865:         self, engine, parser, index_name, r_idx_type, c_idx_type, idx_func_dict
  866:     ):
  867:         df = DataFrame(
  868:             np.random.default_rng(2).standard_normal((10, 10)),
  869:             index=idx_func_dict[r_idx_type](10),
  870:             columns=idx_func_dict[c_idx_type](10),
  871:         )
  872:         index = getattr(df, index_name)
  873:         s = Series(np.random.default_rng(2).standard_normal(5), index[:5])
  874: 
  875:         if should_warn(df.index, s.index):
  876:             with tm.assert_produces_warning(RuntimeWarning):
  877:                 res = pd.eval("df + s", engine=engine, parser=parser)
  878:         else:
  879:             res = pd.eval("df + s", engine=engine, parser=parser)
  880: 
  881:         if r_idx_type == "dt" or c_idx_type == "dt":
  882:             expected = df.add(s) if engine == "numexpr" else df + s
  883:         else:
  884:             expected = df + s
  885:         tm.assert_frame_equal(res, expected)
  886: 
  887:     @pytest.mark.parametrize("index_name", ["index", "columns"])
  888:     @pytest.mark.parametrize(
  889:         "r_idx_type, c_idx_type",
  890:         list(product(["i", "s"], ["i", "s"])) + [("dt", "dt")],
  891:     )
  892:     @pytest.mark.filterwarnings("ignore::RuntimeWarning")
  893:     def test_basic_series_frame_alignment(
  894:         self, request, engine, parser, index_name, r_idx_type, c_idx_type, idx_func_dict
  895:     ):
  896:         if (
  897:             engine == "numexpr"
  898:             and parser in ("pandas", "python")
  899:             and index_name == "index"
  900:             and r_idx_type == "i"
  901:             and c_idx_type == "s"
  902:         ):
  903:             reason = (
  904:                 f"Flaky column ordering when engine={engine}, "
  905:                 f"parser={parser}, index_name={index_name}, "
  906:                 f"r_idx_type={r_idx_type}, c_idx_type={c_idx_type}"
  907:             )
  908:             request.applymarker(pytest.mark.xfail(reason=reason, strict=False))
  909:         df = DataFrame(
  910:             np.random.default_rng(2).standard_normal((10, 7)),
  911:             index=idx_func_dict[r_idx_type](10),
  912:             columns=idx_func_dict[c_idx_type](7),
  913:         )
  914:         index = getattr(df, index_name)
  915:         s = Series(np.random.default_rng(2).standard_normal(5), index[:5])
  916:         if should_warn(s.index, df.index):
  917:             with tm.assert_produces_warning(RuntimeWarning):
  918:                 res = pd.eval("s + df", engine=engine, parser=parser)
  919:         else:
  920:             res = pd.eval("s + df", engine=engine, parser=parser)
  921: 
  922:         if r_idx_type == "dt" or c_idx_type == "dt":
  923:             expected = df.add(s) if engine == "numexpr" else s + df
  924:         else:
  925:             expected = s + df
  926:         tm.assert_frame_equal(res, expected)
  927: 
  928:     @pytest.mark.filterwarnings("ignore::RuntimeWarning")
  929:     @pytest.mark.parametrize("c_idx_type", index_types)
  930:     @pytest.mark.parametrize("r_idx_type", lhs_index_types)
  931:     @pytest.mark.parametrize("index_name", ["index", "columns"])
  932:     @pytest.mark.parametrize("op", ["+", "*"])
  933:     def test_series_frame_commutativity(
  934:         self, engine, parser, index_name, op, r_idx_type, c_idx_type, idx_func_dict
  935:     ):
  936:         df = DataFrame(
  937:             np.random.default_rng(2).standard_normal((10, 10)),
  938:             index=idx_func_dict[r_idx_type](10),
  939:             columns=idx_func_dict[c_idx_type](10),
  940:         )
  941:         index = getattr(df, index_name)
  942:         s = Series(np.random.default_rng(2).standard_normal(5), index[:5])
  943: 
  944:         lhs = f"s {op} df"
  945:         rhs = f"df {op} s"
  946:         if should_warn(df.index, s.index):
  947:             with tm.assert_produces_warning(RuntimeWarning):
  948:                 a = pd.eval(lhs, engine=engine, parser=parser)
  949:             with tm.assert_produces_warning(RuntimeWarning):
  950:                 b = pd.eval(rhs, engine=engine, parser=parser)
  951:         else:
  952:             a = pd.eval(lhs, engine=engine, parser=parser)
  953:             b = pd.eval(rhs, engine=engine, parser=parser)
  954: 
  955:         if r_idx_type != "dt" and c_idx_type != "dt":
  956:             if engine == "numexpr":
  957:                 tm.assert_frame_equal(a, b)
  958: 
  959:     @pytest.mark.filterwarnings("always::RuntimeWarning")
  960:     @pytest.mark.parametrize("r1", lhs_index_types)
  961:     @pytest.mark.parametrize("c1", index_types)
  962:     @pytest.mark.parametrize("r2", index_types)
  963:     @pytest.mark.parametrize("c2", index_types)
  964:     def test_complex_series_frame_alignment(
  965:         self, engine, parser, r1, c1, r2, c2, idx_func_dict
  966:     ):
  967:         n = 3
  968:         m1 = 5
  969:         m2 = 2 * m1
  970:         df = DataFrame(
  971:             np.random.default_rng(2).standard_normal((m1, n)),
  972:             index=idx_func_dict[r1](m1),
  973:             columns=idx_func_dict[c1](n),
  974:         )
  975:         df2 = DataFrame(
  976:             np.random.default_rng(2).standard_normal((m2, n)),
  977:             index=idx_func_dict[r2](m2),
  978:             columns=idx_func_dict[c2](n),
  979:         )
  980:         index = df2.columns
  981:         ser = Series(np.random.default_rng(2).standard_normal(n), index[:n])
  982: 
  983:         if r2 == "dt" or c2 == "dt":
  984:             if engine == "numexpr":
  985:                 expected2 = df2.add(ser)
  986:             else:
  987:                 expected2 = df2 + ser
  988:         else:
  989:             expected2 = df2 + ser
  990: 
  991:         if r1 == "dt" or c1 == "dt":
  992:             if engine == "numexpr":
  993:                 expected = expected2.add(df)
  994:             else:
  995:                 expected = expected2 + df
  996:         else:
  997:             expected = expected2 + df
  998: 
  999:         if should_warn(df2.index, ser.index, df.index):
 1000:             with tm.assert_produces_warning(RuntimeWarning):
 1001:                 res = pd.eval("df2 + ser + df", engine=engine, parser=parser)
 1002:         else:
 1003:             res = pd.eval("df2 + ser + df", engine=engine, parser=parser)
 1004:         assert res.shape == expected.shape
 1005:         tm.assert_frame_equal(res, expected)
 1006: 
 1007:     def test_performance_warning_for_poor_alignment(self, engine, parser):
 1008:         df = DataFrame(np.random.default_rng(2).standard_normal((1000, 10)))
 1009:         s = Series(np.random.default_rng(2).standard_normal(10000))
 1010:         if engine == "numexpr":
 1011:             seen = PerformanceWarning
 1012:         else:
 1013:             seen = False
 1014: 
 1015:         with tm.assert_produces_warning(seen):
 1016:             pd.eval("df + s", engine=engine, parser=parser)
 1017: 
 1018:         s = Series(np.random.default_rng(2).standard_normal(1000))
 1019:         with tm.assert_produces_warning(False):
 1020:             pd.eval("df + s", engine=engine, parser=parser)
 1021: 
 1022:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 10000)))
 1023:         s = Series(np.random.default_rng(2).standard_normal(10000))
 1024:         with tm.assert_produces_warning(False):
 1025:             pd.eval("df + s", engine=engine, parser=parser)
 1026: 
 1027:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 10)))
 1028:         s = Series(np.random.default_rng(2).standard_normal(10000))
 1029: 
 1030:         is_python_engine = engine == "python"
 1031: 
 1032:         if not is_python_engine:
 1033:             wrn = PerformanceWarning
 1034:         else:
 1035:             wrn = False
 1036: 
 1037:         with tm.assert_produces_warning(wrn) as w:
 1038:             pd.eval("df + s", engine=engine, parser=parser)
 1039: 
 1040:             if not is_python_engine:
 1041:                 assert len(w) == 1
 1042:                 msg = str(w[0].message)
 1043:                 logged = np.log10(s.size - df.shape[1])
 1044:                 expected = (
 1045:                     f"Alignment difference on axis 1 is larger "
 1046:                     f"than an order of magnitude on term 'df', "
 1047:                     f"by more than {logged:.4g}; performance may suffer."
 1048:                 )
 1049:                 assert msg == expected
 1050: 
 1051: 
 1052: # ------------------------------------
 1053: # Slightly more complex ops
 1054: 
 1055: 
 1056: class TestOperations:
 1057:     def eval(self, *args, **kwargs):
 1058:         kwargs["level"] = kwargs.pop("level", 0) + 1
 1059:         return pd.eval(*args, **kwargs)
 1060: 
 1061:     def test_simple_arith_ops(self, engine, parser):
 1062:         exclude_arith = []
 1063:         if parser == "python":
 1064:             exclude_arith = ["in", "not in"]
 1065: 
 1066:         arith_ops = [
 1067:             op
 1068:             for op in expr.ARITH_OPS_SYMS + expr.CMP_OPS_SYMS
 1069:             if op not in exclude_arith
 1070:         ]
 1071: 
 1072:         ops = (op for op in arith_ops if op != "//")
 1073: 
 1074:         for op in ops:
 1075:             ex = f"1 {op} 1"
 1076:             ex2 = f"x {op} 1"
 1077:             ex3 = f"1 {op} (x + 1)"
 1078: 
 1079:             if op in ("in", "not in"):
 1080:                 msg = "argument of type 'int' is not iterable"
 1081:                 with pytest.raises(TypeError, match=msg):
 1082:                     pd.eval(ex, engine=engine, parser=parser)
 1083:             else:
 1084:                 expec = _eval_single_bin(1, op, 1, engine)
 1085:                 x = self.eval(ex, engine=engine, parser=parser)
 1086:                 assert x == expec
 1087: 
 1088:                 expec = _eval_single_bin(x, op, 1, engine)
 1089:                 y = self.eval(ex2, local_dict={"x": x}, engine=engine, parser=parser)
 1090:                 assert y == expec
 1091: 
 1092:                 expec = _eval_single_bin(1, op, x + 1, engine)
 1093:                 y = self.eval(ex3, local_dict={"x": x}, engine=engine, parser=parser)
 1094:                 assert y == expec
 1095: 
 1096:     @pytest.mark.parametrize("rhs", [True, False])
 1097:     @pytest.mark.parametrize("lhs", [True, False])
 1098:     @pytest.mark.parametrize("op", expr.BOOL_OPS_SYMS)
 1099:     def test_simple_bool_ops(self, rhs, lhs, op):
 1100:         ex = f"{lhs} {op} {rhs}"
 1101: 
 1102:         if parser == "python" and op in ["and", "or"]:
 1103:             msg = "'BoolOp' nodes are not implemented"
 1104:             with pytest.raises(NotImplementedError, match=msg):
 1105:                 self.eval(ex)
 1106:             return
 1107: 
 1108:         res = self.eval(ex)
 1109:         exp = eval(ex)
 1110:         assert res == exp
 1111: 
 1112:     @pytest.mark.parametrize("rhs", [True, False])
 1113:     @pytest.mark.parametrize("lhs", [True, False])
 1114:     @pytest.mark.parametrize("op", expr.BOOL_OPS_SYMS)
 1115:     def test_bool_ops_with_constants(self, rhs, lhs, op):
 1116:         ex = f"{lhs} {op} {rhs}"
 1117: 
 1118:         if parser == "python" and op in ["and", "or"]:
 1119:             msg = "'BoolOp' nodes are not implemented"
 1120:             with pytest.raises(NotImplementedError, match=msg):
 1121:                 self.eval(ex)
 1122:             return
 1123: 
 1124:         res = self.eval(ex)
 1125:         exp = eval(ex)
 1126:         assert res == exp
 1127: 
 1128:     def test_4d_ndarray_fails(self):
 1129:         x = np.random.default_rng(2).standard_normal((3, 4, 5, 6))
 1130:         y = Series(np.random.default_rng(2).standard_normal(10))
 1131:         msg = "N-dimensional objects, where N > 2, are not supported with eval"
 1132:         with pytest.raises(NotImplementedError, match=msg):
 1133:             self.eval("x + y", local_dict={"x": x, "y": y})
 1134: 
 1135:     def test_constant(self):
 1136:         x = self.eval("1")
 1137:         assert x == 1
 1138: 
 1139:     def test_single_variable(self):
 1140:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)))
 1141:         df2 = self.eval("df", local_dict={"df": df})
 1142:         tm.assert_frame_equal(df, df2)
 1143: 
 1144:     def test_failing_subscript_with_name_error(self):
 1145:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))  # noqa: F841
 1146:         with pytest.raises(NameError, match="name 'x' is not defined"):
 1147:             self.eval("df[x > 2] > 2")
 1148: 
 1149:     def test_lhs_expression_subscript(self):
 1150:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
 1151:         result = self.eval("(df + 1)[df > 2]", local_dict={"df": df})
 1152:         expected = (df + 1)[df > 2]
 1153:         tm.assert_frame_equal(result, expected)
 1154: 
 1155:     def test_attr_expression(self):
 1156:         df = DataFrame(
 1157:             np.random.default_rng(2).standard_normal((5, 3)), columns=list("abc")
 1158:         )
 1159:         expr1 = "df.a < df.b"
 1160:         expec1 = df.a < df.b
 1161:         expr2 = "df.a + df.b + df.c"
 1162:         expec2 = df.a + df.b + df.c
 1163:         expr3 = "df.a + df.b + df.c[df.b < 0]"
 1164:         expec3 = df.a + df.b + df.c[df.b < 0]
 1165:         exprs = expr1, expr2, expr3
 1166:         expecs = expec1, expec2, expec3
 1167:         for e, expec in zip(exprs, expecs):
 1168:             tm.assert_series_equal(expec, self.eval(e, local_dict={"df": df}))
 1169: 
 1170:     def test_assignment_fails(self):
 1171:         df = DataFrame(
 1172:             np.random.default_rng(2).standard_normal((5, 3)), columns=list("abc")
 1173:         )
 1174:         df2 = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
 1175:         expr1 = "df = df2"
 1176:         msg = "cannot assign without a target object"
 1177:         with pytest.raises(ValueError, match=msg):
 1178:             self.eval(expr1, local_dict={"df": df, "df2": df2})
 1179: 
 1180:     def test_assignment_column_multiple_raise(self):
 1181:         df = DataFrame(
 1182:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("ab")
 1183:         )
 1184:         # multiple assignees
 1185:         with pytest.raises(SyntaxError, match="invalid syntax"):
 1186:             df.eval("d c = a + b")
 1187: 
 1188:     def test_assignment_column_invalid_assign(self):
 1189:         df = DataFrame(
 1190:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("ab")
 1191:         )
 1192:         # invalid assignees
 1193:         msg = "left hand side of an assignment must be a single name"
 1194:         with pytest.raises(SyntaxError, match=msg):
 1195:             df.eval("d,c = a + b")
 1196: 
 1197:     def test_assignment_column_invalid_assign_function_call(self):
 1198:         df = DataFrame(
 1199:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("ab")
 1200:         )
 1201:         msg = "cannot assign to function call"
 1202:         with pytest.raises(SyntaxError, match=msg):
 1203:             df.eval('Timestamp("20131001") = a + b')
 1204: 
 1205:     def test_assignment_single_assign_existing(self):
 1206:         df = DataFrame(
 1207:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("ab")
 1208:         )
 1209:         # single assignment - existing variable
 1210:         expected = df.copy()
 1211:         expected["a"] = expected["a"] + expected["b"]
 1212:         df.eval("a = a + b", inplace=True)
 1213:         tm.assert_frame_equal(df, expected)
 1214: 
 1215:     def test_assignment_single_assign_new(self):
 1216:         df = DataFrame(
 1217:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("ab")
 1218:         )
 1219:         # single assignment - new variable
 1220:         expected = df.copy()
 1221:         expected["c"] = expected["a"] + expected["b"]
 1222:         df.eval("c = a + b", inplace=True)
 1223:         tm.assert_frame_equal(df, expected)
 1224: 
 1225:     def test_assignment_single_assign_local_overlap(self):
 1226:         df = DataFrame(
 1227:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("ab")
 1228:         )
 1229:         df = df.copy()
 1230:         a = 1  # noqa: F841
 1231:         df.eval("a = 1 + b", inplace=True)
 1232: 
 1233:         expected = df.copy()
 1234:         expected["a"] = 1 + expected["b"]
 1235:         tm.assert_frame_equal(df, expected)
 1236: 
 1237:     def test_assignment_single_assign_name(self):
 1238:         df = DataFrame(
 1239:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("ab")
 1240:         )
 1241: 
 1242:         a = 1  # noqa: F841
 1243:         old_a = df.a.copy()
 1244:         df.eval("a = a + b", inplace=True)
 1245:         result = old_a + df.b
 1246:         tm.assert_series_equal(result, df.a, check_names=False)
 1247:         assert result.name is None
 1248: 
 1249:     def test_assignment_multiple_raises(self):
 1250:         df = DataFrame(
 1251:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("ab")
 1252:         )
 1253:         # multiple assignment
 1254:         df.eval("c = a + b", inplace=True)
 1255:         msg = "can only assign a single expression"
 1256:         with pytest.raises(SyntaxError, match=msg):
 1257:             df.eval("c = a = b")
 1258: 
 1259:     def test_assignment_explicit(self):
 1260:         df = DataFrame(
 1261:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("ab")
 1262:         )
 1263:         # explicit targets
 1264:         self.eval("c = df.a + df.b", local_dict={"df": df}, target=df, inplace=True)
 1265:         expected = df.copy()
 1266:         expected["c"] = expected["a"] + expected["b"]
 1267:         tm.assert_frame_equal(df, expected)
 1268: 
 1269:     def test_column_in(self):
 1270:         # GH 11235
 1271:         df = DataFrame({"a": [11], "b": [-32]})
 1272:         result = df.eval("a in [11, -32]")
 1273:         expected = Series([True])
 1274:         # TODO: 2022-01-29: Name check failed with numexpr 2.7.3 in CI
 1275:         # but cannot reproduce locally
 1276:         tm.assert_series_equal(result, expected, check_names=False)
 1277: 
 1278:     @pytest.mark.xfail(reason="Unknown: Omitted test_ in name prior.")
 1279:     def test_assignment_not_inplace(self):
 1280:         # see gh-9297
 1281:         df = DataFrame(
 1282:             np.random.default_rng(2).standard_normal((5, 2)), columns=list("ab")
 1283:         )
 1284: 
 1285:         actual = df.eval("c = a + b", inplace=False)
 1286:         assert actual is not None
 1287: 
 1288:         expected = df.copy()
 1289:         expected["c"] = expected["a"] + expected["b"]
 1290:         tm.assert_frame_equal(df, expected)
 1291: 
 1292:     def test_multi_line_expression(self, warn_copy_on_write):
 1293:         # GH 11149
 1294:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 1295:         expected = df.copy()
 1296: 
 1297:         expected["c"] = expected["a"] + expected["b"]
 1298:         expected["d"] = expected["c"] + expected["b"]
 1299:         answer = df.eval(
 1300:             """
 1301:         c = a + b
 1302:         d = c + b""",
 1303:             inplace=True,
 1304:         )
 1305:         tm.assert_frame_equal(expected, df)
 1306:         assert answer is None
 1307: 
 1308:         expected["a"] = expected["a"] - 1
 1309:         expected["e"] = expected["a"] + 2
 1310:         answer = df.eval(
 1311:             """
 1312:         a = a - 1
 1313:         e = a + 2""",
 1314:             inplace=True,
 1315:         )
 1316:         tm.assert_frame_equal(expected, df)
 1317:         assert answer is None
 1318: 
 1319:         # multi-line not valid if not all assignments
 1320:         msg = "Multi-line expressions are only valid if all expressions contain"
 1321:         with pytest.raises(ValueError, match=msg):
 1322:             df.eval(
 1323:                 """
 1324:             a = b + 2
 1325:             b - 2""",
 1326:                 inplace=False,
 1327:             )
 1328: 
 1329:     def test_multi_line_expression_not_inplace(self):
 1330:         # GH 11149
 1331:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 1332:         expected = df.copy()
 1333: 
 1334:         expected["c"] = expected["a"] + expected["b"]
 1335:         expected["d"] = expected["c"] + expected["b"]
 1336:         df = df.eval(
 1337:             """
 1338:         c = a + b
 1339:         d = c + b""",
 1340:             inplace=False,
 1341:         )
 1342:         tm.assert_frame_equal(expected, df)
 1343: 
 1344:         expected["a"] = expected["a"] - 1
 1345:         expected["e"] = expected["a"] + 2
 1346:         df = df.eval(
 1347:             """
 1348:         a = a - 1
 1349:         e = a + 2""",
 1350:             inplace=False,
 1351:         )
 1352:         tm.assert_frame_equal(expected, df)
 1353: 
 1354:     def test_multi_line_expression_local_variable(self):
 1355:         # GH 15342
 1356:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 1357:         expected = df.copy()
 1358: 
 1359:         local_var = 7
 1360:         expected["c"] = expected["a"] * local_var
 1361:         expected["d"] = expected["c"] + local_var
 1362:         answer = df.eval(
 1363:             """
 1364:         c = a * @local_var
 1365:         d = c + @local_var
 1366:         """,
 1367:             inplace=True,
 1368:         )
 1369:         tm.assert_frame_equal(expected, df)
 1370:         assert answer is None
 1371: 
 1372:     def test_multi_line_expression_callable_local_variable(self):
 1373:         # 26426
 1374:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 1375: 
 1376:         def local_func(a, b):
 1377:             return b
 1378: 
 1379:         expected = df.copy()
 1380:         expected["c"] = expected["a"] * local_func(1, 7)
 1381:         expected["d"] = expected["c"] + local_func(1, 7)
 1382:         answer = df.eval(
 1383:             """
 1384:         c = a * @local_func(1, 7)
 1385:         d = c + @local_func(1, 7)
 1386:         """,
 1387:             inplace=True,
 1388:         )
 1389:         tm.assert_frame_equal(expected, df)
 1390:         assert answer is None
 1391: 
 1392:     def test_multi_line_expression_callable_local_variable_with_kwargs(self):
 1393:         # 26426
 1394:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 1395: 
 1396:         def local_func(a, b):
 1397:             return b
 1398: 
 1399:         expected = df.copy()
 1400:         expected["c"] = expected["a"] * local_func(b=7, a=1)
 1401:         expected["d"] = expected["c"] + local_func(b=7, a=1)
 1402:         answer = df.eval(
 1403:             """
 1404:         c = a * @local_func(b=7, a=1)
 1405:         d = c + @local_func(b=7, a=1)
 1406:         """,
 1407:             inplace=True,
 1408:         )
 1409:         tm.assert_frame_equal(expected, df)
 1410:         assert answer is None
 1411: 
 1412:     def test_assignment_in_query(self):
 1413:         # GH 8664
 1414:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 1415:         df_orig = df.copy()
 1416:         msg = "cannot assign without a target object"
 1417:         with pytest.raises(ValueError, match=msg):
 1418:             df.query("a = 1")
 1419:         tm.assert_frame_equal(df, df_orig)
 1420: 
 1421:     def test_query_inplace(self):
 1422:         # see gh-11149
 1423:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 1424:         expected = df.copy()
 1425:         expected = expected[expected["a"] == 2]
 1426:         df.query("a == 2", inplace=True)
 1427:         tm.assert_frame_equal(expected, df)
 1428: 
 1429:         df = {}
 1430:         expected = {"a": 3}
 1431: 
 1432:         self.eval("a = 1 + 2", target=df, inplace=True)
 1433:         tm.assert_dict_equal(df, expected)
 1434: 
 1435:     @pytest.mark.parametrize("invalid_target", [1, "cat", [1, 2], np.array([]), (1, 3)])
 1436:     def test_cannot_item_assign(self, invalid_target):
 1437:         msg = "Cannot assign expression output to target"
 1438:         expression = "a = 1 + 2"
 1439: 
 1440:         with pytest.raises(ValueError, match=msg):
 1441:             self.eval(expression, target=invalid_target, inplace=True)
 1442: 
 1443:         if hasattr(invalid_target, "copy"):
 1444:             with pytest.raises(ValueError, match=msg):
 1445:                 self.eval(expression, target=invalid_target, inplace=False)
 1446: 
 1447:     @pytest.mark.parametrize("invalid_target", [1, "cat", (1, 3)])
 1448:     def test_cannot_copy_item(self, invalid_target):
 1449:         msg = "Cannot return a copy of the target"
 1450:         expression = "a = 1 + 2"
 1451: 
 1452:         with pytest.raises(ValueError, match=msg):
 1453:             self.eval(expression, target=invalid_target, inplace=False)
 1454: 
 1455:     @pytest.mark.parametrize("target", [1, "cat", [1, 2], np.array([]), (1, 3), {1: 2}])
 1456:     def test_inplace_no_assignment(self, target):
 1457:         expression = "1 + 2"
 1458: 
 1459:         assert self.eval(expression, target=target, inplace=False) == 3
 1460: 
 1461:         msg = "Cannot operate inplace if there is no assignment"
 1462:         with pytest.raises(ValueError, match=msg):
 1463:             self.eval(expression, target=target, inplace=True)
 1464: 
 1465:     def test_basic_period_index_boolean_expression(self):
 1466:         df = DataFrame(
 1467:             np.random.default_rng(2).standard_normal((2, 2)),
 1468:             columns=period_range("2020-01-01", freq="D", periods=2),
 1469:         )
 1470:         e = df < 2
 1471:         r = self.eval("df < 2", local_dict={"df": df})
 1472:         x = df < 2
 1473: 
 1474:         tm.assert_frame_equal(r, e)
 1475:         tm.assert_frame_equal(x, e)
 1476: 
 1477:     def test_basic_period_index_subscript_expression(self):
 1478:         df = DataFrame(
 1479:             np.random.default_rng(2).standard_normal((2, 2)),
 1480:             columns=period_range("2020-01-01", freq="D", periods=2),
 1481:         )
 1482:         r = self.eval("df[df < 2 + 3]", local_dict={"df": df})
 1483:         e = df[df < 2 + 3]
 1484:         tm.assert_frame_equal(r, e)
 1485: 
 1486:     def test_nested_period_index_subscript_expression(self):
 1487:         df = DataFrame(
 1488:             np.random.default_rng(2).standard_normal((2, 2)),
 1489:             columns=period_range("2020-01-01", freq="D", periods=2),
 1490:         )
 1491:         r = self.eval("df[df[df < 2] < 2] + df * 2", local_dict={"df": df})
 1492:         e = df[df[df < 2] < 2] + df * 2
 1493:         tm.assert_frame_equal(r, e)
 1494: 
 1495:     def test_date_boolean(self, engine, parser):
 1496:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
 1497:         df["dates1"] = date_range("1/1/2012", periods=5)
 1498:         res = self.eval(
 1499:             "df.dates1 < 20130101",
 1500:             local_dict={"df": df},
 1501:             engine=engine,
 1502:             parser=parser,
 1503:         )
 1504:         expec = df.dates1 < "20130101"
 1505:         tm.assert_series_equal(res, expec, check_names=False)
 1506: 
 1507:     def test_simple_in_ops(self, engine, parser):
 1508:         if parser != "python":
 1509:             res = pd.eval("1 in [1, 2]", engine=engine, parser=parser)
 1510:             assert res
 1511: 
 1512:             res = pd.eval("2 in (1, 2)", engine=engine, parser=parser)
 1513:             assert res
 1514: 
 1515:             res = pd.eval("3 in (1, 2)", engine=engine, parser=parser)
 1516:             assert not res
 1517: 
 1518:             res = pd.eval("3 not in (1, 2)", engine=engine, parser=parser)
 1519:             assert res
 1520: 
 1521:             res = pd.eval("[3] not in (1, 2)", engine=engine, parser=parser)
 1522:             assert res
 1523: 
 1524:             res = pd.eval("[3] in ([3], 2)", engine=engine, parser=parser)
 1525:             assert res
 1526: 
 1527:             res = pd.eval("[[3]] in [[[3]], 2]", engine=engine, parser=parser)
 1528:             assert res
 1529: 
 1530:             res = pd.eval("(3,) in [(3,), 2]", engine=engine, parser=parser)
 1531:             assert res
 1532: 
 1533:             res = pd.eval("(3,) not in [(3,), 2]", engine=engine, parser=parser)
 1534:             assert not res
 1535: 
 1536:             res = pd.eval("[(3,)] in [[(3,)], 2]", engine=engine, parser=parser)
 1537:             assert res
 1538:         else:
 1539:             msg = "'In' nodes are not implemented"
 1540:             with pytest.raises(NotImplementedError, match=msg):
 1541:                 pd.eval("1 in [1, 2]", engine=engine, parser=parser)
 1542:             with pytest.raises(NotImplementedError, match=msg):
 1543:                 pd.eval("2 in (1, 2)", engine=engine, parser=parser)
 1544:             with pytest.raises(NotImplementedError, match=msg):
 1545:                 pd.eval("3 in (1, 2)", engine=engine, parser=parser)
 1546:             with pytest.raises(NotImplementedError, match=msg):
 1547:                 pd.eval("[(3,)] in (1, 2, [(3,)])", engine=engine, parser=parser)
 1548:             msg = "'NotIn' nodes are not implemented"
 1549:             with pytest.raises(NotImplementedError, match=msg):
 1550:                 pd.eval("3 not in (1, 2)", engine=engine, parser=parser)
 1551:             with pytest.raises(NotImplementedError, match=msg):
 1552:                 pd.eval("[3] not in (1, 2, [[3]])", engine=engine, parser=parser)
 1553: 
 1554:     def test_check_many_exprs(self, engine, parser):
 1555:         a = 1  # noqa: F841
 1556:         expr = " * ".join("a" * 33)
 1557:         expected = 1
 1558:         res = pd.eval(expr, engine=engine, parser=parser)
 1559:         assert res == expected
 1560: 
 1561:     @pytest.mark.parametrize(
 1562:         "expr",
 1563:         [
 1564:             "df > 2 and df > 3",
 1565:             "df > 2 or df > 3",
 1566:             "not df > 2",
 1567:         ],
 1568:     )
 1569:     def test_fails_and_or_not(self, expr, engine, parser):
 1570:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
 1571:         if parser == "python":
 1572:             msg = "'BoolOp' nodes are not implemented"
 1573:             if "not" in expr:
 1574:                 msg = "'Not' nodes are not implemented"
 1575: 
 1576:             with pytest.raises(NotImplementedError, match=msg):
 1577:                 pd.eval(
 1578:                     expr,
 1579:                     local_dict={"df": df},
 1580:                     parser=parser,
 1581:                     engine=engine,
 1582:                 )
 1583:         else:
 1584:             # smoke-test, should not raise
 1585:             pd.eval(
 1586:                 expr,
 1587:                 local_dict={"df": df},
 1588:                 parser=parser,
 1589:                 engine=engine,
 1590:             )
 1591: 
 1592:     @pytest.mark.parametrize("char", ["|", "&"])
 1593:     def test_fails_ampersand_pipe(self, char, engine, parser):
 1594:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))  # noqa: F841
 1595:         ex = f"(df + 2)[df > 1] > 0 {char} (df > 0)"
 1596:         if parser == "python":
 1597:             msg = "cannot evaluate scalar only bool ops"
 1598:             with pytest.raises(NotImplementedError, match=msg):
 1599:                 pd.eval(ex, parser=parser, engine=engine)
 1600:         else:
 1601:             # smoke-test, should not raise
 1602:             pd.eval(ex, parser=parser, engine=engine)
 1603: 
 1604: 
 1605: class TestMath:
 1606:     def eval(self, *args, **kwargs):
 1607:         kwargs["level"] = kwargs.pop("level", 0) + 1
 1608:         return pd.eval(*args, **kwargs)
 1609: 
 1610:     @pytest.mark.skipif(
 1611:         not NUMEXPR_INSTALLED, reason="Unary ops only implemented for numexpr"
 1612:     )
 1613:     @pytest.mark.parametrize("fn", _unary_math_ops)
 1614:     def test_unary_functions(self, fn):
 1615:         df = DataFrame({"a": np.random.default_rng(2).standard_normal(10)})
 1616:         a = df.a
 1617: 
 1618:         expr = f"{fn}(a)"
 1619:         got = self.eval(expr)
 1620:         with np.errstate(all="ignore"):
 1621:             expect = getattr(np, fn)(a)
 1622:         tm.assert_series_equal(got, expect, check_names=False)
 1623: 
 1624:     @pytest.mark.parametrize("fn", _binary_math_ops)
 1625:     def test_binary_functions(self, fn):
 1626:         df = DataFrame(
 1627:             {
 1628:                 "a": np.random.default_rng(2).standard_normal(10),
 1629:                 "b": np.random.default_rng(2).standard_normal(10),
 1630:             }
 1631:         )
 1632:         a = df.a
 1633:         b = df.b
 1634: 
 1635:         expr = f"{fn}(a, b)"
 1636:         got = self.eval(expr)
 1637:         with np.errstate(all="ignore"):
 1638:             expect = getattr(np, fn)(a, b)
 1639:         tm.assert_almost_equal(got, expect, check_names=False)
 1640: 
 1641:     def test_df_use_case(self, engine, parser):
 1642:         df = DataFrame(
 1643:             {
 1644:                 "a": np.random.default_rng(2).standard_normal(10),
 1645:                 "b": np.random.default_rng(2).standard_normal(10),
 1646:             }
 1647:         )
 1648:         df.eval(
 1649:             "e = arctan2(sin(a), b)",
 1650:             engine=engine,
 1651:             parser=parser,
 1652:             inplace=True,
 1653:         )
 1654:         got = df.e
 1655:         expect = np.arctan2(np.sin(df.a), df.b)
 1656:         tm.assert_series_equal(got, expect, check_names=False)
 1657: 
 1658:     def test_df_arithmetic_subexpression(self, engine, parser):
 1659:         df = DataFrame(
 1660:             {
 1661:                 "a": np.random.default_rng(2).standard_normal(10),
 1662:                 "b": np.random.default_rng(2).standard_normal(10),
 1663:             }
 1664:         )
 1665:         df.eval("e = sin(a + b)", engine=engine, parser=parser, inplace=True)
 1666:         got = df.e
 1667:         expect = np.sin(df.a + df.b)
 1668:         tm.assert_series_equal(got, expect, check_names=False)
 1669: 
 1670:     @pytest.mark.parametrize(
 1671:         "dtype, expect_dtype",
 1672:         [
 1673:             (np.int32, np.float64),
 1674:             (np.int64, np.float64),
 1675:             (np.float32, np.float32),
 1676:             (np.float64, np.float64),
 1677:             pytest.param(np.complex128, np.complex128, marks=td.skip_if_windows),
 1678:         ],
 1679:     )
 1680:     def test_result_types(self, dtype, expect_dtype, engine, parser):
 1681:         # xref https://github.com/pandas-dev/pandas/issues/12293
 1682:         #  this fails on Windows, apparently a floating point precision issue
 1683: 
 1684:         # Did not test complex64 because DataFrame is converting it to
 1685:         # complex128. Due to https://github.com/pandas-dev/pandas/issues/10952
 1686:         df = DataFrame(
 1687:             {"a": np.random.default_rng(2).standard_normal(10).astype(dtype)}
 1688:         )
 1689:         assert df.a.dtype == dtype
 1690:         df.eval("b = sin(a)", engine=engine, parser=parser, inplace=True)
 1691:         got = df.b
 1692:         expect = np.sin(df.a)
 1693:         assert expect.dtype == got.dtype
 1694:         assert expect_dtype == got.dtype
 1695:         tm.assert_series_equal(got, expect, check_names=False)
 1696: 
 1697:     def test_undefined_func(self, engine, parser):
 1698:         df = DataFrame({"a": np.random.default_rng(2).standard_normal(10)})
 1699:         msg = '"mysin" is not a supported function'
 1700: 
 1701:         with pytest.raises(ValueError, match=msg):
 1702:             df.eval("mysin(a)", engine=engine, parser=parser)
 1703: 
 1704:     def test_keyword_arg(self, engine, parser):
 1705:         df = DataFrame({"a": np.random.default_rng(2).standard_normal(10)})
 1706:         msg = 'Function "sin" does not support keyword arguments'
 1707: 
 1708:         with pytest.raises(TypeError, match=msg):
 1709:             df.eval("sin(x=a)", engine=engine, parser=parser)
 1710: 
 1711: 
 1712: _var_s = np.random.default_rng(2).standard_normal(10)
 1713: 
 1714: 
 1715: class TestScope:
 1716:     def test_global_scope(self, engine, parser):
 1717:         e = "_var_s * 2"
 1718:         tm.assert_numpy_array_equal(
 1719:             _var_s * 2, pd.eval(e, engine=engine, parser=parser)
 1720:         )
 1721: 
 1722:     def test_no_new_locals(self, engine, parser):
 1723:         x = 1
 1724:         lcls = locals().copy()
 1725:         pd.eval("x + 1", local_dict=lcls, engine=engine, parser=parser)
 1726:         lcls2 = locals().copy()
 1727:         lcls2.pop("lcls")
 1728:         assert lcls == lcls2
 1729: 
 1730:     def test_no_new_globals(self, engine, parser):
 1731:         x = 1  # noqa: F841
 1732:         gbls = globals().copy()
 1733:         pd.eval("x + 1", engine=engine, parser=parser)
 1734:         gbls2 = globals().copy()
 1735:         assert gbls == gbls2
 1736: 
 1737:     def test_empty_locals(self, engine, parser):
 1738:         # GH 47084
 1739:         x = 1  # noqa: F841
 1740:         msg = "name 'x' is not defined"
 1741:         with pytest.raises(UndefinedVariableError, match=msg):
 1742:             pd.eval("x + 1", engine=engine, parser=parser, local_dict={})
 1743: 
 1744:     def test_empty_globals(self, engine, parser):
 1745:         # GH 47084
 1746:         msg = "name '_var_s' is not defined"
 1747:         e = "_var_s * 2"
 1748:         with pytest.raises(UndefinedVariableError, match=msg):
 1749:             pd.eval(e, engine=engine, parser=parser, global_dict={})
 1750: 
 1751: 
 1752: @td.skip_if_no("numexpr")
 1753: def test_invalid_engine():
 1754:     msg = "Invalid engine 'asdf' passed"
 1755:     with pytest.raises(KeyError, match=msg):
 1756:         pd.eval("x + y", local_dict={"x": 1, "y": 2}, engine="asdf")
 1757: 
 1758: 
 1759: @td.skip_if_no("numexpr")
 1760: @pytest.mark.parametrize(
 1761:     ("use_numexpr", "expected"),
 1762:     (
 1763:         (True, "numexpr"),
 1764:         (False, "python"),
 1765:     ),
 1766: )
 1767: def test_numexpr_option_respected(use_numexpr, expected):
 1768:     # GH 32556
 1769:     from pandas.core.computation.eval import _check_engine
 1770: 
 1771:     with pd.option_context("compute.use_numexpr", use_numexpr):
 1772:         result = _check_engine(None)
 1773:         assert result == expected
 1774: 
 1775: 
 1776: @td.skip_if_no("numexpr")
 1777: def test_numexpr_option_incompatible_op():
 1778:     # GH 32556
 1779:     with pd.option_context("compute.use_numexpr", False):
 1780:         df = DataFrame(
 1781:             {"A": [True, False, True, False, None, None], "B": [1, 2, 3, 4, 5, 6]}
 1782:         )
 1783:         result = df.query("A.isnull()")
 1784:         expected = DataFrame({"A": [None, None], "B": [5, 6]}, index=[4, 5])
 1785:         tm.assert_frame_equal(result, expected)
 1786: 
 1787: 
 1788: @td.skip_if_no("numexpr")
 1789: def test_invalid_parser():
 1790:     msg = "Invalid parser 'asdf' passed"
 1791:     with pytest.raises(KeyError, match=msg):
 1792:         pd.eval("x + y", local_dict={"x": 1, "y": 2}, parser="asdf")
 1793: 
 1794: 
 1795: _parsers: dict[str, type[BaseExprVisitor]] = {
 1796:     "python": PythonExprVisitor,
 1797:     "pytables": pytables.PyTablesExprVisitor,
 1798:     "pandas": PandasExprVisitor,
 1799: }
 1800: 
 1801: 
 1802: @pytest.mark.parametrize("engine", ENGINES)
 1803: @pytest.mark.parametrize("parser", _parsers)
 1804: def test_disallowed_nodes(engine, parser):
 1805:     VisitorClass = _parsers[parser]
 1806:     inst = VisitorClass("x + 1", engine, parser)
 1807: 
 1808:     for ops in VisitorClass.unsupported_nodes:
 1809:         msg = "nodes are not implemented"
 1810:         with pytest.raises(NotImplementedError, match=msg):
 1811:             getattr(inst, ops)()
 1812: 
 1813: 
 1814: def test_syntax_error_exprs(engine, parser):
 1815:     e = "s +"
 1816:     with pytest.raises(SyntaxError, match="invalid syntax"):
 1817:         pd.eval(e, engine=engine, parser=parser)
 1818: 
 1819: 
 1820: def test_name_error_exprs(engine, parser):
 1821:     e = "s + t"
 1822:     msg = "name 's' is not defined"
 1823:     with pytest.raises(NameError, match=msg):
 1824:         pd.eval(e, engine=engine, parser=parser)
 1825: 
 1826: 
 1827: @pytest.mark.parametrize("express", ["a + @b", "@a + b", "@a + @b"])
 1828: def test_invalid_local_variable_reference(engine, parser, express):
 1829:     a, b = 1, 2  # noqa: F841
 1830: 
 1831:     if parser != "pandas":
 1832:         with pytest.raises(SyntaxError, match="The '@' prefix is only"):
 1833:             pd.eval(express, engine=engine, parser=parser)
 1834:     else:
 1835:         with pytest.raises(SyntaxError, match="The '@' prefix is not"):
 1836:             pd.eval(express, engine=engine, parser=parser)
 1837: 
 1838: 
 1839: def test_numexpr_builtin_raises(engine, parser):
 1840:     sin, dotted_line = 1, 2
 1841:     if engine == "numexpr":
 1842:         msg = "Variables in expression .+"
 1843:         with pytest.raises(NumExprClobberingError, match=msg):
 1844:             pd.eval("sin + dotted_line", engine=engine, parser=parser)
 1845:     else:
 1846:         res = pd.eval("sin + dotted_line", engine=engine, parser=parser)
 1847:         assert res == sin + dotted_line
 1848: 
 1849: 
 1850: def test_bad_resolver_raises(engine, parser):
 1851:     cannot_resolve = 42, 3.0
 1852:     with pytest.raises(TypeError, match="Resolver of type .+"):
 1853:         pd.eval("1 + 2", resolvers=cannot_resolve, engine=engine, parser=parser)
 1854: 
 1855: 
 1856: def test_empty_string_raises(engine, parser):
 1857:     # GH 13139
 1858:     with pytest.raises(ValueError, match="expr cannot be an empty string"):
 1859:         pd.eval("", engine=engine, parser=parser)
 1860: 
 1861: 
 1862: def test_more_than_one_expression_raises(engine, parser):
 1863:     with pytest.raises(SyntaxError, match="only a single expression is allowed"):
 1864:         pd.eval("1 + 1; 2 + 2", engine=engine, parser=parser)
 1865: 
 1866: 
 1867: @pytest.mark.parametrize("cmp", ("and", "or"))
 1868: @pytest.mark.parametrize("lhs", (int, float))
 1869: @pytest.mark.parametrize("rhs", (int, float))
 1870: def test_bool_ops_fails_on_scalars(lhs, cmp, rhs, engine, parser):
 1871:     gen = {
 1872:         int: lambda: np.random.default_rng(2).integers(10),
 1873:         float: np.random.default_rng(2).standard_normal,
 1874:     }
 1875: 
 1876:     mid = gen[lhs]()  # noqa: F841
 1877:     lhs = gen[lhs]()
 1878:     rhs = gen[rhs]()
 1879: 
 1880:     ex1 = f"lhs {cmp} mid {cmp} rhs"
 1881:     ex2 = f"lhs {cmp} mid and mid {cmp} rhs"
 1882:     ex3 = f"(lhs {cmp} mid) & (mid {cmp} rhs)"
 1883:     for ex in (ex1, ex2, ex3):
 1884:         msg = "cannot evaluate scalar only bool ops|'BoolOp' nodes are not"
 1885:         with pytest.raises(NotImplementedError, match=msg):
 1886:             pd.eval(ex, engine=engine, parser=parser)
 1887: 
 1888: 
 1889: @pytest.mark.parametrize(
 1890:     "other",
 1891:     [
 1892:         "'x'",
 1893:         "...",
 1894:     ],
 1895: )
 1896: def test_equals_various(other):
 1897:     df = DataFrame({"A": ["a", "b", "c"]}, dtype=object)
 1898:     result = df.eval(f"A == {other}")
 1899:     expected = Series([False, False, False], name="A")
 1900:     if USE_NUMEXPR:
 1901:         # https://github.com/pandas-dev/pandas/issues/10239
 1902:         # lose name with numexpr engine. Remove when that's fixed.
 1903:         expected.name = None
 1904:     tm.assert_series_equal(result, expected)
 1905: 
 1906: 
 1907: def test_inf(engine, parser):
 1908:     s = "inf + 1"
 1909:     expected = np.inf
 1910:     result = pd.eval(s, engine=engine, parser=parser)
 1911:     assert result == expected
 1912: 
 1913: 
 1914: @pytest.mark.parametrize("column", ["Temp(В°C)", "Capacitance(ОјF)"])
 1915: def test_query_token(engine, column):
 1916:     # See: https://github.com/pandas-dev/pandas/pull/42826
 1917:     df = DataFrame(
 1918:         np.random.default_rng(2).standard_normal((5, 2)), columns=[column, "b"]
 1919:     )
 1920:     expected = df[df[column] > 5]
 1921:     query_string = f"`{column}` > 5"
 1922:     result = df.query(query_string, engine=engine)
 1923:     tm.assert_frame_equal(result, expected)
 1924: 
 1925: 
 1926: def test_negate_lt_eq_le(engine, parser):
 1927:     df = DataFrame([[0, 10], [1, 20]], columns=["cat", "count"])
 1928:     expected = df[~(df.cat > 0)]
 1929: 
 1930:     result = df.query("~(cat > 0)", engine=engine, parser=parser)
 1931:     tm.assert_frame_equal(result, expected)
 1932: 
 1933:     if parser == "python":
 1934:         msg = "'Not' nodes are not implemented"
 1935:         with pytest.raises(NotImplementedError, match=msg):
 1936:             df.query("not (cat > 0)", engine=engine, parser=parser)
 1937:     else:
 1938:         result = df.query("not (cat > 0)", engine=engine, parser=parser)
 1939:         tm.assert_frame_equal(result, expected)
 1940: 
 1941: 
 1942: @pytest.mark.parametrize(
 1943:     "column",
 1944:     DEFAULT_GLOBALS.keys(),
 1945: )
 1946: def test_eval_no_support_column_name(request, column):
 1947:     # GH 44603
 1948:     if column in ["True", "False", "inf", "Inf"]:
 1949:         request.applymarker(
 1950:             pytest.mark.xfail(
 1951:                 raises=KeyError,
 1952:                 reason=f"GH 47859 DataFrame eval not supported with {column}",
 1953:             )
 1954:         )
 1955: 
 1956:     df = DataFrame(
 1957:         np.random.default_rng(2).integers(0, 100, size=(10, 2)),
 1958:         columns=[column, "col1"],
 1959:     )
 1960:     expected = df[df[column] > 6]
 1961:     result = df.query(f"{column}>6")
 1962: 
 1963:     tm.assert_frame_equal(result, expected)
 1964: 
 1965: 
 1966: def test_set_inplace(using_copy_on_write, warn_copy_on_write):
 1967:     # https://github.com/pandas-dev/pandas/issues/47449
 1968:     # Ensure we don't only update the DataFrame inplace, but also the actual
 1969:     # column values, such that references to this column also get updated
 1970:     df = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6], "C": [7, 8, 9]})
 1971:     result_view = df[:]
 1972:     ser = df["A"]
 1973:     with tm.assert_cow_warning(warn_copy_on_write):
 1974:         df.eval("A = B + C", inplace=True)
 1975:     expected = DataFrame({"A": [11, 13, 15], "B": [4, 5, 6], "C": [7, 8, 9]})
 1976:     tm.assert_frame_equal(df, expected)
 1977:     if not using_copy_on_write:
 1978:         tm.assert_series_equal(ser, expected["A"])
 1979:         tm.assert_series_equal(result_view["A"], expected["A"])
 1980:     else:
 1981:         expected = Series([1, 2, 3], name="A")
 1982:         tm.assert_series_equal(ser, expected)
 1983:         tm.assert_series_equal(result_view["A"], expected)
 1984: 
 1985: 
 1986: class TestValidate:
 1987:     @pytest.mark.parametrize("value", [1, "True", [1, 2, 3], 5.0])
 1988:     def test_validate_bool_args(self, value):
 1989:         msg = 'For argument "inplace" expected type bool, received type'
 1990:         with pytest.raises(ValueError, match=msg):
 1991:             pd.eval("2+2", inplace=value)
