    1: """
    2: Tests of pandas.tseries.offsets
    3: """
    4: from __future__ import annotations
    5: 
    6: from datetime import (
    7:     datetime,
    8:     timedelta,
    9: )
   10: 
   11: import numpy as np
   12: import pytest
   13: 
   14: from pandas._libs.tslibs import (
   15:     NaT,
   16:     Timedelta,
   17:     Timestamp,
   18:     conversion,
   19:     timezones,
   20: )
   21: import pandas._libs.tslibs.offsets as liboffsets
   22: from pandas._libs.tslibs.offsets import (
   23:     _get_offset,
   24:     _offset_map,
   25:     to_offset,
   26: )
   27: from pandas._libs.tslibs.period import INVALID_FREQ_ERR_MSG
   28: from pandas.errors import PerformanceWarning
   29: 
   30: from pandas import (
   31:     DataFrame,
   32:     DatetimeIndex,
   33:     Series,
   34:     date_range,
   35: )
   36: import pandas._testing as tm
   37: from pandas.tests.tseries.offsets.common import WeekDay
   38: 
   39: from pandas.tseries import offsets
   40: from pandas.tseries.offsets import (
   41:     FY5253,
   42:     BDay,
   43:     BMonthEnd,
   44:     BusinessHour,
   45:     CustomBusinessDay,
   46:     CustomBusinessHour,
   47:     CustomBusinessMonthBegin,
   48:     CustomBusinessMonthEnd,
   49:     DateOffset,
   50:     Easter,
   51:     FY5253Quarter,
   52:     LastWeekOfMonth,
   53:     MonthBegin,
   54:     Nano,
   55:     Tick,
   56:     Week,
   57:     WeekOfMonth,
   58: )
   59: 
   60: _ARITHMETIC_DATE_OFFSET = [
   61:     "years",
   62:     "months",
   63:     "weeks",
   64:     "days",
   65:     "hours",
   66:     "minutes",
   67:     "seconds",
   68:     "milliseconds",
   69:     "microseconds",
   70: ]
   71: 
   72: 
   73: def _create_offset(klass, value=1, normalize=False):
   74:     # create instance from offset class
   75:     if klass is FY5253:
   76:         klass = klass(
   77:             n=value,
   78:             startingMonth=1,
   79:             weekday=1,
   80:             variation="last",
   81:             normalize=normalize,
   82:         )
   83:     elif klass is FY5253Quarter:
   84:         klass = klass(
   85:             n=value,
   86:             startingMonth=1,
   87:             weekday=1,
   88:             qtr_with_extra_week=1,
   89:             variation="last",
   90:             normalize=normalize,
   91:         )
   92:     elif klass is LastWeekOfMonth:
   93:         klass = klass(n=value, weekday=5, normalize=normalize)
   94:     elif klass is WeekOfMonth:
   95:         klass = klass(n=value, week=1, weekday=5, normalize=normalize)
   96:     elif klass is Week:
   97:         klass = klass(n=value, weekday=5, normalize=normalize)
   98:     elif klass is DateOffset:
   99:         klass = klass(days=value, normalize=normalize)
  100:     else:
  101:         klass = klass(value, normalize=normalize)
  102:     return klass
  103: 
  104: 
  105: @pytest.fixture(
  106:     params=[
  107:         getattr(offsets, o)
  108:         for o in offsets.__all__
  109:         if issubclass(getattr(offsets, o), liboffsets.MonthOffset)
  110:         and o != "MonthOffset"
  111:     ]
  112: )
  113: def month_classes(request):
  114:     """
  115:     Fixture for month based datetime offsets available for a time series.
  116:     """
  117:     return request.param
  118: 
  119: 
  120: @pytest.fixture(
  121:     params=[
  122:         getattr(offsets, o) for o in offsets.__all__ if o not in ("Tick", "BaseOffset")
  123:     ]
  124: )
  125: def offset_types(request):
  126:     """
  127:     Fixture for all the datetime offsets available for a time series.
  128:     """
  129:     return request.param
  130: 
  131: 
  132: @pytest.fixture
  133: def dt():
  134:     return Timestamp(datetime(2008, 1, 2))
  135: 
  136: 
  137: @pytest.fixture
  138: def expecteds():
  139:     # executed value created by _create_offset
  140:     # are applied to 2011/01/01 09:00 (Saturday)
  141:     # used for .apply and .rollforward
  142:     return {
  143:         "Day": Timestamp("2011-01-02 09:00:00"),
  144:         "DateOffset": Timestamp("2011-01-02 09:00:00"),
  145:         "BusinessDay": Timestamp("2011-01-03 09:00:00"),
  146:         "CustomBusinessDay": Timestamp("2011-01-03 09:00:00"),
  147:         "CustomBusinessMonthEnd": Timestamp("2011-01-31 09:00:00"),
  148:         "CustomBusinessMonthBegin": Timestamp("2011-01-03 09:00:00"),
  149:         "MonthBegin": Timestamp("2011-02-01 09:00:00"),
  150:         "BusinessMonthBegin": Timestamp("2011-01-03 09:00:00"),
  151:         "MonthEnd": Timestamp("2011-01-31 09:00:00"),
  152:         "SemiMonthEnd": Timestamp("2011-01-15 09:00:00"),
  153:         "SemiMonthBegin": Timestamp("2011-01-15 09:00:00"),
  154:         "BusinessMonthEnd": Timestamp("2011-01-31 09:00:00"),
  155:         "YearBegin": Timestamp("2012-01-01 09:00:00"),
  156:         "BYearBegin": Timestamp("2011-01-03 09:00:00"),
  157:         "YearEnd": Timestamp("2011-12-31 09:00:00"),
  158:         "BYearEnd": Timestamp("2011-12-30 09:00:00"),
  159:         "QuarterBegin": Timestamp("2011-03-01 09:00:00"),
  160:         "BQuarterBegin": Timestamp("2011-03-01 09:00:00"),
  161:         "QuarterEnd": Timestamp("2011-03-31 09:00:00"),
  162:         "BQuarterEnd": Timestamp("2011-03-31 09:00:00"),
  163:         "BusinessHour": Timestamp("2011-01-03 10:00:00"),
  164:         "CustomBusinessHour": Timestamp("2011-01-03 10:00:00"),
  165:         "WeekOfMonth": Timestamp("2011-01-08 09:00:00"),
  166:         "LastWeekOfMonth": Timestamp("2011-01-29 09:00:00"),
  167:         "FY5253Quarter": Timestamp("2011-01-25 09:00:00"),
  168:         "FY5253": Timestamp("2011-01-25 09:00:00"),
  169:         "Week": Timestamp("2011-01-08 09:00:00"),
  170:         "Easter": Timestamp("2011-04-24 09:00:00"),
  171:         "Hour": Timestamp("2011-01-01 10:00:00"),
  172:         "Minute": Timestamp("2011-01-01 09:01:00"),
  173:         "Second": Timestamp("2011-01-01 09:00:01"),
  174:         "Milli": Timestamp("2011-01-01 09:00:00.001000"),
  175:         "Micro": Timestamp("2011-01-01 09:00:00.000001"),
  176:         "Nano": Timestamp("2011-01-01T09:00:00.000000001"),
  177:     }
  178: 
  179: 
  180: class TestCommon:
  181:     def test_immutable(self, offset_types):
  182:         # GH#21341 check that __setattr__ raises
  183:         offset = _create_offset(offset_types)
  184:         msg = "objects is not writable|DateOffset objects are immutable"
  185:         with pytest.raises(AttributeError, match=msg):
  186:             offset.normalize = True
  187:         with pytest.raises(AttributeError, match=msg):
  188:             offset.n = 91
  189: 
  190:     def test_return_type(self, offset_types):
  191:         offset = _create_offset(offset_types)
  192: 
  193:         # make sure that we are returning a Timestamp
  194:         result = Timestamp("20080101") + offset
  195:         assert isinstance(result, Timestamp)
  196: 
  197:         # make sure that we are returning NaT
  198:         assert NaT + offset is NaT
  199:         assert offset + NaT is NaT
  200: 
  201:         assert NaT - offset is NaT
  202:         assert (-offset)._apply(NaT) is NaT
  203: 
  204:     def test_offset_n(self, offset_types):
  205:         offset = _create_offset(offset_types)
  206:         assert offset.n == 1
  207: 
  208:         neg_offset = offset * -1
  209:         assert neg_offset.n == -1
  210: 
  211:         mul_offset = offset * 3
  212:         assert mul_offset.n == 3
  213: 
  214:     def test_offset_timedelta64_arg(self, offset_types):
  215:         # check that offset._validate_n raises TypeError on a timedelt64
  216:         #  object
  217:         off = _create_offset(offset_types)
  218: 
  219:         td64 = np.timedelta64(4567, "s")
  220:         with pytest.raises(TypeError, match="argument must be an integer"):
  221:             type(off)(n=td64, **off.kwds)
  222: 
  223:     def test_offset_mul_ndarray(self, offset_types):
  224:         off = _create_offset(offset_types)
  225: 
  226:         expected = np.array([[off, off * 2], [off * 3, off * 4]])
  227: 
  228:         result = np.array([[1, 2], [3, 4]]) * off
  229:         tm.assert_numpy_array_equal(result, expected)
  230: 
  231:         result = off * np.array([[1, 2], [3, 4]])
  232:         tm.assert_numpy_array_equal(result, expected)
  233: 
  234:     def test_offset_freqstr(self, offset_types):
  235:         offset = _create_offset(offset_types)
  236: 
  237:         freqstr = offset.freqstr
  238:         if freqstr not in ("<Easter>", "<DateOffset: days=1>", "LWOM-SAT"):
  239:             code = _get_offset(freqstr)
  240:             assert offset.rule_code == code
  241: 
  242:     def _check_offsetfunc_works(self, offset, funcname, dt, expected, normalize=False):
  243:         if normalize and issubclass(offset, Tick):
  244:             # normalize=True disallowed for Tick subclasses GH#21427
  245:             return
  246: 
  247:         offset_s = _create_offset(offset, normalize=normalize)
  248:         func = getattr(offset_s, funcname)
  249: 
  250:         result = func(dt)
  251:         assert isinstance(result, Timestamp)
  252:         assert result == expected
  253: 
  254:         result = func(Timestamp(dt))
  255:         assert isinstance(result, Timestamp)
  256:         assert result == expected
  257: 
  258:         # see gh-14101
  259:         ts = Timestamp(dt) + Nano(5)
  260:         # test nanosecond is preserved
  261:         with tm.assert_produces_warning(None):
  262:             result = func(ts)
  263: 
  264:         assert isinstance(result, Timestamp)
  265:         if normalize is False:
  266:             assert result == expected + Nano(5)
  267:         else:
  268:             assert result == expected
  269: 
  270:         if isinstance(dt, np.datetime64):
  271:             # test tz when input is datetime or Timestamp
  272:             return
  273: 
  274:         for tz in [
  275:             None,
  276:             "UTC",
  277:             "Asia/Tokyo",
  278:             "US/Eastern",
  279:             "dateutil/Asia/Tokyo",
  280:             "dateutil/US/Pacific",
  281:         ]:
  282:             expected_localize = expected.tz_localize(tz)
  283:             tz_obj = timezones.maybe_get_tz(tz)
  284:             dt_tz = conversion.localize_pydatetime(dt, tz_obj)
  285: 
  286:             result = func(dt_tz)
  287:             assert isinstance(result, Timestamp)
  288:             assert result == expected_localize
  289: 
  290:             result = func(Timestamp(dt, tz=tz))
  291:             assert isinstance(result, Timestamp)
  292:             assert result == expected_localize
  293: 
  294:             # see gh-14101
  295:             ts = Timestamp(dt, tz=tz) + Nano(5)
  296:             # test nanosecond is preserved
  297:             with tm.assert_produces_warning(None):
  298:                 result = func(ts)
  299:             assert isinstance(result, Timestamp)
  300:             if normalize is False:
  301:                 assert result == expected_localize + Nano(5)
  302:             else:
  303:                 assert result == expected_localize
  304: 
  305:     def test_apply(self, offset_types, expecteds):
  306:         sdt = datetime(2011, 1, 1, 9, 0)
  307:         ndt = np.datetime64("2011-01-01 09:00")
  308: 
  309:         expected = expecteds[offset_types.__name__]
  310:         expected_norm = Timestamp(expected.date())
  311: 
  312:         for dt in [sdt, ndt]:
  313:             self._check_offsetfunc_works(offset_types, "_apply", dt, expected)
  314: 
  315:             self._check_offsetfunc_works(
  316:                 offset_types, "_apply", dt, expected_norm, normalize=True
  317:             )
  318: 
  319:     def test_rollforward(self, offset_types, expecteds):
  320:         expecteds = expecteds.copy()
  321: 
  322:         # result will not be changed if the target is on the offset
  323:         no_changes = [
  324:             "Day",
  325:             "MonthBegin",
  326:             "SemiMonthBegin",
  327:             "YearBegin",
  328:             "Week",
  329:             "Hour",
  330:             "Minute",
  331:             "Second",
  332:             "Milli",
  333:             "Micro",
  334:             "Nano",
  335:             "DateOffset",
  336:         ]
  337:         for n in no_changes:
  338:             expecteds[n] = Timestamp("2011/01/01 09:00")
  339: 
  340:         expecteds["BusinessHour"] = Timestamp("2011-01-03 09:00:00")
  341:         expecteds["CustomBusinessHour"] = Timestamp("2011-01-03 09:00:00")
  342: 
  343:         # but be changed when normalize=True
  344:         norm_expected = expecteds.copy()
  345:         for k in norm_expected:
  346:             norm_expected[k] = Timestamp(norm_expected[k].date())
  347: 
  348:         normalized = {
  349:             "Day": Timestamp("2011-01-02 00:00:00"),
  350:             "DateOffset": Timestamp("2011-01-02 00:00:00"),
  351:             "MonthBegin": Timestamp("2011-02-01 00:00:00"),
  352:             "SemiMonthBegin": Timestamp("2011-01-15 00:00:00"),
  353:             "YearBegin": Timestamp("2012-01-01 00:00:00"),
  354:             "Week": Timestamp("2011-01-08 00:00:00"),
  355:             "Hour": Timestamp("2011-01-01 00:00:00"),
  356:             "Minute": Timestamp("2011-01-01 00:00:00"),
  357:             "Second": Timestamp("2011-01-01 00:00:00"),
  358:             "Milli": Timestamp("2011-01-01 00:00:00"),
  359:             "Micro": Timestamp("2011-01-01 00:00:00"),
  360:         }
  361:         norm_expected.update(normalized)
  362: 
  363:         sdt = datetime(2011, 1, 1, 9, 0)
  364:         ndt = np.datetime64("2011-01-01 09:00")
  365: 
  366:         for dt in [sdt, ndt]:
  367:             expected = expecteds[offset_types.__name__]
  368:             self._check_offsetfunc_works(offset_types, "rollforward", dt, expected)
  369:             expected = norm_expected[offset_types.__name__]
  370:             self._check_offsetfunc_works(
  371:                 offset_types, "rollforward", dt, expected, normalize=True
  372:             )
  373: 
  374:     def test_rollback(self, offset_types):
  375:         expecteds = {
  376:             "BusinessDay": Timestamp("2010-12-31 09:00:00"),
  377:             "CustomBusinessDay": Timestamp("2010-12-31 09:00:00"),
  378:             "CustomBusinessMonthEnd": Timestamp("2010-12-31 09:00:00"),
  379:             "CustomBusinessMonthBegin": Timestamp("2010-12-01 09:00:00"),
  380:             "BusinessMonthBegin": Timestamp("2010-12-01 09:00:00"),
  381:             "MonthEnd": Timestamp("2010-12-31 09:00:00"),
  382:             "SemiMonthEnd": Timestamp("2010-12-31 09:00:00"),
  383:             "BusinessMonthEnd": Timestamp("2010-12-31 09:00:00"),
  384:             "BYearBegin": Timestamp("2010-01-01 09:00:00"),
  385:             "YearEnd": Timestamp("2010-12-31 09:00:00"),
  386:             "BYearEnd": Timestamp("2010-12-31 09:00:00"),
  387:             "QuarterBegin": Timestamp("2010-12-01 09:00:00"),
  388:             "BQuarterBegin": Timestamp("2010-12-01 09:00:00"),
  389:             "QuarterEnd": Timestamp("2010-12-31 09:00:00"),
  390:             "BQuarterEnd": Timestamp("2010-12-31 09:00:00"),
  391:             "BusinessHour": Timestamp("2010-12-31 17:00:00"),
  392:             "CustomBusinessHour": Timestamp("2010-12-31 17:00:00"),
  393:             "WeekOfMonth": Timestamp("2010-12-11 09:00:00"),
  394:             "LastWeekOfMonth": Timestamp("2010-12-25 09:00:00"),
  395:             "FY5253Quarter": Timestamp("2010-10-26 09:00:00"),
  396:             "FY5253": Timestamp("2010-01-26 09:00:00"),
  397:             "Easter": Timestamp("2010-04-04 09:00:00"),
  398:         }
  399: 
  400:         # result will not be changed if the target is on the offset
  401:         for n in [
  402:             "Day",
  403:             "MonthBegin",
  404:             "SemiMonthBegin",
  405:             "YearBegin",
  406:             "Week",
  407:             "Hour",
  408:             "Minute",
  409:             "Second",
  410:             "Milli",
  411:             "Micro",
  412:             "Nano",
  413:             "DateOffset",
  414:         ]:
  415:             expecteds[n] = Timestamp("2011/01/01 09:00")
  416: 
  417:         # but be changed when normalize=True
  418:         norm_expected = expecteds.copy()
  419:         for k in norm_expected:
  420:             norm_expected[k] = Timestamp(norm_expected[k].date())
  421: 
  422:         normalized = {
  423:             "Day": Timestamp("2010-12-31 00:00:00"),
  424:             "DateOffset": Timestamp("2010-12-31 00:00:00"),
  425:             "MonthBegin": Timestamp("2010-12-01 00:00:00"),
  426:             "SemiMonthBegin": Timestamp("2010-12-15 00:00:00"),
  427:             "YearBegin": Timestamp("2010-01-01 00:00:00"),
  428:             "Week": Timestamp("2010-12-25 00:00:00"),
  429:             "Hour": Timestamp("2011-01-01 00:00:00"),
  430:             "Minute": Timestamp("2011-01-01 00:00:00"),
  431:             "Second": Timestamp("2011-01-01 00:00:00"),
  432:             "Milli": Timestamp("2011-01-01 00:00:00"),
  433:             "Micro": Timestamp("2011-01-01 00:00:00"),
  434:         }
  435:         norm_expected.update(normalized)
  436: 
  437:         sdt = datetime(2011, 1, 1, 9, 0)
  438:         ndt = np.datetime64("2011-01-01 09:00")
  439: 
  440:         for dt in [sdt, ndt]:
  441:             expected = expecteds[offset_types.__name__]
  442:             self._check_offsetfunc_works(offset_types, "rollback", dt, expected)
  443: 
  444:             expected = norm_expected[offset_types.__name__]
  445:             self._check_offsetfunc_works(
  446:                 offset_types, "rollback", dt, expected, normalize=True
  447:             )
  448: 
  449:     def test_is_on_offset(self, offset_types, expecteds):
  450:         dt = expecteds[offset_types.__name__]
  451:         offset_s = _create_offset(offset_types)
  452:         assert offset_s.is_on_offset(dt)
  453: 
  454:         # when normalize=True, is_on_offset checks time is 00:00:00
  455:         if issubclass(offset_types, Tick):
  456:             # normalize=True disallowed for Tick subclasses GH#21427
  457:             return
  458:         offset_n = _create_offset(offset_types, normalize=True)
  459:         assert not offset_n.is_on_offset(dt)
  460: 
  461:         if offset_types in (BusinessHour, CustomBusinessHour):
  462:             # In default BusinessHour (9:00-17:00), normalized time
  463:             # cannot be in business hour range
  464:             return
  465:         date = datetime(dt.year, dt.month, dt.day)
  466:         assert offset_n.is_on_offset(date)
  467: 
  468:     def test_add(self, offset_types, tz_naive_fixture, expecteds):
  469:         tz = tz_naive_fixture
  470:         dt = datetime(2011, 1, 1, 9, 0)
  471: 
  472:         offset_s = _create_offset(offset_types)
  473:         expected = expecteds[offset_types.__name__]
  474: 
  475:         result_dt = dt + offset_s
  476:         result_ts = Timestamp(dt) + offset_s
  477:         for result in [result_dt, result_ts]:
  478:             assert isinstance(result, Timestamp)
  479:             assert result == expected
  480: 
  481:         expected_localize = expected.tz_localize(tz)
  482:         result = Timestamp(dt, tz=tz) + offset_s
  483:         assert isinstance(result, Timestamp)
  484:         assert result == expected_localize
  485: 
  486:         # normalize=True, disallowed for Tick subclasses GH#21427
  487:         if issubclass(offset_types, Tick):
  488:             return
  489:         offset_s = _create_offset(offset_types, normalize=True)
  490:         expected = Timestamp(expected.date())
  491: 
  492:         result_dt = dt + offset_s
  493:         result_ts = Timestamp(dt) + offset_s
  494:         for result in [result_dt, result_ts]:
  495:             assert isinstance(result, Timestamp)
  496:             assert result == expected
  497: 
  498:         expected_localize = expected.tz_localize(tz)
  499:         result = Timestamp(dt, tz=tz) + offset_s
  500:         assert isinstance(result, Timestamp)
  501:         assert result == expected_localize
  502: 
  503:     def test_add_empty_datetimeindex(self, offset_types, tz_naive_fixture):
  504:         # GH#12724, GH#30336
  505:         offset_s = _create_offset(offset_types)
  506: 
  507:         dti = DatetimeIndex([], tz=tz_naive_fixture).as_unit("ns")
  508: 
  509:         warn = None
  510:         if isinstance(
  511:             offset_s,
  512:             (
  513:                 Easter,
  514:                 WeekOfMonth,
  515:                 LastWeekOfMonth,
  516:                 CustomBusinessDay,
  517:                 BusinessHour,
  518:                 CustomBusinessHour,
  519:                 CustomBusinessMonthBegin,
  520:                 CustomBusinessMonthEnd,
  521:                 FY5253,
  522:                 FY5253Quarter,
  523:             ),
  524:         ):
  525:             # We don't have an optimized apply_index
  526:             warn = PerformanceWarning
  527: 
  528:         # stacklevel checking is slow, and we have ~800 of variants of this
  529:         #  test, so let's only check the stacklevel in a subset of them
  530:         check_stacklevel = tz_naive_fixture is None
  531:         with tm.assert_produces_warning(warn, check_stacklevel=check_stacklevel):
  532:             result = dti + offset_s
  533:         tm.assert_index_equal(result, dti)
  534:         with tm.assert_produces_warning(warn, check_stacklevel=check_stacklevel):
  535:             result = offset_s + dti
  536:         tm.assert_index_equal(result, dti)
  537: 
  538:         dta = dti._data
  539:         with tm.assert_produces_warning(warn, check_stacklevel=check_stacklevel):
  540:             result = dta + offset_s
  541:         tm.assert_equal(result, dta)
  542:         with tm.assert_produces_warning(warn, check_stacklevel=check_stacklevel):
  543:             result = offset_s + dta
  544:         tm.assert_equal(result, dta)
  545: 
  546:     def test_pickle_roundtrip(self, offset_types):
  547:         off = _create_offset(offset_types)
  548:         res = tm.round_trip_pickle(off)
  549:         assert off == res
  550:         if type(off) is not DateOffset:
  551:             for attr in off._attributes:
  552:                 if attr == "calendar":
  553:                     # np.busdaycalendar __eq__ will return False;
  554:                     #  we check holidays and weekmask attrs so are OK
  555:                     continue
  556:                 # Make sure nothings got lost from _params (which __eq__) is based on
  557:                 assert getattr(off, attr) == getattr(res, attr)
  558: 
  559:     def test_pickle_dateoffset_odd_inputs(self):
  560:         # GH#34511
  561:         off = DateOffset(months=12)
  562:         res = tm.round_trip_pickle(off)
  563:         assert off == res
  564: 
  565:         base_dt = datetime(2020, 1, 1)
  566:         assert base_dt + off == base_dt + res
  567: 
  568:     def test_offsets_hashable(self, offset_types):
  569:         # GH: 37267
  570:         off = _create_offset(offset_types)
  571:         assert hash(off) is not None
  572: 
  573:     # TODO: belongs in arithmetic tests?
  574:     @pytest.mark.filterwarnings(
  575:         "ignore:Non-vectorized DateOffset being applied to Series or DatetimeIndex"
  576:     )
  577:     @pytest.mark.parametrize("unit", ["s", "ms", "us"])
  578:     def test_add_dt64_ndarray_non_nano(self, offset_types, unit):
  579:         # check that the result with non-nano matches nano
  580:         off = _create_offset(offset_types)
  581: 
  582:         dti = date_range("2016-01-01", periods=35, freq="D", unit=unit)
  583: 
  584:         result = (dti + off)._with_freq(None)
  585: 
  586:         exp_unit = unit
  587:         if isinstance(off, Tick) and off._creso > dti._data._creso:
  588:             # cast to higher reso like we would with Timedelta scalar
  589:             exp_unit = Timedelta(off).unit
  590:         # TODO(GH#55564): as_unit will be unnecessary
  591:         expected = DatetimeIndex([x + off for x in dti]).as_unit(exp_unit)
  592: 
  593:         tm.assert_index_equal(result, expected)
  594: 
  595: 
  596: class TestDateOffset:
  597:     def setup_method(self):
  598:         _offset_map.clear()
  599: 
  600:     def test_repr(self):
  601:         repr(DateOffset())
  602:         repr(DateOffset(2))
  603:         repr(2 * DateOffset())
  604:         repr(2 * DateOffset(months=2))
  605: 
  606:     def test_mul(self):
  607:         assert DateOffset(2) == 2 * DateOffset(1)
  608:         assert DateOffset(2) == DateOffset(1) * 2
  609: 
  610:     @pytest.mark.parametrize("kwd", sorted(liboffsets._relativedelta_kwds))
  611:     def test_constructor(self, kwd, request):
  612:         if kwd == "millisecond":
  613:             request.applymarker(
  614:                 pytest.mark.xfail(
  615:                     raises=NotImplementedError,
  616:                     reason="Constructing DateOffset object with `millisecond` is not "
  617:                     "yet supported.",
  618:                 )
  619:             )
  620:         offset = DateOffset(**{kwd: 2})
  621:         assert offset.kwds == {kwd: 2}
  622:         assert getattr(offset, kwd) == 2
  623: 
  624:     def test_default_constructor(self, dt):
  625:         assert (dt + DateOffset(2)) == datetime(2008, 1, 4)
  626: 
  627:     def test_is_anchored(self):
  628:         msg = "DateOffset.is_anchored is deprecated "
  629: 
  630:         with tm.assert_produces_warning(FutureWarning, match=msg):
  631:             assert not DateOffset(2).is_anchored()
  632:             assert DateOffset(1).is_anchored()
  633: 
  634:     def test_copy(self):
  635:         assert DateOffset(months=2).copy() == DateOffset(months=2)
  636:         assert DateOffset(milliseconds=1).copy() == DateOffset(milliseconds=1)
  637: 
  638:     @pytest.mark.parametrize(
  639:         "arithmatic_offset_type, expected",
  640:         zip(
  641:             _ARITHMETIC_DATE_OFFSET,
  642:             [
  643:                 "2009-01-02",
  644:                 "2008-02-02",
  645:                 "2008-01-09",
  646:                 "2008-01-03",
  647:                 "2008-01-02 01:00:00",
  648:                 "2008-01-02 00:01:00",
  649:                 "2008-01-02 00:00:01",
  650:                 "2008-01-02 00:00:00.001000000",
  651:                 "2008-01-02 00:00:00.000001000",
  652:             ],
  653:         ),
  654:     )
  655:     def test_add(self, arithmatic_offset_type, expected, dt):
  656:         assert DateOffset(**{arithmatic_offset_type: 1}) + dt == Timestamp(expected)
  657:         assert dt + DateOffset(**{arithmatic_offset_type: 1}) == Timestamp(expected)
  658: 
  659:     @pytest.mark.parametrize(
  660:         "arithmatic_offset_type, expected",
  661:         zip(
  662:             _ARITHMETIC_DATE_OFFSET,
  663:             [
  664:                 "2007-01-02",
  665:                 "2007-12-02",
  666:                 "2007-12-26",
  667:                 "2008-01-01",
  668:                 "2008-01-01 23:00:00",
  669:                 "2008-01-01 23:59:00",
  670:                 "2008-01-01 23:59:59",
  671:                 "2008-01-01 23:59:59.999000000",
  672:                 "2008-01-01 23:59:59.999999000",
  673:             ],
  674:         ),
  675:     )
  676:     def test_sub(self, arithmatic_offset_type, expected, dt):
  677:         assert dt - DateOffset(**{arithmatic_offset_type: 1}) == Timestamp(expected)
  678:         with pytest.raises(TypeError, match="Cannot subtract datetime from offset"):
  679:             DateOffset(**{arithmatic_offset_type: 1}) - dt
  680: 
  681:     @pytest.mark.parametrize(
  682:         "arithmatic_offset_type, n, expected",
  683:         zip(
  684:             _ARITHMETIC_DATE_OFFSET,
  685:             range(1, 10),
  686:             [
  687:                 "2009-01-02",
  688:                 "2008-03-02",
  689:                 "2008-01-23",
  690:                 "2008-01-06",
  691:                 "2008-01-02 05:00:00",
  692:                 "2008-01-02 00:06:00",
  693:                 "2008-01-02 00:00:07",
  694:                 "2008-01-02 00:00:00.008000000",
  695:                 "2008-01-02 00:00:00.000009000",
  696:             ],
  697:         ),
  698:     )
  699:     def test_mul_add(self, arithmatic_offset_type, n, expected, dt):
  700:         assert DateOffset(**{arithmatic_offset_type: 1}) * n + dt == Timestamp(expected)
  701:         assert n * DateOffset(**{arithmatic_offset_type: 1}) + dt == Timestamp(expected)
  702:         assert dt + DateOffset(**{arithmatic_offset_type: 1}) * n == Timestamp(expected)
  703:         assert dt + n * DateOffset(**{arithmatic_offset_type: 1}) == Timestamp(expected)
  704: 
  705:     @pytest.mark.parametrize(
  706:         "arithmatic_offset_type, n, expected",
  707:         zip(
  708:             _ARITHMETIC_DATE_OFFSET,
  709:             range(1, 10),
  710:             [
  711:                 "2007-01-02",
  712:                 "2007-11-02",
  713:                 "2007-12-12",
  714:                 "2007-12-29",
  715:                 "2008-01-01 19:00:00",
  716:                 "2008-01-01 23:54:00",
  717:                 "2008-01-01 23:59:53",
  718:                 "2008-01-01 23:59:59.992000000",
  719:                 "2008-01-01 23:59:59.999991000",
  720:             ],
  721:         ),
  722:     )
  723:     def test_mul_sub(self, arithmatic_offset_type, n, expected, dt):
  724:         assert dt - DateOffset(**{arithmatic_offset_type: 1}) * n == Timestamp(expected)
  725:         assert dt - n * DateOffset(**{arithmatic_offset_type: 1}) == Timestamp(expected)
  726: 
  727:     def test_leap_year(self):
  728:         d = datetime(2008, 1, 31)
  729:         assert (d + DateOffset(months=1)) == datetime(2008, 2, 29)
  730: 
  731:     def test_eq(self):
  732:         offset1 = DateOffset(days=1)
  733:         offset2 = DateOffset(days=365)
  734: 
  735:         assert offset1 != offset2
  736: 
  737:         assert DateOffset(milliseconds=3) != DateOffset(milliseconds=7)
  738: 
  739:     @pytest.mark.parametrize(
  740:         "offset_kwargs, expected_arg",
  741:         [
  742:             ({"microseconds": 1, "milliseconds": 1}, "2022-01-01 00:00:00.001001"),
  743:             ({"seconds": 1, "milliseconds": 1}, "2022-01-01 00:00:01.001"),
  744:             ({"minutes": 1, "milliseconds": 1}, "2022-01-01 00:01:00.001"),
  745:             ({"hours": 1, "milliseconds": 1}, "2022-01-01 01:00:00.001"),
  746:             ({"days": 1, "milliseconds": 1}, "2022-01-02 00:00:00.001"),
  747:             ({"weeks": 1, "milliseconds": 1}, "2022-01-08 00:00:00.001"),
  748:             ({"months": 1, "milliseconds": 1}, "2022-02-01 00:00:00.001"),
  749:             ({"years": 1, "milliseconds": 1}, "2023-01-01 00:00:00.001"),
  750:         ],
  751:     )
  752:     def test_milliseconds_combination(self, offset_kwargs, expected_arg):
  753:         # GH 49897
  754:         offset = DateOffset(**offset_kwargs)
  755:         ts = Timestamp("2022-01-01")
  756:         result = ts + offset
  757:         expected = Timestamp(expected_arg)
  758: 
  759:         assert result == expected
  760: 
  761:     def test_offset_invalid_arguments(self):
  762:         msg = "^Invalid argument/s or bad combination of arguments"
  763:         with pytest.raises(ValueError, match=msg):
  764:             DateOffset(picoseconds=1)
  765: 
  766: 
  767: class TestOffsetNames:
  768:     def test_get_offset_name(self):
  769:         assert BDay().freqstr == "B"
  770:         assert BDay(2).freqstr == "2B"
  771:         assert BMonthEnd().freqstr == "BME"
  772:         assert Week(weekday=0).freqstr == "W-MON"
  773:         assert Week(weekday=1).freqstr == "W-TUE"
  774:         assert Week(weekday=2).freqstr == "W-WED"
  775:         assert Week(weekday=3).freqstr == "W-THU"
  776:         assert Week(weekday=4).freqstr == "W-FRI"
  777: 
  778:         assert LastWeekOfMonth(weekday=WeekDay.SUN).freqstr == "LWOM-SUN"
  779: 
  780: 
  781: def test_get_offset():
  782:     with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):
  783:         _get_offset("gibberish")
  784:     with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):
  785:         _get_offset("QS-JAN-B")
  786: 
  787:     pairs = [
  788:         ("B", BDay()),
  789:         ("b", BDay()),
  790:         ("bme", BMonthEnd()),
  791:         ("Bme", BMonthEnd()),
  792:         ("W-MON", Week(weekday=0)),
  793:         ("W-TUE", Week(weekday=1)),
  794:         ("W-WED", Week(weekday=2)),
  795:         ("W-THU", Week(weekday=3)),
  796:         ("W-FRI", Week(weekday=4)),
  797:     ]
  798: 
  799:     for name, expected in pairs:
  800:         offset = _get_offset(name)
  801:         assert offset == expected, (
  802:             f"Expected {repr(name)} to yield {repr(expected)} "
  803:             f"(actual: {repr(offset)})"
  804:         )
  805: 
  806: 
  807: def test_get_offset_legacy():
  808:     pairs = [("w@Sat", Week(weekday=5))]
  809:     for name, expected in pairs:
  810:         with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):
  811:             _get_offset(name)
  812: 
  813: 
  814: class TestOffsetAliases:
  815:     def setup_method(self):
  816:         _offset_map.clear()
  817: 
  818:     def test_alias_equality(self):
  819:         for k, v in _offset_map.items():
  820:             if v is None:
  821:                 continue
  822:             assert k == v.copy()
  823: 
  824:     def test_rule_code(self):
  825:         lst = ["ME", "MS", "BME", "BMS", "D", "B", "h", "min", "s", "ms", "us"]
  826:         for k in lst:
  827:             assert k == _get_offset(k).rule_code
  828:             # should be cached - this is kind of an internals test...
  829:             assert k in _offset_map
  830:             assert k == (_get_offset(k) * 3).rule_code
  831: 
  832:         suffix_lst = ["MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"]
  833:         base = "W"
  834:         for v in suffix_lst:
  835:             alias = "-".join([base, v])
  836:             assert alias == _get_offset(alias).rule_code
  837:             assert alias == (_get_offset(alias) * 5).rule_code
  838: 
  839:         suffix_lst = [
  840:             "JAN",
  841:             "FEB",
  842:             "MAR",
  843:             "APR",
  844:             "MAY",
  845:             "JUN",
  846:             "JUL",
  847:             "AUG",
  848:             "SEP",
  849:             "OCT",
  850:             "NOV",
  851:             "DEC",
  852:         ]
  853:         base_lst = ["YE", "YS", "BYE", "BYS", "QE", "QS", "BQE", "BQS"]
  854:         for base in base_lst:
  855:             for v in suffix_lst:
  856:                 alias = "-".join([base, v])
  857:                 assert alias == _get_offset(alias).rule_code
  858:                 assert alias == (_get_offset(alias) * 5).rule_code
  859: 
  860: 
  861: def test_freq_offsets():
  862:     off = BDay(1, offset=timedelta(0, 1800))
  863:     assert off.freqstr == "B+30Min"
  864: 
  865:     off = BDay(1, offset=timedelta(0, -1800))
  866:     assert off.freqstr == "B-30Min"
  867: 
  868: 
  869: class TestReprNames:
  870:     def test_str_for_named_is_name(self):
  871:         # look at all the amazing combinations!
  872:         month_prefixes = ["YE", "YS", "BYE", "BYS", "QE", "BQE", "BQS", "QS"]
  873:         names = [
  874:             prefix + "-" + month
  875:             for prefix in month_prefixes
  876:             for month in [
  877:                 "JAN",
  878:                 "FEB",
  879:                 "MAR",
  880:                 "APR",
  881:                 "MAY",
  882:                 "JUN",
  883:                 "JUL",
  884:                 "AUG",
  885:                 "SEP",
  886:                 "OCT",
  887:                 "NOV",
  888:                 "DEC",
  889:             ]
  890:         ]
  891:         days = ["MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"]
  892:         names += ["W-" + day for day in days]
  893:         names += ["WOM-" + week + day for week in ("1", "2", "3", "4") for day in days]
  894:         _offset_map.clear()
  895:         for name in names:
  896:             offset = _get_offset(name)
  897:             assert offset.freqstr == name
  898: 
  899: 
  900: # ---------------------------------------------------------------------
  901: 
  902: 
  903: def test_valid_default_arguments(offset_types):
  904:     # GH#19142 check that the calling the constructors without passing
  905:     # any keyword arguments produce valid offsets
  906:     cls = offset_types
  907:     cls()
  908: 
  909: 
  910: @pytest.mark.parametrize("kwd", sorted(liboffsets._relativedelta_kwds))
  911: def test_valid_month_attributes(kwd, month_classes):
  912:     # GH#18226
  913:     cls = month_classes
  914:     # check that we cannot create e.g. MonthEnd(weeks=3)
  915:     msg = rf"__init__\(\) got an unexpected keyword argument '{kwd}'"
  916:     with pytest.raises(TypeError, match=msg):
  917:         cls(**{kwd: 3})
  918: 
  919: 
  920: def test_month_offset_name(month_classes):
  921:     # GH#33757 off.name with n != 1 should not raise AttributeError
  922:     obj = month_classes(1)
  923:     obj2 = month_classes(2)
  924:     assert obj2.name == obj.name
  925: 
  926: 
  927: @pytest.mark.parametrize("kwd", sorted(liboffsets._relativedelta_kwds))
  928: def test_valid_relativedelta_kwargs(kwd, request):
  929:     if kwd == "millisecond":
  930:         request.applymarker(
  931:             pytest.mark.xfail(
  932:                 raises=NotImplementedError,
  933:                 reason="Constructing DateOffset object with `millisecond` is not "
  934:                 "yet supported.",
  935:             )
  936:         )
  937:     # Check that all the arguments specified in liboffsets._relativedelta_kwds
  938:     # are in fact valid relativedelta keyword args
  939:     DateOffset(**{kwd: 1})
  940: 
  941: 
  942: @pytest.mark.parametrize("kwd", sorted(liboffsets._relativedelta_kwds))
  943: def test_valid_tick_attributes(kwd, tick_classes):
  944:     # GH#18226
  945:     cls = tick_classes
  946:     # check that we cannot create e.g. Hour(weeks=3)
  947:     msg = rf"__init__\(\) got an unexpected keyword argument '{kwd}'"
  948:     with pytest.raises(TypeError, match=msg):
  949:         cls(**{kwd: 3})
  950: 
  951: 
  952: def test_validate_n_error():
  953:     with pytest.raises(TypeError, match="argument must be an integer"):
  954:         DateOffset(n="Doh!")
  955: 
  956:     with pytest.raises(TypeError, match="argument must be an integer"):
  957:         MonthBegin(n=timedelta(1))
  958: 
  959:     with pytest.raises(TypeError, match="argument must be an integer"):
  960:         BDay(n=np.array([1, 2], dtype=np.int64))
  961: 
  962: 
  963: def test_require_integers(offset_types):
  964:     cls = offset_types
  965:     with pytest.raises(ValueError, match="argument must be an integer"):
  966:         cls(n=1.5)
  967: 
  968: 
  969: def test_tick_normalize_raises(tick_classes):
  970:     # check that trying to create a Tick object with normalize=True raises
  971:     # GH#21427
  972:     cls = tick_classes
  973:     msg = "Tick offset with `normalize=True` are not allowed."
  974:     with pytest.raises(ValueError, match=msg):
  975:         cls(n=3, normalize=True)
  976: 
  977: 
  978: @pytest.mark.parametrize(
  979:     "offset_kwargs, expected_arg",
  980:     [
  981:         ({"nanoseconds": 1}, "1970-01-01 00:00:00.000000001"),
  982:         ({"nanoseconds": 5}, "1970-01-01 00:00:00.000000005"),
  983:         ({"nanoseconds": -1}, "1969-12-31 23:59:59.999999999"),
  984:         ({"microseconds": 1}, "1970-01-01 00:00:00.000001"),
  985:         ({"microseconds": -1}, "1969-12-31 23:59:59.999999"),
  986:         ({"seconds": 1}, "1970-01-01 00:00:01"),
  987:         ({"seconds": -1}, "1969-12-31 23:59:59"),
  988:         ({"minutes": 1}, "1970-01-01 00:01:00"),
  989:         ({"minutes": -1}, "1969-12-31 23:59:00"),
  990:         ({"hours": 1}, "1970-01-01 01:00:00"),
  991:         ({"hours": -1}, "1969-12-31 23:00:00"),
  992:         ({"days": 1}, "1970-01-02 00:00:00"),
  993:         ({"days": -1}, "1969-12-31 00:00:00"),
  994:         ({"weeks": 1}, "1970-01-08 00:00:00"),
  995:         ({"weeks": -1}, "1969-12-25 00:00:00"),
  996:         ({"months": 1}, "1970-02-01 00:00:00"),
  997:         ({"months": -1}, "1969-12-01 00:00:00"),
  998:         ({"years": 1}, "1971-01-01 00:00:00"),
  999:         ({"years": -1}, "1969-01-01 00:00:00"),
 1000:     ],
 1001: )
 1002: def test_dateoffset_add_sub(offset_kwargs, expected_arg):
 1003:     offset = DateOffset(**offset_kwargs)
 1004:     ts = Timestamp(0)
 1005:     result = ts + offset
 1006:     expected = Timestamp(expected_arg)
 1007:     assert result == expected
 1008:     result -= offset
 1009:     assert result == ts
 1010:     result = offset + ts
 1011:     assert result == expected
 1012: 
 1013: 
 1014: def test_dateoffset_add_sub_timestamp_with_nano():
 1015:     offset = DateOffset(minutes=2, nanoseconds=9)
 1016:     ts = Timestamp(4)
 1017:     result = ts + offset
 1018:     expected = Timestamp("1970-01-01 00:02:00.000000013")
 1019:     assert result == expected
 1020:     result -= offset
 1021:     assert result == ts
 1022:     result = offset + ts
 1023:     assert result == expected
 1024: 
 1025:     offset2 = DateOffset(minutes=2, nanoseconds=9, hour=1)
 1026:     assert offset2._use_relativedelta
 1027:     with tm.assert_produces_warning(None):
 1028:         # no warning about Discarding nonzero nanoseconds
 1029:         result2 = ts + offset2
 1030:     expected2 = Timestamp("1970-01-01 01:02:00.000000013")
 1031:     assert result2 == expected2
 1032: 
 1033: 
 1034: @pytest.mark.parametrize(
 1035:     "attribute",
 1036:     [
 1037:         "hours",
 1038:         "days",
 1039:         "weeks",
 1040:         "months",
 1041:         "years",
 1042:     ],
 1043: )
 1044: def test_dateoffset_immutable(attribute):
 1045:     offset = DateOffset(**{attribute: 0})
 1046:     msg = "DateOffset objects are immutable"
 1047:     with pytest.raises(AttributeError, match=msg):
 1048:         setattr(offset, attribute, 5)
 1049: 
 1050: 
 1051: def test_dateoffset_misc():
 1052:     oset = offsets.DateOffset(months=2, days=4)
 1053:     # it works
 1054:     oset.freqstr
 1055: 
 1056:     assert not offsets.DateOffset(months=2) == 2
 1057: 
 1058: 
 1059: @pytest.mark.parametrize("n", [-1, 1, 3])
 1060: def test_construct_int_arg_no_kwargs_assumed_days(n):
 1061:     # GH 45890, 45643
 1062:     offset = DateOffset(n)
 1063:     assert offset._offset == timedelta(1)
 1064:     result = Timestamp(2022, 1, 2) + offset
 1065:     expected = Timestamp(2022, 1, 2 + n)
 1066:     assert result == expected
 1067: 
 1068: 
 1069: @pytest.mark.parametrize(
 1070:     "offset, expected",
 1071:     [
 1072:         (
 1073:             DateOffset(minutes=7, nanoseconds=18),
 1074:             Timestamp("2022-01-01 00:07:00.000000018"),
 1075:         ),
 1076:         (DateOffset(nanoseconds=3), Timestamp("2022-01-01 00:00:00.000000003")),
 1077:     ],
 1078: )
 1079: def test_dateoffset_add_sub_timestamp_series_with_nano(offset, expected):
 1080:     # GH 47856
 1081:     start_time = Timestamp("2022-01-01")
 1082:     teststamp = start_time
 1083:     testseries = Series([start_time])
 1084:     testseries = testseries + offset
 1085:     assert testseries[0] == expected
 1086:     testseries -= offset
 1087:     assert testseries[0] == teststamp
 1088:     testseries = offset + testseries
 1089:     assert testseries[0] == expected
 1090: 
 1091: 
 1092: @pytest.mark.parametrize(
 1093:     "n_months, scaling_factor, start_timestamp, expected_timestamp",
 1094:     [
 1095:         (1, 2, "2020-01-30", "2020-03-30"),
 1096:         (2, 1, "2020-01-30", "2020-03-30"),
 1097:         (1, 0, "2020-01-30", "2020-01-30"),
 1098:         (2, 0, "2020-01-30", "2020-01-30"),
 1099:         (1, -1, "2020-01-30", "2019-12-30"),
 1100:         (2, -1, "2020-01-30", "2019-11-30"),
 1101:     ],
 1102: )
 1103: def test_offset_multiplication(
 1104:     n_months, scaling_factor, start_timestamp, expected_timestamp
 1105: ):
 1106:     # GH 47953
 1107:     mo1 = DateOffset(months=n_months)
 1108: 
 1109:     startscalar = Timestamp(start_timestamp)
 1110:     startarray = Series([startscalar])
 1111: 
 1112:     resultscalar = startscalar + (mo1 * scaling_factor)
 1113:     resultarray = startarray + (mo1 * scaling_factor)
 1114: 
 1115:     expectedscalar = Timestamp(expected_timestamp)
 1116:     expectedarray = Series([expectedscalar])
 1117:     assert resultscalar == expectedscalar
 1118: 
 1119:     tm.assert_series_equal(resultarray, expectedarray)
 1120: 
 1121: 
 1122: def test_dateoffset_operations_on_dataframes():
 1123:     # GH 47953
 1124:     df = DataFrame({"T": [Timestamp("2019-04-30")], "D": [DateOffset(months=1)]})
 1125:     frameresult1 = df["T"] + 26 * df["D"]
 1126:     df2 = DataFrame(
 1127:         {
 1128:             "T": [Timestamp("2019-04-30"), Timestamp("2019-04-30")],
 1129:             "D": [DateOffset(months=1), DateOffset(months=1)],
 1130:         }
 1131:     )
 1132:     expecteddate = Timestamp("2021-06-30")
 1133:     with tm.assert_produces_warning(PerformanceWarning):
 1134:         frameresult2 = df2["T"] + 26 * df2["D"]
 1135: 
 1136:     assert frameresult1[0] == expecteddate
 1137:     assert frameresult2[0] == expecteddate
 1138: 
 1139: 
 1140: def test_is_yqm_start_end():
 1141:     freq_m = to_offset("ME")
 1142:     bm = to_offset("BME")
 1143:     qfeb = to_offset("QE-FEB")
 1144:     qsfeb = to_offset("QS-FEB")
 1145:     bq = to_offset("BQE")
 1146:     bqs_apr = to_offset("BQS-APR")
 1147:     as_nov = to_offset("YS-NOV")
 1148: 
 1149:     tests = [
 1150:         (freq_m.is_month_start(Timestamp("2013-06-01")), 1),
 1151:         (bm.is_month_start(Timestamp("2013-06-01")), 0),
 1152:         (freq_m.is_month_start(Timestamp("2013-06-03")), 0),
 1153:         (bm.is_month_start(Timestamp("2013-06-03")), 1),
 1154:         (qfeb.is_month_end(Timestamp("2013-02-28")), 1),
 1155:         (qfeb.is_quarter_end(Timestamp("2013-02-28")), 1),
 1156:         (qfeb.is_year_end(Timestamp("2013-02-28")), 1),
 1157:         (qfeb.is_month_start(Timestamp("2013-03-01")), 1),
 1158:         (qfeb.is_quarter_start(Timestamp("2013-03-01")), 1),
 1159:         (qfeb.is_year_start(Timestamp("2013-03-01")), 1),
 1160:         (qsfeb.is_month_end(Timestamp("2013-03-31")), 1),
 1161:         (qsfeb.is_quarter_end(Timestamp("2013-03-31")), 0),
 1162:         (qsfeb.is_year_end(Timestamp("2013-03-31")), 0),
 1163:         (qsfeb.is_month_start(Timestamp("2013-02-01")), 1),
 1164:         (qsfeb.is_quarter_start(Timestamp("2013-02-01")), 1),
 1165:         (qsfeb.is_year_start(Timestamp("2013-02-01")), 1),
 1166:         (bq.is_month_end(Timestamp("2013-06-30")), 0),
 1167:         (bq.is_quarter_end(Timestamp("2013-06-30")), 0),
 1168:         (bq.is_year_end(Timestamp("2013-06-30")), 0),
 1169:         (bq.is_month_end(Timestamp("2013-06-28")), 1),
 1170:         (bq.is_quarter_end(Timestamp("2013-06-28")), 1),
 1171:         (bq.is_year_end(Timestamp("2013-06-28")), 0),
 1172:         (bqs_apr.is_month_end(Timestamp("2013-06-30")), 0),
 1173:         (bqs_apr.is_quarter_end(Timestamp("2013-06-30")), 0),
 1174:         (bqs_apr.is_year_end(Timestamp("2013-06-30")), 0),
 1175:         (bqs_apr.is_month_end(Timestamp("2013-06-28")), 1),
 1176:         (bqs_apr.is_quarter_end(Timestamp("2013-06-28")), 1),
 1177:         (bqs_apr.is_year_end(Timestamp("2013-03-29")), 1),
 1178:         (as_nov.is_year_start(Timestamp("2013-11-01")), 1),
 1179:         (as_nov.is_year_end(Timestamp("2013-10-31")), 1),
 1180:         (Timestamp("2012-02-01").days_in_month, 29),
 1181:         (Timestamp("2013-02-01").days_in_month, 28),
 1182:     ]
 1183: 
 1184:     for ts, value in tests:
 1185:         assert ts == value
