    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas._libs.tslibs.ccalendar import (
   10:     DAYS,
   11:     MONTHS,
   12: )
   13: from pandas._libs.tslibs.offsets import _get_offset
   14: from pandas._libs.tslibs.period import INVALID_FREQ_ERR_MSG
   15: from pandas.compat import is_platform_windows
   16: 
   17: from pandas import (
   18:     DatetimeIndex,
   19:     Index,
   20:     RangeIndex,
   21:     Series,
   22:     Timestamp,
   23:     date_range,
   24:     period_range,
   25: )
   26: import pandas._testing as tm
   27: from pandas.core.arrays import (
   28:     DatetimeArray,
   29:     TimedeltaArray,
   30: )
   31: from pandas.core.tools.datetimes import to_datetime
   32: 
   33: from pandas.tseries import (
   34:     frequencies,
   35:     offsets,
   36: )
   37: 
   38: 
   39: @pytest.fixture(
   40:     params=[
   41:         (timedelta(1), "D"),
   42:         (timedelta(hours=1), "h"),
   43:         (timedelta(minutes=1), "min"),
   44:         (timedelta(seconds=1), "s"),
   45:         (np.timedelta64(1, "ns"), "ns"),
   46:         (timedelta(microseconds=1), "us"),
   47:         (timedelta(microseconds=1000), "ms"),
   48:     ]
   49: )
   50: def base_delta_code_pair(request):
   51:     return request.param
   52: 
   53: 
   54: freqs = (
   55:     [f"QE-{month}" for month in MONTHS]
   56:     + [f"{annual}-{month}" for annual in ["YE", "BYE"] for month in MONTHS]
   57:     + ["ME", "BME", "BMS"]
   58:     + [f"WOM-{count}{day}" for count in range(1, 5) for day in DAYS]
   59:     + [f"W-{day}" for day in DAYS]
   60: )
   61: 
   62: 
   63: @pytest.mark.parametrize("freq", freqs)
   64: @pytest.mark.parametrize("periods", [5, 7])
   65: def test_infer_freq_range(periods, freq):
   66:     freq = freq.upper()
   67: 
   68:     gen = date_range("1/1/2000", periods=periods, freq=freq)
   69:     index = DatetimeIndex(gen.values)
   70: 
   71:     if not freq.startswith("QE-"):
   72:         assert frequencies.infer_freq(index) == gen.freqstr
   73:     else:
   74:         inf_freq = frequencies.infer_freq(index)
   75:         is_dec_range = inf_freq == "QE-DEC" and gen.freqstr in (
   76:             "QE",
   77:             "QE-DEC",
   78:             "QE-SEP",
   79:             "QE-JUN",
   80:             "QE-MAR",
   81:         )
   82:         is_nov_range = inf_freq == "QE-NOV" and gen.freqstr in (
   83:             "QE-NOV",
   84:             "QE-AUG",
   85:             "QE-MAY",
   86:             "QE-FEB",
   87:         )
   88:         is_oct_range = inf_freq == "QE-OCT" and gen.freqstr in (
   89:             "QE-OCT",
   90:             "QE-JUL",
   91:             "QE-APR",
   92:             "QE-JAN",
   93:         )
   94:         assert is_dec_range or is_nov_range or is_oct_range
   95: 
   96: 
   97: def test_raise_if_period_index():
   98:     index = period_range(start="1/1/1990", periods=20, freq="M")
   99:     msg = "Check the `freq` attribute instead of using infer_freq"
  100: 
  101:     with pytest.raises(TypeError, match=msg):
  102:         frequencies.infer_freq(index)
  103: 
  104: 
  105: def test_raise_if_too_few():
  106:     index = DatetimeIndex(["12/31/1998", "1/3/1999"])
  107:     msg = "Need at least 3 dates to infer frequency"
  108: 
  109:     with pytest.raises(ValueError, match=msg):
  110:         frequencies.infer_freq(index)
  111: 
  112: 
  113: def test_business_daily():
  114:     index = DatetimeIndex(["01/01/1999", "1/4/1999", "1/5/1999"])
  115:     assert frequencies.infer_freq(index) == "B"
  116: 
  117: 
  118: def test_business_daily_look_alike():
  119:     # see gh-16624
  120:     #
  121:     # Do not infer "B when "weekend" (2-day gap) in wrong place.
  122:     index = DatetimeIndex(["12/31/1998", "1/3/1999", "1/4/1999"])
  123:     assert frequencies.infer_freq(index) is None
  124: 
  125: 
  126: def test_day_corner():
  127:     index = DatetimeIndex(["1/1/2000", "1/2/2000", "1/3/2000"])
  128:     assert frequencies.infer_freq(index) == "D"
  129: 
  130: 
  131: def test_non_datetime_index():
  132:     dates = to_datetime(["1/1/2000", "1/2/2000", "1/3/2000"])
  133:     assert frequencies.infer_freq(dates) == "D"
  134: 
  135: 
  136: def test_fifth_week_of_month_infer():
  137:     # see gh-9425
  138:     #
  139:     # Only attempt to infer up to WOM-4.
  140:     index = DatetimeIndex(["2014-03-31", "2014-06-30", "2015-03-30"])
  141:     assert frequencies.infer_freq(index) is None
  142: 
  143: 
  144: def test_week_of_month_fake():
  145:     # All of these dates are on same day
  146:     # of week and are 4 or 5 weeks apart.
  147:     index = DatetimeIndex(["2013-08-27", "2013-10-01", "2013-10-29", "2013-11-26"])
  148:     assert frequencies.infer_freq(index) != "WOM-4TUE"
  149: 
  150: 
  151: def test_fifth_week_of_month():
  152:     # see gh-9425
  153:     #
  154:     # Only supports freq up to WOM-4.
  155:     msg = (
  156:         "Of the four parameters: start, end, periods, "
  157:         "and freq, exactly three must be specified"
  158:     )
  159: 
  160:     with pytest.raises(ValueError, match=msg):
  161:         date_range("2014-01-01", freq="WOM-5MON")
  162: 
  163: 
  164: def test_monthly_ambiguous():
  165:     rng = DatetimeIndex(["1/31/2000", "2/29/2000", "3/31/2000"])
  166:     assert rng.inferred_freq == "ME"
  167: 
  168: 
  169: def test_annual_ambiguous():
  170:     rng = DatetimeIndex(["1/31/2000", "1/31/2001", "1/31/2002"])
  171:     assert rng.inferred_freq == "YE-JAN"
  172: 
  173: 
  174: @pytest.mark.parametrize("count", range(1, 5))
  175: def test_infer_freq_delta(base_delta_code_pair, count):
  176:     b = Timestamp(datetime.now())
  177:     base_delta, code = base_delta_code_pair
  178: 
  179:     inc = base_delta * count
  180:     index = DatetimeIndex([b + inc * j for j in range(3)])
  181: 
  182:     exp_freq = f"{count:d}{code}" if count > 1 else code
  183:     assert frequencies.infer_freq(index) == exp_freq
  184: 
  185: 
  186: @pytest.mark.parametrize(
  187:     "constructor",
  188:     [
  189:         lambda now, delta: DatetimeIndex(
  190:             [now + delta * 7] + [now + delta * j for j in range(3)]
  191:         ),
  192:         lambda now, delta: DatetimeIndex(
  193:             [now + delta * j for j in range(3)] + [now + delta * 7]
  194:         ),
  195:     ],
  196: )
  197: def test_infer_freq_custom(base_delta_code_pair, constructor):
  198:     b = Timestamp(datetime.now())
  199:     base_delta, _ = base_delta_code_pair
  200: 
  201:     index = constructor(b, base_delta)
  202:     assert frequencies.infer_freq(index) is None
  203: 
  204: 
  205: @pytest.mark.parametrize(
  206:     "freq,expected", [("Q", "QE-DEC"), ("Q-NOV", "QE-NOV"), ("Q-OCT", "QE-OCT")]
  207: )
  208: def test_infer_freq_index(freq, expected):
  209:     rng = period_range("1959Q2", "2009Q3", freq=freq)
  210:     with tm.assert_produces_warning(FutureWarning, match="Dtype inference"):
  211:         rng = Index(rng.to_timestamp("D", how="e").astype(object))
  212: 
  213:     assert rng.inferred_freq == expected
  214: 
  215: 
  216: @pytest.mark.parametrize(
  217:     "expected,dates",
  218:     list(
  219:         {
  220:             "YS-JAN": ["2009-01-01", "2010-01-01", "2011-01-01", "2012-01-01"],
  221:             "QE-OCT": ["2009-01-31", "2009-04-30", "2009-07-31", "2009-10-31"],
  222:             "ME": ["2010-11-30", "2010-12-31", "2011-01-31", "2011-02-28"],
  223:             "W-SAT": ["2010-12-25", "2011-01-01", "2011-01-08", "2011-01-15"],
  224:             "D": ["2011-01-01", "2011-01-02", "2011-01-03", "2011-01-04"],
  225:             "h": [
  226:                 "2011-12-31 22:00",
  227:                 "2011-12-31 23:00",
  228:                 "2012-01-01 00:00",
  229:                 "2012-01-01 01:00",
  230:             ],
  231:         }.items()
  232:     ),
  233: )
  234: @pytest.mark.parametrize("unit", ["s", "ms", "us", "ns"])
  235: def test_infer_freq_tz(tz_naive_fixture, expected, dates, unit):
  236:     # see gh-7310, GH#55609
  237:     tz = tz_naive_fixture
  238:     idx = DatetimeIndex(dates, tz=tz).as_unit(unit)
  239:     assert idx.inferred_freq == expected
  240: 
  241: 
  242: def test_infer_freq_tz_series(tz_naive_fixture):
  243:     # infer_freq should work with both tz-naive and tz-aware series. See gh-52456
  244:     tz = tz_naive_fixture
  245:     idx = date_range("2021-01-01", "2021-01-04", tz=tz)
  246:     series = idx.to_series().reset_index(drop=True)
  247:     inferred_freq = frequencies.infer_freq(series)
  248:     assert inferred_freq == "D"
  249: 
  250: 
  251: @pytest.mark.parametrize(
  252:     "date_pair",
  253:     [
  254:         ["2013-11-02", "2013-11-5"],  # Fall DST
  255:         ["2014-03-08", "2014-03-11"],  # Spring DST
  256:         ["2014-01-01", "2014-01-03"],  # Regular Time
  257:     ],
  258: )
  259: @pytest.mark.parametrize(
  260:     "freq",
  261:     ["h", "3h", "10min", "3601s", "3600001ms", "3600000001us", "3600000000001ns"],
  262: )
  263: def test_infer_freq_tz_transition(tz_naive_fixture, date_pair, freq):
  264:     # see gh-8772
  265:     tz = tz_naive_fixture
  266:     idx = date_range(date_pair[0], date_pair[1], freq=freq, tz=tz)
  267:     assert idx.inferred_freq == freq
  268: 
  269: 
  270: def test_infer_freq_tz_transition_custom():
  271:     index = date_range("2013-11-03", periods=5, freq="3h").tz_localize(
  272:         "America/Chicago"
  273:     )
  274:     assert index.inferred_freq is None
  275: 
  276: 
  277: @pytest.mark.parametrize(
  278:     "data,expected",
  279:     [
  280:         # Hourly freq in a day must result in "h"
  281:         (
  282:             [
  283:                 "2014-07-01 09:00",
  284:                 "2014-07-01 10:00",
  285:                 "2014-07-01 11:00",
  286:                 "2014-07-01 12:00",
  287:                 "2014-07-01 13:00",
  288:                 "2014-07-01 14:00",
  289:             ],
  290:             "h",
  291:         ),
  292:         (
  293:             [
  294:                 "2014-07-01 09:00",
  295:                 "2014-07-01 10:00",
  296:                 "2014-07-01 11:00",
  297:                 "2014-07-01 12:00",
  298:                 "2014-07-01 13:00",
  299:                 "2014-07-01 14:00",
  300:                 "2014-07-01 15:00",
  301:                 "2014-07-01 16:00",
  302:                 "2014-07-02 09:00",
  303:                 "2014-07-02 10:00",
  304:                 "2014-07-02 11:00",
  305:             ],
  306:             "bh",
  307:         ),
  308:         (
  309:             [
  310:                 "2014-07-04 09:00",
  311:                 "2014-07-04 10:00",
  312:                 "2014-07-04 11:00",
  313:                 "2014-07-04 12:00",
  314:                 "2014-07-04 13:00",
  315:                 "2014-07-04 14:00",
  316:                 "2014-07-04 15:00",
  317:                 "2014-07-04 16:00",
  318:                 "2014-07-07 09:00",
  319:                 "2014-07-07 10:00",
  320:                 "2014-07-07 11:00",
  321:             ],
  322:             "bh",
  323:         ),
  324:         (
  325:             [
  326:                 "2014-07-04 09:00",
  327:                 "2014-07-04 10:00",
  328:                 "2014-07-04 11:00",
  329:                 "2014-07-04 12:00",
  330:                 "2014-07-04 13:00",
  331:                 "2014-07-04 14:00",
  332:                 "2014-07-04 15:00",
  333:                 "2014-07-04 16:00",
  334:                 "2014-07-07 09:00",
  335:                 "2014-07-07 10:00",
  336:                 "2014-07-07 11:00",
  337:                 "2014-07-07 12:00",
  338:                 "2014-07-07 13:00",
  339:                 "2014-07-07 14:00",
  340:                 "2014-07-07 15:00",
  341:                 "2014-07-07 16:00",
  342:                 "2014-07-08 09:00",
  343:                 "2014-07-08 10:00",
  344:                 "2014-07-08 11:00",
  345:                 "2014-07-08 12:00",
  346:                 "2014-07-08 13:00",
  347:                 "2014-07-08 14:00",
  348:                 "2014-07-08 15:00",
  349:                 "2014-07-08 16:00",
  350:             ],
  351:             "bh",
  352:         ),
  353:     ],
  354: )
  355: def test_infer_freq_business_hour(data, expected):
  356:     # see gh-7905
  357:     idx = DatetimeIndex(data)
  358:     assert idx.inferred_freq == expected
  359: 
  360: 
  361: def test_not_monotonic():
  362:     rng = DatetimeIndex(["1/31/2000", "1/31/2001", "1/31/2002"])
  363:     rng = rng[::-1]
  364: 
  365:     assert rng.inferred_freq == "-1YE-JAN"
  366: 
  367: 
  368: def test_non_datetime_index2():
  369:     rng = DatetimeIndex(["1/31/2000", "1/31/2001", "1/31/2002"])
  370:     vals = rng.to_pydatetime()
  371: 
  372:     result = frequencies.infer_freq(vals)
  373:     assert result == rng.inferred_freq
  374: 
  375: 
  376: @pytest.mark.parametrize(
  377:     "idx",
  378:     [
  379:         Index(np.arange(5), dtype=np.int64),
  380:         Index(np.arange(5), dtype=np.float64),
  381:         period_range("2020-01-01", periods=5),
  382:         RangeIndex(5),
  383:     ],
  384: )
  385: def test_invalid_index_types(idx):
  386:     # see gh-48439
  387:     msg = "|".join(
  388:         [
  389:             "cannot infer freq from a non-convertible",
  390:             "Check the `freq` attribute instead of using infer_freq",
  391:         ]
  392:     )
  393: 
  394:     with pytest.raises(TypeError, match=msg):
  395:         frequencies.infer_freq(idx)
  396: 
  397: 
  398: @pytest.mark.skipif(is_platform_windows(), reason="see gh-10822: Windows issue")
  399: def test_invalid_index_types_unicode():
  400:     # see gh-10822
  401:     #
  402:     # Odd error message on conversions to datetime for unicode.
  403:     msg = "Unknown datetime string format"
  404: 
  405:     with pytest.raises(ValueError, match=msg):
  406:         frequencies.infer_freq(Index(["ZqgszYBfuL"]))
  407: 
  408: 
  409: def test_string_datetime_like_compat():
  410:     # see gh-6463
  411:     data = ["2004-01", "2004-02", "2004-03", "2004-04"]
  412: 
  413:     expected = frequencies.infer_freq(data)
  414:     result = frequencies.infer_freq(Index(data))
  415: 
  416:     assert result == expected
  417: 
  418: 
  419: def test_series():
  420:     # see gh-6407
  421:     s = Series(date_range("20130101", "20130110"))
  422:     inferred = frequencies.infer_freq(s)
  423:     assert inferred == "D"
  424: 
  425: 
  426: @pytest.mark.parametrize("end", [10, 10.0])
  427: def test_series_invalid_type(end):
  428:     # see gh-6407
  429:     msg = "cannot infer freq from a non-convertible dtype on a Series"
  430:     s = Series(np.arange(end))
  431: 
  432:     with pytest.raises(TypeError, match=msg):
  433:         frequencies.infer_freq(s)
  434: 
  435: 
  436: def test_series_inconvertible_string(using_infer_string):
  437:     # see gh-6407
  438:     if using_infer_string:
  439:         msg = "cannot infer freq from"
  440: 
  441:         with pytest.raises(TypeError, match=msg):
  442:             frequencies.infer_freq(Series(["foo", "bar"]))
  443:     else:
  444:         msg = "Unknown datetime string format"
  445: 
  446:         with pytest.raises(ValueError, match=msg):
  447:             frequencies.infer_freq(Series(["foo", "bar"]))
  448: 
  449: 
  450: @pytest.mark.parametrize("freq", [None, "ms"])
  451: def test_series_period_index(freq):
  452:     # see gh-6407
  453:     #
  454:     # Cannot infer on PeriodIndex
  455:     msg = "cannot infer freq from a non-convertible dtype on a Series"
  456:     s = Series(period_range("2013", periods=10, freq=freq))
  457: 
  458:     with pytest.raises(TypeError, match=msg):
  459:         frequencies.infer_freq(s)
  460: 
  461: 
  462: @pytest.mark.parametrize("freq", ["ME", "ms", "s"])
  463: def test_series_datetime_index(freq):
  464:     s = Series(date_range("20130101", periods=10, freq=freq))
  465:     inferred = frequencies.infer_freq(s)
  466:     assert inferred == freq
  467: 
  468: 
  469: @pytest.mark.parametrize(
  470:     "offset_func",
  471:     [
  472:         _get_offset,
  473:         lambda freq: date_range("2011-01-01", periods=5, freq=freq),
  474:     ],
  475: )
  476: @pytest.mark.parametrize(
  477:     "freq",
  478:     [
  479:         "WEEKDAY",
  480:         "EOM",
  481:         "W@MON",
  482:         "W@TUE",
  483:         "W@WED",
  484:         "W@THU",
  485:         "W@FRI",
  486:         "W@SAT",
  487:         "W@SUN",
  488:         "QE@JAN",
  489:         "QE@FEB",
  490:         "QE@MAR",
  491:         "YE@JAN",
  492:         "YE@FEB",
  493:         "YE@MAR",
  494:         "YE@APR",
  495:         "YE@MAY",
  496:         "YE@JUN",
  497:         "YE@JUL",
  498:         "YE@AUG",
  499:         "YE@SEP",
  500:         "YE@OCT",
  501:         "YE@NOV",
  502:         "YE@DEC",
  503:         "YE@JAN",
  504:         "WOM@1MON",
  505:         "WOM@2MON",
  506:         "WOM@3MON",
  507:         "WOM@4MON",
  508:         "WOM@1TUE",
  509:         "WOM@2TUE",
  510:         "WOM@3TUE",
  511:         "WOM@4TUE",
  512:         "WOM@1WED",
  513:         "WOM@2WED",
  514:         "WOM@3WED",
  515:         "WOM@4WED",
  516:         "WOM@1THU",
  517:         "WOM@2THU",
  518:         "WOM@3THU",
  519:         "WOM@4THU",
  520:         "WOM@1FRI",
  521:         "WOM@2FRI",
  522:         "WOM@3FRI",
  523:         "WOM@4FRI",
  524:     ],
  525: )
  526: def test_legacy_offset_warnings(offset_func, freq):
  527:     with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):
  528:         offset_func(freq)
  529: 
  530: 
  531: def test_ms_vs_capital_ms():
  532:     left = _get_offset("ms")
  533:     right = _get_offset("MS")
  534: 
  535:     assert left == offsets.Milli()
  536:     assert right == offsets.MonthBegin()
  537: 
  538: 
  539: def test_infer_freq_non_nano():
  540:     arr = np.arange(10).astype(np.int64).view("M8[s]")
  541:     dta = DatetimeArray._simple_new(arr, dtype=arr.dtype)
  542:     res = frequencies.infer_freq(dta)
  543:     assert res == "s"
  544: 
  545:     arr2 = arr.view("m8[ms]")
  546:     tda = TimedeltaArray._simple_new(arr2, dtype=arr2.dtype)
  547:     res2 = frequencies.infer_freq(tda)
  548:     assert res2 == "ms"
  549: 
  550: 
  551: def test_infer_freq_non_nano_tzaware(tz_aware_fixture):
  552:     tz = tz_aware_fixture
  553: 
  554:     dti = date_range("2016-01-01", periods=365, freq="B", tz=tz)
  555:     dta = dti._data.as_unit("s")
  556: 
  557:     res = frequencies.infer_freq(dta)
  558:     assert res == "B"
