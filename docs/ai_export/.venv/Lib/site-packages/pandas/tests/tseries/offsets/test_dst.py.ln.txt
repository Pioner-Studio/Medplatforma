    1: """
    2: Tests for DateOffset additions over Daylight Savings Time
    3: """
    4: from datetime import timedelta
    5: 
    6: import pytest
    7: import pytz
    8: 
    9: from pandas._libs.tslibs import Timestamp
   10: from pandas._libs.tslibs.offsets import (
   11:     BMonthBegin,
   12:     BMonthEnd,
   13:     BQuarterBegin,
   14:     BQuarterEnd,
   15:     BYearBegin,
   16:     BYearEnd,
   17:     CBMonthBegin,
   18:     CBMonthEnd,
   19:     CustomBusinessDay,
   20:     DateOffset,
   21:     Day,
   22:     MonthBegin,
   23:     MonthEnd,
   24:     QuarterBegin,
   25:     QuarterEnd,
   26:     SemiMonthBegin,
   27:     SemiMonthEnd,
   28:     Week,
   29:     YearBegin,
   30:     YearEnd,
   31: )
   32: from pandas.errors import PerformanceWarning
   33: 
   34: from pandas import DatetimeIndex
   35: import pandas._testing as tm
   36: from pandas.util.version import Version
   37: 
   38: # error: Module has no attribute "__version__"
   39: pytz_version = Version(pytz.__version__)  # type: ignore[attr-defined]
   40: 
   41: 
   42: def get_utc_offset_hours(ts):
   43:     # take a Timestamp and compute total hours of utc offset
   44:     o = ts.utcoffset()
   45:     return (o.days * 24 * 3600 + o.seconds) / 3600.0
   46: 
   47: 
   48: class TestDST:
   49:     # one microsecond before the DST transition
   50:     ts_pre_fallback = "2013-11-03 01:59:59.999999"
   51:     ts_pre_springfwd = "2013-03-10 01:59:59.999999"
   52: 
   53:     # test both basic names and dateutil timezones
   54:     timezone_utc_offsets = {
   55:         "US/Eastern": {"utc_offset_daylight": -4, "utc_offset_standard": -5},
   56:         "dateutil/US/Pacific": {"utc_offset_daylight": -7, "utc_offset_standard": -8},
   57:     }
   58:     valid_date_offsets_singular = [
   59:         "weekday",
   60:         "day",
   61:         "hour",
   62:         "minute",
   63:         "second",
   64:         "microsecond",
   65:     ]
   66:     valid_date_offsets_plural = [
   67:         "weeks",
   68:         "days",
   69:         "hours",
   70:         "minutes",
   71:         "seconds",
   72:         "milliseconds",
   73:         "microseconds",
   74:     ]
   75: 
   76:     def _test_all_offsets(self, n, **kwds):
   77:         valid_offsets = (
   78:             self.valid_date_offsets_plural
   79:             if n > 1
   80:             else self.valid_date_offsets_singular
   81:         )
   82: 
   83:         for name in valid_offsets:
   84:             self._test_offset(offset_name=name, offset_n=n, **kwds)
   85: 
   86:     def _test_offset(self, offset_name, offset_n, tstart, expected_utc_offset):
   87:         offset = DateOffset(**{offset_name: offset_n})
   88: 
   89:         if (
   90:             offset_name in ["hour", "minute", "second", "microsecond"]
   91:             and offset_n == 1
   92:             and tstart == Timestamp("2013-11-03 01:59:59.999999-0500", tz="US/Eastern")
   93:         ):
   94:             # This addition results in an ambiguous wall time
   95:             err_msg = {
   96:                 "hour": "2013-11-03 01:59:59.999999",
   97:                 "minute": "2013-11-03 01:01:59.999999",
   98:                 "second": "2013-11-03 01:59:01.999999",
   99:                 "microsecond": "2013-11-03 01:59:59.000001",
  100:             }[offset_name]
  101:             with pytest.raises(pytz.AmbiguousTimeError, match=err_msg):
  102:                 tstart + offset
  103:             # While we're here, let's check that we get the same behavior in a
  104:             #  vectorized path
  105:             dti = DatetimeIndex([tstart])
  106:             warn_msg = "Non-vectorized DateOffset"
  107:             with pytest.raises(pytz.AmbiguousTimeError, match=err_msg):
  108:                 with tm.assert_produces_warning(PerformanceWarning, match=warn_msg):
  109:                     dti + offset
  110:             return
  111: 
  112:         t = tstart + offset
  113:         if expected_utc_offset is not None:
  114:             assert get_utc_offset_hours(t) == expected_utc_offset
  115: 
  116:         if offset_name == "weeks":
  117:             # dates should match
  118:             assert t.date() == timedelta(days=7 * offset.kwds["weeks"]) + tstart.date()
  119:             # expect the same day of week, hour of day, minute, second, ...
  120:             assert (
  121:                 t.dayofweek == tstart.dayofweek
  122:                 and t.hour == tstart.hour
  123:                 and t.minute == tstart.minute
  124:                 and t.second == tstart.second
  125:             )
  126:         elif offset_name == "days":
  127:             # dates should match
  128:             assert timedelta(offset.kwds["days"]) + tstart.date() == t.date()
  129:             # expect the same hour of day, minute, second, ...
  130:             assert (
  131:                 t.hour == tstart.hour
  132:                 and t.minute == tstart.minute
  133:                 and t.second == tstart.second
  134:             )
  135:         elif offset_name in self.valid_date_offsets_singular:
  136:             # expect the singular offset value to match between tstart and t
  137:             datepart_offset = getattr(
  138:                 t, offset_name if offset_name != "weekday" else "dayofweek"
  139:             )
  140:             assert datepart_offset == offset.kwds[offset_name]
  141:         else:
  142:             # the offset should be the same as if it was done in UTC
  143:             assert t == (tstart.tz_convert("UTC") + offset).tz_convert("US/Pacific")
  144: 
  145:     def _make_timestamp(self, string, hrs_offset, tz):
  146:         if hrs_offset >= 0:
  147:             offset_string = f"{hrs_offset:02d}00"
  148:         else:
  149:             offset_string = f"-{(hrs_offset * -1):02}00"
  150:         return Timestamp(string + offset_string).tz_convert(tz)
  151: 
  152:     def test_springforward_plural(self):
  153:         # test moving from standard to daylight savings
  154:         for tz, utc_offsets in self.timezone_utc_offsets.items():
  155:             hrs_pre = utc_offsets["utc_offset_standard"]
  156:             hrs_post = utc_offsets["utc_offset_daylight"]
  157:             self._test_all_offsets(
  158:                 n=3,
  159:                 tstart=self._make_timestamp(self.ts_pre_springfwd, hrs_pre, tz),
  160:                 expected_utc_offset=hrs_post,
  161:             )
  162: 
  163:     def test_fallback_singular(self):
  164:         # in the case of singular offsets, we don't necessarily know which utc
  165:         # offset the new Timestamp will wind up in (the tz for 1 month may be
  166:         # different from 1 second) so we don't specify an expected_utc_offset
  167:         for tz, utc_offsets in self.timezone_utc_offsets.items():
  168:             hrs_pre = utc_offsets["utc_offset_standard"]
  169:             self._test_all_offsets(
  170:                 n=1,
  171:                 tstart=self._make_timestamp(self.ts_pre_fallback, hrs_pre, tz),
  172:                 expected_utc_offset=None,
  173:             )
  174: 
  175:     def test_springforward_singular(self):
  176:         for tz, utc_offsets in self.timezone_utc_offsets.items():
  177:             hrs_pre = utc_offsets["utc_offset_standard"]
  178:             self._test_all_offsets(
  179:                 n=1,
  180:                 tstart=self._make_timestamp(self.ts_pre_springfwd, hrs_pre, tz),
  181:                 expected_utc_offset=None,
  182:             )
  183: 
  184:     offset_classes = {
  185:         MonthBegin: ["11/2/2012", "12/1/2012"],
  186:         MonthEnd: ["11/2/2012", "11/30/2012"],
  187:         BMonthBegin: ["11/2/2012", "12/3/2012"],
  188:         BMonthEnd: ["11/2/2012", "11/30/2012"],
  189:         CBMonthBegin: ["11/2/2012", "12/3/2012"],
  190:         CBMonthEnd: ["11/2/2012", "11/30/2012"],
  191:         SemiMonthBegin: ["11/2/2012", "11/15/2012"],
  192:         SemiMonthEnd: ["11/2/2012", "11/15/2012"],
  193:         Week: ["11/2/2012", "11/9/2012"],
  194:         YearBegin: ["11/2/2012", "1/1/2013"],
  195:         YearEnd: ["11/2/2012", "12/31/2012"],
  196:         BYearBegin: ["11/2/2012", "1/1/2013"],
  197:         BYearEnd: ["11/2/2012", "12/31/2012"],
  198:         QuarterBegin: ["11/2/2012", "12/1/2012"],
  199:         QuarterEnd: ["11/2/2012", "12/31/2012"],
  200:         BQuarterBegin: ["11/2/2012", "12/3/2012"],
  201:         BQuarterEnd: ["11/2/2012", "12/31/2012"],
  202:         Day: ["11/4/2012", "11/4/2012 23:00"],
  203:     }.items()
  204: 
  205:     @pytest.mark.parametrize("tup", offset_classes)
  206:     def test_all_offset_classes(self, tup):
  207:         offset, test_values = tup
  208: 
  209:         first = Timestamp(test_values[0], tz="US/Eastern") + offset()
  210:         second = Timestamp(test_values[1], tz="US/Eastern")
  211:         assert first == second
  212: 
  213: 
  214: @pytest.mark.parametrize(
  215:     "original_dt, target_dt, offset, tz",
  216:     [
  217:         pytest.param(
  218:             Timestamp("1900-01-01"),
  219:             Timestamp("1905-07-01"),
  220:             MonthBegin(66),
  221:             "Africa/Lagos",
  222:             marks=pytest.mark.xfail(
  223:                 pytz_version < Version("2020.5") or pytz_version == Version("2022.2"),
  224:                 reason="GH#41906: pytz utc transition dates changed",
  225:             ),
  226:         ),
  227:         (
  228:             Timestamp("2021-10-01 01:15"),
  229:             Timestamp("2021-10-31 01:15"),
  230:             MonthEnd(1),
  231:             "Europe/London",
  232:         ),
  233:         (
  234:             Timestamp("2010-12-05 02:59"),
  235:             Timestamp("2010-10-31 02:59"),
  236:             SemiMonthEnd(-3),
  237:             "Europe/Paris",
  238:         ),
  239:         (
  240:             Timestamp("2021-10-31 01:20"),
  241:             Timestamp("2021-11-07 01:20"),
  242:             CustomBusinessDay(2, weekmask="Sun Mon"),
  243:             "US/Eastern",
  244:         ),
  245:         (
  246:             Timestamp("2020-04-03 01:30"),
  247:             Timestamp("2020-11-01 01:30"),
  248:             YearBegin(1, month=11),
  249:             "America/Chicago",
  250:         ),
  251:     ],
  252: )
  253: def test_nontick_offset_with_ambiguous_time_error(original_dt, target_dt, offset, tz):
  254:     # .apply for non-Tick offsets throws AmbiguousTimeError when the target dt
  255:     # is dst-ambiguous
  256:     localized_dt = original_dt.tz_localize(tz)
  257: 
  258:     msg = f"Cannot infer dst time from {target_dt}, try using the 'ambiguous' argument"
  259:     with pytest.raises(pytz.AmbiguousTimeError, match=msg):
  260:         localized_dt + offset
