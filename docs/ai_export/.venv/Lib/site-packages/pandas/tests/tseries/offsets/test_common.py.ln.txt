    1: from datetime import datetime
    2: 
    3: from dateutil.tz.tz import tzlocal
    4: import pytest
    5: 
    6: from pandas._libs.tslibs import (
    7:     OutOfBoundsDatetime,
    8:     Timestamp,
    9: )
   10: from pandas.compat import (
   11:     IS64,
   12:     is_platform_windows,
   13: )
   14: 
   15: from pandas.tseries.offsets import (
   16:     FY5253,
   17:     BDay,
   18:     BMonthBegin,
   19:     BMonthEnd,
   20:     BQuarterBegin,
   21:     BQuarterEnd,
   22:     BusinessHour,
   23:     BYearBegin,
   24:     BYearEnd,
   25:     CBMonthBegin,
   26:     CBMonthEnd,
   27:     CDay,
   28:     CustomBusinessHour,
   29:     DateOffset,
   30:     FY5253Quarter,
   31:     LastWeekOfMonth,
   32:     MonthBegin,
   33:     MonthEnd,
   34:     QuarterEnd,
   35:     SemiMonthBegin,
   36:     SemiMonthEnd,
   37:     Week,
   38:     WeekOfMonth,
   39:     YearBegin,
   40:     YearEnd,
   41: )
   42: 
   43: 
   44: def _get_offset(klass, value=1, normalize=False):
   45:     # create instance from offset class
   46:     if klass is FY5253:
   47:         klass = klass(
   48:             n=value,
   49:             startingMonth=1,
   50:             weekday=1,
   51:             variation="last",
   52:             normalize=normalize,
   53:         )
   54:     elif klass is FY5253Quarter:
   55:         klass = klass(
   56:             n=value,
   57:             startingMonth=1,
   58:             weekday=1,
   59:             qtr_with_extra_week=1,
   60:             variation="last",
   61:             normalize=normalize,
   62:         )
   63:     elif klass is LastWeekOfMonth:
   64:         klass = klass(n=value, weekday=5, normalize=normalize)
   65:     elif klass is WeekOfMonth:
   66:         klass = klass(n=value, week=1, weekday=5, normalize=normalize)
   67:     elif klass is Week:
   68:         klass = klass(n=value, weekday=5, normalize=normalize)
   69:     elif klass is DateOffset:
   70:         klass = klass(days=value, normalize=normalize)
   71:     else:
   72:         klass = klass(value, normalize=normalize)
   73:     return klass
   74: 
   75: 
   76: @pytest.fixture(
   77:     params=[
   78:         BDay,
   79:         BusinessHour,
   80:         BMonthEnd,
   81:         BMonthBegin,
   82:         BQuarterEnd,
   83:         BQuarterBegin,
   84:         BYearEnd,
   85:         BYearBegin,
   86:         CDay,
   87:         CustomBusinessHour,
   88:         CBMonthEnd,
   89:         CBMonthBegin,
   90:         MonthEnd,
   91:         MonthBegin,
   92:         SemiMonthBegin,
   93:         SemiMonthEnd,
   94:         QuarterEnd,
   95:         LastWeekOfMonth,
   96:         WeekOfMonth,
   97:         Week,
   98:         YearBegin,
   99:         YearEnd,
  100:         FY5253,
  101:         FY5253Quarter,
  102:         DateOffset,
  103:     ]
  104: )
  105: def _offset(request):
  106:     return request.param
  107: 
  108: 
  109: @pytest.fixture
  110: def dt(_offset):
  111:     if _offset in (CBMonthBegin, CBMonthEnd, BDay):
  112:         return Timestamp(2008, 1, 1)
  113:     elif _offset is (CustomBusinessHour, BusinessHour):
  114:         return Timestamp(2014, 7, 1, 10, 00)
  115:     return Timestamp(2008, 1, 2)
  116: 
  117: 
  118: def test_apply_out_of_range(request, tz_naive_fixture, _offset):
  119:     tz = tz_naive_fixture
  120: 
  121:     # try to create an out-of-bounds result timestamp; if we can't create
  122:     # the offset skip
  123:     try:
  124:         if _offset in (BusinessHour, CustomBusinessHour):
  125:             # Using 10000 in BusinessHour fails in tz check because of DST
  126:             # difference
  127:             offset = _get_offset(_offset, value=100000)
  128:         else:
  129:             offset = _get_offset(_offset, value=10000)
  130: 
  131:         result = Timestamp("20080101") + offset
  132:         assert isinstance(result, datetime)
  133:         assert result.tzinfo is None
  134: 
  135:         # Check tz is preserved
  136:         t = Timestamp("20080101", tz=tz)
  137:         result = t + offset
  138:         assert isinstance(result, datetime)
  139:         if tz is not None:
  140:             assert t.tzinfo is not None
  141: 
  142:         if isinstance(tz, tzlocal) and not IS64 and _offset is not DateOffset:
  143:             # If we hit OutOfBoundsDatetime on non-64 bit machines
  144:             # we'll drop out of the try clause before the next test
  145:             request.applymarker(
  146:                 pytest.mark.xfail(reason="OverflowError inside tzlocal past 2038")
  147:             )
  148:         elif (
  149:             isinstance(tz, tzlocal)
  150:             and is_platform_windows()
  151:             and _offset in (QuarterEnd, BQuarterBegin, BQuarterEnd)
  152:         ):
  153:             request.applymarker(
  154:                 pytest.mark.xfail(reason="After GH#49737 t.tzinfo is None on CI")
  155:             )
  156:         assert str(t.tzinfo) == str(result.tzinfo)
  157: 
  158:     except OutOfBoundsDatetime:
  159:         pass
  160:     except (ValueError, KeyError):
  161:         # we are creating an invalid offset
  162:         # so ignore
  163:         pass
  164: 
  165: 
  166: def test_offsets_compare_equal(_offset):
  167:     # root cause of GH#456: __ne__ was not implemented
  168:     offset1 = _offset()
  169:     offset2 = _offset()
  170:     assert not offset1 != offset2
  171:     assert offset1 == offset2
  172: 
  173: 
  174: @pytest.mark.parametrize(
  175:     "date, offset2",
  176:     [
  177:         [Timestamp(2008, 1, 1), BDay(2)],
  178:         [Timestamp(2014, 7, 1, 10, 00), BusinessHour(n=3)],
  179:         [
  180:             Timestamp(2014, 7, 1, 10),
  181:             CustomBusinessHour(
  182:                 holidays=["2014-06-27", Timestamp(2014, 6, 30), Timestamp("2014-07-02")]
  183:             ),
  184:         ],
  185:         [Timestamp(2008, 1, 2), SemiMonthEnd(2)],
  186:         [Timestamp(2008, 1, 2), SemiMonthBegin(2)],
  187:         [Timestamp(2008, 1, 2), Week(2)],
  188:         [Timestamp(2008, 1, 2), WeekOfMonth(2)],
  189:         [Timestamp(2008, 1, 2), LastWeekOfMonth(2)],
  190:     ],
  191: )
  192: def test_rsub(date, offset2):
  193:     assert date - offset2 == (-offset2)._apply(date)
  194: 
  195: 
  196: @pytest.mark.parametrize(
  197:     "date, offset2",
  198:     [
  199:         [Timestamp(2008, 1, 1), BDay(2)],
  200:         [Timestamp(2014, 7, 1, 10, 00), BusinessHour(n=3)],
  201:         [
  202:             Timestamp(2014, 7, 1, 10),
  203:             CustomBusinessHour(
  204:                 holidays=["2014-06-27", Timestamp(2014, 6, 30), Timestamp("2014-07-02")]
  205:             ),
  206:         ],
  207:         [Timestamp(2008, 1, 2), SemiMonthEnd(2)],
  208:         [Timestamp(2008, 1, 2), SemiMonthBegin(2)],
  209:         [Timestamp(2008, 1, 2), Week(2)],
  210:         [Timestamp(2008, 1, 2), WeekOfMonth(2)],
  211:         [Timestamp(2008, 1, 2), LastWeekOfMonth(2)],
  212:     ],
  213: )
  214: def test_radd(date, offset2):
  215:     assert date + offset2 == offset2 + date
  216: 
  217: 
  218: @pytest.mark.parametrize(
  219:     "date, offset_box, offset2",
  220:     [
  221:         [Timestamp(2008, 1, 1), BDay, BDay(2)],
  222:         [Timestamp(2008, 1, 2), SemiMonthEnd, SemiMonthEnd(2)],
  223:         [Timestamp(2008, 1, 2), SemiMonthBegin, SemiMonthBegin(2)],
  224:         [Timestamp(2008, 1, 2), Week, Week(2)],
  225:         [Timestamp(2008, 1, 2), WeekOfMonth, WeekOfMonth(2)],
  226:         [Timestamp(2008, 1, 2), LastWeekOfMonth, LastWeekOfMonth(2)],
  227:     ],
  228: )
  229: def test_sub(date, offset_box, offset2):
  230:     off = offset2
  231:     msg = "Cannot subtract datetime from offset"
  232:     with pytest.raises(TypeError, match=msg):
  233:         off - date
  234: 
  235:     assert 2 * off - off == off
  236:     assert date - offset2 == date + offset_box(-2)
  237:     assert date - offset2 == date - (2 * off - off)
  238: 
  239: 
  240: @pytest.mark.parametrize(
  241:     "offset_box, offset1",
  242:     [
  243:         [BDay, BDay()],
  244:         [LastWeekOfMonth, LastWeekOfMonth()],
  245:         [WeekOfMonth, WeekOfMonth()],
  246:         [Week, Week()],
  247:         [SemiMonthBegin, SemiMonthBegin()],
  248:         [SemiMonthEnd, SemiMonthEnd()],
  249:         [CustomBusinessHour, CustomBusinessHour(weekmask="Tue Wed Thu Fri")],
  250:         [BusinessHour, BusinessHour()],
  251:     ],
  252: )
  253: def test_Mult1(offset_box, offset1):
  254:     dt = Timestamp(2008, 1, 2)
  255:     assert dt + 10 * offset1 == dt + offset_box(10)
  256:     assert dt + 5 * offset1 == dt + offset_box(5)
  257: 
  258: 
  259: def test_compare_str(_offset):
  260:     # GH#23524
  261:     # comparing to strings that cannot be cast to DateOffsets should
  262:     #  not raise for __eq__ or __ne__
  263:     off = _get_offset(_offset)
  264: 
  265:     assert not off == "infer"
  266:     assert off != "foo"
  267:     # Note: inequalities are only implemented for Tick subclasses;
  268:     #  tests for this are in test_ticks
