    1: """
    2: Tests for offsets.Tick and subclasses
    3: """
    4: from datetime import (
    5:     datetime,
    6:     timedelta,
    7: )
    8: 
    9: from hypothesis import (
   10:     assume,
   11:     example,
   12:     given,
   13: )
   14: import numpy as np
   15: import pytest
   16: 
   17: from pandas._libs.tslibs.offsets import delta_to_tick
   18: from pandas.errors import OutOfBoundsTimedelta
   19: 
   20: from pandas import (
   21:     Timedelta,
   22:     Timestamp,
   23: )
   24: import pandas._testing as tm
   25: from pandas._testing._hypothesis import INT_NEG_999_TO_POS_999
   26: from pandas.tests.tseries.offsets.common import assert_offset_equal
   27: 
   28: from pandas.tseries import offsets
   29: from pandas.tseries.offsets import (
   30:     Hour,
   31:     Micro,
   32:     Milli,
   33:     Minute,
   34:     Nano,
   35:     Second,
   36: )
   37: 
   38: # ---------------------------------------------------------------------
   39: # Test Helpers
   40: 
   41: tick_classes = [Hour, Minute, Second, Milli, Micro, Nano]
   42: 
   43: 
   44: # ---------------------------------------------------------------------
   45: 
   46: 
   47: def test_apply_ticks():
   48:     result = offsets.Hour(3) + offsets.Hour(4)
   49:     exp = offsets.Hour(7)
   50:     assert result == exp
   51: 
   52: 
   53: def test_delta_to_tick():
   54:     delta = timedelta(3)
   55: 
   56:     tick = delta_to_tick(delta)
   57:     assert tick == offsets.Day(3)
   58: 
   59:     td = Timedelta(nanoseconds=5)
   60:     tick = delta_to_tick(td)
   61:     assert tick == Nano(5)
   62: 
   63: 
   64: @pytest.mark.parametrize("cls", tick_classes)
   65: @example(n=2, m=3)
   66: @example(n=800, m=300)
   67: @example(n=1000, m=5)
   68: @given(n=INT_NEG_999_TO_POS_999, m=INT_NEG_999_TO_POS_999)
   69: def test_tick_add_sub(cls, n, m):
   70:     # For all Tick subclasses and all integers n, m, we should have
   71:     # tick(n) + tick(m) == tick(n+m)
   72:     # tick(n) - tick(m) == tick(n-m)
   73:     left = cls(n)
   74:     right = cls(m)
   75:     expected = cls(n + m)
   76: 
   77:     assert left + right == expected
   78: 
   79:     expected = cls(n - m)
   80:     assert left - right == expected
   81: 
   82: 
   83: @pytest.mark.arm_slow
   84: @pytest.mark.parametrize("cls", tick_classes)
   85: @example(n=2, m=3)
   86: @given(n=INT_NEG_999_TO_POS_999, m=INT_NEG_999_TO_POS_999)
   87: def test_tick_equality(cls, n, m):
   88:     assume(m != n)
   89:     # tick == tock iff tick.n == tock.n
   90:     left = cls(n)
   91:     right = cls(m)
   92:     assert left != right
   93: 
   94:     right = cls(n)
   95:     assert left == right
   96:     assert not left != right
   97: 
   98:     if n != 0:
   99:         assert cls(n) != cls(-n)
  100: 
  101: 
  102: # ---------------------------------------------------------------------
  103: 
  104: 
  105: def test_Hour():
  106:     assert_offset_equal(Hour(), datetime(2010, 1, 1), datetime(2010, 1, 1, 1))
  107:     assert_offset_equal(Hour(-1), datetime(2010, 1, 1, 1), datetime(2010, 1, 1))
  108:     assert_offset_equal(2 * Hour(), datetime(2010, 1, 1), datetime(2010, 1, 1, 2))
  109:     assert_offset_equal(-1 * Hour(), datetime(2010, 1, 1, 1), datetime(2010, 1, 1))
  110: 
  111:     assert Hour(3) + Hour(2) == Hour(5)
  112:     assert Hour(3) - Hour(2) == Hour()
  113: 
  114:     assert Hour(4) != Hour(1)
  115: 
  116: 
  117: def test_Minute():
  118:     assert_offset_equal(Minute(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 1))
  119:     assert_offset_equal(Minute(-1), datetime(2010, 1, 1, 0, 1), datetime(2010, 1, 1))
  120:     assert_offset_equal(2 * Minute(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 2))
  121:     assert_offset_equal(-1 * Minute(), datetime(2010, 1, 1, 0, 1), datetime(2010, 1, 1))
  122: 
  123:     assert Minute(3) + Minute(2) == Minute(5)
  124:     assert Minute(3) - Minute(2) == Minute()
  125:     assert Minute(5) != Minute()
  126: 
  127: 
  128: def test_Second():
  129:     assert_offset_equal(Second(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 1))
  130:     assert_offset_equal(Second(-1), datetime(2010, 1, 1, 0, 0, 1), datetime(2010, 1, 1))
  131:     assert_offset_equal(
  132:         2 * Second(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 2)
  133:     )
  134:     assert_offset_equal(
  135:         -1 * Second(), datetime(2010, 1, 1, 0, 0, 1), datetime(2010, 1, 1)
  136:     )
  137: 
  138:     assert Second(3) + Second(2) == Second(5)
  139:     assert Second(3) - Second(2) == Second()
  140: 
  141: 
  142: def test_Millisecond():
  143:     assert_offset_equal(
  144:         Milli(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 0, 1000)
  145:     )
  146:     assert_offset_equal(
  147:         Milli(-1), datetime(2010, 1, 1, 0, 0, 0, 1000), datetime(2010, 1, 1)
  148:     )
  149:     assert_offset_equal(
  150:         Milli(2), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 0, 2000)
  151:     )
  152:     assert_offset_equal(
  153:         2 * Milli(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 0, 2000)
  154:     )
  155:     assert_offset_equal(
  156:         -1 * Milli(), datetime(2010, 1, 1, 0, 0, 0, 1000), datetime(2010, 1, 1)
  157:     )
  158: 
  159:     assert Milli(3) + Milli(2) == Milli(5)
  160:     assert Milli(3) - Milli(2) == Milli()
  161: 
  162: 
  163: def test_MillisecondTimestampArithmetic():
  164:     assert_offset_equal(
  165:         Milli(), Timestamp("2010-01-01"), Timestamp("2010-01-01 00:00:00.001")
  166:     )
  167:     assert_offset_equal(
  168:         Milli(-1), Timestamp("2010-01-01 00:00:00.001"), Timestamp("2010-01-01")
  169:     )
  170: 
  171: 
  172: def test_Microsecond():
  173:     assert_offset_equal(Micro(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 0, 1))
  174:     assert_offset_equal(
  175:         Micro(-1), datetime(2010, 1, 1, 0, 0, 0, 1), datetime(2010, 1, 1)
  176:     )
  177: 
  178:     assert_offset_equal(
  179:         2 * Micro(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 0, 2)
  180:     )
  181:     assert_offset_equal(
  182:         -1 * Micro(), datetime(2010, 1, 1, 0, 0, 0, 1), datetime(2010, 1, 1)
  183:     )
  184: 
  185:     assert Micro(3) + Micro(2) == Micro(5)
  186:     assert Micro(3) - Micro(2) == Micro()
  187: 
  188: 
  189: def test_NanosecondGeneric():
  190:     timestamp = Timestamp(datetime(2010, 1, 1))
  191:     assert timestamp.nanosecond == 0
  192: 
  193:     result = timestamp + Nano(10)
  194:     assert result.nanosecond == 10
  195: 
  196:     reverse_result = Nano(10) + timestamp
  197:     assert reverse_result.nanosecond == 10
  198: 
  199: 
  200: def test_Nanosecond():
  201:     timestamp = Timestamp(datetime(2010, 1, 1))
  202:     assert_offset_equal(Nano(), timestamp, timestamp + np.timedelta64(1, "ns"))
  203:     assert_offset_equal(Nano(-1), timestamp + np.timedelta64(1, "ns"), timestamp)
  204:     assert_offset_equal(2 * Nano(), timestamp, timestamp + np.timedelta64(2, "ns"))
  205:     assert_offset_equal(-1 * Nano(), timestamp + np.timedelta64(1, "ns"), timestamp)
  206: 
  207:     assert Nano(3) + Nano(2) == Nano(5)
  208:     assert Nano(3) - Nano(2) == Nano()
  209: 
  210:     # GH9284
  211:     assert Nano(1) + Nano(10) == Nano(11)
  212:     assert Nano(5) + Micro(1) == Nano(1005)
  213:     assert Micro(5) + Nano(1) == Nano(5001)
  214: 
  215: 
  216: @pytest.mark.parametrize(
  217:     "kls, expected",
  218:     [
  219:         (Hour, Timedelta(hours=5)),
  220:         (Minute, Timedelta(hours=2, minutes=3)),
  221:         (Second, Timedelta(hours=2, seconds=3)),
  222:         (Milli, Timedelta(hours=2, milliseconds=3)),
  223:         (Micro, Timedelta(hours=2, microseconds=3)),
  224:         (Nano, Timedelta(hours=2, nanoseconds=3)),
  225:     ],
  226: )
  227: def test_tick_addition(kls, expected):
  228:     offset = kls(3)
  229:     td = Timedelta(hours=2)
  230: 
  231:     for other in [td, td.to_pytimedelta(), td.to_timedelta64()]:
  232:         result = offset + other
  233:         assert isinstance(result, Timedelta)
  234:         assert result == expected
  235: 
  236:         result = other + offset
  237:         assert isinstance(result, Timedelta)
  238:         assert result == expected
  239: 
  240: 
  241: def test_tick_delta_overflow():
  242:     # GH#55503 raise OutOfBoundsTimedelta, not OverflowError
  243:     tick = offsets.Day(10**9)
  244:     msg = "Cannot cast 1000000000 days 00:00:00 to unit='ns' without overflow"
  245:     depr_msg = "Day.delta is deprecated"
  246:     with pytest.raises(OutOfBoundsTimedelta, match=msg):
  247:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  248:             tick.delta
  249: 
  250: 
  251: @pytest.mark.parametrize("cls", tick_classes)
  252: def test_tick_division(cls):
  253:     off = cls(10)
  254: 
  255:     assert off / cls(5) == 2
  256:     assert off / 2 == cls(5)
  257:     assert off / 2.0 == cls(5)
  258: 
  259:     assert off / off._as_pd_timedelta == 1
  260:     assert off / off._as_pd_timedelta.to_timedelta64() == 1
  261: 
  262:     assert off / Nano(1) == off._as_pd_timedelta / Nano(1)._as_pd_timedelta
  263: 
  264:     if cls is not Nano:
  265:         # A case where we end up with a smaller class
  266:         result = off / 1000
  267:         assert isinstance(result, offsets.Tick)
  268:         assert not isinstance(result, cls)
  269:         assert result._as_pd_timedelta == off._as_pd_timedelta / 1000
  270: 
  271:     if cls._nanos_inc < Timedelta(seconds=1)._value:
  272:         # Case where we end up with a bigger class
  273:         result = off / 0.001
  274:         assert isinstance(result, offsets.Tick)
  275:         assert not isinstance(result, cls)
  276:         assert result._as_pd_timedelta == off._as_pd_timedelta / 0.001
  277: 
  278: 
  279: def test_tick_mul_float():
  280:     off = Micro(2)
  281: 
  282:     # Case where we retain type
  283:     result = off * 1.5
  284:     expected = Micro(3)
  285:     assert result == expected
  286:     assert isinstance(result, Micro)
  287: 
  288:     # Case where we bump up to the next type
  289:     result = off * 1.25
  290:     expected = Nano(2500)
  291:     assert result == expected
  292:     assert isinstance(result, Nano)
  293: 
  294: 
  295: @pytest.mark.parametrize("cls", tick_classes)
  296: def test_tick_rdiv(cls):
  297:     off = cls(10)
  298:     delta = off._as_pd_timedelta
  299:     td64 = delta.to_timedelta64()
  300:     instance__type = ".".join([cls.__module__, cls.__name__])
  301:     msg = (
  302:         "unsupported operand type\\(s\\) for \\/: 'int'|'float' and "
  303:         f"'{instance__type}'"
  304:     )
  305: 
  306:     with pytest.raises(TypeError, match=msg):
  307:         2 / off
  308:     with pytest.raises(TypeError, match=msg):
  309:         2.0 / off
  310: 
  311:     assert (td64 * 2.5) / off == 2.5
  312: 
  313:     if cls is not Nano:
  314:         # skip pytimedelta for Nano since it gets dropped
  315:         assert (delta.to_pytimedelta() * 2) / off == 2
  316: 
  317:     result = np.array([2 * td64, td64]) / off
  318:     expected = np.array([2.0, 1.0])
  319:     tm.assert_numpy_array_equal(result, expected)
  320: 
  321: 
  322: @pytest.mark.parametrize("cls1", tick_classes)
  323: @pytest.mark.parametrize("cls2", tick_classes)
  324: def test_tick_zero(cls1, cls2):
  325:     assert cls1(0) == cls2(0)
  326:     assert cls1(0) + cls2(0) == cls1(0)
  327: 
  328:     if cls1 is not Nano:
  329:         assert cls1(2) + cls2(0) == cls1(2)
  330: 
  331:     if cls1 is Nano:
  332:         assert cls1(2) + Nano(0) == cls1(2)
  333: 
  334: 
  335: @pytest.mark.parametrize("cls", tick_classes)
  336: def test_tick_equalities(cls):
  337:     assert cls() == cls(1)
  338: 
  339: 
  340: @pytest.mark.parametrize("cls", tick_classes)
  341: def test_tick_offset(cls):
  342:     msg = f"{cls.__name__}.is_anchored is deprecated "
  343: 
  344:     with tm.assert_produces_warning(FutureWarning, match=msg):
  345:         assert not cls().is_anchored()
  346: 
  347: 
  348: @pytest.mark.parametrize("cls", tick_classes)
  349: def test_compare_ticks(cls):
  350:     three = cls(3)
  351:     four = cls(4)
  352: 
  353:     assert three < cls(4)
  354:     assert cls(3) < four
  355:     assert four > cls(3)
  356:     assert cls(4) > three
  357:     assert cls(3) == cls(3)
  358:     assert cls(3) != cls(4)
  359: 
  360: 
  361: @pytest.mark.parametrize("cls", tick_classes)
  362: def test_compare_ticks_to_strs(cls):
  363:     # GH#23524
  364:     off = cls(19)
  365: 
  366:     # These tests should work with any strings, but we particularly are
  367:     #  interested in "infer" as that comparison is convenient to make in
  368:     #  Datetime/Timedelta Array/Index constructors
  369:     assert not off == "infer"
  370:     assert not "foo" == off
  371: 
  372:     instance_type = ".".join([cls.__module__, cls.__name__])
  373:     msg = (
  374:         "'<'|'<='|'>'|'>=' not supported between instances of "
  375:         f"'str' and '{instance_type}'|'{instance_type}' and 'str'"
  376:     )
  377: 
  378:     for left, right in [("infer", off), (off, "infer")]:
  379:         with pytest.raises(TypeError, match=msg):
  380:             left < right
  381:         with pytest.raises(TypeError, match=msg):
  382:             left <= right
  383:         with pytest.raises(TypeError, match=msg):
  384:             left > right
  385:         with pytest.raises(TypeError, match=msg):
  386:             left >= right
  387: 
  388: 
  389: @pytest.mark.parametrize("cls", tick_classes)
  390: def test_compare_ticks_to_timedeltalike(cls):
  391:     off = cls(19)
  392: 
  393:     td = off._as_pd_timedelta
  394: 
  395:     others = [td, td.to_timedelta64()]
  396:     if cls is not Nano:
  397:         others.append(td.to_pytimedelta())
  398: 
  399:     for other in others:
  400:         assert off == other
  401:         assert not off != other
  402:         assert not off < other
  403:         assert not off > other
  404:         assert off <= other
  405:         assert off >= other
