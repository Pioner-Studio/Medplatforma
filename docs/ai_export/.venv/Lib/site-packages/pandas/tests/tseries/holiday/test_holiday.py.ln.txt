    1: from datetime import datetime
    2: 
    3: import pytest
    4: from pytz import utc
    5: 
    6: from pandas import (
    7:     DatetimeIndex,
    8:     Series,
    9: )
   10: import pandas._testing as tm
   11: 
   12: from pandas.tseries.holiday import (
   13:     MO,
   14:     SA,
   15:     AbstractHolidayCalendar,
   16:     DateOffset,
   17:     EasterMonday,
   18:     GoodFriday,
   19:     Holiday,
   20:     HolidayCalendarFactory,
   21:     Timestamp,
   22:     USColumbusDay,
   23:     USFederalHolidayCalendar,
   24:     USLaborDay,
   25:     USMartinLutherKingJr,
   26:     USMemorialDay,
   27:     USPresidentsDay,
   28:     USThanksgivingDay,
   29:     get_calendar,
   30:     next_monday,
   31: )
   32: 
   33: 
   34: @pytest.mark.parametrize(
   35:     "holiday,start_date,end_date,expected",
   36:     [
   37:         (
   38:             USMemorialDay,
   39:             datetime(2011, 1, 1),
   40:             datetime(2020, 12, 31),
   41:             [
   42:                 datetime(2011, 5, 30),
   43:                 datetime(2012, 5, 28),
   44:                 datetime(2013, 5, 27),
   45:                 datetime(2014, 5, 26),
   46:                 datetime(2015, 5, 25),
   47:                 datetime(2016, 5, 30),
   48:                 datetime(2017, 5, 29),
   49:                 datetime(2018, 5, 28),
   50:                 datetime(2019, 5, 27),
   51:                 datetime(2020, 5, 25),
   52:             ],
   53:         ),
   54:         (
   55:             Holiday("July 4th Eve", month=7, day=3),
   56:             "2001-01-01",
   57:             "2003-03-03",
   58:             [Timestamp("2001-07-03 00:00:00"), Timestamp("2002-07-03 00:00:00")],
   59:         ),
   60:         (
   61:             Holiday("July 4th Eve", month=7, day=3, days_of_week=(0, 1, 2, 3)),
   62:             "2001-01-01",
   63:             "2008-03-03",
   64:             [
   65:                 Timestamp("2001-07-03 00:00:00"),
   66:                 Timestamp("2002-07-03 00:00:00"),
   67:                 Timestamp("2003-07-03 00:00:00"),
   68:                 Timestamp("2006-07-03 00:00:00"),
   69:                 Timestamp("2007-07-03 00:00:00"),
   70:             ],
   71:         ),
   72:         (
   73:             EasterMonday,
   74:             datetime(2011, 1, 1),
   75:             datetime(2020, 12, 31),
   76:             [
   77:                 Timestamp("2011-04-25 00:00:00"),
   78:                 Timestamp("2012-04-09 00:00:00"),
   79:                 Timestamp("2013-04-01 00:00:00"),
   80:                 Timestamp("2014-04-21 00:00:00"),
   81:                 Timestamp("2015-04-06 00:00:00"),
   82:                 Timestamp("2016-03-28 00:00:00"),
   83:                 Timestamp("2017-04-17 00:00:00"),
   84:                 Timestamp("2018-04-02 00:00:00"),
   85:                 Timestamp("2019-04-22 00:00:00"),
   86:                 Timestamp("2020-04-13 00:00:00"),
   87:             ],
   88:         ),
   89:         (
   90:             GoodFriday,
   91:             datetime(2011, 1, 1),
   92:             datetime(2020, 12, 31),
   93:             [
   94:                 Timestamp("2011-04-22 00:00:00"),
   95:                 Timestamp("2012-04-06 00:00:00"),
   96:                 Timestamp("2013-03-29 00:00:00"),
   97:                 Timestamp("2014-04-18 00:00:00"),
   98:                 Timestamp("2015-04-03 00:00:00"),
   99:                 Timestamp("2016-03-25 00:00:00"),
  100:                 Timestamp("2017-04-14 00:00:00"),
  101:                 Timestamp("2018-03-30 00:00:00"),
  102:                 Timestamp("2019-04-19 00:00:00"),
  103:                 Timestamp("2020-04-10 00:00:00"),
  104:             ],
  105:         ),
  106:         (
  107:             USThanksgivingDay,
  108:             datetime(2011, 1, 1),
  109:             datetime(2020, 12, 31),
  110:             [
  111:                 datetime(2011, 11, 24),
  112:                 datetime(2012, 11, 22),
  113:                 datetime(2013, 11, 28),
  114:                 datetime(2014, 11, 27),
  115:                 datetime(2015, 11, 26),
  116:                 datetime(2016, 11, 24),
  117:                 datetime(2017, 11, 23),
  118:                 datetime(2018, 11, 22),
  119:                 datetime(2019, 11, 28),
  120:                 datetime(2020, 11, 26),
  121:             ],
  122:         ),
  123:     ],
  124: )
  125: def test_holiday_dates(holiday, start_date, end_date, expected):
  126:     assert list(holiday.dates(start_date, end_date)) == expected
  127: 
  128:     # Verify that timezone info is preserved.
  129:     assert list(
  130:         holiday.dates(
  131:             utc.localize(Timestamp(start_date)), utc.localize(Timestamp(end_date))
  132:         )
  133:     ) == [utc.localize(dt) for dt in expected]
  134: 
  135: 
  136: @pytest.mark.parametrize(
  137:     "holiday,start,expected",
  138:     [
  139:         (USMemorialDay, datetime(2015, 7, 1), []),
  140:         (USMemorialDay, "2015-05-25", [Timestamp("2015-05-25")]),
  141:         (USLaborDay, datetime(2015, 7, 1), []),
  142:         (USLaborDay, "2015-09-07", [Timestamp("2015-09-07")]),
  143:         (USColumbusDay, datetime(2015, 7, 1), []),
  144:         (USColumbusDay, "2015-10-12", [Timestamp("2015-10-12")]),
  145:         (USThanksgivingDay, datetime(2015, 7, 1), []),
  146:         (USThanksgivingDay, "2015-11-26", [Timestamp("2015-11-26")]),
  147:         (USMartinLutherKingJr, datetime(2015, 7, 1), []),
  148:         (USMartinLutherKingJr, "2015-01-19", [Timestamp("2015-01-19")]),
  149:         (USPresidentsDay, datetime(2015, 7, 1), []),
  150:         (USPresidentsDay, "2015-02-16", [Timestamp("2015-02-16")]),
  151:         (GoodFriday, datetime(2015, 7, 1), []),
  152:         (GoodFriday, "2015-04-03", [Timestamp("2015-04-03")]),
  153:         (EasterMonday, "2015-04-06", [Timestamp("2015-04-06")]),
  154:         (EasterMonday, datetime(2015, 7, 1), []),
  155:         (EasterMonday, "2015-04-05", []),
  156:         ("New Year's Day", "2015-01-01", [Timestamp("2015-01-01")]),
  157:         ("New Year's Day", "2010-12-31", [Timestamp("2010-12-31")]),
  158:         ("New Year's Day", datetime(2015, 7, 1), []),
  159:         ("New Year's Day", "2011-01-01", []),
  160:         ("Independence Day", "2015-07-03", [Timestamp("2015-07-03")]),
  161:         ("Independence Day", datetime(2015, 7, 1), []),
  162:         ("Independence Day", "2015-07-04", []),
  163:         ("Veterans Day", "2012-11-12", [Timestamp("2012-11-12")]),
  164:         ("Veterans Day", datetime(2015, 7, 1), []),
  165:         ("Veterans Day", "2012-11-11", []),
  166:         ("Christmas Day", "2011-12-26", [Timestamp("2011-12-26")]),
  167:         ("Christmas Day", datetime(2015, 7, 1), []),
  168:         ("Christmas Day", "2011-12-25", []),
  169:         ("Juneteenth National Independence Day", "2020-06-19", []),
  170:         (
  171:             "Juneteenth National Independence Day",
  172:             "2021-06-18",
  173:             [Timestamp("2021-06-18")],
  174:         ),
  175:         ("Juneteenth National Independence Day", "2022-06-19", []),
  176:         (
  177:             "Juneteenth National Independence Day",
  178:             "2022-06-20",
  179:             [Timestamp("2022-06-20")],
  180:         ),
  181:     ],
  182: )
  183: def test_holidays_within_dates(holiday, start, expected):
  184:     # see gh-11477
  185:     #
  186:     # Fix holiday behavior where holiday.dates returned dates outside
  187:     # start/end date, or observed rules could not be applied because the
  188:     # holiday was not in the original date range (e.g., 7/4/2015 -> 7/3/2015).
  189:     if isinstance(holiday, str):
  190:         calendar = get_calendar("USFederalHolidayCalendar")
  191:         holiday = calendar.rule_from_name(holiday)
  192: 
  193:     assert list(holiday.dates(start, start)) == expected
  194: 
  195:     # Verify that timezone info is preserved.
  196:     assert list(
  197:         holiday.dates(utc.localize(Timestamp(start)), utc.localize(Timestamp(start)))
  198:     ) == [utc.localize(dt) for dt in expected]
  199: 
  200: 
  201: @pytest.mark.parametrize(
  202:     "transform", [lambda x: x.strftime("%Y-%m-%d"), lambda x: Timestamp(x)]
  203: )
  204: def test_argument_types(transform):
  205:     start_date = datetime(2011, 1, 1)
  206:     end_date = datetime(2020, 12, 31)
  207: 
  208:     holidays = USThanksgivingDay.dates(start_date, end_date)
  209:     holidays2 = USThanksgivingDay.dates(transform(start_date), transform(end_date))
  210:     tm.assert_index_equal(holidays, holidays2)
  211: 
  212: 
  213: @pytest.mark.parametrize(
  214:     "name,kwargs",
  215:     [
  216:         ("One-Time", {"year": 2012, "month": 5, "day": 28}),
  217:         (
  218:             "Range",
  219:             {
  220:                 "month": 5,
  221:                 "day": 28,
  222:                 "start_date": datetime(2012, 1, 1),
  223:                 "end_date": datetime(2012, 12, 31),
  224:                 "offset": DateOffset(weekday=MO(1)),
  225:             },
  226:         ),
  227:     ],
  228: )
  229: def test_special_holidays(name, kwargs):
  230:     base_date = [datetime(2012, 5, 28)]
  231:     holiday = Holiday(name, **kwargs)
  232: 
  233:     start_date = datetime(2011, 1, 1)
  234:     end_date = datetime(2020, 12, 31)
  235: 
  236:     assert base_date == holiday.dates(start_date, end_date)
  237: 
  238: 
  239: def test_get_calendar():
  240:     class TestCalendar(AbstractHolidayCalendar):
  241:         rules = []
  242: 
  243:     calendar = get_calendar("TestCalendar")
  244:     assert TestCalendar == type(calendar)
  245: 
  246: 
  247: def test_factory():
  248:     class_1 = HolidayCalendarFactory(
  249:         "MemorialDay", AbstractHolidayCalendar, USMemorialDay
  250:     )
  251:     class_2 = HolidayCalendarFactory(
  252:         "Thanksgiving", AbstractHolidayCalendar, USThanksgivingDay
  253:     )
  254:     class_3 = HolidayCalendarFactory("Combined", class_1, class_2)
  255: 
  256:     assert len(class_1.rules) == 1
  257:     assert len(class_2.rules) == 1
  258:     assert len(class_3.rules) == 2
  259: 
  260: 
  261: def test_both_offset_observance_raises():
  262:     # see gh-10217
  263:     msg = "Cannot use both offset and observance"
  264:     with pytest.raises(NotImplementedError, match=msg):
  265:         Holiday(
  266:             "Cyber Monday",
  267:             month=11,
  268:             day=1,
  269:             offset=[DateOffset(weekday=SA(4))],
  270:             observance=next_monday,
  271:         )
  272: 
  273: 
  274: def test_half_open_interval_with_observance():
  275:     # Prompted by GH 49075
  276:     # Check for holidays that have a half-open date interval where
  277:     # they have either a start_date or end_date defined along
  278:     # with a defined observance pattern to make sure that the return type
  279:     # for Holiday.dates() remains consistent before & after the year that
  280:     # marks the 'edge' of the half-open date interval.
  281: 
  282:     holiday_1 = Holiday(
  283:         "Arbitrary Holiday - start 2022-03-14",
  284:         start_date=datetime(2022, 3, 14),
  285:         month=3,
  286:         day=14,
  287:         observance=next_monday,
  288:     )
  289:     holiday_2 = Holiday(
  290:         "Arbitrary Holiday 2 - end 2022-03-20",
  291:         end_date=datetime(2022, 3, 20),
  292:         month=3,
  293:         day=20,
  294:         observance=next_monday,
  295:     )
  296: 
  297:     class TestHolidayCalendar(AbstractHolidayCalendar):
  298:         rules = [
  299:             USMartinLutherKingJr,
  300:             holiday_1,
  301:             holiday_2,
  302:             USLaborDay,
  303:         ]
  304: 
  305:     start = Timestamp("2022-08-01")
  306:     end = Timestamp("2022-08-31")
  307:     year_offset = DateOffset(years=5)
  308:     expected_results = DatetimeIndex([], dtype="datetime64[ns]", freq=None)
  309:     test_cal = TestHolidayCalendar()
  310: 
  311:     date_interval_low = test_cal.holidays(start - year_offset, end - year_offset)
  312:     date_window_edge = test_cal.holidays(start, end)
  313:     date_interval_high = test_cal.holidays(start + year_offset, end + year_offset)
  314: 
  315:     tm.assert_index_equal(date_interval_low, expected_results)
  316:     tm.assert_index_equal(date_window_edge, expected_results)
  317:     tm.assert_index_equal(date_interval_high, expected_results)
  318: 
  319: 
  320: def test_holidays_with_timezone_specified_but_no_occurences():
  321:     # GH 54580
  322:     # _apply_rule() in holiday.py was silently dropping timezones if you passed it
  323:     # an empty list of holiday dates that had timezone information
  324:     start_date = Timestamp("2018-01-01", tz="America/Chicago")
  325:     end_date = Timestamp("2018-01-11", tz="America/Chicago")
  326:     test_case = USFederalHolidayCalendar().holidays(
  327:         start_date, end_date, return_name=True
  328:     )
  329:     expected_results = Series("New Year's Day", index=[start_date])
  330:     expected_results.index = expected_results.index.as_unit("ns")
  331: 
  332:     tm.assert_equal(test_case, expected_results)
