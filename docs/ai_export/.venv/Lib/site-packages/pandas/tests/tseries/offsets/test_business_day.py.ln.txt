    1: """
    2: Tests for offsets.BDay
    3: """
    4: from __future__ import annotations
    5: 
    6: from datetime import (
    7:     date,
    8:     datetime,
    9:     timedelta,
   10: )
   11: 
   12: import numpy as np
   13: import pytest
   14: 
   15: from pandas._libs.tslibs.offsets import (
   16:     ApplyTypeError,
   17:     BDay,
   18:     BMonthEnd,
   19: )
   20: 
   21: from pandas import (
   22:     DatetimeIndex,
   23:     Timedelta,
   24:     _testing as tm,
   25: )
   26: from pandas.tests.tseries.offsets.common import (
   27:     assert_is_on_offset,
   28:     assert_offset_equal,
   29: )
   30: 
   31: from pandas.tseries import offsets
   32: 
   33: 
   34: @pytest.fixture
   35: def dt():
   36:     return datetime(2008, 1, 1)
   37: 
   38: 
   39: @pytest.fixture
   40: def _offset():
   41:     return BDay
   42: 
   43: 
   44: @pytest.fixture
   45: def offset(_offset):
   46:     return _offset()
   47: 
   48: 
   49: @pytest.fixture
   50: def offset2(_offset):
   51:     return _offset(2)
   52: 
   53: 
   54: class TestBusinessDay:
   55:     def test_different_normalize_equals(self, _offset, offset2):
   56:         # GH#21404 changed __eq__ to return False when `normalize` does not match
   57:         offset = _offset()
   58:         offset2 = _offset(normalize=True)
   59:         assert offset != offset2
   60: 
   61:     def test_repr(self, offset, offset2):
   62:         assert repr(offset) == "<BusinessDay>"
   63:         assert repr(offset2) == "<2 * BusinessDays>"
   64: 
   65:         expected = "<BusinessDay: offset=datetime.timedelta(days=1)>"
   66:         assert repr(offset + timedelta(1)) == expected
   67: 
   68:     def test_with_offset(self, dt, offset):
   69:         offset = offset + timedelta(hours=2)
   70: 
   71:         assert (dt + offset) == datetime(2008, 1, 2, 2)
   72: 
   73:     @pytest.mark.parametrize(
   74:         "td",
   75:         [
   76:             Timedelta(hours=2),
   77:             Timedelta(hours=2).to_pytimedelta(),
   78:             Timedelta(hours=2).to_timedelta64(),
   79:         ],
   80:         ids=lambda x: type(x),
   81:     )
   82:     def test_with_offset_index(self, td, dt, offset):
   83:         dti = DatetimeIndex([dt])
   84:         expected = DatetimeIndex([datetime(2008, 1, 2, 2)])
   85: 
   86:         result = dti + (td + offset)
   87:         tm.assert_index_equal(result, expected)
   88: 
   89:         result = dti + (offset + td)
   90:         tm.assert_index_equal(result, expected)
   91: 
   92:     def test_eq(self, offset2):
   93:         assert offset2 == offset2
   94: 
   95:     def test_hash(self, offset2):
   96:         assert hash(offset2) == hash(offset2)
   97: 
   98:     def test_add_datetime(self, dt, offset2):
   99:         assert offset2 + dt == datetime(2008, 1, 3)
  100:         assert offset2 + np.datetime64("2008-01-01 00:00:00") == datetime(2008, 1, 3)
  101: 
  102:     def testRollback1(self, dt, _offset):
  103:         assert _offset(10).rollback(dt) == dt
  104: 
  105:     def testRollback2(self, _offset):
  106:         assert _offset(10).rollback(datetime(2008, 1, 5)) == datetime(2008, 1, 4)
  107: 
  108:     def testRollforward1(self, dt, _offset):
  109:         assert _offset(10).rollforward(dt) == dt
  110: 
  111:     def testRollforward2(self, _offset):
  112:         assert _offset(10).rollforward(datetime(2008, 1, 5)) == datetime(2008, 1, 7)
  113: 
  114:     def test_roll_date_object(self, offset):
  115:         dt = date(2012, 9, 15)
  116: 
  117:         result = offset.rollback(dt)
  118:         assert result == datetime(2012, 9, 14)
  119: 
  120:         result = offset.rollforward(dt)
  121:         assert result == datetime(2012, 9, 17)
  122: 
  123:         offset = offsets.Day()
  124:         result = offset.rollback(dt)
  125:         assert result == datetime(2012, 9, 15)
  126: 
  127:         result = offset.rollforward(dt)
  128:         assert result == datetime(2012, 9, 15)
  129: 
  130:     @pytest.mark.parametrize(
  131:         "dt, expected",
  132:         [
  133:             (datetime(2008, 1, 1), True),
  134:             (datetime(2008, 1, 5), False),
  135:         ],
  136:     )
  137:     def test_is_on_offset(self, offset, dt, expected):
  138:         assert_is_on_offset(offset, dt, expected)
  139: 
  140:     apply_cases: list[tuple[int, dict[datetime, datetime]]] = [
  141:         (
  142:             1,
  143:             {
  144:                 datetime(2008, 1, 1): datetime(2008, 1, 2),
  145:                 datetime(2008, 1, 4): datetime(2008, 1, 7),
  146:                 datetime(2008, 1, 5): datetime(2008, 1, 7),
  147:                 datetime(2008, 1, 6): datetime(2008, 1, 7),
  148:                 datetime(2008, 1, 7): datetime(2008, 1, 8),
  149:             },
  150:         ),
  151:         (
  152:             2,
  153:             {
  154:                 datetime(2008, 1, 1): datetime(2008, 1, 3),
  155:                 datetime(2008, 1, 4): datetime(2008, 1, 8),
  156:                 datetime(2008, 1, 5): datetime(2008, 1, 8),
  157:                 datetime(2008, 1, 6): datetime(2008, 1, 8),
  158:                 datetime(2008, 1, 7): datetime(2008, 1, 9),
  159:             },
  160:         ),
  161:         (
  162:             -1,
  163:             {
  164:                 datetime(2008, 1, 1): datetime(2007, 12, 31),
  165:                 datetime(2008, 1, 4): datetime(2008, 1, 3),
  166:                 datetime(2008, 1, 5): datetime(2008, 1, 4),
  167:                 datetime(2008, 1, 6): datetime(2008, 1, 4),
  168:                 datetime(2008, 1, 7): datetime(2008, 1, 4),
  169:                 datetime(2008, 1, 8): datetime(2008, 1, 7),
  170:             },
  171:         ),
  172:         (
  173:             -2,
  174:             {
  175:                 datetime(2008, 1, 1): datetime(2007, 12, 28),
  176:                 datetime(2008, 1, 4): datetime(2008, 1, 2),
  177:                 datetime(2008, 1, 5): datetime(2008, 1, 3),
  178:                 datetime(2008, 1, 6): datetime(2008, 1, 3),
  179:                 datetime(2008, 1, 7): datetime(2008, 1, 3),
  180:                 datetime(2008, 1, 8): datetime(2008, 1, 4),
  181:                 datetime(2008, 1, 9): datetime(2008, 1, 7),
  182:             },
  183:         ),
  184:         (
  185:             0,
  186:             {
  187:                 datetime(2008, 1, 1): datetime(2008, 1, 1),
  188:                 datetime(2008, 1, 4): datetime(2008, 1, 4),
  189:                 datetime(2008, 1, 5): datetime(2008, 1, 7),
  190:                 datetime(2008, 1, 6): datetime(2008, 1, 7),
  191:                 datetime(2008, 1, 7): datetime(2008, 1, 7),
  192:             },
  193:         ),
  194:     ]
  195: 
  196:     @pytest.mark.parametrize("case", apply_cases)
  197:     def test_apply(self, case, _offset):
  198:         n, cases = case
  199:         offset = _offset(n)
  200:         for base, expected in cases.items():
  201:             assert_offset_equal(offset, base, expected)
  202: 
  203:     def test_apply_large_n(self, _offset):
  204:         dt = datetime(2012, 10, 23)
  205: 
  206:         result = dt + _offset(10)
  207:         assert result == datetime(2012, 11, 6)
  208: 
  209:         result = dt + _offset(100) - _offset(100)
  210:         assert result == dt
  211: 
  212:         off = _offset() * 6
  213:         rs = datetime(2012, 1, 1) - off
  214:         xp = datetime(2011, 12, 23)
  215:         assert rs == xp
  216: 
  217:         st = datetime(2011, 12, 18)
  218:         rs = st + off
  219:         xp = datetime(2011, 12, 26)
  220:         assert rs == xp
  221: 
  222:         off = _offset() * 10
  223:         rs = datetime(2014, 1, 5) + off  # see #5890
  224:         xp = datetime(2014, 1, 17)
  225:         assert rs == xp
  226: 
  227:     def test_apply_corner(self, _offset):
  228:         if _offset is BDay:
  229:             msg = "Only know how to combine business day with datetime or timedelta"
  230:         else:
  231:             msg = (
  232:                 "Only know how to combine trading day "
  233:                 "with datetime, datetime64 or timedelta"
  234:             )
  235:         with pytest.raises(ApplyTypeError, match=msg):
  236:             _offset()._apply(BMonthEnd())
