    1: """
    2: These test the method maybe_promote from core/dtypes/cast.py
    3: """
    4: 
    5: import datetime
    6: from decimal import Decimal
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas._libs.tslibs import NaT
   12: 
   13: from pandas.core.dtypes.cast import maybe_promote
   14: from pandas.core.dtypes.common import is_scalar
   15: from pandas.core.dtypes.dtypes import DatetimeTZDtype
   16: from pandas.core.dtypes.missing import isna
   17: 
   18: import pandas as pd
   19: 
   20: 
   21: def _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar=None):
   22:     """
   23:     Auxiliary function to unify testing of scalar/array promotion.
   24: 
   25:     Parameters
   26:     ----------
   27:     dtype : dtype
   28:         The value to pass on as the first argument to maybe_promote.
   29:     fill_value : scalar
   30:         The value to pass on as the second argument to maybe_promote as
   31:         a scalar.
   32:     expected_dtype : dtype
   33:         The expected dtype returned by maybe_promote (by design this is the
   34:         same regardless of whether fill_value was passed as a scalar or in an
   35:         array!).
   36:     exp_val_for_scalar : scalar
   37:         The expected value for the (potentially upcast) fill_value returned by
   38:         maybe_promote.
   39:     """
   40:     assert is_scalar(fill_value)
   41: 
   42:     # here, we pass on fill_value as a scalar directly; the expected value
   43:     # returned from maybe_promote is fill_value, potentially upcast to the
   44:     # returned dtype.
   45:     result_dtype, result_fill_value = maybe_promote(dtype, fill_value)
   46:     expected_fill_value = exp_val_for_scalar
   47: 
   48:     assert result_dtype == expected_dtype
   49:     _assert_match(result_fill_value, expected_fill_value)
   50: 
   51: 
   52: def _assert_match(result_fill_value, expected_fill_value):
   53:     # GH#23982/25425 require the same type in addition to equality/NA-ness
   54:     res_type = type(result_fill_value)
   55:     ex_type = type(expected_fill_value)
   56: 
   57:     if hasattr(result_fill_value, "dtype"):
   58:         # Compare types in a way that is robust to platform-specific
   59:         #  idiosyncrasies where e.g. sometimes we get "ulonglong" as an alias
   60:         #  for "uint64" or "intc" as an alias for "int32"
   61:         assert result_fill_value.dtype.kind == expected_fill_value.dtype.kind
   62:         assert result_fill_value.dtype.itemsize == expected_fill_value.dtype.itemsize
   63:     else:
   64:         # On some builds, type comparison fails, e.g. np.int32 != np.int32
   65:         assert res_type == ex_type or res_type.__name__ == ex_type.__name__
   66: 
   67:     match_value = result_fill_value == expected_fill_value
   68:     if match_value is pd.NA:
   69:         match_value = False
   70: 
   71:     # Note: type check above ensures that we have the _same_ NA value
   72:     # for missing values, None == None (which is checked
   73:     # through match_value above), but np.nan != np.nan and pd.NaT != pd.NaT
   74:     match_missing = isna(result_fill_value) and isna(expected_fill_value)
   75: 
   76:     assert match_value or match_missing
   77: 
   78: 
   79: @pytest.mark.parametrize(
   80:     "dtype, fill_value, expected_dtype",
   81:     [
   82:         # size 8
   83:         ("int8", 1, "int8"),
   84:         ("int8", np.iinfo("int8").max + 1, "int16"),
   85:         ("int8", np.iinfo("int16").max + 1, "int32"),
   86:         ("int8", np.iinfo("int32").max + 1, "int64"),
   87:         ("int8", np.iinfo("int64").max + 1, "object"),
   88:         ("int8", -1, "int8"),
   89:         ("int8", np.iinfo("int8").min - 1, "int16"),
   90:         ("int8", np.iinfo("int16").min - 1, "int32"),
   91:         ("int8", np.iinfo("int32").min - 1, "int64"),
   92:         ("int8", np.iinfo("int64").min - 1, "object"),
   93:         # keep signed-ness as long as possible
   94:         ("uint8", 1, "uint8"),
   95:         ("uint8", np.iinfo("int8").max + 1, "uint8"),
   96:         ("uint8", np.iinfo("uint8").max + 1, "uint16"),
   97:         ("uint8", np.iinfo("int16").max + 1, "uint16"),
   98:         ("uint8", np.iinfo("uint16").max + 1, "uint32"),
   99:         ("uint8", np.iinfo("int32").max + 1, "uint32"),
  100:         ("uint8", np.iinfo("uint32").max + 1, "uint64"),
  101:         ("uint8", np.iinfo("int64").max + 1, "uint64"),
  102:         ("uint8", np.iinfo("uint64").max + 1, "object"),
  103:         # max of uint8 cannot be contained in int8
  104:         ("uint8", -1, "int16"),
  105:         ("uint8", np.iinfo("int8").min - 1, "int16"),
  106:         ("uint8", np.iinfo("int16").min - 1, "int32"),
  107:         ("uint8", np.iinfo("int32").min - 1, "int64"),
  108:         ("uint8", np.iinfo("int64").min - 1, "object"),
  109:         # size 16
  110:         ("int16", 1, "int16"),
  111:         ("int16", np.iinfo("int8").max + 1, "int16"),
  112:         ("int16", np.iinfo("int16").max + 1, "int32"),
  113:         ("int16", np.iinfo("int32").max + 1, "int64"),
  114:         ("int16", np.iinfo("int64").max + 1, "object"),
  115:         ("int16", -1, "int16"),
  116:         ("int16", np.iinfo("int8").min - 1, "int16"),
  117:         ("int16", np.iinfo("int16").min - 1, "int32"),
  118:         ("int16", np.iinfo("int32").min - 1, "int64"),
  119:         ("int16", np.iinfo("int64").min - 1, "object"),
  120:         ("uint16", 1, "uint16"),
  121:         ("uint16", np.iinfo("int8").max + 1, "uint16"),
  122:         ("uint16", np.iinfo("uint8").max + 1, "uint16"),
  123:         ("uint16", np.iinfo("int16").max + 1, "uint16"),
  124:         ("uint16", np.iinfo("uint16").max + 1, "uint32"),
  125:         ("uint16", np.iinfo("int32").max + 1, "uint32"),
  126:         ("uint16", np.iinfo("uint32").max + 1, "uint64"),
  127:         ("uint16", np.iinfo("int64").max + 1, "uint64"),
  128:         ("uint16", np.iinfo("uint64").max + 1, "object"),
  129:         ("uint16", -1, "int32"),
  130:         ("uint16", np.iinfo("int8").min - 1, "int32"),
  131:         ("uint16", np.iinfo("int16").min - 1, "int32"),
  132:         ("uint16", np.iinfo("int32").min - 1, "int64"),
  133:         ("uint16", np.iinfo("int64").min - 1, "object"),
  134:         # size 32
  135:         ("int32", 1, "int32"),
  136:         ("int32", np.iinfo("int8").max + 1, "int32"),
  137:         ("int32", np.iinfo("int16").max + 1, "int32"),
  138:         ("int32", np.iinfo("int32").max + 1, "int64"),
  139:         ("int32", np.iinfo("int64").max + 1, "object"),
  140:         ("int32", -1, "int32"),
  141:         ("int32", np.iinfo("int8").min - 1, "int32"),
  142:         ("int32", np.iinfo("int16").min - 1, "int32"),
  143:         ("int32", np.iinfo("int32").min - 1, "int64"),
  144:         ("int32", np.iinfo("int64").min - 1, "object"),
  145:         ("uint32", 1, "uint32"),
  146:         ("uint32", np.iinfo("int8").max + 1, "uint32"),
  147:         ("uint32", np.iinfo("uint8").max + 1, "uint32"),
  148:         ("uint32", np.iinfo("int16").max + 1, "uint32"),
  149:         ("uint32", np.iinfo("uint16").max + 1, "uint32"),
  150:         ("uint32", np.iinfo("int32").max + 1, "uint32"),
  151:         ("uint32", np.iinfo("uint32").max + 1, "uint64"),
  152:         ("uint32", np.iinfo("int64").max + 1, "uint64"),
  153:         ("uint32", np.iinfo("uint64").max + 1, "object"),
  154:         ("uint32", -1, "int64"),
  155:         ("uint32", np.iinfo("int8").min - 1, "int64"),
  156:         ("uint32", np.iinfo("int16").min - 1, "int64"),
  157:         ("uint32", np.iinfo("int32").min - 1, "int64"),
  158:         ("uint32", np.iinfo("int64").min - 1, "object"),
  159:         # size 64
  160:         ("int64", 1, "int64"),
  161:         ("int64", np.iinfo("int8").max + 1, "int64"),
  162:         ("int64", np.iinfo("int16").max + 1, "int64"),
  163:         ("int64", np.iinfo("int32").max + 1, "int64"),
  164:         ("int64", np.iinfo("int64").max + 1, "object"),
  165:         ("int64", -1, "int64"),
  166:         ("int64", np.iinfo("int8").min - 1, "int64"),
  167:         ("int64", np.iinfo("int16").min - 1, "int64"),
  168:         ("int64", np.iinfo("int32").min - 1, "int64"),
  169:         ("int64", np.iinfo("int64").min - 1, "object"),
  170:         ("uint64", 1, "uint64"),
  171:         ("uint64", np.iinfo("int8").max + 1, "uint64"),
  172:         ("uint64", np.iinfo("uint8").max + 1, "uint64"),
  173:         ("uint64", np.iinfo("int16").max + 1, "uint64"),
  174:         ("uint64", np.iinfo("uint16").max + 1, "uint64"),
  175:         ("uint64", np.iinfo("int32").max + 1, "uint64"),
  176:         ("uint64", np.iinfo("uint32").max + 1, "uint64"),
  177:         ("uint64", np.iinfo("int64").max + 1, "uint64"),
  178:         ("uint64", np.iinfo("uint64").max + 1, "object"),
  179:         ("uint64", -1, "object"),
  180:         ("uint64", np.iinfo("int8").min - 1, "object"),
  181:         ("uint64", np.iinfo("int16").min - 1, "object"),
  182:         ("uint64", np.iinfo("int32").min - 1, "object"),
  183:         ("uint64", np.iinfo("int64").min - 1, "object"),
  184:     ],
  185: )
  186: def test_maybe_promote_int_with_int(dtype, fill_value, expected_dtype):
  187:     dtype = np.dtype(dtype)
  188:     expected_dtype = np.dtype(expected_dtype)
  189: 
  190:     # output is not a generic int, but corresponds to expected_dtype
  191:     exp_val_for_scalar = np.array([fill_value], dtype=expected_dtype)[0]
  192: 
  193:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  194: 
  195: 
  196: def test_maybe_promote_int_with_float(any_int_numpy_dtype, float_numpy_dtype):
  197:     dtype = np.dtype(any_int_numpy_dtype)
  198:     fill_dtype = np.dtype(float_numpy_dtype)
  199: 
  200:     # create array of given dtype; casts "1" to correct dtype
  201:     fill_value = np.array([1], dtype=fill_dtype)[0]
  202: 
  203:     # filling int with float always upcasts to float64
  204:     expected_dtype = np.float64
  205:     # fill_value can be different float type
  206:     exp_val_for_scalar = np.float64(fill_value)
  207: 
  208:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  209: 
  210: 
  211: def test_maybe_promote_float_with_int(float_numpy_dtype, any_int_numpy_dtype):
  212:     dtype = np.dtype(float_numpy_dtype)
  213:     fill_dtype = np.dtype(any_int_numpy_dtype)
  214: 
  215:     # create array of given dtype; casts "1" to correct dtype
  216:     fill_value = np.array([1], dtype=fill_dtype)[0]
  217: 
  218:     # filling float with int always keeps float dtype
  219:     # because: np.finfo('float32').max > np.iinfo('uint64').max
  220:     expected_dtype = dtype
  221:     # output is not a generic float, but corresponds to expected_dtype
  222:     exp_val_for_scalar = np.array([fill_value], dtype=expected_dtype)[0]
  223: 
  224:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  225: 
  226: 
  227: @pytest.mark.parametrize(
  228:     "dtype, fill_value, expected_dtype",
  229:     [
  230:         # float filled with float
  231:         ("float32", 1, "float32"),
  232:         ("float32", float(np.finfo("float32").max) * 1.1, "float64"),
  233:         ("float64", 1, "float64"),
  234:         ("float64", float(np.finfo("float32").max) * 1.1, "float64"),
  235:         # complex filled with float
  236:         ("complex64", 1, "complex64"),
  237:         ("complex64", float(np.finfo("float32").max) * 1.1, "complex128"),
  238:         ("complex128", 1, "complex128"),
  239:         ("complex128", float(np.finfo("float32").max) * 1.1, "complex128"),
  240:         # float filled with complex
  241:         ("float32", 1 + 1j, "complex64"),
  242:         ("float32", float(np.finfo("float32").max) * (1.1 + 1j), "complex128"),
  243:         ("float64", 1 + 1j, "complex128"),
  244:         ("float64", float(np.finfo("float32").max) * (1.1 + 1j), "complex128"),
  245:         # complex filled with complex
  246:         ("complex64", 1 + 1j, "complex64"),
  247:         ("complex64", float(np.finfo("float32").max) * (1.1 + 1j), "complex128"),
  248:         ("complex128", 1 + 1j, "complex128"),
  249:         ("complex128", float(np.finfo("float32").max) * (1.1 + 1j), "complex128"),
  250:     ],
  251: )
  252: def test_maybe_promote_float_with_float(dtype, fill_value, expected_dtype):
  253:     dtype = np.dtype(dtype)
  254:     expected_dtype = np.dtype(expected_dtype)
  255: 
  256:     # output is not a generic float, but corresponds to expected_dtype
  257:     exp_val_for_scalar = np.array([fill_value], dtype=expected_dtype)[0]
  258: 
  259:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  260: 
  261: 
  262: def test_maybe_promote_bool_with_any(any_numpy_dtype):
  263:     dtype = np.dtype(bool)
  264:     fill_dtype = np.dtype(any_numpy_dtype)
  265: 
  266:     # create array of given dtype; casts "1" to correct dtype
  267:     fill_value = np.array([1], dtype=fill_dtype)[0]
  268: 
  269:     # filling bool with anything but bool casts to object
  270:     expected_dtype = np.dtype(object) if fill_dtype != bool else fill_dtype
  271:     exp_val_for_scalar = fill_value
  272: 
  273:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  274: 
  275: 
  276: def test_maybe_promote_any_with_bool(any_numpy_dtype):
  277:     dtype = np.dtype(any_numpy_dtype)
  278:     fill_value = True
  279: 
  280:     # filling anything but bool with bool casts to object
  281:     expected_dtype = np.dtype(object) if dtype != bool else dtype
  282:     # output is not a generic bool, but corresponds to expected_dtype
  283:     exp_val_for_scalar = np.array([fill_value], dtype=expected_dtype)[0]
  284: 
  285:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  286: 
  287: 
  288: def test_maybe_promote_bytes_with_any(bytes_dtype, any_numpy_dtype):
  289:     dtype = np.dtype(bytes_dtype)
  290:     fill_dtype = np.dtype(any_numpy_dtype)
  291: 
  292:     # create array of given dtype; casts "1" to correct dtype
  293:     fill_value = np.array([1], dtype=fill_dtype)[0]
  294: 
  295:     # we never use bytes dtype internally, always promote to object
  296:     expected_dtype = np.dtype(np.object_)
  297:     exp_val_for_scalar = fill_value
  298: 
  299:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  300: 
  301: 
  302: def test_maybe_promote_any_with_bytes(any_numpy_dtype):
  303:     dtype = np.dtype(any_numpy_dtype)
  304: 
  305:     # create array of given dtype
  306:     fill_value = b"abc"
  307: 
  308:     # we never use bytes dtype internally, always promote to object
  309:     expected_dtype = np.dtype(np.object_)
  310:     # output is not a generic bytes, but corresponds to expected_dtype
  311:     exp_val_for_scalar = np.array([fill_value], dtype=expected_dtype)[0]
  312: 
  313:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  314: 
  315: 
  316: def test_maybe_promote_datetime64_with_any(datetime64_dtype, any_numpy_dtype):
  317:     dtype = np.dtype(datetime64_dtype)
  318:     fill_dtype = np.dtype(any_numpy_dtype)
  319: 
  320:     # create array of given dtype; casts "1" to correct dtype
  321:     fill_value = np.array([1], dtype=fill_dtype)[0]
  322: 
  323:     # filling datetime with anything but datetime casts to object
  324:     if fill_dtype.kind == "M":
  325:         expected_dtype = dtype
  326:         # for datetime dtypes, scalar values get cast to to_datetime64
  327:         exp_val_for_scalar = pd.Timestamp(fill_value).to_datetime64()
  328:     else:
  329:         expected_dtype = np.dtype(object)
  330:         exp_val_for_scalar = fill_value
  331: 
  332:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  333: 
  334: 
  335: @pytest.mark.parametrize(
  336:     "fill_value",
  337:     [
  338:         pd.Timestamp("now"),
  339:         np.datetime64("now"),
  340:         datetime.datetime.now(),
  341:         datetime.date.today(),
  342:     ],
  343:     ids=["pd.Timestamp", "np.datetime64", "datetime.datetime", "datetime.date"],
  344: )
  345: def test_maybe_promote_any_with_datetime64(any_numpy_dtype, fill_value):
  346:     dtype = np.dtype(any_numpy_dtype)
  347: 
  348:     # filling datetime with anything but datetime casts to object
  349:     if dtype.kind == "M":
  350:         expected_dtype = dtype
  351:         # for datetime dtypes, scalar values get cast to pd.Timestamp.value
  352:         exp_val_for_scalar = pd.Timestamp(fill_value).to_datetime64()
  353:     else:
  354:         expected_dtype = np.dtype(object)
  355:         exp_val_for_scalar = fill_value
  356: 
  357:     if type(fill_value) is datetime.date and dtype.kind == "M":
  358:         # Casting date to dt64 is deprecated, in 2.0 enforced to cast to object
  359:         expected_dtype = np.dtype(object)
  360:         exp_val_for_scalar = fill_value
  361: 
  362:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  363: 
  364: 
  365: @pytest.mark.parametrize(
  366:     "fill_value",
  367:     [
  368:         pd.Timestamp(2023, 1, 1),
  369:         np.datetime64("2023-01-01"),
  370:         datetime.datetime(2023, 1, 1),
  371:         datetime.date(2023, 1, 1),
  372:     ],
  373:     ids=["pd.Timestamp", "np.datetime64", "datetime.datetime", "datetime.date"],
  374: )
  375: def test_maybe_promote_any_numpy_dtype_with_datetimetz(
  376:     any_numpy_dtype, tz_aware_fixture, fill_value
  377: ):
  378:     dtype = np.dtype(any_numpy_dtype)
  379:     fill_dtype = DatetimeTZDtype(tz=tz_aware_fixture)
  380: 
  381:     fill_value = pd.Series([fill_value], dtype=fill_dtype)[0]
  382: 
  383:     # filling any numpy dtype with datetimetz casts to object
  384:     expected_dtype = np.dtype(object)
  385:     exp_val_for_scalar = fill_value
  386: 
  387:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  388: 
  389: 
  390: def test_maybe_promote_timedelta64_with_any(timedelta64_dtype, any_numpy_dtype):
  391:     dtype = np.dtype(timedelta64_dtype)
  392:     fill_dtype = np.dtype(any_numpy_dtype)
  393: 
  394:     # create array of given dtype; casts "1" to correct dtype
  395:     fill_value = np.array([1], dtype=fill_dtype)[0]
  396: 
  397:     # filling timedelta with anything but timedelta casts to object
  398:     if fill_dtype.kind == "m":
  399:         expected_dtype = dtype
  400:         # for timedelta dtypes, scalar values get cast to pd.Timedelta.value
  401:         exp_val_for_scalar = pd.Timedelta(fill_value).to_timedelta64()
  402:     else:
  403:         expected_dtype = np.dtype(object)
  404:         exp_val_for_scalar = fill_value
  405: 
  406:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  407: 
  408: 
  409: @pytest.mark.parametrize(
  410:     "fill_value",
  411:     [pd.Timedelta(days=1), np.timedelta64(24, "h"), datetime.timedelta(1)],
  412:     ids=["pd.Timedelta", "np.timedelta64", "datetime.timedelta"],
  413: )
  414: def test_maybe_promote_any_with_timedelta64(any_numpy_dtype, fill_value):
  415:     dtype = np.dtype(any_numpy_dtype)
  416: 
  417:     # filling anything but timedelta with timedelta casts to object
  418:     if dtype.kind == "m":
  419:         expected_dtype = dtype
  420:         # for timedelta dtypes, scalar values get cast to pd.Timedelta.value
  421:         exp_val_for_scalar = pd.Timedelta(fill_value).to_timedelta64()
  422:     else:
  423:         expected_dtype = np.dtype(object)
  424:         exp_val_for_scalar = fill_value
  425: 
  426:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  427: 
  428: 
  429: def test_maybe_promote_string_with_any(string_dtype, any_numpy_dtype):
  430:     dtype = np.dtype(string_dtype)
  431:     fill_dtype = np.dtype(any_numpy_dtype)
  432: 
  433:     # create array of given dtype; casts "1" to correct dtype
  434:     fill_value = np.array([1], dtype=fill_dtype)[0]
  435: 
  436:     # filling string with anything casts to object
  437:     expected_dtype = np.dtype(object)
  438:     exp_val_for_scalar = fill_value
  439: 
  440:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  441: 
  442: 
  443: def test_maybe_promote_any_with_string(any_numpy_dtype):
  444:     dtype = np.dtype(any_numpy_dtype)
  445: 
  446:     # create array of given dtype
  447:     fill_value = "abc"
  448: 
  449:     # filling anything with a string casts to object
  450:     expected_dtype = np.dtype(object)
  451:     exp_val_for_scalar = fill_value
  452: 
  453:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  454: 
  455: 
  456: def test_maybe_promote_object_with_any(object_dtype, any_numpy_dtype):
  457:     dtype = np.dtype(object_dtype)
  458:     fill_dtype = np.dtype(any_numpy_dtype)
  459: 
  460:     # create array of given dtype; casts "1" to correct dtype
  461:     fill_value = np.array([1], dtype=fill_dtype)[0]
  462: 
  463:     # filling object with anything stays object
  464:     expected_dtype = np.dtype(object)
  465:     exp_val_for_scalar = fill_value
  466: 
  467:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  468: 
  469: 
  470: def test_maybe_promote_any_with_object(any_numpy_dtype):
  471:     dtype = np.dtype(any_numpy_dtype)
  472: 
  473:     # create array of object dtype from a scalar value (i.e. passing
  474:     # dtypes.common.is_scalar), which can however not be cast to int/float etc.
  475:     fill_value = pd.DateOffset(1)
  476: 
  477:     # filling object with anything stays object
  478:     expected_dtype = np.dtype(object)
  479:     exp_val_for_scalar = fill_value
  480: 
  481:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
  482: 
  483: 
  484: def test_maybe_promote_any_numpy_dtype_with_na(any_numpy_dtype, nulls_fixture):
  485:     fill_value = nulls_fixture
  486:     dtype = np.dtype(any_numpy_dtype)
  487: 
  488:     if isinstance(fill_value, Decimal):
  489:         # Subject to change, but ATM (When Decimal(NAN) is being added to nulls_fixture)
  490:         #  this is the existing behavior in maybe_promote,
  491:         #  hinges on is_valid_na_for_dtype
  492:         if dtype.kind in "iufc":
  493:             if dtype.kind in "iu":
  494:                 expected_dtype = np.dtype(np.float64)
  495:             else:
  496:                 expected_dtype = dtype
  497:             exp_val_for_scalar = np.nan
  498:         else:
  499:             expected_dtype = np.dtype(object)
  500:             exp_val_for_scalar = fill_value
  501:     elif dtype.kind in "iu" and fill_value is not NaT:
  502:         # integer + other missing value (np.nan / None) casts to float
  503:         expected_dtype = np.float64
  504:         exp_val_for_scalar = np.nan
  505:     elif dtype == object and fill_value is NaT:
  506:         # inserting into object does not cast the value
  507:         # but *does* cast None to np.nan
  508:         expected_dtype = np.dtype(object)
  509:         exp_val_for_scalar = fill_value
  510:     elif dtype.kind in "mM":
  511:         # datetime / timedelta cast all missing values to dtyped-NaT
  512:         expected_dtype = dtype
  513:         exp_val_for_scalar = dtype.type("NaT", "ns")
  514:     elif fill_value is NaT:
  515:         # NaT upcasts everything that's not datetime/timedelta to object
  516:         expected_dtype = np.dtype(object)
  517:         exp_val_for_scalar = NaT
  518:     elif dtype.kind in "fc":
  519:         # float / complex + missing value (!= NaT) stays the same
  520:         expected_dtype = dtype
  521:         exp_val_for_scalar = np.nan
  522:     else:
  523:         # all other cases cast to object, and use np.nan as missing value
  524:         expected_dtype = np.dtype(object)
  525:         if fill_value is pd.NA:
  526:             exp_val_for_scalar = pd.NA
  527:         else:
  528:             exp_val_for_scalar = np.nan
  529: 
  530:     _check_promote(dtype, fill_value, expected_dtype, exp_val_for_scalar)
