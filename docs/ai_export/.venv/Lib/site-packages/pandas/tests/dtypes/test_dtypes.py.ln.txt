    1: import re
    2: import weakref
    3: 
    4: import numpy as np
    5: import pytest
    6: import pytz
    7: 
    8: from pandas._libs.tslibs.dtypes import NpyDatetimeUnit
    9: 
   10: from pandas.core.dtypes.base import _registry as registry
   11: from pandas.core.dtypes.common import (
   12:     is_bool_dtype,
   13:     is_categorical_dtype,
   14:     is_datetime64_any_dtype,
   15:     is_datetime64_dtype,
   16:     is_datetime64_ns_dtype,
   17:     is_datetime64tz_dtype,
   18:     is_dtype_equal,
   19:     is_interval_dtype,
   20:     is_period_dtype,
   21:     is_string_dtype,
   22: )
   23: from pandas.core.dtypes.dtypes import (
   24:     CategoricalDtype,
   25:     DatetimeTZDtype,
   26:     IntervalDtype,
   27:     PeriodDtype,
   28: )
   29: 
   30: import pandas as pd
   31: from pandas import (
   32:     Categorical,
   33:     CategoricalIndex,
   34:     DatetimeIndex,
   35:     IntervalIndex,
   36:     Series,
   37:     SparseDtype,
   38:     date_range,
   39: )
   40: import pandas._testing as tm
   41: from pandas.core.arrays.sparse import SparseArray
   42: 
   43: 
   44: class Base:
   45:     def test_hash(self, dtype):
   46:         hash(dtype)
   47: 
   48:     def test_equality_invalid(self, dtype):
   49:         assert not dtype == "foo"
   50:         assert not is_dtype_equal(dtype, np.int64)
   51: 
   52:     def test_numpy_informed(self, dtype):
   53:         # npdev 2020-02-02 changed from "data type not understood" to
   54:         #  "Cannot interpret 'foo' as a data type"
   55:         msg = "|".join(
   56:             ["data type not understood", "Cannot interpret '.*' as a data type"]
   57:         )
   58:         with pytest.raises(TypeError, match=msg):
   59:             np.dtype(dtype)
   60: 
   61:         assert not dtype == np.str_
   62:         assert not np.str_ == dtype
   63: 
   64:     def test_pickle(self, dtype):
   65:         # make sure our cache is NOT pickled
   66: 
   67:         # clear the cache
   68:         type(dtype).reset_cache()
   69:         assert not len(dtype._cache_dtypes)
   70: 
   71:         # force back to the cache
   72:         result = tm.round_trip_pickle(dtype)
   73:         if not isinstance(dtype, PeriodDtype):
   74:             # Because PeriodDtype has a cython class as a base class,
   75:             #  it has different pickle semantics, and its cache is re-populated
   76:             #  on un-pickling.
   77:             assert not len(dtype._cache_dtypes)
   78:         assert result == dtype
   79: 
   80: 
   81: class TestCategoricalDtype(Base):
   82:     @pytest.fixture
   83:     def dtype(self):
   84:         """
   85:         Class level fixture of dtype for TestCategoricalDtype
   86:         """
   87:         return CategoricalDtype()
   88: 
   89:     def test_hash_vs_equality(self, dtype):
   90:         dtype2 = CategoricalDtype()
   91:         assert dtype == dtype2
   92:         assert dtype2 == dtype
   93:         assert hash(dtype) == hash(dtype2)
   94: 
   95:     def test_equality(self, dtype):
   96:         assert dtype == "category"
   97:         assert is_dtype_equal(dtype, "category")
   98:         assert "category" == dtype
   99:         assert is_dtype_equal("category", dtype)
  100: 
  101:         assert dtype == CategoricalDtype()
  102:         assert is_dtype_equal(dtype, CategoricalDtype())
  103:         assert CategoricalDtype() == dtype
  104:         assert is_dtype_equal(CategoricalDtype(), dtype)
  105: 
  106:         assert dtype != "foo"
  107:         assert not is_dtype_equal(dtype, "foo")
  108:         assert "foo" != dtype
  109:         assert not is_dtype_equal("foo", dtype)
  110: 
  111:     def test_construction_from_string(self, dtype):
  112:         result = CategoricalDtype.construct_from_string("category")
  113:         assert is_dtype_equal(dtype, result)
  114:         msg = "Cannot construct a 'CategoricalDtype' from 'foo'"
  115:         with pytest.raises(TypeError, match=msg):
  116:             CategoricalDtype.construct_from_string("foo")
  117: 
  118:     def test_constructor_invalid(self):
  119:         msg = "Parameter 'categories' must be list-like"
  120:         with pytest.raises(TypeError, match=msg):
  121:             CategoricalDtype("category")
  122: 
  123:     dtype1 = CategoricalDtype(["a", "b"], ordered=True)
  124:     dtype2 = CategoricalDtype(["x", "y"], ordered=False)
  125:     c = Categorical([0, 1], dtype=dtype1)
  126: 
  127:     @pytest.mark.parametrize(
  128:         "values, categories, ordered, dtype, expected",
  129:         [
  130:             [None, None, None, None, CategoricalDtype()],
  131:             [None, ["a", "b"], True, None, dtype1],
  132:             [c, None, None, dtype2, dtype2],
  133:             [c, ["x", "y"], False, None, dtype2],
  134:         ],
  135:     )
  136:     def test_from_values_or_dtype(self, values, categories, ordered, dtype, expected):
  137:         result = CategoricalDtype._from_values_or_dtype(
  138:             values, categories, ordered, dtype
  139:         )
  140:         assert result == expected
  141: 
  142:     @pytest.mark.parametrize(
  143:         "values, categories, ordered, dtype",
  144:         [
  145:             [None, ["a", "b"], True, dtype2],
  146:             [None, ["a", "b"], None, dtype2],
  147:             [None, None, True, dtype2],
  148:         ],
  149:     )
  150:     def test_from_values_or_dtype_raises(self, values, categories, ordered, dtype):
  151:         msg = "Cannot specify `categories` or `ordered` together with `dtype`."
  152:         with pytest.raises(ValueError, match=msg):
  153:             CategoricalDtype._from_values_or_dtype(values, categories, ordered, dtype)
  154: 
  155:     def test_from_values_or_dtype_invalid_dtype(self):
  156:         msg = "Cannot not construct CategoricalDtype from <class 'object'>"
  157:         with pytest.raises(ValueError, match=msg):
  158:             CategoricalDtype._from_values_or_dtype(None, None, None, object)
  159: 
  160:     def test_is_dtype(self, dtype):
  161:         assert CategoricalDtype.is_dtype(dtype)
  162:         assert CategoricalDtype.is_dtype("category")
  163:         assert CategoricalDtype.is_dtype(CategoricalDtype())
  164:         assert not CategoricalDtype.is_dtype("foo")
  165:         assert not CategoricalDtype.is_dtype(np.float64)
  166: 
  167:     def test_basic(self, dtype):
  168:         msg = "is_categorical_dtype is deprecated"
  169:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  170:             assert is_categorical_dtype(dtype)
  171: 
  172:             factor = Categorical(["a", "b", "b", "a", "a", "c", "c", "c"])
  173: 
  174:             s = Series(factor, name="A")
  175: 
  176:             # dtypes
  177:             assert is_categorical_dtype(s.dtype)
  178:             assert is_categorical_dtype(s)
  179:             assert not is_categorical_dtype(np.dtype("float64"))
  180: 
  181:     def test_tuple_categories(self):
  182:         categories = [(1, "a"), (2, "b"), (3, "c")]
  183:         result = CategoricalDtype(categories)
  184:         assert all(result.categories == categories)
  185: 
  186:     @pytest.mark.parametrize(
  187:         "categories, expected",
  188:         [
  189:             ([True, False], True),
  190:             ([True, False, None], True),
  191:             ([True, False, "a", "b'"], False),
  192:             ([0, 1], False),
  193:         ],
  194:     )
  195:     def test_is_boolean(self, categories, expected):
  196:         cat = Categorical(categories)
  197:         assert cat.dtype._is_boolean is expected
  198:         assert is_bool_dtype(cat) is expected
  199:         assert is_bool_dtype(cat.dtype) is expected
  200: 
  201:     def test_dtype_specific_categorical_dtype(self):
  202:         expected = "datetime64[ns]"
  203:         dti = DatetimeIndex([], dtype=expected)
  204:         result = str(Categorical(dti).categories.dtype)
  205:         assert result == expected
  206: 
  207:     def test_not_string(self):
  208:         # though CategoricalDtype has object kind, it cannot be string
  209:         assert not is_string_dtype(CategoricalDtype())
  210: 
  211:     def test_repr_range_categories(self):
  212:         rng = pd.Index(range(3))
  213:         dtype = CategoricalDtype(categories=rng, ordered=False)
  214:         result = repr(dtype)
  215: 
  216:         expected = (
  217:             "CategoricalDtype(categories=range(0, 3), ordered=False, "
  218:             "categories_dtype=int64)"
  219:         )
  220:         assert result == expected
  221: 
  222:     def test_update_dtype(self):
  223:         # GH 27338
  224:         result = CategoricalDtype(["a"]).update_dtype(Categorical(["b"], ordered=True))
  225:         expected = CategoricalDtype(["b"], ordered=True)
  226:         assert result == expected
  227: 
  228:     def test_repr(self):
  229:         cat = Categorical(pd.Index([1, 2, 3], dtype="int32"))
  230:         result = cat.dtype.__repr__()
  231:         expected = (
  232:             "CategoricalDtype(categories=[1, 2, 3], ordered=False, "
  233:             "categories_dtype=int32)"
  234:         )
  235:         assert result == expected
  236: 
  237: 
  238: class TestDatetimeTZDtype(Base):
  239:     @pytest.fixture
  240:     def dtype(self):
  241:         """
  242:         Class level fixture of dtype for TestDatetimeTZDtype
  243:         """
  244:         return DatetimeTZDtype("ns", "US/Eastern")
  245: 
  246:     def test_alias_to_unit_raises(self):
  247:         # 23990
  248:         with pytest.raises(ValueError, match="Passing a dtype alias"):
  249:             DatetimeTZDtype("datetime64[ns, US/Central]")
  250: 
  251:     def test_alias_to_unit_bad_alias_raises(self):
  252:         # 23990
  253:         with pytest.raises(TypeError, match=""):
  254:             DatetimeTZDtype("this is a bad string")
  255: 
  256:         with pytest.raises(TypeError, match=""):
  257:             DatetimeTZDtype("datetime64[ns, US/NotATZ]")
  258: 
  259:     def test_hash_vs_equality(self, dtype):
  260:         # make sure that we satisfy is semantics
  261:         dtype2 = DatetimeTZDtype("ns", "US/Eastern")
  262:         dtype3 = DatetimeTZDtype(dtype2)
  263:         assert dtype == dtype2
  264:         assert dtype2 == dtype
  265:         assert dtype3 == dtype
  266:         assert hash(dtype) == hash(dtype2)
  267:         assert hash(dtype) == hash(dtype3)
  268: 
  269:         dtype4 = DatetimeTZDtype("ns", "US/Central")
  270:         assert dtype2 != dtype4
  271:         assert hash(dtype2) != hash(dtype4)
  272: 
  273:     def test_construction_non_nanosecond(self):
  274:         res = DatetimeTZDtype("ms", "US/Eastern")
  275:         assert res.unit == "ms"
  276:         assert res._creso == NpyDatetimeUnit.NPY_FR_ms.value
  277:         assert res.str == "|M8[ms]"
  278:         assert str(res) == "datetime64[ms, US/Eastern]"
  279:         assert res.base == np.dtype("M8[ms]")
  280: 
  281:     def test_day_not_supported(self):
  282:         msg = "DatetimeTZDtype only supports s, ms, us, ns units"
  283:         with pytest.raises(ValueError, match=msg):
  284:             DatetimeTZDtype("D", "US/Eastern")
  285: 
  286:     def test_subclass(self):
  287:         a = DatetimeTZDtype.construct_from_string("datetime64[ns, US/Eastern]")
  288:         b = DatetimeTZDtype.construct_from_string("datetime64[ns, CET]")
  289: 
  290:         assert issubclass(type(a), type(a))
  291:         assert issubclass(type(a), type(b))
  292: 
  293:     def test_compat(self, dtype):
  294:         msg = "is_datetime64tz_dtype is deprecated"
  295:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  296:             assert is_datetime64tz_dtype(dtype)
  297:             assert is_datetime64tz_dtype("datetime64[ns, US/Eastern]")
  298:         assert is_datetime64_any_dtype(dtype)
  299:         assert is_datetime64_any_dtype("datetime64[ns, US/Eastern]")
  300:         assert is_datetime64_ns_dtype(dtype)
  301:         assert is_datetime64_ns_dtype("datetime64[ns, US/Eastern]")
  302:         assert not is_datetime64_dtype(dtype)
  303:         assert not is_datetime64_dtype("datetime64[ns, US/Eastern]")
  304: 
  305:     def test_construction_from_string(self, dtype):
  306:         result = DatetimeTZDtype.construct_from_string("datetime64[ns, US/Eastern]")
  307:         assert is_dtype_equal(dtype, result)
  308: 
  309:     @pytest.mark.parametrize(
  310:         "string",
  311:         [
  312:             "foo",
  313:             "datetime64[ns, notatz]",
  314:             # non-nano unit
  315:             "datetime64[ps, UTC]",
  316:             # dateutil str that returns None from gettz
  317:             "datetime64[ns, dateutil/invalid]",
  318:         ],
  319:     )
  320:     def test_construct_from_string_invalid_raises(self, string):
  321:         msg = f"Cannot construct a 'DatetimeTZDtype' from '{string}'"
  322:         with pytest.raises(TypeError, match=re.escape(msg)):
  323:             DatetimeTZDtype.construct_from_string(string)
  324: 
  325:     def test_construct_from_string_wrong_type_raises(self):
  326:         msg = "'construct_from_string' expects a string, got <class 'list'>"
  327:         with pytest.raises(TypeError, match=msg):
  328:             DatetimeTZDtype.construct_from_string(["datetime64[ns, notatz]"])
  329: 
  330:     def test_is_dtype(self, dtype):
  331:         assert not DatetimeTZDtype.is_dtype(None)
  332:         assert DatetimeTZDtype.is_dtype(dtype)
  333:         assert DatetimeTZDtype.is_dtype("datetime64[ns, US/Eastern]")
  334:         assert DatetimeTZDtype.is_dtype("M8[ns, US/Eastern]")
  335:         assert not DatetimeTZDtype.is_dtype("foo")
  336:         assert DatetimeTZDtype.is_dtype(DatetimeTZDtype("ns", "US/Pacific"))
  337:         assert not DatetimeTZDtype.is_dtype(np.float64)
  338: 
  339:     def test_equality(self, dtype):
  340:         assert is_dtype_equal(dtype, "datetime64[ns, US/Eastern]")
  341:         assert is_dtype_equal(dtype, "M8[ns, US/Eastern]")
  342:         assert is_dtype_equal(dtype, DatetimeTZDtype("ns", "US/Eastern"))
  343:         assert not is_dtype_equal(dtype, "foo")
  344:         assert not is_dtype_equal(dtype, DatetimeTZDtype("ns", "CET"))
  345:         assert not is_dtype_equal(
  346:             DatetimeTZDtype("ns", "US/Eastern"), DatetimeTZDtype("ns", "US/Pacific")
  347:         )
  348: 
  349:         # numpy compat
  350:         assert is_dtype_equal(np.dtype("M8[ns]"), "datetime64[ns]")
  351: 
  352:         assert dtype == "M8[ns, US/Eastern]"
  353: 
  354:     def test_basic(self, dtype):
  355:         msg = "is_datetime64tz_dtype is deprecated"
  356:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  357:             assert is_datetime64tz_dtype(dtype)
  358: 
  359:         dr = date_range("20130101", periods=3, tz="US/Eastern")
  360:         s = Series(dr, name="A")
  361: 
  362:         # dtypes
  363:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  364:             assert is_datetime64tz_dtype(s.dtype)
  365:             assert is_datetime64tz_dtype(s)
  366:             assert not is_datetime64tz_dtype(np.dtype("float64"))
  367:             assert not is_datetime64tz_dtype(1.0)
  368: 
  369:     def test_dst(self):
  370:         dr1 = date_range("2013-01-01", periods=3, tz="US/Eastern")
  371:         s1 = Series(dr1, name="A")
  372:         assert isinstance(s1.dtype, DatetimeTZDtype)
  373: 
  374:         dr2 = date_range("2013-08-01", periods=3, tz="US/Eastern")
  375:         s2 = Series(dr2, name="A")
  376:         assert isinstance(s2.dtype, DatetimeTZDtype)
  377:         assert s1.dtype == s2.dtype
  378: 
  379:     @pytest.mark.parametrize("tz", ["UTC", "US/Eastern"])
  380:     @pytest.mark.parametrize("constructor", ["M8", "datetime64"])
  381:     def test_parser(self, tz, constructor):
  382:         # pr #11245
  383:         dtz_str = f"{constructor}[ns, {tz}]"
  384:         result = DatetimeTZDtype.construct_from_string(dtz_str)
  385:         expected = DatetimeTZDtype("ns", tz)
  386:         assert result == expected
  387: 
  388:     def test_empty(self):
  389:         with pytest.raises(TypeError, match="A 'tz' is required."):
  390:             DatetimeTZDtype()
  391: 
  392:     def test_tz_standardize(self):
  393:         # GH 24713
  394:         tz = pytz.timezone("US/Eastern")
  395:         dr = date_range("2013-01-01", periods=3, tz="US/Eastern")
  396:         dtype = DatetimeTZDtype("ns", dr.tz)
  397:         assert dtype.tz == tz
  398:         dtype = DatetimeTZDtype("ns", dr[0].tz)
  399:         assert dtype.tz == tz
  400: 
  401: 
  402: class TestPeriodDtype(Base):
  403:     @pytest.fixture
  404:     def dtype(self):
  405:         """
  406:         Class level fixture of dtype for TestPeriodDtype
  407:         """
  408:         return PeriodDtype("D")
  409: 
  410:     def test_hash_vs_equality(self, dtype):
  411:         # make sure that we satisfy is semantics
  412:         dtype2 = PeriodDtype("D")
  413:         dtype3 = PeriodDtype(dtype2)
  414:         assert dtype == dtype2
  415:         assert dtype2 == dtype
  416:         assert dtype3 == dtype
  417:         assert dtype is not dtype2
  418:         assert dtype2 is not dtype
  419:         assert dtype3 is not dtype
  420:         assert hash(dtype) == hash(dtype2)
  421:         assert hash(dtype) == hash(dtype3)
  422: 
  423:     def test_construction(self):
  424:         with pytest.raises(ValueError, match="Invalid frequency: xx"):
  425:             PeriodDtype("xx")
  426: 
  427:         for s in ["period[D]", "Period[D]", "D"]:
  428:             dt = PeriodDtype(s)
  429:             assert dt.freq == pd.tseries.offsets.Day()
  430: 
  431:         for s in ["period[3D]", "Period[3D]", "3D"]:
  432:             dt = PeriodDtype(s)
  433:             assert dt.freq == pd.tseries.offsets.Day(3)
  434: 
  435:         for s in [
  436:             "period[26h]",
  437:             "Period[26h]",
  438:             "26h",
  439:             "period[1D2h]",
  440:             "Period[1D2h]",
  441:             "1D2h",
  442:         ]:
  443:             dt = PeriodDtype(s)
  444:             assert dt.freq == pd.tseries.offsets.Hour(26)
  445: 
  446:     def test_cannot_use_custom_businessday(self):
  447:         # GH#52534
  448:         msg = "C is not supported as period frequency"
  449:         msg1 = "<CustomBusinessDay> is not supported as period frequency"
  450:         msg2 = r"PeriodDtype\[B\] is deprecated"
  451:         with pytest.raises(ValueError, match=msg):
  452:             PeriodDtype("C")
  453:         with pytest.raises(ValueError, match=msg1):
  454:             with tm.assert_produces_warning(FutureWarning, match=msg2):
  455:                 PeriodDtype(pd.offsets.CustomBusinessDay())
  456: 
  457:     def test_subclass(self):
  458:         a = PeriodDtype("period[D]")
  459:         b = PeriodDtype("period[3D]")
  460: 
  461:         assert issubclass(type(a), type(a))
  462:         assert issubclass(type(a), type(b))
  463: 
  464:     def test_identity(self):
  465:         assert PeriodDtype("period[D]") == PeriodDtype("period[D]")
  466:         assert PeriodDtype("period[D]") is not PeriodDtype("period[D]")
  467: 
  468:         assert PeriodDtype("period[3D]") == PeriodDtype("period[3D]")
  469:         assert PeriodDtype("period[3D]") is not PeriodDtype("period[3D]")
  470: 
  471:         assert PeriodDtype("period[1s1us]") == PeriodDtype("period[1000001us]")
  472:         assert PeriodDtype("period[1s1us]") is not PeriodDtype("period[1000001us]")
  473: 
  474:     def test_compat(self, dtype):
  475:         assert not is_datetime64_ns_dtype(dtype)
  476:         assert not is_datetime64_ns_dtype("period[D]")
  477:         assert not is_datetime64_dtype(dtype)
  478:         assert not is_datetime64_dtype("period[D]")
  479: 
  480:     def test_construction_from_string(self, dtype):
  481:         result = PeriodDtype("period[D]")
  482:         assert is_dtype_equal(dtype, result)
  483:         result = PeriodDtype.construct_from_string("period[D]")
  484:         assert is_dtype_equal(dtype, result)
  485: 
  486:         with pytest.raises(TypeError, match="list"):
  487:             PeriodDtype.construct_from_string([1, 2, 3])
  488: 
  489:     @pytest.mark.parametrize(
  490:         "string",
  491:         [
  492:             "foo",
  493:             "period[foo]",
  494:             "foo[D]",
  495:             "datetime64[ns]",
  496:             "datetime64[ns, US/Eastern]",
  497:         ],
  498:     )
  499:     def test_construct_dtype_from_string_invalid_raises(self, string):
  500:         msg = f"Cannot construct a 'PeriodDtype' from '{string}'"
  501:         with pytest.raises(TypeError, match=re.escape(msg)):
  502:             PeriodDtype.construct_from_string(string)
  503: 
  504:     def test_is_dtype(self, dtype):
  505:         assert PeriodDtype.is_dtype(dtype)
  506:         assert PeriodDtype.is_dtype("period[D]")
  507:         assert PeriodDtype.is_dtype("period[3D]")
  508:         assert PeriodDtype.is_dtype(PeriodDtype("3D"))
  509:         assert PeriodDtype.is_dtype("period[us]")
  510:         assert PeriodDtype.is_dtype("period[s]")
  511:         assert PeriodDtype.is_dtype(PeriodDtype("us"))
  512:         assert PeriodDtype.is_dtype(PeriodDtype("s"))
  513: 
  514:         assert not PeriodDtype.is_dtype("D")
  515:         assert not PeriodDtype.is_dtype("3D")
  516:         assert not PeriodDtype.is_dtype("U")
  517:         assert not PeriodDtype.is_dtype("s")
  518:         assert not PeriodDtype.is_dtype("foo")
  519:         assert not PeriodDtype.is_dtype(np.object_)
  520:         assert not PeriodDtype.is_dtype(np.int64)
  521:         assert not PeriodDtype.is_dtype(np.float64)
  522: 
  523:     def test_equality(self, dtype):
  524:         assert is_dtype_equal(dtype, "period[D]")
  525:         assert is_dtype_equal(dtype, PeriodDtype("D"))
  526:         assert is_dtype_equal(dtype, PeriodDtype("D"))
  527:         assert is_dtype_equal(PeriodDtype("D"), PeriodDtype("D"))
  528: 
  529:         assert not is_dtype_equal(dtype, "D")
  530:         assert not is_dtype_equal(PeriodDtype("D"), PeriodDtype("2D"))
  531: 
  532:     def test_basic(self, dtype):
  533:         msg = "is_period_dtype is deprecated"
  534:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  535:             assert is_period_dtype(dtype)
  536: 
  537:             pidx = pd.period_range("2013-01-01 09:00", periods=5, freq="h")
  538: 
  539:             assert is_period_dtype(pidx.dtype)
  540:             assert is_period_dtype(pidx)
  541: 
  542:             s = Series(pidx, name="A")
  543: 
  544:             assert is_period_dtype(s.dtype)
  545:             assert is_period_dtype(s)
  546: 
  547:             assert not is_period_dtype(np.dtype("float64"))
  548:             assert not is_period_dtype(1.0)
  549: 
  550:     def test_freq_argument_required(self):
  551:         # GH#27388
  552:         msg = "missing 1 required positional argument: 'freq'"
  553:         with pytest.raises(TypeError, match=msg):
  554:             PeriodDtype()
  555: 
  556:         msg = "PeriodDtype argument should be string or BaseOffset, got NoneType"
  557:         with pytest.raises(TypeError, match=msg):
  558:             # GH#51790
  559:             PeriodDtype(None)
  560: 
  561:     def test_not_string(self):
  562:         # though PeriodDtype has object kind, it cannot be string
  563:         assert not is_string_dtype(PeriodDtype("D"))
  564: 
  565:     def test_perioddtype_caching_dateoffset_normalize(self):
  566:         # GH 24121
  567:         per_d = PeriodDtype(pd.offsets.YearEnd(normalize=True))
  568:         assert per_d.freq.normalize
  569: 
  570:         per_d2 = PeriodDtype(pd.offsets.YearEnd(normalize=False))
  571:         assert not per_d2.freq.normalize
  572: 
  573:     def test_dont_keep_ref_after_del(self):
  574:         # GH 54184
  575:         dtype = PeriodDtype("D")
  576:         ref = weakref.ref(dtype)
  577:         del dtype
  578:         assert ref() is None
  579: 
  580: 
  581: class TestIntervalDtype(Base):
  582:     @pytest.fixture
  583:     def dtype(self):
  584:         """
  585:         Class level fixture of dtype for TestIntervalDtype
  586:         """
  587:         return IntervalDtype("int64", "right")
  588: 
  589:     def test_hash_vs_equality(self, dtype):
  590:         # make sure that we satisfy is semantics
  591:         dtype2 = IntervalDtype("int64", "right")
  592:         dtype3 = IntervalDtype(dtype2)
  593:         assert dtype == dtype2
  594:         assert dtype2 == dtype
  595:         assert dtype3 == dtype
  596:         assert dtype is not dtype2
  597:         assert dtype2 is not dtype3
  598:         assert dtype3 is not dtype
  599:         assert hash(dtype) == hash(dtype2)
  600:         assert hash(dtype) == hash(dtype3)
  601: 
  602:         dtype1 = IntervalDtype("interval")
  603:         dtype2 = IntervalDtype(dtype1)
  604:         dtype3 = IntervalDtype("interval")
  605:         assert dtype2 == dtype1
  606:         assert dtype2 == dtype2
  607:         assert dtype2 == dtype3
  608:         assert dtype2 is not dtype1
  609:         assert dtype2 is dtype2
  610:         assert dtype2 is not dtype3
  611:         assert hash(dtype2) == hash(dtype1)
  612:         assert hash(dtype2) == hash(dtype2)
  613:         assert hash(dtype2) == hash(dtype3)
  614: 
  615:     @pytest.mark.parametrize(
  616:         "subtype", ["interval[int64]", "Interval[int64]", "int64", np.dtype("int64")]
  617:     )
  618:     def test_construction(self, subtype):
  619:         i = IntervalDtype(subtype, closed="right")
  620:         assert i.subtype == np.dtype("int64")
  621:         msg = "is_interval_dtype is deprecated"
  622:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  623:             assert is_interval_dtype(i)
  624: 
  625:     @pytest.mark.parametrize(
  626:         "subtype", ["interval[int64]", "Interval[int64]", "int64", np.dtype("int64")]
  627:     )
  628:     def test_construction_allows_closed_none(self, subtype):
  629:         # GH#38394
  630:         dtype = IntervalDtype(subtype)
  631: 
  632:         assert dtype.closed is None
  633: 
  634:     def test_closed_mismatch(self):
  635:         msg = "'closed' keyword does not match value specified in dtype string"
  636:         with pytest.raises(ValueError, match=msg):
  637:             IntervalDtype("interval[int64, left]", "right")
  638: 
  639:     @pytest.mark.parametrize("subtype", [None, "interval", "Interval"])
  640:     def test_construction_generic(self, subtype):
  641:         # generic
  642:         i = IntervalDtype(subtype)
  643:         assert i.subtype is None
  644:         msg = "is_interval_dtype is deprecated"
  645:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  646:             assert is_interval_dtype(i)
  647: 
  648:     @pytest.mark.parametrize(
  649:         "subtype",
  650:         [
  651:             CategoricalDtype(list("abc"), False),
  652:             CategoricalDtype(list("wxyz"), True),
  653:             object,
  654:             str,
  655:             "<U10",
  656:             "interval[category]",
  657:             "interval[object]",
  658:         ],
  659:     )
  660:     def test_construction_not_supported(self, subtype):
  661:         # GH 19016
  662:         msg = (
  663:             "category, object, and string subtypes are not supported "
  664:             "for IntervalDtype"
  665:         )
  666:         with pytest.raises(TypeError, match=msg):
  667:             IntervalDtype(subtype)
  668: 
  669:     @pytest.mark.parametrize("subtype", ["xx", "IntervalA", "Interval[foo]"])
  670:     def test_construction_errors(self, subtype):
  671:         msg = "could not construct IntervalDtype"
  672:         with pytest.raises(TypeError, match=msg):
  673:             IntervalDtype(subtype)
  674: 
  675:     def test_closed_must_match(self):
  676:         # GH#37933
  677:         dtype = IntervalDtype(np.float64, "left")
  678: 
  679:         msg = "dtype.closed and 'closed' do not match"
  680:         with pytest.raises(ValueError, match=msg):
  681:             IntervalDtype(dtype, closed="both")
  682: 
  683:     def test_closed_invalid(self):
  684:         with pytest.raises(ValueError, match="closed must be one of"):
  685:             IntervalDtype(np.float64, "foo")
  686: 
  687:     def test_construction_from_string(self, dtype):
  688:         result = IntervalDtype("interval[int64, right]")
  689:         assert is_dtype_equal(dtype, result)
  690:         result = IntervalDtype.construct_from_string("interval[int64, right]")
  691:         assert is_dtype_equal(dtype, result)
  692: 
  693:     @pytest.mark.parametrize("string", [0, 3.14, ("a", "b"), None])
  694:     def test_construction_from_string_errors(self, string):
  695:         # these are invalid entirely
  696:         msg = f"'construct_from_string' expects a string, got {type(string)}"
  697: 
  698:         with pytest.raises(TypeError, match=re.escape(msg)):
  699:             IntervalDtype.construct_from_string(string)
  700: 
  701:     @pytest.mark.parametrize("string", ["foo", "foo[int64]", "IntervalA"])
  702:     def test_construction_from_string_error_subtype(self, string):
  703:         # this is an invalid subtype
  704:         msg = (
  705:             "Incorrectly formatted string passed to constructor. "
  706:             r"Valid formats include Interval or Interval\[dtype\] "
  707:             "where dtype is numeric, datetime, or timedelta"
  708:         )
  709: 
  710:         with pytest.raises(TypeError, match=msg):
  711:             IntervalDtype.construct_from_string(string)
  712: 
  713:     def test_subclass(self):
  714:         a = IntervalDtype("interval[int64, right]")
  715:         b = IntervalDtype("interval[int64, right]")
  716: 
  717:         assert issubclass(type(a), type(a))
  718:         assert issubclass(type(a), type(b))
  719: 
  720:     def test_is_dtype(self, dtype):
  721:         assert IntervalDtype.is_dtype(dtype)
  722:         assert IntervalDtype.is_dtype("interval")
  723:         assert IntervalDtype.is_dtype(IntervalDtype("float64"))
  724:         assert IntervalDtype.is_dtype(IntervalDtype("int64"))
  725:         assert IntervalDtype.is_dtype(IntervalDtype(np.int64))
  726:         assert IntervalDtype.is_dtype(IntervalDtype("float64", "left"))
  727:         assert IntervalDtype.is_dtype(IntervalDtype("int64", "right"))
  728:         assert IntervalDtype.is_dtype(IntervalDtype(np.int64, "both"))
  729: 
  730:         assert not IntervalDtype.is_dtype("D")
  731:         assert not IntervalDtype.is_dtype("3D")
  732:         assert not IntervalDtype.is_dtype("us")
  733:         assert not IntervalDtype.is_dtype("S")
  734:         assert not IntervalDtype.is_dtype("foo")
  735:         assert not IntervalDtype.is_dtype("IntervalA")
  736:         assert not IntervalDtype.is_dtype(np.object_)
  737:         assert not IntervalDtype.is_dtype(np.int64)
  738:         assert not IntervalDtype.is_dtype(np.float64)
  739: 
  740:     def test_equality(self, dtype):
  741:         assert is_dtype_equal(dtype, "interval[int64, right]")
  742:         assert is_dtype_equal(dtype, IntervalDtype("int64", "right"))
  743:         assert is_dtype_equal(
  744:             IntervalDtype("int64", "right"), IntervalDtype("int64", "right")
  745:         )
  746: 
  747:         assert not is_dtype_equal(dtype, "interval[int64]")
  748:         assert not is_dtype_equal(dtype, IntervalDtype("int64"))
  749:         assert not is_dtype_equal(
  750:             IntervalDtype("int64", "right"), IntervalDtype("int64")
  751:         )
  752: 
  753:         assert not is_dtype_equal(dtype, "int64")
  754:         assert not is_dtype_equal(
  755:             IntervalDtype("int64", "neither"), IntervalDtype("float64", "right")
  756:         )
  757:         assert not is_dtype_equal(
  758:             IntervalDtype("int64", "both"), IntervalDtype("int64", "left")
  759:         )
  760: 
  761:         # invalid subtype comparisons do not raise when directly compared
  762:         dtype1 = IntervalDtype("float64", "left")
  763:         dtype2 = IntervalDtype("datetime64[ns, US/Eastern]", "left")
  764:         assert dtype1 != dtype2
  765:         assert dtype2 != dtype1
  766: 
  767:     @pytest.mark.parametrize(
  768:         "subtype",
  769:         [
  770:             None,
  771:             "interval",
  772:             "Interval",
  773:             "int64",
  774:             "uint64",
  775:             "float64",
  776:             "complex128",
  777:             "datetime64",
  778:             "timedelta64",
  779:             PeriodDtype("Q"),
  780:         ],
  781:     )
  782:     def test_equality_generic(self, subtype):
  783:         # GH 18980
  784:         closed = "right" if subtype is not None else None
  785:         dtype = IntervalDtype(subtype, closed=closed)
  786:         assert is_dtype_equal(dtype, "interval")
  787:         assert is_dtype_equal(dtype, IntervalDtype())
  788: 
  789:     @pytest.mark.parametrize(
  790:         "subtype",
  791:         [
  792:             "int64",
  793:             "uint64",
  794:             "float64",
  795:             "complex128",
  796:             "datetime64",
  797:             "timedelta64",
  798:             PeriodDtype("Q"),
  799:         ],
  800:     )
  801:     def test_name_repr(self, subtype):
  802:         # GH 18980
  803:         closed = "right" if subtype is not None else None
  804:         dtype = IntervalDtype(subtype, closed=closed)
  805:         expected = f"interval[{subtype}, {closed}]"
  806:         assert str(dtype) == expected
  807:         assert dtype.name == "interval"
  808: 
  809:     @pytest.mark.parametrize("subtype", [None, "interval", "Interval"])
  810:     def test_name_repr_generic(self, subtype):
  811:         # GH 18980
  812:         dtype = IntervalDtype(subtype)
  813:         assert str(dtype) == "interval"
  814:         assert dtype.name == "interval"
  815: 
  816:     def test_basic(self, dtype):
  817:         msg = "is_interval_dtype is deprecated"
  818:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  819:             assert is_interval_dtype(dtype)
  820: 
  821:             ii = IntervalIndex.from_breaks(range(3))
  822: 
  823:             assert is_interval_dtype(ii.dtype)
  824:             assert is_interval_dtype(ii)
  825: 
  826:             s = Series(ii, name="A")
  827: 
  828:             assert is_interval_dtype(s.dtype)
  829:             assert is_interval_dtype(s)
  830: 
  831:     def test_basic_dtype(self):
  832:         msg = "is_interval_dtype is deprecated"
  833:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  834:             assert is_interval_dtype("interval[int64, both]")
  835:             assert is_interval_dtype(IntervalIndex.from_tuples([(0, 1)]))
  836:             assert is_interval_dtype(IntervalIndex.from_breaks(np.arange(4)))
  837:             assert is_interval_dtype(
  838:                 IntervalIndex.from_breaks(date_range("20130101", periods=3))
  839:             )
  840:             assert not is_interval_dtype("U")
  841:             assert not is_interval_dtype("S")
  842:             assert not is_interval_dtype("foo")
  843:             assert not is_interval_dtype(np.object_)
  844:             assert not is_interval_dtype(np.int64)
  845:             assert not is_interval_dtype(np.float64)
  846: 
  847:     def test_caching(self):
  848:         # GH 54184: Caching not shown to improve performance
  849:         IntervalDtype.reset_cache()
  850:         dtype = IntervalDtype("int64", "right")
  851:         assert len(IntervalDtype._cache_dtypes) == 0
  852: 
  853:         IntervalDtype("interval")
  854:         assert len(IntervalDtype._cache_dtypes) == 0
  855: 
  856:         IntervalDtype.reset_cache()
  857:         tm.round_trip_pickle(dtype)
  858:         assert len(IntervalDtype._cache_dtypes) == 0
  859: 
  860:     def test_not_string(self):
  861:         # GH30568: though IntervalDtype has object kind, it cannot be string
  862:         assert not is_string_dtype(IntervalDtype())
  863: 
  864:     def test_unpickling_without_closed(self):
  865:         # GH#38394
  866:         dtype = IntervalDtype("interval")
  867: 
  868:         assert dtype._closed is None
  869: 
  870:         tm.round_trip_pickle(dtype)
  871: 
  872:     def test_dont_keep_ref_after_del(self):
  873:         # GH 54184
  874:         dtype = IntervalDtype("int64", "right")
  875:         ref = weakref.ref(dtype)
  876:         del dtype
  877:         assert ref() is None
  878: 
  879: 
  880: class TestCategoricalDtypeParametrized:
  881:     @pytest.mark.parametrize(
  882:         "categories",
  883:         [
  884:             list("abcd"),
  885:             np.arange(1000),
  886:             ["a", "b", 10, 2, 1.3, True],
  887:             [True, False],
  888:             date_range("2017", periods=4),
  889:         ],
  890:     )
  891:     def test_basic(self, categories, ordered):
  892:         c1 = CategoricalDtype(categories, ordered=ordered)
  893:         tm.assert_index_equal(c1.categories, pd.Index(categories))
  894:         assert c1.ordered is ordered
  895: 
  896:     def test_order_matters(self):
  897:         categories = ["a", "b"]
  898:         c1 = CategoricalDtype(categories, ordered=True)
  899:         c2 = CategoricalDtype(categories, ordered=False)
  900:         c3 = CategoricalDtype(categories, ordered=None)
  901:         assert c1 is not c2
  902:         assert c1 is not c3
  903: 
  904:     @pytest.mark.parametrize("ordered", [False, None])
  905:     def test_unordered_same(self, ordered):
  906:         c1 = CategoricalDtype(["a", "b"], ordered=ordered)
  907:         c2 = CategoricalDtype(["b", "a"], ordered=ordered)
  908:         assert hash(c1) == hash(c2)
  909: 
  910:     def test_categories(self):
  911:         result = CategoricalDtype(["a", "b", "c"])
  912:         tm.assert_index_equal(result.categories, pd.Index(["a", "b", "c"]))
  913:         assert result.ordered is False
  914: 
  915:     def test_equal_but_different(self):
  916:         c1 = CategoricalDtype([1, 2, 3])
  917:         c2 = CategoricalDtype([1.0, 2.0, 3.0])
  918:         assert c1 is not c2
  919:         assert c1 != c2
  920: 
  921:     def test_equal_but_different_mixed_dtypes(self):
  922:         c1 = CategoricalDtype([1, 2, "3"])
  923:         c2 = CategoricalDtype(["3", 1, 2])
  924:         assert c1 is not c2
  925:         assert c1 == c2
  926: 
  927:     def test_equal_empty_ordered(self):
  928:         c1 = CategoricalDtype([], ordered=True)
  929:         c2 = CategoricalDtype([], ordered=True)
  930:         assert c1 is not c2
  931:         assert c1 == c2
  932: 
  933:     def test_equal_empty_unordered(self):
  934:         c1 = CategoricalDtype([])
  935:         c2 = CategoricalDtype([])
  936:         assert c1 is not c2
  937:         assert c1 == c2
  938: 
  939:     @pytest.mark.parametrize("v1, v2", [([1, 2, 3], [1, 2, 3]), ([1, 2, 3], [3, 2, 1])])
  940:     def test_order_hashes_different(self, v1, v2):
  941:         c1 = CategoricalDtype(v1, ordered=False)
  942:         c2 = CategoricalDtype(v2, ordered=True)
  943:         c3 = CategoricalDtype(v1, ordered=None)
  944:         assert c1 is not c2
  945:         assert c1 is not c3
  946: 
  947:     def test_nan_invalid(self):
  948:         msg = "Categorical categories cannot be null"
  949:         with pytest.raises(ValueError, match=msg):
  950:             CategoricalDtype([1, 2, np.nan])
  951: 
  952:     def test_non_unique_invalid(self):
  953:         msg = "Categorical categories must be unique"
  954:         with pytest.raises(ValueError, match=msg):
  955:             CategoricalDtype([1, 2, 1])
  956: 
  957:     def test_same_categories_different_order(self):
  958:         c1 = CategoricalDtype(["a", "b"], ordered=True)
  959:         c2 = CategoricalDtype(["b", "a"], ordered=True)
  960:         assert c1 is not c2
  961: 
  962:     @pytest.mark.parametrize("ordered1", [True, False, None])
  963:     @pytest.mark.parametrize("ordered2", [True, False, None])
  964:     def test_categorical_equality(self, ordered1, ordered2):
  965:         # same categories, same order
  966:         # any combination of None/False are equal
  967:         # True/True is the only combination with True that are equal
  968:         c1 = CategoricalDtype(list("abc"), ordered1)
  969:         c2 = CategoricalDtype(list("abc"), ordered2)
  970:         result = c1 == c2
  971:         expected = bool(ordered1) is bool(ordered2)
  972:         assert result is expected
  973: 
  974:         # same categories, different order
  975:         # any combination of None/False are equal (order doesn't matter)
  976:         # any combination with True are not equal (different order of cats)
  977:         c1 = CategoricalDtype(list("abc"), ordered1)
  978:         c2 = CategoricalDtype(list("cab"), ordered2)
  979:         result = c1 == c2
  980:         expected = (bool(ordered1) is False) and (bool(ordered2) is False)
  981:         assert result is expected
  982: 
  983:         # different categories
  984:         c2 = CategoricalDtype([1, 2, 3], ordered2)
  985:         assert c1 != c2
  986: 
  987:         # none categories
  988:         c1 = CategoricalDtype(list("abc"), ordered1)
  989:         c2 = CategoricalDtype(None, ordered2)
  990:         c3 = CategoricalDtype(None, ordered1)
  991:         assert c1 != c2
  992:         assert c2 != c1
  993:         assert c2 == c3
  994: 
  995:     def test_categorical_dtype_equality_requires_categories(self):
  996:         # CategoricalDtype with categories=None is *not* equal to
  997:         #  any fully-initialized CategoricalDtype
  998:         first = CategoricalDtype(["a", "b"])
  999:         second = CategoricalDtype()
 1000:         third = CategoricalDtype(ordered=True)
 1001: 
 1002:         assert second == second
 1003:         assert third == third
 1004: 
 1005:         assert first != second
 1006:         assert second != first
 1007:         assert first != third
 1008:         assert third != first
 1009:         assert second == third
 1010:         assert third == second
 1011: 
 1012:     @pytest.mark.parametrize("categories", [list("abc"), None])
 1013:     @pytest.mark.parametrize("other", ["category", "not a category"])
 1014:     def test_categorical_equality_strings(self, categories, ordered, other):
 1015:         c1 = CategoricalDtype(categories, ordered)
 1016:         result = c1 == other
 1017:         expected = other == "category"
 1018:         assert result is expected
 1019: 
 1020:     def test_invalid_raises(self):
 1021:         with pytest.raises(TypeError, match="ordered"):
 1022:             CategoricalDtype(["a", "b"], ordered="foo")
 1023: 
 1024:         with pytest.raises(TypeError, match="'categories' must be list-like"):
 1025:             CategoricalDtype("category")
 1026: 
 1027:     def test_mixed(self):
 1028:         a = CategoricalDtype(["a", "b", 1, 2])
 1029:         b = CategoricalDtype(["a", "b", "1", "2"])
 1030:         assert hash(a) != hash(b)
 1031: 
 1032:     def test_from_categorical_dtype_identity(self):
 1033:         c1 = Categorical([1, 2], categories=[1, 2, 3], ordered=True)
 1034:         # Identity test for no changes
 1035:         c2 = CategoricalDtype._from_categorical_dtype(c1)
 1036:         assert c2 is c1
 1037: 
 1038:     def test_from_categorical_dtype_categories(self):
 1039:         c1 = Categorical([1, 2], categories=[1, 2, 3], ordered=True)
 1040:         # override categories
 1041:         result = CategoricalDtype._from_categorical_dtype(c1, categories=[2, 3])
 1042:         assert result == CategoricalDtype([2, 3], ordered=True)
 1043: 
 1044:     def test_from_categorical_dtype_ordered(self):
 1045:         c1 = Categorical([1, 2], categories=[1, 2, 3], ordered=True)
 1046:         # override ordered
 1047:         result = CategoricalDtype._from_categorical_dtype(c1, ordered=False)
 1048:         assert result == CategoricalDtype([1, 2, 3], ordered=False)
 1049: 
 1050:     def test_from_categorical_dtype_both(self):
 1051:         c1 = Categorical([1, 2], categories=[1, 2, 3], ordered=True)
 1052:         # override ordered
 1053:         result = CategoricalDtype._from_categorical_dtype(
 1054:             c1, categories=[1, 2], ordered=False
 1055:         )
 1056:         assert result == CategoricalDtype([1, 2], ordered=False)
 1057: 
 1058:     def test_str_vs_repr(self, ordered, using_infer_string):
 1059:         c1 = CategoricalDtype(["a", "b"], ordered=ordered)
 1060:         assert str(c1) == "category"
 1061:         # Py2 will have unicode prefixes
 1062:         dtype = "string" if using_infer_string else "object"
 1063:         pat = (
 1064:             r"CategoricalDtype\(categories=\[.*\], ordered={ordered}, "
 1065:             rf"categories_dtype={dtype}\)"
 1066:         )
 1067:         assert re.match(pat.format(ordered=ordered), repr(c1))
 1068: 
 1069:     def test_categorical_categories(self):
 1070:         # GH17884
 1071:         c1 = CategoricalDtype(Categorical(["a", "b"]))
 1072:         tm.assert_index_equal(c1.categories, pd.Index(["a", "b"]))
 1073:         c1 = CategoricalDtype(CategoricalIndex(["a", "b"]))
 1074:         tm.assert_index_equal(c1.categories, pd.Index(["a", "b"]))
 1075: 
 1076:     @pytest.mark.parametrize(
 1077:         "new_categories", [list("abc"), list("cba"), list("wxyz"), None]
 1078:     )
 1079:     @pytest.mark.parametrize("new_ordered", [True, False, None])
 1080:     def test_update_dtype(self, ordered, new_categories, new_ordered):
 1081:         original_categories = list("abc")
 1082:         dtype = CategoricalDtype(original_categories, ordered)
 1083:         new_dtype = CategoricalDtype(new_categories, new_ordered)
 1084: 
 1085:         result = dtype.update_dtype(new_dtype)
 1086:         expected_categories = pd.Index(new_categories or original_categories)
 1087:         expected_ordered = new_ordered if new_ordered is not None else dtype.ordered
 1088: 
 1089:         tm.assert_index_equal(result.categories, expected_categories)
 1090:         assert result.ordered is expected_ordered
 1091: 
 1092:     def test_update_dtype_string(self, ordered):
 1093:         dtype = CategoricalDtype(list("abc"), ordered)
 1094:         expected_categories = dtype.categories
 1095:         expected_ordered = dtype.ordered
 1096:         result = dtype.update_dtype("category")
 1097:         tm.assert_index_equal(result.categories, expected_categories)
 1098:         assert result.ordered is expected_ordered
 1099: 
 1100:     @pytest.mark.parametrize("bad_dtype", ["foo", object, np.int64, PeriodDtype("Q")])
 1101:     def test_update_dtype_errors(self, bad_dtype):
 1102:         dtype = CategoricalDtype(list("abc"), False)
 1103:         msg = "a CategoricalDtype must be passed to perform an update, "
 1104:         with pytest.raises(ValueError, match=msg):
 1105:             dtype.update_dtype(bad_dtype)
 1106: 
 1107: 
 1108: @pytest.mark.parametrize(
 1109:     "dtype", [CategoricalDtype, IntervalDtype, DatetimeTZDtype, PeriodDtype]
 1110: )
 1111: def test_registry(dtype):
 1112:     assert dtype in registry.dtypes
 1113: 
 1114: 
 1115: @pytest.mark.parametrize(
 1116:     "dtype, expected",
 1117:     [
 1118:         ("int64", None),
 1119:         ("interval", IntervalDtype()),
 1120:         ("interval[int64, neither]", IntervalDtype()),
 1121:         ("interval[datetime64[ns], left]", IntervalDtype("datetime64[ns]", "left")),
 1122:         ("period[D]", PeriodDtype("D")),
 1123:         ("category", CategoricalDtype()),
 1124:         ("datetime64[ns, US/Eastern]", DatetimeTZDtype("ns", "US/Eastern")),
 1125:     ],
 1126: )
 1127: def test_registry_find(dtype, expected):
 1128:     assert registry.find(dtype) == expected
 1129: 
 1130: 
 1131: @pytest.mark.parametrize(
 1132:     "dtype, expected",
 1133:     [
 1134:         (str, False),
 1135:         (int, False),
 1136:         (bool, True),
 1137:         (np.bool_, True),
 1138:         (np.array(["a", "b"]), False),
 1139:         (Series([1, 2]), False),
 1140:         (np.array([True, False]), True),
 1141:         (Series([True, False]), True),
 1142:         (SparseArray([True, False]), True),
 1143:         (SparseDtype(bool), True),
 1144:     ],
 1145: )
 1146: def test_is_bool_dtype(dtype, expected):
 1147:     result = is_bool_dtype(dtype)
 1148:     assert result is expected
 1149: 
 1150: 
 1151: def test_is_bool_dtype_sparse():
 1152:     result = is_bool_dtype(Series(SparseArray([True, False])))
 1153:     assert result is True
 1154: 
 1155: 
 1156: @pytest.mark.parametrize(
 1157:     "check",
 1158:     [
 1159:         is_categorical_dtype,
 1160:         is_datetime64tz_dtype,
 1161:         is_period_dtype,
 1162:         is_datetime64_ns_dtype,
 1163:         is_datetime64_dtype,
 1164:         is_interval_dtype,
 1165:         is_datetime64_any_dtype,
 1166:         is_string_dtype,
 1167:         is_bool_dtype,
 1168:     ],
 1169: )
 1170: def test_is_dtype_no_warning(check):
 1171:     data = pd.DataFrame({"A": [1, 2]})
 1172: 
 1173:     warn = None
 1174:     msg = f"{check.__name__} is deprecated"
 1175:     if (
 1176:         check is is_categorical_dtype
 1177:         or check is is_interval_dtype
 1178:         or check is is_datetime64tz_dtype
 1179:         or check is is_period_dtype
 1180:     ):
 1181:         warn = DeprecationWarning
 1182: 
 1183:     with tm.assert_produces_warning(warn, match=msg):
 1184:         check(data)
 1185: 
 1186:     with tm.assert_produces_warning(warn, match=msg):
 1187:         check(data["A"])
 1188: 
 1189: 
 1190: def test_period_dtype_compare_to_string():
 1191:     # https://github.com/pandas-dev/pandas/issues/37265
 1192:     dtype = PeriodDtype(freq="M")
 1193:     assert (dtype == "period[M]") is True
 1194:     assert (dtype != "period[M]") is False
 1195: 
 1196: 
 1197: def test_compare_complex_dtypes():
 1198:     # GH 28050
 1199:     df = pd.DataFrame(np.arange(5).astype(np.complex128))
 1200:     msg = "'<' not supported between instances of 'complex' and 'complex'"
 1201: 
 1202:     with pytest.raises(TypeError, match=msg):
 1203:         df < df.astype(object)
 1204: 
 1205:     with pytest.raises(TypeError, match=msg):
 1206:         df.lt(df.astype(object))
 1207: 
 1208: 
 1209: def test_cast_string_to_complex():
 1210:     # GH 4895
 1211:     expected = pd.DataFrame(["1.0+5j", "1.5-3j"], dtype=complex)
 1212:     result = pd.DataFrame(["1.0+5j", "1.5-3j"]).astype(complex)
 1213:     tm.assert_frame_equal(result, expected)
 1214: 
 1215: 
 1216: def test_categorical_complex():
 1217:     result = Categorical([1, 2 + 2j])
 1218:     expected = Categorical([1.0 + 0.0j, 2.0 + 2.0j])
 1219:     tm.assert_categorical_equal(result, expected)
 1220:     result = Categorical([1, 2, 2 + 2j])
 1221:     expected = Categorical([1.0 + 0.0j, 2.0 + 0.0j, 2.0 + 2.0j])
 1222:     tm.assert_categorical_equal(result, expected)
 1223: 
 1224: 
 1225: def test_multi_column_dtype_assignment():
 1226:     # GH #27583
 1227:     df = pd.DataFrame({"a": [0.0], "b": 0.0})
 1228:     expected = pd.DataFrame({"a": [0], "b": 0})
 1229: 
 1230:     df[["a", "b"]] = 0
 1231:     tm.assert_frame_equal(df, expected)
 1232: 
 1233:     df["b"] = 0
 1234:     tm.assert_frame_equal(df, expected)
