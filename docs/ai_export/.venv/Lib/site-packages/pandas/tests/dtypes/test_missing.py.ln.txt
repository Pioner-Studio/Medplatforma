    1: from contextlib import nullcontext
    2: from datetime import datetime
    3: from decimal import Decimal
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas._config import config as cf
    9: 
   10: from pandas._libs import missing as libmissing
   11: from pandas._libs.tslibs import iNaT
   12: from pandas.compat.numpy import np_version_gte1p25
   13: 
   14: from pandas.core.dtypes.common import (
   15:     is_float,
   16:     is_scalar,
   17:     pandas_dtype,
   18: )
   19: from pandas.core.dtypes.dtypes import (
   20:     CategoricalDtype,
   21:     DatetimeTZDtype,
   22:     IntervalDtype,
   23:     PeriodDtype,
   24: )
   25: from pandas.core.dtypes.missing import (
   26:     array_equivalent,
   27:     is_valid_na_for_dtype,
   28:     isna,
   29:     isnull,
   30:     na_value_for_dtype,
   31:     notna,
   32:     notnull,
   33: )
   34: 
   35: import pandas as pd
   36: from pandas import (
   37:     DatetimeIndex,
   38:     Index,
   39:     NaT,
   40:     Series,
   41:     TimedeltaIndex,
   42:     date_range,
   43:     period_range,
   44: )
   45: import pandas._testing as tm
   46: 
   47: fix_now = pd.Timestamp("2021-01-01")
   48: fix_utcnow = pd.Timestamp("2021-01-01", tz="UTC")
   49: 
   50: 
   51: @pytest.mark.parametrize("notna_f", [notna, notnull])
   52: def test_notna_notnull(notna_f):
   53:     assert notna_f(1.0)
   54:     assert not notna_f(None)
   55:     assert not notna_f(np.nan)
   56: 
   57:     msg = "use_inf_as_na option is deprecated"
   58:     with tm.assert_produces_warning(FutureWarning, match=msg):
   59:         with cf.option_context("mode.use_inf_as_na", False):
   60:             assert notna_f(np.inf)
   61:             assert notna_f(-np.inf)
   62: 
   63:             arr = np.array([1.5, np.inf, 3.5, -np.inf])
   64:             result = notna_f(arr)
   65:             assert result.all()
   66: 
   67:     with tm.assert_produces_warning(FutureWarning, match=msg):
   68:         with cf.option_context("mode.use_inf_as_na", True):
   69:             assert not notna_f(np.inf)
   70:             assert not notna_f(-np.inf)
   71: 
   72:             arr = np.array([1.5, np.inf, 3.5, -np.inf])
   73:             result = notna_f(arr)
   74:             assert result.sum() == 2
   75: 
   76: 
   77: @pytest.mark.parametrize("null_func", [notna, notnull, isna, isnull])
   78: @pytest.mark.parametrize(
   79:     "ser",
   80:     [
   81:         Series(
   82:             [str(i) for i in range(5)],
   83:             index=Index([str(i) for i in range(5)], dtype=object),
   84:             dtype=object,
   85:         ),
   86:         Series(range(5), date_range("2020-01-01", periods=5)),
   87:         Series(range(5), period_range("2020-01-01", periods=5)),
   88:     ],
   89: )
   90: def test_null_check_is_series(null_func, ser):
   91:     msg = "use_inf_as_na option is deprecated"
   92:     with tm.assert_produces_warning(FutureWarning, match=msg):
   93:         with cf.option_context("mode.use_inf_as_na", False):
   94:             assert isinstance(null_func(ser), Series)
   95: 
   96: 
   97: class TestIsNA:
   98:     def test_0d_array(self):
   99:         assert isna(np.array(np.nan))
  100:         assert not isna(np.array(0.0))
  101:         assert not isna(np.array(0))
  102:         # test object dtype
  103:         assert isna(np.array(np.nan, dtype=object))
  104:         assert not isna(np.array(0.0, dtype=object))
  105:         assert not isna(np.array(0, dtype=object))
  106: 
  107:     @pytest.mark.parametrize("shape", [(4, 0), (4,)])
  108:     def test_empty_object(self, shape):
  109:         arr = np.empty(shape=shape, dtype=object)
  110:         result = isna(arr)
  111:         expected = np.ones(shape=shape, dtype=bool)
  112:         tm.assert_numpy_array_equal(result, expected)
  113: 
  114:     @pytest.mark.parametrize("isna_f", [isna, isnull])
  115:     def test_isna_isnull(self, isna_f):
  116:         assert not isna_f(1.0)
  117:         assert isna_f(None)
  118:         assert isna_f(np.nan)
  119:         assert float("nan")
  120:         assert not isna_f(np.inf)
  121:         assert not isna_f(-np.inf)
  122: 
  123:         # type
  124:         assert not isna_f(type(Series(dtype=object)))
  125:         assert not isna_f(type(Series(dtype=np.float64)))
  126:         assert not isna_f(type(pd.DataFrame()))
  127: 
  128:     @pytest.mark.parametrize("isna_f", [isna, isnull])
  129:     @pytest.mark.parametrize(
  130:         "data",
  131:         [
  132:             np.arange(4, dtype=float),
  133:             [0.0, 1.0, 0.0, 1.0],
  134:             Series(list("abcd"), dtype=object),
  135:             date_range("2020-01-01", periods=4),
  136:         ],
  137:     )
  138:     @pytest.mark.parametrize(
  139:         "index",
  140:         [
  141:             date_range("2020-01-01", periods=4),
  142:             range(4),
  143:             period_range("2020-01-01", periods=4),
  144:         ],
  145:     )
  146:     def test_isna_isnull_frame(self, isna_f, data, index):
  147:         # frame
  148:         df = pd.DataFrame(data, index=index)
  149:         result = isna_f(df)
  150:         expected = df.apply(isna_f)
  151:         tm.assert_frame_equal(result, expected)
  152: 
  153:     def test_isna_lists(self):
  154:         result = isna([[False]])
  155:         exp = np.array([[False]])
  156:         tm.assert_numpy_array_equal(result, exp)
  157: 
  158:         result = isna([[1], [2]])
  159:         exp = np.array([[False], [False]])
  160:         tm.assert_numpy_array_equal(result, exp)
  161: 
  162:         # list of strings / unicode
  163:         result = isna(["foo", "bar"])
  164:         exp = np.array([False, False])
  165:         tm.assert_numpy_array_equal(result, exp)
  166: 
  167:         result = isna(["foo", "bar"])
  168:         exp = np.array([False, False])
  169:         tm.assert_numpy_array_equal(result, exp)
  170: 
  171:         # GH20675
  172:         result = isna([np.nan, "world"])
  173:         exp = np.array([True, False])
  174:         tm.assert_numpy_array_equal(result, exp)
  175: 
  176:     def test_isna_nat(self):
  177:         result = isna([NaT])
  178:         exp = np.array([True])
  179:         tm.assert_numpy_array_equal(result, exp)
  180: 
  181:         result = isna(np.array([NaT], dtype=object))
  182:         exp = np.array([True])
  183:         tm.assert_numpy_array_equal(result, exp)
  184: 
  185:     def test_isna_numpy_nat(self):
  186:         arr = np.array(
  187:             [
  188:                 NaT,
  189:                 np.datetime64("NaT"),
  190:                 np.timedelta64("NaT"),
  191:                 np.datetime64("NaT", "s"),
  192:             ]
  193:         )
  194:         result = isna(arr)
  195:         expected = np.array([True] * 4)
  196:         tm.assert_numpy_array_equal(result, expected)
  197: 
  198:     def test_isna_datetime(self):
  199:         assert not isna(datetime.now())
  200:         assert notna(datetime.now())
  201: 
  202:         idx = date_range("1/1/1990", periods=20)
  203:         exp = np.ones(len(idx), dtype=bool)
  204:         tm.assert_numpy_array_equal(notna(idx), exp)
  205: 
  206:         idx = np.asarray(idx)
  207:         idx[0] = iNaT
  208:         idx = DatetimeIndex(idx)
  209:         mask = isna(idx)
  210:         assert mask[0]
  211:         exp = np.array([True] + [False] * (len(idx) - 1), dtype=bool)
  212:         tm.assert_numpy_array_equal(mask, exp)
  213: 
  214:         # GH 9129
  215:         pidx = idx.to_period(freq="M")
  216:         mask = isna(pidx)
  217:         assert mask[0]
  218:         exp = np.array([True] + [False] * (len(idx) - 1), dtype=bool)
  219:         tm.assert_numpy_array_equal(mask, exp)
  220: 
  221:         mask = isna(pidx[1:])
  222:         exp = np.zeros(len(mask), dtype=bool)
  223:         tm.assert_numpy_array_equal(mask, exp)
  224: 
  225:     def test_isna_old_datetimelike(self):
  226:         # isna_old should work for dt64tz, td64, and period, not just tznaive
  227:         dti = date_range("2016-01-01", periods=3)
  228:         dta = dti._data
  229:         dta[-1] = NaT
  230:         expected = np.array([False, False, True], dtype=bool)
  231: 
  232:         objs = [dta, dta.tz_localize("US/Eastern"), dta - dta, dta.to_period("D")]
  233: 
  234:         for obj in objs:
  235:             msg = "use_inf_as_na option is deprecated"
  236:             with tm.assert_produces_warning(FutureWarning, match=msg):
  237:                 with cf.option_context("mode.use_inf_as_na", True):
  238:                     result = isna(obj)
  239: 
  240:             tm.assert_numpy_array_equal(result, expected)
  241: 
  242:     @pytest.mark.parametrize(
  243:         "value, expected",
  244:         [
  245:             (np.complex128(np.nan), True),
  246:             (np.float64(1), False),
  247:             (np.array([1, 1 + 0j, np.nan, 3]), np.array([False, False, True, False])),
  248:             (
  249:                 np.array([1, 1 + 0j, np.nan, 3], dtype=object),
  250:                 np.array([False, False, True, False]),
  251:             ),
  252:             (
  253:                 np.array([1, 1 + 0j, np.nan, 3]).astype(object),
  254:                 np.array([False, False, True, False]),
  255:             ),
  256:         ],
  257:     )
  258:     def test_complex(self, value, expected):
  259:         result = isna(value)
  260:         if is_scalar(result):
  261:             assert result is expected
  262:         else:
  263:             tm.assert_numpy_array_equal(result, expected)
  264: 
  265:     def test_datetime_other_units(self):
  266:         idx = DatetimeIndex(["2011-01-01", "NaT", "2011-01-02"])
  267:         exp = np.array([False, True, False])
  268:         tm.assert_numpy_array_equal(isna(idx), exp)
  269:         tm.assert_numpy_array_equal(notna(idx), ~exp)
  270:         tm.assert_numpy_array_equal(isna(idx.values), exp)
  271:         tm.assert_numpy_array_equal(notna(idx.values), ~exp)
  272: 
  273:     @pytest.mark.parametrize(
  274:         "dtype",
  275:         [
  276:             "datetime64[D]",
  277:             "datetime64[h]",
  278:             "datetime64[m]",
  279:             "datetime64[s]",
  280:             "datetime64[ms]",
  281:             "datetime64[us]",
  282:             "datetime64[ns]",
  283:         ],
  284:     )
  285:     def test_datetime_other_units_astype(self, dtype):
  286:         idx = DatetimeIndex(["2011-01-01", "NaT", "2011-01-02"])
  287:         values = idx.values.astype(dtype)
  288: 
  289:         exp = np.array([False, True, False])
  290:         tm.assert_numpy_array_equal(isna(values), exp)
  291:         tm.assert_numpy_array_equal(notna(values), ~exp)
  292: 
  293:         exp = Series([False, True, False])
  294:         s = Series(values)
  295:         tm.assert_series_equal(isna(s), exp)
  296:         tm.assert_series_equal(notna(s), ~exp)
  297:         s = Series(values, dtype=object)
  298:         tm.assert_series_equal(isna(s), exp)
  299:         tm.assert_series_equal(notna(s), ~exp)
  300: 
  301:     def test_timedelta_other_units(self):
  302:         idx = TimedeltaIndex(["1 days", "NaT", "2 days"])
  303:         exp = np.array([False, True, False])
  304:         tm.assert_numpy_array_equal(isna(idx), exp)
  305:         tm.assert_numpy_array_equal(notna(idx), ~exp)
  306:         tm.assert_numpy_array_equal(isna(idx.values), exp)
  307:         tm.assert_numpy_array_equal(notna(idx.values), ~exp)
  308: 
  309:     @pytest.mark.parametrize(
  310:         "dtype",
  311:         [
  312:             "timedelta64[D]",
  313:             "timedelta64[h]",
  314:             "timedelta64[m]",
  315:             "timedelta64[s]",
  316:             "timedelta64[ms]",
  317:             "timedelta64[us]",
  318:             "timedelta64[ns]",
  319:         ],
  320:     )
  321:     def test_timedelta_other_units_dtype(self, dtype):
  322:         idx = TimedeltaIndex(["1 days", "NaT", "2 days"])
  323:         values = idx.values.astype(dtype)
  324: 
  325:         exp = np.array([False, True, False])
  326:         tm.assert_numpy_array_equal(isna(values), exp)
  327:         tm.assert_numpy_array_equal(notna(values), ~exp)
  328: 
  329:         exp = Series([False, True, False])
  330:         s = Series(values)
  331:         tm.assert_series_equal(isna(s), exp)
  332:         tm.assert_series_equal(notna(s), ~exp)
  333:         s = Series(values, dtype=object)
  334:         tm.assert_series_equal(isna(s), exp)
  335:         tm.assert_series_equal(notna(s), ~exp)
  336: 
  337:     def test_period(self):
  338:         idx = pd.PeriodIndex(["2011-01", "NaT", "2012-01"], freq="M")
  339:         exp = np.array([False, True, False])
  340:         tm.assert_numpy_array_equal(isna(idx), exp)
  341:         tm.assert_numpy_array_equal(notna(idx), ~exp)
  342: 
  343:         exp = Series([False, True, False])
  344:         s = Series(idx)
  345:         tm.assert_series_equal(isna(s), exp)
  346:         tm.assert_series_equal(notna(s), ~exp)
  347:         s = Series(idx, dtype=object)
  348:         tm.assert_series_equal(isna(s), exp)
  349:         tm.assert_series_equal(notna(s), ~exp)
  350: 
  351:     def test_decimal(self):
  352:         # scalars GH#23530
  353:         a = Decimal(1.0)
  354:         assert isna(a) is False
  355:         assert notna(a) is True
  356: 
  357:         b = Decimal("NaN")
  358:         assert isna(b) is True
  359:         assert notna(b) is False
  360: 
  361:         # array
  362:         arr = np.array([a, b])
  363:         expected = np.array([False, True])
  364:         result = isna(arr)
  365:         tm.assert_numpy_array_equal(result, expected)
  366: 
  367:         result = notna(arr)
  368:         tm.assert_numpy_array_equal(result, ~expected)
  369: 
  370:         # series
  371:         ser = Series(arr)
  372:         expected = Series(expected)
  373:         result = isna(ser)
  374:         tm.assert_series_equal(result, expected)
  375: 
  376:         result = notna(ser)
  377:         tm.assert_series_equal(result, ~expected)
  378: 
  379:         # index
  380:         idx = Index(arr)
  381:         expected = np.array([False, True])
  382:         result = isna(idx)
  383:         tm.assert_numpy_array_equal(result, expected)
  384: 
  385:         result = notna(idx)
  386:         tm.assert_numpy_array_equal(result, ~expected)
  387: 
  388: 
  389: @pytest.mark.parametrize("dtype_equal", [True, False])
  390: def test_array_equivalent(dtype_equal):
  391:     assert array_equivalent(
  392:         np.array([np.nan, np.nan]), np.array([np.nan, np.nan]), dtype_equal=dtype_equal
  393:     )
  394:     assert array_equivalent(
  395:         np.array([np.nan, 1, np.nan]),
  396:         np.array([np.nan, 1, np.nan]),
  397:         dtype_equal=dtype_equal,
  398:     )
  399:     assert array_equivalent(
  400:         np.array([np.nan, None], dtype="object"),
  401:         np.array([np.nan, None], dtype="object"),
  402:         dtype_equal=dtype_equal,
  403:     )
  404:     # Check the handling of nested arrays in array_equivalent_object
  405:     assert array_equivalent(
  406:         np.array([np.array([np.nan, None], dtype="object"), None], dtype="object"),
  407:         np.array([np.array([np.nan, None], dtype="object"), None], dtype="object"),
  408:         dtype_equal=dtype_equal,
  409:     )
  410:     assert array_equivalent(
  411:         np.array([np.nan, 1 + 1j], dtype="complex"),
  412:         np.array([np.nan, 1 + 1j], dtype="complex"),
  413:         dtype_equal=dtype_equal,
  414:     )
  415:     assert not array_equivalent(
  416:         np.array([np.nan, 1 + 1j], dtype="complex"),
  417:         np.array([np.nan, 1 + 2j], dtype="complex"),
  418:         dtype_equal=dtype_equal,
  419:     )
  420:     assert not array_equivalent(
  421:         np.array([np.nan, 1, np.nan]),
  422:         np.array([np.nan, 2, np.nan]),
  423:         dtype_equal=dtype_equal,
  424:     )
  425:     assert not array_equivalent(
  426:         np.array(["a", "b", "c", "d"]), np.array(["e", "e"]), dtype_equal=dtype_equal
  427:     )
  428:     assert array_equivalent(
  429:         Index([0, np.nan]), Index([0, np.nan]), dtype_equal=dtype_equal
  430:     )
  431:     assert not array_equivalent(
  432:         Index([0, np.nan]), Index([1, np.nan]), dtype_equal=dtype_equal
  433:     )
  434: 
  435: 
  436: @pytest.mark.parametrize("dtype_equal", [True, False])
  437: def test_array_equivalent_tdi(dtype_equal):
  438:     assert array_equivalent(
  439:         TimedeltaIndex([0, np.nan]),
  440:         TimedeltaIndex([0, np.nan]),
  441:         dtype_equal=dtype_equal,
  442:     )
  443:     assert not array_equivalent(
  444:         TimedeltaIndex([0, np.nan]),
  445:         TimedeltaIndex([1, np.nan]),
  446:         dtype_equal=dtype_equal,
  447:     )
  448: 
  449: 
  450: @pytest.mark.parametrize("dtype_equal", [True, False])
  451: def test_array_equivalent_dti(dtype_equal):
  452:     assert array_equivalent(
  453:         DatetimeIndex([0, np.nan]), DatetimeIndex([0, np.nan]), dtype_equal=dtype_equal
  454:     )
  455:     assert not array_equivalent(
  456:         DatetimeIndex([0, np.nan]), DatetimeIndex([1, np.nan]), dtype_equal=dtype_equal
  457:     )
  458: 
  459:     dti1 = DatetimeIndex([0, np.nan], tz="US/Eastern")
  460:     dti2 = DatetimeIndex([0, np.nan], tz="CET")
  461:     dti3 = DatetimeIndex([1, np.nan], tz="US/Eastern")
  462: 
  463:     assert array_equivalent(
  464:         dti1,
  465:         dti1,
  466:         dtype_equal=dtype_equal,
  467:     )
  468:     assert not array_equivalent(
  469:         dti1,
  470:         dti3,
  471:         dtype_equal=dtype_equal,
  472:     )
  473:     # The rest are not dtype_equal
  474:     assert not array_equivalent(DatetimeIndex([0, np.nan]), dti1)
  475:     assert array_equivalent(
  476:         dti2,
  477:         dti1,
  478:     )
  479: 
  480:     assert not array_equivalent(DatetimeIndex([0, np.nan]), TimedeltaIndex([0, np.nan]))
  481: 
  482: 
  483: @pytest.mark.parametrize(
  484:     "val", [1, 1.1, 1 + 1j, True, "abc", [1, 2], (1, 2), {1, 2}, {"a": 1}, None]
  485: )
  486: def test_array_equivalent_series(val):
  487:     arr = np.array([1, 2])
  488:     msg = "elementwise comparison failed"
  489:     cm = (
  490:         # stacklevel is chosen to make sense when called from .equals
  491:         tm.assert_produces_warning(FutureWarning, match=msg, check_stacklevel=False)
  492:         if isinstance(val, str) and not np_version_gte1p25
  493:         else nullcontext()
  494:     )
  495:     with cm:
  496:         assert not array_equivalent(Series([arr, arr]), Series([arr, val]))
  497: 
  498: 
  499: def test_array_equivalent_array_mismatched_shape():
  500:     # to trigger the motivating bug, the first N elements of the arrays need
  501:     #  to match
  502:     first = np.array([1, 2, 3])
  503:     second = np.array([1, 2])
  504: 
  505:     left = Series([first, "a"], dtype=object)
  506:     right = Series([second, "a"], dtype=object)
  507:     assert not array_equivalent(left, right)
  508: 
  509: 
  510: def test_array_equivalent_array_mismatched_dtype():
  511:     # same shape, different dtype can still be equivalent
  512:     first = np.array([1, 2], dtype=np.float64)
  513:     second = np.array([1, 2])
  514: 
  515:     left = Series([first, "a"], dtype=object)
  516:     right = Series([second, "a"], dtype=object)
  517:     assert array_equivalent(left, right)
  518: 
  519: 
  520: def test_array_equivalent_different_dtype_but_equal():
  521:     # Unclear if this is exposed anywhere in the public-facing API
  522:     assert array_equivalent(np.array([1, 2]), np.array([1.0, 2.0]))
  523: 
  524: 
  525: @pytest.mark.parametrize(
  526:     "lvalue, rvalue",
  527:     [
  528:         # There are 3 variants for each of lvalue and rvalue. We include all
  529:         #  three for the tz-naive `now` and exclude the datetim64 variant
  530:         #  for utcnow because it drops tzinfo.
  531:         (fix_now, fix_utcnow),
  532:         (fix_now.to_datetime64(), fix_utcnow),
  533:         (fix_now.to_pydatetime(), fix_utcnow),
  534:         (fix_now, fix_utcnow),
  535:         (fix_now.to_datetime64(), fix_utcnow.to_pydatetime()),
  536:         (fix_now.to_pydatetime(), fix_utcnow.to_pydatetime()),
  537:     ],
  538: )
  539: def test_array_equivalent_tzawareness(lvalue, rvalue):
  540:     # we shouldn't raise if comparing tzaware and tznaive datetimes
  541:     left = np.array([lvalue], dtype=object)
  542:     right = np.array([rvalue], dtype=object)
  543: 
  544:     assert not array_equivalent(left, right, strict_nan=True)
  545:     assert not array_equivalent(left, right, strict_nan=False)
  546: 
  547: 
  548: def test_array_equivalent_compat():
  549:     # see gh-13388
  550:     m = np.array([(1, 2), (3, 4)], dtype=[("a", int), ("b", float)])
  551:     n = np.array([(1, 2), (3, 4)], dtype=[("a", int), ("b", float)])
  552:     assert array_equivalent(m, n, strict_nan=True)
  553:     assert array_equivalent(m, n, strict_nan=False)
  554: 
  555:     m = np.array([(1, 2), (3, 4)], dtype=[("a", int), ("b", float)])
  556:     n = np.array([(1, 2), (4, 3)], dtype=[("a", int), ("b", float)])
  557:     assert not array_equivalent(m, n, strict_nan=True)
  558:     assert not array_equivalent(m, n, strict_nan=False)
  559: 
  560:     m = np.array([(1, 2), (3, 4)], dtype=[("a", int), ("b", float)])
  561:     n = np.array([(1, 2), (3, 4)], dtype=[("b", int), ("a", float)])
  562:     assert not array_equivalent(m, n, strict_nan=True)
  563:     assert not array_equivalent(m, n, strict_nan=False)
  564: 
  565: 
  566: @pytest.mark.parametrize("dtype", ["O", "S", "U"])
  567: def test_array_equivalent_str(dtype):
  568:     assert array_equivalent(
  569:         np.array(["A", "B"], dtype=dtype), np.array(["A", "B"], dtype=dtype)
  570:     )
  571:     assert not array_equivalent(
  572:         np.array(["A", "B"], dtype=dtype), np.array(["A", "X"], dtype=dtype)
  573:     )
  574: 
  575: 
  576: @pytest.mark.parametrize("strict_nan", [True, False])
  577: def test_array_equivalent_nested(strict_nan):
  578:     # reached in groupby aggregations, make sure we use np.any when checking
  579:     #  if the comparison is truthy
  580:     left = np.array([np.array([50, 70, 90]), np.array([20, 30])], dtype=object)
  581:     right = np.array([np.array([50, 70, 90]), np.array([20, 30])], dtype=object)
  582: 
  583:     assert array_equivalent(left, right, strict_nan=strict_nan)
  584:     assert not array_equivalent(left, right[::-1], strict_nan=strict_nan)
  585: 
  586:     left = np.empty(2, dtype=object)
  587:     left[:] = [np.array([50, 70, 90]), np.array([20, 30, 40])]
  588:     right = np.empty(2, dtype=object)
  589:     right[:] = [np.array([50, 70, 90]), np.array([20, 30, 40])]
  590:     assert array_equivalent(left, right, strict_nan=strict_nan)
  591:     assert not array_equivalent(left, right[::-1], strict_nan=strict_nan)
  592: 
  593:     left = np.array([np.array([50, 50, 50]), np.array([40, 40])], dtype=object)
  594:     right = np.array([50, 40])
  595:     assert not array_equivalent(left, right, strict_nan=strict_nan)
  596: 
  597: 
  598: @pytest.mark.filterwarnings("ignore:elementwise comparison failed:DeprecationWarning")
  599: @pytest.mark.parametrize("strict_nan", [True, False])
  600: def test_array_equivalent_nested2(strict_nan):
  601:     # more than one level of nesting
  602:     left = np.array(
  603:         [
  604:             np.array([np.array([50, 70]), np.array([90])], dtype=object),
  605:             np.array([np.array([20, 30])], dtype=object),
  606:         ],
  607:         dtype=object,
  608:     )
  609:     right = np.array(
  610:         [
  611:             np.array([np.array([50, 70]), np.array([90])], dtype=object),
  612:             np.array([np.array([20, 30])], dtype=object),
  613:         ],
  614:         dtype=object,
  615:     )
  616:     assert array_equivalent(left, right, strict_nan=strict_nan)
  617:     assert not array_equivalent(left, right[::-1], strict_nan=strict_nan)
  618: 
  619:     left = np.array([np.array([np.array([50, 50, 50])], dtype=object)], dtype=object)
  620:     right = np.array([50])
  621:     assert not array_equivalent(left, right, strict_nan=strict_nan)
  622: 
  623: 
  624: @pytest.mark.parametrize("strict_nan", [True, False])
  625: def test_array_equivalent_nested_list(strict_nan):
  626:     left = np.array([[50, 70, 90], [20, 30]], dtype=object)
  627:     right = np.array([[50, 70, 90], [20, 30]], dtype=object)
  628: 
  629:     assert array_equivalent(left, right, strict_nan=strict_nan)
  630:     assert not array_equivalent(left, right[::-1], strict_nan=strict_nan)
  631: 
  632:     left = np.array([[50, 50, 50], [40, 40]], dtype=object)
  633:     right = np.array([50, 40])
  634:     assert not array_equivalent(left, right, strict_nan=strict_nan)
  635: 
  636: 
  637: @pytest.mark.filterwarnings("ignore:elementwise comparison failed:DeprecationWarning")
  638: @pytest.mark.xfail(reason="failing")
  639: @pytest.mark.parametrize("strict_nan", [True, False])
  640: def test_array_equivalent_nested_mixed_list(strict_nan):
  641:     # mixed arrays / lists in left and right
  642:     # https://github.com/pandas-dev/pandas/issues/50360
  643:     left = np.array([np.array([1, 2, 3]), np.array([4, 5])], dtype=object)
  644:     right = np.array([[1, 2, 3], [4, 5]], dtype=object)
  645: 
  646:     assert array_equivalent(left, right, strict_nan=strict_nan)
  647:     assert not array_equivalent(left, right[::-1], strict_nan=strict_nan)
  648: 
  649:     # multiple levels of nesting
  650:     left = np.array(
  651:         [
  652:             np.array([np.array([1, 2, 3]), np.array([4, 5])], dtype=object),
  653:             np.array([np.array([6]), np.array([7, 8]), np.array([9])], dtype=object),
  654:         ],
  655:         dtype=object,
  656:     )
  657:     right = np.array([[[1, 2, 3], [4, 5]], [[6], [7, 8], [9]]], dtype=object)
  658:     assert array_equivalent(left, right, strict_nan=strict_nan)
  659:     assert not array_equivalent(left, right[::-1], strict_nan=strict_nan)
  660: 
  661:     # same-length lists
  662:     subarr = np.empty(2, dtype=object)
  663:     subarr[:] = [
  664:         np.array([None, "b"], dtype=object),
  665:         np.array(["c", "d"], dtype=object),
  666:     ]
  667:     left = np.array([subarr, None], dtype=object)
  668:     right = np.array([[[None, "b"], ["c", "d"]], None], dtype=object)
  669:     assert array_equivalent(left, right, strict_nan=strict_nan)
  670:     assert not array_equivalent(left, right[::-1], strict_nan=strict_nan)
  671: 
  672: 
  673: @pytest.mark.xfail(reason="failing")
  674: @pytest.mark.parametrize("strict_nan", [True, False])
  675: def test_array_equivalent_nested_dicts(strict_nan):
  676:     left = np.array([{"f1": 1, "f2": np.array(["a", "b"], dtype=object)}], dtype=object)
  677:     right = np.array(
  678:         [{"f1": 1, "f2": np.array(["a", "b"], dtype=object)}], dtype=object
  679:     )
  680:     assert array_equivalent(left, right, strict_nan=strict_nan)
  681:     assert not array_equivalent(left, right[::-1], strict_nan=strict_nan)
  682: 
  683:     right2 = np.array([{"f1": 1, "f2": ["a", "b"]}], dtype=object)
  684:     assert array_equivalent(left, right2, strict_nan=strict_nan)
  685:     assert not array_equivalent(left, right2[::-1], strict_nan=strict_nan)
  686: 
  687: 
  688: def test_array_equivalent_index_with_tuples():
  689:     # GH#48446
  690:     idx1 = Index(np.array([(pd.NA, 4), (1, 1)], dtype="object"))
  691:     idx2 = Index(np.array([(1, 1), (pd.NA, 4)], dtype="object"))
  692:     assert not array_equivalent(idx1, idx2)
  693:     assert not idx1.equals(idx2)
  694:     assert not array_equivalent(idx2, idx1)
  695:     assert not idx2.equals(idx1)
  696: 
  697:     idx1 = Index(np.array([(4, pd.NA), (1, 1)], dtype="object"))
  698:     idx2 = Index(np.array([(1, 1), (4, pd.NA)], dtype="object"))
  699:     assert not array_equivalent(idx1, idx2)
  700:     assert not idx1.equals(idx2)
  701:     assert not array_equivalent(idx2, idx1)
  702:     assert not idx2.equals(idx1)
  703: 
  704: 
  705: @pytest.mark.parametrize(
  706:     "dtype, na_value",
  707:     [
  708:         # Datetime-like
  709:         (np.dtype("M8[ns]"), np.datetime64("NaT", "ns")),
  710:         (np.dtype("m8[ns]"), np.timedelta64("NaT", "ns")),
  711:         (DatetimeTZDtype.construct_from_string("datetime64[ns, US/Eastern]"), NaT),
  712:         (PeriodDtype("M"), NaT),
  713:         # Integer
  714:         ("u1", 0),
  715:         ("u2", 0),
  716:         ("u4", 0),
  717:         ("u8", 0),
  718:         ("i1", 0),
  719:         ("i2", 0),
  720:         ("i4", 0),
  721:         ("i8", 0),
  722:         # Bool
  723:         ("bool", False),
  724:         # Float
  725:         ("f2", np.nan),
  726:         ("f4", np.nan),
  727:         ("f8", np.nan),
  728:         # Object
  729:         ("O", np.nan),
  730:         # Interval
  731:         (IntervalDtype(), np.nan),
  732:     ],
  733: )
  734: def test_na_value_for_dtype(dtype, na_value):
  735:     result = na_value_for_dtype(pandas_dtype(dtype))
  736:     # identify check doesn't work for datetime64/timedelta64("NaT") bc they
  737:     #  are not singletons
  738:     assert result is na_value or (
  739:         isna(result) and isna(na_value) and type(result) is type(na_value)
  740:     )
  741: 
  742: 
  743: class TestNAObj:
  744:     def _check_behavior(self, arr, expected):
  745:         result = libmissing.isnaobj(arr)
  746:         tm.assert_numpy_array_equal(result, expected)
  747:         result = libmissing.isnaobj(arr, inf_as_na=True)
  748:         tm.assert_numpy_array_equal(result, expected)
  749: 
  750:         arr = np.atleast_2d(arr)
  751:         expected = np.atleast_2d(expected)
  752: 
  753:         result = libmissing.isnaobj(arr)
  754:         tm.assert_numpy_array_equal(result, expected)
  755:         result = libmissing.isnaobj(arr, inf_as_na=True)
  756:         tm.assert_numpy_array_equal(result, expected)
  757: 
  758:         # Test fortran order
  759:         arr = arr.copy(order="F")
  760:         result = libmissing.isnaobj(arr)
  761:         tm.assert_numpy_array_equal(result, expected)
  762:         result = libmissing.isnaobj(arr, inf_as_na=True)
  763:         tm.assert_numpy_array_equal(result, expected)
  764: 
  765:     def test_basic(self):
  766:         arr = np.array([1, None, "foo", -5.1, NaT, np.nan])
  767:         expected = np.array([False, True, False, False, True, True])
  768: 
  769:         self._check_behavior(arr, expected)
  770: 
  771:     def test_non_obj_dtype(self):
  772:         arr = np.array([1, 3, np.nan, 5], dtype=float)
  773:         expected = np.array([False, False, True, False])
  774: 
  775:         self._check_behavior(arr, expected)
  776: 
  777:     def test_empty_arr(self):
  778:         arr = np.array([])
  779:         expected = np.array([], dtype=bool)
  780: 
  781:         self._check_behavior(arr, expected)
  782: 
  783:     def test_empty_str_inp(self):
  784:         arr = np.array([""])  # empty but not na
  785:         expected = np.array([False])
  786: 
  787:         self._check_behavior(arr, expected)
  788: 
  789:     def test_empty_like(self):
  790:         # see gh-13717: no segfaults!
  791:         arr = np.empty_like([None])
  792:         expected = np.array([True])
  793: 
  794:         self._check_behavior(arr, expected)
  795: 
  796: 
  797: m8_units = ["as", "ps", "ns", "us", "ms", "s", "m", "h", "D", "W", "M", "Y"]
  798: 
  799: na_vals = (
  800:     [
  801:         None,
  802:         NaT,
  803:         float("NaN"),
  804:         complex("NaN"),
  805:         np.nan,
  806:         np.float64("NaN"),
  807:         np.float32("NaN"),
  808:         np.complex64(np.nan),
  809:         np.complex128(np.nan),
  810:         np.datetime64("NaT"),
  811:         np.timedelta64("NaT"),
  812:     ]
  813:     + [np.datetime64("NaT", unit) for unit in m8_units]
  814:     + [np.timedelta64("NaT", unit) for unit in m8_units]
  815: )
  816: 
  817: inf_vals = [
  818:     float("inf"),
  819:     float("-inf"),
  820:     complex("inf"),
  821:     complex("-inf"),
  822:     np.inf,
  823:     -np.inf,
  824: ]
  825: 
  826: int_na_vals = [
  827:     # Values that match iNaT, which we treat as null in specific cases
  828:     np.int64(NaT._value),
  829:     int(NaT._value),
  830: ]
  831: 
  832: sometimes_na_vals = [Decimal("NaN")]
  833: 
  834: never_na_vals = [
  835:     # float/complex values that when viewed as int64 match iNaT
  836:     -0.0,
  837:     np.float64("-0.0"),
  838:     -0j,
  839:     np.complex64(-0j),
  840: ]
  841: 
  842: 
  843: class TestLibMissing:
  844:     @pytest.mark.parametrize("func", [libmissing.checknull, isna])
  845:     @pytest.mark.parametrize(
  846:         "value", na_vals + sometimes_na_vals  # type: ignore[operator]
  847:     )
  848:     def test_checknull_na_vals(self, func, value):
  849:         assert func(value)
  850: 
  851:     @pytest.mark.parametrize("func", [libmissing.checknull, isna])
  852:     @pytest.mark.parametrize("value", inf_vals)
  853:     def test_checknull_inf_vals(self, func, value):
  854:         assert not func(value)
  855: 
  856:     @pytest.mark.parametrize("func", [libmissing.checknull, isna])
  857:     @pytest.mark.parametrize("value", int_na_vals)
  858:     def test_checknull_intna_vals(self, func, value):
  859:         assert not func(value)
  860: 
  861:     @pytest.mark.parametrize("func", [libmissing.checknull, isna])
  862:     @pytest.mark.parametrize("value", never_na_vals)
  863:     def test_checknull_never_na_vals(self, func, value):
  864:         assert not func(value)
  865: 
  866:     @pytest.mark.parametrize(
  867:         "value", na_vals + sometimes_na_vals  # type: ignore[operator]
  868:     )
  869:     def test_checknull_old_na_vals(self, value):
  870:         assert libmissing.checknull(value, inf_as_na=True)
  871: 
  872:     @pytest.mark.parametrize("value", inf_vals)
  873:     def test_checknull_old_inf_vals(self, value):
  874:         assert libmissing.checknull(value, inf_as_na=True)
  875: 
  876:     @pytest.mark.parametrize("value", int_na_vals)
  877:     def test_checknull_old_intna_vals(self, value):
  878:         assert not libmissing.checknull(value, inf_as_na=True)
  879: 
  880:     @pytest.mark.parametrize("value", int_na_vals)
  881:     def test_checknull_old_never_na_vals(self, value):
  882:         assert not libmissing.checknull(value, inf_as_na=True)
  883: 
  884:     def test_is_matching_na(self, nulls_fixture, nulls_fixture2):
  885:         left = nulls_fixture
  886:         right = nulls_fixture2
  887: 
  888:         assert libmissing.is_matching_na(left, left)
  889: 
  890:         if left is right:
  891:             assert libmissing.is_matching_na(left, right)
  892:         elif is_float(left) and is_float(right):
  893:             # np.nan vs float("NaN") we consider as matching
  894:             assert libmissing.is_matching_na(left, right)
  895:         elif type(left) is type(right):
  896:             # e.g. both Decimal("NaN")
  897:             assert libmissing.is_matching_na(left, right)
  898:         else:
  899:             assert not libmissing.is_matching_na(left, right)
  900: 
  901:     def test_is_matching_na_nan_matches_none(self):
  902:         assert not libmissing.is_matching_na(None, np.nan)
  903:         assert not libmissing.is_matching_na(np.nan, None)
  904: 
  905:         assert libmissing.is_matching_na(None, np.nan, nan_matches_none=True)
  906:         assert libmissing.is_matching_na(np.nan, None, nan_matches_none=True)
  907: 
  908: 
  909: class TestIsValidNAForDtype:
  910:     def test_is_valid_na_for_dtype_interval(self):
  911:         dtype = IntervalDtype("int64", "left")
  912:         assert not is_valid_na_for_dtype(NaT, dtype)
  913: 
  914:         dtype = IntervalDtype("datetime64[ns]", "both")
  915:         assert not is_valid_na_for_dtype(NaT, dtype)
  916: 
  917:     def test_is_valid_na_for_dtype_categorical(self):
  918:         dtype = CategoricalDtype(categories=[0, 1, 2])
  919:         assert is_valid_na_for_dtype(np.nan, dtype)
  920: 
  921:         assert not is_valid_na_for_dtype(NaT, dtype)
  922:         assert not is_valid_na_for_dtype(np.datetime64("NaT", "ns"), dtype)
  923:         assert not is_valid_na_for_dtype(np.timedelta64("NaT", "ns"), dtype)
