    1: from __future__ import annotations
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas.util._test_decorators as td
    7: 
    8: from pandas.core.dtypes.astype import astype_array
    9: import pandas.core.dtypes.common as com
   10: from pandas.core.dtypes.dtypes import (
   11:     CategoricalDtype,
   12:     CategoricalDtypeType,
   13:     DatetimeTZDtype,
   14:     ExtensionDtype,
   15:     IntervalDtype,
   16:     PeriodDtype,
   17: )
   18: from pandas.core.dtypes.missing import isna
   19: 
   20: import pandas as pd
   21: import pandas._testing as tm
   22: from pandas.api.types import pandas_dtype
   23: from pandas.arrays import SparseArray
   24: 
   25: 
   26: # EA & Actual Dtypes
   27: def to_ea_dtypes(dtypes):
   28:     """convert list of string dtypes to EA dtype"""
   29:     return [getattr(pd, dt + "Dtype") for dt in dtypes]
   30: 
   31: 
   32: def to_numpy_dtypes(dtypes):
   33:     """convert list of string dtypes to numpy dtype"""
   34:     return [getattr(np, dt) for dt in dtypes if isinstance(dt, str)]
   35: 
   36: 
   37: class TestNumpyEADtype:
   38:     # Passing invalid dtype, both as a string or object, must raise TypeError
   39:     # Per issue GH15520
   40:     @pytest.mark.parametrize("box", [pd.Timestamp, "pd.Timestamp", list])
   41:     def test_invalid_dtype_error(self, box):
   42:         with pytest.raises(TypeError, match="not understood"):
   43:             com.pandas_dtype(box)
   44: 
   45:     @pytest.mark.parametrize(
   46:         "dtype",
   47:         [
   48:             object,
   49:             "float64",
   50:             np.object_,
   51:             np.dtype("object"),
   52:             "O",
   53:             np.float64,
   54:             float,
   55:             np.dtype("float64"),
   56:             "object_",
   57:         ],
   58:     )
   59:     def test_pandas_dtype_valid(self, dtype):
   60:         assert com.pandas_dtype(dtype) == dtype
   61: 
   62:     @pytest.mark.parametrize(
   63:         "dtype", ["M8[ns]", "m8[ns]", "object", "float64", "int64"]
   64:     )
   65:     def test_numpy_dtype(self, dtype):
   66:         assert com.pandas_dtype(dtype) == np.dtype(dtype)
   67: 
   68:     def test_numpy_string_dtype(self):
   69:         # do not parse freq-like string as period dtype
   70:         assert com.pandas_dtype("U") == np.dtype("U")
   71:         assert com.pandas_dtype("S") == np.dtype("S")
   72: 
   73:     @pytest.mark.parametrize(
   74:         "dtype",
   75:         [
   76:             "datetime64[ns, US/Eastern]",
   77:             "datetime64[ns, Asia/Tokyo]",
   78:             "datetime64[ns, UTC]",
   79:             # GH#33885 check that the M8 alias is understood
   80:             "M8[ns, US/Eastern]",
   81:             "M8[ns, Asia/Tokyo]",
   82:             "M8[ns, UTC]",
   83:         ],
   84:     )
   85:     def test_datetimetz_dtype(self, dtype):
   86:         assert com.pandas_dtype(dtype) == DatetimeTZDtype.construct_from_string(dtype)
   87:         assert com.pandas_dtype(dtype) == dtype
   88: 
   89:     def test_categorical_dtype(self):
   90:         assert com.pandas_dtype("category") == CategoricalDtype()
   91: 
   92:     @pytest.mark.parametrize(
   93:         "dtype",
   94:         [
   95:             "period[D]",
   96:             "period[3M]",
   97:             "period[us]",
   98:             "Period[D]",
   99:             "Period[3M]",
  100:             "Period[us]",
  101:         ],
  102:     )
  103:     def test_period_dtype(self, dtype):
  104:         assert com.pandas_dtype(dtype) is not PeriodDtype(dtype)
  105:         assert com.pandas_dtype(dtype) == PeriodDtype(dtype)
  106:         assert com.pandas_dtype(dtype) == dtype
  107: 
  108: 
  109: dtypes = {
  110:     "datetime_tz": com.pandas_dtype("datetime64[ns, US/Eastern]"),
  111:     "datetime": com.pandas_dtype("datetime64[ns]"),
  112:     "timedelta": com.pandas_dtype("timedelta64[ns]"),
  113:     "period": PeriodDtype("D"),
  114:     "integer": np.dtype(np.int64),
  115:     "float": np.dtype(np.float64),
  116:     "object": np.dtype(object),
  117:     "category": com.pandas_dtype("category"),
  118:     "string": pd.StringDtype(),
  119: }
  120: 
  121: 
  122: @pytest.mark.parametrize("name1,dtype1", list(dtypes.items()), ids=lambda x: str(x))
  123: @pytest.mark.parametrize("name2,dtype2", list(dtypes.items()), ids=lambda x: str(x))
  124: def test_dtype_equal(name1, dtype1, name2, dtype2):
  125:     # match equal to self, but not equal to other
  126:     assert com.is_dtype_equal(dtype1, dtype1)
  127:     if name1 != name2:
  128:         assert not com.is_dtype_equal(dtype1, dtype2)
  129: 
  130: 
  131: @pytest.mark.parametrize("name,dtype", list(dtypes.items()), ids=lambda x: str(x))
  132: def test_pyarrow_string_import_error(name, dtype):
  133:     # GH-44276
  134:     assert not com.is_dtype_equal(dtype, "string[pyarrow]")
  135: 
  136: 
  137: @pytest.mark.parametrize(
  138:     "dtype1,dtype2",
  139:     [
  140:         (np.int8, np.int64),
  141:         (np.int16, np.int64),
  142:         (np.int32, np.int64),
  143:         (np.float32, np.float64),
  144:         (PeriodDtype("D"), PeriodDtype("2D")),  # PeriodType
  145:         (
  146:             com.pandas_dtype("datetime64[ns, US/Eastern]"),
  147:             com.pandas_dtype("datetime64[ns, CET]"),
  148:         ),  # Datetime
  149:         (None, None),  # gh-15941: no exception should be raised.
  150:     ],
  151: )
  152: def test_dtype_equal_strict(dtype1, dtype2):
  153:     assert not com.is_dtype_equal(dtype1, dtype2)
  154: 
  155: 
  156: def get_is_dtype_funcs():
  157:     """
  158:     Get all functions in pandas.core.dtypes.common that
  159:     begin with 'is_' and end with 'dtype'
  160: 
  161:     """
  162:     fnames = [f for f in dir(com) if (f.startswith("is_") and f.endswith("dtype"))]
  163:     fnames.remove("is_string_or_object_np_dtype")  # fastpath requires np.dtype obj
  164:     return [getattr(com, fname) for fname in fnames]
  165: 
  166: 
  167: @pytest.mark.filterwarnings(
  168:     "ignore:is_categorical_dtype is deprecated:DeprecationWarning"
  169: )
  170: @pytest.mark.parametrize("func", get_is_dtype_funcs(), ids=lambda x: x.__name__)
  171: def test_get_dtype_error_catch(func):
  172:     # see gh-15941
  173:     #
  174:     # No exception should be raised.
  175: 
  176:     msg = f"{func.__name__} is deprecated"
  177:     warn = None
  178:     if (
  179:         func is com.is_int64_dtype
  180:         or func is com.is_interval_dtype
  181:         or func is com.is_datetime64tz_dtype
  182:         or func is com.is_categorical_dtype
  183:         or func is com.is_period_dtype
  184:     ):
  185:         warn = DeprecationWarning
  186: 
  187:     with tm.assert_produces_warning(warn, match=msg):
  188:         assert not func(None)
  189: 
  190: 
  191: def test_is_object():
  192:     assert com.is_object_dtype(object)
  193:     assert com.is_object_dtype(np.array([], dtype=object))
  194: 
  195:     assert not com.is_object_dtype(int)
  196:     assert not com.is_object_dtype(np.array([], dtype=int))
  197:     assert not com.is_object_dtype([1, 2, 3])
  198: 
  199: 
  200: @pytest.mark.parametrize(
  201:     "check_scipy", [False, pytest.param(True, marks=td.skip_if_no("scipy"))]
  202: )
  203: def test_is_sparse(check_scipy):
  204:     msg = "is_sparse is deprecated"
  205:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  206:         assert com.is_sparse(SparseArray([1, 2, 3]))
  207: 
  208:         assert not com.is_sparse(np.array([1, 2, 3]))
  209: 
  210:         if check_scipy:
  211:             import scipy.sparse
  212: 
  213:             assert not com.is_sparse(scipy.sparse.bsr_matrix([1, 2, 3]))
  214: 
  215: 
  216: def test_is_scipy_sparse():
  217:     sp_sparse = pytest.importorskip("scipy.sparse")
  218: 
  219:     assert com.is_scipy_sparse(sp_sparse.bsr_matrix([1, 2, 3]))
  220: 
  221:     assert not com.is_scipy_sparse(SparseArray([1, 2, 3]))
  222: 
  223: 
  224: def test_is_datetime64_dtype():
  225:     assert not com.is_datetime64_dtype(object)
  226:     assert not com.is_datetime64_dtype([1, 2, 3])
  227:     assert not com.is_datetime64_dtype(np.array([], dtype=int))
  228: 
  229:     assert com.is_datetime64_dtype(np.datetime64)
  230:     assert com.is_datetime64_dtype(np.array([], dtype=np.datetime64))
  231: 
  232: 
  233: def test_is_datetime64tz_dtype():
  234:     msg = "is_datetime64tz_dtype is deprecated"
  235:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  236:         assert not com.is_datetime64tz_dtype(object)
  237:         assert not com.is_datetime64tz_dtype([1, 2, 3])
  238:         assert not com.is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))
  239:         assert com.is_datetime64tz_dtype(pd.DatetimeIndex(["2000"], tz="US/Eastern"))
  240: 
  241: 
  242: def test_custom_ea_kind_M_not_datetime64tz():
  243:     # GH 34986
  244:     class NotTZDtype(ExtensionDtype):
  245:         @property
  246:         def kind(self) -> str:
  247:             return "M"
  248: 
  249:     not_tz_dtype = NotTZDtype()
  250:     msg = "is_datetime64tz_dtype is deprecated"
  251:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  252:         assert not com.is_datetime64tz_dtype(not_tz_dtype)
  253:         assert not com.needs_i8_conversion(not_tz_dtype)
  254: 
  255: 
  256: def test_is_timedelta64_dtype():
  257:     assert not com.is_timedelta64_dtype(object)
  258:     assert not com.is_timedelta64_dtype(None)
  259:     assert not com.is_timedelta64_dtype([1, 2, 3])
  260:     assert not com.is_timedelta64_dtype(np.array([], dtype=np.datetime64))
  261:     assert not com.is_timedelta64_dtype("0 days")
  262:     assert not com.is_timedelta64_dtype("0 days 00:00:00")
  263:     assert not com.is_timedelta64_dtype(["0 days 00:00:00"])
  264:     assert not com.is_timedelta64_dtype("NO DATE")
  265: 
  266:     assert com.is_timedelta64_dtype(np.timedelta64)
  267:     assert com.is_timedelta64_dtype(pd.Series([], dtype="timedelta64[ns]"))
  268:     assert com.is_timedelta64_dtype(pd.to_timedelta(["0 days", "1 days"]))
  269: 
  270: 
  271: def test_is_period_dtype():
  272:     msg = "is_period_dtype is deprecated"
  273:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  274:         assert not com.is_period_dtype(object)
  275:         assert not com.is_period_dtype([1, 2, 3])
  276:         assert not com.is_period_dtype(pd.Period("2017-01-01"))
  277: 
  278:         assert com.is_period_dtype(PeriodDtype(freq="D"))
  279:         assert com.is_period_dtype(pd.PeriodIndex([], freq="Y"))
  280: 
  281: 
  282: def test_is_interval_dtype():
  283:     msg = "is_interval_dtype is deprecated"
  284:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  285:         assert not com.is_interval_dtype(object)
  286:         assert not com.is_interval_dtype([1, 2, 3])
  287: 
  288:         assert com.is_interval_dtype(IntervalDtype())
  289: 
  290:         interval = pd.Interval(1, 2, closed="right")
  291:         assert not com.is_interval_dtype(interval)
  292:         assert com.is_interval_dtype(pd.IntervalIndex([interval]))
  293: 
  294: 
  295: def test_is_categorical_dtype():
  296:     msg = "is_categorical_dtype is deprecated"
  297:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  298:         assert not com.is_categorical_dtype(object)
  299:         assert not com.is_categorical_dtype([1, 2, 3])
  300: 
  301:         assert com.is_categorical_dtype(CategoricalDtype())
  302:         assert com.is_categorical_dtype(pd.Categorical([1, 2, 3]))
  303:         assert com.is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))
  304: 
  305: 
  306: @pytest.mark.parametrize(
  307:     "dtype, expected",
  308:     [
  309:         (int, False),
  310:         (pd.Series([1, 2]), False),
  311:         (str, True),
  312:         (object, True),
  313:         (np.array(["a", "b"]), True),
  314:         (pd.StringDtype(), True),
  315:         (pd.Index([], dtype="O"), True),
  316:     ],
  317: )
  318: def test_is_string_dtype(dtype, expected):
  319:     # GH#54661
  320: 
  321:     result = com.is_string_dtype(dtype)
  322:     assert result is expected
  323: 
  324: 
  325: @pytest.mark.parametrize(
  326:     "data",
  327:     [[(0, 1), (1, 1)], pd.Categorical([1, 2, 3]), np.array([1, 2], dtype=object)],
  328: )
  329: def test_is_string_dtype_arraylike_with_object_elements_not_strings(data):
  330:     # GH 15585
  331:     assert not com.is_string_dtype(pd.Series(data))
  332: 
  333: 
  334: def test_is_string_dtype_nullable(nullable_string_dtype):
  335:     assert com.is_string_dtype(pd.array(["a", "b"], dtype=nullable_string_dtype))
  336: 
  337: 
  338: integer_dtypes: list = []
  339: 
  340: 
  341: @pytest.mark.parametrize(
  342:     "dtype",
  343:     integer_dtypes
  344:     + [pd.Series([1, 2])]
  345:     + tm.ALL_INT_NUMPY_DTYPES
  346:     + to_numpy_dtypes(tm.ALL_INT_NUMPY_DTYPES)
  347:     + tm.ALL_INT_EA_DTYPES
  348:     + to_ea_dtypes(tm.ALL_INT_EA_DTYPES),
  349: )
  350: def test_is_integer_dtype(dtype):
  351:     assert com.is_integer_dtype(dtype)
  352: 
  353: 
  354: @pytest.mark.parametrize(
  355:     "dtype",
  356:     [
  357:         str,
  358:         float,
  359:         np.datetime64,
  360:         np.timedelta64,
  361:         pd.Index([1, 2.0]),
  362:         np.array(["a", "b"]),
  363:         np.array([], dtype=np.timedelta64),
  364:     ],
  365: )
  366: def test_is_not_integer_dtype(dtype):
  367:     assert not com.is_integer_dtype(dtype)
  368: 
  369: 
  370: signed_integer_dtypes: list = []
  371: 
  372: 
  373: @pytest.mark.parametrize(
  374:     "dtype",
  375:     signed_integer_dtypes
  376:     + [pd.Series([1, 2])]
  377:     + tm.SIGNED_INT_NUMPY_DTYPES
  378:     + to_numpy_dtypes(tm.SIGNED_INT_NUMPY_DTYPES)
  379:     + tm.SIGNED_INT_EA_DTYPES
  380:     + to_ea_dtypes(tm.SIGNED_INT_EA_DTYPES),
  381: )
  382: def test_is_signed_integer_dtype(dtype):
  383:     assert com.is_integer_dtype(dtype)
  384: 
  385: 
  386: @pytest.mark.parametrize(
  387:     "dtype",
  388:     [
  389:         str,
  390:         float,
  391:         np.datetime64,
  392:         np.timedelta64,
  393:         pd.Index([1, 2.0]),
  394:         np.array(["a", "b"]),
  395:         np.array([], dtype=np.timedelta64),
  396:     ]
  397:     + tm.UNSIGNED_INT_NUMPY_DTYPES
  398:     + to_numpy_dtypes(tm.UNSIGNED_INT_NUMPY_DTYPES)
  399:     + tm.UNSIGNED_INT_EA_DTYPES
  400:     + to_ea_dtypes(tm.UNSIGNED_INT_EA_DTYPES),
  401: )
  402: def test_is_not_signed_integer_dtype(dtype):
  403:     assert not com.is_signed_integer_dtype(dtype)
  404: 
  405: 
  406: unsigned_integer_dtypes: list = []
  407: 
  408: 
  409: @pytest.mark.parametrize(
  410:     "dtype",
  411:     unsigned_integer_dtypes
  412:     + [pd.Series([1, 2], dtype=np.uint32)]
  413:     + tm.UNSIGNED_INT_NUMPY_DTYPES
  414:     + to_numpy_dtypes(tm.UNSIGNED_INT_NUMPY_DTYPES)
  415:     + tm.UNSIGNED_INT_EA_DTYPES
  416:     + to_ea_dtypes(tm.UNSIGNED_INT_EA_DTYPES),
  417: )
  418: def test_is_unsigned_integer_dtype(dtype):
  419:     assert com.is_unsigned_integer_dtype(dtype)
  420: 
  421: 
  422: @pytest.mark.parametrize(
  423:     "dtype",
  424:     [
  425:         str,
  426:         float,
  427:         np.datetime64,
  428:         np.timedelta64,
  429:         pd.Index([1, 2.0]),
  430:         np.array(["a", "b"]),
  431:         np.array([], dtype=np.timedelta64),
  432:     ]
  433:     + tm.SIGNED_INT_NUMPY_DTYPES
  434:     + to_numpy_dtypes(tm.SIGNED_INT_NUMPY_DTYPES)
  435:     + tm.SIGNED_INT_EA_DTYPES
  436:     + to_ea_dtypes(tm.SIGNED_INT_EA_DTYPES),
  437: )
  438: def test_is_not_unsigned_integer_dtype(dtype):
  439:     assert not com.is_unsigned_integer_dtype(dtype)
  440: 
  441: 
  442: @pytest.mark.parametrize(
  443:     "dtype", [np.int64, np.array([1, 2], dtype=np.int64), "Int64", pd.Int64Dtype]
  444: )
  445: def test_is_int64_dtype(dtype):
  446:     msg = "is_int64_dtype is deprecated"
  447:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  448:         assert com.is_int64_dtype(dtype)
  449: 
  450: 
  451: def test_type_comparison_with_numeric_ea_dtype(any_numeric_ea_dtype):
  452:     # GH#43038
  453:     assert pandas_dtype(any_numeric_ea_dtype) == any_numeric_ea_dtype
  454: 
  455: 
  456: def test_type_comparison_with_real_numpy_dtype(any_real_numpy_dtype):
  457:     # GH#43038
  458:     assert pandas_dtype(any_real_numpy_dtype) == any_real_numpy_dtype
  459: 
  460: 
  461: def test_type_comparison_with_signed_int_ea_dtype_and_signed_int_numpy_dtype(
  462:     any_signed_int_ea_dtype, any_signed_int_numpy_dtype
  463: ):
  464:     # GH#43038
  465:     assert not pandas_dtype(any_signed_int_ea_dtype) == any_signed_int_numpy_dtype
  466: 
  467: 
  468: @pytest.mark.parametrize(
  469:     "dtype",
  470:     [
  471:         str,
  472:         float,
  473:         np.int32,
  474:         np.uint64,
  475:         pd.Index([1, 2.0]),
  476:         np.array(["a", "b"]),
  477:         np.array([1, 2], dtype=np.uint32),
  478:         "int8",
  479:         "Int8",
  480:         pd.Int8Dtype,
  481:     ],
  482: )
  483: def test_is_not_int64_dtype(dtype):
  484:     msg = "is_int64_dtype is deprecated"
  485:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  486:         assert not com.is_int64_dtype(dtype)
  487: 
  488: 
  489: def test_is_datetime64_any_dtype():
  490:     assert not com.is_datetime64_any_dtype(int)
  491:     assert not com.is_datetime64_any_dtype(str)
  492:     assert not com.is_datetime64_any_dtype(np.array([1, 2]))
  493:     assert not com.is_datetime64_any_dtype(np.array(["a", "b"]))
  494: 
  495:     assert com.is_datetime64_any_dtype(np.datetime64)
  496:     assert com.is_datetime64_any_dtype(np.array([], dtype=np.datetime64))
  497:     assert com.is_datetime64_any_dtype(DatetimeTZDtype("ns", "US/Eastern"))
  498:     assert com.is_datetime64_any_dtype(
  499:         pd.DatetimeIndex([1, 2, 3], dtype="datetime64[ns]")
  500:     )
  501: 
  502: 
  503: def test_is_datetime64_ns_dtype():
  504:     assert not com.is_datetime64_ns_dtype(int)
  505:     assert not com.is_datetime64_ns_dtype(str)
  506:     assert not com.is_datetime64_ns_dtype(np.datetime64)
  507:     assert not com.is_datetime64_ns_dtype(np.array([1, 2]))
  508:     assert not com.is_datetime64_ns_dtype(np.array(["a", "b"]))
  509:     assert not com.is_datetime64_ns_dtype(np.array([], dtype=np.datetime64))
  510: 
  511:     # This datetime array has the wrong unit (ps instead of ns)
  512:     assert not com.is_datetime64_ns_dtype(np.array([], dtype="datetime64[ps]"))
  513: 
  514:     assert com.is_datetime64_ns_dtype(DatetimeTZDtype("ns", "US/Eastern"))
  515:     assert com.is_datetime64_ns_dtype(
  516:         pd.DatetimeIndex([1, 2, 3], dtype=np.dtype("datetime64[ns]"))
  517:     )
  518: 
  519:     # non-nano dt64tz
  520:     assert not com.is_datetime64_ns_dtype(DatetimeTZDtype("us", "US/Eastern"))
  521: 
  522: 
  523: def test_is_timedelta64_ns_dtype():
  524:     assert not com.is_timedelta64_ns_dtype(np.dtype("m8[ps]"))
  525:     assert not com.is_timedelta64_ns_dtype(np.array([1, 2], dtype=np.timedelta64))
  526: 
  527:     assert com.is_timedelta64_ns_dtype(np.dtype("m8[ns]"))
  528:     assert com.is_timedelta64_ns_dtype(np.array([1, 2], dtype="m8[ns]"))
  529: 
  530: 
  531: def test_is_numeric_v_string_like():
  532:     assert not com.is_numeric_v_string_like(np.array([1]), 1)
  533:     assert not com.is_numeric_v_string_like(np.array([1]), np.array([2]))
  534:     assert not com.is_numeric_v_string_like(np.array(["foo"]), np.array(["foo"]))
  535: 
  536:     assert com.is_numeric_v_string_like(np.array([1]), "foo")
  537:     assert com.is_numeric_v_string_like(np.array([1, 2]), np.array(["foo"]))
  538:     assert com.is_numeric_v_string_like(np.array(["foo"]), np.array([1, 2]))
  539: 
  540: 
  541: def test_needs_i8_conversion():
  542:     assert not com.needs_i8_conversion(str)
  543:     assert not com.needs_i8_conversion(np.int64)
  544:     assert not com.needs_i8_conversion(pd.Series([1, 2]))
  545:     assert not com.needs_i8_conversion(np.array(["a", "b"]))
  546: 
  547:     assert not com.needs_i8_conversion(np.datetime64)
  548:     assert com.needs_i8_conversion(np.dtype(np.datetime64))
  549:     assert not com.needs_i8_conversion(pd.Series([], dtype="timedelta64[ns]"))
  550:     assert com.needs_i8_conversion(pd.Series([], dtype="timedelta64[ns]").dtype)
  551:     assert not com.needs_i8_conversion(pd.DatetimeIndex(["2000"], tz="US/Eastern"))
  552:     assert com.needs_i8_conversion(pd.DatetimeIndex(["2000"], tz="US/Eastern").dtype)
  553: 
  554: 
  555: def test_is_numeric_dtype():
  556:     assert not com.is_numeric_dtype(str)
  557:     assert not com.is_numeric_dtype(np.datetime64)
  558:     assert not com.is_numeric_dtype(np.timedelta64)
  559:     assert not com.is_numeric_dtype(np.array(["a", "b"]))
  560:     assert not com.is_numeric_dtype(np.array([], dtype=np.timedelta64))
  561: 
  562:     assert com.is_numeric_dtype(int)
  563:     assert com.is_numeric_dtype(float)
  564:     assert com.is_numeric_dtype(np.uint64)
  565:     assert com.is_numeric_dtype(pd.Series([1, 2]))
  566:     assert com.is_numeric_dtype(pd.Index([1, 2.0]))
  567: 
  568:     class MyNumericDType(ExtensionDtype):
  569:         @property
  570:         def type(self):
  571:             return str
  572: 
  573:         @property
  574:         def name(self):
  575:             raise NotImplementedError
  576: 
  577:         @classmethod
  578:         def construct_array_type(cls):
  579:             raise NotImplementedError
  580: 
  581:         def _is_numeric(self) -> bool:
  582:             return True
  583: 
  584:     assert com.is_numeric_dtype(MyNumericDType())
  585: 
  586: 
  587: def test_is_any_real_numeric_dtype():
  588:     assert not com.is_any_real_numeric_dtype(str)
  589:     assert not com.is_any_real_numeric_dtype(bool)
  590:     assert not com.is_any_real_numeric_dtype(complex)
  591:     assert not com.is_any_real_numeric_dtype(object)
  592:     assert not com.is_any_real_numeric_dtype(np.datetime64)
  593:     assert not com.is_any_real_numeric_dtype(np.array(["a", "b", complex(1, 2)]))
  594:     assert not com.is_any_real_numeric_dtype(pd.DataFrame([complex(1, 2), True]))
  595: 
  596:     assert com.is_any_real_numeric_dtype(int)
  597:     assert com.is_any_real_numeric_dtype(float)
  598:     assert com.is_any_real_numeric_dtype(np.array([1, 2.5]))
  599: 
  600: 
  601: def test_is_float_dtype():
  602:     assert not com.is_float_dtype(str)
  603:     assert not com.is_float_dtype(int)
  604:     assert not com.is_float_dtype(pd.Series([1, 2]))
  605:     assert not com.is_float_dtype(np.array(["a", "b"]))
  606: 
  607:     assert com.is_float_dtype(float)
  608:     assert com.is_float_dtype(pd.Index([1, 2.0]))
  609: 
  610: 
  611: def test_is_bool_dtype():
  612:     assert not com.is_bool_dtype(int)
  613:     assert not com.is_bool_dtype(str)
  614:     assert not com.is_bool_dtype(pd.Series([1, 2]))
  615:     assert not com.is_bool_dtype(pd.Series(["a", "b"], dtype="category"))
  616:     assert not com.is_bool_dtype(np.array(["a", "b"]))
  617:     assert not com.is_bool_dtype(pd.Index(["a", "b"]))
  618:     assert not com.is_bool_dtype("Int64")
  619: 
  620:     assert com.is_bool_dtype(bool)
  621:     assert com.is_bool_dtype(np.bool_)
  622:     assert com.is_bool_dtype(pd.Series([True, False], dtype="category"))
  623:     assert com.is_bool_dtype(np.array([True, False]))
  624:     assert com.is_bool_dtype(pd.Index([True, False]))
  625: 
  626:     assert com.is_bool_dtype(pd.BooleanDtype())
  627:     assert com.is_bool_dtype(pd.array([True, False, None], dtype="boolean"))
  628:     assert com.is_bool_dtype("boolean")
  629: 
  630: 
  631: def test_is_bool_dtype_numpy_error():
  632:     # GH39010
  633:     assert not com.is_bool_dtype("0 - Name")
  634: 
  635: 
  636: @pytest.mark.parametrize(
  637:     "check_scipy", [False, pytest.param(True, marks=td.skip_if_no("scipy"))]
  638: )
  639: def test_is_extension_array_dtype(check_scipy):
  640:     assert not com.is_extension_array_dtype([1, 2, 3])
  641:     assert not com.is_extension_array_dtype(np.array([1, 2, 3]))
  642:     assert not com.is_extension_array_dtype(pd.DatetimeIndex([1, 2, 3]))
  643: 
  644:     cat = pd.Categorical([1, 2, 3])
  645:     assert com.is_extension_array_dtype(cat)
  646:     assert com.is_extension_array_dtype(pd.Series(cat))
  647:     assert com.is_extension_array_dtype(SparseArray([1, 2, 3]))
  648:     assert com.is_extension_array_dtype(pd.DatetimeIndex(["2000"], tz="US/Eastern"))
  649: 
  650:     dtype = DatetimeTZDtype("ns", tz="US/Eastern")
  651:     s = pd.Series([], dtype=dtype)
  652:     assert com.is_extension_array_dtype(s)
  653: 
  654:     if check_scipy:
  655:         import scipy.sparse
  656: 
  657:         assert not com.is_extension_array_dtype(scipy.sparse.bsr_matrix([1, 2, 3]))
  658: 
  659: 
  660: def test_is_complex_dtype():
  661:     assert not com.is_complex_dtype(int)
  662:     assert not com.is_complex_dtype(str)
  663:     assert not com.is_complex_dtype(pd.Series([1, 2]))
  664:     assert not com.is_complex_dtype(np.array(["a", "b"]))
  665: 
  666:     assert com.is_complex_dtype(np.complex128)
  667:     assert com.is_complex_dtype(complex)
  668:     assert com.is_complex_dtype(np.array([1 + 1j, 5]))
  669: 
  670: 
  671: @pytest.mark.parametrize(
  672:     "input_param,result",
  673:     [
  674:         (int, np.dtype(int)),
  675:         ("int32", np.dtype("int32")),
  676:         (float, np.dtype(float)),
  677:         ("float64", np.dtype("float64")),
  678:         (np.dtype("float64"), np.dtype("float64")),
  679:         (str, np.dtype(str)),
  680:         (pd.Series([1, 2], dtype=np.dtype("int16")), np.dtype("int16")),
  681:         (pd.Series(["a", "b"], dtype=object), np.dtype(object)),
  682:         (pd.Index([1, 2]), np.dtype("int64")),
  683:         (pd.Index(["a", "b"], dtype=object), np.dtype(object)),
  684:         ("category", "category"),
  685:         (pd.Categorical(["a", "b"]).dtype, CategoricalDtype(["a", "b"])),
  686:         (pd.Categorical(["a", "b"]), CategoricalDtype(["a", "b"])),
  687:         (pd.CategoricalIndex(["a", "b"]).dtype, CategoricalDtype(["a", "b"])),
  688:         (pd.CategoricalIndex(["a", "b"]), CategoricalDtype(["a", "b"])),
  689:         (CategoricalDtype(), CategoricalDtype()),
  690:         (pd.DatetimeIndex([1, 2]), np.dtype("=M8[ns]")),
  691:         (pd.DatetimeIndex([1, 2]).dtype, np.dtype("=M8[ns]")),
  692:         ("<M8[ns]", np.dtype("<M8[ns]")),
  693:         ("datetime64[ns, Europe/London]", DatetimeTZDtype("ns", "Europe/London")),
  694:         (PeriodDtype(freq="D"), PeriodDtype(freq="D")),
  695:         ("period[D]", PeriodDtype(freq="D")),
  696:         (IntervalDtype(), IntervalDtype()),
  697:     ],
  698: )
  699: def test_get_dtype(input_param, result):
  700:     assert com._get_dtype(input_param) == result
  701: 
  702: 
  703: @pytest.mark.parametrize(
  704:     "input_param,expected_error_message",
  705:     [
  706:         (None, "Cannot deduce dtype from null object"),
  707:         (1, "data type not understood"),
  708:         (1.2, "data type not understood"),
  709:         # numpy dev changed from double-quotes to single quotes
  710:         ("random string", "data type [\"']random string[\"'] not understood"),
  711:         (pd.DataFrame([1, 2]), "data type not understood"),
  712:     ],
  713: )
  714: def test_get_dtype_fails(input_param, expected_error_message):
  715:     # python objects
  716:     # 2020-02-02 npdev changed error message
  717:     expected_error_message += f"|Cannot interpret '{input_param}' as a data type"
  718:     with pytest.raises(TypeError, match=expected_error_message):
  719:         com._get_dtype(input_param)
  720: 
  721: 
  722: @pytest.mark.parametrize(
  723:     "input_param,result",
  724:     [
  725:         (int, np.dtype(int).type),
  726:         ("int32", np.int32),
  727:         (float, np.dtype(float).type),
  728:         ("float64", np.float64),
  729:         (np.dtype("float64"), np.float64),
  730:         (str, np.dtype(str).type),
  731:         (pd.Series([1, 2], dtype=np.dtype("int16")), np.int16),
  732:         (pd.Series(["a", "b"], dtype=object), np.object_),
  733:         (pd.Index([1, 2], dtype="int64"), np.int64),
  734:         (pd.Index(["a", "b"], dtype=object), np.object_),
  735:         ("category", CategoricalDtypeType),
  736:         (pd.Categorical(["a", "b"]).dtype, CategoricalDtypeType),
  737:         (pd.Categorical(["a", "b"]), CategoricalDtypeType),
  738:         (pd.CategoricalIndex(["a", "b"]).dtype, CategoricalDtypeType),
  739:         (pd.CategoricalIndex(["a", "b"]), CategoricalDtypeType),
  740:         (pd.DatetimeIndex([1, 2]), np.datetime64),
  741:         (pd.DatetimeIndex([1, 2]).dtype, np.datetime64),
  742:         ("<M8[ns]", np.datetime64),
  743:         (pd.DatetimeIndex(["2000"], tz="Europe/London"), pd.Timestamp),
  744:         (pd.DatetimeIndex(["2000"], tz="Europe/London").dtype, pd.Timestamp),
  745:         ("datetime64[ns, Europe/London]", pd.Timestamp),
  746:         (PeriodDtype(freq="D"), pd.Period),
  747:         ("period[D]", pd.Period),
  748:         (IntervalDtype(), pd.Interval),
  749:         (None, type(None)),
  750:         (1, type(None)),
  751:         (1.2, type(None)),
  752:         (pd.DataFrame([1, 2]), type(None)),  # composite dtype
  753:     ],
  754: )
  755: def test__is_dtype_type(input_param, result):
  756:     assert com._is_dtype_type(input_param, lambda tipo: tipo == result)
  757: 
  758: 
  759: def test_astype_nansafe_copy_false(any_int_numpy_dtype):
  760:     # GH#34457 use astype, not view
  761:     arr = np.array([1, 2, 3], dtype=any_int_numpy_dtype)
  762: 
  763:     dtype = np.dtype("float64")
  764:     result = astype_array(arr, dtype, copy=False)
  765: 
  766:     expected = np.array([1.0, 2.0, 3.0], dtype=dtype)
  767:     tm.assert_numpy_array_equal(result, expected)
  768: 
  769: 
  770: @pytest.mark.parametrize("from_type", [np.datetime64, np.timedelta64])
  771: def test_astype_object_preserves_datetime_na(from_type):
  772:     arr = np.array([from_type("NaT", "ns")])
  773:     result = astype_array(arr, dtype=np.dtype("object"))
  774: 
  775:     assert isna(result)[0]
  776: 
  777: 
  778: def test_validate_allhashable():
  779:     assert com.validate_all_hashable(1, "a") is None
  780: 
  781:     with pytest.raises(TypeError, match="All elements must be hashable"):
  782:         com.validate_all_hashable([])
  783: 
  784:     with pytest.raises(TypeError, match="list must be a hashable type"):
  785:         com.validate_all_hashable([], error_name="list")
  786: 
  787: 
  788: def test_pandas_dtype_numpy_warning():
  789:     # GH#51523
  790:     with tm.assert_produces_warning(
  791:         DeprecationWarning,
  792:         check_stacklevel=False,
  793:         match="Converting `np.integer` or `np.signedinteger` to a dtype is deprecated",
  794:     ):
  795:         pandas_dtype(np.integer)
  796: 
  797: 
  798: def test_pandas_dtype_ea_not_instance():
  799:     # GH 31356 GH 54592
  800:     with tm.assert_produces_warning(UserWarning):
  801:         assert pandas_dtype(CategoricalDtype) == CategoricalDtype()
