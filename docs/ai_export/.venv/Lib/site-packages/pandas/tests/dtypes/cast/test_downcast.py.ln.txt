    1: import decimal
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.core.dtypes.cast import maybe_downcast_to_dtype
    7: 
    8: from pandas import (
    9:     Series,
   10:     Timedelta,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: @pytest.mark.parametrize(
   16:     "arr,dtype,expected",
   17:     [
   18:         (
   19:             np.array([8.5, 8.6, 8.7, 8.8, 8.9999999999995]),
   20:             "infer",
   21:             np.array([8.5, 8.6, 8.7, 8.8, 8.9999999999995]),
   22:         ),
   23:         (
   24:             np.array([8.0, 8.0, 8.0, 8.0, 8.9999999999995]),
   25:             "infer",
   26:             np.array([8, 8, 8, 8, 9], dtype=np.int64),
   27:         ),
   28:         (
   29:             np.array([8.0, 8.0, 8.0, 8.0, 9.0000000000005]),
   30:             "infer",
   31:             np.array([8, 8, 8, 8, 9], dtype=np.int64),
   32:         ),
   33:         (
   34:             # This is a judgement call, but we do _not_ downcast Decimal
   35:             #  objects
   36:             np.array([decimal.Decimal(0.0)]),
   37:             "int64",
   38:             np.array([decimal.Decimal(0.0)]),
   39:         ),
   40:         (
   41:             # GH#45837
   42:             np.array([Timedelta(days=1), Timedelta(days=2)], dtype=object),
   43:             "infer",
   44:             np.array([1, 2], dtype="m8[D]").astype("m8[ns]"),
   45:         ),
   46:         # TODO: similar for dt64, dt64tz, Period, Interval?
   47:     ],
   48: )
   49: def test_downcast(arr, expected, dtype):
   50:     result = maybe_downcast_to_dtype(arr, dtype)
   51:     tm.assert_numpy_array_equal(result, expected)
   52: 
   53: 
   54: def test_downcast_booleans():
   55:     # see gh-16875: coercing of booleans.
   56:     ser = Series([True, True, False])
   57:     result = maybe_downcast_to_dtype(ser, np.dtype(np.float64))
   58: 
   59:     expected = ser.values
   60:     tm.assert_numpy_array_equal(result, expected)
   61: 
   62: 
   63: def test_downcast_conversion_no_nan(any_real_numpy_dtype):
   64:     dtype = any_real_numpy_dtype
   65:     expected = np.array([1, 2])
   66:     arr = np.array([1.0, 2.0], dtype=dtype)
   67: 
   68:     result = maybe_downcast_to_dtype(arr, "infer")
   69:     tm.assert_almost_equal(result, expected, check_dtype=False)
   70: 
   71: 
   72: def test_downcast_conversion_nan(float_numpy_dtype):
   73:     dtype = float_numpy_dtype
   74:     data = [1.0, 2.0, np.nan]
   75: 
   76:     expected = np.array(data, dtype=dtype)
   77:     arr = np.array(data, dtype=dtype)
   78: 
   79:     result = maybe_downcast_to_dtype(arr, "infer")
   80:     tm.assert_almost_equal(result, expected)
   81: 
   82: 
   83: def test_downcast_conversion_empty(any_real_numpy_dtype):
   84:     dtype = any_real_numpy_dtype
   85:     arr = np.array([], dtype=dtype)
   86:     result = maybe_downcast_to_dtype(arr, np.dtype("int64"))
   87:     tm.assert_numpy_array_equal(result, np.array([], dtype=np.int64))
   88: 
   89: 
   90: @pytest.mark.parametrize("klass", [np.datetime64, np.timedelta64])
   91: def test_datetime_likes_nan(klass):
   92:     dtype = klass.__name__ + "[ns]"
   93:     arr = np.array([1, 2, np.nan])
   94: 
   95:     exp = np.array([1, 2, klass("NaT")], dtype)
   96:     res = maybe_downcast_to_dtype(arr, dtype)
   97:     tm.assert_numpy_array_equal(res, exp)
