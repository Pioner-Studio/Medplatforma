    1: import pytest
    2: 
    3: from pandas._config import config as cf
    4: from pandas._config.config import OptionError
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: 
    9: 
   10: class TestConfig:
   11:     @pytest.fixture(autouse=True)
   12:     def clean_config(self, monkeypatch):
   13:         with monkeypatch.context() as m:
   14:             m.setattr(cf, "_global_config", {})
   15:             m.setattr(cf, "options", cf.DictWrapper(cf._global_config))
   16:             m.setattr(cf, "_deprecated_options", {})
   17:             m.setattr(cf, "_registered_options", {})
   18: 
   19:             # Our test fixture in conftest.py sets "chained_assignment"
   20:             # to "raise" only after all test methods have been setup.
   21:             # However, after this setup, there is no longer any
   22:             # "chained_assignment" option, so re-register it.
   23:             cf.register_option("chained_assignment", "raise")
   24:             yield
   25: 
   26:     def test_api(self):
   27:         # the pandas object exposes the user API
   28:         assert hasattr(pd, "get_option")
   29:         assert hasattr(pd, "set_option")
   30:         assert hasattr(pd, "reset_option")
   31:         assert hasattr(pd, "describe_option")
   32: 
   33:     def test_is_one_of_factory(self):
   34:         v = cf.is_one_of_factory([None, 12])
   35: 
   36:         v(12)
   37:         v(None)
   38:         msg = r"Value must be one of None\|12"
   39:         with pytest.raises(ValueError, match=msg):
   40:             v(1.1)
   41: 
   42:     def test_register_option(self):
   43:         cf.register_option("a", 1, "doc")
   44: 
   45:         # can't register an already registered option
   46:         msg = "Option 'a' has already been registered"
   47:         with pytest.raises(OptionError, match=msg):
   48:             cf.register_option("a", 1, "doc")
   49: 
   50:         # can't register an already registered option
   51:         msg = "Path prefix to option 'a' is already an option"
   52:         with pytest.raises(OptionError, match=msg):
   53:             cf.register_option("a.b.c.d1", 1, "doc")
   54:         with pytest.raises(OptionError, match=msg):
   55:             cf.register_option("a.b.c.d2", 1, "doc")
   56: 
   57:         # no python keywords
   58:         msg = "for is a python keyword"
   59:         with pytest.raises(ValueError, match=msg):
   60:             cf.register_option("for", 0)
   61:         with pytest.raises(ValueError, match=msg):
   62:             cf.register_option("a.for.b", 0)
   63:         # must be valid identifier (ensure attribute access works)
   64:         msg = "oh my goddess! is not a valid identifier"
   65:         with pytest.raises(ValueError, match=msg):
   66:             cf.register_option("Oh my Goddess!", 0)
   67: 
   68:         # we can register options several levels deep
   69:         # without predefining the intermediate steps
   70:         # and we can define differently named options
   71:         # in the same namespace
   72:         cf.register_option("k.b.c.d1", 1, "doc")
   73:         cf.register_option("k.b.c.d2", 1, "doc")
   74: 
   75:     def test_describe_option(self):
   76:         cf.register_option("a", 1, "doc")
   77:         cf.register_option("b", 1, "doc2")
   78:         cf.deprecate_option("b")
   79: 
   80:         cf.register_option("c.d.e1", 1, "doc3")
   81:         cf.register_option("c.d.e2", 1, "doc4")
   82:         cf.register_option("f", 1)
   83:         cf.register_option("g.h", 1)
   84:         cf.register_option("k", 2)
   85:         cf.deprecate_option("g.h", rkey="k")
   86:         cf.register_option("l", "foo")
   87: 
   88:         # non-existent keys raise KeyError
   89:         msg = r"No such keys\(s\)"
   90:         with pytest.raises(OptionError, match=msg):
   91:             cf.describe_option("no.such.key")
   92: 
   93:         # we can get the description for any key we registered
   94:         assert "doc" in cf.describe_option("a", _print_desc=False)
   95:         assert "doc2" in cf.describe_option("b", _print_desc=False)
   96:         assert "precated" in cf.describe_option("b", _print_desc=False)
   97:         assert "doc3" in cf.describe_option("c.d.e1", _print_desc=False)
   98:         assert "doc4" in cf.describe_option("c.d.e2", _print_desc=False)
   99: 
  100:         # if no doc is specified we get a default message
  101:         # saying "description not available"
  102:         assert "available" in cf.describe_option("f", _print_desc=False)
  103:         assert "available" in cf.describe_option("g.h", _print_desc=False)
  104:         assert "precated" in cf.describe_option("g.h", _print_desc=False)
  105:         assert "k" in cf.describe_option("g.h", _print_desc=False)
  106: 
  107:         # default is reported
  108:         assert "foo" in cf.describe_option("l", _print_desc=False)
  109:         # current value is reported
  110:         assert "bar" not in cf.describe_option("l", _print_desc=False)
  111:         cf.set_option("l", "bar")
  112:         assert "bar" in cf.describe_option("l", _print_desc=False)
  113: 
  114:     def test_case_insensitive(self):
  115:         cf.register_option("KanBAN", 1, "doc")
  116: 
  117:         assert "doc" in cf.describe_option("kanbaN", _print_desc=False)
  118:         assert cf.get_option("kanBaN") == 1
  119:         cf.set_option("KanBan", 2)
  120:         assert cf.get_option("kAnBaN") == 2
  121: 
  122:         # gets of non-existent keys fail
  123:         msg = r"No such keys\(s\): 'no_such_option'"
  124:         with pytest.raises(OptionError, match=msg):
  125:             cf.get_option("no_such_option")
  126:         cf.deprecate_option("KanBan")
  127: 
  128:         assert cf._is_deprecated("kAnBaN")
  129: 
  130:     def test_get_option(self):
  131:         cf.register_option("a", 1, "doc")
  132:         cf.register_option("b.c", "hullo", "doc2")
  133:         cf.register_option("b.b", None, "doc2")
  134: 
  135:         # gets of existing keys succeed
  136:         assert cf.get_option("a") == 1
  137:         assert cf.get_option("b.c") == "hullo"
  138:         assert cf.get_option("b.b") is None
  139: 
  140:         # gets of non-existent keys fail
  141:         msg = r"No such keys\(s\): 'no_such_option'"
  142:         with pytest.raises(OptionError, match=msg):
  143:             cf.get_option("no_such_option")
  144: 
  145:     def test_set_option(self):
  146:         cf.register_option("a", 1, "doc")
  147:         cf.register_option("b.c", "hullo", "doc2")
  148:         cf.register_option("b.b", None, "doc2")
  149: 
  150:         assert cf.get_option("a") == 1
  151:         assert cf.get_option("b.c") == "hullo"
  152:         assert cf.get_option("b.b") is None
  153: 
  154:         cf.set_option("a", 2)
  155:         cf.set_option("b.c", "wurld")
  156:         cf.set_option("b.b", 1.1)
  157: 
  158:         assert cf.get_option("a") == 2
  159:         assert cf.get_option("b.c") == "wurld"
  160:         assert cf.get_option("b.b") == 1.1
  161: 
  162:         msg = r"No such keys\(s\): 'no.such.key'"
  163:         with pytest.raises(OptionError, match=msg):
  164:             cf.set_option("no.such.key", None)
  165: 
  166:     def test_set_option_empty_args(self):
  167:         msg = "Must provide an even number of non-keyword arguments"
  168:         with pytest.raises(ValueError, match=msg):
  169:             cf.set_option()
  170: 
  171:     def test_set_option_uneven_args(self):
  172:         msg = "Must provide an even number of non-keyword arguments"
  173:         with pytest.raises(ValueError, match=msg):
  174:             cf.set_option("a.b", 2, "b.c")
  175: 
  176:     def test_set_option_invalid_single_argument_type(self):
  177:         msg = "Must provide an even number of non-keyword arguments"
  178:         with pytest.raises(ValueError, match=msg):
  179:             cf.set_option(2)
  180: 
  181:     def test_set_option_multiple(self):
  182:         cf.register_option("a", 1, "doc")
  183:         cf.register_option("b.c", "hullo", "doc2")
  184:         cf.register_option("b.b", None, "doc2")
  185: 
  186:         assert cf.get_option("a") == 1
  187:         assert cf.get_option("b.c") == "hullo"
  188:         assert cf.get_option("b.b") is None
  189: 
  190:         cf.set_option("a", "2", "b.c", None, "b.b", 10.0)
  191: 
  192:         assert cf.get_option("a") == "2"
  193:         assert cf.get_option("b.c") is None
  194:         assert cf.get_option("b.b") == 10.0
  195: 
  196:     def test_validation(self):
  197:         cf.register_option("a", 1, "doc", validator=cf.is_int)
  198:         cf.register_option("d", 1, "doc", validator=cf.is_nonnegative_int)
  199:         cf.register_option("b.c", "hullo", "doc2", validator=cf.is_text)
  200: 
  201:         msg = "Value must have type '<class 'int'>'"
  202:         with pytest.raises(ValueError, match=msg):
  203:             cf.register_option("a.b.c.d2", "NO", "doc", validator=cf.is_int)
  204: 
  205:         cf.set_option("a", 2)  # int is_int
  206:         cf.set_option("b.c", "wurld")  # str is_str
  207:         cf.set_option("d", 2)
  208:         cf.set_option("d", None)  # non-negative int can be None
  209: 
  210:         # None not is_int
  211:         with pytest.raises(ValueError, match=msg):
  212:             cf.set_option("a", None)
  213:         with pytest.raises(ValueError, match=msg):
  214:             cf.set_option("a", "ab")
  215: 
  216:         msg = "Value must be a nonnegative integer or None"
  217:         with pytest.raises(ValueError, match=msg):
  218:             cf.register_option("a.b.c.d3", "NO", "doc", validator=cf.is_nonnegative_int)
  219:         with pytest.raises(ValueError, match=msg):
  220:             cf.register_option("a.b.c.d3", -2, "doc", validator=cf.is_nonnegative_int)
  221: 
  222:         msg = r"Value must be an instance of <class 'str'>\|<class 'bytes'>"
  223:         with pytest.raises(ValueError, match=msg):
  224:             cf.set_option("b.c", 1)
  225: 
  226:         validator = cf.is_one_of_factory([None, cf.is_callable])
  227:         cf.register_option("b", lambda: None, "doc", validator=validator)
  228:         # pylint: disable-next=consider-using-f-string
  229:         cf.set_option("b", "%.1f".format)  # Formatter is callable
  230:         cf.set_option("b", None)  # Formatter is none (default)
  231:         with pytest.raises(ValueError, match="Value must be a callable"):
  232:             cf.set_option("b", "%.1f")
  233: 
  234:     def test_reset_option(self):
  235:         cf.register_option("a", 1, "doc", validator=cf.is_int)
  236:         cf.register_option("b.c", "hullo", "doc2", validator=cf.is_str)
  237:         assert cf.get_option("a") == 1
  238:         assert cf.get_option("b.c") == "hullo"
  239: 
  240:         cf.set_option("a", 2)
  241:         cf.set_option("b.c", "wurld")
  242:         assert cf.get_option("a") == 2
  243:         assert cf.get_option("b.c") == "wurld"
  244: 
  245:         cf.reset_option("a")
  246:         assert cf.get_option("a") == 1
  247:         assert cf.get_option("b.c") == "wurld"
  248:         cf.reset_option("b.c")
  249:         assert cf.get_option("a") == 1
  250:         assert cf.get_option("b.c") == "hullo"
  251: 
  252:     def test_reset_option_all(self):
  253:         cf.register_option("a", 1, "doc", validator=cf.is_int)
  254:         cf.register_option("b.c", "hullo", "doc2", validator=cf.is_str)
  255:         assert cf.get_option("a") == 1
  256:         assert cf.get_option("b.c") == "hullo"
  257: 
  258:         cf.set_option("a", 2)
  259:         cf.set_option("b.c", "wurld")
  260:         assert cf.get_option("a") == 2
  261:         assert cf.get_option("b.c") == "wurld"
  262: 
  263:         cf.reset_option("all")
  264:         assert cf.get_option("a") == 1
  265:         assert cf.get_option("b.c") == "hullo"
  266: 
  267:     def test_deprecate_option(self):
  268:         # we can deprecate non-existent options
  269:         cf.deprecate_option("foo")
  270: 
  271:         assert cf._is_deprecated("foo")
  272:         with tm.assert_produces_warning(FutureWarning, match="deprecated"):
  273:             with pytest.raises(KeyError, match="No such keys.s.: 'foo'"):
  274:                 cf.get_option("foo")
  275: 
  276:         cf.register_option("a", 1, "doc", validator=cf.is_int)
  277:         cf.register_option("b.c", "hullo", "doc2")
  278:         cf.register_option("foo", "hullo", "doc2")
  279: 
  280:         cf.deprecate_option("a", removal_ver="nifty_ver")
  281:         with tm.assert_produces_warning(FutureWarning, match="eprecated.*nifty_ver"):
  282:             cf.get_option("a")
  283: 
  284:             msg = "Option 'a' has already been defined as deprecated"
  285:             with pytest.raises(OptionError, match=msg):
  286:                 cf.deprecate_option("a")
  287: 
  288:         cf.deprecate_option("b.c", "zounds!")
  289:         with tm.assert_produces_warning(FutureWarning, match="zounds!"):
  290:             cf.get_option("b.c")
  291: 
  292:         # test rerouting keys
  293:         cf.register_option("d.a", "foo", "doc2")
  294:         cf.register_option("d.dep", "bar", "doc2")
  295:         assert cf.get_option("d.a") == "foo"
  296:         assert cf.get_option("d.dep") == "bar"
  297: 
  298:         cf.deprecate_option("d.dep", rkey="d.a")  # reroute d.dep to d.a
  299:         with tm.assert_produces_warning(FutureWarning, match="eprecated"):
  300:             assert cf.get_option("d.dep") == "foo"
  301: 
  302:         with tm.assert_produces_warning(FutureWarning, match="eprecated"):
  303:             cf.set_option("d.dep", "baz")  # should overwrite "d.a"
  304: 
  305:         with tm.assert_produces_warning(FutureWarning, match="eprecated"):
  306:             assert cf.get_option("d.dep") == "baz"
  307: 
  308:     def test_config_prefix(self):
  309:         with cf.config_prefix("base"):
  310:             cf.register_option("a", 1, "doc1")
  311:             cf.register_option("b", 2, "doc2")
  312:             assert cf.get_option("a") == 1
  313:             assert cf.get_option("b") == 2
  314: 
  315:             cf.set_option("a", 3)
  316:             cf.set_option("b", 4)
  317:             assert cf.get_option("a") == 3
  318:             assert cf.get_option("b") == 4
  319: 
  320:         assert cf.get_option("base.a") == 3
  321:         assert cf.get_option("base.b") == 4
  322:         assert "doc1" in cf.describe_option("base.a", _print_desc=False)
  323:         assert "doc2" in cf.describe_option("base.b", _print_desc=False)
  324: 
  325:         cf.reset_option("base.a")
  326:         cf.reset_option("base.b")
  327: 
  328:         with cf.config_prefix("base"):
  329:             assert cf.get_option("a") == 1
  330:             assert cf.get_option("b") == 2
  331: 
  332:     def test_callback(self):
  333:         k = [None]
  334:         v = [None]
  335: 
  336:         def callback(key):
  337:             k.append(key)
  338:             v.append(cf.get_option(key))
  339: 
  340:         cf.register_option("d.a", "foo", cb=callback)
  341:         cf.register_option("d.b", "foo", cb=callback)
  342: 
  343:         del k[-1], v[-1]
  344:         cf.set_option("d.a", "fooz")
  345:         assert k[-1] == "d.a"
  346:         assert v[-1] == "fooz"
  347: 
  348:         del k[-1], v[-1]
  349:         cf.set_option("d.b", "boo")
  350:         assert k[-1] == "d.b"
  351:         assert v[-1] == "boo"
  352: 
  353:         del k[-1], v[-1]
  354:         cf.reset_option("d.b")
  355:         assert k[-1] == "d.b"
  356: 
  357:     def test_set_ContextManager(self):
  358:         def eq(val):
  359:             assert cf.get_option("a") == val
  360: 
  361:         cf.register_option("a", 0)
  362:         eq(0)
  363:         with cf.option_context("a", 15):
  364:             eq(15)
  365:             with cf.option_context("a", 25):
  366:                 eq(25)
  367:             eq(15)
  368:         eq(0)
  369: 
  370:         cf.set_option("a", 17)
  371:         eq(17)
  372: 
  373:         # Test that option_context can be used as a decorator too (#34253).
  374:         @cf.option_context("a", 123)
  375:         def f():
  376:             eq(123)
  377: 
  378:         f()
  379: 
  380:     def test_attribute_access(self):
  381:         holder = []
  382: 
  383:         def f3(key):
  384:             holder.append(True)
  385: 
  386:         cf.register_option("a", 0)
  387:         cf.register_option("c", 0, cb=f3)
  388:         options = cf.options
  389: 
  390:         assert options.a == 0
  391:         with cf.option_context("a", 15):
  392:             assert options.a == 15
  393: 
  394:         options.a = 500
  395:         assert cf.get_option("a") == 500
  396: 
  397:         cf.reset_option("a")
  398:         assert options.a == cf.get_option("a", 0)
  399: 
  400:         msg = "You can only set the value of existing options"
  401:         with pytest.raises(OptionError, match=msg):
  402:             options.b = 1
  403:         with pytest.raises(OptionError, match=msg):
  404:             options.display = 1
  405: 
  406:         # make sure callback kicks when using this form of setting
  407:         options.c = 1
  408:         assert len(holder) == 1
  409: 
  410:     def test_option_context_scope(self):
  411:         # Ensure that creating a context does not affect the existing
  412:         # environment as it is supposed to be used with the `with` statement.
  413:         # See https://github.com/pandas-dev/pandas/issues/8514
  414: 
  415:         original_value = 60
  416:         context_value = 10
  417:         option_name = "a"
  418: 
  419:         cf.register_option(option_name, original_value)
  420: 
  421:         # Ensure creating contexts didn't affect the current context.
  422:         ctx = cf.option_context(option_name, context_value)
  423:         assert cf.get_option(option_name) == original_value
  424: 
  425:         # Ensure the correct value is available inside the context.
  426:         with ctx:
  427:             assert cf.get_option(option_name) == context_value
  428: 
  429:         # Ensure the current context is reset
  430:         assert cf.get_option(option_name) == original_value
  431: 
  432:     def test_dictwrapper_getattr(self):
  433:         options = cf.options
  434:         # GH 19789
  435:         with pytest.raises(OptionError, match="No such option"):
  436:             options.bananas
  437:         assert not hasattr(options, "bananas")
