    1: from collections.abc import Iterator
    2: from functools import partial
    3: from io import (
    4:     BytesIO,
    5:     StringIO,
    6: )
    7: import os
    8: from pathlib import Path
    9: import re
   10: import threading
   11: from urllib.error import URLError
   12: 
   13: import numpy as np
   14: import pytest
   15: 
   16: from pandas.compat import is_platform_windows
   17: import pandas.util._test_decorators as td
   18: 
   19: import pandas as pd
   20: from pandas import (
   21:     NA,
   22:     DataFrame,
   23:     MultiIndex,
   24:     Series,
   25:     Timestamp,
   26:     date_range,
   27:     read_csv,
   28:     read_html,
   29:     to_datetime,
   30: )
   31: import pandas._testing as tm
   32: from pandas.core.arrays import (
   33:     ArrowStringArray,
   34:     StringArray,
   35: )
   36: 
   37: from pandas.io.common import file_path_to_url
   38: 
   39: 
   40: @pytest.fixture(
   41:     params=[
   42:         "chinese_utf-16.html",
   43:         "chinese_utf-32.html",
   44:         "chinese_utf-8.html",
   45:         "letz_latin1.html",
   46:     ]
   47: )
   48: def html_encoding_file(request, datapath):
   49:     """Parametrized fixture for HTML encoding test filenames."""
   50:     return datapath("io", "data", "html_encoding", request.param)
   51: 
   52: 
   53: def assert_framelist_equal(list1, list2, *args, **kwargs):
   54:     assert len(list1) == len(list2), (
   55:         "lists are not of equal size "
   56:         f"len(list1) == {len(list1)}, "
   57:         f"len(list2) == {len(list2)}"
   58:     )
   59:     msg = "not all list elements are DataFrames"
   60:     both_frames = all(
   61:         map(
   62:             lambda x, y: isinstance(x, DataFrame) and isinstance(y, DataFrame),
   63:             list1,
   64:             list2,
   65:         )
   66:     )
   67:     assert both_frames, msg
   68:     for frame_i, frame_j in zip(list1, list2):
   69:         tm.assert_frame_equal(frame_i, frame_j, *args, **kwargs)
   70:         assert not frame_i.empty, "frames are both empty"
   71: 
   72: 
   73: def test_bs4_version_fails(monkeypatch, datapath):
   74:     bs4 = pytest.importorskip("bs4")
   75:     pytest.importorskip("html5lib")
   76: 
   77:     monkeypatch.setattr(bs4, "__version__", "4.2")
   78:     with pytest.raises(ImportError, match="Pandas requires version"):
   79:         read_html(datapath("io", "data", "html", "spam.html"), flavor="bs4")
   80: 
   81: 
   82: def test_invalid_flavor():
   83:     url = "google.com"
   84:     flavor = "invalid flavor"
   85:     msg = r"\{" + flavor + r"\} is not a valid set of flavors"
   86: 
   87:     with pytest.raises(ValueError, match=msg):
   88:         read_html(StringIO(url), match="google", flavor=flavor)
   89: 
   90: 
   91: def test_same_ordering(datapath):
   92:     pytest.importorskip("bs4")
   93:     pytest.importorskip("lxml")
   94:     pytest.importorskip("html5lib")
   95: 
   96:     filename = datapath("io", "data", "html", "valid_markup.html")
   97:     dfs_lxml = read_html(filename, index_col=0, flavor=["lxml"])
   98:     dfs_bs4 = read_html(filename, index_col=0, flavor=["bs4"])
   99:     assert_framelist_equal(dfs_lxml, dfs_bs4)
  100: 
  101: 
  102: @pytest.fixture(
  103:     params=[
  104:         pytest.param("bs4", marks=[td.skip_if_no("bs4"), td.skip_if_no("html5lib")]),
  105:         pytest.param("lxml", marks=td.skip_if_no("lxml")),
  106:     ],
  107: )
  108: def flavor_read_html(request):
  109:     return partial(read_html, flavor=request.param)
  110: 
  111: 
  112: class TestReadHtml:
  113:     def test_literal_html_deprecation(self, flavor_read_html):
  114:         # GH 53785
  115:         msg = (
  116:             "Passing literal html to 'read_html' is deprecated and "
  117:             "will be removed in a future version. To read from a "
  118:             "literal string, wrap it in a 'StringIO' object."
  119:         )
  120: 
  121:         with tm.assert_produces_warning(FutureWarning, match=msg):
  122:             flavor_read_html(
  123:                 """<table>
  124:                 <thead>
  125:                     <tr>
  126:                         <th>A</th>
  127:                         <th>B</th>
  128:                     </tr>
  129:                 </thead>
  130:                 <tbody>
  131:                     <tr>
  132:                         <td>1</td>
  133:                         <td>2</td>
  134:                     </tr>
  135:                 </tbody>
  136:                 <tbody>
  137:                     <tr>
  138:                         <td>3</td>
  139:                         <td>4</td>
  140:                     </tr>
  141:                 </tbody>
  142:             </table>"""
  143:             )
  144: 
  145:     @pytest.fixture
  146:     def spam_data(self, datapath):
  147:         return datapath("io", "data", "html", "spam.html")
  148: 
  149:     @pytest.fixture
  150:     def banklist_data(self, datapath):
  151:         return datapath("io", "data", "html", "banklist.html")
  152: 
  153:     def test_to_html_compat(self, flavor_read_html):
  154:         df = (
  155:             DataFrame(
  156:                 np.random.default_rng(2).random((4, 3)),
  157:                 columns=pd.Index(list("abc"), dtype=object),
  158:             )
  159:             # pylint: disable-next=consider-using-f-string
  160:             .map("{:.3f}".format).astype(float)
  161:         )
  162:         out = df.to_html()
  163:         res = flavor_read_html(
  164:             StringIO(out), attrs={"class": "dataframe"}, index_col=0
  165:         )[0]
  166:         tm.assert_frame_equal(res, df)
  167: 
  168:     def test_dtype_backend(self, string_storage, dtype_backend, flavor_read_html):
  169:         # GH#50286
  170:         df = DataFrame(
  171:             {
  172:                 "a": Series([1, np.nan, 3], dtype="Int64"),
  173:                 "b": Series([1, 2, 3], dtype="Int64"),
  174:                 "c": Series([1.5, np.nan, 2.5], dtype="Float64"),
  175:                 "d": Series([1.5, 2.0, 2.5], dtype="Float64"),
  176:                 "e": [True, False, None],
  177:                 "f": [True, False, True],
  178:                 "g": ["a", "b", "c"],
  179:                 "h": ["a", "b", None],
  180:             }
  181:         )
  182: 
  183:         if string_storage == "python":
  184:             string_array = StringArray(np.array(["a", "b", "c"], dtype=np.object_))
  185:             string_array_na = StringArray(np.array(["a", "b", NA], dtype=np.object_))
  186:         elif dtype_backend == "pyarrow":
  187:             pa = pytest.importorskip("pyarrow")
  188:             from pandas.arrays import ArrowExtensionArray
  189: 
  190:             string_array = ArrowExtensionArray(pa.array(["a", "b", "c"]))
  191:             string_array_na = ArrowExtensionArray(pa.array(["a", "b", None]))
  192:         else:
  193:             pa = pytest.importorskip("pyarrow")
  194:             string_array = ArrowStringArray(pa.array(["a", "b", "c"]))
  195:             string_array_na = ArrowStringArray(pa.array(["a", "b", None]))
  196: 
  197:         out = df.to_html(index=False)
  198:         with pd.option_context("mode.string_storage", string_storage):
  199:             result = flavor_read_html(StringIO(out), dtype_backend=dtype_backend)[0]
  200: 
  201:         expected = DataFrame(
  202:             {
  203:                 "a": Series([1, np.nan, 3], dtype="Int64"),
  204:                 "b": Series([1, 2, 3], dtype="Int64"),
  205:                 "c": Series([1.5, np.nan, 2.5], dtype="Float64"),
  206:                 "d": Series([1.5, 2.0, 2.5], dtype="Float64"),
  207:                 "e": Series([True, False, NA], dtype="boolean"),
  208:                 "f": Series([True, False, True], dtype="boolean"),
  209:                 "g": string_array,
  210:                 "h": string_array_na,
  211:             }
  212:         )
  213: 
  214:         if dtype_backend == "pyarrow":
  215:             import pyarrow as pa
  216: 
  217:             from pandas.arrays import ArrowExtensionArray
  218: 
  219:             expected = DataFrame(
  220:                 {
  221:                     col: ArrowExtensionArray(pa.array(expected[col], from_pandas=True))
  222:                     for col in expected.columns
  223:                 }
  224:             )
  225: 
  226:         tm.assert_frame_equal(result, expected)
  227: 
  228:     @pytest.mark.network
  229:     @pytest.mark.single_cpu
  230:     def test_banklist_url(self, httpserver, banklist_data, flavor_read_html):
  231:         with open(banklist_data, encoding="utf-8") as f:
  232:             httpserver.serve_content(content=f.read())
  233:             df1 = flavor_read_html(
  234:                 # lxml cannot find attrs leave out for now
  235:                 httpserver.url,
  236:                 match="First Federal Bank of Florida",  # attrs={"class": "dataTable"}
  237:             )
  238:             # lxml cannot find attrs leave out for now
  239:             df2 = flavor_read_html(
  240:                 httpserver.url,
  241:                 match="Metcalf Bank",
  242:             )  # attrs={"class": "dataTable"})
  243: 
  244:         assert_framelist_equal(df1, df2)
  245: 
  246:     @pytest.mark.network
  247:     @pytest.mark.single_cpu
  248:     def test_spam_url(self, httpserver, spam_data, flavor_read_html):
  249:         with open(spam_data, encoding="utf-8") as f:
  250:             httpserver.serve_content(content=f.read())
  251:             df1 = flavor_read_html(httpserver.url, match=".*Water.*")
  252:             df2 = flavor_read_html(httpserver.url, match="Unit")
  253: 
  254:         assert_framelist_equal(df1, df2)
  255: 
  256:     @pytest.mark.slow
  257:     def test_banklist(self, banklist_data, flavor_read_html):
  258:         df1 = flavor_read_html(
  259:             banklist_data, match=".*Florida.*", attrs={"id": "table"}
  260:         )
  261:         df2 = flavor_read_html(
  262:             banklist_data, match="Metcalf Bank", attrs={"id": "table"}
  263:         )
  264: 
  265:         assert_framelist_equal(df1, df2)
  266: 
  267:     def test_spam(self, spam_data, flavor_read_html):
  268:         df1 = flavor_read_html(spam_data, match=".*Water.*")
  269:         df2 = flavor_read_html(spam_data, match="Unit")
  270:         assert_framelist_equal(df1, df2)
  271: 
  272:         assert df1[0].iloc[0, 0] == "Proximates"
  273:         assert df1[0].columns[0] == "Nutrient"
  274: 
  275:     def test_spam_no_match(self, spam_data, flavor_read_html):
  276:         dfs = flavor_read_html(spam_data)
  277:         for df in dfs:
  278:             assert isinstance(df, DataFrame)
  279: 
  280:     def test_banklist_no_match(self, banklist_data, flavor_read_html):
  281:         dfs = flavor_read_html(banklist_data, attrs={"id": "table"})
  282:         for df in dfs:
  283:             assert isinstance(df, DataFrame)
  284: 
  285:     def test_spam_header(self, spam_data, flavor_read_html):
  286:         df = flavor_read_html(spam_data, match=".*Water.*", header=2)[0]
  287:         assert df.columns[0] == "Proximates"
  288:         assert not df.empty
  289: 
  290:     def test_skiprows_int(self, spam_data, flavor_read_html):
  291:         df1 = flavor_read_html(spam_data, match=".*Water.*", skiprows=1)
  292:         df2 = flavor_read_html(spam_data, match="Unit", skiprows=1)
  293: 
  294:         assert_framelist_equal(df1, df2)
  295: 
  296:     def test_skiprows_range(self, spam_data, flavor_read_html):
  297:         df1 = flavor_read_html(spam_data, match=".*Water.*", skiprows=range(2))
  298:         df2 = flavor_read_html(spam_data, match="Unit", skiprows=range(2))
  299: 
  300:         assert_framelist_equal(df1, df2)
  301: 
  302:     def test_skiprows_list(self, spam_data, flavor_read_html):
  303:         df1 = flavor_read_html(spam_data, match=".*Water.*", skiprows=[1, 2])
  304:         df2 = flavor_read_html(spam_data, match="Unit", skiprows=[2, 1])
  305: 
  306:         assert_framelist_equal(df1, df2)
  307: 
  308:     def test_skiprows_set(self, spam_data, flavor_read_html):
  309:         df1 = flavor_read_html(spam_data, match=".*Water.*", skiprows={1, 2})
  310:         df2 = flavor_read_html(spam_data, match="Unit", skiprows={2, 1})
  311: 
  312:         assert_framelist_equal(df1, df2)
  313: 
  314:     def test_skiprows_slice(self, spam_data, flavor_read_html):
  315:         df1 = flavor_read_html(spam_data, match=".*Water.*", skiprows=1)
  316:         df2 = flavor_read_html(spam_data, match="Unit", skiprows=1)
  317: 
  318:         assert_framelist_equal(df1, df2)
  319: 
  320:     def test_skiprows_slice_short(self, spam_data, flavor_read_html):
  321:         df1 = flavor_read_html(spam_data, match=".*Water.*", skiprows=slice(2))
  322:         df2 = flavor_read_html(spam_data, match="Unit", skiprows=slice(2))
  323: 
  324:         assert_framelist_equal(df1, df2)
  325: 
  326:     def test_skiprows_slice_long(self, spam_data, flavor_read_html):
  327:         df1 = flavor_read_html(spam_data, match=".*Water.*", skiprows=slice(2, 5))
  328:         df2 = flavor_read_html(spam_data, match="Unit", skiprows=slice(4, 1, -1))
  329: 
  330:         assert_framelist_equal(df1, df2)
  331: 
  332:     def test_skiprows_ndarray(self, spam_data, flavor_read_html):
  333:         df1 = flavor_read_html(spam_data, match=".*Water.*", skiprows=np.arange(2))
  334:         df2 = flavor_read_html(spam_data, match="Unit", skiprows=np.arange(2))
  335: 
  336:         assert_framelist_equal(df1, df2)
  337: 
  338:     def test_skiprows_invalid(self, spam_data, flavor_read_html):
  339:         with pytest.raises(TypeError, match=("is not a valid type for skipping rows")):
  340:             flavor_read_html(spam_data, match=".*Water.*", skiprows="asdf")
  341: 
  342:     def test_index(self, spam_data, flavor_read_html):
  343:         df1 = flavor_read_html(spam_data, match=".*Water.*", index_col=0)
  344:         df2 = flavor_read_html(spam_data, match="Unit", index_col=0)
  345:         assert_framelist_equal(df1, df2)
  346: 
  347:     def test_header_and_index_no_types(self, spam_data, flavor_read_html):
  348:         df1 = flavor_read_html(spam_data, match=".*Water.*", header=1, index_col=0)
  349:         df2 = flavor_read_html(spam_data, match="Unit", header=1, index_col=0)
  350:         assert_framelist_equal(df1, df2)
  351: 
  352:     def test_header_and_index_with_types(self, spam_data, flavor_read_html):
  353:         df1 = flavor_read_html(spam_data, match=".*Water.*", header=1, index_col=0)
  354:         df2 = flavor_read_html(spam_data, match="Unit", header=1, index_col=0)
  355:         assert_framelist_equal(df1, df2)
  356: 
  357:     def test_infer_types(self, spam_data, flavor_read_html):
  358:         # 10892 infer_types removed
  359:         df1 = flavor_read_html(spam_data, match=".*Water.*", index_col=0)
  360:         df2 = flavor_read_html(spam_data, match="Unit", index_col=0)
  361:         assert_framelist_equal(df1, df2)
  362: 
  363:     def test_string_io(self, spam_data, flavor_read_html):
  364:         with open(spam_data, encoding="UTF-8") as f:
  365:             data1 = StringIO(f.read())
  366: 
  367:         with open(spam_data, encoding="UTF-8") as f:
  368:             data2 = StringIO(f.read())
  369: 
  370:         df1 = flavor_read_html(data1, match=".*Water.*")
  371:         df2 = flavor_read_html(data2, match="Unit")
  372:         assert_framelist_equal(df1, df2)
  373: 
  374:     def test_string(self, spam_data, flavor_read_html):
  375:         with open(spam_data, encoding="UTF-8") as f:
  376:             data = f.read()
  377: 
  378:         df1 = flavor_read_html(StringIO(data), match=".*Water.*")
  379:         df2 = flavor_read_html(StringIO(data), match="Unit")
  380: 
  381:         assert_framelist_equal(df1, df2)
  382: 
  383:     def test_file_like(self, spam_data, flavor_read_html):
  384:         with open(spam_data, encoding="UTF-8") as f:
  385:             df1 = flavor_read_html(f, match=".*Water.*")
  386: 
  387:         with open(spam_data, encoding="UTF-8") as f:
  388:             df2 = flavor_read_html(f, match="Unit")
  389: 
  390:         assert_framelist_equal(df1, df2)
  391: 
  392:     @pytest.mark.network
  393:     @pytest.mark.single_cpu
  394:     def test_bad_url_protocol(self, httpserver, flavor_read_html):
  395:         httpserver.serve_content("urlopen error unknown url type: git", code=404)
  396:         with pytest.raises(URLError, match="urlopen error unknown url type: git"):
  397:             flavor_read_html("git://github.com", match=".*Water.*")
  398: 
  399:     @pytest.mark.slow
  400:     @pytest.mark.network
  401:     @pytest.mark.single_cpu
  402:     def test_invalid_url(self, httpserver, flavor_read_html):
  403:         httpserver.serve_content("Name or service not known", code=404)
  404:         with pytest.raises((URLError, ValueError), match="HTTP Error 404: NOT FOUND"):
  405:             flavor_read_html(httpserver.url, match=".*Water.*")
  406: 
  407:     @pytest.mark.slow
  408:     def test_file_url(self, banklist_data, flavor_read_html):
  409:         url = banklist_data
  410:         dfs = flavor_read_html(
  411:             file_path_to_url(os.path.abspath(url)), match="First", attrs={"id": "table"}
  412:         )
  413:         assert isinstance(dfs, list)
  414:         for df in dfs:
  415:             assert isinstance(df, DataFrame)
  416: 
  417:     @pytest.mark.slow
  418:     def test_invalid_table_attrs(self, banklist_data, flavor_read_html):
  419:         url = banklist_data
  420:         with pytest.raises(ValueError, match="No tables found"):
  421:             flavor_read_html(
  422:                 url, match="First Federal Bank of Florida", attrs={"id": "tasdfable"}
  423:             )
  424: 
  425:     @pytest.mark.slow
  426:     def test_multiindex_header(self, banklist_data, flavor_read_html):
  427:         df = flavor_read_html(
  428:             banklist_data, match="Metcalf", attrs={"id": "table"}, header=[0, 1]
  429:         )[0]
  430:         assert isinstance(df.columns, MultiIndex)
  431: 
  432:     @pytest.mark.slow
  433:     def test_multiindex_index(self, banklist_data, flavor_read_html):
  434:         df = flavor_read_html(
  435:             banklist_data, match="Metcalf", attrs={"id": "table"}, index_col=[0, 1]
  436:         )[0]
  437:         assert isinstance(df.index, MultiIndex)
  438: 
  439:     @pytest.mark.slow
  440:     def test_multiindex_header_index(self, banklist_data, flavor_read_html):
  441:         df = flavor_read_html(
  442:             banklist_data,
  443:             match="Metcalf",
  444:             attrs={"id": "table"},
  445:             header=[0, 1],
  446:             index_col=[0, 1],
  447:         )[0]
  448:         assert isinstance(df.columns, MultiIndex)
  449:         assert isinstance(df.index, MultiIndex)
  450: 
  451:     @pytest.mark.slow
  452:     def test_multiindex_header_skiprows_tuples(self, banklist_data, flavor_read_html):
  453:         df = flavor_read_html(
  454:             banklist_data,
  455:             match="Metcalf",
  456:             attrs={"id": "table"},
  457:             header=[0, 1],
  458:             skiprows=1,
  459:         )[0]
  460:         assert isinstance(df.columns, MultiIndex)
  461: 
  462:     @pytest.mark.slow
  463:     def test_multiindex_header_skiprows(self, banklist_data, flavor_read_html):
  464:         df = flavor_read_html(
  465:             banklist_data,
  466:             match="Metcalf",
  467:             attrs={"id": "table"},
  468:             header=[0, 1],
  469:             skiprows=1,
  470:         )[0]
  471:         assert isinstance(df.columns, MultiIndex)
  472: 
  473:     @pytest.mark.slow
  474:     def test_multiindex_header_index_skiprows(self, banklist_data, flavor_read_html):
  475:         df = flavor_read_html(
  476:             banklist_data,
  477:             match="Metcalf",
  478:             attrs={"id": "table"},
  479:             header=[0, 1],
  480:             index_col=[0, 1],
  481:             skiprows=1,
  482:         )[0]
  483:         assert isinstance(df.index, MultiIndex)
  484:         assert isinstance(df.columns, MultiIndex)
  485: 
  486:     @pytest.mark.slow
  487:     def test_regex_idempotency(self, banklist_data, flavor_read_html):
  488:         url = banklist_data
  489:         dfs = flavor_read_html(
  490:             file_path_to_url(os.path.abspath(url)),
  491:             match=re.compile(re.compile("Florida")),
  492:             attrs={"id": "table"},
  493:         )
  494:         assert isinstance(dfs, list)
  495:         for df in dfs:
  496:             assert isinstance(df, DataFrame)
  497: 
  498:     def test_negative_skiprows(self, spam_data, flavor_read_html):
  499:         msg = r"\(you passed a negative value\)"
  500:         with pytest.raises(ValueError, match=msg):
  501:             flavor_read_html(spam_data, match="Water", skiprows=-1)
  502: 
  503:     @pytest.fixture
  504:     def python_docs(self):
  505:         return """
  506:           <table class="contentstable" align="center"><tr>
  507:             <td width="50%">
  508:             <p class="biglink"><a class="biglink" href="whatsnew/2.7.html">What's new in Python 2.7?</a><br/>
  509:                 <span class="linkdescr">or <a href="whatsnew/index.html">all "What's new" documents</a> since 2.0</span></p>
  510:             <p class="biglink"><a class="biglink" href="tutorial/index.html">Tutorial</a><br/>
  511:                 <span class="linkdescr">start here</span></p>
  512:             <p class="biglink"><a class="biglink" href="library/index.html">Library Reference</a><br/>
  513:                 <span class="linkdescr">keep this under your pillow</span></p>
  514:             <p class="biglink"><a class="biglink" href="reference/index.html">Language Reference</a><br/>
  515:                 <span class="linkdescr">describes syntax and language elements</span></p>
  516:             <p class="biglink"><a class="biglink" href="using/index.html">Python Setup and Usage</a><br/>
  517:                 <span class="linkdescr">how to use Python on different platforms</span></p>
  518:             <p class="biglink"><a class="biglink" href="howto/index.html">Python HOWTOs</a><br/>
  519:                 <span class="linkdescr">in-depth documents on specific topics</span></p>
  520:             </td><td width="50%">
  521:             <p class="biglink"><a class="biglink" href="installing/index.html">Installing Python Modules</a><br/>
  522:                 <span class="linkdescr">installing from the Python Package Index &amp; other sources</span></p>
  523:             <p class="biglink"><a class="biglink" href="distributing/index.html">Distributing Python Modules</a><br/>
  524:                 <span class="linkdescr">publishing modules for installation by others</span></p>
  525:             <p class="biglink"><a class="biglink" href="extending/index.html">Extending and Embedding</a><br/>
  526:                 <span class="linkdescr">tutorial for C/C++ programmers</span></p>
  527:             <p class="biglink"><a class="biglink" href="c-api/index.html">Python/C API</a><br/>
  528:                 <span class="linkdescr">reference for C/C++ programmers</span></p>
  529:             <p class="biglink"><a class="biglink" href="faq/index.html">FAQs</a><br/>
  530:                 <span class="linkdescr">frequently asked questions (with answers!)</span></p>
  531:             </td></tr>
  532:         </table>
  533: 
  534:         <p><strong>Indices and tables:</strong></p>
  535:         <table class="contentstable" align="center"><tr>
  536:             <td width="50%">
  537:             <p class="biglink"><a class="biglink" href="py-modindex.html">Python Global Module Index</a><br/>
  538:                 <span class="linkdescr">quick access to all modules</span></p>
  539:             <p class="biglink"><a class="biglink" href="genindex.html">General Index</a><br/>
  540:                 <span class="linkdescr">all functions, classes, terms</span></p>
  541:             <p class="biglink"><a class="biglink" href="glossary.html">Glossary</a><br/>
  542:                 <span class="linkdescr">the most important terms explained</span></p>
  543:             </td><td width="50%">
  544:             <p class="biglink"><a class="biglink" href="search.html">Search page</a><br/>
  545:                 <span class="linkdescr">search this documentation</span></p>
  546:             <p class="biglink"><a class="biglink" href="contents.html">Complete Table of Contents</a><br/>
  547:                 <span class="linkdescr">lists all sections and subsections</span></p>
  548:             </td></tr>
  549:         </table>
  550:         """  # noqa: E501
  551: 
  552:     @pytest.mark.network
  553:     @pytest.mark.single_cpu
  554:     def test_multiple_matches(self, python_docs, httpserver, flavor_read_html):
  555:         httpserver.serve_content(content=python_docs)
  556:         dfs = flavor_read_html(httpserver.url, match="Python")
  557:         assert len(dfs) > 1
  558: 
  559:     @pytest.mark.network
  560:     @pytest.mark.single_cpu
  561:     def test_python_docs_table(self, python_docs, httpserver, flavor_read_html):
  562:         httpserver.serve_content(content=python_docs)
  563:         dfs = flavor_read_html(httpserver.url, match="Python")
  564:         zz = [df.iloc[0, 0][0:4] for df in dfs]
  565:         assert sorted(zz) == ["Pyth", "What"]
  566: 
  567:     def test_empty_tables(self, flavor_read_html):
  568:         """
  569:         Make sure that read_html ignores empty tables.
  570:         """
  571:         html = """
  572:             <table>
  573:                 <thead>
  574:                     <tr>
  575:                         <th>A</th>
  576:                         <th>B</th>
  577:                     </tr>
  578:                 </thead>
  579:                 <tbody>
  580:                     <tr>
  581:                         <td>1</td>
  582:                         <td>2</td>
  583:                     </tr>
  584:                 </tbody>
  585:             </table>
  586:             <table>
  587:                 <tbody>
  588:                 </tbody>
  589:             </table>
  590:         """
  591:         result = flavor_read_html(StringIO(html))
  592:         assert len(result) == 1
  593: 
  594:     def test_multiple_tbody(self, flavor_read_html):
  595:         # GH-20690
  596:         # Read all tbody tags within a single table.
  597:         result = flavor_read_html(
  598:             StringIO(
  599:                 """<table>
  600:             <thead>
  601:                 <tr>
  602:                     <th>A</th>
  603:                     <th>B</th>
  604:                 </tr>
  605:             </thead>
  606:             <tbody>
  607:                 <tr>
  608:                     <td>1</td>
  609:                     <td>2</td>
  610:                 </tr>
  611:             </tbody>
  612:             <tbody>
  613:                 <tr>
  614:                     <td>3</td>
  615:                     <td>4</td>
  616:                 </tr>
  617:             </tbody>
  618:         </table>"""
  619:             )
  620:         )[0]
  621: 
  622:         expected = DataFrame(data=[[1, 2], [3, 4]], columns=["A", "B"])
  623: 
  624:         tm.assert_frame_equal(result, expected)
  625: 
  626:     def test_header_and_one_column(self, flavor_read_html):
  627:         """
  628:         Don't fail with bs4 when there is a header and only one column
  629:         as described in issue #9178
  630:         """
  631:         result = flavor_read_html(
  632:             StringIO(
  633:                 """<table>
  634:                 <thead>
  635:                     <tr>
  636:                         <th>Header</th>
  637:                     </tr>
  638:                 </thead>
  639:                 <tbody>
  640:                     <tr>
  641:                         <td>first</td>
  642:                     </tr>
  643:                 </tbody>
  644:             </table>"""
  645:             )
  646:         )[0]
  647: 
  648:         expected = DataFrame(data={"Header": "first"}, index=[0])
  649: 
  650:         tm.assert_frame_equal(result, expected)
  651: 
  652:     def test_thead_without_tr(self, flavor_read_html):
  653:         """
  654:         Ensure parser adds <tr> within <thead> on malformed HTML.
  655:         """
  656:         result = flavor_read_html(
  657:             StringIO(
  658:                 """<table>
  659:             <thead>
  660:                 <tr>
  661:                     <th>Country</th>
  662:                     <th>Municipality</th>
  663:                     <th>Year</th>
  664:                 </tr>
  665:             </thead>
  666:             <tbody>
  667:                 <tr>
  668:                     <td>Ukraine</td>
  669:                     <th>Odessa</th>
  670:                     <td>1944</td>
  671:                 </tr>
  672:             </tbody>
  673:         </table>"""
  674:             )
  675:         )[0]
  676: 
  677:         expected = DataFrame(
  678:             data=[["Ukraine", "Odessa", 1944]],
  679:             columns=["Country", "Municipality", "Year"],
  680:         )
  681: 
  682:         tm.assert_frame_equal(result, expected)
  683: 
  684:     def test_tfoot_read(self, flavor_read_html):
  685:         """
  686:         Make sure that read_html reads tfoot, containing td or th.
  687:         Ignores empty tfoot
  688:         """
  689:         data_template = """<table>
  690:             <thead>
  691:                 <tr>
  692:                     <th>A</th>
  693:                     <th>B</th>
  694:                 </tr>
  695:             </thead>
  696:             <tbody>
  697:                 <tr>
  698:                     <td>bodyA</td>
  699:                     <td>bodyB</td>
  700:                 </tr>
  701:             </tbody>
  702:             <tfoot>
  703:                 {footer}
  704:             </tfoot>
  705:         </table>"""
  706: 
  707:         expected1 = DataFrame(data=[["bodyA", "bodyB"]], columns=["A", "B"])
  708: 
  709:         expected2 = DataFrame(
  710:             data=[["bodyA", "bodyB"], ["footA", "footB"]], columns=["A", "B"]
  711:         )
  712: 
  713:         data1 = data_template.format(footer="")
  714:         data2 = data_template.format(footer="<tr><td>footA</td><th>footB</th></tr>")
  715: 
  716:         result1 = flavor_read_html(StringIO(data1))[0]
  717:         result2 = flavor_read_html(StringIO(data2))[0]
  718: 
  719:         tm.assert_frame_equal(result1, expected1)
  720:         tm.assert_frame_equal(result2, expected2)
  721: 
  722:     def test_parse_header_of_non_string_column(self, flavor_read_html):
  723:         # GH5048: if header is specified explicitly, an int column should be
  724:         # parsed as int while its header is parsed as str
  725:         result = flavor_read_html(
  726:             StringIO(
  727:                 """
  728:             <table>
  729:                 <tr>
  730:                     <td>S</td>
  731:                     <td>I</td>
  732:                 </tr>
  733:                 <tr>
  734:                     <td>text</td>
  735:                     <td>1944</td>
  736:                 </tr>
  737:             </table>
  738:         """
  739:             ),
  740:             header=0,
  741:         )[0]
  742: 
  743:         expected = DataFrame([["text", 1944]], columns=("S", "I"))
  744: 
  745:         tm.assert_frame_equal(result, expected)
  746: 
  747:     @pytest.mark.slow
  748:     def test_banklist_header(self, banklist_data, datapath, flavor_read_html):
  749:         from pandas.io.html import _remove_whitespace
  750: 
  751:         def try_remove_ws(x):
  752:             try:
  753:                 return _remove_whitespace(x)
  754:             except AttributeError:
  755:                 return x
  756: 
  757:         df = flavor_read_html(banklist_data, match="Metcalf", attrs={"id": "table"})[0]
  758:         ground_truth = read_csv(
  759:             datapath("io", "data", "csv", "banklist.csv"),
  760:             converters={"Updated Date": Timestamp, "Closing Date": Timestamp},
  761:         )
  762:         assert df.shape == ground_truth.shape
  763:         old = [
  764:             "First Vietnamese American Bank In Vietnamese",
  765:             "Westernbank Puerto Rico En Espanol",
  766:             "R-G Premier Bank of Puerto Rico En Espanol",
  767:             "Eurobank En Espanol",
  768:             "Sanderson State Bank En Espanol",
  769:             "Washington Mutual Bank (Including its subsidiary Washington "
  770:             "Mutual Bank FSB)",
  771:             "Silver State Bank En Espanol",
  772:             "AmTrade International Bank En Espanol",
  773:             "Hamilton Bank, NA En Espanol",
  774:             "The Citizens Savings Bank Pioneer Community Bank, Inc.",
  775:         ]
  776:         new = [
  777:             "First Vietnamese American Bank",
  778:             "Westernbank Puerto Rico",
  779:             "R-G Premier Bank of Puerto Rico",
  780:             "Eurobank",
  781:             "Sanderson State Bank",
  782:             "Washington Mutual Bank",
  783:             "Silver State Bank",
  784:             "AmTrade International Bank",
  785:             "Hamilton Bank, NA",
  786:             "The Citizens Savings Bank",
  787:         ]
  788:         dfnew = df.map(try_remove_ws).replace(old, new)
  789:         gtnew = ground_truth.map(try_remove_ws)
  790:         converted = dfnew
  791:         date_cols = ["Closing Date", "Updated Date"]
  792:         converted[date_cols] = converted[date_cols].apply(to_datetime)
  793:         tm.assert_frame_equal(converted, gtnew)
  794: 
  795:     @pytest.mark.slow
  796:     def test_gold_canyon(self, banklist_data, flavor_read_html):
  797:         gc = "Gold Canyon"
  798:         with open(banklist_data, encoding="utf-8") as f:
  799:             raw_text = f.read()
  800: 
  801:         assert gc in raw_text
  802:         df = flavor_read_html(
  803:             banklist_data, match="Gold Canyon", attrs={"id": "table"}
  804:         )[0]
  805:         assert gc in df.to_string()
  806: 
  807:     def test_different_number_of_cols(self, flavor_read_html):
  808:         expected = flavor_read_html(
  809:             StringIO(
  810:                 """<table>
  811:                         <thead>
  812:                             <tr style="text-align: right;">
  813:                             <th></th>
  814:                             <th>C_l0_g0</th>
  815:                             <th>C_l0_g1</th>
  816:                             <th>C_l0_g2</th>
  817:                             <th>C_l0_g3</th>
  818:                             <th>C_l0_g4</th>
  819:                             </tr>
  820:                         </thead>
  821:                         <tbody>
  822:                             <tr>
  823:                             <th>R_l0_g0</th>
  824:                             <td> 0.763</td>
  825:                             <td> 0.233</td>
  826:                             <td> nan</td>
  827:                             <td> nan</td>
  828:                             <td> nan</td>
  829:                             </tr>
  830:                             <tr>
  831:                             <th>R_l0_g1</th>
  832:                             <td> 0.244</td>
  833:                             <td> 0.285</td>
  834:                             <td> 0.392</td>
  835:                             <td> 0.137</td>
  836:                             <td> 0.222</td>
  837:                             </tr>
  838:                         </tbody>
  839:                     </table>"""
  840:             ),
  841:             index_col=0,
  842:         )[0]
  843: 
  844:         result = flavor_read_html(
  845:             StringIO(
  846:                 """<table>
  847:                     <thead>
  848:                         <tr style="text-align: right;">
  849:                         <th></th>
  850:                         <th>C_l0_g0</th>
  851:                         <th>C_l0_g1</th>
  852:                         <th>C_l0_g2</th>
  853:                         <th>C_l0_g3</th>
  854:                         <th>C_l0_g4</th>
  855:                         </tr>
  856:                     </thead>
  857:                     <tbody>
  858:                         <tr>
  859:                         <th>R_l0_g0</th>
  860:                         <td> 0.763</td>
  861:                         <td> 0.233</td>
  862:                         </tr>
  863:                         <tr>
  864:                         <th>R_l0_g1</th>
  865:                         <td> 0.244</td>
  866:                         <td> 0.285</td>
  867:                         <td> 0.392</td>
  868:                         <td> 0.137</td>
  869:                         <td> 0.222</td>
  870:                         </tr>
  871:                     </tbody>
  872:                  </table>"""
  873:             ),
  874:             index_col=0,
  875:         )[0]
  876: 
  877:         tm.assert_frame_equal(result, expected)
  878: 
  879:     def test_colspan_rowspan_1(self, flavor_read_html):
  880:         # GH17054
  881:         result = flavor_read_html(
  882:             StringIO(
  883:                 """
  884:             <table>
  885:                 <tr>
  886:                     <th>A</th>
  887:                     <th colspan="1">B</th>
  888:                     <th rowspan="1">C</th>
  889:                 </tr>
  890:                 <tr>
  891:                     <td>a</td>
  892:                     <td>b</td>
  893:                     <td>c</td>
  894:                 </tr>
  895:             </table>
  896:         """
  897:             )
  898:         )[0]
  899: 
  900:         expected = DataFrame([["a", "b", "c"]], columns=["A", "B", "C"])
  901: 
  902:         tm.assert_frame_equal(result, expected)
  903: 
  904:     def test_colspan_rowspan_copy_values(self, flavor_read_html):
  905:         # GH17054
  906: 
  907:         # In ASCII, with lowercase letters being copies:
  908:         #
  909:         # X x Y Z W
  910:         # A B b z C
  911: 
  912:         result = flavor_read_html(
  913:             StringIO(
  914:                 """
  915:             <table>
  916:                 <tr>
  917:                     <td colspan="2">X</td>
  918:                     <td>Y</td>
  919:                     <td rowspan="2">Z</td>
  920:                     <td>W</td>
  921:                 </tr>
  922:                 <tr>
  923:                     <td>A</td>
  924:                     <td colspan="2">B</td>
  925:                     <td>C</td>
  926:                 </tr>
  927:             </table>
  928:         """
  929:             ),
  930:             header=0,
  931:         )[0]
  932: 
  933:         expected = DataFrame(
  934:             data=[["A", "B", "B", "Z", "C"]], columns=["X", "X.1", "Y", "Z", "W"]
  935:         )
  936: 
  937:         tm.assert_frame_equal(result, expected)
  938: 
  939:     def test_colspan_rowspan_both_not_1(self, flavor_read_html):
  940:         # GH17054
  941: 
  942:         # In ASCII, with lowercase letters being copies:
  943:         #
  944:         # A B b b C
  945:         # a b b b D
  946: 
  947:         result = flavor_read_html(
  948:             StringIO(
  949:                 """
  950:             <table>
  951:                 <tr>
  952:                     <td rowspan="2">A</td>
  953:                     <td rowspan="2" colspan="3">B</td>
  954:                     <td>C</td>
  955:                 </tr>
  956:                 <tr>
  957:                     <td>D</td>
  958:                 </tr>
  959:             </table>
  960:         """
  961:             ),
  962:             header=0,
  963:         )[0]
  964: 
  965:         expected = DataFrame(
  966:             data=[["A", "B", "B", "B", "D"]], columns=["A", "B", "B.1", "B.2", "C"]
  967:         )
  968: 
  969:         tm.assert_frame_equal(result, expected)
  970: 
  971:     def test_rowspan_at_end_of_row(self, flavor_read_html):
  972:         # GH17054
  973: 
  974:         # In ASCII, with lowercase letters being copies:
  975:         #
  976:         # A B
  977:         # C b
  978: 
  979:         result = flavor_read_html(
  980:             StringIO(
  981:                 """
  982:             <table>
  983:                 <tr>
  984:                     <td>A</td>
  985:                     <td rowspan="2">B</td>
  986:                 </tr>
  987:                 <tr>
  988:                     <td>C</td>
  989:                 </tr>
  990:             </table>
  991:         """
  992:             ),
  993:             header=0,
  994:         )[0]
  995: 
  996:         expected = DataFrame(data=[["C", "B"]], columns=["A", "B"])
  997: 
  998:         tm.assert_frame_equal(result, expected)
  999: 
 1000:     def test_rowspan_only_rows(self, flavor_read_html):
 1001:         # GH17054
 1002: 
 1003:         result = flavor_read_html(
 1004:             StringIO(
 1005:                 """
 1006:             <table>
 1007:                 <tr>
 1008:                     <td rowspan="3">A</td>
 1009:                     <td rowspan="3">B</td>
 1010:                 </tr>
 1011:             </table>
 1012:         """
 1013:             ),
 1014:             header=0,
 1015:         )[0]
 1016: 
 1017:         expected = DataFrame(data=[["A", "B"], ["A", "B"]], columns=["A", "B"])
 1018: 
 1019:         tm.assert_frame_equal(result, expected)
 1020: 
 1021:     def test_header_inferred_from_rows_with_only_th(self, flavor_read_html):
 1022:         # GH17054
 1023:         result = flavor_read_html(
 1024:             StringIO(
 1025:                 """
 1026:             <table>
 1027:                 <tr>
 1028:                     <th>A</th>
 1029:                     <th>B</th>
 1030:                 </tr>
 1031:                 <tr>
 1032:                     <th>a</th>
 1033:                     <th>b</th>
 1034:                 </tr>
 1035:                 <tr>
 1036:                     <td>1</td>
 1037:                     <td>2</td>
 1038:                 </tr>
 1039:             </table>
 1040:         """
 1041:             )
 1042:         )[0]
 1043: 
 1044:         columns = MultiIndex(levels=[["A", "B"], ["a", "b"]], codes=[[0, 1], [0, 1]])
 1045:         expected = DataFrame(data=[[1, 2]], columns=columns)
 1046: 
 1047:         tm.assert_frame_equal(result, expected)
 1048: 
 1049:     def test_parse_dates_list(self, flavor_read_html):
 1050:         df = DataFrame({"date": date_range("1/1/2001", periods=10)})
 1051:         expected = df.to_html()
 1052:         res = flavor_read_html(StringIO(expected), parse_dates=[1], index_col=0)
 1053:         tm.assert_frame_equal(df, res[0])
 1054:         res = flavor_read_html(StringIO(expected), parse_dates=["date"], index_col=0)
 1055:         tm.assert_frame_equal(df, res[0])
 1056: 
 1057:     def test_parse_dates_combine(self, flavor_read_html):
 1058:         raw_dates = Series(date_range("1/1/2001", periods=10))
 1059:         df = DataFrame(
 1060:             {
 1061:                 "date": raw_dates.map(lambda x: str(x.date())),
 1062:                 "time": raw_dates.map(lambda x: str(x.time())),
 1063:             }
 1064:         )
 1065:         res = flavor_read_html(
 1066:             StringIO(df.to_html()), parse_dates={"datetime": [1, 2]}, index_col=1
 1067:         )
 1068:         newdf = DataFrame({"datetime": raw_dates})
 1069:         tm.assert_frame_equal(newdf, res[0])
 1070: 
 1071:     def test_wikipedia_states_table(self, datapath, flavor_read_html):
 1072:         data = datapath("io", "data", "html", "wikipedia_states.html")
 1073:         assert os.path.isfile(data), f"{repr(data)} is not a file"
 1074:         assert os.path.getsize(data), f"{repr(data)} is an empty file"
 1075:         result = flavor_read_html(data, match="Arizona", header=1)[0]
 1076:         assert result.shape == (60, 12)
 1077:         assert "Unnamed" in result.columns[-1]
 1078:         assert result["sq mi"].dtype == np.dtype("float64")
 1079:         assert np.allclose(result.loc[0, "sq mi"], 665384.04)
 1080: 
 1081:     def test_wikipedia_states_multiindex(self, datapath, flavor_read_html):
 1082:         data = datapath("io", "data", "html", "wikipedia_states.html")
 1083:         result = flavor_read_html(data, match="Arizona", index_col=0)[0]
 1084:         assert result.shape == (60, 11)
 1085:         assert "Unnamed" in result.columns[-1][1]
 1086:         assert result.columns.nlevels == 2
 1087:         assert np.allclose(result.loc["Alaska", ("Total area[2]", "sq mi")], 665384.04)
 1088: 
 1089:     def test_parser_error_on_empty_header_row(self, flavor_read_html):
 1090:         result = flavor_read_html(
 1091:             StringIO(
 1092:                 """
 1093:                 <table>
 1094:                     <thead>
 1095:                         <tr><th></th><th></tr>
 1096:                         <tr><th>A</th><th>B</th></tr>
 1097:                     </thead>
 1098:                     <tbody>
 1099:                         <tr><td>a</td><td>b</td></tr>
 1100:                     </tbody>
 1101:                 </table>
 1102:             """
 1103:             ),
 1104:             header=[0, 1],
 1105:         )
 1106:         expected = DataFrame(
 1107:             [["a", "b"]],
 1108:             columns=MultiIndex.from_tuples(
 1109:                 [("Unnamed: 0_level_0", "A"), ("Unnamed: 1_level_0", "B")]
 1110:             ),
 1111:         )
 1112:         tm.assert_frame_equal(result[0], expected)
 1113: 
 1114:     def test_decimal_rows(self, flavor_read_html):
 1115:         # GH 12907
 1116:         result = flavor_read_html(
 1117:             StringIO(
 1118:                 """<html>
 1119:             <body>
 1120:              <table>
 1121:                 <thead>
 1122:                     <tr>
 1123:                         <th>Header</th>
 1124:                     </tr>
 1125:                 </thead>
 1126:                 <tbody>
 1127:                     <tr>
 1128:                         <td>1100#101</td>
 1129:                     </tr>
 1130:                 </tbody>
 1131:             </table>
 1132:             </body>
 1133:         </html>"""
 1134:             ),
 1135:             decimal="#",
 1136:         )[0]
 1137: 
 1138:         expected = DataFrame(data={"Header": 1100.101}, index=[0])
 1139: 
 1140:         assert result["Header"].dtype == np.dtype("float64")
 1141:         tm.assert_frame_equal(result, expected)
 1142: 
 1143:     @pytest.mark.parametrize("arg", [True, False])
 1144:     def test_bool_header_arg(self, spam_data, arg, flavor_read_html):
 1145:         # GH 6114
 1146:         msg = re.escape(
 1147:             "Passing a bool to header is invalid. Use header=None for no header or "
 1148:             "header=int or list-like of ints to specify the row(s) making up the "
 1149:             "column names"
 1150:         )
 1151:         with pytest.raises(TypeError, match=msg):
 1152:             flavor_read_html(spam_data, header=arg)
 1153: 
 1154:     def test_converters(self, flavor_read_html):
 1155:         # GH 13461
 1156:         result = flavor_read_html(
 1157:             StringIO(
 1158:                 """<table>
 1159:                  <thead>
 1160:                    <tr>
 1161:                      <th>a</th>
 1162:                     </tr>
 1163:                  </thead>
 1164:                  <tbody>
 1165:                    <tr>
 1166:                      <td> 0.763</td>
 1167:                    </tr>
 1168:                    <tr>
 1169:                      <td> 0.244</td>
 1170:                    </tr>
 1171:                  </tbody>
 1172:                </table>"""
 1173:             ),
 1174:             converters={"a": str},
 1175:         )[0]
 1176: 
 1177:         expected = DataFrame({"a": ["0.763", "0.244"]})
 1178: 
 1179:         tm.assert_frame_equal(result, expected)
 1180: 
 1181:     def test_na_values(self, flavor_read_html):
 1182:         # GH 13461
 1183:         result = flavor_read_html(
 1184:             StringIO(
 1185:                 """<table>
 1186:                  <thead>
 1187:                    <tr>
 1188:                      <th>a</th>
 1189:                    </tr>
 1190:                  </thead>
 1191:                  <tbody>
 1192:                    <tr>
 1193:                      <td> 0.763</td>
 1194:                    </tr>
 1195:                    <tr>
 1196:                      <td> 0.244</td>
 1197:                    </tr>
 1198:                  </tbody>
 1199:                </table>"""
 1200:             ),
 1201:             na_values=[0.244],
 1202:         )[0]
 1203: 
 1204:         expected = DataFrame({"a": [0.763, np.nan]})
 1205: 
 1206:         tm.assert_frame_equal(result, expected)
 1207: 
 1208:     def test_keep_default_na(self, flavor_read_html):
 1209:         html_data = """<table>
 1210:                         <thead>
 1211:                             <tr>
 1212:                             <th>a</th>
 1213:                             </tr>
 1214:                         </thead>
 1215:                         <tbody>
 1216:                             <tr>
 1217:                             <td> N/A</td>
 1218:                             </tr>
 1219:                             <tr>
 1220:                             <td> NA</td>
 1221:                             </tr>
 1222:                         </tbody>
 1223:                     </table>"""
 1224: 
 1225:         expected_df = DataFrame({"a": ["N/A", "NA"]})
 1226:         html_df = flavor_read_html(StringIO(html_data), keep_default_na=False)[0]
 1227:         tm.assert_frame_equal(expected_df, html_df)
 1228: 
 1229:         expected_df = DataFrame({"a": [np.nan, np.nan]})
 1230:         html_df = flavor_read_html(StringIO(html_data), keep_default_na=True)[0]
 1231:         tm.assert_frame_equal(expected_df, html_df)
 1232: 
 1233:     def test_preserve_empty_rows(self, flavor_read_html):
 1234:         result = flavor_read_html(
 1235:             StringIO(
 1236:                 """
 1237:             <table>
 1238:                 <tr>
 1239:                     <th>A</th>
 1240:                     <th>B</th>
 1241:                 </tr>
 1242:                 <tr>
 1243:                     <td>a</td>
 1244:                     <td>b</td>
 1245:                 </tr>
 1246:                 <tr>
 1247:                     <td></td>
 1248:                     <td></td>
 1249:                 </tr>
 1250:             </table>
 1251:         """
 1252:             )
 1253:         )[0]
 1254: 
 1255:         expected = DataFrame(data=[["a", "b"], [np.nan, np.nan]], columns=["A", "B"])
 1256: 
 1257:         tm.assert_frame_equal(result, expected)
 1258: 
 1259:     def test_ignore_empty_rows_when_inferring_header(self, flavor_read_html):
 1260:         result = flavor_read_html(
 1261:             StringIO(
 1262:                 """
 1263:             <table>
 1264:                 <thead>
 1265:                     <tr><th></th><th></tr>
 1266:                     <tr><th>A</th><th>B</th></tr>
 1267:                     <tr><th>a</th><th>b</th></tr>
 1268:                 </thead>
 1269:                 <tbody>
 1270:                     <tr><td>1</td><td>2</td></tr>
 1271:                 </tbody>
 1272:             </table>
 1273:         """
 1274:             )
 1275:         )[0]
 1276: 
 1277:         columns = MultiIndex(levels=[["A", "B"], ["a", "b"]], codes=[[0, 1], [0, 1]])
 1278:         expected = DataFrame(data=[[1, 2]], columns=columns)
 1279: 
 1280:         tm.assert_frame_equal(result, expected)
 1281: 
 1282:     def test_multiple_header_rows(self, flavor_read_html):
 1283:         # Issue #13434
 1284:         expected_df = DataFrame(
 1285:             data=[("Hillary", 68, "D"), ("Bernie", 74, "D"), ("Donald", 69, "R")]
 1286:         )
 1287:         expected_df.columns = [
 1288:             ["Unnamed: 0_level_0", "Age", "Party"],
 1289:             ["Name", "Unnamed: 1_level_1", "Unnamed: 2_level_1"],
 1290:         ]
 1291:         html = expected_df.to_html(index=False)
 1292:         html_df = flavor_read_html(StringIO(html))[0]
 1293:         tm.assert_frame_equal(expected_df, html_df)
 1294: 
 1295:     def test_works_on_valid_markup(self, datapath, flavor_read_html):
 1296:         filename = datapath("io", "data", "html", "valid_markup.html")
 1297:         dfs = flavor_read_html(filename, index_col=0)
 1298:         assert isinstance(dfs, list)
 1299:         assert isinstance(dfs[0], DataFrame)
 1300: 
 1301:     @pytest.mark.slow
 1302:     def test_fallback_success(self, datapath, flavor_read_html):
 1303:         banklist_data = datapath("io", "data", "html", "banklist.html")
 1304: 
 1305:         flavor_read_html(banklist_data, match=".*Water.*", flavor=["lxml", "html5lib"])
 1306: 
 1307:     def test_to_html_timestamp(self):
 1308:         rng = date_range("2000-01-01", periods=10)
 1309:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)), index=rng)
 1310: 
 1311:         result = df.to_html()
 1312:         assert "2000-01-01" in result
 1313: 
 1314:     def test_to_html_borderless(self):
 1315:         df = DataFrame([{"A": 1, "B": 2}])
 1316:         out_border_default = df.to_html()
 1317:         out_border_true = df.to_html(border=True)
 1318:         out_border_explicit_default = df.to_html(border=1)
 1319:         out_border_nondefault = df.to_html(border=2)
 1320:         out_border_zero = df.to_html(border=0)
 1321: 
 1322:         out_border_false = df.to_html(border=False)
 1323: 
 1324:         assert ' border="1"' in out_border_default
 1325:         assert out_border_true == out_border_default
 1326:         assert out_border_default == out_border_explicit_default
 1327:         assert out_border_default != out_border_nondefault
 1328:         assert ' border="2"' in out_border_nondefault
 1329:         assert ' border="0"' not in out_border_zero
 1330:         assert " border" not in out_border_false
 1331:         assert out_border_zero == out_border_false
 1332: 
 1333:     @pytest.mark.parametrize(
 1334:         "displayed_only,exp0,exp1",
 1335:         [
 1336:             (True, DataFrame(["foo"]), None),
 1337:             (False, DataFrame(["foo  bar  baz  qux"]), DataFrame(["foo"])),
 1338:         ],
 1339:     )
 1340:     def test_displayed_only(self, displayed_only, exp0, exp1, flavor_read_html):
 1341:         # GH 20027
 1342:         data = """<html>
 1343:           <body>
 1344:             <table>
 1345:               <tr>
 1346:                 <td>
 1347:                   foo
 1348:                   <span style="display:none;text-align:center">bar</span>
 1349:                   <span style="display:none">baz</span>
 1350:                   <span style="display: none">qux</span>
 1351:                 </td>
 1352:               </tr>
 1353:             </table>
 1354:             <table style="display: none">
 1355:               <tr>
 1356:                 <td>foo</td>
 1357:               </tr>
 1358:             </table>
 1359:           </body>
 1360:         </html>"""
 1361: 
 1362:         dfs = flavor_read_html(StringIO(data), displayed_only=displayed_only)
 1363:         tm.assert_frame_equal(dfs[0], exp0)
 1364: 
 1365:         if exp1 is not None:
 1366:             tm.assert_frame_equal(dfs[1], exp1)
 1367:         else:
 1368:             assert len(dfs) == 1  # Should not parse hidden table
 1369: 
 1370:     @pytest.mark.parametrize("displayed_only", [True, False])
 1371:     def test_displayed_only_with_many_elements(self, displayed_only, flavor_read_html):
 1372:         html_table = """
 1373:         <table>
 1374:             <tr>
 1375:                 <th>A</th>
 1376:                 <th>B</th>
 1377:             </tr>
 1378:             <tr>
 1379:                 <td>1</td>
 1380:                 <td>2</td>
 1381:             </tr>
 1382:             <tr>
 1383:                 <td><span style="display:none"></span>4</td>
 1384:                 <td>5</td>
 1385:             </tr>
 1386:         </table>
 1387:         """
 1388:         result = flavor_read_html(StringIO(html_table), displayed_only=displayed_only)[
 1389:             0
 1390:         ]
 1391:         expected = DataFrame({"A": [1, 4], "B": [2, 5]})
 1392:         tm.assert_frame_equal(result, expected)
 1393: 
 1394:     @pytest.mark.filterwarnings(
 1395:         "ignore:You provided Unicode markup but also provided a value for "
 1396:         "from_encoding.*:UserWarning"
 1397:     )
 1398:     def test_encode(self, html_encoding_file, flavor_read_html):
 1399:         base_path = os.path.basename(html_encoding_file)
 1400:         root = os.path.splitext(base_path)[0]
 1401:         _, encoding = root.split("_")
 1402: 
 1403:         try:
 1404:             with open(html_encoding_file, "rb") as fobj:
 1405:                 from_string = flavor_read_html(
 1406:                     fobj.read(), encoding=encoding, index_col=0
 1407:                 ).pop()
 1408: 
 1409:             with open(html_encoding_file, "rb") as fobj:
 1410:                 from_file_like = flavor_read_html(
 1411:                     BytesIO(fobj.read()), encoding=encoding, index_col=0
 1412:                 ).pop()
 1413: 
 1414:             from_filename = flavor_read_html(
 1415:                 html_encoding_file, encoding=encoding, index_col=0
 1416:             ).pop()
 1417:             tm.assert_frame_equal(from_string, from_file_like)
 1418:             tm.assert_frame_equal(from_string, from_filename)
 1419:         except Exception:
 1420:             # seems utf-16/32 fail on windows
 1421:             if is_platform_windows():
 1422:                 if "16" in encoding or "32" in encoding:
 1423:                     pytest.skip()
 1424:             raise
 1425: 
 1426:     def test_parse_failure_unseekable(self, flavor_read_html):
 1427:         # Issue #17975
 1428: 
 1429:         if flavor_read_html.keywords.get("flavor") == "lxml":
 1430:             pytest.skip("Not applicable for lxml")
 1431: 
 1432:         class UnseekableStringIO(StringIO):
 1433:             def seekable(self):
 1434:                 return False
 1435: 
 1436:         bad = UnseekableStringIO(
 1437:             """
 1438:             <table><tr><td>spam<foobr />eggs</td></tr></table>"""
 1439:         )
 1440: 
 1441:         assert flavor_read_html(bad)
 1442: 
 1443:         with pytest.raises(ValueError, match="passed a non-rewindable file object"):
 1444:             flavor_read_html(bad)
 1445: 
 1446:     def test_parse_failure_rewinds(self, flavor_read_html):
 1447:         # Issue #17975
 1448: 
 1449:         class MockFile:
 1450:             def __init__(self, data) -> None:
 1451:                 self.data = data
 1452:                 self.at_end = False
 1453: 
 1454:             def read(self, size=None):
 1455:                 data = "" if self.at_end else self.data
 1456:                 self.at_end = True
 1457:                 return data
 1458: 
 1459:             def seek(self, offset):
 1460:                 self.at_end = False
 1461: 
 1462:             def seekable(self):
 1463:                 return True
 1464: 
 1465:             # GH 49036 pylint checks for presence of __next__ for iterators
 1466:             def __next__(self):
 1467:                 ...
 1468: 
 1469:             def __iter__(self) -> Iterator:
 1470:                 # `is_file_like` depends on the presence of
 1471:                 # the __iter__ attribute.
 1472:                 return self
 1473: 
 1474:         good = MockFile("<table><tr><td>spam<br />eggs</td></tr></table>")
 1475:         bad = MockFile("<table><tr><td>spam<foobr />eggs</td></tr></table>")
 1476: 
 1477:         assert flavor_read_html(good)
 1478:         assert flavor_read_html(bad)
 1479: 
 1480:     @pytest.mark.slow
 1481:     @pytest.mark.single_cpu
 1482:     def test_importcheck_thread_safety(self, datapath, flavor_read_html):
 1483:         # see gh-16928
 1484: 
 1485:         class ErrorThread(threading.Thread):
 1486:             def run(self):
 1487:                 try:
 1488:                     super().run()
 1489:                 except Exception as err:
 1490:                     self.err = err
 1491:                 else:
 1492:                     self.err = None
 1493: 
 1494:         filename = datapath("io", "data", "html", "valid_markup.html")
 1495:         helper_thread1 = ErrorThread(target=flavor_read_html, args=(filename,))
 1496:         helper_thread2 = ErrorThread(target=flavor_read_html, args=(filename,))
 1497: 
 1498:         helper_thread1.start()
 1499:         helper_thread2.start()
 1500: 
 1501:         while helper_thread1.is_alive() or helper_thread2.is_alive():
 1502:             pass
 1503:         assert None is helper_thread1.err is helper_thread2.err
 1504: 
 1505:     def test_parse_path_object(self, datapath, flavor_read_html):
 1506:         # GH 37705
 1507:         file_path_string = datapath("io", "data", "html", "spam.html")
 1508:         file_path = Path(file_path_string)
 1509:         df1 = flavor_read_html(file_path_string)[0]
 1510:         df2 = flavor_read_html(file_path)[0]
 1511:         tm.assert_frame_equal(df1, df2)
 1512: 
 1513:     def test_parse_br_as_space(self, flavor_read_html):
 1514:         # GH 29528: pd.read_html() convert <br> to space
 1515:         result = flavor_read_html(
 1516:             StringIO(
 1517:                 """
 1518:             <table>
 1519:                 <tr>
 1520:                     <th>A</th>
 1521:                 </tr>
 1522:                 <tr>
 1523:                     <td>word1<br>word2</td>
 1524:                 </tr>
 1525:             </table>
 1526:         """
 1527:             )
 1528:         )[0]
 1529: 
 1530:         expected = DataFrame(data=[["word1 word2"]], columns=["A"])
 1531: 
 1532:         tm.assert_frame_equal(result, expected)
 1533: 
 1534:     @pytest.mark.parametrize("arg", ["all", "body", "header", "footer"])
 1535:     def test_extract_links(self, arg, flavor_read_html):
 1536:         gh_13141_data = """
 1537:           <table>
 1538:             <tr>
 1539:               <th>HTTP</th>
 1540:               <th>FTP</th>
 1541:               <th><a href="https://en.wiktionary.org/wiki/linkless">Linkless</a></th>
 1542:             </tr>
 1543:             <tr>
 1544:               <td><a href="https://en.wikipedia.org/">Wikipedia</a></td>
 1545:               <td>SURROUNDING <a href="ftp://ftp.us.debian.org/">Debian</a> TEXT</td>
 1546:               <td>Linkless</td>
 1547:             </tr>
 1548:             <tfoot>
 1549:               <tr>
 1550:                 <td><a href="https://en.wikipedia.org/wiki/Page_footer">Footer</a></td>
 1551:                 <td>
 1552:                   Multiple <a href="1">links:</a> <a href="2">Only first captured.</a>
 1553:                 </td>
 1554:               </tr>
 1555:             </tfoot>
 1556:           </table>
 1557:           """
 1558: 
 1559:         gh_13141_expected = {
 1560:             "head_ignore": ["HTTP", "FTP", "Linkless"],
 1561:             "head_extract": [
 1562:                 ("HTTP", None),
 1563:                 ("FTP", None),
 1564:                 ("Linkless", "https://en.wiktionary.org/wiki/linkless"),
 1565:             ],
 1566:             "body_ignore": ["Wikipedia", "SURROUNDING Debian TEXT", "Linkless"],
 1567:             "body_extract": [
 1568:                 ("Wikipedia", "https://en.wikipedia.org/"),
 1569:                 ("SURROUNDING Debian TEXT", "ftp://ftp.us.debian.org/"),
 1570:                 ("Linkless", None),
 1571:             ],
 1572:             "footer_ignore": [
 1573:                 "Footer",
 1574:                 "Multiple links: Only first captured.",
 1575:                 None,
 1576:             ],
 1577:             "footer_extract": [
 1578:                 ("Footer", "https://en.wikipedia.org/wiki/Page_footer"),
 1579:                 ("Multiple links: Only first captured.", "1"),
 1580:                 None,
 1581:             ],
 1582:         }
 1583: 
 1584:         data_exp = gh_13141_expected["body_ignore"]
 1585:         foot_exp = gh_13141_expected["footer_ignore"]
 1586:         head_exp = gh_13141_expected["head_ignore"]
 1587:         if arg == "all":
 1588:             data_exp = gh_13141_expected["body_extract"]
 1589:             foot_exp = gh_13141_expected["footer_extract"]
 1590:             head_exp = gh_13141_expected["head_extract"]
 1591:         elif arg == "body":
 1592:             data_exp = gh_13141_expected["body_extract"]
 1593:         elif arg == "footer":
 1594:             foot_exp = gh_13141_expected["footer_extract"]
 1595:         elif arg == "header":
 1596:             head_exp = gh_13141_expected["head_extract"]
 1597: 
 1598:         result = flavor_read_html(StringIO(gh_13141_data), extract_links=arg)[0]
 1599:         expected = DataFrame([data_exp, foot_exp], columns=head_exp)
 1600:         expected = expected.fillna(np.nan)
 1601:         tm.assert_frame_equal(result, expected)
 1602: 
 1603:     def test_extract_links_bad(self, spam_data):
 1604:         msg = (
 1605:             "`extract_links` must be one of "
 1606:             '{None, "header", "footer", "body", "all"}, got "incorrect"'
 1607:         )
 1608:         with pytest.raises(ValueError, match=msg):
 1609:             read_html(spam_data, extract_links="incorrect")
 1610: 
 1611:     def test_extract_links_all_no_header(self, flavor_read_html):
 1612:         # GH 48316
 1613:         data = """
 1614:         <table>
 1615:           <tr>
 1616:             <td>
 1617:               <a href='https://google.com'>Google.com</a>
 1618:             </td>
 1619:           </tr>
 1620:         </table>
 1621:         """
 1622:         result = flavor_read_html(StringIO(data), extract_links="all")[0]
 1623:         expected = DataFrame([[("Google.com", "https://google.com")]])
 1624:         tm.assert_frame_equal(result, expected)
 1625: 
 1626:     def test_invalid_dtype_backend(self):
 1627:         msg = (
 1628:             "dtype_backend numpy is invalid, only 'numpy_nullable' and "
 1629:             "'pyarrow' are allowed."
 1630:         )
 1631:         with pytest.raises(ValueError, match=msg):
 1632:             read_html("test", dtype_backend="numpy")
 1633: 
 1634:     def test_style_tag(self, flavor_read_html):
 1635:         # GH 48316
 1636:         data = """
 1637:         <table>
 1638:             <tr>
 1639:                 <th>
 1640:                     <style>.style</style>
 1641:                     A
 1642:                     </th>
 1643:                 <th>B</th>
 1644:             </tr>
 1645:             <tr>
 1646:                 <td>A1</td>
 1647:                 <td>B1</td>
 1648:             </tr>
 1649:             <tr>
 1650:                 <td>A2</td>
 1651:                 <td>B2</td>
 1652:             </tr>
 1653:         </table>
 1654:         """
 1655:         result = flavor_read_html(StringIO(data))[0]
 1656:         expected = DataFrame(data=[["A1", "B1"], ["A2", "B2"]], columns=["A", "B"])
 1657:         tm.assert_frame_equal(result, expected)
