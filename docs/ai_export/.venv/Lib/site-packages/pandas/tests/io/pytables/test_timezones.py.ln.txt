    1: from datetime import (
    2:     date,
    3:     timedelta,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas._libs.tslibs.timezones import maybe_get_tz
   10: import pandas.util._test_decorators as td
   11: 
   12: import pandas as pd
   13: from pandas import (
   14:     DataFrame,
   15:     DatetimeIndex,
   16:     Series,
   17:     Timestamp,
   18:     date_range,
   19: )
   20: import pandas._testing as tm
   21: from pandas.tests.io.pytables.common import (
   22:     _maybe_remove,
   23:     ensure_clean_store,
   24: )
   25: 
   26: 
   27: def _compare_with_tz(a, b):
   28:     tm.assert_frame_equal(a, b)
   29: 
   30:     # compare the zones on each element
   31:     for c in a.columns:
   32:         for i in a.index:
   33:             a_e = a.loc[i, c]
   34:             b_e = b.loc[i, c]
   35:             if not (a_e == b_e and a_e.tz == b_e.tz):
   36:                 raise AssertionError(f"invalid tz comparison [{a_e}] [{b_e}]")
   37: 
   38: 
   39: # use maybe_get_tz instead of dateutil.tz.gettz to handle the windows
   40: # filename issues.
   41: gettz_dateutil = lambda x: maybe_get_tz("dateutil/" + x)
   42: gettz_pytz = lambda x: x
   43: 
   44: 
   45: @pytest.mark.parametrize("gettz", [gettz_dateutil, gettz_pytz])
   46: def test_append_with_timezones(setup_path, gettz):
   47:     # as columns
   48: 
   49:     # Single-tzinfo, no DST transition
   50:     df_est = DataFrame(
   51:         {
   52:             "A": [
   53:                 Timestamp("20130102 2:00:00", tz=gettz("US/Eastern")).as_unit("ns")
   54:                 + timedelta(hours=1) * i
   55:                 for i in range(5)
   56:             ]
   57:         }
   58:     )
   59: 
   60:     # frame with all columns having same tzinfo, but different sides
   61:     #  of DST transition
   62:     df_crosses_dst = DataFrame(
   63:         {
   64:             "A": Timestamp("20130102", tz=gettz("US/Eastern")).as_unit("ns"),
   65:             "B": Timestamp("20130603", tz=gettz("US/Eastern")).as_unit("ns"),
   66:         },
   67:         index=range(5),
   68:     )
   69: 
   70:     df_mixed_tz = DataFrame(
   71:         {
   72:             "A": Timestamp("20130102", tz=gettz("US/Eastern")).as_unit("ns"),
   73:             "B": Timestamp("20130102", tz=gettz("EET")).as_unit("ns"),
   74:         },
   75:         index=range(5),
   76:     )
   77: 
   78:     df_different_tz = DataFrame(
   79:         {
   80:             "A": Timestamp("20130102", tz=gettz("US/Eastern")).as_unit("ns"),
   81:             "B": Timestamp("20130102", tz=gettz("CET")).as_unit("ns"),
   82:         },
   83:         index=range(5),
   84:     )
   85: 
   86:     with ensure_clean_store(setup_path) as store:
   87:         _maybe_remove(store, "df_tz")
   88:         store.append("df_tz", df_est, data_columns=["A"])
   89:         result = store["df_tz"]
   90:         _compare_with_tz(result, df_est)
   91:         tm.assert_frame_equal(result, df_est)
   92: 
   93:         # select with tz aware
   94:         expected = df_est[df_est.A >= df_est.A[3]]
   95:         result = store.select("df_tz", where="A>=df_est.A[3]")
   96:         _compare_with_tz(result, expected)
   97: 
   98:         # ensure we include dates in DST and STD time here.
   99:         _maybe_remove(store, "df_tz")
  100:         store.append("df_tz", df_crosses_dst)
  101:         result = store["df_tz"]
  102:         _compare_with_tz(result, df_crosses_dst)
  103:         tm.assert_frame_equal(result, df_crosses_dst)
  104: 
  105:         msg = (
  106:             r"invalid info for \[values_block_1\] for \[tz\], "
  107:             r"existing_value \[(dateutil/.*)?(US/Eastern|America/New_York)\] "
  108:             r"conflicts with new value \[(dateutil/.*)?EET\]"
  109:         )
  110:         with pytest.raises(ValueError, match=msg):
  111:             store.append("df_tz", df_mixed_tz)
  112: 
  113:         # this is ok
  114:         _maybe_remove(store, "df_tz")
  115:         store.append("df_tz", df_mixed_tz, data_columns=["A", "B"])
  116:         result = store["df_tz"]
  117:         _compare_with_tz(result, df_mixed_tz)
  118:         tm.assert_frame_equal(result, df_mixed_tz)
  119: 
  120:         # can't append with diff timezone
  121:         msg = (
  122:             r"invalid info for \[B\] for \[tz\], "
  123:             r"existing_value \[(dateutil/.*)?EET\] "
  124:             r"conflicts with new value \[(dateutil/.*)?CET\]"
  125:         )
  126:         with pytest.raises(ValueError, match=msg):
  127:             store.append("df_tz", df_different_tz)
  128: 
  129: 
  130: @pytest.mark.parametrize("gettz", [gettz_dateutil, gettz_pytz])
  131: def test_append_with_timezones_as_index(setup_path, gettz):
  132:     # GH#4098 example
  133: 
  134:     dti = date_range("2000-1-1", periods=3, freq="h", tz=gettz("US/Eastern"))
  135:     dti = dti._with_freq(None)  # freq doesn't round-trip
  136: 
  137:     df = DataFrame({"A": Series(range(3), index=dti)})
  138: 
  139:     with ensure_clean_store(setup_path) as store:
  140:         _maybe_remove(store, "df")
  141:         store.put("df", df)
  142:         result = store.select("df")
  143:         tm.assert_frame_equal(result, df)
  144: 
  145:         _maybe_remove(store, "df")
  146:         store.append("df", df)
  147:         result = store.select("df")
  148:         tm.assert_frame_equal(result, df)
  149: 
  150: 
  151: def test_roundtrip_tz_aware_index(setup_path, unit):
  152:     # GH 17618
  153:     ts = Timestamp("2000-01-01 01:00:00", tz="US/Eastern")
  154:     dti = DatetimeIndex([ts]).as_unit(unit)
  155:     df = DataFrame(data=[0], index=dti)
  156: 
  157:     with ensure_clean_store(setup_path) as store:
  158:         store.put("frame", df, format="fixed")
  159:         recons = store["frame"]
  160:         tm.assert_frame_equal(recons, df)
  161: 
  162:     value = recons.index[0]._value
  163:     denom = {"ns": 1, "us": 1000, "ms": 10**6, "s": 10**9}[unit]
  164:     assert value == 946706400000000000 // denom
  165: 
  166: 
  167: def test_store_index_name_with_tz(setup_path):
  168:     # GH 13884
  169:     df = DataFrame({"A": [1, 2]})
  170:     df.index = DatetimeIndex([1234567890123456787, 1234567890123456788])
  171:     df.index = df.index.tz_localize("UTC")
  172:     df.index.name = "foo"
  173: 
  174:     with ensure_clean_store(setup_path) as store:
  175:         store.put("frame", df, format="table")
  176:         recons = store["frame"]
  177:         tm.assert_frame_equal(recons, df)
  178: 
  179: 
  180: def test_tseries_select_index_column(setup_path):
  181:     # GH7777
  182:     # selecting a UTC datetimeindex column did
  183:     # not preserve UTC tzinfo set before storing
  184: 
  185:     # check that no tz still works
  186:     rng = date_range("1/1/2000", "1/30/2000")
  187:     frame = DataFrame(
  188:         np.random.default_rng(2).standard_normal((len(rng), 4)), index=rng
  189:     )
  190: 
  191:     with ensure_clean_store(setup_path) as store:
  192:         store.append("frame", frame)
  193:         result = store.select_column("frame", "index")
  194:         assert rng.tz == DatetimeIndex(result.values).tz
  195: 
  196:     # check utc
  197:     rng = date_range("1/1/2000", "1/30/2000", tz="UTC")
  198:     frame = DataFrame(
  199:         np.random.default_rng(2).standard_normal((len(rng), 4)), index=rng
  200:     )
  201: 
  202:     with ensure_clean_store(setup_path) as store:
  203:         store.append("frame", frame)
  204:         result = store.select_column("frame", "index")
  205:         assert rng.tz == result.dt.tz
  206: 
  207:     # double check non-utc
  208:     rng = date_range("1/1/2000", "1/30/2000", tz="US/Eastern")
  209:     frame = DataFrame(
  210:         np.random.default_rng(2).standard_normal((len(rng), 4)), index=rng
  211:     )
  212: 
  213:     with ensure_clean_store(setup_path) as store:
  214:         store.append("frame", frame)
  215:         result = store.select_column("frame", "index")
  216:         assert rng.tz == result.dt.tz
  217: 
  218: 
  219: def test_timezones_fixed_format_frame_non_empty(setup_path):
  220:     with ensure_clean_store(setup_path) as store:
  221:         # index
  222:         rng = date_range("1/1/2000", "1/30/2000", tz="US/Eastern")
  223:         rng = rng._with_freq(None)  # freq doesn't round-trip
  224:         df = DataFrame(
  225:             np.random.default_rng(2).standard_normal((len(rng), 4)), index=rng
  226:         )
  227:         store["df"] = df
  228:         result = store["df"]
  229:         tm.assert_frame_equal(result, df)
  230: 
  231:         # as data
  232:         # GH11411
  233:         _maybe_remove(store, "df")
  234:         df = DataFrame(
  235:             {
  236:                 "A": rng,
  237:                 "B": rng.tz_convert("UTC").tz_localize(None),
  238:                 "C": rng.tz_convert("CET"),
  239:                 "D": range(len(rng)),
  240:             },
  241:             index=rng,
  242:         )
  243:         store["df"] = df
  244:         result = store["df"]
  245:         tm.assert_frame_equal(result, df)
  246: 
  247: 
  248: def test_timezones_fixed_format_empty(setup_path, tz_aware_fixture, frame_or_series):
  249:     # GH 20594
  250: 
  251:     dtype = pd.DatetimeTZDtype(tz=tz_aware_fixture)
  252: 
  253:     obj = Series(dtype=dtype, name="A")
  254:     if frame_or_series is DataFrame:
  255:         obj = obj.to_frame()
  256: 
  257:     with ensure_clean_store(setup_path) as store:
  258:         store["obj"] = obj
  259:         result = store["obj"]
  260:         tm.assert_equal(result, obj)
  261: 
  262: 
  263: def test_timezones_fixed_format_series_nonempty(setup_path, tz_aware_fixture):
  264:     # GH 20594
  265: 
  266:     dtype = pd.DatetimeTZDtype(tz=tz_aware_fixture)
  267: 
  268:     with ensure_clean_store(setup_path) as store:
  269:         s = Series([0], dtype=dtype)
  270:         store["s"] = s
  271:         result = store["s"]
  272:         tm.assert_series_equal(result, s)
  273: 
  274: 
  275: def test_fixed_offset_tz(setup_path):
  276:     rng = date_range("1/1/2000 00:00:00-07:00", "1/30/2000 00:00:00-07:00")
  277:     frame = DataFrame(
  278:         np.random.default_rng(2).standard_normal((len(rng), 4)), index=rng
  279:     )
  280: 
  281:     with ensure_clean_store(setup_path) as store:
  282:         store["frame"] = frame
  283:         recons = store["frame"]
  284:         tm.assert_index_equal(recons.index, rng)
  285:         assert rng.tz == recons.index.tz
  286: 
  287: 
  288: @td.skip_if_windows
  289: def test_store_timezone(setup_path):
  290:     # GH2852
  291:     # issue storing datetime.date with a timezone as it resets when read
  292:     # back in a new timezone
  293: 
  294:     # original method
  295:     with ensure_clean_store(setup_path) as store:
  296:         today = date(2013, 9, 10)
  297:         df = DataFrame([1, 2, 3], index=[today, today, today])
  298:         store["obj1"] = df
  299:         result = store["obj1"]
  300:         tm.assert_frame_equal(result, df)
  301: 
  302:     # with tz setting
  303:     with ensure_clean_store(setup_path) as store:
  304:         with tm.set_timezone("EST5EDT"):
  305:             today = date(2013, 9, 10)
  306:             df = DataFrame([1, 2, 3], index=[today, today, today])
  307:             store["obj1"] = df
  308: 
  309:         with tm.set_timezone("CST6CDT"):
  310:             result = store["obj1"]
  311: 
  312:         tm.assert_frame_equal(result, df)
  313: 
  314: 
  315: def test_legacy_datetimetz_object(datapath):
  316:     # legacy from < 0.17.0
  317:     # 8260
  318:     expected = DataFrame(
  319:         {
  320:             "A": Timestamp("20130102", tz="US/Eastern").as_unit("ns"),
  321:             "B": Timestamp("20130603", tz="CET").as_unit("ns"),
  322:         },
  323:         index=range(5),
  324:     )
  325:     with ensure_clean_store(
  326:         datapath("io", "data", "legacy_hdf", "datetimetz_object.h5"), mode="r"
  327:     ) as store:
  328:         result = store["df"]
  329:         tm.assert_frame_equal(result, expected)
  330: 
  331: 
  332: def test_dst_transitions(setup_path):
  333:     # make sure we are not failing on transitions
  334:     with ensure_clean_store(setup_path) as store:
  335:         times = date_range(
  336:             "2013-10-26 23:00",
  337:             "2013-10-27 01:00",
  338:             tz="Europe/London",
  339:             freq="h",
  340:             ambiguous="infer",
  341:         )
  342:         times = times._with_freq(None)  # freq doesn't round-trip
  343: 
  344:         for i in [times, times + pd.Timedelta("10min")]:
  345:             _maybe_remove(store, "df")
  346:             df = DataFrame({"A": range(len(i)), "B": i}, index=i)
  347:             store.append("df", df)
  348:             result = store.select("df")
  349:             tm.assert_frame_equal(result, df)
  350: 
  351: 
  352: def test_read_with_where_tz_aware_index(tmp_path, setup_path):
  353:     # GH 11926
  354:     periods = 10
  355:     dts = date_range("20151201", periods=periods, freq="D", tz="UTC")
  356:     mi = pd.MultiIndex.from_arrays([dts, range(periods)], names=["DATE", "NO"])
  357:     expected = DataFrame({"MYCOL": 0}, index=mi)
  358: 
  359:     key = "mykey"
  360:     path = tmp_path / setup_path
  361:     with pd.HDFStore(path) as store:
  362:         store.append(key, expected, format="table", append=True)
  363:     result = pd.read_hdf(path, key, where="DATE > 20151130")
  364:     tm.assert_frame_equal(result, expected)
  365: 
  366: 
  367: def test_py2_created_with_datetimez(datapath):
  368:     # The test HDF5 file was created in Python 2, but could not be read in
  369:     # Python 3.
  370:     #
  371:     # GH26443
  372:     index = DatetimeIndex(["2019-01-01T18:00"], dtype="M8[ns, America/New_York]")
  373:     expected = DataFrame({"data": 123}, index=index)
  374:     with ensure_clean_store(
  375:         datapath("io", "data", "legacy_hdf", "gh26443.h5"), mode="r"
  376:     ) as store:
  377:         result = store["key"]
  378:         tm.assert_frame_equal(result, expected)
