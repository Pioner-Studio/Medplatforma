    1: """Tests for Table Schema integration."""
    2: from collections import OrderedDict
    3: from io import StringIO
    4: import json
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas.core.dtypes.dtypes import (
   10:     CategoricalDtype,
   11:     DatetimeTZDtype,
   12:     PeriodDtype,
   13: )
   14: 
   15: import pandas as pd
   16: from pandas import DataFrame
   17: import pandas._testing as tm
   18: 
   19: from pandas.io.json._table_schema import (
   20:     as_json_table_type,
   21:     build_table_schema,
   22:     convert_json_field_to_pandas_type,
   23:     convert_pandas_type_to_json_field,
   24:     set_default_names,
   25: )
   26: 
   27: 
   28: @pytest.fixture
   29: def df_schema():
   30:     return DataFrame(
   31:         {
   32:             "A": [1, 2, 3, 4],
   33:             "B": ["a", "b", "c", "c"],
   34:             "C": pd.date_range("2016-01-01", freq="d", periods=4),
   35:             "D": pd.timedelta_range("1h", periods=4, freq="min"),
   36:         },
   37:         index=pd.Index(range(4), name="idx"),
   38:     )
   39: 
   40: 
   41: @pytest.fixture
   42: def df_table():
   43:     return DataFrame(
   44:         {
   45:             "A": [1, 2, 3, 4],
   46:             "B": ["a", "b", "c", "c"],
   47:             "C": pd.date_range("2016-01-01", freq="d", periods=4),
   48:             "D": pd.timedelta_range("1h", periods=4, freq="min"),
   49:             "E": pd.Series(pd.Categorical(["a", "b", "c", "c"])),
   50:             "F": pd.Series(pd.Categorical(["a", "b", "c", "c"], ordered=True)),
   51:             "G": [1.0, 2.0, 3, 4.0],
   52:             "H": pd.date_range("2016-01-01", freq="d", periods=4, tz="US/Central"),
   53:         },
   54:         index=pd.Index(range(4), name="idx"),
   55:     )
   56: 
   57: 
   58: class TestBuildSchema:
   59:     def test_build_table_schema(self, df_schema, using_infer_string):
   60:         result = build_table_schema(df_schema, version=False)
   61:         expected = {
   62:             "fields": [
   63:                 {"name": "idx", "type": "integer"},
   64:                 {"name": "A", "type": "integer"},
   65:                 {"name": "B", "type": "string"},
   66:                 {"name": "C", "type": "datetime"},
   67:                 {"name": "D", "type": "duration"},
   68:             ],
   69:             "primaryKey": ["idx"],
   70:         }
   71:         if using_infer_string:
   72:             expected["fields"][2] = {"name": "B", "type": "any", "extDtype": "string"}
   73:         assert result == expected
   74:         result = build_table_schema(df_schema)
   75:         assert "pandas_version" in result
   76: 
   77:     def test_series(self):
   78:         s = pd.Series([1, 2, 3], name="foo")
   79:         result = build_table_schema(s, version=False)
   80:         expected = {
   81:             "fields": [
   82:                 {"name": "index", "type": "integer"},
   83:                 {"name": "foo", "type": "integer"},
   84:             ],
   85:             "primaryKey": ["index"],
   86:         }
   87:         assert result == expected
   88:         result = build_table_schema(s)
   89:         assert "pandas_version" in result
   90: 
   91:     def test_series_unnamed(self):
   92:         result = build_table_schema(pd.Series([1, 2, 3]), version=False)
   93:         expected = {
   94:             "fields": [
   95:                 {"name": "index", "type": "integer"},
   96:                 {"name": "values", "type": "integer"},
   97:             ],
   98:             "primaryKey": ["index"],
   99:         }
  100:         assert result == expected
  101: 
  102:     def test_multiindex(self, df_schema, using_infer_string):
  103:         df = df_schema
  104:         idx = pd.MultiIndex.from_product([("a", "b"), (1, 2)])
  105:         df.index = idx
  106: 
  107:         result = build_table_schema(df, version=False)
  108:         expected = {
  109:             "fields": [
  110:                 {"name": "level_0", "type": "string"},
  111:                 {"name": "level_1", "type": "integer"},
  112:                 {"name": "A", "type": "integer"},
  113:                 {"name": "B", "type": "string"},
  114:                 {"name": "C", "type": "datetime"},
  115:                 {"name": "D", "type": "duration"},
  116:             ],
  117:             "primaryKey": ["level_0", "level_1"],
  118:         }
  119:         if using_infer_string:
  120:             expected["fields"][0] = {
  121:                 "name": "level_0",
  122:                 "type": "any",
  123:                 "extDtype": "string",
  124:             }
  125:             expected["fields"][3] = {"name": "B", "type": "any", "extDtype": "string"}
  126:         assert result == expected
  127: 
  128:         df.index.names = ["idx0", None]
  129:         expected["fields"][0]["name"] = "idx0"
  130:         expected["primaryKey"] = ["idx0", "level_1"]
  131:         result = build_table_schema(df, version=False)
  132:         assert result == expected
  133: 
  134: 
  135: class TestTableSchemaType:
  136:     @pytest.mark.parametrize("int_type", [int, np.int16, np.int32, np.int64])
  137:     def test_as_json_table_type_int_data(self, int_type):
  138:         int_data = [1, 2, 3]
  139:         assert as_json_table_type(np.array(int_data, dtype=int_type).dtype) == "integer"
  140: 
  141:     @pytest.mark.parametrize("float_type", [float, np.float16, np.float32, np.float64])
  142:     def test_as_json_table_type_float_data(self, float_type):
  143:         float_data = [1.0, 2.0, 3.0]
  144:         assert (
  145:             as_json_table_type(np.array(float_data, dtype=float_type).dtype) == "number"
  146:         )
  147: 
  148:     @pytest.mark.parametrize("bool_type", [bool, np.bool_])
  149:     def test_as_json_table_type_bool_data(self, bool_type):
  150:         bool_data = [True, False]
  151:         assert (
  152:             as_json_table_type(np.array(bool_data, dtype=bool_type).dtype) == "boolean"
  153:         )
  154: 
  155:     @pytest.mark.parametrize(
  156:         "date_data",
  157:         [
  158:             pd.to_datetime(["2016"]),
  159:             pd.to_datetime(["2016"], utc=True),
  160:             pd.Series(pd.to_datetime(["2016"])),
  161:             pd.Series(pd.to_datetime(["2016"], utc=True)),
  162:             pd.period_range("2016", freq="Y", periods=3),
  163:         ],
  164:     )
  165:     def test_as_json_table_type_date_data(self, date_data):
  166:         assert as_json_table_type(date_data.dtype) == "datetime"
  167: 
  168:     @pytest.mark.parametrize(
  169:         "str_data",
  170:         [pd.Series(["a", "b"], dtype=object), pd.Index(["a", "b"], dtype=object)],
  171:     )
  172:     def test_as_json_table_type_string_data(self, str_data):
  173:         assert as_json_table_type(str_data.dtype) == "string"
  174: 
  175:     @pytest.mark.parametrize(
  176:         "cat_data",
  177:         [
  178:             pd.Categorical(["a"]),
  179:             pd.Categorical([1]),
  180:             pd.Series(pd.Categorical([1])),
  181:             pd.CategoricalIndex([1]),
  182:             pd.Categorical([1]),
  183:         ],
  184:     )
  185:     def test_as_json_table_type_categorical_data(self, cat_data):
  186:         assert as_json_table_type(cat_data.dtype) == "any"
  187: 
  188:     # ------
  189:     # dtypes
  190:     # ------
  191:     @pytest.mark.parametrize("int_dtype", [int, np.int16, np.int32, np.int64])
  192:     def test_as_json_table_type_int_dtypes(self, int_dtype):
  193:         assert as_json_table_type(int_dtype) == "integer"
  194: 
  195:     @pytest.mark.parametrize("float_dtype", [float, np.float16, np.float32, np.float64])
  196:     def test_as_json_table_type_float_dtypes(self, float_dtype):
  197:         assert as_json_table_type(float_dtype) == "number"
  198: 
  199:     @pytest.mark.parametrize("bool_dtype", [bool, np.bool_])
  200:     def test_as_json_table_type_bool_dtypes(self, bool_dtype):
  201:         assert as_json_table_type(bool_dtype) == "boolean"
  202: 
  203:     @pytest.mark.parametrize(
  204:         "date_dtype",
  205:         [
  206:             np.dtype("<M8[ns]"),
  207:             PeriodDtype("D"),
  208:             DatetimeTZDtype("ns", "US/Central"),
  209:         ],
  210:     )
  211:     def test_as_json_table_type_date_dtypes(self, date_dtype):
  212:         # TODO: datedate.date? datetime.time?
  213:         assert as_json_table_type(date_dtype) == "datetime"
  214: 
  215:     @pytest.mark.parametrize("td_dtype", [np.dtype("<m8[ns]")])
  216:     def test_as_json_table_type_timedelta_dtypes(self, td_dtype):
  217:         assert as_json_table_type(td_dtype) == "duration"
  218: 
  219:     @pytest.mark.parametrize("str_dtype", [object])  # TODO(GH#14904) flesh out dtypes?
  220:     def test_as_json_table_type_string_dtypes(self, str_dtype):
  221:         assert as_json_table_type(str_dtype) == "string"
  222: 
  223:     def test_as_json_table_type_categorical_dtypes(self):
  224:         assert as_json_table_type(pd.Categorical(["a"]).dtype) == "any"
  225:         assert as_json_table_type(CategoricalDtype()) == "any"
  226: 
  227: 
  228: class TestTableOrient:
  229:     def test_build_series(self):
  230:         s = pd.Series([1, 2], name="a")
  231:         s.index.name = "id"
  232:         result = s.to_json(orient="table", date_format="iso")
  233:         result = json.loads(result, object_pairs_hook=OrderedDict)
  234: 
  235:         assert "pandas_version" in result["schema"]
  236:         result["schema"].pop("pandas_version")
  237: 
  238:         fields = [{"name": "id", "type": "integer"}, {"name": "a", "type": "integer"}]
  239: 
  240:         schema = {"fields": fields, "primaryKey": ["id"]}
  241: 
  242:         expected = OrderedDict(
  243:             [
  244:                 ("schema", schema),
  245:                 (
  246:                     "data",
  247:                     [
  248:                         OrderedDict([("id", 0), ("a", 1)]),
  249:                         OrderedDict([("id", 1), ("a", 2)]),
  250:                     ],
  251:                 ),
  252:             ]
  253:         )
  254: 
  255:         assert result == expected
  256: 
  257:     def test_read_json_from_to_json_results(self):
  258:         # GH32383
  259:         df = DataFrame(
  260:             {
  261:                 "_id": {"row_0": 0},
  262:                 "category": {"row_0": "Goods"},
  263:                 "recommender_id": {"row_0": 3},
  264:                 "recommender_name_jp": {"row_0": "жµ¦з”°"},
  265:                 "recommender_name_en": {"row_0": "Urata"},
  266:                 "name_jp": {"row_0": "еЌље¤љдєєеЅў(жќѕе°ѕеђ‰е°†гЃѕгЃ¤гЃЉ г‚€гЃ—гЃѕгЃ•)"},
  267:                 "name_en": {"row_0": "Hakata Dolls Matsuo"},
  268:             }
  269:         )
  270: 
  271:         result1 = pd.read_json(StringIO(df.to_json()))
  272:         result2 = DataFrame.from_dict(json.loads(df.to_json()))
  273:         tm.assert_frame_equal(result1, df)
  274:         tm.assert_frame_equal(result2, df)
  275: 
  276:     def test_to_json(self, df_table, using_infer_string):
  277:         df = df_table
  278:         df.index.name = "idx"
  279:         result = df.to_json(orient="table", date_format="iso")
  280:         result = json.loads(result, object_pairs_hook=OrderedDict)
  281: 
  282:         assert "pandas_version" in result["schema"]
  283:         result["schema"].pop("pandas_version")
  284: 
  285:         fields = [
  286:             {"name": "idx", "type": "integer"},
  287:             {"name": "A", "type": "integer"},
  288:             {"name": "B", "type": "string"},
  289:             {"name": "C", "type": "datetime"},
  290:             {"name": "D", "type": "duration"},
  291:             {
  292:                 "constraints": {"enum": ["a", "b", "c"]},
  293:                 "name": "E",
  294:                 "ordered": False,
  295:                 "type": "any",
  296:             },
  297:             {
  298:                 "constraints": {"enum": ["a", "b", "c"]},
  299:                 "name": "F",
  300:                 "ordered": True,
  301:                 "type": "any",
  302:             },
  303:             {"name": "G", "type": "number"},
  304:             {"name": "H", "type": "datetime", "tz": "US/Central"},
  305:         ]
  306: 
  307:         if using_infer_string:
  308:             fields[2] = {"name": "B", "type": "any", "extDtype": "string"}
  309: 
  310:         schema = {"fields": fields, "primaryKey": ["idx"]}
  311:         data = [
  312:             OrderedDict(
  313:                 [
  314:                     ("idx", 0),
  315:                     ("A", 1),
  316:                     ("B", "a"),
  317:                     ("C", "2016-01-01T00:00:00.000"),
  318:                     ("D", "P0DT1H0M0S"),
  319:                     ("E", "a"),
  320:                     ("F", "a"),
  321:                     ("G", 1.0),
  322:                     ("H", "2016-01-01T06:00:00.000Z"),
  323:                 ]
  324:             ),
  325:             OrderedDict(
  326:                 [
  327:                     ("idx", 1),
  328:                     ("A", 2),
  329:                     ("B", "b"),
  330:                     ("C", "2016-01-02T00:00:00.000"),
  331:                     ("D", "P0DT1H1M0S"),
  332:                     ("E", "b"),
  333:                     ("F", "b"),
  334:                     ("G", 2.0),
  335:                     ("H", "2016-01-02T06:00:00.000Z"),
  336:                 ]
  337:             ),
  338:             OrderedDict(
  339:                 [
  340:                     ("idx", 2),
  341:                     ("A", 3),
  342:                     ("B", "c"),
  343:                     ("C", "2016-01-03T00:00:00.000"),
  344:                     ("D", "P0DT1H2M0S"),
  345:                     ("E", "c"),
  346:                     ("F", "c"),
  347:                     ("G", 3.0),
  348:                     ("H", "2016-01-03T06:00:00.000Z"),
  349:                 ]
  350:             ),
  351:             OrderedDict(
  352:                 [
  353:                     ("idx", 3),
  354:                     ("A", 4),
  355:                     ("B", "c"),
  356:                     ("C", "2016-01-04T00:00:00.000"),
  357:                     ("D", "P0DT1H3M0S"),
  358:                     ("E", "c"),
  359:                     ("F", "c"),
  360:                     ("G", 4.0),
  361:                     ("H", "2016-01-04T06:00:00.000Z"),
  362:                 ]
  363:             ),
  364:         ]
  365:         expected = OrderedDict([("schema", schema), ("data", data)])
  366: 
  367:         assert result == expected
  368: 
  369:     def test_to_json_float_index(self):
  370:         data = pd.Series(1, index=[1.0, 2.0])
  371:         result = data.to_json(orient="table", date_format="iso")
  372:         result = json.loads(result, object_pairs_hook=OrderedDict)
  373:         result["schema"].pop("pandas_version")
  374: 
  375:         expected = OrderedDict(
  376:             [
  377:                 (
  378:                     "schema",
  379:                     {
  380:                         "fields": [
  381:                             {"name": "index", "type": "number"},
  382:                             {"name": "values", "type": "integer"},
  383:                         ],
  384:                         "primaryKey": ["index"],
  385:                     },
  386:                 ),
  387:                 (
  388:                     "data",
  389:                     [
  390:                         OrderedDict([("index", 1.0), ("values", 1)]),
  391:                         OrderedDict([("index", 2.0), ("values", 1)]),
  392:                     ],
  393:                 ),
  394:             ]
  395:         )
  396: 
  397:         assert result == expected
  398: 
  399:     def test_to_json_period_index(self):
  400:         idx = pd.period_range("2016", freq="Q-JAN", periods=2)
  401:         data = pd.Series(1, idx)
  402:         result = data.to_json(orient="table", date_format="iso")
  403:         result = json.loads(result, object_pairs_hook=OrderedDict)
  404:         result["schema"].pop("pandas_version")
  405: 
  406:         fields = [
  407:             {"freq": "QE-JAN", "name": "index", "type": "datetime"},
  408:             {"name": "values", "type": "integer"},
  409:         ]
  410: 
  411:         schema = {"fields": fields, "primaryKey": ["index"]}
  412:         data = [
  413:             OrderedDict([("index", "2015-11-01T00:00:00.000"), ("values", 1)]),
  414:             OrderedDict([("index", "2016-02-01T00:00:00.000"), ("values", 1)]),
  415:         ]
  416:         expected = OrderedDict([("schema", schema), ("data", data)])
  417: 
  418:         assert result == expected
  419: 
  420:     def test_to_json_categorical_index(self):
  421:         data = pd.Series(1, pd.CategoricalIndex(["a", "b"]))
  422:         result = data.to_json(orient="table", date_format="iso")
  423:         result = json.loads(result, object_pairs_hook=OrderedDict)
  424:         result["schema"].pop("pandas_version")
  425: 
  426:         expected = OrderedDict(
  427:             [
  428:                 (
  429:                     "schema",
  430:                     {
  431:                         "fields": [
  432:                             {
  433:                                 "name": "index",
  434:                                 "type": "any",
  435:                                 "constraints": {"enum": ["a", "b"]},
  436:                                 "ordered": False,
  437:                             },
  438:                             {"name": "values", "type": "integer"},
  439:                         ],
  440:                         "primaryKey": ["index"],
  441:                     },
  442:                 ),
  443:                 (
  444:                     "data",
  445:                     [
  446:                         OrderedDict([("index", "a"), ("values", 1)]),
  447:                         OrderedDict([("index", "b"), ("values", 1)]),
  448:                     ],
  449:                 ),
  450:             ]
  451:         )
  452: 
  453:         assert result == expected
  454: 
  455:     def test_date_format_raises(self, df_table):
  456:         msg = (
  457:             "Trying to write with `orient='table'` and `date_format='epoch'`. Table "
  458:             "Schema requires dates to be formatted with `date_format='iso'`"
  459:         )
  460:         with pytest.raises(ValueError, match=msg):
  461:             df_table.to_json(orient="table", date_format="epoch")
  462: 
  463:         # others work
  464:         df_table.to_json(orient="table", date_format="iso")
  465:         df_table.to_json(orient="table")
  466: 
  467:     def test_convert_pandas_type_to_json_field_int(self, index_or_series):
  468:         kind = index_or_series
  469:         data = [1, 2, 3]
  470:         result = convert_pandas_type_to_json_field(kind(data, name="name"))
  471:         expected = {"name": "name", "type": "integer"}
  472:         assert result == expected
  473: 
  474:     def test_convert_pandas_type_to_json_field_float(self, index_or_series):
  475:         kind = index_or_series
  476:         data = [1.0, 2.0, 3.0]
  477:         result = convert_pandas_type_to_json_field(kind(data, name="name"))
  478:         expected = {"name": "name", "type": "number"}
  479:         assert result == expected
  480: 
  481:     @pytest.mark.parametrize(
  482:         "dt_args,extra_exp", [({}, {}), ({"utc": True}, {"tz": "UTC"})]
  483:     )
  484:     @pytest.mark.parametrize("wrapper", [None, pd.Series])
  485:     def test_convert_pandas_type_to_json_field_datetime(
  486:         self, dt_args, extra_exp, wrapper
  487:     ):
  488:         data = [1.0, 2.0, 3.0]
  489:         data = pd.to_datetime(data, **dt_args)
  490:         if wrapper is pd.Series:
  491:             data = pd.Series(data, name="values")
  492:         result = convert_pandas_type_to_json_field(data)
  493:         expected = {"name": "values", "type": "datetime"}
  494:         expected.update(extra_exp)
  495:         assert result == expected
  496: 
  497:     def test_convert_pandas_type_to_json_period_range(self):
  498:         arr = pd.period_range("2016", freq="Y-DEC", periods=4)
  499:         result = convert_pandas_type_to_json_field(arr)
  500:         expected = {"name": "values", "type": "datetime", "freq": "YE-DEC"}
  501:         assert result == expected
  502: 
  503:     @pytest.mark.parametrize("kind", [pd.Categorical, pd.CategoricalIndex])
  504:     @pytest.mark.parametrize("ordered", [True, False])
  505:     def test_convert_pandas_type_to_json_field_categorical(self, kind, ordered):
  506:         data = ["a", "b", "c"]
  507:         if kind is pd.Categorical:
  508:             arr = pd.Series(kind(data, ordered=ordered), name="cats")
  509:         elif kind is pd.CategoricalIndex:
  510:             arr = kind(data, ordered=ordered, name="cats")
  511: 
  512:         result = convert_pandas_type_to_json_field(arr)
  513:         expected = {
  514:             "name": "cats",
  515:             "type": "any",
  516:             "constraints": {"enum": data},
  517:             "ordered": ordered,
  518:         }
  519:         assert result == expected
  520: 
  521:     @pytest.mark.parametrize(
  522:         "inp,exp",
  523:         [
  524:             ({"type": "integer"}, "int64"),
  525:             ({"type": "number"}, "float64"),
  526:             ({"type": "boolean"}, "bool"),
  527:             ({"type": "duration"}, "timedelta64"),
  528:             ({"type": "datetime"}, "datetime64[ns]"),
  529:             ({"type": "datetime", "tz": "US/Hawaii"}, "datetime64[ns, US/Hawaii]"),
  530:             ({"type": "any"}, "object"),
  531:             (
  532:                 {
  533:                     "type": "any",
  534:                     "constraints": {"enum": ["a", "b", "c"]},
  535:                     "ordered": False,
  536:                 },
  537:                 CategoricalDtype(categories=["a", "b", "c"], ordered=False),
  538:             ),
  539:             (
  540:                 {
  541:                     "type": "any",
  542:                     "constraints": {"enum": ["a", "b", "c"]},
  543:                     "ordered": True,
  544:                 },
  545:                 CategoricalDtype(categories=["a", "b", "c"], ordered=True),
  546:             ),
  547:             ({"type": "string"}, "object"),
  548:         ],
  549:     )
  550:     def test_convert_json_field_to_pandas_type(self, inp, exp):
  551:         field = {"name": "foo"}
  552:         field.update(inp)
  553:         assert convert_json_field_to_pandas_type(field) == exp
  554: 
  555:     @pytest.mark.parametrize("inp", ["geopoint", "geojson", "fake_type"])
  556:     def test_convert_json_field_to_pandas_type_raises(self, inp):
  557:         field = {"type": inp}
  558:         with pytest.raises(
  559:             ValueError, match=f"Unsupported or invalid field type: {inp}"
  560:         ):
  561:             convert_json_field_to_pandas_type(field)
  562: 
  563:     def test_categorical(self):
  564:         s = pd.Series(pd.Categorical(["a", "b", "a"]))
  565:         s.index.name = "idx"
  566:         result = s.to_json(orient="table", date_format="iso")
  567:         result = json.loads(result, object_pairs_hook=OrderedDict)
  568:         result["schema"].pop("pandas_version")
  569: 
  570:         fields = [
  571:             {"name": "idx", "type": "integer"},
  572:             {
  573:                 "constraints": {"enum": ["a", "b"]},
  574:                 "name": "values",
  575:                 "ordered": False,
  576:                 "type": "any",
  577:             },
  578:         ]
  579: 
  580:         expected = OrderedDict(
  581:             [
  582:                 ("schema", {"fields": fields, "primaryKey": ["idx"]}),
  583:                 (
  584:                     "data",
  585:                     [
  586:                         OrderedDict([("idx", 0), ("values", "a")]),
  587:                         OrderedDict([("idx", 1), ("values", "b")]),
  588:                         OrderedDict([("idx", 2), ("values", "a")]),
  589:                     ],
  590:                 ),
  591:             ]
  592:         )
  593: 
  594:         assert result == expected
  595: 
  596:     @pytest.mark.parametrize(
  597:         "idx,nm,prop",
  598:         [
  599:             (pd.Index([1]), "index", "name"),
  600:             (pd.Index([1], name="myname"), "myname", "name"),
  601:             (
  602:                 pd.MultiIndex.from_product([("a", "b"), ("c", "d")]),
  603:                 ["level_0", "level_1"],
  604:                 "names",
  605:             ),
  606:             (
  607:                 pd.MultiIndex.from_product(
  608:                     [("a", "b"), ("c", "d")], names=["n1", "n2"]
  609:                 ),
  610:                 ["n1", "n2"],
  611:                 "names",
  612:             ),
  613:             (
  614:                 pd.MultiIndex.from_product(
  615:                     [("a", "b"), ("c", "d")], names=["n1", None]
  616:                 ),
  617:                 ["n1", "level_1"],
  618:                 "names",
  619:             ),
  620:         ],
  621:     )
  622:     def test_set_names_unset(self, idx, nm, prop):
  623:         data = pd.Series(1, idx)
  624:         result = set_default_names(data)
  625:         assert getattr(result.index, prop) == nm
  626: 
  627:     @pytest.mark.parametrize(
  628:         "idx",
  629:         [
  630:             pd.Index([], name="index"),
  631:             pd.MultiIndex.from_arrays([["foo"], ["bar"]], names=("level_0", "level_1")),
  632:             pd.MultiIndex.from_arrays([["foo"], ["bar"]], names=("foo", "level_1")),
  633:         ],
  634:     )
  635:     def test_warns_non_roundtrippable_names(self, idx):
  636:         # GH 19130
  637:         df = DataFrame(index=idx)
  638:         df.index.name = "index"
  639:         with tm.assert_produces_warning():
  640:             set_default_names(df)
  641: 
  642:     def test_timestamp_in_columns(self):
  643:         df = DataFrame(
  644:             [[1, 2]], columns=[pd.Timestamp("2016"), pd.Timedelta(10, unit="s")]
  645:         )
  646:         result = df.to_json(orient="table")
  647:         js = json.loads(result)
  648:         assert js["schema"]["fields"][1]["name"] == "2016-01-01T00:00:00.000"
  649:         assert js["schema"]["fields"][2]["name"] == "P0DT0H0M10S"
  650: 
  651:     @pytest.mark.parametrize(
  652:         "case",
  653:         [
  654:             pd.Series([1], index=pd.Index([1], name="a"), name="a"),
  655:             DataFrame({"A": [1]}, index=pd.Index([1], name="A")),
  656:             DataFrame(
  657:                 {"A": [1]},
  658:                 index=pd.MultiIndex.from_arrays([["a"], [1]], names=["A", "a"]),
  659:             ),
  660:         ],
  661:     )
  662:     def test_overlapping_names(self, case):
  663:         with pytest.raises(ValueError, match="Overlapping"):
  664:             case.to_json(orient="table")
  665: 
  666:     def test_mi_falsey_name(self):
  667:         # GH 16203
  668:         df = DataFrame(
  669:             np.random.default_rng(2).standard_normal((4, 4)),
  670:             index=pd.MultiIndex.from_product([("A", "B"), ("a", "b")]),
  671:         )
  672:         result = [x["name"] for x in build_table_schema(df)["fields"]]
  673:         assert result == ["level_0", "level_1", 0, 1, 2, 3]
  674: 
  675: 
  676: class TestTableOrientReader:
  677:     @pytest.mark.parametrize(
  678:         "index_nm",
  679:         [None, "idx", pytest.param("index", marks=pytest.mark.xfail), "level_0"],
  680:     )
  681:     @pytest.mark.parametrize(
  682:         "vals",
  683:         [
  684:             {"ints": [1, 2, 3, 4]},
  685:             {"objects": ["a", "b", "c", "d"]},
  686:             {"objects": ["1", "2", "3", "4"]},
  687:             {"date_ranges": pd.date_range("2016-01-01", freq="d", periods=4)},
  688:             {"categoricals": pd.Series(pd.Categorical(["a", "b", "c", "c"]))},
  689:             {
  690:                 "ordered_cats": pd.Series(
  691:                     pd.Categorical(["a", "b", "c", "c"], ordered=True)
  692:                 )
  693:             },
  694:             {"floats": [1.0, 2.0, 3.0, 4.0]},
  695:             {"floats": [1.1, 2.2, 3.3, 4.4]},
  696:             {"bools": [True, False, False, True]},
  697:             {
  698:                 "timezones": pd.date_range(
  699:                     "2016-01-01", freq="d", periods=4, tz="US/Central"
  700:                 )  # added in # GH 35973
  701:             },
  702:         ],
  703:     )
  704:     def test_read_json_table_orient(self, index_nm, vals, recwarn):
  705:         df = DataFrame(vals, index=pd.Index(range(4), name=index_nm))
  706:         out = df.to_json(orient="table")
  707:         result = pd.read_json(out, orient="table")
  708:         tm.assert_frame_equal(df, result)
  709: 
  710:     @pytest.mark.parametrize("index_nm", [None, "idx", "index"])
  711:     @pytest.mark.parametrize(
  712:         "vals",
  713:         [{"timedeltas": pd.timedelta_range("1h", periods=4, freq="min")}],
  714:     )
  715:     def test_read_json_table_orient_raises(self, index_nm, vals, recwarn):
  716:         df = DataFrame(vals, index=pd.Index(range(4), name=index_nm))
  717:         out = df.to_json(orient="table")
  718:         with pytest.raises(NotImplementedError, match="can not yet read "):
  719:             pd.read_json(out, orient="table")
  720: 
  721:     @pytest.mark.parametrize(
  722:         "index_nm",
  723:         [None, "idx", pytest.param("index", marks=pytest.mark.xfail), "level_0"],
  724:     )
  725:     @pytest.mark.parametrize(
  726:         "vals",
  727:         [
  728:             {"ints": [1, 2, 3, 4]},
  729:             {"objects": ["a", "b", "c", "d"]},
  730:             {"objects": ["1", "2", "3", "4"]},
  731:             {"date_ranges": pd.date_range("2016-01-01", freq="d", periods=4)},
  732:             {"categoricals": pd.Series(pd.Categorical(["a", "b", "c", "c"]))},
  733:             {
  734:                 "ordered_cats": pd.Series(
  735:                     pd.Categorical(["a", "b", "c", "c"], ordered=True)
  736:                 )
  737:             },
  738:             {"floats": [1.0, 2.0, 3.0, 4.0]},
  739:             {"floats": [1.1, 2.2, 3.3, 4.4]},
  740:             {"bools": [True, False, False, True]},
  741:             {
  742:                 "timezones": pd.date_range(
  743:                     "2016-01-01", freq="d", periods=4, tz="US/Central"
  744:                 )  # added in # GH 35973
  745:             },
  746:         ],
  747:     )
  748:     def test_read_json_table_period_orient(self, index_nm, vals, recwarn):
  749:         df = DataFrame(
  750:             vals,
  751:             index=pd.Index(
  752:                 (pd.Period(f"2022Q{q}") for q in range(1, 5)), name=index_nm
  753:             ),
  754:         )
  755:         out = df.to_json(orient="table")
  756:         result = pd.read_json(out, orient="table")
  757:         tm.assert_frame_equal(df, result)
  758: 
  759:     @pytest.mark.parametrize(
  760:         "idx",
  761:         [
  762:             pd.Index(range(4)),
  763:             pd.date_range(
  764:                 "2020-08-30",
  765:                 freq="d",
  766:                 periods=4,
  767:             )._with_freq(None),
  768:             pd.date_range(
  769:                 "2020-08-30", freq="d", periods=4, tz="US/Central"
  770:             )._with_freq(None),
  771:             pd.MultiIndex.from_product(
  772:                 [
  773:                     pd.date_range("2020-08-30", freq="d", periods=2, tz="US/Central"),
  774:                     ["x", "y"],
  775:                 ],
  776:             ),
  777:         ],
  778:     )
  779:     @pytest.mark.parametrize(
  780:         "vals",
  781:         [
  782:             {"floats": [1.1, 2.2, 3.3, 4.4]},
  783:             {"dates": pd.date_range("2020-08-30", freq="d", periods=4)},
  784:             {
  785:                 "timezones": pd.date_range(
  786:                     "2020-08-30", freq="d", periods=4, tz="Europe/London"
  787:                 )
  788:             },
  789:         ],
  790:     )
  791:     def test_read_json_table_timezones_orient(self, idx, vals, recwarn):
  792:         # GH 35973
  793:         df = DataFrame(vals, index=idx)
  794:         out = df.to_json(orient="table")
  795:         result = pd.read_json(out, orient="table")
  796:         tm.assert_frame_equal(df, result)
  797: 
  798:     def test_comprehensive(self):
  799:         df = DataFrame(
  800:             {
  801:                 "A": [1, 2, 3, 4],
  802:                 "B": ["a", "b", "c", "c"],
  803:                 "C": pd.date_range("2016-01-01", freq="d", periods=4),
  804:                 # 'D': pd.timedelta_range('1h', periods=4, freq='min'),
  805:                 "E": pd.Series(pd.Categorical(["a", "b", "c", "c"])),
  806:                 "F": pd.Series(pd.Categorical(["a", "b", "c", "c"], ordered=True)),
  807:                 "G": [1.1, 2.2, 3.3, 4.4],
  808:                 "H": pd.date_range("2016-01-01", freq="d", periods=4, tz="US/Central"),
  809:                 "I": [True, False, False, True],
  810:             },
  811:             index=pd.Index(range(4), name="idx"),
  812:         )
  813: 
  814:         out = StringIO(df.to_json(orient="table"))
  815:         result = pd.read_json(out, orient="table")
  816:         tm.assert_frame_equal(df, result)
  817: 
  818:     @pytest.mark.parametrize(
  819:         "index_names",
  820:         [[None, None], ["foo", "bar"], ["foo", None], [None, "foo"], ["index", "foo"]],
  821:     )
  822:     def test_multiindex(self, index_names):
  823:         # GH 18912
  824:         df = DataFrame(
  825:             [["Arr", "alpha", [1, 2, 3, 4]], ["Bee", "Beta", [10, 20, 30, 40]]],
  826:             index=[["A", "B"], ["Null", "Eins"]],
  827:             columns=["Aussprache", "Griechisch", "Args"],
  828:         )
  829:         df.index.names = index_names
  830:         out = StringIO(df.to_json(orient="table"))
  831:         result = pd.read_json(out, orient="table")
  832:         tm.assert_frame_equal(df, result)
  833: 
  834:     def test_empty_frame_roundtrip(self):
  835:         # GH 21287
  836:         df = DataFrame(columns=["a", "b", "c"])
  837:         expected = df.copy()
  838:         out = StringIO(df.to_json(orient="table"))
  839:         result = pd.read_json(out, orient="table")
  840:         tm.assert_frame_equal(expected, result)
  841: 
  842:     def test_read_json_orient_table_old_schema_version(self):
  843:         df_json = """
  844:         {
  845:             "schema":{
  846:                 "fields":[
  847:                     {"name":"index","type":"integer"},
  848:                     {"name":"a","type":"string"}
  849:                 ],
  850:                 "primaryKey":["index"],
  851:                 "pandas_version":"0.20.0"
  852:             },
  853:             "data":[
  854:                 {"index":0,"a":1},
  855:                 {"index":1,"a":2.0},
  856:                 {"index":2,"a":"s"}
  857:             ]
  858:         }
  859:         """
  860:         expected = DataFrame({"a": [1, 2.0, "s"]})
  861:         result = pd.read_json(StringIO(df_json), orient="table")
  862:         tm.assert_frame_equal(expected, result)
  863: 
  864:     @pytest.mark.parametrize("freq", ["M", "2M", "Q", "2Q", "Y", "2Y"])
  865:     def test_read_json_table_orient_period_depr_freq(self, freq, recwarn):
  866:         # GH#9586
  867:         df = DataFrame(
  868:             {"ints": [1, 2]},
  869:             index=pd.PeriodIndex(["2020-01", "2021-06"], freq=freq),
  870:         )
  871:         out = df.to_json(orient="table")
  872:         result = pd.read_json(out, orient="table")
  873:         tm.assert_frame_equal(df, result)
