    1: from __future__ import annotations
    2: 
    3: from datetime import (
    4:     datetime,
    5:     time,
    6: )
    7: from functools import partial
    8: from io import BytesIO
    9: import os
   10: from pathlib import Path
   11: import platform
   12: import re
   13: from urllib.error import URLError
   14: from zipfile import BadZipFile
   15: 
   16: import numpy as np
   17: import pytest
   18: 
   19: from pandas._config import using_pyarrow_string_dtype
   20: 
   21: from pandas.compat import is_platform_windows
   22: import pandas.util._test_decorators as td
   23: 
   24: import pandas as pd
   25: from pandas import (
   26:     DataFrame,
   27:     Index,
   28:     MultiIndex,
   29:     Series,
   30:     read_csv,
   31: )
   32: import pandas._testing as tm
   33: from pandas.core.arrays import (
   34:     ArrowStringArray,
   35:     StringArray,
   36: )
   37: 
   38: if is_platform_windows():
   39:     pytestmark = pytest.mark.single_cpu
   40: 
   41: read_ext_params = [".xls", ".xlsx", ".xlsm", ".xlsb", ".ods"]
   42: engine_params = [
   43:     # Add any engines to test here
   44:     # When defusedxml is installed it triggers deprecation warnings for
   45:     # xlrd and openpyxl, so catch those here
   46:     pytest.param(
   47:         "xlrd",
   48:         marks=[
   49:             td.skip_if_no("xlrd"),
   50:         ],
   51:     ),
   52:     pytest.param(
   53:         "openpyxl",
   54:         marks=[
   55:             td.skip_if_no("openpyxl"),
   56:         ],
   57:     ),
   58:     pytest.param(
   59:         None,
   60:         marks=[
   61:             td.skip_if_no("xlrd"),
   62:         ],
   63:     ),
   64:     pytest.param("pyxlsb", marks=td.skip_if_no("pyxlsb")),
   65:     pytest.param("odf", marks=td.skip_if_no("odf")),
   66:     pytest.param("calamine", marks=td.skip_if_no("python_calamine")),
   67: ]
   68: 
   69: 
   70: def _is_valid_engine_ext_pair(engine, read_ext: str) -> bool:
   71:     """
   72:     Filter out invalid (engine, ext) pairs instead of skipping, as that
   73:     produces 500+ pytest.skips.
   74:     """
   75:     engine = engine.values[0]
   76:     if engine == "openpyxl" and read_ext == ".xls":
   77:         return False
   78:     if engine == "odf" and read_ext != ".ods":
   79:         return False
   80:     if read_ext == ".ods" and engine not in {"odf", "calamine"}:
   81:         return False
   82:     if engine == "pyxlsb" and read_ext != ".xlsb":
   83:         return False
   84:     if read_ext == ".xlsb" and engine not in {"pyxlsb", "calamine"}:
   85:         return False
   86:     if engine == "xlrd" and read_ext != ".xls":
   87:         return False
   88:     return True
   89: 
   90: 
   91: def _transfer_marks(engine, read_ext):
   92:     """
   93:     engine gives us a pytest.param object with some marks, read_ext is just
   94:     a string.  We need to generate a new pytest.param inheriting the marks.
   95:     """
   96:     values = engine.values + (read_ext,)
   97:     new_param = pytest.param(values, marks=engine.marks)
   98:     return new_param
   99: 
  100: 
  101: @pytest.fixture(
  102:     params=[
  103:         _transfer_marks(eng, ext)
  104:         for eng in engine_params
  105:         for ext in read_ext_params
  106:         if _is_valid_engine_ext_pair(eng, ext)
  107:     ],
  108:     ids=str,
  109: )
  110: def engine_and_read_ext(request):
  111:     """
  112:     Fixture for Excel reader engine and read_ext, only including valid pairs.
  113:     """
  114:     return request.param
  115: 
  116: 
  117: @pytest.fixture
  118: def engine(engine_and_read_ext):
  119:     engine, read_ext = engine_and_read_ext
  120:     return engine
  121: 
  122: 
  123: @pytest.fixture
  124: def read_ext(engine_and_read_ext):
  125:     engine, read_ext = engine_and_read_ext
  126:     return read_ext
  127: 
  128: 
  129: @pytest.fixture
  130: def df_ref(datapath):
  131:     """
  132:     Obtain the reference data from read_csv with the Python engine.
  133:     """
  134:     filepath = datapath("io", "data", "csv", "test1.csv")
  135:     df_ref = read_csv(filepath, index_col=0, parse_dates=True, engine="python")
  136:     return df_ref
  137: 
  138: 
  139: def get_exp_unit(read_ext: str, engine: str | None) -> str:
  140:     return "ns"
  141: 
  142: 
  143: def adjust_expected(expected: DataFrame, read_ext: str, engine: str) -> None:
  144:     expected.index.name = None
  145:     unit = get_exp_unit(read_ext, engine)
  146:     # error: "Index" has no attribute "as_unit"
  147:     expected.index = expected.index.as_unit(unit)  # type: ignore[attr-defined]
  148: 
  149: 
  150: def xfail_datetimes_with_pyxlsb(engine, request):
  151:     if engine == "pyxlsb":
  152:         request.applymarker(
  153:             pytest.mark.xfail(
  154:                 reason="Sheets containing datetimes not supported by pyxlsb"
  155:             )
  156:         )
  157: 
  158: 
  159: class TestReaders:
  160:     @pytest.fixture(autouse=True)
  161:     def cd_and_set_engine(self, engine, datapath, monkeypatch):
  162:         """
  163:         Change directory and set engine for read_excel calls.
  164:         """
  165:         func = partial(pd.read_excel, engine=engine)
  166:         monkeypatch.chdir(datapath("io", "data", "excel"))
  167:         monkeypatch.setattr(pd, "read_excel", func)
  168: 
  169:     def test_engine_used(self, read_ext, engine, monkeypatch):
  170:         # GH 38884
  171:         def parser(self, *args, **kwargs):
  172:             return self.engine
  173: 
  174:         monkeypatch.setattr(pd.ExcelFile, "parse", parser)
  175: 
  176:         expected_defaults = {
  177:             "xlsx": "openpyxl",
  178:             "xlsm": "openpyxl",
  179:             "xlsb": "pyxlsb",
  180:             "xls": "xlrd",
  181:             "ods": "odf",
  182:         }
  183: 
  184:         with open("test1" + read_ext, "rb") as f:
  185:             result = pd.read_excel(f)
  186: 
  187:         if engine is not None:
  188:             expected = engine
  189:         else:
  190:             expected = expected_defaults[read_ext[1:]]
  191:         assert result == expected
  192: 
  193:     def test_engine_kwargs(self, read_ext, engine):
  194:         # GH#52214
  195:         expected_defaults = {
  196:             "xlsx": {"foo": "abcd"},
  197:             "xlsm": {"foo": 123},
  198:             "xlsb": {"foo": "True"},
  199:             "xls": {"foo": True},
  200:             "ods": {"foo": "abcd"},
  201:         }
  202: 
  203:         if engine in {"xlrd", "pyxlsb"}:
  204:             msg = re.escape(r"open_workbook() got an unexpected keyword argument 'foo'")
  205:         elif engine == "odf":
  206:             msg = re.escape(r"load() got an unexpected keyword argument 'foo'")
  207:         else:
  208:             msg = re.escape(r"load_workbook() got an unexpected keyword argument 'foo'")
  209: 
  210:         if engine is not None:
  211:             with pytest.raises(TypeError, match=msg):
  212:                 pd.read_excel(
  213:                     "test1" + read_ext,
  214:                     sheet_name="Sheet1",
  215:                     index_col=0,
  216:                     engine_kwargs=expected_defaults[read_ext[1:]],
  217:                 )
  218: 
  219:     def test_usecols_int(self, read_ext):
  220:         # usecols as int
  221:         msg = "Passing an integer for `usecols`"
  222:         with pytest.raises(ValueError, match=msg):
  223:             pd.read_excel(
  224:                 "test1" + read_ext, sheet_name="Sheet1", index_col=0, usecols=3
  225:             )
  226: 
  227:         # usecols as int
  228:         with pytest.raises(ValueError, match=msg):
  229:             pd.read_excel(
  230:                 "test1" + read_ext,
  231:                 sheet_name="Sheet2",
  232:                 skiprows=[1],
  233:                 index_col=0,
  234:                 usecols=3,
  235:             )
  236: 
  237:     def test_usecols_list(self, request, engine, read_ext, df_ref):
  238:         xfail_datetimes_with_pyxlsb(engine, request)
  239: 
  240:         expected = df_ref[["B", "C"]]
  241:         adjust_expected(expected, read_ext, engine)
  242: 
  243:         df1 = pd.read_excel(
  244:             "test1" + read_ext, sheet_name="Sheet1", index_col=0, usecols=[0, 2, 3]
  245:         )
  246:         df2 = pd.read_excel(
  247:             "test1" + read_ext,
  248:             sheet_name="Sheet2",
  249:             skiprows=[1],
  250:             index_col=0,
  251:             usecols=[0, 2, 3],
  252:         )
  253: 
  254:         # TODO add index to xls file)
  255:         tm.assert_frame_equal(df1, expected)
  256:         tm.assert_frame_equal(df2, expected)
  257: 
  258:     def test_usecols_str(self, request, engine, read_ext, df_ref):
  259:         xfail_datetimes_with_pyxlsb(engine, request)
  260: 
  261:         expected = df_ref[["A", "B", "C"]]
  262:         adjust_expected(expected, read_ext, engine)
  263: 
  264:         df2 = pd.read_excel(
  265:             "test1" + read_ext, sheet_name="Sheet1", index_col=0, usecols="A:D"
  266:         )
  267:         df3 = pd.read_excel(
  268:             "test1" + read_ext,
  269:             sheet_name="Sheet2",
  270:             skiprows=[1],
  271:             index_col=0,
  272:             usecols="A:D",
  273:         )
  274: 
  275:         # TODO add index to xls, read xls ignores index name ?
  276:         tm.assert_frame_equal(df2, expected)
  277:         tm.assert_frame_equal(df3, expected)
  278: 
  279:         expected = df_ref[["B", "C"]]
  280:         adjust_expected(expected, read_ext, engine)
  281: 
  282:         df2 = pd.read_excel(
  283:             "test1" + read_ext, sheet_name="Sheet1", index_col=0, usecols="A,C,D"
  284:         )
  285:         df3 = pd.read_excel(
  286:             "test1" + read_ext,
  287:             sheet_name="Sheet2",
  288:             skiprows=[1],
  289:             index_col=0,
  290:             usecols="A,C,D",
  291:         )
  292:         # TODO add index to xls file
  293:         tm.assert_frame_equal(df2, expected)
  294:         tm.assert_frame_equal(df3, expected)
  295: 
  296:         df2 = pd.read_excel(
  297:             "test1" + read_ext, sheet_name="Sheet1", index_col=0, usecols="A,C:D"
  298:         )
  299:         df3 = pd.read_excel(
  300:             "test1" + read_ext,
  301:             sheet_name="Sheet2",
  302:             skiprows=[1],
  303:             index_col=0,
  304:             usecols="A,C:D",
  305:         )
  306:         tm.assert_frame_equal(df2, expected)
  307:         tm.assert_frame_equal(df3, expected)
  308: 
  309:     @pytest.mark.parametrize(
  310:         "usecols", [[0, 1, 3], [0, 3, 1], [1, 0, 3], [1, 3, 0], [3, 0, 1], [3, 1, 0]]
  311:     )
  312:     def test_usecols_diff_positional_int_columns_order(
  313:         self, request, engine, read_ext, usecols, df_ref
  314:     ):
  315:         xfail_datetimes_with_pyxlsb(engine, request)
  316: 
  317:         expected = df_ref[["A", "C"]]
  318:         adjust_expected(expected, read_ext, engine)
  319: 
  320:         result = pd.read_excel(
  321:             "test1" + read_ext, sheet_name="Sheet1", index_col=0, usecols=usecols
  322:         )
  323:         tm.assert_frame_equal(result, expected)
  324: 
  325:     @pytest.mark.parametrize("usecols", [["B", "D"], ["D", "B"]])
  326:     def test_usecols_diff_positional_str_columns_order(self, read_ext, usecols, df_ref):
  327:         expected = df_ref[["B", "D"]]
  328:         expected.index = range(len(expected))
  329: 
  330:         result = pd.read_excel("test1" + read_ext, sheet_name="Sheet1", usecols=usecols)
  331:         tm.assert_frame_equal(result, expected)
  332: 
  333:     def test_read_excel_without_slicing(self, request, engine, read_ext, df_ref):
  334:         xfail_datetimes_with_pyxlsb(engine, request)
  335: 
  336:         expected = df_ref
  337:         adjust_expected(expected, read_ext, engine)
  338: 
  339:         result = pd.read_excel("test1" + read_ext, sheet_name="Sheet1", index_col=0)
  340:         tm.assert_frame_equal(result, expected)
  341: 
  342:     def test_usecols_excel_range_str(self, request, engine, read_ext, df_ref):
  343:         xfail_datetimes_with_pyxlsb(engine, request)
  344: 
  345:         expected = df_ref[["C", "D"]]
  346:         adjust_expected(expected, read_ext, engine)
  347: 
  348:         result = pd.read_excel(
  349:             "test1" + read_ext, sheet_name="Sheet1", index_col=0, usecols="A,D:E"
  350:         )
  351:         tm.assert_frame_equal(result, expected)
  352: 
  353:     def test_usecols_excel_range_str_invalid(self, read_ext):
  354:         msg = "Invalid column name: E1"
  355: 
  356:         with pytest.raises(ValueError, match=msg):
  357:             pd.read_excel("test1" + read_ext, sheet_name="Sheet1", usecols="D:E1")
  358: 
  359:     def test_index_col_label_error(self, read_ext):
  360:         msg = "list indices must be integers.*, not str"
  361: 
  362:         with pytest.raises(TypeError, match=msg):
  363:             pd.read_excel(
  364:                 "test1" + read_ext,
  365:                 sheet_name="Sheet1",
  366:                 index_col=["A"],
  367:                 usecols=["A", "C"],
  368:             )
  369: 
  370:     def test_index_col_str(self, read_ext):
  371:         # see gh-52716
  372:         result = pd.read_excel("test1" + read_ext, sheet_name="Sheet3", index_col="A")
  373:         expected = DataFrame(
  374:             columns=["B", "C", "D", "E", "F"], index=Index([], name="A")
  375:         )
  376:         tm.assert_frame_equal(result, expected)
  377: 
  378:     def test_index_col_empty(self, read_ext):
  379:         # see gh-9208
  380:         result = pd.read_excel(
  381:             "test1" + read_ext, sheet_name="Sheet3", index_col=["A", "B", "C"]
  382:         )
  383:         expected = DataFrame(
  384:             columns=["D", "E", "F"],
  385:             index=MultiIndex(levels=[[]] * 3, codes=[[]] * 3, names=["A", "B", "C"]),
  386:         )
  387:         tm.assert_frame_equal(result, expected)
  388: 
  389:     @pytest.mark.parametrize("index_col", [None, 2])
  390:     def test_index_col_with_unnamed(self, read_ext, index_col):
  391:         # see gh-18792
  392:         result = pd.read_excel(
  393:             "test1" + read_ext, sheet_name="Sheet4", index_col=index_col
  394:         )
  395:         expected = DataFrame(
  396:             [["i1", "a", "x"], ["i2", "b", "y"]], columns=["Unnamed: 0", "col1", "col2"]
  397:         )
  398:         if index_col:
  399:             expected = expected.set_index(expected.columns[index_col])
  400: 
  401:         tm.assert_frame_equal(result, expected)
  402: 
  403:     def test_usecols_pass_non_existent_column(self, read_ext):
  404:         msg = (
  405:             "Usecols do not match columns, "
  406:             "columns expected but not found: "
  407:             r"\['E'\]"
  408:         )
  409: 
  410:         with pytest.raises(ValueError, match=msg):
  411:             pd.read_excel("test1" + read_ext, usecols=["E"])
  412: 
  413:     def test_usecols_wrong_type(self, read_ext):
  414:         msg = (
  415:             "'usecols' must either be list-like of "
  416:             "all strings, all unicode, all integers or a callable."
  417:         )
  418: 
  419:         with pytest.raises(ValueError, match=msg):
  420:             pd.read_excel("test1" + read_ext, usecols=["E1", 0])
  421: 
  422:     def test_excel_stop_iterator(self, read_ext):
  423:         parsed = pd.read_excel("test2" + read_ext, sheet_name="Sheet1")
  424:         expected = DataFrame([["aaaa", "bbbbb"]], columns=["Test", "Test1"])
  425:         tm.assert_frame_equal(parsed, expected)
  426: 
  427:     def test_excel_cell_error_na(self, request, engine, read_ext):
  428:         xfail_datetimes_with_pyxlsb(engine, request)
  429: 
  430:         # https://github.com/tafia/calamine/issues/355
  431:         if engine == "calamine" and read_ext == ".ods":
  432:             request.applymarker(
  433:                 pytest.mark.xfail(reason="Calamine can't extract error from ods files")
  434:             )
  435: 
  436:         parsed = pd.read_excel("test3" + read_ext, sheet_name="Sheet1")
  437:         expected = DataFrame([[np.nan]], columns=["Test"])
  438:         tm.assert_frame_equal(parsed, expected)
  439: 
  440:     def test_excel_table(self, request, engine, read_ext, df_ref):
  441:         xfail_datetimes_with_pyxlsb(engine, request)
  442: 
  443:         expected = df_ref
  444:         adjust_expected(expected, read_ext, engine)
  445: 
  446:         df1 = pd.read_excel("test1" + read_ext, sheet_name="Sheet1", index_col=0)
  447:         df2 = pd.read_excel(
  448:             "test1" + read_ext, sheet_name="Sheet2", skiprows=[1], index_col=0
  449:         )
  450:         # TODO add index to file
  451:         tm.assert_frame_equal(df1, expected)
  452:         tm.assert_frame_equal(df2, expected)
  453: 
  454:         df3 = pd.read_excel(
  455:             "test1" + read_ext, sheet_name="Sheet1", index_col=0, skipfooter=1
  456:         )
  457:         tm.assert_frame_equal(df3, df1.iloc[:-1])
  458: 
  459:     def test_reader_special_dtypes(self, request, engine, read_ext):
  460:         xfail_datetimes_with_pyxlsb(engine, request)
  461: 
  462:         unit = get_exp_unit(read_ext, engine)
  463:         expected = DataFrame.from_dict(
  464:             {
  465:                 "IntCol": [1, 2, -3, 4, 0],
  466:                 "FloatCol": [1.25, 2.25, 1.83, 1.92, 0.0000000005],
  467:                 "BoolCol": [True, False, True, True, False],
  468:                 "StrCol": [1, 2, 3, 4, 5],
  469:                 "Str2Col": ["a", 3, "c", "d", "e"],
  470:                 "DateCol": Index(
  471:                     [
  472:                         datetime(2013, 10, 30),
  473:                         datetime(2013, 10, 31),
  474:                         datetime(1905, 1, 1),
  475:                         datetime(2013, 12, 14),
  476:                         datetime(2015, 3, 14),
  477:                     ],
  478:                     dtype=f"M8[{unit}]",
  479:                 ),
  480:             },
  481:         )
  482:         basename = "test_types"
  483: 
  484:         # should read in correctly and infer types
  485:         actual = pd.read_excel(basename + read_ext, sheet_name="Sheet1")
  486:         tm.assert_frame_equal(actual, expected)
  487: 
  488:         # if not coercing number, then int comes in as float
  489:         float_expected = expected.copy()
  490:         float_expected.loc[float_expected.index[1], "Str2Col"] = 3.0
  491:         actual = pd.read_excel(basename + read_ext, sheet_name="Sheet1")
  492:         tm.assert_frame_equal(actual, float_expected)
  493: 
  494:         # check setting Index (assuming xls and xlsx are the same here)
  495:         for icol, name in enumerate(expected.columns):
  496:             actual = pd.read_excel(
  497:                 basename + read_ext, sheet_name="Sheet1", index_col=icol
  498:             )
  499:             exp = expected.set_index(name)
  500:             tm.assert_frame_equal(actual, exp)
  501: 
  502:         expected["StrCol"] = expected["StrCol"].apply(str)
  503:         actual = pd.read_excel(
  504:             basename + read_ext, sheet_name="Sheet1", converters={"StrCol": str}
  505:         )
  506:         tm.assert_frame_equal(actual, expected)
  507: 
  508:     # GH8212 - support for converters and missing values
  509:     def test_reader_converters(self, read_ext):
  510:         basename = "test_converters"
  511: 
  512:         expected = DataFrame.from_dict(
  513:             {
  514:                 "IntCol": [1, 2, -3, -1000, 0],
  515:                 "FloatCol": [12.5, np.nan, 18.3, 19.2, 0.000000005],
  516:                 "BoolCol": ["Found", "Found", "Found", "Not found", "Found"],
  517:                 "StrCol": ["1", np.nan, "3", "4", "5"],
  518:             }
  519:         )
  520: 
  521:         converters = {
  522:             "IntCol": lambda x: int(x) if x != "" else -1000,
  523:             "FloatCol": lambda x: 10 * x if x else np.nan,
  524:             2: lambda x: "Found" if x != "" else "Not found",
  525:             3: lambda x: str(x) if x else "",
  526:         }
  527: 
  528:         # should read in correctly and set types of single cells (not array
  529:         # dtypes)
  530:         actual = pd.read_excel(
  531:             basename + read_ext, sheet_name="Sheet1", converters=converters
  532:         )
  533:         tm.assert_frame_equal(actual, expected)
  534: 
  535:     def test_reader_dtype(self, read_ext):
  536:         # GH 8212
  537:         basename = "testdtype"
  538:         actual = pd.read_excel(basename + read_ext)
  539: 
  540:         expected = DataFrame(
  541:             {
  542:                 "a": [1, 2, 3, 4],
  543:                 "b": [2.5, 3.5, 4.5, 5.5],
  544:                 "c": [1, 2, 3, 4],
  545:                 "d": [1.0, 2.0, np.nan, 4.0],
  546:             }
  547:         )
  548: 
  549:         tm.assert_frame_equal(actual, expected)
  550: 
  551:         actual = pd.read_excel(
  552:             basename + read_ext, dtype={"a": "float64", "b": "float32", "c": str}
  553:         )
  554: 
  555:         expected["a"] = expected["a"].astype("float64")
  556:         expected["b"] = expected["b"].astype("float32")
  557:         expected["c"] = Series(["001", "002", "003", "004"], dtype=object)
  558:         tm.assert_frame_equal(actual, expected)
  559: 
  560:         msg = "Unable to convert column d to type int64"
  561:         with pytest.raises(ValueError, match=msg):
  562:             pd.read_excel(basename + read_ext, dtype={"d": "int64"})
  563: 
  564:     @pytest.mark.parametrize(
  565:         "dtype,expected",
  566:         [
  567:             (
  568:                 None,
  569:                 DataFrame(
  570:                     {
  571:                         "a": [1, 2, 3, 4],
  572:                         "b": [2.5, 3.5, 4.5, 5.5],
  573:                         "c": [1, 2, 3, 4],
  574:                         "d": [1.0, 2.0, np.nan, 4.0],
  575:                     }
  576:                 ),
  577:             ),
  578:             (
  579:                 {"a": "float64", "b": "float32", "c": str, "d": str},
  580:                 DataFrame(
  581:                     {
  582:                         "a": Series([1, 2, 3, 4], dtype="float64"),
  583:                         "b": Series([2.5, 3.5, 4.5, 5.5], dtype="float32"),
  584:                         "c": Series(["001", "002", "003", "004"], dtype=object),
  585:                         "d": Series(["1", "2", np.nan, "4"], dtype=object),
  586:                     }
  587:                 ),
  588:             ),
  589:         ],
  590:     )
  591:     def test_reader_dtype_str(self, read_ext, dtype, expected):
  592:         # see gh-20377
  593:         basename = "testdtype"
  594: 
  595:         actual = pd.read_excel(basename + read_ext, dtype=dtype)
  596:         tm.assert_frame_equal(actual, expected)
  597: 
  598:     def test_dtype_backend(self, read_ext, dtype_backend, engine):
  599:         # GH#36712
  600:         if read_ext in (".xlsb", ".xls"):
  601:             pytest.skip(f"No engine for filetype: '{read_ext}'")
  602: 
  603:         df = DataFrame(
  604:             {
  605:                 "a": Series([1, 3], dtype="Int64"),
  606:                 "b": Series([2.5, 4.5], dtype="Float64"),
  607:                 "c": Series([True, False], dtype="boolean"),
  608:                 "d": Series(["a", "b"], dtype="string"),
  609:                 "e": Series([pd.NA, 6], dtype="Int64"),
  610:                 "f": Series([pd.NA, 7.5], dtype="Float64"),
  611:                 "g": Series([pd.NA, True], dtype="boolean"),
  612:                 "h": Series([pd.NA, "a"], dtype="string"),
  613:                 "i": Series([pd.Timestamp("2019-12-31")] * 2),
  614:                 "j": Series([pd.NA, pd.NA], dtype="Int64"),
  615:             }
  616:         )
  617:         with tm.ensure_clean(read_ext) as file_path:
  618:             df.to_excel(file_path, sheet_name="test", index=False)
  619:             result = pd.read_excel(
  620:                 file_path, sheet_name="test", dtype_backend=dtype_backend
  621:             )
  622:         if dtype_backend == "pyarrow":
  623:             import pyarrow as pa
  624: 
  625:             from pandas.arrays import ArrowExtensionArray
  626: 
  627:             expected = DataFrame(
  628:                 {
  629:                     col: ArrowExtensionArray(pa.array(df[col], from_pandas=True))
  630:                     for col in df.columns
  631:                 }
  632:             )
  633:             # pyarrow by default infers timestamp resolution as us, not ns
  634:             expected["i"] = ArrowExtensionArray(
  635:                 expected["i"].array._pa_array.cast(pa.timestamp(unit="us"))
  636:             )
  637:             # pyarrow supports a null type, so don't have to default to Int64
  638:             expected["j"] = ArrowExtensionArray(pa.array([None, None]))
  639:         else:
  640:             expected = df
  641:             unit = get_exp_unit(read_ext, engine)
  642:             expected["i"] = expected["i"].astype(f"M8[{unit}]")
  643: 
  644:         tm.assert_frame_equal(result, expected)
  645: 
  646:     def test_dtype_backend_and_dtype(self, read_ext):
  647:         # GH#36712
  648:         if read_ext in (".xlsb", ".xls"):
  649:             pytest.skip(f"No engine for filetype: '{read_ext}'")
  650: 
  651:         df = DataFrame({"a": [np.nan, 1.0], "b": [2.5, np.nan]})
  652:         with tm.ensure_clean(read_ext) as file_path:
  653:             df.to_excel(file_path, sheet_name="test", index=False)
  654:             result = pd.read_excel(
  655:                 file_path,
  656:                 sheet_name="test",
  657:                 dtype_backend="numpy_nullable",
  658:                 dtype="float64",
  659:             )
  660:         tm.assert_frame_equal(result, df)
  661: 
  662:     @pytest.mark.xfail(
  663:         using_pyarrow_string_dtype(), reason="infer_string takes precedence"
  664:     )
  665:     def test_dtype_backend_string(self, read_ext, string_storage):
  666:         # GH#36712
  667:         if read_ext in (".xlsb", ".xls"):
  668:             pytest.skip(f"No engine for filetype: '{read_ext}'")
  669: 
  670:         pa = pytest.importorskip("pyarrow")
  671: 
  672:         with pd.option_context("mode.string_storage", string_storage):
  673:             df = DataFrame(
  674:                 {
  675:                     "a": np.array(["a", "b"], dtype=np.object_),
  676:                     "b": np.array(["x", pd.NA], dtype=np.object_),
  677:                 }
  678:             )
  679:             with tm.ensure_clean(read_ext) as file_path:
  680:                 df.to_excel(file_path, sheet_name="test", index=False)
  681:                 result = pd.read_excel(
  682:                     file_path, sheet_name="test", dtype_backend="numpy_nullable"
  683:                 )
  684: 
  685:             if string_storage == "python":
  686:                 expected = DataFrame(
  687:                     {
  688:                         "a": StringArray(np.array(["a", "b"], dtype=np.object_)),
  689:                         "b": StringArray(np.array(["x", pd.NA], dtype=np.object_)),
  690:                     }
  691:                 )
  692:             else:
  693:                 expected = DataFrame(
  694:                     {
  695:                         "a": ArrowStringArray(pa.array(["a", "b"])),
  696:                         "b": ArrowStringArray(pa.array(["x", None])),
  697:                     }
  698:                 )
  699:             tm.assert_frame_equal(result, expected)
  700: 
  701:     @pytest.mark.parametrize("dtypes, exp_value", [({}, 1), ({"a.1": "int64"}, 1)])
  702:     def test_dtype_mangle_dup_cols(self, read_ext, dtypes, exp_value):
  703:         # GH#35211
  704:         basename = "df_mangle_dup_col_dtypes"
  705:         dtype_dict = {"a": object, **dtypes}
  706:         dtype_dict_copy = dtype_dict.copy()
  707:         # GH#42462
  708:         result = pd.read_excel(basename + read_ext, dtype=dtype_dict)
  709:         expected = DataFrame(
  710:             {
  711:                 "a": Series([1], dtype=object),
  712:                 "a.1": Series([exp_value], dtype=object if not dtypes else None),
  713:             }
  714:         )
  715:         assert dtype_dict == dtype_dict_copy, "dtype dict changed"
  716:         tm.assert_frame_equal(result, expected)
  717: 
  718:     def test_reader_spaces(self, read_ext):
  719:         # see gh-32207
  720:         basename = "test_spaces"
  721: 
  722:         actual = pd.read_excel(basename + read_ext)
  723:         expected = DataFrame(
  724:             {
  725:                 "testcol": [
  726:                     "this is great",
  727:                     "4    spaces",
  728:                     "1 trailing ",
  729:                     " 1 leading",
  730:                     "2  spaces  multiple  times",
  731:                 ]
  732:             }
  733:         )
  734:         tm.assert_frame_equal(actual, expected)
  735: 
  736:     # gh-36122, gh-35802
  737:     @pytest.mark.parametrize(
  738:         "basename,expected",
  739:         [
  740:             ("gh-35802", DataFrame({"COLUMN": ["Test (1)"]})),
  741:             ("gh-36122", DataFrame(columns=["got 2nd sa"])),
  742:         ],
  743:     )
  744:     def test_read_excel_ods_nested_xml(self, engine, read_ext, basename, expected):
  745:         # see gh-35802
  746:         if engine != "odf":
  747:             pytest.skip(f"Skipped for engine: {engine}")
  748: 
  749:         actual = pd.read_excel(basename + read_ext)
  750:         tm.assert_frame_equal(actual, expected)
  751: 
  752:     def test_reading_all_sheets(self, read_ext):
  753:         # Test reading all sheet names by setting sheet_name to None,
  754:         # Ensure a dict is returned.
  755:         # See PR #9450
  756:         basename = "test_multisheet"
  757:         dfs = pd.read_excel(basename + read_ext, sheet_name=None)
  758:         # ensure this is not alphabetical to test order preservation
  759:         expected_keys = ["Charlie", "Alpha", "Beta"]
  760:         tm.assert_contains_all(expected_keys, dfs.keys())
  761:         # Issue 9930
  762:         # Ensure sheet order is preserved
  763:         assert expected_keys == list(dfs.keys())
  764: 
  765:     def test_reading_multiple_specific_sheets(self, read_ext):
  766:         # Test reading specific sheet names by specifying a mixed list
  767:         # of integers and strings, and confirm that duplicated sheet
  768:         # references (positions/names) are removed properly.
  769:         # Ensure a dict is returned
  770:         # See PR #9450
  771:         basename = "test_multisheet"
  772:         # Explicitly request duplicates. Only the set should be returned.
  773:         expected_keys = [2, "Charlie", "Charlie"]
  774:         dfs = pd.read_excel(basename + read_ext, sheet_name=expected_keys)
  775:         expected_keys = list(set(expected_keys))
  776:         tm.assert_contains_all(expected_keys, dfs.keys())
  777:         assert len(expected_keys) == len(dfs.keys())
  778: 
  779:     def test_reading_all_sheets_with_blank(self, read_ext):
  780:         # Test reading all sheet names by setting sheet_name to None,
  781:         # In the case where some sheets are blank.
  782:         # Issue #11711
  783:         basename = "blank_with_header"
  784:         dfs = pd.read_excel(basename + read_ext, sheet_name=None)
  785:         expected_keys = ["Sheet1", "Sheet2", "Sheet3"]
  786:         tm.assert_contains_all(expected_keys, dfs.keys())
  787: 
  788:     # GH6403
  789:     def test_read_excel_blank(self, read_ext):
  790:         actual = pd.read_excel("blank" + read_ext, sheet_name="Sheet1")
  791:         tm.assert_frame_equal(actual, DataFrame())
  792: 
  793:     def test_read_excel_blank_with_header(self, read_ext):
  794:         expected = DataFrame(columns=["col_1", "col_2"])
  795:         actual = pd.read_excel("blank_with_header" + read_ext, sheet_name="Sheet1")
  796:         tm.assert_frame_equal(actual, expected)
  797: 
  798:     def test_exception_message_includes_sheet_name(self, read_ext):
  799:         # GH 48706
  800:         with pytest.raises(ValueError, match=r" \(sheet: Sheet1\)$"):
  801:             pd.read_excel("blank_with_header" + read_ext, header=[1], sheet_name=None)
  802:         with pytest.raises(ZeroDivisionError, match=r" \(sheet: Sheet1\)$"):
  803:             pd.read_excel("test1" + read_ext, usecols=lambda x: 1 / 0, sheet_name=None)
  804: 
  805:     @pytest.mark.filterwarnings("ignore:Cell A4 is marked:UserWarning:openpyxl")
  806:     def test_date_conversion_overflow(self, request, engine, read_ext):
  807:         # GH 10001 : pandas.ExcelFile ignore parse_dates=False
  808:         xfail_datetimes_with_pyxlsb(engine, request)
  809: 
  810:         expected = DataFrame(
  811:             [
  812:                 [pd.Timestamp("2016-03-12"), "Marc Johnson"],
  813:                 [pd.Timestamp("2016-03-16"), "Jack Black"],
  814:                 [1e20, "Timothy Brown"],
  815:             ],
  816:             columns=["DateColWithBigInt", "StringCol"],
  817:         )
  818: 
  819:         if engine == "openpyxl":
  820:             request.applymarker(
  821:                 pytest.mark.xfail(reason="Maybe not supported by openpyxl")
  822:             )
  823: 
  824:         if engine is None and read_ext in (".xlsx", ".xlsm"):
  825:             # GH 35029
  826:             request.applymarker(
  827:                 pytest.mark.xfail(reason="Defaults to openpyxl, maybe not supported")
  828:             )
  829: 
  830:         result = pd.read_excel("testdateoverflow" + read_ext)
  831:         tm.assert_frame_equal(result, expected)
  832: 
  833:     def test_sheet_name(self, request, read_ext, engine, df_ref):
  834:         xfail_datetimes_with_pyxlsb(engine, request)
  835: 
  836:         filename = "test1"
  837:         sheet_name = "Sheet1"
  838: 
  839:         expected = df_ref
  840:         adjust_expected(expected, read_ext, engine)
  841: 
  842:         df1 = pd.read_excel(
  843:             filename + read_ext, sheet_name=sheet_name, index_col=0
  844:         )  # doc
  845:         df2 = pd.read_excel(filename + read_ext, index_col=0, sheet_name=sheet_name)
  846: 
  847:         tm.assert_frame_equal(df1, expected)
  848:         tm.assert_frame_equal(df2, expected)
  849: 
  850:     def test_excel_read_buffer(self, read_ext):
  851:         pth = "test1" + read_ext
  852:         expected = pd.read_excel(pth, sheet_name="Sheet1", index_col=0)
  853:         with open(pth, "rb") as f:
  854:             actual = pd.read_excel(f, sheet_name="Sheet1", index_col=0)
  855:             tm.assert_frame_equal(expected, actual)
  856: 
  857:     def test_bad_engine_raises(self):
  858:         bad_engine = "foo"
  859:         with pytest.raises(ValueError, match="Unknown engine: foo"):
  860:             pd.read_excel("", engine=bad_engine)
  861: 
  862:     @pytest.mark.parametrize(
  863:         "sheet_name",
  864:         [3, [0, 3], [3, 0], "Sheet4", ["Sheet1", "Sheet4"], ["Sheet4", "Sheet1"]],
  865:     )
  866:     def test_bad_sheetname_raises(self, read_ext, sheet_name):
  867:         # GH 39250
  868:         msg = "Worksheet index 3 is invalid|Worksheet named 'Sheet4' not found"
  869:         with pytest.raises(ValueError, match=msg):
  870:             pd.read_excel("blank" + read_ext, sheet_name=sheet_name)
  871: 
  872:     def test_missing_file_raises(self, read_ext):
  873:         bad_file = f"foo{read_ext}"
  874:         # CI tests with other languages, translates to "No such file or directory"
  875:         match = "|".join(
  876:             [
  877:                 "(No such file or directory",
  878:                 "жІЎжњ‰й‚ЈдёЄж–‡д»¶ж€–з›®еЅ•",
  879:                 "File o directory non esistente)",
  880:             ]
  881:         )
  882:         with pytest.raises(FileNotFoundError, match=match):
  883:             pd.read_excel(bad_file)
  884: 
  885:     def test_corrupt_bytes_raises(self, engine):
  886:         bad_stream = b"foo"
  887:         if engine is None:
  888:             error = ValueError
  889:             msg = (
  890:                 "Excel file format cannot be determined, you must "
  891:                 "specify an engine manually."
  892:             )
  893:         elif engine == "xlrd":
  894:             from xlrd import XLRDError
  895: 
  896:             error = XLRDError
  897:             msg = (
  898:                 "Unsupported format, or corrupt file: Expected BOF "
  899:                 "record; found b'foo'"
  900:             )
  901:         elif engine == "calamine":
  902:             from python_calamine import CalamineError
  903: 
  904:             error = CalamineError
  905:             msg = "Cannot detect file format"
  906:         else:
  907:             error = BadZipFile
  908:             msg = "File is not a zip file"
  909:         with pytest.raises(error, match=msg):
  910:             pd.read_excel(BytesIO(bad_stream))
  911: 
  912:     @pytest.mark.network
  913:     @pytest.mark.single_cpu
  914:     def test_read_from_http_url(self, httpserver, read_ext):
  915:         with open("test1" + read_ext, "rb") as f:
  916:             httpserver.serve_content(content=f.read())
  917:         url_table = pd.read_excel(httpserver.url)
  918:         local_table = pd.read_excel("test1" + read_ext)
  919:         tm.assert_frame_equal(url_table, local_table)
  920: 
  921:     @td.skip_if_not_us_locale
  922:     @pytest.mark.single_cpu
  923:     def test_read_from_s3_url(self, read_ext, s3_public_bucket, s3so):
  924:         # Bucket created in tests/io/conftest.py
  925:         with open("test1" + read_ext, "rb") as f:
  926:             s3_public_bucket.put_object(Key="test1" + read_ext, Body=f)
  927: 
  928:         url = f"s3://{s3_public_bucket.name}/test1" + read_ext
  929: 
  930:         url_table = pd.read_excel(url, storage_options=s3so)
  931:         local_table = pd.read_excel("test1" + read_ext)
  932:         tm.assert_frame_equal(url_table, local_table)
  933: 
  934:     @pytest.mark.single_cpu
  935:     def test_read_from_s3_object(self, read_ext, s3_public_bucket, s3so):
  936:         # GH 38788
  937:         # Bucket created in tests/io/conftest.py
  938:         with open("test1" + read_ext, "rb") as f:
  939:             s3_public_bucket.put_object(Key="test1" + read_ext, Body=f)
  940: 
  941:         import s3fs
  942: 
  943:         s3 = s3fs.S3FileSystem(**s3so)
  944: 
  945:         with s3.open(f"s3://{s3_public_bucket.name}/test1" + read_ext) as f:
  946:             url_table = pd.read_excel(f)
  947: 
  948:         local_table = pd.read_excel("test1" + read_ext)
  949:         tm.assert_frame_equal(url_table, local_table)
  950: 
  951:     @pytest.mark.slow
  952:     def test_read_from_file_url(self, read_ext, datapath):
  953:         # FILE
  954:         localtable = os.path.join(datapath("io", "data", "excel"), "test1" + read_ext)
  955:         local_table = pd.read_excel(localtable)
  956: 
  957:         try:
  958:             url_table = pd.read_excel("file://localhost/" + localtable)
  959:         except URLError:
  960:             # fails on some systems
  961:             platform_info = " ".join(platform.uname()).strip()
  962:             pytest.skip(f"failing on {platform_info}")
  963: 
  964:         tm.assert_frame_equal(url_table, local_table)
  965: 
  966:     def test_read_from_pathlib_path(self, read_ext):
  967:         # GH12655
  968:         str_path = "test1" + read_ext
  969:         expected = pd.read_excel(str_path, sheet_name="Sheet1", index_col=0)
  970: 
  971:         path_obj = Path("test1" + read_ext)
  972:         actual = pd.read_excel(path_obj, sheet_name="Sheet1", index_col=0)
  973: 
  974:         tm.assert_frame_equal(expected, actual)
  975: 
  976:     @td.skip_if_no("py.path")
  977:     def test_read_from_py_localpath(self, read_ext):
  978:         # GH12655
  979:         from py.path import local as LocalPath
  980: 
  981:         str_path = os.path.join("test1" + read_ext)
  982:         expected = pd.read_excel(str_path, sheet_name="Sheet1", index_col=0)
  983: 
  984:         path_obj = LocalPath().join("test1" + read_ext)
  985:         actual = pd.read_excel(path_obj, sheet_name="Sheet1", index_col=0)
  986: 
  987:         tm.assert_frame_equal(expected, actual)
  988: 
  989:     def test_close_from_py_localpath(self, read_ext):
  990:         # GH31467
  991:         str_path = os.path.join("test1" + read_ext)
  992:         with open(str_path, "rb") as f:
  993:             x = pd.read_excel(f, sheet_name="Sheet1", index_col=0)
  994:             del x
  995:             # should not throw an exception because the passed file was closed
  996:             f.read()
  997: 
  998:     def test_reader_seconds(self, request, engine, read_ext):
  999:         xfail_datetimes_with_pyxlsb(engine, request)
 1000: 
 1001:         # GH 55045
 1002:         if engine == "calamine" and read_ext == ".ods":
 1003:             request.applymarker(
 1004:                 pytest.mark.xfail(
 1005:                     reason="ODS file contains bad datetime (seconds as text)"
 1006:                 )
 1007:             )
 1008: 
 1009:         # Test reading times with and without milliseconds. GH5945.
 1010:         expected = DataFrame.from_dict(
 1011:             {
 1012:                 "Time": [
 1013:                     time(1, 2, 3),
 1014:                     time(2, 45, 56, 100000),
 1015:                     time(4, 29, 49, 200000),
 1016:                     time(6, 13, 42, 300000),
 1017:                     time(7, 57, 35, 400000),
 1018:                     time(9, 41, 28, 500000),
 1019:                     time(11, 25, 21, 600000),
 1020:                     time(13, 9, 14, 700000),
 1021:                     time(14, 53, 7, 800000),
 1022:                     time(16, 37, 0, 900000),
 1023:                     time(18, 20, 54),
 1024:                 ]
 1025:             }
 1026:         )
 1027: 
 1028:         actual = pd.read_excel("times_1900" + read_ext, sheet_name="Sheet1")
 1029:         tm.assert_frame_equal(actual, expected)
 1030: 
 1031:         actual = pd.read_excel("times_1904" + read_ext, sheet_name="Sheet1")
 1032:         tm.assert_frame_equal(actual, expected)
 1033: 
 1034:     def test_read_excel_multiindex(self, request, engine, read_ext):
 1035:         # see gh-4679
 1036:         xfail_datetimes_with_pyxlsb(engine, request)
 1037: 
 1038:         unit = get_exp_unit(read_ext, engine)
 1039: 
 1040:         mi = MultiIndex.from_product([["foo", "bar"], ["a", "b"]])
 1041:         mi_file = "testmultiindex" + read_ext
 1042: 
 1043:         # "mi_column" sheet
 1044:         expected = DataFrame(
 1045:             [
 1046:                 [1, 2.5, pd.Timestamp("2015-01-01"), True],
 1047:                 [2, 3.5, pd.Timestamp("2015-01-02"), False],
 1048:                 [3, 4.5, pd.Timestamp("2015-01-03"), False],
 1049:                 [4, 5.5, pd.Timestamp("2015-01-04"), True],
 1050:             ],
 1051:             columns=mi,
 1052:         )
 1053:         expected[mi[2]] = expected[mi[2]].astype(f"M8[{unit}]")
 1054: 
 1055:         actual = pd.read_excel(
 1056:             mi_file, sheet_name="mi_column", header=[0, 1], index_col=0
 1057:         )
 1058:         tm.assert_frame_equal(actual, expected)
 1059: 
 1060:         # "mi_index" sheet
 1061:         expected.index = mi
 1062:         expected.columns = ["a", "b", "c", "d"]
 1063: 
 1064:         actual = pd.read_excel(mi_file, sheet_name="mi_index", index_col=[0, 1])
 1065:         tm.assert_frame_equal(actual, expected)
 1066: 
 1067:         # "both" sheet
 1068:         expected.columns = mi
 1069: 
 1070:         actual = pd.read_excel(
 1071:             mi_file, sheet_name="both", index_col=[0, 1], header=[0, 1]
 1072:         )
 1073:         tm.assert_frame_equal(actual, expected)
 1074: 
 1075:         # "mi_index_name" sheet
 1076:         expected.columns = ["a", "b", "c", "d"]
 1077:         expected.index = mi.set_names(["ilvl1", "ilvl2"])
 1078: 
 1079:         actual = pd.read_excel(mi_file, sheet_name="mi_index_name", index_col=[0, 1])
 1080:         tm.assert_frame_equal(actual, expected)
 1081: 
 1082:         # "mi_column_name" sheet
 1083:         expected.index = list(range(4))
 1084:         expected.columns = mi.set_names(["c1", "c2"])
 1085:         actual = pd.read_excel(
 1086:             mi_file, sheet_name="mi_column_name", header=[0, 1], index_col=0
 1087:         )
 1088:         tm.assert_frame_equal(actual, expected)
 1089: 
 1090:         # see gh-11317
 1091:         # "name_with_int" sheet
 1092:         expected.columns = mi.set_levels([1, 2], level=1).set_names(["c1", "c2"])
 1093: 
 1094:         actual = pd.read_excel(
 1095:             mi_file, sheet_name="name_with_int", index_col=0, header=[0, 1]
 1096:         )
 1097:         tm.assert_frame_equal(actual, expected)
 1098: 
 1099:         # "both_name" sheet
 1100:         expected.columns = mi.set_names(["c1", "c2"])
 1101:         expected.index = mi.set_names(["ilvl1", "ilvl2"])
 1102: 
 1103:         actual = pd.read_excel(
 1104:             mi_file, sheet_name="both_name", index_col=[0, 1], header=[0, 1]
 1105:         )
 1106:         tm.assert_frame_equal(actual, expected)
 1107: 
 1108:         # "both_skiprows" sheet
 1109:         actual = pd.read_excel(
 1110:             mi_file,
 1111:             sheet_name="both_name_skiprows",
 1112:             index_col=[0, 1],
 1113:             header=[0, 1],
 1114:             skiprows=2,
 1115:         )
 1116:         tm.assert_frame_equal(actual, expected)
 1117: 
 1118:     @pytest.mark.parametrize(
 1119:         "sheet_name,idx_lvl2",
 1120:         [
 1121:             ("both_name_blank_after_mi_name", [np.nan, "b", "a", "b"]),
 1122:             ("both_name_multiple_blanks", [np.nan] * 4),
 1123:         ],
 1124:     )
 1125:     def test_read_excel_multiindex_blank_after_name(
 1126:         self, request, engine, read_ext, sheet_name, idx_lvl2
 1127:     ):
 1128:         # GH34673
 1129:         xfail_datetimes_with_pyxlsb(engine, request)
 1130: 
 1131:         mi_file = "testmultiindex" + read_ext
 1132:         mi = MultiIndex.from_product([["foo", "bar"], ["a", "b"]], names=["c1", "c2"])
 1133: 
 1134:         unit = get_exp_unit(read_ext, engine)
 1135: 
 1136:         expected = DataFrame(
 1137:             [
 1138:                 [1, 2.5, pd.Timestamp("2015-01-01"), True],
 1139:                 [2, 3.5, pd.Timestamp("2015-01-02"), False],
 1140:                 [3, 4.5, pd.Timestamp("2015-01-03"), False],
 1141:                 [4, 5.5, pd.Timestamp("2015-01-04"), True],
 1142:             ],
 1143:             columns=mi,
 1144:             index=MultiIndex.from_arrays(
 1145:                 (["foo", "foo", "bar", "bar"], idx_lvl2),
 1146:                 names=["ilvl1", "ilvl2"],
 1147:             ),
 1148:         )
 1149:         expected[mi[2]] = expected[mi[2]].astype(f"M8[{unit}]")
 1150:         result = pd.read_excel(
 1151:             mi_file,
 1152:             sheet_name=sheet_name,
 1153:             index_col=[0, 1],
 1154:             header=[0, 1],
 1155:         )
 1156:         tm.assert_frame_equal(result, expected)
 1157: 
 1158:     def test_read_excel_multiindex_header_only(self, read_ext):
 1159:         # see gh-11733.
 1160:         #
 1161:         # Don't try to parse a header name if there isn't one.
 1162:         mi_file = "testmultiindex" + read_ext
 1163:         result = pd.read_excel(mi_file, sheet_name="index_col_none", header=[0, 1])
 1164: 
 1165:         exp_columns = MultiIndex.from_product([("A", "B"), ("key", "val")])
 1166:         expected = DataFrame([[1, 2, 3, 4]] * 2, columns=exp_columns)
 1167:         tm.assert_frame_equal(result, expected)
 1168: 
 1169:     def test_excel_old_index_format(self, read_ext):
 1170:         # see gh-4679
 1171:         filename = "test_index_name_pre17" + read_ext
 1172: 
 1173:         # We detect headers to determine if index names exist, so
 1174:         # that "index" name in the "names" version of the data will
 1175:         # now be interpreted as rows that include null data.
 1176:         data = np.array(
 1177:             [
 1178:                 [np.nan, np.nan, np.nan, np.nan, np.nan],
 1179:                 ["R0C0", "R0C1", "R0C2", "R0C3", "R0C4"],
 1180:                 ["R1C0", "R1C1", "R1C2", "R1C3", "R1C4"],
 1181:                 ["R2C0", "R2C1", "R2C2", "R2C3", "R2C4"],
 1182:                 ["R3C0", "R3C1", "R3C2", "R3C3", "R3C4"],
 1183:                 ["R4C0", "R4C1", "R4C2", "R4C3", "R4C4"],
 1184:             ],
 1185:             dtype=object,
 1186:         )
 1187:         columns = ["C_l0_g0", "C_l0_g1", "C_l0_g2", "C_l0_g3", "C_l0_g4"]
 1188:         mi = MultiIndex(
 1189:             levels=[
 1190:                 ["R0", "R_l0_g0", "R_l0_g1", "R_l0_g2", "R_l0_g3", "R_l0_g4"],
 1191:                 ["R1", "R_l1_g0", "R_l1_g1", "R_l1_g2", "R_l1_g3", "R_l1_g4"],
 1192:             ],
 1193:             codes=[[0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5]],
 1194:             names=[None, None],
 1195:         )
 1196:         si = Index(
 1197:             ["R0", "R_l0_g0", "R_l0_g1", "R_l0_g2", "R_l0_g3", "R_l0_g4"], name=None
 1198:         )
 1199: 
 1200:         expected = DataFrame(data, index=si, columns=columns)
 1201: 
 1202:         actual = pd.read_excel(filename, sheet_name="single_names", index_col=0)
 1203:         tm.assert_frame_equal(actual, expected)
 1204: 
 1205:         expected.index = mi
 1206: 
 1207:         actual = pd.read_excel(filename, sheet_name="multi_names", index_col=[0, 1])
 1208:         tm.assert_frame_equal(actual, expected)
 1209: 
 1210:         # The analogous versions of the "names" version data
 1211:         # where there are explicitly no names for the indices.
 1212:         data = np.array(
 1213:             [
 1214:                 ["R0C0", "R0C1", "R0C2", "R0C3", "R0C4"],
 1215:                 ["R1C0", "R1C1", "R1C2", "R1C3", "R1C4"],
 1216:                 ["R2C0", "R2C1", "R2C2", "R2C3", "R2C4"],
 1217:                 ["R3C0", "R3C1", "R3C2", "R3C3", "R3C4"],
 1218:                 ["R4C0", "R4C1", "R4C2", "R4C3", "R4C4"],
 1219:             ]
 1220:         )
 1221:         columns = ["C_l0_g0", "C_l0_g1", "C_l0_g2", "C_l0_g3", "C_l0_g4"]
 1222:         mi = MultiIndex(
 1223:             levels=[
 1224:                 ["R_l0_g0", "R_l0_g1", "R_l0_g2", "R_l0_g3", "R_l0_g4"],
 1225:                 ["R_l1_g0", "R_l1_g1", "R_l1_g2", "R_l1_g3", "R_l1_g4"],
 1226:             ],
 1227:             codes=[[0, 1, 2, 3, 4], [0, 1, 2, 3, 4]],
 1228:             names=[None, None],
 1229:         )
 1230:         si = Index(["R_l0_g0", "R_l0_g1", "R_l0_g2", "R_l0_g3", "R_l0_g4"], name=None)
 1231: 
 1232:         expected = DataFrame(data, index=si, columns=columns)
 1233: 
 1234:         actual = pd.read_excel(filename, sheet_name="single_no_names", index_col=0)
 1235:         tm.assert_frame_equal(actual, expected)
 1236: 
 1237:         expected.index = mi
 1238: 
 1239:         actual = pd.read_excel(filename, sheet_name="multi_no_names", index_col=[0, 1])
 1240:         tm.assert_frame_equal(actual, expected)
 1241: 
 1242:     def test_read_excel_bool_header_arg(self, read_ext):
 1243:         # GH 6114
 1244:         msg = "Passing a bool to header is invalid"
 1245:         for arg in [True, False]:
 1246:             with pytest.raises(TypeError, match=msg):
 1247:                 pd.read_excel("test1" + read_ext, header=arg)
 1248: 
 1249:     def test_read_excel_skiprows(self, request, engine, read_ext):
 1250:         # GH 4903
 1251:         xfail_datetimes_with_pyxlsb(engine, request)
 1252: 
 1253:         unit = get_exp_unit(read_ext, engine)
 1254: 
 1255:         actual = pd.read_excel(
 1256:             "testskiprows" + read_ext, sheet_name="skiprows_list", skiprows=[0, 2]
 1257:         )
 1258:         expected = DataFrame(
 1259:             [
 1260:                 [1, 2.5, pd.Timestamp("2015-01-01"), True],
 1261:                 [2, 3.5, pd.Timestamp("2015-01-02"), False],
 1262:                 [3, 4.5, pd.Timestamp("2015-01-03"), False],
 1263:                 [4, 5.5, pd.Timestamp("2015-01-04"), True],
 1264:             ],
 1265:             columns=["a", "b", "c", "d"],
 1266:         )
 1267:         expected["c"] = expected["c"].astype(f"M8[{unit}]")
 1268:         tm.assert_frame_equal(actual, expected)
 1269: 
 1270:         actual = pd.read_excel(
 1271:             "testskiprows" + read_ext,
 1272:             sheet_name="skiprows_list",
 1273:             skiprows=np.array([0, 2]),
 1274:         )
 1275:         tm.assert_frame_equal(actual, expected)
 1276: 
 1277:         # GH36435
 1278:         actual = pd.read_excel(
 1279:             "testskiprows" + read_ext,
 1280:             sheet_name="skiprows_list",
 1281:             skiprows=lambda x: x in [0, 2],
 1282:         )
 1283:         tm.assert_frame_equal(actual, expected)
 1284: 
 1285:         actual = pd.read_excel(
 1286:             "testskiprows" + read_ext,
 1287:             sheet_name="skiprows_list",
 1288:             skiprows=3,
 1289:             names=["a", "b", "c", "d"],
 1290:         )
 1291:         expected = DataFrame(
 1292:             [
 1293:                 # [1, 2.5, pd.Timestamp("2015-01-01"), True],
 1294:                 [2, 3.5, pd.Timestamp("2015-01-02"), False],
 1295:                 [3, 4.5, pd.Timestamp("2015-01-03"), False],
 1296:                 [4, 5.5, pd.Timestamp("2015-01-04"), True],
 1297:             ],
 1298:             columns=["a", "b", "c", "d"],
 1299:         )
 1300:         expected["c"] = expected["c"].astype(f"M8[{unit}]")
 1301:         tm.assert_frame_equal(actual, expected)
 1302: 
 1303:     def test_read_excel_skiprows_callable_not_in(self, request, engine, read_ext):
 1304:         # GH 4903
 1305:         xfail_datetimes_with_pyxlsb(engine, request)
 1306:         unit = get_exp_unit(read_ext, engine)
 1307: 
 1308:         actual = pd.read_excel(
 1309:             "testskiprows" + read_ext,
 1310:             sheet_name="skiprows_list",
 1311:             skiprows=lambda x: x not in [1, 3, 5],
 1312:         )
 1313:         expected = DataFrame(
 1314:             [
 1315:                 [1, 2.5, pd.Timestamp("2015-01-01"), True],
 1316:                 # [2, 3.5, pd.Timestamp("2015-01-02"), False],
 1317:                 [3, 4.5, pd.Timestamp("2015-01-03"), False],
 1318:                 # [4, 5.5, pd.Timestamp("2015-01-04"), True],
 1319:             ],
 1320:             columns=["a", "b", "c", "d"],
 1321:         )
 1322:         expected["c"] = expected["c"].astype(f"M8[{unit}]")
 1323:         tm.assert_frame_equal(actual, expected)
 1324: 
 1325:     def test_read_excel_nrows(self, read_ext):
 1326:         # GH 16645
 1327:         num_rows_to_pull = 5
 1328:         actual = pd.read_excel("test1" + read_ext, nrows=num_rows_to_pull)
 1329:         expected = pd.read_excel("test1" + read_ext)
 1330:         expected = expected[:num_rows_to_pull]
 1331:         tm.assert_frame_equal(actual, expected)
 1332: 
 1333:     def test_read_excel_nrows_greater_than_nrows_in_file(self, read_ext):
 1334:         # GH 16645
 1335:         expected = pd.read_excel("test1" + read_ext)
 1336:         num_records_in_file = len(expected)
 1337:         num_rows_to_pull = num_records_in_file + 10
 1338:         actual = pd.read_excel("test1" + read_ext, nrows=num_rows_to_pull)
 1339:         tm.assert_frame_equal(actual, expected)
 1340: 
 1341:     def test_read_excel_nrows_non_integer_parameter(self, read_ext):
 1342:         # GH 16645
 1343:         msg = "'nrows' must be an integer >=0"
 1344:         with pytest.raises(ValueError, match=msg):
 1345:             pd.read_excel("test1" + read_ext, nrows="5")
 1346: 
 1347:     @pytest.mark.parametrize(
 1348:         "filename,sheet_name,header,index_col,skiprows",
 1349:         [
 1350:             ("testmultiindex", "mi_column", [0, 1], 0, None),
 1351:             ("testmultiindex", "mi_index", None, [0, 1], None),
 1352:             ("testmultiindex", "both", [0, 1], [0, 1], None),
 1353:             ("testmultiindex", "mi_column_name", [0, 1], 0, None),
 1354:             ("testskiprows", "skiprows_list", None, None, [0, 2]),
 1355:             ("testskiprows", "skiprows_list", None, None, lambda x: x in (0, 2)),
 1356:         ],
 1357:     )
 1358:     def test_read_excel_nrows_params(
 1359:         self, read_ext, filename, sheet_name, header, index_col, skiprows
 1360:     ):
 1361:         """
 1362:         For various parameters, we should get the same result whether we
 1363:         limit the rows during load (nrows=3) or after (df.iloc[:3]).
 1364:         """
 1365:         # GH 46894
 1366:         expected = pd.read_excel(
 1367:             filename + read_ext,
 1368:             sheet_name=sheet_name,
 1369:             header=header,
 1370:             index_col=index_col,
 1371:             skiprows=skiprows,
 1372:         ).iloc[:3]
 1373:         actual = pd.read_excel(
 1374:             filename + read_ext,
 1375:             sheet_name=sheet_name,
 1376:             header=header,
 1377:             index_col=index_col,
 1378:             skiprows=skiprows,
 1379:             nrows=3,
 1380:         )
 1381:         tm.assert_frame_equal(actual, expected)
 1382: 
 1383:     def test_deprecated_kwargs(self, read_ext):
 1384:         with pytest.raises(TypeError, match="but 3 positional arguments"):
 1385:             pd.read_excel("test1" + read_ext, "Sheet1", 0)
 1386: 
 1387:     def test_no_header_with_list_index_col(self, read_ext):
 1388:         # GH 31783
 1389:         file_name = "testmultiindex" + read_ext
 1390:         data = [("B", "B"), ("key", "val"), (3, 4), (3, 4)]
 1391:         idx = MultiIndex.from_tuples(
 1392:             [("A", "A"), ("key", "val"), (1, 2), (1, 2)], names=(0, 1)
 1393:         )
 1394:         expected = DataFrame(data, index=idx, columns=(2, 3))
 1395:         result = pd.read_excel(
 1396:             file_name, sheet_name="index_col_none", index_col=[0, 1], header=None
 1397:         )
 1398:         tm.assert_frame_equal(expected, result)
 1399: 
 1400:     def test_one_col_noskip_blank_line(self, read_ext):
 1401:         # GH 39808
 1402:         file_name = "one_col_blank_line" + read_ext
 1403:         data = [0.5, np.nan, 1, 2]
 1404:         expected = DataFrame(data, columns=["numbers"])
 1405:         result = pd.read_excel(file_name)
 1406:         tm.assert_frame_equal(result, expected)
 1407: 
 1408:     def test_multiheader_two_blank_lines(self, read_ext):
 1409:         # GH 40442
 1410:         file_name = "testmultiindex" + read_ext
 1411:         columns = MultiIndex.from_tuples([("a", "A"), ("b", "B")])
 1412:         data = [[np.nan, np.nan], [np.nan, np.nan], [1, 3], [2, 4]]
 1413:         expected = DataFrame(data, columns=columns)
 1414:         result = pd.read_excel(
 1415:             file_name, sheet_name="mi_column_empty_rows", header=[0, 1]
 1416:         )
 1417:         tm.assert_frame_equal(result, expected)
 1418: 
 1419:     def test_trailing_blanks(self, read_ext):
 1420:         """
 1421:         Sheets can contain blank cells with no data. Some of our readers
 1422:         were including those cells, creating many empty rows and columns
 1423:         """
 1424:         file_name = "trailing_blanks" + read_ext
 1425:         result = pd.read_excel(file_name)
 1426:         assert result.shape == (3, 3)
 1427: 
 1428:     def test_ignore_chartsheets_by_str(self, request, engine, read_ext):
 1429:         # GH 41448
 1430:         if read_ext == ".ods":
 1431:             pytest.skip("chartsheets do not exist in the ODF format")
 1432:         if engine == "pyxlsb":
 1433:             request.applymarker(
 1434:                 pytest.mark.xfail(
 1435:                     reason="pyxlsb can't distinguish chartsheets from worksheets"
 1436:                 )
 1437:             )
 1438:         with pytest.raises(ValueError, match="Worksheet named 'Chart1' not found"):
 1439:             pd.read_excel("chartsheet" + read_ext, sheet_name="Chart1")
 1440: 
 1441:     def test_ignore_chartsheets_by_int(self, request, engine, read_ext):
 1442:         # GH 41448
 1443:         if read_ext == ".ods":
 1444:             pytest.skip("chartsheets do not exist in the ODF format")
 1445:         if engine == "pyxlsb":
 1446:             request.applymarker(
 1447:                 pytest.mark.xfail(
 1448:                     reason="pyxlsb can't distinguish chartsheets from worksheets"
 1449:                 )
 1450:             )
 1451:         with pytest.raises(
 1452:             ValueError, match="Worksheet index 1 is invalid, 1 worksheets found"
 1453:         ):
 1454:             pd.read_excel("chartsheet" + read_ext, sheet_name=1)
 1455: 
 1456:     def test_euro_decimal_format(self, read_ext):
 1457:         # copied from read_csv
 1458:         result = pd.read_excel("test_decimal" + read_ext, decimal=",", skiprows=1)
 1459:         expected = DataFrame(
 1460:             [
 1461:                 [1, 1521.1541, 187101.9543, "ABC", "poi", 4.738797819],
 1462:                 [2, 121.12, 14897.76, "DEF", "uyt", 0.377320872],
 1463:                 [3, 878.158, 108013.434, "GHI", "rez", 2.735694704],
 1464:             ],
 1465:             columns=["Id", "Number1", "Number2", "Text1", "Text2", "Number3"],
 1466:         )
 1467:         tm.assert_frame_equal(result, expected)
 1468: 
 1469: 
 1470: class TestExcelFileRead:
 1471:     def test_deprecate_bytes_input(self, engine, read_ext):
 1472:         # GH 53830
 1473:         msg = (
 1474:             "Passing bytes to 'read_excel' is deprecated and "
 1475:             "will be removed in a future version. To read from a "
 1476:             "byte string, wrap it in a `BytesIO` object."
 1477:         )
 1478: 
 1479:         with tm.assert_produces_warning(
 1480:             FutureWarning, match=msg, raise_on_extra_warnings=False
 1481:         ):
 1482:             with open("test1" + read_ext, "rb") as f:
 1483:                 pd.read_excel(f.read(), engine=engine)
 1484: 
 1485:     @pytest.fixture(autouse=True)
 1486:     def cd_and_set_engine(self, engine, datapath, monkeypatch):
 1487:         """
 1488:         Change directory and set engine for ExcelFile objects.
 1489:         """
 1490:         func = partial(pd.ExcelFile, engine=engine)
 1491:         monkeypatch.chdir(datapath("io", "data", "excel"))
 1492:         monkeypatch.setattr(pd, "ExcelFile", func)
 1493: 
 1494:     def test_engine_used(self, read_ext, engine):
 1495:         expected_defaults = {
 1496:             "xlsx": "openpyxl",
 1497:             "xlsm": "openpyxl",
 1498:             "xlsb": "pyxlsb",
 1499:             "xls": "xlrd",
 1500:             "ods": "odf",
 1501:         }
 1502: 
 1503:         with pd.ExcelFile("test1" + read_ext) as excel:
 1504:             result = excel.engine
 1505: 
 1506:         if engine is not None:
 1507:             expected = engine
 1508:         else:
 1509:             expected = expected_defaults[read_ext[1:]]
 1510:         assert result == expected
 1511: 
 1512:     def test_excel_passes_na(self, read_ext):
 1513:         with pd.ExcelFile("test4" + read_ext) as excel:
 1514:             parsed = pd.read_excel(
 1515:                 excel, sheet_name="Sheet1", keep_default_na=False, na_values=["apple"]
 1516:             )
 1517:         expected = DataFrame(
 1518:             [["NA"], [1], ["NA"], [np.nan], ["rabbit"]], columns=["Test"]
 1519:         )
 1520:         tm.assert_frame_equal(parsed, expected)
 1521: 
 1522:         with pd.ExcelFile("test4" + read_ext) as excel:
 1523:             parsed = pd.read_excel(
 1524:                 excel, sheet_name="Sheet1", keep_default_na=True, na_values=["apple"]
 1525:             )
 1526:         expected = DataFrame(
 1527:             [[np.nan], [1], [np.nan], [np.nan], ["rabbit"]], columns=["Test"]
 1528:         )
 1529:         tm.assert_frame_equal(parsed, expected)
 1530: 
 1531:         # 13967
 1532:         with pd.ExcelFile("test5" + read_ext) as excel:
 1533:             parsed = pd.read_excel(
 1534:                 excel, sheet_name="Sheet1", keep_default_na=False, na_values=["apple"]
 1535:             )
 1536:         expected = DataFrame(
 1537:             [["1.#QNAN"], [1], ["nan"], [np.nan], ["rabbit"]], columns=["Test"]
 1538:         )
 1539:         tm.assert_frame_equal(parsed, expected)
 1540: 
 1541:         with pd.ExcelFile("test5" + read_ext) as excel:
 1542:             parsed = pd.read_excel(
 1543:                 excel, sheet_name="Sheet1", keep_default_na=True, na_values=["apple"]
 1544:             )
 1545:         expected = DataFrame(
 1546:             [[np.nan], [1], [np.nan], [np.nan], ["rabbit"]], columns=["Test"]
 1547:         )
 1548:         tm.assert_frame_equal(parsed, expected)
 1549: 
 1550:     @pytest.mark.parametrize("na_filter", [None, True, False])
 1551:     def test_excel_passes_na_filter(self, read_ext, na_filter):
 1552:         # gh-25453
 1553:         kwargs = {}
 1554: 
 1555:         if na_filter is not None:
 1556:             kwargs["na_filter"] = na_filter
 1557: 
 1558:         with pd.ExcelFile("test5" + read_ext) as excel:
 1559:             parsed = pd.read_excel(
 1560:                 excel,
 1561:                 sheet_name="Sheet1",
 1562:                 keep_default_na=True,
 1563:                 na_values=["apple"],
 1564:                 **kwargs,
 1565:             )
 1566: 
 1567:         if na_filter is False:
 1568:             expected = [["1.#QNAN"], [1], ["nan"], ["apple"], ["rabbit"]]
 1569:         else:
 1570:             expected = [[np.nan], [1], [np.nan], [np.nan], ["rabbit"]]
 1571: 
 1572:         expected = DataFrame(expected, columns=["Test"])
 1573:         tm.assert_frame_equal(parsed, expected)
 1574: 
 1575:     def test_excel_table_sheet_by_index(self, request, engine, read_ext, df_ref):
 1576:         xfail_datetimes_with_pyxlsb(engine, request)
 1577: 
 1578:         expected = df_ref
 1579:         adjust_expected(expected, read_ext, engine)
 1580: 
 1581:         with pd.ExcelFile("test1" + read_ext) as excel:
 1582:             df1 = pd.read_excel(excel, sheet_name=0, index_col=0)
 1583:             df2 = pd.read_excel(excel, sheet_name=1, skiprows=[1], index_col=0)
 1584:         tm.assert_frame_equal(df1, expected)
 1585:         tm.assert_frame_equal(df2, expected)
 1586: 
 1587:         with pd.ExcelFile("test1" + read_ext) as excel:
 1588:             df1 = excel.parse(0, index_col=0)
 1589:             df2 = excel.parse(1, skiprows=[1], index_col=0)
 1590:         tm.assert_frame_equal(df1, expected)
 1591:         tm.assert_frame_equal(df2, expected)
 1592: 
 1593:         with pd.ExcelFile("test1" + read_ext) as excel:
 1594:             df3 = pd.read_excel(excel, sheet_name=0, index_col=0, skipfooter=1)
 1595:         tm.assert_frame_equal(df3, df1.iloc[:-1])
 1596: 
 1597:         with pd.ExcelFile("test1" + read_ext) as excel:
 1598:             df3 = excel.parse(0, index_col=0, skipfooter=1)
 1599: 
 1600:         tm.assert_frame_equal(df3, df1.iloc[:-1])
 1601: 
 1602:     def test_sheet_name(self, request, engine, read_ext, df_ref):
 1603:         xfail_datetimes_with_pyxlsb(engine, request)
 1604: 
 1605:         expected = df_ref
 1606:         adjust_expected(expected, read_ext, engine)
 1607: 
 1608:         filename = "test1"
 1609:         sheet_name = "Sheet1"
 1610: 
 1611:         with pd.ExcelFile(filename + read_ext) as excel:
 1612:             df1_parse = excel.parse(sheet_name=sheet_name, index_col=0)  # doc
 1613: 
 1614:         with pd.ExcelFile(filename + read_ext) as excel:
 1615:             df2_parse = excel.parse(index_col=0, sheet_name=sheet_name)
 1616: 
 1617:         tm.assert_frame_equal(df1_parse, expected)
 1618:         tm.assert_frame_equal(df2_parse, expected)
 1619: 
 1620:     @pytest.mark.parametrize(
 1621:         "sheet_name",
 1622:         [3, [0, 3], [3, 0], "Sheet4", ["Sheet1", "Sheet4"], ["Sheet4", "Sheet1"]],
 1623:     )
 1624:     def test_bad_sheetname_raises(self, read_ext, sheet_name):
 1625:         # GH 39250
 1626:         msg = "Worksheet index 3 is invalid|Worksheet named 'Sheet4' not found"
 1627:         with pytest.raises(ValueError, match=msg):
 1628:             with pd.ExcelFile("blank" + read_ext) as excel:
 1629:                 excel.parse(sheet_name=sheet_name)
 1630: 
 1631:     def test_excel_read_buffer(self, engine, read_ext):
 1632:         pth = "test1" + read_ext
 1633:         expected = pd.read_excel(pth, sheet_name="Sheet1", index_col=0, engine=engine)
 1634: 
 1635:         with open(pth, "rb") as f:
 1636:             with pd.ExcelFile(f) as xls:
 1637:                 actual = pd.read_excel(xls, sheet_name="Sheet1", index_col=0)
 1638: 
 1639:         tm.assert_frame_equal(expected, actual)
 1640: 
 1641:     def test_reader_closes_file(self, engine, read_ext):
 1642:         with open("test1" + read_ext, "rb") as f:
 1643:             with pd.ExcelFile(f) as xlsx:
 1644:                 # parses okay
 1645:                 pd.read_excel(xlsx, sheet_name="Sheet1", index_col=0, engine=engine)
 1646: 
 1647:         assert f.closed
 1648: 
 1649:     def test_conflicting_excel_engines(self, read_ext):
 1650:         # GH 26566
 1651:         msg = "Engine should not be specified when passing an ExcelFile"
 1652: 
 1653:         with pd.ExcelFile("test1" + read_ext) as xl:
 1654:             with pytest.raises(ValueError, match=msg):
 1655:                 pd.read_excel(xl, engine="foo")
 1656: 
 1657:     def test_excel_read_binary(self, engine, read_ext):
 1658:         # GH 15914
 1659:         expected = pd.read_excel("test1" + read_ext, engine=engine)
 1660: 
 1661:         with open("test1" + read_ext, "rb") as f:
 1662:             data = f.read()
 1663: 
 1664:         actual = pd.read_excel(BytesIO(data), engine=engine)
 1665:         tm.assert_frame_equal(expected, actual)
 1666: 
 1667:     def test_excel_read_binary_via_read_excel(self, read_ext, engine):
 1668:         # GH 38424
 1669:         with open("test1" + read_ext, "rb") as f:
 1670:             result = pd.read_excel(f, engine=engine)
 1671:         expected = pd.read_excel("test1" + read_ext, engine=engine)
 1672:         tm.assert_frame_equal(result, expected)
 1673: 
 1674:     def test_read_excel_header_index_out_of_range(self, engine):
 1675:         # GH#43143
 1676:         with open("df_header_oob.xlsx", "rb") as f:
 1677:             with pytest.raises(ValueError, match="exceeds maximum"):
 1678:                 pd.read_excel(f, header=[0, 1])
 1679: 
 1680:     @pytest.mark.parametrize("filename", ["df_empty.xlsx", "df_equals.xlsx"])
 1681:     def test_header_with_index_col(self, filename):
 1682:         # GH 33476
 1683:         idx = Index(["Z"], name="I2")
 1684:         cols = MultiIndex.from_tuples([("A", "B"), ("A", "B.1")], names=["I11", "I12"])
 1685:         expected = DataFrame([[1, 3]], index=idx, columns=cols, dtype="int64")
 1686:         result = pd.read_excel(
 1687:             filename, sheet_name="Sheet1", index_col=0, header=[0, 1]
 1688:         )
 1689:         tm.assert_frame_equal(expected, result)
 1690: 
 1691:     def test_read_datetime_multiindex(self, request, engine, read_ext):
 1692:         # GH 34748
 1693:         xfail_datetimes_with_pyxlsb(engine, request)
 1694: 
 1695:         f = "test_datetime_mi" + read_ext
 1696:         with pd.ExcelFile(f) as excel:
 1697:             actual = pd.read_excel(excel, header=[0, 1], index_col=0, engine=engine)
 1698: 
 1699:         unit = get_exp_unit(read_ext, engine)
 1700:         dti = pd.DatetimeIndex(["2020-02-29", "2020-03-01"], dtype=f"M8[{unit}]")
 1701:         expected_column_index = MultiIndex.from_arrays(
 1702:             [dti[:1], dti[1:]],
 1703:             names=[
 1704:                 dti[0].to_pydatetime(),
 1705:                 dti[1].to_pydatetime(),
 1706:             ],
 1707:         )
 1708:         expected = DataFrame([], index=[], columns=expected_column_index)
 1709: 
 1710:         tm.assert_frame_equal(expected, actual)
 1711: 
 1712:     def test_engine_invalid_option(self, read_ext):
 1713:         # read_ext includes the '.' hence the weird formatting
 1714:         with pytest.raises(ValueError, match="Value must be one of *"):
 1715:             with pd.option_context(f"io.excel{read_ext}.reader", "abc"):
 1716:                 pass
 1717: 
 1718:     def test_ignore_chartsheets(self, request, engine, read_ext):
 1719:         # GH 41448
 1720:         if read_ext == ".ods":
 1721:             pytest.skip("chartsheets do not exist in the ODF format")
 1722:         if engine == "pyxlsb":
 1723:             request.applymarker(
 1724:                 pytest.mark.xfail(
 1725:                     reason="pyxlsb can't distinguish chartsheets from worksheets"
 1726:                 )
 1727:             )
 1728:         with pd.ExcelFile("chartsheet" + read_ext) as excel:
 1729:             assert excel.sheet_names == ["Sheet1"]
 1730: 
 1731:     def test_corrupt_files_closed(self, engine, read_ext):
 1732:         # GH41778
 1733:         errors = (BadZipFile,)
 1734:         if engine is None:
 1735:             pytest.skip(f"Invalid test for engine={engine}")
 1736:         elif engine == "xlrd":
 1737:             import xlrd
 1738: 
 1739:             errors = (BadZipFile, xlrd.biffh.XLRDError)
 1740:         elif engine == "calamine":
 1741:             from python_calamine import CalamineError
 1742: 
 1743:             errors = (CalamineError,)
 1744: 
 1745:         with tm.ensure_clean(f"corrupt{read_ext}") as file:
 1746:             Path(file).write_text("corrupt", encoding="utf-8")
 1747:             with tm.assert_produces_warning(False):
 1748:                 try:
 1749:                     pd.ExcelFile(file, engine=engine)
 1750:                 except errors:
 1751:                     pass
