    1: """
    2: Tests that quoting specifications are properly handled
    3: during parsing for all of the parsers defined in parsers.py
    4: """
    5: 
    6: import csv
    7: from io import StringIO
    8: 
    9: import pytest
   10: 
   11: from pandas.compat import PY311
   12: from pandas.errors import ParserError
   13: 
   14: from pandas import DataFrame
   15: import pandas._testing as tm
   16: 
   17: pytestmark = pytest.mark.filterwarnings(
   18:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   19: )
   20: xfail_pyarrow = pytest.mark.usefixtures("pyarrow_xfail")
   21: skip_pyarrow = pytest.mark.usefixtures("pyarrow_skip")
   22: 
   23: 
   24: @pytest.mark.parametrize(
   25:     "kwargs,msg",
   26:     [
   27:         ({"quotechar": "foo"}, '"quotechar" must be a(n)? 1-character string'),
   28:         (
   29:             {"quotechar": None, "quoting": csv.QUOTE_MINIMAL},
   30:             "quotechar must be set if quoting enabled",
   31:         ),
   32:         ({"quotechar": 2}, '"quotechar" must be string( or None)?, not int'),
   33:     ],
   34: )
   35: @skip_pyarrow  # ParserError: CSV parse error: Empty CSV file or block
   36: def test_bad_quote_char(all_parsers, kwargs, msg):
   37:     data = "1,2,3"
   38:     parser = all_parsers
   39: 
   40:     with pytest.raises(TypeError, match=msg):
   41:         parser.read_csv(StringIO(data), **kwargs)
   42: 
   43: 
   44: @pytest.mark.parametrize(
   45:     "quoting,msg",
   46:     [
   47:         ("foo", '"quoting" must be an integer|Argument'),
   48:         (10, 'bad "quoting" value'),  # quoting must be in the range [0, 3]
   49:     ],
   50: )
   51: @xfail_pyarrow  # ValueError: The 'quoting' option is not supported
   52: def test_bad_quoting(all_parsers, quoting, msg):
   53:     data = "1,2,3"
   54:     parser = all_parsers
   55: 
   56:     with pytest.raises(TypeError, match=msg):
   57:         parser.read_csv(StringIO(data), quoting=quoting)
   58: 
   59: 
   60: def test_quote_char_basic(all_parsers):
   61:     parser = all_parsers
   62:     data = 'a,b,c\n1,2,"cat"'
   63:     expected = DataFrame([[1, 2, "cat"]], columns=["a", "b", "c"])
   64: 
   65:     result = parser.read_csv(StringIO(data), quotechar='"')
   66:     tm.assert_frame_equal(result, expected)
   67: 
   68: 
   69: @pytest.mark.parametrize("quote_char", ["~", "*", "%", "$", "@", "P"])
   70: def test_quote_char_various(all_parsers, quote_char):
   71:     parser = all_parsers
   72:     expected = DataFrame([[1, 2, "cat"]], columns=["a", "b", "c"])
   73: 
   74:     data = 'a,b,c\n1,2,"cat"'
   75:     new_data = data.replace('"', quote_char)
   76: 
   77:     result = parser.read_csv(StringIO(new_data), quotechar=quote_char)
   78:     tm.assert_frame_equal(result, expected)
   79: 
   80: 
   81: @xfail_pyarrow  # ValueError: The 'quoting' option is not supported
   82: @pytest.mark.parametrize("quoting", [csv.QUOTE_MINIMAL, csv.QUOTE_NONE])
   83: @pytest.mark.parametrize("quote_char", ["", None])
   84: def test_null_quote_char(all_parsers, quoting, quote_char):
   85:     kwargs = {"quotechar": quote_char, "quoting": quoting}
   86:     data = "a,b,c\n1,2,3"
   87:     parser = all_parsers
   88: 
   89:     if quoting != csv.QUOTE_NONE:
   90:         # Sanity checking.
   91:         msg = (
   92:             '"quotechar" must be a 1-character string'
   93:             if PY311 and all_parsers.engine == "python" and quote_char == ""
   94:             else "quotechar must be set if quoting enabled"
   95:         )
   96: 
   97:         with pytest.raises(TypeError, match=msg):
   98:             parser.read_csv(StringIO(data), **kwargs)
   99:     elif not (PY311 and all_parsers.engine == "python"):
  100:         # Python 3.11+ doesn't support null/blank quote chars in their csv parsers
  101:         expected = DataFrame([[1, 2, 3]], columns=["a", "b", "c"])
  102:         result = parser.read_csv(StringIO(data), **kwargs)
  103:         tm.assert_frame_equal(result, expected)
  104: 
  105: 
  106: @pytest.mark.parametrize(
  107:     "kwargs,exp_data",
  108:     [
  109:         ({}, [[1, 2, "foo"]]),  # Test default.
  110:         # QUOTE_MINIMAL only applies to CSV writing, so no effect on reading.
  111:         ({"quotechar": '"', "quoting": csv.QUOTE_MINIMAL}, [[1, 2, "foo"]]),
  112:         # QUOTE_MINIMAL only applies to CSV writing, so no effect on reading.
  113:         ({"quotechar": '"', "quoting": csv.QUOTE_ALL}, [[1, 2, "foo"]]),
  114:         # QUOTE_NONE tells the reader to do no special handling
  115:         # of quote characters and leave them alone.
  116:         ({"quotechar": '"', "quoting": csv.QUOTE_NONE}, [[1, 2, '"foo"']]),
  117:         # QUOTE_NONNUMERIC tells the reader to cast
  118:         # all non-quoted fields to float
  119:         ({"quotechar": '"', "quoting": csv.QUOTE_NONNUMERIC}, [[1.0, 2.0, "foo"]]),
  120:     ],
  121: )
  122: @xfail_pyarrow  # ValueError: The 'quoting' option is not supported
  123: def test_quoting_various(all_parsers, kwargs, exp_data):
  124:     data = '1,2,"foo"'
  125:     parser = all_parsers
  126:     columns = ["a", "b", "c"]
  127: 
  128:     result = parser.read_csv(StringIO(data), names=columns, **kwargs)
  129:     expected = DataFrame(exp_data, columns=columns)
  130:     tm.assert_frame_equal(result, expected)
  131: 
  132: 
  133: @pytest.mark.parametrize(
  134:     "doublequote,exp_data", [(True, [[3, '4 " 5']]), (False, [[3, '4 " 5"']])]
  135: )
  136: def test_double_quote(all_parsers, doublequote, exp_data, request):
  137:     parser = all_parsers
  138:     data = 'a,b\n3,"4 "" 5"'
  139: 
  140:     if parser.engine == "pyarrow" and not doublequote:
  141:         mark = pytest.mark.xfail(reason="Mismatched result")
  142:         request.applymarker(mark)
  143: 
  144:     result = parser.read_csv(StringIO(data), quotechar='"', doublequote=doublequote)
  145:     expected = DataFrame(exp_data, columns=["a", "b"])
  146:     tm.assert_frame_equal(result, expected)
  147: 
  148: 
  149: @pytest.mark.parametrize("quotechar", ['"', "\u0001"])
  150: def test_quotechar_unicode(all_parsers, quotechar):
  151:     # see gh-14477
  152:     data = "a\n1"
  153:     parser = all_parsers
  154:     expected = DataFrame({"a": [1]})
  155: 
  156:     result = parser.read_csv(StringIO(data), quotechar=quotechar)
  157:     tm.assert_frame_equal(result, expected)
  158: 
  159: 
  160: @pytest.mark.parametrize("balanced", [True, False])
  161: def test_unbalanced_quoting(all_parsers, balanced, request):
  162:     # see gh-22789.
  163:     parser = all_parsers
  164:     data = 'a,b,c\n1,2,"3'
  165: 
  166:     if parser.engine == "pyarrow" and not balanced:
  167:         mark = pytest.mark.xfail(reason="Mismatched result")
  168:         request.applymarker(mark)
  169: 
  170:     if balanced:
  171:         # Re-balance the quoting and read in without errors.
  172:         expected = DataFrame([[1, 2, 3]], columns=["a", "b", "c"])
  173:         result = parser.read_csv(StringIO(data + '"'))
  174:         tm.assert_frame_equal(result, expected)
  175:     else:
  176:         msg = (
  177:             "EOF inside string starting at row 1"
  178:             if parser.engine == "c"
  179:             else "unexpected end of data"
  180:         )
  181: 
  182:         with pytest.raises(ParserError, match=msg):
  183:             parser.read_csv(StringIO(data))
