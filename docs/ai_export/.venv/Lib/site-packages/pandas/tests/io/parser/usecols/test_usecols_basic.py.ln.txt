    1: """
    2: Tests the usecols functionality during parsing
    3: for all of the parsers defined in parsers.py
    4: """
    5: from io import StringIO
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: from pandas.errors import ParserError
   11: 
   12: from pandas import (
   13:     DataFrame,
   14:     Index,
   15:     array,
   16: )
   17: import pandas._testing as tm
   18: 
   19: pytestmark = pytest.mark.filterwarnings(
   20:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   21: )
   22: 
   23: _msg_validate_usecols_arg = (
   24:     "'usecols' must either be list-like "
   25:     "of all strings, all unicode, all "
   26:     "integers or a callable."
   27: )
   28: _msg_validate_usecols_names = (
   29:     "Usecols do not match columns, columns expected but not found: {0}"
   30: )
   31: _msg_pyarrow_requires_names = (
   32:     "The pyarrow engine does not allow 'usecols' to be integer column "
   33:     "positions. Pass a list of string column names instead."
   34: )
   35: 
   36: xfail_pyarrow = pytest.mark.usefixtures("pyarrow_xfail")
   37: skip_pyarrow = pytest.mark.usefixtures("pyarrow_skip")
   38: 
   39: pytestmark = pytest.mark.filterwarnings(
   40:     "ignore:Passing a BlockManager to DataFrame is deprecated:DeprecationWarning"
   41: )
   42: 
   43: 
   44: def test_raise_on_mixed_dtype_usecols(all_parsers):
   45:     # See gh-12678
   46:     data = """a,b,c
   47:         1000,2000,3000
   48:         4000,5000,6000
   49:         """
   50:     usecols = [0, "b", 2]
   51:     parser = all_parsers
   52: 
   53:     with pytest.raises(ValueError, match=_msg_validate_usecols_arg):
   54:         parser.read_csv(StringIO(data), usecols=usecols)
   55: 
   56: 
   57: @pytest.mark.parametrize("usecols", [(1, 2), ("b", "c")])
   58: def test_usecols(all_parsers, usecols, request):
   59:     data = """\
   60: a,b,c
   61: 1,2,3
   62: 4,5,6
   63: 7,8,9
   64: 10,11,12"""
   65:     parser = all_parsers
   66:     if parser.engine == "pyarrow" and isinstance(usecols[0], int):
   67:         with pytest.raises(ValueError, match=_msg_pyarrow_requires_names):
   68:             parser.read_csv(StringIO(data), usecols=usecols)
   69:         return
   70: 
   71:     result = parser.read_csv(StringIO(data), usecols=usecols)
   72: 
   73:     expected = DataFrame([[2, 3], [5, 6], [8, 9], [11, 12]], columns=["b", "c"])
   74:     tm.assert_frame_equal(result, expected)
   75: 
   76: 
   77: def test_usecols_with_names(all_parsers):
   78:     data = """\
   79: a,b,c
   80: 1,2,3
   81: 4,5,6
   82: 7,8,9
   83: 10,11,12"""
   84:     parser = all_parsers
   85:     names = ["foo", "bar"]
   86: 
   87:     if parser.engine == "pyarrow":
   88:         with pytest.raises(ValueError, match=_msg_pyarrow_requires_names):
   89:             parser.read_csv(StringIO(data), names=names, usecols=[1, 2], header=0)
   90:         return
   91: 
   92:     result = parser.read_csv(StringIO(data), names=names, usecols=[1, 2], header=0)
   93: 
   94:     expected = DataFrame([[2, 3], [5, 6], [8, 9], [11, 12]], columns=names)
   95:     tm.assert_frame_equal(result, expected)
   96: 
   97: 
   98: @pytest.mark.parametrize(
   99:     "names,usecols", [(["b", "c"], [1, 2]), (["a", "b", "c"], ["b", "c"])]
  100: )
  101: def test_usecols_relative_to_names(all_parsers, names, usecols):
  102:     data = """\
  103: 1,2,3
  104: 4,5,6
  105: 7,8,9
  106: 10,11,12"""
  107:     parser = all_parsers
  108:     if parser.engine == "pyarrow" and not isinstance(usecols[0], int):
  109:         # ArrowKeyError: Column 'fb' in include_columns does not exist
  110:         pytest.skip(reason="https://github.com/apache/arrow/issues/38676")
  111: 
  112:     result = parser.read_csv(StringIO(data), names=names, header=None, usecols=usecols)
  113: 
  114:     expected = DataFrame([[2, 3], [5, 6], [8, 9], [11, 12]], columns=["b", "c"])
  115:     tm.assert_frame_equal(result, expected)
  116: 
  117: 
  118: def test_usecols_relative_to_names2(all_parsers):
  119:     # see gh-5766
  120:     data = """\
  121: 1,2,3
  122: 4,5,6
  123: 7,8,9
  124: 10,11,12"""
  125:     parser = all_parsers
  126: 
  127:     result = parser.read_csv(
  128:         StringIO(data), names=["a", "b"], header=None, usecols=[0, 1]
  129:     )
  130: 
  131:     expected = DataFrame([[1, 2], [4, 5], [7, 8], [10, 11]], columns=["a", "b"])
  132:     tm.assert_frame_equal(result, expected)
  133: 
  134: 
  135: # regex mismatch: "Length mismatch: Expected axis has 1 elements"
  136: @xfail_pyarrow
  137: def test_usecols_name_length_conflict(all_parsers):
  138:     data = """\
  139: 1,2,3
  140: 4,5,6
  141: 7,8,9
  142: 10,11,12"""
  143:     parser = all_parsers
  144:     msg = "Number of passed names did not match number of header fields in the file"
  145:     with pytest.raises(ValueError, match=msg):
  146:         parser.read_csv(StringIO(data), names=["a", "b"], header=None, usecols=[1])
  147: 
  148: 
  149: def test_usecols_single_string(all_parsers):
  150:     # see gh-20558
  151:     parser = all_parsers
  152:     data = """foo, bar, baz
  153: 1000, 2000, 3000
  154: 4000, 5000, 6000"""
  155: 
  156:     with pytest.raises(ValueError, match=_msg_validate_usecols_arg):
  157:         parser.read_csv(StringIO(data), usecols="foo")
  158: 
  159: 
  160: @skip_pyarrow  # CSV parse error in one case, AttributeError in another
  161: @pytest.mark.parametrize(
  162:     "data", ["a,b,c,d\n1,2,3,4\n5,6,7,8", "a,b,c,d\n1,2,3,4,\n5,6,7,8,"]
  163: )
  164: def test_usecols_index_col_false(all_parsers, data):
  165:     # see gh-9082
  166:     parser = all_parsers
  167:     usecols = ["a", "c", "d"]
  168:     expected = DataFrame({"a": [1, 5], "c": [3, 7], "d": [4, 8]})
  169: 
  170:     result = parser.read_csv(StringIO(data), usecols=usecols, index_col=False)
  171:     tm.assert_frame_equal(result, expected)
  172: 
  173: 
  174: @pytest.mark.parametrize("index_col", ["b", 0])
  175: @pytest.mark.parametrize("usecols", [["b", "c"], [1, 2]])
  176: def test_usecols_index_col_conflict(all_parsers, usecols, index_col, request):
  177:     # see gh-4201: test that index_col as integer reflects usecols
  178:     parser = all_parsers
  179:     data = "a,b,c,d\nA,a,1,one\nB,b,2,two"
  180: 
  181:     if parser.engine == "pyarrow" and isinstance(usecols[0], int):
  182:         with pytest.raises(ValueError, match=_msg_pyarrow_requires_names):
  183:             parser.read_csv(StringIO(data), usecols=usecols, index_col=index_col)
  184:         return
  185: 
  186:     expected = DataFrame({"c": [1, 2]}, index=Index(["a", "b"], name="b"))
  187: 
  188:     result = parser.read_csv(StringIO(data), usecols=usecols, index_col=index_col)
  189:     tm.assert_frame_equal(result, expected)
  190: 
  191: 
  192: def test_usecols_index_col_conflict2(all_parsers):
  193:     # see gh-4201: test that index_col as integer reflects usecols
  194:     parser = all_parsers
  195:     data = "a,b,c,d\nA,a,1,one\nB,b,2,two"
  196: 
  197:     expected = DataFrame({"b": ["a", "b"], "c": [1, 2], "d": ("one", "two")})
  198:     expected = expected.set_index(["b", "c"])
  199: 
  200:     result = parser.read_csv(
  201:         StringIO(data), usecols=["b", "c", "d"], index_col=["b", "c"]
  202:     )
  203:     tm.assert_frame_equal(result, expected)
  204: 
  205: 
  206: @skip_pyarrow  # CSV parse error: Expected 3 columns, got 4
  207: def test_usecols_implicit_index_col(all_parsers):
  208:     # see gh-2654
  209:     parser = all_parsers
  210:     data = "a,b,c\n4,apple,bat,5.7\n8,orange,cow,10"
  211: 
  212:     result = parser.read_csv(StringIO(data), usecols=["a", "b"])
  213:     expected = DataFrame({"a": ["apple", "orange"], "b": ["bat", "cow"]}, index=[4, 8])
  214:     tm.assert_frame_equal(result, expected)
  215: 
  216: 
  217: def test_usecols_index_col_middle(all_parsers):
  218:     # GH#9098
  219:     parser = all_parsers
  220:     data = """a,b,c,d
  221: 1,2,3,4
  222: """
  223:     result = parser.read_csv(StringIO(data), usecols=["b", "c", "d"], index_col="c")
  224:     expected = DataFrame({"b": [2], "d": [4]}, index=Index([3], name="c"))
  225:     tm.assert_frame_equal(result, expected)
  226: 
  227: 
  228: def test_usecols_index_col_end(all_parsers):
  229:     # GH#9098
  230:     parser = all_parsers
  231:     data = """a,b,c,d
  232: 1,2,3,4
  233: """
  234:     result = parser.read_csv(StringIO(data), usecols=["b", "c", "d"], index_col="d")
  235:     expected = DataFrame({"b": [2], "c": [3]}, index=Index([4], name="d"))
  236:     tm.assert_frame_equal(result, expected)
  237: 
  238: 
  239: def test_usecols_regex_sep(all_parsers):
  240:     # see gh-2733
  241:     parser = all_parsers
  242:     data = "a  b  c\n4  apple  bat  5.7\n8  orange  cow  10"
  243: 
  244:     if parser.engine == "pyarrow":
  245:         msg = "the 'pyarrow' engine does not support regex separators"
  246:         with pytest.raises(ValueError, match=msg):
  247:             parser.read_csv(StringIO(data), sep=r"\s+", usecols=("a", "b"))
  248:         return
  249: 
  250:     result = parser.read_csv(StringIO(data), sep=r"\s+", usecols=("a", "b"))
  251: 
  252:     expected = DataFrame({"a": ["apple", "orange"], "b": ["bat", "cow"]}, index=[4, 8])
  253:     tm.assert_frame_equal(result, expected)
  254: 
  255: 
  256: def test_usecols_with_whitespace(all_parsers):
  257:     parser = all_parsers
  258:     data = "a  b  c\n4  apple  bat  5.7\n8  orange  cow  10"
  259: 
  260:     depr_msg = "The 'delim_whitespace' keyword in pd.read_csv is deprecated"
  261: 
  262:     if parser.engine == "pyarrow":
  263:         msg = "The 'delim_whitespace' option is not supported with the 'pyarrow' engine"
  264:         with pytest.raises(ValueError, match=msg):
  265:             with tm.assert_produces_warning(
  266:                 FutureWarning, match=depr_msg, check_stacklevel=False
  267:             ):
  268:                 parser.read_csv(
  269:                     StringIO(data), delim_whitespace=True, usecols=("a", "b")
  270:                 )
  271:         return
  272: 
  273:     with tm.assert_produces_warning(
  274:         FutureWarning, match=depr_msg, check_stacklevel=False
  275:     ):
  276:         result = parser.read_csv(
  277:             StringIO(data), delim_whitespace=True, usecols=("a", "b")
  278:         )
  279:     expected = DataFrame({"a": ["apple", "orange"], "b": ["bat", "cow"]}, index=[4, 8])
  280:     tm.assert_frame_equal(result, expected)
  281: 
  282: 
  283: @pytest.mark.parametrize(
  284:     "usecols,expected",
  285:     [
  286:         # Column selection by index.
  287:         ([0, 1], DataFrame(data=[[1000, 2000], [4000, 5000]], columns=["2", "0"])),
  288:         # Column selection by name.
  289:         (
  290:             ["0", "1"],
  291:             DataFrame(data=[[2000, 3000], [5000, 6000]], columns=["0", "1"]),
  292:         ),
  293:     ],
  294: )
  295: def test_usecols_with_integer_like_header(all_parsers, usecols, expected, request):
  296:     parser = all_parsers
  297:     data = """2,0,1
  298: 1000,2000,3000
  299: 4000,5000,6000"""
  300: 
  301:     if parser.engine == "pyarrow" and isinstance(usecols[0], int):
  302:         with pytest.raises(ValueError, match=_msg_pyarrow_requires_names):
  303:             parser.read_csv(StringIO(data), usecols=usecols)
  304:         return
  305: 
  306:     result = parser.read_csv(StringIO(data), usecols=usecols)
  307:     tm.assert_frame_equal(result, expected)
  308: 
  309: 
  310: @xfail_pyarrow  # mismatched shape
  311: def test_empty_usecols(all_parsers):
  312:     data = "a,b,c\n1,2,3\n4,5,6"
  313:     expected = DataFrame(columns=Index([]))
  314:     parser = all_parsers
  315: 
  316:     result = parser.read_csv(StringIO(data), usecols=set())
  317:     tm.assert_frame_equal(result, expected)
  318: 
  319: 
  320: def test_np_array_usecols(all_parsers):
  321:     # see gh-12546
  322:     parser = all_parsers
  323:     data = "a,b,c\n1,2,3"
  324:     usecols = np.array(["a", "b"])
  325: 
  326:     expected = DataFrame([[1, 2]], columns=usecols)
  327:     result = parser.read_csv(StringIO(data), usecols=usecols)
  328:     tm.assert_frame_equal(result, expected)
  329: 
  330: 
  331: @pytest.mark.parametrize(
  332:     "usecols,expected",
  333:     [
  334:         (
  335:             lambda x: x.upper() in ["AAA", "BBB", "DDD"],
  336:             DataFrame(
  337:                 {
  338:                     "AaA": {
  339:                         0: 0.056674972999999997,
  340:                         1: 2.6132309819999997,
  341:                         2: 3.5689350380000002,
  342:                     },
  343:                     "bBb": {0: 8, 1: 2, 2: 7},
  344:                     "ddd": {0: "a", 1: "b", 2: "a"},
  345:                 }
  346:             ),
  347:         ),
  348:         (lambda x: False, DataFrame(columns=Index([]))),
  349:     ],
  350: )
  351: def test_callable_usecols(all_parsers, usecols, expected):
  352:     # see gh-14154
  353:     data = """AaA,bBb,CCC,ddd
  354: 0.056674973,8,True,a
  355: 2.613230982,2,False,b
  356: 3.568935038,7,False,a"""
  357:     parser = all_parsers
  358: 
  359:     if parser.engine == "pyarrow":
  360:         msg = "The pyarrow engine does not allow 'usecols' to be a callable"
  361:         with pytest.raises(ValueError, match=msg):
  362:             parser.read_csv(StringIO(data), usecols=usecols)
  363:         return
  364: 
  365:     result = parser.read_csv(StringIO(data), usecols=usecols)
  366:     tm.assert_frame_equal(result, expected)
  367: 
  368: 
  369: # ArrowKeyError: Column 'fa' in include_columns does not exist in CSV file
  370: @skip_pyarrow
  371: @pytest.mark.parametrize("usecols", [["a", "c"], lambda x: x in ["a", "c"]])
  372: def test_incomplete_first_row(all_parsers, usecols):
  373:     # see gh-6710
  374:     data = "1,2\n1,2,3"
  375:     parser = all_parsers
  376:     names = ["a", "b", "c"]
  377:     expected = DataFrame({"a": [1, 1], "c": [np.nan, 3]})
  378: 
  379:     result = parser.read_csv(StringIO(data), names=names, usecols=usecols)
  380:     tm.assert_frame_equal(result, expected)
  381: 
  382: 
  383: @skip_pyarrow  # CSV parse error: Expected 3 columns, got 4
  384: @pytest.mark.parametrize(
  385:     "data,usecols,kwargs,expected",
  386:     [
  387:         # see gh-8985
  388:         (
  389:             "19,29,39\n" * 2 + "10,20,30,40",
  390:             [0, 1, 2],
  391:             {"header": None},
  392:             DataFrame([[19, 29, 39], [19, 29, 39], [10, 20, 30]]),
  393:         ),
  394:         # see gh-9549
  395:         (
  396:             ("A,B,C\n1,2,3\n3,4,5\n1,2,4,5,1,6\n1,2,3,,,1,\n1,2,3\n5,6,7"),
  397:             ["A", "B", "C"],
  398:             {},
  399:             DataFrame(
  400:                 {
  401:                     "A": [1, 3, 1, 1, 1, 5],
  402:                     "B": [2, 4, 2, 2, 2, 6],
  403:                     "C": [3, 5, 4, 3, 3, 7],
  404:                 }
  405:             ),
  406:         ),
  407:     ],
  408: )
  409: def test_uneven_length_cols(all_parsers, data, usecols, kwargs, expected):
  410:     # see gh-8985
  411:     parser = all_parsers
  412:     result = parser.read_csv(StringIO(data), usecols=usecols, **kwargs)
  413:     tm.assert_frame_equal(result, expected)
  414: 
  415: 
  416: @pytest.mark.parametrize(
  417:     "usecols,kwargs,expected,msg",
  418:     [
  419:         (
  420:             ["a", "b", "c", "d"],
  421:             {},
  422:             DataFrame({"a": [1, 5], "b": [2, 6], "c": [3, 7], "d": [4, 8]}),
  423:             None,
  424:         ),
  425:         (
  426:             ["a", "b", "c", "f"],
  427:             {},
  428:             None,
  429:             _msg_validate_usecols_names.format(r"\['f'\]"),
  430:         ),
  431:         (["a", "b", "f"], {}, None, _msg_validate_usecols_names.format(r"\['f'\]")),
  432:         (
  433:             ["a", "b", "f", "g"],
  434:             {},
  435:             None,
  436:             _msg_validate_usecols_names.format(r"\[('f', 'g'|'g', 'f')\]"),
  437:         ),
  438:         # see gh-14671
  439:         (
  440:             None,
  441:             {"header": 0, "names": ["A", "B", "C", "D"]},
  442:             DataFrame({"A": [1, 5], "B": [2, 6], "C": [3, 7], "D": [4, 8]}),
  443:             None,
  444:         ),
  445:         (
  446:             ["A", "B", "C", "f"],
  447:             {"header": 0, "names": ["A", "B", "C", "D"]},
  448:             None,
  449:             _msg_validate_usecols_names.format(r"\['f'\]"),
  450:         ),
  451:         (
  452:             ["A", "B", "f"],
  453:             {"names": ["A", "B", "C", "D"]},
  454:             None,
  455:             _msg_validate_usecols_names.format(r"\['f'\]"),
  456:         ),
  457:     ],
  458: )
  459: def test_raises_on_usecols_names_mismatch(
  460:     all_parsers, usecols, kwargs, expected, msg, request
  461: ):
  462:     data = "a,b,c,d\n1,2,3,4\n5,6,7,8"
  463:     kwargs.update(usecols=usecols)
  464:     parser = all_parsers
  465: 
  466:     if parser.engine == "pyarrow" and not (
  467:         usecols is not None and expected is not None
  468:     ):
  469:         # everything but the first case
  470:         # ArrowKeyError: Column 'f' in include_columns does not exist in CSV file
  471:         pytest.skip(reason="https://github.com/apache/arrow/issues/38676")
  472: 
  473:     if expected is None:
  474:         with pytest.raises(ValueError, match=msg):
  475:             parser.read_csv(StringIO(data), **kwargs)
  476:     else:
  477:         result = parser.read_csv(StringIO(data), **kwargs)
  478:         tm.assert_frame_equal(result, expected)
  479: 
  480: 
  481: @pytest.mark.parametrize("usecols", [["A", "C"], [0, 2]])
  482: def test_usecols_subset_names_mismatch_orig_columns(all_parsers, usecols, request):
  483:     data = "a,b,c,d\n1,2,3,4\n5,6,7,8"
  484:     names = ["A", "B", "C", "D"]
  485:     parser = all_parsers
  486: 
  487:     if parser.engine == "pyarrow":
  488:         if isinstance(usecols[0], int):
  489:             with pytest.raises(ValueError, match=_msg_pyarrow_requires_names):
  490:                 parser.read_csv(StringIO(data), header=0, names=names, usecols=usecols)
  491:             return
  492:         # "pyarrow.lib.ArrowKeyError: Column 'A' in include_columns does not exist"
  493:         pytest.skip(reason="https://github.com/apache/arrow/issues/38676")
  494: 
  495:     result = parser.read_csv(StringIO(data), header=0, names=names, usecols=usecols)
  496:     expected = DataFrame({"A": [1, 5], "C": [3, 7]})
  497:     tm.assert_frame_equal(result, expected)
  498: 
  499: 
  500: @pytest.mark.parametrize("names", [None, ["a", "b"]])
  501: def test_usecols_indices_out_of_bounds(all_parsers, names):
  502:     # GH#25623 & GH 41130; enforced in 2.0
  503:     parser = all_parsers
  504:     data = """
  505: a,b
  506: 1,2
  507:     """
  508: 
  509:     err = ParserError
  510:     msg = "Defining usecols with out-of-bounds"
  511:     if parser.engine == "pyarrow":
  512:         err = ValueError
  513:         msg = _msg_pyarrow_requires_names
  514: 
  515:     with pytest.raises(err, match=msg):
  516:         parser.read_csv(StringIO(data), usecols=[0, 2], names=names, header=0)
  517: 
  518: 
  519: def test_usecols_additional_columns(all_parsers):
  520:     # GH#46997
  521:     parser = all_parsers
  522:     usecols = lambda header: header.strip() in ["a", "b", "c"]
  523: 
  524:     if parser.engine == "pyarrow":
  525:         msg = "The pyarrow engine does not allow 'usecols' to be a callable"
  526:         with pytest.raises(ValueError, match=msg):
  527:             parser.read_csv(StringIO("a,b\nx,y,z"), index_col=False, usecols=usecols)
  528:         return
  529:     result = parser.read_csv(StringIO("a,b\nx,y,z"), index_col=False, usecols=usecols)
  530:     expected = DataFrame({"a": ["x"], "b": "y"})
  531:     tm.assert_frame_equal(result, expected)
  532: 
  533: 
  534: def test_usecols_additional_columns_integer_columns(all_parsers):
  535:     # GH#46997
  536:     parser = all_parsers
  537:     usecols = lambda header: header.strip() in ["0", "1"]
  538:     if parser.engine == "pyarrow":
  539:         msg = "The pyarrow engine does not allow 'usecols' to be a callable"
  540:         with pytest.raises(ValueError, match=msg):
  541:             parser.read_csv(StringIO("0,1\nx,y,z"), index_col=False, usecols=usecols)
  542:         return
  543:     result = parser.read_csv(StringIO("0,1\nx,y,z"), index_col=False, usecols=usecols)
  544:     expected = DataFrame({"0": ["x"], "1": "y"})
  545:     tm.assert_frame_equal(result, expected)
  546: 
  547: 
  548: def test_usecols_dtype(all_parsers):
  549:     parser = all_parsers
  550:     data = """
  551: col1,col2,col3
  552: a,1,x
  553: b,2,y
  554: """
  555:     result = parser.read_csv(
  556:         StringIO(data),
  557:         usecols=["col1", "col2"],
  558:         dtype={"col1": "string", "col2": "uint8", "col3": "string"},
  559:     )
  560:     expected = DataFrame(
  561:         {"col1": array(["a", "b"]), "col2": np.array([1, 2], dtype="uint8")}
  562:     )
  563:     tm.assert_frame_equal(result, expected)
