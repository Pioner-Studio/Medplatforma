    1: """
    2: Tests that dialects are properly handled during parsing
    3: for all of the parsers defined in parsers.py
    4: """
    5: 
    6: import csv
    7: from io import StringIO
    8: 
    9: import pytest
   10: 
   11: from pandas.errors import ParserWarning
   12: 
   13: from pandas import DataFrame
   14: import pandas._testing as tm
   15: 
   16: pytestmark = pytest.mark.filterwarnings(
   17:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   18: )
   19: 
   20: 
   21: @pytest.fixture
   22: def custom_dialect():
   23:     dialect_name = "weird"
   24:     dialect_kwargs = {
   25:         "doublequote": False,
   26:         "escapechar": "~",
   27:         "delimiter": ":",
   28:         "skipinitialspace": False,
   29:         "quotechar": "~",
   30:         "quoting": 3,
   31:     }
   32:     return dialect_name, dialect_kwargs
   33: 
   34: 
   35: def test_dialect(all_parsers):
   36:     parser = all_parsers
   37:     data = """\
   38: label1,label2,label3
   39: index1,"a,c,e
   40: index2,b,d,f
   41: """
   42: 
   43:     dia = csv.excel()
   44:     dia.quoting = csv.QUOTE_NONE
   45: 
   46:     if parser.engine == "pyarrow":
   47:         msg = "The 'dialect' option is not supported with the 'pyarrow' engine"
   48:         with pytest.raises(ValueError, match=msg):
   49:             parser.read_csv(StringIO(data), dialect=dia)
   50:         return
   51: 
   52:     df = parser.read_csv(StringIO(data), dialect=dia)
   53: 
   54:     data = """\
   55: label1,label2,label3
   56: index1,a,c,e
   57: index2,b,d,f
   58: """
   59:     exp = parser.read_csv(StringIO(data))
   60:     exp.replace("a", '"a', inplace=True)
   61:     tm.assert_frame_equal(df, exp)
   62: 
   63: 
   64: def test_dialect_str(all_parsers):
   65:     dialect_name = "mydialect"
   66:     parser = all_parsers
   67:     data = """\
   68: fruit:vegetable
   69: apple:broccoli
   70: pear:tomato
   71: """
   72:     exp = DataFrame({"fruit": ["apple", "pear"], "vegetable": ["broccoli", "tomato"]})
   73: 
   74:     with tm.with_csv_dialect(dialect_name, delimiter=":"):
   75:         if parser.engine == "pyarrow":
   76:             msg = "The 'dialect' option is not supported with the 'pyarrow' engine"
   77:             with pytest.raises(ValueError, match=msg):
   78:                 parser.read_csv(StringIO(data), dialect=dialect_name)
   79:             return
   80: 
   81:         df = parser.read_csv(StringIO(data), dialect=dialect_name)
   82:         tm.assert_frame_equal(df, exp)
   83: 
   84: 
   85: def test_invalid_dialect(all_parsers):
   86:     class InvalidDialect:
   87:         pass
   88: 
   89:     data = "a\n1"
   90:     parser = all_parsers
   91:     msg = "Invalid dialect"
   92: 
   93:     with pytest.raises(ValueError, match=msg):
   94:         parser.read_csv(StringIO(data), dialect=InvalidDialect)
   95: 
   96: 
   97: @pytest.mark.parametrize(
   98:     "arg",
   99:     [None, "doublequote", "escapechar", "skipinitialspace", "quotechar", "quoting"],
  100: )
  101: @pytest.mark.parametrize("value", ["dialect", "default", "other"])
  102: def test_dialect_conflict_except_delimiter(all_parsers, custom_dialect, arg, value):
  103:     # see gh-23761.
  104:     dialect_name, dialect_kwargs = custom_dialect
  105:     parser = all_parsers
  106: 
  107:     expected = DataFrame({"a": [1], "b": [2]})
  108:     data = "a:b\n1:2"
  109: 
  110:     warning_klass = None
  111:     kwds = {}
  112: 
  113:     # arg=None tests when we pass in the dialect without any other arguments.
  114:     if arg is not None:
  115:         if value == "dialect":  # No conflict --> no warning.
  116:             kwds[arg] = dialect_kwargs[arg]
  117:         elif value == "default":  # Default --> no warning.
  118:             from pandas.io.parsers.base_parser import parser_defaults
  119: 
  120:             kwds[arg] = parser_defaults[arg]
  121:         else:  # Non-default + conflict with dialect --> warning.
  122:             warning_klass = ParserWarning
  123:             kwds[arg] = "blah"
  124: 
  125:     with tm.with_csv_dialect(dialect_name, **dialect_kwargs):
  126:         if parser.engine == "pyarrow":
  127:             msg = "The 'dialect' option is not supported with the 'pyarrow' engine"
  128:             with pytest.raises(ValueError, match=msg):
  129:                 parser.read_csv_check_warnings(
  130:                     # No warning bc we raise
  131:                     None,
  132:                     "Conflicting values for",
  133:                     StringIO(data),
  134:                     dialect=dialect_name,
  135:                     **kwds,
  136:                 )
  137:             return
  138:         result = parser.read_csv_check_warnings(
  139:             warning_klass,
  140:             "Conflicting values for",
  141:             StringIO(data),
  142:             dialect=dialect_name,
  143:             **kwds,
  144:         )
  145:         tm.assert_frame_equal(result, expected)
  146: 
  147: 
  148: @pytest.mark.parametrize(
  149:     "kwargs,warning_klass",
  150:     [
  151:         ({"sep": ","}, None),  # sep is default --> sep_override=True
  152:         ({"sep": "."}, ParserWarning),  # sep isn't default --> sep_override=False
  153:         ({"delimiter": ":"}, None),  # No conflict
  154:         ({"delimiter": None}, None),  # Default arguments --> sep_override=True
  155:         ({"delimiter": ","}, ParserWarning),  # Conflict
  156:         ({"delimiter": "."}, ParserWarning),  # Conflict
  157:     ],
  158:     ids=[
  159:         "sep-override-true",
  160:         "sep-override-false",
  161:         "delimiter-no-conflict",
  162:         "delimiter-default-arg",
  163:         "delimiter-conflict",
  164:         "delimiter-conflict2",
  165:     ],
  166: )
  167: def test_dialect_conflict_delimiter(all_parsers, custom_dialect, kwargs, warning_klass):
  168:     # see gh-23761.
  169:     dialect_name, dialect_kwargs = custom_dialect
  170:     parser = all_parsers
  171: 
  172:     expected = DataFrame({"a": [1], "b": [2]})
  173:     data = "a:b\n1:2"
  174: 
  175:     with tm.with_csv_dialect(dialect_name, **dialect_kwargs):
  176:         if parser.engine == "pyarrow":
  177:             msg = "The 'dialect' option is not supported with the 'pyarrow' engine"
  178:             with pytest.raises(ValueError, match=msg):
  179:                 parser.read_csv_check_warnings(
  180:                     # no warning bc we raise
  181:                     None,
  182:                     "Conflicting values for 'delimiter'",
  183:                     StringIO(data),
  184:                     dialect=dialect_name,
  185:                     **kwargs,
  186:                 )
  187:             return
  188:         result = parser.read_csv_check_warnings(
  189:             warning_klass,
  190:             "Conflicting values for 'delimiter'",
  191:             StringIO(data),
  192:             dialect=dialect_name,
  193:             **kwargs,
  194:         )
  195:         tm.assert_frame_equal(result, expected)
