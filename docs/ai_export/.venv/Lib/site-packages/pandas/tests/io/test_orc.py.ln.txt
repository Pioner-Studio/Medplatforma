    1: """ test orc compat """
    2: import datetime
    3: from decimal import Decimal
    4: from io import BytesIO
    5: import os
    6: import pathlib
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: import pandas as pd
   12: from pandas import read_orc
   13: import pandas._testing as tm
   14: from pandas.core.arrays import StringArray
   15: 
   16: pytest.importorskip("pyarrow.orc")
   17: 
   18: import pyarrow as pa
   19: 
   20: pytestmark = pytest.mark.filterwarnings(
   21:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   22: )
   23: 
   24: 
   25: @pytest.fixture
   26: def dirpath(datapath):
   27:     return datapath("io", "data", "orc")
   28: 
   29: 
   30: @pytest.fixture(
   31:     params=[
   32:         np.array([1, 20], dtype="uint64"),
   33:         pd.Series(["a", "b", "a"], dtype="category"),
   34:         [pd.Interval(left=0, right=2), pd.Interval(left=0, right=5)],
   35:         [pd.Period("2022-01-03", freq="D"), pd.Period("2022-01-04", freq="D")],
   36:     ]
   37: )
   38: def orc_writer_dtypes_not_supported(request):
   39:     # Examples of dataframes with dtypes for which conversion to ORC
   40:     # hasn't been implemented yet, that is, Category, unsigned integers,
   41:     # interval, period and sparse.
   42:     return pd.DataFrame({"unimpl": request.param})
   43: 
   44: 
   45: def test_orc_reader_empty(dirpath):
   46:     columns = [
   47:         "boolean1",
   48:         "byte1",
   49:         "short1",
   50:         "int1",
   51:         "long1",
   52:         "float1",
   53:         "double1",
   54:         "bytes1",
   55:         "string1",
   56:     ]
   57:     dtypes = [
   58:         "bool",
   59:         "int8",
   60:         "int16",
   61:         "int32",
   62:         "int64",
   63:         "float32",
   64:         "float64",
   65:         "object",
   66:         "object",
   67:     ]
   68:     expected = pd.DataFrame(index=pd.RangeIndex(0))
   69:     for colname, dtype in zip(columns, dtypes):
   70:         expected[colname] = pd.Series(dtype=dtype)
   71: 
   72:     inputfile = os.path.join(dirpath, "TestOrcFile.emptyFile.orc")
   73:     got = read_orc(inputfile, columns=columns)
   74: 
   75:     tm.assert_equal(expected, got)
   76: 
   77: 
   78: def test_orc_reader_basic(dirpath):
   79:     data = {
   80:         "boolean1": np.array([False, True], dtype="bool"),
   81:         "byte1": np.array([1, 100], dtype="int8"),
   82:         "short1": np.array([1024, 2048], dtype="int16"),
   83:         "int1": np.array([65536, 65536], dtype="int32"),
   84:         "long1": np.array([9223372036854775807, 9223372036854775807], dtype="int64"),
   85:         "float1": np.array([1.0, 2.0], dtype="float32"),
   86:         "double1": np.array([-15.0, -5.0], dtype="float64"),
   87:         "bytes1": np.array([b"\x00\x01\x02\x03\x04", b""], dtype="object"),
   88:         "string1": np.array(["hi", "bye"], dtype="object"),
   89:     }
   90:     expected = pd.DataFrame.from_dict(data)
   91: 
   92:     inputfile = os.path.join(dirpath, "TestOrcFile.test1.orc")
   93:     got = read_orc(inputfile, columns=data.keys())
   94: 
   95:     tm.assert_equal(expected, got)
   96: 
   97: 
   98: def test_orc_reader_decimal(dirpath):
   99:     # Only testing the first 10 rows of data
  100:     data = {
  101:         "_col0": np.array(
  102:             [
  103:                 Decimal("-1000.50000"),
  104:                 Decimal("-999.60000"),
  105:                 Decimal("-998.70000"),
  106:                 Decimal("-997.80000"),
  107:                 Decimal("-996.90000"),
  108:                 Decimal("-995.10000"),
  109:                 Decimal("-994.11000"),
  110:                 Decimal("-993.12000"),
  111:                 Decimal("-992.13000"),
  112:                 Decimal("-991.14000"),
  113:             ],
  114:             dtype="object",
  115:         )
  116:     }
  117:     expected = pd.DataFrame.from_dict(data)
  118: 
  119:     inputfile = os.path.join(dirpath, "TestOrcFile.decimal.orc")
  120:     got = read_orc(inputfile).iloc[:10]
  121: 
  122:     tm.assert_equal(expected, got)
  123: 
  124: 
  125: def test_orc_reader_date_low(dirpath):
  126:     data = {
  127:         "time": np.array(
  128:             [
  129:                 "1900-05-05 12:34:56.100000",
  130:                 "1900-05-05 12:34:56.100100",
  131:                 "1900-05-05 12:34:56.100200",
  132:                 "1900-05-05 12:34:56.100300",
  133:                 "1900-05-05 12:34:56.100400",
  134:                 "1900-05-05 12:34:56.100500",
  135:                 "1900-05-05 12:34:56.100600",
  136:                 "1900-05-05 12:34:56.100700",
  137:                 "1900-05-05 12:34:56.100800",
  138:                 "1900-05-05 12:34:56.100900",
  139:             ],
  140:             dtype="datetime64[ns]",
  141:         ),
  142:         "date": np.array(
  143:             [
  144:                 datetime.date(1900, 12, 25),
  145:                 datetime.date(1900, 12, 25),
  146:                 datetime.date(1900, 12, 25),
  147:                 datetime.date(1900, 12, 25),
  148:                 datetime.date(1900, 12, 25),
  149:                 datetime.date(1900, 12, 25),
  150:                 datetime.date(1900, 12, 25),
  151:                 datetime.date(1900, 12, 25),
  152:                 datetime.date(1900, 12, 25),
  153:                 datetime.date(1900, 12, 25),
  154:             ],
  155:             dtype="object",
  156:         ),
  157:     }
  158:     expected = pd.DataFrame.from_dict(data)
  159: 
  160:     inputfile = os.path.join(dirpath, "TestOrcFile.testDate1900.orc")
  161:     got = read_orc(inputfile).iloc[:10]
  162: 
  163:     tm.assert_equal(expected, got)
  164: 
  165: 
  166: def test_orc_reader_date_high(dirpath):
  167:     data = {
  168:         "time": np.array(
  169:             [
  170:                 "2038-05-05 12:34:56.100000",
  171:                 "2038-05-05 12:34:56.100100",
  172:                 "2038-05-05 12:34:56.100200",
  173:                 "2038-05-05 12:34:56.100300",
  174:                 "2038-05-05 12:34:56.100400",
  175:                 "2038-05-05 12:34:56.100500",
  176:                 "2038-05-05 12:34:56.100600",
  177:                 "2038-05-05 12:34:56.100700",
  178:                 "2038-05-05 12:34:56.100800",
  179:                 "2038-05-05 12:34:56.100900",
  180:             ],
  181:             dtype="datetime64[ns]",
  182:         ),
  183:         "date": np.array(
  184:             [
  185:                 datetime.date(2038, 12, 25),
  186:                 datetime.date(2038, 12, 25),
  187:                 datetime.date(2038, 12, 25),
  188:                 datetime.date(2038, 12, 25),
  189:                 datetime.date(2038, 12, 25),
  190:                 datetime.date(2038, 12, 25),
  191:                 datetime.date(2038, 12, 25),
  192:                 datetime.date(2038, 12, 25),
  193:                 datetime.date(2038, 12, 25),
  194:                 datetime.date(2038, 12, 25),
  195:             ],
  196:             dtype="object",
  197:         ),
  198:     }
  199:     expected = pd.DataFrame.from_dict(data)
  200: 
  201:     inputfile = os.path.join(dirpath, "TestOrcFile.testDate2038.orc")
  202:     got = read_orc(inputfile).iloc[:10]
  203: 
  204:     tm.assert_equal(expected, got)
  205: 
  206: 
  207: def test_orc_reader_snappy_compressed(dirpath):
  208:     data = {
  209:         "int1": np.array(
  210:             [
  211:                 -1160101563,
  212:                 1181413113,
  213:                 2065821249,
  214:                 -267157795,
  215:                 172111193,
  216:                 1752363137,
  217:                 1406072123,
  218:                 1911809390,
  219:                 -1308542224,
  220:                 -467100286,
  221:             ],
  222:             dtype="int32",
  223:         ),
  224:         "string1": np.array(
  225:             [
  226:                 "f50dcb8",
  227:                 "382fdaaa",
  228:                 "90758c6",
  229:                 "9e8caf3f",
  230:                 "ee97332b",
  231:                 "d634da1",
  232:                 "2bea4396",
  233:                 "d67d89e8",
  234:                 "ad71007e",
  235:                 "e8c82066",
  236:             ],
  237:             dtype="object",
  238:         ),
  239:     }
  240:     expected = pd.DataFrame.from_dict(data)
  241: 
  242:     inputfile = os.path.join(dirpath, "TestOrcFile.testSnappy.orc")
  243:     got = read_orc(inputfile).iloc[:10]
  244: 
  245:     tm.assert_equal(expected, got)
  246: 
  247: 
  248: def test_orc_roundtrip_file(dirpath):
  249:     # GH44554
  250:     # PyArrow gained ORC write support with the current argument order
  251:     pytest.importorskip("pyarrow")
  252: 
  253:     data = {
  254:         "boolean1": np.array([False, True], dtype="bool"),
  255:         "byte1": np.array([1, 100], dtype="int8"),
  256:         "short1": np.array([1024, 2048], dtype="int16"),
  257:         "int1": np.array([65536, 65536], dtype="int32"),
  258:         "long1": np.array([9223372036854775807, 9223372036854775807], dtype="int64"),
  259:         "float1": np.array([1.0, 2.0], dtype="float32"),
  260:         "double1": np.array([-15.0, -5.0], dtype="float64"),
  261:         "bytes1": np.array([b"\x00\x01\x02\x03\x04", b""], dtype="object"),
  262:         "string1": np.array(["hi", "bye"], dtype="object"),
  263:     }
  264:     expected = pd.DataFrame.from_dict(data)
  265: 
  266:     with tm.ensure_clean() as path:
  267:         expected.to_orc(path)
  268:         got = read_orc(path)
  269: 
  270:         tm.assert_equal(expected, got)
  271: 
  272: 
  273: def test_orc_roundtrip_bytesio():
  274:     # GH44554
  275:     # PyArrow gained ORC write support with the current argument order
  276:     pytest.importorskip("pyarrow")
  277: 
  278:     data = {
  279:         "boolean1": np.array([False, True], dtype="bool"),
  280:         "byte1": np.array([1, 100], dtype="int8"),
  281:         "short1": np.array([1024, 2048], dtype="int16"),
  282:         "int1": np.array([65536, 65536], dtype="int32"),
  283:         "long1": np.array([9223372036854775807, 9223372036854775807], dtype="int64"),
  284:         "float1": np.array([1.0, 2.0], dtype="float32"),
  285:         "double1": np.array([-15.0, -5.0], dtype="float64"),
  286:         "bytes1": np.array([b"\x00\x01\x02\x03\x04", b""], dtype="object"),
  287:         "string1": np.array(["hi", "bye"], dtype="object"),
  288:     }
  289:     expected = pd.DataFrame.from_dict(data)
  290: 
  291:     bytes = expected.to_orc()
  292:     got = read_orc(BytesIO(bytes))
  293: 
  294:     tm.assert_equal(expected, got)
  295: 
  296: 
  297: def test_orc_writer_dtypes_not_supported(orc_writer_dtypes_not_supported):
  298:     # GH44554
  299:     # PyArrow gained ORC write support with the current argument order
  300:     pytest.importorskip("pyarrow")
  301: 
  302:     msg = "The dtype of one or more columns is not supported yet."
  303:     with pytest.raises(NotImplementedError, match=msg):
  304:         orc_writer_dtypes_not_supported.to_orc()
  305: 
  306: 
  307: def test_orc_dtype_backend_pyarrow():
  308:     pytest.importorskip("pyarrow")
  309:     df = pd.DataFrame(
  310:         {
  311:             "string": list("abc"),
  312:             "string_with_nan": ["a", np.nan, "c"],
  313:             "string_with_none": ["a", None, "c"],
  314:             "bytes": [b"foo", b"bar", None],
  315:             "int": list(range(1, 4)),
  316:             "float": np.arange(4.0, 7.0, dtype="float64"),
  317:             "float_with_nan": [2.0, np.nan, 3.0],
  318:             "bool": [True, False, True],
  319:             "bool_with_na": [True, False, None],
  320:             "datetime": pd.date_range("20130101", periods=3),
  321:             "datetime_with_nat": [
  322:                 pd.Timestamp("20130101"),
  323:                 pd.NaT,
  324:                 pd.Timestamp("20130103"),
  325:             ],
  326:         }
  327:     )
  328: 
  329:     bytes_data = df.copy().to_orc()
  330:     result = read_orc(BytesIO(bytes_data), dtype_backend="pyarrow")
  331: 
  332:     expected = pd.DataFrame(
  333:         {
  334:             col: pd.arrays.ArrowExtensionArray(pa.array(df[col], from_pandas=True))
  335:             for col in df.columns
  336:         }
  337:     )
  338: 
  339:     tm.assert_frame_equal(result, expected)
  340: 
  341: 
  342: def test_orc_dtype_backend_numpy_nullable():
  343:     # GH#50503
  344:     pytest.importorskip("pyarrow")
  345:     df = pd.DataFrame(
  346:         {
  347:             "string": list("abc"),
  348:             "string_with_nan": ["a", np.nan, "c"],
  349:             "string_with_none": ["a", None, "c"],
  350:             "int": list(range(1, 4)),
  351:             "int_with_nan": pd.Series([1, pd.NA, 3], dtype="Int64"),
  352:             "na_only": pd.Series([pd.NA, pd.NA, pd.NA], dtype="Int64"),
  353:             "float": np.arange(4.0, 7.0, dtype="float64"),
  354:             "float_with_nan": [2.0, np.nan, 3.0],
  355:             "bool": [True, False, True],
  356:             "bool_with_na": [True, False, None],
  357:         }
  358:     )
  359: 
  360:     bytes_data = df.copy().to_orc()
  361:     result = read_orc(BytesIO(bytes_data), dtype_backend="numpy_nullable")
  362: 
  363:     expected = pd.DataFrame(
  364:         {
  365:             "string": StringArray(np.array(["a", "b", "c"], dtype=np.object_)),
  366:             "string_with_nan": StringArray(
  367:                 np.array(["a", pd.NA, "c"], dtype=np.object_)
  368:             ),
  369:             "string_with_none": StringArray(
  370:                 np.array(["a", pd.NA, "c"], dtype=np.object_)
  371:             ),
  372:             "int": pd.Series([1, 2, 3], dtype="Int64"),
  373:             "int_with_nan": pd.Series([1, pd.NA, 3], dtype="Int64"),
  374:             "na_only": pd.Series([pd.NA, pd.NA, pd.NA], dtype="Int64"),
  375:             "float": pd.Series([4.0, 5.0, 6.0], dtype="Float64"),
  376:             "float_with_nan": pd.Series([2.0, pd.NA, 3.0], dtype="Float64"),
  377:             "bool": pd.Series([True, False, True], dtype="boolean"),
  378:             "bool_with_na": pd.Series([True, False, pd.NA], dtype="boolean"),
  379:         }
  380:     )
  381: 
  382:     tm.assert_frame_equal(result, expected)
  383: 
  384: 
  385: def test_orc_uri_path():
  386:     expected = pd.DataFrame({"int": list(range(1, 4))})
  387:     with tm.ensure_clean("tmp.orc") as path:
  388:         expected.to_orc(path)
  389:         uri = pathlib.Path(path).as_uri()
  390:         result = read_orc(uri)
  391:     tm.assert_frame_equal(result, expected)
  392: 
  393: 
  394: @pytest.mark.parametrize(
  395:     "index",
  396:     [
  397:         pd.RangeIndex(start=2, stop=5, step=1),
  398:         pd.RangeIndex(start=0, stop=3, step=1, name="non-default"),
  399:         pd.Index([1, 2, 3]),
  400:     ],
  401: )
  402: def test_to_orc_non_default_index(index):
  403:     df = pd.DataFrame({"a": [1, 2, 3]}, index=index)
  404:     msg = (
  405:         "orc does not support serializing a non-default index|"
  406:         "orc does not serialize index meta-data"
  407:     )
  408:     with pytest.raises(ValueError, match=msg):
  409:         df.to_orc()
  410: 
  411: 
  412: def test_invalid_dtype_backend():
  413:     msg = (
  414:         "dtype_backend numpy is invalid, only 'numpy_nullable' and "
  415:         "'pyarrow' are allowed."
  416:     )
  417:     df = pd.DataFrame({"int": list(range(1, 4))})
  418:     with tm.ensure_clean("tmp.orc") as path:
  419:         df.to_orc(path)
  420:         with pytest.raises(ValueError, match=msg):
  421:             read_orc(path, dtype_backend="numpy")
  422: 
  423: 
  424: def test_string_inference(tmp_path):
  425:     # GH#54431
  426:     path = tmp_path / "test_string_inference.p"
  427:     df = pd.DataFrame(data={"a": ["x", "y"]})
  428:     df.to_orc(path)
  429:     with pd.option_context("future.infer_string", True):
  430:         result = read_orc(path)
  431:     expected = pd.DataFrame(
  432:         data={"a": ["x", "y"]},
  433:         dtype="string[pyarrow_numpy]",
  434:         columns=pd.Index(["a"], dtype="string[pyarrow_numpy]"),
  435:     )
  436:     tm.assert_frame_equal(result, expected)
