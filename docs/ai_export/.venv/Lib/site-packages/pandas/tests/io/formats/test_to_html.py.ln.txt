    1: from datetime import datetime
    2: from io import StringIO
    3: import itertools
    4: import re
    5: import textwrap
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: import pandas as pd
   11: from pandas import (
   12:     DataFrame,
   13:     Index,
   14:     MultiIndex,
   15:     get_option,
   16:     option_context,
   17: )
   18: import pandas._testing as tm
   19: 
   20: import pandas.io.formats.format as fmt
   21: 
   22: lorem_ipsum = (
   23:     "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod "
   24:     "tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim "
   25:     "veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex "
   26:     "ea commodo consequat. Duis aute irure dolor in reprehenderit in "
   27:     "voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur "
   28:     "sint occaecat cupidatat non proident, sunt in culpa qui officia "
   29:     "deserunt mollit anim id est laborum."
   30: )
   31: 
   32: 
   33: def expected_html(datapath, name):
   34:     """
   35:     Read HTML file from formats data directory.
   36: 
   37:     Parameters
   38:     ----------
   39:     datapath : pytest fixture
   40:         The datapath fixture injected into a test by pytest.
   41:     name : str
   42:         The name of the HTML file without the suffix.
   43: 
   44:     Returns
   45:     -------
   46:     str : contents of HTML file.
   47:     """
   48:     filename = ".".join([name, "html"])
   49:     filepath = datapath("io", "formats", "data", "html", filename)
   50:     with open(filepath, encoding="utf-8") as f:
   51:         html = f.read()
   52:     return html.rstrip()
   53: 
   54: 
   55: @pytest.fixture(params=["mixed", "empty"])
   56: def biggie_df_fixture(request):
   57:     """Fixture for a big mixed Dataframe and an empty Dataframe"""
   58:     if request.param == "mixed":
   59:         df = DataFrame(
   60:             {
   61:                 "A": np.random.default_rng(2).standard_normal(200),
   62:                 "B": Index([f"{i}?!" for i in range(200)]),
   63:             },
   64:             index=np.arange(200),
   65:         )
   66:         df.loc[:20, "A"] = np.nan
   67:         df.loc[:20, "B"] = np.nan
   68:         return df
   69:     elif request.param == "empty":
   70:         df = DataFrame(index=np.arange(200))
   71:         return df
   72: 
   73: 
   74: @pytest.fixture(params=fmt.VALID_JUSTIFY_PARAMETERS)
   75: def justify(request):
   76:     return request.param
   77: 
   78: 
   79: @pytest.mark.parametrize("col_space", [30, 50])
   80: def test_to_html_with_col_space(col_space):
   81:     df = DataFrame(np.random.default_rng(2).random(size=(1, 3)))
   82:     # check that col_space affects HTML generation
   83:     # and be very brittle about it.
   84:     result = df.to_html(col_space=col_space)
   85:     hdrs = [x for x in result.split(r"\n") if re.search(r"<th[>\s]", x)]
   86:     assert len(hdrs) > 0
   87:     for h in hdrs:
   88:         assert "min-width" in h
   89:         assert str(col_space) in h
   90: 
   91: 
   92: def test_to_html_with_column_specific_col_space_raises():
   93:     df = DataFrame(
   94:         np.random.default_rng(2).random(size=(3, 3)), columns=["a", "b", "c"]
   95:     )
   96: 
   97:     msg = (
   98:         "Col_space length\\(\\d+\\) should match "
   99:         "DataFrame number of columns\\(\\d+\\)"
  100:     )
  101:     with pytest.raises(ValueError, match=msg):
  102:         df.to_html(col_space=[30, 40])
  103: 
  104:     with pytest.raises(ValueError, match=msg):
  105:         df.to_html(col_space=[30, 40, 50, 60])
  106: 
  107:     msg = "unknown column"
  108:     with pytest.raises(ValueError, match=msg):
  109:         df.to_html(col_space={"a": "foo", "b": 23, "d": 34})
  110: 
  111: 
  112: def test_to_html_with_column_specific_col_space():
  113:     df = DataFrame(
  114:         np.random.default_rng(2).random(size=(3, 3)), columns=["a", "b", "c"]
  115:     )
  116: 
  117:     result = df.to_html(col_space={"a": "2em", "b": 23})
  118:     hdrs = [x for x in result.split("\n") if re.search(r"<th[>\s]", x)]
  119:     assert 'min-width: 2em;">a</th>' in hdrs[1]
  120:     assert 'min-width: 23px;">b</th>' in hdrs[2]
  121:     assert "<th>c</th>" in hdrs[3]
  122: 
  123:     result = df.to_html(col_space=["1em", 2, 3])
  124:     hdrs = [x for x in result.split("\n") if re.search(r"<th[>\s]", x)]
  125:     assert 'min-width: 1em;">a</th>' in hdrs[1]
  126:     assert 'min-width: 2px;">b</th>' in hdrs[2]
  127:     assert 'min-width: 3px;">c</th>' in hdrs[3]
  128: 
  129: 
  130: def test_to_html_with_empty_string_label():
  131:     # GH 3547, to_html regards empty string labels as repeated labels
  132:     data = {"c1": ["a", "b"], "c2": ["a", ""], "data": [1, 2]}
  133:     df = DataFrame(data).set_index(["c1", "c2"])
  134:     result = df.to_html()
  135:     assert "rowspan" not in result
  136: 
  137: 
  138: @pytest.mark.parametrize(
  139:     "df,expected",
  140:     [
  141:         (DataFrame({"\u03c3": np.arange(10.0)}), "unicode_1"),
  142:         (DataFrame({"A": ["\u03c3"]}), "unicode_2"),
  143:     ],
  144: )
  145: def test_to_html_unicode(df, expected, datapath):
  146:     expected = expected_html(datapath, expected)
  147:     result = df.to_html()
  148:     assert result == expected
  149: 
  150: 
  151: def test_to_html_encoding(float_frame, tmp_path):
  152:     # GH 28663
  153:     path = tmp_path / "test.html"
  154:     float_frame.to_html(path, encoding="gbk")
  155:     with open(str(path), encoding="gbk") as f:
  156:         assert float_frame.to_html() == f.read()
  157: 
  158: 
  159: def test_to_html_decimal(datapath):
  160:     # GH 12031
  161:     df = DataFrame({"A": [6.0, 3.1, 2.2]})
  162:     result = df.to_html(decimal=",")
  163:     expected = expected_html(datapath, "gh12031_expected_output")
  164:     assert result == expected
  165: 
  166: 
  167: @pytest.mark.parametrize(
  168:     "kwargs,string,expected",
  169:     [
  170:         ({}, "<type 'str'>", "escaped"),
  171:         ({"escape": False}, "<b>bold</b>", "escape_disabled"),
  172:     ],
  173: )
  174: def test_to_html_escaped(kwargs, string, expected, datapath):
  175:     a = "str<ing1 &amp;"
  176:     b = "stri>ng2 &amp;"
  177: 
  178:     test_dict = {"co<l1": {a: string, b: string}, "co>l2": {a: string, b: string}}
  179:     result = DataFrame(test_dict).to_html(**kwargs)
  180:     expected = expected_html(datapath, expected)
  181:     assert result == expected
  182: 
  183: 
  184: @pytest.mark.parametrize("index_is_named", [True, False])
  185: def test_to_html_multiindex_index_false(index_is_named, datapath):
  186:     # GH 8452
  187:     df = DataFrame(
  188:         {"a": range(2), "b": range(3, 5), "c": range(5, 7), "d": range(3, 5)}
  189:     )
  190:     df.columns = MultiIndex.from_product([["a", "b"], ["c", "d"]])
  191:     if index_is_named:
  192:         df.index = Index(df.index.values, name="idx")
  193:     result = df.to_html(index=False)
  194:     expected = expected_html(datapath, "gh8452_expected_output")
  195:     assert result == expected
  196: 
  197: 
  198: @pytest.mark.parametrize(
  199:     "multi_sparse,expected",
  200:     [
  201:         (False, "multiindex_sparsify_false_multi_sparse_1"),
  202:         (False, "multiindex_sparsify_false_multi_sparse_2"),
  203:         (True, "multiindex_sparsify_1"),
  204:         (True, "multiindex_sparsify_2"),
  205:     ],
  206: )
  207: def test_to_html_multiindex_sparsify(multi_sparse, expected, datapath):
  208:     index = MultiIndex.from_arrays([[0, 0, 1, 1], [0, 1, 0, 1]], names=["foo", None])
  209:     df = DataFrame([[0, 1], [2, 3], [4, 5], [6, 7]], index=index)
  210:     if expected.endswith("2"):
  211:         df.columns = index[::2]
  212:     with option_context("display.multi_sparse", multi_sparse):
  213:         result = df.to_html()
  214:     expected = expected_html(datapath, expected)
  215:     assert result == expected
  216: 
  217: 
  218: @pytest.mark.parametrize(
  219:     "max_rows,expected",
  220:     [
  221:         (60, "gh14882_expected_output_1"),
  222:         # Test that ... appears in a middle level
  223:         (56, "gh14882_expected_output_2"),
  224:     ],
  225: )
  226: def test_to_html_multiindex_odd_even_truncate(max_rows, expected, datapath):
  227:     # GH 14882 - Issue on truncation with odd length DataFrame
  228:     index = MultiIndex.from_product(
  229:         [[100, 200, 300], [10, 20, 30], [1, 2, 3, 4, 5, 6, 7]], names=["a", "b", "c"]
  230:     )
  231:     df = DataFrame({"n": range(len(index))}, index=index)
  232:     result = df.to_html(max_rows=max_rows)
  233:     expected = expected_html(datapath, expected)
  234:     assert result == expected
  235: 
  236: 
  237: @pytest.mark.parametrize(
  238:     "df,formatters,expected",
  239:     [
  240:         (
  241:             DataFrame(
  242:                 [[0, 1], [2, 3], [4, 5], [6, 7]],
  243:                 columns=Index(["foo", None], dtype=object),
  244:                 index=np.arange(4),
  245:             ),
  246:             {"__index__": lambda x: "abcd"[x]},
  247:             "index_formatter",
  248:         ),
  249:         (
  250:             DataFrame({"months": [datetime(2016, 1, 1), datetime(2016, 2, 2)]}),
  251:             {"months": lambda x: x.strftime("%Y-%m")},
  252:             "datetime64_monthformatter",
  253:         ),
  254:         (
  255:             DataFrame(
  256:                 {
  257:                     "hod": pd.to_datetime(
  258:                         ["10:10:10.100", "12:12:12.120"], format="%H:%M:%S.%f"
  259:                     )
  260:                 }
  261:             ),
  262:             {"hod": lambda x: x.strftime("%H:%M")},
  263:             "datetime64_hourformatter",
  264:         ),
  265:         (
  266:             DataFrame(
  267:                 {
  268:                     "i": pd.Series([1, 2], dtype="int64"),
  269:                     "f": pd.Series([1, 2], dtype="float64"),
  270:                     "I": pd.Series([1, 2], dtype="Int64"),
  271:                     "s": pd.Series([1, 2], dtype="string"),
  272:                     "b": pd.Series([True, False], dtype="boolean"),
  273:                     "c": pd.Series(["a", "b"], dtype=pd.CategoricalDtype(["a", "b"])),
  274:                     "o": pd.Series([1, "2"], dtype=object),
  275:                 }
  276:             ),
  277:             [lambda x: "formatted"] * 7,
  278:             "various_dtypes_formatted",
  279:         ),
  280:     ],
  281: )
  282: def test_to_html_formatters(df, formatters, expected, datapath):
  283:     expected = expected_html(datapath, expected)
  284:     result = df.to_html(formatters=formatters)
  285:     assert result == expected
  286: 
  287: 
  288: def test_to_html_regression_GH6098():
  289:     df = DataFrame(
  290:         {
  291:             "clГ©1": ["a", "a", "b", "b", "a"],
  292:             "clГ©2": ["1er", "2ГЁme", "1er", "2ГЁme", "1er"],
  293:             "donnГ©es1": np.random.default_rng(2).standard_normal(5),
  294:             "donnГ©es2": np.random.default_rng(2).standard_normal(5),
  295:         }
  296:     )
  297: 
  298:     # it works
  299:     df.pivot_table(index=["clГ©1"], columns=["clГ©2"])._repr_html_()
  300: 
  301: 
  302: def test_to_html_truncate(datapath):
  303:     index = pd.date_range(start="20010101", freq="D", periods=20)
  304:     df = DataFrame(index=index, columns=range(20))
  305:     result = df.to_html(max_rows=8, max_cols=4)
  306:     expected = expected_html(datapath, "truncate")
  307:     assert result == expected
  308: 
  309: 
  310: @pytest.mark.parametrize("size", [1, 5])
  311: def test_html_invalid_formatters_arg_raises(size):
  312:     # issue-28469
  313:     df = DataFrame(columns=["a", "b", "c"])
  314:     msg = "Formatters length({}) should match DataFrame number of columns(3)"
  315:     with pytest.raises(ValueError, match=re.escape(msg.format(size))):
  316:         df.to_html(formatters=["{}".format] * size)
  317: 
  318: 
  319: def test_to_html_truncate_formatter(datapath):
  320:     # issue-25955
  321:     data = [
  322:         {"A": 1, "B": 2, "C": 3, "D": 4},
  323:         {"A": 5, "B": 6, "C": 7, "D": 8},
  324:         {"A": 9, "B": 10, "C": 11, "D": 12},
  325:         {"A": 13, "B": 14, "C": 15, "D": 16},
  326:     ]
  327: 
  328:     df = DataFrame(data)
  329:     fmt = lambda x: str(x) + "_mod"
  330:     formatters = [fmt, fmt, None, None]
  331:     result = df.to_html(formatters=formatters, max_cols=3)
  332:     expected = expected_html(datapath, "truncate_formatter")
  333:     assert result == expected
  334: 
  335: 
  336: @pytest.mark.parametrize(
  337:     "sparsify,expected",
  338:     [(True, "truncate_multi_index"), (False, "truncate_multi_index_sparse_off")],
  339: )
  340: def test_to_html_truncate_multi_index(sparsify, expected, datapath):
  341:     arrays = [
  342:         ["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"],
  343:         ["one", "two", "one", "two", "one", "two", "one", "two"],
  344:     ]
  345:     df = DataFrame(index=arrays, columns=arrays)
  346:     result = df.to_html(max_rows=7, max_cols=7, sparsify=sparsify)
  347:     expected = expected_html(datapath, expected)
  348:     assert result == expected
  349: 
  350: 
  351: @pytest.mark.parametrize(
  352:     "option,result,expected",
  353:     [
  354:         (None, lambda df: df.to_html(), "1"),
  355:         (None, lambda df: df.to_html(border=2), "2"),
  356:         (2, lambda df: df.to_html(), "2"),
  357:         (2, lambda df: df._repr_html_(), "2"),
  358:     ],
  359: )
  360: def test_to_html_border(option, result, expected):
  361:     df = DataFrame({"A": [1, 2]})
  362:     if option is None:
  363:         result = result(df)
  364:     else:
  365:         with option_context("display.html.border", option):
  366:             result = result(df)
  367:     expected = f'border="{expected}"'
  368:     assert expected in result
  369: 
  370: 
  371: @pytest.mark.parametrize("biggie_df_fixture", ["mixed"], indirect=True)
  372: def test_to_html(biggie_df_fixture):
  373:     # TODO: split this test
  374:     df = biggie_df_fixture
  375:     s = df.to_html()
  376: 
  377:     buf = StringIO()
  378:     retval = df.to_html(buf=buf)
  379:     assert retval is None
  380:     assert buf.getvalue() == s
  381: 
  382:     assert isinstance(s, str)
  383: 
  384:     df.to_html(columns=["B", "A"], col_space=17)
  385:     df.to_html(columns=["B", "A"], formatters={"A": lambda x: f"{x:.1f}"})
  386: 
  387:     df.to_html(columns=["B", "A"], float_format=str)
  388:     df.to_html(columns=["B", "A"], col_space=12, float_format=str)
  389: 
  390: 
  391: @pytest.mark.parametrize("biggie_df_fixture", ["empty"], indirect=True)
  392: def test_to_html_empty_dataframe(biggie_df_fixture):
  393:     df = biggie_df_fixture
  394:     df.to_html()
  395: 
  396: 
  397: def test_to_html_filename(biggie_df_fixture, tmpdir):
  398:     df = biggie_df_fixture
  399:     expected = df.to_html()
  400:     path = tmpdir.join("test.html")
  401:     df.to_html(path)
  402:     result = path.read()
  403:     assert result == expected
  404: 
  405: 
  406: def test_to_html_with_no_bold():
  407:     df = DataFrame({"x": np.random.default_rng(2).standard_normal(5)})
  408:     html = df.to_html(bold_rows=False)
  409:     result = html[html.find("</thead>")]
  410:     assert "<strong" not in result
  411: 
  412: 
  413: def test_to_html_columns_arg(float_frame):
  414:     result = float_frame.to_html(columns=["A"])
  415:     assert "<th>B</th>" not in result
  416: 
  417: 
  418: @pytest.mark.parametrize(
  419:     "columns,justify,expected",
  420:     [
  421:         (
  422:             MultiIndex.from_arrays(
  423:                 [np.arange(2).repeat(2), np.mod(range(4), 2)],
  424:                 names=["CL0", "CL1"],
  425:             ),
  426:             "left",
  427:             "multiindex_1",
  428:         ),
  429:         (
  430:             MultiIndex.from_arrays([np.arange(4), np.mod(range(4), 2)]),
  431:             "right",
  432:             "multiindex_2",
  433:         ),
  434:     ],
  435: )
  436: def test_to_html_multiindex(columns, justify, expected, datapath):
  437:     df = DataFrame([list("abcd"), list("efgh")], columns=columns)
  438:     result = df.to_html(justify=justify)
  439:     expected = expected_html(datapath, expected)
  440:     assert result == expected
  441: 
  442: 
  443: def test_to_html_justify(justify, datapath):
  444:     df = DataFrame(
  445:         {"A": [6, 30000, 2], "B": [1, 2, 70000], "C": [223442, 0, 1]},
  446:         columns=["A", "B", "C"],
  447:     )
  448:     result = df.to_html(justify=justify)
  449:     expected = expected_html(datapath, "justify").format(justify=justify)
  450:     assert result == expected
  451: 
  452: 
  453: @pytest.mark.parametrize(
  454:     "justify", ["super-right", "small-left", "noinherit", "tiny", "pandas"]
  455: )
  456: def test_to_html_invalid_justify(justify):
  457:     # GH 17527
  458:     df = DataFrame()
  459:     msg = "Invalid value for justify parameter"
  460: 
  461:     with pytest.raises(ValueError, match=msg):
  462:         df.to_html(justify=justify)
  463: 
  464: 
  465: class TestHTMLIndex:
  466:     @pytest.fixture
  467:     def df(self):
  468:         index = ["foo", "bar", "baz"]
  469:         df = DataFrame(
  470:             {"A": [1, 2, 3], "B": [1.2, 3.4, 5.6], "C": ["one", "two", np.nan]},
  471:             columns=["A", "B", "C"],
  472:             index=index,
  473:         )
  474:         return df
  475: 
  476:     @pytest.fixture
  477:     def expected_without_index(self, datapath):
  478:         return expected_html(datapath, "index_2")
  479: 
  480:     def test_to_html_flat_index_without_name(
  481:         self, datapath, df, expected_without_index
  482:     ):
  483:         expected_with_index = expected_html(datapath, "index_1")
  484:         assert df.to_html() == expected_with_index
  485: 
  486:         result = df.to_html(index=False)
  487:         for i in df.index:
  488:             assert i not in result
  489:         assert result == expected_without_index
  490: 
  491:     def test_to_html_flat_index_with_name(self, datapath, df, expected_without_index):
  492:         df.index = Index(["foo", "bar", "baz"], name="idx")
  493:         expected_with_index = expected_html(datapath, "index_3")
  494:         assert df.to_html() == expected_with_index
  495:         assert df.to_html(index=False) == expected_without_index
  496: 
  497:     def test_to_html_multiindex_without_names(
  498:         self, datapath, df, expected_without_index
  499:     ):
  500:         tuples = [("foo", "car"), ("foo", "bike"), ("bar", "car")]
  501:         df.index = MultiIndex.from_tuples(tuples)
  502: 
  503:         expected_with_index = expected_html(datapath, "index_4")
  504:         assert df.to_html() == expected_with_index
  505: 
  506:         result = df.to_html(index=False)
  507:         for i in ["foo", "bar", "car", "bike"]:
  508:             assert i not in result
  509:         # must be the same result as normal index
  510:         assert result == expected_without_index
  511: 
  512:     def test_to_html_multiindex_with_names(self, datapath, df, expected_without_index):
  513:         tuples = [("foo", "car"), ("foo", "bike"), ("bar", "car")]
  514:         df.index = MultiIndex.from_tuples(tuples, names=["idx1", "idx2"])
  515:         expected_with_index = expected_html(datapath, "index_5")
  516:         assert df.to_html() == expected_with_index
  517:         assert df.to_html(index=False) == expected_without_index
  518: 
  519: 
  520: @pytest.mark.parametrize("classes", ["sortable draggable", ["sortable", "draggable"]])
  521: def test_to_html_with_classes(classes, datapath):
  522:     df = DataFrame()
  523:     expected = expected_html(datapath, "with_classes")
  524:     result = df.to_html(classes=classes)
  525:     assert result == expected
  526: 
  527: 
  528: def test_to_html_no_index_max_rows(datapath):
  529:     # GH 14998
  530:     df = DataFrame({"A": [1, 2, 3, 4]})
  531:     result = df.to_html(index=False, max_rows=1)
  532:     expected = expected_html(datapath, "gh14998_expected_output")
  533:     assert result == expected
  534: 
  535: 
  536: def test_to_html_multiindex_max_cols(datapath):
  537:     # GH 6131
  538:     index = MultiIndex(
  539:         levels=[["ba", "bb", "bc"], ["ca", "cb", "cc"]],
  540:         codes=[[0, 1, 2], [0, 1, 2]],
  541:         names=["b", "c"],
  542:     )
  543:     columns = MultiIndex(
  544:         levels=[["d"], ["aa", "ab", "ac"]],
  545:         codes=[[0, 0, 0], [0, 1, 2]],
  546:         names=[None, "a"],
  547:     )
  548:     data = np.array(
  549:         [[1.0, np.nan, np.nan], [np.nan, 2.0, np.nan], [np.nan, np.nan, 3.0]]
  550:     )
  551:     df = DataFrame(data, index, columns)
  552:     result = df.to_html(max_cols=2)
  553:     expected = expected_html(datapath, "gh6131_expected_output")
  554:     assert result == expected
  555: 
  556: 
  557: def test_to_html_multi_indexes_index_false(datapath):
  558:     # GH 22579
  559:     df = DataFrame(
  560:         {"a": range(10), "b": range(10, 20), "c": range(10, 20), "d": range(10, 20)}
  561:     )
  562:     df.columns = MultiIndex.from_product([["a", "b"], ["c", "d"]])
  563:     df.index = MultiIndex.from_product([["a", "b"], ["c", "d", "e", "f", "g"]])
  564:     result = df.to_html(index=False)
  565:     expected = expected_html(datapath, "gh22579_expected_output")
  566:     assert result == expected
  567: 
  568: 
  569: @pytest.mark.parametrize("index_names", [True, False])
  570: @pytest.mark.parametrize("header", [True, False])
  571: @pytest.mark.parametrize("index", [True, False])
  572: @pytest.mark.parametrize(
  573:     "column_index, column_type",
  574:     [
  575:         (Index([0, 1]), "unnamed_standard"),
  576:         (Index([0, 1], name="columns.name"), "named_standard"),
  577:         (MultiIndex.from_product([["a"], ["b", "c"]]), "unnamed_multi"),
  578:         (
  579:             MultiIndex.from_product(
  580:                 [["a"], ["b", "c"]], names=["columns.name.0", "columns.name.1"]
  581:             ),
  582:             "named_multi",
  583:         ),
  584:     ],
  585: )
  586: @pytest.mark.parametrize(
  587:     "row_index, row_type",
  588:     [
  589:         (Index([0, 1]), "unnamed_standard"),
  590:         (Index([0, 1], name="index.name"), "named_standard"),
  591:         (MultiIndex.from_product([["a"], ["b", "c"]]), "unnamed_multi"),
  592:         (
  593:             MultiIndex.from_product(
  594:                 [["a"], ["b", "c"]], names=["index.name.0", "index.name.1"]
  595:             ),
  596:             "named_multi",
  597:         ),
  598:     ],
  599: )
  600: def test_to_html_basic_alignment(
  601:     datapath, row_index, row_type, column_index, column_type, index, header, index_names
  602: ):
  603:     # GH 22747, GH 22579
  604:     df = DataFrame(np.zeros((2, 2), dtype=int), index=row_index, columns=column_index)
  605:     result = df.to_html(index=index, header=header, index_names=index_names)
  606: 
  607:     if not index:
  608:         row_type = "none"
  609:     elif not index_names and row_type.startswith("named"):
  610:         row_type = "un" + row_type
  611: 
  612:     if not header:
  613:         column_type = "none"
  614:     elif not index_names and column_type.startswith("named"):
  615:         column_type = "un" + column_type
  616: 
  617:     filename = "index_" + row_type + "_columns_" + column_type
  618:     expected = expected_html(datapath, filename)
  619:     assert result == expected
  620: 
  621: 
  622: @pytest.mark.parametrize("index_names", [True, False])
  623: @pytest.mark.parametrize("header", [True, False])
  624: @pytest.mark.parametrize("index", [True, False])
  625: @pytest.mark.parametrize(
  626:     "column_index, column_type",
  627:     [
  628:         (Index(np.arange(8)), "unnamed_standard"),
  629:         (Index(np.arange(8), name="columns.name"), "named_standard"),
  630:         (
  631:             MultiIndex.from_product([["a", "b"], ["c", "d"], ["e", "f"]]),
  632:             "unnamed_multi",
  633:         ),
  634:         (
  635:             MultiIndex.from_product(
  636:                 [["a", "b"], ["c", "d"], ["e", "f"]], names=["foo", None, "baz"]
  637:             ),
  638:             "named_multi",
  639:         ),
  640:     ],
  641: )
  642: @pytest.mark.parametrize(
  643:     "row_index, row_type",
  644:     [
  645:         (Index(np.arange(8)), "unnamed_standard"),
  646:         (Index(np.arange(8), name="index.name"), "named_standard"),
  647:         (
  648:             MultiIndex.from_product([["a", "b"], ["c", "d"], ["e", "f"]]),
  649:             "unnamed_multi",
  650:         ),
  651:         (
  652:             MultiIndex.from_product(
  653:                 [["a", "b"], ["c", "d"], ["e", "f"]], names=["foo", None, "baz"]
  654:             ),
  655:             "named_multi",
  656:         ),
  657:     ],
  658: )
  659: def test_to_html_alignment_with_truncation(
  660:     datapath, row_index, row_type, column_index, column_type, index, header, index_names
  661: ):
  662:     # GH 22747, GH 22579
  663:     df = DataFrame(np.arange(64).reshape(8, 8), index=row_index, columns=column_index)
  664:     result = df.to_html(
  665:         max_rows=4, max_cols=4, index=index, header=header, index_names=index_names
  666:     )
  667: 
  668:     if not index:
  669:         row_type = "none"
  670:     elif not index_names and row_type.startswith("named"):
  671:         row_type = "un" + row_type
  672: 
  673:     if not header:
  674:         column_type = "none"
  675:     elif not index_names and column_type.startswith("named"):
  676:         column_type = "un" + column_type
  677: 
  678:     filename = "trunc_df_index_" + row_type + "_columns_" + column_type
  679:     expected = expected_html(datapath, filename)
  680:     assert result == expected
  681: 
  682: 
  683: @pytest.mark.parametrize("index", [False, 0])
  684: def test_to_html_truncation_index_false_max_rows(datapath, index):
  685:     # GH 15019
  686:     data = [
  687:         [1.764052, 0.400157],
  688:         [0.978738, 2.240893],
  689:         [1.867558, -0.977278],
  690:         [0.950088, -0.151357],
  691:         [-0.103219, 0.410599],
  692:     ]
  693:     df = DataFrame(data)
  694:     result = df.to_html(max_rows=4, index=index)
  695:     expected = expected_html(datapath, "gh15019_expected_output")
  696:     assert result == expected
  697: 
  698: 
  699: @pytest.mark.parametrize("index", [False, 0])
  700: @pytest.mark.parametrize(
  701:     "col_index_named, expected_output",
  702:     [(False, "gh22783_expected_output"), (True, "gh22783_named_columns_index")],
  703: )
  704: def test_to_html_truncation_index_false_max_cols(
  705:     datapath, index, col_index_named, expected_output
  706: ):
  707:     # GH 22783
  708:     data = [
  709:         [1.764052, 0.400157, 0.978738, 2.240893, 1.867558],
  710:         [-0.977278, 0.950088, -0.151357, -0.103219, 0.410599],
  711:     ]
  712:     df = DataFrame(data)
  713:     if col_index_named:
  714:         df.columns.rename("columns.name", inplace=True)
  715:     result = df.to_html(max_cols=4, index=index)
  716:     expected = expected_html(datapath, expected_output)
  717:     assert result == expected
  718: 
  719: 
  720: @pytest.mark.parametrize("notebook", [True, False])
  721: def test_to_html_notebook_has_style(notebook):
  722:     df = DataFrame({"A": [1, 2, 3]})
  723:     result = df.to_html(notebook=notebook)
  724: 
  725:     if notebook:
  726:         assert "tbody tr th:only-of-type" in result
  727:         assert "vertical-align: middle;" in result
  728:         assert "thead th" in result
  729:     else:
  730:         assert "tbody tr th:only-of-type" not in result
  731:         assert "vertical-align: middle;" not in result
  732:         assert "thead th" not in result
  733: 
  734: 
  735: def test_to_html_with_index_names_false():
  736:     # GH 16493
  737:     df = DataFrame({"A": [1, 2]}, index=Index(["a", "b"], name="myindexname"))
  738:     result = df.to_html(index_names=False)
  739:     assert "myindexname" not in result
  740: 
  741: 
  742: def test_to_html_with_id():
  743:     # GH 8496
  744:     df = DataFrame({"A": [1, 2]}, index=Index(["a", "b"], name="myindexname"))
  745:     result = df.to_html(index_names=False, table_id="TEST_ID")
  746:     assert ' id="TEST_ID"' in result
  747: 
  748: 
  749: @pytest.mark.parametrize(
  750:     "value,float_format,expected",
  751:     [
  752:         (0.19999, "%.3f", "gh21625_expected_output"),
  753:         (100.0, "%.0f", "gh22270_expected_output"),
  754:     ],
  755: )
  756: def test_to_html_float_format_no_fixed_width(value, float_format, expected, datapath):
  757:     # GH 21625, GH 22270
  758:     df = DataFrame({"x": [value]})
  759:     expected = expected_html(datapath, expected)
  760:     result = df.to_html(float_format=float_format)
  761:     assert result == expected
  762: 
  763: 
  764: @pytest.mark.parametrize(
  765:     "render_links,expected",
  766:     [(True, "render_links_true"), (False, "render_links_false")],
  767: )
  768: def test_to_html_render_links(render_links, expected, datapath):
  769:     # GH 2679
  770:     data = [
  771:         [0, "https://pandas.pydata.org/?q1=a&q2=b", "pydata.org"],
  772:         [0, "www.pydata.org", "pydata.org"],
  773:     ]
  774:     df = DataFrame(data, columns=Index(["foo", "bar", None], dtype=object))
  775: 
  776:     result = df.to_html(render_links=render_links)
  777:     expected = expected_html(datapath, expected)
  778:     assert result == expected
  779: 
  780: 
  781: @pytest.mark.parametrize(
  782:     "method,expected",
  783:     [
  784:         ("to_html", lambda x: lorem_ipsum),
  785:         ("_repr_html_", lambda x: lorem_ipsum[: x - 4] + "..."),  # regression case
  786:     ],
  787: )
  788: @pytest.mark.parametrize("max_colwidth", [10, 20, 50, 100])
  789: def test_ignore_display_max_colwidth(method, expected, max_colwidth):
  790:     # see gh-17004
  791:     df = DataFrame([lorem_ipsum])
  792:     with option_context("display.max_colwidth", max_colwidth):
  793:         result = getattr(df, method)()
  794:     expected = expected(max_colwidth)
  795:     assert expected in result
  796: 
  797: 
  798: @pytest.mark.parametrize("classes", [True, 0])
  799: def test_to_html_invalid_classes_type(classes):
  800:     # GH 25608
  801:     df = DataFrame()
  802:     msg = "classes must be a string, list, or tuple"
  803: 
  804:     with pytest.raises(TypeError, match=msg):
  805:         df.to_html(classes=classes)
  806: 
  807: 
  808: def test_to_html_round_column_headers():
  809:     # GH 17280
  810:     df = DataFrame([1], columns=[0.55555])
  811:     with option_context("display.precision", 3):
  812:         html = df.to_html(notebook=False)
  813:         notebook = df.to_html(notebook=True)
  814:     assert "0.55555" in html
  815:     assert "0.556" in notebook
  816: 
  817: 
  818: @pytest.mark.parametrize("unit", ["100px", "10%", "5em", 150])
  819: def test_to_html_with_col_space_units(unit):
  820:     # GH 25941
  821:     df = DataFrame(np.random.default_rng(2).random(size=(1, 3)))
  822:     result = df.to_html(col_space=unit)
  823:     result = result.split("tbody")[0]
  824:     hdrs = [x for x in result.split("\n") if re.search(r"<th[>\s]", x)]
  825:     if isinstance(unit, int):
  826:         unit = str(unit) + "px"
  827:     for h in hdrs:
  828:         expected = f'<th style="min-width: {unit};">'
  829:         assert expected in h
  830: 
  831: 
  832: class TestReprHTML:
  833:     def test_html_repr_min_rows_default(self, datapath):
  834:         # gh-27991
  835: 
  836:         # default setting no truncation even if above min_rows
  837:         df = DataFrame({"a": range(20)})
  838:         result = df._repr_html_()
  839:         expected = expected_html(datapath, "html_repr_min_rows_default_no_truncation")
  840:         assert result == expected
  841: 
  842:         # default of max_rows 60 triggers truncation if above
  843:         df = DataFrame({"a": range(61)})
  844:         result = df._repr_html_()
  845:         expected = expected_html(datapath, "html_repr_min_rows_default_truncated")
  846:         assert result == expected
  847: 
  848:     @pytest.mark.parametrize(
  849:         "max_rows,min_rows,expected",
  850:         [
  851:             # truncated after first two rows
  852:             (10, 4, "html_repr_max_rows_10_min_rows_4"),
  853:             # when set to None, follow value of max_rows
  854:             (12, None, "html_repr_max_rows_12_min_rows_None"),
  855:             # when set value higher as max_rows, use the minimum
  856:             (10, 12, "html_repr_max_rows_10_min_rows_12"),
  857:             # max_rows of None -> never truncate
  858:             (None, 12, "html_repr_max_rows_None_min_rows_12"),
  859:         ],
  860:     )
  861:     def test_html_repr_min_rows(self, datapath, max_rows, min_rows, expected):
  862:         # gh-27991
  863: 
  864:         df = DataFrame({"a": range(61)})
  865:         expected = expected_html(datapath, expected)
  866:         with option_context("display.max_rows", max_rows, "display.min_rows", min_rows):
  867:             result = df._repr_html_()
  868:         assert result == expected
  869: 
  870:     def test_repr_html_ipython_config(self, ip):
  871:         code = textwrap.dedent(
  872:             """\
  873:         from pandas import DataFrame
  874:         df = DataFrame({"A": [1, 2]})
  875:         df._repr_html_()
  876: 
  877:         cfg = get_ipython().config
  878:         cfg['IPKernelApp']['parent_appname']
  879:         df._repr_html_()
  880:         """
  881:         )
  882:         result = ip.run_cell(code, silent=True)
  883:         assert not result.error_in_exec
  884: 
  885:     def test_info_repr_html(self):
  886:         max_rows = 60
  887:         max_cols = 20
  888:         # Long
  889:         h, w = max_rows + 1, max_cols - 1
  890:         df = DataFrame({k: np.arange(1, 1 + h) for k in np.arange(w)})
  891:         assert r"&lt;class" not in df._repr_html_()
  892:         with option_context("display.large_repr", "info"):
  893:             assert r"&lt;class" in df._repr_html_()
  894: 
  895:         # Wide
  896:         h, w = max_rows - 1, max_cols + 1
  897:         df = DataFrame({k: np.arange(1, 1 + h) for k in np.arange(w)})
  898:         assert "<class" not in df._repr_html_()
  899:         with option_context(
  900:             "display.large_repr", "info", "display.max_columns", max_cols
  901:         ):
  902:             assert "&lt;class" in df._repr_html_()
  903: 
  904:     def test_fake_qtconsole_repr_html(self, float_frame):
  905:         df = float_frame
  906: 
  907:         def get_ipython():
  908:             return {"config": {"KernelApp": {"parent_appname": "ipython-qtconsole"}}}
  909: 
  910:         repstr = df._repr_html_()
  911:         assert repstr is not None
  912: 
  913:         with option_context("display.max_rows", 5, "display.max_columns", 2):
  914:             repstr = df._repr_html_()
  915: 
  916:         assert "class" in repstr  # info fallback
  917: 
  918:     def test_repr_html(self, float_frame):
  919:         df = float_frame
  920:         df._repr_html_()
  921: 
  922:         with option_context("display.max_rows", 1, "display.max_columns", 1):
  923:             df._repr_html_()
  924: 
  925:         with option_context("display.notebook_repr_html", False):
  926:             df._repr_html_()
  927: 
  928:         df = DataFrame([[1, 2], [3, 4]])
  929:         with option_context("display.show_dimensions", True):
  930:             assert "2 rows" in df._repr_html_()
  931:         with option_context("display.show_dimensions", False):
  932:             assert "2 rows" not in df._repr_html_()
  933: 
  934:     def test_repr_html_mathjax(self):
  935:         df = DataFrame([[1, 2], [3, 4]])
  936:         assert "tex2jax_ignore" not in df._repr_html_()
  937: 
  938:         with option_context("display.html.use_mathjax", False):
  939:             assert "tex2jax_ignore" in df._repr_html_()
  940: 
  941:     def test_repr_html_wide(self):
  942:         max_cols = 20
  943:         df = DataFrame([["a" * 25] * (max_cols - 1)] * 10)
  944:         with option_context("display.max_rows", 60, "display.max_columns", 20):
  945:             assert "..." not in df._repr_html_()
  946: 
  947:         wide_df = DataFrame([["a" * 25] * (max_cols + 1)] * 10)
  948:         with option_context("display.max_rows", 60, "display.max_columns", 20):
  949:             assert "..." in wide_df._repr_html_()
  950: 
  951:     def test_repr_html_wide_multiindex_cols(self):
  952:         max_cols = 20
  953: 
  954:         mcols = MultiIndex.from_product(
  955:             [np.arange(max_cols // 2), ["foo", "bar"]], names=["first", "second"]
  956:         )
  957:         df = DataFrame([["a" * 25] * len(mcols)] * 10, columns=mcols)
  958:         reg_repr = df._repr_html_()
  959:         assert "..." not in reg_repr
  960: 
  961:         mcols = MultiIndex.from_product(
  962:             (np.arange(1 + (max_cols // 2)), ["foo", "bar"]), names=["first", "second"]
  963:         )
  964:         df = DataFrame([["a" * 25] * len(mcols)] * 10, columns=mcols)
  965:         with option_context("display.max_rows", 60, "display.max_columns", 20):
  966:             assert "..." in df._repr_html_()
  967: 
  968:     def test_repr_html_long(self):
  969:         with option_context("display.max_rows", 60):
  970:             max_rows = get_option("display.max_rows")
  971:             h = max_rows - 1
  972:             df = DataFrame({"A": np.arange(1, 1 + h), "B": np.arange(41, 41 + h)})
  973:             reg_repr = df._repr_html_()
  974:             assert ".." not in reg_repr
  975:             assert str(41 + max_rows // 2) in reg_repr
  976: 
  977:             h = max_rows + 1
  978:             df = DataFrame({"A": np.arange(1, 1 + h), "B": np.arange(41, 41 + h)})
  979:             long_repr = df._repr_html_()
  980:             assert ".." in long_repr
  981:             assert str(41 + max_rows // 2) not in long_repr
  982:             assert f"{h} rows " in long_repr
  983:             assert "2 columns" in long_repr
  984: 
  985:     def test_repr_html_float(self):
  986:         with option_context("display.max_rows", 60):
  987:             max_rows = get_option("display.max_rows")
  988:             h = max_rows - 1
  989:             df = DataFrame(
  990:                 {
  991:                     "idx": np.linspace(-10, 10, h),
  992:                     "A": np.arange(1, 1 + h),
  993:                     "B": np.arange(41, 41 + h),
  994:                 }
  995:             ).set_index("idx")
  996:             reg_repr = df._repr_html_()
  997:             assert ".." not in reg_repr
  998:             assert f"<td>{40 + h}</td>" in reg_repr
  999: 
 1000:             h = max_rows + 1
 1001:             df = DataFrame(
 1002:                 {
 1003:                     "idx": np.linspace(-10, 10, h),
 1004:                     "A": np.arange(1, 1 + h),
 1005:                     "B": np.arange(41, 41 + h),
 1006:                 }
 1007:             ).set_index("idx")
 1008:             long_repr = df._repr_html_()
 1009:             assert ".." in long_repr
 1010:             assert "<td>31</td>" not in long_repr
 1011:             assert f"{h} rows " in long_repr
 1012:             assert "2 columns" in long_repr
 1013: 
 1014:     def test_repr_html_long_multiindex(self):
 1015:         max_rows = 60
 1016:         max_L1 = max_rows // 2
 1017: 
 1018:         tuples = list(itertools.product(np.arange(max_L1), ["foo", "bar"]))
 1019:         idx = MultiIndex.from_tuples(tuples, names=["first", "second"])
 1020:         df = DataFrame(
 1021:             np.random.default_rng(2).standard_normal((max_L1 * 2, 2)),
 1022:             index=idx,
 1023:             columns=["A", "B"],
 1024:         )
 1025:         with option_context("display.max_rows", 60, "display.max_columns", 20):
 1026:             reg_repr = df._repr_html_()
 1027:         assert "..." not in reg_repr
 1028: 
 1029:         tuples = list(itertools.product(np.arange(max_L1 + 1), ["foo", "bar"]))
 1030:         idx = MultiIndex.from_tuples(tuples, names=["first", "second"])
 1031:         df = DataFrame(
 1032:             np.random.default_rng(2).standard_normal(((max_L1 + 1) * 2, 2)),
 1033:             index=idx,
 1034:             columns=["A", "B"],
 1035:         )
 1036:         long_repr = df._repr_html_()
 1037:         assert "..." in long_repr
 1038: 
 1039:     def test_repr_html_long_and_wide(self):
 1040:         max_cols = 20
 1041:         max_rows = 60
 1042: 
 1043:         h, w = max_rows - 1, max_cols - 1
 1044:         df = DataFrame({k: np.arange(1, 1 + h) for k in np.arange(w)})
 1045:         with option_context("display.max_rows", 60, "display.max_columns", 20):
 1046:             assert "..." not in df._repr_html_()
 1047: 
 1048:         h, w = max_rows + 1, max_cols + 1
 1049:         df = DataFrame({k: np.arange(1, 1 + h) for k in np.arange(w)})
 1050:         with option_context("display.max_rows", 60, "display.max_columns", 20):
 1051:             assert "..." in df._repr_html_()
 1052: 
 1053: 
 1054: def test_to_html_multilevel(multiindex_year_month_day_dataframe_random_data):
 1055:     ymd = multiindex_year_month_day_dataframe_random_data
 1056: 
 1057:     ymd.columns.name = "foo"
 1058:     ymd.to_html()
 1059:     ymd.T.to_html()
 1060: 
 1061: 
 1062: @pytest.mark.parametrize("na_rep", ["NaN", "Ted"])
 1063: def test_to_html_na_rep_and_float_format(na_rep, datapath):
 1064:     # https://github.com/pandas-dev/pandas/issues/13828
 1065:     df = DataFrame(
 1066:         [
 1067:             ["A", 1.2225],
 1068:             ["A", None],
 1069:         ],
 1070:         columns=["Group", "Data"],
 1071:     )
 1072:     result = df.to_html(na_rep=na_rep, float_format="{:.2f}".format)
 1073:     expected = expected_html(datapath, "gh13828_expected_output")
 1074:     expected = expected.format(na_rep=na_rep)
 1075:     assert result == expected
 1076: 
 1077: 
 1078: def test_to_html_na_rep_non_scalar_data(datapath):
 1079:     # GH47103
 1080:     df = DataFrame([{"a": 1, "b": [1, 2, 3]}])
 1081:     result = df.to_html(na_rep="-")
 1082:     expected = expected_html(datapath, "gh47103_expected_output")
 1083:     assert result == expected
 1084: 
 1085: 
 1086: def test_to_html_float_format_object_col(datapath):
 1087:     # GH#40024
 1088:     df = DataFrame(data={"x": [1000.0, "test"]})
 1089:     result = df.to_html(float_format=lambda x: f"{x:,.0f}")
 1090:     expected = expected_html(datapath, "gh40024_expected_output")
 1091:     assert result == expected
 1092: 
 1093: 
 1094: def test_to_html_multiindex_col_with_colspace():
 1095:     # GH#53885
 1096:     df = DataFrame([[1, 2]])
 1097:     df.columns = MultiIndex.from_tuples([(1, 1), (2, 1)])
 1098:     result = df.to_html(col_space=100)
 1099:     expected = (
 1100:         '<table border="1" class="dataframe">\n'
 1101:         "  <thead>\n"
 1102:         "    <tr>\n"
 1103:         '      <th style="min-width: 100px;"></th>\n'
 1104:         '      <th style="min-width: 100px;">1</th>\n'
 1105:         '      <th style="min-width: 100px;">2</th>\n'
 1106:         "    </tr>\n"
 1107:         "    <tr>\n"
 1108:         '      <th style="min-width: 100px;"></th>\n'
 1109:         '      <th style="min-width: 100px;">1</th>\n'
 1110:         '      <th style="min-width: 100px;">1</th>\n'
 1111:         "    </tr>\n"
 1112:         "  </thead>\n"
 1113:         "  <tbody>\n"
 1114:         "    <tr>\n"
 1115:         "      <th>0</th>\n"
 1116:         "      <td>1</td>\n"
 1117:         "      <td>2</td>\n"
 1118:         "    </tr>\n"
 1119:         "  </tbody>\n"
 1120:         "</table>"
 1121:     )
 1122:     assert result == expected
 1123: 
 1124: 
 1125: def test_to_html_tuple_col_with_colspace():
 1126:     # GH#53885
 1127:     df = DataFrame({("a", "b"): [1], "b": [2]})
 1128:     result = df.to_html(col_space=100)
 1129:     expected = (
 1130:         '<table border="1" class="dataframe">\n'
 1131:         "  <thead>\n"
 1132:         '    <tr style="text-align: right;">\n'
 1133:         '      <th style="min-width: 100px;"></th>\n'
 1134:         '      <th style="min-width: 100px;">(a, b)</th>\n'
 1135:         '      <th style="min-width: 100px;">b</th>\n'
 1136:         "    </tr>\n"
 1137:         "  </thead>\n"
 1138:         "  <tbody>\n"
 1139:         "    <tr>\n"
 1140:         "      <th>0</th>\n"
 1141:         "      <td>1</td>\n"
 1142:         "      <td>2</td>\n"
 1143:         "    </tr>\n"
 1144:         "  </tbody>\n"
 1145:         "</table>"
 1146:     )
 1147:     assert result == expected
 1148: 
 1149: 
 1150: def test_to_html_empty_complex_array():
 1151:     # GH#54167
 1152:     df = DataFrame({"x": np.array([], dtype="complex")})
 1153:     result = df.to_html(col_space=100)
 1154:     expected = (
 1155:         '<table border="1" class="dataframe">\n'
 1156:         "  <thead>\n"
 1157:         '    <tr style="text-align: right;">\n'
 1158:         '      <th style="min-width: 100px;"></th>\n'
 1159:         '      <th style="min-width: 100px;">x</th>\n'
 1160:         "    </tr>\n"
 1161:         "  </thead>\n"
 1162:         "  <tbody>\n"
 1163:         "  </tbody>\n"
 1164:         "</table>"
 1165:     )
 1166:     assert result == expected
 1167: 
 1168: 
 1169: def test_to_html_pos_args_deprecation():
 1170:     # GH-54229
 1171:     df = DataFrame({"a": [1, 2, 3]})
 1172:     msg = (
 1173:         r"Starting with pandas version 3.0 all arguments of to_html except for the "
 1174:         r"argument 'buf' will be keyword-only."
 1175:     )
 1176:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1177:         df.to_html(None, None)
