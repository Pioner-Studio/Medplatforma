    1: import datetime
    2: from io import BytesIO
    3: import re
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas import (
    9:     CategoricalIndex,
   10:     DataFrame,
   11:     HDFStore,
   12:     Index,
   13:     MultiIndex,
   14:     _testing as tm,
   15:     date_range,
   16:     read_hdf,
   17: )
   18: from pandas.tests.io.pytables.common import ensure_clean_store
   19: 
   20: from pandas.io.pytables import (
   21:     Term,
   22:     _maybe_adjust_name,
   23: )
   24: 
   25: pytestmark = pytest.mark.single_cpu
   26: 
   27: 
   28: def test_pass_spec_to_storer(setup_path):
   29:     df = DataFrame(
   30:         1.1 * np.arange(120).reshape((30, 4)),
   31:         columns=Index(list("ABCD"), dtype=object),
   32:         index=Index([f"i-{i}" for i in range(30)], dtype=object),
   33:     )
   34: 
   35:     with ensure_clean_store(setup_path) as store:
   36:         store.put("df", df)
   37:         msg = (
   38:             "cannot pass a column specification when reading a Fixed format "
   39:             "store. this store must be selected in its entirety"
   40:         )
   41:         with pytest.raises(TypeError, match=msg):
   42:             store.select("df", columns=["A"])
   43:         msg = (
   44:             "cannot pass a where specification when reading from a Fixed "
   45:             "format store. this store must be selected in its entirety"
   46:         )
   47:         with pytest.raises(TypeError, match=msg):
   48:             store.select("df", where=[("columns=A")])
   49: 
   50: 
   51: def test_table_index_incompatible_dtypes(setup_path):
   52:     df1 = DataFrame({"a": [1, 2, 3]})
   53:     df2 = DataFrame({"a": [4, 5, 6]}, index=date_range("1/1/2000", periods=3))
   54: 
   55:     with ensure_clean_store(setup_path) as store:
   56:         store.put("frame", df1, format="table")
   57:         msg = re.escape("incompatible kind in col [integer - datetime64[ns]]")
   58:         with pytest.raises(TypeError, match=msg):
   59:             store.put("frame", df2, format="table", append=True)
   60: 
   61: 
   62: def test_unimplemented_dtypes_table_columns(setup_path):
   63:     with ensure_clean_store(setup_path) as store:
   64:         dtypes = [("date", datetime.date(2001, 1, 2))]
   65: 
   66:         # currently not supported dtypes ####
   67:         for n, f in dtypes:
   68:             df = DataFrame(
   69:                 1.1 * np.arange(120).reshape((30, 4)),
   70:                 columns=Index(list("ABCD"), dtype=object),
   71:                 index=Index([f"i-{i}" for i in range(30)], dtype=object),
   72:             )
   73:             df[n] = f
   74:             msg = re.escape(f"[{n}] is not implemented as a table column")
   75:             with pytest.raises(TypeError, match=msg):
   76:                 store.append(f"df1_{n}", df)
   77: 
   78:     # frame
   79:     df = DataFrame(
   80:         1.1 * np.arange(120).reshape((30, 4)),
   81:         columns=Index(list("ABCD"), dtype=object),
   82:         index=Index([f"i-{i}" for i in range(30)], dtype=object),
   83:     )
   84:     df["obj1"] = "foo"
   85:     df["obj2"] = "bar"
   86:     df["datetime1"] = datetime.date(2001, 1, 2)
   87:     df = df._consolidate()
   88: 
   89:     with ensure_clean_store(setup_path) as store:
   90:         # this fails because we have a date in the object block......
   91:         msg = re.escape(
   92:             """Cannot serialize the column [datetime1]
   93: because its data contents are not [string] but [date] object dtype"""
   94:         )
   95:         with pytest.raises(TypeError, match=msg):
   96:             store.append("df_unimplemented", df)
   97: 
   98: 
   99: def test_invalid_terms(tmp_path, setup_path):
  100:     with ensure_clean_store(setup_path) as store:
  101:         df = DataFrame(
  102:             np.random.default_rng(2).standard_normal((10, 4)),
  103:             columns=Index(list("ABCD"), dtype=object),
  104:             index=date_range("2000-01-01", periods=10, freq="B"),
  105:         )
  106:         df["string"] = "foo"
  107:         df.loc[df.index[0:4], "string"] = "bar"
  108: 
  109:         store.put("df", df, format="table")
  110: 
  111:         # some invalid terms
  112:         msg = re.escape("__init__() missing 1 required positional argument: 'where'")
  113:         with pytest.raises(TypeError, match=msg):
  114:             Term()
  115: 
  116:         # more invalid
  117:         msg = re.escape(
  118:             "cannot process expression [df.index[3]], "
  119:             "[2000-01-06 00:00:00] is not a valid condition"
  120:         )
  121:         with pytest.raises(ValueError, match=msg):
  122:             store.select("df", "df.index[3]")
  123: 
  124:         msg = "invalid syntax"
  125:         with pytest.raises(SyntaxError, match=msg):
  126:             store.select("df", "index>")
  127: 
  128:     # from the docs
  129:     path = tmp_path / setup_path
  130:     dfq = DataFrame(
  131:         np.random.default_rng(2).standard_normal((10, 4)),
  132:         columns=list("ABCD"),
  133:         index=date_range("20130101", periods=10),
  134:     )
  135:     dfq.to_hdf(path, key="dfq", format="table", data_columns=True)
  136: 
  137:     # check ok
  138:     read_hdf(path, "dfq", where="index>Timestamp('20130104') & columns=['A', 'B']")
  139:     read_hdf(path, "dfq", where="A>0 or C>0")
  140: 
  141:     # catch the invalid reference
  142:     path = tmp_path / setup_path
  143:     dfq = DataFrame(
  144:         np.random.default_rng(2).standard_normal((10, 4)),
  145:         columns=list("ABCD"),
  146:         index=date_range("20130101", periods=10),
  147:     )
  148:     dfq.to_hdf(path, key="dfq", format="table")
  149: 
  150:     msg = (
  151:         r"The passed where expression: A>0 or C>0\n\s*"
  152:         r"contains an invalid variable reference\n\s*"
  153:         r"all of the variable references must be a reference to\n\s*"
  154:         r"an axis \(e.g. 'index' or 'columns'\), or a data_column\n\s*"
  155:         r"The currently defined references are: index,columns\n"
  156:     )
  157:     with pytest.raises(ValueError, match=msg):
  158:         read_hdf(path, "dfq", where="A>0 or C>0")
  159: 
  160: 
  161: def test_append_with_diff_col_name_types_raises_value_error(setup_path):
  162:     df = DataFrame(np.random.default_rng(2).standard_normal((10, 1)))
  163:     df2 = DataFrame({"a": np.random.default_rng(2).standard_normal(10)})
  164:     df3 = DataFrame({(1, 2): np.random.default_rng(2).standard_normal(10)})
  165:     df4 = DataFrame({("1", 2): np.random.default_rng(2).standard_normal(10)})
  166:     df5 = DataFrame({("1", 2, object): np.random.default_rng(2).standard_normal(10)})
  167: 
  168:     with ensure_clean_store(setup_path) as store:
  169:         name = "df_diff_valerror"
  170:         store.append(name, df)
  171: 
  172:         for d in (df2, df3, df4, df5):
  173:             msg = re.escape(
  174:                 "cannot match existing table structure for [0] on appending data"
  175:             )
  176:             with pytest.raises(ValueError, match=msg):
  177:                 store.append(name, d)
  178: 
  179: 
  180: def test_invalid_complib(setup_path):
  181:     df = DataFrame(
  182:         np.random.default_rng(2).random((4, 5)),
  183:         index=list("abcd"),
  184:         columns=list("ABCDE"),
  185:     )
  186:     with tm.ensure_clean(setup_path) as path:
  187:         msg = r"complib only supports \[.*\] compression."
  188:         with pytest.raises(ValueError, match=msg):
  189:             df.to_hdf(path, key="df", complib="foolib")
  190: 
  191: 
  192: @pytest.mark.parametrize(
  193:     "idx",
  194:     [
  195:         date_range("2019", freq="D", periods=3, tz="UTC"),
  196:         CategoricalIndex(list("abc")),
  197:     ],
  198: )
  199: def test_to_hdf_multiindex_extension_dtype(idx, tmp_path, setup_path):
  200:     # GH 7775
  201:     mi = MultiIndex.from_arrays([idx, idx])
  202:     df = DataFrame(0, index=mi, columns=["a"])
  203:     path = tmp_path / setup_path
  204:     with pytest.raises(NotImplementedError, match="Saving a MultiIndex"):
  205:         df.to_hdf(path, key="df")
  206: 
  207: 
  208: def test_unsuppored_hdf_file_error(datapath):
  209:     # GH 9539
  210:     data_path = datapath("io", "data", "legacy_hdf/incompatible_dataset.h5")
  211:     message = (
  212:         r"Dataset\(s\) incompatible with Pandas data types, "
  213:         "not table, or no datasets found in HDF5 file."
  214:     )
  215: 
  216:     with pytest.raises(ValueError, match=message):
  217:         read_hdf(data_path)
  218: 
  219: 
  220: def test_read_hdf_errors(setup_path, tmp_path):
  221:     df = DataFrame(
  222:         np.random.default_rng(2).random((4, 5)),
  223:         index=list("abcd"),
  224:         columns=list("ABCDE"),
  225:     )
  226: 
  227:     path = tmp_path / setup_path
  228:     msg = r"File [\S]* does not exist"
  229:     with pytest.raises(OSError, match=msg):
  230:         read_hdf(path, "key")
  231: 
  232:     df.to_hdf(path, key="df")
  233:     store = HDFStore(path, mode="r")
  234:     store.close()
  235: 
  236:     msg = "The HDFStore must be open for reading."
  237:     with pytest.raises(OSError, match=msg):
  238:         read_hdf(store, "df")
  239: 
  240: 
  241: def test_read_hdf_generic_buffer_errors():
  242:     msg = "Support for generic buffers has not been implemented."
  243:     with pytest.raises(NotImplementedError, match=msg):
  244:         read_hdf(BytesIO(b""), "df")
  245: 
  246: 
  247: @pytest.mark.parametrize("bad_version", [(1, 2), (1,), [], "12", "123"])
  248: def test_maybe_adjust_name_bad_version_raises(bad_version):
  249:     msg = "Version is incorrect, expected sequence of 3 integers"
  250:     with pytest.raises(ValueError, match=msg):
  251:         _maybe_adjust_name("values_block_0", version=bad_version)
