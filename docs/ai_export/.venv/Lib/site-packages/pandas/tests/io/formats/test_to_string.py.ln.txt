    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: from io import StringIO
    6: import re
    7: import sys
    8: from textwrap import dedent
    9: 
   10: import numpy as np
   11: import pytest
   12: 
   13: from pandas._config import using_pyarrow_string_dtype
   14: 
   15: from pandas import (
   16:     CategoricalIndex,
   17:     DataFrame,
   18:     Index,
   19:     NaT,
   20:     Series,
   21:     Timestamp,
   22:     concat,
   23:     date_range,
   24:     get_option,
   25:     option_context,
   26:     read_csv,
   27:     timedelta_range,
   28:     to_datetime,
   29: )
   30: import pandas._testing as tm
   31: 
   32: 
   33: def _three_digit_exp():
   34:     return f"{1.7e8:.4g}" == "1.7e+008"
   35: 
   36: 
   37: class TestDataFrameToStringFormatters:
   38:     def test_to_string_masked_ea_with_formatter(self):
   39:         # GH#39336
   40:         df = DataFrame(
   41:             {
   42:                 "a": Series([0.123456789, 1.123456789], dtype="Float64"),
   43:                 "b": Series([1, 2], dtype="Int64"),
   44:             }
   45:         )
   46:         result = df.to_string(formatters=["{:.2f}".format, "{:.2f}".format])
   47:         expected = dedent(
   48:             """\
   49:                   a     b
   50:             0  0.12  1.00
   51:             1  1.12  2.00"""
   52:         )
   53:         assert result == expected
   54: 
   55:     def test_to_string_with_formatters(self):
   56:         df = DataFrame(
   57:             {
   58:                 "int": [1, 2, 3],
   59:                 "float": [1.0, 2.0, 3.0],
   60:                 "object": [(1, 2), True, False],
   61:             },
   62:             columns=["int", "float", "object"],
   63:         )
   64: 
   65:         formatters = [
   66:             ("int", lambda x: f"0x{x:x}"),
   67:             ("float", lambda x: f"[{x: 4.1f}]"),
   68:             ("object", lambda x: f"-{x!s}-"),
   69:         ]
   70:         result = df.to_string(formatters=dict(formatters))
   71:         result2 = df.to_string(formatters=list(zip(*formatters))[1])
   72:         assert result == (
   73:             "  int  float    object\n"
   74:             "0 0x1 [ 1.0]  -(1, 2)-\n"
   75:             "1 0x2 [ 2.0]    -True-\n"
   76:             "2 0x3 [ 3.0]   -False-"
   77:         )
   78:         assert result == result2
   79: 
   80:     def test_to_string_with_datetime64_monthformatter(self):
   81:         months = [datetime(2016, 1, 1), datetime(2016, 2, 2)]
   82:         x = DataFrame({"months": months})
   83: 
   84:         def format_func(x):
   85:             return x.strftime("%Y-%m")
   86: 
   87:         result = x.to_string(formatters={"months": format_func})
   88:         expected = dedent(
   89:             """\
   90:             months
   91:             0 2016-01
   92:             1 2016-02"""
   93:         )
   94:         assert result.strip() == expected
   95: 
   96:     def test_to_string_with_datetime64_hourformatter(self):
   97:         x = DataFrame(
   98:             {"hod": to_datetime(["10:10:10.100", "12:12:12.120"], format="%H:%M:%S.%f")}
   99:         )
  100: 
  101:         def format_func(x):
  102:             return x.strftime("%H:%M")
  103: 
  104:         result = x.to_string(formatters={"hod": format_func})
  105:         expected = dedent(
  106:             """\
  107:             hod
  108:             0 10:10
  109:             1 12:12"""
  110:         )
  111:         assert result.strip() == expected
  112: 
  113:     def test_to_string_with_formatters_unicode(self):
  114:         df = DataFrame({"c/\u03c3": [1, 2, 3]})
  115:         result = df.to_string(formatters={"c/\u03c3": str})
  116:         expected = dedent(
  117:             """\
  118:               c/\u03c3
  119:             0   1
  120:             1   2
  121:             2   3"""
  122:         )
  123:         assert result == expected
  124: 
  125:         def test_to_string_index_formatter(self):
  126:             df = DataFrame([range(5), range(5, 10), range(10, 15)])
  127: 
  128:             rs = df.to_string(formatters={"__index__": lambda x: "abc"[x]})
  129: 
  130:             xp = dedent(
  131:                 """\
  132:                 0   1   2   3   4
  133:             a   0   1   2   3   4
  134:             b   5   6   7   8   9
  135:             c  10  11  12  13  14\
  136:             """
  137:             )
  138:             assert rs == xp
  139: 
  140:     def test_no_extra_space(self):
  141:         # GH#52690: Check that no extra space is given
  142:         col1 = "TEST"
  143:         col2 = "PANDAS"
  144:         col3 = "to_string"
  145:         expected = f"{col1:<6s} {col2:<7s} {col3:<10s}"
  146:         df = DataFrame([{"col1": "TEST", "col2": "PANDAS", "col3": "to_string"}])
  147:         d = {"col1": "{:<6s}".format, "col2": "{:<7s}".format, "col3": "{:<10s}".format}
  148:         result = df.to_string(index=False, header=False, formatters=d)
  149:         assert result == expected
  150: 
  151: 
  152: class TestDataFrameToStringColSpace:
  153:     def test_to_string_with_column_specific_col_space_raises(self):
  154:         df = DataFrame(
  155:             np.random.default_rng(2).random(size=(3, 3)), columns=["a", "b", "c"]
  156:         )
  157: 
  158:         msg = (
  159:             "Col_space length\\(\\d+\\) should match "
  160:             "DataFrame number of columns\\(\\d+\\)"
  161:         )
  162:         with pytest.raises(ValueError, match=msg):
  163:             df.to_string(col_space=[30, 40])
  164: 
  165:         with pytest.raises(ValueError, match=msg):
  166:             df.to_string(col_space=[30, 40, 50, 60])
  167: 
  168:         msg = "unknown column"
  169:         with pytest.raises(ValueError, match=msg):
  170:             df.to_string(col_space={"a": "foo", "b": 23, "d": 34})
  171: 
  172:     def test_to_string_with_column_specific_col_space(self):
  173:         df = DataFrame(
  174:             np.random.default_rng(2).random(size=(3, 3)), columns=["a", "b", "c"]
  175:         )
  176: 
  177:         result = df.to_string(col_space={"a": 10, "b": 11, "c": 12})
  178:         # 3 separating space + each col_space for (id, a, b, c)
  179:         assert len(result.split("\n")[1]) == (3 + 1 + 10 + 11 + 12)
  180: 
  181:         result = df.to_string(col_space=[10, 11, 12])
  182:         assert len(result.split("\n")[1]) == (3 + 1 + 10 + 11 + 12)
  183: 
  184:     def test_to_string_with_col_space(self):
  185:         df = DataFrame(np.random.default_rng(2).random(size=(1, 3)))
  186:         c10 = len(df.to_string(col_space=10).split("\n")[1])
  187:         c20 = len(df.to_string(col_space=20).split("\n")[1])
  188:         c30 = len(df.to_string(col_space=30).split("\n")[1])
  189:         assert c10 < c20 < c30
  190: 
  191:         # GH#8230
  192:         # col_space wasn't being applied with header=False
  193:         with_header = df.to_string(col_space=20)
  194:         with_header_row1 = with_header.splitlines()[1]
  195:         no_header = df.to_string(col_space=20, header=False)
  196:         assert len(with_header_row1) == len(no_header)
  197: 
  198:     def test_to_string_repr_tuples(self):
  199:         buf = StringIO()
  200: 
  201:         df = DataFrame({"tups": list(zip(range(10), range(10)))})
  202:         repr(df)
  203:         df.to_string(col_space=10, buf=buf)
  204: 
  205: 
  206: class TestDataFrameToStringHeader:
  207:     def test_to_string_header_false(self):
  208:         # GH#49230
  209:         df = DataFrame([1, 2])
  210:         df.index.name = "a"
  211:         s = df.to_string(header=False)
  212:         expected = "a   \n0  1\n1  2"
  213:         assert s == expected
  214: 
  215:         df = DataFrame([[1, 2], [3, 4]])
  216:         df.index.name = "a"
  217:         s = df.to_string(header=False)
  218:         expected = "a      \n0  1  2\n1  3  4"
  219:         assert s == expected
  220: 
  221:     def test_to_string_multindex_header(self):
  222:         # GH#16718
  223:         df = DataFrame({"a": [0], "b": [1], "c": [2], "d": [3]}).set_index(["a", "b"])
  224:         res = df.to_string(header=["r1", "r2"])
  225:         exp = "    r1 r2\na b      \n0 1  2  3"
  226:         assert res == exp
  227: 
  228:     def test_to_string_no_header(self):
  229:         df = DataFrame({"x": [1, 2, 3], "y": [4, 5, 6]})
  230: 
  231:         df_s = df.to_string(header=False)
  232:         expected = "0  1  4\n1  2  5\n2  3  6"
  233: 
  234:         assert df_s == expected
  235: 
  236:     def test_to_string_specified_header(self):
  237:         df = DataFrame({"x": [1, 2, 3], "y": [4, 5, 6]})
  238: 
  239:         df_s = df.to_string(header=["X", "Y"])
  240:         expected = "   X  Y\n0  1  4\n1  2  5\n2  3  6"
  241: 
  242:         assert df_s == expected
  243: 
  244:         msg = "Writing 2 cols but got 1 aliases"
  245:         with pytest.raises(ValueError, match=msg):
  246:             df.to_string(header=["X"])
  247: 
  248: 
  249: class TestDataFrameToStringLineWidth:
  250:     def test_to_string_line_width(self):
  251:         df = DataFrame(123, index=range(10, 15), columns=range(30))
  252:         lines = df.to_string(line_width=80)
  253:         assert max(len(line) for line in lines.split("\n")) == 80
  254: 
  255:     def test_to_string_line_width_no_index(self):
  256:         # GH#13998, GH#22505
  257:         df = DataFrame({"x": [1, 2, 3], "y": [4, 5, 6]})
  258: 
  259:         df_s = df.to_string(line_width=1, index=False)
  260:         expected = " x  \\\n 1   \n 2   \n 3   \n\n y  \n 4  \n 5  \n 6  "
  261: 
  262:         assert df_s == expected
  263: 
  264:         df = DataFrame({"x": [11, 22, 33], "y": [4, 5, 6]})
  265: 
  266:         df_s = df.to_string(line_width=1, index=False)
  267:         expected = " x  \\\n11   \n22   \n33   \n\n y  \n 4  \n 5  \n 6  "
  268: 
  269:         assert df_s == expected
  270: 
  271:         df = DataFrame({"x": [11, 22, -33], "y": [4, 5, -6]})
  272: 
  273:         df_s = df.to_string(line_width=1, index=False)
  274:         expected = "  x  \\\n 11   \n 22   \n-33   \n\n y  \n 4  \n 5  \n-6  "
  275: 
  276:         assert df_s == expected
  277: 
  278:     def test_to_string_line_width_no_header(self):
  279:         # GH#53054
  280:         df = DataFrame({"x": [1, 2, 3], "y": [4, 5, 6]})
  281: 
  282:         df_s = df.to_string(line_width=1, header=False)
  283:         expected = "0  1  \\\n1  2   \n2  3   \n\n0  4  \n1  5  \n2  6  "
  284: 
  285:         assert df_s == expected
  286: 
  287:         df = DataFrame({"x": [11, 22, 33], "y": [4, 5, 6]})
  288: 
  289:         df_s = df.to_string(line_width=1, header=False)
  290:         expected = "0  11  \\\n1  22   \n2  33   \n\n0  4  \n1  5  \n2  6  "
  291: 
  292:         assert df_s == expected
  293: 
  294:         df = DataFrame({"x": [11, 22, -33], "y": [4, 5, -6]})
  295: 
  296:         df_s = df.to_string(line_width=1, header=False)
  297:         expected = "0  11  \\\n1  22   \n2 -33   \n\n0  4  \n1  5  \n2 -6  "
  298: 
  299:         assert df_s == expected
  300: 
  301:     def test_to_string_line_width_with_both_index_and_header(self):
  302:         # GH#53054
  303:         df = DataFrame({"x": [1, 2, 3], "y": [4, 5, 6]})
  304: 
  305:         df_s = df.to_string(line_width=1)
  306:         expected = (
  307:             "   x  \\\n0  1   \n1  2   \n2  3   \n\n   y  \n0  4  \n1  5  \n2  6  "
  308:         )
  309: 
  310:         assert df_s == expected
  311: 
  312:         df = DataFrame({"x": [11, 22, 33], "y": [4, 5, 6]})
  313: 
  314:         df_s = df.to_string(line_width=1)
  315:         expected = (
  316:             "    x  \\\n0  11   \n1  22   \n2  33   \n\n   y  \n0  4  \n1  5  \n2  6  "
  317:         )
  318: 
  319:         assert df_s == expected
  320: 
  321:         df = DataFrame({"x": [11, 22, -33], "y": [4, 5, -6]})
  322: 
  323:         df_s = df.to_string(line_width=1)
  324:         expected = (
  325:             "    x  \\\n0  11   \n1  22   \n2 -33   \n\n   y  \n0  4  \n1  5  \n2 -6  "
  326:         )
  327: 
  328:         assert df_s == expected
  329: 
  330:     def test_to_string_line_width_no_index_no_header(self):
  331:         # GH#53054
  332:         df = DataFrame({"x": [1, 2, 3], "y": [4, 5, 6]})
  333: 
  334:         df_s = df.to_string(line_width=1, index=False, header=False)
  335:         expected = "1  \\\n2   \n3   \n\n4  \n5  \n6  "
  336: 
  337:         assert df_s == expected
  338: 
  339:         df = DataFrame({"x": [11, 22, 33], "y": [4, 5, 6]})
  340: 
  341:         df_s = df.to_string(line_width=1, index=False, header=False)
  342:         expected = "11  \\\n22   \n33   \n\n4  \n5  \n6  "
  343: 
  344:         assert df_s == expected
  345: 
  346:         df = DataFrame({"x": [11, 22, -33], "y": [4, 5, -6]})
  347: 
  348:         df_s = df.to_string(line_width=1, index=False, header=False)
  349:         expected = " 11  \\\n 22   \n-33   \n\n 4  \n 5  \n-6  "
  350: 
  351:         assert df_s == expected
  352: 
  353: 
  354: class TestToStringNumericFormatting:
  355:     def test_to_string_float_format_no_fixed_width(self):
  356:         # GH#21625
  357:         df = DataFrame({"x": [0.19999]})
  358:         expected = "      x\n0 0.200"
  359:         assert df.to_string(float_format="%.3f") == expected
  360: 
  361:         # GH#22270
  362:         df = DataFrame({"x": [100.0]})
  363:         expected = "    x\n0 100"
  364:         assert df.to_string(float_format="%.0f") == expected
  365: 
  366:     def test_to_string_small_float_values(self):
  367:         df = DataFrame({"a": [1.5, 1e-17, -5.5e-7]})
  368: 
  369:         result = df.to_string()
  370:         # sadness per above
  371:         if _three_digit_exp():
  372:             expected = (
  373:                 "               a\n"
  374:                 "0  1.500000e+000\n"
  375:                 "1  1.000000e-017\n"
  376:                 "2 -5.500000e-007"
  377:             )
  378:         else:
  379:             expected = (
  380:                 "              a\n"
  381:                 "0  1.500000e+00\n"
  382:                 "1  1.000000e-17\n"
  383:                 "2 -5.500000e-07"
  384:             )
  385:         assert result == expected
  386: 
  387:         # but not all exactly zero
  388:         df = df * 0
  389:         result = df.to_string()
  390:         expected = "   0\n0  0\n1  0\n2 -0"
  391:         # TODO: assert that these match??
  392: 
  393:     def test_to_string_complex_float_formatting(self):
  394:         # GH #25514, 25745
  395:         with option_context("display.precision", 5):
  396:             df = DataFrame(
  397:                 {
  398:                     "x": [
  399:                         (0.4467846931321966 + 0.0715185102060818j),
  400:                         (0.2739442392974528 + 0.23515228785438969j),
  401:                         (0.26974928742135185 + 0.3250604054898979j),
  402:                         (-1j),
  403:                     ]
  404:                 }
  405:             )
  406:             result = df.to_string()
  407:             expected = (
  408:                 "                  x\n0  0.44678+0.07152j\n"
  409:                 "1  0.27394+0.23515j\n"
  410:                 "2  0.26975+0.32506j\n"
  411:                 "3 -0.00000-1.00000j"
  412:             )
  413:             assert result == expected
  414: 
  415:     def test_to_string_format_inf(self):
  416:         # GH#24861
  417:         df = DataFrame(
  418:             {
  419:                 "A": [-np.inf, np.inf, -1, -2.1234, 3, 4],
  420:                 "B": [-np.inf, np.inf, "foo", "foooo", "fooooo", "bar"],
  421:             }
  422:         )
  423:         result = df.to_string()
  424: 
  425:         expected = (
  426:             "        A       B\n"
  427:             "0    -inf    -inf\n"
  428:             "1     inf     inf\n"
  429:             "2 -1.0000     foo\n"
  430:             "3 -2.1234   foooo\n"
  431:             "4  3.0000  fooooo\n"
  432:             "5  4.0000     bar"
  433:         )
  434:         assert result == expected
  435: 
  436:         df = DataFrame(
  437:             {
  438:                 "A": [-np.inf, np.inf, -1.0, -2.0, 3.0, 4.0],
  439:                 "B": [-np.inf, np.inf, "foo", "foooo", "fooooo", "bar"],
  440:             }
  441:         )
  442:         result = df.to_string()
  443: 
  444:         expected = (
  445:             "     A       B\n"
  446:             "0 -inf    -inf\n"
  447:             "1  inf     inf\n"
  448:             "2 -1.0     foo\n"
  449:             "3 -2.0   foooo\n"
  450:             "4  3.0  fooooo\n"
  451:             "5  4.0     bar"
  452:         )
  453:         assert result == expected
  454: 
  455:     def test_to_string_int_formatting(self):
  456:         df = DataFrame({"x": [-15, 20, 25, -35]})
  457:         assert issubclass(df["x"].dtype.type, np.integer)
  458: 
  459:         output = df.to_string()
  460:         expected = "    x\n0 -15\n1  20\n2  25\n3 -35"
  461:         assert output == expected
  462: 
  463:     def test_to_string_float_formatting(self):
  464:         with option_context(
  465:             "display.precision",
  466:             5,
  467:             "display.notebook_repr_html",
  468:             False,
  469:         ):
  470:             df = DataFrame(
  471:                 {"x": [0, 0.25, 3456.000, 12e45, 1.64e6, 1.7e8, 1.253456, np.pi, -1e6]}
  472:             )
  473: 
  474:             df_s = df.to_string()
  475: 
  476:             if _three_digit_exp():
  477:                 expected = (
  478:                     "              x\n0  0.00000e+000\n1  2.50000e-001\n"
  479:                     "2  3.45600e+003\n3  1.20000e+046\n4  1.64000e+006\n"
  480:                     "5  1.70000e+008\n6  1.25346e+000\n7  3.14159e+000\n"
  481:                     "8 -1.00000e+006"
  482:                 )
  483:             else:
  484:                 expected = (
  485:                     "             x\n0  0.00000e+00\n1  2.50000e-01\n"
  486:                     "2  3.45600e+03\n3  1.20000e+46\n4  1.64000e+06\n"
  487:                     "5  1.70000e+08\n6  1.25346e+00\n7  3.14159e+00\n"
  488:                     "8 -1.00000e+06"
  489:                 )
  490:             assert df_s == expected
  491: 
  492:             df = DataFrame({"x": [3234, 0.253]})
  493:             df_s = df.to_string()
  494: 
  495:             expected = "          x\n0  3234.000\n1     0.253"
  496:             assert df_s == expected
  497: 
  498:         assert get_option("display.precision") == 6
  499: 
  500:         df = DataFrame({"x": [1e9, 0.2512]})
  501:         df_s = df.to_string()
  502: 
  503:         if _three_digit_exp():
  504:             expected = "               x\n0  1.000000e+009\n1  2.512000e-001"
  505:         else:
  506:             expected = "              x\n0  1.000000e+09\n1  2.512000e-01"
  507:         assert df_s == expected
  508: 
  509: 
  510: class TestDataFrameToString:
  511:     def test_to_string_decimal(self):
  512:         # GH#23614
  513:         df = DataFrame({"A": [6.0, 3.1, 2.2]})
  514:         expected = "     A\n0  6,0\n1  3,1\n2  2,2"
  515:         assert df.to_string(decimal=",") == expected
  516: 
  517:     def test_to_string_left_justify_cols(self):
  518:         df = DataFrame({"x": [3234, 0.253]})
  519:         df_s = df.to_string(justify="left")
  520:         expected = "   x       \n0  3234.000\n1     0.253"
  521:         assert df_s == expected
  522: 
  523:     def test_to_string_format_na(self):
  524:         df = DataFrame(
  525:             {
  526:                 "A": [np.nan, -1, -2.1234, 3, 4],
  527:                 "B": [np.nan, "foo", "foooo", "fooooo", "bar"],
  528:             }
  529:         )
  530:         result = df.to_string()
  531: 
  532:         expected = (
  533:             "        A       B\n"
  534:             "0     NaN     NaN\n"
  535:             "1 -1.0000     foo\n"
  536:             "2 -2.1234   foooo\n"
  537:             "3  3.0000  fooooo\n"
  538:             "4  4.0000     bar"
  539:         )
  540:         assert result == expected
  541: 
  542:         df = DataFrame(
  543:             {
  544:                 "A": [np.nan, -1.0, -2.0, 3.0, 4.0],
  545:                 "B": [np.nan, "foo", "foooo", "fooooo", "bar"],
  546:             }
  547:         )
  548:         result = df.to_string()
  549: 
  550:         expected = (
  551:             "     A       B\n"
  552:             "0  NaN     NaN\n"
  553:             "1 -1.0     foo\n"
  554:             "2 -2.0   foooo\n"
  555:             "3  3.0  fooooo\n"
  556:             "4  4.0     bar"
  557:         )
  558:         assert result == expected
  559: 
  560:     def test_to_string_with_dict_entries(self):
  561:         df = DataFrame({"A": [{"a": 1, "b": 2}]})
  562: 
  563:         val = df.to_string()
  564:         assert "'a': 1" in val
  565:         assert "'b': 2" in val
  566: 
  567:     def test_to_string_with_categorical_columns(self):
  568:         # GH#35439
  569:         data = [[4, 2], [3, 2], [4, 3]]
  570:         cols = ["aaaaaaaaa", "b"]
  571:         df = DataFrame(data, columns=cols)
  572:         df_cat_cols = DataFrame(data, columns=CategoricalIndex(cols))
  573: 
  574:         assert df.to_string() == df_cat_cols.to_string()
  575: 
  576:     def test_repr_embedded_ndarray(self):
  577:         arr = np.empty(10, dtype=[("err", object)])
  578:         for i in range(len(arr)):
  579:             arr["err"][i] = np.random.default_rng(2).standard_normal(i)
  580: 
  581:         df = DataFrame(arr)
  582:         repr(df["err"])
  583:         repr(df)
  584:         df.to_string()
  585: 
  586:     def test_to_string_truncate(self):
  587:         # GH 9784 - dont truncate when calling DataFrame.to_string
  588:         df = DataFrame(
  589:             [
  590:                 {
  591:                     "a": "foo",
  592:                     "b": "bar",
  593:                     "c": "let's make this a very VERY long line that is longer "
  594:                     "than the default 50 character limit",
  595:                     "d": 1,
  596:                 },
  597:                 {"a": "foo", "b": "bar", "c": "stuff", "d": 1},
  598:             ]
  599:         )
  600:         df.set_index(["a", "b", "c"])
  601:         assert df.to_string() == (
  602:             "     a    b                                         "
  603:             "                                                c  d\n"
  604:             "0  foo  bar  let's make this a very VERY long line t"
  605:             "hat is longer than the default 50 character limit  1\n"
  606:             "1  foo  bar                                         "
  607:             "                                            stuff  1"
  608:         )
  609:         with option_context("max_colwidth", 20):
  610:             # the display option has no effect on the to_string method
  611:             assert df.to_string() == (
  612:                 "     a    b                                         "
  613:                 "                                                c  d\n"
  614:                 "0  foo  bar  let's make this a very VERY long line t"
  615:                 "hat is longer than the default 50 character limit  1\n"
  616:                 "1  foo  bar                                         "
  617:                 "                                            stuff  1"
  618:             )
  619:         assert df.to_string(max_colwidth=20) == (
  620:             "     a    b                    c  d\n"
  621:             "0  foo  bar  let's make this ...  1\n"
  622:             "1  foo  bar                stuff  1"
  623:         )
  624: 
  625:     @pytest.mark.parametrize(
  626:         "input_array, expected",
  627:         [
  628:             ({"A": ["a"]}, "A\na"),
  629:             ({"A": ["a", "b"], "B": ["c", "dd"]}, "A  B\na  c\nb dd"),
  630:             ({"A": ["a", 1], "B": ["aa", 1]}, "A  B\na aa\n1  1"),
  631:         ],
  632:     )
  633:     def test_format_remove_leading_space_dataframe(self, input_array, expected):
  634:         # GH#24980
  635:         df = DataFrame(input_array).to_string(index=False)
  636:         assert df == expected
  637: 
  638:     @pytest.mark.parametrize(
  639:         "data,expected",
  640:         [
  641:             (
  642:                 {"col1": [1, 2], "col2": [3, 4]},
  643:                 "   col1  col2\n0     1     3\n1     2     4",
  644:             ),
  645:             (
  646:                 {"col1": ["Abc", 0.756], "col2": [np.nan, 4.5435]},
  647:                 "    col1    col2\n0    Abc     NaN\n1  0.756  4.5435",
  648:             ),
  649:             (
  650:                 {"col1": [np.nan, "a"], "col2": [0.009, 3.543], "col3": ["Abc", 23]},
  651:                 "  col1   col2 col3\n0  NaN  0.009  Abc\n1    a  3.543   23",
  652:             ),
  653:         ],
  654:     )
  655:     def test_to_string_max_rows_zero(self, data, expected):
  656:         # GH#35394
  657:         result = DataFrame(data=data).to_string(max_rows=0)
  658:         assert result == expected
  659: 
  660:     @pytest.mark.parametrize(
  661:         "max_cols, max_rows, expected",
  662:         [
  663:             (
  664:                 10,
  665:                 None,
  666:                 " 0   1   2   3   4   ...  6   7   8   9   10\n"
  667:                 "  0   0   0   0   0  ...   0   0   0   0   0\n"
  668:                 "  0   0   0   0   0  ...   0   0   0   0   0\n"
  669:                 "  0   0   0   0   0  ...   0   0   0   0   0\n"
  670:                 "  0   0   0   0   0  ...   0   0   0   0   0",
  671:             ),
  672:             (
  673:                 None,
  674:                 2,
  675:                 " 0   1   2   3   4   5   6   7   8   9   10\n"
  676:                 "  0   0   0   0   0   0   0   0   0   0   0\n"
  677:                 " ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\n"
  678:                 "  0   0   0   0   0   0   0   0   0   0   0",
  679:             ),
  680:             (
  681:                 10,
  682:                 2,
  683:                 " 0   1   2   3   4   ...  6   7   8   9   10\n"
  684:                 "  0   0   0   0   0  ...   0   0   0   0   0\n"
  685:                 " ..  ..  ..  ..  ..  ...  ..  ..  ..  ..  ..\n"
  686:                 "  0   0   0   0   0  ...   0   0   0   0   0",
  687:             ),
  688:             (
  689:                 9,
  690:                 2,
  691:                 " 0   1   2   3   ...  7   8   9   10\n"
  692:                 "  0   0   0   0  ...   0   0   0   0\n"
  693:                 " ..  ..  ..  ..  ...  ..  ..  ..  ..\n"
  694:                 "  0   0   0   0  ...   0   0   0   0",
  695:             ),
  696:             (
  697:                 1,
  698:                 1,
  699:                 " 0  ...\n 0  ...\n..  ...",
  700:             ),
  701:         ],
  702:     )
  703:     def test_truncation_no_index(self, max_cols, max_rows, expected):
  704:         df = DataFrame([[0] * 11] * 4)
  705:         assert (
  706:             df.to_string(index=False, max_cols=max_cols, max_rows=max_rows) == expected
  707:         )
  708: 
  709:     def test_to_string_no_index(self):
  710:         # GH#16839, GH#13032
  711:         df = DataFrame({"x": [11, 22], "y": [33, -44], "z": ["AAA", "   "]})
  712: 
  713:         df_s = df.to_string(index=False)
  714:         # Leading space is expected for positive numbers.
  715:         expected = " x   y   z\n11  33 AAA\n22 -44    "
  716:         assert df_s == expected
  717: 
  718:         df_s = df[["y", "x", "z"]].to_string(index=False)
  719:         expected = "  y  x   z\n 33 11 AAA\n-44 22    "
  720:         assert df_s == expected
  721: 
  722:     def test_to_string_unicode_columns(self, float_frame):
  723:         df = DataFrame({"\u03c3": np.arange(10.0)})
  724: 
  725:         buf = StringIO()
  726:         df.to_string(buf=buf)
  727:         buf.getvalue()
  728: 
  729:         buf = StringIO()
  730:         df.info(buf=buf)
  731:         buf.getvalue()
  732: 
  733:         result = float_frame.to_string()
  734:         assert isinstance(result, str)
  735: 
  736:     @pytest.mark.parametrize("na_rep", ["NaN", "Ted"])
  737:     def test_to_string_na_rep_and_float_format(self, na_rep):
  738:         # GH#13828
  739:         df = DataFrame([["A", 1.2225], ["A", None]], columns=["Group", "Data"])
  740:         result = df.to_string(na_rep=na_rep, float_format="{:.2f}".format)
  741:         expected = dedent(
  742:             f"""\
  743:                Group  Data
  744:              0     A  1.22
  745:              1     A   {na_rep}"""
  746:         )
  747:         assert result == expected
  748: 
  749:     def test_to_string_string_dtype(self):
  750:         # GH#50099
  751:         pytest.importorskip("pyarrow")
  752:         df = DataFrame(
  753:             {"x": ["foo", "bar", "baz"], "y": ["a", "b", "c"], "z": [1, 2, 3]}
  754:         )
  755:         df = df.astype(
  756:             {"x": "string[pyarrow]", "y": "string[python]", "z": "int64[pyarrow]"}
  757:         )
  758:         result = df.dtypes.to_string()
  759:         expected = dedent(
  760:             """\
  761:             x    string[pyarrow]
  762:             y     string[python]
  763:             z     int64[pyarrow]"""
  764:         )
  765:         assert result == expected
  766: 
  767:     def test_to_string_pos_args_deprecation(self):
  768:         # GH#54229
  769:         df = DataFrame({"a": [1, 2, 3]})
  770:         msg = (
  771:             "Starting with pandas version 3.0 all arguments of to_string "
  772:             "except for the "
  773:             "argument 'buf' will be keyword-only."
  774:         )
  775:         with tm.assert_produces_warning(FutureWarning, match=msg):
  776:             buf = StringIO()
  777:             df.to_string(buf, None, None, True, True)
  778: 
  779:     def test_to_string_utf8_columns(self):
  780:         n = "\u05d0".encode()
  781:         df = DataFrame([1, 2], columns=[n])
  782: 
  783:         with option_context("display.max_rows", 1):
  784:             repr(df)
  785: 
  786:     def test_to_string_unicode_two(self):
  787:         dm = DataFrame({"c/\u03c3": []})
  788:         buf = StringIO()
  789:         dm.to_string(buf)
  790: 
  791:     def test_to_string_unicode_three(self):
  792:         dm = DataFrame(["\xc2"])
  793:         buf = StringIO()
  794:         dm.to_string(buf)
  795: 
  796:     def test_to_string_with_float_index(self):
  797:         index = Index([1.5, 2, 3, 4, 5])
  798:         df = DataFrame(np.arange(5), index=index)
  799: 
  800:         result = df.to_string()
  801:         expected = "     0\n1.5  0\n2.0  1\n3.0  2\n4.0  3\n5.0  4"
  802:         assert result == expected
  803: 
  804:     def test_to_string(self):
  805:         # big mixed
  806:         biggie = DataFrame(
  807:             {
  808:                 "A": np.random.default_rng(2).standard_normal(200),
  809:                 "B": Index([f"{i}?!" for i in range(200)]),
  810:             },
  811:         )
  812: 
  813:         biggie.loc[:20, "A"] = np.nan
  814:         biggie.loc[:20, "B"] = np.nan
  815:         s = biggie.to_string()
  816: 
  817:         buf = StringIO()
  818:         retval = biggie.to_string(buf=buf)
  819:         assert retval is None
  820:         assert buf.getvalue() == s
  821: 
  822:         assert isinstance(s, str)
  823: 
  824:         # print in right order
  825:         result = biggie.to_string(
  826:             columns=["B", "A"], col_space=17, float_format="%.5f".__mod__
  827:         )
  828:         lines = result.split("\n")
  829:         header = lines[0].strip().split()
  830:         joined = "\n".join([re.sub(r"\s+", " ", x).strip() for x in lines[1:]])
  831:         recons = read_csv(StringIO(joined), names=header, header=None, sep=" ")
  832:         tm.assert_series_equal(recons["B"], biggie["B"])
  833:         assert recons["A"].count() == biggie["A"].count()
  834:         assert (np.abs(recons["A"].dropna() - biggie["A"].dropna()) < 0.1).all()
  835: 
  836:         # FIXME: don't leave commented-out
  837:         # expected = ['B', 'A']
  838:         # assert header == expected
  839: 
  840:         result = biggie.to_string(columns=["A"], col_space=17)
  841:         header = result.split("\n")[0].strip().split()
  842:         expected = ["A"]
  843:         assert header == expected
  844: 
  845:         biggie.to_string(columns=["B", "A"], formatters={"A": lambda x: f"{x:.1f}"})
  846: 
  847:         biggie.to_string(columns=["B", "A"], float_format=str)
  848:         biggie.to_string(columns=["B", "A"], col_space=12, float_format=str)
  849: 
  850:         frame = DataFrame(index=np.arange(200))
  851:         frame.to_string()
  852: 
  853:     # TODO: split or simplify this test?
  854:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="fix when arrow is default")
  855:     def test_to_string_index_with_nan(self):
  856:         # GH#2850
  857:         df = DataFrame(
  858:             {
  859:                 "id1": {0: "1a3", 1: "9h4"},
  860:                 "id2": {0: np.nan, 1: "d67"},
  861:                 "id3": {0: "78d", 1: "79d"},
  862:                 "value": {0: 123, 1: 64},
  863:             }
  864:         )
  865: 
  866:         # multi-index
  867:         y = df.set_index(["id1", "id2", "id3"])
  868:         result = y.to_string()
  869:         expected = (
  870:             "             value\nid1 id2 id3       \n"
  871:             "1a3 NaN 78d    123\n9h4 d67 79d     64"
  872:         )
  873:         assert result == expected
  874: 
  875:         # index
  876:         y = df.set_index("id2")
  877:         result = y.to_string()
  878:         expected = (
  879:             "     id1  id3  value\nid2                 \n"
  880:             "NaN  1a3  78d    123\nd67  9h4  79d     64"
  881:         )
  882:         assert result == expected
  883: 
  884:         # with append (this failed in 0.12)
  885:         y = df.set_index(["id1", "id2"]).set_index("id3", append=True)
  886:         result = y.to_string()
  887:         expected = (
  888:             "             value\nid1 id2 id3       \n"
  889:             "1a3 NaN 78d    123\n9h4 d67 79d     64"
  890:         )
  891:         assert result == expected
  892: 
  893:         # all-nan in mi
  894:         df2 = df.copy()
  895:         df2.loc[:, "id2"] = np.nan
  896:         y = df2.set_index("id2")
  897:         result = y.to_string()
  898:         expected = (
  899:             "     id1  id3  value\nid2                 \n"
  900:             "NaN  1a3  78d    123\nNaN  9h4  79d     64"
  901:         )
  902:         assert result == expected
  903: 
  904:         # partial nan in mi
  905:         df2 = df.copy()
  906:         df2.loc[:, "id2"] = np.nan
  907:         y = df2.set_index(["id2", "id3"])
  908:         result = y.to_string()
  909:         expected = (
  910:             "         id1  value\nid2 id3            \n"
  911:             "NaN 78d  1a3    123\n    79d  9h4     64"
  912:         )
  913:         assert result == expected
  914: 
  915:         df = DataFrame(
  916:             {
  917:                 "id1": {0: np.nan, 1: "9h4"},
  918:                 "id2": {0: np.nan, 1: "d67"},
  919:                 "id3": {0: np.nan, 1: "79d"},
  920:                 "value": {0: 123, 1: 64},
  921:             }
  922:         )
  923: 
  924:         y = df.set_index(["id1", "id2", "id3"])
  925:         result = y.to_string()
  926:         expected = (
  927:             "             value\nid1 id2 id3       \n"
  928:             "NaN NaN NaN    123\n9h4 d67 79d     64"
  929:         )
  930:         assert result == expected
  931: 
  932:     def test_to_string_nonunicode_nonascii_alignment(self):
  933:         df = DataFrame([["aa\xc3\xa4\xc3\xa4", 1], ["bbbb", 2]])
  934:         rep_str = df.to_string()
  935:         lines = rep_str.split("\n")
  936:         assert len(lines[1]) == len(lines[2])
  937: 
  938:     def test_unicode_problem_decoding_as_ascii(self):
  939:         df = DataFrame({"c/\u03c3": Series({"test": np.nan})})
  940:         str(df.to_string())
  941: 
  942:     def test_to_string_repr_unicode(self):
  943:         buf = StringIO()
  944: 
  945:         unicode_values = ["\u03c3"] * 10
  946:         unicode_values = np.array(unicode_values, dtype=object)
  947:         df = DataFrame({"unicode": unicode_values})
  948:         df.to_string(col_space=10, buf=buf)
  949: 
  950:         # it works!
  951:         repr(df)
  952:         # it works even if sys.stdin in None
  953:         _stdin = sys.stdin
  954:         try:
  955:             sys.stdin = None
  956:             repr(df)
  957:         finally:
  958:             sys.stdin = _stdin
  959: 
  960: 
  961: class TestSeriesToString:
  962:     def test_to_string_without_index(self):
  963:         # GH#11729 Test index=False option
  964:         ser = Series([1, 2, 3, 4])
  965:         result = ser.to_string(index=False)
  966:         expected = "\n".join(["1", "2", "3", "4"])
  967:         assert result == expected
  968: 
  969:     def test_to_string_name(self):
  970:         ser = Series(range(100), dtype="int64")
  971:         ser.name = "myser"
  972:         res = ser.to_string(max_rows=2, name=True)
  973:         exp = "0      0\n      ..\n99    99\nName: myser"
  974:         assert res == exp
  975:         res = ser.to_string(max_rows=2, name=False)
  976:         exp = "0      0\n      ..\n99    99"
  977:         assert res == exp
  978: 
  979:     def test_to_string_dtype(self):
  980:         ser = Series(range(100), dtype="int64")
  981:         res = ser.to_string(max_rows=2, dtype=True)
  982:         exp = "0      0\n      ..\n99    99\ndtype: int64"
  983:         assert res == exp
  984:         res = ser.to_string(max_rows=2, dtype=False)
  985:         exp = "0      0\n      ..\n99    99"
  986:         assert res == exp
  987: 
  988:     def test_to_string_length(self):
  989:         ser = Series(range(100), dtype="int64")
  990:         res = ser.to_string(max_rows=2, length=True)
  991:         exp = "0      0\n      ..\n99    99\nLength: 100"
  992:         assert res == exp
  993: 
  994:     def test_to_string_na_rep(self):
  995:         ser = Series(index=range(100), dtype=np.float64)
  996:         res = ser.to_string(na_rep="foo", max_rows=2)
  997:         exp = "0    foo\n      ..\n99   foo"
  998:         assert res == exp
  999: 
 1000:     def test_to_string_float_format(self):
 1001:         ser = Series(range(10), dtype="float64")
 1002:         res = ser.to_string(float_format=lambda x: f"{x:2.1f}", max_rows=2)
 1003:         exp = "0   0.0\n     ..\n9   9.0"
 1004:         assert res == exp
 1005: 
 1006:     def test_to_string_header(self):
 1007:         ser = Series(range(10), dtype="int64")
 1008:         ser.index.name = "foo"
 1009:         res = ser.to_string(header=True, max_rows=2)
 1010:         exp = "foo\n0    0\n    ..\n9    9"
 1011:         assert res == exp
 1012:         res = ser.to_string(header=False, max_rows=2)
 1013:         exp = "0    0\n    ..\n9    9"
 1014:         assert res == exp
 1015: 
 1016:     def test_to_string_empty_col(self):
 1017:         # GH#13653
 1018:         ser = Series(["", "Hello", "World", "", "", "Mooooo", "", ""])
 1019:         res = ser.to_string(index=False)
 1020:         exp = "      \n Hello\n World\n      \n      \nMooooo\n      \n      "
 1021:         assert re.match(exp, res)
 1022: 
 1023:     def test_to_string_timedelta64(self):
 1024:         Series(np.array([1100, 20], dtype="timedelta64[ns]")).to_string()
 1025: 
 1026:         ser = Series(date_range("2012-1-1", periods=3, freq="D"))
 1027: 
 1028:         # GH#2146
 1029: 
 1030:         # adding NaTs
 1031:         y = ser - ser.shift(1)
 1032:         result = y.to_string()
 1033:         assert "1 days" in result
 1034:         assert "00:00:00" not in result
 1035:         assert "NaT" in result
 1036: 
 1037:         # with frac seconds
 1038:         o = Series([datetime(2012, 1, 1, microsecond=150)] * 3)
 1039:         y = ser - o
 1040:         result = y.to_string()
 1041:         assert "-1 days +23:59:59.999850" in result
 1042: 
 1043:         # rounding?
 1044:         o = Series([datetime(2012, 1, 1, 1)] * 3)
 1045:         y = ser - o
 1046:         result = y.to_string()
 1047:         assert "-1 days +23:00:00" in result
 1048:         assert "1 days 23:00:00" in result
 1049: 
 1050:         o = Series([datetime(2012, 1, 1, 1, 1)] * 3)
 1051:         y = ser - o
 1052:         result = y.to_string()
 1053:         assert "-1 days +22:59:00" in result
 1054:         assert "1 days 22:59:00" in result
 1055: 
 1056:         o = Series([datetime(2012, 1, 1, 1, 1, microsecond=150)] * 3)
 1057:         y = ser - o
 1058:         result = y.to_string()
 1059:         assert "-1 days +22:58:59.999850" in result
 1060:         assert "0 days 22:58:59.999850" in result
 1061: 
 1062:         # neg time
 1063:         td = timedelta(minutes=5, seconds=3)
 1064:         s2 = Series(date_range("2012-1-1", periods=3, freq="D")) + td
 1065:         y = ser - s2
 1066:         result = y.to_string()
 1067:         assert "-1 days +23:54:57" in result
 1068: 
 1069:         td = timedelta(microseconds=550)
 1070:         s2 = Series(date_range("2012-1-1", periods=3, freq="D")) + td
 1071:         y = ser - td
 1072:         result = y.to_string()
 1073:         assert "2012-01-01 23:59:59.999450" in result
 1074: 
 1075:         # no boxing of the actual elements
 1076:         td = Series(timedelta_range("1 days", periods=3))
 1077:         result = td.to_string()
 1078:         assert result == "0   1 days\n1   2 days\n2   3 days"
 1079: 
 1080:     def test_to_string(self):
 1081:         ts = Series(
 1082:             np.arange(10, dtype=np.float64),
 1083:             index=date_range("2020-01-01", periods=10, freq="B"),
 1084:         )
 1085:         buf = StringIO()
 1086: 
 1087:         s = ts.to_string()
 1088: 
 1089:         retval = ts.to_string(buf=buf)
 1090:         assert retval is None
 1091:         assert buf.getvalue().strip() == s
 1092: 
 1093:         # pass float_format
 1094:         format = "%.4f".__mod__
 1095:         result = ts.to_string(float_format=format)
 1096:         result = [x.split()[1] for x in result.split("\n")[:-1]]
 1097:         expected = [format(x) for x in ts]
 1098:         assert result == expected
 1099: 
 1100:         # empty string
 1101:         result = ts[:0].to_string()
 1102:         assert result == "Series([], Freq: B)"
 1103: 
 1104:         result = ts[:0].to_string(length=0)
 1105:         assert result == "Series([], Freq: B)"
 1106: 
 1107:         # name and length
 1108:         cp = ts.copy()
 1109:         cp.name = "foo"
 1110:         result = cp.to_string(length=True, name=True, dtype=True)
 1111:         last_line = result.split("\n")[-1].strip()
 1112:         assert last_line == (f"Freq: B, Name: foo, Length: {len(cp)}, dtype: float64")
 1113: 
 1114:     @pytest.mark.parametrize(
 1115:         "input_array, expected",
 1116:         [
 1117:             ("a", "a"),
 1118:             (["a", "b"], "a\nb"),
 1119:             ([1, "a"], "1\na"),
 1120:             (1, "1"),
 1121:             ([0, -1], " 0\n-1"),
 1122:             (1.0, "1.0"),
 1123:             ([" a", " b"], " a\n b"),
 1124:             ([".1", "1"], ".1\n 1"),
 1125:             (["10", "-10"], " 10\n-10"),
 1126:         ],
 1127:     )
 1128:     def test_format_remove_leading_space_series(self, input_array, expected):
 1129:         # GH: 24980
 1130:         ser = Series(input_array)
 1131:         result = ser.to_string(index=False)
 1132:         assert result == expected
 1133: 
 1134:     def test_to_string_complex_number_trims_zeros(self):
 1135:         ser = Series([1.000000 + 1.000000j, 1.0 + 1.0j, 1.05 + 1.0j])
 1136:         result = ser.to_string()
 1137:         expected = dedent(
 1138:             """\
 1139:             0    1.00+1.00j
 1140:             1    1.00+1.00j
 1141:             2    1.05+1.00j"""
 1142:         )
 1143:         assert result == expected
 1144: 
 1145:     def test_nullable_float_to_string(self, float_ea_dtype):
 1146:         # https://github.com/pandas-dev/pandas/issues/36775
 1147:         dtype = float_ea_dtype
 1148:         ser = Series([0.0, 1.0, None], dtype=dtype)
 1149:         result = ser.to_string()
 1150:         expected = dedent(
 1151:             """\
 1152:             0     0.0
 1153:             1     1.0
 1154:             2    <NA>"""
 1155:         )
 1156:         assert result == expected
 1157: 
 1158:     def test_nullable_int_to_string(self, any_int_ea_dtype):
 1159:         # https://github.com/pandas-dev/pandas/issues/36775
 1160:         dtype = any_int_ea_dtype
 1161:         ser = Series([0, 1, None], dtype=dtype)
 1162:         result = ser.to_string()
 1163:         expected = dedent(
 1164:             """\
 1165:             0       0
 1166:             1       1
 1167:             2    <NA>"""
 1168:         )
 1169:         assert result == expected
 1170: 
 1171:     def test_to_string_mixed(self):
 1172:         ser = Series(["foo", np.nan, -1.23, 4.56])
 1173:         result = ser.to_string()
 1174:         expected = "".join(["0     foo\n", "1     NaN\n", "2   -1.23\n", "3    4.56"])
 1175:         assert result == expected
 1176: 
 1177:         # but don't count NAs as floats
 1178:         ser = Series(["foo", np.nan, "bar", "baz"])
 1179:         result = ser.to_string()
 1180:         expected = "".join(["0    foo\n", "1    NaN\n", "2    bar\n", "3    baz"])
 1181:         assert result == expected
 1182: 
 1183:         ser = Series(["foo", 5, "bar", "baz"])
 1184:         result = ser.to_string()
 1185:         expected = "".join(["0    foo\n", "1      5\n", "2    bar\n", "3    baz"])
 1186:         assert result == expected
 1187: 
 1188:     def test_to_string_float_na_spacing(self):
 1189:         ser = Series([0.0, 1.5678, 2.0, -3.0, 4.0])
 1190:         ser[::2] = np.nan
 1191: 
 1192:         result = ser.to_string()
 1193:         expected = (
 1194:             "0       NaN\n"
 1195:             "1    1.5678\n"
 1196:             "2       NaN\n"
 1197:             "3   -3.0000\n"
 1198:             "4       NaN"
 1199:         )
 1200:         assert result == expected
 1201: 
 1202:     def test_to_string_with_datetimeindex(self):
 1203:         index = date_range("20130102", periods=6)
 1204:         ser = Series(1, index=index)
 1205:         result = ser.to_string()
 1206:         assert "2013-01-02" in result
 1207: 
 1208:         # nat in index
 1209:         s2 = Series(2, index=[Timestamp("20130111"), NaT])
 1210:         ser = concat([s2, ser])
 1211:         result = ser.to_string()
 1212:         assert "NaT" in result
 1213: 
 1214:         # nat in summary
 1215:         result = str(s2.index)
 1216:         assert "NaT" in result
