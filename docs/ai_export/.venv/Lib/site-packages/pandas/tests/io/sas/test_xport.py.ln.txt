    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: import pandas._testing as tm
    6: 
    7: from pandas.io.sas.sasreader import read_sas
    8: 
    9: # CSV versions of test xpt files were obtained using the R foreign library
   10: 
   11: # Numbers in a SAS xport file are always float64, so need to convert
   12: # before making comparisons.
   13: 
   14: 
   15: def numeric_as_float(data):
   16:     for v in data.columns:
   17:         if data[v].dtype is np.dtype("int64"):
   18:             data[v] = data[v].astype(np.float64)
   19: 
   20: 
   21: class TestXport:
   22:     @pytest.fixture
   23:     def file01(self, datapath):
   24:         return datapath("io", "sas", "data", "DEMO_G.xpt")
   25: 
   26:     @pytest.fixture
   27:     def file02(self, datapath):
   28:         return datapath("io", "sas", "data", "SSHSV1_A.xpt")
   29: 
   30:     @pytest.fixture
   31:     def file03(self, datapath):
   32:         return datapath("io", "sas", "data", "DRXFCD_G.xpt")
   33: 
   34:     @pytest.fixture
   35:     def file04(self, datapath):
   36:         return datapath("io", "sas", "data", "paxraw_d_short.xpt")
   37: 
   38:     @pytest.fixture
   39:     def file05(self, datapath):
   40:         return datapath("io", "sas", "data", "DEMO_PUF.cpt")
   41: 
   42:     @pytest.mark.slow
   43:     def test1_basic(self, file01):
   44:         # Tests with DEMO_G.xpt (all numeric file)
   45: 
   46:         # Compare to this
   47:         data_csv = pd.read_csv(file01.replace(".xpt", ".csv"))
   48:         numeric_as_float(data_csv)
   49: 
   50:         # Read full file
   51:         data = read_sas(file01, format="xport")
   52:         tm.assert_frame_equal(data, data_csv)
   53:         num_rows = data.shape[0]
   54: 
   55:         # Test reading beyond end of file
   56:         with read_sas(file01, format="xport", iterator=True) as reader:
   57:             data = reader.read(num_rows + 100)
   58:         assert data.shape[0] == num_rows
   59: 
   60:         # Test incremental read with `read` method.
   61:         with read_sas(file01, format="xport", iterator=True) as reader:
   62:             data = reader.read(10)
   63:         tm.assert_frame_equal(data, data_csv.iloc[0:10, :])
   64: 
   65:         # Test incremental read with `get_chunk` method.
   66:         with read_sas(file01, format="xport", chunksize=10) as reader:
   67:             data = reader.get_chunk()
   68:         tm.assert_frame_equal(data, data_csv.iloc[0:10, :])
   69: 
   70:         # Test read in loop
   71:         m = 0
   72:         with read_sas(file01, format="xport", chunksize=100) as reader:
   73:             for x in reader:
   74:                 m += x.shape[0]
   75:         assert m == num_rows
   76: 
   77:         # Read full file with `read_sas` method
   78:         data = read_sas(file01)
   79:         tm.assert_frame_equal(data, data_csv)
   80: 
   81:     def test1_index(self, file01):
   82:         # Tests with DEMO_G.xpt using index (all numeric file)
   83: 
   84:         # Compare to this
   85:         data_csv = pd.read_csv(file01.replace(".xpt", ".csv"))
   86:         data_csv = data_csv.set_index("SEQN")
   87:         numeric_as_float(data_csv)
   88: 
   89:         # Read full file
   90:         data = read_sas(file01, index="SEQN", format="xport")
   91:         tm.assert_frame_equal(data, data_csv, check_index_type=False)
   92: 
   93:         # Test incremental read with `read` method.
   94:         with read_sas(file01, index="SEQN", format="xport", iterator=True) as reader:
   95:             data = reader.read(10)
   96:         tm.assert_frame_equal(data, data_csv.iloc[0:10, :], check_index_type=False)
   97: 
   98:         # Test incremental read with `get_chunk` method.
   99:         with read_sas(file01, index="SEQN", format="xport", chunksize=10) as reader:
  100:             data = reader.get_chunk()
  101:         tm.assert_frame_equal(data, data_csv.iloc[0:10, :], check_index_type=False)
  102: 
  103:     def test1_incremental(self, file01):
  104:         # Test with DEMO_G.xpt, reading full file incrementally
  105: 
  106:         data_csv = pd.read_csv(file01.replace(".xpt", ".csv"))
  107:         data_csv = data_csv.set_index("SEQN")
  108:         numeric_as_float(data_csv)
  109: 
  110:         with read_sas(file01, index="SEQN", chunksize=1000) as reader:
  111:             all_data = list(reader)
  112:         data = pd.concat(all_data, axis=0)
  113: 
  114:         tm.assert_frame_equal(data, data_csv, check_index_type=False)
  115: 
  116:     def test2(self, file02):
  117:         # Test with SSHSV1_A.xpt
  118: 
  119:         # Compare to this
  120:         data_csv = pd.read_csv(file02.replace(".xpt", ".csv"))
  121:         numeric_as_float(data_csv)
  122: 
  123:         data = read_sas(file02)
  124:         tm.assert_frame_equal(data, data_csv)
  125: 
  126:     def test2_binary(self, file02):
  127:         # Test with SSHSV1_A.xpt, read as a binary file
  128: 
  129:         # Compare to this
  130:         data_csv = pd.read_csv(file02.replace(".xpt", ".csv"))
  131:         numeric_as_float(data_csv)
  132: 
  133:         with open(file02, "rb") as fd:
  134:             # GH#35693 ensure that if we pass an open file, we
  135:             #  dont incorrectly close it in read_sas
  136:             data = read_sas(fd, format="xport")
  137: 
  138:         tm.assert_frame_equal(data, data_csv)
  139: 
  140:     def test_multiple_types(self, file03):
  141:         # Test with DRXFCD_G.xpt (contains text and numeric variables)
  142: 
  143:         # Compare to this
  144:         data_csv = pd.read_csv(file03.replace(".xpt", ".csv"))
  145: 
  146:         data = read_sas(file03, encoding="utf-8")
  147:         tm.assert_frame_equal(data, data_csv)
  148: 
  149:     def test_truncated_float_support(self, file04):
  150:         # Test with paxraw_d_short.xpt, a shortened version of:
  151:         # http://wwwn.cdc.gov/Nchs/Nhanes/2005-2006/PAXRAW_D.ZIP
  152:         # This file has truncated floats (5 bytes in this case).
  153: 
  154:         # GH 11713
  155: 
  156:         data_csv = pd.read_csv(file04.replace(".xpt", ".csv"))
  157: 
  158:         data = read_sas(file04, format="xport")
  159:         tm.assert_frame_equal(data.astype("int64"), data_csv)
  160: 
  161:     def test_cport_header_found_raises(self, file05):
  162:         # Test with DEMO_PUF.cpt, the beginning of puf2019_1_fall.xpt
  163:         # from https://www.cms.gov/files/zip/puf2019.zip
  164:         # (despite the extension, it's a cpt file)
  165:         msg = "Header record indicates a CPORT file, which is not readable."
  166:         with pytest.raises(ValueError, match=msg):
  167:             read_sas(file05, format="xport")
