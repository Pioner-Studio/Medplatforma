    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._libs.tslibs import Timestamp
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     HDFStore,
   10:     Index,
   11:     MultiIndex,
   12:     Series,
   13:     _testing as tm,
   14:     bdate_range,
   15:     concat,
   16:     date_range,
   17:     isna,
   18:     read_hdf,
   19: )
   20: from pandas.tests.io.pytables.common import (
   21:     _maybe_remove,
   22:     ensure_clean_store,
   23: )
   24: 
   25: from pandas.io.pytables import Term
   26: 
   27: pytestmark = pytest.mark.single_cpu
   28: 
   29: 
   30: def test_select_columns_in_where(setup_path):
   31:     # GH 6169
   32:     # recreate multi-indexes when columns is passed
   33:     # in the `where` argument
   34:     index = MultiIndex(
   35:         levels=[["foo", "bar", "baz", "qux"], ["one", "two", "three"]],
   36:         codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
   37:         names=["foo_name", "bar_name"],
   38:     )
   39: 
   40:     # With a DataFrame
   41:     df = DataFrame(
   42:         np.random.default_rng(2).standard_normal((10, 3)),
   43:         index=index,
   44:         columns=["A", "B", "C"],
   45:     )
   46: 
   47:     with ensure_clean_store(setup_path) as store:
   48:         store.put("df", df, format="table")
   49:         expected = df[["A"]]
   50: 
   51:         tm.assert_frame_equal(store.select("df", columns=["A"]), expected)
   52: 
   53:         tm.assert_frame_equal(store.select("df", where="columns=['A']"), expected)
   54: 
   55:     # With a Series
   56:     s = Series(np.random.default_rng(2).standard_normal(10), index=index, name="A")
   57:     with ensure_clean_store(setup_path) as store:
   58:         store.put("s", s, format="table")
   59:         tm.assert_series_equal(store.select("s", where="columns=['A']"), s)
   60: 
   61: 
   62: def test_select_with_dups(setup_path):
   63:     # single dtypes
   64:     df = DataFrame(
   65:         np.random.default_rng(2).standard_normal((10, 4)), columns=["A", "A", "B", "B"]
   66:     )
   67:     df.index = date_range("20130101 9:30", periods=10, freq="min")
   68: 
   69:     with ensure_clean_store(setup_path) as store:
   70:         store.append("df", df)
   71: 
   72:         result = store.select("df")
   73:         expected = df
   74:         tm.assert_frame_equal(result, expected, by_blocks=True)
   75: 
   76:         result = store.select("df", columns=df.columns)
   77:         expected = df
   78:         tm.assert_frame_equal(result, expected, by_blocks=True)
   79: 
   80:         result = store.select("df", columns=["A"])
   81:         expected = df.loc[:, ["A"]]
   82:         tm.assert_frame_equal(result, expected)
   83: 
   84:     # dups across dtypes
   85:     df = concat(
   86:         [
   87:             DataFrame(
   88:                 np.random.default_rng(2).standard_normal((10, 4)),
   89:                 columns=["A", "A", "B", "B"],
   90:             ),
   91:             DataFrame(
   92:                 np.random.default_rng(2).integers(0, 10, size=20).reshape(10, 2),
   93:                 columns=["A", "C"],
   94:             ),
   95:         ],
   96:         axis=1,
   97:     )
   98:     df.index = date_range("20130101 9:30", periods=10, freq="min")
   99: 
  100:     with ensure_clean_store(setup_path) as store:
  101:         store.append("df", df)
  102: 
  103:         result = store.select("df")
  104:         expected = df
  105:         tm.assert_frame_equal(result, expected, by_blocks=True)
  106: 
  107:         result = store.select("df", columns=df.columns)
  108:         expected = df
  109:         tm.assert_frame_equal(result, expected, by_blocks=True)
  110: 
  111:         expected = df.loc[:, ["A"]]
  112:         result = store.select("df", columns=["A"])
  113:         tm.assert_frame_equal(result, expected, by_blocks=True)
  114: 
  115:         expected = df.loc[:, ["B", "A"]]
  116:         result = store.select("df", columns=["B", "A"])
  117:         tm.assert_frame_equal(result, expected, by_blocks=True)
  118: 
  119:     # duplicates on both index and columns
  120:     with ensure_clean_store(setup_path) as store:
  121:         store.append("df", df)
  122:         store.append("df", df)
  123: 
  124:         expected = df.loc[:, ["B", "A"]]
  125:         expected = concat([expected, expected])
  126:         result = store.select("df", columns=["B", "A"])
  127:         tm.assert_frame_equal(result, expected, by_blocks=True)
  128: 
  129: 
  130: def test_select(setup_path):
  131:     with ensure_clean_store(setup_path) as store:
  132:         # select with columns=
  133:         df = DataFrame(
  134:             np.random.default_rng(2).standard_normal((10, 4)),
  135:             columns=Index(list("ABCD"), dtype=object),
  136:             index=date_range("2000-01-01", periods=10, freq="B"),
  137:         )
  138:         _maybe_remove(store, "df")
  139:         store.append("df", df)
  140:         result = store.select("df", columns=["A", "B"])
  141:         expected = df.reindex(columns=["A", "B"])
  142:         tm.assert_frame_equal(expected, result)
  143: 
  144:         # equivalently
  145:         result = store.select("df", [("columns=['A', 'B']")])
  146:         expected = df.reindex(columns=["A", "B"])
  147:         tm.assert_frame_equal(expected, result)
  148: 
  149:         # with a data column
  150:         _maybe_remove(store, "df")
  151:         store.append("df", df, data_columns=["A"])
  152:         result = store.select("df", ["A > 0"], columns=["A", "B"])
  153:         expected = df[df.A > 0].reindex(columns=["A", "B"])
  154:         tm.assert_frame_equal(expected, result)
  155: 
  156:         # all a data columns
  157:         _maybe_remove(store, "df")
  158:         store.append("df", df, data_columns=True)
  159:         result = store.select("df", ["A > 0"], columns=["A", "B"])
  160:         expected = df[df.A > 0].reindex(columns=["A", "B"])
  161:         tm.assert_frame_equal(expected, result)
  162: 
  163:         # with a data column, but different columns
  164:         _maybe_remove(store, "df")
  165:         store.append("df", df, data_columns=["A"])
  166:         result = store.select("df", ["A > 0"], columns=["C", "D"])
  167:         expected = df[df.A > 0].reindex(columns=["C", "D"])
  168:         tm.assert_frame_equal(expected, result)
  169: 
  170: 
  171: def test_select_dtypes(setup_path):
  172:     with ensure_clean_store(setup_path) as store:
  173:         # with a Timestamp data column (GH #2637)
  174:         df = DataFrame(
  175:             {
  176:                 "ts": bdate_range("2012-01-01", periods=300),
  177:                 "A": np.random.default_rng(2).standard_normal(300),
  178:             }
  179:         )
  180:         _maybe_remove(store, "df")
  181:         store.append("df", df, data_columns=["ts", "A"])
  182: 
  183:         result = store.select("df", "ts>=Timestamp('2012-02-01')")
  184:         expected = df[df.ts >= Timestamp("2012-02-01")]
  185:         tm.assert_frame_equal(expected, result)
  186: 
  187:         # bool columns (GH #2849)
  188:         df = DataFrame(
  189:             np.random.default_rng(2).standard_normal((5, 2)), columns=["A", "B"]
  190:         )
  191:         df["object"] = "foo"
  192:         df.loc[4:5, "object"] = "bar"
  193:         df["boolv"] = df["A"] > 0
  194:         _maybe_remove(store, "df")
  195:         store.append("df", df, data_columns=True)
  196: 
  197:         expected = df[df.boolv == True].reindex(columns=["A", "boolv"])  # noqa: E712
  198:         for v in [True, "true", 1]:
  199:             result = store.select("df", f"boolv == {v}", columns=["A", "boolv"])
  200:             tm.assert_frame_equal(expected, result)
  201: 
  202:         expected = df[df.boolv == False].reindex(columns=["A", "boolv"])  # noqa: E712
  203:         for v in [False, "false", 0]:
  204:             result = store.select("df", f"boolv == {v}", columns=["A", "boolv"])
  205:             tm.assert_frame_equal(expected, result)
  206: 
  207:         # integer index
  208:         df = DataFrame(
  209:             {
  210:                 "A": np.random.default_rng(2).random(20),
  211:                 "B": np.random.default_rng(2).random(20),
  212:             }
  213:         )
  214:         _maybe_remove(store, "df_int")
  215:         store.append("df_int", df)
  216:         result = store.select("df_int", "index<10 and columns=['A']")
  217:         expected = df.reindex(index=list(df.index)[0:10], columns=["A"])
  218:         tm.assert_frame_equal(expected, result)
  219: 
  220:         # float index
  221:         df = DataFrame(
  222:             {
  223:                 "A": np.random.default_rng(2).random(20),
  224:                 "B": np.random.default_rng(2).random(20),
  225:                 "index": np.arange(20, dtype="f8"),
  226:             }
  227:         )
  228:         _maybe_remove(store, "df_float")
  229:         store.append("df_float", df)
  230:         result = store.select("df_float", "index<10.0 and columns=['A']")
  231:         expected = df.reindex(index=list(df.index)[0:10], columns=["A"])
  232:         tm.assert_frame_equal(expected, result)
  233: 
  234:     with ensure_clean_store(setup_path) as store:
  235:         # floats w/o NaN
  236:         df = DataFrame({"cols": range(11), "values": range(11)}, dtype="float64")
  237:         df["cols"] = (df["cols"] + 10).apply(str)
  238: 
  239:         store.append("df1", df, data_columns=True)
  240:         result = store.select("df1", where="values>2.0")
  241:         expected = df[df["values"] > 2.0]
  242:         tm.assert_frame_equal(expected, result)
  243: 
  244:         # floats with NaN
  245:         df.iloc[0] = np.nan
  246:         expected = df[df["values"] > 2.0]
  247: 
  248:         store.append("df2", df, data_columns=True, index=False)
  249:         result = store.select("df2", where="values>2.0")
  250:         tm.assert_frame_equal(expected, result)
  251: 
  252:         # https://github.com/PyTables/PyTables/issues/282
  253:         # bug in selection when 0th row has a np.nan and an index
  254:         # store.append('df3',df,data_columns=True)
  255:         # result = store.select(
  256:         #    'df3', where='values>2.0')
  257:         # tm.assert_frame_equal(expected, result)
  258: 
  259:         # not in first position float with NaN ok too
  260:         df = DataFrame({"cols": range(11), "values": range(11)}, dtype="float64")
  261:         df["cols"] = (df["cols"] + 10).apply(str)
  262: 
  263:         df.iloc[1] = np.nan
  264:         expected = df[df["values"] > 2.0]
  265: 
  266:         store.append("df4", df, data_columns=True)
  267:         result = store.select("df4", where="values>2.0")
  268:         tm.assert_frame_equal(expected, result)
  269: 
  270:     # test selection with comparison against numpy scalar
  271:     # GH 11283
  272:     with ensure_clean_store(setup_path) as store:
  273:         df = DataFrame(
  274:             1.1 * np.arange(120).reshape((30, 4)),
  275:             columns=Index(list("ABCD"), dtype=object),
  276:             index=Index([f"i-{i}" for i in range(30)], dtype=object),
  277:         )
  278: 
  279:         expected = df[df["A"] > 0]
  280: 
  281:         store.append("df", df, data_columns=True)
  282:         np_zero = np.float64(0)  # noqa: F841
  283:         result = store.select("df", where=["A>np_zero"])
  284:         tm.assert_frame_equal(expected, result)
  285: 
  286: 
  287: def test_select_with_many_inputs(setup_path):
  288:     with ensure_clean_store(setup_path) as store:
  289:         df = DataFrame(
  290:             {
  291:                 "ts": bdate_range("2012-01-01", periods=300),
  292:                 "A": np.random.default_rng(2).standard_normal(300),
  293:                 "B": range(300),
  294:                 "users": ["a"] * 50
  295:                 + ["b"] * 50
  296:                 + ["c"] * 100
  297:                 + [f"a{i:03d}" for i in range(100)],
  298:             }
  299:         )
  300:         _maybe_remove(store, "df")
  301:         store.append("df", df, data_columns=["ts", "A", "B", "users"])
  302: 
  303:         # regular select
  304:         result = store.select("df", "ts>=Timestamp('2012-02-01')")
  305:         expected = df[df.ts >= Timestamp("2012-02-01")]
  306:         tm.assert_frame_equal(expected, result)
  307: 
  308:         # small selector
  309:         result = store.select("df", "ts>=Timestamp('2012-02-01') & users=['a','b','c']")
  310:         expected = df[
  311:             (df.ts >= Timestamp("2012-02-01")) & df.users.isin(["a", "b", "c"])
  312:         ]
  313:         tm.assert_frame_equal(expected, result)
  314: 
  315:         # big selector along the columns
  316:         selector = ["a", "b", "c"] + [f"a{i:03d}" for i in range(60)]
  317:         result = store.select("df", "ts>=Timestamp('2012-02-01') and users=selector")
  318:         expected = df[(df.ts >= Timestamp("2012-02-01")) & df.users.isin(selector)]
  319:         tm.assert_frame_equal(expected, result)
  320: 
  321:         selector = range(100, 200)
  322:         result = store.select("df", "B=selector")
  323:         expected = df[df.B.isin(selector)]
  324:         tm.assert_frame_equal(expected, result)
  325:         assert len(result) == 100
  326: 
  327:         # big selector along the index
  328:         selector = Index(df.ts[0:100].values)
  329:         result = store.select("df", "ts=selector")
  330:         expected = df[df.ts.isin(selector.values)]
  331:         tm.assert_frame_equal(expected, result)
  332:         assert len(result) == 100
  333: 
  334: 
  335: def test_select_iterator(tmp_path, setup_path):
  336:     # single table
  337:     with ensure_clean_store(setup_path) as store:
  338:         df = DataFrame(
  339:             np.random.default_rng(2).standard_normal((10, 4)),
  340:             columns=Index(list("ABCD"), dtype=object),
  341:             index=date_range("2000-01-01", periods=10, freq="B"),
  342:         )
  343:         _maybe_remove(store, "df")
  344:         store.append("df", df)
  345: 
  346:         expected = store.select("df")
  347: 
  348:         results = list(store.select("df", iterator=True))
  349:         result = concat(results)
  350:         tm.assert_frame_equal(expected, result)
  351: 
  352:         results = list(store.select("df", chunksize=2))
  353:         assert len(results) == 5
  354:         result = concat(results)
  355:         tm.assert_frame_equal(expected, result)
  356: 
  357:         results = list(store.select("df", chunksize=2))
  358:         result = concat(results)
  359:         tm.assert_frame_equal(result, expected)
  360: 
  361:     path = tmp_path / setup_path
  362: 
  363:     df = DataFrame(
  364:         np.random.default_rng(2).standard_normal((10, 4)),
  365:         columns=Index(list("ABCD"), dtype=object),
  366:         index=date_range("2000-01-01", periods=10, freq="B"),
  367:     )
  368:     df.to_hdf(path, key="df_non_table")
  369: 
  370:     msg = "can only use an iterator or chunksize on a table"
  371:     with pytest.raises(TypeError, match=msg):
  372:         read_hdf(path, "df_non_table", chunksize=2)
  373: 
  374:     with pytest.raises(TypeError, match=msg):
  375:         read_hdf(path, "df_non_table", iterator=True)
  376: 
  377:     path = tmp_path / setup_path
  378: 
  379:     df = DataFrame(
  380:         np.random.default_rng(2).standard_normal((10, 4)),
  381:         columns=Index(list("ABCD"), dtype=object),
  382:         index=date_range("2000-01-01", periods=10, freq="B"),
  383:     )
  384:     df.to_hdf(path, key="df", format="table")
  385: 
  386:     results = list(read_hdf(path, "df", chunksize=2))
  387:     result = concat(results)
  388: 
  389:     assert len(results) == 5
  390:     tm.assert_frame_equal(result, df)
  391:     tm.assert_frame_equal(result, read_hdf(path, "df"))
  392: 
  393:     # multiple
  394: 
  395:     with ensure_clean_store(setup_path) as store:
  396:         df1 = DataFrame(
  397:             np.random.default_rng(2).standard_normal((10, 4)),
  398:             columns=Index(list("ABCD"), dtype=object),
  399:             index=date_range("2000-01-01", periods=10, freq="B"),
  400:         )
  401:         store.append("df1", df1, data_columns=True)
  402:         df2 = df1.copy().rename(columns="{}_2".format)
  403:         df2["foo"] = "bar"
  404:         store.append("df2", df2)
  405: 
  406:         df = concat([df1, df2], axis=1)
  407: 
  408:         # full selection
  409:         expected = store.select_as_multiple(["df1", "df2"], selector="df1")
  410:         results = list(
  411:             store.select_as_multiple(["df1", "df2"], selector="df1", chunksize=2)
  412:         )
  413:         result = concat(results)
  414:         tm.assert_frame_equal(expected, result)
  415: 
  416: 
  417: def test_select_iterator_complete_8014(setup_path):
  418:     # GH 8014
  419:     # using iterator and where clause
  420:     chunksize = 1e4
  421: 
  422:     # no iterator
  423:     with ensure_clean_store(setup_path) as store:
  424:         expected = DataFrame(
  425:             np.random.default_rng(2).standard_normal((100064, 4)),
  426:             columns=Index(list("ABCD"), dtype=object),
  427:             index=date_range("2000-01-01", periods=100064, freq="s"),
  428:         )
  429:         _maybe_remove(store, "df")
  430:         store.append("df", expected)
  431: 
  432:         beg_dt = expected.index[0]
  433:         end_dt = expected.index[-1]
  434: 
  435:         # select w/o iteration and no where clause works
  436:         result = store.select("df")
  437:         tm.assert_frame_equal(expected, result)
  438: 
  439:         # select w/o iterator and where clause, single term, begin
  440:         # of range, works
  441:         where = f"index >= '{beg_dt}'"
  442:         result = store.select("df", where=where)
  443:         tm.assert_frame_equal(expected, result)
  444: 
  445:         # select w/o iterator and where clause, single term, end
  446:         # of range, works
  447:         where = f"index <= '{end_dt}'"
  448:         result = store.select("df", where=where)
  449:         tm.assert_frame_equal(expected, result)
  450: 
  451:         # select w/o iterator and where clause, inclusive range,
  452:         # works
  453:         where = f"index >= '{beg_dt}' & index <= '{end_dt}'"
  454:         result = store.select("df", where=where)
  455:         tm.assert_frame_equal(expected, result)
  456: 
  457:     # with iterator, full range
  458:     with ensure_clean_store(setup_path) as store:
  459:         expected = DataFrame(
  460:             np.random.default_rng(2).standard_normal((100064, 4)),
  461:             columns=Index(list("ABCD"), dtype=object),
  462:             index=date_range("2000-01-01", periods=100064, freq="s"),
  463:         )
  464:         _maybe_remove(store, "df")
  465:         store.append("df", expected)
  466: 
  467:         beg_dt = expected.index[0]
  468:         end_dt = expected.index[-1]
  469: 
  470:         # select w/iterator and no where clause works
  471:         results = list(store.select("df", chunksize=chunksize))
  472:         result = concat(results)
  473:         tm.assert_frame_equal(expected, result)
  474: 
  475:         # select w/iterator and where clause, single term, begin of range
  476:         where = f"index >= '{beg_dt}'"
  477:         results = list(store.select("df", where=where, chunksize=chunksize))
  478:         result = concat(results)
  479:         tm.assert_frame_equal(expected, result)
  480: 
  481:         # select w/iterator and where clause, single term, end of range
  482:         where = f"index <= '{end_dt}'"
  483:         results = list(store.select("df", where=where, chunksize=chunksize))
  484:         result = concat(results)
  485:         tm.assert_frame_equal(expected, result)
  486: 
  487:         # select w/iterator and where clause, inclusive range
  488:         where = f"index >= '{beg_dt}' & index <= '{end_dt}'"
  489:         results = list(store.select("df", where=where, chunksize=chunksize))
  490:         result = concat(results)
  491:         tm.assert_frame_equal(expected, result)
  492: 
  493: 
  494: def test_select_iterator_non_complete_8014(setup_path):
  495:     # GH 8014
  496:     # using iterator and where clause
  497:     chunksize = 1e4
  498: 
  499:     # with iterator, non complete range
  500:     with ensure_clean_store(setup_path) as store:
  501:         expected = DataFrame(
  502:             np.random.default_rng(2).standard_normal((100064, 4)),
  503:             columns=Index(list("ABCD"), dtype=object),
  504:             index=date_range("2000-01-01", periods=100064, freq="s"),
  505:         )
  506:         _maybe_remove(store, "df")
  507:         store.append("df", expected)
  508: 
  509:         beg_dt = expected.index[1]
  510:         end_dt = expected.index[-2]
  511: 
  512:         # select w/iterator and where clause, single term, begin of range
  513:         where = f"index >= '{beg_dt}'"
  514:         results = list(store.select("df", where=where, chunksize=chunksize))
  515:         result = concat(results)
  516:         rexpected = expected[expected.index >= beg_dt]
  517:         tm.assert_frame_equal(rexpected, result)
  518: 
  519:         # select w/iterator and where clause, single term, end of range
  520:         where = f"index <= '{end_dt}'"
  521:         results = list(store.select("df", where=where, chunksize=chunksize))
  522:         result = concat(results)
  523:         rexpected = expected[expected.index <= end_dt]
  524:         tm.assert_frame_equal(rexpected, result)
  525: 
  526:         # select w/iterator and where clause, inclusive range
  527:         where = f"index >= '{beg_dt}' & index <= '{end_dt}'"
  528:         results = list(store.select("df", where=where, chunksize=chunksize))
  529:         result = concat(results)
  530:         rexpected = expected[(expected.index >= beg_dt) & (expected.index <= end_dt)]
  531:         tm.assert_frame_equal(rexpected, result)
  532: 
  533:     # with iterator, empty where
  534:     with ensure_clean_store(setup_path) as store:
  535:         expected = DataFrame(
  536:             np.random.default_rng(2).standard_normal((100064, 4)),
  537:             columns=Index(list("ABCD"), dtype=object),
  538:             index=date_range("2000-01-01", periods=100064, freq="s"),
  539:         )
  540:         _maybe_remove(store, "df")
  541:         store.append("df", expected)
  542: 
  543:         end_dt = expected.index[-1]
  544: 
  545:         # select w/iterator and where clause, single term, begin of range
  546:         where = f"index > '{end_dt}'"
  547:         results = list(store.select("df", where=where, chunksize=chunksize))
  548:         assert 0 == len(results)
  549: 
  550: 
  551: def test_select_iterator_many_empty_frames(setup_path):
  552:     # GH 8014
  553:     # using iterator and where clause can return many empty
  554:     # frames.
  555:     chunksize = 10_000
  556: 
  557:     # with iterator, range limited to the first chunk
  558:     with ensure_clean_store(setup_path) as store:
  559:         expected = DataFrame(
  560:             np.random.default_rng(2).standard_normal((100064, 4)),
  561:             columns=Index(list("ABCD"), dtype=object),
  562:             index=date_range("2000-01-01", periods=100064, freq="s"),
  563:         )
  564:         _maybe_remove(store, "df")
  565:         store.append("df", expected)
  566: 
  567:         beg_dt = expected.index[0]
  568:         end_dt = expected.index[chunksize - 1]
  569: 
  570:         # select w/iterator and where clause, single term, begin of range
  571:         where = f"index >= '{beg_dt}'"
  572:         results = list(store.select("df", where=where, chunksize=chunksize))
  573:         result = concat(results)
  574:         rexpected = expected[expected.index >= beg_dt]
  575:         tm.assert_frame_equal(rexpected, result)
  576: 
  577:         # select w/iterator and where clause, single term, end of range
  578:         where = f"index <= '{end_dt}'"
  579:         results = list(store.select("df", where=where, chunksize=chunksize))
  580: 
  581:         assert len(results) == 1
  582:         result = concat(results)
  583:         rexpected = expected[expected.index <= end_dt]
  584:         tm.assert_frame_equal(rexpected, result)
  585: 
  586:         # select w/iterator and where clause, inclusive range
  587:         where = f"index >= '{beg_dt}' & index <= '{end_dt}'"
  588:         results = list(store.select("df", where=where, chunksize=chunksize))
  589: 
  590:         # should be 1, is 10
  591:         assert len(results) == 1
  592:         result = concat(results)
  593:         rexpected = expected[(expected.index >= beg_dt) & (expected.index <= end_dt)]
  594:         tm.assert_frame_equal(rexpected, result)
  595: 
  596:         # select w/iterator and where clause which selects
  597:         # *nothing*.
  598:         #
  599:         # To be consistent with Python idiom I suggest this should
  600:         # return [] e.g. `for e in []: print True` never prints
  601:         # True.
  602: 
  603:         where = f"index <= '{beg_dt}' & index >= '{end_dt}'"
  604:         results = list(store.select("df", where=where, chunksize=chunksize))
  605: 
  606:         # should be []
  607:         assert len(results) == 0
  608: 
  609: 
  610: def test_frame_select(setup_path):
  611:     df = DataFrame(
  612:         np.random.default_rng(2).standard_normal((10, 4)),
  613:         columns=Index(list("ABCD"), dtype=object),
  614:         index=date_range("2000-01-01", periods=10, freq="B"),
  615:     )
  616: 
  617:     with ensure_clean_store(setup_path) as store:
  618:         store.put("frame", df, format="table")
  619:         date = df.index[len(df) // 2]
  620: 
  621:         crit1 = Term("index>=date")
  622:         assert crit1.env.scope["date"] == date
  623: 
  624:         crit2 = "columns=['A', 'D']"
  625:         crit3 = "columns=A"
  626: 
  627:         result = store.select("frame", [crit1, crit2])
  628:         expected = df.loc[date:, ["A", "D"]]
  629:         tm.assert_frame_equal(result, expected)
  630: 
  631:         result = store.select("frame", [crit3])
  632:         expected = df.loc[:, ["A"]]
  633:         tm.assert_frame_equal(result, expected)
  634: 
  635:         # invalid terms
  636:         df = DataFrame(
  637:             np.random.default_rng(2).standard_normal((10, 4)),
  638:             columns=Index(list("ABCD"), dtype=object),
  639:             index=date_range("2000-01-01", periods=10, freq="B"),
  640:         )
  641:         store.append("df_time", df)
  642:         msg = "day is out of range for month: 0"
  643:         with pytest.raises(ValueError, match=msg):
  644:             store.select("df_time", "index>0")
  645: 
  646:         # can't select if not written as table
  647:         # store['frame'] = df
  648:         # with pytest.raises(ValueError):
  649:         #     store.select('frame', [crit1, crit2])
  650: 
  651: 
  652: def test_frame_select_complex(setup_path):
  653:     # select via complex criteria
  654: 
  655:     df = DataFrame(
  656:         np.random.default_rng(2).standard_normal((10, 4)),
  657:         columns=Index(list("ABCD"), dtype=object),
  658:         index=date_range("2000-01-01", periods=10, freq="B"),
  659:     )
  660:     df["string"] = "foo"
  661:     df.loc[df.index[0:4], "string"] = "bar"
  662: 
  663:     with ensure_clean_store(setup_path) as store:
  664:         store.put("df", df, format="table", data_columns=["string"])
  665: 
  666:         # empty
  667:         result = store.select("df", 'index>df.index[3] & string="bar"')
  668:         expected = df.loc[(df.index > df.index[3]) & (df.string == "bar")]
  669:         tm.assert_frame_equal(result, expected)
  670: 
  671:         result = store.select("df", 'index>df.index[3] & string="foo"')
  672:         expected = df.loc[(df.index > df.index[3]) & (df.string == "foo")]
  673:         tm.assert_frame_equal(result, expected)
  674: 
  675:         # or
  676:         result = store.select("df", 'index>df.index[3] | string="bar"')
  677:         expected = df.loc[(df.index > df.index[3]) | (df.string == "bar")]
  678:         tm.assert_frame_equal(result, expected)
  679: 
  680:         result = store.select(
  681:             "df", '(index>df.index[3] & index<=df.index[6]) | string="bar"'
  682:         )
  683:         expected = df.loc[
  684:             ((df.index > df.index[3]) & (df.index <= df.index[6]))
  685:             | (df.string == "bar")
  686:         ]
  687:         tm.assert_frame_equal(result, expected)
  688: 
  689:         # invert
  690:         result = store.select("df", 'string!="bar"')
  691:         expected = df.loc[df.string != "bar"]
  692:         tm.assert_frame_equal(result, expected)
  693: 
  694:         # invert not implemented in numexpr :(
  695:         msg = "cannot use an invert condition when passing to numexpr"
  696:         with pytest.raises(NotImplementedError, match=msg):
  697:             store.select("df", '~(string="bar")')
  698: 
  699:         # invert ok for filters
  700:         result = store.select("df", "~(columns=['A','B'])")
  701:         expected = df.loc[:, df.columns.difference(["A", "B"])]
  702:         tm.assert_frame_equal(result, expected)
  703: 
  704:         # in
  705:         result = store.select("df", "index>df.index[3] & columns in ['A','B']")
  706:         expected = df.loc[df.index > df.index[3]].reindex(columns=["A", "B"])
  707:         tm.assert_frame_equal(result, expected)
  708: 
  709: 
  710: def test_frame_select_complex2(tmp_path):
  711:     pp = tmp_path / "params.hdf"
  712:     hh = tmp_path / "hist.hdf"
  713: 
  714:     # use non-trivial selection criteria
  715:     params = DataFrame({"A": [1, 1, 2, 2, 3]})
  716:     params.to_hdf(pp, key="df", mode="w", format="table", data_columns=["A"])
  717: 
  718:     selection = read_hdf(pp, "df", where="A=[2,3]")
  719:     hist = DataFrame(
  720:         np.random.default_rng(2).standard_normal((25, 1)),
  721:         columns=["data"],
  722:         index=MultiIndex.from_tuples(
  723:             [(i, j) for i in range(5) for j in range(5)], names=["l1", "l2"]
  724:         ),
  725:     )
  726: 
  727:     hist.to_hdf(hh, key="df", mode="w", format="table")
  728: 
  729:     expected = read_hdf(hh, "df", where="l1=[2, 3, 4]")
  730: 
  731:     # scope with list like
  732:     l0 = selection.index.tolist()  # noqa: F841
  733:     with HDFStore(hh) as store:
  734:         result = store.select("df", where="l1=l0")
  735:         tm.assert_frame_equal(result, expected)
  736: 
  737:     result = read_hdf(hh, "df", where="l1=l0")
  738:     tm.assert_frame_equal(result, expected)
  739: 
  740:     # index
  741:     index = selection.index  # noqa: F841
  742:     result = read_hdf(hh, "df", where="l1=index")
  743:     tm.assert_frame_equal(result, expected)
  744: 
  745:     result = read_hdf(hh, "df", where="l1=selection.index")
  746:     tm.assert_frame_equal(result, expected)
  747: 
  748:     result = read_hdf(hh, "df", where="l1=selection.index.tolist()")
  749:     tm.assert_frame_equal(result, expected)
  750: 
  751:     result = read_hdf(hh, "df", where="l1=list(selection.index)")
  752:     tm.assert_frame_equal(result, expected)
  753: 
  754:     # scope with index
  755:     with HDFStore(hh) as store:
  756:         result = store.select("df", where="l1=index")
  757:         tm.assert_frame_equal(result, expected)
  758: 
  759:         result = store.select("df", where="l1=selection.index")
  760:         tm.assert_frame_equal(result, expected)
  761: 
  762:         result = store.select("df", where="l1=selection.index.tolist()")
  763:         tm.assert_frame_equal(result, expected)
  764: 
  765:         result = store.select("df", where="l1=list(selection.index)")
  766:         tm.assert_frame_equal(result, expected)
  767: 
  768: 
  769: def test_invalid_filtering(setup_path):
  770:     # can't use more than one filter (atm)
  771: 
  772:     df = DataFrame(
  773:         np.random.default_rng(2).standard_normal((10, 4)),
  774:         columns=Index(list("ABCD"), dtype=object),
  775:         index=date_range("2000-01-01", periods=10, freq="B"),
  776:     )
  777: 
  778:     with ensure_clean_store(setup_path) as store:
  779:         store.put("df", df, format="table")
  780: 
  781:         msg = "unable to collapse Joint Filters"
  782:         # not implemented
  783:         with pytest.raises(NotImplementedError, match=msg):
  784:             store.select("df", "columns=['A'] | columns=['B']")
  785: 
  786:         # in theory we could deal with this
  787:         with pytest.raises(NotImplementedError, match=msg):
  788:             store.select("df", "columns=['A','B'] & columns=['C']")
  789: 
  790: 
  791: def test_string_select(setup_path):
  792:     # GH 2973
  793:     with ensure_clean_store(setup_path) as store:
  794:         df = DataFrame(
  795:             np.random.default_rng(2).standard_normal((10, 4)),
  796:             columns=Index(list("ABCD"), dtype=object),
  797:             index=date_range("2000-01-01", periods=10, freq="B"),
  798:         )
  799: 
  800:         # test string ==/!=
  801:         df["x"] = "none"
  802:         df.loc[df.index[2:7], "x"] = ""
  803: 
  804:         store.append("df", df, data_columns=["x"])
  805: 
  806:         result = store.select("df", "x=none")
  807:         expected = df[df.x == "none"]
  808:         tm.assert_frame_equal(result, expected)
  809: 
  810:         result = store.select("df", "x!=none")
  811:         expected = df[df.x != "none"]
  812:         tm.assert_frame_equal(result, expected)
  813: 
  814:         df2 = df.copy()
  815:         df2.loc[df2.x == "", "x"] = np.nan
  816: 
  817:         store.append("df2", df2, data_columns=["x"])
  818:         result = store.select("df2", "x!=none")
  819:         expected = df2[isna(df2.x)]
  820:         tm.assert_frame_equal(result, expected)
  821: 
  822:         # int ==/!=
  823:         df["int"] = 1
  824:         df.loc[df.index[2:7], "int"] = 2
  825: 
  826:         store.append("df3", df, data_columns=["int"])
  827: 
  828:         result = store.select("df3", "int=2")
  829:         expected = df[df.int == 2]
  830:         tm.assert_frame_equal(result, expected)
  831: 
  832:         result = store.select("df3", "int!=2")
  833:         expected = df[df.int != 2]
  834:         tm.assert_frame_equal(result, expected)
  835: 
  836: 
  837: def test_select_as_multiple(setup_path):
  838:     df1 = DataFrame(
  839:         np.random.default_rng(2).standard_normal((10, 4)),
  840:         columns=Index(list("ABCD"), dtype=object),
  841:         index=date_range("2000-01-01", periods=10, freq="B"),
  842:     )
  843:     df2 = df1.copy().rename(columns="{}_2".format)
  844:     df2["foo"] = "bar"
  845: 
  846:     with ensure_clean_store(setup_path) as store:
  847:         msg = "keys must be a list/tuple"
  848:         # no tables stored
  849:         with pytest.raises(TypeError, match=msg):
  850:             store.select_as_multiple(None, where=["A>0", "B>0"], selector="df1")
  851: 
  852:         store.append("df1", df1, data_columns=["A", "B"])
  853:         store.append("df2", df2)
  854: 
  855:         # exceptions
  856:         with pytest.raises(TypeError, match=msg):
  857:             store.select_as_multiple(None, where=["A>0", "B>0"], selector="df1")
  858: 
  859:         with pytest.raises(TypeError, match=msg):
  860:             store.select_as_multiple([None], where=["A>0", "B>0"], selector="df1")
  861: 
  862:         msg = "'No object named df3 in the file'"
  863:         with pytest.raises(KeyError, match=msg):
  864:             store.select_as_multiple(
  865:                 ["df1", "df3"], where=["A>0", "B>0"], selector="df1"
  866:             )
  867: 
  868:         with pytest.raises(KeyError, match=msg):
  869:             store.select_as_multiple(["df3"], where=["A>0", "B>0"], selector="df1")
  870: 
  871:         with pytest.raises(KeyError, match="'No object named df4 in the file'"):
  872:             store.select_as_multiple(
  873:                 ["df1", "df2"], where=["A>0", "B>0"], selector="df4"
  874:             )
  875: 
  876:         # default select
  877:         result = store.select("df1", ["A>0", "B>0"])
  878:         expected = store.select_as_multiple(
  879:             ["df1"], where=["A>0", "B>0"], selector="df1"
  880:         )
  881:         tm.assert_frame_equal(result, expected)
  882:         expected = store.select_as_multiple("df1", where=["A>0", "B>0"], selector="df1")
  883:         tm.assert_frame_equal(result, expected)
  884: 
  885:         # multiple
  886:         result = store.select_as_multiple(
  887:             ["df1", "df2"], where=["A>0", "B>0"], selector="df1"
  888:         )
  889:         expected = concat([df1, df2], axis=1)
  890:         expected = expected[(expected.A > 0) & (expected.B > 0)]
  891:         tm.assert_frame_equal(result, expected, check_freq=False)
  892:         # FIXME: 2021-01-20 this is failing with freq None vs 4B on some builds
  893: 
  894:         # multiple (diff selector)
  895:         result = store.select_as_multiple(
  896:             ["df1", "df2"], where="index>df2.index[4]", selector="df2"
  897:         )
  898:         expected = concat([df1, df2], axis=1)
  899:         expected = expected[5:]
  900:         tm.assert_frame_equal(result, expected)
  901: 
  902:         # test exception for diff rows
  903:         df3 = df1.copy().head(2)
  904:         store.append("df3", df3)
  905:         msg = "all tables must have exactly the same nrows!"
  906:         with pytest.raises(ValueError, match=msg):
  907:             store.select_as_multiple(
  908:                 ["df1", "df3"], where=["A>0", "B>0"], selector="df1"
  909:             )
  910: 
  911: 
  912: def test_nan_selection_bug_4858(setup_path):
  913:     with ensure_clean_store(setup_path) as store:
  914:         df = DataFrame({"cols": range(6), "values": range(6)}, dtype="float64")
  915:         df["cols"] = (df["cols"] + 10).apply(str)
  916:         df.iloc[0] = np.nan
  917: 
  918:         expected = DataFrame(
  919:             {"cols": ["13.0", "14.0", "15.0"], "values": [3.0, 4.0, 5.0]},
  920:             index=[3, 4, 5],
  921:         )
  922: 
  923:         # write w/o the index on that particular column
  924:         store.append("df", df, data_columns=True, index=["cols"])
  925:         result = store.select("df", where="values>2.0")
  926:         tm.assert_frame_equal(result, expected)
  927: 
  928: 
  929: def test_query_with_nested_special_character(setup_path):
  930:     df = DataFrame(
  931:         {
  932:             "a": ["a", "a", "c", "b", "test & test", "c", "b", "e"],
  933:             "b": [1, 2, 3, 4, 5, 6, 7, 8],
  934:         }
  935:     )
  936:     expected = df[df.a == "test & test"]
  937:     with ensure_clean_store(setup_path) as store:
  938:         store.append("test", df, format="table", data_columns=True)
  939:         result = store.select("test", 'a = "test & test"')
  940:     tm.assert_frame_equal(expected, result)
  941: 
  942: 
  943: def test_query_long_float_literal(setup_path):
  944:     # GH 14241
  945:     df = DataFrame({"A": [1000000000.0009, 1000000000.0011, 1000000000.0015]})
  946: 
  947:     with ensure_clean_store(setup_path) as store:
  948:         store.append("test", df, format="table", data_columns=True)
  949: 
  950:         cutoff = 1000000000.0006
  951:         result = store.select("test", f"A < {cutoff:.4f}")
  952:         assert result.empty
  953: 
  954:         cutoff = 1000000000.0010
  955:         result = store.select("test", f"A > {cutoff:.4f}")
  956:         expected = df.loc[[1, 2], :]
  957:         tm.assert_frame_equal(expected, result)
  958: 
  959:         exact = 1000000000.0011
  960:         result = store.select("test", f"A == {exact:.4f}")
  961:         expected = df.loc[[1], :]
  962:         tm.assert_frame_equal(expected, result)
  963: 
  964: 
  965: def test_query_compare_column_type(setup_path):
  966:     # GH 15492
  967:     df = DataFrame(
  968:         {
  969:             "date": ["2014-01-01", "2014-01-02"],
  970:             "real_date": date_range("2014-01-01", periods=2),
  971:             "float": [1.1, 1.2],
  972:             "int": [1, 2],
  973:         },
  974:         columns=["date", "real_date", "float", "int"],
  975:     )
  976: 
  977:     with ensure_clean_store(setup_path) as store:
  978:         store.append("test", df, format="table", data_columns=True)
  979: 
  980:         ts = Timestamp("2014-01-01")  # noqa: F841
  981:         result = store.select("test", where="real_date > ts")
  982:         expected = df.loc[[1], :]
  983:         tm.assert_frame_equal(expected, result)
  984: 
  985:         for op in ["<", ">", "=="]:
  986:             # non strings to string column always fail
  987:             for v in [2.1, True, Timestamp("2014-01-01"), pd.Timedelta(1, "s")]:
  988:                 query = f"date {op} v"
  989:                 msg = f"Cannot compare {v} of type {type(v)} to string column"
  990:                 with pytest.raises(TypeError, match=msg):
  991:                     store.select("test", where=query)
  992: 
  993:             # strings to other columns must be convertible to type
  994:             v = "a"
  995:             for col in ["int", "float", "real_date"]:
  996:                 query = f"{col} {op} v"
  997:                 if col == "real_date":
  998:                     msg = 'Given date string "a" not likely a datetime'
  999:                 else:
 1000:                     msg = "could not convert string to"
 1001:                 with pytest.raises(ValueError, match=msg):
 1002:                     store.select("test", where=query)
 1003: 
 1004:             for v, col in zip(
 1005:                 ["1", "1.1", "2014-01-01"], ["int", "float", "real_date"]
 1006:             ):
 1007:                 query = f"{col} {op} v"
 1008:                 result = store.select("test", where=query)
 1009: 
 1010:                 if op == "==":
 1011:                     expected = df.loc[[0], :]
 1012:                 elif op == ">":
 1013:                     expected = df.loc[[1], :]
 1014:                 else:
 1015:                     expected = df.loc[[], :]
 1016:                 tm.assert_frame_equal(expected, result)
 1017: 
 1018: 
 1019: @pytest.mark.parametrize("where", ["", (), (None,), [], [None]])
 1020: def test_select_empty_where(tmp_path, where):
 1021:     # GH26610
 1022: 
 1023:     df = DataFrame([1, 2, 3])
 1024:     path = tmp_path / "empty_where.h5"
 1025:     with HDFStore(path) as store:
 1026:         store.put("df", df, "t")
 1027:         result = read_hdf(store, "df", where=where)
 1028:         tm.assert_frame_equal(result, df)
 1029: 
 1030: 
 1031: def test_select_large_integer(tmp_path):
 1032:     path = tmp_path / "large_int.h5"
 1033: 
 1034:     df = DataFrame(
 1035:         zip(
 1036:             ["a", "b", "c", "d"],
 1037:             [-9223372036854775801, -9223372036854775802, -9223372036854775803, 123],
 1038:         ),
 1039:         columns=["x", "y"],
 1040:     )
 1041:     result = None
 1042:     with HDFStore(path) as s:
 1043:         s.append("data", df, data_columns=True, index=False)
 1044:         result = s.select("data", where="y==-9223372036854775801").get("y").get(0)
 1045:     expected = df["y"][0]
 1046: 
 1047:     assert expected == result
