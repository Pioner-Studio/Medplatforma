    1: """
    2: Tests that features that are currently unsupported in
    3: either the Python or C parser are actually enforced
    4: and are clearly communicated to the user.
    5: 
    6: Ultimately, the goal is to remove test cases from this
    7: test suite as new feature support is added to the parsers.
    8: """
    9: from io import StringIO
   10: import os
   11: from pathlib import Path
   12: 
   13: import pytest
   14: 
   15: from pandas.errors import ParserError
   16: 
   17: import pandas._testing as tm
   18: 
   19: from pandas.io.parsers import read_csv
   20: import pandas.io.parsers.readers as parsers
   21: 
   22: pytestmark = pytest.mark.filterwarnings(
   23:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   24: )
   25: 
   26: 
   27: @pytest.fixture(params=["python", "python-fwf"], ids=lambda val: val)
   28: def python_engine(request):
   29:     return request.param
   30: 
   31: 
   32: class TestUnsupportedFeatures:
   33:     def test_mangle_dupe_cols_false(self):
   34:         # see gh-12935
   35:         data = "a b c\n1 2 3"
   36: 
   37:         for engine in ("c", "python"):
   38:             with pytest.raises(TypeError, match="unexpected keyword"):
   39:                 read_csv(StringIO(data), engine=engine, mangle_dupe_cols=True)
   40: 
   41:     def test_c_engine(self):
   42:         # see gh-6607
   43:         data = "a b c\n1 2 3"
   44:         msg = "does not support"
   45: 
   46:         depr_msg = "The 'delim_whitespace' keyword in pd.read_csv is deprecated"
   47: 
   48:         # specify C engine with unsupported options (raise)
   49:         with pytest.raises(ValueError, match=msg):
   50:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   51:                 read_csv(StringIO(data), engine="c", sep=None, delim_whitespace=False)
   52:         with pytest.raises(ValueError, match=msg):
   53:             read_csv(StringIO(data), engine="c", sep=r"\s")
   54:         with pytest.raises(ValueError, match=msg):
   55:             read_csv(StringIO(data), engine="c", sep="\t", quotechar=chr(128))
   56:         with pytest.raises(ValueError, match=msg):
   57:             read_csv(StringIO(data), engine="c", skipfooter=1)
   58: 
   59:         # specify C-unsupported options without python-unsupported options
   60:         with tm.assert_produces_warning((parsers.ParserWarning, FutureWarning)):
   61:             read_csv(StringIO(data), sep=None, delim_whitespace=False)
   62:         with tm.assert_produces_warning(parsers.ParserWarning):
   63:             read_csv(StringIO(data), sep=r"\s")
   64:         with tm.assert_produces_warning(parsers.ParserWarning):
   65:             read_csv(StringIO(data), sep="\t", quotechar=chr(128))
   66:         with tm.assert_produces_warning(parsers.ParserWarning):
   67:             read_csv(StringIO(data), skipfooter=1)
   68: 
   69:         text = """                      A       B       C       D        E
   70: one two three   four
   71: a   b   10.0032 5    -0.5109 -2.3358 -0.4645  0.05076  0.3640
   72: a   q   20      4     0.4473  1.4152  0.2834  1.00661  0.1744
   73: x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
   74:         msg = "Error tokenizing data"
   75: 
   76:         with pytest.raises(ParserError, match=msg):
   77:             read_csv(StringIO(text), sep="\\s+")
   78:         with pytest.raises(ParserError, match=msg):
   79:             read_csv(StringIO(text), engine="c", sep="\\s+")
   80: 
   81:         msg = "Only length-1 thousands markers supported"
   82:         data = """A|B|C
   83: 1|2,334|5
   84: 10|13|10.
   85: """
   86:         with pytest.raises(ValueError, match=msg):
   87:             read_csv(StringIO(data), thousands=",,")
   88:         with pytest.raises(ValueError, match=msg):
   89:             read_csv(StringIO(data), thousands="")
   90: 
   91:         msg = "Only length-1 line terminators supported"
   92:         data = "a,b,c~~1,2,3~~4,5,6"
   93:         with pytest.raises(ValueError, match=msg):
   94:             read_csv(StringIO(data), lineterminator="~~")
   95: 
   96:     def test_python_engine(self, python_engine):
   97:         from pandas.io.parsers.readers import _python_unsupported as py_unsupported
   98: 
   99:         data = """1,2,3,,
  100: 1,2,3,4,
  101: 1,2,3,4,5
  102: 1,2,,,
  103: 1,2,3,4,"""
  104: 
  105:         for default in py_unsupported:
  106:             msg = (
  107:                 f"The {repr(default)} option is not "
  108:                 f"supported with the {repr(python_engine)} engine"
  109:             )
  110: 
  111:             kwargs = {default: object()}
  112:             with pytest.raises(ValueError, match=msg):
  113:                 read_csv(StringIO(data), engine=python_engine, **kwargs)
  114: 
  115:     def test_python_engine_file_no_iter(self, python_engine):
  116:         # see gh-16530
  117:         class NoNextBuffer:
  118:             def __init__(self, csv_data) -> None:
  119:                 self.data = csv_data
  120: 
  121:             def __next__(self):
  122:                 return self.data.__next__()
  123: 
  124:             def read(self):
  125:                 return self.data
  126: 
  127:             def readline(self):
  128:                 return self.data
  129: 
  130:         data = "a\n1"
  131:         msg = "'NoNextBuffer' object is not iterable|argument 1 must be an iterator"
  132: 
  133:         with pytest.raises(TypeError, match=msg):
  134:             read_csv(NoNextBuffer(data), engine=python_engine)
  135: 
  136:     def test_pyarrow_engine(self):
  137:         from pandas.io.parsers.readers import _pyarrow_unsupported as pa_unsupported
  138: 
  139:         data = """1,2,3,,
  140:         1,2,3,4,
  141:         1,2,3,4,5
  142:         1,2,,,
  143:         1,2,3,4,"""
  144: 
  145:         for default in pa_unsupported:
  146:             msg = (
  147:                 f"The {repr(default)} option is not "
  148:                 f"supported with the 'pyarrow' engine"
  149:             )
  150:             kwargs = {default: object()}
  151:             default_needs_bool = {"warn_bad_lines", "error_bad_lines"}
  152:             if default == "dialect":
  153:                 kwargs[default] = "excel"  # test a random dialect
  154:             elif default in default_needs_bool:
  155:                 kwargs[default] = True
  156:             elif default == "on_bad_lines":
  157:                 kwargs[default] = "warn"
  158: 
  159:             warn = None
  160:             depr_msg = None
  161:             if "delim_whitespace" in kwargs:
  162:                 depr_msg = "The 'delim_whitespace' keyword in pd.read_csv is deprecated"
  163:                 warn = FutureWarning
  164:             if "verbose" in kwargs:
  165:                 depr_msg = "The 'verbose' keyword in pd.read_csv is deprecated"
  166:                 warn = FutureWarning
  167: 
  168:             with pytest.raises(ValueError, match=msg):
  169:                 with tm.assert_produces_warning(warn, match=depr_msg):
  170:                     read_csv(StringIO(data), engine="pyarrow", **kwargs)
  171: 
  172:     def test_on_bad_lines_callable_python_or_pyarrow(self, all_parsers):
  173:         # GH 5686
  174:         # GH 54643
  175:         sio = StringIO("a,b\n1,2")
  176:         bad_lines_func = lambda x: x
  177:         parser = all_parsers
  178:         if all_parsers.engine not in ["python", "pyarrow"]:
  179:             msg = (
  180:                 "on_bad_line can only be a callable "
  181:                 "function if engine='python' or 'pyarrow'"
  182:             )
  183:             with pytest.raises(ValueError, match=msg):
  184:                 parser.read_csv(sio, on_bad_lines=bad_lines_func)
  185:         else:
  186:             parser.read_csv(sio, on_bad_lines=bad_lines_func)
  187: 
  188: 
  189: def test_close_file_handle_on_invalid_usecols(all_parsers):
  190:     # GH 45384
  191:     parser = all_parsers
  192: 
  193:     error = ValueError
  194:     if parser.engine == "pyarrow":
  195:         # Raises pyarrow.lib.ArrowKeyError
  196:         pytest.skip(reason="https://github.com/apache/arrow/issues/38676")
  197: 
  198:     with tm.ensure_clean("test.csv") as fname:
  199:         Path(fname).write_text("col1,col2\na,b\n1,2", encoding="utf-8")
  200:         with tm.assert_produces_warning(False):
  201:             with pytest.raises(error, match="col3"):
  202:                 parser.read_csv(fname, usecols=["col1", "col2", "col3"])
  203:         # unlink fails on windows if file handles still point to it
  204:         os.unlink(fname)
  205: 
  206: 
  207: def test_invalid_file_inputs(request, all_parsers):
  208:     # GH#45957
  209:     parser = all_parsers
  210:     if parser.engine == "python":
  211:         request.applymarker(
  212:             pytest.mark.xfail(reason=f"{parser.engine} engine supports lists.")
  213:         )
  214: 
  215:     with pytest.raises(ValueError, match="Invalid"):
  216:         parser.read_csv([])
  217: 
  218: 
  219: def test_invalid_dtype_backend(all_parsers):
  220:     parser = all_parsers
  221:     msg = (
  222:         "dtype_backend numpy is invalid, only 'numpy_nullable' and "
  223:         "'pyarrow' are allowed."
  224:     )
  225:     with pytest.raises(ValueError, match=msg):
  226:         parser.read_csv("test", dtype_backend="numpy")
