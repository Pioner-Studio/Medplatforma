    1: import calendar
    2: import datetime
    3: import decimal
    4: import json
    5: import locale
    6: import math
    7: import re
    8: import time
    9: 
   10: import dateutil
   11: import numpy as np
   12: import pytest
   13: import pytz
   14: 
   15: import pandas._libs.json as ujson
   16: from pandas.compat import IS64
   17: 
   18: from pandas import (
   19:     DataFrame,
   20:     DatetimeIndex,
   21:     Index,
   22:     NaT,
   23:     PeriodIndex,
   24:     Series,
   25:     Timedelta,
   26:     Timestamp,
   27:     date_range,
   28: )
   29: import pandas._testing as tm
   30: 
   31: 
   32: def _clean_dict(d):
   33:     """
   34:     Sanitize dictionary for JSON by converting all keys to strings.
   35: 
   36:     Parameters
   37:     ----------
   38:     d : dict
   39:         The dictionary to convert.
   40: 
   41:     Returns
   42:     -------
   43:     cleaned_dict : dict
   44:     """
   45:     return {str(k): v for k, v in d.items()}
   46: 
   47: 
   48: @pytest.fixture(
   49:     params=[None, "split", "records", "values", "index"]  # Column indexed by default.
   50: )
   51: def orient(request):
   52:     return request.param
   53: 
   54: 
   55: class TestUltraJSONTests:
   56:     @pytest.mark.skipif(not IS64, reason="not compliant on 32-bit, xref #15865")
   57:     def test_encode_decimal(self):
   58:         sut = decimal.Decimal("1337.1337")
   59:         encoded = ujson.ujson_dumps(sut, double_precision=15)
   60:         decoded = ujson.ujson_loads(encoded)
   61:         assert decoded == 1337.1337
   62: 
   63:         sut = decimal.Decimal("0.95")
   64:         encoded = ujson.ujson_dumps(sut, double_precision=1)
   65:         assert encoded == "1.0"
   66: 
   67:         decoded = ujson.ujson_loads(encoded)
   68:         assert decoded == 1.0
   69: 
   70:         sut = decimal.Decimal("0.94")
   71:         encoded = ujson.ujson_dumps(sut, double_precision=1)
   72:         assert encoded == "0.9"
   73: 
   74:         decoded = ujson.ujson_loads(encoded)
   75:         assert decoded == 0.9
   76: 
   77:         sut = decimal.Decimal("1.95")
   78:         encoded = ujson.ujson_dumps(sut, double_precision=1)
   79:         assert encoded == "2.0"
   80: 
   81:         decoded = ujson.ujson_loads(encoded)
   82:         assert decoded == 2.0
   83: 
   84:         sut = decimal.Decimal("-1.95")
   85:         encoded = ujson.ujson_dumps(sut, double_precision=1)
   86:         assert encoded == "-2.0"
   87: 
   88:         decoded = ujson.ujson_loads(encoded)
   89:         assert decoded == -2.0
   90: 
   91:         sut = decimal.Decimal("0.995")
   92:         encoded = ujson.ujson_dumps(sut, double_precision=2)
   93:         assert encoded == "1.0"
   94: 
   95:         decoded = ujson.ujson_loads(encoded)
   96:         assert decoded == 1.0
   97: 
   98:         sut = decimal.Decimal("0.9995")
   99:         encoded = ujson.ujson_dumps(sut, double_precision=3)
  100:         assert encoded == "1.0"
  101: 
  102:         decoded = ujson.ujson_loads(encoded)
  103:         assert decoded == 1.0
  104: 
  105:         sut = decimal.Decimal("0.99999999999999944")
  106:         encoded = ujson.ujson_dumps(sut, double_precision=15)
  107:         assert encoded == "1.0"
  108: 
  109:         decoded = ujson.ujson_loads(encoded)
  110:         assert decoded == 1.0
  111: 
  112:     @pytest.mark.parametrize("ensure_ascii", [True, False])
  113:     def test_encode_string_conversion(self, ensure_ascii):
  114:         string_input = "A string \\ / \b \f \n \r \t </script> &"
  115:         not_html_encoded = '"A string \\\\ \\/ \\b \\f \\n \\r \\t <\\/script> &"'
  116:         html_encoded = (
  117:             '"A string \\\\ \\/ \\b \\f \\n \\r \\t \\u003c\\/script\\u003e \\u0026"'
  118:         )
  119: 
  120:         def helper(expected_output, **encode_kwargs):
  121:             output = ujson.ujson_dumps(
  122:                 string_input, ensure_ascii=ensure_ascii, **encode_kwargs
  123:             )
  124: 
  125:             assert output == expected_output
  126:             assert string_input == json.loads(output)
  127:             assert string_input == ujson.ujson_loads(output)
  128: 
  129:         # Default behavior assumes encode_html_chars=False.
  130:         helper(not_html_encoded)
  131: 
  132:         # Make sure explicit encode_html_chars=False works.
  133:         helper(not_html_encoded, encode_html_chars=False)
  134: 
  135:         # Make sure explicit encode_html_chars=True does the encoding.
  136:         helper(html_encoded, encode_html_chars=True)
  137: 
  138:     @pytest.mark.parametrize(
  139:         "long_number", [-4342969734183514, -12345678901234.56789012, -528656961.4399388]
  140:     )
  141:     def test_double_long_numbers(self, long_number):
  142:         sut = {"a": long_number}
  143:         encoded = ujson.ujson_dumps(sut, double_precision=15)
  144: 
  145:         decoded = ujson.ujson_loads(encoded)
  146:         assert sut == decoded
  147: 
  148:     def test_encode_non_c_locale(self):
  149:         lc_category = locale.LC_NUMERIC
  150: 
  151:         # We just need one of these locales to work.
  152:         for new_locale in ("it_IT.UTF-8", "Italian_Italy"):
  153:             if tm.can_set_locale(new_locale, lc_category):
  154:                 with tm.set_locale(new_locale, lc_category):
  155:                     assert ujson.ujson_loads(ujson.ujson_dumps(4.78e60)) == 4.78e60
  156:                     assert ujson.ujson_loads("4.78", precise_float=True) == 4.78
  157:                 break
  158: 
  159:     def test_decimal_decode_test_precise(self):
  160:         sut = {"a": 4.56}
  161:         encoded = ujson.ujson_dumps(sut)
  162:         decoded = ujson.ujson_loads(encoded, precise_float=True)
  163:         assert sut == decoded
  164: 
  165:     def test_encode_double_tiny_exponential(self):
  166:         num = 1e-40
  167:         assert num == ujson.ujson_loads(ujson.ujson_dumps(num))
  168:         num = 1e-100
  169:         assert num == ujson.ujson_loads(ujson.ujson_dumps(num))
  170:         num = -1e-45
  171:         assert num == ujson.ujson_loads(ujson.ujson_dumps(num))
  172:         num = -1e-145
  173:         assert np.allclose(num, ujson.ujson_loads(ujson.ujson_dumps(num)))
  174: 
  175:     @pytest.mark.parametrize("unicode_key", ["key1", "ШЁЩ†"])
  176:     def test_encode_dict_with_unicode_keys(self, unicode_key):
  177:         unicode_dict = {unicode_key: "value1"}
  178:         assert unicode_dict == ujson.ujson_loads(ujson.ujson_dumps(unicode_dict))
  179: 
  180:     @pytest.mark.parametrize(
  181:         "double_input", [math.pi, -math.pi]  # Should work with negatives too.
  182:     )
  183:     def test_encode_double_conversion(self, double_input):
  184:         output = ujson.ujson_dumps(double_input)
  185:         assert round(double_input, 5) == round(json.loads(output), 5)
  186:         assert round(double_input, 5) == round(ujson.ujson_loads(output), 5)
  187: 
  188:     def test_encode_with_decimal(self):
  189:         decimal_input = 1.0
  190:         output = ujson.ujson_dumps(decimal_input)
  191: 
  192:         assert output == "1.0"
  193: 
  194:     def test_encode_array_of_nested_arrays(self):
  195:         nested_input = [[[[]]]] * 20
  196:         output = ujson.ujson_dumps(nested_input)
  197: 
  198:         assert nested_input == json.loads(output)
  199:         assert nested_input == ujson.ujson_loads(output)
  200: 
  201:     def test_encode_array_of_doubles(self):
  202:         doubles_input = [31337.31337, 31337.31337, 31337.31337, 31337.31337] * 10
  203:         output = ujson.ujson_dumps(doubles_input)
  204: 
  205:         assert doubles_input == json.loads(output)
  206:         assert doubles_input == ujson.ujson_loads(output)
  207: 
  208:     def test_double_precision(self):
  209:         double_input = 30.012345678901234
  210:         output = ujson.ujson_dumps(double_input, double_precision=15)
  211: 
  212:         assert double_input == json.loads(output)
  213:         assert double_input == ujson.ujson_loads(output)
  214: 
  215:         for double_precision in (3, 9):
  216:             output = ujson.ujson_dumps(double_input, double_precision=double_precision)
  217:             rounded_input = round(double_input, double_precision)
  218: 
  219:             assert rounded_input == json.loads(output)
  220:             assert rounded_input == ujson.ujson_loads(output)
  221: 
  222:     @pytest.mark.parametrize(
  223:         "invalid_val",
  224:         [
  225:             20,
  226:             -1,
  227:             "9",
  228:             None,
  229:         ],
  230:     )
  231:     def test_invalid_double_precision(self, invalid_val):
  232:         double_input = 30.12345678901234567890
  233:         expected_exception = ValueError if isinstance(invalid_val, int) else TypeError
  234:         msg = (
  235:             r"Invalid value '.*' for option 'double_precision', max is '15'|"
  236:             r"an integer is required \(got type |"
  237:             r"object cannot be interpreted as an integer"
  238:         )
  239:         with pytest.raises(expected_exception, match=msg):
  240:             ujson.ujson_dumps(double_input, double_precision=invalid_val)
  241: 
  242:     def test_encode_string_conversion2(self):
  243:         string_input = "A string \\ / \b \f \n \r \t"
  244:         output = ujson.ujson_dumps(string_input)
  245: 
  246:         assert string_input == json.loads(output)
  247:         assert string_input == ujson.ujson_loads(output)
  248:         assert output == '"A string \\\\ \\/ \\b \\f \\n \\r \\t"'
  249: 
  250:     @pytest.mark.parametrize(
  251:         "unicode_input",
  252:         ["RГ¤ksmГ¶rgГҐs Ш§ШіШ§Щ…Ш© ШЁЩ† Щ…Ш­Щ…ШЇ ШЁЩ† Ш№Щ€Ш¶ ШЁЩ† Щ„Ш§ШЇЩ†", "\xe6\x97\xa5\xd1\x88"],
  253:     )
  254:     def test_encode_unicode_conversion(self, unicode_input):
  255:         enc = ujson.ujson_dumps(unicode_input)
  256:         dec = ujson.ujson_loads(enc)
  257: 
  258:         assert enc == json.dumps(unicode_input)
  259:         assert dec == json.loads(enc)
  260: 
  261:     def test_encode_control_escaping(self):
  262:         escaped_input = "\x19"
  263:         enc = ujson.ujson_dumps(escaped_input)
  264:         dec = ujson.ujson_loads(enc)
  265: 
  266:         assert escaped_input == dec
  267:         assert enc == json.dumps(escaped_input)
  268: 
  269:     def test_encode_unicode_surrogate_pair(self):
  270:         surrogate_input = "\xf0\x90\x8d\x86"
  271:         enc = ujson.ujson_dumps(surrogate_input)
  272:         dec = ujson.ujson_loads(enc)
  273: 
  274:         assert enc == json.dumps(surrogate_input)
  275:         assert dec == json.loads(enc)
  276: 
  277:     def test_encode_unicode_4bytes_utf8(self):
  278:         four_bytes_input = "\xf0\x91\x80\xb0TRAILINGNORMAL"
  279:         enc = ujson.ujson_dumps(four_bytes_input)
  280:         dec = ujson.ujson_loads(enc)
  281: 
  282:         assert enc == json.dumps(four_bytes_input)
  283:         assert dec == json.loads(enc)
  284: 
  285:     def test_encode_unicode_4bytes_utf8highest(self):
  286:         four_bytes_input = "\xf3\xbf\xbf\xbfTRAILINGNORMAL"
  287:         enc = ujson.ujson_dumps(four_bytes_input)
  288: 
  289:         dec = ujson.ujson_loads(enc)
  290: 
  291:         assert enc == json.dumps(four_bytes_input)
  292:         assert dec == json.loads(enc)
  293: 
  294:     def test_encode_unicode_error(self):
  295:         string = "'\udac0'"
  296:         msg = (
  297:             r"'utf-8' codec can't encode character '\\udac0' "
  298:             r"in position 1: surrogates not allowed"
  299:         )
  300:         with pytest.raises(UnicodeEncodeError, match=msg):
  301:             ujson.ujson_dumps([string])
  302: 
  303:     def test_encode_array_in_array(self):
  304:         arr_in_arr_input = [[[[]]]]
  305:         output = ujson.ujson_dumps(arr_in_arr_input)
  306: 
  307:         assert arr_in_arr_input == json.loads(output)
  308:         assert output == json.dumps(arr_in_arr_input)
  309:         assert arr_in_arr_input == ujson.ujson_loads(output)
  310: 
  311:     @pytest.mark.parametrize(
  312:         "num_input",
  313:         [
  314:             31337,
  315:             -31337,  # Negative number.
  316:             -9223372036854775808,  # Large negative number.
  317:         ],
  318:     )
  319:     def test_encode_num_conversion(self, num_input):
  320:         output = ujson.ujson_dumps(num_input)
  321:         assert num_input == json.loads(output)
  322:         assert output == json.dumps(num_input)
  323:         assert num_input == ujson.ujson_loads(output)
  324: 
  325:     def test_encode_list_conversion(self):
  326:         list_input = [1, 2, 3, 4]
  327:         output = ujson.ujson_dumps(list_input)
  328: 
  329:         assert list_input == json.loads(output)
  330:         assert list_input == ujson.ujson_loads(output)
  331: 
  332:     def test_encode_dict_conversion(self):
  333:         dict_input = {"k1": 1, "k2": 2, "k3": 3, "k4": 4}
  334:         output = ujson.ujson_dumps(dict_input)
  335: 
  336:         assert dict_input == json.loads(output)
  337:         assert dict_input == ujson.ujson_loads(output)
  338: 
  339:     @pytest.mark.parametrize("builtin_value", [None, True, False])
  340:     def test_encode_builtin_values_conversion(self, builtin_value):
  341:         output = ujson.ujson_dumps(builtin_value)
  342:         assert builtin_value == json.loads(output)
  343:         assert output == json.dumps(builtin_value)
  344:         assert builtin_value == ujson.ujson_loads(output)
  345: 
  346:     def test_encode_datetime_conversion(self):
  347:         datetime_input = datetime.datetime.fromtimestamp(time.time())
  348:         output = ujson.ujson_dumps(datetime_input, date_unit="s")
  349:         expected = calendar.timegm(datetime_input.utctimetuple())
  350: 
  351:         assert int(expected) == json.loads(output)
  352:         assert int(expected) == ujson.ujson_loads(output)
  353: 
  354:     def test_encode_date_conversion(self):
  355:         date_input = datetime.date.fromtimestamp(time.time())
  356:         output = ujson.ujson_dumps(date_input, date_unit="s")
  357: 
  358:         tup = (date_input.year, date_input.month, date_input.day, 0, 0, 0)
  359:         expected = calendar.timegm(tup)
  360: 
  361:         assert int(expected) == json.loads(output)
  362:         assert int(expected) == ujson.ujson_loads(output)
  363: 
  364:     @pytest.mark.parametrize(
  365:         "test",
  366:         [datetime.time(), datetime.time(1, 2, 3), datetime.time(10, 12, 15, 343243)],
  367:     )
  368:     def test_encode_time_conversion_basic(self, test):
  369:         output = ujson.ujson_dumps(test)
  370:         expected = f'"{test.isoformat()}"'
  371:         assert expected == output
  372: 
  373:     def test_encode_time_conversion_pytz(self):
  374:         # see gh-11473: to_json segfaults with timezone-aware datetimes
  375:         test = datetime.time(10, 12, 15, 343243, pytz.utc)
  376:         output = ujson.ujson_dumps(test)
  377:         expected = f'"{test.isoformat()}"'
  378:         assert expected == output
  379: 
  380:     def test_encode_time_conversion_dateutil(self):
  381:         # see gh-11473: to_json segfaults with timezone-aware datetimes
  382:         test = datetime.time(10, 12, 15, 343243, dateutil.tz.tzutc())
  383:         output = ujson.ujson_dumps(test)
  384:         expected = f'"{test.isoformat()}"'
  385:         assert expected == output
  386: 
  387:     @pytest.mark.parametrize(
  388:         "decoded_input", [NaT, np.datetime64("NaT"), np.nan, np.inf, -np.inf]
  389:     )
  390:     def test_encode_as_null(self, decoded_input):
  391:         assert ujson.ujson_dumps(decoded_input) == "null", "Expected null"
  392: 
  393:     def test_datetime_units(self):
  394:         val = datetime.datetime(2013, 8, 17, 21, 17, 12, 215504)
  395:         stamp = Timestamp(val).as_unit("ns")
  396: 
  397:         roundtrip = ujson.ujson_loads(ujson.ujson_dumps(val, date_unit="s"))
  398:         assert roundtrip == stamp._value // 10**9
  399: 
  400:         roundtrip = ujson.ujson_loads(ujson.ujson_dumps(val, date_unit="ms"))
  401:         assert roundtrip == stamp._value // 10**6
  402: 
  403:         roundtrip = ujson.ujson_loads(ujson.ujson_dumps(val, date_unit="us"))
  404:         assert roundtrip == stamp._value // 10**3
  405: 
  406:         roundtrip = ujson.ujson_loads(ujson.ujson_dumps(val, date_unit="ns"))
  407:         assert roundtrip == stamp._value
  408: 
  409:         msg = "Invalid value 'foo' for option 'date_unit'"
  410:         with pytest.raises(ValueError, match=msg):
  411:             ujson.ujson_dumps(val, date_unit="foo")
  412: 
  413:     def test_encode_to_utf8(self):
  414:         unencoded = "\xe6\x97\xa5\xd1\x88"
  415: 
  416:         enc = ujson.ujson_dumps(unencoded, ensure_ascii=False)
  417:         dec = ujson.ujson_loads(enc)
  418: 
  419:         assert enc == json.dumps(unencoded, ensure_ascii=False)
  420:         assert dec == json.loads(enc)
  421: 
  422:     def test_decode_from_unicode(self):
  423:         unicode_input = '{"obj": 31337}'
  424: 
  425:         dec1 = ujson.ujson_loads(unicode_input)
  426:         dec2 = ujson.ujson_loads(str(unicode_input))
  427: 
  428:         assert dec1 == dec2
  429: 
  430:     def test_encode_recursion_max(self):
  431:         # 8 is the max recursion depth
  432: 
  433:         class O2:
  434:             member = 0
  435: 
  436:         class O1:
  437:             member = 0
  438: 
  439:         decoded_input = O1()
  440:         decoded_input.member = O2()
  441:         decoded_input.member.member = decoded_input
  442: 
  443:         with pytest.raises(OverflowError, match="Maximum recursion level reached"):
  444:             ujson.ujson_dumps(decoded_input)
  445: 
  446:     def test_decode_jibberish(self):
  447:         jibberish = "fdsa sda v9sa fdsa"
  448:         msg = "Unexpected character found when decoding 'false'"
  449:         with pytest.raises(ValueError, match=msg):
  450:             ujson.ujson_loads(jibberish)
  451: 
  452:     @pytest.mark.parametrize(
  453:         "broken_json",
  454:         [
  455:             "[",  # Broken array start.
  456:             "{",  # Broken object start.
  457:             "]",  # Broken array end.
  458:             "}",  # Broken object end.
  459:         ],
  460:     )
  461:     def test_decode_broken_json(self, broken_json):
  462:         msg = "Expected object or value"
  463:         with pytest.raises(ValueError, match=msg):
  464:             ujson.ujson_loads(broken_json)
  465: 
  466:     @pytest.mark.parametrize("too_big_char", ["[", "{"])
  467:     def test_decode_depth_too_big(self, too_big_char):
  468:         with pytest.raises(ValueError, match="Reached object decoding depth limit"):
  469:             ujson.ujson_loads(too_big_char * (1024 * 1024))
  470: 
  471:     @pytest.mark.parametrize(
  472:         "bad_string",
  473:         [
  474:             '"TESTING',  # Unterminated.
  475:             '"TESTING\\"',  # Unterminated escape.
  476:             "tru",  # Broken True.
  477:             "fa",  # Broken False.
  478:             "n",  # Broken None.
  479:         ],
  480:     )
  481:     def test_decode_bad_string(self, bad_string):
  482:         msg = (
  483:             "Unexpected character found when decoding|"
  484:             "Unmatched ''\"' when when decoding 'string'"
  485:         )
  486:         with pytest.raises(ValueError, match=msg):
  487:             ujson.ujson_loads(bad_string)
  488: 
  489:     @pytest.mark.parametrize(
  490:         "broken_json, err_msg",
  491:         [
  492:             (
  493:                 '{{1337:""}}',
  494:                 "Key name of object must be 'string' when decoding 'object'",
  495:             ),
  496:             ('{{"key":"}', "Unmatched ''\"' when when decoding 'string'"),
  497:             ("[[[true", "Unexpected character found when decoding array value (2)"),
  498:         ],
  499:     )
  500:     def test_decode_broken_json_leak(self, broken_json, err_msg):
  501:         for _ in range(1000):
  502:             with pytest.raises(ValueError, match=re.escape(err_msg)):
  503:                 ujson.ujson_loads(broken_json)
  504: 
  505:     @pytest.mark.parametrize(
  506:         "invalid_dict",
  507:         [
  508:             "{{{{31337}}}}",  # No key.
  509:             '{{{{"key":}}}}',  # No value.
  510:             '{{{{"key"}}}}',  # No colon or value.
  511:         ],
  512:     )
  513:     def test_decode_invalid_dict(self, invalid_dict):
  514:         msg = (
  515:             "Key name of object must be 'string' when decoding 'object'|"
  516:             "No ':' found when decoding object value|"
  517:             "Expected object or value"
  518:         )
  519:         with pytest.raises(ValueError, match=msg):
  520:             ujson.ujson_loads(invalid_dict)
  521: 
  522:     @pytest.mark.parametrize(
  523:         "numeric_int_as_str", ["31337", "-31337"]  # Should work with negatives.
  524:     )
  525:     def test_decode_numeric_int(self, numeric_int_as_str):
  526:         assert int(numeric_int_as_str) == ujson.ujson_loads(numeric_int_as_str)
  527: 
  528:     def test_encode_null_character(self):
  529:         wrapped_input = "31337 \x00 1337"
  530:         output = ujson.ujson_dumps(wrapped_input)
  531: 
  532:         assert wrapped_input == json.loads(output)
  533:         assert output == json.dumps(wrapped_input)
  534:         assert wrapped_input == ujson.ujson_loads(output)
  535: 
  536:         alone_input = "\x00"
  537:         output = ujson.ujson_dumps(alone_input)
  538: 
  539:         assert alone_input == json.loads(output)
  540:         assert output == json.dumps(alone_input)
  541:         assert alone_input == ujson.ujson_loads(output)
  542:         assert '"  \\u0000\\r\\n "' == ujson.ujson_dumps("  \u0000\r\n ")
  543: 
  544:     def test_decode_null_character(self):
  545:         wrapped_input = '"31337 \\u0000 31337"'
  546:         assert ujson.ujson_loads(wrapped_input) == json.loads(wrapped_input)
  547: 
  548:     def test_encode_list_long_conversion(self):
  549:         long_input = [
  550:             9223372036854775807,
  551:             9223372036854775807,
  552:             9223372036854775807,
  553:             9223372036854775807,
  554:             9223372036854775807,
  555:             9223372036854775807,
  556:         ]
  557:         output = ujson.ujson_dumps(long_input)
  558: 
  559:         assert long_input == json.loads(output)
  560:         assert long_input == ujson.ujson_loads(output)
  561: 
  562:     @pytest.mark.parametrize("long_input", [9223372036854775807, 18446744073709551615])
  563:     def test_encode_long_conversion(self, long_input):
  564:         output = ujson.ujson_dumps(long_input)
  565: 
  566:         assert long_input == json.loads(output)
  567:         assert output == json.dumps(long_input)
  568:         assert long_input == ujson.ujson_loads(output)
  569: 
  570:     @pytest.mark.parametrize("bigNum", [2**64, -(2**63) - 1])
  571:     def test_dumps_ints_larger_than_maxsize(self, bigNum):
  572:         encoding = ujson.ujson_dumps(bigNum)
  573:         assert str(bigNum) == encoding
  574: 
  575:         with pytest.raises(
  576:             ValueError,
  577:             match="Value is too big|Value is too small",
  578:         ):
  579:             assert ujson.ujson_loads(encoding) == bigNum
  580: 
  581:     @pytest.mark.parametrize(
  582:         "int_exp", ["1337E40", "1.337E40", "1337E+9", "1.337e+40", "1.337E-4"]
  583:     )
  584:     def test_decode_numeric_int_exp(self, int_exp):
  585:         assert ujson.ujson_loads(int_exp) == json.loads(int_exp)
  586: 
  587:     def test_loads_non_str_bytes_raises(self):
  588:         msg = "a bytes-like object is required, not 'NoneType'"
  589:         with pytest.raises(TypeError, match=msg):
  590:             ujson.ujson_loads(None)
  591: 
  592:     @pytest.mark.parametrize("val", [3590016419, 2**31, 2**32, (2**32) - 1])
  593:     def test_decode_number_with_32bit_sign_bit(self, val):
  594:         # Test that numbers that fit within 32 bits but would have the
  595:         # sign bit set (2**31 <= x < 2**32) are decoded properly.
  596:         doc = f'{{"id": {val}}}'
  597:         assert ujson.ujson_loads(doc)["id"] == val
  598: 
  599:     def test_encode_big_escape(self):
  600:         # Make sure no Exception is raised.
  601:         for _ in range(10):
  602:             base = "\u00e5".encode()
  603:             escape_input = base * 1024 * 1024 * 2
  604:             ujson.ujson_dumps(escape_input)
  605: 
  606:     def test_decode_big_escape(self):
  607:         # Make sure no Exception is raised.
  608:         for _ in range(10):
  609:             base = "\u00e5".encode()
  610:             quote = b'"'
  611: 
  612:             escape_input = quote + (base * 1024 * 1024 * 2) + quote
  613:             ujson.ujson_loads(escape_input)
  614: 
  615:     def test_to_dict(self):
  616:         d = {"key": 31337}
  617: 
  618:         class DictTest:
  619:             def toDict(self):
  620:                 return d
  621: 
  622:         o = DictTest()
  623:         output = ujson.ujson_dumps(o)
  624: 
  625:         dec = ujson.ujson_loads(output)
  626:         assert dec == d
  627: 
  628:     def test_default_handler(self):
  629:         class _TestObject:
  630:             def __init__(self, val) -> None:
  631:                 self.val = val
  632: 
  633:             @property
  634:             def recursive_attr(self):
  635:                 return _TestObject("recursive_attr")
  636: 
  637:             def __str__(self) -> str:
  638:                 return str(self.val)
  639: 
  640:         msg = "Maximum recursion level reached"
  641:         with pytest.raises(OverflowError, match=msg):
  642:             ujson.ujson_dumps(_TestObject("foo"))
  643:         assert '"foo"' == ujson.ujson_dumps(_TestObject("foo"), default_handler=str)
  644: 
  645:         def my_handler(_):
  646:             return "foobar"
  647: 
  648:         assert '"foobar"' == ujson.ujson_dumps(
  649:             _TestObject("foo"), default_handler=my_handler
  650:         )
  651: 
  652:         def my_handler_raises(_):
  653:             raise TypeError("I raise for anything")
  654: 
  655:         with pytest.raises(TypeError, match="I raise for anything"):
  656:             ujson.ujson_dumps(_TestObject("foo"), default_handler=my_handler_raises)
  657: 
  658:         def my_int_handler(_):
  659:             return 42
  660: 
  661:         assert (
  662:             ujson.ujson_loads(
  663:                 ujson.ujson_dumps(_TestObject("foo"), default_handler=my_int_handler)
  664:             )
  665:             == 42
  666:         )
  667: 
  668:         def my_obj_handler(_):
  669:             return datetime.datetime(2013, 2, 3)
  670: 
  671:         assert ujson.ujson_loads(
  672:             ujson.ujson_dumps(datetime.datetime(2013, 2, 3))
  673:         ) == ujson.ujson_loads(
  674:             ujson.ujson_dumps(_TestObject("foo"), default_handler=my_obj_handler)
  675:         )
  676: 
  677:         obj_list = [_TestObject("foo"), _TestObject("bar")]
  678:         assert json.loads(json.dumps(obj_list, default=str)) == ujson.ujson_loads(
  679:             ujson.ujson_dumps(obj_list, default_handler=str)
  680:         )
  681: 
  682:     def test_encode_object(self):
  683:         class _TestObject:
  684:             def __init__(self, a, b, _c, d) -> None:
  685:                 self.a = a
  686:                 self.b = b
  687:                 self._c = _c
  688:                 self.d = d
  689: 
  690:             def e(self):
  691:                 return 5
  692: 
  693:         # JSON keys should be all non-callable non-underscore attributes, see GH-42768
  694:         test_object = _TestObject(a=1, b=2, _c=3, d=4)
  695:         assert ujson.ujson_loads(ujson.ujson_dumps(test_object)) == {
  696:             "a": 1,
  697:             "b": 2,
  698:             "d": 4,
  699:         }
  700: 
  701:     def test_ujson__name__(self):
  702:         # GH 52898
  703:         assert ujson.__name__ == "pandas._libs.json"
  704: 
  705: 
  706: class TestNumpyJSONTests:
  707:     @pytest.mark.parametrize("bool_input", [True, False])
  708:     def test_bool(self, bool_input):
  709:         b = bool(bool_input)
  710:         assert ujson.ujson_loads(ujson.ujson_dumps(b)) == b
  711: 
  712:     def test_bool_array(self):
  713:         bool_array = np.array(
  714:             [True, False, True, True, False, True, False, False], dtype=bool
  715:         )
  716:         output = np.array(ujson.ujson_loads(ujson.ujson_dumps(bool_array)), dtype=bool)
  717:         tm.assert_numpy_array_equal(bool_array, output)
  718: 
  719:     def test_int(self, any_int_numpy_dtype):
  720:         klass = np.dtype(any_int_numpy_dtype).type
  721:         num = klass(1)
  722: 
  723:         assert klass(ujson.ujson_loads(ujson.ujson_dumps(num))) == num
  724: 
  725:     def test_int_array(self, any_int_numpy_dtype):
  726:         arr = np.arange(100, dtype=int)
  727:         arr_input = arr.astype(any_int_numpy_dtype)
  728: 
  729:         arr_output = np.array(
  730:             ujson.ujson_loads(ujson.ujson_dumps(arr_input)), dtype=any_int_numpy_dtype
  731:         )
  732:         tm.assert_numpy_array_equal(arr_input, arr_output)
  733: 
  734:     def test_int_max(self, any_int_numpy_dtype):
  735:         if any_int_numpy_dtype in ("int64", "uint64") and not IS64:
  736:             pytest.skip("Cannot test 64-bit integer on 32-bit platform")
  737: 
  738:         klass = np.dtype(any_int_numpy_dtype).type
  739: 
  740:         # uint64 max will always overflow,
  741:         # as it's encoded to signed.
  742:         if any_int_numpy_dtype == "uint64":
  743:             num = np.iinfo("int64").max
  744:         else:
  745:             num = np.iinfo(any_int_numpy_dtype).max
  746: 
  747:         assert klass(ujson.ujson_loads(ujson.ujson_dumps(num))) == num
  748: 
  749:     def test_float(self, float_numpy_dtype):
  750:         klass = np.dtype(float_numpy_dtype).type
  751:         num = klass(256.2013)
  752: 
  753:         assert klass(ujson.ujson_loads(ujson.ujson_dumps(num))) == num
  754: 
  755:     def test_float_array(self, float_numpy_dtype):
  756:         arr = np.arange(12.5, 185.72, 1.7322, dtype=float)
  757:         float_input = arr.astype(float_numpy_dtype)
  758: 
  759:         float_output = np.array(
  760:             ujson.ujson_loads(ujson.ujson_dumps(float_input, double_precision=15)),
  761:             dtype=float_numpy_dtype,
  762:         )
  763:         tm.assert_almost_equal(float_input, float_output)
  764: 
  765:     def test_float_max(self, float_numpy_dtype):
  766:         klass = np.dtype(float_numpy_dtype).type
  767:         num = klass(np.finfo(float_numpy_dtype).max / 10)
  768: 
  769:         tm.assert_almost_equal(
  770:             klass(ujson.ujson_loads(ujson.ujson_dumps(num, double_precision=15))), num
  771:         )
  772: 
  773:     def test_array_basic(self):
  774:         arr = np.arange(96)
  775:         arr = arr.reshape((2, 2, 2, 2, 3, 2))
  776: 
  777:         tm.assert_numpy_array_equal(
  778:             np.array(ujson.ujson_loads(ujson.ujson_dumps(arr))), arr
  779:         )
  780: 
  781:     @pytest.mark.parametrize("shape", [(10, 10), (5, 5, 4), (100, 1)])
  782:     def test_array_reshaped(self, shape):
  783:         arr = np.arange(100)
  784:         arr = arr.reshape(shape)
  785: 
  786:         tm.assert_numpy_array_equal(
  787:             np.array(ujson.ujson_loads(ujson.ujson_dumps(arr))), arr
  788:         )
  789: 
  790:     def test_array_list(self):
  791:         arr_list = [
  792:             "a",
  793:             [],
  794:             {},
  795:             {},
  796:             [],
  797:             42,
  798:             97.8,
  799:             ["a", "b"],
  800:             {"key": "val"},
  801:         ]
  802:         arr = np.array(arr_list, dtype=object)
  803:         result = np.array(ujson.ujson_loads(ujson.ujson_dumps(arr)), dtype=object)
  804:         tm.assert_numpy_array_equal(result, arr)
  805: 
  806:     def test_array_float(self):
  807:         dtype = np.float32
  808: 
  809:         arr = np.arange(100.202, 200.202, 1, dtype=dtype)
  810:         arr = arr.reshape((5, 5, 4))
  811: 
  812:         arr_out = np.array(ujson.ujson_loads(ujson.ujson_dumps(arr)), dtype=dtype)
  813:         tm.assert_almost_equal(arr, arr_out)
  814: 
  815:     def test_0d_array(self):
  816:         # gh-18878
  817:         msg = re.escape(
  818:             "array(1) (numpy-scalar) is not JSON serializable at the moment"
  819:         )
  820:         with pytest.raises(TypeError, match=msg):
  821:             ujson.ujson_dumps(np.array(1))
  822: 
  823:     def test_array_long_double(self):
  824:         msg = re.compile(
  825:             "1234.5.* \\(numpy-scalar\\) is not JSON serializable at the moment"
  826:         )
  827:         with pytest.raises(TypeError, match=msg):
  828:             ujson.ujson_dumps(np.longdouble(1234.5))
  829: 
  830: 
  831: class TestPandasJSONTests:
  832:     def test_dataframe(self, orient):
  833:         dtype = np.int64
  834: 
  835:         df = DataFrame(
  836:             [[1, 2, 3], [4, 5, 6]],
  837:             index=["a", "b"],
  838:             columns=["x", "y", "z"],
  839:             dtype=dtype,
  840:         )
  841:         encode_kwargs = {} if orient is None else {"orient": orient}
  842:         assert (df.dtypes == dtype).all()
  843: 
  844:         output = ujson.ujson_loads(ujson.ujson_dumps(df, **encode_kwargs))
  845:         assert (df.dtypes == dtype).all()
  846: 
  847:         # Ensure proper DataFrame initialization.
  848:         if orient == "split":
  849:             dec = _clean_dict(output)
  850:             output = DataFrame(**dec)
  851:         else:
  852:             output = DataFrame(output)
  853: 
  854:         # Corrections to enable DataFrame comparison.
  855:         if orient == "values":
  856:             df.columns = [0, 1, 2]
  857:             df.index = [0, 1]
  858:         elif orient == "records":
  859:             df.index = [0, 1]
  860:         elif orient == "index":
  861:             df = df.transpose()
  862: 
  863:         assert (df.dtypes == dtype).all()
  864:         tm.assert_frame_equal(output, df)
  865: 
  866:     def test_dataframe_nested(self, orient):
  867:         df = DataFrame(
  868:             [[1, 2, 3], [4, 5, 6]], index=["a", "b"], columns=["x", "y", "z"]
  869:         )
  870: 
  871:         nested = {"df1": df, "df2": df.copy()}
  872:         kwargs = {} if orient is None else {"orient": orient}
  873: 
  874:         exp = {
  875:             "df1": ujson.ujson_loads(ujson.ujson_dumps(df, **kwargs)),
  876:             "df2": ujson.ujson_loads(ujson.ujson_dumps(df, **kwargs)),
  877:         }
  878:         assert ujson.ujson_loads(ujson.ujson_dumps(nested, **kwargs)) == exp
  879: 
  880:     def test_series(self, orient):
  881:         dtype = np.int64
  882:         s = Series(
  883:             [10, 20, 30, 40, 50, 60],
  884:             name="series",
  885:             index=[6, 7, 8, 9, 10, 15],
  886:             dtype=dtype,
  887:         ).sort_values()
  888:         assert s.dtype == dtype
  889: 
  890:         encode_kwargs = {} if orient is None else {"orient": orient}
  891: 
  892:         output = ujson.ujson_loads(ujson.ujson_dumps(s, **encode_kwargs))
  893:         assert s.dtype == dtype
  894: 
  895:         if orient == "split":
  896:             dec = _clean_dict(output)
  897:             output = Series(**dec)
  898:         else:
  899:             output = Series(output)
  900: 
  901:         if orient in (None, "index"):
  902:             s.name = None
  903:             output = output.sort_values()
  904:             s.index = ["6", "7", "8", "9", "10", "15"]
  905:         elif orient in ("records", "values"):
  906:             s.name = None
  907:             s.index = [0, 1, 2, 3, 4, 5]
  908: 
  909:         assert s.dtype == dtype
  910:         tm.assert_series_equal(output, s)
  911: 
  912:     def test_series_nested(self, orient):
  913:         s = Series(
  914:             [10, 20, 30, 40, 50, 60], name="series", index=[6, 7, 8, 9, 10, 15]
  915:         ).sort_values()
  916:         nested = {"s1": s, "s2": s.copy()}
  917:         kwargs = {} if orient is None else {"orient": orient}
  918: 
  919:         exp = {
  920:             "s1": ujson.ujson_loads(ujson.ujson_dumps(s, **kwargs)),
  921:             "s2": ujson.ujson_loads(ujson.ujson_dumps(s, **kwargs)),
  922:         }
  923:         assert ujson.ujson_loads(ujson.ujson_dumps(nested, **kwargs)) == exp
  924: 
  925:     def test_index(self):
  926:         i = Index([23, 45, 18, 98, 43, 11], name="index")
  927: 
  928:         # Column indexed.
  929:         output = Index(ujson.ujson_loads(ujson.ujson_dumps(i)), name="index")
  930:         tm.assert_index_equal(i, output)
  931: 
  932:         dec = _clean_dict(ujson.ujson_loads(ujson.ujson_dumps(i, orient="split")))
  933:         output = Index(**dec)
  934: 
  935:         tm.assert_index_equal(i, output)
  936:         assert i.name == output.name
  937: 
  938:         tm.assert_index_equal(i, output)
  939:         assert i.name == output.name
  940: 
  941:         output = Index(
  942:             ujson.ujson_loads(ujson.ujson_dumps(i, orient="values")), name="index"
  943:         )
  944:         tm.assert_index_equal(i, output)
  945: 
  946:         output = Index(
  947:             ujson.ujson_loads(ujson.ujson_dumps(i, orient="records")), name="index"
  948:         )
  949:         tm.assert_index_equal(i, output)
  950: 
  951:         output = Index(
  952:             ujson.ujson_loads(ujson.ujson_dumps(i, orient="index")), name="index"
  953:         )
  954:         tm.assert_index_equal(i, output)
  955: 
  956:     def test_datetime_index(self):
  957:         date_unit = "ns"
  958: 
  959:         # freq doesn't round-trip
  960:         rng = DatetimeIndex(list(date_range("1/1/2000", periods=20)), freq=None)
  961:         encoded = ujson.ujson_dumps(rng, date_unit=date_unit)
  962: 
  963:         decoded = DatetimeIndex(np.array(ujson.ujson_loads(encoded)))
  964:         tm.assert_index_equal(rng, decoded)
  965: 
  966:         ts = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
  967:         decoded = Series(ujson.ujson_loads(ujson.ujson_dumps(ts, date_unit=date_unit)))
  968: 
  969:         idx_values = decoded.index.values.astype(np.int64)
  970:         decoded.index = DatetimeIndex(idx_values)
  971:         tm.assert_series_equal(ts, decoded)
  972: 
  973:     @pytest.mark.parametrize(
  974:         "invalid_arr",
  975:         [
  976:             "[31337,]",  # Trailing comma.
  977:             "[,31337]",  # Leading comma.
  978:             "[]]",  # Unmatched bracket.
  979:             "[,]",  # Only comma.
  980:         ],
  981:     )
  982:     def test_decode_invalid_array(self, invalid_arr):
  983:         msg = (
  984:             "Expected object or value|Trailing data|"
  985:             "Unexpected character found when decoding array value"
  986:         )
  987:         with pytest.raises(ValueError, match=msg):
  988:             ujson.ujson_loads(invalid_arr)
  989: 
  990:     @pytest.mark.parametrize("arr", [[], [31337]])
  991:     def test_decode_array(self, arr):
  992:         assert arr == ujson.ujson_loads(str(arr))
  993: 
  994:     @pytest.mark.parametrize("extreme_num", [9223372036854775807, -9223372036854775808])
  995:     def test_decode_extreme_numbers(self, extreme_num):
  996:         assert extreme_num == ujson.ujson_loads(str(extreme_num))
  997: 
  998:     @pytest.mark.parametrize("too_extreme_num", [f"{2**64}", f"{-2**63-1}"])
  999:     def test_decode_too_extreme_numbers(self, too_extreme_num):
 1000:         with pytest.raises(
 1001:             ValueError,
 1002:             match="Value is too big|Value is too small",
 1003:         ):
 1004:             ujson.ujson_loads(too_extreme_num)
 1005: 
 1006:     def test_decode_with_trailing_whitespaces(self):
 1007:         assert {} == ujson.ujson_loads("{}\n\t ")
 1008: 
 1009:     def test_decode_with_trailing_non_whitespaces(self):
 1010:         with pytest.raises(ValueError, match="Trailing data"):
 1011:             ujson.ujson_loads("{}\n\t a")
 1012: 
 1013:     @pytest.mark.parametrize("value", [f"{2**64}", f"{-2**63-1}"])
 1014:     def test_decode_array_with_big_int(self, value):
 1015:         with pytest.raises(
 1016:             ValueError,
 1017:             match="Value is too big|Value is too small",
 1018:         ):
 1019:             ujson.ujson_loads(value)
 1020: 
 1021:     @pytest.mark.parametrize(
 1022:         "float_number",
 1023:         [
 1024:             1.1234567893,
 1025:             1.234567893,
 1026:             1.34567893,
 1027:             1.4567893,
 1028:             1.567893,
 1029:             1.67893,
 1030:             1.7893,
 1031:             1.893,
 1032:             1.3,
 1033:         ],
 1034:     )
 1035:     @pytest.mark.parametrize("sign", [-1, 1])
 1036:     def test_decode_floating_point(self, sign, float_number):
 1037:         float_number *= sign
 1038:         tm.assert_almost_equal(
 1039:             float_number, ujson.ujson_loads(str(float_number)), rtol=1e-15
 1040:         )
 1041: 
 1042:     def test_encode_big_set(self):
 1043:         s = set()
 1044: 
 1045:         for x in range(100000):
 1046:             s.add(x)
 1047: 
 1048:         # Make sure no Exception is raised.
 1049:         ujson.ujson_dumps(s)
 1050: 
 1051:     def test_encode_empty_set(self):
 1052:         assert "[]" == ujson.ujson_dumps(set())
 1053: 
 1054:     def test_encode_set(self):
 1055:         s = {1, 2, 3, 4, 5, 6, 7, 8, 9}
 1056:         enc = ujson.ujson_dumps(s)
 1057:         dec = ujson.ujson_loads(enc)
 1058: 
 1059:         for v in dec:
 1060:             assert v in s
 1061: 
 1062:     @pytest.mark.parametrize(
 1063:         "td",
 1064:         [
 1065:             Timedelta(days=366),
 1066:             Timedelta(days=-1),
 1067:             Timedelta(hours=13, minutes=5, seconds=5),
 1068:             Timedelta(hours=13, minutes=20, seconds=30),
 1069:             Timedelta(days=-1, nanoseconds=5),
 1070:             Timedelta(nanoseconds=1),
 1071:             Timedelta(microseconds=1, nanoseconds=1),
 1072:             Timedelta(milliseconds=1, microseconds=1, nanoseconds=1),
 1073:             Timedelta(milliseconds=999, microseconds=999, nanoseconds=999),
 1074:         ],
 1075:     )
 1076:     def test_encode_timedelta_iso(self, td):
 1077:         # GH 28256
 1078:         result = ujson.ujson_dumps(td, iso_dates=True)
 1079:         expected = f'"{td.isoformat()}"'
 1080: 
 1081:         assert result == expected
 1082: 
 1083:     def test_encode_periodindex(self):
 1084:         # GH 46683
 1085:         p = PeriodIndex(["2022-04-06", "2022-04-07"], freq="D")
 1086:         df = DataFrame(index=p)
 1087:         assert df.to_json() == "{}"
