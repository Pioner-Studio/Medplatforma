    1: """
    2: Tests the 'read_fwf' function in parsers.py. This
    3: test suite is independent of the others because the
    4: engine is set to 'python-fwf' internally.
    5: """
    6: 
    7: from datetime import datetime
    8: from io import (
    9:     BytesIO,
   10:     StringIO,
   11: )
   12: from pathlib import Path
   13: 
   14: import numpy as np
   15: import pytest
   16: 
   17: from pandas.errors import EmptyDataError
   18: 
   19: import pandas as pd
   20: from pandas import (
   21:     DataFrame,
   22:     DatetimeIndex,
   23: )
   24: import pandas._testing as tm
   25: from pandas.core.arrays import (
   26:     ArrowStringArray,
   27:     StringArray,
   28: )
   29: 
   30: from pandas.io.common import urlopen
   31: from pandas.io.parsers import (
   32:     read_csv,
   33:     read_fwf,
   34: )
   35: 
   36: 
   37: def test_basic():
   38:     data = """\
   39: A         B            C            D
   40: 201158    360.242940   149.910199   11950.7
   41: 201159    444.953632   166.985655   11788.4
   42: 201160    364.136849   183.628767   11806.2
   43: 201161    413.836124   184.375703   11916.8
   44: 201162    502.953953   173.237159   12468.3
   45: """
   46:     result = read_fwf(StringIO(data))
   47:     expected = DataFrame(
   48:         [
   49:             [201158, 360.242940, 149.910199, 11950.7],
   50:             [201159, 444.953632, 166.985655, 11788.4],
   51:             [201160, 364.136849, 183.628767, 11806.2],
   52:             [201161, 413.836124, 184.375703, 11916.8],
   53:             [201162, 502.953953, 173.237159, 12468.3],
   54:         ],
   55:         columns=["A", "B", "C", "D"],
   56:     )
   57:     tm.assert_frame_equal(result, expected)
   58: 
   59: 
   60: def test_colspecs():
   61:     data = """\
   62: A   B     C            D            E
   63: 201158    360.242940   149.910199   11950.7
   64: 201159    444.953632   166.985655   11788.4
   65: 201160    364.136849   183.628767   11806.2
   66: 201161    413.836124   184.375703   11916.8
   67: 201162    502.953953   173.237159   12468.3
   68: """
   69:     colspecs = [(0, 4), (4, 8), (8, 20), (21, 33), (34, 43)]
   70:     result = read_fwf(StringIO(data), colspecs=colspecs)
   71: 
   72:     expected = DataFrame(
   73:         [
   74:             [2011, 58, 360.242940, 149.910199, 11950.7],
   75:             [2011, 59, 444.953632, 166.985655, 11788.4],
   76:             [2011, 60, 364.136849, 183.628767, 11806.2],
   77:             [2011, 61, 413.836124, 184.375703, 11916.8],
   78:             [2011, 62, 502.953953, 173.237159, 12468.3],
   79:         ],
   80:         columns=["A", "B", "C", "D", "E"],
   81:     )
   82:     tm.assert_frame_equal(result, expected)
   83: 
   84: 
   85: def test_widths():
   86:     data = """\
   87: A    B    C            D            E
   88: 2011 58   360.242940   149.910199   11950.7
   89: 2011 59   444.953632   166.985655   11788.4
   90: 2011 60   364.136849   183.628767   11806.2
   91: 2011 61   413.836124   184.375703   11916.8
   92: 2011 62   502.953953   173.237159   12468.3
   93: """
   94:     result = read_fwf(StringIO(data), widths=[5, 5, 13, 13, 7])
   95: 
   96:     expected = DataFrame(
   97:         [
   98:             [2011, 58, 360.242940, 149.910199, 11950.7],
   99:             [2011, 59, 444.953632, 166.985655, 11788.4],
  100:             [2011, 60, 364.136849, 183.628767, 11806.2],
  101:             [2011, 61, 413.836124, 184.375703, 11916.8],
  102:             [2011, 62, 502.953953, 173.237159, 12468.3],
  103:         ],
  104:         columns=["A", "B", "C", "D", "E"],
  105:     )
  106:     tm.assert_frame_equal(result, expected)
  107: 
  108: 
  109: def test_non_space_filler():
  110:     # From Thomas Kluyver:
  111:     #
  112:     # Apparently, some non-space filler characters can be seen, this is
  113:     # supported by specifying the 'delimiter' character:
  114:     #
  115:     # http://publib.boulder.ibm.com/infocenter/dmndhelp/v6r1mx/index.jsp?topic=/com.ibm.wbit.612.help.config.doc/topics/rfixwidth.html
  116:     data = """\
  117: A~~~~B~~~~C~~~~~~~~~~~~D~~~~~~~~~~~~E
  118: 201158~~~~360.242940~~~149.910199~~~11950.7
  119: 201159~~~~444.953632~~~166.985655~~~11788.4
  120: 201160~~~~364.136849~~~183.628767~~~11806.2
  121: 201161~~~~413.836124~~~184.375703~~~11916.8
  122: 201162~~~~502.953953~~~173.237159~~~12468.3
  123: """
  124:     colspecs = [(0, 4), (4, 8), (8, 20), (21, 33), (34, 43)]
  125:     result = read_fwf(StringIO(data), colspecs=colspecs, delimiter="~")
  126: 
  127:     expected = DataFrame(
  128:         [
  129:             [2011, 58, 360.242940, 149.910199, 11950.7],
  130:             [2011, 59, 444.953632, 166.985655, 11788.4],
  131:             [2011, 60, 364.136849, 183.628767, 11806.2],
  132:             [2011, 61, 413.836124, 184.375703, 11916.8],
  133:             [2011, 62, 502.953953, 173.237159, 12468.3],
  134:         ],
  135:         columns=["A", "B", "C", "D", "E"],
  136:     )
  137:     tm.assert_frame_equal(result, expected)
  138: 
  139: 
  140: def test_over_specified():
  141:     data = """\
  142: A   B     C            D            E
  143: 201158    360.242940   149.910199   11950.7
  144: 201159    444.953632   166.985655   11788.4
  145: 201160    364.136849   183.628767   11806.2
  146: 201161    413.836124   184.375703   11916.8
  147: 201162    502.953953   173.237159   12468.3
  148: """
  149:     colspecs = [(0, 4), (4, 8), (8, 20), (21, 33), (34, 43)]
  150: 
  151:     with pytest.raises(ValueError, match="must specify only one of"):
  152:         read_fwf(StringIO(data), colspecs=colspecs, widths=[6, 10, 10, 7])
  153: 
  154: 
  155: def test_under_specified():
  156:     data = """\
  157: A   B     C            D            E
  158: 201158    360.242940   149.910199   11950.7
  159: 201159    444.953632   166.985655   11788.4
  160: 201160    364.136849   183.628767   11806.2
  161: 201161    413.836124   184.375703   11916.8
  162: 201162    502.953953   173.237159   12468.3
  163: """
  164:     with pytest.raises(ValueError, match="Must specify either"):
  165:         read_fwf(StringIO(data), colspecs=None, widths=None)
  166: 
  167: 
  168: def test_read_csv_compat():
  169:     csv_data = """\
  170: A,B,C,D,E
  171: 2011,58,360.242940,149.910199,11950.7
  172: 2011,59,444.953632,166.985655,11788.4
  173: 2011,60,364.136849,183.628767,11806.2
  174: 2011,61,413.836124,184.375703,11916.8
  175: 2011,62,502.953953,173.237159,12468.3
  176: """
  177:     expected = read_csv(StringIO(csv_data), engine="python")
  178: 
  179:     fwf_data = """\
  180: A   B     C            D            E
  181: 201158    360.242940   149.910199   11950.7
  182: 201159    444.953632   166.985655   11788.4
  183: 201160    364.136849   183.628767   11806.2
  184: 201161    413.836124   184.375703   11916.8
  185: 201162    502.953953   173.237159   12468.3
  186: """
  187:     colspecs = [(0, 4), (4, 8), (8, 20), (21, 33), (34, 43)]
  188:     result = read_fwf(StringIO(fwf_data), colspecs=colspecs)
  189:     tm.assert_frame_equal(result, expected)
  190: 
  191: 
  192: def test_bytes_io_input():
  193:     data = BytesIO("Ч©ЧњЧ•Чќ\nЧ©ЧњЧ•Чќ".encode())  # noqa: RUF001
  194:     result = read_fwf(data, widths=[2, 2], encoding="utf8")
  195:     expected = DataFrame([["Ч©Чњ", "Ч•Чќ"]], columns=["Ч©Чњ", "Ч•Чќ"])
  196:     tm.assert_frame_equal(result, expected)
  197: 
  198: 
  199: def test_fwf_colspecs_is_list_or_tuple():
  200:     data = """index,A,B,C,D
  201: foo,2,3,4,5
  202: bar,7,8,9,10
  203: baz,12,13,14,15
  204: qux,12,13,14,15
  205: foo2,12,13,14,15
  206: bar2,12,13,14,15
  207: """
  208: 
  209:     msg = "column specifications must be a list or tuple.+"
  210: 
  211:     with pytest.raises(TypeError, match=msg):
  212:         read_fwf(StringIO(data), colspecs={"a": 1}, delimiter=",")
  213: 
  214: 
  215: def test_fwf_colspecs_is_list_or_tuple_of_two_element_tuples():
  216:     data = """index,A,B,C,D
  217: foo,2,3,4,5
  218: bar,7,8,9,10
  219: baz,12,13,14,15
  220: qux,12,13,14,15
  221: foo2,12,13,14,15
  222: bar2,12,13,14,15
  223: """
  224: 
  225:     msg = "Each column specification must be.+"
  226: 
  227:     with pytest.raises(TypeError, match=msg):
  228:         read_fwf(StringIO(data), colspecs=[("a", 1)])
  229: 
  230: 
  231: @pytest.mark.parametrize(
  232:     "colspecs,exp_data",
  233:     [
  234:         ([(0, 3), (3, None)], [[123, 456], [456, 789]]),
  235:         ([(None, 3), (3, 6)], [[123, 456], [456, 789]]),
  236:         ([(0, None), (3, None)], [[123456, 456], [456789, 789]]),
  237:         ([(None, None), (3, 6)], [[123456, 456], [456789, 789]]),
  238:     ],
  239: )
  240: def test_fwf_colspecs_none(colspecs, exp_data):
  241:     # see gh-7079
  242:     data = """\
  243: 123456
  244: 456789
  245: """
  246:     expected = DataFrame(exp_data)
  247: 
  248:     result = read_fwf(StringIO(data), colspecs=colspecs, header=None)
  249:     tm.assert_frame_equal(result, expected)
  250: 
  251: 
  252: @pytest.mark.parametrize(
  253:     "infer_nrows,exp_data",
  254:     [
  255:         # infer_nrows --> colspec == [(2, 3), (5, 6)]
  256:         (1, [[1, 2], [3, 8]]),
  257:         # infer_nrows > number of rows
  258:         (10, [[1, 2], [123, 98]]),
  259:     ],
  260: )
  261: def test_fwf_colspecs_infer_nrows(infer_nrows, exp_data):
  262:     # see gh-15138
  263:     data = """\
  264:   1  2
  265: 123 98
  266: """
  267:     expected = DataFrame(exp_data)
  268: 
  269:     result = read_fwf(StringIO(data), infer_nrows=infer_nrows, header=None)
  270:     tm.assert_frame_equal(result, expected)
  271: 
  272: 
  273: def test_fwf_regression():
  274:     # see gh-3594
  275:     #
  276:     # Turns out "T060" is parsable as a datetime slice!
  277:     tz_list = [1, 10, 20, 30, 60, 80, 100]
  278:     widths = [16] + [8] * len(tz_list)
  279:     names = ["SST"] + [f"T{z:03d}" for z in tz_list[1:]]
  280: 
  281:     data = """  2009164202000   9.5403  9.4105  8.6571  7.8372  6.0612  5.8843  5.5192
  282: 2009164203000   9.5435  9.2010  8.6167  7.8176  6.0804  5.8728  5.4869
  283: 2009164204000   9.5873  9.1326  8.4694  7.5889  6.0422  5.8526  5.4657
  284: 2009164205000   9.5810  9.0896  8.4009  7.4652  6.0322  5.8189  5.4379
  285: 2009164210000   9.6034  9.0897  8.3822  7.4905  6.0908  5.7904  5.4039
  286: """
  287: 
  288:     with tm.assert_produces_warning(FutureWarning, match="use 'date_format' instead"):
  289:         result = read_fwf(
  290:             StringIO(data),
  291:             index_col=0,
  292:             header=None,
  293:             names=names,
  294:             widths=widths,
  295:             parse_dates=True,
  296:             date_parser=lambda s: datetime.strptime(s, "%Y%j%H%M%S"),
  297:         )
  298:     expected = DataFrame(
  299:         [
  300:             [9.5403, 9.4105, 8.6571, 7.8372, 6.0612, 5.8843, 5.5192],
  301:             [9.5435, 9.2010, 8.6167, 7.8176, 6.0804, 5.8728, 5.4869],
  302:             [9.5873, 9.1326, 8.4694, 7.5889, 6.0422, 5.8526, 5.4657],
  303:             [9.5810, 9.0896, 8.4009, 7.4652, 6.0322, 5.8189, 5.4379],
  304:             [9.6034, 9.0897, 8.3822, 7.4905, 6.0908, 5.7904, 5.4039],
  305:         ],
  306:         index=DatetimeIndex(
  307:             [
  308:                 "2009-06-13 20:20:00",
  309:                 "2009-06-13 20:30:00",
  310:                 "2009-06-13 20:40:00",
  311:                 "2009-06-13 20:50:00",
  312:                 "2009-06-13 21:00:00",
  313:             ]
  314:         ),
  315:         columns=["SST", "T010", "T020", "T030", "T060", "T080", "T100"],
  316:     )
  317:     tm.assert_frame_equal(result, expected)
  318:     result = read_fwf(
  319:         StringIO(data),
  320:         index_col=0,
  321:         header=None,
  322:         names=names,
  323:         widths=widths,
  324:         parse_dates=True,
  325:         date_format="%Y%j%H%M%S",
  326:     )
  327:     tm.assert_frame_equal(result, expected)
  328: 
  329: 
  330: def test_fwf_for_uint8():
  331:     data = """1421302965.213420    PRI=3 PGN=0xef00      DST=0x17 SRC=0x28    04 154 00 00 00 00 00 127
  332: 1421302964.226776    PRI=6 PGN=0xf002               SRC=0x47    243 00 00 255 247 00 00 71"""  # noqa: E501
  333:     df = read_fwf(
  334:         StringIO(data),
  335:         colspecs=[(0, 17), (25, 26), (33, 37), (49, 51), (58, 62), (63, 1000)],
  336:         names=["time", "pri", "pgn", "dst", "src", "data"],
  337:         converters={
  338:             "pgn": lambda x: int(x, 16),
  339:             "src": lambda x: int(x, 16),
  340:             "dst": lambda x: int(x, 16),
  341:             "data": lambda x: len(x.split(" ")),
  342:         },
  343:     )
  344: 
  345:     expected = DataFrame(
  346:         [
  347:             [1421302965.213420, 3, 61184, 23, 40, 8],
  348:             [1421302964.226776, 6, 61442, None, 71, 8],
  349:         ],
  350:         columns=["time", "pri", "pgn", "dst", "src", "data"],
  351:     )
  352:     expected["dst"] = expected["dst"].astype(object)
  353:     tm.assert_frame_equal(df, expected)
  354: 
  355: 
  356: @pytest.mark.parametrize("comment", ["#", "~", "!"])
  357: def test_fwf_comment(comment):
  358:     data = """\
  359:   1   2.   4  #hello world
  360:   5  NaN  10.0
  361: """
  362:     data = data.replace("#", comment)
  363: 
  364:     colspecs = [(0, 3), (4, 9), (9, 25)]
  365:     expected = DataFrame([[1, 2.0, 4], [5, np.nan, 10.0]])
  366: 
  367:     result = read_fwf(StringIO(data), colspecs=colspecs, header=None, comment=comment)
  368:     tm.assert_almost_equal(result, expected)
  369: 
  370: 
  371: def test_fwf_skip_blank_lines():
  372:     data = """
  373: 
  374: A         B            C            D
  375: 
  376: 201158    360.242940   149.910199   11950.7
  377: 201159    444.953632   166.985655   11788.4
  378: 
  379: 
  380: 201162    502.953953   173.237159   12468.3
  381: 
  382: """
  383:     result = read_fwf(StringIO(data), skip_blank_lines=True)
  384:     expected = DataFrame(
  385:         [
  386:             [201158, 360.242940, 149.910199, 11950.7],
  387:             [201159, 444.953632, 166.985655, 11788.4],
  388:             [201162, 502.953953, 173.237159, 12468.3],
  389:         ],
  390:         columns=["A", "B", "C", "D"],
  391:     )
  392:     tm.assert_frame_equal(result, expected)
  393: 
  394:     data = """\
  395: A         B            C            D
  396: 201158    360.242940   149.910199   11950.7
  397: 201159    444.953632   166.985655   11788.4
  398: 
  399: 
  400: 201162    502.953953   173.237159   12468.3
  401: """
  402:     result = read_fwf(StringIO(data), skip_blank_lines=False)
  403:     expected = DataFrame(
  404:         [
  405:             [201158, 360.242940, 149.910199, 11950.7],
  406:             [201159, 444.953632, 166.985655, 11788.4],
  407:             [np.nan, np.nan, np.nan, np.nan],
  408:             [np.nan, np.nan, np.nan, np.nan],
  409:             [201162, 502.953953, 173.237159, 12468.3],
  410:         ],
  411:         columns=["A", "B", "C", "D"],
  412:     )
  413:     tm.assert_frame_equal(result, expected)
  414: 
  415: 
  416: @pytest.mark.parametrize("thousands", [",", "#", "~"])
  417: def test_fwf_thousands(thousands):
  418:     data = """\
  419:  1 2,334.0    5
  420: 10   13     10.
  421: """
  422:     data = data.replace(",", thousands)
  423: 
  424:     colspecs = [(0, 3), (3, 11), (12, 16)]
  425:     expected = DataFrame([[1, 2334.0, 5], [10, 13, 10.0]])
  426: 
  427:     result = read_fwf(
  428:         StringIO(data), header=None, colspecs=colspecs, thousands=thousands
  429:     )
  430:     tm.assert_almost_equal(result, expected)
  431: 
  432: 
  433: @pytest.mark.parametrize("header", [True, False])
  434: def test_bool_header_arg(header):
  435:     # see gh-6114
  436:     data = """\
  437: MyColumn
  438:    a
  439:    b
  440:    a
  441:    b"""
  442: 
  443:     msg = "Passing a bool to header is invalid"
  444:     with pytest.raises(TypeError, match=msg):
  445:         read_fwf(StringIO(data), header=header)
  446: 
  447: 
  448: def test_full_file():
  449:     # File with all values.
  450:     test = """index                             A    B    C
  451: 2000-01-03T00:00:00  0.980268513777    3  foo
  452: 2000-01-04T00:00:00  1.04791624281    -4  bar
  453: 2000-01-05T00:00:00  0.498580885705   73  baz
  454: 2000-01-06T00:00:00  1.12020151869     1  foo
  455: 2000-01-07T00:00:00  0.487094399463    0  bar
  456: 2000-01-10T00:00:00  0.836648671666    2  baz
  457: 2000-01-11T00:00:00  0.157160753327   34  foo"""
  458:     colspecs = ((0, 19), (21, 35), (38, 40), (42, 45))
  459:     expected = read_fwf(StringIO(test), colspecs=colspecs)
  460: 
  461:     result = read_fwf(StringIO(test))
  462:     tm.assert_frame_equal(result, expected)
  463: 
  464: 
  465: def test_full_file_with_missing():
  466:     # File with missing values.
  467:     test = """index                             A    B    C
  468: 2000-01-03T00:00:00  0.980268513777    3  foo
  469: 2000-01-04T00:00:00  1.04791624281    -4  bar
  470:                      0.498580885705   73  baz
  471: 2000-01-06T00:00:00  1.12020151869     1  foo
  472: 2000-01-07T00:00:00                    0  bar
  473: 2000-01-10T00:00:00  0.836648671666    2  baz
  474:                                       34"""
  475:     colspecs = ((0, 19), (21, 35), (38, 40), (42, 45))
  476:     expected = read_fwf(StringIO(test), colspecs=colspecs)
  477: 
  478:     result = read_fwf(StringIO(test))
  479:     tm.assert_frame_equal(result, expected)
  480: 
  481: 
  482: def test_full_file_with_spaces():
  483:     # File with spaces in columns.
  484:     test = """
  485: Account                 Name  Balance     CreditLimit   AccountCreated
  486: 101     Keanu Reeves          9315.45     10000.00           1/17/1998
  487: 312     Gerard Butler         90.00       1000.00             8/6/2003
  488: 868     Jennifer Love Hewitt  0           17000.00           5/25/1985
  489: 761     Jada Pinkett-Smith    49654.87    100000.00          12/5/2006
  490: 317     Bill Murray           789.65      5000.00             2/5/2007
  491: """.strip(
  492:         "\r\n"
  493:     )
  494:     colspecs = ((0, 7), (8, 28), (30, 38), (42, 53), (56, 70))
  495:     expected = read_fwf(StringIO(test), colspecs=colspecs)
  496: 
  497:     result = read_fwf(StringIO(test))
  498:     tm.assert_frame_equal(result, expected)
  499: 
  500: 
  501: def test_full_file_with_spaces_and_missing():
  502:     # File with spaces and missing values in columns.
  503:     test = """
  504: Account               Name    Balance     CreditLimit   AccountCreated
  505: 101                           10000.00                       1/17/1998
  506: 312     Gerard Butler         90.00       1000.00             8/6/2003
  507: 868                                                          5/25/1985
  508: 761     Jada Pinkett-Smith    49654.87    100000.00          12/5/2006
  509: 317     Bill Murray           789.65
  510: """.strip(
  511:         "\r\n"
  512:     )
  513:     colspecs = ((0, 7), (8, 28), (30, 38), (42, 53), (56, 70))
  514:     expected = read_fwf(StringIO(test), colspecs=colspecs)
  515: 
  516:     result = read_fwf(StringIO(test))
  517:     tm.assert_frame_equal(result, expected)
  518: 
  519: 
  520: def test_messed_up_data():
  521:     # Completely messed up file.
  522:     test = """
  523:    Account          Name             Balance     Credit Limit   Account Created
  524:        101                           10000.00                       1/17/1998
  525:        312     Gerard Butler         90.00       1000.00
  526: 
  527:        761     Jada Pinkett-Smith    49654.87    100000.00          12/5/2006
  528:   317          Bill Murray           789.65
  529: """.strip(
  530:         "\r\n"
  531:     )
  532:     colspecs = ((2, 10), (15, 33), (37, 45), (49, 61), (64, 79))
  533:     expected = read_fwf(StringIO(test), colspecs=colspecs)
  534: 
  535:     result = read_fwf(StringIO(test))
  536:     tm.assert_frame_equal(result, expected)
  537: 
  538: 
  539: def test_multiple_delimiters():
  540:     test = r"""
  541: col1~~~~~col2  col3++++++++++++++++++col4
  542: ~~22.....11.0+++foo~~~~~~~~~~Keanu Reeves
  543:   33+++122.33\\\bar.........Gerard Butler
  544: ++44~~~~12.01   baz~~Jennifer Love Hewitt
  545: ~~55       11+++foo++++Jada Pinkett-Smith
  546: ..66++++++.03~~~bar           Bill Murray
  547: """.strip(
  548:         "\r\n"
  549:     )
  550:     delimiter = " +~.\\"
  551:     colspecs = ((0, 4), (7, 13), (15, 19), (21, 41))
  552:     expected = read_fwf(StringIO(test), colspecs=colspecs, delimiter=delimiter)
  553: 
  554:     result = read_fwf(StringIO(test), delimiter=delimiter)
  555:     tm.assert_frame_equal(result, expected)
  556: 
  557: 
  558: def test_variable_width_unicode():
  559:     data = """
  560: Ч©ЧњЧ•Чќ Ч©ЧњЧ•Чќ
  561: Ч•Чќ   Ч©ЧњЧњ
  562: Ч©Чњ   Ч•Чќ
  563: """.strip(
  564:         "\r\n"
  565:     )
  566:     encoding = "utf8"
  567:     kwargs = {"header": None, "encoding": encoding}
  568: 
  569:     expected = read_fwf(
  570:         BytesIO(data.encode(encoding)), colspecs=[(0, 4), (5, 9)], **kwargs
  571:     )
  572:     result = read_fwf(BytesIO(data.encode(encoding)), **kwargs)
  573:     tm.assert_frame_equal(result, expected)
  574: 
  575: 
  576: @pytest.mark.parametrize("dtype", [{}, {"a": "float64", "b": str, "c": "int32"}])
  577: def test_dtype(dtype):
  578:     data = """ a    b    c
  579: 1    2    3.2
  580: 3    4    5.2
  581: """
  582:     colspecs = [(0, 5), (5, 10), (10, None)]
  583:     result = read_fwf(StringIO(data), colspecs=colspecs, dtype=dtype)
  584: 
  585:     expected = DataFrame(
  586:         {"a": [1, 3], "b": [2, 4], "c": [3.2, 5.2]}, columns=["a", "b", "c"]
  587:     )
  588: 
  589:     for col, dt in dtype.items():
  590:         expected[col] = expected[col].astype(dt)
  591: 
  592:     tm.assert_frame_equal(result, expected)
  593: 
  594: 
  595: def test_skiprows_inference():
  596:     # see gh-11256
  597:     data = """
  598: Text contained in the file header
  599: 
  600: DataCol1   DataCol2
  601:      0.0        1.0
  602:    101.6      956.1
  603: """.strip()
  604:     skiprows = 2
  605: 
  606:     depr_msg = "The 'delim_whitespace' keyword in pd.read_csv is deprecated"
  607:     with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  608:         expected = read_csv(StringIO(data), skiprows=skiprows, delim_whitespace=True)
  609: 
  610:     result = read_fwf(StringIO(data), skiprows=skiprows)
  611:     tm.assert_frame_equal(result, expected)
  612: 
  613: 
  614: def test_skiprows_by_index_inference():
  615:     data = """
  616: To be skipped
  617: Not  To  Be  Skipped
  618: Once more to be skipped
  619: 123  34   8      123
  620: 456  78   9      456
  621: """.strip()
  622:     skiprows = [0, 2]
  623: 
  624:     depr_msg = "The 'delim_whitespace' keyword in pd.read_csv is deprecated"
  625:     with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  626:         expected = read_csv(StringIO(data), skiprows=skiprows, delim_whitespace=True)
  627: 
  628:     result = read_fwf(StringIO(data), skiprows=skiprows)
  629:     tm.assert_frame_equal(result, expected)
  630: 
  631: 
  632: def test_skiprows_inference_empty():
  633:     data = """
  634: AA   BBB  C
  635: 12   345  6
  636: 78   901  2
  637: """.strip()
  638: 
  639:     msg = "No rows from which to infer column width"
  640:     with pytest.raises(EmptyDataError, match=msg):
  641:         read_fwf(StringIO(data), skiprows=3)
  642: 
  643: 
  644: def test_whitespace_preservation():
  645:     # see gh-16772
  646:     header = None
  647:     csv_data = """
  648:  a ,bbb
  649:  cc,dd """
  650: 
  651:     fwf_data = """
  652:  a bbb
  653:  ccdd """
  654:     result = read_fwf(
  655:         StringIO(fwf_data), widths=[3, 3], header=header, skiprows=[0], delimiter="\n\t"
  656:     )
  657:     expected = read_csv(StringIO(csv_data), header=header)
  658:     tm.assert_frame_equal(result, expected)
  659: 
  660: 
  661: def test_default_delimiter():
  662:     header = None
  663:     csv_data = """
  664: a,bbb
  665: cc,dd"""
  666: 
  667:     fwf_data = """
  668: a \tbbb
  669: cc\tdd """
  670:     result = read_fwf(StringIO(fwf_data), widths=[3, 3], header=header, skiprows=[0])
  671:     expected = read_csv(StringIO(csv_data), header=header)
  672:     tm.assert_frame_equal(result, expected)
  673: 
  674: 
  675: @pytest.mark.parametrize("infer", [True, False])
  676: def test_fwf_compression(compression_only, infer, compression_to_extension):
  677:     data = """1111111111
  678:     2222222222
  679:     3333333333""".strip()
  680: 
  681:     compression = compression_only
  682:     extension = compression_to_extension[compression]
  683: 
  684:     kwargs = {"widths": [5, 5], "names": ["one", "two"]}
  685:     expected = read_fwf(StringIO(data), **kwargs)
  686: 
  687:     data = bytes(data, encoding="utf-8")
  688: 
  689:     with tm.ensure_clean(filename="tmp." + extension) as path:
  690:         tm.write_to_compressed(compression, path, data)
  691: 
  692:         if infer is not None:
  693:             kwargs["compression"] = "infer" if infer else compression
  694: 
  695:         result = read_fwf(path, **kwargs)
  696:         tm.assert_frame_equal(result, expected)
  697: 
  698: 
  699: def test_binary_mode():
  700:     """
  701:     read_fwf supports opening files in binary mode.
  702: 
  703:     GH 18035.
  704:     """
  705:     data = """aaa aaa aaa
  706: bba bab b a"""
  707:     df_reference = DataFrame(
  708:         [["bba", "bab", "b a"]], columns=["aaa", "aaa.1", "aaa.2"], index=[0]
  709:     )
  710:     with tm.ensure_clean() as path:
  711:         Path(path).write_text(data, encoding="utf-8")
  712:         with open(path, "rb") as file:
  713:             df = read_fwf(file)
  714:             file.seek(0)
  715:             tm.assert_frame_equal(df, df_reference)
  716: 
  717: 
  718: @pytest.mark.parametrize("memory_map", [True, False])
  719: def test_encoding_mmap(memory_map):
  720:     """
  721:     encoding should be working, even when using a memory-mapped file.
  722: 
  723:     GH 23254.
  724:     """
  725:     encoding = "iso8859_1"
  726:     with tm.ensure_clean() as path:
  727:         Path(path).write_bytes(" 1 A Г„ 2\n".encode(encoding))
  728:         df = read_fwf(
  729:             path,
  730:             header=None,
  731:             widths=[2, 2, 2, 2],
  732:             encoding=encoding,
  733:             memory_map=memory_map,
  734:         )
  735:     df_reference = DataFrame([[1, "A", "Г„", 2]])
  736:     tm.assert_frame_equal(df, df_reference)
  737: 
  738: 
  739: @pytest.mark.parametrize(
  740:     "colspecs, names, widths, index_col",
  741:     [
  742:         (
  743:             [(0, 6), (6, 12), (12, 18), (18, None)],
  744:             list("abcde"),
  745:             None,
  746:             None,
  747:         ),
  748:         (
  749:             None,
  750:             list("abcde"),
  751:             [6] * 4,
  752:             None,
  753:         ),
  754:         (
  755:             [(0, 6), (6, 12), (12, 18), (18, None)],
  756:             list("abcde"),
  757:             None,
  758:             True,
  759:         ),
  760:         (
  761:             None,
  762:             list("abcde"),
  763:             [6] * 4,
  764:             False,
  765:         ),
  766:         (
  767:             None,
  768:             list("abcde"),
  769:             [6] * 4,
  770:             True,
  771:         ),
  772:         (
  773:             [(0, 6), (6, 12), (12, 18), (18, None)],
  774:             list("abcde"),
  775:             None,
  776:             False,
  777:         ),
  778:     ],
  779: )
  780: def test_len_colspecs_len_names(colspecs, names, widths, index_col):
  781:     # GH#40830
  782:     data = """col1  col2  col3  col4
  783:     bab   ba    2"""
  784:     msg = "Length of colspecs must match length of names"
  785:     with pytest.raises(ValueError, match=msg):
  786:         read_fwf(
  787:             StringIO(data),
  788:             colspecs=colspecs,
  789:             names=names,
  790:             widths=widths,
  791:             index_col=index_col,
  792:         )
  793: 
  794: 
  795: @pytest.mark.parametrize(
  796:     "colspecs, names, widths, index_col, expected",
  797:     [
  798:         (
  799:             [(0, 6), (6, 12), (12, 18), (18, None)],
  800:             list("abc"),
  801:             None,
  802:             0,
  803:             DataFrame(
  804:                 index=["col1", "ba"],
  805:                 columns=["a", "b", "c"],
  806:                 data=[["col2", "col3", "col4"], ["b   ba", "2", np.nan]],
  807:             ),
  808:         ),
  809:         (
  810:             [(0, 6), (6, 12), (12, 18), (18, None)],
  811:             list("ab"),
  812:             None,
  813:             [0, 1],
  814:             DataFrame(
  815:                 index=[["col1", "ba"], ["col2", "b   ba"]],
  816:                 columns=["a", "b"],
  817:                 data=[["col3", "col4"], ["2", np.nan]],
  818:             ),
  819:         ),
  820:         (
  821:             [(0, 6), (6, 12), (12, 18), (18, None)],
  822:             list("a"),
  823:             None,
  824:             [0, 1, 2],
  825:             DataFrame(
  826:                 index=[["col1", "ba"], ["col2", "b   ba"], ["col3", "2"]],
  827:                 columns=["a"],
  828:                 data=[["col4"], [np.nan]],
  829:             ),
  830:         ),
  831:         (
  832:             None,
  833:             list("abc"),
  834:             [6] * 4,
  835:             0,
  836:             DataFrame(
  837:                 index=["col1", "ba"],
  838:                 columns=["a", "b", "c"],
  839:                 data=[["col2", "col3", "col4"], ["b   ba", "2", np.nan]],
  840:             ),
  841:         ),
  842:         (
  843:             None,
  844:             list("ab"),
  845:             [6] * 4,
  846:             [0, 1],
  847:             DataFrame(
  848:                 index=[["col1", "ba"], ["col2", "b   ba"]],
  849:                 columns=["a", "b"],
  850:                 data=[["col3", "col4"], ["2", np.nan]],
  851:             ),
  852:         ),
  853:         (
  854:             None,
  855:             list("a"),
  856:             [6] * 4,
  857:             [0, 1, 2],
  858:             DataFrame(
  859:                 index=[["col1", "ba"], ["col2", "b   ba"], ["col3", "2"]],
  860:                 columns=["a"],
  861:                 data=[["col4"], [np.nan]],
  862:             ),
  863:         ),
  864:     ],
  865: )
  866: def test_len_colspecs_len_names_with_index_col(
  867:     colspecs, names, widths, index_col, expected
  868: ):
  869:     # GH#40830
  870:     data = """col1  col2  col3  col4
  871:     bab   ba    2"""
  872:     result = read_fwf(
  873:         StringIO(data),
  874:         colspecs=colspecs,
  875:         names=names,
  876:         widths=widths,
  877:         index_col=index_col,
  878:     )
  879:     tm.assert_frame_equal(result, expected)
  880: 
  881: 
  882: def test_colspecs_with_comment():
  883:     # GH 14135
  884:     result = read_fwf(
  885:         StringIO("#\nA1K\n"), colspecs=[(1, 2), (2, 3)], comment="#", header=None
  886:     )
  887:     expected = DataFrame([[1, "K"]], columns=[0, 1])
  888:     tm.assert_frame_equal(result, expected)
  889: 
  890: 
  891: def test_skip_rows_and_n_rows():
  892:     # GH#44021
  893:     data = """a\tb
  894: 1\t a
  895: 2\t b
  896: 3\t c
  897: 4\t d
  898: 5\t e
  899: 6\t f
  900:     """
  901:     result = read_fwf(StringIO(data), nrows=4, skiprows=[2, 4])
  902:     expected = DataFrame({"a": [1, 3, 5, 6], "b": ["a", "c", "e", "f"]})
  903:     tm.assert_frame_equal(result, expected)
  904: 
  905: 
  906: def test_skiprows_with_iterator():
  907:     # GH#10261, GH#56323
  908:     data = """0
  909: 1
  910: 2
  911: 3
  912: 4
  913: 5
  914: 6
  915: 7
  916: 8
  917: 9
  918:     """
  919:     df_iter = read_fwf(
  920:         StringIO(data),
  921:         colspecs=[(0, 2)],
  922:         names=["a"],
  923:         iterator=True,
  924:         chunksize=2,
  925:         skiprows=[0, 1, 2, 6, 9],
  926:     )
  927:     expected_frames = [
  928:         DataFrame({"a": [3, 4]}),
  929:         DataFrame({"a": [5, 7]}, index=[2, 3]),
  930:         DataFrame({"a": [8]}, index=[4]),
  931:     ]
  932:     for i, result in enumerate(df_iter):
  933:         tm.assert_frame_equal(result, expected_frames[i])
  934: 
  935: 
  936: def test_names_and_infer_colspecs():
  937:     # GH#45337
  938:     data = """X   Y   Z
  939:       959.0    345   22.2
  940:     """
  941:     result = read_fwf(StringIO(data), skiprows=1, usecols=[0, 2], names=["a", "b"])
  942:     expected = DataFrame({"a": [959.0], "b": 22.2})
  943:     tm.assert_frame_equal(result, expected)
  944: 
  945: 
  946: def test_widths_and_usecols():
  947:     # GH#46580
  948:     data = """0  1    n -0.4100.1
  949: 0  2    p  0.2 90.1
  950: 0  3    n -0.3140.4"""
  951:     result = read_fwf(
  952:         StringIO(data),
  953:         header=None,
  954:         usecols=(0, 1, 3),
  955:         widths=(3, 5, 1, 5, 5),
  956:         index_col=False,
  957:         names=("c0", "c1", "c3"),
  958:     )
  959:     expected = DataFrame(
  960:         {
  961:             "c0": 0,
  962:             "c1": [1, 2, 3],
  963:             "c3": [-0.4, 0.2, -0.3],
  964:         }
  965:     )
  966:     tm.assert_frame_equal(result, expected)
  967: 
  968: 
  969: def test_dtype_backend(string_storage, dtype_backend):
  970:     # GH#50289
  971:     if string_storage == "python":
  972:         arr = StringArray(np.array(["a", "b"], dtype=np.object_))
  973:         arr_na = StringArray(np.array([pd.NA, "a"], dtype=np.object_))
  974:     elif dtype_backend == "pyarrow":
  975:         pa = pytest.importorskip("pyarrow")
  976:         from pandas.arrays import ArrowExtensionArray
  977: 
  978:         arr = ArrowExtensionArray(pa.array(["a", "b"]))
  979:         arr_na = ArrowExtensionArray(pa.array([None, "a"]))
  980:     else:
  981:         pa = pytest.importorskip("pyarrow")
  982:         arr = ArrowStringArray(pa.array(["a", "b"]))
  983:         arr_na = ArrowStringArray(pa.array([None, "a"]))
  984: 
  985:     data = """a  b    c      d  e     f  g    h  i
  986: 1  2.5  True  a
  987: 3  4.5  False b  True  6  7.5  a"""
  988:     with pd.option_context("mode.string_storage", string_storage):
  989:         result = read_fwf(StringIO(data), dtype_backend=dtype_backend)
  990: 
  991:     expected = DataFrame(
  992:         {
  993:             "a": pd.Series([1, 3], dtype="Int64"),
  994:             "b": pd.Series([2.5, 4.5], dtype="Float64"),
  995:             "c": pd.Series([True, False], dtype="boolean"),
  996:             "d": arr,
  997:             "e": pd.Series([pd.NA, True], dtype="boolean"),
  998:             "f": pd.Series([pd.NA, 6], dtype="Int64"),
  999:             "g": pd.Series([pd.NA, 7.5], dtype="Float64"),
 1000:             "h": arr_na,
 1001:             "i": pd.Series([pd.NA, pd.NA], dtype="Int64"),
 1002:         }
 1003:     )
 1004:     if dtype_backend == "pyarrow":
 1005:         pa = pytest.importorskip("pyarrow")
 1006:         from pandas.arrays import ArrowExtensionArray
 1007: 
 1008:         expected = DataFrame(
 1009:             {
 1010:                 col: ArrowExtensionArray(pa.array(expected[col], from_pandas=True))
 1011:                 for col in expected.columns
 1012:             }
 1013:         )
 1014:         expected["i"] = ArrowExtensionArray(pa.array([None, None]))
 1015: 
 1016:     tm.assert_frame_equal(result, expected)
 1017: 
 1018: 
 1019: def test_invalid_dtype_backend():
 1020:     msg = (
 1021:         "dtype_backend numpy is invalid, only 'numpy_nullable' and "
 1022:         "'pyarrow' are allowed."
 1023:     )
 1024:     with pytest.raises(ValueError, match=msg):
 1025:         read_fwf("test", dtype_backend="numpy")
 1026: 
 1027: 
 1028: @pytest.mark.network
 1029: @pytest.mark.single_cpu
 1030: def test_url_urlopen(httpserver):
 1031:     data = """\
 1032: A         B            C            D
 1033: 201158    360.242940   149.910199   11950.7
 1034: 201159    444.953632   166.985655   11788.4
 1035: 201160    364.136849   183.628767   11806.2
 1036: 201161    413.836124   184.375703   11916.8
 1037: 201162    502.953953   173.237159   12468.3
 1038: """
 1039:     httpserver.serve_content(content=data)
 1040:     expected = pd.Index(list("ABCD"))
 1041:     with urlopen(httpserver.url) as f:
 1042:         result = read_fwf(f).columns
 1043: 
 1044:     tm.assert_index_equal(result, expected)
