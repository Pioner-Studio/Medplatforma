    1: """
    2: Tests dtype specification during parsing
    3: for all of the parsers defined in parsers.py
    4: """
    5: from io import StringIO
    6: import os
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas._libs import parsers as libparsers
   12: 
   13: from pandas.core.dtypes.dtypes import CategoricalDtype
   14: 
   15: import pandas as pd
   16: from pandas import (
   17:     Categorical,
   18:     DataFrame,
   19:     Timestamp,
   20: )
   21: import pandas._testing as tm
   22: 
   23: pytestmark = pytest.mark.filterwarnings(
   24:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   25: )
   26: 
   27: xfail_pyarrow = pytest.mark.usefixtures("pyarrow_xfail")
   28: 
   29: 
   30: @xfail_pyarrow  # AssertionError: Attributes of DataFrame.iloc[:, 0] are different
   31: @pytest.mark.parametrize(
   32:     "dtype",
   33:     [
   34:         "category",
   35:         CategoricalDtype(),
   36:         {"a": "category", "b": "category", "c": CategoricalDtype()},
   37:     ],
   38: )
   39: def test_categorical_dtype(all_parsers, dtype):
   40:     # see gh-10153
   41:     parser = all_parsers
   42:     data = """a,b,c
   43: 1,a,3.4
   44: 1,a,3.4
   45: 2,b,4.5"""
   46:     expected = DataFrame(
   47:         {
   48:             "a": Categorical(["1", "1", "2"]),
   49:             "b": Categorical(["a", "a", "b"]),
   50:             "c": Categorical(["3.4", "3.4", "4.5"]),
   51:         }
   52:     )
   53:     actual = parser.read_csv(StringIO(data), dtype=dtype)
   54:     tm.assert_frame_equal(actual, expected)
   55: 
   56: 
   57: @pytest.mark.parametrize("dtype", [{"b": "category"}, {1: "category"}])
   58: def test_categorical_dtype_single(all_parsers, dtype, request):
   59:     # see gh-10153
   60:     parser = all_parsers
   61:     data = """a,b,c
   62: 1,a,3.4
   63: 1,a,3.4
   64: 2,b,4.5"""
   65:     expected = DataFrame(
   66:         {"a": [1, 1, 2], "b": Categorical(["a", "a", "b"]), "c": [3.4, 3.4, 4.5]}
   67:     )
   68:     if parser.engine == "pyarrow":
   69:         mark = pytest.mark.xfail(
   70:             strict=False,
   71:             reason="Flaky test sometimes gives object dtype instead of Categorical",
   72:         )
   73:         request.applymarker(mark)
   74: 
   75:     actual = parser.read_csv(StringIO(data), dtype=dtype)
   76:     tm.assert_frame_equal(actual, expected)
   77: 
   78: 
   79: @xfail_pyarrow  # AssertionError: Attributes of DataFrame.iloc[:, 0] are different
   80: def test_categorical_dtype_unsorted(all_parsers):
   81:     # see gh-10153
   82:     parser = all_parsers
   83:     data = """a,b,c
   84: 1,b,3.4
   85: 1,b,3.4
   86: 2,a,4.5"""
   87:     expected = DataFrame(
   88:         {
   89:             "a": Categorical(["1", "1", "2"]),
   90:             "b": Categorical(["b", "b", "a"]),
   91:             "c": Categorical(["3.4", "3.4", "4.5"]),
   92:         }
   93:     )
   94:     actual = parser.read_csv(StringIO(data), dtype="category")
   95:     tm.assert_frame_equal(actual, expected)
   96: 
   97: 
   98: @xfail_pyarrow  # AssertionError: Attributes of DataFrame.iloc[:, 0] are different
   99: def test_categorical_dtype_missing(all_parsers):
  100:     # see gh-10153
  101:     parser = all_parsers
  102:     data = """a,b,c
  103: 1,b,3.4
  104: 1,nan,3.4
  105: 2,a,4.5"""
  106:     expected = DataFrame(
  107:         {
  108:             "a": Categorical(["1", "1", "2"]),
  109:             "b": Categorical(["b", np.nan, "a"]),
  110:             "c": Categorical(["3.4", "3.4", "4.5"]),
  111:         }
  112:     )
  113:     actual = parser.read_csv(StringIO(data), dtype="category")
  114:     tm.assert_frame_equal(actual, expected)
  115: 
  116: 
  117: @xfail_pyarrow  # AssertionError: Attributes of DataFrame.iloc[:, 0] are different
  118: @pytest.mark.slow
  119: def test_categorical_dtype_high_cardinality_numeric(all_parsers, monkeypatch):
  120:     # see gh-18186
  121:     # was an issue with C parser, due to DEFAULT_BUFFER_HEURISTIC
  122:     parser = all_parsers
  123:     heuristic = 2**5
  124:     data = np.sort([str(i) for i in range(heuristic + 1)])
  125:     expected = DataFrame({"a": Categorical(data, ordered=True)})
  126:     with monkeypatch.context() as m:
  127:         m.setattr(libparsers, "DEFAULT_BUFFER_HEURISTIC", heuristic)
  128:         actual = parser.read_csv(StringIO("a\n" + "\n".join(data)), dtype="category")
  129:     actual["a"] = actual["a"].cat.reorder_categories(
  130:         np.sort(actual.a.cat.categories), ordered=True
  131:     )
  132:     tm.assert_frame_equal(actual, expected)
  133: 
  134: 
  135: def test_categorical_dtype_utf16(all_parsers, csv_dir_path):
  136:     # see gh-10153
  137:     pth = os.path.join(csv_dir_path, "utf16_ex.txt")
  138:     parser = all_parsers
  139:     encoding = "utf-16"
  140:     sep = "\t"
  141: 
  142:     expected = parser.read_csv(pth, sep=sep, encoding=encoding)
  143:     expected = expected.apply(Categorical)
  144: 
  145:     actual = parser.read_csv(pth, sep=sep, encoding=encoding, dtype="category")
  146:     tm.assert_frame_equal(actual, expected)
  147: 
  148: 
  149: def test_categorical_dtype_chunksize_infer_categories(all_parsers):
  150:     # see gh-10153
  151:     parser = all_parsers
  152:     data = """a,b
  153: 1,a
  154: 1,b
  155: 1,b
  156: 2,c"""
  157:     expecteds = [
  158:         DataFrame({"a": [1, 1], "b": Categorical(["a", "b"])}),
  159:         DataFrame({"a": [1, 2], "b": Categorical(["b", "c"])}, index=[2, 3]),
  160:     ]
  161: 
  162:     if parser.engine == "pyarrow":
  163:         msg = "The 'chunksize' option is not supported with the 'pyarrow' engine"
  164:         with pytest.raises(ValueError, match=msg):
  165:             parser.read_csv(StringIO(data), dtype={"b": "category"}, chunksize=2)
  166:         return
  167: 
  168:     with parser.read_csv(
  169:         StringIO(data), dtype={"b": "category"}, chunksize=2
  170:     ) as actuals:
  171:         for actual, expected in zip(actuals, expecteds):
  172:             tm.assert_frame_equal(actual, expected)
  173: 
  174: 
  175: def test_categorical_dtype_chunksize_explicit_categories(all_parsers):
  176:     # see gh-10153
  177:     parser = all_parsers
  178:     data = """a,b
  179: 1,a
  180: 1,b
  181: 1,b
  182: 2,c"""
  183:     cats = ["a", "b", "c"]
  184:     expecteds = [
  185:         DataFrame({"a": [1, 1], "b": Categorical(["a", "b"], categories=cats)}),
  186:         DataFrame(
  187:             {"a": [1, 2], "b": Categorical(["b", "c"], categories=cats)},
  188:             index=[2, 3],
  189:         ),
  190:     ]
  191:     dtype = CategoricalDtype(cats)
  192: 
  193:     if parser.engine == "pyarrow":
  194:         msg = "The 'chunksize' option is not supported with the 'pyarrow' engine"
  195:         with pytest.raises(ValueError, match=msg):
  196:             parser.read_csv(StringIO(data), dtype={"b": dtype}, chunksize=2)
  197:         return
  198: 
  199:     with parser.read_csv(StringIO(data), dtype={"b": dtype}, chunksize=2) as actuals:
  200:         for actual, expected in zip(actuals, expecteds):
  201:             tm.assert_frame_equal(actual, expected)
  202: 
  203: 
  204: def test_categorical_dtype_latin1(all_parsers, csv_dir_path):
  205:     # see gh-10153
  206:     pth = os.path.join(csv_dir_path, "unicode_series.csv")
  207:     parser = all_parsers
  208:     encoding = "latin-1"
  209: 
  210:     expected = parser.read_csv(pth, header=None, encoding=encoding)
  211:     expected[1] = Categorical(expected[1])
  212: 
  213:     actual = parser.read_csv(pth, header=None, encoding=encoding, dtype={1: "category"})
  214:     tm.assert_frame_equal(actual, expected)
  215: 
  216: 
  217: @pytest.mark.parametrize("ordered", [False, True])
  218: @pytest.mark.parametrize(
  219:     "categories",
  220:     [["a", "b", "c"], ["a", "c", "b"], ["a", "b", "c", "d"], ["c", "b", "a"]],
  221: )
  222: def test_categorical_category_dtype(all_parsers, categories, ordered):
  223:     parser = all_parsers
  224:     data = """a,b
  225: 1,a
  226: 1,b
  227: 1,b
  228: 2,c"""
  229:     expected = DataFrame(
  230:         {
  231:             "a": [1, 1, 1, 2],
  232:             "b": Categorical(
  233:                 ["a", "b", "b", "c"], categories=categories, ordered=ordered
  234:             ),
  235:         }
  236:     )
  237: 
  238:     dtype = {"b": CategoricalDtype(categories=categories, ordered=ordered)}
  239:     result = parser.read_csv(StringIO(data), dtype=dtype)
  240:     tm.assert_frame_equal(result, expected)
  241: 
  242: 
  243: def test_categorical_category_dtype_unsorted(all_parsers):
  244:     parser = all_parsers
  245:     data = """a,b
  246: 1,a
  247: 1,b
  248: 1,b
  249: 2,c"""
  250:     dtype = CategoricalDtype(["c", "b", "a"])
  251:     expected = DataFrame(
  252:         {
  253:             "a": [1, 1, 1, 2],
  254:             "b": Categorical(["a", "b", "b", "c"], categories=["c", "b", "a"]),
  255:         }
  256:     )
  257: 
  258:     result = parser.read_csv(StringIO(data), dtype={"b": dtype})
  259:     tm.assert_frame_equal(result, expected)
  260: 
  261: 
  262: def test_categorical_coerces_numeric(all_parsers):
  263:     parser = all_parsers
  264:     dtype = {"b": CategoricalDtype([1, 2, 3])}
  265: 
  266:     data = "b\n1\n1\n2\n3"
  267:     expected = DataFrame({"b": Categorical([1, 1, 2, 3])})
  268: 
  269:     result = parser.read_csv(StringIO(data), dtype=dtype)
  270:     tm.assert_frame_equal(result, expected)
  271: 
  272: 
  273: def test_categorical_coerces_datetime(all_parsers):
  274:     parser = all_parsers
  275:     dti = pd.DatetimeIndex(["2017-01-01", "2018-01-01", "2019-01-01"], freq=None)
  276:     dtype = {"b": CategoricalDtype(dti)}
  277: 
  278:     data = "b\n2017-01-01\n2018-01-01\n2019-01-01"
  279:     expected = DataFrame({"b": Categorical(dtype["b"].categories)})
  280: 
  281:     result = parser.read_csv(StringIO(data), dtype=dtype)
  282:     tm.assert_frame_equal(result, expected)
  283: 
  284: 
  285: def test_categorical_coerces_timestamp(all_parsers):
  286:     parser = all_parsers
  287:     dtype = {"b": CategoricalDtype([Timestamp("2014")])}
  288: 
  289:     data = "b\n2014-01-01\n2014-01-01"
  290:     expected = DataFrame({"b": Categorical([Timestamp("2014")] * 2)})
  291: 
  292:     result = parser.read_csv(StringIO(data), dtype=dtype)
  293:     tm.assert_frame_equal(result, expected)
  294: 
  295: 
  296: def test_categorical_coerces_timedelta(all_parsers):
  297:     parser = all_parsers
  298:     dtype = {"b": CategoricalDtype(pd.to_timedelta(["1h", "2h", "3h"]))}
  299: 
  300:     data = "b\n1h\n2h\n3h"
  301:     expected = DataFrame({"b": Categorical(dtype["b"].categories)})
  302: 
  303:     result = parser.read_csv(StringIO(data), dtype=dtype)
  304:     tm.assert_frame_equal(result, expected)
  305: 
  306: 
  307: @pytest.mark.parametrize(
  308:     "data",
  309:     [
  310:         "b\nTrue\nFalse\nNA\nFalse",
  311:         "b\ntrue\nfalse\nNA\nfalse",
  312:         "b\nTRUE\nFALSE\nNA\nFALSE",
  313:         "b\nTrue\nFalse\nNA\nFALSE",
  314:     ],
  315: )
  316: def test_categorical_dtype_coerces_boolean(all_parsers, data):
  317:     # see gh-20498
  318:     parser = all_parsers
  319:     dtype = {"b": CategoricalDtype([False, True])}
  320:     expected = DataFrame({"b": Categorical([True, False, None, False])})
  321: 
  322:     result = parser.read_csv(StringIO(data), dtype=dtype)
  323:     tm.assert_frame_equal(result, expected)
  324: 
  325: 
  326: def test_categorical_unexpected_categories(all_parsers):
  327:     parser = all_parsers
  328:     dtype = {"b": CategoricalDtype(["a", "b", "d", "e"])}
  329: 
  330:     data = "b\nd\na\nc\nd"  # Unexpected c
  331:     expected = DataFrame({"b": Categorical(list("dacd"), dtype=dtype["b"])})
  332: 
  333:     result = parser.read_csv(StringIO(data), dtype=dtype)
  334:     tm.assert_frame_equal(result, expected)
