    1: from datetime import (
    2:     date,
    3:     datetime,
    4:     timedelta,
    5: )
    6: from functools import partial
    7: from io import BytesIO
    8: import os
    9: import re
   10: 
   11: import numpy as np
   12: import pytest
   13: 
   14: from pandas.compat import is_platform_windows
   15: from pandas.compat._constants import PY310
   16: from pandas.compat._optional import import_optional_dependency
   17: import pandas.util._test_decorators as td
   18: 
   19: import pandas as pd
   20: from pandas import (
   21:     DataFrame,
   22:     Index,
   23:     MultiIndex,
   24:     date_range,
   25:     option_context,
   26: )
   27: import pandas._testing as tm
   28: 
   29: from pandas.io.excel import (
   30:     ExcelFile,
   31:     ExcelWriter,
   32:     _OpenpyxlWriter,
   33:     _XlsxWriter,
   34:     register_writer,
   35: )
   36: from pandas.io.excel._util import _writers
   37: 
   38: if is_platform_windows():
   39:     pytestmark = pytest.mark.single_cpu
   40: 
   41: 
   42: def get_exp_unit(path: str) -> str:
   43:     return "ns"
   44: 
   45: 
   46: @pytest.fixture
   47: def frame(float_frame):
   48:     """
   49:     Returns the first ten items in fixture "float_frame".
   50:     """
   51:     return float_frame[:10]
   52: 
   53: 
   54: @pytest.fixture(params=[True, False])
   55: def merge_cells(request):
   56:     return request.param
   57: 
   58: 
   59: @pytest.fixture
   60: def path(ext):
   61:     """
   62:     Fixture to open file for use in each test case.
   63:     """
   64:     with tm.ensure_clean(ext) as file_path:
   65:         yield file_path
   66: 
   67: 
   68: @pytest.fixture
   69: def set_engine(engine, ext):
   70:     """
   71:     Fixture to set engine for use in each test case.
   72: 
   73:     Rather than requiring `engine=...` to be provided explicitly as an
   74:     argument in each test, this fixture sets a global option to dictate
   75:     which engine should be used to write Excel files. After executing
   76:     the test it rolls back said change to the global option.
   77:     """
   78:     option_name = f"io.excel.{ext.strip('.')}.writer"
   79:     with option_context(option_name, engine):
   80:         yield
   81: 
   82: 
   83: @pytest.mark.parametrize(
   84:     "ext",
   85:     [
   86:         pytest.param(".xlsx", marks=[td.skip_if_no("openpyxl"), td.skip_if_no("xlrd")]),
   87:         pytest.param(".xlsm", marks=[td.skip_if_no("openpyxl"), td.skip_if_no("xlrd")]),
   88:         pytest.param(
   89:             ".xlsx", marks=[td.skip_if_no("xlsxwriter"), td.skip_if_no("xlrd")]
   90:         ),
   91:         pytest.param(".ods", marks=td.skip_if_no("odf")),
   92:     ],
   93: )
   94: class TestRoundTrip:
   95:     @pytest.mark.parametrize(
   96:         "header,expected",
   97:         [(None, DataFrame([np.nan] * 4)), (0, DataFrame({"Unnamed: 0": [np.nan] * 3}))],
   98:     )
   99:     def test_read_one_empty_col_no_header(self, ext, header, expected):
  100:         # xref gh-12292
  101:         filename = "no_header"
  102:         df = DataFrame([["", 1, 100], ["", 2, 200], ["", 3, 300], ["", 4, 400]])
  103: 
  104:         with tm.ensure_clean(ext) as path:
  105:             df.to_excel(path, sheet_name=filename, index=False, header=False)
  106:             result = pd.read_excel(
  107:                 path, sheet_name=filename, usecols=[0], header=header
  108:             )
  109: 
  110:         tm.assert_frame_equal(result, expected)
  111: 
  112:     @pytest.mark.parametrize(
  113:         "header,expected",
  114:         [(None, DataFrame([0] + [np.nan] * 4)), (0, DataFrame([np.nan] * 4))],
  115:     )
  116:     def test_read_one_empty_col_with_header(self, ext, header, expected):
  117:         filename = "with_header"
  118:         df = DataFrame([["", 1, 100], ["", 2, 200], ["", 3, 300], ["", 4, 400]])
  119: 
  120:         with tm.ensure_clean(ext) as path:
  121:             df.to_excel(path, sheet_name="with_header", index=False, header=True)
  122:             result = pd.read_excel(
  123:                 path, sheet_name=filename, usecols=[0], header=header
  124:             )
  125: 
  126:         tm.assert_frame_equal(result, expected)
  127: 
  128:     def test_set_column_names_in_parameter(self, ext):
  129:         # GH 12870 : pass down column names associated with
  130:         # keyword argument names
  131:         refdf = DataFrame([[1, "foo"], [2, "bar"], [3, "baz"]], columns=["a", "b"])
  132: 
  133:         with tm.ensure_clean(ext) as pth:
  134:             with ExcelWriter(pth) as writer:
  135:                 refdf.to_excel(
  136:                     writer, sheet_name="Data_no_head", header=False, index=False
  137:                 )
  138:                 refdf.to_excel(writer, sheet_name="Data_with_head", index=False)
  139: 
  140:             refdf.columns = ["A", "B"]
  141: 
  142:             with ExcelFile(pth) as reader:
  143:                 xlsdf_no_head = pd.read_excel(
  144:                     reader, sheet_name="Data_no_head", header=None, names=["A", "B"]
  145:                 )
  146:                 xlsdf_with_head = pd.read_excel(
  147:                     reader,
  148:                     sheet_name="Data_with_head",
  149:                     index_col=None,
  150:                     names=["A", "B"],
  151:                 )
  152: 
  153:             tm.assert_frame_equal(xlsdf_no_head, refdf)
  154:             tm.assert_frame_equal(xlsdf_with_head, refdf)
  155: 
  156:     def test_creating_and_reading_multiple_sheets(self, ext):
  157:         # see gh-9450
  158:         #
  159:         # Test reading multiple sheets, from a runtime
  160:         # created Excel file with multiple sheets.
  161:         def tdf(col_sheet_name):
  162:             d, i = [11, 22, 33], [1, 2, 3]
  163:             return DataFrame(d, i, columns=[col_sheet_name])
  164: 
  165:         sheets = ["AAA", "BBB", "CCC"]
  166: 
  167:         dfs = [tdf(s) for s in sheets]
  168:         dfs = dict(zip(sheets, dfs))
  169: 
  170:         with tm.ensure_clean(ext) as pth:
  171:             with ExcelWriter(pth) as ew:
  172:                 for sheetname, df in dfs.items():
  173:                     df.to_excel(ew, sheet_name=sheetname)
  174: 
  175:             dfs_returned = pd.read_excel(pth, sheet_name=sheets, index_col=0)
  176: 
  177:             for s in sheets:
  178:                 tm.assert_frame_equal(dfs[s], dfs_returned[s])
  179: 
  180:     def test_read_excel_multiindex_empty_level(self, ext):
  181:         # see gh-12453
  182:         with tm.ensure_clean(ext) as path:
  183:             df = DataFrame(
  184:                 {
  185:                     ("One", "x"): {0: 1},
  186:                     ("Two", "X"): {0: 3},
  187:                     ("Two", "Y"): {0: 7},
  188:                     ("Zero", ""): {0: 0},
  189:                 }
  190:             )
  191: 
  192:             expected = DataFrame(
  193:                 {
  194:                     ("One", "x"): {0: 1},
  195:                     ("Two", "X"): {0: 3},
  196:                     ("Two", "Y"): {0: 7},
  197:                     ("Zero", "Unnamed: 4_level_1"): {0: 0},
  198:                 }
  199:             )
  200: 
  201:             df.to_excel(path)
  202:             actual = pd.read_excel(path, header=[0, 1], index_col=0)
  203:             tm.assert_frame_equal(actual, expected)
  204: 
  205:             df = DataFrame(
  206:                 {
  207:                     ("Beg", ""): {0: 0},
  208:                     ("Middle", "x"): {0: 1},
  209:                     ("Tail", "X"): {0: 3},
  210:                     ("Tail", "Y"): {0: 7},
  211:                 }
  212:             )
  213: 
  214:             expected = DataFrame(
  215:                 {
  216:                     ("Beg", "Unnamed: 1_level_1"): {0: 0},
  217:                     ("Middle", "x"): {0: 1},
  218:                     ("Tail", "X"): {0: 3},
  219:                     ("Tail", "Y"): {0: 7},
  220:                 }
  221:             )
  222: 
  223:             df.to_excel(path)
  224:             actual = pd.read_excel(path, header=[0, 1], index_col=0)
  225:             tm.assert_frame_equal(actual, expected)
  226: 
  227:     @pytest.mark.parametrize("c_idx_names", ["a", None])
  228:     @pytest.mark.parametrize("r_idx_names", ["b", None])
  229:     @pytest.mark.parametrize("c_idx_levels", [1, 3])
  230:     @pytest.mark.parametrize("r_idx_levels", [1, 3])
  231:     def test_excel_multindex_roundtrip(
  232:         self, ext, c_idx_names, r_idx_names, c_idx_levels, r_idx_levels, request
  233:     ):
  234:         # see gh-4679
  235:         with tm.ensure_clean(ext) as pth:
  236:             # Empty name case current read in as
  237:             # unnamed levels, not Nones.
  238:             check_names = bool(r_idx_names) or r_idx_levels <= 1
  239: 
  240:             if c_idx_levels == 1:
  241:                 columns = Index(list("abcde"))
  242:             else:
  243:                 columns = MultiIndex.from_arrays(
  244:                     [range(5) for _ in range(c_idx_levels)],
  245:                     names=[f"{c_idx_names}-{i}" for i in range(c_idx_levels)],
  246:                 )
  247:             if r_idx_levels == 1:
  248:                 index = Index(list("ghijk"))
  249:             else:
  250:                 index = MultiIndex.from_arrays(
  251:                     [range(5) for _ in range(r_idx_levels)],
  252:                     names=[f"{r_idx_names}-{i}" for i in range(r_idx_levels)],
  253:                 )
  254:             df = DataFrame(
  255:                 1.1 * np.ones((5, 5)),
  256:                 columns=columns,
  257:                 index=index,
  258:             )
  259:             df.to_excel(pth)
  260: 
  261:             act = pd.read_excel(
  262:                 pth,
  263:                 index_col=list(range(r_idx_levels)),
  264:                 header=list(range(c_idx_levels)),
  265:             )
  266:             tm.assert_frame_equal(df, act, check_names=check_names)
  267: 
  268:             df.iloc[0, :] = np.nan
  269:             df.to_excel(pth)
  270: 
  271:             act = pd.read_excel(
  272:                 pth,
  273:                 index_col=list(range(r_idx_levels)),
  274:                 header=list(range(c_idx_levels)),
  275:             )
  276:             tm.assert_frame_equal(df, act, check_names=check_names)
  277: 
  278:             df.iloc[-1, :] = np.nan
  279:             df.to_excel(pth)
  280:             act = pd.read_excel(
  281:                 pth,
  282:                 index_col=list(range(r_idx_levels)),
  283:                 header=list(range(c_idx_levels)),
  284:             )
  285:             tm.assert_frame_equal(df, act, check_names=check_names)
  286: 
  287:     def test_read_excel_parse_dates(self, ext):
  288:         # see gh-11544, gh-12051
  289:         df = DataFrame(
  290:             {"col": [1, 2, 3], "date_strings": date_range("2012-01-01", periods=3)}
  291:         )
  292:         df2 = df.copy()
  293:         df2["date_strings"] = df2["date_strings"].dt.strftime("%m/%d/%Y")
  294: 
  295:         with tm.ensure_clean(ext) as pth:
  296:             df2.to_excel(pth)
  297: 
  298:             res = pd.read_excel(pth, index_col=0)
  299:             tm.assert_frame_equal(df2, res)
  300: 
  301:             res = pd.read_excel(pth, parse_dates=["date_strings"], index_col=0)
  302:             tm.assert_frame_equal(df, res)
  303: 
  304:             date_parser = lambda x: datetime.strptime(x, "%m/%d/%Y")
  305:             with tm.assert_produces_warning(
  306:                 FutureWarning,
  307:                 match="use 'date_format' instead",
  308:                 raise_on_extra_warnings=False,
  309:             ):
  310:                 res = pd.read_excel(
  311:                     pth,
  312:                     parse_dates=["date_strings"],
  313:                     date_parser=date_parser,
  314:                     index_col=0,
  315:                 )
  316:             tm.assert_frame_equal(df, res)
  317:             res = pd.read_excel(
  318:                 pth, parse_dates=["date_strings"], date_format="%m/%d/%Y", index_col=0
  319:             )
  320:             tm.assert_frame_equal(df, res)
  321: 
  322:     def test_multiindex_interval_datetimes(self, ext):
  323:         # GH 30986
  324:         midx = MultiIndex.from_arrays(
  325:             [
  326:                 range(4),
  327:                 pd.interval_range(
  328:                     start=pd.Timestamp("2020-01-01"), periods=4, freq="6ME"
  329:                 ),
  330:             ]
  331:         )
  332:         df = DataFrame(range(4), index=midx)
  333:         with tm.ensure_clean(ext) as pth:
  334:             df.to_excel(pth)
  335:             result = pd.read_excel(pth, index_col=[0, 1])
  336:         expected = DataFrame(
  337:             range(4),
  338:             MultiIndex.from_arrays(
  339:                 [
  340:                     range(4),
  341:                     [
  342:                         "(2020-01-31 00:00:00, 2020-07-31 00:00:00]",
  343:                         "(2020-07-31 00:00:00, 2021-01-31 00:00:00]",
  344:                         "(2021-01-31 00:00:00, 2021-07-31 00:00:00]",
  345:                         "(2021-07-31 00:00:00, 2022-01-31 00:00:00]",
  346:                     ],
  347:                 ]
  348:             ),
  349:         )
  350:         tm.assert_frame_equal(result, expected)
  351: 
  352: 
  353: @pytest.mark.parametrize(
  354:     "engine,ext",
  355:     [
  356:         pytest.param(
  357:             "openpyxl",
  358:             ".xlsx",
  359:             marks=[td.skip_if_no("openpyxl"), td.skip_if_no("xlrd")],
  360:         ),
  361:         pytest.param(
  362:             "openpyxl",
  363:             ".xlsm",
  364:             marks=[td.skip_if_no("openpyxl"), td.skip_if_no("xlrd")],
  365:         ),
  366:         pytest.param(
  367:             "xlsxwriter",
  368:             ".xlsx",
  369:             marks=[td.skip_if_no("xlsxwriter"), td.skip_if_no("xlrd")],
  370:         ),
  371:         pytest.param("odf", ".ods", marks=td.skip_if_no("odf")),
  372:     ],
  373: )
  374: @pytest.mark.usefixtures("set_engine")
  375: class TestExcelWriter:
  376:     def test_excel_sheet_size(self, path):
  377:         # GH 26080
  378:         breaking_row_count = 2**20 + 1
  379:         breaking_col_count = 2**14 + 1
  380:         # purposely using two arrays to prevent memory issues while testing
  381:         row_arr = np.zeros(shape=(breaking_row_count, 1))
  382:         col_arr = np.zeros(shape=(1, breaking_col_count))
  383:         row_df = DataFrame(row_arr)
  384:         col_df = DataFrame(col_arr)
  385: 
  386:         msg = "sheet is too large"
  387:         with pytest.raises(ValueError, match=msg):
  388:             row_df.to_excel(path)
  389: 
  390:         with pytest.raises(ValueError, match=msg):
  391:             col_df.to_excel(path)
  392: 
  393:     def test_excel_sheet_by_name_raise(self, path):
  394:         gt = DataFrame(np.random.default_rng(2).standard_normal((10, 2)))
  395:         gt.to_excel(path)
  396: 
  397:         with ExcelFile(path) as xl:
  398:             df = pd.read_excel(xl, sheet_name=0, index_col=0)
  399: 
  400:         tm.assert_frame_equal(gt, df)
  401: 
  402:         msg = "Worksheet named '0' not found"
  403:         with pytest.raises(ValueError, match=msg):
  404:             pd.read_excel(xl, "0")
  405: 
  406:     def test_excel_writer_context_manager(self, frame, path):
  407:         with ExcelWriter(path) as writer:
  408:             frame.to_excel(writer, sheet_name="Data1")
  409:             frame2 = frame.copy()
  410:             frame2.columns = frame.columns[::-1]
  411:             frame2.to_excel(writer, sheet_name="Data2")
  412: 
  413:         with ExcelFile(path) as reader:
  414:             found_df = pd.read_excel(reader, sheet_name="Data1", index_col=0)
  415:             found_df2 = pd.read_excel(reader, sheet_name="Data2", index_col=0)
  416: 
  417:             tm.assert_frame_equal(found_df, frame)
  418:             tm.assert_frame_equal(found_df2, frame2)
  419: 
  420:     def test_roundtrip(self, frame, path):
  421:         frame = frame.copy()
  422:         frame.iloc[:5, frame.columns.get_loc("A")] = np.nan
  423: 
  424:         frame.to_excel(path, sheet_name="test1")
  425:         frame.to_excel(path, sheet_name="test1", columns=["A", "B"])
  426:         frame.to_excel(path, sheet_name="test1", header=False)
  427:         frame.to_excel(path, sheet_name="test1", index=False)
  428: 
  429:         # test roundtrip
  430:         frame.to_excel(path, sheet_name="test1")
  431:         recons = pd.read_excel(path, sheet_name="test1", index_col=0)
  432:         tm.assert_frame_equal(frame, recons)
  433: 
  434:         frame.to_excel(path, sheet_name="test1", index=False)
  435:         recons = pd.read_excel(path, sheet_name="test1", index_col=None)
  436:         recons.index = frame.index
  437:         tm.assert_frame_equal(frame, recons)
  438: 
  439:         frame.to_excel(path, sheet_name="test1", na_rep="NA")
  440:         recons = pd.read_excel(path, sheet_name="test1", index_col=0, na_values=["NA"])
  441:         tm.assert_frame_equal(frame, recons)
  442: 
  443:         # GH 3611
  444:         frame.to_excel(path, sheet_name="test1", na_rep="88")
  445:         recons = pd.read_excel(path, sheet_name="test1", index_col=0, na_values=["88"])
  446:         tm.assert_frame_equal(frame, recons)
  447: 
  448:         frame.to_excel(path, sheet_name="test1", na_rep="88")
  449:         recons = pd.read_excel(
  450:             path, sheet_name="test1", index_col=0, na_values=[88, 88.0]
  451:         )
  452:         tm.assert_frame_equal(frame, recons)
  453: 
  454:         # GH 6573
  455:         frame.to_excel(path, sheet_name="Sheet1")
  456:         recons = pd.read_excel(path, index_col=0)
  457:         tm.assert_frame_equal(frame, recons)
  458: 
  459:         frame.to_excel(path, sheet_name="0")
  460:         recons = pd.read_excel(path, index_col=0)
  461:         tm.assert_frame_equal(frame, recons)
  462: 
  463:         # GH 8825 Pandas Series should provide to_excel method
  464:         s = frame["A"]
  465:         s.to_excel(path)
  466:         recons = pd.read_excel(path, index_col=0)
  467:         tm.assert_frame_equal(s.to_frame(), recons)
  468: 
  469:     def test_mixed(self, frame, path):
  470:         mixed_frame = frame.copy()
  471:         mixed_frame["foo"] = "bar"
  472: 
  473:         mixed_frame.to_excel(path, sheet_name="test1")
  474:         with ExcelFile(path) as reader:
  475:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0)
  476:         tm.assert_frame_equal(mixed_frame, recons)
  477: 
  478:     def test_ts_frame(self, path):
  479:         unit = get_exp_unit(path)
  480:         df = DataFrame(
  481:             np.random.default_rng(2).standard_normal((5, 4)),
  482:             columns=Index(list("ABCD")),
  483:             index=date_range("2000-01-01", periods=5, freq="B"),
  484:         )
  485: 
  486:         # freq doesn't round-trip
  487:         index = pd.DatetimeIndex(np.asarray(df.index), freq=None)
  488:         df.index = index
  489: 
  490:         expected = df[:]
  491:         expected.index = expected.index.as_unit(unit)
  492: 
  493:         df.to_excel(path, sheet_name="test1")
  494:         with ExcelFile(path) as reader:
  495:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0)
  496:         tm.assert_frame_equal(expected, recons)
  497: 
  498:     def test_basics_with_nan(self, frame, path):
  499:         frame = frame.copy()
  500:         frame.iloc[:5, frame.columns.get_loc("A")] = np.nan
  501:         frame.to_excel(path, sheet_name="test1")
  502:         frame.to_excel(path, sheet_name="test1", columns=["A", "B"])
  503:         frame.to_excel(path, sheet_name="test1", header=False)
  504:         frame.to_excel(path, sheet_name="test1", index=False)
  505: 
  506:     @pytest.mark.parametrize("np_type", [np.int8, np.int16, np.int32, np.int64])
  507:     def test_int_types(self, np_type, path):
  508:         # Test np.int values read come back as int
  509:         # (rather than float which is Excel's format).
  510:         df = DataFrame(
  511:             np.random.default_rng(2).integers(-10, 10, size=(10, 2)), dtype=np_type
  512:         )
  513:         df.to_excel(path, sheet_name="test1")
  514: 
  515:         with ExcelFile(path) as reader:
  516:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0)
  517: 
  518:         int_frame = df.astype(np.int64)
  519:         tm.assert_frame_equal(int_frame, recons)
  520: 
  521:         recons2 = pd.read_excel(path, sheet_name="test1", index_col=0)
  522:         tm.assert_frame_equal(int_frame, recons2)
  523: 
  524:     @pytest.mark.parametrize("np_type", [np.float16, np.float32, np.float64])
  525:     def test_float_types(self, np_type, path):
  526:         # Test np.float values read come back as float.
  527:         df = DataFrame(np.random.default_rng(2).random(10), dtype=np_type)
  528:         df.to_excel(path, sheet_name="test1")
  529: 
  530:         with ExcelFile(path) as reader:
  531:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0).astype(
  532:                 np_type
  533:             )
  534: 
  535:         tm.assert_frame_equal(df, recons)
  536: 
  537:     def test_bool_types(self, path):
  538:         # Test np.bool_ values read come back as float.
  539:         df = DataFrame([1, 0, True, False], dtype=np.bool_)
  540:         df.to_excel(path, sheet_name="test1")
  541: 
  542:         with ExcelFile(path) as reader:
  543:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0).astype(
  544:                 np.bool_
  545:             )
  546: 
  547:         tm.assert_frame_equal(df, recons)
  548: 
  549:     def test_inf_roundtrip(self, path):
  550:         df = DataFrame([(1, np.inf), (2, 3), (5, -np.inf)])
  551:         df.to_excel(path, sheet_name="test1")
  552: 
  553:         with ExcelFile(path) as reader:
  554:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0)
  555: 
  556:         tm.assert_frame_equal(df, recons)
  557: 
  558:     def test_sheets(self, frame, path):
  559:         # freq doesn't round-trip
  560:         unit = get_exp_unit(path)
  561:         tsframe = DataFrame(
  562:             np.random.default_rng(2).standard_normal((5, 4)),
  563:             columns=Index(list("ABCD")),
  564:             index=date_range("2000-01-01", periods=5, freq="B"),
  565:         )
  566:         index = pd.DatetimeIndex(np.asarray(tsframe.index), freq=None)
  567:         tsframe.index = index
  568: 
  569:         expected = tsframe[:]
  570:         expected.index = expected.index.as_unit(unit)
  571: 
  572:         frame = frame.copy()
  573:         frame.iloc[:5, frame.columns.get_loc("A")] = np.nan
  574: 
  575:         frame.to_excel(path, sheet_name="test1")
  576:         frame.to_excel(path, sheet_name="test1", columns=["A", "B"])
  577:         frame.to_excel(path, sheet_name="test1", header=False)
  578:         frame.to_excel(path, sheet_name="test1", index=False)
  579: 
  580:         # Test writing to separate sheets
  581:         with ExcelWriter(path) as writer:
  582:             frame.to_excel(writer, sheet_name="test1")
  583:             tsframe.to_excel(writer, sheet_name="test2")
  584:         with ExcelFile(path) as reader:
  585:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0)
  586:             tm.assert_frame_equal(frame, recons)
  587:             recons = pd.read_excel(reader, sheet_name="test2", index_col=0)
  588:         tm.assert_frame_equal(expected, recons)
  589:         assert 2 == len(reader.sheet_names)
  590:         assert "test1" == reader.sheet_names[0]
  591:         assert "test2" == reader.sheet_names[1]
  592: 
  593:     def test_colaliases(self, frame, path):
  594:         frame = frame.copy()
  595:         frame.iloc[:5, frame.columns.get_loc("A")] = np.nan
  596: 
  597:         frame.to_excel(path, sheet_name="test1")
  598:         frame.to_excel(path, sheet_name="test1", columns=["A", "B"])
  599:         frame.to_excel(path, sheet_name="test1", header=False)
  600:         frame.to_excel(path, sheet_name="test1", index=False)
  601: 
  602:         # column aliases
  603:         col_aliases = Index(["AA", "X", "Y", "Z"])
  604:         frame.to_excel(path, sheet_name="test1", header=col_aliases)
  605:         with ExcelFile(path) as reader:
  606:             rs = pd.read_excel(reader, sheet_name="test1", index_col=0)
  607:         xp = frame.copy()
  608:         xp.columns = col_aliases
  609:         tm.assert_frame_equal(xp, rs)
  610: 
  611:     def test_roundtrip_indexlabels(self, merge_cells, frame, path):
  612:         frame = frame.copy()
  613:         frame.iloc[:5, frame.columns.get_loc("A")] = np.nan
  614: 
  615:         frame.to_excel(path, sheet_name="test1")
  616:         frame.to_excel(path, sheet_name="test1", columns=["A", "B"])
  617:         frame.to_excel(path, sheet_name="test1", header=False)
  618:         frame.to_excel(path, sheet_name="test1", index=False)
  619: 
  620:         # test index_label
  621:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2))) >= 0
  622:         df.to_excel(
  623:             path, sheet_name="test1", index_label=["test"], merge_cells=merge_cells
  624:         )
  625:         with ExcelFile(path) as reader:
  626:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0).astype(
  627:                 np.int64
  628:             )
  629:         df.index.names = ["test"]
  630:         assert df.index.names == recons.index.names
  631: 
  632:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2))) >= 0
  633:         df.to_excel(
  634:             path,
  635:             sheet_name="test1",
  636:             index_label=["test", "dummy", "dummy2"],
  637:             merge_cells=merge_cells,
  638:         )
  639:         with ExcelFile(path) as reader:
  640:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0).astype(
  641:                 np.int64
  642:             )
  643:         df.index.names = ["test"]
  644:         assert df.index.names == recons.index.names
  645: 
  646:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2))) >= 0
  647:         df.to_excel(
  648:             path, sheet_name="test1", index_label="test", merge_cells=merge_cells
  649:         )
  650:         with ExcelFile(path) as reader:
  651:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0).astype(
  652:                 np.int64
  653:             )
  654:         df.index.names = ["test"]
  655:         tm.assert_frame_equal(df, recons.astype(bool))
  656: 
  657:         frame.to_excel(
  658:             path,
  659:             sheet_name="test1",
  660:             columns=["A", "B", "C", "D"],
  661:             index=False,
  662:             merge_cells=merge_cells,
  663:         )
  664:         # take 'A' and 'B' as indexes (same row as cols 'C', 'D')
  665:         df = frame.copy()
  666:         df = df.set_index(["A", "B"])
  667: 
  668:         with ExcelFile(path) as reader:
  669:             recons = pd.read_excel(reader, sheet_name="test1", index_col=[0, 1])
  670:         tm.assert_frame_equal(df, recons)
  671: 
  672:     def test_excel_roundtrip_indexname(self, merge_cells, path):
  673:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))
  674:         df.index.name = "foo"
  675: 
  676:         df.to_excel(path, merge_cells=merge_cells)
  677: 
  678:         with ExcelFile(path) as xf:
  679:             result = pd.read_excel(xf, sheet_name=xf.sheet_names[0], index_col=0)
  680: 
  681:         tm.assert_frame_equal(result, df)
  682:         assert result.index.name == "foo"
  683: 
  684:     def test_excel_roundtrip_datetime(self, merge_cells, path):
  685:         # datetime.date, not sure what to test here exactly
  686:         unit = get_exp_unit(path)
  687: 
  688:         # freq does not round-trip
  689:         tsframe = DataFrame(
  690:             np.random.default_rng(2).standard_normal((5, 4)),
  691:             columns=Index(list("ABCD")),
  692:             index=date_range("2000-01-01", periods=5, freq="B"),
  693:         )
  694:         index = pd.DatetimeIndex(np.asarray(tsframe.index), freq=None)
  695:         tsframe.index = index
  696: 
  697:         tsf = tsframe.copy()
  698: 
  699:         tsf.index = [x.date() for x in tsframe.index]
  700:         tsf.to_excel(path, sheet_name="test1", merge_cells=merge_cells)
  701: 
  702:         with ExcelFile(path) as reader:
  703:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0)
  704: 
  705:         expected = tsframe[:]
  706:         expected.index = expected.index.as_unit(unit)
  707:         tm.assert_frame_equal(expected, recons)
  708: 
  709:     def test_excel_date_datetime_format(self, ext, path):
  710:         # see gh-4133
  711:         #
  712:         # Excel output format strings
  713:         unit = get_exp_unit(path)
  714: 
  715:         df = DataFrame(
  716:             [
  717:                 [date(2014, 1, 31), date(1999, 9, 24)],
  718:                 [datetime(1998, 5, 26, 23, 33, 4), datetime(2014, 2, 28, 13, 5, 13)],
  719:             ],
  720:             index=["DATE", "DATETIME"],
  721:             columns=["X", "Y"],
  722:         )
  723:         df_expected = DataFrame(
  724:             [
  725:                 [datetime(2014, 1, 31), datetime(1999, 9, 24)],
  726:                 [datetime(1998, 5, 26, 23, 33, 4), datetime(2014, 2, 28, 13, 5, 13)],
  727:             ],
  728:             index=["DATE", "DATETIME"],
  729:             columns=["X", "Y"],
  730:         )
  731:         df_expected = df_expected.astype(f"M8[{unit}]")
  732: 
  733:         with tm.ensure_clean(ext) as filename2:
  734:             with ExcelWriter(path) as writer1:
  735:                 df.to_excel(writer1, sheet_name="test1")
  736: 
  737:             with ExcelWriter(
  738:                 filename2,
  739:                 date_format="DD.MM.YYYY",
  740:                 datetime_format="DD.MM.YYYY HH-MM-SS",
  741:             ) as writer2:
  742:                 df.to_excel(writer2, sheet_name="test1")
  743: 
  744:             with ExcelFile(path) as reader1:
  745:                 rs1 = pd.read_excel(reader1, sheet_name="test1", index_col=0)
  746: 
  747:             with ExcelFile(filename2) as reader2:
  748:                 rs2 = pd.read_excel(reader2, sheet_name="test1", index_col=0)
  749: 
  750:         tm.assert_frame_equal(rs1, rs2)
  751: 
  752:         # Since the reader returns a datetime object for dates,
  753:         # we need to use df_expected to check the result.
  754:         tm.assert_frame_equal(rs2, df_expected)
  755: 
  756:     def test_to_excel_interval_no_labels(self, path, using_infer_string):
  757:         # see gh-19242
  758:         #
  759:         # Test writing Interval without labels.
  760:         df = DataFrame(
  761:             np.random.default_rng(2).integers(-10, 10, size=(20, 1)), dtype=np.int64
  762:         )
  763:         expected = df.copy()
  764: 
  765:         df["new"] = pd.cut(df[0], 10)
  766:         expected["new"] = pd.cut(expected[0], 10).astype(
  767:             str if not using_infer_string else "string[pyarrow_numpy]"
  768:         )
  769: 
  770:         df.to_excel(path, sheet_name="test1")
  771:         with ExcelFile(path) as reader:
  772:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0)
  773:         tm.assert_frame_equal(expected, recons)
  774: 
  775:     def test_to_excel_interval_labels(self, path):
  776:         # see gh-19242
  777:         #
  778:         # Test writing Interval with labels.
  779:         df = DataFrame(
  780:             np.random.default_rng(2).integers(-10, 10, size=(20, 1)), dtype=np.int64
  781:         )
  782:         expected = df.copy()
  783:         intervals = pd.cut(
  784:             df[0], 10, labels=["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"]
  785:         )
  786:         df["new"] = intervals
  787:         expected["new"] = pd.Series(list(intervals))
  788: 
  789:         df.to_excel(path, sheet_name="test1")
  790:         with ExcelFile(path) as reader:
  791:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0)
  792:         tm.assert_frame_equal(expected, recons)
  793: 
  794:     def test_to_excel_timedelta(self, path):
  795:         # see gh-19242, gh-9155
  796:         #
  797:         # Test writing timedelta to xls.
  798:         df = DataFrame(
  799:             np.random.default_rng(2).integers(-10, 10, size=(20, 1)),
  800:             columns=["A"],
  801:             dtype=np.int64,
  802:         )
  803:         expected = df.copy()
  804: 
  805:         df["new"] = df["A"].apply(lambda x: timedelta(seconds=x))
  806:         expected["new"] = expected["A"].apply(
  807:             lambda x: timedelta(seconds=x).total_seconds() / 86400
  808:         )
  809: 
  810:         df.to_excel(path, sheet_name="test1")
  811:         with ExcelFile(path) as reader:
  812:             recons = pd.read_excel(reader, sheet_name="test1", index_col=0)
  813:         tm.assert_frame_equal(expected, recons)
  814: 
  815:     def test_to_excel_periodindex(self, path):
  816:         # xp has a PeriodIndex
  817:         df = DataFrame(
  818:             np.random.default_rng(2).standard_normal((5, 4)),
  819:             columns=Index(list("ABCD")),
  820:             index=date_range("2000-01-01", periods=5, freq="B"),
  821:         )
  822:         xp = df.resample("ME").mean().to_period("M")
  823: 
  824:         xp.to_excel(path, sheet_name="sht1")
  825: 
  826:         with ExcelFile(path) as reader:
  827:             rs = pd.read_excel(reader, sheet_name="sht1", index_col=0)
  828:         tm.assert_frame_equal(xp, rs.to_period("M"))
  829: 
  830:     def test_to_excel_multiindex(self, merge_cells, frame, path):
  831:         arrays = np.arange(len(frame.index) * 2, dtype=np.int64).reshape(2, -1)
  832:         new_index = MultiIndex.from_arrays(arrays, names=["first", "second"])
  833:         frame.index = new_index
  834: 
  835:         frame.to_excel(path, sheet_name="test1", header=False)
  836:         frame.to_excel(path, sheet_name="test1", columns=["A", "B"])
  837: 
  838:         # round trip
  839:         frame.to_excel(path, sheet_name="test1", merge_cells=merge_cells)
  840:         with ExcelFile(path) as reader:
  841:             df = pd.read_excel(reader, sheet_name="test1", index_col=[0, 1])
  842:         tm.assert_frame_equal(frame, df)
  843: 
  844:     # GH13511
  845:     def test_to_excel_multiindex_nan_label(self, merge_cells, path):
  846:         df = DataFrame(
  847:             {
  848:                 "A": [None, 2, 3],
  849:                 "B": [10, 20, 30],
  850:                 "C": np.random.default_rng(2).random(3),
  851:             }
  852:         )
  853:         df = df.set_index(["A", "B"])
  854: 
  855:         df.to_excel(path, merge_cells=merge_cells)
  856:         df1 = pd.read_excel(path, index_col=[0, 1])
  857:         tm.assert_frame_equal(df, df1)
  858: 
  859:     # Test for Issue 11328. If column indices are integers, make
  860:     # sure they are handled correctly for either setting of
  861:     # merge_cells
  862:     def test_to_excel_multiindex_cols(self, merge_cells, frame, path):
  863:         arrays = np.arange(len(frame.index) * 2, dtype=np.int64).reshape(2, -1)
  864:         new_index = MultiIndex.from_arrays(arrays, names=["first", "second"])
  865:         frame.index = new_index
  866: 
  867:         new_cols_index = MultiIndex.from_tuples([(40, 1), (40, 2), (50, 1), (50, 2)])
  868:         frame.columns = new_cols_index
  869:         header = [0, 1]
  870:         if not merge_cells:
  871:             header = 0
  872: 
  873:         # round trip
  874:         frame.to_excel(path, sheet_name="test1", merge_cells=merge_cells)
  875:         with ExcelFile(path) as reader:
  876:             df = pd.read_excel(
  877:                 reader, sheet_name="test1", header=header, index_col=[0, 1]
  878:             )
  879:         if not merge_cells:
  880:             fm = frame.columns._format_multi(sparsify=False, include_names=False)
  881:             frame.columns = [".".join(map(str, q)) for q in zip(*fm)]
  882:         tm.assert_frame_equal(frame, df)
  883: 
  884:     def test_to_excel_multiindex_dates(self, merge_cells, path):
  885:         # try multiindex with dates
  886:         unit = get_exp_unit(path)
  887:         tsframe = DataFrame(
  888:             np.random.default_rng(2).standard_normal((5, 4)),
  889:             columns=Index(list("ABCD")),
  890:             index=date_range("2000-01-01", periods=5, freq="B"),
  891:         )
  892:         tsframe.index = MultiIndex.from_arrays(
  893:             [
  894:                 tsframe.index.as_unit(unit),
  895:                 np.arange(len(tsframe.index), dtype=np.int64),
  896:             ],
  897:             names=["time", "foo"],
  898:         )
  899: 
  900:         tsframe.to_excel(path, sheet_name="test1", merge_cells=merge_cells)
  901:         with ExcelFile(path) as reader:
  902:             recons = pd.read_excel(reader, sheet_name="test1", index_col=[0, 1])
  903: 
  904:         tm.assert_frame_equal(tsframe, recons)
  905:         assert recons.index.names == ("time", "foo")
  906: 
  907:     def test_to_excel_multiindex_no_write_index(self, path):
  908:         # Test writing and re-reading a MI without the index. GH 5616.
  909: 
  910:         # Initial non-MI frame.
  911:         frame1 = DataFrame({"a": [10, 20], "b": [30, 40], "c": [50, 60]})
  912: 
  913:         # Add a MI.
  914:         frame2 = frame1.copy()
  915:         multi_index = MultiIndex.from_tuples([(70, 80), (90, 100)])
  916:         frame2.index = multi_index
  917: 
  918:         # Write out to Excel without the index.
  919:         frame2.to_excel(path, sheet_name="test1", index=False)
  920: 
  921:         # Read it back in.
  922:         with ExcelFile(path) as reader:
  923:             frame3 = pd.read_excel(reader, sheet_name="test1")
  924: 
  925:         # Test that it is the same as the initial frame.
  926:         tm.assert_frame_equal(frame1, frame3)
  927: 
  928:     def test_to_excel_empty_multiindex(self, path):
  929:         # GH 19543.
  930:         expected = DataFrame([], columns=[0, 1, 2])
  931: 
  932:         df = DataFrame([], index=MultiIndex.from_tuples([], names=[0, 1]), columns=[2])
  933:         df.to_excel(path, sheet_name="test1")
  934: 
  935:         with ExcelFile(path) as reader:
  936:             result = pd.read_excel(reader, sheet_name="test1")
  937:         tm.assert_frame_equal(
  938:             result, expected, check_index_type=False, check_dtype=False
  939:         )
  940: 
  941:     def test_to_excel_float_format(self, path):
  942:         df = DataFrame(
  943:             [[0.123456, 0.234567, 0.567567], [12.32112, 123123.2, 321321.2]],
  944:             index=["A", "B"],
  945:             columns=["X", "Y", "Z"],
  946:         )
  947:         df.to_excel(path, sheet_name="test1", float_format="%.2f")
  948: 
  949:         with ExcelFile(path) as reader:
  950:             result = pd.read_excel(reader, sheet_name="test1", index_col=0)
  951: 
  952:         expected = DataFrame(
  953:             [[0.12, 0.23, 0.57], [12.32, 123123.20, 321321.20]],
  954:             index=["A", "B"],
  955:             columns=["X", "Y", "Z"],
  956:         )
  957:         tm.assert_frame_equal(result, expected)
  958: 
  959:     def test_to_excel_output_encoding(self, ext):
  960:         # Avoid mixed inferred_type.
  961:         df = DataFrame(
  962:             [["\u0192", "\u0193", "\u0194"], ["\u0195", "\u0196", "\u0197"]],
  963:             index=["A\u0192", "B"],
  964:             columns=["X\u0193", "Y", "Z"],
  965:         )
  966: 
  967:         with tm.ensure_clean("__tmp_to_excel_float_format__." + ext) as filename:
  968:             df.to_excel(filename, sheet_name="TestSheet")
  969:             result = pd.read_excel(filename, sheet_name="TestSheet", index_col=0)
  970:             tm.assert_frame_equal(result, df)
  971: 
  972:     def test_to_excel_unicode_filename(self, ext):
  973:         with tm.ensure_clean("\u0192u." + ext) as filename:
  974:             try:
  975:                 with open(filename, "wb"):
  976:                     pass
  977:             except UnicodeEncodeError:
  978:                 pytest.skip("No unicode file names on this system")
  979: 
  980:             df = DataFrame(
  981:                 [[0.123456, 0.234567, 0.567567], [12.32112, 123123.2, 321321.2]],
  982:                 index=["A", "B"],
  983:                 columns=["X", "Y", "Z"],
  984:             )
  985:             df.to_excel(filename, sheet_name="test1", float_format="%.2f")
  986: 
  987:             with ExcelFile(filename) as reader:
  988:                 result = pd.read_excel(reader, sheet_name="test1", index_col=0)
  989: 
  990:         expected = DataFrame(
  991:             [[0.12, 0.23, 0.57], [12.32, 123123.20, 321321.20]],
  992:             index=["A", "B"],
  993:             columns=["X", "Y", "Z"],
  994:         )
  995:         tm.assert_frame_equal(result, expected)
  996: 
  997:     @pytest.mark.parametrize("use_headers", [True, False])
  998:     @pytest.mark.parametrize("r_idx_nlevels", [1, 2, 3])
  999:     @pytest.mark.parametrize("c_idx_nlevels", [1, 2, 3])
 1000:     def test_excel_010_hemstring(
 1001:         self, merge_cells, c_idx_nlevels, r_idx_nlevels, use_headers, path
 1002:     ):
 1003:         def roundtrip(data, header=True, parser_hdr=0, index=True):
 1004:             data.to_excel(path, header=header, merge_cells=merge_cells, index=index)
 1005: 
 1006:             with ExcelFile(path) as xf:
 1007:                 return pd.read_excel(
 1008:                     xf, sheet_name=xf.sheet_names[0], header=parser_hdr
 1009:                 )
 1010: 
 1011:         # Basic test.
 1012:         parser_header = 0 if use_headers else None
 1013:         res = roundtrip(DataFrame([0]), use_headers, parser_header)
 1014: 
 1015:         assert res.shape == (1, 2)
 1016:         assert res.iloc[0, 0] is not np.nan
 1017: 
 1018:         # More complex tests with multi-index.
 1019:         nrows = 5
 1020:         ncols = 3
 1021: 
 1022:         # ensure limited functionality in 0.10
 1023:         # override of gh-2370 until sorted out in 0.11
 1024: 
 1025:         if c_idx_nlevels == 1:
 1026:             columns = Index([f"a-{i}" for i in range(ncols)], dtype=object)
 1027:         else:
 1028:             columns = MultiIndex.from_arrays(
 1029:                 [range(ncols) for _ in range(c_idx_nlevels)],
 1030:                 names=[f"i-{i}" for i in range(c_idx_nlevels)],
 1031:             )
 1032:         if r_idx_nlevels == 1:
 1033:             index = Index([f"b-{i}" for i in range(nrows)], dtype=object)
 1034:         else:
 1035:             index = MultiIndex.from_arrays(
 1036:                 [range(nrows) for _ in range(r_idx_nlevels)],
 1037:                 names=[f"j-{i}" for i in range(r_idx_nlevels)],
 1038:             )
 1039: 
 1040:         df = DataFrame(
 1041:             np.ones((nrows, ncols)),
 1042:             columns=columns,
 1043:             index=index,
 1044:         )
 1045: 
 1046:         # This if will be removed once multi-column Excel writing
 1047:         # is implemented. For now fixing gh-9794.
 1048:         if c_idx_nlevels > 1:
 1049:             msg = (
 1050:                 "Writing to Excel with MultiIndex columns and no index "
 1051:                 "\\('index'=False\\) is not yet implemented."
 1052:             )
 1053:             with pytest.raises(NotImplementedError, match=msg):
 1054:                 roundtrip(df, use_headers, index=False)
 1055:         else:
 1056:             res = roundtrip(df, use_headers)
 1057: 
 1058:             if use_headers:
 1059:                 assert res.shape == (nrows, ncols + r_idx_nlevels)
 1060:             else:
 1061:                 # First row taken as columns.
 1062:                 assert res.shape == (nrows - 1, ncols + r_idx_nlevels)
 1063: 
 1064:             # No NaNs.
 1065:             for r in range(len(res.index)):
 1066:                 for c in range(len(res.columns)):
 1067:                     assert res.iloc[r, c] is not np.nan
 1068: 
 1069:     def test_duplicated_columns(self, path):
 1070:         # see gh-5235
 1071:         df = DataFrame([[1, 2, 3], [1, 2, 3], [1, 2, 3]], columns=["A", "B", "B"])
 1072:         df.to_excel(path, sheet_name="test1")
 1073:         expected = DataFrame(
 1074:             [[1, 2, 3], [1, 2, 3], [1, 2, 3]], columns=["A", "B", "B.1"]
 1075:         )
 1076: 
 1077:         # By default, we mangle.
 1078:         result = pd.read_excel(path, sheet_name="test1", index_col=0)
 1079:         tm.assert_frame_equal(result, expected)
 1080: 
 1081:         # see gh-11007, gh-10970
 1082:         df = DataFrame([[1, 2, 3, 4], [5, 6, 7, 8]], columns=["A", "B", "A", "B"])
 1083:         df.to_excel(path, sheet_name="test1")
 1084: 
 1085:         result = pd.read_excel(path, sheet_name="test1", index_col=0)
 1086:         expected = DataFrame(
 1087:             [[1, 2, 3, 4], [5, 6, 7, 8]], columns=["A", "B", "A.1", "B.1"]
 1088:         )
 1089:         tm.assert_frame_equal(result, expected)
 1090: 
 1091:         # see gh-10982
 1092:         df.to_excel(path, sheet_name="test1", index=False, header=False)
 1093:         result = pd.read_excel(path, sheet_name="test1", header=None)
 1094: 
 1095:         expected = DataFrame([[1, 2, 3, 4], [5, 6, 7, 8]])
 1096:         tm.assert_frame_equal(result, expected)
 1097: 
 1098:     def test_swapped_columns(self, path):
 1099:         # Test for issue #5427.
 1100:         write_frame = DataFrame({"A": [1, 1, 1], "B": [2, 2, 2]})
 1101:         write_frame.to_excel(path, sheet_name="test1", columns=["B", "A"])
 1102: 
 1103:         read_frame = pd.read_excel(path, sheet_name="test1", header=0)
 1104: 
 1105:         tm.assert_series_equal(write_frame["A"], read_frame["A"])
 1106:         tm.assert_series_equal(write_frame["B"], read_frame["B"])
 1107: 
 1108:     def test_invalid_columns(self, path):
 1109:         # see gh-10982
 1110:         write_frame = DataFrame({"A": [1, 1, 1], "B": [2, 2, 2]})
 1111: 
 1112:         with pytest.raises(KeyError, match="Not all names specified"):
 1113:             write_frame.to_excel(path, sheet_name="test1", columns=["B", "C"])
 1114: 
 1115:         with pytest.raises(
 1116:             KeyError, match="'passes columns are not ALL present dataframe'"
 1117:         ):
 1118:             write_frame.to_excel(path, sheet_name="test1", columns=["C", "D"])
 1119: 
 1120:     @pytest.mark.parametrize(
 1121:         "to_excel_index,read_excel_index_col",
 1122:         [
 1123:             (True, 0),  # Include index in write to file
 1124:             (False, None),  # Dont include index in write to file
 1125:         ],
 1126:     )
 1127:     def test_write_subset_columns(self, path, to_excel_index, read_excel_index_col):
 1128:         # GH 31677
 1129:         write_frame = DataFrame({"A": [1, 1, 1], "B": [2, 2, 2], "C": [3, 3, 3]})
 1130:         write_frame.to_excel(
 1131:             path, sheet_name="col_subset_bug", columns=["A", "B"], index=to_excel_index
 1132:         )
 1133: 
 1134:         expected = write_frame[["A", "B"]]
 1135:         read_frame = pd.read_excel(
 1136:             path, sheet_name="col_subset_bug", index_col=read_excel_index_col
 1137:         )
 1138: 
 1139:         tm.assert_frame_equal(expected, read_frame)
 1140: 
 1141:     def test_comment_arg(self, path):
 1142:         # see gh-18735
 1143:         #
 1144:         # Test the comment argument functionality to pd.read_excel.
 1145: 
 1146:         # Create file to read in.
 1147:         df = DataFrame({"A": ["one", "#one", "one"], "B": ["two", "two", "#two"]})
 1148:         df.to_excel(path, sheet_name="test_c")
 1149: 
 1150:         # Read file without comment arg.
 1151:         result1 = pd.read_excel(path, sheet_name="test_c", index_col=0)
 1152: 
 1153:         result1.iloc[1, 0] = None
 1154:         result1.iloc[1, 1] = None
 1155:         result1.iloc[2, 1] = None
 1156: 
 1157:         result2 = pd.read_excel(path, sheet_name="test_c", comment="#", index_col=0)
 1158:         tm.assert_frame_equal(result1, result2)
 1159: 
 1160:     def test_comment_default(self, path):
 1161:         # Re issue #18735
 1162:         # Test the comment argument default to pd.read_excel
 1163: 
 1164:         # Create file to read in
 1165:         df = DataFrame({"A": ["one", "#one", "one"], "B": ["two", "two", "#two"]})
 1166:         df.to_excel(path, sheet_name="test_c")
 1167: 
 1168:         # Read file with default and explicit comment=None
 1169:         result1 = pd.read_excel(path, sheet_name="test_c")
 1170:         result2 = pd.read_excel(path, sheet_name="test_c", comment=None)
 1171:         tm.assert_frame_equal(result1, result2)
 1172: 
 1173:     def test_comment_used(self, path):
 1174:         # see gh-18735
 1175:         #
 1176:         # Test the comment argument is working as expected when used.
 1177: 
 1178:         # Create file to read in.
 1179:         df = DataFrame({"A": ["one", "#one", "one"], "B": ["two", "two", "#two"]})
 1180:         df.to_excel(path, sheet_name="test_c")
 1181: 
 1182:         # Test read_frame_comment against manually produced expected output.
 1183:         expected = DataFrame({"A": ["one", None, "one"], "B": ["two", None, None]})
 1184:         result = pd.read_excel(path, sheet_name="test_c", comment="#", index_col=0)
 1185:         tm.assert_frame_equal(result, expected)
 1186: 
 1187:     def test_comment_empty_line(self, path):
 1188:         # Re issue #18735
 1189:         # Test that pd.read_excel ignores commented lines at the end of file
 1190: 
 1191:         df = DataFrame({"a": ["1", "#2"], "b": ["2", "3"]})
 1192:         df.to_excel(path, index=False)
 1193: 
 1194:         # Test that all-comment lines at EoF are ignored
 1195:         expected = DataFrame({"a": [1], "b": [2]})
 1196:         result = pd.read_excel(path, comment="#")
 1197:         tm.assert_frame_equal(result, expected)
 1198: 
 1199:     def test_datetimes(self, path):
 1200:         # Test writing and reading datetimes. For issue #9139. (xref #9185)
 1201:         unit = get_exp_unit(path)
 1202:         datetimes = [
 1203:             datetime(2013, 1, 13, 1, 2, 3),
 1204:             datetime(2013, 1, 13, 2, 45, 56),
 1205:             datetime(2013, 1, 13, 4, 29, 49),
 1206:             datetime(2013, 1, 13, 6, 13, 42),
 1207:             datetime(2013, 1, 13, 7, 57, 35),
 1208:             datetime(2013, 1, 13, 9, 41, 28),
 1209:             datetime(2013, 1, 13, 11, 25, 21),
 1210:             datetime(2013, 1, 13, 13, 9, 14),
 1211:             datetime(2013, 1, 13, 14, 53, 7),
 1212:             datetime(2013, 1, 13, 16, 37, 0),
 1213:             datetime(2013, 1, 13, 18, 20, 52),
 1214:         ]
 1215: 
 1216:         write_frame = DataFrame({"A": datetimes})
 1217:         write_frame.to_excel(path, sheet_name="Sheet1")
 1218:         read_frame = pd.read_excel(path, sheet_name="Sheet1", header=0)
 1219: 
 1220:         expected = write_frame.astype(f"M8[{unit}]")
 1221:         tm.assert_series_equal(expected["A"], read_frame["A"])
 1222: 
 1223:     def test_bytes_io(self, engine):
 1224:         # see gh-7074
 1225:         with BytesIO() as bio:
 1226:             df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)))
 1227: 
 1228:             # Pass engine explicitly, as there is no file path to infer from.
 1229:             with ExcelWriter(bio, engine=engine) as writer:
 1230:                 df.to_excel(writer)
 1231: 
 1232:             bio.seek(0)
 1233:             reread_df = pd.read_excel(bio, index_col=0)
 1234:             tm.assert_frame_equal(df, reread_df)
 1235: 
 1236:     def test_engine_kwargs(self, engine, path):
 1237:         # GH#52368
 1238:         df = DataFrame([{"A": 1, "B": 2}, {"A": 3, "B": 4}])
 1239: 
 1240:         msgs = {
 1241:             "odf": r"OpenDocumentSpreadsheet() got an unexpected keyword "
 1242:             r"argument 'foo'",
 1243:             "openpyxl": r"__init__() got an unexpected keyword argument 'foo'",
 1244:             "xlsxwriter": r"__init__() got an unexpected keyword argument 'foo'",
 1245:         }
 1246: 
 1247:         if PY310:
 1248:             msgs[
 1249:                 "openpyxl"
 1250:             ] = "Workbook.__init__() got an unexpected keyword argument 'foo'"
 1251:             msgs[
 1252:                 "xlsxwriter"
 1253:             ] = "Workbook.__init__() got an unexpected keyword argument 'foo'"
 1254: 
 1255:         # Handle change in error message for openpyxl (write and append mode)
 1256:         if engine == "openpyxl" and not os.path.exists(path):
 1257:             msgs[
 1258:                 "openpyxl"
 1259:             ] = r"load_workbook() got an unexpected keyword argument 'foo'"
 1260: 
 1261:         with pytest.raises(TypeError, match=re.escape(msgs[engine])):
 1262:             df.to_excel(
 1263:                 path,
 1264:                 engine=engine,
 1265:                 engine_kwargs={"foo": "bar"},
 1266:             )
 1267: 
 1268:     def test_write_lists_dict(self, path):
 1269:         # see gh-8188.
 1270:         df = DataFrame(
 1271:             {
 1272:                 "mixed": ["a", ["b", "c"], {"d": "e", "f": 2}],
 1273:                 "numeric": [1, 2, 3.0],
 1274:                 "str": ["apple", "banana", "cherry"],
 1275:             }
 1276:         )
 1277:         df.to_excel(path, sheet_name="Sheet1")
 1278:         read = pd.read_excel(path, sheet_name="Sheet1", header=0, index_col=0)
 1279: 
 1280:         expected = df.copy()
 1281:         expected.mixed = expected.mixed.apply(str)
 1282:         expected.numeric = expected.numeric.astype("int64")
 1283: 
 1284:         tm.assert_frame_equal(read, expected)
 1285: 
 1286:     def test_render_as_column_name(self, path):
 1287:         # see gh-34331
 1288:         df = DataFrame({"render": [1, 2], "data": [3, 4]})
 1289:         df.to_excel(path, sheet_name="Sheet1")
 1290:         read = pd.read_excel(path, "Sheet1", index_col=0)
 1291:         expected = df
 1292:         tm.assert_frame_equal(read, expected)
 1293: 
 1294:     def test_true_and_false_value_options(self, path):
 1295:         # see gh-13347
 1296:         df = DataFrame([["foo", "bar"]], columns=["col1", "col2"], dtype=object)
 1297:         with option_context("future.no_silent_downcasting", True):
 1298:             expected = df.replace({"foo": True, "bar": False}).astype("bool")
 1299: 
 1300:         df.to_excel(path)
 1301:         read_frame = pd.read_excel(
 1302:             path, true_values=["foo"], false_values=["bar"], index_col=0
 1303:         )
 1304:         tm.assert_frame_equal(read_frame, expected)
 1305: 
 1306:     def test_freeze_panes(self, path):
 1307:         # see gh-15160
 1308:         expected = DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])
 1309:         expected.to_excel(path, sheet_name="Sheet1", freeze_panes=(1, 1))
 1310: 
 1311:         result = pd.read_excel(path, index_col=0)
 1312:         tm.assert_frame_equal(result, expected)
 1313: 
 1314:     def test_path_path_lib(self, engine, ext):
 1315:         df = DataFrame(
 1316:             1.1 * np.arange(120).reshape((30, 4)),
 1317:             columns=Index(list("ABCD")),
 1318:             index=Index([f"i-{i}" for i in range(30)], dtype=object),
 1319:         )
 1320:         writer = partial(df.to_excel, engine=engine)
 1321: 
 1322:         reader = partial(pd.read_excel, index_col=0)
 1323:         result = tm.round_trip_pathlib(writer, reader, path=f"foo{ext}")
 1324:         tm.assert_frame_equal(result, df)
 1325: 
 1326:     def test_path_local_path(self, engine, ext):
 1327:         df = DataFrame(
 1328:             1.1 * np.arange(120).reshape((30, 4)),
 1329:             columns=Index(list("ABCD")),
 1330:             index=Index([f"i-{i}" for i in range(30)]),
 1331:         )
 1332:         writer = partial(df.to_excel, engine=engine)
 1333: 
 1334:         reader = partial(pd.read_excel, index_col=0)
 1335:         result = tm.round_trip_localpath(writer, reader, path=f"foo{ext}")
 1336:         tm.assert_frame_equal(result, df)
 1337: 
 1338:     def test_merged_cell_custom_objects(self, path):
 1339:         # see GH-27006
 1340:         mi = MultiIndex.from_tuples(
 1341:             [
 1342:                 (pd.Period("2018"), pd.Period("2018Q1")),
 1343:                 (pd.Period("2018"), pd.Period("2018Q2")),
 1344:             ]
 1345:         )
 1346:         expected = DataFrame(np.ones((2, 2), dtype="int64"), columns=mi)
 1347:         expected.to_excel(path)
 1348:         result = pd.read_excel(path, header=[0, 1], index_col=0)
 1349:         # need to convert PeriodIndexes to standard Indexes for assert equal
 1350:         expected.columns = expected.columns.set_levels(
 1351:             [[str(i) for i in mi.levels[0]], [str(i) for i in mi.levels[1]]],
 1352:             level=[0, 1],
 1353:         )
 1354:         tm.assert_frame_equal(result, expected)
 1355: 
 1356:     @pytest.mark.parametrize("dtype", [None, object])
 1357:     def test_raise_when_saving_timezones(self, dtype, tz_aware_fixture, path):
 1358:         # GH 27008, GH 7056
 1359:         tz = tz_aware_fixture
 1360:         data = pd.Timestamp("2019", tz=tz)
 1361:         df = DataFrame([data], dtype=dtype)
 1362:         with pytest.raises(ValueError, match="Excel does not support"):
 1363:             df.to_excel(path)
 1364: 
 1365:         data = data.to_pydatetime()
 1366:         df = DataFrame([data], dtype=dtype)
 1367:         with pytest.raises(ValueError, match="Excel does not support"):
 1368:             df.to_excel(path)
 1369: 
 1370:     def test_excel_duplicate_columns_with_names(self, path):
 1371:         # GH#39695
 1372:         df = DataFrame({"A": [0, 1], "B": [10, 11]})
 1373:         df.to_excel(path, columns=["A", "B", "A"], index=False)
 1374: 
 1375:         result = pd.read_excel(path)
 1376:         expected = DataFrame([[0, 10, 0], [1, 11, 1]], columns=["A", "B", "A.1"])
 1377:         tm.assert_frame_equal(result, expected)
 1378: 
 1379:     def test_if_sheet_exists_raises(self, ext):
 1380:         # GH 40230
 1381:         msg = "if_sheet_exists is only valid in append mode (mode='a')"
 1382: 
 1383:         with tm.ensure_clean(ext) as f:
 1384:             with pytest.raises(ValueError, match=re.escape(msg)):
 1385:                 ExcelWriter(f, if_sheet_exists="replace")
 1386: 
 1387:     def test_excel_writer_empty_frame(self, engine, ext):
 1388:         # GH#45793
 1389:         with tm.ensure_clean(ext) as path:
 1390:             with ExcelWriter(path, engine=engine) as writer:
 1391:                 DataFrame().to_excel(writer)
 1392:             result = pd.read_excel(path)
 1393:             expected = DataFrame()
 1394:             tm.assert_frame_equal(result, expected)
 1395: 
 1396:     def test_to_excel_empty_frame(self, engine, ext):
 1397:         # GH#45793
 1398:         with tm.ensure_clean(ext) as path:
 1399:             DataFrame().to_excel(path, engine=engine)
 1400:             result = pd.read_excel(path)
 1401:             expected = DataFrame()
 1402:             tm.assert_frame_equal(result, expected)
 1403: 
 1404: 
 1405: class TestExcelWriterEngineTests:
 1406:     @pytest.mark.parametrize(
 1407:         "klass,ext",
 1408:         [
 1409:             pytest.param(_XlsxWriter, ".xlsx", marks=td.skip_if_no("xlsxwriter")),
 1410:             pytest.param(_OpenpyxlWriter, ".xlsx", marks=td.skip_if_no("openpyxl")),
 1411:         ],
 1412:     )
 1413:     def test_ExcelWriter_dispatch(self, klass, ext):
 1414:         with tm.ensure_clean(ext) as path:
 1415:             with ExcelWriter(path) as writer:
 1416:                 if ext == ".xlsx" and bool(
 1417:                     import_optional_dependency("xlsxwriter", errors="ignore")
 1418:                 ):
 1419:                     # xlsxwriter has preference over openpyxl if both installed
 1420:                     assert isinstance(writer, _XlsxWriter)
 1421:                 else:
 1422:                     assert isinstance(writer, klass)
 1423: 
 1424:     def test_ExcelWriter_dispatch_raises(self):
 1425:         with pytest.raises(ValueError, match="No engine"):
 1426:             ExcelWriter("nothing")
 1427: 
 1428:     def test_register_writer(self):
 1429:         class DummyClass(ExcelWriter):
 1430:             called_save = False
 1431:             called_write_cells = False
 1432:             called_sheets = False
 1433:             _supported_extensions = ("xlsx", "xls")
 1434:             _engine = "dummy"
 1435: 
 1436:             def book(self):
 1437:                 pass
 1438: 
 1439:             def _save(self):
 1440:                 type(self).called_save = True
 1441: 
 1442:             def _write_cells(self, *args, **kwargs):
 1443:                 type(self).called_write_cells = True
 1444: 
 1445:             @property
 1446:             def sheets(self):
 1447:                 type(self).called_sheets = True
 1448: 
 1449:             @classmethod
 1450:             def assert_called_and_reset(cls):
 1451:                 assert cls.called_save
 1452:                 assert cls.called_write_cells
 1453:                 assert not cls.called_sheets
 1454:                 cls.called_save = False
 1455:                 cls.called_write_cells = False
 1456: 
 1457:         register_writer(DummyClass)
 1458: 
 1459:         with option_context("io.excel.xlsx.writer", "dummy"):
 1460:             path = "something.xlsx"
 1461:             with tm.ensure_clean(path) as filepath:
 1462:                 with ExcelWriter(filepath) as writer:
 1463:                     assert isinstance(writer, DummyClass)
 1464:                 df = DataFrame(
 1465:                     ["a"],
 1466:                     columns=Index(["b"], name="foo"),
 1467:                     index=Index(["c"], name="bar"),
 1468:                 )
 1469:                 df.to_excel(filepath)
 1470:             DummyClass.assert_called_and_reset()
 1471: 
 1472:         with tm.ensure_clean("something.xls") as filepath:
 1473:             df.to_excel(filepath, engine="dummy")
 1474:         DummyClass.assert_called_and_reset()
 1475: 
 1476: 
 1477: @td.skip_if_no("xlrd")
 1478: @td.skip_if_no("openpyxl")
 1479: class TestFSPath:
 1480:     def test_excelfile_fspath(self):
 1481:         with tm.ensure_clean("foo.xlsx") as path:
 1482:             df = DataFrame({"A": [1, 2]})
 1483:             df.to_excel(path)
 1484:             with ExcelFile(path) as xl:
 1485:                 result = os.fspath(xl)
 1486:             assert result == path
 1487: 
 1488:     def test_excelwriter_fspath(self):
 1489:         with tm.ensure_clean("foo.xlsx") as path:
 1490:             with ExcelWriter(path) as writer:
 1491:                 assert os.fspath(writer) == str(path)
 1492: 
 1493:     def test_to_excel_pos_args_deprecation(self):
 1494:         # GH-54229
 1495:         df = DataFrame({"a": [1, 2, 3]})
 1496:         msg = (
 1497:             r"Starting with pandas version 3.0 all arguments of to_excel except "
 1498:             r"for the argument 'excel_writer' will be keyword-only."
 1499:         )
 1500:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1501:             buf = BytesIO()
 1502:             writer = ExcelWriter(buf)
 1503:             df.to_excel(writer, "Sheet_name_1")
 1504: 
 1505: 
 1506: @pytest.mark.parametrize("klass", _writers.values())
 1507: def test_subclass_attr(klass):
 1508:     # testing that subclasses of ExcelWriter don't have public attributes (issue 49602)
 1509:     attrs_base = {name for name in dir(ExcelWriter) if not name.startswith("_")}
 1510:     attrs_klass = {name for name in dir(klass) if not name.startswith("_")}
 1511:     assert not attrs_base.symmetric_difference(attrs_klass)
