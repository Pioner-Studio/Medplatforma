    1: """
    2: Tests compressed data parsing functionality for all
    3: of the parsers defined in parsers.py
    4: """
    5: 
    6: import os
    7: from pathlib import Path
    8: import tarfile
    9: import zipfile
   10: 
   11: import pytest
   12: 
   13: from pandas import DataFrame
   14: import pandas._testing as tm
   15: 
   16: pytestmark = pytest.mark.filterwarnings(
   17:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   18: )
   19: 
   20: 
   21: @pytest.fixture(params=[True, False])
   22: def buffer(request):
   23:     return request.param
   24: 
   25: 
   26: @pytest.fixture
   27: def parser_and_data(all_parsers, csv1):
   28:     parser = all_parsers
   29: 
   30:     with open(csv1, "rb") as f:
   31:         data = f.read()
   32:     expected = parser.read_csv(csv1)
   33: 
   34:     return parser, data, expected
   35: 
   36: 
   37: @pytest.mark.parametrize("compression", ["zip", "infer", "zip2"])
   38: def test_zip(parser_and_data, compression):
   39:     parser, data, expected = parser_and_data
   40: 
   41:     with tm.ensure_clean("test_file.zip") as path:
   42:         with zipfile.ZipFile(path, mode="w") as tmp:
   43:             tmp.writestr("test_file", data)
   44: 
   45:         if compression == "zip2":
   46:             with open(path, "rb") as f:
   47:                 result = parser.read_csv(f, compression="zip")
   48:         else:
   49:             result = parser.read_csv(path, compression=compression)
   50: 
   51:         tm.assert_frame_equal(result, expected)
   52: 
   53: 
   54: @pytest.mark.parametrize("compression", ["zip", "infer"])
   55: def test_zip_error_multiple_files(parser_and_data, compression):
   56:     parser, data, expected = parser_and_data
   57: 
   58:     with tm.ensure_clean("combined_zip.zip") as path:
   59:         inner_file_names = ["test_file", "second_file"]
   60: 
   61:         with zipfile.ZipFile(path, mode="w") as tmp:
   62:             for file_name in inner_file_names:
   63:                 tmp.writestr(file_name, data)
   64: 
   65:         with pytest.raises(ValueError, match="Multiple files"):
   66:             parser.read_csv(path, compression=compression)
   67: 
   68: 
   69: def test_zip_error_no_files(parser_and_data):
   70:     parser, _, _ = parser_and_data
   71: 
   72:     with tm.ensure_clean() as path:
   73:         with zipfile.ZipFile(path, mode="w"):
   74:             pass
   75: 
   76:         with pytest.raises(ValueError, match="Zero files"):
   77:             parser.read_csv(path, compression="zip")
   78: 
   79: 
   80: def test_zip_error_invalid_zip(parser_and_data):
   81:     parser, _, _ = parser_and_data
   82: 
   83:     with tm.ensure_clean() as path:
   84:         with open(path, "rb") as f:
   85:             with pytest.raises(zipfile.BadZipFile, match="File is not a zip file"):
   86:                 parser.read_csv(f, compression="zip")
   87: 
   88: 
   89: @pytest.mark.parametrize("filename", [None, "test.{ext}"])
   90: def test_compression(
   91:     request,
   92:     parser_and_data,
   93:     compression_only,
   94:     buffer,
   95:     filename,
   96:     compression_to_extension,
   97: ):
   98:     parser, data, expected = parser_and_data
   99:     compress_type = compression_only
  100: 
  101:     ext = compression_to_extension[compress_type]
  102:     filename = filename if filename is None else filename.format(ext=ext)
  103: 
  104:     if filename and buffer:
  105:         request.applymarker(
  106:             pytest.mark.xfail(
  107:                 reason="Cannot deduce compression from buffer of compressed data."
  108:             )
  109:         )
  110: 
  111:     with tm.ensure_clean(filename=filename) as path:
  112:         tm.write_to_compressed(compress_type, path, data)
  113:         compression = "infer" if filename else compress_type
  114: 
  115:         if buffer:
  116:             with open(path, "rb") as f:
  117:                 result = parser.read_csv(f, compression=compression)
  118:         else:
  119:             result = parser.read_csv(path, compression=compression)
  120: 
  121:         tm.assert_frame_equal(result, expected)
  122: 
  123: 
  124: @pytest.mark.parametrize("ext", [None, "gz", "bz2"])
  125: def test_infer_compression(all_parsers, csv1, buffer, ext):
  126:     # see gh-9770
  127:     parser = all_parsers
  128:     kwargs = {"index_col": 0, "parse_dates": True}
  129: 
  130:     expected = parser.read_csv(csv1, **kwargs)
  131:     kwargs["compression"] = "infer"
  132: 
  133:     if buffer:
  134:         with open(csv1, encoding="utf-8") as f:
  135:             result = parser.read_csv(f, **kwargs)
  136:     else:
  137:         ext = "." + ext if ext else ""
  138:         result = parser.read_csv(csv1 + ext, **kwargs)
  139: 
  140:     tm.assert_frame_equal(result, expected)
  141: 
  142: 
  143: def test_compression_utf_encoding(all_parsers, csv_dir_path, utf_value, encoding_fmt):
  144:     # see gh-18071, gh-24130
  145:     parser = all_parsers
  146:     encoding = encoding_fmt.format(utf_value)
  147:     path = os.path.join(csv_dir_path, f"utf{utf_value}_ex_small.zip")
  148: 
  149:     result = parser.read_csv(path, encoding=encoding, compression="zip", sep="\t")
  150:     expected = DataFrame(
  151:         {
  152:             "Country": ["Venezuela", "Venezuela"],
  153:             "Twitter": ["Hugo ChГЎvez FrГ­as", "Henrique Capriles R."],
  154:         }
  155:     )
  156: 
  157:     tm.assert_frame_equal(result, expected)
  158: 
  159: 
  160: @pytest.mark.parametrize("invalid_compression", ["sfark", "bz3", "zipper"])
  161: def test_invalid_compression(all_parsers, invalid_compression):
  162:     parser = all_parsers
  163:     compress_kwargs = {"compression": invalid_compression}
  164: 
  165:     msg = f"Unrecognized compression type: {invalid_compression}"
  166: 
  167:     with pytest.raises(ValueError, match=msg):
  168:         parser.read_csv("test_file.zip", **compress_kwargs)
  169: 
  170: 
  171: def test_compression_tar_archive(all_parsers, csv_dir_path):
  172:     parser = all_parsers
  173:     path = os.path.join(csv_dir_path, "tar_csv.tar.gz")
  174:     df = parser.read_csv(path)
  175:     assert list(df.columns) == ["a"]
  176: 
  177: 
  178: def test_ignore_compression_extension(all_parsers):
  179:     parser = all_parsers
  180:     df = DataFrame({"a": [0, 1]})
  181:     with tm.ensure_clean("test.csv") as path_csv:
  182:         with tm.ensure_clean("test.csv.zip") as path_zip:
  183:             # make sure to create un-compressed file with zip extension
  184:             df.to_csv(path_csv, index=False)
  185:             Path(path_zip).write_text(
  186:                 Path(path_csv).read_text(encoding="utf-8"), encoding="utf-8"
  187:             )
  188: 
  189:             tm.assert_frame_equal(parser.read_csv(path_zip, compression=None), df)
  190: 
  191: 
  192: def test_writes_tar_gz(all_parsers):
  193:     parser = all_parsers
  194:     data = DataFrame(
  195:         {
  196:             "Country": ["Venezuela", "Venezuela"],
  197:             "Twitter": ["Hugo ChГЎvez FrГ­as", "Henrique Capriles R."],
  198:         }
  199:     )
  200:     with tm.ensure_clean("test.tar.gz") as tar_path:
  201:         data.to_csv(tar_path, index=False)
  202: 
  203:         # test that read_csv infers .tar.gz to gzip:
  204:         tm.assert_frame_equal(parser.read_csv(tar_path), data)
  205: 
  206:         # test that file is indeed gzipped:
  207:         with tarfile.open(tar_path, "r:gz") as tar:
  208:             result = parser.read_csv(
  209:                 tar.extractfile(tar.getnames()[0]), compression="infer"
  210:             )
  211:             tm.assert_frame_equal(result, data)
