    1: import contextlib
    2: from pathlib import Path
    3: import re
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas.compat import is_platform_windows
    9: 
   10: import pandas as pd
   11: from pandas import DataFrame
   12: import pandas._testing as tm
   13: 
   14: from pandas.io.excel import (
   15:     ExcelWriter,
   16:     _OpenpyxlWriter,
   17: )
   18: from pandas.io.excel._openpyxl import OpenpyxlReader
   19: 
   20: openpyxl = pytest.importorskip("openpyxl")
   21: 
   22: if is_platform_windows():
   23:     pytestmark = pytest.mark.single_cpu
   24: 
   25: 
   26: @pytest.fixture
   27: def ext():
   28:     return ".xlsx"
   29: 
   30: 
   31: def test_to_excel_styleconverter():
   32:     from openpyxl import styles
   33: 
   34:     hstyle = {
   35:         "font": {"color": "00FF0000", "bold": True},
   36:         "borders": {"top": "thin", "right": "thin", "bottom": "thin", "left": "thin"},
   37:         "alignment": {"horizontal": "center", "vertical": "top"},
   38:         "fill": {"patternType": "solid", "fgColor": {"rgb": "006666FF", "tint": 0.3}},
   39:         "number_format": {"format_code": "0.00"},
   40:         "protection": {"locked": True, "hidden": False},
   41:     }
   42: 
   43:     font_color = styles.Color("00FF0000")
   44:     font = styles.Font(bold=True, color=font_color)
   45:     side = styles.Side(style=styles.borders.BORDER_THIN)
   46:     border = styles.Border(top=side, right=side, bottom=side, left=side)
   47:     alignment = styles.Alignment(horizontal="center", vertical="top")
   48:     fill_color = styles.Color(rgb="006666FF", tint=0.3)
   49:     fill = styles.PatternFill(patternType="solid", fgColor=fill_color)
   50: 
   51:     number_format = "0.00"
   52: 
   53:     protection = styles.Protection(locked=True, hidden=False)
   54: 
   55:     kw = _OpenpyxlWriter._convert_to_style_kwargs(hstyle)
   56:     assert kw["font"] == font
   57:     assert kw["border"] == border
   58:     assert kw["alignment"] == alignment
   59:     assert kw["fill"] == fill
   60:     assert kw["number_format"] == number_format
   61:     assert kw["protection"] == protection
   62: 
   63: 
   64: def test_write_cells_merge_styled(ext):
   65:     from pandas.io.formats.excel import ExcelCell
   66: 
   67:     sheet_name = "merge_styled"
   68: 
   69:     sty_b1 = {"font": {"color": "00FF0000"}}
   70:     sty_a2 = {"font": {"color": "0000FF00"}}
   71: 
   72:     initial_cells = [
   73:         ExcelCell(col=1, row=0, val=42, style=sty_b1),
   74:         ExcelCell(col=0, row=1, val=99, style=sty_a2),
   75:     ]
   76: 
   77:     sty_merged = {"font": {"color": "000000FF", "bold": True}}
   78:     sty_kwargs = _OpenpyxlWriter._convert_to_style_kwargs(sty_merged)
   79:     openpyxl_sty_merged = sty_kwargs["font"]
   80:     merge_cells = [
   81:         ExcelCell(
   82:             col=0, row=0, val="pandas", mergestart=1, mergeend=1, style=sty_merged
   83:         )
   84:     ]
   85: 
   86:     with tm.ensure_clean(ext) as path:
   87:         with _OpenpyxlWriter(path) as writer:
   88:             writer._write_cells(initial_cells, sheet_name=sheet_name)
   89:             writer._write_cells(merge_cells, sheet_name=sheet_name)
   90: 
   91:             wks = writer.sheets[sheet_name]
   92:         xcell_b1 = wks["B1"]
   93:         xcell_a2 = wks["A2"]
   94:         assert xcell_b1.font == openpyxl_sty_merged
   95:         assert xcell_a2.font == openpyxl_sty_merged
   96: 
   97: 
   98: @pytest.mark.parametrize("iso_dates", [True, False])
   99: def test_engine_kwargs_write(ext, iso_dates):
  100:     # GH 42286 GH 43445
  101:     engine_kwargs = {"iso_dates": iso_dates}
  102:     with tm.ensure_clean(ext) as f:
  103:         with ExcelWriter(f, engine="openpyxl", engine_kwargs=engine_kwargs) as writer:
  104:             assert writer.book.iso_dates == iso_dates
  105:             # ExcelWriter won't allow us to close without writing something
  106:             DataFrame().to_excel(writer)
  107: 
  108: 
  109: def test_engine_kwargs_append_invalid(ext):
  110:     # GH 43445
  111:     # test whether an invalid engine kwargs actually raises
  112:     with tm.ensure_clean(ext) as f:
  113:         DataFrame(["hello", "world"]).to_excel(f)
  114:         with pytest.raises(
  115:             TypeError,
  116:             match=re.escape(
  117:                 "load_workbook() got an unexpected keyword argument 'apple_banana'"
  118:             ),
  119:         ):
  120:             with ExcelWriter(
  121:                 f, engine="openpyxl", mode="a", engine_kwargs={"apple_banana": "fruit"}
  122:             ) as writer:
  123:                 # ExcelWriter needs us to write something to close properly
  124:                 DataFrame(["good"]).to_excel(writer, sheet_name="Sheet2")
  125: 
  126: 
  127: @pytest.mark.parametrize("data_only, expected", [(True, 0), (False, "=1+1")])
  128: def test_engine_kwargs_append_data_only(ext, data_only, expected):
  129:     # GH 43445
  130:     # tests whether the data_only engine_kwarg actually works well for
  131:     # openpyxl's load_workbook
  132:     with tm.ensure_clean(ext) as f:
  133:         DataFrame(["=1+1"]).to_excel(f)
  134:         with ExcelWriter(
  135:             f, engine="openpyxl", mode="a", engine_kwargs={"data_only": data_only}
  136:         ) as writer:
  137:             assert writer.sheets["Sheet1"]["B2"].value == expected
  138:             # ExcelWriter needs us to writer something to close properly?
  139:             DataFrame().to_excel(writer, sheet_name="Sheet2")
  140: 
  141:         # ensure that data_only also works for reading
  142:         #  and that formulas/values roundtrip
  143:         assert (
  144:             pd.read_excel(
  145:                 f,
  146:                 sheet_name="Sheet1",
  147:                 engine="openpyxl",
  148:                 engine_kwargs={"data_only": data_only},
  149:             ).iloc[0, 1]
  150:             == expected
  151:         )
  152: 
  153: 
  154: @pytest.mark.parametrize("kwarg_name", ["read_only", "data_only"])
  155: @pytest.mark.parametrize("kwarg_value", [True, False])
  156: def test_engine_kwargs_append_reader(datapath, ext, kwarg_name, kwarg_value):
  157:     # GH 55027
  158:     # test that `read_only` and `data_only` can be passed to
  159:     #  `openpyxl.reader.excel.load_workbook` via `engine_kwargs`
  160:     filename = datapath("io", "data", "excel", "test1" + ext)
  161:     with contextlib.closing(
  162:         OpenpyxlReader(filename, engine_kwargs={kwarg_name: kwarg_value})
  163:     ) as reader:
  164:         assert getattr(reader.book, kwarg_name) == kwarg_value
  165: 
  166: 
  167: @pytest.mark.parametrize(
  168:     "mode,expected", [("w", ["baz"]), ("a", ["foo", "bar", "baz"])]
  169: )
  170: def test_write_append_mode(ext, mode, expected):
  171:     df = DataFrame([1], columns=["baz"])
  172: 
  173:     with tm.ensure_clean(ext) as f:
  174:         wb = openpyxl.Workbook()
  175:         wb.worksheets[0].title = "foo"
  176:         wb.worksheets[0]["A1"].value = "foo"
  177:         wb.create_sheet("bar")
  178:         wb.worksheets[1]["A1"].value = "bar"
  179:         wb.save(f)
  180: 
  181:         with ExcelWriter(f, engine="openpyxl", mode=mode) as writer:
  182:             df.to_excel(writer, sheet_name="baz", index=False)
  183: 
  184:         with contextlib.closing(openpyxl.load_workbook(f)) as wb2:
  185:             result = [sheet.title for sheet in wb2.worksheets]
  186:             assert result == expected
  187: 
  188:             for index, cell_value in enumerate(expected):
  189:                 assert wb2.worksheets[index]["A1"].value == cell_value
  190: 
  191: 
  192: @pytest.mark.parametrize(
  193:     "if_sheet_exists,num_sheets,expected",
  194:     [
  195:         ("new", 2, ["apple", "banana"]),
  196:         ("replace", 1, ["pear"]),
  197:         ("overlay", 1, ["pear", "banana"]),
  198:     ],
  199: )
  200: def test_if_sheet_exists_append_modes(ext, if_sheet_exists, num_sheets, expected):
  201:     # GH 40230
  202:     df1 = DataFrame({"fruit": ["apple", "banana"]})
  203:     df2 = DataFrame({"fruit": ["pear"]})
  204: 
  205:     with tm.ensure_clean(ext) as f:
  206:         df1.to_excel(f, engine="openpyxl", sheet_name="foo", index=False)
  207:         with ExcelWriter(
  208:             f, engine="openpyxl", mode="a", if_sheet_exists=if_sheet_exists
  209:         ) as writer:
  210:             df2.to_excel(writer, sheet_name="foo", index=False)
  211: 
  212:         with contextlib.closing(openpyxl.load_workbook(f)) as wb:
  213:             assert len(wb.sheetnames) == num_sheets
  214:             assert wb.sheetnames[0] == "foo"
  215:             result = pd.read_excel(wb, "foo", engine="openpyxl")
  216:             assert list(result["fruit"]) == expected
  217:             if len(wb.sheetnames) == 2:
  218:                 result = pd.read_excel(wb, wb.sheetnames[1], engine="openpyxl")
  219:                 tm.assert_frame_equal(result, df2)
  220: 
  221: 
  222: @pytest.mark.parametrize(
  223:     "startrow, startcol, greeting, goodbye",
  224:     [
  225:         (0, 0, ["poop", "world"], ["goodbye", "people"]),
  226:         (0, 1, ["hello", "world"], ["poop", "people"]),
  227:         (1, 0, ["hello", "poop"], ["goodbye", "people"]),
  228:         (1, 1, ["hello", "world"], ["goodbye", "poop"]),
  229:     ],
  230: )
  231: def test_append_overlay_startrow_startcol(ext, startrow, startcol, greeting, goodbye):
  232:     df1 = DataFrame({"greeting": ["hello", "world"], "goodbye": ["goodbye", "people"]})
  233:     df2 = DataFrame(["poop"])
  234: 
  235:     with tm.ensure_clean(ext) as f:
  236:         df1.to_excel(f, engine="openpyxl", sheet_name="poo", index=False)
  237:         with ExcelWriter(
  238:             f, engine="openpyxl", mode="a", if_sheet_exists="overlay"
  239:         ) as writer:
  240:             # use startrow+1 because we don't have a header
  241:             df2.to_excel(
  242:                 writer,
  243:                 index=False,
  244:                 header=False,
  245:                 startrow=startrow + 1,
  246:                 startcol=startcol,
  247:                 sheet_name="poo",
  248:             )
  249: 
  250:         result = pd.read_excel(f, sheet_name="poo", engine="openpyxl")
  251:         expected = DataFrame({"greeting": greeting, "goodbye": goodbye})
  252:         tm.assert_frame_equal(result, expected)
  253: 
  254: 
  255: @pytest.mark.parametrize(
  256:     "if_sheet_exists,msg",
  257:     [
  258:         (
  259:             "invalid",
  260:             "'invalid' is not valid for if_sheet_exists. Valid options "
  261:             "are 'error', 'new', 'replace' and 'overlay'.",
  262:         ),
  263:         (
  264:             "error",
  265:             "Sheet 'foo' already exists and if_sheet_exists is set to 'error'.",
  266:         ),
  267:         (
  268:             None,
  269:             "Sheet 'foo' already exists and if_sheet_exists is set to 'error'.",
  270:         ),
  271:     ],
  272: )
  273: def test_if_sheet_exists_raises(ext, if_sheet_exists, msg):
  274:     # GH 40230
  275:     df = DataFrame({"fruit": ["pear"]})
  276:     with tm.ensure_clean(ext) as f:
  277:         with pytest.raises(ValueError, match=re.escape(msg)):
  278:             df.to_excel(f, sheet_name="foo", engine="openpyxl")
  279:             with ExcelWriter(
  280:                 f, engine="openpyxl", mode="a", if_sheet_exists=if_sheet_exists
  281:             ) as writer:
  282:                 df.to_excel(writer, sheet_name="foo")
  283: 
  284: 
  285: def test_to_excel_with_openpyxl_engine(ext):
  286:     # GH 29854
  287:     with tm.ensure_clean(ext) as filename:
  288:         df1 = DataFrame({"A": np.linspace(1, 10, 10)})
  289:         df2 = DataFrame({"B": np.linspace(1, 20, 10)})
  290:         df = pd.concat([df1, df2], axis=1)
  291:         styled = df.style.map(
  292:             lambda val: f"color: {'red' if val < 0 else 'black'}"
  293:         ).highlight_max()
  294: 
  295:         styled.to_excel(filename, engine="openpyxl")
  296: 
  297: 
  298: @pytest.mark.parametrize("read_only", [True, False])
  299: def test_read_workbook(datapath, ext, read_only):
  300:     # GH 39528
  301:     filename = datapath("io", "data", "excel", "test1" + ext)
  302:     with contextlib.closing(
  303:         openpyxl.load_workbook(filename, read_only=read_only)
  304:     ) as wb:
  305:         result = pd.read_excel(wb, engine="openpyxl")
  306:     expected = pd.read_excel(filename)
  307:     tm.assert_frame_equal(result, expected)
  308: 
  309: 
  310: @pytest.mark.parametrize(
  311:     "header, expected_data",
  312:     [
  313:         (
  314:             0,
  315:             {
  316:                 "Title": [np.nan, "A", 1, 2, 3],
  317:                 "Unnamed: 1": [np.nan, "B", 4, 5, 6],
  318:                 "Unnamed: 2": [np.nan, "C", 7, 8, 9],
  319:             },
  320:         ),
  321:         (2, {"A": [1, 2, 3], "B": [4, 5, 6], "C": [7, 8, 9]}),
  322:     ],
  323: )
  324: @pytest.mark.parametrize(
  325:     "filename", ["dimension_missing", "dimension_small", "dimension_large"]
  326: )
  327: # When read_only is None, use read_excel instead of a workbook
  328: @pytest.mark.parametrize("read_only", [True, False, None])
  329: def test_read_with_bad_dimension(
  330:     datapath, ext, header, expected_data, filename, read_only
  331: ):
  332:     # GH 38956, 39001 - no/incorrect dimension information
  333:     path = datapath("io", "data", "excel", f"{filename}{ext}")
  334:     if read_only is None:
  335:         result = pd.read_excel(path, header=header)
  336:     else:
  337:         with contextlib.closing(
  338:             openpyxl.load_workbook(path, read_only=read_only)
  339:         ) as wb:
  340:             result = pd.read_excel(wb, engine="openpyxl", header=header)
  341:     expected = DataFrame(expected_data)
  342:     tm.assert_frame_equal(result, expected)
  343: 
  344: 
  345: def test_append_mode_file(ext):
  346:     # GH 39576
  347:     df = DataFrame()
  348: 
  349:     with tm.ensure_clean(ext) as f:
  350:         df.to_excel(f, engine="openpyxl")
  351: 
  352:         with ExcelWriter(
  353:             f, mode="a", engine="openpyxl", if_sheet_exists="new"
  354:         ) as writer:
  355:             df.to_excel(writer)
  356: 
  357:         # make sure that zip files are not concatenated by making sure that
  358:         # "docProps/app.xml" only occurs twice in the file
  359:         data = Path(f).read_bytes()
  360:         first = data.find(b"docProps/app.xml")
  361:         second = data.find(b"docProps/app.xml", first + 1)
  362:         third = data.find(b"docProps/app.xml", second + 1)
  363:         assert second != -1 and third == -1
  364: 
  365: 
  366: # When read_only is None, use read_excel instead of a workbook
  367: @pytest.mark.parametrize("read_only", [True, False, None])
  368: def test_read_with_empty_trailing_rows(datapath, ext, read_only):
  369:     # GH 39181
  370:     path = datapath("io", "data", "excel", f"empty_trailing_rows{ext}")
  371:     if read_only is None:
  372:         result = pd.read_excel(path)
  373:     else:
  374:         with contextlib.closing(
  375:             openpyxl.load_workbook(path, read_only=read_only)
  376:         ) as wb:
  377:             result = pd.read_excel(wb, engine="openpyxl")
  378:     expected = DataFrame(
  379:         {
  380:             "Title": [np.nan, "A", 1, 2, 3],
  381:             "Unnamed: 1": [np.nan, "B", 4, 5, 6],
  382:             "Unnamed: 2": [np.nan, "C", 7, 8, 9],
  383:         }
  384:     )
  385:     tm.assert_frame_equal(result, expected)
  386: 
  387: 
  388: # When read_only is None, use read_excel instead of a workbook
  389: @pytest.mark.parametrize("read_only", [True, False, None])
  390: def test_read_empty_with_blank_row(datapath, ext, read_only):
  391:     # GH 39547 - empty excel file with a row that has no data
  392:     path = datapath("io", "data", "excel", f"empty_with_blank_row{ext}")
  393:     if read_only is None:
  394:         result = pd.read_excel(path)
  395:     else:
  396:         with contextlib.closing(
  397:             openpyxl.load_workbook(path, read_only=read_only)
  398:         ) as wb:
  399:             result = pd.read_excel(wb, engine="openpyxl")
  400:     expected = DataFrame()
  401:     tm.assert_frame_equal(result, expected)
  402: 
  403: 
  404: def test_book_and_sheets_consistent(ext):
  405:     # GH#45687 - Ensure sheets is updated if user modifies book
  406:     with tm.ensure_clean(ext) as f:
  407:         with ExcelWriter(f, engine="openpyxl") as writer:
  408:             assert writer.sheets == {}
  409:             sheet = writer.book.create_sheet("test_name", 0)
  410:             assert writer.sheets == {"test_name": sheet}
  411: 
  412: 
  413: def test_ints_spelled_with_decimals(datapath, ext):
  414:     # GH 46988 - openpyxl returns this sheet with floats
  415:     path = datapath("io", "data", "excel", f"ints_spelled_with_decimals{ext}")
  416:     result = pd.read_excel(path)
  417:     expected = DataFrame(range(2, 12), columns=[1])
  418:     tm.assert_frame_equal(result, expected)
  419: 
  420: 
  421: def test_read_multiindex_header_no_index_names(datapath, ext):
  422:     # GH#47487
  423:     path = datapath("io", "data", "excel", f"multiindex_no_index_names{ext}")
  424:     result = pd.read_excel(path, index_col=[0, 1, 2], header=[0, 1, 2])
  425:     expected = DataFrame(
  426:         [[np.nan, "x", "x", "x"], ["x", np.nan, np.nan, np.nan]],
  427:         columns=pd.MultiIndex.from_tuples(
  428:             [("X", "Y", "A1"), ("X", "Y", "A2"), ("XX", "YY", "B1"), ("XX", "YY", "B2")]
  429:         ),
  430:         index=pd.MultiIndex.from_tuples([("A", "AA", "AAA"), ("A", "BB", "BBB")]),
  431:     )
  432:     tm.assert_frame_equal(result, expected)
