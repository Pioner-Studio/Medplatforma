    1: from hypothesis import (
    2:     assume,
    3:     example,
    4:     given,
    5:     strategies as st,
    6: )
    7: import numpy as np
    8: import pytest
    9: 
   10: from pandas._libs.byteswap import (
   11:     read_double_with_byteswap,
   12:     read_float_with_byteswap,
   13:     read_uint16_with_byteswap,
   14:     read_uint32_with_byteswap,
   15:     read_uint64_with_byteswap,
   16: )
   17: 
   18: import pandas._testing as tm
   19: 
   20: 
   21: @given(read_offset=st.integers(0, 11), number=st.integers(min_value=0))
   22: @example(number=2**16, read_offset=0)
   23: @example(number=2**32, read_offset=0)
   24: @example(number=2**64, read_offset=0)
   25: @pytest.mark.parametrize("int_type", [np.uint16, np.uint32, np.uint64])
   26: @pytest.mark.parametrize("should_byteswap", [True, False])
   27: def test_int_byteswap(read_offset, number, int_type, should_byteswap):
   28:     assume(number < 2 ** (8 * int_type(0).itemsize))
   29:     _test(number, int_type, read_offset, should_byteswap)
   30: 
   31: 
   32: @pytest.mark.filterwarnings("ignore:overflow encountered:RuntimeWarning")
   33: @given(read_offset=st.integers(0, 11), number=st.floats())
   34: @pytest.mark.parametrize("float_type", [np.float32, np.float64])
   35: @pytest.mark.parametrize("should_byteswap", [True, False])
   36: def test_float_byteswap(read_offset, number, float_type, should_byteswap):
   37:     _test(number, float_type, read_offset, should_byteswap)
   38: 
   39: 
   40: def _test(number, number_type, read_offset, should_byteswap):
   41:     number = number_type(number)
   42:     data = np.random.default_rng(2).integers(0, 256, size=20, dtype="uint8")
   43:     data[read_offset : read_offset + number.itemsize] = number[None].view("uint8")
   44:     swap_func = {
   45:         np.float32: read_float_with_byteswap,
   46:         np.float64: read_double_with_byteswap,
   47:         np.uint16: read_uint16_with_byteswap,
   48:         np.uint32: read_uint32_with_byteswap,
   49:         np.uint64: read_uint64_with_byteswap,
   50:     }[type(number)]
   51:     output_number = number_type(swap_func(bytes(data), read_offset, should_byteswap))
   52:     if should_byteswap:
   53:         tm.assert_equal(output_number, number.byteswap())
   54:     else:
   55:         tm.assert_equal(output_number, number)
