    1: import contextlib
    2: import copy
    3: import re
    4: from textwrap import dedent
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     IndexSlice,
   12:     MultiIndex,
   13:     Series,
   14:     option_context,
   15: )
   16: import pandas._testing as tm
   17: 
   18: jinja2 = pytest.importorskip("jinja2")
   19: from pandas.io.formats.style import (  # isort:skip
   20:     Styler,
   21: )
   22: from pandas.io.formats.style_render import (
   23:     _get_level_lengths,
   24:     _get_trimming_maximums,
   25:     maybe_convert_css_to_tuples,
   26:     non_reducing_slice,
   27: )
   28: 
   29: 
   30: @pytest.fixture
   31: def mi_df():
   32:     return DataFrame(
   33:         [[1, 2], [3, 4]],
   34:         index=MultiIndex.from_product([["i0"], ["i1_a", "i1_b"]]),
   35:         columns=MultiIndex.from_product([["c0"], ["c1_a", "c1_b"]]),
   36:         dtype=int,
   37:     )
   38: 
   39: 
   40: @pytest.fixture
   41: def mi_styler(mi_df):
   42:     return Styler(mi_df, uuid_len=0)
   43: 
   44: 
   45: @pytest.fixture
   46: def mi_styler_comp(mi_styler):
   47:     # comprehensively add features to mi_styler
   48:     mi_styler = mi_styler._copy(deepcopy=True)
   49:     mi_styler.css = {**mi_styler.css, "row": "ROW", "col": "COL"}
   50:     mi_styler.uuid_len = 5
   51:     mi_styler.uuid = "abcde"
   52:     mi_styler.set_caption("capt")
   53:     mi_styler.set_table_styles([{"selector": "a", "props": "a:v;"}])
   54:     mi_styler.hide(axis="columns")
   55:     mi_styler.hide([("c0", "c1_a")], axis="columns", names=True)
   56:     mi_styler.hide(axis="index")
   57:     mi_styler.hide([("i0", "i1_a")], axis="index", names=True)
   58:     mi_styler.set_table_attributes('class="box"')
   59:     other = mi_styler.data.agg(["mean"])
   60:     other.index = MultiIndex.from_product([[""], other.index])
   61:     mi_styler.concat(other.style)
   62:     mi_styler.format(na_rep="MISSING", precision=3)
   63:     mi_styler.format_index(precision=2, axis=0)
   64:     mi_styler.format_index(precision=4, axis=1)
   65:     mi_styler.highlight_max(axis=None)
   66:     mi_styler.map_index(lambda x: "color: white;", axis=0)
   67:     mi_styler.map_index(lambda x: "color: black;", axis=1)
   68:     mi_styler.set_td_classes(
   69:         DataFrame(
   70:             [["a", "b"], ["a", "c"]], index=mi_styler.index, columns=mi_styler.columns
   71:         )
   72:     )
   73:     mi_styler.set_tooltips(
   74:         DataFrame(
   75:             [["a2", "b2"], ["a2", "c2"]],
   76:             index=mi_styler.index,
   77:             columns=mi_styler.columns,
   78:         )
   79:     )
   80:     return mi_styler
   81: 
   82: 
   83: @pytest.fixture
   84: def blank_value():
   85:     return "&nbsp;"
   86: 
   87: 
   88: @pytest.fixture
   89: def df():
   90:     df = DataFrame({"A": [0, 1], "B": np.random.default_rng(2).standard_normal(2)})
   91:     return df
   92: 
   93: 
   94: @pytest.fixture
   95: def styler(df):
   96:     df = DataFrame({"A": [0, 1], "B": np.random.default_rng(2).standard_normal(2)})
   97:     return Styler(df)
   98: 
   99: 
  100: @pytest.mark.parametrize(
  101:     "sparse_columns, exp_cols",
  102:     [
  103:         (
  104:             True,
  105:             [
  106:                 {"is_visible": True, "attributes": 'colspan="2"', "value": "c0"},
  107:                 {"is_visible": False, "attributes": "", "value": "c0"},
  108:             ],
  109:         ),
  110:         (
  111:             False,
  112:             [
  113:                 {"is_visible": True, "attributes": "", "value": "c0"},
  114:                 {"is_visible": True, "attributes": "", "value": "c0"},
  115:             ],
  116:         ),
  117:     ],
  118: )
  119: def test_mi_styler_sparsify_columns(mi_styler, sparse_columns, exp_cols):
  120:     exp_l1_c0 = {"is_visible": True, "attributes": "", "display_value": "c1_a"}
  121:     exp_l1_c1 = {"is_visible": True, "attributes": "", "display_value": "c1_b"}
  122: 
  123:     ctx = mi_styler._translate(True, sparse_columns)
  124: 
  125:     assert exp_cols[0].items() <= ctx["head"][0][2].items()
  126:     assert exp_cols[1].items() <= ctx["head"][0][3].items()
  127:     assert exp_l1_c0.items() <= ctx["head"][1][2].items()
  128:     assert exp_l1_c1.items() <= ctx["head"][1][3].items()
  129: 
  130: 
  131: @pytest.mark.parametrize(
  132:     "sparse_index, exp_rows",
  133:     [
  134:         (
  135:             True,
  136:             [
  137:                 {"is_visible": True, "attributes": 'rowspan="2"', "value": "i0"},
  138:                 {"is_visible": False, "attributes": "", "value": "i0"},
  139:             ],
  140:         ),
  141:         (
  142:             False,
  143:             [
  144:                 {"is_visible": True, "attributes": "", "value": "i0"},
  145:                 {"is_visible": True, "attributes": "", "value": "i0"},
  146:             ],
  147:         ),
  148:     ],
  149: )
  150: def test_mi_styler_sparsify_index(mi_styler, sparse_index, exp_rows):
  151:     exp_l1_r0 = {"is_visible": True, "attributes": "", "display_value": "i1_a"}
  152:     exp_l1_r1 = {"is_visible": True, "attributes": "", "display_value": "i1_b"}
  153: 
  154:     ctx = mi_styler._translate(sparse_index, True)
  155: 
  156:     assert exp_rows[0].items() <= ctx["body"][0][0].items()
  157:     assert exp_rows[1].items() <= ctx["body"][1][0].items()
  158:     assert exp_l1_r0.items() <= ctx["body"][0][1].items()
  159:     assert exp_l1_r1.items() <= ctx["body"][1][1].items()
  160: 
  161: 
  162: def test_mi_styler_sparsify_options(mi_styler):
  163:     with option_context("styler.sparse.index", False):
  164:         html1 = mi_styler.to_html()
  165:     with option_context("styler.sparse.index", True):
  166:         html2 = mi_styler.to_html()
  167: 
  168:     assert html1 != html2
  169: 
  170:     with option_context("styler.sparse.columns", False):
  171:         html1 = mi_styler.to_html()
  172:     with option_context("styler.sparse.columns", True):
  173:         html2 = mi_styler.to_html()
  174: 
  175:     assert html1 != html2
  176: 
  177: 
  178: @pytest.mark.parametrize(
  179:     "rn, cn, max_els, max_rows, max_cols, exp_rn, exp_cn",
  180:     [
  181:         (100, 100, 100, None, None, 12, 6),  # reduce to (12, 6) < 100 elements
  182:         (1000, 3, 750, None, None, 250, 3),  # dynamically reduce rows to 250, keep cols
  183:         (4, 1000, 500, None, None, 4, 125),  # dynamically reduce cols to 125, keep rows
  184:         (1000, 3, 750, 10, None, 10, 3),  # overwrite above dynamics with max_row
  185:         (4, 1000, 500, None, 5, 4, 5),  # overwrite above dynamics with max_col
  186:         (100, 100, 700, 50, 50, 25, 25),  # rows cols below given maxes so < 700 elmts
  187:     ],
  188: )
  189: def test_trimming_maximum(rn, cn, max_els, max_rows, max_cols, exp_rn, exp_cn):
  190:     rn, cn = _get_trimming_maximums(
  191:         rn, cn, max_els, max_rows, max_cols, scaling_factor=0.5
  192:     )
  193:     assert (rn, cn) == (exp_rn, exp_cn)
  194: 
  195: 
  196: @pytest.mark.parametrize(
  197:     "option, val",
  198:     [
  199:         ("styler.render.max_elements", 6),
  200:         ("styler.render.max_rows", 3),
  201:     ],
  202: )
  203: def test_render_trimming_rows(option, val):
  204:     # test auto and specific trimming of rows
  205:     df = DataFrame(np.arange(120).reshape(60, 2))
  206:     with option_context(option, val):
  207:         ctx = df.style._translate(True, True)
  208:     assert len(ctx["head"][0]) == 3  # index + 2 data cols
  209:     assert len(ctx["body"]) == 4  # 3 data rows + trimming row
  210:     assert len(ctx["body"][0]) == 3  # index + 2 data cols
  211: 
  212: 
  213: @pytest.mark.parametrize(
  214:     "option, val",
  215:     [
  216:         ("styler.render.max_elements", 6),
  217:         ("styler.render.max_columns", 2),
  218:     ],
  219: )
  220: def test_render_trimming_cols(option, val):
  221:     # test auto and specific trimming of cols
  222:     df = DataFrame(np.arange(30).reshape(3, 10))
  223:     with option_context(option, val):
  224:         ctx = df.style._translate(True, True)
  225:     assert len(ctx["head"][0]) == 4  # index + 2 data cols + trimming col
  226:     assert len(ctx["body"]) == 3  # 3 data rows
  227:     assert len(ctx["body"][0]) == 4  # index + 2 data cols + trimming col
  228: 
  229: 
  230: def test_render_trimming_mi():
  231:     midx = MultiIndex.from_product([[1, 2], [1, 2, 3]])
  232:     df = DataFrame(np.arange(36).reshape(6, 6), columns=midx, index=midx)
  233:     with option_context("styler.render.max_elements", 4):
  234:         ctx = df.style._translate(True, True)
  235: 
  236:     assert len(ctx["body"][0]) == 5  # 2 indexes + 2 data cols + trimming row
  237:     assert {"attributes": 'rowspan="2"'}.items() <= ctx["body"][0][0].items()
  238:     assert {"class": "data row0 col_trim"}.items() <= ctx["body"][0][4].items()
  239:     assert {"class": "data row_trim col_trim"}.items() <= ctx["body"][2][4].items()
  240:     assert len(ctx["body"]) == 3  # 2 data rows + trimming row
  241: 
  242: 
  243: def test_render_empty_mi():
  244:     # GH 43305
  245:     df = DataFrame(index=MultiIndex.from_product([["A"], [0, 1]], names=[None, "one"]))
  246:     expected = dedent(
  247:         """\
  248:     >
  249:       <thead>
  250:         <tr>
  251:           <th class="index_name level0" >&nbsp;</th>
  252:           <th class="index_name level1" >one</th>
  253:         </tr>
  254:       </thead>
  255:     """
  256:     )
  257:     assert expected in df.style.to_html()
  258: 
  259: 
  260: @pytest.mark.parametrize("comprehensive", [True, False])
  261: @pytest.mark.parametrize("render", [True, False])
  262: @pytest.mark.parametrize("deepcopy", [True, False])
  263: def test_copy(comprehensive, render, deepcopy, mi_styler, mi_styler_comp):
  264:     styler = mi_styler_comp if comprehensive else mi_styler
  265:     styler.uuid_len = 5
  266: 
  267:     s2 = copy.deepcopy(styler) if deepcopy else copy.copy(styler)  # make copy and check
  268:     assert s2 is not styler
  269: 
  270:     if render:
  271:         styler.to_html()
  272: 
  273:     excl = [
  274:         "cellstyle_map",  # render time vars..
  275:         "cellstyle_map_columns",
  276:         "cellstyle_map_index",
  277:         "template_latex",  # render templates are class level
  278:         "template_html",
  279:         "template_html_style",
  280:         "template_html_table",
  281:     ]
  282:     if not deepcopy:  # check memory locations are equal for all included attributes
  283:         for attr in [a for a in styler.__dict__ if (not callable(a) and a not in excl)]:
  284:             assert id(getattr(s2, attr)) == id(getattr(styler, attr))
  285:     else:  # check memory locations are different for nested or mutable vars
  286:         shallow = [
  287:             "data",
  288:             "columns",
  289:             "index",
  290:             "uuid_len",
  291:             "uuid",
  292:             "caption",
  293:             "cell_ids",
  294:             "hide_index_",
  295:             "hide_columns_",
  296:             "hide_index_names",
  297:             "hide_column_names",
  298:             "table_attributes",
  299:         ]
  300:         for attr in shallow:
  301:             assert id(getattr(s2, attr)) == id(getattr(styler, attr))
  302: 
  303:         for attr in [
  304:             a
  305:             for a in styler.__dict__
  306:             if (not callable(a) and a not in excl and a not in shallow)
  307:         ]:
  308:             if getattr(s2, attr) is None:
  309:                 assert id(getattr(s2, attr)) == id(getattr(styler, attr))
  310:             else:
  311:                 assert id(getattr(s2, attr)) != id(getattr(styler, attr))
  312: 
  313: 
  314: @pytest.mark.parametrize("deepcopy", [True, False])
  315: def test_inherited_copy(mi_styler, deepcopy):
  316:     # Ensure that the inherited class is preserved when a Styler object is copied.
  317:     # GH 52728
  318:     class CustomStyler(Styler):
  319:         pass
  320: 
  321:     custom_styler = CustomStyler(mi_styler.data)
  322:     custom_styler_copy = (
  323:         copy.deepcopy(custom_styler) if deepcopy else copy.copy(custom_styler)
  324:     )
  325:     assert isinstance(custom_styler_copy, CustomStyler)
  326: 
  327: 
  328: def test_clear(mi_styler_comp):
  329:     # NOTE: if this test fails for new features then 'mi_styler_comp' should be updated
  330:     # to ensure proper testing of the 'copy', 'clear', 'export' methods with new feature
  331:     # GH 40675
  332:     styler = mi_styler_comp
  333:     styler._compute()  # execute applied methods
  334: 
  335:     clean_copy = Styler(styler.data, uuid=styler.uuid)
  336: 
  337:     excl = [
  338:         "data",
  339:         "index",
  340:         "columns",
  341:         "uuid",
  342:         "uuid_len",  # uuid is set to be the same on styler and clean_copy
  343:         "cell_ids",
  344:         "cellstyle_map",  # execution time only
  345:         "cellstyle_map_columns",  # execution time only
  346:         "cellstyle_map_index",  # execution time only
  347:         "template_latex",  # render templates are class level
  348:         "template_html",
  349:         "template_html_style",
  350:         "template_html_table",
  351:     ]
  352:     # tests vars are not same vals on obj and clean copy before clear (except for excl)
  353:     for attr in [a for a in styler.__dict__ if not (callable(a) or a in excl)]:
  354:         res = getattr(styler, attr) == getattr(clean_copy, attr)
  355:         if hasattr(res, "__iter__") and len(res) > 0:
  356:             assert not all(res)  # some element in iterable differs
  357:         elif hasattr(res, "__iter__") and len(res) == 0:
  358:             pass  # empty array
  359:         else:
  360:             assert not res  # explicit var differs
  361: 
  362:     # test vars have same vales on obj and clean copy after clearing
  363:     styler.clear()
  364:     for attr in [a for a in styler.__dict__ if not callable(a)]:
  365:         res = getattr(styler, attr) == getattr(clean_copy, attr)
  366:         assert all(res) if hasattr(res, "__iter__") else res
  367: 
  368: 
  369: def test_export(mi_styler_comp, mi_styler):
  370:     exp_attrs = [
  371:         "_todo",
  372:         "hide_index_",
  373:         "hide_index_names",
  374:         "hide_columns_",
  375:         "hide_column_names",
  376:         "table_attributes",
  377:         "table_styles",
  378:         "css",
  379:     ]
  380:     for attr in exp_attrs:
  381:         check = getattr(mi_styler, attr) == getattr(mi_styler_comp, attr)
  382:         assert not (
  383:             all(check) if (hasattr(check, "__iter__") and len(check) > 0) else check
  384:         )
  385: 
  386:     export = mi_styler_comp.export()
  387:     used = mi_styler.use(export)
  388:     for attr in exp_attrs:
  389:         check = getattr(used, attr) == getattr(mi_styler_comp, attr)
  390:         assert all(check) if (hasattr(check, "__iter__") and len(check) > 0) else check
  391: 
  392:     used.to_html()
  393: 
  394: 
  395: def test_hide_raises(mi_styler):
  396:     msg = "`subset` and `level` cannot be passed simultaneously"
  397:     with pytest.raises(ValueError, match=msg):
  398:         mi_styler.hide(axis="index", subset="something", level="something else")
  399: 
  400:     msg = "`level` must be of type `int`, `str` or list of such"
  401:     with pytest.raises(ValueError, match=msg):
  402:         mi_styler.hide(axis="index", level={"bad": 1, "type": 2})
  403: 
  404: 
  405: @pytest.mark.parametrize("level", [1, "one", [1], ["one"]])
  406: def test_hide_index_level(mi_styler, level):
  407:     mi_styler.index.names, mi_styler.columns.names = ["zero", "one"], ["zero", "one"]
  408:     ctx = mi_styler.hide(axis="index", level=level)._translate(False, True)
  409:     assert len(ctx["head"][0]) == 3
  410:     assert len(ctx["head"][1]) == 3
  411:     assert len(ctx["head"][2]) == 4
  412:     assert ctx["head"][2][0]["is_visible"]
  413:     assert not ctx["head"][2][1]["is_visible"]
  414: 
  415:     assert ctx["body"][0][0]["is_visible"]
  416:     assert not ctx["body"][0][1]["is_visible"]
  417:     assert ctx["body"][1][0]["is_visible"]
  418:     assert not ctx["body"][1][1]["is_visible"]
  419: 
  420: 
  421: @pytest.mark.parametrize("level", [1, "one", [1], ["one"]])
  422: @pytest.mark.parametrize("names", [True, False])
  423: def test_hide_columns_level(mi_styler, level, names):
  424:     mi_styler.columns.names = ["zero", "one"]
  425:     if names:
  426:         mi_styler.index.names = ["zero", "one"]
  427:     ctx = mi_styler.hide(axis="columns", level=level)._translate(True, False)
  428:     assert len(ctx["head"]) == (2 if names else 1)
  429: 
  430: 
  431: @pytest.mark.parametrize("method", ["map", "apply"])
  432: @pytest.mark.parametrize("axis", ["index", "columns"])
  433: def test_apply_map_header(method, axis):
  434:     # GH 41893
  435:     df = DataFrame({"A": [0, 0], "B": [1, 1]}, index=["C", "D"])
  436:     func = {
  437:         "apply": lambda s: ["attr: val" if ("A" in v or "C" in v) else "" for v in s],
  438:         "map": lambda v: "attr: val" if ("A" in v or "C" in v) else "",
  439:     }
  440: 
  441:     # test execution added to todo
  442:     result = getattr(df.style, f"{method}_index")(func[method], axis=axis)
  443:     assert len(result._todo) == 1
  444:     assert len(getattr(result, f"ctx_{axis}")) == 0
  445: 
  446:     # test ctx object on compute
  447:     result._compute()
  448:     expected = {
  449:         (0, 0): [("attr", "val")],
  450:     }
  451:     assert getattr(result, f"ctx_{axis}") == expected
  452: 
  453: 
  454: @pytest.mark.parametrize("method", ["apply", "map"])
  455: @pytest.mark.parametrize("axis", ["index", "columns"])
  456: def test_apply_map_header_mi(mi_styler, method, axis):
  457:     # GH 41893
  458:     func = {
  459:         "apply": lambda s: ["attr: val;" if "b" in v else "" for v in s],
  460:         "map": lambda v: "attr: val" if "b" in v else "",
  461:     }
  462:     result = getattr(mi_styler, f"{method}_index")(func[method], axis=axis)._compute()
  463:     expected = {(1, 1): [("attr", "val")]}
  464:     assert getattr(result, f"ctx_{axis}") == expected
  465: 
  466: 
  467: def test_apply_map_header_raises(mi_styler):
  468:     # GH 41893
  469:     with pytest.raises(ValueError, match="No axis named bad for object type DataFrame"):
  470:         mi_styler.map_index(lambda v: "attr: val;", axis="bad")._compute()
  471: 
  472: 
  473: class TestStyler:
  474:     def test_init_non_pandas(self):
  475:         msg = "``data`` must be a Series or DataFrame"
  476:         with pytest.raises(TypeError, match=msg):
  477:             Styler([1, 2, 3])
  478: 
  479:     def test_init_series(self):
  480:         result = Styler(Series([1, 2]))
  481:         assert result.data.ndim == 2
  482: 
  483:     def test_repr_html_ok(self, styler):
  484:         styler._repr_html_()
  485: 
  486:     def test_repr_html_mathjax(self, styler):
  487:         # gh-19824 / 41395
  488:         assert "tex2jax_ignore" not in styler._repr_html_()
  489: 
  490:         with option_context("styler.html.mathjax", False):
  491:             assert "tex2jax_ignore" in styler._repr_html_()
  492: 
  493:     def test_update_ctx(self, styler):
  494:         styler._update_ctx(DataFrame({"A": ["color: red", "color: blue"]}))
  495:         expected = {(0, 0): [("color", "red")], (1, 0): [("color", "blue")]}
  496:         assert styler.ctx == expected
  497: 
  498:     def test_update_ctx_flatten_multi_and_trailing_semi(self, styler):
  499:         attrs = DataFrame({"A": ["color: red; foo: bar", "color:blue ; foo: baz;"]})
  500:         styler._update_ctx(attrs)
  501:         expected = {
  502:             (0, 0): [("color", "red"), ("foo", "bar")],
  503:             (1, 0): [("color", "blue"), ("foo", "baz")],
  504:         }
  505:         assert styler.ctx == expected
  506: 
  507:     def test_render(self):
  508:         df = DataFrame({"A": [0, 1]})
  509:         style = lambda x: Series(["color: red", "color: blue"], name=x.name)
  510:         s = Styler(df, uuid="AB").apply(style)
  511:         s.to_html()
  512:         # it worked?
  513: 
  514:     def test_multiple_render(self, df):
  515:         # GH 39396
  516:         s = Styler(df, uuid_len=0).map(lambda x: "color: red;", subset=["A"])
  517:         s.to_html()  # do 2 renders to ensure css styles not duplicated
  518:         assert (
  519:             '<style type="text/css">\n#T__row0_col0, #T__row1_col0 {\n'
  520:             "  color: red;\n}\n</style>" in s.to_html()
  521:         )
  522: 
  523:     def test_render_empty_dfs(self):
  524:         empty_df = DataFrame()
  525:         es = Styler(empty_df)
  526:         es.to_html()
  527:         # An index but no columns
  528:         DataFrame(columns=["a"]).style.to_html()
  529:         # A column but no index
  530:         DataFrame(index=["a"]).style.to_html()
  531:         # No IndexError raised?
  532: 
  533:     def test_render_double(self):
  534:         df = DataFrame({"A": [0, 1]})
  535:         style = lambda x: Series(
  536:             ["color: red; border: 1px", "color: blue; border: 2px"], name=x.name
  537:         )
  538:         s = Styler(df, uuid="AB").apply(style)
  539:         s.to_html()
  540:         # it worked?
  541: 
  542:     def test_set_properties(self):
  543:         df = DataFrame({"A": [0, 1]})
  544:         result = df.style.set_properties(color="white", size="10px")._compute().ctx
  545:         # order is deterministic
  546:         v = [("color", "white"), ("size", "10px")]
  547:         expected = {(0, 0): v, (1, 0): v}
  548:         assert result.keys() == expected.keys()
  549:         for v1, v2 in zip(result.values(), expected.values()):
  550:             assert sorted(v1) == sorted(v2)
  551: 
  552:     def test_set_properties_subset(self):
  553:         df = DataFrame({"A": [0, 1]})
  554:         result = (
  555:             df.style.set_properties(subset=IndexSlice[0, "A"], color="white")
  556:             ._compute()
  557:             .ctx
  558:         )
  559:         expected = {(0, 0): [("color", "white")]}
  560:         assert result == expected
  561: 
  562:     def test_empty_index_name_doesnt_display(self, blank_value):
  563:         # https://github.com/pandas-dev/pandas/pull/12090#issuecomment-180695902
  564:         df = DataFrame({"A": [1, 2], "B": [3, 4], "C": [5, 6]})
  565:         result = df.style._translate(True, True)
  566:         assert len(result["head"]) == 1
  567:         expected = {
  568:             "class": "blank level0",
  569:             "type": "th",
  570:             "value": blank_value,
  571:             "is_visible": True,
  572:             "display_value": blank_value,
  573:         }
  574:         assert expected.items() <= result["head"][0][0].items()
  575: 
  576:     def test_index_name(self):
  577:         # https://github.com/pandas-dev/pandas/issues/11655
  578:         df = DataFrame({"A": [1, 2], "B": [3, 4], "C": [5, 6]})
  579:         result = df.set_index("A").style._translate(True, True)
  580:         expected = {
  581:             "class": "index_name level0",
  582:             "type": "th",
  583:             "value": "A",
  584:             "is_visible": True,
  585:             "display_value": "A",
  586:         }
  587:         assert expected.items() <= result["head"][1][0].items()
  588: 
  589:     def test_numeric_columns(self):
  590:         # https://github.com/pandas-dev/pandas/issues/12125
  591:         # smoke test for _translate
  592:         df = DataFrame({0: [1, 2, 3]})
  593:         df.style._translate(True, True)
  594: 
  595:     def test_apply_axis(self):
  596:         df = DataFrame({"A": [0, 0], "B": [1, 1]})
  597:         f = lambda x: [f"val: {x.max()}" for v in x]
  598:         result = df.style.apply(f, axis=1)
  599:         assert len(result._todo) == 1
  600:         assert len(result.ctx) == 0
  601:         result._compute()
  602:         expected = {
  603:             (0, 0): [("val", "1")],
  604:             (0, 1): [("val", "1")],
  605:             (1, 0): [("val", "1")],
  606:             (1, 1): [("val", "1")],
  607:         }
  608:         assert result.ctx == expected
  609: 
  610:         result = df.style.apply(f, axis=0)
  611:         expected = {
  612:             (0, 0): [("val", "0")],
  613:             (0, 1): [("val", "1")],
  614:             (1, 0): [("val", "0")],
  615:             (1, 1): [("val", "1")],
  616:         }
  617:         result._compute()
  618:         assert result.ctx == expected
  619:         result = df.style.apply(f)  # default
  620:         result._compute()
  621:         assert result.ctx == expected
  622: 
  623:     @pytest.mark.parametrize("axis", [0, 1])
  624:     def test_apply_series_return(self, axis):
  625:         # GH 42014
  626:         df = DataFrame([[1, 2], [3, 4]], index=["X", "Y"], columns=["X", "Y"])
  627: 
  628:         # test Series return where len(Series) < df.index or df.columns but labels OK
  629:         func = lambda s: Series(["color: red;"], index=["Y"])
  630:         result = df.style.apply(func, axis=axis)._compute().ctx
  631:         assert result[(1, 1)] == [("color", "red")]
  632:         assert result[(1 - axis, axis)] == [("color", "red")]
  633: 
  634:         # test Series return where labels align but different order
  635:         func = lambda s: Series(["color: red;", "color: blue;"], index=["Y", "X"])
  636:         result = df.style.apply(func, axis=axis)._compute().ctx
  637:         assert result[(0, 0)] == [("color", "blue")]
  638:         assert result[(1, 1)] == [("color", "red")]
  639:         assert result[(1 - axis, axis)] == [("color", "red")]
  640:         assert result[(axis, 1 - axis)] == [("color", "blue")]
  641: 
  642:     @pytest.mark.parametrize("index", [False, True])
  643:     @pytest.mark.parametrize("columns", [False, True])
  644:     def test_apply_dataframe_return(self, index, columns):
  645:         # GH 42014
  646:         df = DataFrame([[1, 2], [3, 4]], index=["X", "Y"], columns=["X", "Y"])
  647:         idxs = ["X", "Y"] if index else ["Y"]
  648:         cols = ["X", "Y"] if columns else ["Y"]
  649:         df_styles = DataFrame("color: red;", index=idxs, columns=cols)
  650:         result = df.style.apply(lambda x: df_styles, axis=None)._compute().ctx
  651: 
  652:         assert result[(1, 1)] == [("color", "red")]  # (Y,Y) styles always present
  653:         assert (result[(0, 1)] == [("color", "red")]) is index  # (X,Y) only if index
  654:         assert (result[(1, 0)] == [("color", "red")]) is columns  # (Y,X) only if cols
  655:         assert (result[(0, 0)] == [("color", "red")]) is (index and columns)  # (X,X)
  656: 
  657:     @pytest.mark.parametrize(
  658:         "slice_",
  659:         [
  660:             IndexSlice[:],
  661:             IndexSlice[:, ["A"]],
  662:             IndexSlice[[1], :],
  663:             IndexSlice[[1], ["A"]],
  664:             IndexSlice[:2, ["A", "B"]],
  665:         ],
  666:     )
  667:     @pytest.mark.parametrize("axis", [0, 1])
  668:     def test_apply_subset(self, slice_, axis, df):
  669:         def h(x, color="bar"):
  670:             return Series(f"color: {color}", index=x.index, name=x.name)
  671: 
  672:         result = df.style.apply(h, axis=axis, subset=slice_, color="baz")._compute().ctx
  673:         expected = {
  674:             (r, c): [("color", "baz")]
  675:             for r, row in enumerate(df.index)
  676:             for c, col in enumerate(df.columns)
  677:             if row in df.loc[slice_].index and col in df.loc[slice_].columns
  678:         }
  679:         assert result == expected
  680: 
  681:     @pytest.mark.parametrize(
  682:         "slice_",
  683:         [
  684:             IndexSlice[:],
  685:             IndexSlice[:, ["A"]],
  686:             IndexSlice[[1], :],
  687:             IndexSlice[[1], ["A"]],
  688:             IndexSlice[:2, ["A", "B"]],
  689:         ],
  690:     )
  691:     def test_map_subset(self, slice_, df):
  692:         result = df.style.map(lambda x: "color:baz;", subset=slice_)._compute().ctx
  693:         expected = {
  694:             (r, c): [("color", "baz")]
  695:             for r, row in enumerate(df.index)
  696:             for c, col in enumerate(df.columns)
  697:             if row in df.loc[slice_].index and col in df.loc[slice_].columns
  698:         }
  699:         assert result == expected
  700: 
  701:     @pytest.mark.parametrize(
  702:         "slice_",
  703:         [
  704:             IndexSlice[:, IndexSlice["x", "A"]],
  705:             IndexSlice[:, IndexSlice[:, "A"]],
  706:             IndexSlice[:, IndexSlice[:, ["A", "C"]]],  # missing col element
  707:             IndexSlice[IndexSlice["a", 1], :],
  708:             IndexSlice[IndexSlice[:, 1], :],
  709:             IndexSlice[IndexSlice[:, [1, 3]], :],  # missing row element
  710:             IndexSlice[:, ("x", "A")],
  711:             IndexSlice[("a", 1), :],
  712:         ],
  713:     )
  714:     def test_map_subset_multiindex(self, slice_):
  715:         # GH 19861
  716:         # edited for GH 33562
  717:         if (
  718:             isinstance(slice_[-1], tuple)
  719:             and isinstance(slice_[-1][-1], list)
  720:             and "C" in slice_[-1][-1]
  721:         ):
  722:             ctx = pytest.raises(KeyError, match="C")
  723:         elif (
  724:             isinstance(slice_[0], tuple)
  725:             and isinstance(slice_[0][1], list)
  726:             and 3 in slice_[0][1]
  727:         ):
  728:             ctx = pytest.raises(KeyError, match="3")
  729:         else:
  730:             ctx = contextlib.nullcontext()
  731: 
  732:         idx = MultiIndex.from_product([["a", "b"], [1, 2]])
  733:         col = MultiIndex.from_product([["x", "y"], ["A", "B"]])
  734:         df = DataFrame(np.random.default_rng(2).random((4, 4)), columns=col, index=idx)
  735: 
  736:         with ctx:
  737:             df.style.map(lambda x: "color: red;", subset=slice_).to_html()
  738: 
  739:     def test_map_subset_multiindex_code(self):
  740:         # https://github.com/pandas-dev/pandas/issues/25858
  741:         # Checks styler.map works with multindex when codes are provided
  742:         codes = np.array([[0, 0, 1, 1], [0, 1, 0, 1]])
  743:         columns = MultiIndex(
  744:             levels=[["a", "b"], ["%", "#"]], codes=codes, names=["", ""]
  745:         )
  746:         df = DataFrame(
  747:             [[1, -1, 1, 1], [-1, 1, 1, 1]], index=["hello", "world"], columns=columns
  748:         )
  749:         pct_subset = IndexSlice[:, IndexSlice[:, "%":"%"]]
  750: 
  751:         def color_negative_red(val):
  752:             color = "red" if val < 0 else "black"
  753:             return f"color: {color}"
  754: 
  755:         df.loc[pct_subset]
  756:         df.style.map(color_negative_red, subset=pct_subset)
  757: 
  758:     @pytest.mark.parametrize(
  759:         "stylefunc", ["background_gradient", "bar", "text_gradient"]
  760:     )
  761:     def test_subset_for_boolean_cols(self, stylefunc):
  762:         # GH47838
  763:         df = DataFrame(
  764:             [
  765:                 [1, 2],
  766:                 [3, 4],
  767:             ],
  768:             columns=[False, True],
  769:         )
  770:         styled = getattr(df.style, stylefunc)()
  771:         styled._compute()
  772:         assert set(styled.ctx) == {(0, 0), (0, 1), (1, 0), (1, 1)}
  773: 
  774:     def test_empty(self):
  775:         df = DataFrame({"A": [1, 0]})
  776:         s = df.style
  777:         s.ctx = {(0, 0): [("color", "red")], (1, 0): [("", "")]}
  778: 
  779:         result = s._translate(True, True)["cellstyle"]
  780:         expected = [
  781:             {"props": [("color", "red")], "selectors": ["row0_col0"]},
  782:             {"props": [("", "")], "selectors": ["row1_col0"]},
  783:         ]
  784:         assert result == expected
  785: 
  786:     def test_duplicate(self):
  787:         df = DataFrame({"A": [1, 0]})
  788:         s = df.style
  789:         s.ctx = {(0, 0): [("color", "red")], (1, 0): [("color", "red")]}
  790: 
  791:         result = s._translate(True, True)["cellstyle"]
  792:         expected = [
  793:             {"props": [("color", "red")], "selectors": ["row0_col0", "row1_col0"]}
  794:         ]
  795:         assert result == expected
  796: 
  797:     def test_init_with_na_rep(self):
  798:         # GH 21527 28358
  799:         df = DataFrame([[None, None], [1.1, 1.2]], columns=["A", "B"])
  800: 
  801:         ctx = Styler(df, na_rep="NA")._translate(True, True)
  802:         assert ctx["body"][0][1]["display_value"] == "NA"
  803:         assert ctx["body"][0][2]["display_value"] == "NA"
  804: 
  805:     def test_caption(self, df):
  806:         styler = Styler(df, caption="foo")
  807:         result = styler.to_html()
  808:         assert all(["caption" in result, "foo" in result])
  809: 
  810:         styler = df.style
  811:         result = styler.set_caption("baz")
  812:         assert styler is result
  813:         assert styler.caption == "baz"
  814: 
  815:     def test_uuid(self, df):
  816:         styler = Styler(df, uuid="abc123")
  817:         result = styler.to_html()
  818:         assert "abc123" in result
  819: 
  820:         styler = df.style
  821:         result = styler.set_uuid("aaa")
  822:         assert result is styler
  823:         assert result.uuid == "aaa"
  824: 
  825:     def test_unique_id(self):
  826:         # See https://github.com/pandas-dev/pandas/issues/16780
  827:         df = DataFrame({"a": [1, 3, 5, 6], "b": [2, 4, 12, 21]})
  828:         result = df.style.to_html(uuid="test")
  829:         assert "test" in result
  830:         ids = re.findall('id="(.*?)"', result)
  831:         assert np.unique(ids).size == len(ids)
  832: 
  833:     def test_table_styles(self, df):
  834:         style = [{"selector": "th", "props": [("foo", "bar")]}]  # default format
  835:         styler = Styler(df, table_styles=style)
  836:         result = " ".join(styler.to_html().split())
  837:         assert "th { foo: bar; }" in result
  838: 
  839:         styler = df.style
  840:         result = styler.set_table_styles(style)
  841:         assert styler is result
  842:         assert styler.table_styles == style
  843: 
  844:         # GH 39563
  845:         style = [{"selector": "th", "props": "foo:bar;"}]  # css string format
  846:         styler = df.style.set_table_styles(style)
  847:         result = " ".join(styler.to_html().split())
  848:         assert "th { foo: bar; }" in result
  849: 
  850:     def test_table_styles_multiple(self, df):
  851:         ctx = df.style.set_table_styles(
  852:             [
  853:                 {"selector": "th,td", "props": "color:red;"},
  854:                 {"selector": "tr", "props": "color:green;"},
  855:             ]
  856:         )._translate(True, True)["table_styles"]
  857:         assert ctx == [
  858:             {"selector": "th", "props": [("color", "red")]},
  859:             {"selector": "td", "props": [("color", "red")]},
  860:             {"selector": "tr", "props": [("color", "green")]},
  861:         ]
  862: 
  863:     def test_table_styles_dict_multiple_selectors(self, df):
  864:         # GH 44011
  865:         result = df.style.set_table_styles(
  866:             {
  867:                 "B": [
  868:                     {"selector": "th,td", "props": [("border-left", "2px solid black")]}
  869:                 ]
  870:             }
  871:         )._translate(True, True)["table_styles"]
  872: 
  873:         expected = [
  874:             {"selector": "th.col1", "props": [("border-left", "2px solid black")]},
  875:             {"selector": "td.col1", "props": [("border-left", "2px solid black")]},
  876:         ]
  877: 
  878:         assert result == expected
  879: 
  880:     def test_maybe_convert_css_to_tuples(self):
  881:         expected = [("a", "b"), ("c", "d e")]
  882:         assert maybe_convert_css_to_tuples("a:b;c:d e;") == expected
  883:         assert maybe_convert_css_to_tuples("a: b ;c:  d e  ") == expected
  884:         expected = []
  885:         assert maybe_convert_css_to_tuples("") == expected
  886: 
  887:     def test_maybe_convert_css_to_tuples_err(self):
  888:         msg = "Styles supplied as string must follow CSS rule formats"
  889:         with pytest.raises(ValueError, match=msg):
  890:             maybe_convert_css_to_tuples("err")
  891: 
  892:     def test_table_attributes(self, df):
  893:         attributes = 'class="foo" data-bar'
  894:         styler = Styler(df, table_attributes=attributes)
  895:         result = styler.to_html()
  896:         assert 'class="foo" data-bar' in result
  897: 
  898:         result = df.style.set_table_attributes(attributes).to_html()
  899:         assert 'class="foo" data-bar' in result
  900: 
  901:     def test_apply_none(self):
  902:         def f(x):
  903:             return DataFrame(
  904:                 np.where(x == x.max(), "color: red", ""),
  905:                 index=x.index,
  906:                 columns=x.columns,
  907:             )
  908: 
  909:         result = DataFrame([[1, 2], [3, 4]]).style.apply(f, axis=None)._compute().ctx
  910:         assert result[(1, 1)] == [("color", "red")]
  911: 
  912:     def test_trim(self, df):
  913:         result = df.style.to_html()  # trim=True
  914:         assert result.count("#") == 0
  915: 
  916:         result = df.style.highlight_max().to_html()
  917:         assert result.count("#") == len(df.columns)
  918: 
  919:     def test_export(self, df, styler):
  920:         f = lambda x: "color: red" if x > 0 else "color: blue"
  921:         g = lambda x, z: f"color: {z}" if x > 0 else f"color: {z}"
  922:         style1 = styler
  923:         style1.map(f).map(g, z="b").highlight_max()._compute()  # = render
  924:         result = style1.export()
  925:         style2 = df.style
  926:         style2.use(result)
  927:         assert style1._todo == style2._todo
  928:         style2.to_html()
  929: 
  930:     def test_bad_apply_shape(self):
  931:         df = DataFrame([[1, 2], [3, 4]], index=["A", "B"], columns=["X", "Y"])
  932: 
  933:         msg = "resulted in the apply method collapsing to a Series."
  934:         with pytest.raises(ValueError, match=msg):
  935:             df.style._apply(lambda x: "x")
  936: 
  937:         msg = "created invalid {} labels"
  938:         with pytest.raises(ValueError, match=msg.format("index")):
  939:             df.style._apply(lambda x: [""])
  940: 
  941:         with pytest.raises(ValueError, match=msg.format("index")):
  942:             df.style._apply(lambda x: ["", "", "", ""])
  943: 
  944:         with pytest.raises(ValueError, match=msg.format("index")):
  945:             df.style._apply(lambda x: Series(["a:v;", ""], index=["A", "C"]), axis=0)
  946: 
  947:         with pytest.raises(ValueError, match=msg.format("columns")):
  948:             df.style._apply(lambda x: ["", "", ""], axis=1)
  949: 
  950:         with pytest.raises(ValueError, match=msg.format("columns")):
  951:             df.style._apply(lambda x: Series(["a:v;", ""], index=["X", "Z"]), axis=1)
  952: 
  953:         msg = "returned ndarray with wrong shape"
  954:         with pytest.raises(ValueError, match=msg):
  955:             df.style._apply(lambda x: np.array([[""], [""]]), axis=None)
  956: 
  957:     def test_apply_bad_return(self):
  958:         def f(x):
  959:             return ""
  960: 
  961:         df = DataFrame([[1, 2], [3, 4]])
  962:         msg = (
  963:             "must return a DataFrame or ndarray when passed to `Styler.apply` "
  964:             "with axis=None"
  965:         )
  966:         with pytest.raises(TypeError, match=msg):
  967:             df.style._apply(f, axis=None)
  968: 
  969:     @pytest.mark.parametrize("axis", ["index", "columns"])
  970:     def test_apply_bad_labels(self, axis):
  971:         def f(x):
  972:             return DataFrame(**{axis: ["bad", "labels"]})
  973: 
  974:         df = DataFrame([[1, 2], [3, 4]])
  975:         msg = f"created invalid {axis} labels."
  976:         with pytest.raises(ValueError, match=msg):
  977:             df.style._apply(f, axis=None)
  978: 
  979:     def test_get_level_lengths(self):
  980:         index = MultiIndex.from_product([["a", "b"], [0, 1, 2]])
  981:         expected = {
  982:             (0, 0): 3,
  983:             (0, 3): 3,
  984:             (1, 0): 1,
  985:             (1, 1): 1,
  986:             (1, 2): 1,
  987:             (1, 3): 1,
  988:             (1, 4): 1,
  989:             (1, 5): 1,
  990:         }
  991:         result = _get_level_lengths(index, sparsify=True, max_index=100)
  992:         tm.assert_dict_equal(result, expected)
  993: 
  994:         expected = {
  995:             (0, 0): 1,
  996:             (0, 1): 1,
  997:             (0, 2): 1,
  998:             (0, 3): 1,
  999:             (0, 4): 1,
 1000:             (0, 5): 1,
 1001:             (1, 0): 1,
 1002:             (1, 1): 1,
 1003:             (1, 2): 1,
 1004:             (1, 3): 1,
 1005:             (1, 4): 1,
 1006:             (1, 5): 1,
 1007:         }
 1008:         result = _get_level_lengths(index, sparsify=False, max_index=100)
 1009:         tm.assert_dict_equal(result, expected)
 1010: 
 1011:     def test_get_level_lengths_un_sorted(self):
 1012:         index = MultiIndex.from_arrays([[1, 1, 2, 1], ["a", "b", "b", "d"]])
 1013:         expected = {
 1014:             (0, 0): 2,
 1015:             (0, 2): 1,
 1016:             (0, 3): 1,
 1017:             (1, 0): 1,
 1018:             (1, 1): 1,
 1019:             (1, 2): 1,
 1020:             (1, 3): 1,
 1021:         }
 1022:         result = _get_level_lengths(index, sparsify=True, max_index=100)
 1023:         tm.assert_dict_equal(result, expected)
 1024: 
 1025:         expected = {
 1026:             (0, 0): 1,
 1027:             (0, 1): 1,
 1028:             (0, 2): 1,
 1029:             (0, 3): 1,
 1030:             (1, 0): 1,
 1031:             (1, 1): 1,
 1032:             (1, 2): 1,
 1033:             (1, 3): 1,
 1034:         }
 1035:         result = _get_level_lengths(index, sparsify=False, max_index=100)
 1036:         tm.assert_dict_equal(result, expected)
 1037: 
 1038:     def test_mi_sparse_index_names(self, blank_value):
 1039:         # Test the class names and displayed value are correct on rendering MI names
 1040:         df = DataFrame(
 1041:             {"A": [1, 2]},
 1042:             index=MultiIndex.from_arrays(
 1043:                 [["a", "a"], [0, 1]], names=["idx_level_0", "idx_level_1"]
 1044:             ),
 1045:         )
 1046:         result = df.style._translate(True, True)
 1047:         head = result["head"][1]
 1048:         expected = [
 1049:             {
 1050:                 "class": "index_name level0",
 1051:                 "display_value": "idx_level_0",
 1052:                 "is_visible": True,
 1053:             },
 1054:             {
 1055:                 "class": "index_name level1",
 1056:                 "display_value": "idx_level_1",
 1057:                 "is_visible": True,
 1058:             },
 1059:             {
 1060:                 "class": "blank col0",
 1061:                 "display_value": blank_value,
 1062:                 "is_visible": True,
 1063:             },
 1064:         ]
 1065:         for i, expected_dict in enumerate(expected):
 1066:             assert expected_dict.items() <= head[i].items()
 1067: 
 1068:     def test_mi_sparse_column_names(self, blank_value):
 1069:         df = DataFrame(
 1070:             np.arange(16).reshape(4, 4),
 1071:             index=MultiIndex.from_arrays(
 1072:                 [["a", "a", "b", "a"], [0, 1, 1, 2]],
 1073:                 names=["idx_level_0", "idx_level_1"],
 1074:             ),
 1075:             columns=MultiIndex.from_arrays(
 1076:                 [["C1", "C1", "C2", "C2"], [1, 0, 1, 0]], names=["colnam_0", "colnam_1"]
 1077:             ),
 1078:         )
 1079:         result = Styler(df, cell_ids=False)._translate(True, True)
 1080: 
 1081:         for level in [0, 1]:
 1082:             head = result["head"][level]
 1083:             expected = [
 1084:                 {
 1085:                     "class": "blank",
 1086:                     "display_value": blank_value,
 1087:                     "is_visible": True,
 1088:                 },
 1089:                 {
 1090:                     "class": f"index_name level{level}",
 1091:                     "display_value": f"colnam_{level}",
 1092:                     "is_visible": True,
 1093:                 },
 1094:             ]
 1095:             for i, expected_dict in enumerate(expected):
 1096:                 assert expected_dict.items() <= head[i].items()
 1097: 
 1098:     def test_hide_column_headers(self, df, styler):
 1099:         ctx = styler.hide(axis="columns")._translate(True, True)
 1100:         assert len(ctx["head"]) == 0  # no header entries with an unnamed index
 1101: 
 1102:         df.index.name = "some_name"
 1103:         ctx = df.style.hide(axis="columns")._translate(True, True)
 1104:         assert len(ctx["head"]) == 1
 1105:         # index names still visible, changed in #42101, reverted in 43404
 1106: 
 1107:     def test_hide_single_index(self, df):
 1108:         # GH 14194
 1109:         # single unnamed index
 1110:         ctx = df.style._translate(True, True)
 1111:         assert ctx["body"][0][0]["is_visible"]
 1112:         assert ctx["head"][0][0]["is_visible"]
 1113:         ctx2 = df.style.hide(axis="index")._translate(True, True)
 1114:         assert not ctx2["body"][0][0]["is_visible"]
 1115:         assert not ctx2["head"][0][0]["is_visible"]
 1116: 
 1117:         # single named index
 1118:         ctx3 = df.set_index("A").style._translate(True, True)
 1119:         assert ctx3["body"][0][0]["is_visible"]
 1120:         assert len(ctx3["head"]) == 2  # 2 header levels
 1121:         assert ctx3["head"][0][0]["is_visible"]
 1122: 
 1123:         ctx4 = df.set_index("A").style.hide(axis="index")._translate(True, True)
 1124:         assert not ctx4["body"][0][0]["is_visible"]
 1125:         assert len(ctx4["head"]) == 1  # only 1 header levels
 1126:         assert not ctx4["head"][0][0]["is_visible"]
 1127: 
 1128:     def test_hide_multiindex(self):
 1129:         # GH 14194
 1130:         df = DataFrame(
 1131:             {"A": [1, 2], "B": [1, 2]},
 1132:             index=MultiIndex.from_arrays(
 1133:                 [["a", "a"], [0, 1]], names=["idx_level_0", "idx_level_1"]
 1134:             ),
 1135:         )
 1136:         ctx1 = df.style._translate(True, True)
 1137:         # tests for 'a' and '0'
 1138:         assert ctx1["body"][0][0]["is_visible"]
 1139:         assert ctx1["body"][0][1]["is_visible"]
 1140:         # check for blank header rows
 1141:         assert len(ctx1["head"][0]) == 4  # two visible indexes and two data columns
 1142: 
 1143:         ctx2 = df.style.hide(axis="index")._translate(True, True)
 1144:         # tests for 'a' and '0'
 1145:         assert not ctx2["body"][0][0]["is_visible"]
 1146:         assert not ctx2["body"][0][1]["is_visible"]
 1147:         # check for blank header rows
 1148:         assert len(ctx2["head"][0]) == 3  # one hidden (col name) and two data columns
 1149:         assert not ctx2["head"][0][0]["is_visible"]
 1150: 
 1151:     def test_hide_columns_single_level(self, df):
 1152:         # GH 14194
 1153:         # test hiding single column
 1154:         ctx = df.style._translate(True, True)
 1155:         assert ctx["head"][0][1]["is_visible"]
 1156:         assert ctx["head"][0][1]["display_value"] == "A"
 1157:         assert ctx["head"][0][2]["is_visible"]
 1158:         assert ctx["head"][0][2]["display_value"] == "B"
 1159:         assert ctx["body"][0][1]["is_visible"]  # col A, row 1
 1160:         assert ctx["body"][1][2]["is_visible"]  # col B, row 1
 1161: 
 1162:         ctx = df.style.hide("A", axis="columns")._translate(True, True)
 1163:         assert not ctx["head"][0][1]["is_visible"]
 1164:         assert not ctx["body"][0][1]["is_visible"]  # col A, row 1
 1165:         assert ctx["body"][1][2]["is_visible"]  # col B, row 1
 1166: 
 1167:         # test hiding multiple columns
 1168:         ctx = df.style.hide(["A", "B"], axis="columns")._translate(True, True)
 1169:         assert not ctx["head"][0][1]["is_visible"]
 1170:         assert not ctx["head"][0][2]["is_visible"]
 1171:         assert not ctx["body"][0][1]["is_visible"]  # col A, row 1
 1172:         assert not ctx["body"][1][2]["is_visible"]  # col B, row 1
 1173: 
 1174:     def test_hide_columns_index_mult_levels(self):
 1175:         # GH 14194
 1176:         # setup dataframe with multiple column levels and indices
 1177:         i1 = MultiIndex.from_arrays(
 1178:             [["a", "a"], [0, 1]], names=["idx_level_0", "idx_level_1"]
 1179:         )
 1180:         i2 = MultiIndex.from_arrays(
 1181:             [["b", "b"], [0, 1]], names=["col_level_0", "col_level_1"]
 1182:         )
 1183:         df = DataFrame([[1, 2], [3, 4]], index=i1, columns=i2)
 1184:         ctx = df.style._translate(True, True)
 1185:         # column headers
 1186:         assert ctx["head"][0][2]["is_visible"]
 1187:         assert ctx["head"][1][2]["is_visible"]
 1188:         assert ctx["head"][1][3]["display_value"] == "1"
 1189:         # indices
 1190:         assert ctx["body"][0][0]["is_visible"]
 1191:         # data
 1192:         assert ctx["body"][1][2]["is_visible"]
 1193:         assert ctx["body"][1][2]["display_value"] == "3"
 1194:         assert ctx["body"][1][3]["is_visible"]
 1195:         assert ctx["body"][1][3]["display_value"] == "4"
 1196: 
 1197:         # hide top column level, which hides both columns
 1198:         ctx = df.style.hide("b", axis="columns")._translate(True, True)
 1199:         assert not ctx["head"][0][2]["is_visible"]  # b
 1200:         assert not ctx["head"][1][2]["is_visible"]  # 0
 1201:         assert not ctx["body"][1][2]["is_visible"]  # 3
 1202:         assert ctx["body"][0][0]["is_visible"]  # index
 1203: 
 1204:         # hide first column only
 1205:         ctx = df.style.hide([("b", 0)], axis="columns")._translate(True, True)
 1206:         assert not ctx["head"][0][2]["is_visible"]  # b
 1207:         assert ctx["head"][0][3]["is_visible"]  # b
 1208:         assert not ctx["head"][1][2]["is_visible"]  # 0
 1209:         assert not ctx["body"][1][2]["is_visible"]  # 3
 1210:         assert ctx["body"][1][3]["is_visible"]
 1211:         assert ctx["body"][1][3]["display_value"] == "4"
 1212: 
 1213:         # hide second column and index
 1214:         ctx = df.style.hide([("b", 1)], axis=1).hide(axis=0)._translate(True, True)
 1215:         assert not ctx["body"][0][0]["is_visible"]  # index
 1216:         assert len(ctx["head"][0]) == 3
 1217:         assert ctx["head"][0][1]["is_visible"]  # b
 1218:         assert ctx["head"][1][1]["is_visible"]  # 0
 1219:         assert not ctx["head"][1][2]["is_visible"]  # 1
 1220:         assert not ctx["body"][1][3]["is_visible"]  # 4
 1221:         assert ctx["body"][1][2]["is_visible"]
 1222:         assert ctx["body"][1][2]["display_value"] == "3"
 1223: 
 1224:         # hide top row level, which hides both rows so body empty
 1225:         ctx = df.style.hide("a", axis="index")._translate(True, True)
 1226:         assert ctx["body"] == []
 1227: 
 1228:         # hide first row only
 1229:         ctx = df.style.hide(("a", 0), axis="index")._translate(True, True)
 1230:         for i in [0, 1, 2, 3]:
 1231:             assert "row1" in ctx["body"][0][i]["class"]  # row0 not included in body
 1232:             assert ctx["body"][0][i]["is_visible"]
 1233: 
 1234:     def test_pipe(self, df):
 1235:         def set_caption_from_template(styler, a, b):
 1236:             return styler.set_caption(f"Dataframe with a = {a} and b = {b}")
 1237: 
 1238:         styler = df.style.pipe(set_caption_from_template, "A", b="B")
 1239:         assert "Dataframe with a = A and b = B" in styler.to_html()
 1240: 
 1241:         # Test with an argument that is a (callable, keyword_name) pair.
 1242:         def f(a, b, styler):
 1243:             return (a, b, styler)
 1244: 
 1245:         styler = df.style
 1246:         result = styler.pipe((f, "styler"), a=1, b=2)
 1247:         assert result == (1, 2, styler)
 1248: 
 1249:     def test_no_cell_ids(self):
 1250:         # GH 35588
 1251:         # GH 35663
 1252:         df = DataFrame(data=[[0]])
 1253:         styler = Styler(df, uuid="_", cell_ids=False)
 1254:         styler.to_html()
 1255:         s = styler.to_html()  # render twice to ensure ctx is not updated
 1256:         assert s.find('<td class="data row0 col0" >') != -1
 1257: 
 1258:     @pytest.mark.parametrize(
 1259:         "classes",
 1260:         [
 1261:             DataFrame(
 1262:                 data=[["", "test-class"], [np.nan, None]],
 1263:                 columns=["A", "B"],
 1264:                 index=["a", "b"],
 1265:             ),
 1266:             DataFrame(data=[["test-class"]], columns=["B"], index=["a"]),
 1267:             DataFrame(data=[["test-class", "unused"]], columns=["B", "C"], index=["a"]),
 1268:         ],
 1269:     )
 1270:     def test_set_data_classes(self, classes):
 1271:         # GH 36159
 1272:         df = DataFrame(data=[[0, 1], [2, 3]], columns=["A", "B"], index=["a", "b"])
 1273:         s = Styler(df, uuid_len=0, cell_ids=False).set_td_classes(classes).to_html()
 1274:         assert '<td class="data row0 col0" >0</td>' in s
 1275:         assert '<td class="data row0 col1 test-class" >1</td>' in s
 1276:         assert '<td class="data row1 col0" >2</td>' in s
 1277:         assert '<td class="data row1 col1" >3</td>' in s
 1278:         # GH 39317
 1279:         s = Styler(df, uuid_len=0, cell_ids=True).set_td_classes(classes).to_html()
 1280:         assert '<td id="T__row0_col0" class="data row0 col0" >0</td>' in s
 1281:         assert '<td id="T__row0_col1" class="data row0 col1 test-class" >1</td>' in s
 1282:         assert '<td id="T__row1_col0" class="data row1 col0" >2</td>' in s
 1283:         assert '<td id="T__row1_col1" class="data row1 col1" >3</td>' in s
 1284: 
 1285:     def test_set_data_classes_reindex(self):
 1286:         # GH 39317
 1287:         df = DataFrame(
 1288:             data=[[0, 1, 2], [3, 4, 5], [6, 7, 8]], columns=[0, 1, 2], index=[0, 1, 2]
 1289:         )
 1290:         classes = DataFrame(
 1291:             data=[["mi", "ma"], ["mu", "mo"]],
 1292:             columns=[0, 2],
 1293:             index=[0, 2],
 1294:         )
 1295:         s = Styler(df, uuid_len=0).set_td_classes(classes).to_html()
 1296:         assert '<td id="T__row0_col0" class="data row0 col0 mi" >0</td>' in s
 1297:         assert '<td id="T__row0_col2" class="data row0 col2 ma" >2</td>' in s
 1298:         assert '<td id="T__row1_col1" class="data row1 col1" >4</td>' in s
 1299:         assert '<td id="T__row2_col0" class="data row2 col0 mu" >6</td>' in s
 1300:         assert '<td id="T__row2_col2" class="data row2 col2 mo" >8</td>' in s
 1301: 
 1302:     def test_chaining_table_styles(self):
 1303:         # GH 35607
 1304:         df = DataFrame(data=[[0, 1], [1, 2]], columns=["A", "B"])
 1305:         styler = df.style.set_table_styles(
 1306:             [{"selector": "", "props": [("background-color", "yellow")]}]
 1307:         ).set_table_styles(
 1308:             [{"selector": ".col0", "props": [("background-color", "blue")]}],
 1309:             overwrite=False,
 1310:         )
 1311:         assert len(styler.table_styles) == 2
 1312: 
 1313:     def test_column_and_row_styling(self):
 1314:         # GH 35607
 1315:         df = DataFrame(data=[[0, 1], [1, 2]], columns=["A", "B"])
 1316:         s = Styler(df, uuid_len=0)
 1317:         s = s.set_table_styles({"A": [{"selector": "", "props": [("color", "blue")]}]})
 1318:         assert "#T_ .col0 {\n  color: blue;\n}" in s.to_html()
 1319:         s = s.set_table_styles(
 1320:             {0: [{"selector": "", "props": [("color", "blue")]}]}, axis=1
 1321:         )
 1322:         assert "#T_ .row0 {\n  color: blue;\n}" in s.to_html()
 1323: 
 1324:     @pytest.mark.parametrize("len_", [1, 5, 32, 33, 100])
 1325:     def test_uuid_len(self, len_):
 1326:         # GH 36345
 1327:         df = DataFrame(data=[["A"]])
 1328:         s = Styler(df, uuid_len=len_, cell_ids=False).to_html()
 1329:         strt = s.find('id="T_')
 1330:         end = s[strt + 6 :].find('"')
 1331:         if len_ > 32:
 1332:             assert end == 32
 1333:         else:
 1334:             assert end == len_
 1335: 
 1336:     @pytest.mark.parametrize("len_", [-2, "bad", None])
 1337:     def test_uuid_len_raises(self, len_):
 1338:         # GH 36345
 1339:         df = DataFrame(data=[["A"]])
 1340:         msg = "``uuid_len`` must be an integer in range \\[0, 32\\]."
 1341:         with pytest.raises(TypeError, match=msg):
 1342:             Styler(df, uuid_len=len_, cell_ids=False).to_html()
 1343: 
 1344:     @pytest.mark.parametrize(
 1345:         "slc",
 1346:         [
 1347:             IndexSlice[:, :],
 1348:             IndexSlice[:, 1],
 1349:             IndexSlice[1, :],
 1350:             IndexSlice[[1], [1]],
 1351:             IndexSlice[1, [1]],
 1352:             IndexSlice[[1], 1],
 1353:             IndexSlice[1],
 1354:             IndexSlice[1, 1],
 1355:             slice(None, None, None),
 1356:             [0, 1],
 1357:             np.array([0, 1]),
 1358:             Series([0, 1]),
 1359:         ],
 1360:     )
 1361:     def test_non_reducing_slice(self, slc):
 1362:         df = DataFrame([[0, 1], [2, 3]])
 1363: 
 1364:         tslice_ = non_reducing_slice(slc)
 1365:         assert isinstance(df.loc[tslice_], DataFrame)
 1366: 
 1367:     @pytest.mark.parametrize("box", [list, Series, np.array])
 1368:     def test_list_slice(self, box):
 1369:         # like dataframe getitem
 1370:         subset = box(["A"])
 1371: 
 1372:         df = DataFrame({"A": [1, 2], "B": [3, 4]}, index=["A", "B"])
 1373:         expected = IndexSlice[:, ["A"]]
 1374: 
 1375:         result = non_reducing_slice(subset)
 1376:         tm.assert_frame_equal(df.loc[result], df.loc[expected])
 1377: 
 1378:     def test_non_reducing_slice_on_multiindex(self):
 1379:         # GH 19861
 1380:         dic = {
 1381:             ("a", "d"): [1, 4],
 1382:             ("a", "c"): [2, 3],
 1383:             ("b", "c"): [3, 2],
 1384:             ("b", "d"): [4, 1],
 1385:         }
 1386:         df = DataFrame(dic, index=[0, 1])
 1387:         idx = IndexSlice
 1388:         slice_ = idx[:, idx["b", "d"]]
 1389:         tslice_ = non_reducing_slice(slice_)
 1390: 
 1391:         result = df.loc[tslice_]
 1392:         expected = DataFrame({("b", "d"): [4, 1]})
 1393:         tm.assert_frame_equal(result, expected)
 1394: 
 1395:     @pytest.mark.parametrize(
 1396:         "slice_",
 1397:         [
 1398:             IndexSlice[:, :],
 1399:             # check cols
 1400:             IndexSlice[:, IndexSlice[["a"]]],  # inferred deeper need list
 1401:             IndexSlice[:, IndexSlice[["a"], ["c"]]],  # inferred deeper need list
 1402:             IndexSlice[:, IndexSlice["a", "c", :]],
 1403:             IndexSlice[:, IndexSlice["a", :, "e"]],
 1404:             IndexSlice[:, IndexSlice[:, "c", "e"]],
 1405:             IndexSlice[:, IndexSlice["a", ["c", "d"], :]],  # check list
 1406:             IndexSlice[:, IndexSlice["a", ["c", "d", "-"], :]],  # don't allow missing
 1407:             IndexSlice[:, IndexSlice["a", ["c", "d", "-"], "e"]],  # no slice
 1408:             # check rows
 1409:             IndexSlice[IndexSlice[["U"]], :],  # inferred deeper need list
 1410:             IndexSlice[IndexSlice[["U"], ["W"]], :],  # inferred deeper need list
 1411:             IndexSlice[IndexSlice["U", "W", :], :],
 1412:             IndexSlice[IndexSlice["U", :, "Y"], :],
 1413:             IndexSlice[IndexSlice[:, "W", "Y"], :],
 1414:             IndexSlice[IndexSlice[:, "W", ["Y", "Z"]], :],  # check list
 1415:             IndexSlice[IndexSlice[:, "W", ["Y", "Z", "-"]], :],  # don't allow missing
 1416:             IndexSlice[IndexSlice["U", "W", ["Y", "Z", "-"]], :],  # no slice
 1417:             # check simultaneous
 1418:             IndexSlice[IndexSlice[:, "W", "Y"], IndexSlice["a", "c", :]],
 1419:         ],
 1420:     )
 1421:     def test_non_reducing_multi_slice_on_multiindex(self, slice_):
 1422:         # GH 33562
 1423:         cols = MultiIndex.from_product([["a", "b"], ["c", "d"], ["e", "f"]])
 1424:         idxs = MultiIndex.from_product([["U", "V"], ["W", "X"], ["Y", "Z"]])
 1425:         df = DataFrame(np.arange(64).reshape(8, 8), columns=cols, index=idxs)
 1426: 
 1427:         for lvl in [0, 1]:
 1428:             key = slice_[lvl]
 1429:             if isinstance(key, tuple):
 1430:                 for subkey in key:
 1431:                     if isinstance(subkey, list) and "-" in subkey:
 1432:                         # not present in the index level, raises KeyError since 2.0
 1433:                         with pytest.raises(KeyError, match="-"):
 1434:                             df.loc[slice_]
 1435:                         return
 1436: 
 1437:         expected = df.loc[slice_]
 1438:         result = df.loc[non_reducing_slice(slice_)]
 1439:         tm.assert_frame_equal(result, expected)
 1440: 
 1441: 
 1442: def test_hidden_index_names(mi_df):
 1443:     mi_df.index.names = ["Lev0", "Lev1"]
 1444:     mi_styler = mi_df.style
 1445:     ctx = mi_styler._translate(True, True)
 1446:     assert len(ctx["head"]) == 3  # 2 column index levels + 1 index names row
 1447: 
 1448:     mi_styler.hide(axis="index", names=True)
 1449:     ctx = mi_styler._translate(True, True)
 1450:     assert len(ctx["head"]) == 2  # index names row is unparsed
 1451:     for i in range(4):
 1452:         assert ctx["body"][0][i]["is_visible"]  # 2 index levels + 2 data values visible
 1453: 
 1454:     mi_styler.hide(axis="index", level=1)
 1455:     ctx = mi_styler._translate(True, True)
 1456:     assert len(ctx["head"]) == 2  # index names row is still hidden
 1457:     assert ctx["body"][0][0]["is_visible"] is True
 1458:     assert ctx["body"][0][1]["is_visible"] is False
 1459: 
 1460: 
 1461: def test_hidden_column_names(mi_df):
 1462:     mi_df.columns.names = ["Lev0", "Lev1"]
 1463:     mi_styler = mi_df.style
 1464:     ctx = mi_styler._translate(True, True)
 1465:     assert ctx["head"][0][1]["display_value"] == "Lev0"
 1466:     assert ctx["head"][1][1]["display_value"] == "Lev1"
 1467: 
 1468:     mi_styler.hide(names=True, axis="columns")
 1469:     ctx = mi_styler._translate(True, True)
 1470:     assert ctx["head"][0][1]["display_value"] == "&nbsp;"
 1471:     assert ctx["head"][1][1]["display_value"] == "&nbsp;"
 1472: 
 1473:     mi_styler.hide(level=0, axis="columns")
 1474:     ctx = mi_styler._translate(True, True)
 1475:     assert len(ctx["head"]) == 1  # no index names and only one visible column headers
 1476:     assert ctx["head"][0][1]["display_value"] == "&nbsp;"
 1477: 
 1478: 
 1479: @pytest.mark.parametrize("caption", [1, ("a", "b", "c"), (1, "s")])
 1480: def test_caption_raises(mi_styler, caption):
 1481:     msg = "`caption` must be either a string or 2-tuple of strings."
 1482:     with pytest.raises(ValueError, match=msg):
 1483:         mi_styler.set_caption(caption)
 1484: 
 1485: 
 1486: def test_hiding_headers_over_index_no_sparsify():
 1487:     # GH 43464
 1488:     midx = MultiIndex.from_product([[1, 2], ["a", "a", "b"]])
 1489:     df = DataFrame(9, index=midx, columns=[0])
 1490:     ctx = df.style._translate(False, False)
 1491:     assert len(ctx["body"]) == 6
 1492:     ctx = df.style.hide((1, "a"), axis=0)._translate(False, False)
 1493:     assert len(ctx["body"]) == 4
 1494:     assert "row2" in ctx["body"][0][0]["class"]
 1495: 
 1496: 
 1497: def test_hiding_headers_over_columns_no_sparsify():
 1498:     # GH 43464
 1499:     midx = MultiIndex.from_product([[1, 2], ["a", "a", "b"]])
 1500:     df = DataFrame(9, columns=midx, index=[0])
 1501:     ctx = df.style._translate(False, False)
 1502:     for ix in [(0, 1), (0, 2), (1, 1), (1, 2)]:
 1503:         assert ctx["head"][ix[0]][ix[1]]["is_visible"] is True
 1504:     ctx = df.style.hide((1, "a"), axis="columns")._translate(False, False)
 1505:     for ix in [(0, 1), (0, 2), (1, 1), (1, 2)]:
 1506:         assert ctx["head"][ix[0]][ix[1]]["is_visible"] is False
 1507: 
 1508: 
 1509: def test_get_level_lengths_mi_hidden():
 1510:     # GH 43464
 1511:     index = MultiIndex.from_arrays([[1, 1, 1, 2, 2, 2], ["a", "a", "b", "a", "a", "b"]])
 1512:     expected = {
 1513:         (0, 2): 1,
 1514:         (0, 3): 1,
 1515:         (0, 4): 1,
 1516:         (0, 5): 1,
 1517:         (1, 2): 1,
 1518:         (1, 3): 1,
 1519:         (1, 4): 1,
 1520:         (1, 5): 1,
 1521:     }
 1522:     result = _get_level_lengths(
 1523:         index,
 1524:         sparsify=False,
 1525:         max_index=100,
 1526:         hidden_elements=[0, 1, 0, 1],  # hidden element can repeat if duplicated index
 1527:     )
 1528:     tm.assert_dict_equal(result, expected)
 1529: 
 1530: 
 1531: def test_row_trimming_hide_index():
 1532:     # gh 43703
 1533:     df = DataFrame([[1], [2], [3], [4], [5]])
 1534:     with option_context("styler.render.max_rows", 2):
 1535:         ctx = df.style.hide([0, 1], axis="index")._translate(True, True)
 1536:     assert len(ctx["body"]) == 3
 1537:     for r, val in enumerate(["3", "4", "..."]):
 1538:         assert ctx["body"][r][1]["display_value"] == val
 1539: 
 1540: 
 1541: def test_row_trimming_hide_index_mi():
 1542:     # gh 44247
 1543:     df = DataFrame([[1], [2], [3], [4], [5]])
 1544:     df.index = MultiIndex.from_product([[0], [0, 1, 2, 3, 4]])
 1545:     with option_context("styler.render.max_rows", 2):
 1546:         ctx = df.style.hide([(0, 0), (0, 1)], axis="index")._translate(True, True)
 1547:     assert len(ctx["body"]) == 3
 1548: 
 1549:     # level 0 index headers (sparsified)
 1550:     assert {"value": 0, "attributes": 'rowspan="2"', "is_visible": True}.items() <= ctx[
 1551:         "body"
 1552:     ][0][0].items()
 1553:     assert {"value": 0, "attributes": "", "is_visible": False}.items() <= ctx["body"][
 1554:         1
 1555:     ][0].items()
 1556:     assert {"value": "...", "is_visible": True}.items() <= ctx["body"][2][0].items()
 1557: 
 1558:     for r, val in enumerate(["2", "3", "..."]):
 1559:         assert ctx["body"][r][1]["display_value"] == val  # level 1 index headers
 1560:     for r, val in enumerate(["3", "4", "..."]):
 1561:         assert ctx["body"][r][2]["display_value"] == val  # data values
 1562: 
 1563: 
 1564: def test_col_trimming_hide_columns():
 1565:     # gh 44272
 1566:     df = DataFrame([[1, 2, 3, 4, 5]])
 1567:     with option_context("styler.render.max_columns", 2):
 1568:         ctx = df.style.hide([0, 1], axis="columns")._translate(True, True)
 1569: 
 1570:     assert len(ctx["head"][0]) == 6  # blank, [0, 1 (hidden)], [2 ,3 (visible)], + trim
 1571:     for c, vals in enumerate([(1, False), (2, True), (3, True), ("...", True)]):
 1572:         assert ctx["head"][0][c + 2]["value"] == vals[0]
 1573:         assert ctx["head"][0][c + 2]["is_visible"] == vals[1]
 1574: 
 1575:     assert len(ctx["body"][0]) == 6  # index + 2 hidden + 2 visible + trimming col
 1576: 
 1577: 
 1578: def test_no_empty_apply(mi_styler):
 1579:     # 45313
 1580:     mi_styler.apply(lambda s: ["a:v;"] * 2, subset=[False, False])
 1581:     mi_styler._compute()
 1582: 
 1583: 
 1584: @pytest.mark.parametrize("format", ["html", "latex", "string"])
 1585: def test_output_buffer(mi_styler, format):
 1586:     # gh 47053
 1587:     with tm.ensure_clean(f"delete_me.{format}") as f:
 1588:         getattr(mi_styler, f"to_{format}")(f)
