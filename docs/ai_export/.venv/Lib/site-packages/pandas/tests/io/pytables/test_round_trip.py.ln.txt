    1: import datetime
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas._libs.tslibs import Timestamp
    8: from pandas.compat import is_platform_windows
    9: 
   10: import pandas as pd
   11: from pandas import (
   12:     DataFrame,
   13:     DatetimeIndex,
   14:     Index,
   15:     Series,
   16:     _testing as tm,
   17:     bdate_range,
   18:     date_range,
   19:     read_hdf,
   20: )
   21: from pandas.tests.io.pytables.common import (
   22:     _maybe_remove,
   23:     ensure_clean_store,
   24: )
   25: from pandas.util import _test_decorators as td
   26: 
   27: pytestmark = pytest.mark.single_cpu
   28: 
   29: 
   30: def test_conv_read_write():
   31:     with tm.ensure_clean() as path:
   32: 
   33:         def roundtrip(key, obj, **kwargs):
   34:             obj.to_hdf(path, key=key, **kwargs)
   35:             return read_hdf(path, key)
   36: 
   37:         o = Series(
   38:             np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
   39:         )
   40:         tm.assert_series_equal(o, roundtrip("series", o))
   41: 
   42:         o = Series(range(10), dtype="float64", index=[f"i_{i}" for i in range(10)])
   43:         tm.assert_series_equal(o, roundtrip("string_series", o))
   44: 
   45:         o = DataFrame(
   46:             1.1 * np.arange(120).reshape((30, 4)),
   47:             columns=Index(list("ABCD"), dtype=object),
   48:             index=Index([f"i-{i}" for i in range(30)], dtype=object),
   49:         )
   50:         tm.assert_frame_equal(o, roundtrip("frame", o))
   51: 
   52:         # table
   53:         df = DataFrame({"A": range(5), "B": range(5)})
   54:         df.to_hdf(path, key="table", append=True)
   55:         result = read_hdf(path, "table", where=["index>2"])
   56:         tm.assert_frame_equal(df[df.index > 2], result)
   57: 
   58: 
   59: def test_long_strings(setup_path):
   60:     # GH6166
   61:     data = ["a" * 50] * 10
   62:     df = DataFrame({"a": data}, index=data)
   63: 
   64:     with ensure_clean_store(setup_path) as store:
   65:         store.append("df", df, data_columns=["a"])
   66: 
   67:         result = store.select("df")
   68:         tm.assert_frame_equal(df, result)
   69: 
   70: 
   71: def test_api(tmp_path, setup_path):
   72:     # GH4584
   73:     # API issue when to_hdf doesn't accept append AND format args
   74:     path = tmp_path / setup_path
   75: 
   76:     df = DataFrame(range(20))
   77:     df.iloc[:10].to_hdf(path, key="df", append=True, format="table")
   78:     df.iloc[10:].to_hdf(path, key="df", append=True, format="table")
   79:     tm.assert_frame_equal(read_hdf(path, "df"), df)
   80: 
   81:     # append to False
   82:     df.iloc[:10].to_hdf(path, key="df", append=False, format="table")
   83:     df.iloc[10:].to_hdf(path, key="df", append=True, format="table")
   84:     tm.assert_frame_equal(read_hdf(path, "df"), df)
   85: 
   86: 
   87: def test_api_append(tmp_path, setup_path):
   88:     path = tmp_path / setup_path
   89: 
   90:     df = DataFrame(range(20))
   91:     df.iloc[:10].to_hdf(path, key="df", append=True)
   92:     df.iloc[10:].to_hdf(path, key="df", append=True, format="table")
   93:     tm.assert_frame_equal(read_hdf(path, "df"), df)
   94: 
   95:     # append to False
   96:     df.iloc[:10].to_hdf(path, key="df", append=False, format="table")
   97:     df.iloc[10:].to_hdf(path, key="df", append=True)
   98:     tm.assert_frame_equal(read_hdf(path, "df"), df)
   99: 
  100: 
  101: def test_api_2(tmp_path, setup_path):
  102:     path = tmp_path / setup_path
  103: 
  104:     df = DataFrame(range(20))
  105:     df.to_hdf(path, key="df", append=False, format="fixed")
  106:     tm.assert_frame_equal(read_hdf(path, "df"), df)
  107: 
  108:     df.to_hdf(path, key="df", append=False, format="f")
  109:     tm.assert_frame_equal(read_hdf(path, "df"), df)
  110: 
  111:     df.to_hdf(path, key="df", append=False)
  112:     tm.assert_frame_equal(read_hdf(path, "df"), df)
  113: 
  114:     df.to_hdf(path, key="df")
  115:     tm.assert_frame_equal(read_hdf(path, "df"), df)
  116: 
  117:     with ensure_clean_store(setup_path) as store:
  118:         df = DataFrame(range(20))
  119: 
  120:         _maybe_remove(store, "df")
  121:         store.append("df", df.iloc[:10], append=True, format="table")
  122:         store.append("df", df.iloc[10:], append=True, format="table")
  123:         tm.assert_frame_equal(store.select("df"), df)
  124: 
  125:         # append to False
  126:         _maybe_remove(store, "df")
  127:         store.append("df", df.iloc[:10], append=False, format="table")
  128:         store.append("df", df.iloc[10:], append=True, format="table")
  129:         tm.assert_frame_equal(store.select("df"), df)
  130: 
  131:         # formats
  132:         _maybe_remove(store, "df")
  133:         store.append("df", df.iloc[:10], append=False, format="table")
  134:         store.append("df", df.iloc[10:], append=True, format="table")
  135:         tm.assert_frame_equal(store.select("df"), df)
  136: 
  137:         _maybe_remove(store, "df")
  138:         store.append("df", df.iloc[:10], append=False, format="table")
  139:         store.append("df", df.iloc[10:], append=True, format=None)
  140:         tm.assert_frame_equal(store.select("df"), df)
  141: 
  142: 
  143: def test_api_invalid(tmp_path, setup_path):
  144:     path = tmp_path / setup_path
  145:     # Invalid.
  146:     df = DataFrame(
  147:         1.1 * np.arange(120).reshape((30, 4)),
  148:         columns=Index(list("ABCD"), dtype=object),
  149:         index=Index([f"i-{i}" for i in range(30)], dtype=object),
  150:     )
  151: 
  152:     msg = "Can only append to Tables"
  153: 
  154:     with pytest.raises(ValueError, match=msg):
  155:         df.to_hdf(path, key="df", append=True, format="f")
  156: 
  157:     with pytest.raises(ValueError, match=msg):
  158:         df.to_hdf(path, key="df", append=True, format="fixed")
  159: 
  160:     msg = r"invalid HDFStore format specified \[foo\]"
  161: 
  162:     with pytest.raises(TypeError, match=msg):
  163:         df.to_hdf(path, key="df", append=True, format="foo")
  164: 
  165:     with pytest.raises(TypeError, match=msg):
  166:         df.to_hdf(path, key="df", append=False, format="foo")
  167: 
  168:     # File path doesn't exist
  169:     path = ""
  170:     msg = f"File {path} does not exist"
  171: 
  172:     with pytest.raises(FileNotFoundError, match=msg):
  173:         read_hdf(path, "df")
  174: 
  175: 
  176: def test_get(setup_path):
  177:     with ensure_clean_store(setup_path) as store:
  178:         store["a"] = Series(
  179:             np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
  180:         )
  181:         left = store.get("a")
  182:         right = store["a"]
  183:         tm.assert_series_equal(left, right)
  184: 
  185:         left = store.get("/a")
  186:         right = store["/a"]
  187:         tm.assert_series_equal(left, right)
  188: 
  189:         with pytest.raises(KeyError, match="'No object named b in the file'"):
  190:             store.get("b")
  191: 
  192: 
  193: def test_put_integer(setup_path):
  194:     # non-date, non-string index
  195:     df = DataFrame(np.random.default_rng(2).standard_normal((50, 100)))
  196:     _check_roundtrip(df, tm.assert_frame_equal, setup_path)
  197: 
  198: 
  199: def test_table_values_dtypes_roundtrip(setup_path):
  200:     with ensure_clean_store(setup_path) as store:
  201:         df1 = DataFrame({"a": [1, 2, 3]}, dtype="f8")
  202:         store.append("df_f8", df1)
  203:         tm.assert_series_equal(df1.dtypes, store["df_f8"].dtypes)
  204: 
  205:         df2 = DataFrame({"a": [1, 2, 3]}, dtype="i8")
  206:         store.append("df_i8", df2)
  207:         tm.assert_series_equal(df2.dtypes, store["df_i8"].dtypes)
  208: 
  209:         # incompatible dtype
  210:         msg = re.escape(
  211:             "invalid combination of [values_axes] on appending data "
  212:             "[name->values_block_0,cname->values_block_0,"
  213:             "dtype->float64,kind->float,shape->(1, 3)] vs "
  214:             "current table [name->values_block_0,"
  215:             "cname->values_block_0,dtype->int64,kind->integer,"
  216:             "shape->None]"
  217:         )
  218:         with pytest.raises(ValueError, match=msg):
  219:             store.append("df_i8", df1)
  220: 
  221:         # check creation/storage/retrieval of float32 (a bit hacky to
  222:         # actually create them thought)
  223:         df1 = DataFrame(np.array([[1], [2], [3]], dtype="f4"), columns=["A"])
  224:         store.append("df_f4", df1)
  225:         tm.assert_series_equal(df1.dtypes, store["df_f4"].dtypes)
  226:         assert df1.dtypes.iloc[0] == "float32"
  227: 
  228:         # check with mixed dtypes
  229:         df1 = DataFrame(
  230:             {
  231:                 c: Series(np.random.default_rng(2).integers(5), dtype=c)
  232:                 for c in ["float32", "float64", "int32", "int64", "int16", "int8"]
  233:             }
  234:         )
  235:         df1["string"] = "foo"
  236:         df1["float322"] = 1.0
  237:         df1["float322"] = df1["float322"].astype("float32")
  238:         df1["bool"] = df1["float32"] > 0
  239:         df1["time1"] = Timestamp("20130101")
  240:         df1["time2"] = Timestamp("20130102")
  241: 
  242:         store.append("df_mixed_dtypes1", df1)
  243:         result = store.select("df_mixed_dtypes1").dtypes.value_counts()
  244:         result.index = [str(i) for i in result.index]
  245:         expected = Series(
  246:             {
  247:                 "float32": 2,
  248:                 "float64": 1,
  249:                 "int32": 1,
  250:                 "bool": 1,
  251:                 "int16": 1,
  252:                 "int8": 1,
  253:                 "int64": 1,
  254:                 "object": 1,
  255:                 "datetime64[ns]": 2,
  256:             },
  257:             name="count",
  258:         )
  259:         result = result.sort_index()
  260:         expected = expected.sort_index()
  261:         tm.assert_series_equal(result, expected)
  262: 
  263: 
  264: @pytest.mark.filterwarnings("ignore::pandas.errors.PerformanceWarning")
  265: def test_series(setup_path):
  266:     s = Series(range(10), dtype="float64", index=[f"i_{i}" for i in range(10)])
  267:     _check_roundtrip(s, tm.assert_series_equal, path=setup_path)
  268: 
  269:     ts = Series(
  270:         np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
  271:     )
  272:     _check_roundtrip(ts, tm.assert_series_equal, path=setup_path)
  273: 
  274:     ts2 = Series(ts.index, Index(ts.index, dtype=object))
  275:     _check_roundtrip(ts2, tm.assert_series_equal, path=setup_path)
  276: 
  277:     ts3 = Series(ts.values, Index(np.asarray(ts.index, dtype=object), dtype=object))
  278:     _check_roundtrip(
  279:         ts3, tm.assert_series_equal, path=setup_path, check_index_type=False
  280:     )
  281: 
  282: 
  283: def test_float_index(setup_path):
  284:     # GH #454
  285:     index = np.random.default_rng(2).standard_normal(10)
  286:     s = Series(np.random.default_rng(2).standard_normal(10), index=index)
  287:     _check_roundtrip(s, tm.assert_series_equal, path=setup_path)
  288: 
  289: 
  290: def test_tuple_index(setup_path):
  291:     # GH #492
  292:     col = np.arange(10)
  293:     idx = [(0.0, 1.0), (2.0, 3.0), (4.0, 5.0)]
  294:     data = np.random.default_rng(2).standard_normal(30).reshape((3, 10))
  295:     DF = DataFrame(data, index=idx, columns=col)
  296: 
  297:     with tm.assert_produces_warning(pd.errors.PerformanceWarning):
  298:         _check_roundtrip(DF, tm.assert_frame_equal, path=setup_path)
  299: 
  300: 
  301: @pytest.mark.filterwarnings("ignore::pandas.errors.PerformanceWarning")
  302: def test_index_types(setup_path):
  303:     values = np.random.default_rng(2).standard_normal(2)
  304: 
  305:     func = lambda lhs, rhs: tm.assert_series_equal(lhs, rhs, check_index_type=True)
  306: 
  307:     ser = Series(values, [0, "y"])
  308:     _check_roundtrip(ser, func, path=setup_path)
  309: 
  310:     ser = Series(values, [datetime.datetime.today(), 0])
  311:     _check_roundtrip(ser, func, path=setup_path)
  312: 
  313:     ser = Series(values, ["y", 0])
  314:     _check_roundtrip(ser, func, path=setup_path)
  315: 
  316:     ser = Series(values, [datetime.date.today(), "a"])
  317:     _check_roundtrip(ser, func, path=setup_path)
  318: 
  319:     ser = Series(values, [0, "y"])
  320:     _check_roundtrip(ser, func, path=setup_path)
  321: 
  322:     ser = Series(values, [datetime.datetime.today(), 0])
  323:     _check_roundtrip(ser, func, path=setup_path)
  324: 
  325:     ser = Series(values, ["y", 0])
  326:     _check_roundtrip(ser, func, path=setup_path)
  327: 
  328:     ser = Series(values, [datetime.date.today(), "a"])
  329:     _check_roundtrip(ser, func, path=setup_path)
  330: 
  331:     ser = Series(values, [1.23, "b"])
  332:     _check_roundtrip(ser, func, path=setup_path)
  333: 
  334:     ser = Series(values, [1, 1.53])
  335:     _check_roundtrip(ser, func, path=setup_path)
  336: 
  337:     ser = Series(values, [1, 5])
  338:     _check_roundtrip(ser, func, path=setup_path)
  339: 
  340:     dti = DatetimeIndex(["2012-01-01", "2012-01-02"], dtype="M8[ns]")
  341:     ser = Series(values, index=dti)
  342:     _check_roundtrip(ser, func, path=setup_path)
  343: 
  344:     ser.index = ser.index.as_unit("s")
  345:     _check_roundtrip(ser, func, path=setup_path)
  346: 
  347: 
  348: def test_timeseries_preepoch(setup_path, request):
  349:     dr = bdate_range("1/1/1940", "1/1/1960")
  350:     ts = Series(np.random.default_rng(2).standard_normal(len(dr)), index=dr)
  351:     try:
  352:         _check_roundtrip(ts, tm.assert_series_equal, path=setup_path)
  353:     except OverflowError:
  354:         if is_platform_windows():
  355:             request.applymarker(
  356:                 pytest.mark.xfail("known failure on some windows platforms")
  357:             )
  358:         raise
  359: 
  360: 
  361: @pytest.mark.parametrize(
  362:     "compression", [False, pytest.param(True, marks=td.skip_if_windows)]
  363: )
  364: def test_frame(compression, setup_path):
  365:     df = DataFrame(
  366:         1.1 * np.arange(120).reshape((30, 4)),
  367:         columns=Index(list("ABCD"), dtype=object),
  368:         index=Index([f"i-{i}" for i in range(30)], dtype=object),
  369:     )
  370: 
  371:     # put in some random NAs
  372:     df.iloc[0, 0] = np.nan
  373:     df.iloc[5, 3] = np.nan
  374: 
  375:     _check_roundtrip_table(
  376:         df, tm.assert_frame_equal, path=setup_path, compression=compression
  377:     )
  378:     _check_roundtrip(
  379:         df, tm.assert_frame_equal, path=setup_path, compression=compression
  380:     )
  381: 
  382:     tdf = DataFrame(
  383:         np.random.default_rng(2).standard_normal((10, 4)),
  384:         columns=Index(list("ABCD"), dtype=object),
  385:         index=date_range("2000-01-01", periods=10, freq="B"),
  386:     )
  387:     _check_roundtrip(
  388:         tdf, tm.assert_frame_equal, path=setup_path, compression=compression
  389:     )
  390: 
  391:     with ensure_clean_store(setup_path) as store:
  392:         # not consolidated
  393:         df["foo"] = np.random.default_rng(2).standard_normal(len(df))
  394:         store["df"] = df
  395:         recons = store["df"]
  396:         assert recons._mgr.is_consolidated()
  397: 
  398:     # empty
  399:     _check_roundtrip(df[:0], tm.assert_frame_equal, path=setup_path)
  400: 
  401: 
  402: def test_empty_series_frame(setup_path):
  403:     s0 = Series(dtype=object)
  404:     s1 = Series(name="myseries", dtype=object)
  405:     df0 = DataFrame()
  406:     df1 = DataFrame(index=["a", "b", "c"])
  407:     df2 = DataFrame(columns=["d", "e", "f"])
  408: 
  409:     _check_roundtrip(s0, tm.assert_series_equal, path=setup_path)
  410:     _check_roundtrip(s1, tm.assert_series_equal, path=setup_path)
  411:     _check_roundtrip(df0, tm.assert_frame_equal, path=setup_path)
  412:     _check_roundtrip(df1, tm.assert_frame_equal, path=setup_path)
  413:     _check_roundtrip(df2, tm.assert_frame_equal, path=setup_path)
  414: 
  415: 
  416: @pytest.mark.parametrize("dtype", [np.int64, np.float64, object, "m8[ns]", "M8[ns]"])
  417: def test_empty_series(dtype, setup_path):
  418:     s = Series(dtype=dtype)
  419:     _check_roundtrip(s, tm.assert_series_equal, path=setup_path)
  420: 
  421: 
  422: def test_can_serialize_dates(setup_path):
  423:     rng = [x.date() for x in bdate_range("1/1/2000", "1/30/2000")]
  424:     frame = DataFrame(
  425:         np.random.default_rng(2).standard_normal((len(rng), 4)), index=rng
  426:     )
  427: 
  428:     _check_roundtrip(frame, tm.assert_frame_equal, path=setup_path)
  429: 
  430: 
  431: def test_store_hierarchical(setup_path, multiindex_dataframe_random_data):
  432:     frame = multiindex_dataframe_random_data
  433: 
  434:     _check_roundtrip(frame, tm.assert_frame_equal, path=setup_path)
  435:     _check_roundtrip(frame.T, tm.assert_frame_equal, path=setup_path)
  436:     _check_roundtrip(frame["A"], tm.assert_series_equal, path=setup_path)
  437: 
  438:     # check that the names are stored
  439:     with ensure_clean_store(setup_path) as store:
  440:         store["frame"] = frame
  441:         recons = store["frame"]
  442:         tm.assert_frame_equal(recons, frame)
  443: 
  444: 
  445: @pytest.mark.parametrize(
  446:     "compression", [False, pytest.param(True, marks=td.skip_if_windows)]
  447: )
  448: def test_store_mixed(compression, setup_path):
  449:     def _make_one():
  450:         df = DataFrame(
  451:             1.1 * np.arange(120).reshape((30, 4)),
  452:             columns=Index(list("ABCD"), dtype=object),
  453:             index=Index([f"i-{i}" for i in range(30)], dtype=object),
  454:         )
  455:         df["obj1"] = "foo"
  456:         df["obj2"] = "bar"
  457:         df["bool1"] = df["A"] > 0
  458:         df["bool2"] = df["B"] > 0
  459:         df["int1"] = 1
  460:         df["int2"] = 2
  461:         return df._consolidate()
  462: 
  463:     df1 = _make_one()
  464:     df2 = _make_one()
  465: 
  466:     _check_roundtrip(df1, tm.assert_frame_equal, path=setup_path)
  467:     _check_roundtrip(df2, tm.assert_frame_equal, path=setup_path)
  468: 
  469:     with ensure_clean_store(setup_path) as store:
  470:         store["obj"] = df1
  471:         tm.assert_frame_equal(store["obj"], df1)
  472:         store["obj"] = df2
  473:         tm.assert_frame_equal(store["obj"], df2)
  474: 
  475:     # check that can store Series of all of these types
  476:     _check_roundtrip(
  477:         df1["obj1"],
  478:         tm.assert_series_equal,
  479:         path=setup_path,
  480:         compression=compression,
  481:     )
  482:     _check_roundtrip(
  483:         df1["bool1"],
  484:         tm.assert_series_equal,
  485:         path=setup_path,
  486:         compression=compression,
  487:     )
  488:     _check_roundtrip(
  489:         df1["int1"],
  490:         tm.assert_series_equal,
  491:         path=setup_path,
  492:         compression=compression,
  493:     )
  494: 
  495: 
  496: def _check_roundtrip(obj, comparator, path, compression=False, **kwargs):
  497:     options = {}
  498:     if compression:
  499:         options["complib"] = "blosc"
  500: 
  501:     with ensure_clean_store(path, "w", **options) as store:
  502:         store["obj"] = obj
  503:         retrieved = store["obj"]
  504:         comparator(retrieved, obj, **kwargs)
  505: 
  506: 
  507: def _check_roundtrip_table(obj, comparator, path, compression=False):
  508:     options = {}
  509:     if compression:
  510:         options["complib"] = "blosc"
  511: 
  512:     with ensure_clean_store(path, "w", **options) as store:
  513:         store.put("obj", obj, format="table")
  514:         retrieved = store["obj"]
  515: 
  516:         comparator(retrieved, obj)
  517: 
  518: 
  519: def test_unicode_index(setup_path):
  520:     unicode_values = ["\u03c3", "\u03c3\u03c3"]
  521: 
  522:     s = Series(
  523:         np.random.default_rng(2).standard_normal(len(unicode_values)),
  524:         unicode_values,
  525:     )
  526:     _check_roundtrip(s, tm.assert_series_equal, path=setup_path)
  527: 
  528: 
  529: def test_unicode_longer_encoded(setup_path):
  530:     # GH 11234
  531:     char = "\u0394"
  532:     df = DataFrame({"A": [char]})
  533:     with ensure_clean_store(setup_path) as store:
  534:         store.put("df", df, format="table", encoding="utf-8")
  535:         result = store.get("df")
  536:         tm.assert_frame_equal(result, df)
  537: 
  538:     df = DataFrame({"A": ["a", char], "B": ["b", "b"]})
  539:     with ensure_clean_store(setup_path) as store:
  540:         store.put("df", df, format="table", encoding="utf-8")
  541:         result = store.get("df")
  542:         tm.assert_frame_equal(result, df)
  543: 
  544: 
  545: def test_store_datetime_mixed(setup_path):
  546:     df = DataFrame({"a": [1, 2, 3], "b": [1.0, 2.0, 3.0], "c": ["a", "b", "c"]})
  547:     ts = Series(
  548:         np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
  549:     )
  550:     df["d"] = ts.index[:3]
  551:     _check_roundtrip(df, tm.assert_frame_equal, path=setup_path)
  552: 
  553: 
  554: def test_round_trip_equals(tmp_path, setup_path):
  555:     # GH 9330
  556:     df = DataFrame({"B": [1, 2], "A": ["x", "y"]})
  557: 
  558:     path = tmp_path / setup_path
  559:     df.to_hdf(path, key="df", format="table")
  560:     other = read_hdf(path, "df")
  561:     tm.assert_frame_equal(df, other)
  562:     assert df.equals(other)
  563:     assert other.equals(df)
  564: 
  565: 
  566: def test_infer_string_columns(tmp_path, setup_path):
  567:     # GH#
  568:     pytest.importorskip("pyarrow")
  569:     path = tmp_path / setup_path
  570:     with pd.option_context("future.infer_string", True):
  571:         df = DataFrame(1, columns=list("ABCD"), index=list(range(10))).set_index(
  572:             ["A", "B"]
  573:         )
  574:         expected = df.copy()
  575:         df.to_hdf(path, key="df", format="table")
  576: 
  577:         result = read_hdf(path, "df")
  578:         tm.assert_frame_equal(result, expected)
