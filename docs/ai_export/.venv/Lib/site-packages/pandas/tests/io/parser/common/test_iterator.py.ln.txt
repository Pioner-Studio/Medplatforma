    1: """
    2: Tests that work on both the Python and C engines but do not have a
    3: specific classification into the other test modules.
    4: """
    5: from io import StringIO
    6: 
    7: import pytest
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     concat,
   12: )
   13: import pandas._testing as tm
   14: 
   15: pytestmark = pytest.mark.filterwarnings(
   16:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   17: )
   18: 
   19: 
   20: def test_iterator(all_parsers):
   21:     # see gh-6607
   22:     data = """index,A,B,C,D
   23: foo,2,3,4,5
   24: bar,7,8,9,10
   25: baz,12,13,14,15
   26: qux,12,13,14,15
   27: foo2,12,13,14,15
   28: bar2,12,13,14,15
   29: """
   30:     parser = all_parsers
   31:     kwargs = {"index_col": 0}
   32: 
   33:     expected = parser.read_csv(StringIO(data), **kwargs)
   34: 
   35:     if parser.engine == "pyarrow":
   36:         msg = "The 'iterator' option is not supported with the 'pyarrow' engine"
   37:         with pytest.raises(ValueError, match=msg):
   38:             parser.read_csv(StringIO(data), iterator=True, **kwargs)
   39:         return
   40: 
   41:     with parser.read_csv(StringIO(data), iterator=True, **kwargs) as reader:
   42:         first_chunk = reader.read(3)
   43:         tm.assert_frame_equal(first_chunk, expected[:3])
   44: 
   45:         last_chunk = reader.read(5)
   46:     tm.assert_frame_equal(last_chunk, expected[3:])
   47: 
   48: 
   49: def test_iterator2(all_parsers):
   50:     parser = all_parsers
   51:     data = """A,B,C
   52: foo,1,2,3
   53: bar,4,5,6
   54: baz,7,8,9
   55: """
   56: 
   57:     if parser.engine == "pyarrow":
   58:         msg = "The 'iterator' option is not supported with the 'pyarrow' engine"
   59:         with pytest.raises(ValueError, match=msg):
   60:             parser.read_csv(StringIO(data), iterator=True)
   61:         return
   62: 
   63:     with parser.read_csv(StringIO(data), iterator=True) as reader:
   64:         result = list(reader)
   65: 
   66:     expected = DataFrame(
   67:         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
   68:         index=["foo", "bar", "baz"],
   69:         columns=["A", "B", "C"],
   70:     )
   71:     tm.assert_frame_equal(result[0], expected)
   72: 
   73: 
   74: def test_iterator_stop_on_chunksize(all_parsers):
   75:     # gh-3967: stopping iteration when chunksize is specified
   76:     parser = all_parsers
   77:     data = """A,B,C
   78: foo,1,2,3
   79: bar,4,5,6
   80: baz,7,8,9
   81: """
   82:     if parser.engine == "pyarrow":
   83:         msg = "The 'chunksize' option is not supported with the 'pyarrow' engine"
   84:         with pytest.raises(ValueError, match=msg):
   85:             parser.read_csv(StringIO(data), chunksize=1)
   86:         return
   87: 
   88:     with parser.read_csv(StringIO(data), chunksize=1) as reader:
   89:         result = list(reader)
   90: 
   91:     assert len(result) == 3
   92:     expected = DataFrame(
   93:         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
   94:         index=["foo", "bar", "baz"],
   95:         columns=["A", "B", "C"],
   96:     )
   97:     tm.assert_frame_equal(concat(result), expected)
   98: 
   99: 
  100: @pytest.mark.parametrize(
  101:     "kwargs", [{"iterator": True, "chunksize": 1}, {"iterator": True}, {"chunksize": 1}]
  102: )
  103: def test_iterator_skipfooter_errors(all_parsers, kwargs):
  104:     msg = "'skipfooter' not supported for iteration"
  105:     parser = all_parsers
  106:     data = "a\n1\n2"
  107: 
  108:     if parser.engine == "pyarrow":
  109:         msg = (
  110:             "The '(chunksize|iterator)' option is not supported with the "
  111:             "'pyarrow' engine"
  112:         )
  113: 
  114:     with pytest.raises(ValueError, match=msg):
  115:         with parser.read_csv(StringIO(data), skipfooter=1, **kwargs) as _:
  116:             pass
  117: 
  118: 
  119: def test_iteration_open_handle(all_parsers):
  120:     parser = all_parsers
  121:     kwargs = {"header": None}
  122: 
  123:     with tm.ensure_clean() as path:
  124:         with open(path, "w", encoding="utf-8") as f:
  125:             f.write("AAA\nBBB\nCCC\nDDD\nEEE\nFFF\nGGG")
  126: 
  127:         with open(path, encoding="utf-8") as f:
  128:             for line in f:
  129:                 if "CCC" in line:
  130:                     break
  131: 
  132:             result = parser.read_csv(f, **kwargs)
  133:             expected = DataFrame({0: ["DDD", "EEE", "FFF", "GGG"]})
  134:             tm.assert_frame_equal(result, expected)
