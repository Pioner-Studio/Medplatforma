    1: """ test feather-format compat """
    2: import numpy as np
    3: import pytest
    4: 
    5: import pandas as pd
    6: import pandas._testing as tm
    7: from pandas.core.arrays import (
    8:     ArrowStringArray,
    9:     StringArray,
   10: )
   11: 
   12: from pandas.io.feather_format import read_feather, to_feather  # isort:skip
   13: 
   14: pytestmark = pytest.mark.filterwarnings(
   15:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   16: )
   17: 
   18: pa = pytest.importorskip("pyarrow")
   19: 
   20: 
   21: @pytest.mark.single_cpu
   22: class TestFeather:
   23:     def check_error_on_write(self, df, exc, err_msg):
   24:         # check that we are raising the exception
   25:         # on writing
   26: 
   27:         with pytest.raises(exc, match=err_msg):
   28:             with tm.ensure_clean() as path:
   29:                 to_feather(df, path)
   30: 
   31:     def check_external_error_on_write(self, df):
   32:         # check that we are raising the exception
   33:         # on writing
   34: 
   35:         with tm.external_error_raised(Exception):
   36:             with tm.ensure_clean() as path:
   37:                 to_feather(df, path)
   38: 
   39:     def check_round_trip(self, df, expected=None, write_kwargs={}, **read_kwargs):
   40:         if expected is None:
   41:             expected = df.copy()
   42: 
   43:         with tm.ensure_clean() as path:
   44:             to_feather(df, path, **write_kwargs)
   45: 
   46:             result = read_feather(path, **read_kwargs)
   47: 
   48:             tm.assert_frame_equal(result, expected)
   49: 
   50:     def test_error(self):
   51:         msg = "feather only support IO with DataFrames"
   52:         for obj in [
   53:             pd.Series([1, 2, 3]),
   54:             1,
   55:             "foo",
   56:             pd.Timestamp("20130101"),
   57:             np.array([1, 2, 3]),
   58:         ]:
   59:             self.check_error_on_write(obj, ValueError, msg)
   60: 
   61:     def test_basic(self):
   62:         df = pd.DataFrame(
   63:             {
   64:                 "string": list("abc"),
   65:                 "int": list(range(1, 4)),
   66:                 "uint": np.arange(3, 6).astype("u1"),
   67:                 "float": np.arange(4.0, 7.0, dtype="float64"),
   68:                 "float_with_null": [1.0, np.nan, 3],
   69:                 "bool": [True, False, True],
   70:                 "bool_with_null": [True, np.nan, False],
   71:                 "cat": pd.Categorical(list("abc")),
   72:                 "dt": pd.DatetimeIndex(
   73:                     list(pd.date_range("20130101", periods=3)), freq=None
   74:                 ),
   75:                 "dttz": pd.DatetimeIndex(
   76:                     list(pd.date_range("20130101", periods=3, tz="US/Eastern")),
   77:                     freq=None,
   78:                 ),
   79:                 "dt_with_null": [
   80:                     pd.Timestamp("20130101"),
   81:                     pd.NaT,
   82:                     pd.Timestamp("20130103"),
   83:                 ],
   84:                 "dtns": pd.DatetimeIndex(
   85:                     list(pd.date_range("20130101", periods=3, freq="ns")), freq=None
   86:                 ),
   87:             }
   88:         )
   89:         df["periods"] = pd.period_range("2013", freq="M", periods=3)
   90:         df["timedeltas"] = pd.timedelta_range("1 day", periods=3)
   91:         df["intervals"] = pd.interval_range(0, 3, 3)
   92: 
   93:         assert df.dttz.dtype.tz.zone == "US/Eastern"
   94: 
   95:         expected = df.copy()
   96:         expected.loc[1, "bool_with_null"] = None
   97:         self.check_round_trip(df, expected=expected)
   98: 
   99:     def test_duplicate_columns(self):
  100:         # https://github.com/wesm/feather/issues/53
  101:         # not currently able to handle duplicate columns
  102:         df = pd.DataFrame(np.arange(12).reshape(4, 3), columns=list("aaa")).copy()
  103:         self.check_external_error_on_write(df)
  104: 
  105:     def test_read_columns(self):
  106:         # GH 24025
  107:         df = pd.DataFrame(
  108:             {
  109:                 "col1": list("abc"),
  110:                 "col2": list(range(1, 4)),
  111:                 "col3": list("xyz"),
  112:                 "col4": list(range(4, 7)),
  113:             }
  114:         )
  115:         columns = ["col1", "col3"]
  116:         self.check_round_trip(df, expected=df[columns], columns=columns)
  117: 
  118:     def test_read_columns_different_order(self):
  119:         # GH 33878
  120:         df = pd.DataFrame({"A": [1, 2], "B": ["x", "y"], "C": [True, False]})
  121:         expected = df[["B", "A"]]
  122:         self.check_round_trip(df, expected, columns=["B", "A"])
  123: 
  124:     def test_unsupported_other(self):
  125:         # mixed python objects
  126:         df = pd.DataFrame({"a": ["a", 1, 2.0]})
  127:         self.check_external_error_on_write(df)
  128: 
  129:     def test_rw_use_threads(self):
  130:         df = pd.DataFrame({"A": np.arange(100000)})
  131:         self.check_round_trip(df, use_threads=True)
  132:         self.check_round_trip(df, use_threads=False)
  133: 
  134:     def test_path_pathlib(self):
  135:         df = pd.DataFrame(
  136:             1.1 * np.arange(120).reshape((30, 4)),
  137:             columns=pd.Index(list("ABCD"), dtype=object),
  138:             index=pd.Index([f"i-{i}" for i in range(30)], dtype=object),
  139:         ).reset_index()
  140:         result = tm.round_trip_pathlib(df.to_feather, read_feather)
  141:         tm.assert_frame_equal(df, result)
  142: 
  143:     def test_path_localpath(self):
  144:         df = pd.DataFrame(
  145:             1.1 * np.arange(120).reshape((30, 4)),
  146:             columns=pd.Index(list("ABCD"), dtype=object),
  147:             index=pd.Index([f"i-{i}" for i in range(30)], dtype=object),
  148:         ).reset_index()
  149:         result = tm.round_trip_localpath(df.to_feather, read_feather)
  150:         tm.assert_frame_equal(df, result)
  151: 
  152:     def test_passthrough_keywords(self):
  153:         df = pd.DataFrame(
  154:             1.1 * np.arange(120).reshape((30, 4)),
  155:             columns=pd.Index(list("ABCD"), dtype=object),
  156:             index=pd.Index([f"i-{i}" for i in range(30)], dtype=object),
  157:         ).reset_index()
  158:         self.check_round_trip(df, write_kwargs={"version": 1})
  159: 
  160:     @pytest.mark.network
  161:     @pytest.mark.single_cpu
  162:     def test_http_path(self, feather_file, httpserver):
  163:         # GH 29055
  164:         expected = read_feather(feather_file)
  165:         with open(feather_file, "rb") as f:
  166:             httpserver.serve_content(content=f.read())
  167:             res = read_feather(httpserver.url)
  168:         tm.assert_frame_equal(expected, res)
  169: 
  170:     def test_read_feather_dtype_backend(self, string_storage, dtype_backend):
  171:         # GH#50765
  172:         df = pd.DataFrame(
  173:             {
  174:                 "a": pd.Series([1, np.nan, 3], dtype="Int64"),
  175:                 "b": pd.Series([1, 2, 3], dtype="Int64"),
  176:                 "c": pd.Series([1.5, np.nan, 2.5], dtype="Float64"),
  177:                 "d": pd.Series([1.5, 2.0, 2.5], dtype="Float64"),
  178:                 "e": [True, False, None],
  179:                 "f": [True, False, True],
  180:                 "g": ["a", "b", "c"],
  181:                 "h": ["a", "b", None],
  182:             }
  183:         )
  184: 
  185:         if string_storage == "python":
  186:             string_array = StringArray(np.array(["a", "b", "c"], dtype=np.object_))
  187:             string_array_na = StringArray(np.array(["a", "b", pd.NA], dtype=np.object_))
  188: 
  189:         elif dtype_backend == "pyarrow":
  190:             from pandas.arrays import ArrowExtensionArray
  191: 
  192:             string_array = ArrowExtensionArray(pa.array(["a", "b", "c"]))
  193:             string_array_na = ArrowExtensionArray(pa.array(["a", "b", None]))
  194: 
  195:         else:
  196:             string_array = ArrowStringArray(pa.array(["a", "b", "c"]))
  197:             string_array_na = ArrowStringArray(pa.array(["a", "b", None]))
  198: 
  199:         with tm.ensure_clean() as path:
  200:             to_feather(df, path)
  201:             with pd.option_context("mode.string_storage", string_storage):
  202:                 result = read_feather(path, dtype_backend=dtype_backend)
  203: 
  204:         expected = pd.DataFrame(
  205:             {
  206:                 "a": pd.Series([1, np.nan, 3], dtype="Int64"),
  207:                 "b": pd.Series([1, 2, 3], dtype="Int64"),
  208:                 "c": pd.Series([1.5, np.nan, 2.5], dtype="Float64"),
  209:                 "d": pd.Series([1.5, 2.0, 2.5], dtype="Float64"),
  210:                 "e": pd.Series([True, False, pd.NA], dtype="boolean"),
  211:                 "f": pd.Series([True, False, True], dtype="boolean"),
  212:                 "g": string_array,
  213:                 "h": string_array_na,
  214:             }
  215:         )
  216: 
  217:         if dtype_backend == "pyarrow":
  218:             from pandas.arrays import ArrowExtensionArray
  219: 
  220:             expected = pd.DataFrame(
  221:                 {
  222:                     col: ArrowExtensionArray(pa.array(expected[col], from_pandas=True))
  223:                     for col in expected.columns
  224:                 }
  225:             )
  226: 
  227:         tm.assert_frame_equal(result, expected)
  228: 
  229:     def test_int_columns_and_index(self):
  230:         df = pd.DataFrame({"a": [1, 2, 3]}, index=pd.Index([3, 4, 5], name="test"))
  231:         self.check_round_trip(df)
  232: 
  233:     def test_invalid_dtype_backend(self):
  234:         msg = (
  235:             "dtype_backend numpy is invalid, only 'numpy_nullable' and "
  236:             "'pyarrow' are allowed."
  237:         )
  238:         df = pd.DataFrame({"int": list(range(1, 4))})
  239:         with tm.ensure_clean("tmp.feather") as path:
  240:             df.to_feather(path)
  241:             with pytest.raises(ValueError, match=msg):
  242:                 read_feather(path, dtype_backend="numpy")
  243: 
  244:     def test_string_inference(self, tmp_path):
  245:         # GH#54431
  246:         path = tmp_path / "test_string_inference.p"
  247:         df = pd.DataFrame(data={"a": ["x", "y"]})
  248:         df.to_feather(path)
  249:         with pd.option_context("future.infer_string", True):
  250:             result = read_feather(path)
  251:         expected = pd.DataFrame(data={"a": ["x", "y"]}, dtype="string[pyarrow_numpy]")
  252:         tm.assert_frame_equal(result, expected)
