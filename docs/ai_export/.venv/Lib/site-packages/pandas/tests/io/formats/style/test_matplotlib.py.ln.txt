    1: import gc
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas import (
    7:     DataFrame,
    8:     IndexSlice,
    9:     Series,
   10: )
   11: 
   12: pytest.importorskip("matplotlib")
   13: pytest.importorskip("jinja2")
   14: 
   15: import matplotlib as mpl
   16: 
   17: from pandas.io.formats.style import Styler
   18: 
   19: 
   20: @pytest.fixture(autouse=True)
   21: def mpl_cleanup():
   22:     # matplotlib/testing/decorators.py#L24
   23:     # 1) Resets units registry
   24:     # 2) Resets rc_context
   25:     # 3) Closes all figures
   26:     mpl = pytest.importorskip("matplotlib")
   27:     mpl_units = pytest.importorskip("matplotlib.units")
   28:     plt = pytest.importorskip("matplotlib.pyplot")
   29:     orig_units_registry = mpl_units.registry.copy()
   30:     with mpl.rc_context():
   31:         mpl.use("template")
   32:         yield
   33:     mpl_units.registry.clear()
   34:     mpl_units.registry.update(orig_units_registry)
   35:     plt.close("all")
   36:     # https://matplotlib.org/stable/users/prev_whats_new/whats_new_3.6.0.html#garbage-collection-is-no-longer-run-on-figure-close  # noqa: E501
   37:     gc.collect(1)
   38: 
   39: 
   40: @pytest.fixture
   41: def df():
   42:     return DataFrame([[1, 2], [2, 4]], columns=["A", "B"])
   43: 
   44: 
   45: @pytest.fixture
   46: def styler(df):
   47:     return Styler(df, uuid_len=0)
   48: 
   49: 
   50: @pytest.fixture
   51: def df_blank():
   52:     return DataFrame([[0, 0], [0, 0]], columns=["A", "B"], index=["X", "Y"])
   53: 
   54: 
   55: @pytest.fixture
   56: def styler_blank(df_blank):
   57:     return Styler(df_blank, uuid_len=0)
   58: 
   59: 
   60: @pytest.mark.parametrize("f", ["background_gradient", "text_gradient"])
   61: def test_function_gradient(styler, f):
   62:     for c_map in [None, "YlOrRd"]:
   63:         result = getattr(styler, f)(cmap=c_map)._compute().ctx
   64:         assert all("#" in x[0][1] for x in result.values())
   65:         assert result[(0, 0)] == result[(0, 1)]
   66:         assert result[(1, 0)] == result[(1, 1)]
   67: 
   68: 
   69: @pytest.mark.parametrize("f", ["background_gradient", "text_gradient"])
   70: def test_background_gradient_color(styler, f):
   71:     result = getattr(styler, f)(subset=IndexSlice[1, "A"])._compute().ctx
   72:     if f == "background_gradient":
   73:         assert result[(1, 0)] == [("background-color", "#fff7fb"), ("color", "#000000")]
   74:     elif f == "text_gradient":
   75:         assert result[(1, 0)] == [("color", "#fff7fb")]
   76: 
   77: 
   78: @pytest.mark.parametrize(
   79:     "axis, expected",
   80:     [
   81:         (0, ["low", "low", "high", "high"]),
   82:         (1, ["low", "high", "low", "high"]),
   83:         (None, ["low", "mid", "mid", "high"]),
   84:     ],
   85: )
   86: @pytest.mark.parametrize("f", ["background_gradient", "text_gradient"])
   87: def test_background_gradient_axis(styler, axis, expected, f):
   88:     if f == "background_gradient":
   89:         colors = {
   90:             "low": [("background-color", "#f7fbff"), ("color", "#000000")],
   91:             "mid": [("background-color", "#abd0e6"), ("color", "#000000")],
   92:             "high": [("background-color", "#08306b"), ("color", "#f1f1f1")],
   93:         }
   94:     elif f == "text_gradient":
   95:         colors = {
   96:             "low": [("color", "#f7fbff")],
   97:             "mid": [("color", "#abd0e6")],
   98:             "high": [("color", "#08306b")],
   99:         }
  100:     result = getattr(styler, f)(cmap="Blues", axis=axis)._compute().ctx
  101:     for i, cell in enumerate([(0, 0), (0, 1), (1, 0), (1, 1)]):
  102:         assert result[cell] == colors[expected[i]]
  103: 
  104: 
  105: @pytest.mark.parametrize(
  106:     "cmap, expected",
  107:     [
  108:         (
  109:             "PuBu",
  110:             {
  111:                 (4, 5): [("background-color", "#86b0d3"), ("color", "#000000")],
  112:                 (4, 6): [("background-color", "#83afd3"), ("color", "#f1f1f1")],
  113:             },
  114:         ),
  115:         (
  116:             "YlOrRd",
  117:             {
  118:                 (4, 8): [("background-color", "#fd913e"), ("color", "#000000")],
  119:                 (4, 9): [("background-color", "#fd8f3d"), ("color", "#f1f1f1")],
  120:             },
  121:         ),
  122:         (
  123:             None,
  124:             {
  125:                 (7, 0): [("background-color", "#48c16e"), ("color", "#f1f1f1")],
  126:                 (7, 1): [("background-color", "#4cc26c"), ("color", "#000000")],
  127:             },
  128:         ),
  129:     ],
  130: )
  131: def test_text_color_threshold(cmap, expected):
  132:     # GH 39888
  133:     df = DataFrame(np.arange(100).reshape(10, 10))
  134:     result = df.style.background_gradient(cmap=cmap, axis=None)._compute().ctx
  135:     for k in expected.keys():
  136:         assert result[k] == expected[k]
  137: 
  138: 
  139: def test_background_gradient_vmin_vmax():
  140:     # GH 12145
  141:     df = DataFrame(range(5))
  142:     ctx = df.style.background_gradient(vmin=1, vmax=3)._compute().ctx
  143:     assert ctx[(0, 0)] == ctx[(1, 0)]
  144:     assert ctx[(4, 0)] == ctx[(3, 0)]
  145: 
  146: 
  147: def test_background_gradient_int64():
  148:     # GH 28869
  149:     df1 = Series(range(3)).to_frame()
  150:     df2 = Series(range(3), dtype="Int64").to_frame()
  151:     ctx1 = df1.style.background_gradient()._compute().ctx
  152:     ctx2 = df2.style.background_gradient()._compute().ctx
  153:     assert ctx2[(0, 0)] == ctx1[(0, 0)]
  154:     assert ctx2[(1, 0)] == ctx1[(1, 0)]
  155:     assert ctx2[(2, 0)] == ctx1[(2, 0)]
  156: 
  157: 
  158: @pytest.mark.parametrize(
  159:     "axis, gmap, expected",
  160:     [
  161:         (
  162:             0,
  163:             [1, 2],
  164:             {
  165:                 (0, 0): [("background-color", "#fff7fb"), ("color", "#000000")],
  166:                 (1, 0): [("background-color", "#023858"), ("color", "#f1f1f1")],
  167:                 (0, 1): [("background-color", "#fff7fb"), ("color", "#000000")],
  168:                 (1, 1): [("background-color", "#023858"), ("color", "#f1f1f1")],
  169:             },
  170:         ),
  171:         (
  172:             1,
  173:             [1, 2],
  174:             {
  175:                 (0, 0): [("background-color", "#fff7fb"), ("color", "#000000")],
  176:                 (1, 0): [("background-color", "#fff7fb"), ("color", "#000000")],
  177:                 (0, 1): [("background-color", "#023858"), ("color", "#f1f1f1")],
  178:                 (1, 1): [("background-color", "#023858"), ("color", "#f1f1f1")],
  179:             },
  180:         ),
  181:         (
  182:             None,
  183:             np.array([[2, 1], [1, 2]]),
  184:             {
  185:                 (0, 0): [("background-color", "#023858"), ("color", "#f1f1f1")],
  186:                 (1, 0): [("background-color", "#fff7fb"), ("color", "#000000")],
  187:                 (0, 1): [("background-color", "#fff7fb"), ("color", "#000000")],
  188:                 (1, 1): [("background-color", "#023858"), ("color", "#f1f1f1")],
  189:             },
  190:         ),
  191:     ],
  192: )
  193: def test_background_gradient_gmap_array(styler_blank, axis, gmap, expected):
  194:     # tests when gmap is given as a sequence and converted to ndarray
  195:     result = styler_blank.background_gradient(axis=axis, gmap=gmap)._compute().ctx
  196:     assert result == expected
  197: 
  198: 
  199: @pytest.mark.parametrize(
  200:     "gmap, axis", [([1, 2, 3], 0), ([1, 2], 1), (np.array([[1, 2], [1, 2]]), None)]
  201: )
  202: def test_background_gradient_gmap_array_raises(gmap, axis):
  203:     # test when gmap as converted ndarray is bad shape
  204:     df = DataFrame([[0, 0, 0], [0, 0, 0]])
  205:     msg = "supplied 'gmap' is not correct shape"
  206:     with pytest.raises(ValueError, match=msg):
  207:         df.style.background_gradient(gmap=gmap, axis=axis)._compute()
  208: 
  209: 
  210: @pytest.mark.parametrize(
  211:     "gmap",
  212:     [
  213:         DataFrame(  # reverse the columns
  214:             [[2, 1], [1, 2]], columns=["B", "A"], index=["X", "Y"]
  215:         ),
  216:         DataFrame(  # reverse the index
  217:             [[2, 1], [1, 2]], columns=["A", "B"], index=["Y", "X"]
  218:         ),
  219:         DataFrame(  # reverse the index and columns
  220:             [[1, 2], [2, 1]], columns=["B", "A"], index=["Y", "X"]
  221:         ),
  222:         DataFrame(  # add unnecessary columns
  223:             [[1, 2, 3], [2, 1, 3]], columns=["A", "B", "C"], index=["X", "Y"]
  224:         ),
  225:         DataFrame(  # add unnecessary index
  226:             [[1, 2], [2, 1], [3, 3]], columns=["A", "B"], index=["X", "Y", "Z"]
  227:         ),
  228:     ],
  229: )
  230: @pytest.mark.parametrize(
  231:     "subset, exp_gmap",  # exp_gmap is underlying map DataFrame should conform to
  232:     [
  233:         (None, [[1, 2], [2, 1]]),
  234:         (["A"], [[1], [2]]),  # slice only column "A" in data and gmap
  235:         (["B", "A"], [[2, 1], [1, 2]]),  # reverse the columns in data
  236:         (IndexSlice["X", :], [[1, 2]]),  # slice only index "X" in data and gmap
  237:         (IndexSlice[["Y", "X"], :], [[2, 1], [1, 2]]),  # reverse the index in data
  238:     ],
  239: )
  240: def test_background_gradient_gmap_dataframe_align(styler_blank, gmap, subset, exp_gmap):
  241:     # test gmap given as DataFrame that it aligns to the data including subset
  242:     expected = styler_blank.background_gradient(axis=None, gmap=exp_gmap, subset=subset)
  243:     result = styler_blank.background_gradient(axis=None, gmap=gmap, subset=subset)
  244:     assert expected._compute().ctx == result._compute().ctx
  245: 
  246: 
  247: @pytest.mark.parametrize(
  248:     "gmap, axis, exp_gmap",
  249:     [
  250:         (Series([2, 1], index=["Y", "X"]), 0, [[1, 1], [2, 2]]),  # revrse the index
  251:         (Series([2, 1], index=["B", "A"]), 1, [[1, 2], [1, 2]]),  # revrse the cols
  252:         (Series([1, 2, 3], index=["X", "Y", "Z"]), 0, [[1, 1], [2, 2]]),  # add idx
  253:         (Series([1, 2, 3], index=["A", "B", "C"]), 1, [[1, 2], [1, 2]]),  # add col
  254:     ],
  255: )
  256: def test_background_gradient_gmap_series_align(styler_blank, gmap, axis, exp_gmap):
  257:     # test gmap given as Series that it aligns to the data including subset
  258:     expected = styler_blank.background_gradient(axis=None, gmap=exp_gmap)._compute()
  259:     result = styler_blank.background_gradient(axis=axis, gmap=gmap)._compute()
  260:     assert expected.ctx == result.ctx
  261: 
  262: 
  263: @pytest.mark.parametrize(
  264:     "gmap, axis",
  265:     [
  266:         (DataFrame([[1, 2], [2, 1]], columns=["A", "B"], index=["X", "Y"]), 1),
  267:         (DataFrame([[1, 2], [2, 1]], columns=["A", "B"], index=["X", "Y"]), 0),
  268:     ],
  269: )
  270: def test_background_gradient_gmap_wrong_dataframe(styler_blank, gmap, axis):
  271:     # test giving a gmap in DataFrame but with wrong axis
  272:     msg = "'gmap' is a DataFrame but underlying data for operations is a Series"
  273:     with pytest.raises(ValueError, match=msg):
  274:         styler_blank.background_gradient(gmap=gmap, axis=axis)._compute()
  275: 
  276: 
  277: def test_background_gradient_gmap_wrong_series(styler_blank):
  278:     # test giving a gmap in Series form but with wrong axis
  279:     msg = "'gmap' is a Series but underlying data for operations is a DataFrame"
  280:     gmap = Series([1, 2], index=["X", "Y"])
  281:     with pytest.raises(ValueError, match=msg):
  282:         styler_blank.background_gradient(gmap=gmap, axis=None)._compute()
  283: 
  284: 
  285: def test_background_gradient_nullable_dtypes():
  286:     # GH 50712
  287:     df1 = DataFrame([[1], [0], [np.nan]], dtype=float)
  288:     df2 = DataFrame([[1], [0], [None]], dtype="Int64")
  289: 
  290:     ctx1 = df1.style.background_gradient()._compute().ctx
  291:     ctx2 = df2.style.background_gradient()._compute().ctx
  292:     assert ctx1 == ctx2
  293: 
  294: 
  295: @pytest.mark.parametrize(
  296:     "cmap",
  297:     ["PuBu", mpl.colormaps["PuBu"]],
  298: )
  299: def test_bar_colormap(cmap):
  300:     data = DataFrame([[1, 2], [3, 4]])
  301:     ctx = data.style.bar(cmap=cmap, axis=None)._compute().ctx
  302:     pubu_colors = {
  303:         (0, 0): "#d0d1e6",
  304:         (1, 0): "#056faf",
  305:         (0, 1): "#73a9cf",
  306:         (1, 1): "#023858",
  307:     }
  308:     for k, v in pubu_colors.items():
  309:         assert v in ctx[k][1][1]
  310: 
  311: 
  312: def test_bar_color_raises(df):
  313:     msg = "`color` must be string or list or tuple of 2 strings"
  314:     with pytest.raises(ValueError, match=msg):
  315:         df.style.bar(color={"a", "b"}).to_html()
  316:     with pytest.raises(ValueError, match=msg):
  317:         df.style.bar(color=["a", "b", "c"]).to_html()
  318: 
  319:     msg = "`color` and `cmap` cannot both be given"
  320:     with pytest.raises(ValueError, match=msg):
  321:         df.style.bar(color="something", cmap="something else").to_html()
  322: 
  323: 
  324: @pytest.mark.parametrize(
  325:     "plot_method",
  326:     ["scatter", "hexbin"],
  327: )
  328: def test_pass_colormap_instance(df, plot_method):
  329:     # https://github.com/pandas-dev/pandas/issues/49374
  330:     cmap = mpl.colors.ListedColormap([[1, 1, 1], [0, 0, 0]])
  331:     df["c"] = df.A + df.B
  332:     kwargs = {"x": "A", "y": "B", "c": "c", "colormap": cmap}
  333:     if plot_method == "hexbin":
  334:         kwargs["C"] = kwargs.pop("c")
  335:     getattr(df.plot, plot_method)(**kwargs)
