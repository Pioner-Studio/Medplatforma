    1: from textwrap import dedent
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.errors import (
    7:     PyperclipException,
    8:     PyperclipWindowsException,
    9: )
   10: 
   11: import pandas as pd
   12: from pandas import (
   13:     NA,
   14:     DataFrame,
   15:     Series,
   16:     get_option,
   17:     read_clipboard,
   18: )
   19: import pandas._testing as tm
   20: from pandas.core.arrays import (
   21:     ArrowStringArray,
   22:     StringArray,
   23: )
   24: 
   25: from pandas.io.clipboard import (
   26:     CheckedCall,
   27:     _stringifyText,
   28:     init_qt_clipboard,
   29: )
   30: 
   31: 
   32: def build_kwargs(sep, excel):
   33:     kwargs = {}
   34:     if excel != "default":
   35:         kwargs["excel"] = excel
   36:     if sep != "default":
   37:         kwargs["sep"] = sep
   38:     return kwargs
   39: 
   40: 
   41: @pytest.fixture(
   42:     params=[
   43:         "delims",
   44:         "utf8",
   45:         "utf16",
   46:         "string",
   47:         "long",
   48:         "nonascii",
   49:         "colwidth",
   50:         "mixed",
   51:         "float",
   52:         "int",
   53:     ]
   54: )
   55: def df(request):
   56:     data_type = request.param
   57: 
   58:     if data_type == "delims":
   59:         return DataFrame({"a": ['"a,\t"b|c', "d\tef`"], "b": ["hi'j", "k''lm"]})
   60:     elif data_type == "utf8":
   61:         return DataFrame({"a": ["Вµasd", "О©Е“в€‘`"], "b": ["ГёПЂв€†ЛљВ¬", "Е“в€‘`В®"]})
   62:     elif data_type == "utf16":
   63:         return DataFrame(
   64:             {"a": ["\U0001f44d\U0001f44d", "\U0001f44d\U0001f44d"], "b": ["abc", "def"]}
   65:         )
   66:     elif data_type == "string":
   67:         return DataFrame(
   68:             np.array([f"i-{i}" for i in range(15)]).reshape(5, 3), columns=list("abc")
   69:         )
   70:     elif data_type == "long":
   71:         max_rows = get_option("display.max_rows")
   72:         return DataFrame(
   73:             np.random.default_rng(2).integers(0, 10, size=(max_rows + 1, 3)),
   74:             columns=list("abc"),
   75:         )
   76:     elif data_type == "nonascii":
   77:         return DataFrame({"en": "in English".split(), "es": "en espaГ±ol".split()})
   78:     elif data_type == "colwidth":
   79:         _cw = get_option("display.max_colwidth") + 1
   80:         return DataFrame(
   81:             np.array(["x" * _cw for _ in range(15)]).reshape(5, 3), columns=list("abc")
   82:         )
   83:     elif data_type == "mixed":
   84:         return DataFrame(
   85:             {
   86:                 "a": np.arange(1.0, 6.0) + 0.01,
   87:                 "b": np.arange(1, 6).astype(np.int64),
   88:                 "c": list("abcde"),
   89:             }
   90:         )
   91:     elif data_type == "float":
   92:         return DataFrame(np.random.default_rng(2).random((5, 3)), columns=list("abc"))
   93:     elif data_type == "int":
   94:         return DataFrame(
   95:             np.random.default_rng(2).integers(0, 10, (5, 3)), columns=list("abc")
   96:         )
   97:     else:
   98:         raise ValueError
   99: 
  100: 
  101: @pytest.fixture
  102: def mock_ctypes(monkeypatch):
  103:     """
  104:     Mocks WinError to help with testing the clipboard.
  105:     """
  106: 
  107:     def _mock_win_error():
  108:         return "Window Error"
  109: 
  110:     # Set raising to False because WinError won't exist on non-windows platforms
  111:     with monkeypatch.context() as m:
  112:         m.setattr("ctypes.WinError", _mock_win_error, raising=False)
  113:         yield
  114: 
  115: 
  116: @pytest.mark.usefixtures("mock_ctypes")
  117: def test_checked_call_with_bad_call(monkeypatch):
  118:     """
  119:     Give CheckCall a function that returns a falsey value and
  120:     mock get_errno so it returns false so an exception is raised.
  121:     """
  122: 
  123:     def _return_false():
  124:         return False
  125: 
  126:     monkeypatch.setattr("pandas.io.clipboard.get_errno", lambda: True)
  127:     msg = f"Error calling {_return_false.__name__} \\(Window Error\\)"
  128: 
  129:     with pytest.raises(PyperclipWindowsException, match=msg):
  130:         CheckedCall(_return_false)()
  131: 
  132: 
  133: @pytest.mark.usefixtures("mock_ctypes")
  134: def test_checked_call_with_valid_call(monkeypatch):
  135:     """
  136:     Give CheckCall a function that returns a truthy value and
  137:     mock get_errno so it returns true so an exception is not raised.
  138:     The function should return the results from _return_true.
  139:     """
  140: 
  141:     def _return_true():
  142:         return True
  143: 
  144:     monkeypatch.setattr("pandas.io.clipboard.get_errno", lambda: False)
  145: 
  146:     # Give CheckedCall a callable that returns a truthy value s
  147:     checked_call = CheckedCall(_return_true)
  148:     assert checked_call() is True
  149: 
  150: 
  151: @pytest.mark.parametrize(
  152:     "text",
  153:     [
  154:         "String_test",
  155:         True,
  156:         1,
  157:         1.0,
  158:         1j,
  159:     ],
  160: )
  161: def test_stringify_text(text):
  162:     valid_types = (str, int, float, bool)
  163: 
  164:     if isinstance(text, valid_types):
  165:         result = _stringifyText(text)
  166:         assert result == str(text)
  167:     else:
  168:         msg = (
  169:             "only str, int, float, and bool values "
  170:             f"can be copied to the clipboard, not {type(text).__name__}"
  171:         )
  172:         with pytest.raises(PyperclipException, match=msg):
  173:             _stringifyText(text)
  174: 
  175: 
  176: @pytest.fixture
  177: def set_pyqt_clipboard(monkeypatch):
  178:     qt_cut, qt_paste = init_qt_clipboard()
  179:     with monkeypatch.context() as m:
  180:         m.setattr(pd.io.clipboard, "clipboard_set", qt_cut)
  181:         m.setattr(pd.io.clipboard, "clipboard_get", qt_paste)
  182:         yield
  183: 
  184: 
  185: @pytest.fixture
  186: def clipboard(qapp):
  187:     clip = qapp.clipboard()
  188:     yield clip
  189:     clip.clear()
  190: 
  191: 
  192: @pytest.mark.single_cpu
  193: @pytest.mark.clipboard
  194: @pytest.mark.usefixtures("set_pyqt_clipboard")
  195: @pytest.mark.usefixtures("clipboard")
  196: class TestClipboard:
  197:     # Test that default arguments copy as tab delimited
  198:     # Test that explicit delimiters are respected
  199:     @pytest.mark.parametrize("sep", [None, "\t", ",", "|"])
  200:     @pytest.mark.parametrize("encoding", [None, "UTF-8", "utf-8", "utf8"])
  201:     def test_round_trip_frame_sep(self, df, sep, encoding):
  202:         df.to_clipboard(excel=None, sep=sep, encoding=encoding)
  203:         result = read_clipboard(sep=sep or "\t", index_col=0, encoding=encoding)
  204:         tm.assert_frame_equal(df, result)
  205: 
  206:     # Test white space separator
  207:     def test_round_trip_frame_string(self, df):
  208:         df.to_clipboard(excel=False, sep=None)
  209:         result = read_clipboard()
  210:         assert df.to_string() == result.to_string()
  211:         assert df.shape == result.shape
  212: 
  213:     # Two character separator is not supported in to_clipboard
  214:     # Test that multi-character separators are not silently passed
  215:     def test_excel_sep_warning(self, df):
  216:         with tm.assert_produces_warning(
  217:             UserWarning,
  218:             match="to_clipboard in excel mode requires a single character separator.",
  219:             check_stacklevel=False,
  220:         ):
  221:             df.to_clipboard(excel=True, sep=r"\t")
  222: 
  223:     # Separator is ignored when excel=False and should produce a warning
  224:     def test_copy_delim_warning(self, df):
  225:         with tm.assert_produces_warning():
  226:             df.to_clipboard(excel=False, sep="\t")
  227: 
  228:     # Tests that the default behavior of to_clipboard is tab
  229:     # delimited and excel="True"
  230:     @pytest.mark.parametrize("sep", ["\t", None, "default"])
  231:     @pytest.mark.parametrize("excel", [True, None, "default"])
  232:     def test_clipboard_copy_tabs_default(self, sep, excel, df, clipboard):
  233:         kwargs = build_kwargs(sep, excel)
  234:         df.to_clipboard(**kwargs)
  235:         assert clipboard.text() == df.to_csv(sep="\t")
  236: 
  237:     # Tests reading of white space separated tables
  238:     @pytest.mark.parametrize("sep", [None, "default"])
  239:     def test_clipboard_copy_strings(self, sep, df):
  240:         kwargs = build_kwargs(sep, False)
  241:         df.to_clipboard(**kwargs)
  242:         result = read_clipboard(sep=r"\s+")
  243:         assert result.to_string() == df.to_string()
  244:         assert df.shape == result.shape
  245: 
  246:     def test_read_clipboard_infer_excel(self, clipboard):
  247:         # gh-19010: avoid warnings
  248:         clip_kwargs = {"engine": "python"}
  249: 
  250:         text = dedent(
  251:             """
  252:             John James\tCharlie Mingus
  253:             1\t2
  254:             4\tHarry Carney
  255:             """.strip()
  256:         )
  257:         clipboard.setText(text)
  258:         df = read_clipboard(**clip_kwargs)
  259: 
  260:         # excel data is parsed correctly
  261:         assert df.iloc[1, 1] == "Harry Carney"
  262: 
  263:         # having diff tab counts doesn't trigger it
  264:         text = dedent(
  265:             """
  266:             a\t b
  267:             1  2
  268:             3  4
  269:             """.strip()
  270:         )
  271:         clipboard.setText(text)
  272:         res = read_clipboard(**clip_kwargs)
  273: 
  274:         text = dedent(
  275:             """
  276:             a  b
  277:             1  2
  278:             3  4
  279:             """.strip()
  280:         )
  281:         clipboard.setText(text)
  282:         exp = read_clipboard(**clip_kwargs)
  283: 
  284:         tm.assert_frame_equal(res, exp)
  285: 
  286:     def test_infer_excel_with_nulls(self, clipboard):
  287:         # GH41108
  288:         text = "col1\tcol2\n1\tred\n\tblue\n2\tgreen"
  289: 
  290:         clipboard.setText(text)
  291:         df = read_clipboard()
  292:         df_expected = DataFrame(
  293:             data={"col1": [1, None, 2], "col2": ["red", "blue", "green"]}
  294:         )
  295: 
  296:         # excel data is parsed correctly
  297:         tm.assert_frame_equal(df, df_expected)
  298: 
  299:     @pytest.mark.parametrize(
  300:         "multiindex",
  301:         [
  302:             (  # Can't use `dedent` here as it will remove the leading `\t`
  303:                 "\n".join(
  304:                     [
  305:                         "\t\t\tcol1\tcol2",
  306:                         "A\t0\tTrue\t1\tred",
  307:                         "A\t1\tTrue\t\tblue",
  308:                         "B\t0\tFalse\t2\tgreen",
  309:                     ]
  310:                 ),
  311:                 [["A", "A", "B"], [0, 1, 0], [True, True, False]],
  312:             ),
  313:             (
  314:                 "\n".join(
  315:                     ["\t\tcol1\tcol2", "A\t0\t1\tred", "A\t1\t\tblue", "B\t0\t2\tgreen"]
  316:                 ),
  317:                 [["A", "A", "B"], [0, 1, 0]],
  318:             ),
  319:         ],
  320:     )
  321:     def test_infer_excel_with_multiindex(self, clipboard, multiindex):
  322:         # GH41108
  323: 
  324:         clipboard.setText(multiindex[0])
  325:         df = read_clipboard()
  326:         df_expected = DataFrame(
  327:             data={"col1": [1, None, 2], "col2": ["red", "blue", "green"]},
  328:             index=multiindex[1],
  329:         )
  330: 
  331:         # excel data is parsed correctly
  332:         tm.assert_frame_equal(df, df_expected)
  333: 
  334:     def test_invalid_encoding(self, df):
  335:         msg = "clipboard only supports utf-8 encoding"
  336:         # test case for testing invalid encoding
  337:         with pytest.raises(ValueError, match=msg):
  338:             df.to_clipboard(encoding="ascii")
  339:         with pytest.raises(NotImplementedError, match=msg):
  340:             read_clipboard(encoding="ascii")
  341: 
  342:     @pytest.mark.parametrize("data", ["\U0001f44d...", "О©Е“в€‘`...", "abcd..."])
  343:     def test_raw_roundtrip(self, data):
  344:         # PR #25040 wide unicode wasn't copied correctly on PY3 on windows
  345:         df = DataFrame({"data": [data]})
  346:         df.to_clipboard()
  347:         result = read_clipboard()
  348:         tm.assert_frame_equal(df, result)
  349: 
  350:     @pytest.mark.parametrize("engine", ["c", "python"])
  351:     def test_read_clipboard_dtype_backend(
  352:         self, clipboard, string_storage, dtype_backend, engine
  353:     ):
  354:         # GH#50502
  355:         if string_storage == "pyarrow" or dtype_backend == "pyarrow":
  356:             pa = pytest.importorskip("pyarrow")
  357: 
  358:         if string_storage == "python":
  359:             string_array = StringArray(np.array(["x", "y"], dtype=np.object_))
  360:             string_array_na = StringArray(np.array(["x", NA], dtype=np.object_))
  361: 
  362:         elif dtype_backend == "pyarrow" and engine != "c":
  363:             pa = pytest.importorskip("pyarrow")
  364:             from pandas.arrays import ArrowExtensionArray
  365: 
  366:             string_array = ArrowExtensionArray(pa.array(["x", "y"]))
  367:             string_array_na = ArrowExtensionArray(pa.array(["x", None]))
  368: 
  369:         else:
  370:             string_array = ArrowStringArray(pa.array(["x", "y"]))
  371:             string_array_na = ArrowStringArray(pa.array(["x", None]))
  372: 
  373:         text = """a,b,c,d,e,f,g,h,i
  374: x,1,4.0,x,2,4.0,,True,False
  375: y,2,5.0,,,,,False,"""
  376:         clipboard.setText(text)
  377: 
  378:         with pd.option_context("mode.string_storage", string_storage):
  379:             result = read_clipboard(sep=",", dtype_backend=dtype_backend, engine=engine)
  380: 
  381:         expected = DataFrame(
  382:             {
  383:                 "a": string_array,
  384:                 "b": Series([1, 2], dtype="Int64"),
  385:                 "c": Series([4.0, 5.0], dtype="Float64"),
  386:                 "d": string_array_na,
  387:                 "e": Series([2, NA], dtype="Int64"),
  388:                 "f": Series([4.0, NA], dtype="Float64"),
  389:                 "g": Series([NA, NA], dtype="Int64"),
  390:                 "h": Series([True, False], dtype="boolean"),
  391:                 "i": Series([False, NA], dtype="boolean"),
  392:             }
  393:         )
  394:         if dtype_backend == "pyarrow":
  395:             from pandas.arrays import ArrowExtensionArray
  396: 
  397:             expected = DataFrame(
  398:                 {
  399:                     col: ArrowExtensionArray(pa.array(expected[col], from_pandas=True))
  400:                     for col in expected.columns
  401:                 }
  402:             )
  403:             expected["g"] = ArrowExtensionArray(pa.array([None, None]))
  404: 
  405:         tm.assert_frame_equal(result, expected)
  406: 
  407:     def test_invalid_dtype_backend(self):
  408:         msg = (
  409:             "dtype_backend numpy is invalid, only 'numpy_nullable' and "
  410:             "'pyarrow' are allowed."
  411:         )
  412:         with pytest.raises(ValueError, match=msg):
  413:             read_clipboard(dtype_backend="numpy")
  414: 
  415:     def test_to_clipboard_pos_args_deprecation(self):
  416:         # GH-54229
  417:         df = DataFrame({"a": [1, 2, 3]})
  418:         msg = (
  419:             r"Starting with pandas version 3.0 all arguments of to_clipboard "
  420:             r"will be keyword-only."
  421:         )
  422:         with tm.assert_produces_warning(FutureWarning, match=msg):
  423:             df.to_clipboard(True, None)
