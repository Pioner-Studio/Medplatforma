    1: """
    2: Tests that apply specifically to the Python parser. Unless specifically
    3: stated as a Python-specific issue, the goal is to eventually move as many of
    4: these tests out of this module as soon as the C parser can accept further
    5: arguments when parsing.
    6: """
    7: from __future__ import annotations
    8: 
    9: import csv
   10: from io import (
   11:     BytesIO,
   12:     StringIO,
   13:     TextIOWrapper,
   14: )
   15: from typing import TYPE_CHECKING
   16: 
   17: import numpy as np
   18: import pytest
   19: 
   20: from pandas.errors import (
   21:     ParserError,
   22:     ParserWarning,
   23: )
   24: 
   25: from pandas import (
   26:     DataFrame,
   27:     Index,
   28:     MultiIndex,
   29: )
   30: import pandas._testing as tm
   31: 
   32: if TYPE_CHECKING:
   33:     from collections.abc import Iterator
   34: 
   35: 
   36: def test_default_separator(python_parser_only):
   37:     # see gh-17333
   38:     #
   39:     # csv.Sniffer in Python treats "o" as separator.
   40:     data = "aob\n1o2\n3o4"
   41:     parser = python_parser_only
   42:     expected = DataFrame({"a": [1, 3], "b": [2, 4]})
   43: 
   44:     result = parser.read_csv(StringIO(data), sep=None)
   45:     tm.assert_frame_equal(result, expected)
   46: 
   47: 
   48: @pytest.mark.parametrize("skipfooter", ["foo", 1.5, True])
   49: def test_invalid_skipfooter_non_int(python_parser_only, skipfooter):
   50:     # see gh-15925 (comment)
   51:     data = "a\n1\n2"
   52:     parser = python_parser_only
   53:     msg = "skipfooter must be an integer"
   54: 
   55:     with pytest.raises(ValueError, match=msg):
   56:         parser.read_csv(StringIO(data), skipfooter=skipfooter)
   57: 
   58: 
   59: def test_invalid_skipfooter_negative(python_parser_only):
   60:     # see gh-15925 (comment)
   61:     data = "a\n1\n2"
   62:     parser = python_parser_only
   63:     msg = "skipfooter cannot be negative"
   64: 
   65:     with pytest.raises(ValueError, match=msg):
   66:         parser.read_csv(StringIO(data), skipfooter=-1)
   67: 
   68: 
   69: @pytest.mark.parametrize("kwargs", [{"sep": None}, {"delimiter": "|"}])
   70: def test_sniff_delimiter(python_parser_only, kwargs):
   71:     data = """index|A|B|C
   72: foo|1|2|3
   73: bar|4|5|6
   74: baz|7|8|9
   75: """
   76:     parser = python_parser_only
   77:     result = parser.read_csv(StringIO(data), index_col=0, **kwargs)
   78:     expected = DataFrame(
   79:         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
   80:         columns=["A", "B", "C"],
   81:         index=Index(["foo", "bar", "baz"], name="index"),
   82:     )
   83:     tm.assert_frame_equal(result, expected)
   84: 
   85: 
   86: def test_sniff_delimiter_comment(python_parser_only):
   87:     data = """# comment line
   88: index|A|B|C
   89: # comment line
   90: foo|1|2|3 # ignore | this
   91: bar|4|5|6
   92: baz|7|8|9
   93: """
   94:     parser = python_parser_only
   95:     result = parser.read_csv(StringIO(data), index_col=0, sep=None, comment="#")
   96:     expected = DataFrame(
   97:         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
   98:         columns=["A", "B", "C"],
   99:         index=Index(["foo", "bar", "baz"], name="index"),
  100:     )
  101:     tm.assert_frame_equal(result, expected)
  102: 
  103: 
  104: @pytest.mark.parametrize("encoding", [None, "utf-8"])
  105: def test_sniff_delimiter_encoding(python_parser_only, encoding):
  106:     parser = python_parser_only
  107:     data = """ignore this
  108: ignore this too
  109: index|A|B|C
  110: foo|1|2|3
  111: bar|4|5|6
  112: baz|7|8|9
  113: """
  114: 
  115:     if encoding is not None:
  116:         data = data.encode(encoding)
  117:         data = BytesIO(data)
  118:         data = TextIOWrapper(data, encoding=encoding)
  119:     else:
  120:         data = StringIO(data)
  121: 
  122:     result = parser.read_csv(data, index_col=0, sep=None, skiprows=2, encoding=encoding)
  123:     expected = DataFrame(
  124:         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
  125:         columns=["A", "B", "C"],
  126:         index=Index(["foo", "bar", "baz"], name="index"),
  127:     )
  128:     tm.assert_frame_equal(result, expected)
  129: 
  130: 
  131: def test_single_line(python_parser_only):
  132:     # see gh-6607: sniff separator
  133:     parser = python_parser_only
  134:     result = parser.read_csv(StringIO("1,2"), names=["a", "b"], header=None, sep=None)
  135: 
  136:     expected = DataFrame({"a": [1], "b": [2]})
  137:     tm.assert_frame_equal(result, expected)
  138: 
  139: 
  140: @pytest.mark.parametrize("kwargs", [{"skipfooter": 2}, {"nrows": 3}])
  141: def test_skipfooter(python_parser_only, kwargs):
  142:     # see gh-6607
  143:     data = """A,B,C
  144: 1,2,3
  145: 4,5,6
  146: 7,8,9
  147: want to skip this
  148: also also skip this
  149: """
  150:     parser = python_parser_only
  151:     result = parser.read_csv(StringIO(data), **kwargs)
  152: 
  153:     expected = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=["A", "B", "C"])
  154:     tm.assert_frame_equal(result, expected)
  155: 
  156: 
  157: @pytest.mark.parametrize(
  158:     "compression,klass", [("gzip", "GzipFile"), ("bz2", "BZ2File")]
  159: )
  160: def test_decompression_regex_sep(python_parser_only, csv1, compression, klass):
  161:     # see gh-6607
  162:     parser = python_parser_only
  163: 
  164:     with open(csv1, "rb") as f:
  165:         data = f.read()
  166: 
  167:     data = data.replace(b",", b"::")
  168:     expected = parser.read_csv(csv1)
  169: 
  170:     module = pytest.importorskip(compression)
  171:     klass = getattr(module, klass)
  172: 
  173:     with tm.ensure_clean() as path:
  174:         with klass(path, mode="wb") as tmp:
  175:             tmp.write(data)
  176: 
  177:         result = parser.read_csv(path, sep="::", compression=compression)
  178:         tm.assert_frame_equal(result, expected)
  179: 
  180: 
  181: def test_read_csv_buglet_4x_multi_index(python_parser_only):
  182:     # see gh-6607
  183:     data = """                      A       B       C       D        E
  184: one two three   four
  185: a   b   10.0032 5    -0.5109 -2.3358 -0.4645  0.05076  0.3640
  186: a   q   20      4     0.4473  1.4152  0.2834  1.00661  0.1744
  187: x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
  188:     parser = python_parser_only
  189: 
  190:     expected = DataFrame(
  191:         [
  192:             [-0.5109, -2.3358, -0.4645, 0.05076, 0.3640],
  193:             [0.4473, 1.4152, 0.2834, 1.00661, 0.1744],
  194:             [-0.6662, -0.5243, -0.3580, 0.89145, 2.5838],
  195:         ],
  196:         columns=["A", "B", "C", "D", "E"],
  197:         index=MultiIndex.from_tuples(
  198:             [("a", "b", 10.0032, 5), ("a", "q", 20, 4), ("x", "q", 30, 3)],
  199:             names=["one", "two", "three", "four"],
  200:         ),
  201:     )
  202:     result = parser.read_csv(StringIO(data), sep=r"\s+")
  203:     tm.assert_frame_equal(result, expected)
  204: 
  205: 
  206: def test_read_csv_buglet_4x_multi_index2(python_parser_only):
  207:     # see gh-6893
  208:     data = "      A B C\na b c\n1 3 7 0 3 6\n3 1 4 1 5 9"
  209:     parser = python_parser_only
  210: 
  211:     expected = DataFrame.from_records(
  212:         [(1, 3, 7, 0, 3, 6), (3, 1, 4, 1, 5, 9)],
  213:         columns=list("abcABC"),
  214:         index=list("abc"),
  215:     )
  216:     result = parser.read_csv(StringIO(data), sep=r"\s+")
  217:     tm.assert_frame_equal(result, expected)
  218: 
  219: 
  220: @pytest.mark.parametrize("add_footer", [True, False])
  221: def test_skipfooter_with_decimal(python_parser_only, add_footer):
  222:     # see gh-6971
  223:     data = "1#2\n3#4"
  224:     parser = python_parser_only
  225:     expected = DataFrame({"a": [1.2, 3.4]})
  226: 
  227:     if add_footer:
  228:         # The stray footer line should not mess with the
  229:         # casting of the first two lines if we skip it.
  230:         kwargs = {"skipfooter": 1}
  231:         data += "\nFooter"
  232:     else:
  233:         kwargs = {}
  234: 
  235:     result = parser.read_csv(StringIO(data), names=["a"], decimal="#", **kwargs)
  236:     tm.assert_frame_equal(result, expected)
  237: 
  238: 
  239: @pytest.mark.parametrize(
  240:     "sep", ["::", "#####", "!!!", "123", "#1!c5", "%!c!d", "@@#4:2", "_!pd#_"]
  241: )
  242: @pytest.mark.parametrize(
  243:     "encoding", ["utf-16", "utf-16-be", "utf-16-le", "utf-32", "cp037"]
  244: )
  245: def test_encoding_non_utf8_multichar_sep(python_parser_only, sep, encoding):
  246:     # see gh-3404
  247:     expected = DataFrame({"a": [1], "b": [2]})
  248:     parser = python_parser_only
  249: 
  250:     data = "1" + sep + "2"
  251:     encoded_data = data.encode(encoding)
  252: 
  253:     result = parser.read_csv(
  254:         BytesIO(encoded_data), sep=sep, names=["a", "b"], encoding=encoding
  255:     )
  256:     tm.assert_frame_equal(result, expected)
  257: 
  258: 
  259: @pytest.mark.parametrize("quoting", [csv.QUOTE_MINIMAL, csv.QUOTE_NONE])
  260: def test_multi_char_sep_quotes(python_parser_only, quoting):
  261:     # see gh-13374
  262:     kwargs = {"sep": ",,"}
  263:     parser = python_parser_only
  264: 
  265:     data = 'a,,b\n1,,a\n2,,"2,,b"'
  266: 
  267:     if quoting == csv.QUOTE_NONE:
  268:         msg = "Expected 2 fields in line 3, saw 3"
  269:         with pytest.raises(ParserError, match=msg):
  270:             parser.read_csv(StringIO(data), quoting=quoting, **kwargs)
  271:     else:
  272:         msg = "ignored when a multi-char delimiter is used"
  273:         with pytest.raises(ParserError, match=msg):
  274:             parser.read_csv(StringIO(data), quoting=quoting, **kwargs)
  275: 
  276: 
  277: def test_none_delimiter(python_parser_only):
  278:     # see gh-13374 and gh-17465
  279:     parser = python_parser_only
  280:     data = "a,b,c\n0,1,2\n3,4,5,6\n7,8,9"
  281:     expected = DataFrame({"a": [0, 7], "b": [1, 8], "c": [2, 9]})
  282: 
  283:     # We expect the third line in the data to be
  284:     # skipped because it is malformed, but we do
  285:     # not expect any errors to occur.
  286:     with tm.assert_produces_warning(
  287:         ParserWarning, match="Skipping line 3", check_stacklevel=False
  288:     ):
  289:         result = parser.read_csv(
  290:             StringIO(data), header=0, sep=None, on_bad_lines="warn"
  291:         )
  292:     tm.assert_frame_equal(result, expected)
  293: 
  294: 
  295: @pytest.mark.parametrize("data", ['a\n1\n"b"a', 'a,b,c\ncat,foo,bar\ndog,foo,"baz'])
  296: @pytest.mark.parametrize("skipfooter", [0, 1])
  297: def test_skipfooter_bad_row(python_parser_only, data, skipfooter):
  298:     # see gh-13879 and gh-15910
  299:     parser = python_parser_only
  300:     if skipfooter:
  301:         msg = "parsing errors in the skipped footer rows"
  302:         with pytest.raises(ParserError, match=msg):
  303:             parser.read_csv(StringIO(data), skipfooter=skipfooter)
  304:     else:
  305:         msg = "unexpected end of data|expected after"
  306:         with pytest.raises(ParserError, match=msg):
  307:             parser.read_csv(StringIO(data), skipfooter=skipfooter)
  308: 
  309: 
  310: def test_malformed_skipfooter(python_parser_only):
  311:     parser = python_parser_only
  312:     data = """ignore
  313: A,B,C
  314: 1,2,3 # comment
  315: 1,2,3,4,5
  316: 2,3,4
  317: footer
  318: """
  319:     msg = "Expected 3 fields in line 4, saw 5"
  320:     with pytest.raises(ParserError, match=msg):
  321:         parser.read_csv(StringIO(data), header=1, comment="#", skipfooter=1)
  322: 
  323: 
  324: def test_python_engine_file_no_next(python_parser_only):
  325:     parser = python_parser_only
  326: 
  327:     class NoNextBuffer:
  328:         def __init__(self, csv_data) -> None:
  329:             self.data = csv_data
  330: 
  331:         def __iter__(self) -> Iterator:
  332:             return self.data.__iter__()
  333: 
  334:         def read(self):
  335:             return self.data
  336: 
  337:         def readline(self):
  338:             return self.data
  339: 
  340:     parser.read_csv(NoNextBuffer("a\n1"))
  341: 
  342: 
  343: @pytest.mark.parametrize("bad_line_func", [lambda x: ["2", "3"], lambda x: x[:2]])
  344: def test_on_bad_lines_callable(python_parser_only, bad_line_func):
  345:     # GH 5686
  346:     parser = python_parser_only
  347:     data = """a,b
  348: 1,2
  349: 2,3,4,5,6
  350: 3,4
  351: """
  352:     bad_sio = StringIO(data)
  353:     result = parser.read_csv(bad_sio, on_bad_lines=bad_line_func)
  354:     expected = DataFrame({"a": [1, 2, 3], "b": [2, 3, 4]})
  355:     tm.assert_frame_equal(result, expected)
  356: 
  357: 
  358: def test_on_bad_lines_callable_write_to_external_list(python_parser_only):
  359:     # GH 5686
  360:     parser = python_parser_only
  361:     data = """a,b
  362: 1,2
  363: 2,3,4,5,6
  364: 3,4
  365: """
  366:     bad_sio = StringIO(data)
  367:     lst = []
  368: 
  369:     def bad_line_func(bad_line: list[str]) -> list[str]:
  370:         lst.append(bad_line)
  371:         return ["2", "3"]
  372: 
  373:     result = parser.read_csv(bad_sio, on_bad_lines=bad_line_func)
  374:     expected = DataFrame({"a": [1, 2, 3], "b": [2, 3, 4]})
  375:     tm.assert_frame_equal(result, expected)
  376:     assert lst == [["2", "3", "4", "5", "6"]]
  377: 
  378: 
  379: @pytest.mark.parametrize("bad_line_func", [lambda x: ["foo", "bar"], lambda x: x[:2]])
  380: @pytest.mark.parametrize("sep", [",", "111"])
  381: def test_on_bad_lines_callable_iterator_true(python_parser_only, bad_line_func, sep):
  382:     # GH 5686
  383:     # iterator=True has a separate code path than iterator=False
  384:     parser = python_parser_only
  385:     data = f"""
  386: 0{sep}1
  387: hi{sep}there
  388: foo{sep}bar{sep}baz
  389: good{sep}bye
  390: """
  391:     bad_sio = StringIO(data)
  392:     result_iter = parser.read_csv(
  393:         bad_sio, on_bad_lines=bad_line_func, chunksize=1, iterator=True, sep=sep
  394:     )
  395:     expecteds = [
  396:         {"0": "hi", "1": "there"},
  397:         {"0": "foo", "1": "bar"},
  398:         {"0": "good", "1": "bye"},
  399:     ]
  400:     for i, (result, expected) in enumerate(zip(result_iter, expecteds)):
  401:         expected = DataFrame(expected, index=range(i, i + 1))
  402:         tm.assert_frame_equal(result, expected)
  403: 
  404: 
  405: def test_on_bad_lines_callable_dont_swallow_errors(python_parser_only):
  406:     # GH 5686
  407:     parser = python_parser_only
  408:     data = """a,b
  409: 1,2
  410: 2,3,4,5,6
  411: 3,4
  412: """
  413:     bad_sio = StringIO(data)
  414:     msg = "This function is buggy."
  415: 
  416:     def bad_line_func(bad_line):
  417:         raise ValueError(msg)
  418: 
  419:     with pytest.raises(ValueError, match=msg):
  420:         parser.read_csv(bad_sio, on_bad_lines=bad_line_func)
  421: 
  422: 
  423: def test_on_bad_lines_callable_not_expected_length(python_parser_only):
  424:     # GH 5686
  425:     parser = python_parser_only
  426:     data = """a,b
  427: 1,2
  428: 2,3,4,5,6
  429: 3,4
  430: """
  431:     bad_sio = StringIO(data)
  432: 
  433:     result = parser.read_csv_check_warnings(
  434:         ParserWarning, "Length of header or names", bad_sio, on_bad_lines=lambda x: x
  435:     )
  436:     expected = DataFrame({"a": [1, 2, 3], "b": [2, 3, 4]})
  437:     tm.assert_frame_equal(result, expected)
  438: 
  439: 
  440: def test_on_bad_lines_callable_returns_none(python_parser_only):
  441:     # GH 5686
  442:     parser = python_parser_only
  443:     data = """a,b
  444: 1,2
  445: 2,3,4,5,6
  446: 3,4
  447: """
  448:     bad_sio = StringIO(data)
  449: 
  450:     result = parser.read_csv(bad_sio, on_bad_lines=lambda x: None)
  451:     expected = DataFrame({"a": [1, 3], "b": [2, 4]})
  452:     tm.assert_frame_equal(result, expected)
  453: 
  454: 
  455: def test_on_bad_lines_index_col_inferred(python_parser_only):
  456:     # GH 5686
  457:     parser = python_parser_only
  458:     data = """a,b
  459: 1,2,3
  460: 4,5,6
  461: """
  462:     bad_sio = StringIO(data)
  463: 
  464:     result = parser.read_csv(bad_sio, on_bad_lines=lambda x: ["99", "99"])
  465:     expected = DataFrame({"a": [2, 5], "b": [3, 6]}, index=[1, 4])
  466:     tm.assert_frame_equal(result, expected)
  467: 
  468: 
  469: def test_index_col_false_and_header_none(python_parser_only):
  470:     # GH#46955
  471:     parser = python_parser_only
  472:     data = """
  473: 0.5,0.03
  474: 0.1,0.2,0.3,2
  475: """
  476:     result = parser.read_csv_check_warnings(
  477:         ParserWarning,
  478:         "Length of header",
  479:         StringIO(data),
  480:         sep=",",
  481:         header=None,
  482:         index_col=False,
  483:     )
  484:     expected = DataFrame({0: [0.5, 0.1], 1: [0.03, 0.2]})
  485:     tm.assert_frame_equal(result, expected)
  486: 
  487: 
  488: def test_header_int_do_not_infer_multiindex_names_on_different_line(python_parser_only):
  489:     # GH#46569
  490:     parser = python_parser_only
  491:     data = StringIO("a\na,b\nc,d,e\nf,g,h")
  492:     result = parser.read_csv_check_warnings(
  493:         ParserWarning, "Length of header", data, engine="python", index_col=False
  494:     )
  495:     expected = DataFrame({"a": ["a", "c", "f"]})
  496:     tm.assert_frame_equal(result, expected)
  497: 
  498: 
  499: @pytest.mark.parametrize(
  500:     "dtype", [{"a": object}, {"a": str, "b": np.int64, "c": np.int64}]
  501: )
  502: def test_no_thousand_convert_with_dot_for_non_numeric_cols(python_parser_only, dtype):
  503:     # GH#50270
  504:     parser = python_parser_only
  505:     data = """\
  506: a;b;c
  507: 0000.7995;16.000;0
  508: 3.03.001.00514;0;4.000
  509: 4923.600.041;23.000;131"""
  510:     result = parser.read_csv(
  511:         StringIO(data),
  512:         sep=";",
  513:         dtype=dtype,
  514:         thousands=".",
  515:     )
  516:     expected = DataFrame(
  517:         {
  518:             "a": ["0000.7995", "3.03.001.00514", "4923.600.041"],
  519:             "b": [16000, 0, 23000],
  520:             "c": [0, 4000, 131],
  521:         }
  522:     )
  523:     tm.assert_frame_equal(result, expected)
  524: 
  525: 
  526: @pytest.mark.parametrize(
  527:     "dtype,expected",
  528:     [
  529:         (
  530:             {"a": str, "b": np.float64, "c": np.int64},
  531:             DataFrame(
  532:                 {
  533:                     "b": [16000.1, 0, 23000],
  534:                     "c": [0, 4001, 131],
  535:                 }
  536:             ),
  537:         ),
  538:         (
  539:             str,
  540:             DataFrame(
  541:                 {
  542:                     "b": ["16,000.1", "0", "23,000"],
  543:                     "c": ["0", "4,001", "131"],
  544:                 }
  545:             ),
  546:         ),
  547:     ],
  548: )
  549: def test_no_thousand_convert_for_non_numeric_cols(python_parser_only, dtype, expected):
  550:     # GH#50270
  551:     parser = python_parser_only
  552:     data = """a;b;c
  553: 0000,7995;16,000.1;0
  554: 3,03,001,00514;0;4,001
  555: 4923,600,041;23,000;131
  556: """
  557:     result = parser.read_csv(
  558:         StringIO(data),
  559:         sep=";",
  560:         dtype=dtype,
  561:         thousands=",",
  562:     )
  563:     expected.insert(0, "a", ["0000,7995", "3,03,001,00514", "4923,600,041"])
  564:     tm.assert_frame_equal(result, expected)
