    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     Categorical,
    6:     DataFrame,
    7:     Series,
    8:     _testing as tm,
    9:     concat,
   10:     read_hdf,
   11: )
   12: from pandas.tests.io.pytables.common import (
   13:     _maybe_remove,
   14:     ensure_clean_store,
   15: )
   16: 
   17: pytestmark = pytest.mark.single_cpu
   18: 
   19: 
   20: def test_categorical(setup_path):
   21:     with ensure_clean_store(setup_path) as store:
   22:         # Basic
   23:         _maybe_remove(store, "s")
   24:         s = Series(
   25:             Categorical(
   26:                 ["a", "b", "b", "a", "a", "c"],
   27:                 categories=["a", "b", "c", "d"],
   28:                 ordered=False,
   29:             )
   30:         )
   31:         store.append("s", s, format="table")
   32:         result = store.select("s")
   33:         tm.assert_series_equal(s, result)
   34: 
   35:         _maybe_remove(store, "s_ordered")
   36:         s = Series(
   37:             Categorical(
   38:                 ["a", "b", "b", "a", "a", "c"],
   39:                 categories=["a", "b", "c", "d"],
   40:                 ordered=True,
   41:             )
   42:         )
   43:         store.append("s_ordered", s, format="table")
   44:         result = store.select("s_ordered")
   45:         tm.assert_series_equal(s, result)
   46: 
   47:         _maybe_remove(store, "df")
   48:         df = DataFrame({"s": s, "vals": [1, 2, 3, 4, 5, 6]})
   49:         store.append("df", df, format="table")
   50:         result = store.select("df")
   51:         tm.assert_frame_equal(result, df)
   52: 
   53:         # Dtypes
   54:         _maybe_remove(store, "si")
   55:         s = Series([1, 1, 2, 2, 3, 4, 5]).astype("category")
   56:         store.append("si", s)
   57:         result = store.select("si")
   58:         tm.assert_series_equal(result, s)
   59: 
   60:         _maybe_remove(store, "si2")
   61:         s = Series([1, 1, np.nan, 2, 3, 4, 5]).astype("category")
   62:         store.append("si2", s)
   63:         result = store.select("si2")
   64:         tm.assert_series_equal(result, s)
   65: 
   66:         # Multiple
   67:         _maybe_remove(store, "df2")
   68:         df2 = df.copy()
   69:         df2["s2"] = Series(list("abcdefg")).astype("category")
   70:         store.append("df2", df2)
   71:         result = store.select("df2")
   72:         tm.assert_frame_equal(result, df2)
   73: 
   74:         # Make sure the metadata is OK
   75:         info = store.info()
   76:         assert "/df2   " in info
   77:         # df2._mgr.blocks[0] and df2._mgr.blocks[2] are Categorical
   78:         assert "/df2/meta/values_block_0/meta" in info
   79:         assert "/df2/meta/values_block_2/meta" in info
   80: 
   81:         # unordered
   82:         _maybe_remove(store, "s2")
   83:         s = Series(
   84:             Categorical(
   85:                 ["a", "b", "b", "a", "a", "c"],
   86:                 categories=["a", "b", "c", "d"],
   87:                 ordered=False,
   88:             )
   89:         )
   90:         store.append("s2", s, format="table")
   91:         result = store.select("s2")
   92:         tm.assert_series_equal(result, s)
   93: 
   94:         # Query
   95:         _maybe_remove(store, "df3")
   96:         store.append("df3", df, data_columns=["s"])
   97:         expected = df[df.s.isin(["b", "c"])]
   98:         result = store.select("df3", where=['s in ["b","c"]'])
   99:         tm.assert_frame_equal(result, expected)
  100: 
  101:         expected = df[df.s.isin(["b", "c"])]
  102:         result = store.select("df3", where=['s = ["b","c"]'])
  103:         tm.assert_frame_equal(result, expected)
  104: 
  105:         expected = df[df.s.isin(["d"])]
  106:         result = store.select("df3", where=['s in ["d"]'])
  107:         tm.assert_frame_equal(result, expected)
  108: 
  109:         expected = df[df.s.isin(["f"])]
  110:         result = store.select("df3", where=['s in ["f"]'])
  111:         tm.assert_frame_equal(result, expected)
  112: 
  113:         # Appending with same categories is ok
  114:         store.append("df3", df)
  115: 
  116:         df = concat([df, df])
  117:         expected = df[df.s.isin(["b", "c"])]
  118:         result = store.select("df3", where=['s in ["b","c"]'])
  119:         tm.assert_frame_equal(result, expected)
  120: 
  121:         # Appending must have the same categories
  122:         df3 = df.copy()
  123:         df3["s"] = df3["s"].cat.remove_unused_categories()
  124: 
  125:         msg = "cannot append a categorical with different categories to the existing"
  126:         with pytest.raises(ValueError, match=msg):
  127:             store.append("df3", df3)
  128: 
  129:         # Remove, and make sure meta data is removed (its a recursive
  130:         # removal so should be).
  131:         result = store.select("df3/meta/s/meta")
  132:         assert result is not None
  133:         store.remove("df3")
  134: 
  135:         with pytest.raises(
  136:             KeyError, match="'No object named df3/meta/s/meta in the file'"
  137:         ):
  138:             store.select("df3/meta/s/meta")
  139: 
  140: 
  141: def test_categorical_conversion(tmp_path, setup_path):
  142:     # GH13322
  143:     # Check that read_hdf with categorical columns doesn't return rows if
  144:     # where criteria isn't met.
  145:     obsids = ["ESP_012345_6789", "ESP_987654_3210"]
  146:     imgids = ["APF00006np", "APF0001imm"]
  147:     data = [4.3, 9.8]
  148: 
  149:     # Test without categories
  150:     df = DataFrame({"obsids": obsids, "imgids": imgids, "data": data})
  151: 
  152:     # We are expecting an empty DataFrame matching types of df
  153:     expected = df.iloc[[], :]
  154:     path = tmp_path / setup_path
  155:     df.to_hdf(path, key="df", format="table", data_columns=True)
  156:     result = read_hdf(path, "df", where="obsids=B")
  157:     tm.assert_frame_equal(result, expected)
  158: 
  159:     # Test with categories
  160:     df.obsids = df.obsids.astype("category")
  161:     df.imgids = df.imgids.astype("category")
  162: 
  163:     # We are expecting an empty DataFrame matching types of df
  164:     expected = df.iloc[[], :]
  165:     path = tmp_path / setup_path
  166:     df.to_hdf(path, key="df", format="table", data_columns=True)
  167:     result = read_hdf(path, "df", where="obsids=B")
  168:     tm.assert_frame_equal(result, expected)
  169: 
  170: 
  171: def test_categorical_nan_only_columns(tmp_path, setup_path):
  172:     # GH18413
  173:     # Check that read_hdf with categorical columns with NaN-only values can
  174:     # be read back.
  175:     df = DataFrame(
  176:         {
  177:             "a": ["a", "b", "c", np.nan],
  178:             "b": [np.nan, np.nan, np.nan, np.nan],
  179:             "c": [1, 2, 3, 4],
  180:             "d": Series([None] * 4, dtype=object),
  181:         }
  182:     )
  183:     df["a"] = df.a.astype("category")
  184:     df["b"] = df.b.astype("category")
  185:     df["d"] = df.b.astype("category")
  186:     expected = df
  187:     path = tmp_path / setup_path
  188:     df.to_hdf(path, key="df", format="table", data_columns=True)
  189:     result = read_hdf(path, "df")
  190:     tm.assert_frame_equal(result, expected)
  191: 
  192: 
  193: @pytest.mark.parametrize(
  194:     "where, df, expected",
  195:     [
  196:         ('col=="q"', DataFrame({"col": ["a", "b", "s"]}), DataFrame({"col": []})),
  197:         ('col=="a"', DataFrame({"col": ["a", "b", "s"]}), DataFrame({"col": ["a"]})),
  198:     ],
  199: )
  200: def test_convert_value(
  201:     tmp_path, setup_path, where: str, df: DataFrame, expected: DataFrame
  202: ):
  203:     # GH39420
  204:     # Check that read_hdf with categorical columns can filter by where condition.
  205:     df.col = df.col.astype("category")
  206:     max_widths = {"col": 1}
  207:     categorical_values = sorted(df.col.unique())
  208:     expected.col = expected.col.astype("category")
  209:     expected.col = expected.col.cat.set_categories(categorical_values)
  210: 
  211:     path = tmp_path / setup_path
  212:     df.to_hdf(path, key="df", format="table", min_itemsize=max_widths)
  213:     result = read_hdf(path, where=where)
  214:     tm.assert_frame_equal(result, expected)
