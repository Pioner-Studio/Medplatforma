    1: """
    2: Tests that the specified index column (a.k.a "index_col")
    3: is properly handled or inferred during parsing for all of
    4: the parsers defined in parsers.py
    5: """
    6: from io import StringIO
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas import (
   12:     DataFrame,
   13:     Index,
   14:     MultiIndex,
   15: )
   16: import pandas._testing as tm
   17: 
   18: pytestmark = pytest.mark.filterwarnings(
   19:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   20: )
   21: 
   22: xfail_pyarrow = pytest.mark.usefixtures("pyarrow_xfail")
   23: skip_pyarrow = pytest.mark.usefixtures("pyarrow_skip")
   24: 
   25: 
   26: @pytest.mark.parametrize("with_header", [True, False])
   27: def test_index_col_named(all_parsers, with_header):
   28:     parser = all_parsers
   29:     no_header = """\
   30: KORD1,19990127, 19:00:00, 18:56:00, 0.8100, 2.8100, 7.2000, 0.0000, 280.0000
   31: KORD2,19990127, 20:00:00, 19:56:00, 0.0100, 2.2100, 7.2000, 0.0000, 260.0000
   32: KORD3,19990127, 21:00:00, 20:56:00, -0.5900, 2.2100, 5.7000, 0.0000, 280.0000
   33: KORD4,19990127, 21:00:00, 21:18:00, -0.9900, 2.0100, 3.6000, 0.0000, 270.0000
   34: KORD5,19990127, 22:00:00, 21:56:00, -0.5900, 1.7100, 5.1000, 0.0000, 290.0000
   35: KORD6,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000"""
   36:     header = "ID,date,NominalTime,ActualTime,TDew,TAir,Windspeed,Precip,WindDir\n"
   37: 
   38:     if with_header:
   39:         data = header + no_header
   40: 
   41:         result = parser.read_csv(StringIO(data), index_col="ID")
   42:         expected = parser.read_csv(StringIO(data), header=0).set_index("ID")
   43:         tm.assert_frame_equal(result, expected)
   44:     else:
   45:         data = no_header
   46:         msg = "Index ID invalid"
   47: 
   48:         with pytest.raises(ValueError, match=msg):
   49:             parser.read_csv(StringIO(data), index_col="ID")
   50: 
   51: 
   52: def test_index_col_named2(all_parsers):
   53:     parser = all_parsers
   54:     data = """\
   55: 1,2,3,4,hello
   56: 5,6,7,8,world
   57: 9,10,11,12,foo
   58: """
   59: 
   60:     expected = DataFrame(
   61:         {"a": [1, 5, 9], "b": [2, 6, 10], "c": [3, 7, 11], "d": [4, 8, 12]},
   62:         index=Index(["hello", "world", "foo"], name="message"),
   63:     )
   64:     names = ["a", "b", "c", "d", "message"]
   65: 
   66:     result = parser.read_csv(StringIO(data), names=names, index_col=["message"])
   67:     tm.assert_frame_equal(result, expected)
   68: 
   69: 
   70: def test_index_col_is_true(all_parsers):
   71:     # see gh-9798
   72:     data = "a,b\n1,2"
   73:     parser = all_parsers
   74: 
   75:     msg = "The value of index_col couldn't be 'True'"
   76:     with pytest.raises(ValueError, match=msg):
   77:         parser.read_csv(StringIO(data), index_col=True)
   78: 
   79: 
   80: @skip_pyarrow  # CSV parse error: Expected 3 columns, got 4
   81: def test_infer_index_col(all_parsers):
   82:     data = """A,B,C
   83: foo,1,2,3
   84: bar,4,5,6
   85: baz,7,8,9
   86: """
   87:     parser = all_parsers
   88:     result = parser.read_csv(StringIO(data))
   89: 
   90:     expected = DataFrame(
   91:         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
   92:         index=["foo", "bar", "baz"],
   93:         columns=["A", "B", "C"],
   94:     )
   95:     tm.assert_frame_equal(result, expected)
   96: 
   97: 
   98: @skip_pyarrow  # CSV parse error: Empty CSV file or block
   99: @pytest.mark.parametrize(
  100:     "index_col,kwargs",
  101:     [
  102:         (None, {"columns": ["x", "y", "z"]}),
  103:         (False, {"columns": ["x", "y", "z"]}),
  104:         (0, {"columns": ["y", "z"], "index": Index([], name="x")}),
  105:         (1, {"columns": ["x", "z"], "index": Index([], name="y")}),
  106:         ("x", {"columns": ["y", "z"], "index": Index([], name="x")}),
  107:         ("y", {"columns": ["x", "z"], "index": Index([], name="y")}),
  108:         (
  109:             [0, 1],
  110:             {
  111:                 "columns": ["z"],
  112:                 "index": MultiIndex.from_arrays([[]] * 2, names=["x", "y"]),
  113:             },
  114:         ),
  115:         (
  116:             ["x", "y"],
  117:             {
  118:                 "columns": ["z"],
  119:                 "index": MultiIndex.from_arrays([[]] * 2, names=["x", "y"]),
  120:             },
  121:         ),
  122:         (
  123:             [1, 0],
  124:             {
  125:                 "columns": ["z"],
  126:                 "index": MultiIndex.from_arrays([[]] * 2, names=["y", "x"]),
  127:             },
  128:         ),
  129:         (
  130:             ["y", "x"],
  131:             {
  132:                 "columns": ["z"],
  133:                 "index": MultiIndex.from_arrays([[]] * 2, names=["y", "x"]),
  134:             },
  135:         ),
  136:     ],
  137: )
  138: def test_index_col_empty_data(all_parsers, index_col, kwargs):
  139:     data = "x,y,z"
  140:     parser = all_parsers
  141:     result = parser.read_csv(StringIO(data), index_col=index_col)
  142: 
  143:     expected = DataFrame(**kwargs)
  144:     tm.assert_frame_equal(result, expected)
  145: 
  146: 
  147: @skip_pyarrow  # CSV parse error: Empty CSV file or block
  148: def test_empty_with_index_col_false(all_parsers):
  149:     # see gh-10413
  150:     data = "x,y"
  151:     parser = all_parsers
  152:     result = parser.read_csv(StringIO(data), index_col=False)
  153: 
  154:     expected = DataFrame(columns=["x", "y"])
  155:     tm.assert_frame_equal(result, expected)
  156: 
  157: 
  158: @pytest.mark.parametrize(
  159:     "index_names",
  160:     [
  161:         ["", ""],
  162:         ["foo", ""],
  163:         ["", "bar"],
  164:         ["foo", "bar"],
  165:         ["NotReallyUnnamed", "Unnamed: 0"],
  166:     ],
  167: )
  168: def test_multi_index_naming(all_parsers, index_names, request):
  169:     parser = all_parsers
  170: 
  171:     if parser.engine == "pyarrow" and "" in index_names:
  172:         mark = pytest.mark.xfail(reason="One case raises, others are wrong")
  173:         request.applymarker(mark)
  174: 
  175:     # We don't want empty index names being replaced with "Unnamed: 0"
  176:     data = ",".join(index_names + ["col\na,c,1\na,d,2\nb,c,3\nb,d,4"])
  177:     result = parser.read_csv(StringIO(data), index_col=[0, 1])
  178: 
  179:     expected = DataFrame(
  180:         {"col": [1, 2, 3, 4]}, index=MultiIndex.from_product([["a", "b"], ["c", "d"]])
  181:     )
  182:     expected.index.names = [name if name else None for name in index_names]
  183:     tm.assert_frame_equal(result, expected)
  184: 
  185: 
  186: @xfail_pyarrow  # ValueError: Found non-unique column index
  187: def test_multi_index_naming_not_all_at_beginning(all_parsers):
  188:     parser = all_parsers
  189:     data = ",Unnamed: 2,\na,c,1\na,d,2\nb,c,3\nb,d,4"
  190:     result = parser.read_csv(StringIO(data), index_col=[0, 2])
  191: 
  192:     expected = DataFrame(
  193:         {"Unnamed: 2": ["c", "d", "c", "d"]},
  194:         index=MultiIndex(
  195:             levels=[["a", "b"], [1, 2, 3, 4]], codes=[[0, 0, 1, 1], [0, 1, 2, 3]]
  196:         ),
  197:     )
  198:     tm.assert_frame_equal(result, expected)
  199: 
  200: 
  201: @xfail_pyarrow  # ValueError: Found non-unique column index
  202: def test_no_multi_index_level_names_empty(all_parsers):
  203:     # GH 10984
  204:     parser = all_parsers
  205:     midx = MultiIndex.from_tuples([("A", 1, 2), ("A", 1, 2), ("B", 1, 2)])
  206:     expected = DataFrame(
  207:         np.random.default_rng(2).standard_normal((3, 3)),
  208:         index=midx,
  209:         columns=["x", "y", "z"],
  210:     )
  211:     with tm.ensure_clean() as path:
  212:         expected.to_csv(path)
  213:         result = parser.read_csv(path, index_col=[0, 1, 2])
  214:     tm.assert_frame_equal(result, expected)
  215: 
  216: 
  217: @xfail_pyarrow  # TypeError: an integer is required
  218: def test_header_with_index_col(all_parsers):
  219:     # GH 33476
  220:     parser = all_parsers
  221:     data = """
  222: I11,A,A
  223: I12,B,B
  224: I2,1,3
  225: """
  226:     midx = MultiIndex.from_tuples([("A", "B"), ("A", "B.1")], names=["I11", "I12"])
  227:     idx = Index(["I2"])
  228:     expected = DataFrame([[1, 3]], index=idx, columns=midx)
  229: 
  230:     result = parser.read_csv(StringIO(data), index_col=0, header=[0, 1])
  231:     tm.assert_frame_equal(result, expected)
  232: 
  233:     col_idx = Index(["A", "A.1"])
  234:     idx = Index(["I12", "I2"], name="I11")
  235:     expected = DataFrame([["B", "B"], ["1", "3"]], index=idx, columns=col_idx)
  236: 
  237:     result = parser.read_csv(StringIO(data), index_col="I11", header=0)
  238:     tm.assert_frame_equal(result, expected)
  239: 
  240: 
  241: @pytest.mark.slow
  242: def test_index_col_large_csv(all_parsers, monkeypatch):
  243:     # https://github.com/pandas-dev/pandas/issues/37094
  244:     parser = all_parsers
  245: 
  246:     ARR_LEN = 100
  247:     df = DataFrame(
  248:         {
  249:             "a": range(ARR_LEN + 1),
  250:             "b": np.random.default_rng(2).standard_normal(ARR_LEN + 1),
  251:         }
  252:     )
  253: 
  254:     with tm.ensure_clean() as path:
  255:         df.to_csv(path, index=False)
  256:         with monkeypatch.context() as m:
  257:             m.setattr("pandas.core.algorithms._MINIMUM_COMP_ARR_LEN", ARR_LEN)
  258:             result = parser.read_csv(path, index_col=[0])
  259: 
  260:     tm.assert_frame_equal(result, df.set_index("a"))
  261: 
  262: 
  263: @xfail_pyarrow  # TypeError: an integer is required
  264: def test_index_col_multiindex_columns_no_data(all_parsers):
  265:     # GH#38292
  266:     parser = all_parsers
  267:     result = parser.read_csv(
  268:         StringIO("a0,a1,a2\nb0,b1,b2\n"), header=[0, 1], index_col=0
  269:     )
  270:     expected = DataFrame(
  271:         [],
  272:         index=Index([]),
  273:         columns=MultiIndex.from_arrays(
  274:             [["a1", "a2"], ["b1", "b2"]], names=["a0", "b0"]
  275:         ),
  276:     )
  277:     tm.assert_frame_equal(result, expected)
  278: 
  279: 
  280: @xfail_pyarrow  # TypeError: an integer is required
  281: def test_index_col_header_no_data(all_parsers):
  282:     # GH#38292
  283:     parser = all_parsers
  284:     result = parser.read_csv(StringIO("a0,a1,a2\n"), header=[0], index_col=0)
  285:     expected = DataFrame(
  286:         [],
  287:         columns=["a1", "a2"],
  288:         index=Index([], name="a0"),
  289:     )
  290:     tm.assert_frame_equal(result, expected)
  291: 
  292: 
  293: @xfail_pyarrow  # TypeError: an integer is required
  294: def test_multiindex_columns_no_data(all_parsers):
  295:     # GH#38292
  296:     parser = all_parsers
  297:     result = parser.read_csv(StringIO("a0,a1,a2\nb0,b1,b2\n"), header=[0, 1])
  298:     expected = DataFrame(
  299:         [], columns=MultiIndex.from_arrays([["a0", "a1", "a2"], ["b0", "b1", "b2"]])
  300:     )
  301:     tm.assert_frame_equal(result, expected)
  302: 
  303: 
  304: @xfail_pyarrow  # TypeError: an integer is required
  305: def test_multiindex_columns_index_col_with_data(all_parsers):
  306:     # GH#38292
  307:     parser = all_parsers
  308:     result = parser.read_csv(
  309:         StringIO("a0,a1,a2\nb0,b1,b2\ndata,data,data"), header=[0, 1], index_col=0
  310:     )
  311:     expected = DataFrame(
  312:         [["data", "data"]],
  313:         columns=MultiIndex.from_arrays(
  314:             [["a1", "a2"], ["b1", "b2"]], names=["a0", "b0"]
  315:         ),
  316:         index=Index(["data"]),
  317:     )
  318:     tm.assert_frame_equal(result, expected)
  319: 
  320: 
  321: @skip_pyarrow  # CSV parse error: Empty CSV file or block
  322: def test_infer_types_boolean_sum(all_parsers):
  323:     # GH#44079
  324:     parser = all_parsers
  325:     result = parser.read_csv(
  326:         StringIO("0,1"),
  327:         names=["a", "b"],
  328:         index_col=["a"],
  329:         dtype={"a": "UInt8"},
  330:     )
  331:     expected = DataFrame(
  332:         data={
  333:             "a": [
  334:                 0,
  335:             ],
  336:             "b": [1],
  337:         }
  338:     ).set_index("a")
  339:     # Not checking index type now, because the C parser will return a
  340:     # index column of dtype 'object', and the Python parser will return a
  341:     # index column of dtype 'int64'.
  342:     tm.assert_frame_equal(result, expected, check_index_type=False)
  343: 
  344: 
  345: @pytest.mark.parametrize("dtype, val", [(object, "01"), ("int64", 1)])
  346: def test_specify_dtype_for_index_col(all_parsers, dtype, val, request):
  347:     # GH#9435
  348:     data = "a,b\n01,2"
  349:     parser = all_parsers
  350:     if dtype == object and parser.engine == "pyarrow":
  351:         request.applymarker(
  352:             pytest.mark.xfail(reason="Cannot disable type-inference for pyarrow engine")
  353:         )
  354:     result = parser.read_csv(StringIO(data), index_col="a", dtype={"a": dtype})
  355:     expected = DataFrame({"b": [2]}, index=Index([val], name="a"))
  356:     tm.assert_frame_equal(result, expected)
  357: 
  358: 
  359: @xfail_pyarrow  # TypeError: an integer is required
  360: def test_multiindex_columns_not_leading_index_col(all_parsers):
  361:     # GH#38549
  362:     parser = all_parsers
  363:     data = """a,b,c,d
  364: e,f,g,h
  365: x,y,1,2
  366: """
  367:     result = parser.read_csv(
  368:         StringIO(data),
  369:         header=[0, 1],
  370:         index_col=1,
  371:     )
  372:     cols = MultiIndex.from_tuples(
  373:         [("a", "e"), ("c", "g"), ("d", "h")], names=["b", "f"]
  374:     )
  375:     expected = DataFrame([["x", 1, 2]], columns=cols, index=["y"])
  376:     tm.assert_frame_equal(result, expected)
