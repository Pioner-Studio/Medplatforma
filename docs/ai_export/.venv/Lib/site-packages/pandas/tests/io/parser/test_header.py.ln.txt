    1: """
    2: Tests that the file header is properly handled or inferred
    3: during parsing for all of the parsers defined in parsers.py
    4: """
    5: 
    6: from collections import namedtuple
    7: from io import StringIO
    8: 
    9: import numpy as np
   10: import pytest
   11: 
   12: from pandas.errors import ParserError
   13: 
   14: from pandas import (
   15:     DataFrame,
   16:     Index,
   17:     MultiIndex,
   18: )
   19: import pandas._testing as tm
   20: 
   21: pytestmark = pytest.mark.filterwarnings(
   22:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   23: )
   24: 
   25: xfail_pyarrow = pytest.mark.usefixtures("pyarrow_xfail")
   26: skip_pyarrow = pytest.mark.usefixtures("pyarrow_skip")
   27: 
   28: 
   29: @xfail_pyarrow  # TypeError: an integer is required
   30: def test_read_with_bad_header(all_parsers):
   31:     parser = all_parsers
   32:     msg = r"but only \d+ lines in file"
   33: 
   34:     with pytest.raises(ValueError, match=msg):
   35:         s = StringIO(",,")
   36:         parser.read_csv(s, header=[10])
   37: 
   38: 
   39: def test_negative_header(all_parsers):
   40:     # see gh-27779
   41:     parser = all_parsers
   42:     data = """1,2,3,4,5
   43: 6,7,8,9,10
   44: 11,12,13,14,15
   45: """
   46:     with pytest.raises(
   47:         ValueError,
   48:         match="Passing negative integer to header is invalid. "
   49:         "For no header, use header=None instead",
   50:     ):
   51:         parser.read_csv(StringIO(data), header=-1)
   52: 
   53: 
   54: @pytest.mark.parametrize("header", [([-1, 2, 4]), ([-5, 0])])
   55: def test_negative_multi_index_header(all_parsers, header):
   56:     # see gh-27779
   57:     parser = all_parsers
   58:     data = """1,2,3,4,5
   59:         6,7,8,9,10
   60:         11,12,13,14,15
   61:         """
   62:     with pytest.raises(
   63:         ValueError, match="cannot specify multi-index header with negative integers"
   64:     ):
   65:         parser.read_csv(StringIO(data), header=header)
   66: 
   67: 
   68: @pytest.mark.parametrize("header", [True, False])
   69: def test_bool_header_arg(all_parsers, header):
   70:     # see gh-6114
   71:     parser = all_parsers
   72:     data = """\
   73: MyColumn
   74: a
   75: b
   76: a
   77: b"""
   78:     msg = "Passing a bool to header is invalid"
   79:     with pytest.raises(TypeError, match=msg):
   80:         parser.read_csv(StringIO(data), header=header)
   81: 
   82: 
   83: @xfail_pyarrow  # AssertionError: DataFrame are different
   84: def test_header_with_index_col(all_parsers):
   85:     parser = all_parsers
   86:     data = """foo,1,2,3
   87: bar,4,5,6
   88: baz,7,8,9
   89: """
   90:     names = ["A", "B", "C"]
   91:     result = parser.read_csv(StringIO(data), names=names)
   92: 
   93:     expected = DataFrame(
   94:         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
   95:         index=["foo", "bar", "baz"],
   96:         columns=["A", "B", "C"],
   97:     )
   98:     tm.assert_frame_equal(result, expected)
   99: 
  100: 
  101: def test_header_not_first_line(all_parsers):
  102:     parser = all_parsers
  103:     data = """got,to,ignore,this,line
  104: got,to,ignore,this,line
  105: index,A,B,C,D
  106: foo,2,3,4,5
  107: bar,7,8,9,10
  108: baz,12,13,14,15
  109: """
  110:     data2 = """index,A,B,C,D
  111: foo,2,3,4,5
  112: bar,7,8,9,10
  113: baz,12,13,14,15
  114: """
  115: 
  116:     result = parser.read_csv(StringIO(data), header=2, index_col=0)
  117:     expected = parser.read_csv(StringIO(data2), header=0, index_col=0)
  118:     tm.assert_frame_equal(result, expected)
  119: 
  120: 
  121: @xfail_pyarrow  # TypeError: an integer is required
  122: def test_header_multi_index(all_parsers):
  123:     parser = all_parsers
  124: 
  125:     data = """\
  126: C0,,C_l0_g0,C_l0_g1,C_l0_g2
  127: 
  128: C1,,C_l1_g0,C_l1_g1,C_l1_g2
  129: C2,,C_l2_g0,C_l2_g1,C_l2_g2
  130: C3,,C_l3_g0,C_l3_g1,C_l3_g2
  131: R0,R1,,,
  132: R_l0_g0,R_l1_g0,R0C0,R0C1,R0C2
  133: R_l0_g1,R_l1_g1,R1C0,R1C1,R1C2
  134: R_l0_g2,R_l1_g2,R2C0,R2C1,R2C2
  135: R_l0_g3,R_l1_g3,R3C0,R3C1,R3C2
  136: R_l0_g4,R_l1_g4,R4C0,R4C1,R4C2
  137: """
  138:     result = parser.read_csv(StringIO(data), header=[0, 1, 2, 3], index_col=[0, 1])
  139:     data_gen_f = lambda r, c: f"R{r}C{c}"
  140: 
  141:     data = [[data_gen_f(r, c) for c in range(3)] for r in range(5)]
  142:     index = MultiIndex.from_arrays(
  143:         [[f"R_l0_g{i}" for i in range(5)], [f"R_l1_g{i}" for i in range(5)]],
  144:         names=["R0", "R1"],
  145:     )
  146:     columns = MultiIndex.from_arrays(
  147:         [
  148:             [f"C_l0_g{i}" for i in range(3)],
  149:             [f"C_l1_g{i}" for i in range(3)],
  150:             [f"C_l2_g{i}" for i in range(3)],
  151:             [f"C_l3_g{i}" for i in range(3)],
  152:         ],
  153:         names=["C0", "C1", "C2", "C3"],
  154:     )
  155:     expected = DataFrame(data, columns=columns, index=index)
  156:     tm.assert_frame_equal(result, expected)
  157: 
  158: 
  159: @pytest.mark.parametrize(
  160:     "kwargs,msg",
  161:     [
  162:         (
  163:             {"index_col": ["foo", "bar"]},
  164:             (
  165:                 "index_col must only contain "
  166:                 "row numbers when specifying "
  167:                 "a multi-index header"
  168:             ),
  169:         ),
  170:         (
  171:             {"index_col": [0, 1], "names": ["foo", "bar"]},
  172:             ("cannot specify names when specifying a multi-index header"),
  173:         ),
  174:         (
  175:             {"index_col": [0, 1], "usecols": ["foo", "bar"]},
  176:             ("cannot specify usecols when specifying a multi-index header"),
  177:         ),
  178:     ],
  179: )
  180: def test_header_multi_index_invalid(all_parsers, kwargs, msg):
  181:     data = """\
  182: C0,,C_l0_g0,C_l0_g1,C_l0_g2
  183: 
  184: C1,,C_l1_g0,C_l1_g1,C_l1_g2
  185: C2,,C_l2_g0,C_l2_g1,C_l2_g2
  186: C3,,C_l3_g0,C_l3_g1,C_l3_g2
  187: R0,R1,,,
  188: R_l0_g0,R_l1_g0,R0C0,R0C1,R0C2
  189: R_l0_g1,R_l1_g1,R1C0,R1C1,R1C2
  190: R_l0_g2,R_l1_g2,R2C0,R2C1,R2C2
  191: R_l0_g3,R_l1_g3,R3C0,R3C1,R3C2
  192: R_l0_g4,R_l1_g4,R4C0,R4C1,R4C2
  193: """
  194:     parser = all_parsers
  195: 
  196:     with pytest.raises(ValueError, match=msg):
  197:         parser.read_csv(StringIO(data), header=[0, 1, 2, 3], **kwargs)
  198: 
  199: 
  200: _TestTuple = namedtuple("_TestTuple", ["first", "second"])
  201: 
  202: 
  203: @xfail_pyarrow  # TypeError: an integer is required
  204: @pytest.mark.parametrize(
  205:     "kwargs",
  206:     [
  207:         {"header": [0, 1]},
  208:         {
  209:             "skiprows": 3,
  210:             "names": [
  211:                 ("a", "q"),
  212:                 ("a", "r"),
  213:                 ("a", "s"),
  214:                 ("b", "t"),
  215:                 ("c", "u"),
  216:                 ("c", "v"),
  217:             ],
  218:         },
  219:         {
  220:             "skiprows": 3,
  221:             "names": [
  222:                 _TestTuple("a", "q"),
  223:                 _TestTuple("a", "r"),
  224:                 _TestTuple("a", "s"),
  225:                 _TestTuple("b", "t"),
  226:                 _TestTuple("c", "u"),
  227:                 _TestTuple("c", "v"),
  228:             ],
  229:         },
  230:     ],
  231: )
  232: def test_header_multi_index_common_format1(all_parsers, kwargs):
  233:     parser = all_parsers
  234:     expected = DataFrame(
  235:         [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]],
  236:         index=["one", "two"],
  237:         columns=MultiIndex.from_tuples(
  238:             [("a", "q"), ("a", "r"), ("a", "s"), ("b", "t"), ("c", "u"), ("c", "v")]
  239:         ),
  240:     )
  241:     data = """,a,a,a,b,c,c
  242: ,q,r,s,t,u,v
  243: ,,,,,,
  244: one,1,2,3,4,5,6
  245: two,7,8,9,10,11,12"""
  246: 
  247:     result = parser.read_csv(StringIO(data), index_col=0, **kwargs)
  248:     tm.assert_frame_equal(result, expected)
  249: 
  250: 
  251: @xfail_pyarrow  # TypeError: an integer is required
  252: @pytest.mark.parametrize(
  253:     "kwargs",
  254:     [
  255:         {"header": [0, 1]},
  256:         {
  257:             "skiprows": 2,
  258:             "names": [
  259:                 ("a", "q"),
  260:                 ("a", "r"),
  261:                 ("a", "s"),
  262:                 ("b", "t"),
  263:                 ("c", "u"),
  264:                 ("c", "v"),
  265:             ],
  266:         },
  267:         {
  268:             "skiprows": 2,
  269:             "names": [
  270:                 _TestTuple("a", "q"),
  271:                 _TestTuple("a", "r"),
  272:                 _TestTuple("a", "s"),
  273:                 _TestTuple("b", "t"),
  274:                 _TestTuple("c", "u"),
  275:                 _TestTuple("c", "v"),
  276:             ],
  277:         },
  278:     ],
  279: )
  280: def test_header_multi_index_common_format2(all_parsers, kwargs):
  281:     parser = all_parsers
  282:     expected = DataFrame(
  283:         [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]],
  284:         index=["one", "two"],
  285:         columns=MultiIndex.from_tuples(
  286:             [("a", "q"), ("a", "r"), ("a", "s"), ("b", "t"), ("c", "u"), ("c", "v")]
  287:         ),
  288:     )
  289:     data = """,a,a,a,b,c,c
  290: ,q,r,s,t,u,v
  291: one,1,2,3,4,5,6
  292: two,7,8,9,10,11,12"""
  293: 
  294:     result = parser.read_csv(StringIO(data), index_col=0, **kwargs)
  295:     tm.assert_frame_equal(result, expected)
  296: 
  297: 
  298: @xfail_pyarrow  # TypeError: an integer is required
  299: @pytest.mark.parametrize(
  300:     "kwargs",
  301:     [
  302:         {"header": [0, 1]},
  303:         {
  304:             "skiprows": 2,
  305:             "names": [
  306:                 ("a", "q"),
  307:                 ("a", "r"),
  308:                 ("a", "s"),
  309:                 ("b", "t"),
  310:                 ("c", "u"),
  311:                 ("c", "v"),
  312:             ],
  313:         },
  314:         {
  315:             "skiprows": 2,
  316:             "names": [
  317:                 _TestTuple("a", "q"),
  318:                 _TestTuple("a", "r"),
  319:                 _TestTuple("a", "s"),
  320:                 _TestTuple("b", "t"),
  321:                 _TestTuple("c", "u"),
  322:                 _TestTuple("c", "v"),
  323:             ],
  324:         },
  325:     ],
  326: )
  327: def test_header_multi_index_common_format3(all_parsers, kwargs):
  328:     parser = all_parsers
  329:     expected = DataFrame(
  330:         [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]],
  331:         index=["one", "two"],
  332:         columns=MultiIndex.from_tuples(
  333:             [("a", "q"), ("a", "r"), ("a", "s"), ("b", "t"), ("c", "u"), ("c", "v")]
  334:         ),
  335:     )
  336:     expected = expected.reset_index(drop=True)
  337:     data = """a,a,a,b,c,c
  338: q,r,s,t,u,v
  339: 1,2,3,4,5,6
  340: 7,8,9,10,11,12"""
  341: 
  342:     result = parser.read_csv(StringIO(data), index_col=None, **kwargs)
  343:     tm.assert_frame_equal(result, expected)
  344: 
  345: 
  346: @xfail_pyarrow  # TypeError: an integer is required
  347: def test_header_multi_index_common_format_malformed1(all_parsers):
  348:     parser = all_parsers
  349:     expected = DataFrame(
  350:         np.array([[2, 3, 4, 5, 6], [8, 9, 10, 11, 12]], dtype="int64"),
  351:         index=Index([1, 7]),
  352:         columns=MultiIndex(
  353:             levels=[["a", "b", "c"], ["r", "s", "t", "u", "v"]],
  354:             codes=[[0, 0, 1, 2, 2], [0, 1, 2, 3, 4]],
  355:             names=["a", "q"],
  356:         ),
  357:     )
  358:     data = """a,a,a,b,c,c
  359: q,r,s,t,u,v
  360: 1,2,3,4,5,6
  361: 7,8,9,10,11,12"""
  362: 
  363:     result = parser.read_csv(StringIO(data), header=[0, 1], index_col=0)
  364:     tm.assert_frame_equal(expected, result)
  365: 
  366: 
  367: @xfail_pyarrow  # TypeError: an integer is required
  368: def test_header_multi_index_common_format_malformed2(all_parsers):
  369:     parser = all_parsers
  370:     expected = DataFrame(
  371:         np.array([[2, 3, 4, 5, 6], [8, 9, 10, 11, 12]], dtype="int64"),
  372:         index=Index([1, 7]),
  373:         columns=MultiIndex(
  374:             levels=[["a", "b", "c"], ["r", "s", "t", "u", "v"]],
  375:             codes=[[0, 0, 1, 2, 2], [0, 1, 2, 3, 4]],
  376:             names=[None, "q"],
  377:         ),
  378:     )
  379: 
  380:     data = """,a,a,b,c,c
  381: q,r,s,t,u,v
  382: 1,2,3,4,5,6
  383: 7,8,9,10,11,12"""
  384: 
  385:     result = parser.read_csv(StringIO(data), header=[0, 1], index_col=0)
  386:     tm.assert_frame_equal(expected, result)
  387: 
  388: 
  389: @xfail_pyarrow  # TypeError: an integer is required
  390: def test_header_multi_index_common_format_malformed3(all_parsers):
  391:     parser = all_parsers
  392:     expected = DataFrame(
  393:         np.array([[3, 4, 5, 6], [9, 10, 11, 12]], dtype="int64"),
  394:         index=MultiIndex(levels=[[1, 7], [2, 8]], codes=[[0, 1], [0, 1]]),
  395:         columns=MultiIndex(
  396:             levels=[["a", "b", "c"], ["s", "t", "u", "v"]],
  397:             codes=[[0, 1, 2, 2], [0, 1, 2, 3]],
  398:             names=[None, "q"],
  399:         ),
  400:     )
  401:     data = """,a,a,b,c,c
  402: q,r,s,t,u,v
  403: 1,2,3,4,5,6
  404: 7,8,9,10,11,12"""
  405: 
  406:     result = parser.read_csv(StringIO(data), header=[0, 1], index_col=[0, 1])
  407:     tm.assert_frame_equal(expected, result)
  408: 
  409: 
  410: @xfail_pyarrow  # TypeError: an integer is required
  411: def test_header_multi_index_blank_line(all_parsers):
  412:     # GH 40442
  413:     parser = all_parsers
  414:     data = [[None, None], [1, 2], [3, 4]]
  415:     columns = MultiIndex.from_tuples([("a", "A"), ("b", "B")])
  416:     expected = DataFrame(data, columns=columns)
  417:     data = "a,b\nA,B\n,\n1,2\n3,4"
  418:     result = parser.read_csv(StringIO(data), header=[0, 1])
  419:     tm.assert_frame_equal(expected, result)
  420: 
  421: 
  422: @pytest.mark.parametrize(
  423:     "data,header", [("1,2,3\n4,5,6", None), ("foo,bar,baz\n1,2,3\n4,5,6", 0)]
  424: )
  425: def test_header_names_backward_compat(all_parsers, data, header, request):
  426:     # see gh-2539
  427:     parser = all_parsers
  428: 
  429:     if parser.engine == "pyarrow" and header is not None:
  430:         mark = pytest.mark.xfail(reason="DataFrame.columns are different")
  431:         request.applymarker(mark)
  432: 
  433:     expected = parser.read_csv(StringIO("1,2,3\n4,5,6"), names=["a", "b", "c"])
  434: 
  435:     result = parser.read_csv(StringIO(data), names=["a", "b", "c"], header=header)
  436:     tm.assert_frame_equal(result, expected)
  437: 
  438: 
  439: @skip_pyarrow  # CSV parse error: Empty CSV file or block: cannot infer
  440: @pytest.mark.parametrize("kwargs", [{}, {"index_col": False}])
  441: def test_read_only_header_no_rows(all_parsers, kwargs):
  442:     # See gh-7773
  443:     parser = all_parsers
  444:     expected = DataFrame(columns=["a", "b", "c"])
  445: 
  446:     result = parser.read_csv(StringIO("a,b,c"), **kwargs)
  447:     tm.assert_frame_equal(result, expected)
  448: 
  449: 
  450: @pytest.mark.parametrize(
  451:     "kwargs,names",
  452:     [
  453:         ({}, [0, 1, 2, 3, 4]),
  454:         (
  455:             {"names": ["foo", "bar", "baz", "quux", "panda"]},
  456:             ["foo", "bar", "baz", "quux", "panda"],
  457:         ),
  458:     ],
  459: )
  460: def test_no_header(all_parsers, kwargs, names):
  461:     parser = all_parsers
  462:     data = """1,2,3,4,5
  463: 6,7,8,9,10
  464: 11,12,13,14,15
  465: """
  466:     expected = DataFrame(
  467:         [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]], columns=names
  468:     )
  469:     result = parser.read_csv(StringIO(data), header=None, **kwargs)
  470:     tm.assert_frame_equal(result, expected)
  471: 
  472: 
  473: @pytest.mark.parametrize("header", [["a", "b"], "string_header"])
  474: def test_non_int_header(all_parsers, header):
  475:     # see gh-16338
  476:     msg = "header must be integer or list of integers"
  477:     data = """1,2\n3,4"""
  478:     parser = all_parsers
  479: 
  480:     with pytest.raises(ValueError, match=msg):
  481:         parser.read_csv(StringIO(data), header=header)
  482: 
  483: 
  484: @xfail_pyarrow  # TypeError: an integer is required
  485: def test_singleton_header(all_parsers):
  486:     # see gh-7757
  487:     data = """a,b,c\n0,1,2\n1,2,3"""
  488:     parser = all_parsers
  489: 
  490:     expected = DataFrame({"a": [0, 1], "b": [1, 2], "c": [2, 3]})
  491:     result = parser.read_csv(StringIO(data), header=[0])
  492:     tm.assert_frame_equal(result, expected)
  493: 
  494: 
  495: @xfail_pyarrow  # TypeError: an integer is required
  496: @pytest.mark.parametrize(
  497:     "data,expected",
  498:     [
  499:         (
  500:             "A,A,A,B\none,one,one,two\n0,40,34,0.1",
  501:             DataFrame(
  502:                 [[0, 40, 34, 0.1]],
  503:                 columns=MultiIndex.from_tuples(
  504:                     [("A", "one"), ("A", "one.1"), ("A", "one.2"), ("B", "two")]
  505:                 ),
  506:             ),
  507:         ),
  508:         (
  509:             "A,A,A,B\none,one,one.1,two\n0,40,34,0.1",
  510:             DataFrame(
  511:                 [[0, 40, 34, 0.1]],
  512:                 columns=MultiIndex.from_tuples(
  513:                     [("A", "one"), ("A", "one.1"), ("A", "one.1.1"), ("B", "two")]
  514:                 ),
  515:             ),
  516:         ),
  517:         (
  518:             "A,A,A,B,B\none,one,one.1,two,two\n0,40,34,0.1,0.1",
  519:             DataFrame(
  520:                 [[0, 40, 34, 0.1, 0.1]],
  521:                 columns=MultiIndex.from_tuples(
  522:                     [
  523:                         ("A", "one"),
  524:                         ("A", "one.1"),
  525:                         ("A", "one.1.1"),
  526:                         ("B", "two"),
  527:                         ("B", "two.1"),
  528:                     ]
  529:                 ),
  530:             ),
  531:         ),
  532:     ],
  533: )
  534: def test_mangles_multi_index(all_parsers, data, expected):
  535:     # see gh-18062
  536:     parser = all_parsers
  537: 
  538:     result = parser.read_csv(StringIO(data), header=[0, 1])
  539:     tm.assert_frame_equal(result, expected)
  540: 
  541: 
  542: @xfail_pyarrow  # TypeError: an integer is requireds
  543: @pytest.mark.parametrize("index_col", [None, [0]])
  544: @pytest.mark.parametrize(
  545:     "columns", [None, (["", "Unnamed"]), (["Unnamed", ""]), (["Unnamed", "NotUnnamed"])]
  546: )
  547: def test_multi_index_unnamed(all_parsers, index_col, columns):
  548:     # see gh-23687
  549:     #
  550:     # When specifying a multi-index header, make sure that
  551:     # we don't error just because one of the rows in our header
  552:     # has ALL column names containing the string "Unnamed". The
  553:     # correct condition to check is whether the row contains
  554:     # ALL columns that did not have names (and instead were given
  555:     # placeholder ones).
  556:     parser = all_parsers
  557:     header = [0, 1]
  558: 
  559:     if index_col is None:
  560:         data = ",".join(columns or ["", ""]) + "\n0,1\n2,3\n4,5\n"
  561:     else:
  562:         data = ",".join([""] + (columns or ["", ""])) + "\n,0,1\n0,2,3\n1,4,5\n"
  563: 
  564:     result = parser.read_csv(StringIO(data), header=header, index_col=index_col)
  565:     exp_columns = []
  566: 
  567:     if columns is None:
  568:         columns = ["", "", ""]
  569: 
  570:     for i, col in enumerate(columns):
  571:         if not col:  # Unnamed.
  572:             col = f"Unnamed: {i if index_col is None else i + 1}_level_0"
  573: 
  574:         exp_columns.append(col)
  575: 
  576:     columns = MultiIndex.from_tuples(zip(exp_columns, ["0", "1"]))
  577:     expected = DataFrame([[2, 3], [4, 5]], columns=columns)
  578:     tm.assert_frame_equal(result, expected)
  579: 
  580: 
  581: @skip_pyarrow  # CSV parse error: Expected 2 columns, got 3
  582: def test_names_longer_than_header_but_equal_with_data_rows(all_parsers):
  583:     # GH#38453
  584:     parser = all_parsers
  585:     data = """a, b
  586: 1,2,3
  587: 5,6,4
  588: """
  589:     result = parser.read_csv(StringIO(data), header=0, names=["A", "B", "C"])
  590:     expected = DataFrame({"A": [1, 5], "B": [2, 6], "C": [3, 4]})
  591:     tm.assert_frame_equal(result, expected)
  592: 
  593: 
  594: @xfail_pyarrow  # TypeError: an integer is required
  595: def test_read_csv_multiindex_columns(all_parsers):
  596:     # GH#6051
  597:     parser = all_parsers
  598: 
  599:     s1 = "Male, Male, Male, Female, Female\nR, R, L, R, R\n.86, .67, .88, .78, .81"
  600:     s2 = (
  601:         "Male, Male, Male, Female, Female\n"
  602:         "R, R, L, R, R\n"
  603:         ".86, .67, .88, .78, .81\n"
  604:         ".86, .67, .88, .78, .82"
  605:     )
  606: 
  607:     mi = MultiIndex.from_tuples(
  608:         [
  609:             ("Male", "R"),
  610:             (" Male", " R"),
  611:             (" Male", " L"),
  612:             (" Female", " R"),
  613:             (" Female", " R.1"),
  614:         ]
  615:     )
  616:     expected = DataFrame(
  617:         [[0.86, 0.67, 0.88, 0.78, 0.81], [0.86, 0.67, 0.88, 0.78, 0.82]], columns=mi
  618:     )
  619: 
  620:     df1 = parser.read_csv(StringIO(s1), header=[0, 1])
  621:     tm.assert_frame_equal(df1, expected.iloc[:1])
  622:     df2 = parser.read_csv(StringIO(s2), header=[0, 1])
  623:     tm.assert_frame_equal(df2, expected)
  624: 
  625: 
  626: @xfail_pyarrow  # TypeError: an integer is required
  627: def test_read_csv_multi_header_length_check(all_parsers):
  628:     # GH#43102
  629:     parser = all_parsers
  630: 
  631:     case = """row11,row12,row13
  632: row21,row22, row23
  633: row31,row32
  634: """
  635: 
  636:     with pytest.raises(
  637:         ParserError, match="Header rows must have an equal number of columns."
  638:     ):
  639:         parser.read_csv(StringIO(case), header=[0, 2])
  640: 
  641: 
  642: @skip_pyarrow  # CSV parse error: Expected 3 columns, got 2
  643: def test_header_none_and_implicit_index(all_parsers):
  644:     # GH#22144
  645:     parser = all_parsers
  646:     data = "x,1,5\ny,2\nz,3\n"
  647:     result = parser.read_csv(StringIO(data), names=["a", "b"], header=None)
  648:     expected = DataFrame(
  649:         {"a": [1, 2, 3], "b": [5, np.nan, np.nan]}, index=["x", "y", "z"]
  650:     )
  651:     tm.assert_frame_equal(result, expected)
  652: 
  653: 
  654: @skip_pyarrow  # regex mismatch "CSV parse error: Expected 2 columns, got "
  655: def test_header_none_and_implicit_index_in_second_row(all_parsers):
  656:     # GH#22144
  657:     parser = all_parsers
  658:     data = "x,1\ny,2,5\nz,3\n"
  659:     with pytest.raises(ParserError, match="Expected 2 fields in line 2, saw 3"):
  660:         parser.read_csv(StringIO(data), names=["a", "b"], header=None)
  661: 
  662: 
  663: def test_header_none_and_on_bad_lines_skip(all_parsers):
  664:     # GH#22144
  665:     parser = all_parsers
  666:     data = "x,1\ny,2,5\nz,3\n"
  667:     result = parser.read_csv(
  668:         StringIO(data), names=["a", "b"], header=None, on_bad_lines="skip"
  669:     )
  670:     expected = DataFrame({"a": ["x", "z"], "b": [1, 3]})
  671:     tm.assert_frame_equal(result, expected)
  672: 
  673: 
  674: @xfail_pyarrow  # TypeError: an integer is requireds
  675: def test_header_missing_rows(all_parsers):
  676:     # GH#47400
  677:     parser = all_parsers
  678:     data = """a,b
  679: 1,2
  680: """
  681:     msg = r"Passed header=\[0,1,2\], len of 3, but only 2 lines in file"
  682:     with pytest.raises(ValueError, match=msg):
  683:         parser.read_csv(StringIO(data), header=[0, 1, 2])
  684: 
  685: 
  686: # ValueError: The 'delim_whitespace' option is not supported with the 'pyarrow' engine
  687: @xfail_pyarrow
  688: def test_header_multiple_whitespaces(all_parsers):
  689:     # GH#54931
  690:     parser = all_parsers
  691:     data = """aa    bb(1,1)   cc(1,1)
  692:                 0  2  3.5"""
  693: 
  694:     result = parser.read_csv(StringIO(data), sep=r"\s+")
  695:     expected = DataFrame({"aa": [0], "bb(1,1)": 2, "cc(1,1)": 3.5})
  696:     tm.assert_frame_equal(result, expected)
  697: 
  698: 
  699: # ValueError: The 'delim_whitespace' option is not supported with the 'pyarrow' engine
  700: @xfail_pyarrow
  701: def test_header_delim_whitespace(all_parsers):
  702:     # GH#54918
  703:     parser = all_parsers
  704:     data = """a,b
  705: 1,2
  706: 3,4
  707:     """
  708: 
  709:     depr_msg = "The 'delim_whitespace' keyword in pd.read_csv is deprecated"
  710:     with tm.assert_produces_warning(
  711:         FutureWarning, match=depr_msg, check_stacklevel=False
  712:     ):
  713:         result = parser.read_csv(StringIO(data), delim_whitespace=True)
  714:     expected = DataFrame({"a,b": ["1,2", "3,4"]})
  715:     tm.assert_frame_equal(result, expected)
  716: 
  717: 
  718: def test_usecols_no_header_pyarrow(pyarrow_parser_only):
  719:     parser = pyarrow_parser_only
  720:     data = """
  721: a,i,x
  722: b,j,y
  723: """
  724:     result = parser.read_csv(
  725:         StringIO(data),
  726:         header=None,
  727:         usecols=[0, 1],
  728:         dtype="string[pyarrow]",
  729:         dtype_backend="pyarrow",
  730:         engine="pyarrow",
  731:     )
  732:     expected = DataFrame([["a", "i"], ["b", "j"]], dtype="string[pyarrow]")
  733:     tm.assert_frame_equal(result, expected)
