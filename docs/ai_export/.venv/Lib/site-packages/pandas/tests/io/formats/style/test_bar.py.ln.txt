    1: import io
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas import (
    7:     NA,
    8:     DataFrame,
    9:     read_csv,
   10: )
   11: 
   12: pytest.importorskip("jinja2")
   13: 
   14: 
   15: def bar_grad(a=None, b=None, c=None, d=None):
   16:     """Used in multiple tests to simplify formatting of expected result"""
   17:     ret = [("width", "10em")]
   18:     if all(x is None for x in [a, b, c, d]):
   19:         return ret
   20:     return ret + [
   21:         (
   22:             "background",
   23:             f"linear-gradient(90deg,{','.join([x for x in [a, b, c, d] if x])})",
   24:         )
   25:     ]
   26: 
   27: 
   28: def no_bar():
   29:     return bar_grad()
   30: 
   31: 
   32: def bar_to(x, color="#d65f5f"):
   33:     return bar_grad(f" {color} {x:.1f}%", f" transparent {x:.1f}%")
   34: 
   35: 
   36: def bar_from_to(x, y, color="#d65f5f"):
   37:     return bar_grad(
   38:         f" transparent {x:.1f}%",
   39:         f" {color} {x:.1f}%",
   40:         f" {color} {y:.1f}%",
   41:         f" transparent {y:.1f}%",
   42:     )
   43: 
   44: 
   45: @pytest.fixture
   46: def df_pos():
   47:     return DataFrame([[1], [2], [3]])
   48: 
   49: 
   50: @pytest.fixture
   51: def df_neg():
   52:     return DataFrame([[-1], [-2], [-3]])
   53: 
   54: 
   55: @pytest.fixture
   56: def df_mix():
   57:     return DataFrame([[-3], [1], [2]])
   58: 
   59: 
   60: @pytest.mark.parametrize(
   61:     "align, exp",
   62:     [
   63:         ("left", [no_bar(), bar_to(50), bar_to(100)]),
   64:         ("right", [bar_to(100), bar_from_to(50, 100), no_bar()]),
   65:         ("mid", [bar_to(33.33), bar_to(66.66), bar_to(100)]),
   66:         ("zero", [bar_from_to(50, 66.7), bar_from_to(50, 83.3), bar_from_to(50, 100)]),
   67:         ("mean", [bar_to(50), no_bar(), bar_from_to(50, 100)]),
   68:         (2.0, [bar_to(50), no_bar(), bar_from_to(50, 100)]),
   69:         (np.median, [bar_to(50), no_bar(), bar_from_to(50, 100)]),
   70:     ],
   71: )
   72: def test_align_positive_cases(df_pos, align, exp):
   73:     # test different align cases for all positive values
   74:     result = df_pos.style.bar(align=align)._compute().ctx
   75:     expected = {(0, 0): exp[0], (1, 0): exp[1], (2, 0): exp[2]}
   76:     assert result == expected
   77: 
   78: 
   79: @pytest.mark.parametrize(
   80:     "align, exp",
   81:     [
   82:         ("left", [bar_to(100), bar_to(50), no_bar()]),
   83:         ("right", [no_bar(), bar_from_to(50, 100), bar_to(100)]),
   84:         ("mid", [bar_from_to(66.66, 100), bar_from_to(33.33, 100), bar_to(100)]),
   85:         ("zero", [bar_from_to(33.33, 50), bar_from_to(16.66, 50), bar_to(50)]),
   86:         ("mean", [bar_from_to(50, 100), no_bar(), bar_to(50)]),
   87:         (-2.0, [bar_from_to(50, 100), no_bar(), bar_to(50)]),
   88:         (np.median, [bar_from_to(50, 100), no_bar(), bar_to(50)]),
   89:     ],
   90: )
   91: def test_align_negative_cases(df_neg, align, exp):
   92:     # test different align cases for all negative values
   93:     result = df_neg.style.bar(align=align)._compute().ctx
   94:     expected = {(0, 0): exp[0], (1, 0): exp[1], (2, 0): exp[2]}
   95:     assert result == expected
   96: 
   97: 
   98: @pytest.mark.parametrize(
   99:     "align, exp",
  100:     [
  101:         ("left", [no_bar(), bar_to(80), bar_to(100)]),
  102:         ("right", [bar_to(100), bar_from_to(80, 100), no_bar()]),
  103:         ("mid", [bar_to(60), bar_from_to(60, 80), bar_from_to(60, 100)]),
  104:         ("zero", [bar_to(50), bar_from_to(50, 66.66), bar_from_to(50, 83.33)]),
  105:         ("mean", [bar_to(50), bar_from_to(50, 66.66), bar_from_to(50, 83.33)]),
  106:         (-0.0, [bar_to(50), bar_from_to(50, 66.66), bar_from_to(50, 83.33)]),
  107:         (np.nanmedian, [bar_to(50), no_bar(), bar_from_to(50, 62.5)]),
  108:     ],
  109: )
  110: @pytest.mark.parametrize("nans", [True, False])
  111: def test_align_mixed_cases(df_mix, align, exp, nans):
  112:     # test different align cases for mixed positive and negative values
  113:     # also test no impact of NaNs and no_bar
  114:     expected = {(0, 0): exp[0], (1, 0): exp[1], (2, 0): exp[2]}
  115:     if nans:
  116:         df_mix.loc[3, :] = np.nan
  117:         expected.update({(3, 0): no_bar()})
  118:     result = df_mix.style.bar(align=align)._compute().ctx
  119:     assert result == expected
  120: 
  121: 
  122: @pytest.mark.parametrize(
  123:     "align, exp",
  124:     [
  125:         (
  126:             "left",
  127:             {
  128:                 "index": [[no_bar(), no_bar()], [bar_to(100), bar_to(100)]],
  129:                 "columns": [[no_bar(), bar_to(100)], [no_bar(), bar_to(100)]],
  130:                 "none": [[no_bar(), bar_to(33.33)], [bar_to(66.66), bar_to(100)]],
  131:             },
  132:         ),
  133:         (
  134:             "mid",
  135:             {
  136:                 "index": [[bar_to(33.33), bar_to(50)], [bar_to(100), bar_to(100)]],
  137:                 "columns": [[bar_to(50), bar_to(100)], [bar_to(75), bar_to(100)]],
  138:                 "none": [[bar_to(25), bar_to(50)], [bar_to(75), bar_to(100)]],
  139:             },
  140:         ),
  141:         (
  142:             "zero",
  143:             {
  144:                 "index": [
  145:                     [bar_from_to(50, 66.66), bar_from_to(50, 75)],
  146:                     [bar_from_to(50, 100), bar_from_to(50, 100)],
  147:                 ],
  148:                 "columns": [
  149:                     [bar_from_to(50, 75), bar_from_to(50, 100)],
  150:                     [bar_from_to(50, 87.5), bar_from_to(50, 100)],
  151:                 ],
  152:                 "none": [
  153:                     [bar_from_to(50, 62.5), bar_from_to(50, 75)],
  154:                     [bar_from_to(50, 87.5), bar_from_to(50, 100)],
  155:                 ],
  156:             },
  157:         ),
  158:         (
  159:             2,
  160:             {
  161:                 "index": [
  162:                     [bar_to(50), no_bar()],
  163:                     [bar_from_to(50, 100), bar_from_to(50, 100)],
  164:                 ],
  165:                 "columns": [
  166:                     [bar_to(50), no_bar()],
  167:                     [bar_from_to(50, 75), bar_from_to(50, 100)],
  168:                 ],
  169:                 "none": [
  170:                     [bar_from_to(25, 50), no_bar()],
  171:                     [bar_from_to(50, 75), bar_from_to(50, 100)],
  172:                 ],
  173:             },
  174:         ),
  175:     ],
  176: )
  177: @pytest.mark.parametrize("axis", ["index", "columns", "none"])
  178: def test_align_axis(align, exp, axis):
  179:     # test all axis combinations with positive values and different aligns
  180:     data = DataFrame([[1, 2], [3, 4]])
  181:     result = (
  182:         data.style.bar(align=align, axis=None if axis == "none" else axis)
  183:         ._compute()
  184:         .ctx
  185:     )
  186:     expected = {
  187:         (0, 0): exp[axis][0][0],
  188:         (0, 1): exp[axis][0][1],
  189:         (1, 0): exp[axis][1][0],
  190:         (1, 1): exp[axis][1][1],
  191:     }
  192:     assert result == expected
  193: 
  194: 
  195: @pytest.mark.parametrize(
  196:     "values, vmin, vmax",
  197:     [
  198:         ("positive", 1.5, 2.5),
  199:         ("negative", -2.5, -1.5),
  200:         ("mixed", -2.5, 1.5),
  201:     ],
  202: )
  203: @pytest.mark.parametrize("nullify", [None, "vmin", "vmax"])  # test min/max separately
  204: @pytest.mark.parametrize("align", ["left", "right", "zero", "mid"])
  205: def test_vmin_vmax_clipping(df_pos, df_neg, df_mix, values, vmin, vmax, nullify, align):
  206:     # test that clipping occurs if any vmin > data_values or vmax < data_values
  207:     if align == "mid":  # mid acts as left or right in each case
  208:         if values == "positive":
  209:             align = "left"
  210:         elif values == "negative":
  211:             align = "right"
  212:     df = {"positive": df_pos, "negative": df_neg, "mixed": df_mix}[values]
  213:     vmin = None if nullify == "vmin" else vmin
  214:     vmax = None if nullify == "vmax" else vmax
  215: 
  216:     clip_df = df.where(df <= (vmax if vmax else 999), other=vmax)
  217:     clip_df = clip_df.where(clip_df >= (vmin if vmin else -999), other=vmin)
  218: 
  219:     result = (
  220:         df.style.bar(align=align, vmin=vmin, vmax=vmax, color=["red", "green"])
  221:         ._compute()
  222:         .ctx
  223:     )
  224:     expected = clip_df.style.bar(align=align, color=["red", "green"])._compute().ctx
  225:     assert result == expected
  226: 
  227: 
  228: @pytest.mark.parametrize(
  229:     "values, vmin, vmax",
  230:     [
  231:         ("positive", 0.5, 4.5),
  232:         ("negative", -4.5, -0.5),
  233:         ("mixed", -4.5, 4.5),
  234:     ],
  235: )
  236: @pytest.mark.parametrize("nullify", [None, "vmin", "vmax"])  # test min/max separately
  237: @pytest.mark.parametrize("align", ["left", "right", "zero", "mid"])
  238: def test_vmin_vmax_widening(df_pos, df_neg, df_mix, values, vmin, vmax, nullify, align):
  239:     # test that widening occurs if any vmax > data_values or vmin < data_values
  240:     if align == "mid":  # mid acts as left or right in each case
  241:         if values == "positive":
  242:             align = "left"
  243:         elif values == "negative":
  244:             align = "right"
  245:     df = {"positive": df_pos, "negative": df_neg, "mixed": df_mix}[values]
  246:     vmin = None if nullify == "vmin" else vmin
  247:     vmax = None if nullify == "vmax" else vmax
  248: 
  249:     expand_df = df.copy()
  250:     expand_df.loc[3, :], expand_df.loc[4, :] = vmin, vmax
  251: 
  252:     result = (
  253:         df.style.bar(align=align, vmin=vmin, vmax=vmax, color=["red", "green"])
  254:         ._compute()
  255:         .ctx
  256:     )
  257:     expected = expand_df.style.bar(align=align, color=["red", "green"])._compute().ctx
  258:     assert result.items() <= expected.items()
  259: 
  260: 
  261: def test_numerics():
  262:     # test data is pre-selected for numeric values
  263:     data = DataFrame([[1, "a"], [2, "b"]])
  264:     result = data.style.bar()._compute().ctx
  265:     assert (0, 1) not in result
  266:     assert (1, 1) not in result
  267: 
  268: 
  269: @pytest.mark.parametrize(
  270:     "align, exp",
  271:     [
  272:         ("left", [no_bar(), bar_to(100, "green")]),
  273:         ("right", [bar_to(100, "red"), no_bar()]),
  274:         ("mid", [bar_to(25, "red"), bar_from_to(25, 100, "green")]),
  275:         ("zero", [bar_from_to(33.33, 50, "red"), bar_from_to(50, 100, "green")]),
  276:     ],
  277: )
  278: def test_colors_mixed(align, exp):
  279:     data = DataFrame([[-1], [3]])
  280:     result = data.style.bar(align=align, color=["red", "green"])._compute().ctx
  281:     assert result == {(0, 0): exp[0], (1, 0): exp[1]}
  282: 
  283: 
  284: def test_bar_align_height():
  285:     # test when keyword height is used 'no-repeat center' and 'background-size' present
  286:     data = DataFrame([[1], [2]])
  287:     result = data.style.bar(align="left", height=50)._compute().ctx
  288:     bg_s = "linear-gradient(90deg, #d65f5f 100.0%, transparent 100.0%) no-repeat center"
  289:     expected = {
  290:         (0, 0): [("width", "10em")],
  291:         (1, 0): [
  292:             ("width", "10em"),
  293:             ("background", bg_s),
  294:             ("background-size", "100% 50.0%"),
  295:         ],
  296:     }
  297:     assert result == expected
  298: 
  299: 
  300: def test_bar_value_error_raises():
  301:     df = DataFrame({"A": [-100, -60, -30, -20]})
  302: 
  303:     msg = "`align` should be in {'left', 'right', 'mid', 'mean', 'zero'} or"
  304:     with pytest.raises(ValueError, match=msg):
  305:         df.style.bar(align="poorly", color=["#d65f5f", "#5fba7d"]).to_html()
  306: 
  307:     msg = r"`width` must be a value in \[0, 100\]"
  308:     with pytest.raises(ValueError, match=msg):
  309:         df.style.bar(width=200).to_html()
  310: 
  311:     msg = r"`height` must be a value in \[0, 100\]"
  312:     with pytest.raises(ValueError, match=msg):
  313:         df.style.bar(height=200).to_html()
  314: 
  315: 
  316: def test_bar_color_and_cmap_error_raises():
  317:     df = DataFrame({"A": [1, 2, 3, 4]})
  318:     msg = "`color` and `cmap` cannot both be given"
  319:     # Test that providing both color and cmap raises a ValueError
  320:     with pytest.raises(ValueError, match=msg):
  321:         df.style.bar(color="#d65f5f", cmap="viridis").to_html()
  322: 
  323: 
  324: def test_bar_invalid_color_type_error_raises():
  325:     df = DataFrame({"A": [1, 2, 3, 4]})
  326:     msg = (
  327:         r"`color` must be string or list or tuple of 2 strings,"
  328:         r"\(eg: color=\['#d65f5f', '#5fba7d'\]\)"
  329:     )
  330:     # Test that providing an invalid color type raises a ValueError
  331:     with pytest.raises(ValueError, match=msg):
  332:         df.style.bar(color=123).to_html()
  333: 
  334:     # Test that providing a color list with more than two elements raises a ValueError
  335:     with pytest.raises(ValueError, match=msg):
  336:         df.style.bar(color=["#d65f5f", "#5fba7d", "#abcdef"]).to_html()
  337: 
  338: 
  339: def test_styler_bar_with_NA_values():
  340:     df1 = DataFrame({"A": [1, 2, NA, 4]})
  341:     df2 = DataFrame([[NA, NA], [NA, NA]])
  342:     expected_substring = "style type="
  343:     html_output1 = df1.style.bar(subset="A").to_html()
  344:     html_output2 = df2.style.bar(align="left", axis=None).to_html()
  345:     assert expected_substring in html_output1
  346:     assert expected_substring in html_output2
  347: 
  348: 
  349: def test_style_bar_with_pyarrow_NA_values():
  350:     data = """name,age,test1,test2,teacher
  351:         Adam,15,95.0,80,Ashby
  352:         Bob,16,81.0,82,Ashby
  353:         Dave,16,89.0,84,Jones
  354:         Fred,15,,88,Jones"""
  355:     df = read_csv(io.StringIO(data), dtype_backend="pyarrow")
  356:     expected_substring = "style type="
  357:     html_output = df.style.bar(subset="test1").to_html()
  358:     assert expected_substring in html_output
