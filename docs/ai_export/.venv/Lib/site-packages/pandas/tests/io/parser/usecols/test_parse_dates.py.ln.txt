    1: """
    2: Tests the usecols functionality during parsing
    3: for all of the parsers defined in parsers.py
    4: """
    5: from io import StringIO
    6: 
    7: import pytest
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     Index,
   12:     Timestamp,
   13: )
   14: import pandas._testing as tm
   15: 
   16: pytestmark = pytest.mark.filterwarnings(
   17:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   18: )
   19: xfail_pyarrow = pytest.mark.usefixtures("pyarrow_xfail")
   20: skip_pyarrow = pytest.mark.usefixtures("pyarrow_skip")
   21: 
   22: _msg_pyarrow_requires_names = (
   23:     "The pyarrow engine does not allow 'usecols' to be integer column "
   24:     "positions. Pass a list of string column names instead."
   25: )
   26: 
   27: 
   28: @pytest.mark.parametrize("usecols", [[0, 2, 3], [3, 0, 2]])
   29: def test_usecols_with_parse_dates(all_parsers, usecols):
   30:     # see gh-9755
   31:     data = """a,b,c,d,e
   32: 0,1,2014-01-01,09:00,4
   33: 0,1,2014-01-02,10:00,4"""
   34:     parser = all_parsers
   35:     parse_dates = [[1, 2]]
   36: 
   37:     depr_msg = (
   38:         "Support for nested sequences for 'parse_dates' in pd.read_csv is deprecated"
   39:     )
   40: 
   41:     cols = {
   42:         "a": [0, 0],
   43:         "c_d": [Timestamp("2014-01-01 09:00:00"), Timestamp("2014-01-02 10:00:00")],
   44:     }
   45:     expected = DataFrame(cols, columns=["c_d", "a"])
   46:     if parser.engine == "pyarrow":
   47:         with pytest.raises(ValueError, match=_msg_pyarrow_requires_names):
   48:             with tm.assert_produces_warning(
   49:                 FutureWarning, match=depr_msg, check_stacklevel=False
   50:             ):
   51:                 parser.read_csv(
   52:                     StringIO(data), usecols=usecols, parse_dates=parse_dates
   53:                 )
   54:         return
   55:     with tm.assert_produces_warning(
   56:         FutureWarning, match=depr_msg, check_stacklevel=False
   57:     ):
   58:         result = parser.read_csv(
   59:             StringIO(data), usecols=usecols, parse_dates=parse_dates
   60:         )
   61:     tm.assert_frame_equal(result, expected)
   62: 
   63: 
   64: @skip_pyarrow  # pyarrow.lib.ArrowKeyError: Column 'fdate' in include_columns
   65: def test_usecols_with_parse_dates2(all_parsers):
   66:     # see gh-13604
   67:     parser = all_parsers
   68:     data = """2008-02-07 09:40,1032.43
   69: 2008-02-07 09:50,1042.54
   70: 2008-02-07 10:00,1051.65"""
   71: 
   72:     names = ["date", "values"]
   73:     usecols = names[:]
   74:     parse_dates = [0]
   75: 
   76:     index = Index(
   77:         [
   78:             Timestamp("2008-02-07 09:40"),
   79:             Timestamp("2008-02-07 09:50"),
   80:             Timestamp("2008-02-07 10:00"),
   81:         ],
   82:         name="date",
   83:     )
   84:     cols = {"values": [1032.43, 1042.54, 1051.65]}
   85:     expected = DataFrame(cols, index=index)
   86: 
   87:     result = parser.read_csv(
   88:         StringIO(data),
   89:         parse_dates=parse_dates,
   90:         index_col=0,
   91:         usecols=usecols,
   92:         header=None,
   93:         names=names,
   94:     )
   95:     tm.assert_frame_equal(result, expected)
   96: 
   97: 
   98: def test_usecols_with_parse_dates3(all_parsers):
   99:     # see gh-14792
  100:     parser = all_parsers
  101:     data = """a,b,c,d,e,f,g,h,i,j
  102: 2016/09/21,1,1,2,3,4,5,6,7,8"""
  103: 
  104:     usecols = list("abcdefghij")
  105:     parse_dates = [0]
  106: 
  107:     cols = {
  108:         "a": Timestamp("2016-09-21").as_unit("ns"),
  109:         "b": [1],
  110:         "c": [1],
  111:         "d": [2],
  112:         "e": [3],
  113:         "f": [4],
  114:         "g": [5],
  115:         "h": [6],
  116:         "i": [7],
  117:         "j": [8],
  118:     }
  119:     expected = DataFrame(cols, columns=usecols)
  120: 
  121:     result = parser.read_csv(StringIO(data), usecols=usecols, parse_dates=parse_dates)
  122:     tm.assert_frame_equal(result, expected)
  123: 
  124: 
  125: def test_usecols_with_parse_dates4(all_parsers):
  126:     data = "a,b,c,d,e,f,g,h,i,j\n2016/09/21,1,1,2,3,4,5,6,7,8"
  127:     usecols = list("abcdefghij")
  128:     parse_dates = [[0, 1]]
  129:     parser = all_parsers
  130: 
  131:     cols = {
  132:         "a_b": "2016/09/21 1",
  133:         "c": [1],
  134:         "d": [2],
  135:         "e": [3],
  136:         "f": [4],
  137:         "g": [5],
  138:         "h": [6],
  139:         "i": [7],
  140:         "j": [8],
  141:     }
  142:     expected = DataFrame(cols, columns=["a_b"] + list("cdefghij"))
  143: 
  144:     depr_msg = (
  145:         "Support for nested sequences for 'parse_dates' in pd.read_csv is deprecated"
  146:     )
  147:     with tm.assert_produces_warning(
  148:         (FutureWarning, DeprecationWarning), match=depr_msg, check_stacklevel=False
  149:     ):
  150:         result = parser.read_csv(
  151:             StringIO(data),
  152:             usecols=usecols,
  153:             parse_dates=parse_dates,
  154:         )
  155:     tm.assert_frame_equal(result, expected)
  156: 
  157: 
  158: @pytest.mark.parametrize("usecols", [[0, 2, 3], [3, 0, 2]])
  159: @pytest.mark.parametrize(
  160:     "names",
  161:     [
  162:         list("abcde"),  # Names span all columns in original data.
  163:         list("acd"),  # Names span only the selected columns.
  164:     ],
  165: )
  166: def test_usecols_with_parse_dates_and_names(all_parsers, usecols, names, request):
  167:     # see gh-9755
  168:     s = """0,1,2014-01-01,09:00,4
  169: 0,1,2014-01-02,10:00,4"""
  170:     parse_dates = [[1, 2]]
  171:     parser = all_parsers
  172: 
  173:     if parser.engine == "pyarrow" and not (len(names) == 3 and usecols[0] == 0):
  174:         mark = pytest.mark.xfail(
  175:             reason="Length mismatch in some cases, UserWarning in other"
  176:         )
  177:         request.applymarker(mark)
  178: 
  179:     cols = {
  180:         "a": [0, 0],
  181:         "c_d": [Timestamp("2014-01-01 09:00:00"), Timestamp("2014-01-02 10:00:00")],
  182:     }
  183:     expected = DataFrame(cols, columns=["c_d", "a"])
  184: 
  185:     depr_msg = (
  186:         "Support for nested sequences for 'parse_dates' in pd.read_csv is deprecated"
  187:     )
  188:     with tm.assert_produces_warning(
  189:         (FutureWarning, DeprecationWarning), match=depr_msg, check_stacklevel=False
  190:     ):
  191:         result = parser.read_csv(
  192:             StringIO(s), names=names, parse_dates=parse_dates, usecols=usecols
  193:         )
  194:     tm.assert_frame_equal(result, expected)
