    1: from __future__ import annotations
    2: 
    3: import os
    4: 
    5: import pytest
    6: 
    7: from pandas.compat._optional import VERSIONS
    8: 
    9: from pandas import (
   10:     read_csv,
   11:     read_table,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: class BaseParser:
   17:     engine: str | None = None
   18:     low_memory = True
   19:     float_precision_choices: list[str | None] = []
   20: 
   21:     def update_kwargs(self, kwargs):
   22:         kwargs = kwargs.copy()
   23:         kwargs.update({"engine": self.engine, "low_memory": self.low_memory})
   24: 
   25:         return kwargs
   26: 
   27:     def read_csv(self, *args, **kwargs):
   28:         kwargs = self.update_kwargs(kwargs)
   29:         return read_csv(*args, **kwargs)
   30: 
   31:     def read_csv_check_warnings(
   32:         self,
   33:         warn_type: type[Warning],
   34:         warn_msg: str,
   35:         *args,
   36:         raise_on_extra_warnings=True,
   37:         check_stacklevel: bool = True,
   38:         **kwargs,
   39:     ):
   40:         # We need to check the stacklevel here instead of in the tests
   41:         # since this is where read_csv is called and where the warning
   42:         # should point to.
   43:         kwargs = self.update_kwargs(kwargs)
   44:         with tm.assert_produces_warning(
   45:             warn_type,
   46:             match=warn_msg,
   47:             raise_on_extra_warnings=raise_on_extra_warnings,
   48:             check_stacklevel=check_stacklevel,
   49:         ):
   50:             return read_csv(*args, **kwargs)
   51: 
   52:     def read_table(self, *args, **kwargs):
   53:         kwargs = self.update_kwargs(kwargs)
   54:         return read_table(*args, **kwargs)
   55: 
   56:     def read_table_check_warnings(
   57:         self,
   58:         warn_type: type[Warning],
   59:         warn_msg: str,
   60:         *args,
   61:         raise_on_extra_warnings=True,
   62:         **kwargs,
   63:     ):
   64:         # We need to check the stacklevel here instead of in the tests
   65:         # since this is where read_table is called and where the warning
   66:         # should point to.
   67:         kwargs = self.update_kwargs(kwargs)
   68:         with tm.assert_produces_warning(
   69:             warn_type, match=warn_msg, raise_on_extra_warnings=raise_on_extra_warnings
   70:         ):
   71:             return read_table(*args, **kwargs)
   72: 
   73: 
   74: class CParser(BaseParser):
   75:     engine = "c"
   76:     float_precision_choices = [None, "high", "round_trip"]
   77: 
   78: 
   79: class CParserHighMemory(CParser):
   80:     low_memory = False
   81: 
   82: 
   83: class CParserLowMemory(CParser):
   84:     low_memory = True
   85: 
   86: 
   87: class PythonParser(BaseParser):
   88:     engine = "python"
   89:     float_precision_choices = [None]
   90: 
   91: 
   92: class PyArrowParser(BaseParser):
   93:     engine = "pyarrow"
   94:     float_precision_choices = [None]
   95: 
   96: 
   97: @pytest.fixture
   98: def csv_dir_path(datapath):
   99:     """
  100:     The directory path to the data files needed for parser tests.
  101:     """
  102:     return datapath("io", "parser", "data")
  103: 
  104: 
  105: @pytest.fixture
  106: def csv1(datapath):
  107:     """
  108:     The path to the data file "test1.csv" needed for parser tests.
  109:     """
  110:     return os.path.join(datapath("io", "data", "csv"), "test1.csv")
  111: 
  112: 
  113: _cParserHighMemory = CParserHighMemory
  114: _cParserLowMemory = CParserLowMemory
  115: _pythonParser = PythonParser
  116: _pyarrowParser = PyArrowParser
  117: 
  118: _py_parsers_only = [_pythonParser]
  119: _c_parsers_only = [_cParserHighMemory, _cParserLowMemory]
  120: _pyarrow_parsers_only = [pytest.param(_pyarrowParser, marks=pytest.mark.single_cpu)]
  121: 
  122: _all_parsers = [*_c_parsers_only, *_py_parsers_only, *_pyarrow_parsers_only]
  123: 
  124: _py_parser_ids = ["python"]
  125: _c_parser_ids = ["c_high", "c_low"]
  126: _pyarrow_parsers_ids = ["pyarrow"]
  127: 
  128: _all_parser_ids = [*_c_parser_ids, *_py_parser_ids, *_pyarrow_parsers_ids]
  129: 
  130: 
  131: @pytest.fixture(params=_all_parsers, ids=_all_parser_ids)
  132: def all_parsers(request):
  133:     """
  134:     Fixture all of the CSV parsers.
  135:     """
  136:     parser = request.param()
  137:     if parser.engine == "pyarrow":
  138:         pytest.importorskip("pyarrow", VERSIONS["pyarrow"])
  139:         # Try finding a way to disable threads all together
  140:         # for more stable CI runs
  141:         import pyarrow
  142: 
  143:         pyarrow.set_cpu_count(1)
  144:     return parser
  145: 
  146: 
  147: @pytest.fixture(params=_c_parsers_only, ids=_c_parser_ids)
  148: def c_parser_only(request):
  149:     """
  150:     Fixture all of the CSV parsers using the C engine.
  151:     """
  152:     return request.param()
  153: 
  154: 
  155: @pytest.fixture(params=_py_parsers_only, ids=_py_parser_ids)
  156: def python_parser_only(request):
  157:     """
  158:     Fixture all of the CSV parsers using the Python engine.
  159:     """
  160:     return request.param()
  161: 
  162: 
  163: @pytest.fixture(params=_pyarrow_parsers_only, ids=_pyarrow_parsers_ids)
  164: def pyarrow_parser_only(request):
  165:     """
  166:     Fixture all of the CSV parsers using the Pyarrow engine.
  167:     """
  168:     return request.param()
  169: 
  170: 
  171: def _get_all_parser_float_precision_combinations():
  172:     """
  173:     Return all allowable parser and float precision
  174:     combinations and corresponding ids.
  175:     """
  176:     params = []
  177:     ids = []
  178:     for parser, parser_id in zip(_all_parsers, _all_parser_ids):
  179:         if hasattr(parser, "values"):
  180:             # Wrapped in pytest.param, get the actual parser back
  181:             parser = parser.values[0]
  182:         for precision in parser.float_precision_choices:
  183:             # Re-wrap in pytest.param for pyarrow
  184:             mark = pytest.mark.single_cpu if parser.engine == "pyarrow" else ()
  185:             param = pytest.param((parser(), precision), marks=mark)
  186:             params.append(param)
  187:             ids.append(f"{parser_id}-{precision}")
  188: 
  189:     return {"params": params, "ids": ids}
  190: 
  191: 
  192: @pytest.fixture(
  193:     params=_get_all_parser_float_precision_combinations()["params"],
  194:     ids=_get_all_parser_float_precision_combinations()["ids"],
  195: )
  196: def all_parsers_all_precisions(request):
  197:     """
  198:     Fixture for all allowable combinations of parser
  199:     and float precision
  200:     """
  201:     return request.param
  202: 
  203: 
  204: _utf_values = [8, 16, 32]
  205: 
  206: _encoding_seps = ["", "-", "_"]
  207: _encoding_prefixes = ["utf", "UTF"]
  208: 
  209: _encoding_fmts = [
  210:     f"{prefix}{sep}{{0}}" for sep in _encoding_seps for prefix in _encoding_prefixes
  211: ]
  212: 
  213: 
  214: @pytest.fixture(params=_utf_values)
  215: def utf_value(request):
  216:     """
  217:     Fixture for all possible integer values for a UTF encoding.
  218:     """
  219:     return request.param
  220: 
  221: 
  222: @pytest.fixture(params=_encoding_fmts)
  223: def encoding_fmt(request):
  224:     """
  225:     Fixture for all possible string formats of a UTF encoding.
  226:     """
  227:     return request.param
  228: 
  229: 
  230: @pytest.fixture(
  231:     params=[
  232:         ("-1,0", -1.0),
  233:         ("-1,2e0", -1.2),
  234:         ("-1e0", -1.0),
  235:         ("+1e0", 1.0),
  236:         ("+1e+0", 1.0),
  237:         ("+1e-1", 0.1),
  238:         ("+,1e1", 1.0),
  239:         ("+1,e0", 1.0),
  240:         ("-,1e1", -1.0),
  241:         ("-1,e0", -1.0),
  242:         ("0,1", 0.1),
  243:         ("1,", 1.0),
  244:         (",1", 0.1),
  245:         ("-,1", -0.1),
  246:         ("1_,", 1.0),
  247:         ("1_234,56", 1234.56),
  248:         ("1_234,56e0", 1234.56),
  249:         # negative cases; must not parse as float
  250:         ("_", "_"),
  251:         ("-_", "-_"),
  252:         ("-_1", "-_1"),
  253:         ("-_1e0", "-_1e0"),
  254:         ("_1", "_1"),
  255:         ("_1,", "_1,"),
  256:         ("_1,_", "_1,_"),
  257:         ("_1e0", "_1e0"),
  258:         ("1,2e_1", "1,2e_1"),
  259:         ("1,2e1_0", "1,2e1_0"),
  260:         ("1,_2", "1,_2"),
  261:         (",1__2", ",1__2"),
  262:         (",1e", ",1e"),
  263:         ("-,1e", "-,1e"),
  264:         ("1_000,000_000", "1_000,000_000"),
  265:         ("1,e1_2", "1,e1_2"),
  266:         ("e11,2", "e11,2"),
  267:         ("1e11,2", "1e11,2"),
  268:         ("1,2,2", "1,2,2"),
  269:         ("1,2_1", "1,2_1"),
  270:         ("1,2e-10e1", "1,2e-10e1"),
  271:         ("--1,2", "--1,2"),
  272:         ("1a_2,1", "1a_2,1"),
  273:         ("1,2E-1", 0.12),
  274:         ("1,2E1", 12.0),
  275:     ]
  276: )
  277: def numeric_decimal(request):
  278:     """
  279:     Fixture for all numeric formats which should get recognized. The first entry
  280:     represents the value to read while the second represents the expected result.
  281:     """
  282:     return request.param
  283: 
  284: 
  285: @pytest.fixture
  286: def pyarrow_xfail(request):
  287:     """
  288:     Fixture that xfails a test if the engine is pyarrow.
  289: 
  290:     Use if failure is do to unsupported keywords or inconsistent results.
  291:     """
  292:     if "all_parsers" in request.fixturenames:
  293:         parser = request.getfixturevalue("all_parsers")
  294:     elif "all_parsers_all_precisions" in request.fixturenames:
  295:         # Return value is tuple of (engine, precision)
  296:         parser = request.getfixturevalue("all_parsers_all_precisions")[0]
  297:     else:
  298:         return
  299:     if parser.engine == "pyarrow":
  300:         mark = pytest.mark.xfail(reason="pyarrow doesn't support this.")
  301:         request.applymarker(mark)
  302: 
  303: 
  304: @pytest.fixture
  305: def pyarrow_skip(request):
  306:     """
  307:     Fixture that skips a test if the engine is pyarrow.
  308: 
  309:     Use if failure is do a parsing failure from pyarrow.csv.read_csv
  310:     """
  311:     if "all_parsers" in request.fixturenames:
  312:         parser = request.getfixturevalue("all_parsers")
  313:     elif "all_parsers_all_precisions" in request.fixturenames:
  314:         # Return value is tuple of (engine, precision)
  315:         parser = request.getfixturevalue("all_parsers_all_precisions")[0]
  316:     else:
  317:         return
  318:     if parser.engine == "pyarrow":
  319:         pytest.skip(reason="https://github.com/apache/arrow/issues/38676")
