    1: """
    2: Tests that work on both the Python and C engines but do not have a
    3: specific classification into the other test modules.
    4: """
    5: from datetime import datetime
    6: from io import StringIO
    7: import os
    8: 
    9: import pytest
   10: 
   11: from pandas import (
   12:     DataFrame,
   13:     Index,
   14:     MultiIndex,
   15: )
   16: import pandas._testing as tm
   17: 
   18: pytestmark = pytest.mark.filterwarnings(
   19:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
   20: )
   21: 
   22: xfail_pyarrow = pytest.mark.usefixtures("pyarrow_xfail")
   23: skip_pyarrow = pytest.mark.usefixtures("pyarrow_skip")
   24: 
   25: 
   26: @pytest.mark.parametrize(
   27:     "data,kwargs,expected",
   28:     [
   29:         (
   30:             """foo,2,3,4,5
   31: bar,7,8,9,10
   32: baz,12,13,14,15
   33: qux,12,13,14,15
   34: foo2,12,13,14,15
   35: bar2,12,13,14,15
   36: """,
   37:             {"index_col": 0, "names": ["index", "A", "B", "C", "D"]},
   38:             DataFrame(
   39:                 [
   40:                     [2, 3, 4, 5],
   41:                     [7, 8, 9, 10],
   42:                     [12, 13, 14, 15],
   43:                     [12, 13, 14, 15],
   44:                     [12, 13, 14, 15],
   45:                     [12, 13, 14, 15],
   46:                 ],
   47:                 index=Index(["foo", "bar", "baz", "qux", "foo2", "bar2"], name="index"),
   48:                 columns=["A", "B", "C", "D"],
   49:             ),
   50:         ),
   51:         (
   52:             """foo,one,2,3,4,5
   53: foo,two,7,8,9,10
   54: foo,three,12,13,14,15
   55: bar,one,12,13,14,15
   56: bar,two,12,13,14,15
   57: """,
   58:             {"index_col": [0, 1], "names": ["index1", "index2", "A", "B", "C", "D"]},
   59:             DataFrame(
   60:                 [
   61:                     [2, 3, 4, 5],
   62:                     [7, 8, 9, 10],
   63:                     [12, 13, 14, 15],
   64:                     [12, 13, 14, 15],
   65:                     [12, 13, 14, 15],
   66:                 ],
   67:                 index=MultiIndex.from_tuples(
   68:                     [
   69:                         ("foo", "one"),
   70:                         ("foo", "two"),
   71:                         ("foo", "three"),
   72:                         ("bar", "one"),
   73:                         ("bar", "two"),
   74:                     ],
   75:                     names=["index1", "index2"],
   76:                 ),
   77:                 columns=["A", "B", "C", "D"],
   78:             ),
   79:         ),
   80:     ],
   81: )
   82: def test_pass_names_with_index(all_parsers, data, kwargs, expected):
   83:     parser = all_parsers
   84:     result = parser.read_csv(StringIO(data), **kwargs)
   85:     tm.assert_frame_equal(result, expected)
   86: 
   87: 
   88: @pytest.mark.parametrize("index_col", [[0, 1], [1, 0]])
   89: def test_multi_index_no_level_names(all_parsers, index_col):
   90:     data = """index1,index2,A,B,C,D
   91: foo,one,2,3,4,5
   92: foo,two,7,8,9,10
   93: foo,three,12,13,14,15
   94: bar,one,12,13,14,15
   95: bar,two,12,13,14,15
   96: """
   97:     headless_data = "\n".join(data.split("\n")[1:])
   98: 
   99:     names = ["A", "B", "C", "D"]
  100:     parser = all_parsers
  101: 
  102:     result = parser.read_csv(
  103:         StringIO(headless_data), index_col=index_col, header=None, names=names
  104:     )
  105:     expected = parser.read_csv(StringIO(data), index_col=index_col)
  106: 
  107:     # No index names in headless data.
  108:     expected.index.names = [None] * 2
  109:     tm.assert_frame_equal(result, expected)
  110: 
  111: 
  112: @skip_pyarrow
  113: def test_multi_index_no_level_names_implicit(all_parsers):
  114:     parser = all_parsers
  115:     data = """A,B,C,D
  116: foo,one,2,3,4,5
  117: foo,two,7,8,9,10
  118: foo,three,12,13,14,15
  119: bar,one,12,13,14,15
  120: bar,two,12,13,14,15
  121: """
  122: 
  123:     result = parser.read_csv(StringIO(data))
  124:     expected = DataFrame(
  125:         [
  126:             [2, 3, 4, 5],
  127:             [7, 8, 9, 10],
  128:             [12, 13, 14, 15],
  129:             [12, 13, 14, 15],
  130:             [12, 13, 14, 15],
  131:         ],
  132:         columns=["A", "B", "C", "D"],
  133:         index=MultiIndex.from_tuples(
  134:             [
  135:                 ("foo", "one"),
  136:                 ("foo", "two"),
  137:                 ("foo", "three"),
  138:                 ("bar", "one"),
  139:                 ("bar", "two"),
  140:             ]
  141:         ),
  142:     )
  143:     tm.assert_frame_equal(result, expected)
  144: 
  145: 
  146: @xfail_pyarrow  # TypeError: an integer is required
  147: @pytest.mark.parametrize(
  148:     "data,expected,header",
  149:     [
  150:         ("a,b", DataFrame(columns=["a", "b"]), [0]),
  151:         (
  152:             "a,b\nc,d",
  153:             DataFrame(columns=MultiIndex.from_tuples([("a", "c"), ("b", "d")])),
  154:             [0, 1],
  155:         ),
  156:     ],
  157: )
  158: @pytest.mark.parametrize("round_trip", [True, False])
  159: def test_multi_index_blank_df(all_parsers, data, expected, header, round_trip):
  160:     # see gh-14545
  161:     parser = all_parsers
  162:     data = expected.to_csv(index=False) if round_trip else data
  163: 
  164:     result = parser.read_csv(StringIO(data), header=header)
  165:     tm.assert_frame_equal(result, expected)
  166: 
  167: 
  168: @xfail_pyarrow  # AssertionError: DataFrame.columns are different
  169: def test_no_unnamed_index(all_parsers):
  170:     parser = all_parsers
  171:     data = """ id c0 c1 c2
  172: 0 1 0 a b
  173: 1 2 0 c d
  174: 2 2 2 e f
  175: """
  176:     result = parser.read_csv(StringIO(data), sep=" ")
  177:     expected = DataFrame(
  178:         [[0, 1, 0, "a", "b"], [1, 2, 0, "c", "d"], [2, 2, 2, "e", "f"]],
  179:         columns=["Unnamed: 0", "id", "c0", "c1", "c2"],
  180:     )
  181:     tm.assert_frame_equal(result, expected)
  182: 
  183: 
  184: def test_read_duplicate_index_explicit(all_parsers):
  185:     data = """index,A,B,C,D
  186: foo,2,3,4,5
  187: bar,7,8,9,10
  188: baz,12,13,14,15
  189: qux,12,13,14,15
  190: foo,12,13,14,15
  191: bar,12,13,14,15
  192: """
  193:     parser = all_parsers
  194:     result = parser.read_csv(StringIO(data), index_col=0)
  195: 
  196:     expected = DataFrame(
  197:         [
  198:             [2, 3, 4, 5],
  199:             [7, 8, 9, 10],
  200:             [12, 13, 14, 15],
  201:             [12, 13, 14, 15],
  202:             [12, 13, 14, 15],
  203:             [12, 13, 14, 15],
  204:         ],
  205:         columns=["A", "B", "C", "D"],
  206:         index=Index(["foo", "bar", "baz", "qux", "foo", "bar"], name="index"),
  207:     )
  208:     tm.assert_frame_equal(result, expected)
  209: 
  210: 
  211: @skip_pyarrow
  212: def test_read_duplicate_index_implicit(all_parsers):
  213:     data = """A,B,C,D
  214: foo,2,3,4,5
  215: bar,7,8,9,10
  216: baz,12,13,14,15
  217: qux,12,13,14,15
  218: foo,12,13,14,15
  219: bar,12,13,14,15
  220: """
  221:     parser = all_parsers
  222:     result = parser.read_csv(StringIO(data))
  223: 
  224:     expected = DataFrame(
  225:         [
  226:             [2, 3, 4, 5],
  227:             [7, 8, 9, 10],
  228:             [12, 13, 14, 15],
  229:             [12, 13, 14, 15],
  230:             [12, 13, 14, 15],
  231:             [12, 13, 14, 15],
  232:         ],
  233:         columns=["A", "B", "C", "D"],
  234:         index=Index(["foo", "bar", "baz", "qux", "foo", "bar"]),
  235:     )
  236:     tm.assert_frame_equal(result, expected)
  237: 
  238: 
  239: @skip_pyarrow
  240: def test_read_csv_no_index_name(all_parsers, csv_dir_path):
  241:     parser = all_parsers
  242:     csv2 = os.path.join(csv_dir_path, "test2.csv")
  243:     result = parser.read_csv(csv2, index_col=0, parse_dates=True)
  244: 
  245:     expected = DataFrame(
  246:         [
  247:             [0.980269, 3.685731, -0.364216805298, -1.159738, "foo"],
  248:             [1.047916, -0.041232, -0.16181208307, 0.212549, "bar"],
  249:             [0.498581, 0.731168, -0.537677223318, 1.346270, "baz"],
  250:             [1.120202, 1.567621, 0.00364077397681, 0.675253, "qux"],
  251:             [-0.487094, 0.571455, -1.6116394093, 0.103469, "foo2"],
  252:         ],
  253:         columns=["A", "B", "C", "D", "E"],
  254:         index=Index(
  255:             [
  256:                 datetime(2000, 1, 3),
  257:                 datetime(2000, 1, 4),
  258:                 datetime(2000, 1, 5),
  259:                 datetime(2000, 1, 6),
  260:                 datetime(2000, 1, 7),
  261:             ]
  262:         ),
  263:     )
  264:     tm.assert_frame_equal(result, expected)
  265: 
  266: 
  267: @skip_pyarrow
  268: def test_empty_with_index(all_parsers):
  269:     # see gh-10184
  270:     data = "x,y"
  271:     parser = all_parsers
  272:     result = parser.read_csv(StringIO(data), index_col=0)
  273: 
  274:     expected = DataFrame(columns=["y"], index=Index([], name="x"))
  275:     tm.assert_frame_equal(result, expected)
  276: 
  277: 
  278: # CSV parse error: Empty CSV file or block: cannot infer number of columns
  279: @skip_pyarrow
  280: def test_empty_with_multi_index(all_parsers):
  281:     # see gh-10467
  282:     data = "x,y,z"
  283:     parser = all_parsers
  284:     result = parser.read_csv(StringIO(data), index_col=["x", "y"])
  285: 
  286:     expected = DataFrame(
  287:         columns=["z"], index=MultiIndex.from_arrays([[]] * 2, names=["x", "y"])
  288:     )
  289:     tm.assert_frame_equal(result, expected)
  290: 
  291: 
  292: # CSV parse error: Empty CSV file or block: cannot infer number of columns
  293: @skip_pyarrow
  294: def test_empty_with_reversed_multi_index(all_parsers):
  295:     data = "x,y,z"
  296:     parser = all_parsers
  297:     result = parser.read_csv(StringIO(data), index_col=[1, 0])
  298: 
  299:     expected = DataFrame(
  300:         columns=["z"], index=MultiIndex.from_arrays([[]] * 2, names=["y", "x"])
  301:     )
  302:     tm.assert_frame_equal(result, expected)
