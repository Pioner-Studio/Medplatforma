    1: from __future__ import annotations
    2: 
    3: from io import StringIO
    4: 
    5: import pytest
    6: 
    7: from pandas.errors import ParserWarning
    8: import pandas.util._test_decorators as td
    9: 
   10: from pandas import (
   11:     DataFrame,
   12:     DatetimeIndex,
   13:     Series,
   14:     to_datetime,
   15: )
   16: import pandas._testing as tm
   17: 
   18: from pandas.io.xml import read_xml
   19: 
   20: 
   21: @pytest.fixture(params=[pytest.param("lxml", marks=td.skip_if_no("lxml")), "etree"])
   22: def parser(request):
   23:     return request.param
   24: 
   25: 
   26: @pytest.fixture(
   27:     params=[None, {"book": ["category", "title", "author", "year", "price"]}]
   28: )
   29: def iterparse(request):
   30:     return request.param
   31: 
   32: 
   33: def read_xml_iterparse(data, **kwargs):
   34:     with tm.ensure_clean() as path:
   35:         with open(path, "w", encoding="utf-8") as f:
   36:             f.write(data)
   37:         return read_xml(path, **kwargs)
   38: 
   39: 
   40: xml_types = """\
   41: <?xml version='1.0' encoding='utf-8'?>
   42: <data>
   43:   <row>
   44:     <shape>square</shape>
   45:     <degrees>00360</degrees>
   46:     <sides>4.0</sides>
   47:    </row>
   48:   <row>
   49:     <shape>circle</shape>
   50:     <degrees>00360</degrees>
   51:     <sides/>
   52:   </row>
   53:   <row>
   54:     <shape>triangle</shape>
   55:     <degrees>00180</degrees>
   56:     <sides>3.0</sides>
   57:   </row>
   58: </data>"""
   59: 
   60: xml_dates = """<?xml version='1.0' encoding='utf-8'?>
   61: <data>
   62:   <row>
   63:     <shape>square</shape>
   64:     <degrees>00360</degrees>
   65:     <sides>4.0</sides>
   66:     <date>2020-01-01</date>
   67:    </row>
   68:   <row>
   69:     <shape>circle</shape>
   70:     <degrees>00360</degrees>
   71:     <sides/>
   72:     <date>2021-01-01</date>
   73:   </row>
   74:   <row>
   75:     <shape>triangle</shape>
   76:     <degrees>00180</degrees>
   77:     <sides>3.0</sides>
   78:     <date>2022-01-01</date>
   79:   </row>
   80: </data>"""
   81: 
   82: 
   83: # DTYPE
   84: 
   85: 
   86: def test_dtype_single_str(parser):
   87:     df_result = read_xml(StringIO(xml_types), dtype={"degrees": "str"}, parser=parser)
   88:     df_iter = read_xml_iterparse(
   89:         xml_types,
   90:         parser=parser,
   91:         dtype={"degrees": "str"},
   92:         iterparse={"row": ["shape", "degrees", "sides"]},
   93:     )
   94: 
   95:     df_expected = DataFrame(
   96:         {
   97:             "shape": ["square", "circle", "triangle"],
   98:             "degrees": ["00360", "00360", "00180"],
   99:             "sides": [4.0, float("nan"), 3.0],
  100:         }
  101:     )
  102: 
  103:     tm.assert_frame_equal(df_result, df_expected)
  104:     tm.assert_frame_equal(df_iter, df_expected)
  105: 
  106: 
  107: def test_dtypes_all_str(parser):
  108:     df_result = read_xml(StringIO(xml_dates), dtype="string", parser=parser)
  109:     df_iter = read_xml_iterparse(
  110:         xml_dates,
  111:         parser=parser,
  112:         dtype="string",
  113:         iterparse={"row": ["shape", "degrees", "sides", "date"]},
  114:     )
  115: 
  116:     df_expected = DataFrame(
  117:         {
  118:             "shape": ["square", "circle", "triangle"],
  119:             "degrees": ["00360", "00360", "00180"],
  120:             "sides": ["4.0", None, "3.0"],
  121:             "date": ["2020-01-01", "2021-01-01", "2022-01-01"],
  122:         },
  123:         dtype="string",
  124:     )
  125: 
  126:     tm.assert_frame_equal(df_result, df_expected)
  127:     tm.assert_frame_equal(df_iter, df_expected)
  128: 
  129: 
  130: def test_dtypes_with_names(parser):
  131:     df_result = read_xml(
  132:         StringIO(xml_dates),
  133:         names=["Col1", "Col2", "Col3", "Col4"],
  134:         dtype={"Col2": "string", "Col3": "Int64", "Col4": "datetime64[ns]"},
  135:         parser=parser,
  136:     )
  137:     df_iter = read_xml_iterparse(
  138:         xml_dates,
  139:         parser=parser,
  140:         names=["Col1", "Col2", "Col3", "Col4"],
  141:         dtype={"Col2": "string", "Col3": "Int64", "Col4": "datetime64[ns]"},
  142:         iterparse={"row": ["shape", "degrees", "sides", "date"]},
  143:     )
  144: 
  145:     df_expected = DataFrame(
  146:         {
  147:             "Col1": ["square", "circle", "triangle"],
  148:             "Col2": Series(["00360", "00360", "00180"]).astype("string"),
  149:             "Col3": Series([4.0, float("nan"), 3.0]).astype("Int64"),
  150:             "Col4": DatetimeIndex(
  151:                 ["2020-01-01", "2021-01-01", "2022-01-01"], dtype="M8[ns]"
  152:             ),
  153:         }
  154:     )
  155: 
  156:     tm.assert_frame_equal(df_result, df_expected)
  157:     tm.assert_frame_equal(df_iter, df_expected)
  158: 
  159: 
  160: def test_dtype_nullable_int(parser):
  161:     df_result = read_xml(StringIO(xml_types), dtype={"sides": "Int64"}, parser=parser)
  162:     df_iter = read_xml_iterparse(
  163:         xml_types,
  164:         parser=parser,
  165:         dtype={"sides": "Int64"},
  166:         iterparse={"row": ["shape", "degrees", "sides"]},
  167:     )
  168: 
  169:     df_expected = DataFrame(
  170:         {
  171:             "shape": ["square", "circle", "triangle"],
  172:             "degrees": [360, 360, 180],
  173:             "sides": Series([4.0, float("nan"), 3.0]).astype("Int64"),
  174:         }
  175:     )
  176: 
  177:     tm.assert_frame_equal(df_result, df_expected)
  178:     tm.assert_frame_equal(df_iter, df_expected)
  179: 
  180: 
  181: def test_dtype_float(parser):
  182:     df_result = read_xml(StringIO(xml_types), dtype={"degrees": "float"}, parser=parser)
  183:     df_iter = read_xml_iterparse(
  184:         xml_types,
  185:         parser=parser,
  186:         dtype={"degrees": "float"},
  187:         iterparse={"row": ["shape", "degrees", "sides"]},
  188:     )
  189: 
  190:     df_expected = DataFrame(
  191:         {
  192:             "shape": ["square", "circle", "triangle"],
  193:             "degrees": Series([360, 360, 180]).astype("float"),
  194:             "sides": [4.0, float("nan"), 3.0],
  195:         }
  196:     )
  197: 
  198:     tm.assert_frame_equal(df_result, df_expected)
  199:     tm.assert_frame_equal(df_iter, df_expected)
  200: 
  201: 
  202: def test_wrong_dtype(xml_books, parser, iterparse):
  203:     with pytest.raises(
  204:         ValueError, match=('Unable to parse string "Everyday Italian" at position 0')
  205:     ):
  206:         read_xml(
  207:             xml_books, dtype={"title": "Int64"}, parser=parser, iterparse=iterparse
  208:         )
  209: 
  210: 
  211: def test_both_dtype_converters(parser):
  212:     df_expected = DataFrame(
  213:         {
  214:             "shape": ["square", "circle", "triangle"],
  215:             "degrees": ["00360", "00360", "00180"],
  216:             "sides": [4.0, float("nan"), 3.0],
  217:         }
  218:     )
  219: 
  220:     with tm.assert_produces_warning(ParserWarning, match="Both a converter and dtype"):
  221:         df_result = read_xml(
  222:             StringIO(xml_types),
  223:             dtype={"degrees": "str"},
  224:             converters={"degrees": str},
  225:             parser=parser,
  226:         )
  227:         df_iter = read_xml_iterparse(
  228:             xml_types,
  229:             dtype={"degrees": "str"},
  230:             converters={"degrees": str},
  231:             parser=parser,
  232:             iterparse={"row": ["shape", "degrees", "sides"]},
  233:         )
  234: 
  235:         tm.assert_frame_equal(df_result, df_expected)
  236:         tm.assert_frame_equal(df_iter, df_expected)
  237: 
  238: 
  239: # CONVERTERS
  240: 
  241: 
  242: def test_converters_str(parser):
  243:     df_result = read_xml(
  244:         StringIO(xml_types), converters={"degrees": str}, parser=parser
  245:     )
  246:     df_iter = read_xml_iterparse(
  247:         xml_types,
  248:         parser=parser,
  249:         converters={"degrees": str},
  250:         iterparse={"row": ["shape", "degrees", "sides"]},
  251:     )
  252: 
  253:     df_expected = DataFrame(
  254:         {
  255:             "shape": ["square", "circle", "triangle"],
  256:             "degrees": ["00360", "00360", "00180"],
  257:             "sides": [4.0, float("nan"), 3.0],
  258:         }
  259:     )
  260: 
  261:     tm.assert_frame_equal(df_result, df_expected)
  262:     tm.assert_frame_equal(df_iter, df_expected)
  263: 
  264: 
  265: def test_converters_date(parser):
  266:     convert_to_datetime = lambda x: to_datetime(x)
  267:     df_result = read_xml(
  268:         StringIO(xml_dates), converters={"date": convert_to_datetime}, parser=parser
  269:     )
  270:     df_iter = read_xml_iterparse(
  271:         xml_dates,
  272:         parser=parser,
  273:         converters={"date": convert_to_datetime},
  274:         iterparse={"row": ["shape", "degrees", "sides", "date"]},
  275:     )
  276: 
  277:     df_expected = DataFrame(
  278:         {
  279:             "shape": ["square", "circle", "triangle"],
  280:             "degrees": [360, 360, 180],
  281:             "sides": [4.0, float("nan"), 3.0],
  282:             "date": to_datetime(["2020-01-01", "2021-01-01", "2022-01-01"]),
  283:         }
  284:     )
  285: 
  286:     tm.assert_frame_equal(df_result, df_expected)
  287:     tm.assert_frame_equal(df_iter, df_expected)
  288: 
  289: 
  290: def test_wrong_converters_type(xml_books, parser, iterparse):
  291:     with pytest.raises(TypeError, match=("Type converters must be a dict or subclass")):
  292:         read_xml(
  293:             xml_books, converters={"year", str}, parser=parser, iterparse=iterparse
  294:         )
  295: 
  296: 
  297: def test_callable_func_converters(xml_books, parser, iterparse):
  298:     with pytest.raises(TypeError, match=("'float' object is not callable")):
  299:         read_xml(
  300:             xml_books, converters={"year": float()}, parser=parser, iterparse=iterparse
  301:         )
  302: 
  303: 
  304: def test_callable_str_converters(xml_books, parser, iterparse):
  305:     with pytest.raises(TypeError, match=("'str' object is not callable")):
  306:         read_xml(
  307:             xml_books, converters={"year": "float"}, parser=parser, iterparse=iterparse
  308:         )
  309: 
  310: 
  311: # PARSE DATES
  312: 
  313: 
  314: def test_parse_dates_column_name(parser):
  315:     df_result = read_xml(StringIO(xml_dates), parse_dates=["date"], parser=parser)
  316:     df_iter = read_xml_iterparse(
  317:         xml_dates,
  318:         parser=parser,
  319:         parse_dates=["date"],
  320:         iterparse={"row": ["shape", "degrees", "sides", "date"]},
  321:     )
  322: 
  323:     df_expected = DataFrame(
  324:         {
  325:             "shape": ["square", "circle", "triangle"],
  326:             "degrees": [360, 360, 180],
  327:             "sides": [4.0, float("nan"), 3.0],
  328:             "date": to_datetime(["2020-01-01", "2021-01-01", "2022-01-01"]),
  329:         }
  330:     )
  331: 
  332:     tm.assert_frame_equal(df_result, df_expected)
  333:     tm.assert_frame_equal(df_iter, df_expected)
  334: 
  335: 
  336: def test_parse_dates_column_index(parser):
  337:     df_result = read_xml(StringIO(xml_dates), parse_dates=[3], parser=parser)
  338:     df_iter = read_xml_iterparse(
  339:         xml_dates,
  340:         parser=parser,
  341:         parse_dates=[3],
  342:         iterparse={"row": ["shape", "degrees", "sides", "date"]},
  343:     )
  344: 
  345:     df_expected = DataFrame(
  346:         {
  347:             "shape": ["square", "circle", "triangle"],
  348:             "degrees": [360, 360, 180],
  349:             "sides": [4.0, float("nan"), 3.0],
  350:             "date": to_datetime(["2020-01-01", "2021-01-01", "2022-01-01"]),
  351:         }
  352:     )
  353: 
  354:     tm.assert_frame_equal(df_result, df_expected)
  355:     tm.assert_frame_equal(df_iter, df_expected)
  356: 
  357: 
  358: def test_parse_dates_true(parser):
  359:     df_result = read_xml(StringIO(xml_dates), parse_dates=True, parser=parser)
  360: 
  361:     df_iter = read_xml_iterparse(
  362:         xml_dates,
  363:         parser=parser,
  364:         parse_dates=True,
  365:         iterparse={"row": ["shape", "degrees", "sides", "date"]},
  366:     )
  367: 
  368:     df_expected = DataFrame(
  369:         {
  370:             "shape": ["square", "circle", "triangle"],
  371:             "degrees": [360, 360, 180],
  372:             "sides": [4.0, float("nan"), 3.0],
  373:             "date": ["2020-01-01", "2021-01-01", "2022-01-01"],
  374:         }
  375:     )
  376: 
  377:     tm.assert_frame_equal(df_result, df_expected)
  378:     tm.assert_frame_equal(df_iter, df_expected)
  379: 
  380: 
  381: def test_parse_dates_dictionary(parser):
  382:     xml = """<?xml version='1.0' encoding='utf-8'?>
  383: <data>
  384:   <row>
  385:     <shape>square</shape>
  386:     <degrees>360</degrees>
  387:     <sides>4.0</sides>
  388:     <year>2020</year>
  389:     <month>12</month>
  390:     <day>31</day>
  391:    </row>
  392:   <row>
  393:     <shape>circle</shape>
  394:     <degrees>360</degrees>
  395:     <sides/>
  396:     <year>2021</year>
  397:     <month>12</month>
  398:     <day>31</day>
  399:   </row>
  400:   <row>
  401:     <shape>triangle</shape>
  402:     <degrees>180</degrees>
  403:     <sides>3.0</sides>
  404:     <year>2022</year>
  405:     <month>12</month>
  406:     <day>31</day>
  407:   </row>
  408: </data>"""
  409: 
  410:     df_result = read_xml(
  411:         StringIO(xml), parse_dates={"date_end": ["year", "month", "day"]}, parser=parser
  412:     )
  413:     df_iter = read_xml_iterparse(
  414:         xml,
  415:         parser=parser,
  416:         parse_dates={"date_end": ["year", "month", "day"]},
  417:         iterparse={"row": ["shape", "degrees", "sides", "year", "month", "day"]},
  418:     )
  419: 
  420:     df_expected = DataFrame(
  421:         {
  422:             "date_end": to_datetime(["2020-12-31", "2021-12-31", "2022-12-31"]),
  423:             "shape": ["square", "circle", "triangle"],
  424:             "degrees": [360, 360, 180],
  425:             "sides": [4.0, float("nan"), 3.0],
  426:         }
  427:     )
  428: 
  429:     tm.assert_frame_equal(df_result, df_expected)
  430:     tm.assert_frame_equal(df_iter, df_expected)
  431: 
  432: 
  433: def test_day_first_parse_dates(parser):
  434:     xml = """\
  435: <?xml version='1.0' encoding='utf-8'?>
  436: <data>
  437:   <row>
  438:     <shape>square</shape>
  439:     <degrees>00360</degrees>
  440:     <sides>4.0</sides>
  441:     <date>31/12/2020</date>
  442:    </row>
  443:   <row>
  444:     <shape>circle</shape>
  445:     <degrees>00360</degrees>
  446:     <sides/>
  447:     <date>31/12/2021</date>
  448:   </row>
  449:   <row>
  450:     <shape>triangle</shape>
  451:     <degrees>00180</degrees>
  452:     <sides>3.0</sides>
  453:     <date>31/12/2022</date>
  454:   </row>
  455: </data>"""
  456: 
  457:     df_expected = DataFrame(
  458:         {
  459:             "shape": ["square", "circle", "triangle"],
  460:             "degrees": [360, 360, 180],
  461:             "sides": [4.0, float("nan"), 3.0],
  462:             "date": to_datetime(["2020-12-31", "2021-12-31", "2022-12-31"]),
  463:         }
  464:     )
  465: 
  466:     with tm.assert_produces_warning(
  467:         UserWarning, match="Parsing dates in %d/%m/%Y format"
  468:     ):
  469:         df_result = read_xml(StringIO(xml), parse_dates=["date"], parser=parser)
  470:         df_iter = read_xml_iterparse(
  471:             xml,
  472:             parse_dates=["date"],
  473:             parser=parser,
  474:             iterparse={"row": ["shape", "degrees", "sides", "date"]},
  475:         )
  476: 
  477:         tm.assert_frame_equal(df_result, df_expected)
  478:         tm.assert_frame_equal(df_iter, df_expected)
  479: 
  480: 
  481: def test_wrong_parse_dates_type(xml_books, parser, iterparse):
  482:     with pytest.raises(
  483:         TypeError, match=("Only booleans, lists, and dictionaries are accepted")
  484:     ):
  485:         read_xml(xml_books, parse_dates={"date"}, parser=parser, iterparse=iterparse)
