    1: from datetime import (
    2:     date,
    3:     datetime,
    4:     timedelta,
    5: )
    6: import re
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas.core.dtypes.common import (
   12:     is_object_dtype,
   13:     is_string_dtype,
   14: )
   15: from pandas.core.dtypes.dtypes import CategoricalDtype
   16: 
   17: import pandas as pd
   18: from pandas import (
   19:     Categorical,
   20:     CategoricalIndex,
   21:     DataFrame,
   22:     DatetimeIndex,
   23:     Index,
   24:     IntervalIndex,
   25:     MultiIndex,
   26:     PeriodIndex,
   27:     RangeIndex,
   28:     Series,
   29:     TimedeltaIndex,
   30: )
   31: import pandas._testing as tm
   32: from pandas.core.reshape.concat import concat
   33: from pandas.core.reshape.merge import (
   34:     MergeError,
   35:     merge,
   36: )
   37: 
   38: 
   39: def get_test_data(ngroups=8, n=50):
   40:     unique_groups = list(range(ngroups))
   41:     arr = np.asarray(np.tile(unique_groups, n // ngroups))
   42: 
   43:     if len(arr) < n:
   44:         arr = np.asarray(list(arr) + unique_groups[: n - len(arr)])
   45: 
   46:     np.random.default_rng(2).shuffle(arr)
   47:     return arr
   48: 
   49: 
   50: def get_series():
   51:     return [
   52:         Series([1], dtype="int64"),
   53:         Series([1], dtype="Int64"),
   54:         Series([1.23]),
   55:         Series(["foo"]),
   56:         Series([True]),
   57:         Series([pd.Timestamp("2018-01-01")]),
   58:         Series([pd.Timestamp("2018-01-01", tz="US/Eastern")]),
   59:     ]
   60: 
   61: 
   62: def get_series_na():
   63:     return [
   64:         Series([np.nan], dtype="Int64"),
   65:         Series([np.nan], dtype="float"),
   66:         Series([np.nan], dtype="object"),
   67:         Series([pd.NaT]),
   68:     ]
   69: 
   70: 
   71: @pytest.fixture(params=get_series(), ids=lambda x: x.dtype.name)
   72: def series_of_dtype(request):
   73:     """
   74:     A parametrized fixture returning a variety of Series of different
   75:     dtypes
   76:     """
   77:     return request.param
   78: 
   79: 
   80: @pytest.fixture(params=get_series(), ids=lambda x: x.dtype.name)
   81: def series_of_dtype2(request):
   82:     """
   83:     A duplicate of the series_of_dtype fixture, so that it can be used
   84:     twice by a single function
   85:     """
   86:     return request.param
   87: 
   88: 
   89: @pytest.fixture(params=get_series_na(), ids=lambda x: x.dtype.name)
   90: def series_of_dtype_all_na(request):
   91:     """
   92:     A parametrized fixture returning a variety of Series with all NA
   93:     values
   94:     """
   95:     return request.param
   96: 
   97: 
   98: @pytest.fixture
   99: def dfs_for_indicator():
  100:     df1 = DataFrame({"col1": [0, 1], "col_conflict": [1, 2], "col_left": ["a", "b"]})
  101:     df2 = DataFrame(
  102:         {
  103:             "col1": [1, 2, 3, 4, 5],
  104:             "col_conflict": [1, 2, 3, 4, 5],
  105:             "col_right": [2, 2, 2, 2, 2],
  106:         }
  107:     )
  108:     return df1, df2
  109: 
  110: 
  111: class TestMerge:
  112:     @pytest.fixture
  113:     def df(self):
  114:         df = DataFrame(
  115:             {
  116:                 "key1": get_test_data(),
  117:                 "key2": get_test_data(),
  118:                 "data1": np.random.default_rng(2).standard_normal(50),
  119:                 "data2": np.random.default_rng(2).standard_normal(50),
  120:             }
  121:         )
  122: 
  123:         # exclude a couple keys for fun
  124:         df = df[df["key2"] > 1]
  125:         return df
  126: 
  127:     @pytest.fixture
  128:     def df2(self):
  129:         return DataFrame(
  130:             {
  131:                 "key1": get_test_data(n=10),
  132:                 "key2": get_test_data(ngroups=4, n=10),
  133:                 "value": np.random.default_rng(2).standard_normal(10),
  134:             }
  135:         )
  136: 
  137:     @pytest.fixture
  138:     def left(self):
  139:         return DataFrame(
  140:             {
  141:                 "key": ["a", "b", "c", "d", "e", "e", "a"],
  142:                 "v1": np.random.default_rng(2).standard_normal(7),
  143:             }
  144:         )
  145: 
  146:     @pytest.fixture
  147:     def right(self):
  148:         return DataFrame(
  149:             {"v2": np.random.default_rng(2).standard_normal(4)},
  150:             index=["d", "b", "c", "a"],
  151:         )
  152: 
  153:     def test_merge_inner_join_empty(self):
  154:         # GH 15328
  155:         df_empty = DataFrame()
  156:         df_a = DataFrame({"a": [1, 2]}, index=[0, 1], dtype="int64")
  157:         result = merge(df_empty, df_a, left_index=True, right_index=True)
  158:         expected = DataFrame({"a": []}, dtype="int64")
  159:         tm.assert_frame_equal(result, expected)
  160: 
  161:     def test_merge_common(self, df, df2):
  162:         joined = merge(df, df2)
  163:         exp = merge(df, df2, on=["key1", "key2"])
  164:         tm.assert_frame_equal(joined, exp)
  165: 
  166:     def test_merge_non_string_columns(self):
  167:         # https://github.com/pandas-dev/pandas/issues/17962
  168:         # Checks that method runs for non string column names
  169:         left = DataFrame(
  170:             {0: [1, 0, 1, 0], 1: [0, 1, 0, 0], 2: [0, 0, 2, 0], 3: [1, 0, 0, 3]}
  171:         )
  172: 
  173:         right = left.astype(float)
  174:         expected = left
  175:         result = merge(left, right)
  176:         tm.assert_frame_equal(expected, result)
  177: 
  178:     def test_merge_index_as_on_arg(self, df, df2):
  179:         # GH14355
  180: 
  181:         left = df.set_index("key1")
  182:         right = df2.set_index("key1")
  183:         result = merge(left, right, on="key1")
  184:         expected = merge(df, df2, on="key1").set_index("key1")
  185:         tm.assert_frame_equal(result, expected)
  186: 
  187:     def test_merge_index_singlekey_right_vs_left(self):
  188:         left = DataFrame(
  189:             {
  190:                 "key": ["a", "b", "c", "d", "e", "e", "a"],
  191:                 "v1": np.random.default_rng(2).standard_normal(7),
  192:             }
  193:         )
  194:         right = DataFrame(
  195:             {"v2": np.random.default_rng(2).standard_normal(4)},
  196:             index=["d", "b", "c", "a"],
  197:         )
  198: 
  199:         merged1 = merge(
  200:             left, right, left_on="key", right_index=True, how="left", sort=False
  201:         )
  202:         merged2 = merge(
  203:             right, left, right_on="key", left_index=True, how="right", sort=False
  204:         )
  205:         tm.assert_frame_equal(merged1, merged2.loc[:, merged1.columns])
  206: 
  207:         merged1 = merge(
  208:             left, right, left_on="key", right_index=True, how="left", sort=True
  209:         )
  210:         merged2 = merge(
  211:             right, left, right_on="key", left_index=True, how="right", sort=True
  212:         )
  213:         tm.assert_frame_equal(merged1, merged2.loc[:, merged1.columns])
  214: 
  215:     def test_merge_index_singlekey_inner(self):
  216:         left = DataFrame(
  217:             {
  218:                 "key": ["a", "b", "c", "d", "e", "e", "a"],
  219:                 "v1": np.random.default_rng(2).standard_normal(7),
  220:             }
  221:         )
  222:         right = DataFrame(
  223:             {"v2": np.random.default_rng(2).standard_normal(4)},
  224:             index=["d", "b", "c", "a"],
  225:         )
  226: 
  227:         # inner join
  228:         result = merge(left, right, left_on="key", right_index=True, how="inner")
  229:         expected = left.join(right, on="key").loc[result.index]
  230:         tm.assert_frame_equal(result, expected)
  231: 
  232:         result = merge(right, left, right_on="key", left_index=True, how="inner")
  233:         expected = left.join(right, on="key").loc[result.index]
  234:         tm.assert_frame_equal(result, expected.loc[:, result.columns])
  235: 
  236:     def test_merge_misspecified(self, df, df2, left, right):
  237:         msg = "Must pass right_on or right_index=True"
  238:         with pytest.raises(pd.errors.MergeError, match=msg):
  239:             merge(left, right, left_index=True)
  240:         msg = "Must pass left_on or left_index=True"
  241:         with pytest.raises(pd.errors.MergeError, match=msg):
  242:             merge(left, right, right_index=True)
  243: 
  244:         msg = (
  245:             'Can only pass argument "on" OR "left_on" and "right_on", not '
  246:             "a combination of both"
  247:         )
  248:         with pytest.raises(pd.errors.MergeError, match=msg):
  249:             merge(left, left, left_on="key", on="key")
  250: 
  251:         msg = r"len\(right_on\) must equal len\(left_on\)"
  252:         with pytest.raises(ValueError, match=msg):
  253:             merge(df, df2, left_on=["key1"], right_on=["key1", "key2"])
  254: 
  255:     def test_index_and_on_parameters_confusion(self, df, df2):
  256:         msg = "right_index parameter must be of type bool, not <class 'list'>"
  257:         with pytest.raises(ValueError, match=msg):
  258:             merge(
  259:                 df,
  260:                 df2,
  261:                 how="left",
  262:                 left_index=False,
  263:                 right_index=["key1", "key2"],
  264:             )
  265:         msg = "left_index parameter must be of type bool, not <class 'list'>"
  266:         with pytest.raises(ValueError, match=msg):
  267:             merge(
  268:                 df,
  269:                 df2,
  270:                 how="left",
  271:                 left_index=["key1", "key2"],
  272:                 right_index=False,
  273:             )
  274:         with pytest.raises(ValueError, match=msg):
  275:             merge(
  276:                 df,
  277:                 df2,
  278:                 how="left",
  279:                 left_index=["key1", "key2"],
  280:                 right_index=["key1", "key2"],
  281:             )
  282: 
  283:     def test_merge_overlap(self, left):
  284:         merged = merge(left, left, on="key")
  285:         exp_len = (left["key"].value_counts() ** 2).sum()
  286:         assert len(merged) == exp_len
  287:         assert "v1_x" in merged
  288:         assert "v1_y" in merged
  289: 
  290:     def test_merge_different_column_key_names(self):
  291:         left = DataFrame({"lkey": ["foo", "bar", "baz", "foo"], "value": [1, 2, 3, 4]})
  292:         right = DataFrame({"rkey": ["foo", "bar", "qux", "foo"], "value": [5, 6, 7, 8]})
  293: 
  294:         merged = left.merge(
  295:             right, left_on="lkey", right_on="rkey", how="outer", sort=True
  296:         )
  297: 
  298:         exp = Series(["bar", "baz", "foo", "foo", "foo", "foo", np.nan], name="lkey")
  299:         tm.assert_series_equal(merged["lkey"], exp)
  300: 
  301:         exp = Series(["bar", np.nan, "foo", "foo", "foo", "foo", "qux"], name="rkey")
  302:         tm.assert_series_equal(merged["rkey"], exp)
  303: 
  304:         exp = Series([2, 3, 1, 1, 4, 4, np.nan], name="value_x")
  305:         tm.assert_series_equal(merged["value_x"], exp)
  306: 
  307:         exp = Series([6, np.nan, 5, 8, 5, 8, 7], name="value_y")
  308:         tm.assert_series_equal(merged["value_y"], exp)
  309: 
  310:     def test_merge_copy(self):
  311:         left = DataFrame({"a": 0, "b": 1}, index=range(10))
  312:         right = DataFrame({"c": "foo", "d": "bar"}, index=range(10))
  313: 
  314:         merged = merge(left, right, left_index=True, right_index=True, copy=True)
  315: 
  316:         merged["a"] = 6
  317:         assert (left["a"] == 0).all()
  318: 
  319:         merged["d"] = "peekaboo"
  320:         assert (right["d"] == "bar").all()
  321: 
  322:     def test_merge_nocopy(self, using_array_manager, using_infer_string):
  323:         left = DataFrame({"a": 0, "b": 1}, index=range(10))
  324:         right = DataFrame({"c": "foo", "d": "bar"}, index=range(10))
  325: 
  326:         merged = merge(left, right, left_index=True, right_index=True, copy=False)
  327: 
  328:         assert np.shares_memory(merged["a"]._values, left["a"]._values)
  329:         if not using_infer_string:
  330:             assert np.shares_memory(merged["d"]._values, right["d"]._values)
  331: 
  332:     def test_intelligently_handle_join_key(self):
  333:         # #733, be a bit more 1337 about not returning unconsolidated DataFrame
  334: 
  335:         left = DataFrame(
  336:             {"key": [1, 1, 2, 2, 3], "value": list(range(5))}, columns=["value", "key"]
  337:         )
  338:         right = DataFrame({"key": [1, 1, 2, 3, 4, 5], "rvalue": list(range(6))})
  339: 
  340:         joined = merge(left, right, on="key", how="outer")
  341:         expected = DataFrame(
  342:             {
  343:                 "key": [1, 1, 1, 1, 2, 2, 3, 4, 5],
  344:                 "value": np.array([0, 0, 1, 1, 2, 3, 4, np.nan, np.nan]),
  345:                 "rvalue": [0, 1, 0, 1, 2, 2, 3, 4, 5],
  346:             },
  347:             columns=["value", "key", "rvalue"],
  348:         )
  349:         tm.assert_frame_equal(joined, expected)
  350: 
  351:     def test_merge_join_key_dtype_cast(self):
  352:         # #8596
  353: 
  354:         df1 = DataFrame({"key": [1], "v1": [10]})
  355:         df2 = DataFrame({"key": [2], "v1": [20]})
  356:         df = merge(df1, df2, how="outer")
  357:         assert df["key"].dtype == "int64"
  358: 
  359:         df1 = DataFrame({"key": [True], "v1": [1]})
  360:         df2 = DataFrame({"key": [False], "v1": [0]})
  361:         df = merge(df1, df2, how="outer")
  362: 
  363:         # GH13169
  364:         # GH#40073
  365:         assert df["key"].dtype == "bool"
  366: 
  367:         df1 = DataFrame({"val": [1]})
  368:         df2 = DataFrame({"val": [2]})
  369:         lkey = np.array([1])
  370:         rkey = np.array([2])
  371:         df = merge(df1, df2, left_on=lkey, right_on=rkey, how="outer")
  372:         assert df["key_0"].dtype == np.dtype(int)
  373: 
  374:     def test_handle_join_key_pass_array(self):
  375:         left = DataFrame(
  376:             {"key": [1, 1, 2, 2, 3], "value": np.arange(5)},
  377:             columns=["value", "key"],
  378:             dtype="int64",
  379:         )
  380:         right = DataFrame({"rvalue": np.arange(6)}, dtype="int64")
  381:         key = np.array([1, 1, 2, 3, 4, 5], dtype="int64")
  382: 
  383:         merged = merge(left, right, left_on="key", right_on=key, how="outer")
  384:         merged2 = merge(right, left, left_on=key, right_on="key", how="outer")
  385: 
  386:         tm.assert_series_equal(merged["key"], merged2["key"])
  387:         assert merged["key"].notna().all()
  388:         assert merged2["key"].notna().all()
  389: 
  390:         left = DataFrame({"value": np.arange(5)}, columns=["value"])
  391:         right = DataFrame({"rvalue": np.arange(6)})
  392:         lkey = np.array([1, 1, 2, 2, 3])
  393:         rkey = np.array([1, 1, 2, 3, 4, 5])
  394: 
  395:         merged = merge(left, right, left_on=lkey, right_on=rkey, how="outer")
  396:         expected = Series([1, 1, 1, 1, 2, 2, 3, 4, 5], dtype=int, name="key_0")
  397:         tm.assert_series_equal(merged["key_0"], expected)
  398: 
  399:         left = DataFrame({"value": np.arange(3)})
  400:         right = DataFrame({"rvalue": np.arange(6)})
  401: 
  402:         key = np.array([0, 1, 1, 2, 2, 3], dtype=np.int64)
  403:         merged = merge(left, right, left_index=True, right_on=key, how="outer")
  404:         tm.assert_series_equal(merged["key_0"], Series(key, name="key_0"))
  405: 
  406:     def test_no_overlap_more_informative_error(self):
  407:         dt = datetime.now()
  408:         df1 = DataFrame({"x": ["a"]}, index=[dt])
  409: 
  410:         df2 = DataFrame({"y": ["b", "c"]}, index=[dt, dt])
  411: 
  412:         msg = (
  413:             "No common columns to perform merge on. "
  414:             f"Merge options: left_on={None}, right_on={None}, "
  415:             f"left_index={False}, right_index={False}"
  416:         )
  417: 
  418:         with pytest.raises(MergeError, match=msg):
  419:             merge(df1, df2)
  420: 
  421:     def test_merge_non_unique_indexes(self):
  422:         dt = datetime(2012, 5, 1)
  423:         dt2 = datetime(2012, 5, 2)
  424:         dt3 = datetime(2012, 5, 3)
  425:         dt4 = datetime(2012, 5, 4)
  426: 
  427:         df1 = DataFrame({"x": ["a"]}, index=[dt])
  428:         df2 = DataFrame({"y": ["b", "c"]}, index=[dt, dt])
  429:         _check_merge(df1, df2)
  430: 
  431:         # Not monotonic
  432:         df1 = DataFrame({"x": ["a", "b", "q"]}, index=[dt2, dt, dt4])
  433:         df2 = DataFrame(
  434:             {"y": ["c", "d", "e", "f", "g", "h"]}, index=[dt3, dt3, dt2, dt2, dt, dt]
  435:         )
  436:         _check_merge(df1, df2)
  437: 
  438:         df1 = DataFrame({"x": ["a", "b"]}, index=[dt, dt])
  439:         df2 = DataFrame({"y": ["c", "d"]}, index=[dt, dt])
  440:         _check_merge(df1, df2)
  441: 
  442:     def test_merge_non_unique_index_many_to_many(self):
  443:         dt = datetime(2012, 5, 1)
  444:         dt2 = datetime(2012, 5, 2)
  445:         dt3 = datetime(2012, 5, 3)
  446:         df1 = DataFrame({"x": ["a", "b", "c", "d"]}, index=[dt2, dt2, dt, dt])
  447:         df2 = DataFrame(
  448:             {"y": ["e", "f", "g", " h", "i"]}, index=[dt2, dt2, dt3, dt, dt]
  449:         )
  450:         _check_merge(df1, df2)
  451: 
  452:     def test_left_merge_empty_dataframe(self):
  453:         left = DataFrame({"key": [1], "value": [2]})
  454:         right = DataFrame({"key": []})
  455: 
  456:         result = merge(left, right, on="key", how="left")
  457:         tm.assert_frame_equal(result, left)
  458: 
  459:         result = merge(right, left, on="key", how="right")
  460:         tm.assert_frame_equal(result, left)
  461: 
  462:     @pytest.mark.parametrize("how", ["inner", "left", "right", "outer"])
  463:     def test_merge_empty_dataframe(self, index, how):
  464:         # GH52777
  465:         left = DataFrame([], index=index[:0])
  466:         right = left.copy()
  467: 
  468:         result = left.join(right, how=how)
  469:         tm.assert_frame_equal(result, left)
  470: 
  471:     @pytest.mark.parametrize(
  472:         "kwarg",
  473:         [
  474:             {"left_index": True, "right_index": True},
  475:             {"left_index": True, "right_on": "x"},
  476:             {"left_on": "a", "right_index": True},
  477:             {"left_on": "a", "right_on": "x"},
  478:         ],
  479:     )
  480:     def test_merge_left_empty_right_empty(self, join_type, kwarg):
  481:         # GH 10824
  482:         left = DataFrame(columns=["a", "b", "c"])
  483:         right = DataFrame(columns=["x", "y", "z"])
  484: 
  485:         exp_in = DataFrame(columns=["a", "b", "c", "x", "y", "z"], dtype=object)
  486: 
  487:         result = merge(left, right, how=join_type, **kwarg)
  488:         tm.assert_frame_equal(result, exp_in)
  489: 
  490:     def test_merge_left_empty_right_notempty(self):
  491:         # GH 10824
  492:         left = DataFrame(columns=["a", "b", "c"])
  493:         right = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=["x", "y", "z"])
  494: 
  495:         exp_out = DataFrame(
  496:             {
  497:                 "a": np.array([np.nan] * 3, dtype=object),
  498:                 "b": np.array([np.nan] * 3, dtype=object),
  499:                 "c": np.array([np.nan] * 3, dtype=object),
  500:                 "x": [1, 4, 7],
  501:                 "y": [2, 5, 8],
  502:                 "z": [3, 6, 9],
  503:             },
  504:             columns=["a", "b", "c", "x", "y", "z"],
  505:         )
  506:         exp_in = exp_out[0:0]  # make empty DataFrame keeping dtype
  507: 
  508:         def check1(exp, kwarg):
  509:             result = merge(left, right, how="inner", **kwarg)
  510:             tm.assert_frame_equal(result, exp)
  511:             result = merge(left, right, how="left", **kwarg)
  512:             tm.assert_frame_equal(result, exp)
  513: 
  514:         def check2(exp, kwarg):
  515:             result = merge(left, right, how="right", **kwarg)
  516:             tm.assert_frame_equal(result, exp)
  517:             result = merge(left, right, how="outer", **kwarg)
  518:             tm.assert_frame_equal(result, exp)
  519: 
  520:         for kwarg in [
  521:             {"left_index": True, "right_index": True},
  522:             {"left_index": True, "right_on": "x"},
  523:         ]:
  524:             check1(exp_in, kwarg)
  525:             check2(exp_out, kwarg)
  526: 
  527:         kwarg = {"left_on": "a", "right_index": True}
  528:         check1(exp_in, kwarg)
  529:         exp_out["a"] = [0, 1, 2]
  530:         check2(exp_out, kwarg)
  531: 
  532:         kwarg = {"left_on": "a", "right_on": "x"}
  533:         check1(exp_in, kwarg)
  534:         exp_out["a"] = np.array([np.nan] * 3, dtype=object)
  535:         check2(exp_out, kwarg)
  536: 
  537:     def test_merge_left_notempty_right_empty(self):
  538:         # GH 10824
  539:         left = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=["a", "b", "c"])
  540:         right = DataFrame(columns=["x", "y", "z"])
  541: 
  542:         exp_out = DataFrame(
  543:             {
  544:                 "a": [1, 4, 7],
  545:                 "b": [2, 5, 8],
  546:                 "c": [3, 6, 9],
  547:                 "x": np.array([np.nan] * 3, dtype=object),
  548:                 "y": np.array([np.nan] * 3, dtype=object),
  549:                 "z": np.array([np.nan] * 3, dtype=object),
  550:             },
  551:             columns=["a", "b", "c", "x", "y", "z"],
  552:         )
  553:         exp_in = exp_out[0:0]  # make empty DataFrame keeping dtype
  554:         # result will have object dtype
  555:         exp_in.index = exp_in.index.astype(object)
  556: 
  557:         def check1(exp, kwarg):
  558:             result = merge(left, right, how="inner", **kwarg)
  559:             tm.assert_frame_equal(result, exp)
  560:             result = merge(left, right, how="right", **kwarg)
  561:             tm.assert_frame_equal(result, exp)
  562: 
  563:         def check2(exp, kwarg):
  564:             result = merge(left, right, how="left", **kwarg)
  565:             tm.assert_frame_equal(result, exp)
  566:             result = merge(left, right, how="outer", **kwarg)
  567:             tm.assert_frame_equal(result, exp)
  568: 
  569:             # TODO: should the next loop be un-indented? doing so breaks this test
  570:             for kwarg in [
  571:                 {"left_index": True, "right_index": True},
  572:                 {"left_index": True, "right_on": "x"},
  573:                 {"left_on": "a", "right_index": True},
  574:                 {"left_on": "a", "right_on": "x"},
  575:             ]:
  576:                 check1(exp_in, kwarg)
  577:                 check2(exp_out, kwarg)
  578: 
  579:     def test_merge_empty_frame(self, series_of_dtype, series_of_dtype2):
  580:         # GH 25183
  581:         df = DataFrame(
  582:             {"key": series_of_dtype, "value": series_of_dtype2},
  583:             columns=["key", "value"],
  584:         )
  585:         df_empty = df[:0]
  586:         expected = DataFrame(
  587:             {
  588:                 "key": Series(dtype=df.dtypes["key"]),
  589:                 "value_x": Series(dtype=df.dtypes["value"]),
  590:                 "value_y": Series(dtype=df.dtypes["value"]),
  591:             },
  592:             columns=["key", "value_x", "value_y"],
  593:         )
  594:         actual = df_empty.merge(df, on="key")
  595:         tm.assert_frame_equal(actual, expected)
  596: 
  597:     def test_merge_all_na_column(self, series_of_dtype, series_of_dtype_all_na):
  598:         # GH 25183
  599:         df_left = DataFrame(
  600:             {"key": series_of_dtype, "value": series_of_dtype_all_na},
  601:             columns=["key", "value"],
  602:         )
  603:         df_right = DataFrame(
  604:             {"key": series_of_dtype, "value": series_of_dtype_all_na},
  605:             columns=["key", "value"],
  606:         )
  607:         expected = DataFrame(
  608:             {
  609:                 "key": series_of_dtype,
  610:                 "value_x": series_of_dtype_all_na,
  611:                 "value_y": series_of_dtype_all_na,
  612:             },
  613:             columns=["key", "value_x", "value_y"],
  614:         )
  615:         actual = df_left.merge(df_right, on="key")
  616:         tm.assert_frame_equal(actual, expected)
  617: 
  618:     def test_merge_nosort(self):
  619:         # GH#2098
  620: 
  621:         d = {
  622:             "var1": np.random.default_rng(2).integers(0, 10, size=10),
  623:             "var2": np.random.default_rng(2).integers(0, 10, size=10),
  624:             "var3": [
  625:                 datetime(2012, 1, 12),
  626:                 datetime(2011, 2, 4),
  627:                 datetime(2010, 2, 3),
  628:                 datetime(2012, 1, 12),
  629:                 datetime(2011, 2, 4),
  630:                 datetime(2012, 4, 3),
  631:                 datetime(2012, 3, 4),
  632:                 datetime(2008, 5, 1),
  633:                 datetime(2010, 2, 3),
  634:                 datetime(2012, 2, 3),
  635:             ],
  636:         }
  637:         df = DataFrame.from_dict(d)
  638:         var3 = df.var3.unique()
  639:         var3 = np.sort(var3)
  640:         new = DataFrame.from_dict(
  641:             {"var3": var3, "var8": np.random.default_rng(2).random(7)}
  642:         )
  643: 
  644:         result = df.merge(new, on="var3", sort=False)
  645:         exp = merge(df, new, on="var3", sort=False)
  646:         tm.assert_frame_equal(result, exp)
  647: 
  648:         assert (df.var3.unique() == result.var3.unique()).all()
  649: 
  650:     @pytest.mark.parametrize(
  651:         ("sort", "values"), [(False, [1, 1, 0, 1, 1]), (True, [0, 1, 1, 1, 1])]
  652:     )
  653:     @pytest.mark.parametrize("how", ["left", "right"])
  654:     def test_merge_same_order_left_right(self, sort, values, how):
  655:         # GH#35382
  656:         df = DataFrame({"a": [1, 0, 1]})
  657: 
  658:         result = df.merge(df, on="a", how=how, sort=sort)
  659:         expected = DataFrame(values, columns=["a"])
  660:         tm.assert_frame_equal(result, expected)
  661: 
  662:     def test_merge_nan_right(self):
  663:         df1 = DataFrame({"i1": [0, 1], "i2": [0, 1]})
  664:         df2 = DataFrame({"i1": [0], "i3": [0]})
  665:         result = df1.join(df2, on="i1", rsuffix="_")
  666:         expected = (
  667:             DataFrame(
  668:                 {
  669:                     "i1": {0: 0.0, 1: 1},
  670:                     "i2": {0: 0, 1: 1},
  671:                     "i1_": {0: 0, 1: np.nan},
  672:                     "i3": {0: 0.0, 1: np.nan},
  673:                     None: {0: 0, 1: 0},
  674:                 },
  675:                 columns=Index(["i1", "i2", "i1_", "i3", None], dtype=object),
  676:             )
  677:             .set_index(None)
  678:             .reset_index()[["i1", "i2", "i1_", "i3"]]
  679:         )
  680:         result.columns = result.columns.astype("object")
  681:         tm.assert_frame_equal(result, expected, check_dtype=False)
  682: 
  683:     def test_merge_nan_right2(self):
  684:         df1 = DataFrame({"i1": [0, 1], "i2": [0.5, 1.5]})
  685:         df2 = DataFrame({"i1": [0], "i3": [0.7]})
  686:         result = df1.join(df2, rsuffix="_", on="i1")
  687:         expected = DataFrame(
  688:             {
  689:                 "i1": {0: 0, 1: 1},
  690:                 "i1_": {0: 0.0, 1: np.nan},
  691:                 "i2": {0: 0.5, 1: 1.5},
  692:                 "i3": {0: 0.69999999999999996, 1: np.nan},
  693:             }
  694:         )[["i1", "i2", "i1_", "i3"]]
  695:         tm.assert_frame_equal(result, expected)
  696: 
  697:     @pytest.mark.filterwarnings(
  698:         "ignore:Passing a BlockManager|Passing a SingleBlockManager:DeprecationWarning"
  699:     )
  700:     def test_merge_type(self, df, df2):
  701:         class NotADataFrame(DataFrame):
  702:             @property
  703:             def _constructor(self):
  704:                 return NotADataFrame
  705: 
  706:         nad = NotADataFrame(df)
  707:         result = nad.merge(df2, on="key1")
  708: 
  709:         assert isinstance(result, NotADataFrame)
  710: 
  711:     def test_join_append_timedeltas(self, using_array_manager):
  712:         # timedelta64 issues with join/merge
  713:         # GH 5695
  714: 
  715:         d = DataFrame.from_dict(
  716:             {"d": [datetime(2013, 11, 5, 5, 56)], "t": [timedelta(0, 22500)]}
  717:         )
  718:         df = DataFrame(columns=list("dt"))
  719:         msg = "The behavior of DataFrame concatenation with empty or all-NA entries"
  720:         warn = FutureWarning
  721:         if using_array_manager:
  722:             warn = None
  723:         with tm.assert_produces_warning(warn, match=msg):
  724:             df = concat([df, d], ignore_index=True)
  725:             result = concat([df, d], ignore_index=True)
  726:         expected = DataFrame(
  727:             {
  728:                 "d": [datetime(2013, 11, 5, 5, 56), datetime(2013, 11, 5, 5, 56)],
  729:                 "t": [timedelta(0, 22500), timedelta(0, 22500)],
  730:             }
  731:         )
  732:         if using_array_manager:
  733:             # TODO(ArrayManager) decide on exact casting rules in concat
  734:             expected = expected.astype(object)
  735:         tm.assert_frame_equal(result, expected)
  736: 
  737:     def test_join_append_timedeltas2(self):
  738:         # timedelta64 issues with join/merge
  739:         # GH 5695
  740:         td = np.timedelta64(300000000)
  741:         lhs = DataFrame(Series([td, td], index=["A", "B"]))
  742:         rhs = DataFrame(Series([td], index=["A"]))
  743: 
  744:         result = lhs.join(rhs, rsuffix="r", how="left")
  745:         expected = DataFrame(
  746:             {
  747:                 "0": Series([td, td], index=list("AB")),
  748:                 "0r": Series([td, pd.NaT], index=list("AB")),
  749:             }
  750:         )
  751:         tm.assert_frame_equal(result, expected)
  752: 
  753:     @pytest.mark.parametrize("unit", ["D", "h", "m", "s", "ms", "us", "ns"])
  754:     def test_other_datetime_unit(self, unit):
  755:         # GH 13389
  756:         df1 = DataFrame({"entity_id": [101, 102]})
  757:         ser = Series([None, None], index=[101, 102], name="days")
  758: 
  759:         dtype = f"datetime64[{unit}]"
  760: 
  761:         if unit in ["D", "h", "m"]:
  762:             # not supported so we cast to the nearest supported unit, seconds
  763:             exp_dtype = "datetime64[s]"
  764:         else:
  765:             exp_dtype = dtype
  766:         df2 = ser.astype(exp_dtype).to_frame("days")
  767:         assert df2["days"].dtype == exp_dtype
  768: 
  769:         result = df1.merge(df2, left_on="entity_id", right_index=True)
  770: 
  771:         days = np.array(["nat", "nat"], dtype=exp_dtype)
  772:         days = pd.core.arrays.DatetimeArray._simple_new(days, dtype=days.dtype)
  773:         exp = DataFrame(
  774:             {
  775:                 "entity_id": [101, 102],
  776:                 "days": days,
  777:             },
  778:             columns=["entity_id", "days"],
  779:         )
  780:         assert exp["days"].dtype == exp_dtype
  781:         tm.assert_frame_equal(result, exp)
  782: 
  783:     @pytest.mark.parametrize("unit", ["D", "h", "m", "s", "ms", "us", "ns"])
  784:     def test_other_timedelta_unit(self, unit):
  785:         # GH 13389
  786:         df1 = DataFrame({"entity_id": [101, 102]})
  787:         ser = Series([None, None], index=[101, 102], name="days")
  788: 
  789:         dtype = f"m8[{unit}]"
  790:         if unit in ["D", "h", "m"]:
  791:             # We cannot astype, instead do nearest supported unit, i.e. "s"
  792:             msg = "Supported resolutions are 's', 'ms', 'us', 'ns'"
  793:             with pytest.raises(ValueError, match=msg):
  794:                 ser.astype(dtype)
  795: 
  796:             df2 = ser.astype("m8[s]").to_frame("days")
  797:         else:
  798:             df2 = ser.astype(dtype).to_frame("days")
  799:             assert df2["days"].dtype == dtype
  800: 
  801:         result = df1.merge(df2, left_on="entity_id", right_index=True)
  802: 
  803:         exp = DataFrame(
  804:             {"entity_id": [101, 102], "days": np.array(["nat", "nat"], dtype=dtype)},
  805:             columns=["entity_id", "days"],
  806:         )
  807:         tm.assert_frame_equal(result, exp)
  808: 
  809:     def test_overlapping_columns_error_message(self):
  810:         df = DataFrame({"key": [1, 2, 3], "v1": [4, 5, 6], "v2": [7, 8, 9]})
  811:         df2 = DataFrame({"key": [1, 2, 3], "v1": [4, 5, 6], "v2": [7, 8, 9]})
  812: 
  813:         df.columns = ["key", "foo", "foo"]
  814:         df2.columns = ["key", "bar", "bar"]
  815:         expected = DataFrame(
  816:             {
  817:                 "key": [1, 2, 3],
  818:                 "v1": [4, 5, 6],
  819:                 "v2": [7, 8, 9],
  820:                 "v3": [4, 5, 6],
  821:                 "v4": [7, 8, 9],
  822:             }
  823:         )
  824:         expected.columns = ["key", "foo", "foo", "bar", "bar"]
  825:         tm.assert_frame_equal(merge(df, df2), expected)
  826: 
  827:         # #2649, #10639
  828:         df2.columns = ["key1", "foo", "foo"]
  829:         msg = r"Data columns not unique: Index\(\['foo'\], dtype='object|string'\)"
  830:         with pytest.raises(MergeError, match=msg):
  831:             merge(df, df2)
  832: 
  833:     def test_merge_on_datetime64tz(self):
  834:         # GH11405
  835:         left = DataFrame(
  836:             {
  837:                 "key": pd.date_range("20151010", periods=2, tz="US/Eastern"),
  838:                 "value": [1, 2],
  839:             }
  840:         )
  841:         right = DataFrame(
  842:             {
  843:                 "key": pd.date_range("20151011", periods=3, tz="US/Eastern"),
  844:                 "value": [1, 2, 3],
  845:             }
  846:         )
  847: 
  848:         expected = DataFrame(
  849:             {
  850:                 "key": pd.date_range("20151010", periods=4, tz="US/Eastern"),
  851:                 "value_x": [1, 2, np.nan, np.nan],
  852:                 "value_y": [np.nan, 1, 2, 3],
  853:             }
  854:         )
  855:         result = merge(left, right, on="key", how="outer")
  856:         tm.assert_frame_equal(result, expected)
  857: 
  858:     def test_merge_datetime64tz_values(self):
  859:         left = DataFrame(
  860:             {
  861:                 "key": [1, 2],
  862:                 "value": pd.date_range("20151010", periods=2, tz="US/Eastern"),
  863:             }
  864:         )
  865:         right = DataFrame(
  866:             {
  867:                 "key": [2, 3],
  868:                 "value": pd.date_range("20151011", periods=2, tz="US/Eastern"),
  869:             }
  870:         )
  871:         expected = DataFrame(
  872:             {
  873:                 "key": [1, 2, 3],
  874:                 "value_x": list(pd.date_range("20151010", periods=2, tz="US/Eastern"))
  875:                 + [pd.NaT],
  876:                 "value_y": [pd.NaT]
  877:                 + list(pd.date_range("20151011", periods=2, tz="US/Eastern")),
  878:             }
  879:         )
  880:         result = merge(left, right, on="key", how="outer")
  881:         tm.assert_frame_equal(result, expected)
  882:         assert result["value_x"].dtype == "datetime64[ns, US/Eastern]"
  883:         assert result["value_y"].dtype == "datetime64[ns, US/Eastern]"
  884: 
  885:     def test_merge_on_datetime64tz_empty(self):
  886:         # https://github.com/pandas-dev/pandas/issues/25014
  887:         dtz = pd.DatetimeTZDtype(tz="UTC")
  888:         right = DataFrame(
  889:             {
  890:                 "date": DatetimeIndex(["2018"], dtype=dtz),
  891:                 "value": [4.0],
  892:                 "date2": DatetimeIndex(["2019"], dtype=dtz),
  893:             },
  894:             columns=["date", "value", "date2"],
  895:         )
  896:         left = right[:0]
  897:         result = left.merge(right, on="date")
  898:         expected = DataFrame(
  899:             {
  900:                 "date": Series(dtype=dtz),
  901:                 "value_x": Series(dtype=float),
  902:                 "date2_x": Series(dtype=dtz),
  903:                 "value_y": Series(dtype=float),
  904:                 "date2_y": Series(dtype=dtz),
  905:             },
  906:             columns=["date", "value_x", "date2_x", "value_y", "date2_y"],
  907:         )
  908:         tm.assert_frame_equal(result, expected)
  909: 
  910:     def test_merge_datetime64tz_with_dst_transition(self):
  911:         # GH 18885
  912:         df1 = DataFrame(
  913:             pd.date_range("2017-10-29 01:00", periods=4, freq="h", tz="Europe/Madrid"),
  914:             columns=["date"],
  915:         )
  916:         df1["value"] = 1
  917:         df2 = DataFrame(
  918:             {
  919:                 "date": pd.to_datetime(
  920:                     [
  921:                         "2017-10-29 03:00:00",
  922:                         "2017-10-29 04:00:00",
  923:                         "2017-10-29 05:00:00",
  924:                     ]
  925:                 ),
  926:                 "value": 2,
  927:             }
  928:         )
  929:         df2["date"] = df2["date"].dt.tz_localize("UTC").dt.tz_convert("Europe/Madrid")
  930:         result = merge(df1, df2, how="outer", on="date")
  931:         expected = DataFrame(
  932:             {
  933:                 "date": pd.date_range(
  934:                     "2017-10-29 01:00", periods=7, freq="h", tz="Europe/Madrid"
  935:                 ),
  936:                 "value_x": [1] * 4 + [np.nan] * 3,
  937:                 "value_y": [np.nan] * 4 + [2] * 3,
  938:             }
  939:         )
  940:         tm.assert_frame_equal(result, expected)
  941: 
  942:     def test_merge_non_unique_period_index(self):
  943:         # GH #16871
  944:         index = pd.period_range("2016-01-01", periods=16, freq="M")
  945:         df = DataFrame(list(range(len(index))), index=index, columns=["pnum"])
  946:         df2 = concat([df, df])
  947:         result = df.merge(df2, left_index=True, right_index=True, how="inner")
  948:         expected = DataFrame(
  949:             np.tile(np.arange(16, dtype=np.int64).repeat(2).reshape(-1, 1), 2),
  950:             columns=["pnum_x", "pnum_y"],
  951:             index=df2.sort_index().index,
  952:         )
  953:         tm.assert_frame_equal(result, expected)
  954: 
  955:     def test_merge_on_periods(self):
  956:         left = DataFrame(
  957:             {"key": pd.period_range("20151010", periods=2, freq="D"), "value": [1, 2]}
  958:         )
  959:         right = DataFrame(
  960:             {
  961:                 "key": pd.period_range("20151011", periods=3, freq="D"),
  962:                 "value": [1, 2, 3],
  963:             }
  964:         )
  965: 
  966:         expected = DataFrame(
  967:             {
  968:                 "key": pd.period_range("20151010", periods=4, freq="D"),
  969:                 "value_x": [1, 2, np.nan, np.nan],
  970:                 "value_y": [np.nan, 1, 2, 3],
  971:             }
  972:         )
  973:         result = merge(left, right, on="key", how="outer")
  974:         tm.assert_frame_equal(result, expected)
  975: 
  976:     def test_merge_period_values(self):
  977:         left = DataFrame(
  978:             {"key": [1, 2], "value": pd.period_range("20151010", periods=2, freq="D")}
  979:         )
  980:         right = DataFrame(
  981:             {"key": [2, 3], "value": pd.period_range("20151011", periods=2, freq="D")}
  982:         )
  983: 
  984:         exp_x = pd.period_range("20151010", periods=2, freq="D")
  985:         exp_y = pd.period_range("20151011", periods=2, freq="D")
  986:         expected = DataFrame(
  987:             {
  988:                 "key": [1, 2, 3],
  989:                 "value_x": list(exp_x) + [pd.NaT],
  990:                 "value_y": [pd.NaT] + list(exp_y),
  991:             }
  992:         )
  993:         result = merge(left, right, on="key", how="outer")
  994:         tm.assert_frame_equal(result, expected)
  995:         assert result["value_x"].dtype == "Period[D]"
  996:         assert result["value_y"].dtype == "Period[D]"
  997: 
  998:     def test_indicator(self, dfs_for_indicator):
  999:         # PR #10054. xref #7412 and closes #8790.
 1000:         df1, df2 = dfs_for_indicator
 1001:         df1_copy = df1.copy()
 1002: 
 1003:         df2_copy = df2.copy()
 1004: 
 1005:         df_result = DataFrame(
 1006:             {
 1007:                 "col1": [0, 1, 2, 3, 4, 5],
 1008:                 "col_conflict_x": [1, 2, np.nan, np.nan, np.nan, np.nan],
 1009:                 "col_left": ["a", "b", np.nan, np.nan, np.nan, np.nan],
 1010:                 "col_conflict_y": [np.nan, 1, 2, 3, 4, 5],
 1011:                 "col_right": [np.nan, 2, 2, 2, 2, 2],
 1012:             }
 1013:         )
 1014:         df_result["_merge"] = Categorical(
 1015:             [
 1016:                 "left_only",
 1017:                 "both",
 1018:                 "right_only",
 1019:                 "right_only",
 1020:                 "right_only",
 1021:                 "right_only",
 1022:             ],
 1023:             categories=["left_only", "right_only", "both"],
 1024:         )
 1025: 
 1026:         df_result = df_result[
 1027:             [
 1028:                 "col1",
 1029:                 "col_conflict_x",
 1030:                 "col_left",
 1031:                 "col_conflict_y",
 1032:                 "col_right",
 1033:                 "_merge",
 1034:             ]
 1035:         ]
 1036: 
 1037:         test = merge(df1, df2, on="col1", how="outer", indicator=True)
 1038:         tm.assert_frame_equal(test, df_result)
 1039:         test = df1.merge(df2, on="col1", how="outer", indicator=True)
 1040:         tm.assert_frame_equal(test, df_result)
 1041: 
 1042:         # No side effects
 1043:         tm.assert_frame_equal(df1, df1_copy)
 1044:         tm.assert_frame_equal(df2, df2_copy)
 1045: 
 1046:         # Check with custom name
 1047:         df_result_custom_name = df_result
 1048:         df_result_custom_name = df_result_custom_name.rename(
 1049:             columns={"_merge": "custom_name"}
 1050:         )
 1051: 
 1052:         test_custom_name = merge(
 1053:             df1, df2, on="col1", how="outer", indicator="custom_name"
 1054:         )
 1055:         tm.assert_frame_equal(test_custom_name, df_result_custom_name)
 1056:         test_custom_name = df1.merge(
 1057:             df2, on="col1", how="outer", indicator="custom_name"
 1058:         )
 1059:         tm.assert_frame_equal(test_custom_name, df_result_custom_name)
 1060: 
 1061:     def test_merge_indicator_arg_validation(self, dfs_for_indicator):
 1062:         # Check only accepts strings and booleans
 1063:         df1, df2 = dfs_for_indicator
 1064: 
 1065:         msg = "indicator option can only accept boolean or string arguments"
 1066:         with pytest.raises(ValueError, match=msg):
 1067:             merge(df1, df2, on="col1", how="outer", indicator=5)
 1068:         with pytest.raises(ValueError, match=msg):
 1069:             df1.merge(df2, on="col1", how="outer", indicator=5)
 1070: 
 1071:     def test_merge_indicator_result_integrity(self, dfs_for_indicator):
 1072:         # Check result integrity
 1073:         df1, df2 = dfs_for_indicator
 1074: 
 1075:         test2 = merge(df1, df2, on="col1", how="left", indicator=True)
 1076:         assert (test2._merge != "right_only").all()
 1077:         test2 = df1.merge(df2, on="col1", how="left", indicator=True)
 1078:         assert (test2._merge != "right_only").all()
 1079: 
 1080:         test3 = merge(df1, df2, on="col1", how="right", indicator=True)
 1081:         assert (test3._merge != "left_only").all()
 1082:         test3 = df1.merge(df2, on="col1", how="right", indicator=True)
 1083:         assert (test3._merge != "left_only").all()
 1084: 
 1085:         test4 = merge(df1, df2, on="col1", how="inner", indicator=True)
 1086:         assert (test4._merge == "both").all()
 1087:         test4 = df1.merge(df2, on="col1", how="inner", indicator=True)
 1088:         assert (test4._merge == "both").all()
 1089: 
 1090:     def test_merge_indicator_invalid(self, dfs_for_indicator):
 1091:         # Check if working name in df
 1092:         df1, _ = dfs_for_indicator
 1093: 
 1094:         for i in ["_right_indicator", "_left_indicator", "_merge"]:
 1095:             df_badcolumn = DataFrame({"col1": [1, 2], i: [2, 2]})
 1096: 
 1097:             msg = (
 1098:                 "Cannot use `indicator=True` option when data contains a "
 1099:                 f"column named {i}|"
 1100:                 "Cannot use name of an existing column for indicator column"
 1101:             )
 1102:             with pytest.raises(ValueError, match=msg):
 1103:                 merge(df1, df_badcolumn, on="col1", how="outer", indicator=True)
 1104:             with pytest.raises(ValueError, match=msg):
 1105:                 df1.merge(df_badcolumn, on="col1", how="outer", indicator=True)
 1106: 
 1107:         # Check for name conflict with custom name
 1108:         df_badcolumn = DataFrame({"col1": [1, 2], "custom_column_name": [2, 2]})
 1109: 
 1110:         msg = "Cannot use name of an existing column for indicator column"
 1111:         with pytest.raises(ValueError, match=msg):
 1112:             merge(
 1113:                 df1,
 1114:                 df_badcolumn,
 1115:                 on="col1",
 1116:                 how="outer",
 1117:                 indicator="custom_column_name",
 1118:             )
 1119:         with pytest.raises(ValueError, match=msg):
 1120:             df1.merge(
 1121:                 df_badcolumn, on="col1", how="outer", indicator="custom_column_name"
 1122:             )
 1123: 
 1124:     def test_merge_indicator_multiple_columns(self):
 1125:         # Merge on multiple columns
 1126:         df3 = DataFrame({"col1": [0, 1], "col2": ["a", "b"]})
 1127: 
 1128:         df4 = DataFrame({"col1": [1, 1, 3], "col2": ["b", "x", "y"]})
 1129: 
 1130:         hand_coded_result = DataFrame(
 1131:             {"col1": [0, 1, 1, 3], "col2": ["a", "b", "x", "y"]}
 1132:         )
 1133:         hand_coded_result["_merge"] = Categorical(
 1134:             ["left_only", "both", "right_only", "right_only"],
 1135:             categories=["left_only", "right_only", "both"],
 1136:         )
 1137: 
 1138:         test5 = merge(df3, df4, on=["col1", "col2"], how="outer", indicator=True)
 1139:         tm.assert_frame_equal(test5, hand_coded_result)
 1140:         test5 = df3.merge(df4, on=["col1", "col2"], how="outer", indicator=True)
 1141:         tm.assert_frame_equal(test5, hand_coded_result)
 1142: 
 1143:     def test_validation(self):
 1144:         left = DataFrame(
 1145:             {"a": ["a", "b", "c", "d"], "b": ["cat", "dog", "weasel", "horse"]},
 1146:             index=range(4),
 1147:         )
 1148: 
 1149:         right = DataFrame(
 1150:             {
 1151:                 "a": ["a", "b", "c", "d", "e"],
 1152:                 "c": ["meow", "bark", "um... weasel noise?", "nay", "chirp"],
 1153:             },
 1154:             index=range(5),
 1155:         )
 1156: 
 1157:         # Make sure no side effects.
 1158:         left_copy = left.copy()
 1159:         right_copy = right.copy()
 1160: 
 1161:         result = merge(left, right, left_index=True, right_index=True, validate="1:1")
 1162:         tm.assert_frame_equal(left, left_copy)
 1163:         tm.assert_frame_equal(right, right_copy)
 1164: 
 1165:         # make sure merge still correct
 1166:         expected = DataFrame(
 1167:             {
 1168:                 "a_x": ["a", "b", "c", "d"],
 1169:                 "b": ["cat", "dog", "weasel", "horse"],
 1170:                 "a_y": ["a", "b", "c", "d"],
 1171:                 "c": ["meow", "bark", "um... weasel noise?", "nay"],
 1172:             },
 1173:             index=range(4),
 1174:             columns=["a_x", "b", "a_y", "c"],
 1175:         )
 1176: 
 1177:         result = merge(
 1178:             left, right, left_index=True, right_index=True, validate="one_to_one"
 1179:         )
 1180:         tm.assert_frame_equal(result, expected)
 1181: 
 1182:         expected_2 = DataFrame(
 1183:             {
 1184:                 "a": ["a", "b", "c", "d"],
 1185:                 "b": ["cat", "dog", "weasel", "horse"],
 1186:                 "c": ["meow", "bark", "um... weasel noise?", "nay"],
 1187:             },
 1188:             index=range(4),
 1189:         )
 1190: 
 1191:         result = merge(left, right, on="a", validate="1:1")
 1192:         tm.assert_frame_equal(left, left_copy)
 1193:         tm.assert_frame_equal(right, right_copy)
 1194:         tm.assert_frame_equal(result, expected_2)
 1195: 
 1196:         result = merge(left, right, on="a", validate="one_to_one")
 1197:         tm.assert_frame_equal(result, expected_2)
 1198: 
 1199:         # One index, one column
 1200:         expected_3 = DataFrame(
 1201:             {
 1202:                 "b": ["cat", "dog", "weasel", "horse"],
 1203:                 "a": ["a", "b", "c", "d"],
 1204:                 "c": ["meow", "bark", "um... weasel noise?", "nay"],
 1205:             },
 1206:             columns=["b", "a", "c"],
 1207:             index=range(4),
 1208:         )
 1209: 
 1210:         left_index_reset = left.set_index("a")
 1211:         result = merge(
 1212:             left_index_reset,
 1213:             right,
 1214:             left_index=True,
 1215:             right_on="a",
 1216:             validate="one_to_one",
 1217:         )
 1218:         tm.assert_frame_equal(result, expected_3)
 1219: 
 1220:         # Dups on right
 1221:         right_w_dups = concat([right, DataFrame({"a": ["e"], "c": ["moo"]}, index=[4])])
 1222:         merge(
 1223:             left,
 1224:             right_w_dups,
 1225:             left_index=True,
 1226:             right_index=True,
 1227:             validate="one_to_many",
 1228:         )
 1229: 
 1230:         msg = "Merge keys are not unique in right dataset; not a one-to-one merge"
 1231:         with pytest.raises(MergeError, match=msg):
 1232:             merge(
 1233:                 left,
 1234:                 right_w_dups,
 1235:                 left_index=True,
 1236:                 right_index=True,
 1237:                 validate="one_to_one",
 1238:             )
 1239: 
 1240:         with pytest.raises(MergeError, match=msg):
 1241:             merge(left, right_w_dups, on="a", validate="one_to_one")
 1242: 
 1243:         # Dups on left
 1244:         left_w_dups = concat(
 1245:             [left, DataFrame({"a": ["a"], "c": ["cow"]}, index=[3])], sort=True
 1246:         )
 1247:         merge(
 1248:             left_w_dups,
 1249:             right,
 1250:             left_index=True,
 1251:             right_index=True,
 1252:             validate="many_to_one",
 1253:         )
 1254: 
 1255:         msg = "Merge keys are not unique in left dataset; not a one-to-one merge"
 1256:         with pytest.raises(MergeError, match=msg):
 1257:             merge(
 1258:                 left_w_dups,
 1259:                 right,
 1260:                 left_index=True,
 1261:                 right_index=True,
 1262:                 validate="one_to_one",
 1263:             )
 1264: 
 1265:         with pytest.raises(MergeError, match=msg):
 1266:             merge(left_w_dups, right, on="a", validate="one_to_one")
 1267: 
 1268:         # Dups on both
 1269:         merge(left_w_dups, right_w_dups, on="a", validate="many_to_many")
 1270: 
 1271:         msg = "Merge keys are not unique in right dataset; not a many-to-one merge"
 1272:         with pytest.raises(MergeError, match=msg):
 1273:             merge(
 1274:                 left_w_dups,
 1275:                 right_w_dups,
 1276:                 left_index=True,
 1277:                 right_index=True,
 1278:                 validate="many_to_one",
 1279:             )
 1280: 
 1281:         msg = "Merge keys are not unique in left dataset; not a one-to-many merge"
 1282:         with pytest.raises(MergeError, match=msg):
 1283:             merge(left_w_dups, right_w_dups, on="a", validate="one_to_many")
 1284: 
 1285:         # Check invalid arguments
 1286:         msg = (
 1287:             '"jibberish" is not a valid argument. '
 1288:             "Valid arguments are:\n"
 1289:             '- "1:1"\n'
 1290:             '- "1:m"\n'
 1291:             '- "m:1"\n'
 1292:             '- "m:m"\n'
 1293:             '- "one_to_one"\n'
 1294:             '- "one_to_many"\n'
 1295:             '- "many_to_one"\n'
 1296:             '- "many_to_many"'
 1297:         )
 1298:         with pytest.raises(ValueError, match=msg):
 1299:             merge(left, right, on="a", validate="jibberish")
 1300: 
 1301:         # Two column merge, dups in both, but jointly no dups.
 1302:         left = DataFrame(
 1303:             {
 1304:                 "a": ["a", "a", "b", "b"],
 1305:                 "b": [0, 1, 0, 1],
 1306:                 "c": ["cat", "dog", "weasel", "horse"],
 1307:             },
 1308:             index=range(4),
 1309:         )
 1310: 
 1311:         right = DataFrame(
 1312:             {
 1313:                 "a": ["a", "a", "b"],
 1314:                 "b": [0, 1, 0],
 1315:                 "d": ["meow", "bark", "um... weasel noise?"],
 1316:             },
 1317:             index=range(3),
 1318:         )
 1319: 
 1320:         expected_multi = DataFrame(
 1321:             {
 1322:                 "a": ["a", "a", "b"],
 1323:                 "b": [0, 1, 0],
 1324:                 "c": ["cat", "dog", "weasel"],
 1325:                 "d": ["meow", "bark", "um... weasel noise?"],
 1326:             },
 1327:             index=range(3),
 1328:         )
 1329: 
 1330:         msg = (
 1331:             "Merge keys are not unique in either left or right dataset; "
 1332:             "not a one-to-one merge"
 1333:         )
 1334:         with pytest.raises(MergeError, match=msg):
 1335:             merge(left, right, on="a", validate="1:1")
 1336: 
 1337:         result = merge(left, right, on=["a", "b"], validate="1:1")
 1338:         tm.assert_frame_equal(result, expected_multi)
 1339: 
 1340:     def test_merge_two_empty_df_no_division_error(self):
 1341:         # GH17776, PR #17846
 1342:         a = DataFrame({"a": [], "b": [], "c": []})
 1343:         with np.errstate(divide="raise"):
 1344:             merge(a, a, on=("a", "b"))
 1345: 
 1346:     @pytest.mark.parametrize("how", ["right", "outer"])
 1347:     @pytest.mark.parametrize(
 1348:         "index,expected_index",
 1349:         [
 1350:             (
 1351:                 CategoricalIndex([1, 2, 4]),
 1352:                 CategoricalIndex([1, 2, 4, None, None, None]),
 1353:             ),
 1354:             (
 1355:                 DatetimeIndex(
 1356:                     ["2001-01-01", "2002-02-02", "2003-03-03"], dtype="M8[ns]"
 1357:                 ),
 1358:                 DatetimeIndex(
 1359:                     ["2001-01-01", "2002-02-02", "2003-03-03", pd.NaT, pd.NaT, pd.NaT],
 1360:                     dtype="M8[ns]",
 1361:                 ),
 1362:             ),
 1363:             *[
 1364:                 (
 1365:                     Index([1, 2, 3], dtype=dtyp),
 1366:                     Index([1, 2, 3, None, None, None], dtype=np.float64),
 1367:                 )
 1368:                 for dtyp in tm.ALL_REAL_NUMPY_DTYPES
 1369:             ],
 1370:             (
 1371:                 IntervalIndex.from_tuples([(1, 2), (2, 3), (3, 4)]),
 1372:                 IntervalIndex.from_tuples(
 1373:                     [(1, 2), (2, 3), (3, 4), np.nan, np.nan, np.nan]
 1374:                 ),
 1375:             ),
 1376:             (
 1377:                 PeriodIndex(["2001-01-01", "2001-01-02", "2001-01-03"], freq="D"),
 1378:                 PeriodIndex(
 1379:                     ["2001-01-01", "2001-01-02", "2001-01-03", pd.NaT, pd.NaT, pd.NaT],
 1380:                     freq="D",
 1381:                 ),
 1382:             ),
 1383:             (
 1384:                 TimedeltaIndex(["1d", "2d", "3d"]),
 1385:                 TimedeltaIndex(["1d", "2d", "3d", pd.NaT, pd.NaT, pd.NaT]),
 1386:             ),
 1387:         ],
 1388:     )
 1389:     def test_merge_on_index_with_more_values(self, how, index, expected_index):
 1390:         # GH 24212
 1391:         # pd.merge gets [0, 1, 2, -1, -1, -1] as left_indexer, ensure that
 1392:         # -1 is interpreted as a missing value instead of the last element
 1393:         df1 = DataFrame({"a": [0, 1, 2], "key": [0, 1, 2]}, index=index)
 1394:         df2 = DataFrame({"b": [0, 1, 2, 3, 4, 5]})
 1395:         result = df1.merge(df2, left_on="key", right_index=True, how=how)
 1396:         expected = DataFrame(
 1397:             [
 1398:                 [0, 0, 0],
 1399:                 [1, 1, 1],
 1400:                 [2, 2, 2],
 1401:                 [np.nan, 3, 3],
 1402:                 [np.nan, 4, 4],
 1403:                 [np.nan, 5, 5],
 1404:             ],
 1405:             columns=["a", "key", "b"],
 1406:         )
 1407:         expected.set_index(expected_index, inplace=True)
 1408:         tm.assert_frame_equal(result, expected)
 1409: 
 1410:     def test_merge_right_index_right(self):
 1411:         # Note: the expected output here is probably incorrect.
 1412:         # See https://github.com/pandas-dev/pandas/issues/17257 for more.
 1413:         # We include this as a regression test for GH-24897.
 1414:         left = DataFrame({"a": [1, 2, 3], "key": [0, 1, 1]})
 1415:         right = DataFrame({"b": [1, 2, 3]})
 1416: 
 1417:         expected = DataFrame(
 1418:             {"a": [1, 2, 3, None], "key": [0, 1, 1, 2], "b": [1, 2, 2, 3]},
 1419:             columns=["a", "key", "b"],
 1420:             index=[0, 1, 2, np.nan],
 1421:         )
 1422:         result = left.merge(right, left_on="key", right_index=True, how="right")
 1423:         tm.assert_frame_equal(result, expected)
 1424: 
 1425:     @pytest.mark.parametrize("how", ["left", "right"])
 1426:     def test_merge_preserves_row_order(self, how):
 1427:         # GH 27453
 1428:         left_df = DataFrame({"animal": ["dog", "pig"], "max_speed": [40, 11]})
 1429:         right_df = DataFrame({"animal": ["quetzal", "pig"], "max_speed": [80, 11]})
 1430:         result = left_df.merge(right_df, on=["animal", "max_speed"], how=how)
 1431:         if how == "right":
 1432:             expected = DataFrame({"animal": ["quetzal", "pig"], "max_speed": [80, 11]})
 1433:         else:
 1434:             expected = DataFrame({"animal": ["dog", "pig"], "max_speed": [40, 11]})
 1435:         tm.assert_frame_equal(result, expected)
 1436: 
 1437:     def test_merge_take_missing_values_from_index_of_other_dtype(self):
 1438:         # GH 24212
 1439:         left = DataFrame(
 1440:             {
 1441:                 "a": [1, 2, 3],
 1442:                 "key": Categorical(["a", "a", "b"], categories=list("abc")),
 1443:             }
 1444:         )
 1445:         right = DataFrame({"b": [1, 2, 3]}, index=CategoricalIndex(["a", "b", "c"]))
 1446:         result = left.merge(right, left_on="key", right_index=True, how="right")
 1447:         expected = DataFrame(
 1448:             {
 1449:                 "a": [1, 2, 3, None],
 1450:                 "key": Categorical(["a", "a", "b", "c"]),
 1451:                 "b": [1, 1, 2, 3],
 1452:             },
 1453:             index=[0, 1, 2, np.nan],
 1454:         )
 1455:         expected = expected.reindex(columns=["a", "key", "b"])
 1456:         tm.assert_frame_equal(result, expected)
 1457: 
 1458:     def test_merge_readonly(self):
 1459:         # https://github.com/pandas-dev/pandas/issues/27943
 1460:         data1 = DataFrame(
 1461:             np.arange(20).reshape((4, 5)) + 1, columns=["a", "b", "c", "d", "e"]
 1462:         )
 1463:         data2 = DataFrame(
 1464:             np.arange(20).reshape((5, 4)) + 1, columns=["a", "b", "x", "y"]
 1465:         )
 1466: 
 1467:         # make each underlying block array / column array read-only
 1468:         for arr in data1._mgr.arrays:
 1469:             arr.flags.writeable = False
 1470: 
 1471:         data1.merge(data2)  # no error
 1472: 
 1473: 
 1474: def _check_merge(x, y):
 1475:     for how in ["inner", "left", "outer"]:
 1476:         for sort in [True, False]:
 1477:             result = x.join(y, how=how, sort=sort)
 1478: 
 1479:             expected = merge(x.reset_index(), y.reset_index(), how=how, sort=sort)
 1480:             expected = expected.set_index("index")
 1481: 
 1482:             # TODO check_names on merge?
 1483:             tm.assert_frame_equal(result, expected, check_names=False)
 1484: 
 1485: 
 1486: class TestMergeDtypes:
 1487:     @pytest.mark.parametrize(
 1488:         "right_vals", [["foo", "bar"], Series(["foo", "bar"]).astype("category")]
 1489:     )
 1490:     def test_different(self, right_vals):
 1491:         left = DataFrame(
 1492:             {
 1493:                 "A": ["foo", "bar"],
 1494:                 "B": Series(["foo", "bar"]).astype("category"),
 1495:                 "C": [1, 2],
 1496:                 "D": [1.0, 2.0],
 1497:                 "E": Series([1, 2], dtype="uint64"),
 1498:                 "F": Series([1, 2], dtype="int32"),
 1499:             }
 1500:         )
 1501:         right = DataFrame({"A": right_vals})
 1502: 
 1503:         # GH 9780
 1504:         # We allow merging on object and categorical cols and cast
 1505:         # categorical cols to object
 1506:         result = merge(left, right, on="A")
 1507:         assert is_object_dtype(result.A.dtype) or is_string_dtype(result.A.dtype)
 1508: 
 1509:     @pytest.mark.parametrize(
 1510:         "d1", [np.int64, np.int32, np.intc, np.int16, np.int8, np.uint8]
 1511:     )
 1512:     @pytest.mark.parametrize("d2", [np.int64, np.float64, np.float32, np.float16])
 1513:     def test_join_multi_dtypes(self, d1, d2):
 1514:         dtype1 = np.dtype(d1)
 1515:         dtype2 = np.dtype(d2)
 1516: 
 1517:         left = DataFrame(
 1518:             {
 1519:                 "k1": np.array([0, 1, 2] * 8, dtype=dtype1),
 1520:                 "k2": ["foo", "bar"] * 12,
 1521:                 "v": np.array(np.arange(24), dtype=np.int64),
 1522:             }
 1523:         )
 1524: 
 1525:         index = MultiIndex.from_tuples([(2, "bar"), (1, "foo")])
 1526:         right = DataFrame({"v2": np.array([5, 7], dtype=dtype2)}, index=index)
 1527: 
 1528:         result = left.join(right, on=["k1", "k2"])
 1529: 
 1530:         expected = left.copy()
 1531: 
 1532:         if dtype2.kind == "i":
 1533:             dtype2 = np.dtype("float64")
 1534:         expected["v2"] = np.array(np.nan, dtype=dtype2)
 1535:         expected.loc[(expected.k1 == 2) & (expected.k2 == "bar"), "v2"] = 5
 1536:         expected.loc[(expected.k1 == 1) & (expected.k2 == "foo"), "v2"] = 7
 1537: 
 1538:         tm.assert_frame_equal(result, expected)
 1539: 
 1540:         result = left.join(right, on=["k1", "k2"], sort=True)
 1541:         expected.sort_values(["k1", "k2"], kind="mergesort", inplace=True)
 1542:         tm.assert_frame_equal(result, expected)
 1543: 
 1544:     @pytest.mark.parametrize(
 1545:         "int_vals, float_vals, exp_vals",
 1546:         [
 1547:             ([1, 2, 3], [1.0, 2.0, 3.0], {"X": [1, 2, 3], "Y": [1.0, 2.0, 3.0]}),
 1548:             ([1, 2, 3], [1.0, 3.0], {"X": [1, 3], "Y": [1.0, 3.0]}),
 1549:             ([1, 2], [1.0, 2.0, 3.0], {"X": [1, 2], "Y": [1.0, 2.0]}),
 1550:         ],
 1551:     )
 1552:     def test_merge_on_ints_floats(self, int_vals, float_vals, exp_vals):
 1553:         # GH 16572
 1554:         # Check that float column is not cast to object if
 1555:         # merging on float and int columns
 1556:         A = DataFrame({"X": int_vals})
 1557:         B = DataFrame({"Y": float_vals})
 1558:         expected = DataFrame(exp_vals)
 1559: 
 1560:         result = A.merge(B, left_on="X", right_on="Y")
 1561:         tm.assert_frame_equal(result, expected)
 1562: 
 1563:         result = B.merge(A, left_on="Y", right_on="X")
 1564:         tm.assert_frame_equal(result, expected[["Y", "X"]])
 1565: 
 1566:     def test_merge_key_dtype_cast(self):
 1567:         # GH 17044
 1568:         df1 = DataFrame({"key": [1.0, 2.0], "v1": [10, 20]}, columns=["key", "v1"])
 1569:         df2 = DataFrame({"key": [2], "v2": [200]}, columns=["key", "v2"])
 1570:         result = df1.merge(df2, on="key", how="left")
 1571:         expected = DataFrame(
 1572:             {"key": [1.0, 2.0], "v1": [10, 20], "v2": [np.nan, 200.0]},
 1573:             columns=["key", "v1", "v2"],
 1574:         )
 1575:         tm.assert_frame_equal(result, expected)
 1576: 
 1577:     def test_merge_on_ints_floats_warning(self):
 1578:         # GH 16572
 1579:         # merge will produce a warning when merging on int and
 1580:         # float columns where the float values are not exactly
 1581:         # equal to their int representation
 1582:         A = DataFrame({"X": [1, 2, 3]})
 1583:         B = DataFrame({"Y": [1.1, 2.5, 3.0]})
 1584:         expected = DataFrame({"X": [3], "Y": [3.0]})
 1585: 
 1586:         with tm.assert_produces_warning(UserWarning):
 1587:             result = A.merge(B, left_on="X", right_on="Y")
 1588:             tm.assert_frame_equal(result, expected)
 1589: 
 1590:         with tm.assert_produces_warning(UserWarning):
 1591:             result = B.merge(A, left_on="Y", right_on="X")
 1592:             tm.assert_frame_equal(result, expected[["Y", "X"]])
 1593: 
 1594:         # test no warning if float has NaNs
 1595:         B = DataFrame({"Y": [np.nan, np.nan, 3.0]})
 1596: 
 1597:         with tm.assert_produces_warning(None):
 1598:             result = B.merge(A, left_on="Y", right_on="X")
 1599:             tm.assert_frame_equal(result, expected[["Y", "X"]])
 1600: 
 1601:     def test_merge_incompat_infer_boolean_object(self):
 1602:         # GH21119: bool + object bool merge OK
 1603:         df1 = DataFrame({"key": Series([True, False], dtype=object)})
 1604:         df2 = DataFrame({"key": [True, False]})
 1605: 
 1606:         expected = DataFrame({"key": [True, False]}, dtype=object)
 1607:         result = merge(df1, df2, on="key")
 1608:         tm.assert_frame_equal(result, expected)
 1609:         result = merge(df2, df1, on="key")
 1610:         tm.assert_frame_equal(result, expected)
 1611: 
 1612:     def test_merge_incompat_infer_boolean_object_with_missing(self):
 1613:         # GH21119: bool + object bool merge OK
 1614:         # with missing value
 1615:         df1 = DataFrame({"key": Series([True, False, np.nan], dtype=object)})
 1616:         df2 = DataFrame({"key": [True, False]})
 1617: 
 1618:         expected = DataFrame({"key": [True, False]}, dtype=object)
 1619:         result = merge(df1, df2, on="key")
 1620:         tm.assert_frame_equal(result, expected)
 1621:         result = merge(df2, df1, on="key")
 1622:         tm.assert_frame_equal(result, expected)
 1623: 
 1624:     @pytest.mark.parametrize(
 1625:         "df1_vals, df2_vals",
 1626:         [
 1627:             # merge on category coerces to object
 1628:             ([0, 1, 2], Series(["a", "b", "a"]).astype("category")),
 1629:             ([0.0, 1.0, 2.0], Series(["a", "b", "a"]).astype("category")),
 1630:             # no not infer
 1631:             ([0, 1], Series([False, True], dtype=object)),
 1632:             ([0, 1], Series([False, True], dtype=bool)),
 1633:         ],
 1634:     )
 1635:     def test_merge_incompat_dtypes_are_ok(self, df1_vals, df2_vals):
 1636:         # these are explicitly allowed incompat merges, that pass thru
 1637:         # the result type is dependent on if the values on the rhs are
 1638:         # inferred, otherwise these will be coerced to object
 1639: 
 1640:         df1 = DataFrame({"A": df1_vals})
 1641:         df2 = DataFrame({"A": df2_vals})
 1642: 
 1643:         result = merge(df1, df2, on=["A"])
 1644:         assert is_object_dtype(result.A.dtype)
 1645:         result = merge(df2, df1, on=["A"])
 1646:         assert is_object_dtype(result.A.dtype) or is_string_dtype(result.A.dtype)
 1647: 
 1648:     @pytest.mark.parametrize(
 1649:         "df1_vals, df2_vals",
 1650:         [
 1651:             # do not infer to numeric
 1652:             (Series([1, 2], dtype="uint64"), ["a", "b", "c"]),
 1653:             (Series([1, 2], dtype="int32"), ["a", "b", "c"]),
 1654:             ([0, 1, 2], ["0", "1", "2"]),
 1655:             ([0.0, 1.0, 2.0], ["0", "1", "2"]),
 1656:             ([0, 1, 2], ["0", "1", "2"]),
 1657:             (
 1658:                 pd.date_range("1/1/2011", periods=2, freq="D"),
 1659:                 ["2011-01-01", "2011-01-02"],
 1660:             ),
 1661:             (pd.date_range("1/1/2011", periods=2, freq="D"), [0, 1]),
 1662:             (pd.date_range("1/1/2011", periods=2, freq="D"), [0.0, 1.0]),
 1663:             (
 1664:                 pd.date_range("20130101", periods=3),
 1665:                 pd.date_range("20130101", periods=3, tz="US/Eastern"),
 1666:             ),
 1667:         ],
 1668:     )
 1669:     def test_merge_incompat_dtypes_error(self, df1_vals, df2_vals):
 1670:         # GH 9780, GH 15800
 1671:         # Raise a ValueError when a user tries to merge on
 1672:         # dtypes that are incompatible (e.g., obj and int/float)
 1673: 
 1674:         df1 = DataFrame({"A": df1_vals})
 1675:         df2 = DataFrame({"A": df2_vals})
 1676: 
 1677:         msg = (
 1678:             f"You are trying to merge on {df1['A'].dtype} and {df2['A'].dtype} "
 1679:             "columns for key 'A'. If you wish to proceed you should use pd.concat"
 1680:         )
 1681:         msg = re.escape(msg)
 1682:         with pytest.raises(ValueError, match=msg):
 1683:             merge(df1, df2, on=["A"])
 1684: 
 1685:         # Check that error still raised when swapping order of dataframes
 1686:         msg = (
 1687:             f"You are trying to merge on {df2['A'].dtype} and {df1['A'].dtype} "
 1688:             "columns for key 'A'. If you wish to proceed you should use pd.concat"
 1689:         )
 1690:         msg = re.escape(msg)
 1691:         with pytest.raises(ValueError, match=msg):
 1692:             merge(df2, df1, on=["A"])
 1693: 
 1694:         # Check that error still raised when merging on multiple columns
 1695:         # The error message should mention the first incompatible column
 1696:         if len(df1_vals) == len(df2_vals):
 1697:             # Column A in df1 and df2 is of compatible (the same) dtype
 1698:             # Columns B and C in df1 and df2 are of incompatible dtypes
 1699:             df3 = DataFrame({"A": df2_vals, "B": df1_vals, "C": df1_vals})
 1700:             df4 = DataFrame({"A": df2_vals, "B": df2_vals, "C": df2_vals})
 1701: 
 1702:             # Check that error raised correctly when merging all columns A, B, and C
 1703:             # The error message should mention key 'B'
 1704:             msg = (
 1705:                 f"You are trying to merge on {df3['B'].dtype} and {df4['B'].dtype} "
 1706:                 "columns for key 'B'. If you wish to proceed you should use pd.concat"
 1707:             )
 1708:             msg = re.escape(msg)
 1709:             with pytest.raises(ValueError, match=msg):
 1710:                 merge(df3, df4)
 1711: 
 1712:             # Check that error raised correctly when merging columns A and C
 1713:             # The error message should mention key 'C'
 1714:             msg = (
 1715:                 f"You are trying to merge on {df3['C'].dtype} and {df4['C'].dtype} "
 1716:                 "columns for key 'C'. If you wish to proceed you should use pd.concat"
 1717:             )
 1718:             msg = re.escape(msg)
 1719:             with pytest.raises(ValueError, match=msg):
 1720:                 merge(df3, df4, on=["A", "C"])
 1721: 
 1722:     @pytest.mark.parametrize(
 1723:         "expected_data, how",
 1724:         [
 1725:             ([1, 2], "outer"),
 1726:             ([], "inner"),
 1727:             ([2], "right"),
 1728:             ([1], "left"),
 1729:         ],
 1730:     )
 1731:     def test_merge_EA_dtype(self, any_numeric_ea_dtype, how, expected_data):
 1732:         # GH#40073
 1733:         d1 = DataFrame([(1,)], columns=["id"], dtype=any_numeric_ea_dtype)
 1734:         d2 = DataFrame([(2,)], columns=["id"], dtype=any_numeric_ea_dtype)
 1735:         result = merge(d1, d2, how=how)
 1736:         exp_index = RangeIndex(len(expected_data))
 1737:         expected = DataFrame(
 1738:             expected_data, index=exp_index, columns=["id"], dtype=any_numeric_ea_dtype
 1739:         )
 1740:         tm.assert_frame_equal(result, expected)
 1741: 
 1742:     @pytest.mark.parametrize(
 1743:         "expected_data, how",
 1744:         [
 1745:             (["a", "b"], "outer"),
 1746:             ([], "inner"),
 1747:             (["b"], "right"),
 1748:             (["a"], "left"),
 1749:         ],
 1750:     )
 1751:     def test_merge_string_dtype(self, how, expected_data, any_string_dtype):
 1752:         # GH#40073
 1753:         d1 = DataFrame([("a",)], columns=["id"], dtype=any_string_dtype)
 1754:         d2 = DataFrame([("b",)], columns=["id"], dtype=any_string_dtype)
 1755:         result = merge(d1, d2, how=how)
 1756:         exp_idx = RangeIndex(len(expected_data))
 1757:         expected = DataFrame(
 1758:             expected_data, index=exp_idx, columns=["id"], dtype=any_string_dtype
 1759:         )
 1760:         tm.assert_frame_equal(result, expected)
 1761: 
 1762:     @pytest.mark.parametrize(
 1763:         "how, expected_data",
 1764:         [
 1765:             ("inner", [[True, 1, 4], [False, 5, 3]]),
 1766:             ("outer", [[False, 5, 3], [True, 1, 4]]),
 1767:             ("left", [[True, 1, 4], [False, 5, 3]]),
 1768:             ("right", [[False, 5, 3], [True, 1, 4]]),
 1769:         ],
 1770:     )
 1771:     def test_merge_bool_dtype(self, how, expected_data):
 1772:         # GH#40073
 1773:         df1 = DataFrame({"A": [True, False], "B": [1, 5]})
 1774:         df2 = DataFrame({"A": [False, True], "C": [3, 4]})
 1775:         result = merge(df1, df2, how=how)
 1776:         expected = DataFrame(expected_data, columns=["A", "B", "C"])
 1777:         tm.assert_frame_equal(result, expected)
 1778: 
 1779:     def test_merge_ea_with_string(self, join_type, string_dtype):
 1780:         # GH 43734 Avoid the use of `assign` with multi-index
 1781:         df1 = DataFrame(
 1782:             data={
 1783:                 ("lvl0", "lvl1-a"): ["1", "2", "3", "4", None],
 1784:                 ("lvl0", "lvl1-b"): ["4", "5", "6", "7", "8"],
 1785:             },
 1786:             dtype=pd.StringDtype(),
 1787:         )
 1788:         df1_copy = df1.copy()
 1789:         df2 = DataFrame(
 1790:             data={
 1791:                 ("lvl0", "lvl1-a"): ["1", "2", "3", pd.NA, "5"],
 1792:                 ("lvl0", "lvl1-c"): ["7", "8", "9", pd.NA, "11"],
 1793:             },
 1794:             dtype=string_dtype,
 1795:         )
 1796:         df2_copy = df2.copy()
 1797:         merged = merge(left=df1, right=df2, on=[("lvl0", "lvl1-a")], how=join_type)
 1798: 
 1799:         # No change in df1 and df2
 1800:         tm.assert_frame_equal(df1, df1_copy)
 1801:         tm.assert_frame_equal(df2, df2_copy)
 1802: 
 1803:         # Check the expected types for the merged data frame
 1804:         expected = Series(
 1805:             [np.dtype("O"), pd.StringDtype(), np.dtype("O")],
 1806:             index=MultiIndex.from_tuples(
 1807:                 [("lvl0", "lvl1-a"), ("lvl0", "lvl1-b"), ("lvl0", "lvl1-c")]
 1808:             ),
 1809:         )
 1810:         tm.assert_series_equal(merged.dtypes, expected)
 1811: 
 1812:     @pytest.mark.parametrize(
 1813:         "left_empty, how, exp",
 1814:         [
 1815:             (False, "left", "left"),
 1816:             (False, "right", "empty"),
 1817:             (False, "inner", "empty"),
 1818:             (False, "outer", "left"),
 1819:             (False, "cross", "empty_cross"),
 1820:             (True, "left", "empty"),
 1821:             (True, "right", "right"),
 1822:             (True, "inner", "empty"),
 1823:             (True, "outer", "right"),
 1824:             (True, "cross", "empty_cross"),
 1825:         ],
 1826:     )
 1827:     def test_merge_empty(self, left_empty, how, exp):
 1828:         left = DataFrame({"A": [2, 1], "B": [3, 4]})
 1829:         right = DataFrame({"A": [1], "C": [5]}, dtype="int64")
 1830: 
 1831:         if left_empty:
 1832:             left = left.head(0)
 1833:         else:
 1834:             right = right.head(0)
 1835: 
 1836:         result = left.merge(right, how=how)
 1837: 
 1838:         if exp == "left":
 1839:             expected = DataFrame({"A": [2, 1], "B": [3, 4], "C": [np.nan, np.nan]})
 1840:         elif exp == "right":
 1841:             expected = DataFrame({"A": [1], "B": [np.nan], "C": [5]})
 1842:         elif exp == "empty":
 1843:             expected = DataFrame(columns=["A", "B", "C"], dtype="int64")
 1844:         elif exp == "empty_cross":
 1845:             expected = DataFrame(columns=["A_x", "B", "A_y", "C"], dtype="int64")
 1846: 
 1847:         if how == "outer":
 1848:             expected = expected.sort_values("A", ignore_index=True)
 1849: 
 1850:         tm.assert_frame_equal(result, expected)
 1851: 
 1852: 
 1853: @pytest.fixture
 1854: def left():
 1855:     return DataFrame(
 1856:         {
 1857:             "X": Series(
 1858:                 np.random.default_rng(2).choice(["foo", "bar"], size=(10,))
 1859:             ).astype(CategoricalDtype(["foo", "bar"])),
 1860:             "Y": np.random.default_rng(2).choice(["one", "two", "three"], size=(10,)),
 1861:         }
 1862:     )
 1863: 
 1864: 
 1865: @pytest.fixture
 1866: def right():
 1867:     return DataFrame(
 1868:         {
 1869:             "X": Series(["foo", "bar"]).astype(CategoricalDtype(["foo", "bar"])),
 1870:             "Z": [1, 2],
 1871:         }
 1872:     )
 1873: 
 1874: 
 1875: class TestMergeCategorical:
 1876:     def test_identical(self, left, using_infer_string):
 1877:         # merging on the same, should preserve dtypes
 1878:         merged = merge(left, left, on="X")
 1879:         result = merged.dtypes.sort_index()
 1880:         dtype = np.dtype("O") if not using_infer_string else "string"
 1881:         expected = Series(
 1882:             [CategoricalDtype(categories=["foo", "bar"]), dtype, dtype],
 1883:             index=["X", "Y_x", "Y_y"],
 1884:         )
 1885:         tm.assert_series_equal(result, expected)
 1886: 
 1887:     def test_basic(self, left, right, using_infer_string):
 1888:         # we have matching Categorical dtypes in X
 1889:         # so should preserve the merged column
 1890:         merged = merge(left, right, on="X")
 1891:         result = merged.dtypes.sort_index()
 1892:         dtype = np.dtype("O") if not using_infer_string else "string"
 1893:         expected = Series(
 1894:             [
 1895:                 CategoricalDtype(categories=["foo", "bar"]),
 1896:                 dtype,
 1897:                 np.dtype("int64"),
 1898:             ],
 1899:             index=["X", "Y", "Z"],
 1900:         )
 1901:         tm.assert_series_equal(result, expected)
 1902: 
 1903:     def test_merge_categorical(self):
 1904:         # GH 9426
 1905: 
 1906:         right = DataFrame(
 1907:             {
 1908:                 "c": {0: "a", 1: "b", 2: "c", 3: "d", 4: "e"},
 1909:                 "d": {0: "null", 1: "null", 2: "null", 3: "null", 4: "null"},
 1910:             }
 1911:         )
 1912:         left = DataFrame(
 1913:             {
 1914:                 "a": {0: "f", 1: "f", 2: "f", 3: "f", 4: "f"},
 1915:                 "b": {0: "g", 1: "g", 2: "g", 3: "g", 4: "g"},
 1916:             }
 1917:         )
 1918:         df = merge(left, right, how="left", left_on="b", right_on="c")
 1919: 
 1920:         # object-object
 1921:         expected = df.copy()
 1922: 
 1923:         # object-cat
 1924:         # note that we propagate the category
 1925:         # because we don't have any matching rows
 1926:         cright = right.copy()
 1927:         cright["d"] = cright["d"].astype("category")
 1928:         result = merge(left, cright, how="left", left_on="b", right_on="c")
 1929:         expected["d"] = expected["d"].astype(CategoricalDtype(["null"]))
 1930:         tm.assert_frame_equal(result, expected)
 1931: 
 1932:         # cat-object
 1933:         cleft = left.copy()
 1934:         cleft["b"] = cleft["b"].astype("category")
 1935:         result = merge(cleft, cright, how="left", left_on="b", right_on="c")
 1936:         tm.assert_frame_equal(result, expected)
 1937: 
 1938:         # cat-cat
 1939:         cright = right.copy()
 1940:         cright["d"] = cright["d"].astype("category")
 1941:         cleft = left.copy()
 1942:         cleft["b"] = cleft["b"].astype("category")
 1943:         result = merge(cleft, cright, how="left", left_on="b", right_on="c")
 1944:         tm.assert_frame_equal(result, expected)
 1945: 
 1946:     def tests_merge_categorical_unordered_equal(self):
 1947:         # GH-19551
 1948:         df1 = DataFrame(
 1949:             {
 1950:                 "Foo": Categorical(["A", "B", "C"], categories=["A", "B", "C"]),
 1951:                 "Left": ["A0", "B0", "C0"],
 1952:             }
 1953:         )
 1954: 
 1955:         df2 = DataFrame(
 1956:             {
 1957:                 "Foo": Categorical(["C", "B", "A"], categories=["C", "B", "A"]),
 1958:                 "Right": ["C1", "B1", "A1"],
 1959:             }
 1960:         )
 1961:         result = merge(df1, df2, on=["Foo"])
 1962:         expected = DataFrame(
 1963:             {
 1964:                 "Foo": Categorical(["A", "B", "C"]),
 1965:                 "Left": ["A0", "B0", "C0"],
 1966:                 "Right": ["A1", "B1", "C1"],
 1967:             }
 1968:         )
 1969:         tm.assert_frame_equal(result, expected)
 1970: 
 1971:     @pytest.mark.parametrize("ordered", [True, False])
 1972:     def test_multiindex_merge_with_unordered_categoricalindex(self, ordered):
 1973:         # GH 36973
 1974:         pcat = CategoricalDtype(categories=["P2", "P1"], ordered=ordered)
 1975:         df1 = DataFrame(
 1976:             {
 1977:                 "id": ["C", "C", "D"],
 1978:                 "p": Categorical(["P2", "P1", "P2"], dtype=pcat),
 1979:                 "a": [0, 1, 2],
 1980:             }
 1981:         ).set_index(["id", "p"])
 1982:         df2 = DataFrame(
 1983:             {
 1984:                 "id": ["A", "C", "C"],
 1985:                 "p": Categorical(["P2", "P2", "P1"], dtype=pcat),
 1986:                 "d1": [10, 11, 12],
 1987:             }
 1988:         ).set_index(["id", "p"])
 1989:         result = merge(df1, df2, how="left", left_index=True, right_index=True)
 1990:         expected = DataFrame(
 1991:             {
 1992:                 "id": ["C", "C", "D"],
 1993:                 "p": Categorical(["P2", "P1", "P2"], dtype=pcat),
 1994:                 "a": [0, 1, 2],
 1995:                 "d1": [11.0, 12.0, np.nan],
 1996:             }
 1997:         ).set_index(["id", "p"])
 1998:         tm.assert_frame_equal(result, expected)
 1999: 
 2000:     def test_other_columns(self, left, right, using_infer_string):
 2001:         # non-merge columns should preserve if possible
 2002:         right = right.assign(Z=right.Z.astype("category"))
 2003: 
 2004:         merged = merge(left, right, on="X")
 2005:         result = merged.dtypes.sort_index()
 2006:         dtype = np.dtype("O") if not using_infer_string else "string"
 2007:         expected = Series(
 2008:             [
 2009:                 CategoricalDtype(categories=["foo", "bar"]),
 2010:                 dtype,
 2011:                 CategoricalDtype(categories=[1, 2]),
 2012:             ],
 2013:             index=["X", "Y", "Z"],
 2014:         )
 2015:         tm.assert_series_equal(result, expected)
 2016: 
 2017:         # categories are preserved
 2018:         assert left.X.values._categories_match_up_to_permutation(merged.X.values)
 2019:         assert right.Z.values._categories_match_up_to_permutation(merged.Z.values)
 2020: 
 2021:     @pytest.mark.parametrize(
 2022:         "change",
 2023:         [
 2024:             lambda x: x,
 2025:             lambda x: x.astype(CategoricalDtype(["foo", "bar", "bah"])),
 2026:             lambda x: x.astype(CategoricalDtype(ordered=True)),
 2027:         ],
 2028:     )
 2029:     def test_dtype_on_merged_different(
 2030:         self, change, join_type, left, right, using_infer_string
 2031:     ):
 2032:         # our merging columns, X now has 2 different dtypes
 2033:         # so we must be object as a result
 2034: 
 2035:         X = change(right.X.astype("object"))
 2036:         right = right.assign(X=X)
 2037:         assert isinstance(left.X.values.dtype, CategoricalDtype)
 2038:         # assert not left.X.values._categories_match_up_to_permutation(right.X.values)
 2039: 
 2040:         merged = merge(left, right, on="X", how=join_type)
 2041: 
 2042:         result = merged.dtypes.sort_index()
 2043:         dtype = np.dtype("O") if not using_infer_string else "string"
 2044:         expected = Series([dtype, dtype, np.dtype("int64")], index=["X", "Y", "Z"])
 2045:         tm.assert_series_equal(result, expected)
 2046: 
 2047:     def test_self_join_multiple_categories(self):
 2048:         # GH 16767
 2049:         # non-duplicates should work with multiple categories
 2050:         m = 5
 2051:         df = DataFrame(
 2052:             {
 2053:                 "a": ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"] * m,
 2054:                 "b": ["t", "w", "x", "y", "z"] * 2 * m,
 2055:                 "c": [
 2056:                     letter
 2057:                     for each in ["m", "n", "u", "p", "o"]
 2058:                     for letter in [each] * 2 * m
 2059:                 ],
 2060:                 "d": [
 2061:                     letter
 2062:                     for each in [
 2063:                         "aa",
 2064:                         "bb",
 2065:                         "cc",
 2066:                         "dd",
 2067:                         "ee",
 2068:                         "ff",
 2069:                         "gg",
 2070:                         "hh",
 2071:                         "ii",
 2072:                         "jj",
 2073:                     ]
 2074:                     for letter in [each] * m
 2075:                 ],
 2076:             }
 2077:         )
 2078: 
 2079:         # change them all to categorical variables
 2080:         df = df.apply(lambda x: x.astype("category"))
 2081: 
 2082:         # self-join should equal ourselves
 2083:         result = merge(df, df, on=list(df.columns))
 2084: 
 2085:         tm.assert_frame_equal(result, df)
 2086: 
 2087:     def test_dtype_on_categorical_dates(self):
 2088:         # GH 16900
 2089:         # dates should not be coerced to ints
 2090: 
 2091:         df = DataFrame(
 2092:             [[date(2001, 1, 1), 1.1], [date(2001, 1, 2), 1.3]], columns=["date", "num2"]
 2093:         )
 2094:         df["date"] = df["date"].astype("category")
 2095: 
 2096:         df2 = DataFrame(
 2097:             [[date(2001, 1, 1), 1.3], [date(2001, 1, 3), 1.4]], columns=["date", "num4"]
 2098:         )
 2099:         df2["date"] = df2["date"].astype("category")
 2100: 
 2101:         expected_outer = DataFrame(
 2102:             [
 2103:                 [pd.Timestamp("2001-01-01").date(), 1.1, 1.3],
 2104:                 [pd.Timestamp("2001-01-02").date(), 1.3, np.nan],
 2105:                 [pd.Timestamp("2001-01-03").date(), np.nan, 1.4],
 2106:             ],
 2107:             columns=["date", "num2", "num4"],
 2108:         )
 2109:         result_outer = merge(df, df2, how="outer", on=["date"])
 2110:         tm.assert_frame_equal(result_outer, expected_outer)
 2111: 
 2112:         expected_inner = DataFrame(
 2113:             [[pd.Timestamp("2001-01-01").date(), 1.1, 1.3]],
 2114:             columns=["date", "num2", "num4"],
 2115:         )
 2116:         result_inner = merge(df, df2, how="inner", on=["date"])
 2117:         tm.assert_frame_equal(result_inner, expected_inner)
 2118: 
 2119:     @pytest.mark.parametrize("ordered", [True, False])
 2120:     @pytest.mark.parametrize(
 2121:         "category_column,categories,expected_categories",
 2122:         [
 2123:             ([False, True, True, False], [True, False], [True, False]),
 2124:             ([2, 1, 1, 2], [1, 2], [1, 2]),
 2125:             (["False", "True", "True", "False"], ["True", "False"], ["True", "False"]),
 2126:         ],
 2127:     )
 2128:     def test_merging_with_bool_or_int_cateorical_column(
 2129:         self, category_column, categories, expected_categories, ordered
 2130:     ):
 2131:         # GH 17187
 2132:         # merging with a boolean/int categorical column
 2133:         df1 = DataFrame({"id": [1, 2, 3, 4], "cat": category_column})
 2134:         df1["cat"] = df1["cat"].astype(CategoricalDtype(categories, ordered=ordered))
 2135:         df2 = DataFrame({"id": [2, 4], "num": [1, 9]})
 2136:         result = df1.merge(df2)
 2137:         expected = DataFrame({"id": [2, 4], "cat": expected_categories, "num": [1, 9]})
 2138:         expected["cat"] = expected["cat"].astype(
 2139:             CategoricalDtype(categories, ordered=ordered)
 2140:         )
 2141:         tm.assert_frame_equal(expected, result)
 2142: 
 2143:     def test_merge_on_int_array(self):
 2144:         # GH 23020
 2145:         df = DataFrame({"A": Series([1, 2, np.nan], dtype="Int64"), "B": 1})
 2146:         result = merge(df, df, on="A")
 2147:         expected = DataFrame(
 2148:             {"A": Series([1, 2, np.nan], dtype="Int64"), "B_x": 1, "B_y": 1}
 2149:         )
 2150:         tm.assert_frame_equal(result, expected)
 2151: 
 2152: 
 2153: @pytest.fixture
 2154: def left_df():
 2155:     return DataFrame({"a": [20, 10, 0]}, index=[2, 1, 0])
 2156: 
 2157: 
 2158: @pytest.fixture
 2159: def right_df():
 2160:     return DataFrame({"b": [300, 100, 200]}, index=[3, 1, 2])
 2161: 
 2162: 
 2163: class TestMergeOnIndexes:
 2164:     @pytest.mark.parametrize(
 2165:         "how, sort, expected",
 2166:         [
 2167:             ("inner", False, DataFrame({"a": [20, 10], "b": [200, 100]}, index=[2, 1])),
 2168:             ("inner", True, DataFrame({"a": [10, 20], "b": [100, 200]}, index=[1, 2])),
 2169:             (
 2170:                 "left",
 2171:                 False,
 2172:                 DataFrame({"a": [20, 10, 0], "b": [200, 100, np.nan]}, index=[2, 1, 0]),
 2173:             ),
 2174:             (
 2175:                 "left",
 2176:                 True,
 2177:                 DataFrame({"a": [0, 10, 20], "b": [np.nan, 100, 200]}, index=[0, 1, 2]),
 2178:             ),
 2179:             (
 2180:                 "right",
 2181:                 False,
 2182:                 DataFrame(
 2183:                     {"a": [np.nan, 10, 20], "b": [300, 100, 200]}, index=[3, 1, 2]
 2184:                 ),
 2185:             ),
 2186:             (
 2187:                 "right",
 2188:                 True,
 2189:                 DataFrame(
 2190:                     {"a": [10, 20, np.nan], "b": [100, 200, 300]}, index=[1, 2, 3]
 2191:                 ),
 2192:             ),
 2193:             (
 2194:                 "outer",
 2195:                 False,
 2196:                 DataFrame(
 2197:                     {"a": [0, 10, 20, np.nan], "b": [np.nan, 100, 200, 300]},
 2198:                     index=[0, 1, 2, 3],
 2199:                 ),
 2200:             ),
 2201:             (
 2202:                 "outer",
 2203:                 True,
 2204:                 DataFrame(
 2205:                     {"a": [0, 10, 20, np.nan], "b": [np.nan, 100, 200, 300]},
 2206:                     index=[0, 1, 2, 3],
 2207:                 ),
 2208:             ),
 2209:         ],
 2210:     )
 2211:     def test_merge_on_indexes(self, left_df, right_df, how, sort, expected):
 2212:         result = merge(
 2213:             left_df, right_df, left_index=True, right_index=True, how=how, sort=sort
 2214:         )
 2215:         tm.assert_frame_equal(result, expected)
 2216: 
 2217: 
 2218: @pytest.mark.parametrize(
 2219:     "index",
 2220:     [Index([1, 2], dtype=dtyp, name="index_col") for dtyp in tm.ALL_REAL_NUMPY_DTYPES]
 2221:     + [
 2222:         CategoricalIndex(["A", "B"], categories=["A", "B"], name="index_col"),
 2223:         RangeIndex(start=0, stop=2, name="index_col"),
 2224:         DatetimeIndex(["2018-01-01", "2018-01-02"], name="index_col"),
 2225:     ],
 2226:     ids=lambda x: f"{type(x).__name__}[{x.dtype}]",
 2227: )
 2228: def test_merge_index_types(index):
 2229:     # gh-20777
 2230:     # assert key access is consistent across index types
 2231:     left = DataFrame({"left_data": [1, 2]}, index=index)
 2232:     right = DataFrame({"right_data": [1.0, 2.0]}, index=index)
 2233: 
 2234:     result = left.merge(right, on=["index_col"])
 2235: 
 2236:     expected = DataFrame({"left_data": [1, 2], "right_data": [1.0, 2.0]}, index=index)
 2237:     tm.assert_frame_equal(result, expected)
 2238: 
 2239: 
 2240: @pytest.mark.parametrize(
 2241:     "on,left_on,right_on,left_index,right_index,nm",
 2242:     [
 2243:         (["outer", "inner"], None, None, False, False, "B"),
 2244:         (None, None, None, True, True, "B"),
 2245:         (None, ["outer", "inner"], None, False, True, "B"),
 2246:         (None, None, ["outer", "inner"], True, False, "B"),
 2247:         (["outer", "inner"], None, None, False, False, None),
 2248:         (None, None, None, True, True, None),
 2249:         (None, ["outer", "inner"], None, False, True, None),
 2250:         (None, None, ["outer", "inner"], True, False, None),
 2251:     ],
 2252: )
 2253: def test_merge_series(on, left_on, right_on, left_index, right_index, nm):
 2254:     # GH 21220
 2255:     a = DataFrame(
 2256:         {"A": [1, 2, 3, 4]},
 2257:         index=MultiIndex.from_product([["a", "b"], [0, 1]], names=["outer", "inner"]),
 2258:     )
 2259:     b = Series(
 2260:         [1, 2, 3, 4],
 2261:         index=MultiIndex.from_product([["a", "b"], [1, 2]], names=["outer", "inner"]),
 2262:         name=nm,
 2263:     )
 2264:     expected = DataFrame(
 2265:         {"A": [2, 4], "B": [1, 3]},
 2266:         index=MultiIndex.from_product([["a", "b"], [1]], names=["outer", "inner"]),
 2267:     )
 2268:     if nm is not None:
 2269:         result = merge(
 2270:             a,
 2271:             b,
 2272:             on=on,
 2273:             left_on=left_on,
 2274:             right_on=right_on,
 2275:             left_index=left_index,
 2276:             right_index=right_index,
 2277:         )
 2278:         tm.assert_frame_equal(result, expected)
 2279:     else:
 2280:         msg = "Cannot merge a Series without a name"
 2281:         with pytest.raises(ValueError, match=msg):
 2282:             result = merge(
 2283:                 a,
 2284:                 b,
 2285:                 on=on,
 2286:                 left_on=left_on,
 2287:                 right_on=right_on,
 2288:                 left_index=left_index,
 2289:                 right_index=right_index,
 2290:             )
 2291: 
 2292: 
 2293: def test_merge_series_multilevel():
 2294:     # GH#47946
 2295:     # GH 40993: For raising, enforced in 2.0
 2296:     a = DataFrame(
 2297:         {"A": [1, 2, 3, 4]},
 2298:         index=MultiIndex.from_product([["a", "b"], [0, 1]], names=["outer", "inner"]),
 2299:     )
 2300:     b = Series(
 2301:         [1, 2, 3, 4],
 2302:         index=MultiIndex.from_product([["a", "b"], [1, 2]], names=["outer", "inner"]),
 2303:         name=("B", "C"),
 2304:     )
 2305:     with pytest.raises(
 2306:         MergeError, match="Not allowed to merge between different levels"
 2307:     ):
 2308:         merge(a, b, on=["outer", "inner"])
 2309: 
 2310: 
 2311: @pytest.mark.parametrize(
 2312:     "col1, col2, kwargs, expected_cols",
 2313:     [
 2314:         (0, 0, {"suffixes": ("", "_dup")}, ["0", "0_dup"]),
 2315:         (0, 0, {"suffixes": (None, "_dup")}, [0, "0_dup"]),
 2316:         (0, 0, {"suffixes": ("_x", "_y")}, ["0_x", "0_y"]),
 2317:         (0, 0, {"suffixes": ["_x", "_y"]}, ["0_x", "0_y"]),
 2318:         ("a", 0, {"suffixes": (None, "_y")}, ["a", 0]),
 2319:         (0.0, 0.0, {"suffixes": ("_x", None)}, ["0.0_x", 0.0]),
 2320:         ("b", "b", {"suffixes": (None, "_y")}, ["b", "b_y"]),
 2321:         ("a", "a", {"suffixes": ("_x", None)}, ["a_x", "a"]),
 2322:         ("a", "b", {"suffixes": ("_x", None)}, ["a", "b"]),
 2323:         ("a", "a", {"suffixes": (None, "_x")}, ["a", "a_x"]),
 2324:         (0, 0, {"suffixes": ("_a", None)}, ["0_a", 0]),
 2325:         ("a", "a", {}, ["a_x", "a_y"]),
 2326:         (0, 0, {}, ["0_x", "0_y"]),
 2327:     ],
 2328: )
 2329: def test_merge_suffix(col1, col2, kwargs, expected_cols):
 2330:     # issue: 24782
 2331:     a = DataFrame({col1: [1, 2, 3]})
 2332:     b = DataFrame({col2: [4, 5, 6]})
 2333: 
 2334:     expected = DataFrame([[1, 4], [2, 5], [3, 6]], columns=expected_cols)
 2335: 
 2336:     result = a.merge(b, left_index=True, right_index=True, **kwargs)
 2337:     tm.assert_frame_equal(result, expected)
 2338: 
 2339:     result = merge(a, b, left_index=True, right_index=True, **kwargs)
 2340:     tm.assert_frame_equal(result, expected)
 2341: 
 2342: 
 2343: @pytest.mark.parametrize(
 2344:     "how,expected",
 2345:     [
 2346:         (
 2347:             "right",
 2348:             DataFrame(
 2349:                 {"A": [100, 200, 300], "B1": [60, 70, np.nan], "B2": [600, 700, 800]}
 2350:             ),
 2351:         ),
 2352:         (
 2353:             "outer",
 2354:             DataFrame(
 2355:                 {
 2356:                     "A": [1, 100, 200, 300],
 2357:                     "B1": [80, 60, 70, np.nan],
 2358:                     "B2": [np.nan, 600, 700, 800],
 2359:                 }
 2360:             ),
 2361:         ),
 2362:     ],
 2363: )
 2364: def test_merge_duplicate_suffix(how, expected):
 2365:     left_df = DataFrame({"A": [100, 200, 1], "B": [60, 70, 80]})
 2366:     right_df = DataFrame({"A": [100, 200, 300], "B": [600, 700, 800]})
 2367:     result = merge(left_df, right_df, on="A", how=how, suffixes=("_x", "_x"))
 2368:     expected.columns = ["A", "B_x", "B_x"]
 2369: 
 2370:     tm.assert_frame_equal(result, expected)
 2371: 
 2372: 
 2373: @pytest.mark.parametrize(
 2374:     "col1, col2, suffixes",
 2375:     [("a", "a", (None, None)), ("a", "a", ("", None)), (0, 0, (None, ""))],
 2376: )
 2377: def test_merge_suffix_error(col1, col2, suffixes):
 2378:     # issue: 24782
 2379:     a = DataFrame({col1: [1, 2, 3]})
 2380:     b = DataFrame({col2: [3, 4, 5]})
 2381: 
 2382:     # TODO: might reconsider current raise behaviour, see issue 24782
 2383:     msg = "columns overlap but no suffix specified"
 2384:     with pytest.raises(ValueError, match=msg):
 2385:         merge(a, b, left_index=True, right_index=True, suffixes=suffixes)
 2386: 
 2387: 
 2388: @pytest.mark.parametrize("suffixes", [{"left", "right"}, {"left": 0, "right": 0}])
 2389: def test_merge_suffix_raises(suffixes):
 2390:     a = DataFrame({"a": [1, 2, 3]})
 2391:     b = DataFrame({"b": [3, 4, 5]})
 2392: 
 2393:     with pytest.raises(TypeError, match="Passing 'suffixes' as a"):
 2394:         merge(a, b, left_index=True, right_index=True, suffixes=suffixes)
 2395: 
 2396: 
 2397: @pytest.mark.parametrize(
 2398:     "col1, col2, suffixes, msg",
 2399:     [
 2400:         ("a", "a", ("a", "b", "c"), r"too many values to unpack \(expected 2\)"),
 2401:         ("a", "a", tuple("a"), r"not enough values to unpack \(expected 2, got 1\)"),
 2402:     ],
 2403: )
 2404: def test_merge_suffix_length_error(col1, col2, suffixes, msg):
 2405:     a = DataFrame({col1: [1, 2, 3]})
 2406:     b = DataFrame({col2: [3, 4, 5]})
 2407: 
 2408:     with pytest.raises(ValueError, match=msg):
 2409:         merge(a, b, left_index=True, right_index=True, suffixes=suffixes)
 2410: 
 2411: 
 2412: @pytest.mark.parametrize("cat_dtype", ["one", "two"])
 2413: @pytest.mark.parametrize("reverse", [True, False])
 2414: def test_merge_equal_cat_dtypes(cat_dtype, reverse):
 2415:     # see gh-22501
 2416:     cat_dtypes = {
 2417:         "one": CategoricalDtype(categories=["a", "b", "c"], ordered=False),
 2418:         "two": CategoricalDtype(categories=["a", "b", "c"], ordered=False),
 2419:     }
 2420: 
 2421:     df1 = DataFrame(
 2422:         {"foo": Series(["a", "b", "c"]).astype(cat_dtypes["one"]), "left": [1, 2, 3]}
 2423:     ).set_index("foo")
 2424: 
 2425:     data_foo = ["a", "b", "c"]
 2426:     data_right = [1, 2, 3]
 2427: 
 2428:     if reverse:
 2429:         data_foo.reverse()
 2430:         data_right.reverse()
 2431: 
 2432:     df2 = DataFrame(
 2433:         {"foo": Series(data_foo).astype(cat_dtypes[cat_dtype]), "right": data_right}
 2434:     ).set_index("foo")
 2435: 
 2436:     result = df1.merge(df2, left_index=True, right_index=True)
 2437: 
 2438:     expected = DataFrame(
 2439:         {
 2440:             "left": [1, 2, 3],
 2441:             "right": [1, 2, 3],
 2442:             "foo": Series(["a", "b", "c"]).astype(cat_dtypes["one"]),
 2443:         }
 2444:     ).set_index("foo")
 2445: 
 2446:     tm.assert_frame_equal(result, expected)
 2447: 
 2448: 
 2449: def test_merge_equal_cat_dtypes2():
 2450:     # see gh-22501
 2451:     cat_dtype = CategoricalDtype(categories=["a", "b", "c"], ordered=False)
 2452: 
 2453:     # Test Data
 2454:     df1 = DataFrame(
 2455:         {"foo": Series(["a", "b"]).astype(cat_dtype), "left": [1, 2]}
 2456:     ).set_index("foo")
 2457: 
 2458:     df2 = DataFrame(
 2459:         {"foo": Series(["a", "b", "c"]).astype(cat_dtype), "right": [3, 2, 1]}
 2460:     ).set_index("foo")
 2461: 
 2462:     result = df1.merge(df2, left_index=True, right_index=True)
 2463: 
 2464:     expected = DataFrame(
 2465:         {"left": [1, 2], "right": [3, 2], "foo": Series(["a", "b"]).astype(cat_dtype)}
 2466:     ).set_index("foo")
 2467: 
 2468:     tm.assert_frame_equal(result, expected)
 2469: 
 2470: 
 2471: def test_merge_on_cat_and_ext_array():
 2472:     # GH 28668
 2473:     right = DataFrame(
 2474:         {"a": Series([pd.Interval(0, 1), pd.Interval(1, 2)], dtype="interval")}
 2475:     )
 2476:     left = right.copy()
 2477:     left["a"] = left["a"].astype("category")
 2478: 
 2479:     result = merge(left, right, how="inner", on="a")
 2480:     expected = right.copy()
 2481: 
 2482:     tm.assert_frame_equal(result, expected)
 2483: 
 2484: 
 2485: def test_merge_multiindex_columns():
 2486:     # Issue #28518
 2487:     # Verify that merging two dataframes give the expected labels
 2488:     # The original cause of this issue come from a bug lexsort_depth and is tested in
 2489:     # test_lexsort_depth
 2490: 
 2491:     letters = ["a", "b", "c", "d"]
 2492:     numbers = ["1", "2", "3"]
 2493:     index = MultiIndex.from_product((letters, numbers), names=["outer", "inner"])
 2494: 
 2495:     frame_x = DataFrame(columns=index)
 2496:     frame_x["id"] = ""
 2497:     frame_y = DataFrame(columns=index)
 2498:     frame_y["id"] = ""
 2499: 
 2500:     l_suf = "_x"
 2501:     r_suf = "_y"
 2502:     result = frame_x.merge(frame_y, on="id", suffixes=((l_suf, r_suf)))
 2503: 
 2504:     # Constructing the expected results
 2505:     tuples = [(letter + l_suf, num) for letter in letters for num in numbers]
 2506:     tuples += [("id", "")]
 2507:     tuples += [(letter + r_suf, num) for letter in letters for num in numbers]
 2508: 
 2509:     expected_index = MultiIndex.from_tuples(tuples, names=["outer", "inner"])
 2510:     expected = DataFrame(columns=expected_index)
 2511: 
 2512:     tm.assert_frame_equal(result, expected, check_dtype=False)
 2513: 
 2514: 
 2515: def test_merge_datetime_upcast_dtype():
 2516:     # https://github.com/pandas-dev/pandas/issues/31208
 2517:     df1 = DataFrame({"x": ["a", "b", "c"], "y": ["1", "2", "4"]})
 2518:     df2 = DataFrame(
 2519:         {"y": ["1", "2", "3"], "z": pd.to_datetime(["2000", "2001", "2002"])}
 2520:     )
 2521:     result = merge(df1, df2, how="left", on="y")
 2522:     expected = DataFrame(
 2523:         {
 2524:             "x": ["a", "b", "c"],
 2525:             "y": ["1", "2", "4"],
 2526:             "z": pd.to_datetime(["2000", "2001", "NaT"]),
 2527:         }
 2528:     )
 2529:     tm.assert_frame_equal(result, expected)
 2530: 
 2531: 
 2532: @pytest.mark.parametrize("n_categories", [5, 128])
 2533: def test_categorical_non_unique_monotonic(n_categories):
 2534:     # GH 28189
 2535:     # With n_categories as 5, we test the int8 case is hit in libjoin,
 2536:     # with n_categories as 128 we test the int16 case.
 2537:     left_index = CategoricalIndex([0] + list(range(n_categories)))
 2538:     df1 = DataFrame(range(n_categories + 1), columns=["value"], index=left_index)
 2539:     df2 = DataFrame(
 2540:         [[6]],
 2541:         columns=["value"],
 2542:         index=CategoricalIndex([0], categories=list(range(n_categories))),
 2543:     )
 2544: 
 2545:     result = merge(df1, df2, how="left", left_index=True, right_index=True)
 2546:     expected = DataFrame(
 2547:         [[i, 6.0] if i < 2 else [i, np.nan] for i in range(n_categories + 1)],
 2548:         columns=["value_x", "value_y"],
 2549:         index=left_index,
 2550:     )
 2551:     tm.assert_frame_equal(expected, result)
 2552: 
 2553: 
 2554: def test_merge_join_categorical_multiindex():
 2555:     # From issue 16627
 2556:     a = {
 2557:         "Cat1": Categorical(["a", "b", "a", "c", "a", "b"], ["a", "b", "c"]),
 2558:         "Int1": [0, 1, 0, 1, 0, 0],
 2559:     }
 2560:     a = DataFrame(a)
 2561: 
 2562:     b = {
 2563:         "Cat": Categorical(["a", "b", "c", "a", "b", "c"], ["a", "b", "c"]),
 2564:         "Int": [0, 0, 0, 1, 1, 1],
 2565:         "Factor": [1.1, 1.2, 1.3, 1.4, 1.5, 1.6],
 2566:     }
 2567:     b = DataFrame(b).set_index(["Cat", "Int"])["Factor"]
 2568: 
 2569:     expected = merge(
 2570:         a,
 2571:         b.reset_index(),
 2572:         left_on=["Cat1", "Int1"],
 2573:         right_on=["Cat", "Int"],
 2574:         how="left",
 2575:     )
 2576:     expected = expected.drop(["Cat", "Int"], axis=1)
 2577:     result = a.join(b, on=["Cat1", "Int1"])
 2578:     tm.assert_frame_equal(expected, result)
 2579: 
 2580:     # Same test, but with ordered categorical
 2581:     a = {
 2582:         "Cat1": Categorical(
 2583:             ["a", "b", "a", "c", "a", "b"], ["b", "a", "c"], ordered=True
 2584:         ),
 2585:         "Int1": [0, 1, 0, 1, 0, 0],
 2586:     }
 2587:     a = DataFrame(a)
 2588: 
 2589:     b = {
 2590:         "Cat": Categorical(
 2591:             ["a", "b", "c", "a", "b", "c"], ["b", "a", "c"], ordered=True
 2592:         ),
 2593:         "Int": [0, 0, 0, 1, 1, 1],
 2594:         "Factor": [1.1, 1.2, 1.3, 1.4, 1.5, 1.6],
 2595:     }
 2596:     b = DataFrame(b).set_index(["Cat", "Int"])["Factor"]
 2597: 
 2598:     expected = merge(
 2599:         a,
 2600:         b.reset_index(),
 2601:         left_on=["Cat1", "Int1"],
 2602:         right_on=["Cat", "Int"],
 2603:         how="left",
 2604:     )
 2605:     expected = expected.drop(["Cat", "Int"], axis=1)
 2606:     result = a.join(b, on=["Cat1", "Int1"])
 2607:     tm.assert_frame_equal(expected, result)
 2608: 
 2609: 
 2610: @pytest.mark.parametrize("func", ["merge", "merge_asof"])
 2611: @pytest.mark.parametrize(
 2612:     ("kwargs", "err_msg"),
 2613:     [
 2614:         ({"left_on": "a", "left_index": True}, ["left_on", "left_index"]),
 2615:         ({"right_on": "a", "right_index": True}, ["right_on", "right_index"]),
 2616:     ],
 2617: )
 2618: def test_merge_join_cols_error_reporting_duplicates(func, kwargs, err_msg):
 2619:     # GH: 16228
 2620:     left = DataFrame({"a": [1, 2], "b": [3, 4]})
 2621:     right = DataFrame({"a": [1, 1], "c": [5, 6]})
 2622:     msg = rf'Can only pass argument "{err_msg[0]}" OR "{err_msg[1]}" not both\.'
 2623:     with pytest.raises(MergeError, match=msg):
 2624:         getattr(pd, func)(left, right, **kwargs)
 2625: 
 2626: 
 2627: @pytest.mark.parametrize("func", ["merge", "merge_asof"])
 2628: @pytest.mark.parametrize(
 2629:     ("kwargs", "err_msg"),
 2630:     [
 2631:         ({"left_on": "a"}, ["right_on", "right_index"]),
 2632:         ({"right_on": "a"}, ["left_on", "left_index"]),
 2633:     ],
 2634: )
 2635: def test_merge_join_cols_error_reporting_missing(func, kwargs, err_msg):
 2636:     # GH: 16228
 2637:     left = DataFrame({"a": [1, 2], "b": [3, 4]})
 2638:     right = DataFrame({"a": [1, 1], "c": [5, 6]})
 2639:     msg = rf'Must pass "{err_msg[0]}" OR "{err_msg[1]}"\.'
 2640:     with pytest.raises(MergeError, match=msg):
 2641:         getattr(pd, func)(left, right, **kwargs)
 2642: 
 2643: 
 2644: @pytest.mark.parametrize("func", ["merge", "merge_asof"])
 2645: @pytest.mark.parametrize(
 2646:     "kwargs",
 2647:     [
 2648:         {"right_index": True},
 2649:         {"left_index": True},
 2650:     ],
 2651: )
 2652: def test_merge_join_cols_error_reporting_on_and_index(func, kwargs):
 2653:     # GH: 16228
 2654:     left = DataFrame({"a": [1, 2], "b": [3, 4]})
 2655:     right = DataFrame({"a": [1, 1], "c": [5, 6]})
 2656:     msg = (
 2657:         r'Can only pass argument "on" OR "left_index" '
 2658:         r'and "right_index", not a combination of both\.'
 2659:     )
 2660:     with pytest.raises(MergeError, match=msg):
 2661:         getattr(pd, func)(left, right, on="a", **kwargs)
 2662: 
 2663: 
 2664: def test_merge_right_left_index():
 2665:     # GH#38616
 2666:     left = DataFrame({"x": [1, 1], "z": ["foo", "foo"]})
 2667:     right = DataFrame({"x": [1, 1], "z": ["foo", "foo"]})
 2668:     result = merge(left, right, how="right", left_index=True, right_on="x")
 2669:     expected = DataFrame(
 2670:         {
 2671:             "x": [1, 1],
 2672:             "x_x": [1, 1],
 2673:             "z_x": ["foo", "foo"],
 2674:             "x_y": [1, 1],
 2675:             "z_y": ["foo", "foo"],
 2676:         }
 2677:     )
 2678:     tm.assert_frame_equal(result, expected)
 2679: 
 2680: 
 2681: def test_merge_result_empty_index_and_on():
 2682:     # GH#33814
 2683:     df1 = DataFrame({"a": [1], "b": [2]}).set_index(["a", "b"])
 2684:     df2 = DataFrame({"b": [1]}).set_index(["b"])
 2685:     expected = DataFrame({"a": [], "b": []}, dtype=np.int64).set_index(["a", "b"])
 2686:     result = merge(df1, df2, left_on=["b"], right_index=True)
 2687:     tm.assert_frame_equal(result, expected)
 2688: 
 2689:     result = merge(df2, df1, left_index=True, right_on=["b"])
 2690:     tm.assert_frame_equal(result, expected)
 2691: 
 2692: 
 2693: def test_merge_suffixes_produce_dup_columns_raises():
 2694:     # GH#22818; Enforced in 2.0
 2695:     left = DataFrame({"a": [1, 2, 3], "b": 1, "b_x": 2})
 2696:     right = DataFrame({"a": [1, 2, 3], "b": 2})
 2697: 
 2698:     with pytest.raises(MergeError, match="Passing 'suffixes' which cause duplicate"):
 2699:         merge(left, right, on="a")
 2700: 
 2701:     with pytest.raises(MergeError, match="Passing 'suffixes' which cause duplicate"):
 2702:         merge(right, left, on="a", suffixes=("_y", "_x"))
 2703: 
 2704: 
 2705: def test_merge_duplicate_columns_with_suffix_no_warning():
 2706:     # GH#22818
 2707:     # Do not raise warning when duplicates are caused by duplicates in origin
 2708:     left = DataFrame([[1, 1, 1], [2, 2, 2]], columns=["a", "b", "b"])
 2709:     right = DataFrame({"a": [1, 3], "b": 2})
 2710:     result = merge(left, right, on="a")
 2711:     expected = DataFrame([[1, 1, 1, 2]], columns=["a", "b_x", "b_x", "b_y"])
 2712:     tm.assert_frame_equal(result, expected)
 2713: 
 2714: 
 2715: def test_merge_duplicate_columns_with_suffix_causing_another_duplicate_raises():
 2716:     # GH#22818, Enforced in 2.0
 2717:     # This should raise warning because suffixes cause another collision
 2718:     left = DataFrame([[1, 1, 1, 1], [2, 2, 2, 2]], columns=["a", "b", "b", "b_x"])
 2719:     right = DataFrame({"a": [1, 3], "b": 2})
 2720:     with pytest.raises(MergeError, match="Passing 'suffixes' which cause duplicate"):
 2721:         merge(left, right, on="a")
 2722: 
 2723: 
 2724: def test_merge_string_float_column_result():
 2725:     # GH 13353
 2726:     df1 = DataFrame([[1, 2], [3, 4]], columns=Index(["a", 114.0]))
 2727:     df2 = DataFrame([[9, 10], [11, 12]], columns=["x", "y"])
 2728:     result = merge(df2, df1, how="inner", left_index=True, right_index=True)
 2729:     expected = DataFrame(
 2730:         [[9, 10, 1, 2], [11, 12, 3, 4]], columns=Index(["x", "y", "a", 114.0])
 2731:     )
 2732:     tm.assert_frame_equal(result, expected)
 2733: 
 2734: 
 2735: def test_mergeerror_on_left_index_mismatched_dtypes():
 2736:     # GH 22449
 2737:     df_1 = DataFrame(data=["X"], columns=["C"], index=[22])
 2738:     df_2 = DataFrame(data=["X"], columns=["C"], index=[999])
 2739:     with pytest.raises(MergeError, match="Can only pass argument"):
 2740:         merge(df_1, df_2, on=["C"], left_index=True)
 2741: 
 2742: 
 2743: def test_merge_on_left_categoricalindex():
 2744:     # GH#48464 don't raise when left_on is a CategoricalIndex
 2745:     ci = CategoricalIndex(range(3))
 2746: 
 2747:     right = DataFrame({"A": ci, "B": range(3)})
 2748:     left = DataFrame({"C": range(3, 6)})
 2749: 
 2750:     res = merge(left, right, left_on=ci, right_on="A")
 2751:     expected = merge(left, right, left_on=ci._data, right_on="A")
 2752:     tm.assert_frame_equal(res, expected)
 2753: 
 2754: 
 2755: @pytest.mark.parametrize("dtype", [None, "Int64"])
 2756: def test_merge_outer_with_NaN(dtype):
 2757:     # GH#43550
 2758:     left = DataFrame({"key": [1, 2], "col1": [1, 2]}, dtype=dtype)
 2759:     right = DataFrame({"key": [np.nan, np.nan], "col2": [3, 4]}, dtype=dtype)
 2760:     result = merge(left, right, on="key", how="outer")
 2761:     expected = DataFrame(
 2762:         {
 2763:             "key": [1, 2, np.nan, np.nan],
 2764:             "col1": [1, 2, np.nan, np.nan],
 2765:             "col2": [np.nan, np.nan, 3, 4],
 2766:         },
 2767:         dtype=dtype,
 2768:     )
 2769:     tm.assert_frame_equal(result, expected)
 2770: 
 2771:     # switch left and right
 2772:     result = merge(right, left, on="key", how="outer")
 2773:     expected = DataFrame(
 2774:         {
 2775:             "key": [1, 2, np.nan, np.nan],
 2776:             "col2": [np.nan, np.nan, 3, 4],
 2777:             "col1": [1, 2, np.nan, np.nan],
 2778:         },
 2779:         dtype=dtype,
 2780:     )
 2781:     tm.assert_frame_equal(result, expected)
 2782: 
 2783: 
 2784: def test_merge_different_index_names():
 2785:     # GH#45094
 2786:     left = DataFrame({"a": [1]}, index=Index([1], name="c"))
 2787:     right = DataFrame({"a": [1]}, index=Index([1], name="d"))
 2788:     result = merge(left, right, left_on="c", right_on="d")
 2789:     expected = DataFrame({"a_x": [1], "a_y": 1})
 2790:     tm.assert_frame_equal(result, expected)
 2791: 
 2792: 
 2793: def test_merge_ea(any_numeric_ea_dtype, join_type):
 2794:     # GH#44240
 2795:     left = DataFrame({"a": [1, 2, 3], "b": 1}, dtype=any_numeric_ea_dtype)
 2796:     right = DataFrame({"a": [1, 2, 3], "c": 2}, dtype=any_numeric_ea_dtype)
 2797:     result = left.merge(right, how=join_type)
 2798:     expected = DataFrame({"a": [1, 2, 3], "b": 1, "c": 2}, dtype=any_numeric_ea_dtype)
 2799:     tm.assert_frame_equal(result, expected)
 2800: 
 2801: 
 2802: def test_merge_ea_and_non_ea(any_numeric_ea_dtype, join_type):
 2803:     # GH#44240
 2804:     left = DataFrame({"a": [1, 2, 3], "b": 1}, dtype=any_numeric_ea_dtype)
 2805:     right = DataFrame({"a": [1, 2, 3], "c": 2}, dtype=any_numeric_ea_dtype.lower())
 2806:     result = left.merge(right, how=join_type)
 2807:     expected = DataFrame(
 2808:         {
 2809:             "a": Series([1, 2, 3], dtype=any_numeric_ea_dtype),
 2810:             "b": Series([1, 1, 1], dtype=any_numeric_ea_dtype),
 2811:             "c": Series([2, 2, 2], dtype=any_numeric_ea_dtype.lower()),
 2812:         }
 2813:     )
 2814:     tm.assert_frame_equal(result, expected)
 2815: 
 2816: 
 2817: @pytest.mark.parametrize("dtype", ["int64", "int64[pyarrow]"])
 2818: def test_merge_arrow_and_numpy_dtypes(dtype):
 2819:     # GH#52406
 2820:     pytest.importorskip("pyarrow")
 2821:     df = DataFrame({"a": [1, 2]}, dtype=dtype)
 2822:     df2 = DataFrame({"a": [1, 2]}, dtype="int64[pyarrow]")
 2823:     result = df.merge(df2)
 2824:     expected = df.copy()
 2825:     tm.assert_frame_equal(result, expected)
 2826: 
 2827:     result = df2.merge(df)
 2828:     expected = df2.copy()
 2829:     tm.assert_frame_equal(result, expected)
 2830: 
 2831: 
 2832: @pytest.mark.parametrize("how", ["inner", "left", "outer", "right"])
 2833: @pytest.mark.parametrize("tz", [None, "America/Chicago"])
 2834: def test_merge_datetime_different_resolution(tz, how):
 2835:     # https://github.com/pandas-dev/pandas/issues/53200
 2836:     vals = [
 2837:         pd.Timestamp(2023, 5, 12, tz=tz),
 2838:         pd.Timestamp(2023, 5, 13, tz=tz),
 2839:         pd.Timestamp(2023, 5, 14, tz=tz),
 2840:     ]
 2841:     df1 = DataFrame({"t": vals[:2], "a": [1.0, 2.0]})
 2842:     df1["t"] = df1["t"].dt.as_unit("ns")
 2843:     df2 = DataFrame({"t": vals[1:], "b": [1.0, 2.0]})
 2844:     df2["t"] = df2["t"].dt.as_unit("s")
 2845: 
 2846:     expected = DataFrame({"t": vals, "a": [1.0, 2.0, np.nan], "b": [np.nan, 1.0, 2.0]})
 2847:     expected["t"] = expected["t"].dt.as_unit("ns")
 2848:     if how == "inner":
 2849:         expected = expected.iloc[[1]].reset_index(drop=True)
 2850:     elif how == "left":
 2851:         expected = expected.iloc[[0, 1]]
 2852:     elif how == "right":
 2853:         expected = expected.iloc[[1, 2]].reset_index(drop=True)
 2854: 
 2855:     result = df1.merge(df2, on="t", how=how)
 2856:     tm.assert_frame_equal(result, expected)
 2857: 
 2858: 
 2859: def test_merge_multiindex_single_level():
 2860:     # GH52331
 2861:     df = DataFrame({"col": ["A", "B"]})
 2862:     df2 = DataFrame(
 2863:         data={"b": [100]},
 2864:         index=MultiIndex.from_tuples([("A",), ("C",)], names=["col"]),
 2865:     )
 2866:     expected = DataFrame({"col": ["A", "B"], "b": [100, np.nan]})
 2867: 
 2868:     result = df.merge(df2, left_on=["col"], right_index=True, how="left")
 2869:     tm.assert_frame_equal(result, expected)
 2870: 
 2871: 
 2872: @pytest.mark.parametrize("how", ["left", "right", "inner", "outer"])
 2873: @pytest.mark.parametrize("sort", [True, False])
 2874: @pytest.mark.parametrize("on_index", [True, False])
 2875: @pytest.mark.parametrize("left_unique", [True, False])
 2876: @pytest.mark.parametrize("left_monotonic", [True, False])
 2877: @pytest.mark.parametrize("right_unique", [True, False])
 2878: @pytest.mark.parametrize("right_monotonic", [True, False])
 2879: def test_merge_combinations(
 2880:     how, sort, on_index, left_unique, left_monotonic, right_unique, right_monotonic
 2881: ):
 2882:     # GH 54611
 2883:     left = [2, 3]
 2884:     if left_unique:
 2885:         left.append(4 if left_monotonic else 1)
 2886:     else:
 2887:         left.append(3 if left_monotonic else 2)
 2888: 
 2889:     right = [2, 3]
 2890:     if right_unique:
 2891:         right.append(4 if right_monotonic else 1)
 2892:     else:
 2893:         right.append(3 if right_monotonic else 2)
 2894: 
 2895:     left = DataFrame({"key": left})
 2896:     right = DataFrame({"key": right})
 2897: 
 2898:     if on_index:
 2899:         left = left.set_index("key")
 2900:         right = right.set_index("key")
 2901:         on_kwargs = {"left_index": True, "right_index": True}
 2902:     else:
 2903:         on_kwargs = {"on": "key"}
 2904: 
 2905:     result = merge(left, right, how=how, sort=sort, **on_kwargs)
 2906: 
 2907:     if on_index:
 2908:         left = left.reset_index()
 2909:         right = right.reset_index()
 2910: 
 2911:     if how in ["left", "right", "inner"]:
 2912:         if how in ["left", "inner"]:
 2913:             expected, other, other_unique = left, right, right_unique
 2914:         else:
 2915:             expected, other, other_unique = right, left, left_unique
 2916:         if how == "inner":
 2917:             keep_values = set(left["key"].values).intersection(right["key"].values)
 2918:             keep_mask = expected["key"].isin(keep_values)
 2919:             expected = expected[keep_mask]
 2920:         if sort:
 2921:             expected = expected.sort_values("key")
 2922:         if not other_unique:
 2923:             other_value_counts = other["key"].value_counts()
 2924:             repeats = other_value_counts.reindex(expected["key"].values, fill_value=1)
 2925:             repeats = repeats.astype(np.intp)
 2926:             expected = expected["key"].repeat(repeats.values)
 2927:             expected = expected.to_frame()
 2928:     elif how == "outer":
 2929:         left_counts = left["key"].value_counts()
 2930:         right_counts = right["key"].value_counts()
 2931:         expected_counts = left_counts.mul(right_counts, fill_value=1)
 2932:         expected_counts = expected_counts.astype(np.intp)
 2933:         expected = expected_counts.index.values.repeat(expected_counts.values)
 2934:         expected = DataFrame({"key": expected})
 2935:         expected = expected.sort_values("key")
 2936: 
 2937:     if on_index:
 2938:         expected = expected.set_index("key")
 2939:     else:
 2940:         expected = expected.reset_index(drop=True)
 2941: 
 2942:     tm.assert_frame_equal(result, expected)
 2943: 
 2944: 
 2945: def test_merge_ea_int_and_float_numpy():
 2946:     # GH#46178
 2947:     df1 = DataFrame([1.0, np.nan], dtype=pd.Int64Dtype())
 2948:     df2 = DataFrame([1.5])
 2949:     expected = DataFrame(columns=[0], dtype="Int64")
 2950: 
 2951:     with tm.assert_produces_warning(UserWarning, match="You are merging"):
 2952:         result = df1.merge(df2)
 2953:     tm.assert_frame_equal(result, expected)
 2954: 
 2955:     with tm.assert_produces_warning(UserWarning, match="You are merging"):
 2956:         result = df2.merge(df1)
 2957:     tm.assert_frame_equal(result, expected.astype("float64"))
 2958: 
 2959:     df2 = DataFrame([1.0])
 2960:     expected = DataFrame([1], columns=[0], dtype="Int64")
 2961:     result = df1.merge(df2)
 2962:     tm.assert_frame_equal(result, expected)
 2963: 
 2964:     result = df2.merge(df1)
 2965:     tm.assert_frame_equal(result, expected.astype("float64"))
 2966: 
 2967: 
 2968: def test_merge_arrow_string_index(any_string_dtype):
 2969:     # GH#54894
 2970:     pytest.importorskip("pyarrow")
 2971:     left = DataFrame({"a": ["a", "b"]}, dtype=any_string_dtype)
 2972:     right = DataFrame({"b": 1}, index=Index(["a", "c"], dtype=any_string_dtype))
 2973:     result = left.merge(right, left_on="a", right_index=True, how="left")
 2974:     expected = DataFrame(
 2975:         {"a": Series(["a", "b"], dtype=any_string_dtype), "b": [1, np.nan]}
 2976:     )
 2977:     tm.assert_frame_equal(result, expected)
 2978: 
 2979: 
 2980: @pytest.mark.parametrize("left_empty", [True, False])
 2981: @pytest.mark.parametrize("right_empty", [True, False])
 2982: def test_merge_empty_frames_column_order(left_empty, right_empty):
 2983:     # GH 51929
 2984:     df1 = DataFrame(1, index=[0], columns=["A", "B"])
 2985:     df2 = DataFrame(1, index=[0], columns=["A", "C", "D"])
 2986: 
 2987:     if left_empty:
 2988:         df1 = df1.iloc[:0]
 2989:     if right_empty:
 2990:         df2 = df2.iloc[:0]
 2991: 
 2992:     result = merge(df1, df2, on=["A"], how="outer")
 2993:     expected = DataFrame(1, index=[0], columns=["A", "B", "C", "D"])
 2994:     if left_empty and right_empty:
 2995:         expected = expected.iloc[:0]
 2996:     elif left_empty:
 2997:         expected["B"] = np.nan
 2998:     elif right_empty:
 2999:         expected[["C", "D"]] = np.nan
 3000:     tm.assert_frame_equal(result, expected)
 3001: 
 3002: 
 3003: @pytest.mark.parametrize("how", ["left", "right", "inner", "outer"])
 3004: def test_merge_datetime_and_timedelta(how):
 3005:     left = DataFrame({"key": Series([1, None], dtype="datetime64[ns]")})
 3006:     right = DataFrame({"key": Series([1], dtype="timedelta64[ns]")})
 3007: 
 3008:     msg = (
 3009:         f"You are trying to merge on {left['key'].dtype} and {right['key'].dtype} "
 3010:         "columns for key 'key'. If you wish to proceed you should use pd.concat"
 3011:     )
 3012:     with pytest.raises(ValueError, match=re.escape(msg)):
 3013:         left.merge(right, on="key", how=how)
 3014: 
 3015:     msg = (
 3016:         f"You are trying to merge on {right['key'].dtype} and {left['key'].dtype} "
 3017:         "columns for key 'key'. If you wish to proceed you should use pd.concat"
 3018:     )
 3019:     with pytest.raises(ValueError, match=re.escape(msg)):
 3020:         right.merge(left, on="key", how=how)
