    1: import os
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     Categorical,
    9:     DatetimeIndex,
   10:     Interval,
   11:     IntervalIndex,
   12:     NaT,
   13:     Series,
   14:     Timedelta,
   15:     TimedeltaIndex,
   16:     Timestamp,
   17:     cut,
   18:     date_range,
   19:     isna,
   20:     qcut,
   21:     timedelta_range,
   22: )
   23: import pandas._testing as tm
   24: from pandas.api.types import CategoricalDtype
   25: 
   26: from pandas.tseries.offsets import Day
   27: 
   28: 
   29: def test_qcut():
   30:     arr = np.random.default_rng(2).standard_normal(1000)
   31: 
   32:     # We store the bins as Index that have been
   33:     # rounded to comparisons are a bit tricky.
   34:     labels, _ = qcut(arr, 4, retbins=True)
   35:     ex_bins = np.quantile(arr, [0, 0.25, 0.5, 0.75, 1.0])
   36: 
   37:     result = labels.categories.left.values
   38:     assert np.allclose(result, ex_bins[:-1], atol=1e-2)
   39: 
   40:     result = labels.categories.right.values
   41:     assert np.allclose(result, ex_bins[1:], atol=1e-2)
   42: 
   43:     ex_levels = cut(arr, ex_bins, include_lowest=True)
   44:     tm.assert_categorical_equal(labels, ex_levels)
   45: 
   46: 
   47: def test_qcut_bounds():
   48:     arr = np.random.default_rng(2).standard_normal(1000)
   49: 
   50:     factor = qcut(arr, 10, labels=False)
   51:     assert len(np.unique(factor)) == 10
   52: 
   53: 
   54: def test_qcut_specify_quantiles():
   55:     arr = np.random.default_rng(2).standard_normal(100)
   56:     factor = qcut(arr, [0, 0.25, 0.5, 0.75, 1.0])
   57: 
   58:     expected = qcut(arr, 4)
   59:     tm.assert_categorical_equal(factor, expected)
   60: 
   61: 
   62: def test_qcut_all_bins_same():
   63:     with pytest.raises(ValueError, match="edges.*unique"):
   64:         qcut([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 3)
   65: 
   66: 
   67: def test_qcut_include_lowest():
   68:     values = np.arange(10)
   69:     ii = qcut(values, 4)
   70: 
   71:     ex_levels = IntervalIndex(
   72:         [
   73:             Interval(-0.001, 2.25),
   74:             Interval(2.25, 4.5),
   75:             Interval(4.5, 6.75),
   76:             Interval(6.75, 9),
   77:         ]
   78:     )
   79:     tm.assert_index_equal(ii.categories, ex_levels)
   80: 
   81: 
   82: def test_qcut_nas():
   83:     arr = np.random.default_rng(2).standard_normal(100)
   84:     arr[:20] = np.nan
   85: 
   86:     result = qcut(arr, 4)
   87:     assert isna(result[:20]).all()
   88: 
   89: 
   90: def test_qcut_index():
   91:     result = qcut([0, 2], 2)
   92:     intervals = [Interval(-0.001, 1), Interval(1, 2)]
   93: 
   94:     expected = Categorical(intervals, ordered=True)
   95:     tm.assert_categorical_equal(result, expected)
   96: 
   97: 
   98: def test_qcut_binning_issues(datapath):
   99:     # see gh-1978, gh-1979
  100:     cut_file = datapath(os.path.join("reshape", "data", "cut_data.csv"))
  101:     arr = np.loadtxt(cut_file)
  102:     result = qcut(arr, 20)
  103: 
  104:     starts = []
  105:     ends = []
  106: 
  107:     for lev in np.unique(result):
  108:         s = lev.left
  109:         e = lev.right
  110:         assert s != e
  111: 
  112:         starts.append(float(s))
  113:         ends.append(float(e))
  114: 
  115:     for (sp, sn), (ep, en) in zip(
  116:         zip(starts[:-1], starts[1:]), zip(ends[:-1], ends[1:])
  117:     ):
  118:         assert sp < sn
  119:         assert ep < en
  120:         assert ep <= sn
  121: 
  122: 
  123: def test_qcut_return_intervals():
  124:     ser = Series([0, 1, 2, 3, 4, 5, 6, 7, 8])
  125:     res = qcut(ser, [0, 0.333, 0.666, 1])
  126: 
  127:     exp_levels = np.array(
  128:         [Interval(-0.001, 2.664), Interval(2.664, 5.328), Interval(5.328, 8)]
  129:     )
  130:     exp = Series(exp_levels.take([0, 0, 0, 1, 1, 1, 2, 2, 2])).astype(
  131:         CategoricalDtype(ordered=True)
  132:     )
  133:     tm.assert_series_equal(res, exp)
  134: 
  135: 
  136: @pytest.mark.parametrize("labels", ["foo", 1, True])
  137: def test_qcut_incorrect_labels(labels):
  138:     # GH 13318
  139:     values = range(5)
  140:     msg = "Bin labels must either be False, None or passed in as a list-like argument"
  141:     with pytest.raises(ValueError, match=msg):
  142:         qcut(values, 4, labels=labels)
  143: 
  144: 
  145: @pytest.mark.parametrize("labels", [["a", "b", "c"], list(range(3))])
  146: def test_qcut_wrong_length_labels(labels):
  147:     # GH 13318
  148:     values = range(10)
  149:     msg = "Bin labels must be one fewer than the number of bin edges"
  150:     with pytest.raises(ValueError, match=msg):
  151:         qcut(values, 4, labels=labels)
  152: 
  153: 
  154: @pytest.mark.parametrize(
  155:     "labels, expected",
  156:     [
  157:         (["a", "b", "c"], Categorical(["a", "b", "c"], ordered=True)),
  158:         (list(range(3)), Categorical([0, 1, 2], ordered=True)),
  159:     ],
  160: )
  161: def test_qcut_list_like_labels(labels, expected):
  162:     # GH 13318
  163:     values = range(3)
  164:     result = qcut(values, 3, labels=labels)
  165:     tm.assert_categorical_equal(result, expected)
  166: 
  167: 
  168: @pytest.mark.parametrize(
  169:     "kwargs,msg",
  170:     [
  171:         ({"duplicates": "drop"}, None),
  172:         ({}, "Bin edges must be unique"),
  173:         ({"duplicates": "raise"}, "Bin edges must be unique"),
  174:         ({"duplicates": "foo"}, "invalid value for 'duplicates' parameter"),
  175:     ],
  176: )
  177: def test_qcut_duplicates_bin(kwargs, msg):
  178:     # see gh-7751
  179:     values = [0, 0, 0, 0, 1, 2, 3]
  180: 
  181:     if msg is not None:
  182:         with pytest.raises(ValueError, match=msg):
  183:             qcut(values, 3, **kwargs)
  184:     else:
  185:         result = qcut(values, 3, **kwargs)
  186:         expected = IntervalIndex([Interval(-0.001, 1), Interval(1, 3)])
  187:         tm.assert_index_equal(result.categories, expected)
  188: 
  189: 
  190: @pytest.mark.parametrize(
  191:     "data,start,end", [(9.0, 8.999, 9.0), (0.0, -0.001, 0.0), (-9.0, -9.001, -9.0)]
  192: )
  193: @pytest.mark.parametrize("length", [1, 2])
  194: @pytest.mark.parametrize("labels", [None, False])
  195: def test_single_quantile(data, start, end, length, labels):
  196:     # see gh-15431
  197:     ser = Series([data] * length)
  198:     result = qcut(ser, 1, labels=labels)
  199: 
  200:     if labels is None:
  201:         intervals = IntervalIndex([Interval(start, end)] * length, closed="right")
  202:         expected = Series(intervals).astype(CategoricalDtype(ordered=True))
  203:     else:
  204:         expected = Series([0] * length, dtype=np.intp)
  205: 
  206:     tm.assert_series_equal(result, expected)
  207: 
  208: 
  209: @pytest.mark.parametrize(
  210:     "ser",
  211:     [
  212:         Series(DatetimeIndex(["20180101", NaT, "20180103"])),
  213:         Series(TimedeltaIndex(["0 days", NaT, "2 days"])),
  214:     ],
  215:     ids=lambda x: str(x.dtype),
  216: )
  217: def test_qcut_nat(ser, unit):
  218:     # see gh-19768
  219:     ser = ser.dt.as_unit(unit)
  220:     td = Timedelta(1, unit=unit).as_unit(unit)
  221: 
  222:     left = Series([ser[0] - td, np.nan, ser[2] - Day()], dtype=ser.dtype)
  223:     right = Series([ser[2] - Day(), np.nan, ser[2]], dtype=ser.dtype)
  224:     intervals = IntervalIndex.from_arrays(left, right)
  225:     expected = Series(Categorical(intervals, ordered=True))
  226: 
  227:     result = qcut(ser, 2)
  228:     tm.assert_series_equal(result, expected)
  229: 
  230: 
  231: @pytest.mark.parametrize("bins", [3, np.linspace(0, 1, 4)])
  232: def test_datetime_tz_qcut(bins):
  233:     # see gh-19872
  234:     tz = "US/Eastern"
  235:     ser = Series(date_range("20130101", periods=3, tz=tz))
  236: 
  237:     result = qcut(ser, bins)
  238:     expected = Series(
  239:         IntervalIndex(
  240:             [
  241:                 Interval(
  242:                     Timestamp("2012-12-31 23:59:59.999999999", tz=tz),
  243:                     Timestamp("2013-01-01 16:00:00", tz=tz),
  244:                 ),
  245:                 Interval(
  246:                     Timestamp("2013-01-01 16:00:00", tz=tz),
  247:                     Timestamp("2013-01-02 08:00:00", tz=tz),
  248:                 ),
  249:                 Interval(
  250:                     Timestamp("2013-01-02 08:00:00", tz=tz),
  251:                     Timestamp("2013-01-03 00:00:00", tz=tz),
  252:                 ),
  253:             ]
  254:         )
  255:     ).astype(CategoricalDtype(ordered=True))
  256:     tm.assert_series_equal(result, expected)
  257: 
  258: 
  259: @pytest.mark.parametrize(
  260:     "arg,expected_bins",
  261:     [
  262:         [
  263:             timedelta_range("1day", periods=3),
  264:             TimedeltaIndex(["1 days", "2 days", "3 days"]),
  265:         ],
  266:         [
  267:             date_range("20180101", periods=3),
  268:             DatetimeIndex(["2018-01-01", "2018-01-02", "2018-01-03"]),
  269:         ],
  270:     ],
  271: )
  272: def test_date_like_qcut_bins(arg, expected_bins):
  273:     # see gh-19891
  274:     ser = Series(arg)
  275:     result, result_bins = qcut(ser, 2, retbins=True)
  276:     tm.assert_index_equal(result_bins, expected_bins)
  277: 
  278: 
  279: @pytest.mark.parametrize("bins", [6, 7])
  280: @pytest.mark.parametrize(
  281:     "box, compare",
  282:     [
  283:         (Series, tm.assert_series_equal),
  284:         (np.array, tm.assert_categorical_equal),
  285:         (list, tm.assert_equal),
  286:     ],
  287: )
  288: def test_qcut_bool_coercion_to_int(bins, box, compare):
  289:     # issue 20303
  290:     data_expected = box([0, 1, 1, 0, 1] * 10)
  291:     data_result = box([False, True, True, False, True] * 10)
  292:     expected = qcut(data_expected, bins, duplicates="drop")
  293:     result = qcut(data_result, bins, duplicates="drop")
  294:     compare(result, expected)
  295: 
  296: 
  297: @pytest.mark.parametrize("q", [2, 5, 10])
  298: def test_qcut_nullable_integer(q, any_numeric_ea_dtype):
  299:     arr = pd.array(np.arange(100), dtype=any_numeric_ea_dtype)
  300:     arr[::2] = pd.NA
  301: 
  302:     result = qcut(arr, q)
  303:     expected = qcut(arr.astype(float), q)
  304: 
  305:     tm.assert_categorical_equal(result, expected)
