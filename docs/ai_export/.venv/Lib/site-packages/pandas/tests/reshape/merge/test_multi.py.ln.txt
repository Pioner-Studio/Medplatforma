    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     Index,
   10:     MultiIndex,
   11:     RangeIndex,
   12:     Series,
   13:     Timestamp,
   14:     option_context,
   15: )
   16: import pandas._testing as tm
   17: from pandas.core.reshape.concat import concat
   18: from pandas.core.reshape.merge import merge
   19: 
   20: 
   21: @pytest.fixture
   22: def left():
   23:     """left dataframe (not multi-indexed) for multi-index join tests"""
   24:     # a little relevant example with NAs
   25:     key1 = ["bar", "bar", "bar", "foo", "foo", "baz", "baz", "qux", "qux", "snap"]
   26:     key2 = ["two", "one", "three", "one", "two", "one", "two", "two", "three", "one"]
   27: 
   28:     data = np.random.default_rng(2).standard_normal(len(key1))
   29:     return DataFrame({"key1": key1, "key2": key2, "data": data})
   30: 
   31: 
   32: @pytest.fixture
   33: def right(multiindex_dataframe_random_data):
   34:     """right dataframe (multi-indexed) for multi-index join tests"""
   35:     df = multiindex_dataframe_random_data
   36:     df.index.names = ["key1", "key2"]
   37: 
   38:     df.columns = ["j_one", "j_two", "j_three"]
   39:     return df
   40: 
   41: 
   42: @pytest.fixture
   43: def left_multi():
   44:     return DataFrame(
   45:         {
   46:             "Origin": ["A", "A", "B", "B", "C"],
   47:             "Destination": ["A", "B", "A", "C", "A"],
   48:             "Period": ["AM", "AM", "IP", "AM", "OP"],
   49:             "TripPurp": ["hbw", "nhb", "hbo", "nhb", "hbw"],
   50:             "Trips": [1987, 3647, 2470, 4296, 4444],
   51:         },
   52:         columns=["Origin", "Destination", "Period", "TripPurp", "Trips"],
   53:     ).set_index(["Origin", "Destination", "Period", "TripPurp"])
   54: 
   55: 
   56: @pytest.fixture
   57: def right_multi():
   58:     return DataFrame(
   59:         {
   60:             "Origin": ["A", "A", "B", "B", "C", "C", "E"],
   61:             "Destination": ["A", "B", "A", "B", "A", "B", "F"],
   62:             "Period": ["AM", "AM", "IP", "AM", "OP", "IP", "AM"],
   63:             "LinkType": ["a", "b", "c", "b", "a", "b", "a"],
   64:             "Distance": [100, 80, 90, 80, 75, 35, 55],
   65:         },
   66:         columns=["Origin", "Destination", "Period", "LinkType", "Distance"],
   67:     ).set_index(["Origin", "Destination", "Period", "LinkType"])
   68: 
   69: 
   70: @pytest.fixture
   71: def on_cols_multi():
   72:     return ["Origin", "Destination", "Period"]
   73: 
   74: 
   75: class TestMergeMulti:
   76:     def test_merge_on_multikey(self, left, right, join_type):
   77:         on_cols = ["key1", "key2"]
   78:         result = left.join(right, on=on_cols, how=join_type).reset_index(drop=True)
   79: 
   80:         expected = merge(left, right.reset_index(), on=on_cols, how=join_type)
   81: 
   82:         tm.assert_frame_equal(result, expected)
   83: 
   84:         result = left.join(right, on=on_cols, how=join_type, sort=True).reset_index(
   85:             drop=True
   86:         )
   87: 
   88:         expected = merge(
   89:             left, right.reset_index(), on=on_cols, how=join_type, sort=True
   90:         )
   91: 
   92:         tm.assert_frame_equal(result, expected)
   93: 
   94:     @pytest.mark.parametrize(
   95:         "infer_string", [False, pytest.param(True, marks=td.skip_if_no("pyarrow"))]
   96:     )
   97:     @pytest.mark.parametrize("sort", [True, False])
   98:     def test_left_join_multi_index(self, sort, infer_string):
   99:         with option_context("future.infer_string", infer_string):
  100:             icols = ["1st", "2nd", "3rd"]
  101: 
  102:             def bind_cols(df):
  103:                 iord = lambda a: 0 if a != a else ord(a)
  104:                 f = lambda ts: ts.map(iord) - ord("a")
  105:                 return f(df["1st"]) + f(df["3rd"]) * 1e2 + df["2nd"].fillna(0) * 10
  106: 
  107:             def run_asserts(left, right, sort):
  108:                 res = left.join(right, on=icols, how="left", sort=sort)
  109: 
  110:                 assert len(left) < len(res) + 1
  111:                 assert not res["4th"].isna().any()
  112:                 assert not res["5th"].isna().any()
  113: 
  114:                 tm.assert_series_equal(res["4th"], -res["5th"], check_names=False)
  115:                 result = bind_cols(res.iloc[:, :-2])
  116:                 tm.assert_series_equal(res["4th"], result, check_names=False)
  117:                 assert result.name is None
  118: 
  119:                 if sort:
  120:                     tm.assert_frame_equal(res, res.sort_values(icols, kind="mergesort"))
  121: 
  122:                 out = merge(left, right.reset_index(), on=icols, sort=sort, how="left")
  123: 
  124:                 res.index = RangeIndex(len(res))
  125:                 tm.assert_frame_equal(out, res)
  126: 
  127:             lc = list(map(chr, np.arange(ord("a"), ord("z") + 1)))
  128:             left = DataFrame(
  129:                 np.random.default_rng(2).choice(lc, (50, 2)), columns=["1st", "3rd"]
  130:             )
  131:             # Explicit cast to float to avoid implicit cast when setting nan
  132:             left.insert(
  133:                 1,
  134:                 "2nd",
  135:                 np.random.default_rng(2).integers(0, 10, len(left)).astype("float"),
  136:             )
  137: 
  138:             i = np.random.default_rng(2).permutation(len(left))
  139:             right = left.iloc[i].copy()
  140: 
  141:             left["4th"] = bind_cols(left)
  142:             right["5th"] = -bind_cols(right)
  143:             right.set_index(icols, inplace=True)
  144: 
  145:             run_asserts(left, right, sort)
  146: 
  147:             # inject some nulls
  148:             left.loc[1::4, "1st"] = np.nan
  149:             left.loc[2::5, "2nd"] = np.nan
  150:             left.loc[3::6, "3rd"] = np.nan
  151:             left["4th"] = bind_cols(left)
  152: 
  153:             i = np.random.default_rng(2).permutation(len(left))
  154:             right = left.iloc[i, :-1]
  155:             right["5th"] = -bind_cols(right)
  156:             right.set_index(icols, inplace=True)
  157: 
  158:             run_asserts(left, right, sort)
  159: 
  160:     @pytest.mark.parametrize("sort", [False, True])
  161:     def test_merge_right_vs_left(self, left, right, sort):
  162:         # compare left vs right merge with multikey
  163:         on_cols = ["key1", "key2"]
  164:         merged_left_right = left.merge(
  165:             right, left_on=on_cols, right_index=True, how="left", sort=sort
  166:         )
  167: 
  168:         merge_right_left = right.merge(
  169:             left, right_on=on_cols, left_index=True, how="right", sort=sort
  170:         )
  171: 
  172:         # Reorder columns
  173:         merge_right_left = merge_right_left[merged_left_right.columns]
  174: 
  175:         tm.assert_frame_equal(merged_left_right, merge_right_left)
  176: 
  177:     def test_merge_multiple_cols_with_mixed_cols_index(self):
  178:         # GH29522
  179:         s = Series(
  180:             range(6),
  181:             MultiIndex.from_product([["A", "B"], [1, 2, 3]], names=["lev1", "lev2"]),
  182:             name="Amount",
  183:         )
  184:         df = DataFrame({"lev1": list("AAABBB"), "lev2": [1, 2, 3, 1, 2, 3], "col": 0})
  185:         result = merge(df, s.reset_index(), on=["lev1", "lev2"])
  186:         expected = DataFrame(
  187:             {
  188:                 "lev1": list("AAABBB"),
  189:                 "lev2": [1, 2, 3, 1, 2, 3],
  190:                 "col": [0] * 6,
  191:                 "Amount": range(6),
  192:             }
  193:         )
  194:         tm.assert_frame_equal(result, expected)
  195: 
  196:     def test_compress_group_combinations(self):
  197:         # ~ 40000000 possible unique groups
  198:         key1 = [str(i) for i in range(10000)]
  199:         key1 = np.tile(key1, 2)
  200:         key2 = key1[::-1]
  201: 
  202:         df = DataFrame(
  203:             {
  204:                 "key1": key1,
  205:                 "key2": key2,
  206:                 "value1": np.random.default_rng(2).standard_normal(20000),
  207:             }
  208:         )
  209: 
  210:         df2 = DataFrame(
  211:             {
  212:                 "key1": key1[::2],
  213:                 "key2": key2[::2],
  214:                 "value2": np.random.default_rng(2).standard_normal(10000),
  215:             }
  216:         )
  217: 
  218:         # just to hit the label compression code path
  219:         merge(df, df2, how="outer")
  220: 
  221:     def test_left_join_index_preserve_order(self):
  222:         on_cols = ["k1", "k2"]
  223:         left = DataFrame(
  224:             {
  225:                 "k1": [0, 1, 2] * 8,
  226:                 "k2": ["foo", "bar"] * 12,
  227:                 "v": np.array(np.arange(24), dtype=np.int64),
  228:             }
  229:         )
  230: 
  231:         index = MultiIndex.from_tuples([(2, "bar"), (1, "foo")])
  232:         right = DataFrame({"v2": [5, 7]}, index=index)
  233: 
  234:         result = left.join(right, on=on_cols)
  235: 
  236:         expected = left.copy()
  237:         expected["v2"] = np.nan
  238:         expected.loc[(expected.k1 == 2) & (expected.k2 == "bar"), "v2"] = 5
  239:         expected.loc[(expected.k1 == 1) & (expected.k2 == "foo"), "v2"] = 7
  240: 
  241:         tm.assert_frame_equal(result, expected)
  242: 
  243:         result.sort_values(on_cols, kind="mergesort", inplace=True)
  244:         expected = left.join(right, on=on_cols, sort=True)
  245: 
  246:         tm.assert_frame_equal(result, expected)
  247: 
  248:         # test join with multi dtypes blocks
  249:         left = DataFrame(
  250:             {
  251:                 "k1": [0, 1, 2] * 8,
  252:                 "k2": ["foo", "bar"] * 12,
  253:                 "k3": np.array([0, 1, 2] * 8, dtype=np.float32),
  254:                 "v": np.array(np.arange(24), dtype=np.int32),
  255:             }
  256:         )
  257: 
  258:         index = MultiIndex.from_tuples([(2, "bar"), (1, "foo")])
  259:         right = DataFrame({"v2": [5, 7]}, index=index)
  260: 
  261:         result = left.join(right, on=on_cols)
  262: 
  263:         expected = left.copy()
  264:         expected["v2"] = np.nan
  265:         expected.loc[(expected.k1 == 2) & (expected.k2 == "bar"), "v2"] = 5
  266:         expected.loc[(expected.k1 == 1) & (expected.k2 == "foo"), "v2"] = 7
  267: 
  268:         tm.assert_frame_equal(result, expected)
  269: 
  270:         result = result.sort_values(on_cols, kind="mergesort")
  271:         expected = left.join(right, on=on_cols, sort=True)
  272: 
  273:         tm.assert_frame_equal(result, expected)
  274: 
  275:     def test_left_join_index_multi_match_multiindex(self):
  276:         left = DataFrame(
  277:             [
  278:                 ["X", "Y", "C", "a"],
  279:                 ["W", "Y", "C", "e"],
  280:                 ["V", "Q", "A", "h"],
  281:                 ["V", "R", "D", "i"],
  282:                 ["X", "Y", "D", "b"],
  283:                 ["X", "Y", "A", "c"],
  284:                 ["W", "Q", "B", "f"],
  285:                 ["W", "R", "C", "g"],
  286:                 ["V", "Y", "C", "j"],
  287:                 ["X", "Y", "B", "d"],
  288:             ],
  289:             columns=["cola", "colb", "colc", "tag"],
  290:             index=[3, 2, 0, 1, 7, 6, 4, 5, 9, 8],
  291:         )
  292: 
  293:         right = DataFrame(
  294:             [
  295:                 ["W", "R", "C", 0],
  296:                 ["W", "Q", "B", 3],
  297:                 ["W", "Q", "B", 8],
  298:                 ["X", "Y", "A", 1],
  299:                 ["X", "Y", "A", 4],
  300:                 ["X", "Y", "B", 5],
  301:                 ["X", "Y", "C", 6],
  302:                 ["X", "Y", "C", 9],
  303:                 ["X", "Q", "C", -6],
  304:                 ["X", "R", "C", -9],
  305:                 ["V", "Y", "C", 7],
  306:                 ["V", "R", "D", 2],
  307:                 ["V", "R", "D", -1],
  308:                 ["V", "Q", "A", -3],
  309:             ],
  310:             columns=["col1", "col2", "col3", "val"],
  311:         ).set_index(["col1", "col2", "col3"])
  312: 
  313:         result = left.join(right, on=["cola", "colb", "colc"], how="left")
  314: 
  315:         expected = DataFrame(
  316:             [
  317:                 ["X", "Y", "C", "a", 6],
  318:                 ["X", "Y", "C", "a", 9],
  319:                 ["W", "Y", "C", "e", np.nan],
  320:                 ["V", "Q", "A", "h", -3],
  321:                 ["V", "R", "D", "i", 2],
  322:                 ["V", "R", "D", "i", -1],
  323:                 ["X", "Y", "D", "b", np.nan],
  324:                 ["X", "Y", "A", "c", 1],
  325:                 ["X", "Y", "A", "c", 4],
  326:                 ["W", "Q", "B", "f", 3],
  327:                 ["W", "Q", "B", "f", 8],
  328:                 ["W", "R", "C", "g", 0],
  329:                 ["V", "Y", "C", "j", 7],
  330:                 ["X", "Y", "B", "d", 5],
  331:             ],
  332:             columns=["cola", "colb", "colc", "tag", "val"],
  333:             index=[3, 3, 2, 0, 1, 1, 7, 6, 6, 4, 4, 5, 9, 8],
  334:         )
  335: 
  336:         tm.assert_frame_equal(result, expected)
  337: 
  338:         result = left.join(right, on=["cola", "colb", "colc"], how="left", sort=True)
  339: 
  340:         expected = expected.sort_values(["cola", "colb", "colc"], kind="mergesort")
  341: 
  342:         tm.assert_frame_equal(result, expected)
  343: 
  344:     def test_left_join_index_multi_match(self):
  345:         left = DataFrame(
  346:             [["c", 0], ["b", 1], ["a", 2], ["b", 3]],
  347:             columns=["tag", "val"],
  348:             index=[2, 0, 1, 3],
  349:         )
  350: 
  351:         right = DataFrame(
  352:             [
  353:                 ["a", "v"],
  354:                 ["c", "w"],
  355:                 ["c", "x"],
  356:                 ["d", "y"],
  357:                 ["a", "z"],
  358:                 ["c", "r"],
  359:                 ["e", "q"],
  360:                 ["c", "s"],
  361:             ],
  362:             columns=["tag", "char"],
  363:         ).set_index("tag")
  364: 
  365:         result = left.join(right, on="tag", how="left")
  366: 
  367:         expected = DataFrame(
  368:             [
  369:                 ["c", 0, "w"],
  370:                 ["c", 0, "x"],
  371:                 ["c", 0, "r"],
  372:                 ["c", 0, "s"],
  373:                 ["b", 1, np.nan],
  374:                 ["a", 2, "v"],
  375:                 ["a", 2, "z"],
  376:                 ["b", 3, np.nan],
  377:             ],
  378:             columns=["tag", "val", "char"],
  379:             index=[2, 2, 2, 2, 0, 1, 1, 3],
  380:         )
  381: 
  382:         tm.assert_frame_equal(result, expected)
  383: 
  384:         result = left.join(right, on="tag", how="left", sort=True)
  385:         expected2 = expected.sort_values("tag", kind="mergesort")
  386: 
  387:         tm.assert_frame_equal(result, expected2)
  388: 
  389:         # GH7331 - maintain left frame order in left merge
  390:         result = merge(left, right.reset_index(), how="left", on="tag")
  391:         expected.index = RangeIndex(len(expected))
  392:         tm.assert_frame_equal(result, expected)
  393: 
  394:     def test_left_merge_na_buglet(self):
  395:         left = DataFrame(
  396:             {
  397:                 "id": list("abcde"),
  398:                 "v1": np.random.default_rng(2).standard_normal(5),
  399:                 "v2": np.random.default_rng(2).standard_normal(5),
  400:                 "dummy": list("abcde"),
  401:                 "v3": np.random.default_rng(2).standard_normal(5),
  402:             },
  403:             columns=["id", "v1", "v2", "dummy", "v3"],
  404:         )
  405:         right = DataFrame(
  406:             {
  407:                 "id": ["a", "b", np.nan, np.nan, np.nan],
  408:                 "sv3": [1.234, 5.678, np.nan, np.nan, np.nan],
  409:             }
  410:         )
  411: 
  412:         result = merge(left, right, on="id", how="left")
  413: 
  414:         rdf = right.drop(["id"], axis=1)
  415:         expected = left.join(rdf)
  416:         tm.assert_frame_equal(result, expected)
  417: 
  418:     def test_merge_na_keys(self):
  419:         data = [
  420:             [1950, "A", 1.5],
  421:             [1950, "B", 1.5],
  422:             [1955, "B", 1.5],
  423:             [1960, "B", np.nan],
  424:             [1970, "B", 4.0],
  425:             [1950, "C", 4.0],
  426:             [1960, "C", np.nan],
  427:             [1965, "C", 3.0],
  428:             [1970, "C", 4.0],
  429:         ]
  430: 
  431:         frame = DataFrame(data, columns=["year", "panel", "data"])
  432: 
  433:         other_data = [
  434:             [1960, "A", np.nan],
  435:             [1970, "A", np.nan],
  436:             [1955, "A", np.nan],
  437:             [1965, "A", np.nan],
  438:             [1965, "B", np.nan],
  439:             [1955, "C", np.nan],
  440:         ]
  441:         other = DataFrame(other_data, columns=["year", "panel", "data"])
  442: 
  443:         result = frame.merge(other, how="outer")
  444: 
  445:         expected = frame.fillna(-999).merge(other.fillna(-999), how="outer")
  446:         expected = expected.replace(-999, np.nan)
  447: 
  448:         tm.assert_frame_equal(result, expected)
  449: 
  450:     @pytest.mark.parametrize("klass", [None, np.asarray, Series, Index])
  451:     def test_merge_datetime_index(self, klass):
  452:         # see gh-19038
  453:         df = DataFrame(
  454:             [1, 2, 3], ["2016-01-01", "2017-01-01", "2018-01-01"], columns=["a"]
  455:         )
  456:         df.index = pd.to_datetime(df.index)
  457:         on_vector = df.index.year
  458: 
  459:         if klass is not None:
  460:             on_vector = klass(on_vector)
  461: 
  462:         exp_years = np.array([2016, 2017, 2018], dtype=np.int32)
  463:         expected = DataFrame({"a": [1, 2, 3], "key_1": exp_years})
  464: 
  465:         result = df.merge(df, on=["a", on_vector], how="inner")
  466:         tm.assert_frame_equal(result, expected)
  467: 
  468:         expected = DataFrame({"key_0": exp_years, "a_x": [1, 2, 3], "a_y": [1, 2, 3]})
  469: 
  470:         result = df.merge(df, on=[df.index.year], how="inner")
  471:         tm.assert_frame_equal(result, expected)
  472: 
  473:     @pytest.mark.parametrize("merge_type", ["left", "right"])
  474:     def test_merge_datetime_multi_index_empty_df(self, merge_type):
  475:         # see gh-36895
  476: 
  477:         left = DataFrame(
  478:             data={
  479:                 "data": [1.5, 1.5],
  480:             },
  481:             index=MultiIndex.from_tuples(
  482:                 [[Timestamp("1950-01-01"), "A"], [Timestamp("1950-01-02"), "B"]],
  483:                 names=["date", "panel"],
  484:             ),
  485:         )
  486: 
  487:         right = DataFrame(
  488:             index=MultiIndex.from_tuples([], names=["date", "panel"]), columns=["state"]
  489:         )
  490: 
  491:         expected_index = MultiIndex.from_tuples(
  492:             [[Timestamp("1950-01-01"), "A"], [Timestamp("1950-01-02"), "B"]],
  493:             names=["date", "panel"],
  494:         )
  495: 
  496:         if merge_type == "left":
  497:             expected = DataFrame(
  498:                 data={
  499:                     "data": [1.5, 1.5],
  500:                     "state": np.array([np.nan, np.nan], dtype=object),
  501:                 },
  502:                 index=expected_index,
  503:             )
  504:             results_merge = left.merge(right, how="left", on=["date", "panel"])
  505:             results_join = left.join(right, how="left")
  506:         else:
  507:             expected = DataFrame(
  508:                 data={
  509:                     "state": np.array([np.nan, np.nan], dtype=object),
  510:                     "data": [1.5, 1.5],
  511:                 },
  512:                 index=expected_index,
  513:             )
  514:             results_merge = right.merge(left, how="right", on=["date", "panel"])
  515:             results_join = right.join(left, how="right")
  516: 
  517:         tm.assert_frame_equal(results_merge, expected)
  518:         tm.assert_frame_equal(results_join, expected)
  519: 
  520:     @pytest.fixture
  521:     def household(self):
  522:         household = DataFrame(
  523:             {
  524:                 "household_id": [1, 2, 3],
  525:                 "male": [0, 1, 0],
  526:                 "wealth": [196087.3, 316478.7, 294750],
  527:             },
  528:             columns=["household_id", "male", "wealth"],
  529:         ).set_index("household_id")
  530:         return household
  531: 
  532:     @pytest.fixture
  533:     def portfolio(self):
  534:         portfolio = DataFrame(
  535:             {
  536:                 "household_id": [1, 2, 2, 3, 3, 3, 4],
  537:                 "asset_id": [
  538:                     "nl0000301109",
  539:                     "nl0000289783",
  540:                     "gb00b03mlx29",
  541:                     "gb00b03mlx29",
  542:                     "lu0197800237",
  543:                     "nl0000289965",
  544:                     np.nan,
  545:                 ],
  546:                 "name": [
  547:                     "ABN Amro",
  548:                     "Robeco",
  549:                     "Royal Dutch Shell",
  550:                     "Royal Dutch Shell",
  551:                     "AAB Eastern Europe Equity Fund",
  552:                     "Postbank BioTech Fonds",
  553:                     np.nan,
  554:                 ],
  555:                 "share": [1.0, 0.4, 0.6, 0.15, 0.6, 0.25, 1.0],
  556:             },
  557:             columns=["household_id", "asset_id", "name", "share"],
  558:         ).set_index(["household_id", "asset_id"])
  559:         return portfolio
  560: 
  561:     @pytest.fixture
  562:     def expected(self):
  563:         expected = (
  564:             DataFrame(
  565:                 {
  566:                     "male": [0, 1, 1, 0, 0, 0],
  567:                     "wealth": [
  568:                         196087.3,
  569:                         316478.7,
  570:                         316478.7,
  571:                         294750.0,
  572:                         294750.0,
  573:                         294750.0,
  574:                     ],
  575:                     "name": [
  576:                         "ABN Amro",
  577:                         "Robeco",
  578:                         "Royal Dutch Shell",
  579:                         "Royal Dutch Shell",
  580:                         "AAB Eastern Europe Equity Fund",
  581:                         "Postbank BioTech Fonds",
  582:                     ],
  583:                     "share": [1.00, 0.40, 0.60, 0.15, 0.60, 0.25],
  584:                     "household_id": [1, 2, 2, 3, 3, 3],
  585:                     "asset_id": [
  586:                         "nl0000301109",
  587:                         "nl0000289783",
  588:                         "gb00b03mlx29",
  589:                         "gb00b03mlx29",
  590:                         "lu0197800237",
  591:                         "nl0000289965",
  592:                     ],
  593:                 }
  594:             )
  595:             .set_index(["household_id", "asset_id"])
  596:             .reindex(columns=["male", "wealth", "name", "share"])
  597:         )
  598:         return expected
  599: 
  600:     def test_join_multi_levels(self, portfolio, household, expected):
  601:         portfolio = portfolio.copy()
  602:         household = household.copy()
  603: 
  604:         # GH 3662
  605:         # merge multi-levels
  606:         result = household.join(portfolio, how="inner")
  607:         tm.assert_frame_equal(result, expected)
  608: 
  609:     def test_join_multi_levels_merge_equivalence(self, portfolio, household, expected):
  610:         portfolio = portfolio.copy()
  611:         household = household.copy()
  612: 
  613:         # equivalency
  614:         result = merge(
  615:             household.reset_index(),
  616:             portfolio.reset_index(),
  617:             on=["household_id"],
  618:             how="inner",
  619:         ).set_index(["household_id", "asset_id"])
  620:         tm.assert_frame_equal(result, expected)
  621: 
  622:     def test_join_multi_levels_outer(self, portfolio, household, expected):
  623:         portfolio = portfolio.copy()
  624:         household = household.copy()
  625: 
  626:         result = household.join(portfolio, how="outer")
  627:         expected = concat(
  628:             [
  629:                 expected,
  630:                 (
  631:                     DataFrame(
  632:                         {"share": [1.00]},
  633:                         index=MultiIndex.from_tuples(
  634:                             [(4, np.nan)], names=["household_id", "asset_id"]
  635:                         ),
  636:                     )
  637:                 ),
  638:             ],
  639:             axis=0,
  640:             sort=True,
  641:         ).reindex(columns=expected.columns)
  642:         tm.assert_frame_equal(result, expected, check_index_type=False)
  643: 
  644:     def test_join_multi_levels_invalid(self, portfolio, household):
  645:         portfolio = portfolio.copy()
  646:         household = household.copy()
  647: 
  648:         # invalid cases
  649:         household.index.name = "foo"
  650: 
  651:         with pytest.raises(
  652:             ValueError, match="cannot join with no overlapping index names"
  653:         ):
  654:             household.join(portfolio, how="inner")
  655: 
  656:         portfolio2 = portfolio.copy()
  657:         portfolio2.index.set_names(["household_id", "foo"])
  658: 
  659:         with pytest.raises(ValueError, match="columns overlap but no suffix specified"):
  660:             portfolio2.join(portfolio, how="inner")
  661: 
  662:     def test_join_multi_levels2(self):
  663:         # some more advanced merges
  664:         # GH6360
  665:         household = DataFrame(
  666:             {
  667:                 "household_id": [1, 2, 2, 3, 3, 3, 4],
  668:                 "asset_id": [
  669:                     "nl0000301109",
  670:                     "nl0000301109",
  671:                     "gb00b03mlx29",
  672:                     "gb00b03mlx29",
  673:                     "lu0197800237",
  674:                     "nl0000289965",
  675:                     np.nan,
  676:                 ],
  677:                 "share": [1.0, 0.4, 0.6, 0.15, 0.6, 0.25, 1.0],
  678:             },
  679:             columns=["household_id", "asset_id", "share"],
  680:         ).set_index(["household_id", "asset_id"])
  681: 
  682:         log_return = DataFrame(
  683:             {
  684:                 "asset_id": [
  685:                     "gb00b03mlx29",
  686:                     "gb00b03mlx29",
  687:                     "gb00b03mlx29",
  688:                     "lu0197800237",
  689:                     "lu0197800237",
  690:                 ],
  691:                 "t": [233, 234, 235, 180, 181],
  692:                 "log_return": [
  693:                     0.09604978,
  694:                     -0.06524096,
  695:                     0.03532373,
  696:                     0.03025441,
  697:                     0.036997,
  698:                 ],
  699:             }
  700:         ).set_index(["asset_id", "t"])
  701: 
  702:         expected = (
  703:             DataFrame(
  704:                 {
  705:                     "household_id": [2, 2, 2, 3, 3, 3, 3, 3],
  706:                     "asset_id": [
  707:                         "gb00b03mlx29",
  708:                         "gb00b03mlx29",
  709:                         "gb00b03mlx29",
  710:                         "gb00b03mlx29",
  711:                         "gb00b03mlx29",
  712:                         "gb00b03mlx29",
  713:                         "lu0197800237",
  714:                         "lu0197800237",
  715:                     ],
  716:                     "t": [233, 234, 235, 233, 234, 235, 180, 181],
  717:                     "share": [0.6, 0.6, 0.6, 0.15, 0.15, 0.15, 0.6, 0.6],
  718:                     "log_return": [
  719:                         0.09604978,
  720:                         -0.06524096,
  721:                         0.03532373,
  722:                         0.09604978,
  723:                         -0.06524096,
  724:                         0.03532373,
  725:                         0.03025441,
  726:                         0.036997,
  727:                     ],
  728:                 }
  729:             )
  730:             .set_index(["household_id", "asset_id", "t"])
  731:             .reindex(columns=["share", "log_return"])
  732:         )
  733: 
  734:         # this is the equivalency
  735:         result = merge(
  736:             household.reset_index(),
  737:             log_return.reset_index(),
  738:             on=["asset_id"],
  739:             how="inner",
  740:         ).set_index(["household_id", "asset_id", "t"])
  741:         tm.assert_frame_equal(result, expected)
  742: 
  743:         expected = (
  744:             DataFrame(
  745:                 {
  746:                     "household_id": [2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 2, 4],
  747:                     "asset_id": [
  748:                         "gb00b03mlx29",
  749:                         "gb00b03mlx29",
  750:                         "gb00b03mlx29",
  751:                         "gb00b03mlx29",
  752:                         "gb00b03mlx29",
  753:                         "gb00b03mlx29",
  754:                         "lu0197800237",
  755:                         "lu0197800237",
  756:                         "nl0000289965",
  757:                         "nl0000301109",
  758:                         "nl0000301109",
  759:                         None,
  760:                     ],
  761:                     "t": [
  762:                         233,
  763:                         234,
  764:                         235,
  765:                         233,
  766:                         234,
  767:                         235,
  768:                         180,
  769:                         181,
  770:                         None,
  771:                         None,
  772:                         None,
  773:                         None,
  774:                     ],
  775:                     "share": [
  776:                         0.6,
  777:                         0.6,
  778:                         0.6,
  779:                         0.15,
  780:                         0.15,
  781:                         0.15,
  782:                         0.6,
  783:                         0.6,
  784:                         0.25,
  785:                         1.0,
  786:                         0.4,
  787:                         1.0,
  788:                     ],
  789:                     "log_return": [
  790:                         0.09604978,
  791:                         -0.06524096,
  792:                         0.03532373,
  793:                         0.09604978,
  794:                         -0.06524096,
  795:                         0.03532373,
  796:                         0.03025441,
  797:                         0.036997,
  798:                         None,
  799:                         None,
  800:                         None,
  801:                         None,
  802:                     ],
  803:                 }
  804:             )
  805:             .set_index(["household_id", "asset_id", "t"])
  806:             .reindex(columns=["share", "log_return"])
  807:         )
  808: 
  809:         result = merge(
  810:             household.reset_index(),
  811:             log_return.reset_index(),
  812:             on=["asset_id"],
  813:             how="outer",
  814:         ).set_index(["household_id", "asset_id", "t"])
  815: 
  816:         tm.assert_frame_equal(result, expected)
  817: 
  818: 
  819: class TestJoinMultiMulti:
  820:     def test_join_multi_multi(self, left_multi, right_multi, join_type, on_cols_multi):
  821:         left_names = left_multi.index.names
  822:         right_names = right_multi.index.names
  823:         if join_type == "right":
  824:             level_order = right_names + left_names.difference(right_names)
  825:         else:
  826:             level_order = left_names + right_names.difference(left_names)
  827:         # Multi-index join tests
  828:         expected = (
  829:             merge(
  830:                 left_multi.reset_index(),
  831:                 right_multi.reset_index(),
  832:                 how=join_type,
  833:                 on=on_cols_multi,
  834:             )
  835:             .set_index(level_order)
  836:             .sort_index()
  837:         )
  838: 
  839:         result = left_multi.join(right_multi, how=join_type).sort_index()
  840:         tm.assert_frame_equal(result, expected)
  841: 
  842:     def test_join_multi_empty_frames(
  843:         self, left_multi, right_multi, join_type, on_cols_multi
  844:     ):
  845:         left_multi = left_multi.drop(columns=left_multi.columns)
  846:         right_multi = right_multi.drop(columns=right_multi.columns)
  847: 
  848:         left_names = left_multi.index.names
  849:         right_names = right_multi.index.names
  850:         if join_type == "right":
  851:             level_order = right_names + left_names.difference(right_names)
  852:         else:
  853:             level_order = left_names + right_names.difference(left_names)
  854: 
  855:         expected = (
  856:             merge(
  857:                 left_multi.reset_index(),
  858:                 right_multi.reset_index(),
  859:                 how=join_type,
  860:                 on=on_cols_multi,
  861:             )
  862:             .set_index(level_order)
  863:             .sort_index()
  864:         )
  865: 
  866:         result = left_multi.join(right_multi, how=join_type).sort_index()
  867:         tm.assert_frame_equal(result, expected)
  868: 
  869:     @pytest.mark.parametrize("box", [None, np.asarray, Series, Index])
  870:     def test_merge_datetime_index(self, box):
  871:         # see gh-19038
  872:         df = DataFrame(
  873:             [1, 2, 3], ["2016-01-01", "2017-01-01", "2018-01-01"], columns=["a"]
  874:         )
  875:         df.index = pd.to_datetime(df.index)
  876:         on_vector = df.index.year
  877: 
  878:         if box is not None:
  879:             on_vector = box(on_vector)
  880: 
  881:         exp_years = np.array([2016, 2017, 2018], dtype=np.int32)
  882:         expected = DataFrame({"a": [1, 2, 3], "key_1": exp_years})
  883: 
  884:         result = df.merge(df, on=["a", on_vector], how="inner")
  885:         tm.assert_frame_equal(result, expected)
  886: 
  887:         expected = DataFrame({"key_0": exp_years, "a_x": [1, 2, 3], "a_y": [1, 2, 3]})
  888: 
  889:         result = df.merge(df, on=[df.index.year], how="inner")
  890:         tm.assert_frame_equal(result, expected)
  891: 
  892:     def test_single_common_level(self):
  893:         index_left = MultiIndex.from_tuples(
  894:             [("K0", "X0"), ("K0", "X1"), ("K1", "X2")], names=["key", "X"]
  895:         )
  896: 
  897:         left = DataFrame(
  898:             {"A": ["A0", "A1", "A2"], "B": ["B0", "B1", "B2"]}, index=index_left
  899:         )
  900: 
  901:         index_right = MultiIndex.from_tuples(
  902:             [("K0", "Y0"), ("K1", "Y1"), ("K2", "Y2"), ("K2", "Y3")], names=["key", "Y"]
  903:         )
  904: 
  905:         right = DataFrame(
  906:             {"C": ["C0", "C1", "C2", "C3"], "D": ["D0", "D1", "D2", "D3"]},
  907:             index=index_right,
  908:         )
  909: 
  910:         result = left.join(right)
  911:         expected = merge(
  912:             left.reset_index(), right.reset_index(), on=["key"], how="inner"
  913:         ).set_index(["key", "X", "Y"])
  914: 
  915:         tm.assert_frame_equal(result, expected)
  916: 
  917:     def test_join_multi_wrong_order(self):
  918:         # GH 25760
  919:         # GH 28956
  920: 
  921:         midx1 = MultiIndex.from_product([[1, 2], [3, 4]], names=["a", "b"])
  922:         midx3 = MultiIndex.from_tuples([(4, 1), (3, 2), (3, 1)], names=["b", "a"])
  923: 
  924:         left = DataFrame(index=midx1, data={"x": [10, 20, 30, 40]})
  925:         right = DataFrame(index=midx3, data={"y": ["foo", "bar", "fing"]})
  926: 
  927:         result = left.join(right)
  928: 
  929:         expected = DataFrame(
  930:             index=midx1,
  931:             data={"x": [10, 20, 30, 40], "y": ["fing", "foo", "bar", np.nan]},
  932:         )
  933: 
  934:         tm.assert_frame_equal(result, expected)
