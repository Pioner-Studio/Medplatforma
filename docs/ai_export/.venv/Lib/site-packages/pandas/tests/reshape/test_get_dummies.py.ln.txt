    1: import re
    2: import unicodedata
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas.util._test_decorators as td
    8: 
    9: from pandas.core.dtypes.common import is_integer_dtype
   10: 
   11: import pandas as pd
   12: from pandas import (
   13:     ArrowDtype,
   14:     Categorical,
   15:     CategoricalDtype,
   16:     CategoricalIndex,
   17:     DataFrame,
   18:     Index,
   19:     RangeIndex,
   20:     Series,
   21:     SparseDtype,
   22:     get_dummies,
   23: )
   24: import pandas._testing as tm
   25: from pandas.core.arrays.sparse import SparseArray
   26: 
   27: try:
   28:     import pyarrow as pa
   29: except ImportError:
   30:     pa = None
   31: 
   32: 
   33: class TestGetDummies:
   34:     @pytest.fixture
   35:     def df(self):
   36:         return DataFrame({"A": ["a", "b", "a"], "B": ["b", "b", "c"], "C": [1, 2, 3]})
   37: 
   38:     @pytest.fixture(params=["uint8", "i8", np.float64, bool, None])
   39:     def dtype(self, request):
   40:         return np.dtype(request.param)
   41: 
   42:     @pytest.fixture(params=["dense", "sparse"])
   43:     def sparse(self, request):
   44:         # params are strings to simplify reading test results,
   45:         # e.g. TestGetDummies::test_basic[uint8-sparse] instead of [uint8-True]
   46:         return request.param == "sparse"
   47: 
   48:     def effective_dtype(self, dtype):
   49:         if dtype is None:
   50:             return np.uint8
   51:         return dtype
   52: 
   53:     def test_get_dummies_raises_on_dtype_object(self, df):
   54:         msg = "dtype=object is not a valid dtype for get_dummies"
   55:         with pytest.raises(ValueError, match=msg):
   56:             get_dummies(df, dtype="object")
   57: 
   58:     def test_get_dummies_basic(self, sparse, dtype):
   59:         s_list = list("abc")
   60:         s_series = Series(s_list)
   61:         s_series_index = Series(s_list, list("ABC"))
   62: 
   63:         expected = DataFrame(
   64:             {"a": [1, 0, 0], "b": [0, 1, 0], "c": [0, 0, 1]},
   65:             dtype=self.effective_dtype(dtype),
   66:         )
   67:         if sparse:
   68:             if dtype.kind == "b":
   69:                 expected = expected.apply(SparseArray, fill_value=False)
   70:             else:
   71:                 expected = expected.apply(SparseArray, fill_value=0.0)
   72:         result = get_dummies(s_list, sparse=sparse, dtype=dtype)
   73:         tm.assert_frame_equal(result, expected)
   74: 
   75:         result = get_dummies(s_series, sparse=sparse, dtype=dtype)
   76:         tm.assert_frame_equal(result, expected)
   77: 
   78:         expected.index = list("ABC")
   79:         result = get_dummies(s_series_index, sparse=sparse, dtype=dtype)
   80:         tm.assert_frame_equal(result, expected)
   81: 
   82:     def test_get_dummies_basic_types(self, sparse, dtype, using_infer_string):
   83:         # GH 10531
   84:         s_list = list("abc")
   85:         s_series = Series(s_list)
   86:         s_df = DataFrame(
   87:             {"a": [0, 1, 0, 1, 2], "b": ["A", "A", "B", "C", "C"], "c": [2, 3, 3, 3, 2]}
   88:         )
   89: 
   90:         expected = DataFrame(
   91:             {"a": [1, 0, 0], "b": [0, 1, 0], "c": [0, 0, 1]},
   92:             dtype=self.effective_dtype(dtype),
   93:             columns=list("abc"),
   94:         )
   95:         if sparse:
   96:             if is_integer_dtype(dtype):
   97:                 fill_value = 0
   98:             elif dtype == bool:
   99:                 fill_value = False
  100:             else:
  101:                 fill_value = 0.0
  102: 
  103:             expected = expected.apply(SparseArray, fill_value=fill_value)
  104:         result = get_dummies(s_list, sparse=sparse, dtype=dtype)
  105:         tm.assert_frame_equal(result, expected)
  106: 
  107:         result = get_dummies(s_series, sparse=sparse, dtype=dtype)
  108:         tm.assert_frame_equal(result, expected)
  109: 
  110:         result = get_dummies(s_df, columns=s_df.columns, sparse=sparse, dtype=dtype)
  111:         if sparse:
  112:             dtype_name = f"Sparse[{self.effective_dtype(dtype).name}, {fill_value}]"
  113:         else:
  114:             dtype_name = self.effective_dtype(dtype).name
  115: 
  116:         expected = Series({dtype_name: 8}, name="count")
  117:         result = result.dtypes.value_counts()
  118:         result.index = [str(i) for i in result.index]
  119:         tm.assert_series_equal(result, expected)
  120: 
  121:         result = get_dummies(s_df, columns=["a"], sparse=sparse, dtype=dtype)
  122: 
  123:         key = "string" if using_infer_string else "object"
  124:         expected_counts = {"int64": 1, key: 1}
  125:         expected_counts[dtype_name] = 3 + expected_counts.get(dtype_name, 0)
  126: 
  127:         expected = Series(expected_counts, name="count").sort_index()
  128:         result = result.dtypes.value_counts()
  129:         result.index = [str(i) for i in result.index]
  130:         result = result.sort_index()
  131:         tm.assert_series_equal(result, expected)
  132: 
  133:     def test_get_dummies_just_na(self, sparse):
  134:         just_na_list = [np.nan]
  135:         just_na_series = Series(just_na_list)
  136:         just_na_series_index = Series(just_na_list, index=["A"])
  137: 
  138:         res_list = get_dummies(just_na_list, sparse=sparse)
  139:         res_series = get_dummies(just_na_series, sparse=sparse)
  140:         res_series_index = get_dummies(just_na_series_index, sparse=sparse)
  141: 
  142:         assert res_list.empty
  143:         assert res_series.empty
  144:         assert res_series_index.empty
  145: 
  146:         assert res_list.index.tolist() == [0]
  147:         assert res_series.index.tolist() == [0]
  148:         assert res_series_index.index.tolist() == ["A"]
  149: 
  150:     def test_get_dummies_include_na(self, sparse, dtype):
  151:         s = ["a", "b", np.nan]
  152:         res = get_dummies(s, sparse=sparse, dtype=dtype)
  153:         exp = DataFrame(
  154:             {"a": [1, 0, 0], "b": [0, 1, 0]}, dtype=self.effective_dtype(dtype)
  155:         )
  156:         if sparse:
  157:             if dtype.kind == "b":
  158:                 exp = exp.apply(SparseArray, fill_value=False)
  159:             else:
  160:                 exp = exp.apply(SparseArray, fill_value=0.0)
  161:         tm.assert_frame_equal(res, exp)
  162: 
  163:         # Sparse dataframes do not allow nan labelled columns, see #GH8822
  164:         res_na = get_dummies(s, dummy_na=True, sparse=sparse, dtype=dtype)
  165:         exp_na = DataFrame(
  166:             {np.nan: [0, 0, 1], "a": [1, 0, 0], "b": [0, 1, 0]},
  167:             dtype=self.effective_dtype(dtype),
  168:         )
  169:         exp_na = exp_na.reindex(["a", "b", np.nan], axis=1)
  170:         # hack (NaN handling in assert_index_equal)
  171:         exp_na.columns = res_na.columns
  172:         if sparse:
  173:             if dtype.kind == "b":
  174:                 exp_na = exp_na.apply(SparseArray, fill_value=False)
  175:             else:
  176:                 exp_na = exp_na.apply(SparseArray, fill_value=0.0)
  177:         tm.assert_frame_equal(res_na, exp_na)
  178: 
  179:         res_just_na = get_dummies([np.nan], dummy_na=True, sparse=sparse, dtype=dtype)
  180:         exp_just_na = DataFrame(
  181:             Series(1, index=[0]), columns=[np.nan], dtype=self.effective_dtype(dtype)
  182:         )
  183:         tm.assert_numpy_array_equal(res_just_na.values, exp_just_na.values)
  184: 
  185:     def test_get_dummies_unicode(self, sparse):
  186:         # See GH 6885 - get_dummies chokes on unicode values
  187:         e = "e"
  188:         eacute = unicodedata.lookup("LATIN SMALL LETTER E WITH ACUTE")
  189:         s = [e, eacute, eacute]
  190:         res = get_dummies(s, prefix="letter", sparse=sparse)
  191:         exp = DataFrame(
  192:             {"letter_e": [True, False, False], f"letter_{eacute}": [False, True, True]}
  193:         )
  194:         if sparse:
  195:             exp = exp.apply(SparseArray, fill_value=False)
  196:         tm.assert_frame_equal(res, exp)
  197: 
  198:     def test_dataframe_dummies_all_obj(self, df, sparse):
  199:         df = df[["A", "B"]]
  200:         result = get_dummies(df, sparse=sparse)
  201:         expected = DataFrame(
  202:             {"A_a": [1, 0, 1], "A_b": [0, 1, 0], "B_b": [1, 1, 0], "B_c": [0, 0, 1]},
  203:             dtype=bool,
  204:         )
  205:         if sparse:
  206:             expected = DataFrame(
  207:                 {
  208:                     "A_a": SparseArray([1, 0, 1], dtype="bool"),
  209:                     "A_b": SparseArray([0, 1, 0], dtype="bool"),
  210:                     "B_b": SparseArray([1, 1, 0], dtype="bool"),
  211:                     "B_c": SparseArray([0, 0, 1], dtype="bool"),
  212:                 }
  213:             )
  214: 
  215:         tm.assert_frame_equal(result, expected)
  216: 
  217:     def test_dataframe_dummies_string_dtype(self, df, using_infer_string):
  218:         # GH44965
  219:         df = df[["A", "B"]]
  220:         df = df.astype({"A": "object", "B": "string"})
  221:         result = get_dummies(df)
  222:         expected = DataFrame(
  223:             {
  224:                 "A_a": [1, 0, 1],
  225:                 "A_b": [0, 1, 0],
  226:                 "B_b": [1, 1, 0],
  227:                 "B_c": [0, 0, 1],
  228:             },
  229:             dtype=bool,
  230:         )
  231:         if not using_infer_string:
  232:             # infer_string returns numpy bools
  233:             expected[["B_b", "B_c"]] = expected[["B_b", "B_c"]].astype("boolean")
  234:         tm.assert_frame_equal(result, expected)
  235: 
  236:     def test_dataframe_dummies_mix_default(self, df, sparse, dtype):
  237:         result = get_dummies(df, sparse=sparse, dtype=dtype)
  238:         if sparse:
  239:             arr = SparseArray
  240:             if dtype.kind == "b":
  241:                 typ = SparseDtype(dtype, False)
  242:             else:
  243:                 typ = SparseDtype(dtype, 0)
  244:         else:
  245:             arr = np.array
  246:             typ = dtype
  247:         expected = DataFrame(
  248:             {
  249:                 "C": [1, 2, 3],
  250:                 "A_a": arr([1, 0, 1], dtype=typ),
  251:                 "A_b": arr([0, 1, 0], dtype=typ),
  252:                 "B_b": arr([1, 1, 0], dtype=typ),
  253:                 "B_c": arr([0, 0, 1], dtype=typ),
  254:             }
  255:         )
  256:         expected = expected[["C", "A_a", "A_b", "B_b", "B_c"]]
  257:         tm.assert_frame_equal(result, expected)
  258: 
  259:     def test_dataframe_dummies_prefix_list(self, df, sparse):
  260:         prefixes = ["from_A", "from_B"]
  261:         result = get_dummies(df, prefix=prefixes, sparse=sparse)
  262:         expected = DataFrame(
  263:             {
  264:                 "C": [1, 2, 3],
  265:                 "from_A_a": [True, False, True],
  266:                 "from_A_b": [False, True, False],
  267:                 "from_B_b": [True, True, False],
  268:                 "from_B_c": [False, False, True],
  269:             },
  270:         )
  271:         expected[["C"]] = df[["C"]]
  272:         cols = ["from_A_a", "from_A_b", "from_B_b", "from_B_c"]
  273:         expected = expected[["C"] + cols]
  274: 
  275:         typ = SparseArray if sparse else Series
  276:         expected[cols] = expected[cols].apply(lambda x: typ(x))
  277:         tm.assert_frame_equal(result, expected)
  278: 
  279:     def test_dataframe_dummies_prefix_str(self, df, sparse):
  280:         # not that you should do this...
  281:         result = get_dummies(df, prefix="bad", sparse=sparse)
  282:         bad_columns = ["bad_a", "bad_b", "bad_b", "bad_c"]
  283:         expected = DataFrame(
  284:             [
  285:                 [1, True, False, True, False],
  286:                 [2, False, True, True, False],
  287:                 [3, True, False, False, True],
  288:             ],
  289:             columns=["C"] + bad_columns,
  290:         )
  291:         expected = expected.astype({"C": np.int64})
  292:         if sparse:
  293:             # work around astyping & assigning with duplicate columns
  294:             # https://github.com/pandas-dev/pandas/issues/14427
  295:             expected = pd.concat(
  296:                 [
  297:                     Series([1, 2, 3], name="C"),
  298:                     Series([True, False, True], name="bad_a", dtype="Sparse[bool]"),
  299:                     Series([False, True, False], name="bad_b", dtype="Sparse[bool]"),
  300:                     Series([True, True, False], name="bad_b", dtype="Sparse[bool]"),
  301:                     Series([False, False, True], name="bad_c", dtype="Sparse[bool]"),
  302:                 ],
  303:                 axis=1,
  304:             )
  305: 
  306:         tm.assert_frame_equal(result, expected)
  307: 
  308:     def test_dataframe_dummies_subset(self, df, sparse):
  309:         result = get_dummies(df, prefix=["from_A"], columns=["A"], sparse=sparse)
  310:         expected = DataFrame(
  311:             {
  312:                 "B": ["b", "b", "c"],
  313:                 "C": [1, 2, 3],
  314:                 "from_A_a": [1, 0, 1],
  315:                 "from_A_b": [0, 1, 0],
  316:             },
  317:         )
  318:         cols = expected.columns
  319:         expected[cols[1:]] = expected[cols[1:]].astype(bool)
  320:         expected[["C"]] = df[["C"]]
  321:         if sparse:
  322:             cols = ["from_A_a", "from_A_b"]
  323:             expected[cols] = expected[cols].astype(SparseDtype("bool", False))
  324:         tm.assert_frame_equal(result, expected)
  325: 
  326:     def test_dataframe_dummies_prefix_sep(self, df, sparse):
  327:         result = get_dummies(df, prefix_sep="..", sparse=sparse)
  328:         expected = DataFrame(
  329:             {
  330:                 "C": [1, 2, 3],
  331:                 "A..a": [True, False, True],
  332:                 "A..b": [False, True, False],
  333:                 "B..b": [True, True, False],
  334:                 "B..c": [False, False, True],
  335:             },
  336:         )
  337:         expected[["C"]] = df[["C"]]
  338:         expected = expected[["C", "A..a", "A..b", "B..b", "B..c"]]
  339:         if sparse:
  340:             cols = ["A..a", "A..b", "B..b", "B..c"]
  341:             expected[cols] = expected[cols].astype(SparseDtype("bool", False))
  342: 
  343:         tm.assert_frame_equal(result, expected)
  344: 
  345:         result = get_dummies(df, prefix_sep=["..", "__"], sparse=sparse)
  346:         expected = expected.rename(columns={"B..b": "B__b", "B..c": "B__c"})
  347:         tm.assert_frame_equal(result, expected)
  348: 
  349:         result = get_dummies(df, prefix_sep={"A": "..", "B": "__"}, sparse=sparse)
  350:         tm.assert_frame_equal(result, expected)
  351: 
  352:     def test_dataframe_dummies_prefix_bad_length(self, df, sparse):
  353:         msg = re.escape(
  354:             "Length of 'prefix' (1) did not match the length of the columns being "
  355:             "encoded (2)"
  356:         )
  357:         with pytest.raises(ValueError, match=msg):
  358:             get_dummies(df, prefix=["too few"], sparse=sparse)
  359: 
  360:     def test_dataframe_dummies_prefix_sep_bad_length(self, df, sparse):
  361:         msg = re.escape(
  362:             "Length of 'prefix_sep' (1) did not match the length of the columns being "
  363:             "encoded (2)"
  364:         )
  365:         with pytest.raises(ValueError, match=msg):
  366:             get_dummies(df, prefix_sep=["bad"], sparse=sparse)
  367: 
  368:     def test_dataframe_dummies_prefix_dict(self, sparse):
  369:         prefixes = {"A": "from_A", "B": "from_B"}
  370:         df = DataFrame({"C": [1, 2, 3], "A": ["a", "b", "a"], "B": ["b", "b", "c"]})
  371:         result = get_dummies(df, prefix=prefixes, sparse=sparse)
  372: 
  373:         expected = DataFrame(
  374:             {
  375:                 "C": [1, 2, 3],
  376:                 "from_A_a": [1, 0, 1],
  377:                 "from_A_b": [0, 1, 0],
  378:                 "from_B_b": [1, 1, 0],
  379:                 "from_B_c": [0, 0, 1],
  380:             }
  381:         )
  382: 
  383:         columns = ["from_A_a", "from_A_b", "from_B_b", "from_B_c"]
  384:         expected[columns] = expected[columns].astype(bool)
  385:         if sparse:
  386:             expected[columns] = expected[columns].astype(SparseDtype("bool", False))
  387: 
  388:         tm.assert_frame_equal(result, expected)
  389: 
  390:     def test_dataframe_dummies_with_na(self, df, sparse, dtype):
  391:         df.loc[3, :] = [np.nan, np.nan, np.nan]
  392:         result = get_dummies(df, dummy_na=True, sparse=sparse, dtype=dtype).sort_index(
  393:             axis=1
  394:         )
  395: 
  396:         if sparse:
  397:             arr = SparseArray
  398:             if dtype.kind == "b":
  399:                 typ = SparseDtype(dtype, False)
  400:             else:
  401:                 typ = SparseDtype(dtype, 0)
  402:         else:
  403:             arr = np.array
  404:             typ = dtype
  405: 
  406:         expected = DataFrame(
  407:             {
  408:                 "C": [1, 2, 3, np.nan],
  409:                 "A_a": arr([1, 0, 1, 0], dtype=typ),
  410:                 "A_b": arr([0, 1, 0, 0], dtype=typ),
  411:                 "A_nan": arr([0, 0, 0, 1], dtype=typ),
  412:                 "B_b": arr([1, 1, 0, 0], dtype=typ),
  413:                 "B_c": arr([0, 0, 1, 0], dtype=typ),
  414:                 "B_nan": arr([0, 0, 0, 1], dtype=typ),
  415:             }
  416:         ).sort_index(axis=1)
  417: 
  418:         tm.assert_frame_equal(result, expected)
  419: 
  420:         result = get_dummies(df, dummy_na=False, sparse=sparse, dtype=dtype)
  421:         expected = expected[["C", "A_a", "A_b", "B_b", "B_c"]]
  422:         tm.assert_frame_equal(result, expected)
  423: 
  424:     def test_dataframe_dummies_with_categorical(self, df, sparse, dtype):
  425:         df["cat"] = Categorical(["x", "y", "y"])
  426:         result = get_dummies(df, sparse=sparse, dtype=dtype).sort_index(axis=1)
  427:         if sparse:
  428:             arr = SparseArray
  429:             if dtype.kind == "b":
  430:                 typ = SparseDtype(dtype, False)
  431:             else:
  432:                 typ = SparseDtype(dtype, 0)
  433:         else:
  434:             arr = np.array
  435:             typ = dtype
  436: 
  437:         expected = DataFrame(
  438:             {
  439:                 "C": [1, 2, 3],
  440:                 "A_a": arr([1, 0, 1], dtype=typ),
  441:                 "A_b": arr([0, 1, 0], dtype=typ),
  442:                 "B_b": arr([1, 1, 0], dtype=typ),
  443:                 "B_c": arr([0, 0, 1], dtype=typ),
  444:                 "cat_x": arr([1, 0, 0], dtype=typ),
  445:                 "cat_y": arr([0, 1, 1], dtype=typ),
  446:             }
  447:         ).sort_index(axis=1)
  448: 
  449:         tm.assert_frame_equal(result, expected)
  450: 
  451:     @pytest.mark.parametrize(
  452:         "get_dummies_kwargs,expected",
  453:         [
  454:             (
  455:                 {"data": DataFrame({"Г¤": ["a"]})},
  456:                 DataFrame({"Г¤_a": [True]}),
  457:             ),
  458:             (
  459:                 {"data": DataFrame({"x": ["Г¤"]})},
  460:                 DataFrame({"x_Г¤": [True]}),
  461:             ),
  462:             (
  463:                 {"data": DataFrame({"x": ["a"]}), "prefix": "Г¤"},
  464:                 DataFrame({"Г¤_a": [True]}),
  465:             ),
  466:             (
  467:                 {"data": DataFrame({"x": ["a"]}), "prefix_sep": "Г¤"},
  468:                 DataFrame({"xГ¤a": [True]}),
  469:             ),
  470:         ],
  471:     )
  472:     def test_dataframe_dummies_unicode(self, get_dummies_kwargs, expected):
  473:         # GH22084 get_dummies incorrectly encodes unicode characters
  474:         # in dataframe column names
  475:         result = get_dummies(**get_dummies_kwargs)
  476:         tm.assert_frame_equal(result, expected)
  477: 
  478:     def test_get_dummies_basic_drop_first(self, sparse):
  479:         # GH12402 Add a new parameter `drop_first` to avoid collinearity
  480:         # Basic case
  481:         s_list = list("abc")
  482:         s_series = Series(s_list)
  483:         s_series_index = Series(s_list, list("ABC"))
  484: 
  485:         expected = DataFrame({"b": [0, 1, 0], "c": [0, 0, 1]}, dtype=bool)
  486: 
  487:         result = get_dummies(s_list, drop_first=True, sparse=sparse)
  488:         if sparse:
  489:             expected = expected.apply(SparseArray, fill_value=False)
  490:         tm.assert_frame_equal(result, expected)
  491: 
  492:         result = get_dummies(s_series, drop_first=True, sparse=sparse)
  493:         tm.assert_frame_equal(result, expected)
  494: 
  495:         expected.index = list("ABC")
  496:         result = get_dummies(s_series_index, drop_first=True, sparse=sparse)
  497:         tm.assert_frame_equal(result, expected)
  498: 
  499:     def test_get_dummies_basic_drop_first_one_level(self, sparse):
  500:         # Test the case that categorical variable only has one level.
  501:         s_list = list("aaa")
  502:         s_series = Series(s_list)
  503:         s_series_index = Series(s_list, list("ABC"))
  504: 
  505:         expected = DataFrame(index=RangeIndex(3))
  506: 
  507:         result = get_dummies(s_list, drop_first=True, sparse=sparse)
  508:         tm.assert_frame_equal(result, expected)
  509: 
  510:         result = get_dummies(s_series, drop_first=True, sparse=sparse)
  511:         tm.assert_frame_equal(result, expected)
  512: 
  513:         expected = DataFrame(index=list("ABC"))
  514:         result = get_dummies(s_series_index, drop_first=True, sparse=sparse)
  515:         tm.assert_frame_equal(result, expected)
  516: 
  517:     def test_get_dummies_basic_drop_first_NA(self, sparse):
  518:         # Test NA handling together with drop_first
  519:         s_NA = ["a", "b", np.nan]
  520:         res = get_dummies(s_NA, drop_first=True, sparse=sparse)
  521:         exp = DataFrame({"b": [0, 1, 0]}, dtype=bool)
  522:         if sparse:
  523:             exp = exp.apply(SparseArray, fill_value=False)
  524: 
  525:         tm.assert_frame_equal(res, exp)
  526: 
  527:         res_na = get_dummies(s_NA, dummy_na=True, drop_first=True, sparse=sparse)
  528:         exp_na = DataFrame({"b": [0, 1, 0], np.nan: [0, 0, 1]}, dtype=bool).reindex(
  529:             ["b", np.nan], axis=1
  530:         )
  531:         if sparse:
  532:             exp_na = exp_na.apply(SparseArray, fill_value=False)
  533:         tm.assert_frame_equal(res_na, exp_na)
  534: 
  535:         res_just_na = get_dummies(
  536:             [np.nan], dummy_na=True, drop_first=True, sparse=sparse
  537:         )
  538:         exp_just_na = DataFrame(index=RangeIndex(1))
  539:         tm.assert_frame_equal(res_just_na, exp_just_na)
  540: 
  541:     def test_dataframe_dummies_drop_first(self, df, sparse):
  542:         df = df[["A", "B"]]
  543:         result = get_dummies(df, drop_first=True, sparse=sparse)
  544:         expected = DataFrame({"A_b": [0, 1, 0], "B_c": [0, 0, 1]}, dtype=bool)
  545:         if sparse:
  546:             expected = expected.apply(SparseArray, fill_value=False)
  547:         tm.assert_frame_equal(result, expected)
  548: 
  549:     def test_dataframe_dummies_drop_first_with_categorical(self, df, sparse, dtype):
  550:         df["cat"] = Categorical(["x", "y", "y"])
  551:         result = get_dummies(df, drop_first=True, sparse=sparse)
  552:         expected = DataFrame(
  553:             {"C": [1, 2, 3], "A_b": [0, 1, 0], "B_c": [0, 0, 1], "cat_y": [0, 1, 1]}
  554:         )
  555:         cols = ["A_b", "B_c", "cat_y"]
  556:         expected[cols] = expected[cols].astype(bool)
  557:         expected = expected[["C", "A_b", "B_c", "cat_y"]]
  558:         if sparse:
  559:             for col in cols:
  560:                 expected[col] = SparseArray(expected[col])
  561:         tm.assert_frame_equal(result, expected)
  562: 
  563:     def test_dataframe_dummies_drop_first_with_na(self, df, sparse):
  564:         df.loc[3, :] = [np.nan, np.nan, np.nan]
  565:         result = get_dummies(
  566:             df, dummy_na=True, drop_first=True, sparse=sparse
  567:         ).sort_index(axis=1)
  568:         expected = DataFrame(
  569:             {
  570:                 "C": [1, 2, 3, np.nan],
  571:                 "A_b": [0, 1, 0, 0],
  572:                 "A_nan": [0, 0, 0, 1],
  573:                 "B_c": [0, 0, 1, 0],
  574:                 "B_nan": [0, 0, 0, 1],
  575:             }
  576:         )
  577:         cols = ["A_b", "A_nan", "B_c", "B_nan"]
  578:         expected[cols] = expected[cols].astype(bool)
  579:         expected = expected.sort_index(axis=1)
  580:         if sparse:
  581:             for col in cols:
  582:                 expected[col] = SparseArray(expected[col])
  583: 
  584:         tm.assert_frame_equal(result, expected)
  585: 
  586:         result = get_dummies(df, dummy_na=False, drop_first=True, sparse=sparse)
  587:         expected = expected[["C", "A_b", "B_c"]]
  588:         tm.assert_frame_equal(result, expected)
  589: 
  590:     def test_get_dummies_int_int(self):
  591:         data = Series([1, 2, 1])
  592:         result = get_dummies(data)
  593:         expected = DataFrame([[1, 0], [0, 1], [1, 0]], columns=[1, 2], dtype=bool)
  594:         tm.assert_frame_equal(result, expected)
  595: 
  596:         data = Series(Categorical(["a", "b", "a"]))
  597:         result = get_dummies(data)
  598:         expected = DataFrame(
  599:             [[1, 0], [0, 1], [1, 0]], columns=Categorical(["a", "b"]), dtype=bool
  600:         )
  601:         tm.assert_frame_equal(result, expected)
  602: 
  603:     def test_get_dummies_int_df(self, dtype):
  604:         data = DataFrame(
  605:             {
  606:                 "A": [1, 2, 1],
  607:                 "B": Categorical(["a", "b", "a"]),
  608:                 "C": [1, 2, 1],
  609:                 "D": [1.0, 2.0, 1.0],
  610:             }
  611:         )
  612:         columns = ["C", "D", "A_1", "A_2", "B_a", "B_b"]
  613:         expected = DataFrame(
  614:             [[1, 1.0, 1, 0, 1, 0], [2, 2.0, 0, 1, 0, 1], [1, 1.0, 1, 0, 1, 0]],
  615:             columns=columns,
  616:         )
  617:         expected[columns[2:]] = expected[columns[2:]].astype(dtype)
  618:         result = get_dummies(data, columns=["A", "B"], dtype=dtype)
  619:         tm.assert_frame_equal(result, expected)
  620: 
  621:     @pytest.mark.parametrize("ordered", [True, False])
  622:     def test_dataframe_dummies_preserve_categorical_dtype(self, dtype, ordered):
  623:         # GH13854
  624:         cat = Categorical(list("xy"), categories=list("xyz"), ordered=ordered)
  625:         result = get_dummies(cat, dtype=dtype)
  626: 
  627:         data = np.array([[1, 0, 0], [0, 1, 0]], dtype=self.effective_dtype(dtype))
  628:         cols = CategoricalIndex(
  629:             cat.categories, categories=cat.categories, ordered=ordered
  630:         )
  631:         expected = DataFrame(data, columns=cols, dtype=self.effective_dtype(dtype))
  632: 
  633:         tm.assert_frame_equal(result, expected)
  634: 
  635:     @pytest.mark.parametrize("sparse", [True, False])
  636:     def test_get_dummies_dont_sparsify_all_columns(self, sparse):
  637:         # GH18914
  638:         df = DataFrame.from_dict({"GDP": [1, 2], "Nation": ["AB", "CD"]})
  639:         df = get_dummies(df, columns=["Nation"], sparse=sparse)
  640:         df2 = df.reindex(columns=["GDP"])
  641: 
  642:         tm.assert_frame_equal(df[["GDP"]], df2)
  643: 
  644:     def test_get_dummies_duplicate_columns(self, df):
  645:         # GH20839
  646:         df.columns = ["A", "A", "A"]
  647:         result = get_dummies(df).sort_index(axis=1)
  648: 
  649:         expected = DataFrame(
  650:             [
  651:                 [1, True, False, True, False],
  652:                 [2, False, True, True, False],
  653:                 [3, True, False, False, True],
  654:             ],
  655:             columns=["A", "A_a", "A_b", "A_b", "A_c"],
  656:         ).sort_index(axis=1)
  657: 
  658:         expected = expected.astype({"A": np.int64})
  659: 
  660:         tm.assert_frame_equal(result, expected)
  661: 
  662:     def test_get_dummies_all_sparse(self):
  663:         df = DataFrame({"A": [1, 2]})
  664:         result = get_dummies(df, columns=["A"], sparse=True)
  665:         dtype = SparseDtype("bool", False)
  666:         expected = DataFrame(
  667:             {
  668:                 "A_1": SparseArray([1, 0], dtype=dtype),
  669:                 "A_2": SparseArray([0, 1], dtype=dtype),
  670:             }
  671:         )
  672:         tm.assert_frame_equal(result, expected)
  673: 
  674:     @pytest.mark.parametrize("values", ["baz"])
  675:     def test_get_dummies_with_string_values(self, values):
  676:         # issue #28383
  677:         df = DataFrame(
  678:             {
  679:                 "bar": [1, 2, 3, 4, 5, 6],
  680:                 "foo": ["one", "one", "one", "two", "two", "two"],
  681:                 "baz": ["A", "B", "C", "A", "B", "C"],
  682:                 "zoo": ["x", "y", "z", "q", "w", "t"],
  683:             }
  684:         )
  685: 
  686:         msg = "Input must be a list-like for parameter `columns`"
  687: 
  688:         with pytest.raises(TypeError, match=msg):
  689:             get_dummies(df, columns=values)
  690: 
  691:     def test_get_dummies_ea_dtype_series(self, any_numeric_ea_and_arrow_dtype):
  692:         # GH#32430
  693:         ser = Series(list("abca"))
  694:         result = get_dummies(ser, dtype=any_numeric_ea_and_arrow_dtype)
  695:         expected = DataFrame(
  696:             {"a": [1, 0, 0, 1], "b": [0, 1, 0, 0], "c": [0, 0, 1, 0]},
  697:             dtype=any_numeric_ea_and_arrow_dtype,
  698:         )
  699:         tm.assert_frame_equal(result, expected)
  700: 
  701:     def test_get_dummies_ea_dtype_dataframe(self, any_numeric_ea_and_arrow_dtype):
  702:         # GH#32430
  703:         df = DataFrame({"x": list("abca")})
  704:         result = get_dummies(df, dtype=any_numeric_ea_and_arrow_dtype)
  705:         expected = DataFrame(
  706:             {"x_a": [1, 0, 0, 1], "x_b": [0, 1, 0, 0], "x_c": [0, 0, 1, 0]},
  707:             dtype=any_numeric_ea_and_arrow_dtype,
  708:         )
  709:         tm.assert_frame_equal(result, expected)
  710: 
  711:     @td.skip_if_no("pyarrow")
  712:     def test_get_dummies_ea_dtype(self):
  713:         # GH#56273
  714:         for dtype, exp_dtype in [
  715:             ("string[pyarrow]", "boolean"),
  716:             ("string[pyarrow_numpy]", "bool"),
  717:             (CategoricalDtype(Index(["a"], dtype="string[pyarrow]")), "boolean"),
  718:             (CategoricalDtype(Index(["a"], dtype="string[pyarrow_numpy]")), "bool"),
  719:         ]:
  720:             df = DataFrame({"name": Series(["a"], dtype=dtype), "x": 1})
  721:             result = get_dummies(df)
  722:             expected = DataFrame({"x": 1, "name_a": Series([True], dtype=exp_dtype)})
  723:             tm.assert_frame_equal(result, expected)
  724: 
  725:     @td.skip_if_no("pyarrow")
  726:     def test_get_dummies_arrow_dtype(self):
  727:         # GH#56273
  728:         df = DataFrame({"name": Series(["a"], dtype=ArrowDtype(pa.string())), "x": 1})
  729:         result = get_dummies(df)
  730:         expected = DataFrame({"x": 1, "name_a": Series([True], dtype="bool[pyarrow]")})
  731:         tm.assert_frame_equal(result, expected)
  732: 
  733:         df = DataFrame(
  734:             {
  735:                 "name": Series(
  736:                     ["a"],
  737:                     dtype=CategoricalDtype(Index(["a"], dtype=ArrowDtype(pa.string()))),
  738:                 ),
  739:                 "x": 1,
  740:             }
  741:         )
  742:         result = get_dummies(df)
  743:         tm.assert_frame_equal(result, expected)
