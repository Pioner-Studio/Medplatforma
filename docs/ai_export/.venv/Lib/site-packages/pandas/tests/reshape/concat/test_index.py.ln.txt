    1: from copy import deepcopy
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.errors import PerformanceWarning
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     DataFrame,
   11:     Index,
   12:     MultiIndex,
   13:     Series,
   14:     concat,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: class TestIndexConcat:
   20:     def test_concat_ignore_index(self, sort):
   21:         frame1 = DataFrame(
   22:             {"test1": ["a", "b", "c"], "test2": [1, 2, 3], "test3": [4.5, 3.2, 1.2]}
   23:         )
   24:         frame2 = DataFrame({"test3": [5.2, 2.2, 4.3]})
   25:         frame1.index = Index(["x", "y", "z"])
   26:         frame2.index = Index(["x", "y", "q"])
   27: 
   28:         v1 = concat([frame1, frame2], axis=1, ignore_index=True, sort=sort)
   29: 
   30:         nan = np.nan
   31:         expected = DataFrame(
   32:             [
   33:                 [nan, nan, nan, 4.3],
   34:                 ["a", 1, 4.5, 5.2],
   35:                 ["b", 2, 3.2, 2.2],
   36:                 ["c", 3, 1.2, nan],
   37:             ],
   38:             index=Index(["q", "x", "y", "z"]),
   39:         )
   40:         if not sort:
   41:             expected = expected.loc[["x", "y", "z", "q"]]
   42: 
   43:         tm.assert_frame_equal(v1, expected)
   44: 
   45:     @pytest.mark.parametrize(
   46:         "name_in1,name_in2,name_in3,name_out",
   47:         [
   48:             ("idx", "idx", "idx", "idx"),
   49:             ("idx", "idx", None, None),
   50:             ("idx", None, None, None),
   51:             ("idx1", "idx2", None, None),
   52:             ("idx1", "idx1", "idx2", None),
   53:             ("idx1", "idx2", "idx3", None),
   54:             (None, None, None, None),
   55:         ],
   56:     )
   57:     def test_concat_same_index_names(self, name_in1, name_in2, name_in3, name_out):
   58:         # GH13475
   59:         indices = [
   60:             Index(["a", "b", "c"], name=name_in1),
   61:             Index(["b", "c", "d"], name=name_in2),
   62:             Index(["c", "d", "e"], name=name_in3),
   63:         ]
   64:         frames = [
   65:             DataFrame({c: [0, 1, 2]}, index=i) for i, c in zip(indices, ["x", "y", "z"])
   66:         ]
   67:         result = concat(frames, axis=1)
   68: 
   69:         exp_ind = Index(["a", "b", "c", "d", "e"], name=name_out)
   70:         expected = DataFrame(
   71:             {
   72:                 "x": [0, 1, 2, np.nan, np.nan],
   73:                 "y": [np.nan, 0, 1, 2, np.nan],
   74:                 "z": [np.nan, np.nan, 0, 1, 2],
   75:             },
   76:             index=exp_ind,
   77:         )
   78: 
   79:         tm.assert_frame_equal(result, expected)
   80: 
   81:     def test_concat_rename_index(self):
   82:         a = DataFrame(
   83:             np.random.default_rng(2).random((3, 3)),
   84:             columns=list("ABC"),
   85:             index=Index(list("abc"), name="index_a"),
   86:         )
   87:         b = DataFrame(
   88:             np.random.default_rng(2).random((3, 3)),
   89:             columns=list("ABC"),
   90:             index=Index(list("abc"), name="index_b"),
   91:         )
   92: 
   93:         result = concat([a, b], keys=["key0", "key1"], names=["lvl0", "lvl1"])
   94: 
   95:         exp = concat([a, b], keys=["key0", "key1"], names=["lvl0"])
   96:         names = list(exp.index.names)
   97:         names[1] = "lvl1"
   98:         exp.index.set_names(names, inplace=True)
   99: 
  100:         tm.assert_frame_equal(result, exp)
  101:         assert result.index.names == exp.index.names
  102: 
  103:     def test_concat_copy_index_series(self, axis, using_copy_on_write):
  104:         # GH 29879
  105:         ser = Series([1, 2])
  106:         comb = concat([ser, ser], axis=axis, copy=True)
  107:         if not using_copy_on_write or axis in [0, "index"]:
  108:             assert comb.index is not ser.index
  109:         else:
  110:             assert comb.index is ser.index
  111: 
  112:     def test_concat_copy_index_frame(self, axis, using_copy_on_write):
  113:         # GH 29879
  114:         df = DataFrame([[1, 2], [3, 4]], columns=["a", "b"])
  115:         comb = concat([df, df], axis=axis, copy=True)
  116:         if not using_copy_on_write:
  117:             assert not comb.index.is_(df.index)
  118:             assert not comb.columns.is_(df.columns)
  119:         elif axis in [0, "index"]:
  120:             assert not comb.index.is_(df.index)
  121:             assert comb.columns.is_(df.columns)
  122:         elif axis in [1, "columns"]:
  123:             assert comb.index.is_(df.index)
  124:             assert not comb.columns.is_(df.columns)
  125: 
  126:     def test_default_index(self):
  127:         # is_series and ignore_index
  128:         s1 = Series([1, 2, 3], name="x")
  129:         s2 = Series([4, 5, 6], name="y")
  130:         res = concat([s1, s2], axis=1, ignore_index=True)
  131:         assert isinstance(res.columns, pd.RangeIndex)
  132:         exp = DataFrame([[1, 4], [2, 5], [3, 6]])
  133:         # use check_index_type=True to check the result have
  134:         # RangeIndex (default index)
  135:         tm.assert_frame_equal(res, exp, check_index_type=True, check_column_type=True)
  136: 
  137:         # is_series and all inputs have no names
  138:         s1 = Series([1, 2, 3])
  139:         s2 = Series([4, 5, 6])
  140:         res = concat([s1, s2], axis=1, ignore_index=False)
  141:         assert isinstance(res.columns, pd.RangeIndex)
  142:         exp = DataFrame([[1, 4], [2, 5], [3, 6]])
  143:         exp.columns = pd.RangeIndex(2)
  144:         tm.assert_frame_equal(res, exp, check_index_type=True, check_column_type=True)
  145: 
  146:         # is_dataframe and ignore_index
  147:         df1 = DataFrame({"A": [1, 2], "B": [5, 6]})
  148:         df2 = DataFrame({"A": [3, 4], "B": [7, 8]})
  149: 
  150:         res = concat([df1, df2], axis=0, ignore_index=True)
  151:         exp = DataFrame([[1, 5], [2, 6], [3, 7], [4, 8]], columns=["A", "B"])
  152:         tm.assert_frame_equal(res, exp, check_index_type=True, check_column_type=True)
  153: 
  154:         res = concat([df1, df2], axis=1, ignore_index=True)
  155:         exp = DataFrame([[1, 5, 3, 7], [2, 6, 4, 8]])
  156:         tm.assert_frame_equal(res, exp, check_index_type=True, check_column_type=True)
  157: 
  158:     def test_dups_index(self):
  159:         # GH 4771
  160: 
  161:         # single dtypes
  162:         df = DataFrame(
  163:             np.random.default_rng(2).integers(0, 10, size=40).reshape(10, 4),
  164:             columns=["A", "A", "C", "C"],
  165:         )
  166: 
  167:         result = concat([df, df], axis=1)
  168:         tm.assert_frame_equal(result.iloc[:, :4], df)
  169:         tm.assert_frame_equal(result.iloc[:, 4:], df)
  170: 
  171:         result = concat([df, df], axis=0)
  172:         tm.assert_frame_equal(result.iloc[:10], df)
  173:         tm.assert_frame_equal(result.iloc[10:], df)
  174: 
  175:         # multi dtypes
  176:         df = concat(
  177:             [
  178:                 DataFrame(
  179:                     np.random.default_rng(2).standard_normal((10, 4)),
  180:                     columns=["A", "A", "B", "B"],
  181:                 ),
  182:                 DataFrame(
  183:                     np.random.default_rng(2).integers(0, 10, size=20).reshape(10, 2),
  184:                     columns=["A", "C"],
  185:                 ),
  186:             ],
  187:             axis=1,
  188:         )
  189: 
  190:         result = concat([df, df], axis=1)
  191:         tm.assert_frame_equal(result.iloc[:, :6], df)
  192:         tm.assert_frame_equal(result.iloc[:, 6:], df)
  193: 
  194:         result = concat([df, df], axis=0)
  195:         tm.assert_frame_equal(result.iloc[:10], df)
  196:         tm.assert_frame_equal(result.iloc[10:], df)
  197: 
  198:         # append
  199:         result = df.iloc[0:8, :]._append(df.iloc[8:])
  200:         tm.assert_frame_equal(result, df)
  201: 
  202:         result = df.iloc[0:8, :]._append(df.iloc[8:9])._append(df.iloc[9:10])
  203:         tm.assert_frame_equal(result, df)
  204: 
  205:         expected = concat([df, df], axis=0)
  206:         result = df._append(df)
  207:         tm.assert_frame_equal(result, expected)
  208: 
  209: 
  210: class TestMultiIndexConcat:
  211:     def test_concat_multiindex_with_keys(self, multiindex_dataframe_random_data):
  212:         frame = multiindex_dataframe_random_data
  213:         index = frame.index
  214:         result = concat([frame, frame], keys=[0, 1], names=["iteration"])
  215: 
  216:         assert result.index.names == ("iteration",) + index.names
  217:         tm.assert_frame_equal(result.loc[0], frame)
  218:         tm.assert_frame_equal(result.loc[1], frame)
  219:         assert result.index.nlevels == 3
  220: 
  221:     def test_concat_multiindex_with_none_in_index_names(self):
  222:         # GH 15787
  223:         index = MultiIndex.from_product([[1], range(5)], names=["level1", None])
  224:         df = DataFrame({"col": range(5)}, index=index, dtype=np.int32)
  225: 
  226:         result = concat([df, df], keys=[1, 2], names=["level2"])
  227:         index = MultiIndex.from_product(
  228:             [[1, 2], [1], range(5)], names=["level2", "level1", None]
  229:         )
  230:         expected = DataFrame({"col": list(range(5)) * 2}, index=index, dtype=np.int32)
  231:         tm.assert_frame_equal(result, expected)
  232: 
  233:         result = concat([df, df[:2]], keys=[1, 2], names=["level2"])
  234:         level2 = [1] * 5 + [2] * 2
  235:         level1 = [1] * 7
  236:         no_name = list(range(5)) + list(range(2))
  237:         tuples = list(zip(level2, level1, no_name))
  238:         index = MultiIndex.from_tuples(tuples, names=["level2", "level1", None])
  239:         expected = DataFrame({"col": no_name}, index=index, dtype=np.int32)
  240:         tm.assert_frame_equal(result, expected)
  241: 
  242:     def test_concat_multiindex_rangeindex(self):
  243:         # GH13542
  244:         # when multi-index levels are RangeIndex objects
  245:         # there is a bug in concat with objects of len 1
  246: 
  247:         df = DataFrame(np.random.default_rng(2).standard_normal((9, 2)))
  248:         df.index = MultiIndex(
  249:             levels=[pd.RangeIndex(3), pd.RangeIndex(3)],
  250:             codes=[np.repeat(np.arange(3), 3), np.tile(np.arange(3), 3)],
  251:         )
  252: 
  253:         res = concat([df.iloc[[2, 3, 4], :], df.iloc[[5], :]])
  254:         exp = df.iloc[[2, 3, 4, 5], :]
  255:         tm.assert_frame_equal(res, exp)
  256: 
  257:     def test_concat_multiindex_dfs_with_deepcopy(self):
  258:         # GH 9967
  259:         example_multiindex1 = MultiIndex.from_product([["a"], ["b"]])
  260:         example_dataframe1 = DataFrame([0], index=example_multiindex1)
  261: 
  262:         example_multiindex2 = MultiIndex.from_product([["a"], ["c"]])
  263:         example_dataframe2 = DataFrame([1], index=example_multiindex2)
  264: 
  265:         example_dict = {"s1": example_dataframe1, "s2": example_dataframe2}
  266:         expected_index = MultiIndex(
  267:             levels=[["s1", "s2"], ["a"], ["b", "c"]],
  268:             codes=[[0, 1], [0, 0], [0, 1]],
  269:             names=["testname", None, None],
  270:         )
  271:         expected = DataFrame([[0], [1]], index=expected_index)
  272:         result_copy = concat(deepcopy(example_dict), names=["testname"])
  273:         tm.assert_frame_equal(result_copy, expected)
  274:         result_no_copy = concat(example_dict, names=["testname"])
  275:         tm.assert_frame_equal(result_no_copy, expected)
  276: 
  277:     @pytest.mark.parametrize(
  278:         "mi1_list",
  279:         [
  280:             [["a"], range(2)],
  281:             [["b"], np.arange(2.0, 4.0)],
  282:             [["c"], ["A", "B"]],
  283:             [["d"], pd.date_range(start="2017", end="2018", periods=2)],
  284:         ],
  285:     )
  286:     @pytest.mark.parametrize(
  287:         "mi2_list",
  288:         [
  289:             [["a"], range(2)],
  290:             [["b"], np.arange(2.0, 4.0)],
  291:             [["c"], ["A", "B"]],
  292:             [["d"], pd.date_range(start="2017", end="2018", periods=2)],
  293:         ],
  294:     )
  295:     def test_concat_with_various_multiindex_dtypes(
  296:         self, mi1_list: list, mi2_list: list
  297:     ):
  298:         # GitHub #23478
  299:         mi1 = MultiIndex.from_product(mi1_list)
  300:         mi2 = MultiIndex.from_product(mi2_list)
  301: 
  302:         df1 = DataFrame(np.zeros((1, len(mi1))), columns=mi1)
  303:         df2 = DataFrame(np.zeros((1, len(mi2))), columns=mi2)
  304: 
  305:         if mi1_list[0] == mi2_list[0]:
  306:             expected_mi = MultiIndex(
  307:                 levels=[mi1_list[0], list(mi1_list[1])],
  308:                 codes=[[0, 0, 0, 0], [0, 1, 0, 1]],
  309:             )
  310:         else:
  311:             expected_mi = MultiIndex(
  312:                 levels=[
  313:                     mi1_list[0] + mi2_list[0],
  314:                     list(mi1_list[1]) + list(mi2_list[1]),
  315:                 ],
  316:                 codes=[[0, 0, 1, 1], [0, 1, 2, 3]],
  317:             )
  318: 
  319:         expected_df = DataFrame(np.zeros((1, len(expected_mi))), columns=expected_mi)
  320: 
  321:         with tm.assert_produces_warning(None):
  322:             result_df = concat((df1, df2), axis=1)
  323: 
  324:         tm.assert_frame_equal(expected_df, result_df)
  325: 
  326:     def test_concat_multiindex_(self):
  327:         # GitHub #44786
  328:         df = DataFrame({"col": ["a", "b", "c"]}, index=["1", "2", "2"])
  329:         df = concat([df], keys=["X"])
  330: 
  331:         iterables = [["X"], ["1", "2", "2"]]
  332:         result_index = df.index
  333:         expected_index = MultiIndex.from_product(iterables)
  334: 
  335:         tm.assert_index_equal(result_index, expected_index)
  336: 
  337:         result_df = df
  338:         expected_df = DataFrame(
  339:             {"col": ["a", "b", "c"]}, index=MultiIndex.from_product(iterables)
  340:         )
  341:         tm.assert_frame_equal(result_df, expected_df)
  342: 
  343:     def test_concat_with_key_not_unique(self):
  344:         # GitHub #46519
  345:         df1 = DataFrame({"name": [1]})
  346:         df2 = DataFrame({"name": [2]})
  347:         df3 = DataFrame({"name": [3]})
  348:         df_a = concat([df1, df2, df3], keys=["x", "y", "x"])
  349:         # the warning is caused by indexing unsorted multi-index
  350:         with tm.assert_produces_warning(
  351:             PerformanceWarning, match="indexing past lexsort depth"
  352:         ):
  353:             out_a = df_a.loc[("x", 0), :]
  354: 
  355:         df_b = DataFrame(
  356:             {"name": [1, 2, 3]}, index=Index([("x", 0), ("y", 0), ("x", 0)])
  357:         )
  358:         with tm.assert_produces_warning(
  359:             PerformanceWarning, match="indexing past lexsort depth"
  360:         ):
  361:             out_b = df_b.loc[("x", 0)]
  362: 
  363:         tm.assert_frame_equal(out_a, out_b)
  364: 
  365:         df1 = DataFrame({"name": ["a", "a", "b"]})
  366:         df2 = DataFrame({"name": ["a", "b"]})
  367:         df3 = DataFrame({"name": ["c", "d"]})
  368:         df_a = concat([df1, df2, df3], keys=["x", "y", "x"])
  369:         with tm.assert_produces_warning(
  370:             PerformanceWarning, match="indexing past lexsort depth"
  371:         ):
  372:             out_a = df_a.loc[("x", 0), :]
  373: 
  374:         df_b = DataFrame(
  375:             {
  376:                 "a": ["x", "x", "x", "y", "y", "x", "x"],
  377:                 "b": [0, 1, 2, 0, 1, 0, 1],
  378:                 "name": list("aababcd"),
  379:             }
  380:         ).set_index(["a", "b"])
  381:         df_b.index.names = [None, None]
  382:         with tm.assert_produces_warning(
  383:             PerformanceWarning, match="indexing past lexsort depth"
  384:         ):
  385:             out_b = df_b.loc[("x", 0), :]
  386: 
  387:         tm.assert_frame_equal(out_a, out_b)
  388: 
  389:     def test_concat_with_duplicated_levels(self):
  390:         # keyword levels should be unique
  391:         df1 = DataFrame({"A": [1]}, index=["x"])
  392:         df2 = DataFrame({"A": [1]}, index=["y"])
  393:         msg = r"Level values not unique: \['x', 'y', 'y'\]"
  394:         with pytest.raises(ValueError, match=msg):
  395:             concat([df1, df2], keys=["x", "y"], levels=[["x", "y", "y"]])
  396: 
  397:     @pytest.mark.parametrize("levels", [[["x", "y"]], [["x", "y", "y"]]])
  398:     def test_concat_with_levels_with_none_keys(self, levels):
  399:         df1 = DataFrame({"A": [1]}, index=["x"])
  400:         df2 = DataFrame({"A": [1]}, index=["y"])
  401:         msg = "levels supported only when keys is not None"
  402:         with pytest.raises(ValueError, match=msg):
  403:             concat([df1, df2], levels=levels)
  404: 
  405:     def test_concat_range_index_result(self):
  406:         # GH#47501
  407:         df1 = DataFrame({"a": [1, 2]})
  408:         df2 = DataFrame({"b": [1, 2]})
  409: 
  410:         result = concat([df1, df2], sort=True, axis=1)
  411:         expected = DataFrame({"a": [1, 2], "b": [1, 2]})
  412:         tm.assert_frame_equal(result, expected)
  413:         expected_index = pd.RangeIndex(0, 2)
  414:         tm.assert_index_equal(result.index, expected_index, exact=True)
  415: 
  416:     def test_concat_index_keep_dtype(self):
  417:         # GH#47329
  418:         df1 = DataFrame([[0, 1, 1]], columns=Index([1, 2, 3], dtype="object"))
  419:         df2 = DataFrame([[0, 1]], columns=Index([1, 2], dtype="object"))
  420:         result = concat([df1, df2], ignore_index=True, join="outer", sort=True)
  421:         expected = DataFrame(
  422:             [[0, 1, 1.0], [0, 1, np.nan]], columns=Index([1, 2, 3], dtype="object")
  423:         )
  424:         tm.assert_frame_equal(result, expected)
  425: 
  426:     def test_concat_index_keep_dtype_ea_numeric(self, any_numeric_ea_dtype):
  427:         # GH#47329
  428:         df1 = DataFrame(
  429:             [[0, 1, 1]], columns=Index([1, 2, 3], dtype=any_numeric_ea_dtype)
  430:         )
  431:         df2 = DataFrame([[0, 1]], columns=Index([1, 2], dtype=any_numeric_ea_dtype))
  432:         result = concat([df1, df2], ignore_index=True, join="outer", sort=True)
  433:         expected = DataFrame(
  434:             [[0, 1, 1.0], [0, 1, np.nan]],
  435:             columns=Index([1, 2, 3], dtype=any_numeric_ea_dtype),
  436:         )
  437:         tm.assert_frame_equal(result, expected)
  438: 
  439:     @pytest.mark.parametrize("dtype", ["Int8", "Int16", "Int32"])
  440:     def test_concat_index_find_common(self, dtype):
  441:         # GH#47329
  442:         df1 = DataFrame([[0, 1, 1]], columns=Index([1, 2, 3], dtype=dtype))
  443:         df2 = DataFrame([[0, 1]], columns=Index([1, 2], dtype="Int32"))
  444:         result = concat([df1, df2], ignore_index=True, join="outer", sort=True)
  445:         expected = DataFrame(
  446:             [[0, 1, 1.0], [0, 1, np.nan]], columns=Index([1, 2, 3], dtype="Int32")
  447:         )
  448:         tm.assert_frame_equal(result, expected)
  449: 
  450:     def test_concat_axis_1_sort_false_rangeindex(self, using_infer_string):
  451:         # GH 46675
  452:         s1 = Series(["a", "b", "c"])
  453:         s2 = Series(["a", "b"])
  454:         s3 = Series(["a", "b", "c", "d"])
  455:         s4 = Series(
  456:             [], dtype=object if not using_infer_string else "string[pyarrow_numpy]"
  457:         )
  458:         result = concat(
  459:             [s1, s2, s3, s4], sort=False, join="outer", ignore_index=False, axis=1
  460:         )
  461:         expected = DataFrame(
  462:             [
  463:                 ["a"] * 3 + [np.nan],
  464:                 ["b"] * 3 + [np.nan],
  465:                 ["c", np.nan] * 2,
  466:                 [np.nan] * 2 + ["d"] + [np.nan],
  467:             ],
  468:             dtype=object if not using_infer_string else "string[pyarrow_numpy]",
  469:         )
  470:         tm.assert_frame_equal(
  471:             result, expected, check_index_type=True, check_column_type=True
  472:         )
