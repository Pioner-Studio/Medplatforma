    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: 
    5: from pandas.core.dtypes.dtypes import CategoricalDtype
    6: 
    7: import pandas as pd
    8: from pandas import (
    9:     Categorical,
   10:     DataFrame,
   11:     Series,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: class TestCategoricalConcat:
   17:     def test_categorical_concat(self, sort):
   18:         # See GH 10177
   19:         df1 = DataFrame(
   20:             np.arange(18, dtype="int64").reshape(6, 3), columns=["a", "b", "c"]
   21:         )
   22: 
   23:         df2 = DataFrame(np.arange(14, dtype="int64").reshape(7, 2), columns=["a", "c"])
   24: 
   25:         cat_values = ["one", "one", "two", "one", "two", "two", "one"]
   26:         df2["h"] = Series(Categorical(cat_values))
   27: 
   28:         res = pd.concat((df1, df2), axis=0, ignore_index=True, sort=sort)
   29:         exp = DataFrame(
   30:             {
   31:                 "a": [0, 3, 6, 9, 12, 15, 0, 2, 4, 6, 8, 10, 12],
   32:                 "b": [
   33:                     1,
   34:                     4,
   35:                     7,
   36:                     10,
   37:                     13,
   38:                     16,
   39:                     np.nan,
   40:                     np.nan,
   41:                     np.nan,
   42:                     np.nan,
   43:                     np.nan,
   44:                     np.nan,
   45:                     np.nan,
   46:                 ],
   47:                 "c": [2, 5, 8, 11, 14, 17, 1, 3, 5, 7, 9, 11, 13],
   48:                 "h": [None] * 6 + cat_values,
   49:             }
   50:         )
   51:         exp["h"] = exp["h"].astype(df2["h"].dtype)
   52:         tm.assert_frame_equal(res, exp)
   53: 
   54:     def test_categorical_concat_dtypes(self, using_infer_string):
   55:         # GH8143
   56:         index = ["cat", "obj", "num"]
   57:         cat = Categorical(["a", "b", "c"])
   58:         obj = Series(["a", "b", "c"])
   59:         num = Series([1, 2, 3])
   60:         df = pd.concat([Series(cat), obj, num], axis=1, keys=index)
   61: 
   62:         result = df.dtypes == (
   63:             object if not using_infer_string else "string[pyarrow_numpy]"
   64:         )
   65:         expected = Series([False, True, False], index=index)
   66:         tm.assert_series_equal(result, expected)
   67: 
   68:         result = df.dtypes == "int64"
   69:         expected = Series([False, False, True], index=index)
   70:         tm.assert_series_equal(result, expected)
   71: 
   72:         result = df.dtypes == "category"
   73:         expected = Series([True, False, False], index=index)
   74:         tm.assert_series_equal(result, expected)
   75: 
   76:     def test_concat_categoricalindex(self):
   77:         # GH 16111, categories that aren't lexsorted
   78:         categories = [9, 0, 1, 2, 3]
   79: 
   80:         a = Series(1, index=pd.CategoricalIndex([9, 0], categories=categories))
   81:         b = Series(2, index=pd.CategoricalIndex([0, 1], categories=categories))
   82:         c = Series(3, index=pd.CategoricalIndex([1, 2], categories=categories))
   83: 
   84:         result = pd.concat([a, b, c], axis=1)
   85: 
   86:         exp_idx = pd.CategoricalIndex([9, 0, 1, 2], categories=categories)
   87:         exp = DataFrame(
   88:             {
   89:                 0: [1, 1, np.nan, np.nan],
   90:                 1: [np.nan, 2, 2, np.nan],
   91:                 2: [np.nan, np.nan, 3, 3],
   92:             },
   93:             columns=[0, 1, 2],
   94:             index=exp_idx,
   95:         )
   96:         tm.assert_frame_equal(result, exp)
   97: 
   98:     def test_categorical_concat_preserve(self):
   99:         # GH 8641  series concat not preserving category dtype
  100:         # GH 13524 can concat different categories
  101:         s = Series(list("abc"), dtype="category")
  102:         s2 = Series(list("abd"), dtype="category")
  103: 
  104:         exp = Series(list("abcabd"))
  105:         res = pd.concat([s, s2], ignore_index=True)
  106:         tm.assert_series_equal(res, exp)
  107: 
  108:         exp = Series(list("abcabc"), dtype="category")
  109:         res = pd.concat([s, s], ignore_index=True)
  110:         tm.assert_series_equal(res, exp)
  111: 
  112:         exp = Series(list("abcabc"), index=[0, 1, 2, 0, 1, 2], dtype="category")
  113:         res = pd.concat([s, s])
  114:         tm.assert_series_equal(res, exp)
  115: 
  116:         a = Series(np.arange(6, dtype="int64"))
  117:         b = Series(list("aabbca"))
  118: 
  119:         df2 = DataFrame({"A": a, "B": b.astype(CategoricalDtype(list("cab")))})
  120:         res = pd.concat([df2, df2])
  121:         exp = DataFrame(
  122:             {
  123:                 "A": pd.concat([a, a]),
  124:                 "B": pd.concat([b, b]).astype(CategoricalDtype(list("cab"))),
  125:             }
  126:         )
  127:         tm.assert_frame_equal(res, exp)
  128: 
  129:     def test_categorical_index_preserver(self):
  130:         a = Series(np.arange(6, dtype="int64"))
  131:         b = Series(list("aabbca"))
  132: 
  133:         df2 = DataFrame(
  134:             {"A": a, "B": b.astype(CategoricalDtype(list("cab")))}
  135:         ).set_index("B")
  136:         result = pd.concat([df2, df2])
  137:         expected = DataFrame(
  138:             {
  139:                 "A": pd.concat([a, a]),
  140:                 "B": pd.concat([b, b]).astype(CategoricalDtype(list("cab"))),
  141:             }
  142:         ).set_index("B")
  143:         tm.assert_frame_equal(result, expected)
  144: 
  145:         # wrong categories -> uses concat_compat, which casts to object
  146:         df3 = DataFrame(
  147:             {"A": a, "B": Categorical(b, categories=list("abe"))}
  148:         ).set_index("B")
  149:         result = pd.concat([df2, df3])
  150:         expected = pd.concat(
  151:             [
  152:                 df2.set_axis(df2.index.astype(object), axis=0),
  153:                 df3.set_axis(df3.index.astype(object), axis=0),
  154:             ]
  155:         )
  156:         tm.assert_frame_equal(result, expected)
  157: 
  158:     def test_concat_categorical_tz(self):
  159:         # GH-23816
  160:         a = Series(pd.date_range("2017-01-01", periods=2, tz="US/Pacific"))
  161:         b = Series(["a", "b"], dtype="category")
  162:         result = pd.concat([a, b], ignore_index=True)
  163:         expected = Series(
  164:             [
  165:                 pd.Timestamp("2017-01-01", tz="US/Pacific"),
  166:                 pd.Timestamp("2017-01-02", tz="US/Pacific"),
  167:                 "a",
  168:                 "b",
  169:             ]
  170:         )
  171:         tm.assert_series_equal(result, expected)
  172: 
  173:     def test_concat_categorical_datetime(self):
  174:         # GH-39443
  175:         df1 = DataFrame(
  176:             {"x": Series(datetime(2021, 1, 1), index=[0], dtype="category")}
  177:         )
  178:         df2 = DataFrame(
  179:             {"x": Series(datetime(2021, 1, 2), index=[1], dtype="category")}
  180:         )
  181: 
  182:         result = pd.concat([df1, df2])
  183:         expected = DataFrame(
  184:             {"x": Series([datetime(2021, 1, 1), datetime(2021, 1, 2)])}
  185:         )
  186: 
  187:         tm.assert_equal(result, expected)
  188: 
  189:     def test_concat_categorical_unchanged(self):
  190:         # GH-12007
  191:         # test fix for when concat on categorical and float
  192:         # coerces dtype categorical -> float
  193:         df = DataFrame(Series(["a", "b", "c"], dtype="category", name="A"))
  194:         ser = Series([0, 1, 2], index=[0, 1, 3], name="B")
  195:         result = pd.concat([df, ser], axis=1)
  196:         expected = DataFrame(
  197:             {
  198:                 "A": Series(["a", "b", "c", np.nan], dtype="category"),
  199:                 "B": Series([0, 1, np.nan, 2], dtype="float"),
  200:             }
  201:         )
  202:         tm.assert_equal(result, expected)
  203: 
  204:     def test_categorical_concat_gh7864(self):
  205:         # GH 7864
  206:         # make sure ordering is preserved
  207:         df = DataFrame({"id": [1, 2, 3, 4, 5, 6], "raw_grade": list("abbaae")})
  208:         df["grade"] = Categorical(df["raw_grade"])
  209:         df["grade"].cat.set_categories(["e", "a", "b"])
  210: 
  211:         df1 = df[0:3]
  212:         df2 = df[3:]
  213: 
  214:         tm.assert_index_equal(df["grade"].cat.categories, df1["grade"].cat.categories)
  215:         tm.assert_index_equal(df["grade"].cat.categories, df2["grade"].cat.categories)
  216: 
  217:         dfx = pd.concat([df1, df2])
  218:         tm.assert_index_equal(df["grade"].cat.categories, dfx["grade"].cat.categories)
  219: 
  220:         dfa = df1._append(df2)
  221:         tm.assert_index_equal(df["grade"].cat.categories, dfa["grade"].cat.categories)
  222: 
  223:     def test_categorical_index_upcast(self):
  224:         # GH 17629
  225:         # test upcasting to object when concatenating on categorical indexes
  226:         # with non-identical categories
  227: 
  228:         a = DataFrame({"foo": [1, 2]}, index=Categorical(["foo", "bar"]))
  229:         b = DataFrame({"foo": [4, 3]}, index=Categorical(["baz", "bar"]))
  230: 
  231:         res = pd.concat([a, b])
  232:         exp = DataFrame({"foo": [1, 2, 4, 3]}, index=["foo", "bar", "baz", "bar"])
  233: 
  234:         tm.assert_equal(res, exp)
  235: 
  236:         a = Series([1, 2], index=Categorical(["foo", "bar"]))
  237:         b = Series([4, 3], index=Categorical(["baz", "bar"]))
  238: 
  239:         res = pd.concat([a, b])
  240:         exp = Series([1, 2, 4, 3], index=["foo", "bar", "baz", "bar"])
  241: 
  242:         tm.assert_equal(res, exp)
  243: 
  244:     def test_categorical_missing_from_one_frame(self):
  245:         # GH 25412
  246:         df1 = DataFrame({"f1": [1, 2, 3]})
  247:         df2 = DataFrame({"f1": [2, 3, 1], "f2": Series([4, 4, 4]).astype("category")})
  248:         result = pd.concat([df1, df2], sort=True)
  249:         dtype = CategoricalDtype([4])
  250:         expected = DataFrame(
  251:             {
  252:                 "f1": [1, 2, 3, 2, 3, 1],
  253:                 "f2": Categorical.from_codes([-1, -1, -1, 0, 0, 0], dtype=dtype),
  254:             },
  255:             index=[0, 1, 2, 0, 1, 2],
  256:         )
  257:         tm.assert_frame_equal(result, expected)
  258: 
  259:     def test_concat_categorical_same_categories_different_order(self):
  260:         # https://github.com/pandas-dev/pandas/issues/24845
  261: 
  262:         c1 = pd.CategoricalIndex(["a", "a"], categories=["a", "b"], ordered=False)
  263:         c2 = pd.CategoricalIndex(["b", "b"], categories=["b", "a"], ordered=False)
  264:         c3 = pd.CategoricalIndex(
  265:             ["a", "a", "b", "b"], categories=["a", "b"], ordered=False
  266:         )
  267: 
  268:         df1 = DataFrame({"A": [1, 2]}, index=c1)
  269:         df2 = DataFrame({"A": [3, 4]}, index=c2)
  270: 
  271:         result = pd.concat((df1, df2))
  272:         expected = DataFrame({"A": [1, 2, 3, 4]}, index=c3)
  273:         tm.assert_frame_equal(result, expected)
