    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     Series,
    7:     from_dummies,
    8:     get_dummies,
    9: )
   10: import pandas._testing as tm
   11: 
   12: 
   13: @pytest.fixture
   14: def dummies_basic():
   15:     return DataFrame(
   16:         {
   17:             "col1_a": [1, 0, 1],
   18:             "col1_b": [0, 1, 0],
   19:             "col2_a": [0, 1, 0],
   20:             "col2_b": [1, 0, 0],
   21:             "col2_c": [0, 0, 1],
   22:         },
   23:     )
   24: 
   25: 
   26: @pytest.fixture
   27: def dummies_with_unassigned():
   28:     return DataFrame(
   29:         {
   30:             "col1_a": [1, 0, 0],
   31:             "col1_b": [0, 1, 0],
   32:             "col2_a": [0, 1, 0],
   33:             "col2_b": [0, 0, 0],
   34:             "col2_c": [0, 0, 1],
   35:         },
   36:     )
   37: 
   38: 
   39: def test_error_wrong_data_type():
   40:     dummies = [0, 1, 0]
   41:     with pytest.raises(
   42:         TypeError,
   43:         match=r"Expected 'data' to be a 'DataFrame'; Received 'data' of type: list",
   44:     ):
   45:         from_dummies(dummies)
   46: 
   47: 
   48: def test_error_no_prefix_contains_unassigned():
   49:     dummies = DataFrame({"a": [1, 0, 0], "b": [0, 1, 0]})
   50:     with pytest.raises(
   51:         ValueError,
   52:         match=(
   53:             r"Dummy DataFrame contains unassigned value\(s\); "
   54:             r"First instance in row: 2"
   55:         ),
   56:     ):
   57:         from_dummies(dummies)
   58: 
   59: 
   60: def test_error_no_prefix_wrong_default_category_type():
   61:     dummies = DataFrame({"a": [1, 0, 1], "b": [0, 1, 1]})
   62:     with pytest.raises(
   63:         TypeError,
   64:         match=(
   65:             r"Expected 'default_category' to be of type 'None', 'Hashable', or 'dict'; "
   66:             r"Received 'default_category' of type: list"
   67:         ),
   68:     ):
   69:         from_dummies(dummies, default_category=["c", "d"])
   70: 
   71: 
   72: def test_error_no_prefix_multi_assignment():
   73:     dummies = DataFrame({"a": [1, 0, 1], "b": [0, 1, 1]})
   74:     with pytest.raises(
   75:         ValueError,
   76:         match=(
   77:             r"Dummy DataFrame contains multi-assignment\(s\); "
   78:             r"First instance in row: 2"
   79:         ),
   80:     ):
   81:         from_dummies(dummies)
   82: 
   83: 
   84: def test_error_no_prefix_contains_nan():
   85:     dummies = DataFrame({"a": [1, 0, 0], "b": [0, 1, np.nan]})
   86:     with pytest.raises(
   87:         ValueError, match=r"Dummy DataFrame contains NA value in column: 'b'"
   88:     ):
   89:         from_dummies(dummies)
   90: 
   91: 
   92: def test_error_contains_non_dummies():
   93:     dummies = DataFrame(
   94:         {"a": [1, 6, 3, 1], "b": [0, 1, 0, 2], "c": ["c1", "c2", "c3", "c4"]}
   95:     )
   96:     with pytest.raises(
   97:         TypeError,
   98:         match=r"Passed DataFrame contains non-dummy data",
   99:     ):
  100:         from_dummies(dummies)
  101: 
  102: 
  103: def test_error_with_prefix_multiple_seperators():
  104:     dummies = DataFrame(
  105:         {
  106:             "col1_a": [1, 0, 1],
  107:             "col1_b": [0, 1, 0],
  108:             "col2-a": [0, 1, 0],
  109:             "col2-b": [1, 0, 1],
  110:         },
  111:     )
  112:     with pytest.raises(
  113:         ValueError,
  114:         match=(r"Separator not specified for column: col2-a"),
  115:     ):
  116:         from_dummies(dummies, sep="_")
  117: 
  118: 
  119: def test_error_with_prefix_sep_wrong_type(dummies_basic):
  120:     with pytest.raises(
  121:         TypeError,
  122:         match=(
  123:             r"Expected 'sep' to be of type 'str' or 'None'; "
  124:             r"Received 'sep' of type: list"
  125:         ),
  126:     ):
  127:         from_dummies(dummies_basic, sep=["_"])
  128: 
  129: 
  130: def test_error_with_prefix_contains_unassigned(dummies_with_unassigned):
  131:     with pytest.raises(
  132:         ValueError,
  133:         match=(
  134:             r"Dummy DataFrame contains unassigned value\(s\); "
  135:             r"First instance in row: 2"
  136:         ),
  137:     ):
  138:         from_dummies(dummies_with_unassigned, sep="_")
  139: 
  140: 
  141: def test_error_with_prefix_default_category_wrong_type(dummies_with_unassigned):
  142:     with pytest.raises(
  143:         TypeError,
  144:         match=(
  145:             r"Expected 'default_category' to be of type 'None', 'Hashable', or 'dict'; "
  146:             r"Received 'default_category' of type: list"
  147:         ),
  148:     ):
  149:         from_dummies(dummies_with_unassigned, sep="_", default_category=["x", "y"])
  150: 
  151: 
  152: def test_error_with_prefix_default_category_dict_not_complete(
  153:     dummies_with_unassigned,
  154: ):
  155:     with pytest.raises(
  156:         ValueError,
  157:         match=(
  158:             r"Length of 'default_category' \(1\) did not match "
  159:             r"the length of the columns being encoded \(2\)"
  160:         ),
  161:     ):
  162:         from_dummies(dummies_with_unassigned, sep="_", default_category={"col1": "x"})
  163: 
  164: 
  165: def test_error_with_prefix_contains_nan(dummies_basic):
  166:     # Set float64 dtype to avoid upcast when setting np.nan
  167:     dummies_basic["col2_c"] = dummies_basic["col2_c"].astype("float64")
  168:     dummies_basic.loc[2, "col2_c"] = np.nan
  169:     with pytest.raises(
  170:         ValueError, match=r"Dummy DataFrame contains NA value in column: 'col2_c'"
  171:     ):
  172:         from_dummies(dummies_basic, sep="_")
  173: 
  174: 
  175: def test_error_with_prefix_contains_non_dummies(dummies_basic):
  176:     # Set object dtype to avoid upcast when setting "str"
  177:     dummies_basic["col2_c"] = dummies_basic["col2_c"].astype(object)
  178:     dummies_basic.loc[2, "col2_c"] = "str"
  179:     with pytest.raises(TypeError, match=r"Passed DataFrame contains non-dummy data"):
  180:         from_dummies(dummies_basic, sep="_")
  181: 
  182: 
  183: def test_error_with_prefix_double_assignment():
  184:     dummies = DataFrame(
  185:         {
  186:             "col1_a": [1, 0, 1],
  187:             "col1_b": [1, 1, 0],
  188:             "col2_a": [0, 1, 0],
  189:             "col2_b": [1, 0, 0],
  190:             "col2_c": [0, 0, 1],
  191:         },
  192:     )
  193:     with pytest.raises(
  194:         ValueError,
  195:         match=(
  196:             r"Dummy DataFrame contains multi-assignment\(s\); "
  197:             r"First instance in row: 0"
  198:         ),
  199:     ):
  200:         from_dummies(dummies, sep="_")
  201: 
  202: 
  203: def test_roundtrip_series_to_dataframe():
  204:     categories = Series(["a", "b", "c", "a"])
  205:     dummies = get_dummies(categories)
  206:     result = from_dummies(dummies)
  207:     expected = DataFrame({"": ["a", "b", "c", "a"]})
  208:     tm.assert_frame_equal(result, expected)
  209: 
  210: 
  211: def test_roundtrip_single_column_dataframe():
  212:     categories = DataFrame({"": ["a", "b", "c", "a"]})
  213:     dummies = get_dummies(categories)
  214:     result = from_dummies(dummies, sep="_")
  215:     expected = categories
  216:     tm.assert_frame_equal(result, expected)
  217: 
  218: 
  219: def test_roundtrip_with_prefixes():
  220:     categories = DataFrame({"col1": ["a", "b", "a"], "col2": ["b", "a", "c"]})
  221:     dummies = get_dummies(categories)
  222:     result = from_dummies(dummies, sep="_")
  223:     expected = categories
  224:     tm.assert_frame_equal(result, expected)
  225: 
  226: 
  227: def test_no_prefix_string_cats_basic():
  228:     dummies = DataFrame({"a": [1, 0, 0, 1], "b": [0, 1, 0, 0], "c": [0, 0, 1, 0]})
  229:     expected = DataFrame({"": ["a", "b", "c", "a"]})
  230:     result = from_dummies(dummies)
  231:     tm.assert_frame_equal(result, expected)
  232: 
  233: 
  234: def test_no_prefix_string_cats_basic_bool_values():
  235:     dummies = DataFrame(
  236:         {
  237:             "a": [True, False, False, True],
  238:             "b": [False, True, False, False],
  239:             "c": [False, False, True, False],
  240:         }
  241:     )
  242:     expected = DataFrame({"": ["a", "b", "c", "a"]})
  243:     result = from_dummies(dummies)
  244:     tm.assert_frame_equal(result, expected)
  245: 
  246: 
  247: def test_no_prefix_string_cats_basic_mixed_bool_values():
  248:     dummies = DataFrame(
  249:         {"a": [1, 0, 0, 1], "b": [False, True, False, False], "c": [0, 0, 1, 0]}
  250:     )
  251:     expected = DataFrame({"": ["a", "b", "c", "a"]})
  252:     result = from_dummies(dummies)
  253:     tm.assert_frame_equal(result, expected)
  254: 
  255: 
  256: def test_no_prefix_int_cats_basic():
  257:     dummies = DataFrame(
  258:         {1: [1, 0, 0, 0], 25: [0, 1, 0, 0], 2: [0, 0, 1, 0], 5: [0, 0, 0, 1]}
  259:     )
  260:     expected = DataFrame({"": [1, 25, 2, 5]})
  261:     result = from_dummies(dummies)
  262:     tm.assert_frame_equal(result, expected)
  263: 
  264: 
  265: def test_no_prefix_float_cats_basic():
  266:     dummies = DataFrame(
  267:         {1.0: [1, 0, 0, 0], 25.0: [0, 1, 0, 0], 2.5: [0, 0, 1, 0], 5.84: [0, 0, 0, 1]}
  268:     )
  269:     expected = DataFrame({"": [1.0, 25.0, 2.5, 5.84]})
  270:     result = from_dummies(dummies)
  271:     tm.assert_frame_equal(result, expected)
  272: 
  273: 
  274: def test_no_prefix_mixed_cats_basic():
  275:     dummies = DataFrame(
  276:         {
  277:             1.23: [1, 0, 0, 0, 0],
  278:             "c": [0, 1, 0, 0, 0],
  279:             2: [0, 0, 1, 0, 0],
  280:             False: [0, 0, 0, 1, 0],
  281:             None: [0, 0, 0, 0, 1],
  282:         }
  283:     )
  284:     expected = DataFrame({"": [1.23, "c", 2, False, None]}, dtype="object")
  285:     result = from_dummies(dummies)
  286:     tm.assert_frame_equal(result, expected)
  287: 
  288: 
  289: def test_no_prefix_string_cats_contains_get_dummies_NaN_column():
  290:     dummies = DataFrame({"a": [1, 0, 0], "b": [0, 1, 0], "NaN": [0, 0, 1]})
  291:     expected = DataFrame({"": ["a", "b", "NaN"]})
  292:     result = from_dummies(dummies)
  293:     tm.assert_frame_equal(result, expected)
  294: 
  295: 
  296: @pytest.mark.parametrize(
  297:     "default_category, expected",
  298:     [
  299:         pytest.param(
  300:             "c",
  301:             DataFrame({"": ["a", "b", "c"]}),
  302:             id="default_category is a str",
  303:         ),
  304:         pytest.param(
  305:             1,
  306:             DataFrame({"": ["a", "b", 1]}),
  307:             id="default_category is a int",
  308:         ),
  309:         pytest.param(
  310:             1.25,
  311:             DataFrame({"": ["a", "b", 1.25]}),
  312:             id="default_category is a float",
  313:         ),
  314:         pytest.param(
  315:             0,
  316:             DataFrame({"": ["a", "b", 0]}),
  317:             id="default_category is a 0",
  318:         ),
  319:         pytest.param(
  320:             False,
  321:             DataFrame({"": ["a", "b", False]}),
  322:             id="default_category is a bool",
  323:         ),
  324:         pytest.param(
  325:             (1, 2),
  326:             DataFrame({"": ["a", "b", (1, 2)]}),
  327:             id="default_category is a tuple",
  328:         ),
  329:     ],
  330: )
  331: def test_no_prefix_string_cats_default_category(
  332:     default_category, expected, using_infer_string
  333: ):
  334:     dummies = DataFrame({"a": [1, 0, 0], "b": [0, 1, 0]})
  335:     result = from_dummies(dummies, default_category=default_category)
  336:     if using_infer_string:
  337:         expected[""] = expected[""].astype("string[pyarrow_numpy]")
  338:     tm.assert_frame_equal(result, expected)
  339: 
  340: 
  341: def test_with_prefix_basic(dummies_basic):
  342:     expected = DataFrame({"col1": ["a", "b", "a"], "col2": ["b", "a", "c"]})
  343:     result = from_dummies(dummies_basic, sep="_")
  344:     tm.assert_frame_equal(result, expected)
  345: 
  346: 
  347: def test_with_prefix_contains_get_dummies_NaN_column():
  348:     dummies = DataFrame(
  349:         {
  350:             "col1_a": [1, 0, 0],
  351:             "col1_b": [0, 1, 0],
  352:             "col1_NaN": [0, 0, 1],
  353:             "col2_a": [0, 1, 0],
  354:             "col2_b": [0, 0, 0],
  355:             "col2_c": [0, 0, 1],
  356:             "col2_NaN": [1, 0, 0],
  357:         },
  358:     )
  359:     expected = DataFrame({"col1": ["a", "b", "NaN"], "col2": ["NaN", "a", "c"]})
  360:     result = from_dummies(dummies, sep="_")
  361:     tm.assert_frame_equal(result, expected)
  362: 
  363: 
  364: @pytest.mark.parametrize(
  365:     "default_category, expected",
  366:     [
  367:         pytest.param(
  368:             "x",
  369:             DataFrame({"col1": ["a", "b", "x"], "col2": ["x", "a", "c"]}),
  370:             id="default_category is a str",
  371:         ),
  372:         pytest.param(
  373:             0,
  374:             DataFrame({"col1": ["a", "b", 0], "col2": [0, "a", "c"]}),
  375:             id="default_category is a 0",
  376:         ),
  377:         pytest.param(
  378:             False,
  379:             DataFrame({"col1": ["a", "b", False], "col2": [False, "a", "c"]}),
  380:             id="default_category is a False",
  381:         ),
  382:         pytest.param(
  383:             {"col2": 1, "col1": 2.5},
  384:             DataFrame({"col1": ["a", "b", 2.5], "col2": [1, "a", "c"]}),
  385:             id="default_category is a dict with int and float values",
  386:         ),
  387:         pytest.param(
  388:             {"col2": None, "col1": False},
  389:             DataFrame({"col1": ["a", "b", False], "col2": [None, "a", "c"]}),
  390:             id="default_category is a dict with bool and None values",
  391:         ),
  392:         pytest.param(
  393:             {"col2": (1, 2), "col1": [1.25, False]},
  394:             DataFrame({"col1": ["a", "b", [1.25, False]], "col2": [(1, 2), "a", "c"]}),
  395:             id="default_category is a dict with list and tuple values",
  396:         ),
  397:     ],
  398: )
  399: def test_with_prefix_default_category(
  400:     dummies_with_unassigned, default_category, expected
  401: ):
  402:     result = from_dummies(
  403:         dummies_with_unassigned, sep="_", default_category=default_category
  404:     )
  405:     tm.assert_frame_equal(result, expected)
  406: 
  407: 
  408: def test_ea_categories():
  409:     # GH 54300
  410:     df = DataFrame({"a": [1, 0, 0, 1], "b": [0, 1, 0, 0], "c": [0, 0, 1, 0]})
  411:     df.columns = df.columns.astype("string[python]")
  412:     result = from_dummies(df)
  413:     expected = DataFrame({"": Series(list("abca"), dtype="string[python]")})
  414:     tm.assert_frame_equal(result, expected)
  415: 
  416: 
  417: def test_ea_categories_with_sep():
  418:     # GH 54300
  419:     df = DataFrame(
  420:         {
  421:             "col1_a": [1, 0, 1],
  422:             "col1_b": [0, 1, 0],
  423:             "col2_a": [0, 1, 0],
  424:             "col2_b": [1, 0, 0],
  425:             "col2_c": [0, 0, 1],
  426:         }
  427:     )
  428:     df.columns = df.columns.astype("string[python]")
  429:     result = from_dummies(df, sep="_")
  430:     expected = DataFrame(
  431:         {
  432:             "col1": Series(list("aba"), dtype="string[python]"),
  433:             "col2": Series(list("bac"), dtype="string[python]"),
  434:         }
  435:     )
  436:     expected.columns = expected.columns.astype("string[python]")
  437:     tm.assert_frame_equal(result, expected)
  438: 
  439: 
  440: def test_maintain_original_index():
  441:     # GH 54300
  442:     df = DataFrame(
  443:         {"a": [1, 0, 0, 1], "b": [0, 1, 0, 0], "c": [0, 0, 1, 0]}, index=list("abcd")
  444:     )
  445:     result = from_dummies(df)
  446:     expected = DataFrame({"": list("abca")}, index=list("abcd"))
  447:     tm.assert_frame_equal(result, expected)
