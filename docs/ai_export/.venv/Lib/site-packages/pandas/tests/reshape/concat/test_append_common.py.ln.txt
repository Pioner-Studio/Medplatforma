    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Categorical,
    7:     DataFrame,
    8:     Index,
    9:     Series,
   10: )
   11: import pandas._testing as tm
   12: 
   13: 
   14: @pytest.fixture(
   15:     params=list(
   16:         {
   17:             "bool": [True, False, True],
   18:             "int64": [1, 2, 3],
   19:             "float64": [1.1, np.nan, 3.3],
   20:             "category": Categorical(["X", "Y", "Z"]),
   21:             "object": ["a", "b", "c"],
   22:             "datetime64[ns]": [
   23:                 pd.Timestamp("2011-01-01"),
   24:                 pd.Timestamp("2011-01-02"),
   25:                 pd.Timestamp("2011-01-03"),
   26:             ],
   27:             "datetime64[ns, US/Eastern]": [
   28:                 pd.Timestamp("2011-01-01", tz="US/Eastern"),
   29:                 pd.Timestamp("2011-01-02", tz="US/Eastern"),
   30:                 pd.Timestamp("2011-01-03", tz="US/Eastern"),
   31:             ],
   32:             "timedelta64[ns]": [
   33:                 pd.Timedelta("1 days"),
   34:                 pd.Timedelta("2 days"),
   35:                 pd.Timedelta("3 days"),
   36:             ],
   37:             "period[M]": [
   38:                 pd.Period("2011-01", freq="M"),
   39:                 pd.Period("2011-02", freq="M"),
   40:                 pd.Period("2011-03", freq="M"),
   41:             ],
   42:         }.items()
   43:     )
   44: )
   45: def item(request):
   46:     key, data = request.param
   47:     return key, data
   48: 
   49: 
   50: @pytest.fixture
   51: def item2(item):
   52:     return item
   53: 
   54: 
   55: class TestConcatAppendCommon:
   56:     """
   57:     Test common dtype coercion rules between concat and append.
   58:     """
   59: 
   60:     def test_dtypes(self, item, index_or_series, using_infer_string):
   61:         # to confirm test case covers intended dtypes
   62:         typ, vals = item
   63:         obj = index_or_series(vals)
   64:         if typ == "object" and using_infer_string:
   65:             typ = "string"
   66:         if isinstance(obj, Index):
   67:             assert obj.dtype == typ
   68:         elif isinstance(obj, Series):
   69:             if typ.startswith("period"):
   70:                 assert obj.dtype == "Period[M]"
   71:             else:
   72:                 assert obj.dtype == typ
   73: 
   74:     def test_concatlike_same_dtypes(self, item):
   75:         # GH 13660
   76:         typ1, vals1 = item
   77: 
   78:         vals2 = vals1
   79:         vals3 = vals1
   80: 
   81:         if typ1 == "category":
   82:             exp_data = Categorical(list(vals1) + list(vals2))
   83:             exp_data3 = Categorical(list(vals1) + list(vals2) + list(vals3))
   84:         else:
   85:             exp_data = vals1 + vals2
   86:             exp_data3 = vals1 + vals2 + vals3
   87: 
   88:         # ----- Index ----- #
   89: 
   90:         # index.append
   91:         res = Index(vals1).append(Index(vals2))
   92:         exp = Index(exp_data)
   93:         tm.assert_index_equal(res, exp)
   94: 
   95:         # 3 elements
   96:         res = Index(vals1).append([Index(vals2), Index(vals3)])
   97:         exp = Index(exp_data3)
   98:         tm.assert_index_equal(res, exp)
   99: 
  100:         # index.append name mismatch
  101:         i1 = Index(vals1, name="x")
  102:         i2 = Index(vals2, name="y")
  103:         res = i1.append(i2)
  104:         exp = Index(exp_data)
  105:         tm.assert_index_equal(res, exp)
  106: 
  107:         # index.append name match
  108:         i1 = Index(vals1, name="x")
  109:         i2 = Index(vals2, name="x")
  110:         res = i1.append(i2)
  111:         exp = Index(exp_data, name="x")
  112:         tm.assert_index_equal(res, exp)
  113: 
  114:         # cannot append non-index
  115:         with pytest.raises(TypeError, match="all inputs must be Index"):
  116:             Index(vals1).append(vals2)
  117: 
  118:         with pytest.raises(TypeError, match="all inputs must be Index"):
  119:             Index(vals1).append([Index(vals2), vals3])
  120: 
  121:         # ----- Series ----- #
  122: 
  123:         # series.append
  124:         res = Series(vals1)._append(Series(vals2), ignore_index=True)
  125:         exp = Series(exp_data)
  126:         tm.assert_series_equal(res, exp, check_index_type=True)
  127: 
  128:         # concat
  129:         res = pd.concat([Series(vals1), Series(vals2)], ignore_index=True)
  130:         tm.assert_series_equal(res, exp, check_index_type=True)
  131: 
  132:         # 3 elements
  133:         res = Series(vals1)._append([Series(vals2), Series(vals3)], ignore_index=True)
  134:         exp = Series(exp_data3)
  135:         tm.assert_series_equal(res, exp)
  136: 
  137:         res = pd.concat(
  138:             [Series(vals1), Series(vals2), Series(vals3)],
  139:             ignore_index=True,
  140:         )
  141:         tm.assert_series_equal(res, exp)
  142: 
  143:         # name mismatch
  144:         s1 = Series(vals1, name="x")
  145:         s2 = Series(vals2, name="y")
  146:         res = s1._append(s2, ignore_index=True)
  147:         exp = Series(exp_data)
  148:         tm.assert_series_equal(res, exp, check_index_type=True)
  149: 
  150:         res = pd.concat([s1, s2], ignore_index=True)
  151:         tm.assert_series_equal(res, exp, check_index_type=True)
  152: 
  153:         # name match
  154:         s1 = Series(vals1, name="x")
  155:         s2 = Series(vals2, name="x")
  156:         res = s1._append(s2, ignore_index=True)
  157:         exp = Series(exp_data, name="x")
  158:         tm.assert_series_equal(res, exp, check_index_type=True)
  159: 
  160:         res = pd.concat([s1, s2], ignore_index=True)
  161:         tm.assert_series_equal(res, exp, check_index_type=True)
  162: 
  163:         # cannot append non-index
  164:         msg = (
  165:             r"cannot concatenate object of type '.+'; "
  166:             "only Series and DataFrame objs are valid"
  167:         )
  168:         with pytest.raises(TypeError, match=msg):
  169:             Series(vals1)._append(vals2)
  170: 
  171:         with pytest.raises(TypeError, match=msg):
  172:             Series(vals1)._append([Series(vals2), vals3])
  173: 
  174:         with pytest.raises(TypeError, match=msg):
  175:             pd.concat([Series(vals1), vals2])
  176: 
  177:         with pytest.raises(TypeError, match=msg):
  178:             pd.concat([Series(vals1), Series(vals2), vals3])
  179: 
  180:     def test_concatlike_dtypes_coercion(self, item, item2, request):
  181:         # GH 13660
  182:         typ1, vals1 = item
  183:         typ2, vals2 = item2
  184: 
  185:         vals3 = vals2
  186: 
  187:         # basically infer
  188:         exp_index_dtype = None
  189:         exp_series_dtype = None
  190: 
  191:         if typ1 == typ2:
  192:             pytest.skip("same dtype is tested in test_concatlike_same_dtypes")
  193:         elif typ1 == "category" or typ2 == "category":
  194:             pytest.skip("categorical type tested elsewhere")
  195: 
  196:         # specify expected dtype
  197:         if typ1 == "bool" and typ2 in ("int64", "float64"):
  198:             # series coerces to numeric based on numpy rule
  199:             # index doesn't because bool is object dtype
  200:             exp_series_dtype = typ2
  201:             mark = pytest.mark.xfail(reason="GH#39187 casting to object")
  202:             request.applymarker(mark)
  203:         elif typ2 == "bool" and typ1 in ("int64", "float64"):
  204:             exp_series_dtype = typ1
  205:             mark = pytest.mark.xfail(reason="GH#39187 casting to object")
  206:             request.applymarker(mark)
  207:         elif typ1 in {"datetime64[ns, US/Eastern]", "timedelta64[ns]"} or typ2 in {
  208:             "datetime64[ns, US/Eastern]",
  209:             "timedelta64[ns]",
  210:         }:
  211:             exp_index_dtype = object
  212:             exp_series_dtype = object
  213: 
  214:         exp_data = vals1 + vals2
  215:         exp_data3 = vals1 + vals2 + vals3
  216: 
  217:         # ----- Index ----- #
  218: 
  219:         # index.append
  220:         # GH#39817
  221:         res = Index(vals1).append(Index(vals2))
  222:         exp = Index(exp_data, dtype=exp_index_dtype)
  223:         tm.assert_index_equal(res, exp)
  224: 
  225:         # 3 elements
  226:         res = Index(vals1).append([Index(vals2), Index(vals3)])
  227:         exp = Index(exp_data3, dtype=exp_index_dtype)
  228:         tm.assert_index_equal(res, exp)
  229: 
  230:         # ----- Series ----- #
  231: 
  232:         # series._append
  233:         # GH#39817
  234:         res = Series(vals1)._append(Series(vals2), ignore_index=True)
  235:         exp = Series(exp_data, dtype=exp_series_dtype)
  236:         tm.assert_series_equal(res, exp, check_index_type=True)
  237: 
  238:         # concat
  239:         # GH#39817
  240:         res = pd.concat([Series(vals1), Series(vals2)], ignore_index=True)
  241:         tm.assert_series_equal(res, exp, check_index_type=True)
  242: 
  243:         # 3 elements
  244:         # GH#39817
  245:         res = Series(vals1)._append([Series(vals2), Series(vals3)], ignore_index=True)
  246:         exp = Series(exp_data3, dtype=exp_series_dtype)
  247:         tm.assert_series_equal(res, exp)
  248: 
  249:         # GH#39817
  250:         res = pd.concat(
  251:             [Series(vals1), Series(vals2), Series(vals3)],
  252:             ignore_index=True,
  253:         )
  254:         tm.assert_series_equal(res, exp)
  255: 
  256:     def test_concatlike_common_coerce_to_pandas_object(self):
  257:         # GH 13626
  258:         # result must be Timestamp/Timedelta, not datetime.datetime/timedelta
  259:         dti = pd.DatetimeIndex(["2011-01-01", "2011-01-02"])
  260:         tdi = pd.TimedeltaIndex(["1 days", "2 days"])
  261: 
  262:         exp = Index(
  263:             [
  264:                 pd.Timestamp("2011-01-01"),
  265:                 pd.Timestamp("2011-01-02"),
  266:                 pd.Timedelta("1 days"),
  267:                 pd.Timedelta("2 days"),
  268:             ]
  269:         )
  270: 
  271:         res = dti.append(tdi)
  272:         tm.assert_index_equal(res, exp)
  273:         assert isinstance(res[0], pd.Timestamp)
  274:         assert isinstance(res[-1], pd.Timedelta)
  275: 
  276:         dts = Series(dti)
  277:         tds = Series(tdi)
  278:         res = dts._append(tds)
  279:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  280:         assert isinstance(res.iloc[0], pd.Timestamp)
  281:         assert isinstance(res.iloc[-1], pd.Timedelta)
  282: 
  283:         res = pd.concat([dts, tds])
  284:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  285:         assert isinstance(res.iloc[0], pd.Timestamp)
  286:         assert isinstance(res.iloc[-1], pd.Timedelta)
  287: 
  288:     def test_concatlike_datetimetz(self, tz_aware_fixture):
  289:         tz = tz_aware_fixture
  290:         # GH 7795
  291:         dti1 = pd.DatetimeIndex(["2011-01-01", "2011-01-02"], tz=tz)
  292:         dti2 = pd.DatetimeIndex(["2012-01-01", "2012-01-02"], tz=tz)
  293: 
  294:         exp = pd.DatetimeIndex(
  295:             ["2011-01-01", "2011-01-02", "2012-01-01", "2012-01-02"], tz=tz
  296:         )
  297: 
  298:         res = dti1.append(dti2)
  299:         tm.assert_index_equal(res, exp)
  300: 
  301:         dts1 = Series(dti1)
  302:         dts2 = Series(dti2)
  303:         res = dts1._append(dts2)
  304:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  305: 
  306:         res = pd.concat([dts1, dts2])
  307:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  308: 
  309:     @pytest.mark.parametrize("tz", ["UTC", "US/Eastern", "Asia/Tokyo", "EST5EDT"])
  310:     def test_concatlike_datetimetz_short(self, tz):
  311:         # GH#7795
  312:         ix1 = pd.date_range(start="2014-07-15", end="2014-07-17", freq="D", tz=tz)
  313:         ix2 = pd.DatetimeIndex(["2014-07-11", "2014-07-21"], tz=tz)
  314:         df1 = DataFrame(0, index=ix1, columns=["A", "B"])
  315:         df2 = DataFrame(0, index=ix2, columns=["A", "B"])
  316: 
  317:         exp_idx = pd.DatetimeIndex(
  318:             ["2014-07-15", "2014-07-16", "2014-07-17", "2014-07-11", "2014-07-21"],
  319:             tz=tz,
  320:         ).as_unit("ns")
  321:         exp = DataFrame(0, index=exp_idx, columns=["A", "B"])
  322: 
  323:         tm.assert_frame_equal(df1._append(df2), exp)
  324:         tm.assert_frame_equal(pd.concat([df1, df2]), exp)
  325: 
  326:     def test_concatlike_datetimetz_to_object(self, tz_aware_fixture):
  327:         tz = tz_aware_fixture
  328:         # GH 13660
  329: 
  330:         # different tz coerces to object
  331:         dti1 = pd.DatetimeIndex(["2011-01-01", "2011-01-02"], tz=tz)
  332:         dti2 = pd.DatetimeIndex(["2012-01-01", "2012-01-02"])
  333: 
  334:         exp = Index(
  335:             [
  336:                 pd.Timestamp("2011-01-01", tz=tz),
  337:                 pd.Timestamp("2011-01-02", tz=tz),
  338:                 pd.Timestamp("2012-01-01"),
  339:                 pd.Timestamp("2012-01-02"),
  340:             ],
  341:             dtype=object,
  342:         )
  343: 
  344:         res = dti1.append(dti2)
  345:         tm.assert_index_equal(res, exp)
  346: 
  347:         dts1 = Series(dti1)
  348:         dts2 = Series(dti2)
  349:         res = dts1._append(dts2)
  350:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  351: 
  352:         res = pd.concat([dts1, dts2])
  353:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  354: 
  355:         # different tz
  356:         dti3 = pd.DatetimeIndex(["2012-01-01", "2012-01-02"], tz="US/Pacific")
  357: 
  358:         exp = Index(
  359:             [
  360:                 pd.Timestamp("2011-01-01", tz=tz),
  361:                 pd.Timestamp("2011-01-02", tz=tz),
  362:                 pd.Timestamp("2012-01-01", tz="US/Pacific"),
  363:                 pd.Timestamp("2012-01-02", tz="US/Pacific"),
  364:             ],
  365:             dtype=object,
  366:         )
  367: 
  368:         res = dti1.append(dti3)
  369:         tm.assert_index_equal(res, exp)
  370: 
  371:         dts1 = Series(dti1)
  372:         dts3 = Series(dti3)
  373:         res = dts1._append(dts3)
  374:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  375: 
  376:         res = pd.concat([dts1, dts3])
  377:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  378: 
  379:     def test_concatlike_common_period(self):
  380:         # GH 13660
  381:         pi1 = pd.PeriodIndex(["2011-01", "2011-02"], freq="M")
  382:         pi2 = pd.PeriodIndex(["2012-01", "2012-02"], freq="M")
  383: 
  384:         exp = pd.PeriodIndex(["2011-01", "2011-02", "2012-01", "2012-02"], freq="M")
  385: 
  386:         res = pi1.append(pi2)
  387:         tm.assert_index_equal(res, exp)
  388: 
  389:         ps1 = Series(pi1)
  390:         ps2 = Series(pi2)
  391:         res = ps1._append(ps2)
  392:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  393: 
  394:         res = pd.concat([ps1, ps2])
  395:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  396: 
  397:     def test_concatlike_common_period_diff_freq_to_object(self):
  398:         # GH 13221
  399:         pi1 = pd.PeriodIndex(["2011-01", "2011-02"], freq="M")
  400:         pi2 = pd.PeriodIndex(["2012-01-01", "2012-02-01"], freq="D")
  401: 
  402:         exp = Index(
  403:             [
  404:                 pd.Period("2011-01", freq="M"),
  405:                 pd.Period("2011-02", freq="M"),
  406:                 pd.Period("2012-01-01", freq="D"),
  407:                 pd.Period("2012-02-01", freq="D"),
  408:             ],
  409:             dtype=object,
  410:         )
  411: 
  412:         res = pi1.append(pi2)
  413:         tm.assert_index_equal(res, exp)
  414: 
  415:         ps1 = Series(pi1)
  416:         ps2 = Series(pi2)
  417:         res = ps1._append(ps2)
  418:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  419: 
  420:         res = pd.concat([ps1, ps2])
  421:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  422: 
  423:     def test_concatlike_common_period_mixed_dt_to_object(self):
  424:         # GH 13221
  425:         # different datetimelike
  426:         pi1 = pd.PeriodIndex(["2011-01", "2011-02"], freq="M")
  427:         tdi = pd.TimedeltaIndex(["1 days", "2 days"])
  428:         exp = Index(
  429:             [
  430:                 pd.Period("2011-01", freq="M"),
  431:                 pd.Period("2011-02", freq="M"),
  432:                 pd.Timedelta("1 days"),
  433:                 pd.Timedelta("2 days"),
  434:             ],
  435:             dtype=object,
  436:         )
  437: 
  438:         res = pi1.append(tdi)
  439:         tm.assert_index_equal(res, exp)
  440: 
  441:         ps1 = Series(pi1)
  442:         tds = Series(tdi)
  443:         res = ps1._append(tds)
  444:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  445: 
  446:         res = pd.concat([ps1, tds])
  447:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  448: 
  449:         # inverse
  450:         exp = Index(
  451:             [
  452:                 pd.Timedelta("1 days"),
  453:                 pd.Timedelta("2 days"),
  454:                 pd.Period("2011-01", freq="M"),
  455:                 pd.Period("2011-02", freq="M"),
  456:             ],
  457:             dtype=object,
  458:         )
  459: 
  460:         res = tdi.append(pi1)
  461:         tm.assert_index_equal(res, exp)
  462: 
  463:         ps1 = Series(pi1)
  464:         tds = Series(tdi)
  465:         res = tds._append(ps1)
  466:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  467: 
  468:         res = pd.concat([tds, ps1])
  469:         tm.assert_series_equal(res, Series(exp, index=[0, 1, 0, 1]))
  470: 
  471:     def test_concat_categorical(self):
  472:         # GH 13524
  473: 
  474:         # same categories -> category
  475:         s1 = Series([1, 2, np.nan], dtype="category")
  476:         s2 = Series([2, 1, 2], dtype="category")
  477: 
  478:         exp = Series([1, 2, np.nan, 2, 1, 2], dtype="category")
  479:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  480:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  481: 
  482:         # partially different categories => not-category
  483:         s1 = Series([3, 2], dtype="category")
  484:         s2 = Series([2, 1], dtype="category")
  485: 
  486:         exp = Series([3, 2, 2, 1])
  487:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  488:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  489: 
  490:         # completely different categories (same dtype) => not-category
  491:         s1 = Series([10, 11, np.nan], dtype="category")
  492:         s2 = Series([np.nan, 1, 3, 2], dtype="category")
  493: 
  494:         exp = Series([10, 11, np.nan, np.nan, 1, 3, 2], dtype=np.float64)
  495:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  496:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  497: 
  498:     def test_union_categorical_same_categories_different_order(self):
  499:         # https://github.com/pandas-dev/pandas/issues/19096
  500:         a = Series(Categorical(["a", "b", "c"], categories=["a", "b", "c"]))
  501:         b = Series(Categorical(["a", "b", "c"], categories=["b", "a", "c"]))
  502:         result = pd.concat([a, b], ignore_index=True)
  503:         expected = Series(
  504:             Categorical(["a", "b", "c", "a", "b", "c"], categories=["a", "b", "c"])
  505:         )
  506:         tm.assert_series_equal(result, expected)
  507: 
  508:     def test_concat_categorical_coercion(self):
  509:         # GH 13524
  510: 
  511:         # category + not-category => not-category
  512:         s1 = Series([1, 2, np.nan], dtype="category")
  513:         s2 = Series([2, 1, 2])
  514: 
  515:         exp = Series([1, 2, np.nan, 2, 1, 2], dtype=np.float64)
  516:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  517:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  518: 
  519:         # result shouldn't be affected by 1st elem dtype
  520:         exp = Series([2, 1, 2, 1, 2, np.nan], dtype=np.float64)
  521:         tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)
  522:         tm.assert_series_equal(s2._append(s1, ignore_index=True), exp)
  523: 
  524:         # all values are not in category => not-category
  525:         s1 = Series([3, 2], dtype="category")
  526:         s2 = Series([2, 1])
  527: 
  528:         exp = Series([3, 2, 2, 1])
  529:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  530:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  531: 
  532:         exp = Series([2, 1, 3, 2])
  533:         tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)
  534:         tm.assert_series_equal(s2._append(s1, ignore_index=True), exp)
  535: 
  536:         # completely different categories => not-category
  537:         s1 = Series([10, 11, np.nan], dtype="category")
  538:         s2 = Series([1, 3, 2])
  539: 
  540:         exp = Series([10, 11, np.nan, 1, 3, 2], dtype=np.float64)
  541:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  542:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  543: 
  544:         exp = Series([1, 3, 2, 10, 11, np.nan], dtype=np.float64)
  545:         tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)
  546:         tm.assert_series_equal(s2._append(s1, ignore_index=True), exp)
  547: 
  548:         # different dtype => not-category
  549:         s1 = Series([10, 11, np.nan], dtype="category")
  550:         s2 = Series(["a", "b", "c"])
  551: 
  552:         exp = Series([10, 11, np.nan, "a", "b", "c"])
  553:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  554:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  555: 
  556:         exp = Series(["a", "b", "c", 10, 11, np.nan])
  557:         tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)
  558:         tm.assert_series_equal(s2._append(s1, ignore_index=True), exp)
  559: 
  560:         # if normal series only contains NaN-likes => not-category
  561:         s1 = Series([10, 11], dtype="category")
  562:         s2 = Series([np.nan, np.nan, np.nan])
  563: 
  564:         exp = Series([10, 11, np.nan, np.nan, np.nan])
  565:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  566:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  567: 
  568:         exp = Series([np.nan, np.nan, np.nan, 10, 11])
  569:         tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)
  570:         tm.assert_series_equal(s2._append(s1, ignore_index=True), exp)
  571: 
  572:     def test_concat_categorical_3elem_coercion(self):
  573:         # GH 13524
  574: 
  575:         # mixed dtypes => not-category
  576:         s1 = Series([1, 2, np.nan], dtype="category")
  577:         s2 = Series([2, 1, 2], dtype="category")
  578:         s3 = Series([1, 2, 1, 2, np.nan])
  579: 
  580:         exp = Series([1, 2, np.nan, 2, 1, 2, 1, 2, 1, 2, np.nan], dtype="float")
  581:         tm.assert_series_equal(pd.concat([s1, s2, s3], ignore_index=True), exp)
  582:         tm.assert_series_equal(s1._append([s2, s3], ignore_index=True), exp)
  583: 
  584:         exp = Series([1, 2, 1, 2, np.nan, 1, 2, np.nan, 2, 1, 2], dtype="float")
  585:         tm.assert_series_equal(pd.concat([s3, s1, s2], ignore_index=True), exp)
  586:         tm.assert_series_equal(s3._append([s1, s2], ignore_index=True), exp)
  587: 
  588:         # values are all in either category => not-category
  589:         s1 = Series([4, 5, 6], dtype="category")
  590:         s2 = Series([1, 2, 3], dtype="category")
  591:         s3 = Series([1, 3, 4])
  592: 
  593:         exp = Series([4, 5, 6, 1, 2, 3, 1, 3, 4])
  594:         tm.assert_series_equal(pd.concat([s1, s2, s3], ignore_index=True), exp)
  595:         tm.assert_series_equal(s1._append([s2, s3], ignore_index=True), exp)
  596: 
  597:         exp = Series([1, 3, 4, 4, 5, 6, 1, 2, 3])
  598:         tm.assert_series_equal(pd.concat([s3, s1, s2], ignore_index=True), exp)
  599:         tm.assert_series_equal(s3._append([s1, s2], ignore_index=True), exp)
  600: 
  601:         # values are all in either category => not-category
  602:         s1 = Series([4, 5, 6], dtype="category")
  603:         s2 = Series([1, 2, 3], dtype="category")
  604:         s3 = Series([10, 11, 12])
  605: 
  606:         exp = Series([4, 5, 6, 1, 2, 3, 10, 11, 12])
  607:         tm.assert_series_equal(pd.concat([s1, s2, s3], ignore_index=True), exp)
  608:         tm.assert_series_equal(s1._append([s2, s3], ignore_index=True), exp)
  609: 
  610:         exp = Series([10, 11, 12, 4, 5, 6, 1, 2, 3])
  611:         tm.assert_series_equal(pd.concat([s3, s1, s2], ignore_index=True), exp)
  612:         tm.assert_series_equal(s3._append([s1, s2], ignore_index=True), exp)
  613: 
  614:     def test_concat_categorical_multi_coercion(self):
  615:         # GH 13524
  616: 
  617:         s1 = Series([1, 3], dtype="category")
  618:         s2 = Series([3, 4], dtype="category")
  619:         s3 = Series([2, 3])
  620:         s4 = Series([2, 2], dtype="category")
  621:         s5 = Series([1, np.nan])
  622:         s6 = Series([1, 3, 2], dtype="category")
  623: 
  624:         # mixed dtype, values are all in categories => not-category
  625:         exp = Series([1, 3, 3, 4, 2, 3, 2, 2, 1, np.nan, 1, 3, 2])
  626:         res = pd.concat([s1, s2, s3, s4, s5, s6], ignore_index=True)
  627:         tm.assert_series_equal(res, exp)
  628:         res = s1._append([s2, s3, s4, s5, s6], ignore_index=True)
  629:         tm.assert_series_equal(res, exp)
  630: 
  631:         exp = Series([1, 3, 2, 1, np.nan, 2, 2, 2, 3, 3, 4, 1, 3])
  632:         res = pd.concat([s6, s5, s4, s3, s2, s1], ignore_index=True)
  633:         tm.assert_series_equal(res, exp)
  634:         res = s6._append([s5, s4, s3, s2, s1], ignore_index=True)
  635:         tm.assert_series_equal(res, exp)
  636: 
  637:     def test_concat_categorical_ordered(self):
  638:         # GH 13524
  639: 
  640:         s1 = Series(Categorical([1, 2, np.nan], ordered=True))
  641:         s2 = Series(Categorical([2, 1, 2], ordered=True))
  642: 
  643:         exp = Series(Categorical([1, 2, np.nan, 2, 1, 2], ordered=True))
  644:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  645:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  646: 
  647:         exp = Series(Categorical([1, 2, np.nan, 2, 1, 2, 1, 2, np.nan], ordered=True))
  648:         tm.assert_series_equal(pd.concat([s1, s2, s1], ignore_index=True), exp)
  649:         tm.assert_series_equal(s1._append([s2, s1], ignore_index=True), exp)
  650: 
  651:     def test_concat_categorical_coercion_nan(self):
  652:         # GH 13524
  653: 
  654:         # some edge cases
  655:         # category + not-category => not category
  656:         s1 = Series(np.array([np.nan, np.nan], dtype=np.float64), dtype="category")
  657:         s2 = Series([np.nan, 1])
  658: 
  659:         exp = Series([np.nan, np.nan, np.nan, 1])
  660:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  661:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  662: 
  663:         s1 = Series([1, np.nan], dtype="category")
  664:         s2 = Series([np.nan, np.nan])
  665: 
  666:         exp = Series([1, np.nan, np.nan, np.nan], dtype="float")
  667:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  668:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  669: 
  670:         # mixed dtype, all nan-likes => not-category
  671:         s1 = Series([np.nan, np.nan], dtype="category")
  672:         s2 = Series([np.nan, np.nan])
  673: 
  674:         exp = Series([np.nan, np.nan, np.nan, np.nan])
  675:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  676:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  677:         tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)
  678:         tm.assert_series_equal(s2._append(s1, ignore_index=True), exp)
  679: 
  680:         # all category nan-likes => category
  681:         s1 = Series([np.nan, np.nan], dtype="category")
  682:         s2 = Series([np.nan, np.nan], dtype="category")
  683: 
  684:         exp = Series([np.nan, np.nan, np.nan, np.nan], dtype="category")
  685: 
  686:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  687:         tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  688: 
  689:     def test_concat_categorical_empty(self):
  690:         # GH 13524
  691: 
  692:         s1 = Series([], dtype="category")
  693:         s2 = Series([1, 2], dtype="category")
  694: 
  695:         msg = "The behavior of array concatenation with empty entries is deprecated"
  696:         with tm.assert_produces_warning(FutureWarning, match=msg):
  697:             tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), s2)
  698:             tm.assert_series_equal(s1._append(s2, ignore_index=True), s2)
  699: 
  700:         with tm.assert_produces_warning(FutureWarning, match=msg):
  701:             tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), s2)
  702:             tm.assert_series_equal(s2._append(s1, ignore_index=True), s2)
  703: 
  704:         s1 = Series([], dtype="category")
  705:         s2 = Series([], dtype="category")
  706: 
  707:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), s2)
  708:         tm.assert_series_equal(s1._append(s2, ignore_index=True), s2)
  709: 
  710:         s1 = Series([], dtype="category")
  711:         s2 = Series([], dtype="object")
  712: 
  713:         # different dtype => not-category
  714:         tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), s2)
  715:         tm.assert_series_equal(s1._append(s2, ignore_index=True), s2)
  716:         tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), s2)
  717:         tm.assert_series_equal(s2._append(s1, ignore_index=True), s2)
  718: 
  719:         s1 = Series([], dtype="category")
  720:         s2 = Series([np.nan, np.nan])
  721: 
  722:         # empty Series is ignored
  723:         exp = Series([np.nan, np.nan])
  724:         with tm.assert_produces_warning(FutureWarning, match=msg):
  725:             tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)
  726:             tm.assert_series_equal(s1._append(s2, ignore_index=True), exp)
  727: 
  728:         with tm.assert_produces_warning(FutureWarning, match=msg):
  729:             tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)
  730:             tm.assert_series_equal(s2._append(s1, ignore_index=True), exp)
  731: 
  732:     def test_categorical_concat_append(self):
  733:         cat = Categorical(["a", "b"], categories=["a", "b"])
  734:         vals = [1, 2]
  735:         df = DataFrame({"cats": cat, "vals": vals})
  736:         cat2 = Categorical(["a", "b", "a", "b"], categories=["a", "b"])
  737:         vals2 = [1, 2, 1, 2]
  738:         exp = DataFrame({"cats": cat2, "vals": vals2}, index=Index([0, 1, 0, 1]))
  739: 
  740:         tm.assert_frame_equal(pd.concat([df, df]), exp)
  741:         tm.assert_frame_equal(df._append(df), exp)
  742: 
  743:         # GH 13524 can concat different categories
  744:         cat3 = Categorical(["a", "b"], categories=["a", "b", "c"])
  745:         vals3 = [1, 2]
  746:         df_different_categories = DataFrame({"cats": cat3, "vals": vals3})
  747: 
  748:         res = pd.concat([df, df_different_categories], ignore_index=True)
  749:         exp = DataFrame({"cats": list("abab"), "vals": [1, 2, 1, 2]})
  750:         tm.assert_frame_equal(res, exp)
  751: 
  752:         res = df._append(df_different_categories, ignore_index=True)
  753:         tm.assert_frame_equal(res, exp)
