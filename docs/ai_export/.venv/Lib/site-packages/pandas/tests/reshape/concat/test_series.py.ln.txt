    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     DatetimeIndex,
    7:     Index,
    8:     MultiIndex,
    9:     Series,
   10:     concat,
   11:     date_range,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: class TestSeriesConcat:
   17:     def test_concat_series(self):
   18:         ts = Series(
   19:             np.arange(20, dtype=np.float64),
   20:             index=date_range("2020-01-01", periods=20),
   21:             name="foo",
   22:         )
   23:         ts.name = "foo"
   24: 
   25:         pieces = [ts[:5], ts[5:15], ts[15:]]
   26: 
   27:         result = concat(pieces)
   28:         tm.assert_series_equal(result, ts)
   29:         assert result.name == ts.name
   30: 
   31:         result = concat(pieces, keys=[0, 1, 2])
   32:         expected = ts.copy()
   33: 
   34:         ts.index = DatetimeIndex(np.array(ts.index.values, dtype="M8[ns]"))
   35: 
   36:         exp_codes = [np.repeat([0, 1, 2], [len(x) for x in pieces]), np.arange(len(ts))]
   37:         exp_index = MultiIndex(levels=[[0, 1, 2], ts.index], codes=exp_codes)
   38:         expected.index = exp_index
   39:         tm.assert_series_equal(result, expected)
   40: 
   41:     def test_concat_empty_and_non_empty_series_regression(self):
   42:         # GH 18187 regression test
   43:         s1 = Series([1])
   44:         s2 = Series([], dtype=object)
   45: 
   46:         expected = s1
   47:         msg = "The behavior of array concatenation with empty entries is deprecated"
   48:         with tm.assert_produces_warning(FutureWarning, match=msg):
   49:             result = concat([s1, s2])
   50:         tm.assert_series_equal(result, expected)
   51: 
   52:     def test_concat_series_axis1(self):
   53:         ts = Series(
   54:             np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
   55:         )
   56: 
   57:         pieces = [ts[:-2], ts[2:], ts[2:-2]]
   58: 
   59:         result = concat(pieces, axis=1)
   60:         expected = DataFrame(pieces).T
   61:         tm.assert_frame_equal(result, expected)
   62: 
   63:         result = concat(pieces, keys=["A", "B", "C"], axis=1)
   64:         expected = DataFrame(pieces, index=["A", "B", "C"]).T
   65:         tm.assert_frame_equal(result, expected)
   66: 
   67:     def test_concat_series_axis1_preserves_series_names(self):
   68:         # preserve series names, #2489
   69:         s = Series(np.random.default_rng(2).standard_normal(5), name="A")
   70:         s2 = Series(np.random.default_rng(2).standard_normal(5), name="B")
   71: 
   72:         result = concat([s, s2], axis=1)
   73:         expected = DataFrame({"A": s, "B": s2})
   74:         tm.assert_frame_equal(result, expected)
   75: 
   76:         s2.name = None
   77:         result = concat([s, s2], axis=1)
   78:         tm.assert_index_equal(result.columns, Index(["A", 0], dtype="object"))
   79: 
   80:     def test_concat_series_axis1_with_reindex(self, sort):
   81:         # must reindex, #2603
   82:         s = Series(
   83:             np.random.default_rng(2).standard_normal(3), index=["c", "a", "b"], name="A"
   84:         )
   85:         s2 = Series(
   86:             np.random.default_rng(2).standard_normal(4),
   87:             index=["d", "a", "b", "c"],
   88:             name="B",
   89:         )
   90:         result = concat([s, s2], axis=1, sort=sort)
   91:         expected = DataFrame({"A": s, "B": s2}, index=["c", "a", "b", "d"])
   92:         if sort:
   93:             expected = expected.sort_index()
   94:         tm.assert_frame_equal(result, expected)
   95: 
   96:     def test_concat_series_axis1_names_applied(self):
   97:         # ensure names argument is not ignored on axis=1, #23490
   98:         s = Series([1, 2, 3])
   99:         s2 = Series([4, 5, 6])
  100:         result = concat([s, s2], axis=1, keys=["a", "b"], names=["A"])
  101:         expected = DataFrame(
  102:             [[1, 4], [2, 5], [3, 6]], columns=Index(["a", "b"], name="A")
  103:         )
  104:         tm.assert_frame_equal(result, expected)
  105: 
  106:         result = concat([s, s2], axis=1, keys=[("a", 1), ("b", 2)], names=["A", "B"])
  107:         expected = DataFrame(
  108:             [[1, 4], [2, 5], [3, 6]],
  109:             columns=MultiIndex.from_tuples([("a", 1), ("b", 2)], names=["A", "B"]),
  110:         )
  111:         tm.assert_frame_equal(result, expected)
  112: 
  113:     def test_concat_series_axis1_same_names_ignore_index(self):
  114:         dates = date_range("01-Jan-2013", "01-Jan-2014", freq="MS")[0:-1]
  115:         s1 = Series(
  116:             np.random.default_rng(2).standard_normal(len(dates)),
  117:             index=dates,
  118:             name="value",
  119:         )
  120:         s2 = Series(
  121:             np.random.default_rng(2).standard_normal(len(dates)),
  122:             index=dates,
  123:             name="value",
  124:         )
  125: 
  126:         result = concat([s1, s2], axis=1, ignore_index=True)
  127:         expected = Index(range(2))
  128: 
  129:         tm.assert_index_equal(result.columns, expected, exact=True)
  130: 
  131:     @pytest.mark.parametrize(
  132:         "s1name,s2name", [(np.int64(190), (43, 0)), (190, (43, 0))]
  133:     )
  134:     def test_concat_series_name_npscalar_tuple(self, s1name, s2name):
  135:         # GH21015
  136:         s1 = Series({"a": 1, "b": 2}, name=s1name)
  137:         s2 = Series({"c": 5, "d": 6}, name=s2name)
  138:         result = concat([s1, s2])
  139:         expected = Series({"a": 1, "b": 2, "c": 5, "d": 6})
  140:         tm.assert_series_equal(result, expected)
  141: 
  142:     def test_concat_series_partial_columns_names(self):
  143:         # GH10698
  144:         named_series = Series([1, 2], name="foo")
  145:         unnamed_series1 = Series([1, 2])
  146:         unnamed_series2 = Series([4, 5])
  147: 
  148:         result = concat([named_series, unnamed_series1, unnamed_series2], axis=1)
  149:         expected = DataFrame(
  150:             {"foo": [1, 2], 0: [1, 2], 1: [4, 5]}, columns=["foo", 0, 1]
  151:         )
  152:         tm.assert_frame_equal(result, expected)
  153: 
  154:         result = concat(
  155:             [named_series, unnamed_series1, unnamed_series2],
  156:             axis=1,
  157:             keys=["red", "blue", "yellow"],
  158:         )
  159:         expected = DataFrame(
  160:             {"red": [1, 2], "blue": [1, 2], "yellow": [4, 5]},
  161:             columns=["red", "blue", "yellow"],
  162:         )
  163:         tm.assert_frame_equal(result, expected)
  164: 
  165:         result = concat(
  166:             [named_series, unnamed_series1, unnamed_series2], axis=1, ignore_index=True
  167:         )
  168:         expected = DataFrame({0: [1, 2], 1: [1, 2], 2: [4, 5]})
  169:         tm.assert_frame_equal(result, expected)
  170: 
  171:     def test_concat_series_length_one_reversed(self, frame_or_series):
  172:         # GH39401
  173:         obj = frame_or_series([100])
  174:         result = concat([obj.iloc[::-1]])
  175:         tm.assert_equal(result, obj)
