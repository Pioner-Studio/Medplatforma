    1: import datetime as dt
    2: from itertools import combinations
    3: 
    4: import dateutil
    5: import numpy as np
    6: import pytest
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     DataFrame,
   11:     Index,
   12:     Series,
   13:     Timestamp,
   14:     concat,
   15:     isna,
   16: )
   17: import pandas._testing as tm
   18: 
   19: 
   20: class TestAppend:
   21:     def test_append(self, sort, float_frame):
   22:         mixed_frame = float_frame.copy()
   23:         mixed_frame["foo"] = "bar"
   24: 
   25:         begin_index = float_frame.index[:5]
   26:         end_index = float_frame.index[5:]
   27: 
   28:         begin_frame = float_frame.reindex(begin_index)
   29:         end_frame = float_frame.reindex(end_index)
   30: 
   31:         appended = begin_frame._append(end_frame)
   32:         tm.assert_almost_equal(appended["A"], float_frame["A"])
   33: 
   34:         del end_frame["A"]
   35:         partial_appended = begin_frame._append(end_frame, sort=sort)
   36:         assert "A" in partial_appended
   37: 
   38:         partial_appended = end_frame._append(begin_frame, sort=sort)
   39:         assert "A" in partial_appended
   40: 
   41:         # mixed type handling
   42:         appended = mixed_frame[:5]._append(mixed_frame[5:])
   43:         tm.assert_frame_equal(appended, mixed_frame)
   44: 
   45:         # what to test here
   46:         mixed_appended = mixed_frame[:5]._append(float_frame[5:], sort=sort)
   47:         mixed_appended2 = float_frame[:5]._append(mixed_frame[5:], sort=sort)
   48: 
   49:         # all equal except 'foo' column
   50:         tm.assert_frame_equal(
   51:             mixed_appended.reindex(columns=["A", "B", "C", "D"]),
   52:             mixed_appended2.reindex(columns=["A", "B", "C", "D"]),
   53:         )
   54: 
   55:     def test_append_empty(self, float_frame):
   56:         empty = DataFrame()
   57: 
   58:         appended = float_frame._append(empty)
   59:         tm.assert_frame_equal(float_frame, appended)
   60:         assert appended is not float_frame
   61: 
   62:         appended = empty._append(float_frame)
   63:         tm.assert_frame_equal(float_frame, appended)
   64:         assert appended is not float_frame
   65: 
   66:     def test_append_overlap_raises(self, float_frame):
   67:         msg = "Indexes have overlapping values"
   68:         with pytest.raises(ValueError, match=msg):
   69:             float_frame._append(float_frame, verify_integrity=True)
   70: 
   71:     def test_append_new_columns(self):
   72:         # see gh-6129: new columns
   73:         df = DataFrame({"a": {"x": 1, "y": 2}, "b": {"x": 3, "y": 4}})
   74:         row = Series([5, 6, 7], index=["a", "b", "c"], name="z")
   75:         expected = DataFrame(
   76:             {
   77:                 "a": {"x": 1, "y": 2, "z": 5},
   78:                 "b": {"x": 3, "y": 4, "z": 6},
   79:                 "c": {"z": 7},
   80:             }
   81:         )
   82:         result = df._append(row)
   83:         tm.assert_frame_equal(result, expected)
   84: 
   85:     def test_append_length0_frame(self, sort):
   86:         df = DataFrame(columns=["A", "B", "C"])
   87:         df3 = DataFrame(index=[0, 1], columns=["A", "B"])
   88:         df5 = df._append(df3, sort=sort)
   89: 
   90:         expected = DataFrame(index=[0, 1], columns=["A", "B", "C"])
   91:         tm.assert_frame_equal(df5, expected)
   92: 
   93:     def test_append_records(self):
   94:         arr1 = np.zeros((2,), dtype=("i4,f4,S10"))
   95:         arr1[:] = [(1, 2.0, "Hello"), (2, 3.0, "World")]
   96: 
   97:         arr2 = np.zeros((3,), dtype=("i4,f4,S10"))
   98:         arr2[:] = [(3, 4.0, "foo"), (5, 6.0, "bar"), (7.0, 8.0, "baz")]
   99: 
  100:         df1 = DataFrame(arr1)
  101:         df2 = DataFrame(arr2)
  102: 
  103:         result = df1._append(df2, ignore_index=True)
  104:         expected = DataFrame(np.concatenate((arr1, arr2)))
  105:         tm.assert_frame_equal(result, expected)
  106: 
  107:     # rewrite sort fixture, since we also want to test default of None
  108:     def test_append_sorts(self, sort):
  109:         df1 = DataFrame({"a": [1, 2], "b": [1, 2]}, columns=["b", "a"])
  110:         df2 = DataFrame({"a": [1, 2], "c": [3, 4]}, index=[2, 3])
  111: 
  112:         result = df1._append(df2, sort=sort)
  113: 
  114:         # for None / True
  115:         expected = DataFrame(
  116:             {"b": [1, 2, None, None], "a": [1, 2, 1, 2], "c": [None, None, 3, 4]},
  117:             columns=["a", "b", "c"],
  118:         )
  119:         if sort is False:
  120:             expected = expected[["b", "a", "c"]]
  121:         tm.assert_frame_equal(result, expected)
  122: 
  123:     def test_append_different_columns(self, sort):
  124:         df = DataFrame(
  125:             {
  126:                 "bools": np.random.default_rng(2).standard_normal(10) > 0,
  127:                 "ints": np.random.default_rng(2).integers(0, 10, 10),
  128:                 "floats": np.random.default_rng(2).standard_normal(10),
  129:                 "strings": ["foo", "bar"] * 5,
  130:             }
  131:         )
  132: 
  133:         a = df[:5].loc[:, ["bools", "ints", "floats"]]
  134:         b = df[5:].loc[:, ["strings", "ints", "floats"]]
  135: 
  136:         appended = a._append(b, sort=sort)
  137:         assert isna(appended["strings"][0:4]).all()
  138:         assert isna(appended["bools"][5:]).all()
  139: 
  140:     def test_append_many(self, sort, float_frame):
  141:         chunks = [
  142:             float_frame[:5],
  143:             float_frame[5:10],
  144:             float_frame[10:15],
  145:             float_frame[15:],
  146:         ]
  147: 
  148:         result = chunks[0]._append(chunks[1:])
  149:         tm.assert_frame_equal(result, float_frame)
  150: 
  151:         chunks[-1] = chunks[-1].copy()
  152:         chunks[-1]["foo"] = "bar"
  153:         result = chunks[0]._append(chunks[1:], sort=sort)
  154:         tm.assert_frame_equal(result.loc[:, float_frame.columns], float_frame)
  155:         assert (result["foo"][15:] == "bar").all()
  156:         assert result["foo"][:15].isna().all()
  157: 
  158:     def test_append_preserve_index_name(self):
  159:         # #980
  160:         df1 = DataFrame(columns=["A", "B", "C"])
  161:         df1 = df1.set_index(["A"])
  162:         df2 = DataFrame(data=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], columns=["A", "B", "C"])
  163:         df2 = df2.set_index(["A"])
  164: 
  165:         msg = "The behavior of array concatenation with empty entries is deprecated"
  166:         with tm.assert_produces_warning(FutureWarning, match=msg):
  167:             result = df1._append(df2)
  168:         assert result.index.name == "A"
  169: 
  170:     indexes_can_append = [
  171:         pd.RangeIndex(3),
  172:         Index([4, 5, 6]),
  173:         Index([4.5, 5.5, 6.5]),
  174:         Index(list("abc")),
  175:         pd.CategoricalIndex("A B C".split()),
  176:         pd.CategoricalIndex("D E F".split(), ordered=True),
  177:         pd.IntervalIndex.from_breaks([7, 8, 9, 10]),
  178:         pd.DatetimeIndex(
  179:             [
  180:                 dt.datetime(2013, 1, 3, 0, 0),
  181:                 dt.datetime(2013, 1, 3, 6, 10),
  182:                 dt.datetime(2013, 1, 3, 7, 12),
  183:             ]
  184:         ),
  185:         pd.MultiIndex.from_arrays(["A B C".split(), "D E F".split()]),
  186:     ]
  187: 
  188:     @pytest.mark.parametrize(
  189:         "index", indexes_can_append, ids=lambda x: type(x).__name__
  190:     )
  191:     def test_append_same_columns_type(self, index):
  192:         # GH18359
  193: 
  194:         # df wider than ser
  195:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=index)
  196:         ser_index = index[:2]
  197:         ser = Series([7, 8], index=ser_index, name=2)
  198:         result = df._append(ser)
  199:         expected = DataFrame(
  200:             [[1, 2, 3.0], [4, 5, 6], [7, 8, np.nan]], index=[0, 1, 2], columns=index
  201:         )
  202:         # integer dtype is preserved for columns present in ser.index
  203:         assert expected.dtypes.iloc[0].kind == "i"
  204:         assert expected.dtypes.iloc[1].kind == "i"
  205: 
  206:         tm.assert_frame_equal(result, expected)
  207: 
  208:         # ser wider than df
  209:         ser_index = index
  210:         index = index[:2]
  211:         df = DataFrame([[1, 2], [4, 5]], columns=index)
  212:         ser = Series([7, 8, 9], index=ser_index, name=2)
  213:         result = df._append(ser)
  214:         expected = DataFrame(
  215:             [[1, 2, np.nan], [4, 5, np.nan], [7, 8, 9]],
  216:             index=[0, 1, 2],
  217:             columns=ser_index,
  218:         )
  219:         tm.assert_frame_equal(result, expected)
  220: 
  221:     @pytest.mark.parametrize(
  222:         "df_columns, series_index",
  223:         combinations(indexes_can_append, r=2),
  224:         ids=lambda x: type(x).__name__,
  225:     )
  226:     def test_append_different_columns_types(self, df_columns, series_index):
  227:         # GH18359
  228:         # See also test 'test_append_different_columns_types_raises' below
  229:         # for errors raised when appending
  230: 
  231:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=df_columns)
  232:         ser = Series([7, 8, 9], index=series_index, name=2)
  233: 
  234:         result = df._append(ser)
  235:         idx_diff = ser.index.difference(df_columns)
  236:         combined_columns = Index(df_columns.tolist()).append(idx_diff)
  237:         expected = DataFrame(
  238:             [
  239:                 [1.0, 2.0, 3.0, np.nan, np.nan, np.nan],
  240:                 [4, 5, 6, np.nan, np.nan, np.nan],
  241:                 [np.nan, np.nan, np.nan, 7, 8, 9],
  242:             ],
  243:             index=[0, 1, 2],
  244:             columns=combined_columns,
  245:         )
  246:         tm.assert_frame_equal(result, expected)
  247: 
  248:     def test_append_dtype_coerce(self, sort):
  249:         # GH 4993
  250:         # appending with datetime will incorrectly convert datetime64
  251: 
  252:         df1 = DataFrame(
  253:             index=[1, 2],
  254:             data=[dt.datetime(2013, 1, 1, 0, 0), dt.datetime(2013, 1, 2, 0, 0)],
  255:             columns=["start_time"],
  256:         )
  257:         df2 = DataFrame(
  258:             index=[4, 5],
  259:             data=[
  260:                 [dt.datetime(2013, 1, 3, 0, 0), dt.datetime(2013, 1, 3, 6, 10)],
  261:                 [dt.datetime(2013, 1, 4, 0, 0), dt.datetime(2013, 1, 4, 7, 10)],
  262:             ],
  263:             columns=["start_time", "end_time"],
  264:         )
  265: 
  266:         expected = concat(
  267:             [
  268:                 Series(
  269:                     [
  270:                         pd.NaT,
  271:                         pd.NaT,
  272:                         dt.datetime(2013, 1, 3, 6, 10),
  273:                         dt.datetime(2013, 1, 4, 7, 10),
  274:                     ],
  275:                     name="end_time",
  276:                 ),
  277:                 Series(
  278:                     [
  279:                         dt.datetime(2013, 1, 1, 0, 0),
  280:                         dt.datetime(2013, 1, 2, 0, 0),
  281:                         dt.datetime(2013, 1, 3, 0, 0),
  282:                         dt.datetime(2013, 1, 4, 0, 0),
  283:                     ],
  284:                     name="start_time",
  285:                 ),
  286:             ],
  287:             axis=1,
  288:             sort=sort,
  289:         )
  290:         result = df1._append(df2, ignore_index=True, sort=sort)
  291:         if sort:
  292:             expected = expected[["end_time", "start_time"]]
  293:         else:
  294:             expected = expected[["start_time", "end_time"]]
  295: 
  296:         tm.assert_frame_equal(result, expected)
  297: 
  298:     def test_append_missing_column_proper_upcast(self, sort):
  299:         df1 = DataFrame({"A": np.array([1, 2, 3, 4], dtype="i8")})
  300:         df2 = DataFrame({"B": np.array([True, False, True, False], dtype=bool)})
  301: 
  302:         appended = df1._append(df2, ignore_index=True, sort=sort)
  303:         assert appended["A"].dtype == "f8"
  304:         assert appended["B"].dtype == "O"
  305: 
  306:     def test_append_empty_frame_to_series_with_dateutil_tz(self):
  307:         # GH 23682
  308:         date = Timestamp("2018-10-24 07:30:00", tz=dateutil.tz.tzutc())
  309:         ser = Series({"a": 1.0, "b": 2.0, "date": date})
  310:         df = DataFrame(columns=["c", "d"])
  311:         result_a = df._append(ser, ignore_index=True)
  312:         expected = DataFrame(
  313:             [[np.nan, np.nan, 1.0, 2.0, date]], columns=["c", "d", "a", "b", "date"]
  314:         )
  315:         # These columns get cast to object after append
  316:         expected["c"] = expected["c"].astype(object)
  317:         expected["d"] = expected["d"].astype(object)
  318:         tm.assert_frame_equal(result_a, expected)
  319: 
  320:         expected = DataFrame(
  321:             [[np.nan, np.nan, 1.0, 2.0, date]] * 2, columns=["c", "d", "a", "b", "date"]
  322:         )
  323:         expected["c"] = expected["c"].astype(object)
  324:         expected["d"] = expected["d"].astype(object)
  325:         result_b = result_a._append(ser, ignore_index=True)
  326:         tm.assert_frame_equal(result_b, expected)
  327: 
  328:         result = df._append([ser, ser], ignore_index=True)
  329:         tm.assert_frame_equal(result, expected)
  330: 
  331:     def test_append_empty_tz_frame_with_datetime64ns(self, using_array_manager):
  332:         # https://github.com/pandas-dev/pandas/issues/35460
  333:         df = DataFrame(columns=["a"]).astype("datetime64[ns, UTC]")
  334: 
  335:         # pd.NaT gets inferred as tz-naive, so append result is tz-naive
  336:         result = df._append({"a": pd.NaT}, ignore_index=True)
  337:         if using_array_manager:
  338:             expected = DataFrame({"a": [pd.NaT]}, dtype=object)
  339:         else:
  340:             expected = DataFrame({"a": [np.nan]}, dtype=object)
  341:         tm.assert_frame_equal(result, expected)
  342: 
  343:         # also test with typed value to append
  344:         df = DataFrame(columns=["a"]).astype("datetime64[ns, UTC]")
  345:         other = Series({"a": pd.NaT}, dtype="datetime64[ns]")
  346:         result = df._append(other, ignore_index=True)
  347:         tm.assert_frame_equal(result, expected)
  348: 
  349:         # mismatched tz
  350:         other = Series({"a": pd.NaT}, dtype="datetime64[ns, US/Pacific]")
  351:         result = df._append(other, ignore_index=True)
  352:         expected = DataFrame({"a": [pd.NaT]}).astype(object)
  353:         tm.assert_frame_equal(result, expected)
  354: 
  355:     @pytest.mark.parametrize(
  356:         "dtype_str", ["datetime64[ns, UTC]", "datetime64[ns]", "Int64", "int64"]
  357:     )
  358:     @pytest.mark.parametrize("val", [1, "NaT"])
  359:     def test_append_empty_frame_with_timedelta64ns_nat(
  360:         self, dtype_str, val, using_array_manager
  361:     ):
  362:         # https://github.com/pandas-dev/pandas/issues/35460
  363:         df = DataFrame(columns=["a"]).astype(dtype_str)
  364: 
  365:         other = DataFrame({"a": [np.timedelta64(val, "ns")]})
  366:         result = df._append(other, ignore_index=True)
  367: 
  368:         expected = other.astype(object)
  369:         if isinstance(val, str) and dtype_str != "int64" and not using_array_manager:
  370:             # TODO: expected used to be `other.astype(object)` which is a more
  371:             #  reasonable result.  This was changed when tightening
  372:             #  assert_frame_equal's treatment of mismatched NAs to match the
  373:             #  existing behavior.
  374:             expected = DataFrame({"a": [np.nan]}, dtype=object)
  375:         tm.assert_frame_equal(result, expected)
  376: 
  377:     @pytest.mark.parametrize(
  378:         "dtype_str", ["datetime64[ns, UTC]", "datetime64[ns]", "Int64", "int64"]
  379:     )
  380:     @pytest.mark.parametrize("val", [1, "NaT"])
  381:     def test_append_frame_with_timedelta64ns_nat(self, dtype_str, val):
  382:         # https://github.com/pandas-dev/pandas/issues/35460
  383:         df = DataFrame({"a": pd.array([1], dtype=dtype_str)})
  384: 
  385:         other = DataFrame({"a": [np.timedelta64(val, "ns")]})
  386:         result = df._append(other, ignore_index=True)
  387: 
  388:         expected = DataFrame({"a": [df.iloc[0, 0], other.iloc[0, 0]]}, dtype=object)
  389:         tm.assert_frame_equal(result, expected)
