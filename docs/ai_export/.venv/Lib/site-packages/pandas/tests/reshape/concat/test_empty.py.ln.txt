    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     DataFrame,
    7:     RangeIndex,
    8:     Series,
    9:     concat,
   10:     date_range,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: class TestEmptyConcat:
   16:     def test_handle_empty_objects(self, sort, using_infer_string):
   17:         df = DataFrame(
   18:             np.random.default_rng(2).standard_normal((10, 4)), columns=list("abcd")
   19:         )
   20: 
   21:         dfcopy = df[:5].copy()
   22:         dfcopy["foo"] = "bar"
   23:         empty = df[5:5]
   24: 
   25:         frames = [dfcopy, empty, empty, df[5:]]
   26:         concatted = concat(frames, axis=0, sort=sort)
   27: 
   28:         expected = df.reindex(columns=["a", "b", "c", "d", "foo"])
   29:         expected["foo"] = expected["foo"].astype(
   30:             object if not using_infer_string else "string[pyarrow_numpy]"
   31:         )
   32:         expected.loc[0:4, "foo"] = "bar"
   33: 
   34:         tm.assert_frame_equal(concatted, expected)
   35: 
   36:         # empty as first element with time series
   37:         # GH3259
   38:         df = DataFrame(
   39:             {"A": range(10000)}, index=date_range("20130101", periods=10000, freq="s")
   40:         )
   41:         empty = DataFrame()
   42:         result = concat([df, empty], axis=1)
   43:         tm.assert_frame_equal(result, df)
   44:         result = concat([empty, df], axis=1)
   45:         tm.assert_frame_equal(result, df)
   46: 
   47:         result = concat([df, empty])
   48:         tm.assert_frame_equal(result, df)
   49:         result = concat([empty, df])
   50:         tm.assert_frame_equal(result, df)
   51: 
   52:     def test_concat_empty_series(self):
   53:         # GH 11082
   54:         s1 = Series([1, 2, 3], name="x")
   55:         s2 = Series(name="y", dtype="float64")
   56:         res = concat([s1, s2], axis=1)
   57:         exp = DataFrame(
   58:             {"x": [1, 2, 3], "y": [np.nan, np.nan, np.nan]},
   59:             index=RangeIndex(3),
   60:         )
   61:         tm.assert_frame_equal(res, exp)
   62: 
   63:         s1 = Series([1, 2, 3], name="x")
   64:         s2 = Series(name="y", dtype="float64")
   65:         msg = "The behavior of array concatenation with empty entries is deprecated"
   66:         with tm.assert_produces_warning(FutureWarning, match=msg):
   67:             res = concat([s1, s2], axis=0)
   68:         # name will be reset
   69:         exp = Series([1, 2, 3])
   70:         tm.assert_series_equal(res, exp)
   71: 
   72:         # empty Series with no name
   73:         s1 = Series([1, 2, 3], name="x")
   74:         s2 = Series(name=None, dtype="float64")
   75:         res = concat([s1, s2], axis=1)
   76:         exp = DataFrame(
   77:             {"x": [1, 2, 3], 0: [np.nan, np.nan, np.nan]},
   78:             columns=["x", 0],
   79:             index=RangeIndex(3),
   80:         )
   81:         tm.assert_frame_equal(res, exp)
   82: 
   83:     @pytest.mark.parametrize("tz", [None, "UTC"])
   84:     @pytest.mark.parametrize("values", [[], [1, 2, 3]])
   85:     def test_concat_empty_series_timelike(self, tz, values):
   86:         # GH 18447
   87: 
   88:         first = Series([], dtype="M8[ns]").dt.tz_localize(tz)
   89:         dtype = None if values else np.float64
   90:         second = Series(values, dtype=dtype)
   91: 
   92:         expected = DataFrame(
   93:             {
   94:                 0: Series([pd.NaT] * len(values), dtype="M8[ns]").dt.tz_localize(tz),
   95:                 1: values,
   96:             }
   97:         )
   98:         result = concat([first, second], axis=1)
   99:         tm.assert_frame_equal(result, expected)
  100: 
  101:     @pytest.mark.parametrize(
  102:         "left,right,expected",
  103:         [
  104:             # booleans
  105:             (np.bool_, np.int32, np.object_),  # changed from int32 in 2.0 GH#39817
  106:             (np.bool_, np.float32, np.object_),
  107:             # datetime-like
  108:             ("m8[ns]", np.bool_, np.object_),
  109:             ("m8[ns]", np.int64, np.object_),
  110:             ("M8[ns]", np.bool_, np.object_),
  111:             ("M8[ns]", np.int64, np.object_),
  112:             # categorical
  113:             ("category", "category", "category"),
  114:             ("category", "object", "object"),
  115:         ],
  116:     )
  117:     def test_concat_empty_series_dtypes(self, left, right, expected):
  118:         # GH#39817, GH#45101
  119:         result = concat([Series(dtype=left), Series(dtype=right)])
  120:         assert result.dtype == expected
  121: 
  122:     @pytest.mark.parametrize(
  123:         "dtype", ["float64", "int8", "uint8", "bool", "m8[ns]", "M8[ns]"]
  124:     )
  125:     def test_concat_empty_series_dtypes_match_roundtrips(self, dtype):
  126:         dtype = np.dtype(dtype)
  127: 
  128:         result = concat([Series(dtype=dtype)])
  129:         assert result.dtype == dtype
  130: 
  131:         result = concat([Series(dtype=dtype), Series(dtype=dtype)])
  132:         assert result.dtype == dtype
  133: 
  134:     @pytest.mark.parametrize("dtype", ["float64", "int8", "uint8", "m8[ns]", "M8[ns]"])
  135:     @pytest.mark.parametrize(
  136:         "dtype2",
  137:         ["float64", "int8", "uint8", "m8[ns]", "M8[ns]"],
  138:     )
  139:     def test_concat_empty_series_dtypes_roundtrips(self, dtype, dtype2):
  140:         # round-tripping with self & like self
  141:         if dtype == dtype2:
  142:             pytest.skip("same dtype is not applicable for test")
  143: 
  144:         def int_result_type(dtype, dtype2):
  145:             typs = {dtype.kind, dtype2.kind}
  146:             if not len(typs - {"i", "u", "b"}) and (
  147:                 dtype.kind == "i" or dtype2.kind == "i"
  148:             ):
  149:                 return "i"
  150:             elif not len(typs - {"u", "b"}) and (
  151:                 dtype.kind == "u" or dtype2.kind == "u"
  152:             ):
  153:                 return "u"
  154:             return None
  155: 
  156:         def float_result_type(dtype, dtype2):
  157:             typs = {dtype.kind, dtype2.kind}
  158:             if not len(typs - {"f", "i", "u"}) and (
  159:                 dtype.kind == "f" or dtype2.kind == "f"
  160:             ):
  161:                 return "f"
  162:             return None
  163: 
  164:         def get_result_type(dtype, dtype2):
  165:             result = float_result_type(dtype, dtype2)
  166:             if result is not None:
  167:                 return result
  168:             result = int_result_type(dtype, dtype2)
  169:             if result is not None:
  170:                 return result
  171:             return "O"
  172: 
  173:         dtype = np.dtype(dtype)
  174:         dtype2 = np.dtype(dtype2)
  175:         expected = get_result_type(dtype, dtype2)
  176:         result = concat([Series(dtype=dtype), Series(dtype=dtype2)]).dtype
  177:         assert result.kind == expected
  178: 
  179:     def test_concat_empty_series_dtypes_triple(self):
  180:         assert (
  181:             concat(
  182:                 [Series(dtype="M8[ns]"), Series(dtype=np.bool_), Series(dtype=np.int64)]
  183:             ).dtype
  184:             == np.object_
  185:         )
  186: 
  187:     def test_concat_empty_series_dtype_category_with_array(self):
  188:         # GH#18515
  189:         assert (
  190:             concat(
  191:                 [Series(np.array([]), dtype="category"), Series(dtype="float64")]
  192:             ).dtype
  193:             == "float64"
  194:         )
  195: 
  196:     def test_concat_empty_series_dtypes_sparse(self):
  197:         result = concat(
  198:             [
  199:                 Series(dtype="float64").astype("Sparse"),
  200:                 Series(dtype="float64").astype("Sparse"),
  201:             ]
  202:         )
  203:         assert result.dtype == "Sparse[float64]"
  204: 
  205:         result = concat(
  206:             [Series(dtype="float64").astype("Sparse"), Series(dtype="float64")]
  207:         )
  208:         expected = pd.SparseDtype(np.float64)
  209:         assert result.dtype == expected
  210: 
  211:         result = concat(
  212:             [Series(dtype="float64").astype("Sparse"), Series(dtype="object")]
  213:         )
  214:         expected = pd.SparseDtype("object")
  215:         assert result.dtype == expected
  216: 
  217:     def test_concat_empty_df_object_dtype(self):
  218:         # GH 9149
  219:         df_1 = DataFrame({"Row": [0, 1, 1], "EmptyCol": np.nan, "NumberCol": [1, 2, 3]})
  220:         df_2 = DataFrame(columns=df_1.columns)
  221:         result = concat([df_1, df_2], axis=0)
  222:         expected = df_1.astype(object)
  223:         tm.assert_frame_equal(result, expected)
  224: 
  225:     def test_concat_empty_dataframe_dtypes(self):
  226:         df = DataFrame(columns=list("abc"))
  227:         df["a"] = df["a"].astype(np.bool_)
  228:         df["b"] = df["b"].astype(np.int32)
  229:         df["c"] = df["c"].astype(np.float64)
  230: 
  231:         result = concat([df, df])
  232:         assert result["a"].dtype == np.bool_
  233:         assert result["b"].dtype == np.int32
  234:         assert result["c"].dtype == np.float64
  235: 
  236:         result = concat([df, df.astype(np.float64)])
  237:         assert result["a"].dtype == np.object_
  238:         assert result["b"].dtype == np.float64
  239:         assert result["c"].dtype == np.float64
  240: 
  241:     def test_concat_inner_join_empty(self):
  242:         # GH 15328
  243:         df_empty = DataFrame()
  244:         df_a = DataFrame({"a": [1, 2]}, index=[0, 1], dtype="int64")
  245:         df_expected = DataFrame({"a": []}, index=RangeIndex(0), dtype="int64")
  246: 
  247:         result = concat([df_a, df_empty], axis=1, join="inner")
  248:         tm.assert_frame_equal(result, df_expected)
  249: 
  250:         result = concat([df_a, df_empty], axis=1, join="outer")
  251:         tm.assert_frame_equal(result, df_a)
  252: 
  253:     def test_empty_dtype_coerce(self):
  254:         # xref to #12411
  255:         # xref to #12045
  256:         # xref to #11594
  257:         # see below
  258: 
  259:         # 10571
  260:         df1 = DataFrame(data=[[1, None], [2, None]], columns=["a", "b"])
  261:         df2 = DataFrame(data=[[3, None], [4, None]], columns=["a", "b"])
  262:         result = concat([df1, df2])
  263:         expected = df1.dtypes
  264:         tm.assert_series_equal(result.dtypes, expected)
  265: 
  266:     def test_concat_empty_dataframe(self):
  267:         # 39037
  268:         df1 = DataFrame(columns=["a", "b"])
  269:         df2 = DataFrame(columns=["b", "c"])
  270:         result = concat([df1, df2, df1])
  271:         expected = DataFrame(columns=["a", "b", "c"])
  272:         tm.assert_frame_equal(result, expected)
  273: 
  274:         df3 = DataFrame(columns=["a", "b"])
  275:         df4 = DataFrame(columns=["b"])
  276:         result = concat([df3, df4])
  277:         expected = DataFrame(columns=["a", "b"])
  278:         tm.assert_frame_equal(result, expected)
  279: 
  280:     def test_concat_empty_dataframe_different_dtypes(self, using_infer_string):
  281:         # 39037
  282:         df1 = DataFrame({"a": [1, 2, 3], "b": ["a", "b", "c"]})
  283:         df2 = DataFrame({"a": [1, 2, 3]})
  284: 
  285:         result = concat([df1[:0], df2[:0]])
  286:         assert result["a"].dtype == np.int64
  287:         assert result["b"].dtype == np.object_ if not using_infer_string else "string"
  288: 
  289:     def test_concat_to_empty_ea(self):
  290:         """48510 `concat` to an empty EA should maintain type EA dtype."""
  291:         df_empty = DataFrame({"a": pd.array([], dtype=pd.Int64Dtype())})
  292:         df_new = DataFrame({"a": pd.array([1, 2, 3], dtype=pd.Int64Dtype())})
  293:         expected = df_new.copy()
  294:         result = concat([df_empty, df_new])
  295:         tm.assert_frame_equal(result, expected)
