    1: import datetime as dt
    2: from datetime import datetime
    3: 
    4: import dateutil
    5: import numpy as np
    6: import pytest
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     DataFrame,
   11:     DatetimeIndex,
   12:     Index,
   13:     MultiIndex,
   14:     Series,
   15:     Timestamp,
   16:     concat,
   17:     date_range,
   18:     to_timedelta,
   19: )
   20: import pandas._testing as tm
   21: 
   22: 
   23: class TestDatetimeConcat:
   24:     def test_concat_datetime64_block(self):
   25:         rng = date_range("1/1/2000", periods=10)
   26: 
   27:         df = DataFrame({"time": rng})
   28: 
   29:         result = concat([df, df])
   30:         assert (result.iloc[:10]["time"] == rng).all()
   31:         assert (result.iloc[10:]["time"] == rng).all()
   32: 
   33:     def test_concat_datetime_datetime64_frame(self):
   34:         # GH#2624
   35:         rows = []
   36:         rows.append([datetime(2010, 1, 1), 1])
   37:         rows.append([datetime(2010, 1, 2), "hi"])
   38: 
   39:         df2_obj = DataFrame.from_records(rows, columns=["date", "test"])
   40: 
   41:         ind = date_range(start="2000/1/1", freq="D", periods=10)
   42:         df1 = DataFrame({"date": ind, "test": range(10)})
   43: 
   44:         # it works!
   45:         concat([df1, df2_obj])
   46: 
   47:     def test_concat_datetime_timezone(self):
   48:         # GH 18523
   49:         idx1 = date_range("2011-01-01", periods=3, freq="h", tz="Europe/Paris")
   50:         idx2 = date_range(start=idx1[0], end=idx1[-1], freq="h")
   51:         df1 = DataFrame({"a": [1, 2, 3]}, index=idx1)
   52:         df2 = DataFrame({"b": [1, 2, 3]}, index=idx2)
   53:         result = concat([df1, df2], axis=1)
   54: 
   55:         exp_idx = DatetimeIndex(
   56:             [
   57:                 "2011-01-01 00:00:00+01:00",
   58:                 "2011-01-01 01:00:00+01:00",
   59:                 "2011-01-01 02:00:00+01:00",
   60:             ],
   61:             dtype="M8[ns, Europe/Paris]",
   62:             freq="h",
   63:         )
   64:         expected = DataFrame(
   65:             [[1, 1], [2, 2], [3, 3]], index=exp_idx, columns=["a", "b"]
   66:         )
   67: 
   68:         tm.assert_frame_equal(result, expected)
   69: 
   70:         idx3 = date_range("2011-01-01", periods=3, freq="h", tz="Asia/Tokyo")
   71:         df3 = DataFrame({"b": [1, 2, 3]}, index=idx3)
   72:         result = concat([df1, df3], axis=1)
   73: 
   74:         exp_idx = DatetimeIndex(
   75:             [
   76:                 "2010-12-31 15:00:00+00:00",
   77:                 "2010-12-31 16:00:00+00:00",
   78:                 "2010-12-31 17:00:00+00:00",
   79:                 "2010-12-31 23:00:00+00:00",
   80:                 "2011-01-01 00:00:00+00:00",
   81:                 "2011-01-01 01:00:00+00:00",
   82:             ]
   83:         ).as_unit("ns")
   84: 
   85:         expected = DataFrame(
   86:             [
   87:                 [np.nan, 1],
   88:                 [np.nan, 2],
   89:                 [np.nan, 3],
   90:                 [1, np.nan],
   91:                 [2, np.nan],
   92:                 [3, np.nan],
   93:             ],
   94:             index=exp_idx,
   95:             columns=["a", "b"],
   96:         )
   97: 
   98:         tm.assert_frame_equal(result, expected)
   99: 
  100:         # GH 13783: Concat after resample
  101:         result = concat([df1.resample("h").mean(), df2.resample("h").mean()], sort=True)
  102:         expected = DataFrame(
  103:             {"a": [1, 2, 3] + [np.nan] * 3, "b": [np.nan] * 3 + [1, 2, 3]},
  104:             index=idx1.append(idx1),
  105:         )
  106:         tm.assert_frame_equal(result, expected)
  107: 
  108:     def test_concat_datetimeindex_freq(self):
  109:         # GH 3232
  110:         # Monotonic index result
  111:         dr = date_range("01-Jan-2013", periods=100, freq="50ms", tz="UTC")
  112:         data = list(range(100))
  113:         expected = DataFrame(data, index=dr)
  114:         result = concat([expected[:50], expected[50:]])
  115:         tm.assert_frame_equal(result, expected)
  116: 
  117:         # Non-monotonic index result
  118:         result = concat([expected[50:], expected[:50]])
  119:         expected = DataFrame(data[50:] + data[:50], index=dr[50:].append(dr[:50]))
  120:         expected.index._data.freq = None
  121:         tm.assert_frame_equal(result, expected)
  122: 
  123:     def test_concat_multiindex_datetime_object_index(self):
  124:         # https://github.com/pandas-dev/pandas/issues/11058
  125:         idx = Index(
  126:             [dt.date(2013, 1, 1), dt.date(2014, 1, 1), dt.date(2015, 1, 1)],
  127:             dtype="object",
  128:         )
  129: 
  130:         s = Series(
  131:             ["a", "b"],
  132:             index=MultiIndex.from_arrays(
  133:                 [
  134:                     [1, 2],
  135:                     idx[:-1],
  136:                 ],
  137:                 names=["first", "second"],
  138:             ),
  139:         )
  140:         s2 = Series(
  141:             ["a", "b"],
  142:             index=MultiIndex.from_arrays(
  143:                 [[1, 2], idx[::2]],
  144:                 names=["first", "second"],
  145:             ),
  146:         )
  147:         mi = MultiIndex.from_arrays(
  148:             [[1, 2, 2], idx],
  149:             names=["first", "second"],
  150:         )
  151:         assert mi.levels[1].dtype == object
  152: 
  153:         expected = DataFrame(
  154:             [["a", "a"], ["b", np.nan], [np.nan, "b"]],
  155:             index=mi,
  156:         )
  157:         result = concat([s, s2], axis=1)
  158:         tm.assert_frame_equal(result, expected)
  159: 
  160:     def test_concat_NaT_series(self):
  161:         # GH 11693
  162:         # test for merging NaT series with datetime series.
  163:         x = Series(
  164:             date_range("20151124 08:00", "20151124 09:00", freq="1h", tz="US/Eastern")
  165:         )
  166:         y = Series(pd.NaT, index=[0, 1], dtype="datetime64[ns, US/Eastern]")
  167:         expected = Series([x[0], x[1], pd.NaT, pd.NaT])
  168: 
  169:         result = concat([x, y], ignore_index=True)
  170:         tm.assert_series_equal(result, expected)
  171: 
  172:         # all NaT with tz
  173:         expected = Series(pd.NaT, index=range(4), dtype="datetime64[ns, US/Eastern]")
  174:         result = concat([y, y], ignore_index=True)
  175:         tm.assert_series_equal(result, expected)
  176: 
  177:     def test_concat_NaT_series2(self):
  178:         # without tz
  179:         x = Series(date_range("20151124 08:00", "20151124 09:00", freq="1h"))
  180:         y = Series(date_range("20151124 10:00", "20151124 11:00", freq="1h"))
  181:         y[:] = pd.NaT
  182:         expected = Series([x[0], x[1], pd.NaT, pd.NaT])
  183:         result = concat([x, y], ignore_index=True)
  184:         tm.assert_series_equal(result, expected)
  185: 
  186:         # all NaT without tz
  187:         x[:] = pd.NaT
  188:         expected = Series(pd.NaT, index=range(4), dtype="datetime64[ns]")
  189:         result = concat([x, y], ignore_index=True)
  190:         tm.assert_series_equal(result, expected)
  191: 
  192:     @pytest.mark.parametrize("tz", [None, "UTC"])
  193:     def test_concat_NaT_dataframes(self, tz):
  194:         # GH 12396
  195: 
  196:         dti = DatetimeIndex([pd.NaT, pd.NaT], tz=tz)
  197:         first = DataFrame({0: dti})
  198:         second = DataFrame(
  199:             [[Timestamp("2015/01/01", tz=tz)], [Timestamp("2016/01/01", tz=tz)]],
  200:             index=[2, 3],
  201:         )
  202:         expected = DataFrame(
  203:             [
  204:                 pd.NaT,
  205:                 pd.NaT,
  206:                 Timestamp("2015/01/01", tz=tz),
  207:                 Timestamp("2016/01/01", tz=tz),
  208:             ]
  209:         )
  210: 
  211:         result = concat([first, second], axis=0)
  212:         tm.assert_frame_equal(result, expected)
  213: 
  214:     @pytest.mark.parametrize("tz1", [None, "UTC"])
  215:     @pytest.mark.parametrize("tz2", [None, "UTC"])
  216:     @pytest.mark.parametrize("item", [pd.NaT, Timestamp("20150101")])
  217:     def test_concat_NaT_dataframes_all_NaT_axis_0(
  218:         self, tz1, tz2, item, using_array_manager
  219:     ):
  220:         # GH 12396
  221: 
  222:         # tz-naive
  223:         first = DataFrame([[pd.NaT], [pd.NaT]]).apply(lambda x: x.dt.tz_localize(tz1))
  224:         second = DataFrame([item]).apply(lambda x: x.dt.tz_localize(tz2))
  225: 
  226:         result = concat([first, second], axis=0)
  227:         expected = DataFrame(Series([pd.NaT, pd.NaT, item], index=[0, 1, 0]))
  228:         expected = expected.apply(lambda x: x.dt.tz_localize(tz2))
  229:         if tz1 != tz2:
  230:             expected = expected.astype(object)
  231:             if item is pd.NaT and not using_array_manager:
  232:                 # GH#18463
  233:                 # TODO: setting nan here is to keep the test passing as we
  234:                 #  make assert_frame_equal stricter, but is nan really the
  235:                 #  ideal behavior here?
  236:                 if tz1 is not None:
  237:                     expected.iloc[-1, 0] = np.nan
  238:                 else:
  239:                     expected.iloc[:-1, 0] = np.nan
  240: 
  241:         tm.assert_frame_equal(result, expected)
  242: 
  243:     @pytest.mark.parametrize("tz1", [None, "UTC"])
  244:     @pytest.mark.parametrize("tz2", [None, "UTC"])
  245:     def test_concat_NaT_dataframes_all_NaT_axis_1(self, tz1, tz2):
  246:         # GH 12396
  247: 
  248:         first = DataFrame(Series([pd.NaT, pd.NaT]).dt.tz_localize(tz1))
  249:         second = DataFrame(Series([pd.NaT]).dt.tz_localize(tz2), columns=[1])
  250:         expected = DataFrame(
  251:             {
  252:                 0: Series([pd.NaT, pd.NaT]).dt.tz_localize(tz1),
  253:                 1: Series([pd.NaT, pd.NaT]).dt.tz_localize(tz2),
  254:             }
  255:         )
  256:         result = concat([first, second], axis=1)
  257:         tm.assert_frame_equal(result, expected)
  258: 
  259:     @pytest.mark.parametrize("tz1", [None, "UTC"])
  260:     @pytest.mark.parametrize("tz2", [None, "UTC"])
  261:     def test_concat_NaT_series_dataframe_all_NaT(self, tz1, tz2):
  262:         # GH 12396
  263: 
  264:         # tz-naive
  265:         first = Series([pd.NaT, pd.NaT]).dt.tz_localize(tz1)
  266:         second = DataFrame(
  267:             [
  268:                 [Timestamp("2015/01/01", tz=tz2)],
  269:                 [Timestamp("2016/01/01", tz=tz2)],
  270:             ],
  271:             index=[2, 3],
  272:         )
  273: 
  274:         expected = DataFrame(
  275:             [
  276:                 pd.NaT,
  277:                 pd.NaT,
  278:                 Timestamp("2015/01/01", tz=tz2),
  279:                 Timestamp("2016/01/01", tz=tz2),
  280:             ]
  281:         )
  282:         if tz1 != tz2:
  283:             expected = expected.astype(object)
  284: 
  285:         result = concat([first, second])
  286:         tm.assert_frame_equal(result, expected)
  287: 
  288: 
  289: class TestTimezoneConcat:
  290:     def test_concat_tz_series(self):
  291:         # gh-11755: tz and no tz
  292:         x = Series(date_range("20151124 08:00", "20151124 09:00", freq="1h", tz="UTC"))
  293:         y = Series(date_range("2012-01-01", "2012-01-02"))
  294:         expected = Series([x[0], x[1], y[0], y[1]], dtype="object")
  295:         result = concat([x, y], ignore_index=True)
  296:         tm.assert_series_equal(result, expected)
  297: 
  298:     def test_concat_tz_series2(self):
  299:         # gh-11887: concat tz and object
  300:         x = Series(date_range("20151124 08:00", "20151124 09:00", freq="1h", tz="UTC"))
  301:         y = Series(["a", "b"])
  302:         expected = Series([x[0], x[1], y[0], y[1]], dtype="object")
  303:         result = concat([x, y], ignore_index=True)
  304:         tm.assert_series_equal(result, expected)
  305: 
  306:     def test_concat_tz_series3(self, unit, unit2):
  307:         # see gh-12217 and gh-12306
  308:         # Concatenating two UTC times
  309:         first = DataFrame([[datetime(2016, 1, 1)]], dtype=f"M8[{unit}]")
  310:         first[0] = first[0].dt.tz_localize("UTC")
  311: 
  312:         second = DataFrame([[datetime(2016, 1, 2)]], dtype=f"M8[{unit2}]")
  313:         second[0] = second[0].dt.tz_localize("UTC")
  314: 
  315:         result = concat([first, second])
  316:         exp_unit = tm.get_finest_unit(unit, unit2)
  317:         assert result[0].dtype == f"datetime64[{exp_unit}, UTC]"
  318: 
  319:     def test_concat_tz_series4(self, unit, unit2):
  320:         # Concatenating two London times
  321:         first = DataFrame([[datetime(2016, 1, 1)]], dtype=f"M8[{unit}]")
  322:         first[0] = first[0].dt.tz_localize("Europe/London")
  323: 
  324:         second = DataFrame([[datetime(2016, 1, 2)]], dtype=f"M8[{unit2}]")
  325:         second[0] = second[0].dt.tz_localize("Europe/London")
  326: 
  327:         result = concat([first, second])
  328:         exp_unit = tm.get_finest_unit(unit, unit2)
  329:         assert result[0].dtype == f"datetime64[{exp_unit}, Europe/London]"
  330: 
  331:     def test_concat_tz_series5(self, unit, unit2):
  332:         # Concatenating 2+1 London times
  333:         first = DataFrame(
  334:             [[datetime(2016, 1, 1)], [datetime(2016, 1, 2)]], dtype=f"M8[{unit}]"
  335:         )
  336:         first[0] = first[0].dt.tz_localize("Europe/London")
  337: 
  338:         second = DataFrame([[datetime(2016, 1, 3)]], dtype=f"M8[{unit2}]")
  339:         second[0] = second[0].dt.tz_localize("Europe/London")
  340: 
  341:         result = concat([first, second])
  342:         exp_unit = tm.get_finest_unit(unit, unit2)
  343:         assert result[0].dtype == f"datetime64[{exp_unit}, Europe/London]"
  344: 
  345:     def test_concat_tz_series6(self, unit, unit2):
  346:         # Concatenating 1+2 London times
  347:         first = DataFrame([[datetime(2016, 1, 1)]], dtype=f"M8[{unit}]")
  348:         first[0] = first[0].dt.tz_localize("Europe/London")
  349: 
  350:         second = DataFrame(
  351:             [[datetime(2016, 1, 2)], [datetime(2016, 1, 3)]], dtype=f"M8[{unit2}]"
  352:         )
  353:         second[0] = second[0].dt.tz_localize("Europe/London")
  354: 
  355:         result = concat([first, second])
  356:         exp_unit = tm.get_finest_unit(unit, unit2)
  357:         assert result[0].dtype == f"datetime64[{exp_unit}, Europe/London]"
  358: 
  359:     def test_concat_tz_series_tzlocal(self):
  360:         # see gh-13583
  361:         x = [
  362:             Timestamp("2011-01-01", tz=dateutil.tz.tzlocal()),
  363:             Timestamp("2011-02-01", tz=dateutil.tz.tzlocal()),
  364:         ]
  365:         y = [
  366:             Timestamp("2012-01-01", tz=dateutil.tz.tzlocal()),
  367:             Timestamp("2012-02-01", tz=dateutil.tz.tzlocal()),
  368:         ]
  369: 
  370:         result = concat([Series(x), Series(y)], ignore_index=True)
  371:         tm.assert_series_equal(result, Series(x + y))
  372:         assert result.dtype == "datetime64[ns, tzlocal()]"
  373: 
  374:     def test_concat_tz_series_with_datetimelike(self):
  375:         # see gh-12620: tz and timedelta
  376:         x = [
  377:             Timestamp("2011-01-01", tz="US/Eastern"),
  378:             Timestamp("2011-02-01", tz="US/Eastern"),
  379:         ]
  380:         y = [pd.Timedelta("1 day"), pd.Timedelta("2 day")]
  381:         result = concat([Series(x), Series(y)], ignore_index=True)
  382:         tm.assert_series_equal(result, Series(x + y, dtype="object"))
  383: 
  384:         # tz and period
  385:         y = [pd.Period("2011-03", freq="M"), pd.Period("2011-04", freq="M")]
  386:         result = concat([Series(x), Series(y)], ignore_index=True)
  387:         tm.assert_series_equal(result, Series(x + y, dtype="object"))
  388: 
  389:     def test_concat_tz_frame(self):
  390:         df2 = DataFrame(
  391:             {
  392:                 "A": Timestamp("20130102", tz="US/Eastern"),
  393:                 "B": Timestamp("20130603", tz="CET"),
  394:             },
  395:             index=range(5),
  396:         )
  397: 
  398:         # concat
  399:         df3 = concat([df2.A.to_frame(), df2.B.to_frame()], axis=1)
  400:         tm.assert_frame_equal(df2, df3)
  401: 
  402:     def test_concat_multiple_tzs(self):
  403:         # GH#12467
  404:         # combining datetime tz-aware and naive DataFrames
  405:         ts1 = Timestamp("2015-01-01", tz=None)
  406:         ts2 = Timestamp("2015-01-01", tz="UTC")
  407:         ts3 = Timestamp("2015-01-01", tz="EST")
  408: 
  409:         df1 = DataFrame({"time": [ts1]})
  410:         df2 = DataFrame({"time": [ts2]})
  411:         df3 = DataFrame({"time": [ts3]})
  412: 
  413:         results = concat([df1, df2]).reset_index(drop=True)
  414:         expected = DataFrame({"time": [ts1, ts2]}, dtype=object)
  415:         tm.assert_frame_equal(results, expected)
  416: 
  417:         results = concat([df1, df3]).reset_index(drop=True)
  418:         expected = DataFrame({"time": [ts1, ts3]}, dtype=object)
  419:         tm.assert_frame_equal(results, expected)
  420: 
  421:         results = concat([df2, df3]).reset_index(drop=True)
  422:         expected = DataFrame({"time": [ts2, ts3]})
  423:         tm.assert_frame_equal(results, expected)
  424: 
  425:     def test_concat_multiindex_with_tz(self):
  426:         # GH 6606
  427:         df = DataFrame(
  428:             {
  429:                 "dt": DatetimeIndex(
  430:                     [
  431:                         datetime(2014, 1, 1),
  432:                         datetime(2014, 1, 2),
  433:                         datetime(2014, 1, 3),
  434:                     ],
  435:                     dtype="M8[ns, US/Pacific]",
  436:                 ),
  437:                 "b": ["A", "B", "C"],
  438:                 "c": [1, 2, 3],
  439:                 "d": [4, 5, 6],
  440:             }
  441:         )
  442:         df = df.set_index(["dt", "b"])
  443: 
  444:         exp_idx1 = DatetimeIndex(
  445:             ["2014-01-01", "2014-01-02", "2014-01-03"] * 2,
  446:             dtype="M8[ns, US/Pacific]",
  447:             name="dt",
  448:         )
  449:         exp_idx2 = Index(["A", "B", "C"] * 2, name="b")
  450:         exp_idx = MultiIndex.from_arrays([exp_idx1, exp_idx2])
  451:         expected = DataFrame(
  452:             {"c": [1, 2, 3] * 2, "d": [4, 5, 6] * 2}, index=exp_idx, columns=["c", "d"]
  453:         )
  454: 
  455:         result = concat([df, df])
  456:         tm.assert_frame_equal(result, expected)
  457: 
  458:     def test_concat_tz_not_aligned(self):
  459:         # GH#22796
  460:         ts = pd.to_datetime([1, 2]).tz_localize("UTC")
  461:         a = DataFrame({"A": ts})
  462:         b = DataFrame({"A": ts, "B": ts})
  463:         result = concat([a, b], sort=True, ignore_index=True)
  464:         expected = DataFrame(
  465:             {"A": list(ts) + list(ts), "B": [pd.NaT, pd.NaT] + list(ts)}
  466:         )
  467:         tm.assert_frame_equal(result, expected)
  468: 
  469:     @pytest.mark.parametrize(
  470:         "t1",
  471:         [
  472:             "2015-01-01",
  473:             pytest.param(
  474:                 pd.NaT,
  475:                 marks=pytest.mark.xfail(
  476:                     reason="GH23037 incorrect dtype when concatenating"
  477:                 ),
  478:             ),
  479:         ],
  480:     )
  481:     def test_concat_tz_NaT(self, t1):
  482:         # GH#22796
  483:         # Concatenating tz-aware multicolumn DataFrames
  484:         ts1 = Timestamp(t1, tz="UTC")
  485:         ts2 = Timestamp("2015-01-01", tz="UTC")
  486:         ts3 = Timestamp("2015-01-01", tz="UTC")
  487: 
  488:         df1 = DataFrame([[ts1, ts2]])
  489:         df2 = DataFrame([[ts3]])
  490: 
  491:         result = concat([df1, df2])
  492:         expected = DataFrame([[ts1, ts2], [ts3, pd.NaT]], index=[0, 0])
  493: 
  494:         tm.assert_frame_equal(result, expected)
  495: 
  496:     def test_concat_tz_with_empty(self):
  497:         # GH 9188
  498:         result = concat(
  499:             [DataFrame(date_range("2000", periods=1, tz="UTC")), DataFrame()]
  500:         )
  501:         expected = DataFrame(date_range("2000", periods=1, tz="UTC"))
  502:         tm.assert_frame_equal(result, expected)
  503: 
  504: 
  505: class TestPeriodConcat:
  506:     def test_concat_period_series(self):
  507:         x = Series(pd.PeriodIndex(["2015-11-01", "2015-12-01"], freq="D"))
  508:         y = Series(pd.PeriodIndex(["2015-10-01", "2016-01-01"], freq="D"))
  509:         expected = Series([x[0], x[1], y[0], y[1]], dtype="Period[D]")
  510:         result = concat([x, y], ignore_index=True)
  511:         tm.assert_series_equal(result, expected)
  512: 
  513:     def test_concat_period_multiple_freq_series(self):
  514:         x = Series(pd.PeriodIndex(["2015-11-01", "2015-12-01"], freq="D"))
  515:         y = Series(pd.PeriodIndex(["2015-10-01", "2016-01-01"], freq="M"))
  516:         expected = Series([x[0], x[1], y[0], y[1]], dtype="object")
  517:         result = concat([x, y], ignore_index=True)
  518:         tm.assert_series_equal(result, expected)
  519:         assert result.dtype == "object"
  520: 
  521:     def test_concat_period_other_series(self):
  522:         x = Series(pd.PeriodIndex(["2015-11-01", "2015-12-01"], freq="D"))
  523:         y = Series(pd.PeriodIndex(["2015-11-01", "2015-12-01"], freq="M"))
  524:         expected = Series([x[0], x[1], y[0], y[1]], dtype="object")
  525:         result = concat([x, y], ignore_index=True)
  526:         tm.assert_series_equal(result, expected)
  527:         assert result.dtype == "object"
  528: 
  529:     def test_concat_period_other_series2(self):
  530:         # non-period
  531:         x = Series(pd.PeriodIndex(["2015-11-01", "2015-12-01"], freq="D"))
  532:         y = Series(DatetimeIndex(["2015-11-01", "2015-12-01"]))
  533:         expected = Series([x[0], x[1], y[0], y[1]], dtype="object")
  534:         result = concat([x, y], ignore_index=True)
  535:         tm.assert_series_equal(result, expected)
  536:         assert result.dtype == "object"
  537: 
  538:     def test_concat_period_other_series3(self):
  539:         x = Series(pd.PeriodIndex(["2015-11-01", "2015-12-01"], freq="D"))
  540:         y = Series(["A", "B"])
  541:         expected = Series([x[0], x[1], y[0], y[1]], dtype="object")
  542:         result = concat([x, y], ignore_index=True)
  543:         tm.assert_series_equal(result, expected)
  544:         assert result.dtype == "object"
  545: 
  546: 
  547: def test_concat_timedelta64_block():
  548:     rng = to_timedelta(np.arange(10), unit="s")
  549: 
  550:     df = DataFrame({"time": rng})
  551: 
  552:     result = concat([df, df])
  553:     tm.assert_frame_equal(result.iloc[:10], df)
  554:     tm.assert_frame_equal(result.iloc[10:], df)
  555: 
  556: 
  557: def test_concat_multiindex_datetime_nat():
  558:     # GH#44900
  559:     left = DataFrame({"a": 1}, index=MultiIndex.from_tuples([(1, pd.NaT)]))
  560:     right = DataFrame(
  561:         {"b": 2}, index=MultiIndex.from_tuples([(1, pd.NaT), (2, pd.NaT)])
  562:     )
  563:     result = concat([left, right], axis="columns")
  564:     expected = DataFrame(
  565:         {"a": [1.0, np.nan], "b": 2}, MultiIndex.from_tuples([(1, pd.NaT), (2, pd.NaT)])
  566:     )
  567:     tm.assert_frame_equal(result, expected)
  568: 
  569: 
  570: def test_concat_float_datetime64(using_array_manager):
  571:     # GH#32934
  572:     df_time = DataFrame({"A": pd.array(["2000"], dtype="datetime64[ns]")})
  573:     df_float = DataFrame({"A": pd.array([1.0], dtype="float64")})
  574: 
  575:     expected = DataFrame(
  576:         {
  577:             "A": [
  578:                 pd.array(["2000"], dtype="datetime64[ns]")[0],
  579:                 pd.array([1.0], dtype="float64")[0],
  580:             ]
  581:         },
  582:         index=[0, 0],
  583:     )
  584:     result = concat([df_time, df_float])
  585:     tm.assert_frame_equal(result, expected)
  586: 
  587:     expected = DataFrame({"A": pd.array([], dtype="object")})
  588:     result = concat([df_time.iloc[:0], df_float.iloc[:0]])
  589:     tm.assert_frame_equal(result, expected)
  590: 
  591:     expected = DataFrame({"A": pd.array([1.0], dtype="object")})
  592:     result = concat([df_time.iloc[:0], df_float])
  593:     tm.assert_frame_equal(result, expected)
  594: 
  595:     if not using_array_manager:
  596:         expected = DataFrame({"A": pd.array(["2000"], dtype="datetime64[ns]")})
  597:         msg = "The behavior of DataFrame concatenation with empty or all-NA entries"
  598:         with tm.assert_produces_warning(FutureWarning, match=msg):
  599:             result = concat([df_time, df_float.iloc[:0]])
  600:         tm.assert_frame_equal(result, expected)
  601:     else:
  602:         expected = DataFrame({"A": pd.array(["2000"], dtype="datetime64[ns]")}).astype(
  603:             {"A": "object"}
  604:         )
  605:         result = concat([df_time, df_float.iloc[:0]])
  606:         tm.assert_frame_equal(result, expected)
