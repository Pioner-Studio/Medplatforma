    1: from datetime import (
    2:     date,
    3:     datetime,
    4:     timedelta,
    5: )
    6: from itertools import product
    7: import re
    8: 
    9: import numpy as np
   10: import pytest
   11: 
   12: from pandas._config import using_pyarrow_string_dtype
   13: 
   14: from pandas.errors import PerformanceWarning
   15: 
   16: import pandas as pd
   17: from pandas import (
   18:     Categorical,
   19:     DataFrame,
   20:     Grouper,
   21:     Index,
   22:     MultiIndex,
   23:     Series,
   24:     concat,
   25:     date_range,
   26: )
   27: import pandas._testing as tm
   28: from pandas.api.types import CategoricalDtype
   29: from pandas.core.reshape import reshape as reshape_lib
   30: from pandas.core.reshape.pivot import pivot_table
   31: 
   32: 
   33: @pytest.fixture(params=[True, False])
   34: def dropna(request):
   35:     return request.param
   36: 
   37: 
   38: @pytest.fixture(params=[([0] * 4, [1] * 4), (range(3), range(1, 4))])
   39: def interval_values(request, closed):
   40:     left, right = request.param
   41:     return Categorical(pd.IntervalIndex.from_arrays(left, right, closed))
   42: 
   43: 
   44: class TestPivotTable:
   45:     @pytest.fixture
   46:     def data(self):
   47:         return DataFrame(
   48:             {
   49:                 "A": [
   50:                     "foo",
   51:                     "foo",
   52:                     "foo",
   53:                     "foo",
   54:                     "bar",
   55:                     "bar",
   56:                     "bar",
   57:                     "bar",
   58:                     "foo",
   59:                     "foo",
   60:                     "foo",
   61:                 ],
   62:                 "B": [
   63:                     "one",
   64:                     "one",
   65:                     "one",
   66:                     "two",
   67:                     "one",
   68:                     "one",
   69:                     "one",
   70:                     "two",
   71:                     "two",
   72:                     "two",
   73:                     "one",
   74:                 ],
   75:                 "C": [
   76:                     "dull",
   77:                     "dull",
   78:                     "shiny",
   79:                     "dull",
   80:                     "dull",
   81:                     "shiny",
   82:                     "shiny",
   83:                     "dull",
   84:                     "shiny",
   85:                     "shiny",
   86:                     "shiny",
   87:                 ],
   88:                 "D": np.random.default_rng(2).standard_normal(11),
   89:                 "E": np.random.default_rng(2).standard_normal(11),
   90:                 "F": np.random.default_rng(2).standard_normal(11),
   91:             }
   92:         )
   93: 
   94:     def test_pivot_table(self, observed, data):
   95:         index = ["A", "B"]
   96:         columns = "C"
   97:         table = pivot_table(
   98:             data, values="D", index=index, columns=columns, observed=observed
   99:         )
  100: 
  101:         table2 = data.pivot_table(
  102:             values="D", index=index, columns=columns, observed=observed
  103:         )
  104:         tm.assert_frame_equal(table, table2)
  105: 
  106:         # this works
  107:         pivot_table(data, values="D", index=index, observed=observed)
  108: 
  109:         if len(index) > 1:
  110:             assert table.index.names == tuple(index)
  111:         else:
  112:             assert table.index.name == index[0]
  113: 
  114:         if len(columns) > 1:
  115:             assert table.columns.names == columns
  116:         else:
  117:             assert table.columns.name == columns[0]
  118: 
  119:         expected = data.groupby(index + [columns])["D"].agg("mean").unstack()
  120:         tm.assert_frame_equal(table, expected)
  121: 
  122:     def test_pivot_table_categorical_observed_equal(self, observed):
  123:         # issue #24923
  124:         df = DataFrame(
  125:             {"col1": list("abcde"), "col2": list("fghij"), "col3": [1, 2, 3, 4, 5]}
  126:         )
  127: 
  128:         expected = df.pivot_table(
  129:             index="col1", values="col3", columns="col2", aggfunc="sum", fill_value=0
  130:         )
  131: 
  132:         expected.index = expected.index.astype("category")
  133:         expected.columns = expected.columns.astype("category")
  134: 
  135:         df.col1 = df.col1.astype("category")
  136:         df.col2 = df.col2.astype("category")
  137: 
  138:         result = df.pivot_table(
  139:             index="col1",
  140:             values="col3",
  141:             columns="col2",
  142:             aggfunc="sum",
  143:             fill_value=0,
  144:             observed=observed,
  145:         )
  146: 
  147:         tm.assert_frame_equal(result, expected)
  148: 
  149:     def test_pivot_table_nocols(self):
  150:         df = DataFrame(
  151:             {"rows": ["a", "b", "c"], "cols": ["x", "y", "z"], "values": [1, 2, 3]}
  152:         )
  153:         rs = df.pivot_table(columns="cols", aggfunc="sum")
  154:         xp = df.pivot_table(index="cols", aggfunc="sum").T
  155:         tm.assert_frame_equal(rs, xp)
  156: 
  157:         rs = df.pivot_table(columns="cols", aggfunc={"values": "mean"})
  158:         xp = df.pivot_table(index="cols", aggfunc={"values": "mean"}).T
  159:         tm.assert_frame_equal(rs, xp)
  160: 
  161:     def test_pivot_table_dropna(self):
  162:         df = DataFrame(
  163:             {
  164:                 "amount": {0: 60000, 1: 100000, 2: 50000, 3: 30000},
  165:                 "customer": {0: "A", 1: "A", 2: "B", 3: "C"},
  166:                 "month": {0: 201307, 1: 201309, 2: 201308, 3: 201310},
  167:                 "product": {0: "a", 1: "b", 2: "c", 3: "d"},
  168:                 "quantity": {0: 2000000, 1: 500000, 2: 1000000, 3: 1000000},
  169:             }
  170:         )
  171:         pv_col = df.pivot_table(
  172:             "quantity", "month", ["customer", "product"], dropna=False
  173:         )
  174:         pv_ind = df.pivot_table(
  175:             "quantity", ["customer", "product"], "month", dropna=False
  176:         )
  177: 
  178:         m = MultiIndex.from_tuples(
  179:             [
  180:                 ("A", "a"),
  181:                 ("A", "b"),
  182:                 ("A", "c"),
  183:                 ("A", "d"),
  184:                 ("B", "a"),
  185:                 ("B", "b"),
  186:                 ("B", "c"),
  187:                 ("B", "d"),
  188:                 ("C", "a"),
  189:                 ("C", "b"),
  190:                 ("C", "c"),
  191:                 ("C", "d"),
  192:             ],
  193:             names=["customer", "product"],
  194:         )
  195:         tm.assert_index_equal(pv_col.columns, m)
  196:         tm.assert_index_equal(pv_ind.index, m)
  197: 
  198:     def test_pivot_table_categorical(self):
  199:         cat1 = Categorical(
  200:             ["a", "a", "b", "b"], categories=["a", "b", "z"], ordered=True
  201:         )
  202:         cat2 = Categorical(
  203:             ["c", "d", "c", "d"], categories=["c", "d", "y"], ordered=True
  204:         )
  205:         df = DataFrame({"A": cat1, "B": cat2, "values": [1, 2, 3, 4]})
  206:         msg = "The default value of observed=False is deprecated"
  207:         with tm.assert_produces_warning(FutureWarning, match=msg):
  208:             result = pivot_table(df, values="values", index=["A", "B"], dropna=True)
  209: 
  210:         exp_index = MultiIndex.from_arrays([cat1, cat2], names=["A", "B"])
  211:         expected = DataFrame({"values": [1.0, 2.0, 3.0, 4.0]}, index=exp_index)
  212:         tm.assert_frame_equal(result, expected)
  213: 
  214:     def test_pivot_table_dropna_categoricals(self, dropna):
  215:         # GH 15193
  216:         categories = ["a", "b", "c", "d"]
  217: 
  218:         df = DataFrame(
  219:             {
  220:                 "A": ["a", "a", "a", "b", "b", "b", "c", "c", "c"],
  221:                 "B": [1, 2, 3, 1, 2, 3, 1, 2, 3],
  222:                 "C": range(9),
  223:             }
  224:         )
  225: 
  226:         df["A"] = df["A"].astype(CategoricalDtype(categories, ordered=False))
  227:         msg = "The default value of observed=False is deprecated"
  228:         with tm.assert_produces_warning(FutureWarning, match=msg):
  229:             result = df.pivot_table(index="B", columns="A", values="C", dropna=dropna)
  230:         expected_columns = Series(["a", "b", "c"], name="A")
  231:         expected_columns = expected_columns.astype(
  232:             CategoricalDtype(categories, ordered=False)
  233:         )
  234:         expected_index = Series([1, 2, 3], name="B")
  235:         expected = DataFrame(
  236:             [[0.0, 3.0, 6.0], [1.0, 4.0, 7.0], [2.0, 5.0, 8.0]],
  237:             index=expected_index,
  238:             columns=expected_columns,
  239:         )
  240:         if not dropna:
  241:             # add back the non observed to compare
  242:             expected = expected.reindex(columns=Categorical(categories)).astype("float")
  243: 
  244:         tm.assert_frame_equal(result, expected)
  245: 
  246:     def test_pivot_with_non_observable_dropna(self, dropna):
  247:         # gh-21133
  248:         df = DataFrame(
  249:             {
  250:                 "A": Categorical(
  251:                     [np.nan, "low", "high", "low", "high"],
  252:                     categories=["low", "high"],
  253:                     ordered=True,
  254:                 ),
  255:                 "B": [0.0, 1.0, 2.0, 3.0, 4.0],
  256:             }
  257:         )
  258: 
  259:         msg = "The default value of observed=False is deprecated"
  260:         with tm.assert_produces_warning(FutureWarning, match=msg):
  261:             result = df.pivot_table(index="A", values="B", dropna=dropna)
  262:         if dropna:
  263:             values = [2.0, 3.0]
  264:             codes = [0, 1]
  265:         else:
  266:             # GH: 10772
  267:             values = [2.0, 3.0, 0.0]
  268:             codes = [0, 1, -1]
  269:         expected = DataFrame(
  270:             {"B": values},
  271:             index=Index(
  272:                 Categorical.from_codes(
  273:                     codes, categories=["low", "high"], ordered=dropna
  274:                 ),
  275:                 name="A",
  276:             ),
  277:         )
  278: 
  279:         tm.assert_frame_equal(result, expected)
  280: 
  281:     def test_pivot_with_non_observable_dropna_multi_cat(self, dropna):
  282:         # gh-21378
  283:         df = DataFrame(
  284:             {
  285:                 "A": Categorical(
  286:                     ["left", "low", "high", "low", "high"],
  287:                     categories=["low", "high", "left"],
  288:                     ordered=True,
  289:                 ),
  290:                 "B": range(5),
  291:             }
  292:         )
  293: 
  294:         msg = "The default value of observed=False is deprecated"
  295:         with tm.assert_produces_warning(FutureWarning, match=msg):
  296:             result = df.pivot_table(index="A", values="B", dropna=dropna)
  297:         expected = DataFrame(
  298:             {"B": [2.0, 3.0, 0.0]},
  299:             index=Index(
  300:                 Categorical.from_codes(
  301:                     [0, 1, 2], categories=["low", "high", "left"], ordered=True
  302:                 ),
  303:                 name="A",
  304:             ),
  305:         )
  306:         if not dropna:
  307:             expected["B"] = expected["B"].astype(float)
  308: 
  309:         tm.assert_frame_equal(result, expected)
  310: 
  311:     def test_pivot_with_interval_index(self, interval_values, dropna):
  312:         # GH 25814
  313:         df = DataFrame({"A": interval_values, "B": 1})
  314: 
  315:         msg = "The default value of observed=False is deprecated"
  316:         with tm.assert_produces_warning(FutureWarning, match=msg):
  317:             result = df.pivot_table(index="A", values="B", dropna=dropna)
  318:         expected = DataFrame(
  319:             {"B": 1.0}, index=Index(interval_values.unique(), name="A")
  320:         )
  321:         if not dropna:
  322:             expected = expected.astype(float)
  323:         tm.assert_frame_equal(result, expected)
  324: 
  325:     def test_pivot_with_interval_index_margins(self):
  326:         # GH 25815
  327:         ordered_cat = pd.IntervalIndex.from_arrays([0, 0, 1, 1], [1, 1, 2, 2])
  328:         df = DataFrame(
  329:             {
  330:                 "A": np.arange(4, 0, -1, dtype=np.intp),
  331:                 "B": ["a", "b", "a", "b"],
  332:                 "C": Categorical(ordered_cat, ordered=True).sort_values(
  333:                     ascending=False
  334:                 ),
  335:             }
  336:         )
  337: 
  338:         msg = "The default value of observed=False is deprecated"
  339:         with tm.assert_produces_warning(FutureWarning, match=msg):
  340:             pivot_tab = pivot_table(
  341:                 df, index="C", columns="B", values="A", aggfunc="sum", margins=True
  342:             )
  343: 
  344:         result = pivot_tab["All"]
  345:         expected = Series(
  346:             [3, 7, 10],
  347:             index=Index([pd.Interval(0, 1), pd.Interval(1, 2), "All"], name="C"),
  348:             name="All",
  349:             dtype=np.intp,
  350:         )
  351:         tm.assert_series_equal(result, expected)
  352: 
  353:     def test_pass_array(self, data):
  354:         result = data.pivot_table("D", index=data.A, columns=data.C)
  355:         expected = data.pivot_table("D", index="A", columns="C")
  356:         tm.assert_frame_equal(result, expected)
  357: 
  358:     def test_pass_function(self, data):
  359:         result = data.pivot_table("D", index=lambda x: x // 5, columns=data.C)
  360:         expected = data.pivot_table("D", index=data.index // 5, columns="C")
  361:         tm.assert_frame_equal(result, expected)
  362: 
  363:     def test_pivot_table_multiple(self, data):
  364:         index = ["A", "B"]
  365:         columns = "C"
  366:         table = pivot_table(data, index=index, columns=columns)
  367:         expected = data.groupby(index + [columns]).agg("mean").unstack()
  368:         tm.assert_frame_equal(table, expected)
  369: 
  370:     def test_pivot_dtypes(self):
  371:         # can convert dtypes
  372:         f = DataFrame(
  373:             {
  374:                 "a": ["cat", "bat", "cat", "bat"],
  375:                 "v": [1, 2, 3, 4],
  376:                 "i": ["a", "b", "a", "b"],
  377:             }
  378:         )
  379:         assert f.dtypes["v"] == "int64"
  380: 
  381:         z = pivot_table(
  382:             f, values="v", index=["a"], columns=["i"], fill_value=0, aggfunc="sum"
  383:         )
  384:         result = z.dtypes
  385:         expected = Series([np.dtype("int64")] * 2, index=Index(list("ab"), name="i"))
  386:         tm.assert_series_equal(result, expected)
  387: 
  388:         # cannot convert dtypes
  389:         f = DataFrame(
  390:             {
  391:                 "a": ["cat", "bat", "cat", "bat"],
  392:                 "v": [1.5, 2.5, 3.5, 4.5],
  393:                 "i": ["a", "b", "a", "b"],
  394:             }
  395:         )
  396:         assert f.dtypes["v"] == "float64"
  397: 
  398:         z = pivot_table(
  399:             f, values="v", index=["a"], columns=["i"], fill_value=0, aggfunc="mean"
  400:         )
  401:         result = z.dtypes
  402:         expected = Series([np.dtype("float64")] * 2, index=Index(list("ab"), name="i"))
  403:         tm.assert_series_equal(result, expected)
  404: 
  405:     @pytest.mark.parametrize(
  406:         "columns,values",
  407:         [
  408:             ("bool1", ["float1", "float2"]),
  409:             ("bool1", ["float1", "float2", "bool1"]),
  410:             ("bool2", ["float1", "float2", "bool1"]),
  411:         ],
  412:     )
  413:     def test_pivot_preserve_dtypes(self, columns, values):
  414:         # GH 7142 regression test
  415:         v = np.arange(5, dtype=np.float64)
  416:         df = DataFrame(
  417:             {"float1": v, "float2": v + 2.0, "bool1": v <= 2, "bool2": v <= 3}
  418:         )
  419: 
  420:         df_res = df.reset_index().pivot_table(
  421:             index="index", columns=columns, values=values
  422:         )
  423: 
  424:         result = dict(df_res.dtypes)
  425:         expected = {col: np.dtype("float64") for col in df_res}
  426:         assert result == expected
  427: 
  428:     def test_pivot_no_values(self):
  429:         # GH 14380
  430:         idx = pd.DatetimeIndex(
  431:             ["2011-01-01", "2011-02-01", "2011-01-02", "2011-01-01", "2011-01-02"]
  432:         )
  433:         df = DataFrame({"A": [1, 2, 3, 4, 5]}, index=idx)
  434:         res = df.pivot_table(index=df.index.month, columns=df.index.day)
  435: 
  436:         exp_columns = MultiIndex.from_tuples([("A", 1), ("A", 2)])
  437:         exp_columns = exp_columns.set_levels(
  438:             exp_columns.levels[1].astype(np.int32), level=1
  439:         )
  440:         exp = DataFrame(
  441:             [[2.5, 4.0], [2.0, np.nan]],
  442:             index=Index([1, 2], dtype=np.int32),
  443:             columns=exp_columns,
  444:         )
  445:         tm.assert_frame_equal(res, exp)
  446: 
  447:         df = DataFrame(
  448:             {
  449:                 "A": [1, 2, 3, 4, 5],
  450:                 "dt": date_range("2011-01-01", freq="D", periods=5),
  451:             },
  452:             index=idx,
  453:         )
  454:         res = df.pivot_table(index=df.index.month, columns=Grouper(key="dt", freq="ME"))
  455:         exp_columns = MultiIndex.from_arrays(
  456:             [["A"], pd.DatetimeIndex(["2011-01-31"], dtype="M8[ns]")],
  457:             names=[None, "dt"],
  458:         )
  459:         exp = DataFrame(
  460:             [3.25, 2.0], index=Index([1, 2], dtype=np.int32), columns=exp_columns
  461:         )
  462:         tm.assert_frame_equal(res, exp)
  463: 
  464:         res = df.pivot_table(
  465:             index=Grouper(freq="YE"), columns=Grouper(key="dt", freq="ME")
  466:         )
  467:         exp = DataFrame(
  468:             [3.0],
  469:             index=pd.DatetimeIndex(["2011-12-31"], freq="YE"),
  470:             columns=exp_columns,
  471:         )
  472:         tm.assert_frame_equal(res, exp)
  473: 
  474:     def test_pivot_multi_values(self, data):
  475:         result = pivot_table(
  476:             data, values=["D", "E"], index="A", columns=["B", "C"], fill_value=0
  477:         )
  478:         expected = pivot_table(
  479:             data.drop(["F"], axis=1), index="A", columns=["B", "C"], fill_value=0
  480:         )
  481:         tm.assert_frame_equal(result, expected)
  482: 
  483:     def test_pivot_multi_functions(self, data):
  484:         f = lambda func: pivot_table(
  485:             data, values=["D", "E"], index=["A", "B"], columns="C", aggfunc=func
  486:         )
  487:         result = f(["mean", "std"])
  488:         means = f("mean")
  489:         stds = f("std")
  490:         expected = concat([means, stds], keys=["mean", "std"], axis=1)
  491:         tm.assert_frame_equal(result, expected)
  492: 
  493:         # margins not supported??
  494:         f = lambda func: pivot_table(
  495:             data,
  496:             values=["D", "E"],
  497:             index=["A", "B"],
  498:             columns="C",
  499:             aggfunc=func,
  500:             margins=True,
  501:         )
  502:         result = f(["mean", "std"])
  503:         means = f("mean")
  504:         stds = f("std")
  505:         expected = concat([means, stds], keys=["mean", "std"], axis=1)
  506:         tm.assert_frame_equal(result, expected)
  507: 
  508:     @pytest.mark.parametrize("method", [True, False])
  509:     def test_pivot_index_with_nan(self, method):
  510:         # GH 3588
  511:         nan = np.nan
  512:         df = DataFrame(
  513:             {
  514:                 "a": ["R1", "R2", nan, "R4"],
  515:                 "b": ["C1", "C2", "C3", "C4"],
  516:                 "c": [10, 15, 17, 20],
  517:             }
  518:         )
  519:         if method:
  520:             result = df.pivot(index="a", columns="b", values="c")
  521:         else:
  522:             result = pd.pivot(df, index="a", columns="b", values="c")
  523:         expected = DataFrame(
  524:             [
  525:                 [nan, nan, 17, nan],
  526:                 [10, nan, nan, nan],
  527:                 [nan, 15, nan, nan],
  528:                 [nan, nan, nan, 20],
  529:             ],
  530:             index=Index([nan, "R1", "R2", "R4"], name="a"),
  531:             columns=Index(["C1", "C2", "C3", "C4"], name="b"),
  532:         )
  533:         tm.assert_frame_equal(result, expected)
  534:         tm.assert_frame_equal(df.pivot(index="b", columns="a", values="c"), expected.T)
  535: 
  536:     @pytest.mark.parametrize("method", [True, False])
  537:     def test_pivot_index_with_nan_dates(self, method):
  538:         # GH9491
  539:         df = DataFrame(
  540:             {
  541:                 "a": date_range("2014-02-01", periods=6, freq="D"),
  542:                 "c": 100 + np.arange(6),
  543:             }
  544:         )
  545:         df["b"] = df["a"] - pd.Timestamp("2014-02-02")
  546:         df.loc[1, "a"] = df.loc[3, "a"] = np.nan
  547:         df.loc[1, "b"] = df.loc[4, "b"] = np.nan
  548: 
  549:         if method:
  550:             pv = df.pivot(index="a", columns="b", values="c")
  551:         else:
  552:             pv = pd.pivot(df, index="a", columns="b", values="c")
  553:         assert pv.notna().values.sum() == len(df)
  554: 
  555:         for _, row in df.iterrows():
  556:             assert pv.loc[row["a"], row["b"]] == row["c"]
  557: 
  558:         if method:
  559:             result = df.pivot(index="b", columns="a", values="c")
  560:         else:
  561:             result = pd.pivot(df, index="b", columns="a", values="c")
  562:         tm.assert_frame_equal(result, pv.T)
  563: 
  564:     @pytest.mark.parametrize("method", [True, False])
  565:     def test_pivot_with_tz(self, method, unit):
  566:         # GH 5878
  567:         df = DataFrame(
  568:             {
  569:                 "dt1": pd.DatetimeIndex(
  570:                     [
  571:                         datetime(2013, 1, 1, 9, 0),
  572:                         datetime(2013, 1, 2, 9, 0),
  573:                         datetime(2013, 1, 1, 9, 0),
  574:                         datetime(2013, 1, 2, 9, 0),
  575:                     ],
  576:                     dtype=f"M8[{unit}, US/Pacific]",
  577:                 ),
  578:                 "dt2": pd.DatetimeIndex(
  579:                     [
  580:                         datetime(2014, 1, 1, 9, 0),
  581:                         datetime(2014, 1, 1, 9, 0),
  582:                         datetime(2014, 1, 2, 9, 0),
  583:                         datetime(2014, 1, 2, 9, 0),
  584:                     ],
  585:                     dtype=f"M8[{unit}, Asia/Tokyo]",
  586:                 ),
  587:                 "data1": np.arange(4, dtype="int64"),
  588:                 "data2": np.arange(4, dtype="int64"),
  589:             }
  590:         )
  591: 
  592:         exp_col1 = Index(["data1", "data1", "data2", "data2"])
  593:         exp_col2 = pd.DatetimeIndex(
  594:             ["2014/01/01 09:00", "2014/01/02 09:00"] * 2,
  595:             name="dt2",
  596:             dtype=f"M8[{unit}, Asia/Tokyo]",
  597:         )
  598:         exp_col = MultiIndex.from_arrays([exp_col1, exp_col2])
  599:         exp_idx = pd.DatetimeIndex(
  600:             ["2013/01/01 09:00", "2013/01/02 09:00"],
  601:             name="dt1",
  602:             dtype=f"M8[{unit}, US/Pacific]",
  603:         )
  604:         expected = DataFrame(
  605:             [[0, 2, 0, 2], [1, 3, 1, 3]],
  606:             index=exp_idx,
  607:             columns=exp_col,
  608:         )
  609: 
  610:         if method:
  611:             pv = df.pivot(index="dt1", columns="dt2")
  612:         else:
  613:             pv = pd.pivot(df, index="dt1", columns="dt2")
  614:         tm.assert_frame_equal(pv, expected)
  615: 
  616:         expected = DataFrame(
  617:             [[0, 2], [1, 3]],
  618:             index=exp_idx,
  619:             columns=exp_col2[:2],
  620:         )
  621: 
  622:         if method:
  623:             pv = df.pivot(index="dt1", columns="dt2", values="data1")
  624:         else:
  625:             pv = pd.pivot(df, index="dt1", columns="dt2", values="data1")
  626:         tm.assert_frame_equal(pv, expected)
  627: 
  628:     def test_pivot_tz_in_values(self):
  629:         # GH 14948
  630:         df = DataFrame(
  631:             [
  632:                 {
  633:                     "uid": "aa",
  634:                     "ts": pd.Timestamp("2016-08-12 13:00:00-0700", tz="US/Pacific"),
  635:                 },
  636:                 {
  637:                     "uid": "aa",
  638:                     "ts": pd.Timestamp("2016-08-12 08:00:00-0700", tz="US/Pacific"),
  639:                 },
  640:                 {
  641:                     "uid": "aa",
  642:                     "ts": pd.Timestamp("2016-08-12 14:00:00-0700", tz="US/Pacific"),
  643:                 },
  644:                 {
  645:                     "uid": "aa",
  646:                     "ts": pd.Timestamp("2016-08-25 11:00:00-0700", tz="US/Pacific"),
  647:                 },
  648:                 {
  649:                     "uid": "aa",
  650:                     "ts": pd.Timestamp("2016-08-25 13:00:00-0700", tz="US/Pacific"),
  651:                 },
  652:             ]
  653:         )
  654: 
  655:         df = df.set_index("ts").reset_index()
  656:         mins = df.ts.map(lambda x: x.replace(hour=0, minute=0, second=0, microsecond=0))
  657: 
  658:         result = pivot_table(
  659:             df.set_index("ts").reset_index(),
  660:             values="ts",
  661:             index=["uid"],
  662:             columns=[mins],
  663:             aggfunc="min",
  664:         )
  665:         expected = DataFrame(
  666:             [
  667:                 [
  668:                     pd.Timestamp("2016-08-12 08:00:00-0700", tz="US/Pacific"),
  669:                     pd.Timestamp("2016-08-25 11:00:00-0700", tz="US/Pacific"),
  670:                 ]
  671:             ],
  672:             index=Index(["aa"], name="uid"),
  673:             columns=pd.DatetimeIndex(
  674:                 [
  675:                     pd.Timestamp("2016-08-12 00:00:00", tz="US/Pacific"),
  676:                     pd.Timestamp("2016-08-25 00:00:00", tz="US/Pacific"),
  677:                 ],
  678:                 name="ts",
  679:             ),
  680:         )
  681:         tm.assert_frame_equal(result, expected)
  682: 
  683:     @pytest.mark.parametrize("method", [True, False])
  684:     def test_pivot_periods(self, method):
  685:         df = DataFrame(
  686:             {
  687:                 "p1": [
  688:                     pd.Period("2013-01-01", "D"),
  689:                     pd.Period("2013-01-02", "D"),
  690:                     pd.Period("2013-01-01", "D"),
  691:                     pd.Period("2013-01-02", "D"),
  692:                 ],
  693:                 "p2": [
  694:                     pd.Period("2013-01", "M"),
  695:                     pd.Period("2013-01", "M"),
  696:                     pd.Period("2013-02", "M"),
  697:                     pd.Period("2013-02", "M"),
  698:                 ],
  699:                 "data1": np.arange(4, dtype="int64"),
  700:                 "data2": np.arange(4, dtype="int64"),
  701:             }
  702:         )
  703: 
  704:         exp_col1 = Index(["data1", "data1", "data2", "data2"])
  705:         exp_col2 = pd.PeriodIndex(["2013-01", "2013-02"] * 2, name="p2", freq="M")
  706:         exp_col = MultiIndex.from_arrays([exp_col1, exp_col2])
  707:         expected = DataFrame(
  708:             [[0, 2, 0, 2], [1, 3, 1, 3]],
  709:             index=pd.PeriodIndex(["2013-01-01", "2013-01-02"], name="p1", freq="D"),
  710:             columns=exp_col,
  711:         )
  712:         if method:
  713:             pv = df.pivot(index="p1", columns="p2")
  714:         else:
  715:             pv = pd.pivot(df, index="p1", columns="p2")
  716:         tm.assert_frame_equal(pv, expected)
  717: 
  718:         expected = DataFrame(
  719:             [[0, 2], [1, 3]],
  720:             index=pd.PeriodIndex(["2013-01-01", "2013-01-02"], name="p1", freq="D"),
  721:             columns=pd.PeriodIndex(["2013-01", "2013-02"], name="p2", freq="M"),
  722:         )
  723:         if method:
  724:             pv = df.pivot(index="p1", columns="p2", values="data1")
  725:         else:
  726:             pv = pd.pivot(df, index="p1", columns="p2", values="data1")
  727:         tm.assert_frame_equal(pv, expected)
  728: 
  729:     def test_pivot_periods_with_margins(self):
  730:         # GH 28323
  731:         df = DataFrame(
  732:             {
  733:                 "a": [1, 1, 2, 2],
  734:                 "b": [
  735:                     pd.Period("2019Q1"),
  736:                     pd.Period("2019Q2"),
  737:                     pd.Period("2019Q1"),
  738:                     pd.Period("2019Q2"),
  739:                 ],
  740:                 "x": 1.0,
  741:             }
  742:         )
  743: 
  744:         expected = DataFrame(
  745:             data=1.0,
  746:             index=Index([1, 2, "All"], name="a"),
  747:             columns=Index([pd.Period("2019Q1"), pd.Period("2019Q2"), "All"], name="b"),
  748:         )
  749: 
  750:         result = df.pivot_table(index="a", columns="b", values="x", margins=True)
  751:         tm.assert_frame_equal(expected, result)
  752: 
  753:     @pytest.mark.parametrize(
  754:         "values",
  755:         [
  756:             ["baz", "zoo"],
  757:             np.array(["baz", "zoo"]),
  758:             Series(["baz", "zoo"]),
  759:             Index(["baz", "zoo"]),
  760:         ],
  761:     )
  762:     @pytest.mark.parametrize("method", [True, False])
  763:     def test_pivot_with_list_like_values(self, values, method):
  764:         # issue #17160
  765:         df = DataFrame(
  766:             {
  767:                 "foo": ["one", "one", "one", "two", "two", "two"],
  768:                 "bar": ["A", "B", "C", "A", "B", "C"],
  769:                 "baz": [1, 2, 3, 4, 5, 6],
  770:                 "zoo": ["x", "y", "z", "q", "w", "t"],
  771:             }
  772:         )
  773: 
  774:         if method:
  775:             result = df.pivot(index="foo", columns="bar", values=values)
  776:         else:
  777:             result = pd.pivot(df, index="foo", columns="bar", values=values)
  778: 
  779:         data = [[1, 2, 3, "x", "y", "z"], [4, 5, 6, "q", "w", "t"]]
  780:         index = Index(data=["one", "two"], name="foo")
  781:         columns = MultiIndex(
  782:             levels=[["baz", "zoo"], ["A", "B", "C"]],
  783:             codes=[[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]],
  784:             names=[None, "bar"],
  785:         )
  786:         expected = DataFrame(data=data, index=index, columns=columns)
  787:         expected["baz"] = expected["baz"].astype(object)
  788:         tm.assert_frame_equal(result, expected)
  789: 
  790:     @pytest.mark.parametrize(
  791:         "values",
  792:         [
  793:             ["bar", "baz"],
  794:             np.array(["bar", "baz"]),
  795:             Series(["bar", "baz"]),
  796:             Index(["bar", "baz"]),
  797:         ],
  798:     )
  799:     @pytest.mark.parametrize("method", [True, False])
  800:     def test_pivot_with_list_like_values_nans(self, values, method):
  801:         # issue #17160
  802:         df = DataFrame(
  803:             {
  804:                 "foo": ["one", "one", "one", "two", "two", "two"],
  805:                 "bar": ["A", "B", "C", "A", "B", "C"],
  806:                 "baz": [1, 2, 3, 4, 5, 6],
  807:                 "zoo": ["x", "y", "z", "q", "w", "t"],
  808:             }
  809:         )
  810: 
  811:         if method:
  812:             result = df.pivot(index="zoo", columns="foo", values=values)
  813:         else:
  814:             result = pd.pivot(df, index="zoo", columns="foo", values=values)
  815: 
  816:         data = [
  817:             [np.nan, "A", np.nan, 4],
  818:             [np.nan, "C", np.nan, 6],
  819:             [np.nan, "B", np.nan, 5],
  820:             ["A", np.nan, 1, np.nan],
  821:             ["B", np.nan, 2, np.nan],
  822:             ["C", np.nan, 3, np.nan],
  823:         ]
  824:         index = Index(data=["q", "t", "w", "x", "y", "z"], name="zoo")
  825:         columns = MultiIndex(
  826:             levels=[["bar", "baz"], ["one", "two"]],
  827:             codes=[[0, 0, 1, 1], [0, 1, 0, 1]],
  828:             names=[None, "foo"],
  829:         )
  830:         expected = DataFrame(data=data, index=index, columns=columns)
  831:         expected["baz"] = expected["baz"].astype(object)
  832:         tm.assert_frame_equal(result, expected)
  833: 
  834:     def test_pivot_columns_none_raise_error(self):
  835:         # GH 30924
  836:         df = DataFrame({"col1": ["a", "b", "c"], "col2": [1, 2, 3], "col3": [1, 2, 3]})
  837:         msg = r"pivot\(\) missing 1 required keyword-only argument: 'columns'"
  838:         with pytest.raises(TypeError, match=msg):
  839:             df.pivot(index="col1", values="col3")  # pylint: disable=missing-kwoa
  840: 
  841:     @pytest.mark.xfail(
  842:         reason="MultiIndexed unstack with tuple names fails with KeyError GH#19966"
  843:     )
  844:     @pytest.mark.parametrize("method", [True, False])
  845:     def test_pivot_with_multiindex(self, method):
  846:         # issue #17160
  847:         index = Index(data=[0, 1, 2, 3, 4, 5])
  848:         data = [
  849:             ["one", "A", 1, "x"],
  850:             ["one", "B", 2, "y"],
  851:             ["one", "C", 3, "z"],
  852:             ["two", "A", 4, "q"],
  853:             ["two", "B", 5, "w"],
  854:             ["two", "C", 6, "t"],
  855:         ]
  856:         columns = MultiIndex(
  857:             levels=[["bar", "baz"], ["first", "second"]],
  858:             codes=[[0, 0, 1, 1], [0, 1, 0, 1]],
  859:         )
  860:         df = DataFrame(data=data, index=index, columns=columns, dtype="object")
  861:         if method:
  862:             result = df.pivot(
  863:                 index=("bar", "first"),
  864:                 columns=("bar", "second"),
  865:                 values=("baz", "first"),
  866:             )
  867:         else:
  868:             result = pd.pivot(
  869:                 df,
  870:                 index=("bar", "first"),
  871:                 columns=("bar", "second"),
  872:                 values=("baz", "first"),
  873:             )
  874: 
  875:         data = {
  876:             "A": Series([1, 4], index=["one", "two"]),
  877:             "B": Series([2, 5], index=["one", "two"]),
  878:             "C": Series([3, 6], index=["one", "two"]),
  879:         }
  880:         expected = DataFrame(data)
  881:         tm.assert_frame_equal(result, expected)
  882: 
  883:     @pytest.mark.parametrize("method", [True, False])
  884:     def test_pivot_with_tuple_of_values(self, method):
  885:         # issue #17160
  886:         df = DataFrame(
  887:             {
  888:                 "foo": ["one", "one", "one", "two", "two", "two"],
  889:                 "bar": ["A", "B", "C", "A", "B", "C"],
  890:                 "baz": [1, 2, 3, 4, 5, 6],
  891:                 "zoo": ["x", "y", "z", "q", "w", "t"],
  892:             }
  893:         )
  894:         with pytest.raises(KeyError, match=r"^\('bar', 'baz'\)$"):
  895:             # tuple is seen as a single column name
  896:             if method:
  897:                 df.pivot(index="zoo", columns="foo", values=("bar", "baz"))
  898:             else:
  899:                 pd.pivot(df, index="zoo", columns="foo", values=("bar", "baz"))
  900: 
  901:     def _check_output(
  902:         self,
  903:         result,
  904:         values_col,
  905:         data,
  906:         index=["A", "B"],
  907:         columns=["C"],
  908:         margins_col="All",
  909:     ):
  910:         col_margins = result.loc[result.index[:-1], margins_col]
  911:         expected_col_margins = data.groupby(index)[values_col].mean()
  912:         tm.assert_series_equal(col_margins, expected_col_margins, check_names=False)
  913:         assert col_margins.name == margins_col
  914: 
  915:         result = result.sort_index()
  916:         index_margins = result.loc[(margins_col, "")].iloc[:-1]
  917: 
  918:         expected_ix_margins = data.groupby(columns)[values_col].mean()
  919:         tm.assert_series_equal(index_margins, expected_ix_margins, check_names=False)
  920:         assert index_margins.name == (margins_col, "")
  921: 
  922:         grand_total_margins = result.loc[(margins_col, ""), margins_col]
  923:         expected_total_margins = data[values_col].mean()
  924:         assert grand_total_margins == expected_total_margins
  925: 
  926:     def test_margins(self, data):
  927:         # column specified
  928:         result = data.pivot_table(
  929:             values="D", index=["A", "B"], columns="C", margins=True, aggfunc="mean"
  930:         )
  931:         self._check_output(result, "D", data)
  932: 
  933:         # Set a different margins_name (not 'All')
  934:         result = data.pivot_table(
  935:             values="D",
  936:             index=["A", "B"],
  937:             columns="C",
  938:             margins=True,
  939:             aggfunc="mean",
  940:             margins_name="Totals",
  941:         )
  942:         self._check_output(result, "D", data, margins_col="Totals")
  943: 
  944:         # no column specified
  945:         table = data.pivot_table(
  946:             index=["A", "B"], columns="C", margins=True, aggfunc="mean"
  947:         )
  948:         for value_col in table.columns.levels[0]:
  949:             self._check_output(table[value_col], value_col, data)
  950: 
  951:     def test_no_col(self, data):
  952:         # no col
  953: 
  954:         # to help with a buglet
  955:         data.columns = [k * 2 for k in data.columns]
  956:         msg = re.escape("agg function failed [how->mean,dtype->")
  957:         with pytest.raises(TypeError, match=msg):
  958:             data.pivot_table(index=["AA", "BB"], margins=True, aggfunc="mean")
  959:         table = data.drop(columns="CC").pivot_table(
  960:             index=["AA", "BB"], margins=True, aggfunc="mean"
  961:         )
  962:         for value_col in table.columns:
  963:             totals = table.loc[("All", ""), value_col]
  964:             assert totals == data[value_col].mean()
  965: 
  966:         with pytest.raises(TypeError, match=msg):
  967:             data.pivot_table(index=["AA", "BB"], margins=True, aggfunc="mean")
  968:         table = data.drop(columns="CC").pivot_table(
  969:             index=["AA", "BB"], margins=True, aggfunc="mean"
  970:         )
  971:         for item in ["DD", "EE", "FF"]:
  972:             totals = table.loc[("All", ""), item]
  973:             assert totals == data[item].mean()
  974: 
  975:     @pytest.mark.parametrize(
  976:         "columns, aggfunc, values, expected_columns",
  977:         [
  978:             (
  979:                 "A",
  980:                 "mean",
  981:                 [[5.5, 5.5, 2.2, 2.2], [8.0, 8.0, 4.4, 4.4]],
  982:                 Index(["bar", "All", "foo", "All"], name="A"),
  983:             ),
  984:             (
  985:                 ["A", "B"],
  986:                 "sum",
  987:                 [
  988:                     [9, 13, 22, 5, 6, 11],
  989:                     [14, 18, 32, 11, 11, 22],
  990:                 ],
  991:                 MultiIndex.from_tuples(
  992:                     [
  993:                         ("bar", "one"),
  994:                         ("bar", "two"),
  995:                         ("bar", "All"),
  996:                         ("foo", "one"),
  997:                         ("foo", "two"),
  998:                         ("foo", "All"),
  999:                     ],
 1000:                     names=["A", "B"],
 1001:                 ),
 1002:             ),
 1003:         ],
 1004:     )
 1005:     def test_margin_with_only_columns_defined(
 1006:         self, columns, aggfunc, values, expected_columns
 1007:     ):
 1008:         # GH 31016
 1009:         df = DataFrame(
 1010:             {
 1011:                 "A": ["foo", "foo", "foo", "foo", "foo", "bar", "bar", "bar", "bar"],
 1012:                 "B": ["one", "one", "one", "two", "two", "one", "one", "two", "two"],
 1013:                 "C": [
 1014:                     "small",
 1015:                     "large",
 1016:                     "large",
 1017:                     "small",
 1018:                     "small",
 1019:                     "large",
 1020:                     "small",
 1021:                     "small",
 1022:                     "large",
 1023:                 ],
 1024:                 "D": [1, 2, 2, 3, 3, 4, 5, 6, 7],
 1025:                 "E": [2, 4, 5, 5, 6, 6, 8, 9, 9],
 1026:             }
 1027:         )
 1028:         if aggfunc != "sum":
 1029:             msg = re.escape("agg function failed [how->mean,dtype->")
 1030:             with pytest.raises(TypeError, match=msg):
 1031:                 df.pivot_table(columns=columns, margins=True, aggfunc=aggfunc)
 1032:         if "B" not in columns:
 1033:             df = df.drop(columns="B")
 1034:         result = df.drop(columns="C").pivot_table(
 1035:             columns=columns, margins=True, aggfunc=aggfunc
 1036:         )
 1037:         expected = DataFrame(values, index=Index(["D", "E"]), columns=expected_columns)
 1038: 
 1039:         tm.assert_frame_equal(result, expected)
 1040: 
 1041:     def test_margins_dtype(self, data):
 1042:         # GH 17013
 1043: 
 1044:         df = data.copy()
 1045:         df[["D", "E", "F"]] = np.arange(len(df) * 3).reshape(len(df), 3).astype("i8")
 1046: 
 1047:         mi_val = list(product(["bar", "foo"], ["one", "two"])) + [("All", "")]
 1048:         mi = MultiIndex.from_tuples(mi_val, names=("A", "B"))
 1049:         expected = DataFrame(
 1050:             {"dull": [12, 21, 3, 9, 45], "shiny": [33, 0, 36, 51, 120]}, index=mi
 1051:         ).rename_axis("C", axis=1)
 1052:         expected["All"] = expected["dull"] + expected["shiny"]
 1053: 
 1054:         result = df.pivot_table(
 1055:             values="D",
 1056:             index=["A", "B"],
 1057:             columns="C",
 1058:             margins=True,
 1059:             aggfunc="sum",
 1060:             fill_value=0,
 1061:         )
 1062: 
 1063:         tm.assert_frame_equal(expected, result)
 1064: 
 1065:     def test_margins_dtype_len(self, data):
 1066:         mi_val = list(product(["bar", "foo"], ["one", "two"])) + [("All", "")]
 1067:         mi = MultiIndex.from_tuples(mi_val, names=("A", "B"))
 1068:         expected = DataFrame(
 1069:             {"dull": [1, 1, 2, 1, 5], "shiny": [2, 0, 2, 2, 6]}, index=mi
 1070:         ).rename_axis("C", axis=1)
 1071:         expected["All"] = expected["dull"] + expected["shiny"]
 1072: 
 1073:         result = data.pivot_table(
 1074:             values="D",
 1075:             index=["A", "B"],
 1076:             columns="C",
 1077:             margins=True,
 1078:             aggfunc=len,
 1079:             fill_value=0,
 1080:         )
 1081: 
 1082:         tm.assert_frame_equal(expected, result)
 1083: 
 1084:     @pytest.mark.parametrize("cols", [(1, 2), ("a", "b"), (1, "b"), ("a", 1)])
 1085:     def test_pivot_table_multiindex_only(self, cols):
 1086:         # GH 17038
 1087:         df2 = DataFrame({cols[0]: [1, 2, 3], cols[1]: [1, 2, 3], "v": [4, 5, 6]})
 1088: 
 1089:         result = df2.pivot_table(values="v", columns=cols)
 1090:         expected = DataFrame(
 1091:             [[4.0, 5.0, 6.0]],
 1092:             columns=MultiIndex.from_tuples([(1, 1), (2, 2), (3, 3)], names=cols),
 1093:             index=Index(["v"], dtype=object),
 1094:         )
 1095: 
 1096:         tm.assert_frame_equal(result, expected)
 1097: 
 1098:     def test_pivot_table_retains_tz(self):
 1099:         dti = date_range("2016-01-01", periods=3, tz="Europe/Amsterdam")
 1100:         df = DataFrame(
 1101:             {
 1102:                 "A": np.random.default_rng(2).standard_normal(3),
 1103:                 "B": np.random.default_rng(2).standard_normal(3),
 1104:                 "C": dti,
 1105:             }
 1106:         )
 1107:         result = df.pivot_table(index=["B", "C"], dropna=False)
 1108: 
 1109:         # check tz retention
 1110:         assert result.index.levels[1].equals(dti)
 1111: 
 1112:     def test_pivot_integer_columns(self):
 1113:         # caused by upstream bug in unstack
 1114: 
 1115:         d = date.min
 1116:         data = list(
 1117:             product(
 1118:                 ["foo", "bar"],
 1119:                 ["A", "B", "C"],
 1120:                 ["x1", "x2"],
 1121:                 [d + timedelta(i) for i in range(20)],
 1122:                 [1.0],
 1123:             )
 1124:         )
 1125:         df = DataFrame(data)
 1126:         table = df.pivot_table(values=4, index=[0, 1, 3], columns=[2])
 1127: 
 1128:         df2 = df.rename(columns=str)
 1129:         table2 = df2.pivot_table(values="4", index=["0", "1", "3"], columns=["2"])
 1130: 
 1131:         tm.assert_frame_equal(table, table2, check_names=False)
 1132: 
 1133:     def test_pivot_no_level_overlap(self):
 1134:         # GH #1181
 1135: 
 1136:         data = DataFrame(
 1137:             {
 1138:                 "a": ["a", "a", "a", "a", "b", "b", "b", "b"] * 2,
 1139:                 "b": [0, 0, 0, 0, 1, 1, 1, 1] * 2,
 1140:                 "c": (["foo"] * 4 + ["bar"] * 4) * 2,
 1141:                 "value": np.random.default_rng(2).standard_normal(16),
 1142:             }
 1143:         )
 1144: 
 1145:         table = data.pivot_table("value", index="a", columns=["b", "c"])
 1146: 
 1147:         grouped = data.groupby(["a", "b", "c"])["value"].mean()
 1148:         expected = grouped.unstack("b").unstack("c").dropna(axis=1, how="all")
 1149:         tm.assert_frame_equal(table, expected)
 1150: 
 1151:     def test_pivot_columns_lexsorted(self):
 1152:         n = 10000
 1153: 
 1154:         dtype = np.dtype(
 1155:             [
 1156:                 ("Index", object),
 1157:                 ("Symbol", object),
 1158:                 ("Year", int),
 1159:                 ("Month", int),
 1160:                 ("Day", int),
 1161:                 ("Quantity", int),
 1162:                 ("Price", float),
 1163:             ]
 1164:         )
 1165: 
 1166:         products = np.array(
 1167:             [
 1168:                 ("SP500", "ADBE"),
 1169:                 ("SP500", "NVDA"),
 1170:                 ("SP500", "ORCL"),
 1171:                 ("NDQ100", "AAPL"),
 1172:                 ("NDQ100", "MSFT"),
 1173:                 ("NDQ100", "GOOG"),
 1174:                 ("FTSE", "DGE.L"),
 1175:                 ("FTSE", "TSCO.L"),
 1176:                 ("FTSE", "GSK.L"),
 1177:             ],
 1178:             dtype=[("Index", object), ("Symbol", object)],
 1179:         )
 1180:         items = np.empty(n, dtype=dtype)
 1181:         iproduct = np.random.default_rng(2).integers(0, len(products), n)
 1182:         items["Index"] = products["Index"][iproduct]
 1183:         items["Symbol"] = products["Symbol"][iproduct]
 1184:         dr = date_range(date(2000, 1, 1), date(2010, 12, 31))
 1185:         dates = dr[np.random.default_rng(2).integers(0, len(dr), n)]
 1186:         items["Year"] = dates.year
 1187:         items["Month"] = dates.month
 1188:         items["Day"] = dates.day
 1189:         items["Price"] = np.random.default_rng(2).lognormal(4.0, 2.0, n)
 1190: 
 1191:         df = DataFrame(items)
 1192: 
 1193:         pivoted = df.pivot_table(
 1194:             "Price",
 1195:             index=["Month", "Day"],
 1196:             columns=["Index", "Symbol", "Year"],
 1197:             aggfunc="mean",
 1198:         )
 1199: 
 1200:         assert pivoted.columns.is_monotonic_increasing
 1201: 
 1202:     def test_pivot_complex_aggfunc(self, data):
 1203:         f = {"D": ["std"], "E": ["sum"]}
 1204:         expected = data.groupby(["A", "B"]).agg(f).unstack("B")
 1205:         result = data.pivot_table(index="A", columns="B", aggfunc=f)
 1206: 
 1207:         tm.assert_frame_equal(result, expected)
 1208: 
 1209:     def test_margins_no_values_no_cols(self, data):
 1210:         # Regression test on pivot table: no values or cols passed.
 1211:         result = data[["A", "B"]].pivot_table(
 1212:             index=["A", "B"], aggfunc=len, margins=True
 1213:         )
 1214:         result_list = result.tolist()
 1215:         assert sum(result_list[:-1]) == result_list[-1]
 1216: 
 1217:     def test_margins_no_values_two_rows(self, data):
 1218:         # Regression test on pivot table: no values passed but rows are a
 1219:         # multi-index
 1220:         result = data[["A", "B", "C"]].pivot_table(
 1221:             index=["A", "B"], columns="C", aggfunc=len, margins=True
 1222:         )
 1223:         assert result.All.tolist() == [3.0, 1.0, 4.0, 3.0, 11.0]
 1224: 
 1225:     def test_margins_no_values_one_row_one_col(self, data):
 1226:         # Regression test on pivot table: no values passed but row and col
 1227:         # defined
 1228:         result = data[["A", "B"]].pivot_table(
 1229:             index="A", columns="B", aggfunc=len, margins=True
 1230:         )
 1231:         assert result.All.tolist() == [4.0, 7.0, 11.0]
 1232: 
 1233:     def test_margins_no_values_two_row_two_cols(self, data):
 1234:         # Regression test on pivot table: no values passed but rows and cols
 1235:         # are multi-indexed
 1236:         data["D"] = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k"]
 1237:         result = data[["A", "B", "C", "D"]].pivot_table(
 1238:             index=["A", "B"], columns=["C", "D"], aggfunc=len, margins=True
 1239:         )
 1240:         assert result.All.tolist() == [3.0, 1.0, 4.0, 3.0, 11.0]
 1241: 
 1242:     @pytest.mark.parametrize("margin_name", ["foo", "one", 666, None, ["a", "b"]])
 1243:     def test_pivot_table_with_margins_set_margin_name(self, margin_name, data):
 1244:         # see gh-3335
 1245:         msg = (
 1246:             f'Conflicting name "{margin_name}" in margins|'
 1247:             "margins_name argument must be a string"
 1248:         )
 1249:         with pytest.raises(ValueError, match=msg):
 1250:             # multi-index index
 1251:             pivot_table(
 1252:                 data,
 1253:                 values="D",
 1254:                 index=["A", "B"],
 1255:                 columns=["C"],
 1256:                 margins=True,
 1257:                 margins_name=margin_name,
 1258:             )
 1259:         with pytest.raises(ValueError, match=msg):
 1260:             # multi-index column
 1261:             pivot_table(
 1262:                 data,
 1263:                 values="D",
 1264:                 index=["C"],
 1265:                 columns=["A", "B"],
 1266:                 margins=True,
 1267:                 margins_name=margin_name,
 1268:             )
 1269:         with pytest.raises(ValueError, match=msg):
 1270:             # non-multi-index index/column
 1271:             pivot_table(
 1272:                 data,
 1273:                 values="D",
 1274:                 index=["A"],
 1275:                 columns=["B"],
 1276:                 margins=True,
 1277:                 margins_name=margin_name,
 1278:             )
 1279: 
 1280:     def test_pivot_timegrouper(self, using_array_manager):
 1281:         df = DataFrame(
 1282:             {
 1283:                 "Branch": "A A A A A A A B".split(),
 1284:                 "Buyer": "Carl Mark Carl Carl Joe Joe Joe Carl".split(),
 1285:                 "Quantity": [1, 3, 5, 1, 8, 1, 9, 3],
 1286:                 "Date": [
 1287:                     datetime(2013, 1, 1),
 1288:                     datetime(2013, 1, 1),
 1289:                     datetime(2013, 10, 1),
 1290:                     datetime(2013, 10, 2),
 1291:                     datetime(2013, 10, 1),
 1292:                     datetime(2013, 10, 2),
 1293:                     datetime(2013, 12, 2),
 1294:                     datetime(2013, 12, 2),
 1295:                 ],
 1296:             }
 1297:         ).set_index("Date")
 1298: 
 1299:         expected = DataFrame(
 1300:             np.array([10, 18, 3], dtype="int64").reshape(1, 3),
 1301:             index=pd.DatetimeIndex([datetime(2013, 12, 31)], freq="YE"),
 1302:             columns="Carl Joe Mark".split(),
 1303:         )
 1304:         expected.index.name = "Date"
 1305:         expected.columns.name = "Buyer"
 1306: 
 1307:         result = pivot_table(
 1308:             df,
 1309:             index=Grouper(freq="YE"),
 1310:             columns="Buyer",
 1311:             values="Quantity",
 1312:             aggfunc="sum",
 1313:         )
 1314:         tm.assert_frame_equal(result, expected)
 1315: 
 1316:         result = pivot_table(
 1317:             df,
 1318:             index="Buyer",
 1319:             columns=Grouper(freq="YE"),
 1320:             values="Quantity",
 1321:             aggfunc="sum",
 1322:         )
 1323:         tm.assert_frame_equal(result, expected.T)
 1324: 
 1325:         expected = DataFrame(
 1326:             np.array([1, np.nan, 3, 9, 18, np.nan]).reshape(2, 3),
 1327:             index=pd.DatetimeIndex(
 1328:                 [datetime(2013, 1, 1), datetime(2013, 7, 1)], freq="6MS"
 1329:             ),
 1330:             columns="Carl Joe Mark".split(),
 1331:         )
 1332:         expected.index.name = "Date"
 1333:         expected.columns.name = "Buyer"
 1334:         if using_array_manager:
 1335:             # INFO(ArrayManager) column without NaNs can preserve int dtype
 1336:             expected["Carl"] = expected["Carl"].astype("int64")
 1337: 
 1338:         result = pivot_table(
 1339:             df,
 1340:             index=Grouper(freq="6MS"),
 1341:             columns="Buyer",
 1342:             values="Quantity",
 1343:             aggfunc="sum",
 1344:         )
 1345:         tm.assert_frame_equal(result, expected)
 1346: 
 1347:         result = pivot_table(
 1348:             df,
 1349:             index="Buyer",
 1350:             columns=Grouper(freq="6MS"),
 1351:             values="Quantity",
 1352:             aggfunc="sum",
 1353:         )
 1354:         tm.assert_frame_equal(result, expected.T)
 1355: 
 1356:         # passing the name
 1357:         df = df.reset_index()
 1358:         result = pivot_table(
 1359:             df,
 1360:             index=Grouper(freq="6MS", key="Date"),
 1361:             columns="Buyer",
 1362:             values="Quantity",
 1363:             aggfunc="sum",
 1364:         )
 1365:         tm.assert_frame_equal(result, expected)
 1366: 
 1367:         result = pivot_table(
 1368:             df,
 1369:             index="Buyer",
 1370:             columns=Grouper(freq="6MS", key="Date"),
 1371:             values="Quantity",
 1372:             aggfunc="sum",
 1373:         )
 1374:         tm.assert_frame_equal(result, expected.T)
 1375: 
 1376:         msg = "'The grouper name foo is not found'"
 1377:         with pytest.raises(KeyError, match=msg):
 1378:             pivot_table(
 1379:                 df,
 1380:                 index=Grouper(freq="6MS", key="foo"),
 1381:                 columns="Buyer",
 1382:                 values="Quantity",
 1383:                 aggfunc="sum",
 1384:             )
 1385:         with pytest.raises(KeyError, match=msg):
 1386:             pivot_table(
 1387:                 df,
 1388:                 index="Buyer",
 1389:                 columns=Grouper(freq="6MS", key="foo"),
 1390:                 values="Quantity",
 1391:                 aggfunc="sum",
 1392:             )
 1393: 
 1394:         # passing the level
 1395:         df = df.set_index("Date")
 1396:         result = pivot_table(
 1397:             df,
 1398:             index=Grouper(freq="6MS", level="Date"),
 1399:             columns="Buyer",
 1400:             values="Quantity",
 1401:             aggfunc="sum",
 1402:         )
 1403:         tm.assert_frame_equal(result, expected)
 1404: 
 1405:         result = pivot_table(
 1406:             df,
 1407:             index="Buyer",
 1408:             columns=Grouper(freq="6MS", level="Date"),
 1409:             values="Quantity",
 1410:             aggfunc="sum",
 1411:         )
 1412:         tm.assert_frame_equal(result, expected.T)
 1413: 
 1414:         msg = "The level foo is not valid"
 1415:         with pytest.raises(ValueError, match=msg):
 1416:             pivot_table(
 1417:                 df,
 1418:                 index=Grouper(freq="6MS", level="foo"),
 1419:                 columns="Buyer",
 1420:                 values="Quantity",
 1421:                 aggfunc="sum",
 1422:             )
 1423:         with pytest.raises(ValueError, match=msg):
 1424:             pivot_table(
 1425:                 df,
 1426:                 index="Buyer",
 1427:                 columns=Grouper(freq="6MS", level="foo"),
 1428:                 values="Quantity",
 1429:                 aggfunc="sum",
 1430:             )
 1431: 
 1432:     def test_pivot_timegrouper_double(self):
 1433:         # double grouper
 1434:         df = DataFrame(
 1435:             {
 1436:                 "Branch": "A A A A A A A B".split(),
 1437:                 "Buyer": "Carl Mark Carl Carl Joe Joe Joe Carl".split(),
 1438:                 "Quantity": [1, 3, 5, 1, 8, 1, 9, 3],
 1439:                 "Date": [
 1440:                     datetime(2013, 11, 1, 13, 0),
 1441:                     datetime(2013, 9, 1, 13, 5),
 1442:                     datetime(2013, 10, 1, 20, 0),
 1443:                     datetime(2013, 10, 2, 10, 0),
 1444:                     datetime(2013, 11, 1, 20, 0),
 1445:                     datetime(2013, 10, 2, 10, 0),
 1446:                     datetime(2013, 10, 2, 12, 0),
 1447:                     datetime(2013, 12, 5, 14, 0),
 1448:                 ],
 1449:                 "PayDay": [
 1450:                     datetime(2013, 10, 4, 0, 0),
 1451:                     datetime(2013, 10, 15, 13, 5),
 1452:                     datetime(2013, 9, 5, 20, 0),
 1453:                     datetime(2013, 11, 2, 10, 0),
 1454:                     datetime(2013, 10, 7, 20, 0),
 1455:                     datetime(2013, 9, 5, 10, 0),
 1456:                     datetime(2013, 12, 30, 12, 0),
 1457:                     datetime(2013, 11, 20, 14, 0),
 1458:                 ],
 1459:             }
 1460:         )
 1461: 
 1462:         result = pivot_table(
 1463:             df,
 1464:             index=Grouper(freq="ME", key="Date"),
 1465:             columns=Grouper(freq="ME", key="PayDay"),
 1466:             values="Quantity",
 1467:             aggfunc="sum",
 1468:         )
 1469:         expected = DataFrame(
 1470:             np.array(
 1471:                 [
 1472:                     np.nan,
 1473:                     3,
 1474:                     np.nan,
 1475:                     np.nan,
 1476:                     6,
 1477:                     np.nan,
 1478:                     1,
 1479:                     9,
 1480:                     np.nan,
 1481:                     9,
 1482:                     np.nan,
 1483:                     np.nan,
 1484:                     np.nan,
 1485:                     np.nan,
 1486:                     3,
 1487:                     np.nan,
 1488:                 ]
 1489:             ).reshape(4, 4),
 1490:             index=pd.DatetimeIndex(
 1491:                 [
 1492:                     datetime(2013, 9, 30),
 1493:                     datetime(2013, 10, 31),
 1494:                     datetime(2013, 11, 30),
 1495:                     datetime(2013, 12, 31),
 1496:                 ],
 1497:                 freq="ME",
 1498:             ),
 1499:             columns=pd.DatetimeIndex(
 1500:                 [
 1501:                     datetime(2013, 9, 30),
 1502:                     datetime(2013, 10, 31),
 1503:                     datetime(2013, 11, 30),
 1504:                     datetime(2013, 12, 31),
 1505:                 ],
 1506:                 freq="ME",
 1507:             ),
 1508:         )
 1509:         expected.index.name = "Date"
 1510:         expected.columns.name = "PayDay"
 1511: 
 1512:         tm.assert_frame_equal(result, expected)
 1513: 
 1514:         result = pivot_table(
 1515:             df,
 1516:             index=Grouper(freq="ME", key="PayDay"),
 1517:             columns=Grouper(freq="ME", key="Date"),
 1518:             values="Quantity",
 1519:             aggfunc="sum",
 1520:         )
 1521:         tm.assert_frame_equal(result, expected.T)
 1522: 
 1523:         tuples = [
 1524:             (datetime(2013, 9, 30), datetime(2013, 10, 31)),
 1525:             (datetime(2013, 10, 31), datetime(2013, 9, 30)),
 1526:             (datetime(2013, 10, 31), datetime(2013, 11, 30)),
 1527:             (datetime(2013, 10, 31), datetime(2013, 12, 31)),
 1528:             (datetime(2013, 11, 30), datetime(2013, 10, 31)),
 1529:             (datetime(2013, 12, 31), datetime(2013, 11, 30)),
 1530:         ]
 1531:         idx = MultiIndex.from_tuples(tuples, names=["Date", "PayDay"])
 1532:         expected = DataFrame(
 1533:             np.array(
 1534:                 [3, np.nan, 6, np.nan, 1, np.nan, 9, np.nan, 9, np.nan, np.nan, 3]
 1535:             ).reshape(6, 2),
 1536:             index=idx,
 1537:             columns=["A", "B"],
 1538:         )
 1539:         expected.columns.name = "Branch"
 1540: 
 1541:         result = pivot_table(
 1542:             df,
 1543:             index=[Grouper(freq="ME", key="Date"), Grouper(freq="ME", key="PayDay")],
 1544:             columns=["Branch"],
 1545:             values="Quantity",
 1546:             aggfunc="sum",
 1547:         )
 1548:         tm.assert_frame_equal(result, expected)
 1549: 
 1550:         result = pivot_table(
 1551:             df,
 1552:             index=["Branch"],
 1553:             columns=[Grouper(freq="ME", key="Date"), Grouper(freq="ME", key="PayDay")],
 1554:             values="Quantity",
 1555:             aggfunc="sum",
 1556:         )
 1557:         tm.assert_frame_equal(result, expected.T)
 1558: 
 1559:     def test_pivot_datetime_tz(self):
 1560:         dates1 = pd.DatetimeIndex(
 1561:             [
 1562:                 "2011-07-19 07:00:00",
 1563:                 "2011-07-19 08:00:00",
 1564:                 "2011-07-19 09:00:00",
 1565:                 "2011-07-19 07:00:00",
 1566:                 "2011-07-19 08:00:00",
 1567:                 "2011-07-19 09:00:00",
 1568:             ],
 1569:             dtype="M8[ns, US/Pacific]",
 1570:             name="dt1",
 1571:         )
 1572:         dates2 = pd.DatetimeIndex(
 1573:             [
 1574:                 "2013-01-01 15:00:00",
 1575:                 "2013-01-01 15:00:00",
 1576:                 "2013-01-01 15:00:00",
 1577:                 "2013-02-01 15:00:00",
 1578:                 "2013-02-01 15:00:00",
 1579:                 "2013-02-01 15:00:00",
 1580:             ],
 1581:             dtype="M8[ns, Asia/Tokyo]",
 1582:         )
 1583:         df = DataFrame(
 1584:             {
 1585:                 "label": ["a", "a", "a", "b", "b", "b"],
 1586:                 "dt1": dates1,
 1587:                 "dt2": dates2,
 1588:                 "value1": np.arange(6, dtype="int64"),
 1589:                 "value2": [1, 2] * 3,
 1590:             }
 1591:         )
 1592: 
 1593:         exp_idx = dates1[:3]
 1594:         exp_col1 = Index(["value1", "value1"])
 1595:         exp_col2 = Index(["a", "b"], name="label")
 1596:         exp_col = MultiIndex.from_arrays([exp_col1, exp_col2])
 1597:         expected = DataFrame(
 1598:             [[0.0, 3.0], [1.0, 4.0], [2.0, 5.0]], index=exp_idx, columns=exp_col
 1599:         )
 1600:         result = pivot_table(df, index=["dt1"], columns=["label"], values=["value1"])
 1601:         tm.assert_frame_equal(result, expected)
 1602: 
 1603:         exp_col1 = Index(["sum", "sum", "sum", "sum", "mean", "mean", "mean", "mean"])
 1604:         exp_col2 = Index(["value1", "value1", "value2", "value2"] * 2)
 1605:         exp_col3 = pd.DatetimeIndex(
 1606:             ["2013-01-01 15:00:00", "2013-02-01 15:00:00"] * 4,
 1607:             dtype="M8[ns, Asia/Tokyo]",
 1608:             name="dt2",
 1609:         )
 1610:         exp_col = MultiIndex.from_arrays([exp_col1, exp_col2, exp_col3])
 1611:         expected1 = DataFrame(
 1612:             np.array(
 1613:                 [
 1614:                     [
 1615:                         0,
 1616:                         3,
 1617:                         1,
 1618:                         2,
 1619:                     ],
 1620:                     [1, 4, 2, 1],
 1621:                     [2, 5, 1, 2],
 1622:                 ],
 1623:                 dtype="int64",
 1624:             ),
 1625:             index=exp_idx,
 1626:             columns=exp_col[:4],
 1627:         )
 1628:         expected2 = DataFrame(
 1629:             np.array(
 1630:                 [
 1631:                     [0.0, 3.0, 1.0, 2.0],
 1632:                     [1.0, 4.0, 2.0, 1.0],
 1633:                     [2.0, 5.0, 1.0, 2.0],
 1634:                 ],
 1635:             ),
 1636:             index=exp_idx,
 1637:             columns=exp_col[4:],
 1638:         )
 1639:         expected = concat([expected1, expected2], axis=1)
 1640: 
 1641:         result = pivot_table(
 1642:             df,
 1643:             index=["dt1"],
 1644:             columns=["dt2"],
 1645:             values=["value1", "value2"],
 1646:             aggfunc=["sum", "mean"],
 1647:         )
 1648:         tm.assert_frame_equal(result, expected)
 1649: 
 1650:     def test_pivot_dtaccessor(self):
 1651:         # GH 8103
 1652:         dates1 = pd.DatetimeIndex(
 1653:             [
 1654:                 "2011-07-19 07:00:00",
 1655:                 "2011-07-19 08:00:00",
 1656:                 "2011-07-19 09:00:00",
 1657:                 "2011-07-19 07:00:00",
 1658:                 "2011-07-19 08:00:00",
 1659:                 "2011-07-19 09:00:00",
 1660:             ]
 1661:         )
 1662:         dates2 = pd.DatetimeIndex(
 1663:             [
 1664:                 "2013-01-01 15:00:00",
 1665:                 "2013-01-01 15:00:00",
 1666:                 "2013-01-01 15:00:00",
 1667:                 "2013-02-01 15:00:00",
 1668:                 "2013-02-01 15:00:00",
 1669:                 "2013-02-01 15:00:00",
 1670:             ]
 1671:         )
 1672:         df = DataFrame(
 1673:             {
 1674:                 "label": ["a", "a", "a", "b", "b", "b"],
 1675:                 "dt1": dates1,
 1676:                 "dt2": dates2,
 1677:                 "value1": np.arange(6, dtype="int64"),
 1678:                 "value2": [1, 2] * 3,
 1679:             }
 1680:         )
 1681: 
 1682:         result = pivot_table(
 1683:             df, index="label", columns=df["dt1"].dt.hour, values="value1"
 1684:         )
 1685: 
 1686:         exp_idx = Index(["a", "b"], name="label")
 1687:         expected = DataFrame(
 1688:             {7: [0.0, 3.0], 8: [1.0, 4.0], 9: [2.0, 5.0]},
 1689:             index=exp_idx,
 1690:             columns=Index([7, 8, 9], dtype=np.int32, name="dt1"),
 1691:         )
 1692:         tm.assert_frame_equal(result, expected)
 1693: 
 1694:         result = pivot_table(
 1695:             df, index=df["dt2"].dt.month, columns=df["dt1"].dt.hour, values="value1"
 1696:         )
 1697: 
 1698:         expected = DataFrame(
 1699:             {7: [0.0, 3.0], 8: [1.0, 4.0], 9: [2.0, 5.0]},
 1700:             index=Index([1, 2], dtype=np.int32, name="dt2"),
 1701:             columns=Index([7, 8, 9], dtype=np.int32, name="dt1"),
 1702:         )
 1703:         tm.assert_frame_equal(result, expected)
 1704: 
 1705:         result = pivot_table(
 1706:             df,
 1707:             index=df["dt2"].dt.year.values,
 1708:             columns=[df["dt1"].dt.hour, df["dt2"].dt.month],
 1709:             values="value1",
 1710:         )
 1711: 
 1712:         exp_col = MultiIndex.from_arrays(
 1713:             [
 1714:                 np.array([7, 7, 8, 8, 9, 9], dtype=np.int32),
 1715:                 np.array([1, 2] * 3, dtype=np.int32),
 1716:             ],
 1717:             names=["dt1", "dt2"],
 1718:         )
 1719:         expected = DataFrame(
 1720:             np.array([[0.0, 3.0, 1.0, 4.0, 2.0, 5.0]]),
 1721:             index=Index([2013], dtype=np.int32),
 1722:             columns=exp_col,
 1723:         )
 1724:         tm.assert_frame_equal(result, expected)
 1725: 
 1726:         result = pivot_table(
 1727:             df,
 1728:             index=np.array(["X", "X", "X", "X", "Y", "Y"]),
 1729:             columns=[df["dt1"].dt.hour, df["dt2"].dt.month],
 1730:             values="value1",
 1731:         )
 1732:         expected = DataFrame(
 1733:             np.array(
 1734:                 [[0, 3, 1, np.nan, 2, np.nan], [np.nan, np.nan, np.nan, 4, np.nan, 5]]
 1735:             ),
 1736:             index=["X", "Y"],
 1737:             columns=exp_col,
 1738:         )
 1739:         tm.assert_frame_equal(result, expected)
 1740: 
 1741:     def test_daily(self):
 1742:         rng = date_range("1/1/2000", "12/31/2004", freq="D")
 1743:         ts = Series(np.arange(len(rng)), index=rng)
 1744: 
 1745:         result = pivot_table(
 1746:             DataFrame(ts), index=ts.index.year, columns=ts.index.dayofyear
 1747:         )
 1748:         result.columns = result.columns.droplevel(0)
 1749: 
 1750:         doy = np.asarray(ts.index.dayofyear)
 1751: 
 1752:         expected = {}
 1753:         for y in ts.index.year.unique().values:
 1754:             mask = ts.index.year == y
 1755:             expected[y] = Series(ts.values[mask], index=doy[mask])
 1756:         expected = DataFrame(expected, dtype=float).T
 1757:         tm.assert_frame_equal(result, expected)
 1758: 
 1759:     def test_monthly(self):
 1760:         rng = date_range("1/1/2000", "12/31/2004", freq="ME")
 1761:         ts = Series(np.arange(len(rng)), index=rng)
 1762: 
 1763:         result = pivot_table(DataFrame(ts), index=ts.index.year, columns=ts.index.month)
 1764:         result.columns = result.columns.droplevel(0)
 1765: 
 1766:         month = np.asarray(ts.index.month)
 1767:         expected = {}
 1768:         for y in ts.index.year.unique().values:
 1769:             mask = ts.index.year == y
 1770:             expected[y] = Series(ts.values[mask], index=month[mask])
 1771:         expected = DataFrame(expected, dtype=float).T
 1772:         tm.assert_frame_equal(result, expected)
 1773: 
 1774:     def test_pivot_table_with_iterator_values(self, data):
 1775:         # GH 12017
 1776:         aggs = {"D": "sum", "E": "mean"}
 1777: 
 1778:         pivot_values_list = pivot_table(
 1779:             data, index=["A"], values=list(aggs.keys()), aggfunc=aggs
 1780:         )
 1781: 
 1782:         pivot_values_keys = pivot_table(
 1783:             data, index=["A"], values=aggs.keys(), aggfunc=aggs
 1784:         )
 1785:         tm.assert_frame_equal(pivot_values_keys, pivot_values_list)
 1786: 
 1787:         agg_values_gen = (value for value in aggs)
 1788:         pivot_values_gen = pivot_table(
 1789:             data, index=["A"], values=agg_values_gen, aggfunc=aggs
 1790:         )
 1791:         tm.assert_frame_equal(pivot_values_gen, pivot_values_list)
 1792: 
 1793:     def test_pivot_table_margins_name_with_aggfunc_list(self):
 1794:         # GH 13354
 1795:         margins_name = "Weekly"
 1796:         costs = DataFrame(
 1797:             {
 1798:                 "item": ["bacon", "cheese", "bacon", "cheese"],
 1799:                 "cost": [2.5, 4.5, 3.2, 3.3],
 1800:                 "day": ["ME", "ME", "T", "T"],
 1801:             }
 1802:         )
 1803:         table = costs.pivot_table(
 1804:             index="item",
 1805:             columns="day",
 1806:             margins=True,
 1807:             margins_name=margins_name,
 1808:             aggfunc=["mean", "max"],
 1809:         )
 1810:         ix = Index(["bacon", "cheese", margins_name], name="item")
 1811:         tups = [
 1812:             ("mean", "cost", "ME"),
 1813:             ("mean", "cost", "T"),
 1814:             ("mean", "cost", margins_name),
 1815:             ("max", "cost", "ME"),
 1816:             ("max", "cost", "T"),
 1817:             ("max", "cost", margins_name),
 1818:         ]
 1819:         cols = MultiIndex.from_tuples(tups, names=[None, None, "day"])
 1820:         expected = DataFrame(table.values, index=ix, columns=cols)
 1821:         tm.assert_frame_equal(table, expected)
 1822: 
 1823:     def test_categorical_margins(self, observed):
 1824:         # GH 10989
 1825:         df = DataFrame(
 1826:             {"x": np.arange(8), "y": np.arange(8) // 4, "z": np.arange(8) % 2}
 1827:         )
 1828: 
 1829:         expected = DataFrame([[1.0, 2.0, 1.5], [5, 6, 5.5], [3, 4, 3.5]])
 1830:         expected.index = Index([0, 1, "All"], name="y")
 1831:         expected.columns = Index([0, 1, "All"], name="z")
 1832: 
 1833:         table = df.pivot_table("x", "y", "z", dropna=observed, margins=True)
 1834:         tm.assert_frame_equal(table, expected)
 1835: 
 1836:     def test_categorical_margins_category(self, observed):
 1837:         df = DataFrame(
 1838:             {"x": np.arange(8), "y": np.arange(8) // 4, "z": np.arange(8) % 2}
 1839:         )
 1840: 
 1841:         expected = DataFrame([[1.0, 2.0, 1.5], [5, 6, 5.5], [3, 4, 3.5]])
 1842:         expected.index = Index([0, 1, "All"], name="y")
 1843:         expected.columns = Index([0, 1, "All"], name="z")
 1844: 
 1845:         df.y = df.y.astype("category")
 1846:         df.z = df.z.astype("category")
 1847:         msg = "The default value of observed=False is deprecated"
 1848:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1849:             table = df.pivot_table("x", "y", "z", dropna=observed, margins=True)
 1850:         tm.assert_frame_equal(table, expected)
 1851: 
 1852:     def test_margins_casted_to_float(self):
 1853:         # GH 24893
 1854:         df = DataFrame(
 1855:             {
 1856:                 "A": [2, 4, 6, 8],
 1857:                 "B": [1, 4, 5, 8],
 1858:                 "C": [1, 3, 4, 6],
 1859:                 "D": ["X", "X", "Y", "Y"],
 1860:             }
 1861:         )
 1862: 
 1863:         result = pivot_table(df, index="D", margins=True)
 1864:         expected = DataFrame(
 1865:             {"A": [3.0, 7.0, 5], "B": [2.5, 6.5, 4.5], "C": [2.0, 5.0, 3.5]},
 1866:             index=Index(["X", "Y", "All"], name="D"),
 1867:         )
 1868:         tm.assert_frame_equal(result, expected)
 1869: 
 1870:     def test_pivot_with_categorical(self, observed, ordered):
 1871:         # gh-21370
 1872:         idx = [np.nan, "low", "high", "low", np.nan]
 1873:         col = [np.nan, "A", "B", np.nan, "A"]
 1874:         df = DataFrame(
 1875:             {
 1876:                 "In": Categorical(idx, categories=["low", "high"], ordered=ordered),
 1877:                 "Col": Categorical(col, categories=["A", "B"], ordered=ordered),
 1878:                 "Val": range(1, 6),
 1879:             }
 1880:         )
 1881:         # case with index/columns/value
 1882:         result = df.pivot_table(
 1883:             index="In", columns="Col", values="Val", observed=observed
 1884:         )
 1885: 
 1886:         expected_cols = pd.CategoricalIndex(["A", "B"], ordered=ordered, name="Col")
 1887: 
 1888:         expected = DataFrame(data=[[2.0, np.nan], [np.nan, 3.0]], columns=expected_cols)
 1889:         expected.index = Index(
 1890:             Categorical(["low", "high"], categories=["low", "high"], ordered=ordered),
 1891:             name="In",
 1892:         )
 1893: 
 1894:         tm.assert_frame_equal(result, expected)
 1895: 
 1896:         # case with columns/value
 1897:         result = df.pivot_table(columns="Col", values="Val", observed=observed)
 1898: 
 1899:         expected = DataFrame(
 1900:             data=[[3.5, 3.0]], columns=expected_cols, index=Index(["Val"])
 1901:         )
 1902: 
 1903:         tm.assert_frame_equal(result, expected)
 1904: 
 1905:     def test_categorical_aggfunc(self, observed):
 1906:         # GH 9534
 1907:         df = DataFrame(
 1908:             {"C1": ["A", "B", "C", "C"], "C2": ["a", "a", "b", "b"], "V": [1, 2, 3, 4]}
 1909:         )
 1910:         df["C1"] = df["C1"].astype("category")
 1911:         msg = "The default value of observed=False is deprecated"
 1912:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1913:             result = df.pivot_table(
 1914:                 "V", index="C1", columns="C2", dropna=observed, aggfunc="count"
 1915:             )
 1916: 
 1917:         expected_index = pd.CategoricalIndex(
 1918:             ["A", "B", "C"], categories=["A", "B", "C"], ordered=False, name="C1"
 1919:         )
 1920:         expected_columns = Index(["a", "b"], name="C2")
 1921:         expected_data = np.array([[1, 0], [1, 0], [0, 2]], dtype=np.int64)
 1922:         expected = DataFrame(
 1923:             expected_data, index=expected_index, columns=expected_columns
 1924:         )
 1925:         tm.assert_frame_equal(result, expected)
 1926: 
 1927:     def test_categorical_pivot_index_ordering(self, observed):
 1928:         # GH 8731
 1929:         df = DataFrame(
 1930:             {
 1931:                 "Sales": [100, 120, 220],
 1932:                 "Month": ["January", "January", "January"],
 1933:                 "Year": [2013, 2014, 2013],
 1934:             }
 1935:         )
 1936:         months = [
 1937:             "January",
 1938:             "February",
 1939:             "March",
 1940:             "April",
 1941:             "May",
 1942:             "June",
 1943:             "July",
 1944:             "August",
 1945:             "September",
 1946:             "October",
 1947:             "November",
 1948:             "December",
 1949:         ]
 1950:         df["Month"] = df["Month"].astype("category").cat.set_categories(months)
 1951:         result = df.pivot_table(
 1952:             values="Sales",
 1953:             index="Month",
 1954:             columns="Year",
 1955:             observed=observed,
 1956:             aggfunc="sum",
 1957:         )
 1958:         expected_columns = Index([2013, 2014], name="Year", dtype="int64")
 1959:         expected_index = pd.CategoricalIndex(
 1960:             months, categories=months, ordered=False, name="Month"
 1961:         )
 1962:         expected_data = [[320, 120]] + [[0, 0]] * 11
 1963:         expected = DataFrame(
 1964:             expected_data, index=expected_index, columns=expected_columns
 1965:         )
 1966:         if observed:
 1967:             expected = expected.loc[["January"]]
 1968: 
 1969:         tm.assert_frame_equal(result, expected)
 1970: 
 1971:     def test_pivot_table_not_series(self):
 1972:         # GH 4386
 1973:         # pivot_table always returns a DataFrame
 1974:         # when values is not list like and columns is None
 1975:         # and aggfunc is not instance of list
 1976:         df = DataFrame({"col1": [3, 4, 5], "col2": ["C", "D", "E"], "col3": [1, 3, 9]})
 1977: 
 1978:         result = df.pivot_table("col1", index=["col3", "col2"], aggfunc="sum")
 1979:         m = MultiIndex.from_arrays([[1, 3, 9], ["C", "D", "E"]], names=["col3", "col2"])
 1980:         expected = DataFrame([3, 4, 5], index=m, columns=["col1"])
 1981: 
 1982:         tm.assert_frame_equal(result, expected)
 1983: 
 1984:         result = df.pivot_table("col1", index="col3", columns="col2", aggfunc="sum")
 1985:         expected = DataFrame(
 1986:             [[3, np.nan, np.nan], [np.nan, 4, np.nan], [np.nan, np.nan, 5]],
 1987:             index=Index([1, 3, 9], name="col3"),
 1988:             columns=Index(["C", "D", "E"], name="col2"),
 1989:         )
 1990: 
 1991:         tm.assert_frame_equal(result, expected)
 1992: 
 1993:         result = df.pivot_table("col1", index="col3", aggfunc=["sum"])
 1994:         m = MultiIndex.from_arrays([["sum"], ["col1"]])
 1995:         expected = DataFrame([3, 4, 5], index=Index([1, 3, 9], name="col3"), columns=m)
 1996: 
 1997:         tm.assert_frame_equal(result, expected)
 1998: 
 1999:     def test_pivot_margins_name_unicode(self):
 2000:         # issue #13292
 2001:         greek = "\u0394\u03bf\u03ba\u03b9\u03bc\u03ae"
 2002:         frame = DataFrame({"foo": [1, 2, 3]}, columns=Index(["foo"], dtype=object))
 2003:         table = pivot_table(
 2004:             frame, index=["foo"], aggfunc=len, margins=True, margins_name=greek
 2005:         )
 2006:         index = Index([1, 2, 3, greek], dtype="object", name="foo")
 2007:         expected = DataFrame(index=index, columns=[])
 2008:         tm.assert_frame_equal(table, expected)
 2009: 
 2010:     def test_pivot_string_as_func(self):
 2011:         # GH #18713
 2012:         # for correctness purposes
 2013:         data = DataFrame(
 2014:             {
 2015:                 "A": [
 2016:                     "foo",
 2017:                     "foo",
 2018:                     "foo",
 2019:                     "foo",
 2020:                     "bar",
 2021:                     "bar",
 2022:                     "bar",
 2023:                     "bar",
 2024:                     "foo",
 2025:                     "foo",
 2026:                     "foo",
 2027:                 ],
 2028:                 "B": [
 2029:                     "one",
 2030:                     "one",
 2031:                     "one",
 2032:                     "two",
 2033:                     "one",
 2034:                     "one",
 2035:                     "one",
 2036:                     "two",
 2037:                     "two",
 2038:                     "two",
 2039:                     "one",
 2040:                 ],
 2041:                 "C": range(11),
 2042:             }
 2043:         )
 2044: 
 2045:         result = pivot_table(data, index="A", columns="B", aggfunc="sum")
 2046:         mi = MultiIndex(
 2047:             levels=[["C"], ["one", "two"]], codes=[[0, 0], [0, 1]], names=[None, "B"]
 2048:         )
 2049:         expected = DataFrame(
 2050:             {("C", "one"): {"bar": 15, "foo": 13}, ("C", "two"): {"bar": 7, "foo": 20}},
 2051:             columns=mi,
 2052:         ).rename_axis("A")
 2053:         tm.assert_frame_equal(result, expected)
 2054: 
 2055:         result = pivot_table(data, index="A", columns="B", aggfunc=["sum", "mean"])
 2056:         mi = MultiIndex(
 2057:             levels=[["sum", "mean"], ["C"], ["one", "two"]],
 2058:             codes=[[0, 0, 1, 1], [0, 0, 0, 0], [0, 1, 0, 1]],
 2059:             names=[None, None, "B"],
 2060:         )
 2061:         expected = DataFrame(
 2062:             {
 2063:                 ("mean", "C", "one"): {"bar": 5.0, "foo": 3.25},
 2064:                 ("mean", "C", "two"): {"bar": 7.0, "foo": 6.666666666666667},
 2065:                 ("sum", "C", "one"): {"bar": 15, "foo": 13},
 2066:                 ("sum", "C", "two"): {"bar": 7, "foo": 20},
 2067:             },
 2068:             columns=mi,
 2069:         ).rename_axis("A")
 2070:         tm.assert_frame_equal(result, expected)
 2071: 
 2072:     @pytest.mark.parametrize(
 2073:         "f, f_numpy",
 2074:         [
 2075:             ("sum", np.sum),
 2076:             ("mean", np.mean),
 2077:             ("std", np.std),
 2078:             (["sum", "mean"], [np.sum, np.mean]),
 2079:             (["sum", "std"], [np.sum, np.std]),
 2080:             (["std", "mean"], [np.std, np.mean]),
 2081:         ],
 2082:     )
 2083:     def test_pivot_string_func_vs_func(self, f, f_numpy, data):
 2084:         # GH #18713
 2085:         # for consistency purposes
 2086:         data = data.drop(columns="C")
 2087:         result = pivot_table(data, index="A", columns="B", aggfunc=f)
 2088:         ops = "|".join(f) if isinstance(f, list) else f
 2089:         msg = f"using DataFrameGroupBy.[{ops}]"
 2090:         with tm.assert_produces_warning(FutureWarning, match=msg):
 2091:             expected = pivot_table(data, index="A", columns="B", aggfunc=f_numpy)
 2092:         tm.assert_frame_equal(result, expected)
 2093: 
 2094:     @pytest.mark.slow
 2095:     def test_pivot_number_of_levels_larger_than_int32(self, monkeypatch):
 2096:         # GH 20601
 2097:         # GH 26314: Change ValueError to PerformanceWarning
 2098:         class MockUnstacker(reshape_lib._Unstacker):
 2099:             def __init__(self, *args, **kwargs) -> None:
 2100:                 # __init__ will raise the warning
 2101:                 super().__init__(*args, **kwargs)
 2102:                 raise Exception("Don't compute final result.")
 2103: 
 2104:         with monkeypatch.context() as m:
 2105:             m.setattr(reshape_lib, "_Unstacker", MockUnstacker)
 2106:             df = DataFrame(
 2107:                 {"ind1": np.arange(2**16), "ind2": np.arange(2**16), "count": 0}
 2108:             )
 2109: 
 2110:             msg = "The following operation may generate"
 2111:             with tm.assert_produces_warning(PerformanceWarning, match=msg):
 2112:                 with pytest.raises(Exception, match="Don't compute final result."):
 2113:                     df.pivot_table(
 2114:                         index="ind1", columns="ind2", values="count", aggfunc="count"
 2115:                     )
 2116: 
 2117:     def test_pivot_table_aggfunc_dropna(self, dropna):
 2118:         # GH 22159
 2119:         df = DataFrame(
 2120:             {
 2121:                 "fruit": ["apple", "peach", "apple"],
 2122:                 "size": [1, 1, 2],
 2123:                 "taste": [7, 6, 6],
 2124:             }
 2125:         )
 2126: 
 2127:         def ret_one(x):
 2128:             return 1
 2129: 
 2130:         def ret_sum(x):
 2131:             return sum(x)
 2132: 
 2133:         def ret_none(x):
 2134:             return np.nan
 2135: 
 2136:         result = pivot_table(
 2137:             df, columns="fruit", aggfunc=[ret_sum, ret_none, ret_one], dropna=dropna
 2138:         )
 2139: 
 2140:         data = [[3, 1, np.nan, np.nan, 1, 1], [13, 6, np.nan, np.nan, 1, 1]]
 2141:         col = MultiIndex.from_product(
 2142:             [["ret_sum", "ret_none", "ret_one"], ["apple", "peach"]],
 2143:             names=[None, "fruit"],
 2144:         )
 2145:         expected = DataFrame(data, index=["size", "taste"], columns=col)
 2146: 
 2147:         if dropna:
 2148:             expected = expected.dropna(axis="columns")
 2149: 
 2150:         tm.assert_frame_equal(result, expected)
 2151: 
 2152:     def test_pivot_table_aggfunc_scalar_dropna(self, dropna):
 2153:         # GH 22159
 2154:         df = DataFrame(
 2155:             {"A": ["one", "two", "one"], "x": [3, np.nan, 2], "y": [1, np.nan, np.nan]}
 2156:         )
 2157: 
 2158:         result = pivot_table(df, columns="A", aggfunc="mean", dropna=dropna)
 2159: 
 2160:         data = [[2.5, np.nan], [1, np.nan]]
 2161:         col = Index(["one", "two"], name="A")
 2162:         expected = DataFrame(data, index=["x", "y"], columns=col)
 2163: 
 2164:         if dropna:
 2165:             expected = expected.dropna(axis="columns")
 2166: 
 2167:         tm.assert_frame_equal(result, expected)
 2168: 
 2169:     @pytest.mark.parametrize("margins", [True, False])
 2170:     def test_pivot_table_empty_aggfunc(self, margins):
 2171:         # GH 9186 & GH 13483 & GH 49240
 2172:         df = DataFrame(
 2173:             {
 2174:                 "A": [2, 2, 3, 3, 2],
 2175:                 "id": [5, 6, 7, 8, 9],
 2176:                 "C": ["p", "q", "q", "p", "q"],
 2177:                 "D": [None, None, None, None, None],
 2178:             }
 2179:         )
 2180:         result = df.pivot_table(
 2181:             index="A", columns="D", values="id", aggfunc=np.size, margins=margins
 2182:         )
 2183:         exp_cols = Index([], name="D")
 2184:         expected = DataFrame(index=Index([], dtype="int64", name="A"), columns=exp_cols)
 2185:         tm.assert_frame_equal(result, expected)
 2186: 
 2187:     def test_pivot_table_no_column_raises(self):
 2188:         # GH 10326
 2189:         def agg(arr):
 2190:             return np.mean(arr)
 2191: 
 2192:         df = DataFrame({"X": [0, 0, 1, 1], "Y": [0, 1, 0, 1], "Z": [10, 20, 30, 40]})
 2193:         with pytest.raises(KeyError, match="notpresent"):
 2194:             df.pivot_table("notpresent", "X", "Y", aggfunc=agg)
 2195: 
 2196:     def test_pivot_table_multiindex_columns_doctest_case(self):
 2197:         # The relevant characteristic is that the call
 2198:         #  to maybe_downcast_to_dtype(agged[v], data[v].dtype) in
 2199:         #  __internal_pivot_table has `agged[v]` a DataFrame instead of Series,
 2200:         #  In this case this is because agged.columns is a MultiIndex and 'v'
 2201:         #  is only indexing on its first level.
 2202:         df = DataFrame(
 2203:             {
 2204:                 "A": ["foo", "foo", "foo", "foo", "foo", "bar", "bar", "bar", "bar"],
 2205:                 "B": ["one", "one", "one", "two", "two", "one", "one", "two", "two"],
 2206:                 "C": [
 2207:                     "small",
 2208:                     "large",
 2209:                     "large",
 2210:                     "small",
 2211:                     "small",
 2212:                     "large",
 2213:                     "small",
 2214:                     "small",
 2215:                     "large",
 2216:                 ],
 2217:                 "D": [1, 2, 2, 3, 3, 4, 5, 6, 7],
 2218:                 "E": [2, 4, 5, 5, 6, 6, 8, 9, 9],
 2219:             }
 2220:         )
 2221: 
 2222:         table = pivot_table(
 2223:             df,
 2224:             values=["D", "E"],
 2225:             index=["A", "C"],
 2226:             aggfunc={"D": "mean", "E": ["min", "max", "mean"]},
 2227:         )
 2228:         cols = MultiIndex.from_tuples(
 2229:             [("D", "mean"), ("E", "max"), ("E", "mean"), ("E", "min")]
 2230:         )
 2231:         index = MultiIndex.from_tuples(
 2232:             [("bar", "large"), ("bar", "small"), ("foo", "large"), ("foo", "small")],
 2233:             names=["A", "C"],
 2234:         )
 2235:         vals = np.array(
 2236:             [
 2237:                 [5.5, 9.0, 7.5, 6.0],
 2238:                 [5.5, 9.0, 8.5, 8.0],
 2239:                 [2.0, 5.0, 4.5, 4.0],
 2240:                 [2.33333333, 6.0, 4.33333333, 2.0],
 2241:             ]
 2242:         )
 2243:         expected = DataFrame(vals, columns=cols, index=index)
 2244:         expected[("E", "min")] = expected[("E", "min")].astype(np.int64)
 2245:         expected[("E", "max")] = expected[("E", "max")].astype(np.int64)
 2246:         tm.assert_frame_equal(table, expected)
 2247: 
 2248:     def test_pivot_table_sort_false(self):
 2249:         # GH#39143
 2250:         df = DataFrame(
 2251:             {
 2252:                 "a": ["d1", "d4", "d3"],
 2253:                 "col": ["a", "b", "c"],
 2254:                 "num": [23, 21, 34],
 2255:                 "year": ["2018", "2018", "2019"],
 2256:             }
 2257:         )
 2258:         result = df.pivot_table(
 2259:             index=["a", "col"], columns="year", values="num", aggfunc="sum", sort=False
 2260:         )
 2261:         expected = DataFrame(
 2262:             [[23, np.nan], [21, np.nan], [np.nan, 34]],
 2263:             columns=Index(["2018", "2019"], name="year"),
 2264:             index=MultiIndex.from_arrays(
 2265:                 [["d1", "d4", "d3"], ["a", "b", "c"]], names=["a", "col"]
 2266:             ),
 2267:         )
 2268:         tm.assert_frame_equal(result, expected)
 2269: 
 2270:     def test_pivot_table_nullable_margins(self):
 2271:         # GH#48681
 2272:         df = DataFrame(
 2273:             {"a": "A", "b": [1, 2], "sales": Series([10, 11], dtype="Int64")}
 2274:         )
 2275: 
 2276:         result = df.pivot_table(index="b", columns="a", margins=True, aggfunc="sum")
 2277:         expected = DataFrame(
 2278:             [[10, 10], [11, 11], [21, 21]],
 2279:             index=Index([1, 2, "All"], name="b"),
 2280:             columns=MultiIndex.from_tuples(
 2281:                 [("sales", "A"), ("sales", "All")], names=[None, "a"]
 2282:             ),
 2283:             dtype="Int64",
 2284:         )
 2285:         tm.assert_frame_equal(result, expected)
 2286: 
 2287:     def test_pivot_table_sort_false_with_multiple_values(self):
 2288:         df = DataFrame(
 2289:             {
 2290:                 "firstname": ["John", "Michael"],
 2291:                 "lastname": ["Foo", "Bar"],
 2292:                 "height": [173, 182],
 2293:                 "age": [47, 33],
 2294:             }
 2295:         )
 2296:         result = df.pivot_table(
 2297:             index=["lastname", "firstname"], values=["height", "age"], sort=False
 2298:         )
 2299:         expected = DataFrame(
 2300:             [[173.0, 47.0], [182.0, 33.0]],
 2301:             columns=["height", "age"],
 2302:             index=MultiIndex.from_tuples(
 2303:                 [("Foo", "John"), ("Bar", "Michael")],
 2304:                 names=["lastname", "firstname"],
 2305:             ),
 2306:         )
 2307:         tm.assert_frame_equal(result, expected)
 2308: 
 2309:     def test_pivot_table_with_margins_and_numeric_columns(self):
 2310:         # GH 26568
 2311:         df = DataFrame([["a", "x", 1], ["a", "y", 2], ["b", "y", 3], ["b", "z", 4]])
 2312:         df.columns = [10, 20, 30]
 2313: 
 2314:         result = df.pivot_table(
 2315:             index=10, columns=20, values=30, aggfunc="sum", fill_value=0, margins=True
 2316:         )
 2317: 
 2318:         expected = DataFrame([[1, 2, 0, 3], [0, 3, 4, 7], [1, 5, 4, 10]])
 2319:         expected.columns = ["x", "y", "z", "All"]
 2320:         expected.index = ["a", "b", "All"]
 2321:         expected.columns.name = 20
 2322:         expected.index.name = 10
 2323: 
 2324:         tm.assert_frame_equal(result, expected)
 2325: 
 2326:     @pytest.mark.parametrize("dropna", [True, False])
 2327:     def test_pivot_ea_dtype_dropna(self, dropna):
 2328:         # GH#47477
 2329:         df = DataFrame({"x": "a", "y": "b", "age": Series([20, 40], dtype="Int64")})
 2330:         result = df.pivot_table(
 2331:             index="x", columns="y", values="age", aggfunc="mean", dropna=dropna
 2332:         )
 2333:         expected = DataFrame(
 2334:             [[30]],
 2335:             index=Index(["a"], name="x"),
 2336:             columns=Index(["b"], name="y"),
 2337:             dtype="Float64",
 2338:         )
 2339:         tm.assert_frame_equal(result, expected)
 2340: 
 2341:     def test_pivot_table_datetime_warning(self):
 2342:         # GH#48683
 2343:         df = DataFrame(
 2344:             {
 2345:                 "a": "A",
 2346:                 "b": [1, 2],
 2347:                 "date": pd.Timestamp("2019-12-31"),
 2348:                 "sales": [10.0, 11],
 2349:             }
 2350:         )
 2351:         with tm.assert_produces_warning(None):
 2352:             result = df.pivot_table(
 2353:                 index=["b", "date"], columns="a", margins=True, aggfunc="sum"
 2354:             )
 2355:         expected = DataFrame(
 2356:             [[10.0, 10.0], [11.0, 11.0], [21.0, 21.0]],
 2357:             index=MultiIndex.from_arrays(
 2358:                 [
 2359:                     Index([1, 2, "All"], name="b"),
 2360:                     Index(
 2361:                         [pd.Timestamp("2019-12-31"), pd.Timestamp("2019-12-31"), ""],
 2362:                         dtype=object,
 2363:                         name="date",
 2364:                     ),
 2365:                 ]
 2366:             ),
 2367:             columns=MultiIndex.from_tuples(
 2368:                 [("sales", "A"), ("sales", "All")], names=[None, "a"]
 2369:             ),
 2370:         )
 2371:         tm.assert_frame_equal(result, expected)
 2372: 
 2373:     def test_pivot_table_with_mixed_nested_tuples(self, using_array_manager):
 2374:         # GH 50342
 2375:         df = DataFrame(
 2376:             {
 2377:                 "A": ["foo", "foo", "foo", "foo", "foo", "bar", "bar", "bar", "bar"],
 2378:                 "B": ["one", "one", "one", "two", "two", "one", "one", "two", "two"],
 2379:                 "C": [
 2380:                     "small",
 2381:                     "large",
 2382:                     "large",
 2383:                     "small",
 2384:                     "small",
 2385:                     "large",
 2386:                     "small",
 2387:                     "small",
 2388:                     "large",
 2389:                 ],
 2390:                 "D": [1, 2, 2, 3, 3, 4, 5, 6, 7],
 2391:                 "E": [2, 4, 5, 5, 6, 6, 8, 9, 9],
 2392:                 ("col5",): [
 2393:                     "foo",
 2394:                     "foo",
 2395:                     "foo",
 2396:                     "foo",
 2397:                     "foo",
 2398:                     "bar",
 2399:                     "bar",
 2400:                     "bar",
 2401:                     "bar",
 2402:                 ],
 2403:                 ("col6", 6): [
 2404:                     "one",
 2405:                     "one",
 2406:                     "one",
 2407:                     "two",
 2408:                     "two",
 2409:                     "one",
 2410:                     "one",
 2411:                     "two",
 2412:                     "two",
 2413:                 ],
 2414:                 (7, "seven"): [
 2415:                     "small",
 2416:                     "large",
 2417:                     "large",
 2418:                     "small",
 2419:                     "small",
 2420:                     "large",
 2421:                     "small",
 2422:                     "small",
 2423:                     "large",
 2424:                 ],
 2425:             }
 2426:         )
 2427:         result = pivot_table(
 2428:             df, values="D", index=["A", "B"], columns=[(7, "seven")], aggfunc="sum"
 2429:         )
 2430:         expected = DataFrame(
 2431:             [[4.0, 5.0], [7.0, 6.0], [4.0, 1.0], [np.nan, 6.0]],
 2432:             columns=Index(["large", "small"], name=(7, "seven")),
 2433:             index=MultiIndex.from_arrays(
 2434:                 [["bar", "bar", "foo", "foo"], ["one", "two"] * 2], names=["A", "B"]
 2435:             ),
 2436:         )
 2437:         if using_array_manager:
 2438:             # INFO(ArrayManager) column without NaNs can preserve int dtype
 2439:             expected["small"] = expected["small"].astype("int64")
 2440:         tm.assert_frame_equal(result, expected)
 2441: 
 2442:     def test_pivot_table_aggfunc_nunique_with_different_values(self):
 2443:         test = DataFrame(
 2444:             {
 2445:                 "a": range(10),
 2446:                 "b": range(10),
 2447:                 "c": range(10),
 2448:                 "d": range(10),
 2449:             }
 2450:         )
 2451: 
 2452:         columnval = MultiIndex.from_arrays(
 2453:             [
 2454:                 ["nunique" for i in range(10)],
 2455:                 ["c" for i in range(10)],
 2456:                 range(10),
 2457:             ],
 2458:             names=(None, None, "b"),
 2459:         )
 2460:         nparr = np.full((10, 10), np.nan)
 2461:         np.fill_diagonal(nparr, 1.0)
 2462: 
 2463:         expected = DataFrame(nparr, index=Index(range(10), name="a"), columns=columnval)
 2464:         result = test.pivot_table(
 2465:             index=[
 2466:                 "a",
 2467:             ],
 2468:             columns=[
 2469:                 "b",
 2470:             ],
 2471:             values=[
 2472:                 "c",
 2473:             ],
 2474:             aggfunc=["nunique"],
 2475:         )
 2476: 
 2477:         tm.assert_frame_equal(result, expected)
 2478: 
 2479: 
 2480: class TestPivot:
 2481:     def test_pivot(self):
 2482:         data = {
 2483:             "index": ["A", "B", "C", "C", "B", "A"],
 2484:             "columns": ["One", "One", "One", "Two", "Two", "Two"],
 2485:             "values": [1.0, 2.0, 3.0, 3.0, 2.0, 1.0],
 2486:         }
 2487: 
 2488:         frame = DataFrame(data)
 2489:         pivoted = frame.pivot(index="index", columns="columns", values="values")
 2490: 
 2491:         expected = DataFrame(
 2492:             {
 2493:                 "One": {"A": 1.0, "B": 2.0, "C": 3.0},
 2494:                 "Two": {"A": 1.0, "B": 2.0, "C": 3.0},
 2495:             }
 2496:         )
 2497: 
 2498:         expected.index.name, expected.columns.name = "index", "columns"
 2499:         tm.assert_frame_equal(pivoted, expected)
 2500: 
 2501:         # name tracking
 2502:         assert pivoted.index.name == "index"
 2503:         assert pivoted.columns.name == "columns"
 2504: 
 2505:         # don't specify values
 2506:         pivoted = frame.pivot(index="index", columns="columns")
 2507:         assert pivoted.index.name == "index"
 2508:         assert pivoted.columns.names == (None, "columns")
 2509: 
 2510:     def test_pivot_duplicates(self):
 2511:         data = DataFrame(
 2512:             {
 2513:                 "a": ["bar", "bar", "foo", "foo", "foo"],
 2514:                 "b": ["one", "two", "one", "one", "two"],
 2515:                 "c": [1.0, 2.0, 3.0, 3.0, 4.0],
 2516:             }
 2517:         )
 2518:         with pytest.raises(ValueError, match="duplicate entries"):
 2519:             data.pivot(index="a", columns="b", values="c")
 2520: 
 2521:     def test_pivot_empty(self):
 2522:         df = DataFrame(columns=["a", "b", "c"])
 2523:         result = df.pivot(index="a", columns="b", values="c")
 2524:         expected = DataFrame(index=[], columns=[])
 2525:         tm.assert_frame_equal(result, expected, check_names=False)
 2526: 
 2527:     @pytest.mark.parametrize("dtype", [object, "string"])
 2528:     def test_pivot_integer_bug(self, dtype):
 2529:         df = DataFrame(data=[("A", "1", "A1"), ("B", "2", "B2")], dtype=dtype)
 2530: 
 2531:         result = df.pivot(index=1, columns=0, values=2)
 2532:         tm.assert_index_equal(result.columns, Index(["A", "B"], name=0, dtype=dtype))
 2533: 
 2534:     def test_pivot_index_none(self):
 2535:         # GH#3962
 2536:         data = {
 2537:             "index": ["A", "B", "C", "C", "B", "A"],
 2538:             "columns": ["One", "One", "One", "Two", "Two", "Two"],
 2539:             "values": [1.0, 2.0, 3.0, 3.0, 2.0, 1.0],
 2540:         }
 2541: 
 2542:         frame = DataFrame(data).set_index("index")
 2543:         result = frame.pivot(columns="columns", values="values")
 2544:         expected = DataFrame(
 2545:             {
 2546:                 "One": {"A": 1.0, "B": 2.0, "C": 3.0},
 2547:                 "Two": {"A": 1.0, "B": 2.0, "C": 3.0},
 2548:             }
 2549:         )
 2550: 
 2551:         expected.index.name, expected.columns.name = "index", "columns"
 2552:         tm.assert_frame_equal(result, expected)
 2553: 
 2554:         # omit values
 2555:         result = frame.pivot(columns="columns")
 2556: 
 2557:         expected.columns = MultiIndex.from_tuples(
 2558:             [("values", "One"), ("values", "Two")], names=[None, "columns"]
 2559:         )
 2560:         expected.index.name = "index"
 2561:         tm.assert_frame_equal(result, expected, check_names=False)
 2562:         assert result.index.name == "index"
 2563:         assert result.columns.names == (None, "columns")
 2564:         expected.columns = expected.columns.droplevel(0)
 2565:         result = frame.pivot(columns="columns", values="values")
 2566: 
 2567:         expected.columns.name = "columns"
 2568:         tm.assert_frame_equal(result, expected)
 2569: 
 2570:     def test_pivot_index_list_values_none_immutable_args(self):
 2571:         # GH37635
 2572:         df = DataFrame(
 2573:             {
 2574:                 "lev1": [1, 1, 1, 2, 2, 2],
 2575:                 "lev2": [1, 1, 2, 1, 1, 2],
 2576:                 "lev3": [1, 2, 1, 2, 1, 2],
 2577:                 "lev4": [1, 2, 3, 4, 5, 6],
 2578:                 "values": [0, 1, 2, 3, 4, 5],
 2579:             }
 2580:         )
 2581:         index = ["lev1", "lev2"]
 2582:         columns = ["lev3"]
 2583:         result = df.pivot(index=index, columns=columns)
 2584: 
 2585:         expected = DataFrame(
 2586:             np.array(
 2587:                 [
 2588:                     [1.0, 2.0, 0.0, 1.0],
 2589:                     [3.0, np.nan, 2.0, np.nan],
 2590:                     [5.0, 4.0, 4.0, 3.0],
 2591:                     [np.nan, 6.0, np.nan, 5.0],
 2592:                 ]
 2593:             ),
 2594:             index=MultiIndex.from_arrays(
 2595:                 [(1, 1, 2, 2), (1, 2, 1, 2)], names=["lev1", "lev2"]
 2596:             ),
 2597:             columns=MultiIndex.from_arrays(
 2598:                 [("lev4", "lev4", "values", "values"), (1, 2, 1, 2)],
 2599:                 names=[None, "lev3"],
 2600:             ),
 2601:         )
 2602: 
 2603:         tm.assert_frame_equal(result, expected)
 2604: 
 2605:         assert index == ["lev1", "lev2"]
 2606:         assert columns == ["lev3"]
 2607: 
 2608:     def test_pivot_columns_not_given(self):
 2609:         # GH#48293
 2610:         df = DataFrame({"a": [1], "b": 1})
 2611:         with pytest.raises(TypeError, match="missing 1 required keyword-only argument"):
 2612:             df.pivot()  # pylint: disable=missing-kwoa
 2613: 
 2614:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="None is cast to NaN")
 2615:     def test_pivot_columns_is_none(self):
 2616:         # GH#48293
 2617:         df = DataFrame({None: [1], "b": 2, "c": 3})
 2618:         result = df.pivot(columns=None)
 2619:         expected = DataFrame({("b", 1): [2], ("c", 1): 3})
 2620:         tm.assert_frame_equal(result, expected)
 2621: 
 2622:         result = df.pivot(columns=None, index="b")
 2623:         expected = DataFrame({("c", 1): 3}, index=Index([2], name="b"))
 2624:         tm.assert_frame_equal(result, expected)
 2625: 
 2626:         result = df.pivot(columns=None, index="b", values="c")
 2627:         expected = DataFrame({1: 3}, index=Index([2], name="b"))
 2628:         tm.assert_frame_equal(result, expected)
 2629: 
 2630:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="None is cast to NaN")
 2631:     def test_pivot_index_is_none(self):
 2632:         # GH#48293
 2633:         df = DataFrame({None: [1], "b": 2, "c": 3})
 2634: 
 2635:         result = df.pivot(columns="b", index=None)
 2636:         expected = DataFrame({("c", 2): 3}, index=[1])
 2637:         expected.columns.names = [None, "b"]
 2638:         tm.assert_frame_equal(result, expected)
 2639: 
 2640:         result = df.pivot(columns="b", index=None, values="c")
 2641:         expected = DataFrame(3, index=[1], columns=Index([2], name="b"))
 2642:         tm.assert_frame_equal(result, expected)
 2643: 
 2644:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="None is cast to NaN")
 2645:     def test_pivot_values_is_none(self):
 2646:         # GH#48293
 2647:         df = DataFrame({None: [1], "b": 2, "c": 3})
 2648: 
 2649:         result = df.pivot(columns="b", index="c", values=None)
 2650:         expected = DataFrame(
 2651:             1, index=Index([3], name="c"), columns=Index([2], name="b")
 2652:         )
 2653:         tm.assert_frame_equal(result, expected)
 2654: 
 2655:         result = df.pivot(columns="b", values=None)
 2656:         expected = DataFrame(1, index=[0], columns=Index([2], name="b"))
 2657:         tm.assert_frame_equal(result, expected)
 2658: 
 2659:     def test_pivot_not_changing_index_name(self):
 2660:         # GH#52692
 2661:         df = DataFrame({"one": ["a"], "two": 0, "three": 1})
 2662:         expected = df.copy(deep=True)
 2663:         df.pivot(index="one", columns="two", values="three")
 2664:         tm.assert_frame_equal(df, expected)
 2665: 
 2666:     def test_pivot_table_empty_dataframe_correct_index(self):
 2667:         # GH 21932
 2668:         df = DataFrame([], columns=["a", "b", "value"])
 2669:         pivot = df.pivot_table(index="a", columns="b", values="value", aggfunc="count")
 2670: 
 2671:         expected = Index([], dtype="object", name="b")
 2672:         tm.assert_index_equal(pivot.columns, expected)
 2673: 
 2674:     def test_pivot_table_handles_explicit_datetime_types(self):
 2675:         # GH#43574
 2676:         df = DataFrame(
 2677:             [
 2678:                 {"a": "x", "date_str": "2023-01-01", "amount": 1},
 2679:                 {"a": "y", "date_str": "2023-01-02", "amount": 2},
 2680:                 {"a": "z", "date_str": "2023-01-03", "amount": 3},
 2681:             ]
 2682:         )
 2683:         df["date"] = pd.to_datetime(df["date_str"])
 2684: 
 2685:         with tm.assert_produces_warning(False):
 2686:             pivot = df.pivot_table(
 2687:                 index=["a", "date"], values=["amount"], aggfunc="sum", margins=True
 2688:             )
 2689: 
 2690:         expected = MultiIndex.from_tuples(
 2691:             [
 2692:                 ("x", datetime.strptime("2023-01-01 00:00:00", "%Y-%m-%d %H:%M:%S")),
 2693:                 ("y", datetime.strptime("2023-01-02 00:00:00", "%Y-%m-%d %H:%M:%S")),
 2694:                 ("z", datetime.strptime("2023-01-03 00:00:00", "%Y-%m-%d %H:%M:%S")),
 2695:                 ("All", ""),
 2696:             ],
 2697:             names=["a", "date"],
 2698:         )
 2699:         tm.assert_index_equal(pivot.index, expected)
 2700: 
 2701:     def test_pivot_table_with_margins_and_numeric_column_names(self):
 2702:         # GH#26568
 2703:         df = DataFrame([["a", "x", 1], ["a", "y", 2], ["b", "y", 3], ["b", "z", 4]])
 2704: 
 2705:         result = df.pivot_table(
 2706:             index=0, columns=1, values=2, aggfunc="sum", fill_value=0, margins=True
 2707:         )
 2708: 
 2709:         expected = DataFrame(
 2710:             [[1, 2, 0, 3], [0, 3, 4, 7], [1, 5, 4, 10]],
 2711:             columns=Index(["x", "y", "z", "All"], name=1),
 2712:             index=Index(["a", "b", "All"], name=0),
 2713:         )
 2714:         tm.assert_frame_equal(result, expected)
