    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     Index,
   10:     date_range,
   11:     lreshape,
   12:     melt,
   13:     wide_to_long,
   14: )
   15: import pandas._testing as tm
   16: 
   17: 
   18: @pytest.fixture
   19: def df():
   20:     res = DataFrame(
   21:         np.random.default_rng(2).standard_normal((10, 4)),
   22:         columns=Index(list("ABCD"), dtype=object),
   23:         index=date_range("2000-01-01", periods=10, freq="B"),
   24:     )
   25:     res["id1"] = (res["A"] > 0).astype(np.int64)
   26:     res["id2"] = (res["B"] > 0).astype(np.int64)
   27:     return res
   28: 
   29: 
   30: @pytest.fixture
   31: def df1():
   32:     res = DataFrame(
   33:         [
   34:             [1.067683, -1.110463, 0.20867],
   35:             [-1.321405, 0.368915, -1.055342],
   36:             [-0.807333, 0.08298, -0.873361],
   37:         ]
   38:     )
   39:     res.columns = [list("ABC"), list("abc")]
   40:     res.columns.names = ["CAP", "low"]
   41:     return res
   42: 
   43: 
   44: @pytest.fixture
   45: def var_name():
   46:     return "var"
   47: 
   48: 
   49: @pytest.fixture
   50: def value_name():
   51:     return "val"
   52: 
   53: 
   54: class TestMelt:
   55:     def test_top_level_method(self, df):
   56:         result = melt(df)
   57:         assert result.columns.tolist() == ["variable", "value"]
   58: 
   59:     def test_method_signatures(self, df, df1, var_name, value_name):
   60:         tm.assert_frame_equal(df.melt(), melt(df))
   61: 
   62:         tm.assert_frame_equal(
   63:             df.melt(id_vars=["id1", "id2"], value_vars=["A", "B"]),
   64:             melt(df, id_vars=["id1", "id2"], value_vars=["A", "B"]),
   65:         )
   66: 
   67:         tm.assert_frame_equal(
   68:             df.melt(var_name=var_name, value_name=value_name),
   69:             melt(df, var_name=var_name, value_name=value_name),
   70:         )
   71: 
   72:         tm.assert_frame_equal(df1.melt(col_level=0), melt(df1, col_level=0))
   73: 
   74:     def test_default_col_names(self, df):
   75:         result = df.melt()
   76:         assert result.columns.tolist() == ["variable", "value"]
   77: 
   78:         result1 = df.melt(id_vars=["id1"])
   79:         assert result1.columns.tolist() == ["id1", "variable", "value"]
   80: 
   81:         result2 = df.melt(id_vars=["id1", "id2"])
   82:         assert result2.columns.tolist() == ["id1", "id2", "variable", "value"]
   83: 
   84:     def test_value_vars(self, df):
   85:         result3 = df.melt(id_vars=["id1", "id2"], value_vars="A")
   86:         assert len(result3) == 10
   87: 
   88:         result4 = df.melt(id_vars=["id1", "id2"], value_vars=["A", "B"])
   89:         expected4 = DataFrame(
   90:             {
   91:                 "id1": df["id1"].tolist() * 2,
   92:                 "id2": df["id2"].tolist() * 2,
   93:                 "variable": ["A"] * 10 + ["B"] * 10,
   94:                 "value": (df["A"].tolist() + df["B"].tolist()),
   95:             },
   96:             columns=["id1", "id2", "variable", "value"],
   97:         )
   98:         tm.assert_frame_equal(result4, expected4)
   99: 
  100:     @pytest.mark.parametrize("type_", (tuple, list, np.array))
  101:     def test_value_vars_types(self, type_, df):
  102:         # GH 15348
  103:         expected = DataFrame(
  104:             {
  105:                 "id1": df["id1"].tolist() * 2,
  106:                 "id2": df["id2"].tolist() * 2,
  107:                 "variable": ["A"] * 10 + ["B"] * 10,
  108:                 "value": (df["A"].tolist() + df["B"].tolist()),
  109:             },
  110:             columns=["id1", "id2", "variable", "value"],
  111:         )
  112:         result = df.melt(id_vars=["id1", "id2"], value_vars=type_(("A", "B")))
  113:         tm.assert_frame_equal(result, expected)
  114: 
  115:     def test_vars_work_with_multiindex(self, df1):
  116:         expected = DataFrame(
  117:             {
  118:                 ("A", "a"): df1[("A", "a")],
  119:                 "CAP": ["B"] * len(df1),
  120:                 "low": ["b"] * len(df1),
  121:                 "value": df1[("B", "b")],
  122:             },
  123:             columns=[("A", "a"), "CAP", "low", "value"],
  124:         )
  125: 
  126:         result = df1.melt(id_vars=[("A", "a")], value_vars=[("B", "b")])
  127:         tm.assert_frame_equal(result, expected)
  128: 
  129:     @pytest.mark.parametrize(
  130:         "id_vars, value_vars, col_level, expected",
  131:         [
  132:             (
  133:                 ["A"],
  134:                 ["B"],
  135:                 0,
  136:                 DataFrame(
  137:                     {
  138:                         "A": {0: 1.067683, 1: -1.321405, 2: -0.807333},
  139:                         "CAP": {0: "B", 1: "B", 2: "B"},
  140:                         "value": {0: -1.110463, 1: 0.368915, 2: 0.08298},
  141:                     }
  142:                 ),
  143:             ),
  144:             (
  145:                 ["a"],
  146:                 ["b"],
  147:                 1,
  148:                 DataFrame(
  149:                     {
  150:                         "a": {0: 1.067683, 1: -1.321405, 2: -0.807333},
  151:                         "low": {0: "b", 1: "b", 2: "b"},
  152:                         "value": {0: -1.110463, 1: 0.368915, 2: 0.08298},
  153:                     }
  154:                 ),
  155:             ),
  156:         ],
  157:     )
  158:     def test_single_vars_work_with_multiindex(
  159:         self, id_vars, value_vars, col_level, expected, df1
  160:     ):
  161:         result = df1.melt(id_vars, value_vars, col_level=col_level)
  162:         tm.assert_frame_equal(result, expected)
  163: 
  164:     @pytest.mark.parametrize(
  165:         "id_vars, value_vars",
  166:         [
  167:             [("A", "a"), [("B", "b")]],
  168:             [[("A", "a")], ("B", "b")],
  169:             [("A", "a"), ("B", "b")],
  170:         ],
  171:     )
  172:     def test_tuple_vars_fail_with_multiindex(self, id_vars, value_vars, df1):
  173:         # melt should fail with an informative error message if
  174:         # the columns have a MultiIndex and a tuple is passed
  175:         # for id_vars or value_vars.
  176:         msg = r"(id|value)_vars must be a list of tuples when columns are a MultiIndex"
  177:         with pytest.raises(ValueError, match=msg):
  178:             df1.melt(id_vars=id_vars, value_vars=value_vars)
  179: 
  180:     def test_custom_var_name(self, df, var_name):
  181:         result5 = df.melt(var_name=var_name)
  182:         assert result5.columns.tolist() == ["var", "value"]
  183: 
  184:         result6 = df.melt(id_vars=["id1"], var_name=var_name)
  185:         assert result6.columns.tolist() == ["id1", "var", "value"]
  186: 
  187:         result7 = df.melt(id_vars=["id1", "id2"], var_name=var_name)
  188:         assert result7.columns.tolist() == ["id1", "id2", "var", "value"]
  189: 
  190:         result8 = df.melt(id_vars=["id1", "id2"], value_vars="A", var_name=var_name)
  191:         assert result8.columns.tolist() == ["id1", "id2", "var", "value"]
  192: 
  193:         result9 = df.melt(
  194:             id_vars=["id1", "id2"], value_vars=["A", "B"], var_name=var_name
  195:         )
  196:         expected9 = DataFrame(
  197:             {
  198:                 "id1": df["id1"].tolist() * 2,
  199:                 "id2": df["id2"].tolist() * 2,
  200:                 var_name: ["A"] * 10 + ["B"] * 10,
  201:                 "value": (df["A"].tolist() + df["B"].tolist()),
  202:             },
  203:             columns=["id1", "id2", var_name, "value"],
  204:         )
  205:         tm.assert_frame_equal(result9, expected9)
  206: 
  207:     def test_custom_value_name(self, df, value_name):
  208:         result10 = df.melt(value_name=value_name)
  209:         assert result10.columns.tolist() == ["variable", "val"]
  210: 
  211:         result11 = df.melt(id_vars=["id1"], value_name=value_name)
  212:         assert result11.columns.tolist() == ["id1", "variable", "val"]
  213: 
  214:         result12 = df.melt(id_vars=["id1", "id2"], value_name=value_name)
  215:         assert result12.columns.tolist() == ["id1", "id2", "variable", "val"]
  216: 
  217:         result13 = df.melt(
  218:             id_vars=["id1", "id2"], value_vars="A", value_name=value_name
  219:         )
  220:         assert result13.columns.tolist() == ["id1", "id2", "variable", "val"]
  221: 
  222:         result14 = df.melt(
  223:             id_vars=["id1", "id2"], value_vars=["A", "B"], value_name=value_name
  224:         )
  225:         expected14 = DataFrame(
  226:             {
  227:                 "id1": df["id1"].tolist() * 2,
  228:                 "id2": df["id2"].tolist() * 2,
  229:                 "variable": ["A"] * 10 + ["B"] * 10,
  230:                 value_name: (df["A"].tolist() + df["B"].tolist()),
  231:             },
  232:             columns=["id1", "id2", "variable", value_name],
  233:         )
  234:         tm.assert_frame_equal(result14, expected14)
  235: 
  236:     def test_custom_var_and_value_name(self, df, value_name, var_name):
  237:         result15 = df.melt(var_name=var_name, value_name=value_name)
  238:         assert result15.columns.tolist() == ["var", "val"]
  239: 
  240:         result16 = df.melt(id_vars=["id1"], var_name=var_name, value_name=value_name)
  241:         assert result16.columns.tolist() == ["id1", "var", "val"]
  242: 
  243:         result17 = df.melt(
  244:             id_vars=["id1", "id2"], var_name=var_name, value_name=value_name
  245:         )
  246:         assert result17.columns.tolist() == ["id1", "id2", "var", "val"]
  247: 
  248:         result18 = df.melt(
  249:             id_vars=["id1", "id2"],
  250:             value_vars="A",
  251:             var_name=var_name,
  252:             value_name=value_name,
  253:         )
  254:         assert result18.columns.tolist() == ["id1", "id2", "var", "val"]
  255: 
  256:         result19 = df.melt(
  257:             id_vars=["id1", "id2"],
  258:             value_vars=["A", "B"],
  259:             var_name=var_name,
  260:             value_name=value_name,
  261:         )
  262:         expected19 = DataFrame(
  263:             {
  264:                 "id1": df["id1"].tolist() * 2,
  265:                 "id2": df["id2"].tolist() * 2,
  266:                 var_name: ["A"] * 10 + ["B"] * 10,
  267:                 value_name: (df["A"].tolist() + df["B"].tolist()),
  268:             },
  269:             columns=["id1", "id2", var_name, value_name],
  270:         )
  271:         tm.assert_frame_equal(result19, expected19)
  272: 
  273:         df20 = df.copy()
  274:         df20.columns.name = "foo"
  275:         result20 = df20.melt()
  276:         assert result20.columns.tolist() == ["foo", "value"]
  277: 
  278:     @pytest.mark.parametrize("col_level", [0, "CAP"])
  279:     def test_col_level(self, col_level, df1):
  280:         res = df1.melt(col_level=col_level)
  281:         assert res.columns.tolist() == ["CAP", "value"]
  282: 
  283:     def test_multiindex(self, df1):
  284:         res = df1.melt()
  285:         assert res.columns.tolist() == ["CAP", "low", "value"]
  286: 
  287:     @pytest.mark.parametrize(
  288:         "col",
  289:         [
  290:             pd.Series(date_range("2010", periods=5, tz="US/Pacific")),
  291:             pd.Series(["a", "b", "c", "a", "d"], dtype="category"),
  292:             pd.Series([0, 1, 0, 0, 0]),
  293:         ],
  294:     )
  295:     def test_pandas_dtypes(self, col):
  296:         # GH 15785
  297:         df = DataFrame(
  298:             {"klass": range(5), "col": col, "attr1": [1, 0, 0, 0, 0], "attr2": col}
  299:         )
  300:         expected_value = pd.concat([pd.Series([1, 0, 0, 0, 0]), col], ignore_index=True)
  301:         result = melt(
  302:             df, id_vars=["klass", "col"], var_name="attribute", value_name="value"
  303:         )
  304:         expected = DataFrame(
  305:             {
  306:                 0: list(range(5)) * 2,
  307:                 1: pd.concat([col] * 2, ignore_index=True),
  308:                 2: ["attr1"] * 5 + ["attr2"] * 5,
  309:                 3: expected_value,
  310:             }
  311:         )
  312:         expected.columns = ["klass", "col", "attribute", "value"]
  313:         tm.assert_frame_equal(result, expected)
  314: 
  315:     def test_preserve_category(self):
  316:         # GH 15853
  317:         data = DataFrame({"A": [1, 2], "B": pd.Categorical(["X", "Y"])})
  318:         result = melt(data, ["B"], ["A"])
  319:         expected = DataFrame(
  320:             {"B": pd.Categorical(["X", "Y"]), "variable": ["A", "A"], "value": [1, 2]}
  321:         )
  322: 
  323:         tm.assert_frame_equal(result, expected)
  324: 
  325:     def test_melt_missing_columns_raises(self):
  326:         # GH-23575
  327:         # This test is to ensure that pandas raises an error if melting is
  328:         # attempted with column names absent from the dataframe
  329: 
  330:         # Generate data
  331:         df = DataFrame(
  332:             np.random.default_rng(2).standard_normal((5, 4)), columns=list("abcd")
  333:         )
  334: 
  335:         # Try to melt with missing `value_vars` column name
  336:         msg = "The following id_vars or value_vars are not present in the DataFrame:"
  337:         with pytest.raises(KeyError, match=msg):
  338:             df.melt(["a", "b"], ["C", "d"])
  339: 
  340:         # Try to melt with missing `id_vars` column name
  341:         with pytest.raises(KeyError, match=msg):
  342:             df.melt(["A", "b"], ["c", "d"])
  343: 
  344:         # Multiple missing
  345:         with pytest.raises(
  346:             KeyError,
  347:             match=msg,
  348:         ):
  349:             df.melt(["a", "b", "not_here", "or_there"], ["c", "d"])
  350: 
  351:         # Multiindex melt fails if column is missing from multilevel melt
  352:         multi = df.copy()
  353:         multi.columns = [list("ABCD"), list("abcd")]
  354:         with pytest.raises(KeyError, match=msg):
  355:             multi.melt([("E", "a")], [("B", "b")])
  356:         # Multiindex fails if column is missing from single level melt
  357:         with pytest.raises(KeyError, match=msg):
  358:             multi.melt(["A"], ["F"], col_level=0)
  359: 
  360:     def test_melt_mixed_int_str_id_vars(self):
  361:         # GH 29718
  362:         df = DataFrame({0: ["foo"], "a": ["bar"], "b": [1], "d": [2]})
  363:         result = melt(df, id_vars=[0, "a"], value_vars=["b", "d"])
  364:         expected = DataFrame(
  365:             {0: ["foo"] * 2, "a": ["bar"] * 2, "variable": list("bd"), "value": [1, 2]}
  366:         )
  367:         tm.assert_frame_equal(result, expected)
  368: 
  369:     def test_melt_mixed_int_str_value_vars(self):
  370:         # GH 29718
  371:         df = DataFrame({0: ["foo"], "a": ["bar"]})
  372:         result = melt(df, value_vars=[0, "a"])
  373:         expected = DataFrame({"variable": [0, "a"], "value": ["foo", "bar"]})
  374:         tm.assert_frame_equal(result, expected)
  375: 
  376:     def test_ignore_index(self):
  377:         # GH 17440
  378:         df = DataFrame({"foo": [0], "bar": [1]}, index=["first"])
  379:         result = melt(df, ignore_index=False)
  380:         expected = DataFrame(
  381:             {"variable": ["foo", "bar"], "value": [0, 1]}, index=["first", "first"]
  382:         )
  383:         tm.assert_frame_equal(result, expected)
  384: 
  385:     def test_ignore_multiindex(self):
  386:         # GH 17440
  387:         index = pd.MultiIndex.from_tuples(
  388:             [("first", "second"), ("first", "third")], names=["baz", "foobar"]
  389:         )
  390:         df = DataFrame({"foo": [0, 1], "bar": [2, 3]}, index=index)
  391:         result = melt(df, ignore_index=False)
  392: 
  393:         expected_index = pd.MultiIndex.from_tuples(
  394:             [("first", "second"), ("first", "third")] * 2, names=["baz", "foobar"]
  395:         )
  396:         expected = DataFrame(
  397:             {"variable": ["foo"] * 2 + ["bar"] * 2, "value": [0, 1, 2, 3]},
  398:             index=expected_index,
  399:         )
  400: 
  401:         tm.assert_frame_equal(result, expected)
  402: 
  403:     def test_ignore_index_name_and_type(self):
  404:         # GH 17440
  405:         index = Index(["foo", "bar"], dtype="category", name="baz")
  406:         df = DataFrame({"x": [0, 1], "y": [2, 3]}, index=index)
  407:         result = melt(df, ignore_index=False)
  408: 
  409:         expected_index = Index(["foo", "bar"] * 2, dtype="category", name="baz")
  410:         expected = DataFrame(
  411:             {"variable": ["x", "x", "y", "y"], "value": [0, 1, 2, 3]},
  412:             index=expected_index,
  413:         )
  414: 
  415:         tm.assert_frame_equal(result, expected)
  416: 
  417:     def test_melt_with_duplicate_columns(self):
  418:         # GH#41951
  419:         df = DataFrame([["id", 2, 3]], columns=["a", "b", "b"])
  420:         result = df.melt(id_vars=["a"], value_vars=["b"])
  421:         expected = DataFrame(
  422:             [["id", "b", 2], ["id", "b", 3]], columns=["a", "variable", "value"]
  423:         )
  424:         tm.assert_frame_equal(result, expected)
  425: 
  426:     @pytest.mark.parametrize("dtype", ["Int8", "Int64"])
  427:     def test_melt_ea_dtype(self, dtype):
  428:         # GH#41570
  429:         df = DataFrame(
  430:             {
  431:                 "a": pd.Series([1, 2], dtype="Int8"),
  432:                 "b": pd.Series([3, 4], dtype=dtype),
  433:             }
  434:         )
  435:         result = df.melt()
  436:         expected = DataFrame(
  437:             {
  438:                 "variable": ["a", "a", "b", "b"],
  439:                 "value": pd.Series([1, 2, 3, 4], dtype=dtype),
  440:             }
  441:         )
  442:         tm.assert_frame_equal(result, expected)
  443: 
  444:     def test_melt_ea_columns(self):
  445:         # GH 54297
  446:         df = DataFrame(
  447:             {
  448:                 "A": {0: "a", 1: "b", 2: "c"},
  449:                 "B": {0: 1, 1: 3, 2: 5},
  450:                 "C": {0: 2, 1: 4, 2: 6},
  451:             }
  452:         )
  453:         df.columns = df.columns.astype("string[python]")
  454:         result = df.melt(id_vars=["A"], value_vars=["B"])
  455:         expected = DataFrame(
  456:             {
  457:                 "A": list("abc"),
  458:                 "variable": pd.Series(["B"] * 3, dtype="string[python]"),
  459:                 "value": [1, 3, 5],
  460:             }
  461:         )
  462:         tm.assert_frame_equal(result, expected)
  463: 
  464:     def test_melt_preserves_datetime(self):
  465:         df = DataFrame(
  466:             data=[
  467:                 {
  468:                     "type": "A0",
  469:                     "start_date": pd.Timestamp("2023/03/01", tz="Asia/Tokyo"),
  470:                     "end_date": pd.Timestamp("2023/03/10", tz="Asia/Tokyo"),
  471:                 },
  472:                 {
  473:                     "type": "A1",
  474:                     "start_date": pd.Timestamp("2023/03/01", tz="Asia/Tokyo"),
  475:                     "end_date": pd.Timestamp("2023/03/11", tz="Asia/Tokyo"),
  476:                 },
  477:             ],
  478:             index=["aaaa", "bbbb"],
  479:         )
  480:         result = df.melt(
  481:             id_vars=["type"],
  482:             value_vars=["start_date", "end_date"],
  483:             var_name="start/end",
  484:             value_name="date",
  485:         )
  486:         expected = DataFrame(
  487:             {
  488:                 "type": {0: "A0", 1: "A1", 2: "A0", 3: "A1"},
  489:                 "start/end": {
  490:                     0: "start_date",
  491:                     1: "start_date",
  492:                     2: "end_date",
  493:                     3: "end_date",
  494:                 },
  495:                 "date": {
  496:                     0: pd.Timestamp("2023-03-01 00:00:00+0900", tz="Asia/Tokyo"),
  497:                     1: pd.Timestamp("2023-03-01 00:00:00+0900", tz="Asia/Tokyo"),
  498:                     2: pd.Timestamp("2023-03-10 00:00:00+0900", tz="Asia/Tokyo"),
  499:                     3: pd.Timestamp("2023-03-11 00:00:00+0900", tz="Asia/Tokyo"),
  500:                 },
  501:             }
  502:         )
  503:         tm.assert_frame_equal(result, expected)
  504: 
  505:     def test_melt_allows_non_scalar_id_vars(self):
  506:         df = DataFrame(
  507:             data={"a": [1, 2, 3], "b": [4, 5, 6]},
  508:             index=["11", "22", "33"],
  509:         )
  510:         result = df.melt(
  511:             id_vars="a",
  512:             var_name=0,
  513:             value_name=1,
  514:         )
  515:         expected = DataFrame({"a": [1, 2, 3], 0: ["b"] * 3, 1: [4, 5, 6]})
  516:         tm.assert_frame_equal(result, expected)
  517: 
  518:     def test_melt_allows_non_string_var_name(self):
  519:         df = DataFrame(
  520:             data={"a": [1, 2, 3], "b": [4, 5, 6]},
  521:             index=["11", "22", "33"],
  522:         )
  523:         result = df.melt(
  524:             id_vars=["a"],
  525:             var_name=0,
  526:             value_name=1,
  527:         )
  528:         expected = DataFrame({"a": [1, 2, 3], 0: ["b"] * 3, 1: [4, 5, 6]})
  529:         tm.assert_frame_equal(result, expected)
  530: 
  531:     def test_melt_non_scalar_var_name_raises(self):
  532:         df = DataFrame(
  533:             data={"a": [1, 2, 3], "b": [4, 5, 6]},
  534:             index=["11", "22", "33"],
  535:         )
  536:         with pytest.raises(ValueError, match=r".* must be a scalar."):
  537:             df.melt(id_vars=["a"], var_name=[1, 2])
  538: 
  539: 
  540: class TestLreshape:
  541:     def test_pairs(self):
  542:         data = {
  543:             "birthdt": [
  544:                 "08jan2009",
  545:                 "20dec2008",
  546:                 "30dec2008",
  547:                 "21dec2008",
  548:                 "11jan2009",
  549:             ],
  550:             "birthwt": [1766, 3301, 1454, 3139, 4133],
  551:             "id": [101, 102, 103, 104, 105],
  552:             "sex": ["Male", "Female", "Female", "Female", "Female"],
  553:             "visitdt1": [
  554:                 "11jan2009",
  555:                 "22dec2008",
  556:                 "04jan2009",
  557:                 "29dec2008",
  558:                 "20jan2009",
  559:             ],
  560:             "visitdt2": ["21jan2009", np.nan, "22jan2009", "31dec2008", "03feb2009"],
  561:             "visitdt3": ["05feb2009", np.nan, np.nan, "02jan2009", "15feb2009"],
  562:             "wt1": [1823, 3338, 1549, 3298, 4306],
  563:             "wt2": [2011.0, np.nan, 1892.0, 3338.0, 4575.0],
  564:             "wt3": [2293.0, np.nan, np.nan, 3377.0, 4805.0],
  565:         }
  566: 
  567:         df = DataFrame(data)
  568: 
  569:         spec = {
  570:             "visitdt": [f"visitdt{i:d}" for i in range(1, 4)],
  571:             "wt": [f"wt{i:d}" for i in range(1, 4)],
  572:         }
  573:         result = lreshape(df, spec)
  574: 
  575:         exp_data = {
  576:             "birthdt": [
  577:                 "08jan2009",
  578:                 "20dec2008",
  579:                 "30dec2008",
  580:                 "21dec2008",
  581:                 "11jan2009",
  582:                 "08jan2009",
  583:                 "30dec2008",
  584:                 "21dec2008",
  585:                 "11jan2009",
  586:                 "08jan2009",
  587:                 "21dec2008",
  588:                 "11jan2009",
  589:             ],
  590:             "birthwt": [
  591:                 1766,
  592:                 3301,
  593:                 1454,
  594:                 3139,
  595:                 4133,
  596:                 1766,
  597:                 1454,
  598:                 3139,
  599:                 4133,
  600:                 1766,
  601:                 3139,
  602:                 4133,
  603:             ],
  604:             "id": [101, 102, 103, 104, 105, 101, 103, 104, 105, 101, 104, 105],
  605:             "sex": [
  606:                 "Male",
  607:                 "Female",
  608:                 "Female",
  609:                 "Female",
  610:                 "Female",
  611:                 "Male",
  612:                 "Female",
  613:                 "Female",
  614:                 "Female",
  615:                 "Male",
  616:                 "Female",
  617:                 "Female",
  618:             ],
  619:             "visitdt": [
  620:                 "11jan2009",
  621:                 "22dec2008",
  622:                 "04jan2009",
  623:                 "29dec2008",
  624:                 "20jan2009",
  625:                 "21jan2009",
  626:                 "22jan2009",
  627:                 "31dec2008",
  628:                 "03feb2009",
  629:                 "05feb2009",
  630:                 "02jan2009",
  631:                 "15feb2009",
  632:             ],
  633:             "wt": [
  634:                 1823.0,
  635:                 3338.0,
  636:                 1549.0,
  637:                 3298.0,
  638:                 4306.0,
  639:                 2011.0,
  640:                 1892.0,
  641:                 3338.0,
  642:                 4575.0,
  643:                 2293.0,
  644:                 3377.0,
  645:                 4805.0,
  646:             ],
  647:         }
  648:         exp = DataFrame(exp_data, columns=result.columns)
  649:         tm.assert_frame_equal(result, exp)
  650: 
  651:         result = lreshape(df, spec, dropna=False)
  652:         exp_data = {
  653:             "birthdt": [
  654:                 "08jan2009",
  655:                 "20dec2008",
  656:                 "30dec2008",
  657:                 "21dec2008",
  658:                 "11jan2009",
  659:                 "08jan2009",
  660:                 "20dec2008",
  661:                 "30dec2008",
  662:                 "21dec2008",
  663:                 "11jan2009",
  664:                 "08jan2009",
  665:                 "20dec2008",
  666:                 "30dec2008",
  667:                 "21dec2008",
  668:                 "11jan2009",
  669:             ],
  670:             "birthwt": [
  671:                 1766,
  672:                 3301,
  673:                 1454,
  674:                 3139,
  675:                 4133,
  676:                 1766,
  677:                 3301,
  678:                 1454,
  679:                 3139,
  680:                 4133,
  681:                 1766,
  682:                 3301,
  683:                 1454,
  684:                 3139,
  685:                 4133,
  686:             ],
  687:             "id": [
  688:                 101,
  689:                 102,
  690:                 103,
  691:                 104,
  692:                 105,
  693:                 101,
  694:                 102,
  695:                 103,
  696:                 104,
  697:                 105,
  698:                 101,
  699:                 102,
  700:                 103,
  701:                 104,
  702:                 105,
  703:             ],
  704:             "sex": [
  705:                 "Male",
  706:                 "Female",
  707:                 "Female",
  708:                 "Female",
  709:                 "Female",
  710:                 "Male",
  711:                 "Female",
  712:                 "Female",
  713:                 "Female",
  714:                 "Female",
  715:                 "Male",
  716:                 "Female",
  717:                 "Female",
  718:                 "Female",
  719:                 "Female",
  720:             ],
  721:             "visitdt": [
  722:                 "11jan2009",
  723:                 "22dec2008",
  724:                 "04jan2009",
  725:                 "29dec2008",
  726:                 "20jan2009",
  727:                 "21jan2009",
  728:                 np.nan,
  729:                 "22jan2009",
  730:                 "31dec2008",
  731:                 "03feb2009",
  732:                 "05feb2009",
  733:                 np.nan,
  734:                 np.nan,
  735:                 "02jan2009",
  736:                 "15feb2009",
  737:             ],
  738:             "wt": [
  739:                 1823.0,
  740:                 3338.0,
  741:                 1549.0,
  742:                 3298.0,
  743:                 4306.0,
  744:                 2011.0,
  745:                 np.nan,
  746:                 1892.0,
  747:                 3338.0,
  748:                 4575.0,
  749:                 2293.0,
  750:                 np.nan,
  751:                 np.nan,
  752:                 3377.0,
  753:                 4805.0,
  754:             ],
  755:         }
  756:         exp = DataFrame(exp_data, columns=result.columns)
  757:         tm.assert_frame_equal(result, exp)
  758: 
  759:         spec = {
  760:             "visitdt": [f"visitdt{i:d}" for i in range(1, 3)],
  761:             "wt": [f"wt{i:d}" for i in range(1, 4)],
  762:         }
  763:         msg = "All column lists must be same length"
  764:         with pytest.raises(ValueError, match=msg):
  765:             lreshape(df, spec)
  766: 
  767: 
  768: class TestWideToLong:
  769:     def test_simple(self):
  770:         x = np.random.default_rng(2).standard_normal(3)
  771:         df = DataFrame(
  772:             {
  773:                 "A1970": {0: "a", 1: "b", 2: "c"},
  774:                 "A1980": {0: "d", 1: "e", 2: "f"},
  775:                 "B1970": {0: 2.5, 1: 1.2, 2: 0.7},
  776:                 "B1980": {0: 3.2, 1: 1.3, 2: 0.1},
  777:                 "X": dict(zip(range(3), x)),
  778:             }
  779:         )
  780:         df["id"] = df.index
  781:         exp_data = {
  782:             "X": x.tolist() + x.tolist(),
  783:             "A": ["a", "b", "c", "d", "e", "f"],
  784:             "B": [2.5, 1.2, 0.7, 3.2, 1.3, 0.1],
  785:             "year": [1970, 1970, 1970, 1980, 1980, 1980],
  786:             "id": [0, 1, 2, 0, 1, 2],
  787:         }
  788:         expected = DataFrame(exp_data)
  789:         expected = expected.set_index(["id", "year"])[["X", "A", "B"]]
  790:         result = wide_to_long(df, ["A", "B"], i="id", j="year")
  791:         tm.assert_frame_equal(result, expected)
  792: 
  793:     def test_stubs(self):
  794:         # GH9204 wide_to_long call should not modify 'stubs' list
  795:         df = DataFrame([[0, 1, 2, 3, 8], [4, 5, 6, 7, 9]])
  796:         df.columns = ["id", "inc1", "inc2", "edu1", "edu2"]
  797:         stubs = ["inc", "edu"]
  798: 
  799:         wide_to_long(df, stubs, i="id", j="age")
  800: 
  801:         assert stubs == ["inc", "edu"]
  802: 
  803:     def test_separating_character(self):
  804:         # GH14779
  805: 
  806:         x = np.random.default_rng(2).standard_normal(3)
  807:         df = DataFrame(
  808:             {
  809:                 "A.1970": {0: "a", 1: "b", 2: "c"},
  810:                 "A.1980": {0: "d", 1: "e", 2: "f"},
  811:                 "B.1970": {0: 2.5, 1: 1.2, 2: 0.7},
  812:                 "B.1980": {0: 3.2, 1: 1.3, 2: 0.1},
  813:                 "X": dict(zip(range(3), x)),
  814:             }
  815:         )
  816:         df["id"] = df.index
  817:         exp_data = {
  818:             "X": x.tolist() + x.tolist(),
  819:             "A": ["a", "b", "c", "d", "e", "f"],
  820:             "B": [2.5, 1.2, 0.7, 3.2, 1.3, 0.1],
  821:             "year": [1970, 1970, 1970, 1980, 1980, 1980],
  822:             "id": [0, 1, 2, 0, 1, 2],
  823:         }
  824:         expected = DataFrame(exp_data)
  825:         expected = expected.set_index(["id", "year"])[["X", "A", "B"]]
  826:         result = wide_to_long(df, ["A", "B"], i="id", j="year", sep=".")
  827:         tm.assert_frame_equal(result, expected)
  828: 
  829:     def test_escapable_characters(self):
  830:         x = np.random.default_rng(2).standard_normal(3)
  831:         df = DataFrame(
  832:             {
  833:                 "A(quarterly)1970": {0: "a", 1: "b", 2: "c"},
  834:                 "A(quarterly)1980": {0: "d", 1: "e", 2: "f"},
  835:                 "B(quarterly)1970": {0: 2.5, 1: 1.2, 2: 0.7},
  836:                 "B(quarterly)1980": {0: 3.2, 1: 1.3, 2: 0.1},
  837:                 "X": dict(zip(range(3), x)),
  838:             }
  839:         )
  840:         df["id"] = df.index
  841:         exp_data = {
  842:             "X": x.tolist() + x.tolist(),
  843:             "A(quarterly)": ["a", "b", "c", "d", "e", "f"],
  844:             "B(quarterly)": [2.5, 1.2, 0.7, 3.2, 1.3, 0.1],
  845:             "year": [1970, 1970, 1970, 1980, 1980, 1980],
  846:             "id": [0, 1, 2, 0, 1, 2],
  847:         }
  848:         expected = DataFrame(exp_data)
  849:         expected = expected.set_index(["id", "year"])[
  850:             ["X", "A(quarterly)", "B(quarterly)"]
  851:         ]
  852:         result = wide_to_long(df, ["A(quarterly)", "B(quarterly)"], i="id", j="year")
  853:         tm.assert_frame_equal(result, expected)
  854: 
  855:     def test_unbalanced(self):
  856:         # test that we can have a varying amount of time variables
  857:         df = DataFrame(
  858:             {
  859:                 "A2010": [1.0, 2.0],
  860:                 "A2011": [3.0, 4.0],
  861:                 "B2010": [5.0, 6.0],
  862:                 "X": ["X1", "X2"],
  863:             }
  864:         )
  865:         df["id"] = df.index
  866:         exp_data = {
  867:             "X": ["X1", "X2", "X1", "X2"],
  868:             "A": [1.0, 2.0, 3.0, 4.0],
  869:             "B": [5.0, 6.0, np.nan, np.nan],
  870:             "id": [0, 1, 0, 1],
  871:             "year": [2010, 2010, 2011, 2011],
  872:         }
  873:         expected = DataFrame(exp_data)
  874:         expected = expected.set_index(["id", "year"])[["X", "A", "B"]]
  875:         result = wide_to_long(df, ["A", "B"], i="id", j="year")
  876:         tm.assert_frame_equal(result, expected)
  877: 
  878:     def test_character_overlap(self):
  879:         # Test we handle overlapping characters in both id_vars and value_vars
  880:         df = DataFrame(
  881:             {
  882:                 "A11": ["a11", "a22", "a33"],
  883:                 "A12": ["a21", "a22", "a23"],
  884:                 "B11": ["b11", "b12", "b13"],
  885:                 "B12": ["b21", "b22", "b23"],
  886:                 "BB11": [1, 2, 3],
  887:                 "BB12": [4, 5, 6],
  888:                 "BBBX": [91, 92, 93],
  889:                 "BBBZ": [91, 92, 93],
  890:             }
  891:         )
  892:         df["id"] = df.index
  893:         expected = DataFrame(
  894:             {
  895:                 "BBBX": [91, 92, 93, 91, 92, 93],
  896:                 "BBBZ": [91, 92, 93, 91, 92, 93],
  897:                 "A": ["a11", "a22", "a33", "a21", "a22", "a23"],
  898:                 "B": ["b11", "b12", "b13", "b21", "b22", "b23"],
  899:                 "BB": [1, 2, 3, 4, 5, 6],
  900:                 "id": [0, 1, 2, 0, 1, 2],
  901:                 "year": [11, 11, 11, 12, 12, 12],
  902:             }
  903:         )
  904:         expected = expected.set_index(["id", "year"])[["BBBX", "BBBZ", "A", "B", "BB"]]
  905:         result = wide_to_long(df, ["A", "B", "BB"], i="id", j="year")
  906:         tm.assert_frame_equal(result.sort_index(axis=1), expected.sort_index(axis=1))
  907: 
  908:     def test_invalid_separator(self):
  909:         # if an invalid separator is supplied a empty data frame is returned
  910:         sep = "nope!"
  911:         df = DataFrame(
  912:             {
  913:                 "A2010": [1.0, 2.0],
  914:                 "A2011": [3.0, 4.0],
  915:                 "B2010": [5.0, 6.0],
  916:                 "X": ["X1", "X2"],
  917:             }
  918:         )
  919:         df["id"] = df.index
  920:         exp_data = {
  921:             "X": "",
  922:             "A2010": [],
  923:             "A2011": [],
  924:             "B2010": [],
  925:             "id": [],
  926:             "year": [],
  927:             "A": [],
  928:             "B": [],
  929:         }
  930:         expected = DataFrame(exp_data).astype({"year": np.int64})
  931:         expected = expected.set_index(["id", "year"])[
  932:             ["X", "A2010", "A2011", "B2010", "A", "B"]
  933:         ]
  934:         expected.index = expected.index.set_levels([0, 1], level=0)
  935:         result = wide_to_long(df, ["A", "B"], i="id", j="year", sep=sep)
  936:         tm.assert_frame_equal(result.sort_index(axis=1), expected.sort_index(axis=1))
  937: 
  938:     def test_num_string_disambiguation(self):
  939:         # Test that we can disambiguate number value_vars from
  940:         # string value_vars
  941:         df = DataFrame(
  942:             {
  943:                 "A11": ["a11", "a22", "a33"],
  944:                 "A12": ["a21", "a22", "a23"],
  945:                 "B11": ["b11", "b12", "b13"],
  946:                 "B12": ["b21", "b22", "b23"],
  947:                 "BB11": [1, 2, 3],
  948:                 "BB12": [4, 5, 6],
  949:                 "Arating": [91, 92, 93],
  950:                 "Arating_old": [91, 92, 93],
  951:             }
  952:         )
  953:         df["id"] = df.index
  954:         expected = DataFrame(
  955:             {
  956:                 "Arating": [91, 92, 93, 91, 92, 93],
  957:                 "Arating_old": [91, 92, 93, 91, 92, 93],
  958:                 "A": ["a11", "a22", "a33", "a21", "a22", "a23"],
  959:                 "B": ["b11", "b12", "b13", "b21", "b22", "b23"],
  960:                 "BB": [1, 2, 3, 4, 5, 6],
  961:                 "id": [0, 1, 2, 0, 1, 2],
  962:                 "year": [11, 11, 11, 12, 12, 12],
  963:             }
  964:         )
  965:         expected = expected.set_index(["id", "year"])[
  966:             ["Arating", "Arating_old", "A", "B", "BB"]
  967:         ]
  968:         result = wide_to_long(df, ["A", "B", "BB"], i="id", j="year")
  969:         tm.assert_frame_equal(result.sort_index(axis=1), expected.sort_index(axis=1))
  970: 
  971:     def test_invalid_suffixtype(self):
  972:         # If all stubs names end with a string, but a numeric suffix is
  973:         # assumed,  an empty data frame is returned
  974:         df = DataFrame(
  975:             {
  976:                 "Aone": [1.0, 2.0],
  977:                 "Atwo": [3.0, 4.0],
  978:                 "Bone": [5.0, 6.0],
  979:                 "X": ["X1", "X2"],
  980:             }
  981:         )
  982:         df["id"] = df.index
  983:         exp_data = {
  984:             "X": "",
  985:             "Aone": [],
  986:             "Atwo": [],
  987:             "Bone": [],
  988:             "id": [],
  989:             "year": [],
  990:             "A": [],
  991:             "B": [],
  992:         }
  993:         expected = DataFrame(exp_data).astype({"year": np.int64})
  994: 
  995:         expected = expected.set_index(["id", "year"])
  996:         expected.index = expected.index.set_levels([0, 1], level=0)
  997:         result = wide_to_long(df, ["A", "B"], i="id", j="year")
  998:         tm.assert_frame_equal(result.sort_index(axis=1), expected.sort_index(axis=1))
  999: 
 1000:     def test_multiple_id_columns(self):
 1001:         # Taken from http://www.ats.ucla.edu/stat/stata/modules/reshapel.htm
 1002:         df = DataFrame(
 1003:             {
 1004:                 "famid": [1, 1, 1, 2, 2, 2, 3, 3, 3],
 1005:                 "birth": [1, 2, 3, 1, 2, 3, 1, 2, 3],
 1006:                 "ht1": [2.8, 2.9, 2.2, 2, 1.8, 1.9, 2.2, 2.3, 2.1],
 1007:                 "ht2": [3.4, 3.8, 2.9, 3.2, 2.8, 2.4, 3.3, 3.4, 2.9],
 1008:             }
 1009:         )
 1010:         expected = DataFrame(
 1011:             {
 1012:                 "ht": [
 1013:                     2.8,
 1014:                     3.4,
 1015:                     2.9,
 1016:                     3.8,
 1017:                     2.2,
 1018:                     2.9,
 1019:                     2.0,
 1020:                     3.2,
 1021:                     1.8,
 1022:                     2.8,
 1023:                     1.9,
 1024:                     2.4,
 1025:                     2.2,
 1026:                     3.3,
 1027:                     2.3,
 1028:                     3.4,
 1029:                     2.1,
 1030:                     2.9,
 1031:                 ],
 1032:                 "famid": [1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3],
 1033:                 "birth": [1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3],
 1034:                 "age": [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2],
 1035:             }
 1036:         )
 1037:         expected = expected.set_index(["famid", "birth", "age"])[["ht"]]
 1038:         result = wide_to_long(df, "ht", i=["famid", "birth"], j="age")
 1039:         tm.assert_frame_equal(result, expected)
 1040: 
 1041:     def test_non_unique_idvars(self):
 1042:         # GH16382
 1043:         # Raise an error message if non unique id vars (i) are passed
 1044:         df = DataFrame(
 1045:             {"A_A1": [1, 2, 3, 4, 5], "B_B1": [1, 2, 3, 4, 5], "x": [1, 1, 1, 1, 1]}
 1046:         )
 1047:         msg = "the id variables need to uniquely identify each row"
 1048:         with pytest.raises(ValueError, match=msg):
 1049:             wide_to_long(df, ["A_A", "B_B"], i="x", j="colname")
 1050: 
 1051:     def test_cast_j_int(self):
 1052:         df = DataFrame(
 1053:             {
 1054:                 "actor_1": ["CCH Pounder", "Johnny Depp", "Christoph Waltz"],
 1055:                 "actor_2": ["Joel David Moore", "Orlando Bloom", "Rory Kinnear"],
 1056:                 "actor_fb_likes_1": [1000.0, 40000.0, 11000.0],
 1057:                 "actor_fb_likes_2": [936.0, 5000.0, 393.0],
 1058:                 "title": ["Avatar", "Pirates of the Caribbean", "Spectre"],
 1059:             }
 1060:         )
 1061: 
 1062:         expected = DataFrame(
 1063:             {
 1064:                 "actor": [
 1065:                     "CCH Pounder",
 1066:                     "Johnny Depp",
 1067:                     "Christoph Waltz",
 1068:                     "Joel David Moore",
 1069:                     "Orlando Bloom",
 1070:                     "Rory Kinnear",
 1071:                 ],
 1072:                 "actor_fb_likes": [1000.0, 40000.0, 11000.0, 936.0, 5000.0, 393.0],
 1073:                 "num": [1, 1, 1, 2, 2, 2],
 1074:                 "title": [
 1075:                     "Avatar",
 1076:                     "Pirates of the Caribbean",
 1077:                     "Spectre",
 1078:                     "Avatar",
 1079:                     "Pirates of the Caribbean",
 1080:                     "Spectre",
 1081:                 ],
 1082:             }
 1083:         ).set_index(["title", "num"])
 1084:         result = wide_to_long(
 1085:             df, ["actor", "actor_fb_likes"], i="title", j="num", sep="_"
 1086:         )
 1087: 
 1088:         tm.assert_frame_equal(result, expected)
 1089: 
 1090:     def test_identical_stubnames(self):
 1091:         df = DataFrame(
 1092:             {
 1093:                 "A2010": [1.0, 2.0],
 1094:                 "A2011": [3.0, 4.0],
 1095:                 "B2010": [5.0, 6.0],
 1096:                 "A": ["X1", "X2"],
 1097:             }
 1098:         )
 1099:         msg = "stubname can't be identical to a column name"
 1100:         with pytest.raises(ValueError, match=msg):
 1101:             wide_to_long(df, ["A", "B"], i="A", j="colname")
 1102: 
 1103:     def test_nonnumeric_suffix(self):
 1104:         df = DataFrame(
 1105:             {
 1106:                 "treatment_placebo": [1.0, 2.0],
 1107:                 "treatment_test": [3.0, 4.0],
 1108:                 "result_placebo": [5.0, 6.0],
 1109:                 "A": ["X1", "X2"],
 1110:             }
 1111:         )
 1112:         expected = DataFrame(
 1113:             {
 1114:                 "A": ["X1", "X2", "X1", "X2"],
 1115:                 "colname": ["placebo", "placebo", "test", "test"],
 1116:                 "result": [5.0, 6.0, np.nan, np.nan],
 1117:                 "treatment": [1.0, 2.0, 3.0, 4.0],
 1118:             }
 1119:         )
 1120:         expected = expected.set_index(["A", "colname"])
 1121:         result = wide_to_long(
 1122:             df, ["result", "treatment"], i="A", j="colname", suffix="[a-z]+", sep="_"
 1123:         )
 1124:         tm.assert_frame_equal(result, expected)
 1125: 
 1126:     def test_mixed_type_suffix(self):
 1127:         df = DataFrame(
 1128:             {
 1129:                 "A": ["X1", "X2"],
 1130:                 "result_1": [0, 9],
 1131:                 "result_foo": [5.0, 6.0],
 1132:                 "treatment_1": [1.0, 2.0],
 1133:                 "treatment_foo": [3.0, 4.0],
 1134:             }
 1135:         )
 1136:         expected = DataFrame(
 1137:             {
 1138:                 "A": ["X1", "X2", "X1", "X2"],
 1139:                 "colname": ["1", "1", "foo", "foo"],
 1140:                 "result": [0.0, 9.0, 5.0, 6.0],
 1141:                 "treatment": [1.0, 2.0, 3.0, 4.0],
 1142:             }
 1143:         ).set_index(["A", "colname"])
 1144:         result = wide_to_long(
 1145:             df, ["result", "treatment"], i="A", j="colname", suffix=".+", sep="_"
 1146:         )
 1147:         tm.assert_frame_equal(result, expected)
 1148: 
 1149:     def test_float_suffix(self):
 1150:         df = DataFrame(
 1151:             {
 1152:                 "treatment_1.1": [1.0, 2.0],
 1153:                 "treatment_2.1": [3.0, 4.0],
 1154:                 "result_1.2": [5.0, 6.0],
 1155:                 "result_1": [0, 9],
 1156:                 "A": ["X1", "X2"],
 1157:             }
 1158:         )
 1159:         expected = DataFrame(
 1160:             {
 1161:                 "A": ["X1", "X2", "X1", "X2", "X1", "X2", "X1", "X2"],
 1162:                 "colname": [1.2, 1.2, 1.0, 1.0, 1.1, 1.1, 2.1, 2.1],
 1163:                 "result": [5.0, 6.0, 0.0, 9.0, np.nan, np.nan, np.nan, np.nan],
 1164:                 "treatment": [np.nan, np.nan, np.nan, np.nan, 1.0, 2.0, 3.0, 4.0],
 1165:             }
 1166:         )
 1167:         expected = expected.set_index(["A", "colname"])
 1168:         result = wide_to_long(
 1169:             df, ["result", "treatment"], i="A", j="colname", suffix="[0-9.]+", sep="_"
 1170:         )
 1171:         tm.assert_frame_equal(result, expected)
 1172: 
 1173:     def test_col_substring_of_stubname(self):
 1174:         # GH22468
 1175:         # Don't raise ValueError when a column name is a substring
 1176:         # of a stubname that's been passed as a string
 1177:         wide_data = {
 1178:             "node_id": {0: 0, 1: 1, 2: 2, 3: 3, 4: 4},
 1179:             "A": {0: 0.80, 1: 0.0, 2: 0.25, 3: 1.0, 4: 0.81},
 1180:             "PA0": {0: 0.74, 1: 0.56, 2: 0.56, 3: 0.98, 4: 0.6},
 1181:             "PA1": {0: 0.77, 1: 0.64, 2: 0.52, 3: 0.98, 4: 0.67},
 1182:             "PA3": {0: 0.34, 1: 0.70, 2: 0.52, 3: 0.98, 4: 0.67},
 1183:         }
 1184:         wide_df = DataFrame.from_dict(wide_data)
 1185:         expected = wide_to_long(wide_df, stubnames=["PA"], i=["node_id", "A"], j="time")
 1186:         result = wide_to_long(wide_df, stubnames="PA", i=["node_id", "A"], j="time")
 1187:         tm.assert_frame_equal(result, expected)
 1188: 
 1189:     def test_raise_of_column_name_value(self):
 1190:         # GH34731, enforced in 2.0
 1191:         # raise a ValueError if the resultant value column name matches
 1192:         # a name in the dataframe already (default name is "value")
 1193:         df = DataFrame({"col": list("ABC"), "value": range(10, 16, 2)})
 1194: 
 1195:         with pytest.raises(
 1196:             ValueError, match=re.escape("value_name (value) cannot match")
 1197:         ):
 1198:             df.melt(id_vars="value", value_name="value")
 1199: 
 1200:     @pytest.mark.parametrize("dtype", ["O", "string"])
 1201:     def test_missing_stubname(self, dtype):
 1202:         # GH46044
 1203:         df = DataFrame({"id": ["1", "2"], "a-1": [100, 200], "a-2": [300, 400]})
 1204:         df = df.astype({"id": dtype})
 1205:         result = wide_to_long(
 1206:             df,
 1207:             stubnames=["a", "b"],
 1208:             i="id",
 1209:             j="num",
 1210:             sep="-",
 1211:         )
 1212:         index = Index(
 1213:             [("1", 1), ("2", 1), ("1", 2), ("2", 2)],
 1214:             name=("id", "num"),
 1215:         )
 1216:         expected = DataFrame(
 1217:             {"a": [100, 200, 300, 400], "b": [np.nan] * 4},
 1218:             index=index,
 1219:         )
 1220:         new_level = expected.index.levels[0].astype(dtype)
 1221:         expected.index = expected.index.set_levels(new_level, level=0)
 1222:         tm.assert_frame_equal(result, expected)
 1223: 
 1224: 
 1225: def test_wide_to_long_pyarrow_string_columns():
 1226:     # GH 57066
 1227:     pytest.importorskip("pyarrow")
 1228:     df = DataFrame(
 1229:         {
 1230:             "ID": {0: 1},
 1231:             "R_test1": {0: 1},
 1232:             "R_test2": {0: 1},
 1233:             "R_test3": {0: 2},
 1234:             "D": {0: 1},
 1235:         }
 1236:     )
 1237:     df.columns = df.columns.astype("string[pyarrow_numpy]")
 1238:     result = wide_to_long(
 1239:         df, stubnames="R", i="ID", j="UNPIVOTED", sep="_", suffix=".*"
 1240:     )
 1241:     expected = DataFrame(
 1242:         [[1, 1], [1, 1], [1, 2]],
 1243:         columns=Index(["D", "R"], dtype=object),
 1244:         index=pd.MultiIndex.from_arrays(
 1245:             [
 1246:                 [1, 1, 1],
 1247:                 Index(["test1", "test2", "test3"], dtype="string[pyarrow_numpy]"),
 1248:             ],
 1249:             names=["ID", "UNPIVOTED"],
 1250:         ),
 1251:     )
 1252:     tm.assert_frame_equal(result, expected)
