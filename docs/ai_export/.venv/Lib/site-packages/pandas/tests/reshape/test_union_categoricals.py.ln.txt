    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.core.dtypes.concat import union_categoricals
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     Categorical,
    9:     CategoricalIndex,
   10:     Series,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: class TestUnionCategoricals:
   16:     @pytest.mark.parametrize(
   17:         "a, b, combined",
   18:         [
   19:             (list("abc"), list("abd"), list("abcabd")),
   20:             ([0, 1, 2], [2, 3, 4], [0, 1, 2, 2, 3, 4]),
   21:             ([0, 1.2, 2], [2, 3.4, 4], [0, 1.2, 2, 2, 3.4, 4]),
   22:             (
   23:                 ["b", "b", np.nan, "a"],
   24:                 ["a", np.nan, "c"],
   25:                 ["b", "b", np.nan, "a", "a", np.nan, "c"],
   26:             ),
   27:             (
   28:                 pd.date_range("2014-01-01", "2014-01-05"),
   29:                 pd.date_range("2014-01-06", "2014-01-07"),
   30:                 pd.date_range("2014-01-01", "2014-01-07"),
   31:             ),
   32:             (
   33:                 pd.date_range("2014-01-01", "2014-01-05", tz="US/Central"),
   34:                 pd.date_range("2014-01-06", "2014-01-07", tz="US/Central"),
   35:                 pd.date_range("2014-01-01", "2014-01-07", tz="US/Central"),
   36:             ),
   37:             (
   38:                 pd.period_range("2014-01-01", "2014-01-05"),
   39:                 pd.period_range("2014-01-06", "2014-01-07"),
   40:                 pd.period_range("2014-01-01", "2014-01-07"),
   41:             ),
   42:         ],
   43:     )
   44:     @pytest.mark.parametrize("box", [Categorical, CategoricalIndex, Series])
   45:     def test_union_categorical(self, a, b, combined, box):
   46:         # GH 13361
   47:         result = union_categoricals([box(Categorical(a)), box(Categorical(b))])
   48:         expected = Categorical(combined)
   49:         tm.assert_categorical_equal(result, expected)
   50: 
   51:     def test_union_categorical_ordered_appearance(self):
   52:         # new categories ordered by appearance
   53:         s = Categorical(["x", "y", "z"])
   54:         s2 = Categorical(["a", "b", "c"])
   55:         result = union_categoricals([s, s2])
   56:         expected = Categorical(
   57:             ["x", "y", "z", "a", "b", "c"], categories=["x", "y", "z", "a", "b", "c"]
   58:         )
   59:         tm.assert_categorical_equal(result, expected)
   60: 
   61:     def test_union_categorical_ordered_true(self):
   62:         s = Categorical([0, 1.2, 2], ordered=True)
   63:         s2 = Categorical([0, 1.2, 2], ordered=True)
   64:         result = union_categoricals([s, s2])
   65:         expected = Categorical([0, 1.2, 2, 0, 1.2, 2], ordered=True)
   66:         tm.assert_categorical_equal(result, expected)
   67: 
   68:     def test_union_categorical_match_types(self):
   69:         # must exactly match types
   70:         s = Categorical([0, 1.2, 2])
   71:         s2 = Categorical([2, 3, 4])
   72:         msg = "dtype of categories must be the same"
   73:         with pytest.raises(TypeError, match=msg):
   74:             union_categoricals([s, s2])
   75: 
   76:     def test_union_categorical_empty(self):
   77:         msg = "No Categoricals to union"
   78:         with pytest.raises(ValueError, match=msg):
   79:             union_categoricals([])
   80: 
   81:     def test_union_categoricals_nan(self):
   82:         # GH 13759
   83:         res = union_categoricals(
   84:             [Categorical([1, 2, np.nan]), Categorical([3, 2, np.nan])]
   85:         )
   86:         exp = Categorical([1, 2, np.nan, 3, 2, np.nan])
   87:         tm.assert_categorical_equal(res, exp)
   88: 
   89:         res = union_categoricals(
   90:             [Categorical(["A", "B"]), Categorical(["B", "B", np.nan])]
   91:         )
   92:         exp = Categorical(["A", "B", "B", "B", np.nan])
   93:         tm.assert_categorical_equal(res, exp)
   94: 
   95:         val1 = [pd.Timestamp("2011-01-01"), pd.Timestamp("2011-03-01"), pd.NaT]
   96:         val2 = [pd.NaT, pd.Timestamp("2011-01-01"), pd.Timestamp("2011-02-01")]
   97: 
   98:         res = union_categoricals([Categorical(val1), Categorical(val2)])
   99:         exp = Categorical(
  100:             val1 + val2,
  101:             categories=[
  102:                 pd.Timestamp("2011-01-01"),
  103:                 pd.Timestamp("2011-03-01"),
  104:                 pd.Timestamp("2011-02-01"),
  105:             ],
  106:         )
  107:         tm.assert_categorical_equal(res, exp)
  108: 
  109:         # all NaN
  110:         res = union_categoricals(
  111:             [
  112:                 Categorical(np.array([np.nan, np.nan], dtype=object)),
  113:                 Categorical(["X"], categories=pd.Index(["X"], dtype=object)),
  114:             ]
  115:         )
  116:         exp = Categorical([np.nan, np.nan, "X"])
  117:         tm.assert_categorical_equal(res, exp)
  118: 
  119:         res = union_categoricals(
  120:             [Categorical([np.nan, np.nan]), Categorical([np.nan, np.nan])]
  121:         )
  122:         exp = Categorical([np.nan, np.nan, np.nan, np.nan])
  123:         tm.assert_categorical_equal(res, exp)
  124: 
  125:     @pytest.mark.parametrize("val", [[], ["1"]])
  126:     def test_union_categoricals_empty(self, val, request, using_infer_string):
  127:         # GH 13759
  128:         if using_infer_string and val == ["1"]:
  129:             request.applymarker(pytest.mark.xfail("object and strings dont match"))
  130:         res = union_categoricals([Categorical([]), Categorical(val)])
  131:         exp = Categorical(val)
  132:         tm.assert_categorical_equal(res, exp)
  133: 
  134:     def test_union_categorical_same_category(self):
  135:         # check fastpath
  136:         c1 = Categorical([1, 2, 3, 4], categories=[1, 2, 3, 4])
  137:         c2 = Categorical([3, 2, 1, np.nan], categories=[1, 2, 3, 4])
  138:         res = union_categoricals([c1, c2])
  139:         exp = Categorical([1, 2, 3, 4, 3, 2, 1, np.nan], categories=[1, 2, 3, 4])
  140:         tm.assert_categorical_equal(res, exp)
  141: 
  142:     def test_union_categorical_same_category_str(self):
  143:         c1 = Categorical(["z", "z", "z"], categories=["x", "y", "z"])
  144:         c2 = Categorical(["x", "x", "x"], categories=["x", "y", "z"])
  145:         res = union_categoricals([c1, c2])
  146:         exp = Categorical(["z", "z", "z", "x", "x", "x"], categories=["x", "y", "z"])
  147:         tm.assert_categorical_equal(res, exp)
  148: 
  149:     def test_union_categorical_same_categories_different_order(self):
  150:         # https://github.com/pandas-dev/pandas/issues/19096
  151:         c1 = Categorical(["a", "b", "c"], categories=["a", "b", "c"])
  152:         c2 = Categorical(["a", "b", "c"], categories=["b", "a", "c"])
  153:         result = union_categoricals([c1, c2])
  154:         expected = Categorical(
  155:             ["a", "b", "c", "a", "b", "c"], categories=["a", "b", "c"]
  156:         )
  157:         tm.assert_categorical_equal(result, expected)
  158: 
  159:     def test_union_categoricals_ordered(self):
  160:         c1 = Categorical([1, 2, 3], ordered=True)
  161:         c2 = Categorical([1, 2, 3], ordered=False)
  162: 
  163:         msg = "Categorical.ordered must be the same"
  164:         with pytest.raises(TypeError, match=msg):
  165:             union_categoricals([c1, c2])
  166: 
  167:         res = union_categoricals([c1, c1])
  168:         exp = Categorical([1, 2, 3, 1, 2, 3], ordered=True)
  169:         tm.assert_categorical_equal(res, exp)
  170: 
  171:         c1 = Categorical([1, 2, 3, np.nan], ordered=True)
  172:         c2 = Categorical([3, 2], categories=[1, 2, 3], ordered=True)
  173: 
  174:         res = union_categoricals([c1, c2])
  175:         exp = Categorical([1, 2, 3, np.nan, 3, 2], ordered=True)
  176:         tm.assert_categorical_equal(res, exp)
  177: 
  178:         c1 = Categorical([1, 2, 3], ordered=True)
  179:         c2 = Categorical([1, 2, 3], categories=[3, 2, 1], ordered=True)
  180: 
  181:         msg = "to union ordered Categoricals, all categories must be the same"
  182:         with pytest.raises(TypeError, match=msg):
  183:             union_categoricals([c1, c2])
  184: 
  185:     def test_union_categoricals_ignore_order(self):
  186:         # GH 15219
  187:         c1 = Categorical([1, 2, 3], ordered=True)
  188:         c2 = Categorical([1, 2, 3], ordered=False)
  189: 
  190:         res = union_categoricals([c1, c2], ignore_order=True)
  191:         exp = Categorical([1, 2, 3, 1, 2, 3])
  192:         tm.assert_categorical_equal(res, exp)
  193: 
  194:         msg = "Categorical.ordered must be the same"
  195:         with pytest.raises(TypeError, match=msg):
  196:             union_categoricals([c1, c2], ignore_order=False)
  197: 
  198:         res = union_categoricals([c1, c1], ignore_order=True)
  199:         exp = Categorical([1, 2, 3, 1, 2, 3])
  200:         tm.assert_categorical_equal(res, exp)
  201: 
  202:         res = union_categoricals([c1, c1], ignore_order=False)
  203:         exp = Categorical([1, 2, 3, 1, 2, 3], categories=[1, 2, 3], ordered=True)
  204:         tm.assert_categorical_equal(res, exp)
  205: 
  206:         c1 = Categorical([1, 2, 3, np.nan], ordered=True)
  207:         c2 = Categorical([3, 2], categories=[1, 2, 3], ordered=True)
  208: 
  209:         res = union_categoricals([c1, c2], ignore_order=True)
  210:         exp = Categorical([1, 2, 3, np.nan, 3, 2])
  211:         tm.assert_categorical_equal(res, exp)
  212: 
  213:         c1 = Categorical([1, 2, 3], ordered=True)
  214:         c2 = Categorical([1, 2, 3], categories=[3, 2, 1], ordered=True)
  215: 
  216:         res = union_categoricals([c1, c2], ignore_order=True)
  217:         exp = Categorical([1, 2, 3, 1, 2, 3])
  218:         tm.assert_categorical_equal(res, exp)
  219: 
  220:         res = union_categoricals([c2, c1], ignore_order=True, sort_categories=True)
  221:         exp = Categorical([1, 2, 3, 1, 2, 3], categories=[1, 2, 3])
  222:         tm.assert_categorical_equal(res, exp)
  223: 
  224:         c1 = Categorical([1, 2, 3], ordered=True)
  225:         c2 = Categorical([4, 5, 6], ordered=True)
  226:         result = union_categoricals([c1, c2], ignore_order=True)
  227:         expected = Categorical([1, 2, 3, 4, 5, 6])
  228:         tm.assert_categorical_equal(result, expected)
  229: 
  230:         msg = "to union ordered Categoricals, all categories must be the same"
  231:         with pytest.raises(TypeError, match=msg):
  232:             union_categoricals([c1, c2], ignore_order=False)
  233: 
  234:         with pytest.raises(TypeError, match=msg):
  235:             union_categoricals([c1, c2])
  236: 
  237:     def test_union_categoricals_sort(self):
  238:         # GH 13846
  239:         c1 = Categorical(["x", "y", "z"])
  240:         c2 = Categorical(["a", "b", "c"])
  241:         result = union_categoricals([c1, c2], sort_categories=True)
  242:         expected = Categorical(
  243:             ["x", "y", "z", "a", "b", "c"], categories=["a", "b", "c", "x", "y", "z"]
  244:         )
  245:         tm.assert_categorical_equal(result, expected)
  246: 
  247:         # fastpath
  248:         c1 = Categorical(["a", "b"], categories=["b", "a", "c"])
  249:         c2 = Categorical(["b", "c"], categories=["b", "a", "c"])
  250:         result = union_categoricals([c1, c2], sort_categories=True)
  251:         expected = Categorical(["a", "b", "b", "c"], categories=["a", "b", "c"])
  252:         tm.assert_categorical_equal(result, expected)
  253: 
  254:         c1 = Categorical(["a", "b"], categories=["c", "a", "b"])
  255:         c2 = Categorical(["b", "c"], categories=["c", "a", "b"])
  256:         result = union_categoricals([c1, c2], sort_categories=True)
  257:         expected = Categorical(["a", "b", "b", "c"], categories=["a", "b", "c"])
  258:         tm.assert_categorical_equal(result, expected)
  259: 
  260:         # fastpath - skip resort
  261:         c1 = Categorical(["a", "b"], categories=["a", "b", "c"])
  262:         c2 = Categorical(["b", "c"], categories=["a", "b", "c"])
  263:         result = union_categoricals([c1, c2], sort_categories=True)
  264:         expected = Categorical(["a", "b", "b", "c"], categories=["a", "b", "c"])
  265:         tm.assert_categorical_equal(result, expected)
  266: 
  267:         c1 = Categorical(["x", np.nan])
  268:         c2 = Categorical([np.nan, "b"])
  269:         result = union_categoricals([c1, c2], sort_categories=True)
  270:         expected = Categorical(["x", np.nan, np.nan, "b"], categories=["b", "x"])
  271:         tm.assert_categorical_equal(result, expected)
  272: 
  273:         c1 = Categorical([np.nan])
  274:         c2 = Categorical([np.nan])
  275:         result = union_categoricals([c1, c2], sort_categories=True)
  276:         expected = Categorical([np.nan, np.nan])
  277:         tm.assert_categorical_equal(result, expected)
  278: 
  279:         c1 = Categorical([])
  280:         c2 = Categorical([])
  281:         result = union_categoricals([c1, c2], sort_categories=True)
  282:         expected = Categorical([])
  283:         tm.assert_categorical_equal(result, expected)
  284: 
  285:         c1 = Categorical(["b", "a"], categories=["b", "a", "c"], ordered=True)
  286:         c2 = Categorical(["a", "c"], categories=["b", "a", "c"], ordered=True)
  287:         msg = "Cannot use sort_categories=True with ordered Categoricals"
  288:         with pytest.raises(TypeError, match=msg):
  289:             union_categoricals([c1, c2], sort_categories=True)
  290: 
  291:     def test_union_categoricals_sort_false(self):
  292:         # GH 13846
  293:         c1 = Categorical(["x", "y", "z"])
  294:         c2 = Categorical(["a", "b", "c"])
  295:         result = union_categoricals([c1, c2], sort_categories=False)
  296:         expected = Categorical(
  297:             ["x", "y", "z", "a", "b", "c"], categories=["x", "y", "z", "a", "b", "c"]
  298:         )
  299:         tm.assert_categorical_equal(result, expected)
  300: 
  301:     def test_union_categoricals_sort_false_fastpath(self):
  302:         # fastpath
  303:         c1 = Categorical(["a", "b"], categories=["b", "a", "c"])
  304:         c2 = Categorical(["b", "c"], categories=["b", "a", "c"])
  305:         result = union_categoricals([c1, c2], sort_categories=False)
  306:         expected = Categorical(["a", "b", "b", "c"], categories=["b", "a", "c"])
  307:         tm.assert_categorical_equal(result, expected)
  308: 
  309:     def test_union_categoricals_sort_false_skipresort(self):
  310:         # fastpath - skip resort
  311:         c1 = Categorical(["a", "b"], categories=["a", "b", "c"])
  312:         c2 = Categorical(["b", "c"], categories=["a", "b", "c"])
  313:         result = union_categoricals([c1, c2], sort_categories=False)
  314:         expected = Categorical(["a", "b", "b", "c"], categories=["a", "b", "c"])
  315:         tm.assert_categorical_equal(result, expected)
  316: 
  317:     def test_union_categoricals_sort_false_one_nan(self):
  318:         c1 = Categorical(["x", np.nan])
  319:         c2 = Categorical([np.nan, "b"])
  320:         result = union_categoricals([c1, c2], sort_categories=False)
  321:         expected = Categorical(["x", np.nan, np.nan, "b"], categories=["x", "b"])
  322:         tm.assert_categorical_equal(result, expected)
  323: 
  324:     def test_union_categoricals_sort_false_only_nan(self):
  325:         c1 = Categorical([np.nan])
  326:         c2 = Categorical([np.nan])
  327:         result = union_categoricals([c1, c2], sort_categories=False)
  328:         expected = Categorical([np.nan, np.nan])
  329:         tm.assert_categorical_equal(result, expected)
  330: 
  331:     def test_union_categoricals_sort_false_empty(self):
  332:         c1 = Categorical([])
  333:         c2 = Categorical([])
  334:         result = union_categoricals([c1, c2], sort_categories=False)
  335:         expected = Categorical([])
  336:         tm.assert_categorical_equal(result, expected)
  337: 
  338:     def test_union_categoricals_sort_false_ordered_true(self):
  339:         c1 = Categorical(["b", "a"], categories=["b", "a", "c"], ordered=True)
  340:         c2 = Categorical(["a", "c"], categories=["b", "a", "c"], ordered=True)
  341:         result = union_categoricals([c1, c2], sort_categories=False)
  342:         expected = Categorical(
  343:             ["b", "a", "a", "c"], categories=["b", "a", "c"], ordered=True
  344:         )
  345:         tm.assert_categorical_equal(result, expected)
  346: 
  347:     def test_union_categorical_unwrap(self):
  348:         # GH 14173
  349:         c1 = Categorical(["a", "b"])
  350:         c2 = Series(["b", "c"], dtype="category")
  351:         result = union_categoricals([c1, c2])
  352:         expected = Categorical(["a", "b", "b", "c"])
  353:         tm.assert_categorical_equal(result, expected)
  354: 
  355:         c2 = CategoricalIndex(c2)
  356:         result = union_categoricals([c1, c2])
  357:         tm.assert_categorical_equal(result, expected)
  358: 
  359:         c1 = Series(c1)
  360:         result = union_categoricals([c1, c2])
  361:         tm.assert_categorical_equal(result, expected)
  362: 
  363:         msg = "all components to combine must be Categorical"
  364:         with pytest.raises(TypeError, match=msg):
  365:             union_categoricals([c1, ["a", "b", "c"]])
