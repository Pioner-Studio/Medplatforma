    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Categorical,
    7:     DataFrame,
    8:     DatetimeIndex,
    9:     Index,
   10:     Interval,
   11:     IntervalIndex,
   12:     Series,
   13:     TimedeltaIndex,
   14:     Timestamp,
   15:     cut,
   16:     date_range,
   17:     interval_range,
   18:     isna,
   19:     qcut,
   20:     timedelta_range,
   21:     to_datetime,
   22: )
   23: import pandas._testing as tm
   24: from pandas.api.types import CategoricalDtype
   25: import pandas.core.reshape.tile as tmod
   26: 
   27: 
   28: def test_simple():
   29:     data = np.ones(5, dtype="int64")
   30:     result = cut(data, 4, labels=False)
   31: 
   32:     expected = np.array([1, 1, 1, 1, 1])
   33:     tm.assert_numpy_array_equal(result, expected, check_dtype=False)
   34: 
   35: 
   36: @pytest.mark.parametrize("func", [list, np.array])
   37: def test_bins(func):
   38:     data = func([0.2, 1.4, 2.5, 6.2, 9.7, 2.1])
   39:     result, bins = cut(data, 3, retbins=True)
   40: 
   41:     intervals = IntervalIndex.from_breaks(bins.round(3))
   42:     intervals = intervals.take([0, 0, 0, 1, 2, 0])
   43:     expected = Categorical(intervals, ordered=True)
   44: 
   45:     tm.assert_categorical_equal(result, expected)
   46:     tm.assert_almost_equal(bins, np.array([0.1905, 3.36666667, 6.53333333, 9.7]))
   47: 
   48: 
   49: def test_right():
   50:     data = np.array([0.2, 1.4, 2.5, 6.2, 9.7, 2.1, 2.575])
   51:     result, bins = cut(data, 4, right=True, retbins=True)
   52: 
   53:     intervals = IntervalIndex.from_breaks(bins.round(3))
   54:     expected = Categorical(intervals, ordered=True)
   55:     expected = expected.take([0, 0, 0, 2, 3, 0, 0])
   56: 
   57:     tm.assert_categorical_equal(result, expected)
   58:     tm.assert_almost_equal(bins, np.array([0.1905, 2.575, 4.95, 7.325, 9.7]))
   59: 
   60: 
   61: def test_no_right():
   62:     data = np.array([0.2, 1.4, 2.5, 6.2, 9.7, 2.1, 2.575])
   63:     result, bins = cut(data, 4, right=False, retbins=True)
   64: 
   65:     intervals = IntervalIndex.from_breaks(bins.round(3), closed="left")
   66:     intervals = intervals.take([0, 0, 0, 2, 3, 0, 1])
   67:     expected = Categorical(intervals, ordered=True)
   68: 
   69:     tm.assert_categorical_equal(result, expected)
   70:     tm.assert_almost_equal(bins, np.array([0.2, 2.575, 4.95, 7.325, 9.7095]))
   71: 
   72: 
   73: def test_bins_from_interval_index():
   74:     c = cut(range(5), 3)
   75:     expected = c
   76:     result = cut(range(5), bins=expected.categories)
   77:     tm.assert_categorical_equal(result, expected)
   78: 
   79:     expected = Categorical.from_codes(
   80:         np.append(c.codes, -1), categories=c.categories, ordered=True
   81:     )
   82:     result = cut(range(6), bins=expected.categories)
   83:     tm.assert_categorical_equal(result, expected)
   84: 
   85: 
   86: def test_bins_from_interval_index_doc_example():
   87:     # Make sure we preserve the bins.
   88:     ages = np.array([10, 15, 13, 12, 23, 25, 28, 59, 60])
   89:     c = cut(ages, bins=[0, 18, 35, 70])
   90:     expected = IntervalIndex.from_tuples([(0, 18), (18, 35), (35, 70)])
   91:     tm.assert_index_equal(c.categories, expected)
   92: 
   93:     result = cut([25, 20, 50], bins=c.categories)
   94:     tm.assert_index_equal(result.categories, expected)
   95:     tm.assert_numpy_array_equal(result.codes, np.array([1, 1, 2], dtype="int8"))
   96: 
   97: 
   98: def test_bins_not_overlapping_from_interval_index():
   99:     # see gh-23980
  100:     msg = "Overlapping IntervalIndex is not accepted"
  101:     ii = IntervalIndex.from_tuples([(0, 10), (2, 12), (4, 14)])
  102: 
  103:     with pytest.raises(ValueError, match=msg):
  104:         cut([5, 6], bins=ii)
  105: 
  106: 
  107: def test_bins_not_monotonic():
  108:     msg = "bins must increase monotonically"
  109:     data = [0.2, 1.4, 2.5, 6.2, 9.7, 2.1]
  110: 
  111:     with pytest.raises(ValueError, match=msg):
  112:         cut(data, [0.1, 1.5, 1, 10])
  113: 
  114: 
  115: @pytest.mark.parametrize(
  116:     "x, bins, expected",
  117:     [
  118:         (
  119:             date_range("2017-12-31", periods=3),
  120:             [Timestamp.min, Timestamp("2018-01-01"), Timestamp.max],
  121:             IntervalIndex.from_tuples(
  122:                 [
  123:                     (Timestamp.min, Timestamp("2018-01-01")),
  124:                     (Timestamp("2018-01-01"), Timestamp.max),
  125:                 ]
  126:             ),
  127:         ),
  128:         (
  129:             [-1, 0, 1],
  130:             np.array(
  131:                 [np.iinfo(np.int64).min, 0, np.iinfo(np.int64).max], dtype="int64"
  132:             ),
  133:             IntervalIndex.from_tuples(
  134:                 [(np.iinfo(np.int64).min, 0), (0, np.iinfo(np.int64).max)]
  135:             ),
  136:         ),
  137:         (
  138:             [
  139:                 np.timedelta64(-1, "ns"),
  140:                 np.timedelta64(0, "ns"),
  141:                 np.timedelta64(1, "ns"),
  142:             ],
  143:             np.array(
  144:                 [
  145:                     np.timedelta64(-np.iinfo(np.int64).max, "ns"),
  146:                     np.timedelta64(0, "ns"),
  147:                     np.timedelta64(np.iinfo(np.int64).max, "ns"),
  148:                 ]
  149:             ),
  150:             IntervalIndex.from_tuples(
  151:                 [
  152:                     (
  153:                         np.timedelta64(-np.iinfo(np.int64).max, "ns"),
  154:                         np.timedelta64(0, "ns"),
  155:                     ),
  156:                     (
  157:                         np.timedelta64(0, "ns"),
  158:                         np.timedelta64(np.iinfo(np.int64).max, "ns"),
  159:                     ),
  160:                 ]
  161:             ),
  162:         ),
  163:     ],
  164: )
  165: def test_bins_monotonic_not_overflowing(x, bins, expected):
  166:     # GH 26045
  167:     result = cut(x, bins)
  168:     tm.assert_index_equal(result.categories, expected)
  169: 
  170: 
  171: def test_wrong_num_labels():
  172:     msg = "Bin labels must be one fewer than the number of bin edges"
  173:     data = [0.2, 1.4, 2.5, 6.2, 9.7, 2.1]
  174: 
  175:     with pytest.raises(ValueError, match=msg):
  176:         cut(data, [0, 1, 10], labels=["foo", "bar", "baz"])
  177: 
  178: 
  179: @pytest.mark.parametrize(
  180:     "x,bins,msg",
  181:     [
  182:         ([], 2, "Cannot cut empty array"),
  183:         ([1, 2, 3], 0.5, "`bins` should be a positive integer"),
  184:     ],
  185: )
  186: def test_cut_corner(x, bins, msg):
  187:     with pytest.raises(ValueError, match=msg):
  188:         cut(x, bins)
  189: 
  190: 
  191: @pytest.mark.parametrize("arg", [2, np.eye(2), DataFrame(np.eye(2))])
  192: @pytest.mark.parametrize("cut_func", [cut, qcut])
  193: def test_cut_not_1d_arg(arg, cut_func):
  194:     msg = "Input array must be 1 dimensional"
  195:     with pytest.raises(ValueError, match=msg):
  196:         cut_func(arg, 2)
  197: 
  198: 
  199: @pytest.mark.parametrize(
  200:     "data",
  201:     [
  202:         [0, 1, 2, 3, 4, np.inf],
  203:         [-np.inf, 0, 1, 2, 3, 4],
  204:         [-np.inf, 0, 1, 2, 3, 4, np.inf],
  205:     ],
  206: )
  207: def test_int_bins_with_inf(data):
  208:     # GH 24314
  209:     msg = "cannot specify integer `bins` when input data contains infinity"
  210:     with pytest.raises(ValueError, match=msg):
  211:         cut(data, bins=3)
  212: 
  213: 
  214: def test_cut_out_of_range_more():
  215:     # see gh-1511
  216:     name = "x"
  217: 
  218:     ser = Series([0, -1, 0, 1, -3], name=name)
  219:     ind = cut(ser, [0, 1], labels=False)
  220: 
  221:     exp = Series([np.nan, np.nan, np.nan, 0, np.nan], name=name)
  222:     tm.assert_series_equal(ind, exp)
  223: 
  224: 
  225: @pytest.mark.parametrize(
  226:     "right,breaks,closed",
  227:     [
  228:         (True, [-1e-3, 0.25, 0.5, 0.75, 1], "right"),
  229:         (False, [0, 0.25, 0.5, 0.75, 1 + 1e-3], "left"),
  230:     ],
  231: )
  232: def test_labels(right, breaks, closed):
  233:     arr = np.tile(np.arange(0, 1.01, 0.1), 4)
  234: 
  235:     result, bins = cut(arr, 4, retbins=True, right=right)
  236:     ex_levels = IntervalIndex.from_breaks(breaks, closed=closed)
  237:     tm.assert_index_equal(result.categories, ex_levels)
  238: 
  239: 
  240: def test_cut_pass_series_name_to_factor():
  241:     name = "foo"
  242:     ser = Series(np.random.default_rng(2).standard_normal(100), name=name)
  243: 
  244:     factor = cut(ser, 4)
  245:     assert factor.name == name
  246: 
  247: 
  248: def test_label_precision():
  249:     arr = np.arange(0, 0.73, 0.01)
  250:     result = cut(arr, 4, precision=2)
  251: 
  252:     ex_levels = IntervalIndex.from_breaks([-0.00072, 0.18, 0.36, 0.54, 0.72])
  253:     tm.assert_index_equal(result.categories, ex_levels)
  254: 
  255: 
  256: @pytest.mark.parametrize("labels", [None, False])
  257: def test_na_handling(labels):
  258:     arr = np.arange(0, 0.75, 0.01)
  259:     arr[::3] = np.nan
  260: 
  261:     result = cut(arr, 4, labels=labels)
  262:     result = np.asarray(result)
  263: 
  264:     expected = np.where(isna(arr), np.nan, result)
  265:     tm.assert_almost_equal(result, expected)
  266: 
  267: 
  268: def test_inf_handling():
  269:     data = np.arange(6)
  270:     data_ser = Series(data, dtype="int64")
  271: 
  272:     bins = [-np.inf, 2, 4, np.inf]
  273:     result = cut(data, bins)
  274:     result_ser = cut(data_ser, bins)
  275: 
  276:     ex_uniques = IntervalIndex.from_breaks(bins)
  277:     tm.assert_index_equal(result.categories, ex_uniques)
  278: 
  279:     assert result[5] == Interval(4, np.inf)
  280:     assert result[0] == Interval(-np.inf, 2)
  281:     assert result_ser[5] == Interval(4, np.inf)
  282:     assert result_ser[0] == Interval(-np.inf, 2)
  283: 
  284: 
  285: def test_cut_out_of_bounds():
  286:     arr = np.random.default_rng(2).standard_normal(100)
  287:     result = cut(arr, [-1, 0, 1])
  288: 
  289:     mask = isna(result)
  290:     ex_mask = (arr < -1) | (arr > 1)
  291:     tm.assert_numpy_array_equal(mask, ex_mask)
  292: 
  293: 
  294: @pytest.mark.parametrize(
  295:     "get_labels,get_expected",
  296:     [
  297:         (
  298:             lambda labels: labels,
  299:             lambda labels: Categorical(
  300:                 ["Medium"] + 4 * ["Small"] + ["Medium", "Large"],
  301:                 categories=labels,
  302:                 ordered=True,
  303:             ),
  304:         ),
  305:         (
  306:             lambda labels: Categorical.from_codes([0, 1, 2], labels),
  307:             lambda labels: Categorical.from_codes([1] + 4 * [0] + [1, 2], labels),
  308:         ),
  309:     ],
  310: )
  311: def test_cut_pass_labels(get_labels, get_expected):
  312:     bins = [0, 25, 50, 100]
  313:     arr = [50, 5, 10, 15, 20, 30, 70]
  314:     labels = ["Small", "Medium", "Large"]
  315: 
  316:     result = cut(arr, bins, labels=get_labels(labels))
  317:     tm.assert_categorical_equal(result, get_expected(labels))
  318: 
  319: 
  320: def test_cut_pass_labels_compat():
  321:     # see gh-16459
  322:     arr = [50, 5, 10, 15, 20, 30, 70]
  323:     labels = ["Good", "Medium", "Bad"]
  324: 
  325:     result = cut(arr, 3, labels=labels)
  326:     exp = cut(arr, 3, labels=Categorical(labels, categories=labels, ordered=True))
  327:     tm.assert_categorical_equal(result, exp)
  328: 
  329: 
  330: @pytest.mark.parametrize("x", [np.arange(11.0), np.arange(11.0) / 1e10])
  331: def test_round_frac_just_works(x):
  332:     # It works.
  333:     cut(x, 2)
  334: 
  335: 
  336: @pytest.mark.parametrize(
  337:     "val,precision,expected",
  338:     [
  339:         (-117.9998, 3, -118),
  340:         (117.9998, 3, 118),
  341:         (117.9998, 2, 118),
  342:         (0.000123456, 2, 0.00012),
  343:     ],
  344: )
  345: def test_round_frac(val, precision, expected):
  346:     # see gh-1979
  347:     result = tmod._round_frac(val, precision=precision)
  348:     assert result == expected
  349: 
  350: 
  351: def test_cut_return_intervals():
  352:     ser = Series([0, 1, 2, 3, 4, 5, 6, 7, 8])
  353:     result = cut(ser, 3)
  354: 
  355:     exp_bins = np.linspace(0, 8, num=4).round(3)
  356:     exp_bins[0] -= 0.008
  357: 
  358:     expected = Series(
  359:         IntervalIndex.from_breaks(exp_bins, closed="right").take(
  360:             [0, 0, 0, 1, 1, 1, 2, 2, 2]
  361:         )
  362:     ).astype(CategoricalDtype(ordered=True))
  363:     tm.assert_series_equal(result, expected)
  364: 
  365: 
  366: def test_series_ret_bins():
  367:     # see gh-8589
  368:     ser = Series(np.arange(4))
  369:     result, bins = cut(ser, 2, retbins=True)
  370: 
  371:     expected = Series(
  372:         IntervalIndex.from_breaks([-0.003, 1.5, 3], closed="right").repeat(2)
  373:     ).astype(CategoricalDtype(ordered=True))
  374:     tm.assert_series_equal(result, expected)
  375: 
  376: 
  377: @pytest.mark.parametrize(
  378:     "kwargs,msg",
  379:     [
  380:         ({"duplicates": "drop"}, None),
  381:         ({}, "Bin edges must be unique"),
  382:         ({"duplicates": "raise"}, "Bin edges must be unique"),
  383:         ({"duplicates": "foo"}, "invalid value for 'duplicates' parameter"),
  384:     ],
  385: )
  386: def test_cut_duplicates_bin(kwargs, msg):
  387:     # see gh-20947
  388:     bins = [0, 2, 4, 6, 10, 10]
  389:     values = Series(np.array([1, 3, 5, 7, 9]), index=["a", "b", "c", "d", "e"])
  390: 
  391:     if msg is not None:
  392:         with pytest.raises(ValueError, match=msg):
  393:             cut(values, bins, **kwargs)
  394:     else:
  395:         result = cut(values, bins, **kwargs)
  396:         expected = cut(values, pd.unique(np.asarray(bins)))
  397:         tm.assert_series_equal(result, expected)
  398: 
  399: 
  400: @pytest.mark.parametrize("data", [9.0, -9.0, 0.0])
  401: @pytest.mark.parametrize("length", [1, 2])
  402: def test_single_bin(data, length):
  403:     # see gh-14652, gh-15428
  404:     ser = Series([data] * length)
  405:     result = cut(ser, 1, labels=False)
  406: 
  407:     expected = Series([0] * length, dtype=np.intp)
  408:     tm.assert_series_equal(result, expected)
  409: 
  410: 
  411: @pytest.mark.parametrize(
  412:     "array_1_writeable,array_2_writeable", [(True, True), (True, False), (False, False)]
  413: )
  414: def test_cut_read_only(array_1_writeable, array_2_writeable):
  415:     # issue 18773
  416:     array_1 = np.arange(0, 100, 10)
  417:     array_1.flags.writeable = array_1_writeable
  418: 
  419:     array_2 = np.arange(0, 100, 10)
  420:     array_2.flags.writeable = array_2_writeable
  421: 
  422:     hundred_elements = np.arange(100)
  423:     tm.assert_categorical_equal(
  424:         cut(hundred_elements, array_1), cut(hundred_elements, array_2)
  425:     )
  426: 
  427: 
  428: @pytest.mark.parametrize(
  429:     "conv",
  430:     [
  431:         lambda v: Timestamp(v),
  432:         lambda v: to_datetime(v),
  433:         lambda v: np.datetime64(v),
  434:         lambda v: Timestamp(v).to_pydatetime(),
  435:     ],
  436: )
  437: def test_datetime_bin(conv):
  438:     data = [np.datetime64("2012-12-13"), np.datetime64("2012-12-15")]
  439:     bin_data = ["2012-12-12", "2012-12-14", "2012-12-16"]
  440: 
  441:     expected = Series(
  442:         IntervalIndex(
  443:             [
  444:                 Interval(Timestamp(bin_data[0]), Timestamp(bin_data[1])),
  445:                 Interval(Timestamp(bin_data[1]), Timestamp(bin_data[2])),
  446:             ]
  447:         )
  448:     ).astype(CategoricalDtype(ordered=True))
  449: 
  450:     bins = [conv(v) for v in bin_data]
  451:     result = Series(cut(data, bins=bins))
  452:     tm.assert_series_equal(result, expected)
  453: 
  454: 
  455: @pytest.mark.parametrize("box", [Series, Index, np.array, list])
  456: def test_datetime_cut(unit, box):
  457:     # see gh-14714
  458:     #
  459:     # Testing time data when it comes in various collection types.
  460:     data = to_datetime(["2013-01-01", "2013-01-02", "2013-01-03"]).astype(f"M8[{unit}]")
  461:     data = box(data)
  462:     result, _ = cut(data, 3, retbins=True)
  463: 
  464:     if box is list:
  465:         # We don't (yet) do inference on these, so get nanos
  466:         unit = "ns"
  467: 
  468:     if unit == "s":
  469:         # See https://github.com/pandas-dev/pandas/pull/56101#discussion_r1405325425
  470:         # for why we round to 8 seconds instead of 7
  471:         left = DatetimeIndex(
  472:             ["2012-12-31 23:57:08", "2013-01-01 16:00:00", "2013-01-02 08:00:00"],
  473:             dtype=f"M8[{unit}]",
  474:         )
  475:     else:
  476:         left = DatetimeIndex(
  477:             [
  478:                 "2012-12-31 23:57:07.200000",
  479:                 "2013-01-01 16:00:00",
  480:                 "2013-01-02 08:00:00",
  481:             ],
  482:             dtype=f"M8[{unit}]",
  483:         )
  484:     right = DatetimeIndex(
  485:         ["2013-01-01 16:00:00", "2013-01-02 08:00:00", "2013-01-03 00:00:00"],
  486:         dtype=f"M8[{unit}]",
  487:     )
  488: 
  489:     exp_intervals = IntervalIndex.from_arrays(left, right)
  490:     expected = Series(exp_intervals).astype(CategoricalDtype(ordered=True))
  491:     tm.assert_series_equal(Series(result), expected)
  492: 
  493: 
  494: @pytest.mark.parametrize("box", [list, np.array, Index, Series])
  495: def test_datetime_tz_cut_mismatched_tzawareness(box):
  496:     # GH#54964
  497:     bins = box(
  498:         [
  499:             Timestamp("2013-01-01 04:57:07.200000"),
  500:             Timestamp("2013-01-01 21:00:00"),
  501:             Timestamp("2013-01-02 13:00:00"),
  502:             Timestamp("2013-01-03 05:00:00"),
  503:         ]
  504:     )
  505:     ser = Series(date_range("20130101", periods=3, tz="US/Eastern"))
  506: 
  507:     msg = "Cannot use timezone-naive bins with timezone-aware values"
  508:     with pytest.raises(ValueError, match=msg):
  509:         cut(ser, bins)
  510: 
  511: 
  512: @pytest.mark.parametrize(
  513:     "bins",
  514:     [
  515:         3,
  516:         [
  517:             Timestamp("2013-01-01 04:57:07.200000", tz="UTC").tz_convert("US/Eastern"),
  518:             Timestamp("2013-01-01 21:00:00", tz="UTC").tz_convert("US/Eastern"),
  519:             Timestamp("2013-01-02 13:00:00", tz="UTC").tz_convert("US/Eastern"),
  520:             Timestamp("2013-01-03 05:00:00", tz="UTC").tz_convert("US/Eastern"),
  521:         ],
  522:     ],
  523: )
  524: @pytest.mark.parametrize("box", [list, np.array, Index, Series])
  525: def test_datetime_tz_cut(bins, box):
  526:     # see gh-19872
  527:     tz = "US/Eastern"
  528:     ser = Series(date_range("20130101", periods=3, tz=tz))
  529: 
  530:     if not isinstance(bins, int):
  531:         bins = box(bins)
  532: 
  533:     result = cut(ser, bins)
  534:     expected = Series(
  535:         IntervalIndex(
  536:             [
  537:                 Interval(
  538:                     Timestamp("2012-12-31 23:57:07.200000", tz=tz),
  539:                     Timestamp("2013-01-01 16:00:00", tz=tz),
  540:                 ),
  541:                 Interval(
  542:                     Timestamp("2013-01-01 16:00:00", tz=tz),
  543:                     Timestamp("2013-01-02 08:00:00", tz=tz),
  544:                 ),
  545:                 Interval(
  546:                     Timestamp("2013-01-02 08:00:00", tz=tz),
  547:                     Timestamp("2013-01-03 00:00:00", tz=tz),
  548:                 ),
  549:             ]
  550:         )
  551:     ).astype(CategoricalDtype(ordered=True))
  552:     tm.assert_series_equal(result, expected)
  553: 
  554: 
  555: def test_datetime_nan_error():
  556:     msg = "bins must be of datetime64 dtype"
  557: 
  558:     with pytest.raises(ValueError, match=msg):
  559:         cut(date_range("20130101", periods=3), bins=[0, 2, 4])
  560: 
  561: 
  562: def test_datetime_nan_mask():
  563:     result = cut(
  564:         date_range("20130102", periods=5), bins=date_range("20130101", periods=2)
  565:     )
  566: 
  567:     mask = result.categories.isna()
  568:     tm.assert_numpy_array_equal(mask, np.array([False]))
  569: 
  570:     mask = result.isna()
  571:     tm.assert_numpy_array_equal(mask, np.array([False, True, True, True, True]))
  572: 
  573: 
  574: @pytest.mark.parametrize("tz", [None, "UTC", "US/Pacific"])
  575: def test_datetime_cut_roundtrip(tz, unit):
  576:     # see gh-19891
  577:     ser = Series(date_range("20180101", periods=3, tz=tz, unit=unit))
  578:     result, result_bins = cut(ser, 2, retbins=True)
  579: 
  580:     expected = cut(ser, result_bins)
  581:     tm.assert_series_equal(result, expected)
  582: 
  583:     if unit == "s":
  584:         # TODO: constructing DatetimeIndex with dtype="M8[s]" without truncating
  585:         #  the first entry here raises in array_to_datetime. Should truncate
  586:         #  instead of raising?
  587:         # See https://github.com/pandas-dev/pandas/pull/56101#discussion_r1405325425
  588:         # for why we round to 8 seconds instead of 7
  589:         expected_bins = DatetimeIndex(
  590:             ["2017-12-31 23:57:08", "2018-01-02 00:00:00", "2018-01-03 00:00:00"],
  591:             dtype=f"M8[{unit}]",
  592:         )
  593:     else:
  594:         expected_bins = DatetimeIndex(
  595:             [
  596:                 "2017-12-31 23:57:07.200000",
  597:                 "2018-01-02 00:00:00",
  598:                 "2018-01-03 00:00:00",
  599:             ],
  600:             dtype=f"M8[{unit}]",
  601:         )
  602:     expected_bins = expected_bins.tz_localize(tz)
  603:     tm.assert_index_equal(result_bins, expected_bins)
  604: 
  605: 
  606: def test_timedelta_cut_roundtrip():
  607:     # see gh-19891
  608:     ser = Series(timedelta_range("1day", periods=3))
  609:     result, result_bins = cut(ser, 2, retbins=True)
  610: 
  611:     expected = cut(ser, result_bins)
  612:     tm.assert_series_equal(result, expected)
  613: 
  614:     expected_bins = TimedeltaIndex(
  615:         ["0 days 23:57:07.200000", "2 days 00:00:00", "3 days 00:00:00"]
  616:     )
  617:     tm.assert_index_equal(result_bins, expected_bins)
  618: 
  619: 
  620: @pytest.mark.parametrize("bins", [6, 7])
  621: @pytest.mark.parametrize(
  622:     "box, compare",
  623:     [
  624:         (Series, tm.assert_series_equal),
  625:         (np.array, tm.assert_categorical_equal),
  626:         (list, tm.assert_equal),
  627:     ],
  628: )
  629: def test_cut_bool_coercion_to_int(bins, box, compare):
  630:     # issue 20303
  631:     data_expected = box([0, 1, 1, 0, 1] * 10)
  632:     data_result = box([False, True, True, False, True] * 10)
  633:     expected = cut(data_expected, bins, duplicates="drop")
  634:     result = cut(data_result, bins, duplicates="drop")
  635:     compare(result, expected)
  636: 
  637: 
  638: @pytest.mark.parametrize("labels", ["foo", 1, True])
  639: def test_cut_incorrect_labels(labels):
  640:     # GH 13318
  641:     values = range(5)
  642:     msg = "Bin labels must either be False, None or passed in as a list-like argument"
  643:     with pytest.raises(ValueError, match=msg):
  644:         cut(values, 4, labels=labels)
  645: 
  646: 
  647: @pytest.mark.parametrize("bins", [3, [0, 5, 15]])
  648: @pytest.mark.parametrize("right", [True, False])
  649: @pytest.mark.parametrize("include_lowest", [True, False])
  650: def test_cut_nullable_integer(bins, right, include_lowest):
  651:     a = np.random.default_rng(2).integers(0, 10, size=50).astype(float)
  652:     a[::2] = np.nan
  653:     result = cut(
  654:         pd.array(a, dtype="Int64"), bins, right=right, include_lowest=include_lowest
  655:     )
  656:     expected = cut(a, bins, right=right, include_lowest=include_lowest)
  657:     tm.assert_categorical_equal(result, expected)
  658: 
  659: 
  660: @pytest.mark.parametrize(
  661:     "data, bins, labels, expected_codes, expected_labels",
  662:     [
  663:         ([15, 17, 19], [14, 16, 18, 20], ["A", "B", "A"], [0, 1, 0], ["A", "B"]),
  664:         ([1, 3, 5], [0, 2, 4, 6, 8], [2, 0, 1, 2], [2, 0, 1], [0, 1, 2]),
  665:     ],
  666: )
  667: def test_cut_non_unique_labels(data, bins, labels, expected_codes, expected_labels):
  668:     # GH 33141
  669:     result = cut(data, bins=bins, labels=labels, ordered=False)
  670:     expected = Categorical.from_codes(
  671:         expected_codes, categories=expected_labels, ordered=False
  672:     )
  673:     tm.assert_categorical_equal(result, expected)
  674: 
  675: 
  676: @pytest.mark.parametrize(
  677:     "data, bins, labels, expected_codes, expected_labels",
  678:     [
  679:         ([15, 17, 19], [14, 16, 18, 20], ["C", "B", "A"], [0, 1, 2], ["C", "B", "A"]),
  680:         ([1, 3, 5], [0, 2, 4, 6, 8], [3, 0, 1, 2], [0, 1, 2], [3, 0, 1, 2]),
  681:     ],
  682: )
  683: def test_cut_unordered_labels(data, bins, labels, expected_codes, expected_labels):
  684:     # GH 33141
  685:     result = cut(data, bins=bins, labels=labels, ordered=False)
  686:     expected = Categorical.from_codes(
  687:         expected_codes, categories=expected_labels, ordered=False
  688:     )
  689:     tm.assert_categorical_equal(result, expected)
  690: 
  691: 
  692: def test_cut_unordered_with_missing_labels_raises_error():
  693:     # GH 33141
  694:     msg = "'labels' must be provided if 'ordered = False'"
  695:     with pytest.raises(ValueError, match=msg):
  696:         cut([0.5, 3], bins=[0, 1, 2], ordered=False)
  697: 
  698: 
  699: def test_cut_unordered_with_series_labels():
  700:     # https://github.com/pandas-dev/pandas/issues/36603
  701:     ser = Series([1, 2, 3, 4, 5])
  702:     bins = Series([0, 2, 4, 6])
  703:     labels = Series(["a", "b", "c"])
  704:     result = cut(ser, bins=bins, labels=labels, ordered=False)
  705:     expected = Series(["a", "a", "b", "b", "c"], dtype="category")
  706:     tm.assert_series_equal(result, expected)
  707: 
  708: 
  709: def test_cut_no_warnings():
  710:     df = DataFrame({"value": np.random.default_rng(2).integers(0, 100, 20)})
  711:     labels = [f"{i} - {i + 9}" for i in range(0, 100, 10)]
  712:     with tm.assert_produces_warning(False):
  713:         df["group"] = cut(df.value, range(0, 105, 10), right=False, labels=labels)
  714: 
  715: 
  716: def test_cut_with_duplicated_index_lowest_included():
  717:     # GH 42185
  718:     expected = Series(
  719:         [Interval(-0.001, 2, closed="right")] * 3
  720:         + [Interval(2, 4, closed="right"), Interval(-0.001, 2, closed="right")],
  721:         index=[0, 1, 2, 3, 0],
  722:         dtype="category",
  723:     ).cat.as_ordered()
  724: 
  725:     ser = Series([0, 1, 2, 3, 0], index=[0, 1, 2, 3, 0])
  726:     result = cut(ser, bins=[0, 2, 4], include_lowest=True)
  727:     tm.assert_series_equal(result, expected)
  728: 
  729: 
  730: def test_cut_with_nonexact_categorical_indices():
  731:     # GH 42424
  732: 
  733:     ser = Series(range(100))
  734:     ser1 = cut(ser, 10).value_counts().head(5)
  735:     ser2 = cut(ser, 10).value_counts().tail(5)
  736:     result = DataFrame({"1": ser1, "2": ser2})
  737: 
  738:     index = pd.CategoricalIndex(
  739:         [
  740:             Interval(-0.099, 9.9, closed="right"),
  741:             Interval(9.9, 19.8, closed="right"),
  742:             Interval(19.8, 29.7, closed="right"),
  743:             Interval(29.7, 39.6, closed="right"),
  744:             Interval(39.6, 49.5, closed="right"),
  745:             Interval(49.5, 59.4, closed="right"),
  746:             Interval(59.4, 69.3, closed="right"),
  747:             Interval(69.3, 79.2, closed="right"),
  748:             Interval(79.2, 89.1, closed="right"),
  749:             Interval(89.1, 99, closed="right"),
  750:         ],
  751:         ordered=True,
  752:     )
  753: 
  754:     expected = DataFrame(
  755:         {"1": [10] * 5 + [np.nan] * 5, "2": [np.nan] * 5 + [10] * 5}, index=index
  756:     )
  757: 
  758:     tm.assert_frame_equal(expected, result)
  759: 
  760: 
  761: def test_cut_with_timestamp_tuple_labels():
  762:     # GH 40661
  763:     labels = [(Timestamp(10),), (Timestamp(20),), (Timestamp(30),)]
  764:     result = cut([2, 4, 6], bins=[1, 3, 5, 7], labels=labels)
  765: 
  766:     expected = Categorical.from_codes([0, 1, 2], labels, ordered=True)
  767:     tm.assert_categorical_equal(result, expected)
  768: 
  769: 
  770: def test_cut_bins_datetime_intervalindex():
  771:     # https://github.com/pandas-dev/pandas/issues/46218
  772:     bins = interval_range(Timestamp("2022-02-25"), Timestamp("2022-02-27"), freq="1D")
  773:     # passing Series instead of list is important to trigger bug
  774:     result = cut(Series([Timestamp("2022-02-26")]).astype("M8[ns]"), bins=bins)
  775:     expected = Categorical.from_codes([0], bins, ordered=True)
  776:     tm.assert_categorical_equal(result.array, expected)
  777: 
  778: 
  779: def test_cut_with_nullable_int64():
  780:     # GH 30787
  781:     series = Series([0, 1, 2, 3, 4, pd.NA, 6, 7], dtype="Int64")
  782:     bins = [0, 2, 4, 6, 8]
  783:     intervals = IntervalIndex.from_breaks(bins)
  784: 
  785:     expected = Series(
  786:         Categorical.from_codes([-1, 0, 0, 1, 1, -1, 2, 3], intervals, ordered=True)
  787:     )
  788: 
  789:     result = cut(series, bins=bins)
  790: 
  791:     tm.assert_series_equal(result, expected)
