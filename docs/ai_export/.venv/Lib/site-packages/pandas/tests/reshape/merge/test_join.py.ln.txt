    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas.util._test_decorators as td
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     Categorical,
   11:     DataFrame,
   12:     Index,
   13:     MultiIndex,
   14:     Series,
   15:     Timestamp,
   16:     bdate_range,
   17:     concat,
   18:     merge,
   19:     option_context,
   20: )
   21: import pandas._testing as tm
   22: 
   23: 
   24: def get_test_data(ngroups=8, n=50):
   25:     unique_groups = list(range(ngroups))
   26:     arr = np.asarray(np.tile(unique_groups, n // ngroups))
   27: 
   28:     if len(arr) < n:
   29:         arr = np.asarray(list(arr) + unique_groups[: n - len(arr)])
   30: 
   31:     np.random.default_rng(2).shuffle(arr)
   32:     return arr
   33: 
   34: 
   35: class TestJoin:
   36:     # aggregate multiple columns
   37:     @pytest.fixture
   38:     def df(self):
   39:         df = DataFrame(
   40:             {
   41:                 "key1": get_test_data(),
   42:                 "key2": get_test_data(),
   43:                 "data1": np.random.default_rng(2).standard_normal(50),
   44:                 "data2": np.random.default_rng(2).standard_normal(50),
   45:             }
   46:         )
   47: 
   48:         # exclude a couple keys for fun
   49:         df = df[df["key2"] > 1]
   50:         return df
   51: 
   52:     @pytest.fixture
   53:     def df2(self):
   54:         return DataFrame(
   55:             {
   56:                 "key1": get_test_data(n=10),
   57:                 "key2": get_test_data(ngroups=4, n=10),
   58:                 "value": np.random.default_rng(2).standard_normal(10),
   59:             }
   60:         )
   61: 
   62:     @pytest.fixture
   63:     def target_source(self):
   64:         data = {
   65:             "A": [0.0, 1.0, 2.0, 3.0, 4.0],
   66:             "B": [0.0, 1.0, 0.0, 1.0, 0.0],
   67:             "C": ["foo1", "foo2", "foo3", "foo4", "foo5"],
   68:             "D": bdate_range("1/1/2009", periods=5),
   69:         }
   70:         target = DataFrame(data, index=Index(["a", "b", "c", "d", "e"], dtype=object))
   71: 
   72:         # Join on string value
   73: 
   74:         source = DataFrame(
   75:             {"MergedA": data["A"], "MergedD": data["D"]}, index=data["C"]
   76:         )
   77:         return target, source
   78: 
   79:     def test_left_outer_join(self, df, df2):
   80:         joined_key2 = merge(df, df2, on="key2")
   81:         _check_join(df, df2, joined_key2, ["key2"], how="left")
   82: 
   83:         joined_both = merge(df, df2)
   84:         _check_join(df, df2, joined_both, ["key1", "key2"], how="left")
   85: 
   86:     def test_right_outer_join(self, df, df2):
   87:         joined_key2 = merge(df, df2, on="key2", how="right")
   88:         _check_join(df, df2, joined_key2, ["key2"], how="right")
   89: 
   90:         joined_both = merge(df, df2, how="right")
   91:         _check_join(df, df2, joined_both, ["key1", "key2"], how="right")
   92: 
   93:     def test_full_outer_join(self, df, df2):
   94:         joined_key2 = merge(df, df2, on="key2", how="outer")
   95:         _check_join(df, df2, joined_key2, ["key2"], how="outer")
   96: 
   97:         joined_both = merge(df, df2, how="outer")
   98:         _check_join(df, df2, joined_both, ["key1", "key2"], how="outer")
   99: 
  100:     def test_inner_join(self, df, df2):
  101:         joined_key2 = merge(df, df2, on="key2", how="inner")
  102:         _check_join(df, df2, joined_key2, ["key2"], how="inner")
  103: 
  104:         joined_both = merge(df, df2, how="inner")
  105:         _check_join(df, df2, joined_both, ["key1", "key2"], how="inner")
  106: 
  107:     def test_handle_overlap(self, df, df2):
  108:         joined = merge(df, df2, on="key2", suffixes=(".foo", ".bar"))
  109: 
  110:         assert "key1.foo" in joined
  111:         assert "key1.bar" in joined
  112: 
  113:     def test_handle_overlap_arbitrary_key(self, df, df2):
  114:         joined = merge(
  115:             df,
  116:             df2,
  117:             left_on="key2",
  118:             right_on="key1",
  119:             suffixes=(".foo", ".bar"),
  120:         )
  121:         assert "key1.foo" in joined
  122:         assert "key2.bar" in joined
  123: 
  124:     @pytest.mark.parametrize(
  125:         "infer_string", [False, pytest.param(True, marks=td.skip_if_no("pyarrow"))]
  126:     )
  127:     def test_join_on(self, target_source, infer_string):
  128:         target, source = target_source
  129: 
  130:         merged = target.join(source, on="C")
  131:         tm.assert_series_equal(merged["MergedA"], target["A"], check_names=False)
  132:         tm.assert_series_equal(merged["MergedD"], target["D"], check_names=False)
  133: 
  134:         # join with duplicates (fix regression from DataFrame/Matrix merge)
  135:         df = DataFrame({"key": ["a", "a", "b", "b", "c"]})
  136:         df2 = DataFrame({"value": [0, 1, 2]}, index=["a", "b", "c"])
  137:         joined = df.join(df2, on="key")
  138:         expected = DataFrame(
  139:             {"key": ["a", "a", "b", "b", "c"], "value": [0, 0, 1, 1, 2]}
  140:         )
  141:         tm.assert_frame_equal(joined, expected)
  142: 
  143:         # Test when some are missing
  144:         df_a = DataFrame([[1], [2], [3]], index=["a", "b", "c"], columns=["one"])
  145:         df_b = DataFrame([["foo"], ["bar"]], index=[1, 2], columns=["two"])
  146:         df_c = DataFrame([[1], [2]], index=[1, 2], columns=["three"])
  147:         joined = df_a.join(df_b, on="one")
  148:         joined = joined.join(df_c, on="one")
  149:         assert np.isnan(joined["two"]["c"])
  150:         assert np.isnan(joined["three"]["c"])
  151: 
  152:         # merge column not p resent
  153:         with pytest.raises(KeyError, match="^'E'$"):
  154:             target.join(source, on="E")
  155: 
  156:         # overlap
  157:         source_copy = source.copy()
  158:         msg = (
  159:             "You are trying to merge on float64 and object|string columns for key "
  160:             "'A'. If you wish to proceed you should use pd.concat"
  161:         )
  162:         with pytest.raises(ValueError, match=msg):
  163:             target.join(source_copy, on="A")
  164: 
  165:     def test_join_on_fails_with_different_right_index(self):
  166:         df = DataFrame(
  167:             {
  168:                 "a": np.random.default_rng(2).choice(["m", "f"], size=3),
  169:                 "b": np.random.default_rng(2).standard_normal(3),
  170:             }
  171:         )
  172:         df2 = DataFrame(
  173:             {
  174:                 "a": np.random.default_rng(2).choice(["m", "f"], size=10),
  175:                 "b": np.random.default_rng(2).standard_normal(10),
  176:             },
  177:             index=MultiIndex.from_product([range(5), ["A", "B"]]),
  178:         )
  179:         msg = r'len\(left_on\) must equal the number of levels in the index of "right"'
  180:         with pytest.raises(ValueError, match=msg):
  181:             merge(df, df2, left_on="a", right_index=True)
  182: 
  183:     def test_join_on_fails_with_different_left_index(self):
  184:         df = DataFrame(
  185:             {
  186:                 "a": np.random.default_rng(2).choice(["m", "f"], size=3),
  187:                 "b": np.random.default_rng(2).standard_normal(3),
  188:             },
  189:             index=MultiIndex.from_arrays([range(3), list("abc")]),
  190:         )
  191:         df2 = DataFrame(
  192:             {
  193:                 "a": np.random.default_rng(2).choice(["m", "f"], size=10),
  194:                 "b": np.random.default_rng(2).standard_normal(10),
  195:             }
  196:         )
  197:         msg = r'len\(right_on\) must equal the number of levels in the index of "left"'
  198:         with pytest.raises(ValueError, match=msg):
  199:             merge(df, df2, right_on="b", left_index=True)
  200: 
  201:     def test_join_on_fails_with_different_column_counts(self):
  202:         df = DataFrame(
  203:             {
  204:                 "a": np.random.default_rng(2).choice(["m", "f"], size=3),
  205:                 "b": np.random.default_rng(2).standard_normal(3),
  206:             }
  207:         )
  208:         df2 = DataFrame(
  209:             {
  210:                 "a": np.random.default_rng(2).choice(["m", "f"], size=10),
  211:                 "b": np.random.default_rng(2).standard_normal(10),
  212:             },
  213:             index=MultiIndex.from_product([range(5), ["A", "B"]]),
  214:         )
  215:         msg = r"len\(right_on\) must equal len\(left_on\)"
  216:         with pytest.raises(ValueError, match=msg):
  217:             merge(df, df2, right_on="a", left_on=["a", "b"])
  218: 
  219:     @pytest.mark.parametrize("wrong_type", [2, "str", None, np.array([0, 1])])
  220:     def test_join_on_fails_with_wrong_object_type(self, wrong_type):
  221:         # GH12081 - original issue
  222: 
  223:         # GH21220 - merging of Series and DataFrame is now allowed
  224:         # Edited test to remove the Series object from test parameters
  225: 
  226:         df = DataFrame({"a": [1, 1]})
  227:         msg = (
  228:             "Can only merge Series or DataFrame objects, "
  229:             f"a {type(wrong_type)} was passed"
  230:         )
  231:         with pytest.raises(TypeError, match=msg):
  232:             merge(wrong_type, df, left_on="a", right_on="a")
  233:         with pytest.raises(TypeError, match=msg):
  234:             merge(df, wrong_type, left_on="a", right_on="a")
  235: 
  236:     def test_join_on_pass_vector(self, target_source):
  237:         target, source = target_source
  238:         expected = target.join(source, on="C")
  239:         expected = expected.rename(columns={"C": "key_0"})
  240:         expected = expected[["key_0", "A", "B", "D", "MergedA", "MergedD"]]
  241: 
  242:         join_col = target.pop("C")
  243:         result = target.join(source, on=join_col)
  244:         tm.assert_frame_equal(result, expected)
  245: 
  246:     def test_join_with_len0(self, target_source):
  247:         # nothing to merge
  248:         target, source = target_source
  249:         merged = target.join(source.reindex([]), on="C")
  250:         for col in source:
  251:             assert col in merged
  252:             assert merged[col].isna().all()
  253: 
  254:         merged2 = target.join(source.reindex([]), on="C", how="inner")
  255:         tm.assert_index_equal(merged2.columns, merged.columns)
  256:         assert len(merged2) == 0
  257: 
  258:     def test_join_on_inner(self):
  259:         df = DataFrame({"key": ["a", "a", "d", "b", "b", "c"]})
  260:         df2 = DataFrame({"value": [0, 1]}, index=["a", "b"])
  261: 
  262:         joined = df.join(df2, on="key", how="inner")
  263: 
  264:         expected = df.join(df2, on="key")
  265:         expected = expected[expected["value"].notna()]
  266:         tm.assert_series_equal(joined["key"], expected["key"])
  267:         tm.assert_series_equal(joined["value"], expected["value"], check_dtype=False)
  268:         tm.assert_index_equal(joined.index, expected.index)
  269: 
  270:     def test_join_on_singlekey_list(self):
  271:         df = DataFrame({"key": ["a", "a", "b", "b", "c"]})
  272:         df2 = DataFrame({"value": [0, 1, 2]}, index=["a", "b", "c"])
  273: 
  274:         # corner cases
  275:         joined = df.join(df2, on=["key"])
  276:         expected = df.join(df2, on="key")
  277: 
  278:         tm.assert_frame_equal(joined, expected)
  279: 
  280:     def test_join_on_series(self, target_source):
  281:         target, source = target_source
  282:         result = target.join(source["MergedA"], on="C")
  283:         expected = target.join(source[["MergedA"]], on="C")
  284:         tm.assert_frame_equal(result, expected)
  285: 
  286:     def test_join_on_series_buglet(self):
  287:         # GH #638
  288:         df = DataFrame({"a": [1, 1]})
  289:         ds = Series([2], index=[1], name="b")
  290:         result = df.join(ds, on="a")
  291:         expected = DataFrame({"a": [1, 1], "b": [2, 2]}, index=df.index)
  292:         tm.assert_frame_equal(result, expected)
  293: 
  294:     def test_join_index_mixed(self, join_type):
  295:         # no overlapping blocks
  296:         df1 = DataFrame(index=np.arange(10))
  297:         df1["bool"] = True
  298:         df1["string"] = "foo"
  299: 
  300:         df2 = DataFrame(index=np.arange(5, 15))
  301:         df2["int"] = 1
  302:         df2["float"] = 1.0
  303: 
  304:         joined = df1.join(df2, how=join_type)
  305:         expected = _join_by_hand(df1, df2, how=join_type)
  306:         tm.assert_frame_equal(joined, expected)
  307: 
  308:         joined = df2.join(df1, how=join_type)
  309:         expected = _join_by_hand(df2, df1, how=join_type)
  310:         tm.assert_frame_equal(joined, expected)
  311: 
  312:     def test_join_index_mixed_overlap(self):
  313:         df1 = DataFrame(
  314:             {"A": 1.0, "B": 2, "C": "foo", "D": True},
  315:             index=np.arange(10),
  316:             columns=["A", "B", "C", "D"],
  317:         )
  318:         assert df1["B"].dtype == np.int64
  319:         assert df1["D"].dtype == np.bool_
  320: 
  321:         df2 = DataFrame(
  322:             {"A": 1.0, "B": 2, "C": "foo", "D": True},
  323:             index=np.arange(0, 10, 2),
  324:             columns=["A", "B", "C", "D"],
  325:         )
  326: 
  327:         # overlap
  328:         joined = df1.join(df2, lsuffix="_one", rsuffix="_two")
  329:         expected_columns = [
  330:             "A_one",
  331:             "B_one",
  332:             "C_one",
  333:             "D_one",
  334:             "A_two",
  335:             "B_two",
  336:             "C_two",
  337:             "D_two",
  338:         ]
  339:         df1.columns = expected_columns[:4]
  340:         df2.columns = expected_columns[4:]
  341:         expected = _join_by_hand(df1, df2)
  342:         tm.assert_frame_equal(joined, expected)
  343: 
  344:     def test_join_empty_bug(self):
  345:         # generated an exception in 0.4.3
  346:         x = DataFrame()
  347:         x.join(DataFrame([3], index=[0], columns=["A"]), how="outer")
  348: 
  349:     def test_join_unconsolidated(self):
  350:         # GH #331
  351:         a = DataFrame(
  352:             np.random.default_rng(2).standard_normal((30, 2)), columns=["a", "b"]
  353:         )
  354:         c = Series(np.random.default_rng(2).standard_normal(30))
  355:         a["c"] = c
  356:         d = DataFrame(np.random.default_rng(2).standard_normal((30, 1)), columns=["q"])
  357: 
  358:         # it works!
  359:         a.join(d)
  360:         d.join(a)
  361: 
  362:     def test_join_multiindex(self):
  363:         index1 = MultiIndex.from_arrays(
  364:             [["a", "a", "a", "b", "b", "b"], [1, 2, 3, 1, 2, 3]],
  365:             names=["first", "second"],
  366:         )
  367: 
  368:         index2 = MultiIndex.from_arrays(
  369:             [["b", "b", "b", "c", "c", "c"], [1, 2, 3, 1, 2, 3]],
  370:             names=["first", "second"],
  371:         )
  372: 
  373:         df1 = DataFrame(
  374:             data=np.random.default_rng(2).standard_normal(6),
  375:             index=index1,
  376:             columns=["var X"],
  377:         )
  378:         df2 = DataFrame(
  379:             data=np.random.default_rng(2).standard_normal(6),
  380:             index=index2,
  381:             columns=["var Y"],
  382:         )
  383: 
  384:         df1 = df1.sort_index(level=0)
  385:         df2 = df2.sort_index(level=0)
  386: 
  387:         joined = df1.join(df2, how="outer")
  388:         ex_index = Index(index1.values).union(Index(index2.values))
  389:         expected = df1.reindex(ex_index).join(df2.reindex(ex_index))
  390:         expected.index.names = index1.names
  391:         tm.assert_frame_equal(joined, expected)
  392:         assert joined.index.names == index1.names
  393: 
  394:         df1 = df1.sort_index(level=1)
  395:         df2 = df2.sort_index(level=1)
  396: 
  397:         joined = df1.join(df2, how="outer").sort_index(level=0)
  398:         ex_index = Index(index1.values).union(Index(index2.values))
  399:         expected = df1.reindex(ex_index).join(df2.reindex(ex_index))
  400:         expected.index.names = index1.names
  401: 
  402:         tm.assert_frame_equal(joined, expected)
  403:         assert joined.index.names == index1.names
  404: 
  405:     def test_join_inner_multiindex(self, lexsorted_two_level_string_multiindex):
  406:         key1 = ["bar", "bar", "bar", "foo", "foo", "baz", "baz", "qux", "qux", "snap"]
  407:         key2 = [
  408:             "two",
  409:             "one",
  410:             "three",
  411:             "one",
  412:             "two",
  413:             "one",
  414:             "two",
  415:             "two",
  416:             "three",
  417:             "one",
  418:         ]
  419: 
  420:         data = np.random.default_rng(2).standard_normal(len(key1))
  421:         data = DataFrame({"key1": key1, "key2": key2, "data": data})
  422: 
  423:         index = lexsorted_two_level_string_multiindex
  424:         to_join = DataFrame(
  425:             np.random.default_rng(2).standard_normal((10, 3)),
  426:             index=index,
  427:             columns=["j_one", "j_two", "j_three"],
  428:         )
  429: 
  430:         joined = data.join(to_join, on=["key1", "key2"], how="inner")
  431:         expected = merge(
  432:             data,
  433:             to_join.reset_index(),
  434:             left_on=["key1", "key2"],
  435:             right_on=["first", "second"],
  436:             how="inner",
  437:             sort=False,
  438:         )
  439: 
  440:         expected2 = merge(
  441:             to_join,
  442:             data,
  443:             right_on=["key1", "key2"],
  444:             left_index=True,
  445:             how="inner",
  446:             sort=False,
  447:         )
  448:         tm.assert_frame_equal(joined, expected2.reindex_like(joined))
  449: 
  450:         expected2 = merge(
  451:             to_join,
  452:             data,
  453:             right_on=["key1", "key2"],
  454:             left_index=True,
  455:             how="inner",
  456:             sort=False,
  457:         )
  458: 
  459:         expected = expected.drop(["first", "second"], axis=1)
  460:         expected.index = joined.index
  461: 
  462:         assert joined.index.is_monotonic_increasing
  463:         tm.assert_frame_equal(joined, expected)
  464: 
  465:         # _assert_same_contents(expected, expected2.loc[:, expected.columns])
  466: 
  467:     def test_join_hierarchical_mixed_raises(self):
  468:         # GH 2024
  469:         # GH 40993: For raising, enforced in 2.0
  470:         df = DataFrame([(1, 2, 3), (4, 5, 6)], columns=["a", "b", "c"])
  471:         new_df = df.groupby(["a"]).agg({"b": ["mean", "sum"]})
  472:         other_df = DataFrame([(1, 2, 3), (7, 10, 6)], columns=["a", "b", "d"])
  473:         other_df.set_index("a", inplace=True)
  474:         # GH 9455, 12219
  475:         with pytest.raises(
  476:             pd.errors.MergeError, match="Not allowed to merge between different levels"
  477:         ):
  478:             merge(new_df, other_df, left_index=True, right_index=True)
  479: 
  480:     def test_join_float64_float32(self):
  481:         a = DataFrame(
  482:             np.random.default_rng(2).standard_normal((10, 2)),
  483:             columns=["a", "b"],
  484:             dtype=np.float64,
  485:         )
  486:         b = DataFrame(
  487:             np.random.default_rng(2).standard_normal((10, 1)),
  488:             columns=["c"],
  489:             dtype=np.float32,
  490:         )
  491:         joined = a.join(b)
  492:         assert joined.dtypes["a"] == "float64"
  493:         assert joined.dtypes["b"] == "float64"
  494:         assert joined.dtypes["c"] == "float32"
  495: 
  496:         a = np.random.default_rng(2).integers(0, 5, 100).astype("int64")
  497:         b = np.random.default_rng(2).random(100).astype("float64")
  498:         c = np.random.default_rng(2).random(100).astype("float32")
  499:         df = DataFrame({"a": a, "b": b, "c": c})
  500:         xpdf = DataFrame({"a": a, "b": b, "c": c})
  501:         s = DataFrame(
  502:             np.random.default_rng(2).random(5).astype("float32"), columns=["md"]
  503:         )
  504:         rs = df.merge(s, left_on="a", right_index=True)
  505:         assert rs.dtypes["a"] == "int64"
  506:         assert rs.dtypes["b"] == "float64"
  507:         assert rs.dtypes["c"] == "float32"
  508:         assert rs.dtypes["md"] == "float32"
  509: 
  510:         xp = xpdf.merge(s, left_on="a", right_index=True)
  511:         tm.assert_frame_equal(rs, xp)
  512: 
  513:     def test_join_many_non_unique_index(self):
  514:         df1 = DataFrame({"a": [1, 1], "b": [1, 1], "c": [10, 20]})
  515:         df2 = DataFrame({"a": [1, 1], "b": [1, 2], "d": [100, 200]})
  516:         df3 = DataFrame({"a": [1, 1], "b": [1, 2], "e": [1000, 2000]})
  517:         idf1 = df1.set_index(["a", "b"])
  518:         idf2 = df2.set_index(["a", "b"])
  519:         idf3 = df3.set_index(["a", "b"])
  520: 
  521:         result = idf1.join([idf2, idf3], how="outer")
  522: 
  523:         df_partially_merged = merge(df1, df2, on=["a", "b"], how="outer")
  524:         expected = merge(df_partially_merged, df3, on=["a", "b"], how="outer")
  525: 
  526:         result = result.reset_index()
  527:         expected = expected[result.columns]
  528:         expected["a"] = expected.a.astype("int64")
  529:         expected["b"] = expected.b.astype("int64")
  530:         tm.assert_frame_equal(result, expected)
  531: 
  532:         df1 = DataFrame({"a": [1, 1, 1], "b": [1, 1, 1], "c": [10, 20, 30]})
  533:         df2 = DataFrame({"a": [1, 1, 1], "b": [1, 1, 2], "d": [100, 200, 300]})
  534:         df3 = DataFrame({"a": [1, 1, 1], "b": [1, 1, 2], "e": [1000, 2000, 3000]})
  535:         idf1 = df1.set_index(["a", "b"])
  536:         idf2 = df2.set_index(["a", "b"])
  537:         idf3 = df3.set_index(["a", "b"])
  538:         result = idf1.join([idf2, idf3], how="inner")
  539: 
  540:         df_partially_merged = merge(df1, df2, on=["a", "b"], how="inner")
  541:         expected = merge(df_partially_merged, df3, on=["a", "b"], how="inner")
  542: 
  543:         result = result.reset_index()
  544: 
  545:         tm.assert_frame_equal(result, expected.loc[:, result.columns])
  546: 
  547:         # GH 11519
  548:         df = DataFrame(
  549:             {
  550:                 "A": ["foo", "bar", "foo", "bar", "foo", "bar", "foo", "foo"],
  551:                 "B": ["one", "one", "two", "three", "two", "two", "one", "three"],
  552:                 "C": np.random.default_rng(2).standard_normal(8),
  553:                 "D": np.random.default_rng(2).standard_normal(8),
  554:             }
  555:         )
  556:         s = Series(
  557:             np.repeat(np.arange(8), 2), index=np.repeat(np.arange(8), 2), name="TEST"
  558:         )
  559:         inner = df.join(s, how="inner")
  560:         outer = df.join(s, how="outer")
  561:         left = df.join(s, how="left")
  562:         right = df.join(s, how="right")
  563:         tm.assert_frame_equal(inner, outer)
  564:         tm.assert_frame_equal(inner, left)
  565:         tm.assert_frame_equal(inner, right)
  566: 
  567:     @pytest.mark.parametrize(
  568:         "infer_string", [False, pytest.param(True, marks=td.skip_if_no("pyarrow"))]
  569:     )
  570:     def test_join_sort(self, infer_string):
  571:         with option_context("future.infer_string", infer_string):
  572:             left = DataFrame(
  573:                 {"key": ["foo", "bar", "baz", "foo"], "value": [1, 2, 3, 4]}
  574:             )
  575:             right = DataFrame({"value2": ["a", "b", "c"]}, index=["bar", "baz", "foo"])
  576: 
  577:             joined = left.join(right, on="key", sort=True)
  578:             expected = DataFrame(
  579:                 {
  580:                     "key": ["bar", "baz", "foo", "foo"],
  581:                     "value": [2, 3, 1, 4],
  582:                     "value2": ["a", "b", "c", "c"],
  583:                 },
  584:                 index=[1, 2, 0, 3],
  585:             )
  586:             tm.assert_frame_equal(joined, expected)
  587: 
  588:             # smoke test
  589:             joined = left.join(right, on="key", sort=False)
  590:             tm.assert_index_equal(joined.index, Index(range(4)), exact=True)
  591: 
  592:     def test_join_mixed_non_unique_index(self):
  593:         # GH 12814, unorderable types in py3 with a non-unique index
  594:         df1 = DataFrame({"a": [1, 2, 3, 4]}, index=[1, 2, 3, "a"])
  595:         df2 = DataFrame({"b": [5, 6, 7, 8]}, index=[1, 3, 3, 4])
  596:         result = df1.join(df2)
  597:         expected = DataFrame(
  598:             {"a": [1, 2, 3, 3, 4], "b": [5, np.nan, 6, 7, np.nan]},
  599:             index=[1, 2, 3, 3, "a"],
  600:         )
  601:         tm.assert_frame_equal(result, expected)
  602: 
  603:         df3 = DataFrame({"a": [1, 2, 3, 4]}, index=[1, 2, 2, "a"])
  604:         df4 = DataFrame({"b": [5, 6, 7, 8]}, index=[1, 2, 3, 4])
  605:         result = df3.join(df4)
  606:         expected = DataFrame(
  607:             {"a": [1, 2, 3, 4], "b": [5, 6, 6, np.nan]}, index=[1, 2, 2, "a"]
  608:         )
  609:         tm.assert_frame_equal(result, expected)
  610: 
  611:     def test_join_non_unique_period_index(self):
  612:         # GH #16871
  613:         index = pd.period_range("2016-01-01", periods=16, freq="M")
  614:         df = DataFrame(list(range(len(index))), index=index, columns=["pnum"])
  615:         df2 = concat([df, df])
  616:         result = df.join(df2, how="inner", rsuffix="_df2")
  617:         expected = DataFrame(
  618:             np.tile(np.arange(16, dtype=np.int64).repeat(2).reshape(-1, 1), 2),
  619:             columns=["pnum", "pnum_df2"],
  620:             index=df2.sort_index().index,
  621:         )
  622:         tm.assert_frame_equal(result, expected)
  623: 
  624:     def test_mixed_type_join_with_suffix(self):
  625:         # GH #916
  626:         df = DataFrame(
  627:             np.random.default_rng(2).standard_normal((20, 6)),
  628:             columns=["a", "b", "c", "d", "e", "f"],
  629:         )
  630:         df.insert(0, "id", 0)
  631:         df.insert(5, "dt", "foo")
  632: 
  633:         grouped = df.groupby("id")
  634:         msg = re.escape("agg function failed [how->mean,dtype->")
  635:         with pytest.raises(TypeError, match=msg):
  636:             grouped.mean()
  637:         mn = grouped.mean(numeric_only=True)
  638:         cn = grouped.count()
  639: 
  640:         # it works!
  641:         mn.join(cn, rsuffix="_right")
  642: 
  643:     def test_join_many(self):
  644:         df = DataFrame(
  645:             np.random.default_rng(2).standard_normal((10, 6)), columns=list("abcdef")
  646:         )
  647:         df_list = [df[["a", "b"]], df[["c", "d"]], df[["e", "f"]]]
  648: 
  649:         joined = df_list[0].join(df_list[1:])
  650:         tm.assert_frame_equal(joined, df)
  651: 
  652:         df_list = [df[["a", "b"]][:-2], df[["c", "d"]][2:], df[["e", "f"]][1:9]]
  653: 
  654:         def _check_diff_index(df_list, result, exp_index):
  655:             reindexed = [x.reindex(exp_index) for x in df_list]
  656:             expected = reindexed[0].join(reindexed[1:])
  657:             tm.assert_frame_equal(result, expected)
  658: 
  659:         # different join types
  660:         joined = df_list[0].join(df_list[1:], how="outer")
  661:         _check_diff_index(df_list, joined, df.index)
  662: 
  663:         joined = df_list[0].join(df_list[1:])
  664:         _check_diff_index(df_list, joined, df_list[0].index)
  665: 
  666:         joined = df_list[0].join(df_list[1:], how="inner")
  667:         _check_diff_index(df_list, joined, df.index[2:8])
  668: 
  669:         msg = "Joining multiple DataFrames only supported for joining on index"
  670:         with pytest.raises(ValueError, match=msg):
  671:             df_list[0].join(df_list[1:], on="a")
  672: 
  673:     def test_join_many_mixed(self):
  674:         df = DataFrame(
  675:             np.random.default_rng(2).standard_normal((8, 4)),
  676:             columns=["A", "B", "C", "D"],
  677:         )
  678:         df["key"] = ["foo", "bar"] * 4
  679:         df1 = df.loc[:, ["A", "B"]]
  680:         df2 = df.loc[:, ["C", "D"]]
  681:         df3 = df.loc[:, ["key"]]
  682: 
  683:         result = df1.join([df2, df3])
  684:         tm.assert_frame_equal(result, df)
  685: 
  686:     def test_join_dups(self):
  687:         # joining dups
  688:         df = concat(
  689:             [
  690:                 DataFrame(
  691:                     np.random.default_rng(2).standard_normal((10, 4)),
  692:                     columns=["A", "A", "B", "B"],
  693:                 ),
  694:                 DataFrame(
  695:                     np.random.default_rng(2).integers(0, 10, size=20).reshape(10, 2),
  696:                     columns=["A", "C"],
  697:                 ),
  698:             ],
  699:             axis=1,
  700:         )
  701: 
  702:         expected = concat([df, df], axis=1)
  703:         result = df.join(df, rsuffix="_2")
  704:         result.columns = expected.columns
  705:         tm.assert_frame_equal(result, expected)
  706: 
  707:         # GH 4975, invalid join on dups
  708:         w = DataFrame(
  709:             np.random.default_rng(2).standard_normal((4, 2)), columns=["x", "y"]
  710:         )
  711:         x = DataFrame(
  712:             np.random.default_rng(2).standard_normal((4, 2)), columns=["x", "y"]
  713:         )
  714:         y = DataFrame(
  715:             np.random.default_rng(2).standard_normal((4, 2)), columns=["x", "y"]
  716:         )
  717:         z = DataFrame(
  718:             np.random.default_rng(2).standard_normal((4, 2)), columns=["x", "y"]
  719:         )
  720: 
  721:         dta = x.merge(y, left_index=True, right_index=True).merge(
  722:             z, left_index=True, right_index=True, how="outer"
  723:         )
  724:         # GH 40991: As of 2.0 causes duplicate columns
  725:         with pytest.raises(
  726:             pd.errors.MergeError,
  727:             match="Passing 'suffixes' which cause duplicate columns",
  728:         ):
  729:             dta.merge(w, left_index=True, right_index=True)
  730: 
  731:     def test_join_multi_to_multi(self, join_type):
  732:         # GH 20475
  733:         leftindex = MultiIndex.from_product(
  734:             [list("abc"), list("xy"), [1, 2]], names=["abc", "xy", "num"]
  735:         )
  736:         left = DataFrame({"v1": range(12)}, index=leftindex)
  737: 
  738:         rightindex = MultiIndex.from_product(
  739:             [list("abc"), list("xy")], names=["abc", "xy"]
  740:         )
  741:         right = DataFrame({"v2": [100 * i for i in range(1, 7)]}, index=rightindex)
  742: 
  743:         result = left.join(right, on=["abc", "xy"], how=join_type)
  744:         expected = (
  745:             left.reset_index()
  746:             .merge(right.reset_index(), on=["abc", "xy"], how=join_type)
  747:             .set_index(["abc", "xy", "num"])
  748:         )
  749:         tm.assert_frame_equal(expected, result)
  750: 
  751:         msg = r'len\(left_on\) must equal the number of levels in the index of "right"'
  752:         with pytest.raises(ValueError, match=msg):
  753:             left.join(right, on="xy", how=join_type)
  754: 
  755:         with pytest.raises(ValueError, match=msg):
  756:             right.join(left, on=["abc", "xy"], how=join_type)
  757: 
  758:     def test_join_on_tz_aware_datetimeindex(self):
  759:         # GH 23931, 26335
  760:         df1 = DataFrame(
  761:             {
  762:                 "date": pd.date_range(
  763:                     start="2018-01-01", periods=5, tz="America/Chicago"
  764:                 ),
  765:                 "vals": list("abcde"),
  766:             }
  767:         )
  768: 
  769:         df2 = DataFrame(
  770:             {
  771:                 "date": pd.date_range(
  772:                     start="2018-01-03", periods=5, tz="America/Chicago"
  773:                 ),
  774:                 "vals_2": list("tuvwx"),
  775:             }
  776:         )
  777:         result = df1.join(df2.set_index("date"), on="date")
  778:         expected = df1.copy()
  779:         expected["vals_2"] = Series([np.nan] * 2 + list("tuv"))
  780:         tm.assert_frame_equal(result, expected)
  781: 
  782:     def test_join_datetime_string(self):
  783:         # GH 5647
  784:         dfa = DataFrame(
  785:             [
  786:                 ["2012-08-02", "L", 10],
  787:                 ["2012-08-02", "J", 15],
  788:                 ["2013-04-06", "L", 20],
  789:                 ["2013-04-06", "J", 25],
  790:             ],
  791:             columns=["x", "y", "a"],
  792:         )
  793:         dfa["x"] = pd.to_datetime(dfa["x"]).astype("M8[ns]")
  794:         dfb = DataFrame(
  795:             [["2012-08-02", "J", 1], ["2013-04-06", "L", 2]],
  796:             columns=["x", "y", "z"],
  797:             index=[2, 4],
  798:         )
  799:         dfb["x"] = pd.to_datetime(dfb["x"]).astype("M8[ns]")
  800:         result = dfb.join(dfa.set_index(["x", "y"]), on=["x", "y"])
  801:         expected = DataFrame(
  802:             [
  803:                 [Timestamp("2012-08-02 00:00:00"), "J", 1, 15],
  804:                 [Timestamp("2013-04-06 00:00:00"), "L", 2, 20],
  805:             ],
  806:             index=[2, 4],
  807:             columns=["x", "y", "z", "a"],
  808:         )
  809:         expected["x"] = expected["x"].astype("M8[ns]")
  810:         tm.assert_frame_equal(result, expected)
  811: 
  812:     def test_join_with_categorical_index(self):
  813:         # GH47812
  814:         ix = ["a", "b"]
  815:         id1 = pd.CategoricalIndex(ix, categories=ix)
  816:         id2 = pd.CategoricalIndex(reversed(ix), categories=reversed(ix))
  817: 
  818:         df1 = DataFrame({"c1": ix}, index=id1)
  819:         df2 = DataFrame({"c2": reversed(ix)}, index=id2)
  820:         result = df1.join(df2)
  821:         expected = DataFrame(
  822:             {"c1": ["a", "b"], "c2": ["a", "b"]},
  823:             index=pd.CategoricalIndex(["a", "b"], categories=["a", "b"]),
  824:         )
  825:         tm.assert_frame_equal(result, expected)
  826: 
  827: 
  828: def _check_join(left, right, result, join_col, how="left", lsuffix="_x", rsuffix="_y"):
  829:     # some smoke tests
  830:     for c in join_col:
  831:         assert result[c].notna().all()
  832: 
  833:     left_grouped = left.groupby(join_col)
  834:     right_grouped = right.groupby(join_col)
  835: 
  836:     for group_key, group in result.groupby(join_col):
  837:         l_joined = _restrict_to_columns(group, left.columns, lsuffix)
  838:         r_joined = _restrict_to_columns(group, right.columns, rsuffix)
  839: 
  840:         try:
  841:             lgroup = left_grouped.get_group(group_key)
  842:         except KeyError as err:
  843:             if how in ("left", "inner"):
  844:                 raise AssertionError(
  845:                     f"key {group_key} should not have been in the join"
  846:                 ) from err
  847: 
  848:             _assert_all_na(l_joined, left.columns, join_col)
  849:         else:
  850:             _assert_same_contents(l_joined, lgroup)
  851: 
  852:         try:
  853:             rgroup = right_grouped.get_group(group_key)
  854:         except KeyError as err:
  855:             if how in ("right", "inner"):
  856:                 raise AssertionError(
  857:                     f"key {group_key} should not have been in the join"
  858:                 ) from err
  859: 
  860:             _assert_all_na(r_joined, right.columns, join_col)
  861:         else:
  862:             _assert_same_contents(r_joined, rgroup)
  863: 
  864: 
  865: def _restrict_to_columns(group, columns, suffix):
  866:     found = [
  867:         c for c in group.columns if c in columns or c.replace(suffix, "") in columns
  868:     ]
  869: 
  870:     # filter
  871:     group = group.loc[:, found]
  872: 
  873:     # get rid of suffixes, if any
  874:     group = group.rename(columns=lambda x: x.replace(suffix, ""))
  875: 
  876:     # put in the right order...
  877:     group = group.loc[:, columns]
  878: 
  879:     return group
  880: 
  881: 
  882: def _assert_same_contents(join_chunk, source):
  883:     NA_SENTINEL = -1234567  # drop_duplicates not so NA-friendly...
  884: 
  885:     jvalues = join_chunk.fillna(NA_SENTINEL).drop_duplicates().values
  886:     svalues = source.fillna(NA_SENTINEL).drop_duplicates().values
  887: 
  888:     rows = {tuple(row) for row in jvalues}
  889:     assert len(rows) == len(source)
  890:     assert all(tuple(row) in rows for row in svalues)
  891: 
  892: 
  893: def _assert_all_na(join_chunk, source_columns, join_col):
  894:     for c in source_columns:
  895:         if c in join_col:
  896:             continue
  897:         assert join_chunk[c].isna().all()
  898: 
  899: 
  900: def _join_by_hand(a, b, how="left"):
  901:     join_index = a.index.join(b.index, how=how)
  902: 
  903:     a_re = a.reindex(join_index)
  904:     b_re = b.reindex(join_index)
  905: 
  906:     result_columns = a.columns.append(b.columns)
  907: 
  908:     for col, s in b_re.items():
  909:         a_re[col] = s
  910:     return a_re.reindex(columns=result_columns)
  911: 
  912: 
  913: def test_join_inner_multiindex_deterministic_order():
  914:     # GH: 36910
  915:     left = DataFrame(
  916:         data={"e": 5},
  917:         index=MultiIndex.from_tuples([(1, 2, 4)], names=("a", "b", "d")),
  918:     )
  919:     right = DataFrame(
  920:         data={"f": 6}, index=MultiIndex.from_tuples([(2, 3)], names=("b", "c"))
  921:     )
  922:     result = left.join(right, how="inner")
  923:     expected = DataFrame(
  924:         {"e": [5], "f": [6]},
  925:         index=MultiIndex.from_tuples([(1, 2, 4, 3)], names=("a", "b", "d", "c")),
  926:     )
  927:     tm.assert_frame_equal(result, expected)
  928: 
  929: 
  930: @pytest.mark.parametrize(
  931:     ("input_col", "output_cols"), [("b", ["a", "b"]), ("a", ["a_x", "a_y"])]
  932: )
  933: def test_join_cross(input_col, output_cols):
  934:     # GH#5401
  935:     left = DataFrame({"a": [1, 3]})
  936:     right = DataFrame({input_col: [3, 4]})
  937:     result = left.join(right, how="cross", lsuffix="_x", rsuffix="_y")
  938:     expected = DataFrame({output_cols[0]: [1, 1, 3, 3], output_cols[1]: [3, 4, 3, 4]})
  939:     tm.assert_frame_equal(result, expected)
  940: 
  941: 
  942: def test_join_multiindex_one_level(join_type):
  943:     # GH#36909
  944:     left = DataFrame(
  945:         data={"c": 3}, index=MultiIndex.from_tuples([(1, 2)], names=("a", "b"))
  946:     )
  947:     right = DataFrame(data={"d": 4}, index=MultiIndex.from_tuples([(2,)], names=("b",)))
  948:     result = left.join(right, how=join_type)
  949:     if join_type == "right":
  950:         expected = DataFrame(
  951:             {"c": [3], "d": [4]},
  952:             index=MultiIndex.from_tuples([(2, 1)], names=["b", "a"]),
  953:         )
  954:     else:
  955:         expected = DataFrame(
  956:             {"c": [3], "d": [4]},
  957:             index=MultiIndex.from_tuples([(1, 2)], names=["a", "b"]),
  958:         )
  959:     tm.assert_frame_equal(result, expected)
  960: 
  961: 
  962: @pytest.mark.parametrize(
  963:     "categories, values",
  964:     [
  965:         (["Y", "X"], ["Y", "X", "X"]),
  966:         ([2, 1], [2, 1, 1]),
  967:         ([2.5, 1.5], [2.5, 1.5, 1.5]),
  968:         (
  969:             [Timestamp("2020-12-31"), Timestamp("2019-12-31")],
  970:             [Timestamp("2020-12-31"), Timestamp("2019-12-31"), Timestamp("2019-12-31")],
  971:         ),
  972:     ],
  973: )
  974: def test_join_multiindex_not_alphabetical_categorical(categories, values):
  975:     # GH#38502
  976:     left = DataFrame(
  977:         {
  978:             "first": ["A", "A"],
  979:             "second": Categorical(categories, categories=categories),
  980:             "value": [1, 2],
  981:         }
  982:     ).set_index(["first", "second"])
  983:     right = DataFrame(
  984:         {
  985:             "first": ["A", "A", "B"],
  986:             "second": Categorical(values, categories=categories),
  987:             "value": [3, 4, 5],
  988:         }
  989:     ).set_index(["first", "second"])
  990:     result = left.join(right, lsuffix="_left", rsuffix="_right")
  991: 
  992:     expected = DataFrame(
  993:         {
  994:             "first": ["A", "A"],
  995:             "second": Categorical(categories, categories=categories),
  996:             "value_left": [1, 2],
  997:             "value_right": [3, 4],
  998:         }
  999:     ).set_index(["first", "second"])
 1000:     tm.assert_frame_equal(result, expected)
 1001: 
 1002: 
 1003: @pytest.mark.parametrize(
 1004:     "left_empty, how, exp",
 1005:     [
 1006:         (False, "left", "left"),
 1007:         (False, "right", "empty"),
 1008:         (False, "inner", "empty"),
 1009:         (False, "outer", "left"),
 1010:         (False, "cross", "empty"),
 1011:         (True, "left", "empty"),
 1012:         (True, "right", "right"),
 1013:         (True, "inner", "empty"),
 1014:         (True, "outer", "right"),
 1015:         (True, "cross", "empty"),
 1016:     ],
 1017: )
 1018: def test_join_empty(left_empty, how, exp):
 1019:     left = DataFrame({"A": [2, 1], "B": [3, 4]}, dtype="int64").set_index("A")
 1020:     right = DataFrame({"A": [1], "C": [5]}, dtype="int64").set_index("A")
 1021: 
 1022:     if left_empty:
 1023:         left = left.head(0)
 1024:     else:
 1025:         right = right.head(0)
 1026: 
 1027:     result = left.join(right, how=how)
 1028: 
 1029:     if exp == "left":
 1030:         expected = DataFrame({"A": [2, 1], "B": [3, 4], "C": [np.nan, np.nan]})
 1031:         expected = expected.set_index("A")
 1032:     elif exp == "right":
 1033:         expected = DataFrame({"B": [np.nan], "A": [1], "C": [5]})
 1034:         expected = expected.set_index("A")
 1035:     elif exp == "empty":
 1036:         expected = DataFrame(columns=["B", "C"], dtype="int64")
 1037:         if how != "cross":
 1038:             expected = expected.rename_axis("A")
 1039:     if how == "outer":
 1040:         expected = expected.sort_index()
 1041: 
 1042:     tm.assert_frame_equal(result, expected)
 1043: 
 1044: 
 1045: def test_join_empty_uncomparable_columns():
 1046:     # GH 57048
 1047:     df1 = DataFrame()
 1048:     df2 = DataFrame(columns=["test"])
 1049:     df3 = DataFrame(columns=["foo", ("bar", "baz")])
 1050: 
 1051:     result = df1 + df2
 1052:     expected = DataFrame(columns=["test"])
 1053:     tm.assert_frame_equal(result, expected)
 1054: 
 1055:     result = df2 + df3
 1056:     expected = DataFrame(columns=[("bar", "baz"), "foo", "test"])
 1057:     tm.assert_frame_equal(result, expected)
 1058: 
 1059:     result = df1 + df3
 1060:     expected = DataFrame(columns=[("bar", "baz"), "foo"])
 1061:     tm.assert_frame_equal(result, expected)
 1062: 
 1063: 
 1064: @pytest.mark.parametrize(
 1065:     "how, values",
 1066:     [
 1067:         ("inner", [0, 1, 2]),
 1068:         ("outer", [0, 1, 2]),
 1069:         ("left", [0, 1, 2]),
 1070:         ("right", [0, 2, 1]),
 1071:     ],
 1072: )
 1073: def test_join_multiindex_categorical_output_index_dtype(how, values):
 1074:     # GH#50906
 1075:     df1 = DataFrame(
 1076:         {
 1077:             "a": Categorical([0, 1, 2]),
 1078:             "b": Categorical([0, 1, 2]),
 1079:             "c": [0, 1, 2],
 1080:         }
 1081:     ).set_index(["a", "b"])
 1082: 
 1083:     df2 = DataFrame(
 1084:         {
 1085:             "a": Categorical([0, 2, 1]),
 1086:             "b": Categorical([0, 2, 1]),
 1087:             "d": [0, 2, 1],
 1088:         }
 1089:     ).set_index(["a", "b"])
 1090: 
 1091:     expected = DataFrame(
 1092:         {
 1093:             "a": Categorical(values),
 1094:             "b": Categorical(values),
 1095:             "c": values,
 1096:             "d": values,
 1097:         }
 1098:     ).set_index(["a", "b"])
 1099: 
 1100:     result = df1.join(df2, how=how)
 1101:     tm.assert_frame_equal(result, expected)
