    1: from collections import deque
    2: from datetime import (
    3:     datetime,
    4:     timezone,
    5: )
    6: from enum import Enum
    7: import functools
    8: import operator
    9: import re
   10: 
   11: import numpy as np
   12: import pytest
   13: 
   14: from pandas._config import using_pyarrow_string_dtype
   15: 
   16: import pandas.util._test_decorators as td
   17: 
   18: import pandas as pd
   19: from pandas import (
   20:     DataFrame,
   21:     Index,
   22:     MultiIndex,
   23:     Series,
   24: )
   25: import pandas._testing as tm
   26: from pandas.core.computation import expressions as expr
   27: from pandas.tests.frame.common import (
   28:     _check_mixed_float,
   29:     _check_mixed_int,
   30: )
   31: 
   32: 
   33: @pytest.fixture
   34: def simple_frame():
   35:     """
   36:     Fixture for simple 3x3 DataFrame
   37: 
   38:     Columns are ['one', 'two', 'three'], index is ['a', 'b', 'c'].
   39: 
   40:        one  two  three
   41:     a  1.0  2.0    3.0
   42:     b  4.0  5.0    6.0
   43:     c  7.0  8.0    9.0
   44:     """
   45:     arr = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
   46: 
   47:     return DataFrame(arr, columns=["one", "two", "three"], index=["a", "b", "c"])
   48: 
   49: 
   50: @pytest.fixture(autouse=True, params=[0, 100], ids=["numexpr", "python"])
   51: def switch_numexpr_min_elements(request, monkeypatch):
   52:     with monkeypatch.context() as m:
   53:         m.setattr(expr, "_MIN_ELEMENTS", request.param)
   54:         yield request.param
   55: 
   56: 
   57: class DummyElement:
   58:     def __init__(self, value, dtype) -> None:
   59:         self.value = value
   60:         self.dtype = np.dtype(dtype)
   61: 
   62:     def __array__(self, dtype=None, copy=None):
   63:         return np.array(self.value, dtype=self.dtype)
   64: 
   65:     def __str__(self) -> str:
   66:         return f"DummyElement({self.value}, {self.dtype})"
   67: 
   68:     def __repr__(self) -> str:
   69:         return str(self)
   70: 
   71:     def astype(self, dtype, copy=False):
   72:         self.dtype = dtype
   73:         return self
   74: 
   75:     def view(self, dtype):
   76:         return type(self)(self.value.view(dtype), dtype)
   77: 
   78:     def any(self, axis=None):
   79:         return bool(self.value)
   80: 
   81: 
   82: # -------------------------------------------------------------------
   83: # Comparisons
   84: 
   85: 
   86: class TestFrameComparisons:
   87:     # Specifically _not_ flex-comparisons
   88: 
   89:     def test_comparison_with_categorical_dtype(self):
   90:         # GH#12564
   91: 
   92:         df = DataFrame({"A": ["foo", "bar", "baz"]})
   93:         exp = DataFrame({"A": [True, False, False]})
   94: 
   95:         res = df == "foo"
   96:         tm.assert_frame_equal(res, exp)
   97: 
   98:         # casting to categorical shouldn't affect the result
   99:         df["A"] = df["A"].astype("category")
  100: 
  101:         res = df == "foo"
  102:         tm.assert_frame_equal(res, exp)
  103: 
  104:     def test_frame_in_list(self):
  105:         # GH#12689 this should raise at the DataFrame level, not blocks
  106:         df = DataFrame(
  107:             np.random.default_rng(2).standard_normal((6, 4)), columns=list("ABCD")
  108:         )
  109:         msg = "The truth value of a DataFrame is ambiguous"
  110:         with pytest.raises(ValueError, match=msg):
  111:             df in [None]
  112: 
  113:     @pytest.mark.parametrize(
  114:         "arg, arg2",
  115:         [
  116:             [
  117:                 {
  118:                     "a": np.random.default_rng(2).integers(10, size=10),
  119:                     "b": pd.date_range("20010101", periods=10),
  120:                 },
  121:                 {
  122:                     "a": np.random.default_rng(2).integers(10, size=10),
  123:                     "b": np.random.default_rng(2).integers(10, size=10),
  124:                 },
  125:             ],
  126:             [
  127:                 {
  128:                     "a": np.random.default_rng(2).integers(10, size=10),
  129:                     "b": np.random.default_rng(2).integers(10, size=10),
  130:                 },
  131:                 {
  132:                     "a": np.random.default_rng(2).integers(10, size=10),
  133:                     "b": pd.date_range("20010101", periods=10),
  134:                 },
  135:             ],
  136:             [
  137:                 {
  138:                     "a": pd.date_range("20010101", periods=10),
  139:                     "b": pd.date_range("20010101", periods=10),
  140:                 },
  141:                 {
  142:                     "a": np.random.default_rng(2).integers(10, size=10),
  143:                     "b": np.random.default_rng(2).integers(10, size=10),
  144:                 },
  145:             ],
  146:             [
  147:                 {
  148:                     "a": np.random.default_rng(2).integers(10, size=10),
  149:                     "b": pd.date_range("20010101", periods=10),
  150:                 },
  151:                 {
  152:                     "a": pd.date_range("20010101", periods=10),
  153:                     "b": pd.date_range("20010101", periods=10),
  154:                 },
  155:             ],
  156:         ],
  157:     )
  158:     def test_comparison_invalid(self, arg, arg2):
  159:         # GH4968
  160:         # invalid date/int comparisons
  161:         x = DataFrame(arg)
  162:         y = DataFrame(arg2)
  163:         # we expect the result to match Series comparisons for
  164:         # == and !=, inequalities should raise
  165:         result = x == y
  166:         expected = DataFrame(
  167:             {col: x[col] == y[col] for col in x.columns},
  168:             index=x.index,
  169:             columns=x.columns,
  170:         )
  171:         tm.assert_frame_equal(result, expected)
  172: 
  173:         result = x != y
  174:         expected = DataFrame(
  175:             {col: x[col] != y[col] for col in x.columns},
  176:             index=x.index,
  177:             columns=x.columns,
  178:         )
  179:         tm.assert_frame_equal(result, expected)
  180: 
  181:         msgs = [
  182:             r"Invalid comparison between dtype=datetime64\[ns\] and ndarray",
  183:             "invalid type promotion",
  184:             (
  185:                 # npdev 1.20.0
  186:                 r"The DTypes <class 'numpy.dtype\[.*\]'> and "
  187:                 r"<class 'numpy.dtype\[.*\]'> do not have a common DType."
  188:             ),
  189:         ]
  190:         msg = "|".join(msgs)
  191:         with pytest.raises(TypeError, match=msg):
  192:             x >= y
  193:         with pytest.raises(TypeError, match=msg):
  194:             x > y
  195:         with pytest.raises(TypeError, match=msg):
  196:             x < y
  197:         with pytest.raises(TypeError, match=msg):
  198:             x <= y
  199: 
  200:     @pytest.mark.parametrize(
  201:         "left, right",
  202:         [
  203:             ("gt", "lt"),
  204:             ("lt", "gt"),
  205:             ("ge", "le"),
  206:             ("le", "ge"),
  207:             ("eq", "eq"),
  208:             ("ne", "ne"),
  209:         ],
  210:     )
  211:     def test_timestamp_compare(self, left, right):
  212:         # make sure we can compare Timestamps on the right AND left hand side
  213:         # GH#4982
  214:         df = DataFrame(
  215:             {
  216:                 "dates1": pd.date_range("20010101", periods=10),
  217:                 "dates2": pd.date_range("20010102", periods=10),
  218:                 "intcol": np.random.default_rng(2).integers(1000000000, size=10),
  219:                 "floatcol": np.random.default_rng(2).standard_normal(10),
  220:                 "stringcol": [chr(100 + i) for i in range(10)],
  221:             }
  222:         )
  223:         df.loc[np.random.default_rng(2).random(len(df)) > 0.5, "dates2"] = pd.NaT
  224:         left_f = getattr(operator, left)
  225:         right_f = getattr(operator, right)
  226: 
  227:         # no nats
  228:         if left in ["eq", "ne"]:
  229:             expected = left_f(df, pd.Timestamp("20010109"))
  230:             result = right_f(pd.Timestamp("20010109"), df)
  231:             tm.assert_frame_equal(result, expected)
  232:         else:
  233:             msg = (
  234:                 "'(<|>)=?' not supported between "
  235:                 "instances of 'numpy.ndarray' and 'Timestamp'"
  236:             )
  237:             with pytest.raises(TypeError, match=msg):
  238:                 left_f(df, pd.Timestamp("20010109"))
  239:             with pytest.raises(TypeError, match=msg):
  240:                 right_f(pd.Timestamp("20010109"), df)
  241:         # nats
  242:         if left in ["eq", "ne"]:
  243:             expected = left_f(df, pd.Timestamp("nat"))
  244:             result = right_f(pd.Timestamp("nat"), df)
  245:             tm.assert_frame_equal(result, expected)
  246:         else:
  247:             msg = (
  248:                 "'(<|>)=?' not supported between "
  249:                 "instances of 'numpy.ndarray' and 'NaTType'"
  250:             )
  251:             with pytest.raises(TypeError, match=msg):
  252:                 left_f(df, pd.Timestamp("nat"))
  253:             with pytest.raises(TypeError, match=msg):
  254:                 right_f(pd.Timestamp("nat"), df)
  255: 
  256:     @pytest.mark.xfail(
  257:         using_pyarrow_string_dtype(), reason="can't compare string and int"
  258:     )
  259:     def test_mixed_comparison(self):
  260:         # GH#13128, GH#22163 != datetime64 vs non-dt64 should be False,
  261:         # not raise TypeError
  262:         # (this appears to be fixed before GH#22163, not sure when)
  263:         df = DataFrame([["1989-08-01", 1], ["1989-08-01", 2]])
  264:         other = DataFrame([["a", "b"], ["c", "d"]])
  265: 
  266:         result = df == other
  267:         assert not result.any().any()
  268: 
  269:         result = df != other
  270:         assert result.all().all()
  271: 
  272:     def test_df_boolean_comparison_error(self):
  273:         # GH#4576, GH#22880
  274:         # comparing DataFrame against list/tuple with len(obj) matching
  275:         #  len(df.columns) is supported as of GH#22800
  276:         df = DataFrame(np.arange(6).reshape((3, 2)))
  277: 
  278:         expected = DataFrame([[False, False], [True, False], [False, False]])
  279: 
  280:         result = df == (2, 2)
  281:         tm.assert_frame_equal(result, expected)
  282: 
  283:         result = df == [2, 2]
  284:         tm.assert_frame_equal(result, expected)
  285: 
  286:     def test_df_float_none_comparison(self):
  287:         df = DataFrame(
  288:             np.random.default_rng(2).standard_normal((8, 3)),
  289:             index=range(8),
  290:             columns=["A", "B", "C"],
  291:         )
  292: 
  293:         result = df.__eq__(None)
  294:         assert not result.any().any()
  295: 
  296:     def test_df_string_comparison(self):
  297:         df = DataFrame([{"a": 1, "b": "foo"}, {"a": 2, "b": "bar"}])
  298:         mask_a = df.a > 1
  299:         tm.assert_frame_equal(df[mask_a], df.loc[1:1, :])
  300:         tm.assert_frame_equal(df[-mask_a], df.loc[0:0, :])
  301: 
  302:         mask_b = df.b == "foo"
  303:         tm.assert_frame_equal(df[mask_b], df.loc[0:0, :])
  304:         tm.assert_frame_equal(df[-mask_b], df.loc[1:1, :])
  305: 
  306: 
  307: class TestFrameFlexComparisons:
  308:     # TODO: test_bool_flex_frame needs a better name
  309:     @pytest.mark.parametrize("op", ["eq", "ne", "gt", "lt", "ge", "le"])
  310:     def test_bool_flex_frame(self, op):
  311:         data = np.random.default_rng(2).standard_normal((5, 3))
  312:         other_data = np.random.default_rng(2).standard_normal((5, 3))
  313:         df = DataFrame(data)
  314:         other = DataFrame(other_data)
  315:         ndim_5 = np.ones(df.shape + (1, 3))
  316: 
  317:         # DataFrame
  318:         assert df.eq(df).values.all()
  319:         assert not df.ne(df).values.any()
  320:         f = getattr(df, op)
  321:         o = getattr(operator, op)
  322:         # No NAs
  323:         tm.assert_frame_equal(f(other), o(df, other))
  324:         # Unaligned
  325:         part_o = other.loc[3:, 1:].copy()
  326:         rs = f(part_o)
  327:         xp = o(df, part_o.reindex(index=df.index, columns=df.columns))
  328:         tm.assert_frame_equal(rs, xp)
  329:         # ndarray
  330:         tm.assert_frame_equal(f(other.values), o(df, other.values))
  331:         # scalar
  332:         tm.assert_frame_equal(f(0), o(df, 0))
  333:         # NAs
  334:         msg = "Unable to coerce to Series/DataFrame"
  335:         tm.assert_frame_equal(f(np.nan), o(df, np.nan))
  336:         with pytest.raises(ValueError, match=msg):
  337:             f(ndim_5)
  338: 
  339:     @pytest.mark.parametrize("box", [np.array, Series])
  340:     def test_bool_flex_series(self, box):
  341:         # Series
  342:         # list/tuple
  343:         data = np.random.default_rng(2).standard_normal((5, 3))
  344:         df = DataFrame(data)
  345:         idx_ser = box(np.random.default_rng(2).standard_normal(5))
  346:         col_ser = box(np.random.default_rng(2).standard_normal(3))
  347: 
  348:         idx_eq = df.eq(idx_ser, axis=0)
  349:         col_eq = df.eq(col_ser)
  350:         idx_ne = df.ne(idx_ser, axis=0)
  351:         col_ne = df.ne(col_ser)
  352:         tm.assert_frame_equal(col_eq, df == Series(col_ser))
  353:         tm.assert_frame_equal(col_eq, -col_ne)
  354:         tm.assert_frame_equal(idx_eq, -idx_ne)
  355:         tm.assert_frame_equal(idx_eq, df.T.eq(idx_ser).T)
  356:         tm.assert_frame_equal(col_eq, df.eq(list(col_ser)))
  357:         tm.assert_frame_equal(idx_eq, df.eq(Series(idx_ser), axis=0))
  358:         tm.assert_frame_equal(idx_eq, df.eq(list(idx_ser), axis=0))
  359: 
  360:         idx_gt = df.gt(idx_ser, axis=0)
  361:         col_gt = df.gt(col_ser)
  362:         idx_le = df.le(idx_ser, axis=0)
  363:         col_le = df.le(col_ser)
  364: 
  365:         tm.assert_frame_equal(col_gt, df > Series(col_ser))
  366:         tm.assert_frame_equal(col_gt, -col_le)
  367:         tm.assert_frame_equal(idx_gt, -idx_le)
  368:         tm.assert_frame_equal(idx_gt, df.T.gt(idx_ser).T)
  369: 
  370:         idx_ge = df.ge(idx_ser, axis=0)
  371:         col_ge = df.ge(col_ser)
  372:         idx_lt = df.lt(idx_ser, axis=0)
  373:         col_lt = df.lt(col_ser)
  374:         tm.assert_frame_equal(col_ge, df >= Series(col_ser))
  375:         tm.assert_frame_equal(col_ge, -col_lt)
  376:         tm.assert_frame_equal(idx_ge, -idx_lt)
  377:         tm.assert_frame_equal(idx_ge, df.T.ge(idx_ser).T)
  378: 
  379:         idx_ser = Series(np.random.default_rng(2).standard_normal(5))
  380:         col_ser = Series(np.random.default_rng(2).standard_normal(3))
  381: 
  382:     def test_bool_flex_frame_na(self):
  383:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
  384:         # NA
  385:         df.loc[0, 0] = np.nan
  386:         rs = df.eq(df)
  387:         assert not rs.loc[0, 0]
  388:         rs = df.ne(df)
  389:         assert rs.loc[0, 0]
  390:         rs = df.gt(df)
  391:         assert not rs.loc[0, 0]
  392:         rs = df.lt(df)
  393:         assert not rs.loc[0, 0]
  394:         rs = df.ge(df)
  395:         assert not rs.loc[0, 0]
  396:         rs = df.le(df)
  397:         assert not rs.loc[0, 0]
  398: 
  399:     def test_bool_flex_frame_complex_dtype(self):
  400:         # complex
  401:         arr = np.array([np.nan, 1, 6, np.nan])
  402:         arr2 = np.array([2j, np.nan, 7, None])
  403:         df = DataFrame({"a": arr})
  404:         df2 = DataFrame({"a": arr2})
  405: 
  406:         msg = "|".join(
  407:             [
  408:                 "'>' not supported between instances of '.*' and 'complex'",
  409:                 r"unorderable types: .*complex\(\)",  # PY35
  410:             ]
  411:         )
  412:         with pytest.raises(TypeError, match=msg):
  413:             # inequalities are not well-defined for complex numbers
  414:             df.gt(df2)
  415:         with pytest.raises(TypeError, match=msg):
  416:             # regression test that we get the same behavior for Series
  417:             df["a"].gt(df2["a"])
  418:         with pytest.raises(TypeError, match=msg):
  419:             # Check that we match numpy behavior here
  420:             df.values > df2.values
  421: 
  422:         rs = df.ne(df2)
  423:         assert rs.values.all()
  424: 
  425:         arr3 = np.array([2j, np.nan, None])
  426:         df3 = DataFrame({"a": arr3})
  427: 
  428:         with pytest.raises(TypeError, match=msg):
  429:             # inequalities are not well-defined for complex numbers
  430:             df3.gt(2j)
  431:         with pytest.raises(TypeError, match=msg):
  432:             # regression test that we get the same behavior for Series
  433:             df3["a"].gt(2j)
  434:         with pytest.raises(TypeError, match=msg):
  435:             # Check that we match numpy behavior here
  436:             df3.values > 2j
  437: 
  438:     def test_bool_flex_frame_object_dtype(self):
  439:         # corner, dtype=object
  440:         df1 = DataFrame({"col": ["foo", np.nan, "bar"]}, dtype=object)
  441:         df2 = DataFrame({"col": ["foo", datetime.now(), "bar"]}, dtype=object)
  442:         result = df1.ne(df2)
  443:         exp = DataFrame({"col": [False, True, False]})
  444:         tm.assert_frame_equal(result, exp)
  445: 
  446:     def test_flex_comparison_nat(self):
  447:         # GH 15697, GH 22163 df.eq(pd.NaT) should behave like df == pd.NaT,
  448:         # and _definitely_ not be NaN
  449:         df = DataFrame([pd.NaT])
  450: 
  451:         result = df == pd.NaT
  452:         # result.iloc[0, 0] is a np.bool_ object
  453:         assert result.iloc[0, 0].item() is False
  454: 
  455:         result = df.eq(pd.NaT)
  456:         assert result.iloc[0, 0].item() is False
  457: 
  458:         result = df != pd.NaT
  459:         assert result.iloc[0, 0].item() is True
  460: 
  461:         result = df.ne(pd.NaT)
  462:         assert result.iloc[0, 0].item() is True
  463: 
  464:     @pytest.mark.parametrize("opname", ["eq", "ne", "gt", "lt", "ge", "le"])
  465:     def test_df_flex_cmp_constant_return_types(self, opname):
  466:         # GH 15077, non-empty DataFrame
  467:         df = DataFrame({"x": [1, 2, 3], "y": [1.0, 2.0, 3.0]})
  468:         const = 2
  469: 
  470:         result = getattr(df, opname)(const).dtypes.value_counts()
  471:         tm.assert_series_equal(
  472:             result, Series([2], index=[np.dtype(bool)], name="count")
  473:         )
  474: 
  475:     @pytest.mark.parametrize("opname", ["eq", "ne", "gt", "lt", "ge", "le"])
  476:     def test_df_flex_cmp_constant_return_types_empty(self, opname):
  477:         # GH 15077 empty DataFrame
  478:         df = DataFrame({"x": [1, 2, 3], "y": [1.0, 2.0, 3.0]})
  479:         const = 2
  480: 
  481:         empty = df.iloc[:0]
  482:         result = getattr(empty, opname)(const).dtypes.value_counts()
  483:         tm.assert_series_equal(
  484:             result, Series([2], index=[np.dtype(bool)], name="count")
  485:         )
  486: 
  487:     def test_df_flex_cmp_ea_dtype_with_ndarray_series(self):
  488:         ii = pd.IntervalIndex.from_breaks([1, 2, 3])
  489:         df = DataFrame({"A": ii, "B": ii})
  490: 
  491:         ser = Series([0, 0])
  492:         res = df.eq(ser, axis=0)
  493: 
  494:         expected = DataFrame({"A": [False, False], "B": [False, False]})
  495:         tm.assert_frame_equal(res, expected)
  496: 
  497:         ser2 = Series([1, 2], index=["A", "B"])
  498:         res2 = df.eq(ser2, axis=1)
  499:         tm.assert_frame_equal(res2, expected)
  500: 
  501: 
  502: # -------------------------------------------------------------------
  503: # Arithmetic
  504: 
  505: 
  506: class TestFrameFlexArithmetic:
  507:     def test_floordiv_axis0(self):
  508:         # make sure we df.floordiv(ser, axis=0) matches column-wise result
  509:         arr = np.arange(3)
  510:         ser = Series(arr)
  511:         df = DataFrame({"A": ser, "B": ser})
  512: 
  513:         result = df.floordiv(ser, axis=0)
  514: 
  515:         expected = DataFrame({col: df[col] // ser for col in df.columns})
  516: 
  517:         tm.assert_frame_equal(result, expected)
  518: 
  519:         result2 = df.floordiv(ser.values, axis=0)
  520:         tm.assert_frame_equal(result2, expected)
  521: 
  522:     def test_df_add_td64_columnwise(self):
  523:         # GH 22534 Check that column-wise addition broadcasts correctly
  524:         dti = pd.date_range("2016-01-01", periods=10)
  525:         tdi = pd.timedelta_range("1", periods=10)
  526:         tser = Series(tdi)
  527:         df = DataFrame({0: dti, 1: tdi})
  528: 
  529:         result = df.add(tser, axis=0)
  530:         expected = DataFrame({0: dti + tdi, 1: tdi + tdi})
  531:         tm.assert_frame_equal(result, expected)
  532: 
  533:     def test_df_add_flex_filled_mixed_dtypes(self):
  534:         # GH 19611
  535:         dti = pd.date_range("2016-01-01", periods=3)
  536:         ser = Series(["1 Day", "NaT", "2 Days"], dtype="timedelta64[ns]")
  537:         df = DataFrame({"A": dti, "B": ser})
  538:         other = DataFrame({"A": ser, "B": ser})
  539:         fill = pd.Timedelta(days=1).to_timedelta64()
  540:         result = df.add(other, fill_value=fill)
  541: 
  542:         expected = DataFrame(
  543:             {
  544:                 "A": Series(
  545:                     ["2016-01-02", "2016-01-03", "2016-01-05"], dtype="datetime64[ns]"
  546:                 ),
  547:                 "B": ser * 2,
  548:             }
  549:         )
  550:         tm.assert_frame_equal(result, expected)
  551: 
  552:     def test_arith_flex_frame(
  553:         self, all_arithmetic_operators, float_frame, mixed_float_frame
  554:     ):
  555:         # one instance of parametrized fixture
  556:         op = all_arithmetic_operators
  557: 
  558:         def f(x, y):
  559:             # r-versions not in operator-stdlib; get op without "r" and invert
  560:             if op.startswith("__r"):
  561:                 return getattr(operator, op.replace("__r", "__"))(y, x)
  562:             return getattr(operator, op)(x, y)
  563: 
  564:         result = getattr(float_frame, op)(2 * float_frame)
  565:         expected = f(float_frame, 2 * float_frame)
  566:         tm.assert_frame_equal(result, expected)
  567: 
  568:         # vs mix float
  569:         result = getattr(mixed_float_frame, op)(2 * mixed_float_frame)
  570:         expected = f(mixed_float_frame, 2 * mixed_float_frame)
  571:         tm.assert_frame_equal(result, expected)
  572:         _check_mixed_float(result, dtype={"C": None})
  573: 
  574:     @pytest.mark.parametrize("op", ["__add__", "__sub__", "__mul__"])
  575:     def test_arith_flex_frame_mixed(
  576:         self,
  577:         op,
  578:         int_frame,
  579:         mixed_int_frame,
  580:         mixed_float_frame,
  581:         switch_numexpr_min_elements,
  582:     ):
  583:         f = getattr(operator, op)
  584: 
  585:         # vs mix int
  586:         result = getattr(mixed_int_frame, op)(2 + mixed_int_frame)
  587:         expected = f(mixed_int_frame, 2 + mixed_int_frame)
  588: 
  589:         # no overflow in the uint
  590:         dtype = None
  591:         if op in ["__sub__"]:
  592:             dtype = {"B": "uint64", "C": None}
  593:         elif op in ["__add__", "__mul__"]:
  594:             dtype = {"C": None}
  595:         if expr.USE_NUMEXPR and switch_numexpr_min_elements == 0:
  596:             # when using numexpr, the casting rules are slightly different:
  597:             # in the `2 + mixed_int_frame` operation, int32 column becomes
  598:             # and int64 column (not preserving dtype in operation with Python
  599:             # scalar), and then the int32/int64 combo results in int64 result
  600:             dtype["A"] = (2 + mixed_int_frame)["A"].dtype
  601:         tm.assert_frame_equal(result, expected)
  602:         _check_mixed_int(result, dtype=dtype)
  603: 
  604:         # vs mix float
  605:         result = getattr(mixed_float_frame, op)(2 * mixed_float_frame)
  606:         expected = f(mixed_float_frame, 2 * mixed_float_frame)
  607:         tm.assert_frame_equal(result, expected)
  608:         _check_mixed_float(result, dtype={"C": None})
  609: 
  610:         # vs plain int
  611:         result = getattr(int_frame, op)(2 * int_frame)
  612:         expected = f(int_frame, 2 * int_frame)
  613:         tm.assert_frame_equal(result, expected)
  614: 
  615:     @pytest.mark.parametrize("dim", range(3, 6))
  616:     def test_arith_flex_frame_raise(self, all_arithmetic_operators, float_frame, dim):
  617:         # one instance of parametrized fixture
  618:         op = all_arithmetic_operators
  619: 
  620:         # Check that arrays with dim >= 3 raise
  621:         arr = np.ones((1,) * dim)
  622:         msg = "Unable to coerce to Series/DataFrame"
  623:         with pytest.raises(ValueError, match=msg):
  624:             getattr(float_frame, op)(arr)
  625: 
  626:     def test_arith_flex_frame_corner(self, float_frame):
  627:         const_add = float_frame.add(1)
  628:         tm.assert_frame_equal(const_add, float_frame + 1)
  629: 
  630:         # corner cases
  631:         result = float_frame.add(float_frame[:0])
  632:         expected = float_frame.sort_index() * np.nan
  633:         tm.assert_frame_equal(result, expected)
  634: 
  635:         result = float_frame[:0].add(float_frame)
  636:         expected = float_frame.sort_index() * np.nan
  637:         tm.assert_frame_equal(result, expected)
  638: 
  639:         with pytest.raises(NotImplementedError, match="fill_value"):
  640:             float_frame.add(float_frame.iloc[0], fill_value=3)
  641: 
  642:         with pytest.raises(NotImplementedError, match="fill_value"):
  643:             float_frame.add(float_frame.iloc[0], axis="index", fill_value=3)
  644: 
  645:     @pytest.mark.parametrize("op", ["add", "sub", "mul", "mod"])
  646:     def test_arith_flex_series_ops(self, simple_frame, op):
  647:         # after arithmetic refactor, add truediv here
  648:         df = simple_frame
  649: 
  650:         row = df.xs("a")
  651:         col = df["two"]
  652:         f = getattr(df, op)
  653:         op = getattr(operator, op)
  654:         tm.assert_frame_equal(f(row), op(df, row))
  655:         tm.assert_frame_equal(f(col, axis=0), op(df.T, col).T)
  656: 
  657:     def test_arith_flex_series(self, simple_frame):
  658:         df = simple_frame
  659: 
  660:         row = df.xs("a")
  661:         col = df["two"]
  662:         # special case for some reason
  663:         tm.assert_frame_equal(df.add(row, axis=None), df + row)
  664: 
  665:         # cases which will be refactored after big arithmetic refactor
  666:         tm.assert_frame_equal(df.div(row), df / row)
  667:         tm.assert_frame_equal(df.div(col, axis=0), (df.T / col).T)
  668: 
  669:     @pytest.mark.parametrize("dtype", ["int64", "float64"])
  670:     def test_arith_flex_series_broadcasting(self, dtype):
  671:         # broadcasting issue in GH 7325
  672:         df = DataFrame(np.arange(3 * 2).reshape((3, 2)), dtype=dtype)
  673:         expected = DataFrame([[np.nan, np.inf], [1.0, 1.5], [1.0, 1.25]])
  674:         result = df.div(df[0], axis="index")
  675:         tm.assert_frame_equal(result, expected)
  676: 
  677:     def test_arith_flex_zero_len_raises(self):
  678:         # GH 19522 passing fill_value to frame flex arith methods should
  679:         # raise even in the zero-length special cases
  680:         ser_len0 = Series([], dtype=object)
  681:         df_len0 = DataFrame(columns=["A", "B"])
  682:         df = DataFrame([[1, 2], [3, 4]], columns=["A", "B"])
  683: 
  684:         with pytest.raises(NotImplementedError, match="fill_value"):
  685:             df.add(ser_len0, fill_value="E")
  686: 
  687:         with pytest.raises(NotImplementedError, match="fill_value"):
  688:             df_len0.sub(df["A"], axis=None, fill_value=3)
  689: 
  690:     def test_flex_add_scalar_fill_value(self):
  691:         # GH#12723
  692:         dat = np.array([0, 1, np.nan, 3, 4, 5], dtype="float")
  693:         df = DataFrame({"foo": dat}, index=range(6))
  694: 
  695:         exp = df.fillna(0).add(2)
  696:         res = df.add(2, fill_value=0)
  697:         tm.assert_frame_equal(res, exp)
  698: 
  699:     def test_sub_alignment_with_duplicate_index(self):
  700:         # GH#5185 dup aligning operations should work
  701:         df1 = DataFrame([1, 2, 3, 4, 5], index=[1, 2, 1, 2, 3])
  702:         df2 = DataFrame([1, 2, 3], index=[1, 2, 3])
  703:         expected = DataFrame([0, 2, 0, 2, 2], index=[1, 1, 2, 2, 3])
  704:         result = df1.sub(df2)
  705:         tm.assert_frame_equal(result, expected)
  706: 
  707:     @pytest.mark.parametrize("op", ["__add__", "__mul__", "__sub__", "__truediv__"])
  708:     def test_arithmetic_with_duplicate_columns(self, op):
  709:         # operations
  710:         df = DataFrame({"A": np.arange(10), "B": np.random.default_rng(2).random(10)})
  711:         expected = getattr(df, op)(df)
  712:         expected.columns = ["A", "A"]
  713:         df.columns = ["A", "A"]
  714:         result = getattr(df, op)(df)
  715:         tm.assert_frame_equal(result, expected)
  716: 
  717:     @pytest.mark.parametrize("level", [0, None])
  718:     def test_broadcast_multiindex(self, level):
  719:         # GH34388
  720:         df1 = DataFrame({"A": [0, 1, 2], "B": [1, 2, 3]})
  721:         df1.columns = df1.columns.set_names("L1")
  722: 
  723:         df2 = DataFrame({("A", "C"): [0, 0, 0], ("A", "D"): [0, 0, 0]})
  724:         df2.columns = df2.columns.set_names(["L1", "L2"])
  725: 
  726:         result = df1.add(df2, level=level)
  727:         expected = DataFrame({("A", "C"): [0, 1, 2], ("A", "D"): [0, 1, 2]})
  728:         expected.columns = expected.columns.set_names(["L1", "L2"])
  729: 
  730:         tm.assert_frame_equal(result, expected)
  731: 
  732:     def test_frame_multiindex_operations(self):
  733:         # GH 43321
  734:         df = DataFrame(
  735:             {2010: [1, 2, 3], 2020: [3, 4, 5]},
  736:             index=MultiIndex.from_product(
  737:                 [["a"], ["b"], [0, 1, 2]], names=["scen", "mod", "id"]
  738:             ),
  739:         )
  740: 
  741:         series = Series(
  742:             [0.4],
  743:             index=MultiIndex.from_product([["b"], ["a"]], names=["mod", "scen"]),
  744:         )
  745: 
  746:         expected = DataFrame(
  747:             {2010: [1.4, 2.4, 3.4], 2020: [3.4, 4.4, 5.4]},
  748:             index=MultiIndex.from_product(
  749:                 [["a"], ["b"], [0, 1, 2]], names=["scen", "mod", "id"]
  750:             ),
  751:         )
  752:         result = df.add(series, axis=0)
  753: 
  754:         tm.assert_frame_equal(result, expected)
  755: 
  756:     def test_frame_multiindex_operations_series_index_to_frame_index(self):
  757:         # GH 43321
  758:         df = DataFrame(
  759:             {2010: [1], 2020: [3]},
  760:             index=MultiIndex.from_product([["a"], ["b"]], names=["scen", "mod"]),
  761:         )
  762: 
  763:         series = Series(
  764:             [10.0, 20.0, 30.0],
  765:             index=MultiIndex.from_product(
  766:                 [["a"], ["b"], [0, 1, 2]], names=["scen", "mod", "id"]
  767:             ),
  768:         )
  769: 
  770:         expected = DataFrame(
  771:             {2010: [11.0, 21, 31.0], 2020: [13.0, 23.0, 33.0]},
  772:             index=MultiIndex.from_product(
  773:                 [["a"], ["b"], [0, 1, 2]], names=["scen", "mod", "id"]
  774:             ),
  775:         )
  776:         result = df.add(series, axis=0)
  777: 
  778:         tm.assert_frame_equal(result, expected)
  779: 
  780:     def test_frame_multiindex_operations_no_align(self):
  781:         df = DataFrame(
  782:             {2010: [1, 2, 3], 2020: [3, 4, 5]},
  783:             index=MultiIndex.from_product(
  784:                 [["a"], ["b"], [0, 1, 2]], names=["scen", "mod", "id"]
  785:             ),
  786:         )
  787: 
  788:         series = Series(
  789:             [0.4],
  790:             index=MultiIndex.from_product([["c"], ["a"]], names=["mod", "scen"]),
  791:         )
  792: 
  793:         expected = DataFrame(
  794:             {2010: np.nan, 2020: np.nan},
  795:             index=MultiIndex.from_tuples(
  796:                 [
  797:                     ("a", "b", 0),
  798:                     ("a", "b", 1),
  799:                     ("a", "b", 2),
  800:                     ("a", "c", np.nan),
  801:                 ],
  802:                 names=["scen", "mod", "id"],
  803:             ),
  804:         )
  805:         result = df.add(series, axis=0)
  806: 
  807:         tm.assert_frame_equal(result, expected)
  808: 
  809:     def test_frame_multiindex_operations_part_align(self):
  810:         df = DataFrame(
  811:             {2010: [1, 2, 3], 2020: [3, 4, 5]},
  812:             index=MultiIndex.from_tuples(
  813:                 [
  814:                     ("a", "b", 0),
  815:                     ("a", "b", 1),
  816:                     ("a", "c", 2),
  817:                 ],
  818:                 names=["scen", "mod", "id"],
  819:             ),
  820:         )
  821: 
  822:         series = Series(
  823:             [0.4],
  824:             index=MultiIndex.from_product([["b"], ["a"]], names=["mod", "scen"]),
  825:         )
  826: 
  827:         expected = DataFrame(
  828:             {2010: [1.4, 2.4, np.nan], 2020: [3.4, 4.4, np.nan]},
  829:             index=MultiIndex.from_tuples(
  830:                 [
  831:                     ("a", "b", 0),
  832:                     ("a", "b", 1),
  833:                     ("a", "c", 2),
  834:                 ],
  835:                 names=["scen", "mod", "id"],
  836:             ),
  837:         )
  838:         result = df.add(series, axis=0)
  839: 
  840:         tm.assert_frame_equal(result, expected)
  841: 
  842: 
  843: class TestFrameArithmetic:
  844:     def test_td64_op_nat_casting(self):
  845:         # Make sure we don't accidentally treat timedelta64(NaT) as datetime64
  846:         #  when calling dispatch_to_series in DataFrame arithmetic
  847:         ser = Series(["NaT", "NaT"], dtype="timedelta64[ns]")
  848:         df = DataFrame([[1, 2], [3, 4]])
  849: 
  850:         result = df * ser
  851:         expected = DataFrame({0: ser, 1: ser})
  852:         tm.assert_frame_equal(result, expected)
  853: 
  854:     def test_df_add_2d_array_rowlike_broadcasts(self):
  855:         # GH#23000
  856:         arr = np.arange(6).reshape(3, 2)
  857:         df = DataFrame(arr, columns=[True, False], index=["A", "B", "C"])
  858: 
  859:         rowlike = arr[[1], :]  # shape --> (1, ncols)
  860:         assert rowlike.shape == (1, df.shape[1])
  861: 
  862:         expected = DataFrame(
  863:             [[2, 4], [4, 6], [6, 8]],
  864:             columns=df.columns,
  865:             index=df.index,
  866:             # specify dtype explicitly to avoid failing
  867:             # on 32bit builds
  868:             dtype=arr.dtype,
  869:         )
  870:         result = df + rowlike
  871:         tm.assert_frame_equal(result, expected)
  872:         result = rowlike + df
  873:         tm.assert_frame_equal(result, expected)
  874: 
  875:     def test_df_add_2d_array_collike_broadcasts(self):
  876:         # GH#23000
  877:         arr = np.arange(6).reshape(3, 2)
  878:         df = DataFrame(arr, columns=[True, False], index=["A", "B", "C"])
  879: 
  880:         collike = arr[:, [1]]  # shape --> (nrows, 1)
  881:         assert collike.shape == (df.shape[0], 1)
  882: 
  883:         expected = DataFrame(
  884:             [[1, 2], [5, 6], [9, 10]],
  885:             columns=df.columns,
  886:             index=df.index,
  887:             # specify dtype explicitly to avoid failing
  888:             # on 32bit builds
  889:             dtype=arr.dtype,
  890:         )
  891:         result = df + collike
  892:         tm.assert_frame_equal(result, expected)
  893:         result = collike + df
  894:         tm.assert_frame_equal(result, expected)
  895: 
  896:     def test_df_arith_2d_array_rowlike_broadcasts(
  897:         self, request, all_arithmetic_operators, using_array_manager
  898:     ):
  899:         # GH#23000
  900:         opname = all_arithmetic_operators
  901: 
  902:         if using_array_manager and opname in ("__rmod__", "__rfloordiv__"):
  903:             # TODO(ArrayManager) decide on dtypes
  904:             td.mark_array_manager_not_yet_implemented(request)
  905: 
  906:         arr = np.arange(6).reshape(3, 2)
  907:         df = DataFrame(arr, columns=[True, False], index=["A", "B", "C"])
  908: 
  909:         rowlike = arr[[1], :]  # shape --> (1, ncols)
  910:         assert rowlike.shape == (1, df.shape[1])
  911: 
  912:         exvals = [
  913:             getattr(df.loc["A"], opname)(rowlike.squeeze()),
  914:             getattr(df.loc["B"], opname)(rowlike.squeeze()),
  915:             getattr(df.loc["C"], opname)(rowlike.squeeze()),
  916:         ]
  917: 
  918:         expected = DataFrame(exvals, columns=df.columns, index=df.index)
  919: 
  920:         result = getattr(df, opname)(rowlike)
  921:         tm.assert_frame_equal(result, expected)
  922: 
  923:     def test_df_arith_2d_array_collike_broadcasts(
  924:         self, request, all_arithmetic_operators, using_array_manager
  925:     ):
  926:         # GH#23000
  927:         opname = all_arithmetic_operators
  928: 
  929:         if using_array_manager and opname in ("__rmod__", "__rfloordiv__"):
  930:             # TODO(ArrayManager) decide on dtypes
  931:             td.mark_array_manager_not_yet_implemented(request)
  932: 
  933:         arr = np.arange(6).reshape(3, 2)
  934:         df = DataFrame(arr, columns=[True, False], index=["A", "B", "C"])
  935: 
  936:         collike = arr[:, [1]]  # shape --> (nrows, 1)
  937:         assert collike.shape == (df.shape[0], 1)
  938: 
  939:         exvals = {
  940:             True: getattr(df[True], opname)(collike.squeeze()),
  941:             False: getattr(df[False], opname)(collike.squeeze()),
  942:         }
  943: 
  944:         dtype = None
  945:         if opname in ["__rmod__", "__rfloordiv__"]:
  946:             # Series ops may return mixed int/float dtypes in cases where
  947:             #   DataFrame op will return all-float.  So we upcast `expected`
  948:             dtype = np.common_type(*(x.values for x in exvals.values()))
  949: 
  950:         expected = DataFrame(exvals, columns=df.columns, index=df.index, dtype=dtype)
  951: 
  952:         result = getattr(df, opname)(collike)
  953:         tm.assert_frame_equal(result, expected)
  954: 
  955:     def test_df_bool_mul_int(self):
  956:         # GH 22047, GH 22163 multiplication by 1 should result in int dtype,
  957:         # not object dtype
  958:         df = DataFrame([[False, True], [False, False]])
  959:         result = df * 1
  960: 
  961:         # On appveyor this comes back as np.int32 instead of np.int64,
  962:         # so we check dtype.kind instead of just dtype
  963:         kinds = result.dtypes.apply(lambda x: x.kind)
  964:         assert (kinds == "i").all()
  965: 
  966:         result = 1 * df
  967:         kinds = result.dtypes.apply(lambda x: x.kind)
  968:         assert (kinds == "i").all()
  969: 
  970:     def test_arith_mixed(self):
  971:         left = DataFrame({"A": ["a", "b", "c"], "B": [1, 2, 3]})
  972: 
  973:         result = left + left
  974:         expected = DataFrame({"A": ["aa", "bb", "cc"], "B": [2, 4, 6]})
  975:         tm.assert_frame_equal(result, expected)
  976: 
  977:     @pytest.mark.parametrize("col", ["A", "B"])
  978:     def test_arith_getitem_commute(self, all_arithmetic_functions, col):
  979:         df = DataFrame({"A": [1.1, 3.3], "B": [2.5, -3.9]})
  980:         result = all_arithmetic_functions(df, 1)[col]
  981:         expected = all_arithmetic_functions(df[col], 1)
  982:         tm.assert_series_equal(result, expected)
  983: 
  984:     @pytest.mark.parametrize(
  985:         "values", [[1, 2], (1, 2), np.array([1, 2]), range(1, 3), deque([1, 2])]
  986:     )
  987:     def test_arith_alignment_non_pandas_object(self, values):
  988:         # GH#17901
  989:         df = DataFrame({"A": [1, 1], "B": [1, 1]})
  990:         expected = DataFrame({"A": [2, 2], "B": [3, 3]})
  991:         result = df + values
  992:         tm.assert_frame_equal(result, expected)
  993: 
  994:     def test_arith_non_pandas_object(self):
  995:         df = DataFrame(
  996:             np.arange(1, 10, dtype="f8").reshape(3, 3),
  997:             columns=["one", "two", "three"],
  998:             index=["a", "b", "c"],
  999:         )
 1000: 
 1001:         val1 = df.xs("a").values
 1002:         added = DataFrame(df.values + val1, index=df.index, columns=df.columns)
 1003:         tm.assert_frame_equal(df + val1, added)
 1004: 
 1005:         added = DataFrame((df.values.T + val1).T, index=df.index, columns=df.columns)
 1006:         tm.assert_frame_equal(df.add(val1, axis=0), added)
 1007: 
 1008:         val2 = list(df["two"])
 1009: 
 1010:         added = DataFrame(df.values + val2, index=df.index, columns=df.columns)
 1011:         tm.assert_frame_equal(df + val2, added)
 1012: 
 1013:         added = DataFrame((df.values.T + val2).T, index=df.index, columns=df.columns)
 1014:         tm.assert_frame_equal(df.add(val2, axis="index"), added)
 1015: 
 1016:         val3 = np.random.default_rng(2).random(df.shape)
 1017:         added = DataFrame(df.values + val3, index=df.index, columns=df.columns)
 1018:         tm.assert_frame_equal(df.add(val3), added)
 1019: 
 1020:     def test_operations_with_interval_categories_index(self, all_arithmetic_operators):
 1021:         # GH#27415
 1022:         op = all_arithmetic_operators
 1023:         ind = pd.CategoricalIndex(pd.interval_range(start=0.0, end=2.0))
 1024:         data = [1, 2]
 1025:         df = DataFrame([data], columns=ind)
 1026:         num = 10
 1027:         result = getattr(df, op)(num)
 1028:         expected = DataFrame([[getattr(n, op)(num) for n in data]], columns=ind)
 1029:         tm.assert_frame_equal(result, expected)
 1030: 
 1031:     def test_frame_with_frame_reindex(self):
 1032:         # GH#31623
 1033:         df = DataFrame(
 1034:             {
 1035:                 "foo": [pd.Timestamp("2019"), pd.Timestamp("2020")],
 1036:                 "bar": [pd.Timestamp("2018"), pd.Timestamp("2021")],
 1037:             },
 1038:             columns=["foo", "bar"],
 1039:             dtype="M8[ns]",
 1040:         )
 1041:         df2 = df[["foo"]]
 1042: 
 1043:         result = df - df2
 1044: 
 1045:         expected = DataFrame(
 1046:             {"foo": [pd.Timedelta(0), pd.Timedelta(0)], "bar": [np.nan, np.nan]},
 1047:             columns=["bar", "foo"],
 1048:         )
 1049:         tm.assert_frame_equal(result, expected)
 1050: 
 1051:     @pytest.mark.parametrize(
 1052:         "value, dtype",
 1053:         [
 1054:             (1, "i8"),
 1055:             (1.0, "f8"),
 1056:             (2**63, "f8"),
 1057:             (1j, "complex128"),
 1058:             (2**63, "complex128"),
 1059:             (True, "bool"),
 1060:             (np.timedelta64(20, "ns"), "<m8[ns]"),
 1061:             (np.datetime64(20, "ns"), "<M8[ns]"),
 1062:         ],
 1063:     )
 1064:     @pytest.mark.parametrize(
 1065:         "op",
 1066:         [
 1067:             operator.add,
 1068:             operator.sub,
 1069:             operator.mul,
 1070:             operator.truediv,
 1071:             operator.mod,
 1072:             operator.pow,
 1073:         ],
 1074:         ids=lambda x: x.__name__,
 1075:     )
 1076:     def test_binop_other(self, op, value, dtype, switch_numexpr_min_elements):
 1077:         skip = {
 1078:             (operator.truediv, "bool"),
 1079:             (operator.pow, "bool"),
 1080:             (operator.add, "bool"),
 1081:             (operator.mul, "bool"),
 1082:         }
 1083: 
 1084:         elem = DummyElement(value, dtype)
 1085:         df = DataFrame({"A": [elem.value, elem.value]}, dtype=elem.dtype)
 1086: 
 1087:         invalid = {
 1088:             (operator.pow, "<M8[ns]"),
 1089:             (operator.mod, "<M8[ns]"),
 1090:             (operator.truediv, "<M8[ns]"),
 1091:             (operator.mul, "<M8[ns]"),
 1092:             (operator.add, "<M8[ns]"),
 1093:             (operator.pow, "<m8[ns]"),
 1094:             (operator.mul, "<m8[ns]"),
 1095:             (operator.sub, "bool"),
 1096:             (operator.mod, "complex128"),
 1097:         }
 1098: 
 1099:         if (op, dtype) in invalid:
 1100:             warn = None
 1101:             if (dtype == "<M8[ns]" and op == operator.add) or (
 1102:                 dtype == "<m8[ns]" and op == operator.mul
 1103:             ):
 1104:                 msg = None
 1105:             elif dtype == "complex128":
 1106:                 msg = "ufunc 'remainder' not supported for the input types"
 1107:             elif op is operator.sub:
 1108:                 msg = "numpy boolean subtract, the `-` operator, is "
 1109:                 if (
 1110:                     dtype == "bool"
 1111:                     and expr.USE_NUMEXPR
 1112:                     and switch_numexpr_min_elements == 0
 1113:                 ):
 1114:                     warn = UserWarning  # "evaluating in Python space because ..."
 1115:             else:
 1116:                 msg = (
 1117:                     f"cannot perform __{op.__name__}__ with this "
 1118:                     "index type: (DatetimeArray|TimedeltaArray)"
 1119:                 )
 1120: 
 1121:             with pytest.raises(TypeError, match=msg):
 1122:                 with tm.assert_produces_warning(warn):
 1123:                     op(df, elem.value)
 1124: 
 1125:         elif (op, dtype) in skip:
 1126:             if op in [operator.add, operator.mul]:
 1127:                 if expr.USE_NUMEXPR and switch_numexpr_min_elements == 0:
 1128:                     # "evaluating in Python space because ..."
 1129:                     warn = UserWarning
 1130:                 else:
 1131:                     warn = None
 1132:                 with tm.assert_produces_warning(warn):
 1133:                     op(df, elem.value)
 1134: 
 1135:             else:
 1136:                 msg = "operator '.*' not implemented for .* dtypes"
 1137:                 with pytest.raises(NotImplementedError, match=msg):
 1138:                     op(df, elem.value)
 1139: 
 1140:         else:
 1141:             with tm.assert_produces_warning(None):
 1142:                 result = op(df, elem.value).dtypes
 1143:                 expected = op(df, value).dtypes
 1144:             tm.assert_series_equal(result, expected)
 1145: 
 1146:     def test_arithmetic_midx_cols_different_dtypes(self):
 1147:         # GH#49769
 1148:         midx = MultiIndex.from_arrays([Series([1, 2]), Series([3, 4])])
 1149:         midx2 = MultiIndex.from_arrays([Series([1, 2], dtype="Int8"), Series([3, 4])])
 1150:         left = DataFrame([[1, 2], [3, 4]], columns=midx)
 1151:         right = DataFrame([[1, 2], [3, 4]], columns=midx2)
 1152:         result = left - right
 1153:         expected = DataFrame([[0, 0], [0, 0]], columns=midx)
 1154:         tm.assert_frame_equal(result, expected)
 1155: 
 1156:     def test_arithmetic_midx_cols_different_dtypes_different_order(self):
 1157:         # GH#49769
 1158:         midx = MultiIndex.from_arrays([Series([1, 2]), Series([3, 4])])
 1159:         midx2 = MultiIndex.from_arrays([Series([2, 1], dtype="Int8"), Series([4, 3])])
 1160:         left = DataFrame([[1, 2], [3, 4]], columns=midx)
 1161:         right = DataFrame([[1, 2], [3, 4]], columns=midx2)
 1162:         result = left - right
 1163:         expected = DataFrame([[-1, 1], [-1, 1]], columns=midx)
 1164:         tm.assert_frame_equal(result, expected)
 1165: 
 1166: 
 1167: def test_frame_with_zero_len_series_corner_cases():
 1168:     # GH#28600
 1169:     # easy all-float case
 1170:     df = DataFrame(
 1171:         np.random.default_rng(2).standard_normal(6).reshape(3, 2), columns=["A", "B"]
 1172:     )
 1173:     ser = Series(dtype=np.float64)
 1174: 
 1175:     result = df + ser
 1176:     expected = DataFrame(df.values * np.nan, columns=df.columns)
 1177:     tm.assert_frame_equal(result, expected)
 1178: 
 1179:     with pytest.raises(ValueError, match="not aligned"):
 1180:         # Automatic alignment for comparisons deprecated GH#36795, enforced 2.0
 1181:         df == ser
 1182: 
 1183:     # non-float case should not raise TypeError on comparison
 1184:     df2 = DataFrame(df.values.view("M8[ns]"), columns=df.columns)
 1185:     with pytest.raises(ValueError, match="not aligned"):
 1186:         # Automatic alignment for comparisons deprecated
 1187:         df2 == ser
 1188: 
 1189: 
 1190: def test_zero_len_frame_with_series_corner_cases():
 1191:     # GH#28600
 1192:     df = DataFrame(columns=["A", "B"], dtype=np.float64)
 1193:     ser = Series([1, 2], index=["A", "B"])
 1194: 
 1195:     result = df + ser
 1196:     expected = df
 1197:     tm.assert_frame_equal(result, expected)
 1198: 
 1199: 
 1200: def test_frame_single_columns_object_sum_axis_1():
 1201:     # GH 13758
 1202:     data = {
 1203:         "One": Series(["A", 1.2, np.nan]),
 1204:     }
 1205:     df = DataFrame(data)
 1206:     result = df.sum(axis=1)
 1207:     expected = Series(["A", 1.2, 0])
 1208:     tm.assert_series_equal(result, expected)
 1209: 
 1210: 
 1211: # -------------------------------------------------------------------
 1212: # Unsorted
 1213: #  These arithmetic tests were previously in other files, eventually
 1214: #  should be parametrized and put into tests.arithmetic
 1215: 
 1216: 
 1217: class TestFrameArithmeticUnsorted:
 1218:     def test_frame_add_tz_mismatch_converts_to_utc(self):
 1219:         rng = pd.date_range("1/1/2011", periods=10, freq="h", tz="US/Eastern")
 1220:         df = DataFrame(
 1221:             np.random.default_rng(2).standard_normal(len(rng)), index=rng, columns=["a"]
 1222:         )
 1223: 
 1224:         df_moscow = df.tz_convert("Europe/Moscow")
 1225:         result = df + df_moscow
 1226:         assert result.index.tz is timezone.utc
 1227: 
 1228:         result = df_moscow + df
 1229:         assert result.index.tz is timezone.utc
 1230: 
 1231:     def test_align_frame(self):
 1232:         rng = pd.period_range("1/1/2000", "1/1/2010", freq="Y")
 1233:         ts = DataFrame(
 1234:             np.random.default_rng(2).standard_normal((len(rng), 3)), index=rng
 1235:         )
 1236: 
 1237:         result = ts + ts[::2]
 1238:         expected = ts + ts
 1239:         expected.iloc[1::2] = np.nan
 1240:         tm.assert_frame_equal(result, expected)
 1241: 
 1242:         half = ts[::2]
 1243:         result = ts + half.take(np.random.default_rng(2).permutation(len(half)))
 1244:         tm.assert_frame_equal(result, expected)
 1245: 
 1246:     @pytest.mark.parametrize(
 1247:         "op", [operator.add, operator.sub, operator.mul, operator.truediv]
 1248:     )
 1249:     def test_operators_none_as_na(self, op):
 1250:         df = DataFrame(
 1251:             {"col1": [2, 5.0, 123, None], "col2": [1, 2, 3, 4]}, dtype=object
 1252:         )
 1253: 
 1254:         # since filling converts dtypes from object, changed expected to be
 1255:         # object
 1256:         msg = "Downcasting object dtype arrays"
 1257:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1258:             filled = df.fillna(np.nan)
 1259:         result = op(df, 3)
 1260:         expected = op(filled, 3).astype(object)
 1261:         expected[pd.isna(expected)] = np.nan
 1262:         tm.assert_frame_equal(result, expected)
 1263: 
 1264:         result = op(df, df)
 1265:         expected = op(filled, filled).astype(object)
 1266:         expected[pd.isna(expected)] = np.nan
 1267:         tm.assert_frame_equal(result, expected)
 1268: 
 1269:         msg = "Downcasting object dtype arrays"
 1270:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1271:             result = op(df, df.fillna(7))
 1272:         tm.assert_frame_equal(result, expected)
 1273: 
 1274:         msg = "Downcasting object dtype arrays"
 1275:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1276:             result = op(df.fillna(7), df)
 1277:         tm.assert_frame_equal(result, expected)
 1278: 
 1279:     @pytest.mark.parametrize("op,res", [("__eq__", False), ("__ne__", True)])
 1280:     # TODO: not sure what's correct here.
 1281:     @pytest.mark.filterwarnings("ignore:elementwise:FutureWarning")
 1282:     def test_logical_typeerror_with_non_valid(self, op, res, float_frame):
 1283:         # we are comparing floats vs a string
 1284:         result = getattr(float_frame, op)("foo")
 1285:         assert bool(result.all().all()) is res
 1286: 
 1287:     @pytest.mark.parametrize("op", ["add", "sub", "mul", "div", "truediv"])
 1288:     def test_binary_ops_align(self, op):
 1289:         # test aligning binary ops
 1290: 
 1291:         # GH 6681
 1292:         index = MultiIndex.from_product(
 1293:             [list("abc"), ["one", "two", "three"], [1, 2, 3]],
 1294:             names=["first", "second", "third"],
 1295:         )
 1296: 
 1297:         df = DataFrame(
 1298:             np.arange(27 * 3).reshape(27, 3),
 1299:             index=index,
 1300:             columns=["value1", "value2", "value3"],
 1301:         ).sort_index()
 1302: 
 1303:         idx = pd.IndexSlice
 1304:         opa = getattr(operator, op, None)
 1305:         if opa is None:
 1306:             return
 1307: 
 1308:         x = Series([1.0, 10.0, 100.0], [1, 2, 3])
 1309:         result = getattr(df, op)(x, level="third", axis=0)
 1310: 
 1311:         expected = pd.concat(
 1312:             [opa(df.loc[idx[:, :, i], :], v) for i, v in x.items()]
 1313:         ).sort_index()
 1314:         tm.assert_frame_equal(result, expected)
 1315: 
 1316:         x = Series([1.0, 10.0], ["two", "three"])
 1317:         result = getattr(df, op)(x, level="second", axis=0)
 1318: 
 1319:         expected = (
 1320:             pd.concat([opa(df.loc[idx[:, i], :], v) for i, v in x.items()])
 1321:             .reindex_like(df)
 1322:             .sort_index()
 1323:         )
 1324:         tm.assert_frame_equal(result, expected)
 1325: 
 1326:     def test_binary_ops_align_series_dataframe(self):
 1327:         # GH9463 (alignment level of dataframe with series)
 1328: 
 1329:         midx = MultiIndex.from_product([["A", "B"], ["a", "b"]])
 1330:         df = DataFrame(np.ones((2, 4), dtype="int64"), columns=midx)
 1331:         s = Series({"a": 1, "b": 2})
 1332: 
 1333:         df2 = df.copy()
 1334:         df2.columns.names = ["lvl0", "lvl1"]
 1335:         s2 = s.copy()
 1336:         s2.index.name = "lvl1"
 1337: 
 1338:         # different cases of integer/string level names:
 1339:         res1 = df.mul(s, axis=1, level=1)
 1340:         res2 = df.mul(s2, axis=1, level=1)
 1341:         res3 = df2.mul(s, axis=1, level=1)
 1342:         res4 = df2.mul(s2, axis=1, level=1)
 1343:         res5 = df2.mul(s, axis=1, level="lvl1")
 1344:         res6 = df2.mul(s2, axis=1, level="lvl1")
 1345: 
 1346:         exp = DataFrame(
 1347:             np.array([[1, 2, 1, 2], [1, 2, 1, 2]], dtype="int64"), columns=midx
 1348:         )
 1349: 
 1350:         for res in [res1, res2]:
 1351:             tm.assert_frame_equal(res, exp)
 1352: 
 1353:         exp.columns.names = ["lvl0", "lvl1"]
 1354:         for res in [res3, res4, res5, res6]:
 1355:             tm.assert_frame_equal(res, exp)
 1356: 
 1357:     def test_add_with_dti_mismatched_tzs(self):
 1358:         base = pd.DatetimeIndex(["2011-01-01", "2011-01-02", "2011-01-03"], tz="UTC")
 1359:         idx1 = base.tz_convert("Asia/Tokyo")[:2]
 1360:         idx2 = base.tz_convert("US/Eastern")[1:]
 1361: 
 1362:         df1 = DataFrame({"A": [1, 2]}, index=idx1)
 1363:         df2 = DataFrame({"A": [1, 1]}, index=idx2)
 1364:         exp = DataFrame({"A": [np.nan, 3, np.nan]}, index=base)
 1365:         tm.assert_frame_equal(df1 + df2, exp)
 1366: 
 1367:     def test_combineFrame(self, float_frame, mixed_float_frame, mixed_int_frame):
 1368:         frame_copy = float_frame.reindex(float_frame.index[::2])
 1369: 
 1370:         del frame_copy["D"]
 1371:         # adding NAs to first 5 values of column "C"
 1372:         frame_copy.loc[: frame_copy.index[4], "C"] = np.nan
 1373: 
 1374:         added = float_frame + frame_copy
 1375: 
 1376:         indexer = added["A"].dropna().index
 1377:         exp = (float_frame["A"] * 2).copy()
 1378: 
 1379:         tm.assert_series_equal(added["A"].dropna(), exp.loc[indexer])
 1380: 
 1381:         exp.loc[~exp.index.isin(indexer)] = np.nan
 1382:         tm.assert_series_equal(added["A"], exp.loc[added["A"].index])
 1383: 
 1384:         assert np.isnan(added["C"].reindex(frame_copy.index)[:5]).all()
 1385: 
 1386:         # assert(False)
 1387: 
 1388:         assert np.isnan(added["D"]).all()
 1389: 
 1390:         self_added = float_frame + float_frame
 1391:         tm.assert_index_equal(self_added.index, float_frame.index)
 1392: 
 1393:         added_rev = frame_copy + float_frame
 1394:         assert np.isnan(added["D"]).all()
 1395:         assert np.isnan(added_rev["D"]).all()
 1396: 
 1397:         # corner cases
 1398: 
 1399:         # empty
 1400:         plus_empty = float_frame + DataFrame()
 1401:         assert np.isnan(plus_empty.values).all()
 1402: 
 1403:         empty_plus = DataFrame() + float_frame
 1404:         assert np.isnan(empty_plus.values).all()
 1405: 
 1406:         empty_empty = DataFrame() + DataFrame()
 1407:         assert empty_empty.empty
 1408: 
 1409:         # out of order
 1410:         reverse = float_frame.reindex(columns=float_frame.columns[::-1])
 1411: 
 1412:         tm.assert_frame_equal(reverse + float_frame, float_frame * 2)
 1413: 
 1414:         # mix vs float64, upcast
 1415:         added = float_frame + mixed_float_frame
 1416:         _check_mixed_float(added, dtype="float64")
 1417:         added = mixed_float_frame + float_frame
 1418:         _check_mixed_float(added, dtype="float64")
 1419: 
 1420:         # mix vs mix
 1421:         added = mixed_float_frame + mixed_float_frame
 1422:         _check_mixed_float(added, dtype={"C": None})
 1423: 
 1424:         # with int
 1425:         added = float_frame + mixed_int_frame
 1426:         _check_mixed_float(added, dtype="float64")
 1427: 
 1428:     def test_combine_series(self, float_frame, mixed_float_frame, mixed_int_frame):
 1429:         # Series
 1430:         series = float_frame.xs(float_frame.index[0])
 1431: 
 1432:         added = float_frame + series
 1433: 
 1434:         for key, s in added.items():
 1435:             tm.assert_series_equal(s, float_frame[key] + series[key])
 1436: 
 1437:         larger_series = series.to_dict()
 1438:         larger_series["E"] = 1
 1439:         larger_series = Series(larger_series)
 1440:         larger_added = float_frame + larger_series
 1441: 
 1442:         for key, s in float_frame.items():
 1443:             tm.assert_series_equal(larger_added[key], s + series[key])
 1444:         assert "E" in larger_added
 1445:         assert np.isnan(larger_added["E"]).all()
 1446: 
 1447:         # no upcast needed
 1448:         added = mixed_float_frame + series
 1449:         assert np.all(added.dtypes == series.dtype)
 1450: 
 1451:         # vs mix (upcast) as needed
 1452:         added = mixed_float_frame + series.astype("float32")
 1453:         _check_mixed_float(added, dtype={"C": None})
 1454:         added = mixed_float_frame + series.astype("float16")
 1455:         _check_mixed_float(added, dtype={"C": None})
 1456: 
 1457:         # these used to raise with numexpr as we are adding an int64 to an
 1458:         #  uint64....weird vs int
 1459:         added = mixed_int_frame + (100 * series).astype("int64")
 1460:         _check_mixed_int(
 1461:             added, dtype={"A": "int64", "B": "float64", "C": "int64", "D": "int64"}
 1462:         )
 1463:         added = mixed_int_frame + (100 * series).astype("int32")
 1464:         _check_mixed_int(
 1465:             added, dtype={"A": "int32", "B": "float64", "C": "int32", "D": "int64"}
 1466:         )
 1467: 
 1468:     def test_combine_timeseries(self, datetime_frame):
 1469:         # TimeSeries
 1470:         ts = datetime_frame["A"]
 1471: 
 1472:         # 10890
 1473:         # we no longer allow auto timeseries broadcasting
 1474:         # and require explicit broadcasting
 1475:         added = datetime_frame.add(ts, axis="index")
 1476: 
 1477:         for key, col in datetime_frame.items():
 1478:             result = col + ts
 1479:             tm.assert_series_equal(added[key], result, check_names=False)
 1480:             assert added[key].name == key
 1481:             if col.name == ts.name:
 1482:                 assert result.name == "A"
 1483:             else:
 1484:                 assert result.name is None
 1485: 
 1486:         smaller_frame = datetime_frame[:-5]
 1487:         smaller_added = smaller_frame.add(ts, axis="index")
 1488: 
 1489:         tm.assert_index_equal(smaller_added.index, datetime_frame.index)
 1490: 
 1491:         smaller_ts = ts[:-5]
 1492:         smaller_added2 = datetime_frame.add(smaller_ts, axis="index")
 1493:         tm.assert_frame_equal(smaller_added, smaller_added2)
 1494: 
 1495:         # length 0, result is all-nan
 1496:         result = datetime_frame.add(ts[:0], axis="index")
 1497:         expected = DataFrame(
 1498:             np.nan, index=datetime_frame.index, columns=datetime_frame.columns
 1499:         )
 1500:         tm.assert_frame_equal(result, expected)
 1501: 
 1502:         # Frame is all-nan
 1503:         result = datetime_frame[:0].add(ts, axis="index")
 1504:         expected = DataFrame(
 1505:             np.nan, index=datetime_frame.index, columns=datetime_frame.columns
 1506:         )
 1507:         tm.assert_frame_equal(result, expected)
 1508: 
 1509:         # empty but with non-empty index
 1510:         frame = datetime_frame[:1].reindex(columns=[])
 1511:         result = frame.mul(ts, axis="index")
 1512:         assert len(result) == len(ts)
 1513: 
 1514:     def test_combineFunc(self, float_frame, mixed_float_frame):
 1515:         result = float_frame * 2
 1516:         tm.assert_numpy_array_equal(result.values, float_frame.values * 2)
 1517: 
 1518:         # vs mix
 1519:         result = mixed_float_frame * 2
 1520:         for c, s in result.items():
 1521:             tm.assert_numpy_array_equal(s.values, mixed_float_frame[c].values * 2)
 1522:         _check_mixed_float(result, dtype={"C": None})
 1523: 
 1524:         result = DataFrame() * 2
 1525:         assert result.index.equals(DataFrame().index)
 1526:         assert len(result.columns) == 0
 1527: 
 1528:     @pytest.mark.parametrize(
 1529:         "func",
 1530:         [operator.eq, operator.ne, operator.lt, operator.gt, operator.ge, operator.le],
 1531:     )
 1532:     def test_comparisons(self, simple_frame, float_frame, func):
 1533:         df1 = DataFrame(
 1534:             np.random.default_rng(2).standard_normal((30, 4)),
 1535:             columns=Index(list("ABCD"), dtype=object),
 1536:             index=pd.date_range("2000-01-01", periods=30, freq="B"),
 1537:         )
 1538:         df2 = df1.copy()
 1539: 
 1540:         row = simple_frame.xs("a")
 1541:         ndim_5 = np.ones(df1.shape + (1, 1, 1))
 1542: 
 1543:         result = func(df1, df2)
 1544:         tm.assert_numpy_array_equal(result.values, func(df1.values, df2.values))
 1545: 
 1546:         msg = (
 1547:             "Unable to coerce to Series/DataFrame, "
 1548:             "dimension must be <= 2: (30, 4, 1, 1, 1)"
 1549:         )
 1550:         with pytest.raises(ValueError, match=re.escape(msg)):
 1551:             func(df1, ndim_5)
 1552: 
 1553:         result2 = func(simple_frame, row)
 1554:         tm.assert_numpy_array_equal(
 1555:             result2.values, func(simple_frame.values, row.values)
 1556:         )
 1557: 
 1558:         result3 = func(float_frame, 0)
 1559:         tm.assert_numpy_array_equal(result3.values, func(float_frame.values, 0))
 1560: 
 1561:         msg = (
 1562:             r"Can only compare identically-labeled \(both index and columns\) "
 1563:             "DataFrame objects"
 1564:         )
 1565:         with pytest.raises(ValueError, match=msg):
 1566:             func(simple_frame, simple_frame[:2])
 1567: 
 1568:     def test_strings_to_numbers_comparisons_raises(self, compare_operators_no_eq_ne):
 1569:         # GH 11565
 1570:         df = DataFrame(
 1571:             {x: {"x": "foo", "y": "bar", "z": "baz"} for x in ["a", "b", "c"]}
 1572:         )
 1573: 
 1574:         f = getattr(operator, compare_operators_no_eq_ne)
 1575:         msg = "'[<>]=?' not supported between instances of 'str' and 'int'"
 1576:         with pytest.raises(TypeError, match=msg):
 1577:             f(df, 0)
 1578: 
 1579:     def test_comparison_protected_from_errstate(self):
 1580:         missing_df = DataFrame(
 1581:             np.ones((10, 4), dtype=np.float64),
 1582:             columns=Index(list("ABCD"), dtype=object),
 1583:         )
 1584:         missing_df.loc[missing_df.index[0], "A"] = np.nan
 1585:         with np.errstate(invalid="ignore"):
 1586:             expected = missing_df.values < 0
 1587:         with np.errstate(invalid="raise"):
 1588:             result = (missing_df < 0).values
 1589:         tm.assert_numpy_array_equal(result, expected)
 1590: 
 1591:     def test_boolean_comparison(self):
 1592:         # GH 4576
 1593:         # boolean comparisons with a tuple/list give unexpected results
 1594:         df = DataFrame(np.arange(6).reshape((3, 2)))
 1595:         b = np.array([2, 2])
 1596:         b_r = np.atleast_2d([2, 2])
 1597:         b_c = b_r.T
 1598:         lst = [2, 2, 2]
 1599:         tup = tuple(lst)
 1600: 
 1601:         # gt
 1602:         expected = DataFrame([[False, False], [False, True], [True, True]])
 1603:         result = df > b
 1604:         tm.assert_frame_equal(result, expected)
 1605: 
 1606:         result = df.values > b
 1607:         tm.assert_numpy_array_equal(result, expected.values)
 1608: 
 1609:         msg1d = "Unable to coerce to Series, length must be 2: given 3"
 1610:         msg2d = "Unable to coerce to DataFrame, shape must be"
 1611:         msg2db = "operands could not be broadcast together with shapes"
 1612:         with pytest.raises(ValueError, match=msg1d):
 1613:             # wrong shape
 1614:             df > lst
 1615: 
 1616:         with pytest.raises(ValueError, match=msg1d):
 1617:             # wrong shape
 1618:             df > tup
 1619: 
 1620:         # broadcasts like ndarray (GH#23000)
 1621:         result = df > b_r
 1622:         tm.assert_frame_equal(result, expected)
 1623: 
 1624:         result = df.values > b_r
 1625:         tm.assert_numpy_array_equal(result, expected.values)
 1626: 
 1627:         with pytest.raises(ValueError, match=msg2d):
 1628:             df > b_c
 1629: 
 1630:         with pytest.raises(ValueError, match=msg2db):
 1631:             df.values > b_c
 1632: 
 1633:         # ==
 1634:         expected = DataFrame([[False, False], [True, False], [False, False]])
 1635:         result = df == b
 1636:         tm.assert_frame_equal(result, expected)
 1637: 
 1638:         with pytest.raises(ValueError, match=msg1d):
 1639:             df == lst
 1640: 
 1641:         with pytest.raises(ValueError, match=msg1d):
 1642:             df == tup
 1643: 
 1644:         # broadcasts like ndarray (GH#23000)
 1645:         result = df == b_r
 1646:         tm.assert_frame_equal(result, expected)
 1647: 
 1648:         result = df.values == b_r
 1649:         tm.assert_numpy_array_equal(result, expected.values)
 1650: 
 1651:         with pytest.raises(ValueError, match=msg2d):
 1652:             df == b_c
 1653: 
 1654:         assert df.values.shape != b_c.shape
 1655: 
 1656:         # with alignment
 1657:         df = DataFrame(
 1658:             np.arange(6).reshape((3, 2)), columns=list("AB"), index=list("abc")
 1659:         )
 1660:         expected.index = df.index
 1661:         expected.columns = df.columns
 1662: 
 1663:         with pytest.raises(ValueError, match=msg1d):
 1664:             df == lst
 1665: 
 1666:         with pytest.raises(ValueError, match=msg1d):
 1667:             df == tup
 1668: 
 1669:     def test_inplace_ops_alignment(self):
 1670:         # inplace ops / ops alignment
 1671:         # GH 8511
 1672: 
 1673:         columns = list("abcdefg")
 1674:         X_orig = DataFrame(
 1675:             np.arange(10 * len(columns)).reshape(-1, len(columns)),
 1676:             columns=columns,
 1677:             index=range(10),
 1678:         )
 1679:         Z = 100 * X_orig.iloc[:, 1:-1].copy()
 1680:         block1 = list("bedcf")
 1681:         subs = list("bcdef")
 1682: 
 1683:         # add
 1684:         X = X_orig.copy()
 1685:         result1 = (X[block1] + Z).reindex(columns=subs)
 1686: 
 1687:         X[block1] += Z
 1688:         result2 = X.reindex(columns=subs)
 1689: 
 1690:         X = X_orig.copy()
 1691:         result3 = (X[block1] + Z[block1]).reindex(columns=subs)
 1692: 
 1693:         X[block1] += Z[block1]
 1694:         result4 = X.reindex(columns=subs)
 1695: 
 1696:         tm.assert_frame_equal(result1, result2)
 1697:         tm.assert_frame_equal(result1, result3)
 1698:         tm.assert_frame_equal(result1, result4)
 1699: 
 1700:         # sub
 1701:         X = X_orig.copy()
 1702:         result1 = (X[block1] - Z).reindex(columns=subs)
 1703: 
 1704:         X[block1] -= Z
 1705:         result2 = X.reindex(columns=subs)
 1706: 
 1707:         X = X_orig.copy()
 1708:         result3 = (X[block1] - Z[block1]).reindex(columns=subs)
 1709: 
 1710:         X[block1] -= Z[block1]
 1711:         result4 = X.reindex(columns=subs)
 1712: 
 1713:         tm.assert_frame_equal(result1, result2)
 1714:         tm.assert_frame_equal(result1, result3)
 1715:         tm.assert_frame_equal(result1, result4)
 1716: 
 1717:     def test_inplace_ops_identity(self):
 1718:         # GH 5104
 1719:         # make sure that we are actually changing the object
 1720:         s_orig = Series([1, 2, 3])
 1721:         df_orig = DataFrame(
 1722:             np.random.default_rng(2).integers(0, 5, size=10).reshape(-1, 5)
 1723:         )
 1724: 
 1725:         # no dtype change
 1726:         s = s_orig.copy()
 1727:         s2 = s
 1728:         s += 1
 1729:         tm.assert_series_equal(s, s2)
 1730:         tm.assert_series_equal(s_orig + 1, s)
 1731:         assert s is s2
 1732:         assert s._mgr is s2._mgr
 1733: 
 1734:         df = df_orig.copy()
 1735:         df2 = df
 1736:         df += 1
 1737:         tm.assert_frame_equal(df, df2)
 1738:         tm.assert_frame_equal(df_orig + 1, df)
 1739:         assert df is df2
 1740:         assert df._mgr is df2._mgr
 1741: 
 1742:         # dtype change
 1743:         s = s_orig.copy()
 1744:         s2 = s
 1745:         s += 1.5
 1746:         tm.assert_series_equal(s, s2)
 1747:         tm.assert_series_equal(s_orig + 1.5, s)
 1748: 
 1749:         df = df_orig.copy()
 1750:         df2 = df
 1751:         df += 1.5
 1752:         tm.assert_frame_equal(df, df2)
 1753:         tm.assert_frame_equal(df_orig + 1.5, df)
 1754:         assert df is df2
 1755:         assert df._mgr is df2._mgr
 1756: 
 1757:         # mixed dtype
 1758:         arr = np.random.default_rng(2).integers(0, 10, size=5)
 1759:         df_orig = DataFrame({"A": arr.copy(), "B": "foo"})
 1760:         df = df_orig.copy()
 1761:         df2 = df
 1762:         df["A"] += 1
 1763:         expected = DataFrame({"A": arr.copy() + 1, "B": "foo"})
 1764:         tm.assert_frame_equal(df, expected)
 1765:         tm.assert_frame_equal(df2, expected)
 1766:         assert df._mgr is df2._mgr
 1767: 
 1768:         df = df_orig.copy()
 1769:         df2 = df
 1770:         df["A"] += 1.5
 1771:         expected = DataFrame({"A": arr.copy() + 1.5, "B": "foo"})
 1772:         tm.assert_frame_equal(df, expected)
 1773:         tm.assert_frame_equal(df2, expected)
 1774:         assert df._mgr is df2._mgr
 1775: 
 1776:     @pytest.mark.parametrize(
 1777:         "op",
 1778:         [
 1779:             "add",
 1780:             "and",
 1781:             pytest.param(
 1782:                 "div",
 1783:                 marks=pytest.mark.xfail(
 1784:                     raises=AttributeError, reason="__idiv__ not implemented"
 1785:                 ),
 1786:             ),
 1787:             "floordiv",
 1788:             "mod",
 1789:             "mul",
 1790:             "or",
 1791:             "pow",
 1792:             "sub",
 1793:             "truediv",
 1794:             "xor",
 1795:         ],
 1796:     )
 1797:     def test_inplace_ops_identity2(self, op):
 1798:         df = DataFrame({"a": [1.0, 2.0, 3.0], "b": [1, 2, 3]})
 1799: 
 1800:         operand = 2
 1801:         if op in ("and", "or", "xor"):
 1802:             # cannot use floats for boolean ops
 1803:             df["a"] = [True, False, True]
 1804: 
 1805:         df_copy = df.copy()
 1806:         iop = f"__i{op}__"
 1807:         op = f"__{op}__"
 1808: 
 1809:         # no id change and value is correct
 1810:         getattr(df, iop)(operand)
 1811:         expected = getattr(df_copy, op)(operand)
 1812:         tm.assert_frame_equal(df, expected)
 1813:         expected = id(df)
 1814:         assert id(df) == expected
 1815: 
 1816:     @pytest.mark.parametrize(
 1817:         "val",
 1818:         [
 1819:             [1, 2, 3],
 1820:             (1, 2, 3),
 1821:             np.array([1, 2, 3], dtype=np.int64),
 1822:             range(1, 4),
 1823:         ],
 1824:     )
 1825:     def test_alignment_non_pandas(self, val):
 1826:         index = ["A", "B", "C"]
 1827:         columns = ["X", "Y", "Z"]
 1828:         df = DataFrame(
 1829:             np.random.default_rng(2).standard_normal((3, 3)),
 1830:             index=index,
 1831:             columns=columns,
 1832:         )
 1833: 
 1834:         align = DataFrame._align_for_op
 1835: 
 1836:         expected = DataFrame({"X": val, "Y": val, "Z": val}, index=df.index)
 1837:         tm.assert_frame_equal(align(df, val, axis=0)[1], expected)
 1838: 
 1839:         expected = DataFrame(
 1840:             {"X": [1, 1, 1], "Y": [2, 2, 2], "Z": [3, 3, 3]}, index=df.index
 1841:         )
 1842:         tm.assert_frame_equal(align(df, val, axis=1)[1], expected)
 1843: 
 1844:     @pytest.mark.parametrize("val", [[1, 2], (1, 2), np.array([1, 2]), range(1, 3)])
 1845:     def test_alignment_non_pandas_length_mismatch(self, val):
 1846:         index = ["A", "B", "C"]
 1847:         columns = ["X", "Y", "Z"]
 1848:         df = DataFrame(
 1849:             np.random.default_rng(2).standard_normal((3, 3)),
 1850:             index=index,
 1851:             columns=columns,
 1852:         )
 1853: 
 1854:         align = DataFrame._align_for_op
 1855:         # length mismatch
 1856:         msg = "Unable to coerce to Series, length must be 3: given 2"
 1857:         with pytest.raises(ValueError, match=msg):
 1858:             align(df, val, axis=0)
 1859: 
 1860:         with pytest.raises(ValueError, match=msg):
 1861:             align(df, val, axis=1)
 1862: 
 1863:     def test_alignment_non_pandas_index_columns(self):
 1864:         index = ["A", "B", "C"]
 1865:         columns = ["X", "Y", "Z"]
 1866:         df = DataFrame(
 1867:             np.random.default_rng(2).standard_normal((3, 3)),
 1868:             index=index,
 1869:             columns=columns,
 1870:         )
 1871: 
 1872:         align = DataFrame._align_for_op
 1873:         val = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
 1874:         tm.assert_frame_equal(
 1875:             align(df, val, axis=0)[1],
 1876:             DataFrame(val, index=df.index, columns=df.columns),
 1877:         )
 1878:         tm.assert_frame_equal(
 1879:             align(df, val, axis=1)[1],
 1880:             DataFrame(val, index=df.index, columns=df.columns),
 1881:         )
 1882: 
 1883:         # shape mismatch
 1884:         msg = "Unable to coerce to DataFrame, shape must be"
 1885:         val = np.array([[1, 2, 3], [4, 5, 6]])
 1886:         with pytest.raises(ValueError, match=msg):
 1887:             align(df, val, axis=0)
 1888: 
 1889:         with pytest.raises(ValueError, match=msg):
 1890:             align(df, val, axis=1)
 1891: 
 1892:         val = np.zeros((3, 3, 3))
 1893:         msg = re.escape(
 1894:             "Unable to coerce to Series/DataFrame, dimension must be <= 2: (3, 3, 3)"
 1895:         )
 1896:         with pytest.raises(ValueError, match=msg):
 1897:             align(df, val, axis=0)
 1898:         with pytest.raises(ValueError, match=msg):
 1899:             align(df, val, axis=1)
 1900: 
 1901:     def test_no_warning(self, all_arithmetic_operators):
 1902:         df = DataFrame({"A": [0.0, 0.0], "B": [0.0, None]})
 1903:         b = df["B"]
 1904:         with tm.assert_produces_warning(None):
 1905:             getattr(df, all_arithmetic_operators)(b)
 1906: 
 1907:     def test_dunder_methods_binary(self, all_arithmetic_operators):
 1908:         # GH#??? frame.__foo__ should only accept one argument
 1909:         df = DataFrame({"A": [0.0, 0.0], "B": [0.0, None]})
 1910:         b = df["B"]
 1911:         with pytest.raises(TypeError, match="takes 2 positional arguments"):
 1912:             getattr(df, all_arithmetic_operators)(b, 0)
 1913: 
 1914:     def test_align_int_fill_bug(self):
 1915:         # GH#910
 1916:         X = np.arange(10 * 10, dtype="float64").reshape(10, 10)
 1917:         Y = np.ones((10, 1), dtype=int)
 1918: 
 1919:         df1 = DataFrame(X)
 1920:         df1["0.X"] = Y.squeeze()
 1921: 
 1922:         df2 = df1.astype(float)
 1923: 
 1924:         result = df1 - df1.mean()
 1925:         expected = df2 - df2.mean()
 1926:         tm.assert_frame_equal(result, expected)
 1927: 
 1928: 
 1929: def test_pow_with_realignment():
 1930:     # GH#32685 pow has special semantics for operating with null values
 1931:     left = DataFrame({"A": [0, 1, 2]})
 1932:     right = DataFrame(index=[0, 1, 2])
 1933: 
 1934:     result = left**right
 1935:     expected = DataFrame({"A": [np.nan, 1.0, np.nan]})
 1936:     tm.assert_frame_equal(result, expected)
 1937: 
 1938: 
 1939: def test_dataframe_series_extension_dtypes():
 1940:     # https://github.com/pandas-dev/pandas/issues/34311
 1941:     df = DataFrame(
 1942:         np.random.default_rng(2).integers(0, 100, (10, 3)), columns=["a", "b", "c"]
 1943:     )
 1944:     ser = Series([1, 2, 3], index=["a", "b", "c"])
 1945: 
 1946:     expected = df.to_numpy("int64") + ser.to_numpy("int64").reshape(-1, 3)
 1947:     expected = DataFrame(expected, columns=df.columns, dtype="Int64")
 1948: 
 1949:     df_ea = df.astype("Int64")
 1950:     result = df_ea + ser
 1951:     tm.assert_frame_equal(result, expected)
 1952:     result = df_ea + ser.astype("Int64")
 1953:     tm.assert_frame_equal(result, expected)
 1954: 
 1955: 
 1956: def test_dataframe_blockwise_slicelike():
 1957:     # GH#34367
 1958:     arr = np.random.default_rng(2).integers(0, 1000, (100, 10))
 1959:     df1 = DataFrame(arr)
 1960:     # Explicit cast to float to avoid implicit cast when setting nan
 1961:     df2 = df1.copy().astype({1: "float", 3: "float", 7: "float"})
 1962:     df2.iloc[0, [1, 3, 7]] = np.nan
 1963: 
 1964:     # Explicit cast to float to avoid implicit cast when setting nan
 1965:     df3 = df1.copy().astype({5: "float"})
 1966:     df3.iloc[0, [5]] = np.nan
 1967: 
 1968:     # Explicit cast to float to avoid implicit cast when setting nan
 1969:     df4 = df1.copy().astype({2: "float", 3: "float", 4: "float"})
 1970:     df4.iloc[0, np.arange(2, 5)] = np.nan
 1971:     # Explicit cast to float to avoid implicit cast when setting nan
 1972:     df5 = df1.copy().astype({4: "float", 5: "float", 6: "float"})
 1973:     df5.iloc[0, np.arange(4, 7)] = np.nan
 1974: 
 1975:     for left, right in [(df1, df2), (df2, df3), (df4, df5)]:
 1976:         res = left + right
 1977: 
 1978:         expected = DataFrame({i: left[i] + right[i] for i in left.columns})
 1979:         tm.assert_frame_equal(res, expected)
 1980: 
 1981: 
 1982: @pytest.mark.parametrize(
 1983:     "df, col_dtype",
 1984:     [
 1985:         (DataFrame([[1.0, 2.0], [4.0, 5.0]], columns=list("ab")), "float64"),
 1986:         (
 1987:             DataFrame([[1.0, "b"], [4.0, "b"]], columns=list("ab")).astype(
 1988:                 {"b": object}
 1989:             ),
 1990:             "object",
 1991:         ),
 1992:     ],
 1993: )
 1994: def test_dataframe_operation_with_non_numeric_types(df, col_dtype):
 1995:     # GH #22663
 1996:     expected = DataFrame([[0.0, np.nan], [3.0, np.nan]], columns=list("ab"))
 1997:     expected = expected.astype({"b": col_dtype})
 1998:     result = df + Series([-1.0], index=list("a"))
 1999:     tm.assert_frame_equal(result, expected)
 2000: 
 2001: 
 2002: def test_arith_reindex_with_duplicates():
 2003:     # https://github.com/pandas-dev/pandas/issues/35194
 2004:     df1 = DataFrame(data=[[0]], columns=["second"])
 2005:     df2 = DataFrame(data=[[0, 0, 0]], columns=["first", "second", "second"])
 2006:     result = df1 + df2
 2007:     expected = DataFrame([[np.nan, 0, 0]], columns=["first", "second", "second"])
 2008:     tm.assert_frame_equal(result, expected)
 2009: 
 2010: 
 2011: @pytest.mark.parametrize("to_add", [[Series([1, 1])], [Series([1, 1]), Series([1, 1])]])
 2012: def test_arith_list_of_arraylike_raise(to_add):
 2013:     # GH 36702. Raise when trying to add list of array-like to DataFrame
 2014:     df = DataFrame({"x": [1, 2], "y": [1, 2]})
 2015: 
 2016:     msg = f"Unable to coerce list of {type(to_add[0])} to Series/DataFrame"
 2017:     with pytest.raises(ValueError, match=msg):
 2018:         df + to_add
 2019:     with pytest.raises(ValueError, match=msg):
 2020:         to_add + df
 2021: 
 2022: 
 2023: def test_inplace_arithmetic_series_update(using_copy_on_write, warn_copy_on_write):
 2024:     # https://github.com/pandas-dev/pandas/issues/36373
 2025:     df = DataFrame({"A": [1, 2, 3]})
 2026:     df_orig = df.copy()
 2027:     series = df["A"]
 2028:     vals = series._values
 2029: 
 2030:     with tm.assert_cow_warning(warn_copy_on_write):
 2031:         series += 1
 2032:     if using_copy_on_write:
 2033:         assert series._values is not vals
 2034:         tm.assert_frame_equal(df, df_orig)
 2035:     else:
 2036:         assert series._values is vals
 2037: 
 2038:         expected = DataFrame({"A": [2, 3, 4]})
 2039:         tm.assert_frame_equal(df, expected)
 2040: 
 2041: 
 2042: def test_arithmetic_multiindex_align():
 2043:     """
 2044:     Regression test for: https://github.com/pandas-dev/pandas/issues/33765
 2045:     """
 2046:     df1 = DataFrame(
 2047:         [[1]],
 2048:         index=["a"],
 2049:         columns=MultiIndex.from_product([[0], [1]], names=["a", "b"]),
 2050:     )
 2051:     df2 = DataFrame([[1]], index=["a"], columns=Index([0], name="a"))
 2052:     expected = DataFrame(
 2053:         [[0]],
 2054:         index=["a"],
 2055:         columns=MultiIndex.from_product([[0], [1]], names=["a", "b"]),
 2056:     )
 2057:     result = df1 - df2
 2058:     tm.assert_frame_equal(result, expected)
 2059: 
 2060: 
 2061: def test_bool_frame_mult_float():
 2062:     # GH 18549
 2063:     df = DataFrame(True, list("ab"), list("cd"))
 2064:     result = df * 1.0
 2065:     expected = DataFrame(np.ones((2, 2)), list("ab"), list("cd"))
 2066:     tm.assert_frame_equal(result, expected)
 2067: 
 2068: 
 2069: def test_frame_sub_nullable_int(any_int_ea_dtype):
 2070:     # GH 32822
 2071:     series1 = Series([1, 2, None], dtype=any_int_ea_dtype)
 2072:     series2 = Series([1, 2, 3], dtype=any_int_ea_dtype)
 2073:     expected = DataFrame([0, 0, None], dtype=any_int_ea_dtype)
 2074:     result = series1.to_frame() - series2.to_frame()
 2075:     tm.assert_frame_equal(result, expected)
 2076: 
 2077: 
 2078: @pytest.mark.filterwarnings(
 2079:     "ignore:Passing a BlockManager|Passing a SingleBlockManager:DeprecationWarning"
 2080: )
 2081: def test_frame_op_subclass_nonclass_constructor():
 2082:     # GH#43201 subclass._constructor is a function, not the subclass itself
 2083: 
 2084:     class SubclassedSeries(Series):
 2085:         @property
 2086:         def _constructor(self):
 2087:             return SubclassedSeries
 2088: 
 2089:         @property
 2090:         def _constructor_expanddim(self):
 2091:             return SubclassedDataFrame
 2092: 
 2093:     class SubclassedDataFrame(DataFrame):
 2094:         _metadata = ["my_extra_data"]
 2095: 
 2096:         def __init__(self, my_extra_data, *args, **kwargs) -> None:
 2097:             self.my_extra_data = my_extra_data
 2098:             super().__init__(*args, **kwargs)
 2099: 
 2100:         @property
 2101:         def _constructor(self):
 2102:             return functools.partial(type(self), self.my_extra_data)
 2103: 
 2104:         @property
 2105:         def _constructor_sliced(self):
 2106:             return SubclassedSeries
 2107: 
 2108:     sdf = SubclassedDataFrame("some_data", {"A": [1, 2, 3], "B": [4, 5, 6]})
 2109:     result = sdf * 2
 2110:     expected = SubclassedDataFrame("some_data", {"A": [2, 4, 6], "B": [8, 10, 12]})
 2111:     tm.assert_frame_equal(result, expected)
 2112: 
 2113:     result = sdf + sdf
 2114:     tm.assert_frame_equal(result, expected)
 2115: 
 2116: 
 2117: def test_enum_column_equality():
 2118:     Cols = Enum("Cols", "col1 col2")
 2119: 
 2120:     q1 = DataFrame({Cols.col1: [1, 2, 3]})
 2121:     q2 = DataFrame({Cols.col1: [1, 2, 3]})
 2122: 
 2123:     result = q1[Cols.col1] == q2[Cols.col1]
 2124:     expected = Series([True, True, True], name=Cols.col1)
 2125: 
 2126:     tm.assert_series_equal(result, expected)
 2127: 
 2128: 
 2129: def test_mixed_col_index_dtype():
 2130:     # GH 47382
 2131:     df1 = DataFrame(columns=list("abc"), data=1.0, index=[0])
 2132:     df2 = DataFrame(columns=list("abc"), data=0.0, index=[0])
 2133:     df1.columns = df2.columns.astype("string")
 2134:     result = df1 + df2
 2135:     expected = DataFrame(columns=list("abc"), data=1.0, index=[0])
 2136:     tm.assert_frame_equal(result, expected)
