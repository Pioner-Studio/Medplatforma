    1: from datetime import timezone
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     Index,
   10:     Series,
   11:     date_range,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: class TestDataFrameAlign:
   17:     def test_align_asfreq_method_raises(self):
   18:         df = DataFrame({"A": [1, np.nan, 2]})
   19:         msg = "Invalid fill method"
   20:         msg2 = "The 'method', 'limit', and 'fill_axis' keywords"
   21:         with pytest.raises(ValueError, match=msg):
   22:             with tm.assert_produces_warning(FutureWarning, match=msg2):
   23:                 df.align(df.iloc[::-1], method="asfreq")
   24: 
   25:     def test_frame_align_aware(self):
   26:         idx1 = date_range("2001", periods=5, freq="h", tz="US/Eastern")
   27:         idx2 = date_range("2001", periods=5, freq="2h", tz="US/Eastern")
   28:         df1 = DataFrame(np.random.default_rng(2).standard_normal((len(idx1), 3)), idx1)
   29:         df2 = DataFrame(np.random.default_rng(2).standard_normal((len(idx2), 3)), idx2)
   30:         new1, new2 = df1.align(df2)
   31:         assert df1.index.tz == new1.index.tz
   32:         assert df2.index.tz == new2.index.tz
   33: 
   34:         # different timezones convert to UTC
   35: 
   36:         # frame with frame
   37:         df1_central = df1.tz_convert("US/Central")
   38:         new1, new2 = df1.align(df1_central)
   39:         assert new1.index.tz is timezone.utc
   40:         assert new2.index.tz is timezone.utc
   41: 
   42:         # frame with Series
   43:         new1, new2 = df1.align(df1_central[0], axis=0)
   44:         assert new1.index.tz is timezone.utc
   45:         assert new2.index.tz is timezone.utc
   46: 
   47:         df1[0].align(df1_central, axis=0)
   48:         assert new1.index.tz is timezone.utc
   49:         assert new2.index.tz is timezone.utc
   50: 
   51:     def test_align_float(self, float_frame, using_copy_on_write):
   52:         af, bf = float_frame.align(float_frame)
   53:         assert af._mgr is not float_frame._mgr
   54: 
   55:         af, bf = float_frame.align(float_frame, copy=False)
   56:         if not using_copy_on_write:
   57:             assert af._mgr is float_frame._mgr
   58:         else:
   59:             assert af._mgr is not float_frame._mgr
   60: 
   61:         # axis = 0
   62:         other = float_frame.iloc[:-5, :3]
   63:         af, bf = float_frame.align(other, axis=0, fill_value=-1)
   64: 
   65:         tm.assert_index_equal(bf.columns, other.columns)
   66: 
   67:         # test fill value
   68:         join_idx = float_frame.index.join(other.index)
   69:         diff_a = float_frame.index.difference(join_idx)
   70:         diff_a_vals = af.reindex(diff_a).values
   71:         assert (diff_a_vals == -1).all()
   72: 
   73:         af, bf = float_frame.align(other, join="right", axis=0)
   74:         tm.assert_index_equal(bf.columns, other.columns)
   75:         tm.assert_index_equal(bf.index, other.index)
   76:         tm.assert_index_equal(af.index, other.index)
   77: 
   78:         # axis = 1
   79:         other = float_frame.iloc[:-5, :3].copy()
   80:         af, bf = float_frame.align(other, axis=1)
   81:         tm.assert_index_equal(bf.columns, float_frame.columns)
   82:         tm.assert_index_equal(bf.index, other.index)
   83: 
   84:         # test fill value
   85:         join_idx = float_frame.index.join(other.index)
   86:         diff_a = float_frame.index.difference(join_idx)
   87:         diff_a_vals = af.reindex(diff_a).values
   88: 
   89:         assert (diff_a_vals == -1).all()
   90: 
   91:         af, bf = float_frame.align(other, join="inner", axis=1)
   92:         tm.assert_index_equal(bf.columns, other.columns)
   93: 
   94:         msg = (
   95:             "The 'method', 'limit', and 'fill_axis' keywords in DataFrame.align "
   96:             "are deprecated"
   97:         )
   98:         with tm.assert_produces_warning(FutureWarning, match=msg):
   99:             af, bf = float_frame.align(other, join="inner", axis=1, method="pad")
  100:         tm.assert_index_equal(bf.columns, other.columns)
  101: 
  102:         msg = (
  103:             "The 'method', 'limit', and 'fill_axis' keywords in DataFrame.align "
  104:             "are deprecated"
  105:         )
  106:         with tm.assert_produces_warning(FutureWarning, match=msg):
  107:             af, bf = float_frame.align(
  108:                 other.iloc[:, 0], join="inner", axis=1, method=None, fill_value=None
  109:             )
  110:         tm.assert_index_equal(bf.index, Index([]).astype(bf.index.dtype))
  111: 
  112:         msg = (
  113:             "The 'method', 'limit', and 'fill_axis' keywords in DataFrame.align "
  114:             "are deprecated"
  115:         )
  116:         with tm.assert_produces_warning(FutureWarning, match=msg):
  117:             af, bf = float_frame.align(
  118:                 other.iloc[:, 0], join="inner", axis=1, method=None, fill_value=0
  119:             )
  120:         tm.assert_index_equal(bf.index, Index([]).astype(bf.index.dtype))
  121: 
  122:         # Try to align DataFrame to Series along bad axis
  123:         msg = "No axis named 2 for object type DataFrame"
  124:         with pytest.raises(ValueError, match=msg):
  125:             float_frame.align(af.iloc[0, :3], join="inner", axis=2)
  126: 
  127:     def test_align_frame_with_series(self, float_frame):
  128:         # align dataframe to series with broadcast or not
  129:         idx = float_frame.index
  130:         s = Series(range(len(idx)), index=idx)
  131: 
  132:         left, right = float_frame.align(s, axis=0)
  133:         tm.assert_index_equal(left.index, float_frame.index)
  134:         tm.assert_index_equal(right.index, float_frame.index)
  135:         assert isinstance(right, Series)
  136: 
  137:         msg = "The 'broadcast_axis' keyword in DataFrame.align is deprecated"
  138:         with tm.assert_produces_warning(FutureWarning, match=msg):
  139:             left, right = float_frame.align(s, broadcast_axis=1)
  140:         tm.assert_index_equal(left.index, float_frame.index)
  141:         expected = {c: s for c in float_frame.columns}
  142:         expected = DataFrame(
  143:             expected, index=float_frame.index, columns=float_frame.columns
  144:         )
  145:         tm.assert_frame_equal(right, expected)
  146: 
  147:     def test_align_series_condition(self):
  148:         # see gh-9558
  149:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  150:         result = df[df["a"] == 2]
  151:         expected = DataFrame([[2, 5]], index=[1], columns=["a", "b"])
  152:         tm.assert_frame_equal(result, expected)
  153: 
  154:         result = df.where(df["a"] == 2, 0)
  155:         expected = DataFrame({"a": [0, 2, 0], "b": [0, 5, 0]})
  156:         tm.assert_frame_equal(result, expected)
  157: 
  158:     def test_align_int(self, int_frame):
  159:         # test other non-float types
  160:         other = DataFrame(index=range(5), columns=["A", "B", "C"])
  161: 
  162:         msg = (
  163:             "The 'method', 'limit', and 'fill_axis' keywords in DataFrame.align "
  164:             "are deprecated"
  165:         )
  166:         with tm.assert_produces_warning(FutureWarning, match=msg):
  167:             af, bf = int_frame.align(other, join="inner", axis=1, method="pad")
  168:         tm.assert_index_equal(bf.columns, other.columns)
  169: 
  170:     def test_align_mixed_type(self, float_string_frame):
  171:         msg = (
  172:             "The 'method', 'limit', and 'fill_axis' keywords in DataFrame.align "
  173:             "are deprecated"
  174:         )
  175:         with tm.assert_produces_warning(FutureWarning, match=msg):
  176:             af, bf = float_string_frame.align(
  177:                 float_string_frame, join="inner", axis=1, method="pad"
  178:             )
  179:         tm.assert_index_equal(bf.columns, float_string_frame.columns)
  180: 
  181:     def test_align_mixed_float(self, mixed_float_frame):
  182:         # mixed floats/ints
  183:         other = DataFrame(index=range(5), columns=["A", "B", "C"])
  184: 
  185:         msg = (
  186:             "The 'method', 'limit', and 'fill_axis' keywords in DataFrame.align "
  187:             "are deprecated"
  188:         )
  189:         with tm.assert_produces_warning(FutureWarning, match=msg):
  190:             af, bf = mixed_float_frame.align(
  191:                 other.iloc[:, 0], join="inner", axis=1, method=None, fill_value=0
  192:             )
  193:         tm.assert_index_equal(bf.index, Index([]))
  194: 
  195:     def test_align_mixed_int(self, mixed_int_frame):
  196:         other = DataFrame(index=range(5), columns=["A", "B", "C"])
  197: 
  198:         msg = (
  199:             "The 'method', 'limit', and 'fill_axis' keywords in DataFrame.align "
  200:             "are deprecated"
  201:         )
  202:         with tm.assert_produces_warning(FutureWarning, match=msg):
  203:             af, bf = mixed_int_frame.align(
  204:                 other.iloc[:, 0], join="inner", axis=1, method=None, fill_value=0
  205:             )
  206:         tm.assert_index_equal(bf.index, Index([]))
  207: 
  208:     @pytest.mark.parametrize(
  209:         "l_ordered,r_ordered,expected",
  210:         [
  211:             [True, True, pd.CategoricalIndex],
  212:             [True, False, Index],
  213:             [False, True, Index],
  214:             [False, False, pd.CategoricalIndex],
  215:         ],
  216:     )
  217:     def test_align_categorical(self, l_ordered, r_ordered, expected):
  218:         # GH-28397
  219:         df_1 = DataFrame(
  220:             {
  221:                 "A": np.arange(6, dtype="int64"),
  222:                 "B": Series(list("aabbca")).astype(
  223:                     pd.CategoricalDtype(list("cab"), ordered=l_ordered)
  224:                 ),
  225:             }
  226:         ).set_index("B")
  227:         df_2 = DataFrame(
  228:             {
  229:                 "A": np.arange(5, dtype="int64"),
  230:                 "B": Series(list("babca")).astype(
  231:                     pd.CategoricalDtype(list("cab"), ordered=r_ordered)
  232:                 ),
  233:             }
  234:         ).set_index("B")
  235: 
  236:         aligned_1, aligned_2 = df_1.align(df_2)
  237:         assert isinstance(aligned_1.index, expected)
  238:         assert isinstance(aligned_2.index, expected)
  239:         tm.assert_index_equal(aligned_1.index, aligned_2.index)
  240: 
  241:     def test_align_multiindex(self):
  242:         # GH#10665
  243:         # same test cases as test_align_multiindex in test_series.py
  244: 
  245:         midx = pd.MultiIndex.from_product(
  246:             [range(2), range(3), range(2)], names=("a", "b", "c")
  247:         )
  248:         idx = Index(range(2), name="b")
  249:         df1 = DataFrame(np.arange(12, dtype="int64"), index=midx)
  250:         df2 = DataFrame(np.arange(2, dtype="int64"), index=idx)
  251: 
  252:         # these must be the same results (but flipped)
  253:         res1l, res1r = df1.align(df2, join="left")
  254:         res2l, res2r = df2.align(df1, join="right")
  255: 
  256:         expl = df1
  257:         tm.assert_frame_equal(expl, res1l)
  258:         tm.assert_frame_equal(expl, res2r)
  259:         expr = DataFrame([0, 0, 1, 1, np.nan, np.nan] * 2, index=midx)
  260:         tm.assert_frame_equal(expr, res1r)
  261:         tm.assert_frame_equal(expr, res2l)
  262: 
  263:         res1l, res1r = df1.align(df2, join="right")
  264:         res2l, res2r = df2.align(df1, join="left")
  265: 
  266:         exp_idx = pd.MultiIndex.from_product(
  267:             [range(2), range(2), range(2)], names=("a", "b", "c")
  268:         )
  269:         expl = DataFrame([0, 1, 2, 3, 6, 7, 8, 9], index=exp_idx)
  270:         tm.assert_frame_equal(expl, res1l)
  271:         tm.assert_frame_equal(expl, res2r)
  272:         expr = DataFrame([0, 0, 1, 1] * 2, index=exp_idx)
  273:         tm.assert_frame_equal(expr, res1r)
  274:         tm.assert_frame_equal(expr, res2l)
  275: 
  276:     def test_align_series_combinations(self):
  277:         df = DataFrame({"a": [1, 3, 5], "b": [1, 3, 5]}, index=list("ACE"))
  278:         s = Series([1, 2, 4], index=list("ABD"), name="x")
  279: 
  280:         # frame + series
  281:         res1, res2 = df.align(s, axis=0)
  282:         exp1 = DataFrame(
  283:             {"a": [1, np.nan, 3, np.nan, 5], "b": [1, np.nan, 3, np.nan, 5]},
  284:             index=list("ABCDE"),
  285:         )
  286:         exp2 = Series([1, 2, np.nan, 4, np.nan], index=list("ABCDE"), name="x")
  287: 
  288:         tm.assert_frame_equal(res1, exp1)
  289:         tm.assert_series_equal(res2, exp2)
  290: 
  291:         # series + frame
  292:         res1, res2 = s.align(df)
  293:         tm.assert_series_equal(res1, exp2)
  294:         tm.assert_frame_equal(res2, exp1)
  295: 
  296:     def test_multiindex_align_to_series_with_common_index_level(self):
  297:         #  GH-46001
  298:         foo_index = Index([1, 2, 3], name="foo")
  299:         bar_index = Index([1, 2], name="bar")
  300: 
  301:         series = Series([1, 2], index=bar_index, name="foo_series")
  302:         df = DataFrame(
  303:             {"col": np.arange(6)},
  304:             index=pd.MultiIndex.from_product([foo_index, bar_index]),
  305:         )
  306: 
  307:         expected_r = Series([1, 2] * 3, index=df.index, name="foo_series")
  308:         result_l, result_r = df.align(series, axis=0)
  309: 
  310:         tm.assert_frame_equal(result_l, df)
  311:         tm.assert_series_equal(result_r, expected_r)
  312: 
  313:     def test_multiindex_align_to_series_with_common_index_level_missing_in_left(self):
  314:         #  GH-46001
  315:         foo_index = Index([1, 2, 3], name="foo")
  316:         bar_index = Index([1, 2], name="bar")
  317: 
  318:         series = Series(
  319:             [1, 2, 3, 4], index=Index([1, 2, 3, 4], name="bar"), name="foo_series"
  320:         )
  321:         df = DataFrame(
  322:             {"col": np.arange(6)},
  323:             index=pd.MultiIndex.from_product([foo_index, bar_index]),
  324:         )
  325: 
  326:         expected_r = Series([1, 2] * 3, index=df.index, name="foo_series")
  327:         result_l, result_r = df.align(series, axis=0)
  328: 
  329:         tm.assert_frame_equal(result_l, df)
  330:         tm.assert_series_equal(result_r, expected_r)
  331: 
  332:     def test_multiindex_align_to_series_with_common_index_level_missing_in_right(self):
  333:         #  GH-46001
  334:         foo_index = Index([1, 2, 3], name="foo")
  335:         bar_index = Index([1, 2, 3, 4], name="bar")
  336: 
  337:         series = Series([1, 2], index=Index([1, 2], name="bar"), name="foo_series")
  338:         df = DataFrame(
  339:             {"col": np.arange(12)},
  340:             index=pd.MultiIndex.from_product([foo_index, bar_index]),
  341:         )
  342: 
  343:         expected_r = Series(
  344:             [1, 2, np.nan, np.nan] * 3, index=df.index, name="foo_series"
  345:         )
  346:         result_l, result_r = df.align(series, axis=0)
  347: 
  348:         tm.assert_frame_equal(result_l, df)
  349:         tm.assert_series_equal(result_r, expected_r)
  350: 
  351:     def test_multiindex_align_to_series_with_common_index_level_missing_in_both(self):
  352:         #  GH-46001
  353:         foo_index = Index([1, 2, 3], name="foo")
  354:         bar_index = Index([1, 3, 4], name="bar")
  355: 
  356:         series = Series(
  357:             [1, 2, 3], index=Index([1, 2, 4], name="bar"), name="foo_series"
  358:         )
  359:         df = DataFrame(
  360:             {"col": np.arange(9)},
  361:             index=pd.MultiIndex.from_product([foo_index, bar_index]),
  362:         )
  363: 
  364:         expected_r = Series([1, np.nan, 3] * 3, index=df.index, name="foo_series")
  365:         result_l, result_r = df.align(series, axis=0)
  366: 
  367:         tm.assert_frame_equal(result_l, df)
  368:         tm.assert_series_equal(result_r, expected_r)
  369: 
  370:     def test_multiindex_align_to_series_with_common_index_level_non_unique_cols(self):
  371:         #  GH-46001
  372:         foo_index = Index([1, 2, 3], name="foo")
  373:         bar_index = Index([1, 2], name="bar")
  374: 
  375:         series = Series([1, 2], index=bar_index, name="foo_series")
  376:         df = DataFrame(
  377:             np.arange(18).reshape(6, 3),
  378:             index=pd.MultiIndex.from_product([foo_index, bar_index]),
  379:         )
  380:         df.columns = ["cfoo", "cbar", "cfoo"]
  381: 
  382:         expected = Series([1, 2] * 3, index=df.index, name="foo_series")
  383:         result_left, result_right = df.align(series, axis=0)
  384: 
  385:         tm.assert_series_equal(result_right, expected)
  386:         tm.assert_index_equal(result_left.columns, df.columns)
  387: 
  388:     def test_missing_axis_specification_exception(self):
  389:         df = DataFrame(np.arange(50).reshape((10, 5)))
  390:         series = Series(np.arange(5))
  391: 
  392:         with pytest.raises(ValueError, match=r"axis=0 or 1"):
  393:             df.align(series)
  394: 
  395:     @pytest.mark.parametrize("method", ["pad", "bfill"])
  396:     @pytest.mark.parametrize("axis", [0, 1, None])
  397:     @pytest.mark.parametrize("fill_axis", [0, 1])
  398:     @pytest.mark.parametrize("how", ["inner", "outer", "left", "right"])
  399:     @pytest.mark.parametrize(
  400:         "left_slice",
  401:         [
  402:             [slice(4), slice(10)],
  403:             [slice(0), slice(0)],
  404:         ],
  405:     )
  406:     @pytest.mark.parametrize(
  407:         "right_slice",
  408:         [
  409:             [slice(2, None), slice(6, None)],
  410:             [slice(0), slice(0)],
  411:         ],
  412:     )
  413:     @pytest.mark.parametrize("limit", [1, None])
  414:     def test_align_fill_method(
  415:         self, how, method, axis, fill_axis, float_frame, left_slice, right_slice, limit
  416:     ):
  417:         frame = float_frame
  418:         left = frame.iloc[left_slice[0], left_slice[1]]
  419:         right = frame.iloc[right_slice[0], right_slice[1]]
  420: 
  421:         msg = (
  422:             "The 'method', 'limit', and 'fill_axis' keywords in DataFrame.align "
  423:             "are deprecated"
  424:         )
  425: 
  426:         with tm.assert_produces_warning(FutureWarning, match=msg):
  427:             aa, ab = left.align(
  428:                 right,
  429:                 axis=axis,
  430:                 join=how,
  431:                 method=method,
  432:                 limit=limit,
  433:                 fill_axis=fill_axis,
  434:             )
  435: 
  436:         join_index, join_columns = None, None
  437: 
  438:         ea, eb = left, right
  439:         if axis is None or axis == 0:
  440:             join_index = left.index.join(right.index, how=how)
  441:             ea = ea.reindex(index=join_index)
  442:             eb = eb.reindex(index=join_index)
  443: 
  444:         if axis is None or axis == 1:
  445:             join_columns = left.columns.join(right.columns, how=how)
  446:             ea = ea.reindex(columns=join_columns)
  447:             eb = eb.reindex(columns=join_columns)
  448: 
  449:         msg = "DataFrame.fillna with 'method' is deprecated"
  450:         with tm.assert_produces_warning(FutureWarning, match=msg):
  451:             ea = ea.fillna(axis=fill_axis, method=method, limit=limit)
  452:             eb = eb.fillna(axis=fill_axis, method=method, limit=limit)
  453: 
  454:         tm.assert_frame_equal(aa, ea)
  455:         tm.assert_frame_equal(ab, eb)
  456: 
  457:     def test_align_series_check_copy(self):
  458:         # GH#
  459:         df = DataFrame({0: [1, 2]})
  460:         ser = Series([1], name=0)
  461:         expected = ser.copy()
  462:         result, other = df.align(ser, axis=1)
  463:         ser.iloc[0] = 100
  464:         tm.assert_series_equal(other, expected)
  465: 
  466:     def test_align_identical_different_object(self):
  467:         # GH#51032
  468:         df = DataFrame({"a": [1, 2]})
  469:         ser = Series([3, 4])
  470:         result, result2 = df.align(ser, axis=0)
  471:         tm.assert_frame_equal(result, df)
  472:         tm.assert_series_equal(result2, ser)
  473:         assert df is not result
  474:         assert ser is not result2
  475: 
  476:     def test_align_identical_different_object_columns(self):
  477:         # GH#51032
  478:         df = DataFrame({"a": [1, 2]})
  479:         ser = Series([1], index=["a"])
  480:         result, result2 = df.align(ser, axis=1)
  481:         tm.assert_frame_equal(result, df)
  482:         tm.assert_series_equal(result2, ser)
  483:         assert df is not result
  484:         assert ser is not result2
