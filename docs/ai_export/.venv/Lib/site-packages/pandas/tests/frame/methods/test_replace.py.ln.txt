    1: from __future__ import annotations
    2: 
    3: from datetime import datetime
    4: import re
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas._config import using_pyarrow_string_dtype
   10: 
   11: import pandas as pd
   12: from pandas import (
   13:     DataFrame,
   14:     Index,
   15:     Series,
   16:     Timestamp,
   17:     date_range,
   18: )
   19: import pandas._testing as tm
   20: 
   21: 
   22: @pytest.fixture
   23: def mix_ab() -> dict[str, list[int | str]]:
   24:     return {"a": list(range(4)), "b": list("ab..")}
   25: 
   26: 
   27: @pytest.fixture
   28: def mix_abc() -> dict[str, list[float | str]]:
   29:     return {"a": list(range(4)), "b": list("ab.."), "c": ["a", "b", np.nan, "d"]}
   30: 
   31: 
   32: class TestDataFrameReplace:
   33:     @pytest.mark.xfail(
   34:         using_pyarrow_string_dtype(), reason="can't set float into string"
   35:     )
   36:     def test_replace_inplace(self, datetime_frame, float_string_frame):
   37:         datetime_frame.loc[datetime_frame.index[:5], "A"] = np.nan
   38:         datetime_frame.loc[datetime_frame.index[-5:], "A"] = np.nan
   39: 
   40:         tsframe = datetime_frame.copy()
   41:         return_value = tsframe.replace(np.nan, 0, inplace=True)
   42:         assert return_value is None
   43:         tm.assert_frame_equal(tsframe, datetime_frame.fillna(0))
   44: 
   45:         # mixed type
   46:         mf = float_string_frame
   47:         mf.iloc[5:20, mf.columns.get_loc("foo")] = np.nan
   48:         mf.iloc[-10:, mf.columns.get_loc("A")] = np.nan
   49: 
   50:         result = float_string_frame.replace(np.nan, 0)
   51:         expected = float_string_frame.fillna(value=0)
   52:         tm.assert_frame_equal(result, expected)
   53: 
   54:         tsframe = datetime_frame.copy()
   55:         return_value = tsframe.replace([np.nan], [0], inplace=True)
   56:         assert return_value is None
   57:         tm.assert_frame_equal(tsframe, datetime_frame.fillna(0))
   58: 
   59:     @pytest.mark.parametrize(
   60:         "to_replace,values,expected",
   61:         [
   62:             # lists of regexes and values
   63:             # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]
   64:             (
   65:                 [r"\s*\.\s*", r"e|f|g"],
   66:                 [np.nan, "crap"],
   67:                 {
   68:                     "a": ["a", "b", np.nan, np.nan],
   69:                     "b": ["crap"] * 3 + ["h"],
   70:                     "c": ["h", "crap", "l", "o"],
   71:                 },
   72:             ),
   73:             # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]
   74:             (
   75:                 [r"\s*(\.)\s*", r"(e|f|g)"],
   76:                 [r"\1\1", r"\1_crap"],
   77:                 {
   78:                     "a": ["a", "b", "..", ".."],
   79:                     "b": ["e_crap", "f_crap", "g_crap", "h"],
   80:                     "c": ["h", "e_crap", "l", "o"],
   81:                 },
   82:             ),
   83:             # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN
   84:             # or vN)]
   85:             (
   86:                 [r"\s*(\.)\s*", r"e"],
   87:                 [r"\1\1", r"crap"],
   88:                 {
   89:                     "a": ["a", "b", "..", ".."],
   90:                     "b": ["crap", "f", "g", "h"],
   91:                     "c": ["h", "crap", "l", "o"],
   92:                 },
   93:             ),
   94:         ],
   95:     )
   96:     @pytest.mark.parametrize("inplace", [True, False])
   97:     @pytest.mark.parametrize("use_value_regex_args", [True, False])
   98:     def test_regex_replace_list_obj(
   99:         self, to_replace, values, expected, inplace, use_value_regex_args
  100:     ):
  101:         df = DataFrame({"a": list("ab.."), "b": list("efgh"), "c": list("helo")})
  102: 
  103:         if use_value_regex_args:
  104:             result = df.replace(value=values, regex=to_replace, inplace=inplace)
  105:         else:
  106:             result = df.replace(to_replace, values, regex=True, inplace=inplace)
  107: 
  108:         if inplace:
  109:             assert result is None
  110:             result = df
  111: 
  112:         expected = DataFrame(expected)
  113:         tm.assert_frame_equal(result, expected)
  114: 
  115:     def test_regex_replace_list_mixed(self, mix_ab):
  116:         # mixed frame to make sure this doesn't break things
  117:         dfmix = DataFrame(mix_ab)
  118: 
  119:         # lists of regexes and values
  120:         # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]
  121:         to_replace_res = [r"\s*\.\s*", r"a"]
  122:         values = [np.nan, "crap"]
  123:         mix2 = {"a": list(range(4)), "b": list("ab.."), "c": list("halo")}
  124:         dfmix2 = DataFrame(mix2)
  125:         res = dfmix2.replace(to_replace_res, values, regex=True)
  126:         expec = DataFrame(
  127:             {
  128:                 "a": mix2["a"],
  129:                 "b": ["crap", "b", np.nan, np.nan],
  130:                 "c": ["h", "crap", "l", "o"],
  131:             }
  132:         )
  133:         tm.assert_frame_equal(res, expec)
  134: 
  135:         # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]
  136:         to_replace_res = [r"\s*(\.)\s*", r"(a|b)"]
  137:         values = [r"\1\1", r"\1_crap"]
  138:         res = dfmix.replace(to_replace_res, values, regex=True)
  139:         expec = DataFrame({"a": mix_ab["a"], "b": ["a_crap", "b_crap", "..", ".."]})
  140:         tm.assert_frame_equal(res, expec)
  141: 
  142:         # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN
  143:         # or vN)]
  144:         to_replace_res = [r"\s*(\.)\s*", r"a", r"(b)"]
  145:         values = [r"\1\1", r"crap", r"\1_crap"]
  146:         res = dfmix.replace(to_replace_res, values, regex=True)
  147:         expec = DataFrame({"a": mix_ab["a"], "b": ["crap", "b_crap", "..", ".."]})
  148:         tm.assert_frame_equal(res, expec)
  149: 
  150:         to_replace_res = [r"\s*(\.)\s*", r"a", r"(b)"]
  151:         values = [r"\1\1", r"crap", r"\1_crap"]
  152:         res = dfmix.replace(regex=to_replace_res, value=values)
  153:         expec = DataFrame({"a": mix_ab["a"], "b": ["crap", "b_crap", "..", ".."]})
  154:         tm.assert_frame_equal(res, expec)
  155: 
  156:     def test_regex_replace_list_mixed_inplace(self, mix_ab):
  157:         dfmix = DataFrame(mix_ab)
  158:         # the same inplace
  159:         # lists of regexes and values
  160:         # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]
  161:         to_replace_res = [r"\s*\.\s*", r"a"]
  162:         values = [np.nan, "crap"]
  163:         res = dfmix.copy()
  164:         return_value = res.replace(to_replace_res, values, inplace=True, regex=True)
  165:         assert return_value is None
  166:         expec = DataFrame({"a": mix_ab["a"], "b": ["crap", "b", np.nan, np.nan]})
  167:         tm.assert_frame_equal(res, expec)
  168: 
  169:         # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]
  170:         to_replace_res = [r"\s*(\.)\s*", r"(a|b)"]
  171:         values = [r"\1\1", r"\1_crap"]
  172:         res = dfmix.copy()
  173:         return_value = res.replace(to_replace_res, values, inplace=True, regex=True)
  174:         assert return_value is None
  175:         expec = DataFrame({"a": mix_ab["a"], "b": ["a_crap", "b_crap", "..", ".."]})
  176:         tm.assert_frame_equal(res, expec)
  177: 
  178:         # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN
  179:         # or vN)]
  180:         to_replace_res = [r"\s*(\.)\s*", r"a", r"(b)"]
  181:         values = [r"\1\1", r"crap", r"\1_crap"]
  182:         res = dfmix.copy()
  183:         return_value = res.replace(to_replace_res, values, inplace=True, regex=True)
  184:         assert return_value is None
  185:         expec = DataFrame({"a": mix_ab["a"], "b": ["crap", "b_crap", "..", ".."]})
  186:         tm.assert_frame_equal(res, expec)
  187: 
  188:         to_replace_res = [r"\s*(\.)\s*", r"a", r"(b)"]
  189:         values = [r"\1\1", r"crap", r"\1_crap"]
  190:         res = dfmix.copy()
  191:         return_value = res.replace(regex=to_replace_res, value=values, inplace=True)
  192:         assert return_value is None
  193:         expec = DataFrame({"a": mix_ab["a"], "b": ["crap", "b_crap", "..", ".."]})
  194:         tm.assert_frame_equal(res, expec)
  195: 
  196:     def test_regex_replace_dict_mixed(self, mix_abc):
  197:         dfmix = DataFrame(mix_abc)
  198: 
  199:         # dicts
  200:         # single dict {re1: v1}, search the whole frame
  201:         # need test for this...
  202: 
  203:         # list of dicts {re1: v1, re2: v2, ..., re3: v3}, search the whole
  204:         # frame
  205:         res = dfmix.replace({"b": r"\s*\.\s*"}, {"b": np.nan}, regex=True)
  206:         res2 = dfmix.copy()
  207:         return_value = res2.replace(
  208:             {"b": r"\s*\.\s*"}, {"b": np.nan}, inplace=True, regex=True
  209:         )
  210:         assert return_value is None
  211:         expec = DataFrame(
  212:             {"a": mix_abc["a"], "b": ["a", "b", np.nan, np.nan], "c": mix_abc["c"]}
  213:         )
  214:         tm.assert_frame_equal(res, expec)
  215:         tm.assert_frame_equal(res2, expec)
  216: 
  217:         # list of dicts {re1: re11, re2: re12, ..., reN: re1N}, search the
  218:         # whole frame
  219:         res = dfmix.replace({"b": r"\s*(\.)\s*"}, {"b": r"\1ty"}, regex=True)
  220:         res2 = dfmix.copy()
  221:         return_value = res2.replace(
  222:             {"b": r"\s*(\.)\s*"}, {"b": r"\1ty"}, inplace=True, regex=True
  223:         )
  224:         assert return_value is None
  225:         expec = DataFrame(
  226:             {"a": mix_abc["a"], "b": ["a", "b", ".ty", ".ty"], "c": mix_abc["c"]}
  227:         )
  228:         tm.assert_frame_equal(res, expec)
  229:         tm.assert_frame_equal(res2, expec)
  230: 
  231:         res = dfmix.replace(regex={"b": r"\s*(\.)\s*"}, value={"b": r"\1ty"})
  232:         res2 = dfmix.copy()
  233:         return_value = res2.replace(
  234:             regex={"b": r"\s*(\.)\s*"}, value={"b": r"\1ty"}, inplace=True
  235:         )
  236:         assert return_value is None
  237:         expec = DataFrame(
  238:             {"a": mix_abc["a"], "b": ["a", "b", ".ty", ".ty"], "c": mix_abc["c"]}
  239:         )
  240:         tm.assert_frame_equal(res, expec)
  241:         tm.assert_frame_equal(res2, expec)
  242: 
  243:         # scalar -> dict
  244:         # to_replace regex, {value: value}
  245:         expec = DataFrame(
  246:             {"a": mix_abc["a"], "b": [np.nan, "b", ".", "."], "c": mix_abc["c"]}
  247:         )
  248:         res = dfmix.replace("a", {"b": np.nan}, regex=True)
  249:         res2 = dfmix.copy()
  250:         return_value = res2.replace("a", {"b": np.nan}, regex=True, inplace=True)
  251:         assert return_value is None
  252:         tm.assert_frame_equal(res, expec)
  253:         tm.assert_frame_equal(res2, expec)
  254: 
  255:         res = dfmix.replace("a", {"b": np.nan}, regex=True)
  256:         res2 = dfmix.copy()
  257:         return_value = res2.replace(regex="a", value={"b": np.nan}, inplace=True)
  258:         assert return_value is None
  259:         expec = DataFrame(
  260:             {"a": mix_abc["a"], "b": [np.nan, "b", ".", "."], "c": mix_abc["c"]}
  261:         )
  262:         tm.assert_frame_equal(res, expec)
  263:         tm.assert_frame_equal(res2, expec)
  264: 
  265:     def test_regex_replace_dict_nested(self, mix_abc):
  266:         # nested dicts will not work until this is implemented for Series
  267:         dfmix = DataFrame(mix_abc)
  268:         res = dfmix.replace({"b": {r"\s*\.\s*": np.nan}}, regex=True)
  269:         res2 = dfmix.copy()
  270:         res4 = dfmix.copy()
  271:         return_value = res2.replace(
  272:             {"b": {r"\s*\.\s*": np.nan}}, inplace=True, regex=True
  273:         )
  274:         assert return_value is None
  275:         res3 = dfmix.replace(regex={"b": {r"\s*\.\s*": np.nan}})
  276:         return_value = res4.replace(regex={"b": {r"\s*\.\s*": np.nan}}, inplace=True)
  277:         assert return_value is None
  278:         expec = DataFrame(
  279:             {"a": mix_abc["a"], "b": ["a", "b", np.nan, np.nan], "c": mix_abc["c"]}
  280:         )
  281:         tm.assert_frame_equal(res, expec)
  282:         tm.assert_frame_equal(res2, expec)
  283:         tm.assert_frame_equal(res3, expec)
  284:         tm.assert_frame_equal(res4, expec)
  285: 
  286:     def test_regex_replace_dict_nested_non_first_character(
  287:         self, any_string_dtype, using_infer_string
  288:     ):
  289:         # GH 25259
  290:         dtype = any_string_dtype
  291:         df = DataFrame({"first": ["abc", "bca", "cab"]}, dtype=dtype)
  292:         if using_infer_string and any_string_dtype == "object":
  293:             with tm.assert_produces_warning(FutureWarning, match="Downcasting"):
  294:                 result = df.replace({"a": "."}, regex=True)
  295:             expected = DataFrame({"first": [".bc", "bc.", "c.b"]})
  296: 
  297:         else:
  298:             result = df.replace({"a": "."}, regex=True)
  299:             expected = DataFrame({"first": [".bc", "bc.", "c.b"]}, dtype=dtype)
  300:         tm.assert_frame_equal(result, expected)
  301: 
  302:     @pytest.mark.xfail(
  303:         using_pyarrow_string_dtype(), reason="can't set float into string"
  304:     )
  305:     def test_regex_replace_dict_nested_gh4115(self):
  306:         df = DataFrame({"Type": ["Q", "T", "Q", "Q", "T"], "tmp": 2})
  307:         expected = DataFrame({"Type": [0, 1, 0, 0, 1], "tmp": 2})
  308:         msg = "Downcasting behavior in `replace`"
  309:         with tm.assert_produces_warning(FutureWarning, match=msg):
  310:             result = df.replace({"Type": {"Q": 0, "T": 1}})
  311:         tm.assert_frame_equal(result, expected)
  312: 
  313:     @pytest.mark.xfail(
  314:         using_pyarrow_string_dtype(), reason="can't set float into string"
  315:     )
  316:     def test_regex_replace_list_to_scalar(self, mix_abc):
  317:         df = DataFrame(mix_abc)
  318:         expec = DataFrame(
  319:             {
  320:                 "a": mix_abc["a"],
  321:                 "b": np.array([np.nan] * 4),
  322:                 "c": [np.nan, np.nan, np.nan, "d"],
  323:             }
  324:         )
  325:         msg = "Downcasting behavior in `replace`"
  326:         with tm.assert_produces_warning(FutureWarning, match=msg):
  327:             res = df.replace([r"\s*\.\s*", "a|b"], np.nan, regex=True)
  328:         res2 = df.copy()
  329:         res3 = df.copy()
  330:         with tm.assert_produces_warning(FutureWarning, match=msg):
  331:             return_value = res2.replace(
  332:                 [r"\s*\.\s*", "a|b"], np.nan, regex=True, inplace=True
  333:             )
  334:         assert return_value is None
  335:         with tm.assert_produces_warning(FutureWarning, match=msg):
  336:             return_value = res3.replace(
  337:                 regex=[r"\s*\.\s*", "a|b"], value=np.nan, inplace=True
  338:             )
  339:         assert return_value is None
  340:         tm.assert_frame_equal(res, expec)
  341:         tm.assert_frame_equal(res2, expec)
  342:         tm.assert_frame_equal(res3, expec)
  343: 
  344:     @pytest.mark.xfail(
  345:         using_pyarrow_string_dtype(), reason="can't set float into string"
  346:     )
  347:     def test_regex_replace_str_to_numeric(self, mix_abc):
  348:         # what happens when you try to replace a numeric value with a regex?
  349:         df = DataFrame(mix_abc)
  350:         res = df.replace(r"\s*\.\s*", 0, regex=True)
  351:         res2 = df.copy()
  352:         return_value = res2.replace(r"\s*\.\s*", 0, inplace=True, regex=True)
  353:         assert return_value is None
  354:         res3 = df.copy()
  355:         return_value = res3.replace(regex=r"\s*\.\s*", value=0, inplace=True)
  356:         assert return_value is None
  357:         expec = DataFrame({"a": mix_abc["a"], "b": ["a", "b", 0, 0], "c": mix_abc["c"]})
  358:         tm.assert_frame_equal(res, expec)
  359:         tm.assert_frame_equal(res2, expec)
  360:         tm.assert_frame_equal(res3, expec)
  361: 
  362:     @pytest.mark.xfail(
  363:         using_pyarrow_string_dtype(), reason="can't set float into string"
  364:     )
  365:     def test_regex_replace_regex_list_to_numeric(self, mix_abc):
  366:         df = DataFrame(mix_abc)
  367:         res = df.replace([r"\s*\.\s*", "b"], 0, regex=True)
  368:         res2 = df.copy()
  369:         return_value = res2.replace([r"\s*\.\s*", "b"], 0, regex=True, inplace=True)
  370:         assert return_value is None
  371:         res3 = df.copy()
  372:         return_value = res3.replace(regex=[r"\s*\.\s*", "b"], value=0, inplace=True)
  373:         assert return_value is None
  374:         expec = DataFrame(
  375:             {"a": mix_abc["a"], "b": ["a", 0, 0, 0], "c": ["a", 0, np.nan, "d"]}
  376:         )
  377:         tm.assert_frame_equal(res, expec)
  378:         tm.assert_frame_equal(res2, expec)
  379:         tm.assert_frame_equal(res3, expec)
  380: 
  381:     def test_regex_replace_series_of_regexes(self, mix_abc):
  382:         df = DataFrame(mix_abc)
  383:         s1 = Series({"b": r"\s*\.\s*"})
  384:         s2 = Series({"b": np.nan})
  385:         res = df.replace(s1, s2, regex=True)
  386:         res2 = df.copy()
  387:         return_value = res2.replace(s1, s2, inplace=True, regex=True)
  388:         assert return_value is None
  389:         res3 = df.copy()
  390:         return_value = res3.replace(regex=s1, value=s2, inplace=True)
  391:         assert return_value is None
  392:         expec = DataFrame(
  393:             {"a": mix_abc["a"], "b": ["a", "b", np.nan, np.nan], "c": mix_abc["c"]}
  394:         )
  395:         tm.assert_frame_equal(res, expec)
  396:         tm.assert_frame_equal(res2, expec)
  397:         tm.assert_frame_equal(res3, expec)
  398: 
  399:     def test_regex_replace_numeric_to_object_conversion(self, mix_abc):
  400:         df = DataFrame(mix_abc)
  401:         expec = DataFrame({"a": ["a", 1, 2, 3], "b": mix_abc["b"], "c": mix_abc["c"]})
  402:         res = df.replace(0, "a")
  403:         tm.assert_frame_equal(res, expec)
  404:         assert res.a.dtype == np.object_
  405: 
  406:     @pytest.mark.parametrize(
  407:         "to_replace", [{"": np.nan, ",": ""}, {",": "", "": np.nan}]
  408:     )
  409:     def test_joint_simple_replace_and_regex_replace(self, to_replace):
  410:         # GH-39338
  411:         df = DataFrame(
  412:             {
  413:                 "col1": ["1,000", "a", "3"],
  414:                 "col2": ["a", "", "b"],
  415:                 "col3": ["a", "b", "c"],
  416:             }
  417:         )
  418:         result = df.replace(regex=to_replace)
  419:         expected = DataFrame(
  420:             {
  421:                 "col1": ["1000", "a", "3"],
  422:                 "col2": ["a", np.nan, "b"],
  423:                 "col3": ["a", "b", "c"],
  424:             }
  425:         )
  426:         tm.assert_frame_equal(result, expected)
  427: 
  428:     @pytest.mark.parametrize("metachar", ["[]", "()", r"\d", r"\w", r"\s"])
  429:     def test_replace_regex_metachar(self, metachar):
  430:         df = DataFrame({"a": [metachar, "else"]})
  431:         result = df.replace({"a": {metachar: "paren"}})
  432:         expected = DataFrame({"a": ["paren", "else"]})
  433:         tm.assert_frame_equal(result, expected)
  434: 
  435:     @pytest.mark.parametrize(
  436:         "data,to_replace,expected",
  437:         [
  438:             (["xax", "xbx"], {"a": "c", "b": "d"}, ["xcx", "xdx"]),
  439:             (["d", "", ""], {r"^\s*$": pd.NA}, ["d", pd.NA, pd.NA]),
  440:         ],
  441:     )
  442:     def test_regex_replace_string_types(
  443:         self,
  444:         data,
  445:         to_replace,
  446:         expected,
  447:         frame_or_series,
  448:         any_string_dtype,
  449:         using_infer_string,
  450:         request,
  451:     ):
  452:         # GH-41333, GH-35977
  453:         dtype = any_string_dtype
  454:         obj = frame_or_series(data, dtype=dtype)
  455:         if using_infer_string and any_string_dtype == "object":
  456:             if len(to_replace) > 1 and isinstance(obj, DataFrame):
  457:                 request.node.add_marker(
  458:                     pytest.mark.xfail(
  459:                         reason="object input array that gets downcasted raises on "
  460:                         "second pass"
  461:                     )
  462:                 )
  463:             with tm.assert_produces_warning(FutureWarning, match="Downcasting"):
  464:                 result = obj.replace(to_replace, regex=True)
  465:                 dtype = "string[pyarrow_numpy]"
  466:         else:
  467:             result = obj.replace(to_replace, regex=True)
  468:         expected = frame_or_series(expected, dtype=dtype)
  469: 
  470:         tm.assert_equal(result, expected)
  471: 
  472:     def test_replace(self, datetime_frame):
  473:         datetime_frame.loc[datetime_frame.index[:5], "A"] = np.nan
  474:         datetime_frame.loc[datetime_frame.index[-5:], "A"] = np.nan
  475: 
  476:         zero_filled = datetime_frame.replace(np.nan, -1e8)
  477:         tm.assert_frame_equal(zero_filled, datetime_frame.fillna(-1e8))
  478:         tm.assert_frame_equal(zero_filled.replace(-1e8, np.nan), datetime_frame)
  479: 
  480:         datetime_frame.loc[datetime_frame.index[:5], "A"] = np.nan
  481:         datetime_frame.loc[datetime_frame.index[-5:], "A"] = np.nan
  482:         datetime_frame.loc[datetime_frame.index[:5], "B"] = -1e8
  483: 
  484:         # empty
  485:         df = DataFrame(index=["a", "b"])
  486:         tm.assert_frame_equal(df, df.replace(5, 7))
  487: 
  488:         # GH 11698
  489:         # test for mixed data types.
  490:         df = DataFrame(
  491:             [("-", pd.to_datetime("20150101")), ("a", pd.to_datetime("20150102"))]
  492:         )
  493:         df1 = df.replace("-", np.nan)
  494:         expected_df = DataFrame(
  495:             [(np.nan, pd.to_datetime("20150101")), ("a", pd.to_datetime("20150102"))]
  496:         )
  497:         tm.assert_frame_equal(df1, expected_df)
  498: 
  499:     def test_replace_list(self):
  500:         obj = {"a": list("ab.."), "b": list("efgh"), "c": list("helo")}
  501:         dfobj = DataFrame(obj)
  502: 
  503:         # lists of regexes and values
  504:         # list of [v1, v2, ..., vN] -> [v1, v2, ..., vN]
  505:         to_replace_res = [r".", r"e"]
  506:         values = [np.nan, "crap"]
  507:         res = dfobj.replace(to_replace_res, values)
  508:         expec = DataFrame(
  509:             {
  510:                 "a": ["a", "b", np.nan, np.nan],
  511:                 "b": ["crap", "f", "g", "h"],
  512:                 "c": ["h", "crap", "l", "o"],
  513:             }
  514:         )
  515:         tm.assert_frame_equal(res, expec)
  516: 
  517:         # list of [v1, v2, ..., vN] -> [v1, v2, .., vN]
  518:         to_replace_res = [r".", r"f"]
  519:         values = [r"..", r"crap"]
  520:         res = dfobj.replace(to_replace_res, values)
  521:         expec = DataFrame(
  522:             {
  523:                 "a": ["a", "b", "..", ".."],
  524:                 "b": ["e", "crap", "g", "h"],
  525:                 "c": ["h", "e", "l", "o"],
  526:             }
  527:         )
  528:         tm.assert_frame_equal(res, expec)
  529: 
  530:     def test_replace_with_empty_list(self, frame_or_series):
  531:         # GH 21977
  532:         ser = Series([["a", "b"], [], np.nan, [1]])
  533:         obj = DataFrame({"col": ser})
  534:         obj = tm.get_obj(obj, frame_or_series)
  535:         expected = obj
  536:         result = obj.replace([], np.nan)
  537:         tm.assert_equal(result, expected)
  538: 
  539:         # GH 19266
  540:         msg = (
  541:             "NumPy boolean array indexing assignment cannot assign {size} "
  542:             "input values to the 1 output values where the mask is true"
  543:         )
  544:         with pytest.raises(ValueError, match=msg.format(size=0)):
  545:             obj.replace({np.nan: []})
  546:         with pytest.raises(ValueError, match=msg.format(size=2)):
  547:             obj.replace({np.nan: ["dummy", "alt"]})
  548: 
  549:     def test_replace_series_dict(self):
  550:         # from GH 3064
  551:         df = DataFrame({"zero": {"a": 0.0, "b": 1}, "one": {"a": 2.0, "b": 0}})
  552:         result = df.replace(0, {"zero": 0.5, "one": 1.0})
  553:         expected = DataFrame({"zero": {"a": 0.5, "b": 1}, "one": {"a": 2.0, "b": 1.0}})
  554:         tm.assert_frame_equal(result, expected)
  555: 
  556:         result = df.replace(0, df.mean())
  557:         tm.assert_frame_equal(result, expected)
  558: 
  559:         # series to series/dict
  560:         df = DataFrame({"zero": {"a": 0.0, "b": 1}, "one": {"a": 2.0, "b": 0}})
  561:         s = Series({"zero": 0.0, "one": 2.0})
  562:         result = df.replace(s, {"zero": 0.5, "one": 1.0})
  563:         expected = DataFrame({"zero": {"a": 0.5, "b": 1}, "one": {"a": 1.0, "b": 0.0}})
  564:         tm.assert_frame_equal(result, expected)
  565: 
  566:         result = df.replace(s, df.mean())
  567:         tm.assert_frame_equal(result, expected)
  568: 
  569:     @pytest.mark.xfail(
  570:         using_pyarrow_string_dtype(), reason="can't set float into string"
  571:     )
  572:     def test_replace_convert(self):
  573:         # gh 3907
  574:         df = DataFrame([["foo", "bar", "bah"], ["bar", "foo", "bah"]])
  575:         m = {"foo": 1, "bar": 2, "bah": 3}
  576:         msg = "Downcasting behavior in `replace` "
  577:         with tm.assert_produces_warning(FutureWarning, match=msg):
  578:             rep = df.replace(m)
  579:         expec = Series([np.int64] * 3)
  580:         res = rep.dtypes
  581:         tm.assert_series_equal(expec, res)
  582: 
  583:     @pytest.mark.xfail(
  584:         using_pyarrow_string_dtype(), reason="can't set float into string"
  585:     )
  586:     def test_replace_mixed(self, float_string_frame):
  587:         mf = float_string_frame
  588:         mf.iloc[5:20, mf.columns.get_loc("foo")] = np.nan
  589:         mf.iloc[-10:, mf.columns.get_loc("A")] = np.nan
  590: 
  591:         result = float_string_frame.replace(np.nan, -18)
  592:         expected = float_string_frame.fillna(value=-18)
  593:         tm.assert_frame_equal(result, expected)
  594:         tm.assert_frame_equal(result.replace(-18, np.nan), float_string_frame)
  595: 
  596:         result = float_string_frame.replace(np.nan, -1e8)
  597:         expected = float_string_frame.fillna(value=-1e8)
  598:         tm.assert_frame_equal(result, expected)
  599:         tm.assert_frame_equal(result.replace(-1e8, np.nan), float_string_frame)
  600: 
  601:     def test_replace_mixed_int_block_upcasting(self):
  602:         # int block upcasting
  603:         df = DataFrame(
  604:             {
  605:                 "A": Series([1.0, 2.0], dtype="float64"),
  606:                 "B": Series([0, 1], dtype="int64"),
  607:             }
  608:         )
  609:         expected = DataFrame(
  610:             {
  611:                 "A": Series([1.0, 2.0], dtype="float64"),
  612:                 "B": Series([0.5, 1], dtype="float64"),
  613:             }
  614:         )
  615:         result = df.replace(0, 0.5)
  616:         tm.assert_frame_equal(result, expected)
  617: 
  618:         return_value = df.replace(0, 0.5, inplace=True)
  619:         assert return_value is None
  620:         tm.assert_frame_equal(df, expected)
  621: 
  622:     def test_replace_mixed_int_block_splitting(self):
  623:         # int block splitting
  624:         df = DataFrame(
  625:             {
  626:                 "A": Series([1.0, 2.0], dtype="float64"),
  627:                 "B": Series([0, 1], dtype="int64"),
  628:                 "C": Series([1, 2], dtype="int64"),
  629:             }
  630:         )
  631:         expected = DataFrame(
  632:             {
  633:                 "A": Series([1.0, 2.0], dtype="float64"),
  634:                 "B": Series([0.5, 1], dtype="float64"),
  635:                 "C": Series([1, 2], dtype="int64"),
  636:             }
  637:         )
  638:         result = df.replace(0, 0.5)
  639:         tm.assert_frame_equal(result, expected)
  640: 
  641:     def test_replace_mixed2(self, using_infer_string):
  642:         # to object block upcasting
  643:         df = DataFrame(
  644:             {
  645:                 "A": Series([1.0, 2.0], dtype="float64"),
  646:                 "B": Series([0, 1], dtype="int64"),
  647:             }
  648:         )
  649:         expected = DataFrame(
  650:             {
  651:                 "A": Series([1, "foo"], dtype="object"),
  652:                 "B": Series([0, 1], dtype="int64"),
  653:             }
  654:         )
  655:         result = df.replace(2, "foo")
  656:         tm.assert_frame_equal(result, expected)
  657: 
  658:         expected = DataFrame(
  659:             {
  660:                 "A": Series(["foo", "bar"]),
  661:                 "B": Series([0, "foo"], dtype="object"),
  662:             }
  663:         )
  664:         if using_infer_string:
  665:             with tm.assert_produces_warning(FutureWarning, match="Downcasting"):
  666:                 result = df.replace([1, 2], ["foo", "bar"])
  667:         else:
  668:             result = df.replace([1, 2], ["foo", "bar"])
  669:         tm.assert_frame_equal(result, expected)
  670: 
  671:     def test_replace_mixed3(self):
  672:         # test case from
  673:         df = DataFrame(
  674:             {"A": Series([3, 0], dtype="int64"), "B": Series([0, 3], dtype="int64")}
  675:         )
  676:         result = df.replace(3, df.mean().to_dict())
  677:         expected = df.copy().astype("float64")
  678:         m = df.mean()
  679:         expected.iloc[0, 0] = m.iloc[0]
  680:         expected.iloc[1, 1] = m.iloc[1]
  681:         tm.assert_frame_equal(result, expected)
  682: 
  683:     def test_replace_nullable_int_with_string_doesnt_cast(self):
  684:         # GH#25438 don't cast df['a'] to float64
  685:         df = DataFrame({"a": [1, 2, 3, np.nan], "b": ["some", "strings", "here", "he"]})
  686:         df["a"] = df["a"].astype("Int64")
  687: 
  688:         res = df.replace("", np.nan)
  689:         tm.assert_series_equal(res["a"], df["a"])
  690: 
  691:     @pytest.mark.parametrize("dtype", ["boolean", "Int64", "Float64"])
  692:     def test_replace_with_nullable_column(self, dtype):
  693:         # GH-44499
  694:         nullable_ser = Series([1, 0, 1], dtype=dtype)
  695:         df = DataFrame({"A": ["A", "B", "x"], "B": nullable_ser})
  696:         result = df.replace("x", "X")
  697:         expected = DataFrame({"A": ["A", "B", "X"], "B": nullable_ser})
  698:         tm.assert_frame_equal(result, expected)
  699: 
  700:     def test_replace_simple_nested_dict(self):
  701:         df = DataFrame({"col": range(1, 5)})
  702:         expected = DataFrame({"col": ["a", 2, 3, "b"]})
  703: 
  704:         result = df.replace({"col": {1: "a", 4: "b"}})
  705:         tm.assert_frame_equal(expected, result)
  706: 
  707:         # in this case, should be the same as the not nested version
  708:         result = df.replace({1: "a", 4: "b"})
  709:         tm.assert_frame_equal(expected, result)
  710: 
  711:     def test_replace_simple_nested_dict_with_nonexistent_value(self):
  712:         df = DataFrame({"col": range(1, 5)})
  713:         expected = DataFrame({"col": ["a", 2, 3, "b"]})
  714: 
  715:         result = df.replace({-1: "-", 1: "a", 4: "b"})
  716:         tm.assert_frame_equal(expected, result)
  717: 
  718:         result = df.replace({"col": {-1: "-", 1: "a", 4: "b"}})
  719:         tm.assert_frame_equal(expected, result)
  720: 
  721:     def test_replace_NA_with_None(self):
  722:         # gh-45601
  723:         df = DataFrame({"value": [42, None]}).astype({"value": "Int64"})
  724:         result = df.replace({pd.NA: None})
  725:         expected = DataFrame({"value": [42, None]}, dtype=object)
  726:         tm.assert_frame_equal(result, expected)
  727: 
  728:     def test_replace_NAT_with_None(self):
  729:         # gh-45836
  730:         df = DataFrame([pd.NaT, pd.NaT])
  731:         result = df.replace({pd.NaT: None, np.nan: None})
  732:         expected = DataFrame([None, None])
  733:         tm.assert_frame_equal(result, expected)
  734: 
  735:     def test_replace_with_None_keeps_categorical(self):
  736:         # gh-46634
  737:         cat_series = Series(["b", "b", "b", "d"], dtype="category")
  738:         df = DataFrame(
  739:             {
  740:                 "id": Series([5, 4, 3, 2], dtype="float64"),
  741:                 "col": cat_series,
  742:             }
  743:         )
  744:         result = df.replace({3: None})
  745: 
  746:         expected = DataFrame(
  747:             {
  748:                 "id": Series([5.0, 4.0, None, 2.0], dtype="object"),
  749:                 "col": cat_series,
  750:             }
  751:         )
  752:         tm.assert_frame_equal(result, expected)
  753: 
  754:     def test_replace_value_is_none(self, datetime_frame):
  755:         orig_value = datetime_frame.iloc[0, 0]
  756:         orig2 = datetime_frame.iloc[1, 0]
  757: 
  758:         datetime_frame.iloc[0, 0] = np.nan
  759:         datetime_frame.iloc[1, 0] = 1
  760: 
  761:         result = datetime_frame.replace(to_replace={np.nan: 0})
  762:         expected = datetime_frame.T.replace(to_replace={np.nan: 0}).T
  763:         tm.assert_frame_equal(result, expected)
  764: 
  765:         result = datetime_frame.replace(to_replace={np.nan: 0, 1: -1e8})
  766:         tsframe = datetime_frame.copy()
  767:         tsframe.iloc[0, 0] = 0
  768:         tsframe.iloc[1, 0] = -1e8
  769:         expected = tsframe
  770:         tm.assert_frame_equal(expected, result)
  771:         datetime_frame.iloc[0, 0] = orig_value
  772:         datetime_frame.iloc[1, 0] = orig2
  773: 
  774:     def test_replace_for_new_dtypes(self, datetime_frame):
  775:         # dtypes
  776:         tsframe = datetime_frame.copy().astype(np.float32)
  777:         tsframe.loc[tsframe.index[:5], "A"] = np.nan
  778:         tsframe.loc[tsframe.index[-5:], "A"] = np.nan
  779: 
  780:         zero_filled = tsframe.replace(np.nan, -1e8)
  781:         tm.assert_frame_equal(zero_filled, tsframe.fillna(-1e8))
  782:         tm.assert_frame_equal(zero_filled.replace(-1e8, np.nan), tsframe)
  783: 
  784:         tsframe.loc[tsframe.index[:5], "A"] = np.nan
  785:         tsframe.loc[tsframe.index[-5:], "A"] = np.nan
  786:         tsframe.loc[tsframe.index[:5], "B"] = np.nan
  787:         msg = "DataFrame.fillna with 'method' is deprecated"
  788:         with tm.assert_produces_warning(FutureWarning, match=msg):
  789:             # TODO: what is this even testing?
  790:             result = tsframe.fillna(method="bfill")
  791:             tm.assert_frame_equal(result, tsframe.fillna(method="bfill"))
  792: 
  793:     @pytest.mark.parametrize(
  794:         "frame, to_replace, value, expected",
  795:         [
  796:             (DataFrame({"ints": [1, 2, 3]}), 1, 0, DataFrame({"ints": [0, 2, 3]})),
  797:             (
  798:                 DataFrame({"ints": [1, 2, 3]}, dtype=np.int32),
  799:                 1,
  800:                 0,
  801:                 DataFrame({"ints": [0, 2, 3]}, dtype=np.int32),
  802:             ),
  803:             (
  804:                 DataFrame({"ints": [1, 2, 3]}, dtype=np.int16),
  805:                 1,
  806:                 0,
  807:                 DataFrame({"ints": [0, 2, 3]}, dtype=np.int16),
  808:             ),
  809:             (
  810:                 DataFrame({"bools": [True, False, True]}),
  811:                 False,
  812:                 True,
  813:                 DataFrame({"bools": [True, True, True]}),
  814:             ),
  815:             (
  816:                 DataFrame({"complex": [1j, 2j, 3j]}),
  817:                 1j,
  818:                 0,
  819:                 DataFrame({"complex": [0j, 2j, 3j]}),
  820:             ),
  821:             (
  822:                 DataFrame(
  823:                     {
  824:                         "datetime64": Index(
  825:                             [
  826:                                 datetime(2018, 5, 28),
  827:                                 datetime(2018, 7, 28),
  828:                                 datetime(2018, 5, 28),
  829:                             ]
  830:                         )
  831:                     }
  832:                 ),
  833:                 datetime(2018, 5, 28),
  834:                 datetime(2018, 7, 28),
  835:                 DataFrame({"datetime64": Index([datetime(2018, 7, 28)] * 3)}),
  836:             ),
  837:             # GH 20380
  838:             (
  839:                 DataFrame({"dt": [datetime(3017, 12, 20)], "str": ["foo"]}),
  840:                 "foo",
  841:                 "bar",
  842:                 DataFrame({"dt": [datetime(3017, 12, 20)], "str": ["bar"]}),
  843:             ),
  844:             # GH 36782
  845:             (
  846:                 DataFrame({"dt": [datetime(2920, 10, 1)]}),
  847:                 datetime(2920, 10, 1),
  848:                 datetime(2020, 10, 1),
  849:                 DataFrame({"dt": [datetime(2020, 10, 1)]}),
  850:             ),
  851:             (
  852:                 DataFrame(
  853:                     {
  854:                         "A": date_range("20130101", periods=3, tz="US/Eastern"),
  855:                         "B": [0, np.nan, 2],
  856:                     }
  857:                 ),
  858:                 Timestamp("20130102", tz="US/Eastern"),
  859:                 Timestamp("20130104", tz="US/Eastern"),
  860:                 DataFrame(
  861:                     {
  862:                         "A": pd.DatetimeIndex(
  863:                             [
  864:                                 Timestamp("20130101", tz="US/Eastern"),
  865:                                 Timestamp("20130104", tz="US/Eastern"),
  866:                                 Timestamp("20130103", tz="US/Eastern"),
  867:                             ]
  868:                         ).as_unit("ns"),
  869:                         "B": [0, np.nan, 2],
  870:                     }
  871:                 ),
  872:             ),
  873:             # GH 35376
  874:             (
  875:                 DataFrame([[1, 1.0], [2, 2.0]]),
  876:                 1.0,
  877:                 5,
  878:                 DataFrame([[5, 5.0], [2, 2.0]]),
  879:             ),
  880:             (
  881:                 DataFrame([[1, 1.0], [2, 2.0]]),
  882:                 1,
  883:                 5,
  884:                 DataFrame([[5, 5.0], [2, 2.0]]),
  885:             ),
  886:             (
  887:                 DataFrame([[1, 1.0], [2, 2.0]]),
  888:                 1.0,
  889:                 5.0,
  890:                 DataFrame([[5, 5.0], [2, 2.0]]),
  891:             ),
  892:             (
  893:                 DataFrame([[1, 1.0], [2, 2.0]]),
  894:                 1,
  895:                 5.0,
  896:                 DataFrame([[5, 5.0], [2, 2.0]]),
  897:             ),
  898:         ],
  899:     )
  900:     def test_replace_dtypes(self, frame, to_replace, value, expected):
  901:         warn = None
  902:         if isinstance(to_replace, datetime) and to_replace.year == 2920:
  903:             warn = FutureWarning
  904:         msg = "Downcasting behavior in `replace` "
  905:         with tm.assert_produces_warning(warn, match=msg):
  906:             result = frame.replace(to_replace, value)
  907:         tm.assert_frame_equal(result, expected)
  908: 
  909:     def test_replace_input_formats_listlike(self):
  910:         # both dicts
  911:         to_rep = {"A": np.nan, "B": 0, "C": ""}
  912:         values = {"A": 0, "B": -1, "C": "missing"}
  913:         df = DataFrame(
  914:             {"A": [np.nan, 0, np.inf], "B": [0, 2, 5], "C": ["", "asdf", "fd"]}
  915:         )
  916:         filled = df.replace(to_rep, values)
  917:         expected = {k: v.replace(to_rep[k], values[k]) for k, v in df.items()}
  918:         tm.assert_frame_equal(filled, DataFrame(expected))
  919: 
  920:         result = df.replace([0, 2, 5], [5, 2, 0])
  921:         expected = DataFrame(
  922:             {"A": [np.nan, 5, np.inf], "B": [5, 2, 0], "C": ["", "asdf", "fd"]}
  923:         )
  924:         tm.assert_frame_equal(result, expected)
  925: 
  926:         # scalar to dict
  927:         values = {"A": 0, "B": -1, "C": "missing"}
  928:         df = DataFrame(
  929:             {"A": [np.nan, 0, np.nan], "B": [0, 2, 5], "C": ["", "asdf", "fd"]}
  930:         )
  931:         filled = df.replace(np.nan, values)
  932:         expected = {k: v.replace(np.nan, values[k]) for k, v in df.items()}
  933:         tm.assert_frame_equal(filled, DataFrame(expected))
  934: 
  935:         # list to list
  936:         to_rep = [np.nan, 0, ""]
  937:         values = [-2, -1, "missing"]
  938:         result = df.replace(to_rep, values)
  939:         expected = df.copy()
  940:         for rep, value in zip(to_rep, values):
  941:             return_value = expected.replace(rep, value, inplace=True)
  942:             assert return_value is None
  943:         tm.assert_frame_equal(result, expected)
  944: 
  945:         msg = r"Replacement lists must match in length\. Expecting 3 got 2"
  946:         with pytest.raises(ValueError, match=msg):
  947:             df.replace(to_rep, values[1:])
  948: 
  949:     @pytest.mark.xfail(
  950:         using_pyarrow_string_dtype(), reason="can't set float into string"
  951:     )
  952:     def test_replace_input_formats_scalar(self):
  953:         df = DataFrame(
  954:             {"A": [np.nan, 0, np.inf], "B": [0, 2, 5], "C": ["", "asdf", "fd"]}
  955:         )
  956: 
  957:         # dict to scalar
  958:         to_rep = {"A": np.nan, "B": 0, "C": ""}
  959:         filled = df.replace(to_rep, 0)
  960:         expected = {k: v.replace(to_rep[k], 0) for k, v in df.items()}
  961:         tm.assert_frame_equal(filled, DataFrame(expected))
  962: 
  963:         msg = "value argument must be scalar, dict, or Series"
  964:         with pytest.raises(TypeError, match=msg):
  965:             df.replace(to_rep, [np.nan, 0, ""])
  966: 
  967:         # list to scalar
  968:         to_rep = [np.nan, 0, ""]
  969:         result = df.replace(to_rep, -1)
  970:         expected = df.copy()
  971:         for rep in to_rep:
  972:             return_value = expected.replace(rep, -1, inplace=True)
  973:             assert return_value is None
  974:         tm.assert_frame_equal(result, expected)
  975: 
  976:     def test_replace_limit(self):
  977:         # TODO
  978:         pass
  979: 
  980:     @pytest.mark.xfail(
  981:         using_pyarrow_string_dtype(), reason="can't set float into string"
  982:     )
  983:     def test_replace_dict_no_regex(self):
  984:         answer = Series(
  985:             {
  986:                 0: "Strongly Agree",
  987:                 1: "Agree",
  988:                 2: "Neutral",
  989:                 3: "Disagree",
  990:                 4: "Strongly Disagree",
  991:             }
  992:         )
  993:         weights = {
  994:             "Agree": 4,
  995:             "Disagree": 2,
  996:             "Neutral": 3,
  997:             "Strongly Agree": 5,
  998:             "Strongly Disagree": 1,
  999:         }
 1000:         expected = Series({0: 5, 1: 4, 2: 3, 3: 2, 4: 1})
 1001:         msg = "Downcasting behavior in `replace` "
 1002:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1003:             result = answer.replace(weights)
 1004:         tm.assert_series_equal(result, expected)
 1005: 
 1006:     @pytest.mark.xfail(
 1007:         using_pyarrow_string_dtype(), reason="can't set float into string"
 1008:     )
 1009:     def test_replace_series_no_regex(self):
 1010:         answer = Series(
 1011:             {
 1012:                 0: "Strongly Agree",
 1013:                 1: "Agree",
 1014:                 2: "Neutral",
 1015:                 3: "Disagree",
 1016:                 4: "Strongly Disagree",
 1017:             }
 1018:         )
 1019:         weights = Series(
 1020:             {
 1021:                 "Agree": 4,
 1022:                 "Disagree": 2,
 1023:                 "Neutral": 3,
 1024:                 "Strongly Agree": 5,
 1025:                 "Strongly Disagree": 1,
 1026:             }
 1027:         )
 1028:         expected = Series({0: 5, 1: 4, 2: 3, 3: 2, 4: 1})
 1029:         msg = "Downcasting behavior in `replace` "
 1030:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1031:             result = answer.replace(weights)
 1032:         tm.assert_series_equal(result, expected)
 1033: 
 1034:     def test_replace_dict_tuple_list_ordering_remains_the_same(self):
 1035:         df = DataFrame({"A": [np.nan, 1]})
 1036:         res1 = df.replace(to_replace={np.nan: 0, 1: -1e8})
 1037:         res2 = df.replace(to_replace=(1, np.nan), value=[-1e8, 0])
 1038:         res3 = df.replace(to_replace=[1, np.nan], value=[-1e8, 0])
 1039: 
 1040:         expected = DataFrame({"A": [0, -1e8]})
 1041:         tm.assert_frame_equal(res1, res2)
 1042:         tm.assert_frame_equal(res2, res3)
 1043:         tm.assert_frame_equal(res3, expected)
 1044: 
 1045:     def test_replace_doesnt_replace_without_regex(self):
 1046:         df = DataFrame(
 1047:             {
 1048:                 "fol": [1, 2, 2, 3],
 1049:                 "T_opp": ["0", "vr", "0", "0"],
 1050:                 "T_Dir": ["0", "0", "0", "bt"],
 1051:                 "T_Enh": ["vo", "0", "0", "0"],
 1052:             }
 1053:         )
 1054:         res = df.replace({r"\D": 1})
 1055:         tm.assert_frame_equal(df, res)
 1056: 
 1057:     def test_replace_bool_with_string(self):
 1058:         df = DataFrame({"a": [True, False], "b": list("ab")})
 1059:         result = df.replace(True, "a")
 1060:         expected = DataFrame({"a": ["a", False], "b": df.b})
 1061:         tm.assert_frame_equal(result, expected)
 1062: 
 1063:     def test_replace_pure_bool_with_string_no_op(self):
 1064:         df = DataFrame(np.random.default_rng(2).random((2, 2)) > 0.5)
 1065:         result = df.replace("asdf", "fdsa")
 1066:         tm.assert_frame_equal(df, result)
 1067: 
 1068:     def test_replace_bool_with_bool(self):
 1069:         df = DataFrame(np.random.default_rng(2).random((2, 2)) > 0.5)
 1070:         result = df.replace(False, True)
 1071:         expected = DataFrame(np.ones((2, 2), dtype=bool))
 1072:         tm.assert_frame_equal(result, expected)
 1073: 
 1074:     def test_replace_with_dict_with_bool_keys(self):
 1075:         df = DataFrame({0: [True, False], 1: [False, True]})
 1076:         result = df.replace({"asdf": "asdb", True: "yes"})
 1077:         expected = DataFrame({0: ["yes", False], 1: [False, "yes"]})
 1078:         tm.assert_frame_equal(result, expected)
 1079: 
 1080:     def test_replace_dict_strings_vs_ints(self):
 1081:         # GH#34789
 1082:         df = DataFrame({"Y0": [1, 2], "Y1": [3, 4]})
 1083:         result = df.replace({"replace_string": "test"})
 1084: 
 1085:         tm.assert_frame_equal(result, df)
 1086: 
 1087:         result = df["Y0"].replace({"replace_string": "test"})
 1088:         tm.assert_series_equal(result, df["Y0"])
 1089: 
 1090:     def test_replace_truthy(self):
 1091:         df = DataFrame({"a": [True, True]})
 1092:         r = df.replace([np.inf, -np.inf], np.nan)
 1093:         e = df
 1094:         tm.assert_frame_equal(r, e)
 1095: 
 1096:     def test_nested_dict_overlapping_keys_replace_int(self):
 1097:         # GH 27660 keep behaviour consistent for simple dictionary and
 1098:         # nested dictionary replacement
 1099:         df = DataFrame({"a": list(range(1, 5))})
 1100: 
 1101:         result = df.replace({"a": dict(zip(range(1, 5), range(2, 6)))})
 1102:         expected = df.replace(dict(zip(range(1, 5), range(2, 6))))
 1103:         tm.assert_frame_equal(result, expected)
 1104: 
 1105:     def test_nested_dict_overlapping_keys_replace_str(self):
 1106:         # GH 27660
 1107:         a = np.arange(1, 5)
 1108:         astr = a.astype(str)
 1109:         bstr = np.arange(2, 6).astype(str)
 1110:         df = DataFrame({"a": astr})
 1111:         result = df.replace(dict(zip(astr, bstr)))
 1112:         expected = df.replace({"a": dict(zip(astr, bstr))})
 1113:         tm.assert_frame_equal(result, expected)
 1114: 
 1115:     @pytest.mark.xfail(
 1116:         using_pyarrow_string_dtype(), reason="can't set float into string"
 1117:     )
 1118:     def test_replace_swapping_bug(self, using_infer_string):
 1119:         df = DataFrame({"a": [True, False, True]})
 1120:         res = df.replace({"a": {True: "Y", False: "N"}})
 1121:         expect = DataFrame({"a": ["Y", "N", "Y"]})
 1122:         tm.assert_frame_equal(res, expect)
 1123: 
 1124:         df = DataFrame({"a": [0, 1, 0]})
 1125:         res = df.replace({"a": {0: "Y", 1: "N"}})
 1126:         expect = DataFrame({"a": ["Y", "N", "Y"]})
 1127:         tm.assert_frame_equal(res, expect)
 1128: 
 1129:     @pytest.mark.xfail(
 1130:         using_pyarrow_string_dtype(), reason="can't set float into string"
 1131:     )
 1132:     def test_replace_period(self):
 1133:         d = {
 1134:             "fname": {
 1135:                 "out_augmented_AUG_2011.json": pd.Period(year=2011, month=8, freq="M"),
 1136:                 "out_augmented_JAN_2011.json": pd.Period(year=2011, month=1, freq="M"),
 1137:                 "out_augmented_MAY_2012.json": pd.Period(year=2012, month=5, freq="M"),
 1138:                 "out_augmented_SUBSIDY_WEEK.json": pd.Period(
 1139:                     year=2011, month=4, freq="M"
 1140:                 ),
 1141:                 "out_augmented_AUG_2012.json": pd.Period(year=2012, month=8, freq="M"),
 1142:                 "out_augmented_MAY_2011.json": pd.Period(year=2011, month=5, freq="M"),
 1143:                 "out_augmented_SEP_2013.json": pd.Period(year=2013, month=9, freq="M"),
 1144:             }
 1145:         }
 1146: 
 1147:         df = DataFrame(
 1148:             [
 1149:                 "out_augmented_AUG_2012.json",
 1150:                 "out_augmented_SEP_2013.json",
 1151:                 "out_augmented_SUBSIDY_WEEK.json",
 1152:                 "out_augmented_MAY_2012.json",
 1153:                 "out_augmented_MAY_2011.json",
 1154:                 "out_augmented_AUG_2011.json",
 1155:                 "out_augmented_JAN_2011.json",
 1156:             ],
 1157:             columns=["fname"],
 1158:         )
 1159:         assert set(df.fname.values) == set(d["fname"].keys())
 1160: 
 1161:         expected = DataFrame({"fname": [d["fname"][k] for k in df.fname.values]})
 1162:         assert expected.dtypes.iloc[0] == "Period[M]"
 1163:         msg = "Downcasting behavior in `replace` "
 1164:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1165:             result = df.replace(d)
 1166:         tm.assert_frame_equal(result, expected)
 1167: 
 1168:     @pytest.mark.xfail(
 1169:         using_pyarrow_string_dtype(), reason="can't set float into string"
 1170:     )
 1171:     def test_replace_datetime(self):
 1172:         d = {
 1173:             "fname": {
 1174:                 "out_augmented_AUG_2011.json": Timestamp("2011-08"),
 1175:                 "out_augmented_JAN_2011.json": Timestamp("2011-01"),
 1176:                 "out_augmented_MAY_2012.json": Timestamp("2012-05"),
 1177:                 "out_augmented_SUBSIDY_WEEK.json": Timestamp("2011-04"),
 1178:                 "out_augmented_AUG_2012.json": Timestamp("2012-08"),
 1179:                 "out_augmented_MAY_2011.json": Timestamp("2011-05"),
 1180:                 "out_augmented_SEP_2013.json": Timestamp("2013-09"),
 1181:             }
 1182:         }
 1183: 
 1184:         df = DataFrame(
 1185:             [
 1186:                 "out_augmented_AUG_2012.json",
 1187:                 "out_augmented_SEP_2013.json",
 1188:                 "out_augmented_SUBSIDY_WEEK.json",
 1189:                 "out_augmented_MAY_2012.json",
 1190:                 "out_augmented_MAY_2011.json",
 1191:                 "out_augmented_AUG_2011.json",
 1192:                 "out_augmented_JAN_2011.json",
 1193:             ],
 1194:             columns=["fname"],
 1195:         )
 1196:         assert set(df.fname.values) == set(d["fname"].keys())
 1197:         expected = DataFrame({"fname": [d["fname"][k] for k in df.fname.values]})
 1198:         msg = "Downcasting behavior in `replace` "
 1199:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1200:             result = df.replace(d)
 1201:         tm.assert_frame_equal(result, expected)
 1202: 
 1203:     def test_replace_datetimetz(self):
 1204:         # GH 11326
 1205:         # behaving poorly when presented with a datetime64[ns, tz]
 1206:         df = DataFrame(
 1207:             {
 1208:                 "A": date_range("20130101", periods=3, tz="US/Eastern"),
 1209:                 "B": [0, np.nan, 2],
 1210:             }
 1211:         )
 1212:         result = df.replace(np.nan, 1)
 1213:         expected = DataFrame(
 1214:             {
 1215:                 "A": date_range("20130101", periods=3, tz="US/Eastern"),
 1216:                 "B": Series([0, 1, 2], dtype="float64"),
 1217:             }
 1218:         )
 1219:         tm.assert_frame_equal(result, expected)
 1220: 
 1221:         result = df.fillna(1)
 1222:         tm.assert_frame_equal(result, expected)
 1223: 
 1224:         result = df.replace(0, np.nan)
 1225:         expected = DataFrame(
 1226:             {
 1227:                 "A": date_range("20130101", periods=3, tz="US/Eastern"),
 1228:                 "B": [np.nan, np.nan, 2],
 1229:             }
 1230:         )
 1231:         tm.assert_frame_equal(result, expected)
 1232: 
 1233:         result = df.replace(
 1234:             Timestamp("20130102", tz="US/Eastern"),
 1235:             Timestamp("20130104", tz="US/Eastern"),
 1236:         )
 1237:         expected = DataFrame(
 1238:             {
 1239:                 "A": [
 1240:                     Timestamp("20130101", tz="US/Eastern"),
 1241:                     Timestamp("20130104", tz="US/Eastern"),
 1242:                     Timestamp("20130103", tz="US/Eastern"),
 1243:                 ],
 1244:                 "B": [0, np.nan, 2],
 1245:             }
 1246:         )
 1247:         expected["A"] = expected["A"].dt.as_unit("ns")
 1248:         tm.assert_frame_equal(result, expected)
 1249: 
 1250:         result = df.copy()
 1251:         result.iloc[1, 0] = np.nan
 1252:         result = result.replace({"A": pd.NaT}, Timestamp("20130104", tz="US/Eastern"))
 1253:         tm.assert_frame_equal(result, expected)
 1254: 
 1255:         # pre-2.0 this would coerce to object with mismatched tzs
 1256:         result = df.copy()
 1257:         result.iloc[1, 0] = np.nan
 1258:         result = result.replace({"A": pd.NaT}, Timestamp("20130104", tz="US/Pacific"))
 1259:         expected = DataFrame(
 1260:             {
 1261:                 "A": [
 1262:                     Timestamp("20130101", tz="US/Eastern"),
 1263:                     Timestamp("20130104", tz="US/Pacific").tz_convert("US/Eastern"),
 1264:                     Timestamp("20130103", tz="US/Eastern"),
 1265:                 ],
 1266:                 "B": [0, np.nan, 2],
 1267:             }
 1268:         )
 1269:         expected["A"] = expected["A"].dt.as_unit("ns")
 1270:         tm.assert_frame_equal(result, expected)
 1271: 
 1272:         result = df.copy()
 1273:         result.iloc[1, 0] = np.nan
 1274:         result = result.replace({"A": np.nan}, Timestamp("20130104"))
 1275:         expected = DataFrame(
 1276:             {
 1277:                 "A": [
 1278:                     Timestamp("20130101", tz="US/Eastern"),
 1279:                     Timestamp("20130104"),
 1280:                     Timestamp("20130103", tz="US/Eastern"),
 1281:                 ],
 1282:                 "B": [0, np.nan, 2],
 1283:             }
 1284:         )
 1285:         tm.assert_frame_equal(result, expected)
 1286: 
 1287:     def test_replace_with_empty_dictlike(self, mix_abc):
 1288:         # GH 15289
 1289:         df = DataFrame(mix_abc)
 1290:         tm.assert_frame_equal(df, df.replace({}))
 1291:         tm.assert_frame_equal(df, df.replace(Series([], dtype=object)))
 1292: 
 1293:         tm.assert_frame_equal(df, df.replace({"b": {}}))
 1294:         tm.assert_frame_equal(df, df.replace(Series({"b": {}})))
 1295: 
 1296:     @pytest.mark.parametrize(
 1297:         "to_replace, method, expected",
 1298:         [
 1299:             (0, "bfill", {"A": [1, 1, 2], "B": [5, np.nan, 7], "C": ["a", "b", "c"]}),
 1300:             (
 1301:                 np.nan,
 1302:                 "bfill",
 1303:                 {"A": [0, 1, 2], "B": [5.0, 7.0, 7.0], "C": ["a", "b", "c"]},
 1304:             ),
 1305:             ("d", "ffill", {"A": [0, 1, 2], "B": [5, np.nan, 7], "C": ["a", "b", "c"]}),
 1306:             (
 1307:                 [0, 2],
 1308:                 "bfill",
 1309:                 {"A": [1, 1, 2], "B": [5, np.nan, 7], "C": ["a", "b", "c"]},
 1310:             ),
 1311:             (
 1312:                 [1, 2],
 1313:                 "pad",
 1314:                 {"A": [0, 0, 0], "B": [5, np.nan, 7], "C": ["a", "b", "c"]},
 1315:             ),
 1316:             (
 1317:                 (1, 2),
 1318:                 "bfill",
 1319:                 {"A": [0, 2, 2], "B": [5, np.nan, 7], "C": ["a", "b", "c"]},
 1320:             ),
 1321:             (
 1322:                 ["b", "c"],
 1323:                 "ffill",
 1324:                 {"A": [0, 1, 2], "B": [5, np.nan, 7], "C": ["a", "a", "a"]},
 1325:             ),
 1326:         ],
 1327:     )
 1328:     def test_replace_method(self, to_replace, method, expected):
 1329:         # GH 19632
 1330:         df = DataFrame({"A": [0, 1, 2], "B": [5, np.nan, 7], "C": ["a", "b", "c"]})
 1331: 
 1332:         msg = "The 'method' keyword in DataFrame.replace is deprecated"
 1333:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1334:             result = df.replace(to_replace=to_replace, value=None, method=method)
 1335:         expected = DataFrame(expected)
 1336:         tm.assert_frame_equal(result, expected)
 1337: 
 1338:     @pytest.mark.parametrize(
 1339:         "replace_dict, final_data",
 1340:         [({"a": 1, "b": 1}, [[3, 3], [2, 2]]), ({"a": 1, "b": 2}, [[3, 1], [2, 3]])],
 1341:     )
 1342:     def test_categorical_replace_with_dict(self, replace_dict, final_data):
 1343:         # GH 26988
 1344:         df = DataFrame([[1, 1], [2, 2]], columns=["a", "b"], dtype="category")
 1345: 
 1346:         final_data = np.array(final_data)
 1347: 
 1348:         a = pd.Categorical(final_data[:, 0], categories=[3, 2])
 1349: 
 1350:         ex_cat = [3, 2] if replace_dict["b"] == 1 else [1, 3]
 1351:         b = pd.Categorical(final_data[:, 1], categories=ex_cat)
 1352: 
 1353:         expected = DataFrame({"a": a, "b": b})
 1354:         msg2 = "with CategoricalDtype is deprecated"
 1355:         with tm.assert_produces_warning(FutureWarning, match=msg2):
 1356:             result = df.replace(replace_dict, 3)
 1357:         tm.assert_frame_equal(result, expected)
 1358:         msg = (
 1359:             r"Attributes of DataFrame.iloc\[:, 0\] \(column name=\"a\"\) are "
 1360:             "different"
 1361:         )
 1362:         with pytest.raises(AssertionError, match=msg):
 1363:             # ensure non-inplace call does not affect original
 1364:             tm.assert_frame_equal(df, expected)
 1365:         with tm.assert_produces_warning(FutureWarning, match=msg2):
 1366:             return_value = df.replace(replace_dict, 3, inplace=True)
 1367:         assert return_value is None
 1368:         tm.assert_frame_equal(df, expected)
 1369: 
 1370:     @pytest.mark.parametrize(
 1371:         "df, to_replace, exp",
 1372:         [
 1373:             (
 1374:                 {"col1": [1, 2, 3], "col2": [4, 5, 6]},
 1375:                 {4: 5, 5: 6, 6: 7},
 1376:                 {"col1": [1, 2, 3], "col2": [5, 6, 7]},
 1377:             ),
 1378:             (
 1379:                 {"col1": [1, 2, 3], "col2": ["4", "5", "6"]},
 1380:                 {"4": "5", "5": "6", "6": "7"},
 1381:                 {"col1": [1, 2, 3], "col2": ["5", "6", "7"]},
 1382:             ),
 1383:         ],
 1384:     )
 1385:     def test_replace_commutative(self, df, to_replace, exp):
 1386:         # GH 16051
 1387:         # DataFrame.replace() overwrites when values are non-numeric
 1388:         # also added to data frame whilst issue was for series
 1389: 
 1390:         df = DataFrame(df)
 1391: 
 1392:         expected = DataFrame(exp)
 1393:         result = df.replace(to_replace)
 1394:         tm.assert_frame_equal(result, expected)
 1395: 
 1396:     @pytest.mark.xfail(
 1397:         using_pyarrow_string_dtype(), reason="can't set float into string"
 1398:     )
 1399:     @pytest.mark.parametrize(
 1400:         "replacer",
 1401:         [
 1402:             Timestamp("20170827"),
 1403:             np.int8(1),
 1404:             np.int16(1),
 1405:             np.float32(1),
 1406:             np.float64(1),
 1407:         ],
 1408:     )
 1409:     def test_replace_replacer_dtype(self, replacer):
 1410:         # GH26632
 1411:         df = DataFrame(["a"])
 1412:         msg = "Downcasting behavior in `replace` "
 1413:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1414:             result = df.replace({"a": replacer, "b": replacer})
 1415:         expected = DataFrame([replacer])
 1416:         tm.assert_frame_equal(result, expected)
 1417: 
 1418:     def test_replace_after_convert_dtypes(self):
 1419:         # GH31517
 1420:         df = DataFrame({"grp": [1, 2, 3, 4, 5]}, dtype="Int64")
 1421:         result = df.replace(1, 10)
 1422:         expected = DataFrame({"grp": [10, 2, 3, 4, 5]}, dtype="Int64")
 1423:         tm.assert_frame_equal(result, expected)
 1424: 
 1425:     def test_replace_invalid_to_replace(self):
 1426:         # GH 18634
 1427:         # API: replace() should raise an exception if invalid argument is given
 1428:         df = DataFrame({"one": ["a", "b ", "c"], "two": ["d ", "e ", "f "]})
 1429:         msg = (
 1430:             r"Expecting 'to_replace' to be either a scalar, array-like, "
 1431:             r"dict or None, got invalid type.*"
 1432:         )
 1433:         msg2 = (
 1434:             "DataFrame.replace without 'value' and with non-dict-like "
 1435:             "'to_replace' is deprecated"
 1436:         )
 1437:         with pytest.raises(TypeError, match=msg):
 1438:             with tm.assert_produces_warning(FutureWarning, match=msg2):
 1439:                 df.replace(lambda x: x.strip())
 1440: 
 1441:     @pytest.mark.parametrize("dtype", ["float", "float64", "int64", "Int64", "boolean"])
 1442:     @pytest.mark.parametrize("value", [np.nan, pd.NA])
 1443:     def test_replace_no_replacement_dtypes(self, dtype, value):
 1444:         # https://github.com/pandas-dev/pandas/issues/32988
 1445:         df = DataFrame(np.eye(2), dtype=dtype)
 1446:         result = df.replace(to_replace=[None, -np.inf, np.inf], value=value)
 1447:         tm.assert_frame_equal(result, df)
 1448: 
 1449:     @pytest.mark.parametrize("replacement", [np.nan, 5])
 1450:     def test_replace_with_duplicate_columns(self, replacement):
 1451:         # GH 24798
 1452:         result = DataFrame({"A": [1, 2, 3], "A1": [4, 5, 6], "B": [7, 8, 9]})
 1453:         result.columns = list("AAB")
 1454: 
 1455:         expected = DataFrame(
 1456:             {"A": [1, 2, 3], "A1": [4, 5, 6], "B": [replacement, 8, 9]}
 1457:         )
 1458:         expected.columns = list("AAB")
 1459: 
 1460:         result["B"] = result["B"].replace(7, replacement)
 1461: 
 1462:         tm.assert_frame_equal(result, expected)
 1463: 
 1464:     @pytest.mark.parametrize("value", [pd.Period("2020-01"), pd.Interval(0, 5)])
 1465:     def test_replace_ea_ignore_float(self, frame_or_series, value):
 1466:         # GH#34871
 1467:         obj = DataFrame({"Per": [value] * 3})
 1468:         obj = tm.get_obj(obj, frame_or_series)
 1469: 
 1470:         expected = obj.copy()
 1471:         result = obj.replace(1.0, 0.0)
 1472:         tm.assert_equal(expected, result)
 1473: 
 1474:     def test_replace_value_category_type(self):
 1475:         """
 1476:         Test for #23305: to ensure category dtypes are maintained
 1477:         after replace with direct values
 1478:         """
 1479: 
 1480:         # create input data
 1481:         input_dict = {
 1482:             "col1": [1, 2, 3, 4],
 1483:             "col2": ["a", "b", "c", "d"],
 1484:             "col3": [1.5, 2.5, 3.5, 4.5],
 1485:             "col4": ["cat1", "cat2", "cat3", "cat4"],
 1486:             "col5": ["obj1", "obj2", "obj3", "obj4"],
 1487:         }
 1488:         # explicitly cast columns as category and order them
 1489:         input_df = DataFrame(data=input_dict).astype(
 1490:             {"col2": "category", "col4": "category"}
 1491:         )
 1492:         input_df["col2"] = input_df["col2"].cat.reorder_categories(
 1493:             ["a", "b", "c", "d"], ordered=True
 1494:         )
 1495:         input_df["col4"] = input_df["col4"].cat.reorder_categories(
 1496:             ["cat1", "cat2", "cat3", "cat4"], ordered=True
 1497:         )
 1498: 
 1499:         # create expected dataframe
 1500:         expected_dict = {
 1501:             "col1": [1, 2, 3, 4],
 1502:             "col2": ["a", "b", "c", "z"],
 1503:             "col3": [1.5, 2.5, 3.5, 4.5],
 1504:             "col4": ["cat1", "catX", "cat3", "cat4"],
 1505:             "col5": ["obj9", "obj2", "obj3", "obj4"],
 1506:         }
 1507:         # explicitly cast columns as category and order them
 1508:         expected = DataFrame(data=expected_dict).astype(
 1509:             {"col2": "category", "col4": "category"}
 1510:         )
 1511:         expected["col2"] = expected["col2"].cat.reorder_categories(
 1512:             ["a", "b", "c", "z"], ordered=True
 1513:         )
 1514:         expected["col4"] = expected["col4"].cat.reorder_categories(
 1515:             ["cat1", "catX", "cat3", "cat4"], ordered=True
 1516:         )
 1517: 
 1518:         # replace values in input dataframe
 1519:         msg = (
 1520:             r"The behavior of Series\.replace \(and DataFrame.replace\) "
 1521:             "with CategoricalDtype"
 1522:         )
 1523:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1524:             input_df = input_df.replace("d", "z")
 1525:             input_df = input_df.replace("obj1", "obj9")
 1526:             result = input_df.replace("cat2", "catX")
 1527: 
 1528:         tm.assert_frame_equal(result, expected)
 1529: 
 1530:     def test_replace_dict_category_type(self):
 1531:         """
 1532:         Test to ensure category dtypes are maintained
 1533:         after replace with dict values
 1534:         """
 1535:         # GH#35268, GH#44940
 1536: 
 1537:         # create input dataframe
 1538:         input_dict = {"col1": ["a"], "col2": ["obj1"], "col3": ["cat1"]}
 1539:         # explicitly cast columns as category
 1540:         input_df = DataFrame(data=input_dict).astype(
 1541:             {"col1": "category", "col2": "category", "col3": "category"}
 1542:         )
 1543: 
 1544:         # create expected dataframe
 1545:         expected_dict = {"col1": ["z"], "col2": ["obj9"], "col3": ["catX"]}
 1546:         # explicitly cast columns as category
 1547:         expected = DataFrame(data=expected_dict).astype(
 1548:             {"col1": "category", "col2": "category", "col3": "category"}
 1549:         )
 1550: 
 1551:         # replace values in input dataframe using a dict
 1552:         msg = (
 1553:             r"The behavior of Series\.replace \(and DataFrame.replace\) "
 1554:             "with CategoricalDtype"
 1555:         )
 1556:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1557:             result = input_df.replace({"a": "z", "obj1": "obj9", "cat1": "catX"})
 1558: 
 1559:         tm.assert_frame_equal(result, expected)
 1560: 
 1561:     def test_replace_with_compiled_regex(self):
 1562:         # https://github.com/pandas-dev/pandas/issues/35680
 1563:         df = DataFrame(["a", "b", "c"])
 1564:         regex = re.compile("^a$")
 1565:         result = df.replace({regex: "z"}, regex=True)
 1566:         expected = DataFrame(["z", "b", "c"])
 1567:         tm.assert_frame_equal(result, expected)
 1568: 
 1569:     def test_replace_intervals(self, using_infer_string):
 1570:         # https://github.com/pandas-dev/pandas/issues/35931
 1571:         df = DataFrame({"a": [pd.Interval(0, 1), pd.Interval(0, 1)]})
 1572:         warning = FutureWarning if using_infer_string else None
 1573:         with tm.assert_produces_warning(warning, match="Downcasting"):
 1574:             result = df.replace({"a": {pd.Interval(0, 1): "x"}})
 1575:         expected = DataFrame({"a": ["x", "x"]})
 1576:         tm.assert_frame_equal(result, expected)
 1577: 
 1578:     def test_replace_unicode(self):
 1579:         # GH: 16784
 1580:         columns_values_map = {"positive": {"ж­Јйќў": 1, "дё­з«‹": 1, "иґџйќў": 0}}
 1581:         df1 = DataFrame({"positive": np.ones(3)})
 1582:         result = df1.replace(columns_values_map)
 1583:         expected = DataFrame({"positive": np.ones(3)})
 1584:         tm.assert_frame_equal(result, expected)
 1585: 
 1586:     def test_replace_bytes(self, frame_or_series):
 1587:         # GH#38900
 1588:         obj = frame_or_series(["o"]).astype("|S")
 1589:         expected = obj.copy()
 1590:         obj = obj.replace({None: np.nan})
 1591:         tm.assert_equal(obj, expected)
 1592: 
 1593:     @pytest.mark.parametrize(
 1594:         "data, to_replace, value, expected",
 1595:         [
 1596:             ([1], [1.0], [0], [0]),
 1597:             ([1], [1], [0], [0]),
 1598:             ([1.0], [1.0], [0], [0.0]),
 1599:             ([1.0], [1], [0], [0.0]),
 1600:         ],
 1601:     )
 1602:     @pytest.mark.parametrize("box", [list, tuple, np.array])
 1603:     def test_replace_list_with_mixed_type(
 1604:         self, data, to_replace, value, expected, box, frame_or_series
 1605:     ):
 1606:         # GH#40371
 1607:         obj = frame_or_series(data)
 1608:         expected = frame_or_series(expected)
 1609:         result = obj.replace(box(to_replace), value)
 1610:         tm.assert_equal(result, expected)
 1611: 
 1612:     @pytest.mark.parametrize("val", [2, np.nan, 2.0])
 1613:     def test_replace_value_none_dtype_numeric(self, val):
 1614:         # GH#48231
 1615:         df = DataFrame({"a": [1, val]})
 1616:         result = df.replace(val, None)
 1617:         expected = DataFrame({"a": [1, None]}, dtype=object)
 1618:         tm.assert_frame_equal(result, expected)
 1619: 
 1620:         df = DataFrame({"a": [1, val]})
 1621:         result = df.replace({val: None})
 1622:         tm.assert_frame_equal(result, expected)
 1623: 
 1624:     def test_replace_with_nil_na(self):
 1625:         # GH 32075
 1626:         ser = DataFrame({"a": ["nil", pd.NA]})
 1627:         expected = DataFrame({"a": ["anything else", pd.NA]}, index=[0, 1])
 1628:         result = ser.replace("nil", "anything else")
 1629:         tm.assert_frame_equal(expected, result)
 1630: 
 1631: 
 1632: class TestDataFrameReplaceRegex:
 1633:     @pytest.mark.parametrize(
 1634:         "data",
 1635:         [
 1636:             {"a": list("ab.."), "b": list("efgh")},
 1637:             {"a": list("ab.."), "b": list(range(4))},
 1638:         ],
 1639:     )
 1640:     @pytest.mark.parametrize(
 1641:         "to_replace,value", [(r"\s*\.\s*", np.nan), (r"\s*(\.)\s*", r"\1\1\1")]
 1642:     )
 1643:     @pytest.mark.parametrize("compile_regex", [True, False])
 1644:     @pytest.mark.parametrize("regex_kwarg", [True, False])
 1645:     @pytest.mark.parametrize("inplace", [True, False])
 1646:     def test_regex_replace_scalar(
 1647:         self, data, to_replace, value, compile_regex, regex_kwarg, inplace
 1648:     ):
 1649:         df = DataFrame(data)
 1650:         expected = df.copy()
 1651: 
 1652:         if compile_regex:
 1653:             to_replace = re.compile(to_replace)
 1654: 
 1655:         if regex_kwarg:
 1656:             regex = to_replace
 1657:             to_replace = None
 1658:         else:
 1659:             regex = True
 1660: 
 1661:         result = df.replace(to_replace, value, inplace=inplace, regex=regex)
 1662: 
 1663:         if inplace:
 1664:             assert result is None
 1665:             result = df
 1666: 
 1667:         if value is np.nan:
 1668:             expected_replace_val = np.nan
 1669:         else:
 1670:             expected_replace_val = "..."
 1671: 
 1672:         expected.loc[expected["a"] == ".", "a"] = expected_replace_val
 1673:         tm.assert_frame_equal(result, expected)
 1674: 
 1675:     @pytest.mark.xfail(
 1676:         using_pyarrow_string_dtype(), reason="can't set float into string"
 1677:     )
 1678:     @pytest.mark.parametrize("regex", [False, True])
 1679:     def test_replace_regex_dtype_frame(self, regex):
 1680:         # GH-48644
 1681:         df1 = DataFrame({"A": ["0"], "B": ["0"]})
 1682:         expected_df1 = DataFrame({"A": [1], "B": [1]})
 1683:         msg = "Downcasting behavior in `replace`"
 1684:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1685:             result_df1 = df1.replace(to_replace="0", value=1, regex=regex)
 1686:         tm.assert_frame_equal(result_df1, expected_df1)
 1687: 
 1688:         df2 = DataFrame({"A": ["0"], "B": ["1"]})
 1689:         expected_df2 = DataFrame({"A": [1], "B": ["1"]})
 1690:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1691:             result_df2 = df2.replace(to_replace="0", value=1, regex=regex)
 1692:         tm.assert_frame_equal(result_df2, expected_df2)
 1693: 
 1694:     def test_replace_with_value_also_being_replaced(self):
 1695:         # GH46306
 1696:         df = DataFrame({"A": [0, 1, 2], "B": [1, 0, 2]})
 1697:         result = df.replace({0: 1, 1: np.nan})
 1698:         expected = DataFrame({"A": [1, np.nan, 2], "B": [np.nan, 1, 2]})
 1699:         tm.assert_frame_equal(result, expected)
 1700: 
 1701:     def test_replace_categorical_no_replacement(self):
 1702:         # GH#46672
 1703:         df = DataFrame(
 1704:             {
 1705:                 "a": ["one", "two", None, "three"],
 1706:                 "b": ["one", None, "two", "three"],
 1707:             },
 1708:             dtype="category",
 1709:         )
 1710:         expected = df.copy()
 1711: 
 1712:         result = df.replace(to_replace=[".", "def"], value=["_", None])
 1713:         tm.assert_frame_equal(result, expected)
 1714: 
 1715:     def test_replace_object_splitting(self, using_infer_string):
 1716:         # GH#53977
 1717:         df = DataFrame({"a": ["a"], "b": "b"})
 1718:         if using_infer_string:
 1719:             assert len(df._mgr.blocks) == 2
 1720:         else:
 1721:             assert len(df._mgr.blocks) == 1
 1722:         df.replace(to_replace=r"^\s*$", value="", inplace=True, regex=True)
 1723:         if using_infer_string:
 1724:             assert len(df._mgr.blocks) == 2
 1725:         else:
 1726:             assert len(df._mgr.blocks) == 1
