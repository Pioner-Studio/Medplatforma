    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.core.dtypes.cast import find_common_type
    7: from pandas.core.dtypes.common import is_dtype_equal
    8: 
    9: import pandas as pd
   10: from pandas import (
   11:     DataFrame,
   12:     Index,
   13:     MultiIndex,
   14:     Series,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: class TestDataFrameCombineFirst:
   20:     def test_combine_first_mixed(self):
   21:         a = Series(["a", "b"], index=range(2))
   22:         b = Series(range(2), index=range(2))
   23:         f = DataFrame({"A": a, "B": b})
   24: 
   25:         a = Series(["a", "b"], index=range(5, 7))
   26:         b = Series(range(2), index=range(5, 7))
   27:         g = DataFrame({"A": a, "B": b})
   28: 
   29:         exp = DataFrame({"A": list("abab"), "B": [0, 1, 0, 1]}, index=[0, 1, 5, 6])
   30:         combined = f.combine_first(g)
   31:         tm.assert_frame_equal(combined, exp)
   32: 
   33:     def test_combine_first(self, float_frame, using_infer_string):
   34:         # disjoint
   35:         head, tail = float_frame[:5], float_frame[5:]
   36: 
   37:         combined = head.combine_first(tail)
   38:         reordered_frame = float_frame.reindex(combined.index)
   39:         tm.assert_frame_equal(combined, reordered_frame)
   40:         tm.assert_index_equal(combined.columns, float_frame.columns)
   41:         tm.assert_series_equal(combined["A"], reordered_frame["A"])
   42: 
   43:         # same index
   44:         fcopy = float_frame.copy()
   45:         fcopy["A"] = 1
   46:         del fcopy["C"]
   47: 
   48:         fcopy2 = float_frame.copy()
   49:         fcopy2["B"] = 0
   50:         del fcopy2["D"]
   51: 
   52:         combined = fcopy.combine_first(fcopy2)
   53: 
   54:         assert (combined["A"] == 1).all()
   55:         tm.assert_series_equal(combined["B"], fcopy["B"])
   56:         tm.assert_series_equal(combined["C"], fcopy2["C"])
   57:         tm.assert_series_equal(combined["D"], fcopy["D"])
   58: 
   59:         # overlap
   60:         head, tail = reordered_frame[:10].copy(), reordered_frame
   61:         head["A"] = 1
   62: 
   63:         combined = head.combine_first(tail)
   64:         assert (combined["A"][:10] == 1).all()
   65: 
   66:         # reverse overlap
   67:         tail.iloc[:10, tail.columns.get_loc("A")] = 0
   68:         combined = tail.combine_first(head)
   69:         assert (combined["A"][:10] == 0).all()
   70: 
   71:         # no overlap
   72:         f = float_frame[:10]
   73:         g = float_frame[10:]
   74:         combined = f.combine_first(g)
   75:         tm.assert_series_equal(combined["A"].reindex(f.index), f["A"])
   76:         tm.assert_series_equal(combined["A"].reindex(g.index), g["A"])
   77: 
   78:         # corner cases
   79:         warning = FutureWarning if using_infer_string else None
   80:         with tm.assert_produces_warning(warning, match="empty entries"):
   81:             comb = float_frame.combine_first(DataFrame())
   82:         tm.assert_frame_equal(comb, float_frame)
   83: 
   84:         comb = DataFrame().combine_first(float_frame)
   85:         tm.assert_frame_equal(comb, float_frame.sort_index())
   86: 
   87:         comb = float_frame.combine_first(DataFrame(index=["faz", "boo"]))
   88:         assert "faz" in comb.index
   89: 
   90:         # #2525
   91:         df = DataFrame({"a": [1]}, index=[datetime(2012, 1, 1)])
   92:         df2 = DataFrame(columns=["b"])
   93:         result = df.combine_first(df2)
   94:         assert "b" in result
   95: 
   96:     def test_combine_first_mixed_bug(self):
   97:         idx = Index(["a", "b", "c", "e"])
   98:         ser1 = Series([5.0, -9.0, 4.0, 100.0], index=idx)
   99:         ser2 = Series(["a", "b", "c", "e"], index=idx)
  100:         ser3 = Series([12, 4, 5, 97], index=idx)
  101: 
  102:         frame1 = DataFrame({"col0": ser1, "col2": ser2, "col3": ser3})
  103: 
  104:         idx = Index(["a", "b", "c", "f"])
  105:         ser1 = Series([5.0, -9.0, 4.0, 100.0], index=idx)
  106:         ser2 = Series(["a", "b", "c", "f"], index=idx)
  107:         ser3 = Series([12, 4, 5, 97], index=idx)
  108: 
  109:         frame2 = DataFrame({"col1": ser1, "col2": ser2, "col5": ser3})
  110: 
  111:         combined = frame1.combine_first(frame2)
  112:         assert len(combined.columns) == 5
  113: 
  114:     def test_combine_first_same_as_in_update(self):
  115:         # gh 3016 (same as in update)
  116:         df = DataFrame(
  117:             [[1.0, 2.0, False, True], [4.0, 5.0, True, False]],
  118:             columns=["A", "B", "bool1", "bool2"],
  119:         )
  120: 
  121:         other = DataFrame([[45, 45]], index=[0], columns=["A", "B"])
  122:         result = df.combine_first(other)
  123:         tm.assert_frame_equal(result, df)
  124: 
  125:         df.loc[0, "A"] = np.nan
  126:         result = df.combine_first(other)
  127:         df.loc[0, "A"] = 45
  128:         tm.assert_frame_equal(result, df)
  129: 
  130:     def test_combine_first_doc_example(self):
  131:         # doc example
  132:         df1 = DataFrame(
  133:             {"A": [1.0, np.nan, 3.0, 5.0, np.nan], "B": [np.nan, 2.0, 3.0, np.nan, 6.0]}
  134:         )
  135: 
  136:         df2 = DataFrame(
  137:             {
  138:                 "A": [5.0, 2.0, 4.0, np.nan, 3.0, 7.0],
  139:                 "B": [np.nan, np.nan, 3.0, 4.0, 6.0, 8.0],
  140:             }
  141:         )
  142: 
  143:         result = df1.combine_first(df2)
  144:         expected = DataFrame({"A": [1, 2, 3, 5, 3, 7.0], "B": [np.nan, 2, 3, 4, 6, 8]})
  145:         tm.assert_frame_equal(result, expected)
  146: 
  147:     def test_combine_first_return_obj_type_with_bools(self):
  148:         # GH3552
  149: 
  150:         df1 = DataFrame(
  151:             [[np.nan, 3.0, True], [-4.6, np.nan, True], [np.nan, 7.0, False]]
  152:         )
  153:         df2 = DataFrame([[-42.6, np.nan, True], [-5.0, 1.6, False]], index=[1, 2])
  154: 
  155:         expected = Series([True, True, False], name=2, dtype=bool)
  156: 
  157:         result_12 = df1.combine_first(df2)[2]
  158:         tm.assert_series_equal(result_12, expected)
  159: 
  160:         result_21 = df2.combine_first(df1)[2]
  161:         tm.assert_series_equal(result_21, expected)
  162: 
  163:     @pytest.mark.parametrize(
  164:         "data1, data2, data_expected",
  165:         (
  166:             (
  167:                 [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)],
  168:                 [pd.NaT, pd.NaT, pd.NaT],
  169:                 [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)],
  170:             ),
  171:             (
  172:                 [pd.NaT, pd.NaT, pd.NaT],
  173:                 [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)],
  174:                 [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)],
  175:             ),
  176:             (
  177:                 [datetime(2000, 1, 2), pd.NaT, pd.NaT],
  178:                 [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)],
  179:                 [datetime(2000, 1, 2), datetime(2000, 1, 2), datetime(2000, 1, 3)],
  180:             ),
  181:             (
  182:                 [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)],
  183:                 [datetime(2000, 1, 2), pd.NaT, pd.NaT],
  184:                 [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)],
  185:             ),
  186:         ),
  187:     )
  188:     def test_combine_first_convert_datatime_correctly(
  189:         self, data1, data2, data_expected
  190:     ):
  191:         # GH 3593
  192: 
  193:         df1, df2 = DataFrame({"a": data1}), DataFrame({"a": data2})
  194:         result = df1.combine_first(df2)
  195:         expected = DataFrame({"a": data_expected})
  196:         tm.assert_frame_equal(result, expected)
  197: 
  198:     def test_combine_first_align_nan(self):
  199:         # GH 7509 (not fixed)
  200:         dfa = DataFrame([[pd.Timestamp("2011-01-01"), 2]], columns=["a", "b"])
  201:         dfb = DataFrame([[4], [5]], columns=["b"])
  202:         assert dfa["a"].dtype == "datetime64[ns]"
  203:         assert dfa["b"].dtype == "int64"
  204: 
  205:         res = dfa.combine_first(dfb)
  206:         exp = DataFrame(
  207:             {"a": [pd.Timestamp("2011-01-01"), pd.NaT], "b": [2, 5]},
  208:             columns=["a", "b"],
  209:         )
  210:         tm.assert_frame_equal(res, exp)
  211:         assert res["a"].dtype == "datetime64[ns]"
  212:         # TODO: this must be int64
  213:         assert res["b"].dtype == "int64"
  214: 
  215:         res = dfa.iloc[:0].combine_first(dfb)
  216:         exp = DataFrame({"a": [np.nan, np.nan], "b": [4, 5]}, columns=["a", "b"])
  217:         tm.assert_frame_equal(res, exp)
  218:         # TODO: this must be datetime64
  219:         assert res["a"].dtype == "float64"
  220:         # TODO: this must be int64
  221:         assert res["b"].dtype == "int64"
  222: 
  223:     def test_combine_first_timezone(self, unit):
  224:         # see gh-7630
  225:         data1 = pd.to_datetime("20100101 01:01").tz_localize("UTC").as_unit(unit)
  226:         df1 = DataFrame(
  227:             columns=["UTCdatetime", "abc"],
  228:             data=data1,
  229:             index=pd.date_range("20140627", periods=1),
  230:         )
  231:         data2 = pd.to_datetime("20121212 12:12").tz_localize("UTC").as_unit(unit)
  232:         df2 = DataFrame(
  233:             columns=["UTCdatetime", "xyz"],
  234:             data=data2,
  235:             index=pd.date_range("20140628", periods=1),
  236:         )
  237:         res = df2[["UTCdatetime"]].combine_first(df1)
  238:         exp = DataFrame(
  239:             {
  240:                 "UTCdatetime": [
  241:                     pd.Timestamp("2010-01-01 01:01", tz="UTC"),
  242:                     pd.Timestamp("2012-12-12 12:12", tz="UTC"),
  243:                 ],
  244:                 "abc": [pd.Timestamp("2010-01-01 01:01:00", tz="UTC"), pd.NaT],
  245:             },
  246:             columns=["UTCdatetime", "abc"],
  247:             index=pd.date_range("20140627", periods=2, freq="D"),
  248:             dtype=f"datetime64[{unit}, UTC]",
  249:         )
  250:         assert res["UTCdatetime"].dtype == f"datetime64[{unit}, UTC]"
  251:         assert res["abc"].dtype == f"datetime64[{unit}, UTC]"
  252: 
  253:         tm.assert_frame_equal(res, exp)
  254: 
  255:     def test_combine_first_timezone2(self, unit):
  256:         # see gh-10567
  257:         dts1 = pd.date_range("2015-01-01", "2015-01-05", tz="UTC", unit=unit)
  258:         df1 = DataFrame({"DATE": dts1})
  259:         dts2 = pd.date_range("2015-01-03", "2015-01-05", tz="UTC", unit=unit)
  260:         df2 = DataFrame({"DATE": dts2})
  261: 
  262:         res = df1.combine_first(df2)
  263:         tm.assert_frame_equal(res, df1)
  264:         assert res["DATE"].dtype == f"datetime64[{unit}, UTC]"
  265: 
  266:     def test_combine_first_timezone3(self, unit):
  267:         dts1 = pd.DatetimeIndex(
  268:             ["2011-01-01", "NaT", "2011-01-03", "2011-01-04"], tz="US/Eastern"
  269:         ).as_unit(unit)
  270:         df1 = DataFrame({"DATE": dts1}, index=[1, 3, 5, 7])
  271:         dts2 = pd.DatetimeIndex(
  272:             ["2012-01-01", "2012-01-02", "2012-01-03"], tz="US/Eastern"
  273:         ).as_unit(unit)
  274:         df2 = DataFrame({"DATE": dts2}, index=[2, 4, 5])
  275: 
  276:         res = df1.combine_first(df2)
  277:         exp_dts = pd.DatetimeIndex(
  278:             [
  279:                 "2011-01-01",
  280:                 "2012-01-01",
  281:                 "NaT",
  282:                 "2012-01-02",
  283:                 "2011-01-03",
  284:                 "2011-01-04",
  285:             ],
  286:             tz="US/Eastern",
  287:         ).as_unit(unit)
  288:         exp = DataFrame({"DATE": exp_dts}, index=[1, 2, 3, 4, 5, 7])
  289:         tm.assert_frame_equal(res, exp)
  290: 
  291:     # FIXME: parametrizing over unit breaks on non-nano
  292:     def test_combine_first_timezone4(self):
  293:         # different tz
  294:         dts1 = pd.date_range("2015-01-01", "2015-01-05", tz="US/Eastern")
  295:         df1 = DataFrame({"DATE": dts1})
  296:         dts2 = pd.date_range("2015-01-03", "2015-01-05")
  297:         df2 = DataFrame({"DATE": dts2})
  298: 
  299:         # if df1 doesn't have NaN, keep its dtype
  300:         res = df1.combine_first(df2)
  301:         tm.assert_frame_equal(res, df1)
  302:         assert res["DATE"].dtype == "datetime64[ns, US/Eastern]"
  303: 
  304:     def test_combine_first_timezone5(self, unit):
  305:         dts1 = pd.date_range("2015-01-01", "2015-01-02", tz="US/Eastern", unit=unit)
  306:         df1 = DataFrame({"DATE": dts1})
  307:         dts2 = pd.date_range("2015-01-01", "2015-01-03", unit=unit)
  308:         df2 = DataFrame({"DATE": dts2})
  309: 
  310:         res = df1.combine_first(df2)
  311:         exp_dts = [
  312:             pd.Timestamp("2015-01-01", tz="US/Eastern"),
  313:             pd.Timestamp("2015-01-02", tz="US/Eastern"),
  314:             pd.Timestamp("2015-01-03"),
  315:         ]
  316:         exp = DataFrame({"DATE": exp_dts})
  317:         tm.assert_frame_equal(res, exp)
  318:         assert res["DATE"].dtype == "object"
  319: 
  320:     def test_combine_first_timedelta(self):
  321:         data1 = pd.TimedeltaIndex(["1 day", "NaT", "3 day", "4day"])
  322:         df1 = DataFrame({"TD": data1}, index=[1, 3, 5, 7])
  323:         data2 = pd.TimedeltaIndex(["10 day", "11 day", "12 day"])
  324:         df2 = DataFrame({"TD": data2}, index=[2, 4, 5])
  325: 
  326:         res = df1.combine_first(df2)
  327:         exp_dts = pd.TimedeltaIndex(
  328:             ["1 day", "10 day", "NaT", "11 day", "3 day", "4 day"]
  329:         )
  330:         exp = DataFrame({"TD": exp_dts}, index=[1, 2, 3, 4, 5, 7])
  331:         tm.assert_frame_equal(res, exp)
  332:         assert res["TD"].dtype == "timedelta64[ns]"
  333: 
  334:     def test_combine_first_period(self):
  335:         data1 = pd.PeriodIndex(["2011-01", "NaT", "2011-03", "2011-04"], freq="M")
  336:         df1 = DataFrame({"P": data1}, index=[1, 3, 5, 7])
  337:         data2 = pd.PeriodIndex(["2012-01-01", "2012-02", "2012-03"], freq="M")
  338:         df2 = DataFrame({"P": data2}, index=[2, 4, 5])
  339: 
  340:         res = df1.combine_first(df2)
  341:         exp_dts = pd.PeriodIndex(
  342:             ["2011-01", "2012-01", "NaT", "2012-02", "2011-03", "2011-04"], freq="M"
  343:         )
  344:         exp = DataFrame({"P": exp_dts}, index=[1, 2, 3, 4, 5, 7])
  345:         tm.assert_frame_equal(res, exp)
  346:         assert res["P"].dtype == data1.dtype
  347: 
  348:         # different freq
  349:         dts2 = pd.PeriodIndex(["2012-01-01", "2012-01-02", "2012-01-03"], freq="D")
  350:         df2 = DataFrame({"P": dts2}, index=[2, 4, 5])
  351: 
  352:         res = df1.combine_first(df2)
  353:         exp_dts = [
  354:             pd.Period("2011-01", freq="M"),
  355:             pd.Period("2012-01-01", freq="D"),
  356:             pd.NaT,
  357:             pd.Period("2012-01-02", freq="D"),
  358:             pd.Period("2011-03", freq="M"),
  359:             pd.Period("2011-04", freq="M"),
  360:         ]
  361:         exp = DataFrame({"P": exp_dts}, index=[1, 2, 3, 4, 5, 7])
  362:         tm.assert_frame_equal(res, exp)
  363:         assert res["P"].dtype == "object"
  364: 
  365:     def test_combine_first_int(self):
  366:         # GH14687 - integer series that do no align exactly
  367: 
  368:         df1 = DataFrame({"a": [0, 1, 3, 5]}, dtype="int64")
  369:         df2 = DataFrame({"a": [1, 4]}, dtype="int64")
  370: 
  371:         result_12 = df1.combine_first(df2)
  372:         expected_12 = DataFrame({"a": [0, 1, 3, 5]})
  373:         tm.assert_frame_equal(result_12, expected_12)
  374: 
  375:         result_21 = df2.combine_first(df1)
  376:         expected_21 = DataFrame({"a": [1, 4, 3, 5]})
  377:         tm.assert_frame_equal(result_21, expected_21)
  378: 
  379:     @pytest.mark.parametrize("val", [1, 1.0])
  380:     def test_combine_first_with_asymmetric_other(self, val):
  381:         # see gh-20699
  382:         df1 = DataFrame({"isNum": [val]})
  383:         df2 = DataFrame({"isBool": [True]})
  384: 
  385:         res = df1.combine_first(df2)
  386:         exp = DataFrame({"isBool": [True], "isNum": [val]})
  387: 
  388:         tm.assert_frame_equal(res, exp)
  389: 
  390:     def test_combine_first_string_dtype_only_na(self, nullable_string_dtype):
  391:         # GH: 37519
  392:         df = DataFrame(
  393:             {"a": ["962", "85"], "b": [pd.NA] * 2}, dtype=nullable_string_dtype
  394:         )
  395:         df2 = DataFrame({"a": ["85"], "b": [pd.NA]}, dtype=nullable_string_dtype)
  396:         df.set_index(["a", "b"], inplace=True)
  397:         df2.set_index(["a", "b"], inplace=True)
  398:         result = df.combine_first(df2)
  399:         expected = DataFrame(
  400:             {"a": ["962", "85"], "b": [pd.NA] * 2}, dtype=nullable_string_dtype
  401:         ).set_index(["a", "b"])
  402:         tm.assert_frame_equal(result, expected)
  403: 
  404: 
  405: @pytest.mark.parametrize(
  406:     "scalar1, scalar2",
  407:     [
  408:         (datetime(2020, 1, 1), datetime(2020, 1, 2)),
  409:         (pd.Period("2020-01-01", "D"), pd.Period("2020-01-02", "D")),
  410:         (pd.Timedelta("89 days"), pd.Timedelta("60 min")),
  411:         (pd.Interval(left=0, right=1), pd.Interval(left=2, right=3, closed="left")),
  412:     ],
  413: )
  414: def test_combine_first_timestamp_bug(scalar1, scalar2, nulls_fixture):
  415:     # GH28481
  416:     na_value = nulls_fixture
  417: 
  418:     frame = DataFrame([[na_value, na_value]], columns=["a", "b"])
  419:     other = DataFrame([[scalar1, scalar2]], columns=["b", "c"])
  420: 
  421:     common_dtype = find_common_type([frame.dtypes["b"], other.dtypes["b"]])
  422: 
  423:     if is_dtype_equal(common_dtype, "object") or frame.dtypes["b"] == other.dtypes["b"]:
  424:         val = scalar1
  425:     else:
  426:         val = na_value
  427: 
  428:     result = frame.combine_first(other)
  429: 
  430:     expected = DataFrame([[na_value, val, scalar2]], columns=["a", "b", "c"])
  431: 
  432:     expected["b"] = expected["b"].astype(common_dtype)
  433: 
  434:     tm.assert_frame_equal(result, expected)
  435: 
  436: 
  437: def test_combine_first_timestamp_bug_NaT():
  438:     # GH28481
  439:     frame = DataFrame([[pd.NaT, pd.NaT]], columns=["a", "b"])
  440:     other = DataFrame(
  441:         [[datetime(2020, 1, 1), datetime(2020, 1, 2)]], columns=["b", "c"]
  442:     )
  443: 
  444:     result = frame.combine_first(other)
  445:     expected = DataFrame(
  446:         [[pd.NaT, datetime(2020, 1, 1), datetime(2020, 1, 2)]], columns=["a", "b", "c"]
  447:     )
  448: 
  449:     tm.assert_frame_equal(result, expected)
  450: 
  451: 
  452: def test_combine_first_with_nan_multiindex():
  453:     # gh-36562
  454: 
  455:     mi1 = MultiIndex.from_arrays(
  456:         [["b", "b", "c", "a", "b", np.nan], [1, 2, 3, 4, 5, 6]], names=["a", "b"]
  457:     )
  458:     df = DataFrame({"c": [1, 1, 1, 1, 1, 1]}, index=mi1)
  459:     mi2 = MultiIndex.from_arrays(
  460:         [["a", "b", "c", "a", "b", "d"], [1, 1, 1, 1, 1, 1]], names=["a", "b"]
  461:     )
  462:     s = Series([1, 2, 3, 4, 5, 6], index=mi2)
  463:     res = df.combine_first(DataFrame({"d": s}))
  464:     mi_expected = MultiIndex.from_arrays(
  465:         [
  466:             ["a", "a", "a", "b", "b", "b", "b", "c", "c", "d", np.nan],
  467:             [1, 1, 4, 1, 1, 2, 5, 1, 3, 1, 6],
  468:         ],
  469:         names=["a", "b"],
  470:     )
  471:     expected = DataFrame(
  472:         {
  473:             "c": [np.nan, np.nan, 1, 1, 1, 1, 1, np.nan, 1, np.nan, 1],
  474:             "d": [1.0, 4.0, np.nan, 2.0, 5.0, np.nan, np.nan, 3.0, np.nan, 6.0, np.nan],
  475:         },
  476:         index=mi_expected,
  477:     )
  478:     tm.assert_frame_equal(res, expected)
  479: 
  480: 
  481: def test_combine_preserve_dtypes():
  482:     # GH7509
  483:     a_column = Series(["a", "b"], index=range(2))
  484:     b_column = Series(range(2), index=range(2))
  485:     df1 = DataFrame({"A": a_column, "B": b_column})
  486: 
  487:     c_column = Series(["a", "b"], index=range(5, 7))
  488:     b_column = Series(range(-1, 1), index=range(5, 7))
  489:     df2 = DataFrame({"B": b_column, "C": c_column})
  490: 
  491:     expected = DataFrame(
  492:         {
  493:             "A": ["a", "b", np.nan, np.nan],
  494:             "B": [0, 1, -1, 0],
  495:             "C": [np.nan, np.nan, "a", "b"],
  496:         },
  497:         index=[0, 1, 5, 6],
  498:     )
  499:     combined = df1.combine_first(df2)
  500:     tm.assert_frame_equal(combined, expected)
  501: 
  502: 
  503: def test_combine_first_duplicates_rows_for_nan_index_values():
  504:     # GH39881
  505:     df1 = DataFrame(
  506:         {"x": [9, 10, 11]},
  507:         index=MultiIndex.from_arrays([[1, 2, 3], [np.nan, 5, 6]], names=["a", "b"]),
  508:     )
  509: 
  510:     df2 = DataFrame(
  511:         {"y": [12, 13, 14]},
  512:         index=MultiIndex.from_arrays([[1, 2, 4], [np.nan, 5, 7]], names=["a", "b"]),
  513:     )
  514: 
  515:     expected = DataFrame(
  516:         {
  517:             "x": [9.0, 10.0, 11.0, np.nan],
  518:             "y": [12.0, 13.0, np.nan, 14.0],
  519:         },
  520:         index=MultiIndex.from_arrays(
  521:             [[1, 2, 3, 4], [np.nan, 5, 6, 7]], names=["a", "b"]
  522:         ),
  523:     )
  524:     combined = df1.combine_first(df2)
  525:     tm.assert_frame_equal(combined, expected)
  526: 
  527: 
  528: def test_combine_first_int64_not_cast_to_float64():
  529:     # GH 28613
  530:     df_1 = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
  531:     df_2 = DataFrame({"A": [1, 20, 30], "B": [40, 50, 60], "C": [12, 34, 65]})
  532:     result = df_1.combine_first(df_2)
  533:     expected = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6], "C": [12, 34, 65]})
  534:     tm.assert_frame_equal(result, expected)
  535: 
  536: 
  537: def test_midx_losing_dtype():
  538:     # GH#49830
  539:     midx = MultiIndex.from_arrays([[0, 0], [np.nan, np.nan]])
  540:     midx2 = MultiIndex.from_arrays([[1, 1], [np.nan, np.nan]])
  541:     df1 = DataFrame({"a": [None, 4]}, index=midx)
  542:     df2 = DataFrame({"a": [3, 3]}, index=midx2)
  543:     result = df1.combine_first(df2)
  544:     expected_midx = MultiIndex.from_arrays(
  545:         [[0, 0, 1, 1], [np.nan, np.nan, np.nan, np.nan]]
  546:     )
  547:     expected = DataFrame({"a": [np.nan, 4, 3, 3]}, index=expected_midx)
  548:     tm.assert_frame_equal(result, expected)
  549: 
  550: 
  551: def test_combine_first_empty_columns():
  552:     left = DataFrame(columns=["a", "b"])
  553:     right = DataFrame(columns=["a", "c"])
  554:     result = left.combine_first(right)
  555:     expected = DataFrame(columns=["a", "b", "c"])
  556:     tm.assert_frame_equal(result, expected)
