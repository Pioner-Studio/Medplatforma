    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.errors import SettingWithCopyError
    7: 
    8: from pandas import (
    9:     DataFrame,
   10:     Index,
   11:     IndexSlice,
   12:     MultiIndex,
   13:     Series,
   14:     concat,
   15: )
   16: import pandas._testing as tm
   17: 
   18: from pandas.tseries.offsets import BDay
   19: 
   20: 
   21: @pytest.fixture
   22: def four_level_index_dataframe():
   23:     arr = np.array(
   24:         [
   25:             [-0.5109, -2.3358, -0.4645, 0.05076, 0.364],
   26:             [0.4473, 1.4152, 0.2834, 1.00661, 0.1744],
   27:             [-0.6662, -0.5243, -0.358, 0.89145, 2.5838],
   28:         ]
   29:     )
   30:     index = MultiIndex(
   31:         levels=[["a", "x"], ["b", "q"], [10.0032, 20.0, 30.0], [3, 4, 5]],
   32:         codes=[[0, 0, 1], [0, 1, 1], [0, 1, 2], [2, 1, 0]],
   33:         names=["one", "two", "three", "four"],
   34:     )
   35:     return DataFrame(arr, index=index, columns=list("ABCDE"))
   36: 
   37: 
   38: class TestXS:
   39:     def test_xs(
   40:         self, float_frame, datetime_frame, using_copy_on_write, warn_copy_on_write
   41:     ):
   42:         float_frame_orig = float_frame.copy()
   43:         idx = float_frame.index[5]
   44:         xs = float_frame.xs(idx)
   45:         for item, value in xs.items():
   46:             if np.isnan(value):
   47:                 assert np.isnan(float_frame[item][idx])
   48:             else:
   49:                 assert value == float_frame[item][idx]
   50: 
   51:         # mixed-type xs
   52:         test_data = {"A": {"1": 1, "2": 2}, "B": {"1": "1", "2": "2", "3": "3"}}
   53:         frame = DataFrame(test_data)
   54:         xs = frame.xs("1")
   55:         assert xs.dtype == np.object_
   56:         assert xs["A"] == 1
   57:         assert xs["B"] == "1"
   58: 
   59:         with pytest.raises(
   60:             KeyError, match=re.escape("Timestamp('1999-12-31 00:00:00')")
   61:         ):
   62:             datetime_frame.xs(datetime_frame.index[0] - BDay())
   63: 
   64:         # xs get column
   65:         series = float_frame.xs("A", axis=1)
   66:         expected = float_frame["A"]
   67:         tm.assert_series_equal(series, expected)
   68: 
   69:         # view is returned if possible
   70:         series = float_frame.xs("A", axis=1)
   71:         with tm.assert_cow_warning(warn_copy_on_write):
   72:             series[:] = 5
   73:         if using_copy_on_write:
   74:             # but with CoW the view shouldn't propagate mutations
   75:             tm.assert_series_equal(float_frame["A"], float_frame_orig["A"])
   76:             assert not (expected == 5).all()
   77:         else:
   78:             assert (expected == 5).all()
   79: 
   80:     def test_xs_corner(self):
   81:         # pathological mixed-type reordering case
   82:         df = DataFrame(index=[0])
   83:         df["A"] = 1.0
   84:         df["B"] = "foo"
   85:         df["C"] = 2.0
   86:         df["D"] = "bar"
   87:         df["E"] = 3.0
   88: 
   89:         xs = df.xs(0)
   90:         exp = Series([1.0, "foo", 2.0, "bar", 3.0], index=list("ABCDE"), name=0)
   91:         tm.assert_series_equal(xs, exp)
   92: 
   93:         # no columns but Index(dtype=object)
   94:         df = DataFrame(index=["a", "b", "c"])
   95:         result = df.xs("a")
   96:         expected = Series([], name="a", dtype=np.float64)
   97:         tm.assert_series_equal(result, expected)
   98: 
   99:     def test_xs_duplicates(self):
  100:         df = DataFrame(
  101:             np.random.default_rng(2).standard_normal((5, 2)),
  102:             index=["b", "b", "c", "b", "a"],
  103:         )
  104: 
  105:         cross = df.xs("c")
  106:         exp = df.iloc[2]
  107:         tm.assert_series_equal(cross, exp)
  108: 
  109:     def test_xs_keep_level(self):
  110:         df = DataFrame(
  111:             {
  112:                 "day": {0: "sat", 1: "sun"},
  113:                 "flavour": {0: "strawberry", 1: "strawberry"},
  114:                 "sales": {0: 10, 1: 12},
  115:                 "year": {0: 2008, 1: 2008},
  116:             }
  117:         ).set_index(["year", "flavour", "day"])
  118:         result = df.xs("sat", level="day", drop_level=False)
  119:         expected = df[:1]
  120:         tm.assert_frame_equal(result, expected)
  121: 
  122:         result = df.xs((2008, "sat"), level=["year", "day"], drop_level=False)
  123:         tm.assert_frame_equal(result, expected)
  124: 
  125:     def test_xs_view(
  126:         self, using_array_manager, using_copy_on_write, warn_copy_on_write
  127:     ):
  128:         # in 0.14 this will return a view if possible a copy otherwise, but
  129:         # this is numpy dependent
  130: 
  131:         dm = DataFrame(np.arange(20.0).reshape(4, 5), index=range(4), columns=range(5))
  132:         df_orig = dm.copy()
  133: 
  134:         if using_copy_on_write:
  135:             with tm.raises_chained_assignment_error():
  136:                 dm.xs(2)[:] = 20
  137:             tm.assert_frame_equal(dm, df_orig)
  138:         elif using_array_manager:
  139:             # INFO(ArrayManager) with ArrayManager getting a row as a view is
  140:             # not possible
  141:             msg = r"\nA value is trying to be set on a copy of a slice from a DataFrame"
  142:             with pytest.raises(SettingWithCopyError, match=msg):
  143:                 dm.xs(2)[:] = 20
  144:             assert not (dm.xs(2) == 20).any()
  145:         else:
  146:             with tm.raises_chained_assignment_error():
  147:                 dm.xs(2)[:] = 20
  148:             assert (dm.xs(2) == 20).all()
  149: 
  150: 
  151: class TestXSWithMultiIndex:
  152:     def test_xs_doc_example(self):
  153:         # TODO: more descriptive name
  154:         # based on example in advanced.rst
  155:         arrays = [
  156:             ["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"],
  157:             ["one", "two", "one", "two", "one", "two", "one", "two"],
  158:         ]
  159:         tuples = list(zip(*arrays))
  160: 
  161:         index = MultiIndex.from_tuples(tuples, names=["first", "second"])
  162:         df = DataFrame(
  163:             np.random.default_rng(2).standard_normal((3, 8)),
  164:             index=["A", "B", "C"],
  165:             columns=index,
  166:         )
  167: 
  168:         result = df.xs(("one", "bar"), level=("second", "first"), axis=1)
  169: 
  170:         expected = df.iloc[:, [0]]
  171:         tm.assert_frame_equal(result, expected)
  172: 
  173:     def test_xs_integer_key(self):
  174:         # see GH#2107
  175:         dates = range(20111201, 20111205)
  176:         ids = list("abcde")
  177:         index = MultiIndex.from_product([dates, ids], names=["date", "secid"])
  178:         df = DataFrame(
  179:             np.random.default_rng(2).standard_normal((len(index), 3)),
  180:             index,
  181:             ["X", "Y", "Z"],
  182:         )
  183: 
  184:         result = df.xs(20111201, level="date")
  185:         expected = df.loc[20111201, :]
  186:         tm.assert_frame_equal(result, expected)
  187: 
  188:     def test_xs_level(self, multiindex_dataframe_random_data):
  189:         df = multiindex_dataframe_random_data
  190:         result = df.xs("two", level="second")
  191:         expected = df[df.index.get_level_values(1) == "two"]
  192:         expected.index = Index(["foo", "bar", "baz", "qux"], name="first")
  193:         tm.assert_frame_equal(result, expected)
  194: 
  195:     def test_xs_level_eq_2(self):
  196:         arr = np.random.default_rng(2).standard_normal((3, 5))
  197:         index = MultiIndex(
  198:             levels=[["a", "p", "x"], ["b", "q", "y"], ["c", "r", "z"]],
  199:             codes=[[2, 0, 1], [2, 0, 1], [2, 0, 1]],
  200:         )
  201:         df = DataFrame(arr, index=index)
  202:         expected = DataFrame(arr[1:2], index=[["a"], ["b"]])
  203:         result = df.xs("c", level=2)
  204:         tm.assert_frame_equal(result, expected)
  205: 
  206:     def test_xs_setting_with_copy_error(
  207:         self,
  208:         multiindex_dataframe_random_data,
  209:         using_copy_on_write,
  210:         warn_copy_on_write,
  211:     ):
  212:         # this is a copy in 0.14
  213:         df = multiindex_dataframe_random_data
  214:         df_orig = df.copy()
  215:         result = df.xs("two", level="second")
  216: 
  217:         if using_copy_on_write or warn_copy_on_write:
  218:             result[:] = 10
  219:         else:
  220:             # setting this will give a SettingWithCopyError
  221:             # as we are trying to write a view
  222:             msg = "A value is trying to be set on a copy of a slice from a DataFrame"
  223:             with pytest.raises(SettingWithCopyError, match=msg):
  224:                 result[:] = 10
  225:         tm.assert_frame_equal(df, df_orig)
  226: 
  227:     def test_xs_setting_with_copy_error_multiple(
  228:         self, four_level_index_dataframe, using_copy_on_write, warn_copy_on_write
  229:     ):
  230:         # this is a copy in 0.14
  231:         df = four_level_index_dataframe
  232:         df_orig = df.copy()
  233:         result = df.xs(("a", 4), level=["one", "four"])
  234: 
  235:         if using_copy_on_write or warn_copy_on_write:
  236:             result[:] = 10
  237:         else:
  238:             # setting this will give a SettingWithCopyError
  239:             # as we are trying to write a view
  240:             msg = "A value is trying to be set on a copy of a slice from a DataFrame"
  241:             with pytest.raises(SettingWithCopyError, match=msg):
  242:                 result[:] = 10
  243:         tm.assert_frame_equal(df, df_orig)
  244: 
  245:     @pytest.mark.parametrize("key, level", [("one", "second"), (["one"], ["second"])])
  246:     def test_xs_with_duplicates(self, key, level, multiindex_dataframe_random_data):
  247:         # see GH#13719
  248:         frame = multiindex_dataframe_random_data
  249:         df = concat([frame] * 2)
  250:         assert df.index.is_unique is False
  251:         expected = concat([frame.xs("one", level="second")] * 2)
  252: 
  253:         if isinstance(key, list):
  254:             result = df.xs(tuple(key), level=level)
  255:         else:
  256:             result = df.xs(key, level=level)
  257:         tm.assert_frame_equal(result, expected)
  258: 
  259:     def test_xs_missing_values_in_index(self):
  260:         # see GH#6574
  261:         # missing values in returned index should be preserved
  262:         acc = [
  263:             ("a", "abcde", 1),
  264:             ("b", "bbcde", 2),
  265:             ("y", "yzcde", 25),
  266:             ("z", "xbcde", 24),
  267:             ("z", None, 26),
  268:             ("z", "zbcde", 25),
  269:             ("z", "ybcde", 26),
  270:         ]
  271:         df = DataFrame(acc, columns=["a1", "a2", "cnt"]).set_index(["a1", "a2"])
  272:         expected = DataFrame(
  273:             {"cnt": [24, 26, 25, 26]},
  274:             index=Index(["xbcde", np.nan, "zbcde", "ybcde"], name="a2"),
  275:         )
  276: 
  277:         result = df.xs("z", level="a1")
  278:         tm.assert_frame_equal(result, expected)
  279: 
  280:     @pytest.mark.parametrize(
  281:         "key, level, exp_arr, exp_index",
  282:         [
  283:             ("a", "lvl0", lambda x: x[:, 0:2], Index(["bar", "foo"], name="lvl1")),
  284:             ("foo", "lvl1", lambda x: x[:, 1:2], Index(["a"], name="lvl0")),
  285:         ],
  286:     )
  287:     def test_xs_named_levels_axis_eq_1(self, key, level, exp_arr, exp_index):
  288:         # see GH#2903
  289:         arr = np.random.default_rng(2).standard_normal((4, 4))
  290:         index = MultiIndex(
  291:             levels=[["a", "b"], ["bar", "foo", "hello", "world"]],
  292:             codes=[[0, 0, 1, 1], [0, 1, 2, 3]],
  293:             names=["lvl0", "lvl1"],
  294:         )
  295:         df = DataFrame(arr, columns=index)
  296:         result = df.xs(key, level=level, axis=1)
  297:         expected = DataFrame(exp_arr(arr), columns=exp_index)
  298:         tm.assert_frame_equal(result, expected)
  299: 
  300:     @pytest.mark.parametrize(
  301:         "indexer",
  302:         [
  303:             lambda df: df.xs(("a", 4), level=["one", "four"]),
  304:             lambda df: df.xs("a").xs(4, level="four"),
  305:         ],
  306:     )
  307:     def test_xs_level_multiple(self, indexer, four_level_index_dataframe):
  308:         df = four_level_index_dataframe
  309:         expected_values = [[0.4473, 1.4152, 0.2834, 1.00661, 0.1744]]
  310:         expected_index = MultiIndex(
  311:             levels=[["q"], [20.0]], codes=[[0], [0]], names=["two", "three"]
  312:         )
  313:         expected = DataFrame(
  314:             expected_values, index=expected_index, columns=list("ABCDE")
  315:         )
  316:         result = indexer(df)
  317:         tm.assert_frame_equal(result, expected)
  318: 
  319:     @pytest.mark.parametrize(
  320:         "indexer", [lambda df: df.xs("a", level=0), lambda df: df.xs("a")]
  321:     )
  322:     def test_xs_level0(self, indexer, four_level_index_dataframe):
  323:         df = four_level_index_dataframe
  324:         expected_values = [
  325:             [-0.5109, -2.3358, -0.4645, 0.05076, 0.364],
  326:             [0.4473, 1.4152, 0.2834, 1.00661, 0.1744],
  327:         ]
  328:         expected_index = MultiIndex(
  329:             levels=[["b", "q"], [10.0032, 20.0], [4, 5]],
  330:             codes=[[0, 1], [0, 1], [1, 0]],
  331:             names=["two", "three", "four"],
  332:         )
  333:         expected = DataFrame(
  334:             expected_values, index=expected_index, columns=list("ABCDE")
  335:         )
  336: 
  337:         result = indexer(df)
  338:         tm.assert_frame_equal(result, expected)
  339: 
  340:     def test_xs_values(self, multiindex_dataframe_random_data):
  341:         df = multiindex_dataframe_random_data
  342:         result = df.xs(("bar", "two")).values
  343:         expected = df.values[4]
  344:         tm.assert_almost_equal(result, expected)
  345: 
  346:     def test_xs_loc_equality(self, multiindex_dataframe_random_data):
  347:         df = multiindex_dataframe_random_data
  348:         result = df.xs(("bar", "two"))
  349:         expected = df.loc[("bar", "two")]
  350:         tm.assert_series_equal(result, expected)
  351: 
  352:     def test_xs_IndexSlice_argument_not_implemented(self, frame_or_series):
  353:         # GH#35301
  354: 
  355:         index = MultiIndex(
  356:             levels=[[("foo", "bar", 0), ("foo", "baz", 0), ("foo", "qux", 0)], [0, 1]],
  357:             codes=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]],
  358:         )
  359: 
  360:         obj = DataFrame(np.random.default_rng(2).standard_normal((6, 4)), index=index)
  361:         if frame_or_series is Series:
  362:             obj = obj[0]
  363: 
  364:         expected = obj.iloc[-2:].droplevel(0)
  365: 
  366:         result = obj.xs(IndexSlice[("foo", "qux", 0), :])
  367:         tm.assert_equal(result, expected)
  368: 
  369:         result = obj.loc[IndexSlice[("foo", "qux", 0), :]]
  370:         tm.assert_equal(result, expected)
  371: 
  372:     def test_xs_levels_raises(self, frame_or_series):
  373:         obj = DataFrame({"A": [1, 2, 3]})
  374:         if frame_or_series is Series:
  375:             obj = obj["A"]
  376: 
  377:         msg = "Index must be a MultiIndex"
  378:         with pytest.raises(TypeError, match=msg):
  379:             obj.xs(0, level="as")
  380: 
  381:     def test_xs_multiindex_droplevel_false(self):
  382:         # GH#19056
  383:         mi = MultiIndex.from_tuples(
  384:             [("a", "x"), ("a", "y"), ("b", "x")], names=["level1", "level2"]
  385:         )
  386:         df = DataFrame([[1, 2, 3]], columns=mi)
  387:         result = df.xs("a", axis=1, drop_level=False)
  388:         expected = DataFrame(
  389:             [[1, 2]],
  390:             columns=MultiIndex.from_tuples(
  391:                 [("a", "x"), ("a", "y")], names=["level1", "level2"]
  392:             ),
  393:         )
  394:         tm.assert_frame_equal(result, expected)
  395: 
  396:     def test_xs_droplevel_false(self):
  397:         # GH#19056
  398:         df = DataFrame([[1, 2, 3]], columns=Index(["a", "b", "c"]))
  399:         result = df.xs("a", axis=1, drop_level=False)
  400:         expected = DataFrame({"a": [1]})
  401:         tm.assert_frame_equal(result, expected)
  402: 
  403:     def test_xs_droplevel_false_view(
  404:         self, using_array_manager, using_copy_on_write, warn_copy_on_write
  405:     ):
  406:         # GH#37832
  407:         df = DataFrame([[1, 2, 3]], columns=Index(["a", "b", "c"]))
  408:         result = df.xs("a", axis=1, drop_level=False)
  409:         # check that result still views the same data as df
  410:         assert np.shares_memory(result.iloc[:, 0]._values, df.iloc[:, 0]._values)
  411: 
  412:         with tm.assert_cow_warning(warn_copy_on_write):
  413:             df.iloc[0, 0] = 2
  414:         if using_copy_on_write:
  415:             # with copy on write the subset is never modified
  416:             expected = DataFrame({"a": [1]})
  417:         else:
  418:             # modifying original df also modifies result when having a single block
  419:             expected = DataFrame({"a": [2]})
  420:         tm.assert_frame_equal(result, expected)
  421: 
  422:         # with mixed dataframe, modifying the parent doesn't modify result
  423:         # TODO the "split" path behaves differently here as with single block
  424:         df = DataFrame([[1, 2.5, "a"]], columns=Index(["a", "b", "c"]))
  425:         result = df.xs("a", axis=1, drop_level=False)
  426:         df.iloc[0, 0] = 2
  427:         if using_copy_on_write:
  428:             # with copy on write the subset is never modified
  429:             expected = DataFrame({"a": [1]})
  430:         elif using_array_manager:
  431:             # Here the behavior is consistent
  432:             expected = DataFrame({"a": [2]})
  433:         else:
  434:             # FIXME: iloc does not update the array inplace using
  435:             # "split" path
  436:             expected = DataFrame({"a": [1]})
  437:         tm.assert_frame_equal(result, expected)
  438: 
  439:     def test_xs_list_indexer_droplevel_false(self):
  440:         # GH#41760
  441:         mi = MultiIndex.from_tuples([("x", "m", "a"), ("x", "n", "b"), ("y", "o", "c")])
  442:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=mi)
  443:         with pytest.raises(KeyError, match="y"):
  444:             df.xs(("x", "y"), drop_level=False, axis=1)
