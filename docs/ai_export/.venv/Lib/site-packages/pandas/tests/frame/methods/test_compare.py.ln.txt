    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.compat.numpy import np_version_gte1p25
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: 
    9: 
   10: @pytest.mark.parametrize("align_axis", [0, 1, "index", "columns"])
   11: def test_compare_axis(align_axis):
   12:     # GH#30429
   13:     df = pd.DataFrame(
   14:         {"col1": ["a", "b", "c"], "col2": [1.0, 2.0, np.nan], "col3": [1.0, 2.0, 3.0]},
   15:         columns=["col1", "col2", "col3"],
   16:     )
   17:     df2 = df.copy()
   18:     df2.loc[0, "col1"] = "c"
   19:     df2.loc[2, "col3"] = 4.0
   20: 
   21:     result = df.compare(df2, align_axis=align_axis)
   22: 
   23:     if align_axis in (1, "columns"):
   24:         indices = pd.Index([0, 2])
   25:         columns = pd.MultiIndex.from_product([["col1", "col3"], ["self", "other"]])
   26:         expected = pd.DataFrame(
   27:             [["a", "c", np.nan, np.nan], [np.nan, np.nan, 3.0, 4.0]],
   28:             index=indices,
   29:             columns=columns,
   30:         )
   31:     else:
   32:         indices = pd.MultiIndex.from_product([[0, 2], ["self", "other"]])
   33:         columns = pd.Index(["col1", "col3"])
   34:         expected = pd.DataFrame(
   35:             [["a", np.nan], ["c", np.nan], [np.nan, 3.0], [np.nan, 4.0]],
   36:             index=indices,
   37:             columns=columns,
   38:         )
   39:     tm.assert_frame_equal(result, expected)
   40: 
   41: 
   42: @pytest.mark.parametrize(
   43:     "keep_shape, keep_equal",
   44:     [
   45:         (True, False),
   46:         (False, True),
   47:         (True, True),
   48:         # False, False case is already covered in test_compare_axis
   49:     ],
   50: )
   51: def test_compare_various_formats(keep_shape, keep_equal):
   52:     df = pd.DataFrame(
   53:         {"col1": ["a", "b", "c"], "col2": [1.0, 2.0, np.nan], "col3": [1.0, 2.0, 3.0]},
   54:         columns=["col1", "col2", "col3"],
   55:     )
   56:     df2 = df.copy()
   57:     df2.loc[0, "col1"] = "c"
   58:     df2.loc[2, "col3"] = 4.0
   59: 
   60:     result = df.compare(df2, keep_shape=keep_shape, keep_equal=keep_equal)
   61: 
   62:     if keep_shape:
   63:         indices = pd.Index([0, 1, 2])
   64:         columns = pd.MultiIndex.from_product(
   65:             [["col1", "col2", "col3"], ["self", "other"]]
   66:         )
   67:         if keep_equal:
   68:             expected = pd.DataFrame(
   69:                 [
   70:                     ["a", "c", 1.0, 1.0, 1.0, 1.0],
   71:                     ["b", "b", 2.0, 2.0, 2.0, 2.0],
   72:                     ["c", "c", np.nan, np.nan, 3.0, 4.0],
   73:                 ],
   74:                 index=indices,
   75:                 columns=columns,
   76:             )
   77:         else:
   78:             expected = pd.DataFrame(
   79:                 [
   80:                     ["a", "c", np.nan, np.nan, np.nan, np.nan],
   81:                     [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],
   82:                     [np.nan, np.nan, np.nan, np.nan, 3.0, 4.0],
   83:                 ],
   84:                 index=indices,
   85:                 columns=columns,
   86:             )
   87:     else:
   88:         indices = pd.Index([0, 2])
   89:         columns = pd.MultiIndex.from_product([["col1", "col3"], ["self", "other"]])
   90:         expected = pd.DataFrame(
   91:             [["a", "c", 1.0, 1.0], ["c", "c", 3.0, 4.0]], index=indices, columns=columns
   92:         )
   93:     tm.assert_frame_equal(result, expected)
   94: 
   95: 
   96: def test_compare_with_equal_nulls():
   97:     # We want to make sure two NaNs are considered the same
   98:     # and dropped where applicable
   99:     df = pd.DataFrame(
  100:         {"col1": ["a", "b", "c"], "col2": [1.0, 2.0, np.nan], "col3": [1.0, 2.0, 3.0]},
  101:         columns=["col1", "col2", "col3"],
  102:     )
  103:     df2 = df.copy()
  104:     df2.loc[0, "col1"] = "c"
  105: 
  106:     result = df.compare(df2)
  107:     indices = pd.Index([0])
  108:     columns = pd.MultiIndex.from_product([["col1"], ["self", "other"]])
  109:     expected = pd.DataFrame([["a", "c"]], index=indices, columns=columns)
  110:     tm.assert_frame_equal(result, expected)
  111: 
  112: 
  113: def test_compare_with_non_equal_nulls():
  114:     # We want to make sure the relevant NaNs do not get dropped
  115:     # even if the entire row or column are NaNs
  116:     df = pd.DataFrame(
  117:         {"col1": ["a", "b", "c"], "col2": [1.0, 2.0, np.nan], "col3": [1.0, 2.0, 3.0]},
  118:         columns=["col1", "col2", "col3"],
  119:     )
  120:     df2 = df.copy()
  121:     df2.loc[0, "col1"] = "c"
  122:     df2.loc[2, "col3"] = np.nan
  123: 
  124:     result = df.compare(df2)
  125: 
  126:     indices = pd.Index([0, 2])
  127:     columns = pd.MultiIndex.from_product([["col1", "col3"], ["self", "other"]])
  128:     expected = pd.DataFrame(
  129:         [["a", "c", np.nan, np.nan], [np.nan, np.nan, 3.0, np.nan]],
  130:         index=indices,
  131:         columns=columns,
  132:     )
  133:     tm.assert_frame_equal(result, expected)
  134: 
  135: 
  136: @pytest.mark.parametrize("align_axis", [0, 1])
  137: def test_compare_multi_index(align_axis):
  138:     df = pd.DataFrame(
  139:         {"col1": ["a", "b", "c"], "col2": [1.0, 2.0, np.nan], "col3": [1.0, 2.0, 3.0]}
  140:     )
  141:     df.columns = pd.MultiIndex.from_arrays([["a", "a", "b"], ["col1", "col2", "col3"]])
  142:     df.index = pd.MultiIndex.from_arrays([["x", "x", "y"], [0, 1, 2]])
  143: 
  144:     df2 = df.copy()
  145:     df2.iloc[0, 0] = "c"
  146:     df2.iloc[2, 2] = 4.0
  147: 
  148:     result = df.compare(df2, align_axis=align_axis)
  149: 
  150:     if align_axis == 0:
  151:         indices = pd.MultiIndex.from_arrays(
  152:             [["x", "x", "y", "y"], [0, 0, 2, 2], ["self", "other", "self", "other"]]
  153:         )
  154:         columns = pd.MultiIndex.from_arrays([["a", "b"], ["col1", "col3"]])
  155:         data = [["a", np.nan], ["c", np.nan], [np.nan, 3.0], [np.nan, 4.0]]
  156:     else:
  157:         indices = pd.MultiIndex.from_arrays([["x", "y"], [0, 2]])
  158:         columns = pd.MultiIndex.from_arrays(
  159:             [
  160:                 ["a", "a", "b", "b"],
  161:                 ["col1", "col1", "col3", "col3"],
  162:                 ["self", "other", "self", "other"],
  163:             ]
  164:         )
  165:         data = [["a", "c", np.nan, np.nan], [np.nan, np.nan, 3.0, 4.0]]
  166: 
  167:     expected = pd.DataFrame(data=data, index=indices, columns=columns)
  168:     tm.assert_frame_equal(result, expected)
  169: 
  170: 
  171: def test_compare_unaligned_objects():
  172:     # test DataFrames with different indices
  173:     msg = (
  174:         r"Can only compare identically-labeled \(both index and columns\) DataFrame "
  175:         "objects"
  176:     )
  177:     with pytest.raises(ValueError, match=msg):
  178:         df1 = pd.DataFrame([1, 2, 3], index=["a", "b", "c"])
  179:         df2 = pd.DataFrame([1, 2, 3], index=["a", "b", "d"])
  180:         df1.compare(df2)
  181: 
  182:     # test DataFrames with different shapes
  183:     msg = (
  184:         r"Can only compare identically-labeled \(both index and columns\) DataFrame "
  185:         "objects"
  186:     )
  187:     with pytest.raises(ValueError, match=msg):
  188:         df1 = pd.DataFrame(np.ones((3, 3)))
  189:         df2 = pd.DataFrame(np.zeros((2, 1)))
  190:         df1.compare(df2)
  191: 
  192: 
  193: def test_compare_result_names():
  194:     # GH 44354
  195:     df1 = pd.DataFrame(
  196:         {"col1": ["a", "b", "c"], "col2": [1.0, 2.0, np.nan], "col3": [1.0, 2.0, 3.0]},
  197:     )
  198:     df2 = pd.DataFrame(
  199:         {
  200:             "col1": ["c", "b", "c"],
  201:             "col2": [1.0, 2.0, np.nan],
  202:             "col3": [1.0, 2.0, np.nan],
  203:         },
  204:     )
  205:     result = df1.compare(df2, result_names=("left", "right"))
  206:     expected = pd.DataFrame(
  207:         {
  208:             ("col1", "left"): {0: "a", 2: np.nan},
  209:             ("col1", "right"): {0: "c", 2: np.nan},
  210:             ("col3", "left"): {0: np.nan, 2: 3.0},
  211:             ("col3", "right"): {0: np.nan, 2: np.nan},
  212:         }
  213:     )
  214:     tm.assert_frame_equal(result, expected)
  215: 
  216: 
  217: @pytest.mark.parametrize(
  218:     "result_names",
  219:     [
  220:         [1, 2],
  221:         "HK",
  222:         {"2": 2, "3": 3},
  223:         3,
  224:         3.0,
  225:     ],
  226: )
  227: def test_invalid_input_result_names(result_names):
  228:     # GH 44354
  229:     df1 = pd.DataFrame(
  230:         {"col1": ["a", "b", "c"], "col2": [1.0, 2.0, np.nan], "col3": [1.0, 2.0, 3.0]},
  231:     )
  232:     df2 = pd.DataFrame(
  233:         {
  234:             "col1": ["c", "b", "c"],
  235:             "col2": [1.0, 2.0, np.nan],
  236:             "col3": [1.0, 2.0, np.nan],
  237:         },
  238:     )
  239:     with pytest.raises(
  240:         TypeError,
  241:         match=(
  242:             f"Passing 'result_names' as a {type(result_names)} is not "
  243:             "supported. Provide 'result_names' as a tuple instead."
  244:         ),
  245:     ):
  246:         df1.compare(df2, result_names=result_names)
  247: 
  248: 
  249: @pytest.mark.parametrize(
  250:     "val1,val2",
  251:     [(4, pd.NA), (pd.NA, pd.NA), (pd.NA, 4)],
  252: )
  253: def test_compare_ea_and_np_dtype(val1, val2):
  254:     # GH 48966
  255:     arr = [4.0, val1]
  256:     ser = pd.Series([1, val2], dtype="Int64")
  257: 
  258:     df1 = pd.DataFrame({"a": arr, "b": [1.0, 2]})
  259:     df2 = pd.DataFrame({"a": ser, "b": [1.0, 2]})
  260:     expected = pd.DataFrame(
  261:         {
  262:             ("a", "self"): arr,
  263:             ("a", "other"): ser,
  264:             ("b", "self"): np.nan,
  265:             ("b", "other"): np.nan,
  266:         }
  267:     )
  268:     if val1 is pd.NA and val2 is pd.NA:
  269:         # GH#18463 TODO: is this really the desired behavior?
  270:         expected.loc[1, ("a", "self")] = np.nan
  271: 
  272:     if val1 is pd.NA and np_version_gte1p25:
  273:         # can't compare with numpy array if it contains pd.NA
  274:         with pytest.raises(TypeError, match="boolean value of NA is ambiguous"):
  275:             result = df1.compare(df2, keep_shape=True)
  276:     else:
  277:         result = df1.compare(df2, keep_shape=True)
  278:         tm.assert_frame_equal(result, expected)
  279: 
  280: 
  281: @pytest.mark.parametrize(
  282:     "df1_val,df2_val,diff_self,diff_other",
  283:     [
  284:         (4, 3, 4, 3),
  285:         (4, 4, pd.NA, pd.NA),
  286:         (4, pd.NA, 4, pd.NA),
  287:         (pd.NA, pd.NA, pd.NA, pd.NA),
  288:     ],
  289: )
  290: def test_compare_nullable_int64_dtype(df1_val, df2_val, diff_self, diff_other):
  291:     # GH 48966
  292:     df1 = pd.DataFrame({"a": pd.Series([df1_val, pd.NA], dtype="Int64"), "b": [1.0, 2]})
  293:     df2 = df1.copy()
  294:     df2.loc[0, "a"] = df2_val
  295: 
  296:     expected = pd.DataFrame(
  297:         {
  298:             ("a", "self"): pd.Series([diff_self, pd.NA], dtype="Int64"),
  299:             ("a", "other"): pd.Series([diff_other, pd.NA], dtype="Int64"),
  300:             ("b", "self"): np.nan,
  301:             ("b", "other"): np.nan,
  302:         }
  303:     )
  304:     result = df1.compare(df2, keep_shape=True)
  305:     tm.assert_frame_equal(result, expected)
