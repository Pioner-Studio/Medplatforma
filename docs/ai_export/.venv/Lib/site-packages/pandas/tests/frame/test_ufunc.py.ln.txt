    1: from functools import partial
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas as pd
    8: import pandas._testing as tm
    9: from pandas.api.types import is_extension_array_dtype
   10: 
   11: dtypes = [
   12:     "int64",
   13:     "Int64",
   14:     {"A": "int64", "B": "Int64"},
   15: ]
   16: 
   17: 
   18: @pytest.mark.parametrize("dtype", dtypes)
   19: def test_unary_unary(dtype):
   20:     # unary input, unary output
   21:     values = np.array([[-1, -1], [1, 1]], dtype="int64")
   22:     df = pd.DataFrame(values, columns=["A", "B"], index=["a", "b"]).astype(dtype=dtype)
   23:     result = np.positive(df)
   24:     expected = pd.DataFrame(
   25:         np.positive(values), index=df.index, columns=df.columns
   26:     ).astype(dtype)
   27:     tm.assert_frame_equal(result, expected)
   28: 
   29: 
   30: @pytest.mark.parametrize("dtype", dtypes)
   31: def test_unary_binary(request, dtype):
   32:     # unary input, binary output
   33:     if is_extension_array_dtype(dtype) or isinstance(dtype, dict):
   34:         request.applymarker(
   35:             pytest.mark.xfail(
   36:                 reason="Extension / mixed with multiple outputs not implemented."
   37:             )
   38:         )
   39: 
   40:     values = np.array([[-1, -1], [1, 1]], dtype="int64")
   41:     df = pd.DataFrame(values, columns=["A", "B"], index=["a", "b"]).astype(dtype=dtype)
   42:     result_pandas = np.modf(df)
   43:     assert isinstance(result_pandas, tuple)
   44:     assert len(result_pandas) == 2
   45:     expected_numpy = np.modf(values)
   46: 
   47:     for result, b in zip(result_pandas, expected_numpy):
   48:         expected = pd.DataFrame(b, index=df.index, columns=df.columns)
   49:         tm.assert_frame_equal(result, expected)
   50: 
   51: 
   52: @pytest.mark.parametrize("dtype", dtypes)
   53: def test_binary_input_dispatch_binop(dtype):
   54:     # binop ufuncs are dispatched to our dunder methods.
   55:     values = np.array([[-1, -1], [1, 1]], dtype="int64")
   56:     df = pd.DataFrame(values, columns=["A", "B"], index=["a", "b"]).astype(dtype=dtype)
   57:     result = np.add(df, df)
   58:     expected = pd.DataFrame(
   59:         np.add(values, values), index=df.index, columns=df.columns
   60:     ).astype(dtype)
   61:     tm.assert_frame_equal(result, expected)
   62: 
   63: 
   64: @pytest.mark.parametrize(
   65:     "func,arg,expected",
   66:     [
   67:         (np.add, 1, [2, 3, 4, 5]),
   68:         (
   69:             partial(np.add, where=[[False, True], [True, False]]),
   70:             np.array([[1, 1], [1, 1]]),
   71:             [0, 3, 4, 0],
   72:         ),
   73:         (np.power, np.array([[1, 1], [2, 2]]), [1, 2, 9, 16]),
   74:         (np.subtract, 2, [-1, 0, 1, 2]),
   75:         (
   76:             partial(np.negative, where=np.array([[False, True], [True, False]])),
   77:             None,
   78:             [0, -2, -3, 0],
   79:         ),
   80:     ],
   81: )
   82: def test_ufunc_passes_args(func, arg, expected):
   83:     # GH#40662
   84:     arr = np.array([[1, 2], [3, 4]])
   85:     df = pd.DataFrame(arr)
   86:     result_inplace = np.zeros_like(arr)
   87:     # 1-argument ufunc
   88:     if arg is None:
   89:         result = func(df, out=result_inplace)
   90:     else:
   91:         result = func(df, arg, out=result_inplace)
   92: 
   93:     expected = np.array(expected).reshape(2, 2)
   94:     tm.assert_numpy_array_equal(result_inplace, expected)
   95: 
   96:     expected = pd.DataFrame(expected)
   97:     tm.assert_frame_equal(result, expected)
   98: 
   99: 
  100: @pytest.mark.parametrize("dtype_a", dtypes)
  101: @pytest.mark.parametrize("dtype_b", dtypes)
  102: def test_binary_input_aligns_columns(request, dtype_a, dtype_b):
  103:     if (
  104:         is_extension_array_dtype(dtype_a)
  105:         or isinstance(dtype_a, dict)
  106:         or is_extension_array_dtype(dtype_b)
  107:         or isinstance(dtype_b, dict)
  108:     ):
  109:         request.applymarker(
  110:             pytest.mark.xfail(
  111:                 reason="Extension / mixed with multiple inputs not implemented."
  112:             )
  113:         )
  114: 
  115:     df1 = pd.DataFrame({"A": [1, 2], "B": [3, 4]}).astype(dtype_a)
  116: 
  117:     if isinstance(dtype_a, dict) and isinstance(dtype_b, dict):
  118:         dtype_b = dtype_b.copy()
  119:         dtype_b["C"] = dtype_b.pop("B")
  120:     df2 = pd.DataFrame({"A": [1, 2], "C": [3, 4]}).astype(dtype_b)
  121:     # As of 2.0, align first before applying the ufunc
  122:     result = np.heaviside(df1, df2)
  123:     expected = np.heaviside(
  124:         np.array([[1, 3, np.nan], [2, 4, np.nan]]),
  125:         np.array([[1, np.nan, 3], [2, np.nan, 4]]),
  126:     )
  127:     expected = pd.DataFrame(expected, index=[0, 1], columns=["A", "B", "C"])
  128:     tm.assert_frame_equal(result, expected)
  129: 
  130:     result = np.heaviside(df1, df2.values)
  131:     expected = pd.DataFrame([[1.0, 1.0], [1.0, 1.0]], columns=["A", "B"])
  132:     tm.assert_frame_equal(result, expected)
  133: 
  134: 
  135: @pytest.mark.parametrize("dtype", dtypes)
  136: def test_binary_input_aligns_index(request, dtype):
  137:     if is_extension_array_dtype(dtype) or isinstance(dtype, dict):
  138:         request.applymarker(
  139:             pytest.mark.xfail(
  140:                 reason="Extension / mixed with multiple inputs not implemented."
  141:             )
  142:         )
  143:     df1 = pd.DataFrame({"A": [1, 2], "B": [3, 4]}, index=["a", "b"]).astype(dtype)
  144:     df2 = pd.DataFrame({"A": [1, 2], "B": [3, 4]}, index=["a", "c"]).astype(dtype)
  145:     result = np.heaviside(df1, df2)
  146:     expected = np.heaviside(
  147:         np.array([[1, 3], [3, 4], [np.nan, np.nan]]),
  148:         np.array([[1, 3], [np.nan, np.nan], [3, 4]]),
  149:     )
  150:     # TODO(FloatArray): this will be Float64Dtype.
  151:     expected = pd.DataFrame(expected, index=["a", "b", "c"], columns=["A", "B"])
  152:     tm.assert_frame_equal(result, expected)
  153: 
  154:     result = np.heaviside(df1, df2.values)
  155:     expected = pd.DataFrame(
  156:         [[1.0, 1.0], [1.0, 1.0]], columns=["A", "B"], index=["a", "b"]
  157:     )
  158:     tm.assert_frame_equal(result, expected)
  159: 
  160: 
  161: def test_binary_frame_series_raises():
  162:     # We don't currently implement
  163:     df = pd.DataFrame({"A": [1, 2]})
  164:     with pytest.raises(NotImplementedError, match="logaddexp"):
  165:         np.logaddexp(df, df["A"])
  166: 
  167:     with pytest.raises(NotImplementedError, match="logaddexp"):
  168:         np.logaddexp(df["A"], df)
  169: 
  170: 
  171: def test_unary_accumulate_axis():
  172:     # https://github.com/pandas-dev/pandas/issues/39259
  173:     df = pd.DataFrame({"a": [1, 3, 2, 4]})
  174:     result = np.maximum.accumulate(df)
  175:     expected = pd.DataFrame({"a": [1, 3, 3, 4]})
  176:     tm.assert_frame_equal(result, expected)
  177: 
  178:     df = pd.DataFrame({"a": [1, 3, 2, 4], "b": [0.1, 4.0, 3.0, 2.0]})
  179:     result = np.maximum.accumulate(df)
  180:     # in theory could preserve int dtype for default axis=0
  181:     expected = pd.DataFrame({"a": [1.0, 3.0, 3.0, 4.0], "b": [0.1, 4.0, 4.0, 4.0]})
  182:     tm.assert_frame_equal(result, expected)
  183: 
  184:     result = np.maximum.accumulate(df, axis=0)
  185:     tm.assert_frame_equal(result, expected)
  186: 
  187:     result = np.maximum.accumulate(df, axis=1)
  188:     expected = pd.DataFrame({"a": [1.0, 3.0, 2.0, 4.0], "b": [1.0, 4.0, 3.0, 4.0]})
  189:     tm.assert_frame_equal(result, expected)
  190: 
  191: 
  192: def test_frame_outer_disallowed():
  193:     df = pd.DataFrame({"A": [1, 2]})
  194:     with pytest.raises(NotImplementedError, match=""):
  195:         # deprecation enforced in 2.0
  196:         np.subtract.outer(df, df)
  197: 
  198: 
  199: def test_alignment_deprecation_enforced():
  200:     # Enforced in 2.0
  201:     # https://github.com/pandas-dev/pandas/issues/39184
  202:     df1 = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  203:     df2 = pd.DataFrame({"b": [1, 2, 3], "c": [4, 5, 6]})
  204:     s1 = pd.Series([1, 2], index=["a", "b"])
  205:     s2 = pd.Series([1, 2], index=["b", "c"])
  206: 
  207:     # binary dataframe / dataframe
  208:     expected = pd.DataFrame({"a": [2, 4, 6], "b": [8, 10, 12]})
  209: 
  210:     with tm.assert_produces_warning(None):
  211:         # aligned -> no warning!
  212:         result = np.add(df1, df1)
  213:     tm.assert_frame_equal(result, expected)
  214: 
  215:     result = np.add(df1, df2.values)
  216:     tm.assert_frame_equal(result, expected)
  217: 
  218:     result = np.add(df1, df2)
  219:     expected = pd.DataFrame({"a": [np.nan] * 3, "b": [5, 7, 9], "c": [np.nan] * 3})
  220:     tm.assert_frame_equal(result, expected)
  221: 
  222:     result = np.add(df1.values, df2)
  223:     expected = pd.DataFrame({"b": [2, 4, 6], "c": [8, 10, 12]})
  224:     tm.assert_frame_equal(result, expected)
  225: 
  226:     # binary dataframe / series
  227:     expected = pd.DataFrame({"a": [2, 3, 4], "b": [6, 7, 8]})
  228: 
  229:     with tm.assert_produces_warning(None):
  230:         # aligned -> no warning!
  231:         result = np.add(df1, s1)
  232:     tm.assert_frame_equal(result, expected)
  233: 
  234:     result = np.add(df1, s2.values)
  235:     tm.assert_frame_equal(result, expected)
  236: 
  237:     expected = pd.DataFrame(
  238:         {"a": [np.nan] * 3, "b": [5.0, 6.0, 7.0], "c": [np.nan] * 3}
  239:     )
  240:     result = np.add(df1, s2)
  241:     tm.assert_frame_equal(result, expected)
  242: 
  243:     msg = "Cannot apply ufunc <ufunc 'add'> to mixed DataFrame and Series inputs."
  244:     with pytest.raises(NotImplementedError, match=msg):
  245:         np.add(s2, df1)
  246: 
  247: 
  248: def test_alignment_deprecation_many_inputs_enforced():
  249:     # Enforced in 2.0
  250:     # https://github.com/pandas-dev/pandas/issues/39184
  251:     # test that the deprecation also works with > 2 inputs -> using a numba
  252:     # written ufunc for this because numpy itself doesn't have such ufuncs
  253:     numba = pytest.importorskip("numba")
  254: 
  255:     @numba.vectorize([numba.float64(numba.float64, numba.float64, numba.float64)])
  256:     def my_ufunc(x, y, z):
  257:         return x + y + z
  258: 
  259:     df1 = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  260:     df2 = pd.DataFrame({"b": [1, 2, 3], "c": [4, 5, 6]})
  261:     df3 = pd.DataFrame({"a": [1, 2, 3], "c": [4, 5, 6]})
  262: 
  263:     result = my_ufunc(df1, df2, df3)
  264:     expected = pd.DataFrame(np.full((3, 3), np.nan), columns=["a", "b", "c"])
  265:     tm.assert_frame_equal(result, expected)
  266: 
  267:     # all aligned -> no warning
  268:     with tm.assert_produces_warning(None):
  269:         result = my_ufunc(df1, df1, df1)
  270:     expected = pd.DataFrame([[3.0, 12.0], [6.0, 15.0], [9.0, 18.0]], columns=["a", "b"])
  271:     tm.assert_frame_equal(result, expected)
  272: 
  273:     # mixed frame / arrays
  274:     msg = (
  275:         r"operands could not be broadcast together with shapes \(3,3\) \(3,3\) \(3,2\)"
  276:     )
  277:     with pytest.raises(ValueError, match=msg):
  278:         my_ufunc(df1, df2, df3.values)
  279: 
  280:     # single frame -> no warning
  281:     with tm.assert_produces_warning(None):
  282:         result = my_ufunc(df1, df2.values, df3.values)
  283:     tm.assert_frame_equal(result, expected)
  284: 
  285:     # takes indices of first frame
  286:     msg = (
  287:         r"operands could not be broadcast together with shapes \(3,2\) \(3,3\) \(3,3\)"
  288:     )
  289:     with pytest.raises(ValueError, match=msg):
  290:         my_ufunc(df1.values, df2, df3)
  291: 
  292: 
  293: def test_array_ufuncs_for_many_arguments():
  294:     # GH39853
  295:     def add3(x, y, z):
  296:         return x + y + z
  297: 
  298:     ufunc = np.frompyfunc(add3, 3, 1)
  299:     df = pd.DataFrame([[1, 2], [3, 4]])
  300: 
  301:     result = ufunc(df, df, 1)
  302:     expected = pd.DataFrame([[3, 5], [7, 9]], dtype=object)
  303:     tm.assert_frame_equal(result, expected)
  304: 
  305:     ser = pd.Series([1, 2])
  306:     msg = (
  307:         "Cannot apply ufunc <ufunc 'add3 (vectorized)'> "
  308:         "to mixed DataFrame and Series inputs."
  309:     )
  310:     with pytest.raises(NotImplementedError, match=re.escape(msg)):
  311:         ufunc(df, df, ser)
