    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas import (
    7:     Categorical,
    8:     CategoricalDtype,
    9:     CategoricalIndex,
   10:     DataFrame,
   11:     DateOffset,
   12:     DatetimeIndex,
   13:     Index,
   14:     MultiIndex,
   15:     Series,
   16:     Timestamp,
   17:     concat,
   18:     date_range,
   19:     get_dummies,
   20:     period_range,
   21: )
   22: import pandas._testing as tm
   23: from pandas.core.arrays import SparseArray
   24: 
   25: 
   26: class TestGetitem:
   27:     def test_getitem_unused_level_raises(self):
   28:         # GH#20410
   29:         mi = MultiIndex(
   30:             levels=[["a_lot", "onlyone", "notevenone"], [1970, ""]],
   31:             codes=[[1, 0], [1, 0]],
   32:         )
   33:         df = DataFrame(-1, index=range(3), columns=mi)
   34: 
   35:         with pytest.raises(KeyError, match="notevenone"):
   36:             df["notevenone"]
   37: 
   38:     def test_getitem_periodindex(self):
   39:         rng = period_range("1/1/2000", periods=5)
   40:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 5)), columns=rng)
   41: 
   42:         ts = df[rng[0]]
   43:         tm.assert_series_equal(ts, df.iloc[:, 0])
   44: 
   45:         ts = df["1/1/2000"]
   46:         tm.assert_series_equal(ts, df.iloc[:, 0])
   47: 
   48:     def test_getitem_list_of_labels_categoricalindex_cols(self):
   49:         # GH#16115
   50:         cats = Categorical([Timestamp("12-31-1999"), Timestamp("12-31-2000")])
   51: 
   52:         expected = DataFrame([[1, 0], [0, 1]], dtype="bool", index=[0, 1], columns=cats)
   53:         dummies = get_dummies(cats)
   54:         result = dummies[list(dummies.columns)]
   55:         tm.assert_frame_equal(result, expected)
   56: 
   57:     def test_getitem_sparse_column_return_type_and_dtype(self):
   58:         # https://github.com/pandas-dev/pandas/issues/23559
   59:         data = SparseArray([0, 1])
   60:         df = DataFrame({"A": data})
   61:         expected = Series(data, name="A")
   62:         result = df["A"]
   63:         tm.assert_series_equal(result, expected)
   64: 
   65:         # Also check iloc and loc while we're here
   66:         result = df.iloc[:, 0]
   67:         tm.assert_series_equal(result, expected)
   68: 
   69:         result = df.loc[:, "A"]
   70:         tm.assert_series_equal(result, expected)
   71: 
   72:     def test_getitem_string_columns(self):
   73:         # GH#46185
   74:         df = DataFrame([[1, 2]], columns=Index(["A", "B"], dtype="string"))
   75:         result = df.A
   76:         expected = df["A"]
   77:         tm.assert_series_equal(result, expected)
   78: 
   79: 
   80: class TestGetitemListLike:
   81:     def test_getitem_list_missing_key(self):
   82:         # GH#13822, incorrect error string with non-unique columns when missing
   83:         # column is accessed
   84:         df = DataFrame({"x": [1.0], "y": [2.0], "z": [3.0]})
   85:         df.columns = ["x", "x", "z"]
   86: 
   87:         # Check that we get the correct value in the KeyError
   88:         with pytest.raises(KeyError, match=r"\['y'\] not in index"):
   89:             df[["x", "y", "z"]]
   90: 
   91:     def test_getitem_list_duplicates(self):
   92:         # GH#1943
   93:         df = DataFrame(
   94:             np.random.default_rng(2).standard_normal((4, 4)), columns=list("AABC")
   95:         )
   96:         df.columns.name = "foo"
   97: 
   98:         result = df[["B", "C"]]
   99:         assert result.columns.name == "foo"
  100: 
  101:         expected = df.iloc[:, 2:]
  102:         tm.assert_frame_equal(result, expected)
  103: 
  104:     def test_getitem_dupe_cols(self):
  105:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=["a", "a", "b"])
  106:         msg = "\"None of [Index(['baf'], dtype="
  107:         with pytest.raises(KeyError, match=re.escape(msg)):
  108:             df[["baf"]]
  109: 
  110:     @pytest.mark.parametrize(
  111:         "idx_type",
  112:         [
  113:             list,
  114:             iter,
  115:             Index,
  116:             set,
  117:             lambda keys: dict(zip(keys, range(len(keys)))),
  118:             lambda keys: dict(zip(keys, range(len(keys)))).keys(),
  119:         ],
  120:         ids=["list", "iter", "Index", "set", "dict", "dict_keys"],
  121:     )
  122:     @pytest.mark.parametrize("levels", [1, 2])
  123:     def test_getitem_listlike(self, idx_type, levels, float_frame):
  124:         # GH#21294
  125: 
  126:         if levels == 1:
  127:             frame, missing = float_frame, "food"
  128:         else:
  129:             # MultiIndex columns
  130:             frame = DataFrame(
  131:                 np.random.default_rng(2).standard_normal((8, 3)),
  132:                 columns=Index(
  133:                     [("foo", "bar"), ("baz", "qux"), ("peek", "aboo")],
  134:                     name=("sth", "sth2"),
  135:                 ),
  136:             )
  137:             missing = ("good", "food")
  138: 
  139:         keys = [frame.columns[1], frame.columns[0]]
  140:         idx = idx_type(keys)
  141:         idx_check = list(idx_type(keys))
  142: 
  143:         if isinstance(idx, (set, dict)):
  144:             with pytest.raises(TypeError, match="as an indexer is not supported"):
  145:                 frame[idx]
  146: 
  147:             return
  148:         else:
  149:             result = frame[idx]
  150: 
  151:         expected = frame.loc[:, idx_check]
  152:         expected.columns.names = frame.columns.names
  153: 
  154:         tm.assert_frame_equal(result, expected)
  155: 
  156:         idx = idx_type(keys + [missing])
  157:         with pytest.raises(KeyError, match="not in index"):
  158:             frame[idx]
  159: 
  160:     def test_getitem_iloc_generator(self):
  161:         # GH#39614
  162:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  163:         indexer = (x for x in [1, 2])
  164:         result = df.iloc[indexer]
  165:         expected = DataFrame({"a": [2, 3], "b": [5, 6]}, index=[1, 2])
  166:         tm.assert_frame_equal(result, expected)
  167: 
  168:     def test_getitem_iloc_two_dimensional_generator(self):
  169:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  170:         indexer = (x for x in [1, 2])
  171:         result = df.iloc[indexer, 1]
  172:         expected = Series([5, 6], name="b", index=[1, 2])
  173:         tm.assert_series_equal(result, expected)
  174: 
  175:     def test_getitem_iloc_dateoffset_days(self):
  176:         # GH 46671
  177:         df = DataFrame(
  178:             list(range(10)),
  179:             index=date_range("01-01-2022", periods=10, freq=DateOffset(days=1)),
  180:         )
  181:         result = df.loc["2022-01-01":"2022-01-03"]
  182:         expected = DataFrame(
  183:             [0, 1, 2],
  184:             index=DatetimeIndex(
  185:                 ["2022-01-01", "2022-01-02", "2022-01-03"],
  186:                 dtype="datetime64[ns]",
  187:                 freq=DateOffset(days=1),
  188:             ),
  189:         )
  190:         tm.assert_frame_equal(result, expected)
  191: 
  192:         df = DataFrame(
  193:             list(range(10)),
  194:             index=date_range(
  195:                 "01-01-2022", periods=10, freq=DateOffset(days=1, hours=2)
  196:             ),
  197:         )
  198:         result = df.loc["2022-01-01":"2022-01-03"]
  199:         expected = DataFrame(
  200:             [0, 1, 2],
  201:             index=DatetimeIndex(
  202:                 ["2022-01-01 00:00:00", "2022-01-02 02:00:00", "2022-01-03 04:00:00"],
  203:                 dtype="datetime64[ns]",
  204:                 freq=DateOffset(days=1, hours=2),
  205:             ),
  206:         )
  207:         tm.assert_frame_equal(result, expected)
  208: 
  209:         df = DataFrame(
  210:             list(range(10)),
  211:             index=date_range("01-01-2022", periods=10, freq=DateOffset(minutes=3)),
  212:         )
  213:         result = df.loc["2022-01-01":"2022-01-03"]
  214:         tm.assert_frame_equal(result, df)
  215: 
  216: 
  217: class TestGetitemCallable:
  218:     def test_getitem_callable(self, float_frame):
  219:         # GH#12533
  220:         result = float_frame[lambda x: "A"]
  221:         expected = float_frame.loc[:, "A"]
  222:         tm.assert_series_equal(result, expected)
  223: 
  224:         result = float_frame[lambda x: ["A", "B"]]
  225:         expected = float_frame.loc[:, ["A", "B"]]
  226:         tm.assert_frame_equal(result, float_frame.loc[:, ["A", "B"]])
  227: 
  228:         df = float_frame[:3]
  229:         result = df[lambda x: [True, False, True]]
  230:         expected = float_frame.iloc[[0, 2], :]
  231:         tm.assert_frame_equal(result, expected)
  232: 
  233:     def test_loc_multiindex_columns_one_level(self):
  234:         # GH#29749
  235:         df = DataFrame([[1, 2]], columns=[["a", "b"]])
  236:         expected = DataFrame([1], columns=[["a"]])
  237: 
  238:         result = df["a"]
  239:         tm.assert_frame_equal(result, expected)
  240: 
  241:         result = df.loc[:, "a"]
  242:         tm.assert_frame_equal(result, expected)
  243: 
  244: 
  245: class TestGetitemBooleanMask:
  246:     def test_getitem_bool_mask_categorical_index(self):
  247:         df3 = DataFrame(
  248:             {
  249:                 "A": np.arange(6, dtype="int64"),
  250:             },
  251:             index=CategoricalIndex(
  252:                 [1, 1, 2, 1, 3, 2],
  253:                 dtype=CategoricalDtype([3, 2, 1], ordered=True),
  254:                 name="B",
  255:             ),
  256:         )
  257:         df4 = DataFrame(
  258:             {
  259:                 "A": np.arange(6, dtype="int64"),
  260:             },
  261:             index=CategoricalIndex(
  262:                 [1, 1, 2, 1, 3, 2],
  263:                 dtype=CategoricalDtype([3, 2, 1], ordered=False),
  264:                 name="B",
  265:             ),
  266:         )
  267: 
  268:         result = df3[df3.index == "a"]
  269:         expected = df3.iloc[[]]
  270:         tm.assert_frame_equal(result, expected)
  271: 
  272:         result = df4[df4.index == "a"]
  273:         expected = df4.iloc[[]]
  274:         tm.assert_frame_equal(result, expected)
  275: 
  276:         result = df3[df3.index == 1]
  277:         expected = df3.iloc[[0, 1, 3]]
  278:         tm.assert_frame_equal(result, expected)
  279: 
  280:         result = df4[df4.index == 1]
  281:         expected = df4.iloc[[0, 1, 3]]
  282:         tm.assert_frame_equal(result, expected)
  283: 
  284:         # since we have an ordered categorical
  285: 
  286:         # CategoricalIndex([1, 1, 2, 1, 3, 2],
  287:         #         categories=[3, 2, 1],
  288:         #         ordered=True,
  289:         #         name='B')
  290:         result = df3[df3.index < 2]
  291:         expected = df3.iloc[[4]]
  292:         tm.assert_frame_equal(result, expected)
  293: 
  294:         result = df3[df3.index > 1]
  295:         expected = df3.iloc[[]]
  296:         tm.assert_frame_equal(result, expected)
  297: 
  298:         # unordered
  299:         # cannot be compared
  300: 
  301:         # CategoricalIndex([1, 1, 2, 1, 3, 2],
  302:         #         categories=[3, 2, 1],
  303:         #         ordered=False,
  304:         #         name='B')
  305:         msg = "Unordered Categoricals can only compare equality or not"
  306:         with pytest.raises(TypeError, match=msg):
  307:             df4[df4.index < 2]
  308:         with pytest.raises(TypeError, match=msg):
  309:             df4[df4.index > 1]
  310: 
  311:     @pytest.mark.parametrize(
  312:         "data1,data2,expected_data",
  313:         (
  314:             (
  315:                 [[1, 2], [3, 4]],
  316:                 [[0.5, 6], [7, 8]],
  317:                 [[np.nan, 3.0], [np.nan, 4.0], [np.nan, 7.0], [6.0, 8.0]],
  318:             ),
  319:             (
  320:                 [[1, 2], [3, 4]],
  321:                 [[5, 6], [7, 8]],
  322:                 [[np.nan, 3.0], [np.nan, 4.0], [5, 7], [6, 8]],
  323:             ),
  324:         ),
  325:     )
  326:     def test_getitem_bool_mask_duplicate_columns_mixed_dtypes(
  327:         self,
  328:         data1,
  329:         data2,
  330:         expected_data,
  331:     ):
  332:         # GH#31954
  333: 
  334:         df1 = DataFrame(np.array(data1))
  335:         df2 = DataFrame(np.array(data2))
  336:         df = concat([df1, df2], axis=1)
  337: 
  338:         result = df[df > 2]
  339: 
  340:         exdict = {i: np.array(col) for i, col in enumerate(expected_data)}
  341:         expected = DataFrame(exdict).rename(columns={2: 0, 3: 1})
  342:         tm.assert_frame_equal(result, expected)
  343: 
  344:     @pytest.fixture
  345:     def df_dup_cols(self):
  346:         dups = ["A", "A", "C", "D"]
  347:         df = DataFrame(np.arange(12).reshape(3, 4), columns=dups, dtype="float64")
  348:         return df
  349: 
  350:     def test_getitem_boolean_frame_unaligned_with_duplicate_columns(self, df_dup_cols):
  351:         # `df.A > 6` is a DataFrame with a different shape from df
  352: 
  353:         # boolean with the duplicate raises
  354:         df = df_dup_cols
  355:         msg = "cannot reindex on an axis with duplicate labels"
  356:         with pytest.raises(ValueError, match=msg):
  357:             df[df.A > 6]
  358: 
  359:     def test_getitem_boolean_series_with_duplicate_columns(self, df_dup_cols):
  360:         # boolean indexing
  361:         # GH#4879
  362:         df = DataFrame(
  363:             np.arange(12).reshape(3, 4), columns=["A", "B", "C", "D"], dtype="float64"
  364:         )
  365:         expected = df[df.C > 6]
  366:         expected.columns = df_dup_cols.columns
  367: 
  368:         df = df_dup_cols
  369:         result = df[df.C > 6]
  370: 
  371:         tm.assert_frame_equal(result, expected)
  372: 
  373:     def test_getitem_boolean_frame_with_duplicate_columns(self, df_dup_cols):
  374:         # where
  375:         df = DataFrame(
  376:             np.arange(12).reshape(3, 4), columns=["A", "B", "C", "D"], dtype="float64"
  377:         )
  378:         # `df > 6` is a DataFrame with the same shape+alignment as df
  379:         expected = df[df > 6]
  380:         expected.columns = df_dup_cols.columns
  381: 
  382:         df = df_dup_cols
  383:         result = df[df > 6]
  384: 
  385:         tm.assert_frame_equal(result, expected)
  386: 
  387:     def test_getitem_empty_frame_with_boolean(self):
  388:         # Test for issue GH#11859
  389: 
  390:         df = DataFrame()
  391:         df2 = df[df > 0]
  392:         tm.assert_frame_equal(df, df2)
  393: 
  394:     def test_getitem_returns_view_when_column_is_unique_in_df(
  395:         self, using_copy_on_write, warn_copy_on_write
  396:     ):
  397:         # GH#45316
  398:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=["a", "a", "b"])
  399:         df_orig = df.copy()
  400:         view = df["b"]
  401:         with tm.assert_cow_warning(warn_copy_on_write):
  402:             view.loc[:] = 100
  403:         if using_copy_on_write:
  404:             expected = df_orig
  405:         else:
  406:             expected = DataFrame([[1, 2, 100], [4, 5, 100]], columns=["a", "a", "b"])
  407:         tm.assert_frame_equal(df, expected)
  408: 
  409:     def test_getitem_frozenset_unique_in_column(self):
  410:         # GH#41062
  411:         df = DataFrame([[1, 2, 3, 4]], columns=[frozenset(["KEY"]), "B", "C", "C"])
  412:         result = df[frozenset(["KEY"])]
  413:         expected = Series([1], name=frozenset(["KEY"]))
  414:         tm.assert_series_equal(result, expected)
  415: 
  416: 
  417: class TestGetitemSlice:
  418:     def test_getitem_slice_float64(self, frame_or_series):
  419:         values = np.arange(10.0, 50.0, 2)
  420:         index = Index(values)
  421: 
  422:         start, end = values[[5, 15]]
  423: 
  424:         data = np.random.default_rng(2).standard_normal((20, 3))
  425:         if frame_or_series is not DataFrame:
  426:             data = data[:, 0]
  427: 
  428:         obj = frame_or_series(data, index=index)
  429: 
  430:         result = obj[start:end]
  431:         expected = obj.iloc[5:16]
  432:         tm.assert_equal(result, expected)
  433: 
  434:         result = obj.loc[start:end]
  435:         tm.assert_equal(result, expected)
  436: 
  437:     def test_getitem_datetime_slice(self):
  438:         # GH#43223
  439:         df = DataFrame(
  440:             {"a": 0},
  441:             index=DatetimeIndex(
  442:                 [
  443:                     "11.01.2011 22:00",
  444:                     "11.01.2011 23:00",
  445:                     "12.01.2011 00:00",
  446:                     "2011-01-13 00:00",
  447:                 ]
  448:             ),
  449:         )
  450:         with pytest.raises(
  451:             KeyError, match="Value based partial slicing on non-monotonic"
  452:         ):
  453:             df["2011-01-01":"2011-11-01"]
  454: 
  455:     def test_getitem_slice_same_dim_only_one_axis(self):
  456:         # GH#54622
  457:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 8)))
  458:         result = df.iloc[(slice(None, None, 2),)]
  459:         assert result.shape == (5, 8)
  460:         expected = df.iloc[slice(None, None, 2), slice(None)]
  461:         tm.assert_frame_equal(result, expected)
  462: 
  463: 
  464: class TestGetitemDeprecatedIndexers:
  465:     @pytest.mark.parametrize("key", [{"a", "b"}, {"a": "a"}])
  466:     def test_getitem_dict_and_set_deprecated(self, key):
  467:         # GH#42825 enforced in 2.0
  468:         df = DataFrame(
  469:             [[1, 2], [3, 4]], columns=MultiIndex.from_tuples([("a", 1), ("b", 2)])
  470:         )
  471:         with pytest.raises(TypeError, match="as an indexer is not supported"):
  472:             df[key]
