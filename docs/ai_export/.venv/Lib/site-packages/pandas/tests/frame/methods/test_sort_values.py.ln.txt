    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Categorical,
    7:     DataFrame,
    8:     NaT,
    9:     Timestamp,
   10:     date_range,
   11: )
   12: import pandas._testing as tm
   13: from pandas.util.version import Version
   14: 
   15: 
   16: class TestDataFrameSortValues:
   17:     @pytest.mark.parametrize("dtype", [np.uint8, bool])
   18:     def test_sort_values_sparse_no_warning(self, dtype):
   19:         # GH#45618
   20:         ser = pd.Series(Categorical(["a", "b", "a"], categories=["a", "b", "c"]))
   21:         df = pd.get_dummies(ser, dtype=dtype, sparse=True)
   22: 
   23:         with tm.assert_produces_warning(None):
   24:             # No warnings about constructing Index from SparseArray
   25:             df.sort_values(by=df.columns.tolist())
   26: 
   27:     def test_sort_values(self):
   28:         frame = DataFrame(
   29:             [[1, 1, 2], [3, 1, 0], [4, 5, 6]], index=[1, 2, 3], columns=list("ABC")
   30:         )
   31: 
   32:         # by column (axis=0)
   33:         sorted_df = frame.sort_values(by="A")
   34:         indexer = frame["A"].argsort().values
   35:         expected = frame.loc[frame.index[indexer]]
   36:         tm.assert_frame_equal(sorted_df, expected)
   37: 
   38:         sorted_df = frame.sort_values(by="A", ascending=False)
   39:         indexer = indexer[::-1]
   40:         expected = frame.loc[frame.index[indexer]]
   41:         tm.assert_frame_equal(sorted_df, expected)
   42: 
   43:         sorted_df = frame.sort_values(by="A", ascending=False)
   44:         tm.assert_frame_equal(sorted_df, expected)
   45: 
   46:         # GH4839
   47:         sorted_df = frame.sort_values(by=["A"], ascending=[False])
   48:         tm.assert_frame_equal(sorted_df, expected)
   49: 
   50:         # multiple bys
   51:         sorted_df = frame.sort_values(by=["B", "C"])
   52:         expected = frame.loc[[2, 1, 3]]
   53:         tm.assert_frame_equal(sorted_df, expected)
   54: 
   55:         sorted_df = frame.sort_values(by=["B", "C"], ascending=False)
   56:         tm.assert_frame_equal(sorted_df, expected[::-1])
   57: 
   58:         sorted_df = frame.sort_values(by=["B", "A"], ascending=[True, False])
   59:         tm.assert_frame_equal(sorted_df, expected)
   60: 
   61:         msg = "No axis named 2 for object type DataFrame"
   62:         with pytest.raises(ValueError, match=msg):
   63:             frame.sort_values(by=["A", "B"], axis=2, inplace=True)
   64: 
   65:         # by row (axis=1): GH#10806
   66:         sorted_df = frame.sort_values(by=3, axis=1)
   67:         expected = frame
   68:         tm.assert_frame_equal(sorted_df, expected)
   69: 
   70:         sorted_df = frame.sort_values(by=3, axis=1, ascending=False)
   71:         expected = frame.reindex(columns=["C", "B", "A"])
   72:         tm.assert_frame_equal(sorted_df, expected)
   73: 
   74:         sorted_df = frame.sort_values(by=[1, 2], axis="columns")
   75:         expected = frame.reindex(columns=["B", "A", "C"])
   76:         tm.assert_frame_equal(sorted_df, expected)
   77: 
   78:         sorted_df = frame.sort_values(by=[1, 3], axis=1, ascending=[True, False])
   79:         tm.assert_frame_equal(sorted_df, expected)
   80: 
   81:         sorted_df = frame.sort_values(by=[1, 3], axis=1, ascending=False)
   82:         expected = frame.reindex(columns=["C", "B", "A"])
   83:         tm.assert_frame_equal(sorted_df, expected)
   84: 
   85:         msg = r"Length of ascending \(5\) != length of by \(2\)"
   86:         with pytest.raises(ValueError, match=msg):
   87:             frame.sort_values(by=["A", "B"], axis=0, ascending=[True] * 5)
   88: 
   89:     def test_sort_values_by_empty_list(self):
   90:         # https://github.com/pandas-dev/pandas/issues/40258
   91:         expected = DataFrame({"a": [1, 4, 2, 5, 3, 6]})
   92:         result = expected.sort_values(by=[])
   93:         tm.assert_frame_equal(result, expected)
   94:         assert result is not expected
   95: 
   96:     def test_sort_values_inplace(self):
   97:         frame = DataFrame(
   98:             np.random.default_rng(2).standard_normal((4, 4)),
   99:             index=[1, 2, 3, 4],
  100:             columns=["A", "B", "C", "D"],
  101:         )
  102: 
  103:         sorted_df = frame.copy()
  104:         return_value = sorted_df.sort_values(by="A", inplace=True)
  105:         assert return_value is None
  106:         expected = frame.sort_values(by="A")
  107:         tm.assert_frame_equal(sorted_df, expected)
  108: 
  109:         sorted_df = frame.copy()
  110:         return_value = sorted_df.sort_values(by=1, axis=1, inplace=True)
  111:         assert return_value is None
  112:         expected = frame.sort_values(by=1, axis=1)
  113:         tm.assert_frame_equal(sorted_df, expected)
  114: 
  115:         sorted_df = frame.copy()
  116:         return_value = sorted_df.sort_values(by="A", ascending=False, inplace=True)
  117:         assert return_value is None
  118:         expected = frame.sort_values(by="A", ascending=False)
  119:         tm.assert_frame_equal(sorted_df, expected)
  120: 
  121:         sorted_df = frame.copy()
  122:         return_value = sorted_df.sort_values(
  123:             by=["A", "B"], ascending=False, inplace=True
  124:         )
  125:         assert return_value is None
  126:         expected = frame.sort_values(by=["A", "B"], ascending=False)
  127:         tm.assert_frame_equal(sorted_df, expected)
  128: 
  129:     def test_sort_values_multicolumn(self):
  130:         A = np.arange(5).repeat(20)
  131:         B = np.tile(np.arange(5), 20)
  132:         np.random.default_rng(2).shuffle(A)
  133:         np.random.default_rng(2).shuffle(B)
  134:         frame = DataFrame(
  135:             {"A": A, "B": B, "C": np.random.default_rng(2).standard_normal(100)}
  136:         )
  137: 
  138:         result = frame.sort_values(by=["A", "B"])
  139:         indexer = np.lexsort((frame["B"], frame["A"]))
  140:         expected = frame.take(indexer)
  141:         tm.assert_frame_equal(result, expected)
  142: 
  143:         result = frame.sort_values(by=["A", "B"], ascending=False)
  144:         indexer = np.lexsort(
  145:             (frame["B"].rank(ascending=False), frame["A"].rank(ascending=False))
  146:         )
  147:         expected = frame.take(indexer)
  148:         tm.assert_frame_equal(result, expected)
  149: 
  150:         result = frame.sort_values(by=["B", "A"])
  151:         indexer = np.lexsort((frame["A"], frame["B"]))
  152:         expected = frame.take(indexer)
  153:         tm.assert_frame_equal(result, expected)
  154: 
  155:     def test_sort_values_multicolumn_uint64(self):
  156:         # GH#9918
  157:         # uint64 multicolumn sort
  158: 
  159:         df = DataFrame(
  160:             {
  161:                 "a": pd.Series([18446637057563306014, 1162265347240853609]),
  162:                 "b": pd.Series([1, 2]),
  163:             }
  164:         )
  165:         df["a"] = df["a"].astype(np.uint64)
  166:         result = df.sort_values(["a", "b"])
  167: 
  168:         expected = DataFrame(
  169:             {
  170:                 "a": pd.Series([18446637057563306014, 1162265347240853609]),
  171:                 "b": pd.Series([1, 2]),
  172:             },
  173:             index=pd.Index([1, 0]),
  174:         )
  175: 
  176:         tm.assert_frame_equal(result, expected)
  177: 
  178:     def test_sort_values_nan(self):
  179:         # GH#3917
  180:         df = DataFrame(
  181:             {"A": [1, 2, np.nan, 1, 6, 8, 4], "B": [9, np.nan, 5, 2, 5, 4, 5]}
  182:         )
  183: 
  184:         # sort one column only
  185:         expected = DataFrame(
  186:             {"A": [np.nan, 1, 1, 2, 4, 6, 8], "B": [5, 9, 2, np.nan, 5, 5, 4]},
  187:             index=[2, 0, 3, 1, 6, 4, 5],
  188:         )
  189:         sorted_df = df.sort_values(["A"], na_position="first")
  190:         tm.assert_frame_equal(sorted_df, expected)
  191: 
  192:         expected = DataFrame(
  193:             {"A": [np.nan, 8, 6, 4, 2, 1, 1], "B": [5, 4, 5, 5, np.nan, 9, 2]},
  194:             index=[2, 5, 4, 6, 1, 0, 3],
  195:         )
  196:         sorted_df = df.sort_values(["A"], na_position="first", ascending=False)
  197:         tm.assert_frame_equal(sorted_df, expected)
  198: 
  199:         expected = df.reindex(columns=["B", "A"])
  200:         sorted_df = df.sort_values(by=1, axis=1, na_position="first")
  201:         tm.assert_frame_equal(sorted_df, expected)
  202: 
  203:         # na_position='last', order
  204:         expected = DataFrame(
  205:             {"A": [1, 1, 2, 4, 6, 8, np.nan], "B": [2, 9, np.nan, 5, 5, 4, 5]},
  206:             index=[3, 0, 1, 6, 4, 5, 2],
  207:         )
  208:         sorted_df = df.sort_values(["A", "B"])
  209:         tm.assert_frame_equal(sorted_df, expected)
  210: 
  211:         # na_position='first', order
  212:         expected = DataFrame(
  213:             {"A": [np.nan, 1, 1, 2, 4, 6, 8], "B": [5, 2, 9, np.nan, 5, 5, 4]},
  214:             index=[2, 3, 0, 1, 6, 4, 5],
  215:         )
  216:         sorted_df = df.sort_values(["A", "B"], na_position="first")
  217:         tm.assert_frame_equal(sorted_df, expected)
  218: 
  219:         # na_position='first', not order
  220:         expected = DataFrame(
  221:             {"A": [np.nan, 1, 1, 2, 4, 6, 8], "B": [5, 9, 2, np.nan, 5, 5, 4]},
  222:             index=[2, 0, 3, 1, 6, 4, 5],
  223:         )
  224:         sorted_df = df.sort_values(["A", "B"], ascending=[1, 0], na_position="first")
  225:         tm.assert_frame_equal(sorted_df, expected)
  226: 
  227:         # na_position='last', not order
  228:         expected = DataFrame(
  229:             {"A": [8, 6, 4, 2, 1, 1, np.nan], "B": [4, 5, 5, np.nan, 2, 9, 5]},
  230:             index=[5, 4, 6, 1, 3, 0, 2],
  231:         )
  232:         sorted_df = df.sort_values(["A", "B"], ascending=[0, 1], na_position="last")
  233:         tm.assert_frame_equal(sorted_df, expected)
  234: 
  235:     def test_sort_values_stable_descending_sort(self):
  236:         # GH#6399
  237:         df = DataFrame(
  238:             [[2, "first"], [2, "second"], [1, "a"], [1, "b"]],
  239:             columns=["sort_col", "order"],
  240:         )
  241:         sorted_df = df.sort_values(by="sort_col", kind="mergesort", ascending=False)
  242:         tm.assert_frame_equal(df, sorted_df)
  243: 
  244:     @pytest.mark.parametrize(
  245:         "expected_idx_non_na, ascending",
  246:         [
  247:             [
  248:                 [3, 4, 5, 0, 1, 8, 6, 9, 7, 10, 13, 14],
  249:                 [True, True],
  250:             ],
  251:             [
  252:                 [0, 3, 4, 5, 1, 8, 6, 7, 10, 13, 14, 9],
  253:                 [True, False],
  254:             ],
  255:             [
  256:                 [9, 7, 10, 13, 14, 6, 8, 1, 3, 4, 5, 0],
  257:                 [False, True],
  258:             ],
  259:             [
  260:                 [7, 10, 13, 14, 9, 6, 8, 1, 0, 3, 4, 5],
  261:                 [False, False],
  262:             ],
  263:         ],
  264:     )
  265:     @pytest.mark.parametrize("na_position", ["first", "last"])
  266:     def test_sort_values_stable_multicolumn_sort(
  267:         self, expected_idx_non_na, ascending, na_position
  268:     ):
  269:         # GH#38426 Clarify sort_values with mult. columns / labels is stable
  270:         df = DataFrame(
  271:             {
  272:                 "A": [1, 2, np.nan, 1, 1, 1, 6, 8, 4, 8, 8, np.nan, np.nan, 8, 8],
  273:                 "B": [9, np.nan, 5, 2, 2, 2, 5, 4, 5, 3, 4, np.nan, np.nan, 4, 4],
  274:             }
  275:         )
  276:         # All rows with NaN in col "B" only have unique values in "A", therefore,
  277:         # only the rows with NaNs in "A" have to be treated individually:
  278:         expected_idx = (
  279:             [11, 12, 2] + expected_idx_non_na
  280:             if na_position == "first"
  281:             else expected_idx_non_na + [2, 11, 12]
  282:         )
  283:         expected = df.take(expected_idx)
  284:         sorted_df = df.sort_values(
  285:             ["A", "B"], ascending=ascending, na_position=na_position
  286:         )
  287:         tm.assert_frame_equal(sorted_df, expected)
  288: 
  289:     def test_sort_values_stable_categorial(self):
  290:         # GH#16793
  291:         df = DataFrame({"x": Categorical(np.repeat([1, 2, 3, 4], 5), ordered=True)})
  292:         expected = df.copy()
  293:         sorted_df = df.sort_values("x", kind="mergesort")
  294:         tm.assert_frame_equal(sorted_df, expected)
  295: 
  296:     def test_sort_values_datetimes(self):
  297:         # GH#3461, argsort / lexsort differences for a datetime column
  298:         df = DataFrame(
  299:             ["a", "a", "a", "b", "c", "d", "e", "f", "g"],
  300:             columns=["A"],
  301:             index=date_range("20130101", periods=9),
  302:         )
  303:         dts = [
  304:             Timestamp(x)
  305:             for x in [
  306:                 "2004-02-11",
  307:                 "2004-01-21",
  308:                 "2004-01-26",
  309:                 "2005-09-20",
  310:                 "2010-10-04",
  311:                 "2009-05-12",
  312:                 "2008-11-12",
  313:                 "2010-09-28",
  314:                 "2010-09-28",
  315:             ]
  316:         ]
  317:         df["B"] = dts[::2] + dts[1::2]
  318:         df["C"] = 2.0
  319:         df["A1"] = 3.0
  320: 
  321:         df1 = df.sort_values(by="A")
  322:         df2 = df.sort_values(by=["A"])
  323:         tm.assert_frame_equal(df1, df2)
  324: 
  325:         df1 = df.sort_values(by="B")
  326:         df2 = df.sort_values(by=["B"])
  327:         tm.assert_frame_equal(df1, df2)
  328: 
  329:         df1 = df.sort_values(by="B")
  330: 
  331:         df2 = df.sort_values(by=["C", "B"])
  332:         tm.assert_frame_equal(df1, df2)
  333: 
  334:     def test_sort_values_frame_column_inplace_sort_exception(
  335:         self, float_frame, using_copy_on_write
  336:     ):
  337:         s = float_frame["A"]
  338:         float_frame_orig = float_frame.copy()
  339:         if using_copy_on_write:
  340:             # INFO(CoW) Series is a new object, so can be changed inplace
  341:             # without modifying original datafame
  342:             s.sort_values(inplace=True)
  343:             tm.assert_series_equal(s, float_frame_orig["A"].sort_values())
  344:             # column in dataframe is not changed
  345:             tm.assert_frame_equal(float_frame, float_frame_orig)
  346:         else:
  347:             with pytest.raises(ValueError, match="This Series is a view"):
  348:                 s.sort_values(inplace=True)
  349: 
  350:         cp = s.copy()
  351:         cp.sort_values()  # it works!
  352: 
  353:     def test_sort_values_nat_values_in_int_column(self):
  354:         # GH#14922: "sorting with large float and multiple columns incorrect"
  355: 
  356:         # cause was that the int64 value NaT was considered as "na". Which is
  357:         # only correct for datetime64 columns.
  358: 
  359:         int_values = (2, int(NaT._value))
  360:         float_values = (2.0, -1.797693e308)
  361: 
  362:         df = DataFrame(
  363:             {"int": int_values, "float": float_values}, columns=["int", "float"]
  364:         )
  365: 
  366:         df_reversed = DataFrame(
  367:             {"int": int_values[::-1], "float": float_values[::-1]},
  368:             columns=["int", "float"],
  369:             index=[1, 0],
  370:         )
  371: 
  372:         # NaT is not a "na" for int64 columns, so na_position must not
  373:         # influence the result:
  374:         df_sorted = df.sort_values(["int", "float"], na_position="last")
  375:         tm.assert_frame_equal(df_sorted, df_reversed)
  376: 
  377:         df_sorted = df.sort_values(["int", "float"], na_position="first")
  378:         tm.assert_frame_equal(df_sorted, df_reversed)
  379: 
  380:         # reverse sorting order
  381:         df_sorted = df.sort_values(["int", "float"], ascending=False)
  382:         tm.assert_frame_equal(df_sorted, df)
  383: 
  384:         # and now check if NaT is still considered as "na" for datetime64
  385:         # columns:
  386:         df = DataFrame(
  387:             {"datetime": [Timestamp("2016-01-01"), NaT], "float": float_values},
  388:             columns=["datetime", "float"],
  389:         )
  390: 
  391:         df_reversed = DataFrame(
  392:             {"datetime": [NaT, Timestamp("2016-01-01")], "float": float_values[::-1]},
  393:             columns=["datetime", "float"],
  394:             index=[1, 0],
  395:         )
  396: 
  397:         df_sorted = df.sort_values(["datetime", "float"], na_position="first")
  398:         tm.assert_frame_equal(df_sorted, df_reversed)
  399: 
  400:         df_sorted = df.sort_values(["datetime", "float"], na_position="last")
  401:         tm.assert_frame_equal(df_sorted, df)
  402: 
  403:         # Ascending should not affect the results.
  404:         df_sorted = df.sort_values(["datetime", "float"], ascending=False)
  405:         tm.assert_frame_equal(df_sorted, df)
  406: 
  407:     def test_sort_nat(self):
  408:         # GH 16836
  409: 
  410:         d1 = [Timestamp(x) for x in ["2016-01-01", "2015-01-01", np.nan, "2016-01-01"]]
  411:         d2 = [
  412:             Timestamp(x)
  413:             for x in ["2017-01-01", "2014-01-01", "2016-01-01", "2015-01-01"]
  414:         ]
  415:         df = DataFrame({"a": d1, "b": d2}, index=[0, 1, 2, 3])
  416: 
  417:         d3 = [Timestamp(x) for x in ["2015-01-01", "2016-01-01", "2016-01-01", np.nan]]
  418:         d4 = [
  419:             Timestamp(x)
  420:             for x in ["2014-01-01", "2015-01-01", "2017-01-01", "2016-01-01"]
  421:         ]
  422:         expected = DataFrame({"a": d3, "b": d4}, index=[1, 3, 0, 2])
  423:         sorted_df = df.sort_values(by=["a", "b"])
  424:         tm.assert_frame_equal(sorted_df, expected)
  425: 
  426:     def test_sort_values_na_position_with_categories(self):
  427:         # GH#22556
  428:         # Positioning missing value properly when column is Categorical.
  429:         categories = ["A", "B", "C"]
  430:         category_indices = [0, 2, 4]
  431:         list_of_nans = [np.nan, np.nan]
  432:         na_indices = [1, 3]
  433:         na_position_first = "first"
  434:         na_position_last = "last"
  435:         column_name = "c"
  436: 
  437:         reversed_categories = sorted(categories, reverse=True)
  438:         reversed_category_indices = sorted(category_indices, reverse=True)
  439:         reversed_na_indices = sorted(na_indices)
  440: 
  441:         df = DataFrame(
  442:             {
  443:                 column_name: Categorical(
  444:                     ["A", np.nan, "B", np.nan, "C"], categories=categories, ordered=True
  445:                 )
  446:             }
  447:         )
  448:         # sort ascending with na first
  449:         result = df.sort_values(
  450:             by=column_name, ascending=True, na_position=na_position_first
  451:         )
  452:         expected = DataFrame(
  453:             {
  454:                 column_name: Categorical(
  455:                     list_of_nans + categories, categories=categories, ordered=True
  456:                 )
  457:             },
  458:             index=na_indices + category_indices,
  459:         )
  460: 
  461:         tm.assert_frame_equal(result, expected)
  462: 
  463:         # sort ascending with na last
  464:         result = df.sort_values(
  465:             by=column_name, ascending=True, na_position=na_position_last
  466:         )
  467:         expected = DataFrame(
  468:             {
  469:                 column_name: Categorical(
  470:                     categories + list_of_nans, categories=categories, ordered=True
  471:                 )
  472:             },
  473:             index=category_indices + na_indices,
  474:         )
  475: 
  476:         tm.assert_frame_equal(result, expected)
  477: 
  478:         # sort descending with na first
  479:         result = df.sort_values(
  480:             by=column_name, ascending=False, na_position=na_position_first
  481:         )
  482:         expected = DataFrame(
  483:             {
  484:                 column_name: Categorical(
  485:                     list_of_nans + reversed_categories,
  486:                     categories=categories,
  487:                     ordered=True,
  488:                 )
  489:             },
  490:             index=reversed_na_indices + reversed_category_indices,
  491:         )
  492: 
  493:         tm.assert_frame_equal(result, expected)
  494: 
  495:         # sort descending with na last
  496:         result = df.sort_values(
  497:             by=column_name, ascending=False, na_position=na_position_last
  498:         )
  499:         expected = DataFrame(
  500:             {
  501:                 column_name: Categorical(
  502:                     reversed_categories + list_of_nans,
  503:                     categories=categories,
  504:                     ordered=True,
  505:                 )
  506:             },
  507:             index=reversed_category_indices + reversed_na_indices,
  508:         )
  509: 
  510:         tm.assert_frame_equal(result, expected)
  511: 
  512:     def test_sort_values_nat(self):
  513:         # GH#16836
  514: 
  515:         d1 = [Timestamp(x) for x in ["2016-01-01", "2015-01-01", np.nan, "2016-01-01"]]
  516:         d2 = [
  517:             Timestamp(x)
  518:             for x in ["2017-01-01", "2014-01-01", "2016-01-01", "2015-01-01"]
  519:         ]
  520:         df = DataFrame({"a": d1, "b": d2}, index=[0, 1, 2, 3])
  521: 
  522:         d3 = [Timestamp(x) for x in ["2015-01-01", "2016-01-01", "2016-01-01", np.nan]]
  523:         d4 = [
  524:             Timestamp(x)
  525:             for x in ["2014-01-01", "2015-01-01", "2017-01-01", "2016-01-01"]
  526:         ]
  527:         expected = DataFrame({"a": d3, "b": d4}, index=[1, 3, 0, 2])
  528:         sorted_df = df.sort_values(by=["a", "b"])
  529:         tm.assert_frame_equal(sorted_df, expected)
  530: 
  531:     def test_sort_values_na_position_with_categories_raises(self):
  532:         df = DataFrame(
  533:             {
  534:                 "c": Categorical(
  535:                     ["A", np.nan, "B", np.nan, "C"],
  536:                     categories=["A", "B", "C"],
  537:                     ordered=True,
  538:                 )
  539:             }
  540:         )
  541: 
  542:         with pytest.raises(ValueError, match="invalid na_position: bad_position"):
  543:             df.sort_values(by="c", ascending=False, na_position="bad_position")
  544: 
  545:     @pytest.mark.parametrize("inplace", [True, False])
  546:     @pytest.mark.parametrize(
  547:         "original_dict, sorted_dict, ignore_index, output_index",
  548:         [
  549:             ({"A": [1, 2, 3]}, {"A": [3, 2, 1]}, True, [0, 1, 2]),
  550:             ({"A": [1, 2, 3]}, {"A": [3, 2, 1]}, False, [2, 1, 0]),
  551:             (
  552:                 {"A": [1, 2, 3], "B": [2, 3, 4]},
  553:                 {"A": [3, 2, 1], "B": [4, 3, 2]},
  554:                 True,
  555:                 [0, 1, 2],
  556:             ),
  557:             (
  558:                 {"A": [1, 2, 3], "B": [2, 3, 4]},
  559:                 {"A": [3, 2, 1], "B": [4, 3, 2]},
  560:                 False,
  561:                 [2, 1, 0],
  562:             ),
  563:         ],
  564:     )
  565:     def test_sort_values_ignore_index(
  566:         self, inplace, original_dict, sorted_dict, ignore_index, output_index
  567:     ):
  568:         # GH 30114
  569:         df = DataFrame(original_dict)
  570:         expected = DataFrame(sorted_dict, index=output_index)
  571:         kwargs = {"ignore_index": ignore_index, "inplace": inplace}
  572: 
  573:         if inplace:
  574:             result_df = df.copy()
  575:             result_df.sort_values("A", ascending=False, **kwargs)
  576:         else:
  577:             result_df = df.sort_values("A", ascending=False, **kwargs)
  578: 
  579:         tm.assert_frame_equal(result_df, expected)
  580:         tm.assert_frame_equal(df, DataFrame(original_dict))
  581: 
  582:     def test_sort_values_nat_na_position_default(self):
  583:         # GH 13230
  584:         expected = DataFrame(
  585:             {
  586:                 "A": [1, 2, 3, 4, 4],
  587:                 "date": pd.DatetimeIndex(
  588:                     [
  589:                         "2010-01-01 09:00:00",
  590:                         "2010-01-01 09:00:01",
  591:                         "2010-01-01 09:00:02",
  592:                         "2010-01-01 09:00:03",
  593:                         "NaT",
  594:                     ]
  595:                 ),
  596:             }
  597:         )
  598:         result = expected.sort_values(["A", "date"])
  599:         tm.assert_frame_equal(result, expected)
  600: 
  601:     def test_sort_values_item_cache(self, using_array_manager, using_copy_on_write):
  602:         # previous behavior incorrect retained an invalid _item_cache entry
  603:         df = DataFrame(
  604:             np.random.default_rng(2).standard_normal((4, 3)), columns=["A", "B", "C"]
  605:         )
  606:         df["D"] = df["A"] * 2
  607:         ser = df["A"]
  608:         if not using_array_manager:
  609:             assert len(df._mgr.blocks) == 2
  610: 
  611:         df.sort_values(by="A")
  612: 
  613:         if using_copy_on_write:
  614:             ser.iloc[0] = 99
  615:             assert df.iloc[0, 0] == df["A"][0]
  616:             assert df.iloc[0, 0] != 99
  617:         else:
  618:             ser.values[0] = 99
  619:             assert df.iloc[0, 0] == df["A"][0]
  620:             assert df.iloc[0, 0] == 99
  621: 
  622:     def test_sort_values_reshaping(self):
  623:         # GH 39426
  624:         values = list(range(21))
  625:         expected = DataFrame([values], columns=values)
  626:         df = expected.sort_values(expected.index[0], axis=1, ignore_index=True)
  627: 
  628:         tm.assert_frame_equal(df, expected)
  629: 
  630:     def test_sort_values_no_by_inplace(self):
  631:         # GH#50643
  632:         df = DataFrame({"a": [1, 2, 3]})
  633:         expected = df.copy()
  634:         result = df.sort_values(by=[], inplace=True)
  635:         tm.assert_frame_equal(df, expected)
  636:         assert result is None
  637: 
  638:     def test_sort_values_no_op_reset_index(self):
  639:         # GH#52553
  640:         df = DataFrame({"A": [10, 20], "B": [1, 5]}, index=[2, 3])
  641:         result = df.sort_values(by="A", ignore_index=True)
  642:         expected = DataFrame({"A": [10, 20], "B": [1, 5]})
  643:         tm.assert_frame_equal(result, expected)
  644: 
  645: 
  646: class TestDataFrameSortKey:  # test key sorting (issue 27237)
  647:     def test_sort_values_inplace_key(self, sort_by_key):
  648:         frame = DataFrame(
  649:             np.random.default_rng(2).standard_normal((4, 4)),
  650:             index=[1, 2, 3, 4],
  651:             columns=["A", "B", "C", "D"],
  652:         )
  653: 
  654:         sorted_df = frame.copy()
  655:         return_value = sorted_df.sort_values(by="A", inplace=True, key=sort_by_key)
  656:         assert return_value is None
  657:         expected = frame.sort_values(by="A", key=sort_by_key)
  658:         tm.assert_frame_equal(sorted_df, expected)
  659: 
  660:         sorted_df = frame.copy()
  661:         return_value = sorted_df.sort_values(
  662:             by=1, axis=1, inplace=True, key=sort_by_key
  663:         )
  664:         assert return_value is None
  665:         expected = frame.sort_values(by=1, axis=1, key=sort_by_key)
  666:         tm.assert_frame_equal(sorted_df, expected)
  667: 
  668:         sorted_df = frame.copy()
  669:         return_value = sorted_df.sort_values(
  670:             by="A", ascending=False, inplace=True, key=sort_by_key
  671:         )
  672:         assert return_value is None
  673:         expected = frame.sort_values(by="A", ascending=False, key=sort_by_key)
  674:         tm.assert_frame_equal(sorted_df, expected)
  675: 
  676:         sorted_df = frame.copy()
  677:         sorted_df.sort_values(
  678:             by=["A", "B"], ascending=False, inplace=True, key=sort_by_key
  679:         )
  680:         expected = frame.sort_values(by=["A", "B"], ascending=False, key=sort_by_key)
  681:         tm.assert_frame_equal(sorted_df, expected)
  682: 
  683:     def test_sort_values_key(self):
  684:         df = DataFrame(np.array([0, 5, np.nan, 3, 2, np.nan]))
  685: 
  686:         result = df.sort_values(0)
  687:         expected = df.iloc[[0, 4, 3, 1, 2, 5]]
  688:         tm.assert_frame_equal(result, expected)
  689: 
  690:         result = df.sort_values(0, key=lambda x: x + 5)
  691:         expected = df.iloc[[0, 4, 3, 1, 2, 5]]
  692:         tm.assert_frame_equal(result, expected)
  693: 
  694:         result = df.sort_values(0, key=lambda x: -x, ascending=False)
  695:         expected = df.iloc[[0, 4, 3, 1, 2, 5]]
  696:         tm.assert_frame_equal(result, expected)
  697: 
  698:     def test_sort_values_by_key(self):
  699:         df = DataFrame(
  700:             {
  701:                 "a": np.array([0, 3, np.nan, 3, 2, np.nan]),
  702:                 "b": np.array([0, 2, np.nan, 5, 2, np.nan]),
  703:             }
  704:         )
  705: 
  706:         result = df.sort_values("a", key=lambda x: -x)
  707:         expected = df.iloc[[1, 3, 4, 0, 2, 5]]
  708:         tm.assert_frame_equal(result, expected)
  709: 
  710:         result = df.sort_values(by=["a", "b"], key=lambda x: -x)
  711:         expected = df.iloc[[3, 1, 4, 0, 2, 5]]
  712:         tm.assert_frame_equal(result, expected)
  713: 
  714:         result = df.sort_values(by=["a", "b"], key=lambda x: -x, ascending=False)
  715:         expected = df.iloc[[0, 4, 1, 3, 2, 5]]
  716:         tm.assert_frame_equal(result, expected)
  717: 
  718:     def test_sort_values_by_key_by_name(self):
  719:         df = DataFrame(
  720:             {
  721:                 "a": np.array([0, 3, np.nan, 3, 2, np.nan]),
  722:                 "b": np.array([0, 2, np.nan, 5, 2, np.nan]),
  723:             }
  724:         )
  725: 
  726:         def key(col):
  727:             if col.name == "a":
  728:                 return -col
  729:             else:
  730:                 return col
  731: 
  732:         result = df.sort_values(by="a", key=key)
  733:         expected = df.iloc[[1, 3, 4, 0, 2, 5]]
  734:         tm.assert_frame_equal(result, expected)
  735: 
  736:         result = df.sort_values(by=["a"], key=key)
  737:         expected = df.iloc[[1, 3, 4, 0, 2, 5]]
  738:         tm.assert_frame_equal(result, expected)
  739: 
  740:         result = df.sort_values(by="b", key=key)
  741:         expected = df.iloc[[0, 1, 4, 3, 2, 5]]
  742:         tm.assert_frame_equal(result, expected)
  743: 
  744:         result = df.sort_values(by=["a", "b"], key=key)
  745:         expected = df.iloc[[1, 3, 4, 0, 2, 5]]
  746:         tm.assert_frame_equal(result, expected)
  747: 
  748:     def test_sort_values_key_string(self):
  749:         df = DataFrame(np.array([["hello", "goodbye"], ["hello", "Hello"]]))
  750: 
  751:         result = df.sort_values(1)
  752:         expected = df[::-1]
  753:         tm.assert_frame_equal(result, expected)
  754: 
  755:         result = df.sort_values([0, 1], key=lambda col: col.str.lower())
  756:         tm.assert_frame_equal(result, df)
  757: 
  758:         result = df.sort_values(
  759:             [0, 1], key=lambda col: col.str.lower(), ascending=False
  760:         )
  761:         expected = df.sort_values(1, key=lambda col: col.str.lower(), ascending=False)
  762:         tm.assert_frame_equal(result, expected)
  763: 
  764:     def test_sort_values_key_empty(self, sort_by_key):
  765:         df = DataFrame(np.array([]))
  766: 
  767:         df.sort_values(0, key=sort_by_key)
  768:         df.sort_index(key=sort_by_key)
  769: 
  770:     def test_changes_length_raises(self):
  771:         df = DataFrame({"A": [1, 2, 3]})
  772:         with pytest.raises(ValueError, match="change the shape"):
  773:             df.sort_values("A", key=lambda x: x[:1])
  774: 
  775:     def test_sort_values_key_axes(self):
  776:         df = DataFrame({0: ["Hello", "goodbye"], 1: [0, 1]})
  777: 
  778:         result = df.sort_values(0, key=lambda col: col.str.lower())
  779:         expected = df[::-1]
  780:         tm.assert_frame_equal(result, expected)
  781: 
  782:         result = df.sort_values(1, key=lambda col: -col)
  783:         expected = df[::-1]
  784:         tm.assert_frame_equal(result, expected)
  785: 
  786:     def test_sort_values_key_dict_axis(self):
  787:         df = DataFrame({0: ["Hello", 0], 1: ["goodbye", 1]})
  788: 
  789:         result = df.sort_values(0, key=lambda col: col.str.lower(), axis=1)
  790:         expected = df.loc[:, ::-1]
  791:         tm.assert_frame_equal(result, expected)
  792: 
  793:         result = df.sort_values(1, key=lambda col: -col, axis=1)
  794:         expected = df.loc[:, ::-1]
  795:         tm.assert_frame_equal(result, expected)
  796: 
  797:     @pytest.mark.parametrize("ordered", [True, False])
  798:     def test_sort_values_key_casts_to_categorical(self, ordered):
  799:         # https://github.com/pandas-dev/pandas/issues/36383
  800:         categories = ["c", "b", "a"]
  801:         df = DataFrame({"x": [1, 1, 1], "y": ["a", "b", "c"]})
  802: 
  803:         def sorter(key):
  804:             if key.name == "y":
  805:                 return pd.Series(
  806:                     Categorical(key, categories=categories, ordered=ordered)
  807:                 )
  808:             return key
  809: 
  810:         result = df.sort_values(by=["x", "y"], key=sorter)
  811:         expected = DataFrame(
  812:             {"x": [1, 1, 1], "y": ["c", "b", "a"]}, index=pd.Index([2, 1, 0])
  813:         )
  814: 
  815:         tm.assert_frame_equal(result, expected)
  816: 
  817: 
  818: @pytest.fixture
  819: def df_none():
  820:     return DataFrame(
  821:         {
  822:             "outer": ["a", "a", "a", "b", "b", "b"],
  823:             "inner": [1, 2, 2, 2, 1, 1],
  824:             "A": np.arange(6, 0, -1),
  825:             ("B", 5): ["one", "one", "two", "two", "one", "one"],
  826:         }
  827:     )
  828: 
  829: 
  830: @pytest.fixture(params=[["outer"], ["outer", "inner"]])
  831: def df_idx(request, df_none):
  832:     levels = request.param
  833:     return df_none.set_index(levels)
  834: 
  835: 
  836: @pytest.fixture(
  837:     params=[
  838:         "inner",  # index level
  839:         ["outer"],  # list of index level
  840:         "A",  # column
  841:         [("B", 5)],  # list of column
  842:         ["inner", "outer"],  # two index levels
  843:         [("B", 5), "outer"],  # index level and column
  844:         ["A", ("B", 5)],  # Two columns
  845:         ["inner", "outer"],  # two index levels and column
  846:     ]
  847: )
  848: def sort_names(request):
  849:     return request.param
  850: 
  851: 
  852: @pytest.fixture(params=[True, False])
  853: def ascending(request):
  854:     return request.param
  855: 
  856: 
  857: class TestSortValuesLevelAsStr:
  858:     def test_sort_index_level_and_column_label(
  859:         self, df_none, df_idx, sort_names, ascending, request
  860:     ):
  861:         # GH#14353
  862:         if (
  863:             Version(np.__version__) >= Version("1.25")
  864:             and request.node.callspec.id == "df_idx0-inner-True"
  865:         ):
  866:             request.applymarker(
  867:                 pytest.mark.xfail(
  868:                     reason=(
  869:                         "pandas default unstable sorting of duplicates"
  870:                         "issue with numpy>=1.25 with AVX instructions"
  871:                     ),
  872:                     strict=False,
  873:                 )
  874:             )
  875: 
  876:         # Get index levels from df_idx
  877:         levels = df_idx.index.names
  878: 
  879:         # Compute expected by sorting on columns and the setting index
  880:         expected = df_none.sort_values(
  881:             by=sort_names, ascending=ascending, axis=0
  882:         ).set_index(levels)
  883: 
  884:         # Compute result sorting on mix on columns and index levels
  885:         result = df_idx.sort_values(by=sort_names, ascending=ascending, axis=0)
  886: 
  887:         tm.assert_frame_equal(result, expected)
  888: 
  889:     def test_sort_column_level_and_index_label(
  890:         self, df_none, df_idx, sort_names, ascending, request
  891:     ):
  892:         # GH#14353
  893: 
  894:         # Get levels from df_idx
  895:         levels = df_idx.index.names
  896: 
  897:         # Compute expected by sorting on axis=0, setting index levels, and then
  898:         # transposing. For some cases this will result in a frame with
  899:         # multiple column levels
  900:         expected = (
  901:             df_none.sort_values(by=sort_names, ascending=ascending, axis=0)
  902:             .set_index(levels)
  903:             .T
  904:         )
  905: 
  906:         # Compute result by transposing and sorting on axis=1.
  907:         result = df_idx.T.sort_values(by=sort_names, ascending=ascending, axis=1)
  908: 
  909:         if Version(np.__version__) >= Version("1.25"):
  910:             request.applymarker(
  911:                 pytest.mark.xfail(
  912:                     reason=(
  913:                         "pandas default unstable sorting of duplicates"
  914:                         "issue with numpy>=1.25 with AVX instructions"
  915:                     ),
  916:                     strict=False,
  917:                 )
  918:             )
  919: 
  920:         tm.assert_frame_equal(result, expected)
  921: 
  922:     def test_sort_values_validate_ascending_for_value_error(self):
  923:         # GH41634
  924:         df = DataFrame({"D": [23, 7, 21]})
  925: 
  926:         msg = 'For argument "ascending" expected type bool, received type str.'
  927:         with pytest.raises(ValueError, match=msg):
  928:             df.sort_values(by="D", ascending="False")
  929: 
  930:     @pytest.mark.parametrize("ascending", [False, 0, 1, True])
  931:     def test_sort_values_validate_ascending_functional(self, ascending):
  932:         df = DataFrame({"D": [23, 7, 21]})
  933:         indexer = df["D"].argsort().values
  934: 
  935:         if not ascending:
  936:             indexer = indexer[::-1]
  937: 
  938:         expected = df.loc[df.index[indexer]]
  939:         result = df.sort_values(by="D", ascending=ascending)
  940:         tm.assert_frame_equal(result, expected)
