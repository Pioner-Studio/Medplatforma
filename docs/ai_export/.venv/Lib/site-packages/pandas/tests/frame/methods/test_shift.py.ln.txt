    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     CategoricalIndex,
    9:     DataFrame,
   10:     Index,
   11:     NaT,
   12:     Series,
   13:     date_range,
   14:     offsets,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: class TestDataFrameShift:
   20:     def test_shift_axis1_with_valid_fill_value_one_array(self):
   21:         # Case with axis=1 that does not go through the "len(arrays)>1" path
   22:         #  in DataFrame.shift
   23:         data = np.random.default_rng(2).standard_normal((5, 3))
   24:         df = DataFrame(data)
   25:         res = df.shift(axis=1, periods=1, fill_value=12345)
   26:         expected = df.T.shift(periods=1, fill_value=12345).T
   27:         tm.assert_frame_equal(res, expected)
   28: 
   29:         # same but with an 1D ExtensionArray backing it
   30:         df2 = df[[0]].astype("Float64")
   31:         res2 = df2.shift(axis=1, periods=1, fill_value=12345)
   32:         expected2 = DataFrame([12345] * 5, dtype="Float64")
   33:         tm.assert_frame_equal(res2, expected2)
   34: 
   35:     def test_shift_deprecate_freq_and_fill_value(self, frame_or_series):
   36:         # Can't pass both!
   37:         obj = frame_or_series(
   38:             np.random.default_rng(2).standard_normal(5),
   39:             index=date_range("1/1/2000", periods=5, freq="h"),
   40:         )
   41: 
   42:         msg = (
   43:             "Passing a 'freq' together with a 'fill_value' silently ignores the "
   44:             "fill_value"
   45:         )
   46:         with tm.assert_produces_warning(FutureWarning, match=msg):
   47:             obj.shift(1, fill_value=1, freq="h")
   48: 
   49:         if frame_or_series is DataFrame:
   50:             obj.columns = date_range("1/1/2000", periods=1, freq="h")
   51:             with tm.assert_produces_warning(FutureWarning, match=msg):
   52:                 obj.shift(1, axis=1, fill_value=1, freq="h")
   53: 
   54:     @pytest.mark.parametrize(
   55:         "input_data, output_data",
   56:         [(np.empty(shape=(0,)), []), (np.ones(shape=(2,)), [np.nan, 1.0])],
   57:     )
   58:     def test_shift_non_writable_array(self, input_data, output_data, frame_or_series):
   59:         # GH21049 Verify whether non writable numpy array is shiftable
   60:         input_data.setflags(write=False)
   61: 
   62:         result = frame_or_series(input_data).shift(1)
   63:         if frame_or_series is not Series:
   64:             # need to explicitly specify columns in the empty case
   65:             expected = frame_or_series(
   66:                 output_data,
   67:                 index=range(len(output_data)),
   68:                 columns=range(1),
   69:                 dtype="float64",
   70:             )
   71:         else:
   72:             expected = frame_or_series(output_data, dtype="float64")
   73: 
   74:         tm.assert_equal(result, expected)
   75: 
   76:     def test_shift_mismatched_freq(self, frame_or_series):
   77:         ts = frame_or_series(
   78:             np.random.default_rng(2).standard_normal(5),
   79:             index=date_range("1/1/2000", periods=5, freq="h"),
   80:         )
   81: 
   82:         result = ts.shift(1, freq="5min")
   83:         exp_index = ts.index.shift(1, freq="5min")
   84:         tm.assert_index_equal(result.index, exp_index)
   85: 
   86:         # GH#1063, multiple of same base
   87:         result = ts.shift(1, freq="4h")
   88:         exp_index = ts.index + offsets.Hour(4)
   89:         tm.assert_index_equal(result.index, exp_index)
   90: 
   91:     @pytest.mark.parametrize(
   92:         "obj",
   93:         [
   94:             Series([np.arange(5)]),
   95:             date_range("1/1/2011", periods=24, freq="h"),
   96:             Series(range(5), index=date_range("2017", periods=5)),
   97:         ],
   98:     )
   99:     @pytest.mark.parametrize("shift_size", [0, 1, 2])
  100:     def test_shift_always_copy(self, obj, shift_size, frame_or_series):
  101:         # GH#22397
  102:         if frame_or_series is not Series:
  103:             obj = obj.to_frame()
  104:         assert obj.shift(shift_size) is not obj
  105: 
  106:     def test_shift_object_non_scalar_fill(self):
  107:         # shift requires scalar fill_value except for object dtype
  108:         ser = Series(range(3))
  109:         with pytest.raises(ValueError, match="fill_value must be a scalar"):
  110:             ser.shift(1, fill_value=[])
  111: 
  112:         df = ser.to_frame()
  113:         with pytest.raises(ValueError, match="fill_value must be a scalar"):
  114:             df.shift(1, fill_value=np.arange(3))
  115: 
  116:         obj_ser = ser.astype(object)
  117:         result = obj_ser.shift(1, fill_value={})
  118:         assert result[0] == {}
  119: 
  120:         obj_df = obj_ser.to_frame()
  121:         result = obj_df.shift(1, fill_value={})
  122:         assert result.iloc[0, 0] == {}
  123: 
  124:     def test_shift_int(self, datetime_frame, frame_or_series):
  125:         ts = tm.get_obj(datetime_frame, frame_or_series).astype(int)
  126:         shifted = ts.shift(1)
  127:         expected = ts.astype(float).shift(1)
  128:         tm.assert_equal(shifted, expected)
  129: 
  130:     @pytest.mark.parametrize("dtype", ["int32", "int64"])
  131:     def test_shift_32bit_take(self, frame_or_series, dtype):
  132:         # 32-bit taking
  133:         # GH#8129
  134:         index = date_range("2000-01-01", periods=5)
  135:         arr = np.arange(5, dtype=dtype)
  136:         s1 = frame_or_series(arr, index=index)
  137:         p = arr[1]
  138:         result = s1.shift(periods=p)
  139:         expected = frame_or_series([np.nan, 0, 1, 2, 3], index=index)
  140:         tm.assert_equal(result, expected)
  141: 
  142:     @pytest.mark.parametrize("periods", [1, 2, 3, 4])
  143:     def test_shift_preserve_freqstr(self, periods, frame_or_series):
  144:         # GH#21275
  145:         obj = frame_or_series(
  146:             range(periods),
  147:             index=date_range("2016-1-1 00:00:00", periods=periods, freq="h"),
  148:         )
  149: 
  150:         result = obj.shift(1, "2h")
  151: 
  152:         expected = frame_or_series(
  153:             range(periods),
  154:             index=date_range("2016-1-1 02:00:00", periods=periods, freq="h"),
  155:         )
  156:         tm.assert_equal(result, expected)
  157: 
  158:     def test_shift_dst(self, frame_or_series):
  159:         # GH#13926
  160:         dates = date_range("2016-11-06", freq="h", periods=10, tz="US/Eastern")
  161:         obj = frame_or_series(dates)
  162: 
  163:         res = obj.shift(0)
  164:         tm.assert_equal(res, obj)
  165:         assert tm.get_dtype(res) == "datetime64[ns, US/Eastern]"
  166: 
  167:         res = obj.shift(1)
  168:         exp_vals = [NaT] + dates.astype(object).values.tolist()[:9]
  169:         exp = frame_or_series(exp_vals)
  170:         tm.assert_equal(res, exp)
  171:         assert tm.get_dtype(res) == "datetime64[ns, US/Eastern]"
  172: 
  173:         res = obj.shift(-2)
  174:         exp_vals = dates.astype(object).values.tolist()[2:] + [NaT, NaT]
  175:         exp = frame_or_series(exp_vals)
  176:         tm.assert_equal(res, exp)
  177:         assert tm.get_dtype(res) == "datetime64[ns, US/Eastern]"
  178: 
  179:     @pytest.mark.parametrize("ex", [10, -10, 20, -20])
  180:     def test_shift_dst_beyond(self, frame_or_series, ex):
  181:         # GH#13926
  182:         dates = date_range("2016-11-06", freq="h", periods=10, tz="US/Eastern")
  183:         obj = frame_or_series(dates)
  184:         res = obj.shift(ex)
  185:         exp = frame_or_series([NaT] * 10, dtype="datetime64[ns, US/Eastern]")
  186:         tm.assert_equal(res, exp)
  187:         assert tm.get_dtype(res) == "datetime64[ns, US/Eastern]"
  188: 
  189:     def test_shift_by_zero(self, datetime_frame, frame_or_series):
  190:         # shift by 0
  191:         obj = tm.get_obj(datetime_frame, frame_or_series)
  192:         unshifted = obj.shift(0)
  193:         tm.assert_equal(unshifted, obj)
  194: 
  195:     def test_shift(self, datetime_frame):
  196:         # naive shift
  197:         ser = datetime_frame["A"]
  198: 
  199:         shifted = datetime_frame.shift(5)
  200:         tm.assert_index_equal(shifted.index, datetime_frame.index)
  201: 
  202:         shifted_ser = ser.shift(5)
  203:         tm.assert_series_equal(shifted["A"], shifted_ser)
  204: 
  205:         shifted = datetime_frame.shift(-5)
  206:         tm.assert_index_equal(shifted.index, datetime_frame.index)
  207: 
  208:         shifted_ser = ser.shift(-5)
  209:         tm.assert_series_equal(shifted["A"], shifted_ser)
  210: 
  211:         unshifted = datetime_frame.shift(5).shift(-5)
  212:         tm.assert_numpy_array_equal(
  213:             unshifted.dropna().values, datetime_frame.values[:-5]
  214:         )
  215: 
  216:         unshifted_ser = ser.shift(5).shift(-5)
  217:         tm.assert_numpy_array_equal(unshifted_ser.dropna().values, ser.values[:-5])
  218: 
  219:     def test_shift_by_offset(self, datetime_frame, frame_or_series):
  220:         # shift by DateOffset
  221:         obj = tm.get_obj(datetime_frame, frame_or_series)
  222:         offset = offsets.BDay()
  223: 
  224:         shifted = obj.shift(5, freq=offset)
  225:         assert len(shifted) == len(obj)
  226:         unshifted = shifted.shift(-5, freq=offset)
  227:         tm.assert_equal(unshifted, obj)
  228: 
  229:         shifted2 = obj.shift(5, freq="B")
  230:         tm.assert_equal(shifted, shifted2)
  231: 
  232:         unshifted = obj.shift(0, freq=offset)
  233:         tm.assert_equal(unshifted, obj)
  234: 
  235:         d = obj.index[0]
  236:         shifted_d = d + offset * 5
  237:         if frame_or_series is DataFrame:
  238:             tm.assert_series_equal(obj.xs(d), shifted.xs(shifted_d), check_names=False)
  239:         else:
  240:             tm.assert_almost_equal(obj.at[d], shifted.at[shifted_d])
  241: 
  242:     def test_shift_with_periodindex(self, frame_or_series):
  243:         # Shifting with PeriodIndex
  244:         ps = DataFrame(
  245:             np.arange(4, dtype=float), index=pd.period_range("2020-01-01", periods=4)
  246:         )
  247:         ps = tm.get_obj(ps, frame_or_series)
  248: 
  249:         shifted = ps.shift(1)
  250:         unshifted = shifted.shift(-1)
  251:         tm.assert_index_equal(shifted.index, ps.index)
  252:         tm.assert_index_equal(unshifted.index, ps.index)
  253:         if frame_or_series is DataFrame:
  254:             tm.assert_numpy_array_equal(
  255:                 unshifted.iloc[:, 0].dropna().values, ps.iloc[:-1, 0].values
  256:             )
  257:         else:
  258:             tm.assert_numpy_array_equal(unshifted.dropna().values, ps.values[:-1])
  259: 
  260:         shifted2 = ps.shift(1, "D")
  261:         shifted3 = ps.shift(1, offsets.Day())
  262:         tm.assert_equal(shifted2, shifted3)
  263:         tm.assert_equal(ps, shifted2.shift(-1, "D"))
  264: 
  265:         msg = "does not match PeriodIndex freq"
  266:         with pytest.raises(ValueError, match=msg):
  267:             ps.shift(freq="W")
  268: 
  269:         # legacy support
  270:         shifted4 = ps.shift(1, freq="D")
  271:         tm.assert_equal(shifted2, shifted4)
  272: 
  273:         shifted5 = ps.shift(1, freq=offsets.Day())
  274:         tm.assert_equal(shifted5, shifted4)
  275: 
  276:     def test_shift_other_axis(self):
  277:         # shift other axis
  278:         # GH#6371
  279:         df = DataFrame(np.random.default_rng(2).random((10, 5)))
  280:         expected = pd.concat(
  281:             [DataFrame(np.nan, index=df.index, columns=[0]), df.iloc[:, 0:-1]],
  282:             ignore_index=True,
  283:             axis=1,
  284:         )
  285:         result = df.shift(1, axis=1)
  286:         tm.assert_frame_equal(result, expected)
  287: 
  288:     def test_shift_named_axis(self):
  289:         # shift named axis
  290:         df = DataFrame(np.random.default_rng(2).random((10, 5)))
  291:         expected = pd.concat(
  292:             [DataFrame(np.nan, index=df.index, columns=[0]), df.iloc[:, 0:-1]],
  293:             ignore_index=True,
  294:             axis=1,
  295:         )
  296:         result = df.shift(1, axis="columns")
  297:         tm.assert_frame_equal(result, expected)
  298: 
  299:     def test_shift_other_axis_with_freq(self, datetime_frame):
  300:         obj = datetime_frame.T
  301:         offset = offsets.BDay()
  302: 
  303:         # GH#47039
  304:         shifted = obj.shift(5, freq=offset, axis=1)
  305:         assert len(shifted) == len(obj)
  306:         unshifted = shifted.shift(-5, freq=offset, axis=1)
  307:         tm.assert_equal(unshifted, obj)
  308: 
  309:     def test_shift_bool(self):
  310:         df = DataFrame({"high": [True, False], "low": [False, False]})
  311:         rs = df.shift(1)
  312:         xp = DataFrame(
  313:             np.array([[np.nan, np.nan], [True, False]], dtype=object),
  314:             columns=["high", "low"],
  315:         )
  316:         tm.assert_frame_equal(rs, xp)
  317: 
  318:     def test_shift_categorical1(self, frame_or_series):
  319:         # GH#9416
  320:         obj = frame_or_series(["a", "b", "c", "d"], dtype="category")
  321: 
  322:         rt = obj.shift(1).shift(-1)
  323:         tm.assert_equal(obj.iloc[:-1], rt.dropna())
  324: 
  325:         def get_cat_values(ndframe):
  326:             # For Series we could just do ._values; for DataFrame
  327:             #  we may be able to do this if we ever have 2D Categoricals
  328:             return ndframe._mgr.arrays[0]
  329: 
  330:         cat = get_cat_values(obj)
  331: 
  332:         sp1 = obj.shift(1)
  333:         tm.assert_index_equal(obj.index, sp1.index)
  334:         assert np.all(get_cat_values(sp1).codes[:1] == -1)
  335:         assert np.all(cat.codes[:-1] == get_cat_values(sp1).codes[1:])
  336: 
  337:         sn2 = obj.shift(-2)
  338:         tm.assert_index_equal(obj.index, sn2.index)
  339:         assert np.all(get_cat_values(sn2).codes[-2:] == -1)
  340:         assert np.all(cat.codes[2:] == get_cat_values(sn2).codes[:-2])
  341: 
  342:         tm.assert_index_equal(cat.categories, get_cat_values(sp1).categories)
  343:         tm.assert_index_equal(cat.categories, get_cat_values(sn2).categories)
  344: 
  345:     def test_shift_categorical(self):
  346:         # GH#9416
  347:         s1 = Series(["a", "b", "c"], dtype="category")
  348:         s2 = Series(["A", "B", "C"], dtype="category")
  349:         df = DataFrame({"one": s1, "two": s2})
  350:         rs = df.shift(1)
  351:         xp = DataFrame({"one": s1.shift(1), "two": s2.shift(1)})
  352:         tm.assert_frame_equal(rs, xp)
  353: 
  354:     def test_shift_categorical_fill_value(self, frame_or_series):
  355:         ts = frame_or_series(["a", "b", "c", "d"], dtype="category")
  356:         res = ts.shift(1, fill_value="a")
  357:         expected = frame_or_series(
  358:             pd.Categorical(
  359:                 ["a", "a", "b", "c"], categories=["a", "b", "c", "d"], ordered=False
  360:             )
  361:         )
  362:         tm.assert_equal(res, expected)
  363: 
  364:         # check for incorrect fill_value
  365:         msg = r"Cannot setitem on a Categorical with a new category \(f\)"
  366:         with pytest.raises(TypeError, match=msg):
  367:             ts.shift(1, fill_value="f")
  368: 
  369:     def test_shift_fill_value(self, frame_or_series):
  370:         # GH#24128
  371:         dti = date_range("1/1/2000", periods=5, freq="h")
  372: 
  373:         ts = frame_or_series([1.0, 2.0, 3.0, 4.0, 5.0], index=dti)
  374:         exp = frame_or_series([0.0, 1.0, 2.0, 3.0, 4.0], index=dti)
  375:         # check that fill value works
  376:         result = ts.shift(1, fill_value=0.0)
  377:         tm.assert_equal(result, exp)
  378: 
  379:         exp = frame_or_series([0.0, 0.0, 1.0, 2.0, 3.0], index=dti)
  380:         result = ts.shift(2, fill_value=0.0)
  381:         tm.assert_equal(result, exp)
  382: 
  383:         ts = frame_or_series([1, 2, 3])
  384:         res = ts.shift(2, fill_value=0)
  385:         assert tm.get_dtype(res) == tm.get_dtype(ts)
  386: 
  387:         # retain integer dtype
  388:         obj = frame_or_series([1, 2, 3, 4, 5], index=dti)
  389:         exp = frame_or_series([0, 1, 2, 3, 4], index=dti)
  390:         result = obj.shift(1, fill_value=0)
  391:         tm.assert_equal(result, exp)
  392: 
  393:         exp = frame_or_series([0, 0, 1, 2, 3], index=dti)
  394:         result = obj.shift(2, fill_value=0)
  395:         tm.assert_equal(result, exp)
  396: 
  397:     def test_shift_empty(self):
  398:         # Regression test for GH#8019
  399:         df = DataFrame({"foo": []})
  400:         rs = df.shift(-1)
  401: 
  402:         tm.assert_frame_equal(df, rs)
  403: 
  404:     def test_shift_duplicate_columns(self):
  405:         # GH#9092; verify that position-based shifting works
  406:         # in the presence of duplicate columns
  407:         column_lists = [list(range(5)), [1] * 5, [1, 1, 2, 2, 1]]
  408:         data = np.random.default_rng(2).standard_normal((20, 5))
  409: 
  410:         shifted = []
  411:         for columns in column_lists:
  412:             df = DataFrame(data.copy(), columns=columns)
  413:             for s in range(5):
  414:                 df.iloc[:, s] = df.iloc[:, s].shift(s + 1)
  415:             df.columns = range(5)
  416:             shifted.append(df)
  417: 
  418:         # sanity check the base case
  419:         nulls = shifted[0].isna().sum()
  420:         tm.assert_series_equal(nulls, Series(range(1, 6), dtype="int64"))
  421: 
  422:         # check all answers are the same
  423:         tm.assert_frame_equal(shifted[0], shifted[1])
  424:         tm.assert_frame_equal(shifted[0], shifted[2])
  425: 
  426:     def test_shift_axis1_multiple_blocks(self, using_array_manager):
  427:         # GH#35488
  428:         df1 = DataFrame(np.random.default_rng(2).integers(1000, size=(5, 3)))
  429:         df2 = DataFrame(np.random.default_rng(2).integers(1000, size=(5, 2)))
  430:         df3 = pd.concat([df1, df2], axis=1)
  431:         if not using_array_manager:
  432:             assert len(df3._mgr.blocks) == 2
  433: 
  434:         result = df3.shift(2, axis=1)
  435: 
  436:         expected = df3.take([-1, -1, 0, 1, 2], axis=1)
  437:         # Explicit cast to float to avoid implicit cast when setting nan.
  438:         # Column names aren't unique, so directly calling `expected.astype` won't work.
  439:         expected = expected.pipe(
  440:             lambda df: df.set_axis(range(df.shape[1]), axis=1)
  441:             .astype({0: "float", 1: "float"})
  442:             .set_axis(df.columns, axis=1)
  443:         )
  444:         expected.iloc[:, :2] = np.nan
  445:         expected.columns = df3.columns
  446: 
  447:         tm.assert_frame_equal(result, expected)
  448: 
  449:         # Case with periods < 0
  450:         # rebuild df3 because `take` call above consolidated
  451:         df3 = pd.concat([df1, df2], axis=1)
  452:         if not using_array_manager:
  453:             assert len(df3._mgr.blocks) == 2
  454:         result = df3.shift(-2, axis=1)
  455: 
  456:         expected = df3.take([2, 3, 4, -1, -1], axis=1)
  457:         # Explicit cast to float to avoid implicit cast when setting nan.
  458:         # Column names aren't unique, so directly calling `expected.astype` won't work.
  459:         expected = expected.pipe(
  460:             lambda df: df.set_axis(range(df.shape[1]), axis=1)
  461:             .astype({3: "float", 4: "float"})
  462:             .set_axis(df.columns, axis=1)
  463:         )
  464:         expected.iloc[:, -2:] = np.nan
  465:         expected.columns = df3.columns
  466: 
  467:         tm.assert_frame_equal(result, expected)
  468: 
  469:     @td.skip_array_manager_not_yet_implemented  # TODO(ArrayManager) axis=1 support
  470:     def test_shift_axis1_multiple_blocks_with_int_fill(self):
  471:         # GH#42719
  472:         rng = np.random.default_rng(2)
  473:         df1 = DataFrame(rng.integers(1000, size=(5, 3), dtype=int))
  474:         df2 = DataFrame(rng.integers(1000, size=(5, 2), dtype=int))
  475:         df3 = pd.concat([df1.iloc[:4, 1:3], df2.iloc[:4, :]], axis=1)
  476:         result = df3.shift(2, axis=1, fill_value=np.int_(0))
  477:         assert len(df3._mgr.blocks) == 2
  478: 
  479:         expected = df3.take([-1, -1, 0, 1], axis=1)
  480:         expected.iloc[:, :2] = np.int_(0)
  481:         expected.columns = df3.columns
  482: 
  483:         tm.assert_frame_equal(result, expected)
  484: 
  485:         # Case with periods < 0
  486:         df3 = pd.concat([df1.iloc[:4, 1:3], df2.iloc[:4, :]], axis=1)
  487:         result = df3.shift(-2, axis=1, fill_value=np.int_(0))
  488:         assert len(df3._mgr.blocks) == 2
  489: 
  490:         expected = df3.take([2, 3, -1, -1], axis=1)
  491:         expected.iloc[:, -2:] = np.int_(0)
  492:         expected.columns = df3.columns
  493: 
  494:         tm.assert_frame_equal(result, expected)
  495: 
  496:     def test_period_index_frame_shift_with_freq(self, frame_or_series):
  497:         ps = DataFrame(range(4), index=pd.period_range("2020-01-01", periods=4))
  498:         ps = tm.get_obj(ps, frame_or_series)
  499: 
  500:         shifted = ps.shift(1, freq="infer")
  501:         unshifted = shifted.shift(-1, freq="infer")
  502:         tm.assert_equal(unshifted, ps)
  503: 
  504:         shifted2 = ps.shift(freq="D")
  505:         tm.assert_equal(shifted, shifted2)
  506: 
  507:         shifted3 = ps.shift(freq=offsets.Day())
  508:         tm.assert_equal(shifted, shifted3)
  509: 
  510:     def test_datetime_frame_shift_with_freq(self, datetime_frame, frame_or_series):
  511:         dtobj = tm.get_obj(datetime_frame, frame_or_series)
  512:         shifted = dtobj.shift(1, freq="infer")
  513:         unshifted = shifted.shift(-1, freq="infer")
  514:         tm.assert_equal(dtobj, unshifted)
  515: 
  516:         shifted2 = dtobj.shift(freq=dtobj.index.freq)
  517:         tm.assert_equal(shifted, shifted2)
  518: 
  519:         inferred_ts = DataFrame(
  520:             datetime_frame.values,
  521:             Index(np.asarray(datetime_frame.index)),
  522:             columns=datetime_frame.columns,
  523:         )
  524:         inferred_ts = tm.get_obj(inferred_ts, frame_or_series)
  525:         shifted = inferred_ts.shift(1, freq="infer")
  526:         expected = dtobj.shift(1, freq="infer")
  527:         expected.index = expected.index._with_freq(None)
  528:         tm.assert_equal(shifted, expected)
  529: 
  530:         unshifted = shifted.shift(-1, freq="infer")
  531:         tm.assert_equal(unshifted, inferred_ts)
  532: 
  533:     def test_period_index_frame_shift_with_freq_error(self, frame_or_series):
  534:         ps = DataFrame(range(4), index=pd.period_range("2020-01-01", periods=4))
  535:         ps = tm.get_obj(ps, frame_or_series)
  536:         msg = "Given freq M does not match PeriodIndex freq D"
  537:         with pytest.raises(ValueError, match=msg):
  538:             ps.shift(freq="M")
  539: 
  540:     def test_datetime_frame_shift_with_freq_error(
  541:         self, datetime_frame, frame_or_series
  542:     ):
  543:         dtobj = tm.get_obj(datetime_frame, frame_or_series)
  544:         no_freq = dtobj.iloc[[0, 5, 7]]
  545:         msg = "Freq was not set in the index hence cannot be inferred"
  546:         with pytest.raises(ValueError, match=msg):
  547:             no_freq.shift(freq="infer")
  548: 
  549:     def test_shift_dt64values_int_fill_deprecated(self):
  550:         # GH#31971
  551:         ser = Series([pd.Timestamp("2020-01-01"), pd.Timestamp("2020-01-02")])
  552: 
  553:         with pytest.raises(TypeError, match="value should be a"):
  554:             ser.shift(1, fill_value=0)
  555: 
  556:         df = ser.to_frame()
  557:         with pytest.raises(TypeError, match="value should be a"):
  558:             df.shift(1, fill_value=0)
  559: 
  560:         # axis = 1
  561:         df2 = DataFrame({"A": ser, "B": ser})
  562:         df2._consolidate_inplace()
  563: 
  564:         result = df2.shift(1, axis=1, fill_value=0)
  565:         expected = DataFrame({"A": [0, 0], "B": df2["A"]})
  566:         tm.assert_frame_equal(result, expected)
  567: 
  568:         # same thing but not consolidated; pre-2.0 we got different behavior
  569:         df3 = DataFrame({"A": ser})
  570:         df3["B"] = ser
  571:         assert len(df3._mgr.arrays) == 2
  572:         result = df3.shift(1, axis=1, fill_value=0)
  573:         tm.assert_frame_equal(result, expected)
  574: 
  575:     @pytest.mark.parametrize(
  576:         "as_cat",
  577:         [
  578:             pytest.param(
  579:                 True,
  580:                 marks=pytest.mark.xfail(
  581:                     reason="_can_hold_element incorrectly always returns True"
  582:                 ),
  583:             ),
  584:             False,
  585:         ],
  586:     )
  587:     @pytest.mark.parametrize(
  588:         "vals",
  589:         [
  590:             date_range("2020-01-01", periods=2),
  591:             date_range("2020-01-01", periods=2, tz="US/Pacific"),
  592:             pd.period_range("2020-01-01", periods=2, freq="D"),
  593:             pd.timedelta_range("2020 Days", periods=2, freq="D"),
  594:             pd.interval_range(0, 3, periods=2),
  595:             pytest.param(
  596:                 pd.array([1, 2], dtype="Int64"),
  597:                 marks=pytest.mark.xfail(
  598:                     reason="_can_hold_element incorrectly always returns True"
  599:                 ),
  600:             ),
  601:             pytest.param(
  602:                 pd.array([1, 2], dtype="Float32"),
  603:                 marks=pytest.mark.xfail(
  604:                     reason="_can_hold_element incorrectly always returns True"
  605:                 ),
  606:             ),
  607:         ],
  608:         ids=lambda x: str(x.dtype),
  609:     )
  610:     def test_shift_dt64values_axis1_invalid_fill(self, vals, as_cat):
  611:         # GH#44564
  612:         ser = Series(vals)
  613:         if as_cat:
  614:             ser = ser.astype("category")
  615: 
  616:         df = DataFrame({"A": ser})
  617:         result = df.shift(-1, axis=1, fill_value="foo")
  618:         expected = DataFrame({"A": ["foo", "foo"]})
  619:         tm.assert_frame_equal(result, expected)
  620: 
  621:         # same thing but multiple blocks
  622:         df2 = DataFrame({"A": ser, "B": ser})
  623:         df2._consolidate_inplace()
  624: 
  625:         result = df2.shift(-1, axis=1, fill_value="foo")
  626:         expected = DataFrame({"A": df2["B"], "B": ["foo", "foo"]})
  627:         tm.assert_frame_equal(result, expected)
  628: 
  629:         # same thing but not consolidated
  630:         df3 = DataFrame({"A": ser})
  631:         df3["B"] = ser
  632:         assert len(df3._mgr.arrays) == 2
  633:         result = df3.shift(-1, axis=1, fill_value="foo")
  634:         tm.assert_frame_equal(result, expected)
  635: 
  636:     def test_shift_axis1_categorical_columns(self):
  637:         # GH#38434
  638:         ci = CategoricalIndex(["a", "b", "c"])
  639:         df = DataFrame(
  640:             {"a": [1, 3], "b": [2, 4], "c": [5, 6]}, index=ci[:-1], columns=ci
  641:         )
  642:         result = df.shift(axis=1)
  643: 
  644:         expected = DataFrame(
  645:             {"a": [np.nan, np.nan], "b": [1, 3], "c": [2, 4]}, index=ci[:-1], columns=ci
  646:         )
  647:         tm.assert_frame_equal(result, expected)
  648: 
  649:         # periods != 1
  650:         result = df.shift(2, axis=1)
  651:         expected = DataFrame(
  652:             {"a": [np.nan, np.nan], "b": [np.nan, np.nan], "c": [1, 3]},
  653:             index=ci[:-1],
  654:             columns=ci,
  655:         )
  656:         tm.assert_frame_equal(result, expected)
  657: 
  658:     def test_shift_axis1_many_periods(self):
  659:         # GH#44978 periods > len(columns)
  660:         df = DataFrame(np.random.default_rng(2).random((5, 3)))
  661:         shifted = df.shift(6, axis=1, fill_value=None)
  662: 
  663:         expected = df * np.nan
  664:         tm.assert_frame_equal(shifted, expected)
  665: 
  666:         shifted2 = df.shift(-6, axis=1, fill_value=None)
  667:         tm.assert_frame_equal(shifted2, expected)
  668: 
  669:     def test_shift_with_offsets_freq(self):
  670:         df = DataFrame({"x": [1, 2, 3]}, index=date_range("2000", periods=3))
  671:         shifted = df.shift(freq="1MS")
  672:         expected = DataFrame(
  673:             {"x": [1, 2, 3]},
  674:             index=date_range(start="02/01/2000", end="02/01/2000", periods=3),
  675:         )
  676:         tm.assert_frame_equal(shifted, expected)
  677: 
  678:     def test_shift_with_iterable_basic_functionality(self):
  679:         # GH#44424
  680:         data = {"a": [1, 2, 3], "b": [4, 5, 6]}
  681:         shifts = [0, 1, 2]
  682: 
  683:         df = DataFrame(data)
  684:         shifted = df.shift(shifts)
  685: 
  686:         expected = DataFrame(
  687:             {
  688:                 "a_0": [1, 2, 3],
  689:                 "b_0": [4, 5, 6],
  690:                 "a_1": [np.nan, 1.0, 2.0],
  691:                 "b_1": [np.nan, 4.0, 5.0],
  692:                 "a_2": [np.nan, np.nan, 1.0],
  693:                 "b_2": [np.nan, np.nan, 4.0],
  694:             }
  695:         )
  696:         tm.assert_frame_equal(expected, shifted)
  697: 
  698:     def test_shift_with_iterable_series(self):
  699:         # GH#44424
  700:         data = {"a": [1, 2, 3]}
  701:         shifts = [0, 1, 2]
  702: 
  703:         df = DataFrame(data)
  704:         s = df["a"]
  705:         tm.assert_frame_equal(s.shift(shifts), df.shift(shifts))
  706: 
  707:     def test_shift_with_iterable_freq_and_fill_value(self):
  708:         # GH#44424
  709:         df = DataFrame(
  710:             np.random.default_rng(2).standard_normal(5),
  711:             index=date_range("1/1/2000", periods=5, freq="h"),
  712:         )
  713: 
  714:         tm.assert_frame_equal(
  715:             # rename because shift with an iterable leads to str column names
  716:             df.shift([1], fill_value=1).rename(columns=lambda x: int(x[0])),
  717:             df.shift(1, fill_value=1),
  718:         )
  719: 
  720:         tm.assert_frame_equal(
  721:             df.shift([1], freq="h").rename(columns=lambda x: int(x[0])),
  722:             df.shift(1, freq="h"),
  723:         )
  724: 
  725:         msg = (
  726:             "Passing a 'freq' together with a 'fill_value' silently ignores the "
  727:             "fill_value"
  728:         )
  729:         with tm.assert_produces_warning(FutureWarning, match=msg):
  730:             df.shift([1, 2], fill_value=1, freq="h")
  731: 
  732:     def test_shift_with_iterable_check_other_arguments(self):
  733:         # GH#44424
  734:         data = {"a": [1, 2], "b": [4, 5]}
  735:         shifts = [0, 1]
  736:         df = DataFrame(data)
  737: 
  738:         # test suffix
  739:         shifted = df[["a"]].shift(shifts, suffix="_suffix")
  740:         expected = DataFrame({"a_suffix_0": [1, 2], "a_suffix_1": [np.nan, 1.0]})
  741:         tm.assert_frame_equal(shifted, expected)
  742: 
  743:         # check bad inputs when doing multiple shifts
  744:         msg = "If `periods` contains multiple shifts, `axis` cannot be 1."
  745:         with pytest.raises(ValueError, match=msg):
  746:             df.shift(shifts, axis=1)
  747: 
  748:         msg = "Periods must be integer, but s is <class 'str'>."
  749:         with pytest.raises(TypeError, match=msg):
  750:             df.shift(["s"])
  751: 
  752:         msg = "If `periods` is an iterable, it cannot be empty."
  753:         with pytest.raises(ValueError, match=msg):
  754:             df.shift([])
  755: 
  756:         msg = "Cannot specify `suffix` if `periods` is an int."
  757:         with pytest.raises(ValueError, match=msg):
  758:             df.shift(1, suffix="fails")
  759: 
  760:     def test_shift_axis_one_empty(self):
  761:         # GH#57301
  762:         df = DataFrame()
  763:         result = df.shift(1, axis=1)
  764:         tm.assert_frame_equal(result, df)
