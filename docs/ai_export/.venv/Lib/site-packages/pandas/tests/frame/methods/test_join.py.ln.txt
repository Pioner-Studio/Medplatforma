    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.errors import MergeError
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     DataFrame,
   11:     Index,
   12:     MultiIndex,
   13:     date_range,
   14:     period_range,
   15: )
   16: import pandas._testing as tm
   17: from pandas.core.reshape.concat import concat
   18: 
   19: 
   20: @pytest.fixture
   21: def frame_with_period_index():
   22:     return DataFrame(
   23:         data=np.arange(20).reshape(4, 5),
   24:         columns=list("abcde"),
   25:         index=period_range(start="2000", freq="Y", periods=4),
   26:     )
   27: 
   28: 
   29: @pytest.fixture
   30: def left():
   31:     return DataFrame({"a": [20, 10, 0]}, index=[2, 1, 0])
   32: 
   33: 
   34: @pytest.fixture
   35: def right():
   36:     return DataFrame({"b": [300, 100, 200]}, index=[3, 1, 2])
   37: 
   38: 
   39: @pytest.fixture
   40: def left_no_dup():
   41:     return DataFrame(
   42:         {"a": ["a", "b", "c", "d"], "b": ["cat", "dog", "weasel", "horse"]},
   43:         index=range(4),
   44:     )
   45: 
   46: 
   47: @pytest.fixture
   48: def right_no_dup():
   49:     return DataFrame(
   50:         {
   51:             "a": ["a", "b", "c", "d", "e"],
   52:             "c": ["meow", "bark", "um... weasel noise?", "nay", "chirp"],
   53:         },
   54:         index=range(5),
   55:     ).set_index("a")
   56: 
   57: 
   58: @pytest.fixture
   59: def left_w_dups(left_no_dup):
   60:     return concat(
   61:         [left_no_dup, DataFrame({"a": ["a"], "b": ["cow"]}, index=[3])], sort=True
   62:     )
   63: 
   64: 
   65: @pytest.fixture
   66: def right_w_dups(right_no_dup):
   67:     return concat(
   68:         [right_no_dup, DataFrame({"a": ["e"], "c": ["moo"]}, index=[3])]
   69:     ).set_index("a")
   70: 
   71: 
   72: @pytest.mark.parametrize(
   73:     "how, sort, expected",
   74:     [
   75:         ("inner", False, DataFrame({"a": [20, 10], "b": [200, 100]}, index=[2, 1])),
   76:         ("inner", True, DataFrame({"a": [10, 20], "b": [100, 200]}, index=[1, 2])),
   77:         (
   78:             "left",
   79:             False,
   80:             DataFrame({"a": [20, 10, 0], "b": [200, 100, np.nan]}, index=[2, 1, 0]),
   81:         ),
   82:         (
   83:             "left",
   84:             True,
   85:             DataFrame({"a": [0, 10, 20], "b": [np.nan, 100, 200]}, index=[0, 1, 2]),
   86:         ),
   87:         (
   88:             "right",
   89:             False,
   90:             DataFrame({"a": [np.nan, 10, 20], "b": [300, 100, 200]}, index=[3, 1, 2]),
   91:         ),
   92:         (
   93:             "right",
   94:             True,
   95:             DataFrame({"a": [10, 20, np.nan], "b": [100, 200, 300]}, index=[1, 2, 3]),
   96:         ),
   97:         (
   98:             "outer",
   99:             False,
  100:             DataFrame(
  101:                 {"a": [0, 10, 20, np.nan], "b": [np.nan, 100, 200, 300]},
  102:                 index=[0, 1, 2, 3],
  103:             ),
  104:         ),
  105:         (
  106:             "outer",
  107:             True,
  108:             DataFrame(
  109:                 {"a": [0, 10, 20, np.nan], "b": [np.nan, 100, 200, 300]},
  110:                 index=[0, 1, 2, 3],
  111:             ),
  112:         ),
  113:     ],
  114: )
  115: def test_join(left, right, how, sort, expected):
  116:     result = left.join(right, how=how, sort=sort, validate="1:1")
  117:     tm.assert_frame_equal(result, expected)
  118: 
  119: 
  120: def test_suffix_on_list_join():
  121:     first = DataFrame({"key": [1, 2, 3, 4, 5]})
  122:     second = DataFrame({"key": [1, 8, 3, 2, 5], "v1": [1, 2, 3, 4, 5]})
  123:     third = DataFrame({"keys": [5, 2, 3, 4, 1], "v2": [1, 2, 3, 4, 5]})
  124: 
  125:     # check proper errors are raised
  126:     msg = "Suffixes not supported when joining multiple DataFrames"
  127:     with pytest.raises(ValueError, match=msg):
  128:         first.join([second], lsuffix="y")
  129:     with pytest.raises(ValueError, match=msg):
  130:         first.join([second, third], rsuffix="x")
  131:     with pytest.raises(ValueError, match=msg):
  132:         first.join([second, third], lsuffix="y", rsuffix="x")
  133:     with pytest.raises(ValueError, match="Indexes have overlapping values"):
  134:         first.join([second, third])
  135: 
  136:     # no errors should be raised
  137:     arr_joined = first.join([third])
  138:     norm_joined = first.join(third)
  139:     tm.assert_frame_equal(arr_joined, norm_joined)
  140: 
  141: 
  142: def test_join_invalid_validate(left_no_dup, right_no_dup):
  143:     # GH 46622
  144:     # Check invalid arguments
  145:     msg = (
  146:         '"invalid" is not a valid argument. '
  147:         "Valid arguments are:\n"
  148:         '- "1:1"\n'
  149:         '- "1:m"\n'
  150:         '- "m:1"\n'
  151:         '- "m:m"\n'
  152:         '- "one_to_one"\n'
  153:         '- "one_to_many"\n'
  154:         '- "many_to_one"\n'
  155:         '- "many_to_many"'
  156:     )
  157:     with pytest.raises(ValueError, match=msg):
  158:         left_no_dup.merge(right_no_dup, on="a", validate="invalid")
  159: 
  160: 
  161: @pytest.mark.parametrize("dtype", ["object", "string[pyarrow]"])
  162: def test_join_on_single_col_dup_on_right(left_no_dup, right_w_dups, dtype):
  163:     # GH 46622
  164:     # Dups on right allowed by one_to_many constraint
  165:     if dtype == "string[pyarrow]":
  166:         pytest.importorskip("pyarrow")
  167:     left_no_dup = left_no_dup.astype(dtype)
  168:     right_w_dups.index = right_w_dups.index.astype(dtype)
  169:     left_no_dup.join(
  170:         right_w_dups,
  171:         on="a",
  172:         validate="one_to_many",
  173:     )
  174: 
  175:     # Dups on right not allowed by one_to_one constraint
  176:     msg = "Merge keys are not unique in right dataset; not a one-to-one merge"
  177:     with pytest.raises(MergeError, match=msg):
  178:         left_no_dup.join(
  179:             right_w_dups,
  180:             on="a",
  181:             validate="one_to_one",
  182:         )
  183: 
  184: 
  185: def test_join_on_single_col_dup_on_left(left_w_dups, right_no_dup):
  186:     # GH 46622
  187:     # Dups on left allowed by many_to_one constraint
  188:     left_w_dups.join(
  189:         right_no_dup,
  190:         on="a",
  191:         validate="many_to_one",
  192:     )
  193: 
  194:     # Dups on left not allowed by one_to_one constraint
  195:     msg = "Merge keys are not unique in left dataset; not a one-to-one merge"
  196:     with pytest.raises(MergeError, match=msg):
  197:         left_w_dups.join(
  198:             right_no_dup,
  199:             on="a",
  200:             validate="one_to_one",
  201:         )
  202: 
  203: 
  204: def test_join_on_single_col_dup_on_both(left_w_dups, right_w_dups):
  205:     # GH 46622
  206:     # Dups on both allowed by many_to_many constraint
  207:     left_w_dups.join(right_w_dups, on="a", validate="many_to_many")
  208: 
  209:     # Dups on both not allowed by many_to_one constraint
  210:     msg = "Merge keys are not unique in right dataset; not a many-to-one merge"
  211:     with pytest.raises(MergeError, match=msg):
  212:         left_w_dups.join(
  213:             right_w_dups,
  214:             on="a",
  215:             validate="many_to_one",
  216:         )
  217: 
  218:     # Dups on both not allowed by one_to_many constraint
  219:     msg = "Merge keys are not unique in left dataset; not a one-to-many merge"
  220:     with pytest.raises(MergeError, match=msg):
  221:         left_w_dups.join(
  222:             right_w_dups,
  223:             on="a",
  224:             validate="one_to_many",
  225:         )
  226: 
  227: 
  228: def test_join_on_multi_col_check_dup():
  229:     # GH 46622
  230:     # Two column join, dups in both, but jointly no dups
  231:     left = DataFrame(
  232:         {
  233:             "a": ["a", "a", "b", "b"],
  234:             "b": [0, 1, 0, 1],
  235:             "c": ["cat", "dog", "weasel", "horse"],
  236:         },
  237:         index=range(4),
  238:     ).set_index(["a", "b"])
  239: 
  240:     right = DataFrame(
  241:         {
  242:             "a": ["a", "a", "b"],
  243:             "b": [0, 1, 0],
  244:             "d": ["meow", "bark", "um... weasel noise?"],
  245:         },
  246:         index=range(3),
  247:     ).set_index(["a", "b"])
  248: 
  249:     expected_multi = DataFrame(
  250:         {
  251:             "a": ["a", "a", "b"],
  252:             "b": [0, 1, 0],
  253:             "c": ["cat", "dog", "weasel"],
  254:             "d": ["meow", "bark", "um... weasel noise?"],
  255:         },
  256:         index=range(3),
  257:     ).set_index(["a", "b"])
  258: 
  259:     # Jointly no dups allowed by one_to_one constraint
  260:     result = left.join(right, how="inner", validate="1:1")
  261:     tm.assert_frame_equal(result, expected_multi)
  262: 
  263: 
  264: def test_join_index(float_frame):
  265:     # left / right
  266: 
  267:     f = float_frame.loc[float_frame.index[:10], ["A", "B"]]
  268:     f2 = float_frame.loc[float_frame.index[5:], ["C", "D"]].iloc[::-1]
  269: 
  270:     joined = f.join(f2)
  271:     tm.assert_index_equal(f.index, joined.index)
  272:     expected_columns = Index(["A", "B", "C", "D"])
  273:     tm.assert_index_equal(joined.columns, expected_columns)
  274: 
  275:     joined = f.join(f2, how="left")
  276:     tm.assert_index_equal(joined.index, f.index)
  277:     tm.assert_index_equal(joined.columns, expected_columns)
  278: 
  279:     joined = f.join(f2, how="right")
  280:     tm.assert_index_equal(joined.index, f2.index)
  281:     tm.assert_index_equal(joined.columns, expected_columns)
  282: 
  283:     # inner
  284: 
  285:     joined = f.join(f2, how="inner")
  286:     tm.assert_index_equal(joined.index, f.index[5:10])
  287:     tm.assert_index_equal(joined.columns, expected_columns)
  288: 
  289:     # outer
  290: 
  291:     joined = f.join(f2, how="outer")
  292:     tm.assert_index_equal(joined.index, float_frame.index.sort_values())
  293:     tm.assert_index_equal(joined.columns, expected_columns)
  294: 
  295:     with pytest.raises(ValueError, match="join method"):
  296:         f.join(f2, how="foo")
  297: 
  298:     # corner case - overlapping columns
  299:     msg = "columns overlap but no suffix"
  300:     for how in ("outer", "left", "inner"):
  301:         with pytest.raises(ValueError, match=msg):
  302:             float_frame.join(float_frame, how=how)
  303: 
  304: 
  305: def test_join_index_more(float_frame):
  306:     af = float_frame.loc[:, ["A", "B"]]
  307:     bf = float_frame.loc[::2, ["C", "D"]]
  308: 
  309:     expected = af.copy()
  310:     expected["C"] = float_frame["C"][::2]
  311:     expected["D"] = float_frame["D"][::2]
  312: 
  313:     result = af.join(bf)
  314:     tm.assert_frame_equal(result, expected)
  315: 
  316:     result = af.join(bf, how="right")
  317:     tm.assert_frame_equal(result, expected[::2])
  318: 
  319:     result = bf.join(af, how="right")
  320:     tm.assert_frame_equal(result, expected.loc[:, result.columns])
  321: 
  322: 
  323: def test_join_index_series(float_frame):
  324:     df = float_frame.copy()
  325:     ser = df.pop(float_frame.columns[-1])
  326:     joined = df.join(ser)
  327: 
  328:     tm.assert_frame_equal(joined, float_frame)
  329: 
  330:     ser.name = None
  331:     with pytest.raises(ValueError, match="must have a name"):
  332:         df.join(ser)
  333: 
  334: 
  335: def test_join_overlap(float_frame):
  336:     df1 = float_frame.loc[:, ["A", "B", "C"]]
  337:     df2 = float_frame.loc[:, ["B", "C", "D"]]
  338: 
  339:     joined = df1.join(df2, lsuffix="_df1", rsuffix="_df2")
  340:     df1_suf = df1.loc[:, ["B", "C"]].add_suffix("_df1")
  341:     df2_suf = df2.loc[:, ["B", "C"]].add_suffix("_df2")
  342: 
  343:     no_overlap = float_frame.loc[:, ["A", "D"]]
  344:     expected = df1_suf.join(df2_suf).join(no_overlap)
  345: 
  346:     # column order not necessarily sorted
  347:     tm.assert_frame_equal(joined, expected.loc[:, joined.columns])
  348: 
  349: 
  350: def test_join_period_index(frame_with_period_index):
  351:     other = frame_with_period_index.rename(columns=lambda key: f"{key}{key}")
  352: 
  353:     joined_values = np.concatenate([frame_with_period_index.values] * 2, axis=1)
  354: 
  355:     joined_cols = frame_with_period_index.columns.append(other.columns)
  356: 
  357:     joined = frame_with_period_index.join(other)
  358:     expected = DataFrame(
  359:         data=joined_values, columns=joined_cols, index=frame_with_period_index.index
  360:     )
  361: 
  362:     tm.assert_frame_equal(joined, expected)
  363: 
  364: 
  365: def test_join_left_sequence_non_unique_index():
  366:     # https://github.com/pandas-dev/pandas/issues/19607
  367:     df1 = DataFrame({"a": [0, 10, 20]}, index=[1, 2, 3])
  368:     df2 = DataFrame({"b": [100, 200, 300]}, index=[4, 3, 2])
  369:     df3 = DataFrame({"c": [400, 500, 600]}, index=[2, 2, 4])
  370: 
  371:     joined = df1.join([df2, df3], how="left")
  372: 
  373:     expected = DataFrame(
  374:         {
  375:             "a": [0, 10, 10, 20],
  376:             "b": [np.nan, 300, 300, 200],
  377:             "c": [np.nan, 400, 500, np.nan],
  378:         },
  379:         index=[1, 2, 2, 3],
  380:     )
  381: 
  382:     tm.assert_frame_equal(joined, expected)
  383: 
  384: 
  385: def test_join_list_series(float_frame):
  386:     # GH#46850
  387:     # Join a DataFrame with a list containing both a Series and a DataFrame
  388:     left = float_frame.A.to_frame()
  389:     right = [float_frame.B, float_frame[["C", "D"]]]
  390:     result = left.join(right)
  391:     tm.assert_frame_equal(result, float_frame)
  392: 
  393: 
  394: @pytest.mark.parametrize("sort_kw", [True, False])
  395: def test_suppress_future_warning_with_sort_kw(sort_kw):
  396:     a = DataFrame({"col1": [1, 2]}, index=["c", "a"])
  397: 
  398:     b = DataFrame({"col2": [4, 5]}, index=["b", "a"])
  399: 
  400:     c = DataFrame({"col3": [7, 8]}, index=["a", "b"])
  401: 
  402:     expected = DataFrame(
  403:         {
  404:             "col1": {"a": 2.0, "b": float("nan"), "c": 1.0},
  405:             "col2": {"a": 5.0, "b": 4.0, "c": float("nan")},
  406:             "col3": {"a": 7.0, "b": 8.0, "c": float("nan")},
  407:         }
  408:     )
  409:     if sort_kw is False:
  410:         expected = expected.reindex(index=["c", "a", "b"])
  411: 
  412:     with tm.assert_produces_warning(None):
  413:         result = a.join([b, c], how="outer", sort=sort_kw)
  414:     tm.assert_frame_equal(result, expected)
  415: 
  416: 
  417: class TestDataFrameJoin:
  418:     def test_join(self, multiindex_dataframe_random_data):
  419:         frame = multiindex_dataframe_random_data
  420: 
  421:         a = frame.loc[frame.index[:5], ["A"]]
  422:         b = frame.loc[frame.index[2:], ["B", "C"]]
  423: 
  424:         joined = a.join(b, how="outer").reindex(frame.index)
  425:         expected = frame.copy().values.copy()
  426:         expected[np.isnan(joined.values)] = np.nan
  427:         expected = DataFrame(expected, index=frame.index, columns=frame.columns)
  428: 
  429:         assert not np.isnan(joined.values).all()
  430: 
  431:         tm.assert_frame_equal(joined, expected)
  432: 
  433:     def test_join_segfault(self):
  434:         # GH#1532
  435:         df1 = DataFrame({"a": [1, 1], "b": [1, 2], "x": [1, 2]})
  436:         df2 = DataFrame({"a": [2, 2], "b": [1, 2], "y": [1, 2]})
  437:         df1 = df1.set_index(["a", "b"])
  438:         df2 = df2.set_index(["a", "b"])
  439:         # it works!
  440:         for how in ["left", "right", "outer"]:
  441:             df1.join(df2, how=how)
  442: 
  443:     def test_join_str_datetime(self):
  444:         str_dates = ["20120209", "20120222"]
  445:         dt_dates = [datetime(2012, 2, 9), datetime(2012, 2, 22)]
  446: 
  447:         A = DataFrame(str_dates, index=range(2), columns=["aa"])
  448:         C = DataFrame([[1, 2], [3, 4]], index=str_dates, columns=dt_dates)
  449: 
  450:         tst = A.join(C, on="aa")
  451: 
  452:         assert len(tst.columns) == 3
  453: 
  454:     def test_join_multiindex_leftright(self):
  455:         # GH 10741
  456:         df1 = DataFrame(
  457:             [
  458:                 ["a", "x", 0.471780],
  459:                 ["a", "y", 0.774908],
  460:                 ["a", "z", 0.563634],
  461:                 ["b", "x", -0.353756],
  462:                 ["b", "y", 0.368062],
  463:                 ["b", "z", -1.721840],
  464:                 ["c", "x", 1],
  465:                 ["c", "y", 2],
  466:                 ["c", "z", 3],
  467:             ],
  468:             columns=["first", "second", "value1"],
  469:         ).set_index(["first", "second"])
  470: 
  471:         df2 = DataFrame([["a", 10], ["b", 20]], columns=["first", "value2"]).set_index(
  472:             ["first"]
  473:         )
  474: 
  475:         exp = DataFrame(
  476:             [
  477:                 [0.471780, 10],
  478:                 [0.774908, 10],
  479:                 [0.563634, 10],
  480:                 [-0.353756, 20],
  481:                 [0.368062, 20],
  482:                 [-1.721840, 20],
  483:                 [1.000000, np.nan],
  484:                 [2.000000, np.nan],
  485:                 [3.000000, np.nan],
  486:             ],
  487:             index=df1.index,
  488:             columns=["value1", "value2"],
  489:         )
  490: 
  491:         # these must be the same results (but columns are flipped)
  492:         tm.assert_frame_equal(df1.join(df2, how="left"), exp)
  493:         tm.assert_frame_equal(df2.join(df1, how="right"), exp[["value2", "value1"]])
  494: 
  495:         exp_idx = MultiIndex.from_product(
  496:             [["a", "b"], ["x", "y", "z"]], names=["first", "second"]
  497:         )
  498:         exp = DataFrame(
  499:             [
  500:                 [0.471780, 10],
  501:                 [0.774908, 10],
  502:                 [0.563634, 10],
  503:                 [-0.353756, 20],
  504:                 [0.368062, 20],
  505:                 [-1.721840, 20],
  506:             ],
  507:             index=exp_idx,
  508:             columns=["value1", "value2"],
  509:         )
  510: 
  511:         tm.assert_frame_equal(df1.join(df2, how="right"), exp)
  512:         tm.assert_frame_equal(df2.join(df1, how="left"), exp[["value2", "value1"]])
  513: 
  514:     def test_join_multiindex_dates(self):
  515:         # GH 33692
  516:         date = pd.Timestamp(2000, 1, 1).date()
  517: 
  518:         df1_index = MultiIndex.from_tuples([(0, date)], names=["index_0", "date"])
  519:         df1 = DataFrame({"col1": [0]}, index=df1_index)
  520:         df2_index = MultiIndex.from_tuples([(0, date)], names=["index_0", "date"])
  521:         df2 = DataFrame({"col2": [0]}, index=df2_index)
  522:         df3_index = MultiIndex.from_tuples([(0, date)], names=["index_0", "date"])
  523:         df3 = DataFrame({"col3": [0]}, index=df3_index)
  524: 
  525:         result = df1.join([df2, df3])
  526: 
  527:         expected_index = MultiIndex.from_tuples([(0, date)], names=["index_0", "date"])
  528:         expected = DataFrame(
  529:             {"col1": [0], "col2": [0], "col3": [0]}, index=expected_index
  530:         )
  531: 
  532:         tm.assert_equal(result, expected)
  533: 
  534:     def test_merge_join_different_levels_raises(self):
  535:         # GH#9455
  536:         # GH 40993: For raising, enforced in 2.0
  537: 
  538:         # first dataframe
  539:         df1 = DataFrame(columns=["a", "b"], data=[[1, 11], [0, 22]])
  540: 
  541:         # second dataframe
  542:         columns = MultiIndex.from_tuples([("a", ""), ("c", "c1")])
  543:         df2 = DataFrame(columns=columns, data=[[1, 33], [0, 44]])
  544: 
  545:         # merge
  546:         with pytest.raises(
  547:             MergeError, match="Not allowed to merge between different levels"
  548:         ):
  549:             pd.merge(df1, df2, on="a")
  550: 
  551:         # join, see discussion in GH#12219
  552:         with pytest.raises(
  553:             MergeError, match="Not allowed to merge between different levels"
  554:         ):
  555:             df1.join(df2, on="a")
  556: 
  557:     def test_frame_join_tzaware(self):
  558:         test1 = DataFrame(
  559:             np.zeros((6, 3)),
  560:             index=date_range(
  561:                 "2012-11-15 00:00:00", periods=6, freq="100ms", tz="US/Central"
  562:             ),
  563:         )
  564:         test2 = DataFrame(
  565:             np.zeros((3, 3)),
  566:             index=date_range(
  567:                 "2012-11-15 00:00:00", periods=3, freq="250ms", tz="US/Central"
  568:             ),
  569:             columns=range(3, 6),
  570:         )
  571: 
  572:         result = test1.join(test2, how="outer")
  573:         expected = test1.index.union(test2.index)
  574: 
  575:         tm.assert_index_equal(result.index, expected)
  576:         assert result.index.tz.zone == "US/Central"
