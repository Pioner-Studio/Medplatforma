    1: from datetime import datetime
    2: 
    3: from hypothesis import given
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas.core.dtypes.common import is_scalar
    8: 
    9: import pandas as pd
   10: from pandas import (
   11:     DataFrame,
   12:     DatetimeIndex,
   13:     Index,
   14:     Series,
   15:     StringDtype,
   16:     Timestamp,
   17:     date_range,
   18:     isna,
   19: )
   20: import pandas._testing as tm
   21: from pandas._testing._hypothesis import OPTIONAL_ONE_OF_ALL
   22: 
   23: 
   24: @pytest.fixture(params=["default", "float_string", "mixed_float", "mixed_int"])
   25: def where_frame(request, float_string_frame, mixed_float_frame, mixed_int_frame):
   26:     if request.param == "default":
   27:         return DataFrame(
   28:             np.random.default_rng(2).standard_normal((5, 3)), columns=["A", "B", "C"]
   29:         )
   30:     if request.param == "float_string":
   31:         return float_string_frame
   32:     if request.param == "mixed_float":
   33:         return mixed_float_frame
   34:     if request.param == "mixed_int":
   35:         return mixed_int_frame
   36: 
   37: 
   38: def _safe_add(df):
   39:     # only add to the numeric items
   40:     def is_ok(s):
   41:         return (
   42:             issubclass(s.dtype.type, (np.integer, np.floating)) and s.dtype != "uint8"
   43:         )
   44: 
   45:     return DataFrame(dict((c, s + 1) if is_ok(s) else (c, s) for c, s in df.items()))
   46: 
   47: 
   48: class TestDataFrameIndexingWhere:
   49:     def test_where_get(self, where_frame, float_string_frame):
   50:         def _check_get(df, cond, check_dtypes=True):
   51:             other1 = _safe_add(df)
   52:             rs = df.where(cond, other1)
   53:             rs2 = df.where(cond.values, other1)
   54:             for k, v in rs.items():
   55:                 exp = Series(np.where(cond[k], df[k], other1[k]), index=v.index)
   56:                 tm.assert_series_equal(v, exp, check_names=False)
   57:             tm.assert_frame_equal(rs, rs2)
   58: 
   59:             # dtypes
   60:             if check_dtypes:
   61:                 assert (rs.dtypes == df.dtypes).all()
   62: 
   63:         # check getting
   64:         df = where_frame
   65:         if df is float_string_frame:
   66:             msg = "'>' not supported between instances of 'str' and 'int'"
   67:             with pytest.raises(TypeError, match=msg):
   68:                 df > 0
   69:             return
   70:         cond = df > 0
   71:         _check_get(df, cond)
   72: 
   73:     def test_where_upcasting(self):
   74:         # upcasting case (GH # 2794)
   75:         df = DataFrame(
   76:             {
   77:                 c: Series([1] * 3, dtype=c)
   78:                 for c in ["float32", "float64", "int32", "int64"]
   79:             }
   80:         )
   81:         df.iloc[1, :] = 0
   82:         result = df.dtypes
   83:         expected = Series(
   84:             [
   85:                 np.dtype("float32"),
   86:                 np.dtype("float64"),
   87:                 np.dtype("int32"),
   88:                 np.dtype("int64"),
   89:             ],
   90:             index=["float32", "float64", "int32", "int64"],
   91:         )
   92: 
   93:         # when we don't preserve boolean casts
   94:         #
   95:         # expected = Series({ 'float32' : 1, 'float64' : 3 })
   96: 
   97:         tm.assert_series_equal(result, expected)
   98: 
   99:     @pytest.mark.filterwarnings("ignore:Downcasting object dtype arrays:FutureWarning")
  100:     def test_where_alignment(self, where_frame, float_string_frame):
  101:         # aligning
  102:         def _check_align(df, cond, other, check_dtypes=True):
  103:             rs = df.where(cond, other)
  104:             for i, k in enumerate(rs.columns):
  105:                 result = rs[k]
  106:                 d = df[k].values
  107:                 c = cond[k].reindex(df[k].index).fillna(False).values
  108: 
  109:                 if is_scalar(other):
  110:                     o = other
  111:                 elif isinstance(other, np.ndarray):
  112:                     o = Series(other[:, i], index=result.index).values
  113:                 else:
  114:                     o = other[k].values
  115: 
  116:                 new_values = d if c.all() else np.where(c, d, o)
  117:                 expected = Series(new_values, index=result.index, name=k)
  118: 
  119:                 # since we can't always have the correct numpy dtype
  120:                 # as numpy doesn't know how to downcast, don't check
  121:                 tm.assert_series_equal(result, expected, check_dtype=False)
  122: 
  123:             # dtypes
  124:             # can't check dtype when other is an ndarray
  125: 
  126:             if check_dtypes and not isinstance(other, np.ndarray):
  127:                 assert (rs.dtypes == df.dtypes).all()
  128: 
  129:         df = where_frame
  130:         if df is float_string_frame:
  131:             msg = "'>' not supported between instances of 'str' and 'int'"
  132:             with pytest.raises(TypeError, match=msg):
  133:                 df > 0
  134:             return
  135: 
  136:         # other is a frame
  137:         cond = (df > 0)[1:]
  138:         _check_align(df, cond, _safe_add(df))
  139: 
  140:         # check other is ndarray
  141:         cond = df > 0
  142:         _check_align(df, cond, (_safe_add(df).values))
  143: 
  144:         # integers are upcast, so don't check the dtypes
  145:         cond = df > 0
  146:         check_dtypes = all(not issubclass(s.type, np.integer) for s in df.dtypes)
  147:         _check_align(df, cond, np.nan, check_dtypes=check_dtypes)
  148: 
  149:     # Ignore deprecation warning in Python 3.12 for inverting a bool
  150:     @pytest.mark.filterwarnings("ignore::DeprecationWarning")
  151:     def test_where_invalid(self):
  152:         # invalid conditions
  153:         df = DataFrame(
  154:             np.random.default_rng(2).standard_normal((5, 3)), columns=["A", "B", "C"]
  155:         )
  156:         cond = df > 0
  157: 
  158:         err1 = (df + 1).values[0:2, :]
  159:         msg = "other must be the same shape as self when an ndarray"
  160:         with pytest.raises(ValueError, match=msg):
  161:             df.where(cond, err1)
  162: 
  163:         err2 = cond.iloc[:2, :].values
  164:         other1 = _safe_add(df)
  165:         msg = "Array conditional must be same shape as self"
  166:         with pytest.raises(ValueError, match=msg):
  167:             df.where(err2, other1)
  168: 
  169:         with pytest.raises(ValueError, match=msg):
  170:             df.mask(True)
  171:         with pytest.raises(ValueError, match=msg):
  172:             df.mask(0)
  173: 
  174:     @pytest.mark.filterwarnings("ignore:Downcasting object dtype arrays:FutureWarning")
  175:     def test_where_set(self, where_frame, float_string_frame, mixed_int_frame):
  176:         # where inplace
  177: 
  178:         def _check_set(df, cond, check_dtypes=True):
  179:             dfi = df.copy()
  180:             econd = cond.reindex_like(df).fillna(True).infer_objects(copy=False)
  181:             expected = dfi.mask(~econd)
  182: 
  183:             return_value = dfi.where(cond, np.nan, inplace=True)
  184:             assert return_value is None
  185:             tm.assert_frame_equal(dfi, expected)
  186: 
  187:             # dtypes (and confirm upcasts)x
  188:             if check_dtypes:
  189:                 for k, v in df.dtypes.items():
  190:                     if issubclass(v.type, np.integer) and not cond[k].all():
  191:                         v = np.dtype("float64")
  192:                     assert dfi[k].dtype == v
  193: 
  194:         df = where_frame
  195:         if df is float_string_frame:
  196:             msg = "'>' not supported between instances of 'str' and 'int'"
  197:             with pytest.raises(TypeError, match=msg):
  198:                 df > 0
  199:             return
  200:         if df is mixed_int_frame:
  201:             df = df.astype("float64")
  202: 
  203:         cond = df > 0
  204:         _check_set(df, cond)
  205: 
  206:         cond = df >= 0
  207:         _check_set(df, cond)
  208: 
  209:         # aligning
  210:         cond = (df >= 0)[1:]
  211:         _check_set(df, cond)
  212: 
  213:     def test_where_series_slicing(self):
  214:         # GH 10218
  215:         # test DataFrame.where with Series slicing
  216:         df = DataFrame({"a": range(3), "b": range(4, 7)})
  217:         result = df.where(df["a"] == 1)
  218:         expected = df[df["a"] == 1].reindex(df.index)
  219:         tm.assert_frame_equal(result, expected)
  220: 
  221:     @pytest.mark.parametrize("klass", [list, tuple, np.array])
  222:     def test_where_array_like(self, klass):
  223:         # see gh-15414
  224:         df = DataFrame({"a": [1, 2, 3]})
  225:         cond = [[False], [True], [True]]
  226:         expected = DataFrame({"a": [np.nan, 2, 3]})
  227: 
  228:         result = df.where(klass(cond))
  229:         tm.assert_frame_equal(result, expected)
  230: 
  231:         df["b"] = 2
  232:         expected["b"] = [2, np.nan, 2]
  233:         cond = [[False, True], [True, False], [True, True]]
  234: 
  235:         result = df.where(klass(cond))
  236:         tm.assert_frame_equal(result, expected)
  237: 
  238:     @pytest.mark.parametrize(
  239:         "cond",
  240:         [
  241:             [[1], [0], [1]],
  242:             Series([[2], [5], [7]]),
  243:             DataFrame({"a": [2, 5, 7]}),
  244:             [["True"], ["False"], ["True"]],
  245:             [[Timestamp("2017-01-01")], [pd.NaT], [Timestamp("2017-01-02")]],
  246:         ],
  247:     )
  248:     def test_where_invalid_input_single(self, cond):
  249:         # see gh-15414: only boolean arrays accepted
  250:         df = DataFrame({"a": [1, 2, 3]})
  251:         msg = "Boolean array expected for the condition"
  252: 
  253:         with pytest.raises(ValueError, match=msg):
  254:             df.where(cond)
  255: 
  256:     @pytest.mark.parametrize(
  257:         "cond",
  258:         [
  259:             [[0, 1], [1, 0], [1, 1]],
  260:             Series([[0, 2], [5, 0], [4, 7]]),
  261:             [["False", "True"], ["True", "False"], ["True", "True"]],
  262:             DataFrame({"a": [2, 5, 7], "b": [4, 8, 9]}),
  263:             [
  264:                 [pd.NaT, Timestamp("2017-01-01")],
  265:                 [Timestamp("2017-01-02"), pd.NaT],
  266:                 [Timestamp("2017-01-03"), Timestamp("2017-01-03")],
  267:             ],
  268:         ],
  269:     )
  270:     def test_where_invalid_input_multiple(self, cond):
  271:         # see gh-15414: only boolean arrays accepted
  272:         df = DataFrame({"a": [1, 2, 3], "b": [2, 2, 2]})
  273:         msg = "Boolean array expected for the condition"
  274: 
  275:         with pytest.raises(ValueError, match=msg):
  276:             df.where(cond)
  277: 
  278:     def test_where_dataframe_col_match(self):
  279:         df = DataFrame([[1, 2, 3], [4, 5, 6]])
  280:         cond = DataFrame([[True, False, True], [False, False, True]])
  281: 
  282:         result = df.where(cond)
  283:         expected = DataFrame([[1.0, np.nan, 3], [np.nan, np.nan, 6]])
  284:         tm.assert_frame_equal(result, expected)
  285: 
  286:         # this *does* align, though has no matching columns
  287:         cond.columns = ["a", "b", "c"]
  288:         result = df.where(cond)
  289:         expected = DataFrame(np.nan, index=df.index, columns=df.columns)
  290:         tm.assert_frame_equal(result, expected)
  291: 
  292:     def test_where_ndframe_align(self):
  293:         msg = "Array conditional must be same shape as self"
  294:         df = DataFrame([[1, 2, 3], [4, 5, 6]])
  295: 
  296:         cond = [True]
  297:         with pytest.raises(ValueError, match=msg):
  298:             df.where(cond)
  299: 
  300:         expected = DataFrame([[1, 2, 3], [np.nan, np.nan, np.nan]])
  301: 
  302:         out = df.where(Series(cond))
  303:         tm.assert_frame_equal(out, expected)
  304: 
  305:         cond = np.array([False, True, False, True])
  306:         with pytest.raises(ValueError, match=msg):
  307:             df.where(cond)
  308: 
  309:         expected = DataFrame([[np.nan, np.nan, np.nan], [4, 5, 6]])
  310: 
  311:         out = df.where(Series(cond))
  312:         tm.assert_frame_equal(out, expected)
  313: 
  314:     def test_where_bug(self):
  315:         # see gh-2793
  316:         df = DataFrame(
  317:             {"a": [1.0, 2.0, 3.0, 4.0], "b": [4.0, 3.0, 2.0, 1.0]}, dtype="float64"
  318:         )
  319:         expected = DataFrame(
  320:             {"a": [np.nan, np.nan, 3.0, 4.0], "b": [4.0, 3.0, np.nan, np.nan]},
  321:             dtype="float64",
  322:         )
  323:         result = df.where(df > 2, np.nan)
  324:         tm.assert_frame_equal(result, expected)
  325: 
  326:         result = df.copy()
  327:         return_value = result.where(result > 2, np.nan, inplace=True)
  328:         assert return_value is None
  329:         tm.assert_frame_equal(result, expected)
  330: 
  331:     def test_where_bug_mixed(self, any_signed_int_numpy_dtype):
  332:         # see gh-2793
  333:         df = DataFrame(
  334:             {
  335:                 "a": np.array([1, 2, 3, 4], dtype=any_signed_int_numpy_dtype),
  336:                 "b": np.array([4.0, 3.0, 2.0, 1.0], dtype="float64"),
  337:             }
  338:         )
  339: 
  340:         expected = DataFrame(
  341:             {"a": [-1, -1, 3, 4], "b": [4.0, 3.0, -1, -1]},
  342:         ).astype({"a": any_signed_int_numpy_dtype, "b": "float64"})
  343: 
  344:         result = df.where(df > 2, -1)
  345:         tm.assert_frame_equal(result, expected)
  346: 
  347:         result = df.copy()
  348:         return_value = result.where(result > 2, -1, inplace=True)
  349:         assert return_value is None
  350:         tm.assert_frame_equal(result, expected)
  351: 
  352:     def test_where_bug_transposition(self):
  353:         # see gh-7506
  354:         a = DataFrame({0: [1, 2], 1: [3, 4], 2: [5, 6]})
  355:         b = DataFrame({0: [np.nan, 8], 1: [9, np.nan], 2: [np.nan, np.nan]})
  356:         do_not_replace = b.isna() | (a > b)
  357: 
  358:         expected = a.copy()
  359:         expected[~do_not_replace] = b
  360: 
  361:         msg = "Downcasting behavior in Series and DataFrame methods 'where'"
  362:         with tm.assert_produces_warning(FutureWarning, match=msg):
  363:             result = a.where(do_not_replace, b)
  364:         tm.assert_frame_equal(result, expected)
  365: 
  366:         a = DataFrame({0: [4, 6], 1: [1, 0]})
  367:         b = DataFrame({0: [np.nan, 3], 1: [3, np.nan]})
  368:         do_not_replace = b.isna() | (a > b)
  369: 
  370:         expected = a.copy()
  371:         expected[~do_not_replace] = b
  372: 
  373:         with tm.assert_produces_warning(FutureWarning, match=msg):
  374:             result = a.where(do_not_replace, b)
  375:         tm.assert_frame_equal(result, expected)
  376: 
  377:     def test_where_datetime(self):
  378:         # GH 3311
  379:         df = DataFrame(
  380:             {
  381:                 "A": date_range("20130102", periods=5),
  382:                 "B": date_range("20130104", periods=5),
  383:                 "C": np.random.default_rng(2).standard_normal(5),
  384:             }
  385:         )
  386: 
  387:         stamp = datetime(2013, 1, 3)
  388:         msg = "'>' not supported between instances of 'float' and 'datetime.datetime'"
  389:         with pytest.raises(TypeError, match=msg):
  390:             df > stamp
  391: 
  392:         result = df[df.iloc[:, :-1] > stamp]
  393: 
  394:         expected = df.copy()
  395:         expected.loc[[0, 1], "A"] = np.nan
  396: 
  397:         expected.loc[:, "C"] = np.nan
  398:         tm.assert_frame_equal(result, expected)
  399: 
  400:     def test_where_none(self):
  401:         # GH 4667
  402:         # setting with None changes dtype
  403:         df = DataFrame({"series": Series(range(10))}).astype(float)
  404:         df[df > 7] = None
  405:         expected = DataFrame(
  406:             {"series": Series([0, 1, 2, 3, 4, 5, 6, 7, np.nan, np.nan])}
  407:         )
  408:         tm.assert_frame_equal(df, expected)
  409: 
  410:         # GH 7656
  411:         df = DataFrame(
  412:             [
  413:                 {"A": 1, "B": np.nan, "C": "Test"},
  414:                 {"A": np.nan, "B": "Test", "C": np.nan},
  415:             ]
  416:         )
  417: 
  418:         orig = df.copy()
  419: 
  420:         mask = ~isna(df)
  421:         df.where(mask, None, inplace=True)
  422:         expected = DataFrame(
  423:             {
  424:                 "A": [1.0, np.nan],
  425:                 "B": [None, "Test"],
  426:                 "C": ["Test", None],
  427:             }
  428:         )
  429:         tm.assert_frame_equal(df, expected)
  430: 
  431:         df = orig.copy()
  432:         df[~mask] = None
  433:         tm.assert_frame_equal(df, expected)
  434: 
  435:     def test_where_empty_df_and_empty_cond_having_non_bool_dtypes(self):
  436:         # see gh-21947
  437:         df = DataFrame(columns=["a"])
  438:         cond = df
  439:         assert (cond.dtypes == object).all()
  440: 
  441:         result = df.where(cond)
  442:         tm.assert_frame_equal(result, df)
  443: 
  444:     def test_where_align(self):
  445:         def create():
  446:             df = DataFrame(np.random.default_rng(2).standard_normal((10, 3)))
  447:             df.iloc[3:5, 0] = np.nan
  448:             df.iloc[4:6, 1] = np.nan
  449:             df.iloc[5:8, 2] = np.nan
  450:             return df
  451: 
  452:         # series
  453:         df = create()
  454:         expected = df.fillna(df.mean())
  455:         result = df.where(pd.notna(df), df.mean(), axis="columns")
  456:         tm.assert_frame_equal(result, expected)
  457: 
  458:         return_value = df.where(pd.notna(df), df.mean(), inplace=True, axis="columns")
  459:         assert return_value is None
  460:         tm.assert_frame_equal(df, expected)
  461: 
  462:         df = create().fillna(0)
  463:         expected = df.apply(lambda x, y: x.where(x > 0, y), y=df[0])
  464:         result = df.where(df > 0, df[0], axis="index")
  465:         tm.assert_frame_equal(result, expected)
  466:         result = df.where(df > 0, df[0], axis="rows")
  467:         tm.assert_frame_equal(result, expected)
  468: 
  469:         # frame
  470:         df = create()
  471:         expected = df.fillna(1)
  472:         result = df.where(
  473:             pd.notna(df), DataFrame(1, index=df.index, columns=df.columns)
  474:         )
  475:         tm.assert_frame_equal(result, expected)
  476: 
  477:     def test_where_complex(self):
  478:         # GH 6345
  479:         expected = DataFrame([[1 + 1j, 2], [np.nan, 4 + 1j]], columns=["a", "b"])
  480:         df = DataFrame([[1 + 1j, 2], [5 + 1j, 4 + 1j]], columns=["a", "b"])
  481:         df[df.abs() >= 5] = np.nan
  482:         tm.assert_frame_equal(df, expected)
  483: 
  484:     def test_where_axis(self):
  485:         # GH 9736
  486:         df = DataFrame(np.random.default_rng(2).standard_normal((2, 2)))
  487:         mask = DataFrame([[False, False], [False, False]])
  488:         ser = Series([0, 1])
  489: 
  490:         expected = DataFrame([[0, 0], [1, 1]], dtype="float64")
  491:         result = df.where(mask, ser, axis="index")
  492:         tm.assert_frame_equal(result, expected)
  493: 
  494:         result = df.copy()
  495:         return_value = result.where(mask, ser, axis="index", inplace=True)
  496:         assert return_value is None
  497:         tm.assert_frame_equal(result, expected)
  498: 
  499:         expected = DataFrame([[0, 1], [0, 1]], dtype="float64")
  500:         result = df.where(mask, ser, axis="columns")
  501:         tm.assert_frame_equal(result, expected)
  502: 
  503:         result = df.copy()
  504:         return_value = result.where(mask, ser, axis="columns", inplace=True)
  505:         assert return_value is None
  506:         tm.assert_frame_equal(result, expected)
  507: 
  508:     def test_where_axis_with_upcast(self):
  509:         # Upcast needed
  510:         df = DataFrame([[1, 2], [3, 4]], dtype="int64")
  511:         mask = DataFrame([[False, False], [False, False]])
  512:         ser = Series([0, np.nan])
  513: 
  514:         expected = DataFrame([[0, 0], [np.nan, np.nan]], dtype="float64")
  515:         result = df.where(mask, ser, axis="index")
  516:         tm.assert_frame_equal(result, expected)
  517: 
  518:         result = df.copy()
  519:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  520:             return_value = result.where(mask, ser, axis="index", inplace=True)
  521:         assert return_value is None
  522:         tm.assert_frame_equal(result, expected)
  523: 
  524:         expected = DataFrame([[0, np.nan], [0, np.nan]])
  525:         result = df.where(mask, ser, axis="columns")
  526:         tm.assert_frame_equal(result, expected)
  527: 
  528:         expected = DataFrame(
  529:             {
  530:                 0: np.array([0, 0], dtype="int64"),
  531:                 1: np.array([np.nan, np.nan], dtype="float64"),
  532:             }
  533:         )
  534:         result = df.copy()
  535:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  536:             return_value = result.where(mask, ser, axis="columns", inplace=True)
  537:         assert return_value is None
  538:         tm.assert_frame_equal(result, expected)
  539: 
  540:     def test_where_axis_multiple_dtypes(self):
  541:         # Multiple dtypes (=> multiple Blocks)
  542:         df = pd.concat(
  543:             [
  544:                 DataFrame(np.random.default_rng(2).standard_normal((10, 2))),
  545:                 DataFrame(
  546:                     np.random.default_rng(2).integers(0, 10, size=(10, 2)),
  547:                     dtype="int64",
  548:                 ),
  549:             ],
  550:             ignore_index=True,
  551:             axis=1,
  552:         )
  553:         mask = DataFrame(False, columns=df.columns, index=df.index)
  554:         s1 = Series(1, index=df.columns)
  555:         s2 = Series(2, index=df.index)
  556: 
  557:         result = df.where(mask, s1, axis="columns")
  558:         expected = DataFrame(1.0, columns=df.columns, index=df.index)
  559:         expected[2] = expected[2].astype("int64")
  560:         expected[3] = expected[3].astype("int64")
  561:         tm.assert_frame_equal(result, expected)
  562: 
  563:         result = df.copy()
  564:         return_value = result.where(mask, s1, axis="columns", inplace=True)
  565:         assert return_value is None
  566:         tm.assert_frame_equal(result, expected)
  567: 
  568:         result = df.where(mask, s2, axis="index")
  569:         expected = DataFrame(2.0, columns=df.columns, index=df.index)
  570:         expected[2] = expected[2].astype("int64")
  571:         expected[3] = expected[3].astype("int64")
  572:         tm.assert_frame_equal(result, expected)
  573: 
  574:         result = df.copy()
  575:         return_value = result.where(mask, s2, axis="index", inplace=True)
  576:         assert return_value is None
  577:         tm.assert_frame_equal(result, expected)
  578: 
  579:         # DataFrame vs DataFrame
  580:         d1 = df.copy().drop(1, axis=0)
  581:         # Explicit cast to avoid implicit cast when setting value to np.nan
  582:         expected = df.copy().astype("float")
  583:         expected.loc[1, :] = np.nan
  584: 
  585:         result = df.where(mask, d1)
  586:         tm.assert_frame_equal(result, expected)
  587:         result = df.where(mask, d1, axis="index")
  588:         tm.assert_frame_equal(result, expected)
  589:         result = df.copy()
  590:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  591:             return_value = result.where(mask, d1, inplace=True)
  592:         assert return_value is None
  593:         tm.assert_frame_equal(result, expected)
  594:         result = df.copy()
  595:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  596:             return_value = result.where(mask, d1, inplace=True, axis="index")
  597:         assert return_value is None
  598:         tm.assert_frame_equal(result, expected)
  599: 
  600:         d2 = df.copy().drop(1, axis=1)
  601:         expected = df.copy()
  602:         expected.loc[:, 1] = np.nan
  603: 
  604:         result = df.where(mask, d2)
  605:         tm.assert_frame_equal(result, expected)
  606:         result = df.where(mask, d2, axis="columns")
  607:         tm.assert_frame_equal(result, expected)
  608:         result = df.copy()
  609:         return_value = result.where(mask, d2, inplace=True)
  610:         assert return_value is None
  611:         tm.assert_frame_equal(result, expected)
  612:         result = df.copy()
  613:         return_value = result.where(mask, d2, inplace=True, axis="columns")
  614:         assert return_value is None
  615:         tm.assert_frame_equal(result, expected)
  616: 
  617:     def test_where_callable(self):
  618:         # GH 12533
  619:         df = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
  620:         result = df.where(lambda x: x > 4, lambda x: x + 1)
  621:         exp = DataFrame([[2, 3, 4], [5, 5, 6], [7, 8, 9]])
  622:         tm.assert_frame_equal(result, exp)
  623:         tm.assert_frame_equal(result, df.where(df > 4, df + 1))
  624: 
  625:         # return ndarray and scalar
  626:         result = df.where(lambda x: (x % 2 == 0).values, lambda x: 99)
  627:         exp = DataFrame([[99, 2, 99], [4, 99, 6], [99, 8, 99]])
  628:         tm.assert_frame_equal(result, exp)
  629:         tm.assert_frame_equal(result, df.where(df % 2 == 0, 99))
  630: 
  631:         # chain
  632:         result = (df + 2).where(lambda x: x > 8, lambda x: x + 10)
  633:         exp = DataFrame([[13, 14, 15], [16, 17, 18], [9, 10, 11]])
  634:         tm.assert_frame_equal(result, exp)
  635:         tm.assert_frame_equal(result, (df + 2).where((df + 2) > 8, (df + 2) + 10))
  636: 
  637:     def test_where_tz_values(self, tz_naive_fixture, frame_or_series):
  638:         obj1 = DataFrame(
  639:             DatetimeIndex(["20150101", "20150102", "20150103"], tz=tz_naive_fixture),
  640:             columns=["date"],
  641:         )
  642:         obj2 = DataFrame(
  643:             DatetimeIndex(["20150103", "20150104", "20150105"], tz=tz_naive_fixture),
  644:             columns=["date"],
  645:         )
  646:         mask = DataFrame([True, True, False], columns=["date"])
  647:         exp = DataFrame(
  648:             DatetimeIndex(["20150101", "20150102", "20150105"], tz=tz_naive_fixture),
  649:             columns=["date"],
  650:         )
  651:         if frame_or_series is Series:
  652:             obj1 = obj1["date"]
  653:             obj2 = obj2["date"]
  654:             mask = mask["date"]
  655:             exp = exp["date"]
  656: 
  657:         result = obj1.where(mask, obj2)
  658:         tm.assert_equal(exp, result)
  659: 
  660:     def test_df_where_change_dtype(self):
  661:         # GH#16979
  662:         df = DataFrame(np.arange(2 * 3).reshape(2, 3), columns=list("ABC"))
  663:         mask = np.array([[True, False, False], [False, False, True]])
  664: 
  665:         result = df.where(mask)
  666:         expected = DataFrame(
  667:             [[0, np.nan, np.nan], [np.nan, np.nan, 5]], columns=list("ABC")
  668:         )
  669: 
  670:         tm.assert_frame_equal(result, expected)
  671: 
  672:     @pytest.mark.parametrize("kwargs", [{}, {"other": None}])
  673:     def test_df_where_with_category(self, kwargs):
  674:         # GH#16979
  675:         data = np.arange(2 * 3, dtype=np.int64).reshape(2, 3)
  676:         df = DataFrame(data, columns=list("ABC"))
  677:         mask = np.array([[True, False, False], [False, False, True]])
  678: 
  679:         # change type to category
  680:         df.A = df.A.astype("category")
  681:         df.B = df.B.astype("category")
  682:         df.C = df.C.astype("category")
  683: 
  684:         result = df.where(mask, **kwargs)
  685:         A = pd.Categorical([0, np.nan], categories=[0, 3])
  686:         B = pd.Categorical([np.nan, np.nan], categories=[1, 4])
  687:         C = pd.Categorical([np.nan, 5], categories=[2, 5])
  688:         expected = DataFrame({"A": A, "B": B, "C": C})
  689: 
  690:         tm.assert_frame_equal(result, expected)
  691: 
  692:         # Check Series.where while we're here
  693:         result = df.A.where(mask[:, 0], **kwargs)
  694:         expected = Series(A, name="A")
  695: 
  696:         tm.assert_series_equal(result, expected)
  697: 
  698:     def test_where_categorical_filtering(self):
  699:         # GH#22609 Verify filtering operations on DataFrames with categorical Series
  700:         df = DataFrame(data=[[0, 0], [1, 1]], columns=["a", "b"])
  701:         df["b"] = df["b"].astype("category")
  702: 
  703:         result = df.where(df["a"] > 0)
  704:         # Explicitly cast to 'float' to avoid implicit cast when setting np.nan
  705:         expected = df.copy().astype({"a": "float"})
  706:         expected.loc[0, :] = np.nan
  707: 
  708:         tm.assert_equal(result, expected)
  709: 
  710:     def test_where_ea_other(self):
  711:         # GH#38729/GH#38742
  712:         df = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
  713:         arr = pd.array([7, pd.NA, 9])
  714:         ser = Series(arr)
  715:         mask = np.ones(df.shape, dtype=bool)
  716:         mask[1, :] = False
  717: 
  718:         # TODO: ideally we would get Int64 instead of object
  719:         result = df.where(mask, ser, axis=0)
  720:         expected = DataFrame({"A": [1, np.nan, 3], "B": [4, np.nan, 6]})
  721:         tm.assert_frame_equal(result, expected)
  722: 
  723:         ser2 = Series(arr[:2], index=["A", "B"])
  724:         expected = DataFrame({"A": [1, 7, 3], "B": [4, np.nan, 6]})
  725:         result = df.where(mask, ser2, axis=1)
  726:         tm.assert_frame_equal(result, expected)
  727: 
  728:     def test_where_interval_noop(self):
  729:         # GH#44181
  730:         df = DataFrame([pd.Interval(0, 0)])
  731:         res = df.where(df.notna())
  732:         tm.assert_frame_equal(res, df)
  733: 
  734:         ser = df[0]
  735:         res = ser.where(ser.notna())
  736:         tm.assert_series_equal(res, ser)
  737: 
  738:     def test_where_interval_fullop_downcast(self, frame_or_series):
  739:         # GH#45768
  740:         obj = frame_or_series([pd.Interval(0, 0)] * 2)
  741:         other = frame_or_series([1.0, 2.0])
  742: 
  743:         msg = "Downcasting behavior in Series and DataFrame methods 'where'"
  744:         with tm.assert_produces_warning(FutureWarning, match=msg):
  745:             res = obj.where(~obj.notna(), other)
  746: 
  747:         # since all entries are being changed, we will downcast result
  748:         #  from object to ints (not floats)
  749:         tm.assert_equal(res, other.astype(np.int64))
  750: 
  751:         # unlike where, Block.putmask does not downcast
  752:         with tm.assert_produces_warning(
  753:             FutureWarning, match="Setting an item of incompatible dtype"
  754:         ):
  755:             obj.mask(obj.notna(), other, inplace=True)
  756:         tm.assert_equal(obj, other.astype(object))
  757: 
  758:     @pytest.mark.parametrize(
  759:         "dtype",
  760:         [
  761:             "timedelta64[ns]",
  762:             "datetime64[ns]",
  763:             "datetime64[ns, Asia/Tokyo]",
  764:             "Period[D]",
  765:         ],
  766:     )
  767:     def test_where_datetimelike_noop(self, dtype):
  768:         # GH#45135, analogue to GH#44181 for Period don't raise on no-op
  769:         # For td64/dt64/dt64tz we already don't raise, but also are
  770:         #  checking that we don't unnecessarily upcast to object.
  771:         with tm.assert_produces_warning(FutureWarning, match="is deprecated"):
  772:             ser = Series(np.arange(3) * 10**9, dtype=np.int64).view(dtype)
  773:         df = ser.to_frame()
  774:         mask = np.array([False, False, False])
  775: 
  776:         res = ser.where(~mask, "foo")
  777:         tm.assert_series_equal(res, ser)
  778: 
  779:         mask2 = mask.reshape(-1, 1)
  780:         res2 = df.where(~mask2, "foo")
  781:         tm.assert_frame_equal(res2, df)
  782: 
  783:         res3 = ser.mask(mask, "foo")
  784:         tm.assert_series_equal(res3, ser)
  785: 
  786:         res4 = df.mask(mask2, "foo")
  787:         tm.assert_frame_equal(res4, df)
  788: 
  789:         # opposite case where we are replacing *all* values -> we downcast
  790:         #  from object dtype # GH#45768
  791:         msg = "Downcasting behavior in Series and DataFrame methods 'where'"
  792:         with tm.assert_produces_warning(FutureWarning, match=msg):
  793:             res5 = df.where(mask2, 4)
  794:         expected = DataFrame(4, index=df.index, columns=df.columns)
  795:         tm.assert_frame_equal(res5, expected)
  796: 
  797:         # unlike where, Block.putmask does not downcast
  798:         with tm.assert_produces_warning(
  799:             FutureWarning, match="Setting an item of incompatible dtype"
  800:         ):
  801:             df.mask(~mask2, 4, inplace=True)
  802:         tm.assert_frame_equal(df, expected.astype(object))
  803: 
  804: 
  805: def test_where_int_downcasting_deprecated():
  806:     # GH#44597
  807:     arr = np.arange(6).astype(np.int16).reshape(3, 2)
  808:     df = DataFrame(arr)
  809: 
  810:     mask = np.zeros(arr.shape, dtype=bool)
  811:     mask[:, 0] = True
  812: 
  813:     res = df.where(mask, 2**17)
  814: 
  815:     expected = DataFrame({0: arr[:, 0], 1: np.array([2**17] * 3, dtype=np.int32)})
  816:     tm.assert_frame_equal(res, expected)
  817: 
  818: 
  819: def test_where_copies_with_noop(frame_or_series):
  820:     # GH-39595
  821:     result = frame_or_series([1, 2, 3, 4])
  822:     expected = result.copy()
  823:     col = result[0] if frame_or_series is DataFrame else result
  824: 
  825:     where_res = result.where(col < 5)
  826:     where_res *= 2
  827: 
  828:     tm.assert_equal(result, expected)
  829: 
  830:     where_res = result.where(col > 5, [1, 2, 3, 4])
  831:     where_res *= 2
  832: 
  833:     tm.assert_equal(result, expected)
  834: 
  835: 
  836: def test_where_string_dtype(frame_or_series):
  837:     # GH40824
  838:     obj = frame_or_series(
  839:         ["a", "b", "c", "d"], index=["id1", "id2", "id3", "id4"], dtype=StringDtype()
  840:     )
  841:     filtered_obj = frame_or_series(
  842:         ["b", "c"], index=["id2", "id3"], dtype=StringDtype()
  843:     )
  844:     filter_ser = Series([False, True, True, False])
  845: 
  846:     result = obj.where(filter_ser, filtered_obj)
  847:     expected = frame_or_series(
  848:         [pd.NA, "b", "c", pd.NA],
  849:         index=["id1", "id2", "id3", "id4"],
  850:         dtype=StringDtype(),
  851:     )
  852:     tm.assert_equal(result, expected)
  853: 
  854:     result = obj.mask(~filter_ser, filtered_obj)
  855:     tm.assert_equal(result, expected)
  856: 
  857:     obj.mask(~filter_ser, filtered_obj, inplace=True)
  858:     tm.assert_equal(result, expected)
  859: 
  860: 
  861: def test_where_bool_comparison():
  862:     # GH 10336
  863:     df_mask = DataFrame(
  864:         {"AAA": [True] * 4, "BBB": [False] * 4, "CCC": [True, False, True, False]}
  865:     )
  866:     result = df_mask.where(df_mask == False)  # noqa: E712
  867:     expected = DataFrame(
  868:         {
  869:             "AAA": np.array([np.nan] * 4, dtype=object),
  870:             "BBB": [False] * 4,
  871:             "CCC": [np.nan, False, np.nan, False],
  872:         }
  873:     )
  874:     tm.assert_frame_equal(result, expected)
  875: 
  876: 
  877: def test_where_none_nan_coerce():
  878:     # GH 15613
  879:     expected = DataFrame(
  880:         {
  881:             "A": [Timestamp("20130101"), pd.NaT, Timestamp("20130103")],
  882:             "B": [1, 2, np.nan],
  883:         }
  884:     )
  885:     result = expected.where(expected.notnull(), None)
  886:     tm.assert_frame_equal(result, expected)
  887: 
  888: 
  889: def test_where_duplicate_axes_mixed_dtypes():
  890:     # GH 25399, verify manually masking is not affected anymore by dtype of column for
  891:     # duplicate axes.
  892:     result = DataFrame(data=[[0, np.nan]], columns=Index(["A", "A"]))
  893:     index, columns = result.axes
  894:     mask = DataFrame(data=[[True, True]], columns=columns, index=index)
  895:     a = result.astype(object).where(mask)
  896:     b = result.astype("f8").where(mask)
  897:     c = result.T.where(mask.T).T
  898:     d = result.where(mask)  # used to fail with "cannot reindex from a duplicate axis"
  899:     tm.assert_frame_equal(a.astype("f8"), b.astype("f8"))
  900:     tm.assert_frame_equal(b.astype("f8"), c.astype("f8"))
  901:     tm.assert_frame_equal(c.astype("f8"), d.astype("f8"))
  902: 
  903: 
  904: def test_where_columns_casting():
  905:     # GH 42295
  906: 
  907:     df = DataFrame({"a": [1.0, 2.0], "b": [3, np.nan]})
  908:     expected = df.copy()
  909:     result = df.where(pd.notnull(df), None)
  910:     # make sure dtypes don't change
  911:     tm.assert_frame_equal(expected, result)
  912: 
  913: 
  914: @pytest.mark.parametrize("as_cat", [True, False])
  915: def test_where_period_invalid_na(frame_or_series, as_cat, request):
  916:     # GH#44697
  917:     idx = pd.period_range("2016-01-01", periods=3, freq="D")
  918:     if as_cat:
  919:         idx = idx.astype("category")
  920:     obj = frame_or_series(idx)
  921: 
  922:     # NA value that we should *not* cast to Period dtype
  923:     tdnat = pd.NaT.to_numpy("m8[ns]")
  924: 
  925:     mask = np.array([True, True, False], ndmin=obj.ndim).T
  926: 
  927:     if as_cat:
  928:         msg = (
  929:             r"Cannot setitem on a Categorical with a new category \(NaT\), "
  930:             "set the categories first"
  931:         )
  932:     else:
  933:         msg = "value should be a 'Period'"
  934: 
  935:     if as_cat:
  936:         with pytest.raises(TypeError, match=msg):
  937:             obj.where(mask, tdnat)
  938: 
  939:         with pytest.raises(TypeError, match=msg):
  940:             obj.mask(mask, tdnat)
  941: 
  942:         with pytest.raises(TypeError, match=msg):
  943:             obj.mask(mask, tdnat, inplace=True)
  944: 
  945:     else:
  946:         # With PeriodDtype, ser[i] = tdnat coerces instead of raising,
  947:         #  so for consistency, ser[mask] = tdnat must as well
  948:         expected = obj.astype(object).where(mask, tdnat)
  949:         result = obj.where(mask, tdnat)
  950:         tm.assert_equal(result, expected)
  951: 
  952:         expected = obj.astype(object).mask(mask, tdnat)
  953:         result = obj.mask(mask, tdnat)
  954:         tm.assert_equal(result, expected)
  955: 
  956:         with tm.assert_produces_warning(
  957:             FutureWarning, match="Setting an item of incompatible dtype"
  958:         ):
  959:             obj.mask(mask, tdnat, inplace=True)
  960:         tm.assert_equal(obj, expected)
  961: 
  962: 
  963: def test_where_nullable_invalid_na(frame_or_series, any_numeric_ea_dtype):
  964:     # GH#44697
  965:     arr = pd.array([1, 2, 3], dtype=any_numeric_ea_dtype)
  966:     obj = frame_or_series(arr)
  967: 
  968:     mask = np.array([True, True, False], ndmin=obj.ndim).T
  969: 
  970:     msg = r"Invalid value '.*' for dtype (U?Int|Float)\d{1,2}"
  971: 
  972:     for null in tm.NP_NAT_OBJECTS + [pd.NaT]:
  973:         # NaT is an NA value that we should *not* cast to pd.NA dtype
  974:         with pytest.raises(TypeError, match=msg):
  975:             obj.where(mask, null)
  976: 
  977:         with pytest.raises(TypeError, match=msg):
  978:             obj.mask(mask, null)
  979: 
  980: 
  981: @given(data=OPTIONAL_ONE_OF_ALL)
  982: def test_where_inplace_casting(data):
  983:     # GH 22051
  984:     df = DataFrame({"a": data})
  985:     df_copy = df.where(pd.notnull(df), None).copy()
  986:     df.where(pd.notnull(df), None, inplace=True)
  987:     tm.assert_equal(df, df_copy)
  988: 
  989: 
  990: def test_where_downcast_to_td64():
  991:     ser = Series([1, 2, 3])
  992: 
  993:     mask = np.array([False, False, False])
  994: 
  995:     td = pd.Timedelta(days=1)
  996: 
  997:     msg = "Downcasting behavior in Series and DataFrame methods 'where'"
  998:     with tm.assert_produces_warning(FutureWarning, match=msg):
  999:         res = ser.where(mask, td)
 1000:     expected = Series([td, td, td], dtype="m8[ns]")
 1001:     tm.assert_series_equal(res, expected)
 1002: 
 1003:     with pd.option_context("future.no_silent_downcasting", True):
 1004:         with tm.assert_produces_warning(None, match=msg):
 1005:             res2 = ser.where(mask, td)
 1006:     expected2 = expected.astype(object)
 1007:     tm.assert_series_equal(res2, expected2)
 1008: 
 1009: 
 1010: def _check_where_equivalences(df, mask, other, expected):
 1011:     # similar to tests.series.indexing.test_setitem.SetitemCastingEquivalences
 1012:     #  but with DataFrame in mind and less fleshed-out
 1013:     res = df.where(mask, other)
 1014:     tm.assert_frame_equal(res, expected)
 1015: 
 1016:     res = df.mask(~mask, other)
 1017:     tm.assert_frame_equal(res, expected)
 1018: 
 1019:     # Note: frame.mask(~mask, other, inplace=True) takes some more work bc
 1020:     #  Block.putmask does *not* downcast.  The change to 'expected' here
 1021:     #  is specific to the cases in test_where_dt64_2d.
 1022:     df = df.copy()
 1023:     df.mask(~mask, other, inplace=True)
 1024:     if not mask.all():
 1025:         # with mask.all(), Block.putmask is a no-op, so does not downcast
 1026:         expected = expected.copy()
 1027:         expected["A"] = expected["A"].astype(object)
 1028:     tm.assert_frame_equal(df, expected)
 1029: 
 1030: 
 1031: def test_where_dt64_2d():
 1032:     dti = date_range("2016-01-01", periods=6)
 1033:     dta = dti._data.reshape(3, 2)
 1034:     other = dta - dta[0, 0]
 1035: 
 1036:     df = DataFrame(dta, columns=["A", "B"])
 1037: 
 1038:     mask = np.asarray(df.isna()).copy()
 1039:     mask[:, 1] = True
 1040: 
 1041:     # setting all of one column, none of the other
 1042:     expected = DataFrame({"A": other[:, 0], "B": dta[:, 1]})
 1043:     with tm.assert_produces_warning(
 1044:         FutureWarning, match="Setting an item of incompatible dtype"
 1045:     ):
 1046:         _check_where_equivalences(df, mask, other, expected)
 1047: 
 1048:     # setting part of one column, none of the other
 1049:     mask[1, 0] = True
 1050:     expected = DataFrame(
 1051:         {
 1052:             "A": np.array([other[0, 0], dta[1, 0], other[2, 0]], dtype=object),
 1053:             "B": dta[:, 1],
 1054:         }
 1055:     )
 1056:     with tm.assert_produces_warning(
 1057:         FutureWarning, match="Setting an item of incompatible dtype"
 1058:     ):
 1059:         _check_where_equivalences(df, mask, other, expected)
 1060: 
 1061:     # setting nothing in either column
 1062:     mask[:] = True
 1063:     expected = df
 1064:     _check_where_equivalences(df, mask, other, expected)
 1065: 
 1066: 
 1067: def test_where_producing_ea_cond_for_np_dtype():
 1068:     # GH#44014
 1069:     df = DataFrame({"a": Series([1, pd.NA, 2], dtype="Int64"), "b": [1, 2, 3]})
 1070:     result = df.where(lambda x: x.apply(lambda y: y > 1, axis=1))
 1071:     expected = DataFrame(
 1072:         {"a": Series([pd.NA, pd.NA, 2], dtype="Int64"), "b": [np.nan, 2, 3]}
 1073:     )
 1074:     tm.assert_frame_equal(result, expected)
 1075: 
 1076: 
 1077: @pytest.mark.parametrize(
 1078:     "replacement", [0.001, True, "snake", None, datetime(2022, 5, 4)]
 1079: )
 1080: def test_where_int_overflow(replacement, using_infer_string, request):
 1081:     # GH 31687
 1082:     df = DataFrame([[1.0, 2e25, "nine"], [np.nan, 0.1, None]])
 1083:     if using_infer_string and replacement not in (None, "snake"):
 1084:         request.node.add_marker(
 1085:             pytest.mark.xfail(reason="Can't set non-string into string column")
 1086:         )
 1087:     result = df.where(pd.notnull(df), replacement)
 1088:     expected = DataFrame([[1.0, 2e25, "nine"], [replacement, 0.1, replacement]])
 1089: 
 1090:     tm.assert_frame_equal(result, expected)
 1091: 
 1092: 
 1093: def test_where_inplace_no_other():
 1094:     # GH#51685
 1095:     df = DataFrame({"a": [1.0, 2.0], "b": ["x", "y"]})
 1096:     cond = DataFrame({"a": [True, False], "b": [False, True]})
 1097:     df.where(cond, inplace=True)
 1098:     expected = DataFrame({"a": [1, np.nan], "b": [np.nan, "y"]})
 1099:     tm.assert_frame_equal(df, expected)
