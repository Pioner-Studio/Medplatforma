    1: import operator
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas import (
    7:     DataFrame,
    8:     Index,
    9:     Series,
   10: )
   11: import pandas._testing as tm
   12: 
   13: 
   14: class TestMatMul:
   15:     def test_matmul(self):
   16:         # matmul test is for GH#10259
   17:         a = DataFrame(
   18:             np.random.default_rng(2).standard_normal((3, 4)),
   19:             index=["a", "b", "c"],
   20:             columns=["p", "q", "r", "s"],
   21:         )
   22:         b = DataFrame(
   23:             np.random.default_rng(2).standard_normal((4, 2)),
   24:             index=["p", "q", "r", "s"],
   25:             columns=["one", "two"],
   26:         )
   27: 
   28:         # DataFrame @ DataFrame
   29:         result = operator.matmul(a, b)
   30:         expected = DataFrame(
   31:             np.dot(a.values, b.values), index=["a", "b", "c"], columns=["one", "two"]
   32:         )
   33:         tm.assert_frame_equal(result, expected)
   34: 
   35:         # DataFrame @ Series
   36:         result = operator.matmul(a, b.one)
   37:         expected = Series(np.dot(a.values, b.one.values), index=["a", "b", "c"])
   38:         tm.assert_series_equal(result, expected)
   39: 
   40:         # np.array @ DataFrame
   41:         result = operator.matmul(a.values, b)
   42:         assert isinstance(result, DataFrame)
   43:         assert result.columns.equals(b.columns)
   44:         assert result.index.equals(Index(range(3)))
   45:         expected = np.dot(a.values, b.values)
   46:         tm.assert_almost_equal(result.values, expected)
   47: 
   48:         # nested list @ DataFrame (__rmatmul__)
   49:         result = operator.matmul(a.values.tolist(), b)
   50:         expected = DataFrame(
   51:             np.dot(a.values, b.values), index=["a", "b", "c"], columns=["one", "two"]
   52:         )
   53:         tm.assert_almost_equal(result.values, expected.values)
   54: 
   55:         # mixed dtype DataFrame @ DataFrame
   56:         a["q"] = a.q.round().astype(int)
   57:         result = operator.matmul(a, b)
   58:         expected = DataFrame(
   59:             np.dot(a.values, b.values), index=["a", "b", "c"], columns=["one", "two"]
   60:         )
   61:         tm.assert_frame_equal(result, expected)
   62: 
   63:         # different dtypes DataFrame @ DataFrame
   64:         a = a.astype(int)
   65:         result = operator.matmul(a, b)
   66:         expected = DataFrame(
   67:             np.dot(a.values, b.values), index=["a", "b", "c"], columns=["one", "two"]
   68:         )
   69:         tm.assert_frame_equal(result, expected)
   70: 
   71:         # unaligned
   72:         df = DataFrame(
   73:             np.random.default_rng(2).standard_normal((3, 4)),
   74:             index=[1, 2, 3],
   75:             columns=range(4),
   76:         )
   77:         df2 = DataFrame(
   78:             np.random.default_rng(2).standard_normal((5, 3)),
   79:             index=range(5),
   80:             columns=[1, 2, 3],
   81:         )
   82: 
   83:         with pytest.raises(ValueError, match="aligned"):
   84:             operator.matmul(df, df2)
   85: 
   86:     def test_matmul_message_shapes(self):
   87:         # GH#21581 exception message should reflect original shapes,
   88:         #  not transposed shapes
   89:         a = np.random.default_rng(2).random((10, 4))
   90:         b = np.random.default_rng(2).random((5, 3))
   91: 
   92:         df = DataFrame(b)
   93: 
   94:         msg = r"shapes \(10, 4\) and \(5, 3\) not aligned"
   95:         with pytest.raises(ValueError, match=msg):
   96:             a @ df
   97:         with pytest.raises(ValueError, match=msg):
   98:             a.tolist() @ df
