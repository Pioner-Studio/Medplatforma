    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     Series,
    7: )
    8: import pandas._testing as tm
    9: 
   10: 
   11: class TestDataFrameClip:
   12:     def test_clip(self, float_frame):
   13:         median = float_frame.median().median()
   14:         original = float_frame.copy()
   15: 
   16:         double = float_frame.clip(upper=median, lower=median)
   17:         assert not (double.values != median).any()
   18: 
   19:         # Verify that float_frame was not changed inplace
   20:         assert (float_frame.values == original.values).all()
   21: 
   22:     def test_inplace_clip(self, float_frame):
   23:         # GH#15388
   24:         median = float_frame.median().median()
   25:         frame_copy = float_frame.copy()
   26: 
   27:         return_value = frame_copy.clip(upper=median, lower=median, inplace=True)
   28:         assert return_value is None
   29:         assert not (frame_copy.values != median).any()
   30: 
   31:     def test_dataframe_clip(self):
   32:         # GH#2747
   33:         df = DataFrame(np.random.default_rng(2).standard_normal((1000, 2)))
   34: 
   35:         for lb, ub in [(-1, 1), (1, -1)]:
   36:             clipped_df = df.clip(lb, ub)
   37: 
   38:             lb, ub = min(lb, ub), max(ub, lb)
   39:             lb_mask = df.values <= lb
   40:             ub_mask = df.values >= ub
   41:             mask = ~lb_mask & ~ub_mask
   42:             assert (clipped_df.values[lb_mask] == lb).all()
   43:             assert (clipped_df.values[ub_mask] == ub).all()
   44:             assert (clipped_df.values[mask] == df.values[mask]).all()
   45: 
   46:     def test_clip_mixed_numeric(self):
   47:         # clip on mixed integer or floats
   48:         # GH#24162, clipping now preserves numeric types per column
   49:         df = DataFrame({"A": [1, 2, 3], "B": [1.0, np.nan, 3.0]})
   50:         result = df.clip(1, 2)
   51:         expected = DataFrame({"A": [1, 2, 2], "B": [1.0, np.nan, 2.0]})
   52:         tm.assert_frame_equal(result, expected)
   53: 
   54:         df = DataFrame([[1, 2, 3.4], [3, 4, 5.6]], columns=["foo", "bar", "baz"])
   55:         expected = df.dtypes
   56:         result = df.clip(upper=3).dtypes
   57:         tm.assert_series_equal(result, expected)
   58: 
   59:     @pytest.mark.parametrize("inplace", [True, False])
   60:     def test_clip_against_series(self, inplace):
   61:         # GH#6966
   62: 
   63:         df = DataFrame(np.random.default_rng(2).standard_normal((1000, 2)))
   64:         lb = Series(np.random.default_rng(2).standard_normal(1000))
   65:         ub = lb + 1
   66: 
   67:         original = df.copy()
   68:         clipped_df = df.clip(lb, ub, axis=0, inplace=inplace)
   69: 
   70:         if inplace:
   71:             clipped_df = df
   72: 
   73:         for i in range(2):
   74:             lb_mask = original.iloc[:, i] <= lb
   75:             ub_mask = original.iloc[:, i] >= ub
   76:             mask = ~lb_mask & ~ub_mask
   77: 
   78:             result = clipped_df.loc[lb_mask, i]
   79:             tm.assert_series_equal(result, lb[lb_mask], check_names=False)
   80:             assert result.name == i
   81: 
   82:             result = clipped_df.loc[ub_mask, i]
   83:             tm.assert_series_equal(result, ub[ub_mask], check_names=False)
   84:             assert result.name == i
   85: 
   86:             tm.assert_series_equal(clipped_df.loc[mask, i], df.loc[mask, i])
   87: 
   88:     @pytest.mark.parametrize("inplace", [True, False])
   89:     @pytest.mark.parametrize("lower", [[2, 3, 4], np.asarray([2, 3, 4])])
   90:     @pytest.mark.parametrize(
   91:         "axis,res",
   92:         [
   93:             (0, [[2.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 7.0, 7.0]]),
   94:             (1, [[2.0, 3.0, 4.0], [4.0, 5.0, 6.0], [5.0, 6.0, 7.0]]),
   95:         ],
   96:     )
   97:     def test_clip_against_list_like(self, inplace, lower, axis, res):
   98:         # GH#15390
   99:         arr = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
  100: 
  101:         original = DataFrame(
  102:             arr, columns=["one", "two", "three"], index=["a", "b", "c"]
  103:         )
  104: 
  105:         result = original.clip(lower=lower, upper=[5, 6, 7], axis=axis, inplace=inplace)
  106: 
  107:         expected = DataFrame(res, columns=original.columns, index=original.index)
  108:         if inplace:
  109:             result = original
  110:         tm.assert_frame_equal(result, expected, check_exact=True)
  111: 
  112:     @pytest.mark.parametrize("axis", [0, 1, None])
  113:     def test_clip_against_frame(self, axis):
  114:         df = DataFrame(np.random.default_rng(2).standard_normal((1000, 2)))
  115:         lb = DataFrame(np.random.default_rng(2).standard_normal((1000, 2)))
  116:         ub = lb + 1
  117: 
  118:         clipped_df = df.clip(lb, ub, axis=axis)
  119: 
  120:         lb_mask = df <= lb
  121:         ub_mask = df >= ub
  122:         mask = ~lb_mask & ~ub_mask
  123: 
  124:         tm.assert_frame_equal(clipped_df[lb_mask], lb[lb_mask])
  125:         tm.assert_frame_equal(clipped_df[ub_mask], ub[ub_mask])
  126:         tm.assert_frame_equal(clipped_df[mask], df[mask])
  127: 
  128:     def test_clip_against_unordered_columns(self):
  129:         # GH#20911
  130:         df1 = DataFrame(
  131:             np.random.default_rng(2).standard_normal((1000, 4)),
  132:             columns=["A", "B", "C", "D"],
  133:         )
  134:         df2 = DataFrame(
  135:             np.random.default_rng(2).standard_normal((1000, 4)),
  136:             columns=["D", "A", "B", "C"],
  137:         )
  138:         df3 = DataFrame(df2.values - 1, columns=["B", "D", "C", "A"])
  139:         result_upper = df1.clip(lower=0, upper=df2)
  140:         expected_upper = df1.clip(lower=0, upper=df2[df1.columns])
  141:         result_lower = df1.clip(lower=df3, upper=3)
  142:         expected_lower = df1.clip(lower=df3[df1.columns], upper=3)
  143:         result_lower_upper = df1.clip(lower=df3, upper=df2)
  144:         expected_lower_upper = df1.clip(lower=df3[df1.columns], upper=df2[df1.columns])
  145:         tm.assert_frame_equal(result_upper, expected_upper)
  146:         tm.assert_frame_equal(result_lower, expected_lower)
  147:         tm.assert_frame_equal(result_lower_upper, expected_lower_upper)
  148: 
  149:     def test_clip_with_na_args(self, float_frame):
  150:         """Should process np.nan argument as None"""
  151:         # GH#17276
  152:         tm.assert_frame_equal(float_frame.clip(np.nan), float_frame)
  153:         tm.assert_frame_equal(float_frame.clip(upper=np.nan, lower=np.nan), float_frame)
  154: 
  155:         # GH#19992 and adjusted in GH#40420
  156:         df = DataFrame({"col_0": [1, 2, 3], "col_1": [4, 5, 6], "col_2": [7, 8, 9]})
  157: 
  158:         msg = "Downcasting behavior in Series and DataFrame methods 'where'"
  159:         # TODO: avoid this warning here?  seems like we should never be upcasting
  160:         #  in the first place?
  161:         with tm.assert_produces_warning(FutureWarning, match=msg):
  162:             result = df.clip(lower=[4, 5, np.nan], axis=0)
  163:         expected = DataFrame(
  164:             {"col_0": [4, 5, 3], "col_1": [4, 5, 6], "col_2": [7, 8, 9]}
  165:         )
  166:         tm.assert_frame_equal(result, expected)
  167: 
  168:         result = df.clip(lower=[4, 5, np.nan], axis=1)
  169:         expected = DataFrame(
  170:             {"col_0": [4, 4, 4], "col_1": [5, 5, 6], "col_2": [7, 8, 9]}
  171:         )
  172:         tm.assert_frame_equal(result, expected)
  173: 
  174:         # GH#40420
  175:         data = {"col_0": [9, -3, 0, -1, 5], "col_1": [-2, -7, 6, 8, -5]}
  176:         df = DataFrame(data)
  177:         t = Series([2, -4, np.nan, 6, 3])
  178:         with tm.assert_produces_warning(FutureWarning, match=msg):
  179:             result = df.clip(lower=t, axis=0)
  180:         expected = DataFrame({"col_0": [9, -3, 0, 6, 5], "col_1": [2, -4, 6, 8, 3]})
  181:         tm.assert_frame_equal(result, expected)
  182: 
  183:     def test_clip_int_data_with_float_bound(self):
  184:         # GH51472
  185:         df = DataFrame({"a": [1, 2, 3]})
  186:         result = df.clip(lower=1.5)
  187:         expected = DataFrame({"a": [1.5, 2.0, 3.0]})
  188:         tm.assert_frame_equal(result, expected)
  189: 
  190:     def test_clip_with_list_bound(self):
  191:         # GH#54817
  192:         df = DataFrame([1, 5])
  193:         expected = DataFrame([3, 5])
  194:         result = df.clip([3])
  195:         tm.assert_frame_equal(result, expected)
  196: 
  197:         expected = DataFrame([1, 3])
  198:         result = df.clip(upper=[3])
  199:         tm.assert_frame_equal(result, expected)
