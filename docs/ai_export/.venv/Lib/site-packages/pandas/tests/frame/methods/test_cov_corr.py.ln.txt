    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     Index,
   10:     Series,
   11:     date_range,
   12:     isna,
   13: )
   14: import pandas._testing as tm
   15: 
   16: 
   17: class TestDataFrameCov:
   18:     def test_cov(self, float_frame, float_string_frame):
   19:         # min_periods no NAs (corner case)
   20:         expected = float_frame.cov()
   21:         result = float_frame.cov(min_periods=len(float_frame))
   22: 
   23:         tm.assert_frame_equal(expected, result)
   24: 
   25:         result = float_frame.cov(min_periods=len(float_frame) + 1)
   26:         assert isna(result.values).all()
   27: 
   28:         # with NAs
   29:         frame = float_frame.copy()
   30:         frame.iloc[:5, frame.columns.get_loc("A")] = np.nan
   31:         frame.iloc[5:10, frame.columns.get_loc("B")] = np.nan
   32:         result = frame.cov(min_periods=len(frame) - 8)
   33:         expected = frame.cov()
   34:         expected.loc["A", "B"] = np.nan
   35:         expected.loc["B", "A"] = np.nan
   36:         tm.assert_frame_equal(result, expected)
   37: 
   38:         # regular
   39:         result = frame.cov()
   40:         expected = frame["A"].cov(frame["C"])
   41:         tm.assert_almost_equal(result["A"]["C"], expected)
   42: 
   43:         # fails on non-numeric types
   44:         with pytest.raises(ValueError, match="could not convert string to float"):
   45:             float_string_frame.cov()
   46:         result = float_string_frame.cov(numeric_only=True)
   47:         expected = float_string_frame.loc[:, ["A", "B", "C", "D"]].cov()
   48:         tm.assert_frame_equal(result, expected)
   49: 
   50:         # Single column frame
   51:         df = DataFrame(np.linspace(0.0, 1.0, 10))
   52:         result = df.cov()
   53:         expected = DataFrame(
   54:             np.cov(df.values.T).reshape((1, 1)), index=df.columns, columns=df.columns
   55:         )
   56:         tm.assert_frame_equal(result, expected)
   57:         df.loc[0] = np.nan
   58:         result = df.cov()
   59:         expected = DataFrame(
   60:             np.cov(df.values[1:].T).reshape((1, 1)),
   61:             index=df.columns,
   62:             columns=df.columns,
   63:         )
   64:         tm.assert_frame_equal(result, expected)
   65: 
   66:     @pytest.mark.parametrize("test_ddof", [None, 0, 1, 2, 3])
   67:     def test_cov_ddof(self, test_ddof):
   68:         # GH#34611
   69:         np_array1 = np.random.default_rng(2).random(10)
   70:         np_array2 = np.random.default_rng(2).random(10)
   71:         df = DataFrame({0: np_array1, 1: np_array2})
   72:         result = df.cov(ddof=test_ddof)
   73:         expected_np = np.cov(np_array1, np_array2, ddof=test_ddof)
   74:         expected = DataFrame(expected_np)
   75:         tm.assert_frame_equal(result, expected)
   76: 
   77:     @pytest.mark.parametrize(
   78:         "other_column", [pd.array([1, 2, 3]), np.array([1.0, 2.0, 3.0])]
   79:     )
   80:     def test_cov_nullable_integer(self, other_column):
   81:         # https://github.com/pandas-dev/pandas/issues/33803
   82:         data = DataFrame({"a": pd.array([1, 2, None]), "b": other_column})
   83:         result = data.cov()
   84:         arr = np.array([[0.5, 0.5], [0.5, 1.0]])
   85:         expected = DataFrame(arr, columns=["a", "b"], index=["a", "b"])
   86:         tm.assert_frame_equal(result, expected)
   87: 
   88:     @pytest.mark.parametrize("numeric_only", [True, False])
   89:     def test_cov_numeric_only(self, numeric_only):
   90:         # when dtypes of pandas series are different
   91:         # then ndarray will have dtype=object,
   92:         # so it need to be properly handled
   93:         df = DataFrame({"a": [1, 0], "c": ["x", "y"]})
   94:         expected = DataFrame(0.5, index=["a"], columns=["a"])
   95:         if numeric_only:
   96:             result = df.cov(numeric_only=numeric_only)
   97:             tm.assert_frame_equal(result, expected)
   98:         else:
   99:             with pytest.raises(ValueError, match="could not convert string to float"):
  100:                 df.cov(numeric_only=numeric_only)
  101: 
  102: 
  103: class TestDataFrameCorr:
  104:     # DataFrame.corr(), as opposed to DataFrame.corrwith
  105: 
  106:     @pytest.mark.parametrize("method", ["pearson", "kendall", "spearman"])
  107:     def test_corr_scipy_method(self, float_frame, method):
  108:         pytest.importorskip("scipy")
  109:         float_frame.loc[float_frame.index[:5], "A"] = np.nan
  110:         float_frame.loc[float_frame.index[5:10], "B"] = np.nan
  111:         float_frame.loc[float_frame.index[:10], "A"] = float_frame["A"][10:20].copy()
  112: 
  113:         correls = float_frame.corr(method=method)
  114:         expected = float_frame["A"].corr(float_frame["C"], method=method)
  115:         tm.assert_almost_equal(correls["A"]["C"], expected)
  116: 
  117:     # ---------------------------------------------------------------------
  118: 
  119:     def test_corr_non_numeric(self, float_string_frame):
  120:         with pytest.raises(ValueError, match="could not convert string to float"):
  121:             float_string_frame.corr()
  122:         result = float_string_frame.corr(numeric_only=True)
  123:         expected = float_string_frame.loc[:, ["A", "B", "C", "D"]].corr()
  124:         tm.assert_frame_equal(result, expected)
  125: 
  126:     @pytest.mark.parametrize("meth", ["pearson", "kendall", "spearman"])
  127:     def test_corr_nooverlap(self, meth):
  128:         # nothing in common
  129:         pytest.importorskip("scipy")
  130:         df = DataFrame(
  131:             {
  132:                 "A": [1, 1.5, 1, np.nan, np.nan, np.nan],
  133:                 "B": [np.nan, np.nan, np.nan, 1, 1.5, 1],
  134:                 "C": [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],
  135:             }
  136:         )
  137:         rs = df.corr(meth)
  138:         assert isna(rs.loc["A", "B"])
  139:         assert isna(rs.loc["B", "A"])
  140:         assert rs.loc["A", "A"] == 1
  141:         assert rs.loc["B", "B"] == 1
  142:         assert isna(rs.loc["C", "C"])
  143: 
  144:     @pytest.mark.parametrize("meth", ["pearson", "spearman"])
  145:     def test_corr_constant(self, meth):
  146:         # constant --> all NA
  147:         df = DataFrame(
  148:             {
  149:                 "A": [1, 1, 1, np.nan, np.nan, np.nan],
  150:                 "B": [np.nan, np.nan, np.nan, 1, 1, 1],
  151:             }
  152:         )
  153:         rs = df.corr(meth)
  154:         assert isna(rs.values).all()
  155: 
  156:     @pytest.mark.filterwarnings("ignore::RuntimeWarning")
  157:     @pytest.mark.parametrize("meth", ["pearson", "kendall", "spearman"])
  158:     def test_corr_int_and_boolean(self, meth):
  159:         # when dtypes of pandas series are different
  160:         # then ndarray will have dtype=object,
  161:         # so it need to be properly handled
  162:         pytest.importorskip("scipy")
  163:         df = DataFrame({"a": [True, False], "b": [1, 0]})
  164: 
  165:         expected = DataFrame(np.ones((2, 2)), index=["a", "b"], columns=["a", "b"])
  166:         result = df.corr(meth)
  167:         tm.assert_frame_equal(result, expected)
  168: 
  169:     @pytest.mark.parametrize("method", ["cov", "corr"])
  170:     def test_corr_cov_independent_index_column(self, method):
  171:         # GH#14617
  172:         df = DataFrame(
  173:             np.random.default_rng(2).standard_normal(4 * 10).reshape(10, 4),
  174:             columns=list("abcd"),
  175:         )
  176:         result = getattr(df, method)()
  177:         assert result.index is not result.columns
  178:         assert result.index.equals(result.columns)
  179: 
  180:     def test_corr_invalid_method(self):
  181:         # GH#22298
  182:         df = DataFrame(np.random.default_rng(2).normal(size=(10, 2)))
  183:         msg = "method must be either 'pearson', 'spearman', 'kendall', or a callable, "
  184:         with pytest.raises(ValueError, match=msg):
  185:             df.corr(method="____")
  186: 
  187:     def test_corr_int(self):
  188:         # dtypes other than float64 GH#1761
  189:         df = DataFrame({"a": [1, 2, 3, 4], "b": [1, 2, 3, 4]})
  190: 
  191:         df.cov()
  192:         df.corr()
  193: 
  194:     @pytest.mark.parametrize(
  195:         "nullable_column", [pd.array([1, 2, 3]), pd.array([1, 2, None])]
  196:     )
  197:     @pytest.mark.parametrize(
  198:         "other_column",
  199:         [pd.array([1, 2, 3]), np.array([1.0, 2.0, 3.0]), np.array([1.0, 2.0, np.nan])],
  200:     )
  201:     @pytest.mark.parametrize("method", ["pearson", "spearman", "kendall"])
  202:     def test_corr_nullable_integer(self, nullable_column, other_column, method):
  203:         # https://github.com/pandas-dev/pandas/issues/33803
  204:         pytest.importorskip("scipy")
  205:         data = DataFrame({"a": nullable_column, "b": other_column})
  206:         result = data.corr(method=method)
  207:         expected = DataFrame(np.ones((2, 2)), columns=["a", "b"], index=["a", "b"])
  208:         tm.assert_frame_equal(result, expected)
  209: 
  210:     def test_corr_item_cache(self, using_copy_on_write, warn_copy_on_write):
  211:         # Check that corr does not lead to incorrect entries in item_cache
  212: 
  213:         df = DataFrame({"A": range(10)})
  214:         df["B"] = range(10)[::-1]
  215: 
  216:         ser = df["A"]  # populate item_cache
  217:         assert len(df._mgr.arrays) == 2  # i.e. 2 blocks
  218: 
  219:         _ = df.corr(numeric_only=True)
  220: 
  221:         if using_copy_on_write:
  222:             ser.iloc[0] = 99
  223:             assert df.loc[0, "A"] == 0
  224:         else:
  225:             # Check that the corr didn't break link between ser and df
  226:             ser.values[0] = 99
  227:             assert df.loc[0, "A"] == 99
  228:             if not warn_copy_on_write:
  229:                 assert df["A"] is ser
  230:             assert df.values[0, 0] == 99
  231: 
  232:     @pytest.mark.parametrize("length", [2, 20, 200, 2000])
  233:     def test_corr_for_constant_columns(self, length):
  234:         # GH: 37448
  235:         df = DataFrame(length * [[0.4, 0.1]], columns=["A", "B"])
  236:         result = df.corr()
  237:         expected = DataFrame(
  238:             {"A": [np.nan, np.nan], "B": [np.nan, np.nan]}, index=["A", "B"]
  239:         )
  240:         tm.assert_frame_equal(result, expected)
  241: 
  242:     def test_calc_corr_small_numbers(self):
  243:         # GH: 37452
  244:         df = DataFrame(
  245:             {"A": [1.0e-20, 2.0e-20, 3.0e-20], "B": [1.0e-20, 2.0e-20, 3.0e-20]}
  246:         )
  247:         result = df.corr()
  248:         expected = DataFrame({"A": [1.0, 1.0], "B": [1.0, 1.0]}, index=["A", "B"])
  249:         tm.assert_frame_equal(result, expected)
  250: 
  251:     @pytest.mark.parametrize("method", ["pearson", "spearman", "kendall"])
  252:     def test_corr_min_periods_greater_than_length(self, method):
  253:         pytest.importorskip("scipy")
  254:         df = DataFrame({"A": [1, 2], "B": [1, 2]})
  255:         result = df.corr(method=method, min_periods=3)
  256:         expected = DataFrame(
  257:             {"A": [np.nan, np.nan], "B": [np.nan, np.nan]}, index=["A", "B"]
  258:         )
  259:         tm.assert_frame_equal(result, expected)
  260: 
  261:     @pytest.mark.parametrize("meth", ["pearson", "kendall", "spearman"])
  262:     @pytest.mark.parametrize("numeric_only", [True, False])
  263:     def test_corr_numeric_only(self, meth, numeric_only):
  264:         # when dtypes of pandas series are different
  265:         # then ndarray will have dtype=object,
  266:         # so it need to be properly handled
  267:         pytest.importorskip("scipy")
  268:         df = DataFrame({"a": [1, 0], "b": [1, 0], "c": ["x", "y"]})
  269:         expected = DataFrame(np.ones((2, 2)), index=["a", "b"], columns=["a", "b"])
  270:         if numeric_only:
  271:             result = df.corr(meth, numeric_only=numeric_only)
  272:             tm.assert_frame_equal(result, expected)
  273:         else:
  274:             with pytest.raises(ValueError, match="could not convert string to float"):
  275:                 df.corr(meth, numeric_only=numeric_only)
  276: 
  277: 
  278: class TestDataFrameCorrWith:
  279:     @pytest.mark.parametrize(
  280:         "dtype",
  281:         [
  282:             "float64",
  283:             "Float64",
  284:             pytest.param("float64[pyarrow]", marks=td.skip_if_no("pyarrow")),
  285:         ],
  286:     )
  287:     def test_corrwith(self, datetime_frame, dtype):
  288:         datetime_frame = datetime_frame.astype(dtype)
  289: 
  290:         a = datetime_frame
  291:         noise = Series(np.random.default_rng(2).standard_normal(len(a)), index=a.index)
  292: 
  293:         b = datetime_frame.add(noise, axis=0)
  294: 
  295:         # make sure order does not matter
  296:         b = b.reindex(columns=b.columns[::-1], index=b.index[::-1][10:])
  297:         del b["B"]
  298: 
  299:         colcorr = a.corrwith(b, axis=0)
  300:         tm.assert_almost_equal(colcorr["A"], a["A"].corr(b["A"]))
  301: 
  302:         rowcorr = a.corrwith(b, axis=1)
  303:         tm.assert_series_equal(rowcorr, a.T.corrwith(b.T, axis=0))
  304: 
  305:         dropped = a.corrwith(b, axis=0, drop=True)
  306:         tm.assert_almost_equal(dropped["A"], a["A"].corr(b["A"]))
  307:         assert "B" not in dropped
  308: 
  309:         dropped = a.corrwith(b, axis=1, drop=True)
  310:         assert a.index[-1] not in dropped.index
  311: 
  312:         # non time-series data
  313:         index = ["a", "b", "c", "d", "e"]
  314:         columns = ["one", "two", "three", "four"]
  315:         df1 = DataFrame(
  316:             np.random.default_rng(2).standard_normal((5, 4)),
  317:             index=index,
  318:             columns=columns,
  319:         )
  320:         df2 = DataFrame(
  321:             np.random.default_rng(2).standard_normal((4, 4)),
  322:             index=index[:4],
  323:             columns=columns,
  324:         )
  325:         correls = df1.corrwith(df2, axis=1)
  326:         for row in index[:4]:
  327:             tm.assert_almost_equal(correls[row], df1.loc[row].corr(df2.loc[row]))
  328: 
  329:     def test_corrwith_with_objects(self, using_infer_string):
  330:         df1 = DataFrame(
  331:             np.random.default_rng(2).standard_normal((10, 4)),
  332:             columns=Index(list("ABCD"), dtype=object),
  333:             index=date_range("2000-01-01", periods=10, freq="B"),
  334:         )
  335:         df2 = df1.copy()
  336:         cols = ["A", "B", "C", "D"]
  337: 
  338:         df1["obj"] = "foo"
  339:         df2["obj"] = "bar"
  340: 
  341:         if using_infer_string:
  342:             import pyarrow as pa
  343: 
  344:             with pytest.raises(pa.lib.ArrowNotImplementedError, match="has no kernel"):
  345:                 df1.corrwith(df2)
  346:         else:
  347:             with pytest.raises(TypeError, match="Could not convert"):
  348:                 df1.corrwith(df2)
  349:         result = df1.corrwith(df2, numeric_only=True)
  350:         expected = df1.loc[:, cols].corrwith(df2.loc[:, cols])
  351:         tm.assert_series_equal(result, expected)
  352: 
  353:         with pytest.raises(TypeError, match="unsupported operand type"):
  354:             df1.corrwith(df2, axis=1)
  355:         result = df1.corrwith(df2, axis=1, numeric_only=True)
  356:         expected = df1.loc[:, cols].corrwith(df2.loc[:, cols], axis=1)
  357:         tm.assert_series_equal(result, expected)
  358: 
  359:     def test_corrwith_series(self, datetime_frame):
  360:         result = datetime_frame.corrwith(datetime_frame["A"])
  361:         expected = datetime_frame.apply(datetime_frame["A"].corr)
  362: 
  363:         tm.assert_series_equal(result, expected)
  364: 
  365:     def test_corrwith_matches_corrcoef(self):
  366:         df1 = DataFrame(np.arange(10000), columns=["a"])
  367:         df2 = DataFrame(np.arange(10000) ** 2, columns=["a"])
  368:         c1 = df1.corrwith(df2)["a"]
  369:         c2 = np.corrcoef(df1["a"], df2["a"])[0][1]
  370: 
  371:         tm.assert_almost_equal(c1, c2)
  372:         assert c1 < 1
  373: 
  374:     @pytest.mark.parametrize("numeric_only", [True, False])
  375:     def test_corrwith_mixed_dtypes(self, numeric_only):
  376:         # GH#18570
  377:         df = DataFrame(
  378:             {"a": [1, 4, 3, 2], "b": [4, 6, 7, 3], "c": ["a", "b", "c", "d"]}
  379:         )
  380:         s = Series([0, 6, 7, 3])
  381:         if numeric_only:
  382:             result = df.corrwith(s, numeric_only=numeric_only)
  383:             corrs = [df["a"].corr(s), df["b"].corr(s)]
  384:             expected = Series(data=corrs, index=["a", "b"])
  385:             tm.assert_series_equal(result, expected)
  386:         else:
  387:             with pytest.raises(
  388:                 ValueError,
  389:                 match="could not convert string to float",
  390:             ):
  391:                 df.corrwith(s, numeric_only=numeric_only)
  392: 
  393:     def test_corrwith_index_intersection(self):
  394:         df1 = DataFrame(
  395:             np.random.default_rng(2).random(size=(10, 2)), columns=["a", "b"]
  396:         )
  397:         df2 = DataFrame(
  398:             np.random.default_rng(2).random(size=(10, 3)), columns=["a", "b", "c"]
  399:         )
  400: 
  401:         result = df1.corrwith(df2, drop=True).index.sort_values()
  402:         expected = df1.columns.intersection(df2.columns).sort_values()
  403:         tm.assert_index_equal(result, expected)
  404: 
  405:     def test_corrwith_index_union(self):
  406:         df1 = DataFrame(
  407:             np.random.default_rng(2).random(size=(10, 2)), columns=["a", "b"]
  408:         )
  409:         df2 = DataFrame(
  410:             np.random.default_rng(2).random(size=(10, 3)), columns=["a", "b", "c"]
  411:         )
  412: 
  413:         result = df1.corrwith(df2, drop=False).index.sort_values()
  414:         expected = df1.columns.union(df2.columns).sort_values()
  415:         tm.assert_index_equal(result, expected)
  416: 
  417:     def test_corrwith_dup_cols(self):
  418:         # GH#21925
  419:         df1 = DataFrame(np.vstack([np.arange(10)] * 3).T)
  420:         df2 = df1.copy()
  421:         df2 = pd.concat((df2, df2[0]), axis=1)
  422: 
  423:         result = df1.corrwith(df2)
  424:         expected = Series(np.ones(4), index=[0, 0, 1, 2])
  425:         tm.assert_series_equal(result, expected)
  426: 
  427:     def test_corr_numerical_instabilities(self):
  428:         # GH#45640
  429:         df = DataFrame([[0.2, 0.4], [0.4, 0.2]])
  430:         result = df.corr()
  431:         expected = DataFrame({0: [1.0, -1.0], 1: [-1.0, 1.0]})
  432:         tm.assert_frame_equal(result - 1, expected - 1, atol=1e-17)
  433: 
  434:     def test_corrwith_spearman(self):
  435:         # GH#21925
  436:         pytest.importorskip("scipy")
  437:         df = DataFrame(np.random.default_rng(2).random(size=(100, 3)))
  438:         result = df.corrwith(df**2, method="spearman")
  439:         expected = Series(np.ones(len(result)))
  440:         tm.assert_series_equal(result, expected)
  441: 
  442:     def test_corrwith_kendall(self):
  443:         # GH#21925
  444:         pytest.importorskip("scipy")
  445:         df = DataFrame(np.random.default_rng(2).random(size=(100, 3)))
  446:         result = df.corrwith(df**2, method="kendall")
  447:         expected = Series(np.ones(len(result)))
  448:         tm.assert_series_equal(result, expected)
  449: 
  450:     def test_corrwith_spearman_with_tied_data(self):
  451:         # GH#48826
  452:         pytest.importorskip("scipy")
  453:         df1 = DataFrame(
  454:             {
  455:                 "A": [1, np.nan, 7, 8],
  456:                 "B": [False, True, True, False],
  457:                 "C": [10, 4, 9, 3],
  458:             }
  459:         )
  460:         df2 = df1[["B", "C"]]
  461:         result = (df1 + 1).corrwith(df2.B, method="spearman")
  462:         expected = Series([0.0, 1.0, 0.0], index=["A", "B", "C"])
  463:         tm.assert_series_equal(result, expected)
  464: 
  465:         df_bool = DataFrame(
  466:             {"A": [True, True, False, False], "B": [True, False, False, True]}
  467:         )
  468:         ser_bool = Series([True, True, False, True])
  469:         result = df_bool.corrwith(ser_bool)
  470:         expected = Series([0.57735, 0.57735], index=["A", "B"])
  471:         tm.assert_series_equal(result, expected)
