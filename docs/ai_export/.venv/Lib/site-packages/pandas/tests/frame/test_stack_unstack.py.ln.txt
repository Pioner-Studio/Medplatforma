    1: from datetime import datetime
    2: import itertools
    3: import re
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas._libs import lib
    9: from pandas.errors import PerformanceWarning
   10: 
   11: import pandas as pd
   12: from pandas import (
   13:     DataFrame,
   14:     Index,
   15:     MultiIndex,
   16:     Period,
   17:     Series,
   18:     Timedelta,
   19:     date_range,
   20: )
   21: import pandas._testing as tm
   22: from pandas.core.reshape import reshape as reshape_lib
   23: 
   24: 
   25: @pytest.fixture(params=[True, False])
   26: def future_stack(request):
   27:     return request.param
   28: 
   29: 
   30: class TestDataFrameReshape:
   31:     def test_stack_unstack(self, float_frame, future_stack):
   32:         df = float_frame.copy()
   33:         df[:] = np.arange(np.prod(df.shape)).reshape(df.shape)
   34: 
   35:         stacked = df.stack(future_stack=future_stack)
   36:         stacked_df = DataFrame({"foo": stacked, "bar": stacked})
   37: 
   38:         unstacked = stacked.unstack()
   39:         unstacked_df = stacked_df.unstack()
   40: 
   41:         tm.assert_frame_equal(unstacked, df)
   42:         tm.assert_frame_equal(unstacked_df["bar"], df)
   43: 
   44:         unstacked_cols = stacked.unstack(0)
   45:         unstacked_cols_df = stacked_df.unstack(0)
   46:         tm.assert_frame_equal(unstacked_cols.T, df)
   47:         tm.assert_frame_equal(unstacked_cols_df["bar"].T, df)
   48: 
   49:     @pytest.mark.filterwarnings(
   50:         "ignore:The previous implementation of stack is deprecated"
   51:     )
   52:     def test_stack_mixed_level(self, future_stack):
   53:         # GH 18310
   54:         levels = [range(3), [3, "a", "b"], [1, 2]]
   55: 
   56:         # flat columns:
   57:         df = DataFrame(1, index=levels[0], columns=levels[1])
   58:         result = df.stack(future_stack=future_stack)
   59:         expected = Series(1, index=MultiIndex.from_product(levels[:2]))
   60:         tm.assert_series_equal(result, expected)
   61: 
   62:         # MultiIndex columns:
   63:         df = DataFrame(1, index=levels[0], columns=MultiIndex.from_product(levels[1:]))
   64:         result = df.stack(1, future_stack=future_stack)
   65:         expected = DataFrame(
   66:             1, index=MultiIndex.from_product([levels[0], levels[2]]), columns=levels[1]
   67:         )
   68:         tm.assert_frame_equal(result, expected)
   69: 
   70:         # as above, but used labels in level are actually of homogeneous type
   71:         result = df[["a", "b"]].stack(1, future_stack=future_stack)
   72:         expected = expected[["a", "b"]]
   73:         tm.assert_frame_equal(result, expected)
   74: 
   75:     def test_unstack_not_consolidated(self, using_array_manager):
   76:         # Gh#34708
   77:         df = DataFrame({"x": [1, 2, np.nan], "y": [3.0, 4, np.nan]})
   78:         df2 = df[["x"]]
   79:         df2["y"] = df["y"]
   80:         if not using_array_manager:
   81:             assert len(df2._mgr.blocks) == 2
   82: 
   83:         res = df2.unstack()
   84:         expected = df.unstack()
   85:         tm.assert_series_equal(res, expected)
   86: 
   87:     @pytest.mark.filterwarnings(
   88:         "ignore:The previous implementation of stack is deprecated"
   89:     )
   90:     def test_unstack_fill(self, future_stack):
   91:         # GH #9746: fill_value keyword argument for Series
   92:         # and DataFrame unstack
   93: 
   94:         # From a series
   95:         data = Series([1, 2, 4, 5], dtype=np.int16)
   96:         data.index = MultiIndex.from_tuples(
   97:             [("x", "a"), ("x", "b"), ("y", "b"), ("z", "a")]
   98:         )
   99: 
  100:         result = data.unstack(fill_value=-1)
  101:         expected = DataFrame(
  102:             {"a": [1, -1, 5], "b": [2, 4, -1]}, index=["x", "y", "z"], dtype=np.int16
  103:         )
  104:         tm.assert_frame_equal(result, expected)
  105: 
  106:         # From a series with incorrect data type for fill_value
  107:         result = data.unstack(fill_value=0.5)
  108:         expected = DataFrame(
  109:             {"a": [1, 0.5, 5], "b": [2, 4, 0.5]}, index=["x", "y", "z"], dtype=float
  110:         )
  111:         tm.assert_frame_equal(result, expected)
  112: 
  113:         # GH #13971: fill_value when unstacking multiple levels:
  114:         df = DataFrame(
  115:             {"x": ["a", "a", "b"], "y": ["j", "k", "j"], "z": [0, 1, 2], "w": [0, 1, 2]}
  116:         ).set_index(["x", "y", "z"])
  117:         unstacked = df.unstack(["x", "y"], fill_value=0)
  118:         key = ("w", "b", "j")
  119:         expected = unstacked[key]
  120:         result = Series([0, 0, 2], index=unstacked.index, name=key)
  121:         tm.assert_series_equal(result, expected)
  122: 
  123:         stacked = unstacked.stack(["x", "y"], future_stack=future_stack)
  124:         stacked.index = stacked.index.reorder_levels(df.index.names)
  125:         # Workaround for GH #17886 (unnecessarily casts to float):
  126:         stacked = stacked.astype(np.int64)
  127:         result = stacked.loc[df.index]
  128:         tm.assert_frame_equal(result, df)
  129: 
  130:         # From a series
  131:         s = df["w"]
  132:         result = s.unstack(["x", "y"], fill_value=0)
  133:         expected = unstacked["w"]
  134:         tm.assert_frame_equal(result, expected)
  135: 
  136:     def test_unstack_fill_frame(self):
  137:         # From a dataframe
  138:         rows = [[1, 2], [3, 4], [5, 6], [7, 8]]
  139:         df = DataFrame(rows, columns=list("AB"), dtype=np.int32)
  140:         df.index = MultiIndex.from_tuples(
  141:             [("x", "a"), ("x", "b"), ("y", "b"), ("z", "a")]
  142:         )
  143: 
  144:         result = df.unstack(fill_value=-1)
  145: 
  146:         rows = [[1, 3, 2, 4], [-1, 5, -1, 6], [7, -1, 8, -1]]
  147:         expected = DataFrame(rows, index=list("xyz"), dtype=np.int32)
  148:         expected.columns = MultiIndex.from_tuples(
  149:             [("A", "a"), ("A", "b"), ("B", "a"), ("B", "b")]
  150:         )
  151:         tm.assert_frame_equal(result, expected)
  152: 
  153:         # From a mixed type dataframe
  154:         df["A"] = df["A"].astype(np.int16)
  155:         df["B"] = df["B"].astype(np.float64)
  156: 
  157:         result = df.unstack(fill_value=-1)
  158:         expected["A"] = expected["A"].astype(np.int16)
  159:         expected["B"] = expected["B"].astype(np.float64)
  160:         tm.assert_frame_equal(result, expected)
  161: 
  162:         # From a dataframe with incorrect data type for fill_value
  163:         result = df.unstack(fill_value=0.5)
  164: 
  165:         rows = [[1, 3, 2, 4], [0.5, 5, 0.5, 6], [7, 0.5, 8, 0.5]]
  166:         expected = DataFrame(rows, index=list("xyz"), dtype=float)
  167:         expected.columns = MultiIndex.from_tuples(
  168:             [("A", "a"), ("A", "b"), ("B", "a"), ("B", "b")]
  169:         )
  170:         tm.assert_frame_equal(result, expected)
  171: 
  172:     def test_unstack_fill_frame_datetime(self):
  173:         # Test unstacking with date times
  174:         dv = date_range("2012-01-01", periods=4).values
  175:         data = Series(dv)
  176:         data.index = MultiIndex.from_tuples(
  177:             [("x", "a"), ("x", "b"), ("y", "b"), ("z", "a")]
  178:         )
  179: 
  180:         result = data.unstack()
  181:         expected = DataFrame(
  182:             {"a": [dv[0], pd.NaT, dv[3]], "b": [dv[1], dv[2], pd.NaT]},
  183:             index=["x", "y", "z"],
  184:         )
  185:         tm.assert_frame_equal(result, expected)
  186: 
  187:         result = data.unstack(fill_value=dv[0])
  188:         expected = DataFrame(
  189:             {"a": [dv[0], dv[0], dv[3]], "b": [dv[1], dv[2], dv[0]]},
  190:             index=["x", "y", "z"],
  191:         )
  192:         tm.assert_frame_equal(result, expected)
  193: 
  194:     def test_unstack_fill_frame_timedelta(self):
  195:         # Test unstacking with time deltas
  196:         td = [Timedelta(days=i) for i in range(4)]
  197:         data = Series(td)
  198:         data.index = MultiIndex.from_tuples(
  199:             [("x", "a"), ("x", "b"), ("y", "b"), ("z", "a")]
  200:         )
  201: 
  202:         result = data.unstack()
  203:         expected = DataFrame(
  204:             {"a": [td[0], pd.NaT, td[3]], "b": [td[1], td[2], pd.NaT]},
  205:             index=["x", "y", "z"],
  206:         )
  207:         tm.assert_frame_equal(result, expected)
  208: 
  209:         result = data.unstack(fill_value=td[1])
  210:         expected = DataFrame(
  211:             {"a": [td[0], td[1], td[3]], "b": [td[1], td[2], td[1]]},
  212:             index=["x", "y", "z"],
  213:         )
  214:         tm.assert_frame_equal(result, expected)
  215: 
  216:     def test_unstack_fill_frame_period(self):
  217:         # Test unstacking with period
  218:         periods = [
  219:             Period("2012-01"),
  220:             Period("2012-02"),
  221:             Period("2012-03"),
  222:             Period("2012-04"),
  223:         ]
  224:         data = Series(periods)
  225:         data.index = MultiIndex.from_tuples(
  226:             [("x", "a"), ("x", "b"), ("y", "b"), ("z", "a")]
  227:         )
  228: 
  229:         result = data.unstack()
  230:         expected = DataFrame(
  231:             {"a": [periods[0], None, periods[3]], "b": [periods[1], periods[2], None]},
  232:             index=["x", "y", "z"],
  233:         )
  234:         tm.assert_frame_equal(result, expected)
  235: 
  236:         result = data.unstack(fill_value=periods[1])
  237:         expected = DataFrame(
  238:             {
  239:                 "a": [periods[0], periods[1], periods[3]],
  240:                 "b": [periods[1], periods[2], periods[1]],
  241:             },
  242:             index=["x", "y", "z"],
  243:         )
  244:         tm.assert_frame_equal(result, expected)
  245: 
  246:     def test_unstack_fill_frame_categorical(self):
  247:         # Test unstacking with categorical
  248:         data = Series(["a", "b", "c", "a"], dtype="category")
  249:         data.index = MultiIndex.from_tuples(
  250:             [("x", "a"), ("x", "b"), ("y", "b"), ("z", "a")]
  251:         )
  252: 
  253:         # By default missing values will be NaN
  254:         result = data.unstack()
  255:         expected = DataFrame(
  256:             {
  257:                 "a": pd.Categorical(list("axa"), categories=list("abc")),
  258:                 "b": pd.Categorical(list("bcx"), categories=list("abc")),
  259:             },
  260:             index=list("xyz"),
  261:         )
  262:         tm.assert_frame_equal(result, expected)
  263: 
  264:         # Fill with non-category results in a ValueError
  265:         msg = r"Cannot setitem on a Categorical with a new category \(d\)"
  266:         with pytest.raises(TypeError, match=msg):
  267:             data.unstack(fill_value="d")
  268: 
  269:         # Fill with category value replaces missing values as expected
  270:         result = data.unstack(fill_value="c")
  271:         expected = DataFrame(
  272:             {
  273:                 "a": pd.Categorical(list("aca"), categories=list("abc")),
  274:                 "b": pd.Categorical(list("bcc"), categories=list("abc")),
  275:             },
  276:             index=list("xyz"),
  277:         )
  278:         tm.assert_frame_equal(result, expected)
  279: 
  280:     def test_unstack_tuplename_in_multiindex(self):
  281:         # GH 19966
  282:         idx = MultiIndex.from_product(
  283:             [["a", "b", "c"], [1, 2, 3]], names=[("A", "a"), ("B", "b")]
  284:         )
  285:         df = DataFrame({"d": [1] * 9, "e": [2] * 9}, index=idx)
  286:         result = df.unstack(("A", "a"))
  287: 
  288:         expected = DataFrame(
  289:             [[1, 1, 1, 2, 2, 2], [1, 1, 1, 2, 2, 2], [1, 1, 1, 2, 2, 2]],
  290:             columns=MultiIndex.from_tuples(
  291:                 [
  292:                     ("d", "a"),
  293:                     ("d", "b"),
  294:                     ("d", "c"),
  295:                     ("e", "a"),
  296:                     ("e", "b"),
  297:                     ("e", "c"),
  298:                 ],
  299:                 names=[None, ("A", "a")],
  300:             ),
  301:             index=Index([1, 2, 3], name=("B", "b")),
  302:         )
  303:         tm.assert_frame_equal(result, expected)
  304: 
  305:     @pytest.mark.parametrize(
  306:         "unstack_idx, expected_values, expected_index, expected_columns",
  307:         [
  308:             (
  309:                 ("A", "a"),
  310:                 [[1, 1, 2, 2], [1, 1, 2, 2], [1, 1, 2, 2], [1, 1, 2, 2]],
  311:                 MultiIndex.from_tuples(
  312:                     [(1, 3), (1, 4), (2, 3), (2, 4)], names=["B", "C"]
  313:                 ),
  314:                 MultiIndex.from_tuples(
  315:                     [("d", "a"), ("d", "b"), ("e", "a"), ("e", "b")],
  316:                     names=[None, ("A", "a")],
  317:                 ),
  318:             ),
  319:             (
  320:                 (("A", "a"), "B"),
  321:                 [[1, 1, 1, 1, 2, 2, 2, 2], [1, 1, 1, 1, 2, 2, 2, 2]],
  322:                 Index([3, 4], name="C"),
  323:                 MultiIndex.from_tuples(
  324:                     [
  325:                         ("d", "a", 1),
  326:                         ("d", "a", 2),
  327:                         ("d", "b", 1),
  328:                         ("d", "b", 2),
  329:                         ("e", "a", 1),
  330:                         ("e", "a", 2),
  331:                         ("e", "b", 1),
  332:                         ("e", "b", 2),
  333:                     ],
  334:                     names=[None, ("A", "a"), "B"],
  335:                 ),
  336:             ),
  337:         ],
  338:     )
  339:     def test_unstack_mixed_type_name_in_multiindex(
  340:         self, unstack_idx, expected_values, expected_index, expected_columns
  341:     ):
  342:         # GH 19966
  343:         idx = MultiIndex.from_product(
  344:             [["a", "b"], [1, 2], [3, 4]], names=[("A", "a"), "B", "C"]
  345:         )
  346:         df = DataFrame({"d": [1] * 8, "e": [2] * 8}, index=idx)
  347:         result = df.unstack(unstack_idx)
  348: 
  349:         expected = DataFrame(
  350:             expected_values, columns=expected_columns, index=expected_index
  351:         )
  352:         tm.assert_frame_equal(result, expected)
  353: 
  354:     def test_unstack_preserve_dtypes(self):
  355:         # Checks fix for #11847
  356:         df = DataFrame(
  357:             {
  358:                 "state": ["IL", "MI", "NC"],
  359:                 "index": ["a", "b", "c"],
  360:                 "some_categories": Series(["a", "b", "c"]).astype("category"),
  361:                 "A": np.random.default_rng(2).random(3),
  362:                 "B": 1,
  363:                 "C": "foo",
  364:                 "D": pd.Timestamp("20010102"),
  365:                 "E": Series([1.0, 50.0, 100.0]).astype("float32"),
  366:                 "F": Series([3.0, 4.0, 5.0]).astype("float64"),
  367:                 "G": False,
  368:                 "H": Series([1, 200, 923442]).astype("int8"),
  369:             }
  370:         )
  371: 
  372:         def unstack_and_compare(df, column_name):
  373:             unstacked1 = df.unstack([column_name])
  374:             unstacked2 = df.unstack(column_name)
  375:             tm.assert_frame_equal(unstacked1, unstacked2)
  376: 
  377:         df1 = df.set_index(["state", "index"])
  378:         unstack_and_compare(df1, "index")
  379: 
  380:         df1 = df.set_index(["state", "some_categories"])
  381:         unstack_and_compare(df1, "some_categories")
  382: 
  383:         df1 = df.set_index(["F", "C"])
  384:         unstack_and_compare(df1, "F")
  385: 
  386:         df1 = df.set_index(["G", "B", "state"])
  387:         unstack_and_compare(df1, "B")
  388: 
  389:         df1 = df.set_index(["E", "A"])
  390:         unstack_and_compare(df1, "E")
  391: 
  392:         df1 = df.set_index(["state", "index"])
  393:         s = df1["A"]
  394:         unstack_and_compare(s, "index")
  395: 
  396:     @pytest.mark.filterwarnings(
  397:         "ignore:The previous implementation of stack is deprecated"
  398:     )
  399:     def test_stack_ints(self, future_stack):
  400:         columns = MultiIndex.from_tuples(list(itertools.product(range(3), repeat=3)))
  401:         df = DataFrame(
  402:             np.random.default_rng(2).standard_normal((30, 27)), columns=columns
  403:         )
  404: 
  405:         tm.assert_frame_equal(
  406:             df.stack(level=[1, 2], future_stack=future_stack),
  407:             df.stack(level=1, future_stack=future_stack).stack(
  408:                 level=1, future_stack=future_stack
  409:             ),
  410:         )
  411:         tm.assert_frame_equal(
  412:             df.stack(level=[-2, -1], future_stack=future_stack),
  413:             df.stack(level=1, future_stack=future_stack).stack(
  414:                 level=1, future_stack=future_stack
  415:             ),
  416:         )
  417: 
  418:         df_named = df.copy()
  419:         return_value = df_named.columns.set_names(range(3), inplace=True)
  420:         assert return_value is None
  421: 
  422:         tm.assert_frame_equal(
  423:             df_named.stack(level=[1, 2], future_stack=future_stack),
  424:             df_named.stack(level=1, future_stack=future_stack).stack(
  425:                 level=1, future_stack=future_stack
  426:             ),
  427:         )
  428: 
  429:     @pytest.mark.filterwarnings(
  430:         "ignore:The previous implementation of stack is deprecated"
  431:     )
  432:     def test_stack_mixed_levels(self, future_stack):
  433:         columns = MultiIndex.from_tuples(
  434:             [
  435:                 ("A", "cat", "long"),
  436:                 ("B", "cat", "long"),
  437:                 ("A", "dog", "short"),
  438:                 ("B", "dog", "short"),
  439:             ],
  440:             names=["exp", "animal", "hair_length"],
  441:         )
  442:         df = DataFrame(
  443:             np.random.default_rng(2).standard_normal((4, 4)), columns=columns
  444:         )
  445: 
  446:         animal_hair_stacked = df.stack(
  447:             level=["animal", "hair_length"], future_stack=future_stack
  448:         )
  449:         exp_hair_stacked = df.stack(
  450:             level=["exp", "hair_length"], future_stack=future_stack
  451:         )
  452: 
  453:         # GH #8584: Need to check that stacking works when a number
  454:         # is passed that is both a level name and in the range of
  455:         # the level numbers
  456:         df2 = df.copy()
  457:         df2.columns.names = ["exp", "animal", 1]
  458:         tm.assert_frame_equal(
  459:             df2.stack(level=["animal", 1], future_stack=future_stack),
  460:             animal_hair_stacked,
  461:             check_names=False,
  462:         )
  463:         tm.assert_frame_equal(
  464:             df2.stack(level=["exp", 1], future_stack=future_stack),
  465:             exp_hair_stacked,
  466:             check_names=False,
  467:         )
  468: 
  469:         # When mixed types are passed and the ints are not level
  470:         # names, raise
  471:         msg = (
  472:             "level should contain all level names or all level numbers, not "
  473:             "a mixture of the two"
  474:         )
  475:         with pytest.raises(ValueError, match=msg):
  476:             df2.stack(level=["animal", 0], future_stack=future_stack)
  477: 
  478:         # GH #8584: Having 0 in the level names could raise a
  479:         # strange error about lexsort depth
  480:         df3 = df.copy()
  481:         df3.columns.names = ["exp", "animal", 0]
  482:         tm.assert_frame_equal(
  483:             df3.stack(level=["animal", 0], future_stack=future_stack),
  484:             animal_hair_stacked,
  485:             check_names=False,
  486:         )
  487: 
  488:     @pytest.mark.filterwarnings(
  489:         "ignore:The previous implementation of stack is deprecated"
  490:     )
  491:     def test_stack_int_level_names(self, future_stack):
  492:         columns = MultiIndex.from_tuples(
  493:             [
  494:                 ("A", "cat", "long"),
  495:                 ("B", "cat", "long"),
  496:                 ("A", "dog", "short"),
  497:                 ("B", "dog", "short"),
  498:             ],
  499:             names=["exp", "animal", "hair_length"],
  500:         )
  501:         df = DataFrame(
  502:             np.random.default_rng(2).standard_normal((4, 4)), columns=columns
  503:         )
  504: 
  505:         exp_animal_stacked = df.stack(
  506:             level=["exp", "animal"], future_stack=future_stack
  507:         )
  508:         animal_hair_stacked = df.stack(
  509:             level=["animal", "hair_length"], future_stack=future_stack
  510:         )
  511:         exp_hair_stacked = df.stack(
  512:             level=["exp", "hair_length"], future_stack=future_stack
  513:         )
  514: 
  515:         df2 = df.copy()
  516:         df2.columns.names = [0, 1, 2]
  517:         tm.assert_frame_equal(
  518:             df2.stack(level=[1, 2], future_stack=future_stack),
  519:             animal_hair_stacked,
  520:             check_names=False,
  521:         )
  522:         tm.assert_frame_equal(
  523:             df2.stack(level=[0, 1], future_stack=future_stack),
  524:             exp_animal_stacked,
  525:             check_names=False,
  526:         )
  527:         tm.assert_frame_equal(
  528:             df2.stack(level=[0, 2], future_stack=future_stack),
  529:             exp_hair_stacked,
  530:             check_names=False,
  531:         )
  532: 
  533:         # Out-of-order int column names
  534:         df3 = df.copy()
  535:         df3.columns.names = [2, 0, 1]
  536:         tm.assert_frame_equal(
  537:             df3.stack(level=[0, 1], future_stack=future_stack),
  538:             animal_hair_stacked,
  539:             check_names=False,
  540:         )
  541:         tm.assert_frame_equal(
  542:             df3.stack(level=[2, 0], future_stack=future_stack),
  543:             exp_animal_stacked,
  544:             check_names=False,
  545:         )
  546:         tm.assert_frame_equal(
  547:             df3.stack(level=[2, 1], future_stack=future_stack),
  548:             exp_hair_stacked,
  549:             check_names=False,
  550:         )
  551: 
  552:     def test_unstack_bool(self):
  553:         df = DataFrame(
  554:             [False, False],
  555:             index=MultiIndex.from_arrays([["a", "b"], ["c", "l"]]),
  556:             columns=["col"],
  557:         )
  558:         rs = df.unstack()
  559:         xp = DataFrame(
  560:             np.array([[False, np.nan], [np.nan, False]], dtype=object),
  561:             index=["a", "b"],
  562:             columns=MultiIndex.from_arrays([["col", "col"], ["c", "l"]]),
  563:         )
  564:         tm.assert_frame_equal(rs, xp)
  565: 
  566:     @pytest.mark.filterwarnings(
  567:         "ignore:The previous implementation of stack is deprecated"
  568:     )
  569:     def test_unstack_level_binding(self, future_stack):
  570:         # GH9856
  571:         mi = MultiIndex(
  572:             levels=[["foo", "bar"], ["one", "two"], ["a", "b"]],
  573:             codes=[[0, 0, 1, 1], [0, 1, 0, 1], [1, 0, 1, 0]],
  574:             names=["first", "second", "third"],
  575:         )
  576:         s = Series(0, index=mi)
  577:         result = s.unstack([1, 2]).stack(0, future_stack=future_stack)
  578: 
  579:         expected_mi = MultiIndex(
  580:             levels=[["foo", "bar"], ["one", "two"]],
  581:             codes=[[0, 0, 1, 1], [0, 1, 0, 1]],
  582:             names=["first", "second"],
  583:         )
  584: 
  585:         expected = DataFrame(
  586:             np.array(
  587:                 [[0, np.nan], [np.nan, 0], [0, np.nan], [np.nan, 0]], dtype=np.float64
  588:             ),
  589:             index=expected_mi,
  590:             columns=Index(["b", "a"], name="third"),
  591:         )
  592: 
  593:         tm.assert_frame_equal(result, expected)
  594: 
  595:     def test_unstack_to_series(self, float_frame):
  596:         # check reversibility
  597:         data = float_frame.unstack()
  598: 
  599:         assert isinstance(data, Series)
  600:         undo = data.unstack().T
  601:         tm.assert_frame_equal(undo, float_frame)
  602: 
  603:         # check NA handling
  604:         data = DataFrame({"x": [1, 2, np.nan], "y": [3.0, 4, np.nan]})
  605:         data.index = Index(["a", "b", "c"])
  606:         result = data.unstack()
  607: 
  608:         midx = MultiIndex(
  609:             levels=[["x", "y"], ["a", "b", "c"]],
  610:             codes=[[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]],
  611:         )
  612:         expected = Series([1, 2, np.nan, 3, 4, np.nan], index=midx)
  613: 
  614:         tm.assert_series_equal(result, expected)
  615: 
  616:         # check composability of unstack
  617:         old_data = data.copy()
  618:         for _ in range(4):
  619:             data = data.unstack()
  620:         tm.assert_frame_equal(old_data, data)
  621: 
  622:     def test_unstack_dtypes(self, using_infer_string):
  623:         # GH 2929
  624:         rows = [[1, 1, 3, 4], [1, 2, 3, 4], [2, 1, 3, 4], [2, 2, 3, 4]]
  625: 
  626:         df = DataFrame(rows, columns=list("ABCD"))
  627:         result = df.dtypes
  628:         expected = Series([np.dtype("int64")] * 4, index=list("ABCD"))
  629:         tm.assert_series_equal(result, expected)
  630: 
  631:         # single dtype
  632:         df2 = df.set_index(["A", "B"])
  633:         df3 = df2.unstack("B")
  634:         result = df3.dtypes
  635:         expected = Series(
  636:             [np.dtype("int64")] * 4,
  637:             index=MultiIndex.from_arrays(
  638:                 [["C", "C", "D", "D"], [1, 2, 1, 2]], names=(None, "B")
  639:             ),
  640:         )
  641:         tm.assert_series_equal(result, expected)
  642: 
  643:         # mixed
  644:         df2 = df.set_index(["A", "B"])
  645:         df2["C"] = 3.0
  646:         df3 = df2.unstack("B")
  647:         result = df3.dtypes
  648:         expected = Series(
  649:             [np.dtype("float64")] * 2 + [np.dtype("int64")] * 2,
  650:             index=MultiIndex.from_arrays(
  651:                 [["C", "C", "D", "D"], [1, 2, 1, 2]], names=(None, "B")
  652:             ),
  653:         )
  654:         tm.assert_series_equal(result, expected)
  655:         df2["D"] = "foo"
  656:         df3 = df2.unstack("B")
  657:         result = df3.dtypes
  658:         dtype = "string" if using_infer_string else np.dtype("object")
  659:         expected = Series(
  660:             [np.dtype("float64")] * 2 + [dtype] * 2,
  661:             index=MultiIndex.from_arrays(
  662:                 [["C", "C", "D", "D"], [1, 2, 1, 2]], names=(None, "B")
  663:             ),
  664:         )
  665:         tm.assert_series_equal(result, expected)
  666: 
  667:     @pytest.mark.parametrize(
  668:         "c, d",
  669:         (
  670:             (np.zeros(5), np.zeros(5)),
  671:             (np.arange(5, dtype="f8"), np.arange(5, 10, dtype="f8")),
  672:         ),
  673:     )
  674:     def test_unstack_dtypes_mixed_date(self, c, d):
  675:         # GH7405
  676:         df = DataFrame(
  677:             {
  678:                 "A": ["a"] * 5,
  679:                 "C": c,
  680:                 "D": d,
  681:                 "B": date_range("2012-01-01", periods=5),
  682:             }
  683:         )
  684: 
  685:         right = df.iloc[:3].copy(deep=True)
  686: 
  687:         df = df.set_index(["A", "B"])
  688:         df["D"] = df["D"].astype("int64")
  689: 
  690:         left = df.iloc[:3].unstack(0)
  691:         right = right.set_index(["A", "B"]).unstack(0)
  692:         right[("D", "a")] = right[("D", "a")].astype("int64")
  693: 
  694:         assert left.shape == (3, 2)
  695:         tm.assert_frame_equal(left, right)
  696: 
  697:     @pytest.mark.filterwarnings(
  698:         "ignore:The previous implementation of stack is deprecated"
  699:     )
  700:     def test_unstack_non_unique_index_names(self, future_stack):
  701:         idx = MultiIndex.from_tuples([("a", "b"), ("c", "d")], names=["c1", "c1"])
  702:         df = DataFrame([1, 2], index=idx)
  703:         msg = "The name c1 occurs multiple times, use a level number"
  704:         with pytest.raises(ValueError, match=msg):
  705:             df.unstack("c1")
  706: 
  707:         with pytest.raises(ValueError, match=msg):
  708:             df.T.stack("c1", future_stack=future_stack)
  709: 
  710:     def test_unstack_unused_levels(self):
  711:         # GH 17845: unused codes in index make unstack() cast int to float
  712:         idx = MultiIndex.from_product([["a"], ["A", "B", "C", "D"]])[:-1]
  713:         df = DataFrame([[1, 0]] * 3, index=idx)
  714: 
  715:         result = df.unstack()
  716:         exp_col = MultiIndex.from_product([[0, 1], ["A", "B", "C"]])
  717:         expected = DataFrame([[1, 1, 1, 0, 0, 0]], index=["a"], columns=exp_col)
  718:         tm.assert_frame_equal(result, expected)
  719:         assert (result.columns.levels[1] == idx.levels[1]).all()
  720: 
  721:         # Unused items on both levels
  722:         levels = [[0, 1, 7], [0, 1, 2, 3]]
  723:         codes = [[0, 0, 1, 1], [0, 2, 0, 2]]
  724:         idx = MultiIndex(levels, codes)
  725:         block = np.arange(4).reshape(2, 2)
  726:         df = DataFrame(np.concatenate([block, block + 4]), index=idx)
  727:         result = df.unstack()
  728:         expected = DataFrame(
  729:             np.concatenate([block * 2, block * 2 + 1], axis=1), columns=idx
  730:         )
  731:         tm.assert_frame_equal(result, expected)
  732:         assert (result.columns.levels[1] == idx.levels[1]).all()
  733: 
  734:     @pytest.mark.parametrize(
  735:         "level, idces, col_level, idx_level",
  736:         (
  737:             (0, [13, 16, 6, 9, 2, 5, 8, 11], [np.nan, "a", 2], [np.nan, 5, 1]),
  738:             (1, [8, 11, 1, 4, 12, 15, 13, 16], [np.nan, 5, 1], [np.nan, "a", 2]),
  739:         ),
  740:     )
  741:     def test_unstack_unused_levels_mixed_with_nan(
  742:         self, level, idces, col_level, idx_level
  743:     ):
  744:         # With mixed dtype and NaN
  745:         levels = [["a", 2, "c"], [1, 3, 5, 7]]
  746:         codes = [[0, -1, 1, 1], [0, 2, -1, 2]]
  747:         idx = MultiIndex(levels, codes)
  748:         data = np.arange(8)
  749:         df = DataFrame(data.reshape(4, 2), index=idx)
  750: 
  751:         result = df.unstack(level=level)
  752:         exp_data = np.zeros(18) * np.nan
  753:         exp_data[idces] = data
  754:         cols = MultiIndex.from_product([[0, 1], col_level])
  755:         expected = DataFrame(exp_data.reshape(3, 6), index=idx_level, columns=cols)
  756:         tm.assert_frame_equal(result, expected)
  757: 
  758:     @pytest.mark.parametrize("cols", [["A", "C"], slice(None)])
  759:     def test_unstack_unused_level(self, cols):
  760:         # GH 18562 : unused codes on the unstacked level
  761:         df = DataFrame([[2010, "a", "I"], [2011, "b", "II"]], columns=["A", "B", "C"])
  762: 
  763:         ind = df.set_index(["A", "B", "C"], drop=False)
  764:         selection = ind.loc[(slice(None), slice(None), "I"), cols]
  765:         result = selection.unstack()
  766: 
  767:         expected = ind.iloc[[0]][cols]
  768:         expected.columns = MultiIndex.from_product(
  769:             [expected.columns, ["I"]], names=[None, "C"]
  770:         )
  771:         expected.index = expected.index.droplevel("C")
  772:         tm.assert_frame_equal(result, expected)
  773: 
  774:     def test_unstack_long_index(self):
  775:         # PH 32624: Error when using a lot of indices to unstack.
  776:         # The error occurred only, if a lot of indices are used.
  777:         df = DataFrame(
  778:             [[1]],
  779:             columns=MultiIndex.from_tuples([[0]], names=["c1"]),
  780:             index=MultiIndex.from_tuples(
  781:                 [[0, 0, 1, 0, 0, 0, 1]],
  782:                 names=["i1", "i2", "i3", "i4", "i5", "i6", "i7"],
  783:             ),
  784:         )
  785:         result = df.unstack(["i2", "i3", "i4", "i5", "i6", "i7"])
  786:         expected = DataFrame(
  787:             [[1]],
  788:             columns=MultiIndex.from_tuples(
  789:                 [[0, 0, 1, 0, 0, 0, 1]],
  790:                 names=["c1", "i2", "i3", "i4", "i5", "i6", "i7"],
  791:             ),
  792:             index=Index([0], name="i1"),
  793:         )
  794:         tm.assert_frame_equal(result, expected)
  795: 
  796:     def test_unstack_multi_level_cols(self):
  797:         # PH 24729: Unstack a df with multi level columns
  798:         df = DataFrame(
  799:             [[0.0, 0.0], [0.0, 0.0]],
  800:             columns=MultiIndex.from_tuples(
  801:                 [["B", "C"], ["B", "D"]], names=["c1", "c2"]
  802:             ),
  803:             index=MultiIndex.from_tuples(
  804:                 [[10, 20, 30], [10, 20, 40]], names=["i1", "i2", "i3"]
  805:             ),
  806:         )
  807:         assert df.unstack(["i2", "i1"]).columns.names[-2:] == ["i2", "i1"]
  808: 
  809:     def test_unstack_multi_level_rows_and_cols(self):
  810:         # PH 28306: Unstack df with multi level cols and rows
  811:         df = DataFrame(
  812:             [[1, 2], [3, 4], [-1, -2], [-3, -4]],
  813:             columns=MultiIndex.from_tuples([["a", "b", "c"], ["d", "e", "f"]]),
  814:             index=MultiIndex.from_tuples(
  815:                 [
  816:                     ["m1", "P3", 222],
  817:                     ["m1", "A5", 111],
  818:                     ["m2", "P3", 222],
  819:                     ["m2", "A5", 111],
  820:                 ],
  821:                 names=["i1", "i2", "i3"],
  822:             ),
  823:         )
  824:         result = df.unstack(["i3", "i2"])
  825:         expected = df.unstack(["i3"]).unstack(["i2"])
  826:         tm.assert_frame_equal(result, expected)
  827: 
  828:     @pytest.mark.parametrize("idx", [("jim", "joe"), ("joe", "jim")])
  829:     @pytest.mark.parametrize("lev", list(range(2)))
  830:     def test_unstack_nan_index1(self, idx, lev):
  831:         # GH7466
  832:         def cast(val):
  833:             val_str = "" if val != val else val
  834:             return f"{val_str:1}"
  835: 
  836:         df = DataFrame(
  837:             {
  838:                 "jim": ["a", "b", np.nan, "d"],
  839:                 "joe": ["w", "x", "y", "z"],
  840:                 "jolie": ["a.w", "b.x", " .y", "d.z"],
  841:             }
  842:         )
  843: 
  844:         left = df.set_index(["jim", "joe"]).unstack()["jolie"]
  845:         right = df.set_index(["joe", "jim"]).unstack()["jolie"].T
  846:         tm.assert_frame_equal(left, right)
  847: 
  848:         mi = df.set_index(list(idx))
  849:         udf = mi.unstack(level=lev)
  850:         assert udf.notna().values.sum() == len(df)
  851:         mk_list = lambda a: list(a) if isinstance(a, tuple) else [a]
  852:         rows, cols = udf["jolie"].notna().values.nonzero()
  853:         for i, j in zip(rows, cols):
  854:             left = sorted(udf["jolie"].iloc[i, j].split("."))
  855:             right = mk_list(udf["jolie"].index[i]) + mk_list(udf["jolie"].columns[j])
  856:             right = sorted(map(cast, right))
  857:             assert left == right
  858: 
  859:     @pytest.mark.parametrize("idx", itertools.permutations(["1st", "2nd", "3rd"]))
  860:     @pytest.mark.parametrize("lev", list(range(3)))
  861:     @pytest.mark.parametrize("col", ["4th", "5th"])
  862:     def test_unstack_nan_index_repeats(self, idx, lev, col):
  863:         def cast(val):
  864:             val_str = "" if val != val else val
  865:             return f"{val_str:1}"
  866: 
  867:         df = DataFrame(
  868:             {
  869:                 "1st": ["d"] * 3
  870:                 + [np.nan] * 5
  871:                 + ["a"] * 2
  872:                 + ["c"] * 3
  873:                 + ["e"] * 2
  874:                 + ["b"] * 5,
  875:                 "2nd": ["y"] * 2
  876:                 + ["w"] * 3
  877:                 + [np.nan] * 3
  878:                 + ["z"] * 4
  879:                 + [np.nan] * 3
  880:                 + ["x"] * 3
  881:                 + [np.nan] * 2,
  882:                 "3rd": [
  883:                     67,
  884:                     39,
  885:                     53,
  886:                     72,
  887:                     57,
  888:                     80,
  889:                     31,
  890:                     18,
  891:                     11,
  892:                     30,
  893:                     59,
  894:                     50,
  895:                     62,
  896:                     59,
  897:                     76,
  898:                     52,
  899:                     14,
  900:                     53,
  901:                     60,
  902:                     51,
  903:                 ],
  904:             }
  905:         )
  906: 
  907:         df["4th"], df["5th"] = (
  908:             df.apply(lambda r: ".".join(map(cast, r)), axis=1),
  909:             df.apply(lambda r: ".".join(map(cast, r.iloc[::-1])), axis=1),
  910:         )
  911: 
  912:         mi = df.set_index(list(idx))
  913:         udf = mi.unstack(level=lev)
  914:         assert udf.notna().values.sum() == 2 * len(df)
  915:         mk_list = lambda a: list(a) if isinstance(a, tuple) else [a]
  916:         rows, cols = udf[col].notna().values.nonzero()
  917:         for i, j in zip(rows, cols):
  918:             left = sorted(udf[col].iloc[i, j].split("."))
  919:             right = mk_list(udf[col].index[i]) + mk_list(udf[col].columns[j])
  920:             right = sorted(map(cast, right))
  921:             assert left == right
  922: 
  923:     def test_unstack_nan_index2(self):
  924:         # GH7403
  925:         df = DataFrame({"A": list("aaaabbbb"), "B": range(8), "C": range(8)})
  926:         # Explicit cast to avoid implicit cast when setting to np.nan
  927:         df = df.astype({"B": "float"})
  928:         df.iloc[3, 1] = np.nan
  929:         left = df.set_index(["A", "B"]).unstack(0)
  930: 
  931:         vals = [
  932:             [3, 0, 1, 2, np.nan, np.nan, np.nan, np.nan],
  933:             [np.nan, np.nan, np.nan, np.nan, 4, 5, 6, 7],
  934:         ]
  935:         vals = list(map(list, zip(*vals)))
  936:         idx = Index([np.nan, 0, 1, 2, 4, 5, 6, 7], name="B")
  937:         cols = MultiIndex(
  938:             levels=[["C"], ["a", "b"]], codes=[[0, 0], [0, 1]], names=[None, "A"]
  939:         )
  940: 
  941:         right = DataFrame(vals, columns=cols, index=idx)
  942:         tm.assert_frame_equal(left, right)
  943: 
  944:         df = DataFrame({"A": list("aaaabbbb"), "B": list(range(4)) * 2, "C": range(8)})
  945:         # Explicit cast to avoid implicit cast when setting to np.nan
  946:         df = df.astype({"B": "float"})
  947:         df.iloc[2, 1] = np.nan
  948:         left = df.set_index(["A", "B"]).unstack(0)
  949: 
  950:         vals = [[2, np.nan], [0, 4], [1, 5], [np.nan, 6], [3, 7]]
  951:         cols = MultiIndex(
  952:             levels=[["C"], ["a", "b"]], codes=[[0, 0], [0, 1]], names=[None, "A"]
  953:         )
  954:         idx = Index([np.nan, 0, 1, 2, 3], name="B")
  955:         right = DataFrame(vals, columns=cols, index=idx)
  956:         tm.assert_frame_equal(left, right)
  957: 
  958:         df = DataFrame({"A": list("aaaabbbb"), "B": list(range(4)) * 2, "C": range(8)})
  959:         # Explicit cast to avoid implicit cast when setting to np.nan
  960:         df = df.astype({"B": "float"})
  961:         df.iloc[3, 1] = np.nan
  962:         left = df.set_index(["A", "B"]).unstack(0)
  963: 
  964:         vals = [[3, np.nan], [0, 4], [1, 5], [2, 6], [np.nan, 7]]
  965:         cols = MultiIndex(
  966:             levels=[["C"], ["a", "b"]], codes=[[0, 0], [0, 1]], names=[None, "A"]
  967:         )
  968:         idx = Index([np.nan, 0, 1, 2, 3], name="B")
  969:         right = DataFrame(vals, columns=cols, index=idx)
  970:         tm.assert_frame_equal(left, right)
  971: 
  972:     def test_unstack_nan_index3(self, using_array_manager):
  973:         # GH7401
  974:         df = DataFrame(
  975:             {
  976:                 "A": list("aaaaabbbbb"),
  977:                 "B": (date_range("2012-01-01", periods=5).tolist() * 2),
  978:                 "C": np.arange(10),
  979:             }
  980:         )
  981: 
  982:         df.iloc[3, 1] = np.nan
  983:         left = df.set_index(["A", "B"]).unstack()
  984: 
  985:         vals = np.array([[3, 0, 1, 2, np.nan, 4], [np.nan, 5, 6, 7, 8, 9]])
  986:         idx = Index(["a", "b"], name="A")
  987:         cols = MultiIndex(
  988:             levels=[["C"], date_range("2012-01-01", periods=5)],
  989:             codes=[[0, 0, 0, 0, 0, 0], [-1, 0, 1, 2, 3, 4]],
  990:             names=[None, "B"],
  991:         )
  992: 
  993:         right = DataFrame(vals, columns=cols, index=idx)
  994:         if using_array_manager:
  995:             # INFO(ArrayManager) with ArrayManager preserve dtype where possible
  996:             cols = right.columns[[1, 2, 3, 5]]
  997:             right[cols] = right[cols].astype(df["C"].dtype)
  998:         tm.assert_frame_equal(left, right)
  999: 
 1000:     def test_unstack_nan_index4(self):
 1001:         # GH4862
 1002:         vals = [
 1003:             ["Hg", np.nan, np.nan, 680585148],
 1004:             ["U", 0.0, np.nan, 680585148],
 1005:             ["Pb", 7.07e-06, np.nan, 680585148],
 1006:             ["Sn", 2.3614e-05, 0.0133, 680607017],
 1007:             ["Ag", 0.0, 0.0133, 680607017],
 1008:             ["Hg", -0.00015, 0.0133, 680607017],
 1009:         ]
 1010:         df = DataFrame(
 1011:             vals,
 1012:             columns=["agent", "change", "dosage", "s_id"],
 1013:             index=[17263, 17264, 17265, 17266, 17267, 17268],
 1014:         )
 1015: 
 1016:         left = df.copy().set_index(["s_id", "dosage", "agent"]).unstack()
 1017: 
 1018:         vals = [
 1019:             [np.nan, np.nan, 7.07e-06, np.nan, 0.0],
 1020:             [0.0, -0.00015, np.nan, 2.3614e-05, np.nan],
 1021:         ]
 1022: 
 1023:         idx = MultiIndex(
 1024:             levels=[[680585148, 680607017], [0.0133]],
 1025:             codes=[[0, 1], [-1, 0]],
 1026:             names=["s_id", "dosage"],
 1027:         )
 1028: 
 1029:         cols = MultiIndex(
 1030:             levels=[["change"], ["Ag", "Hg", "Pb", "Sn", "U"]],
 1031:             codes=[[0, 0, 0, 0, 0], [0, 1, 2, 3, 4]],
 1032:             names=[None, "agent"],
 1033:         )
 1034: 
 1035:         right = DataFrame(vals, columns=cols, index=idx)
 1036:         tm.assert_frame_equal(left, right)
 1037: 
 1038:         left = df.loc[17264:].copy().set_index(["s_id", "dosage", "agent"])
 1039:         tm.assert_frame_equal(left.unstack(), right)
 1040: 
 1041:     def test_unstack_nan_index5(self):
 1042:         # GH9497 - multiple unstack with nulls
 1043:         df = DataFrame(
 1044:             {
 1045:                 "1st": [1, 2, 1, 2, 1, 2],
 1046:                 "2nd": date_range("2014-02-01", periods=6, freq="D"),
 1047:                 "jim": 100 + np.arange(6),
 1048:                 "joe": (np.random.default_rng(2).standard_normal(6) * 10).round(2),
 1049:             }
 1050:         )
 1051: 
 1052:         df["3rd"] = df["2nd"] - pd.Timestamp("2014-02-02")
 1053:         df.loc[1, "2nd"] = df.loc[3, "2nd"] = np.nan
 1054:         df.loc[1, "3rd"] = df.loc[4, "3rd"] = np.nan
 1055: 
 1056:         left = df.set_index(["1st", "2nd", "3rd"]).unstack(["2nd", "3rd"])
 1057:         assert left.notna().values.sum() == 2 * len(df)
 1058: 
 1059:         for col in ["jim", "joe"]:
 1060:             for _, r in df.iterrows():
 1061:                 key = r["1st"], (col, r["2nd"], r["3rd"])
 1062:                 assert r[col] == left.loc[key]
 1063: 
 1064:     def test_stack_datetime_column_multiIndex(self, future_stack):
 1065:         # GH 8039
 1066:         t = datetime(2014, 1, 1)
 1067:         df = DataFrame([1, 2, 3, 4], columns=MultiIndex.from_tuples([(t, "A", "B")]))
 1068:         warn = None if future_stack else FutureWarning
 1069:         msg = "The previous implementation of stack is deprecated"
 1070:         with tm.assert_produces_warning(warn, match=msg):
 1071:             result = df.stack(future_stack=future_stack)
 1072: 
 1073:         eidx = MultiIndex.from_product([(0, 1, 2, 3), ("B",)])
 1074:         ecols = MultiIndex.from_tuples([(t, "A")])
 1075:         expected = DataFrame([1, 2, 3, 4], index=eidx, columns=ecols)
 1076:         tm.assert_frame_equal(result, expected)
 1077: 
 1078:     @pytest.mark.filterwarnings(
 1079:         "ignore:The previous implementation of stack is deprecated"
 1080:     )
 1081:     @pytest.mark.parametrize(
 1082:         "multiindex_columns",
 1083:         [
 1084:             [0, 1, 2, 3, 4],
 1085:             [0, 1, 2, 3],
 1086:             [0, 1, 2, 4],
 1087:             [0, 1, 2],
 1088:             [1, 2, 3],
 1089:             [2, 3, 4],
 1090:             [0, 1],
 1091:             [0, 2],
 1092:             [0, 3],
 1093:             [0],
 1094:             [2],
 1095:             [4],
 1096:             [4, 3, 2, 1, 0],
 1097:             [3, 2, 1, 0],
 1098:             [4, 2, 1, 0],
 1099:             [2, 1, 0],
 1100:             [3, 2, 1],
 1101:             [4, 3, 2],
 1102:             [1, 0],
 1103:             [2, 0],
 1104:             [3, 0],
 1105:         ],
 1106:     )
 1107:     @pytest.mark.parametrize("level", (-1, 0, 1, [0, 1], [1, 0]))
 1108:     def test_stack_partial_multiIndex(self, multiindex_columns, level, future_stack):
 1109:         # GH 8844
 1110:         dropna = False if not future_stack else lib.no_default
 1111:         full_multiindex = MultiIndex.from_tuples(
 1112:             [("B", "x"), ("B", "z"), ("A", "y"), ("C", "x"), ("C", "u")],
 1113:             names=["Upper", "Lower"],
 1114:         )
 1115:         multiindex = full_multiindex[multiindex_columns]
 1116:         df = DataFrame(
 1117:             np.arange(3 * len(multiindex)).reshape(3, len(multiindex)),
 1118:             columns=multiindex,
 1119:         )
 1120:         result = df.stack(level=level, dropna=dropna, future_stack=future_stack)
 1121: 
 1122:         if isinstance(level, int) and not future_stack:
 1123:             # Stacking a single level should not make any all-NaN rows,
 1124:             # so df.stack(level=level, dropna=False) should be the same
 1125:             # as df.stack(level=level, dropna=True).
 1126:             expected = df.stack(level=level, dropna=True, future_stack=future_stack)
 1127:             if isinstance(expected, Series):
 1128:                 tm.assert_series_equal(result, expected)
 1129:             else:
 1130:                 tm.assert_frame_equal(result, expected)
 1131: 
 1132:         df.columns = MultiIndex.from_tuples(
 1133:             df.columns.to_numpy(), names=df.columns.names
 1134:         )
 1135:         expected = df.stack(level=level, dropna=dropna, future_stack=future_stack)
 1136:         if isinstance(expected, Series):
 1137:             tm.assert_series_equal(result, expected)
 1138:         else:
 1139:             tm.assert_frame_equal(result, expected)
 1140: 
 1141:     @pytest.mark.filterwarnings(
 1142:         "ignore:The previous implementation of stack is deprecated"
 1143:     )
 1144:     def test_stack_full_multiIndex(self, future_stack):
 1145:         # GH 8844
 1146:         full_multiindex = MultiIndex.from_tuples(
 1147:             [("B", "x"), ("B", "z"), ("A", "y"), ("C", "x"), ("C", "u")],
 1148:             names=["Upper", "Lower"],
 1149:         )
 1150:         df = DataFrame(np.arange(6).reshape(2, 3), columns=full_multiindex[[0, 1, 3]])
 1151:         dropna = False if not future_stack else lib.no_default
 1152:         result = df.stack(dropna=dropna, future_stack=future_stack)
 1153:         expected = DataFrame(
 1154:             [[0, 2], [1, np.nan], [3, 5], [4, np.nan]],
 1155:             index=MultiIndex(
 1156:                 levels=[[0, 1], ["u", "x", "y", "z"]],
 1157:                 codes=[[0, 0, 1, 1], [1, 3, 1, 3]],
 1158:                 names=[None, "Lower"],
 1159:             ),
 1160:             columns=Index(["B", "C"], name="Upper"),
 1161:         )
 1162:         expected["B"] = expected["B"].astype(df.dtypes.iloc[0])
 1163:         tm.assert_frame_equal(result, expected)
 1164: 
 1165:     @pytest.mark.parametrize("ordered", [False, True])
 1166:     def test_stack_preserve_categorical_dtype(self, ordered, future_stack):
 1167:         # GH13854
 1168:         cidx = pd.CategoricalIndex(list("yxz"), categories=list("xyz"), ordered=ordered)
 1169:         df = DataFrame([[10, 11, 12]], columns=cidx)
 1170:         result = df.stack(future_stack=future_stack)
 1171: 
 1172:         # `MultiIndex.from_product` preserves categorical dtype -
 1173:         # it's tested elsewhere.
 1174:         midx = MultiIndex.from_product([df.index, cidx])
 1175:         expected = Series([10, 11, 12], index=midx)
 1176: 
 1177:         tm.assert_series_equal(result, expected)
 1178: 
 1179:     @pytest.mark.filterwarnings(
 1180:         "ignore:The previous implementation of stack is deprecated"
 1181:     )
 1182:     @pytest.mark.parametrize("ordered", [False, True])
 1183:     @pytest.mark.parametrize(
 1184:         "labels,data",
 1185:         [
 1186:             (list("xyz"), [10, 11, 12, 13, 14, 15]),
 1187:             (list("zyx"), [14, 15, 12, 13, 10, 11]),
 1188:         ],
 1189:     )
 1190:     def test_stack_multi_preserve_categorical_dtype(
 1191:         self, ordered, labels, data, future_stack
 1192:     ):
 1193:         # GH-36991
 1194:         cidx = pd.CategoricalIndex(labels, categories=sorted(labels), ordered=ordered)
 1195:         cidx2 = pd.CategoricalIndex(["u", "v"], ordered=ordered)
 1196:         midx = MultiIndex.from_product([cidx, cidx2])
 1197:         df = DataFrame([sorted(data)], columns=midx)
 1198:         result = df.stack([0, 1], future_stack=future_stack)
 1199: 
 1200:         labels = labels if future_stack else sorted(labels)
 1201:         s_cidx = pd.CategoricalIndex(labels, ordered=ordered)
 1202:         expected_data = sorted(data) if future_stack else data
 1203:         expected = Series(
 1204:             expected_data, index=MultiIndex.from_product([[0], s_cidx, cidx2])
 1205:         )
 1206: 
 1207:         tm.assert_series_equal(result, expected)
 1208: 
 1209:     def test_stack_preserve_categorical_dtype_values(self, future_stack):
 1210:         # GH-23077
 1211:         cat = pd.Categorical(["a", "a", "b", "c"])
 1212:         df = DataFrame({"A": cat, "B": cat})
 1213:         result = df.stack(future_stack=future_stack)
 1214:         index = MultiIndex.from_product([[0, 1, 2, 3], ["A", "B"]])
 1215:         expected = Series(
 1216:             pd.Categorical(["a", "a", "a", "a", "b", "b", "c", "c"]), index=index
 1217:         )
 1218:         tm.assert_series_equal(result, expected)
 1219: 
 1220:     @pytest.mark.filterwarnings(
 1221:         "ignore:The previous implementation of stack is deprecated"
 1222:     )
 1223:     @pytest.mark.filterwarnings("ignore:Downcasting object dtype arrays:FutureWarning")
 1224:     @pytest.mark.parametrize(
 1225:         "index, columns",
 1226:         [
 1227:             ([0, 0, 1, 1], MultiIndex.from_product([[1, 2], ["a", "b"]])),
 1228:             ([0, 0, 2, 3], MultiIndex.from_product([[1, 2], ["a", "b"]])),
 1229:             ([0, 1, 2, 3], MultiIndex.from_product([[1, 2], ["a", "b"]])),
 1230:         ],
 1231:     )
 1232:     def test_stack_multi_columns_non_unique_index(self, index, columns, future_stack):
 1233:         # GH-28301
 1234: 
 1235:         df = DataFrame(index=index, columns=columns).fillna(1)
 1236:         stacked = df.stack(future_stack=future_stack)
 1237:         new_index = MultiIndex.from_tuples(stacked.index.to_numpy())
 1238:         expected = DataFrame(
 1239:             stacked.to_numpy(), index=new_index, columns=stacked.columns
 1240:         )
 1241:         tm.assert_frame_equal(stacked, expected)
 1242:         stacked_codes = np.asarray(stacked.index.codes)
 1243:         expected_codes = np.asarray(new_index.codes)
 1244:         tm.assert_numpy_array_equal(stacked_codes, expected_codes)
 1245: 
 1246:     @pytest.mark.filterwarnings(
 1247:         "ignore:The previous implementation of stack is deprecated"
 1248:     )
 1249:     @pytest.mark.parametrize(
 1250:         "vals1, vals2, dtype1, dtype2, expected_dtype",
 1251:         [
 1252:             ([1, 2], [3.0, 4.0], "Int64", "Float64", "Float64"),
 1253:             ([1, 2], ["foo", "bar"], "Int64", "string", "object"),
 1254:         ],
 1255:     )
 1256:     def test_stack_multi_columns_mixed_extension_types(
 1257:         self, vals1, vals2, dtype1, dtype2, expected_dtype, future_stack
 1258:     ):
 1259:         # GH45740
 1260:         df = DataFrame(
 1261:             {
 1262:                 ("A", 1): Series(vals1, dtype=dtype1),
 1263:                 ("A", 2): Series(vals2, dtype=dtype2),
 1264:             }
 1265:         )
 1266:         result = df.stack(future_stack=future_stack)
 1267:         expected = (
 1268:             df.astype(object).stack(future_stack=future_stack).astype(expected_dtype)
 1269:         )
 1270:         tm.assert_frame_equal(result, expected)
 1271: 
 1272:     @pytest.mark.parametrize("level", [0, 1])
 1273:     def test_unstack_mixed_extension_types(self, level):
 1274:         index = MultiIndex.from_tuples([("A", 0), ("A", 1), ("B", 1)], names=["a", "b"])
 1275:         df = DataFrame(
 1276:             {
 1277:                 "A": pd.array([0, 1, None], dtype="Int64"),
 1278:                 "B": pd.Categorical(["a", "a", "b"]),
 1279:             },
 1280:             index=index,
 1281:         )
 1282: 
 1283:         result = df.unstack(level=level)
 1284:         expected = df.astype(object).unstack(level=level)
 1285:         if level == 0:
 1286:             expected[("A", "B")] = expected[("A", "B")].fillna(pd.NA)
 1287:         else:
 1288:             expected[("A", 0)] = expected[("A", 0)].fillna(pd.NA)
 1289: 
 1290:         expected_dtypes = Series(
 1291:             [df.A.dtype] * 2 + [df.B.dtype] * 2, index=result.columns
 1292:         )
 1293:         tm.assert_series_equal(result.dtypes, expected_dtypes)
 1294:         tm.assert_frame_equal(result.astype(object), expected)
 1295: 
 1296:     @pytest.mark.parametrize("level", [0, "baz"])
 1297:     def test_unstack_swaplevel_sortlevel(self, level):
 1298:         # GH 20994
 1299:         mi = MultiIndex.from_product([[0], ["d", "c"]], names=["bar", "baz"])
 1300:         df = DataFrame([[0, 2], [1, 3]], index=mi, columns=["B", "A"])
 1301:         df.columns.name = "foo"
 1302: 
 1303:         expected = DataFrame(
 1304:             [[3, 1, 2, 0]],
 1305:             columns=MultiIndex.from_tuples(
 1306:                 [("c", "A"), ("c", "B"), ("d", "A"), ("d", "B")], names=["baz", "foo"]
 1307:             ),
 1308:         )
 1309:         expected.index.name = "bar"
 1310: 
 1311:         result = df.unstack().swaplevel(axis=1).sort_index(axis=1, level=level)
 1312:         tm.assert_frame_equal(result, expected)
 1313: 
 1314: 
 1315: @pytest.mark.parametrize("dtype", ["float64", "Float64"])
 1316: def test_unstack_sort_false(frame_or_series, dtype):
 1317:     # GH 15105
 1318:     index = MultiIndex.from_tuples(
 1319:         [("two", "z", "b"), ("two", "y", "a"), ("one", "z", "b"), ("one", "y", "a")]
 1320:     )
 1321:     obj = frame_or_series(np.arange(1.0, 5.0), index=index, dtype=dtype)
 1322:     result = obj.unstack(level=-1, sort=False)
 1323: 
 1324:     if frame_or_series is DataFrame:
 1325:         expected_columns = MultiIndex.from_tuples([(0, "b"), (0, "a")])
 1326:     else:
 1327:         expected_columns = ["b", "a"]
 1328:     expected = DataFrame(
 1329:         [[1.0, np.nan], [np.nan, 2.0], [3.0, np.nan], [np.nan, 4.0]],
 1330:         columns=expected_columns,
 1331:         index=MultiIndex.from_tuples(
 1332:             [("two", "z"), ("two", "y"), ("one", "z"), ("one", "y")]
 1333:         ),
 1334:         dtype=dtype,
 1335:     )
 1336:     tm.assert_frame_equal(result, expected)
 1337: 
 1338:     result = obj.unstack(level=[1, 2], sort=False)
 1339: 
 1340:     if frame_or_series is DataFrame:
 1341:         expected_columns = MultiIndex.from_tuples([(0, "z", "b"), (0, "y", "a")])
 1342:     else:
 1343:         expected_columns = MultiIndex.from_tuples([("z", "b"), ("y", "a")])
 1344:     expected = DataFrame(
 1345:         [[1.0, 2.0], [3.0, 4.0]],
 1346:         index=["two", "one"],
 1347:         columns=expected_columns,
 1348:         dtype=dtype,
 1349:     )
 1350:     tm.assert_frame_equal(result, expected)
 1351: 
 1352: 
 1353: def test_unstack_fill_frame_object():
 1354:     # GH12815 Test unstacking with object.
 1355:     data = Series(["a", "b", "c", "a"], dtype="object")
 1356:     data.index = MultiIndex.from_tuples(
 1357:         [("x", "a"), ("x", "b"), ("y", "b"), ("z", "a")]
 1358:     )
 1359: 
 1360:     # By default missing values will be NaN
 1361:     result = data.unstack()
 1362:     expected = DataFrame(
 1363:         {"a": ["a", np.nan, "a"], "b": ["b", "c", np.nan]},
 1364:         index=list("xyz"),
 1365:         dtype=object,
 1366:     )
 1367:     tm.assert_frame_equal(result, expected)
 1368: 
 1369:     # Fill with any value replaces missing values as expected
 1370:     result = data.unstack(fill_value="d")
 1371:     expected = DataFrame(
 1372:         {"a": ["a", "d", "a"], "b": ["b", "c", "d"]}, index=list("xyz"), dtype=object
 1373:     )
 1374:     tm.assert_frame_equal(result, expected)
 1375: 
 1376: 
 1377: def test_unstack_timezone_aware_values():
 1378:     # GH 18338
 1379:     df = DataFrame(
 1380:         {
 1381:             "timestamp": [pd.Timestamp("2017-08-27 01:00:00.709949+0000", tz="UTC")],
 1382:             "a": ["a"],
 1383:             "b": ["b"],
 1384:             "c": ["c"],
 1385:         },
 1386:         columns=["timestamp", "a", "b", "c"],
 1387:     )
 1388:     result = df.set_index(["a", "b"]).unstack()
 1389:     expected = DataFrame(
 1390:         [[pd.Timestamp("2017-08-27 01:00:00.709949+0000", tz="UTC"), "c"]],
 1391:         index=Index(["a"], name="a"),
 1392:         columns=MultiIndex(
 1393:             levels=[["timestamp", "c"], ["b"]],
 1394:             codes=[[0, 1], [0, 0]],
 1395:             names=[None, "b"],
 1396:         ),
 1397:     )
 1398:     tm.assert_frame_equal(result, expected)
 1399: 
 1400: 
 1401: def test_stack_timezone_aware_values(future_stack):
 1402:     # GH 19420
 1403:     ts = date_range(freq="D", start="20180101", end="20180103", tz="America/New_York")
 1404:     df = DataFrame({"A": ts}, index=["a", "b", "c"])
 1405:     result = df.stack(future_stack=future_stack)
 1406:     expected = Series(
 1407:         ts,
 1408:         index=MultiIndex(levels=[["a", "b", "c"], ["A"]], codes=[[0, 1, 2], [0, 0, 0]]),
 1409:     )
 1410:     tm.assert_series_equal(result, expected)
 1411: 
 1412: 
 1413: @pytest.mark.filterwarnings("ignore:The previous implementation of stack is deprecated")
 1414: @pytest.mark.parametrize("dropna", [True, False, lib.no_default])
 1415: def test_stack_empty_frame(dropna, future_stack):
 1416:     # GH 36113
 1417:     levels = [np.array([], dtype=np.int64), np.array([], dtype=np.int64)]
 1418:     expected = Series(dtype=np.float64, index=MultiIndex(levels=levels, codes=[[], []]))
 1419:     if future_stack and dropna is not lib.no_default:
 1420:         with pytest.raises(ValueError, match="dropna must be unspecified"):
 1421:             DataFrame(dtype=np.float64).stack(dropna=dropna, future_stack=future_stack)
 1422:     else:
 1423:         result = DataFrame(dtype=np.float64).stack(
 1424:             dropna=dropna, future_stack=future_stack
 1425:         )
 1426:         tm.assert_series_equal(result, expected)
 1427: 
 1428: 
 1429: @pytest.mark.filterwarnings("ignore:The previous implementation of stack is deprecated")
 1430: @pytest.mark.parametrize("dropna", [True, False, lib.no_default])
 1431: @pytest.mark.parametrize("fill_value", [None, 0])
 1432: def test_stack_unstack_empty_frame(dropna, fill_value, future_stack):
 1433:     # GH 36113
 1434:     if future_stack and dropna is not lib.no_default:
 1435:         with pytest.raises(ValueError, match="dropna must be unspecified"):
 1436:             DataFrame(dtype=np.int64).stack(
 1437:                 dropna=dropna, future_stack=future_stack
 1438:             ).unstack(fill_value=fill_value)
 1439:     else:
 1440:         result = (
 1441:             DataFrame(dtype=np.int64)
 1442:             .stack(dropna=dropna, future_stack=future_stack)
 1443:             .unstack(fill_value=fill_value)
 1444:         )
 1445:         expected = DataFrame(dtype=np.int64)
 1446:         tm.assert_frame_equal(result, expected)
 1447: 
 1448: 
 1449: def test_unstack_single_index_series():
 1450:     # GH 36113
 1451:     msg = r"index must be a MultiIndex to unstack.*"
 1452:     with pytest.raises(ValueError, match=msg):
 1453:         Series(dtype=np.int64).unstack()
 1454: 
 1455: 
 1456: def test_unstacking_multi_index_df():
 1457:     # see gh-30740
 1458:     df = DataFrame(
 1459:         {
 1460:             "name": ["Alice", "Bob"],
 1461:             "score": [9.5, 8],
 1462:             "employed": [False, True],
 1463:             "kids": [0, 0],
 1464:             "gender": ["female", "male"],
 1465:         }
 1466:     )
 1467:     df = df.set_index(["name", "employed", "kids", "gender"])
 1468:     df = df.unstack(["gender"], fill_value=0)
 1469:     expected = df.unstack("employed", fill_value=0).unstack("kids", fill_value=0)
 1470:     result = df.unstack(["employed", "kids"], fill_value=0)
 1471:     expected = DataFrame(
 1472:         [[9.5, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 8.0]],
 1473:         index=Index(["Alice", "Bob"], name="name"),
 1474:         columns=MultiIndex.from_tuples(
 1475:             [
 1476:                 ("score", "female", False, 0),
 1477:                 ("score", "female", True, 0),
 1478:                 ("score", "male", False, 0),
 1479:                 ("score", "male", True, 0),
 1480:             ],
 1481:             names=[None, "gender", "employed", "kids"],
 1482:         ),
 1483:     )
 1484:     tm.assert_frame_equal(result, expected)
 1485: 
 1486: 
 1487: @pytest.mark.filterwarnings("ignore:The previous implementation of stack is deprecated")
 1488: def test_stack_positional_level_duplicate_column_names(future_stack):
 1489:     # https://github.com/pandas-dev/pandas/issues/36353
 1490:     columns = MultiIndex.from_product([("x", "y"), ("y", "z")], names=["a", "a"])
 1491:     df = DataFrame([[1, 1, 1, 1]], columns=columns)
 1492:     result = df.stack(0, future_stack=future_stack)
 1493: 
 1494:     new_columns = Index(["y", "z"], name="a")
 1495:     new_index = MultiIndex.from_tuples([(0, "x"), (0, "y")], names=[None, "a"])
 1496:     expected = DataFrame([[1, 1], [1, 1]], index=new_index, columns=new_columns)
 1497: 
 1498:     tm.assert_frame_equal(result, expected)
 1499: 
 1500: 
 1501: def test_unstack_non_slice_like_blocks(using_array_manager):
 1502:     # Case where the mgr_locs of a DataFrame's underlying blocks are not slice-like
 1503: 
 1504:     mi = MultiIndex.from_product([range(5), ["A", "B", "C"]])
 1505:     df = DataFrame(
 1506:         {
 1507:             0: np.random.default_rng(2).standard_normal(15),
 1508:             1: np.random.default_rng(2).standard_normal(15).astype(np.int64),
 1509:             2: np.random.default_rng(2).standard_normal(15),
 1510:             3: np.random.default_rng(2).standard_normal(15),
 1511:         },
 1512:         index=mi,
 1513:     )
 1514:     if not using_array_manager:
 1515:         assert any(not x.mgr_locs.is_slice_like for x in df._mgr.blocks)
 1516: 
 1517:     res = df.unstack()
 1518: 
 1519:     expected = pd.concat([df[n].unstack() for n in range(4)], keys=range(4), axis=1)
 1520:     tm.assert_frame_equal(res, expected)
 1521: 
 1522: 
 1523: @pytest.mark.filterwarnings("ignore:The previous implementation of stack is deprecated")
 1524: def test_stack_sort_false(future_stack):
 1525:     # GH 15105
 1526:     data = [[1, 2, 3.0, 4.0], [2, 3, 4.0, 5.0], [3, 4, np.nan, np.nan]]
 1527:     df = DataFrame(
 1528:         data,
 1529:         columns=MultiIndex(
 1530:             levels=[["B", "A"], ["x", "y"]], codes=[[0, 0, 1, 1], [0, 1, 0, 1]]
 1531:         ),
 1532:     )
 1533:     kwargs = {} if future_stack else {"sort": False}
 1534:     result = df.stack(level=0, future_stack=future_stack, **kwargs)
 1535:     if future_stack:
 1536:         expected = DataFrame(
 1537:             {
 1538:                 "x": [1.0, 3.0, 2.0, 4.0, 3.0, np.nan],
 1539:                 "y": [2.0, 4.0, 3.0, 5.0, 4.0, np.nan],
 1540:             },
 1541:             index=MultiIndex.from_arrays(
 1542:                 [[0, 0, 1, 1, 2, 2], ["B", "A", "B", "A", "B", "A"]]
 1543:             ),
 1544:         )
 1545:     else:
 1546:         expected = DataFrame(
 1547:             {"x": [1.0, 3.0, 2.0, 4.0, 3.0], "y": [2.0, 4.0, 3.0, 5.0, 4.0]},
 1548:             index=MultiIndex.from_arrays([[0, 0, 1, 1, 2], ["B", "A", "B", "A", "B"]]),
 1549:         )
 1550:     tm.assert_frame_equal(result, expected)
 1551: 
 1552:     # Codes sorted in this call
 1553:     df = DataFrame(
 1554:         data,
 1555:         columns=MultiIndex.from_arrays([["B", "B", "A", "A"], ["x", "y", "x", "y"]]),
 1556:     )
 1557:     kwargs = {} if future_stack else {"sort": False}
 1558:     result = df.stack(level=0, future_stack=future_stack, **kwargs)
 1559:     tm.assert_frame_equal(result, expected)
 1560: 
 1561: 
 1562: @pytest.mark.filterwarnings("ignore:The previous implementation of stack is deprecated")
 1563: def test_stack_sort_false_multi_level(future_stack):
 1564:     # GH 15105
 1565:     idx = MultiIndex.from_tuples([("weight", "kg"), ("height", "m")])
 1566:     df = DataFrame([[1.0, 2.0], [3.0, 4.0]], index=["cat", "dog"], columns=idx)
 1567:     kwargs = {} if future_stack else {"sort": False}
 1568:     result = df.stack([0, 1], future_stack=future_stack, **kwargs)
 1569:     expected_index = MultiIndex.from_tuples(
 1570:         [
 1571:             ("cat", "weight", "kg"),
 1572:             ("cat", "height", "m"),
 1573:             ("dog", "weight", "kg"),
 1574:             ("dog", "height", "m"),
 1575:         ]
 1576:     )
 1577:     expected = Series([1.0, 2.0, 3.0, 4.0], index=expected_index)
 1578:     tm.assert_series_equal(result, expected)
 1579: 
 1580: 
 1581: class TestStackUnstackMultiLevel:
 1582:     def test_unstack(self, multiindex_year_month_day_dataframe_random_data):
 1583:         # just check that it works for now
 1584:         ymd = multiindex_year_month_day_dataframe_random_data
 1585: 
 1586:         unstacked = ymd.unstack()
 1587:         unstacked.unstack()
 1588: 
 1589:         # test that ints work
 1590:         ymd.astype(int).unstack()
 1591: 
 1592:         # test that int32 work
 1593:         ymd.astype(np.int32).unstack()
 1594: 
 1595:     @pytest.mark.parametrize(
 1596:         "result_rows,result_columns,index_product,expected_row",
 1597:         [
 1598:             (
 1599:                 [[1, 1, None, None, 30.0, None], [2, 2, None, None, 30.0, None]],
 1600:                 ["ix1", "ix2", "col1", "col2", "col3", "col4"],
 1601:                 2,
 1602:                 [None, None, 30.0, None],
 1603:             ),
 1604:             (
 1605:                 [[1, 1, None, None, 30.0], [2, 2, None, None, 30.0]],
 1606:                 ["ix1", "ix2", "col1", "col2", "col3"],
 1607:                 2,
 1608:                 [None, None, 30.0],
 1609:             ),
 1610:             (
 1611:                 [[1, 1, None, None, 30.0], [2, None, None, None, 30.0]],
 1612:                 ["ix1", "ix2", "col1", "col2", "col3"],
 1613:                 None,
 1614:                 [None, None, 30.0],
 1615:             ),
 1616:         ],
 1617:     )
 1618:     def test_unstack_partial(
 1619:         self, result_rows, result_columns, index_product, expected_row
 1620:     ):
 1621:         # check for regressions on this issue:
 1622:         # https://github.com/pandas-dev/pandas/issues/19351
 1623:         # make sure DataFrame.unstack() works when its run on a subset of the DataFrame
 1624:         # and the Index levels contain values that are not present in the subset
 1625:         result = DataFrame(result_rows, columns=result_columns).set_index(
 1626:             ["ix1", "ix2"]
 1627:         )
 1628:         result = result.iloc[1:2].unstack("ix2")
 1629:         expected = DataFrame(
 1630:             [expected_row],
 1631:             columns=MultiIndex.from_product(
 1632:                 [result_columns[2:], [index_product]], names=[None, "ix2"]
 1633:             ),
 1634:             index=Index([2], name="ix1"),
 1635:         )
 1636:         tm.assert_frame_equal(result, expected)
 1637: 
 1638:     def test_unstack_multiple_no_empty_columns(self):
 1639:         index = MultiIndex.from_tuples(
 1640:             [(0, "foo", 0), (0, "bar", 0), (1, "baz", 1), (1, "qux", 1)]
 1641:         )
 1642: 
 1643:         s = Series(np.random.default_rng(2).standard_normal(4), index=index)
 1644: 
 1645:         unstacked = s.unstack([1, 2])
 1646:         expected = unstacked.dropna(axis=1, how="all")
 1647:         tm.assert_frame_equal(unstacked, expected)
 1648: 
 1649:     @pytest.mark.filterwarnings(
 1650:         "ignore:The previous implementation of stack is deprecated"
 1651:     )
 1652:     def test_stack(self, multiindex_year_month_day_dataframe_random_data, future_stack):
 1653:         ymd = multiindex_year_month_day_dataframe_random_data
 1654: 
 1655:         # regular roundtrip
 1656:         unstacked = ymd.unstack()
 1657:         restacked = unstacked.stack(future_stack=future_stack)
 1658:         if future_stack:
 1659:             # NA values in unstacked persist to restacked in version 3
 1660:             restacked = restacked.dropna(how="all")
 1661:         tm.assert_frame_equal(restacked, ymd)
 1662: 
 1663:         unlexsorted = ymd.sort_index(level=2)
 1664: 
 1665:         unstacked = unlexsorted.unstack(2)
 1666:         restacked = unstacked.stack(future_stack=future_stack)
 1667:         if future_stack:
 1668:             # NA values in unstacked persist to restacked in version 3
 1669:             restacked = restacked.dropna(how="all")
 1670:         tm.assert_frame_equal(restacked.sort_index(level=0), ymd)
 1671: 
 1672:         unlexsorted = unlexsorted[::-1]
 1673:         unstacked = unlexsorted.unstack(1)
 1674:         restacked = unstacked.stack(future_stack=future_stack).swaplevel(1, 2)
 1675:         if future_stack:
 1676:             # NA values in unstacked persist to restacked in version 3
 1677:             restacked = restacked.dropna(how="all")
 1678:         tm.assert_frame_equal(restacked.sort_index(level=0), ymd)
 1679: 
 1680:         unlexsorted = unlexsorted.swaplevel(0, 1)
 1681:         unstacked = unlexsorted.unstack(0).swaplevel(0, 1, axis=1)
 1682:         restacked = unstacked.stack(0, future_stack=future_stack).swaplevel(1, 2)
 1683:         if future_stack:
 1684:             # NA values in unstacked persist to restacked in version 3
 1685:             restacked = restacked.dropna(how="all")
 1686:         tm.assert_frame_equal(restacked.sort_index(level=0), ymd)
 1687: 
 1688:         # columns unsorted
 1689:         unstacked = ymd.unstack()
 1690:         restacked = unstacked.stack(future_stack=future_stack)
 1691:         if future_stack:
 1692:             # NA values in unstacked persist to restacked in version 3
 1693:             restacked = restacked.dropna(how="all")
 1694:         tm.assert_frame_equal(restacked, ymd)
 1695: 
 1696:         # more than 2 levels in the columns
 1697:         unstacked = ymd.unstack(1).unstack(1)
 1698: 
 1699:         result = unstacked.stack(1, future_stack=future_stack)
 1700:         expected = ymd.unstack()
 1701:         tm.assert_frame_equal(result, expected)
 1702: 
 1703:         result = unstacked.stack(2, future_stack=future_stack)
 1704:         expected = ymd.unstack(1)
 1705:         tm.assert_frame_equal(result, expected)
 1706: 
 1707:         result = unstacked.stack(0, future_stack=future_stack)
 1708:         expected = ymd.stack(future_stack=future_stack).unstack(1).unstack(1)
 1709:         tm.assert_frame_equal(result, expected)
 1710: 
 1711:         # not all levels present in each echelon
 1712:         unstacked = ymd.unstack(2).loc[:, ::3]
 1713:         stacked = unstacked.stack(future_stack=future_stack).stack(
 1714:             future_stack=future_stack
 1715:         )
 1716:         ymd_stacked = ymd.stack(future_stack=future_stack)
 1717:         if future_stack:
 1718:             # NA values in unstacked persist to restacked in version 3
 1719:             stacked = stacked.dropna(how="all")
 1720:             ymd_stacked = ymd_stacked.dropna(how="all")
 1721:         tm.assert_series_equal(stacked, ymd_stacked.reindex(stacked.index))
 1722: 
 1723:         # stack with negative number
 1724:         result = ymd.unstack(0).stack(-2, future_stack=future_stack)
 1725:         expected = ymd.unstack(0).stack(0, future_stack=future_stack)
 1726:         tm.assert_equal(result, expected)
 1727: 
 1728:     @pytest.mark.parametrize(
 1729:         "idx, columns, exp_idx",
 1730:         [
 1731:             [
 1732:                 list("abab"),
 1733:                 ["1st", "2nd", "1st"],
 1734:                 MultiIndex(
 1735:                     levels=[["a", "b"], ["1st", "2nd"]],
 1736:                     codes=[np.tile(np.arange(2).repeat(3), 2), np.tile([0, 1, 0], 4)],
 1737:                 ),
 1738:             ],
 1739:             [
 1740:                 MultiIndex.from_tuples((("a", 2), ("b", 1), ("a", 1), ("b", 2))),
 1741:                 ["1st", "2nd", "1st"],
 1742:                 MultiIndex(
 1743:                     levels=[["a", "b"], [1, 2], ["1st", "2nd"]],
 1744:                     codes=[
 1745:                         np.tile(np.arange(2).repeat(3), 2),
 1746:                         np.repeat([1, 0, 1], [3, 6, 3]),
 1747:                         np.tile([0, 1, 0], 4),
 1748:                     ],
 1749:                 ),
 1750:             ],
 1751:         ],
 1752:     )
 1753:     def test_stack_duplicate_index(self, idx, columns, exp_idx, future_stack):
 1754:         # GH10417
 1755:         df = DataFrame(
 1756:             np.arange(12).reshape(4, 3),
 1757:             index=idx,
 1758:             columns=columns,
 1759:         )
 1760:         if future_stack:
 1761:             msg = "Columns with duplicate values are not supported in stack"
 1762:             with pytest.raises(ValueError, match=msg):
 1763:                 df.stack(future_stack=future_stack)
 1764:         else:
 1765:             result = df.stack(future_stack=future_stack)
 1766:             expected = Series(np.arange(12), index=exp_idx)
 1767:             tm.assert_series_equal(result, expected)
 1768:             assert result.index.is_unique is False
 1769:             li, ri = result.index, expected.index
 1770:             tm.assert_index_equal(li, ri)
 1771: 
 1772:     @pytest.mark.filterwarnings(
 1773:         "ignore:The previous implementation of stack is deprecated"
 1774:     )
 1775:     def test_unstack_odd_failure(self, future_stack):
 1776:         mi = MultiIndex.from_arrays(
 1777:             [
 1778:                 ["Fri"] * 4 + ["Sat"] * 2 + ["Sun"] * 2 + ["Thu"] * 3,
 1779:                 ["Dinner"] * 2 + ["Lunch"] * 2 + ["Dinner"] * 5 + ["Lunch"] * 2,
 1780:                 ["No", "Yes"] * 4 + ["No", "No", "Yes"],
 1781:             ],
 1782:             names=["day", "time", "smoker"],
 1783:         )
 1784:         df = DataFrame(
 1785:             {
 1786:                 "sum": np.arange(11, dtype="float64"),
 1787:                 "len": np.arange(11, dtype="float64"),
 1788:             },
 1789:             index=mi,
 1790:         )
 1791:         # it works, #2100
 1792:         result = df.unstack(2)
 1793: 
 1794:         recons = result.stack(future_stack=future_stack)
 1795:         if future_stack:
 1796:             # NA values in unstacked persist to restacked in version 3
 1797:             recons = recons.dropna(how="all")
 1798:         tm.assert_frame_equal(recons, df)
 1799: 
 1800:     @pytest.mark.filterwarnings(
 1801:         "ignore:The previous implementation of stack is deprecated"
 1802:     )
 1803:     def test_stack_mixed_dtype(self, multiindex_dataframe_random_data, future_stack):
 1804:         frame = multiindex_dataframe_random_data
 1805: 
 1806:         df = frame.T
 1807:         df["foo", "four"] = "foo"
 1808:         df = df.sort_index(level=1, axis=1)
 1809: 
 1810:         stacked = df.stack(future_stack=future_stack)
 1811:         result = df["foo"].stack(future_stack=future_stack).sort_index()
 1812:         tm.assert_series_equal(stacked["foo"], result, check_names=False)
 1813:         assert result.name is None
 1814:         assert stacked["bar"].dtype == np.float64
 1815: 
 1816:     def test_unstack_bug(self, future_stack):
 1817:         df = DataFrame(
 1818:             {
 1819:                 "state": ["naive", "naive", "naive", "active", "active", "active"],
 1820:                 "exp": ["a", "b", "b", "b", "a", "a"],
 1821:                 "barcode": [1, 2, 3, 4, 1, 3],
 1822:                 "v": ["hi", "hi", "bye", "bye", "bye", "peace"],
 1823:                 "extra": np.arange(6.0),
 1824:             }
 1825:         )
 1826: 
 1827:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1828:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1829:             result = df.groupby(["state", "exp", "barcode", "v"]).apply(len)
 1830: 
 1831:         unstacked = result.unstack()
 1832:         restacked = unstacked.stack(future_stack=future_stack)
 1833:         tm.assert_series_equal(restacked, result.reindex(restacked.index).astype(float))
 1834: 
 1835:     @pytest.mark.filterwarnings(
 1836:         "ignore:The previous implementation of stack is deprecated"
 1837:     )
 1838:     def test_stack_unstack_preserve_names(
 1839:         self, multiindex_dataframe_random_data, future_stack
 1840:     ):
 1841:         frame = multiindex_dataframe_random_data
 1842: 
 1843:         unstacked = frame.unstack()
 1844:         assert unstacked.index.name == "first"
 1845:         assert unstacked.columns.names == ["exp", "second"]
 1846: 
 1847:         restacked = unstacked.stack(future_stack=future_stack)
 1848:         assert restacked.index.names == frame.index.names
 1849: 
 1850:     @pytest.mark.parametrize("method", ["stack", "unstack"])
 1851:     def test_stack_unstack_wrong_level_name(
 1852:         self, method, multiindex_dataframe_random_data, future_stack
 1853:     ):
 1854:         # GH 18303 - wrong level name should raise
 1855:         frame = multiindex_dataframe_random_data
 1856: 
 1857:         # A DataFrame with flat axes:
 1858:         df = frame.loc["foo"]
 1859: 
 1860:         kwargs = {"future_stack": future_stack} if method == "stack" else {}
 1861:         with pytest.raises(KeyError, match="does not match index name"):
 1862:             getattr(df, method)("mistake", **kwargs)
 1863: 
 1864:         if method == "unstack":
 1865:             # Same on a Series:
 1866:             s = df.iloc[:, 0]
 1867:             with pytest.raises(KeyError, match="does not match index name"):
 1868:                 getattr(s, method)("mistake", **kwargs)
 1869: 
 1870:     def test_unstack_level_name(self, multiindex_dataframe_random_data):
 1871:         frame = multiindex_dataframe_random_data
 1872: 
 1873:         result = frame.unstack("second")
 1874:         expected = frame.unstack(level=1)
 1875:         tm.assert_frame_equal(result, expected)
 1876: 
 1877:     @pytest.mark.filterwarnings(
 1878:         "ignore:The previous implementation of stack is deprecated"
 1879:     )
 1880:     def test_stack_level_name(self, multiindex_dataframe_random_data, future_stack):
 1881:         frame = multiindex_dataframe_random_data
 1882: 
 1883:         unstacked = frame.unstack("second")
 1884:         result = unstacked.stack("exp", future_stack=future_stack)
 1885:         expected = frame.unstack().stack(0, future_stack=future_stack)
 1886:         tm.assert_frame_equal(result, expected)
 1887: 
 1888:         result = frame.stack("exp", future_stack=future_stack)
 1889:         expected = frame.stack(future_stack=future_stack)
 1890:         tm.assert_series_equal(result, expected)
 1891: 
 1892:     @pytest.mark.filterwarnings(
 1893:         "ignore:The previous implementation of stack is deprecated"
 1894:     )
 1895:     def test_stack_unstack_multiple(
 1896:         self, multiindex_year_month_day_dataframe_random_data, future_stack
 1897:     ):
 1898:         ymd = multiindex_year_month_day_dataframe_random_data
 1899: 
 1900:         unstacked = ymd.unstack(["year", "month"])
 1901:         expected = ymd.unstack("year").unstack("month")
 1902:         tm.assert_frame_equal(unstacked, expected)
 1903:         assert unstacked.columns.names == expected.columns.names
 1904: 
 1905:         # series
 1906:         s = ymd["A"]
 1907:         s_unstacked = s.unstack(["year", "month"])
 1908:         tm.assert_frame_equal(s_unstacked, expected["A"])
 1909: 
 1910:         restacked = unstacked.stack(["year", "month"], future_stack=future_stack)
 1911:         if future_stack:
 1912:             # NA values in unstacked persist to restacked in version 3
 1913:             restacked = restacked.dropna(how="all")
 1914:         restacked = restacked.swaplevel(0, 1).swaplevel(1, 2)
 1915:         restacked = restacked.sort_index(level=0)
 1916: 
 1917:         tm.assert_frame_equal(restacked, ymd)
 1918:         assert restacked.index.names == ymd.index.names
 1919: 
 1920:         # GH #451
 1921:         unstacked = ymd.unstack([1, 2])
 1922:         expected = ymd.unstack(1).unstack(1).dropna(axis=1, how="all")
 1923:         tm.assert_frame_equal(unstacked, expected)
 1924: 
 1925:         unstacked = ymd.unstack([2, 1])
 1926:         expected = ymd.unstack(2).unstack(1).dropna(axis=1, how="all")
 1927:         tm.assert_frame_equal(unstacked, expected.loc[:, unstacked.columns])
 1928: 
 1929:     @pytest.mark.filterwarnings(
 1930:         "ignore:The previous implementation of stack is deprecated"
 1931:     )
 1932:     def test_stack_names_and_numbers(
 1933:         self, multiindex_year_month_day_dataframe_random_data, future_stack
 1934:     ):
 1935:         ymd = multiindex_year_month_day_dataframe_random_data
 1936: 
 1937:         unstacked = ymd.unstack(["year", "month"])
 1938: 
 1939:         # Can't use mixture of names and numbers to stack
 1940:         with pytest.raises(ValueError, match="level should contain"):
 1941:             unstacked.stack([0, "month"], future_stack=future_stack)
 1942: 
 1943:     @pytest.mark.filterwarnings(
 1944:         "ignore:The previous implementation of stack is deprecated"
 1945:     )
 1946:     def test_stack_multiple_out_of_bounds(
 1947:         self, multiindex_year_month_day_dataframe_random_data, future_stack
 1948:     ):
 1949:         # nlevels == 3
 1950:         ymd = multiindex_year_month_day_dataframe_random_data
 1951: 
 1952:         unstacked = ymd.unstack(["year", "month"])
 1953: 
 1954:         with pytest.raises(IndexError, match="Too many levels"):
 1955:             unstacked.stack([2, 3], future_stack=future_stack)
 1956:         with pytest.raises(IndexError, match="not a valid level number"):
 1957:             unstacked.stack([-4, -3], future_stack=future_stack)
 1958: 
 1959:     def test_unstack_period_series(self):
 1960:         # GH4342
 1961:         idx1 = pd.PeriodIndex(
 1962:             ["2013-01", "2013-01", "2013-02", "2013-02", "2013-03", "2013-03"],
 1963:             freq="M",
 1964:             name="period",
 1965:         )
 1966:         idx2 = Index(["A", "B"] * 3, name="str")
 1967:         value = [1, 2, 3, 4, 5, 6]
 1968: 
 1969:         idx = MultiIndex.from_arrays([idx1, idx2])
 1970:         s = Series(value, index=idx)
 1971: 
 1972:         result1 = s.unstack()
 1973:         result2 = s.unstack(level=1)
 1974:         result3 = s.unstack(level=0)
 1975: 
 1976:         e_idx = pd.PeriodIndex(
 1977:             ["2013-01", "2013-02", "2013-03"], freq="M", name="period"
 1978:         )
 1979:         expected = DataFrame(
 1980:             {"A": [1, 3, 5], "B": [2, 4, 6]}, index=e_idx, columns=["A", "B"]
 1981:         )
 1982:         expected.columns.name = "str"
 1983: 
 1984:         tm.assert_frame_equal(result1, expected)
 1985:         tm.assert_frame_equal(result2, expected)
 1986:         tm.assert_frame_equal(result3, expected.T)
 1987: 
 1988:         idx1 = pd.PeriodIndex(
 1989:             ["2013-01", "2013-01", "2013-02", "2013-02", "2013-03", "2013-03"],
 1990:             freq="M",
 1991:             name="period1",
 1992:         )
 1993: 
 1994:         idx2 = pd.PeriodIndex(
 1995:             ["2013-12", "2013-11", "2013-10", "2013-09", "2013-08", "2013-07"],
 1996:             freq="M",
 1997:             name="period2",
 1998:         )
 1999:         idx = MultiIndex.from_arrays([idx1, idx2])
 2000:         s = Series(value, index=idx)
 2001: 
 2002:         result1 = s.unstack()
 2003:         result2 = s.unstack(level=1)
 2004:         result3 = s.unstack(level=0)
 2005: 
 2006:         e_idx = pd.PeriodIndex(
 2007:             ["2013-01", "2013-02", "2013-03"], freq="M", name="period1"
 2008:         )
 2009:         e_cols = pd.PeriodIndex(
 2010:             ["2013-07", "2013-08", "2013-09", "2013-10", "2013-11", "2013-12"],
 2011:             freq="M",
 2012:             name="period2",
 2013:         )
 2014:         expected = DataFrame(
 2015:             [
 2016:                 [np.nan, np.nan, np.nan, np.nan, 2, 1],
 2017:                 [np.nan, np.nan, 4, 3, np.nan, np.nan],
 2018:                 [6, 5, np.nan, np.nan, np.nan, np.nan],
 2019:             ],
 2020:             index=e_idx,
 2021:             columns=e_cols,
 2022:         )
 2023: 
 2024:         tm.assert_frame_equal(result1, expected)
 2025:         tm.assert_frame_equal(result2, expected)
 2026:         tm.assert_frame_equal(result3, expected.T)
 2027: 
 2028:     def test_unstack_period_frame(self):
 2029:         # GH4342
 2030:         idx1 = pd.PeriodIndex(
 2031:             ["2014-01", "2014-02", "2014-02", "2014-02", "2014-01", "2014-01"],
 2032:             freq="M",
 2033:             name="period1",
 2034:         )
 2035:         idx2 = pd.PeriodIndex(
 2036:             ["2013-12", "2013-12", "2014-02", "2013-10", "2013-10", "2014-02"],
 2037:             freq="M",
 2038:             name="period2",
 2039:         )
 2040:         value = {"A": [1, 2, 3, 4, 5, 6], "B": [6, 5, 4, 3, 2, 1]}
 2041:         idx = MultiIndex.from_arrays([idx1, idx2])
 2042:         df = DataFrame(value, index=idx)
 2043: 
 2044:         result1 = df.unstack()
 2045:         result2 = df.unstack(level=1)
 2046:         result3 = df.unstack(level=0)
 2047: 
 2048:         e_1 = pd.PeriodIndex(["2014-01", "2014-02"], freq="M", name="period1")
 2049:         e_2 = pd.PeriodIndex(
 2050:             ["2013-10", "2013-12", "2014-02", "2013-10", "2013-12", "2014-02"],
 2051:             freq="M",
 2052:             name="period2",
 2053:         )
 2054:         e_cols = MultiIndex.from_arrays(["A A A B B B".split(), e_2])
 2055:         expected = DataFrame(
 2056:             [[5, 1, 6, 2, 6, 1], [4, 2, 3, 3, 5, 4]], index=e_1, columns=e_cols
 2057:         )
 2058: 
 2059:         tm.assert_frame_equal(result1, expected)
 2060:         tm.assert_frame_equal(result2, expected)
 2061: 
 2062:         e_1 = pd.PeriodIndex(
 2063:             ["2014-01", "2014-02", "2014-01", "2014-02"], freq="M", name="period1"
 2064:         )
 2065:         e_2 = pd.PeriodIndex(
 2066:             ["2013-10", "2013-12", "2014-02"], freq="M", name="period2"
 2067:         )
 2068:         e_cols = MultiIndex.from_arrays(["A A B B".split(), e_1])
 2069:         expected = DataFrame(
 2070:             [[5, 4, 2, 3], [1, 2, 6, 5], [6, 3, 1, 4]], index=e_2, columns=e_cols
 2071:         )
 2072: 
 2073:         tm.assert_frame_equal(result3, expected)
 2074: 
 2075:     @pytest.mark.filterwarnings(
 2076:         "ignore:The previous implementation of stack is deprecated"
 2077:     )
 2078:     def test_stack_multiple_bug(self, future_stack):
 2079:         # bug when some uniques are not present in the data GH#3170
 2080:         id_col = ([1] * 3) + ([2] * 3)
 2081:         name = (["a"] * 3) + (["b"] * 3)
 2082:         date = pd.to_datetime(["2013-01-03", "2013-01-04", "2013-01-05"] * 2)
 2083:         var1 = np.random.default_rng(2).integers(0, 100, 6)
 2084:         df = DataFrame({"ID": id_col, "NAME": name, "DATE": date, "VAR1": var1})
 2085: 
 2086:         multi = df.set_index(["DATE", "ID"])
 2087:         multi.columns.name = "Params"
 2088:         unst = multi.unstack("ID")
 2089:         msg = re.escape("agg function failed [how->mean,dtype->")
 2090:         with pytest.raises(TypeError, match=msg):
 2091:             unst.resample("W-THU").mean()
 2092:         down = unst.resample("W-THU").mean(numeric_only=True)
 2093:         rs = down.stack("ID", future_stack=future_stack)
 2094:         xp = (
 2095:             unst.loc[:, ["VAR1"]]
 2096:             .resample("W-THU")
 2097:             .mean()
 2098:             .stack("ID", future_stack=future_stack)
 2099:         )
 2100:         xp.columns.name = "Params"
 2101:         tm.assert_frame_equal(rs, xp)
 2102: 
 2103:     @pytest.mark.filterwarnings(
 2104:         "ignore:The previous implementation of stack is deprecated"
 2105:     )
 2106:     def test_stack_dropna(self, future_stack):
 2107:         # GH#3997
 2108:         df = DataFrame({"A": ["a1", "a2"], "B": ["b1", "b2"], "C": [1, 1]})
 2109:         df = df.set_index(["A", "B"])
 2110: 
 2111:         dropna = False if not future_stack else lib.no_default
 2112:         stacked = df.unstack().stack(dropna=dropna, future_stack=future_stack)
 2113:         assert len(stacked) > len(stacked.dropna())
 2114: 
 2115:         if future_stack:
 2116:             with pytest.raises(ValueError, match="dropna must be unspecified"):
 2117:                 df.unstack().stack(dropna=True, future_stack=future_stack)
 2118:         else:
 2119:             stacked = df.unstack().stack(dropna=True, future_stack=future_stack)
 2120:             tm.assert_frame_equal(stacked, stacked.dropna())
 2121: 
 2122:     def test_unstack_multiple_hierarchical(self, future_stack):
 2123:         df = DataFrame(
 2124:             index=[
 2125:                 [0, 0, 0, 0, 1, 1, 1, 1],
 2126:                 [0, 0, 1, 1, 0, 0, 1, 1],
 2127:                 [0, 1, 0, 1, 0, 1, 0, 1],
 2128:             ],
 2129:             columns=[[0, 0, 1, 1], [0, 1, 0, 1]],
 2130:         )
 2131: 
 2132:         df.index.names = ["a", "b", "c"]
 2133:         df.columns.names = ["d", "e"]
 2134: 
 2135:         # it works!
 2136:         df.unstack(["b", "c"])
 2137: 
 2138:     def test_unstack_sparse_keyspace(self):
 2139:         # memory problems with naive impl GH#2278
 2140:         # Generate Long File & Test Pivot
 2141:         NUM_ROWS = 1000
 2142: 
 2143:         df = DataFrame(
 2144:             {
 2145:                 "A": np.random.default_rng(2).integers(100, size=NUM_ROWS),
 2146:                 "B": np.random.default_rng(3).integers(300, size=NUM_ROWS),
 2147:                 "C": np.random.default_rng(4).integers(-7, 7, size=NUM_ROWS),
 2148:                 "D": np.random.default_rng(5).integers(-19, 19, size=NUM_ROWS),
 2149:                 "E": np.random.default_rng(6).integers(3000, size=NUM_ROWS),
 2150:                 "F": np.random.default_rng(7).standard_normal(NUM_ROWS),
 2151:             }
 2152:         )
 2153: 
 2154:         idf = df.set_index(["A", "B", "C", "D", "E"])
 2155: 
 2156:         # it works! is sufficient
 2157:         idf.unstack("E")
 2158: 
 2159:     @pytest.mark.filterwarnings(
 2160:         "ignore:The previous implementation of stack is deprecated"
 2161:     )
 2162:     def test_unstack_unobserved_keys(self, future_stack):
 2163:         # related to GH#2278 refactoring
 2164:         levels = [[0, 1], [0, 1, 2, 3]]
 2165:         codes = [[0, 0, 1, 1], [0, 2, 0, 2]]
 2166: 
 2167:         index = MultiIndex(levels, codes)
 2168: 
 2169:         df = DataFrame(np.random.default_rng(2).standard_normal((4, 2)), index=index)
 2170: 
 2171:         result = df.unstack()
 2172:         assert len(result.columns) == 4
 2173: 
 2174:         recons = result.stack(future_stack=future_stack)
 2175:         tm.assert_frame_equal(recons, df)
 2176: 
 2177:     @pytest.mark.slow
 2178:     def test_unstack_number_of_levels_larger_than_int32(self, monkeypatch):
 2179:         # GH#20601
 2180:         # GH 26314: Change ValueError to PerformanceWarning
 2181: 
 2182:         class MockUnstacker(reshape_lib._Unstacker):
 2183:             def __init__(self, *args, **kwargs) -> None:
 2184:                 # __init__ will raise the warning
 2185:                 super().__init__(*args, **kwargs)
 2186:                 raise Exception("Don't compute final result.")
 2187: 
 2188:         with monkeypatch.context() as m:
 2189:             m.setattr(reshape_lib, "_Unstacker", MockUnstacker)
 2190:             df = DataFrame(
 2191:                 np.zeros((2**16, 2)),
 2192:                 index=[np.arange(2**16), np.arange(2**16)],
 2193:             )
 2194:             msg = "The following operation may generate"
 2195:             with tm.assert_produces_warning(PerformanceWarning, match=msg):
 2196:                 with pytest.raises(Exception, match="Don't compute final result."):
 2197:                     df.unstack()
 2198: 
 2199:     @pytest.mark.filterwarnings(
 2200:         "ignore:The previous implementation of stack is deprecated"
 2201:     )
 2202:     @pytest.mark.parametrize(
 2203:         "levels",
 2204:         itertools.chain.from_iterable(
 2205:             itertools.product(itertools.permutations([0, 1, 2], width), repeat=2)
 2206:             for width in [2, 3]
 2207:         ),
 2208:     )
 2209:     @pytest.mark.parametrize("stack_lev", range(2))
 2210:     @pytest.mark.parametrize("sort", [True, False])
 2211:     def test_stack_order_with_unsorted_levels(
 2212:         self, levels, stack_lev, sort, future_stack
 2213:     ):
 2214:         # GH#16323
 2215:         # deep check for 1-row case
 2216:         columns = MultiIndex(levels=levels, codes=[[0, 0, 1, 1], [0, 1, 0, 1]])
 2217:         df = DataFrame(columns=columns, data=[range(4)])
 2218:         kwargs = {} if future_stack else {"sort": sort}
 2219:         df_stacked = df.stack(stack_lev, future_stack=future_stack, **kwargs)
 2220:         for row in df.index:
 2221:             for col in df.columns:
 2222:                 expected = df.loc[row, col]
 2223:                 result_row = row, col[stack_lev]
 2224:                 result_col = col[1 - stack_lev]
 2225:                 result = df_stacked.loc[result_row, result_col]
 2226:                 assert result == expected
 2227: 
 2228:     @pytest.mark.filterwarnings(
 2229:         "ignore:The previous implementation of stack is deprecated"
 2230:     )
 2231:     def test_stack_order_with_unsorted_levels_multi_row(self, future_stack):
 2232:         # GH#16323
 2233: 
 2234:         # check multi-row case
 2235:         mi = MultiIndex(
 2236:             levels=[["A", "C", "B"], ["B", "A", "C"]],
 2237:             codes=[np.repeat(range(3), 3), np.tile(range(3), 3)],
 2238:         )
 2239:         df = DataFrame(
 2240:             columns=mi, index=range(5), data=np.arange(5 * len(mi)).reshape(5, -1)
 2241:         )
 2242:         assert all(
 2243:             df.loc[row, col]
 2244:             == df.stack(0, future_stack=future_stack).loc[(row, col[0]), col[1]]
 2245:             for row in df.index
 2246:             for col in df.columns
 2247:         )
 2248: 
 2249:     @pytest.mark.filterwarnings(
 2250:         "ignore:The previous implementation of stack is deprecated"
 2251:     )
 2252:     def test_stack_order_with_unsorted_levels_multi_row_2(self, future_stack):
 2253:         # GH#53636
 2254:         levels = ((0, 1), (1, 0))
 2255:         stack_lev = 1
 2256:         columns = MultiIndex(levels=levels, codes=[[0, 0, 1, 1], [0, 1, 0, 1]])
 2257:         df = DataFrame(columns=columns, data=[range(4)], index=[1, 0, 2, 3])
 2258:         kwargs = {} if future_stack else {"sort": True}
 2259:         result = df.stack(stack_lev, future_stack=future_stack, **kwargs)
 2260:         expected_index = MultiIndex(
 2261:             levels=[[0, 1, 2, 3], [0, 1]],
 2262:             codes=[[1, 1, 0, 0, 2, 2, 3, 3], [1, 0, 1, 0, 1, 0, 1, 0]],
 2263:         )
 2264:         expected = DataFrame(
 2265:             {
 2266:                 0: [0, 1, 0, 1, 0, 1, 0, 1],
 2267:                 1: [2, 3, 2, 3, 2, 3, 2, 3],
 2268:             },
 2269:             index=expected_index,
 2270:         )
 2271:         tm.assert_frame_equal(result, expected)
 2272: 
 2273:     @pytest.mark.filterwarnings(
 2274:         "ignore:The previous implementation of stack is deprecated"
 2275:     )
 2276:     def test_stack_unstack_unordered_multiindex(self, future_stack):
 2277:         # GH# 18265
 2278:         values = np.arange(5)
 2279:         data = np.vstack(
 2280:             [
 2281:                 [f"b{x}" for x in values],  # b0, b1, ..
 2282:                 [f"a{x}" for x in values],  # a0, a1, ..
 2283:             ]
 2284:         )
 2285:         df = DataFrame(data.T, columns=["b", "a"])
 2286:         df.columns.name = "first"
 2287:         second_level_dict = {"x": df}
 2288:         multi_level_df = pd.concat(second_level_dict, axis=1)
 2289:         multi_level_df.columns.names = ["second", "first"]
 2290:         df = multi_level_df.reindex(sorted(multi_level_df.columns), axis=1)
 2291:         result = df.stack(["first", "second"], future_stack=future_stack).unstack(
 2292:             ["first", "second"]
 2293:         )
 2294:         expected = DataFrame(
 2295:             [["a0", "b0"], ["a1", "b1"], ["a2", "b2"], ["a3", "b3"], ["a4", "b4"]],
 2296:             index=[0, 1, 2, 3, 4],
 2297:             columns=MultiIndex.from_tuples(
 2298:                 [("a", "x"), ("b", "x")], names=["first", "second"]
 2299:             ),
 2300:         )
 2301:         tm.assert_frame_equal(result, expected)
 2302: 
 2303:     def test_unstack_preserve_types(
 2304:         self, multiindex_year_month_day_dataframe_random_data, using_infer_string
 2305:     ):
 2306:         # GH#403
 2307:         ymd = multiindex_year_month_day_dataframe_random_data
 2308:         ymd["E"] = "foo"
 2309:         ymd["F"] = 2
 2310: 
 2311:         unstacked = ymd.unstack("month")
 2312:         assert unstacked["A", 1].dtype == np.float64
 2313:         assert (
 2314:             unstacked["E", 1].dtype == np.object_
 2315:             if not using_infer_string
 2316:             else "string"
 2317:         )
 2318:         assert unstacked["F", 1].dtype == np.float64
 2319: 
 2320:     def test_unstack_group_index_overflow(self, future_stack):
 2321:         codes = np.tile(np.arange(500), 2)
 2322:         level = np.arange(500)
 2323: 
 2324:         index = MultiIndex(
 2325:             levels=[level] * 8 + [[0, 1]],
 2326:             codes=[codes] * 8 + [np.arange(2).repeat(500)],
 2327:         )
 2328: 
 2329:         s = Series(np.arange(1000), index=index)
 2330:         result = s.unstack()
 2331:         assert result.shape == (500, 2)
 2332: 
 2333:         # test roundtrip
 2334:         stacked = result.stack(future_stack=future_stack)
 2335:         tm.assert_series_equal(s, stacked.reindex(s.index))
 2336: 
 2337:         # put it at beginning
 2338:         index = MultiIndex(
 2339:             levels=[[0, 1]] + [level] * 8,
 2340:             codes=[np.arange(2).repeat(500)] + [codes] * 8,
 2341:         )
 2342: 
 2343:         s = Series(np.arange(1000), index=index)
 2344:         result = s.unstack(0)
 2345:         assert result.shape == (500, 2)
 2346: 
 2347:         # put it in middle
 2348:         index = MultiIndex(
 2349:             levels=[level] * 4 + [[0, 1]] + [level] * 4,
 2350:             codes=([codes] * 4 + [np.arange(2).repeat(500)] + [codes] * 4),
 2351:         )
 2352: 
 2353:         s = Series(np.arange(1000), index=index)
 2354:         result = s.unstack(4)
 2355:         assert result.shape == (500, 2)
 2356: 
 2357:     def test_unstack_with_missing_int_cast_to_float(self, using_array_manager):
 2358:         # https://github.com/pandas-dev/pandas/issues/37115
 2359:         df = DataFrame(
 2360:             {
 2361:                 "a": ["A", "A", "B"],
 2362:                 "b": ["ca", "cb", "cb"],
 2363:                 "v": [10] * 3,
 2364:             }
 2365:         ).set_index(["a", "b"])
 2366: 
 2367:         # add another int column to get 2 blocks
 2368:         df["is_"] = 1
 2369:         if not using_array_manager:
 2370:             assert len(df._mgr.blocks) == 2
 2371: 
 2372:         result = df.unstack("b")
 2373:         result[("is_", "ca")] = result[("is_", "ca")].fillna(0)
 2374: 
 2375:         expected = DataFrame(
 2376:             [[10.0, 10.0, 1.0, 1.0], [np.nan, 10.0, 0.0, 1.0]],
 2377:             index=Index(["A", "B"], name="a"),
 2378:             columns=MultiIndex.from_tuples(
 2379:                 [("v", "ca"), ("v", "cb"), ("is_", "ca"), ("is_", "cb")],
 2380:                 names=[None, "b"],
 2381:             ),
 2382:         )
 2383:         if using_array_manager:
 2384:             # INFO(ArrayManager) with ArrayManager preserve dtype where possible
 2385:             expected[("v", "cb")] = expected[("v", "cb")].astype("int64")
 2386:             expected[("is_", "cb")] = expected[("is_", "cb")].astype("int64")
 2387:         tm.assert_frame_equal(result, expected)
 2388: 
 2389:     def test_unstack_with_level_has_nan(self):
 2390:         # GH 37510
 2391:         df1 = DataFrame(
 2392:             {
 2393:                 "L1": [1, 2, 3, 4],
 2394:                 "L2": [3, 4, 1, 2],
 2395:                 "L3": [1, 1, 1, 1],
 2396:                 "x": [1, 2, 3, 4],
 2397:             }
 2398:         )
 2399:         df1 = df1.set_index(["L1", "L2", "L3"])
 2400:         new_levels = ["n1", "n2", "n3", None]
 2401:         df1.index = df1.index.set_levels(levels=new_levels, level="L1")
 2402:         df1.index = df1.index.set_levels(levels=new_levels, level="L2")
 2403: 
 2404:         result = df1.unstack("L3")[("x", 1)].sort_index().index
 2405:         expected = MultiIndex(
 2406:             levels=[["n1", "n2", "n3", None], ["n1", "n2", "n3", None]],
 2407:             codes=[[0, 1, 2, 3], [2, 3, 0, 1]],
 2408:             names=["L1", "L2"],
 2409:         )
 2410: 
 2411:         tm.assert_index_equal(result, expected)
 2412: 
 2413:     @pytest.mark.filterwarnings(
 2414:         "ignore:The previous implementation of stack is deprecated"
 2415:     )
 2416:     def test_stack_nan_in_multiindex_columns(self, future_stack):
 2417:         # GH#39481
 2418:         df = DataFrame(
 2419:             np.zeros([1, 5]),
 2420:             columns=MultiIndex.from_tuples(
 2421:                 [
 2422:                     (0, None, None),
 2423:                     (0, 2, 0),
 2424:                     (0, 2, 1),
 2425:                     (0, 3, 0),
 2426:                     (0, 3, 1),
 2427:                 ],
 2428:             ),
 2429:         )
 2430:         result = df.stack(2, future_stack=future_stack)
 2431:         if future_stack:
 2432:             index = MultiIndex(levels=[[0], [0.0, 1.0]], codes=[[0, 0, 0], [-1, 0, 1]])
 2433:             columns = MultiIndex(levels=[[0], [2, 3]], codes=[[0, 0, 0], [-1, 0, 1]])
 2434:         else:
 2435:             index = Index([(0, None), (0, 0), (0, 1)])
 2436:             columns = Index([(0, None), (0, 2), (0, 3)])
 2437:         expected = DataFrame(
 2438:             [[0.0, np.nan, np.nan], [np.nan, 0.0, 0.0], [np.nan, 0.0, 0.0]],
 2439:             index=index,
 2440:             columns=columns,
 2441:         )
 2442:         tm.assert_frame_equal(result, expected)
 2443: 
 2444:     @pytest.mark.filterwarnings(
 2445:         "ignore:The previous implementation of stack is deprecated"
 2446:     )
 2447:     def test_multi_level_stack_categorical(self, future_stack):
 2448:         # GH 15239
 2449:         midx = MultiIndex.from_arrays(
 2450:             [
 2451:                 ["A"] * 2 + ["B"] * 2,
 2452:                 pd.Categorical(list("abab")),
 2453:                 pd.Categorical(list("ccdd")),
 2454:             ]
 2455:         )
 2456:         df = DataFrame(np.arange(8).reshape(2, 4), columns=midx)
 2457:         result = df.stack([1, 2], future_stack=future_stack)
 2458:         if future_stack:
 2459:             expected = DataFrame(
 2460:                 [
 2461:                     [0, np.nan],
 2462:                     [1, np.nan],
 2463:                     [np.nan, 2],
 2464:                     [np.nan, 3],
 2465:                     [4, np.nan],
 2466:                     [5, np.nan],
 2467:                     [np.nan, 6],
 2468:                     [np.nan, 7],
 2469:                 ],
 2470:                 columns=["A", "B"],
 2471:                 index=MultiIndex.from_arrays(
 2472:                     [
 2473:                         [0] * 4 + [1] * 4,
 2474:                         pd.Categorical(list("abababab")),
 2475:                         pd.Categorical(list("ccddccdd")),
 2476:                     ]
 2477:                 ),
 2478:             )
 2479:         else:
 2480:             expected = DataFrame(
 2481:                 [
 2482:                     [0, np.nan],
 2483:                     [np.nan, 2],
 2484:                     [1, np.nan],
 2485:                     [np.nan, 3],
 2486:                     [4, np.nan],
 2487:                     [np.nan, 6],
 2488:                     [5, np.nan],
 2489:                     [np.nan, 7],
 2490:                 ],
 2491:                 columns=["A", "B"],
 2492:                 index=MultiIndex.from_arrays(
 2493:                     [
 2494:                         [0] * 4 + [1] * 4,
 2495:                         pd.Categorical(list("aabbaabb")),
 2496:                         pd.Categorical(list("cdcdcdcd")),
 2497:                     ]
 2498:                 ),
 2499:             )
 2500:         tm.assert_frame_equal(result, expected)
 2501: 
 2502:     @pytest.mark.filterwarnings(
 2503:         "ignore:The previous implementation of stack is deprecated"
 2504:     )
 2505:     def test_stack_nan_level(self, future_stack):
 2506:         # GH 9406
 2507:         df_nan = DataFrame(
 2508:             np.arange(4).reshape(2, 2),
 2509:             columns=MultiIndex.from_tuples(
 2510:                 [("A", np.nan), ("B", "b")], names=["Upper", "Lower"]
 2511:             ),
 2512:             index=Index([0, 1], name="Num"),
 2513:             dtype=np.float64,
 2514:         )
 2515:         result = df_nan.stack(future_stack=future_stack)
 2516:         if future_stack:
 2517:             index = MultiIndex(
 2518:                 levels=[[0, 1], [np.nan, "b"]],
 2519:                 codes=[[0, 0, 1, 1], [0, 1, 0, 1]],
 2520:                 names=["Num", "Lower"],
 2521:             )
 2522:         else:
 2523:             index = MultiIndex.from_tuples(
 2524:                 [(0, np.nan), (0, "b"), (1, np.nan), (1, "b")], names=["Num", "Lower"]
 2525:             )
 2526:         expected = DataFrame(
 2527:             [[0.0, np.nan], [np.nan, 1], [2.0, np.nan], [np.nan, 3.0]],
 2528:             columns=Index(["A", "B"], name="Upper"),
 2529:             index=index,
 2530:         )
 2531:         tm.assert_frame_equal(result, expected)
 2532: 
 2533:     def test_unstack_categorical_columns(self):
 2534:         # GH 14018
 2535:         idx = MultiIndex.from_product([["A"], [0, 1]])
 2536:         df = DataFrame({"cat": pd.Categorical(["a", "b"])}, index=idx)
 2537:         result = df.unstack()
 2538:         expected = DataFrame(
 2539:             {
 2540:                 0: pd.Categorical(["a"], categories=["a", "b"]),
 2541:                 1: pd.Categorical(["b"], categories=["a", "b"]),
 2542:             },
 2543:             index=["A"],
 2544:         )
 2545:         expected.columns = MultiIndex.from_tuples([("cat", 0), ("cat", 1)])
 2546:         tm.assert_frame_equal(result, expected)
 2547: 
 2548:     @pytest.mark.filterwarnings(
 2549:         "ignore:The previous implementation of stack is deprecated"
 2550:     )
 2551:     def test_stack_unsorted(self, future_stack):
 2552:         # GH 16925
 2553:         PAE = ["ITA", "FRA"]
 2554:         VAR = ["A1", "A2"]
 2555:         TYP = ["CRT", "DBT", "NET"]
 2556:         MI = MultiIndex.from_product([PAE, VAR, TYP], names=["PAE", "VAR", "TYP"])
 2557: 
 2558:         V = list(range(len(MI)))
 2559:         DF = DataFrame(data=V, index=MI, columns=["VALUE"])
 2560: 
 2561:         DF = DF.unstack(["VAR", "TYP"])
 2562:         DF.columns = DF.columns.droplevel(0)
 2563:         DF.loc[:, ("A0", "NET")] = 9999
 2564: 
 2565:         result = DF.stack(["VAR", "TYP"], future_stack=future_stack).sort_index()
 2566:         expected = (
 2567:             DF.sort_index(axis=1)
 2568:             .stack(["VAR", "TYP"], future_stack=future_stack)
 2569:             .sort_index()
 2570:         )
 2571:         tm.assert_series_equal(result, expected)
 2572: 
 2573:     @pytest.mark.filterwarnings(
 2574:         "ignore:The previous implementation of stack is deprecated"
 2575:     )
 2576:     def test_stack_nullable_dtype(self, future_stack):
 2577:         # GH#43561
 2578:         columns = MultiIndex.from_product(
 2579:             [["54511", "54515"], ["r", "t_mean"]], names=["station", "element"]
 2580:         )
 2581:         index = Index([1, 2, 3], name="time")
 2582: 
 2583:         arr = np.array([[50, 226, 10, 215], [10, 215, 9, 220], [305, 232, 111, 220]])
 2584:         df = DataFrame(arr, columns=columns, index=index, dtype=pd.Int64Dtype())
 2585: 
 2586:         result = df.stack("station", future_stack=future_stack)
 2587: 
 2588:         expected = (
 2589:             df.astype(np.int64)
 2590:             .stack("station", future_stack=future_stack)
 2591:             .astype(pd.Int64Dtype())
 2592:         )
 2593:         tm.assert_frame_equal(result, expected)
 2594: 
 2595:         # non-homogeneous case
 2596:         df[df.columns[0]] = df[df.columns[0]].astype(pd.Float64Dtype())
 2597:         result = df.stack("station", future_stack=future_stack)
 2598: 
 2599:         expected = DataFrame(
 2600:             {
 2601:                 "r": pd.array(
 2602:                     [50.0, 10.0, 10.0, 9.0, 305.0, 111.0], dtype=pd.Float64Dtype()
 2603:                 ),
 2604:                 "t_mean": pd.array(
 2605:                     [226, 215, 215, 220, 232, 220], dtype=pd.Int64Dtype()
 2606:                 ),
 2607:             },
 2608:             index=MultiIndex.from_product([index, columns.levels[0]]),
 2609:         )
 2610:         expected.columns.name = "element"
 2611:         tm.assert_frame_equal(result, expected)
 2612: 
 2613:     def test_unstack_mixed_level_names(self):
 2614:         # GH#48763
 2615:         arrays = [["a", "a"], [1, 2], ["red", "blue"]]
 2616:         idx = MultiIndex.from_arrays(arrays, names=("x", 0, "y"))
 2617:         df = DataFrame({"m": [1, 2]}, index=idx)
 2618:         result = df.unstack("x")
 2619:         expected = DataFrame(
 2620:             [[1], [2]],
 2621:             columns=MultiIndex.from_tuples([("m", "a")], names=[None, "x"]),
 2622:             index=MultiIndex.from_tuples([(1, "red"), (2, "blue")], names=[0, "y"]),
 2623:         )
 2624:         tm.assert_frame_equal(result, expected)
 2625: 
 2626: 
 2627: def test_stack_tuple_columns(future_stack):
 2628:     # GH#54948 - test stack when the input has a non-MultiIndex with tuples
 2629:     df = DataFrame(
 2630:         [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=[("a", 1), ("a", 2), ("b", 1)]
 2631:     )
 2632:     result = df.stack(future_stack=future_stack)
 2633:     expected = Series(
 2634:         [1, 2, 3, 4, 5, 6, 7, 8, 9],
 2635:         index=MultiIndex(
 2636:             levels=[[0, 1, 2], [("a", 1), ("a", 2), ("b", 1)]],
 2637:             codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2], [0, 1, 2, 0, 1, 2, 0, 1, 2]],
 2638:         ),
 2639:     )
 2640:     tm.assert_series_equal(result, expected)
 2641: 
 2642: 
 2643: @pytest.mark.parametrize(
 2644:     "dtype, na_value",
 2645:     [
 2646:         ("float64", np.nan),
 2647:         ("Float64", np.nan),
 2648:         ("Float64", pd.NA),
 2649:         ("Int64", pd.NA),
 2650:     ],
 2651: )
 2652: @pytest.mark.parametrize("test_multiindex", [True, False])
 2653: def test_stack_preserves_na(dtype, na_value, test_multiindex):
 2654:     # GH#56573
 2655:     if test_multiindex:
 2656:         index = MultiIndex.from_arrays(2 * [Index([na_value], dtype=dtype)])
 2657:     else:
 2658:         index = Index([na_value], dtype=dtype)
 2659:     df = DataFrame({"a": [1]}, index=index)
 2660:     result = df.stack(future_stack=True)
 2661: 
 2662:     if test_multiindex:
 2663:         expected_index = MultiIndex.from_arrays(
 2664:             [
 2665:                 Index([na_value], dtype=dtype),
 2666:                 Index([na_value], dtype=dtype),
 2667:                 Index(["a"]),
 2668:             ]
 2669:         )
 2670:     else:
 2671:         expected_index = MultiIndex.from_arrays(
 2672:             [
 2673:                 Index([na_value], dtype=dtype),
 2674:                 Index(["a"]),
 2675:             ]
 2676:         )
 2677:     expected = Series(1, index=expected_index)
 2678:     tm.assert_series_equal(result, expected)
