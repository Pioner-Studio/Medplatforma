    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas.util._test_decorators as td
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     Categorical,
   11:     CategoricalDtype,
   12:     DataFrame,
   13:     DatetimeTZDtype,
   14:     Index,
   15:     Interval,
   16:     IntervalDtype,
   17:     NaT,
   18:     Series,
   19:     Timedelta,
   20:     Timestamp,
   21:     concat,
   22:     date_range,
   23:     option_context,
   24: )
   25: import pandas._testing as tm
   26: 
   27: 
   28: def _check_cast(df, v):
   29:     """
   30:     Check if all dtypes of df are equal to v
   31:     """
   32:     assert all(s.dtype.name == v for _, s in df.items())
   33: 
   34: 
   35: class TestAstype:
   36:     def test_astype_float(self, float_frame):
   37:         casted = float_frame.astype(int)
   38:         expected = DataFrame(
   39:             float_frame.values.astype(int),
   40:             index=float_frame.index,
   41:             columns=float_frame.columns,
   42:         )
   43:         tm.assert_frame_equal(casted, expected)
   44: 
   45:         casted = float_frame.astype(np.int32)
   46:         expected = DataFrame(
   47:             float_frame.values.astype(np.int32),
   48:             index=float_frame.index,
   49:             columns=float_frame.columns,
   50:         )
   51:         tm.assert_frame_equal(casted, expected)
   52: 
   53:         float_frame["foo"] = "5"
   54:         casted = float_frame.astype(int)
   55:         expected = DataFrame(
   56:             float_frame.values.astype(int),
   57:             index=float_frame.index,
   58:             columns=float_frame.columns,
   59:         )
   60:         tm.assert_frame_equal(casted, expected)
   61: 
   62:     def test_astype_mixed_float(self, mixed_float_frame):
   63:         # mixed casting
   64:         casted = mixed_float_frame.reindex(columns=["A", "B"]).astype("float32")
   65:         _check_cast(casted, "float32")
   66: 
   67:         casted = mixed_float_frame.reindex(columns=["A", "B"]).astype("float16")
   68:         _check_cast(casted, "float16")
   69: 
   70:     def test_astype_mixed_type(self):
   71:         # mixed casting
   72:         df = DataFrame(
   73:             {
   74:                 "a": 1.0,
   75:                 "b": 2,
   76:                 "c": "foo",
   77:                 "float32": np.array([1.0] * 10, dtype="float32"),
   78:                 "int32": np.array([1] * 10, dtype="int32"),
   79:             },
   80:             index=np.arange(10),
   81:         )
   82:         mn = df._get_numeric_data().copy()
   83:         mn["little_float"] = np.array(12345.0, dtype="float16")
   84:         mn["big_float"] = np.array(123456789101112.0, dtype="float64")
   85: 
   86:         casted = mn.astype("float64")
   87:         _check_cast(casted, "float64")
   88: 
   89:         casted = mn.astype("int64")
   90:         _check_cast(casted, "int64")
   91: 
   92:         casted = mn.reindex(columns=["little_float"]).astype("float16")
   93:         _check_cast(casted, "float16")
   94: 
   95:         casted = mn.astype("float32")
   96:         _check_cast(casted, "float32")
   97: 
   98:         casted = mn.astype("int32")
   99:         _check_cast(casted, "int32")
  100: 
  101:         # to object
  102:         casted = mn.astype("O")
  103:         _check_cast(casted, "object")
  104: 
  105:     def test_astype_with_exclude_string(self, float_frame):
  106:         df = float_frame.copy()
  107:         expected = float_frame.astype(int)
  108:         df["string"] = "foo"
  109:         casted = df.astype(int, errors="ignore")
  110: 
  111:         expected["string"] = "foo"
  112:         tm.assert_frame_equal(casted, expected)
  113: 
  114:         df = float_frame.copy()
  115:         expected = float_frame.astype(np.int32)
  116:         df["string"] = "foo"
  117:         casted = df.astype(np.int32, errors="ignore")
  118: 
  119:         expected["string"] = "foo"
  120:         tm.assert_frame_equal(casted, expected)
  121: 
  122:     def test_astype_with_view_float(self, float_frame):
  123:         # this is the only real reason to do it this way
  124:         tf = np.round(float_frame).astype(np.int32)
  125:         tf.astype(np.float32, copy=False)
  126: 
  127:         # TODO(wesm): verification?
  128:         tf = float_frame.astype(np.float64)
  129:         tf.astype(np.int64, copy=False)
  130: 
  131:     def test_astype_with_view_mixed_float(self, mixed_float_frame):
  132:         tf = mixed_float_frame.reindex(columns=["A", "B", "C"])
  133: 
  134:         tf.astype(np.int64)
  135:         tf.astype(np.float32)
  136: 
  137:     @pytest.mark.parametrize("dtype", [np.int32, np.int64])
  138:     @pytest.mark.parametrize("val", [np.nan, np.inf])
  139:     def test_astype_cast_nan_inf_int(self, val, dtype):
  140:         # see GH#14265
  141:         #
  142:         # Check NaN and inf --> raise error when converting to int.
  143:         msg = "Cannot convert non-finite values \\(NA or inf\\) to integer"
  144:         df = DataFrame([val])
  145: 
  146:         with pytest.raises(ValueError, match=msg):
  147:             df.astype(dtype)
  148: 
  149:     def test_astype_str(self):
  150:         # see GH#9757
  151:         a = Series(date_range("2010-01-04", periods=5))
  152:         b = Series(date_range("3/6/2012 00:00", periods=5, tz="US/Eastern"))
  153:         c = Series([Timedelta(x, unit="d") for x in range(5)])
  154:         d = Series(range(5))
  155:         e = Series([0.0, 0.2, 0.4, 0.6, 0.8])
  156: 
  157:         df = DataFrame({"a": a, "b": b, "c": c, "d": d, "e": e})
  158: 
  159:         # Datetime-like
  160:         result = df.astype(str)
  161: 
  162:         expected = DataFrame(
  163:             {
  164:                 "a": list(map(str, (Timestamp(x)._date_repr for x in a._values))),
  165:                 "b": list(map(str, map(Timestamp, b._values))),
  166:                 "c": [Timedelta(x)._repr_base() for x in c._values],
  167:                 "d": list(map(str, d._values)),
  168:                 "e": list(map(str, e._values)),
  169:             },
  170:             dtype="object",
  171:         )
  172: 
  173:         tm.assert_frame_equal(result, expected)
  174: 
  175:     def test_astype_str_float(self):
  176:         # see GH#11302
  177:         result = DataFrame([np.nan]).astype(str)
  178:         expected = DataFrame(["nan"], dtype="object")
  179: 
  180:         tm.assert_frame_equal(result, expected)
  181:         result = DataFrame([1.12345678901234567890]).astype(str)
  182: 
  183:         val = "1.1234567890123457"
  184:         expected = DataFrame([val], dtype="object")
  185:         tm.assert_frame_equal(result, expected)
  186: 
  187:     @pytest.mark.parametrize("dtype_class", [dict, Series])
  188:     def test_astype_dict_like(self, dtype_class):
  189:         # GH7271 & GH16717
  190:         a = Series(date_range("2010-01-04", periods=5))
  191:         b = Series(range(5))
  192:         c = Series([0.0, 0.2, 0.4, 0.6, 0.8])
  193:         d = Series(["1.0", "2", "3.14", "4", "5.4"])
  194:         df = DataFrame({"a": a, "b": b, "c": c, "d": d})
  195:         original = df.copy(deep=True)
  196: 
  197:         # change type of a subset of columns
  198:         dt1 = dtype_class({"b": "str", "d": "float32"})
  199:         result = df.astype(dt1)
  200:         expected = DataFrame(
  201:             {
  202:                 "a": a,
  203:                 "b": Series(["0", "1", "2", "3", "4"], dtype="object"),
  204:                 "c": c,
  205:                 "d": Series([1.0, 2.0, 3.14, 4.0, 5.4], dtype="float32"),
  206:             }
  207:         )
  208:         tm.assert_frame_equal(result, expected)
  209:         tm.assert_frame_equal(df, original)
  210: 
  211:         dt2 = dtype_class({"b": np.float32, "c": "float32", "d": np.float64})
  212:         result = df.astype(dt2)
  213:         expected = DataFrame(
  214:             {
  215:                 "a": a,
  216:                 "b": Series([0.0, 1.0, 2.0, 3.0, 4.0], dtype="float32"),
  217:                 "c": Series([0.0, 0.2, 0.4, 0.6, 0.8], dtype="float32"),
  218:                 "d": Series([1.0, 2.0, 3.14, 4.0, 5.4], dtype="float64"),
  219:             }
  220:         )
  221:         tm.assert_frame_equal(result, expected)
  222:         tm.assert_frame_equal(df, original)
  223: 
  224:         # change all columns
  225:         dt3 = dtype_class({"a": str, "b": str, "c": str, "d": str})
  226:         tm.assert_frame_equal(df.astype(dt3), df.astype(str))
  227:         tm.assert_frame_equal(df, original)
  228: 
  229:         # error should be raised when using something other than column labels
  230:         # in the keys of the dtype dict
  231:         dt4 = dtype_class({"b": str, 2: str})
  232:         dt5 = dtype_class({"e": str})
  233:         msg_frame = (
  234:             "Only a column name can be used for the key in a dtype mappings argument. "
  235:             "'{}' not found in columns."
  236:         )
  237:         with pytest.raises(KeyError, match=msg_frame.format(2)):
  238:             df.astype(dt4)
  239:         with pytest.raises(KeyError, match=msg_frame.format("e")):
  240:             df.astype(dt5)
  241:         tm.assert_frame_equal(df, original)
  242: 
  243:         # if the dtypes provided are the same as the original dtypes, the
  244:         # resulting DataFrame should be the same as the original DataFrame
  245:         dt6 = dtype_class({col: df[col].dtype for col in df.columns})
  246:         equiv = df.astype(dt6)
  247:         tm.assert_frame_equal(df, equiv)
  248:         tm.assert_frame_equal(df, original)
  249: 
  250:         # GH#16717
  251:         # if dtypes provided is empty, the resulting DataFrame
  252:         # should be the same as the original DataFrame
  253:         dt7 = dtype_class({}) if dtype_class is dict else dtype_class({}, dtype=object)
  254:         equiv = df.astype(dt7)
  255:         tm.assert_frame_equal(df, equiv)
  256:         tm.assert_frame_equal(df, original)
  257: 
  258:     def test_astype_duplicate_col(self):
  259:         a1 = Series([1, 2, 3, 4, 5], name="a")
  260:         b = Series([0.1, 0.2, 0.4, 0.6, 0.8], name="b")
  261:         a2 = Series([0, 1, 2, 3, 4], name="a")
  262:         df = concat([a1, b, a2], axis=1)
  263: 
  264:         result = df.astype(str)
  265:         a1_str = Series(["1", "2", "3", "4", "5"], dtype="str", name="a")
  266:         b_str = Series(["0.1", "0.2", "0.4", "0.6", "0.8"], dtype=str, name="b")
  267:         a2_str = Series(["0", "1", "2", "3", "4"], dtype="str", name="a")
  268:         expected = concat([a1_str, b_str, a2_str], axis=1)
  269:         tm.assert_frame_equal(result, expected)
  270: 
  271:         result = df.astype({"a": "str"})
  272:         expected = concat([a1_str, b, a2_str], axis=1)
  273:         tm.assert_frame_equal(result, expected)
  274: 
  275:     def test_astype_duplicate_col_series_arg(self):
  276:         # GH#44417
  277:         vals = np.random.default_rng(2).standard_normal((3, 4))
  278:         df = DataFrame(vals, columns=["A", "B", "C", "A"])
  279:         dtypes = df.dtypes
  280:         dtypes.iloc[0] = str
  281:         dtypes.iloc[2] = "Float64"
  282: 
  283:         result = df.astype(dtypes)
  284:         expected = DataFrame(
  285:             {
  286:                 0: Series(vals[:, 0].astype(str), dtype=object),
  287:                 1: vals[:, 1],
  288:                 2: pd.array(vals[:, 2], dtype="Float64"),
  289:                 3: vals[:, 3],
  290:             }
  291:         )
  292:         expected.columns = df.columns
  293:         tm.assert_frame_equal(result, expected)
  294: 
  295:     @pytest.mark.parametrize(
  296:         "dtype",
  297:         [
  298:             "category",
  299:             CategoricalDtype(),
  300:             CategoricalDtype(ordered=True),
  301:             CategoricalDtype(ordered=False),
  302:             CategoricalDtype(categories=list("abcdef")),
  303:             CategoricalDtype(categories=list("edba"), ordered=False),
  304:             CategoricalDtype(categories=list("edcb"), ordered=True),
  305:         ],
  306:         ids=repr,
  307:     )
  308:     def test_astype_categorical(self, dtype):
  309:         # GH#18099
  310:         d = {"A": list("abbc"), "B": list("bccd"), "C": list("cdde")}
  311:         df = DataFrame(d)
  312:         result = df.astype(dtype)
  313:         expected = DataFrame({k: Categorical(v, dtype=dtype) for k, v in d.items()})
  314:         tm.assert_frame_equal(result, expected)
  315: 
  316:     @pytest.mark.parametrize("cls", [CategoricalDtype, DatetimeTZDtype, IntervalDtype])
  317:     def test_astype_categoricaldtype_class_raises(self, cls):
  318:         df = DataFrame({"A": ["a", "a", "b", "c"]})
  319:         xpr = f"Expected an instance of {cls.__name__}"
  320:         with pytest.raises(TypeError, match=xpr):
  321:             df.astype({"A": cls})
  322: 
  323:         with pytest.raises(TypeError, match=xpr):
  324:             df["A"].astype(cls)
  325: 
  326:     @pytest.mark.parametrize("dtype", ["Int64", "Int32", "Int16"])
  327:     def test_astype_extension_dtypes(self, dtype):
  328:         # GH#22578
  329:         df = DataFrame([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], columns=["a", "b"])
  330: 
  331:         expected1 = DataFrame(
  332:             {
  333:                 "a": pd.array([1, 3, 5], dtype=dtype),
  334:                 "b": pd.array([2, 4, 6], dtype=dtype),
  335:             }
  336:         )
  337:         tm.assert_frame_equal(df.astype(dtype), expected1)
  338:         tm.assert_frame_equal(df.astype("int64").astype(dtype), expected1)
  339:         tm.assert_frame_equal(df.astype(dtype).astype("float64"), df)
  340: 
  341:         df = DataFrame([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], columns=["a", "b"])
  342:         df["b"] = df["b"].astype(dtype)
  343:         expected2 = DataFrame(
  344:             {"a": [1.0, 3.0, 5.0], "b": pd.array([2, 4, 6], dtype=dtype)}
  345:         )
  346:         tm.assert_frame_equal(df, expected2)
  347: 
  348:         tm.assert_frame_equal(df.astype(dtype), expected1)
  349:         tm.assert_frame_equal(df.astype("int64").astype(dtype), expected1)
  350: 
  351:     @pytest.mark.parametrize("dtype", ["Int64", "Int32", "Int16"])
  352:     def test_astype_extension_dtypes_1d(self, dtype):
  353:         # GH#22578
  354:         df = DataFrame({"a": [1.0, 2.0, 3.0]})
  355: 
  356:         expected1 = DataFrame({"a": pd.array([1, 2, 3], dtype=dtype)})
  357:         tm.assert_frame_equal(df.astype(dtype), expected1)
  358:         tm.assert_frame_equal(df.astype("int64").astype(dtype), expected1)
  359: 
  360:         df = DataFrame({"a": [1.0, 2.0, 3.0]})
  361:         df["a"] = df["a"].astype(dtype)
  362:         expected2 = DataFrame({"a": pd.array([1, 2, 3], dtype=dtype)})
  363:         tm.assert_frame_equal(df, expected2)
  364: 
  365:         tm.assert_frame_equal(df.astype(dtype), expected1)
  366:         tm.assert_frame_equal(df.astype("int64").astype(dtype), expected1)
  367: 
  368:     @pytest.mark.parametrize("dtype", ["category", "Int64"])
  369:     def test_astype_extension_dtypes_duplicate_col(self, dtype):
  370:         # GH#24704
  371:         a1 = Series([0, np.nan, 4], name="a")
  372:         a2 = Series([np.nan, 3, 5], name="a")
  373:         df = concat([a1, a2], axis=1)
  374: 
  375:         result = df.astype(dtype)
  376:         expected = concat([a1.astype(dtype), a2.astype(dtype)], axis=1)
  377:         tm.assert_frame_equal(result, expected)
  378: 
  379:     @pytest.mark.parametrize(
  380:         "dtype", [{100: "float64", 200: "uint64"}, "category", "float64"]
  381:     )
  382:     def test_astype_column_metadata(self, dtype):
  383:         # GH#19920
  384:         columns = Index([100, 200, 300], dtype=np.uint64, name="foo")
  385:         df = DataFrame(np.arange(15).reshape(5, 3), columns=columns)
  386:         df = df.astype(dtype)
  387:         tm.assert_index_equal(df.columns, columns)
  388: 
  389:     @pytest.mark.parametrize("unit", ["Y", "M", "W", "D", "h", "m"])
  390:     def test_astype_from_object_to_datetime_unit(self, unit):
  391:         vals = [
  392:             ["2015-01-01", "2015-01-02", "2015-01-03"],
  393:             ["2017-01-01", "2017-01-02", "2017-02-03"],
  394:         ]
  395:         df = DataFrame(vals, dtype=object)
  396:         msg = (
  397:             rf"Unexpected value for 'dtype': 'datetime64\[{unit}\]'. "
  398:             r"Must be 'datetime64\[s\]', 'datetime64\[ms\]', 'datetime64\[us\]', "
  399:             r"'datetime64\[ns\]' or DatetimeTZDtype"
  400:         )
  401:         with pytest.raises(ValueError, match=msg):
  402:             df.astype(f"M8[{unit}]")
  403: 
  404:     @pytest.mark.parametrize("unit", ["Y", "M", "W", "D", "h", "m"])
  405:     def test_astype_from_object_to_timedelta_unit(self, unit):
  406:         vals = [
  407:             ["1 Day", "2 Days", "3 Days"],
  408:             ["4 Days", "5 Days", "6 Days"],
  409:         ]
  410:         df = DataFrame(vals, dtype=object)
  411:         msg = (
  412:             r"Cannot convert from timedelta64\[ns\] to timedelta64\[.*\]. "
  413:             "Supported resolutions are 's', 'ms', 'us', 'ns'"
  414:         )
  415:         with pytest.raises(ValueError, match=msg):
  416:             # TODO: this is ValueError while for DatetimeArray it is TypeError;
  417:             #  get these consistent
  418:             df.astype(f"m8[{unit}]")
  419: 
  420:     @pytest.mark.parametrize("dtype", ["M8", "m8"])
  421:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s", "h", "m", "D"])
  422:     def test_astype_from_datetimelike_to_object(self, dtype, unit):
  423:         # tests astype to object dtype
  424:         # GH#19223 / GH#12425
  425:         dtype = f"{dtype}[{unit}]"
  426:         arr = np.array([[1, 2, 3]], dtype=dtype)
  427:         df = DataFrame(arr)
  428:         result = df.astype(object)
  429:         assert (result.dtypes == object).all()
  430: 
  431:         if dtype.startswith("M8"):
  432:             assert result.iloc[0, 0] == Timestamp(1, unit=unit)
  433:         else:
  434:             assert result.iloc[0, 0] == Timedelta(1, unit=unit)
  435: 
  436:     @pytest.mark.parametrize("arr_dtype", [np.int64, np.float64])
  437:     @pytest.mark.parametrize("dtype", ["M8", "m8"])
  438:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s", "h", "m", "D"])
  439:     def test_astype_to_datetimelike_unit(self, arr_dtype, dtype, unit):
  440:         # tests all units from numeric origination
  441:         # GH#19223 / GH#12425
  442:         dtype = f"{dtype}[{unit}]"
  443:         arr = np.array([[1, 2, 3]], dtype=arr_dtype)
  444:         df = DataFrame(arr)
  445:         result = df.astype(dtype)
  446:         expected = DataFrame(arr.astype(dtype))
  447: 
  448:         tm.assert_frame_equal(result, expected)
  449: 
  450:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s", "h", "m", "D"])
  451:     def test_astype_to_datetime_unit(self, unit):
  452:         # tests all units from datetime origination
  453:         # GH#19223
  454:         dtype = f"M8[{unit}]"
  455:         arr = np.array([[1, 2, 3]], dtype=dtype)
  456:         df = DataFrame(arr)
  457:         ser = df.iloc[:, 0]
  458:         idx = Index(ser)
  459:         dta = ser._values
  460: 
  461:         if unit in ["ns", "us", "ms", "s"]:
  462:             # GH#48928
  463:             result = df.astype(dtype)
  464:         else:
  465:             # we use the nearest supported dtype (i.e. M8[s])
  466:             msg = rf"Cannot cast DatetimeArray to dtype datetime64\[{unit}\]"
  467:             with pytest.raises(TypeError, match=msg):
  468:                 df.astype(dtype)
  469: 
  470:             with pytest.raises(TypeError, match=msg):
  471:                 ser.astype(dtype)
  472: 
  473:             with pytest.raises(TypeError, match=msg.replace("Array", "Index")):
  474:                 idx.astype(dtype)
  475: 
  476:             with pytest.raises(TypeError, match=msg):
  477:                 dta.astype(dtype)
  478: 
  479:             return
  480: 
  481:         exp_df = DataFrame(arr.astype(dtype))
  482:         assert (exp_df.dtypes == dtype).all()
  483:         tm.assert_frame_equal(result, exp_df)
  484: 
  485:         res_ser = ser.astype(dtype)
  486:         exp_ser = exp_df.iloc[:, 0]
  487:         assert exp_ser.dtype == dtype
  488:         tm.assert_series_equal(res_ser, exp_ser)
  489: 
  490:         exp_dta = exp_ser._values
  491: 
  492:         res_index = idx.astype(dtype)
  493:         exp_index = Index(exp_ser)
  494:         assert exp_index.dtype == dtype
  495:         tm.assert_index_equal(res_index, exp_index)
  496: 
  497:         res_dta = dta.astype(dtype)
  498:         assert exp_dta.dtype == dtype
  499:         tm.assert_extension_array_equal(res_dta, exp_dta)
  500: 
  501:     @pytest.mark.parametrize("unit", ["ns"])
  502:     def test_astype_to_timedelta_unit_ns(self, unit):
  503:         # preserver the timedelta conversion
  504:         # GH#19223
  505:         dtype = f"m8[{unit}]"
  506:         arr = np.array([[1, 2, 3]], dtype=dtype)
  507:         df = DataFrame(arr)
  508:         result = df.astype(dtype)
  509:         expected = DataFrame(arr.astype(dtype))
  510: 
  511:         tm.assert_frame_equal(result, expected)
  512: 
  513:     @pytest.mark.parametrize("unit", ["us", "ms", "s", "h", "m", "D"])
  514:     def test_astype_to_timedelta_unit(self, unit):
  515:         # coerce to float
  516:         # GH#19223 until 2.0 used to coerce to float
  517:         dtype = f"m8[{unit}]"
  518:         arr = np.array([[1, 2, 3]], dtype=dtype)
  519:         df = DataFrame(arr)
  520:         ser = df.iloc[:, 0]
  521:         tdi = Index(ser)
  522:         tda = tdi._values
  523: 
  524:         if unit in ["us", "ms", "s"]:
  525:             assert (df.dtypes == dtype).all()
  526:             result = df.astype(dtype)
  527:         else:
  528:             # We get the nearest supported unit, i.e. "s"
  529:             assert (df.dtypes == "m8[s]").all()
  530: 
  531:             msg = (
  532:                 rf"Cannot convert from timedelta64\[s\] to timedelta64\[{unit}\]. "
  533:                 "Supported resolutions are 's', 'ms', 'us', 'ns'"
  534:             )
  535:             with pytest.raises(ValueError, match=msg):
  536:                 df.astype(dtype)
  537:             with pytest.raises(ValueError, match=msg):
  538:                 ser.astype(dtype)
  539:             with pytest.raises(ValueError, match=msg):
  540:                 tdi.astype(dtype)
  541:             with pytest.raises(ValueError, match=msg):
  542:                 tda.astype(dtype)
  543: 
  544:             return
  545: 
  546:         result = df.astype(dtype)
  547:         # The conversion is a no-op, so we just get a copy
  548:         expected = df
  549:         tm.assert_frame_equal(result, expected)
  550: 
  551:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s", "h", "m", "D"])
  552:     def test_astype_to_incorrect_datetimelike(self, unit):
  553:         # trying to astype a m to a M, or vice-versa
  554:         # GH#19224
  555:         dtype = f"M8[{unit}]"
  556:         other = f"m8[{unit}]"
  557: 
  558:         df = DataFrame(np.array([[1, 2, 3]], dtype=dtype))
  559:         msg = "|".join(
  560:             [
  561:                 # BlockManager path
  562:                 rf"Cannot cast DatetimeArray to dtype timedelta64\[{unit}\]",
  563:                 # ArrayManager path
  564:                 "cannot astype a datetimelike from "
  565:                 rf"\[datetime64\[ns\]\] to \[timedelta64\[{unit}\]\]",
  566:             ]
  567:         )
  568:         with pytest.raises(TypeError, match=msg):
  569:             df.astype(other)
  570: 
  571:         msg = "|".join(
  572:             [
  573:                 # BlockManager path
  574:                 rf"Cannot cast TimedeltaArray to dtype datetime64\[{unit}\]",
  575:                 # ArrayManager path
  576:                 "cannot astype a timedelta from "
  577:                 rf"\[timedelta64\[ns\]\] to \[datetime64\[{unit}\]\]",
  578:             ]
  579:         )
  580:         df = DataFrame(np.array([[1, 2, 3]], dtype=other))
  581:         with pytest.raises(TypeError, match=msg):
  582:             df.astype(dtype)
  583: 
  584:     def test_astype_arg_for_errors(self):
  585:         # GH#14878
  586: 
  587:         df = DataFrame([1, 2, 3])
  588: 
  589:         msg = (
  590:             "Expected value of kwarg 'errors' to be one of "
  591:             "['raise', 'ignore']. Supplied value is 'True'"
  592:         )
  593:         with pytest.raises(ValueError, match=re.escape(msg)):
  594:             df.astype(np.float64, errors=True)
  595: 
  596:         df.astype(np.int8, errors="ignore")
  597: 
  598:     def test_astype_invalid_conversion(self):
  599:         # GH#47571
  600:         df = DataFrame({"a": [1, 2, "text"], "b": [1, 2, 3]})
  601: 
  602:         msg = (
  603:             "invalid literal for int() with base 10: 'text': "
  604:             "Error while type casting for column 'a'"
  605:         )
  606: 
  607:         with pytest.raises(ValueError, match=re.escape(msg)):
  608:             df.astype({"a": int})
  609: 
  610:     def test_astype_arg_for_errors_dictlist(self):
  611:         # GH#25905
  612:         df = DataFrame(
  613:             [
  614:                 {"a": "1", "b": "16.5%", "c": "test"},
  615:                 {"a": "2.2", "b": "15.3", "c": "another_test"},
  616:             ]
  617:         )
  618:         expected = DataFrame(
  619:             [
  620:                 {"a": 1.0, "b": "16.5%", "c": "test"},
  621:                 {"a": 2.2, "b": "15.3", "c": "another_test"},
  622:             ]
  623:         )
  624:         expected["c"] = expected["c"].astype("object")
  625:         type_dict = {"a": "float64", "b": "float64", "c": "object"}
  626: 
  627:         result = df.astype(dtype=type_dict, errors="ignore")
  628: 
  629:         tm.assert_frame_equal(result, expected)
  630: 
  631:     def test_astype_dt64tz(self, timezone_frame):
  632:         # astype
  633:         expected = np.array(
  634:             [
  635:                 [
  636:                     Timestamp("2013-01-01 00:00:00"),
  637:                     Timestamp("2013-01-02 00:00:00"),
  638:                     Timestamp("2013-01-03 00:00:00"),
  639:                 ],
  640:                 [
  641:                     Timestamp("2013-01-01 00:00:00-0500", tz="US/Eastern"),
  642:                     NaT,
  643:                     Timestamp("2013-01-03 00:00:00-0500", tz="US/Eastern"),
  644:                 ],
  645:                 [
  646:                     Timestamp("2013-01-01 00:00:00+0100", tz="CET"),
  647:                     NaT,
  648:                     Timestamp("2013-01-03 00:00:00+0100", tz="CET"),
  649:                 ],
  650:             ],
  651:             dtype=object,
  652:         ).T
  653:         expected = DataFrame(
  654:             expected,
  655:             index=timezone_frame.index,
  656:             columns=timezone_frame.columns,
  657:             dtype=object,
  658:         )
  659:         result = timezone_frame.astype(object)
  660:         tm.assert_frame_equal(result, expected)
  661: 
  662:         msg = "Cannot use .astype to convert from timezone-aware dtype to timezone-"
  663:         with pytest.raises(TypeError, match=msg):
  664:             # dt64tz->dt64 deprecated
  665:             timezone_frame.astype("datetime64[ns]")
  666: 
  667:     def test_astype_dt64tz_to_str(self, timezone_frame):
  668:         # str formatting
  669:         result = timezone_frame.astype(str)
  670:         expected = DataFrame(
  671:             [
  672:                 [
  673:                     "2013-01-01",
  674:                     "2013-01-01 00:00:00-05:00",
  675:                     "2013-01-01 00:00:00+01:00",
  676:                 ],
  677:                 ["2013-01-02", "NaT", "NaT"],
  678:                 [
  679:                     "2013-01-03",
  680:                     "2013-01-03 00:00:00-05:00",
  681:                     "2013-01-03 00:00:00+01:00",
  682:                 ],
  683:             ],
  684:             columns=timezone_frame.columns,
  685:             dtype="object",
  686:         )
  687:         tm.assert_frame_equal(result, expected)
  688: 
  689:         with option_context("display.max_columns", 20):
  690:             result = str(timezone_frame)
  691:             assert (
  692:                 "0 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00+01:00"
  693:             ) in result
  694:             assert (
  695:                 "1 2013-01-02                       NaT                       NaT"
  696:             ) in result
  697:             assert (
  698:                 "2 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-03 00:00:00+01:00"
  699:             ) in result
  700: 
  701:     def test_astype_empty_dtype_dict(self):
  702:         # issue mentioned further down in the following issue's thread
  703:         # https://github.com/pandas-dev/pandas/issues/33113
  704:         df = DataFrame()
  705:         result = df.astype({})
  706:         tm.assert_frame_equal(result, df)
  707:         assert result is not df
  708: 
  709:     @pytest.mark.parametrize(
  710:         "data, dtype",
  711:         [
  712:             (["x", "y", "z"], "string[python]"),
  713:             pytest.param(
  714:                 ["x", "y", "z"],
  715:                 "string[pyarrow]",
  716:                 marks=td.skip_if_no("pyarrow"),
  717:             ),
  718:             (["x", "y", "z"], "category"),
  719:             (3 * [Timestamp("2020-01-01", tz="UTC")], None),
  720:             (3 * [Interval(0, 1)], None),
  721:         ],
  722:     )
  723:     @pytest.mark.parametrize("errors", ["raise", "ignore"])
  724:     def test_astype_ignores_errors_for_extension_dtypes(self, data, dtype, errors):
  725:         # https://github.com/pandas-dev/pandas/issues/35471
  726:         df = DataFrame(Series(data, dtype=dtype))
  727:         if errors == "ignore":
  728:             expected = df
  729:             result = df.astype(float, errors=errors)
  730:             tm.assert_frame_equal(result, expected)
  731:         else:
  732:             msg = "(Cannot cast)|(could not convert)"
  733:             with pytest.raises((ValueError, TypeError), match=msg):
  734:                 df.astype(float, errors=errors)
  735: 
  736:     def test_astype_tz_conversion(self):
  737:         # GH 35973
  738:         val = {"tz": date_range("2020-08-30", freq="d", periods=2, tz="Europe/London")}
  739:         df = DataFrame(val)
  740:         result = df.astype({"tz": "datetime64[ns, Europe/Berlin]"})
  741: 
  742:         expected = df
  743:         expected["tz"] = expected["tz"].dt.tz_convert("Europe/Berlin")
  744:         tm.assert_frame_equal(result, expected)
  745: 
  746:     @pytest.mark.parametrize("tz", ["UTC", "Europe/Berlin"])
  747:     def test_astype_tz_object_conversion(self, tz):
  748:         # GH 35973
  749:         val = {"tz": date_range("2020-08-30", freq="d", periods=2, tz="Europe/London")}
  750:         expected = DataFrame(val)
  751: 
  752:         # convert expected to object dtype from other tz str (independently tested)
  753:         result = expected.astype({"tz": f"datetime64[ns, {tz}]"})
  754:         result = result.astype({"tz": "object"})
  755: 
  756:         # do real test: object dtype to a specified tz, different from construction tz.
  757:         result = result.astype({"tz": "datetime64[ns, Europe/London]"})
  758:         tm.assert_frame_equal(result, expected)
  759: 
  760:     def test_astype_dt64_to_string(
  761:         self, frame_or_series, tz_naive_fixture, using_infer_string
  762:     ):
  763:         # GH#41409
  764:         tz = tz_naive_fixture
  765: 
  766:         dti = date_range("2016-01-01", periods=3, tz=tz)
  767:         dta = dti._data
  768:         dta[0] = NaT
  769: 
  770:         obj = frame_or_series(dta)
  771:         result = obj.astype("string")
  772: 
  773:         # Check that Series/DataFrame.astype matches DatetimeArray.astype
  774:         expected = frame_or_series(dta.astype("string"))
  775:         tm.assert_equal(result, expected)
  776: 
  777:         item = result.iloc[0]
  778:         if frame_or_series is DataFrame:
  779:             item = item.iloc[0]
  780:         if using_infer_string:
  781:             assert item is np.nan
  782:         else:
  783:             assert item is pd.NA
  784: 
  785:         # For non-NA values, we should match what we get for non-EA str
  786:         alt = obj.astype(str)
  787:         assert np.all(alt.iloc[1:] == result.iloc[1:])
  788: 
  789:     def test_astype_td64_to_string(self, frame_or_series):
  790:         # GH#41409
  791:         tdi = pd.timedelta_range("1 Day", periods=3)
  792:         obj = frame_or_series(tdi)
  793: 
  794:         expected = frame_or_series(["1 days", "2 days", "3 days"], dtype="string")
  795:         result = obj.astype("string")
  796:         tm.assert_equal(result, expected)
  797: 
  798:     def test_astype_bytes(self):
  799:         # GH#39474
  800:         result = DataFrame(["foo", "bar", "baz"]).astype(bytes)
  801:         assert result.dtypes[0] == np.dtype("S3")
  802: 
  803:     @pytest.mark.parametrize(
  804:         "index_slice",
  805:         [
  806:             np.s_[:2, :2],
  807:             np.s_[:1, :2],
  808:             np.s_[:2, :1],
  809:             np.s_[::2, ::2],
  810:             np.s_[::1, ::2],
  811:             np.s_[::2, ::1],
  812:         ],
  813:     )
  814:     def test_astype_noncontiguous(self, index_slice):
  815:         # GH#42396
  816:         data = np.arange(16).reshape(4, 4)
  817:         df = DataFrame(data)
  818: 
  819:         result = df.iloc[index_slice].astype("int16")
  820:         expected = df.iloc[index_slice]
  821:         tm.assert_frame_equal(result, expected, check_dtype=False)
  822: 
  823:     def test_astype_retain_attrs(self, any_numpy_dtype):
  824:         # GH#44414
  825:         df = DataFrame({"a": [0, 1, 2], "b": [3, 4, 5]})
  826:         df.attrs["Location"] = "Michigan"
  827: 
  828:         result = df.astype({"a": any_numpy_dtype}).attrs
  829:         expected = df.attrs
  830: 
  831:         tm.assert_dict_equal(expected, result)
  832: 
  833: 
  834: class TestAstypeCategorical:
  835:     def test_astype_from_categorical3(self):
  836:         df = DataFrame({"cats": [1, 2, 3, 4, 5, 6], "vals": [1, 2, 3, 4, 5, 6]})
  837:         cats = Categorical([1, 2, 3, 4, 5, 6])
  838:         exp_df = DataFrame({"cats": cats, "vals": [1, 2, 3, 4, 5, 6]})
  839:         df["cats"] = df["cats"].astype("category")
  840:         tm.assert_frame_equal(exp_df, df)
  841: 
  842:     def test_astype_from_categorical4(self):
  843:         df = DataFrame(
  844:             {"cats": ["a", "b", "b", "a", "a", "d"], "vals": [1, 2, 3, 4, 5, 6]}
  845:         )
  846:         cats = Categorical(["a", "b", "b", "a", "a", "d"])
  847:         exp_df = DataFrame({"cats": cats, "vals": [1, 2, 3, 4, 5, 6]})
  848:         df["cats"] = df["cats"].astype("category")
  849:         tm.assert_frame_equal(exp_df, df)
  850: 
  851:     def test_categorical_astype_to_int(self, any_int_dtype):
  852:         # GH#39402
  853: 
  854:         df = DataFrame(data={"col1": pd.array([2.0, 1.0, 3.0])})
  855:         df.col1 = df.col1.astype("category")
  856:         df.col1 = df.col1.astype(any_int_dtype)
  857:         expected = DataFrame({"col1": pd.array([2, 1, 3], dtype=any_int_dtype)})
  858:         tm.assert_frame_equal(df, expected)
  859: 
  860:     def test_astype_categorical_to_string_missing(self):
  861:         # https://github.com/pandas-dev/pandas/issues/41797
  862:         df = DataFrame(["a", "b", np.nan])
  863:         expected = df.astype(str)
  864:         cat = df.astype("category")
  865:         result = cat.astype(str)
  866:         tm.assert_frame_equal(result, expected)
  867: 
  868: 
  869: class IntegerArrayNoCopy(pd.core.arrays.IntegerArray):
  870:     # GH 42501
  871: 
  872:     def copy(self):
  873:         assert False
  874: 
  875: 
  876: class Int16DtypeNoCopy(pd.Int16Dtype):
  877:     # GH 42501
  878: 
  879:     @classmethod
  880:     def construct_array_type(cls):
  881:         return IntegerArrayNoCopy
  882: 
  883: 
  884: def test_frame_astype_no_copy():
  885:     # GH 42501
  886:     df = DataFrame({"a": [1, 4, None, 5], "b": [6, 7, 8, 9]}, dtype=object)
  887:     result = df.astype({"a": Int16DtypeNoCopy()}, copy=False)
  888: 
  889:     assert result.a.dtype == pd.Int16Dtype()
  890:     assert np.shares_memory(df.b.values, result.b.values)
  891: 
  892: 
  893: @pytest.mark.parametrize("dtype", ["int64", "Int64"])
  894: def test_astype_copies(dtype):
  895:     # GH#50984
  896:     pytest.importorskip("pyarrow")
  897:     df = DataFrame({"a": [1, 2, 3]}, dtype=dtype)
  898:     result = df.astype("int64[pyarrow]", copy=True)
  899:     df.iloc[0, 0] = 100
  900:     expected = DataFrame({"a": [1, 2, 3]}, dtype="int64[pyarrow]")
  901:     tm.assert_frame_equal(result, expected)
  902: 
  903: 
  904: @pytest.mark.parametrize("val", [None, 1, 1.5, np.nan, NaT])
  905: def test_astype_to_string_not_modifying_input(string_storage, val):
  906:     # GH#51073
  907:     df = DataFrame({"a": ["a", "b", val]})
  908:     expected = df.copy()
  909:     with option_context("mode.string_storage", string_storage):
  910:         df.astype("string", copy=False)
  911:     tm.assert_frame_equal(df, expected)
