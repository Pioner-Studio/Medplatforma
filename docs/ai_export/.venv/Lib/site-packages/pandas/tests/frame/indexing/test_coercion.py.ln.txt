    1: """
    2: Tests for values coercion in setitem-like operations on DataFrame.
    3: 
    4: For the most part, these should be multi-column DataFrames, otherwise
    5: we would share the tests with Series.
    6: """
    7: import numpy as np
    8: import pytest
    9: 
   10: import pandas as pd
   11: from pandas import (
   12:     DataFrame,
   13:     MultiIndex,
   14:     NaT,
   15:     Series,
   16:     Timestamp,
   17:     date_range,
   18: )
   19: import pandas._testing as tm
   20: 
   21: 
   22: class TestDataFrameSetitemCoercion:
   23:     @pytest.mark.parametrize("consolidate", [True, False])
   24:     def test_loc_setitem_multiindex_columns(self, consolidate):
   25:         # GH#18415 Setting values in a single column preserves dtype,
   26:         #  while setting them in multiple columns did unwanted cast.
   27: 
   28:         # Note that A here has 2 blocks, below we do the same thing
   29:         #  with a consolidated frame.
   30:         A = DataFrame(np.zeros((6, 5), dtype=np.float32))
   31:         A = pd.concat([A, A], axis=1, keys=[1, 2])
   32:         if consolidate:
   33:             A = A._consolidate()
   34: 
   35:         A.loc[2:3, (1, slice(2, 3))] = np.ones((2, 2), dtype=np.float32)
   36:         assert (A.dtypes == np.float32).all()
   37: 
   38:         A.loc[0:5, (1, slice(2, 3))] = np.ones((6, 2), dtype=np.float32)
   39: 
   40:         assert (A.dtypes == np.float32).all()
   41: 
   42:         A.loc[:, (1, slice(2, 3))] = np.ones((6, 2), dtype=np.float32)
   43:         assert (A.dtypes == np.float32).all()
   44: 
   45:         # TODO: i think this isn't about MultiIndex and could be done with iloc?
   46: 
   47: 
   48: def test_37477():
   49:     # fixed by GH#45121
   50:     orig = DataFrame({"A": [1, 2, 3], "B": [3, 4, 5]})
   51:     expected = DataFrame({"A": [1, 2, 3], "B": [3, 1.2, 5]})
   52: 
   53:     df = orig.copy()
   54:     with tm.assert_produces_warning(
   55:         FutureWarning, match="Setting an item of incompatible dtype"
   56:     ):
   57:         df.at[1, "B"] = 1.2
   58:     tm.assert_frame_equal(df, expected)
   59: 
   60:     df = orig.copy()
   61:     with tm.assert_produces_warning(
   62:         FutureWarning, match="Setting an item of incompatible dtype"
   63:     ):
   64:         df.loc[1, "B"] = 1.2
   65:     tm.assert_frame_equal(df, expected)
   66: 
   67:     df = orig.copy()
   68:     with tm.assert_produces_warning(
   69:         FutureWarning, match="Setting an item of incompatible dtype"
   70:     ):
   71:         df.iat[1, 1] = 1.2
   72:     tm.assert_frame_equal(df, expected)
   73: 
   74:     df = orig.copy()
   75:     with tm.assert_produces_warning(
   76:         FutureWarning, match="Setting an item of incompatible dtype"
   77:     ):
   78:         df.iloc[1, 1] = 1.2
   79:     tm.assert_frame_equal(df, expected)
   80: 
   81: 
   82: def test_6942(indexer_al):
   83:     # check that the .at __setitem__ after setting "Live" actually sets the data
   84:     start = Timestamp("2014-04-01")
   85:     t1 = Timestamp("2014-04-23 12:42:38.883082")
   86:     t2 = Timestamp("2014-04-24 01:33:30.040039")
   87: 
   88:     dti = date_range(start, periods=1)
   89:     orig = DataFrame(index=dti, columns=["timenow", "Live"])
   90: 
   91:     df = orig.copy()
   92:     indexer_al(df)[start, "timenow"] = t1
   93: 
   94:     df["Live"] = True
   95: 
   96:     df.at[start, "timenow"] = t2
   97:     assert df.iloc[0, 0] == t2
   98: 
   99: 
  100: def test_26395(indexer_al):
  101:     # .at case fixed by GH#45121 (best guess)
  102:     df = DataFrame(index=["A", "B", "C"])
  103:     df["D"] = 0
  104: 
  105:     indexer_al(df)["C", "D"] = 2
  106:     expected = DataFrame({"D": [0, 0, 2]}, index=["A", "B", "C"], dtype=np.int64)
  107:     tm.assert_frame_equal(df, expected)
  108: 
  109:     with tm.assert_produces_warning(
  110:         FutureWarning, match="Setting an item of incompatible dtype"
  111:     ):
  112:         indexer_al(df)["C", "D"] = 44.5
  113:     expected = DataFrame({"D": [0, 0, 44.5]}, index=["A", "B", "C"], dtype=np.float64)
  114:     tm.assert_frame_equal(df, expected)
  115: 
  116:     with tm.assert_produces_warning(
  117:         FutureWarning, match="Setting an item of incompatible dtype"
  118:     ):
  119:         indexer_al(df)["C", "D"] = "hello"
  120:     expected = DataFrame({"D": [0, 0, "hello"]}, index=["A", "B", "C"], dtype=object)
  121:     tm.assert_frame_equal(df, expected)
  122: 
  123: 
  124: @pytest.mark.xfail(reason="unwanted upcast")
  125: def test_15231():
  126:     df = DataFrame([[1, 2], [3, 4]], columns=["a", "b"])
  127:     df.loc[2] = Series({"a": 5, "b": 6})
  128:     assert (df.dtypes == np.int64).all()
  129: 
  130:     df.loc[3] = Series({"a": 7})
  131: 
  132:     # df["a"] doesn't have any NaNs, should not have been cast
  133:     exp_dtypes = Series([np.int64, np.float64], dtype=object, index=["a", "b"])
  134:     tm.assert_series_equal(df.dtypes, exp_dtypes)
  135: 
  136: 
  137: def test_iloc_setitem_unnecesssary_float_upcasting():
  138:     # GH#12255
  139:     df = DataFrame(
  140:         {
  141:             0: np.array([1, 3], dtype=np.float32),
  142:             1: np.array([2, 4], dtype=np.float32),
  143:             2: ["a", "b"],
  144:         }
  145:     )
  146:     orig = df.copy()
  147: 
  148:     values = df[0].values.reshape(2, 1)
  149:     df.iloc[:, 0:1] = values
  150: 
  151:     tm.assert_frame_equal(df, orig)
  152: 
  153: 
  154: @pytest.mark.xfail(reason="unwanted casting to dt64")
  155: def test_12499():
  156:     # TODO: OP in GH#12499 used np.datetim64("NaT") instead of pd.NaT,
  157:     #  which has consequences for the expected df["two"] (though i think at
  158:     #  the time it might not have because of a separate bug). See if it makes
  159:     #  a difference which one we use here.
  160:     ts = Timestamp("2016-03-01 03:13:22.98986", tz="UTC")
  161: 
  162:     data = [{"one": 0, "two": ts}]
  163:     orig = DataFrame(data)
  164:     df = orig.copy()
  165:     df.loc[1] = [np.nan, NaT]
  166: 
  167:     expected = DataFrame(
  168:         {"one": [0, np.nan], "two": Series([ts, NaT], dtype="datetime64[ns, UTC]")}
  169:     )
  170:     tm.assert_frame_equal(df, expected)
  171: 
  172:     data = [{"one": 0, "two": ts}]
  173:     df = orig.copy()
  174:     df.loc[1, :] = [np.nan, NaT]
  175:     tm.assert_frame_equal(df, expected)
  176: 
  177: 
  178: def test_20476():
  179:     mi = MultiIndex.from_product([["A", "B"], ["a", "b", "c"]])
  180:     df = DataFrame(-1, index=range(3), columns=mi)
  181:     filler = DataFrame([[1, 2, 3.0]] * 3, index=range(3), columns=["a", "b", "c"])
  182:     df["A"] = filler
  183: 
  184:     expected = DataFrame(
  185:         {
  186:             0: [1, 1, 1],
  187:             1: [2, 2, 2],
  188:             2: [3.0, 3.0, 3.0],
  189:             3: [-1, -1, -1],
  190:             4: [-1, -1, -1],
  191:             5: [-1, -1, -1],
  192:         }
  193:     )
  194:     expected.columns = mi
  195:     exp_dtypes = Series(
  196:         [np.dtype(np.int64)] * 2 + [np.dtype(np.float64)] + [np.dtype(np.int64)] * 3,
  197:         index=mi,
  198:     )
  199:     tm.assert_series_equal(df.dtypes, exp_dtypes)
