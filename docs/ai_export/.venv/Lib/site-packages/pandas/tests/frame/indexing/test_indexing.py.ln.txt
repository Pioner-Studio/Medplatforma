    1: from collections import namedtuple
    2: from datetime import (
    3:     datetime,
    4:     timedelta,
    5: )
    6: from decimal import Decimal
    7: import re
    8: 
    9: import numpy as np
   10: import pytest
   11: 
   12: from pandas._libs import iNaT
   13: from pandas.errors import (
   14:     InvalidIndexError,
   15:     PerformanceWarning,
   16:     SettingWithCopyError,
   17: )
   18: import pandas.util._test_decorators as td
   19: 
   20: from pandas.core.dtypes.common import is_integer
   21: 
   22: import pandas as pd
   23: from pandas import (
   24:     Categorical,
   25:     DataFrame,
   26:     DatetimeIndex,
   27:     Index,
   28:     MultiIndex,
   29:     Series,
   30:     Timestamp,
   31:     date_range,
   32:     isna,
   33:     notna,
   34:     to_datetime,
   35: )
   36: import pandas._testing as tm
   37: 
   38: # We pass through a TypeError raised by numpy
   39: _slice_msg = "slice indices must be integers or None or have an __index__ method"
   40: 
   41: 
   42: class TestDataFrameIndexing:
   43:     def test_getitem(self, float_frame):
   44:         # Slicing
   45:         sl = float_frame[:20]
   46:         assert len(sl.index) == 20
   47: 
   48:         # Column access
   49:         for _, series in sl.items():
   50:             assert len(series.index) == 20
   51:             tm.assert_index_equal(series.index, sl.index)
   52: 
   53:         for key, _ in float_frame._series.items():
   54:             assert float_frame[key] is not None
   55: 
   56:         assert "random" not in float_frame
   57:         with pytest.raises(KeyError, match="random"):
   58:             float_frame["random"]
   59: 
   60:     def test_getitem_numeric_should_not_fallback_to_positional(self, any_numeric_dtype):
   61:         # GH51053
   62:         dtype = any_numeric_dtype
   63:         idx = Index([1, 0, 1], dtype=dtype)
   64:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=idx)
   65:         result = df[1]
   66:         expected = DataFrame([[1, 3], [4, 6]], columns=Index([1, 1], dtype=dtype))
   67:         tm.assert_frame_equal(result, expected, check_exact=True)
   68: 
   69:     def test_getitem2(self, float_frame):
   70:         df = float_frame.copy()
   71:         df["$10"] = np.random.default_rng(2).standard_normal(len(df))
   72: 
   73:         ad = np.random.default_rng(2).standard_normal(len(df))
   74:         df["@awesome_domain"] = ad
   75: 
   76:         with pytest.raises(KeyError, match=re.escape("'df[\"$10\"]'")):
   77:             df.__getitem__('df["$10"]')
   78: 
   79:         res = df["@awesome_domain"]
   80:         tm.assert_numpy_array_equal(ad, res.values)
   81: 
   82:     def test_setitem_numeric_should_not_fallback_to_positional(self, any_numeric_dtype):
   83:         # GH51053
   84:         dtype = any_numeric_dtype
   85:         idx = Index([1, 0, 1], dtype=dtype)
   86:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=idx)
   87:         df[1] = 10
   88:         expected = DataFrame([[10, 2, 10], [10, 5, 10]], columns=idx)
   89:         tm.assert_frame_equal(df, expected, check_exact=True)
   90: 
   91:     def test_setitem_list(self, float_frame):
   92:         float_frame["E"] = "foo"
   93:         data = float_frame[["A", "B"]]
   94:         float_frame[["B", "A"]] = data
   95: 
   96:         tm.assert_series_equal(float_frame["B"], data["A"], check_names=False)
   97:         tm.assert_series_equal(float_frame["A"], data["B"], check_names=False)
   98: 
   99:         msg = "Columns must be same length as key"
  100:         with pytest.raises(ValueError, match=msg):
  101:             data[["A"]] = float_frame[["A", "B"]]
  102:         newcolumndata = range(len(data.index) - 1)
  103:         msg = (
  104:             rf"Length of values \({len(newcolumndata)}\) "
  105:             rf"does not match length of index \({len(data)}\)"
  106:         )
  107:         with pytest.raises(ValueError, match=msg):
  108:             data["A"] = newcolumndata
  109: 
  110:     def test_setitem_list2(self):
  111:         df = DataFrame(0, index=range(3), columns=["tt1", "tt2"], dtype=int)
  112:         df.loc[1, ["tt1", "tt2"]] = [1, 2]
  113: 
  114:         result = df.loc[df.index[1], ["tt1", "tt2"]]
  115:         expected = Series([1, 2], df.columns, dtype=int, name=1)
  116:         tm.assert_series_equal(result, expected)
  117: 
  118:         df["tt1"] = df["tt2"] = "0"
  119:         df.loc[df.index[1], ["tt1", "tt2"]] = ["1", "2"]
  120:         result = df.loc[df.index[1], ["tt1", "tt2"]]
  121:         expected = Series(["1", "2"], df.columns, name=1)
  122:         tm.assert_series_equal(result, expected)
  123: 
  124:     def test_getitem_boolean(self, mixed_float_frame, mixed_int_frame, datetime_frame):
  125:         # boolean indexing
  126:         d = datetime_frame.index[10]
  127:         indexer = datetime_frame.index > d
  128:         indexer_obj = indexer.astype(object)
  129: 
  130:         subindex = datetime_frame.index[indexer]
  131:         subframe = datetime_frame[indexer]
  132: 
  133:         tm.assert_index_equal(subindex, subframe.index)
  134:         with pytest.raises(ValueError, match="Item wrong length"):
  135:             datetime_frame[indexer[:-1]]
  136: 
  137:         subframe_obj = datetime_frame[indexer_obj]
  138:         tm.assert_frame_equal(subframe_obj, subframe)
  139: 
  140:         with pytest.raises(ValueError, match="Boolean array expected"):
  141:             datetime_frame[datetime_frame]
  142: 
  143:         # test that Series work
  144:         indexer_obj = Series(indexer_obj, datetime_frame.index)
  145: 
  146:         subframe_obj = datetime_frame[indexer_obj]
  147:         tm.assert_frame_equal(subframe_obj, subframe)
  148: 
  149:         # test that Series indexers reindex
  150:         # we are producing a warning that since the passed boolean
  151:         # key is not the same as the given index, we will reindex
  152:         # not sure this is really necessary
  153:         with tm.assert_produces_warning(UserWarning):
  154:             indexer_obj = indexer_obj.reindex(datetime_frame.index[::-1])
  155:             subframe_obj = datetime_frame[indexer_obj]
  156:             tm.assert_frame_equal(subframe_obj, subframe)
  157: 
  158:         # test df[df > 0]
  159:         for df in [
  160:             datetime_frame,
  161:             mixed_float_frame,
  162:             mixed_int_frame,
  163:         ]:
  164:             data = df._get_numeric_data()
  165:             bif = df[df > 0]
  166:             bifw = DataFrame(
  167:                 {c: np.where(data[c] > 0, data[c], np.nan) for c in data.columns},
  168:                 index=data.index,
  169:                 columns=data.columns,
  170:             )
  171: 
  172:             # add back other columns to compare
  173:             for c in df.columns:
  174:                 if c not in bifw:
  175:                     bifw[c] = df[c]
  176:             bifw = bifw.reindex(columns=df.columns)
  177: 
  178:             tm.assert_frame_equal(bif, bifw, check_dtype=False)
  179:             for c in df.columns:
  180:                 if bif[c].dtype != bifw[c].dtype:
  181:                     assert bif[c].dtype == df[c].dtype
  182: 
  183:     def test_getitem_boolean_casting(self, datetime_frame):
  184:         # don't upcast if we don't need to
  185:         df = datetime_frame.copy()
  186:         df["E"] = 1
  187:         df["E"] = df["E"].astype("int32")
  188:         df["E1"] = df["E"].copy()
  189:         df["F"] = 1
  190:         df["F"] = df["F"].astype("int64")
  191:         df["F1"] = df["F"].copy()
  192: 
  193:         casted = df[df > 0]
  194:         result = casted.dtypes
  195:         expected = Series(
  196:             [np.dtype("float64")] * 4
  197:             + [np.dtype("int32")] * 2
  198:             + [np.dtype("int64")] * 2,
  199:             index=["A", "B", "C", "D", "E", "E1", "F", "F1"],
  200:         )
  201:         tm.assert_series_equal(result, expected)
  202: 
  203:         # int block splitting
  204:         df.loc[df.index[1:3], ["E1", "F1"]] = 0
  205:         casted = df[df > 0]
  206:         result = casted.dtypes
  207:         expected = Series(
  208:             [np.dtype("float64")] * 4
  209:             + [np.dtype("int32")]
  210:             + [np.dtype("float64")]
  211:             + [np.dtype("int64")]
  212:             + [np.dtype("float64")],
  213:             index=["A", "B", "C", "D", "E", "E1", "F", "F1"],
  214:         )
  215:         tm.assert_series_equal(result, expected)
  216: 
  217:     @pytest.mark.parametrize(
  218:         "lst", [[True, False, True], [True, True, True], [False, False, False]]
  219:     )
  220:     def test_getitem_boolean_list(self, lst):
  221:         df = DataFrame(np.arange(12).reshape(3, 4))
  222:         result = df[lst]
  223:         expected = df.loc[df.index[lst]]
  224:         tm.assert_frame_equal(result, expected)
  225: 
  226:     def test_getitem_boolean_iadd(self):
  227:         arr = np.random.default_rng(2).standard_normal((5, 5))
  228: 
  229:         df = DataFrame(arr.copy(), columns=["A", "B", "C", "D", "E"])
  230: 
  231:         df[df < 0] += 1
  232:         arr[arr < 0] += 1
  233: 
  234:         tm.assert_almost_equal(df.values, arr)
  235: 
  236:     def test_boolean_index_empty_corner(self):
  237:         # #2096
  238:         blah = DataFrame(np.empty([0, 1]), columns=["A"], index=DatetimeIndex([]))
  239: 
  240:         # both of these should succeed trivially
  241:         k = np.array([], bool)
  242: 
  243:         blah[k]
  244:         blah[k] = 0
  245: 
  246:     def test_getitem_ix_mixed_integer(self):
  247:         df = DataFrame(
  248:             np.random.default_rng(2).standard_normal((4, 3)),
  249:             index=[1, 10, "C", "E"],
  250:             columns=[1, 2, 3],
  251:         )
  252: 
  253:         result = df.iloc[:-1]
  254:         expected = df.loc[df.index[:-1]]
  255:         tm.assert_frame_equal(result, expected)
  256: 
  257:         result = df.loc[[1, 10]]
  258:         expected = df.loc[Index([1, 10])]
  259:         tm.assert_frame_equal(result, expected)
  260: 
  261:     def test_getitem_ix_mixed_integer2(self):
  262:         # 11320
  263:         df = DataFrame(
  264:             {
  265:                 "rna": (1.5, 2.2, 3.2, 4.5),
  266:                 -1000: [11, 21, 36, 40],
  267:                 0: [10, 22, 43, 34],
  268:                 1000: [0, 10, 20, 30],
  269:             },
  270:             columns=["rna", -1000, 0, 1000],
  271:         )
  272:         result = df[[1000]]
  273:         expected = df.iloc[:, [3]]
  274:         tm.assert_frame_equal(result, expected)
  275:         result = df[[-1000]]
  276:         expected = df.iloc[:, [1]]
  277:         tm.assert_frame_equal(result, expected)
  278: 
  279:     def test_getattr(self, float_frame):
  280:         tm.assert_series_equal(float_frame.A, float_frame["A"])
  281:         msg = "'DataFrame' object has no attribute 'NONEXISTENT_NAME'"
  282:         with pytest.raises(AttributeError, match=msg):
  283:             float_frame.NONEXISTENT_NAME
  284: 
  285:     def test_setattr_column(self):
  286:         df = DataFrame({"foobar": 1}, index=range(10))
  287: 
  288:         df.foobar = 5
  289:         assert (df.foobar == 5).all()
  290: 
  291:     def test_setitem(
  292:         self, float_frame, using_copy_on_write, warn_copy_on_write, using_infer_string
  293:     ):
  294:         # not sure what else to do here
  295:         series = float_frame["A"][::2]
  296:         float_frame["col5"] = series
  297:         assert "col5" in float_frame
  298: 
  299:         assert len(series) == 15
  300:         assert len(float_frame) == 30
  301: 
  302:         exp = np.ravel(np.column_stack((series.values, [np.nan] * 15)))
  303:         exp = Series(exp, index=float_frame.index, name="col5")
  304:         tm.assert_series_equal(float_frame["col5"], exp)
  305: 
  306:         series = float_frame["A"]
  307:         float_frame["col6"] = series
  308:         tm.assert_series_equal(series, float_frame["col6"], check_names=False)
  309: 
  310:         # set ndarray
  311:         arr = np.random.default_rng(2).standard_normal(len(float_frame))
  312:         float_frame["col9"] = arr
  313:         assert (float_frame["col9"] == arr).all()
  314: 
  315:         float_frame["col7"] = 5
  316:         assert (float_frame["col7"] == 5).all()
  317: 
  318:         float_frame["col0"] = 3.14
  319:         assert (float_frame["col0"] == 3.14).all()
  320: 
  321:         float_frame["col8"] = "foo"
  322:         assert (float_frame["col8"] == "foo").all()
  323: 
  324:         # this is partially a view (e.g. some blocks are view)
  325:         # so raise/warn
  326:         smaller = float_frame[:2]
  327: 
  328:         msg = r"\nA value is trying to be set on a copy of a slice from a DataFrame"
  329:         if using_copy_on_write or warn_copy_on_write:
  330:             # With CoW, adding a new column doesn't raise a warning
  331:             smaller["col10"] = ["1", "2"]
  332:         else:
  333:             with pytest.raises(SettingWithCopyError, match=msg):
  334:                 smaller["col10"] = ["1", "2"]
  335: 
  336:         if using_infer_string:
  337:             assert smaller["col10"].dtype == "string"
  338:         else:
  339:             assert smaller["col10"].dtype == np.object_
  340:         assert (smaller["col10"] == ["1", "2"]).all()
  341: 
  342:     def test_setitem2(self):
  343:         # dtype changing GH4204
  344:         df = DataFrame([[0, 0]])
  345:         df.iloc[0] = np.nan
  346:         expected = DataFrame([[np.nan, np.nan]])
  347:         tm.assert_frame_equal(df, expected)
  348: 
  349:         df = DataFrame([[0, 0]])
  350:         df.loc[0] = np.nan
  351:         tm.assert_frame_equal(df, expected)
  352: 
  353:     def test_setitem_boolean(self, float_frame):
  354:         df = float_frame.copy()
  355:         values = float_frame.values.copy()
  356: 
  357:         df[df["A"] > 0] = 4
  358:         values[values[:, 0] > 0] = 4
  359:         tm.assert_almost_equal(df.values, values)
  360: 
  361:         # test that column reindexing works
  362:         series = df["A"] == 4
  363:         series = series.reindex(df.index[::-1])
  364:         df[series] = 1
  365:         values[values[:, 0] == 4] = 1
  366:         tm.assert_almost_equal(df.values, values)
  367: 
  368:         df[df > 0] = 5
  369:         values[values > 0] = 5
  370:         tm.assert_almost_equal(df.values, values)
  371: 
  372:         df[df == 5] = 0
  373:         values[values == 5] = 0
  374:         tm.assert_almost_equal(df.values, values)
  375: 
  376:         # a df that needs alignment first
  377:         df[df[:-1] < 0] = 2
  378:         np.putmask(values[:-1], values[:-1] < 0, 2)
  379:         tm.assert_almost_equal(df.values, values)
  380: 
  381:         # indexed with same shape but rows-reversed df
  382:         df[df[::-1] == 2] = 3
  383:         values[values == 2] = 3
  384:         tm.assert_almost_equal(df.values, values)
  385: 
  386:         msg = "Must pass DataFrame or 2-d ndarray with boolean values only"
  387:         with pytest.raises(TypeError, match=msg):
  388:             df[df * 0] = 2
  389: 
  390:         # index with DataFrame
  391:         df_orig = df.copy()
  392:         mask = df > np.abs(df)
  393:         df[df > np.abs(df)] = np.nan
  394:         values = df_orig.values.copy()
  395:         values[mask.values] = np.nan
  396:         expected = DataFrame(values, index=df_orig.index, columns=df_orig.columns)
  397:         tm.assert_frame_equal(df, expected)
  398: 
  399:         # set from DataFrame
  400:         df[df > np.abs(df)] = df * 2
  401:         np.putmask(values, mask.values, df.values * 2)
  402:         expected = DataFrame(values, index=df_orig.index, columns=df_orig.columns)
  403:         tm.assert_frame_equal(df, expected)
  404: 
  405:     def test_setitem_cast(self, float_frame):
  406:         float_frame["D"] = float_frame["D"].astype("i8")
  407:         assert float_frame["D"].dtype == np.int64
  408: 
  409:         # #669, should not cast?
  410:         # this is now set to int64, which means a replacement of the column to
  411:         # the value dtype (and nothing to do with the existing dtype)
  412:         float_frame["B"] = 0
  413:         assert float_frame["B"].dtype == np.int64
  414: 
  415:         # cast if pass array of course
  416:         float_frame["B"] = np.arange(len(float_frame))
  417:         assert issubclass(float_frame["B"].dtype.type, np.integer)
  418: 
  419:         float_frame["foo"] = "bar"
  420:         float_frame["foo"] = 0
  421:         assert float_frame["foo"].dtype == np.int64
  422: 
  423:         float_frame["foo"] = "bar"
  424:         float_frame["foo"] = 2.5
  425:         assert float_frame["foo"].dtype == np.float64
  426: 
  427:         float_frame["something"] = 0
  428:         assert float_frame["something"].dtype == np.int64
  429:         float_frame["something"] = 2
  430:         assert float_frame["something"].dtype == np.int64
  431:         float_frame["something"] = 2.5
  432:         assert float_frame["something"].dtype == np.float64
  433: 
  434:     def test_setitem_corner(self, float_frame, using_infer_string):
  435:         # corner case
  436:         df = DataFrame({"B": [1.0, 2.0, 3.0], "C": ["a", "b", "c"]}, index=np.arange(3))
  437:         del df["B"]
  438:         df["B"] = [1.0, 2.0, 3.0]
  439:         assert "B" in df
  440:         assert len(df.columns) == 2
  441: 
  442:         df["A"] = "beginning"
  443:         df["E"] = "foo"
  444:         df["D"] = "bar"
  445:         df[datetime.now()] = "date"
  446:         df[datetime.now()] = 5.0
  447: 
  448:         # what to do when empty frame with index
  449:         dm = DataFrame(index=float_frame.index)
  450:         dm["A"] = "foo"
  451:         dm["B"] = "bar"
  452:         assert len(dm.columns) == 2
  453:         assert dm.values.dtype == np.object_
  454: 
  455:         # upcast
  456:         dm["C"] = 1
  457:         assert dm["C"].dtype == np.int64
  458: 
  459:         dm["E"] = 1.0
  460:         assert dm["E"].dtype == np.float64
  461: 
  462:         # set existing column
  463:         dm["A"] = "bar"
  464:         assert "bar" == dm["A"].iloc[0]
  465: 
  466:         dm = DataFrame(index=np.arange(3))
  467:         dm["A"] = 1
  468:         dm["foo"] = "bar"
  469:         del dm["foo"]
  470:         dm["foo"] = "bar"
  471:         if using_infer_string:
  472:             assert dm["foo"].dtype == "string"
  473:         else:
  474:             assert dm["foo"].dtype == np.object_
  475: 
  476:         dm["coercible"] = ["1", "2", "3"]
  477:         if using_infer_string:
  478:             assert dm["coercible"].dtype == "string"
  479:         else:
  480:             assert dm["coercible"].dtype == np.object_
  481: 
  482:     def test_setitem_corner2(self):
  483:         data = {
  484:             "title": ["foobar", "bar", "foobar"] + ["foobar"] * 17,
  485:             "cruft": np.random.default_rng(2).random(20),
  486:         }
  487: 
  488:         df = DataFrame(data)
  489:         ix = df[df["title"] == "bar"].index
  490: 
  491:         df.loc[ix, ["title"]] = "foobar"
  492:         df.loc[ix, ["cruft"]] = 0
  493: 
  494:         assert df.loc[1, "title"] == "foobar"
  495:         assert df.loc[1, "cruft"] == 0
  496: 
  497:     def test_setitem_ambig(self, using_infer_string):
  498:         # Difficulties with mixed-type data
  499:         # Created as float type
  500:         dm = DataFrame(index=range(3), columns=range(3))
  501: 
  502:         coercable_series = Series([Decimal(1) for _ in range(3)], index=range(3))
  503:         uncoercable_series = Series(["foo", "bzr", "baz"], index=range(3))
  504: 
  505:         dm[0] = np.ones(3)
  506:         assert len(dm.columns) == 3
  507: 
  508:         dm[1] = coercable_series
  509:         assert len(dm.columns) == 3
  510: 
  511:         dm[2] = uncoercable_series
  512:         assert len(dm.columns) == 3
  513:         if using_infer_string:
  514:             assert dm[2].dtype == "string"
  515:         else:
  516:             assert dm[2].dtype == np.object_
  517: 
  518:     def test_setitem_None(self, float_frame, using_infer_string):
  519:         # GH #766
  520:         float_frame[None] = float_frame["A"]
  521:         key = None if not using_infer_string else np.nan
  522:         tm.assert_series_equal(
  523:             float_frame.iloc[:, -1], float_frame["A"], check_names=False
  524:         )
  525:         tm.assert_series_equal(
  526:             float_frame.loc[:, key], float_frame["A"], check_names=False
  527:         )
  528:         tm.assert_series_equal(float_frame[key], float_frame["A"], check_names=False)
  529: 
  530:     def test_loc_setitem_boolean_mask_allfalse(self):
  531:         # GH 9596
  532:         df = DataFrame(
  533:             {"a": ["1", "2", "3"], "b": ["11", "22", "33"], "c": ["111", "222", "333"]}
  534:         )
  535: 
  536:         result = df.copy()
  537:         result.loc[result.b.isna(), "a"] = result.a.copy()
  538:         tm.assert_frame_equal(result, df)
  539: 
  540:     def test_getitem_fancy_slice_integers_step(self):
  541:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 5)))
  542: 
  543:         # this is OK
  544:         df.iloc[:8:2]
  545:         df.iloc[:8:2] = np.nan
  546:         assert isna(df.iloc[:8:2]).values.all()
  547: 
  548:     def test_getitem_setitem_integer_slice_keyerrors(self):
  549:         df = DataFrame(
  550:             np.random.default_rng(2).standard_normal((10, 5)), index=range(0, 20, 2)
  551:         )
  552: 
  553:         # this is OK
  554:         cp = df.copy()
  555:         cp.iloc[4:10] = 0
  556:         assert (cp.iloc[4:10] == 0).values.all()
  557: 
  558:         # so is this
  559:         cp = df.copy()
  560:         cp.iloc[3:11] = 0
  561:         assert (cp.iloc[3:11] == 0).values.all()
  562: 
  563:         result = df.iloc[2:6]
  564:         result2 = df.loc[3:11]
  565:         expected = df.reindex([4, 6, 8, 10])
  566: 
  567:         tm.assert_frame_equal(result, expected)
  568:         tm.assert_frame_equal(result2, expected)
  569: 
  570:         # non-monotonic, raise KeyError
  571:         df2 = df.iloc[list(range(5)) + list(range(5, 10))[::-1]]
  572:         with pytest.raises(KeyError, match=r"^3$"):
  573:             df2.loc[3:11]
  574:         with pytest.raises(KeyError, match=r"^3$"):
  575:             df2.loc[3:11] = 0
  576: 
  577:     @td.skip_array_manager_invalid_test  # already covered in test_iloc_col_slice_view
  578:     def test_fancy_getitem_slice_mixed(
  579:         self, float_frame, float_string_frame, using_copy_on_write, warn_copy_on_write
  580:     ):
  581:         sliced = float_string_frame.iloc[:, -3:]
  582:         assert sliced["D"].dtype == np.float64
  583: 
  584:         # get view with single block
  585:         # setting it triggers setting with copy
  586:         original = float_frame.copy()
  587:         sliced = float_frame.iloc[:, -3:]
  588: 
  589:         assert np.shares_memory(sliced["C"]._values, float_frame["C"]._values)
  590: 
  591:         with tm.assert_cow_warning(warn_copy_on_write):
  592:             sliced.loc[:, "C"] = 4.0
  593:         if not using_copy_on_write:
  594:             assert (float_frame["C"] == 4).all()
  595: 
  596:             # with the enforcement of GH#45333 in 2.0, this remains a view
  597:             np.shares_memory(sliced["C"]._values, float_frame["C"]._values)
  598:         else:
  599:             tm.assert_frame_equal(float_frame, original)
  600: 
  601:     def test_getitem_setitem_non_ix_labels(self):
  602:         df = DataFrame(range(20), index=date_range("2020-01-01", periods=20))
  603: 
  604:         start, end = df.index[[5, 10]]
  605: 
  606:         result = df.loc[start:end]
  607:         result2 = df[start:end]
  608:         expected = df[5:11]
  609:         tm.assert_frame_equal(result, expected)
  610:         tm.assert_frame_equal(result2, expected)
  611: 
  612:         result = df.copy()
  613:         result.loc[start:end] = 0
  614:         result2 = df.copy()
  615:         result2[start:end] = 0
  616:         expected = df.copy()
  617:         expected[5:11] = 0
  618:         tm.assert_frame_equal(result, expected)
  619:         tm.assert_frame_equal(result2, expected)
  620: 
  621:     def test_ix_multi_take(self):
  622:         df = DataFrame(np.random.default_rng(2).standard_normal((3, 2)))
  623:         rs = df.loc[df.index == 0, :]
  624:         xp = df.reindex([0])
  625:         tm.assert_frame_equal(rs, xp)
  626: 
  627:         # GH#1321
  628:         df = DataFrame(np.random.default_rng(2).standard_normal((3, 2)))
  629:         rs = df.loc[df.index == 0, df.columns == 1]
  630:         xp = df.reindex(index=[0], columns=[1])
  631:         tm.assert_frame_equal(rs, xp)
  632: 
  633:     def test_getitem_fancy_scalar(self, float_frame):
  634:         f = float_frame
  635:         ix = f.loc
  636: 
  637:         # individual value
  638:         for col in f.columns:
  639:             ts = f[col]
  640:             for idx in f.index[::5]:
  641:                 assert ix[idx, col] == ts[idx]
  642: 
  643:     @td.skip_array_manager_invalid_test  # TODO(ArrayManager) rewrite not using .values
  644:     def test_setitem_fancy_scalar(self, float_frame):
  645:         f = float_frame
  646:         expected = float_frame.copy()
  647:         ix = f.loc
  648: 
  649:         # individual value
  650:         for j, col in enumerate(f.columns):
  651:             f[col]
  652:             for idx in f.index[::5]:
  653:                 i = f.index.get_loc(idx)
  654:                 val = np.random.default_rng(2).standard_normal()
  655:                 expected.iloc[i, j] = val
  656: 
  657:                 ix[idx, col] = val
  658:                 tm.assert_frame_equal(f, expected)
  659: 
  660:     def test_getitem_fancy_boolean(self, float_frame):
  661:         f = float_frame
  662:         ix = f.loc
  663: 
  664:         expected = f.reindex(columns=["B", "D"])
  665:         result = ix[:, [False, True, False, True]]
  666:         tm.assert_frame_equal(result, expected)
  667: 
  668:         expected = f.reindex(index=f.index[5:10], columns=["B", "D"])
  669:         result = ix[f.index[5:10], [False, True, False, True]]
  670:         tm.assert_frame_equal(result, expected)
  671: 
  672:         boolvec = f.index > f.index[7]
  673:         expected = f.reindex(index=f.index[boolvec])
  674:         result = ix[boolvec]
  675:         tm.assert_frame_equal(result, expected)
  676:         result = ix[boolvec, :]
  677:         tm.assert_frame_equal(result, expected)
  678: 
  679:         result = ix[boolvec, f.columns[2:]]
  680:         expected = f.reindex(index=f.index[boolvec], columns=["C", "D"])
  681:         tm.assert_frame_equal(result, expected)
  682: 
  683:     @td.skip_array_manager_invalid_test  # TODO(ArrayManager) rewrite not using .values
  684:     def test_setitem_fancy_boolean(self, float_frame):
  685:         # from 2d, set with booleans
  686:         frame = float_frame.copy()
  687:         expected = float_frame.copy()
  688:         values = expected.values.copy()
  689: 
  690:         mask = frame["A"] > 0
  691:         frame.loc[mask] = 0.0
  692:         values[mask.values] = 0.0
  693:         expected = DataFrame(values, index=expected.index, columns=expected.columns)
  694:         tm.assert_frame_equal(frame, expected)
  695: 
  696:         frame = float_frame.copy()
  697:         expected = float_frame.copy()
  698:         values = expected.values.copy()
  699:         frame.loc[mask, ["A", "B"]] = 0.0
  700:         values[mask.values, :2] = 0.0
  701:         expected = DataFrame(values, index=expected.index, columns=expected.columns)
  702:         tm.assert_frame_equal(frame, expected)
  703: 
  704:     def test_getitem_fancy_ints(self, float_frame):
  705:         result = float_frame.iloc[[1, 4, 7]]
  706:         expected = float_frame.loc[float_frame.index[[1, 4, 7]]]
  707:         tm.assert_frame_equal(result, expected)
  708: 
  709:         result = float_frame.iloc[:, [2, 0, 1]]
  710:         expected = float_frame.loc[:, float_frame.columns[[2, 0, 1]]]
  711:         tm.assert_frame_equal(result, expected)
  712: 
  713:     def test_getitem_setitem_boolean_misaligned(self, float_frame):
  714:         # boolean index misaligned labels
  715:         mask = float_frame["A"][::-1] > 1
  716: 
  717:         result = float_frame.loc[mask]
  718:         expected = float_frame.loc[mask[::-1]]
  719:         tm.assert_frame_equal(result, expected)
  720: 
  721:         cp = float_frame.copy()
  722:         expected = float_frame.copy()
  723:         cp.loc[mask] = 0
  724:         expected.loc[mask] = 0
  725:         tm.assert_frame_equal(cp, expected)
  726: 
  727:     def test_getitem_setitem_boolean_multi(self):
  728:         df = DataFrame(np.random.default_rng(2).standard_normal((3, 2)))
  729: 
  730:         # get
  731:         k1 = np.array([True, False, True])
  732:         k2 = np.array([False, True])
  733:         result = df.loc[k1, k2]
  734:         expected = df.loc[[0, 2], [1]]
  735:         tm.assert_frame_equal(result, expected)
  736: 
  737:         expected = df.copy()
  738:         df.loc[np.array([True, False, True]), np.array([False, True])] = 5
  739:         expected.loc[[0, 2], [1]] = 5
  740:         tm.assert_frame_equal(df, expected)
  741: 
  742:     def test_getitem_setitem_float_labels(self, using_array_manager):
  743:         index = Index([1.5, 2, 3, 4, 5])
  744:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)), index=index)
  745: 
  746:         result = df.loc[1.5:4]
  747:         expected = df.reindex([1.5, 2, 3, 4])
  748:         tm.assert_frame_equal(result, expected)
  749:         assert len(result) == 4
  750: 
  751:         result = df.loc[4:5]
  752:         expected = df.reindex([4, 5])  # reindex with int
  753:         tm.assert_frame_equal(result, expected, check_index_type=False)
  754:         assert len(result) == 2
  755: 
  756:         result = df.loc[4:5]
  757:         expected = df.reindex([4.0, 5.0])  # reindex with float
  758:         tm.assert_frame_equal(result, expected)
  759:         assert len(result) == 2
  760: 
  761:         # loc_float changes this to work properly
  762:         result = df.loc[1:2]
  763:         expected = df.iloc[0:2]
  764:         tm.assert_frame_equal(result, expected)
  765: 
  766:         expected = df.iloc[0:2]
  767:         msg = r"The behavior of obj\[i:j\] with a float-dtype index"
  768:         with tm.assert_produces_warning(FutureWarning, match=msg):
  769:             result = df[1:2]
  770:         tm.assert_frame_equal(result, expected)
  771: 
  772:         # #2727
  773:         index = Index([1.0, 2.5, 3.5, 4.5, 5.0])
  774:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)), index=index)
  775: 
  776:         # positional slicing only via iloc!
  777:         msg = (
  778:             "cannot do positional indexing on Index with "
  779:             r"these indexers \[1.0\] of type float"
  780:         )
  781:         with pytest.raises(TypeError, match=msg):
  782:             df.iloc[1.0:5]
  783: 
  784:         result = df.iloc[4:5]
  785:         expected = df.reindex([5.0])
  786:         tm.assert_frame_equal(result, expected)
  787:         assert len(result) == 1
  788: 
  789:         cp = df.copy()
  790: 
  791:         with pytest.raises(TypeError, match=_slice_msg):
  792:             cp.iloc[1.0:5] = 0
  793: 
  794:         with pytest.raises(TypeError, match=msg):
  795:             result = cp.iloc[1.0:5] == 0
  796: 
  797:         assert result.values.all()
  798:         assert (cp.iloc[0:1] == df.iloc[0:1]).values.all()
  799: 
  800:         cp = df.copy()
  801:         cp.iloc[4:5] = 0
  802:         assert (cp.iloc[4:5] == 0).values.all()
  803:         assert (cp.iloc[0:4] == df.iloc[0:4]).values.all()
  804: 
  805:         # float slicing
  806:         result = df.loc[1.0:5]
  807:         expected = df
  808:         tm.assert_frame_equal(result, expected)
  809:         assert len(result) == 5
  810: 
  811:         result = df.loc[1.1:5]
  812:         expected = df.reindex([2.5, 3.5, 4.5, 5.0])
  813:         tm.assert_frame_equal(result, expected)
  814:         assert len(result) == 4
  815: 
  816:         result = df.loc[4.51:5]
  817:         expected = df.reindex([5.0])
  818:         tm.assert_frame_equal(result, expected)
  819:         assert len(result) == 1
  820: 
  821:         result = df.loc[1.0:5.0]
  822:         expected = df.reindex([1.0, 2.5, 3.5, 4.5, 5.0])
  823:         tm.assert_frame_equal(result, expected)
  824:         assert len(result) == 5
  825: 
  826:         cp = df.copy()
  827:         cp.loc[1.0:5.0] = 0
  828:         result = cp.loc[1.0:5.0]
  829:         assert (result == 0).values.all()
  830: 
  831:     def test_setitem_single_column_mixed_datetime(self):
  832:         df = DataFrame(
  833:             np.random.default_rng(2).standard_normal((5, 3)),
  834:             index=["a", "b", "c", "d", "e"],
  835:             columns=["foo", "bar", "baz"],
  836:         )
  837: 
  838:         df["timestamp"] = Timestamp("20010102")
  839: 
  840:         # check our dtypes
  841:         result = df.dtypes
  842:         expected = Series(
  843:             [np.dtype("float64")] * 3 + [np.dtype("datetime64[s]")],
  844:             index=["foo", "bar", "baz", "timestamp"],
  845:         )
  846:         tm.assert_series_equal(result, expected)
  847: 
  848:         # GH#16674 iNaT is treated as an integer when given by the user
  849:         with tm.assert_produces_warning(
  850:             FutureWarning, match="Setting an item of incompatible dtype"
  851:         ):
  852:             df.loc["b", "timestamp"] = iNaT
  853:         assert not isna(df.loc["b", "timestamp"])
  854:         assert df["timestamp"].dtype == np.object_
  855:         assert df.loc["b", "timestamp"] == iNaT
  856: 
  857:         # allow this syntax (as of GH#3216)
  858:         df.loc["c", "timestamp"] = np.nan
  859:         assert isna(df.loc["c", "timestamp"])
  860: 
  861:         # allow this syntax
  862:         df.loc["d", :] = np.nan
  863:         assert not isna(df.loc["c", :]).all()
  864: 
  865:     def test_setitem_mixed_datetime(self):
  866:         # GH 9336
  867:         expected = DataFrame(
  868:             {
  869:                 "a": [0, 0, 0, 0, 13, 14],
  870:                 "b": [
  871:                     datetime(2012, 1, 1),
  872:                     1,
  873:                     "x",
  874:                     "y",
  875:                     datetime(2013, 1, 1),
  876:                     datetime(2014, 1, 1),
  877:                 ],
  878:             }
  879:         )
  880:         df = DataFrame(0, columns=list("ab"), index=range(6))
  881:         df["b"] = pd.NaT
  882:         df.loc[0, "b"] = datetime(2012, 1, 1)
  883:         with tm.assert_produces_warning(
  884:             FutureWarning, match="Setting an item of incompatible dtype"
  885:         ):
  886:             df.loc[1, "b"] = 1
  887:         df.loc[[2, 3], "b"] = "x", "y"
  888:         A = np.array(
  889:             [
  890:                 [13, np.datetime64("2013-01-01T00:00:00")],
  891:                 [14, np.datetime64("2014-01-01T00:00:00")],
  892:             ]
  893:         )
  894:         df.loc[[4, 5], ["a", "b"]] = A
  895:         tm.assert_frame_equal(df, expected)
  896: 
  897:     def test_setitem_frame_float(self, float_frame):
  898:         piece = float_frame.loc[float_frame.index[:2], ["A", "B"]]
  899:         float_frame.loc[float_frame.index[-2] :, ["A", "B"]] = piece.values
  900:         result = float_frame.loc[float_frame.index[-2:], ["A", "B"]].values
  901:         expected = piece.values
  902:         tm.assert_almost_equal(result, expected)
  903: 
  904:     def test_setitem_frame_mixed(self, float_string_frame):
  905:         # GH 3216
  906: 
  907:         # already aligned
  908:         f = float_string_frame.copy()
  909:         piece = DataFrame(
  910:             [[1.0, 2.0], [3.0, 4.0]], index=f.index[0:2], columns=["A", "B"]
  911:         )
  912:         key = (f.index[slice(None, 2)], ["A", "B"])
  913:         f.loc[key] = piece
  914:         tm.assert_almost_equal(f.loc[f.index[0:2], ["A", "B"]].values, piece.values)
  915: 
  916:     def test_setitem_frame_mixed_rows_unaligned(self, float_string_frame):
  917:         # GH#3216 rows unaligned
  918:         f = float_string_frame.copy()
  919:         piece = DataFrame(
  920:             [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], [7.0, 8.0]],
  921:             index=list(f.index[0:2]) + ["foo", "bar"],
  922:             columns=["A", "B"],
  923:         )
  924:         key = (f.index[slice(None, 2)], ["A", "B"])
  925:         f.loc[key] = piece
  926:         tm.assert_almost_equal(
  927:             f.loc[f.index[0:2:], ["A", "B"]].values, piece.values[0:2]
  928:         )
  929: 
  930:     def test_setitem_frame_mixed_key_unaligned(self, float_string_frame):
  931:         # GH#3216 key is unaligned with values
  932:         f = float_string_frame.copy()
  933:         piece = f.loc[f.index[:2], ["A"]]
  934:         piece.index = f.index[-2:]
  935:         key = (f.index[slice(-2, None)], ["A", "B"])
  936:         f.loc[key] = piece
  937:         piece["B"] = np.nan
  938:         tm.assert_almost_equal(f.loc[f.index[-2:], ["A", "B"]].values, piece.values)
  939: 
  940:     def test_setitem_frame_mixed_ndarray(self, float_string_frame):
  941:         # GH#3216 ndarray
  942:         f = float_string_frame.copy()
  943:         piece = float_string_frame.loc[f.index[:2], ["A", "B"]]
  944:         key = (f.index[slice(-2, None)], ["A", "B"])
  945:         f.loc[key] = piece.values
  946:         tm.assert_almost_equal(f.loc[f.index[-2:], ["A", "B"]].values, piece.values)
  947: 
  948:     def test_setitem_frame_upcast(self):
  949:         # needs upcasting
  950:         df = DataFrame([[1, 2, "foo"], [3, 4, "bar"]], columns=["A", "B", "C"])
  951:         df2 = df.copy()
  952:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  953:             df2.loc[:, ["A", "B"]] = df.loc[:, ["A", "B"]] + 0.5
  954:         expected = df.reindex(columns=["A", "B"])
  955:         expected += 0.5
  956:         expected["C"] = df["C"]
  957:         tm.assert_frame_equal(df2, expected)
  958: 
  959:     def test_setitem_frame_align(self, float_frame):
  960:         piece = float_frame.loc[float_frame.index[:2], ["A", "B"]]
  961:         piece.index = float_frame.index[-2:]
  962:         piece.columns = ["A", "B"]
  963:         float_frame.loc[float_frame.index[-2:], ["A", "B"]] = piece
  964:         result = float_frame.loc[float_frame.index[-2:], ["A", "B"]].values
  965:         expected = piece.values
  966:         tm.assert_almost_equal(result, expected)
  967: 
  968:     def test_getitem_setitem_ix_duplicates(self):
  969:         # #1201
  970:         df = DataFrame(
  971:             np.random.default_rng(2).standard_normal((5, 3)),
  972:             index=["foo", "foo", "bar", "baz", "bar"],
  973:         )
  974: 
  975:         result = df.loc["foo"]
  976:         expected = df[:2]
  977:         tm.assert_frame_equal(result, expected)
  978: 
  979:         result = df.loc["bar"]
  980:         expected = df.iloc[[2, 4]]
  981:         tm.assert_frame_equal(result, expected)
  982: 
  983:         result = df.loc["baz"]
  984:         expected = df.iloc[3]
  985:         tm.assert_series_equal(result, expected)
  986: 
  987:     def test_getitem_ix_boolean_duplicates_multiple(self):
  988:         # #1201
  989:         df = DataFrame(
  990:             np.random.default_rng(2).standard_normal((5, 3)),
  991:             index=["foo", "foo", "bar", "baz", "bar"],
  992:         )
  993: 
  994:         result = df.loc[["bar"]]
  995:         exp = df.iloc[[2, 4]]
  996:         tm.assert_frame_equal(result, exp)
  997: 
  998:         result = df.loc[df[1] > 0]
  999:         exp = df[df[1] > 0]
 1000:         tm.assert_frame_equal(result, exp)
 1001: 
 1002:         result = df.loc[df[0] > 0]
 1003:         exp = df[df[0] > 0]
 1004:         tm.assert_frame_equal(result, exp)
 1005: 
 1006:     @pytest.mark.parametrize("bool_value", [True, False])
 1007:     def test_getitem_setitem_ix_bool_keyerror(self, bool_value):
 1008:         # #2199
 1009:         df = DataFrame({"a": [1, 2, 3]})
 1010:         message = f"{bool_value}: boolean label can not be used without a boolean index"
 1011:         with pytest.raises(KeyError, match=message):
 1012:             df.loc[bool_value]
 1013: 
 1014:         msg = "cannot use a single bool to index into setitem"
 1015:         with pytest.raises(KeyError, match=msg):
 1016:             df.loc[bool_value] = 0
 1017: 
 1018:     # TODO: rename?  remove?
 1019:     def test_single_element_ix_dont_upcast(self, float_frame):
 1020:         float_frame["E"] = 1
 1021:         assert issubclass(float_frame["E"].dtype.type, (int, np.integer))
 1022: 
 1023:         result = float_frame.loc[float_frame.index[5], "E"]
 1024:         assert is_integer(result)
 1025: 
 1026:         # GH 11617
 1027:         df = DataFrame({"a": [1.23]})
 1028:         df["b"] = 666
 1029: 
 1030:         result = df.loc[0, "b"]
 1031:         assert is_integer(result)
 1032: 
 1033:         expected = Series([666], [0], name="b")
 1034:         result = df.loc[[0], "b"]
 1035:         tm.assert_series_equal(result, expected)
 1036: 
 1037:     def test_iloc_callable_tuple_return_value(self):
 1038:         # GH53769
 1039:         df = DataFrame(np.arange(40).reshape(10, 4), index=range(0, 20, 2))
 1040:         msg = "callable with iloc"
 1041:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1042:             df.iloc[lambda _: (0,)]
 1043:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1044:             df.iloc[lambda _: (0,)] = 1
 1045: 
 1046:     def test_iloc_row(self):
 1047:         df = DataFrame(
 1048:             np.random.default_rng(2).standard_normal((10, 4)), index=range(0, 20, 2)
 1049:         )
 1050: 
 1051:         result = df.iloc[1]
 1052:         exp = df.loc[2]
 1053:         tm.assert_series_equal(result, exp)
 1054: 
 1055:         result = df.iloc[2]
 1056:         exp = df.loc[4]
 1057:         tm.assert_series_equal(result, exp)
 1058: 
 1059:         # slice
 1060:         result = df.iloc[slice(4, 8)]
 1061:         expected = df.loc[8:14]
 1062:         tm.assert_frame_equal(result, expected)
 1063: 
 1064:         # list of integers
 1065:         result = df.iloc[[1, 2, 4, 6]]
 1066:         expected = df.reindex(df.index[[1, 2, 4, 6]])
 1067:         tm.assert_frame_equal(result, expected)
 1068: 
 1069:     def test_iloc_row_slice_view(self, using_copy_on_write, warn_copy_on_write):
 1070:         df = DataFrame(
 1071:             np.random.default_rng(2).standard_normal((10, 4)), index=range(0, 20, 2)
 1072:         )
 1073:         original = df.copy()
 1074: 
 1075:         # verify slice is view
 1076:         # setting it makes it raise/warn
 1077:         subset = df.iloc[slice(4, 8)]
 1078: 
 1079:         assert np.shares_memory(df[2], subset[2])
 1080: 
 1081:         exp_col = original[2].copy()
 1082:         with tm.assert_cow_warning(warn_copy_on_write):
 1083:             subset.loc[:, 2] = 0.0
 1084:         if not using_copy_on_write:
 1085:             exp_col._values[4:8] = 0.0
 1086: 
 1087:             # With the enforcement of GH#45333 in 2.0, this remains a view
 1088:             assert np.shares_memory(df[2], subset[2])
 1089:         tm.assert_series_equal(df[2], exp_col)
 1090: 
 1091:     def test_iloc_col(self):
 1092:         df = DataFrame(
 1093:             np.random.default_rng(2).standard_normal((4, 10)), columns=range(0, 20, 2)
 1094:         )
 1095: 
 1096:         result = df.iloc[:, 1]
 1097:         exp = df.loc[:, 2]
 1098:         tm.assert_series_equal(result, exp)
 1099: 
 1100:         result = df.iloc[:, 2]
 1101:         exp = df.loc[:, 4]
 1102:         tm.assert_series_equal(result, exp)
 1103: 
 1104:         # slice
 1105:         result = df.iloc[:, slice(4, 8)]
 1106:         expected = df.loc[:, 8:14]
 1107:         tm.assert_frame_equal(result, expected)
 1108: 
 1109:         # list of integers
 1110:         result = df.iloc[:, [1, 2, 4, 6]]
 1111:         expected = df.reindex(columns=df.columns[[1, 2, 4, 6]])
 1112:         tm.assert_frame_equal(result, expected)
 1113: 
 1114:     def test_iloc_col_slice_view(
 1115:         self, using_array_manager, using_copy_on_write, warn_copy_on_write
 1116:     ):
 1117:         df = DataFrame(
 1118:             np.random.default_rng(2).standard_normal((4, 10)), columns=range(0, 20, 2)
 1119:         )
 1120:         original = df.copy()
 1121:         subset = df.iloc[:, slice(4, 8)]
 1122: 
 1123:         if not using_array_manager and not using_copy_on_write:
 1124:             # verify slice is view
 1125:             assert np.shares_memory(df[8]._values, subset[8]._values)
 1126: 
 1127:             with tm.assert_cow_warning(warn_copy_on_write):
 1128:                 subset.loc[:, 8] = 0.0
 1129: 
 1130:             assert (df[8] == 0).all()
 1131: 
 1132:             # with the enforcement of GH#45333 in 2.0, this remains a view
 1133:             assert np.shares_memory(df[8]._values, subset[8]._values)
 1134:         else:
 1135:             if using_copy_on_write:
 1136:                 # verify slice is view
 1137:                 assert np.shares_memory(df[8]._values, subset[8]._values)
 1138:             subset[8] = 0.0
 1139:             # subset changed
 1140:             assert (subset[8] == 0).all()
 1141:             # but df itself did not change (setitem replaces full column)
 1142:             tm.assert_frame_equal(df, original)
 1143: 
 1144:     def test_loc_duplicates(self):
 1145:         # gh-17105
 1146: 
 1147:         # insert a duplicate element to the index
 1148:         trange = date_range(
 1149:             start=Timestamp(year=2017, month=1, day=1),
 1150:             end=Timestamp(year=2017, month=1, day=5),
 1151:         )
 1152: 
 1153:         trange = trange.insert(loc=5, item=Timestamp(year=2017, month=1, day=5))
 1154: 
 1155:         df = DataFrame(0, index=trange, columns=["A", "B"])
 1156:         bool_idx = np.array([False, False, False, False, False, True])
 1157: 
 1158:         # assignment
 1159:         df.loc[trange[bool_idx], "A"] = 6
 1160: 
 1161:         expected = DataFrame(
 1162:             {"A": [0, 0, 0, 0, 6, 6], "B": [0, 0, 0, 0, 0, 0]}, index=trange
 1163:         )
 1164:         tm.assert_frame_equal(df, expected)
 1165: 
 1166:         # in-place
 1167:         df = DataFrame(0, index=trange, columns=["A", "B"])
 1168:         df.loc[trange[bool_idx], "A"] += 6
 1169:         tm.assert_frame_equal(df, expected)
 1170: 
 1171:     def test_setitem_with_unaligned_tz_aware_datetime_column(self):
 1172:         # GH 12981
 1173:         # Assignment of unaligned offset-aware datetime series.
 1174:         # Make sure timezone isn't lost
 1175:         column = Series(date_range("2015-01-01", periods=3, tz="utc"), name="dates")
 1176:         df = DataFrame({"dates": column})
 1177:         df["dates"] = column[[1, 0, 2]]
 1178:         tm.assert_series_equal(df["dates"], column)
 1179: 
 1180:         df = DataFrame({"dates": column})
 1181:         df.loc[[0, 1, 2], "dates"] = column[[1, 0, 2]]
 1182:         tm.assert_series_equal(df["dates"], column)
 1183: 
 1184:     def test_loc_setitem_datetimelike_with_inference(self):
 1185:         # GH 7592
 1186:         # assignment of timedeltas with NaT
 1187: 
 1188:         one_hour = timedelta(hours=1)
 1189:         df = DataFrame(index=date_range("20130101", periods=4))
 1190:         df["A"] = np.array([1 * one_hour] * 4, dtype="m8[ns]")
 1191:         df.loc[:, "B"] = np.array([2 * one_hour] * 4, dtype="m8[ns]")
 1192:         df.loc[df.index[:3], "C"] = np.array([3 * one_hour] * 3, dtype="m8[ns]")
 1193:         df.loc[:, "D"] = np.array([4 * one_hour] * 4, dtype="m8[ns]")
 1194:         df.loc[df.index[:3], "E"] = np.array([5 * one_hour] * 3, dtype="m8[ns]")
 1195:         df["F"] = np.timedelta64("NaT")
 1196:         df.loc[df.index[:-1], "F"] = np.array([6 * one_hour] * 3, dtype="m8[ns]")
 1197:         df.loc[df.index[-3] :, "G"] = date_range("20130101", periods=3)
 1198:         df["H"] = np.datetime64("NaT")
 1199:         result = df.dtypes
 1200:         expected = Series(
 1201:             [np.dtype("timedelta64[ns]")] * 6 + [np.dtype("datetime64[ns]")] * 2,
 1202:             index=list("ABCDEFGH"),
 1203:         )
 1204:         tm.assert_series_equal(result, expected)
 1205: 
 1206:     def test_getitem_boolean_indexing_mixed(self):
 1207:         df = DataFrame(
 1208:             {
 1209:                 0: {35: np.nan, 40: np.nan, 43: np.nan, 49: np.nan, 50: np.nan},
 1210:                 1: {
 1211:                     35: np.nan,
 1212:                     40: 0.32632316859446198,
 1213:                     43: np.nan,
 1214:                     49: 0.32632316859446198,
 1215:                     50: 0.39114724480578139,
 1216:                 },
 1217:                 2: {
 1218:                     35: np.nan,
 1219:                     40: np.nan,
 1220:                     43: 0.29012581014105987,
 1221:                     49: np.nan,
 1222:                     50: np.nan,
 1223:                 },
 1224:                 3: {35: np.nan, 40: np.nan, 43: np.nan, 49: np.nan, 50: np.nan},
 1225:                 4: {
 1226:                     35: 0.34215328467153283,
 1227:                     40: np.nan,
 1228:                     43: np.nan,
 1229:                     49: np.nan,
 1230:                     50: np.nan,
 1231:                 },
 1232:                 "y": {35: 0, 40: 0, 43: 0, 49: 0, 50: 1},
 1233:             }
 1234:         )
 1235: 
 1236:         # mixed int/float ok
 1237:         df2 = df.copy()
 1238:         df2[df2 > 0.3] = 1
 1239:         expected = df.copy()
 1240:         expected.loc[40, 1] = 1
 1241:         expected.loc[49, 1] = 1
 1242:         expected.loc[50, 1] = 1
 1243:         expected.loc[35, 4] = 1
 1244:         tm.assert_frame_equal(df2, expected)
 1245: 
 1246:         df["foo"] = "test"
 1247:         msg = "not supported between instances|unorderable types"
 1248: 
 1249:         with pytest.raises(TypeError, match=msg):
 1250:             df[df > 0.3] = 1
 1251: 
 1252:     def test_type_error_multiindex(self):
 1253:         # See gh-12218
 1254:         mi = MultiIndex.from_product([["x", "y"], [0, 1]], names=[None, "c"])
 1255:         dg = DataFrame(
 1256:             [[1, 1, 2, 2], [3, 3, 4, 4]], columns=mi, index=Index([0, 1], name="i")
 1257:         )
 1258:         with pytest.raises(InvalidIndexError, match="slice"):
 1259:             dg[:, 0]
 1260: 
 1261:         index = Index(range(2), name="i")
 1262:         columns = MultiIndex(
 1263:             levels=[["x", "y"], [0, 1]], codes=[[0, 1], [0, 0]], names=[None, "c"]
 1264:         )
 1265:         expected = DataFrame([[1, 2], [3, 4]], columns=columns, index=index)
 1266: 
 1267:         result = dg.loc[:, (slice(None), 0)]
 1268:         tm.assert_frame_equal(result, expected)
 1269: 
 1270:         name = ("x", 0)
 1271:         index = Index(range(2), name="i")
 1272:         expected = Series([1, 3], index=index, name=name)
 1273: 
 1274:         result = dg["x", 0]
 1275:         tm.assert_series_equal(result, expected)
 1276: 
 1277:     def test_getitem_interval_index_partial_indexing(self):
 1278:         # GH#36490
 1279:         df = DataFrame(
 1280:             np.ones((3, 4)), columns=pd.IntervalIndex.from_breaks(np.arange(5))
 1281:         )
 1282: 
 1283:         expected = df.iloc[:, 0]
 1284: 
 1285:         res = df[0.5]
 1286:         tm.assert_series_equal(res, expected)
 1287: 
 1288:         res = df.loc[:, 0.5]
 1289:         tm.assert_series_equal(res, expected)
 1290: 
 1291:     def test_setitem_array_as_cell_value(self):
 1292:         # GH#43422
 1293:         df = DataFrame(columns=["a", "b"], dtype=object)
 1294:         df.loc[0] = {"a": np.zeros((2,)), "b": np.zeros((2, 2))}
 1295:         expected = DataFrame({"a": [np.zeros((2,))], "b": [np.zeros((2, 2))]})
 1296:         tm.assert_frame_equal(df, expected)
 1297: 
 1298:     def test_iloc_setitem_nullable_2d_values(self):
 1299:         df = DataFrame({"A": [1, 2, 3]}, dtype="Int64")
 1300:         orig = df.copy()
 1301: 
 1302:         df.loc[:] = df.values[:, ::-1]
 1303:         tm.assert_frame_equal(df, orig)
 1304: 
 1305:         df.loc[:] = pd.core.arrays.NumpyExtensionArray(df.values[:, ::-1])
 1306:         tm.assert_frame_equal(df, orig)
 1307: 
 1308:         df.iloc[:] = df.iloc[:, :].copy()
 1309:         tm.assert_frame_equal(df, orig)
 1310: 
 1311:     def test_getitem_segfault_with_empty_like_object(self):
 1312:         # GH#46848
 1313:         df = DataFrame(np.empty((1, 1), dtype=object))
 1314:         df[0] = np.empty_like(df[0])
 1315:         # this produces the segfault
 1316:         df[[0]]
 1317: 
 1318:     @pytest.mark.filterwarnings("ignore:Setting a value on a view:FutureWarning")
 1319:     @pytest.mark.parametrize(
 1320:         "null", [pd.NaT, pd.NaT.to_numpy("M8[ns]"), pd.NaT.to_numpy("m8[ns]")]
 1321:     )
 1322:     def test_setting_mismatched_na_into_nullable_fails(
 1323:         self, null, any_numeric_ea_dtype
 1324:     ):
 1325:         # GH#44514 don't cast mismatched nulls to pd.NA
 1326:         df = DataFrame({"A": [1, 2, 3]}, dtype=any_numeric_ea_dtype)
 1327:         ser = df["A"].copy()
 1328:         arr = ser._values
 1329: 
 1330:         msg = "|".join(
 1331:             [
 1332:                 r"timedelta64\[ns\] cannot be converted to (Floating|Integer)Dtype",
 1333:                 r"datetime64\[ns\] cannot be converted to (Floating|Integer)Dtype",
 1334:                 "'values' contains non-numeric NA",
 1335:                 r"Invalid value '.*' for dtype (U?Int|Float)\d{1,2}",
 1336:             ]
 1337:         )
 1338:         with pytest.raises(TypeError, match=msg):
 1339:             arr[0] = null
 1340: 
 1341:         with pytest.raises(TypeError, match=msg):
 1342:             arr[:2] = [null, null]
 1343: 
 1344:         with pytest.raises(TypeError, match=msg):
 1345:             ser[0] = null
 1346: 
 1347:         with pytest.raises(TypeError, match=msg):
 1348:             ser[:2] = [null, null]
 1349: 
 1350:         with pytest.raises(TypeError, match=msg):
 1351:             ser.iloc[0] = null
 1352: 
 1353:         with pytest.raises(TypeError, match=msg):
 1354:             ser.iloc[:2] = [null, null]
 1355: 
 1356:         with pytest.raises(TypeError, match=msg):
 1357:             df.iloc[0, 0] = null
 1358: 
 1359:         with pytest.raises(TypeError, match=msg):
 1360:             df.iloc[:2, 0] = [null, null]
 1361: 
 1362:         # Multi-Block
 1363:         df2 = df.copy()
 1364:         df2["B"] = ser.copy()
 1365:         with pytest.raises(TypeError, match=msg):
 1366:             df2.iloc[0, 0] = null
 1367: 
 1368:         with pytest.raises(TypeError, match=msg):
 1369:             df2.iloc[:2, 0] = [null, null]
 1370: 
 1371:     def test_loc_expand_empty_frame_keep_index_name(self):
 1372:         # GH#45621
 1373:         df = DataFrame(columns=["b"], index=Index([], name="a"))
 1374:         df.loc[0] = 1
 1375:         expected = DataFrame({"b": [1]}, index=Index([0], name="a"))
 1376:         tm.assert_frame_equal(df, expected)
 1377: 
 1378:     def test_loc_expand_empty_frame_keep_midx_names(self):
 1379:         # GH#46317
 1380:         df = DataFrame(
 1381:             columns=["d"], index=MultiIndex.from_tuples([], names=["a", "b", "c"])
 1382:         )
 1383:         df.loc[(1, 2, 3)] = "foo"
 1384:         expected = DataFrame(
 1385:             {"d": ["foo"]},
 1386:             index=MultiIndex.from_tuples([(1, 2, 3)], names=["a", "b", "c"]),
 1387:         )
 1388:         tm.assert_frame_equal(df, expected)
 1389: 
 1390:     @pytest.mark.parametrize(
 1391:         "val, idxr",
 1392:         [
 1393:             ("x", "a"),
 1394:             ("x", ["a"]),
 1395:             (1, "a"),
 1396:             (1, ["a"]),
 1397:         ],
 1398:     )
 1399:     def test_loc_setitem_rhs_frame(self, idxr, val):
 1400:         # GH#47578
 1401:         df = DataFrame({"a": [1, 2]})
 1402: 
 1403:         with tm.assert_produces_warning(
 1404:             FutureWarning, match="Setting an item of incompatible dtype"
 1405:         ):
 1406:             df.loc[:, idxr] = DataFrame({"a": [val, 11]}, index=[1, 2])
 1407:         expected = DataFrame({"a": [np.nan, val]})
 1408:         tm.assert_frame_equal(df, expected)
 1409: 
 1410:     @td.skip_array_manager_invalid_test
 1411:     def test_iloc_setitem_enlarge_no_warning(self, warn_copy_on_write):
 1412:         # GH#47381
 1413:         df = DataFrame(columns=["a", "b"])
 1414:         expected = df.copy()
 1415:         view = df[:]
 1416:         df.iloc[:, 0] = np.array([1, 2], dtype=np.float64)
 1417:         tm.assert_frame_equal(view, expected)
 1418: 
 1419:     def test_loc_internals_not_updated_correctly(self):
 1420:         # GH#47867 all steps are necessary to reproduce the initial bug
 1421:         df = DataFrame(
 1422:             {"bool_col": True, "a": 1, "b": 2.5},
 1423:             index=MultiIndex.from_arrays([[1, 2], [1, 2]], names=["idx1", "idx2"]),
 1424:         )
 1425:         idx = [(1, 1)]
 1426: 
 1427:         df["c"] = 3
 1428:         df.loc[idx, "c"] = 0
 1429: 
 1430:         df.loc[idx, "c"]
 1431:         df.loc[idx, ["a", "b"]]
 1432: 
 1433:         df.loc[idx, "c"] = 15
 1434:         result = df.loc[idx, "c"]
 1435:         expected = df = Series(
 1436:             15,
 1437:             index=MultiIndex.from_arrays([[1], [1]], names=["idx1", "idx2"]),
 1438:             name="c",
 1439:         )
 1440:         tm.assert_series_equal(result, expected)
 1441: 
 1442:     @pytest.mark.parametrize("val", [None, [None], pd.NA, [pd.NA]])
 1443:     def test_iloc_setitem_string_list_na(self, val):
 1444:         # GH#45469
 1445:         df = DataFrame({"a": ["a", "b", "c"]}, dtype="string")
 1446:         df.iloc[[0], :] = val
 1447:         expected = DataFrame({"a": [pd.NA, "b", "c"]}, dtype="string")
 1448:         tm.assert_frame_equal(df, expected)
 1449: 
 1450:     @pytest.mark.parametrize("val", [None, pd.NA])
 1451:     def test_iloc_setitem_string_na(self, val):
 1452:         # GH#45469
 1453:         df = DataFrame({"a": ["a", "b", "c"]}, dtype="string")
 1454:         df.iloc[0, :] = val
 1455:         expected = DataFrame({"a": [pd.NA, "b", "c"]}, dtype="string")
 1456:         tm.assert_frame_equal(df, expected)
 1457: 
 1458:     @pytest.mark.parametrize("func", [list, Series, np.array])
 1459:     def test_iloc_setitem_ea_null_slice_length_one_list(self, func):
 1460:         # GH#48016
 1461:         df = DataFrame({"a": [1, 2, 3]}, dtype="Int64")
 1462:         df.iloc[:, func([0])] = 5
 1463:         expected = DataFrame({"a": [5, 5, 5]}, dtype="Int64")
 1464:         tm.assert_frame_equal(df, expected)
 1465: 
 1466:     def test_loc_named_tuple_for_midx(self):
 1467:         # GH#48124
 1468:         df = DataFrame(
 1469:             index=MultiIndex.from_product(
 1470:                 [["A", "B"], ["a", "b", "c"]], names=["first", "second"]
 1471:             )
 1472:         )
 1473:         indexer_tuple = namedtuple("Indexer", df.index.names)
 1474:         idxr = indexer_tuple(first="A", second=["a", "b"])
 1475:         result = df.loc[idxr, :]
 1476:         expected = DataFrame(
 1477:             index=MultiIndex.from_tuples(
 1478:                 [("A", "a"), ("A", "b")], names=["first", "second"]
 1479:             )
 1480:         )
 1481:         tm.assert_frame_equal(result, expected)
 1482: 
 1483:     @pytest.mark.parametrize("indexer", [["a"], "a"])
 1484:     @pytest.mark.parametrize("col", [{}, {"b": 1}])
 1485:     def test_set_2d_casting_date_to_int(self, col, indexer):
 1486:         # GH#49159
 1487:         df = DataFrame(
 1488:             {"a": [Timestamp("2022-12-29"), Timestamp("2022-12-30")], **col},
 1489:         )
 1490:         df.loc[[1], indexer] = df["a"] + pd.Timedelta(days=1)
 1491:         expected = DataFrame(
 1492:             {"a": [Timestamp("2022-12-29"), Timestamp("2022-12-31")], **col},
 1493:         )
 1494:         tm.assert_frame_equal(df, expected)
 1495: 
 1496:     @pytest.mark.parametrize("col", [{}, {"name": "a"}])
 1497:     def test_loc_setitem_reordering_with_all_true_indexer(self, col):
 1498:         # GH#48701
 1499:         n = 17
 1500:         df = DataFrame({**col, "x": range(n), "y": range(n)})
 1501:         expected = df.copy()
 1502:         df.loc[n * [True], ["x", "y"]] = df[["x", "y"]]
 1503:         tm.assert_frame_equal(df, expected)
 1504: 
 1505:     def test_loc_rhs_empty_warning(self):
 1506:         # GH48480
 1507:         df = DataFrame(columns=["a", "b"])
 1508:         expected = df.copy()
 1509:         rhs = DataFrame(columns=["a"])
 1510:         with tm.assert_produces_warning(None):
 1511:             df.loc[:, "a"] = rhs
 1512:         tm.assert_frame_equal(df, expected)
 1513: 
 1514:     def test_iloc_ea_series_indexer(self):
 1515:         # GH#49521
 1516:         df = DataFrame([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])
 1517:         indexer = Series([0, 1], dtype="Int64")
 1518:         row_indexer = Series([1], dtype="Int64")
 1519:         result = df.iloc[row_indexer, indexer]
 1520:         expected = DataFrame([[5, 6]], index=[1])
 1521:         tm.assert_frame_equal(result, expected)
 1522: 
 1523:         result = df.iloc[row_indexer.values, indexer.values]
 1524:         tm.assert_frame_equal(result, expected)
 1525: 
 1526:     def test_iloc_ea_series_indexer_with_na(self):
 1527:         # GH#49521
 1528:         df = DataFrame([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])
 1529:         indexer = Series([0, pd.NA], dtype="Int64")
 1530:         msg = "cannot convert"
 1531:         with pytest.raises(ValueError, match=msg):
 1532:             df.iloc[:, indexer]
 1533:         with pytest.raises(ValueError, match=msg):
 1534:             df.iloc[:, indexer.values]
 1535: 
 1536:     @pytest.mark.parametrize("indexer", [True, (True,)])
 1537:     @pytest.mark.parametrize("dtype", [bool, "boolean"])
 1538:     def test_loc_bool_multiindex(self, dtype, indexer):
 1539:         # GH#47687
 1540:         midx = MultiIndex.from_arrays(
 1541:             [
 1542:                 Series([True, True, False, False], dtype=dtype),
 1543:                 Series([True, False, True, False], dtype=dtype),
 1544:             ],
 1545:             names=["a", "b"],
 1546:         )
 1547:         df = DataFrame({"c": [1, 2, 3, 4]}, index=midx)
 1548:         with tm.maybe_produces_warning(PerformanceWarning, isinstance(indexer, tuple)):
 1549:             result = df.loc[indexer]
 1550:         expected = DataFrame(
 1551:             {"c": [1, 2]}, index=Index([True, False], name="b", dtype=dtype)
 1552:         )
 1553:         tm.assert_frame_equal(result, expected)
 1554: 
 1555:     @pytest.mark.parametrize("utc", [False, True])
 1556:     @pytest.mark.parametrize("indexer", ["date", ["date"]])
 1557:     def test_loc_datetime_assignment_dtype_does_not_change(self, utc, indexer):
 1558:         # GH#49837
 1559:         df = DataFrame(
 1560:             {
 1561:                 "date": to_datetime(
 1562:                     [datetime(2022, 1, 20), datetime(2022, 1, 22)], utc=utc
 1563:                 ),
 1564:                 "update": [True, False],
 1565:             }
 1566:         )
 1567:         expected = df.copy(deep=True)
 1568: 
 1569:         update_df = df[df["update"]]
 1570: 
 1571:         df.loc[df["update"], indexer] = update_df["date"]
 1572: 
 1573:         tm.assert_frame_equal(df, expected)
 1574: 
 1575:     @pytest.mark.parametrize("indexer, idx", [(tm.loc, 1), (tm.iloc, 2)])
 1576:     def test_setitem_value_coercing_dtypes(self, indexer, idx):
 1577:         # GH#50467
 1578:         df = DataFrame([["1", np.nan], ["2", np.nan], ["3", np.nan]], dtype=object)
 1579:         rhs = DataFrame([[1, np.nan], [2, np.nan]])
 1580:         indexer(df)[:idx, :] = rhs
 1581:         expected = DataFrame([[1, np.nan], [2, np.nan], ["3", np.nan]], dtype=object)
 1582:         tm.assert_frame_equal(df, expected)
 1583: 
 1584: 
 1585: class TestDataFrameIndexingUInt64:
 1586:     def test_setitem(self):
 1587:         df = DataFrame(
 1588:             {"A": np.arange(3), "B": [2**63, 2**63 + 5, 2**63 + 10]},
 1589:             dtype=np.uint64,
 1590:         )
 1591:         idx = df["A"].rename("foo")
 1592: 
 1593:         # setitem
 1594:         assert "C" not in df.columns
 1595:         df["C"] = idx
 1596:         tm.assert_series_equal(df["C"], Series(idx, name="C"))
 1597: 
 1598:         assert "D" not in df.columns
 1599:         df["D"] = "foo"
 1600:         df["D"] = idx
 1601:         tm.assert_series_equal(df["D"], Series(idx, name="D"))
 1602:         del df["D"]
 1603: 
 1604:         # With NaN: because uint64 has no NaN element,
 1605:         # the column should be cast to object.
 1606:         df2 = df.copy()
 1607:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1608:             df2.iloc[1, 1] = pd.NaT
 1609:             df2.iloc[1, 2] = pd.NaT
 1610:         result = df2["B"]
 1611:         tm.assert_series_equal(notna(result), Series([True, False, True], name="B"))
 1612:         tm.assert_series_equal(
 1613:             df2.dtypes,
 1614:             Series(
 1615:                 [np.dtype("uint64"), np.dtype("O"), np.dtype("O")],
 1616:                 index=["A", "B", "C"],
 1617:             ),
 1618:         )
 1619: 
 1620: 
 1621: def test_object_casting_indexing_wraps_datetimelike(using_array_manager):
 1622:     # GH#31649, check the indexing methods all the way down the stack
 1623:     df = DataFrame(
 1624:         {
 1625:             "A": [1, 2],
 1626:             "B": date_range("2000", periods=2),
 1627:             "C": pd.timedelta_range("1 Day", periods=2),
 1628:         }
 1629:     )
 1630: 
 1631:     ser = df.loc[0]
 1632:     assert isinstance(ser.values[1], Timestamp)
 1633:     assert isinstance(ser.values[2], pd.Timedelta)
 1634: 
 1635:     ser = df.iloc[0]
 1636:     assert isinstance(ser.values[1], Timestamp)
 1637:     assert isinstance(ser.values[2], pd.Timedelta)
 1638: 
 1639:     ser = df.xs(0, axis=0)
 1640:     assert isinstance(ser.values[1], Timestamp)
 1641:     assert isinstance(ser.values[2], pd.Timedelta)
 1642: 
 1643:     if using_array_manager:
 1644:         # remainder of the test checking BlockManager internals
 1645:         return
 1646: 
 1647:     mgr = df._mgr
 1648:     mgr._rebuild_blknos_and_blklocs()
 1649:     arr = mgr.fast_xs(0).array
 1650:     assert isinstance(arr[1], Timestamp)
 1651:     assert isinstance(arr[2], pd.Timedelta)
 1652: 
 1653:     blk = mgr.blocks[mgr.blknos[1]]
 1654:     assert blk.dtype == "M8[ns]"  # we got the right block
 1655:     val = blk.iget((0, 0))
 1656:     assert isinstance(val, Timestamp)
 1657: 
 1658:     blk = mgr.blocks[mgr.blknos[2]]
 1659:     assert blk.dtype == "m8[ns]"  # we got the right block
 1660:     val = blk.iget((0, 0))
 1661:     assert isinstance(val, pd.Timedelta)
 1662: 
 1663: 
 1664: msg1 = r"Cannot setitem on a Categorical with a new category( \(.*\))?, set the"
 1665: msg2 = "Cannot set a Categorical with another, without identical categories"
 1666: 
 1667: 
 1668: class TestLocILocDataFrameCategorical:
 1669:     @pytest.fixture
 1670:     def orig(self):
 1671:         cats = Categorical(["a", "a", "a", "a", "a", "a", "a"], categories=["a", "b"])
 1672:         idx = Index(["h", "i", "j", "k", "l", "m", "n"])
 1673:         values = [1, 1, 1, 1, 1, 1, 1]
 1674:         orig = DataFrame({"cats": cats, "values": values}, index=idx)
 1675:         return orig
 1676: 
 1677:     @pytest.fixture
 1678:     def exp_single_row(self):
 1679:         # The expected values if we change a single row
 1680:         cats1 = Categorical(["a", "a", "b", "a", "a", "a", "a"], categories=["a", "b"])
 1681:         idx1 = Index(["h", "i", "j", "k", "l", "m", "n"])
 1682:         values1 = [1, 1, 2, 1, 1, 1, 1]
 1683:         exp_single_row = DataFrame({"cats": cats1, "values": values1}, index=idx1)
 1684:         return exp_single_row
 1685: 
 1686:     @pytest.fixture
 1687:     def exp_multi_row(self):
 1688:         # assign multiple rows (mixed values) (-> array) -> exp_multi_row
 1689:         # changed multiple rows
 1690:         cats2 = Categorical(["a", "a", "b", "b", "a", "a", "a"], categories=["a", "b"])
 1691:         idx2 = Index(["h", "i", "j", "k", "l", "m", "n"])
 1692:         values2 = [1, 1, 2, 2, 1, 1, 1]
 1693:         exp_multi_row = DataFrame({"cats": cats2, "values": values2}, index=idx2)
 1694:         return exp_multi_row
 1695: 
 1696:     @pytest.fixture
 1697:     def exp_parts_cats_col(self):
 1698:         # changed part of the cats column
 1699:         cats3 = Categorical(["a", "a", "b", "b", "a", "a", "a"], categories=["a", "b"])
 1700:         idx3 = Index(["h", "i", "j", "k", "l", "m", "n"])
 1701:         values3 = [1, 1, 1, 1, 1, 1, 1]
 1702:         exp_parts_cats_col = DataFrame({"cats": cats3, "values": values3}, index=idx3)
 1703:         return exp_parts_cats_col
 1704: 
 1705:     @pytest.fixture
 1706:     def exp_single_cats_value(self):
 1707:         # changed single value in cats col
 1708:         cats4 = Categorical(["a", "a", "b", "a", "a", "a", "a"], categories=["a", "b"])
 1709:         idx4 = Index(["h", "i", "j", "k", "l", "m", "n"])
 1710:         values4 = [1, 1, 1, 1, 1, 1, 1]
 1711:         exp_single_cats_value = DataFrame(
 1712:             {"cats": cats4, "values": values4}, index=idx4
 1713:         )
 1714:         return exp_single_cats_value
 1715: 
 1716:     @pytest.mark.parametrize("indexer", [tm.loc, tm.iloc])
 1717:     def test_loc_iloc_setitem_list_of_lists(self, orig, exp_multi_row, indexer):
 1718:         #   - assign multiple rows (mixed values) -> exp_multi_row
 1719:         df = orig.copy()
 1720: 
 1721:         key = slice(2, 4)
 1722:         if indexer is tm.loc:
 1723:             key = slice("j", "k")
 1724: 
 1725:         indexer(df)[key, :] = [["b", 2], ["b", 2]]
 1726:         tm.assert_frame_equal(df, exp_multi_row)
 1727: 
 1728:         df = orig.copy()
 1729:         with pytest.raises(TypeError, match=msg1):
 1730:             indexer(df)[key, :] = [["c", 2], ["c", 2]]
 1731: 
 1732:     @pytest.mark.parametrize("indexer", [tm.loc, tm.iloc, tm.at, tm.iat])
 1733:     def test_loc_iloc_at_iat_setitem_single_value_in_categories(
 1734:         self, orig, exp_single_cats_value, indexer
 1735:     ):
 1736:         #   - assign a single value -> exp_single_cats_value
 1737:         df = orig.copy()
 1738: 
 1739:         key = (2, 0)
 1740:         if indexer in [tm.loc, tm.at]:
 1741:             key = (df.index[2], df.columns[0])
 1742: 
 1743:         # "b" is among the categories for df["cat"}]
 1744:         indexer(df)[key] = "b"
 1745:         tm.assert_frame_equal(df, exp_single_cats_value)
 1746: 
 1747:         # "c" is not among the categories for df["cat"]
 1748:         with pytest.raises(TypeError, match=msg1):
 1749:             indexer(df)[key] = "c"
 1750: 
 1751:     @pytest.mark.parametrize("indexer", [tm.loc, tm.iloc])
 1752:     def test_loc_iloc_setitem_mask_single_value_in_categories(
 1753:         self, orig, exp_single_cats_value, indexer
 1754:     ):
 1755:         # mask with single True
 1756:         df = orig.copy()
 1757: 
 1758:         mask = df.index == "j"
 1759:         key = 0
 1760:         if indexer is tm.loc:
 1761:             key = df.columns[key]
 1762: 
 1763:         indexer(df)[mask, key] = "b"
 1764:         tm.assert_frame_equal(df, exp_single_cats_value)
 1765: 
 1766:     @pytest.mark.parametrize("indexer", [tm.loc, tm.iloc])
 1767:     def test_loc_iloc_setitem_full_row_non_categorical_rhs(
 1768:         self, orig, exp_single_row, indexer
 1769:     ):
 1770:         #   - assign a complete row (mixed values) -> exp_single_row
 1771:         df = orig.copy()
 1772: 
 1773:         key = 2
 1774:         if indexer is tm.loc:
 1775:             key = df.index[2]
 1776: 
 1777:         # not categorical dtype, but "b" _is_ among the categories for df["cat"]
 1778:         indexer(df)[key, :] = ["b", 2]
 1779:         tm.assert_frame_equal(df, exp_single_row)
 1780: 
 1781:         # "c" is not among the categories for df["cat"]
 1782:         with pytest.raises(TypeError, match=msg1):
 1783:             indexer(df)[key, :] = ["c", 2]
 1784: 
 1785:     @pytest.mark.parametrize("indexer", [tm.loc, tm.iloc])
 1786:     def test_loc_iloc_setitem_partial_col_categorical_rhs(
 1787:         self, orig, exp_parts_cats_col, indexer
 1788:     ):
 1789:         # assign a part of a column with dtype == categorical ->
 1790:         # exp_parts_cats_col
 1791:         df = orig.copy()
 1792: 
 1793:         key = (slice(2, 4), 0)
 1794:         if indexer is tm.loc:
 1795:             key = (slice("j", "k"), df.columns[0])
 1796: 
 1797:         # same categories as we currently have in df["cats"]
 1798:         compat = Categorical(["b", "b"], categories=["a", "b"])
 1799:         indexer(df)[key] = compat
 1800:         tm.assert_frame_equal(df, exp_parts_cats_col)
 1801: 
 1802:         # categories do not match df["cat"]'s, but "b" is among them
 1803:         semi_compat = Categorical(list("bb"), categories=list("abc"))
 1804:         with pytest.raises(TypeError, match=msg2):
 1805:             # different categories but holdable values
 1806:             #  -> not sure if this should fail or pass
 1807:             indexer(df)[key] = semi_compat
 1808: 
 1809:         # categories do not match df["cat"]'s, and "c" is not among them
 1810:         incompat = Categorical(list("cc"), categories=list("abc"))
 1811:         with pytest.raises(TypeError, match=msg2):
 1812:             # different values
 1813:             indexer(df)[key] = incompat
 1814: 
 1815:     @pytest.mark.parametrize("indexer", [tm.loc, tm.iloc])
 1816:     def test_loc_iloc_setitem_non_categorical_rhs(
 1817:         self, orig, exp_parts_cats_col, indexer
 1818:     ):
 1819:         # assign a part of a column with dtype != categorical -> exp_parts_cats_col
 1820:         df = orig.copy()
 1821: 
 1822:         key = (slice(2, 4), 0)
 1823:         if indexer is tm.loc:
 1824:             key = (slice("j", "k"), df.columns[0])
 1825: 
 1826:         # "b" is among the categories for df["cat"]
 1827:         indexer(df)[key] = ["b", "b"]
 1828:         tm.assert_frame_equal(df, exp_parts_cats_col)
 1829: 
 1830:         # "c" not part of the categories
 1831:         with pytest.raises(TypeError, match=msg1):
 1832:             indexer(df)[key] = ["c", "c"]
 1833: 
 1834:     @pytest.mark.parametrize("indexer", [tm.getitem, tm.loc, tm.iloc])
 1835:     def test_getitem_preserve_object_index_with_dates(self, indexer):
 1836:         # https://github.com/pandas-dev/pandas/pull/42950 - when selecting a column
 1837:         # from dataframe, don't try to infer object dtype index on Series construction
 1838:         idx = date_range("2012", periods=3).astype(object)
 1839:         df = DataFrame({0: [1, 2, 3]}, index=idx)
 1840:         assert df.index.dtype == object
 1841: 
 1842:         if indexer is tm.getitem:
 1843:             ser = indexer(df)[0]
 1844:         else:
 1845:             ser = indexer(df)[:, 0]
 1846: 
 1847:         assert ser.index.dtype == object
 1848: 
 1849:     def test_loc_on_multiindex_one_level(self):
 1850:         # GH#45779
 1851:         df = DataFrame(
 1852:             data=[[0], [1]],
 1853:             index=MultiIndex.from_tuples([("a",), ("b",)], names=["first"]),
 1854:         )
 1855:         expected = DataFrame(
 1856:             data=[[0]], index=MultiIndex.from_tuples([("a",)], names=["first"])
 1857:         )
 1858:         result = df.loc["a"]
 1859:         tm.assert_frame_equal(result, expected)
 1860: 
 1861: 
 1862: class TestDeprecatedIndexers:
 1863:     @pytest.mark.parametrize(
 1864:         "key", [{1}, {1: 1}, ({1}, "a"), ({1: 1}, "a"), (1, {"a"}), (1, {"a": "a"})]
 1865:     )
 1866:     def test_getitem_dict_and_set_deprecated(self, key):
 1867:         # GH#42825 enforced in 2.0
 1868:         df = DataFrame([[1, 2], [3, 4]], columns=["a", "b"])
 1869:         with pytest.raises(TypeError, match="as an indexer is not supported"):
 1870:             df.loc[key]
 1871: 
 1872:     @pytest.mark.parametrize(
 1873:         "key",
 1874:         [
 1875:             {1},
 1876:             {1: 1},
 1877:             (({1}, 2), "a"),
 1878:             (({1: 1}, 2), "a"),
 1879:             ((1, 2), {"a"}),
 1880:             ((1, 2), {"a": "a"}),
 1881:         ],
 1882:     )
 1883:     def test_getitem_dict_and_set_deprecated_multiindex(self, key):
 1884:         # GH#42825 enforced in 2.0
 1885:         df = DataFrame(
 1886:             [[1, 2], [3, 4]],
 1887:             columns=["a", "b"],
 1888:             index=MultiIndex.from_tuples([(1, 2), (3, 4)]),
 1889:         )
 1890:         with pytest.raises(TypeError, match="as an indexer is not supported"):
 1891:             df.loc[key]
 1892: 
 1893:     @pytest.mark.parametrize(
 1894:         "key", [{1}, {1: 1}, ({1}, "a"), ({1: 1}, "a"), (1, {"a"}), (1, {"a": "a"})]
 1895:     )
 1896:     def test_setitem_dict_and_set_disallowed(self, key):
 1897:         # GH#42825 enforced in 2.0
 1898:         df = DataFrame([[1, 2], [3, 4]], columns=["a", "b"])
 1899:         with pytest.raises(TypeError, match="as an indexer is not supported"):
 1900:             df.loc[key] = 1
 1901: 
 1902:     @pytest.mark.parametrize(
 1903:         "key",
 1904:         [
 1905:             {1},
 1906:             {1: 1},
 1907:             (({1}, 2), "a"),
 1908:             (({1: 1}, 2), "a"),
 1909:             ((1, 2), {"a"}),
 1910:             ((1, 2), {"a": "a"}),
 1911:         ],
 1912:     )
 1913:     def test_setitem_dict_and_set_disallowed_multiindex(self, key):
 1914:         # GH#42825 enforced in 2.0
 1915:         df = DataFrame(
 1916:             [[1, 2], [3, 4]],
 1917:             columns=["a", "b"],
 1918:             index=MultiIndex.from_tuples([(1, 2), (3, 4)]),
 1919:         )
 1920:         with pytest.raises(TypeError, match="as an indexer is not supported"):
 1921:             df.loc[key] = 1
 1922: 
 1923: 
 1924: def test_adding_new_conditional_column() -> None:
 1925:     # https://github.com/pandas-dev/pandas/issues/55025
 1926:     df = DataFrame({"x": [1]})
 1927:     df.loc[df["x"] == 1, "y"] = "1"
 1928:     expected = DataFrame({"x": [1], "y": ["1"]})
 1929:     tm.assert_frame_equal(df, expected)
 1930: 
 1931:     df = DataFrame({"x": [1]})
 1932:     # try inserting something which numpy would store as 'object'
 1933:     value = lambda x: x
 1934:     df.loc[df["x"] == 1, "y"] = value
 1935:     expected = DataFrame({"x": [1], "y": [value]})
 1936:     tm.assert_frame_equal(df, expected)
 1937: 
 1938: 
 1939: @pytest.mark.parametrize(
 1940:     ("dtype", "infer_string"),
 1941:     [
 1942:         (object, False),
 1943:         ("string[pyarrow_numpy]", True),
 1944:     ],
 1945: )
 1946: def test_adding_new_conditional_column_with_string(dtype, infer_string) -> None:
 1947:     # https://github.com/pandas-dev/pandas/issues/56204
 1948:     pytest.importorskip("pyarrow")
 1949: 
 1950:     df = DataFrame({"a": [1, 2], "b": [3, 4]})
 1951:     with pd.option_context("future.infer_string", infer_string):
 1952:         df.loc[df["a"] == 1, "c"] = "1"
 1953:     expected = DataFrame({"a": [1, 2], "b": [3, 4], "c": ["1", float("nan")]}).astype(
 1954:         {"a": "int64", "b": "int64", "c": dtype}
 1955:     )
 1956:     tm.assert_frame_equal(df, expected)
 1957: 
 1958: 
 1959: def test_add_new_column_infer_string():
 1960:     # GH#55366
 1961:     pytest.importorskip("pyarrow")
 1962:     df = DataFrame({"x": [1]})
 1963:     with pd.option_context("future.infer_string", True):
 1964:         df.loc[df["x"] == 1, "y"] = "1"
 1965:     expected = DataFrame(
 1966:         {"x": [1], "y": Series(["1"], dtype="string[pyarrow_numpy]")},
 1967:         columns=Index(["x", "y"], dtype=object),
 1968:     )
 1969:     tm.assert_frame_equal(df, expected)
 1970: 
 1971: 
 1972: class TestSetitemValidation:
 1973:     # This is adapted from pandas/tests/arrays/masked/test_indexing.py
 1974:     # but checks for warnings instead of errors.
 1975:     def _check_setitem_invalid(self, df, invalid, indexer, warn):
 1976:         msg = "Setting an item of incompatible dtype is deprecated"
 1977:         msg = re.escape(msg)
 1978: 
 1979:         orig_df = df.copy()
 1980: 
 1981:         # iloc
 1982:         with tm.assert_produces_warning(warn, match=msg):
 1983:             df.iloc[indexer, 0] = invalid
 1984:             df = orig_df.copy()
 1985: 
 1986:         # loc
 1987:         with tm.assert_produces_warning(warn, match=msg):
 1988:             df.loc[indexer, "a"] = invalid
 1989:             df = orig_df.copy()
 1990: 
 1991:     _invalid_scalars = [
 1992:         1 + 2j,
 1993:         "True",
 1994:         "1",
 1995:         "1.0",
 1996:         pd.NaT,
 1997:         np.datetime64("NaT"),
 1998:         np.timedelta64("NaT"),
 1999:     ]
 2000:     _indexers = [0, [0], slice(0, 1), [True, False, False], slice(None, None, None)]
 2001: 
 2002:     @pytest.mark.parametrize(
 2003:         "invalid", _invalid_scalars + [1, 1.0, np.int64(1), np.float64(1)]
 2004:     )
 2005:     @pytest.mark.parametrize("indexer", _indexers)
 2006:     def test_setitem_validation_scalar_bool(self, invalid, indexer):
 2007:         df = DataFrame({"a": [True, False, False]}, dtype="bool")
 2008:         self._check_setitem_invalid(df, invalid, indexer, FutureWarning)
 2009: 
 2010:     @pytest.mark.parametrize("invalid", _invalid_scalars + [True, 1.5, np.float64(1.5)])
 2011:     @pytest.mark.parametrize("indexer", _indexers)
 2012:     def test_setitem_validation_scalar_int(self, invalid, any_int_numpy_dtype, indexer):
 2013:         df = DataFrame({"a": [1, 2, 3]}, dtype=any_int_numpy_dtype)
 2014:         if isna(invalid) and invalid is not pd.NaT and not np.isnat(invalid):
 2015:             warn = None
 2016:         else:
 2017:             warn = FutureWarning
 2018:         self._check_setitem_invalid(df, invalid, indexer, warn)
 2019: 
 2020:     @pytest.mark.parametrize("invalid", _invalid_scalars + [True])
 2021:     @pytest.mark.parametrize("indexer", _indexers)
 2022:     def test_setitem_validation_scalar_float(self, invalid, float_numpy_dtype, indexer):
 2023:         df = DataFrame({"a": [1, 2, None]}, dtype=float_numpy_dtype)
 2024:         self._check_setitem_invalid(df, invalid, indexer, FutureWarning)
