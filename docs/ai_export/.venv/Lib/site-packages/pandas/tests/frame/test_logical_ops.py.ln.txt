    1: import operator
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas import (
    8:     CategoricalIndex,
    9:     DataFrame,
   10:     Interval,
   11:     Series,
   12:     isnull,
   13: )
   14: import pandas._testing as tm
   15: 
   16: 
   17: class TestDataFrameLogicalOperators:
   18:     # &, |, ^
   19: 
   20:     @pytest.mark.parametrize(
   21:         "left, right, op, expected",
   22:         [
   23:             (
   24:                 [True, False, np.nan],
   25:                 [True, False, True],
   26:                 operator.and_,
   27:                 [True, False, False],
   28:             ),
   29:             (
   30:                 [True, False, True],
   31:                 [True, False, np.nan],
   32:                 operator.and_,
   33:                 [True, False, False],
   34:             ),
   35:             (
   36:                 [True, False, np.nan],
   37:                 [True, False, True],
   38:                 operator.or_,
   39:                 [True, False, False],
   40:             ),
   41:             (
   42:                 [True, False, True],
   43:                 [True, False, np.nan],
   44:                 operator.or_,
   45:                 [True, False, True],
   46:             ),
   47:         ],
   48:     )
   49:     def test_logical_operators_nans(self, left, right, op, expected, frame_or_series):
   50:         # GH#13896
   51:         result = op(frame_or_series(left), frame_or_series(right))
   52:         expected = frame_or_series(expected)
   53: 
   54:         tm.assert_equal(result, expected)
   55: 
   56:     def test_logical_ops_empty_frame(self):
   57:         # GH#5808
   58:         # empty frames, non-mixed dtype
   59:         df = DataFrame(index=[1])
   60: 
   61:         result = df & df
   62:         tm.assert_frame_equal(result, df)
   63: 
   64:         result = df | df
   65:         tm.assert_frame_equal(result, df)
   66: 
   67:         df2 = DataFrame(index=[1, 2])
   68:         result = df & df2
   69:         tm.assert_frame_equal(result, df2)
   70: 
   71:         dfa = DataFrame(index=[1], columns=["A"])
   72: 
   73:         result = dfa & dfa
   74:         expected = DataFrame(False, index=[1], columns=["A"])
   75:         tm.assert_frame_equal(result, expected)
   76: 
   77:     def test_logical_ops_bool_frame(self):
   78:         # GH#5808
   79:         df1a_bool = DataFrame(True, index=[1], columns=["A"])
   80: 
   81:         result = df1a_bool & df1a_bool
   82:         tm.assert_frame_equal(result, df1a_bool)
   83: 
   84:         result = df1a_bool | df1a_bool
   85:         tm.assert_frame_equal(result, df1a_bool)
   86: 
   87:     def test_logical_ops_int_frame(self):
   88:         # GH#5808
   89:         df1a_int = DataFrame(1, index=[1], columns=["A"])
   90:         df1a_bool = DataFrame(True, index=[1], columns=["A"])
   91: 
   92:         result = df1a_int | df1a_bool
   93:         tm.assert_frame_equal(result, df1a_bool)
   94: 
   95:         # Check that this matches Series behavior
   96:         res_ser = df1a_int["A"] | df1a_bool["A"]
   97:         tm.assert_series_equal(res_ser, df1a_bool["A"])
   98: 
   99:     def test_logical_ops_invalid(self, using_infer_string):
  100:         # GH#5808
  101: 
  102:         df1 = DataFrame(1.0, index=[1], columns=["A"])
  103:         df2 = DataFrame(True, index=[1], columns=["A"])
  104:         msg = re.escape("unsupported operand type(s) for |: 'float' and 'bool'")
  105:         with pytest.raises(TypeError, match=msg):
  106:             df1 | df2
  107: 
  108:         df1 = DataFrame("foo", index=[1], columns=["A"])
  109:         df2 = DataFrame(True, index=[1], columns=["A"])
  110:         msg = re.escape("unsupported operand type(s) for |: 'str' and 'bool'")
  111:         if using_infer_string:
  112:             import pyarrow as pa
  113: 
  114:             with pytest.raises(pa.lib.ArrowNotImplementedError, match="|has no kernel"):
  115:                 df1 | df2
  116:         else:
  117:             with pytest.raises(TypeError, match=msg):
  118:                 df1 | df2
  119: 
  120:     def test_logical_operators(self):
  121:         def _check_bin_op(op):
  122:             result = op(df1, df2)
  123:             expected = DataFrame(
  124:                 op(df1.values, df2.values), index=df1.index, columns=df1.columns
  125:             )
  126:             assert result.values.dtype == np.bool_
  127:             tm.assert_frame_equal(result, expected)
  128: 
  129:         def _check_unary_op(op):
  130:             result = op(df1)
  131:             expected = DataFrame(op(df1.values), index=df1.index, columns=df1.columns)
  132:             assert result.values.dtype == np.bool_
  133:             tm.assert_frame_equal(result, expected)
  134: 
  135:         df1 = {
  136:             "a": {"a": True, "b": False, "c": False, "d": True, "e": True},
  137:             "b": {"a": False, "b": True, "c": False, "d": False, "e": False},
  138:             "c": {"a": False, "b": False, "c": True, "d": False, "e": False},
  139:             "d": {"a": True, "b": False, "c": False, "d": True, "e": True},
  140:             "e": {"a": True, "b": False, "c": False, "d": True, "e": True},
  141:         }
  142: 
  143:         df2 = {
  144:             "a": {"a": True, "b": False, "c": True, "d": False, "e": False},
  145:             "b": {"a": False, "b": True, "c": False, "d": False, "e": False},
  146:             "c": {"a": True, "b": False, "c": True, "d": False, "e": False},
  147:             "d": {"a": False, "b": False, "c": False, "d": True, "e": False},
  148:             "e": {"a": False, "b": False, "c": False, "d": False, "e": True},
  149:         }
  150: 
  151:         df1 = DataFrame(df1)
  152:         df2 = DataFrame(df2)
  153: 
  154:         _check_bin_op(operator.and_)
  155:         _check_bin_op(operator.or_)
  156:         _check_bin_op(operator.xor)
  157: 
  158:         _check_unary_op(operator.inv)  # TODO: belongs elsewhere
  159: 
  160:     @pytest.mark.filterwarnings("ignore:Downcasting object dtype arrays:FutureWarning")
  161:     def test_logical_with_nas(self):
  162:         d = DataFrame({"a": [np.nan, False], "b": [True, True]})
  163: 
  164:         # GH4947
  165:         # bool comparisons should return bool
  166:         result = d["a"] | d["b"]
  167:         expected = Series([False, True])
  168:         tm.assert_series_equal(result, expected)
  169: 
  170:         # GH4604, automatic casting here
  171:         result = d["a"].fillna(False) | d["b"]
  172:         expected = Series([True, True])
  173:         tm.assert_series_equal(result, expected)
  174: 
  175:         msg = "The 'downcast' keyword in fillna is deprecated"
  176:         with tm.assert_produces_warning(FutureWarning, match=msg):
  177:             result = d["a"].fillna(False, downcast=False) | d["b"]
  178:         expected = Series([True, True])
  179:         tm.assert_series_equal(result, expected)
  180: 
  181:     def test_logical_ops_categorical_columns(self):
  182:         # GH#38367
  183:         intervals = [Interval(1, 2), Interval(3, 4)]
  184:         data = DataFrame(
  185:             [[1, np.nan], [2, np.nan]],
  186:             columns=CategoricalIndex(
  187:                 intervals, categories=intervals + [Interval(5, 6)]
  188:             ),
  189:         )
  190:         mask = DataFrame(
  191:             [[False, False], [False, False]], columns=data.columns, dtype=bool
  192:         )
  193:         result = mask | isnull(data)
  194:         expected = DataFrame(
  195:             [[False, True], [False, True]],
  196:             columns=CategoricalIndex(
  197:                 intervals, categories=intervals + [Interval(5, 6)]
  198:             ),
  199:         )
  200:         tm.assert_frame_equal(result, expected)
  201: 
  202:     def test_int_dtype_different_index_not_bool(self):
  203:         # GH 52500
  204:         df1 = DataFrame([1, 2, 3], index=[10, 11, 23], columns=["a"])
  205:         df2 = DataFrame([10, 20, 30], index=[11, 10, 23], columns=["a"])
  206:         result = np.bitwise_xor(df1, df2)
  207:         expected = DataFrame([21, 8, 29], index=[10, 11, 23], columns=["a"])
  208:         tm.assert_frame_equal(result, expected)
  209: 
  210:         result = df1 ^ df2
  211:         tm.assert_frame_equal(result, expected)
  212: 
  213:     def test_different_dtypes_different_index_raises(self):
  214:         # GH 52538
  215:         df1 = DataFrame([1, 2], index=["a", "b"])
  216:         df2 = DataFrame([3, 4], index=["b", "c"])
  217:         with pytest.raises(TypeError, match="unsupported operand type"):
  218:             df1 & df2
