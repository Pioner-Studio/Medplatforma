    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._config import using_pyarrow_string_dtype
    5: 
    6: from pandas.errors import ChainedAssignmentError
    7: import pandas.util._test_decorators as td
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     NaT,
   12:     Series,
   13:     date_range,
   14: )
   15: import pandas._testing as tm
   16: 
   17: 
   18: class TestDataFrameInterpolate:
   19:     def test_interpolate_complex(self):
   20:         # GH#53635
   21:         ser = Series([complex("1+1j"), float("nan"), complex("2+2j")])
   22:         assert ser.dtype.kind == "c"
   23: 
   24:         res = ser.interpolate()
   25:         expected = Series([ser[0], ser[0] * 1.5, ser[2]])
   26:         tm.assert_series_equal(res, expected)
   27: 
   28:         df = ser.to_frame()
   29:         res = df.interpolate()
   30:         expected = expected.to_frame()
   31:         tm.assert_frame_equal(res, expected)
   32: 
   33:     def test_interpolate_datetimelike_values(self, frame_or_series):
   34:         # GH#11312, GH#51005
   35:         orig = Series(date_range("2012-01-01", periods=5))
   36:         ser = orig.copy()
   37:         ser[2] = NaT
   38: 
   39:         res = frame_or_series(ser).interpolate()
   40:         expected = frame_or_series(orig)
   41:         tm.assert_equal(res, expected)
   42: 
   43:         # datetime64tz cast
   44:         ser_tz = ser.dt.tz_localize("US/Pacific")
   45:         res_tz = frame_or_series(ser_tz).interpolate()
   46:         expected_tz = frame_or_series(orig.dt.tz_localize("US/Pacific"))
   47:         tm.assert_equal(res_tz, expected_tz)
   48: 
   49:         # timedelta64 cast
   50:         ser_td = ser - ser[0]
   51:         res_td = frame_or_series(ser_td).interpolate()
   52:         expected_td = frame_or_series(orig - orig[0])
   53:         tm.assert_equal(res_td, expected_td)
   54: 
   55:     def test_interpolate_inplace(self, frame_or_series, using_array_manager, request):
   56:         # GH#44749
   57:         if using_array_manager and frame_or_series is DataFrame:
   58:             mark = pytest.mark.xfail(reason=".values-based in-place check is invalid")
   59:             request.applymarker(mark)
   60: 
   61:         obj = frame_or_series([1, np.nan, 2])
   62:         orig = obj.values
   63: 
   64:         obj.interpolate(inplace=True)
   65:         expected = frame_or_series([1, 1.5, 2])
   66:         tm.assert_equal(obj, expected)
   67: 
   68:         # check we operated *actually* inplace
   69:         assert np.shares_memory(orig, obj.values)
   70:         assert orig.squeeze()[1] == 1.5
   71: 
   72:     @pytest.mark.xfail(
   73:         using_pyarrow_string_dtype(), reason="interpolate doesn't work for string"
   74:     )
   75:     def test_interp_basic(self, using_copy_on_write):
   76:         df = DataFrame(
   77:             {
   78:                 "A": [1, 2, np.nan, 4],
   79:                 "B": [1, 4, 9, np.nan],
   80:                 "C": [1, 2, 3, 5],
   81:                 "D": list("abcd"),
   82:             }
   83:         )
   84:         expected = DataFrame(
   85:             {
   86:                 "A": [1.0, 2.0, 3.0, 4.0],
   87:                 "B": [1.0, 4.0, 9.0, 9.0],
   88:                 "C": [1, 2, 3, 5],
   89:                 "D": list("abcd"),
   90:             }
   91:         )
   92:         msg = "DataFrame.interpolate with object dtype"
   93:         with tm.assert_produces_warning(FutureWarning, match=msg):
   94:             result = df.interpolate()
   95:         tm.assert_frame_equal(result, expected)
   96: 
   97:         # check we didn't operate inplace GH#45791
   98:         cvalues = df["C"]._values
   99:         dvalues = df["D"].values
  100:         if using_copy_on_write:
  101:             assert np.shares_memory(cvalues, result["C"]._values)
  102:             assert np.shares_memory(dvalues, result["D"]._values)
  103:         else:
  104:             assert not np.shares_memory(cvalues, result["C"]._values)
  105:             assert not np.shares_memory(dvalues, result["D"]._values)
  106: 
  107:         with tm.assert_produces_warning(FutureWarning, match=msg):
  108:             res = df.interpolate(inplace=True)
  109:         assert res is None
  110:         tm.assert_frame_equal(df, expected)
  111: 
  112:         # check we DID operate inplace
  113:         assert np.shares_memory(df["C"]._values, cvalues)
  114:         assert np.shares_memory(df["D"]._values, dvalues)
  115: 
  116:     @pytest.mark.xfail(
  117:         using_pyarrow_string_dtype(), reason="interpolate doesn't work for string"
  118:     )
  119:     def test_interp_basic_with_non_range_index(self, using_infer_string):
  120:         df = DataFrame(
  121:             {
  122:                 "A": [1, 2, np.nan, 4],
  123:                 "B": [1, 4, 9, np.nan],
  124:                 "C": [1, 2, 3, 5],
  125:                 "D": list("abcd"),
  126:             }
  127:         )
  128: 
  129:         msg = "DataFrame.interpolate with object dtype"
  130:         warning = FutureWarning if not using_infer_string else None
  131:         with tm.assert_produces_warning(warning, match=msg):
  132:             result = df.set_index("C").interpolate()
  133:         expected = df.set_index("C")
  134:         expected.loc[3, "A"] = 3
  135:         expected.loc[5, "B"] = 9
  136:         tm.assert_frame_equal(result, expected)
  137: 
  138:     def test_interp_empty(self):
  139:         # https://github.com/pandas-dev/pandas/issues/35598
  140:         df = DataFrame()
  141:         result = df.interpolate()
  142:         assert result is not df
  143:         expected = df
  144:         tm.assert_frame_equal(result, expected)
  145: 
  146:     def test_interp_bad_method(self):
  147:         df = DataFrame(
  148:             {
  149:                 "A": [1, 2, np.nan, 4],
  150:                 "B": [1, 4, 9, np.nan],
  151:                 "C": [1, 2, 3, 5],
  152:             }
  153:         )
  154:         msg = (
  155:             r"method must be one of \['linear', 'time', 'index', 'values', "
  156:             r"'nearest', 'zero', 'slinear', 'quadratic', 'cubic', "
  157:             r"'barycentric', 'krogh', 'spline', 'polynomial', "
  158:             r"'from_derivatives', 'piecewise_polynomial', 'pchip', 'akima', "
  159:             r"'cubicspline'\]. Got 'not_a_method' instead."
  160:         )
  161:         with pytest.raises(ValueError, match=msg):
  162:             df.interpolate(method="not_a_method")
  163: 
  164:     def test_interp_combo(self):
  165:         df = DataFrame(
  166:             {
  167:                 "A": [1.0, 2.0, np.nan, 4.0],
  168:                 "B": [1, 4, 9, np.nan],
  169:                 "C": [1, 2, 3, 5],
  170:                 "D": list("abcd"),
  171:             }
  172:         )
  173: 
  174:         result = df["A"].interpolate()
  175:         expected = Series([1.0, 2.0, 3.0, 4.0], name="A")
  176:         tm.assert_series_equal(result, expected)
  177: 
  178:         msg = "The 'downcast' keyword in Series.interpolate is deprecated"
  179:         with tm.assert_produces_warning(FutureWarning, match=msg):
  180:             result = df["A"].interpolate(downcast="infer")
  181:         expected = Series([1, 2, 3, 4], name="A")
  182:         tm.assert_series_equal(result, expected)
  183: 
  184:     def test_inerpolate_invalid_downcast(self):
  185:         # GH#53103
  186:         df = DataFrame(
  187:             {
  188:                 "A": [1.0, 2.0, np.nan, 4.0],
  189:                 "B": [1, 4, 9, np.nan],
  190:                 "C": [1, 2, 3, 5],
  191:                 "D": list("abcd"),
  192:             }
  193:         )
  194: 
  195:         msg = "downcast must be either None or 'infer'"
  196:         msg2 = "The 'downcast' keyword in DataFrame.interpolate is deprecated"
  197:         msg3 = "The 'downcast' keyword in Series.interpolate is deprecated"
  198:         with pytest.raises(ValueError, match=msg):
  199:             with tm.assert_produces_warning(FutureWarning, match=msg2):
  200:                 df.interpolate(downcast="int64")
  201:         with pytest.raises(ValueError, match=msg):
  202:             with tm.assert_produces_warning(FutureWarning, match=msg3):
  203:                 df["A"].interpolate(downcast="int64")
  204: 
  205:     def test_interp_nan_idx(self):
  206:         df = DataFrame({"A": [1, 2, np.nan, 4], "B": [np.nan, 2, 3, 4]})
  207:         df = df.set_index("A")
  208:         msg = (
  209:             "Interpolation with NaNs in the index has not been implemented. "
  210:             "Try filling those NaNs before interpolating."
  211:         )
  212:         with pytest.raises(NotImplementedError, match=msg):
  213:             df.interpolate(method="values")
  214: 
  215:     def test_interp_various(self):
  216:         pytest.importorskip("scipy")
  217:         df = DataFrame(
  218:             {"A": [1, 2, np.nan, 4, 5, np.nan, 7], "C": [1, 2, 3, 5, 8, 13, 21]}
  219:         )
  220:         df = df.set_index("C")
  221:         expected = df.copy()
  222:         result = df.interpolate(method="polynomial", order=1)
  223: 
  224:         expected.loc[3, "A"] = 2.66666667
  225:         expected.loc[13, "A"] = 5.76923076
  226:         tm.assert_frame_equal(result, expected)
  227: 
  228:         result = df.interpolate(method="cubic")
  229:         # GH #15662.
  230:         expected.loc[3, "A"] = 2.81547781
  231:         expected.loc[13, "A"] = 5.52964175
  232:         tm.assert_frame_equal(result, expected)
  233: 
  234:         result = df.interpolate(method="nearest")
  235:         expected.loc[3, "A"] = 2
  236:         expected.loc[13, "A"] = 5
  237:         tm.assert_frame_equal(result, expected, check_dtype=False)
  238: 
  239:         result = df.interpolate(method="quadratic")
  240:         expected.loc[3, "A"] = 2.82150771
  241:         expected.loc[13, "A"] = 6.12648668
  242:         tm.assert_frame_equal(result, expected)
  243: 
  244:         result = df.interpolate(method="slinear")
  245:         expected.loc[3, "A"] = 2.66666667
  246:         expected.loc[13, "A"] = 5.76923077
  247:         tm.assert_frame_equal(result, expected)
  248: 
  249:         result = df.interpolate(method="zero")
  250:         expected.loc[3, "A"] = 2.0
  251:         expected.loc[13, "A"] = 5
  252:         tm.assert_frame_equal(result, expected, check_dtype=False)
  253: 
  254:     def test_interp_alt_scipy(self):
  255:         pytest.importorskip("scipy")
  256:         df = DataFrame(
  257:             {"A": [1, 2, np.nan, 4, 5, np.nan, 7], "C": [1, 2, 3, 5, 8, 13, 21]}
  258:         )
  259:         result = df.interpolate(method="barycentric")
  260:         expected = df.copy()
  261:         expected.loc[2, "A"] = 3
  262:         expected.loc[5, "A"] = 6
  263:         tm.assert_frame_equal(result, expected)
  264: 
  265:         msg = "The 'downcast' keyword in DataFrame.interpolate is deprecated"
  266:         with tm.assert_produces_warning(FutureWarning, match=msg):
  267:             result = df.interpolate(method="barycentric", downcast="infer")
  268:         tm.assert_frame_equal(result, expected.astype(np.int64))
  269: 
  270:         result = df.interpolate(method="krogh")
  271:         expectedk = df.copy()
  272:         expectedk["A"] = expected["A"]
  273:         tm.assert_frame_equal(result, expectedk)
  274: 
  275:         result = df.interpolate(method="pchip")
  276:         expected.loc[2, "A"] = 3
  277:         expected.loc[5, "A"] = 6.0
  278: 
  279:         tm.assert_frame_equal(result, expected)
  280: 
  281:     def test_interp_rowwise(self):
  282:         df = DataFrame(
  283:             {
  284:                 0: [1, 2, np.nan, 4],
  285:                 1: [2, 3, 4, np.nan],
  286:                 2: [np.nan, 4, 5, 6],
  287:                 3: [4, np.nan, 6, 7],
  288:                 4: [1, 2, 3, 4],
  289:             }
  290:         )
  291:         result = df.interpolate(axis=1)
  292:         expected = df.copy()
  293:         expected.loc[3, 1] = 5
  294:         expected.loc[0, 2] = 3
  295:         expected.loc[1, 3] = 3
  296:         expected[4] = expected[4].astype(np.float64)
  297:         tm.assert_frame_equal(result, expected)
  298: 
  299:         result = df.interpolate(axis=1, method="values")
  300:         tm.assert_frame_equal(result, expected)
  301: 
  302:         result = df.interpolate(axis=0)
  303:         expected = df.interpolate()
  304:         tm.assert_frame_equal(result, expected)
  305: 
  306:     @pytest.mark.parametrize(
  307:         "axis_name, axis_number",
  308:         [
  309:             pytest.param("rows", 0, id="rows_0"),
  310:             pytest.param("index", 0, id="index_0"),
  311:             pytest.param("columns", 1, id="columns_1"),
  312:         ],
  313:     )
  314:     def test_interp_axis_names(self, axis_name, axis_number):
  315:         # GH 29132: test axis names
  316:         data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}
  317: 
  318:         df = DataFrame(data, dtype=np.float64)
  319:         result = df.interpolate(axis=axis_name, method="linear")
  320:         expected = df.interpolate(axis=axis_number, method="linear")
  321:         tm.assert_frame_equal(result, expected)
  322: 
  323:     def test_rowwise_alt(self):
  324:         df = DataFrame(
  325:             {
  326:                 0: [0, 0.5, 1.0, np.nan, 4, 8, np.nan, np.nan, 64],
  327:                 1: [1, 2, 3, 4, 3, 2, 1, 0, -1],
  328:             }
  329:         )
  330:         df.interpolate(axis=0)
  331:         # TODO: assert something?
  332: 
  333:     @pytest.mark.parametrize(
  334:         "check_scipy", [False, pytest.param(True, marks=td.skip_if_no("scipy"))]
  335:     )
  336:     def test_interp_leading_nans(self, check_scipy):
  337:         df = DataFrame(
  338:             {"A": [np.nan, np.nan, 0.5, 0.25, 0], "B": [np.nan, -3, -3.5, np.nan, -4]}
  339:         )
  340:         result = df.interpolate()
  341:         expected = df.copy()
  342:         expected.loc[3, "B"] = -3.75
  343:         tm.assert_frame_equal(result, expected)
  344: 
  345:         if check_scipy:
  346:             result = df.interpolate(method="polynomial", order=1)
  347:             tm.assert_frame_equal(result, expected)
  348: 
  349:     def test_interp_raise_on_only_mixed(self, axis):
  350:         df = DataFrame(
  351:             {
  352:                 "A": [1, 2, np.nan, 4],
  353:                 "B": ["a", "b", "c", "d"],
  354:                 "C": [np.nan, 2, 5, 7],
  355:                 "D": [np.nan, np.nan, 9, 9],
  356:                 "E": [1, 2, 3, 4],
  357:             }
  358:         )
  359:         msg = (
  360:             "Cannot interpolate with all object-dtype columns "
  361:             "in the DataFrame. Try setting at least one "
  362:             "column to a numeric dtype."
  363:         )
  364:         with pytest.raises(TypeError, match=msg):
  365:             df.astype("object").interpolate(axis=axis)
  366: 
  367:     def test_interp_raise_on_all_object_dtype(self):
  368:         # GH 22985
  369:         df = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}, dtype="object")
  370:         msg = (
  371:             "Cannot interpolate with all object-dtype columns "
  372:             "in the DataFrame. Try setting at least one "
  373:             "column to a numeric dtype."
  374:         )
  375:         with pytest.raises(TypeError, match=msg):
  376:             df.interpolate()
  377: 
  378:     def test_interp_inplace(self, using_copy_on_write):
  379:         df = DataFrame({"a": [1.0, 2.0, np.nan, 4.0]})
  380:         expected = DataFrame({"a": [1.0, 2.0, 3.0, 4.0]})
  381:         expected_cow = df.copy()
  382:         result = df.copy()
  383: 
  384:         if using_copy_on_write:
  385:             with tm.raises_chained_assignment_error():
  386:                 return_value = result["a"].interpolate(inplace=True)
  387:             assert return_value is None
  388:             tm.assert_frame_equal(result, expected_cow)
  389:         else:
  390:             with tm.assert_produces_warning(FutureWarning, match="inplace method"):
  391:                 return_value = result["a"].interpolate(inplace=True)
  392:             assert return_value is None
  393:             tm.assert_frame_equal(result, expected)
  394: 
  395:         result = df.copy()
  396:         msg = "The 'downcast' keyword in Series.interpolate is deprecated"
  397: 
  398:         if using_copy_on_write:
  399:             with tm.assert_produces_warning(
  400:                 (FutureWarning, ChainedAssignmentError), match=msg
  401:             ):
  402:                 return_value = result["a"].interpolate(inplace=True, downcast="infer")
  403:             assert return_value is None
  404:             tm.assert_frame_equal(result, expected_cow)
  405:         else:
  406:             with tm.assert_produces_warning(FutureWarning, match=msg):
  407:                 return_value = result["a"].interpolate(inplace=True, downcast="infer")
  408:             assert return_value is None
  409:             tm.assert_frame_equal(result, expected.astype("int64"))
  410: 
  411:     def test_interp_inplace_row(self):
  412:         # GH 10395
  413:         result = DataFrame(
  414:             {"a": [1.0, 2.0, 3.0, 4.0], "b": [np.nan, 2.0, 3.0, 4.0], "c": [3, 2, 2, 2]}
  415:         )
  416:         expected = result.interpolate(method="linear", axis=1, inplace=False)
  417:         return_value = result.interpolate(method="linear", axis=1, inplace=True)
  418:         assert return_value is None
  419:         tm.assert_frame_equal(result, expected)
  420: 
  421:     def test_interp_ignore_all_good(self):
  422:         # GH
  423:         df = DataFrame(
  424:             {
  425:                 "A": [1, 2, np.nan, 4],
  426:                 "B": [1, 2, 3, 4],
  427:                 "C": [1.0, 2.0, np.nan, 4.0],
  428:                 "D": [1.0, 2.0, 3.0, 4.0],
  429:             }
  430:         )
  431:         expected = DataFrame(
  432:             {
  433:                 "A": np.array([1, 2, 3, 4], dtype="float64"),
  434:                 "B": np.array([1, 2, 3, 4], dtype="int64"),
  435:                 "C": np.array([1.0, 2.0, 3, 4.0], dtype="float64"),
  436:                 "D": np.array([1.0, 2.0, 3.0, 4.0], dtype="float64"),
  437:             }
  438:         )
  439: 
  440:         msg = "The 'downcast' keyword in DataFrame.interpolate is deprecated"
  441:         with tm.assert_produces_warning(FutureWarning, match=msg):
  442:             result = df.interpolate(downcast=None)
  443:         tm.assert_frame_equal(result, expected)
  444: 
  445:         # all good
  446:         with tm.assert_produces_warning(FutureWarning, match=msg):
  447:             result = df[["B", "D"]].interpolate(downcast=None)
  448:         tm.assert_frame_equal(result, df[["B", "D"]])
  449: 
  450:     def test_interp_time_inplace_axis(self):
  451:         # GH 9687
  452:         periods = 5
  453:         idx = date_range(start="2014-01-01", periods=periods)
  454:         data = np.random.default_rng(2).random((periods, periods))
  455:         data[data < 0.5] = np.nan
  456:         expected = DataFrame(index=idx, columns=idx, data=data)
  457: 
  458:         result = expected.interpolate(axis=0, method="time")
  459:         return_value = expected.interpolate(axis=0, method="time", inplace=True)
  460:         assert return_value is None
  461:         tm.assert_frame_equal(result, expected)
  462: 
  463:     @pytest.mark.parametrize("axis_name, axis_number", [("index", 0), ("columns", 1)])
  464:     def test_interp_string_axis(self, axis_name, axis_number):
  465:         # https://github.com/pandas-dev/pandas/issues/25190
  466:         x = np.linspace(0, 100, 1000)
  467:         y = np.sin(x)
  468:         df = DataFrame(
  469:             data=np.tile(y, (10, 1)), index=np.arange(10), columns=x
  470:         ).reindex(columns=x * 1.005)
  471:         result = df.interpolate(method="linear", axis=axis_name)
  472:         expected = df.interpolate(method="linear", axis=axis_number)
  473:         tm.assert_frame_equal(result, expected)
  474: 
  475:     @pytest.mark.parametrize("multiblock", [True, False])
  476:     @pytest.mark.parametrize("method", ["ffill", "bfill", "pad"])
  477:     def test_interp_fillna_methods(
  478:         self, request, axis, multiblock, method, using_array_manager
  479:     ):
  480:         # GH 12918
  481:         if using_array_manager and axis in (1, "columns"):
  482:             # TODO(ArrayManager) support axis=1
  483:             td.mark_array_manager_not_yet_implemented(request)
  484: 
  485:         df = DataFrame(
  486:             {
  487:                 "A": [1.0, 2.0, 3.0, 4.0, np.nan, 5.0],
  488:                 "B": [2.0, 4.0, 6.0, np.nan, 8.0, 10.0],
  489:                 "C": [3.0, 6.0, 9.0, np.nan, np.nan, 30.0],
  490:             }
  491:         )
  492:         if multiblock:
  493:             df["D"] = np.nan
  494:             df["E"] = 1.0
  495: 
  496:         method2 = method if method != "pad" else "ffill"
  497:         expected = getattr(df, method2)(axis=axis)
  498:         msg = f"DataFrame.interpolate with method={method} is deprecated"
  499:         with tm.assert_produces_warning(FutureWarning, match=msg):
  500:             result = df.interpolate(method=method, axis=axis)
  501:         tm.assert_frame_equal(result, expected)
  502: 
  503:     def test_interpolate_empty_df(self):
  504:         # GH#53199
  505:         df = DataFrame()
  506:         expected = df.copy()
  507:         result = df.interpolate(inplace=True)
  508:         assert result is None
  509:         tm.assert_frame_equal(df, expected)
  510: 
  511:     def test_interpolate_ea(self, any_int_ea_dtype):
  512:         # GH#55347
  513:         df = DataFrame({"a": [1, None, None, None, 3]}, dtype=any_int_ea_dtype)
  514:         orig = df.copy()
  515:         result = df.interpolate(limit=2)
  516:         expected = DataFrame({"a": [1, 1.5, 2.0, None, 3]}, dtype="Float64")
  517:         tm.assert_frame_equal(result, expected)
  518:         tm.assert_frame_equal(df, orig)
  519: 
  520:     @pytest.mark.parametrize(
  521:         "dtype",
  522:         [
  523:             "Float64",
  524:             "Float32",
  525:             pytest.param("float32[pyarrow]", marks=td.skip_if_no("pyarrow")),
  526:             pytest.param("float64[pyarrow]", marks=td.skip_if_no("pyarrow")),
  527:         ],
  528:     )
  529:     def test_interpolate_ea_float(self, dtype):
  530:         # GH#55347
  531:         df = DataFrame({"a": [1, None, None, None, 3]}, dtype=dtype)
  532:         orig = df.copy()
  533:         result = df.interpolate(limit=2)
  534:         expected = DataFrame({"a": [1, 1.5, 2.0, None, 3]}, dtype=dtype)
  535:         tm.assert_frame_equal(result, expected)
  536:         tm.assert_frame_equal(df, orig)
  537: 
  538:     @pytest.mark.parametrize(
  539:         "dtype",
  540:         ["int64", "uint64", "int32", "int16", "int8", "uint32", "uint16", "uint8"],
  541:     )
  542:     def test_interpolate_arrow(self, dtype):
  543:         # GH#55347
  544:         pytest.importorskip("pyarrow")
  545:         df = DataFrame({"a": [1, None, None, None, 3]}, dtype=dtype + "[pyarrow]")
  546:         result = df.interpolate(limit=2)
  547:         expected = DataFrame({"a": [1, 1.5, 2.0, None, 3]}, dtype="float64[pyarrow]")
  548:         tm.assert_frame_equal(result, expected)
