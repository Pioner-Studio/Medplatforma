    1: """
    2: Note: for naming purposes, most tests are title with as e.g. "test_nlargest_foo"
    3: but are implicitly also testing nsmallest_foo.
    4: """
    5: from string import ascii_lowercase
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: import pandas as pd
   11: import pandas._testing as tm
   12: from pandas.util.version import Version
   13: 
   14: 
   15: @pytest.fixture
   16: def df_duplicates():
   17:     return pd.DataFrame(
   18:         {"a": [1, 2, 3, 4, 4], "b": [1, 1, 1, 1, 1], "c": [0, 1, 2, 5, 4]},
   19:         index=[0, 0, 1, 1, 1],
   20:     )
   21: 
   22: 
   23: @pytest.fixture
   24: def df_strings():
   25:     return pd.DataFrame(
   26:         {
   27:             "a": np.random.default_rng(2).permutation(10),
   28:             "b": list(ascii_lowercase[:10]),
   29:             "c": np.random.default_rng(2).permutation(10).astype("float64"),
   30:         }
   31:     )
   32: 
   33: 
   34: @pytest.fixture
   35: def df_main_dtypes():
   36:     return pd.DataFrame(
   37:         {
   38:             "group": [1, 1, 2],
   39:             "int": [1, 2, 3],
   40:             "float": [4.0, 5.0, 6.0],
   41:             "string": list("abc"),
   42:             "category_string": pd.Series(list("abc")).astype("category"),
   43:             "category_int": [7, 8, 9],
   44:             "datetime": pd.date_range("20130101", periods=3),
   45:             "datetimetz": pd.date_range("20130101", periods=3, tz="US/Eastern"),
   46:             "timedelta": pd.timedelta_range("1 s", periods=3, freq="s"),
   47:         },
   48:         columns=[
   49:             "group",
   50:             "int",
   51:             "float",
   52:             "string",
   53:             "category_string",
   54:             "category_int",
   55:             "datetime",
   56:             "datetimetz",
   57:             "timedelta",
   58:         ],
   59:     )
   60: 
   61: 
   62: class TestNLargestNSmallest:
   63:     # ----------------------------------------------------------------------
   64:     # Top / bottom
   65:     @pytest.mark.parametrize(
   66:         "order",
   67:         [
   68:             ["a"],
   69:             ["c"],
   70:             ["a", "b"],
   71:             ["a", "c"],
   72:             ["b", "a"],
   73:             ["b", "c"],
   74:             ["a", "b", "c"],
   75:             ["c", "a", "b"],
   76:             ["c", "b", "a"],
   77:             ["b", "c", "a"],
   78:             ["b", "a", "c"],
   79:             # dups!
   80:             ["b", "c", "c"],
   81:         ],
   82:     )
   83:     @pytest.mark.parametrize("n", range(1, 11))
   84:     def test_nlargest_n(self, df_strings, nselect_method, n, order):
   85:         # GH#10393
   86:         df = df_strings
   87:         if "b" in order:
   88:             error_msg = (
   89:                 f"Column 'b' has dtype (object|string), "
   90:                 f"cannot use method '{nselect_method}' with this dtype"
   91:             )
   92:             with pytest.raises(TypeError, match=error_msg):
   93:                 getattr(df, nselect_method)(n, order)
   94:         else:
   95:             ascending = nselect_method == "nsmallest"
   96:             result = getattr(df, nselect_method)(n, order)
   97:             expected = df.sort_values(order, ascending=ascending).head(n)
   98:             tm.assert_frame_equal(result, expected)
   99: 
  100:     @pytest.mark.parametrize(
  101:         "columns", [["group", "category_string"], ["group", "string"]]
  102:     )
  103:     def test_nlargest_error(self, df_main_dtypes, nselect_method, columns):
  104:         df = df_main_dtypes
  105:         col = columns[1]
  106:         error_msg = (
  107:             f"Column '{col}' has dtype {df[col].dtype}, "
  108:             f"cannot use method '{nselect_method}' with this dtype"
  109:         )
  110:         # escape some characters that may be in the repr
  111:         error_msg = (
  112:             error_msg.replace("(", "\\(")
  113:             .replace(")", "\\)")
  114:             .replace("[", "\\[")
  115:             .replace("]", "\\]")
  116:         )
  117:         with pytest.raises(TypeError, match=error_msg):
  118:             getattr(df, nselect_method)(2, columns)
  119: 
  120:     def test_nlargest_all_dtypes(self, df_main_dtypes):
  121:         df = df_main_dtypes
  122:         df.nsmallest(2, list(set(df) - {"category_string", "string"}))
  123:         df.nlargest(2, list(set(df) - {"category_string", "string"}))
  124: 
  125:     def test_nlargest_duplicates_on_starter_columns(self):
  126:         # regression test for GH#22752
  127: 
  128:         df = pd.DataFrame({"a": [2, 2, 2, 1, 1, 1], "b": [1, 2, 3, 3, 2, 1]})
  129: 
  130:         result = df.nlargest(4, columns=["a", "b"])
  131:         expected = pd.DataFrame(
  132:             {"a": [2, 2, 2, 1], "b": [3, 2, 1, 3]}, index=[2, 1, 0, 3]
  133:         )
  134:         tm.assert_frame_equal(result, expected)
  135: 
  136:         result = df.nsmallest(4, columns=["a", "b"])
  137:         expected = pd.DataFrame(
  138:             {"a": [1, 1, 1, 2], "b": [1, 2, 3, 1]}, index=[5, 4, 3, 0]
  139:         )
  140:         tm.assert_frame_equal(result, expected)
  141: 
  142:     def test_nlargest_n_identical_values(self):
  143:         # GH#15297
  144:         df = pd.DataFrame({"a": [1] * 5, "b": [1, 2, 3, 4, 5]})
  145: 
  146:         result = df.nlargest(3, "a")
  147:         expected = pd.DataFrame({"a": [1] * 3, "b": [1, 2, 3]}, index=[0, 1, 2])
  148:         tm.assert_frame_equal(result, expected)
  149: 
  150:         result = df.nsmallest(3, "a")
  151:         expected = pd.DataFrame({"a": [1] * 3, "b": [1, 2, 3]})
  152:         tm.assert_frame_equal(result, expected)
  153: 
  154:     @pytest.mark.parametrize(
  155:         "order",
  156:         [["a", "b", "c"], ["c", "b", "a"], ["a"], ["b"], ["a", "b"], ["c", "b"]],
  157:     )
  158:     @pytest.mark.parametrize("n", range(1, 6))
  159:     def test_nlargest_n_duplicate_index(self, df_duplicates, n, order, request):
  160:         # GH#13412
  161: 
  162:         df = df_duplicates
  163:         result = df.nsmallest(n, order)
  164:         expected = df.sort_values(order).head(n)
  165:         tm.assert_frame_equal(result, expected)
  166: 
  167:         result = df.nlargest(n, order)
  168:         expected = df.sort_values(order, ascending=False).head(n)
  169:         if Version(np.__version__) >= Version("1.25") and (
  170:             (order == ["a"] and n in (1, 2, 3, 4)) or (order == ["a", "b"]) and n == 5
  171:         ):
  172:             request.applymarker(
  173:                 pytest.mark.xfail(
  174:                     reason=(
  175:                         "pandas default unstable sorting of duplicates"
  176:                         "issue with numpy>=1.25 with AVX instructions"
  177:                     ),
  178:                     strict=False,
  179:                 )
  180:             )
  181:         tm.assert_frame_equal(result, expected)
  182: 
  183:     def test_nlargest_duplicate_keep_all_ties(self):
  184:         # GH#16818
  185:         df = pd.DataFrame(
  186:             {"a": [5, 4, 4, 2, 3, 3, 3, 3], "b": [10, 9, 8, 7, 5, 50, 10, 20]}
  187:         )
  188:         result = df.nlargest(4, "a", keep="all")
  189:         expected = pd.DataFrame(
  190:             {
  191:                 "a": {0: 5, 1: 4, 2: 4, 4: 3, 5: 3, 6: 3, 7: 3},
  192:                 "b": {0: 10, 1: 9, 2: 8, 4: 5, 5: 50, 6: 10, 7: 20},
  193:             }
  194:         )
  195:         tm.assert_frame_equal(result, expected)
  196: 
  197:         result = df.nsmallest(2, "a", keep="all")
  198:         expected = pd.DataFrame(
  199:             {
  200:                 "a": {3: 2, 4: 3, 5: 3, 6: 3, 7: 3},
  201:                 "b": {3: 7, 4: 5, 5: 50, 6: 10, 7: 20},
  202:             }
  203:         )
  204:         tm.assert_frame_equal(result, expected)
  205: 
  206:     def test_nlargest_multiindex_column_lookup(self):
  207:         # Check whether tuples are correctly treated as multi-level lookups.
  208:         # GH#23033
  209:         df = pd.DataFrame(
  210:             columns=pd.MultiIndex.from_product([["x"], ["a", "b"]]),
  211:             data=[[0.33, 0.13], [0.86, 0.25], [0.25, 0.70], [0.85, 0.91]],
  212:         )
  213: 
  214:         # nsmallest
  215:         result = df.nsmallest(3, ("x", "a"))
  216:         expected = df.iloc[[2, 0, 3]]
  217:         tm.assert_frame_equal(result, expected)
  218: 
  219:         # nlargest
  220:         result = df.nlargest(3, ("x", "b"))
  221:         expected = df.iloc[[3, 2, 1]]
  222:         tm.assert_frame_equal(result, expected)
  223: 
  224:     def test_nlargest_nan(self):
  225:         # GH#43060
  226:         df = pd.DataFrame([np.nan, np.nan, 0, 1, 2, 3])
  227:         result = df.nlargest(5, 0)
  228:         expected = df.sort_values(0, ascending=False).head(5)
  229:         tm.assert_frame_equal(result, expected)
  230: 
  231:     def test_nsmallest_nan_after_n_element(self):
  232:         # GH#46589
  233:         df = pd.DataFrame(
  234:             {
  235:                 "a": [1, 2, 3, 4, 5, None, 7],
  236:                 "b": [7, 6, 5, 4, 3, 2, 1],
  237:                 "c": [1, 1, 2, 2, 3, 3, 3],
  238:             },
  239:             index=range(7),
  240:         )
  241:         result = df.nsmallest(5, columns=["a", "b"])
  242:         expected = pd.DataFrame(
  243:             {
  244:                 "a": [1, 2, 3, 4, 5],
  245:                 "b": [7, 6, 5, 4, 3],
  246:                 "c": [1, 1, 2, 2, 3],
  247:             },
  248:             index=range(5),
  249:         ).astype({"a": "float"})
  250:         tm.assert_frame_equal(result, expected)
