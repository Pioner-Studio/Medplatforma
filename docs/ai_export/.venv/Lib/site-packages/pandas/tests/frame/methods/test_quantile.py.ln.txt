    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     DataFrame,
    7:     Index,
    8:     Series,
    9:     Timestamp,
   10: )
   11: import pandas._testing as tm
   12: 
   13: 
   14: @pytest.fixture(
   15:     params=[["linear", "single"], ["nearest", "table"]], ids=lambda x: "-".join(x)
   16: )
   17: def interp_method(request):
   18:     """(interpolation, method) arguments for quantile"""
   19:     return request.param
   20: 
   21: 
   22: class TestDataFrameQuantile:
   23:     @pytest.mark.parametrize(
   24:         "df,expected",
   25:         [
   26:             [
   27:                 DataFrame(
   28:                     {
   29:                         0: Series(pd.arrays.SparseArray([1, 2])),
   30:                         1: Series(pd.arrays.SparseArray([3, 4])),
   31:                     }
   32:                 ),
   33:                 Series([1.5, 3.5], name=0.5),
   34:             ],
   35:             [
   36:                 DataFrame(Series([0.0, None, 1.0, 2.0], dtype="Sparse[float]")),
   37:                 Series([1.0], name=0.5),
   38:             ],
   39:         ],
   40:     )
   41:     def test_quantile_sparse(self, df, expected):
   42:         # GH#17198
   43:         # GH#24600
   44:         result = df.quantile()
   45:         expected = expected.astype("Sparse[float]")
   46:         tm.assert_series_equal(result, expected)
   47: 
   48:     def test_quantile(
   49:         self, datetime_frame, interp_method, using_array_manager, request
   50:     ):
   51:         interpolation, method = interp_method
   52:         df = datetime_frame
   53:         result = df.quantile(
   54:             0.1, axis=0, numeric_only=True, interpolation=interpolation, method=method
   55:         )
   56:         expected = Series(
   57:             [np.percentile(df[col], 10) for col in df.columns],
   58:             index=df.columns,
   59:             name=0.1,
   60:         )
   61:         if interpolation == "linear":
   62:             # np.percentile values only comparable to linear interpolation
   63:             tm.assert_series_equal(result, expected)
   64:         else:
   65:             tm.assert_index_equal(result.index, expected.index)
   66:             request.applymarker(
   67:                 pytest.mark.xfail(
   68:                     using_array_manager, reason="Name set incorrectly for arraymanager"
   69:                 )
   70:             )
   71:             assert result.name == expected.name
   72: 
   73:         result = df.quantile(
   74:             0.9, axis=1, numeric_only=True, interpolation=interpolation, method=method
   75:         )
   76:         expected = Series(
   77:             [np.percentile(df.loc[date], 90) for date in df.index],
   78:             index=df.index,
   79:             name=0.9,
   80:         )
   81:         if interpolation == "linear":
   82:             # np.percentile values only comparable to linear interpolation
   83:             tm.assert_series_equal(result, expected)
   84:         else:
   85:             tm.assert_index_equal(result.index, expected.index)
   86:             request.applymarker(
   87:                 pytest.mark.xfail(
   88:                     using_array_manager, reason="Name set incorrectly for arraymanager"
   89:                 )
   90:             )
   91:             assert result.name == expected.name
   92: 
   93:     def test_empty(self, interp_method):
   94:         interpolation, method = interp_method
   95:         q = DataFrame({"x": [], "y": []}).quantile(
   96:             0.1, axis=0, numeric_only=True, interpolation=interpolation, method=method
   97:         )
   98:         assert np.isnan(q["x"]) and np.isnan(q["y"])
   99: 
  100:     def test_non_numeric_exclusion(self, interp_method, request, using_array_manager):
  101:         interpolation, method = interp_method
  102:         df = DataFrame({"col1": ["A", "A", "B", "B"], "col2": [1, 2, 3, 4]})
  103:         rs = df.quantile(
  104:             0.5, numeric_only=True, interpolation=interpolation, method=method
  105:         )
  106:         xp = df.median(numeric_only=True).rename(0.5)
  107:         if interpolation == "nearest":
  108:             xp = (xp + 0.5).astype(np.int64)
  109:         if method == "table" and using_array_manager:
  110:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  111:         tm.assert_series_equal(rs, xp)
  112: 
  113:     def test_axis(self, interp_method, request, using_array_manager):
  114:         # axis
  115:         interpolation, method = interp_method
  116:         df = DataFrame({"A": [1, 2, 3], "B": [2, 3, 4]}, index=[1, 2, 3])
  117:         result = df.quantile(0.5, axis=1, interpolation=interpolation, method=method)
  118:         expected = Series([1.5, 2.5, 3.5], index=[1, 2, 3], name=0.5)
  119:         if interpolation == "nearest":
  120:             expected = expected.astype(np.int64)
  121:         if method == "table" and using_array_manager:
  122:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  123:         tm.assert_series_equal(result, expected)
  124: 
  125:         result = df.quantile(
  126:             [0.5, 0.75], axis=1, interpolation=interpolation, method=method
  127:         )
  128:         expected = DataFrame(
  129:             {1: [1.5, 1.75], 2: [2.5, 2.75], 3: [3.5, 3.75]}, index=[0.5, 0.75]
  130:         )
  131:         if interpolation == "nearest":
  132:             expected.iloc[0, :] -= 0.5
  133:             expected.iloc[1, :] += 0.25
  134:             expected = expected.astype(np.int64)
  135:         tm.assert_frame_equal(result, expected, check_index_type=True)
  136: 
  137:     def test_axis_numeric_only_true(self, interp_method, request, using_array_manager):
  138:         # We may want to break API in the future to change this
  139:         # so that we exclude non-numeric along the same axis
  140:         # See GH #7312
  141:         interpolation, method = interp_method
  142:         df = DataFrame([[1, 2, 3], ["a", "b", 4]])
  143:         result = df.quantile(
  144:             0.5, axis=1, numeric_only=True, interpolation=interpolation, method=method
  145:         )
  146:         expected = Series([3.0, 4.0], index=[0, 1], name=0.5)
  147:         if interpolation == "nearest":
  148:             expected = expected.astype(np.int64)
  149:         if method == "table" and using_array_manager:
  150:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  151:         tm.assert_series_equal(result, expected)
  152: 
  153:     def test_quantile_date_range(self, interp_method, request, using_array_manager):
  154:         # GH 2460
  155:         interpolation, method = interp_method
  156:         dti = pd.date_range("2016-01-01", periods=3, tz="US/Pacific")
  157:         ser = Series(dti)
  158:         df = DataFrame(ser)
  159: 
  160:         result = df.quantile(
  161:             numeric_only=False, interpolation=interpolation, method=method
  162:         )
  163:         expected = Series(
  164:             ["2016-01-02 00:00:00"], name=0.5, dtype="datetime64[ns, US/Pacific]"
  165:         )
  166:         if method == "table" and using_array_manager:
  167:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  168: 
  169:         tm.assert_series_equal(result, expected)
  170: 
  171:     def test_quantile_axis_mixed(self, interp_method, request, using_array_manager):
  172:         # mixed on axis=1
  173:         interpolation, method = interp_method
  174:         df = DataFrame(
  175:             {
  176:                 "A": [1, 2, 3],
  177:                 "B": [2.0, 3.0, 4.0],
  178:                 "C": pd.date_range("20130101", periods=3),
  179:                 "D": ["foo", "bar", "baz"],
  180:             }
  181:         )
  182:         result = df.quantile(
  183:             0.5, axis=1, numeric_only=True, interpolation=interpolation, method=method
  184:         )
  185:         expected = Series([1.5, 2.5, 3.5], name=0.5)
  186:         if interpolation == "nearest":
  187:             expected -= 0.5
  188:         if method == "table" and using_array_manager:
  189:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  190:         tm.assert_series_equal(result, expected)
  191: 
  192:         # must raise
  193:         msg = "'<' not supported between instances of 'Timestamp' and 'float'"
  194:         with pytest.raises(TypeError, match=msg):
  195:             df.quantile(0.5, axis=1, numeric_only=False)
  196: 
  197:     def test_quantile_axis_parameter(self, interp_method, request, using_array_manager):
  198:         # GH 9543/9544
  199:         interpolation, method = interp_method
  200:         if method == "table" and using_array_manager:
  201:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  202:         df = DataFrame({"A": [1, 2, 3], "B": [2, 3, 4]}, index=[1, 2, 3])
  203: 
  204:         result = df.quantile(0.5, axis=0, interpolation=interpolation, method=method)
  205: 
  206:         expected = Series([2.0, 3.0], index=["A", "B"], name=0.5)
  207:         if interpolation == "nearest":
  208:             expected = expected.astype(np.int64)
  209:         tm.assert_series_equal(result, expected)
  210: 
  211:         expected = df.quantile(
  212:             0.5, axis="index", interpolation=interpolation, method=method
  213:         )
  214:         if interpolation == "nearest":
  215:             expected = expected.astype(np.int64)
  216:         tm.assert_series_equal(result, expected)
  217: 
  218:         result = df.quantile(0.5, axis=1, interpolation=interpolation, method=method)
  219: 
  220:         expected = Series([1.5, 2.5, 3.5], index=[1, 2, 3], name=0.5)
  221:         if interpolation == "nearest":
  222:             expected = expected.astype(np.int64)
  223:         tm.assert_series_equal(result, expected)
  224: 
  225:         result = df.quantile(
  226:             0.5, axis="columns", interpolation=interpolation, method=method
  227:         )
  228:         tm.assert_series_equal(result, expected)
  229: 
  230:         msg = "No axis named -1 for object type DataFrame"
  231:         with pytest.raises(ValueError, match=msg):
  232:             df.quantile(0.1, axis=-1, interpolation=interpolation, method=method)
  233:         msg = "No axis named column for object type DataFrame"
  234:         with pytest.raises(ValueError, match=msg):
  235:             df.quantile(0.1, axis="column")
  236: 
  237:     def test_quantile_interpolation(self):
  238:         # see gh-10174
  239: 
  240:         # interpolation method other than default linear
  241:         df = DataFrame({"A": [1, 2, 3], "B": [2, 3, 4]}, index=[1, 2, 3])
  242:         result = df.quantile(0.5, axis=1, interpolation="nearest")
  243:         expected = Series([1, 2, 3], index=[1, 2, 3], name=0.5)
  244:         tm.assert_series_equal(result, expected)
  245: 
  246:         # cross-check interpolation=nearest results in original dtype
  247:         exp = np.percentile(
  248:             np.array([[1, 2, 3], [2, 3, 4]]),
  249:             0.5,
  250:             axis=0,
  251:             method="nearest",
  252:         )
  253:         expected = Series(exp, index=[1, 2, 3], name=0.5, dtype="int64")
  254:         tm.assert_series_equal(result, expected)
  255: 
  256:         # float
  257:         df = DataFrame({"A": [1.0, 2.0, 3.0], "B": [2.0, 3.0, 4.0]}, index=[1, 2, 3])
  258:         result = df.quantile(0.5, axis=1, interpolation="nearest")
  259:         expected = Series([1.0, 2.0, 3.0], index=[1, 2, 3], name=0.5)
  260:         tm.assert_series_equal(result, expected)
  261:         exp = np.percentile(
  262:             np.array([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0]]),
  263:             0.5,
  264:             axis=0,
  265:             method="nearest",
  266:         )
  267:         expected = Series(exp, index=[1, 2, 3], name=0.5, dtype="float64")
  268:         tm.assert_series_equal(result, expected)
  269: 
  270:         # axis
  271:         result = df.quantile([0.5, 0.75], axis=1, interpolation="lower")
  272:         expected = DataFrame(
  273:             {1: [1.0, 1.0], 2: [2.0, 2.0], 3: [3.0, 3.0]}, index=[0.5, 0.75]
  274:         )
  275:         tm.assert_frame_equal(result, expected)
  276: 
  277:         # test degenerate case
  278:         df = DataFrame({"x": [], "y": []})
  279:         q = df.quantile(0.1, axis=0, interpolation="higher")
  280:         assert np.isnan(q["x"]) and np.isnan(q["y"])
  281: 
  282:         # multi
  283:         df = DataFrame([[1, 1, 1], [2, 2, 2], [3, 3, 3]], columns=["a", "b", "c"])
  284:         result = df.quantile([0.25, 0.5], interpolation="midpoint")
  285: 
  286:         # https://github.com/numpy/numpy/issues/7163
  287:         expected = DataFrame(
  288:             [[1.5, 1.5, 1.5], [2.0, 2.0, 2.0]],
  289:             index=[0.25, 0.5],
  290:             columns=["a", "b", "c"],
  291:         )
  292:         tm.assert_frame_equal(result, expected)
  293: 
  294:     def test_quantile_interpolation_datetime(self, datetime_frame):
  295:         # see gh-10174
  296: 
  297:         # interpolation = linear (default case)
  298:         df = datetime_frame
  299:         q = df.quantile(0.1, axis=0, numeric_only=True, interpolation="linear")
  300:         assert q["A"] == np.percentile(df["A"], 10)
  301: 
  302:     def test_quantile_interpolation_int(self, int_frame):
  303:         # see gh-10174
  304: 
  305:         df = int_frame
  306:         # interpolation = linear (default case)
  307:         q = df.quantile(0.1)
  308:         assert q["A"] == np.percentile(df["A"], 10)
  309: 
  310:         # test with and without interpolation keyword
  311:         q1 = df.quantile(0.1, axis=0, interpolation="linear")
  312:         assert q1["A"] == np.percentile(df["A"], 10)
  313:         tm.assert_series_equal(q, q1)
  314: 
  315:     def test_quantile_multi(self, interp_method, request, using_array_manager):
  316:         interpolation, method = interp_method
  317:         df = DataFrame([[1, 1, 1], [2, 2, 2], [3, 3, 3]], columns=["a", "b", "c"])
  318:         result = df.quantile([0.25, 0.5], interpolation=interpolation, method=method)
  319:         expected = DataFrame(
  320:             [[1.5, 1.5, 1.5], [2.0, 2.0, 2.0]],
  321:             index=[0.25, 0.5],
  322:             columns=["a", "b", "c"],
  323:         )
  324:         if interpolation == "nearest":
  325:             expected = expected.astype(np.int64)
  326:         if method == "table" and using_array_manager:
  327:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  328:         tm.assert_frame_equal(result, expected)
  329: 
  330:     def test_quantile_multi_axis_1(self, interp_method, request, using_array_manager):
  331:         interpolation, method = interp_method
  332:         df = DataFrame([[1, 1, 1], [2, 2, 2], [3, 3, 3]], columns=["a", "b", "c"])
  333:         result = df.quantile(
  334:             [0.25, 0.5], axis=1, interpolation=interpolation, method=method
  335:         )
  336:         expected = DataFrame(
  337:             [[1.0, 2.0, 3.0]] * 2, index=[0.25, 0.5], columns=[0, 1, 2]
  338:         )
  339:         if interpolation == "nearest":
  340:             expected = expected.astype(np.int64)
  341:         if method == "table" and using_array_manager:
  342:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  343:         tm.assert_frame_equal(result, expected)
  344: 
  345:     def test_quantile_multi_empty(self, interp_method):
  346:         interpolation, method = interp_method
  347:         result = DataFrame({"x": [], "y": []}).quantile(
  348:             [0.1, 0.9], axis=0, interpolation=interpolation, method=method
  349:         )
  350:         expected = DataFrame(
  351:             {"x": [np.nan, np.nan], "y": [np.nan, np.nan]}, index=[0.1, 0.9]
  352:         )
  353:         tm.assert_frame_equal(result, expected)
  354: 
  355:     def test_quantile_datetime(self, unit):
  356:         dti = pd.to_datetime(["2010", "2011"]).as_unit(unit)
  357:         df = DataFrame({"a": dti, "b": [0, 5]})
  358: 
  359:         # exclude datetime
  360:         result = df.quantile(0.5, numeric_only=True)
  361:         expected = Series([2.5], index=["b"], name=0.5)
  362:         tm.assert_series_equal(result, expected)
  363: 
  364:         # datetime
  365:         result = df.quantile(0.5, numeric_only=False)
  366:         expected = Series(
  367:             [Timestamp("2010-07-02 12:00:00"), 2.5], index=["a", "b"], name=0.5
  368:         )
  369:         tm.assert_series_equal(result, expected)
  370: 
  371:         # datetime w/ multi
  372:         result = df.quantile([0.5], numeric_only=False)
  373:         expected = DataFrame(
  374:             {"a": Timestamp("2010-07-02 12:00:00").as_unit(unit), "b": 2.5},
  375:             index=[0.5],
  376:         )
  377:         tm.assert_frame_equal(result, expected)
  378: 
  379:         # axis = 1
  380:         df["c"] = pd.to_datetime(["2011", "2012"]).as_unit(unit)
  381:         result = df[["a", "c"]].quantile(0.5, axis=1, numeric_only=False)
  382:         expected = Series(
  383:             [Timestamp("2010-07-02 12:00:00"), Timestamp("2011-07-02 12:00:00")],
  384:             index=[0, 1],
  385:             name=0.5,
  386:             dtype=f"M8[{unit}]",
  387:         )
  388:         tm.assert_series_equal(result, expected)
  389: 
  390:         result = df[["a", "c"]].quantile([0.5], axis=1, numeric_only=False)
  391:         expected = DataFrame(
  392:             [[Timestamp("2010-07-02 12:00:00"), Timestamp("2011-07-02 12:00:00")]],
  393:             index=[0.5],
  394:             columns=[0, 1],
  395:             dtype=f"M8[{unit}]",
  396:         )
  397:         tm.assert_frame_equal(result, expected)
  398: 
  399:         # empty when numeric_only=True
  400:         result = df[["a", "c"]].quantile(0.5, numeric_only=True)
  401:         expected = Series([], index=[], dtype=np.float64, name=0.5)
  402:         tm.assert_series_equal(result, expected)
  403: 
  404:         result = df[["a", "c"]].quantile([0.5], numeric_only=True)
  405:         expected = DataFrame(index=[0.5], columns=[])
  406:         tm.assert_frame_equal(result, expected)
  407: 
  408:     @pytest.mark.parametrize(
  409:         "dtype",
  410:         [
  411:             "datetime64[ns]",
  412:             "datetime64[ns, US/Pacific]",
  413:             "timedelta64[ns]",
  414:             "Period[D]",
  415:         ],
  416:     )
  417:     def test_quantile_dt64_empty(self, dtype, interp_method):
  418:         # GH#41544
  419:         interpolation, method = interp_method
  420:         df = DataFrame(columns=["a", "b"], dtype=dtype)
  421: 
  422:         res = df.quantile(
  423:             0.5, axis=1, numeric_only=False, interpolation=interpolation, method=method
  424:         )
  425:         expected = Series([], index=[], name=0.5, dtype=dtype)
  426:         tm.assert_series_equal(res, expected)
  427: 
  428:         # no columns in result, so no dtype preservation
  429:         res = df.quantile(
  430:             [0.5],
  431:             axis=1,
  432:             numeric_only=False,
  433:             interpolation=interpolation,
  434:             method=method,
  435:         )
  436:         expected = DataFrame(index=[0.5], columns=[])
  437:         tm.assert_frame_equal(res, expected)
  438: 
  439:     @pytest.mark.parametrize("invalid", [-1, 2, [0.5, -1], [0.5, 2]])
  440:     def test_quantile_invalid(self, invalid, datetime_frame, interp_method):
  441:         msg = "percentiles should all be in the interval \\[0, 1\\]"
  442:         interpolation, method = interp_method
  443:         with pytest.raises(ValueError, match=msg):
  444:             datetime_frame.quantile(invalid, interpolation=interpolation, method=method)
  445: 
  446:     def test_quantile_box(self, interp_method, request, using_array_manager):
  447:         interpolation, method = interp_method
  448:         if method == "table" and using_array_manager:
  449:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  450:         df = DataFrame(
  451:             {
  452:                 "A": [
  453:                     Timestamp("2011-01-01"),
  454:                     Timestamp("2011-01-02"),
  455:                     Timestamp("2011-01-03"),
  456:                 ],
  457:                 "B": [
  458:                     Timestamp("2011-01-01", tz="US/Eastern"),
  459:                     Timestamp("2011-01-02", tz="US/Eastern"),
  460:                     Timestamp("2011-01-03", tz="US/Eastern"),
  461:                 ],
  462:                 "C": [
  463:                     pd.Timedelta("1 days"),
  464:                     pd.Timedelta("2 days"),
  465:                     pd.Timedelta("3 days"),
  466:                 ],
  467:             }
  468:         )
  469: 
  470:         res = df.quantile(
  471:             0.5, numeric_only=False, interpolation=interpolation, method=method
  472:         )
  473: 
  474:         exp = Series(
  475:             [
  476:                 Timestamp("2011-01-02"),
  477:                 Timestamp("2011-01-02", tz="US/Eastern"),
  478:                 pd.Timedelta("2 days"),
  479:             ],
  480:             name=0.5,
  481:             index=["A", "B", "C"],
  482:         )
  483:         tm.assert_series_equal(res, exp)
  484: 
  485:         res = df.quantile(
  486:             [0.5], numeric_only=False, interpolation=interpolation, method=method
  487:         )
  488:         exp = DataFrame(
  489:             [
  490:                 [
  491:                     Timestamp("2011-01-02"),
  492:                     Timestamp("2011-01-02", tz="US/Eastern"),
  493:                     pd.Timedelta("2 days"),
  494:                 ]
  495:             ],
  496:             index=[0.5],
  497:             columns=["A", "B", "C"],
  498:         )
  499:         tm.assert_frame_equal(res, exp)
  500: 
  501:     def test_quantile_box_nat(self):
  502:         # DatetimeLikeBlock may be consolidated and contain NaT in different loc
  503:         df = DataFrame(
  504:             {
  505:                 "A": [
  506:                     Timestamp("2011-01-01"),
  507:                     pd.NaT,
  508:                     Timestamp("2011-01-02"),
  509:                     Timestamp("2011-01-03"),
  510:                 ],
  511:                 "a": [
  512:                     Timestamp("2011-01-01"),
  513:                     Timestamp("2011-01-02"),
  514:                     pd.NaT,
  515:                     Timestamp("2011-01-03"),
  516:                 ],
  517:                 "B": [
  518:                     Timestamp("2011-01-01", tz="US/Eastern"),
  519:                     pd.NaT,
  520:                     Timestamp("2011-01-02", tz="US/Eastern"),
  521:                     Timestamp("2011-01-03", tz="US/Eastern"),
  522:                 ],
  523:                 "b": [
  524:                     Timestamp("2011-01-01", tz="US/Eastern"),
  525:                     Timestamp("2011-01-02", tz="US/Eastern"),
  526:                     pd.NaT,
  527:                     Timestamp("2011-01-03", tz="US/Eastern"),
  528:                 ],
  529:                 "C": [
  530:                     pd.Timedelta("1 days"),
  531:                     pd.Timedelta("2 days"),
  532:                     pd.Timedelta("3 days"),
  533:                     pd.NaT,
  534:                 ],
  535:                 "c": [
  536:                     pd.NaT,
  537:                     pd.Timedelta("1 days"),
  538:                     pd.Timedelta("2 days"),
  539:                     pd.Timedelta("3 days"),
  540:                 ],
  541:             },
  542:             columns=list("AaBbCc"),
  543:         )
  544: 
  545:         res = df.quantile(0.5, numeric_only=False)
  546:         exp = Series(
  547:             [
  548:                 Timestamp("2011-01-02"),
  549:                 Timestamp("2011-01-02"),
  550:                 Timestamp("2011-01-02", tz="US/Eastern"),
  551:                 Timestamp("2011-01-02", tz="US/Eastern"),
  552:                 pd.Timedelta("2 days"),
  553:                 pd.Timedelta("2 days"),
  554:             ],
  555:             name=0.5,
  556:             index=list("AaBbCc"),
  557:         )
  558:         tm.assert_series_equal(res, exp)
  559: 
  560:         res = df.quantile([0.5], numeric_only=False)
  561:         exp = DataFrame(
  562:             [
  563:                 [
  564:                     Timestamp("2011-01-02"),
  565:                     Timestamp("2011-01-02"),
  566:                     Timestamp("2011-01-02", tz="US/Eastern"),
  567:                     Timestamp("2011-01-02", tz="US/Eastern"),
  568:                     pd.Timedelta("2 days"),
  569:                     pd.Timedelta("2 days"),
  570:                 ]
  571:             ],
  572:             index=[0.5],
  573:             columns=list("AaBbCc"),
  574:         )
  575:         tm.assert_frame_equal(res, exp)
  576: 
  577:     def test_quantile_nan(self, interp_method, request, using_array_manager):
  578:         interpolation, method = interp_method
  579:         if method == "table" and using_array_manager:
  580:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  581:         # GH 14357 - float block where some cols have missing values
  582:         df = DataFrame({"a": np.arange(1, 6.0), "b": np.arange(1, 6.0)})
  583:         df.iloc[-1, 1] = np.nan
  584: 
  585:         res = df.quantile(0.5, interpolation=interpolation, method=method)
  586:         exp = Series(
  587:             [3.0, 2.5 if interpolation == "linear" else 3.0], index=["a", "b"], name=0.5
  588:         )
  589:         tm.assert_series_equal(res, exp)
  590: 
  591:         res = df.quantile([0.5, 0.75], interpolation=interpolation, method=method)
  592:         exp = DataFrame(
  593:             {
  594:                 "a": [3.0, 4.0],
  595:                 "b": [2.5, 3.25] if interpolation == "linear" else [3.0, 4.0],
  596:             },
  597:             index=[0.5, 0.75],
  598:         )
  599:         tm.assert_frame_equal(res, exp)
  600: 
  601:         res = df.quantile(0.5, axis=1, interpolation=interpolation, method=method)
  602:         exp = Series(np.arange(1.0, 6.0), name=0.5)
  603:         tm.assert_series_equal(res, exp)
  604: 
  605:         res = df.quantile(
  606:             [0.5, 0.75], axis=1, interpolation=interpolation, method=method
  607:         )
  608:         exp = DataFrame([np.arange(1.0, 6.0)] * 2, index=[0.5, 0.75])
  609:         if interpolation == "nearest":
  610:             exp.iloc[1, -1] = np.nan
  611:         tm.assert_frame_equal(res, exp)
  612: 
  613:         # full-nan column
  614:         df["b"] = np.nan
  615: 
  616:         res = df.quantile(0.5, interpolation=interpolation, method=method)
  617:         exp = Series([3.0, np.nan], index=["a", "b"], name=0.5)
  618:         tm.assert_series_equal(res, exp)
  619: 
  620:         res = df.quantile([0.5, 0.75], interpolation=interpolation, method=method)
  621:         exp = DataFrame({"a": [3.0, 4.0], "b": [np.nan, np.nan]}, index=[0.5, 0.75])
  622:         tm.assert_frame_equal(res, exp)
  623: 
  624:     def test_quantile_nat(self, interp_method, request, using_array_manager, unit):
  625:         interpolation, method = interp_method
  626:         if method == "table" and using_array_manager:
  627:             request.applymarker(pytest.mark.xfail(reason="Axis name incorrectly set."))
  628:         # full NaT column
  629:         df = DataFrame({"a": [pd.NaT, pd.NaT, pd.NaT]}, dtype=f"M8[{unit}]")
  630: 
  631:         res = df.quantile(
  632:             0.5, numeric_only=False, interpolation=interpolation, method=method
  633:         )
  634:         exp = Series([pd.NaT], index=["a"], name=0.5, dtype=f"M8[{unit}]")
  635:         tm.assert_series_equal(res, exp)
  636: 
  637:         res = df.quantile(
  638:             [0.5], numeric_only=False, interpolation=interpolation, method=method
  639:         )
  640:         exp = DataFrame({"a": [pd.NaT]}, index=[0.5], dtype=f"M8[{unit}]")
  641:         tm.assert_frame_equal(res, exp)
  642: 
  643:         # mixed non-null / full null column
  644:         df = DataFrame(
  645:             {
  646:                 "a": [
  647:                     Timestamp("2012-01-01"),
  648:                     Timestamp("2012-01-02"),
  649:                     Timestamp("2012-01-03"),
  650:                 ],
  651:                 "b": [pd.NaT, pd.NaT, pd.NaT],
  652:             },
  653:             dtype=f"M8[{unit}]",
  654:         )
  655: 
  656:         res = df.quantile(
  657:             0.5, numeric_only=False, interpolation=interpolation, method=method
  658:         )
  659:         exp = Series(
  660:             [Timestamp("2012-01-02"), pd.NaT],
  661:             index=["a", "b"],
  662:             name=0.5,
  663:             dtype=f"M8[{unit}]",
  664:         )
  665:         tm.assert_series_equal(res, exp)
  666: 
  667:         res = df.quantile(
  668:             [0.5], numeric_only=False, interpolation=interpolation, method=method
  669:         )
  670:         exp = DataFrame(
  671:             [[Timestamp("2012-01-02"), pd.NaT]],
  672:             index=[0.5],
  673:             columns=["a", "b"],
  674:             dtype=f"M8[{unit}]",
  675:         )
  676:         tm.assert_frame_equal(res, exp)
  677: 
  678:     def test_quantile_empty_no_rows_floats(self, interp_method):
  679:         interpolation, method = interp_method
  680: 
  681:         df = DataFrame(columns=["a", "b"], dtype="float64")
  682: 
  683:         res = df.quantile(0.5, interpolation=interpolation, method=method)
  684:         exp = Series([np.nan, np.nan], index=["a", "b"], name=0.5)
  685:         tm.assert_series_equal(res, exp)
  686: 
  687:         res = df.quantile([0.5], interpolation=interpolation, method=method)
  688:         exp = DataFrame([[np.nan, np.nan]], columns=["a", "b"], index=[0.5])
  689:         tm.assert_frame_equal(res, exp)
  690: 
  691:         res = df.quantile(0.5, axis=1, interpolation=interpolation, method=method)
  692:         exp = Series([], index=[], dtype="float64", name=0.5)
  693:         tm.assert_series_equal(res, exp)
  694: 
  695:         res = df.quantile([0.5], axis=1, interpolation=interpolation, method=method)
  696:         exp = DataFrame(columns=[], index=[0.5])
  697:         tm.assert_frame_equal(res, exp)
  698: 
  699:     def test_quantile_empty_no_rows_ints(self, interp_method):
  700:         interpolation, method = interp_method
  701:         df = DataFrame(columns=["a", "b"], dtype="int64")
  702: 
  703:         res = df.quantile(0.5, interpolation=interpolation, method=method)
  704:         exp = Series([np.nan, np.nan], index=["a", "b"], name=0.5)
  705:         tm.assert_series_equal(res, exp)
  706: 
  707:     def test_quantile_empty_no_rows_dt64(self, interp_method):
  708:         interpolation, method = interp_method
  709:         # datetimes
  710:         df = DataFrame(columns=["a", "b"], dtype="datetime64[ns]")
  711: 
  712:         res = df.quantile(
  713:             0.5, numeric_only=False, interpolation=interpolation, method=method
  714:         )
  715:         exp = Series(
  716:             [pd.NaT, pd.NaT], index=["a", "b"], dtype="datetime64[ns]", name=0.5
  717:         )
  718:         tm.assert_series_equal(res, exp)
  719: 
  720:         # Mixed dt64/dt64tz
  721:         df["a"] = df["a"].dt.tz_localize("US/Central")
  722:         res = df.quantile(
  723:             0.5, numeric_only=False, interpolation=interpolation, method=method
  724:         )
  725:         exp = exp.astype(object)
  726:         if interpolation == "nearest":
  727:             # GH#18463 TODO: would we prefer NaTs here?
  728:             msg = "The 'downcast' keyword in fillna is deprecated"
  729:             with tm.assert_produces_warning(FutureWarning, match=msg):
  730:                 exp = exp.fillna(np.nan, downcast=False)
  731:         tm.assert_series_equal(res, exp)
  732: 
  733:         # both dt64tz
  734:         df["b"] = df["b"].dt.tz_localize("US/Central")
  735:         res = df.quantile(
  736:             0.5, numeric_only=False, interpolation=interpolation, method=method
  737:         )
  738:         exp = exp.astype(df["b"].dtype)
  739:         tm.assert_series_equal(res, exp)
  740: 
  741:     def test_quantile_empty_no_columns(self, interp_method):
  742:         # GH#23925 _get_numeric_data may drop all columns
  743:         interpolation, method = interp_method
  744:         df = DataFrame(pd.date_range("1/1/18", periods=5))
  745:         df.columns.name = "captain tightpants"
  746:         result = df.quantile(
  747:             0.5, numeric_only=True, interpolation=interpolation, method=method
  748:         )
  749:         expected = Series([], index=[], name=0.5, dtype=np.float64)
  750:         expected.index.name = "captain tightpants"
  751:         tm.assert_series_equal(result, expected)
  752: 
  753:         result = df.quantile(
  754:             [0.5], numeric_only=True, interpolation=interpolation, method=method
  755:         )
  756:         expected = DataFrame([], index=[0.5], columns=[])
  757:         expected.columns.name = "captain tightpants"
  758:         tm.assert_frame_equal(result, expected)
  759: 
  760:     def test_quantile_item_cache(
  761:         self, using_array_manager, interp_method, using_copy_on_write
  762:     ):
  763:         # previous behavior incorrect retained an invalid _item_cache entry
  764:         interpolation, method = interp_method
  765:         df = DataFrame(
  766:             np.random.default_rng(2).standard_normal((4, 3)), columns=["A", "B", "C"]
  767:         )
  768:         df["D"] = df["A"] * 2
  769:         ser = df["A"]
  770:         if not using_array_manager:
  771:             assert len(df._mgr.blocks) == 2
  772: 
  773:         df.quantile(numeric_only=False, interpolation=interpolation, method=method)
  774: 
  775:         if using_copy_on_write:
  776:             ser.iloc[0] = 99
  777:             assert df.iloc[0, 0] == df["A"][0]
  778:             assert df.iloc[0, 0] != 99
  779:         else:
  780:             ser.values[0] = 99
  781:             assert df.iloc[0, 0] == df["A"][0]
  782:             assert df.iloc[0, 0] == 99
  783: 
  784:     def test_invalid_method(self):
  785:         with pytest.raises(ValueError, match="Invalid method: foo"):
  786:             DataFrame(range(1)).quantile(0.5, method="foo")
  787: 
  788:     def test_table_invalid_interpolation(self):
  789:         with pytest.raises(ValueError, match="Invalid interpolation: foo"):
  790:             DataFrame(range(1)).quantile(0.5, method="table", interpolation="foo")
  791: 
  792: 
  793: class TestQuantileExtensionDtype:
  794:     # TODO: tests for axis=1?
  795:     # TODO: empty case?
  796: 
  797:     @pytest.fixture(
  798:         params=[
  799:             pytest.param(
  800:                 pd.IntervalIndex.from_breaks(range(10)),
  801:                 marks=pytest.mark.xfail(reason="raises when trying to add Intervals"),
  802:             ),
  803:             pd.period_range("2016-01-01", periods=9, freq="D"),
  804:             pd.date_range("2016-01-01", periods=9, tz="US/Pacific"),
  805:             pd.timedelta_range("1 Day", periods=9),
  806:             pd.array(np.arange(9), dtype="Int64"),
  807:             pd.array(np.arange(9), dtype="Float64"),
  808:         ],
  809:         ids=lambda x: str(x.dtype),
  810:     )
  811:     def index(self, request):
  812:         # NB: not actually an Index object
  813:         idx = request.param
  814:         idx.name = "A"
  815:         return idx
  816: 
  817:     @pytest.fixture
  818:     def obj(self, index, frame_or_series):
  819:         # bc index is not always an Index (yet), we need to re-patch .name
  820:         obj = frame_or_series(index).copy()
  821: 
  822:         if frame_or_series is Series:
  823:             obj.name = "A"
  824:         else:
  825:             obj.columns = ["A"]
  826:         return obj
  827: 
  828:     def compute_quantile(self, obj, qs):
  829:         if isinstance(obj, Series):
  830:             result = obj.quantile(qs)
  831:         else:
  832:             result = obj.quantile(qs, numeric_only=False)
  833:         return result
  834: 
  835:     def test_quantile_ea(self, request, obj, index):
  836:         # result should be invariant to shuffling
  837:         indexer = np.arange(len(index), dtype=np.intp)
  838:         np.random.default_rng(2).shuffle(indexer)
  839:         obj = obj.iloc[indexer]
  840: 
  841:         qs = [0.5, 0, 1]
  842:         result = self.compute_quantile(obj, qs)
  843: 
  844:         exp_dtype = index.dtype
  845:         if index.dtype == "Int64":
  846:             # match non-nullable casting behavior
  847:             exp_dtype = "Float64"
  848: 
  849:         # expected here assumes len(index) == 9
  850:         expected = Series(
  851:             [index[4], index[0], index[-1]], dtype=exp_dtype, index=qs, name="A"
  852:         )
  853:         expected = type(obj)(expected)
  854: 
  855:         tm.assert_equal(result, expected)
  856: 
  857:     def test_quantile_ea_with_na(self, obj, index):
  858:         obj.iloc[0] = index._na_value
  859:         obj.iloc[-1] = index._na_value
  860: 
  861:         # result should be invariant to shuffling
  862:         indexer = np.arange(len(index), dtype=np.intp)
  863:         np.random.default_rng(2).shuffle(indexer)
  864:         obj = obj.iloc[indexer]
  865: 
  866:         qs = [0.5, 0, 1]
  867:         result = self.compute_quantile(obj, qs)
  868: 
  869:         # expected here assumes len(index) == 9
  870:         expected = Series(
  871:             [index[4], index[1], index[-2]], dtype=index.dtype, index=qs, name="A"
  872:         )
  873:         expected = type(obj)(expected)
  874:         tm.assert_equal(result, expected)
  875: 
  876:     def test_quantile_ea_all_na(self, request, obj, index):
  877:         obj.iloc[:] = index._na_value
  878:         # Check dtypes were preserved; this was once a problem see GH#39763
  879:         assert np.all(obj.dtypes == index.dtype)
  880: 
  881:         # result should be invariant to shuffling
  882:         indexer = np.arange(len(index), dtype=np.intp)
  883:         np.random.default_rng(2).shuffle(indexer)
  884:         obj = obj.iloc[indexer]
  885: 
  886:         qs = [0.5, 0, 1]
  887:         result = self.compute_quantile(obj, qs)
  888: 
  889:         expected = index.take([-1, -1, -1], allow_fill=True, fill_value=index._na_value)
  890:         expected = Series(expected, index=qs, name="A")
  891:         expected = type(obj)(expected)
  892:         tm.assert_equal(result, expected)
  893: 
  894:     def test_quantile_ea_scalar(self, request, obj, index):
  895:         # scalar qs
  896: 
  897:         # result should be invariant to shuffling
  898:         indexer = np.arange(len(index), dtype=np.intp)
  899:         np.random.default_rng(2).shuffle(indexer)
  900:         obj = obj.iloc[indexer]
  901: 
  902:         qs = 0.5
  903:         result = self.compute_quantile(obj, qs)
  904: 
  905:         exp_dtype = index.dtype
  906:         if index.dtype == "Int64":
  907:             exp_dtype = "Float64"
  908: 
  909:         expected = Series({"A": index[4]}, dtype=exp_dtype, name=0.5)
  910:         if isinstance(obj, Series):
  911:             expected = expected["A"]
  912:             assert result == expected
  913:         else:
  914:             tm.assert_series_equal(result, expected)
  915: 
  916:     @pytest.mark.parametrize(
  917:         "dtype, expected_data, expected_index, axis",
  918:         [
  919:             ["float64", [], [], 1],
  920:             ["int64", [], [], 1],
  921:             ["float64", [np.nan, np.nan], ["a", "b"], 0],
  922:             ["int64", [np.nan, np.nan], ["a", "b"], 0],
  923:         ],
  924:     )
  925:     def test_empty_numeric(self, dtype, expected_data, expected_index, axis):
  926:         # GH 14564
  927:         df = DataFrame(columns=["a", "b"], dtype=dtype)
  928:         result = df.quantile(0.5, axis=axis)
  929:         expected = Series(
  930:             expected_data, name=0.5, index=Index(expected_index), dtype="float64"
  931:         )
  932:         tm.assert_series_equal(result, expected)
  933: 
  934:     @pytest.mark.parametrize(
  935:         "dtype, expected_data, expected_index, axis, expected_dtype",
  936:         [
  937:             ["datetime64[ns]", [], [], 1, "datetime64[ns]"],
  938:             ["datetime64[ns]", [pd.NaT, pd.NaT], ["a", "b"], 0, "datetime64[ns]"],
  939:         ],
  940:     )
  941:     def test_empty_datelike(
  942:         self, dtype, expected_data, expected_index, axis, expected_dtype
  943:     ):
  944:         # GH 14564
  945:         df = DataFrame(columns=["a", "b"], dtype=dtype)
  946:         result = df.quantile(0.5, axis=axis, numeric_only=False)
  947:         expected = Series(
  948:             expected_data, name=0.5, index=Index(expected_index), dtype=expected_dtype
  949:         )
  950:         tm.assert_series_equal(result, expected)
  951: 
  952:     @pytest.mark.parametrize(
  953:         "expected_data, expected_index, axis",
  954:         [
  955:             [[np.nan, np.nan], range(2), 1],
  956:             [[], [], 0],
  957:         ],
  958:     )
  959:     def test_datelike_numeric_only(self, expected_data, expected_index, axis):
  960:         # GH 14564
  961:         df = DataFrame(
  962:             {
  963:                 "a": pd.to_datetime(["2010", "2011"]),
  964:                 "b": [0, 5],
  965:                 "c": pd.to_datetime(["2011", "2012"]),
  966:             }
  967:         )
  968:         result = df[["a", "c"]].quantile(0.5, axis=axis, numeric_only=True)
  969:         expected = Series(
  970:             expected_data, name=0.5, index=Index(expected_index), dtype=np.float64
  971:         )
  972:         tm.assert_series_equal(result, expected)
