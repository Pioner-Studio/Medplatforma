    1: """
    2: See also: test_reindex.py:TestReindexSetIndex
    3: """
    4: 
    5: from datetime import (
    6:     datetime,
    7:     timedelta,
    8: )
    9: 
   10: import numpy as np
   11: import pytest
   12: 
   13: from pandas import (
   14:     Categorical,
   15:     CategoricalIndex,
   16:     DataFrame,
   17:     DatetimeIndex,
   18:     Index,
   19:     MultiIndex,
   20:     Series,
   21:     date_range,
   22:     period_range,
   23:     to_datetime,
   24: )
   25: import pandas._testing as tm
   26: 
   27: 
   28: @pytest.fixture
   29: def frame_of_index_cols():
   30:     """
   31:     Fixture for DataFrame of columns that can be used for indexing
   32: 
   33:     Columns are ['A', 'B', 'C', 'D', 'E', ('tuple', 'as', 'label')];
   34:     'A' & 'B' contain duplicates (but are jointly unique), the rest are unique.
   35: 
   36:          A      B  C         D         E  (tuple, as, label)
   37:     0  foo    one  a  0.608477 -0.012500           -1.664297
   38:     1  foo    two  b -0.633460  0.249614           -0.364411
   39:     2  foo  three  c  0.615256  2.154968           -0.834666
   40:     3  bar    one  d  0.234246  1.085675            0.718445
   41:     4  bar    two  e  0.533841 -0.005702           -3.533912
   42:     """
   43:     df = DataFrame(
   44:         {
   45:             "A": ["foo", "foo", "foo", "bar", "bar"],
   46:             "B": ["one", "two", "three", "one", "two"],
   47:             "C": ["a", "b", "c", "d", "e"],
   48:             "D": np.random.default_rng(2).standard_normal(5),
   49:             "E": np.random.default_rng(2).standard_normal(5),
   50:             ("tuple", "as", "label"): np.random.default_rng(2).standard_normal(5),
   51:         }
   52:     )
   53:     return df
   54: 
   55: 
   56: class TestSetIndex:
   57:     def test_set_index_multiindex(self):
   58:         # segfault in GH#3308
   59:         d = {"t1": [2, 2.5, 3], "t2": [4, 5, 6]}
   60:         df = DataFrame(d)
   61:         tuples = [(0, 1), (0, 2), (1, 2)]
   62:         df["tuples"] = tuples
   63: 
   64:         index = MultiIndex.from_tuples(df["tuples"])
   65:         # it works!
   66:         df.set_index(index)
   67: 
   68:     def test_set_index_empty_column(self):
   69:         # GH#1971
   70:         df = DataFrame(
   71:             [
   72:                 {"a": 1, "p": 0},
   73:                 {"a": 2, "m": 10},
   74:                 {"a": 3, "m": 11, "p": 20},
   75:                 {"a": 4, "m": 12, "p": 21},
   76:             ],
   77:             columns=["a", "m", "p", "x"],
   78:         )
   79: 
   80:         result = df.set_index(["a", "x"])
   81: 
   82:         expected = df[["m", "p"]]
   83:         expected.index = MultiIndex.from_arrays([df["a"], df["x"]], names=["a", "x"])
   84:         tm.assert_frame_equal(result, expected)
   85: 
   86:     def test_set_index_empty_dataframe(self):
   87:         # GH#38419
   88:         df1 = DataFrame(
   89:             {"a": Series(dtype="datetime64[ns]"), "b": Series(dtype="int64"), "c": []}
   90:         )
   91: 
   92:         df2 = df1.set_index(["a", "b"])
   93:         result = df2.index.to_frame().dtypes
   94:         expected = df1[["a", "b"]].dtypes
   95:         tm.assert_series_equal(result, expected)
   96: 
   97:     def test_set_index_multiindexcolumns(self):
   98:         columns = MultiIndex.from_tuples([("foo", 1), ("foo", 2), ("bar", 1)])
   99:         df = DataFrame(
  100:             np.random.default_rng(2).standard_normal((3, 3)), columns=columns
  101:         )
  102: 
  103:         result = df.set_index(df.columns[0])
  104: 
  105:         expected = df.iloc[:, 1:]
  106:         expected.index = df.iloc[:, 0].values
  107:         expected.index.names = [df.columns[0]]
  108:         tm.assert_frame_equal(result, expected)
  109: 
  110:     def test_set_index_timezone(self):
  111:         # GH#12358
  112:         # tz-aware Series should retain the tz
  113:         idx = DatetimeIndex(["2014-01-01 10:10:10"], tz="UTC").tz_convert("Europe/Rome")
  114:         df = DataFrame({"A": idx})
  115:         assert df.set_index(idx).index[0].hour == 11
  116:         assert DatetimeIndex(Series(df.A))[0].hour == 11
  117:         assert df.set_index(df.A).index[0].hour == 11
  118: 
  119:     def test_set_index_cast_datetimeindex(self):
  120:         df = DataFrame(
  121:             {
  122:                 "A": [datetime(2000, 1, 1) + timedelta(i) for i in range(1000)],
  123:                 "B": np.random.default_rng(2).standard_normal(1000),
  124:             }
  125:         )
  126: 
  127:         idf = df.set_index("A")
  128:         assert isinstance(idf.index, DatetimeIndex)
  129: 
  130:     def test_set_index_dst(self):
  131:         di = date_range("2006-10-29 00:00:00", periods=3, freq="h", tz="US/Pacific")
  132: 
  133:         df = DataFrame(data={"a": [0, 1, 2], "b": [3, 4, 5]}, index=di).reset_index()
  134:         # single level
  135:         res = df.set_index("index")
  136:         exp = DataFrame(
  137:             data={"a": [0, 1, 2], "b": [3, 4, 5]},
  138:             index=Index(di, name="index"),
  139:         )
  140:         exp.index = exp.index._with_freq(None)
  141:         tm.assert_frame_equal(res, exp)
  142: 
  143:         # GH#12920
  144:         res = df.set_index(["index", "a"])
  145:         exp_index = MultiIndex.from_arrays([di, [0, 1, 2]], names=["index", "a"])
  146:         exp = DataFrame({"b": [3, 4, 5]}, index=exp_index)
  147:         tm.assert_frame_equal(res, exp)
  148: 
  149:     def test_set_index(self, float_string_frame):
  150:         df = float_string_frame
  151:         idx = Index(np.arange(len(df))[::-1])
  152: 
  153:         df = df.set_index(idx)
  154:         tm.assert_index_equal(df.index, idx)
  155:         with pytest.raises(ValueError, match="Length mismatch"):
  156:             df.set_index(idx[::2])
  157: 
  158:     def test_set_index_names(self):
  159:         df = DataFrame(
  160:             np.ones((10, 4)),
  161:             columns=Index(list("ABCD"), dtype=object),
  162:             index=Index([f"i-{i}" for i in range(10)], dtype=object),
  163:         )
  164:         df.index.name = "name"
  165: 
  166:         assert df.set_index(df.index).index.names == ["name"]
  167: 
  168:         mi = MultiIndex.from_arrays(df[["A", "B"]].T.values, names=["A", "B"])
  169:         mi2 = MultiIndex.from_arrays(
  170:             df[["A", "B", "A", "B"]].T.values, names=["A", "B", "C", "D"]
  171:         )
  172: 
  173:         df = df.set_index(["A", "B"])
  174: 
  175:         assert df.set_index(df.index).index.names == ["A", "B"]
  176: 
  177:         # Check that set_index isn't converting a MultiIndex into an Index
  178:         assert isinstance(df.set_index(df.index).index, MultiIndex)
  179: 
  180:         # Check actual equality
  181:         tm.assert_index_equal(df.set_index(df.index).index, mi)
  182: 
  183:         idx2 = df.index.rename(["C", "D"])
  184: 
  185:         # Check that [MultiIndex, MultiIndex] yields a MultiIndex rather
  186:         # than a pair of tuples
  187:         assert isinstance(df.set_index([df.index, idx2]).index, MultiIndex)
  188: 
  189:         # Check equality
  190:         tm.assert_index_equal(df.set_index([df.index, idx2]).index, mi2)
  191: 
  192:     # A has duplicate values, C does not
  193:     @pytest.mark.parametrize("keys", ["A", "C", ["A", "B"], ("tuple", "as", "label")])
  194:     @pytest.mark.parametrize("inplace", [True, False])
  195:     @pytest.mark.parametrize("drop", [True, False])
  196:     def test_set_index_drop_inplace(self, frame_of_index_cols, drop, inplace, keys):
  197:         df = frame_of_index_cols
  198: 
  199:         if isinstance(keys, list):
  200:             idx = MultiIndex.from_arrays([df[x] for x in keys], names=keys)
  201:         else:
  202:             idx = Index(df[keys], name=keys)
  203:         expected = df.drop(keys, axis=1) if drop else df
  204:         expected.index = idx
  205: 
  206:         if inplace:
  207:             result = df.copy()
  208:             return_value = result.set_index(keys, drop=drop, inplace=True)
  209:             assert return_value is None
  210:         else:
  211:             result = df.set_index(keys, drop=drop)
  212: 
  213:         tm.assert_frame_equal(result, expected)
  214: 
  215:     # A has duplicate values, C does not
  216:     @pytest.mark.parametrize("keys", ["A", "C", ["A", "B"], ("tuple", "as", "label")])
  217:     @pytest.mark.parametrize("drop", [True, False])
  218:     def test_set_index_append(self, frame_of_index_cols, drop, keys):
  219:         df = frame_of_index_cols
  220: 
  221:         keys = keys if isinstance(keys, list) else [keys]
  222:         idx = MultiIndex.from_arrays(
  223:             [df.index] + [df[x] for x in keys], names=[None] + keys
  224:         )
  225:         expected = df.drop(keys, axis=1) if drop else df.copy()
  226:         expected.index = idx
  227: 
  228:         result = df.set_index(keys, drop=drop, append=True)
  229: 
  230:         tm.assert_frame_equal(result, expected)
  231: 
  232:     # A has duplicate values, C does not
  233:     @pytest.mark.parametrize("keys", ["A", "C", ["A", "B"], ("tuple", "as", "label")])
  234:     @pytest.mark.parametrize("drop", [True, False])
  235:     def test_set_index_append_to_multiindex(self, frame_of_index_cols, drop, keys):
  236:         # append to existing multiindex
  237:         df = frame_of_index_cols.set_index(["D"], drop=drop, append=True)
  238: 
  239:         keys = keys if isinstance(keys, list) else [keys]
  240:         expected = frame_of_index_cols.set_index(["D"] + keys, drop=drop, append=True)
  241: 
  242:         result = df.set_index(keys, drop=drop, append=True)
  243: 
  244:         tm.assert_frame_equal(result, expected)
  245: 
  246:     def test_set_index_after_mutation(self):
  247:         # GH#1590
  248:         df = DataFrame({"val": [0, 1, 2], "key": ["a", "b", "c"]})
  249:         expected = DataFrame({"val": [1, 2]}, Index(["b", "c"], name="key"))
  250: 
  251:         df2 = df.loc[df.index.map(lambda indx: indx >= 1)]
  252:         result = df2.set_index("key")
  253:         tm.assert_frame_equal(result, expected)
  254: 
  255:     # MultiIndex constructor does not work directly on Series -> lambda
  256:     # Add list-of-list constructor because list is ambiguous -> lambda
  257:     # also test index name if append=True (name is duplicate here for B)
  258:     @pytest.mark.parametrize(
  259:         "box",
  260:         [
  261:             Series,
  262:             Index,
  263:             np.array,
  264:             list,
  265:             lambda x: [list(x)],
  266:             lambda x: MultiIndex.from_arrays([x]),
  267:         ],
  268:     )
  269:     @pytest.mark.parametrize(
  270:         "append, index_name", [(True, None), (True, "B"), (True, "test"), (False, None)]
  271:     )
  272:     @pytest.mark.parametrize("drop", [True, False])
  273:     def test_set_index_pass_single_array(
  274:         self, frame_of_index_cols, drop, append, index_name, box
  275:     ):
  276:         df = frame_of_index_cols
  277:         df.index.name = index_name
  278: 
  279:         key = box(df["B"])
  280:         if box == list:
  281:             # list of strings gets interpreted as list of keys
  282:             msg = "['one', 'two', 'three', 'one', 'two']"
  283:             with pytest.raises(KeyError, match=msg):
  284:                 df.set_index(key, drop=drop, append=append)
  285:         else:
  286:             # np.array/list-of-list "forget" the name of B
  287:             name_mi = getattr(key, "names", None)
  288:             name = [getattr(key, "name", None)] if name_mi is None else name_mi
  289: 
  290:             result = df.set_index(key, drop=drop, append=append)
  291: 
  292:             # only valid column keys are dropped
  293:             # since B is always passed as array above, nothing is dropped
  294:             expected = df.set_index(["B"], drop=False, append=append)
  295:             expected.index.names = [index_name] + name if append else name
  296: 
  297:             tm.assert_frame_equal(result, expected)
  298: 
  299:     # MultiIndex constructor does not work directly on Series -> lambda
  300:     # also test index name if append=True (name is duplicate here for A & B)
  301:     @pytest.mark.parametrize(
  302:         "box", [Series, Index, np.array, list, lambda x: MultiIndex.from_arrays([x])]
  303:     )
  304:     @pytest.mark.parametrize(
  305:         "append, index_name",
  306:         [(True, None), (True, "A"), (True, "B"), (True, "test"), (False, None)],
  307:     )
  308:     @pytest.mark.parametrize("drop", [True, False])
  309:     def test_set_index_pass_arrays(
  310:         self, frame_of_index_cols, drop, append, index_name, box
  311:     ):
  312:         df = frame_of_index_cols
  313:         df.index.name = index_name
  314: 
  315:         keys = ["A", box(df["B"])]
  316:         # np.array/list "forget" the name of B
  317:         names = ["A", None if box in [np.array, list, tuple, iter] else "B"]
  318: 
  319:         result = df.set_index(keys, drop=drop, append=append)
  320: 
  321:         # only valid column keys are dropped
  322:         # since B is always passed as array above, only A is dropped, if at all
  323:         expected = df.set_index(["A", "B"], drop=False, append=append)
  324:         expected = expected.drop("A", axis=1) if drop else expected
  325:         expected.index.names = [index_name] + names if append else names
  326: 
  327:         tm.assert_frame_equal(result, expected)
  328: 
  329:     # MultiIndex constructor does not work directly on Series -> lambda
  330:     # We also emulate a "constructor" for the label -> lambda
  331:     # also test index name if append=True (name is duplicate here for A)
  332:     @pytest.mark.parametrize(
  333:         "box2",
  334:         [
  335:             Series,
  336:             Index,
  337:             np.array,
  338:             list,
  339:             iter,
  340:             lambda x: MultiIndex.from_arrays([x]),
  341:             lambda x: x.name,
  342:         ],
  343:     )
  344:     @pytest.mark.parametrize(
  345:         "box1",
  346:         [
  347:             Series,
  348:             Index,
  349:             np.array,
  350:             list,
  351:             iter,
  352:             lambda x: MultiIndex.from_arrays([x]),
  353:             lambda x: x.name,
  354:         ],
  355:     )
  356:     @pytest.mark.parametrize(
  357:         "append, index_name", [(True, None), (True, "A"), (True, "test"), (False, None)]
  358:     )
  359:     @pytest.mark.parametrize("drop", [True, False])
  360:     def test_set_index_pass_arrays_duplicate(
  361:         self, frame_of_index_cols, drop, append, index_name, box1, box2
  362:     ):
  363:         df = frame_of_index_cols
  364:         df.index.name = index_name
  365: 
  366:         keys = [box1(df["A"]), box2(df["A"])]
  367:         result = df.set_index(keys, drop=drop, append=append)
  368: 
  369:         # if either box is iter, it has been consumed; re-read
  370:         keys = [box1(df["A"]), box2(df["A"])]
  371: 
  372:         # need to adapt first drop for case that both keys are 'A' --
  373:         # cannot drop the same column twice;
  374:         # plain == would give ambiguous Boolean error for containers
  375:         first_drop = (
  376:             False
  377:             if (
  378:                 isinstance(keys[0], str)
  379:                 and keys[0] == "A"
  380:                 and isinstance(keys[1], str)
  381:                 and keys[1] == "A"
  382:             )
  383:             else drop
  384:         )
  385:         # to test against already-tested behaviour, we add sequentially,
  386:         # hence second append always True; must wrap keys in list, otherwise
  387:         # box = list would be interpreted as keys
  388:         expected = df.set_index([keys[0]], drop=first_drop, append=append)
  389:         expected = expected.set_index([keys[1]], drop=drop, append=True)
  390:         tm.assert_frame_equal(result, expected)
  391: 
  392:     @pytest.mark.parametrize("append", [True, False])
  393:     @pytest.mark.parametrize("drop", [True, False])
  394:     def test_set_index_pass_multiindex(self, frame_of_index_cols, drop, append):
  395:         df = frame_of_index_cols
  396:         keys = MultiIndex.from_arrays([df["A"], df["B"]], names=["A", "B"])
  397: 
  398:         result = df.set_index(keys, drop=drop, append=append)
  399: 
  400:         # setting with a MultiIndex will never drop columns
  401:         expected = df.set_index(["A", "B"], drop=False, append=append)
  402: 
  403:         tm.assert_frame_equal(result, expected)
  404: 
  405:     def test_construction_with_categorical_index(self):
  406:         ci = CategoricalIndex(list("ab") * 5, name="B")
  407: 
  408:         # with Categorical
  409:         df = DataFrame(
  410:             {"A": np.random.default_rng(2).standard_normal(10), "B": ci.values}
  411:         )
  412:         idf = df.set_index("B")
  413:         tm.assert_index_equal(idf.index, ci)
  414: 
  415:         # from a CategoricalIndex
  416:         df = DataFrame({"A": np.random.default_rng(2).standard_normal(10), "B": ci})
  417:         idf = df.set_index("B")
  418:         tm.assert_index_equal(idf.index, ci)
  419: 
  420:         # round-trip
  421:         idf = idf.reset_index().set_index("B")
  422:         tm.assert_index_equal(idf.index, ci)
  423: 
  424:     def test_set_index_preserve_categorical_dtype(self):
  425:         # GH#13743, GH#13854
  426:         df = DataFrame(
  427:             {
  428:                 "A": [1, 2, 1, 1, 2],
  429:                 "B": [10, 16, 22, 28, 34],
  430:                 "C1": Categorical(list("abaab"), categories=list("bac"), ordered=False),
  431:                 "C2": Categorical(list("abaab"), categories=list("bac"), ordered=True),
  432:             }
  433:         )
  434:         for cols in ["C1", "C2", ["A", "C1"], ["A", "C2"], ["C1", "C2"]]:
  435:             result = df.set_index(cols).reset_index()
  436:             result = result.reindex(columns=df.columns)
  437:             tm.assert_frame_equal(result, df)
  438: 
  439:     def test_set_index_datetime(self):
  440:         # GH#3950
  441:         df = DataFrame(
  442:             {
  443:                 "label": ["a", "a", "a", "b", "b", "b"],
  444:                 "datetime": [
  445:                     "2011-07-19 07:00:00",
  446:                     "2011-07-19 08:00:00",
  447:                     "2011-07-19 09:00:00",
  448:                     "2011-07-19 07:00:00",
  449:                     "2011-07-19 08:00:00",
  450:                     "2011-07-19 09:00:00",
  451:                 ],
  452:                 "value": range(6),
  453:             }
  454:         )
  455:         df.index = to_datetime(df.pop("datetime"), utc=True)
  456:         df.index = df.index.tz_convert("US/Pacific")
  457: 
  458:         expected = DatetimeIndex(
  459:             ["2011-07-19 07:00:00", "2011-07-19 08:00:00", "2011-07-19 09:00:00"],
  460:             name="datetime",
  461:         )
  462:         expected = expected.tz_localize("UTC").tz_convert("US/Pacific")
  463: 
  464:         df = df.set_index("label", append=True)
  465:         tm.assert_index_equal(df.index.levels[0], expected)
  466:         tm.assert_index_equal(df.index.levels[1], Index(["a", "b"], name="label"))
  467:         assert df.index.names == ["datetime", "label"]
  468: 
  469:         df = df.swaplevel(0, 1)
  470:         tm.assert_index_equal(df.index.levels[0], Index(["a", "b"], name="label"))
  471:         tm.assert_index_equal(df.index.levels[1], expected)
  472:         assert df.index.names == ["label", "datetime"]
  473: 
  474:         df = DataFrame(np.random.default_rng(2).random(6))
  475:         idx1 = DatetimeIndex(
  476:             [
  477:                 "2011-07-19 07:00:00",
  478:                 "2011-07-19 08:00:00",
  479:                 "2011-07-19 09:00:00",
  480:                 "2011-07-19 07:00:00",
  481:                 "2011-07-19 08:00:00",
  482:                 "2011-07-19 09:00:00",
  483:             ],
  484:             tz="US/Eastern",
  485:         )
  486:         idx2 = DatetimeIndex(
  487:             [
  488:                 "2012-04-01 09:00",
  489:                 "2012-04-01 09:00",
  490:                 "2012-04-01 09:00",
  491:                 "2012-04-02 09:00",
  492:                 "2012-04-02 09:00",
  493:                 "2012-04-02 09:00",
  494:             ],
  495:             tz="US/Eastern",
  496:         )
  497:         idx3 = date_range("2011-01-01 09:00", periods=6, tz="Asia/Tokyo")
  498:         idx3 = idx3._with_freq(None)
  499: 
  500:         df = df.set_index(idx1)
  501:         df = df.set_index(idx2, append=True)
  502:         df = df.set_index(idx3, append=True)
  503: 
  504:         expected1 = DatetimeIndex(
  505:             ["2011-07-19 07:00:00", "2011-07-19 08:00:00", "2011-07-19 09:00:00"],
  506:             tz="US/Eastern",
  507:         )
  508:         expected2 = DatetimeIndex(
  509:             ["2012-04-01 09:00", "2012-04-02 09:00"], tz="US/Eastern"
  510:         )
  511: 
  512:         tm.assert_index_equal(df.index.levels[0], expected1)
  513:         tm.assert_index_equal(df.index.levels[1], expected2)
  514:         tm.assert_index_equal(df.index.levels[2], idx3)
  515: 
  516:         # GH#7092
  517:         tm.assert_index_equal(df.index.get_level_values(0), idx1)
  518:         tm.assert_index_equal(df.index.get_level_values(1), idx2)
  519:         tm.assert_index_equal(df.index.get_level_values(2), idx3)
  520: 
  521:     def test_set_index_period(self):
  522:         # GH#6631
  523:         df = DataFrame(np.random.default_rng(2).random(6))
  524:         idx1 = period_range("2011-01-01", periods=3, freq="M")
  525:         idx1 = idx1.append(idx1)
  526:         idx2 = period_range("2013-01-01 09:00", periods=2, freq="h")
  527:         idx2 = idx2.append(idx2).append(idx2)
  528:         idx3 = period_range("2005", periods=6, freq="Y")
  529: 
  530:         df = df.set_index(idx1)
  531:         df = df.set_index(idx2, append=True)
  532:         df = df.set_index(idx3, append=True)
  533: 
  534:         expected1 = period_range("2011-01-01", periods=3, freq="M")
  535:         expected2 = period_range("2013-01-01 09:00", periods=2, freq="h")
  536: 
  537:         tm.assert_index_equal(df.index.levels[0], expected1)
  538:         tm.assert_index_equal(df.index.levels[1], expected2)
  539:         tm.assert_index_equal(df.index.levels[2], idx3)
  540: 
  541:         tm.assert_index_equal(df.index.get_level_values(0), idx1)
  542:         tm.assert_index_equal(df.index.get_level_values(1), idx2)
  543:         tm.assert_index_equal(df.index.get_level_values(2), idx3)
  544: 
  545: 
  546: class TestSetIndexInvalid:
  547:     def test_set_index_verify_integrity(self, frame_of_index_cols):
  548:         df = frame_of_index_cols
  549: 
  550:         with pytest.raises(ValueError, match="Index has duplicate keys"):
  551:             df.set_index("A", verify_integrity=True)
  552:         # with MultiIndex
  553:         with pytest.raises(ValueError, match="Index has duplicate keys"):
  554:             df.set_index([df["A"], df["A"]], verify_integrity=True)
  555: 
  556:     @pytest.mark.parametrize("append", [True, False])
  557:     @pytest.mark.parametrize("drop", [True, False])
  558:     def test_set_index_raise_keys(self, frame_of_index_cols, drop, append):
  559:         df = frame_of_index_cols
  560: 
  561:         with pytest.raises(KeyError, match="['foo', 'bar', 'baz']"):
  562:             # column names are A-E, as well as one tuple
  563:             df.set_index(["foo", "bar", "baz"], drop=drop, append=append)
  564: 
  565:         # non-existent key in list with arrays
  566:         with pytest.raises(KeyError, match="X"):
  567:             df.set_index([df["A"], df["B"], "X"], drop=drop, append=append)
  568: 
  569:         msg = "[('foo', 'foo', 'foo', 'bar', 'bar')]"
  570:         # tuples always raise KeyError
  571:         with pytest.raises(KeyError, match=msg):
  572:             df.set_index(tuple(df["A"]), drop=drop, append=append)
  573: 
  574:         # also within a list
  575:         with pytest.raises(KeyError, match=msg):
  576:             df.set_index(["A", df["A"], tuple(df["A"])], drop=drop, append=append)
  577: 
  578:     @pytest.mark.parametrize("append", [True, False])
  579:     @pytest.mark.parametrize("drop", [True, False])
  580:     @pytest.mark.parametrize("box", [set], ids=["set"])
  581:     def test_set_index_raise_on_type(self, frame_of_index_cols, box, drop, append):
  582:         df = frame_of_index_cols
  583: 
  584:         msg = 'The parameter "keys" may be a column key, .*'
  585:         # forbidden type, e.g. set
  586:         with pytest.raises(TypeError, match=msg):
  587:             df.set_index(box(df["A"]), drop=drop, append=append)
  588: 
  589:         # forbidden type in list, e.g. set
  590:         with pytest.raises(TypeError, match=msg):
  591:             df.set_index(["A", df["A"], box(df["A"])], drop=drop, append=append)
  592: 
  593:     # MultiIndex constructor does not work directly on Series -> lambda
  594:     @pytest.mark.parametrize(
  595:         "box",
  596:         [Series, Index, np.array, iter, lambda x: MultiIndex.from_arrays([x])],
  597:         ids=["Series", "Index", "np.array", "iter", "MultiIndex"],
  598:     )
  599:     @pytest.mark.parametrize("length", [4, 6], ids=["too_short", "too_long"])
  600:     @pytest.mark.parametrize("append", [True, False])
  601:     @pytest.mark.parametrize("drop", [True, False])
  602:     def test_set_index_raise_on_len(
  603:         self, frame_of_index_cols, box, length, drop, append
  604:     ):
  605:         # GH 24984
  606:         df = frame_of_index_cols  # has length 5
  607: 
  608:         values = np.random.default_rng(2).integers(0, 10, (length,))
  609: 
  610:         msg = "Length mismatch: Expected 5 rows, received array of length.*"
  611: 
  612:         # wrong length directly
  613:         with pytest.raises(ValueError, match=msg):
  614:             df.set_index(box(values), drop=drop, append=append)
  615: 
  616:         # wrong length in list
  617:         with pytest.raises(ValueError, match=msg):
  618:             df.set_index(["A", df.A, box(values)], drop=drop, append=append)
  619: 
  620: 
  621: class TestSetIndexCustomLabelType:
  622:     def test_set_index_custom_label_type(self):
  623:         # GH#24969
  624: 
  625:         class Thing:
  626:             def __init__(self, name, color) -> None:
  627:                 self.name = name
  628:                 self.color = color
  629: 
  630:             def __str__(self) -> str:
  631:                 return f"<Thing {repr(self.name)}>"
  632: 
  633:             # necessary for pretty KeyError
  634:             __repr__ = __str__
  635: 
  636:         thing1 = Thing("One", "red")
  637:         thing2 = Thing("Two", "blue")
  638:         df = DataFrame({thing1: [0, 1], thing2: [2, 3]})
  639:         expected = DataFrame({thing1: [0, 1]}, index=Index([2, 3], name=thing2))
  640: 
  641:         # use custom label directly
  642:         result = df.set_index(thing2)
  643:         tm.assert_frame_equal(result, expected)
  644: 
  645:         # custom label wrapped in list
  646:         result = df.set_index([thing2])
  647:         tm.assert_frame_equal(result, expected)
  648: 
  649:         # missing key
  650:         thing3 = Thing("Three", "pink")
  651:         msg = "<Thing 'Three'>"
  652:         with pytest.raises(KeyError, match=msg):
  653:             # missing label directly
  654:             df.set_index(thing3)
  655: 
  656:         with pytest.raises(KeyError, match=msg):
  657:             # missing label in list
  658:             df.set_index([thing3])
  659: 
  660:     def test_set_index_custom_label_hashable_iterable(self):
  661:         # GH#24969
  662: 
  663:         # actual example discussed in GH 24984 was e.g. for shapely.geometry
  664:         # objects (e.g. a collection of Points) that can be both hashable and
  665:         # iterable; using frozenset as a stand-in for testing here
  666: 
  667:         class Thing(frozenset):
  668:             # need to stabilize repr for KeyError (due to random order in sets)
  669:             def __repr__(self) -> str:
  670:                 tmp = sorted(self)
  671:                 joined_reprs = ", ".join(map(repr, tmp))
  672:                 # double curly brace prints one brace in format string
  673:                 return f"frozenset({{{joined_reprs}}})"
  674: 
  675:         thing1 = Thing(["One", "red"])
  676:         thing2 = Thing(["Two", "blue"])
  677:         df = DataFrame({thing1: [0, 1], thing2: [2, 3]})
  678:         expected = DataFrame({thing1: [0, 1]}, index=Index([2, 3], name=thing2))
  679: 
  680:         # use custom label directly
  681:         result = df.set_index(thing2)
  682:         tm.assert_frame_equal(result, expected)
  683: 
  684:         # custom label wrapped in list
  685:         result = df.set_index([thing2])
  686:         tm.assert_frame_equal(result, expected)
  687: 
  688:         # missing key
  689:         thing3 = Thing(["Three", "pink"])
  690:         msg = r"frozenset\(\{'Three', 'pink'\}\)"
  691:         with pytest.raises(KeyError, match=msg):
  692:             # missing label directly
  693:             df.set_index(thing3)
  694: 
  695:         with pytest.raises(KeyError, match=msg):
  696:             # missing label in list
  697:             df.set_index([thing3])
  698: 
  699:     def test_set_index_custom_label_type_raises(self):
  700:         # GH#24969
  701: 
  702:         # purposefully inherit from something unhashable
  703:         class Thing(set):
  704:             def __init__(self, name, color) -> None:
  705:                 self.name = name
  706:                 self.color = color
  707: 
  708:             def __str__(self) -> str:
  709:                 return f"<Thing {repr(self.name)}>"
  710: 
  711:         thing1 = Thing("One", "red")
  712:         thing2 = Thing("Two", "blue")
  713:         df = DataFrame([[0, 2], [1, 3]], columns=[thing1, thing2])
  714: 
  715:         msg = 'The parameter "keys" may be a column key, .*'
  716: 
  717:         with pytest.raises(TypeError, match=msg):
  718:             # use custom label directly
  719:             df.set_index(thing2)
  720: 
  721:         with pytest.raises(TypeError, match=msg):
  722:             # custom label wrapped in list
  723:             df.set_index([thing2])
  724: 
  725:     def test_set_index_periodindex(self):
  726:         # GH#6631
  727:         df = DataFrame(np.random.default_rng(2).random(6))
  728:         idx1 = period_range("2011/01/01", periods=6, freq="M")
  729:         idx2 = period_range("2013", periods=6, freq="Y")
  730: 
  731:         df = df.set_index(idx1)
  732:         tm.assert_index_equal(df.index, idx1)
  733:         df = df.set_index(idx2)
  734:         tm.assert_index_equal(df.index, idx2)
