    1: from datetime import datetime
    2: from itertools import product
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas.core.dtypes.common import (
    8:     is_float_dtype,
    9:     is_integer_dtype,
   10: )
   11: 
   12: import pandas as pd
   13: from pandas import (
   14:     Categorical,
   15:     CategoricalIndex,
   16:     DataFrame,
   17:     Index,
   18:     Interval,
   19:     IntervalIndex,
   20:     MultiIndex,
   21:     RangeIndex,
   22:     Series,
   23:     Timestamp,
   24:     cut,
   25:     date_range,
   26: )
   27: import pandas._testing as tm
   28: 
   29: 
   30: @pytest.fixture()
   31: def multiindex_df():
   32:     levels = [["A", ""], ["B", "b"]]
   33:     return DataFrame([[0, 2], [1, 3]], columns=MultiIndex.from_tuples(levels))
   34: 
   35: 
   36: class TestResetIndex:
   37:     def test_reset_index_empty_rangeindex(self):
   38:         # GH#45230
   39:         df = DataFrame(
   40:             columns=["brand"], dtype=np.int64, index=RangeIndex(0, 0, 1, name="foo")
   41:         )
   42: 
   43:         df2 = df.set_index([df.index, "brand"])
   44: 
   45:         result = df2.reset_index([1], drop=True)
   46:         tm.assert_frame_equal(result, df[[]], check_index_type=True)
   47: 
   48:     def test_set_reset(self):
   49:         idx = Index([2**63, 2**63 + 5, 2**63 + 10], name="foo")
   50: 
   51:         # set/reset
   52:         df = DataFrame({"A": [0, 1, 2]}, index=idx)
   53:         result = df.reset_index()
   54:         assert result["foo"].dtype == np.dtype("uint64")
   55: 
   56:         df = result.set_index("foo")
   57:         tm.assert_index_equal(df.index, idx)
   58: 
   59:     def test_set_index_reset_index_dt64tz(self):
   60:         idx = Index(date_range("20130101", periods=3, tz="US/Eastern"), name="foo")
   61: 
   62:         # set/reset
   63:         df = DataFrame({"A": [0, 1, 2]}, index=idx)
   64:         result = df.reset_index()
   65:         assert result["foo"].dtype == "datetime64[ns, US/Eastern]"
   66: 
   67:         df = result.set_index("foo")
   68:         tm.assert_index_equal(df.index, idx)
   69: 
   70:     def test_reset_index_tz(self, tz_aware_fixture):
   71:         # GH 3950
   72:         # reset_index with single level
   73:         tz = tz_aware_fixture
   74:         idx = date_range("1/1/2011", periods=5, freq="D", tz=tz, name="idx")
   75:         df = DataFrame({"a": range(5), "b": ["A", "B", "C", "D", "E"]}, index=idx)
   76: 
   77:         expected = DataFrame(
   78:             {
   79:                 "idx": idx,
   80:                 "a": range(5),
   81:                 "b": ["A", "B", "C", "D", "E"],
   82:             },
   83:             columns=["idx", "a", "b"],
   84:         )
   85:         result = df.reset_index()
   86:         tm.assert_frame_equal(result, expected)
   87: 
   88:     @pytest.mark.parametrize("tz", ["US/Eastern", "dateutil/US/Eastern"])
   89:     def test_frame_reset_index_tzaware_index(self, tz):
   90:         dr = date_range("2012-06-02", periods=10, tz=tz)
   91:         df = DataFrame(np.random.default_rng(2).standard_normal(len(dr)), dr)
   92:         roundtripped = df.reset_index().set_index("index")
   93:         xp = df.index.tz
   94:         rs = roundtripped.index.tz
   95:         assert xp == rs
   96: 
   97:     def test_reset_index_with_intervals(self):
   98:         idx = IntervalIndex.from_breaks(np.arange(11), name="x")
   99:         original = DataFrame({"x": idx, "y": np.arange(10)})[["x", "y"]]
  100: 
  101:         result = original.set_index("x")
  102:         expected = DataFrame({"y": np.arange(10)}, index=idx)
  103:         tm.assert_frame_equal(result, expected)
  104: 
  105:         result2 = result.reset_index()
  106:         tm.assert_frame_equal(result2, original)
  107: 
  108:     def test_reset_index(self, float_frame):
  109:         stacked = float_frame.stack(future_stack=True)[::2]
  110:         stacked = DataFrame({"foo": stacked, "bar": stacked})
  111: 
  112:         names = ["first", "second"]
  113:         stacked.index.names = names
  114:         deleveled = stacked.reset_index()
  115:         for i, (lev, level_codes) in enumerate(
  116:             zip(stacked.index.levels, stacked.index.codes)
  117:         ):
  118:             values = lev.take(level_codes)
  119:             name = names[i]
  120:             tm.assert_index_equal(values, Index(deleveled[name]))
  121: 
  122:         stacked.index.names = [None, None]
  123:         deleveled2 = stacked.reset_index()
  124:         tm.assert_series_equal(
  125:             deleveled["first"], deleveled2["level_0"], check_names=False
  126:         )
  127:         tm.assert_series_equal(
  128:             deleveled["second"], deleveled2["level_1"], check_names=False
  129:         )
  130: 
  131:         # default name assigned
  132:         rdf = float_frame.reset_index()
  133:         exp = Series(float_frame.index.values, name="index")
  134:         tm.assert_series_equal(rdf["index"], exp)
  135: 
  136:         # default name assigned, corner case
  137:         df = float_frame.copy()
  138:         df["index"] = "foo"
  139:         rdf = df.reset_index()
  140:         exp = Series(float_frame.index.values, name="level_0")
  141:         tm.assert_series_equal(rdf["level_0"], exp)
  142: 
  143:         # but this is ok
  144:         float_frame.index.name = "index"
  145:         deleveled = float_frame.reset_index()
  146:         tm.assert_series_equal(deleveled["index"], Series(float_frame.index))
  147:         tm.assert_index_equal(deleveled.index, Index(range(len(deleveled))), exact=True)
  148: 
  149:         # preserve column names
  150:         float_frame.columns.name = "columns"
  151:         reset = float_frame.reset_index()
  152:         assert reset.columns.name == "columns"
  153: 
  154:         # only remove certain columns
  155:         df = float_frame.reset_index().set_index(["index", "A", "B"])
  156:         rs = df.reset_index(["A", "B"])
  157: 
  158:         tm.assert_frame_equal(rs, float_frame)
  159: 
  160:         rs = df.reset_index(["index", "A", "B"])
  161:         tm.assert_frame_equal(rs, float_frame.reset_index())
  162: 
  163:         rs = df.reset_index(["index", "A", "B"])
  164:         tm.assert_frame_equal(rs, float_frame.reset_index())
  165: 
  166:         rs = df.reset_index("A")
  167:         xp = float_frame.reset_index().set_index(["index", "B"])
  168:         tm.assert_frame_equal(rs, xp)
  169: 
  170:         # test resetting in place
  171:         df = float_frame.copy()
  172:         reset = float_frame.reset_index()
  173:         return_value = df.reset_index(inplace=True)
  174:         assert return_value is None
  175:         tm.assert_frame_equal(df, reset)
  176: 
  177:         df = float_frame.reset_index().set_index(["index", "A", "B"])
  178:         rs = df.reset_index("A", drop=True)
  179:         xp = float_frame.copy()
  180:         del xp["A"]
  181:         xp = xp.set_index(["B"], append=True)
  182:         tm.assert_frame_equal(rs, xp)
  183: 
  184:     def test_reset_index_name(self):
  185:         df = DataFrame(
  186:             [[1, 2, 3, 4], [5, 6, 7, 8]],
  187:             columns=["A", "B", "C", "D"],
  188:             index=Index(range(2), name="x"),
  189:         )
  190:         assert df.reset_index().index.name is None
  191:         assert df.reset_index(drop=True).index.name is None
  192:         return_value = df.reset_index(inplace=True)
  193:         assert return_value is None
  194:         assert df.index.name is None
  195: 
  196:     @pytest.mark.parametrize("levels", [["A", "B"], [0, 1]])
  197:     def test_reset_index_level(self, levels):
  198:         df = DataFrame([[1, 2, 3, 4], [5, 6, 7, 8]], columns=["A", "B", "C", "D"])
  199: 
  200:         # With MultiIndex
  201:         result = df.set_index(["A", "B"]).reset_index(level=levels[0])
  202:         tm.assert_frame_equal(result, df.set_index("B"))
  203: 
  204:         result = df.set_index(["A", "B"]).reset_index(level=levels[:1])
  205:         tm.assert_frame_equal(result, df.set_index("B"))
  206: 
  207:         result = df.set_index(["A", "B"]).reset_index(level=levels)
  208:         tm.assert_frame_equal(result, df)
  209: 
  210:         result = df.set_index(["A", "B"]).reset_index(level=levels, drop=True)
  211:         tm.assert_frame_equal(result, df[["C", "D"]])
  212: 
  213:         # With single-level Index (GH 16263)
  214:         result = df.set_index("A").reset_index(level=levels[0])
  215:         tm.assert_frame_equal(result, df)
  216: 
  217:         result = df.set_index("A").reset_index(level=levels[:1])
  218:         tm.assert_frame_equal(result, df)
  219: 
  220:         result = df.set_index(["A"]).reset_index(level=levels[0], drop=True)
  221:         tm.assert_frame_equal(result, df[["B", "C", "D"]])
  222: 
  223:     @pytest.mark.parametrize("idx_lev", [["A", "B"], ["A"]])
  224:     def test_reset_index_level_missing(self, idx_lev):
  225:         # Missing levels - for both MultiIndex and single-level Index:
  226:         df = DataFrame([[1, 2, 3, 4], [5, 6, 7, 8]], columns=["A", "B", "C", "D"])
  227: 
  228:         with pytest.raises(KeyError, match=r"(L|l)evel \(?E\)?"):
  229:             df.set_index(idx_lev).reset_index(level=["A", "E"])
  230:         with pytest.raises(IndexError, match="Too many levels"):
  231:             df.set_index(idx_lev).reset_index(level=[0, 1, 2])
  232: 
  233:     def test_reset_index_right_dtype(self):
  234:         time = np.arange(0.0, 10, np.sqrt(2) / 2)
  235:         s1 = Series(
  236:             (9.81 * time**2) / 2, index=Index(time, name="time"), name="speed"
  237:         )
  238:         df = DataFrame(s1)
  239: 
  240:         reset = s1.reset_index()
  241:         assert reset["time"].dtype == np.float64
  242: 
  243:         reset = df.reset_index()
  244:         assert reset["time"].dtype == np.float64
  245: 
  246:     def test_reset_index_multiindex_col(self):
  247:         vals = np.random.default_rng(2).standard_normal((3, 3)).astype(object)
  248:         idx = ["x", "y", "z"]
  249:         full = np.hstack(([[x] for x in idx], vals))
  250:         df = DataFrame(
  251:             vals,
  252:             Index(idx, name="a"),
  253:             columns=[["b", "b", "c"], ["mean", "median", "mean"]],
  254:         )
  255:         rs = df.reset_index()
  256:         xp = DataFrame(
  257:             full, columns=[["a", "b", "b", "c"], ["", "mean", "median", "mean"]]
  258:         )
  259:         tm.assert_frame_equal(rs, xp)
  260: 
  261:         rs = df.reset_index(col_fill=None)
  262:         xp = DataFrame(
  263:             full, columns=[["a", "b", "b", "c"], ["a", "mean", "median", "mean"]]
  264:         )
  265:         tm.assert_frame_equal(rs, xp)
  266: 
  267:         rs = df.reset_index(col_level=1, col_fill="blah")
  268:         xp = DataFrame(
  269:             full, columns=[["blah", "b", "b", "c"], ["a", "mean", "median", "mean"]]
  270:         )
  271:         tm.assert_frame_equal(rs, xp)
  272: 
  273:         df = DataFrame(
  274:             vals,
  275:             MultiIndex.from_arrays([[0, 1, 2], ["x", "y", "z"]], names=["d", "a"]),
  276:             columns=[["b", "b", "c"], ["mean", "median", "mean"]],
  277:         )
  278:         rs = df.reset_index("a")
  279:         xp = DataFrame(
  280:             full,
  281:             Index([0, 1, 2], name="d"),
  282:             columns=[["a", "b", "b", "c"], ["", "mean", "median", "mean"]],
  283:         )
  284:         tm.assert_frame_equal(rs, xp)
  285: 
  286:         rs = df.reset_index("a", col_fill=None)
  287:         xp = DataFrame(
  288:             full,
  289:             Index(range(3), name="d"),
  290:             columns=[["a", "b", "b", "c"], ["a", "mean", "median", "mean"]],
  291:         )
  292:         tm.assert_frame_equal(rs, xp)
  293: 
  294:         rs = df.reset_index("a", col_fill="blah", col_level=1)
  295:         xp = DataFrame(
  296:             full,
  297:             Index(range(3), name="d"),
  298:             columns=[["blah", "b", "b", "c"], ["a", "mean", "median", "mean"]],
  299:         )
  300:         tm.assert_frame_equal(rs, xp)
  301: 
  302:     def test_reset_index_multiindex_nan(self):
  303:         # GH#6322, testing reset_index on MultiIndexes
  304:         # when we have a nan or all nan
  305:         df = DataFrame(
  306:             {
  307:                 "A": ["a", "b", "c"],
  308:                 "B": [0, 1, np.nan],
  309:                 "C": np.random.default_rng(2).random(3),
  310:             }
  311:         )
  312:         rs = df.set_index(["A", "B"]).reset_index()
  313:         tm.assert_frame_equal(rs, df)
  314: 
  315:         df = DataFrame(
  316:             {
  317:                 "A": [np.nan, "b", "c"],
  318:                 "B": [0, 1, 2],
  319:                 "C": np.random.default_rng(2).random(3),
  320:             }
  321:         )
  322:         rs = df.set_index(["A", "B"]).reset_index()
  323:         tm.assert_frame_equal(rs, df)
  324: 
  325:         df = DataFrame({"A": ["a", "b", "c"], "B": [0, 1, 2], "C": [np.nan, 1.1, 2.2]})
  326:         rs = df.set_index(["A", "B"]).reset_index()
  327:         tm.assert_frame_equal(rs, df)
  328: 
  329:         df = DataFrame(
  330:             {
  331:                 "A": ["a", "b", "c"],
  332:                 "B": [np.nan, np.nan, np.nan],
  333:                 "C": np.random.default_rng(2).random(3),
  334:             }
  335:         )
  336:         rs = df.set_index(["A", "B"]).reset_index()
  337:         tm.assert_frame_equal(rs, df)
  338: 
  339:     @pytest.mark.parametrize(
  340:         "name",
  341:         [
  342:             None,
  343:             "foo",
  344:             2,
  345:             3.0,
  346:             pd.Timedelta(6),
  347:             Timestamp("2012-12-30", tz="UTC"),
  348:             "2012-12-31",
  349:         ],
  350:     )
  351:     def test_reset_index_with_datetimeindex_cols(self, name):
  352:         # GH#5818
  353:         df = DataFrame(
  354:             [[1, 2], [3, 4]],
  355:             columns=date_range("1/1/2013", "1/2/2013"),
  356:             index=["A", "B"],
  357:         )
  358:         df.index.name = name
  359: 
  360:         result = df.reset_index()
  361: 
  362:         item = name if name is not None else "index"
  363:         columns = Index([item, datetime(2013, 1, 1), datetime(2013, 1, 2)])
  364:         if isinstance(item, str) and item == "2012-12-31":
  365:             columns = columns.astype("datetime64[ns]")
  366:         else:
  367:             assert columns.dtype == object
  368: 
  369:         expected = DataFrame(
  370:             [["A", 1, 2], ["B", 3, 4]],
  371:             columns=columns,
  372:         )
  373:         tm.assert_frame_equal(result, expected)
  374: 
  375:     def test_reset_index_range(self):
  376:         # GH#12071
  377:         df = DataFrame([[0, 0], [1, 1]], columns=["A", "B"], index=RangeIndex(stop=2))
  378:         result = df.reset_index()
  379:         assert isinstance(result.index, RangeIndex)
  380:         expected = DataFrame(
  381:             [[0, 0, 0], [1, 1, 1]],
  382:             columns=["index", "A", "B"],
  383:             index=RangeIndex(stop=2),
  384:         )
  385:         tm.assert_frame_equal(result, expected)
  386: 
  387:     def test_reset_index_multiindex_columns(self, multiindex_df):
  388:         result = multiindex_df[["B"]].rename_axis("A").reset_index()
  389:         tm.assert_frame_equal(result, multiindex_df)
  390: 
  391:         # GH#16120: already existing column
  392:         msg = r"cannot insert \('A', ''\), already exists"
  393:         with pytest.raises(ValueError, match=msg):
  394:             multiindex_df.rename_axis("A").reset_index()
  395: 
  396:         # GH#16164: multiindex (tuple) full key
  397:         result = multiindex_df.set_index([("A", "")]).reset_index()
  398:         tm.assert_frame_equal(result, multiindex_df)
  399: 
  400:         # with additional (unnamed) index level
  401:         idx_col = DataFrame(
  402:             [[0], [1]], columns=MultiIndex.from_tuples([("level_0", "")])
  403:         )
  404:         expected = pd.concat([idx_col, multiindex_df[[("B", "b"), ("A", "")]]], axis=1)
  405:         result = multiindex_df.set_index([("B", "b")], append=True).reset_index()
  406:         tm.assert_frame_equal(result, expected)
  407: 
  408:         # with index name which is a too long tuple...
  409:         msg = "Item must have length equal to number of levels."
  410:         with pytest.raises(ValueError, match=msg):
  411:             multiindex_df.rename_axis([("C", "c", "i")]).reset_index()
  412: 
  413:         # or too short...
  414:         levels = [["A", "a", ""], ["B", "b", "i"]]
  415:         df2 = DataFrame([[0, 2], [1, 3]], columns=MultiIndex.from_tuples(levels))
  416:         idx_col = DataFrame(
  417:             [[0], [1]], columns=MultiIndex.from_tuples([("C", "c", "ii")])
  418:         )
  419:         expected = pd.concat([idx_col, df2], axis=1)
  420:         result = df2.rename_axis([("C", "c")]).reset_index(col_fill="ii")
  421:         tm.assert_frame_equal(result, expected)
  422: 
  423:         # ... which is incompatible with col_fill=None
  424:         with pytest.raises(
  425:             ValueError,
  426:             match=(
  427:                 "col_fill=None is incompatible with "
  428:                 r"incomplete column name \('C', 'c'\)"
  429:             ),
  430:         ):
  431:             df2.rename_axis([("C", "c")]).reset_index(col_fill=None)
  432: 
  433:         # with col_level != 0
  434:         result = df2.rename_axis([("c", "ii")]).reset_index(col_level=1, col_fill="C")
  435:         tm.assert_frame_equal(result, expected)
  436: 
  437:     @pytest.mark.parametrize("flag", [False, True])
  438:     @pytest.mark.parametrize("allow_duplicates", [False, True])
  439:     def test_reset_index_duplicate_columns_allow(
  440:         self, multiindex_df, flag, allow_duplicates
  441:     ):
  442:         # GH#44755 reset_index with duplicate column labels
  443:         df = multiindex_df.rename_axis("A")
  444:         df = df.set_flags(allows_duplicate_labels=flag)
  445: 
  446:         if flag and allow_duplicates:
  447:             result = df.reset_index(allow_duplicates=allow_duplicates)
  448:             levels = [["A", ""], ["A", ""], ["B", "b"]]
  449:             expected = DataFrame(
  450:                 [[0, 0, 2], [1, 1, 3]], columns=MultiIndex.from_tuples(levels)
  451:             )
  452:             tm.assert_frame_equal(result, expected)
  453:         else:
  454:             if not flag and allow_duplicates:
  455:                 msg = (
  456:                     "Cannot specify 'allow_duplicates=True' when "
  457:                     "'self.flags.allows_duplicate_labels' is False"
  458:                 )
  459:             else:
  460:                 msg = r"cannot insert \('A', ''\), already exists"
  461:             with pytest.raises(ValueError, match=msg):
  462:                 df.reset_index(allow_duplicates=allow_duplicates)
  463: 
  464:     @pytest.mark.parametrize("flag", [False, True])
  465:     def test_reset_index_duplicate_columns_default(self, multiindex_df, flag):
  466:         df = multiindex_df.rename_axis("A")
  467:         df = df.set_flags(allows_duplicate_labels=flag)
  468: 
  469:         msg = r"cannot insert \('A', ''\), already exists"
  470:         with pytest.raises(ValueError, match=msg):
  471:             df.reset_index()
  472: 
  473:     @pytest.mark.parametrize("allow_duplicates", ["bad value"])
  474:     def test_reset_index_allow_duplicates_check(self, multiindex_df, allow_duplicates):
  475:         with pytest.raises(ValueError, match="expected type bool"):
  476:             multiindex_df.reset_index(allow_duplicates=allow_duplicates)
  477: 
  478:     def test_reset_index_datetime(self, tz_naive_fixture):
  479:         # GH#3950
  480:         tz = tz_naive_fixture
  481:         idx1 = date_range("1/1/2011", periods=5, freq="D", tz=tz, name="idx1")
  482:         idx2 = Index(range(5), name="idx2", dtype="int64")
  483:         idx = MultiIndex.from_arrays([idx1, idx2])
  484:         df = DataFrame(
  485:             {"a": np.arange(5, dtype="int64"), "b": ["A", "B", "C", "D", "E"]},
  486:             index=idx,
  487:         )
  488: 
  489:         expected = DataFrame(
  490:             {
  491:                 "idx1": idx1,
  492:                 "idx2": np.arange(5, dtype="int64"),
  493:                 "a": np.arange(5, dtype="int64"),
  494:                 "b": ["A", "B", "C", "D", "E"],
  495:             },
  496:             columns=["idx1", "idx2", "a", "b"],
  497:         )
  498: 
  499:         tm.assert_frame_equal(df.reset_index(), expected)
  500: 
  501:     def test_reset_index_datetime2(self, tz_naive_fixture):
  502:         tz = tz_naive_fixture
  503:         idx1 = date_range("1/1/2011", periods=5, freq="D", tz=tz, name="idx1")
  504:         idx2 = Index(range(5), name="idx2", dtype="int64")
  505:         idx3 = date_range(
  506:             "1/1/2012", periods=5, freq="MS", tz="Europe/Paris", name="idx3"
  507:         )
  508:         idx = MultiIndex.from_arrays([idx1, idx2, idx3])
  509:         df = DataFrame(
  510:             {"a": np.arange(5, dtype="int64"), "b": ["A", "B", "C", "D", "E"]},
  511:             index=idx,
  512:         )
  513: 
  514:         expected = DataFrame(
  515:             {
  516:                 "idx1": idx1,
  517:                 "idx2": np.arange(5, dtype="int64"),
  518:                 "idx3": idx3,
  519:                 "a": np.arange(5, dtype="int64"),
  520:                 "b": ["A", "B", "C", "D", "E"],
  521:             },
  522:             columns=["idx1", "idx2", "idx3", "a", "b"],
  523:         )
  524:         result = df.reset_index()
  525:         tm.assert_frame_equal(result, expected)
  526: 
  527:     def test_reset_index_datetime3(self, tz_naive_fixture):
  528:         # GH#7793
  529:         tz = tz_naive_fixture
  530:         dti = date_range("20130101", periods=3, tz=tz)
  531:         idx = MultiIndex.from_product([["a", "b"], dti])
  532:         df = DataFrame(
  533:             np.arange(6, dtype="int64").reshape(6, 1), columns=["a"], index=idx
  534:         )
  535: 
  536:         expected = DataFrame(
  537:             {
  538:                 "level_0": "a a a b b b".split(),
  539:                 "level_1": dti.append(dti),
  540:                 "a": np.arange(6, dtype="int64"),
  541:             },
  542:             columns=["level_0", "level_1", "a"],
  543:         )
  544:         result = df.reset_index()
  545:         tm.assert_frame_equal(result, expected)
  546: 
  547:     def test_reset_index_period(self):
  548:         # GH#7746
  549:         idx = MultiIndex.from_product(
  550:             [pd.period_range("20130101", periods=3, freq="M"), list("abc")],
  551:             names=["month", "feature"],
  552:         )
  553: 
  554:         df = DataFrame(
  555:             np.arange(9, dtype="int64").reshape(-1, 1), index=idx, columns=["a"]
  556:         )
  557:         expected = DataFrame(
  558:             {
  559:                 "month": (
  560:                     [pd.Period("2013-01", freq="M")] * 3
  561:                     + [pd.Period("2013-02", freq="M")] * 3
  562:                     + [pd.Period("2013-03", freq="M")] * 3
  563:                 ),
  564:                 "feature": ["a", "b", "c"] * 3,
  565:                 "a": np.arange(9, dtype="int64"),
  566:             },
  567:             columns=["month", "feature", "a"],
  568:         )
  569:         result = df.reset_index()
  570:         tm.assert_frame_equal(result, expected)
  571: 
  572:     def test_reset_index_delevel_infer_dtype(self):
  573:         tuples = list(product(["foo", "bar"], [10, 20], [1.0, 1.1]))
  574:         index = MultiIndex.from_tuples(tuples, names=["prm0", "prm1", "prm2"])
  575:         df = DataFrame(
  576:             np.random.default_rng(2).standard_normal((8, 3)),
  577:             columns=["A", "B", "C"],
  578:             index=index,
  579:         )
  580:         deleveled = df.reset_index()
  581:         assert is_integer_dtype(deleveled["prm1"])
  582:         assert is_float_dtype(deleveled["prm2"])
  583: 
  584:     def test_reset_index_with_drop(
  585:         self, multiindex_year_month_day_dataframe_random_data
  586:     ):
  587:         ymd = multiindex_year_month_day_dataframe_random_data
  588: 
  589:         deleveled = ymd.reset_index(drop=True)
  590:         assert len(deleveled.columns) == len(ymd.columns)
  591:         assert deleveled.index.name == ymd.index.name
  592: 
  593:     @pytest.mark.parametrize(
  594:         "ix_data, exp_data",
  595:         [
  596:             (
  597:                 [(pd.NaT, 1), (pd.NaT, 2)],
  598:                 {"a": [pd.NaT, pd.NaT], "b": [1, 2], "x": [11, 12]},
  599:             ),
  600:             (
  601:                 [(pd.NaT, 1), (Timestamp("2020-01-01"), 2)],
  602:                 {"a": [pd.NaT, Timestamp("2020-01-01")], "b": [1, 2], "x": [11, 12]},
  603:             ),
  604:             (
  605:                 [(pd.NaT, 1), (pd.Timedelta(123, "d"), 2)],
  606:                 {"a": [pd.NaT, pd.Timedelta(123, "d")], "b": [1, 2], "x": [11, 12]},
  607:             ),
  608:         ],
  609:     )
  610:     def test_reset_index_nat_multiindex(self, ix_data, exp_data):
  611:         # GH#36541: that reset_index() does not raise ValueError
  612:         ix = MultiIndex.from_tuples(ix_data, names=["a", "b"])
  613:         result = DataFrame({"x": [11, 12]}, index=ix)
  614:         result = result.reset_index()
  615: 
  616:         expected = DataFrame(exp_data)
  617:         tm.assert_frame_equal(result, expected)
  618: 
  619:     @pytest.mark.parametrize(
  620:         "codes", ([[0, 0, 1, 1], [0, 1, 0, 1]], [[0, 0, -1, 1], [0, 1, 0, 1]])
  621:     )
  622:     def test_rest_index_multiindex_categorical_with_missing_values(self, codes):
  623:         # GH#24206
  624: 
  625:         index = MultiIndex(
  626:             [CategoricalIndex(["A", "B"]), CategoricalIndex(["a", "b"])], codes
  627:         )
  628:         data = {"col": range(len(index))}
  629:         df = DataFrame(data=data, index=index)
  630: 
  631:         expected = DataFrame(
  632:             {
  633:                 "level_0": Categorical.from_codes(codes[0], categories=["A", "B"]),
  634:                 "level_1": Categorical.from_codes(codes[1], categories=["a", "b"]),
  635:                 "col": range(4),
  636:             }
  637:         )
  638: 
  639:         res = df.reset_index()
  640:         tm.assert_frame_equal(res, expected)
  641: 
  642:         # roundtrip
  643:         res = expected.set_index(["level_0", "level_1"]).reset_index()
  644:         tm.assert_frame_equal(res, expected)
  645: 
  646: 
  647: @pytest.mark.parametrize(
  648:     "array, dtype",
  649:     [
  650:         (["a", "b"], object),
  651:         (
  652:             pd.period_range("12-1-2000", periods=2, freq="Q-DEC"),
  653:             pd.PeriodDtype(freq="Q-DEC"),
  654:         ),
  655:     ],
  656: )
  657: def test_reset_index_dtypes_on_empty_frame_with_multiindex(
  658:     array, dtype, using_infer_string
  659: ):
  660:     # GH 19602 - Preserve dtype on empty DataFrame with MultiIndex
  661:     idx = MultiIndex.from_product([[0, 1], [0.5, 1.0], array])
  662:     result = DataFrame(index=idx)[:0].reset_index().dtypes
  663:     if using_infer_string and dtype == object:
  664:         dtype = "string"
  665:     expected = Series({"level_0": np.int64, "level_1": np.float64, "level_2": dtype})
  666:     tm.assert_series_equal(result, expected)
  667: 
  668: 
  669: def test_reset_index_empty_frame_with_datetime64_multiindex():
  670:     # https://github.com/pandas-dev/pandas/issues/35606
  671:     dti = pd.DatetimeIndex(["2020-07-20 00:00:00"], dtype="M8[ns]")
  672:     idx = MultiIndex.from_product([dti, [3, 4]], names=["a", "b"])[:0]
  673:     df = DataFrame(index=idx, columns=["c", "d"])
  674:     result = df.reset_index()
  675:     expected = DataFrame(
  676:         columns=list("abcd"), index=RangeIndex(start=0, stop=0, step=1)
  677:     )
  678:     expected["a"] = expected["a"].astype("datetime64[ns]")
  679:     expected["b"] = expected["b"].astype("int64")
  680:     tm.assert_frame_equal(result, expected)
  681: 
  682: 
  683: def test_reset_index_empty_frame_with_datetime64_multiindex_from_groupby(
  684:     using_infer_string,
  685: ):
  686:     # https://github.com/pandas-dev/pandas/issues/35657
  687:     dti = pd.DatetimeIndex(["2020-01-01"], dtype="M8[ns]")
  688:     df = DataFrame({"c1": [10.0], "c2": ["a"], "c3": dti})
  689:     df = df.head(0).groupby(["c2", "c3"])[["c1"]].sum()
  690:     result = df.reset_index()
  691:     expected = DataFrame(
  692:         columns=["c2", "c3", "c1"], index=RangeIndex(start=0, stop=0, step=1)
  693:     )
  694:     expected["c3"] = expected["c3"].astype("datetime64[ns]")
  695:     expected["c1"] = expected["c1"].astype("float64")
  696:     if using_infer_string:
  697:         expected["c2"] = expected["c2"].astype("string[pyarrow_numpy]")
  698:     tm.assert_frame_equal(result, expected)
  699: 
  700: 
  701: def test_reset_index_multiindex_nat():
  702:     # GH 11479
  703:     idx = range(3)
  704:     tstamp = date_range("2015-07-01", freq="D", periods=3)
  705:     df = DataFrame({"id": idx, "tstamp": tstamp, "a": list("abc")})
  706:     df.loc[2, "tstamp"] = pd.NaT
  707:     result = df.set_index(["id", "tstamp"]).reset_index("id")
  708:     exp_dti = pd.DatetimeIndex(
  709:         ["2015-07-01", "2015-07-02", "NaT"], dtype="M8[ns]", name="tstamp"
  710:     )
  711:     expected = DataFrame(
  712:         {"id": range(3), "a": list("abc")},
  713:         index=exp_dti,
  714:     )
  715:     tm.assert_frame_equal(result, expected)
  716: 
  717: 
  718: def test_reset_index_interval_columns_object_cast():
  719:     # GH 19136
  720:     df = DataFrame(
  721:         np.eye(2), index=Index([1, 2], name="Year"), columns=cut([1, 2], [0, 1, 2])
  722:     )
  723:     result = df.reset_index()
  724:     expected = DataFrame(
  725:         [[1, 1.0, 0.0], [2, 0.0, 1.0]],
  726:         columns=Index(["Year", Interval(0, 1), Interval(1, 2)]),
  727:     )
  728:     tm.assert_frame_equal(result, expected)
  729: 
  730: 
  731: def test_reset_index_rename(float_frame):
  732:     # GH 6878
  733:     result = float_frame.reset_index(names="new_name")
  734:     expected = Series(float_frame.index.values, name="new_name")
  735:     tm.assert_series_equal(result["new_name"], expected)
  736: 
  737:     result = float_frame.reset_index(names=123)
  738:     expected = Series(float_frame.index.values, name=123)
  739:     tm.assert_series_equal(result[123], expected)
  740: 
  741: 
  742: def test_reset_index_rename_multiindex(float_frame):
  743:     # GH 6878
  744:     stacked_df = float_frame.stack(future_stack=True)[::2]
  745:     stacked_df = DataFrame({"foo": stacked_df, "bar": stacked_df})
  746: 
  747:     names = ["first", "second"]
  748:     stacked_df.index.names = names
  749: 
  750:     result = stacked_df.reset_index()
  751:     expected = stacked_df.reset_index(names=["new_first", "new_second"])
  752:     tm.assert_series_equal(result["first"], expected["new_first"], check_names=False)
  753:     tm.assert_series_equal(result["second"], expected["new_second"], check_names=False)
  754: 
  755: 
  756: def test_errorreset_index_rename(float_frame):
  757:     # GH 6878
  758:     stacked_df = float_frame.stack(future_stack=True)[::2]
  759:     stacked_df = DataFrame({"first": stacked_df, "second": stacked_df})
  760: 
  761:     with pytest.raises(
  762:         ValueError, match="Index names must be str or 1-dimensional list"
  763:     ):
  764:         stacked_df.reset_index(names={"first": "new_first", "second": "new_second"})
  765: 
  766:     with pytest.raises(IndexError, match="list index out of range"):
  767:         stacked_df.reset_index(names=["new_first"])
  768: 
  769: 
  770: def test_reset_index_false_index_name():
  771:     result_series = Series(data=range(5, 10), index=range(5))
  772:     result_series.index.name = False
  773:     result_series.reset_index()
  774:     expected_series = Series(range(5, 10), RangeIndex(range(5), name=False))
  775:     tm.assert_series_equal(result_series, expected_series)
  776: 
  777:     # GH 38147
  778:     result_frame = DataFrame(data=range(5, 10), index=range(5))
  779:     result_frame.index.name = False
  780:     result_frame.reset_index()
  781:     expected_frame = DataFrame(range(5, 10), RangeIndex(range(5), name=False))
  782:     tm.assert_frame_equal(result_frame, expected_frame)
