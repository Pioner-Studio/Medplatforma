    1: from datetime import (
    2:     datetime,
    3:     time,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas._libs.tslibs import timezones
   10: import pandas.util._test_decorators as td
   11: 
   12: from pandas import (
   13:     DataFrame,
   14:     Series,
   15:     date_range,
   16: )
   17: import pandas._testing as tm
   18: 
   19: 
   20: class TestBetweenTime:
   21:     @td.skip_if_not_us_locale
   22:     def test_between_time_formats(self, frame_or_series):
   23:         # GH#11818
   24:         rng = date_range("1/1/2000", "1/5/2000", freq="5min")
   25:         ts = DataFrame(
   26:             np.random.default_rng(2).standard_normal((len(rng), 2)), index=rng
   27:         )
   28:         ts = tm.get_obj(ts, frame_or_series)
   29: 
   30:         strings = [
   31:             ("2:00", "2:30"),
   32:             ("0200", "0230"),
   33:             ("2:00am", "2:30am"),
   34:             ("0200am", "0230am"),
   35:             ("2:00:00", "2:30:00"),
   36:             ("020000", "023000"),
   37:             ("2:00:00am", "2:30:00am"),
   38:             ("020000am", "023000am"),
   39:         ]
   40:         expected_length = 28
   41: 
   42:         for time_string in strings:
   43:             assert len(ts.between_time(*time_string)) == expected_length
   44: 
   45:     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
   46:     def test_localized_between_time(self, tzstr, frame_or_series):
   47:         tz = timezones.maybe_get_tz(tzstr)
   48: 
   49:         rng = date_range("4/16/2012", "5/1/2012", freq="h")
   50:         ts = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
   51:         if frame_or_series is DataFrame:
   52:             ts = ts.to_frame()
   53: 
   54:         ts_local = ts.tz_localize(tzstr)
   55: 
   56:         t1, t2 = time(10, 0), time(11, 0)
   57:         result = ts_local.between_time(t1, t2)
   58:         expected = ts.between_time(t1, t2).tz_localize(tzstr)
   59:         tm.assert_equal(result, expected)
   60:         assert timezones.tz_compare(result.index.tz, tz)
   61: 
   62:     def test_between_time_types(self, frame_or_series):
   63:         # GH11818
   64:         rng = date_range("1/1/2000", "1/5/2000", freq="5min")
   65:         obj = DataFrame({"A": 0}, index=rng)
   66:         obj = tm.get_obj(obj, frame_or_series)
   67: 
   68:         msg = r"Cannot convert arg \[datetime\.datetime\(2010, 1, 2, 1, 0\)\] to a time"
   69:         with pytest.raises(ValueError, match=msg):
   70:             obj.between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))
   71: 
   72:     def test_between_time(self, inclusive_endpoints_fixture, frame_or_series):
   73:         rng = date_range("1/1/2000", "1/5/2000", freq="5min")
   74:         ts = DataFrame(
   75:             np.random.default_rng(2).standard_normal((len(rng), 2)), index=rng
   76:         )
   77:         ts = tm.get_obj(ts, frame_or_series)
   78: 
   79:         stime = time(0, 0)
   80:         etime = time(1, 0)
   81:         inclusive = inclusive_endpoints_fixture
   82: 
   83:         filtered = ts.between_time(stime, etime, inclusive=inclusive)
   84:         exp_len = 13 * 4 + 1
   85: 
   86:         if inclusive in ["right", "neither"]:
   87:             exp_len -= 5
   88:         if inclusive in ["left", "neither"]:
   89:             exp_len -= 4
   90: 
   91:         assert len(filtered) == exp_len
   92:         for rs in filtered.index:
   93:             t = rs.time()
   94:             if inclusive in ["left", "both"]:
   95:                 assert t >= stime
   96:             else:
   97:                 assert t > stime
   98: 
   99:             if inclusive in ["right", "both"]:
  100:                 assert t <= etime
  101:             else:
  102:                 assert t < etime
  103: 
  104:         result = ts.between_time("00:00", "01:00")
  105:         expected = ts.between_time(stime, etime)
  106:         tm.assert_equal(result, expected)
  107: 
  108:         # across midnight
  109:         rng = date_range("1/1/2000", "1/5/2000", freq="5min")
  110:         ts = DataFrame(
  111:             np.random.default_rng(2).standard_normal((len(rng), 2)), index=rng
  112:         )
  113:         ts = tm.get_obj(ts, frame_or_series)
  114:         stime = time(22, 0)
  115:         etime = time(9, 0)
  116: 
  117:         filtered = ts.between_time(stime, etime, inclusive=inclusive)
  118:         exp_len = (12 * 11 + 1) * 4 + 1
  119:         if inclusive in ["right", "neither"]:
  120:             exp_len -= 4
  121:         if inclusive in ["left", "neither"]:
  122:             exp_len -= 4
  123: 
  124:         assert len(filtered) == exp_len
  125:         for rs in filtered.index:
  126:             t = rs.time()
  127:             if inclusive in ["left", "both"]:
  128:                 assert (t >= stime) or (t <= etime)
  129:             else:
  130:                 assert (t > stime) or (t <= etime)
  131: 
  132:             if inclusive in ["right", "both"]:
  133:                 assert (t <= etime) or (t >= stime)
  134:             else:
  135:                 assert (t < etime) or (t >= stime)
  136: 
  137:     def test_between_time_raises(self, frame_or_series):
  138:         # GH#20725
  139:         obj = DataFrame([[1, 2, 3], [4, 5, 6]])
  140:         obj = tm.get_obj(obj, frame_or_series)
  141: 
  142:         msg = "Index must be DatetimeIndex"
  143:         with pytest.raises(TypeError, match=msg):  # index is not a DatetimeIndex
  144:             obj.between_time(start_time="00:00", end_time="12:00")
  145: 
  146:     def test_between_time_axis(self, frame_or_series):
  147:         # GH#8839
  148:         rng = date_range("1/1/2000", periods=100, freq="10min")
  149:         ts = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
  150:         if frame_or_series is DataFrame:
  151:             ts = ts.to_frame()
  152: 
  153:         stime, etime = ("08:00:00", "09:00:00")
  154:         expected_length = 7
  155: 
  156:         assert len(ts.between_time(stime, etime)) == expected_length
  157:         assert len(ts.between_time(stime, etime, axis=0)) == expected_length
  158:         msg = f"No axis named {ts.ndim} for object type {type(ts).__name__}"
  159:         with pytest.raises(ValueError, match=msg):
  160:             ts.between_time(stime, etime, axis=ts.ndim)
  161: 
  162:     def test_between_time_axis_aliases(self, axis):
  163:         # GH#8839
  164:         rng = date_range("1/1/2000", periods=100, freq="10min")
  165:         ts = DataFrame(np.random.default_rng(2).standard_normal((len(rng), len(rng))))
  166:         stime, etime = ("08:00:00", "09:00:00")
  167:         exp_len = 7
  168: 
  169:         if axis in ["index", 0]:
  170:             ts.index = rng
  171:             assert len(ts.between_time(stime, etime)) == exp_len
  172:             assert len(ts.between_time(stime, etime, axis=0)) == exp_len
  173: 
  174:         if axis in ["columns", 1]:
  175:             ts.columns = rng
  176:             selected = ts.between_time(stime, etime, axis=1).columns
  177:             assert len(selected) == exp_len
  178: 
  179:     def test_between_time_axis_raises(self, axis):
  180:         # issue 8839
  181:         rng = date_range("1/1/2000", periods=100, freq="10min")
  182:         mask = np.arange(0, len(rng))
  183:         rand_data = np.random.default_rng(2).standard_normal((len(rng), len(rng)))
  184:         ts = DataFrame(rand_data, index=rng, columns=rng)
  185:         stime, etime = ("08:00:00", "09:00:00")
  186: 
  187:         msg = "Index must be DatetimeIndex"
  188:         if axis in ["columns", 1]:
  189:             ts.index = mask
  190:             with pytest.raises(TypeError, match=msg):
  191:                 ts.between_time(stime, etime)
  192:             with pytest.raises(TypeError, match=msg):
  193:                 ts.between_time(stime, etime, axis=0)
  194: 
  195:         if axis in ["index", 0]:
  196:             ts.columns = mask
  197:             with pytest.raises(TypeError, match=msg):
  198:                 ts.between_time(stime, etime, axis=1)
  199: 
  200:     def test_between_time_datetimeindex(self):
  201:         index = date_range("2012-01-01", "2012-01-05", freq="30min")
  202:         df = DataFrame(
  203:             np.random.default_rng(2).standard_normal((len(index), 5)), index=index
  204:         )
  205:         bkey = slice(time(13, 0, 0), time(14, 0, 0))
  206:         binds = [26, 27, 28, 74, 75, 76, 122, 123, 124, 170, 171, 172]
  207: 
  208:         result = df.between_time(bkey.start, bkey.stop)
  209:         expected = df.loc[bkey]
  210:         expected2 = df.iloc[binds]
  211:         tm.assert_frame_equal(result, expected)
  212:         tm.assert_frame_equal(result, expected2)
  213:         assert len(result) == 12
  214: 
  215:     def test_between_time_incorrect_arg_inclusive(self):
  216:         # GH40245
  217:         rng = date_range("1/1/2000", "1/5/2000", freq="5min")
  218:         ts = DataFrame(
  219:             np.random.default_rng(2).standard_normal((len(rng), 2)), index=rng
  220:         )
  221: 
  222:         stime = time(0, 0)
  223:         etime = time(1, 0)
  224:         inclusive = "bad_string"
  225:         msg = "Inclusive has to be either 'both', 'neither', 'left' or 'right'"
  226:         with pytest.raises(ValueError, match=msg):
  227:             ts.between_time(stime, etime, inclusive=inclusive)
