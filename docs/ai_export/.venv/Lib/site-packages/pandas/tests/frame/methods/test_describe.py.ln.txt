    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Categorical,
    7:     DataFrame,
    8:     Series,
    9:     Timestamp,
   10:     date_range,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: class TestDataFrameDescribe:
   16:     def test_describe_bool_in_mixed_frame(self):
   17:         df = DataFrame(
   18:             {
   19:                 "string_data": ["a", "b", "c", "d", "e"],
   20:                 "bool_data": [True, True, False, False, False],
   21:                 "int_data": [10, 20, 30, 40, 50],
   22:             }
   23:         )
   24: 
   25:         # Integer data are included in .describe() output,
   26:         # Boolean and string data are not.
   27:         result = df.describe()
   28:         expected = DataFrame(
   29:             {"int_data": [5, 30, df.int_data.std(), 10, 20, 30, 40, 50]},
   30:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
   31:         )
   32:         tm.assert_frame_equal(result, expected)
   33: 
   34:         # Top value is a boolean value that is False
   35:         result = df.describe(include=["bool"])
   36: 
   37:         expected = DataFrame(
   38:             {"bool_data": [5, 2, False, 3]}, index=["count", "unique", "top", "freq"]
   39:         )
   40:         tm.assert_frame_equal(result, expected)
   41: 
   42:     def test_describe_empty_object(self):
   43:         # GH#27183
   44:         df = DataFrame({"A": [None, None]}, dtype=object)
   45:         result = df.describe()
   46:         expected = DataFrame(
   47:             {"A": [0, 0, np.nan, np.nan]},
   48:             dtype=object,
   49:             index=["count", "unique", "top", "freq"],
   50:         )
   51:         tm.assert_frame_equal(result, expected)
   52: 
   53:         result = df.iloc[:0].describe()
   54:         tm.assert_frame_equal(result, expected)
   55: 
   56:     def test_describe_bool_frame(self):
   57:         # GH#13891
   58:         df = DataFrame(
   59:             {
   60:                 "bool_data_1": [False, False, True, True],
   61:                 "bool_data_2": [False, True, True, True],
   62:             }
   63:         )
   64:         result = df.describe()
   65:         expected = DataFrame(
   66:             {"bool_data_1": [4, 2, False, 2], "bool_data_2": [4, 2, True, 3]},
   67:             index=["count", "unique", "top", "freq"],
   68:         )
   69:         tm.assert_frame_equal(result, expected)
   70: 
   71:         df = DataFrame(
   72:             {
   73:                 "bool_data": [False, False, True, True, False],
   74:                 "int_data": [0, 1, 2, 3, 4],
   75:             }
   76:         )
   77:         result = df.describe()
   78:         expected = DataFrame(
   79:             {"int_data": [5, 2, df.int_data.std(), 0, 1, 2, 3, 4]},
   80:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
   81:         )
   82:         tm.assert_frame_equal(result, expected)
   83: 
   84:         df = DataFrame(
   85:             {"bool_data": [False, False, True, True], "str_data": ["a", "b", "c", "a"]}
   86:         )
   87:         result = df.describe()
   88:         expected = DataFrame(
   89:             {"bool_data": [4, 2, False, 2], "str_data": [4, 3, "a", 2]},
   90:             index=["count", "unique", "top", "freq"],
   91:         )
   92:         tm.assert_frame_equal(result, expected)
   93: 
   94:     def test_describe_categorical(self):
   95:         df = DataFrame({"value": np.random.default_rng(2).integers(0, 10000, 100)})
   96:         labels = [f"{i} - {i + 499}" for i in range(0, 10000, 500)]
   97:         cat_labels = Categorical(labels, labels)
   98: 
   99:         df = df.sort_values(by=["value"], ascending=True)
  100:         df["value_group"] = pd.cut(
  101:             df.value, range(0, 10500, 500), right=False, labels=cat_labels
  102:         )
  103:         cat = df
  104: 
  105:         # Categoricals should not show up together with numerical columns
  106:         result = cat.describe()
  107:         assert len(result.columns) == 1
  108: 
  109:         # In a frame, describe() for the cat should be the same as for string
  110:         # arrays (count, unique, top, freq)
  111: 
  112:         cat = Categorical(
  113:             ["a", "b", "b", "b"], categories=["a", "b", "c"], ordered=True
  114:         )
  115:         s = Series(cat)
  116:         result = s.describe()
  117:         expected = Series([4, 2, "b", 3], index=["count", "unique", "top", "freq"])
  118:         tm.assert_series_equal(result, expected)
  119: 
  120:         cat = Series(Categorical(["a", "b", "c", "c"]))
  121:         df3 = DataFrame({"cat": cat, "s": ["a", "b", "c", "c"]})
  122:         result = df3.describe()
  123:         tm.assert_numpy_array_equal(result["cat"].values, result["s"].values)
  124: 
  125:     def test_describe_empty_categorical_column(self):
  126:         # GH#26397
  127:         # Ensure the index of an empty categorical DataFrame column
  128:         # also contains (count, unique, top, freq)
  129:         df = DataFrame({"empty_col": Categorical([])})
  130:         result = df.describe()
  131:         expected = DataFrame(
  132:             {"empty_col": [0, 0, np.nan, np.nan]},
  133:             index=["count", "unique", "top", "freq"],
  134:             dtype="object",
  135:         )
  136:         tm.assert_frame_equal(result, expected)
  137:         # ensure NaN, not None
  138:         assert np.isnan(result.iloc[2, 0])
  139:         assert np.isnan(result.iloc[3, 0])
  140: 
  141:     def test_describe_categorical_columns(self):
  142:         # GH#11558
  143:         columns = pd.CategoricalIndex(["int1", "int2", "obj"], ordered=True, name="XXX")
  144:         df = DataFrame(
  145:             {
  146:                 "int1": [10, 20, 30, 40, 50],
  147:                 "int2": [10, 20, 30, 40, 50],
  148:                 "obj": ["A", 0, None, "X", 1],
  149:             },
  150:             columns=columns,
  151:         )
  152:         result = df.describe()
  153: 
  154:         exp_columns = pd.CategoricalIndex(
  155:             ["int1", "int2"],
  156:             categories=["int1", "int2", "obj"],
  157:             ordered=True,
  158:             name="XXX",
  159:         )
  160:         expected = DataFrame(
  161:             {
  162:                 "int1": [5, 30, df.int1.std(), 10, 20, 30, 40, 50],
  163:                 "int2": [5, 30, df.int2.std(), 10, 20, 30, 40, 50],
  164:             },
  165:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
  166:             columns=exp_columns,
  167:         )
  168: 
  169:         tm.assert_frame_equal(result, expected)
  170:         tm.assert_categorical_equal(result.columns.values, expected.columns.values)
  171: 
  172:     def test_describe_datetime_columns(self):
  173:         columns = pd.DatetimeIndex(
  174:             ["2011-01-01", "2011-02-01", "2011-03-01"],
  175:             freq="MS",
  176:             tz="US/Eastern",
  177:             name="XXX",
  178:         )
  179:         df = DataFrame(
  180:             {
  181:                 0: [10, 20, 30, 40, 50],
  182:                 1: [10, 20, 30, 40, 50],
  183:                 2: ["A", 0, None, "X", 1],
  184:             }
  185:         )
  186:         df.columns = columns
  187:         result = df.describe()
  188: 
  189:         exp_columns = pd.DatetimeIndex(
  190:             ["2011-01-01", "2011-02-01"], freq="MS", tz="US/Eastern", name="XXX"
  191:         )
  192:         expected = DataFrame(
  193:             {
  194:                 0: [5, 30, df.iloc[:, 0].std(), 10, 20, 30, 40, 50],
  195:                 1: [5, 30, df.iloc[:, 1].std(), 10, 20, 30, 40, 50],
  196:             },
  197:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
  198:         )
  199:         expected.columns = exp_columns
  200:         tm.assert_frame_equal(result, expected)
  201:         assert result.columns.freq == "MS"
  202:         assert result.columns.tz == expected.columns.tz
  203: 
  204:     def test_describe_timedelta_values(self):
  205:         # GH#6145
  206:         t1 = pd.timedelta_range("1 days", freq="D", periods=5)
  207:         t2 = pd.timedelta_range("1 hours", freq="h", periods=5)
  208:         df = DataFrame({"t1": t1, "t2": t2})
  209: 
  210:         expected = DataFrame(
  211:             {
  212:                 "t1": [
  213:                     5,
  214:                     pd.Timedelta("3 days"),
  215:                     df.iloc[:, 0].std(),
  216:                     pd.Timedelta("1 days"),
  217:                     pd.Timedelta("2 days"),
  218:                     pd.Timedelta("3 days"),
  219:                     pd.Timedelta("4 days"),
  220:                     pd.Timedelta("5 days"),
  221:                 ],
  222:                 "t2": [
  223:                     5,
  224:                     pd.Timedelta("3 hours"),
  225:                     df.iloc[:, 1].std(),
  226:                     pd.Timedelta("1 hours"),
  227:                     pd.Timedelta("2 hours"),
  228:                     pd.Timedelta("3 hours"),
  229:                     pd.Timedelta("4 hours"),
  230:                     pd.Timedelta("5 hours"),
  231:                 ],
  232:             },
  233:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
  234:         )
  235: 
  236:         result = df.describe()
  237:         tm.assert_frame_equal(result, expected)
  238: 
  239:         exp_repr = (
  240:             "                              t1                         t2\n"
  241:             "count                          5                          5\n"
  242:             "mean             3 days 00:00:00            0 days 03:00:00\n"
  243:             "std    1 days 13:56:50.394919273  0 days 01:34:52.099788303\n"
  244:             "min              1 days 00:00:00            0 days 01:00:00\n"
  245:             "25%              2 days 00:00:00            0 days 02:00:00\n"
  246:             "50%              3 days 00:00:00            0 days 03:00:00\n"
  247:             "75%              4 days 00:00:00            0 days 04:00:00\n"
  248:             "max              5 days 00:00:00            0 days 05:00:00"
  249:         )
  250:         assert repr(result) == exp_repr
  251: 
  252:     def test_describe_tz_values(self, tz_naive_fixture):
  253:         # GH#21332
  254:         tz = tz_naive_fixture
  255:         s1 = Series(range(5))
  256:         start = Timestamp(2018, 1, 1)
  257:         end = Timestamp(2018, 1, 5)
  258:         s2 = Series(date_range(start, end, tz=tz))
  259:         df = DataFrame({"s1": s1, "s2": s2})
  260: 
  261:         expected = DataFrame(
  262:             {
  263:                 "s1": [5, 2, 0, 1, 2, 3, 4, 1.581139],
  264:                 "s2": [
  265:                     5,
  266:                     Timestamp(2018, 1, 3).tz_localize(tz),
  267:                     start.tz_localize(tz),
  268:                     s2[1],
  269:                     s2[2],
  270:                     s2[3],
  271:                     end.tz_localize(tz),
  272:                     np.nan,
  273:                 ],
  274:             },
  275:             index=["count", "mean", "min", "25%", "50%", "75%", "max", "std"],
  276:         )
  277:         result = df.describe(include="all")
  278:         tm.assert_frame_equal(result, expected)
  279: 
  280:     def test_datetime_is_numeric_includes_datetime(self):
  281:         df = DataFrame({"a": date_range("2012", periods=3), "b": [1, 2, 3]})
  282:         result = df.describe()
  283:         expected = DataFrame(
  284:             {
  285:                 "a": [
  286:                     3,
  287:                     Timestamp("2012-01-02"),
  288:                     Timestamp("2012-01-01"),
  289:                     Timestamp("2012-01-01T12:00:00"),
  290:                     Timestamp("2012-01-02"),
  291:                     Timestamp("2012-01-02T12:00:00"),
  292:                     Timestamp("2012-01-03"),
  293:                     np.nan,
  294:                 ],
  295:                 "b": [3, 2, 1, 1.5, 2, 2.5, 3, 1],
  296:             },
  297:             index=["count", "mean", "min", "25%", "50%", "75%", "max", "std"],
  298:         )
  299:         tm.assert_frame_equal(result, expected)
  300: 
  301:     def test_describe_tz_values2(self):
  302:         tz = "CET"
  303:         s1 = Series(range(5))
  304:         start = Timestamp(2018, 1, 1)
  305:         end = Timestamp(2018, 1, 5)
  306:         s2 = Series(date_range(start, end, tz=tz))
  307:         df = DataFrame({"s1": s1, "s2": s2})
  308: 
  309:         s1_ = s1.describe()
  310:         s2_ = s2.describe()
  311:         idx = [
  312:             "count",
  313:             "mean",
  314:             "min",
  315:             "25%",
  316:             "50%",
  317:             "75%",
  318:             "max",
  319:             "std",
  320:         ]
  321:         expected = pd.concat([s1_, s2_], axis=1, keys=["s1", "s2"]).reindex(
  322:             idx, copy=False
  323:         )
  324: 
  325:         result = df.describe(include="all")
  326:         tm.assert_frame_equal(result, expected)
  327: 
  328:     def test_describe_percentiles_integer_idx(self):
  329:         # GH#26660
  330:         df = DataFrame({"x": [1]})
  331:         pct = np.linspace(0, 1, 10 + 1)
  332:         result = df.describe(percentiles=pct)
  333: 
  334:         expected = DataFrame(
  335:             {"x": [1.0, 1.0, np.nan, 1.0, *(1.0 for _ in pct), 1.0]},
  336:             index=[
  337:                 "count",
  338:                 "mean",
  339:                 "std",
  340:                 "min",
  341:                 "0%",
  342:                 "10%",
  343:                 "20%",
  344:                 "30%",
  345:                 "40%",
  346:                 "50%",
  347:                 "60%",
  348:                 "70%",
  349:                 "80%",
  350:                 "90%",
  351:                 "100%",
  352:                 "max",
  353:             ],
  354:         )
  355:         tm.assert_frame_equal(result, expected)
  356: 
  357:     def test_describe_does_not_raise_error_for_dictlike_elements(self):
  358:         # GH#32409
  359:         df = DataFrame([{"test": {"a": "1"}}, {"test": {"a": "2"}}])
  360:         expected = DataFrame(
  361:             {"test": [2, 2, {"a": "1"}, 1]}, index=["count", "unique", "top", "freq"]
  362:         )
  363:         result = df.describe()
  364:         tm.assert_frame_equal(result, expected)
  365: 
  366:     @pytest.mark.parametrize("exclude", ["x", "y", ["x", "y"], ["x", "z"]])
  367:     def test_describe_when_include_all_exclude_not_allowed(self, exclude):
  368:         """
  369:         When include is 'all', then setting exclude != None is not allowed.
  370:         """
  371:         df = DataFrame({"x": [1], "y": [2], "z": [3]})
  372:         msg = "exclude must be None when include is 'all'"
  373:         with pytest.raises(ValueError, match=msg):
  374:             df.describe(include="all", exclude=exclude)
  375: 
  376:     def test_describe_with_duplicate_columns(self):
  377:         df = DataFrame(
  378:             [[1, 1, 1], [2, 2, 2], [3, 3, 3]],
  379:             columns=["bar", "a", "a"],
  380:             dtype="float64",
  381:         )
  382:         result = df.describe()
  383:         ser = df.iloc[:, 0].describe()
  384:         expected = pd.concat([ser, ser, ser], keys=df.columns, axis=1)
  385:         tm.assert_frame_equal(result, expected)
  386: 
  387:     def test_ea_with_na(self, any_numeric_ea_dtype):
  388:         # GH#48778
  389: 
  390:         df = DataFrame({"a": [1, pd.NA, pd.NA], "b": pd.NA}, dtype=any_numeric_ea_dtype)
  391:         result = df.describe()
  392:         expected = DataFrame(
  393:             {"a": [1.0, 1.0, pd.NA] + [1.0] * 5, "b": [0.0] + [pd.NA] * 7},
  394:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
  395:             dtype="Float64",
  396:         )
  397:         tm.assert_frame_equal(result, expected)
  398: 
  399:     def test_describe_exclude_pa_dtype(self):
  400:         # GH#52570
  401:         pa = pytest.importorskip("pyarrow")
  402:         df = DataFrame(
  403:             {
  404:                 "a": Series([1, 2, 3], dtype=pd.ArrowDtype(pa.int8())),
  405:                 "b": Series([1, 2, 3], dtype=pd.ArrowDtype(pa.int16())),
  406:                 "c": Series([1, 2, 3], dtype=pd.ArrowDtype(pa.int32())),
  407:             }
  408:         )
  409:         result = df.describe(
  410:             include=pd.ArrowDtype(pa.int8()), exclude=pd.ArrowDtype(pa.int32())
  411:         )
  412:         expected = DataFrame(
  413:             {"a": [3, 2, 1, 1, 1.5, 2, 2.5, 3]},
  414:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
  415:             dtype=pd.ArrowDtype(pa.float64()),
  416:         )
  417:         tm.assert_frame_equal(result, expected)
