    1: from collections import (
    2:     OrderedDict,
    3:     defaultdict,
    4: )
    5: from datetime import datetime
    6: 
    7: import numpy as np
    8: import pytest
    9: import pytz
   10: 
   11: from pandas import (
   12:     NA,
   13:     DataFrame,
   14:     Index,
   15:     Interval,
   16:     MultiIndex,
   17:     Period,
   18:     Series,
   19:     Timedelta,
   20:     Timestamp,
   21: )
   22: import pandas._testing as tm
   23: 
   24: 
   25: class TestDataFrameToDict:
   26:     def test_to_dict_timestamp(self):
   27:         # GH#11247
   28:         # split/records producing np.datetime64 rather than Timestamps
   29:         # on datetime64[ns] dtypes only
   30: 
   31:         tsmp = Timestamp("20130101")
   32:         test_data = DataFrame({"A": [tsmp, tsmp], "B": [tsmp, tsmp]})
   33:         test_data_mixed = DataFrame({"A": [tsmp, tsmp], "B": [1, 2]})
   34: 
   35:         expected_records = [{"A": tsmp, "B": tsmp}, {"A": tsmp, "B": tsmp}]
   36:         expected_records_mixed = [{"A": tsmp, "B": 1}, {"A": tsmp, "B": 2}]
   37: 
   38:         assert test_data.to_dict(orient="records") == expected_records
   39:         assert test_data_mixed.to_dict(orient="records") == expected_records_mixed
   40: 
   41:         expected_series = {
   42:             "A": Series([tsmp, tsmp], name="A"),
   43:             "B": Series([tsmp, tsmp], name="B"),
   44:         }
   45:         expected_series_mixed = {
   46:             "A": Series([tsmp, tsmp], name="A"),
   47:             "B": Series([1, 2], name="B"),
   48:         }
   49: 
   50:         tm.assert_dict_equal(test_data.to_dict(orient="series"), expected_series)
   51:         tm.assert_dict_equal(
   52:             test_data_mixed.to_dict(orient="series"), expected_series_mixed
   53:         )
   54: 
   55:         expected_split = {
   56:             "index": [0, 1],
   57:             "data": [[tsmp, tsmp], [tsmp, tsmp]],
   58:             "columns": ["A", "B"],
   59:         }
   60:         expected_split_mixed = {
   61:             "index": [0, 1],
   62:             "data": [[tsmp, 1], [tsmp, 2]],
   63:             "columns": ["A", "B"],
   64:         }
   65: 
   66:         tm.assert_dict_equal(test_data.to_dict(orient="split"), expected_split)
   67:         tm.assert_dict_equal(
   68:             test_data_mixed.to_dict(orient="split"), expected_split_mixed
   69:         )
   70: 
   71:     def test_to_dict_index_not_unique_with_index_orient(self):
   72:         # GH#22801
   73:         # Data loss when indexes are not unique. Raise ValueError.
   74:         df = DataFrame({"a": [1, 2], "b": [0.5, 0.75]}, index=["A", "A"])
   75:         msg = "DataFrame index must be unique for orient='index'"
   76:         with pytest.raises(ValueError, match=msg):
   77:             df.to_dict(orient="index")
   78: 
   79:     def test_to_dict_invalid_orient(self):
   80:         df = DataFrame({"A": [0, 1]})
   81:         msg = "orient 'xinvalid' not understood"
   82:         with pytest.raises(ValueError, match=msg):
   83:             df.to_dict(orient="xinvalid")
   84: 
   85:     @pytest.mark.parametrize("orient", ["d", "l", "r", "sp", "s", "i"])
   86:     def test_to_dict_short_orient_raises(self, orient):
   87:         # GH#32515
   88:         df = DataFrame({"A": [0, 1]})
   89:         with pytest.raises(ValueError, match="not understood"):
   90:             df.to_dict(orient=orient)
   91: 
   92:     @pytest.mark.parametrize("mapping", [dict, defaultdict(list), OrderedDict])
   93:     def test_to_dict(self, mapping):
   94:         # orient= should only take the listed options
   95:         # see GH#32515
   96:         test_data = {"A": {"1": 1, "2": 2}, "B": {"1": "1", "2": "2", "3": "3"}}
   97: 
   98:         # GH#16122
   99:         recons_data = DataFrame(test_data).to_dict(into=mapping)
  100: 
  101:         for k, v in test_data.items():
  102:             for k2, v2 in v.items():
  103:                 assert v2 == recons_data[k][k2]
  104: 
  105:         recons_data = DataFrame(test_data).to_dict("list", into=mapping)
  106: 
  107:         for k, v in test_data.items():
  108:             for k2, v2 in v.items():
  109:                 assert v2 == recons_data[k][int(k2) - 1]
  110: 
  111:         recons_data = DataFrame(test_data).to_dict("series", into=mapping)
  112: 
  113:         for k, v in test_data.items():
  114:             for k2, v2 in v.items():
  115:                 assert v2 == recons_data[k][k2]
  116: 
  117:         recons_data = DataFrame(test_data).to_dict("split", into=mapping)
  118:         expected_split = {
  119:             "columns": ["A", "B"],
  120:             "index": ["1", "2", "3"],
  121:             "data": [[1.0, "1"], [2.0, "2"], [np.nan, "3"]],
  122:         }
  123:         tm.assert_dict_equal(recons_data, expected_split)
  124: 
  125:         recons_data = DataFrame(test_data).to_dict("records", into=mapping)
  126:         expected_records = [
  127:             {"A": 1.0, "B": "1"},
  128:             {"A": 2.0, "B": "2"},
  129:             {"A": np.nan, "B": "3"},
  130:         ]
  131:         assert isinstance(recons_data, list)
  132:         assert len(recons_data) == 3
  133:         for left, right in zip(recons_data, expected_records):
  134:             tm.assert_dict_equal(left, right)
  135: 
  136:         # GH#10844
  137:         recons_data = DataFrame(test_data).to_dict("index")
  138: 
  139:         for k, v in test_data.items():
  140:             for k2, v2 in v.items():
  141:                 assert v2 == recons_data[k2][k]
  142: 
  143:         df = DataFrame(test_data)
  144:         df["duped"] = df[df.columns[0]]
  145:         recons_data = df.to_dict("index")
  146:         comp_data = test_data.copy()
  147:         comp_data["duped"] = comp_data[df.columns[0]]
  148:         for k, v in comp_data.items():
  149:             for k2, v2 in v.items():
  150:                 assert v2 == recons_data[k2][k]
  151: 
  152:     @pytest.mark.parametrize("mapping", [list, defaultdict, []])
  153:     def test_to_dict_errors(self, mapping):
  154:         # GH#16122
  155:         df = DataFrame(np.random.default_rng(2).standard_normal((3, 3)))
  156:         msg = "|".join(
  157:             [
  158:                 "unsupported type: <class 'list'>",
  159:                 r"to_dict\(\) only accepts initialized defaultdicts",
  160:             ]
  161:         )
  162:         with pytest.raises(TypeError, match=msg):
  163:             df.to_dict(into=mapping)
  164: 
  165:     def test_to_dict_not_unique_warning(self):
  166:         # GH#16927: When converting to a dict, if a column has a non-unique name
  167:         # it will be dropped, throwing a warning.
  168:         df = DataFrame([[1, 2, 3]], columns=["a", "a", "b"])
  169:         with tm.assert_produces_warning(UserWarning):
  170:             df.to_dict()
  171: 
  172:     @pytest.mark.filterwarnings("ignore::UserWarning")
  173:     @pytest.mark.parametrize(
  174:         "orient,expected",
  175:         [
  176:             ("list", {"A": [2, 5], "B": [3, 6]}),
  177:             ("dict", {"A": {0: 2, 1: 5}, "B": {0: 3, 1: 6}}),
  178:         ],
  179:     )
  180:     def test_to_dict_not_unique(self, orient, expected):
  181:         # GH#54824: This is to make sure that dataframes with non-unique column
  182:         # would have uniform behavior throughout different orients
  183:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=["A", "A", "B"])
  184:         result = df.to_dict(orient)
  185:         assert result == expected
  186: 
  187:     # orient - orient argument to to_dict function
  188:     # item_getter - function for extracting value from
  189:     # the resulting dict using column name and index
  190:     @pytest.mark.parametrize(
  191:         "orient,item_getter",
  192:         [
  193:             ("dict", lambda d, col, idx: d[col][idx]),
  194:             ("records", lambda d, col, idx: d[idx][col]),
  195:             ("list", lambda d, col, idx: d[col][idx]),
  196:             ("split", lambda d, col, idx: d["data"][idx][d["columns"].index(col)]),
  197:             ("index", lambda d, col, idx: d[idx][col]),
  198:         ],
  199:     )
  200:     def test_to_dict_box_scalars(self, orient, item_getter):
  201:         # GH#14216, GH#23753
  202:         # make sure that we are boxing properly
  203:         df = DataFrame({"a": [1, 2], "b": [0.1, 0.2]})
  204:         result = df.to_dict(orient=orient)
  205:         assert isinstance(item_getter(result, "a", 0), int)
  206:         assert isinstance(item_getter(result, "b", 0), float)
  207: 
  208:     def test_to_dict_tz(self):
  209:         # GH#18372 When converting to dict with orient='records' columns of
  210:         # datetime that are tz-aware were not converted to required arrays
  211:         data = [
  212:             (datetime(2017, 11, 18, 21, 53, 0, 219225, tzinfo=pytz.utc),),
  213:             (datetime(2017, 11, 18, 22, 6, 30, 61810, tzinfo=pytz.utc),),
  214:         ]
  215:         df = DataFrame(list(data), columns=["d"])
  216: 
  217:         result = df.to_dict(orient="records")
  218:         expected = [
  219:             {"d": Timestamp("2017-11-18 21:53:00.219225+0000", tz=pytz.utc)},
  220:             {"d": Timestamp("2017-11-18 22:06:30.061810+0000", tz=pytz.utc)},
  221:         ]
  222:         tm.assert_dict_equal(result[0], expected[0])
  223:         tm.assert_dict_equal(result[1], expected[1])
  224: 
  225:     @pytest.mark.parametrize(
  226:         "into, expected",
  227:         [
  228:             (
  229:                 dict,
  230:                 {
  231:                     0: {"int_col": 1, "float_col": 1.0},
  232:                     1: {"int_col": 2, "float_col": 2.0},
  233:                     2: {"int_col": 3, "float_col": 3.0},
  234:                 },
  235:             ),
  236:             (
  237:                 OrderedDict,
  238:                 OrderedDict(
  239:                     [
  240:                         (0, {"int_col": 1, "float_col": 1.0}),
  241:                         (1, {"int_col": 2, "float_col": 2.0}),
  242:                         (2, {"int_col": 3, "float_col": 3.0}),
  243:                     ]
  244:                 ),
  245:             ),
  246:             (
  247:                 defaultdict(dict),
  248:                 defaultdict(
  249:                     dict,
  250:                     {
  251:                         0: {"int_col": 1, "float_col": 1.0},
  252:                         1: {"int_col": 2, "float_col": 2.0},
  253:                         2: {"int_col": 3, "float_col": 3.0},
  254:                     },
  255:                 ),
  256:             ),
  257:         ],
  258:     )
  259:     def test_to_dict_index_dtypes(self, into, expected):
  260:         # GH#18580
  261:         # When using to_dict(orient='index') on a dataframe with int
  262:         # and float columns only the int columns were cast to float
  263: 
  264:         df = DataFrame({"int_col": [1, 2, 3], "float_col": [1.0, 2.0, 3.0]})
  265: 
  266:         result = df.to_dict(orient="index", into=into)
  267:         cols = ["int_col", "float_col"]
  268:         result = DataFrame.from_dict(result, orient="index")[cols]
  269:         expected = DataFrame.from_dict(expected, orient="index")[cols]
  270:         tm.assert_frame_equal(result, expected)
  271: 
  272:     def test_to_dict_numeric_names(self):
  273:         # GH#24940
  274:         df = DataFrame({str(i): [i] for i in range(5)})
  275:         result = set(df.to_dict("records")[0].keys())
  276:         expected = set(df.columns)
  277:         assert result == expected
  278: 
  279:     def test_to_dict_wide(self):
  280:         # GH#24939
  281:         df = DataFrame({(f"A_{i:d}"): [i] for i in range(256)})
  282:         result = df.to_dict("records")[0]
  283:         expected = {f"A_{i:d}": i for i in range(256)}
  284:         assert result == expected
  285: 
  286:     @pytest.mark.parametrize(
  287:         "data,dtype",
  288:         (
  289:             ([True, True, False], bool),
  290:             [
  291:                 [
  292:                     datetime(2018, 1, 1),
  293:                     datetime(2019, 2, 2),
  294:                     datetime(2020, 3, 3),
  295:                 ],
  296:                 Timestamp,
  297:             ],
  298:             [[1.0, 2.0, 3.0], float],
  299:             [[1, 2, 3], int],
  300:             [["X", "Y", "Z"], str],
  301:         ),
  302:     )
  303:     def test_to_dict_orient_dtype(self, data, dtype):
  304:         # GH22620 & GH21256
  305: 
  306:         df = DataFrame({"a": data})
  307:         d = df.to_dict(orient="records")
  308:         assert all(type(record["a"]) is dtype for record in d)
  309: 
  310:     @pytest.mark.parametrize(
  311:         "data,expected_dtype",
  312:         (
  313:             [np.uint64(2), int],
  314:             [np.int64(-9), int],
  315:             [np.float64(1.1), float],
  316:             [np.bool_(True), bool],
  317:             [np.datetime64("2005-02-25"), Timestamp],
  318:         ),
  319:     )
  320:     def test_to_dict_scalar_constructor_orient_dtype(self, data, expected_dtype):
  321:         # GH22620 & GH21256
  322: 
  323:         df = DataFrame({"a": data}, index=[0])
  324:         d = df.to_dict(orient="records")
  325:         result = type(d[0]["a"])
  326:         assert result is expected_dtype
  327: 
  328:     def test_to_dict_mixed_numeric_frame(self):
  329:         # GH 12859
  330:         df = DataFrame({"a": [1.0], "b": [9.0]})
  331:         result = df.reset_index().to_dict("records")
  332:         expected = [{"index": 0, "a": 1.0, "b": 9.0}]
  333:         assert result == expected
  334: 
  335:     @pytest.mark.parametrize(
  336:         "index",
  337:         [
  338:             None,
  339:             Index(["aa", "bb"]),
  340:             Index(["aa", "bb"], name="cc"),
  341:             MultiIndex.from_tuples([("a", "b"), ("a", "c")]),
  342:             MultiIndex.from_tuples([("a", "b"), ("a", "c")], names=["n1", "n2"]),
  343:         ],
  344:     )
  345:     @pytest.mark.parametrize(
  346:         "columns",
  347:         [
  348:             ["x", "y"],
  349:             Index(["x", "y"]),
  350:             Index(["x", "y"], name="z"),
  351:             MultiIndex.from_tuples([("x", 1), ("y", 2)]),
  352:             MultiIndex.from_tuples([("x", 1), ("y", 2)], names=["z1", "z2"]),
  353:         ],
  354:     )
  355:     def test_to_dict_orient_tight(self, index, columns):
  356:         df = DataFrame.from_records(
  357:             [[1, 3], [2, 4]],
  358:             columns=columns,
  359:             index=index,
  360:         )
  361:         roundtrip = DataFrame.from_dict(df.to_dict(orient="tight"), orient="tight")
  362: 
  363:         tm.assert_frame_equal(df, roundtrip)
  364: 
  365:     @pytest.mark.parametrize(
  366:         "orient",
  367:         ["dict", "list", "split", "records", "index", "tight"],
  368:     )
  369:     @pytest.mark.parametrize(
  370:         "data,expected_types",
  371:         (
  372:             (
  373:                 {
  374:                     "a": [np.int64(1), 1, np.int64(3)],
  375:                     "b": [np.float64(1.0), 2.0, np.float64(3.0)],
  376:                     "c": [np.float64(1.0), 2, np.int64(3)],
  377:                     "d": [np.float64(1.0), "a", np.int64(3)],
  378:                     "e": [np.float64(1.0), ["a"], np.int64(3)],
  379:                     "f": [np.float64(1.0), ("a",), np.int64(3)],
  380:                 },
  381:                 {
  382:                     "a": [int, int, int],
  383:                     "b": [float, float, float],
  384:                     "c": [float, float, float],
  385:                     "d": [float, str, int],
  386:                     "e": [float, list, int],
  387:                     "f": [float, tuple, int],
  388:                 },
  389:             ),
  390:             (
  391:                 {
  392:                     "a": [1, 2, 3],
  393:                     "b": [1.1, 2.2, 3.3],
  394:                 },
  395:                 {
  396:                     "a": [int, int, int],
  397:                     "b": [float, float, float],
  398:                 },
  399:             ),
  400:             (  # Make sure we have one df which is all object type cols
  401:                 {
  402:                     "a": [1, "hello", 3],
  403:                     "b": [1.1, "world", 3.3],
  404:                 },
  405:                 {
  406:                     "a": [int, str, int],
  407:                     "b": [float, str, float],
  408:                 },
  409:             ),
  410:         ),
  411:     )
  412:     def test_to_dict_returns_native_types(self, orient, data, expected_types):
  413:         # GH 46751
  414:         # Tests we get back native types for all orient types
  415:         df = DataFrame(data)
  416:         result = df.to_dict(orient)
  417:         if orient == "dict":
  418:             assertion_iterator = (
  419:                 (i, key, value)
  420:                 for key, index_value_map in result.items()
  421:                 for i, value in index_value_map.items()
  422:             )
  423:         elif orient == "list":
  424:             assertion_iterator = (
  425:                 (i, key, value)
  426:                 for key, values in result.items()
  427:                 for i, value in enumerate(values)
  428:             )
  429:         elif orient in {"split", "tight"}:
  430:             assertion_iterator = (
  431:                 (i, key, result["data"][i][j])
  432:                 for i in result["index"]
  433:                 for j, key in enumerate(result["columns"])
  434:             )
  435:         elif orient == "records":
  436:             assertion_iterator = (
  437:                 (i, key, value)
  438:                 for i, record in enumerate(result)
  439:                 for key, value in record.items()
  440:             )
  441:         elif orient == "index":
  442:             assertion_iterator = (
  443:                 (i, key, value)
  444:                 for i, record in result.items()
  445:                 for key, value in record.items()
  446:             )
  447: 
  448:         for i, key, value in assertion_iterator:
  449:             assert value == data[key][i]
  450:             assert type(value) is expected_types[key][i]
  451: 
  452:     @pytest.mark.parametrize("orient", ["dict", "list", "series", "records", "index"])
  453:     def test_to_dict_index_false_error(self, orient):
  454:         # GH#46398
  455:         df = DataFrame({"col1": [1, 2], "col2": [3, 4]}, index=["row1", "row2"])
  456:         msg = "'index=False' is only valid when 'orient' is 'split' or 'tight'"
  457:         with pytest.raises(ValueError, match=msg):
  458:             df.to_dict(orient=orient, index=False)
  459: 
  460:     @pytest.mark.parametrize(
  461:         "orient, expected",
  462:         [
  463:             ("split", {"columns": ["col1", "col2"], "data": [[1, 3], [2, 4]]}),
  464:             (
  465:                 "tight",
  466:                 {
  467:                     "columns": ["col1", "col2"],
  468:                     "data": [[1, 3], [2, 4]],
  469:                     "column_names": [None],
  470:                 },
  471:             ),
  472:         ],
  473:     )
  474:     def test_to_dict_index_false(self, orient, expected):
  475:         # GH#46398
  476:         df = DataFrame({"col1": [1, 2], "col2": [3, 4]}, index=["row1", "row2"])
  477:         result = df.to_dict(orient=orient, index=False)
  478:         tm.assert_dict_equal(result, expected)
  479: 
  480:     @pytest.mark.parametrize(
  481:         "orient, expected",
  482:         [
  483:             ("dict", {"a": {0: 1, 1: None}}),
  484:             ("list", {"a": [1, None]}),
  485:             ("split", {"index": [0, 1], "columns": ["a"], "data": [[1], [None]]}),
  486:             (
  487:                 "tight",
  488:                 {
  489:                     "index": [0, 1],
  490:                     "columns": ["a"],
  491:                     "data": [[1], [None]],
  492:                     "index_names": [None],
  493:                     "column_names": [None],
  494:                 },
  495:             ),
  496:             ("records", [{"a": 1}, {"a": None}]),
  497:             ("index", {0: {"a": 1}, 1: {"a": None}}),
  498:         ],
  499:     )
  500:     def test_to_dict_na_to_none(self, orient, expected):
  501:         # GH#50795
  502:         df = DataFrame({"a": [1, NA]}, dtype="Int64")
  503:         result = df.to_dict(orient=orient)
  504:         assert result == expected
  505: 
  506:     def test_to_dict_masked_native_python(self):
  507:         # GH#34665
  508:         df = DataFrame({"a": Series([1, 2], dtype="Int64"), "B": 1})
  509:         result = df.to_dict(orient="records")
  510:         assert isinstance(result[0]["a"], int)
  511: 
  512:         df = DataFrame({"a": Series([1, NA], dtype="Int64"), "B": 1})
  513:         result = df.to_dict(orient="records")
  514:         assert isinstance(result[0]["a"], int)
  515: 
  516:     def test_to_dict_pos_args_deprecation(self):
  517:         # GH-54229
  518:         df = DataFrame({"a": [1, 2, 3]})
  519:         msg = (
  520:             r"Starting with pandas version 3.0 all arguments of to_dict except for the "
  521:             r"argument 'orient' will be keyword-only."
  522:         )
  523:         with tm.assert_produces_warning(FutureWarning, match=msg):
  524:             df.to_dict("records", {})
  525: 
  526: 
  527: @pytest.mark.parametrize(
  528:     "val", [Timestamp(2020, 1, 1), Timedelta(1), Period("2020"), Interval(1, 2)]
  529: )
  530: def test_to_dict_list_pd_scalars(val):
  531:     # GH 54824
  532:     df = DataFrame({"a": [val]})
  533:     result = df.to_dict(orient="list")
  534:     expected = {"a": [val]}
  535:     assert result == expected
