    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: import inspect
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: from pandas._libs.tslibs.timezones import dateutil_gettz as gettz
   11: from pandas.compat import (
   12:     IS64,
   13:     is_platform_windows,
   14: )
   15: from pandas.compat.numpy import np_version_gt2
   16: import pandas.util._test_decorators as td
   17: 
   18: import pandas as pd
   19: from pandas import (
   20:     Categorical,
   21:     CategoricalIndex,
   22:     DataFrame,
   23:     Index,
   24:     MultiIndex,
   25:     Series,
   26:     date_range,
   27:     isna,
   28: )
   29: import pandas._testing as tm
   30: from pandas.api.types import CategoricalDtype
   31: 
   32: 
   33: class TestReindexSetIndex:
   34:     # Tests that check both reindex and set_index
   35: 
   36:     def test_dti_set_index_reindex_datetimeindex(self):
   37:         # GH#6631
   38:         df = DataFrame(np.random.default_rng(2).random(6))
   39:         idx1 = date_range("2011/01/01", periods=6, freq="ME", tz="US/Eastern")
   40:         idx2 = date_range("2013", periods=6, freq="YE", tz="Asia/Tokyo")
   41: 
   42:         df = df.set_index(idx1)
   43:         tm.assert_index_equal(df.index, idx1)
   44:         df = df.reindex(idx2)
   45:         tm.assert_index_equal(df.index, idx2)
   46: 
   47:     def test_dti_set_index_reindex_freq_with_tz(self):
   48:         # GH#11314 with tz
   49:         index = date_range(
   50:             datetime(2015, 10, 1), datetime(2015, 10, 1, 23), freq="h", tz="US/Eastern"
   51:         )
   52:         df = DataFrame(
   53:             np.random.default_rng(2).standard_normal((24, 1)),
   54:             columns=["a"],
   55:             index=index,
   56:         )
   57:         new_index = date_range(
   58:             datetime(2015, 10, 2), datetime(2015, 10, 2, 23), freq="h", tz="US/Eastern"
   59:         )
   60: 
   61:         result = df.set_index(new_index)
   62:         assert result.index.freq == index.freq
   63: 
   64:     def test_set_reset_index_intervalindex(self):
   65:         df = DataFrame({"A": range(10)})
   66:         ser = pd.cut(df.A, 5)
   67:         df["B"] = ser
   68:         df = df.set_index("B")
   69: 
   70:         df = df.reset_index()
   71: 
   72:     def test_setitem_reset_index_dtypes(self):
   73:         # GH 22060
   74:         df = DataFrame(columns=["a", "b", "c"]).astype(
   75:             {"a": "datetime64[ns]", "b": np.int64, "c": np.float64}
   76:         )
   77:         df1 = df.set_index(["a"])
   78:         df1["d"] = []
   79:         result = df1.reset_index()
   80:         expected = DataFrame(columns=["a", "b", "c", "d"], index=range(0)).astype(
   81:             {"a": "datetime64[ns]", "b": np.int64, "c": np.float64, "d": np.float64}
   82:         )
   83:         tm.assert_frame_equal(result, expected)
   84: 
   85:         df2 = df.set_index(["a", "b"])
   86:         df2["d"] = []
   87:         result = df2.reset_index()
   88:         tm.assert_frame_equal(result, expected)
   89: 
   90:     @pytest.mark.parametrize(
   91:         "timezone, year, month, day, hour",
   92:         [["America/Chicago", 2013, 11, 3, 1], ["America/Santiago", 2021, 4, 3, 23]],
   93:     )
   94:     def test_reindex_timestamp_with_fold(self, timezone, year, month, day, hour):
   95:         # see gh-40817
   96:         test_timezone = gettz(timezone)
   97:         transition_1 = pd.Timestamp(
   98:             year=year,
   99:             month=month,
  100:             day=day,
  101:             hour=hour,
  102:             minute=0,
  103:             fold=0,
  104:             tzinfo=test_timezone,
  105:         )
  106:         transition_2 = pd.Timestamp(
  107:             year=year,
  108:             month=month,
  109:             day=day,
  110:             hour=hour,
  111:             minute=0,
  112:             fold=1,
  113:             tzinfo=test_timezone,
  114:         )
  115:         df = (
  116:             DataFrame({"index": [transition_1, transition_2], "vals": ["a", "b"]})
  117:             .set_index("index")
  118:             .reindex(["1", "2"])
  119:         )
  120:         exp = DataFrame({"index": ["1", "2"], "vals": [np.nan, np.nan]}).set_index(
  121:             "index"
  122:         )
  123:         exp = exp.astype(df.vals.dtype)
  124:         tm.assert_frame_equal(
  125:             df,
  126:             exp,
  127:         )
  128: 
  129: 
  130: class TestDataFrameSelectReindex:
  131:     # These are specific reindex-based tests; other indexing tests should go in
  132:     # test_indexing
  133: 
  134:     @pytest.mark.xfail(
  135:         not IS64 or (is_platform_windows() and not np_version_gt2),
  136:         reason="Passes int32 values to DatetimeArray in make_na_array on "
  137:         "windows, 32bit linux builds",
  138:     )
  139:     @td.skip_array_manager_not_yet_implemented
  140:     def test_reindex_tzaware_fill_value(self):
  141:         # GH#52586
  142:         df = DataFrame([[1]])
  143: 
  144:         ts = pd.Timestamp("2023-04-10 17:32", tz="US/Pacific")
  145:         res = df.reindex([0, 1], axis=1, fill_value=ts)
  146:         assert res.dtypes[1] == pd.DatetimeTZDtype(unit="s", tz="US/Pacific")
  147:         expected = DataFrame({0: [1], 1: [ts]})
  148:         expected[1] = expected[1].astype(res.dtypes[1])
  149:         tm.assert_frame_equal(res, expected)
  150: 
  151:         per = ts.tz_localize(None).to_period("s")
  152:         res = df.reindex([0, 1], axis=1, fill_value=per)
  153:         assert res.dtypes[1] == pd.PeriodDtype("s")
  154:         expected = DataFrame({0: [1], 1: [per]})
  155:         tm.assert_frame_equal(res, expected)
  156: 
  157:         interval = pd.Interval(ts, ts + pd.Timedelta(seconds=1))
  158:         res = df.reindex([0, 1], axis=1, fill_value=interval)
  159:         assert res.dtypes[1] == pd.IntervalDtype("datetime64[s, US/Pacific]", "right")
  160:         expected = DataFrame({0: [1], 1: [interval]})
  161:         expected[1] = expected[1].astype(res.dtypes[1])
  162:         tm.assert_frame_equal(res, expected)
  163: 
  164:     def test_reindex_copies(self):
  165:         # based on asv time_reindex_axis1
  166:         N = 10
  167:         df = DataFrame(np.random.default_rng(2).standard_normal((N * 10, N)))
  168:         cols = np.arange(N)
  169:         np.random.default_rng(2).shuffle(cols)
  170: 
  171:         result = df.reindex(columns=cols, copy=True)
  172:         assert not np.shares_memory(result[0]._values, df[0]._values)
  173: 
  174:         # pass both columns and index
  175:         result2 = df.reindex(columns=cols, index=df.index, copy=True)
  176:         assert not np.shares_memory(result2[0]._values, df[0]._values)
  177: 
  178:     def test_reindex_copies_ea(self, using_copy_on_write):
  179:         # https://github.com/pandas-dev/pandas/pull/51197
  180:         # also ensure to honor copy keyword for ExtensionDtypes
  181:         N = 10
  182:         df = DataFrame(
  183:             np.random.default_rng(2).standard_normal((N * 10, N)), dtype="Float64"
  184:         )
  185:         cols = np.arange(N)
  186:         np.random.default_rng(2).shuffle(cols)
  187: 
  188:         result = df.reindex(columns=cols, copy=True)
  189:         if using_copy_on_write:
  190:             assert np.shares_memory(result[0].array._data, df[0].array._data)
  191:         else:
  192:             assert not np.shares_memory(result[0].array._data, df[0].array._data)
  193: 
  194:         # pass both columns and index
  195:         result2 = df.reindex(columns=cols, index=df.index, copy=True)
  196:         if using_copy_on_write:
  197:             assert np.shares_memory(result2[0].array._data, df[0].array._data)
  198:         else:
  199:             assert not np.shares_memory(result2[0].array._data, df[0].array._data)
  200: 
  201:     @td.skip_array_manager_not_yet_implemented
  202:     def test_reindex_date_fill_value(self):
  203:         # passing date to dt64 is deprecated; enforced in 2.0 to cast to object
  204:         arr = date_range("2016-01-01", periods=6).values.reshape(3, 2)
  205:         df = DataFrame(arr, columns=["A", "B"], index=range(3))
  206: 
  207:         ts = df.iloc[0, 0]
  208:         fv = ts.date()
  209: 
  210:         res = df.reindex(index=range(4), columns=["A", "B", "C"], fill_value=fv)
  211: 
  212:         expected = DataFrame(
  213:             {"A": df["A"].tolist() + [fv], "B": df["B"].tolist() + [fv], "C": [fv] * 4},
  214:             dtype=object,
  215:         )
  216:         tm.assert_frame_equal(res, expected)
  217: 
  218:         # only reindexing rows
  219:         res = df.reindex(index=range(4), fill_value=fv)
  220:         tm.assert_frame_equal(res, expected[["A", "B"]])
  221: 
  222:         # same with a datetime-castable str
  223:         res = df.reindex(
  224:             index=range(4), columns=["A", "B", "C"], fill_value="2016-01-01"
  225:         )
  226:         expected = DataFrame(
  227:             {"A": df["A"].tolist() + [ts], "B": df["B"].tolist() + [ts], "C": [ts] * 4},
  228:         )
  229:         tm.assert_frame_equal(res, expected)
  230: 
  231:     def test_reindex_with_multi_index(self):
  232:         # https://github.com/pandas-dev/pandas/issues/29896
  233:         # tests for reindexing a multi-indexed DataFrame with a new MultiIndex
  234:         #
  235:         # confirms that we can reindex a multi-indexed DataFrame with a new
  236:         # MultiIndex object correctly when using no filling, backfilling, and
  237:         # padding
  238:         #
  239:         # The DataFrame, `df`, used in this test is:
  240:         #       c
  241:         #  a b
  242:         # -1 0  A
  243:         #    1  B
  244:         #    2  C
  245:         #    3  D
  246:         #    4  E
  247:         #    5  F
  248:         #    6  G
  249:         #  0 0  A
  250:         #    1  B
  251:         #    2  C
  252:         #    3  D
  253:         #    4  E
  254:         #    5  F
  255:         #    6  G
  256:         #  1 0  A
  257:         #    1  B
  258:         #    2  C
  259:         #    3  D
  260:         #    4  E
  261:         #    5  F
  262:         #    6  G
  263:         #
  264:         # and the other MultiIndex, `new_multi_index`, is:
  265:         # 0: 0 0.5
  266:         # 1:   2.0
  267:         # 2:   5.0
  268:         # 3:   5.8
  269:         df = DataFrame(
  270:             {
  271:                 "a": [-1] * 7 + [0] * 7 + [1] * 7,
  272:                 "b": list(range(7)) * 3,
  273:                 "c": ["A", "B", "C", "D", "E", "F", "G"] * 3,
  274:             }
  275:         ).set_index(["a", "b"])
  276:         new_index = [0.5, 2.0, 5.0, 5.8]
  277:         new_multi_index = MultiIndex.from_product([[0], new_index], names=["a", "b"])
  278: 
  279:         # reindexing w/o a `method` value
  280:         reindexed = df.reindex(new_multi_index)
  281:         expected = DataFrame(
  282:             {"a": [0] * 4, "b": new_index, "c": [np.nan, "C", "F", np.nan]}
  283:         ).set_index(["a", "b"])
  284:         tm.assert_frame_equal(expected, reindexed)
  285: 
  286:         # reindexing with backfilling
  287:         expected = DataFrame(
  288:             {"a": [0] * 4, "b": new_index, "c": ["B", "C", "F", "G"]}
  289:         ).set_index(["a", "b"])
  290:         reindexed_with_backfilling = df.reindex(new_multi_index, method="bfill")
  291:         tm.assert_frame_equal(expected, reindexed_with_backfilling)
  292: 
  293:         reindexed_with_backfilling = df.reindex(new_multi_index, method="backfill")
  294:         tm.assert_frame_equal(expected, reindexed_with_backfilling)
  295: 
  296:         # reindexing with padding
  297:         expected = DataFrame(
  298:             {"a": [0] * 4, "b": new_index, "c": ["A", "C", "F", "F"]}
  299:         ).set_index(["a", "b"])
  300:         reindexed_with_padding = df.reindex(new_multi_index, method="pad")
  301:         tm.assert_frame_equal(expected, reindexed_with_padding)
  302: 
  303:         reindexed_with_padding = df.reindex(new_multi_index, method="ffill")
  304:         tm.assert_frame_equal(expected, reindexed_with_padding)
  305: 
  306:     @pytest.mark.parametrize(
  307:         "method,expected_values",
  308:         [
  309:             ("nearest", [0, 1, 1, 2]),
  310:             ("pad", [np.nan, 0, 1, 1]),
  311:             ("backfill", [0, 1, 2, 2]),
  312:         ],
  313:     )
  314:     def test_reindex_methods(self, method, expected_values):
  315:         df = DataFrame({"x": list(range(5))})
  316:         target = np.array([-0.1, 0.9, 1.1, 1.5])
  317: 
  318:         expected = DataFrame({"x": expected_values}, index=target)
  319:         actual = df.reindex(target, method=method)
  320:         tm.assert_frame_equal(expected, actual)
  321: 
  322:         actual = df.reindex(target, method=method, tolerance=1)
  323:         tm.assert_frame_equal(expected, actual)
  324:         actual = df.reindex(target, method=method, tolerance=[1, 1, 1, 1])
  325:         tm.assert_frame_equal(expected, actual)
  326: 
  327:         e2 = expected[::-1]
  328:         actual = df.reindex(target[::-1], method=method)
  329:         tm.assert_frame_equal(e2, actual)
  330: 
  331:         new_order = [3, 0, 2, 1]
  332:         e2 = expected.iloc[new_order]
  333:         actual = df.reindex(target[new_order], method=method)
  334:         tm.assert_frame_equal(e2, actual)
  335: 
  336:         switched_method = (
  337:             "pad" if method == "backfill" else "backfill" if method == "pad" else method
  338:         )
  339:         actual = df[::-1].reindex(target, method=switched_method)
  340:         tm.assert_frame_equal(expected, actual)
  341: 
  342:     def test_reindex_methods_nearest_special(self):
  343:         df = DataFrame({"x": list(range(5))})
  344:         target = np.array([-0.1, 0.9, 1.1, 1.5])
  345: 
  346:         expected = DataFrame({"x": [0, 1, 1, np.nan]}, index=target)
  347:         actual = df.reindex(target, method="nearest", tolerance=0.2)
  348:         tm.assert_frame_equal(expected, actual)
  349: 
  350:         expected = DataFrame({"x": [0, np.nan, 1, np.nan]}, index=target)
  351:         actual = df.reindex(target, method="nearest", tolerance=[0.5, 0.01, 0.4, 0.1])
  352:         tm.assert_frame_equal(expected, actual)
  353: 
  354:     def test_reindex_nearest_tz(self, tz_aware_fixture):
  355:         # GH26683
  356:         tz = tz_aware_fixture
  357:         idx = date_range("2019-01-01", periods=5, tz=tz)
  358:         df = DataFrame({"x": list(range(5))}, index=idx)
  359: 
  360:         expected = df.head(3)
  361:         actual = df.reindex(idx[:3], method="nearest")
  362:         tm.assert_frame_equal(expected, actual)
  363: 
  364:     def test_reindex_nearest_tz_empty_frame(self):
  365:         # https://github.com/pandas-dev/pandas/issues/31964
  366:         dti = pd.DatetimeIndex(["2016-06-26 14:27:26+00:00"])
  367:         df = DataFrame(index=pd.DatetimeIndex(["2016-07-04 14:00:59+00:00"]))
  368:         expected = DataFrame(index=dti)
  369:         result = df.reindex(dti, method="nearest")
  370:         tm.assert_frame_equal(result, expected)
  371: 
  372:     def test_reindex_frame_add_nat(self):
  373:         rng = date_range("1/1/2000 00:00:00", periods=10, freq="10s")
  374:         df = DataFrame(
  375:             {"A": np.random.default_rng(2).standard_normal(len(rng)), "B": rng}
  376:         )
  377: 
  378:         result = df.reindex(range(15))
  379:         assert np.issubdtype(result["B"].dtype, np.dtype("M8[ns]"))
  380: 
  381:         mask = isna(result)["B"]
  382:         assert mask[-5:].all()
  383:         assert not mask[:-5].any()
  384: 
  385:     @pytest.mark.parametrize(
  386:         "method, exp_values",
  387:         [("ffill", [0, 1, 2, 3]), ("bfill", [1.0, 2.0, 3.0, np.nan])],
  388:     )
  389:     def test_reindex_frame_tz_ffill_bfill(self, frame_or_series, method, exp_values):
  390:         # GH#38566
  391:         obj = frame_or_series(
  392:             [0, 1, 2, 3],
  393:             index=date_range("2020-01-01 00:00:00", periods=4, freq="h", tz="UTC"),
  394:         )
  395:         new_index = date_range("2020-01-01 00:01:00", periods=4, freq="h", tz="UTC")
  396:         result = obj.reindex(new_index, method=method, tolerance=pd.Timedelta("1 hour"))
  397:         expected = frame_or_series(exp_values, index=new_index)
  398:         tm.assert_equal(result, expected)
  399: 
  400:     def test_reindex_limit(self):
  401:         # GH 28631
  402:         data = [["A", "A", "A"], ["B", "B", "B"], ["C", "C", "C"], ["D", "D", "D"]]
  403:         exp_data = [
  404:             ["A", "A", "A"],
  405:             ["B", "B", "B"],
  406:             ["C", "C", "C"],
  407:             ["D", "D", "D"],
  408:             ["D", "D", "D"],
  409:             [np.nan, np.nan, np.nan],
  410:         ]
  411:         df = DataFrame(data)
  412:         result = df.reindex([0, 1, 2, 3, 4, 5], method="ffill", limit=1)
  413:         expected = DataFrame(exp_data)
  414:         tm.assert_frame_equal(result, expected)
  415: 
  416:     @pytest.mark.parametrize(
  417:         "idx, check_index_type",
  418:         [
  419:             [["C", "B", "A"], True],
  420:             [["F", "C", "A", "D"], True],
  421:             [["A"], True],
  422:             [["A", "B", "C"], True],
  423:             [["C", "A", "B"], True],
  424:             [["C", "B"], True],
  425:             [["C", "A"], True],
  426:             [["A", "B"], True],
  427:             [["B", "A", "C"], True],
  428:             # reindex by these causes different MultiIndex levels
  429:             [["D", "F"], False],
  430:             [["A", "C", "B"], False],
  431:         ],
  432:     )
  433:     def test_reindex_level_verify_first_level(self, idx, check_index_type):
  434:         df = DataFrame(
  435:             {
  436:                 "jim": list("B" * 4 + "A" * 2 + "C" * 3),
  437:                 "joe": list("abcdeabcd")[::-1],
  438:                 "jolie": [10, 20, 30] * 3,
  439:                 "joline": np.random.default_rng(2).integers(0, 1000, 9),
  440:             }
  441:         )
  442:         icol = ["jim", "joe", "jolie"]
  443: 
  444:         def f(val):
  445:             return np.nonzero((df["jim"] == val).to_numpy())[0]
  446: 
  447:         i = np.concatenate(list(map(f, idx)))
  448:         left = df.set_index(icol).reindex(idx, level="jim")
  449:         right = df.iloc[i].set_index(icol)
  450:         tm.assert_frame_equal(left, right, check_index_type=check_index_type)
  451: 
  452:     @pytest.mark.parametrize(
  453:         "idx",
  454:         [
  455:             ("mid",),
  456:             ("mid", "btm"),
  457:             ("mid", "btm", "top"),
  458:             ("mid",),
  459:             ("mid", "top"),
  460:             ("mid", "top", "btm"),
  461:             ("btm",),
  462:             ("btm", "mid"),
  463:             ("btm", "mid", "top"),
  464:             ("btm",),
  465:             ("btm", "top"),
  466:             ("btm", "top", "mid"),
  467:             ("top",),
  468:             ("top", "mid"),
  469:             ("top", "mid", "btm"),
  470:             ("top",),
  471:             ("top", "btm"),
  472:             ("top", "btm", "mid"),
  473:         ],
  474:     )
  475:     def test_reindex_level_verify_first_level_repeats(self, idx):
  476:         df = DataFrame(
  477:             {
  478:                 "jim": ["mid"] * 5 + ["btm"] * 8 + ["top"] * 7,
  479:                 "joe": ["3rd"] * 2
  480:                 + ["1st"] * 3
  481:                 + ["2nd"] * 3
  482:                 + ["1st"] * 2
  483:                 + ["3rd"] * 3
  484:                 + ["1st"] * 2
  485:                 + ["3rd"] * 3
  486:                 + ["2nd"] * 2,
  487:                 # this needs to be jointly unique with jim and joe or
  488:                 # reindexing will fail ~1.5% of the time, this works
  489:                 # out to needing unique groups of same size as joe
  490:                 "jolie": np.concatenate(
  491:                     [
  492:                         np.random.default_rng(2).choice(1000, x, replace=False)
  493:                         for x in [2, 3, 3, 2, 3, 2, 3, 2]
  494:                     ]
  495:                 ),
  496:                 "joline": np.random.default_rng(2).standard_normal(20).round(3) * 10,
  497:             }
  498:         )
  499:         icol = ["jim", "joe", "jolie"]
  500: 
  501:         def f(val):
  502:             return np.nonzero((df["jim"] == val).to_numpy())[0]
  503: 
  504:         i = np.concatenate(list(map(f, idx)))
  505:         left = df.set_index(icol).reindex(idx, level="jim")
  506:         right = df.iloc[i].set_index(icol)
  507:         tm.assert_frame_equal(left, right)
  508: 
  509:     @pytest.mark.parametrize(
  510:         "idx, indexer",
  511:         [
  512:             [
  513:                 ["1st", "2nd", "3rd"],
  514:                 [2, 3, 4, 0, 1, 8, 9, 5, 6, 7, 10, 11, 12, 13, 14, 18, 19, 15, 16, 17],
  515:             ],
  516:             [
  517:                 ["3rd", "2nd", "1st"],
  518:                 [0, 1, 2, 3, 4, 10, 11, 12, 5, 6, 7, 8, 9, 15, 16, 17, 18, 19, 13, 14],
  519:             ],
  520:             [["2nd", "3rd"], [0, 1, 5, 6, 7, 10, 11, 12, 18, 19, 15, 16, 17]],
  521:             [["3rd", "1st"], [0, 1, 2, 3, 4, 10, 11, 12, 8, 9, 15, 16, 17, 13, 14]],
  522:         ],
  523:     )
  524:     def test_reindex_level_verify_repeats(self, idx, indexer):
  525:         df = DataFrame(
  526:             {
  527:                 "jim": ["mid"] * 5 + ["btm"] * 8 + ["top"] * 7,
  528:                 "joe": ["3rd"] * 2
  529:                 + ["1st"] * 3
  530:                 + ["2nd"] * 3
  531:                 + ["1st"] * 2
  532:                 + ["3rd"] * 3
  533:                 + ["1st"] * 2
  534:                 + ["3rd"] * 3
  535:                 + ["2nd"] * 2,
  536:                 # this needs to be jointly unique with jim and joe or
  537:                 # reindexing will fail ~1.5% of the time, this works
  538:                 # out to needing unique groups of same size as joe
  539:                 "jolie": np.concatenate(
  540:                     [
  541:                         np.random.default_rng(2).choice(1000, x, replace=False)
  542:                         for x in [2, 3, 3, 2, 3, 2, 3, 2]
  543:                     ]
  544:                 ),
  545:                 "joline": np.random.default_rng(2).standard_normal(20).round(3) * 10,
  546:             }
  547:         )
  548:         icol = ["jim", "joe", "jolie"]
  549:         left = df.set_index(icol).reindex(idx, level="joe")
  550:         right = df.iloc[indexer].set_index(icol)
  551:         tm.assert_frame_equal(left, right)
  552: 
  553:     @pytest.mark.parametrize(
  554:         "idx, indexer, check_index_type",
  555:         [
  556:             [list("abcde"), [3, 2, 1, 0, 5, 4, 8, 7, 6], True],
  557:             [list("abcd"), [3, 2, 1, 0, 5, 8, 7, 6], True],
  558:             [list("abc"), [3, 2, 1, 8, 7, 6], True],
  559:             [list("eca"), [1, 3, 4, 6, 8], True],
  560:             [list("edc"), [0, 1, 4, 5, 6], True],
  561:             [list("eadbc"), [3, 0, 2, 1, 4, 5, 8, 7, 6], True],
  562:             [list("edwq"), [0, 4, 5], True],
  563:             [list("wq"), [], False],
  564:         ],
  565:     )
  566:     def test_reindex_level_verify(self, idx, indexer, check_index_type):
  567:         df = DataFrame(
  568:             {
  569:                 "jim": list("B" * 4 + "A" * 2 + "C" * 3),
  570:                 "joe": list("abcdeabcd")[::-1],
  571:                 "jolie": [10, 20, 30] * 3,
  572:                 "joline": np.random.default_rng(2).integers(0, 1000, 9),
  573:             }
  574:         )
  575:         icol = ["jim", "joe", "jolie"]
  576:         left = df.set_index(icol).reindex(idx, level="joe")
  577:         right = df.iloc[indexer].set_index(icol)
  578:         tm.assert_frame_equal(left, right, check_index_type=check_index_type)
  579: 
  580:     def test_non_monotonic_reindex_methods(self):
  581:         dr = date_range("2013-08-01", periods=6, freq="B")
  582:         data = np.random.default_rng(2).standard_normal((6, 1))
  583:         df = DataFrame(data, index=dr, columns=list("A"))
  584:         df_rev = DataFrame(data, index=dr[[3, 4, 5] + [0, 1, 2]], columns=list("A"))
  585:         # index is not monotonic increasing or decreasing
  586:         msg = "index must be monotonic increasing or decreasing"
  587:         with pytest.raises(ValueError, match=msg):
  588:             df_rev.reindex(df.index, method="pad")
  589:         with pytest.raises(ValueError, match=msg):
  590:             df_rev.reindex(df.index, method="ffill")
  591:         with pytest.raises(ValueError, match=msg):
  592:             df_rev.reindex(df.index, method="bfill")
  593:         with pytest.raises(ValueError, match=msg):
  594:             df_rev.reindex(df.index, method="nearest")
  595: 
  596:     def test_reindex_sparse(self):
  597:         # https://github.com/pandas-dev/pandas/issues/35286
  598:         df = DataFrame(
  599:             {"A": [0, 1], "B": pd.array([0, 1], dtype=pd.SparseDtype("int64", 0))}
  600:         )
  601:         result = df.reindex([0, 2])
  602:         expected = DataFrame(
  603:             {
  604:                 "A": [0.0, np.nan],
  605:                 "B": pd.array([0.0, np.nan], dtype=pd.SparseDtype("float64", 0.0)),
  606:             },
  607:             index=[0, 2],
  608:         )
  609:         tm.assert_frame_equal(result, expected)
  610: 
  611:     def test_reindex(self, float_frame, using_copy_on_write):
  612:         datetime_series = Series(
  613:             np.arange(30, dtype=np.float64), index=date_range("2020-01-01", periods=30)
  614:         )
  615: 
  616:         newFrame = float_frame.reindex(datetime_series.index)
  617: 
  618:         for col in newFrame.columns:
  619:             for idx, val in newFrame[col].items():
  620:                 if idx in float_frame.index:
  621:                     if np.isnan(val):
  622:                         assert np.isnan(float_frame[col][idx])
  623:                     else:
  624:                         assert val == float_frame[col][idx]
  625:                 else:
  626:                     assert np.isnan(val)
  627: 
  628:         for col, series in newFrame.items():
  629:             tm.assert_index_equal(series.index, newFrame.index)
  630:         emptyFrame = float_frame.reindex(Index([]))
  631:         assert len(emptyFrame.index) == 0
  632: 
  633:         # Cython code should be unit-tested directly
  634:         nonContigFrame = float_frame.reindex(datetime_series.index[::2])
  635: 
  636:         for col in nonContigFrame.columns:
  637:             for idx, val in nonContigFrame[col].items():
  638:                 if idx in float_frame.index:
  639:                     if np.isnan(val):
  640:                         assert np.isnan(float_frame[col][idx])
  641:                     else:
  642:                         assert val == float_frame[col][idx]
  643:                 else:
  644:                     assert np.isnan(val)
  645: 
  646:         for col, series in nonContigFrame.items():
  647:             tm.assert_index_equal(series.index, nonContigFrame.index)
  648: 
  649:         # corner cases
  650: 
  651:         # Same index, copies values but not index if copy=False
  652:         newFrame = float_frame.reindex(float_frame.index, copy=False)
  653:         if using_copy_on_write:
  654:             assert newFrame.index.is_(float_frame.index)
  655:         else:
  656:             assert newFrame.index is float_frame.index
  657: 
  658:         # length zero
  659:         newFrame = float_frame.reindex([])
  660:         assert newFrame.empty
  661:         assert len(newFrame.columns) == len(float_frame.columns)
  662: 
  663:         # length zero with columns reindexed with non-empty index
  664:         newFrame = float_frame.reindex([])
  665:         newFrame = newFrame.reindex(float_frame.index)
  666:         assert len(newFrame.index) == len(float_frame.index)
  667:         assert len(newFrame.columns) == len(float_frame.columns)
  668: 
  669:         # pass non-Index
  670:         newFrame = float_frame.reindex(list(datetime_series.index))
  671:         expected = datetime_series.index._with_freq(None)
  672:         tm.assert_index_equal(newFrame.index, expected)
  673: 
  674:         # copy with no axes
  675:         result = float_frame.reindex()
  676:         tm.assert_frame_equal(result, float_frame)
  677:         assert result is not float_frame
  678: 
  679:     def test_reindex_nan(self):
  680:         df = DataFrame(
  681:             [[1, 2], [3, 5], [7, 11], [9, 23]],
  682:             index=[2, np.nan, 1, 5],
  683:             columns=["joe", "jim"],
  684:         )
  685: 
  686:         i, j = [np.nan, 5, 5, np.nan, 1, 2, np.nan], [1, 3, 3, 1, 2, 0, 1]
  687:         tm.assert_frame_equal(df.reindex(i), df.iloc[j])
  688: 
  689:         df.index = df.index.astype("object")
  690:         tm.assert_frame_equal(df.reindex(i), df.iloc[j], check_index_type=False)
  691: 
  692:         # GH10388
  693:         df = DataFrame(
  694:             {
  695:                 "other": ["a", "b", np.nan, "c"],
  696:                 "date": ["2015-03-22", np.nan, "2012-01-08", np.nan],
  697:                 "amount": [2, 3, 4, 5],
  698:             }
  699:         )
  700: 
  701:         df["date"] = pd.to_datetime(df.date)
  702:         df["delta"] = (pd.to_datetime("2015-06-18") - df["date"]).shift(1)
  703: 
  704:         left = df.set_index(["delta", "other", "date"]).reset_index()
  705:         right = df.reindex(columns=["delta", "other", "date", "amount"])
  706:         tm.assert_frame_equal(left, right)
  707: 
  708:     def test_reindex_name_remains(self):
  709:         s = Series(np.random.default_rng(2).random(10))
  710:         df = DataFrame(s, index=np.arange(len(s)))
  711:         i = Series(np.arange(10), name="iname")
  712: 
  713:         df = df.reindex(i)
  714:         assert df.index.name == "iname"
  715: 
  716:         df = df.reindex(Index(np.arange(10), name="tmpname"))
  717:         assert df.index.name == "tmpname"
  718: 
  719:         s = Series(np.random.default_rng(2).random(10))
  720:         df = DataFrame(s.T, index=np.arange(len(s)))
  721:         i = Series(np.arange(10), name="iname")
  722:         df = df.reindex(columns=i)
  723:         assert df.columns.name == "iname"
  724: 
  725:     def test_reindex_int(self, int_frame):
  726:         smaller = int_frame.reindex(int_frame.index[::2])
  727: 
  728:         assert smaller["A"].dtype == np.int64
  729: 
  730:         bigger = smaller.reindex(int_frame.index)
  731:         assert bigger["A"].dtype == np.float64
  732: 
  733:         smaller = int_frame.reindex(columns=["A", "B"])
  734:         assert smaller["A"].dtype == np.int64
  735: 
  736:     def test_reindex_columns(self, float_frame):
  737:         new_frame = float_frame.reindex(columns=["A", "B", "E"])
  738: 
  739:         tm.assert_series_equal(new_frame["B"], float_frame["B"])
  740:         assert np.isnan(new_frame["E"]).all()
  741:         assert "C" not in new_frame
  742: 
  743:         # Length zero
  744:         new_frame = float_frame.reindex(columns=[])
  745:         assert new_frame.empty
  746: 
  747:     def test_reindex_columns_method(self):
  748:         # GH 14992, reindexing over columns ignored method
  749:         df = DataFrame(
  750:             data=[[11, 12, 13], [21, 22, 23], [31, 32, 33]],
  751:             index=[1, 2, 4],
  752:             columns=[1, 2, 4],
  753:             dtype=float,
  754:         )
  755: 
  756:         # default method
  757:         result = df.reindex(columns=range(6))
  758:         expected = DataFrame(
  759:             data=[
  760:                 [np.nan, 11, 12, np.nan, 13, np.nan],
  761:                 [np.nan, 21, 22, np.nan, 23, np.nan],
  762:                 [np.nan, 31, 32, np.nan, 33, np.nan],
  763:             ],
  764:             index=[1, 2, 4],
  765:             columns=range(6),
  766:             dtype=float,
  767:         )
  768:         tm.assert_frame_equal(result, expected)
  769: 
  770:         # method='ffill'
  771:         result = df.reindex(columns=range(6), method="ffill")
  772:         expected = DataFrame(
  773:             data=[
  774:                 [np.nan, 11, 12, 12, 13, 13],
  775:                 [np.nan, 21, 22, 22, 23, 23],
  776:                 [np.nan, 31, 32, 32, 33, 33],
  777:             ],
  778:             index=[1, 2, 4],
  779:             columns=range(6),
  780:             dtype=float,
  781:         )
  782:         tm.assert_frame_equal(result, expected)
  783: 
  784:         # method='bfill'
  785:         result = df.reindex(columns=range(6), method="bfill")
  786:         expected = DataFrame(
  787:             data=[
  788:                 [11, 11, 12, 13, 13, np.nan],
  789:                 [21, 21, 22, 23, 23, np.nan],
  790:                 [31, 31, 32, 33, 33, np.nan],
  791:             ],
  792:             index=[1, 2, 4],
  793:             columns=range(6),
  794:             dtype=float,
  795:         )
  796:         tm.assert_frame_equal(result, expected)
  797: 
  798:     def test_reindex_axes(self):
  799:         # GH 3317, reindexing by both axes loses freq of the index
  800:         df = DataFrame(
  801:             np.ones((3, 3)),
  802:             index=[datetime(2012, 1, 1), datetime(2012, 1, 2), datetime(2012, 1, 3)],
  803:             columns=["a", "b", "c"],
  804:         )
  805:         time_freq = date_range("2012-01-01", "2012-01-03", freq="d")
  806:         some_cols = ["a", "b"]
  807: 
  808:         index_freq = df.reindex(index=time_freq).index.freq
  809:         both_freq = df.reindex(index=time_freq, columns=some_cols).index.freq
  810:         seq_freq = df.reindex(index=time_freq).reindex(columns=some_cols).index.freq
  811:         assert index_freq == both_freq
  812:         assert index_freq == seq_freq
  813: 
  814:     def test_reindex_fill_value(self):
  815:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))
  816: 
  817:         # axis=0
  818:         result = df.reindex(list(range(15)))
  819:         assert np.isnan(result.values[-5:]).all()
  820: 
  821:         result = df.reindex(range(15), fill_value=0)
  822:         expected = df.reindex(range(15)).fillna(0)
  823:         tm.assert_frame_equal(result, expected)
  824: 
  825:         # axis=1
  826:         result = df.reindex(columns=range(5), fill_value=0.0)
  827:         expected = df.copy()
  828:         expected[4] = 0.0
  829:         tm.assert_frame_equal(result, expected)
  830: 
  831:         result = df.reindex(columns=range(5), fill_value=0)
  832:         expected = df.copy()
  833:         expected[4] = 0
  834:         tm.assert_frame_equal(result, expected)
  835: 
  836:         result = df.reindex(columns=range(5), fill_value="foo")
  837:         expected = df.copy()
  838:         expected[4] = "foo"
  839:         tm.assert_frame_equal(result, expected)
  840: 
  841:         # other dtypes
  842:         df["foo"] = "foo"
  843:         result = df.reindex(range(15), fill_value="0")
  844:         expected = df.reindex(range(15)).fillna("0")
  845:         tm.assert_frame_equal(result, expected)
  846: 
  847:     def test_reindex_uint_dtypes_fill_value(self, any_unsigned_int_numpy_dtype):
  848:         # GH#48184
  849:         df = DataFrame({"a": [1, 2], "b": [1, 2]}, dtype=any_unsigned_int_numpy_dtype)
  850:         result = df.reindex(columns=list("abcd"), index=[0, 1, 2, 3], fill_value=10)
  851:         expected = DataFrame(
  852:             {"a": [1, 2, 10, 10], "b": [1, 2, 10, 10], "c": 10, "d": 10},
  853:             dtype=any_unsigned_int_numpy_dtype,
  854:         )
  855:         tm.assert_frame_equal(result, expected)
  856: 
  857:     def test_reindex_single_column_ea_index_and_columns(self, any_numeric_ea_dtype):
  858:         # GH#48190
  859:         df = DataFrame({"a": [1, 2]}, dtype=any_numeric_ea_dtype)
  860:         result = df.reindex(columns=list("ab"), index=[0, 1, 2], fill_value=10)
  861:         expected = DataFrame(
  862:             {"a": Series([1, 2, 10], dtype=any_numeric_ea_dtype), "b": 10}
  863:         )
  864:         tm.assert_frame_equal(result, expected)
  865: 
  866:     def test_reindex_dups(self):
  867:         # GH4746, reindex on duplicate index error messages
  868:         arr = np.random.default_rng(2).standard_normal(10)
  869:         df = DataFrame(arr, index=[1, 2, 3, 4, 5, 1, 2, 3, 4, 5])
  870: 
  871:         # set index is ok
  872:         result = df.copy()
  873:         result.index = list(range(len(df)))
  874:         expected = DataFrame(arr, index=list(range(len(df))))
  875:         tm.assert_frame_equal(result, expected)
  876: 
  877:         # reindex fails
  878:         msg = "cannot reindex on an axis with duplicate labels"
  879:         with pytest.raises(ValueError, match=msg):
  880:             df.reindex(index=list(range(len(df))))
  881: 
  882:     def test_reindex_with_duplicate_columns(self):
  883:         # reindex is invalid!
  884:         df = DataFrame(
  885:             [[1, 5, 7.0], [1, 5, 7.0], [1, 5, 7.0]], columns=["bar", "a", "a"]
  886:         )
  887:         msg = "cannot reindex on an axis with duplicate labels"
  888:         with pytest.raises(ValueError, match=msg):
  889:             df.reindex(columns=["bar"])
  890:         with pytest.raises(ValueError, match=msg):
  891:             df.reindex(columns=["bar", "foo"])
  892: 
  893:     def test_reindex_axis_style(self):
  894:         # https://github.com/pandas-dev/pandas/issues/12392
  895:         df = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
  896:         expected = DataFrame(
  897:             {"A": [1, 2, np.nan], "B": [4, 5, np.nan]}, index=[0, 1, 3]
  898:         )
  899:         result = df.reindex([0, 1, 3])
  900:         tm.assert_frame_equal(result, expected)
  901: 
  902:         result = df.reindex([0, 1, 3], axis=0)
  903:         tm.assert_frame_equal(result, expected)
  904: 
  905:         result = df.reindex([0, 1, 3], axis="index")
  906:         tm.assert_frame_equal(result, expected)
  907: 
  908:     def test_reindex_positional_raises(self):
  909:         # https://github.com/pandas-dev/pandas/issues/12392
  910:         # Enforced in 2.0
  911:         df = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
  912:         msg = r"reindex\(\) takes from 1 to 2 positional arguments but 3 were given"
  913:         with pytest.raises(TypeError, match=msg):
  914:             df.reindex([0, 1], ["A", "B", "C"])
  915: 
  916:     def test_reindex_axis_style_raises(self):
  917:         # https://github.com/pandas-dev/pandas/issues/12392
  918:         df = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
  919:         with pytest.raises(TypeError, match="Cannot specify both 'axis'"):
  920:             df.reindex([0, 1], columns=["A"], axis=1)
  921: 
  922:         with pytest.raises(TypeError, match="Cannot specify both 'axis'"):
  923:             df.reindex([0, 1], columns=["A"], axis="index")
  924: 
  925:         with pytest.raises(TypeError, match="Cannot specify both 'axis'"):
  926:             df.reindex(index=[0, 1], axis="index")
  927: 
  928:         with pytest.raises(TypeError, match="Cannot specify both 'axis'"):
  929:             df.reindex(index=[0, 1], axis="columns")
  930: 
  931:         with pytest.raises(TypeError, match="Cannot specify both 'axis'"):
  932:             df.reindex(columns=[0, 1], axis="columns")
  933: 
  934:         with pytest.raises(TypeError, match="Cannot specify both 'axis'"):
  935:             df.reindex(index=[0, 1], columns=[0, 1], axis="columns")
  936: 
  937:         with pytest.raises(TypeError, match="Cannot specify all"):
  938:             df.reindex(labels=[0, 1], index=[0], columns=["A"])
  939: 
  940:         # Mixing styles
  941:         with pytest.raises(TypeError, match="Cannot specify both 'axis'"):
  942:             df.reindex(index=[0, 1], axis="index")
  943: 
  944:         with pytest.raises(TypeError, match="Cannot specify both 'axis'"):
  945:             df.reindex(index=[0, 1], axis="columns")
  946: 
  947:         # Duplicates
  948:         with pytest.raises(TypeError, match="multiple values"):
  949:             df.reindex([0, 1], labels=[0, 1])
  950: 
  951:     def test_reindex_single_named_indexer(self):
  952:         # https://github.com/pandas-dev/pandas/issues/12392
  953:         df = DataFrame({"A": [1, 2, 3], "B": [1, 2, 3]})
  954:         result = df.reindex([0, 1], columns=["A"])
  955:         expected = DataFrame({"A": [1, 2]})
  956:         tm.assert_frame_equal(result, expected)
  957: 
  958:     def test_reindex_api_equivalence(self):
  959:         # https://github.com/pandas-dev/pandas/issues/12392
  960:         # equivalence of the labels/axis and index/columns API's
  961:         df = DataFrame(
  962:             [[1, 2, 3], [3, 4, 5], [5, 6, 7]],
  963:             index=["a", "b", "c"],
  964:             columns=["d", "e", "f"],
  965:         )
  966: 
  967:         res1 = df.reindex(["b", "a"])
  968:         res2 = df.reindex(index=["b", "a"])
  969:         res3 = df.reindex(labels=["b", "a"])
  970:         res4 = df.reindex(labels=["b", "a"], axis=0)
  971:         res5 = df.reindex(["b", "a"], axis=0)
  972:         for res in [res2, res3, res4, res5]:
  973:             tm.assert_frame_equal(res1, res)
  974: 
  975:         res1 = df.reindex(columns=["e", "d"])
  976:         res2 = df.reindex(["e", "d"], axis=1)
  977:         res3 = df.reindex(labels=["e", "d"], axis=1)
  978:         for res in [res2, res3]:
  979:             tm.assert_frame_equal(res1, res)
  980: 
  981:         res1 = df.reindex(index=["b", "a"], columns=["e", "d"])
  982:         res2 = df.reindex(columns=["e", "d"], index=["b", "a"])
  983:         res3 = df.reindex(labels=["b", "a"], axis=0).reindex(labels=["e", "d"], axis=1)
  984:         for res in [res2, res3]:
  985:             tm.assert_frame_equal(res1, res)
  986: 
  987:     def test_reindex_boolean(self):
  988:         frame = DataFrame(
  989:             np.ones((10, 2), dtype=bool), index=np.arange(0, 20, 2), columns=[0, 2]
  990:         )
  991: 
  992:         reindexed = frame.reindex(np.arange(10))
  993:         assert reindexed.values.dtype == np.object_
  994:         assert isna(reindexed[0][1])
  995: 
  996:         reindexed = frame.reindex(columns=range(3))
  997:         assert reindexed.values.dtype == np.object_
  998:         assert isna(reindexed[1]).all()
  999: 
 1000:     def test_reindex_objects(self, float_string_frame):
 1001:         reindexed = float_string_frame.reindex(columns=["foo", "A", "B"])
 1002:         assert "foo" in reindexed
 1003: 
 1004:         reindexed = float_string_frame.reindex(columns=["A", "B"])
 1005:         assert "foo" not in reindexed
 1006: 
 1007:     def test_reindex_corner(self, int_frame):
 1008:         index = Index(["a", "b", "c"])
 1009:         dm = DataFrame({}).reindex(index=[1, 2, 3])
 1010:         reindexed = dm.reindex(columns=index)
 1011:         tm.assert_index_equal(reindexed.columns, index)
 1012: 
 1013:         # ints are weird
 1014:         smaller = int_frame.reindex(columns=["A", "B", "E"])
 1015:         assert smaller["E"].dtype == np.float64
 1016: 
 1017:     def test_reindex_with_nans(self):
 1018:         df = DataFrame(
 1019:             [[1, 2], [3, 4], [np.nan, np.nan], [7, 8], [9, 10]],
 1020:             columns=["a", "b"],
 1021:             index=[100.0, 101.0, np.nan, 102.0, 103.0],
 1022:         )
 1023: 
 1024:         result = df.reindex(index=[101.0, 102.0, 103.0])
 1025:         expected = df.iloc[[1, 3, 4]]
 1026:         tm.assert_frame_equal(result, expected)
 1027: 
 1028:         result = df.reindex(index=[103.0])
 1029:         expected = df.iloc[[4]]
 1030:         tm.assert_frame_equal(result, expected)
 1031: 
 1032:         result = df.reindex(index=[101.0])
 1033:         expected = df.iloc[[1]]
 1034:         tm.assert_frame_equal(result, expected)
 1035: 
 1036:     def test_reindex_multi(self):
 1037:         df = DataFrame(np.random.default_rng(2).standard_normal((3, 3)))
 1038: 
 1039:         result = df.reindex(index=range(4), columns=range(4))
 1040:         expected = df.reindex(list(range(4))).reindex(columns=range(4))
 1041: 
 1042:         tm.assert_frame_equal(result, expected)
 1043: 
 1044:         df = DataFrame(np.random.default_rng(2).integers(0, 10, (3, 3)))
 1045: 
 1046:         result = df.reindex(index=range(4), columns=range(4))
 1047:         expected = df.reindex(list(range(4))).reindex(columns=range(4))
 1048: 
 1049:         tm.assert_frame_equal(result, expected)
 1050: 
 1051:         df = DataFrame(np.random.default_rng(2).integers(0, 10, (3, 3)))
 1052: 
 1053:         result = df.reindex(index=range(2), columns=range(2))
 1054:         expected = df.reindex(range(2)).reindex(columns=range(2))
 1055: 
 1056:         tm.assert_frame_equal(result, expected)
 1057: 
 1058:         df = DataFrame(
 1059:             np.random.default_rng(2).standard_normal((5, 3)) + 1j,
 1060:             columns=["a", "b", "c"],
 1061:         )
 1062: 
 1063:         result = df.reindex(index=[0, 1], columns=["a", "b"])
 1064:         expected = df.reindex([0, 1]).reindex(columns=["a", "b"])
 1065: 
 1066:         tm.assert_frame_equal(result, expected)
 1067: 
 1068:     def test_reindex_multi_categorical_time(self):
 1069:         # https://github.com/pandas-dev/pandas/issues/21390
 1070:         midx = MultiIndex.from_product(
 1071:             [
 1072:                 Categorical(["a", "b", "c"]),
 1073:                 Categorical(date_range("2012-01-01", periods=3, freq="h")),
 1074:             ]
 1075:         )
 1076:         df = DataFrame({"a": range(len(midx))}, index=midx)
 1077:         df2 = df.iloc[[0, 1, 2, 3, 4, 5, 6, 8]]
 1078: 
 1079:         result = df2.reindex(midx)
 1080:         expected = DataFrame({"a": [0, 1, 2, 3, 4, 5, 6, np.nan, 8]}, index=midx)
 1081:         tm.assert_frame_equal(result, expected)
 1082: 
 1083:     def test_reindex_with_categoricalindex(self):
 1084:         df = DataFrame(
 1085:             {
 1086:                 "A": np.arange(3, dtype="int64"),
 1087:             },
 1088:             index=CategoricalIndex(
 1089:                 list("abc"), dtype=CategoricalDtype(list("cabe")), name="B"
 1090:             ),
 1091:         )
 1092: 
 1093:         # reindexing
 1094:         # convert to a regular index
 1095:         result = df.reindex(["a", "b", "e"])
 1096:         expected = DataFrame({"A": [0, 1, np.nan], "B": Series(list("abe"))}).set_index(
 1097:             "B"
 1098:         )
 1099:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1100: 
 1101:         result = df.reindex(["a", "b"])
 1102:         expected = DataFrame({"A": [0, 1], "B": Series(list("ab"))}).set_index("B")
 1103:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1104: 
 1105:         result = df.reindex(["e"])
 1106:         expected = DataFrame({"A": [np.nan], "B": Series(["e"])}).set_index("B")
 1107:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1108: 
 1109:         result = df.reindex(["d"])
 1110:         expected = DataFrame({"A": [np.nan], "B": Series(["d"])}).set_index("B")
 1111:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1112: 
 1113:         # since we are actually reindexing with a Categorical
 1114:         # then return a Categorical
 1115:         cats = list("cabe")
 1116: 
 1117:         result = df.reindex(Categorical(["a", "e"], categories=cats))
 1118:         expected = DataFrame(
 1119:             {"A": [0, np.nan], "B": Series(list("ae")).astype(CategoricalDtype(cats))}
 1120:         ).set_index("B")
 1121:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1122: 
 1123:         result = df.reindex(Categorical(["a"], categories=cats))
 1124:         expected = DataFrame(
 1125:             {"A": [0], "B": Series(list("a")).astype(CategoricalDtype(cats))}
 1126:         ).set_index("B")
 1127:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1128: 
 1129:         result = df.reindex(["a", "b", "e"])
 1130:         expected = DataFrame({"A": [0, 1, np.nan], "B": Series(list("abe"))}).set_index(
 1131:             "B"
 1132:         )
 1133:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1134: 
 1135:         result = df.reindex(["a", "b"])
 1136:         expected = DataFrame({"A": [0, 1], "B": Series(list("ab"))}).set_index("B")
 1137:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1138: 
 1139:         result = df.reindex(["e"])
 1140:         expected = DataFrame({"A": [np.nan], "B": Series(["e"])}).set_index("B")
 1141:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1142: 
 1143:         # give back the type of categorical that we received
 1144:         result = df.reindex(Categorical(["a", "e"], categories=cats, ordered=True))
 1145:         expected = DataFrame(
 1146:             {
 1147:                 "A": [0, np.nan],
 1148:                 "B": Series(list("ae")).astype(CategoricalDtype(cats, ordered=True)),
 1149:             }
 1150:         ).set_index("B")
 1151:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1152: 
 1153:         result = df.reindex(Categorical(["a", "d"], categories=["a", "d"]))
 1154:         expected = DataFrame(
 1155:             {
 1156:                 "A": [0, np.nan],
 1157:                 "B": Series(list("ad")).astype(CategoricalDtype(["a", "d"])),
 1158:             }
 1159:         ).set_index("B")
 1160:         tm.assert_frame_equal(result, expected, check_index_type=True)
 1161: 
 1162:         df2 = DataFrame(
 1163:             {
 1164:                 "A": np.arange(6, dtype="int64"),
 1165:             },
 1166:             index=CategoricalIndex(
 1167:                 list("aabbca"), dtype=CategoricalDtype(list("cabe")), name="B"
 1168:             ),
 1169:         )
 1170:         # passed duplicate indexers are not allowed
 1171:         msg = "cannot reindex on an axis with duplicate labels"
 1172:         with pytest.raises(ValueError, match=msg):
 1173:             df2.reindex(["a", "b"])
 1174: 
 1175:         # args NotImplemented ATM
 1176:         msg = r"argument {} is not implemented for CategoricalIndex\.reindex"
 1177:         with pytest.raises(NotImplementedError, match=msg.format("method")):
 1178:             df.reindex(["a"], method="ffill")
 1179:         with pytest.raises(NotImplementedError, match=msg.format("level")):
 1180:             df.reindex(["a"], level=1)
 1181:         with pytest.raises(NotImplementedError, match=msg.format("limit")):
 1182:             df.reindex(["a"], limit=2)
 1183: 
 1184:     def test_reindex_signature(self):
 1185:         sig = inspect.signature(DataFrame.reindex)
 1186:         parameters = set(sig.parameters)
 1187:         assert parameters == {
 1188:             "self",
 1189:             "labels",
 1190:             "index",
 1191:             "columns",
 1192:             "axis",
 1193:             "limit",
 1194:             "copy",
 1195:             "level",
 1196:             "method",
 1197:             "fill_value",
 1198:             "tolerance",
 1199:         }
 1200: 
 1201:     def test_reindex_multiindex_ffill_added_rows(self):
 1202:         # GH#23693
 1203:         # reindex added rows with nan values even when fill method was specified
 1204:         mi = MultiIndex.from_tuples([("a", "b"), ("d", "e")])
 1205:         df = DataFrame([[0, 7], [3, 4]], index=mi, columns=["x", "y"])
 1206:         mi2 = MultiIndex.from_tuples([("a", "b"), ("d", "e"), ("h", "i")])
 1207:         result = df.reindex(mi2, axis=0, method="ffill")
 1208:         expected = DataFrame([[0, 7], [3, 4], [3, 4]], index=mi2, columns=["x", "y"])
 1209:         tm.assert_frame_equal(result, expected)
 1210: 
 1211:     @pytest.mark.parametrize(
 1212:         "kwargs",
 1213:         [
 1214:             {"method": "pad", "tolerance": timedelta(seconds=9)},
 1215:             {"method": "backfill", "tolerance": timedelta(seconds=9)},
 1216:             {"method": "nearest"},
 1217:             {"method": None},
 1218:         ],
 1219:     )
 1220:     def test_reindex_empty_frame(self, kwargs):
 1221:         # GH#27315
 1222:         idx = date_range(start="2020", freq="30s", periods=3)
 1223:         df = DataFrame([], index=Index([], name="time"), columns=["a"])
 1224:         result = df.reindex(idx, **kwargs)
 1225:         expected = DataFrame({"a": [np.nan] * 3}, index=idx, dtype=object)
 1226:         tm.assert_frame_equal(result, expected)
 1227: 
 1228:     @pytest.mark.parametrize(
 1229:         "src_idx",
 1230:         [
 1231:             Index([]),
 1232:             CategoricalIndex([]),
 1233:         ],
 1234:     )
 1235:     @pytest.mark.parametrize(
 1236:         "cat_idx",
 1237:         [
 1238:             # No duplicates
 1239:             Index([]),
 1240:             CategoricalIndex([]),
 1241:             Index(["A", "B"]),
 1242:             CategoricalIndex(["A", "B"]),
 1243:             # Duplicates: GH#38906
 1244:             Index(["A", "A"]),
 1245:             CategoricalIndex(["A", "A"]),
 1246:         ],
 1247:     )
 1248:     def test_reindex_empty(self, src_idx, cat_idx):
 1249:         df = DataFrame(columns=src_idx, index=["K"], dtype="f8")
 1250: 
 1251:         result = df.reindex(columns=cat_idx)
 1252:         expected = DataFrame(index=["K"], columns=cat_idx, dtype="f8")
 1253:         tm.assert_frame_equal(result, expected)
 1254: 
 1255:     @pytest.mark.parametrize("dtype", ["m8[ns]", "M8[ns]"])
 1256:     def test_reindex_datetimelike_to_object(self, dtype):
 1257:         # GH#39755 dont cast dt64/td64 to ints
 1258:         mi = MultiIndex.from_product([list("ABCDE"), range(2)])
 1259: 
 1260:         dti = date_range("2016-01-01", periods=10)
 1261:         fv = np.timedelta64("NaT", "ns")
 1262:         if dtype == "m8[ns]":
 1263:             dti = dti - dti[0]
 1264:             fv = np.datetime64("NaT", "ns")
 1265: 
 1266:         ser = Series(dti, index=mi)
 1267:         ser[::3] = pd.NaT
 1268: 
 1269:         df = ser.unstack()
 1270: 
 1271:         index = df.index.append(Index([1]))
 1272:         columns = df.columns.append(Index(["foo"]))
 1273: 
 1274:         res = df.reindex(index=index, columns=columns, fill_value=fv)
 1275: 
 1276:         expected = DataFrame(
 1277:             {
 1278:                 0: df[0].tolist() + [fv],
 1279:                 1: df[1].tolist() + [fv],
 1280:                 "foo": np.array(["NaT"] * 6, dtype=fv.dtype),
 1281:             },
 1282:             index=index,
 1283:         )
 1284:         assert (res.dtypes[[0, 1]] == object).all()
 1285:         assert res.iloc[0, 0] is pd.NaT
 1286:         assert res.iloc[-1, 0] is fv
 1287:         assert res.iloc[-1, 1] is fv
 1288:         tm.assert_frame_equal(res, expected)
 1289: 
 1290:     @pytest.mark.parametrize(
 1291:         "index_df,index_res,index_exp",
 1292:         [
 1293:             (
 1294:                 CategoricalIndex([], categories=["A"]),
 1295:                 Index(["A"]),
 1296:                 Index(["A"]),
 1297:             ),
 1298:             (
 1299:                 CategoricalIndex([], categories=["A"]),
 1300:                 Index(["B"]),
 1301:                 Index(["B"]),
 1302:             ),
 1303:             (
 1304:                 CategoricalIndex([], categories=["A"]),
 1305:                 CategoricalIndex(["A"]),
 1306:                 CategoricalIndex(["A"]),
 1307:             ),
 1308:             (
 1309:                 CategoricalIndex([], categories=["A"]),
 1310:                 CategoricalIndex(["B"]),
 1311:                 CategoricalIndex(["B"]),
 1312:             ),
 1313:         ],
 1314:     )
 1315:     def test_reindex_not_category(self, index_df, index_res, index_exp):
 1316:         # GH#28690
 1317:         df = DataFrame(index=index_df)
 1318:         result = df.reindex(index=index_res)
 1319:         expected = DataFrame(index=index_exp)
 1320:         tm.assert_frame_equal(result, expected)
 1321: 
 1322:     def test_invalid_method(self):
 1323:         df = DataFrame({"A": [1, np.nan, 2]})
 1324: 
 1325:         msg = "Invalid fill method"
 1326:         with pytest.raises(ValueError, match=msg):
 1327:             df.reindex([1, 0, 2], method="asfreq")
