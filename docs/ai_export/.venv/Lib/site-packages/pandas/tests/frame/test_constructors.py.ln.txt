    1: import array
    2: from collections import (
    3:     OrderedDict,
    4:     abc,
    5:     defaultdict,
    6:     namedtuple,
    7: )
    8: from collections.abc import Iterator
    9: from dataclasses import make_dataclass
   10: from datetime import (
   11:     date,
   12:     datetime,
   13:     timedelta,
   14: )
   15: import functools
   16: import re
   17: 
   18: import numpy as np
   19: from numpy import ma
   20: from numpy.ma import mrecords
   21: import pytest
   22: import pytz
   23: 
   24: from pandas._config import using_pyarrow_string_dtype
   25: 
   26: from pandas._libs import lib
   27: from pandas.compat.numpy import np_version_gt2
   28: from pandas.errors import IntCastingNaNError
   29: import pandas.util._test_decorators as td
   30: 
   31: from pandas.core.dtypes.common import is_integer_dtype
   32: from pandas.core.dtypes.dtypes import (
   33:     DatetimeTZDtype,
   34:     IntervalDtype,
   35:     NumpyEADtype,
   36:     PeriodDtype,
   37: )
   38: 
   39: import pandas as pd
   40: from pandas import (
   41:     Categorical,
   42:     CategoricalIndex,
   43:     DataFrame,
   44:     DatetimeIndex,
   45:     Index,
   46:     Interval,
   47:     MultiIndex,
   48:     Period,
   49:     RangeIndex,
   50:     Series,
   51:     Timedelta,
   52:     Timestamp,
   53:     cut,
   54:     date_range,
   55:     isna,
   56: )
   57: import pandas._testing as tm
   58: from pandas.arrays import (
   59:     DatetimeArray,
   60:     IntervalArray,
   61:     PeriodArray,
   62:     SparseArray,
   63:     TimedeltaArray,
   64: )
   65: 
   66: MIXED_FLOAT_DTYPES = ["float16", "float32", "float64"]
   67: MIXED_INT_DTYPES = [
   68:     "uint8",
   69:     "uint16",
   70:     "uint32",
   71:     "uint64",
   72:     "int8",
   73:     "int16",
   74:     "int32",
   75:     "int64",
   76: ]
   77: 
   78: 
   79: class TestDataFrameConstructors:
   80:     def test_constructor_from_ndarray_with_str_dtype(self):
   81:         # If we don't ravel/reshape around ensure_str_array, we end up
   82:         #  with an array of strings each of which is e.g. "[0 1 2]"
   83:         arr = np.arange(12).reshape(4, 3)
   84:         df = DataFrame(arr, dtype=str)
   85:         expected = DataFrame(arr.astype(str), dtype=object)
   86:         tm.assert_frame_equal(df, expected)
   87: 
   88:     def test_constructor_from_2d_datetimearray(self, using_array_manager):
   89:         dti = date_range("2016-01-01", periods=6, tz="US/Pacific")
   90:         dta = dti._data.reshape(3, 2)
   91: 
   92:         df = DataFrame(dta)
   93:         expected = DataFrame({0: dta[:, 0], 1: dta[:, 1]})
   94:         tm.assert_frame_equal(df, expected)
   95:         if not using_array_manager:
   96:             # GH#44724 big performance hit if we de-consolidate
   97:             assert len(df._mgr.blocks) == 1
   98: 
   99:     def test_constructor_dict_with_tzaware_scalar(self):
  100:         # GH#42505
  101:         dt = Timestamp("2019-11-03 01:00:00-0700").tz_convert("America/Los_Angeles")
  102:         dt = dt.as_unit("ns")
  103: 
  104:         df = DataFrame({"dt": dt}, index=[0])
  105:         expected = DataFrame({"dt": [dt]})
  106:         tm.assert_frame_equal(df, expected)
  107: 
  108:         # Non-homogeneous
  109:         df = DataFrame({"dt": dt, "value": [1]})
  110:         expected = DataFrame({"dt": [dt], "value": [1]})
  111:         tm.assert_frame_equal(df, expected)
  112: 
  113:     def test_construct_ndarray_with_nas_and_int_dtype(self):
  114:         # GH#26919 match Series by not casting np.nan to meaningless int
  115:         arr = np.array([[1, np.nan], [2, 3]])
  116:         msg = r"Cannot convert non-finite values \(NA or inf\) to integer"
  117:         with pytest.raises(IntCastingNaNError, match=msg):
  118:             DataFrame(arr, dtype="i8")
  119: 
  120:         # check this matches Series behavior
  121:         with pytest.raises(IntCastingNaNError, match=msg):
  122:             Series(arr[0], dtype="i8", name=0)
  123: 
  124:     def test_construct_from_list_of_datetimes(self):
  125:         df = DataFrame([datetime.now(), datetime.now()])
  126:         assert df[0].dtype == np.dtype("M8[ns]")
  127: 
  128:     def test_constructor_from_tzaware_datetimeindex(self):
  129:         # don't cast a DatetimeIndex WITH a tz, leave as object
  130:         # GH#6032
  131:         naive = DatetimeIndex(["2013-1-1 13:00", "2013-1-2 14:00"], name="B")
  132:         idx = naive.tz_localize("US/Pacific")
  133: 
  134:         expected = Series(np.array(idx.tolist(), dtype="object"), name="B")
  135:         assert expected.dtype == idx.dtype
  136: 
  137:         # convert index to series
  138:         result = Series(idx)
  139:         tm.assert_series_equal(result, expected)
  140: 
  141:     def test_columns_with_leading_underscore_work_with_to_dict(self):
  142:         col_underscore = "_b"
  143:         df = DataFrame({"a": [1, 2], col_underscore: [3, 4]})
  144:         d = df.to_dict(orient="records")
  145: 
  146:         ref_d = [{"a": 1, col_underscore: 3}, {"a": 2, col_underscore: 4}]
  147: 
  148:         assert ref_d == d
  149: 
  150:     def test_columns_with_leading_number_and_underscore_work_with_to_dict(self):
  151:         col_with_num = "1_b"
  152:         df = DataFrame({"a": [1, 2], col_with_num: [3, 4]})
  153:         d = df.to_dict(orient="records")
  154: 
  155:         ref_d = [{"a": 1, col_with_num: 3}, {"a": 2, col_with_num: 4}]
  156: 
  157:         assert ref_d == d
  158: 
  159:     def test_array_of_dt64_nat_with_td64dtype_raises(self, frame_or_series):
  160:         # GH#39462
  161:         nat = np.datetime64("NaT", "ns")
  162:         arr = np.array([nat], dtype=object)
  163:         if frame_or_series is DataFrame:
  164:             arr = arr.reshape(1, 1)
  165: 
  166:         msg = "Invalid type for timedelta scalar: <class 'numpy.datetime64'>"
  167:         with pytest.raises(TypeError, match=msg):
  168:             frame_or_series(arr, dtype="m8[ns]")
  169: 
  170:     @pytest.mark.parametrize("kind", ["m", "M"])
  171:     def test_datetimelike_values_with_object_dtype(self, kind, frame_or_series):
  172:         # with dtype=object, we should cast dt64 values to Timestamps, not pydatetimes
  173:         if kind == "M":
  174:             dtype = "M8[ns]"
  175:             scalar_type = Timestamp
  176:         else:
  177:             dtype = "m8[ns]"
  178:             scalar_type = Timedelta
  179: 
  180:         arr = np.arange(6, dtype="i8").view(dtype).reshape(3, 2)
  181:         if frame_or_series is Series:
  182:             arr = arr[:, 0]
  183: 
  184:         obj = frame_or_series(arr, dtype=object)
  185:         assert obj._mgr.arrays[0].dtype == object
  186:         assert isinstance(obj._mgr.arrays[0].ravel()[0], scalar_type)
  187: 
  188:         # go through a different path in internals.construction
  189:         obj = frame_or_series(frame_or_series(arr), dtype=object)
  190:         assert obj._mgr.arrays[0].dtype == object
  191:         assert isinstance(obj._mgr.arrays[0].ravel()[0], scalar_type)
  192: 
  193:         obj = frame_or_series(frame_or_series(arr), dtype=NumpyEADtype(object))
  194:         assert obj._mgr.arrays[0].dtype == object
  195:         assert isinstance(obj._mgr.arrays[0].ravel()[0], scalar_type)
  196: 
  197:         if frame_or_series is DataFrame:
  198:             # other paths through internals.construction
  199:             sers = [Series(x) for x in arr]
  200:             obj = frame_or_series(sers, dtype=object)
  201:             assert obj._mgr.arrays[0].dtype == object
  202:             assert isinstance(obj._mgr.arrays[0].ravel()[0], scalar_type)
  203: 
  204:     def test_series_with_name_not_matching_column(self):
  205:         # GH#9232
  206:         x = Series(range(5), name=1)
  207:         y = Series(range(5), name=0)
  208: 
  209:         result = DataFrame(x, columns=[0])
  210:         expected = DataFrame([], columns=[0])
  211:         tm.assert_frame_equal(result, expected)
  212: 
  213:         result = DataFrame(y, columns=[1])
  214:         expected = DataFrame([], columns=[1])
  215:         tm.assert_frame_equal(result, expected)
  216: 
  217:     @pytest.mark.parametrize(
  218:         "constructor",
  219:         [
  220:             lambda: DataFrame(),
  221:             lambda: DataFrame(None),
  222:             lambda: DataFrame(()),
  223:             lambda: DataFrame([]),
  224:             lambda: DataFrame(_ for _ in []),
  225:             lambda: DataFrame(range(0)),
  226:             lambda: DataFrame(data=None),
  227:             lambda: DataFrame(data=()),
  228:             lambda: DataFrame(data=[]),
  229:             lambda: DataFrame(data=(_ for _ in [])),
  230:             lambda: DataFrame(data=range(0)),
  231:         ],
  232:     )
  233:     def test_empty_constructor(self, constructor):
  234:         expected = DataFrame()
  235:         result = constructor()
  236:         assert len(result.index) == 0
  237:         assert len(result.columns) == 0
  238:         tm.assert_frame_equal(result, expected)
  239: 
  240:     @pytest.mark.parametrize(
  241:         "constructor",
  242:         [
  243:             lambda: DataFrame({}),
  244:             lambda: DataFrame(data={}),
  245:         ],
  246:     )
  247:     def test_empty_constructor_object_index(self, constructor):
  248:         expected = DataFrame(index=RangeIndex(0), columns=RangeIndex(0))
  249:         result = constructor()
  250:         assert len(result.index) == 0
  251:         assert len(result.columns) == 0
  252:         tm.assert_frame_equal(result, expected, check_index_type=True)
  253: 
  254:     @pytest.mark.parametrize(
  255:         "emptylike,expected_index,expected_columns",
  256:         [
  257:             ([[]], RangeIndex(1), RangeIndex(0)),
  258:             ([[], []], RangeIndex(2), RangeIndex(0)),
  259:             ([(_ for _ in [])], RangeIndex(1), RangeIndex(0)),
  260:         ],
  261:     )
  262:     def test_emptylike_constructor(self, emptylike, expected_index, expected_columns):
  263:         expected = DataFrame(index=expected_index, columns=expected_columns)
  264:         result = DataFrame(emptylike)
  265:         tm.assert_frame_equal(result, expected)
  266: 
  267:     def test_constructor_mixed(self, float_string_frame, using_infer_string):
  268:         dtype = "string" if using_infer_string else np.object_
  269:         assert float_string_frame["foo"].dtype == dtype
  270: 
  271:     def test_constructor_cast_failure(self):
  272:         # as of 2.0, we raise if we can't respect "dtype", previously we
  273:         #  silently ignored
  274:         msg = "could not convert string to float"
  275:         with pytest.raises(ValueError, match=msg):
  276:             DataFrame({"a": ["a", "b", "c"]}, dtype=np.float64)
  277: 
  278:         # GH 3010, constructing with odd arrays
  279:         df = DataFrame(np.ones((4, 2)))
  280: 
  281:         # this is ok
  282:         df["foo"] = np.ones((4, 2)).tolist()
  283: 
  284:         # this is not ok
  285:         msg = "Expected a 1D array, got an array with shape \\(4, 2\\)"
  286:         with pytest.raises(ValueError, match=msg):
  287:             df["test"] = np.ones((4, 2))
  288: 
  289:         # this is ok
  290:         df["foo2"] = np.ones((4, 2)).tolist()
  291: 
  292:     def test_constructor_dtype_copy(self):
  293:         orig_df = DataFrame({"col1": [1.0], "col2": [2.0], "col3": [3.0]})
  294: 
  295:         new_df = DataFrame(orig_df, dtype=float, copy=True)
  296: 
  297:         new_df["col1"] = 200.0
  298:         assert orig_df["col1"][0] == 1.0
  299: 
  300:     def test_constructor_dtype_nocast_view_dataframe(
  301:         self, using_copy_on_write, warn_copy_on_write
  302:     ):
  303:         df = DataFrame([[1, 2]])
  304:         should_be_view = DataFrame(df, dtype=df[0].dtype)
  305:         if using_copy_on_write:
  306:             should_be_view.iloc[0, 0] = 99
  307:             assert df.values[0, 0] == 1
  308:         else:
  309:             with tm.assert_cow_warning(warn_copy_on_write):
  310:                 should_be_view.iloc[0, 0] = 99
  311:             assert df.values[0, 0] == 99
  312: 
  313:     def test_constructor_dtype_nocast_view_2d_array(
  314:         self, using_array_manager, using_copy_on_write, warn_copy_on_write
  315:     ):
  316:         df = DataFrame([[1, 2], [3, 4]], dtype="int64")
  317:         if not using_array_manager and not using_copy_on_write:
  318:             should_be_view = DataFrame(df.values, dtype=df[0].dtype)
  319:             # TODO(CoW-warn) this should warn
  320:             # with tm.assert_cow_warning(warn_copy_on_write):
  321:             should_be_view.iloc[0, 0] = 97
  322:             assert df.values[0, 0] == 97
  323:         else:
  324:             # INFO(ArrayManager) DataFrame(ndarray) doesn't necessarily preserve
  325:             # a view on the array to ensure contiguous 1D arrays
  326:             df2 = DataFrame(df.values, dtype=df[0].dtype)
  327:             assert df2._mgr.arrays[0].flags.c_contiguous
  328: 
  329:     @td.skip_array_manager_invalid_test
  330:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="conversion copies")
  331:     def test_1d_object_array_does_not_copy(self):
  332:         # https://github.com/pandas-dev/pandas/issues/39272
  333:         arr = np.array(["a", "b"], dtype="object")
  334:         df = DataFrame(arr, copy=False)
  335:         assert np.shares_memory(df.values, arr)
  336: 
  337:     @td.skip_array_manager_invalid_test
  338:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="conversion copies")
  339:     def test_2d_object_array_does_not_copy(self):
  340:         # https://github.com/pandas-dev/pandas/issues/39272
  341:         arr = np.array([["a", "b"], ["c", "d"]], dtype="object")
  342:         df = DataFrame(arr, copy=False)
  343:         assert np.shares_memory(df.values, arr)
  344: 
  345:     def test_constructor_dtype_list_data(self):
  346:         df = DataFrame([[1, "2"], [None, "a"]], dtype=object)
  347:         assert df.loc[1, 0] is None
  348:         assert df.loc[0, 1] == "2"
  349: 
  350:     def test_constructor_list_of_2d_raises(self):
  351:         # https://github.com/pandas-dev/pandas/issues/32289
  352:         a = DataFrame()
  353:         b = np.empty((0, 0))
  354:         with pytest.raises(ValueError, match=r"shape=\(1, 0, 0\)"):
  355:             DataFrame([a])
  356: 
  357:         with pytest.raises(ValueError, match=r"shape=\(1, 0, 0\)"):
  358:             DataFrame([b])
  359: 
  360:         a = DataFrame({"A": [1, 2]})
  361:         with pytest.raises(ValueError, match=r"shape=\(2, 2, 1\)"):
  362:             DataFrame([a, a])
  363: 
  364:     @pytest.mark.parametrize(
  365:         "typ, ad",
  366:         [
  367:             # mixed floating and integer coexist in the same frame
  368:             ["float", {}],
  369:             # add lots of types
  370:             ["float", {"A": 1, "B": "foo", "C": "bar"}],
  371:             # GH 622
  372:             ["int", {}],
  373:         ],
  374:     )
  375:     def test_constructor_mixed_dtypes(self, typ, ad):
  376:         if typ == "int":
  377:             dtypes = MIXED_INT_DTYPES
  378:             arrays = [
  379:                 np.array(np.random.default_rng(2).random(10), dtype=d) for d in dtypes
  380:             ]
  381:         elif typ == "float":
  382:             dtypes = MIXED_FLOAT_DTYPES
  383:             arrays = [
  384:                 np.array(np.random.default_rng(2).integers(10, size=10), dtype=d)
  385:                 for d in dtypes
  386:             ]
  387: 
  388:         for d, a in zip(dtypes, arrays):
  389:             assert a.dtype == d
  390:         ad.update(dict(zip(dtypes, arrays)))
  391:         df = DataFrame(ad)
  392: 
  393:         dtypes = MIXED_FLOAT_DTYPES + MIXED_INT_DTYPES
  394:         for d in dtypes:
  395:             if d in df:
  396:                 assert df.dtypes[d] == d
  397: 
  398:     def test_constructor_complex_dtypes(self):
  399:         # GH10952
  400:         a = np.random.default_rng(2).random(10).astype(np.complex64)
  401:         b = np.random.default_rng(2).random(10).astype(np.complex128)
  402: 
  403:         df = DataFrame({"a": a, "b": b})
  404:         assert a.dtype == df.a.dtype
  405:         assert b.dtype == df.b.dtype
  406: 
  407:     def test_constructor_dtype_str_na_values(self, string_dtype):
  408:         # https://github.com/pandas-dev/pandas/issues/21083
  409:         df = DataFrame({"A": ["x", None]}, dtype=string_dtype)
  410:         result = df.isna()
  411:         expected = DataFrame({"A": [False, True]})
  412:         tm.assert_frame_equal(result, expected)
  413:         assert df.iloc[1, 0] is None
  414: 
  415:         df = DataFrame({"A": ["x", np.nan]}, dtype=string_dtype)
  416:         assert np.isnan(df.iloc[1, 0])
  417: 
  418:     def test_constructor_rec(self, float_frame):
  419:         rec = float_frame.to_records(index=False)
  420:         rec.dtype.names = list(rec.dtype.names)[::-1]
  421: 
  422:         index = float_frame.index
  423: 
  424:         df = DataFrame(rec)
  425:         tm.assert_index_equal(df.columns, Index(rec.dtype.names))
  426: 
  427:         df2 = DataFrame(rec, index=index)
  428:         tm.assert_index_equal(df2.columns, Index(rec.dtype.names))
  429:         tm.assert_index_equal(df2.index, index)
  430: 
  431:         # case with columns != the ones we would infer from the data
  432:         rng = np.arange(len(rec))[::-1]
  433:         df3 = DataFrame(rec, index=rng, columns=["C", "B"])
  434:         expected = DataFrame(rec, index=rng).reindex(columns=["C", "B"])
  435:         tm.assert_frame_equal(df3, expected)
  436: 
  437:     def test_constructor_bool(self):
  438:         df = DataFrame({0: np.ones(10, dtype=bool), 1: np.zeros(10, dtype=bool)})
  439:         assert df.values.dtype == np.bool_
  440: 
  441:     def test_constructor_overflow_int64(self):
  442:         # see gh-14881
  443:         values = np.array([2**64 - i for i in range(1, 10)], dtype=np.uint64)
  444: 
  445:         result = DataFrame({"a": values})
  446:         assert result["a"].dtype == np.uint64
  447: 
  448:         # see gh-2355
  449:         data_scores = [
  450:             (6311132704823138710, 273),
  451:             (2685045978526272070, 23),
  452:             (8921811264899370420, 45),
  453:             (17019687244989530680, 270),
  454:             (9930107427299601010, 273),
  455:         ]
  456:         dtype = [("uid", "u8"), ("score", "u8")]
  457:         data = np.zeros((len(data_scores),), dtype=dtype)
  458:         data[:] = data_scores
  459:         df_crawls = DataFrame(data)
  460:         assert df_crawls["uid"].dtype == np.uint64
  461: 
  462:     @pytest.mark.parametrize(
  463:         "values",
  464:         [
  465:             np.array([2**64], dtype=object),
  466:             np.array([2**65]),
  467:             [2**64 + 1],
  468:             np.array([-(2**63) - 4], dtype=object),
  469:             np.array([-(2**64) - 1]),
  470:             [-(2**65) - 2],
  471:         ],
  472:     )
  473:     def test_constructor_int_overflow(self, values):
  474:         # see gh-18584
  475:         value = values[0]
  476:         result = DataFrame(values)
  477: 
  478:         assert result[0].dtype == object
  479:         assert result[0][0] == value
  480: 
  481:     @pytest.mark.parametrize(
  482:         "values",
  483:         [
  484:             np.array([1], dtype=np.uint16),
  485:             np.array([1], dtype=np.uint32),
  486:             np.array([1], dtype=np.uint64),
  487:             [np.uint16(1)],
  488:             [np.uint32(1)],
  489:             [np.uint64(1)],
  490:         ],
  491:     )
  492:     def test_constructor_numpy_uints(self, values):
  493:         # GH#47294
  494:         value = values[0]
  495:         result = DataFrame(values)
  496: 
  497:         assert result[0].dtype == value.dtype
  498:         assert result[0][0] == value
  499: 
  500:     def test_constructor_ordereddict(self):
  501:         nitems = 100
  502:         nums = list(range(nitems))
  503:         np.random.default_rng(2).shuffle(nums)
  504:         expected = [f"A{i:d}" for i in nums]
  505:         df = DataFrame(OrderedDict(zip(expected, [[0]] * nitems)))
  506:         assert expected == list(df.columns)
  507: 
  508:     def test_constructor_dict(self):
  509:         datetime_series = Series(
  510:             np.arange(30, dtype=np.float64), index=date_range("2020-01-01", periods=30)
  511:         )
  512:         # test expects index shifted by 5
  513:         datetime_series_short = datetime_series[5:]
  514: 
  515:         frame = DataFrame({"col1": datetime_series, "col2": datetime_series_short})
  516: 
  517:         # col2 is padded with NaN
  518:         assert len(datetime_series) == 30
  519:         assert len(datetime_series_short) == 25
  520: 
  521:         tm.assert_series_equal(frame["col1"], datetime_series.rename("col1"))
  522: 
  523:         exp = Series(
  524:             np.concatenate([[np.nan] * 5, datetime_series_short.values]),
  525:             index=datetime_series.index,
  526:             name="col2",
  527:         )
  528:         tm.assert_series_equal(exp, frame["col2"])
  529: 
  530:         frame = DataFrame(
  531:             {"col1": datetime_series, "col2": datetime_series_short},
  532:             columns=["col2", "col3", "col4"],
  533:         )
  534: 
  535:         assert len(frame) == len(datetime_series_short)
  536:         assert "col1" not in frame
  537:         assert isna(frame["col3"]).all()
  538: 
  539:         # Corner cases
  540:         assert len(DataFrame()) == 0
  541: 
  542:         # mix dict and array, wrong size - no spec for which error should raise
  543:         # first
  544:         msg = "Mixing dicts with non-Series may lead to ambiguous ordering."
  545:         with pytest.raises(ValueError, match=msg):
  546:             DataFrame({"A": {"a": "a", "b": "b"}, "B": ["a", "b", "c"]})
  547: 
  548:     def test_constructor_dict_length1(self):
  549:         # Length-one dict micro-optimization
  550:         frame = DataFrame({"A": {"1": 1, "2": 2}})
  551:         tm.assert_index_equal(frame.index, Index(["1", "2"]))
  552: 
  553:     def test_constructor_dict_with_index(self):
  554:         # empty dict plus index
  555:         idx = Index([0, 1, 2])
  556:         frame = DataFrame({}, index=idx)
  557:         assert frame.index is idx
  558: 
  559:     def test_constructor_dict_with_index_and_columns(self):
  560:         # empty dict with index and columns
  561:         idx = Index([0, 1, 2])
  562:         frame = DataFrame({}, index=idx, columns=idx)
  563:         assert frame.index is idx
  564:         assert frame.columns is idx
  565:         assert len(frame._series) == 3
  566: 
  567:     def test_constructor_dict_of_empty_lists(self):
  568:         # with dict of empty list and Series
  569:         frame = DataFrame({"A": [], "B": []}, columns=["A", "B"])
  570:         tm.assert_index_equal(frame.index, RangeIndex(0), exact=True)
  571: 
  572:     def test_constructor_dict_with_none(self):
  573:         # GH 14381
  574:         # Dict with None value
  575:         frame_none = DataFrame({"a": None}, index=[0])
  576:         frame_none_list = DataFrame({"a": [None]}, index=[0])
  577:         assert frame_none._get_value(0, "a") is None
  578:         assert frame_none_list._get_value(0, "a") is None
  579:         tm.assert_frame_equal(frame_none, frame_none_list)
  580: 
  581:     def test_constructor_dict_errors(self):
  582:         # GH10856
  583:         # dict with scalar values should raise error, even if columns passed
  584:         msg = "If using all scalar values, you must pass an index"
  585:         with pytest.raises(ValueError, match=msg):
  586:             DataFrame({"a": 0.7})
  587: 
  588:         with pytest.raises(ValueError, match=msg):
  589:             DataFrame({"a": 0.7}, columns=["a"])
  590: 
  591:     @pytest.mark.parametrize("scalar", [2, np.nan, None, "D"])
  592:     def test_constructor_invalid_items_unused(self, scalar):
  593:         # No error if invalid (scalar) value is in fact not used:
  594:         result = DataFrame({"a": scalar}, columns=["b"])
  595:         expected = DataFrame(columns=["b"])
  596:         tm.assert_frame_equal(result, expected)
  597: 
  598:     @pytest.mark.parametrize("value", [2, np.nan, None, float("nan")])
  599:     def test_constructor_dict_nan_key(self, value):
  600:         # GH 18455
  601:         cols = [1, value, 3]
  602:         idx = ["a", value]
  603:         values = [[0, 3], [1, 4], [2, 5]]
  604:         data = {cols[c]: Series(values[c], index=idx) for c in range(3)}
  605:         result = DataFrame(data).sort_values(1).sort_values("a", axis=1)
  606:         expected = DataFrame(
  607:             np.arange(6, dtype="int64").reshape(2, 3), index=idx, columns=cols
  608:         )
  609:         tm.assert_frame_equal(result, expected)
  610: 
  611:         result = DataFrame(data, index=idx).sort_values("a", axis=1)
  612:         tm.assert_frame_equal(result, expected)
  613: 
  614:         result = DataFrame(data, index=idx, columns=cols)
  615:         tm.assert_frame_equal(result, expected)
  616: 
  617:     @pytest.mark.parametrize("value", [np.nan, None, float("nan")])
  618:     def test_constructor_dict_nan_tuple_key(self, value):
  619:         # GH 18455
  620:         cols = Index([(11, 21), (value, 22), (13, value)])
  621:         idx = Index([("a", value), (value, 2)])
  622:         values = [[0, 3], [1, 4], [2, 5]]
  623:         data = {cols[c]: Series(values[c], index=idx) for c in range(3)}
  624:         result = DataFrame(data).sort_values((11, 21)).sort_values(("a", value), axis=1)
  625:         expected = DataFrame(
  626:             np.arange(6, dtype="int64").reshape(2, 3), index=idx, columns=cols
  627:         )
  628:         tm.assert_frame_equal(result, expected)
  629: 
  630:         result = DataFrame(data, index=idx).sort_values(("a", value), axis=1)
  631:         tm.assert_frame_equal(result, expected)
  632: 
  633:         result = DataFrame(data, index=idx, columns=cols)
  634:         tm.assert_frame_equal(result, expected)
  635: 
  636:     def test_constructor_dict_order_insertion(self):
  637:         datetime_series = Series(
  638:             np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
  639:         )
  640:         datetime_series_short = datetime_series[:5]
  641: 
  642:         # GH19018
  643:         # initialization ordering: by insertion order if python>= 3.6
  644:         d = {"b": datetime_series_short, "a": datetime_series}
  645:         frame = DataFrame(data=d)
  646:         expected = DataFrame(data=d, columns=list("ba"))
  647:         tm.assert_frame_equal(frame, expected)
  648: 
  649:     def test_constructor_dict_nan_key_and_columns(self):
  650:         # GH 16894
  651:         result = DataFrame({np.nan: [1, 2], 2: [2, 3]}, columns=[np.nan, 2])
  652:         expected = DataFrame([[1, 2], [2, 3]], columns=[np.nan, 2])
  653:         tm.assert_frame_equal(result, expected)
  654: 
  655:     def test_constructor_multi_index(self):
  656:         # GH 4078
  657:         # construction error with mi and all-nan frame
  658:         tuples = [(2, 3), (3, 3), (3, 3)]
  659:         mi = MultiIndex.from_tuples(tuples)
  660:         df = DataFrame(index=mi, columns=mi)
  661:         assert isna(df).values.ravel().all()
  662: 
  663:         tuples = [(3, 3), (2, 3), (3, 3)]
  664:         mi = MultiIndex.from_tuples(tuples)
  665:         df = DataFrame(index=mi, columns=mi)
  666:         assert isna(df).values.ravel().all()
  667: 
  668:     def test_constructor_2d_index(self):
  669:         # GH 25416
  670:         # handling of 2d index in construction
  671:         df = DataFrame([[1]], columns=[[1]], index=[1, 2])
  672:         expected = DataFrame(
  673:             [1, 1],
  674:             index=Index([1, 2], dtype="int64"),
  675:             columns=MultiIndex(levels=[[1]], codes=[[0]]),
  676:         )
  677:         tm.assert_frame_equal(df, expected)
  678: 
  679:         df = DataFrame([[1]], columns=[[1]], index=[[1, 2]])
  680:         expected = DataFrame(
  681:             [1, 1],
  682:             index=MultiIndex(levels=[[1, 2]], codes=[[0, 1]]),
  683:             columns=MultiIndex(levels=[[1]], codes=[[0]]),
  684:         )
  685:         tm.assert_frame_equal(df, expected)
  686: 
  687:     def test_constructor_error_msgs(self):
  688:         msg = "Empty data passed with indices specified."
  689:         # passing an empty array with columns specified.
  690:         with pytest.raises(ValueError, match=msg):
  691:             DataFrame(np.empty(0), index=[1])
  692: 
  693:         msg = "Mixing dicts with non-Series may lead to ambiguous ordering."
  694:         # mix dict and array, wrong size
  695:         with pytest.raises(ValueError, match=msg):
  696:             DataFrame({"A": {"a": "a", "b": "b"}, "B": ["a", "b", "c"]})
  697: 
  698:         # wrong size ndarray, GH 3105
  699:         msg = r"Shape of passed values is \(4, 3\), indices imply \(3, 3\)"
  700:         with pytest.raises(ValueError, match=msg):
  701:             DataFrame(
  702:                 np.arange(12).reshape((4, 3)),
  703:                 columns=["foo", "bar", "baz"],
  704:                 index=date_range("2000-01-01", periods=3),
  705:             )
  706: 
  707:         arr = np.array([[4, 5, 6]])
  708:         msg = r"Shape of passed values is \(1, 3\), indices imply \(1, 4\)"
  709:         with pytest.raises(ValueError, match=msg):
  710:             DataFrame(index=[0], columns=range(4), data=arr)
  711: 
  712:         arr = np.array([4, 5, 6])
  713:         msg = r"Shape of passed values is \(3, 1\), indices imply \(1, 4\)"
  714:         with pytest.raises(ValueError, match=msg):
  715:             DataFrame(index=[0], columns=range(4), data=arr)
  716: 
  717:         # higher dim raise exception
  718:         with pytest.raises(ValueError, match="Must pass 2-d input"):
  719:             DataFrame(np.zeros((3, 3, 3)), columns=["A", "B", "C"], index=[1])
  720: 
  721:         # wrong size axis labels
  722:         msg = r"Shape of passed values is \(2, 3\), indices imply \(1, 3\)"
  723:         with pytest.raises(ValueError, match=msg):
  724:             DataFrame(
  725:                 np.random.default_rng(2).random((2, 3)),
  726:                 columns=["A", "B", "C"],
  727:                 index=[1],
  728:             )
  729: 
  730:         msg = r"Shape of passed values is \(2, 3\), indices imply \(2, 2\)"
  731:         with pytest.raises(ValueError, match=msg):
  732:             DataFrame(
  733:                 np.random.default_rng(2).random((2, 3)),
  734:                 columns=["A", "B"],
  735:                 index=[1, 2],
  736:             )
  737: 
  738:         # gh-26429
  739:         msg = "2 columns passed, passed data had 10 columns"
  740:         with pytest.raises(ValueError, match=msg):
  741:             DataFrame((range(10), range(10, 20)), columns=("ones", "twos"))
  742: 
  743:         msg = "If using all scalar values, you must pass an index"
  744:         with pytest.raises(ValueError, match=msg):
  745:             DataFrame({"a": False, "b": True})
  746: 
  747:     def test_constructor_subclass_dict(self, dict_subclass):
  748:         # Test for passing dict subclass to constructor
  749:         data = {
  750:             "col1": dict_subclass((x, 10.0 * x) for x in range(10)),
  751:             "col2": dict_subclass((x, 20.0 * x) for x in range(10)),
  752:         }
  753:         df = DataFrame(data)
  754:         refdf = DataFrame({col: dict(val.items()) for col, val in data.items()})
  755:         tm.assert_frame_equal(refdf, df)
  756: 
  757:         data = dict_subclass(data.items())
  758:         df = DataFrame(data)
  759:         tm.assert_frame_equal(refdf, df)
  760: 
  761:     def test_constructor_defaultdict(self, float_frame):
  762:         # try with defaultdict
  763:         data = {}
  764:         float_frame.loc[: float_frame.index[10], "B"] = np.nan
  765: 
  766:         for k, v in float_frame.items():
  767:             dct = defaultdict(dict)
  768:             dct.update(v.to_dict())
  769:             data[k] = dct
  770:         frame = DataFrame(data)
  771:         expected = frame.reindex(index=float_frame.index)
  772:         tm.assert_frame_equal(float_frame, expected)
  773: 
  774:     def test_constructor_dict_block(self):
  775:         expected = np.array([[4.0, 3.0, 2.0, 1.0]])
  776:         df = DataFrame(
  777:             {"d": [4.0], "c": [3.0], "b": [2.0], "a": [1.0]},
  778:             columns=["d", "c", "b", "a"],
  779:         )
  780:         tm.assert_numpy_array_equal(df.values, expected)
  781: 
  782:     def test_constructor_dict_cast(self, using_infer_string):
  783:         # cast float tests
  784:         test_data = {"A": {"1": 1, "2": 2}, "B": {"1": "1", "2": "2", "3": "3"}}
  785:         frame = DataFrame(test_data, dtype=float)
  786:         assert len(frame) == 3
  787:         assert frame["B"].dtype == np.float64
  788:         assert frame["A"].dtype == np.float64
  789: 
  790:         frame = DataFrame(test_data)
  791:         assert len(frame) == 3
  792:         assert frame["B"].dtype == np.object_ if not using_infer_string else "string"
  793:         assert frame["A"].dtype == np.float64
  794: 
  795:     def test_constructor_dict_cast2(self):
  796:         # can't cast to float
  797:         test_data = {
  798:             "A": dict(zip(range(20), [f"word_{i}" for i in range(20)])),
  799:             "B": dict(zip(range(15), np.random.default_rng(2).standard_normal(15))),
  800:         }
  801:         with pytest.raises(ValueError, match="could not convert string"):
  802:             DataFrame(test_data, dtype=float)
  803: 
  804:     def test_constructor_dict_dont_upcast(self):
  805:         d = {"Col1": {"Row1": "A String", "Row2": np.nan}}
  806:         df = DataFrame(d)
  807:         assert isinstance(df["Col1"]["Row2"], float)
  808: 
  809:     def test_constructor_dict_dont_upcast2(self):
  810:         dm = DataFrame([[1, 2], ["a", "b"]], index=[1, 2], columns=[1, 2])
  811:         assert isinstance(dm[1][1], int)
  812: 
  813:     def test_constructor_dict_of_tuples(self):
  814:         # GH #1491
  815:         data = {"a": (1, 2, 3), "b": (4, 5, 6)}
  816: 
  817:         result = DataFrame(data)
  818:         expected = DataFrame({k: list(v) for k, v in data.items()})
  819:         tm.assert_frame_equal(result, expected, check_dtype=False)
  820: 
  821:     def test_constructor_dict_of_ranges(self):
  822:         # GH 26356
  823:         data = {"a": range(3), "b": range(3, 6)}
  824: 
  825:         result = DataFrame(data)
  826:         expected = DataFrame({"a": [0, 1, 2], "b": [3, 4, 5]})
  827:         tm.assert_frame_equal(result, expected)
  828: 
  829:     def test_constructor_dict_of_iterators(self):
  830:         # GH 26349
  831:         data = {"a": iter(range(3)), "b": reversed(range(3))}
  832: 
  833:         result = DataFrame(data)
  834:         expected = DataFrame({"a": [0, 1, 2], "b": [2, 1, 0]})
  835:         tm.assert_frame_equal(result, expected)
  836: 
  837:     def test_constructor_dict_of_generators(self):
  838:         # GH 26349
  839:         data = {"a": (i for i in (range(3))), "b": (i for i in reversed(range(3)))}
  840:         result = DataFrame(data)
  841:         expected = DataFrame({"a": [0, 1, 2], "b": [2, 1, 0]})
  842:         tm.assert_frame_equal(result, expected)
  843: 
  844:     def test_constructor_dict_multiindex(self):
  845:         d = {
  846:             ("a", "a"): {("i", "i"): 0, ("i", "j"): 1, ("j", "i"): 2},
  847:             ("b", "a"): {("i", "i"): 6, ("i", "j"): 5, ("j", "i"): 4},
  848:             ("b", "c"): {("i", "i"): 7, ("i", "j"): 8, ("j", "i"): 9},
  849:         }
  850:         _d = sorted(d.items())
  851:         df = DataFrame(d)
  852:         expected = DataFrame(
  853:             [x[1] for x in _d], index=MultiIndex.from_tuples([x[0] for x in _d])
  854:         ).T
  855:         expected.index = MultiIndex.from_tuples(expected.index)
  856:         tm.assert_frame_equal(
  857:             df,
  858:             expected,
  859:         )
  860: 
  861:         d["z"] = {"y": 123.0, ("i", "i"): 111, ("i", "j"): 111, ("j", "i"): 111}
  862:         _d.insert(0, ("z", d["z"]))
  863:         expected = DataFrame(
  864:             [x[1] for x in _d], index=Index([x[0] for x in _d], tupleize_cols=False)
  865:         ).T
  866:         expected.index = Index(expected.index, tupleize_cols=False)
  867:         df = DataFrame(d)
  868:         df = df.reindex(columns=expected.columns, index=expected.index)
  869:         tm.assert_frame_equal(df, expected)
  870: 
  871:     def test_constructor_dict_datetime64_index(self):
  872:         # GH 10160
  873:         dates_as_str = ["1984-02-19", "1988-11-06", "1989-12-03", "1990-03-15"]
  874: 
  875:         def create_data(constructor):
  876:             return {i: {constructor(s): 2 * i} for i, s in enumerate(dates_as_str)}
  877: 
  878:         data_datetime64 = create_data(np.datetime64)
  879:         data_datetime = create_data(lambda x: datetime.strptime(x, "%Y-%m-%d"))
  880:         data_Timestamp = create_data(Timestamp)
  881: 
  882:         expected = DataFrame(
  883:             [
  884:                 {0: 0, 1: None, 2: None, 3: None},
  885:                 {0: None, 1: 2, 2: None, 3: None},
  886:                 {0: None, 1: None, 2: 4, 3: None},
  887:                 {0: None, 1: None, 2: None, 3: 6},
  888:             ],
  889:             index=[Timestamp(dt) for dt in dates_as_str],
  890:         )
  891: 
  892:         result_datetime64 = DataFrame(data_datetime64)
  893:         result_datetime = DataFrame(data_datetime)
  894:         result_Timestamp = DataFrame(data_Timestamp)
  895:         tm.assert_frame_equal(result_datetime64, expected)
  896:         tm.assert_frame_equal(result_datetime, expected)
  897:         tm.assert_frame_equal(result_Timestamp, expected)
  898: 
  899:     @pytest.mark.parametrize(
  900:         "klass,name",
  901:         [
  902:             (lambda x: np.timedelta64(x, "D"), "timedelta64"),
  903:             (lambda x: timedelta(days=x), "pytimedelta"),
  904:             (lambda x: Timedelta(x, "D"), "Timedelta[ns]"),
  905:             (lambda x: Timedelta(x, "D").as_unit("s"), "Timedelta[s]"),
  906:         ],
  907:     )
  908:     def test_constructor_dict_timedelta64_index(self, klass, name):
  909:         # GH 10160
  910:         td_as_int = [1, 2, 3, 4]
  911: 
  912:         data = {i: {klass(s): 2 * i} for i, s in enumerate(td_as_int)}
  913: 
  914:         expected = DataFrame(
  915:             [
  916:                 {0: 0, 1: None, 2: None, 3: None},
  917:                 {0: None, 1: 2, 2: None, 3: None},
  918:                 {0: None, 1: None, 2: 4, 3: None},
  919:                 {0: None, 1: None, 2: None, 3: 6},
  920:             ],
  921:             index=[Timedelta(td, "D") for td in td_as_int],
  922:         )
  923: 
  924:         result = DataFrame(data)
  925: 
  926:         tm.assert_frame_equal(result, expected)
  927: 
  928:     def test_constructor_period_dict(self):
  929:         # PeriodIndex
  930:         a = pd.PeriodIndex(["2012-01", "NaT", "2012-04"], freq="M")
  931:         b = pd.PeriodIndex(["2012-02-01", "2012-03-01", "NaT"], freq="D")
  932:         df = DataFrame({"a": a, "b": b})
  933:         assert df["a"].dtype == a.dtype
  934:         assert df["b"].dtype == b.dtype
  935: 
  936:         # list of periods
  937:         df = DataFrame({"a": a.astype(object).tolist(), "b": b.astype(object).tolist()})
  938:         assert df["a"].dtype == a.dtype
  939:         assert df["b"].dtype == b.dtype
  940: 
  941:     def test_constructor_dict_extension_scalar(self, ea_scalar_and_dtype):
  942:         ea_scalar, ea_dtype = ea_scalar_and_dtype
  943:         df = DataFrame({"a": ea_scalar}, index=[0])
  944:         assert df["a"].dtype == ea_dtype
  945: 
  946:         expected = DataFrame(index=[0], columns=["a"], data=ea_scalar)
  947: 
  948:         tm.assert_frame_equal(df, expected)
  949: 
  950:     @pytest.mark.parametrize(
  951:         "data,dtype",
  952:         [
  953:             (Period("2020-01"), PeriodDtype("M")),
  954:             (Interval(left=0, right=5), IntervalDtype("int64", "right")),
  955:             (
  956:                 Timestamp("2011-01-01", tz="US/Eastern"),
  957:                 DatetimeTZDtype(unit="s", tz="US/Eastern"),
  958:             ),
  959:         ],
  960:     )
  961:     def test_constructor_extension_scalar_data(self, data, dtype):
  962:         # GH 34832
  963:         df = DataFrame(index=[0, 1], columns=["a", "b"], data=data)
  964: 
  965:         assert df["a"].dtype == dtype
  966:         assert df["b"].dtype == dtype
  967: 
  968:         arr = pd.array([data] * 2, dtype=dtype)
  969:         expected = DataFrame({"a": arr, "b": arr})
  970: 
  971:         tm.assert_frame_equal(df, expected)
  972: 
  973:     def test_nested_dict_frame_constructor(self):
  974:         rng = pd.period_range("1/1/2000", periods=5)
  975:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 5)), columns=rng)
  976: 
  977:         data = {}
  978:         for col in df.columns:
  979:             for row in df.index:
  980:                 data.setdefault(col, {})[row] = df._get_value(row, col)
  981: 
  982:         result = DataFrame(data, columns=rng)
  983:         tm.assert_frame_equal(result, df)
  984: 
  985:         data = {}
  986:         for col in df.columns:
  987:             for row in df.index:
  988:                 data.setdefault(row, {})[col] = df._get_value(row, col)
  989: 
  990:         result = DataFrame(data, index=rng).T
  991:         tm.assert_frame_equal(result, df)
  992: 
  993:     def _check_basic_constructor(self, empty):
  994:         # mat: 2d matrix with shape (3, 2) to input. empty - makes sized
  995:         # objects
  996:         mat = empty((2, 3), dtype=float)
  997:         # 2-D input
  998:         frame = DataFrame(mat, columns=["A", "B", "C"], index=[1, 2])
  999: 
 1000:         assert len(frame.index) == 2
 1001:         assert len(frame.columns) == 3
 1002: 
 1003:         # 1-D input
 1004:         frame = DataFrame(empty((3,)), columns=["A"], index=[1, 2, 3])
 1005:         assert len(frame.index) == 3
 1006:         assert len(frame.columns) == 1
 1007: 
 1008:         if empty is not np.ones:
 1009:             msg = r"Cannot convert non-finite values \(NA or inf\) to integer"
 1010:             with pytest.raises(IntCastingNaNError, match=msg):
 1011:                 DataFrame(mat, columns=["A", "B", "C"], index=[1, 2], dtype=np.int64)
 1012:             return
 1013:         else:
 1014:             frame = DataFrame(
 1015:                 mat, columns=["A", "B", "C"], index=[1, 2], dtype=np.int64
 1016:             )
 1017:             assert frame.values.dtype == np.int64
 1018: 
 1019:         # wrong size axis labels
 1020:         msg = r"Shape of passed values is \(2, 3\), indices imply \(1, 3\)"
 1021:         with pytest.raises(ValueError, match=msg):
 1022:             DataFrame(mat, columns=["A", "B", "C"], index=[1])
 1023:         msg = r"Shape of passed values is \(2, 3\), indices imply \(2, 2\)"
 1024:         with pytest.raises(ValueError, match=msg):
 1025:             DataFrame(mat, columns=["A", "B"], index=[1, 2])
 1026: 
 1027:         # higher dim raise exception
 1028:         with pytest.raises(ValueError, match="Must pass 2-d input"):
 1029:             DataFrame(empty((3, 3, 3)), columns=["A", "B", "C"], index=[1])
 1030: 
 1031:         # automatic labeling
 1032:         frame = DataFrame(mat)
 1033:         tm.assert_index_equal(frame.index, Index(range(2)), exact=True)
 1034:         tm.assert_index_equal(frame.columns, Index(range(3)), exact=True)
 1035: 
 1036:         frame = DataFrame(mat, index=[1, 2])
 1037:         tm.assert_index_equal(frame.columns, Index(range(3)), exact=True)
 1038: 
 1039:         frame = DataFrame(mat, columns=["A", "B", "C"])
 1040:         tm.assert_index_equal(frame.index, Index(range(2)), exact=True)
 1041: 
 1042:         # 0-length axis
 1043:         frame = DataFrame(empty((0, 3)))
 1044:         assert len(frame.index) == 0
 1045: 
 1046:         frame = DataFrame(empty((3, 0)))
 1047:         assert len(frame.columns) == 0
 1048: 
 1049:     def test_constructor_ndarray(self):
 1050:         self._check_basic_constructor(np.ones)
 1051: 
 1052:         frame = DataFrame(["foo", "bar"], index=[0, 1], columns=["A"])
 1053:         assert len(frame) == 2
 1054: 
 1055:     def test_constructor_maskedarray(self):
 1056:         self._check_basic_constructor(ma.masked_all)
 1057: 
 1058:         # Check non-masked values
 1059:         mat = ma.masked_all((2, 3), dtype=float)
 1060:         mat[0, 0] = 1.0
 1061:         mat[1, 2] = 2.0
 1062:         frame = DataFrame(mat, columns=["A", "B", "C"], index=[1, 2])
 1063:         assert 1.0 == frame["A"][1]
 1064:         assert 2.0 == frame["C"][2]
 1065: 
 1066:         # what is this even checking??
 1067:         mat = ma.masked_all((2, 3), dtype=float)
 1068:         frame = DataFrame(mat, columns=["A", "B", "C"], index=[1, 2])
 1069:         assert np.all(~np.asarray(frame == frame))
 1070: 
 1071:     @pytest.mark.filterwarnings(
 1072:         "ignore:elementwise comparison failed:DeprecationWarning"
 1073:     )
 1074:     def test_constructor_maskedarray_nonfloat(self):
 1075:         # masked int promoted to float
 1076:         mat = ma.masked_all((2, 3), dtype=int)
 1077:         # 2-D input
 1078:         frame = DataFrame(mat, columns=["A", "B", "C"], index=[1, 2])
 1079: 
 1080:         assert len(frame.index) == 2
 1081:         assert len(frame.columns) == 3
 1082:         assert np.all(~np.asarray(frame == frame))
 1083: 
 1084:         # cast type
 1085:         frame = DataFrame(mat, columns=["A", "B", "C"], index=[1, 2], dtype=np.float64)
 1086:         assert frame.values.dtype == np.float64
 1087: 
 1088:         # Check non-masked values
 1089:         mat2 = ma.copy(mat)
 1090:         mat2[0, 0] = 1
 1091:         mat2[1, 2] = 2
 1092:         frame = DataFrame(mat2, columns=["A", "B", "C"], index=[1, 2])
 1093:         assert 1 == frame["A"][1]
 1094:         assert 2 == frame["C"][2]
 1095: 
 1096:         # masked np.datetime64 stays (use NaT as null)
 1097:         mat = ma.masked_all((2, 3), dtype="M8[ns]")
 1098:         # 2-D input
 1099:         frame = DataFrame(mat, columns=["A", "B", "C"], index=[1, 2])
 1100: 
 1101:         assert len(frame.index) == 2
 1102:         assert len(frame.columns) == 3
 1103:         assert isna(frame).values.all()
 1104: 
 1105:         # cast type
 1106:         msg = r"datetime64\[ns\] values and dtype=int64 is not supported"
 1107:         with pytest.raises(TypeError, match=msg):
 1108:             DataFrame(mat, columns=["A", "B", "C"], index=[1, 2], dtype=np.int64)
 1109: 
 1110:         # Check non-masked values
 1111:         mat2 = ma.copy(mat)
 1112:         mat2[0, 0] = 1
 1113:         mat2[1, 2] = 2
 1114:         frame = DataFrame(mat2, columns=["A", "B", "C"], index=[1, 2])
 1115:         assert 1 == frame["A"].astype("i8")[1]
 1116:         assert 2 == frame["C"].astype("i8")[2]
 1117: 
 1118:         # masked bool promoted to object
 1119:         mat = ma.masked_all((2, 3), dtype=bool)
 1120:         # 2-D input
 1121:         frame = DataFrame(mat, columns=["A", "B", "C"], index=[1, 2])
 1122: 
 1123:         assert len(frame.index) == 2
 1124:         assert len(frame.columns) == 3
 1125:         assert np.all(~np.asarray(frame == frame))
 1126: 
 1127:         # cast type
 1128:         frame = DataFrame(mat, columns=["A", "B", "C"], index=[1, 2], dtype=object)
 1129:         assert frame.values.dtype == object
 1130: 
 1131:         # Check non-masked values
 1132:         mat2 = ma.copy(mat)
 1133:         mat2[0, 0] = True
 1134:         mat2[1, 2] = False
 1135:         frame = DataFrame(mat2, columns=["A", "B", "C"], index=[1, 2])
 1136:         assert frame["A"][1] is True
 1137:         assert frame["C"][2] is False
 1138: 
 1139:     def test_constructor_maskedarray_hardened(self):
 1140:         # Check numpy masked arrays with hard masks -- from GH24574
 1141:         mat_hard = ma.masked_all((2, 2), dtype=float).harden_mask()
 1142:         result = DataFrame(mat_hard, columns=["A", "B"], index=[1, 2])
 1143:         expected = DataFrame(
 1144:             {"A": [np.nan, np.nan], "B": [np.nan, np.nan]},
 1145:             columns=["A", "B"],
 1146:             index=[1, 2],
 1147:             dtype=float,
 1148:         )
 1149:         tm.assert_frame_equal(result, expected)
 1150:         # Check case where mask is hard but no data are masked
 1151:         mat_hard = ma.ones((2, 2), dtype=float).harden_mask()
 1152:         result = DataFrame(mat_hard, columns=["A", "B"], index=[1, 2])
 1153:         expected = DataFrame(
 1154:             {"A": [1.0, 1.0], "B": [1.0, 1.0]},
 1155:             columns=["A", "B"],
 1156:             index=[1, 2],
 1157:             dtype=float,
 1158:         )
 1159:         tm.assert_frame_equal(result, expected)
 1160: 
 1161:     def test_constructor_maskedrecarray_dtype(self):
 1162:         # Ensure constructor honors dtype
 1163:         data = np.ma.array(
 1164:             np.ma.zeros(5, dtype=[("date", "<f8"), ("price", "<f8")]), mask=[False] * 5
 1165:         )
 1166:         data = data.view(mrecords.mrecarray)
 1167:         with pytest.raises(TypeError, match=r"Pass \{name: data\[name\]"):
 1168:             # Support for MaskedRecords deprecated GH#40363
 1169:             DataFrame(data, dtype=int)
 1170: 
 1171:     def test_constructor_corner_shape(self):
 1172:         df = DataFrame(index=[])
 1173:         assert df.values.shape == (0, 0)
 1174: 
 1175:     @pytest.mark.parametrize(
 1176:         "data, index, columns, dtype, expected",
 1177:         [
 1178:             (None, list(range(10)), ["a", "b"], object, np.object_),
 1179:             (None, None, ["a", "b"], "int64", np.dtype("int64")),
 1180:             (None, list(range(10)), ["a", "b"], int, np.dtype("float64")),
 1181:             ({}, None, ["foo", "bar"], None, np.object_),
 1182:             ({"b": 1}, list(range(10)), list("abc"), int, np.dtype("float64")),
 1183:         ],
 1184:     )
 1185:     def test_constructor_dtype(self, data, index, columns, dtype, expected):
 1186:         df = DataFrame(data, index, columns, dtype)
 1187:         assert df.values.dtype == expected
 1188: 
 1189:     @pytest.mark.parametrize(
 1190:         "data,input_dtype,expected_dtype",
 1191:         (
 1192:             ([True, False, None], "boolean", pd.BooleanDtype),
 1193:             ([1.0, 2.0, None], "Float64", pd.Float64Dtype),
 1194:             ([1, 2, None], "Int64", pd.Int64Dtype),
 1195:             (["a", "b", "c"], "string", pd.StringDtype),
 1196:         ),
 1197:     )
 1198:     def test_constructor_dtype_nullable_extension_arrays(
 1199:         self, data, input_dtype, expected_dtype
 1200:     ):
 1201:         df = DataFrame({"a": data}, dtype=input_dtype)
 1202:         assert df["a"].dtype == expected_dtype()
 1203: 
 1204:     def test_constructor_scalar_inference(self, using_infer_string):
 1205:         data = {"int": 1, "bool": True, "float": 3.0, "complex": 4j, "object": "foo"}
 1206:         df = DataFrame(data, index=np.arange(10))
 1207: 
 1208:         assert df["int"].dtype == np.int64
 1209:         assert df["bool"].dtype == np.bool_
 1210:         assert df["float"].dtype == np.float64
 1211:         assert df["complex"].dtype == np.complex128
 1212:         assert df["object"].dtype == np.object_ if not using_infer_string else "string"
 1213: 
 1214:     def test_constructor_arrays_and_scalars(self):
 1215:         df = DataFrame({"a": np.random.default_rng(2).standard_normal(10), "b": True})
 1216:         exp = DataFrame({"a": df["a"].values, "b": [True] * 10})
 1217: 
 1218:         tm.assert_frame_equal(df, exp)
 1219:         with pytest.raises(ValueError, match="must pass an index"):
 1220:             DataFrame({"a": False, "b": True})
 1221: 
 1222:     def test_constructor_DataFrame(self, float_frame):
 1223:         df = DataFrame(float_frame)
 1224:         tm.assert_frame_equal(df, float_frame)
 1225: 
 1226:         df_casted = DataFrame(float_frame, dtype=np.int64)
 1227:         assert df_casted.values.dtype == np.int64
 1228: 
 1229:     def test_constructor_empty_dataframe(self):
 1230:         # GH 20624
 1231:         actual = DataFrame(DataFrame(), dtype="object")
 1232:         expected = DataFrame([], dtype="object")
 1233:         tm.assert_frame_equal(actual, expected)
 1234: 
 1235:     def test_constructor_more(self, float_frame):
 1236:         # used to be in test_matrix.py
 1237:         arr = np.random.default_rng(2).standard_normal(10)
 1238:         dm = DataFrame(arr, columns=["A"], index=np.arange(10))
 1239:         assert dm.values.ndim == 2
 1240: 
 1241:         arr = np.random.default_rng(2).standard_normal(0)
 1242:         dm = DataFrame(arr)
 1243:         assert dm.values.ndim == 2
 1244:         assert dm.values.ndim == 2
 1245: 
 1246:         # no data specified
 1247:         dm = DataFrame(columns=["A", "B"], index=np.arange(10))
 1248:         assert dm.values.shape == (10, 2)
 1249: 
 1250:         dm = DataFrame(columns=["A", "B"])
 1251:         assert dm.values.shape == (0, 2)
 1252: 
 1253:         dm = DataFrame(index=np.arange(10))
 1254:         assert dm.values.shape == (10, 0)
 1255: 
 1256:         # can't cast
 1257:         mat = np.array(["foo", "bar"], dtype=object).reshape(2, 1)
 1258:         msg = "could not convert string to float: 'foo'"
 1259:         with pytest.raises(ValueError, match=msg):
 1260:             DataFrame(mat, index=[0, 1], columns=[0], dtype=float)
 1261: 
 1262:         dm = DataFrame(DataFrame(float_frame._series))
 1263:         tm.assert_frame_equal(dm, float_frame)
 1264: 
 1265:         # int cast
 1266:         dm = DataFrame(
 1267:             {"A": np.ones(10, dtype=int), "B": np.ones(10, dtype=np.float64)},
 1268:             index=np.arange(10),
 1269:         )
 1270: 
 1271:         assert len(dm.columns) == 2
 1272:         assert dm.values.dtype == np.float64
 1273: 
 1274:     def test_constructor_empty_list(self):
 1275:         df = DataFrame([], index=[])
 1276:         expected = DataFrame(index=[])
 1277:         tm.assert_frame_equal(df, expected)
 1278: 
 1279:         # GH 9939
 1280:         df = DataFrame([], columns=["A", "B"])
 1281:         expected = DataFrame({}, columns=["A", "B"])
 1282:         tm.assert_frame_equal(df, expected)
 1283: 
 1284:         # Empty generator: list(empty_gen()) == []
 1285:         def empty_gen():
 1286:             yield from ()
 1287: 
 1288:         df = DataFrame(empty_gen(), columns=["A", "B"])
 1289:         tm.assert_frame_equal(df, expected)
 1290: 
 1291:     def test_constructor_list_of_lists(self, using_infer_string):
 1292:         # GH #484
 1293:         df = DataFrame(data=[[1, "a"], [2, "b"]], columns=["num", "str"])
 1294:         assert is_integer_dtype(df["num"])
 1295:         assert df["str"].dtype == np.object_ if not using_infer_string else "string"
 1296: 
 1297:         # GH 4851
 1298:         # list of 0-dim ndarrays
 1299:         expected = DataFrame({0: np.arange(10)})
 1300:         data = [np.array(x) for x in range(10)]
 1301:         result = DataFrame(data)
 1302:         tm.assert_frame_equal(result, expected)
 1303: 
 1304:     def test_nested_pandasarray_matches_nested_ndarray(self):
 1305:         # GH#43986
 1306:         ser = Series([1, 2])
 1307: 
 1308:         arr = np.array([None, None], dtype=object)
 1309:         arr[0] = ser
 1310:         arr[1] = ser * 2
 1311: 
 1312:         df = DataFrame(arr)
 1313:         expected = DataFrame(pd.array(arr))
 1314:         tm.assert_frame_equal(df, expected)
 1315:         assert df.shape == (2, 1)
 1316:         tm.assert_numpy_array_equal(df[0].values, arr)
 1317: 
 1318:     def test_constructor_list_like_data_nested_list_column(self):
 1319:         # GH 32173
 1320:         arrays = [list("abcd"), list("cdef")]
 1321:         result = DataFrame([[1, 2, 3, 4], [4, 5, 6, 7]], columns=arrays)
 1322: 
 1323:         mi = MultiIndex.from_arrays(arrays)
 1324:         expected = DataFrame([[1, 2, 3, 4], [4, 5, 6, 7]], columns=mi)
 1325: 
 1326:         tm.assert_frame_equal(result, expected)
 1327: 
 1328:     def test_constructor_wrong_length_nested_list_column(self):
 1329:         # GH 32173
 1330:         arrays = [list("abc"), list("cde")]
 1331: 
 1332:         msg = "3 columns passed, passed data had 4"
 1333:         with pytest.raises(ValueError, match=msg):
 1334:             DataFrame([[1, 2, 3, 4], [4, 5, 6, 7]], columns=arrays)
 1335: 
 1336:     def test_constructor_unequal_length_nested_list_column(self):
 1337:         # GH 32173
 1338:         arrays = [list("abcd"), list("cde")]
 1339: 
 1340:         # exception raised inside MultiIndex constructor
 1341:         msg = "all arrays must be same length"
 1342:         with pytest.raises(ValueError, match=msg):
 1343:             DataFrame([[1, 2, 3, 4], [4, 5, 6, 7]], columns=arrays)
 1344: 
 1345:     @pytest.mark.parametrize(
 1346:         "data",
 1347:         [
 1348:             [[Timestamp("2021-01-01")]],
 1349:             [{"x": Timestamp("2021-01-01")}],
 1350:             {"x": [Timestamp("2021-01-01")]},
 1351:             {"x": Timestamp("2021-01-01").as_unit("ns")},
 1352:         ],
 1353:     )
 1354:     def test_constructor_one_element_data_list(self, data):
 1355:         # GH#42810
 1356:         result = DataFrame(data, index=[0, 1, 2], columns=["x"])
 1357:         expected = DataFrame({"x": [Timestamp("2021-01-01")] * 3})
 1358:         tm.assert_frame_equal(result, expected)
 1359: 
 1360:     def test_constructor_sequence_like(self):
 1361:         # GH 3783
 1362:         # collections.Sequence like
 1363: 
 1364:         class DummyContainer(abc.Sequence):
 1365:             def __init__(self, lst) -> None:
 1366:                 self._lst = lst
 1367: 
 1368:             def __getitem__(self, n):
 1369:                 return self._lst.__getitem__(n)
 1370: 
 1371:             def __len__(self) -> int:
 1372:                 return self._lst.__len__()
 1373: 
 1374:         lst_containers = [DummyContainer([1, "a"]), DummyContainer([2, "b"])]
 1375:         columns = ["num", "str"]
 1376:         result = DataFrame(lst_containers, columns=columns)
 1377:         expected = DataFrame([[1, "a"], [2, "b"]], columns=columns)
 1378:         tm.assert_frame_equal(result, expected, check_dtype=False)
 1379: 
 1380:     def test_constructor_stdlib_array(self):
 1381:         # GH 4297
 1382:         # support Array
 1383:         result = DataFrame({"A": array.array("i", range(10))})
 1384:         expected = DataFrame({"A": list(range(10))})
 1385:         tm.assert_frame_equal(result, expected, check_dtype=False)
 1386: 
 1387:         expected = DataFrame([list(range(10)), list(range(10))])
 1388:         result = DataFrame([array.array("i", range(10)), array.array("i", range(10))])
 1389:         tm.assert_frame_equal(result, expected, check_dtype=False)
 1390: 
 1391:     def test_constructor_range(self):
 1392:         # GH26342
 1393:         result = DataFrame(range(10))
 1394:         expected = DataFrame(list(range(10)))
 1395:         tm.assert_frame_equal(result, expected)
 1396: 
 1397:     def test_constructor_list_of_ranges(self):
 1398:         result = DataFrame([range(10), range(10)])
 1399:         expected = DataFrame([list(range(10)), list(range(10))])
 1400:         tm.assert_frame_equal(result, expected)
 1401: 
 1402:     def test_constructor_iterable(self):
 1403:         # GH 21987
 1404:         class Iter:
 1405:             def __iter__(self) -> Iterator:
 1406:                 for i in range(10):
 1407:                     yield [1, 2, 3]
 1408: 
 1409:         expected = DataFrame([[1, 2, 3]] * 10)
 1410:         result = DataFrame(Iter())
 1411:         tm.assert_frame_equal(result, expected)
 1412: 
 1413:     def test_constructor_iterator(self):
 1414:         result = DataFrame(iter(range(10)))
 1415:         expected = DataFrame(list(range(10)))
 1416:         tm.assert_frame_equal(result, expected)
 1417: 
 1418:     def test_constructor_list_of_iterators(self):
 1419:         result = DataFrame([iter(range(10)), iter(range(10))])
 1420:         expected = DataFrame([list(range(10)), list(range(10))])
 1421:         tm.assert_frame_equal(result, expected)
 1422: 
 1423:     def test_constructor_generator(self):
 1424:         # related #2305
 1425: 
 1426:         gen1 = (i for i in range(10))
 1427:         gen2 = (i for i in range(10))
 1428: 
 1429:         expected = DataFrame([list(range(10)), list(range(10))])
 1430:         result = DataFrame([gen1, gen2])
 1431:         tm.assert_frame_equal(result, expected)
 1432: 
 1433:         gen = ([i, "a"] for i in range(10))
 1434:         result = DataFrame(gen)
 1435:         expected = DataFrame({0: range(10), 1: "a"})
 1436:         tm.assert_frame_equal(result, expected, check_dtype=False)
 1437: 
 1438:     def test_constructor_list_of_dicts(self):
 1439:         result = DataFrame([{}])
 1440:         expected = DataFrame(index=RangeIndex(1), columns=[])
 1441:         tm.assert_frame_equal(result, expected)
 1442: 
 1443:     def test_constructor_ordered_dict_nested_preserve_order(self):
 1444:         # see gh-18166
 1445:         nested1 = OrderedDict([("b", 1), ("a", 2)])
 1446:         nested2 = OrderedDict([("b", 2), ("a", 5)])
 1447:         data = OrderedDict([("col2", nested1), ("col1", nested2)])
 1448:         result = DataFrame(data)
 1449:         data = {"col2": [1, 2], "col1": [2, 5]}
 1450:         expected = DataFrame(data=data, index=["b", "a"])
 1451:         tm.assert_frame_equal(result, expected)
 1452: 
 1453:     @pytest.mark.parametrize("dict_type", [dict, OrderedDict])
 1454:     def test_constructor_ordered_dict_preserve_order(self, dict_type):
 1455:         # see gh-13304
 1456:         expected = DataFrame([[2, 1]], columns=["b", "a"])
 1457: 
 1458:         data = dict_type()
 1459:         data["b"] = [2]
 1460:         data["a"] = [1]
 1461: 
 1462:         result = DataFrame(data)
 1463:         tm.assert_frame_equal(result, expected)
 1464: 
 1465:         data = dict_type()
 1466:         data["b"] = 2
 1467:         data["a"] = 1
 1468: 
 1469:         result = DataFrame([data])
 1470:         tm.assert_frame_equal(result, expected)
 1471: 
 1472:     @pytest.mark.parametrize("dict_type", [dict, OrderedDict])
 1473:     def test_constructor_ordered_dict_conflicting_orders(self, dict_type):
 1474:         # the first dict element sets the ordering for the DataFrame,
 1475:         # even if there are conflicting orders from subsequent ones
 1476:         row_one = dict_type()
 1477:         row_one["b"] = 2
 1478:         row_one["a"] = 1
 1479: 
 1480:         row_two = dict_type()
 1481:         row_two["a"] = 1
 1482:         row_two["b"] = 2
 1483: 
 1484:         row_three = {"b": 2, "a": 1}
 1485: 
 1486:         expected = DataFrame([[2, 1], [2, 1]], columns=["b", "a"])
 1487:         result = DataFrame([row_one, row_two])
 1488:         tm.assert_frame_equal(result, expected)
 1489: 
 1490:         expected = DataFrame([[2, 1], [2, 1], [2, 1]], columns=["b", "a"])
 1491:         result = DataFrame([row_one, row_two, row_three])
 1492:         tm.assert_frame_equal(result, expected)
 1493: 
 1494:     def test_constructor_list_of_series_aligned_index(self):
 1495:         series = [Series(i, index=["b", "a", "c"], name=str(i)) for i in range(3)]
 1496:         result = DataFrame(series)
 1497:         expected = DataFrame(
 1498:             {"b": [0, 1, 2], "a": [0, 1, 2], "c": [0, 1, 2]},
 1499:             columns=["b", "a", "c"],
 1500:             index=["0", "1", "2"],
 1501:         )
 1502:         tm.assert_frame_equal(result, expected)
 1503: 
 1504:     def test_constructor_list_of_derived_dicts(self):
 1505:         class CustomDict(dict):
 1506:             pass
 1507: 
 1508:         d = {"a": 1.5, "b": 3}
 1509: 
 1510:         data_custom = [CustomDict(d)]
 1511:         data = [d]
 1512: 
 1513:         result_custom = DataFrame(data_custom)
 1514:         result = DataFrame(data)
 1515:         tm.assert_frame_equal(result, result_custom)
 1516: 
 1517:     def test_constructor_ragged(self):
 1518:         data = {
 1519:             "A": np.random.default_rng(2).standard_normal(10),
 1520:             "B": np.random.default_rng(2).standard_normal(8),
 1521:         }
 1522:         with pytest.raises(ValueError, match="All arrays must be of the same length"):
 1523:             DataFrame(data)
 1524: 
 1525:     def test_constructor_scalar(self):
 1526:         idx = Index(range(3))
 1527:         df = DataFrame({"a": 0}, index=idx)
 1528:         expected = DataFrame({"a": [0, 0, 0]}, index=idx)
 1529:         tm.assert_frame_equal(df, expected, check_dtype=False)
 1530: 
 1531:     def test_constructor_Series_copy_bug(self, float_frame):
 1532:         df = DataFrame(float_frame["A"], index=float_frame.index, columns=["A"])
 1533:         df.copy()
 1534: 
 1535:     def test_constructor_mixed_dict_and_Series(self):
 1536:         data = {}
 1537:         data["A"] = {"foo": 1, "bar": 2, "baz": 3}
 1538:         data["B"] = Series([4, 3, 2, 1], index=["bar", "qux", "baz", "foo"])
 1539: 
 1540:         result = DataFrame(data)
 1541:         assert result.index.is_monotonic_increasing
 1542: 
 1543:         # ordering ambiguous, raise exception
 1544:         with pytest.raises(ValueError, match="ambiguous ordering"):
 1545:             DataFrame({"A": ["a", "b"], "B": {"a": "a", "b": "b"}})
 1546: 
 1547:         # this is OK though
 1548:         result = DataFrame({"A": ["a", "b"], "B": Series(["a", "b"], index=["a", "b"])})
 1549:         expected = DataFrame({"A": ["a", "b"], "B": ["a", "b"]}, index=["a", "b"])
 1550:         tm.assert_frame_equal(result, expected)
 1551: 
 1552:     def test_constructor_mixed_type_rows(self):
 1553:         # Issue 25075
 1554:         data = [[1, 2], (3, 4)]
 1555:         result = DataFrame(data)
 1556:         expected = DataFrame([[1, 2], [3, 4]])
 1557:         tm.assert_frame_equal(result, expected)
 1558: 
 1559:     @pytest.mark.parametrize(
 1560:         "tuples,lists",
 1561:         [
 1562:             ((), []),
 1563:             ((()), []),
 1564:             (((), ()), [(), ()]),
 1565:             (((), ()), [[], []]),
 1566:             (([], []), [[], []]),
 1567:             (([1], [2]), [[1], [2]]),  # GH 32776
 1568:             (([1, 2, 3], [4, 5, 6]), [[1, 2, 3], [4, 5, 6]]),
 1569:         ],
 1570:     )
 1571:     def test_constructor_tuple(self, tuples, lists):
 1572:         # GH 25691
 1573:         result = DataFrame(tuples)
 1574:         expected = DataFrame(lists)
 1575:         tm.assert_frame_equal(result, expected)
 1576: 
 1577:     def test_constructor_list_of_tuples(self):
 1578:         result = DataFrame({"A": [(1, 2), (3, 4)]})
 1579:         expected = DataFrame({"A": Series([(1, 2), (3, 4)])})
 1580:         tm.assert_frame_equal(result, expected)
 1581: 
 1582:     def test_constructor_list_of_namedtuples(self):
 1583:         # GH11181
 1584:         named_tuple = namedtuple("Pandas", list("ab"))
 1585:         tuples = [named_tuple(1, 3), named_tuple(2, 4)]
 1586:         expected = DataFrame({"a": [1, 2], "b": [3, 4]})
 1587:         result = DataFrame(tuples)
 1588:         tm.assert_frame_equal(result, expected)
 1589: 
 1590:         # with columns
 1591:         expected = DataFrame({"y": [1, 2], "z": [3, 4]})
 1592:         result = DataFrame(tuples, columns=["y", "z"])
 1593:         tm.assert_frame_equal(result, expected)
 1594: 
 1595:     def test_constructor_list_of_dataclasses(self):
 1596:         # GH21910
 1597:         Point = make_dataclass("Point", [("x", int), ("y", int)])
 1598: 
 1599:         data = [Point(0, 3), Point(1, 3)]
 1600:         expected = DataFrame({"x": [0, 1], "y": [3, 3]})
 1601:         result = DataFrame(data)
 1602:         tm.assert_frame_equal(result, expected)
 1603: 
 1604:     def test_constructor_list_of_dataclasses_with_varying_types(self):
 1605:         # GH21910
 1606:         # varying types
 1607:         Point = make_dataclass("Point", [("x", int), ("y", int)])
 1608:         HLine = make_dataclass("HLine", [("x0", int), ("x1", int), ("y", int)])
 1609: 
 1610:         data = [Point(0, 3), HLine(1, 3, 3)]
 1611: 
 1612:         expected = DataFrame(
 1613:             {"x": [0, np.nan], "y": [3, 3], "x0": [np.nan, 1], "x1": [np.nan, 3]}
 1614:         )
 1615:         result = DataFrame(data)
 1616:         tm.assert_frame_equal(result, expected)
 1617: 
 1618:     def test_constructor_list_of_dataclasses_error_thrown(self):
 1619:         # GH21910
 1620:         Point = make_dataclass("Point", [("x", int), ("y", int)])
 1621: 
 1622:         # expect TypeError
 1623:         msg = "asdict() should be called on dataclass instances"
 1624:         with pytest.raises(TypeError, match=re.escape(msg)):
 1625:             DataFrame([Point(0, 0), {"x": 1, "y": 0}])
 1626: 
 1627:     def test_constructor_list_of_dict_order(self):
 1628:         # GH10056
 1629:         data = [
 1630:             {"First": 1, "Second": 4, "Third": 7, "Fourth": 10},
 1631:             {"Second": 5, "First": 2, "Fourth": 11, "Third": 8},
 1632:             {"Second": 6, "First": 3, "Fourth": 12, "Third": 9, "YYY": 14, "XXX": 13},
 1633:         ]
 1634:         expected = DataFrame(
 1635:             {
 1636:                 "First": [1, 2, 3],
 1637:                 "Second": [4, 5, 6],
 1638:                 "Third": [7, 8, 9],
 1639:                 "Fourth": [10, 11, 12],
 1640:                 "YYY": [None, None, 14],
 1641:                 "XXX": [None, None, 13],
 1642:             }
 1643:         )
 1644:         result = DataFrame(data)
 1645:         tm.assert_frame_equal(result, expected)
 1646: 
 1647:     def test_constructor_Series_named(self):
 1648:         a = Series([1, 2, 3], index=["a", "b", "c"], name="x")
 1649:         df = DataFrame(a)
 1650:         assert df.columns[0] == "x"
 1651:         tm.assert_index_equal(df.index, a.index)
 1652: 
 1653:         # ndarray like
 1654:         arr = np.random.default_rng(2).standard_normal(10)
 1655:         s = Series(arr, name="x")
 1656:         df = DataFrame(s)
 1657:         expected = DataFrame({"x": s})
 1658:         tm.assert_frame_equal(df, expected)
 1659: 
 1660:         s = Series(arr, index=range(3, 13))
 1661:         df = DataFrame(s)
 1662:         expected = DataFrame({0: s})
 1663:         tm.assert_frame_equal(df, expected)
 1664: 
 1665:         msg = r"Shape of passed values is \(10, 1\), indices imply \(10, 2\)"
 1666:         with pytest.raises(ValueError, match=msg):
 1667:             DataFrame(s, columns=[1, 2])
 1668: 
 1669:         # #2234
 1670:         a = Series([], name="x", dtype=object)
 1671:         df = DataFrame(a)
 1672:         assert df.columns[0] == "x"
 1673: 
 1674:         # series with name and w/o
 1675:         s1 = Series(arr, name="x")
 1676:         df = DataFrame([s1, arr]).T
 1677:         expected = DataFrame({"x": s1, "Unnamed 0": arr}, columns=["x", "Unnamed 0"])
 1678:         tm.assert_frame_equal(df, expected)
 1679: 
 1680:         # this is a bit non-intuitive here; the series collapse down to arrays
 1681:         df = DataFrame([arr, s1]).T
 1682:         expected = DataFrame({1: s1, 0: arr}, columns=[0, 1])
 1683:         tm.assert_frame_equal(df, expected)
 1684: 
 1685:     def test_constructor_Series_named_and_columns(self):
 1686:         # GH 9232 validation
 1687: 
 1688:         s0 = Series(range(5), name=0)
 1689:         s1 = Series(range(5), name=1)
 1690: 
 1691:         # matching name and column gives standard frame
 1692:         tm.assert_frame_equal(DataFrame(s0, columns=[0]), s0.to_frame())
 1693:         tm.assert_frame_equal(DataFrame(s1, columns=[1]), s1.to_frame())
 1694: 
 1695:         # non-matching produces empty frame
 1696:         assert DataFrame(s0, columns=[1]).empty
 1697:         assert DataFrame(s1, columns=[0]).empty
 1698: 
 1699:     def test_constructor_Series_differently_indexed(self):
 1700:         # name
 1701:         s1 = Series([1, 2, 3], index=["a", "b", "c"], name="x")
 1702: 
 1703:         # no name
 1704:         s2 = Series([1, 2, 3], index=["a", "b", "c"])
 1705: 
 1706:         other_index = Index(["a", "b"])
 1707: 
 1708:         df1 = DataFrame(s1, index=other_index)
 1709:         exp1 = DataFrame(s1.reindex(other_index))
 1710:         assert df1.columns[0] == "x"
 1711:         tm.assert_frame_equal(df1, exp1)
 1712: 
 1713:         df2 = DataFrame(s2, index=other_index)
 1714:         exp2 = DataFrame(s2.reindex(other_index))
 1715:         assert df2.columns[0] == 0
 1716:         tm.assert_index_equal(df2.index, other_index)
 1717:         tm.assert_frame_equal(df2, exp2)
 1718: 
 1719:     @pytest.mark.parametrize(
 1720:         "name_in1,name_in2,name_in3,name_out",
 1721:         [
 1722:             ("idx", "idx", "idx", "idx"),
 1723:             ("idx", "idx", None, None),
 1724:             ("idx", None, None, None),
 1725:             ("idx1", "idx2", None, None),
 1726:             ("idx1", "idx1", "idx2", None),
 1727:             ("idx1", "idx2", "idx3", None),
 1728:             (None, None, None, None),
 1729:         ],
 1730:     )
 1731:     def test_constructor_index_names(self, name_in1, name_in2, name_in3, name_out):
 1732:         # GH13475
 1733:         indices = [
 1734:             Index(["a", "b", "c"], name=name_in1),
 1735:             Index(["b", "c", "d"], name=name_in2),
 1736:             Index(["c", "d", "e"], name=name_in3),
 1737:         ]
 1738:         series = {
 1739:             c: Series([0, 1, 2], index=i) for i, c in zip(indices, ["x", "y", "z"])
 1740:         }
 1741:         result = DataFrame(series)
 1742: 
 1743:         exp_ind = Index(["a", "b", "c", "d", "e"], name=name_out)
 1744:         expected = DataFrame(
 1745:             {
 1746:                 "x": [0, 1, 2, np.nan, np.nan],
 1747:                 "y": [np.nan, 0, 1, 2, np.nan],
 1748:                 "z": [np.nan, np.nan, 0, 1, 2],
 1749:             },
 1750:             index=exp_ind,
 1751:         )
 1752: 
 1753:         tm.assert_frame_equal(result, expected)
 1754: 
 1755:     def test_constructor_manager_resize(self, float_frame):
 1756:         index = list(float_frame.index[:5])
 1757:         columns = list(float_frame.columns[:3])
 1758: 
 1759:         msg = "Passing a BlockManager to DataFrame"
 1760:         with tm.assert_produces_warning(
 1761:             DeprecationWarning, match=msg, check_stacklevel=False
 1762:         ):
 1763:             result = DataFrame(float_frame._mgr, index=index, columns=columns)
 1764:         tm.assert_index_equal(result.index, Index(index))
 1765:         tm.assert_index_equal(result.columns, Index(columns))
 1766: 
 1767:     def test_constructor_mix_series_nonseries(self, float_frame):
 1768:         df = DataFrame(
 1769:             {"A": float_frame["A"], "B": list(float_frame["B"])}, columns=["A", "B"]
 1770:         )
 1771:         tm.assert_frame_equal(df, float_frame.loc[:, ["A", "B"]])
 1772: 
 1773:         msg = "does not match index length"
 1774:         with pytest.raises(ValueError, match=msg):
 1775:             DataFrame({"A": float_frame["A"], "B": list(float_frame["B"])[:-2]})
 1776: 
 1777:     def test_constructor_miscast_na_int_dtype(self):
 1778:         msg = r"Cannot convert non-finite values \(NA or inf\) to integer"
 1779: 
 1780:         with pytest.raises(IntCastingNaNError, match=msg):
 1781:             DataFrame([[np.nan, 1], [1, 0]], dtype=np.int64)
 1782: 
 1783:     def test_constructor_column_duplicates(self):
 1784:         # it works! #2079
 1785:         df = DataFrame([[8, 5]], columns=["a", "a"])
 1786:         edf = DataFrame([[8, 5]])
 1787:         edf.columns = ["a", "a"]
 1788: 
 1789:         tm.assert_frame_equal(df, edf)
 1790: 
 1791:         idf = DataFrame.from_records([(8, 5)], columns=["a", "a"])
 1792: 
 1793:         tm.assert_frame_equal(idf, edf)
 1794: 
 1795:     def test_constructor_empty_with_string_dtype(self):
 1796:         # GH 9428
 1797:         expected = DataFrame(index=[0, 1], columns=[0, 1], dtype=object)
 1798: 
 1799:         df = DataFrame(index=[0, 1], columns=[0, 1], dtype=str)
 1800:         tm.assert_frame_equal(df, expected)
 1801:         df = DataFrame(index=[0, 1], columns=[0, 1], dtype=np.str_)
 1802:         tm.assert_frame_equal(df, expected)
 1803:         df = DataFrame(index=[0, 1], columns=[0, 1], dtype="U5")
 1804:         tm.assert_frame_equal(df, expected)
 1805: 
 1806:     def test_constructor_empty_with_string_extension(self, nullable_string_dtype):
 1807:         # GH 34915
 1808:         expected = DataFrame(columns=["c1"], dtype=nullable_string_dtype)
 1809:         df = DataFrame(columns=["c1"], dtype=nullable_string_dtype)
 1810:         tm.assert_frame_equal(df, expected)
 1811: 
 1812:     def test_constructor_single_value(self):
 1813:         # expecting single value upcasting here
 1814:         df = DataFrame(0.0, index=[1, 2, 3], columns=["a", "b", "c"])
 1815:         tm.assert_frame_equal(
 1816:             df, DataFrame(np.zeros(df.shape).astype("float64"), df.index, df.columns)
 1817:         )
 1818: 
 1819:         df = DataFrame(0, index=[1, 2, 3], columns=["a", "b", "c"])
 1820:         tm.assert_frame_equal(
 1821:             df, DataFrame(np.zeros(df.shape).astype("int64"), df.index, df.columns)
 1822:         )
 1823: 
 1824:         df = DataFrame("a", index=[1, 2], columns=["a", "c"])
 1825:         tm.assert_frame_equal(
 1826:             df,
 1827:             DataFrame(
 1828:                 np.array([["a", "a"], ["a", "a"]], dtype=object),
 1829:                 index=[1, 2],
 1830:                 columns=["a", "c"],
 1831:             ),
 1832:         )
 1833: 
 1834:         msg = "DataFrame constructor not properly called!"
 1835:         with pytest.raises(ValueError, match=msg):
 1836:             DataFrame("a", [1, 2])
 1837:         with pytest.raises(ValueError, match=msg):
 1838:             DataFrame("a", columns=["a", "c"])
 1839: 
 1840:         msg = "incompatible data and dtype"
 1841:         with pytest.raises(TypeError, match=msg):
 1842:             DataFrame("a", [1, 2], ["a", "c"], float)
 1843: 
 1844:     def test_constructor_with_datetimes(self, using_infer_string):
 1845:         intname = np.dtype(int).name
 1846:         floatname = np.dtype(np.float64).name
 1847:         objectname = np.dtype(np.object_).name
 1848: 
 1849:         # single item
 1850:         df = DataFrame(
 1851:             {
 1852:                 "A": 1,
 1853:                 "B": "foo",
 1854:                 "C": "bar",
 1855:                 "D": Timestamp("20010101"),
 1856:                 "E": datetime(2001, 1, 2, 0, 0),
 1857:             },
 1858:             index=np.arange(10),
 1859:         )
 1860:         result = df.dtypes
 1861:         expected = Series(
 1862:             [np.dtype("int64")]
 1863:             + [np.dtype(objectname) if not using_infer_string else "string"] * 2
 1864:             + [np.dtype("M8[s]"), np.dtype("M8[us]")],
 1865:             index=list("ABCDE"),
 1866:         )
 1867:         tm.assert_series_equal(result, expected)
 1868: 
 1869:         # check with ndarray construction ndim==0 (e.g. we are passing a ndim 0
 1870:         # ndarray with a dtype specified)
 1871:         df = DataFrame(
 1872:             {
 1873:                 "a": 1.0,
 1874:                 "b": 2,
 1875:                 "c": "foo",
 1876:                 floatname: np.array(1.0, dtype=floatname),
 1877:                 intname: np.array(1, dtype=intname),
 1878:             },
 1879:             index=np.arange(10),
 1880:         )
 1881:         result = df.dtypes
 1882:         expected = Series(
 1883:             [np.dtype("float64")]
 1884:             + [np.dtype("int64")]
 1885:             + [np.dtype("object") if not using_infer_string else "string"]
 1886:             + [np.dtype("float64")]
 1887:             + [np.dtype(intname)],
 1888:             index=["a", "b", "c", floatname, intname],
 1889:         )
 1890:         tm.assert_series_equal(result, expected)
 1891: 
 1892:         # check with ndarray construction ndim>0
 1893:         df = DataFrame(
 1894:             {
 1895:                 "a": 1.0,
 1896:                 "b": 2,
 1897:                 "c": "foo",
 1898:                 floatname: np.array([1.0] * 10, dtype=floatname),
 1899:                 intname: np.array([1] * 10, dtype=intname),
 1900:             },
 1901:             index=np.arange(10),
 1902:         )
 1903:         result = df.dtypes
 1904:         expected = Series(
 1905:             [np.dtype("float64")]
 1906:             + [np.dtype("int64")]
 1907:             + [np.dtype("object") if not using_infer_string else "string"]
 1908:             + [np.dtype("float64")]
 1909:             + [np.dtype(intname)],
 1910:             index=["a", "b", "c", floatname, intname],
 1911:         )
 1912:         tm.assert_series_equal(result, expected)
 1913: 
 1914:     def test_constructor_with_datetimes1(self):
 1915:         # GH 2809
 1916:         ind = date_range(start="2000-01-01", freq="D", periods=10)
 1917:         datetimes = [ts.to_pydatetime() for ts in ind]
 1918:         datetime_s = Series(datetimes)
 1919:         assert datetime_s.dtype == "M8[ns]"
 1920: 
 1921:     def test_constructor_with_datetimes2(self):
 1922:         # GH 2810
 1923:         ind = date_range(start="2000-01-01", freq="D", periods=10)
 1924:         datetimes = [ts.to_pydatetime() for ts in ind]
 1925:         dates = [ts.date() for ts in ind]
 1926:         df = DataFrame(datetimes, columns=["datetimes"])
 1927:         df["dates"] = dates
 1928:         result = df.dtypes
 1929:         expected = Series(
 1930:             [np.dtype("datetime64[ns]"), np.dtype("object")],
 1931:             index=["datetimes", "dates"],
 1932:         )
 1933:         tm.assert_series_equal(result, expected)
 1934: 
 1935:     def test_constructor_with_datetimes3(self):
 1936:         # GH 7594
 1937:         # don't coerce tz-aware
 1938:         tz = pytz.timezone("US/Eastern")
 1939:         dt = tz.localize(datetime(2012, 1, 1))
 1940: 
 1941:         df = DataFrame({"End Date": dt}, index=[0])
 1942:         assert df.iat[0, 0] == dt
 1943:         tm.assert_series_equal(
 1944:             df.dtypes, Series({"End Date": "datetime64[us, US/Eastern]"}, dtype=object)
 1945:         )
 1946: 
 1947:         df = DataFrame([{"End Date": dt}])
 1948:         assert df.iat[0, 0] == dt
 1949:         tm.assert_series_equal(
 1950:             df.dtypes, Series({"End Date": "datetime64[ns, US/Eastern]"}, dtype=object)
 1951:         )
 1952: 
 1953:     def test_constructor_with_datetimes4(self):
 1954:         # tz-aware (UTC and other tz's)
 1955:         # GH 8411
 1956:         dr = date_range("20130101", periods=3)
 1957:         df = DataFrame({"value": dr})
 1958:         assert df.iat[0, 0].tz is None
 1959:         dr = date_range("20130101", periods=3, tz="UTC")
 1960:         df = DataFrame({"value": dr})
 1961:         assert str(df.iat[0, 0].tz) == "UTC"
 1962:         dr = date_range("20130101", periods=3, tz="US/Eastern")
 1963:         df = DataFrame({"value": dr})
 1964:         assert str(df.iat[0, 0].tz) == "US/Eastern"
 1965: 
 1966:     def test_constructor_with_datetimes5(self):
 1967:         # GH 7822
 1968:         # preserver an index with a tz on dict construction
 1969:         i = date_range("1/1/2011", periods=5, freq="10s", tz="US/Eastern")
 1970: 
 1971:         expected = DataFrame({"a": i.to_series().reset_index(drop=True)})
 1972:         df = DataFrame()
 1973:         df["a"] = i
 1974:         tm.assert_frame_equal(df, expected)
 1975: 
 1976:         df = DataFrame({"a": i})
 1977:         tm.assert_frame_equal(df, expected)
 1978: 
 1979:     def test_constructor_with_datetimes6(self):
 1980:         # multiples
 1981:         i = date_range("1/1/2011", periods=5, freq="10s", tz="US/Eastern")
 1982:         i_no_tz = date_range("1/1/2011", periods=5, freq="10s")
 1983:         df = DataFrame({"a": i, "b": i_no_tz})
 1984:         expected = DataFrame({"a": i.to_series().reset_index(drop=True), "b": i_no_tz})
 1985:         tm.assert_frame_equal(df, expected)
 1986: 
 1987:     @pytest.mark.parametrize(
 1988:         "arr",
 1989:         [
 1990:             np.array([None, None, None, None, datetime.now(), None]),
 1991:             np.array([None, None, datetime.now(), None]),
 1992:             [[np.datetime64("NaT")], [None]],
 1993:             [[np.datetime64("NaT")], [pd.NaT]],
 1994:             [[None], [np.datetime64("NaT")]],
 1995:             [[None], [pd.NaT]],
 1996:             [[pd.NaT], [np.datetime64("NaT")]],
 1997:             [[pd.NaT], [None]],
 1998:         ],
 1999:     )
 2000:     def test_constructor_datetimes_with_nulls(self, arr):
 2001:         # gh-15869, GH#11220
 2002:         result = DataFrame(arr).dtypes
 2003:         expected = Series([np.dtype("datetime64[ns]")])
 2004:         tm.assert_series_equal(result, expected)
 2005: 
 2006:     @pytest.mark.parametrize("order", ["K", "A", "C", "F"])
 2007:     @pytest.mark.parametrize(
 2008:         "unit",
 2009:         ["M", "D", "h", "m", "s", "ms", "us", "ns"],
 2010:     )
 2011:     def test_constructor_datetimes_non_ns(self, order, unit):
 2012:         dtype = f"datetime64[{unit}]"
 2013:         na = np.array(
 2014:             [
 2015:                 ["2015-01-01", "2015-01-02", "2015-01-03"],
 2016:                 ["2017-01-01", "2017-01-02", "2017-02-03"],
 2017:             ],
 2018:             dtype=dtype,
 2019:             order=order,
 2020:         )
 2021:         df = DataFrame(na)
 2022:         expected = DataFrame(na.astype("M8[ns]"))
 2023:         if unit in ["M", "D", "h", "m"]:
 2024:             with pytest.raises(TypeError, match="Cannot cast"):
 2025:                 expected.astype(dtype)
 2026: 
 2027:             # instead the constructor casts to the closest supported reso, i.e. "s"
 2028:             expected = expected.astype("datetime64[s]")
 2029:         else:
 2030:             expected = expected.astype(dtype=dtype)
 2031: 
 2032:         tm.assert_frame_equal(df, expected)
 2033: 
 2034:     @pytest.mark.parametrize("order", ["K", "A", "C", "F"])
 2035:     @pytest.mark.parametrize(
 2036:         "unit",
 2037:         [
 2038:             "D",
 2039:             "h",
 2040:             "m",
 2041:             "s",
 2042:             "ms",
 2043:             "us",
 2044:             "ns",
 2045:         ],
 2046:     )
 2047:     def test_constructor_timedelta_non_ns(self, order, unit):
 2048:         dtype = f"timedelta64[{unit}]"
 2049:         na = np.array(
 2050:             [
 2051:                 [np.timedelta64(1, "D"), np.timedelta64(2, "D")],
 2052:                 [np.timedelta64(4, "D"), np.timedelta64(5, "D")],
 2053:             ],
 2054:             dtype=dtype,
 2055:             order=order,
 2056:         )
 2057:         df = DataFrame(na)
 2058:         if unit in ["D", "h", "m"]:
 2059:             # we get the nearest supported unit, i.e. "s"
 2060:             exp_unit = "s"
 2061:         else:
 2062:             exp_unit = unit
 2063:         exp_dtype = np.dtype(f"m8[{exp_unit}]")
 2064:         expected = DataFrame(
 2065:             [
 2066:                 [Timedelta(1, "D"), Timedelta(2, "D")],
 2067:                 [Timedelta(4, "D"), Timedelta(5, "D")],
 2068:             ],
 2069:             dtype=exp_dtype,
 2070:         )
 2071:         # TODO(2.0): ideally we should get the same 'expected' without passing
 2072:         #  dtype=exp_dtype.
 2073:         tm.assert_frame_equal(df, expected)
 2074: 
 2075:     def test_constructor_for_list_with_dtypes(self, using_infer_string):
 2076:         # test list of lists/ndarrays
 2077:         df = DataFrame([np.arange(5) for x in range(5)])
 2078:         result = df.dtypes
 2079:         expected = Series([np.dtype("int")] * 5)
 2080:         tm.assert_series_equal(result, expected)
 2081: 
 2082:         df = DataFrame([np.array(np.arange(5), dtype="int32") for x in range(5)])
 2083:         result = df.dtypes
 2084:         expected = Series([np.dtype("int32")] * 5)
 2085:         tm.assert_series_equal(result, expected)
 2086: 
 2087:         # overflow issue? (we always expected int64 upcasting here)
 2088:         df = DataFrame({"a": [2**31, 2**31 + 1]})
 2089:         assert df.dtypes.iloc[0] == np.dtype("int64")
 2090: 
 2091:         # GH #2751 (construction with no index specified), make sure we cast to
 2092:         # platform values
 2093:         df = DataFrame([1, 2])
 2094:         assert df.dtypes.iloc[0] == np.dtype("int64")
 2095: 
 2096:         df = DataFrame([1.0, 2.0])
 2097:         assert df.dtypes.iloc[0] == np.dtype("float64")
 2098: 
 2099:         df = DataFrame({"a": [1, 2]})
 2100:         assert df.dtypes.iloc[0] == np.dtype("int64")
 2101: 
 2102:         df = DataFrame({"a": [1.0, 2.0]})
 2103:         assert df.dtypes.iloc[0] == np.dtype("float64")
 2104: 
 2105:         df = DataFrame({"a": 1}, index=range(3))
 2106:         assert df.dtypes.iloc[0] == np.dtype("int64")
 2107: 
 2108:         df = DataFrame({"a": 1.0}, index=range(3))
 2109:         assert df.dtypes.iloc[0] == np.dtype("float64")
 2110: 
 2111:         # with object list
 2112:         df = DataFrame(
 2113:             {
 2114:                 "a": [1, 2, 4, 7],
 2115:                 "b": [1.2, 2.3, 5.1, 6.3],
 2116:                 "c": list("abcd"),
 2117:                 "d": [datetime(2000, 1, 1) for i in range(4)],
 2118:                 "e": [1.0, 2, 4.0, 7],
 2119:             }
 2120:         )
 2121:         result = df.dtypes
 2122:         expected = Series(
 2123:             [
 2124:                 np.dtype("int64"),
 2125:                 np.dtype("float64"),
 2126:                 np.dtype("object") if not using_infer_string else "string",
 2127:                 np.dtype("datetime64[ns]"),
 2128:                 np.dtype("float64"),
 2129:             ],
 2130:             index=list("abcde"),
 2131:         )
 2132:         tm.assert_series_equal(result, expected)
 2133: 
 2134:     def test_constructor_frame_copy(self, float_frame):
 2135:         cop = DataFrame(float_frame, copy=True)
 2136:         cop["A"] = 5
 2137:         assert (cop["A"] == 5).all()
 2138:         assert not (float_frame["A"] == 5).all()
 2139: 
 2140:     def test_constructor_frame_shallow_copy(self, float_frame):
 2141:         # constructing a DataFrame from DataFrame with copy=False should still
 2142:         # give a "shallow" copy (share data, not attributes)
 2143:         # https://github.com/pandas-dev/pandas/issues/49523
 2144:         orig = float_frame.copy()
 2145:         cop = DataFrame(float_frame)
 2146:         assert cop._mgr is not float_frame._mgr
 2147:         # Overwriting index of copy doesn't change original
 2148:         cop.index = np.arange(len(cop))
 2149:         tm.assert_frame_equal(float_frame, orig)
 2150: 
 2151:     def test_constructor_ndarray_copy(
 2152:         self, float_frame, using_array_manager, using_copy_on_write
 2153:     ):
 2154:         if not using_array_manager:
 2155:             arr = float_frame.values.copy()
 2156:             df = DataFrame(arr)
 2157: 
 2158:             arr[5] = 5
 2159:             if using_copy_on_write:
 2160:                 assert not (df.values[5] == 5).all()
 2161:             else:
 2162:                 assert (df.values[5] == 5).all()
 2163: 
 2164:             df = DataFrame(arr, copy=True)
 2165:             arr[6] = 6
 2166:             assert not (df.values[6] == 6).all()
 2167:         else:
 2168:             arr = float_frame.values.copy()
 2169:             # default: copy to ensure contiguous arrays
 2170:             df = DataFrame(arr)
 2171:             assert df._mgr.arrays[0].flags.c_contiguous
 2172:             arr[0, 0] = 100
 2173:             assert df.iloc[0, 0] != 100
 2174: 
 2175:             # manually specify copy=False
 2176:             df = DataFrame(arr, copy=False)
 2177:             assert not df._mgr.arrays[0].flags.c_contiguous
 2178:             arr[0, 0] = 1000
 2179:             assert df.iloc[0, 0] == 1000
 2180: 
 2181:     def test_constructor_series_copy(self, float_frame):
 2182:         series = float_frame._series
 2183: 
 2184:         df = DataFrame({"A": series["A"]}, copy=True)
 2185:         # TODO can be replaced with `df.loc[:, "A"] = 5` after deprecation about
 2186:         # inplace mutation is enforced
 2187:         df.loc[df.index[0] : df.index[-1], "A"] = 5
 2188: 
 2189:         assert not (series["A"] == 5).all()
 2190: 
 2191:     @pytest.mark.parametrize(
 2192:         "df",
 2193:         [
 2194:             DataFrame([[1, 2, 3], [4, 5, 6]], index=[1, np.nan]),
 2195:             DataFrame([[1, 2, 3], [4, 5, 6]], columns=[1.1, 2.2, np.nan]),
 2196:             DataFrame([[0, 1, 2, 3], [4, 5, 6, 7]], columns=[np.nan, 1.1, 2.2, np.nan]),
 2197:             DataFrame(
 2198:                 [[0.0, 1, 2, 3.0], [4, 5, 6, 7]], columns=[np.nan, 1.1, 2.2, np.nan]
 2199:             ),
 2200:             DataFrame([[0.0, 1, 2, 3.0], [4, 5, 6, 7]], columns=[np.nan, 1, 2, 2]),
 2201:         ],
 2202:     )
 2203:     def test_constructor_with_nas(self, df):
 2204:         # GH 5016
 2205:         # na's in indices
 2206:         # GH 21428 (non-unique columns)
 2207: 
 2208:         for i in range(len(df.columns)):
 2209:             df.iloc[:, i]
 2210: 
 2211:         indexer = np.arange(len(df.columns))[isna(df.columns)]
 2212: 
 2213:         # No NaN found -> error
 2214:         if len(indexer) == 0:
 2215:             with pytest.raises(KeyError, match="^nan$"):
 2216:                 df.loc[:, np.nan]
 2217:         # single nan should result in Series
 2218:         elif len(indexer) == 1:
 2219:             tm.assert_series_equal(df.iloc[:, indexer[0]], df.loc[:, np.nan])
 2220:         # multiple nans should result in DataFrame
 2221:         else:
 2222:             tm.assert_frame_equal(df.iloc[:, indexer], df.loc[:, np.nan])
 2223: 
 2224:     def test_constructor_lists_to_object_dtype(self):
 2225:         # from #1074
 2226:         d = DataFrame({"a": [np.nan, False]})
 2227:         assert d["a"].dtype == np.object_
 2228:         assert not d["a"][1]
 2229: 
 2230:     def test_constructor_ndarray_categorical_dtype(self):
 2231:         cat = Categorical(["A", "B", "C"])
 2232:         arr = np.array(cat).reshape(-1, 1)
 2233:         arr = np.broadcast_to(arr, (3, 4))
 2234: 
 2235:         result = DataFrame(arr, dtype=cat.dtype)
 2236: 
 2237:         expected = DataFrame({0: cat, 1: cat, 2: cat, 3: cat})
 2238:         tm.assert_frame_equal(result, expected)
 2239: 
 2240:     def test_constructor_categorical(self):
 2241:         # GH8626
 2242: 
 2243:         # dict creation
 2244:         df = DataFrame({"A": list("abc")}, dtype="category")
 2245:         expected = Series(list("abc"), dtype="category", name="A")
 2246:         tm.assert_series_equal(df["A"], expected)
 2247: 
 2248:         # to_frame
 2249:         s = Series(list("abc"), dtype="category")
 2250:         result = s.to_frame()
 2251:         expected = Series(list("abc"), dtype="category", name=0)
 2252:         tm.assert_series_equal(result[0], expected)
 2253:         result = s.to_frame(name="foo")
 2254:         expected = Series(list("abc"), dtype="category", name="foo")
 2255:         tm.assert_series_equal(result["foo"], expected)
 2256: 
 2257:         # list-like creation
 2258:         df = DataFrame(list("abc"), dtype="category")
 2259:         expected = Series(list("abc"), dtype="category", name=0)
 2260:         tm.assert_series_equal(df[0], expected)
 2261: 
 2262:     def test_construct_from_1item_list_of_categorical(self):
 2263:         # pre-2.0 this behaved as DataFrame({0: cat}), in 2.0 we remove
 2264:         #  Categorical special case
 2265:         # ndim != 1
 2266:         cat = Categorical(list("abc"))
 2267:         df = DataFrame([cat])
 2268:         expected = DataFrame([cat.astype(object)])
 2269:         tm.assert_frame_equal(df, expected)
 2270: 
 2271:     def test_construct_from_list_of_categoricals(self):
 2272:         # pre-2.0 this behaved as DataFrame({0: cat}), in 2.0 we remove
 2273:         #  Categorical special case
 2274: 
 2275:         df = DataFrame([Categorical(list("abc")), Categorical(list("abd"))])
 2276:         expected = DataFrame([["a", "b", "c"], ["a", "b", "d"]])
 2277:         tm.assert_frame_equal(df, expected)
 2278: 
 2279:     def test_from_nested_listlike_mixed_types(self):
 2280:         # pre-2.0 this behaved as DataFrame({0: cat}), in 2.0 we remove
 2281:         #  Categorical special case
 2282:         # mixed
 2283:         df = DataFrame([Categorical(list("abc")), list("def")])
 2284:         expected = DataFrame([["a", "b", "c"], ["d", "e", "f"]])
 2285:         tm.assert_frame_equal(df, expected)
 2286: 
 2287:     def test_construct_from_listlikes_mismatched_lengths(self):
 2288:         df = DataFrame([Categorical(list("abc")), Categorical(list("abdefg"))])
 2289:         expected = DataFrame([list("abc"), list("abdefg")])
 2290:         tm.assert_frame_equal(df, expected)
 2291: 
 2292:     def test_constructor_categorical_series(self):
 2293:         items = [1, 2, 3, 1]
 2294:         exp = Series(items).astype("category")
 2295:         res = Series(items, dtype="category")
 2296:         tm.assert_series_equal(res, exp)
 2297: 
 2298:         items = ["a", "b", "c", "a"]
 2299:         exp = Series(items).astype("category")
 2300:         res = Series(items, dtype="category")
 2301:         tm.assert_series_equal(res, exp)
 2302: 
 2303:         # insert into frame with different index
 2304:         # GH 8076
 2305:         index = date_range("20000101", periods=3)
 2306:         expected = Series(
 2307:             Categorical(values=[np.nan, np.nan, np.nan], categories=["a", "b", "c"])
 2308:         )
 2309:         expected.index = index
 2310: 
 2311:         expected = DataFrame({"x": expected})
 2312:         df = DataFrame({"x": Series(["a", "b", "c"], dtype="category")}, index=index)
 2313:         tm.assert_frame_equal(df, expected)
 2314: 
 2315:     @pytest.mark.parametrize(
 2316:         "dtype",
 2317:         tm.ALL_NUMERIC_DTYPES
 2318:         + tm.DATETIME64_DTYPES
 2319:         + tm.TIMEDELTA64_DTYPES
 2320:         + tm.BOOL_DTYPES,
 2321:     )
 2322:     def test_check_dtype_empty_numeric_column(self, dtype):
 2323:         # GH24386: Ensure dtypes are set correctly for an empty DataFrame.
 2324:         # Empty DataFrame is generated via dictionary data with non-overlapping columns.
 2325:         data = DataFrame({"a": [1, 2]}, columns=["b"], dtype=dtype)
 2326: 
 2327:         assert data.b.dtype == dtype
 2328: 
 2329:     @pytest.mark.parametrize(
 2330:         "dtype", tm.STRING_DTYPES + tm.BYTES_DTYPES + tm.OBJECT_DTYPES
 2331:     )
 2332:     def test_check_dtype_empty_string_column(self, request, dtype, using_array_manager):
 2333:         # GH24386: Ensure dtypes are set correctly for an empty DataFrame.
 2334:         # Empty DataFrame is generated via dictionary data with non-overlapping columns.
 2335:         data = DataFrame({"a": [1, 2]}, columns=["b"], dtype=dtype)
 2336: 
 2337:         if using_array_manager and dtype in tm.BYTES_DTYPES:
 2338:             # TODO(ArrayManager) astype to bytes dtypes does not yet give object dtype
 2339:             td.mark_array_manager_not_yet_implemented(request)
 2340: 
 2341:         assert data.b.dtype.name == "object"
 2342: 
 2343:     def test_to_frame_with_falsey_names(self):
 2344:         # GH 16114
 2345:         result = Series(name=0, dtype=object).to_frame().dtypes
 2346:         expected = Series({0: object})
 2347:         tm.assert_series_equal(result, expected)
 2348: 
 2349:         result = DataFrame(Series(name=0, dtype=object)).dtypes
 2350:         tm.assert_series_equal(result, expected)
 2351: 
 2352:     @pytest.mark.arm_slow
 2353:     @pytest.mark.parametrize("dtype", [None, "uint8", "category"])
 2354:     def test_constructor_range_dtype(self, dtype):
 2355:         expected = DataFrame({"A": [0, 1, 2, 3, 4]}, dtype=dtype or "int64")
 2356: 
 2357:         # GH 26342
 2358:         result = DataFrame(range(5), columns=["A"], dtype=dtype)
 2359:         tm.assert_frame_equal(result, expected)
 2360: 
 2361:         # GH 16804
 2362:         result = DataFrame({"A": range(5)}, dtype=dtype)
 2363:         tm.assert_frame_equal(result, expected)
 2364: 
 2365:     def test_frame_from_list_subclass(self):
 2366:         # GH21226
 2367:         class List(list):
 2368:             pass
 2369: 
 2370:         expected = DataFrame([[1, 2, 3], [4, 5, 6]])
 2371:         result = DataFrame(List([List([1, 2, 3]), List([4, 5, 6])]))
 2372:         tm.assert_frame_equal(result, expected)
 2373: 
 2374:     @pytest.mark.parametrize(
 2375:         "extension_arr",
 2376:         [
 2377:             Categorical(list("aabbc")),
 2378:             SparseArray([1, np.nan, np.nan, np.nan]),
 2379:             IntervalArray([Interval(0, 1), Interval(1, 5)]),
 2380:             PeriodArray(pd.period_range(start="1/1/2017", end="1/1/2018", freq="M")),
 2381:         ],
 2382:     )
 2383:     def test_constructor_with_extension_array(self, extension_arr):
 2384:         # GH11363
 2385:         expected = DataFrame(Series(extension_arr))
 2386:         result = DataFrame(extension_arr)
 2387:         tm.assert_frame_equal(result, expected)
 2388: 
 2389:     def test_datetime_date_tuple_columns_from_dict(self):
 2390:         # GH 10863
 2391:         v = date.today()
 2392:         tup = v, v
 2393:         result = DataFrame({tup: Series(range(3), index=range(3))}, columns=[tup])
 2394:         expected = DataFrame([0, 1, 2], columns=Index(Series([tup])))
 2395:         tm.assert_frame_equal(result, expected)
 2396: 
 2397:     def test_construct_with_two_categoricalindex_series(self):
 2398:         # GH 14600
 2399:         s1 = Series([39, 6, 4], index=CategoricalIndex(["female", "male", "unknown"]))
 2400:         s2 = Series(
 2401:             [2, 152, 2, 242, 150],
 2402:             index=CategoricalIndex(["f", "female", "m", "male", "unknown"]),
 2403:         )
 2404:         result = DataFrame([s1, s2])
 2405:         expected = DataFrame(
 2406:             np.array([[39, 6, 4, np.nan, np.nan], [152.0, 242.0, 150.0, 2.0, 2.0]]),
 2407:             columns=["female", "male", "unknown", "f", "m"],
 2408:         )
 2409:         tm.assert_frame_equal(result, expected)
 2410: 
 2411:     def test_constructor_series_nonexact_categoricalindex(self):
 2412:         # GH 42424
 2413:         ser = Series(range(100))
 2414:         ser1 = cut(ser, 10).value_counts().head(5)
 2415:         ser2 = cut(ser, 10).value_counts().tail(5)
 2416:         result = DataFrame({"1": ser1, "2": ser2})
 2417:         index = CategoricalIndex(
 2418:             [
 2419:                 Interval(-0.099, 9.9, closed="right"),
 2420:                 Interval(9.9, 19.8, closed="right"),
 2421:                 Interval(19.8, 29.7, closed="right"),
 2422:                 Interval(29.7, 39.6, closed="right"),
 2423:                 Interval(39.6, 49.5, closed="right"),
 2424:                 Interval(49.5, 59.4, closed="right"),
 2425:                 Interval(59.4, 69.3, closed="right"),
 2426:                 Interval(69.3, 79.2, closed="right"),
 2427:                 Interval(79.2, 89.1, closed="right"),
 2428:                 Interval(89.1, 99, closed="right"),
 2429:             ],
 2430:             ordered=True,
 2431:         )
 2432:         expected = DataFrame(
 2433:             {"1": [10] * 5 + [np.nan] * 5, "2": [np.nan] * 5 + [10] * 5}, index=index
 2434:         )
 2435:         tm.assert_frame_equal(expected, result)
 2436: 
 2437:     def test_from_M8_structured(self):
 2438:         dates = [(datetime(2012, 9, 9, 0, 0), datetime(2012, 9, 8, 15, 10))]
 2439:         arr = np.array(dates, dtype=[("Date", "M8[us]"), ("Forecasting", "M8[us]")])
 2440:         df = DataFrame(arr)
 2441: 
 2442:         assert df["Date"][0] == dates[0][0]
 2443:         assert df["Forecasting"][0] == dates[0][1]
 2444: 
 2445:         s = Series(arr["Date"])
 2446:         assert isinstance(s[0], Timestamp)
 2447:         assert s[0] == dates[0][0]
 2448: 
 2449:     def test_from_datetime_subclass(self):
 2450:         # GH21142 Verify whether Datetime subclasses are also of dtype datetime
 2451:         class DatetimeSubclass(datetime):
 2452:             pass
 2453: 
 2454:         data = DataFrame({"datetime": [DatetimeSubclass(2020, 1, 1, 1, 1)]})
 2455:         assert data.datetime.dtype == "datetime64[ns]"
 2456: 
 2457:     def test_with_mismatched_index_length_raises(self):
 2458:         # GH#33437
 2459:         dti = date_range("2016-01-01", periods=3, tz="US/Pacific")
 2460:         msg = "Shape of passed values|Passed arrays should have the same length"
 2461:         with pytest.raises(ValueError, match=msg):
 2462:             DataFrame(dti, index=range(4))
 2463: 
 2464:     def test_frame_ctor_datetime64_column(self):
 2465:         rng = date_range("1/1/2000 00:00:00", "1/1/2000 1:59:50", freq="10s")
 2466:         dates = np.asarray(rng)
 2467: 
 2468:         df = DataFrame(
 2469:             {"A": np.random.default_rng(2).standard_normal(len(rng)), "B": dates}
 2470:         )
 2471:         assert np.issubdtype(df["B"].dtype, np.dtype("M8[ns]"))
 2472: 
 2473:     def test_dataframe_constructor_infer_multiindex(self):
 2474:         index_lists = [["a", "a", "b", "b"], ["x", "y", "x", "y"]]
 2475: 
 2476:         multi = DataFrame(
 2477:             np.random.default_rng(2).standard_normal((4, 4)),
 2478:             index=[np.array(x) for x in index_lists],
 2479:         )
 2480:         assert isinstance(multi.index, MultiIndex)
 2481:         assert not isinstance(multi.columns, MultiIndex)
 2482: 
 2483:         multi = DataFrame(
 2484:             np.random.default_rng(2).standard_normal((4, 4)), columns=index_lists
 2485:         )
 2486:         assert isinstance(multi.columns, MultiIndex)
 2487: 
 2488:     @pytest.mark.parametrize(
 2489:         "input_vals",
 2490:         [
 2491:             ([1, 2]),
 2492:             (["1", "2"]),
 2493:             (list(date_range("1/1/2011", periods=2, freq="h"))),
 2494:             (list(date_range("1/1/2011", periods=2, freq="h", tz="US/Eastern"))),
 2495:             ([Interval(left=0, right=5)]),
 2496:         ],
 2497:     )
 2498:     def test_constructor_list_str(self, input_vals, string_dtype):
 2499:         # GH#16605
 2500:         # Ensure that data elements are converted to strings when
 2501:         # dtype is str, 'str', or 'U'
 2502: 
 2503:         result = DataFrame({"A": input_vals}, dtype=string_dtype)
 2504:         expected = DataFrame({"A": input_vals}).astype({"A": string_dtype})
 2505:         tm.assert_frame_equal(result, expected)
 2506: 
 2507:     def test_constructor_list_str_na(self, string_dtype):
 2508:         result = DataFrame({"A": [1.0, 2.0, None]}, dtype=string_dtype)
 2509:         expected = DataFrame({"A": ["1.0", "2.0", None]}, dtype=object)
 2510:         tm.assert_frame_equal(result, expected)
 2511: 
 2512:     @pytest.mark.parametrize("copy", [False, True])
 2513:     def test_dict_nocopy(
 2514:         self,
 2515:         request,
 2516:         copy,
 2517:         any_numeric_ea_dtype,
 2518:         any_numpy_dtype,
 2519:         using_array_manager,
 2520:         using_copy_on_write,
 2521:     ):
 2522:         if (
 2523:             using_array_manager
 2524:             and not copy
 2525:             and any_numpy_dtype not in tm.STRING_DTYPES + tm.BYTES_DTYPES
 2526:         ):
 2527:             # TODO(ArrayManager) properly honor copy keyword for dict input
 2528:             td.mark_array_manager_not_yet_implemented(request)
 2529: 
 2530:         a = np.array([1, 2], dtype=any_numpy_dtype)
 2531:         b = np.array([3, 4], dtype=any_numpy_dtype)
 2532:         if b.dtype.kind in ["S", "U"]:
 2533:             # These get cast, making the checks below more cumbersome
 2534:             pytest.skip(f"{b.dtype} get cast, making the checks below more cumbersome")
 2535: 
 2536:         c = pd.array([1, 2], dtype=any_numeric_ea_dtype)
 2537:         c_orig = c.copy()
 2538:         df = DataFrame({"a": a, "b": b, "c": c}, copy=copy)
 2539: 
 2540:         def get_base(obj):
 2541:             if isinstance(obj, np.ndarray):
 2542:                 return obj.base
 2543:             elif isinstance(obj.dtype, np.dtype):
 2544:                 # i.e. DatetimeArray, TimedeltaArray
 2545:                 return obj._ndarray.base
 2546:             else:
 2547:                 raise TypeError
 2548: 
 2549:         def check_views(c_only: bool = False):
 2550:             # written to work for either BlockManager or ArrayManager
 2551: 
 2552:             # Check that the underlying data behind df["c"] is still `c`
 2553:             #  after setting with iloc.  Since we don't know which entry in
 2554:             #  df._mgr.arrays corresponds to df["c"], we just check that exactly
 2555:             #  one of these arrays is `c`.  GH#38939
 2556:             assert sum(x is c for x in df._mgr.arrays) == 1
 2557:             if c_only:
 2558:                 # If we ever stop consolidating in setitem_with_indexer,
 2559:                 #  this will become unnecessary.
 2560:                 return
 2561: 
 2562:             assert (
 2563:                 sum(
 2564:                     get_base(x) is a
 2565:                     for x in df._mgr.arrays
 2566:                     if isinstance(x.dtype, np.dtype)
 2567:                 )
 2568:                 == 1
 2569:             )
 2570:             assert (
 2571:                 sum(
 2572:                     get_base(x) is b
 2573:                     for x in df._mgr.arrays
 2574:                     if isinstance(x.dtype, np.dtype)
 2575:                 )
 2576:                 == 1
 2577:             )
 2578: 
 2579:         if not copy:
 2580:             # constructor preserves views
 2581:             check_views()
 2582: 
 2583:         # TODO: most of the rest of this test belongs in indexing tests
 2584:         if lib.is_np_dtype(df.dtypes.iloc[0], "fciuO"):
 2585:             warn = None
 2586:         else:
 2587:             warn = FutureWarning
 2588:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
 2589:             df.iloc[0, 0] = 0
 2590:             df.iloc[0, 1] = 0
 2591:         if not copy:
 2592:             check_views(True)
 2593: 
 2594:         # FIXME(GH#35417): until GH#35417, iloc.setitem into EA values does not preserve
 2595:         #  view, so we have to check in the other direction
 2596:         df.iloc[:, 2] = pd.array([45, 46], dtype=c.dtype)
 2597:         assert df.dtypes.iloc[2] == c.dtype
 2598:         if not copy and not using_copy_on_write:
 2599:             check_views(True)
 2600: 
 2601:         if copy:
 2602:             if a.dtype.kind == "M":
 2603:                 assert a[0] == a.dtype.type(1, "ns")
 2604:                 assert b[0] == b.dtype.type(3, "ns")
 2605:             else:
 2606:                 assert a[0] == a.dtype.type(1)
 2607:                 assert b[0] == b.dtype.type(3)
 2608:             # FIXME(GH#35417): enable after GH#35417
 2609:             assert c[0] == c_orig[0]  # i.e. df.iloc[0, 2]=45 did *not* update c
 2610:         elif not using_copy_on_write:
 2611:             # TODO: we can call check_views if we stop consolidating
 2612:             #  in setitem_with_indexer
 2613:             assert c[0] == 45  # i.e. df.iloc[0, 2]=45 *did* update c
 2614:             # TODO: we can check b[0] == 0 if we stop consolidating in
 2615:             #  setitem_with_indexer (except for datetimelike?)
 2616: 
 2617:     def test_construct_from_dict_ea_series(self):
 2618:         # GH#53744 - default of copy=True should also apply for Series with
 2619:         # extension dtype
 2620:         ser = Series([1, 2, 3], dtype="Int64")
 2621:         df = DataFrame({"a": ser})
 2622:         assert not np.shares_memory(ser.values._data, df["a"].values._data)
 2623: 
 2624:     def test_from_series_with_name_with_columns(self):
 2625:         # GH 7893
 2626:         result = DataFrame(Series(1, name="foo"), columns=["bar"])
 2627:         expected = DataFrame(columns=["bar"])
 2628:         tm.assert_frame_equal(result, expected)
 2629: 
 2630:     def test_nested_list_columns(self):
 2631:         # GH 14467
 2632:         result = DataFrame(
 2633:             [[1, 2, 3], [4, 5, 6]], columns=[["A", "A", "A"], ["a", "b", "c"]]
 2634:         )
 2635:         expected = DataFrame(
 2636:             [[1, 2, 3], [4, 5, 6]],
 2637:             columns=MultiIndex.from_tuples([("A", "a"), ("A", "b"), ("A", "c")]),
 2638:         )
 2639:         tm.assert_frame_equal(result, expected)
 2640: 
 2641:     def test_from_2d_object_array_of_periods_or_intervals(self):
 2642:         # Period analogue to GH#26825
 2643:         pi = pd.period_range("2016-04-05", periods=3)
 2644:         data = pi._data.astype(object).reshape(1, -1)
 2645:         df = DataFrame(data)
 2646:         assert df.shape == (1, 3)
 2647:         assert (df.dtypes == pi.dtype).all()
 2648:         assert (df == pi).all().all()
 2649: 
 2650:         ii = pd.IntervalIndex.from_breaks([3, 4, 5, 6])
 2651:         data2 = ii._data.astype(object).reshape(1, -1)
 2652:         df2 = DataFrame(data2)
 2653:         assert df2.shape == (1, 3)
 2654:         assert (df2.dtypes == ii.dtype).all()
 2655:         assert (df2 == ii).all().all()
 2656: 
 2657:         # mixed
 2658:         data3 = np.r_[data, data2, data, data2].T
 2659:         df3 = DataFrame(data3)
 2660:         expected = DataFrame({0: pi, 1: ii, 2: pi, 3: ii})
 2661:         tm.assert_frame_equal(df3, expected)
 2662: 
 2663:     @pytest.mark.parametrize(
 2664:         "col_a, col_b",
 2665:         [
 2666:             ([[1], [2]], np.array([[1], [2]])),
 2667:             (np.array([[1], [2]]), [[1], [2]]),
 2668:             (np.array([[1], [2]]), np.array([[1], [2]])),
 2669:         ],
 2670:     )
 2671:     def test_error_from_2darray(self, col_a, col_b):
 2672:         msg = "Per-column arrays must each be 1-dimensional"
 2673:         with pytest.raises(ValueError, match=msg):
 2674:             DataFrame({"a": col_a, "b": col_b})
 2675: 
 2676:     def test_from_dict_with_missing_copy_false(self):
 2677:         # GH#45369 filled columns should not be views of one another
 2678:         df = DataFrame(index=[1, 2, 3], columns=["a", "b", "c"], copy=False)
 2679:         assert not np.shares_memory(df["a"]._values, df["b"]._values)
 2680: 
 2681:         df.iloc[0, 0] = 0
 2682:         expected = DataFrame(
 2683:             {
 2684:                 "a": [0, np.nan, np.nan],
 2685:                 "b": [np.nan, np.nan, np.nan],
 2686:                 "c": [np.nan, np.nan, np.nan],
 2687:             },
 2688:             index=[1, 2, 3],
 2689:             dtype=object,
 2690:         )
 2691:         tm.assert_frame_equal(df, expected)
 2692: 
 2693:     def test_construction_empty_array_multi_column_raises(self):
 2694:         # GH#46822
 2695:         msg = r"Shape of passed values is \(0, 1\), indices imply \(0, 2\)"
 2696:         with pytest.raises(ValueError, match=msg):
 2697:             DataFrame(data=np.array([]), columns=["a", "b"])
 2698: 
 2699:     def test_construct_with_strings_and_none(self):
 2700:         # GH#32218
 2701:         df = DataFrame(["1", "2", None], columns=["a"], dtype="str")
 2702:         expected = DataFrame({"a": ["1", "2", None]}, dtype="str")
 2703:         tm.assert_frame_equal(df, expected)
 2704: 
 2705:     def test_frame_string_inference(self):
 2706:         # GH#54430
 2707:         pytest.importorskip("pyarrow")
 2708:         dtype = "string[pyarrow_numpy]"
 2709:         expected = DataFrame(
 2710:             {"a": ["a", "b"]}, dtype=dtype, columns=Index(["a"], dtype=dtype)
 2711:         )
 2712:         with pd.option_context("future.infer_string", True):
 2713:             df = DataFrame({"a": ["a", "b"]})
 2714:         tm.assert_frame_equal(df, expected)
 2715: 
 2716:         expected = DataFrame(
 2717:             {"a": ["a", "b"]},
 2718:             dtype=dtype,
 2719:             columns=Index(["a"], dtype=dtype),
 2720:             index=Index(["x", "y"], dtype=dtype),
 2721:         )
 2722:         with pd.option_context("future.infer_string", True):
 2723:             df = DataFrame({"a": ["a", "b"]}, index=["x", "y"])
 2724:         tm.assert_frame_equal(df, expected)
 2725: 
 2726:         expected = DataFrame(
 2727:             {"a": ["a", 1]}, dtype="object", columns=Index(["a"], dtype=dtype)
 2728:         )
 2729:         with pd.option_context("future.infer_string", True):
 2730:             df = DataFrame({"a": ["a", 1]})
 2731:         tm.assert_frame_equal(df, expected)
 2732: 
 2733:         expected = DataFrame(
 2734:             {"a": ["a", "b"]}, dtype="object", columns=Index(["a"], dtype=dtype)
 2735:         )
 2736:         with pd.option_context("future.infer_string", True):
 2737:             df = DataFrame({"a": ["a", "b"]}, dtype="object")
 2738:         tm.assert_frame_equal(df, expected)
 2739: 
 2740:     def test_frame_string_inference_array_string_dtype(self):
 2741:         # GH#54496
 2742:         pytest.importorskip("pyarrow")
 2743:         dtype = "string[pyarrow_numpy]"
 2744:         expected = DataFrame(
 2745:             {"a": ["a", "b"]}, dtype=dtype, columns=Index(["a"], dtype=dtype)
 2746:         )
 2747:         with pd.option_context("future.infer_string", True):
 2748:             df = DataFrame({"a": np.array(["a", "b"])})
 2749:         tm.assert_frame_equal(df, expected)
 2750: 
 2751:         expected = DataFrame({0: ["a", "b"], 1: ["c", "d"]}, dtype=dtype)
 2752:         with pd.option_context("future.infer_string", True):
 2753:             df = DataFrame(np.array([["a", "c"], ["b", "d"]]))
 2754:         tm.assert_frame_equal(df, expected)
 2755: 
 2756:         expected = DataFrame(
 2757:             {"a": ["a", "b"], "b": ["c", "d"]},
 2758:             dtype=dtype,
 2759:             columns=Index(["a", "b"], dtype=dtype),
 2760:         )
 2761:         with pd.option_context("future.infer_string", True):
 2762:             df = DataFrame(np.array([["a", "c"], ["b", "d"]]), columns=["a", "b"])
 2763:         tm.assert_frame_equal(df, expected)
 2764: 
 2765:     def test_frame_string_inference_block_dim(self):
 2766:         # GH#55363
 2767:         pytest.importorskip("pyarrow")
 2768:         with pd.option_context("future.infer_string", True):
 2769:             df = DataFrame(np.array([["hello", "goodbye"], ["hello", "Hello"]]))
 2770:         assert df._mgr.blocks[0].ndim == 2
 2771: 
 2772:     def test_inference_on_pandas_objects(self):
 2773:         # GH#56012
 2774:         idx = Index([Timestamp("2019-12-31")], dtype=object)
 2775:         with tm.assert_produces_warning(FutureWarning, match="Dtype inference"):
 2776:             result = DataFrame(idx, columns=["a"])
 2777:         assert result.dtypes.iloc[0] != np.object_
 2778:         result = DataFrame({"a": idx})
 2779:         assert result.dtypes.iloc[0] == np.object_
 2780: 
 2781:         ser = Series([Timestamp("2019-12-31")], dtype=object)
 2782: 
 2783:         with tm.assert_produces_warning(FutureWarning, match="Dtype inference"):
 2784:             result = DataFrame(ser, columns=["a"])
 2785:         assert result.dtypes.iloc[0] != np.object_
 2786:         result = DataFrame({"a": ser})
 2787:         assert result.dtypes.iloc[0] == np.object_
 2788: 
 2789: 
 2790: class TestDataFrameConstructorIndexInference:
 2791:     def test_frame_from_dict_of_series_overlapping_monthly_period_indexes(self):
 2792:         rng1 = pd.period_range("1/1/1999", "1/1/2012", freq="M")
 2793:         s1 = Series(np.random.default_rng(2).standard_normal(len(rng1)), rng1)
 2794: 
 2795:         rng2 = pd.period_range("1/1/1980", "12/1/2001", freq="M")
 2796:         s2 = Series(np.random.default_rng(2).standard_normal(len(rng2)), rng2)
 2797:         df = DataFrame({"s1": s1, "s2": s2})
 2798: 
 2799:         exp = pd.period_range("1/1/1980", "1/1/2012", freq="M")
 2800:         tm.assert_index_equal(df.index, exp)
 2801: 
 2802:     def test_frame_from_dict_with_mixed_tzaware_indexes(self):
 2803:         # GH#44091
 2804:         dti = date_range("2016-01-01", periods=3)
 2805: 
 2806:         ser1 = Series(range(3), index=dti)
 2807:         ser2 = Series(range(3), index=dti.tz_localize("UTC"))
 2808:         ser3 = Series(range(3), index=dti.tz_localize("US/Central"))
 2809:         ser4 = Series(range(3))
 2810: 
 2811:         # no tz-naive, but we do have mixed tzs and a non-DTI
 2812:         df1 = DataFrame({"A": ser2, "B": ser3, "C": ser4})
 2813:         exp_index = Index(
 2814:             list(ser2.index) + list(ser3.index) + list(ser4.index), dtype=object
 2815:         )
 2816:         tm.assert_index_equal(df1.index, exp_index)
 2817: 
 2818:         df2 = DataFrame({"A": ser2, "C": ser4, "B": ser3})
 2819:         exp_index3 = Index(
 2820:             list(ser2.index) + list(ser4.index) + list(ser3.index), dtype=object
 2821:         )
 2822:         tm.assert_index_equal(df2.index, exp_index3)
 2823: 
 2824:         df3 = DataFrame({"B": ser3, "A": ser2, "C": ser4})
 2825:         exp_index3 = Index(
 2826:             list(ser3.index) + list(ser2.index) + list(ser4.index), dtype=object
 2827:         )
 2828:         tm.assert_index_equal(df3.index, exp_index3)
 2829: 
 2830:         df4 = DataFrame({"C": ser4, "B": ser3, "A": ser2})
 2831:         exp_index4 = Index(
 2832:             list(ser4.index) + list(ser3.index) + list(ser2.index), dtype=object
 2833:         )
 2834:         tm.assert_index_equal(df4.index, exp_index4)
 2835: 
 2836:         # TODO: not clear if these raising is desired (no extant tests),
 2837:         #  but this is de facto behavior 2021-12-22
 2838:         msg = "Cannot join tz-naive with tz-aware DatetimeIndex"
 2839:         with pytest.raises(TypeError, match=msg):
 2840:             DataFrame({"A": ser2, "B": ser3, "C": ser4, "D": ser1})
 2841:         with pytest.raises(TypeError, match=msg):
 2842:             DataFrame({"A": ser2, "B": ser3, "D": ser1})
 2843:         with pytest.raises(TypeError, match=msg):
 2844:             DataFrame({"D": ser1, "A": ser2, "B": ser3})
 2845: 
 2846:     @pytest.mark.parametrize(
 2847:         "key_val, col_vals, col_type",
 2848:         [
 2849:             ["3", ["3", "4"], "utf8"],
 2850:             [3, [3, 4], "int8"],
 2851:         ],
 2852:     )
 2853:     def test_dict_data_arrow_column_expansion(self, key_val, col_vals, col_type):
 2854:         # GH 53617
 2855:         pa = pytest.importorskip("pyarrow")
 2856:         cols = pd.arrays.ArrowExtensionArray(
 2857:             pa.array(col_vals, type=pa.dictionary(pa.int8(), getattr(pa, col_type)()))
 2858:         )
 2859:         result = DataFrame({key_val: [1, 2]}, columns=cols)
 2860:         expected = DataFrame([[1, np.nan], [2, np.nan]], columns=cols)
 2861:         expected.isetitem(1, expected.iloc[:, 1].astype(object))
 2862:         tm.assert_frame_equal(result, expected)
 2863: 
 2864: 
 2865: class TestDataFrameConstructorWithDtypeCoercion:
 2866:     def test_floating_values_integer_dtype(self):
 2867:         # GH#40110 make DataFrame behavior with arraylike floating data and
 2868:         #  inty dtype match Series behavior
 2869: 
 2870:         arr = np.random.default_rng(2).standard_normal((10, 5))
 2871: 
 2872:         # GH#49599 in 2.0 we raise instead of either
 2873:         #  a) silently ignoring dtype and returningfloat (the old Series behavior) or
 2874:         #  b) rounding (the old DataFrame behavior)
 2875:         msg = "Trying to coerce float values to integers"
 2876:         with pytest.raises(ValueError, match=msg):
 2877:             DataFrame(arr, dtype="i8")
 2878: 
 2879:         df = DataFrame(arr.round(), dtype="i8")
 2880:         assert (df.dtypes == "i8").all()
 2881: 
 2882:         # with NaNs, we go through a different path with a different warning
 2883:         arr[0, 0] = np.nan
 2884:         msg = r"Cannot convert non-finite values \(NA or inf\) to integer"
 2885:         with pytest.raises(IntCastingNaNError, match=msg):
 2886:             DataFrame(arr, dtype="i8")
 2887:         with pytest.raises(IntCastingNaNError, match=msg):
 2888:             Series(arr[0], dtype="i8")
 2889:         # The future (raising) behavior matches what we would get via astype:
 2890:         msg = r"Cannot convert non-finite values \(NA or inf\) to integer"
 2891:         with pytest.raises(IntCastingNaNError, match=msg):
 2892:             DataFrame(arr).astype("i8")
 2893:         with pytest.raises(IntCastingNaNError, match=msg):
 2894:             Series(arr[0]).astype("i8")
 2895: 
 2896: 
 2897: class TestDataFrameConstructorWithDatetimeTZ:
 2898:     @pytest.mark.parametrize("tz", ["US/Eastern", "dateutil/US/Eastern"])
 2899:     def test_construction_preserves_tzaware_dtypes(self, tz):
 2900:         # after GH#7822
 2901:         # these retain the timezones on dict construction
 2902:         dr = date_range("2011/1/1", "2012/1/1", freq="W-FRI")
 2903:         dr_tz = dr.tz_localize(tz)
 2904:         df = DataFrame({"A": "foo", "B": dr_tz}, index=dr)
 2905:         tz_expected = DatetimeTZDtype("ns", dr_tz.tzinfo)
 2906:         assert df["B"].dtype == tz_expected
 2907: 
 2908:         # GH#2810 (with timezones)
 2909:         datetimes_naive = [ts.to_pydatetime() for ts in dr]
 2910:         datetimes_with_tz = [ts.to_pydatetime() for ts in dr_tz]
 2911:         df = DataFrame({"dr": dr})
 2912:         df["dr_tz"] = dr_tz
 2913:         df["datetimes_naive"] = datetimes_naive
 2914:         df["datetimes_with_tz"] = datetimes_with_tz
 2915:         result = df.dtypes
 2916:         expected = Series(
 2917:             [
 2918:                 np.dtype("datetime64[ns]"),
 2919:                 DatetimeTZDtype(tz=tz),
 2920:                 np.dtype("datetime64[ns]"),
 2921:                 DatetimeTZDtype(tz=tz),
 2922:             ],
 2923:             index=["dr", "dr_tz", "datetimes_naive", "datetimes_with_tz"],
 2924:         )
 2925:         tm.assert_series_equal(result, expected)
 2926: 
 2927:     @pytest.mark.parametrize("pydt", [True, False])
 2928:     def test_constructor_data_aware_dtype_naive(self, tz_aware_fixture, pydt):
 2929:         # GH#25843, GH#41555, GH#33401
 2930:         tz = tz_aware_fixture
 2931:         ts = Timestamp("2019", tz=tz)
 2932:         if pydt:
 2933:             ts = ts.to_pydatetime()
 2934: 
 2935:         msg = (
 2936:             "Cannot convert timezone-aware data to timezone-naive dtype. "
 2937:             r"Use pd.Series\(values\).dt.tz_localize\(None\) instead."
 2938:         )
 2939:         with pytest.raises(ValueError, match=msg):
 2940:             DataFrame({0: [ts]}, dtype="datetime64[ns]")
 2941: 
 2942:         msg2 = "Cannot unbox tzaware Timestamp to tznaive dtype"
 2943:         with pytest.raises(TypeError, match=msg2):
 2944:             DataFrame({0: ts}, index=[0], dtype="datetime64[ns]")
 2945: 
 2946:         with pytest.raises(ValueError, match=msg):
 2947:             DataFrame([ts], dtype="datetime64[ns]")
 2948: 
 2949:         with pytest.raises(ValueError, match=msg):
 2950:             DataFrame(np.array([ts], dtype=object), dtype="datetime64[ns]")
 2951: 
 2952:         with pytest.raises(TypeError, match=msg2):
 2953:             DataFrame(ts, index=[0], columns=[0], dtype="datetime64[ns]")
 2954: 
 2955:         with pytest.raises(ValueError, match=msg):
 2956:             DataFrame([Series([ts])], dtype="datetime64[ns]")
 2957: 
 2958:         with pytest.raises(ValueError, match=msg):
 2959:             DataFrame([[ts]], columns=[0], dtype="datetime64[ns]")
 2960: 
 2961:     def test_from_dict(self):
 2962:         # 8260
 2963:         # support datetime64 with tz
 2964: 
 2965:         idx = Index(date_range("20130101", periods=3, tz="US/Eastern"), name="foo")
 2966:         dr = date_range("20130110", periods=3)
 2967: 
 2968:         # construction
 2969:         df = DataFrame({"A": idx, "B": dr})
 2970:         assert df["A"].dtype, "M8[ns, US/Eastern"
 2971:         assert df["A"].name == "A"
 2972:         tm.assert_series_equal(df["A"], Series(idx, name="A"))
 2973:         tm.assert_series_equal(df["B"], Series(dr, name="B"))
 2974: 
 2975:     def test_from_index(self):
 2976:         # from index
 2977:         idx2 = date_range("20130101", periods=3, tz="US/Eastern", name="foo")
 2978:         df2 = DataFrame(idx2)
 2979:         tm.assert_series_equal(df2["foo"], Series(idx2, name="foo"))
 2980:         df2 = DataFrame(Series(idx2))
 2981:         tm.assert_series_equal(df2["foo"], Series(idx2, name="foo"))
 2982: 
 2983:         idx2 = date_range("20130101", periods=3, tz="US/Eastern")
 2984:         df2 = DataFrame(idx2)
 2985:         tm.assert_series_equal(df2[0], Series(idx2, name=0))
 2986:         df2 = DataFrame(Series(idx2))
 2987:         tm.assert_series_equal(df2[0], Series(idx2, name=0))
 2988: 
 2989:     def test_frame_dict_constructor_datetime64_1680(self):
 2990:         dr = date_range("1/1/2012", periods=10)
 2991:         s = Series(dr, index=dr)
 2992: 
 2993:         # it works!
 2994:         DataFrame({"a": "foo", "b": s}, index=dr)
 2995:         DataFrame({"a": "foo", "b": s.values}, index=dr)
 2996: 
 2997:     def test_frame_datetime64_mixed_index_ctor_1681(self):
 2998:         dr = date_range("2011/1/1", "2012/1/1", freq="W-FRI")
 2999:         ts = Series(dr)
 3000: 
 3001:         # it works!
 3002:         d = DataFrame({"A": "foo", "B": ts}, index=dr)
 3003:         assert d["B"].isna().all()
 3004: 
 3005:     def test_frame_timeseries_column(self):
 3006:         # GH19157
 3007:         dr = date_range(
 3008:             start="20130101T10:00:00", periods=3, freq="min", tz="US/Eastern"
 3009:         )
 3010:         result = DataFrame(dr, columns=["timestamps"])
 3011:         expected = DataFrame(
 3012:             {
 3013:                 "timestamps": [
 3014:                     Timestamp("20130101T10:00:00", tz="US/Eastern"),
 3015:                     Timestamp("20130101T10:01:00", tz="US/Eastern"),
 3016:                     Timestamp("20130101T10:02:00", tz="US/Eastern"),
 3017:                 ]
 3018:             }
 3019:         )
 3020:         tm.assert_frame_equal(result, expected)
 3021: 
 3022:     def test_nested_dict_construction(self):
 3023:         # GH22227
 3024:         columns = ["Nevada", "Ohio"]
 3025:         pop = {
 3026:             "Nevada": {2001: 2.4, 2002: 2.9},
 3027:             "Ohio": {2000: 1.5, 2001: 1.7, 2002: 3.6},
 3028:         }
 3029:         result = DataFrame(pop, index=[2001, 2002, 2003], columns=columns)
 3030:         expected = DataFrame(
 3031:             [(2.4, 1.7), (2.9, 3.6), (np.nan, np.nan)],
 3032:             columns=columns,
 3033:             index=Index([2001, 2002, 2003]),
 3034:         )
 3035:         tm.assert_frame_equal(result, expected)
 3036: 
 3037:     def test_from_tzaware_object_array(self):
 3038:         # GH#26825 2D object array of tzaware timestamps should not raise
 3039:         dti = date_range("2016-04-05 04:30", periods=3, tz="UTC")
 3040:         data = dti._data.astype(object).reshape(1, -1)
 3041:         df = DataFrame(data)
 3042:         assert df.shape == (1, 3)
 3043:         assert (df.dtypes == dti.dtype).all()
 3044:         assert (df == dti).all().all()
 3045: 
 3046:     def test_from_tzaware_mixed_object_array(self):
 3047:         # GH#26825
 3048:         arr = np.array(
 3049:             [
 3050:                 [
 3051:                     Timestamp("2013-01-01 00:00:00"),
 3052:                     Timestamp("2013-01-02 00:00:00"),
 3053:                     Timestamp("2013-01-03 00:00:00"),
 3054:                 ],
 3055:                 [
 3056:                     Timestamp("2013-01-01 00:00:00-0500", tz="US/Eastern"),
 3057:                     pd.NaT,
 3058:                     Timestamp("2013-01-03 00:00:00-0500", tz="US/Eastern"),
 3059:                 ],
 3060:                 [
 3061:                     Timestamp("2013-01-01 00:00:00+0100", tz="CET"),
 3062:                     pd.NaT,
 3063:                     Timestamp("2013-01-03 00:00:00+0100", tz="CET"),
 3064:                 ],
 3065:             ],
 3066:             dtype=object,
 3067:         ).T
 3068:         res = DataFrame(arr, columns=["A", "B", "C"])
 3069: 
 3070:         expected_dtypes = [
 3071:             "datetime64[ns]",
 3072:             "datetime64[ns, US/Eastern]",
 3073:             "datetime64[ns, CET]",
 3074:         ]
 3075:         assert (res.dtypes == expected_dtypes).all()
 3076: 
 3077:     def test_from_2d_ndarray_with_dtype(self):
 3078:         # GH#12513
 3079:         array_dim2 = np.arange(10).reshape((5, 2))
 3080:         df = DataFrame(array_dim2, dtype="datetime64[ns, UTC]")
 3081: 
 3082:         expected = DataFrame(array_dim2).astype("datetime64[ns, UTC]")
 3083:         tm.assert_frame_equal(df, expected)
 3084: 
 3085:     @pytest.mark.parametrize("typ", [set, frozenset])
 3086:     def test_construction_from_set_raises(self, typ):
 3087:         # https://github.com/pandas-dev/pandas/issues/32582
 3088:         values = typ({1, 2, 3})
 3089:         msg = f"'{typ.__name__}' type is unordered"
 3090:         with pytest.raises(TypeError, match=msg):
 3091:             DataFrame({"a": values})
 3092: 
 3093:         with pytest.raises(TypeError, match=msg):
 3094:             Series(values)
 3095: 
 3096:     def test_construction_from_ndarray_datetimelike(self):
 3097:         # ensure the underlying arrays are properly wrapped as EA when
 3098:         # constructed from 2D ndarray
 3099:         arr = np.arange(0, 12, dtype="datetime64[ns]").reshape(4, 3)
 3100:         df = DataFrame(arr)
 3101:         assert all(isinstance(arr, DatetimeArray) for arr in df._mgr.arrays)
 3102: 
 3103:     def test_construction_from_ndarray_with_eadtype_mismatched_columns(self):
 3104:         arr = np.random.default_rng(2).standard_normal((10, 2))
 3105:         dtype = pd.array([2.0]).dtype
 3106:         msg = r"len\(arrays\) must match len\(columns\)"
 3107:         with pytest.raises(ValueError, match=msg):
 3108:             DataFrame(arr, columns=["foo"], dtype=dtype)
 3109: 
 3110:         arr2 = pd.array([2.0, 3.0, 4.0])
 3111:         with pytest.raises(ValueError, match=msg):
 3112:             DataFrame(arr2, columns=["foo", "bar"])
 3113: 
 3114:     def test_columns_indexes_raise_on_sets(self):
 3115:         # GH 47215
 3116:         data = [[1, 2, 3], [4, 5, 6]]
 3117:         with pytest.raises(ValueError, match="index cannot be a set"):
 3118:             DataFrame(data, index={"a", "b"})
 3119:         with pytest.raises(ValueError, match="columns cannot be a set"):
 3120:             DataFrame(data, columns={"a", "b", "c"})
 3121: 
 3122:     # TODO: make this not cast to object in pandas 3.0
 3123:     @pytest.mark.skipif(
 3124:         not np_version_gt2, reason="StringDType only available in numpy 2 and above"
 3125:     )
 3126:     @pytest.mark.parametrize(
 3127:         "data",
 3128:         [
 3129:             {"a": ["a", "b", "c"], "b": [1.0, 2.0, 3.0], "c": ["d", "e", "f"]},
 3130:         ],
 3131:     )
 3132:     def test_np_string_array_object_cast(self, data):
 3133:         from numpy.dtypes import StringDType
 3134: 
 3135:         data["a"] = np.array(data["a"], dtype=StringDType())
 3136:         res = DataFrame(data)
 3137:         assert res["a"].dtype == np.object_
 3138:         assert (res["a"] == data["a"]).all()
 3139: 
 3140: 
 3141: def get1(obj):  # TODO: make a helper in tm?
 3142:     if isinstance(obj, Series):
 3143:         return obj.iloc[0]
 3144:     else:
 3145:         return obj.iloc[0, 0]
 3146: 
 3147: 
 3148: class TestFromScalar:
 3149:     @pytest.fixture(params=[list, dict, None])
 3150:     def box(self, request):
 3151:         return request.param
 3152: 
 3153:     @pytest.fixture
 3154:     def constructor(self, frame_or_series, box):
 3155:         extra = {"index": range(2)}
 3156:         if frame_or_series is DataFrame:
 3157:             extra["columns"] = ["A"]
 3158: 
 3159:         if box is None:
 3160:             return functools.partial(frame_or_series, **extra)
 3161: 
 3162:         elif box is dict:
 3163:             if frame_or_series is Series:
 3164:                 return lambda x, **kwargs: frame_or_series(
 3165:                     {0: x, 1: x}, **extra, **kwargs
 3166:                 )
 3167:             else:
 3168:                 return lambda x, **kwargs: frame_or_series({"A": x}, **extra, **kwargs)
 3169:         elif frame_or_series is Series:
 3170:             return lambda x, **kwargs: frame_or_series([x, x], **extra, **kwargs)
 3171:         else:
 3172:             return lambda x, **kwargs: frame_or_series({"A": [x, x]}, **extra, **kwargs)
 3173: 
 3174:     @pytest.mark.parametrize("dtype", ["M8[ns]", "m8[ns]"])
 3175:     def test_from_nat_scalar(self, dtype, constructor):
 3176:         obj = constructor(pd.NaT, dtype=dtype)
 3177:         assert np.all(obj.dtypes == dtype)
 3178:         assert np.all(obj.isna())
 3179: 
 3180:     def test_from_timedelta_scalar_preserves_nanos(self, constructor):
 3181:         td = Timedelta(1)
 3182: 
 3183:         obj = constructor(td, dtype="m8[ns]")
 3184:         assert get1(obj) == td
 3185: 
 3186:     def test_from_timestamp_scalar_preserves_nanos(self, constructor, fixed_now_ts):
 3187:         ts = fixed_now_ts + Timedelta(1)
 3188: 
 3189:         obj = constructor(ts, dtype="M8[ns]")
 3190:         assert get1(obj) == ts
 3191: 
 3192:     def test_from_timedelta64_scalar_object(self, constructor):
 3193:         td = Timedelta(1)
 3194:         td64 = td.to_timedelta64()
 3195: 
 3196:         obj = constructor(td64, dtype=object)
 3197:         assert isinstance(get1(obj), np.timedelta64)
 3198: 
 3199:     @pytest.mark.parametrize("cls", [np.datetime64, np.timedelta64])
 3200:     def test_from_scalar_datetimelike_mismatched(self, constructor, cls):
 3201:         scalar = cls("NaT", "ns")
 3202:         dtype = {np.datetime64: "m8[ns]", np.timedelta64: "M8[ns]"}[cls]
 3203: 
 3204:         if cls is np.datetime64:
 3205:             msg1 = "Invalid type for timedelta scalar: <class 'numpy.datetime64'>"
 3206:         else:
 3207:             msg1 = "<class 'numpy.timedelta64'> is not convertible to datetime"
 3208:         msg = "|".join(["Cannot cast", msg1])
 3209: 
 3210:         with pytest.raises(TypeError, match=msg):
 3211:             constructor(scalar, dtype=dtype)
 3212: 
 3213:         scalar = cls(4, "ns")
 3214:         with pytest.raises(TypeError, match=msg):
 3215:             constructor(scalar, dtype=dtype)
 3216: 
 3217:     @pytest.mark.parametrize("cls", [datetime, np.datetime64])
 3218:     def test_from_out_of_bounds_ns_datetime(
 3219:         self, constructor, cls, request, box, frame_or_series
 3220:     ):
 3221:         # scalar that won't fit in nanosecond dt64, but will fit in microsecond
 3222:         if box is list or (frame_or_series is Series and box is dict):
 3223:             mark = pytest.mark.xfail(
 3224:                 reason="Timestamp constructor has been updated to cast dt64 to "
 3225:                 "non-nano, but DatetimeArray._from_sequence has not",
 3226:                 strict=True,
 3227:             )
 3228:             request.applymarker(mark)
 3229: 
 3230:         scalar = datetime(9999, 1, 1)
 3231:         exp_dtype = "M8[us]"  # pydatetime objects default to this reso
 3232: 
 3233:         if cls is np.datetime64:
 3234:             scalar = np.datetime64(scalar, "D")
 3235:             exp_dtype = "M8[s]"  # closest reso to input
 3236:         result = constructor(scalar)
 3237: 
 3238:         item = get1(result)
 3239:         dtype = tm.get_dtype(result)
 3240: 
 3241:         assert type(item) is Timestamp
 3242:         assert item.asm8.dtype == exp_dtype
 3243:         assert dtype == exp_dtype
 3244: 
 3245:     @pytest.mark.skip_ubsan
 3246:     def test_out_of_s_bounds_datetime64(self, constructor):
 3247:         scalar = np.datetime64(np.iinfo(np.int64).max, "D")
 3248:         result = constructor(scalar)
 3249:         item = get1(result)
 3250:         assert type(item) is np.datetime64
 3251:         dtype = tm.get_dtype(result)
 3252:         assert dtype == object
 3253: 
 3254:     @pytest.mark.parametrize("cls", [timedelta, np.timedelta64])
 3255:     def test_from_out_of_bounds_ns_timedelta(
 3256:         self, constructor, cls, request, box, frame_or_series
 3257:     ):
 3258:         # scalar that won't fit in nanosecond td64, but will fit in microsecond
 3259:         if box is list or (frame_or_series is Series and box is dict):
 3260:             mark = pytest.mark.xfail(
 3261:                 reason="TimedeltaArray constructor has been updated to cast td64 "
 3262:                 "to non-nano, but TimedeltaArray._from_sequence has not",
 3263:                 strict=True,
 3264:             )
 3265:             request.applymarker(mark)
 3266: 
 3267:         scalar = datetime(9999, 1, 1) - datetime(1970, 1, 1)
 3268:         exp_dtype = "m8[us]"  # smallest reso that fits
 3269:         if cls is np.timedelta64:
 3270:             scalar = np.timedelta64(scalar, "D")
 3271:             exp_dtype = "m8[s]"  # closest reso to input
 3272:         result = constructor(scalar)
 3273: 
 3274:         item = get1(result)
 3275:         dtype = tm.get_dtype(result)
 3276: 
 3277:         assert type(item) is Timedelta
 3278:         assert item.asm8.dtype == exp_dtype
 3279:         assert dtype == exp_dtype
 3280: 
 3281:     @pytest.mark.skip_ubsan
 3282:     @pytest.mark.parametrize("cls", [np.datetime64, np.timedelta64])
 3283:     def test_out_of_s_bounds_timedelta64(self, constructor, cls):
 3284:         scalar = cls(np.iinfo(np.int64).max, "D")
 3285:         result = constructor(scalar)
 3286:         item = get1(result)
 3287:         assert type(item) is cls
 3288:         dtype = tm.get_dtype(result)
 3289:         assert dtype == object
 3290: 
 3291:     def test_tzaware_data_tznaive_dtype(self, constructor, box, frame_or_series):
 3292:         tz = "US/Eastern"
 3293:         ts = Timestamp("2019", tz=tz)
 3294: 
 3295:         if box is None or (frame_or_series is DataFrame and box is dict):
 3296:             msg = "Cannot unbox tzaware Timestamp to tznaive dtype"
 3297:             err = TypeError
 3298:         else:
 3299:             msg = (
 3300:                 "Cannot convert timezone-aware data to timezone-naive dtype. "
 3301:                 r"Use pd.Series\(values\).dt.tz_localize\(None\) instead."
 3302:             )
 3303:             err = ValueError
 3304: 
 3305:         with pytest.raises(err, match=msg):
 3306:             constructor(ts, dtype="M8[ns]")
 3307: 
 3308: 
 3309: # TODO: better location for this test?
 3310: class TestAllowNonNano:
 3311:     # Until 2.0, we do not preserve non-nano dt64/td64 when passed as ndarray,
 3312:     #  but do preserve it when passed as DTA/TDA
 3313: 
 3314:     @pytest.fixture(params=[True, False])
 3315:     def as_td(self, request):
 3316:         return request.param
 3317: 
 3318:     @pytest.fixture
 3319:     def arr(self, as_td):
 3320:         values = np.arange(5).astype(np.int64).view("M8[s]")
 3321:         if as_td:
 3322:             values = values - values[0]
 3323:             return TimedeltaArray._simple_new(values, dtype=values.dtype)
 3324:         else:
 3325:             return DatetimeArray._simple_new(values, dtype=values.dtype)
 3326: 
 3327:     def test_index_allow_non_nano(self, arr):
 3328:         idx = Index(arr)
 3329:         assert idx.dtype == arr.dtype
 3330: 
 3331:     def test_dti_tdi_allow_non_nano(self, arr, as_td):
 3332:         if as_td:
 3333:             idx = pd.TimedeltaIndex(arr)
 3334:         else:
 3335:             idx = DatetimeIndex(arr)
 3336:         assert idx.dtype == arr.dtype
 3337: 
 3338:     def test_series_allow_non_nano(self, arr):
 3339:         ser = Series(arr)
 3340:         assert ser.dtype == arr.dtype
 3341: 
 3342:     def test_frame_allow_non_nano(self, arr):
 3343:         df = DataFrame(arr)
 3344:         assert df.dtypes[0] == arr.dtype
 3345: 
 3346:     def test_frame_from_dict_allow_non_nano(self, arr):
 3347:         df = DataFrame({0: arr})
 3348:         assert df.dtypes[0] == arr.dtype
