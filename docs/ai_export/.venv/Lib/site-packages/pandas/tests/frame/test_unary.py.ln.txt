    1: from decimal import Decimal
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.compat.numpy import np_version_gte1p25
    7: 
    8: import pandas as pd
    9: import pandas._testing as tm
   10: 
   11: 
   12: class TestDataFrameUnaryOperators:
   13:     # __pos__, __neg__, __invert__
   14: 
   15:     @pytest.mark.parametrize(
   16:         "df,expected",
   17:         [
   18:             (pd.DataFrame({"a": [-1, 1]}), pd.DataFrame({"a": [1, -1]})),
   19:             (pd.DataFrame({"a": [False, True]}), pd.DataFrame({"a": [True, False]})),
   20:             (
   21:                 pd.DataFrame({"a": pd.Series(pd.to_timedelta([-1, 1]))}),
   22:                 pd.DataFrame({"a": pd.Series(pd.to_timedelta([1, -1]))}),
   23:             ),
   24:         ],
   25:     )
   26:     def test_neg_numeric(self, df, expected):
   27:         tm.assert_frame_equal(-df, expected)
   28:         tm.assert_series_equal(-df["a"], expected["a"])
   29: 
   30:     @pytest.mark.parametrize(
   31:         "df, expected",
   32:         [
   33:             (np.array([1, 2], dtype=object), np.array([-1, -2], dtype=object)),
   34:             ([Decimal("1.0"), Decimal("2.0")], [Decimal("-1.0"), Decimal("-2.0")]),
   35:         ],
   36:     )
   37:     def test_neg_object(self, df, expected):
   38:         # GH#21380
   39:         df = pd.DataFrame({"a": df})
   40:         expected = pd.DataFrame({"a": expected})
   41:         tm.assert_frame_equal(-df, expected)
   42:         tm.assert_series_equal(-df["a"], expected["a"])
   43: 
   44:     @pytest.mark.parametrize(
   45:         "df",
   46:         [
   47:             pd.DataFrame({"a": ["a", "b"]}),
   48:             pd.DataFrame({"a": pd.to_datetime(["2017-01-22", "1970-01-01"])}),
   49:         ],
   50:     )
   51:     def test_neg_raises(self, df, using_infer_string):
   52:         msg = (
   53:             "bad operand type for unary -: 'str'|"
   54:             r"bad operand type for unary -: 'DatetimeArray'"
   55:         )
   56:         if using_infer_string and df.dtypes.iloc[0] == "string":
   57:             import pyarrow as pa
   58: 
   59:             msg = "has no kernel"
   60:             with pytest.raises(pa.lib.ArrowNotImplementedError, match=msg):
   61:                 (-df)
   62:             with pytest.raises(pa.lib.ArrowNotImplementedError, match=msg):
   63:                 (-df["a"])
   64: 
   65:         else:
   66:             with pytest.raises(TypeError, match=msg):
   67:                 (-df)
   68:             with pytest.raises(TypeError, match=msg):
   69:                 (-df["a"])
   70: 
   71:     def test_invert(self, float_frame):
   72:         df = float_frame
   73: 
   74:         tm.assert_frame_equal(-(df < 0), ~(df < 0))
   75: 
   76:     def test_invert_mixed(self):
   77:         shape = (10, 5)
   78:         df = pd.concat(
   79:             [
   80:                 pd.DataFrame(np.zeros(shape, dtype="bool")),
   81:                 pd.DataFrame(np.zeros(shape, dtype=int)),
   82:             ],
   83:             axis=1,
   84:             ignore_index=True,
   85:         )
   86:         result = ~df
   87:         expected = pd.concat(
   88:             [
   89:                 pd.DataFrame(np.ones(shape, dtype="bool")),
   90:                 pd.DataFrame(-np.ones(shape, dtype=int)),
   91:             ],
   92:             axis=1,
   93:             ignore_index=True,
   94:         )
   95:         tm.assert_frame_equal(result, expected)
   96: 
   97:     def test_invert_empty_not_input(self):
   98:         # GH#51032
   99:         df = pd.DataFrame()
  100:         result = ~df
  101:         tm.assert_frame_equal(df, result)
  102:         assert df is not result
  103: 
  104:     @pytest.mark.parametrize(
  105:         "df",
  106:         [
  107:             pd.DataFrame({"a": [-1, 1]}),
  108:             pd.DataFrame({"a": [False, True]}),
  109:             pd.DataFrame({"a": pd.Series(pd.to_timedelta([-1, 1]))}),
  110:         ],
  111:     )
  112:     def test_pos_numeric(self, df):
  113:         # GH#16073
  114:         tm.assert_frame_equal(+df, df)
  115:         tm.assert_series_equal(+df["a"], df["a"])
  116: 
  117:     @pytest.mark.parametrize(
  118:         "df",
  119:         [
  120:             pd.DataFrame({"a": np.array([-1, 2], dtype=object)}),
  121:             pd.DataFrame({"a": [Decimal("-1.0"), Decimal("2.0")]}),
  122:         ],
  123:     )
  124:     def test_pos_object(self, df):
  125:         # GH#21380
  126:         tm.assert_frame_equal(+df, df)
  127:         tm.assert_series_equal(+df["a"], df["a"])
  128: 
  129:     @pytest.mark.parametrize(
  130:         "df",
  131:         [
  132:             pytest.param(
  133:                 pd.DataFrame({"a": ["a", "b"]}),
  134:                 # filterwarnings removable once min numpy version is 1.25
  135:                 marks=[
  136:                     pytest.mark.filterwarnings("ignore:Applying:DeprecationWarning")
  137:                 ],
  138:             ),
  139:         ],
  140:     )
  141:     def test_pos_object_raises(self, df):
  142:         # GH#21380
  143:         if np_version_gte1p25:
  144:             with pytest.raises(
  145:                 TypeError, match=r"^bad operand type for unary \+: \'str\'$"
  146:             ):
  147:                 tm.assert_frame_equal(+df, df)
  148:         else:
  149:             tm.assert_series_equal(+df["a"], df["a"])
  150: 
  151:     @pytest.mark.parametrize(
  152:         "df", [pd.DataFrame({"a": pd.to_datetime(["2017-01-22", "1970-01-01"])})]
  153:     )
  154:     def test_pos_raises(self, df):
  155:         msg = r"bad operand type for unary \+: 'DatetimeArray'"
  156:         with pytest.raises(TypeError, match=msg):
  157:             (+df)
  158:         with pytest.raises(TypeError, match=msg):
  159:             (+df["a"])
  160: 
  161:     def test_unary_nullable(self):
  162:         df = pd.DataFrame(
  163:             {
  164:                 "a": pd.array([1, -2, 3, pd.NA], dtype="Int64"),
  165:                 "b": pd.array([4.0, -5.0, 6.0, pd.NA], dtype="Float32"),
  166:                 "c": pd.array([True, False, False, pd.NA], dtype="boolean"),
  167:                 # include numpy bool to make sure bool-vs-boolean behavior
  168:                 #  is consistent in non-NA locations
  169:                 "d": np.array([True, False, False, True]),
  170:             }
  171:         )
  172: 
  173:         result = +df
  174:         res_ufunc = np.positive(df)
  175:         expected = df
  176:         # TODO: assert that we have copies?
  177:         tm.assert_frame_equal(result, expected)
  178:         tm.assert_frame_equal(res_ufunc, expected)
  179: 
  180:         result = -df
  181:         res_ufunc = np.negative(df)
  182:         expected = pd.DataFrame(
  183:             {
  184:                 "a": pd.array([-1, 2, -3, pd.NA], dtype="Int64"),
  185:                 "b": pd.array([-4.0, 5.0, -6.0, pd.NA], dtype="Float32"),
  186:                 "c": pd.array([False, True, True, pd.NA], dtype="boolean"),
  187:                 "d": np.array([False, True, True, False]),
  188:             }
  189:         )
  190:         tm.assert_frame_equal(result, expected)
  191:         tm.assert_frame_equal(res_ufunc, expected)
  192: 
  193:         result = abs(df)
  194:         res_ufunc = np.abs(df)
  195:         expected = pd.DataFrame(
  196:             {
  197:                 "a": pd.array([1, 2, 3, pd.NA], dtype="Int64"),
  198:                 "b": pd.array([4.0, 5.0, 6.0, pd.NA], dtype="Float32"),
  199:                 "c": pd.array([True, False, False, pd.NA], dtype="boolean"),
  200:                 "d": np.array([True, False, False, True]),
  201:             }
  202:         )
  203:         tm.assert_frame_equal(result, expected)
  204:         tm.assert_frame_equal(res_ufunc, expected)
