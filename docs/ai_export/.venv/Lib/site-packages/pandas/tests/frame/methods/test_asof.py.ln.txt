    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._libs.tslibs import IncompatibleFrequency
    5: 
    6: from pandas import (
    7:     DataFrame,
    8:     Period,
    9:     Series,
   10:     Timestamp,
   11:     date_range,
   12:     period_range,
   13:     to_datetime,
   14: )
   15: import pandas._testing as tm
   16: 
   17: 
   18: @pytest.fixture
   19: def date_range_frame():
   20:     """
   21:     Fixture for DataFrame of ints with date_range index
   22: 
   23:     Columns are ['A', 'B'].
   24:     """
   25:     N = 50
   26:     rng = date_range("1/1/1990", periods=N, freq="53s")
   27:     return DataFrame({"A": np.arange(N), "B": np.arange(N)}, index=rng)
   28: 
   29: 
   30: class TestFrameAsof:
   31:     def test_basic(self, date_range_frame):
   32:         # Explicitly cast to float to avoid implicit cast when setting np.nan
   33:         df = date_range_frame.astype({"A": "float"})
   34:         N = 50
   35:         df.loc[df.index[15:30], "A"] = np.nan
   36:         dates = date_range("1/1/1990", periods=N * 3, freq="25s")
   37: 
   38:         result = df.asof(dates)
   39:         assert result.notna().all(1).all()
   40:         lb = df.index[14]
   41:         ub = df.index[30]
   42: 
   43:         dates = list(dates)
   44: 
   45:         result = df.asof(dates)
   46:         assert result.notna().all(1).all()
   47: 
   48:         mask = (result.index >= lb) & (result.index < ub)
   49:         rs = result[mask]
   50:         assert (rs == 14).all(1).all()
   51: 
   52:     def test_subset(self, date_range_frame):
   53:         N = 10
   54:         # explicitly cast to float to avoid implicit upcast when setting to np.nan
   55:         df = date_range_frame.iloc[:N].copy().astype({"A": "float"})
   56:         df.loc[df.index[4:8], "A"] = np.nan
   57:         dates = date_range("1/1/1990", periods=N * 3, freq="25s")
   58: 
   59:         # with a subset of A should be the same
   60:         result = df.asof(dates, subset="A")
   61:         expected = df.asof(dates)
   62:         tm.assert_frame_equal(result, expected)
   63: 
   64:         # same with A/B
   65:         result = df.asof(dates, subset=["A", "B"])
   66:         expected = df.asof(dates)
   67:         tm.assert_frame_equal(result, expected)
   68: 
   69:         # B gives df.asof
   70:         result = df.asof(dates, subset="B")
   71:         expected = df.resample("25s", closed="right").ffill().reindex(dates)
   72:         expected.iloc[20:] = 9
   73:         # no "missing", so "B" can retain int dtype (df["A"].dtype platform-dependent)
   74:         expected["B"] = expected["B"].astype(df["B"].dtype)
   75: 
   76:         tm.assert_frame_equal(result, expected)
   77: 
   78:     def test_missing(self, date_range_frame):
   79:         # GH 15118
   80:         # no match found - `where` value before earliest date in index
   81:         N = 10
   82:         # Cast to 'float64' to avoid upcast when introducing nan in df.asof
   83:         df = date_range_frame.iloc[:N].copy().astype("float64")
   84: 
   85:         result = df.asof("1989-12-31")
   86: 
   87:         expected = Series(
   88:             index=["A", "B"], name=Timestamp("1989-12-31"), dtype=np.float64
   89:         )
   90:         tm.assert_series_equal(result, expected)
   91: 
   92:         result = df.asof(to_datetime(["1989-12-31"]))
   93:         expected = DataFrame(
   94:             index=to_datetime(["1989-12-31"]), columns=["A", "B"], dtype="float64"
   95:         )
   96:         tm.assert_frame_equal(result, expected)
   97: 
   98:         # Check that we handle PeriodIndex correctly, dont end up with
   99:         #  period.ordinal for series name
  100:         df = df.to_period("D")
  101:         result = df.asof("1989-12-31")
  102:         assert isinstance(result.name, Period)
  103: 
  104:     def test_asof_all_nans(self, frame_or_series):
  105:         # GH 15713
  106:         # DataFrame/Series is all nans
  107:         result = frame_or_series([np.nan]).asof([0])
  108:         expected = frame_or_series([np.nan])
  109:         tm.assert_equal(result, expected)
  110: 
  111:     def test_all_nans(self, date_range_frame):
  112:         # GH 15713
  113:         # DataFrame is all nans
  114: 
  115:         # testing non-default indexes, multiple inputs
  116:         N = 150
  117:         rng = date_range_frame.index
  118:         dates = date_range("1/1/1990", periods=N, freq="25s")
  119:         result = DataFrame(np.nan, index=rng, columns=["A"]).asof(dates)
  120:         expected = DataFrame(np.nan, index=dates, columns=["A"])
  121:         tm.assert_frame_equal(result, expected)
  122: 
  123:         # testing multiple columns
  124:         dates = date_range("1/1/1990", periods=N, freq="25s")
  125:         result = DataFrame(np.nan, index=rng, columns=["A", "B", "C"]).asof(dates)
  126:         expected = DataFrame(np.nan, index=dates, columns=["A", "B", "C"])
  127:         tm.assert_frame_equal(result, expected)
  128: 
  129:         # testing scalar input
  130:         result = DataFrame(np.nan, index=[1, 2], columns=["A", "B"]).asof([3])
  131:         expected = DataFrame(np.nan, index=[3], columns=["A", "B"])
  132:         tm.assert_frame_equal(result, expected)
  133: 
  134:         result = DataFrame(np.nan, index=[1, 2], columns=["A", "B"]).asof(3)
  135:         expected = Series(np.nan, index=["A", "B"], name=3)
  136:         tm.assert_series_equal(result, expected)
  137: 
  138:     @pytest.mark.parametrize(
  139:         "stamp,expected",
  140:         [
  141:             (
  142:                 Timestamp("2018-01-01 23:22:43.325+00:00"),
  143:                 Series(2, name=Timestamp("2018-01-01 23:22:43.325+00:00")),
  144:             ),
  145:             (
  146:                 Timestamp("2018-01-01 22:33:20.682+01:00"),
  147:                 Series(1, name=Timestamp("2018-01-01 22:33:20.682+01:00")),
  148:             ),
  149:         ],
  150:     )
  151:     def test_time_zone_aware_index(self, stamp, expected):
  152:         # GH21194
  153:         # Testing awareness of DataFrame index considering different
  154:         # UTC and timezone
  155:         df = DataFrame(
  156:             data=[1, 2],
  157:             index=[
  158:                 Timestamp("2018-01-01 21:00:05.001+00:00"),
  159:                 Timestamp("2018-01-01 22:35:10.550+00:00"),
  160:             ],
  161:         )
  162: 
  163:         result = df.asof(stamp)
  164:         tm.assert_series_equal(result, expected)
  165: 
  166:     def test_is_copy(self, date_range_frame):
  167:         # GH-27357, GH-30784: ensure the result of asof is an actual copy and
  168:         # doesn't track the parent dataframe / doesn't give SettingWithCopy warnings
  169:         df = date_range_frame.astype({"A": "float"})
  170:         N = 50
  171:         df.loc[df.index[15:30], "A"] = np.nan
  172:         dates = date_range("1/1/1990", periods=N * 3, freq="25s")
  173: 
  174:         result = df.asof(dates)
  175: 
  176:         with tm.assert_produces_warning(None):
  177:             result["C"] = 1
  178: 
  179:     def test_asof_periodindex_mismatched_freq(self):
  180:         N = 50
  181:         rng = period_range("1/1/1990", periods=N, freq="h")
  182:         df = DataFrame(np.random.default_rng(2).standard_normal(N), index=rng)
  183: 
  184:         # Mismatched freq
  185:         msg = "Input has different freq"
  186:         with pytest.raises(IncompatibleFrequency, match=msg):
  187:             df.asof(rng.asfreq("D"))
  188: 
  189:     def test_asof_preserves_bool_dtype(self):
  190:         # GH#16063 was casting bools to floats
  191:         dti = date_range("2017-01-01", freq="MS", periods=4)
  192:         ser = Series([True, False, True], index=dti[:-1])
  193: 
  194:         ts = dti[-1]
  195:         res = ser.asof([ts])
  196: 
  197:         expected = Series([True], index=[ts])
  198:         tm.assert_series_equal(res, expected)
