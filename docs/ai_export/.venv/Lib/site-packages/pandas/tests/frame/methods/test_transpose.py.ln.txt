    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     DatetimeIndex,
   10:     Index,
   11:     IntervalIndex,
   12:     Series,
   13:     Timestamp,
   14:     bdate_range,
   15:     date_range,
   16:     timedelta_range,
   17: )
   18: import pandas._testing as tm
   19: 
   20: 
   21: class TestTranspose:
   22:     def test_transpose_td64_intervals(self):
   23:         # GH#44917
   24:         tdi = timedelta_range("0 Days", "3 Days")
   25:         ii = IntervalIndex.from_breaks(tdi)
   26:         ii = ii.insert(-1, np.nan)
   27:         df = DataFrame(ii)
   28: 
   29:         result = df.T
   30:         expected = DataFrame({i: ii[i : i + 1] for i in range(len(ii))})
   31:         tm.assert_frame_equal(result, expected)
   32: 
   33:     def test_transpose_empty_preserves_datetimeindex(self):
   34:         # GH#41382
   35:         dti = DatetimeIndex([], dtype="M8[ns]")
   36:         df = DataFrame(index=dti)
   37: 
   38:         expected = DatetimeIndex([], dtype="datetime64[ns]", freq=None)
   39: 
   40:         result1 = df.T.sum().index
   41:         result2 = df.sum(axis=1).index
   42: 
   43:         tm.assert_index_equal(result1, expected)
   44:         tm.assert_index_equal(result2, expected)
   45: 
   46:     def test_transpose_tzaware_1col_single_tz(self):
   47:         # GH#26825
   48:         dti = date_range("2016-04-05 04:30", periods=3, tz="UTC")
   49: 
   50:         df = DataFrame(dti)
   51:         assert (df.dtypes == dti.dtype).all()
   52:         res = df.T
   53:         assert (res.dtypes == dti.dtype).all()
   54: 
   55:     def test_transpose_tzaware_2col_single_tz(self):
   56:         # GH#26825
   57:         dti = date_range("2016-04-05 04:30", periods=3, tz="UTC")
   58: 
   59:         df3 = DataFrame({"A": dti, "B": dti})
   60:         assert (df3.dtypes == dti.dtype).all()
   61:         res3 = df3.T
   62:         assert (res3.dtypes == dti.dtype).all()
   63: 
   64:     def test_transpose_tzaware_2col_mixed_tz(self):
   65:         # GH#26825
   66:         dti = date_range("2016-04-05 04:30", periods=3, tz="UTC")
   67:         dti2 = dti.tz_convert("US/Pacific")
   68: 
   69:         df4 = DataFrame({"A": dti, "B": dti2})
   70:         assert (df4.dtypes == [dti.dtype, dti2.dtype]).all()
   71:         assert (df4.T.dtypes == object).all()
   72:         tm.assert_frame_equal(df4.T.T, df4.astype(object))
   73: 
   74:     @pytest.mark.parametrize("tz", [None, "America/New_York"])
   75:     def test_transpose_preserves_dtindex_equality_with_dst(self, tz):
   76:         # GH#19970
   77:         idx = date_range("20161101", "20161130", freq="4h", tz=tz)
   78:         df = DataFrame({"a": range(len(idx)), "b": range(len(idx))}, index=idx)
   79:         result = df.T == df.T
   80:         expected = DataFrame(True, index=list("ab"), columns=idx)
   81:         tm.assert_frame_equal(result, expected)
   82: 
   83:     def test_transpose_object_to_tzaware_mixed_tz(self):
   84:         # GH#26825
   85:         dti = date_range("2016-04-05 04:30", periods=3, tz="UTC")
   86:         dti2 = dti.tz_convert("US/Pacific")
   87: 
   88:         # mixed all-tzaware dtypes
   89:         df2 = DataFrame([dti, dti2])
   90:         assert (df2.dtypes == object).all()
   91:         res2 = df2.T
   92:         assert (res2.dtypes == object).all()
   93: 
   94:     def test_transpose_uint64(self):
   95:         df = DataFrame(
   96:             {"A": np.arange(3), "B": [2**63, 2**63 + 5, 2**63 + 10]},
   97:             dtype=np.uint64,
   98:         )
   99:         result = df.T
  100:         expected = DataFrame(df.values.T)
  101:         expected.index = ["A", "B"]
  102:         tm.assert_frame_equal(result, expected)
  103: 
  104:     def test_transpose_float(self, float_frame):
  105:         frame = float_frame
  106:         dft = frame.T
  107:         for idx, series in dft.items():
  108:             for col, value in series.items():
  109:                 if np.isnan(value):
  110:                     assert np.isnan(frame[col][idx])
  111:                 else:
  112:                     assert value == frame[col][idx]
  113: 
  114:     def test_transpose_mixed(self):
  115:         # mixed type
  116:         mixed = DataFrame(
  117:             {
  118:                 "A": [0.0, 1.0, 2.0, 3.0, 4.0],
  119:                 "B": [0.0, 1.0, 0.0, 1.0, 0.0],
  120:                 "C": ["foo1", "foo2", "foo3", "foo4", "foo5"],
  121:                 "D": bdate_range("1/1/2009", periods=5),
  122:             },
  123:             index=Index(["a", "b", "c", "d", "e"], dtype=object),
  124:         )
  125: 
  126:         mixed_T = mixed.T
  127:         for col, s in mixed_T.items():
  128:             assert s.dtype == np.object_
  129: 
  130:     @td.skip_array_manager_invalid_test
  131:     def test_transpose_get_view(self, float_frame, using_copy_on_write):
  132:         dft = float_frame.T
  133:         dft.iloc[:, 5:10] = 5
  134: 
  135:         if using_copy_on_write:
  136:             assert (float_frame.values[5:10] != 5).all()
  137:         else:
  138:             assert (float_frame.values[5:10] == 5).all()
  139: 
  140:     @td.skip_array_manager_invalid_test
  141:     def test_transpose_get_view_dt64tzget_view(self, using_copy_on_write):
  142:         dti = date_range("2016-01-01", periods=6, tz="US/Pacific")
  143:         arr = dti._data.reshape(3, 2)
  144:         df = DataFrame(arr)
  145:         assert df._mgr.nblocks == 1
  146: 
  147:         result = df.T
  148:         assert result._mgr.nblocks == 1
  149: 
  150:         rtrip = result._mgr.blocks[0].values
  151:         if using_copy_on_write:
  152:             assert np.shares_memory(df._mgr.blocks[0].values._ndarray, rtrip._ndarray)
  153:         else:
  154:             assert np.shares_memory(arr._ndarray, rtrip._ndarray)
  155: 
  156:     def test_transpose_not_inferring_dt(self):
  157:         # GH#51546
  158:         df = DataFrame(
  159:             {
  160:                 "a": [Timestamp("2019-12-31"), Timestamp("2019-12-31")],
  161:             },
  162:             dtype=object,
  163:         )
  164:         result = df.T
  165:         expected = DataFrame(
  166:             [[Timestamp("2019-12-31"), Timestamp("2019-12-31")]],
  167:             columns=[0, 1],
  168:             index=["a"],
  169:             dtype=object,
  170:         )
  171:         tm.assert_frame_equal(result, expected)
  172: 
  173:     def test_transpose_not_inferring_dt_mixed_blocks(self):
  174:         # GH#51546
  175:         df = DataFrame(
  176:             {
  177:                 "a": Series(
  178:                     [Timestamp("2019-12-31"), Timestamp("2019-12-31")], dtype=object
  179:                 ),
  180:                 "b": [Timestamp("2019-12-31"), Timestamp("2019-12-31")],
  181:             }
  182:         )
  183:         result = df.T
  184:         expected = DataFrame(
  185:             [
  186:                 [Timestamp("2019-12-31"), Timestamp("2019-12-31")],
  187:                 [Timestamp("2019-12-31"), Timestamp("2019-12-31")],
  188:             ],
  189:             columns=[0, 1],
  190:             index=["a", "b"],
  191:             dtype=object,
  192:         )
  193:         tm.assert_frame_equal(result, expected)
  194: 
  195:     @pytest.mark.parametrize("dtype1", ["Int64", "Float64"])
  196:     @pytest.mark.parametrize("dtype2", ["Int64", "Float64"])
  197:     def test_transpose(self, dtype1, dtype2):
  198:         # GH#57315 - transpose should have F contiguous blocks
  199:         df = DataFrame(
  200:             {
  201:                 "a": pd.array([1, 1, 2], dtype=dtype1),
  202:                 "b": pd.array([3, 4, 5], dtype=dtype2),
  203:             }
  204:         )
  205:         result = df.T
  206:         for blk in result._mgr.blocks:
  207:             # When dtypes are unequal, we get NumPy object array
  208:             data = blk.values._data if dtype1 == dtype2 else blk.values
  209:             assert data.flags["F_CONTIGUOUS"]
