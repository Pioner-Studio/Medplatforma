    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._config import using_pyarrow_string_dtype
    5: 
    6: import pandas.util._test_decorators as td
    7: 
    8: from pandas import (
    9:     Categorical,
   10:     DataFrame,
   11:     DatetimeIndex,
   12:     NaT,
   13:     PeriodIndex,
   14:     Series,
   15:     TimedeltaIndex,
   16:     Timestamp,
   17:     date_range,
   18:     to_datetime,
   19: )
   20: import pandas._testing as tm
   21: from pandas.tests.frame.common import _check_mixed_float
   22: 
   23: 
   24: class TestFillNA:
   25:     def test_fillna_dict_inplace_nonunique_columns(
   26:         self, using_copy_on_write, warn_copy_on_write
   27:     ):
   28:         df = DataFrame(
   29:             {"A": [np.nan] * 3, "B": [NaT, Timestamp(1), NaT], "C": [np.nan, "foo", 2]}
   30:         )
   31:         df.columns = ["A", "A", "A"]
   32:         orig = df[:]
   33: 
   34:         # TODO(CoW-warn) better warning message
   35:         with tm.assert_cow_warning(warn_copy_on_write):
   36:             df.fillna({"A": 2}, inplace=True)
   37:         # The first and third columns can be set inplace, while the second cannot.
   38: 
   39:         expected = DataFrame(
   40:             {"A": [2.0] * 3, "B": [2, Timestamp(1), 2], "C": [2, "foo", 2]}
   41:         )
   42:         expected.columns = ["A", "A", "A"]
   43:         tm.assert_frame_equal(df, expected)
   44: 
   45:         # TODO: what's the expected/desired behavior with CoW?
   46:         if not using_copy_on_write:
   47:             assert tm.shares_memory(df.iloc[:, 0], orig.iloc[:, 0])
   48:         assert not tm.shares_memory(df.iloc[:, 1], orig.iloc[:, 1])
   49:         if not using_copy_on_write:
   50:             assert tm.shares_memory(df.iloc[:, 2], orig.iloc[:, 2])
   51: 
   52:     @td.skip_array_manager_not_yet_implemented
   53:     def test_fillna_on_column_view(self, using_copy_on_write):
   54:         # GH#46149 avoid unnecessary copies
   55:         arr = np.full((40, 50), np.nan)
   56:         df = DataFrame(arr, copy=False)
   57: 
   58:         if using_copy_on_write:
   59:             with tm.raises_chained_assignment_error():
   60:                 df[0].fillna(-1, inplace=True)
   61:             assert np.isnan(arr[:, 0]).all()
   62:         else:
   63:             with tm.assert_produces_warning(FutureWarning, match="inplace method"):
   64:                 df[0].fillna(-1, inplace=True)
   65:             assert (arr[:, 0] == -1).all()
   66: 
   67:         # i.e. we didn't create a new 49-column block
   68:         assert len(df._mgr.arrays) == 1
   69:         assert np.shares_memory(df.values, arr)
   70: 
   71:     def test_fillna_datetime(self, datetime_frame):
   72:         tf = datetime_frame
   73:         tf.loc[tf.index[:5], "A"] = np.nan
   74:         tf.loc[tf.index[-5:], "A"] = np.nan
   75: 
   76:         zero_filled = datetime_frame.fillna(0)
   77:         assert (zero_filled.loc[zero_filled.index[:5], "A"] == 0).all()
   78: 
   79:         msg = "DataFrame.fillna with 'method' is deprecated"
   80:         with tm.assert_produces_warning(FutureWarning, match=msg):
   81:             padded = datetime_frame.fillna(method="pad")
   82:         assert np.isnan(padded.loc[padded.index[:5], "A"]).all()
   83:         assert (
   84:             padded.loc[padded.index[-5:], "A"] == padded.loc[padded.index[-5], "A"]
   85:         ).all()
   86: 
   87:         msg = "Must specify a fill 'value' or 'method'"
   88:         with pytest.raises(ValueError, match=msg):
   89:             datetime_frame.fillna()
   90:         msg = "Cannot specify both 'value' and 'method'"
   91:         with pytest.raises(ValueError, match=msg):
   92:             datetime_frame.fillna(5, method="ffill")
   93: 
   94:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="can't fill 0 in string")
   95:     def test_fillna_mixed_type(self, float_string_frame):
   96:         mf = float_string_frame
   97:         mf.loc[mf.index[5:20], "foo"] = np.nan
   98:         mf.loc[mf.index[-10:], "A"] = np.nan
   99:         # TODO: make stronger assertion here, GH 25640
  100:         mf.fillna(value=0)
  101:         msg = "DataFrame.fillna with 'method' is deprecated"
  102:         with tm.assert_produces_warning(FutureWarning, match=msg):
  103:             mf.fillna(method="pad")
  104: 
  105:     def test_fillna_mixed_float(self, mixed_float_frame):
  106:         # mixed numeric (but no float16)
  107:         mf = mixed_float_frame.reindex(columns=["A", "B", "D"])
  108:         mf.loc[mf.index[-10:], "A"] = np.nan
  109:         result = mf.fillna(value=0)
  110:         _check_mixed_float(result, dtype={"C": None})
  111: 
  112:         msg = "DataFrame.fillna with 'method' is deprecated"
  113:         with tm.assert_produces_warning(FutureWarning, match=msg):
  114:             result = mf.fillna(method="pad")
  115:         _check_mixed_float(result, dtype={"C": None})
  116: 
  117:     def test_fillna_empty(self, using_copy_on_write):
  118:         if using_copy_on_write:
  119:             pytest.skip("condition is unnecessary complex and is deprecated anyway")
  120:         # empty frame (GH#2778)
  121:         df = DataFrame(columns=["x"])
  122:         for m in ["pad", "backfill"]:
  123:             msg = "Series.fillna with 'method' is deprecated"
  124:             with tm.assert_produces_warning(FutureWarning, match=msg):
  125:                 df.x.fillna(method=m, inplace=True)
  126:                 df.x.fillna(method=m)
  127: 
  128:     def test_fillna_different_dtype(self, using_infer_string):
  129:         # with different dtype (GH#3386)
  130:         df = DataFrame(
  131:             [["a", "a", np.nan, "a"], ["b", "b", np.nan, "b"], ["c", "c", np.nan, "c"]]
  132:         )
  133: 
  134:         if using_infer_string:
  135:             with tm.assert_produces_warning(FutureWarning, match="Downcasting"):
  136:                 result = df.fillna({2: "foo"})
  137:         else:
  138:             result = df.fillna({2: "foo"})
  139:         expected = DataFrame(
  140:             [["a", "a", "foo", "a"], ["b", "b", "foo", "b"], ["c", "c", "foo", "c"]]
  141:         )
  142:         tm.assert_frame_equal(result, expected)
  143: 
  144:         if using_infer_string:
  145:             with tm.assert_produces_warning(FutureWarning, match="Downcasting"):
  146:                 return_value = df.fillna({2: "foo"}, inplace=True)
  147:         else:
  148:             return_value = df.fillna({2: "foo"}, inplace=True)
  149:         tm.assert_frame_equal(df, expected)
  150:         assert return_value is None
  151: 
  152:     def test_fillna_limit_and_value(self):
  153:         # limit and value
  154:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 3)))
  155:         df.iloc[2:7, 0] = np.nan
  156:         df.iloc[3:5, 2] = np.nan
  157: 
  158:         expected = df.copy()
  159:         expected.iloc[2, 0] = 999
  160:         expected.iloc[3, 2] = 999
  161:         result = df.fillna(999, limit=1)
  162:         tm.assert_frame_equal(result, expected)
  163: 
  164:     def test_fillna_datelike(self):
  165:         # with datelike
  166:         # GH#6344
  167:         df = DataFrame(
  168:             {
  169:                 "Date": [NaT, Timestamp("2014-1-1")],
  170:                 "Date2": [Timestamp("2013-1-1"), NaT],
  171:             }
  172:         )
  173: 
  174:         expected = df.copy()
  175:         expected["Date"] = expected["Date"].fillna(df.loc[df.index[0], "Date2"])
  176:         result = df.fillna(value={"Date": df["Date2"]})
  177:         tm.assert_frame_equal(result, expected)
  178: 
  179:     def test_fillna_tzaware(self):
  180:         # with timezone
  181:         # GH#15855
  182:         df = DataFrame({"A": [Timestamp("2012-11-11 00:00:00+01:00"), NaT]})
  183:         exp = DataFrame(
  184:             {
  185:                 "A": [
  186:                     Timestamp("2012-11-11 00:00:00+01:00"),
  187:                     Timestamp("2012-11-11 00:00:00+01:00"),
  188:                 ]
  189:             }
  190:         )
  191:         msg = "DataFrame.fillna with 'method' is deprecated"
  192:         with tm.assert_produces_warning(FutureWarning, match=msg):
  193:             res = df.fillna(method="pad")
  194:         tm.assert_frame_equal(res, exp)
  195: 
  196:         df = DataFrame({"A": [NaT, Timestamp("2012-11-11 00:00:00+01:00")]})
  197:         exp = DataFrame(
  198:             {
  199:                 "A": [
  200:                     Timestamp("2012-11-11 00:00:00+01:00"),
  201:                     Timestamp("2012-11-11 00:00:00+01:00"),
  202:                 ]
  203:             }
  204:         )
  205:         msg = "DataFrame.fillna with 'method' is deprecated"
  206:         with tm.assert_produces_warning(FutureWarning, match=msg):
  207:             res = df.fillna(method="bfill")
  208:         tm.assert_frame_equal(res, exp)
  209: 
  210:     def test_fillna_tzaware_different_column(self):
  211:         # with timezone in another column
  212:         # GH#15522
  213:         df = DataFrame(
  214:             {
  215:                 "A": date_range("20130101", periods=4, tz="US/Eastern"),
  216:                 "B": [1, 2, np.nan, np.nan],
  217:             }
  218:         )
  219:         msg = "DataFrame.fillna with 'method' is deprecated"
  220:         with tm.assert_produces_warning(FutureWarning, match=msg):
  221:             result = df.fillna(method="pad")
  222:         expected = DataFrame(
  223:             {
  224:                 "A": date_range("20130101", periods=4, tz="US/Eastern"),
  225:                 "B": [1.0, 2.0, 2.0, 2.0],
  226:             }
  227:         )
  228:         tm.assert_frame_equal(result, expected)
  229: 
  230:     def test_na_actions_categorical(self):
  231:         cat = Categorical([1, 2, 3, np.nan], categories=[1, 2, 3])
  232:         vals = ["a", "b", np.nan, "d"]
  233:         df = DataFrame({"cats": cat, "vals": vals})
  234:         cat2 = Categorical([1, 2, 3, 3], categories=[1, 2, 3])
  235:         vals2 = ["a", "b", "b", "d"]
  236:         df_exp_fill = DataFrame({"cats": cat2, "vals": vals2})
  237:         cat3 = Categorical([1, 2, 3], categories=[1, 2, 3])
  238:         vals3 = ["a", "b", np.nan]
  239:         df_exp_drop_cats = DataFrame({"cats": cat3, "vals": vals3})
  240:         cat4 = Categorical([1, 2], categories=[1, 2, 3])
  241:         vals4 = ["a", "b"]
  242:         df_exp_drop_all = DataFrame({"cats": cat4, "vals": vals4})
  243: 
  244:         # fillna
  245:         res = df.fillna(value={"cats": 3, "vals": "b"})
  246:         tm.assert_frame_equal(res, df_exp_fill)
  247: 
  248:         msg = "Cannot setitem on a Categorical with a new category"
  249:         with pytest.raises(TypeError, match=msg):
  250:             df.fillna(value={"cats": 4, "vals": "c"})
  251: 
  252:         msg = "DataFrame.fillna with 'method' is deprecated"
  253:         with tm.assert_produces_warning(FutureWarning, match=msg):
  254:             res = df.fillna(method="pad")
  255:         tm.assert_frame_equal(res, df_exp_fill)
  256: 
  257:         # dropna
  258:         res = df.dropna(subset=["cats"])
  259:         tm.assert_frame_equal(res, df_exp_drop_cats)
  260: 
  261:         res = df.dropna()
  262:         tm.assert_frame_equal(res, df_exp_drop_all)
  263: 
  264:         # make sure that fillna takes missing values into account
  265:         c = Categorical([np.nan, "b", np.nan], categories=["a", "b"])
  266:         df = DataFrame({"cats": c, "vals": [1, 2, 3]})
  267: 
  268:         cat_exp = Categorical(["a", "b", "a"], categories=["a", "b"])
  269:         df_exp = DataFrame({"cats": cat_exp, "vals": [1, 2, 3]})
  270: 
  271:         res = df.fillna("a")
  272:         tm.assert_frame_equal(res, df_exp)
  273: 
  274:     def test_fillna_categorical_nan(self):
  275:         # GH#14021
  276:         # np.nan should always be a valid filler
  277:         cat = Categorical([np.nan, 2, np.nan])
  278:         val = Categorical([np.nan, np.nan, np.nan])
  279:         df = DataFrame({"cats": cat, "vals": val})
  280: 
  281:         # GH#32950 df.median() is poorly behaved because there is no
  282:         #  Categorical.median
  283:         median = Series({"cats": 2.0, "vals": np.nan})
  284: 
  285:         res = df.fillna(median)
  286:         v_exp = [np.nan, np.nan, np.nan]
  287:         df_exp = DataFrame({"cats": [2, 2, 2], "vals": v_exp}, dtype="category")
  288:         tm.assert_frame_equal(res, df_exp)
  289: 
  290:         result = df.cats.fillna(np.nan)
  291:         tm.assert_series_equal(result, df.cats)
  292: 
  293:         result = df.vals.fillna(np.nan)
  294:         tm.assert_series_equal(result, df.vals)
  295: 
  296:         idx = DatetimeIndex(
  297:             ["2011-01-01 09:00", "2016-01-01 23:45", "2011-01-01 09:00", NaT, NaT]
  298:         )
  299:         df = DataFrame({"a": Categorical(idx)})
  300:         tm.assert_frame_equal(df.fillna(value=NaT), df)
  301: 
  302:         idx = PeriodIndex(["2011-01", "2011-01", "2011-01", NaT, NaT], freq="M")
  303:         df = DataFrame({"a": Categorical(idx)})
  304:         tm.assert_frame_equal(df.fillna(value=NaT), df)
  305: 
  306:         idx = TimedeltaIndex(["1 days", "2 days", "1 days", NaT, NaT])
  307:         df = DataFrame({"a": Categorical(idx)})
  308:         tm.assert_frame_equal(df.fillna(value=NaT), df)
  309: 
  310:     def test_fillna_downcast(self):
  311:         # GH#15277
  312:         # infer int64 from float64
  313:         df = DataFrame({"a": [1.0, np.nan]})
  314:         msg = "The 'downcast' keyword in fillna is deprecated"
  315:         with tm.assert_produces_warning(FutureWarning, match=msg):
  316:             result = df.fillna(0, downcast="infer")
  317:         expected = DataFrame({"a": [1, 0]})
  318:         tm.assert_frame_equal(result, expected)
  319: 
  320:         # infer int64 from float64 when fillna value is a dict
  321:         df = DataFrame({"a": [1.0, np.nan]})
  322:         with tm.assert_produces_warning(FutureWarning, match=msg):
  323:             result = df.fillna({"a": 0}, downcast="infer")
  324:         expected = DataFrame({"a": [1, 0]})
  325:         tm.assert_frame_equal(result, expected)
  326: 
  327:     def test_fillna_downcast_false(self, frame_or_series):
  328:         # GH#45603 preserve object dtype with downcast=False
  329:         obj = frame_or_series([1, 2, 3], dtype="object")
  330:         msg = "The 'downcast' keyword in fillna"
  331:         with tm.assert_produces_warning(FutureWarning, match=msg):
  332:             result = obj.fillna("", downcast=False)
  333:         tm.assert_equal(result, obj)
  334: 
  335:     def test_fillna_downcast_noop(self, frame_or_series):
  336:         # GH#45423
  337:         # Two relevant paths:
  338:         #  1) not _can_hold_na (e.g. integer)
  339:         #  2) _can_hold_na + noop + not can_hold_element
  340: 
  341:         obj = frame_or_series([1, 2, 3], dtype=np.int64)
  342: 
  343:         msg = "The 'downcast' keyword in fillna"
  344:         with tm.assert_produces_warning(FutureWarning, match=msg):
  345:             # GH#40988
  346:             res = obj.fillna("foo", downcast=np.dtype(np.int32))
  347:         expected = obj.astype(np.int32)
  348:         tm.assert_equal(res, expected)
  349: 
  350:         obj2 = obj.astype(np.float64)
  351:         with tm.assert_produces_warning(FutureWarning, match=msg):
  352:             res2 = obj2.fillna("foo", downcast="infer")
  353:         expected2 = obj  # get back int64
  354:         tm.assert_equal(res2, expected2)
  355: 
  356:         with tm.assert_produces_warning(FutureWarning, match=msg):
  357:             # GH#40988
  358:             res3 = obj2.fillna("foo", downcast=np.dtype(np.int32))
  359:         tm.assert_equal(res3, expected)
  360: 
  361:     @pytest.mark.parametrize("columns", [["A", "A", "B"], ["A", "A"]])
  362:     def test_fillna_dictlike_value_duplicate_colnames(self, columns):
  363:         # GH#43476
  364:         df = DataFrame(np.nan, index=[0, 1], columns=columns)
  365:         with tm.assert_produces_warning(None):
  366:             result = df.fillna({"A": 0})
  367: 
  368:         expected = df.copy()
  369:         expected["A"] = 0.0
  370:         tm.assert_frame_equal(result, expected)
  371: 
  372:     def test_fillna_dtype_conversion(self, using_infer_string):
  373:         # make sure that fillna on an empty frame works
  374:         df = DataFrame(index=["A", "B", "C"], columns=[1, 2, 3, 4, 5])
  375:         result = df.dtypes
  376:         expected = Series([np.dtype("object")] * 5, index=[1, 2, 3, 4, 5])
  377:         tm.assert_series_equal(result, expected)
  378: 
  379:         msg = "Downcasting object dtype arrays"
  380:         with tm.assert_produces_warning(FutureWarning, match=msg):
  381:             result = df.fillna(1)
  382:         expected = DataFrame(1, index=["A", "B", "C"], columns=[1, 2, 3, 4, 5])
  383:         tm.assert_frame_equal(result, expected)
  384: 
  385:         # empty block
  386:         df = DataFrame(index=range(3), columns=["A", "B"], dtype="float64")
  387:         if using_infer_string:
  388:             with tm.assert_produces_warning(FutureWarning, match="Downcasting"):
  389:                 result = df.fillna("nan")
  390:         else:
  391:             result = df.fillna("nan")
  392:         expected = DataFrame("nan", index=range(3), columns=["A", "B"])
  393:         tm.assert_frame_equal(result, expected)
  394: 
  395:     @pytest.mark.parametrize("val", ["", 1, np.nan, 1.0])
  396:     def test_fillna_dtype_conversion_equiv_replace(self, val):
  397:         df = DataFrame({"A": [1, np.nan], "B": [1.0, 2.0]})
  398:         expected = df.replace(np.nan, val)
  399:         result = df.fillna(val)
  400:         tm.assert_frame_equal(result, expected)
  401: 
  402:     def test_fillna_datetime_columns(self):
  403:         # GH#7095
  404:         df = DataFrame(
  405:             {
  406:                 "A": [-1, -2, np.nan],
  407:                 "B": date_range("20130101", periods=3),
  408:                 "C": ["foo", "bar", None],
  409:                 "D": ["foo2", "bar2", None],
  410:             },
  411:             index=date_range("20130110", periods=3),
  412:         )
  413:         result = df.fillna("?")
  414:         expected = DataFrame(
  415:             {
  416:                 "A": [-1, -2, "?"],
  417:                 "B": date_range("20130101", periods=3),
  418:                 "C": ["foo", "bar", "?"],
  419:                 "D": ["foo2", "bar2", "?"],
  420:             },
  421:             index=date_range("20130110", periods=3),
  422:         )
  423:         tm.assert_frame_equal(result, expected)
  424: 
  425:         df = DataFrame(
  426:             {
  427:                 "A": [-1, -2, np.nan],
  428:                 "B": [Timestamp("2013-01-01"), Timestamp("2013-01-02"), NaT],
  429:                 "C": ["foo", "bar", None],
  430:                 "D": ["foo2", "bar2", None],
  431:             },
  432:             index=date_range("20130110", periods=3),
  433:         )
  434:         result = df.fillna("?")
  435:         expected = DataFrame(
  436:             {
  437:                 "A": [-1, -2, "?"],
  438:                 "B": [Timestamp("2013-01-01"), Timestamp("2013-01-02"), "?"],
  439:                 "C": ["foo", "bar", "?"],
  440:                 "D": ["foo2", "bar2", "?"],
  441:             },
  442:             index=date_range("20130110", periods=3),
  443:         )
  444:         tm.assert_frame_equal(result, expected)
  445: 
  446:     def test_ffill(self, datetime_frame):
  447:         datetime_frame.loc[datetime_frame.index[:5], "A"] = np.nan
  448:         datetime_frame.loc[datetime_frame.index[-5:], "A"] = np.nan
  449: 
  450:         msg = "DataFrame.fillna with 'method' is deprecated"
  451:         with tm.assert_produces_warning(FutureWarning, match=msg):
  452:             alt = datetime_frame.fillna(method="ffill")
  453:         tm.assert_frame_equal(datetime_frame.ffill(), alt)
  454: 
  455:     def test_bfill(self, datetime_frame):
  456:         datetime_frame.loc[datetime_frame.index[:5], "A"] = np.nan
  457:         datetime_frame.loc[datetime_frame.index[-5:], "A"] = np.nan
  458: 
  459:         msg = "DataFrame.fillna with 'method' is deprecated"
  460:         with tm.assert_produces_warning(FutureWarning, match=msg):
  461:             alt = datetime_frame.fillna(method="bfill")
  462: 
  463:         tm.assert_frame_equal(datetime_frame.bfill(), alt)
  464: 
  465:     def test_frame_pad_backfill_limit(self):
  466:         index = np.arange(10)
  467:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)), index=index)
  468: 
  469:         result = df[:2].reindex(index, method="pad", limit=5)
  470: 
  471:         msg = "DataFrame.fillna with 'method' is deprecated"
  472:         with tm.assert_produces_warning(FutureWarning, match=msg):
  473:             expected = df[:2].reindex(index).fillna(method="pad")
  474:         expected.iloc[-3:] = np.nan
  475:         tm.assert_frame_equal(result, expected)
  476: 
  477:         result = df[-2:].reindex(index, method="backfill", limit=5)
  478: 
  479:         with tm.assert_produces_warning(FutureWarning, match=msg):
  480:             expected = df[-2:].reindex(index).fillna(method="backfill")
  481:         expected.iloc[:3] = np.nan
  482:         tm.assert_frame_equal(result, expected)
  483: 
  484:     def test_frame_fillna_limit(self):
  485:         index = np.arange(10)
  486:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)), index=index)
  487: 
  488:         result = df[:2].reindex(index)
  489:         msg = "DataFrame.fillna with 'method' is deprecated"
  490:         with tm.assert_produces_warning(FutureWarning, match=msg):
  491:             result = result.fillna(method="pad", limit=5)
  492: 
  493:         with tm.assert_produces_warning(FutureWarning, match=msg):
  494:             expected = df[:2].reindex(index).fillna(method="pad")
  495:         expected.iloc[-3:] = np.nan
  496:         tm.assert_frame_equal(result, expected)
  497: 
  498:         result = df[-2:].reindex(index)
  499:         with tm.assert_produces_warning(FutureWarning, match=msg):
  500:             result = result.fillna(method="backfill", limit=5)
  501: 
  502:         with tm.assert_produces_warning(FutureWarning, match=msg):
  503:             expected = df[-2:].reindex(index).fillna(method="backfill")
  504:         expected.iloc[:3] = np.nan
  505:         tm.assert_frame_equal(result, expected)
  506: 
  507:     def test_fillna_skip_certain_blocks(self):
  508:         # don't try to fill boolean, int blocks
  509: 
  510:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)).astype(int))
  511: 
  512:         # it works!
  513:         df.fillna(np.nan)
  514: 
  515:     @pytest.mark.parametrize("type", [int, float])
  516:     def test_fillna_positive_limit(self, type):
  517:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4))).astype(type)
  518: 
  519:         msg = "Limit must be greater than 0"
  520:         with pytest.raises(ValueError, match=msg):
  521:             df.fillna(0, limit=-5)
  522: 
  523:     @pytest.mark.parametrize("type", [int, float])
  524:     def test_fillna_integer_limit(self, type):
  525:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4))).astype(type)
  526: 
  527:         msg = "Limit must be an integer"
  528:         with pytest.raises(ValueError, match=msg):
  529:             df.fillna(0, limit=0.5)
  530: 
  531:     def test_fillna_inplace(self):
  532:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))
  533:         df.loc[:4, 1] = np.nan
  534:         df.loc[-4:, 3] = np.nan
  535: 
  536:         expected = df.fillna(value=0)
  537:         assert expected is not df
  538: 
  539:         df.fillna(value=0, inplace=True)
  540:         tm.assert_frame_equal(df, expected)
  541: 
  542:         expected = df.fillna(value={0: 0}, inplace=True)
  543:         assert expected is None
  544: 
  545:         df.loc[:4, 1] = np.nan
  546:         df.loc[-4:, 3] = np.nan
  547:         msg = "DataFrame.fillna with 'method' is deprecated"
  548:         with tm.assert_produces_warning(FutureWarning, match=msg):
  549:             expected = df.fillna(method="ffill")
  550:         assert expected is not df
  551: 
  552:         with tm.assert_produces_warning(FutureWarning, match=msg):
  553:             df.fillna(method="ffill", inplace=True)
  554:         tm.assert_frame_equal(df, expected)
  555: 
  556:     def test_fillna_dict_series(self):
  557:         df = DataFrame(
  558:             {
  559:                 "a": [np.nan, 1, 2, np.nan, np.nan],
  560:                 "b": [1, 2, 3, np.nan, np.nan],
  561:                 "c": [np.nan, 1, 2, 3, 4],
  562:             }
  563:         )
  564: 
  565:         result = df.fillna({"a": 0, "b": 5})
  566: 
  567:         expected = df.copy()
  568:         expected["a"] = expected["a"].fillna(0)
  569:         expected["b"] = expected["b"].fillna(5)
  570:         tm.assert_frame_equal(result, expected)
  571: 
  572:         # it works
  573:         result = df.fillna({"a": 0, "b": 5, "d": 7})
  574: 
  575:         # Series treated same as dict
  576:         result = df.fillna(df.max())
  577:         expected = df.fillna(df.max().to_dict())
  578:         tm.assert_frame_equal(result, expected)
  579: 
  580:         # disable this for now
  581:         with pytest.raises(NotImplementedError, match="column by column"):
  582:             df.fillna(df.max(1), axis=1)
  583: 
  584:     def test_fillna_dataframe(self):
  585:         # GH#8377
  586:         df = DataFrame(
  587:             {
  588:                 "a": [np.nan, 1, 2, np.nan, np.nan],
  589:                 "b": [1, 2, 3, np.nan, np.nan],
  590:                 "c": [np.nan, 1, 2, 3, 4],
  591:             },
  592:             index=list("VWXYZ"),
  593:         )
  594: 
  595:         # df2 may have different index and columns
  596:         df2 = DataFrame(
  597:             {
  598:                 "a": [np.nan, 10, 20, 30, 40],
  599:                 "b": [50, 60, 70, 80, 90],
  600:                 "foo": ["bar"] * 5,
  601:             },
  602:             index=list("VWXuZ"),
  603:         )
  604: 
  605:         result = df.fillna(df2)
  606: 
  607:         # only those columns and indices which are shared get filled
  608:         expected = DataFrame(
  609:             {
  610:                 "a": [np.nan, 1, 2, np.nan, 40],
  611:                 "b": [1, 2, 3, np.nan, 90],
  612:                 "c": [np.nan, 1, 2, 3, 4],
  613:             },
  614:             index=list("VWXYZ"),
  615:         )
  616: 
  617:         tm.assert_frame_equal(result, expected)
  618: 
  619:     def test_fillna_columns(self):
  620:         arr = np.random.default_rng(2).standard_normal((10, 10))
  621:         arr[:, ::2] = np.nan
  622:         df = DataFrame(arr)
  623: 
  624:         msg = "DataFrame.fillna with 'method' is deprecated"
  625:         with tm.assert_produces_warning(FutureWarning, match=msg):
  626:             result = df.fillna(method="ffill", axis=1)
  627:         with tm.assert_produces_warning(FutureWarning, match=msg):
  628:             expected = df.T.fillna(method="pad").T
  629:         tm.assert_frame_equal(result, expected)
  630: 
  631:         df.insert(6, "foo", 5)
  632:         with tm.assert_produces_warning(FutureWarning, match=msg):
  633:             result = df.fillna(method="ffill", axis=1)
  634:         with tm.assert_produces_warning(FutureWarning, match=msg):
  635:             expected = df.astype(float).fillna(method="ffill", axis=1)
  636:         tm.assert_frame_equal(result, expected)
  637: 
  638:     def test_fillna_invalid_method(self, float_frame):
  639:         with pytest.raises(ValueError, match="ffil"):
  640:             float_frame.fillna(method="ffil")
  641: 
  642:     def test_fillna_invalid_value(self, float_frame):
  643:         # list
  644:         msg = '"value" parameter must be a scalar or dict, but you passed a "{}"'
  645:         with pytest.raises(TypeError, match=msg.format("list")):
  646:             float_frame.fillna([1, 2])
  647:         # tuple
  648:         with pytest.raises(TypeError, match=msg.format("tuple")):
  649:             float_frame.fillna((1, 2))
  650:         # frame with series
  651:         msg = (
  652:             '"value" parameter must be a scalar, dict or Series, but you '
  653:             'passed a "DataFrame"'
  654:         )
  655:         with pytest.raises(TypeError, match=msg):
  656:             float_frame.iloc[:, 0].fillna(float_frame)
  657: 
  658:     def test_fillna_col_reordering(self):
  659:         cols = ["COL." + str(i) for i in range(5, 0, -1)]
  660:         data = np.random.default_rng(2).random((20, 5))
  661:         df = DataFrame(index=range(20), columns=cols, data=data)
  662:         msg = "DataFrame.fillna with 'method' is deprecated"
  663:         with tm.assert_produces_warning(FutureWarning, match=msg):
  664:             filled = df.fillna(method="ffill")
  665:         assert df.columns.tolist() == filled.columns.tolist()
  666: 
  667:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="can't fill 0 in string")
  668:     def test_fill_corner(self, float_frame, float_string_frame):
  669:         mf = float_string_frame
  670:         mf.loc[mf.index[5:20], "foo"] = np.nan
  671:         mf.loc[mf.index[-10:], "A"] = np.nan
  672: 
  673:         filled = float_string_frame.fillna(value=0)
  674:         assert (filled.loc[filled.index[5:20], "foo"] == 0).all()
  675:         del float_string_frame["foo"]
  676: 
  677:         float_frame.reindex(columns=[]).fillna(value=0)
  678: 
  679:     def test_fillna_downcast_dict(self):
  680:         # GH#40809
  681:         df = DataFrame({"col1": [1, np.nan]})
  682: 
  683:         msg = "The 'downcast' keyword in fillna"
  684:         with tm.assert_produces_warning(FutureWarning, match=msg):
  685:             result = df.fillna({"col1": 2}, downcast={"col1": "int64"})
  686:         expected = DataFrame({"col1": [1, 2]})
  687:         tm.assert_frame_equal(result, expected)
  688: 
  689:     def test_fillna_with_columns_and_limit(self):
  690:         # GH40989
  691:         df = DataFrame(
  692:             [
  693:                 [np.nan, 2, np.nan, 0],
  694:                 [3, 4, np.nan, 1],
  695:                 [np.nan, np.nan, np.nan, 5],
  696:                 [np.nan, 3, np.nan, 4],
  697:             ],
  698:             columns=list("ABCD"),
  699:         )
  700:         result = df.fillna(axis=1, value=100, limit=1)
  701:         result2 = df.fillna(axis=1, value=100, limit=2)
  702: 
  703:         expected = DataFrame(
  704:             {
  705:                 "A": Series([100, 3, 100, 100], dtype="float64"),
  706:                 "B": [2, 4, np.nan, 3],
  707:                 "C": [np.nan, 100, np.nan, np.nan],
  708:                 "D": Series([0, 1, 5, 4], dtype="float64"),
  709:             },
  710:             index=[0, 1, 2, 3],
  711:         )
  712:         expected2 = DataFrame(
  713:             {
  714:                 "A": Series([100, 3, 100, 100], dtype="float64"),
  715:                 "B": Series([2, 4, 100, 3], dtype="float64"),
  716:                 "C": [100, 100, np.nan, 100],
  717:                 "D": Series([0, 1, 5, 4], dtype="float64"),
  718:             },
  719:             index=[0, 1, 2, 3],
  720:         )
  721: 
  722:         tm.assert_frame_equal(result, expected)
  723:         tm.assert_frame_equal(result2, expected2)
  724: 
  725:     def test_fillna_datetime_inplace(self):
  726:         # GH#48863
  727:         df = DataFrame(
  728:             {
  729:                 "date1": to_datetime(["2018-05-30", None]),
  730:                 "date2": to_datetime(["2018-09-30", None]),
  731:             }
  732:         )
  733:         expected = df.copy()
  734:         df.fillna(np.nan, inplace=True)
  735:         tm.assert_frame_equal(df, expected)
  736: 
  737:     def test_fillna_inplace_with_columns_limit_and_value(self):
  738:         # GH40989
  739:         df = DataFrame(
  740:             [
  741:                 [np.nan, 2, np.nan, 0],
  742:                 [3, 4, np.nan, 1],
  743:                 [np.nan, np.nan, np.nan, 5],
  744:                 [np.nan, 3, np.nan, 4],
  745:             ],
  746:             columns=list("ABCD"),
  747:         )
  748: 
  749:         expected = df.fillna(axis=1, value=100, limit=1)
  750:         assert expected is not df
  751: 
  752:         df.fillna(axis=1, value=100, limit=1, inplace=True)
  753:         tm.assert_frame_equal(df, expected)
  754: 
  755:     @td.skip_array_manager_invalid_test
  756:     @pytest.mark.parametrize("val", [-1, {"x": -1, "y": -1}])
  757:     def test_inplace_dict_update_view(
  758:         self, val, using_copy_on_write, warn_copy_on_write
  759:     ):
  760:         # GH#47188
  761:         df = DataFrame({"x": [np.nan, 2], "y": [np.nan, 2]})
  762:         df_orig = df.copy()
  763:         result_view = df[:]
  764:         with tm.assert_cow_warning(warn_copy_on_write):
  765:             df.fillna(val, inplace=True)
  766:         expected = DataFrame({"x": [-1, 2.0], "y": [-1.0, 2]})
  767:         tm.assert_frame_equal(df, expected)
  768:         if using_copy_on_write:
  769:             tm.assert_frame_equal(result_view, df_orig)
  770:         else:
  771:             tm.assert_frame_equal(result_view, expected)
  772: 
  773:     def test_single_block_df_with_horizontal_axis(self):
  774:         # GH 47713
  775:         df = DataFrame(
  776:             {
  777:                 "col1": [5, 0, np.nan, 10, np.nan],
  778:                 "col2": [7, np.nan, np.nan, 5, 3],
  779:                 "col3": [12, np.nan, 1, 2, 0],
  780:                 "col4": [np.nan, 1, 1, np.nan, 18],
  781:             }
  782:         )
  783:         result = df.fillna(50, limit=1, axis=1)
  784:         expected = DataFrame(
  785:             [
  786:                 [5.0, 7.0, 12.0, 50.0],
  787:                 [0.0, 50.0, np.nan, 1.0],
  788:                 [50.0, np.nan, 1.0, 1.0],
  789:                 [10.0, 5.0, 2.0, 50.0],
  790:                 [50.0, 3.0, 0.0, 18.0],
  791:             ],
  792:             columns=["col1", "col2", "col3", "col4"],
  793:         )
  794:         tm.assert_frame_equal(result, expected)
  795: 
  796:     def test_fillna_with_multi_index_frame(self):
  797:         # GH 47649
  798:         pdf = DataFrame(
  799:             {
  800:                 ("x", "a"): [np.nan, 2.0, 3.0],
  801:                 ("x", "b"): [1.0, 2.0, np.nan],
  802:                 ("y", "c"): [1.0, 2.0, np.nan],
  803:             }
  804:         )
  805:         expected = DataFrame(
  806:             {
  807:                 ("x", "a"): [-1.0, 2.0, 3.0],
  808:                 ("x", "b"): [1.0, 2.0, -1.0],
  809:                 ("y", "c"): [1.0, 2.0, np.nan],
  810:             }
  811:         )
  812:         tm.assert_frame_equal(pdf.fillna({"x": -1}), expected)
  813:         tm.assert_frame_equal(pdf.fillna({"x": -1, ("x", "b"): -2}), expected)
  814: 
  815:         expected = DataFrame(
  816:             {
  817:                 ("x", "a"): [-1.0, 2.0, 3.0],
  818:                 ("x", "b"): [1.0, 2.0, -2.0],
  819:                 ("y", "c"): [1.0, 2.0, np.nan],
  820:             }
  821:         )
  822:         tm.assert_frame_equal(pdf.fillna({("x", "b"): -2, "x": -1}), expected)
  823: 
  824: 
  825: def test_fillna_nonconsolidated_frame():
  826:     # https://github.com/pandas-dev/pandas/issues/36495
  827:     df = DataFrame(
  828:         [
  829:             [1, 1, 1, 1.0],
  830:             [2, 2, 2, 2.0],
  831:             [3, 3, 3, 3.0],
  832:         ],
  833:         columns=["i1", "i2", "i3", "f1"],
  834:     )
  835:     df_nonconsol = df.pivot(index="i1", columns="i2")
  836:     result = df_nonconsol.fillna(0)
  837:     assert result.isna().sum().sum() == 0
  838: 
  839: 
  840: def test_fillna_nones_inplace():
  841:     # GH 48480
  842:     df = DataFrame(
  843:         [[None, None], [None, None]],
  844:         columns=["A", "B"],
  845:     )
  846:     msg = "Downcasting object dtype arrays"
  847:     with tm.assert_produces_warning(FutureWarning, match=msg):
  848:         df.fillna(value={"A": 1, "B": 2}, inplace=True)
  849: 
  850:     expected = DataFrame([[1, 2], [1, 2]], columns=["A", "B"])
  851:     tm.assert_frame_equal(df, expected)
  852: 
  853: 
  854: @pytest.mark.parametrize("func", ["pad", "backfill"])
  855: def test_pad_backfill_deprecated(func):
  856:     # GH#33396
  857:     df = DataFrame({"a": [1, 2, 3]})
  858:     with tm.assert_produces_warning(FutureWarning):
  859:         getattr(df, func)()
  860: 
  861: 
  862: @pytest.mark.parametrize(
  863:     "data, expected_data, method, kwargs",
  864:     (
  865:         (
  866:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  867:             [np.nan, np.nan, 3.0, 3.0, 3.0, 3.0, 7.0, np.nan, np.nan],
  868:             "ffill",
  869:             {"limit_area": "inside"},
  870:         ),
  871:         (
  872:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  873:             [np.nan, np.nan, 3.0, 3.0, np.nan, np.nan, 7.0, np.nan, np.nan],
  874:             "ffill",
  875:             {"limit_area": "inside", "limit": 1},
  876:         ),
  877:         (
  878:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  879:             [np.nan, np.nan, 3.0, np.nan, np.nan, np.nan, 7.0, 7.0, 7.0],
  880:             "ffill",
  881:             {"limit_area": "outside"},
  882:         ),
  883:         (
  884:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  885:             [np.nan, np.nan, 3.0, np.nan, np.nan, np.nan, 7.0, 7.0, np.nan],
  886:             "ffill",
  887:             {"limit_area": "outside", "limit": 1},
  888:         ),
  889:         (
  890:             [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],
  891:             [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],
  892:             "ffill",
  893:             {"limit_area": "outside", "limit": 1},
  894:         ),
  895:         (
  896:             range(5),
  897:             range(5),
  898:             "ffill",
  899:             {"limit_area": "outside", "limit": 1},
  900:         ),
  901:         (
  902:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  903:             [np.nan, np.nan, 3.0, 7.0, 7.0, 7.0, 7.0, np.nan, np.nan],
  904:             "bfill",
  905:             {"limit_area": "inside"},
  906:         ),
  907:         (
  908:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  909:             [np.nan, np.nan, 3.0, np.nan, np.nan, 7.0, 7.0, np.nan, np.nan],
  910:             "bfill",
  911:             {"limit_area": "inside", "limit": 1},
  912:         ),
  913:         (
  914:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  915:             [3.0, 3.0, 3.0, np.nan, np.nan, np.nan, 7.0, np.nan, np.nan],
  916:             "bfill",
  917:             {"limit_area": "outside"},
  918:         ),
  919:         (
  920:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  921:             [np.nan, 3.0, 3.0, np.nan, np.nan, np.nan, 7.0, np.nan, np.nan],
  922:             "bfill",
  923:             {"limit_area": "outside", "limit": 1},
  924:         ),
  925:     ),
  926: )
  927: def test_ffill_bfill_limit_area(data, expected_data, method, kwargs):
  928:     # GH#56492
  929:     df = DataFrame(data)
  930:     expected = DataFrame(expected_data)
  931:     result = getattr(df, method)(**kwargs)
  932:     tm.assert_frame_equal(result, expected)
