    1: from copy import deepcopy
    2: import inspect
    3: import pydoc
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas._config import using_pyarrow_string_dtype
    9: from pandas._config.config import option_context
   10: 
   11: import pandas as pd
   12: from pandas import (
   13:     DataFrame,
   14:     Series,
   15:     date_range,
   16:     timedelta_range,
   17: )
   18: import pandas._testing as tm
   19: 
   20: 
   21: class TestDataFrameMisc:
   22:     def test_getitem_pop_assign_name(self, float_frame):
   23:         s = float_frame["A"]
   24:         assert s.name == "A"
   25: 
   26:         s = float_frame.pop("A")
   27:         assert s.name == "A"
   28: 
   29:         s = float_frame.loc[:, "B"]
   30:         assert s.name == "B"
   31: 
   32:         s2 = s.loc[:]
   33:         assert s2.name == "B"
   34: 
   35:     def test_get_axis(self, float_frame):
   36:         f = float_frame
   37:         assert f._get_axis_number(0) == 0
   38:         assert f._get_axis_number(1) == 1
   39:         assert f._get_axis_number("index") == 0
   40:         assert f._get_axis_number("rows") == 0
   41:         assert f._get_axis_number("columns") == 1
   42: 
   43:         assert f._get_axis_name(0) == "index"
   44:         assert f._get_axis_name(1) == "columns"
   45:         assert f._get_axis_name("index") == "index"
   46:         assert f._get_axis_name("rows") == "index"
   47:         assert f._get_axis_name("columns") == "columns"
   48: 
   49:         assert f._get_axis(0) is f.index
   50:         assert f._get_axis(1) is f.columns
   51: 
   52:         with pytest.raises(ValueError, match="No axis named"):
   53:             f._get_axis_number(2)
   54: 
   55:         with pytest.raises(ValueError, match="No axis.*foo"):
   56:             f._get_axis_name("foo")
   57: 
   58:         with pytest.raises(ValueError, match="No axis.*None"):
   59:             f._get_axis_name(None)
   60: 
   61:         with pytest.raises(ValueError, match="No axis named"):
   62:             f._get_axis_number(None)
   63: 
   64:     def test_column_contains_raises(self, float_frame):
   65:         with pytest.raises(TypeError, match="unhashable type: 'Index'"):
   66:             float_frame.columns in float_frame
   67: 
   68:     def test_tab_completion(self):
   69:         # DataFrame whose columns are identifiers shall have them in __dir__.
   70:         df = DataFrame([list("abcd"), list("efgh")], columns=list("ABCD"))
   71:         for key in list("ABCD"):
   72:             assert key in dir(df)
   73:         assert isinstance(df.__getitem__("A"), Series)
   74: 
   75:         # DataFrame whose first-level columns are identifiers shall have
   76:         # them in __dir__.
   77:         df = DataFrame(
   78:             [list("abcd"), list("efgh")],
   79:             columns=pd.MultiIndex.from_tuples(list(zip("ABCD", "EFGH"))),
   80:         )
   81:         for key in list("ABCD"):
   82:             assert key in dir(df)
   83:         for key in list("EFGH"):
   84:             assert key not in dir(df)
   85:         assert isinstance(df.__getitem__("A"), DataFrame)
   86: 
   87:     def test_display_max_dir_items(self):
   88:         # display.max_dir_items increaes the number of columns that are in __dir__.
   89:         columns = ["a" + str(i) for i in range(420)]
   90:         values = [range(420), range(420)]
   91:         df = DataFrame(values, columns=columns)
   92: 
   93:         # The default value for display.max_dir_items is 100
   94:         assert "a99" in dir(df)
   95:         assert "a100" not in dir(df)
   96: 
   97:         with option_context("display.max_dir_items", 300):
   98:             df = DataFrame(values, columns=columns)
   99:             assert "a299" in dir(df)
  100:             assert "a300" not in dir(df)
  101: 
  102:         with option_context("display.max_dir_items", None):
  103:             df = DataFrame(values, columns=columns)
  104:             assert "a419" in dir(df)
  105: 
  106:     def test_not_hashable(self):
  107:         empty_frame = DataFrame()
  108: 
  109:         df = DataFrame([1])
  110:         msg = "unhashable type: 'DataFrame'"
  111:         with pytest.raises(TypeError, match=msg):
  112:             hash(df)
  113:         with pytest.raises(TypeError, match=msg):
  114:             hash(empty_frame)
  115: 
  116:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="surrogates not allowed")
  117:     def test_column_name_contains_unicode_surrogate(self):
  118:         # GH 25509
  119:         colname = "\ud83d"
  120:         df = DataFrame({colname: []})
  121:         # this should not crash
  122:         assert colname not in dir(df)
  123:         assert df.columns[0] == colname
  124: 
  125:     def test_new_empty_index(self):
  126:         df1 = DataFrame(np.random.default_rng(2).standard_normal((0, 3)))
  127:         df2 = DataFrame(np.random.default_rng(2).standard_normal((0, 3)))
  128:         df1.index.name = "foo"
  129:         assert df2.index.name is None
  130: 
  131:     def test_get_agg_axis(self, float_frame):
  132:         cols = float_frame._get_agg_axis(0)
  133:         assert cols is float_frame.columns
  134: 
  135:         idx = float_frame._get_agg_axis(1)
  136:         assert idx is float_frame.index
  137: 
  138:         msg = r"Axis must be 0 or 1 \(got 2\)"
  139:         with pytest.raises(ValueError, match=msg):
  140:             float_frame._get_agg_axis(2)
  141: 
  142:     def test_empty(self, float_frame, float_string_frame):
  143:         empty_frame = DataFrame()
  144:         assert empty_frame.empty
  145: 
  146:         assert not float_frame.empty
  147:         assert not float_string_frame.empty
  148: 
  149:         # corner case
  150:         df = DataFrame({"A": [1.0, 2.0, 3.0], "B": ["a", "b", "c"]}, index=np.arange(3))
  151:         del df["A"]
  152:         assert not df.empty
  153: 
  154:     def test_len(self, float_frame):
  155:         assert len(float_frame) == len(float_frame.index)
  156: 
  157:         # single block corner case
  158:         arr = float_frame[["A", "B"]].values
  159:         expected = float_frame.reindex(columns=["A", "B"]).values
  160:         tm.assert_almost_equal(arr, expected)
  161: 
  162:     def test_axis_aliases(self, float_frame):
  163:         f = float_frame
  164: 
  165:         # reg name
  166:         expected = f.sum(axis=0)
  167:         result = f.sum(axis="index")
  168:         tm.assert_series_equal(result, expected)
  169: 
  170:         expected = f.sum(axis=1)
  171:         result = f.sum(axis="columns")
  172:         tm.assert_series_equal(result, expected)
  173: 
  174:     def test_class_axis(self):
  175:         # GH 18147
  176:         # no exception and no empty docstring
  177:         assert pydoc.getdoc(DataFrame.index)
  178:         assert pydoc.getdoc(DataFrame.columns)
  179: 
  180:     def test_series_put_names(self, float_string_frame):
  181:         series = float_string_frame._series
  182:         for k, v in series.items():
  183:             assert v.name == k
  184: 
  185:     def test_empty_nonzero(self):
  186:         df = DataFrame([1, 2, 3])
  187:         assert not df.empty
  188:         df = DataFrame(index=[1], columns=[1])
  189:         assert not df.empty
  190:         df = DataFrame(index=["a", "b"], columns=["c", "d"]).dropna()
  191:         assert df.empty
  192:         assert df.T.empty
  193: 
  194:     @pytest.mark.parametrize(
  195:         "df",
  196:         [
  197:             DataFrame(),
  198:             DataFrame(index=[1]),
  199:             DataFrame(columns=[1]),
  200:             DataFrame({1: []}),
  201:         ],
  202:     )
  203:     def test_empty_like(self, df):
  204:         assert df.empty
  205:         assert df.T.empty
  206: 
  207:     def test_with_datetimelikes(self):
  208:         df = DataFrame(
  209:             {
  210:                 "A": date_range("20130101", periods=10),
  211:                 "B": timedelta_range("1 day", periods=10),
  212:             }
  213:         )
  214:         t = df.T
  215: 
  216:         result = t.dtypes.value_counts()
  217:         expected = Series({np.dtype("object"): 10}, name="count")
  218:         tm.assert_series_equal(result, expected)
  219: 
  220:     def test_deepcopy(self, float_frame):
  221:         cp = deepcopy(float_frame)
  222:         cp.loc[0, "A"] = 10
  223:         assert not float_frame.equals(cp)
  224: 
  225:     def test_inplace_return_self(self):
  226:         # GH 1893
  227: 
  228:         data = DataFrame(
  229:             {"a": ["foo", "bar", "baz", "qux"], "b": [0, 0, 1, 1], "c": [1, 2, 3, 4]}
  230:         )
  231: 
  232:         def _check_f(base, f):
  233:             result = f(base)
  234:             assert result is None
  235: 
  236:         # -----DataFrame-----
  237: 
  238:         # set_index
  239:         f = lambda x: x.set_index("a", inplace=True)
  240:         _check_f(data.copy(), f)
  241: 
  242:         # reset_index
  243:         f = lambda x: x.reset_index(inplace=True)
  244:         _check_f(data.set_index("a"), f)
  245: 
  246:         # drop_duplicates
  247:         f = lambda x: x.drop_duplicates(inplace=True)
  248:         _check_f(data.copy(), f)
  249: 
  250:         # sort
  251:         f = lambda x: x.sort_values("b", inplace=True)
  252:         _check_f(data.copy(), f)
  253: 
  254:         # sort_index
  255:         f = lambda x: x.sort_index(inplace=True)
  256:         _check_f(data.copy(), f)
  257: 
  258:         # fillna
  259:         f = lambda x: x.fillna(0, inplace=True)
  260:         _check_f(data.copy(), f)
  261: 
  262:         # replace
  263:         f = lambda x: x.replace(1, 0, inplace=True)
  264:         _check_f(data.copy(), f)
  265: 
  266:         # rename
  267:         f = lambda x: x.rename({1: "foo"}, inplace=True)
  268:         _check_f(data.copy(), f)
  269: 
  270:         # -----Series-----
  271:         d = data.copy()["c"]
  272: 
  273:         # reset_index
  274:         f = lambda x: x.reset_index(inplace=True, drop=True)
  275:         _check_f(data.set_index("a")["c"], f)
  276: 
  277:         # fillna
  278:         f = lambda x: x.fillna(0, inplace=True)
  279:         _check_f(d.copy(), f)
  280: 
  281:         # replace
  282:         f = lambda x: x.replace(1, 0, inplace=True)
  283:         _check_f(d.copy(), f)
  284: 
  285:         # rename
  286:         f = lambda x: x.rename({1: "foo"}, inplace=True)
  287:         _check_f(d.copy(), f)
  288: 
  289:     def test_tab_complete_warning(self, ip, frame_or_series):
  290:         # GH 16409
  291:         pytest.importorskip("IPython", minversion="6.0.0")
  292:         from IPython.core.completer import provisionalcompleter
  293: 
  294:         if frame_or_series is DataFrame:
  295:             code = "from pandas import DataFrame; obj = DataFrame()"
  296:         else:
  297:             code = "from pandas import Series; obj = Series(dtype=object)"
  298: 
  299:         ip.run_cell(code)
  300:         # GH 31324 newer jedi version raises Deprecation warning;
  301:         #  appears resolved 2021-02-02
  302:         with tm.assert_produces_warning(None, raise_on_extra_warnings=False):
  303:             with provisionalcompleter("ignore"):
  304:                 list(ip.Completer.completions("obj.", 1))
  305: 
  306:     def test_attrs(self):
  307:         df = DataFrame({"A": [2, 3]})
  308:         assert df.attrs == {}
  309:         df.attrs["version"] = 1
  310: 
  311:         result = df.rename(columns=str)
  312:         assert result.attrs == {"version": 1}
  313: 
  314:     def test_attrs_deepcopy(self):
  315:         df = DataFrame({"A": [2, 3]})
  316:         assert df.attrs == {}
  317:         df.attrs["tags"] = {"spam", "ham"}
  318: 
  319:         result = df.rename(columns=str)
  320:         assert result.attrs == df.attrs
  321:         assert result.attrs["tags"] is not df.attrs["tags"]
  322: 
  323:     @pytest.mark.parametrize("allows_duplicate_labels", [True, False, None])
  324:     def test_set_flags(
  325:         self,
  326:         allows_duplicate_labels,
  327:         frame_or_series,
  328:         using_copy_on_write,
  329:         warn_copy_on_write,
  330:     ):
  331:         obj = DataFrame({"A": [1, 2]})
  332:         key = (0, 0)
  333:         if frame_or_series is Series:
  334:             obj = obj["A"]
  335:             key = 0
  336: 
  337:         result = obj.set_flags(allows_duplicate_labels=allows_duplicate_labels)
  338: 
  339:         if allows_duplicate_labels is None:
  340:             # We don't update when it's not provided
  341:             assert result.flags.allows_duplicate_labels is True
  342:         else:
  343:             assert result.flags.allows_duplicate_labels is allows_duplicate_labels
  344: 
  345:         # We made a copy
  346:         assert obj is not result
  347: 
  348:         # We didn't mutate obj
  349:         assert obj.flags.allows_duplicate_labels is True
  350: 
  351:         # But we didn't copy data
  352:         if frame_or_series is Series:
  353:             assert np.may_share_memory(obj.values, result.values)
  354:         else:
  355:             assert np.may_share_memory(obj["A"].values, result["A"].values)
  356: 
  357:         with tm.assert_cow_warning(warn_copy_on_write):
  358:             result.iloc[key] = 0
  359:         if using_copy_on_write:
  360:             assert obj.iloc[key] == 1
  361:         else:
  362:             assert obj.iloc[key] == 0
  363:             # set back to 1 for test below
  364:             with tm.assert_cow_warning(warn_copy_on_write):
  365:                 result.iloc[key] = 1
  366: 
  367:         # Now we do copy.
  368:         result = obj.set_flags(
  369:             copy=True, allows_duplicate_labels=allows_duplicate_labels
  370:         )
  371:         result.iloc[key] = 10
  372:         assert obj.iloc[key] == 1
  373: 
  374:     def test_constructor_expanddim(self):
  375:         # GH#33628 accessing _constructor_expanddim should not raise NotImplementedError
  376:         # GH38782 pandas has no container higher than DataFrame (two-dim), so
  377:         # DataFrame._constructor_expand_dim, doesn't make sense, so is removed.
  378:         df = DataFrame()
  379: 
  380:         msg = "'DataFrame' object has no attribute '_constructor_expanddim'"
  381:         with pytest.raises(AttributeError, match=msg):
  382:             df._constructor_expanddim(np.arange(27).reshape(3, 3, 3))
  383: 
  384:     def test_inspect_getmembers(self):
  385:         # GH38740
  386:         pytest.importorskip("jinja2")
  387:         df = DataFrame()
  388:         msg = "DataFrame._data is deprecated"
  389:         with tm.assert_produces_warning(
  390:             DeprecationWarning, match=msg, check_stacklevel=False
  391:         ):
  392:             inspect.getmembers(df)
