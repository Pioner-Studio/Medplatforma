    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas._libs.algos import (
   10:     Infinity,
   11:     NegInfinity,
   12: )
   13: 
   14: from pandas import (
   15:     DataFrame,
   16:     Index,
   17:     Series,
   18: )
   19: import pandas._testing as tm
   20: 
   21: 
   22: class TestRank:
   23:     s = Series([1, 3, 4, 2, np.nan, 2, 1, 5, np.nan, 3])
   24:     df = DataFrame({"A": s, "B": s})
   25: 
   26:     results = {
   27:         "average": np.array([1.5, 5.5, 7.0, 3.5, np.nan, 3.5, 1.5, 8.0, np.nan, 5.5]),
   28:         "min": np.array([1, 5, 7, 3, np.nan, 3, 1, 8, np.nan, 5]),
   29:         "max": np.array([2, 6, 7, 4, np.nan, 4, 2, 8, np.nan, 6]),
   30:         "first": np.array([1, 5, 7, 3, np.nan, 4, 2, 8, np.nan, 6]),
   31:         "dense": np.array([1, 3, 4, 2, np.nan, 2, 1, 5, np.nan, 3]),
   32:     }
   33: 
   34:     @pytest.fixture(params=["average", "min", "max", "first", "dense"])
   35:     def method(self, request):
   36:         """
   37:         Fixture for trying all rank methods
   38:         """
   39:         return request.param
   40: 
   41:     def test_rank(self, float_frame):
   42:         sp_stats = pytest.importorskip("scipy.stats")
   43: 
   44:         float_frame.loc[::2, "A"] = np.nan
   45:         float_frame.loc[::3, "B"] = np.nan
   46:         float_frame.loc[::4, "C"] = np.nan
   47:         float_frame.loc[::5, "D"] = np.nan
   48: 
   49:         ranks0 = float_frame.rank()
   50:         ranks1 = float_frame.rank(1)
   51:         mask = np.isnan(float_frame.values)
   52: 
   53:         fvals = float_frame.fillna(np.inf).values
   54: 
   55:         exp0 = np.apply_along_axis(sp_stats.rankdata, 0, fvals)
   56:         exp0[mask] = np.nan
   57: 
   58:         exp1 = np.apply_along_axis(sp_stats.rankdata, 1, fvals)
   59:         exp1[mask] = np.nan
   60: 
   61:         tm.assert_almost_equal(ranks0.values, exp0)
   62:         tm.assert_almost_equal(ranks1.values, exp1)
   63: 
   64:         # integers
   65:         df = DataFrame(
   66:             np.random.default_rng(2).integers(0, 5, size=40).reshape((10, 4))
   67:         )
   68: 
   69:         result = df.rank()
   70:         exp = df.astype(float).rank()
   71:         tm.assert_frame_equal(result, exp)
   72: 
   73:         result = df.rank(1)
   74:         exp = df.astype(float).rank(1)
   75:         tm.assert_frame_equal(result, exp)
   76: 
   77:     def test_rank2(self):
   78:         df = DataFrame([[1, 3, 2], [1, 2, 3]])
   79:         expected = DataFrame([[1.0, 3.0, 2.0], [1, 2, 3]]) / 3.0
   80:         result = df.rank(1, pct=True)
   81:         tm.assert_frame_equal(result, expected)
   82: 
   83:         df = DataFrame([[1, 3, 2], [1, 2, 3]])
   84:         expected = df.rank(0) / 2.0
   85:         result = df.rank(0, pct=True)
   86:         tm.assert_frame_equal(result, expected)
   87: 
   88:         df = DataFrame([["b", "c", "a"], ["a", "c", "b"]])
   89:         expected = DataFrame([[2.0, 3.0, 1.0], [1, 3, 2]])
   90:         result = df.rank(1, numeric_only=False)
   91:         tm.assert_frame_equal(result, expected)
   92: 
   93:         expected = DataFrame([[2.0, 1.5, 1.0], [1, 1.5, 2]])
   94:         result = df.rank(0, numeric_only=False)
   95:         tm.assert_frame_equal(result, expected)
   96: 
   97:         df = DataFrame([["b", np.nan, "a"], ["a", "c", "b"]])
   98:         expected = DataFrame([[2.0, np.nan, 1.0], [1.0, 3.0, 2.0]])
   99:         result = df.rank(1, numeric_only=False)
  100:         tm.assert_frame_equal(result, expected)
  101: 
  102:         expected = DataFrame([[2.0, np.nan, 1.0], [1.0, 1.0, 2.0]])
  103:         result = df.rank(0, numeric_only=False)
  104:         tm.assert_frame_equal(result, expected)
  105: 
  106:         # f7u12, this does not work without extensive workaround
  107:         data = [
  108:             [datetime(2001, 1, 5), np.nan, datetime(2001, 1, 2)],
  109:             [datetime(2000, 1, 2), datetime(2000, 1, 3), datetime(2000, 1, 1)],
  110:         ]
  111:         df = DataFrame(data)
  112: 
  113:         # check the rank
  114:         expected = DataFrame([[2.0, np.nan, 1.0], [2.0, 3.0, 1.0]])
  115:         result = df.rank(1, numeric_only=False, ascending=True)
  116:         tm.assert_frame_equal(result, expected)
  117: 
  118:         expected = DataFrame([[1.0, np.nan, 2.0], [2.0, 1.0, 3.0]])
  119:         result = df.rank(1, numeric_only=False, ascending=False)
  120:         tm.assert_frame_equal(result, expected)
  121: 
  122:         df = DataFrame({"a": [1e-20, -5, 1e-20 + 1e-40, 10, 1e60, 1e80, 1e-30]})
  123:         exp = DataFrame({"a": [3.5, 1.0, 3.5, 5.0, 6.0, 7.0, 2.0]})
  124:         tm.assert_frame_equal(df.rank(), exp)
  125: 
  126:     def test_rank_does_not_mutate(self):
  127:         # GH#18521
  128:         # Check rank does not mutate DataFrame
  129:         df = DataFrame(
  130:             np.random.default_rng(2).standard_normal((10, 3)), dtype="float64"
  131:         )
  132:         expected = df.copy()
  133:         df.rank()
  134:         result = df
  135:         tm.assert_frame_equal(result, expected)
  136: 
  137:     def test_rank_mixed_frame(self, float_string_frame):
  138:         float_string_frame["datetime"] = datetime.now()
  139:         float_string_frame["timedelta"] = timedelta(days=1, seconds=1)
  140: 
  141:         float_string_frame.rank(numeric_only=False)
  142:         with pytest.raises(TypeError, match="not supported between instances of"):
  143:             float_string_frame.rank(axis=1)
  144: 
  145:     def test_rank_na_option(self, float_frame):
  146:         sp_stats = pytest.importorskip("scipy.stats")
  147: 
  148:         float_frame.loc[::2, "A"] = np.nan
  149:         float_frame.loc[::3, "B"] = np.nan
  150:         float_frame.loc[::4, "C"] = np.nan
  151:         float_frame.loc[::5, "D"] = np.nan
  152: 
  153:         # bottom
  154:         ranks0 = float_frame.rank(na_option="bottom")
  155:         ranks1 = float_frame.rank(1, na_option="bottom")
  156: 
  157:         fvals = float_frame.fillna(np.inf).values
  158: 
  159:         exp0 = np.apply_along_axis(sp_stats.rankdata, 0, fvals)
  160:         exp1 = np.apply_along_axis(sp_stats.rankdata, 1, fvals)
  161: 
  162:         tm.assert_almost_equal(ranks0.values, exp0)
  163:         tm.assert_almost_equal(ranks1.values, exp1)
  164: 
  165:         # top
  166:         ranks0 = float_frame.rank(na_option="top")
  167:         ranks1 = float_frame.rank(1, na_option="top")
  168: 
  169:         fval0 = float_frame.fillna((float_frame.min() - 1).to_dict()).values
  170:         fval1 = float_frame.T
  171:         fval1 = fval1.fillna((fval1.min() - 1).to_dict()).T
  172:         fval1 = fval1.fillna(np.inf).values
  173: 
  174:         exp0 = np.apply_along_axis(sp_stats.rankdata, 0, fval0)
  175:         exp1 = np.apply_along_axis(sp_stats.rankdata, 1, fval1)
  176: 
  177:         tm.assert_almost_equal(ranks0.values, exp0)
  178:         tm.assert_almost_equal(ranks1.values, exp1)
  179: 
  180:         # descending
  181: 
  182:         # bottom
  183:         ranks0 = float_frame.rank(na_option="top", ascending=False)
  184:         ranks1 = float_frame.rank(1, na_option="top", ascending=False)
  185: 
  186:         fvals = float_frame.fillna(np.inf).values
  187: 
  188:         exp0 = np.apply_along_axis(sp_stats.rankdata, 0, -fvals)
  189:         exp1 = np.apply_along_axis(sp_stats.rankdata, 1, -fvals)
  190: 
  191:         tm.assert_almost_equal(ranks0.values, exp0)
  192:         tm.assert_almost_equal(ranks1.values, exp1)
  193: 
  194:         # descending
  195: 
  196:         # top
  197:         ranks0 = float_frame.rank(na_option="bottom", ascending=False)
  198:         ranks1 = float_frame.rank(1, na_option="bottom", ascending=False)
  199: 
  200:         fval0 = float_frame.fillna((float_frame.min() - 1).to_dict()).values
  201:         fval1 = float_frame.T
  202:         fval1 = fval1.fillna((fval1.min() - 1).to_dict()).T
  203:         fval1 = fval1.fillna(np.inf).values
  204: 
  205:         exp0 = np.apply_along_axis(sp_stats.rankdata, 0, -fval0)
  206:         exp1 = np.apply_along_axis(sp_stats.rankdata, 1, -fval1)
  207: 
  208:         tm.assert_numpy_array_equal(ranks0.values, exp0)
  209:         tm.assert_numpy_array_equal(ranks1.values, exp1)
  210: 
  211:         # bad values throw error
  212:         msg = "na_option must be one of 'keep', 'top', or 'bottom'"
  213: 
  214:         with pytest.raises(ValueError, match=msg):
  215:             float_frame.rank(na_option="bad", ascending=False)
  216: 
  217:         # invalid type
  218:         with pytest.raises(ValueError, match=msg):
  219:             float_frame.rank(na_option=True, ascending=False)
  220: 
  221:     def test_rank_axis(self):
  222:         # check if using axes' names gives the same result
  223:         df = DataFrame([[2, 1], [4, 3]])
  224:         tm.assert_frame_equal(df.rank(axis=0), df.rank(axis="index"))
  225:         tm.assert_frame_equal(df.rank(axis=1), df.rank(axis="columns"))
  226: 
  227:     @pytest.mark.parametrize("ax", [0, 1])
  228:     @pytest.mark.parametrize("m", ["average", "min", "max", "first", "dense"])
  229:     def test_rank_methods_frame(self, ax, m):
  230:         sp_stats = pytest.importorskip("scipy.stats")
  231: 
  232:         xs = np.random.default_rng(2).integers(0, 21, (100, 26))
  233:         xs = (xs - 10.0) / 10.0
  234:         cols = [chr(ord("z") - i) for i in range(xs.shape[1])]
  235: 
  236:         for vals in [xs, xs + 1e6, xs * 1e-6]:
  237:             df = DataFrame(vals, columns=cols)
  238: 
  239:             result = df.rank(axis=ax, method=m)
  240:             sprank = np.apply_along_axis(
  241:                 sp_stats.rankdata, ax, vals, m if m != "first" else "ordinal"
  242:             )
  243:             sprank = sprank.astype(np.float64)
  244:             expected = DataFrame(sprank, columns=cols).astype("float64")
  245:             tm.assert_frame_equal(result, expected)
  246: 
  247:     @pytest.mark.parametrize("dtype", ["O", "f8", "i8"])
  248:     def test_rank_descending(self, method, dtype):
  249:         if "i" in dtype:
  250:             df = self.df.dropna().astype(dtype)
  251:         else:
  252:             df = self.df.astype(dtype)
  253: 
  254:         res = df.rank(ascending=False)
  255:         expected = (df.max() - df).rank()
  256:         tm.assert_frame_equal(res, expected)
  257: 
  258:         expected = (df.max() - df).rank(method=method)
  259: 
  260:         if dtype != "O":
  261:             res2 = df.rank(method=method, ascending=False, numeric_only=True)
  262:             tm.assert_frame_equal(res2, expected)
  263: 
  264:         res3 = df.rank(method=method, ascending=False, numeric_only=False)
  265:         tm.assert_frame_equal(res3, expected)
  266: 
  267:     @pytest.mark.parametrize("axis", [0, 1])
  268:     @pytest.mark.parametrize("dtype", [None, object])
  269:     def test_rank_2d_tie_methods(self, method, axis, dtype):
  270:         df = self.df
  271: 
  272:         def _check2d(df, expected, method="average", axis=0):
  273:             exp_df = DataFrame({"A": expected, "B": expected})
  274: 
  275:             if axis == 1:
  276:                 df = df.T
  277:                 exp_df = exp_df.T
  278: 
  279:             result = df.rank(method=method, axis=axis)
  280:             tm.assert_frame_equal(result, exp_df)
  281: 
  282:         frame = df if dtype is None else df.astype(dtype)
  283:         _check2d(frame, self.results[method], method=method, axis=axis)
  284: 
  285:     @pytest.mark.parametrize(
  286:         "method,exp",
  287:         [
  288:             ("dense", [[1.0, 1.0, 1.0], [1.0, 0.5, 2.0 / 3], [1.0, 0.5, 1.0 / 3]]),
  289:             (
  290:                 "min",
  291:                 [
  292:                     [1.0 / 3, 1.0, 1.0],
  293:                     [1.0 / 3, 1.0 / 3, 2.0 / 3],
  294:                     [1.0 / 3, 1.0 / 3, 1.0 / 3],
  295:                 ],
  296:             ),
  297:             (
  298:                 "max",
  299:                 [[1.0, 1.0, 1.0], [1.0, 2.0 / 3, 2.0 / 3], [1.0, 2.0 / 3, 1.0 / 3]],
  300:             ),
  301:             (
  302:                 "average",
  303:                 [[2.0 / 3, 1.0, 1.0], [2.0 / 3, 0.5, 2.0 / 3], [2.0 / 3, 0.5, 1.0 / 3]],
  304:             ),
  305:             (
  306:                 "first",
  307:                 [
  308:                     [1.0 / 3, 1.0, 1.0],
  309:                     [2.0 / 3, 1.0 / 3, 2.0 / 3],
  310:                     [3.0 / 3, 2.0 / 3, 1.0 / 3],
  311:                 ],
  312:             ),
  313:         ],
  314:     )
  315:     def test_rank_pct_true(self, method, exp):
  316:         # see gh-15630.
  317: 
  318:         df = DataFrame([[2012, 66, 3], [2012, 65, 2], [2012, 65, 1]])
  319:         result = df.rank(method=method, pct=True)
  320: 
  321:         expected = DataFrame(exp)
  322:         tm.assert_frame_equal(result, expected)
  323: 
  324:     @pytest.mark.single_cpu
  325:     def test_pct_max_many_rows(self):
  326:         # GH 18271
  327:         df = DataFrame(
  328:             {"A": np.arange(2**24 + 1), "B": np.arange(2**24 + 1, 0, -1)}
  329:         )
  330:         result = df.rank(pct=True).max()
  331:         assert (result == 1).all()
  332: 
  333:     @pytest.mark.parametrize(
  334:         "contents,dtype",
  335:         [
  336:             (
  337:                 [
  338:                     -np.inf,
  339:                     -50,
  340:                     -1,
  341:                     -1e-20,
  342:                     -1e-25,
  343:                     -1e-50,
  344:                     0,
  345:                     1e-40,
  346:                     1e-20,
  347:                     1e-10,
  348:                     2,
  349:                     40,
  350:                     np.inf,
  351:                 ],
  352:                 "float64",
  353:             ),
  354:             (
  355:                 [
  356:                     -np.inf,
  357:                     -50,
  358:                     -1,
  359:                     -1e-20,
  360:                     -1e-25,
  361:                     -1e-45,
  362:                     0,
  363:                     1e-40,
  364:                     1e-20,
  365:                     1e-10,
  366:                     2,
  367:                     40,
  368:                     np.inf,
  369:                 ],
  370:                 "float32",
  371:             ),
  372:             ([np.iinfo(np.uint8).min, 1, 2, 100, np.iinfo(np.uint8).max], "uint8"),
  373:             (
  374:                 [
  375:                     np.iinfo(np.int64).min,
  376:                     -100,
  377:                     0,
  378:                     1,
  379:                     9999,
  380:                     100000,
  381:                     1e10,
  382:                     np.iinfo(np.int64).max,
  383:                 ],
  384:                 "int64",
  385:             ),
  386:             ([NegInfinity(), "1", "A", "BA", "Ba", "C", Infinity()], "object"),
  387:             (
  388:                 [datetime(2001, 1, 1), datetime(2001, 1, 2), datetime(2001, 1, 5)],
  389:                 "datetime64",
  390:             ),
  391:         ],
  392:     )
  393:     def test_rank_inf_and_nan(self, contents, dtype, frame_or_series):
  394:         dtype_na_map = {
  395:             "float64": np.nan,
  396:             "float32": np.nan,
  397:             "object": None,
  398:             "datetime64": np.datetime64("nat"),
  399:         }
  400:         # Insert nans at random positions if underlying dtype has missing
  401:         # value. Then adjust the expected order by adding nans accordingly
  402:         # This is for testing whether rank calculation is affected
  403:         # when values are interwined with nan values.
  404:         values = np.array(contents, dtype=dtype)
  405:         exp_order = np.array(range(len(values)), dtype="float64") + 1.0
  406:         if dtype in dtype_na_map:
  407:             na_value = dtype_na_map[dtype]
  408:             nan_indices = np.random.default_rng(2).choice(range(len(values)), 5)
  409:             values = np.insert(values, nan_indices, na_value)
  410:             exp_order = np.insert(exp_order, nan_indices, np.nan)
  411: 
  412:         # Shuffle the testing array and expected results in the same way
  413:         random_order = np.random.default_rng(2).permutation(len(values))
  414:         obj = frame_or_series(values[random_order])
  415:         expected = frame_or_series(exp_order[random_order], dtype="float64")
  416:         result = obj.rank()
  417:         tm.assert_equal(result, expected)
  418: 
  419:     def test_df_series_inf_nan_consistency(self):
  420:         # GH#32593
  421:         index = [5, 4, 3, 2, 1, 6, 7, 8, 9, 10]
  422:         col1 = [5, 4, 3, 5, 8, 5, 2, 1, 6, 6]
  423:         col2 = [5, 4, np.nan, 5, 8, 5, np.inf, np.nan, 6, -np.inf]
  424:         df = DataFrame(
  425:             data={
  426:                 "col1": col1,
  427:                 "col2": col2,
  428:             },
  429:             index=index,
  430:             dtype="f8",
  431:         )
  432:         df_result = df.rank()
  433: 
  434:         series_result = df.copy()
  435:         series_result["col1"] = df["col1"].rank()
  436:         series_result["col2"] = df["col2"].rank()
  437: 
  438:         tm.assert_frame_equal(df_result, series_result)
  439: 
  440:     def test_rank_both_inf(self):
  441:         # GH#32593
  442:         df = DataFrame({"a": [-np.inf, 0, np.inf]})
  443:         expected = DataFrame({"a": [1.0, 2.0, 3.0]})
  444:         result = df.rank()
  445:         tm.assert_frame_equal(result, expected)
  446: 
  447:     @pytest.mark.parametrize(
  448:         "na_option,ascending,expected",
  449:         [
  450:             ("top", True, [3.0, 1.0, 2.0]),
  451:             ("top", False, [2.0, 1.0, 3.0]),
  452:             ("bottom", True, [2.0, 3.0, 1.0]),
  453:             ("bottom", False, [1.0, 3.0, 2.0]),
  454:         ],
  455:     )
  456:     def test_rank_inf_nans_na_option(
  457:         self, frame_or_series, method, na_option, ascending, expected
  458:     ):
  459:         obj = frame_or_series([np.inf, np.nan, -np.inf])
  460:         result = obj.rank(method=method, na_option=na_option, ascending=ascending)
  461:         expected = frame_or_series(expected)
  462:         tm.assert_equal(result, expected)
  463: 
  464:     @pytest.mark.parametrize(
  465:         "na_option,ascending,expected",
  466:         [
  467:             ("bottom", True, [1.0, 2.0, 4.0, 3.0]),
  468:             ("bottom", False, [1.0, 2.0, 4.0, 3.0]),
  469:             ("top", True, [2.0, 3.0, 1.0, 4.0]),
  470:             ("top", False, [2.0, 3.0, 1.0, 4.0]),
  471:         ],
  472:     )
  473:     def test_rank_object_first(
  474:         self, frame_or_series, na_option, ascending, expected, using_infer_string
  475:     ):
  476:         obj = frame_or_series(["foo", "foo", None, "foo"])
  477:         result = obj.rank(method="first", na_option=na_option, ascending=ascending)
  478:         expected = frame_or_series(expected)
  479:         if using_infer_string and isinstance(obj, Series):
  480:             expected = expected.astype("uint64")
  481:         tm.assert_equal(result, expected)
  482: 
  483:     @pytest.mark.parametrize(
  484:         "data,expected",
  485:         [
  486:             (
  487:                 {"a": [1, 2, "a"], "b": [4, 5, 6]},
  488:                 DataFrame({"b": [1.0, 2.0, 3.0]}, columns=Index(["b"], dtype=object)),
  489:             ),
  490:             ({"a": [1, 2, "a"]}, DataFrame(index=range(3), columns=[])),
  491:         ],
  492:     )
  493:     def test_rank_mixed_axis_zero(self, data, expected):
  494:         df = DataFrame(data, columns=Index(list(data.keys()), dtype=object))
  495:         with pytest.raises(TypeError, match="'<' not supported between instances of"):
  496:             df.rank()
  497:         result = df.rank(numeric_only=True)
  498:         tm.assert_frame_equal(result, expected)
  499: 
  500:     @pytest.mark.parametrize(
  501:         "dtype, exp_dtype",
  502:         [("string[pyarrow]", "Int64"), ("string[pyarrow_numpy]", "float64")],
  503:     )
  504:     def test_rank_string_dtype(self, dtype, exp_dtype):
  505:         # GH#55362
  506:         pytest.importorskip("pyarrow")
  507:         obj = Series(["foo", "foo", None, "foo"], dtype=dtype)
  508:         result = obj.rank(method="first")
  509:         expected = Series([1, 2, None, 3], dtype=exp_dtype)
  510:         tm.assert_series_equal(result, expected)
