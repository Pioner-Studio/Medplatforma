    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas.util._test_decorators as td
    7: 
    8: from pandas.core.dtypes.base import _registry as ea_registry
    9: from pandas.core.dtypes.common import is_object_dtype
   10: from pandas.core.dtypes.dtypes import (
   11:     CategoricalDtype,
   12:     DatetimeTZDtype,
   13:     IntervalDtype,
   14:     PeriodDtype,
   15: )
   16: 
   17: import pandas as pd
   18: from pandas import (
   19:     Categorical,
   20:     DataFrame,
   21:     DatetimeIndex,
   22:     Index,
   23:     Interval,
   24:     IntervalIndex,
   25:     MultiIndex,
   26:     NaT,
   27:     Period,
   28:     PeriodIndex,
   29:     Series,
   30:     Timestamp,
   31:     cut,
   32:     date_range,
   33:     notna,
   34:     period_range,
   35: )
   36: import pandas._testing as tm
   37: from pandas.core.arrays import SparseArray
   38: 
   39: from pandas.tseries.offsets import BDay
   40: 
   41: 
   42: class TestDataFrameSetItem:
   43:     def test_setitem_str_subclass(self):
   44:         # GH#37366
   45:         class mystring(str):
   46:             pass
   47: 
   48:         data = ["2020-10-22 01:21:00+00:00"]
   49:         index = DatetimeIndex(data)
   50:         df = DataFrame({"a": [1]}, index=index)
   51:         df["b"] = 2
   52:         df[mystring("c")] = 3
   53:         expected = DataFrame({"a": [1], "b": [2], mystring("c"): [3]}, index=index)
   54:         tm.assert_equal(df, expected)
   55: 
   56:     @pytest.mark.parametrize(
   57:         "dtype", ["int32", "int64", "uint32", "uint64", "float32", "float64"]
   58:     )
   59:     def test_setitem_dtype(self, dtype, float_frame):
   60:         # Use integers since casting negative floats to uints is undefined
   61:         arr = np.random.default_rng(2).integers(1, 10, len(float_frame))
   62: 
   63:         float_frame[dtype] = np.array(arr, dtype=dtype)
   64:         assert float_frame[dtype].dtype.name == dtype
   65: 
   66:     def test_setitem_list_not_dataframe(self, float_frame):
   67:         data = np.random.default_rng(2).standard_normal((len(float_frame), 2))
   68:         float_frame[["A", "B"]] = data
   69:         tm.assert_almost_equal(float_frame[["A", "B"]].values, data)
   70: 
   71:     def test_setitem_error_msmgs(self):
   72:         # GH 7432
   73:         df = DataFrame(
   74:             {"bar": [1, 2, 3], "baz": ["d", "e", "f"]},
   75:             index=Index(["a", "b", "c"], name="foo"),
   76:         )
   77:         ser = Series(
   78:             ["g", "h", "i", "j"],
   79:             index=Index(["a", "b", "c", "a"], name="foo"),
   80:             name="fiz",
   81:         )
   82:         msg = "cannot reindex on an axis with duplicate labels"
   83:         with pytest.raises(ValueError, match=msg):
   84:             df["newcol"] = ser
   85: 
   86:         # GH 4107, more descriptive error message
   87:         df = DataFrame(
   88:             np.random.default_rng(2).integers(0, 2, (4, 4)),
   89:             columns=["a", "b", "c", "d"],
   90:         )
   91: 
   92:         msg = "Cannot set a DataFrame with multiple columns to the single column gr"
   93:         with pytest.raises(ValueError, match=msg):
   94:             df["gr"] = df.groupby(["b", "c"]).count()
   95: 
   96:         # GH 55956, specific message for zero columns
   97:         msg = "Cannot set a DataFrame without columns to the column gr"
   98:         with pytest.raises(ValueError, match=msg):
   99:             df["gr"] = DataFrame()
  100: 
  101:     def test_setitem_benchmark(self):
  102:         # from the vb_suite/frame_methods/frame_insert_columns
  103:         N = 10
  104:         K = 5
  105:         df = DataFrame(index=range(N))
  106:         new_col = np.random.default_rng(2).standard_normal(N)
  107:         for i in range(K):
  108:             df[i] = new_col
  109:         expected = DataFrame(np.repeat(new_col, K).reshape(N, K), index=range(N))
  110:         tm.assert_frame_equal(df, expected)
  111: 
  112:     def test_setitem_different_dtype(self):
  113:         df = DataFrame(
  114:             np.random.default_rng(2).standard_normal((5, 3)),
  115:             index=np.arange(5),
  116:             columns=["c", "b", "a"],
  117:         )
  118:         df.insert(0, "foo", df["a"])
  119:         df.insert(2, "bar", df["c"])
  120: 
  121:         # diff dtype
  122: 
  123:         # new item
  124:         df["x"] = df["a"].astype("float32")
  125:         result = df.dtypes
  126:         expected = Series(
  127:             [np.dtype("float64")] * 5 + [np.dtype("float32")],
  128:             index=["foo", "c", "bar", "b", "a", "x"],
  129:         )
  130:         tm.assert_series_equal(result, expected)
  131: 
  132:         # replacing current (in different block)
  133:         df["a"] = df["a"].astype("float32")
  134:         result = df.dtypes
  135:         expected = Series(
  136:             [np.dtype("float64")] * 4 + [np.dtype("float32")] * 2,
  137:             index=["foo", "c", "bar", "b", "a", "x"],
  138:         )
  139:         tm.assert_series_equal(result, expected)
  140: 
  141:         df["y"] = df["a"].astype("int32")
  142:         result = df.dtypes
  143:         expected = Series(
  144:             [np.dtype("float64")] * 4 + [np.dtype("float32")] * 2 + [np.dtype("int32")],
  145:             index=["foo", "c", "bar", "b", "a", "x", "y"],
  146:         )
  147:         tm.assert_series_equal(result, expected)
  148: 
  149:     def test_setitem_empty_columns(self):
  150:         # GH 13522
  151:         df = DataFrame(index=["A", "B", "C"])
  152:         df["X"] = df.index
  153:         df["X"] = ["x", "y", "z"]
  154:         exp = DataFrame(data={"X": ["x", "y", "z"]}, index=["A", "B", "C"])
  155:         tm.assert_frame_equal(df, exp)
  156: 
  157:     def test_setitem_dt64_index_empty_columns(self):
  158:         rng = date_range("1/1/2000 00:00:00", "1/1/2000 1:59:50", freq="10s")
  159:         df = DataFrame(index=np.arange(len(rng)))
  160: 
  161:         df["A"] = rng
  162:         assert df["A"].dtype == np.dtype("M8[ns]")
  163: 
  164:     def test_setitem_timestamp_empty_columns(self):
  165:         # GH#19843
  166:         df = DataFrame(index=range(3))
  167:         df["now"] = Timestamp("20130101", tz="UTC").as_unit("ns")
  168: 
  169:         expected = DataFrame(
  170:             [[Timestamp("20130101", tz="UTC")]] * 3, index=[0, 1, 2], columns=["now"]
  171:         )
  172:         tm.assert_frame_equal(df, expected)
  173: 
  174:     def test_setitem_wrong_length_categorical_dtype_raises(self):
  175:         # GH#29523
  176:         cat = Categorical.from_codes([0, 1, 1, 0, 1, 2], ["a", "b", "c"])
  177:         df = DataFrame(range(10), columns=["bar"])
  178: 
  179:         msg = (
  180:             rf"Length of values \({len(cat)}\) "
  181:             rf"does not match length of index \({len(df)}\)"
  182:         )
  183:         with pytest.raises(ValueError, match=msg):
  184:             df["foo"] = cat
  185: 
  186:     def test_setitem_with_sparse_value(self):
  187:         # GH#8131
  188:         df = DataFrame({"c_1": ["a", "b", "c"], "n_1": [1.0, 2.0, 3.0]})
  189:         sp_array = SparseArray([0, 0, 1])
  190:         df["new_column"] = sp_array
  191: 
  192:         expected = Series(sp_array, name="new_column")
  193:         tm.assert_series_equal(df["new_column"], expected)
  194: 
  195:     def test_setitem_with_unaligned_sparse_value(self):
  196:         df = DataFrame({"c_1": ["a", "b", "c"], "n_1": [1.0, 2.0, 3.0]})
  197:         sp_series = Series(SparseArray([0, 0, 1]), index=[2, 1, 0])
  198: 
  199:         df["new_column"] = sp_series
  200:         expected = Series(SparseArray([1, 0, 0]), name="new_column")
  201:         tm.assert_series_equal(df["new_column"], expected)
  202: 
  203:     def test_setitem_period_preserves_dtype(self):
  204:         # GH: 26861
  205:         data = [Period("2003-12", "D")]
  206:         result = DataFrame([])
  207:         result["a"] = data
  208: 
  209:         expected = DataFrame({"a": data})
  210: 
  211:         tm.assert_frame_equal(result, expected)
  212: 
  213:     def test_setitem_dict_preserves_dtypes(self):
  214:         # https://github.com/pandas-dev/pandas/issues/34573
  215:         expected = DataFrame(
  216:             {
  217:                 "a": Series([0, 1, 2], dtype="int64"),
  218:                 "b": Series([1, 2, 3], dtype=float),
  219:                 "c": Series([1, 2, 3], dtype=float),
  220:                 "d": Series([1, 2, 3], dtype="uint32"),
  221:             }
  222:         )
  223:         df = DataFrame(
  224:             {
  225:                 "a": Series([], dtype="int64"),
  226:                 "b": Series([], dtype=float),
  227:                 "c": Series([], dtype=float),
  228:                 "d": Series([], dtype="uint32"),
  229:             }
  230:         )
  231:         for idx, b in enumerate([1, 2, 3]):
  232:             df.loc[df.shape[0]] = {
  233:                 "a": int(idx),
  234:                 "b": float(b),
  235:                 "c": float(b),
  236:                 "d": np.uint32(b),
  237:             }
  238:         tm.assert_frame_equal(df, expected)
  239: 
  240:     @pytest.mark.parametrize(
  241:         "obj,dtype",
  242:         [
  243:             (Period("2020-01"), PeriodDtype("M")),
  244:             (Interval(left=0, right=5), IntervalDtype("int64", "right")),
  245:             (
  246:                 Timestamp("2011-01-01", tz="US/Eastern"),
  247:                 DatetimeTZDtype(unit="s", tz="US/Eastern"),
  248:             ),
  249:         ],
  250:     )
  251:     def test_setitem_extension_types(self, obj, dtype):
  252:         # GH: 34832
  253:         expected = DataFrame({"idx": [1, 2, 3], "obj": Series([obj] * 3, dtype=dtype)})
  254: 
  255:         df = DataFrame({"idx": [1, 2, 3]})
  256:         df["obj"] = obj
  257: 
  258:         tm.assert_frame_equal(df, expected)
  259: 
  260:     @pytest.mark.parametrize(
  261:         "ea_name",
  262:         [
  263:             dtype.name
  264:             for dtype in ea_registry.dtypes
  265:             # property would require instantiation
  266:             if not isinstance(dtype.name, property)
  267:         ]
  268:         + ["datetime64[ns, UTC]", "period[D]"],
  269:     )
  270:     def test_setitem_with_ea_name(self, ea_name):
  271:         # GH 38386
  272:         result = DataFrame([0])
  273:         result[ea_name] = [1]
  274:         expected = DataFrame({0: [0], ea_name: [1]})
  275:         tm.assert_frame_equal(result, expected)
  276: 
  277:     def test_setitem_dt64_ndarray_with_NaT_and_diff_time_units(self):
  278:         # GH#7492
  279:         data_ns = np.array([1, "nat"], dtype="datetime64[ns]")
  280:         result = Series(data_ns).to_frame()
  281:         result["new"] = data_ns
  282:         expected = DataFrame({0: [1, None], "new": [1, None]}, dtype="datetime64[ns]")
  283:         tm.assert_frame_equal(result, expected)
  284: 
  285:         # OutOfBoundsDatetime error shouldn't occur; as of 2.0 we preserve "M8[s]"
  286:         data_s = np.array([1, "nat"], dtype="datetime64[s]")
  287:         result["new"] = data_s
  288:         tm.assert_series_equal(result[0], expected[0])
  289:         tm.assert_numpy_array_equal(result["new"].to_numpy(), data_s)
  290: 
  291:     @pytest.mark.parametrize("unit", ["h", "m", "s", "ms", "D", "M", "Y"])
  292:     def test_frame_setitem_datetime64_col_other_units(self, unit):
  293:         # Check that non-nano dt64 values get cast to dt64 on setitem
  294:         #  into a not-yet-existing column
  295:         n = 100
  296: 
  297:         dtype = np.dtype(f"M8[{unit}]")
  298:         vals = np.arange(n, dtype=np.int64).view(dtype)
  299:         if unit in ["s", "ms"]:
  300:             # supported unit
  301:             ex_vals = vals
  302:         else:
  303:             # we get the nearest supported units, i.e. "s"
  304:             ex_vals = vals.astype("datetime64[s]")
  305: 
  306:         df = DataFrame({"ints": np.arange(n)}, index=np.arange(n))
  307:         df[unit] = vals
  308: 
  309:         assert df[unit].dtype == ex_vals.dtype
  310:         assert (df[unit].values == ex_vals).all()
  311: 
  312:     @pytest.mark.parametrize("unit", ["h", "m", "s", "ms", "D", "M", "Y"])
  313:     def test_frame_setitem_existing_datetime64_col_other_units(self, unit):
  314:         # Check that non-nano dt64 values get cast to dt64 on setitem
  315:         #  into an already-existing dt64 column
  316:         n = 100
  317: 
  318:         dtype = np.dtype(f"M8[{unit}]")
  319:         vals = np.arange(n, dtype=np.int64).view(dtype)
  320:         ex_vals = vals.astype("datetime64[ns]")
  321: 
  322:         df = DataFrame({"ints": np.arange(n)}, index=np.arange(n))
  323:         df["dates"] = np.arange(n, dtype=np.int64).view("M8[ns]")
  324: 
  325:         # We overwrite existing dt64 column with new, non-nano dt64 vals
  326:         df["dates"] = vals
  327:         assert (df["dates"].values == ex_vals).all()
  328: 
  329:     def test_setitem_dt64tz(self, timezone_frame, using_copy_on_write):
  330:         df = timezone_frame
  331:         idx = df["B"].rename("foo")
  332: 
  333:         # setitem
  334:         df["C"] = idx
  335:         tm.assert_series_equal(df["C"], Series(idx, name="C"))
  336: 
  337:         df["D"] = "foo"
  338:         df["D"] = idx
  339:         tm.assert_series_equal(df["D"], Series(idx, name="D"))
  340:         del df["D"]
  341: 
  342:         # assert that A & C are not sharing the same base (e.g. they
  343:         # are copies)
  344:         # Note: This does not hold with Copy on Write (because of lazy copying)
  345:         v1 = df._mgr.arrays[1]
  346:         v2 = df._mgr.arrays[2]
  347:         tm.assert_extension_array_equal(v1, v2)
  348:         v1base = v1._ndarray.base
  349:         v2base = v2._ndarray.base
  350:         if not using_copy_on_write:
  351:             assert v1base is None or (id(v1base) != id(v2base))
  352:         else:
  353:             assert id(v1base) == id(v2base)
  354: 
  355:         # with nan
  356:         df2 = df.copy()
  357:         df2.iloc[1, 1] = NaT
  358:         df2.iloc[1, 2] = NaT
  359:         result = df2["B"]
  360:         tm.assert_series_equal(notna(result), Series([True, False, True], name="B"))
  361:         tm.assert_series_equal(df2.dtypes, df.dtypes)
  362: 
  363:     def test_setitem_periodindex(self):
  364:         rng = period_range("1/1/2000", periods=5, name="index")
  365:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)), index=rng)
  366: 
  367:         df["Index"] = rng
  368:         rs = Index(df["Index"])
  369:         tm.assert_index_equal(rs, rng, check_names=False)
  370:         assert rs.name == "Index"
  371:         assert rng.name == "index"
  372: 
  373:         rs = df.reset_index().set_index("index")
  374:         assert isinstance(rs.index, PeriodIndex)
  375:         tm.assert_index_equal(rs.index, rng)
  376: 
  377:     def test_setitem_complete_column_with_array(self):
  378:         # GH#37954
  379:         df = DataFrame({"a": ["one", "two", "three"], "b": [1, 2, 3]})
  380:         arr = np.array([[1, 1], [3, 1], [5, 1]])
  381:         df[["c", "d"]] = arr
  382:         expected = DataFrame(
  383:             {
  384:                 "a": ["one", "two", "three"],
  385:                 "b": [1, 2, 3],
  386:                 "c": [1, 3, 5],
  387:                 "d": [1, 1, 1],
  388:             }
  389:         )
  390:         expected["c"] = expected["c"].astype(arr.dtype)
  391:         expected["d"] = expected["d"].astype(arr.dtype)
  392:         assert expected["c"].dtype == arr.dtype
  393:         assert expected["d"].dtype == arr.dtype
  394:         tm.assert_frame_equal(df, expected)
  395: 
  396:     def test_setitem_period_d_dtype(self):
  397:         # GH 39763
  398:         rng = period_range("2016-01-01", periods=9, freq="D", name="A")
  399:         result = DataFrame(rng)
  400:         expected = DataFrame(
  401:             {"A": ["NaT", "NaT", "NaT", "NaT", "NaT", "NaT", "NaT", "NaT", "NaT"]},
  402:             dtype="period[D]",
  403:         )
  404:         result.iloc[:] = rng._na_value
  405:         tm.assert_frame_equal(result, expected)
  406: 
  407:     @pytest.mark.parametrize("dtype", ["f8", "i8", "u8"])
  408:     def test_setitem_bool_with_numeric_index(self, dtype):
  409:         # GH#36319
  410:         cols = Index([1, 2, 3], dtype=dtype)
  411:         df = DataFrame(np.random.default_rng(2).standard_normal((3, 3)), columns=cols)
  412: 
  413:         df[False] = ["a", "b", "c"]
  414: 
  415:         expected_cols = Index([1, 2, 3, False], dtype=object)
  416:         if dtype == "f8":
  417:             expected_cols = Index([1.0, 2.0, 3.0, False], dtype=object)
  418: 
  419:         tm.assert_index_equal(df.columns, expected_cols)
  420: 
  421:     @pytest.mark.parametrize("indexer", ["B", ["B"]])
  422:     def test_setitem_frame_length_0_str_key(self, indexer):
  423:         # GH#38831
  424:         df = DataFrame(columns=["A", "B"])
  425:         other = DataFrame({"B": [1, 2]})
  426:         df[indexer] = other
  427:         expected = DataFrame({"A": [np.nan] * 2, "B": [1, 2]})
  428:         expected["A"] = expected["A"].astype("object")
  429:         tm.assert_frame_equal(df, expected)
  430: 
  431:     def test_setitem_frame_duplicate_columns(self):
  432:         # GH#15695
  433:         cols = ["A", "B", "C"] * 2
  434:         df = DataFrame(index=range(3), columns=cols)
  435:         df.loc[0, "A"] = (0, 3)
  436:         df.loc[:, "B"] = (1, 4)
  437:         df["C"] = (2, 5)
  438:         expected = DataFrame(
  439:             [
  440:                 [0, 1, 2, 3, 4, 5],
  441:                 [np.nan, 1, 2, np.nan, 4, 5],
  442:                 [np.nan, 1, 2, np.nan, 4, 5],
  443:             ],
  444:             dtype="object",
  445:         )
  446: 
  447:         # set these with unique columns to be extra-unambiguous
  448:         expected[2] = expected[2].astype(np.int64)
  449:         expected[5] = expected[5].astype(np.int64)
  450:         expected.columns = cols
  451: 
  452:         tm.assert_frame_equal(df, expected)
  453: 
  454:     def test_setitem_frame_duplicate_columns_size_mismatch(self):
  455:         # GH#39510
  456:         cols = ["A", "B", "C"] * 2
  457:         df = DataFrame(index=range(3), columns=cols)
  458:         with pytest.raises(ValueError, match="Columns must be same length as key"):
  459:             df[["A"]] = (0, 3, 5)
  460: 
  461:         df2 = df.iloc[:, :3]  # unique columns
  462:         with pytest.raises(ValueError, match="Columns must be same length as key"):
  463:             df2[["A"]] = (0, 3, 5)
  464: 
  465:     @pytest.mark.parametrize("cols", [["a", "b", "c"], ["a", "a", "a"]])
  466:     def test_setitem_df_wrong_column_number(self, cols):
  467:         # GH#38604
  468:         df = DataFrame([[1, 2, 3]], columns=cols)
  469:         rhs = DataFrame([[10, 11]], columns=["d", "e"])
  470:         msg = "Columns must be same length as key"
  471:         with pytest.raises(ValueError, match=msg):
  472:             df["a"] = rhs
  473: 
  474:     def test_setitem_listlike_indexer_duplicate_columns(self):
  475:         # GH#38604
  476:         df = DataFrame([[1, 2, 3]], columns=["a", "b", "b"])
  477:         rhs = DataFrame([[10, 11, 12]], columns=["a", "b", "b"])
  478:         df[["a", "b"]] = rhs
  479:         expected = DataFrame([[10, 11, 12]], columns=["a", "b", "b"])
  480:         tm.assert_frame_equal(df, expected)
  481: 
  482:         df[["c", "b"]] = rhs
  483:         expected = DataFrame([[10, 11, 12, 10]], columns=["a", "b", "b", "c"])
  484:         tm.assert_frame_equal(df, expected)
  485: 
  486:     def test_setitem_listlike_indexer_duplicate_columns_not_equal_length(self):
  487:         # GH#39403
  488:         df = DataFrame([[1, 2, 3]], columns=["a", "b", "b"])
  489:         rhs = DataFrame([[10, 11]], columns=["a", "b"])
  490:         msg = "Columns must be same length as key"
  491:         with pytest.raises(ValueError, match=msg):
  492:             df[["a", "b"]] = rhs
  493: 
  494:     def test_setitem_intervals(self):
  495:         df = DataFrame({"A": range(10)})
  496:         ser = cut(df["A"], 5)
  497:         assert isinstance(ser.cat.categories, IntervalIndex)
  498: 
  499:         # B & D end up as Categoricals
  500:         # the remainder are converted to in-line objects
  501:         # containing an IntervalIndex.values
  502:         df["B"] = ser
  503:         df["C"] = np.array(ser)
  504:         df["D"] = ser.values
  505:         df["E"] = np.array(ser.values)
  506:         df["F"] = ser.astype(object)
  507: 
  508:         assert isinstance(df["B"].dtype, CategoricalDtype)
  509:         assert isinstance(df["B"].cat.categories.dtype, IntervalDtype)
  510:         assert isinstance(df["D"].dtype, CategoricalDtype)
  511:         assert isinstance(df["D"].cat.categories.dtype, IntervalDtype)
  512: 
  513:         # These go through the Series constructor and so get inferred back
  514:         #  to IntervalDtype
  515:         assert isinstance(df["C"].dtype, IntervalDtype)
  516:         assert isinstance(df["E"].dtype, IntervalDtype)
  517: 
  518:         # But the Series constructor doesn't do inference on Series objects,
  519:         #  so setting df["F"] doesn't get cast back to IntervalDtype
  520:         assert is_object_dtype(df["F"])
  521: 
  522:         # they compare equal as Index
  523:         # when converted to numpy objects
  524:         c = lambda x: Index(np.array(x))
  525:         tm.assert_index_equal(c(df.B), c(df.B))
  526:         tm.assert_index_equal(c(df.B), c(df.C), check_names=False)
  527:         tm.assert_index_equal(c(df.B), c(df.D), check_names=False)
  528:         tm.assert_index_equal(c(df.C), c(df.D), check_names=False)
  529: 
  530:         # B & D are the same Series
  531:         tm.assert_series_equal(df["B"], df["B"])
  532:         tm.assert_series_equal(df["B"], df["D"], check_names=False)
  533: 
  534:         # C & E are the same Series
  535:         tm.assert_series_equal(df["C"], df["C"])
  536:         tm.assert_series_equal(df["C"], df["E"], check_names=False)
  537: 
  538:     def test_setitem_categorical(self):
  539:         # GH#35369
  540:         df = DataFrame({"h": Series(list("mn")).astype("category")})
  541:         df.h = df.h.cat.reorder_categories(["n", "m"])
  542:         expected = DataFrame(
  543:             {"h": Categorical(["m", "n"]).reorder_categories(["n", "m"])}
  544:         )
  545:         tm.assert_frame_equal(df, expected)
  546: 
  547:     def test_setitem_with_empty_listlike(self):
  548:         # GH#17101
  549:         index = Index([], name="idx")
  550:         result = DataFrame(columns=["A"], index=index)
  551:         result["A"] = []
  552:         expected = DataFrame(columns=["A"], index=index)
  553:         tm.assert_index_equal(result.index, expected.index)
  554: 
  555:     @pytest.mark.parametrize(
  556:         "cols, values, expected",
  557:         [
  558:             (["C", "D", "D", "a"], [1, 2, 3, 4], 4),  # with duplicates
  559:             (["D", "C", "D", "a"], [1, 2, 3, 4], 4),  # mixed order
  560:             (["C", "B", "B", "a"], [1, 2, 3, 4], 4),  # other duplicate cols
  561:             (["C", "B", "a"], [1, 2, 3], 3),  # no duplicates
  562:             (["B", "C", "a"], [3, 2, 1], 1),  # alphabetical order
  563:             (["C", "a", "B"], [3, 2, 1], 2),  # in the middle
  564:         ],
  565:     )
  566:     def test_setitem_same_column(self, cols, values, expected):
  567:         # GH#23239
  568:         df = DataFrame([values], columns=cols)
  569:         df["a"] = df["a"]
  570:         result = df["a"].values[0]
  571:         assert result == expected
  572: 
  573:     def test_setitem_multi_index(self):
  574:         # GH#7655, test that assigning to a sub-frame of a frame
  575:         # with multi-index columns aligns both rows and columns
  576:         it = ["jim", "joe", "jolie"], ["first", "last"], ["left", "center", "right"]
  577: 
  578:         cols = MultiIndex.from_product(it)
  579:         index = date_range("20141006", periods=20)
  580:         vals = np.random.default_rng(2).integers(1, 1000, (len(index), len(cols)))
  581:         df = DataFrame(vals, columns=cols, index=index)
  582: 
  583:         i, j = df.index.values.copy(), it[-1][:]
  584: 
  585:         np.random.default_rng(2).shuffle(i)
  586:         df["jim"] = df["jolie"].loc[i, ::-1]
  587:         tm.assert_frame_equal(df["jim"], df["jolie"])
  588: 
  589:         np.random.default_rng(2).shuffle(j)
  590:         df[("joe", "first")] = df[("jolie", "last")].loc[i, j]
  591:         tm.assert_frame_equal(df[("joe", "first")], df[("jolie", "last")])
  592: 
  593:         np.random.default_rng(2).shuffle(j)
  594:         df[("joe", "last")] = df[("jolie", "first")].loc[i, j]
  595:         tm.assert_frame_equal(df[("joe", "last")], df[("jolie", "first")])
  596: 
  597:     @pytest.mark.parametrize(
  598:         "columns,box,expected",
  599:         [
  600:             (
  601:                 ["A", "B", "C", "D"],
  602:                 7,
  603:                 DataFrame(
  604:                     [[7, 7, 7, 7], [7, 7, 7, 7], [7, 7, 7, 7]],
  605:                     columns=["A", "B", "C", "D"],
  606:                 ),
  607:             ),
  608:             (
  609:                 ["C", "D"],
  610:                 [7, 8],
  611:                 DataFrame(
  612:                     [[1, 2, 7, 8], [3, 4, 7, 8], [5, 6, 7, 8]],
  613:                     columns=["A", "B", "C", "D"],
  614:                 ),
  615:             ),
  616:             (
  617:                 ["A", "B", "C"],
  618:                 np.array([7, 8, 9], dtype=np.int64),
  619:                 DataFrame([[7, 8, 9], [7, 8, 9], [7, 8, 9]], columns=["A", "B", "C"]),
  620:             ),
  621:             (
  622:                 ["B", "C", "D"],
  623:                 [[7, 8, 9], [10, 11, 12], [13, 14, 15]],
  624:                 DataFrame(
  625:                     [[1, 7, 8, 9], [3, 10, 11, 12], [5, 13, 14, 15]],
  626:                     columns=["A", "B", "C", "D"],
  627:                 ),
  628:             ),
  629:             (
  630:                 ["C", "A", "D"],
  631:                 np.array([[7, 8, 9], [10, 11, 12], [13, 14, 15]], dtype=np.int64),
  632:                 DataFrame(
  633:                     [[8, 2, 7, 9], [11, 4, 10, 12], [14, 6, 13, 15]],
  634:                     columns=["A", "B", "C", "D"],
  635:                 ),
  636:             ),
  637:             (
  638:                 ["A", "C"],
  639:                 DataFrame([[7, 8], [9, 10], [11, 12]], columns=["A", "C"]),
  640:                 DataFrame(
  641:                     [[7, 2, 8], [9, 4, 10], [11, 6, 12]], columns=["A", "B", "C"]
  642:                 ),
  643:             ),
  644:         ],
  645:     )
  646:     def test_setitem_list_missing_columns(self, columns, box, expected):
  647:         # GH#29334
  648:         df = DataFrame([[1, 2], [3, 4], [5, 6]], columns=["A", "B"])
  649:         df[columns] = box
  650:         tm.assert_frame_equal(df, expected)
  651: 
  652:     def test_setitem_list_of_tuples(self, float_frame):
  653:         tuples = list(zip(float_frame["A"], float_frame["B"]))
  654:         float_frame["tuples"] = tuples
  655: 
  656:         result = float_frame["tuples"]
  657:         expected = Series(tuples, index=float_frame.index, name="tuples")
  658:         tm.assert_series_equal(result, expected)
  659: 
  660:     def test_setitem_iloc_generator(self):
  661:         # GH#39614
  662:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  663:         indexer = (x for x in [1, 2])
  664:         df.iloc[indexer] = 1
  665:         expected = DataFrame({"a": [1, 1, 1], "b": [4, 1, 1]})
  666:         tm.assert_frame_equal(df, expected)
  667: 
  668:     def test_setitem_iloc_two_dimensional_generator(self):
  669:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  670:         indexer = (x for x in [1, 2])
  671:         df.iloc[indexer, 1] = 1
  672:         expected = DataFrame({"a": [1, 2, 3], "b": [4, 1, 1]})
  673:         tm.assert_frame_equal(df, expected)
  674: 
  675:     def test_setitem_dtypes_bytes_type_to_object(self):
  676:         # GH 20734
  677:         index = Series(name="id", dtype="S24")
  678:         df = DataFrame(index=index)
  679:         df["a"] = Series(name="a", index=index, dtype=np.uint32)
  680:         df["b"] = Series(name="b", index=index, dtype="S64")
  681:         df["c"] = Series(name="c", index=index, dtype="S64")
  682:         df["d"] = Series(name="d", index=index, dtype=np.uint8)
  683:         result = df.dtypes
  684:         expected = Series([np.uint32, object, object, np.uint8], index=list("abcd"))
  685:         tm.assert_series_equal(result, expected)
  686: 
  687:     def test_boolean_mask_nullable_int64(self):
  688:         # GH 28928
  689:         result = DataFrame({"a": [3, 4], "b": [5, 6]}).astype(
  690:             {"a": "int64", "b": "Int64"}
  691:         )
  692:         mask = Series(False, index=result.index)
  693:         result.loc[mask, "a"] = result["a"]
  694:         result.loc[mask, "b"] = result["b"]
  695:         expected = DataFrame({"a": [3, 4], "b": [5, 6]}).astype(
  696:             {"a": "int64", "b": "Int64"}
  697:         )
  698:         tm.assert_frame_equal(result, expected)
  699: 
  700:     def test_setitem_ea_dtype_rhs_series(self):
  701:         # GH#47425
  702:         df = DataFrame({"a": [1, 2]})
  703:         df["a"] = Series([1, 2], dtype="Int64")
  704:         expected = DataFrame({"a": [1, 2]}, dtype="Int64")
  705:         tm.assert_frame_equal(df, expected)
  706: 
  707:     # TODO(ArrayManager) set column with 2d column array, see #44788
  708:     @td.skip_array_manager_not_yet_implemented
  709:     def test_setitem_npmatrix_2d(self):
  710:         # GH#42376
  711:         # for use-case df["x"] = sparse.random((10, 10)).mean(axis=1)
  712:         expected = DataFrame(
  713:             {"np-array": np.ones(10), "np-matrix": np.ones(10)}, index=np.arange(10)
  714:         )
  715: 
  716:         a = np.ones((10, 1))
  717:         df = DataFrame(index=np.arange(10))
  718:         df["np-array"] = a
  719: 
  720:         # Instantiation of `np.matrix` gives PendingDeprecationWarning
  721:         with tm.assert_produces_warning(PendingDeprecationWarning):
  722:             df["np-matrix"] = np.matrix(a)
  723: 
  724:         tm.assert_frame_equal(df, expected)
  725: 
  726:     @pytest.mark.parametrize("vals", [{}, {"d": "a"}])
  727:     def test_setitem_aligning_dict_with_index(self, vals):
  728:         # GH#47216
  729:         df = DataFrame({"a": [1, 2], "b": [3, 4], **vals})
  730:         df.loc[:, "a"] = {1: 100, 0: 200}
  731:         df.loc[:, "c"] = {0: 5, 1: 6}
  732:         df.loc[:, "e"] = {1: 5}
  733:         expected = DataFrame(
  734:             {"a": [200, 100], "b": [3, 4], **vals, "c": [5, 6], "e": [np.nan, 5]}
  735:         )
  736:         tm.assert_frame_equal(df, expected)
  737: 
  738:     def test_setitem_rhs_dataframe(self):
  739:         # GH#47578
  740:         df = DataFrame({"a": [1, 2]})
  741:         df["a"] = DataFrame({"a": [10, 11]}, index=[1, 2])
  742:         expected = DataFrame({"a": [np.nan, 10]})
  743:         tm.assert_frame_equal(df, expected)
  744: 
  745:         df = DataFrame({"a": [1, 2]})
  746:         df.isetitem(0, DataFrame({"a": [10, 11]}, index=[1, 2]))
  747:         tm.assert_frame_equal(df, expected)
  748: 
  749:     def test_setitem_frame_overwrite_with_ea_dtype(self, any_numeric_ea_dtype):
  750:         # GH#46896
  751:         df = DataFrame(columns=["a", "b"], data=[[1, 2], [3, 4]])
  752:         df["a"] = DataFrame({"a": [10, 11]}, dtype=any_numeric_ea_dtype)
  753:         expected = DataFrame(
  754:             {
  755:                 "a": Series([10, 11], dtype=any_numeric_ea_dtype),
  756:                 "b": [2, 4],
  757:             }
  758:         )
  759:         tm.assert_frame_equal(df, expected)
  760: 
  761:     def test_setitem_string_option_object_index(self):
  762:         # GH#55638
  763:         pytest.importorskip("pyarrow")
  764:         df = DataFrame({"a": [1, 2]})
  765:         with pd.option_context("future.infer_string", True):
  766:             df["b"] = Index(["a", "b"], dtype=object)
  767:         expected = DataFrame({"a": [1, 2], "b": Series(["a", "b"], dtype=object)})
  768:         tm.assert_frame_equal(df, expected)
  769: 
  770:     def test_setitem_frame_midx_columns(self):
  771:         # GH#49121
  772:         df = DataFrame({("a", "b"): [10]})
  773:         expected = df.copy()
  774:         col_name = ("a", "b")
  775:         df[col_name] = df[[col_name]]
  776:         tm.assert_frame_equal(df, expected)
  777: 
  778:     def test_loc_setitem_ea_dtype(self):
  779:         # GH#55604
  780:         df = DataFrame({"a": np.array([10], dtype="i8")})
  781:         df.loc[:, "a"] = Series([11], dtype="Int64")
  782:         expected = DataFrame({"a": np.array([11], dtype="i8")})
  783:         tm.assert_frame_equal(df, expected)
  784: 
  785:         df = DataFrame({"a": np.array([10], dtype="i8")})
  786:         df.iloc[:, 0] = Series([11], dtype="Int64")
  787:         tm.assert_frame_equal(df, expected)
  788: 
  789:     def test_setitem_object_inferring(self):
  790:         # GH#56102
  791:         idx = Index([Timestamp("2019-12-31")], dtype=object)
  792:         df = DataFrame({"a": [1]})
  793:         with tm.assert_produces_warning(FutureWarning, match="infer"):
  794:             df.loc[:, "b"] = idx
  795:         with tm.assert_produces_warning(FutureWarning, match="infer"):
  796:             df["c"] = idx
  797: 
  798:         expected = DataFrame(
  799:             {
  800:                 "a": [1],
  801:                 "b": Series([Timestamp("2019-12-31")], dtype="datetime64[ns]"),
  802:                 "c": Series([Timestamp("2019-12-31")], dtype="datetime64[ns]"),
  803:             }
  804:         )
  805:         tm.assert_frame_equal(df, expected)
  806: 
  807: 
  808: class TestSetitemTZAwareValues:
  809:     @pytest.fixture
  810:     def idx(self):
  811:         naive = DatetimeIndex(["2013-1-1 13:00", "2013-1-2 14:00"], name="B")
  812:         idx = naive.tz_localize("US/Pacific")
  813:         return idx
  814: 
  815:     @pytest.fixture
  816:     def expected(self, idx):
  817:         expected = Series(np.array(idx.tolist(), dtype="object"), name="B")
  818:         assert expected.dtype == idx.dtype
  819:         return expected
  820: 
  821:     def test_setitem_dt64series(self, idx, expected):
  822:         # convert to utc
  823:         df = DataFrame(np.random.default_rng(2).standard_normal((2, 1)), columns=["A"])
  824:         df["B"] = idx
  825:         df["B"] = idx.to_series(index=[0, 1]).dt.tz_convert(None)
  826: 
  827:         result = df["B"]
  828:         comp = Series(idx.tz_convert("UTC").tz_localize(None), name="B")
  829:         tm.assert_series_equal(result, comp)
  830: 
  831:     def test_setitem_datetimeindex(self, idx, expected):
  832:         # setting a DataFrame column with a tzaware DTI retains the dtype
  833:         df = DataFrame(np.random.default_rng(2).standard_normal((2, 1)), columns=["A"])
  834: 
  835:         # assign to frame
  836:         df["B"] = idx
  837:         result = df["B"]
  838:         tm.assert_series_equal(result, expected)
  839: 
  840:     def test_setitem_object_array_of_tzaware_datetimes(self, idx, expected):
  841:         # setting a DataFrame column with a tzaware DTI retains the dtype
  842:         df = DataFrame(np.random.default_rng(2).standard_normal((2, 1)), columns=["A"])
  843: 
  844:         # object array of datetimes with a tz
  845:         df["B"] = idx.to_pydatetime()
  846:         result = df["B"]
  847:         tm.assert_series_equal(result, expected)
  848: 
  849: 
  850: class TestDataFrameSetItemWithExpansion:
  851:     def test_setitem_listlike_views(self, using_copy_on_write, warn_copy_on_write):
  852:         # GH#38148
  853:         df = DataFrame({"a": [1, 2, 3], "b": [4, 4, 6]})
  854: 
  855:         # get one column as a view of df
  856:         ser = df["a"]
  857: 
  858:         # add columns with list-like indexer
  859:         df[["c", "d"]] = np.array([[0.1, 0.2], [0.3, 0.4], [0.4, 0.5]])
  860: 
  861:         # edit in place the first column to check view semantics
  862:         with tm.assert_cow_warning(warn_copy_on_write):
  863:             df.iloc[0, 0] = 100
  864: 
  865:         if using_copy_on_write:
  866:             expected = Series([1, 2, 3], name="a")
  867:         else:
  868:             expected = Series([100, 2, 3], name="a")
  869:         tm.assert_series_equal(ser, expected)
  870: 
  871:     def test_setitem_string_column_numpy_dtype_raising(self):
  872:         # GH#39010
  873:         df = DataFrame([[1, 2], [3, 4]])
  874:         df["0 - Name"] = [5, 6]
  875:         expected = DataFrame([[1, 2, 5], [3, 4, 6]], columns=[0, 1, "0 - Name"])
  876:         tm.assert_frame_equal(df, expected)
  877: 
  878:     def test_setitem_empty_df_duplicate_columns(self, using_copy_on_write):
  879:         # GH#38521
  880:         df = DataFrame(columns=["a", "b", "b"], dtype="float64")
  881:         df.loc[:, "a"] = list(range(2))
  882:         expected = DataFrame(
  883:             [[0, np.nan, np.nan], [1, np.nan, np.nan]], columns=["a", "b", "b"]
  884:         )
  885:         tm.assert_frame_equal(df, expected)
  886: 
  887:     def test_setitem_with_expansion_categorical_dtype(self):
  888:         # assignment
  889:         df = DataFrame(
  890:             {
  891:                 "value": np.array(
  892:                     np.random.default_rng(2).integers(0, 10000, 100), dtype="int32"
  893:                 )
  894:             }
  895:         )
  896:         labels = Categorical([f"{i} - {i + 499}" for i in range(0, 10000, 500)])
  897: 
  898:         df = df.sort_values(by=["value"], ascending=True)
  899:         ser = cut(df.value, range(0, 10500, 500), right=False, labels=labels)
  900:         cat = ser.values
  901: 
  902:         # setting with a Categorical
  903:         df["D"] = cat
  904:         result = df.dtypes
  905:         expected = Series(
  906:             [np.dtype("int32"), CategoricalDtype(categories=labels, ordered=False)],
  907:             index=["value", "D"],
  908:         )
  909:         tm.assert_series_equal(result, expected)
  910: 
  911:         # setting with a Series
  912:         df["E"] = ser
  913:         result = df.dtypes
  914:         expected = Series(
  915:             [
  916:                 np.dtype("int32"),
  917:                 CategoricalDtype(categories=labels, ordered=False),
  918:                 CategoricalDtype(categories=labels, ordered=False),
  919:             ],
  920:             index=["value", "D", "E"],
  921:         )
  922:         tm.assert_series_equal(result, expected)
  923: 
  924:         result1 = df["D"]
  925:         result2 = df["E"]
  926:         tm.assert_categorical_equal(result1._mgr.array, cat)
  927: 
  928:         # sorting
  929:         ser.name = "E"
  930:         tm.assert_series_equal(result2.sort_index(), ser.sort_index())
  931: 
  932:     def test_setitem_scalars_no_index(self):
  933:         # GH#16823 / GH#17894
  934:         df = DataFrame()
  935:         df["foo"] = 1
  936:         expected = DataFrame(columns=["foo"]).astype(np.int64)
  937:         tm.assert_frame_equal(df, expected)
  938: 
  939:     def test_setitem_newcol_tuple_key(self, float_frame):
  940:         assert (
  941:             "A",
  942:             "B",
  943:         ) not in float_frame.columns
  944:         float_frame["A", "B"] = float_frame["A"]
  945:         assert ("A", "B") in float_frame.columns
  946: 
  947:         result = float_frame["A", "B"]
  948:         expected = float_frame["A"]
  949:         tm.assert_series_equal(result, expected, check_names=False)
  950: 
  951:     def test_frame_setitem_newcol_timestamp(self):
  952:         # GH#2155
  953:         columns = date_range(start="1/1/2012", end="2/1/2012", freq=BDay())
  954:         data = DataFrame(columns=columns, index=range(10))
  955:         t = datetime(2012, 11, 1)
  956:         ts = Timestamp(t)
  957:         data[ts] = np.nan  # works, mostly a smoke-test
  958:         assert np.isnan(data[ts]).all()
  959: 
  960:     def test_frame_setitem_rangeindex_into_new_col(self):
  961:         # GH#47128
  962:         df = DataFrame({"a": ["a", "b"]})
  963:         df["b"] = df.index
  964:         df.loc[[False, True], "b"] = 100
  965:         result = df.loc[[1], :]
  966:         expected = DataFrame({"a": ["b"], "b": [100]}, index=[1])
  967:         tm.assert_frame_equal(result, expected)
  968: 
  969:     def test_setitem_frame_keep_ea_dtype(self, any_numeric_ea_dtype):
  970:         # GH#46896
  971:         df = DataFrame(columns=["a", "b"], data=[[1, 2], [3, 4]])
  972:         df["c"] = DataFrame({"a": [10, 11]}, dtype=any_numeric_ea_dtype)
  973:         expected = DataFrame(
  974:             {
  975:                 "a": [1, 3],
  976:                 "b": [2, 4],
  977:                 "c": Series([10, 11], dtype=any_numeric_ea_dtype),
  978:             }
  979:         )
  980:         tm.assert_frame_equal(df, expected)
  981: 
  982:     def test_loc_expansion_with_timedelta_type(self):
  983:         result = DataFrame(columns=list("abc"))
  984:         result.loc[0] = {
  985:             "a": pd.to_timedelta(5, unit="s"),
  986:             "b": pd.to_timedelta(72, unit="s"),
  987:             "c": "23",
  988:         }
  989:         expected = DataFrame(
  990:             [[pd.Timedelta("0 days 00:00:05"), pd.Timedelta("0 days 00:01:12"), "23"]],
  991:             index=Index([0]),
  992:             columns=(["a", "b", "c"]),
  993:         )
  994:         tm.assert_frame_equal(result, expected)
  995: 
  996: 
  997: class TestDataFrameSetItemSlicing:
  998:     def test_setitem_slice_position(self):
  999:         # GH#31469
 1000:         df = DataFrame(np.zeros((100, 1)))
 1001:         df[-4:] = 1
 1002:         arr = np.zeros((100, 1))
 1003:         arr[-4:] = 1
 1004:         expected = DataFrame(arr)
 1005:         tm.assert_frame_equal(df, expected)
 1006: 
 1007:     @pytest.mark.parametrize("indexer", [tm.setitem, tm.iloc])
 1008:     @pytest.mark.parametrize("box", [Series, np.array, list, pd.array])
 1009:     @pytest.mark.parametrize("n", [1, 2, 3])
 1010:     def test_setitem_slice_indexer_broadcasting_rhs(self, n, box, indexer):
 1011:         # GH#40440
 1012:         df = DataFrame([[1, 3, 5]] + [[2, 4, 6]] * n, columns=["a", "b", "c"])
 1013:         indexer(df)[1:] = box([10, 11, 12])
 1014:         expected = DataFrame([[1, 3, 5]] + [[10, 11, 12]] * n, columns=["a", "b", "c"])
 1015:         tm.assert_frame_equal(df, expected)
 1016: 
 1017:     @pytest.mark.parametrize("box", [Series, np.array, list, pd.array])
 1018:     @pytest.mark.parametrize("n", [1, 2, 3])
 1019:     def test_setitem_list_indexer_broadcasting_rhs(self, n, box):
 1020:         # GH#40440
 1021:         df = DataFrame([[1, 3, 5]] + [[2, 4, 6]] * n, columns=["a", "b", "c"])
 1022:         df.iloc[list(range(1, n + 1))] = box([10, 11, 12])
 1023:         expected = DataFrame([[1, 3, 5]] + [[10, 11, 12]] * n, columns=["a", "b", "c"])
 1024:         tm.assert_frame_equal(df, expected)
 1025: 
 1026:     @pytest.mark.parametrize("indexer", [tm.setitem, tm.iloc])
 1027:     @pytest.mark.parametrize("box", [Series, np.array, list, pd.array])
 1028:     @pytest.mark.parametrize("n", [1, 2, 3])
 1029:     def test_setitem_slice_broadcasting_rhs_mixed_dtypes(self, n, box, indexer):
 1030:         # GH#40440
 1031:         df = DataFrame(
 1032:             [[1, 3, 5], ["x", "y", "z"]] + [[2, 4, 6]] * n, columns=["a", "b", "c"]
 1033:         )
 1034:         indexer(df)[1:] = box([10, 11, 12])
 1035:         expected = DataFrame(
 1036:             [[1, 3, 5]] + [[10, 11, 12]] * (n + 1),
 1037:             columns=["a", "b", "c"],
 1038:             dtype="object",
 1039:         )
 1040:         tm.assert_frame_equal(df, expected)
 1041: 
 1042: 
 1043: class TestDataFrameSetItemCallable:
 1044:     def test_setitem_callable(self):
 1045:         # GH#12533
 1046:         df = DataFrame({"A": [1, 2, 3, 4], "B": [5, 6, 7, 8]})
 1047:         df[lambda x: "A"] = [11, 12, 13, 14]
 1048: 
 1049:         exp = DataFrame({"A": [11, 12, 13, 14], "B": [5, 6, 7, 8]})
 1050:         tm.assert_frame_equal(df, exp)
 1051: 
 1052:     def test_setitem_other_callable(self):
 1053:         # GH#13299
 1054:         def inc(x):
 1055:             return x + 1
 1056: 
 1057:         # Set dtype object straight away to avoid upcast when setting inc below
 1058:         df = DataFrame([[-1, 1], [1, -1]], dtype=object)
 1059:         df[df > 0] = inc
 1060: 
 1061:         expected = DataFrame([[-1, inc], [inc, -1]])
 1062:         tm.assert_frame_equal(df, expected)
 1063: 
 1064: 
 1065: class TestDataFrameSetItemBooleanMask:
 1066:     @td.skip_array_manager_invalid_test  # TODO(ArrayManager) rewrite not using .values
 1067:     @pytest.mark.parametrize(
 1068:         "mask_type",
 1069:         [lambda df: df > np.abs(df) / 2, lambda df: (df > np.abs(df) / 2).values],
 1070:         ids=["dataframe", "array"],
 1071:     )
 1072:     def test_setitem_boolean_mask(self, mask_type, float_frame):
 1073:         # Test for issue #18582
 1074:         df = float_frame.copy()
 1075:         mask = mask_type(df)
 1076: 
 1077:         # index with boolean mask
 1078:         result = df.copy()
 1079:         result[mask] = np.nan
 1080: 
 1081:         expected = df.values.copy()
 1082:         expected[np.array(mask)] = np.nan
 1083:         expected = DataFrame(expected, index=df.index, columns=df.columns)
 1084:         tm.assert_frame_equal(result, expected)
 1085: 
 1086:     @pytest.mark.xfail(reason="Currently empty indexers are treated as all False")
 1087:     @pytest.mark.parametrize("box", [list, np.array, Series])
 1088:     def test_setitem_loc_empty_indexer_raises_with_non_empty_value(self, box):
 1089:         # GH#37672
 1090:         df = DataFrame({"a": ["a"], "b": [1], "c": [1]})
 1091:         if box == Series:
 1092:             indexer = box([], dtype="object")
 1093:         else:
 1094:             indexer = box([])
 1095:         msg = "Must have equal len keys and value when setting with an iterable"
 1096:         with pytest.raises(ValueError, match=msg):
 1097:             df.loc[indexer, ["b"]] = [1]
 1098: 
 1099:     @pytest.mark.parametrize("box", [list, np.array, Series])
 1100:     def test_setitem_loc_only_false_indexer_dtype_changed(self, box):
 1101:         # GH#37550
 1102:         # Dtype is only changed when value to set is a Series and indexer is
 1103:         # empty/bool all False
 1104:         df = DataFrame({"a": ["a"], "b": [1], "c": [1]})
 1105:         indexer = box([False])
 1106:         df.loc[indexer, ["b"]] = 10 - df["c"]
 1107:         expected = DataFrame({"a": ["a"], "b": [1], "c": [1]})
 1108:         tm.assert_frame_equal(df, expected)
 1109: 
 1110:         df.loc[indexer, ["b"]] = 9
 1111:         tm.assert_frame_equal(df, expected)
 1112: 
 1113:     @pytest.mark.parametrize("indexer", [tm.setitem, tm.loc])
 1114:     def test_setitem_boolean_mask_aligning(self, indexer):
 1115:         # GH#39931
 1116:         df = DataFrame({"a": [1, 4, 2, 3], "b": [5, 6, 7, 8]})
 1117:         expected = df.copy()
 1118:         mask = df["a"] >= 3
 1119:         indexer(df)[mask] = indexer(df)[mask].sort_values("a")
 1120:         tm.assert_frame_equal(df, expected)
 1121: 
 1122:     def test_setitem_mask_categorical(self):
 1123:         # assign multiple rows (mixed values) (-> array) -> exp_multi_row
 1124:         # changed multiple rows
 1125:         cats2 = Categorical(["a", "a", "b", "b", "a", "a", "a"], categories=["a", "b"])
 1126:         idx2 = Index(["h", "i", "j", "k", "l", "m", "n"])
 1127:         values2 = [1, 1, 2, 2, 1, 1, 1]
 1128:         exp_multi_row = DataFrame({"cats": cats2, "values": values2}, index=idx2)
 1129: 
 1130:         catsf = Categorical(
 1131:             ["a", "a", "c", "c", "a", "a", "a"], categories=["a", "b", "c"]
 1132:         )
 1133:         idxf = Index(["h", "i", "j", "k", "l", "m", "n"])
 1134:         valuesf = [1, 1, 3, 3, 1, 1, 1]
 1135:         df = DataFrame({"cats": catsf, "values": valuesf}, index=idxf)
 1136: 
 1137:         exp_fancy = exp_multi_row.copy()
 1138:         exp_fancy["cats"] = exp_fancy["cats"].cat.set_categories(["a", "b", "c"])
 1139: 
 1140:         mask = df["cats"] == "c"
 1141:         df[mask] = ["b", 2]
 1142:         # category c is kept in .categories
 1143:         tm.assert_frame_equal(df, exp_fancy)
 1144: 
 1145:     @pytest.mark.parametrize("dtype", ["float", "int64"])
 1146:     @pytest.mark.parametrize("kwargs", [{}, {"index": [1]}, {"columns": ["A"]}])
 1147:     def test_setitem_empty_frame_with_boolean(self, dtype, kwargs):
 1148:         # see GH#10126
 1149:         kwargs["dtype"] = dtype
 1150:         df = DataFrame(**kwargs)
 1151: 
 1152:         df2 = df.copy()
 1153:         df[df > df2] = 47
 1154:         tm.assert_frame_equal(df, df2)
 1155: 
 1156:     def test_setitem_boolean_indexing(self):
 1157:         idx = list(range(3))
 1158:         cols = ["A", "B", "C"]
 1159:         df1 = DataFrame(
 1160:             index=idx,
 1161:             columns=cols,
 1162:             data=np.array(
 1163:                 [[0.0, 0.5, 1.0], [1.5, 2.0, 2.5], [3.0, 3.5, 4.0]], dtype=float
 1164:             ),
 1165:         )
 1166:         df2 = DataFrame(index=idx, columns=cols, data=np.ones((len(idx), len(cols))))
 1167: 
 1168:         expected = DataFrame(
 1169:             index=idx,
 1170:             columns=cols,
 1171:             data=np.array([[0.0, 0.5, 1.0], [1.5, 2.0, -1], [-1, -1, -1]], dtype=float),
 1172:         )
 1173: 
 1174:         df1[df1 > 2.0 * df2] = -1
 1175:         tm.assert_frame_equal(df1, expected)
 1176:         with pytest.raises(ValueError, match="Item wrong length"):
 1177:             df1[df1.index[:-1] > 2] = -1
 1178: 
 1179:     def test_loc_setitem_all_false_boolean_two_blocks(self):
 1180:         # GH#40885
 1181:         df = DataFrame({"a": [1, 2], "b": [3, 4], "c": "a"})
 1182:         expected = df.copy()
 1183:         indexer = Series([False, False], name="c")
 1184:         df.loc[indexer, ["b"]] = DataFrame({"b": [5, 6]}, index=[0, 1])
 1185:         tm.assert_frame_equal(df, expected)
 1186: 
 1187:     def test_setitem_ea_boolean_mask(self):
 1188:         # GH#47125
 1189:         df = DataFrame([[-1, 2], [3, -4]])
 1190:         expected = DataFrame([[0, 2], [3, 0]])
 1191:         boolean_indexer = DataFrame(
 1192:             {
 1193:                 0: Series([True, False], dtype="boolean"),
 1194:                 1: Series([pd.NA, True], dtype="boolean"),
 1195:             }
 1196:         )
 1197:         df[boolean_indexer] = 0
 1198:         tm.assert_frame_equal(df, expected)
 1199: 
 1200: 
 1201: class TestDataFrameSetitemCopyViewSemantics:
 1202:     def test_setitem_always_copy(self, float_frame):
 1203:         assert "E" not in float_frame.columns
 1204:         s = float_frame["A"].copy()
 1205:         float_frame["E"] = s
 1206: 
 1207:         float_frame.iloc[5:10, float_frame.columns.get_loc("E")] = np.nan
 1208:         assert notna(s[5:10]).all()
 1209: 
 1210:     @pytest.mark.parametrize("consolidate", [True, False])
 1211:     def test_setitem_partial_column_inplace(
 1212:         self, consolidate, using_array_manager, using_copy_on_write
 1213:     ):
 1214:         # This setting should be in-place, regardless of whether frame is
 1215:         #  single-block or multi-block
 1216:         # GH#304 this used to be incorrectly not-inplace, in which case
 1217:         #  we needed to ensure _item_cache was cleared.
 1218: 
 1219:         df = DataFrame(
 1220:             {"x": [1.1, 2.1, 3.1, 4.1], "y": [5.1, 6.1, 7.1, 8.1]}, index=[0, 1, 2, 3]
 1221:         )
 1222:         df.insert(2, "z", np.nan)
 1223:         if not using_array_manager:
 1224:             if consolidate:
 1225:                 df._consolidate_inplace()
 1226:                 assert len(df._mgr.blocks) == 1
 1227:             else:
 1228:                 assert len(df._mgr.blocks) == 2
 1229: 
 1230:         zvals = df["z"]._values
 1231: 
 1232:         df.loc[2:, "z"] = 42
 1233: 
 1234:         expected = Series([np.nan, np.nan, 42, 42], index=df.index, name="z")
 1235:         tm.assert_series_equal(df["z"], expected)
 1236: 
 1237:         # check setting occurred in-place
 1238:         if not using_copy_on_write:
 1239:             tm.assert_numpy_array_equal(zvals, expected.values)
 1240:             assert np.shares_memory(zvals, df["z"]._values)
 1241: 
 1242:     def test_setitem_duplicate_columns_not_inplace(self):
 1243:         # GH#39510
 1244:         cols = ["A", "B"] * 2
 1245:         df = DataFrame(0.0, index=[0], columns=cols)
 1246:         df_copy = df.copy()
 1247:         df_view = df[:]
 1248:         df["B"] = (2, 5)
 1249: 
 1250:         expected = DataFrame([[0.0, 2, 0.0, 5]], columns=cols)
 1251:         tm.assert_frame_equal(df_view, df_copy)
 1252:         tm.assert_frame_equal(df, expected)
 1253: 
 1254:     @pytest.mark.parametrize(
 1255:         "value", [1, np.array([[1], [1]], dtype="int64"), [[1], [1]]]
 1256:     )
 1257:     def test_setitem_same_dtype_not_inplace(self, value, using_array_manager):
 1258:         # GH#39510
 1259:         cols = ["A", "B"]
 1260:         df = DataFrame(0, index=[0, 1], columns=cols)
 1261:         df_copy = df.copy()
 1262:         df_view = df[:]
 1263:         df[["B"]] = value
 1264: 
 1265:         expected = DataFrame([[0, 1], [0, 1]], columns=cols)
 1266:         tm.assert_frame_equal(df, expected)
 1267:         tm.assert_frame_equal(df_view, df_copy)
 1268: 
 1269:     @pytest.mark.parametrize("value", [1.0, np.array([[1.0], [1.0]]), [[1.0], [1.0]]])
 1270:     def test_setitem_listlike_key_scalar_value_not_inplace(self, value):
 1271:         # GH#39510
 1272:         cols = ["A", "B"]
 1273:         df = DataFrame(0, index=[0, 1], columns=cols)
 1274:         df_copy = df.copy()
 1275:         df_view = df[:]
 1276:         df[["B"]] = value
 1277: 
 1278:         expected = DataFrame([[0, 1.0], [0, 1.0]], columns=cols)
 1279:         tm.assert_frame_equal(df_view, df_copy)
 1280:         tm.assert_frame_equal(df, expected)
 1281: 
 1282:     @pytest.mark.parametrize(
 1283:         "indexer",
 1284:         [
 1285:             "a",
 1286:             ["a"],
 1287:             pytest.param(
 1288:                 [True, False],
 1289:                 marks=pytest.mark.xfail(
 1290:                     reason="Boolean indexer incorrectly setting inplace",
 1291:                     strict=False,  # passing on some builds, no obvious pattern
 1292:                 ),
 1293:             ),
 1294:         ],
 1295:     )
 1296:     @pytest.mark.parametrize(
 1297:         "value, set_value",
 1298:         [
 1299:             (1, 5),
 1300:             (1.0, 5.0),
 1301:             (Timestamp("2020-12-31"), Timestamp("2021-12-31")),
 1302:             ("a", "b"),
 1303:         ],
 1304:     )
 1305:     def test_setitem_not_operating_inplace(self, value, set_value, indexer):
 1306:         # GH#43406
 1307:         df = DataFrame({"a": value}, index=[0, 1])
 1308:         expected = df.copy()
 1309:         view = df[:]
 1310:         df[indexer] = set_value
 1311:         tm.assert_frame_equal(view, expected)
 1312: 
 1313:     @td.skip_array_manager_invalid_test
 1314:     def test_setitem_column_update_inplace(
 1315:         self, using_copy_on_write, warn_copy_on_write
 1316:     ):
 1317:         # https://github.com/pandas-dev/pandas/issues/47172
 1318: 
 1319:         labels = [f"c{i}" for i in range(10)]
 1320:         df = DataFrame({col: np.zeros(len(labels)) for col in labels}, index=labels)
 1321:         values = df._mgr.blocks[0].values
 1322: 
 1323:         with tm.raises_chained_assignment_error():
 1324:             for label in df.columns:
 1325:                 df[label][label] = 1
 1326:         if not using_copy_on_write:
 1327:             # diagonal values all updated
 1328:             assert np.all(values[np.arange(10), np.arange(10)] == 1)
 1329:         else:
 1330:             # original dataframe not updated
 1331:             assert np.all(values[np.arange(10), np.arange(10)] == 0)
 1332: 
 1333:     def test_setitem_column_frame_as_category(self):
 1334:         # GH31581
 1335:         df = DataFrame([1, 2, 3])
 1336:         df["col1"] = DataFrame([1, 2, 3], dtype="category")
 1337:         df["col2"] = Series([1, 2, 3], dtype="category")
 1338: 
 1339:         expected_types = Series(
 1340:             ["int64", "category", "category"], index=[0, "col1", "col2"], dtype=object
 1341:         )
 1342:         tm.assert_series_equal(df.dtypes, expected_types)
 1343: 
 1344:     @pytest.mark.parametrize("dtype", ["int64", "Int64"])
 1345:     def test_setitem_iloc_with_numpy_array(self, dtype):
 1346:         # GH-33828
 1347:         df = DataFrame({"a": np.ones(3)}, dtype=dtype)
 1348:         df.iloc[np.array([0]), np.array([0])] = np.array([[2]])
 1349: 
 1350:         expected = DataFrame({"a": [2, 1, 1]}, dtype=dtype)
 1351:         tm.assert_frame_equal(df, expected)
 1352: 
 1353:     def test_setitem_frame_dup_cols_dtype(self):
 1354:         # GH#53143
 1355:         df = DataFrame([[1, 2, 3, 4], [4, 5, 6, 7]], columns=["a", "b", "a", "c"])
 1356:         rhs = DataFrame([[0, 1.5], [2, 2.5]], columns=["a", "a"])
 1357:         df["a"] = rhs
 1358:         expected = DataFrame(
 1359:             [[0, 2, 1.5, 4], [2, 5, 2.5, 7]], columns=["a", "b", "a", "c"]
 1360:         )
 1361:         tm.assert_frame_equal(df, expected)
 1362: 
 1363:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=["a", "a", "b"])
 1364:         rhs = DataFrame([[0, 1.5], [2, 2.5]], columns=["a", "a"])
 1365:         df["a"] = rhs
 1366:         expected = DataFrame([[0, 1.5, 3], [2, 2.5, 6]], columns=["a", "a", "b"])
 1367:         tm.assert_frame_equal(df, expected)
 1368: 
 1369:     def test_frame_setitem_empty_dataframe(self):
 1370:         # GH#28871
 1371:         dti = DatetimeIndex(["2000-01-01"], dtype="M8[ns]", name="date")
 1372:         df = DataFrame({"date": dti}).set_index("date")
 1373:         df = df[0:0].copy()
 1374: 
 1375:         df["3010"] = None
 1376:         df["2010"] = None
 1377: 
 1378:         expected = DataFrame(
 1379:             [],
 1380:             columns=["3010", "2010"],
 1381:             index=dti[:0],
 1382:         )
 1383:         tm.assert_frame_equal(df, expected)
 1384: 
 1385: 
 1386: def test_full_setter_loc_incompatible_dtype():
 1387:     # https://github.com/pandas-dev/pandas/issues/55791
 1388:     df = DataFrame({"a": [1, 2]})
 1389:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1390:         df.loc[:, "a"] = True
 1391:     expected = DataFrame({"a": [True, True]})
 1392:     tm.assert_frame_equal(df, expected)
 1393: 
 1394:     df = DataFrame({"a": [1, 2]})
 1395:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1396:         df.loc[:, "a"] = {0: 3.5, 1: 4.5}
 1397:     expected = DataFrame({"a": [3.5, 4.5]})
 1398:     tm.assert_frame_equal(df, expected)
 1399: 
 1400:     df = DataFrame({"a": [1, 2]})
 1401:     df.loc[:, "a"] = {0: 3, 1: 4}
 1402:     expected = DataFrame({"a": [3, 4]})
 1403:     tm.assert_frame_equal(df, expected)
 1404: 
 1405: 
 1406: def test_setitem_partial_row_multiple_columns():
 1407:     # https://github.com/pandas-dev/pandas/issues/56503
 1408:     df = DataFrame({"A": [1, 2, 3], "B": [4.0, 5, 6]})
 1409:     # should not warn
 1410:     df.loc[df.index <= 1, ["F", "G"]] = (1, "abc")
 1411:     expected = DataFrame(
 1412:         {
 1413:             "A": [1, 2, 3],
 1414:             "B": [4.0, 5, 6],
 1415:             "F": [1.0, 1, float("nan")],
 1416:             "G": ["abc", "abc", float("nan")],
 1417:         }
 1418:     )
 1419:     tm.assert_frame_equal(df, expected)
