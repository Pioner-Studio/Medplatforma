    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.errors import PerformanceWarning
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     DataFrame,
   11:     DatetimeIndex,
   12:     Index,
   13:     MultiIndex,
   14:     Series,
   15:     Timestamp,
   16: )
   17: import pandas._testing as tm
   18: 
   19: 
   20: @pytest.mark.parametrize(
   21:     "msg,labels,level",
   22:     [
   23:         (r"labels \[4\] not found in level", 4, "a"),
   24:         (r"labels \[7\] not found in level", 7, "b"),
   25:     ],
   26: )
   27: def test_drop_raise_exception_if_labels_not_in_level(msg, labels, level):
   28:     # GH 8594
   29:     mi = MultiIndex.from_arrays([[1, 2, 3], [4, 5, 6]], names=["a", "b"])
   30:     s = Series([10, 20, 30], index=mi)
   31:     df = DataFrame([10, 20, 30], index=mi)
   32: 
   33:     with pytest.raises(KeyError, match=msg):
   34:         s.drop(labels, level=level)
   35:     with pytest.raises(KeyError, match=msg):
   36:         df.drop(labels, level=level)
   37: 
   38: 
   39: @pytest.mark.parametrize("labels,level", [(4, "a"), (7, "b")])
   40: def test_drop_errors_ignore(labels, level):
   41:     # GH 8594
   42:     mi = MultiIndex.from_arrays([[1, 2, 3], [4, 5, 6]], names=["a", "b"])
   43:     s = Series([10, 20, 30], index=mi)
   44:     df = DataFrame([10, 20, 30], index=mi)
   45: 
   46:     expected_s = s.drop(labels, level=level, errors="ignore")
   47:     tm.assert_series_equal(s, expected_s)
   48: 
   49:     expected_df = df.drop(labels, level=level, errors="ignore")
   50:     tm.assert_frame_equal(df, expected_df)
   51: 
   52: 
   53: def test_drop_with_non_unique_datetime_index_and_invalid_keys():
   54:     # GH 30399
   55: 
   56:     # define dataframe with unique datetime index
   57:     df = DataFrame(
   58:         np.random.default_rng(2).standard_normal((5, 3)),
   59:         columns=["a", "b", "c"],
   60:         index=pd.date_range("2012", freq="h", periods=5),
   61:     )
   62:     # create dataframe with non-unique datetime index
   63:     df = df.iloc[[0, 2, 2, 3]].copy()
   64: 
   65:     with pytest.raises(KeyError, match="not found in axis"):
   66:         df.drop(["a", "b"])  # Dropping with labels not exist in the index
   67: 
   68: 
   69: class TestDataFrameDrop:
   70:     def test_drop_names(self):
   71:         df = DataFrame(
   72:             [[1, 2, 3], [3, 4, 5], [5, 6, 7]],
   73:             index=["a", "b", "c"],
   74:             columns=["d", "e", "f"],
   75:         )
   76:         df.index.name, df.columns.name = "first", "second"
   77:         df_dropped_b = df.drop("b")
   78:         df_dropped_e = df.drop("e", axis=1)
   79:         df_inplace_b, df_inplace_e = df.copy(), df.copy()
   80:         return_value = df_inplace_b.drop("b", inplace=True)
   81:         assert return_value is None
   82:         return_value = df_inplace_e.drop("e", axis=1, inplace=True)
   83:         assert return_value is None
   84:         for obj in (df_dropped_b, df_dropped_e, df_inplace_b, df_inplace_e):
   85:             assert obj.index.name == "first"
   86:             assert obj.columns.name == "second"
   87:         assert list(df.columns) == ["d", "e", "f"]
   88: 
   89:         msg = r"\['g'\] not found in axis"
   90:         with pytest.raises(KeyError, match=msg):
   91:             df.drop(["g"])
   92:         with pytest.raises(KeyError, match=msg):
   93:             df.drop(["g"], axis=1)
   94: 
   95:         # errors = 'ignore'
   96:         dropped = df.drop(["g"], errors="ignore")
   97:         expected = Index(["a", "b", "c"], name="first")
   98:         tm.assert_index_equal(dropped.index, expected)
   99: 
  100:         dropped = df.drop(["b", "g"], errors="ignore")
  101:         expected = Index(["a", "c"], name="first")
  102:         tm.assert_index_equal(dropped.index, expected)
  103: 
  104:         dropped = df.drop(["g"], axis=1, errors="ignore")
  105:         expected = Index(["d", "e", "f"], name="second")
  106:         tm.assert_index_equal(dropped.columns, expected)
  107: 
  108:         dropped = df.drop(["d", "g"], axis=1, errors="ignore")
  109:         expected = Index(["e", "f"], name="second")
  110:         tm.assert_index_equal(dropped.columns, expected)
  111: 
  112:         # GH 16398
  113:         dropped = df.drop([], errors="ignore")
  114:         expected = Index(["a", "b", "c"], name="first")
  115:         tm.assert_index_equal(dropped.index, expected)
  116: 
  117:     def test_drop(self):
  118:         simple = DataFrame({"A": [1, 2, 3, 4], "B": [0, 1, 2, 3]})
  119:         tm.assert_frame_equal(simple.drop("A", axis=1), simple[["B"]])
  120:         tm.assert_frame_equal(simple.drop(["A", "B"], axis="columns"), simple[[]])
  121:         tm.assert_frame_equal(simple.drop([0, 1, 3], axis=0), simple.loc[[2], :])
  122:         tm.assert_frame_equal(simple.drop([0, 3], axis="index"), simple.loc[[1, 2], :])
  123: 
  124:         with pytest.raises(KeyError, match=r"\[5\] not found in axis"):
  125:             simple.drop(5)
  126:         with pytest.raises(KeyError, match=r"\['C'\] not found in axis"):
  127:             simple.drop("C", axis=1)
  128:         with pytest.raises(KeyError, match=r"\[5\] not found in axis"):
  129:             simple.drop([1, 5])
  130:         with pytest.raises(KeyError, match=r"\['C'\] not found in axis"):
  131:             simple.drop(["A", "C"], axis=1)
  132: 
  133:         # GH 42881
  134:         with pytest.raises(KeyError, match=r"\['C', 'D', 'F'\] not found in axis"):
  135:             simple.drop(["C", "D", "F"], axis=1)
  136: 
  137:         # errors = 'ignore'
  138:         tm.assert_frame_equal(simple.drop(5, errors="ignore"), simple)
  139:         tm.assert_frame_equal(
  140:             simple.drop([0, 5], errors="ignore"), simple.loc[[1, 2, 3], :]
  141:         )
  142:         tm.assert_frame_equal(simple.drop("C", axis=1, errors="ignore"), simple)
  143:         tm.assert_frame_equal(
  144:             simple.drop(["A", "C"], axis=1, errors="ignore"), simple[["B"]]
  145:         )
  146: 
  147:         # non-unique - wheee!
  148:         nu_df = DataFrame(
  149:             list(zip(range(3), range(-3, 1), list("abc"))), columns=["a", "a", "b"]
  150:         )
  151:         tm.assert_frame_equal(nu_df.drop("a", axis=1), nu_df[["b"]])
  152:         tm.assert_frame_equal(nu_df.drop("b", axis="columns"), nu_df["a"])
  153:         tm.assert_frame_equal(nu_df.drop([]), nu_df)  # GH 16398
  154: 
  155:         nu_df = nu_df.set_index(Index(["X", "Y", "X"]))
  156:         nu_df.columns = list("abc")
  157:         tm.assert_frame_equal(nu_df.drop("X", axis="rows"), nu_df.loc[["Y"], :])
  158:         tm.assert_frame_equal(nu_df.drop(["X", "Y"], axis=0), nu_df.loc[[], :])
  159: 
  160:         # inplace cache issue
  161:         # GH#5628
  162:         df = DataFrame(
  163:             np.random.default_rng(2).standard_normal((10, 3)), columns=list("abc")
  164:         )
  165:         expected = df[~(df.b > 0)]
  166:         return_value = df.drop(labels=df[df.b > 0].index, inplace=True)
  167:         assert return_value is None
  168:         tm.assert_frame_equal(df, expected)
  169: 
  170:     def test_drop_multiindex_not_lexsorted(self):
  171:         # GH#11640
  172: 
  173:         # define the lexsorted version
  174:         lexsorted_mi = MultiIndex.from_tuples(
  175:             [("a", ""), ("b1", "c1"), ("b2", "c2")], names=["b", "c"]
  176:         )
  177:         lexsorted_df = DataFrame([[1, 3, 4]], columns=lexsorted_mi)
  178:         assert lexsorted_df.columns._is_lexsorted()
  179: 
  180:         # define the non-lexsorted version
  181:         not_lexsorted_df = DataFrame(
  182:             columns=["a", "b", "c", "d"], data=[[1, "b1", "c1", 3], [1, "b2", "c2", 4]]
  183:         )
  184:         not_lexsorted_df = not_lexsorted_df.pivot_table(
  185:             index="a", columns=["b", "c"], values="d"
  186:         )
  187:         not_lexsorted_df = not_lexsorted_df.reset_index()
  188:         assert not not_lexsorted_df.columns._is_lexsorted()
  189: 
  190:         expected = lexsorted_df.drop("a", axis=1).astype(float)
  191:         with tm.assert_produces_warning(PerformanceWarning):
  192:             result = not_lexsorted_df.drop("a", axis=1)
  193: 
  194:         tm.assert_frame_equal(result, expected)
  195: 
  196:     def test_drop_api_equivalence(self):
  197:         # equivalence of the labels/axis and index/columns API's (GH#12392)
  198:         df = DataFrame(
  199:             [[1, 2, 3], [3, 4, 5], [5, 6, 7]],
  200:             index=["a", "b", "c"],
  201:             columns=["d", "e", "f"],
  202:         )
  203: 
  204:         res1 = df.drop("a")
  205:         res2 = df.drop(index="a")
  206:         tm.assert_frame_equal(res1, res2)
  207: 
  208:         res1 = df.drop("d", axis=1)
  209:         res2 = df.drop(columns="d")
  210:         tm.assert_frame_equal(res1, res2)
  211: 
  212:         res1 = df.drop(labels="e", axis=1)
  213:         res2 = df.drop(columns="e")
  214:         tm.assert_frame_equal(res1, res2)
  215: 
  216:         res1 = df.drop(["a"], axis=0)
  217:         res2 = df.drop(index=["a"])
  218:         tm.assert_frame_equal(res1, res2)
  219: 
  220:         res1 = df.drop(["a"], axis=0).drop(["d"], axis=1)
  221:         res2 = df.drop(index=["a"], columns=["d"])
  222:         tm.assert_frame_equal(res1, res2)
  223: 
  224:         msg = "Cannot specify both 'labels' and 'index'/'columns'"
  225:         with pytest.raises(ValueError, match=msg):
  226:             df.drop(labels="a", index="b")
  227: 
  228:         with pytest.raises(ValueError, match=msg):
  229:             df.drop(labels="a", columns="b")
  230: 
  231:         msg = "Need to specify at least one of 'labels', 'index' or 'columns'"
  232:         with pytest.raises(ValueError, match=msg):
  233:             df.drop(axis=1)
  234: 
  235:     data = [[1, 2, 3], [1, 2, 3]]
  236: 
  237:     @pytest.mark.parametrize(
  238:         "actual",
  239:         [
  240:             DataFrame(data=data, index=["a", "a"]),
  241:             DataFrame(data=data, index=["a", "b"]),
  242:             DataFrame(data=data, index=["a", "b"]).set_index([0, 1]),
  243:             DataFrame(data=data, index=["a", "a"]).set_index([0, 1]),
  244:         ],
  245:     )
  246:     def test_raise_on_drop_duplicate_index(self, actual):
  247:         # GH#19186
  248:         level = 0 if isinstance(actual.index, MultiIndex) else None
  249:         msg = re.escape("\"['c'] not found in axis\"")
  250:         with pytest.raises(KeyError, match=msg):
  251:             actual.drop("c", level=level, axis=0)
  252:         with pytest.raises(KeyError, match=msg):
  253:             actual.T.drop("c", level=level, axis=1)
  254:         expected_no_err = actual.drop("c", axis=0, level=level, errors="ignore")
  255:         tm.assert_frame_equal(expected_no_err, actual)
  256:         expected_no_err = actual.T.drop("c", axis=1, level=level, errors="ignore")
  257:         tm.assert_frame_equal(expected_no_err.T, actual)
  258: 
  259:     @pytest.mark.parametrize("index", [[1, 2, 3], [1, 1, 2]])
  260:     @pytest.mark.parametrize("drop_labels", [[], [1], [2]])
  261:     def test_drop_empty_list(self, index, drop_labels):
  262:         # GH#21494
  263:         expected_index = [i for i in index if i not in drop_labels]
  264:         frame = DataFrame(index=index).drop(drop_labels)
  265:         tm.assert_frame_equal(frame, DataFrame(index=expected_index))
  266: 
  267:     @pytest.mark.parametrize("index", [[1, 2, 3], [1, 2, 2]])
  268:     @pytest.mark.parametrize("drop_labels", [[1, 4], [4, 5]])
  269:     def test_drop_non_empty_list(self, index, drop_labels):
  270:         # GH# 21494
  271:         with pytest.raises(KeyError, match="not found in axis"):
  272:             DataFrame(index=index).drop(drop_labels)
  273: 
  274:     @pytest.mark.parametrize(
  275:         "empty_listlike",
  276:         [
  277:             [],
  278:             {},
  279:             np.array([]),
  280:             Series([], dtype="datetime64[ns]"),
  281:             Index([]),
  282:             DatetimeIndex([]),
  283:         ],
  284:     )
  285:     def test_drop_empty_listlike_non_unique_datetime_index(self, empty_listlike):
  286:         # GH#27994
  287:         data = {"column_a": [5, 10], "column_b": ["one", "two"]}
  288:         index = [Timestamp("2021-01-01"), Timestamp("2021-01-01")]
  289:         df = DataFrame(data, index=index)
  290: 
  291:         # Passing empty list-like should return the same DataFrame.
  292:         expected = df.copy()
  293:         result = df.drop(empty_listlike)
  294:         tm.assert_frame_equal(result, expected)
  295: 
  296:     def test_mixed_depth_drop(self):
  297:         arrays = [
  298:             ["a", "top", "top", "routine1", "routine1", "routine2"],
  299:             ["", "OD", "OD", "result1", "result2", "result1"],
  300:             ["", "wx", "wy", "", "", ""],
  301:         ]
  302: 
  303:         tuples = sorted(zip(*arrays))
  304:         index = MultiIndex.from_tuples(tuples)
  305:         df = DataFrame(np.random.default_rng(2).standard_normal((4, 6)), columns=index)
  306: 
  307:         result = df.drop("a", axis=1)
  308:         expected = df.drop([("a", "", "")], axis=1)
  309:         tm.assert_frame_equal(expected, result)
  310: 
  311:         result = df.drop(["top"], axis=1)
  312:         expected = df.drop([("top", "OD", "wx")], axis=1)
  313:         expected = expected.drop([("top", "OD", "wy")], axis=1)
  314:         tm.assert_frame_equal(expected, result)
  315: 
  316:         result = df.drop(("top", "OD", "wx"), axis=1)
  317:         expected = df.drop([("top", "OD", "wx")], axis=1)
  318:         tm.assert_frame_equal(expected, result)
  319: 
  320:         expected = df.drop([("top", "OD", "wy")], axis=1)
  321:         expected = df.drop("top", axis=1)
  322: 
  323:         result = df.drop("result1", level=1, axis=1)
  324:         expected = df.drop(
  325:             [("routine1", "result1", ""), ("routine2", "result1", "")], axis=1
  326:         )
  327:         tm.assert_frame_equal(expected, result)
  328: 
  329:     def test_drop_multiindex_other_level_nan(self):
  330:         # GH#12754
  331:         df = (
  332:             DataFrame(
  333:                 {
  334:                     "A": ["one", "one", "two", "two"],
  335:                     "B": [np.nan, 0.0, 1.0, 2.0],
  336:                     "C": ["a", "b", "c", "c"],
  337:                     "D": [1, 2, 3, 4],
  338:                 }
  339:             )
  340:             .set_index(["A", "B", "C"])
  341:             .sort_index()
  342:         )
  343:         result = df.drop("c", level="C")
  344:         expected = DataFrame(
  345:             [2, 1],
  346:             columns=["D"],
  347:             index=MultiIndex.from_tuples(
  348:                 [("one", 0.0, "b"), ("one", np.nan, "a")], names=["A", "B", "C"]
  349:             ),
  350:         )
  351:         tm.assert_frame_equal(result, expected)
  352: 
  353:     def test_drop_nonunique(self):
  354:         df = DataFrame(
  355:             [
  356:                 ["x-a", "x", "a", 1.5],
  357:                 ["x-a", "x", "a", 1.2],
  358:                 ["z-c", "z", "c", 3.1],
  359:                 ["x-a", "x", "a", 4.1],
  360:                 ["x-b", "x", "b", 5.1],
  361:                 ["x-b", "x", "b", 4.1],
  362:                 ["x-b", "x", "b", 2.2],
  363:                 ["y-a", "y", "a", 1.2],
  364:                 ["z-b", "z", "b", 2.1],
  365:             ],
  366:             columns=["var1", "var2", "var3", "var4"],
  367:         )
  368: 
  369:         grp_size = df.groupby("var1").size()
  370:         drop_idx = grp_size.loc[grp_size == 1]
  371: 
  372:         idf = df.set_index(["var1", "var2", "var3"])
  373: 
  374:         # it works! GH#2101
  375:         result = idf.drop(drop_idx.index, level=0).reset_index()
  376:         expected = df[-df.var1.isin(drop_idx.index)]
  377: 
  378:         result.index = expected.index
  379: 
  380:         tm.assert_frame_equal(result, expected)
  381: 
  382:     def test_drop_level(self, multiindex_dataframe_random_data):
  383:         frame = multiindex_dataframe_random_data
  384: 
  385:         result = frame.drop(["bar", "qux"], level="first")
  386:         expected = frame.iloc[[0, 1, 2, 5, 6]]
  387:         tm.assert_frame_equal(result, expected)
  388: 
  389:         result = frame.drop(["two"], level="second")
  390:         expected = frame.iloc[[0, 2, 3, 6, 7, 9]]
  391:         tm.assert_frame_equal(result, expected)
  392: 
  393:         result = frame.T.drop(["bar", "qux"], axis=1, level="first")
  394:         expected = frame.iloc[[0, 1, 2, 5, 6]].T
  395:         tm.assert_frame_equal(result, expected)
  396: 
  397:         result = frame.T.drop(["two"], axis=1, level="second")
  398:         expected = frame.iloc[[0, 2, 3, 6, 7, 9]].T
  399:         tm.assert_frame_equal(result, expected)
  400: 
  401:     def test_drop_level_nonunique_datetime(self):
  402:         # GH#12701
  403:         idx = Index([2, 3, 4, 4, 5], name="id")
  404:         idxdt = pd.to_datetime(
  405:             [
  406:                 "2016-03-23 14:00",
  407:                 "2016-03-23 15:00",
  408:                 "2016-03-23 16:00",
  409:                 "2016-03-23 16:00",
  410:                 "2016-03-23 17:00",
  411:             ]
  412:         )
  413:         df = DataFrame(np.arange(10).reshape(5, 2), columns=list("ab"), index=idx)
  414:         df["tstamp"] = idxdt
  415:         df = df.set_index("tstamp", append=True)
  416:         ts = Timestamp("201603231600")
  417:         assert df.index.is_unique is False
  418: 
  419:         result = df.drop(ts, level="tstamp")
  420:         expected = df.loc[idx != 4]
  421:         tm.assert_frame_equal(result, expected)
  422: 
  423:     def test_drop_tz_aware_timestamp_across_dst(self, frame_or_series):
  424:         # GH#21761
  425:         start = Timestamp("2017-10-29", tz="Europe/Berlin")
  426:         end = Timestamp("2017-10-29 04:00:00", tz="Europe/Berlin")
  427:         index = pd.date_range(start, end, freq="15min")
  428:         data = frame_or_series(data=[1] * len(index), index=index)
  429:         result = data.drop(start)
  430:         expected_start = Timestamp("2017-10-29 00:15:00", tz="Europe/Berlin")
  431:         expected_idx = pd.date_range(expected_start, end, freq="15min")
  432:         expected = frame_or_series(data=[1] * len(expected_idx), index=expected_idx)
  433:         tm.assert_equal(result, expected)
  434: 
  435:     def test_drop_preserve_names(self):
  436:         index = MultiIndex.from_arrays(
  437:             [[0, 0, 0, 1, 1, 1], [1, 2, 3, 1, 2, 3]], names=["one", "two"]
  438:         )
  439: 
  440:         df = DataFrame(np.random.default_rng(2).standard_normal((6, 3)), index=index)
  441: 
  442:         result = df.drop([(0, 2)])
  443:         assert result.index.names == ("one", "two")
  444: 
  445:     @pytest.mark.parametrize(
  446:         "operation", ["__iadd__", "__isub__", "__imul__", "__ipow__"]
  447:     )
  448:     @pytest.mark.parametrize("inplace", [False, True])
  449:     def test_inplace_drop_and_operation(self, operation, inplace):
  450:         # GH#30484
  451:         df = DataFrame({"x": range(5)})
  452:         expected = df.copy()
  453:         df["y"] = range(5)
  454:         y = df["y"]
  455: 
  456:         with tm.assert_produces_warning(None):
  457:             if inplace:
  458:                 df.drop("y", axis=1, inplace=inplace)
  459:             else:
  460:                 df = df.drop("y", axis=1, inplace=inplace)
  461: 
  462:             # Perform operation and check result
  463:             getattr(y, operation)(1)
  464:             tm.assert_frame_equal(df, expected)
  465: 
  466:     def test_drop_with_non_unique_multiindex(self):
  467:         # GH#36293
  468:         mi = MultiIndex.from_arrays([["x", "y", "x"], ["i", "j", "i"]])
  469:         df = DataFrame([1, 2, 3], index=mi)
  470:         result = df.drop(index="x")
  471:         expected = DataFrame([2], index=MultiIndex.from_arrays([["y"], ["j"]]))
  472:         tm.assert_frame_equal(result, expected)
  473: 
  474:     @pytest.mark.parametrize("indexer", [("a", "a"), [("a", "a")]])
  475:     def test_drop_tuple_with_non_unique_multiindex(self, indexer):
  476:         # GH#42771
  477:         idx = MultiIndex.from_product([["a", "b"], ["a", "a"]])
  478:         df = DataFrame({"x": range(len(idx))}, index=idx)
  479:         result = df.drop(index=[("a", "a")])
  480:         expected = DataFrame(
  481:             {"x": [2, 3]}, index=MultiIndex.from_tuples([("b", "a"), ("b", "a")])
  482:         )
  483:         tm.assert_frame_equal(result, expected)
  484: 
  485:     def test_drop_with_duplicate_columns(self):
  486:         df = DataFrame(
  487:             [[1, 5, 7.0], [1, 5, 7.0], [1, 5, 7.0]], columns=["bar", "a", "a"]
  488:         )
  489:         result = df.drop(["a"], axis=1)
  490:         expected = DataFrame([[1], [1], [1]], columns=["bar"])
  491:         tm.assert_frame_equal(result, expected)
  492:         result = df.drop("a", axis=1)
  493:         tm.assert_frame_equal(result, expected)
  494: 
  495:     def test_drop_with_duplicate_columns2(self):
  496:         # drop buggy GH#6240
  497:         df = DataFrame(
  498:             {
  499:                 "A": np.random.default_rng(2).standard_normal(5),
  500:                 "B": np.random.default_rng(2).standard_normal(5),
  501:                 "C": np.random.default_rng(2).standard_normal(5),
  502:                 "D": ["a", "b", "c", "d", "e"],
  503:             }
  504:         )
  505: 
  506:         expected = df.take([0, 1, 1], axis=1)
  507:         df2 = df.take([2, 0, 1, 2, 1], axis=1)
  508:         result = df2.drop("C", axis=1)
  509:         tm.assert_frame_equal(result, expected)
  510: 
  511:     def test_drop_inplace_no_leftover_column_reference(self):
  512:         # GH 13934
  513:         df = DataFrame({"a": [1, 2, 3]}, columns=Index(["a"], dtype="object"))
  514:         a = df.a
  515:         df.drop(["a"], axis=1, inplace=True)
  516:         tm.assert_index_equal(df.columns, Index([], dtype="object"))
  517:         a -= a.mean()
  518:         tm.assert_index_equal(df.columns, Index([], dtype="object"))
  519: 
  520:     def test_drop_level_missing_label_multiindex(self):
  521:         # GH 18561
  522:         df = DataFrame(index=MultiIndex.from_product([range(3), range(3)]))
  523:         with pytest.raises(KeyError, match="labels \\[5\\] not found in level"):
  524:             df.drop(5, level=0)
  525: 
  526:     @pytest.mark.parametrize("idx, level", [(["a", "b"], 0), (["a"], None)])
  527:     def test_drop_index_ea_dtype(self, any_numeric_ea_dtype, idx, level):
  528:         # GH#45860
  529:         df = DataFrame(
  530:             {"a": [1, 2, 2, pd.NA], "b": 100}, dtype=any_numeric_ea_dtype
  531:         ).set_index(idx)
  532:         result = df.drop(Index([2, pd.NA]), level=level)
  533:         expected = DataFrame(
  534:             {"a": [1], "b": 100}, dtype=any_numeric_ea_dtype
  535:         ).set_index(idx)
  536:         tm.assert_frame_equal(result, expected)
  537: 
  538:     def test_drop_parse_strings_datetime_index(self):
  539:         # GH #5355
  540:         df = DataFrame(
  541:             {"a": [1, 2], "b": [1, 2]},
  542:             index=[Timestamp("2000-01-03"), Timestamp("2000-01-04")],
  543:         )
  544:         result = df.drop("2000-01-03", axis=0)
  545:         expected = DataFrame({"a": [2], "b": [2]}, index=[Timestamp("2000-01-04")])
  546:         tm.assert_frame_equal(result, expected)
