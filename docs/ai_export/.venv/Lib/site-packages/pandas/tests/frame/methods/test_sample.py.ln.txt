    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     Index,
    7:     Series,
    8: )
    9: import pandas._testing as tm
   10: import pandas.core.common as com
   11: 
   12: 
   13: class TestSample:
   14:     @pytest.fixture
   15:     def obj(self, frame_or_series):
   16:         if frame_or_series is Series:
   17:             arr = np.random.default_rng(2).standard_normal(10)
   18:         else:
   19:             arr = np.random.default_rng(2).standard_normal((10, 10))
   20:         return frame_or_series(arr, dtype=None)
   21: 
   22:     @pytest.mark.parametrize("test", list(range(10)))
   23:     def test_sample(self, test, obj):
   24:         # Fixes issue: 2419
   25:         # Check behavior of random_state argument
   26:         # Check for stability when receives seed or random state -- run 10
   27:         # times.
   28: 
   29:         seed = np.random.default_rng(2).integers(0, 100)
   30:         tm.assert_equal(
   31:             obj.sample(n=4, random_state=seed), obj.sample(n=4, random_state=seed)
   32:         )
   33: 
   34:         tm.assert_equal(
   35:             obj.sample(frac=0.7, random_state=seed),
   36:             obj.sample(frac=0.7, random_state=seed),
   37:         )
   38: 
   39:         tm.assert_equal(
   40:             obj.sample(n=4, random_state=np.random.default_rng(test)),
   41:             obj.sample(n=4, random_state=np.random.default_rng(test)),
   42:         )
   43: 
   44:         tm.assert_equal(
   45:             obj.sample(frac=0.7, random_state=np.random.default_rng(test)),
   46:             obj.sample(frac=0.7, random_state=np.random.default_rng(test)),
   47:         )
   48: 
   49:         tm.assert_equal(
   50:             obj.sample(
   51:                 frac=2,
   52:                 replace=True,
   53:                 random_state=np.random.default_rng(test),
   54:             ),
   55:             obj.sample(
   56:                 frac=2,
   57:                 replace=True,
   58:                 random_state=np.random.default_rng(test),
   59:             ),
   60:         )
   61: 
   62:         os1, os2 = [], []
   63:         for _ in range(2):
   64:             os1.append(obj.sample(n=4, random_state=test))
   65:             os2.append(obj.sample(frac=0.7, random_state=test))
   66:         tm.assert_equal(*os1)
   67:         tm.assert_equal(*os2)
   68: 
   69:     def test_sample_lengths(self, obj):
   70:         # Check lengths are right
   71:         assert len(obj.sample(n=4) == 4)
   72:         assert len(obj.sample(frac=0.34) == 3)
   73:         assert len(obj.sample(frac=0.36) == 4)
   74: 
   75:     def test_sample_invalid_random_state(self, obj):
   76:         # Check for error when random_state argument invalid.
   77:         msg = (
   78:             "random_state must be an integer, array-like, a BitGenerator, Generator, "
   79:             "a numpy RandomState, or None"
   80:         )
   81:         with pytest.raises(ValueError, match=msg):
   82:             obj.sample(random_state="a_string")
   83: 
   84:     def test_sample_wont_accept_n_and_frac(self, obj):
   85:         # Giving both frac and N throws error
   86:         msg = "Please enter a value for `frac` OR `n`, not both"
   87:         with pytest.raises(ValueError, match=msg):
   88:             obj.sample(n=3, frac=0.3)
   89: 
   90:     def test_sample_requires_positive_n_frac(self, obj):
   91:         with pytest.raises(
   92:             ValueError,
   93:             match="A negative number of rows requested. Please provide `n` >= 0",
   94:         ):
   95:             obj.sample(n=-3)
   96:         with pytest.raises(
   97:             ValueError,
   98:             match="A negative number of rows requested. Please provide `frac` >= 0",
   99:         ):
  100:             obj.sample(frac=-0.3)
  101: 
  102:     def test_sample_requires_integer_n(self, obj):
  103:         # Make sure float values of `n` give error
  104:         with pytest.raises(ValueError, match="Only integers accepted as `n` values"):
  105:             obj.sample(n=3.2)
  106: 
  107:     def test_sample_invalid_weight_lengths(self, obj):
  108:         # Weight length must be right
  109:         msg = "Weights and axis to be sampled must be of same length"
  110:         with pytest.raises(ValueError, match=msg):
  111:             obj.sample(n=3, weights=[0, 1])
  112: 
  113:         with pytest.raises(ValueError, match=msg):
  114:             bad_weights = [0.5] * 11
  115:             obj.sample(n=3, weights=bad_weights)
  116: 
  117:         with pytest.raises(ValueError, match="Fewer non-zero entries in p than size"):
  118:             bad_weight_series = Series([0, 0, 0.2])
  119:             obj.sample(n=4, weights=bad_weight_series)
  120: 
  121:     def test_sample_negative_weights(self, obj):
  122:         # Check won't accept negative weights
  123:         bad_weights = [-0.1] * 10
  124:         msg = "weight vector many not include negative values"
  125:         with pytest.raises(ValueError, match=msg):
  126:             obj.sample(n=3, weights=bad_weights)
  127: 
  128:     def test_sample_inf_weights(self, obj):
  129:         # Check inf and -inf throw errors:
  130: 
  131:         weights_with_inf = [0.1] * 10
  132:         weights_with_inf[0] = np.inf
  133:         msg = "weight vector may not include `inf` values"
  134:         with pytest.raises(ValueError, match=msg):
  135:             obj.sample(n=3, weights=weights_with_inf)
  136: 
  137:         weights_with_ninf = [0.1] * 10
  138:         weights_with_ninf[0] = -np.inf
  139:         with pytest.raises(ValueError, match=msg):
  140:             obj.sample(n=3, weights=weights_with_ninf)
  141: 
  142:     def test_sample_zero_weights(self, obj):
  143:         # All zeros raises errors
  144: 
  145:         zero_weights = [0] * 10
  146:         with pytest.raises(ValueError, match="Invalid weights: weights sum to zero"):
  147:             obj.sample(n=3, weights=zero_weights)
  148: 
  149:     def test_sample_missing_weights(self, obj):
  150:         # All missing weights
  151: 
  152:         nan_weights = [np.nan] * 10
  153:         with pytest.raises(ValueError, match="Invalid weights: weights sum to zero"):
  154:             obj.sample(n=3, weights=nan_weights)
  155: 
  156:     def test_sample_none_weights(self, obj):
  157:         # Check None are also replaced by zeros.
  158:         weights_with_None = [None] * 10
  159:         weights_with_None[5] = 0.5
  160:         tm.assert_equal(
  161:             obj.sample(n=1, axis=0, weights=weights_with_None), obj.iloc[5:6]
  162:         )
  163: 
  164:     @pytest.mark.parametrize(
  165:         "func_str,arg",
  166:         [
  167:             ("np.array", [2, 3, 1, 0]),
  168:             ("np.random.MT19937", 3),
  169:             ("np.random.PCG64", 11),
  170:         ],
  171:     )
  172:     def test_sample_random_state(self, func_str, arg, frame_or_series):
  173:         # GH#32503
  174:         obj = DataFrame({"col1": range(10, 20), "col2": range(20, 30)})
  175:         obj = tm.get_obj(obj, frame_or_series)
  176:         result = obj.sample(n=3, random_state=eval(func_str)(arg))
  177:         expected = obj.sample(n=3, random_state=com.random_state(eval(func_str)(arg)))
  178:         tm.assert_equal(result, expected)
  179: 
  180:     def test_sample_generator(self, frame_or_series):
  181:         # GH#38100
  182:         obj = frame_or_series(np.arange(100))
  183:         rng = np.random.default_rng(2)
  184: 
  185:         # Consecutive calls should advance the seed
  186:         result1 = obj.sample(n=50, random_state=rng)
  187:         result2 = obj.sample(n=50, random_state=rng)
  188:         assert not (result1.index.values == result2.index.values).all()
  189: 
  190:         # Matching generator initialization must give same result
  191:         # Consecutive calls should advance the seed
  192:         result1 = obj.sample(n=50, random_state=np.random.default_rng(11))
  193:         result2 = obj.sample(n=50, random_state=np.random.default_rng(11))
  194:         tm.assert_equal(result1, result2)
  195: 
  196:     def test_sample_upsampling_without_replacement(self, frame_or_series):
  197:         # GH#27451
  198: 
  199:         obj = DataFrame({"A": list("abc")})
  200:         obj = tm.get_obj(obj, frame_or_series)
  201: 
  202:         msg = (
  203:             "Replace has to be set to `True` when "
  204:             "upsampling the population `frac` > 1."
  205:         )
  206:         with pytest.raises(ValueError, match=msg):
  207:             obj.sample(frac=2, replace=False)
  208: 
  209: 
  210: class TestSampleDataFrame:
  211:     # Tests which are relevant only for DataFrame, so these are
  212:     #  as fully parametrized as they can get.
  213: 
  214:     def test_sample(self):
  215:         # GH#2419
  216:         # additional specific object based tests
  217: 
  218:         # A few dataframe test with degenerate weights.
  219:         easy_weight_list = [0] * 10
  220:         easy_weight_list[5] = 1
  221: 
  222:         df = DataFrame(
  223:             {
  224:                 "col1": range(10, 20),
  225:                 "col2": range(20, 30),
  226:                 "colString": ["a"] * 10,
  227:                 "easyweights": easy_weight_list,
  228:             }
  229:         )
  230:         sample1 = df.sample(n=1, weights="easyweights")
  231:         tm.assert_frame_equal(sample1, df.iloc[5:6])
  232: 
  233:         # Ensure proper error if string given as weight for Series or
  234:         # DataFrame with axis = 1.
  235:         ser = Series(range(10))
  236:         msg = "Strings cannot be passed as weights when sampling from a Series."
  237:         with pytest.raises(ValueError, match=msg):
  238:             ser.sample(n=3, weights="weight_column")
  239: 
  240:         msg = (
  241:             "Strings can only be passed to weights when sampling from rows on a "
  242:             "DataFrame"
  243:         )
  244:         with pytest.raises(ValueError, match=msg):
  245:             df.sample(n=1, weights="weight_column", axis=1)
  246: 
  247:         # Check weighting key error
  248:         with pytest.raises(
  249:             KeyError, match="'String passed to weights not a valid column'"
  250:         ):
  251:             df.sample(n=3, weights="not_a_real_column_name")
  252: 
  253:         # Check that re-normalizes weights that don't sum to one.
  254:         weights_less_than_1 = [0] * 10
  255:         weights_less_than_1[0] = 0.5
  256:         tm.assert_frame_equal(df.sample(n=1, weights=weights_less_than_1), df.iloc[:1])
  257: 
  258:         ###
  259:         # Test axis argument
  260:         ###
  261: 
  262:         # Test axis argument
  263:         df = DataFrame({"col1": range(10), "col2": ["a"] * 10})
  264:         second_column_weight = [0, 1]
  265:         tm.assert_frame_equal(
  266:             df.sample(n=1, axis=1, weights=second_column_weight), df[["col2"]]
  267:         )
  268: 
  269:         # Different axis arg types
  270:         tm.assert_frame_equal(
  271:             df.sample(n=1, axis="columns", weights=second_column_weight), df[["col2"]]
  272:         )
  273: 
  274:         weight = [0] * 10
  275:         weight[5] = 0.5
  276:         tm.assert_frame_equal(df.sample(n=1, axis="rows", weights=weight), df.iloc[5:6])
  277:         tm.assert_frame_equal(
  278:             df.sample(n=1, axis="index", weights=weight), df.iloc[5:6]
  279:         )
  280: 
  281:         # Check out of range axis values
  282:         msg = "No axis named 2 for object type DataFrame"
  283:         with pytest.raises(ValueError, match=msg):
  284:             df.sample(n=1, axis=2)
  285: 
  286:         msg = "No axis named not_a_name for object type DataFrame"
  287:         with pytest.raises(ValueError, match=msg):
  288:             df.sample(n=1, axis="not_a_name")
  289: 
  290:         ser = Series(range(10))
  291:         with pytest.raises(ValueError, match="No axis named 1 for object type Series"):
  292:             ser.sample(n=1, axis=1)
  293: 
  294:         # Test weight length compared to correct axis
  295:         msg = "Weights and axis to be sampled must be of same length"
  296:         with pytest.raises(ValueError, match=msg):
  297:             df.sample(n=1, axis=1, weights=[0.5] * 10)
  298: 
  299:     def test_sample_axis1(self):
  300:         # Check weights with axis = 1
  301:         easy_weight_list = [0] * 3
  302:         easy_weight_list[2] = 1
  303: 
  304:         df = DataFrame(
  305:             {"col1": range(10, 20), "col2": range(20, 30), "colString": ["a"] * 10}
  306:         )
  307:         sample1 = df.sample(n=1, axis=1, weights=easy_weight_list)
  308:         tm.assert_frame_equal(sample1, df[["colString"]])
  309: 
  310:         # Test default axes
  311:         tm.assert_frame_equal(
  312:             df.sample(n=3, random_state=42), df.sample(n=3, axis=0, random_state=42)
  313:         )
  314: 
  315:     def test_sample_aligns_weights_with_frame(self):
  316:         # Test that function aligns weights with frame
  317:         df = DataFrame({"col1": [5, 6, 7], "col2": ["a", "b", "c"]}, index=[9, 5, 3])
  318:         ser = Series([1, 0, 0], index=[3, 5, 9])
  319:         tm.assert_frame_equal(df.loc[[3]], df.sample(1, weights=ser))
  320: 
  321:         # Weights have index values to be dropped because not in
  322:         # sampled DataFrame
  323:         ser2 = Series([0.001, 0, 10000], index=[3, 5, 10])
  324:         tm.assert_frame_equal(df.loc[[3]], df.sample(1, weights=ser2))
  325: 
  326:         # Weights have empty values to be filed with zeros
  327:         ser3 = Series([0.01, 0], index=[3, 5])
  328:         tm.assert_frame_equal(df.loc[[3]], df.sample(1, weights=ser3))
  329: 
  330:         # No overlap in weight and sampled DataFrame indices
  331:         ser4 = Series([1, 0], index=[1, 2])
  332: 
  333:         with pytest.raises(ValueError, match="Invalid weights: weights sum to zero"):
  334:             df.sample(1, weights=ser4)
  335: 
  336:     def test_sample_is_copy(self):
  337:         # GH#27357, GH#30784: ensure the result of sample is an actual copy and
  338:         # doesn't track the parent dataframe / doesn't give SettingWithCopy warnings
  339:         df = DataFrame(
  340:             np.random.default_rng(2).standard_normal((10, 3)), columns=["a", "b", "c"]
  341:         )
  342:         df2 = df.sample(3)
  343: 
  344:         with tm.assert_produces_warning(None):
  345:             df2["d"] = 1
  346: 
  347:     def test_sample_does_not_modify_weights(self):
  348:         # GH-42843
  349:         result = np.array([np.nan, 1, np.nan])
  350:         expected = result.copy()
  351:         ser = Series([1, 2, 3])
  352: 
  353:         # Test numpy array weights won't be modified in place
  354:         ser.sample(weights=result)
  355:         tm.assert_numpy_array_equal(result, expected)
  356: 
  357:         # Test DataFrame column won't be modified in place
  358:         df = DataFrame({"values": [1, 1, 1], "weights": [1, np.nan, np.nan]})
  359:         expected = df["weights"].copy()
  360: 
  361:         df.sample(frac=1.0, replace=True, weights="weights")
  362:         result = df["weights"]
  363:         tm.assert_series_equal(result, expected)
  364: 
  365:     def test_sample_ignore_index(self):
  366:         # GH 38581
  367:         df = DataFrame(
  368:             {"col1": range(10, 20), "col2": range(20, 30), "colString": ["a"] * 10}
  369:         )
  370:         result = df.sample(3, ignore_index=True)
  371:         expected_index = Index(range(3))
  372:         tm.assert_index_equal(result.index, expected_index, exact=True)
