    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: from pandas import (
    7:     DataFrame,
    8:     NaT,
    9:     Series,
   10:     Timestamp,
   11:     date_range,
   12:     period_range,
   13: )
   14: import pandas._testing as tm
   15: 
   16: 
   17: class TestDataFrameValues:
   18:     @td.skip_array_manager_invalid_test
   19:     def test_values(self, float_frame, using_copy_on_write):
   20:         if using_copy_on_write:
   21:             with pytest.raises(ValueError, match="read-only"):
   22:                 float_frame.values[:, 0] = 5.0
   23:             assert (float_frame.values[:, 0] != 5).all()
   24:         else:
   25:             float_frame.values[:, 0] = 5.0
   26:             assert (float_frame.values[:, 0] == 5).all()
   27: 
   28:     def test_more_values(self, float_string_frame):
   29:         values = float_string_frame.values
   30:         assert values.shape[1] == len(float_string_frame.columns)
   31: 
   32:     def test_values_mixed_dtypes(self, float_frame, float_string_frame):
   33:         frame = float_frame
   34:         arr = frame.values
   35: 
   36:         frame_cols = frame.columns
   37:         for i, row in enumerate(arr):
   38:             for j, value in enumerate(row):
   39:                 col = frame_cols[j]
   40:                 if np.isnan(value):
   41:                     assert np.isnan(frame[col].iloc[i])
   42:                 else:
   43:                     assert value == frame[col].iloc[i]
   44: 
   45:         # mixed type
   46:         arr = float_string_frame[["foo", "A"]].values
   47:         assert arr[0, 0] == "bar"
   48: 
   49:         df = DataFrame({"complex": [1j, 2j, 3j], "real": [1, 2, 3]})
   50:         arr = df.values
   51:         assert arr[0, 0] == 1j
   52: 
   53:     def test_values_duplicates(self):
   54:         df = DataFrame(
   55:             [[1, 2, "a", "b"], [1, 2, "a", "b"]], columns=["one", "one", "two", "two"]
   56:         )
   57: 
   58:         result = df.values
   59:         expected = np.array([[1, 2, "a", "b"], [1, 2, "a", "b"]], dtype=object)
   60: 
   61:         tm.assert_numpy_array_equal(result, expected)
   62: 
   63:     def test_values_with_duplicate_columns(self):
   64:         df = DataFrame([[1, 2.5], [3, 4.5]], index=[1, 2], columns=["x", "x"])
   65:         result = df.values
   66:         expected = np.array([[1, 2.5], [3, 4.5]])
   67:         assert (result == expected).all().all()
   68: 
   69:     @pytest.mark.parametrize("constructor", [date_range, period_range])
   70:     def test_values_casts_datetimelike_to_object(self, constructor):
   71:         series = Series(constructor("2000-01-01", periods=10, freq="D"))
   72: 
   73:         expected = series.astype("object")
   74: 
   75:         df = DataFrame(
   76:             {"a": series, "b": np.random.default_rng(2).standard_normal(len(series))}
   77:         )
   78: 
   79:         result = df.values.squeeze()
   80:         assert (result[:, 0] == expected.values).all()
   81: 
   82:         df = DataFrame({"a": series, "b": ["foo"] * len(series)})
   83: 
   84:         result = df.values.squeeze()
   85:         assert (result[:, 0] == expected.values).all()
   86: 
   87:     def test_frame_values_with_tz(self):
   88:         tz = "US/Central"
   89:         df = DataFrame({"A": date_range("2000", periods=4, tz=tz)})
   90:         result = df.values
   91:         expected = np.array(
   92:             [
   93:                 [Timestamp("2000-01-01", tz=tz)],
   94:                 [Timestamp("2000-01-02", tz=tz)],
   95:                 [Timestamp("2000-01-03", tz=tz)],
   96:                 [Timestamp("2000-01-04", tz=tz)],
   97:             ]
   98:         )
   99:         tm.assert_numpy_array_equal(result, expected)
  100: 
  101:         # two columns, homogeneous
  102: 
  103:         df["B"] = df["A"]
  104:         result = df.values
  105:         expected = np.concatenate([expected, expected], axis=1)
  106:         tm.assert_numpy_array_equal(result, expected)
  107: 
  108:         # three columns, heterogeneous
  109:         est = "US/Eastern"
  110:         df["C"] = df["A"].dt.tz_convert(est)
  111: 
  112:         new = np.array(
  113:             [
  114:                 [Timestamp("2000-01-01T01:00:00", tz=est)],
  115:                 [Timestamp("2000-01-02T01:00:00", tz=est)],
  116:                 [Timestamp("2000-01-03T01:00:00", tz=est)],
  117:                 [Timestamp("2000-01-04T01:00:00", tz=est)],
  118:             ]
  119:         )
  120:         expected = np.concatenate([expected, new], axis=1)
  121:         result = df.values
  122:         tm.assert_numpy_array_equal(result, expected)
  123: 
  124:     def test_interleave_with_tzaware(self, timezone_frame):
  125:         # interleave with object
  126:         result = timezone_frame.assign(D="foo").values
  127:         expected = np.array(
  128:             [
  129:                 [
  130:                     Timestamp("2013-01-01 00:00:00"),
  131:                     Timestamp("2013-01-02 00:00:00"),
  132:                     Timestamp("2013-01-03 00:00:00"),
  133:                 ],
  134:                 [
  135:                     Timestamp("2013-01-01 00:00:00-0500", tz="US/Eastern"),
  136:                     NaT,
  137:                     Timestamp("2013-01-03 00:00:00-0500", tz="US/Eastern"),
  138:                 ],
  139:                 [
  140:                     Timestamp("2013-01-01 00:00:00+0100", tz="CET"),
  141:                     NaT,
  142:                     Timestamp("2013-01-03 00:00:00+0100", tz="CET"),
  143:                 ],
  144:                 ["foo", "foo", "foo"],
  145:             ],
  146:             dtype=object,
  147:         ).T
  148:         tm.assert_numpy_array_equal(result, expected)
  149: 
  150:         # interleave with only datetime64[ns]
  151:         result = timezone_frame.values
  152:         expected = np.array(
  153:             [
  154:                 [
  155:                     Timestamp("2013-01-01 00:00:00"),
  156:                     Timestamp("2013-01-02 00:00:00"),
  157:                     Timestamp("2013-01-03 00:00:00"),
  158:                 ],
  159:                 [
  160:                     Timestamp("2013-01-01 00:00:00-0500", tz="US/Eastern"),
  161:                     NaT,
  162:                     Timestamp("2013-01-03 00:00:00-0500", tz="US/Eastern"),
  163:                 ],
  164:                 [
  165:                     Timestamp("2013-01-01 00:00:00+0100", tz="CET"),
  166:                     NaT,
  167:                     Timestamp("2013-01-03 00:00:00+0100", tz="CET"),
  168:                 ],
  169:             ],
  170:             dtype=object,
  171:         ).T
  172:         tm.assert_numpy_array_equal(result, expected)
  173: 
  174:     def test_values_interleave_non_unique_cols(self):
  175:         df = DataFrame(
  176:             [[Timestamp("20130101"), 3.5], [Timestamp("20130102"), 4.5]],
  177:             columns=["x", "x"],
  178:             index=[1, 2],
  179:         )
  180: 
  181:         df_unique = df.copy()
  182:         df_unique.columns = ["x", "y"]
  183:         assert df_unique.values.shape == df.values.shape
  184:         tm.assert_numpy_array_equal(df_unique.values[0], df.values[0])
  185:         tm.assert_numpy_array_equal(df_unique.values[1], df.values[1])
  186: 
  187:     def test_values_numeric_cols(self, float_frame):
  188:         float_frame["foo"] = "bar"
  189: 
  190:         values = float_frame[["A", "B", "C", "D"]].values
  191:         assert values.dtype == np.float64
  192: 
  193:     def test_values_lcd(self, mixed_float_frame, mixed_int_frame):
  194:         # mixed lcd
  195:         values = mixed_float_frame[["A", "B", "C", "D"]].values
  196:         assert values.dtype == np.float64
  197: 
  198:         values = mixed_float_frame[["A", "B", "C"]].values
  199:         assert values.dtype == np.float32
  200: 
  201:         values = mixed_float_frame[["C"]].values
  202:         assert values.dtype == np.float16
  203: 
  204:         # GH#10364
  205:         # B uint64 forces float because there are other signed int types
  206:         values = mixed_int_frame[["A", "B", "C", "D"]].values
  207:         assert values.dtype == np.float64
  208: 
  209:         values = mixed_int_frame[["A", "D"]].values
  210:         assert values.dtype == np.int64
  211: 
  212:         # B uint64 forces float because there are other signed int types
  213:         values = mixed_int_frame[["A", "B", "C"]].values
  214:         assert values.dtype == np.float64
  215: 
  216:         # as B and C are both unsigned, no forcing to float is needed
  217:         values = mixed_int_frame[["B", "C"]].values
  218:         assert values.dtype == np.uint64
  219: 
  220:         values = mixed_int_frame[["A", "C"]].values
  221:         assert values.dtype == np.int32
  222: 
  223:         values = mixed_int_frame[["C", "D"]].values
  224:         assert values.dtype == np.int64
  225: 
  226:         values = mixed_int_frame[["A"]].values
  227:         assert values.dtype == np.int32
  228: 
  229:         values = mixed_int_frame[["C"]].values
  230:         assert values.dtype == np.uint8
  231: 
  232: 
  233: class TestPrivateValues:
  234:     @td.skip_array_manager_invalid_test
  235:     def test_private_values_dt64tz(self, using_copy_on_write):
  236:         dta = date_range("2000", periods=4, tz="US/Central")._data.reshape(-1, 1)
  237: 
  238:         df = DataFrame(dta, columns=["A"])
  239:         tm.assert_equal(df._values, dta)
  240: 
  241:         if using_copy_on_write:
  242:             assert not np.shares_memory(df._values._ndarray, dta._ndarray)
  243:         else:
  244:             # we have a view
  245:             assert np.shares_memory(df._values._ndarray, dta._ndarray)
  246: 
  247:         # TimedeltaArray
  248:         tda = dta - dta
  249:         df2 = df - df
  250:         tm.assert_equal(df2._values, tda)
  251: 
  252:     @td.skip_array_manager_invalid_test
  253:     def test_private_values_dt64tz_multicol(self, using_copy_on_write):
  254:         dta = date_range("2000", periods=8, tz="US/Central")._data.reshape(-1, 2)
  255: 
  256:         df = DataFrame(dta, columns=["A", "B"])
  257:         tm.assert_equal(df._values, dta)
  258: 
  259:         if using_copy_on_write:
  260:             assert not np.shares_memory(df._values._ndarray, dta._ndarray)
  261:         else:
  262:             # we have a view
  263:             assert np.shares_memory(df._values._ndarray, dta._ndarray)
  264: 
  265:         # TimedeltaArray
  266:         tda = dta - dta
  267:         df2 = df - df
  268:         tm.assert_equal(df2._values, tda)
  269: 
  270:     def test_private_values_dt64_multiblock(self):
  271:         dta = date_range("2000", periods=8)._data
  272: 
  273:         df = DataFrame({"A": dta[:4]}, copy=False)
  274:         df["B"] = dta[4:]
  275: 
  276:         assert len(df._mgr.arrays) == 2
  277: 
  278:         result = df._values
  279:         expected = dta.reshape(2, 4).T
  280:         tm.assert_equal(result, expected)
