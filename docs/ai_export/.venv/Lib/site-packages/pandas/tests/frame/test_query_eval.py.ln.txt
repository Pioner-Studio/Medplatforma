    1: import operator
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.errors import (
    7:     NumExprClobberingError,
    8:     UndefinedVariableError,
    9: )
   10: import pandas.util._test_decorators as td
   11: 
   12: import pandas as pd
   13: from pandas import (
   14:     DataFrame,
   15:     Index,
   16:     MultiIndex,
   17:     Series,
   18:     date_range,
   19: )
   20: import pandas._testing as tm
   21: from pandas.core.computation.check import NUMEXPR_INSTALLED
   22: 
   23: 
   24: @pytest.fixture(params=["python", "pandas"], ids=lambda x: x)
   25: def parser(request):
   26:     return request.param
   27: 
   28: 
   29: @pytest.fixture(
   30:     params=["python", pytest.param("numexpr", marks=td.skip_if_no("numexpr"))],
   31:     ids=lambda x: x,
   32: )
   33: def engine(request):
   34:     return request.param
   35: 
   36: 
   37: def skip_if_no_pandas_parser(parser):
   38:     if parser != "pandas":
   39:         pytest.skip(f"cannot evaluate with parser={parser}")
   40: 
   41: 
   42: class TestCompat:
   43:     @pytest.fixture
   44:     def df(self):
   45:         return DataFrame({"A": [1, 2, 3]})
   46: 
   47:     @pytest.fixture
   48:     def expected1(self, df):
   49:         return df[df.A > 0]
   50: 
   51:     @pytest.fixture
   52:     def expected2(self, df):
   53:         return df.A + 1
   54: 
   55:     def test_query_default(self, df, expected1, expected2):
   56:         # GH 12749
   57:         # this should always work, whether NUMEXPR_INSTALLED or not
   58:         result = df.query("A>0")
   59:         tm.assert_frame_equal(result, expected1)
   60:         result = df.eval("A+1")
   61:         tm.assert_series_equal(result, expected2, check_names=False)
   62: 
   63:     def test_query_None(self, df, expected1, expected2):
   64:         result = df.query("A>0", engine=None)
   65:         tm.assert_frame_equal(result, expected1)
   66:         result = df.eval("A+1", engine=None)
   67:         tm.assert_series_equal(result, expected2, check_names=False)
   68: 
   69:     def test_query_python(self, df, expected1, expected2):
   70:         result = df.query("A>0", engine="python")
   71:         tm.assert_frame_equal(result, expected1)
   72:         result = df.eval("A+1", engine="python")
   73:         tm.assert_series_equal(result, expected2, check_names=False)
   74: 
   75:     def test_query_numexpr(self, df, expected1, expected2):
   76:         if NUMEXPR_INSTALLED:
   77:             result = df.query("A>0", engine="numexpr")
   78:             tm.assert_frame_equal(result, expected1)
   79:             result = df.eval("A+1", engine="numexpr")
   80:             tm.assert_series_equal(result, expected2, check_names=False)
   81:         else:
   82:             msg = (
   83:                 r"'numexpr' is not installed or an unsupported version. "
   84:                 r"Cannot use engine='numexpr' for query/eval if 'numexpr' is "
   85:                 r"not installed"
   86:             )
   87:             with pytest.raises(ImportError, match=msg):
   88:                 df.query("A>0", engine="numexpr")
   89:             with pytest.raises(ImportError, match=msg):
   90:                 df.eval("A+1", engine="numexpr")
   91: 
   92: 
   93: class TestDataFrameEval:
   94:     # smaller hits python, larger hits numexpr
   95:     @pytest.mark.parametrize("n", [4, 4000])
   96:     @pytest.mark.parametrize(
   97:         "op_str,op,rop",
   98:         [
   99:             ("+", "__add__", "__radd__"),
  100:             ("-", "__sub__", "__rsub__"),
  101:             ("*", "__mul__", "__rmul__"),
  102:             ("/", "__truediv__", "__rtruediv__"),
  103:         ],
  104:     )
  105:     def test_ops(self, op_str, op, rop, n):
  106:         # tst ops and reversed ops in evaluation
  107:         # GH7198
  108: 
  109:         df = DataFrame(1, index=range(n), columns=list("abcd"))
  110:         df.iloc[0] = 2
  111:         m = df.mean()
  112: 
  113:         base = DataFrame(  # noqa: F841
  114:             np.tile(m.values, n).reshape(n, -1), columns=list("abcd")
  115:         )
  116: 
  117:         expected = eval(f"base {op_str} df")
  118: 
  119:         # ops as strings
  120:         result = eval(f"m {op_str} df")
  121:         tm.assert_frame_equal(result, expected)
  122: 
  123:         # these are commutative
  124:         if op in ["+", "*"]:
  125:             result = getattr(df, op)(m)
  126:             tm.assert_frame_equal(result, expected)
  127: 
  128:         # these are not
  129:         elif op in ["-", "/"]:
  130:             result = getattr(df, rop)(m)
  131:             tm.assert_frame_equal(result, expected)
  132: 
  133:     def test_dataframe_sub_numexpr_path(self):
  134:         # GH7192: Note we need a large number of rows to ensure this
  135:         #  goes through the numexpr path
  136:         df = DataFrame({"A": np.random.default_rng(2).standard_normal(25000)})
  137:         df.iloc[0:5] = np.nan
  138:         expected = 1 - np.isnan(df.iloc[0:25])
  139:         result = (1 - np.isnan(df)).iloc[0:25]
  140:         tm.assert_frame_equal(result, expected)
  141: 
  142:     def test_query_non_str(self):
  143:         # GH 11485
  144:         df = DataFrame({"A": [1, 2, 3], "B": ["a", "b", "b"]})
  145: 
  146:         msg = "expr must be a string to be evaluated"
  147:         with pytest.raises(ValueError, match=msg):
  148:             df.query(lambda x: x.B == "b")
  149: 
  150:         with pytest.raises(ValueError, match=msg):
  151:             df.query(111)
  152: 
  153:     def test_query_empty_string(self):
  154:         # GH 13139
  155:         df = DataFrame({"A": [1, 2, 3]})
  156: 
  157:         msg = "expr cannot be an empty string"
  158:         with pytest.raises(ValueError, match=msg):
  159:             df.query("")
  160: 
  161:     def test_eval_resolvers_as_list(self):
  162:         # GH 14095
  163:         df = DataFrame(
  164:             np.random.default_rng(2).standard_normal((10, 2)), columns=list("ab")
  165:         )
  166:         dict1 = {"a": 1}
  167:         dict2 = {"b": 2}
  168:         assert df.eval("a + b", resolvers=[dict1, dict2]) == dict1["a"] + dict2["b"]
  169:         assert pd.eval("a + b", resolvers=[dict1, dict2]) == dict1["a"] + dict2["b"]
  170: 
  171:     def test_eval_resolvers_combined(self):
  172:         # GH 34966
  173:         df = DataFrame(
  174:             np.random.default_rng(2).standard_normal((10, 2)), columns=list("ab")
  175:         )
  176:         dict1 = {"c": 2}
  177: 
  178:         # Both input and default index/column resolvers should be usable
  179:         result = df.eval("a + b * c", resolvers=[dict1])
  180: 
  181:         expected = df["a"] + df["b"] * dict1["c"]
  182:         tm.assert_series_equal(result, expected)
  183: 
  184:     def test_eval_object_dtype_binop(self):
  185:         # GH#24883
  186:         df = DataFrame({"a1": ["Y", "N"]})
  187:         res = df.eval("c = ((a1 == 'Y') & True)")
  188:         expected = DataFrame({"a1": ["Y", "N"], "c": [True, False]})
  189:         tm.assert_frame_equal(res, expected)
  190: 
  191: 
  192: class TestDataFrameQueryWithMultiIndex:
  193:     def test_query_with_named_multiindex(self, parser, engine):
  194:         skip_if_no_pandas_parser(parser)
  195:         a = np.random.default_rng(2).choice(["red", "green"], size=10)
  196:         b = np.random.default_rng(2).choice(["eggs", "ham"], size=10)
  197:         index = MultiIndex.from_arrays([a, b], names=["color", "food"])
  198:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)), index=index)
  199:         ind = Series(
  200:             df.index.get_level_values("color").values, index=index, name="color"
  201:         )
  202: 
  203:         # equality
  204:         res1 = df.query('color == "red"', parser=parser, engine=engine)
  205:         res2 = df.query('"red" == color', parser=parser, engine=engine)
  206:         exp = df[ind == "red"]
  207:         tm.assert_frame_equal(res1, exp)
  208:         tm.assert_frame_equal(res2, exp)
  209: 
  210:         # inequality
  211:         res1 = df.query('color != "red"', parser=parser, engine=engine)
  212:         res2 = df.query('"red" != color', parser=parser, engine=engine)
  213:         exp = df[ind != "red"]
  214:         tm.assert_frame_equal(res1, exp)
  215:         tm.assert_frame_equal(res2, exp)
  216: 
  217:         # list equality (really just set membership)
  218:         res1 = df.query('color == ["red"]', parser=parser, engine=engine)
  219:         res2 = df.query('["red"] == color', parser=parser, engine=engine)
  220:         exp = df[ind.isin(["red"])]
  221:         tm.assert_frame_equal(res1, exp)
  222:         tm.assert_frame_equal(res2, exp)
  223: 
  224:         res1 = df.query('color != ["red"]', parser=parser, engine=engine)
  225:         res2 = df.query('["red"] != color', parser=parser, engine=engine)
  226:         exp = df[~ind.isin(["red"])]
  227:         tm.assert_frame_equal(res1, exp)
  228:         tm.assert_frame_equal(res2, exp)
  229: 
  230:         # in/not in ops
  231:         res1 = df.query('["red"] in color', parser=parser, engine=engine)
  232:         res2 = df.query('"red" in color', parser=parser, engine=engine)
  233:         exp = df[ind.isin(["red"])]
  234:         tm.assert_frame_equal(res1, exp)
  235:         tm.assert_frame_equal(res2, exp)
  236: 
  237:         res1 = df.query('["red"] not in color', parser=parser, engine=engine)
  238:         res2 = df.query('"red" not in color', parser=parser, engine=engine)
  239:         exp = df[~ind.isin(["red"])]
  240:         tm.assert_frame_equal(res1, exp)
  241:         tm.assert_frame_equal(res2, exp)
  242: 
  243:     def test_query_with_unnamed_multiindex(self, parser, engine):
  244:         skip_if_no_pandas_parser(parser)
  245:         a = np.random.default_rng(2).choice(["red", "green"], size=10)
  246:         b = np.random.default_rng(2).choice(["eggs", "ham"], size=10)
  247:         index = MultiIndex.from_arrays([a, b])
  248:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)), index=index)
  249:         ind = Series(df.index.get_level_values(0).values, index=index)
  250: 
  251:         res1 = df.query('ilevel_0 == "red"', parser=parser, engine=engine)
  252:         res2 = df.query('"red" == ilevel_0', parser=parser, engine=engine)
  253:         exp = df[ind == "red"]
  254:         tm.assert_frame_equal(res1, exp)
  255:         tm.assert_frame_equal(res2, exp)
  256: 
  257:         # inequality
  258:         res1 = df.query('ilevel_0 != "red"', parser=parser, engine=engine)
  259:         res2 = df.query('"red" != ilevel_0', parser=parser, engine=engine)
  260:         exp = df[ind != "red"]
  261:         tm.assert_frame_equal(res1, exp)
  262:         tm.assert_frame_equal(res2, exp)
  263: 
  264:         # list equality (really just set membership)
  265:         res1 = df.query('ilevel_0 == ["red"]', parser=parser, engine=engine)
  266:         res2 = df.query('["red"] == ilevel_0', parser=parser, engine=engine)
  267:         exp = df[ind.isin(["red"])]
  268:         tm.assert_frame_equal(res1, exp)
  269:         tm.assert_frame_equal(res2, exp)
  270: 
  271:         res1 = df.query('ilevel_0 != ["red"]', parser=parser, engine=engine)
  272:         res2 = df.query('["red"] != ilevel_0', parser=parser, engine=engine)
  273:         exp = df[~ind.isin(["red"])]
  274:         tm.assert_frame_equal(res1, exp)
  275:         tm.assert_frame_equal(res2, exp)
  276: 
  277:         # in/not in ops
  278:         res1 = df.query('["red"] in ilevel_0', parser=parser, engine=engine)
  279:         res2 = df.query('"red" in ilevel_0', parser=parser, engine=engine)
  280:         exp = df[ind.isin(["red"])]
  281:         tm.assert_frame_equal(res1, exp)
  282:         tm.assert_frame_equal(res2, exp)
  283: 
  284:         res1 = df.query('["red"] not in ilevel_0', parser=parser, engine=engine)
  285:         res2 = df.query('"red" not in ilevel_0', parser=parser, engine=engine)
  286:         exp = df[~ind.isin(["red"])]
  287:         tm.assert_frame_equal(res1, exp)
  288:         tm.assert_frame_equal(res2, exp)
  289: 
  290:         # ## LEVEL 1
  291:         ind = Series(df.index.get_level_values(1).values, index=index)
  292:         res1 = df.query('ilevel_1 == "eggs"', parser=parser, engine=engine)
  293:         res2 = df.query('"eggs" == ilevel_1', parser=parser, engine=engine)
  294:         exp = df[ind == "eggs"]
  295:         tm.assert_frame_equal(res1, exp)
  296:         tm.assert_frame_equal(res2, exp)
  297: 
  298:         # inequality
  299:         res1 = df.query('ilevel_1 != "eggs"', parser=parser, engine=engine)
  300:         res2 = df.query('"eggs" != ilevel_1', parser=parser, engine=engine)
  301:         exp = df[ind != "eggs"]
  302:         tm.assert_frame_equal(res1, exp)
  303:         tm.assert_frame_equal(res2, exp)
  304: 
  305:         # list equality (really just set membership)
  306:         res1 = df.query('ilevel_1 == ["eggs"]', parser=parser, engine=engine)
  307:         res2 = df.query('["eggs"] == ilevel_1', parser=parser, engine=engine)
  308:         exp = df[ind.isin(["eggs"])]
  309:         tm.assert_frame_equal(res1, exp)
  310:         tm.assert_frame_equal(res2, exp)
  311: 
  312:         res1 = df.query('ilevel_1 != ["eggs"]', parser=parser, engine=engine)
  313:         res2 = df.query('["eggs"] != ilevel_1', parser=parser, engine=engine)
  314:         exp = df[~ind.isin(["eggs"])]
  315:         tm.assert_frame_equal(res1, exp)
  316:         tm.assert_frame_equal(res2, exp)
  317: 
  318:         # in/not in ops
  319:         res1 = df.query('["eggs"] in ilevel_1', parser=parser, engine=engine)
  320:         res2 = df.query('"eggs" in ilevel_1', parser=parser, engine=engine)
  321:         exp = df[ind.isin(["eggs"])]
  322:         tm.assert_frame_equal(res1, exp)
  323:         tm.assert_frame_equal(res2, exp)
  324: 
  325:         res1 = df.query('["eggs"] not in ilevel_1', parser=parser, engine=engine)
  326:         res2 = df.query('"eggs" not in ilevel_1', parser=parser, engine=engine)
  327:         exp = df[~ind.isin(["eggs"])]
  328:         tm.assert_frame_equal(res1, exp)
  329:         tm.assert_frame_equal(res2, exp)
  330: 
  331:     def test_query_with_partially_named_multiindex(self, parser, engine):
  332:         skip_if_no_pandas_parser(parser)
  333:         a = np.random.default_rng(2).choice(["red", "green"], size=10)
  334:         b = np.arange(10)
  335:         index = MultiIndex.from_arrays([a, b])
  336:         index.names = [None, "rating"]
  337:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)), index=index)
  338:         res = df.query("rating == 1", parser=parser, engine=engine)
  339:         ind = Series(
  340:             df.index.get_level_values("rating").values, index=index, name="rating"
  341:         )
  342:         exp = df[ind == 1]
  343:         tm.assert_frame_equal(res, exp)
  344: 
  345:         res = df.query("rating != 1", parser=parser, engine=engine)
  346:         ind = Series(
  347:             df.index.get_level_values("rating").values, index=index, name="rating"
  348:         )
  349:         exp = df[ind != 1]
  350:         tm.assert_frame_equal(res, exp)
  351: 
  352:         res = df.query('ilevel_0 == "red"', parser=parser, engine=engine)
  353:         ind = Series(df.index.get_level_values(0).values, index=index)
  354:         exp = df[ind == "red"]
  355:         tm.assert_frame_equal(res, exp)
  356: 
  357:         res = df.query('ilevel_0 != "red"', parser=parser, engine=engine)
  358:         ind = Series(df.index.get_level_values(0).values, index=index)
  359:         exp = df[ind != "red"]
  360:         tm.assert_frame_equal(res, exp)
  361: 
  362:     def test_query_multiindex_get_index_resolvers(self):
  363:         df = DataFrame(
  364:             np.ones((10, 3)),
  365:             index=MultiIndex.from_arrays(
  366:                 [range(10) for _ in range(2)], names=["spam", "eggs"]
  367:             ),
  368:         )
  369:         resolvers = df._get_index_resolvers()
  370: 
  371:         def to_series(mi, level):
  372:             level_values = mi.get_level_values(level)
  373:             s = level_values.to_series()
  374:             s.index = mi
  375:             return s
  376: 
  377:         col_series = df.columns.to_series()
  378:         expected = {
  379:             "index": df.index,
  380:             "columns": col_series,
  381:             "spam": to_series(df.index, "spam"),
  382:             "eggs": to_series(df.index, "eggs"),
  383:             "clevel_0": col_series,
  384:         }
  385:         for k, v in resolvers.items():
  386:             if isinstance(v, Index):
  387:                 assert v.is_(expected[k])
  388:             elif isinstance(v, Series):
  389:                 tm.assert_series_equal(v, expected[k])
  390:             else:
  391:                 raise AssertionError("object must be a Series or Index")
  392: 
  393: 
  394: @td.skip_if_no("numexpr")
  395: class TestDataFrameQueryNumExprPandas:
  396:     @pytest.fixture
  397:     def engine(self):
  398:         return "numexpr"
  399: 
  400:     @pytest.fixture
  401:     def parser(self):
  402:         return "pandas"
  403: 
  404:     def test_date_query_with_attribute_access(self, engine, parser):
  405:         skip_if_no_pandas_parser(parser)
  406:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
  407:         df["dates1"] = date_range("1/1/2012", periods=5)
  408:         df["dates2"] = date_range("1/1/2013", periods=5)
  409:         df["dates3"] = date_range("1/1/2014", periods=5)
  410:         res = df.query(
  411:             "@df.dates1 < 20130101 < @df.dates3", engine=engine, parser=parser
  412:         )
  413:         expec = df[(df.dates1 < "20130101") & ("20130101" < df.dates3)]
  414:         tm.assert_frame_equal(res, expec)
  415: 
  416:     def test_date_query_no_attribute_access(self, engine, parser):
  417:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
  418:         df["dates1"] = date_range("1/1/2012", periods=5)
  419:         df["dates2"] = date_range("1/1/2013", periods=5)
  420:         df["dates3"] = date_range("1/1/2014", periods=5)
  421:         res = df.query("dates1 < 20130101 < dates3", engine=engine, parser=parser)
  422:         expec = df[(df.dates1 < "20130101") & ("20130101" < df.dates3)]
  423:         tm.assert_frame_equal(res, expec)
  424: 
  425:     def test_date_query_with_NaT(self, engine, parser):
  426:         n = 10
  427:         df = DataFrame(np.random.default_rng(2).standard_normal((n, 3)))
  428:         df["dates1"] = date_range("1/1/2012", periods=n)
  429:         df["dates2"] = date_range("1/1/2013", periods=n)
  430:         df["dates3"] = date_range("1/1/2014", periods=n)
  431:         df.loc[np.random.default_rng(2).random(n) > 0.5, "dates1"] = pd.NaT
  432:         df.loc[np.random.default_rng(2).random(n) > 0.5, "dates3"] = pd.NaT
  433:         res = df.query("dates1 < 20130101 < dates3", engine=engine, parser=parser)
  434:         expec = df[(df.dates1 < "20130101") & ("20130101" < df.dates3)]
  435:         tm.assert_frame_equal(res, expec)
  436: 
  437:     def test_date_index_query(self, engine, parser):
  438:         n = 10
  439:         df = DataFrame(np.random.default_rng(2).standard_normal((n, 3)))
  440:         df["dates1"] = date_range("1/1/2012", periods=n)
  441:         df["dates3"] = date_range("1/1/2014", periods=n)
  442:         return_value = df.set_index("dates1", inplace=True, drop=True)
  443:         assert return_value is None
  444:         res = df.query("index < 20130101 < dates3", engine=engine, parser=parser)
  445:         expec = df[(df.index < "20130101") & ("20130101" < df.dates3)]
  446:         tm.assert_frame_equal(res, expec)
  447: 
  448:     def test_date_index_query_with_NaT(self, engine, parser):
  449:         n = 10
  450:         # Cast to object to avoid implicit cast when setting entry to pd.NaT below
  451:         df = DataFrame(np.random.default_rng(2).standard_normal((n, 3))).astype(
  452:             {0: object}
  453:         )
  454:         df["dates1"] = date_range("1/1/2012", periods=n)
  455:         df["dates3"] = date_range("1/1/2014", periods=n)
  456:         df.iloc[0, 0] = pd.NaT
  457:         return_value = df.set_index("dates1", inplace=True, drop=True)
  458:         assert return_value is None
  459:         res = df.query("index < 20130101 < dates3", engine=engine, parser=parser)
  460:         expec = df[(df.index < "20130101") & ("20130101" < df.dates3)]
  461:         tm.assert_frame_equal(res, expec)
  462: 
  463:     def test_date_index_query_with_NaT_duplicates(self, engine, parser):
  464:         n = 10
  465:         d = {}
  466:         d["dates1"] = date_range("1/1/2012", periods=n)
  467:         d["dates3"] = date_range("1/1/2014", periods=n)
  468:         df = DataFrame(d)
  469:         df.loc[np.random.default_rng(2).random(n) > 0.5, "dates1"] = pd.NaT
  470:         return_value = df.set_index("dates1", inplace=True, drop=True)
  471:         assert return_value is None
  472:         res = df.query("dates1 < 20130101 < dates3", engine=engine, parser=parser)
  473:         expec = df[(df.index.to_series() < "20130101") & ("20130101" < df.dates3)]
  474:         tm.assert_frame_equal(res, expec)
  475: 
  476:     def test_date_query_with_non_date(self, engine, parser):
  477:         n = 10
  478:         df = DataFrame(
  479:             {"dates": date_range("1/1/2012", periods=n), "nondate": np.arange(n)}
  480:         )
  481: 
  482:         result = df.query("dates == nondate", parser=parser, engine=engine)
  483:         assert len(result) == 0
  484: 
  485:         result = df.query("dates != nondate", parser=parser, engine=engine)
  486:         tm.assert_frame_equal(result, df)
  487: 
  488:         msg = r"Invalid comparison between dtype=datetime64\[ns\] and ndarray"
  489:         for op in ["<", ">", "<=", ">="]:
  490:             with pytest.raises(TypeError, match=msg):
  491:                 df.query(f"dates {op} nondate", parser=parser, engine=engine)
  492: 
  493:     def test_query_syntax_error(self, engine, parser):
  494:         df = DataFrame({"i": range(10), "+": range(3, 13), "r": range(4, 14)})
  495:         msg = "invalid syntax"
  496:         with pytest.raises(SyntaxError, match=msg):
  497:             df.query("i - +", engine=engine, parser=parser)
  498: 
  499:     def test_query_scope(self, engine, parser):
  500:         skip_if_no_pandas_parser(parser)
  501: 
  502:         df = DataFrame(
  503:             np.random.default_rng(2).standard_normal((20, 2)), columns=list("ab")
  504:         )
  505: 
  506:         a, b = 1, 2  # noqa: F841
  507:         res = df.query("a > b", engine=engine, parser=parser)
  508:         expected = df[df.a > df.b]
  509:         tm.assert_frame_equal(res, expected)
  510: 
  511:         res = df.query("@a > b", engine=engine, parser=parser)
  512:         expected = df[a > df.b]
  513:         tm.assert_frame_equal(res, expected)
  514: 
  515:         # no local variable c
  516:         with pytest.raises(
  517:             UndefinedVariableError, match="local variable 'c' is not defined"
  518:         ):
  519:             df.query("@a > b > @c", engine=engine, parser=parser)
  520: 
  521:         # no column named 'c'
  522:         with pytest.raises(UndefinedVariableError, match="name 'c' is not defined"):
  523:             df.query("@a > b > c", engine=engine, parser=parser)
  524: 
  525:     def test_query_doesnt_pickup_local(self, engine, parser):
  526:         n = m = 10
  527:         df = DataFrame(
  528:             np.random.default_rng(2).integers(m, size=(n, 3)), columns=list("abc")
  529:         )
  530: 
  531:         # we don't pick up the local 'sin'
  532:         with pytest.raises(UndefinedVariableError, match="name 'sin' is not defined"):
  533:             df.query("sin > 5", engine=engine, parser=parser)
  534: 
  535:     def test_query_builtin(self, engine, parser):
  536:         n = m = 10
  537:         df = DataFrame(
  538:             np.random.default_rng(2).integers(m, size=(n, 3)), columns=list("abc")
  539:         )
  540: 
  541:         df.index.name = "sin"
  542:         msg = "Variables in expression.+"
  543:         with pytest.raises(NumExprClobberingError, match=msg):
  544:             df.query("sin > 5", engine=engine, parser=parser)
  545: 
  546:     def test_query(self, engine, parser):
  547:         df = DataFrame(
  548:             np.random.default_rng(2).standard_normal((10, 3)), columns=["a", "b", "c"]
  549:         )
  550: 
  551:         tm.assert_frame_equal(
  552:             df.query("a < b", engine=engine, parser=parser), df[df.a < df.b]
  553:         )
  554:         tm.assert_frame_equal(
  555:             df.query("a + b > b * c", engine=engine, parser=parser),
  556:             df[df.a + df.b > df.b * df.c],
  557:         )
  558: 
  559:     def test_query_index_with_name(self, engine, parser):
  560:         df = DataFrame(
  561:             np.random.default_rng(2).integers(10, size=(10, 3)),
  562:             index=Index(range(10), name="blob"),
  563:             columns=["a", "b", "c"],
  564:         )
  565:         res = df.query("(blob < 5) & (a < b)", engine=engine, parser=parser)
  566:         expec = df[(df.index < 5) & (df.a < df.b)]
  567:         tm.assert_frame_equal(res, expec)
  568: 
  569:         res = df.query("blob < b", engine=engine, parser=parser)
  570:         expec = df[df.index < df.b]
  571: 
  572:         tm.assert_frame_equal(res, expec)
  573: 
  574:     def test_query_index_without_name(self, engine, parser):
  575:         df = DataFrame(
  576:             np.random.default_rng(2).integers(10, size=(10, 3)),
  577:             index=range(10),
  578:             columns=["a", "b", "c"],
  579:         )
  580: 
  581:         # "index" should refer to the index
  582:         res = df.query("index < b", engine=engine, parser=parser)
  583:         expec = df[df.index < df.b]
  584:         tm.assert_frame_equal(res, expec)
  585: 
  586:         # test against a scalar
  587:         res = df.query("index < 5", engine=engine, parser=parser)
  588:         expec = df[df.index < 5]
  589:         tm.assert_frame_equal(res, expec)
  590: 
  591:     def test_nested_scope(self, engine, parser):
  592:         skip_if_no_pandas_parser(parser)
  593: 
  594:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
  595:         df2 = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
  596:         expected = df[(df > 0) & (df2 > 0)]
  597: 
  598:         result = df.query("(@df > 0) & (@df2 > 0)", engine=engine, parser=parser)
  599:         tm.assert_frame_equal(result, expected)
  600: 
  601:         result = pd.eval("df[df > 0 and df2 > 0]", engine=engine, parser=parser)
  602:         tm.assert_frame_equal(result, expected)
  603: 
  604:         result = pd.eval(
  605:             "df[df > 0 and df2 > 0 and df[df > 0] > 0]", engine=engine, parser=parser
  606:         )
  607:         expected = df[(df > 0) & (df2 > 0) & (df[df > 0] > 0)]
  608:         tm.assert_frame_equal(result, expected)
  609: 
  610:         result = pd.eval("df[(df>0) & (df2>0)]", engine=engine, parser=parser)
  611:         expected = df.query("(@df>0) & (@df2>0)", engine=engine, parser=parser)
  612:         tm.assert_frame_equal(result, expected)
  613: 
  614:     def test_nested_raises_on_local_self_reference(self, engine, parser):
  615:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
  616: 
  617:         # can't reference ourself b/c we're a local so @ is necessary
  618:         with pytest.raises(UndefinedVariableError, match="name 'df' is not defined"):
  619:             df.query("df > 0", engine=engine, parser=parser)
  620: 
  621:     def test_local_syntax(self, engine, parser):
  622:         skip_if_no_pandas_parser(parser)
  623: 
  624:         df = DataFrame(
  625:             np.random.default_rng(2).standard_normal((100, 10)),
  626:             columns=list("abcdefghij"),
  627:         )
  628:         b = 1
  629:         expect = df[df.a < b]
  630:         result = df.query("a < @b", engine=engine, parser=parser)
  631:         tm.assert_frame_equal(result, expect)
  632: 
  633:         expect = df[df.a < df.b]
  634:         result = df.query("a < b", engine=engine, parser=parser)
  635:         tm.assert_frame_equal(result, expect)
  636: 
  637:     def test_chained_cmp_and_in(self, engine, parser):
  638:         skip_if_no_pandas_parser(parser)
  639:         cols = list("abc")
  640:         df = DataFrame(
  641:             np.random.default_rng(2).standard_normal((100, len(cols))), columns=cols
  642:         )
  643:         res = df.query(
  644:             "a < b < c and a not in b not in c", engine=engine, parser=parser
  645:         )
  646:         ind = (df.a < df.b) & (df.b < df.c) & ~df.b.isin(df.a) & ~df.c.isin(df.b)
  647:         expec = df[ind]
  648:         tm.assert_frame_equal(res, expec)
  649: 
  650:     def test_local_variable_with_in(self, engine, parser):
  651:         skip_if_no_pandas_parser(parser)
  652:         a = Series(np.random.default_rng(2).integers(3, size=15), name="a")
  653:         b = Series(np.random.default_rng(2).integers(10, size=15), name="b")
  654:         df = DataFrame({"a": a, "b": b})
  655: 
  656:         expected = df.loc[(df.b - 1).isin(a)]
  657:         result = df.query("b - 1 in a", engine=engine, parser=parser)
  658:         tm.assert_frame_equal(expected, result)
  659: 
  660:         b = Series(np.random.default_rng(2).integers(10, size=15), name="b")
  661:         expected = df.loc[(b - 1).isin(a)]
  662:         result = df.query("@b - 1 in a", engine=engine, parser=parser)
  663:         tm.assert_frame_equal(expected, result)
  664: 
  665:     def test_at_inside_string(self, engine, parser):
  666:         skip_if_no_pandas_parser(parser)
  667:         c = 1  # noqa: F841
  668:         df = DataFrame({"a": ["a", "a", "b", "b", "@c", "@c"]})
  669:         result = df.query('a == "@c"', engine=engine, parser=parser)
  670:         expected = df[df.a == "@c"]
  671:         tm.assert_frame_equal(result, expected)
  672: 
  673:     def test_query_undefined_local(self):
  674:         engine, parser = self.engine, self.parser
  675:         skip_if_no_pandas_parser(parser)
  676: 
  677:         df = DataFrame(np.random.default_rng(2).random((10, 2)), columns=list("ab"))
  678:         with pytest.raises(
  679:             UndefinedVariableError, match="local variable 'c' is not defined"
  680:         ):
  681:             df.query("a == @c", engine=engine, parser=parser)
  682: 
  683:     def test_index_resolvers_come_after_columns_with_the_same_name(
  684:         self, engine, parser
  685:     ):
  686:         n = 1  # noqa: F841
  687:         a = np.r_[20:101:20]
  688: 
  689:         df = DataFrame(
  690:             {"index": a, "b": np.random.default_rng(2).standard_normal(a.size)}
  691:         )
  692:         df.index.name = "index"
  693:         result = df.query("index > 5", engine=engine, parser=parser)
  694:         expected = df[df["index"] > 5]
  695:         tm.assert_frame_equal(result, expected)
  696: 
  697:         df = DataFrame(
  698:             {"index": a, "b": np.random.default_rng(2).standard_normal(a.size)}
  699:         )
  700:         result = df.query("ilevel_0 > 5", engine=engine, parser=parser)
  701:         expected = df.loc[df.index[df.index > 5]]
  702:         tm.assert_frame_equal(result, expected)
  703: 
  704:         df = DataFrame({"a": a, "b": np.random.default_rng(2).standard_normal(a.size)})
  705:         df.index.name = "a"
  706:         result = df.query("a > 5", engine=engine, parser=parser)
  707:         expected = df[df.a > 5]
  708:         tm.assert_frame_equal(result, expected)
  709: 
  710:         result = df.query("index > 5", engine=engine, parser=parser)
  711:         expected = df.loc[df.index[df.index > 5]]
  712:         tm.assert_frame_equal(result, expected)
  713: 
  714:     @pytest.mark.parametrize("op, f", [["==", operator.eq], ["!=", operator.ne]])
  715:     def test_inf(self, op, f, engine, parser):
  716:         n = 10
  717:         df = DataFrame(
  718:             {
  719:                 "a": np.random.default_rng(2).random(n),
  720:                 "b": np.random.default_rng(2).random(n),
  721:             }
  722:         )
  723:         df.loc[::2, 0] = np.inf
  724:         q = f"a {op} inf"
  725:         expected = df[f(df.a, np.inf)]
  726:         result = df.query(q, engine=engine, parser=parser)
  727:         tm.assert_frame_equal(result, expected)
  728: 
  729:     def test_check_tz_aware_index_query(self, tz_aware_fixture):
  730:         # https://github.com/pandas-dev/pandas/issues/29463
  731:         tz = tz_aware_fixture
  732:         df_index = date_range(
  733:             start="2019-01-01", freq="1d", periods=10, tz=tz, name="time"
  734:         )
  735:         expected = DataFrame(index=df_index)
  736:         df = DataFrame(index=df_index)
  737:         result = df.query('"2018-01-03 00:00:00+00" < time')
  738:         tm.assert_frame_equal(result, expected)
  739: 
  740:         expected = DataFrame(df_index)
  741:         result = df.reset_index().query('"2018-01-03 00:00:00+00" < time')
  742:         tm.assert_frame_equal(result, expected)
  743: 
  744:     def test_method_calls_in_query(self, engine, parser):
  745:         # https://github.com/pandas-dev/pandas/issues/22435
  746:         n = 10
  747:         df = DataFrame(
  748:             {
  749:                 "a": 2 * np.random.default_rng(2).random(n),
  750:                 "b": np.random.default_rng(2).random(n),
  751:             }
  752:         )
  753:         expected = df[df["a"].astype("int") == 0]
  754:         result = df.query("a.astype('int') == 0", engine=engine, parser=parser)
  755:         tm.assert_frame_equal(result, expected)
  756: 
  757:         df = DataFrame(
  758:             {
  759:                 "a": np.where(
  760:                     np.random.default_rng(2).random(n) < 0.5,
  761:                     np.nan,
  762:                     np.random.default_rng(2).standard_normal(n),
  763:                 ),
  764:                 "b": np.random.default_rng(2).standard_normal(n),
  765:             }
  766:         )
  767:         expected = df[df["a"].notnull()]
  768:         result = df.query("a.notnull()", engine=engine, parser=parser)
  769:         tm.assert_frame_equal(result, expected)
  770: 
  771: 
  772: @td.skip_if_no("numexpr")
  773: class TestDataFrameQueryNumExprPython(TestDataFrameQueryNumExprPandas):
  774:     @pytest.fixture
  775:     def engine(self):
  776:         return "numexpr"
  777: 
  778:     @pytest.fixture
  779:     def parser(self):
  780:         return "python"
  781: 
  782:     def test_date_query_no_attribute_access(self, engine, parser):
  783:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
  784:         df["dates1"] = date_range("1/1/2012", periods=5)
  785:         df["dates2"] = date_range("1/1/2013", periods=5)
  786:         df["dates3"] = date_range("1/1/2014", periods=5)
  787:         res = df.query(
  788:             "(dates1 < 20130101) & (20130101 < dates3)", engine=engine, parser=parser
  789:         )
  790:         expec = df[(df.dates1 < "20130101") & ("20130101" < df.dates3)]
  791:         tm.assert_frame_equal(res, expec)
  792: 
  793:     def test_date_query_with_NaT(self, engine, parser):
  794:         n = 10
  795:         df = DataFrame(np.random.default_rng(2).standard_normal((n, 3)))
  796:         df["dates1"] = date_range("1/1/2012", periods=n)
  797:         df["dates2"] = date_range("1/1/2013", periods=n)
  798:         df["dates3"] = date_range("1/1/2014", periods=n)
  799:         df.loc[np.random.default_rng(2).random(n) > 0.5, "dates1"] = pd.NaT
  800:         df.loc[np.random.default_rng(2).random(n) > 0.5, "dates3"] = pd.NaT
  801:         res = df.query(
  802:             "(dates1 < 20130101) & (20130101 < dates3)", engine=engine, parser=parser
  803:         )
  804:         expec = df[(df.dates1 < "20130101") & ("20130101" < df.dates3)]
  805:         tm.assert_frame_equal(res, expec)
  806: 
  807:     def test_date_index_query(self, engine, parser):
  808:         n = 10
  809:         df = DataFrame(np.random.default_rng(2).standard_normal((n, 3)))
  810:         df["dates1"] = date_range("1/1/2012", periods=n)
  811:         df["dates3"] = date_range("1/1/2014", periods=n)
  812:         return_value = df.set_index("dates1", inplace=True, drop=True)
  813:         assert return_value is None
  814:         res = df.query(
  815:             "(index < 20130101) & (20130101 < dates3)", engine=engine, parser=parser
  816:         )
  817:         expec = df[(df.index < "20130101") & ("20130101" < df.dates3)]
  818:         tm.assert_frame_equal(res, expec)
  819: 
  820:     def test_date_index_query_with_NaT(self, engine, parser):
  821:         n = 10
  822:         # Cast to object to avoid implicit cast when setting entry to pd.NaT below
  823:         df = DataFrame(np.random.default_rng(2).standard_normal((n, 3))).astype(
  824:             {0: object}
  825:         )
  826:         df["dates1"] = date_range("1/1/2012", periods=n)
  827:         df["dates3"] = date_range("1/1/2014", periods=n)
  828:         df.iloc[0, 0] = pd.NaT
  829:         return_value = df.set_index("dates1", inplace=True, drop=True)
  830:         assert return_value is None
  831:         res = df.query(
  832:             "(index < 20130101) & (20130101 < dates3)", engine=engine, parser=parser
  833:         )
  834:         expec = df[(df.index < "20130101") & ("20130101" < df.dates3)]
  835:         tm.assert_frame_equal(res, expec)
  836: 
  837:     def test_date_index_query_with_NaT_duplicates(self, engine, parser):
  838:         n = 10
  839:         df = DataFrame(np.random.default_rng(2).standard_normal((n, 3)))
  840:         df["dates1"] = date_range("1/1/2012", periods=n)
  841:         df["dates3"] = date_range("1/1/2014", periods=n)
  842:         df.loc[np.random.default_rng(2).random(n) > 0.5, "dates1"] = pd.NaT
  843:         return_value = df.set_index("dates1", inplace=True, drop=True)
  844:         assert return_value is None
  845:         msg = r"'BoolOp' nodes are not implemented"
  846:         with pytest.raises(NotImplementedError, match=msg):
  847:             df.query("index < 20130101 < dates3", engine=engine, parser=parser)
  848: 
  849:     def test_nested_scope(self, engine, parser):
  850:         # smoke test
  851:         x = 1  # noqa: F841
  852:         result = pd.eval("x + 1", engine=engine, parser=parser)
  853:         assert result == 2
  854: 
  855:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
  856:         df2 = DataFrame(np.random.default_rng(2).standard_normal((5, 3)))
  857: 
  858:         # don't have the pandas parser
  859:         msg = r"The '@' prefix is only supported by the pandas parser"
  860:         with pytest.raises(SyntaxError, match=msg):
  861:             df.query("(@df>0) & (@df2>0)", engine=engine, parser=parser)
  862: 
  863:         with pytest.raises(UndefinedVariableError, match="name 'df' is not defined"):
  864:             df.query("(df>0) & (df2>0)", engine=engine, parser=parser)
  865: 
  866:         expected = df[(df > 0) & (df2 > 0)]
  867:         result = pd.eval("df[(df > 0) & (df2 > 0)]", engine=engine, parser=parser)
  868:         tm.assert_frame_equal(expected, result)
  869: 
  870:         expected = df[(df > 0) & (df2 > 0) & (df[df > 0] > 0)]
  871:         result = pd.eval(
  872:             "df[(df > 0) & (df2 > 0) & (df[df > 0] > 0)]", engine=engine, parser=parser
  873:         )
  874:         tm.assert_frame_equal(expected, result)
  875: 
  876:     def test_query_numexpr_with_min_and_max_columns(self):
  877:         df = DataFrame({"min": [1, 2, 3], "max": [4, 5, 6]})
  878:         regex_to_match = (
  879:             r"Variables in expression \"\(min\) == \(1\)\" "
  880:             r"overlap with builtins: \('min'\)"
  881:         )
  882:         with pytest.raises(NumExprClobberingError, match=regex_to_match):
  883:             df.query("min == 1")
  884: 
  885:         regex_to_match = (
  886:             r"Variables in expression \"\(max\) == \(1\)\" "
  887:             r"overlap with builtins: \('max'\)"
  888:         )
  889:         with pytest.raises(NumExprClobberingError, match=regex_to_match):
  890:             df.query("max == 1")
  891: 
  892: 
  893: class TestDataFrameQueryPythonPandas(TestDataFrameQueryNumExprPandas):
  894:     @pytest.fixture
  895:     def engine(self):
  896:         return "python"
  897: 
  898:     @pytest.fixture
  899:     def parser(self):
  900:         return "pandas"
  901: 
  902:     def test_query_builtin(self, engine, parser):
  903:         n = m = 10
  904:         df = DataFrame(
  905:             np.random.default_rng(2).integers(m, size=(n, 3)), columns=list("abc")
  906:         )
  907: 
  908:         df.index.name = "sin"
  909:         expected = df[df.index > 5]
  910:         result = df.query("sin > 5", engine=engine, parser=parser)
  911:         tm.assert_frame_equal(expected, result)
  912: 
  913: 
  914: class TestDataFrameQueryPythonPython(TestDataFrameQueryNumExprPython):
  915:     @pytest.fixture
  916:     def engine(self):
  917:         return "python"
  918: 
  919:     @pytest.fixture
  920:     def parser(self):
  921:         return "python"
  922: 
  923:     def test_query_builtin(self, engine, parser):
  924:         n = m = 10
  925:         df = DataFrame(
  926:             np.random.default_rng(2).integers(m, size=(n, 3)), columns=list("abc")
  927:         )
  928: 
  929:         df.index.name = "sin"
  930:         expected = df[df.index > 5]
  931:         result = df.query("sin > 5", engine=engine, parser=parser)
  932:         tm.assert_frame_equal(expected, result)
  933: 
  934: 
  935: class TestDataFrameQueryStrings:
  936:     def test_str_query_method(self, parser, engine):
  937:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 1)), columns=["b"])
  938:         df["strings"] = Series(list("aabbccddee"))
  939:         expect = df[df.strings == "a"]
  940: 
  941:         if parser != "pandas":
  942:             col = "strings"
  943:             lst = '"a"'
  944: 
  945:             lhs = [col] * 2 + [lst] * 2
  946:             rhs = lhs[::-1]
  947: 
  948:             eq, ne = "==", "!="
  949:             ops = 2 * ([eq] + [ne])
  950:             msg = r"'(Not)?In' nodes are not implemented"
  951: 
  952:             for lhs, op, rhs in zip(lhs, ops, rhs):
  953:                 ex = f"{lhs} {op} {rhs}"
  954:                 with pytest.raises(NotImplementedError, match=msg):
  955:                     df.query(
  956:                         ex,
  957:                         engine=engine,
  958:                         parser=parser,
  959:                         local_dict={"strings": df.strings},
  960:                     )
  961:         else:
  962:             res = df.query('"a" == strings', engine=engine, parser=parser)
  963:             tm.assert_frame_equal(res, expect)
  964: 
  965:             res = df.query('strings == "a"', engine=engine, parser=parser)
  966:             tm.assert_frame_equal(res, expect)
  967:             tm.assert_frame_equal(res, df[df.strings.isin(["a"])])
  968: 
  969:             expect = df[df.strings != "a"]
  970:             res = df.query('strings != "a"', engine=engine, parser=parser)
  971:             tm.assert_frame_equal(res, expect)
  972: 
  973:             res = df.query('"a" != strings', engine=engine, parser=parser)
  974:             tm.assert_frame_equal(res, expect)
  975:             tm.assert_frame_equal(res, df[~df.strings.isin(["a"])])
  976: 
  977:     def test_str_list_query_method(self, parser, engine):
  978:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 1)), columns=["b"])
  979:         df["strings"] = Series(list("aabbccddee"))
  980:         expect = df[df.strings.isin(["a", "b"])]
  981: 
  982:         if parser != "pandas":
  983:             col = "strings"
  984:             lst = '["a", "b"]'
  985: 
  986:             lhs = [col] * 2 + [lst] * 2
  987:             rhs = lhs[::-1]
  988: 
  989:             eq, ne = "==", "!="
  990:             ops = 2 * ([eq] + [ne])
  991:             msg = r"'(Not)?In' nodes are not implemented"
  992: 
  993:             for lhs, op, rhs in zip(lhs, ops, rhs):
  994:                 ex = f"{lhs} {op} {rhs}"
  995:                 with pytest.raises(NotImplementedError, match=msg):
  996:                     df.query(ex, engine=engine, parser=parser)
  997:         else:
  998:             res = df.query('strings == ["a", "b"]', engine=engine, parser=parser)
  999:             tm.assert_frame_equal(res, expect)
 1000: 
 1001:             res = df.query('["a", "b"] == strings', engine=engine, parser=parser)
 1002:             tm.assert_frame_equal(res, expect)
 1003: 
 1004:             expect = df[~df.strings.isin(["a", "b"])]
 1005: 
 1006:             res = df.query('strings != ["a", "b"]', engine=engine, parser=parser)
 1007:             tm.assert_frame_equal(res, expect)
 1008: 
 1009:             res = df.query('["a", "b"] != strings', engine=engine, parser=parser)
 1010:             tm.assert_frame_equal(res, expect)
 1011: 
 1012:     def test_query_with_string_columns(self, parser, engine):
 1013:         df = DataFrame(
 1014:             {
 1015:                 "a": list("aaaabbbbcccc"),
 1016:                 "b": list("aabbccddeeff"),
 1017:                 "c": np.random.default_rng(2).integers(5, size=12),
 1018:                 "d": np.random.default_rng(2).integers(9, size=12),
 1019:             }
 1020:         )
 1021:         if parser == "pandas":
 1022:             res = df.query("a in b", parser=parser, engine=engine)
 1023:             expec = df[df.a.isin(df.b)]
 1024:             tm.assert_frame_equal(res, expec)
 1025: 
 1026:             res = df.query("a in b and c < d", parser=parser, engine=engine)
 1027:             expec = df[df.a.isin(df.b) & (df.c < df.d)]
 1028:             tm.assert_frame_equal(res, expec)
 1029:         else:
 1030:             msg = r"'(Not)?In' nodes are not implemented"
 1031:             with pytest.raises(NotImplementedError, match=msg):
 1032:                 df.query("a in b", parser=parser, engine=engine)
 1033: 
 1034:             msg = r"'BoolOp' nodes are not implemented"
 1035:             with pytest.raises(NotImplementedError, match=msg):
 1036:                 df.query("a in b and c < d", parser=parser, engine=engine)
 1037: 
 1038:     def test_object_array_eq_ne(self, parser, engine, using_infer_string):
 1039:         df = DataFrame(
 1040:             {
 1041:                 "a": list("aaaabbbbcccc"),
 1042:                 "b": list("aabbccddeeff"),
 1043:                 "c": np.random.default_rng(2).integers(5, size=12),
 1044:                 "d": np.random.default_rng(2).integers(9, size=12),
 1045:             }
 1046:         )
 1047:         warning = RuntimeWarning if using_infer_string and engine == "numexpr" else None
 1048:         with tm.assert_produces_warning(warning):
 1049:             res = df.query("a == b", parser=parser, engine=engine)
 1050:         exp = df[df.a == df.b]
 1051:         tm.assert_frame_equal(res, exp)
 1052: 
 1053:         with tm.assert_produces_warning(warning):
 1054:             res = df.query("a != b", parser=parser, engine=engine)
 1055:         exp = df[df.a != df.b]
 1056:         tm.assert_frame_equal(res, exp)
 1057: 
 1058:     def test_query_with_nested_strings(self, parser, engine):
 1059:         skip_if_no_pandas_parser(parser)
 1060:         events = [
 1061:             f"page {n} {act}" for n in range(1, 4) for act in ["load", "exit"]
 1062:         ] * 2
 1063:         stamps1 = date_range("2014-01-01 0:00:01", freq="30s", periods=6)
 1064:         stamps2 = date_range("2014-02-01 1:00:01", freq="30s", periods=6)
 1065:         df = DataFrame(
 1066:             {
 1067:                 "id": np.arange(1, 7).repeat(2),
 1068:                 "event": events,
 1069:                 "timestamp": stamps1.append(stamps2),
 1070:             }
 1071:         )
 1072: 
 1073:         expected = df[df.event == '"page 1 load"']
 1074:         res = df.query("""'"page 1 load"' in event""", parser=parser, engine=engine)
 1075:         tm.assert_frame_equal(expected, res)
 1076: 
 1077:     def test_query_with_nested_special_character(self, parser, engine):
 1078:         skip_if_no_pandas_parser(parser)
 1079:         df = DataFrame({"a": ["a", "b", "test & test"], "b": [1, 2, 3]})
 1080:         res = df.query('a == "test & test"', parser=parser, engine=engine)
 1081:         expec = df[df.a == "test & test"]
 1082:         tm.assert_frame_equal(res, expec)
 1083: 
 1084:     @pytest.mark.parametrize(
 1085:         "op, func",
 1086:         [
 1087:             ["<", operator.lt],
 1088:             [">", operator.gt],
 1089:             ["<=", operator.le],
 1090:             [">=", operator.ge],
 1091:         ],
 1092:     )
 1093:     def test_query_lex_compare_strings(
 1094:         self, parser, engine, op, func, using_infer_string
 1095:     ):
 1096:         a = Series(np.random.default_rng(2).choice(list("abcde"), 20))
 1097:         b = Series(np.arange(a.size))
 1098:         df = DataFrame({"X": a, "Y": b})
 1099: 
 1100:         warning = RuntimeWarning if using_infer_string and engine == "numexpr" else None
 1101:         with tm.assert_produces_warning(warning):
 1102:             res = df.query(f'X {op} "d"', engine=engine, parser=parser)
 1103:         expected = df[func(df.X, "d")]
 1104:         tm.assert_frame_equal(res, expected)
 1105: 
 1106:     def test_query_single_element_booleans(self, parser, engine):
 1107:         columns = "bid", "bidsize", "ask", "asksize"
 1108:         data = np.random.default_rng(2).integers(2, size=(1, len(columns))).astype(bool)
 1109:         df = DataFrame(data, columns=columns)
 1110:         res = df.query("bid & ask", engine=engine, parser=parser)
 1111:         expected = df[df.bid & df.ask]
 1112:         tm.assert_frame_equal(res, expected)
 1113: 
 1114:     def test_query_string_scalar_variable(self, parser, engine):
 1115:         skip_if_no_pandas_parser(parser)
 1116:         df = DataFrame(
 1117:             {
 1118:                 "Symbol": ["BUD US", "BUD US", "IBM US", "IBM US"],
 1119:                 "Price": [109.70, 109.72, 183.30, 183.35],
 1120:             }
 1121:         )
 1122:         e = df[df.Symbol == "BUD US"]
 1123:         symb = "BUD US"  # noqa: F841
 1124:         r = df.query("Symbol == @symb", parser=parser, engine=engine)
 1125:         tm.assert_frame_equal(e, r)
 1126: 
 1127:     @pytest.mark.parametrize(
 1128:         "in_list",
 1129:         [
 1130:             [None, "asdf", "ghjk"],
 1131:             ["asdf", None, "ghjk"],
 1132:             ["asdf", "ghjk", None],
 1133:             [None, None, "asdf"],
 1134:             ["asdf", None, None],
 1135:             [None, None, None],
 1136:         ],
 1137:     )
 1138:     def test_query_string_null_elements(self, in_list):
 1139:         # GITHUB ISSUE #31516
 1140:         parser = "pandas"
 1141:         engine = "python"
 1142:         expected = {i: value for i, value in enumerate(in_list) if value == "asdf"}
 1143: 
 1144:         df_expected = DataFrame({"a": expected}, dtype="string")
 1145:         df_expected.index = df_expected.index.astype("int64")
 1146:         df = DataFrame({"a": in_list}, dtype="string")
 1147:         res1 = df.query("a == 'asdf'", parser=parser, engine=engine)
 1148:         res2 = df[df["a"] == "asdf"]
 1149:         res3 = df.query("a <= 'asdf'", parser=parser, engine=engine)
 1150:         tm.assert_frame_equal(res1, df_expected)
 1151:         tm.assert_frame_equal(res1, res2)
 1152:         tm.assert_frame_equal(res1, res3)
 1153:         tm.assert_frame_equal(res2, res3)
 1154: 
 1155: 
 1156: class TestDataFrameEvalWithFrame:
 1157:     @pytest.fixture
 1158:     def frame(self):
 1159:         return DataFrame(
 1160:             np.random.default_rng(2).standard_normal((10, 3)), columns=list("abc")
 1161:         )
 1162: 
 1163:     def test_simple_expr(self, frame, parser, engine):
 1164:         res = frame.eval("a + b", engine=engine, parser=parser)
 1165:         expect = frame.a + frame.b
 1166:         tm.assert_series_equal(res, expect)
 1167: 
 1168:     def test_bool_arith_expr(self, frame, parser, engine):
 1169:         res = frame.eval("a[a < 1] + b", engine=engine, parser=parser)
 1170:         expect = frame.a[frame.a < 1] + frame.b
 1171:         tm.assert_series_equal(res, expect)
 1172: 
 1173:     @pytest.mark.parametrize("op", ["+", "-", "*", "/"])
 1174:     def test_invalid_type_for_operator_raises(self, parser, engine, op):
 1175:         df = DataFrame({"a": [1, 2], "b": ["c", "d"]})
 1176:         msg = r"unsupported operand type\(s\) for .+: '.+' and '.+'|Cannot"
 1177: 
 1178:         with pytest.raises(TypeError, match=msg):
 1179:             df.eval(f"a {op} b", engine=engine, parser=parser)
 1180: 
 1181: 
 1182: class TestDataFrameQueryBacktickQuoting:
 1183:     @pytest.fixture
 1184:     def df(self):
 1185:         """
 1186:         Yields a dataframe with strings that may or may not need escaping
 1187:         by backticks. The last two columns cannot be escaped by backticks
 1188:         and should raise a ValueError.
 1189:         """
 1190:         yield DataFrame(
 1191:             {
 1192:                 "A": [1, 2, 3],
 1193:                 "B B": [3, 2, 1],
 1194:                 "C C": [4, 5, 6],
 1195:                 "C  C": [7, 4, 3],
 1196:                 "C_C": [8, 9, 10],
 1197:                 "D_D D": [11, 1, 101],
 1198:                 "E.E": [6, 3, 5],
 1199:                 "F-F": [8, 1, 10],
 1200:                 "1e1": [2, 4, 8],
 1201:                 "def": [10, 11, 2],
 1202:                 "A (x)": [4, 1, 3],
 1203:                 "B(x)": [1, 1, 5],
 1204:                 "B (x)": [2, 7, 4],
 1205:                 "  &^ :!в‚¬$?(} >    <++*''  ": [2, 5, 6],
 1206:                 "": [10, 11, 1],
 1207:                 " A": [4, 7, 9],
 1208:                 "  ": [1, 2, 1],
 1209:                 "it's": [6, 3, 1],
 1210:                 "that's": [9, 1, 8],
 1211:                 "вє": [8, 7, 6],
 1212:                 "foo#bar": [2, 4, 5],
 1213:                 1: [5, 7, 9],
 1214:             }
 1215:         )
 1216: 
 1217:     def test_single_backtick_variable_query(self, df):
 1218:         res = df.query("1 < `B B`")
 1219:         expect = df[1 < df["B B"]]
 1220:         tm.assert_frame_equal(res, expect)
 1221: 
 1222:     def test_two_backtick_variables_query(self, df):
 1223:         res = df.query("1 < `B B` and 4 < `C C`")
 1224:         expect = df[(1 < df["B B"]) & (4 < df["C C"])]
 1225:         tm.assert_frame_equal(res, expect)
 1226: 
 1227:     def test_single_backtick_variable_expr(self, df):
 1228:         res = df.eval("A + `B B`")
 1229:         expect = df["A"] + df["B B"]
 1230:         tm.assert_series_equal(res, expect)
 1231: 
 1232:     def test_two_backtick_variables_expr(self, df):
 1233:         res = df.eval("`B B` + `C C`")
 1234:         expect = df["B B"] + df["C C"]
 1235:         tm.assert_series_equal(res, expect)
 1236: 
 1237:     def test_already_underscore_variable(self, df):
 1238:         res = df.eval("`C_C` + A")
 1239:         expect = df["C_C"] + df["A"]
 1240:         tm.assert_series_equal(res, expect)
 1241: 
 1242:     def test_same_name_but_underscores(self, df):
 1243:         res = df.eval("C_C + `C C`")
 1244:         expect = df["C_C"] + df["C C"]
 1245:         tm.assert_series_equal(res, expect)
 1246: 
 1247:     def test_mixed_underscores_and_spaces(self, df):
 1248:         res = df.eval("A + `D_D D`")
 1249:         expect = df["A"] + df["D_D D"]
 1250:         tm.assert_series_equal(res, expect)
 1251: 
 1252:     def test_backtick_quote_name_with_no_spaces(self, df):
 1253:         res = df.eval("A + `C_C`")
 1254:         expect = df["A"] + df["C_C"]
 1255:         tm.assert_series_equal(res, expect)
 1256: 
 1257:     def test_special_characters(self, df):
 1258:         res = df.eval("`E.E` + `F-F` - A")
 1259:         expect = df["E.E"] + df["F-F"] - df["A"]
 1260:         tm.assert_series_equal(res, expect)
 1261: 
 1262:     def test_start_with_digit(self, df):
 1263:         res = df.eval("A + `1e1`")
 1264:         expect = df["A"] + df["1e1"]
 1265:         tm.assert_series_equal(res, expect)
 1266: 
 1267:     def test_keyword(self, df):
 1268:         res = df.eval("A + `def`")
 1269:         expect = df["A"] + df["def"]
 1270:         tm.assert_series_equal(res, expect)
 1271: 
 1272:     def test_unneeded_quoting(self, df):
 1273:         res = df.query("`A` > 2")
 1274:         expect = df[df["A"] > 2]
 1275:         tm.assert_frame_equal(res, expect)
 1276: 
 1277:     def test_parenthesis(self, df):
 1278:         res = df.query("`A (x)` > 2")
 1279:         expect = df[df["A (x)"] > 2]
 1280:         tm.assert_frame_equal(res, expect)
 1281: 
 1282:     def test_empty_string(self, df):
 1283:         res = df.query("`` > 5")
 1284:         expect = df[df[""] > 5]
 1285:         tm.assert_frame_equal(res, expect)
 1286: 
 1287:     def test_multiple_spaces(self, df):
 1288:         res = df.query("`C  C` > 5")
 1289:         expect = df[df["C  C"] > 5]
 1290:         tm.assert_frame_equal(res, expect)
 1291: 
 1292:     def test_start_with_spaces(self, df):
 1293:         res = df.eval("` A` + `  `")
 1294:         expect = df[" A"] + df["  "]
 1295:         tm.assert_series_equal(res, expect)
 1296: 
 1297:     def test_lots_of_operators_string(self, df):
 1298:         res = df.query("`  &^ :!в‚¬$?(} >    <++*''  ` > 4")
 1299:         expect = df[df["  &^ :!в‚¬$?(} >    <++*''  "] > 4]
 1300:         tm.assert_frame_equal(res, expect)
 1301: 
 1302:     def test_missing_attribute(self, df):
 1303:         message = "module 'pandas' has no attribute 'thing'"
 1304:         with pytest.raises(AttributeError, match=message):
 1305:             df.eval("@pd.thing")
 1306: 
 1307:     def test_failing_quote(self, df):
 1308:         msg = r"(Could not convert ).*( to a valid Python identifier.)"
 1309:         with pytest.raises(SyntaxError, match=msg):
 1310:             df.query("`it's` > `that's`")
 1311: 
 1312:     def test_failing_character_outside_range(self, df):
 1313:         msg = r"(Could not convert ).*( to a valid Python identifier.)"
 1314:         with pytest.raises(SyntaxError, match=msg):
 1315:             df.query("`вє` > 4")
 1316: 
 1317:     def test_failing_hashtag(self, df):
 1318:         msg = "Failed to parse backticks"
 1319:         with pytest.raises(SyntaxError, match=msg):
 1320:             df.query("`foo#bar` > 4")
 1321: 
 1322:     def test_call_non_named_expression(self, df):
 1323:         """
 1324:         Only attributes and variables ('named functions') can be called.
 1325:         .__call__() is not an allowed attribute because that would allow
 1326:         calling anything.
 1327:         https://github.com/pandas-dev/pandas/pull/32460
 1328:         """
 1329: 
 1330:         def func(*_):
 1331:             return 1
 1332: 
 1333:         funcs = [func]  # noqa: F841
 1334: 
 1335:         df.eval("@func()")
 1336: 
 1337:         with pytest.raises(TypeError, match="Only named functions are supported"):
 1338:             df.eval("@funcs[0]()")
 1339: 
 1340:         with pytest.raises(TypeError, match="Only named functions are supported"):
 1341:             df.eval("@funcs[0].__call__()")
 1342: 
 1343:     def test_ea_dtypes(self, any_numeric_ea_and_arrow_dtype):
 1344:         # GH#29618
 1345:         df = DataFrame(
 1346:             [[1, 2], [3, 4]], columns=["a", "b"], dtype=any_numeric_ea_and_arrow_dtype
 1347:         )
 1348:         warning = RuntimeWarning if NUMEXPR_INSTALLED else None
 1349:         with tm.assert_produces_warning(warning):
 1350:             result = df.eval("c = b - a")
 1351:         expected = DataFrame(
 1352:             [[1, 2, 1], [3, 4, 1]],
 1353:             columns=["a", "b", "c"],
 1354:             dtype=any_numeric_ea_and_arrow_dtype,
 1355:         )
 1356:         tm.assert_frame_equal(result, expected)
 1357: 
 1358:     def test_ea_dtypes_and_scalar(self):
 1359:         # GH#29618
 1360:         df = DataFrame([[1, 2], [3, 4]], columns=["a", "b"], dtype="Float64")
 1361:         warning = RuntimeWarning if NUMEXPR_INSTALLED else None
 1362:         with tm.assert_produces_warning(warning):
 1363:             result = df.eval("c = b - 1")
 1364:         expected = DataFrame(
 1365:             [[1, 2, 1], [3, 4, 3]], columns=["a", "b", "c"], dtype="Float64"
 1366:         )
 1367:         tm.assert_frame_equal(result, expected)
 1368: 
 1369:     def test_ea_dtypes_and_scalar_operation(self, any_numeric_ea_and_arrow_dtype):
 1370:         # GH#29618
 1371:         df = DataFrame(
 1372:             [[1, 2], [3, 4]], columns=["a", "b"], dtype=any_numeric_ea_and_arrow_dtype
 1373:         )
 1374:         result = df.eval("c = 2 - 1")
 1375:         expected = DataFrame(
 1376:             {
 1377:                 "a": Series([1, 3], dtype=any_numeric_ea_and_arrow_dtype),
 1378:                 "b": Series([2, 4], dtype=any_numeric_ea_and_arrow_dtype),
 1379:                 "c": Series([1, 1], dtype=result["c"].dtype),
 1380:             }
 1381:         )
 1382:         tm.assert_frame_equal(result, expected)
 1383: 
 1384:     @pytest.mark.parametrize("dtype", ["int64", "Int64", "int64[pyarrow]"])
 1385:     def test_query_ea_dtypes(self, dtype):
 1386:         if dtype == "int64[pyarrow]":
 1387:             pytest.importorskip("pyarrow")
 1388:         # GH#50261
 1389:         df = DataFrame({"a": Series([1, 2], dtype=dtype)})
 1390:         ref = {2}  # noqa: F841
 1391:         warning = RuntimeWarning if dtype == "Int64" and NUMEXPR_INSTALLED else None
 1392:         with tm.assert_produces_warning(warning):
 1393:             result = df.query("a in @ref")
 1394:         expected = DataFrame({"a": Series([2], dtype=dtype, index=[1])})
 1395:         tm.assert_frame_equal(result, expected)
 1396: 
 1397:     @pytest.mark.parametrize("engine", ["python", "numexpr"])
 1398:     @pytest.mark.parametrize("dtype", ["int64", "Int64", "int64[pyarrow]"])
 1399:     def test_query_ea_equality_comparison(self, dtype, engine):
 1400:         # GH#50261
 1401:         warning = RuntimeWarning if engine == "numexpr" else None
 1402:         if engine == "numexpr" and not NUMEXPR_INSTALLED:
 1403:             pytest.skip("numexpr not installed")
 1404:         if dtype == "int64[pyarrow]":
 1405:             pytest.importorskip("pyarrow")
 1406:         df = DataFrame(
 1407:             {"A": Series([1, 1, 2], dtype="Int64"), "B": Series([1, 2, 2], dtype=dtype)}
 1408:         )
 1409:         with tm.assert_produces_warning(warning):
 1410:             result = df.query("A == B", engine=engine)
 1411:         expected = DataFrame(
 1412:             {
 1413:                 "A": Series([1, 2], dtype="Int64", index=[0, 2]),
 1414:                 "B": Series([1, 2], dtype=dtype, index=[0, 2]),
 1415:             }
 1416:         )
 1417:         tm.assert_frame_equal(result, expected)
 1418: 
 1419:     def test_all_nat_in_object(self):
 1420:         # GH#57068
 1421:         now = pd.Timestamp.now("UTC")  # noqa: F841
 1422:         df = DataFrame({"a": pd.to_datetime([None, None], utc=True)}, dtype=object)
 1423:         result = df.query("a > @now")
 1424:         expected = DataFrame({"a": []}, dtype=object)
 1425:         tm.assert_frame_equal(result, expected)
