    1: from collections import abc
    2: import email
    3: from email.parser import Parser
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas import (
    9:     CategoricalDtype,
   10:     DataFrame,
   11:     MultiIndex,
   12:     Series,
   13:     Timestamp,
   14:     date_range,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: class TestDataFrameToRecords:
   20:     def test_to_records_timeseries(self):
   21:         index = date_range("1/1/2000", periods=10)
   22:         df = DataFrame(
   23:             np.random.default_rng(2).standard_normal((10, 3)),
   24:             index=index,
   25:             columns=["a", "b", "c"],
   26:         )
   27: 
   28:         result = df.to_records()
   29:         assert result["index"].dtype == "M8[ns]"
   30: 
   31:         result = df.to_records(index=False)
   32: 
   33:     def test_to_records_dt64(self):
   34:         df = DataFrame(
   35:             [["one", "two", "three"], ["four", "five", "six"]],
   36:             index=date_range("2012-01-01", "2012-01-02"),
   37:         )
   38: 
   39:         expected = df.index.values[0]
   40:         result = df.to_records()["index"][0]
   41:         assert expected == result
   42: 
   43:     def test_to_records_dt64tz_column(self):
   44:         # GH#32535 dont less tz in to_records
   45:         df = DataFrame({"A": date_range("2012-01-01", "2012-01-02", tz="US/Eastern")})
   46: 
   47:         result = df.to_records()
   48: 
   49:         assert result.dtype["A"] == object
   50:         val = result[0][1]
   51:         assert isinstance(val, Timestamp)
   52:         assert val == df.loc[0, "A"]
   53: 
   54:     def test_to_records_with_multindex(self):
   55:         # GH#3189
   56:         index = [
   57:             ["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"],
   58:             ["one", "two", "one", "two", "one", "two", "one", "two"],
   59:         ]
   60:         data = np.zeros((8, 4))
   61:         df = DataFrame(data, index=index)
   62:         r = df.to_records(index=True)["level_0"]
   63:         assert "bar" in r
   64:         assert "one" not in r
   65: 
   66:     def test_to_records_with_Mapping_type(self):
   67:         abc.Mapping.register(email.message.Message)
   68: 
   69:         headers = Parser().parsestr(
   70:             "From: <user@example.com>\n"
   71:             "To: <someone_else@example.com>\n"
   72:             "Subject: Test message\n"
   73:             "\n"
   74:             "Body would go here\n"
   75:         )
   76: 
   77:         frame = DataFrame.from_records([headers])
   78:         all(x in frame for x in ["Type", "Subject", "From"])
   79: 
   80:     def test_to_records_floats(self):
   81:         df = DataFrame(np.random.default_rng(2).random((10, 10)))
   82:         df.to_records()
   83: 
   84:     def test_to_records_index_name(self):
   85:         df = DataFrame(np.random.default_rng(2).standard_normal((3, 3)))
   86:         df.index.name = "X"
   87:         rs = df.to_records()
   88:         assert "X" in rs.dtype.fields
   89: 
   90:         df = DataFrame(np.random.default_rng(2).standard_normal((3, 3)))
   91:         rs = df.to_records()
   92:         assert "index" in rs.dtype.fields
   93: 
   94:         df.index = MultiIndex.from_tuples([("a", "x"), ("a", "y"), ("b", "z")])
   95:         df.index.names = ["A", None]
   96:         result = df.to_records()
   97:         expected = np.rec.fromarrays(
   98:             [np.array(["a", "a", "b"]), np.array(["x", "y", "z"])]
   99:             + [np.asarray(df.iloc[:, i]) for i in range(3)],
  100:             dtype={
  101:                 "names": ["A", "level_1", "0", "1", "2"],
  102:                 "formats": [
  103:                     "O",
  104:                     "O",
  105:                     f"{tm.ENDIAN}f8",
  106:                     f"{tm.ENDIAN}f8",
  107:                     f"{tm.ENDIAN}f8",
  108:                 ],
  109:             },
  110:         )
  111:         tm.assert_numpy_array_equal(result, expected)
  112: 
  113:     def test_to_records_with_unicode_index(self):
  114:         # GH#13172
  115:         # unicode_literals conflict with to_records
  116:         result = DataFrame([{"a": "x", "b": "y"}]).set_index("a").to_records()
  117:         expected = np.rec.array([("x", "y")], dtype=[("a", "O"), ("b", "O")])
  118:         tm.assert_almost_equal(result, expected)
  119: 
  120:     def test_to_records_index_dtype(self):
  121:         # GH 47263: consistent data types for Index and MultiIndex
  122:         df = DataFrame(
  123:             {
  124:                 1: date_range("2022-01-01", periods=2),
  125:                 2: date_range("2022-01-01", periods=2),
  126:                 3: date_range("2022-01-01", periods=2),
  127:             }
  128:         )
  129: 
  130:         expected = np.rec.array(
  131:             [
  132:                 ("2022-01-01", "2022-01-01", "2022-01-01"),
  133:                 ("2022-01-02", "2022-01-02", "2022-01-02"),
  134:             ],
  135:             dtype=[
  136:                 ("1", f"{tm.ENDIAN}M8[ns]"),
  137:                 ("2", f"{tm.ENDIAN}M8[ns]"),
  138:                 ("3", f"{tm.ENDIAN}M8[ns]"),
  139:             ],
  140:         )
  141: 
  142:         result = df.to_records(index=False)
  143:         tm.assert_almost_equal(result, expected)
  144: 
  145:         result = df.set_index(1).to_records(index=True)
  146:         tm.assert_almost_equal(result, expected)
  147: 
  148:         result = df.set_index([1, 2]).to_records(index=True)
  149:         tm.assert_almost_equal(result, expected)
  150: 
  151:     def test_to_records_with_unicode_column_names(self):
  152:         # xref issue: https://github.com/numpy/numpy/issues/2407
  153:         # Issue GH#11879. to_records used to raise an exception when used
  154:         # with column names containing non-ascii characters in Python 2
  155:         result = DataFrame(data={"accented_name_Г©": [1.0]}).to_records()
  156: 
  157:         # Note that numpy allows for unicode field names but dtypes need
  158:         # to be specified using dictionary instead of list of tuples.
  159:         expected = np.rec.array(
  160:             [(0, 1.0)],
  161:             dtype={"names": ["index", "accented_name_Г©"], "formats": ["=i8", "=f8"]},
  162:         )
  163:         tm.assert_almost_equal(result, expected)
  164: 
  165:     def test_to_records_with_categorical(self):
  166:         # GH#8626
  167: 
  168:         # dict creation
  169:         df = DataFrame({"A": list("abc")}, dtype="category")
  170:         expected = Series(list("abc"), dtype="category", name="A")
  171:         tm.assert_series_equal(df["A"], expected)
  172: 
  173:         # list-like creation
  174:         df = DataFrame(list("abc"), dtype="category")
  175:         expected = Series(list("abc"), dtype="category", name=0)
  176:         tm.assert_series_equal(df[0], expected)
  177: 
  178:         # to record array
  179:         # this coerces
  180:         result = df.to_records()
  181:         expected = np.rec.array(
  182:             [(0, "a"), (1, "b"), (2, "c")], dtype=[("index", "=i8"), ("0", "O")]
  183:         )
  184:         tm.assert_almost_equal(result, expected)
  185: 
  186:     @pytest.mark.parametrize(
  187:         "kwargs,expected",
  188:         [
  189:             # No dtypes --> default to array dtypes.
  190:             (
  191:                 {},
  192:                 np.rec.array(
  193:                     [(0, 1, 0.2, "a"), (1, 2, 1.5, "bc")],
  194:                     dtype=[
  195:                         ("index", f"{tm.ENDIAN}i8"),
  196:                         ("A", f"{tm.ENDIAN}i8"),
  197:                         ("B", f"{tm.ENDIAN}f8"),
  198:                         ("C", "O"),
  199:                     ],
  200:                 ),
  201:             ),
  202:             # Should have no effect in this case.
  203:             (
  204:                 {"index": True},
  205:                 np.rec.array(
  206:                     [(0, 1, 0.2, "a"), (1, 2, 1.5, "bc")],
  207:                     dtype=[
  208:                         ("index", f"{tm.ENDIAN}i8"),
  209:                         ("A", f"{tm.ENDIAN}i8"),
  210:                         ("B", f"{tm.ENDIAN}f8"),
  211:                         ("C", "O"),
  212:                     ],
  213:                 ),
  214:             ),
  215:             # Column dtype applied across the board. Index unaffected.
  216:             (
  217:                 {"column_dtypes": f"{tm.ENDIAN}U4"},
  218:                 np.rec.array(
  219:                     [("0", "1", "0.2", "a"), ("1", "2", "1.5", "bc")],
  220:                     dtype=[
  221:                         ("index", f"{tm.ENDIAN}i8"),
  222:                         ("A", f"{tm.ENDIAN}U4"),
  223:                         ("B", f"{tm.ENDIAN}U4"),
  224:                         ("C", f"{tm.ENDIAN}U4"),
  225:                     ],
  226:                 ),
  227:             ),
  228:             # Index dtype applied across the board. Columns unaffected.
  229:             (
  230:                 {"index_dtypes": f"{tm.ENDIAN}U1"},
  231:                 np.rec.array(
  232:                     [("0", 1, 0.2, "a"), ("1", 2, 1.5, "bc")],
  233:                     dtype=[
  234:                         ("index", f"{tm.ENDIAN}U1"),
  235:                         ("A", f"{tm.ENDIAN}i8"),
  236:                         ("B", f"{tm.ENDIAN}f8"),
  237:                         ("C", "O"),
  238:                     ],
  239:                 ),
  240:             ),
  241:             # Pass in a type instance.
  242:             (
  243:                 {"column_dtypes": str},
  244:                 np.rec.array(
  245:                     [("0", "1", "0.2", "a"), ("1", "2", "1.5", "bc")],
  246:                     dtype=[
  247:                         ("index", f"{tm.ENDIAN}i8"),
  248:                         ("A", f"{tm.ENDIAN}U"),
  249:                         ("B", f"{tm.ENDIAN}U"),
  250:                         ("C", f"{tm.ENDIAN}U"),
  251:                     ],
  252:                 ),
  253:             ),
  254:             # Pass in a dtype instance.
  255:             (
  256:                 {"column_dtypes": np.dtype(np.str_)},
  257:                 np.rec.array(
  258:                     [("0", "1", "0.2", "a"), ("1", "2", "1.5", "bc")],
  259:                     dtype=[
  260:                         ("index", f"{tm.ENDIAN}i8"),
  261:                         ("A", f"{tm.ENDIAN}U"),
  262:                         ("B", f"{tm.ENDIAN}U"),
  263:                         ("C", f"{tm.ENDIAN}U"),
  264:                     ],
  265:                 ),
  266:             ),
  267:             # Pass in a dictionary (name-only).
  268:             (
  269:                 {
  270:                     "column_dtypes": {
  271:                         "A": np.int8,
  272:                         "B": np.float32,
  273:                         "C": f"{tm.ENDIAN}U2",
  274:                     }
  275:                 },
  276:                 np.rec.array(
  277:                     [("0", "1", "0.2", "a"), ("1", "2", "1.5", "bc")],
  278:                     dtype=[
  279:                         ("index", f"{tm.ENDIAN}i8"),
  280:                         ("A", "i1"),
  281:                         ("B", f"{tm.ENDIAN}f4"),
  282:                         ("C", f"{tm.ENDIAN}U2"),
  283:                     ],
  284:                 ),
  285:             ),
  286:             # Pass in a dictionary (indices-only).
  287:             (
  288:                 {"index_dtypes": {0: "int16"}},
  289:                 np.rec.array(
  290:                     [(0, 1, 0.2, "a"), (1, 2, 1.5, "bc")],
  291:                     dtype=[
  292:                         ("index", "i2"),
  293:                         ("A", f"{tm.ENDIAN}i8"),
  294:                         ("B", f"{tm.ENDIAN}f8"),
  295:                         ("C", "O"),
  296:                     ],
  297:                 ),
  298:             ),
  299:             # Ignore index mappings if index is not True.
  300:             (
  301:                 {"index": False, "index_dtypes": f"{tm.ENDIAN}U2"},
  302:                 np.rec.array(
  303:                     [(1, 0.2, "a"), (2, 1.5, "bc")],
  304:                     dtype=[
  305:                         ("A", f"{tm.ENDIAN}i8"),
  306:                         ("B", f"{tm.ENDIAN}f8"),
  307:                         ("C", "O"),
  308:                     ],
  309:                 ),
  310:             ),
  311:             # Non-existent names / indices in mapping should not error.
  312:             (
  313:                 {"index_dtypes": {0: "int16", "not-there": "float32"}},
  314:                 np.rec.array(
  315:                     [(0, 1, 0.2, "a"), (1, 2, 1.5, "bc")],
  316:                     dtype=[
  317:                         ("index", "i2"),
  318:                         ("A", f"{tm.ENDIAN}i8"),
  319:                         ("B", f"{tm.ENDIAN}f8"),
  320:                         ("C", "O"),
  321:                     ],
  322:                 ),
  323:             ),
  324:             # Names / indices not in mapping default to array dtype.
  325:             (
  326:                 {"column_dtypes": {"A": np.int8, "B": np.float32}},
  327:                 np.rec.array(
  328:                     [("0", "1", "0.2", "a"), ("1", "2", "1.5", "bc")],
  329:                     dtype=[
  330:                         ("index", f"{tm.ENDIAN}i8"),
  331:                         ("A", "i1"),
  332:                         ("B", f"{tm.ENDIAN}f4"),
  333:                         ("C", "O"),
  334:                     ],
  335:                 ),
  336:             ),
  337:             # Names / indices not in dtype mapping default to array dtype.
  338:             (
  339:                 {"column_dtypes": {"A": np.dtype("int8"), "B": np.dtype("float32")}},
  340:                 np.rec.array(
  341:                     [("0", "1", "0.2", "a"), ("1", "2", "1.5", "bc")],
  342:                     dtype=[
  343:                         ("index", f"{tm.ENDIAN}i8"),
  344:                         ("A", "i1"),
  345:                         ("B", f"{tm.ENDIAN}f4"),
  346:                         ("C", "O"),
  347:                     ],
  348:                 ),
  349:             ),
  350:             # Mixture of everything.
  351:             (
  352:                 {
  353:                     "column_dtypes": {"A": np.int8, "B": np.float32},
  354:                     "index_dtypes": f"{tm.ENDIAN}U2",
  355:                 },
  356:                 np.rec.array(
  357:                     [("0", "1", "0.2", "a"), ("1", "2", "1.5", "bc")],
  358:                     dtype=[
  359:                         ("index", f"{tm.ENDIAN}U2"),
  360:                         ("A", "i1"),
  361:                         ("B", f"{tm.ENDIAN}f4"),
  362:                         ("C", "O"),
  363:                     ],
  364:                 ),
  365:             ),
  366:             # Invalid dype values.
  367:             (
  368:                 {"index": False, "column_dtypes": []},
  369:                 (ValueError, "Invalid dtype \\[\\] specified for column A"),
  370:             ),
  371:             (
  372:                 {"index": False, "column_dtypes": {"A": "int32", "B": 5}},
  373:                 (ValueError, "Invalid dtype 5 specified for column B"),
  374:             ),
  375:             # Numpy can't handle EA types, so check error is raised
  376:             (
  377:                 {
  378:                     "index": False,
  379:                     "column_dtypes": {"A": "int32", "B": CategoricalDtype(["a", "b"])},
  380:                 },
  381:                 (ValueError, "Invalid dtype category specified for column B"),
  382:             ),
  383:             # Check that bad types raise
  384:             (
  385:                 {"index": False, "column_dtypes": {"A": "int32", "B": "foo"}},
  386:                 (TypeError, "data type [\"']foo[\"'] not understood"),
  387:             ),
  388:         ],
  389:     )
  390:     def test_to_records_dtype(self, kwargs, expected):
  391:         # see GH#18146
  392:         df = DataFrame({"A": [1, 2], "B": [0.2, 1.5], "C": ["a", "bc"]})
  393: 
  394:         if not isinstance(expected, np.rec.recarray):
  395:             with pytest.raises(expected[0], match=expected[1]):
  396:                 df.to_records(**kwargs)
  397:         else:
  398:             result = df.to_records(**kwargs)
  399:             tm.assert_almost_equal(result, expected)
  400: 
  401:     @pytest.mark.parametrize(
  402:         "df,kwargs,expected",
  403:         [
  404:             # MultiIndex in the index.
  405:             (
  406:                 DataFrame(
  407:                     [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=list("abc")
  408:                 ).set_index(["a", "b"]),
  409:                 {"column_dtypes": "float64", "index_dtypes": {0: "int32", 1: "int8"}},
  410:                 np.rec.array(
  411:                     [(1, 2, 3.0), (4, 5, 6.0), (7, 8, 9.0)],
  412:                     dtype=[
  413:                         ("a", f"{tm.ENDIAN}i4"),
  414:                         ("b", "i1"),
  415:                         ("c", f"{tm.ENDIAN}f8"),
  416:                     ],
  417:                 ),
  418:             ),
  419:             # MultiIndex in the columns.
  420:             (
  421:                 DataFrame(
  422:                     [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
  423:                     columns=MultiIndex.from_tuples(
  424:                         [("a", "d"), ("b", "e"), ("c", "f")]
  425:                     ),
  426:                 ),
  427:                 {
  428:                     "column_dtypes": {0: f"{tm.ENDIAN}U1", 2: "float32"},
  429:                     "index_dtypes": "float32",
  430:                 },
  431:                 np.rec.array(
  432:                     [(0.0, "1", 2, 3.0), (1.0, "4", 5, 6.0), (2.0, "7", 8, 9.0)],
  433:                     dtype=[
  434:                         ("index", f"{tm.ENDIAN}f4"),
  435:                         ("('a', 'd')", f"{tm.ENDIAN}U1"),
  436:                         ("('b', 'e')", f"{tm.ENDIAN}i8"),
  437:                         ("('c', 'f')", f"{tm.ENDIAN}f4"),
  438:                     ],
  439:                 ),
  440:             ),
  441:             # MultiIndex in both the columns and index.
  442:             (
  443:                 DataFrame(
  444:                     [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
  445:                     columns=MultiIndex.from_tuples(
  446:                         [("a", "d"), ("b", "e"), ("c", "f")], names=list("ab")
  447:                     ),
  448:                     index=MultiIndex.from_tuples(
  449:                         [("d", -4), ("d", -5), ("f", -6)], names=list("cd")
  450:                     ),
  451:                 ),
  452:                 {
  453:                     "column_dtypes": "float64",
  454:                     "index_dtypes": {0: f"{tm.ENDIAN}U2", 1: "int8"},
  455:                 },
  456:                 np.rec.array(
  457:                     [
  458:                         ("d", -4, 1.0, 2.0, 3.0),
  459:                         ("d", -5, 4.0, 5.0, 6.0),
  460:                         ("f", -6, 7, 8, 9.0),
  461:                     ],
  462:                     dtype=[
  463:                         ("c", f"{tm.ENDIAN}U2"),
  464:                         ("d", "i1"),
  465:                         ("('a', 'd')", f"{tm.ENDIAN}f8"),
  466:                         ("('b', 'e')", f"{tm.ENDIAN}f8"),
  467:                         ("('c', 'f')", f"{tm.ENDIAN}f8"),
  468:                     ],
  469:                 ),
  470:             ),
  471:         ],
  472:     )
  473:     def test_to_records_dtype_mi(self, df, kwargs, expected):
  474:         # see GH#18146
  475:         result = df.to_records(**kwargs)
  476:         tm.assert_almost_equal(result, expected)
  477: 
  478:     def test_to_records_dict_like(self):
  479:         # see GH#18146
  480:         class DictLike:
  481:             def __init__(self, **kwargs) -> None:
  482:                 self.d = kwargs.copy()
  483: 
  484:             def __getitem__(self, key):
  485:                 return self.d.__getitem__(key)
  486: 
  487:             def __contains__(self, key) -> bool:
  488:                 return key in self.d
  489: 
  490:             def keys(self):
  491:                 return self.d.keys()
  492: 
  493:         df = DataFrame({"A": [1, 2], "B": [0.2, 1.5], "C": ["a", "bc"]})
  494: 
  495:         dtype_mappings = {
  496:             "column_dtypes": DictLike(A=np.int8, B=np.float32),
  497:             "index_dtypes": f"{tm.ENDIAN}U2",
  498:         }
  499: 
  500:         result = df.to_records(**dtype_mappings)
  501:         expected = np.rec.array(
  502:             [("0", "1", "0.2", "a"), ("1", "2", "1.5", "bc")],
  503:             dtype=[
  504:                 ("index", f"{tm.ENDIAN}U2"),
  505:                 ("A", "i1"),
  506:                 ("B", f"{tm.ENDIAN}f4"),
  507:                 ("C", "O"),
  508:             ],
  509:         )
  510:         tm.assert_almost_equal(result, expected)
  511: 
  512:     @pytest.mark.parametrize("tz", ["UTC", "GMT", "US/Eastern"])
  513:     def test_to_records_datetimeindex_with_tz(self, tz):
  514:         # GH#13937
  515:         dr = date_range("2016-01-01", periods=10, freq="s", tz=tz)
  516: 
  517:         df = DataFrame({"datetime": dr}, index=dr)
  518: 
  519:         expected = df.to_records()
  520:         result = df.tz_convert("UTC").to_records()
  521: 
  522:         # both converted to UTC, so they are equal
  523:         tm.assert_numpy_array_equal(result, expected)
