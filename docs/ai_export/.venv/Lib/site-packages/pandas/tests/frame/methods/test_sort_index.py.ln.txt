    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     CategoricalDtype,
    7:     CategoricalIndex,
    8:     DataFrame,
    9:     IntervalIndex,
   10:     MultiIndex,
   11:     RangeIndex,
   12:     Series,
   13:     Timestamp,
   14: )
   15: import pandas._testing as tm
   16: 
   17: 
   18: class TestDataFrameSortIndex:
   19:     def test_sort_index_and_reconstruction_doc_example(self):
   20:         # doc example
   21:         df = DataFrame(
   22:             {"value": [1, 2, 3, 4]},
   23:             index=MultiIndex(
   24:                 levels=[["a", "b"], ["bb", "aa"]], codes=[[0, 0, 1, 1], [0, 1, 0, 1]]
   25:             ),
   26:         )
   27:         assert df.index._is_lexsorted()
   28:         assert not df.index.is_monotonic_increasing
   29: 
   30:         # sort it
   31:         expected = DataFrame(
   32:             {"value": [2, 1, 4, 3]},
   33:             index=MultiIndex(
   34:                 levels=[["a", "b"], ["aa", "bb"]], codes=[[0, 0, 1, 1], [0, 1, 0, 1]]
   35:             ),
   36:         )
   37:         result = df.sort_index()
   38:         assert result.index.is_monotonic_increasing
   39:         tm.assert_frame_equal(result, expected)
   40: 
   41:         # reconstruct
   42:         result = df.sort_index().copy()
   43:         result.index = result.index._sort_levels_monotonic()
   44:         assert result.index.is_monotonic_increasing
   45:         tm.assert_frame_equal(result, expected)
   46: 
   47:     def test_sort_index_non_existent_label_multiindex(self):
   48:         # GH#12261
   49:         df = DataFrame(0, columns=[], index=MultiIndex.from_product([[], []]))
   50:         with tm.assert_produces_warning(None):
   51:             df.loc["b", "2"] = 1
   52:             df.loc["a", "3"] = 1
   53:         result = df.sort_index().index.is_monotonic_increasing
   54:         assert result is True
   55: 
   56:     def test_sort_index_reorder_on_ops(self):
   57:         # GH#15687
   58:         df = DataFrame(
   59:             np.random.default_rng(2).standard_normal((8, 2)),
   60:             index=MultiIndex.from_product(
   61:                 [["a", "b"], ["big", "small"], ["red", "blu"]],
   62:                 names=["letter", "size", "color"],
   63:             ),
   64:             columns=["near", "far"],
   65:         )
   66:         df = df.sort_index()
   67: 
   68:         def my_func(group):
   69:             group.index = ["newz", "newa"]
   70:             return group
   71: 
   72:         result = df.groupby(level=["letter", "size"]).apply(my_func).sort_index()
   73:         expected = MultiIndex.from_product(
   74:             [["a", "b"], ["big", "small"], ["newa", "newz"]],
   75:             names=["letter", "size", None],
   76:         )
   77: 
   78:         tm.assert_index_equal(result.index, expected)
   79: 
   80:     def test_sort_index_nan_multiindex(self):
   81:         # GH#14784
   82:         # incorrect sorting w.r.t. nans
   83:         tuples = [[12, 13], [np.nan, np.nan], [np.nan, 3], [1, 2]]
   84:         mi = MultiIndex.from_tuples(tuples)
   85: 
   86:         df = DataFrame(np.arange(16).reshape(4, 4), index=mi, columns=list("ABCD"))
   87:         s = Series(np.arange(4), index=mi)
   88: 
   89:         df2 = DataFrame(
   90:             {
   91:                 "date": pd.DatetimeIndex(
   92:                     [
   93:                         "20121002",
   94:                         "20121007",
   95:                         "20130130",
   96:                         "20130202",
   97:                         "20130305",
   98:                         "20121002",
   99:                         "20121207",
  100:                         "20130130",
  101:                         "20130202",
  102:                         "20130305",
  103:                         "20130202",
  104:                         "20130305",
  105:                     ]
  106:                 ),
  107:                 "user_id": [1, 1, 1, 1, 1, 3, 3, 3, 5, 5, 5, 5],
  108:                 "whole_cost": [
  109:                     1790,
  110:                     np.nan,
  111:                     280,
  112:                     259,
  113:                     np.nan,
  114:                     623,
  115:                     90,
  116:                     312,
  117:                     np.nan,
  118:                     301,
  119:                     359,
  120:                     801,
  121:                 ],
  122:                 "cost": [12, 15, 10, 24, 39, 1, 0, np.nan, 45, 34, 1, 12],
  123:             }
  124:         ).set_index(["date", "user_id"])
  125: 
  126:         # sorting frame, default nan position is last
  127:         result = df.sort_index()
  128:         expected = df.iloc[[3, 0, 2, 1], :]
  129:         tm.assert_frame_equal(result, expected)
  130: 
  131:         # sorting frame, nan position last
  132:         result = df.sort_index(na_position="last")
  133:         expected = df.iloc[[3, 0, 2, 1], :]
  134:         tm.assert_frame_equal(result, expected)
  135: 
  136:         # sorting frame, nan position first
  137:         result = df.sort_index(na_position="first")
  138:         expected = df.iloc[[1, 2, 3, 0], :]
  139:         tm.assert_frame_equal(result, expected)
  140: 
  141:         # sorting frame with removed rows
  142:         result = df2.dropna().sort_index()
  143:         expected = df2.sort_index().dropna()
  144:         tm.assert_frame_equal(result, expected)
  145: 
  146:         # sorting series, default nan position is last
  147:         result = s.sort_index()
  148:         expected = s.iloc[[3, 0, 2, 1]]
  149:         tm.assert_series_equal(result, expected)
  150: 
  151:         # sorting series, nan position last
  152:         result = s.sort_index(na_position="last")
  153:         expected = s.iloc[[3, 0, 2, 1]]
  154:         tm.assert_series_equal(result, expected)
  155: 
  156:         # sorting series, nan position first
  157:         result = s.sort_index(na_position="first")
  158:         expected = s.iloc[[1, 2, 3, 0]]
  159:         tm.assert_series_equal(result, expected)
  160: 
  161:     def test_sort_index_nan(self):
  162:         # GH#3917
  163: 
  164:         # Test DataFrame with nan label
  165:         df = DataFrame(
  166:             {"A": [1, 2, np.nan, 1, 6, 8, 4], "B": [9, np.nan, 5, 2, 5, 4, 5]},
  167:             index=[1, 2, 3, 4, 5, 6, np.nan],
  168:         )
  169: 
  170:         # NaN label, ascending=True, na_position='last'
  171:         sorted_df = df.sort_index(kind="quicksort", ascending=True, na_position="last")
  172:         expected = DataFrame(
  173:             {"A": [1, 2, np.nan, 1, 6, 8, 4], "B": [9, np.nan, 5, 2, 5, 4, 5]},
  174:             index=[1, 2, 3, 4, 5, 6, np.nan],
  175:         )
  176:         tm.assert_frame_equal(sorted_df, expected)
  177: 
  178:         # NaN label, ascending=True, na_position='first'
  179:         sorted_df = df.sort_index(na_position="first")
  180:         expected = DataFrame(
  181:             {"A": [4, 1, 2, np.nan, 1, 6, 8], "B": [5, 9, np.nan, 5, 2, 5, 4]},
  182:             index=[np.nan, 1, 2, 3, 4, 5, 6],
  183:         )
  184:         tm.assert_frame_equal(sorted_df, expected)
  185: 
  186:         # NaN label, ascending=False, na_position='last'
  187:         sorted_df = df.sort_index(kind="quicksort", ascending=False)
  188:         expected = DataFrame(
  189:             {"A": [8, 6, 1, np.nan, 2, 1, 4], "B": [4, 5, 2, 5, np.nan, 9, 5]},
  190:             index=[6, 5, 4, 3, 2, 1, np.nan],
  191:         )
  192:         tm.assert_frame_equal(sorted_df, expected)
  193: 
  194:         # NaN label, ascending=False, na_position='first'
  195:         sorted_df = df.sort_index(
  196:             kind="quicksort", ascending=False, na_position="first"
  197:         )
  198:         expected = DataFrame(
  199:             {"A": [4, 8, 6, 1, np.nan, 2, 1], "B": [5, 4, 5, 2, 5, np.nan, 9]},
  200:             index=[np.nan, 6, 5, 4, 3, 2, 1],
  201:         )
  202:         tm.assert_frame_equal(sorted_df, expected)
  203: 
  204:     def test_sort_index_multi_index(self):
  205:         # GH#25775, testing that sorting by index works with a multi-index.
  206:         df = DataFrame(
  207:             {"a": [3, 1, 2], "b": [0, 0, 0], "c": [0, 1, 2], "d": list("abc")}
  208:         )
  209:         result = df.set_index(list("abc")).sort_index(level=list("ba"))
  210: 
  211:         expected = DataFrame(
  212:             {"a": [1, 2, 3], "b": [0, 0, 0], "c": [1, 2, 0], "d": list("bca")}
  213:         )
  214:         expected = expected.set_index(list("abc"))
  215: 
  216:         tm.assert_frame_equal(result, expected)
  217: 
  218:     def test_sort_index_inplace(self):
  219:         frame = DataFrame(
  220:             np.random.default_rng(2).standard_normal((4, 4)),
  221:             index=[1, 2, 3, 4],
  222:             columns=["A", "B", "C", "D"],
  223:         )
  224: 
  225:         # axis=0
  226:         unordered = frame.loc[[3, 2, 4, 1]]
  227:         a_values = unordered["A"]
  228:         df = unordered.copy()
  229:         return_value = df.sort_index(inplace=True)
  230:         assert return_value is None
  231:         expected = frame
  232:         tm.assert_frame_equal(df, expected)
  233:         # GH 44153 related
  234:         # Used to be a_id != id(df["A"]), but flaky in the CI
  235:         assert a_values is not df["A"]
  236: 
  237:         df = unordered.copy()
  238:         return_value = df.sort_index(ascending=False, inplace=True)
  239:         assert return_value is None
  240:         expected = frame[::-1]
  241:         tm.assert_frame_equal(df, expected)
  242: 
  243:         # axis=1
  244:         unordered = frame.loc[:, ["D", "B", "C", "A"]]
  245:         df = unordered.copy()
  246:         return_value = df.sort_index(axis=1, inplace=True)
  247:         assert return_value is None
  248:         expected = frame
  249:         tm.assert_frame_equal(df, expected)
  250: 
  251:         df = unordered.copy()
  252:         return_value = df.sort_index(axis=1, ascending=False, inplace=True)
  253:         assert return_value is None
  254:         expected = frame.iloc[:, ::-1]
  255:         tm.assert_frame_equal(df, expected)
  256: 
  257:     def test_sort_index_different_sortorder(self):
  258:         A = np.arange(20).repeat(5)
  259:         B = np.tile(np.arange(5), 20)
  260: 
  261:         indexer = np.random.default_rng(2).permutation(100)
  262:         A = A.take(indexer)
  263:         B = B.take(indexer)
  264: 
  265:         df = DataFrame(
  266:             {"A": A, "B": B, "C": np.random.default_rng(2).standard_normal(100)}
  267:         )
  268: 
  269:         ex_indexer = np.lexsort((df.B.max() - df.B, df.A))
  270:         expected = df.take(ex_indexer)
  271: 
  272:         # test with multiindex, too
  273:         idf = df.set_index(["A", "B"])
  274: 
  275:         result = idf.sort_index(ascending=[1, 0])
  276:         expected = idf.take(ex_indexer)
  277:         tm.assert_frame_equal(result, expected)
  278: 
  279:         # also, Series!
  280:         result = idf["C"].sort_index(ascending=[1, 0])
  281:         tm.assert_series_equal(result, expected["C"])
  282: 
  283:     def test_sort_index_level(self):
  284:         mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list("ABC"))
  285:         df = DataFrame([[1, 2], [3, 4]], mi)
  286: 
  287:         result = df.sort_index(level="A", sort_remaining=False)
  288:         expected = df
  289:         tm.assert_frame_equal(result, expected)
  290: 
  291:         result = df.sort_index(level=["A", "B"], sort_remaining=False)
  292:         expected = df
  293:         tm.assert_frame_equal(result, expected)
  294: 
  295:         # Error thrown by sort_index when
  296:         # first index is sorted last (GH#26053)
  297:         result = df.sort_index(level=["C", "B", "A"])
  298:         expected = df.iloc[[1, 0]]
  299:         tm.assert_frame_equal(result, expected)
  300: 
  301:         result = df.sort_index(level=["B", "C", "A"])
  302:         expected = df.iloc[[1, 0]]
  303:         tm.assert_frame_equal(result, expected)
  304: 
  305:         result = df.sort_index(level=["C", "A"])
  306:         expected = df.iloc[[1, 0]]
  307:         tm.assert_frame_equal(result, expected)
  308: 
  309:     def test_sort_index_categorical_index(self):
  310:         df = DataFrame(
  311:             {
  312:                 "A": np.arange(6, dtype="int64"),
  313:                 "B": Series(list("aabbca")).astype(CategoricalDtype(list("cab"))),
  314:             }
  315:         ).set_index("B")
  316: 
  317:         result = df.sort_index()
  318:         expected = df.iloc[[4, 0, 1, 5, 2, 3]]
  319:         tm.assert_frame_equal(result, expected)
  320: 
  321:         result = df.sort_index(ascending=False)
  322:         expected = df.iloc[[2, 3, 0, 1, 5, 4]]
  323:         tm.assert_frame_equal(result, expected)
  324: 
  325:     def test_sort_index(self):
  326:         # GH#13496
  327: 
  328:         frame = DataFrame(
  329:             np.arange(16).reshape(4, 4),
  330:             index=[1, 2, 3, 4],
  331:             columns=["A", "B", "C", "D"],
  332:         )
  333: 
  334:         # axis=0 : sort rows by index labels
  335:         unordered = frame.loc[[3, 2, 4, 1]]
  336:         result = unordered.sort_index(axis=0)
  337:         expected = frame
  338:         tm.assert_frame_equal(result, expected)
  339: 
  340:         result = unordered.sort_index(ascending=False)
  341:         expected = frame[::-1]
  342:         tm.assert_frame_equal(result, expected)
  343: 
  344:         # axis=1 : sort columns by column names
  345:         unordered = frame.iloc[:, [2, 1, 3, 0]]
  346:         result = unordered.sort_index(axis=1)
  347:         tm.assert_frame_equal(result, frame)
  348: 
  349:         result = unordered.sort_index(axis=1, ascending=False)
  350:         expected = frame.iloc[:, ::-1]
  351:         tm.assert_frame_equal(result, expected)
  352: 
  353:     @pytest.mark.parametrize("level", ["A", 0])  # GH#21052
  354:     def test_sort_index_multiindex(self, level):
  355:         # GH#13496
  356: 
  357:         # sort rows by specified level of multi-index
  358:         mi = MultiIndex.from_tuples(
  359:             [[2, 1, 3], [2, 1, 2], [1, 1, 1]], names=list("ABC")
  360:         )
  361:         df = DataFrame([[1, 2], [3, 4], [5, 6]], index=mi)
  362: 
  363:         expected_mi = MultiIndex.from_tuples(
  364:             [[1, 1, 1], [2, 1, 2], [2, 1, 3]], names=list("ABC")
  365:         )
  366:         expected = DataFrame([[5, 6], [3, 4], [1, 2]], index=expected_mi)
  367:         result = df.sort_index(level=level)
  368:         tm.assert_frame_equal(result, expected)
  369: 
  370:         # sort_remaining=False
  371:         expected_mi = MultiIndex.from_tuples(
  372:             [[1, 1, 1], [2, 1, 3], [2, 1, 2]], names=list("ABC")
  373:         )
  374:         expected = DataFrame([[5, 6], [1, 2], [3, 4]], index=expected_mi)
  375:         result = df.sort_index(level=level, sort_remaining=False)
  376:         tm.assert_frame_equal(result, expected)
  377: 
  378:     def test_sort_index_intervalindex(self):
  379:         # this is a de-facto sort via unstack
  380:         # confirming that we sort in the order of the bins
  381:         y = Series(np.random.default_rng(2).standard_normal(100))
  382:         x1 = Series(np.sign(np.random.default_rng(2).standard_normal(100)))
  383:         x2 = pd.cut(
  384:             Series(np.random.default_rng(2).standard_normal(100)),
  385:             bins=[-3, -0.5, 0, 0.5, 3],
  386:         )
  387:         model = pd.concat([y, x1, x2], axis=1, keys=["Y", "X1", "X2"])
  388: 
  389:         result = model.groupby(["X1", "X2"], observed=True).mean().unstack()
  390:         expected = IntervalIndex.from_tuples(
  391:             [(-3.0, -0.5), (-0.5, 0.0), (0.0, 0.5), (0.5, 3.0)], closed="right"
  392:         )
  393:         result = result.columns.levels[1].categories
  394:         tm.assert_index_equal(result, expected)
  395: 
  396:     @pytest.mark.parametrize("inplace", [True, False])
  397:     @pytest.mark.parametrize(
  398:         "original_dict, sorted_dict, ascending, ignore_index, output_index",
  399:         [
  400:             ({"A": [1, 2, 3]}, {"A": [2, 3, 1]}, False, True, [0, 1, 2]),
  401:             ({"A": [1, 2, 3]}, {"A": [1, 3, 2]}, True, True, [0, 1, 2]),
  402:             ({"A": [1, 2, 3]}, {"A": [2, 3, 1]}, False, False, [5, 3, 2]),
  403:             ({"A": [1, 2, 3]}, {"A": [1, 3, 2]}, True, False, [2, 3, 5]),
  404:         ],
  405:     )
  406:     def test_sort_index_ignore_index(
  407:         self, inplace, original_dict, sorted_dict, ascending, ignore_index, output_index
  408:     ):
  409:         # GH 30114
  410:         original_index = [2, 5, 3]
  411:         df = DataFrame(original_dict, index=original_index)
  412:         expected_df = DataFrame(sorted_dict, index=output_index)
  413:         kwargs = {
  414:             "ascending": ascending,
  415:             "ignore_index": ignore_index,
  416:             "inplace": inplace,
  417:         }
  418: 
  419:         if inplace:
  420:             result_df = df.copy()
  421:             result_df.sort_index(**kwargs)
  422:         else:
  423:             result_df = df.sort_index(**kwargs)
  424: 
  425:         tm.assert_frame_equal(result_df, expected_df)
  426:         tm.assert_frame_equal(df, DataFrame(original_dict, index=original_index))
  427: 
  428:     @pytest.mark.parametrize("inplace", [True, False])
  429:     @pytest.mark.parametrize("ignore_index", [True, False])
  430:     def test_respect_ignore_index(self, inplace, ignore_index):
  431:         # GH 43591
  432:         df = DataFrame({"a": [1, 2, 3]}, index=RangeIndex(4, -1, -2))
  433:         result = df.sort_index(
  434:             ascending=False, ignore_index=ignore_index, inplace=inplace
  435:         )
  436: 
  437:         if inplace:
  438:             result = df
  439:         if ignore_index:
  440:             expected = DataFrame({"a": [1, 2, 3]})
  441:         else:
  442:             expected = DataFrame({"a": [1, 2, 3]}, index=RangeIndex(4, -1, -2))
  443: 
  444:         tm.assert_frame_equal(result, expected)
  445: 
  446:     @pytest.mark.parametrize("inplace", [True, False])
  447:     @pytest.mark.parametrize(
  448:         "original_dict, sorted_dict, ascending, ignore_index, output_index",
  449:         [
  450:             (
  451:                 {"M1": [1, 2], "M2": [3, 4]},
  452:                 {"M1": [1, 2], "M2": [3, 4]},
  453:                 True,
  454:                 True,
  455:                 [0, 1],
  456:             ),
  457:             (
  458:                 {"M1": [1, 2], "M2": [3, 4]},
  459:                 {"M1": [2, 1], "M2": [4, 3]},
  460:                 False,
  461:                 True,
  462:                 [0, 1],
  463:             ),
  464:             (
  465:                 {"M1": [1, 2], "M2": [3, 4]},
  466:                 {"M1": [1, 2], "M2": [3, 4]},
  467:                 True,
  468:                 False,
  469:                 MultiIndex.from_tuples([(2, 1), (3, 4)], names=list("AB")),
  470:             ),
  471:             (
  472:                 {"M1": [1, 2], "M2": [3, 4]},
  473:                 {"M1": [2, 1], "M2": [4, 3]},
  474:                 False,
  475:                 False,
  476:                 MultiIndex.from_tuples([(3, 4), (2, 1)], names=list("AB")),
  477:             ),
  478:         ],
  479:     )
  480:     def test_sort_index_ignore_index_multi_index(
  481:         self, inplace, original_dict, sorted_dict, ascending, ignore_index, output_index
  482:     ):
  483:         # GH 30114, this is to test ignore_index on MultiIndex of index
  484:         mi = MultiIndex.from_tuples([(2, 1), (3, 4)], names=list("AB"))
  485:         df = DataFrame(original_dict, index=mi)
  486:         expected_df = DataFrame(sorted_dict, index=output_index)
  487: 
  488:         kwargs = {
  489:             "ascending": ascending,
  490:             "ignore_index": ignore_index,
  491:             "inplace": inplace,
  492:         }
  493: 
  494:         if inplace:
  495:             result_df = df.copy()
  496:             result_df.sort_index(**kwargs)
  497:         else:
  498:             result_df = df.sort_index(**kwargs)
  499: 
  500:         tm.assert_frame_equal(result_df, expected_df)
  501:         tm.assert_frame_equal(df, DataFrame(original_dict, index=mi))
  502: 
  503:     def test_sort_index_categorical_multiindex(self):
  504:         # GH#15058
  505:         df = DataFrame(
  506:             {
  507:                 "a": range(6),
  508:                 "l1": pd.Categorical(
  509:                     ["a", "a", "b", "b", "c", "c"],
  510:                     categories=["c", "a", "b"],
  511:                     ordered=True,
  512:                 ),
  513:                 "l2": [0, 1, 0, 1, 0, 1],
  514:             }
  515:         )
  516:         result = df.set_index(["l1", "l2"]).sort_index()
  517:         expected = DataFrame(
  518:             [4, 5, 0, 1, 2, 3],
  519:             columns=["a"],
  520:             index=MultiIndex(
  521:                 levels=[
  522:                     CategoricalIndex(
  523:                         ["c", "a", "b"],
  524:                         categories=["c", "a", "b"],
  525:                         ordered=True,
  526:                         name="l1",
  527:                         dtype="category",
  528:                     ),
  529:                     [0, 1],
  530:                 ],
  531:                 codes=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]],
  532:                 names=["l1", "l2"],
  533:             ),
  534:         )
  535:         tm.assert_frame_equal(result, expected)
  536: 
  537:     def test_sort_index_and_reconstruction(self):
  538:         # GH#15622
  539:         # lexsortedness should be identical
  540:         # across MultiIndex construction methods
  541: 
  542:         df = DataFrame([[1, 1], [2, 2]], index=list("ab"))
  543:         expected = DataFrame(
  544:             [[1, 1], [2, 2], [1, 1], [2, 2]],
  545:             index=MultiIndex.from_tuples(
  546:                 [(0.5, "a"), (0.5, "b"), (0.8, "a"), (0.8, "b")]
  547:             ),
  548:         )
  549:         assert expected.index._is_lexsorted()
  550: 
  551:         result = DataFrame(
  552:             [[1, 1], [2, 2], [1, 1], [2, 2]],
  553:             index=MultiIndex.from_product([[0.5, 0.8], list("ab")]),
  554:         )
  555:         result = result.sort_index()
  556:         assert result.index.is_monotonic_increasing
  557: 
  558:         tm.assert_frame_equal(result, expected)
  559: 
  560:         result = DataFrame(
  561:             [[1, 1], [2, 2], [1, 1], [2, 2]],
  562:             index=MultiIndex(
  563:                 levels=[[0.5, 0.8], ["a", "b"]], codes=[[0, 0, 1, 1], [0, 1, 0, 1]]
  564:             ),
  565:         )
  566:         result = result.sort_index()
  567:         assert result.index._is_lexsorted()
  568: 
  569:         tm.assert_frame_equal(result, expected)
  570: 
  571:         concatted = pd.concat([df, df], keys=[0.8, 0.5])
  572:         result = concatted.sort_index()
  573: 
  574:         assert result.index.is_monotonic_increasing
  575: 
  576:         tm.assert_frame_equal(result, expected)
  577: 
  578:         # GH#14015
  579:         df = DataFrame(
  580:             [[1, 2], [6, 7]],
  581:             columns=MultiIndex.from_tuples(
  582:                 [(0, "20160811 12:00:00"), (0, "20160809 12:00:00")],
  583:                 names=["l1", "Date"],
  584:             ),
  585:         )
  586: 
  587:         df.columns = df.columns.set_levels(
  588:             pd.to_datetime(df.columns.levels[1]), level=1
  589:         )
  590:         assert not df.columns.is_monotonic_increasing
  591:         result = df.sort_index(axis=1)
  592:         assert result.columns.is_monotonic_increasing
  593:         result = df.sort_index(axis=1, level=1)
  594:         assert result.columns.is_monotonic_increasing
  595: 
  596:     # TODO: better name, de-duplicate with test_sort_index_level above
  597:     def test_sort_index_level2(self, multiindex_dataframe_random_data):
  598:         frame = multiindex_dataframe_random_data
  599: 
  600:         df = frame.copy()
  601:         df.index = np.arange(len(df))
  602: 
  603:         # axis=1
  604: 
  605:         # series
  606:         a_sorted = frame["A"].sort_index(level=0)
  607: 
  608:         # preserve names
  609:         assert a_sorted.index.names == frame.index.names
  610: 
  611:         # inplace
  612:         rs = frame.copy()
  613:         return_value = rs.sort_index(level=0, inplace=True)
  614:         assert return_value is None
  615:         tm.assert_frame_equal(rs, frame.sort_index(level=0))
  616: 
  617:     def test_sort_index_level_large_cardinality(self):
  618:         # GH#2684 (int64)
  619:         index = MultiIndex.from_arrays([np.arange(4000)] * 3)
  620:         df = DataFrame(
  621:             np.random.default_rng(2).standard_normal(4000).astype("int64"), index=index
  622:         )
  623: 
  624:         # it works!
  625:         result = df.sort_index(level=0)
  626:         assert result.index._lexsort_depth == 3
  627: 
  628:         # GH#2684 (int32)
  629:         index = MultiIndex.from_arrays([np.arange(4000)] * 3)
  630:         df = DataFrame(
  631:             np.random.default_rng(2).standard_normal(4000).astype("int32"), index=index
  632:         )
  633: 
  634:         # it works!
  635:         result = df.sort_index(level=0)
  636:         assert (result.dtypes.values == df.dtypes.values).all()
  637:         assert result.index._lexsort_depth == 3
  638: 
  639:     def test_sort_index_level_by_name(self, multiindex_dataframe_random_data):
  640:         frame = multiindex_dataframe_random_data
  641: 
  642:         frame.index.names = ["first", "second"]
  643:         result = frame.sort_index(level="second")
  644:         expected = frame.sort_index(level=1)
  645:         tm.assert_frame_equal(result, expected)
  646: 
  647:     def test_sort_index_level_mixed(self, multiindex_dataframe_random_data):
  648:         frame = multiindex_dataframe_random_data
  649: 
  650:         sorted_before = frame.sort_index(level=1)
  651: 
  652:         df = frame.copy()
  653:         df["foo"] = "bar"
  654:         sorted_after = df.sort_index(level=1)
  655:         tm.assert_frame_equal(sorted_before, sorted_after.drop(["foo"], axis=1))
  656: 
  657:         dft = frame.T
  658:         sorted_before = dft.sort_index(level=1, axis=1)
  659:         dft["foo", "three"] = "bar"
  660: 
  661:         sorted_after = dft.sort_index(level=1, axis=1)
  662:         tm.assert_frame_equal(
  663:             sorted_before.drop([("foo", "three")], axis=1),
  664:             sorted_after.drop([("foo", "three")], axis=1),
  665:         )
  666: 
  667:     def test_sort_index_preserve_levels(self, multiindex_dataframe_random_data):
  668:         frame = multiindex_dataframe_random_data
  669: 
  670:         result = frame.sort_index()
  671:         assert result.index.names == frame.index.names
  672: 
  673:     @pytest.mark.parametrize(
  674:         "gen,extra",
  675:         [
  676:             ([1.0, 3.0, 2.0, 5.0], 4.0),
  677:             ([1, 3, 2, 5], 4),
  678:             (
  679:                 [
  680:                     Timestamp("20130101"),
  681:                     Timestamp("20130103"),
  682:                     Timestamp("20130102"),
  683:                     Timestamp("20130105"),
  684:                 ],
  685:                 Timestamp("20130104"),
  686:             ),
  687:             (["1one", "3one", "2one", "5one"], "4one"),
  688:         ],
  689:     )
  690:     def test_sort_index_multilevel_repr_8017(self, gen, extra):
  691:         data = np.random.default_rng(2).standard_normal((3, 4))
  692: 
  693:         columns = MultiIndex.from_tuples([("red", i) for i in gen])
  694:         df = DataFrame(data, index=list("def"), columns=columns)
  695:         df2 = pd.concat(
  696:             [
  697:                 df,
  698:                 DataFrame(
  699:                     "world",
  700:                     index=list("def"),
  701:                     columns=MultiIndex.from_tuples([("red", extra)]),
  702:                 ),
  703:             ],
  704:             axis=1,
  705:         )
  706: 
  707:         # check that the repr is good
  708:         # make sure that we have a correct sparsified repr
  709:         # e.g. only 1 header of read
  710:         assert str(df2).splitlines()[0].split() == ["red"]
  711: 
  712:         # GH 8017
  713:         # sorting fails after columns added
  714: 
  715:         # construct single-dtype then sort
  716:         result = df.copy().sort_index(axis=1)
  717:         expected = df.iloc[:, [0, 2, 1, 3]]
  718:         tm.assert_frame_equal(result, expected)
  719: 
  720:         result = df2.sort_index(axis=1)
  721:         expected = df2.iloc[:, [0, 2, 1, 4, 3]]
  722:         tm.assert_frame_equal(result, expected)
  723: 
  724:         # setitem then sort
  725:         result = df.copy()
  726:         result[("red", extra)] = "world"
  727: 
  728:         result = result.sort_index(axis=1)
  729:         tm.assert_frame_equal(result, expected)
  730: 
  731:     @pytest.mark.parametrize(
  732:         "categories",
  733:         [
  734:             pytest.param(["a", "b", "c"], id="str"),
  735:             pytest.param(
  736:                 [pd.Interval(0, 1), pd.Interval(1, 2), pd.Interval(2, 3)],
  737:                 id="pd.Interval",
  738:             ),
  739:         ],
  740:     )
  741:     def test_sort_index_with_categories(self, categories):
  742:         # GH#23452
  743:         df = DataFrame(
  744:             {"foo": range(len(categories))},
  745:             index=CategoricalIndex(
  746:                 data=categories, categories=categories, ordered=True
  747:             ),
  748:         )
  749:         df.index = df.index.reorder_categories(df.index.categories[::-1])
  750:         result = df.sort_index()
  751:         expected = DataFrame(
  752:             {"foo": reversed(range(len(categories)))},
  753:             index=CategoricalIndex(
  754:                 data=categories[::-1], categories=categories[::-1], ordered=True
  755:             ),
  756:         )
  757:         tm.assert_frame_equal(result, expected)
  758: 
  759:     @pytest.mark.parametrize(
  760:         "ascending",
  761:         [
  762:             None,
  763:             [True, None],
  764:             [False, "True"],
  765:         ],
  766:     )
  767:     def test_sort_index_ascending_bad_value_raises(self, ascending):
  768:         # GH 39434
  769:         df = DataFrame(np.arange(64))
  770:         length = len(df.index)
  771:         df.index = [(i - length / 2) % length for i in range(length)]
  772:         match = 'For argument "ascending" expected type bool'
  773:         with pytest.raises(ValueError, match=match):
  774:             df.sort_index(axis=0, ascending=ascending, na_position="first")
  775: 
  776:     def test_sort_index_use_inf_as_na(self):
  777:         # GH 29687
  778:         expected = DataFrame(
  779:             {"col1": [1, 2, 3], "col2": [3, 4, 5]},
  780:             index=pd.date_range("2020", periods=3),
  781:         )
  782:         msg = "use_inf_as_na option is deprecated"
  783:         with tm.assert_produces_warning(FutureWarning, match=msg):
  784:             with pd.option_context("mode.use_inf_as_na", True):
  785:                 result = expected.sort_index()
  786:         tm.assert_frame_equal(result, expected)
  787: 
  788:     @pytest.mark.parametrize(
  789:         "ascending",
  790:         [(True, False), [True, False]],
  791:     )
  792:     def test_sort_index_ascending_tuple(self, ascending):
  793:         df = DataFrame(
  794:             {
  795:                 "legs": [4, 2, 4, 2, 2],
  796:             },
  797:             index=MultiIndex.from_tuples(
  798:                 [
  799:                     ("mammal", "dog"),
  800:                     ("bird", "duck"),
  801:                     ("mammal", "horse"),
  802:                     ("bird", "penguin"),
  803:                     ("mammal", "kangaroo"),
  804:                 ],
  805:                 names=["class", "animal"],
  806:             ),
  807:         )
  808: 
  809:         # parameter `ascending`` is a tuple
  810:         result = df.sort_index(level=(0, 1), ascending=ascending)
  811: 
  812:         expected = DataFrame(
  813:             {
  814:                 "legs": [2, 2, 2, 4, 4],
  815:             },
  816:             index=MultiIndex.from_tuples(
  817:                 [
  818:                     ("bird", "penguin"),
  819:                     ("bird", "duck"),
  820:                     ("mammal", "kangaroo"),
  821:                     ("mammal", "horse"),
  822:                     ("mammal", "dog"),
  823:                 ],
  824:                 names=["class", "animal"],
  825:             ),
  826:         )
  827: 
  828:         tm.assert_frame_equal(result, expected)
  829: 
  830: 
  831: class TestDataFrameSortIndexKey:
  832:     def test_sort_multi_index_key(self):
  833:         # GH 25775, testing that sorting by index works with a multi-index.
  834:         df = DataFrame(
  835:             {"a": [3, 1, 2], "b": [0, 0, 0], "c": [0, 1, 2], "d": list("abc")}
  836:         ).set_index(list("abc"))
  837: 
  838:         result = df.sort_index(level=list("ac"), key=lambda x: x)
  839: 
  840:         expected = DataFrame(
  841:             {"a": [1, 2, 3], "b": [0, 0, 0], "c": [1, 2, 0], "d": list("bca")}
  842:         ).set_index(list("abc"))
  843:         tm.assert_frame_equal(result, expected)
  844: 
  845:         result = df.sort_index(level=list("ac"), key=lambda x: -x)
  846:         expected = DataFrame(
  847:             {"a": [3, 2, 1], "b": [0, 0, 0], "c": [0, 2, 1], "d": list("acb")}
  848:         ).set_index(list("abc"))
  849: 
  850:         tm.assert_frame_equal(result, expected)
  851: 
  852:     def test_sort_index_key(self):  # issue 27237
  853:         df = DataFrame(np.arange(6, dtype="int64"), index=list("aaBBca"))
  854: 
  855:         result = df.sort_index()
  856:         expected = df.iloc[[2, 3, 0, 1, 5, 4]]
  857:         tm.assert_frame_equal(result, expected)
  858: 
  859:         result = df.sort_index(key=lambda x: x.str.lower())
  860:         expected = df.iloc[[0, 1, 5, 2, 3, 4]]
  861:         tm.assert_frame_equal(result, expected)
  862: 
  863:         result = df.sort_index(key=lambda x: x.str.lower(), ascending=False)
  864:         expected = df.iloc[[4, 2, 3, 0, 1, 5]]
  865:         tm.assert_frame_equal(result, expected)
  866: 
  867:     def test_sort_index_key_int(self):
  868:         df = DataFrame(np.arange(6, dtype="int64"), index=np.arange(6, dtype="int64"))
  869: 
  870:         result = df.sort_index()
  871:         tm.assert_frame_equal(result, df)
  872: 
  873:         result = df.sort_index(key=lambda x: -x)
  874:         expected = df.sort_index(ascending=False)
  875:         tm.assert_frame_equal(result, expected)
  876: 
  877:         result = df.sort_index(key=lambda x: 2 * x)
  878:         tm.assert_frame_equal(result, df)
  879: 
  880:     def test_sort_multi_index_key_str(self):
  881:         # GH 25775, testing that sorting by index works with a multi-index.
  882:         df = DataFrame(
  883:             {"a": ["B", "a", "C"], "b": [0, 1, 0], "c": list("abc"), "d": [0, 1, 2]}
  884:         ).set_index(list("abc"))
  885: 
  886:         result = df.sort_index(level="a", key=lambda x: x.str.lower())
  887: 
  888:         expected = DataFrame(
  889:             {"a": ["a", "B", "C"], "b": [1, 0, 0], "c": list("bac"), "d": [1, 0, 2]}
  890:         ).set_index(list("abc"))
  891:         tm.assert_frame_equal(result, expected)
  892: 
  893:         result = df.sort_index(
  894:             level=list("abc"),  # can refer to names
  895:             key=lambda x: x.str.lower() if x.name in ["a", "c"] else -x,
  896:         )
  897: 
  898:         expected = DataFrame(
  899:             {"a": ["a", "B", "C"], "b": [1, 0, 0], "c": list("bac"), "d": [1, 0, 2]}
  900:         ).set_index(list("abc"))
  901:         tm.assert_frame_equal(result, expected)
  902: 
  903:     def test_changes_length_raises(self):
  904:         df = DataFrame({"A": [1, 2, 3]})
  905:         with pytest.raises(ValueError, match="change the shape"):
  906:             df.sort_index(key=lambda x: x[:1])
  907: 
  908:     def test_sort_index_multiindex_sparse_column(self):
  909:         # GH 29735, testing that sort_index on a multiindexed frame with sparse
  910:         # columns fills with 0.
  911:         expected = DataFrame(
  912:             {
  913:                 i: pd.array([0.0, 0.0, 0.0, 0.0], dtype=pd.SparseDtype("float64", 0.0))
  914:                 for i in range(4)
  915:             },
  916:             index=MultiIndex.from_product([[1, 2], [1, 2]]),
  917:         )
  918: 
  919:         result = expected.sort_index(level=0)
  920: 
  921:         tm.assert_frame_equal(result, expected)
  922: 
  923:     def test_sort_index_na_position(self):
  924:         # GH#51612
  925:         df = DataFrame([1, 2], index=MultiIndex.from_tuples([(1, 1), (1, pd.NA)]))
  926:         expected = df.copy()
  927:         result = df.sort_index(level=[0, 1], na_position="last")
  928:         tm.assert_frame_equal(result, expected)
  929: 
  930:     @pytest.mark.parametrize("ascending", [True, False])
  931:     def test_sort_index_multiindex_sort_remaining(self, ascending):
  932:         # GH #24247
  933:         df = DataFrame(
  934:             {"A": [1, 2, 3, 4, 5], "B": [10, 20, 30, 40, 50]},
  935:             index=MultiIndex.from_tuples(
  936:                 [("a", "x"), ("a", "y"), ("b", "x"), ("b", "y"), ("c", "x")]
  937:             ),
  938:         )
  939: 
  940:         result = df.sort_index(level=1, sort_remaining=False, ascending=ascending)
  941: 
  942:         if ascending:
  943:             expected = DataFrame(
  944:                 {"A": [1, 3, 5, 2, 4], "B": [10, 30, 50, 20, 40]},
  945:                 index=MultiIndex.from_tuples(
  946:                     [("a", "x"), ("b", "x"), ("c", "x"), ("a", "y"), ("b", "y")]
  947:                 ),
  948:             )
  949:         else:
  950:             expected = DataFrame(
  951:                 {"A": [2, 4, 1, 3, 5], "B": [20, 40, 10, 30, 50]},
  952:                 index=MultiIndex.from_tuples(
  953:                     [("a", "y"), ("b", "y"), ("a", "x"), ("b", "x"), ("c", "x")]
  954:                 ),
  955:             )
  956: 
  957:         tm.assert_frame_equal(result, expected)
  958: 
  959: 
  960: def test_sort_index_with_sliced_multiindex():
  961:     # GH 55379
  962:     mi = MultiIndex.from_tuples(
  963:         [
  964:             ("a", "10"),
  965:             ("a", "18"),
  966:             ("a", "25"),
  967:             ("b", "16"),
  968:             ("b", "26"),
  969:             ("a", "45"),
  970:             ("b", "28"),
  971:             ("a", "5"),
  972:             ("a", "50"),
  973:             ("a", "51"),
  974:             ("b", "4"),
  975:         ],
  976:         names=["group", "str"],
  977:     )
  978: 
  979:     df = DataFrame({"x": range(len(mi))}, index=mi)
  980:     result = df.iloc[0:6].sort_index()
  981: 
  982:     expected = DataFrame(
  983:         {"x": [0, 1, 2, 5, 3, 4]},
  984:         index=MultiIndex.from_tuples(
  985:             [
  986:                 ("a", "10"),
  987:                 ("a", "18"),
  988:                 ("a", "25"),
  989:                 ("a", "45"),
  990:                 ("b", "16"),
  991:                 ("b", "26"),
  992:             ],
  993:             names=["group", "str"],
  994:         ),
  995:     )
  996:     tm.assert_frame_equal(result, expected)
  997: 
  998: 
  999: def test_axis_columns_ignore_index():
 1000:     # GH 56478
 1001:     df = DataFrame([[1, 2]], columns=["d", "c"])
 1002:     result = df.sort_index(axis="columns", ignore_index=True)
 1003:     expected = DataFrame([[2, 1]])
 1004:     tm.assert_frame_equal(result, expected)
 1005: 
 1006: 
 1007: def test_sort_index_stable_sort():
 1008:     # GH 57151
 1009:     df = DataFrame(
 1010:         data=[
 1011:             (Timestamp("2024-01-30 13:00:00"), 13.0),
 1012:             (Timestamp("2024-01-30 13:00:00"), 13.1),
 1013:             (Timestamp("2024-01-30 12:00:00"), 12.0),
 1014:             (Timestamp("2024-01-30 12:00:00"), 12.1),
 1015:         ],
 1016:         columns=["dt", "value"],
 1017:     ).set_index(["dt"])
 1018:     result = df.sort_index(level="dt", kind="stable")
 1019:     expected = DataFrame(
 1020:         data=[
 1021:             (Timestamp("2024-01-30 12:00:00"), 12.0),
 1022:             (Timestamp("2024-01-30 12:00:00"), 12.1),
 1023:             (Timestamp("2024-01-30 13:00:00"), 13.0),
 1024:             (Timestamp("2024-01-30 13:00:00"), 13.1),
 1025:         ],
 1026:         columns=["dt", "value"],
 1027:     ).set_index(["dt"])
 1028:     tm.assert_frame_equal(result, expected)
