    1: import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.compat import (
    7:     IS64,
    8:     is_platform_windows,
    9: )
   10: 
   11: from pandas import (
   12:     Categorical,
   13:     DataFrame,
   14:     Series,
   15:     date_range,
   16: )
   17: import pandas._testing as tm
   18: 
   19: 
   20: class TestIteration:
   21:     def test_keys(self, float_frame):
   22:         assert float_frame.keys() is float_frame.columns
   23: 
   24:     def test_iteritems(self):
   25:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=["a", "a", "b"])
   26:         for k, v in df.items():
   27:             assert isinstance(v, DataFrame._constructor_sliced)
   28: 
   29:     def test_items(self):
   30:         # GH#17213, GH#13918
   31:         cols = ["a", "b", "c"]
   32:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=cols)
   33:         for c, (k, v) in zip(cols, df.items()):
   34:             assert c == k
   35:             assert isinstance(v, Series)
   36:             assert (df[k] == v).all()
   37: 
   38:     def test_items_names(self, float_string_frame):
   39:         for k, v in float_string_frame.items():
   40:             assert v.name == k
   41: 
   42:     def test_iter(self, float_frame):
   43:         assert list(float_frame) == list(float_frame.columns)
   44: 
   45:     def test_iterrows(self, float_frame, float_string_frame):
   46:         for k, v in float_frame.iterrows():
   47:             exp = float_frame.loc[k]
   48:             tm.assert_series_equal(v, exp)
   49: 
   50:         for k, v in float_string_frame.iterrows():
   51:             exp = float_string_frame.loc[k]
   52:             tm.assert_series_equal(v, exp)
   53: 
   54:     def test_iterrows_iso8601(self):
   55:         # GH#19671
   56:         s = DataFrame(
   57:             {
   58:                 "non_iso8601": ["M1701", "M1802", "M1903", "M2004"],
   59:                 "iso8601": date_range("2000-01-01", periods=4, freq="ME"),
   60:             }
   61:         )
   62:         for k, v in s.iterrows():
   63:             exp = s.loc[k]
   64:             tm.assert_series_equal(v, exp)
   65: 
   66:     def test_iterrows_corner(self):
   67:         # GH#12222
   68:         df = DataFrame(
   69:             {
   70:                 "a": [datetime.datetime(2015, 1, 1)],
   71:                 "b": [None],
   72:                 "c": [None],
   73:                 "d": [""],
   74:                 "e": [[]],
   75:                 "f": [set()],
   76:                 "g": [{}],
   77:             }
   78:         )
   79:         expected = Series(
   80:             [datetime.datetime(2015, 1, 1), None, None, "", [], set(), {}],
   81:             index=list("abcdefg"),
   82:             name=0,
   83:             dtype="object",
   84:         )
   85:         _, result = next(df.iterrows())
   86:         tm.assert_series_equal(result, expected)
   87: 
   88:     def test_itertuples(self, float_frame):
   89:         for i, tup in enumerate(float_frame.itertuples()):
   90:             ser = DataFrame._constructor_sliced(tup[1:])
   91:             ser.name = tup[0]
   92:             expected = float_frame.iloc[i, :].reset_index(drop=True)
   93:             tm.assert_series_equal(ser, expected)
   94: 
   95:     def test_itertuples_index_false(self):
   96:         df = DataFrame(
   97:             {"floats": np.random.default_rng(2).standard_normal(5), "ints": range(5)},
   98:             columns=["floats", "ints"],
   99:         )
  100: 
  101:         for tup in df.itertuples(index=False):
  102:             assert isinstance(tup[1], int)
  103: 
  104:     def test_itertuples_duplicate_cols(self):
  105:         df = DataFrame(data={"a": [1, 2, 3], "b": [4, 5, 6]})
  106:         dfaa = df[["a", "a"]]
  107: 
  108:         assert list(dfaa.itertuples()) == [(0, 1, 1), (1, 2, 2), (2, 3, 3)]
  109: 
  110:         # repr with int on 32-bit/windows
  111:         if not (is_platform_windows() or not IS64):
  112:             assert (
  113:                 repr(list(df.itertuples(name=None)))
  114:                 == "[(0, 1, 4), (1, 2, 5), (2, 3, 6)]"
  115:             )
  116: 
  117:     def test_itertuples_tuple_name(self):
  118:         df = DataFrame(data={"a": [1, 2, 3], "b": [4, 5, 6]})
  119:         tup = next(df.itertuples(name="TestName"))
  120:         assert tup._fields == ("Index", "a", "b")
  121:         assert (tup.Index, tup.a, tup.b) == tup
  122:         assert type(tup).__name__ == "TestName"
  123: 
  124:     def test_itertuples_disallowed_col_labels(self):
  125:         df = DataFrame(data={"def": [1, 2, 3], "return": [4, 5, 6]})
  126:         tup2 = next(df.itertuples(name="TestName"))
  127:         assert tup2 == (0, 1, 4)
  128:         assert tup2._fields == ("Index", "_1", "_2")
  129: 
  130:     @pytest.mark.parametrize("limit", [254, 255, 1024])
  131:     @pytest.mark.parametrize("index", [True, False])
  132:     def test_itertuples_py2_3_field_limit_namedtuple(self, limit, index):
  133:         # GH#28282
  134:         df = DataFrame([{f"foo_{i}": f"bar_{i}" for i in range(limit)}])
  135:         result = next(df.itertuples(index=index))
  136:         assert isinstance(result, tuple)
  137:         assert hasattr(result, "_fields")
  138: 
  139:     def test_sequence_like_with_categorical(self):
  140:         # GH#7839
  141:         # make sure can iterate
  142:         df = DataFrame(
  143:             {"id": [1, 2, 3, 4, 5, 6], "raw_grade": ["a", "b", "b", "a", "a", "e"]}
  144:         )
  145:         df["grade"] = Categorical(df["raw_grade"])
  146: 
  147:         # basic sequencing testing
  148:         result = list(df.grade.values)
  149:         expected = np.array(df.grade.values).tolist()
  150:         tm.assert_almost_equal(result, expected)
  151: 
  152:         # iteration
  153:         for t in df.itertuples(index=False):
  154:             str(t)
  155: 
  156:         for row, s in df.iterrows():
  157:             str(s)
  158: 
  159:         for c, col in df.items():
  160:             str(col)
