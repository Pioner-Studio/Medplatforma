    1: """ Test cases for misc plot functions """
    2: import os
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas.util._test_decorators as td
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     Index,
   12:     Series,
   13:     Timestamp,
   14:     date_range,
   15:     interval_range,
   16:     period_range,
   17:     plotting,
   18:     read_csv,
   19: )
   20: import pandas._testing as tm
   21: from pandas.tests.plotting.common import (
   22:     _check_colors,
   23:     _check_legend_labels,
   24:     _check_plot_works,
   25:     _check_text_labels,
   26:     _check_ticks_props,
   27: )
   28: 
   29: mpl = pytest.importorskip("matplotlib")
   30: plt = pytest.importorskip("matplotlib.pyplot")
   31: cm = pytest.importorskip("matplotlib.cm")
   32: 
   33: 
   34: @pytest.fixture
   35: def iris(datapath) -> DataFrame:
   36:     """
   37:     The iris dataset as a DataFrame.
   38:     """
   39:     return read_csv(datapath("io", "data", "csv", "iris.csv"))
   40: 
   41: 
   42: @td.skip_if_installed("matplotlib")
   43: def test_import_error_message():
   44:     # GH-19810
   45:     df = DataFrame({"A": [1, 2]})
   46: 
   47:     with pytest.raises(ImportError, match="matplotlib is required for plotting"):
   48:         df.plot()
   49: 
   50: 
   51: def test_get_accessor_args():
   52:     func = plotting._core.PlotAccessor._get_call_args
   53: 
   54:     msg = "Called plot accessor for type list, expected Series or DataFrame"
   55:     with pytest.raises(TypeError, match=msg):
   56:         func(backend_name="", data=[], args=[], kwargs={})
   57: 
   58:     msg = "should not be called with positional arguments"
   59:     with pytest.raises(TypeError, match=msg):
   60:         func(backend_name="", data=Series(dtype=object), args=["line", None], kwargs={})
   61: 
   62:     x, y, kind, kwargs = func(
   63:         backend_name="",
   64:         data=DataFrame(),
   65:         args=["x"],
   66:         kwargs={"y": "y", "kind": "bar", "grid": False},
   67:     )
   68:     assert x == "x"
   69:     assert y == "y"
   70:     assert kind == "bar"
   71:     assert kwargs == {"grid": False}
   72: 
   73:     x, y, kind, kwargs = func(
   74:         backend_name="pandas.plotting._matplotlib",
   75:         data=Series(dtype=object),
   76:         args=[],
   77:         kwargs={},
   78:     )
   79:     assert x is None
   80:     assert y is None
   81:     assert kind == "line"
   82:     assert len(kwargs) == 24
   83: 
   84: 
   85: @pytest.mark.parametrize("kind", plotting.PlotAccessor._all_kinds)
   86: @pytest.mark.parametrize(
   87:     "data", [DataFrame(np.arange(15).reshape(5, 3)), Series(range(5))]
   88: )
   89: @pytest.mark.parametrize(
   90:     "index",
   91:     [
   92:         Index(range(5)),
   93:         date_range("2020-01-01", periods=5),
   94:         period_range("2020-01-01", periods=5),
   95:     ],
   96: )
   97: def test_savefig(kind, data, index):
   98:     fig, ax = plt.subplots()
   99:     data.index = index
  100:     kwargs = {}
  101:     if kind in ["hexbin", "scatter", "pie"]:
  102:         if isinstance(data, Series):
  103:             pytest.skip(f"{kind} not supported with Series")
  104:         kwargs = {"x": 0, "y": 1}
  105:     data.plot(kind=kind, ax=ax, **kwargs)
  106:     fig.savefig(os.devnull)
  107: 
  108: 
  109: class TestSeriesPlots:
  110:     def test_autocorrelation_plot(self):
  111:         from pandas.plotting import autocorrelation_plot
  112: 
  113:         ser = Series(
  114:             np.arange(10, dtype=np.float64),
  115:             index=date_range("2020-01-01", periods=10),
  116:             name="ts",
  117:         )
  118:         # Ensure no UserWarning when making plot
  119:         with tm.assert_produces_warning(None):
  120:             _check_plot_works(autocorrelation_plot, series=ser)
  121:             _check_plot_works(autocorrelation_plot, series=ser.values)
  122: 
  123:             ax = autocorrelation_plot(ser, label="Test")
  124:         _check_legend_labels(ax, labels=["Test"])
  125: 
  126:     @pytest.mark.parametrize("kwargs", [{}, {"lag": 5}])
  127:     def test_lag_plot(self, kwargs):
  128:         from pandas.plotting import lag_plot
  129: 
  130:         ser = Series(
  131:             np.arange(10, dtype=np.float64),
  132:             index=date_range("2020-01-01", periods=10),
  133:             name="ts",
  134:         )
  135:         _check_plot_works(lag_plot, series=ser, **kwargs)
  136: 
  137:     def test_bootstrap_plot(self):
  138:         from pandas.plotting import bootstrap_plot
  139: 
  140:         ser = Series(
  141:             np.arange(10, dtype=np.float64),
  142:             index=date_range("2020-01-01", periods=10),
  143:             name="ts",
  144:         )
  145:         _check_plot_works(bootstrap_plot, series=ser, size=10)
  146: 
  147: 
  148: class TestDataFramePlots:
  149:     @pytest.mark.parametrize("pass_axis", [False, True])
  150:     def test_scatter_matrix_axis(self, pass_axis):
  151:         pytest.importorskip("scipy")
  152:         scatter_matrix = plotting.scatter_matrix
  153: 
  154:         ax = None
  155:         if pass_axis:
  156:             _, ax = mpl.pyplot.subplots(3, 3)
  157: 
  158:         df = DataFrame(np.random.default_rng(2).standard_normal((100, 3)))
  159: 
  160:         # we are plotting multiples on a sub-plot
  161:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  162:             axes = _check_plot_works(
  163:                 scatter_matrix,
  164:                 frame=df,
  165:                 range_padding=0.1,
  166:                 ax=ax,
  167:             )
  168:         axes0_labels = axes[0][0].yaxis.get_majorticklabels()
  169:         # GH 5662
  170:         expected = ["-2", "0", "2"]
  171:         _check_text_labels(axes0_labels, expected)
  172:         _check_ticks_props(axes, xlabelsize=8, xrot=90, ylabelsize=8, yrot=0)
  173: 
  174:     @pytest.mark.parametrize("pass_axis", [False, True])
  175:     def test_scatter_matrix_axis_smaller(self, pass_axis):
  176:         pytest.importorskip("scipy")
  177:         scatter_matrix = plotting.scatter_matrix
  178: 
  179:         ax = None
  180:         if pass_axis:
  181:             _, ax = mpl.pyplot.subplots(3, 3)
  182: 
  183:         df = DataFrame(np.random.default_rng(11).standard_normal((100, 3)))
  184:         df[0] = (df[0] - 2) / 3
  185: 
  186:         # we are plotting multiples on a sub-plot
  187:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  188:             axes = _check_plot_works(
  189:                 scatter_matrix,
  190:                 frame=df,
  191:                 range_padding=0.1,
  192:                 ax=ax,
  193:             )
  194:         axes0_labels = axes[0][0].yaxis.get_majorticklabels()
  195:         expected = ["-1.0", "-0.5", "0.0"]
  196:         _check_text_labels(axes0_labels, expected)
  197:         _check_ticks_props(axes, xlabelsize=8, xrot=90, ylabelsize=8, yrot=0)
  198: 
  199:     @pytest.mark.slow
  200:     def test_andrews_curves_no_warning(self, iris):
  201:         from pandas.plotting import andrews_curves
  202: 
  203:         df = iris
  204:         # Ensure no UserWarning when making plot
  205:         with tm.assert_produces_warning(None):
  206:             _check_plot_works(andrews_curves, frame=df, class_column="Name")
  207: 
  208:     @pytest.mark.slow
  209:     @pytest.mark.parametrize(
  210:         "linecolors",
  211:         [
  212:             ("#556270", "#4ECDC4", "#C7F464"),
  213:             ["dodgerblue", "aquamarine", "seagreen"],
  214:         ],
  215:     )
  216:     @pytest.mark.parametrize(
  217:         "df",
  218:         [
  219:             "iris",
  220:             DataFrame(
  221:                 {
  222:                     "A": np.random.default_rng(2).standard_normal(10),
  223:                     "B": np.random.default_rng(2).standard_normal(10),
  224:                     "C": np.random.default_rng(2).standard_normal(10),
  225:                     "Name": ["A"] * 10,
  226:                 }
  227:             ),
  228:         ],
  229:     )
  230:     def test_andrews_curves_linecolors(self, request, df, linecolors):
  231:         from pandas.plotting import andrews_curves
  232: 
  233:         if isinstance(df, str):
  234:             df = request.getfixturevalue(df)
  235:         ax = _check_plot_works(
  236:             andrews_curves, frame=df, class_column="Name", color=linecolors
  237:         )
  238:         _check_colors(
  239:             ax.get_lines()[:10], linecolors=linecolors, mapping=df["Name"][:10]
  240:         )
  241: 
  242:     @pytest.mark.slow
  243:     @pytest.mark.parametrize(
  244:         "df",
  245:         [
  246:             "iris",
  247:             DataFrame(
  248:                 {
  249:                     "A": np.random.default_rng(2).standard_normal(10),
  250:                     "B": np.random.default_rng(2).standard_normal(10),
  251:                     "C": np.random.default_rng(2).standard_normal(10),
  252:                     "Name": ["A"] * 10,
  253:                 }
  254:             ),
  255:         ],
  256:     )
  257:     def test_andrews_curves_cmap(self, request, df):
  258:         from pandas.plotting import andrews_curves
  259: 
  260:         if isinstance(df, str):
  261:             df = request.getfixturevalue(df)
  262:         cmaps = [cm.jet(n) for n in np.linspace(0, 1, df["Name"].nunique())]
  263:         ax = _check_plot_works(
  264:             andrews_curves, frame=df, class_column="Name", color=cmaps
  265:         )
  266:         _check_colors(ax.get_lines()[:10], linecolors=cmaps, mapping=df["Name"][:10])
  267: 
  268:     @pytest.mark.slow
  269:     def test_andrews_curves_handle(self):
  270:         from pandas.plotting import andrews_curves
  271: 
  272:         colors = ["b", "g", "r"]
  273:         df = DataFrame({"A": [1, 2, 3], "B": [1, 2, 3], "C": [1, 2, 3], "Name": colors})
  274:         ax = andrews_curves(df, "Name", color=colors)
  275:         handles, _ = ax.get_legend_handles_labels()
  276:         _check_colors(handles, linecolors=colors)
  277: 
  278:     @pytest.mark.slow
  279:     @pytest.mark.parametrize(
  280:         "color",
  281:         [("#556270", "#4ECDC4", "#C7F464"), ["dodgerblue", "aquamarine", "seagreen"]],
  282:     )
  283:     def test_parallel_coordinates_colors(self, iris, color):
  284:         from pandas.plotting import parallel_coordinates
  285: 
  286:         df = iris
  287: 
  288:         ax = _check_plot_works(
  289:             parallel_coordinates, frame=df, class_column="Name", color=color
  290:         )
  291:         _check_colors(ax.get_lines()[:10], linecolors=color, mapping=df["Name"][:10])
  292: 
  293:     @pytest.mark.slow
  294:     def test_parallel_coordinates_cmap(self, iris):
  295:         from matplotlib import cm
  296: 
  297:         from pandas.plotting import parallel_coordinates
  298: 
  299:         df = iris
  300: 
  301:         ax = _check_plot_works(
  302:             parallel_coordinates, frame=df, class_column="Name", colormap=cm.jet
  303:         )
  304:         cmaps = [cm.jet(n) for n in np.linspace(0, 1, df["Name"].nunique())]
  305:         _check_colors(ax.get_lines()[:10], linecolors=cmaps, mapping=df["Name"][:10])
  306: 
  307:     @pytest.mark.slow
  308:     def test_parallel_coordinates_line_diff(self, iris):
  309:         from pandas.plotting import parallel_coordinates
  310: 
  311:         df = iris
  312: 
  313:         ax = _check_plot_works(parallel_coordinates, frame=df, class_column="Name")
  314:         nlines = len(ax.get_lines())
  315:         nxticks = len(ax.xaxis.get_ticklabels())
  316: 
  317:         ax = _check_plot_works(
  318:             parallel_coordinates, frame=df, class_column="Name", axvlines=False
  319:         )
  320:         assert len(ax.get_lines()) == (nlines - nxticks)
  321: 
  322:     @pytest.mark.slow
  323:     def test_parallel_coordinates_handles(self, iris):
  324:         from pandas.plotting import parallel_coordinates
  325: 
  326:         df = iris
  327:         colors = ["b", "g", "r"]
  328:         df = DataFrame({"A": [1, 2, 3], "B": [1, 2, 3], "C": [1, 2, 3], "Name": colors})
  329:         ax = parallel_coordinates(df, "Name", color=colors)
  330:         handles, _ = ax.get_legend_handles_labels()
  331:         _check_colors(handles, linecolors=colors)
  332: 
  333:     # not sure if this is indicative of a problem
  334:     @pytest.mark.filterwarnings("ignore:Attempting to set:UserWarning")
  335:     def test_parallel_coordinates_with_sorted_labels(self):
  336:         """For #15908"""
  337:         from pandas.plotting import parallel_coordinates
  338: 
  339:         df = DataFrame(
  340:             {
  341:                 "feat": list(range(30)),
  342:                 "class": [2 for _ in range(10)]
  343:                 + [3 for _ in range(10)]
  344:                 + [1 for _ in range(10)],
  345:             }
  346:         )
  347:         ax = parallel_coordinates(df, "class", sort_labels=True)
  348:         polylines, labels = ax.get_legend_handles_labels()
  349:         color_label_tuples = zip(
  350:             [polyline.get_color() for polyline in polylines], labels
  351:         )
  352:         ordered_color_label_tuples = sorted(color_label_tuples, key=lambda x: x[1])
  353:         prev_next_tupels = zip(
  354:             list(ordered_color_label_tuples[0:-1]), list(ordered_color_label_tuples[1:])
  355:         )
  356:         for prev, nxt in prev_next_tupels:
  357:             # labels and colors are ordered strictly increasing
  358:             assert prev[1] < nxt[1] and prev[0] < nxt[0]
  359: 
  360:     def test_radviz_no_warning(self, iris):
  361:         from pandas.plotting import radviz
  362: 
  363:         df = iris
  364:         # Ensure no UserWarning when making plot
  365:         with tm.assert_produces_warning(None):
  366:             _check_plot_works(radviz, frame=df, class_column="Name")
  367: 
  368:     @pytest.mark.parametrize(
  369:         "color",
  370:         [("#556270", "#4ECDC4", "#C7F464"), ["dodgerblue", "aquamarine", "seagreen"]],
  371:     )
  372:     def test_radviz_color(self, iris, color):
  373:         from pandas.plotting import radviz
  374: 
  375:         df = iris
  376:         ax = _check_plot_works(radviz, frame=df, class_column="Name", color=color)
  377:         # skip Circle drawn as ticks
  378:         patches = [p for p in ax.patches[:20] if p.get_label() != ""]
  379:         _check_colors(patches[:10], facecolors=color, mapping=df["Name"][:10])
  380: 
  381:     def test_radviz_color_cmap(self, iris):
  382:         from matplotlib import cm
  383: 
  384:         from pandas.plotting import radviz
  385: 
  386:         df = iris
  387:         ax = _check_plot_works(radviz, frame=df, class_column="Name", colormap=cm.jet)
  388:         cmaps = [cm.jet(n) for n in np.linspace(0, 1, df["Name"].nunique())]
  389:         patches = [p for p in ax.patches[:20] if p.get_label() != ""]
  390:         _check_colors(patches, facecolors=cmaps, mapping=df["Name"][:10])
  391: 
  392:     def test_radviz_colors_handles(self):
  393:         from pandas.plotting import radviz
  394: 
  395:         colors = [[0.0, 0.0, 1.0, 1.0], [0.0, 0.5, 1.0, 1.0], [1.0, 0.0, 0.0, 1.0]]
  396:         df = DataFrame(
  397:             {"A": [1, 2, 3], "B": [2, 1, 3], "C": [3, 2, 1], "Name": ["b", "g", "r"]}
  398:         )
  399:         ax = radviz(df, "Name", color=colors)
  400:         handles, _ = ax.get_legend_handles_labels()
  401:         _check_colors(handles, facecolors=colors)
  402: 
  403:     def test_subplot_titles(self, iris):
  404:         df = iris.drop("Name", axis=1).head()
  405:         # Use the column names as the subplot titles
  406:         title = list(df.columns)
  407: 
  408:         # Case len(title) == len(df)
  409:         plot = df.plot(subplots=True, title=title)
  410:         assert [p.get_title() for p in plot] == title
  411: 
  412:     def test_subplot_titles_too_much(self, iris):
  413:         df = iris.drop("Name", axis=1).head()
  414:         # Use the column names as the subplot titles
  415:         title = list(df.columns)
  416:         # Case len(title) > len(df)
  417:         msg = (
  418:             "The length of `title` must equal the number of columns if "
  419:             "using `title` of type `list` and `subplots=True`"
  420:         )
  421:         with pytest.raises(ValueError, match=msg):
  422:             df.plot(subplots=True, title=title + ["kittens > puppies"])
  423: 
  424:     def test_subplot_titles_too_little(self, iris):
  425:         df = iris.drop("Name", axis=1).head()
  426:         # Use the column names as the subplot titles
  427:         title = list(df.columns)
  428:         msg = (
  429:             "The length of `title` must equal the number of columns if "
  430:             "using `title` of type `list` and `subplots=True`"
  431:         )
  432:         # Case len(title) < len(df)
  433:         with pytest.raises(ValueError, match=msg):
  434:             df.plot(subplots=True, title=title[:2])
  435: 
  436:     def test_subplot_titles_subplots_false(self, iris):
  437:         df = iris.drop("Name", axis=1).head()
  438:         # Use the column names as the subplot titles
  439:         title = list(df.columns)
  440:         # Case subplots=False and title is of type list
  441:         msg = (
  442:             "Using `title` of type `list` is not supported unless "
  443:             "`subplots=True` is passed"
  444:         )
  445:         with pytest.raises(ValueError, match=msg):
  446:             df.plot(subplots=False, title=title)
  447: 
  448:     def test_subplot_titles_numeric_square_layout(self, iris):
  449:         df = iris.drop("Name", axis=1).head()
  450:         # Use the column names as the subplot titles
  451:         title = list(df.columns)
  452:         # Case df with 3 numeric columns but layout of (2,2)
  453:         plot = df.drop("SepalWidth", axis=1).plot(
  454:             subplots=True, layout=(2, 2), title=title[:-1]
  455:         )
  456:         title_list = [ax.get_title() for sublist in plot for ax in sublist]
  457:         assert title_list == title[:3] + [""]
  458: 
  459:     def test_get_standard_colors_random_seed(self):
  460:         # GH17525
  461:         df = DataFrame(np.zeros((10, 10)))
  462: 
  463:         # Make sure that the random seed isn't reset by get_standard_colors
  464:         plotting.parallel_coordinates(df, 0)
  465:         rand1 = np.random.default_rng(None).random()
  466:         plotting.parallel_coordinates(df, 0)
  467:         rand2 = np.random.default_rng(None).random()
  468:         assert rand1 != rand2
  469: 
  470:     def test_get_standard_colors_consistency(self):
  471:         # GH17525
  472:         # Make sure it produces the same colors every time it's called
  473:         from pandas.plotting._matplotlib.style import get_standard_colors
  474: 
  475:         color1 = get_standard_colors(1, color_type="random")
  476:         color2 = get_standard_colors(1, color_type="random")
  477:         assert color1 == color2
  478: 
  479:     def test_get_standard_colors_default_num_colors(self):
  480:         from pandas.plotting._matplotlib.style import get_standard_colors
  481: 
  482:         # Make sure the default color_types returns the specified amount
  483:         color1 = get_standard_colors(1, color_type="default")
  484:         color2 = get_standard_colors(9, color_type="default")
  485:         color3 = get_standard_colors(20, color_type="default")
  486:         assert len(color1) == 1
  487:         assert len(color2) == 9
  488:         assert len(color3) == 20
  489: 
  490:     def test_plot_single_color(self):
  491:         # Example from #20585. All 3 bars should have the same color
  492:         df = DataFrame(
  493:             {
  494:                 "account-start": ["2017-02-03", "2017-03-03", "2017-01-01"],
  495:                 "client": ["Alice Anders", "Bob Baker", "Charlie Chaplin"],
  496:                 "balance": [-1432.32, 10.43, 30000.00],
  497:                 "db-id": [1234, 2424, 251],
  498:                 "proxy-id": [525, 1525, 2542],
  499:                 "rank": [52, 525, 32],
  500:             }
  501:         )
  502:         ax = df.client.value_counts().plot.bar()
  503:         colors = [rect.get_facecolor() for rect in ax.get_children()[0:3]]
  504:         assert all(color == colors[0] for color in colors)
  505: 
  506:     def test_get_standard_colors_no_appending(self):
  507:         # GH20726
  508: 
  509:         # Make sure not to add more colors so that matplotlib can cycle
  510:         # correctly.
  511:         from matplotlib import cm
  512: 
  513:         from pandas.plotting._matplotlib.style import get_standard_colors
  514: 
  515:         color_before = cm.gnuplot(range(5))
  516:         color_after = get_standard_colors(1, color=color_before)
  517:         assert len(color_after) == len(color_before)
  518: 
  519:         df = DataFrame(
  520:             np.random.default_rng(2).standard_normal((48, 4)), columns=list("ABCD")
  521:         )
  522: 
  523:         color_list = cm.gnuplot(np.linspace(0, 1, 16))
  524:         p = df.A.plot.bar(figsize=(16, 7), color=color_list)
  525:         assert p.patches[1].get_facecolor() == p.patches[17].get_facecolor()
  526: 
  527:     @pytest.mark.parametrize("kind", ["bar", "line"])
  528:     def test_dictionary_color(self, kind):
  529:         # issue-8193
  530:         # Test plot color dictionary format
  531:         data_files = ["a", "b"]
  532: 
  533:         expected = [(0.5, 0.24, 0.6), (0.3, 0.7, 0.7)]
  534: 
  535:         df1 = DataFrame(np.random.default_rng(2).random((2, 2)), columns=data_files)
  536:         dic_color = {"b": (0.3, 0.7, 0.7), "a": (0.5, 0.24, 0.6)}
  537: 
  538:         ax = df1.plot(kind=kind, color=dic_color)
  539:         if kind == "bar":
  540:             colors = [rect.get_facecolor()[0:-1] for rect in ax.get_children()[0:3:2]]
  541:         else:
  542:             colors = [rect.get_color() for rect in ax.get_lines()[0:2]]
  543:         assert all(color == expected[index] for index, color in enumerate(colors))
  544: 
  545:     def test_bar_plot(self):
  546:         # GH38947
  547:         # Test bar plot with string and int index
  548:         from matplotlib.text import Text
  549: 
  550:         expected = [Text(0, 0, "0"), Text(1, 0, "Total")]
  551: 
  552:         df = DataFrame(
  553:             {
  554:                 "a": [1, 2],
  555:             },
  556:             index=Index([0, "Total"]),
  557:         )
  558:         plot_bar = df.plot.bar()
  559:         assert all(
  560:             (a.get_text() == b.get_text())
  561:             for a, b in zip(plot_bar.get_xticklabels(), expected)
  562:         )
  563: 
  564:     def test_barh_plot_labels_mixed_integer_string(self):
  565:         # GH39126
  566:         # Test barh plot with string and integer at the same column
  567:         from matplotlib.text import Text
  568: 
  569:         df = DataFrame([{"word": 1, "value": 0}, {"word": "knowledge", "value": 2}])
  570:         plot_barh = df.plot.barh(x="word", legend=None)
  571:         expected_yticklabels = [Text(0, 0, "1"), Text(0, 1, "knowledge")]
  572:         assert all(
  573:             actual.get_text() == expected.get_text()
  574:             for actual, expected in zip(
  575:                 plot_barh.get_yticklabels(), expected_yticklabels
  576:             )
  577:         )
  578: 
  579:     def test_has_externally_shared_axis_x_axis(self):
  580:         # GH33819
  581:         # Test _has_externally_shared_axis() works for x-axis
  582:         func = plotting._matplotlib.tools._has_externally_shared_axis
  583: 
  584:         fig = mpl.pyplot.figure()
  585:         plots = fig.subplots(2, 4)
  586: 
  587:         # Create *externally* shared axes for first and third columns
  588:         plots[0][0] = fig.add_subplot(231, sharex=plots[1][0])
  589:         plots[0][2] = fig.add_subplot(233, sharex=plots[1][2])
  590: 
  591:         # Create *internally* shared axes for second and third columns
  592:         plots[0][1].twinx()
  593:         plots[0][2].twinx()
  594: 
  595:         # First  column is only externally shared
  596:         # Second column is only internally shared
  597:         # Third  column is both
  598:         # Fourth column is neither
  599:         assert func(plots[0][0], "x")
  600:         assert not func(plots[0][1], "x")
  601:         assert func(plots[0][2], "x")
  602:         assert not func(plots[0][3], "x")
  603: 
  604:     def test_has_externally_shared_axis_y_axis(self):
  605:         # GH33819
  606:         # Test _has_externally_shared_axis() works for y-axis
  607:         func = plotting._matplotlib.tools._has_externally_shared_axis
  608: 
  609:         fig = mpl.pyplot.figure()
  610:         plots = fig.subplots(4, 2)
  611: 
  612:         # Create *externally* shared axes for first and third rows
  613:         plots[0][0] = fig.add_subplot(321, sharey=plots[0][1])
  614:         plots[2][0] = fig.add_subplot(325, sharey=plots[2][1])
  615: 
  616:         # Create *internally* shared axes for second and third rows
  617:         plots[1][0].twiny()
  618:         plots[2][0].twiny()
  619: 
  620:         # First  row is only externally shared
  621:         # Second row is only internally shared
  622:         # Third  row is both
  623:         # Fourth row is neither
  624:         assert func(plots[0][0], "y")
  625:         assert not func(plots[1][0], "y")
  626:         assert func(plots[2][0], "y")
  627:         assert not func(plots[3][0], "y")
  628: 
  629:     def test_has_externally_shared_axis_invalid_compare_axis(self):
  630:         # GH33819
  631:         # Test _has_externally_shared_axis() raises an exception when
  632:         # passed an invalid value as compare_axis parameter
  633:         func = plotting._matplotlib.tools._has_externally_shared_axis
  634: 
  635:         fig = mpl.pyplot.figure()
  636:         plots = fig.subplots(4, 2)
  637: 
  638:         # Create arbitrary axes
  639:         plots[0][0] = fig.add_subplot(321, sharey=plots[0][1])
  640: 
  641:         # Check that an invalid compare_axis value triggers the expected exception
  642:         msg = "needs 'x' or 'y' as a second parameter"
  643:         with pytest.raises(ValueError, match=msg):
  644:             func(plots[0][0], "z")
  645: 
  646:     def test_externally_shared_axes(self):
  647:         # Example from GH33819
  648:         # Create data
  649:         df = DataFrame(
  650:             {
  651:                 "a": np.random.default_rng(2).standard_normal(1000),
  652:                 "b": np.random.default_rng(2).standard_normal(1000),
  653:             }
  654:         )
  655: 
  656:         # Create figure
  657:         fig = mpl.pyplot.figure()
  658:         plots = fig.subplots(2, 3)
  659: 
  660:         # Create *externally* shared axes
  661:         plots[0][0] = fig.add_subplot(231, sharex=plots[1][0])
  662:         # note: no plots[0][1] that's the twin only case
  663:         plots[0][2] = fig.add_subplot(233, sharex=plots[1][2])
  664: 
  665:         # Create *internally* shared axes
  666:         # note: no plots[0][0] that's the external only case
  667:         twin_ax1 = plots[0][1].twinx()
  668:         twin_ax2 = plots[0][2].twinx()
  669: 
  670:         # Plot data to primary axes
  671:         df["a"].plot(ax=plots[0][0], title="External share only").set_xlabel(
  672:             "this label should never be visible"
  673:         )
  674:         df["a"].plot(ax=plots[1][0])
  675: 
  676:         df["a"].plot(ax=plots[0][1], title="Internal share (twin) only").set_xlabel(
  677:             "this label should always be visible"
  678:         )
  679:         df["a"].plot(ax=plots[1][1])
  680: 
  681:         df["a"].plot(ax=plots[0][2], title="Both").set_xlabel(
  682:             "this label should never be visible"
  683:         )
  684:         df["a"].plot(ax=plots[1][2])
  685: 
  686:         # Plot data to twinned axes
  687:         df["b"].plot(ax=twin_ax1, color="green")
  688:         df["b"].plot(ax=twin_ax2, color="yellow")
  689: 
  690:         assert not plots[0][0].xaxis.get_label().get_visible()
  691:         assert plots[0][1].xaxis.get_label().get_visible()
  692:         assert not plots[0][2].xaxis.get_label().get_visible()
  693: 
  694:     def test_plot_bar_axis_units_timestamp_conversion(self):
  695:         # GH 38736
  696:         # Ensure string x-axis from the second plot will not be converted to datetime
  697:         # due to axis data from first plot
  698:         df = DataFrame(
  699:             [1.0],
  700:             index=[Timestamp("2022-02-22 22:22:22")],
  701:         )
  702:         _check_plot_works(df.plot)
  703:         s = Series({"A": 1.0})
  704:         _check_plot_works(s.plot.bar)
  705: 
  706:     def test_bar_plt_xaxis_intervalrange(self):
  707:         # GH 38969
  708:         # Ensure IntervalIndex x-axis produces a bar plot as expected
  709:         from matplotlib.text import Text
  710: 
  711:         expected = [Text(0, 0, "([0, 1],)"), Text(1, 0, "([1, 2],)")]
  712:         s = Series(
  713:             [1, 2],
  714:             index=[interval_range(0, 2, closed="both")],
  715:         )
  716:         _check_plot_works(s.plot.bar)
  717:         assert all(
  718:             (a.get_text() == b.get_text())
  719:             for a, b in zip(s.plot.bar().get_xticklabels(), expected)
  720:         )
