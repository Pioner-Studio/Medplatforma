    1: """ Test cases for .boxplot method """
    2: 
    3: import itertools
    4: import string
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     MultiIndex,
   12:     Series,
   13:     date_range,
   14:     plotting,
   15:     timedelta_range,
   16: )
   17: import pandas._testing as tm
   18: from pandas.tests.plotting.common import (
   19:     _check_axes_shape,
   20:     _check_box_return_type,
   21:     _check_plot_works,
   22:     _check_ticks_props,
   23:     _check_visible,
   24: )
   25: 
   26: from pandas.io.formats.printing import pprint_thing
   27: 
   28: mpl = pytest.importorskip("matplotlib")
   29: plt = pytest.importorskip("matplotlib.pyplot")
   30: 
   31: 
   32: def _check_ax_limits(col, ax):
   33:     y_min, y_max = ax.get_ylim()
   34:     assert y_min <= col.min()
   35:     assert y_max >= col.max()
   36: 
   37: 
   38: class TestDataFramePlots:
   39:     def test_stacked_boxplot_set_axis(self):
   40:         # GH2980
   41:         import matplotlib.pyplot as plt
   42: 
   43:         n = 80
   44:         df = DataFrame(
   45:             {
   46:                 "Clinical": np.random.default_rng(2).choice([0, 1, 2, 3], n),
   47:                 "Confirmed": np.random.default_rng(2).choice([0, 1, 2, 3], n),
   48:                 "Discarded": np.random.default_rng(2).choice([0, 1, 2, 3], n),
   49:             },
   50:             index=np.arange(0, n),
   51:         )
   52:         ax = df.plot(kind="bar", stacked=True)
   53:         assert [int(x.get_text()) for x in ax.get_xticklabels()] == df.index.to_list()
   54:         ax.set_xticks(np.arange(0, 80, 10))
   55:         plt.draw()  # Update changes
   56:         assert [int(x.get_text()) for x in ax.get_xticklabels()] == list(
   57:             np.arange(0, 80, 10)
   58:         )
   59: 
   60:     @pytest.mark.slow
   61:     @pytest.mark.parametrize(
   62:         "kwargs, warn",
   63:         [
   64:             [{"return_type": "dict"}, None],
   65:             [{"column": ["one", "two"]}, None],
   66:             [{"column": ["one", "two"], "by": "indic"}, UserWarning],
   67:             [{"column": ["one"], "by": ["indic", "indic2"]}, None],
   68:             [{"by": "indic"}, UserWarning],
   69:             [{"by": ["indic", "indic2"]}, UserWarning],
   70:             [{"notch": 1}, None],
   71:             [{"by": "indic", "notch": 1}, UserWarning],
   72:         ],
   73:     )
   74:     def test_boxplot_legacy1(self, kwargs, warn):
   75:         df = DataFrame(
   76:             np.random.default_rng(2).standard_normal((6, 4)),
   77:             index=list(string.ascii_letters[:6]),
   78:             columns=["one", "two", "three", "four"],
   79:         )
   80:         df["indic"] = ["foo", "bar"] * 3
   81:         df["indic2"] = ["foo", "bar", "foo"] * 2
   82: 
   83:         # _check_plot_works can add an ax so catch warning. see GH #13188
   84:         with tm.assert_produces_warning(warn, check_stacklevel=False):
   85:             _check_plot_works(df.boxplot, **kwargs)
   86: 
   87:     def test_boxplot_legacy1_series(self):
   88:         ser = Series(np.random.default_rng(2).standard_normal(6))
   89:         _check_plot_works(plotting._core.boxplot, data=ser, return_type="dict")
   90: 
   91:     def test_boxplot_legacy2(self):
   92:         df = DataFrame(
   93:             np.random.default_rng(2).random((10, 2)), columns=["Col1", "Col2"]
   94:         )
   95:         df["X"] = Series(["A", "A", "A", "A", "A", "B", "B", "B", "B", "B"])
   96:         df["Y"] = Series(["A"] * 10)
   97:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
   98:             _check_plot_works(df.boxplot, by="X")
   99: 
  100:     def test_boxplot_legacy2_with_ax(self):
  101:         df = DataFrame(
  102:             np.random.default_rng(2).random((10, 2)), columns=["Col1", "Col2"]
  103:         )
  104:         df["X"] = Series(["A", "A", "A", "A", "A", "B", "B", "B", "B", "B"])
  105:         df["Y"] = Series(["A"] * 10)
  106:         # When ax is supplied and required number of axes is 1,
  107:         # passed ax should be used:
  108:         _, ax = mpl.pyplot.subplots()
  109:         axes = df.boxplot("Col1", by="X", ax=ax)
  110:         ax_axes = ax.axes
  111:         assert ax_axes is axes
  112: 
  113:     def test_boxplot_legacy2_with_ax_return_type(self):
  114:         df = DataFrame(
  115:             np.random.default_rng(2).random((10, 2)), columns=["Col1", "Col2"]
  116:         )
  117:         df["X"] = Series(["A", "A", "A", "A", "A", "B", "B", "B", "B", "B"])
  118:         df["Y"] = Series(["A"] * 10)
  119:         fig, ax = mpl.pyplot.subplots()
  120:         axes = df.groupby("Y").boxplot(ax=ax, return_type="axes")
  121:         ax_axes = ax.axes
  122:         assert ax_axes is axes["A"]
  123: 
  124:     def test_boxplot_legacy2_with_multi_col(self):
  125:         df = DataFrame(
  126:             np.random.default_rng(2).random((10, 2)), columns=["Col1", "Col2"]
  127:         )
  128:         df["X"] = Series(["A", "A", "A", "A", "A", "B", "B", "B", "B", "B"])
  129:         df["Y"] = Series(["A"] * 10)
  130:         # Multiple columns with an ax argument should use same figure
  131:         fig, ax = mpl.pyplot.subplots()
  132:         with tm.assert_produces_warning(UserWarning):
  133:             axes = df.boxplot(
  134:                 column=["Col1", "Col2"], by="X", ax=ax, return_type="axes"
  135:             )
  136:         assert axes["Col1"].get_figure() is fig
  137: 
  138:     def test_boxplot_legacy2_by_none(self):
  139:         df = DataFrame(
  140:             np.random.default_rng(2).random((10, 2)), columns=["Col1", "Col2"]
  141:         )
  142:         df["X"] = Series(["A", "A", "A", "A", "A", "B", "B", "B", "B", "B"])
  143:         df["Y"] = Series(["A"] * 10)
  144:         # When by is None, check that all relevant lines are present in the
  145:         # dict
  146:         _, ax = mpl.pyplot.subplots()
  147:         d = df.boxplot(ax=ax, return_type="dict")
  148:         lines = list(itertools.chain.from_iterable(d.values()))
  149:         assert len(ax.get_lines()) == len(lines)
  150: 
  151:     def test_boxplot_return_type_none(self, hist_df):
  152:         # GH 12216; return_type=None & by=None -> axes
  153:         result = hist_df.boxplot()
  154:         assert isinstance(result, mpl.pyplot.Axes)
  155: 
  156:     def test_boxplot_return_type_legacy(self):
  157:         # API change in https://github.com/pandas-dev/pandas/pull/7096
  158: 
  159:         df = DataFrame(
  160:             np.random.default_rng(2).standard_normal((6, 4)),
  161:             index=list(string.ascii_letters[:6]),
  162:             columns=["one", "two", "three", "four"],
  163:         )
  164:         msg = "return_type must be {'axes', 'dict', 'both'}"
  165:         with pytest.raises(ValueError, match=msg):
  166:             df.boxplot(return_type="NOT_A_TYPE")
  167: 
  168:         result = df.boxplot()
  169:         _check_box_return_type(result, "axes")
  170: 
  171:     @pytest.mark.parametrize("return_type", ["dict", "axes", "both"])
  172:     def test_boxplot_return_type_legacy_return_type(self, return_type):
  173:         # API change in https://github.com/pandas-dev/pandas/pull/7096
  174: 
  175:         df = DataFrame(
  176:             np.random.default_rng(2).standard_normal((6, 4)),
  177:             index=list(string.ascii_letters[:6]),
  178:             columns=["one", "two", "three", "four"],
  179:         )
  180:         with tm.assert_produces_warning(False):
  181:             result = df.boxplot(return_type=return_type)
  182:         _check_box_return_type(result, return_type)
  183: 
  184:     def test_boxplot_axis_limits(self, hist_df):
  185:         df = hist_df.copy()
  186:         df["age"] = np.random.default_rng(2).integers(1, 20, df.shape[0])
  187:         # One full row
  188:         height_ax, weight_ax = df.boxplot(["height", "weight"], by="category")
  189:         _check_ax_limits(df["height"], height_ax)
  190:         _check_ax_limits(df["weight"], weight_ax)
  191:         assert weight_ax._sharey == height_ax
  192: 
  193:     def test_boxplot_axis_limits_two_rows(self, hist_df):
  194:         df = hist_df.copy()
  195:         df["age"] = np.random.default_rng(2).integers(1, 20, df.shape[0])
  196:         # Two rows, one partial
  197:         p = df.boxplot(["height", "weight", "age"], by="category")
  198:         height_ax, weight_ax, age_ax = p[0, 0], p[0, 1], p[1, 0]
  199:         dummy_ax = p[1, 1]
  200: 
  201:         _check_ax_limits(df["height"], height_ax)
  202:         _check_ax_limits(df["weight"], weight_ax)
  203:         _check_ax_limits(df["age"], age_ax)
  204:         assert weight_ax._sharey == height_ax
  205:         assert age_ax._sharey == height_ax
  206:         assert dummy_ax._sharey is None
  207: 
  208:     def test_boxplot_empty_column(self):
  209:         df = DataFrame(np.random.default_rng(2).standard_normal((20, 4)))
  210:         df.loc[:, 0] = np.nan
  211:         _check_plot_works(df.boxplot, return_type="axes")
  212: 
  213:     def test_figsize(self):
  214:         df = DataFrame(
  215:             np.random.default_rng(2).random((10, 5)), columns=["A", "B", "C", "D", "E"]
  216:         )
  217:         result = df.boxplot(return_type="axes", figsize=(12, 8))
  218:         assert result.figure.bbox_inches.width == 12
  219:         assert result.figure.bbox_inches.height == 8
  220: 
  221:     def test_fontsize(self):
  222:         df = DataFrame({"a": [1, 2, 3, 4, 5, 6]})
  223:         _check_ticks_props(df.boxplot("a", fontsize=16), xlabelsize=16, ylabelsize=16)
  224: 
  225:     def test_boxplot_numeric_data(self):
  226:         # GH 22799
  227:         df = DataFrame(
  228:             {
  229:                 "a": date_range("2012-01-01", periods=100),
  230:                 "b": np.random.default_rng(2).standard_normal(100),
  231:                 "c": np.random.default_rng(2).standard_normal(100) + 2,
  232:                 "d": date_range("2012-01-01", periods=100).astype(str),
  233:                 "e": date_range("2012-01-01", periods=100, tz="UTC"),
  234:                 "f": timedelta_range("1 days", periods=100),
  235:             }
  236:         )
  237:         ax = df.plot(kind="box")
  238:         assert [x.get_text() for x in ax.get_xticklabels()] == ["b", "c"]
  239: 
  240:     @pytest.mark.parametrize(
  241:         "colors_kwd, expected",
  242:         [
  243:             (
  244:                 {"boxes": "r", "whiskers": "b", "medians": "g", "caps": "c"},
  245:                 {"boxes": "r", "whiskers": "b", "medians": "g", "caps": "c"},
  246:             ),
  247:             ({"boxes": "r"}, {"boxes": "r"}),
  248:             ("r", {"boxes": "r", "whiskers": "r", "medians": "r", "caps": "r"}),
  249:         ],
  250:     )
  251:     def test_color_kwd(self, colors_kwd, expected):
  252:         # GH: 26214
  253:         df = DataFrame(np.random.default_rng(2).random((10, 2)))
  254:         result = df.boxplot(color=colors_kwd, return_type="dict")
  255:         for k, v in expected.items():
  256:             assert result[k][0].get_color() == v
  257: 
  258:     @pytest.mark.parametrize(
  259:         "scheme,expected",
  260:         [
  261:             (
  262:                 "dark_background",
  263:                 {
  264:                     "boxes": "#8dd3c7",
  265:                     "whiskers": "#8dd3c7",
  266:                     "medians": "#bfbbd9",
  267:                     "caps": "#8dd3c7",
  268:                 },
  269:             ),
  270:             (
  271:                 "default",
  272:                 {
  273:                     "boxes": "#1f77b4",
  274:                     "whiskers": "#1f77b4",
  275:                     "medians": "#2ca02c",
  276:                     "caps": "#1f77b4",
  277:                 },
  278:             ),
  279:         ],
  280:     )
  281:     def test_colors_in_theme(self, scheme, expected):
  282:         # GH: 40769
  283:         df = DataFrame(np.random.default_rng(2).random((10, 2)))
  284:         import matplotlib.pyplot as plt
  285: 
  286:         plt.style.use(scheme)
  287:         result = df.plot.box(return_type="dict")
  288:         for k, v in expected.items():
  289:             assert result[k][0].get_color() == v
  290: 
  291:     @pytest.mark.parametrize(
  292:         "dict_colors, msg",
  293:         [({"boxes": "r", "invalid_key": "r"}, "invalid key 'invalid_key'")],
  294:     )
  295:     def test_color_kwd_errors(self, dict_colors, msg):
  296:         # GH: 26214
  297:         df = DataFrame(np.random.default_rng(2).random((10, 2)))
  298:         with pytest.raises(ValueError, match=msg):
  299:             df.boxplot(color=dict_colors, return_type="dict")
  300: 
  301:     @pytest.mark.parametrize(
  302:         "props, expected",
  303:         [
  304:             ("boxprops", "boxes"),
  305:             ("whiskerprops", "whiskers"),
  306:             ("capprops", "caps"),
  307:             ("medianprops", "medians"),
  308:         ],
  309:     )
  310:     def test_specified_props_kwd(self, props, expected):
  311:         # GH 30346
  312:         df = DataFrame({k: np.random.default_rng(2).random(10) for k in "ABC"})
  313:         kwd = {props: {"color": "C1"}}
  314:         result = df.boxplot(return_type="dict", **kwd)
  315: 
  316:         assert result[expected][0].get_color() == "C1"
  317: 
  318:     @pytest.mark.parametrize("vert", [True, False])
  319:     def test_plot_xlabel_ylabel(self, vert):
  320:         df = DataFrame(
  321:             {
  322:                 "a": np.random.default_rng(2).standard_normal(10),
  323:                 "b": np.random.default_rng(2).standard_normal(10),
  324:                 "group": np.random.default_rng(2).choice(["group1", "group2"], 10),
  325:             }
  326:         )
  327:         xlabel, ylabel = "x", "y"
  328:         ax = df.plot(kind="box", vert=vert, xlabel=xlabel, ylabel=ylabel)
  329:         assert ax.get_xlabel() == xlabel
  330:         assert ax.get_ylabel() == ylabel
  331: 
  332:     @pytest.mark.parametrize("vert", [True, False])
  333:     def test_plot_box(self, vert):
  334:         # GH 54941
  335:         rng = np.random.default_rng(2)
  336:         df1 = DataFrame(rng.integers(0, 100, size=(100, 4)), columns=list("ABCD"))
  337:         df2 = DataFrame(rng.integers(0, 100, size=(100, 4)), columns=list("ABCD"))
  338: 
  339:         xlabel, ylabel = "x", "y"
  340:         _, axs = plt.subplots(ncols=2, figsize=(10, 7), sharey=True)
  341:         df1.plot.box(ax=axs[0], vert=vert, xlabel=xlabel, ylabel=ylabel)
  342:         df2.plot.box(ax=axs[1], vert=vert, xlabel=xlabel, ylabel=ylabel)
  343:         for ax in axs:
  344:             assert ax.get_xlabel() == xlabel
  345:             assert ax.get_ylabel() == ylabel
  346:         mpl.pyplot.close()
  347: 
  348:     @pytest.mark.parametrize("vert", [True, False])
  349:     def test_boxplot_xlabel_ylabel(self, vert):
  350:         df = DataFrame(
  351:             {
  352:                 "a": np.random.default_rng(2).standard_normal(10),
  353:                 "b": np.random.default_rng(2).standard_normal(10),
  354:                 "group": np.random.default_rng(2).choice(["group1", "group2"], 10),
  355:             }
  356:         )
  357:         xlabel, ylabel = "x", "y"
  358:         ax = df.boxplot(vert=vert, xlabel=xlabel, ylabel=ylabel)
  359:         assert ax.get_xlabel() == xlabel
  360:         assert ax.get_ylabel() == ylabel
  361: 
  362:     @pytest.mark.parametrize("vert", [True, False])
  363:     def test_boxplot_group_xlabel_ylabel(self, vert):
  364:         df = DataFrame(
  365:             {
  366:                 "a": np.random.default_rng(2).standard_normal(10),
  367:                 "b": np.random.default_rng(2).standard_normal(10),
  368:                 "group": np.random.default_rng(2).choice(["group1", "group2"], 10),
  369:             }
  370:         )
  371:         xlabel, ylabel = "x", "y"
  372:         ax = df.boxplot(by="group", vert=vert, xlabel=xlabel, ylabel=ylabel)
  373:         for subplot in ax:
  374:             assert subplot.get_xlabel() == xlabel
  375:             assert subplot.get_ylabel() == ylabel
  376:         mpl.pyplot.close()
  377: 
  378:     @pytest.mark.parametrize("vert", [True, False])
  379:     def test_boxplot_group_no_xlabel_ylabel(self, vert):
  380:         df = DataFrame(
  381:             {
  382:                 "a": np.random.default_rng(2).standard_normal(10),
  383:                 "b": np.random.default_rng(2).standard_normal(10),
  384:                 "group": np.random.default_rng(2).choice(["group1", "group2"], 10),
  385:             }
  386:         )
  387:         ax = df.boxplot(by="group", vert=vert)
  388:         for subplot in ax:
  389:             target_label = subplot.get_xlabel() if vert else subplot.get_ylabel()
  390:             assert target_label == pprint_thing(["group"])
  391:         mpl.pyplot.close()
  392: 
  393: 
  394: class TestDataFrameGroupByPlots:
  395:     def test_boxplot_legacy1(self, hist_df):
  396:         grouped = hist_df.groupby(by="gender")
  397:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  398:             axes = _check_plot_works(grouped.boxplot, return_type="axes")
  399:         _check_axes_shape(list(axes.values), axes_num=2, layout=(1, 2))
  400: 
  401:     def test_boxplot_legacy1_return_type(self, hist_df):
  402:         grouped = hist_df.groupby(by="gender")
  403:         axes = _check_plot_works(grouped.boxplot, subplots=False, return_type="axes")
  404:         _check_axes_shape(axes, axes_num=1, layout=(1, 1))
  405: 
  406:     @pytest.mark.slow
  407:     def test_boxplot_legacy2(self):
  408:         tuples = zip(string.ascii_letters[:10], range(10))
  409:         df = DataFrame(
  410:             np.random.default_rng(2).random((10, 3)),
  411:             index=MultiIndex.from_tuples(tuples),
  412:         )
  413:         grouped = df.groupby(level=1)
  414:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  415:             axes = _check_plot_works(grouped.boxplot, return_type="axes")
  416:         _check_axes_shape(list(axes.values), axes_num=10, layout=(4, 3))
  417: 
  418:     @pytest.mark.slow
  419:     def test_boxplot_legacy2_return_type(self):
  420:         tuples = zip(string.ascii_letters[:10], range(10))
  421:         df = DataFrame(
  422:             np.random.default_rng(2).random((10, 3)),
  423:             index=MultiIndex.from_tuples(tuples),
  424:         )
  425:         grouped = df.groupby(level=1)
  426:         axes = _check_plot_works(grouped.boxplot, subplots=False, return_type="axes")
  427:         _check_axes_shape(axes, axes_num=1, layout=(1, 1))
  428: 
  429:     @pytest.mark.parametrize(
  430:         "subplots, warn, axes_num, layout",
  431:         [[True, UserWarning, 3, (2, 2)], [False, None, 1, (1, 1)]],
  432:     )
  433:     def test_boxplot_legacy3(self, subplots, warn, axes_num, layout):
  434:         tuples = zip(string.ascii_letters[:10], range(10))
  435:         df = DataFrame(
  436:             np.random.default_rng(2).random((10, 3)),
  437:             index=MultiIndex.from_tuples(tuples),
  438:         )
  439:         msg = "DataFrame.groupby with axis=1 is deprecated"
  440:         with tm.assert_produces_warning(FutureWarning, match=msg):
  441:             grouped = df.unstack(level=1).groupby(level=0, axis=1)
  442:         with tm.assert_produces_warning(warn, check_stacklevel=False):
  443:             axes = _check_plot_works(
  444:                 grouped.boxplot, subplots=subplots, return_type="axes"
  445:             )
  446:         _check_axes_shape(axes, axes_num=axes_num, layout=layout)
  447: 
  448:     def test_grouped_plot_fignums(self):
  449:         n = 10
  450:         weight = Series(np.random.default_rng(2).normal(166, 20, size=n))
  451:         height = Series(np.random.default_rng(2).normal(60, 10, size=n))
  452:         gender = np.random.default_rng(2).choice(["male", "female"], size=n)
  453:         df = DataFrame({"height": height, "weight": weight, "gender": gender})
  454:         gb = df.groupby("gender")
  455: 
  456:         res = gb.plot()
  457:         assert len(mpl.pyplot.get_fignums()) == 2
  458:         assert len(res) == 2
  459:         plt.close("all")
  460: 
  461:         res = gb.boxplot(return_type="axes")
  462:         assert len(mpl.pyplot.get_fignums()) == 1
  463:         assert len(res) == 2
  464: 
  465:     def test_grouped_plot_fignums_excluded_col(self):
  466:         n = 10
  467:         weight = Series(np.random.default_rng(2).normal(166, 20, size=n))
  468:         height = Series(np.random.default_rng(2).normal(60, 10, size=n))
  469:         gender = np.random.default_rng(2).choice(["male", "female"], size=n)
  470:         df = DataFrame({"height": height, "weight": weight, "gender": gender})
  471:         # now works with GH 5610 as gender is excluded
  472:         df.groupby("gender").hist()
  473: 
  474:     @pytest.mark.slow
  475:     def test_grouped_box_return_type(self, hist_df):
  476:         df = hist_df
  477: 
  478:         # old style: return_type=None
  479:         result = df.boxplot(by="gender")
  480:         assert isinstance(result, np.ndarray)
  481:         _check_box_return_type(
  482:             result, None, expected_keys=["height", "weight", "category"]
  483:         )
  484: 
  485:     @pytest.mark.slow
  486:     def test_grouped_box_return_type_groupby(self, hist_df):
  487:         df = hist_df
  488:         # now for groupby
  489:         result = df.groupby("gender").boxplot(return_type="dict")
  490:         _check_box_return_type(result, "dict", expected_keys=["Male", "Female"])
  491: 
  492:     @pytest.mark.slow
  493:     @pytest.mark.parametrize("return_type", ["dict", "axes", "both"])
  494:     def test_grouped_box_return_type_arg(self, hist_df, return_type):
  495:         df = hist_df
  496: 
  497:         returned = df.groupby("classroom").boxplot(return_type=return_type)
  498:         _check_box_return_type(returned, return_type, expected_keys=["A", "B", "C"])
  499: 
  500:         returned = df.boxplot(by="classroom", return_type=return_type)
  501:         _check_box_return_type(
  502:             returned, return_type, expected_keys=["height", "weight", "category"]
  503:         )
  504: 
  505:     @pytest.mark.slow
  506:     @pytest.mark.parametrize("return_type", ["dict", "axes", "both"])
  507:     def test_grouped_box_return_type_arg_duplcate_cats(self, return_type):
  508:         columns2 = "X B C D A".split()
  509:         df2 = DataFrame(
  510:             np.random.default_rng(2).standard_normal((6, 5)), columns=columns2
  511:         )
  512:         categories2 = "A B".split()
  513:         df2["category"] = categories2 * 3
  514: 
  515:         returned = df2.groupby("category").boxplot(return_type=return_type)
  516:         _check_box_return_type(returned, return_type, expected_keys=categories2)
  517: 
  518:         returned = df2.boxplot(by="category", return_type=return_type)
  519:         _check_box_return_type(returned, return_type, expected_keys=columns2)
  520: 
  521:     @pytest.mark.slow
  522:     def test_grouped_box_layout_too_small(self, hist_df):
  523:         df = hist_df
  524: 
  525:         msg = "Layout of 1x1 must be larger than required size 2"
  526:         with pytest.raises(ValueError, match=msg):
  527:             df.boxplot(column=["weight", "height"], by=df.gender, layout=(1, 1))
  528: 
  529:     @pytest.mark.slow
  530:     def test_grouped_box_layout_needs_by(self, hist_df):
  531:         df = hist_df
  532:         msg = "The 'layout' keyword is not supported when 'by' is None"
  533:         with pytest.raises(ValueError, match=msg):
  534:             df.boxplot(
  535:                 column=["height", "weight", "category"],
  536:                 layout=(2, 1),
  537:                 return_type="dict",
  538:             )
  539: 
  540:     @pytest.mark.slow
  541:     def test_grouped_box_layout_positive_layout(self, hist_df):
  542:         df = hist_df
  543:         msg = "At least one dimension of layout must be positive"
  544:         with pytest.raises(ValueError, match=msg):
  545:             df.boxplot(column=["weight", "height"], by=df.gender, layout=(-1, -1))
  546: 
  547:     @pytest.mark.slow
  548:     @pytest.mark.parametrize(
  549:         "gb_key, axes_num, rows",
  550:         [["gender", 2, 1], ["category", 4, 2], ["classroom", 3, 2]],
  551:     )
  552:     def test_grouped_box_layout_positive_layout_axes(
  553:         self, hist_df, gb_key, axes_num, rows
  554:     ):
  555:         df = hist_df
  556:         # _check_plot_works adds an ax so catch warning. see GH #13188 GH 6769
  557:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  558:             _check_plot_works(
  559:                 df.groupby(gb_key).boxplot, column="height", return_type="dict"
  560:             )
  561:         _check_axes_shape(mpl.pyplot.gcf().axes, axes_num=axes_num, layout=(rows, 2))
  562: 
  563:     @pytest.mark.slow
  564:     @pytest.mark.parametrize(
  565:         "col, visible", [["height", False], ["weight", True], ["category", True]]
  566:     )
  567:     def test_grouped_box_layout_visible(self, hist_df, col, visible):
  568:         df = hist_df
  569:         # GH 5897
  570:         axes = df.boxplot(
  571:             column=["height", "weight", "category"], by="gender", return_type="axes"
  572:         )
  573:         _check_axes_shape(mpl.pyplot.gcf().axes, axes_num=3, layout=(2, 2))
  574:         ax = axes[col]
  575:         _check_visible(ax.get_xticklabels(), visible=visible)
  576:         _check_visible([ax.xaxis.get_label()], visible=visible)
  577: 
  578:     @pytest.mark.slow
  579:     def test_grouped_box_layout_shape(self, hist_df):
  580:         df = hist_df
  581:         df.groupby("classroom").boxplot(
  582:             column=["height", "weight", "category"], return_type="dict"
  583:         )
  584:         _check_axes_shape(mpl.pyplot.gcf().axes, axes_num=3, layout=(2, 2))
  585: 
  586:     @pytest.mark.slow
  587:     @pytest.mark.parametrize("cols", [2, -1])
  588:     def test_grouped_box_layout_works(self, hist_df, cols):
  589:         df = hist_df
  590:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  591:             _check_plot_works(
  592:                 df.groupby("category").boxplot,
  593:                 column="height",
  594:                 layout=(3, cols),
  595:                 return_type="dict",
  596:             )
  597:         _check_axes_shape(mpl.pyplot.gcf().axes, axes_num=4, layout=(3, 2))
  598: 
  599:     @pytest.mark.slow
  600:     @pytest.mark.parametrize("rows, res", [[4, 4], [-1, 3]])
  601:     def test_grouped_box_layout_axes_shape_rows(self, hist_df, rows, res):
  602:         df = hist_df
  603:         df.boxplot(
  604:             column=["height", "weight", "category"], by="gender", layout=(rows, 1)
  605:         )
  606:         _check_axes_shape(mpl.pyplot.gcf().axes, axes_num=3, layout=(res, 1))
  607: 
  608:     @pytest.mark.slow
  609:     @pytest.mark.parametrize("cols, res", [[4, 4], [-1, 3]])
  610:     def test_grouped_box_layout_axes_shape_cols_groupby(self, hist_df, cols, res):
  611:         df = hist_df
  612:         df.groupby("classroom").boxplot(
  613:             column=["height", "weight", "category"],
  614:             layout=(1, cols),
  615:             return_type="dict",
  616:         )
  617:         _check_axes_shape(mpl.pyplot.gcf().axes, axes_num=3, layout=(1, res))
  618: 
  619:     @pytest.mark.slow
  620:     def test_grouped_box_multiple_axes(self, hist_df):
  621:         # GH 6970, GH 7069
  622:         df = hist_df
  623: 
  624:         # check warning to ignore sharex / sharey
  625:         # this check should be done in the first function which
  626:         # passes multiple axes to plot, hist or boxplot
  627:         # location should be changed if other test is added
  628:         # which has earlier alphabetical order
  629:         with tm.assert_produces_warning(UserWarning):
  630:             _, axes = mpl.pyplot.subplots(2, 2)
  631:             df.groupby("category").boxplot(column="height", return_type="axes", ax=axes)
  632:             _check_axes_shape(mpl.pyplot.gcf().axes, axes_num=4, layout=(2, 2))
  633: 
  634:     @pytest.mark.slow
  635:     def test_grouped_box_multiple_axes_on_fig(self, hist_df):
  636:         # GH 6970, GH 7069
  637:         df = hist_df
  638:         fig, axes = mpl.pyplot.subplots(2, 3)
  639:         with tm.assert_produces_warning(UserWarning):
  640:             returned = df.boxplot(
  641:                 column=["height", "weight", "category"],
  642:                 by="gender",
  643:                 return_type="axes",
  644:                 ax=axes[0],
  645:             )
  646:         returned = np.array(list(returned.values))
  647:         _check_axes_shape(returned, axes_num=3, layout=(1, 3))
  648:         tm.assert_numpy_array_equal(returned, axes[0])
  649:         assert returned[0].figure is fig
  650: 
  651:         # draw on second row
  652:         with tm.assert_produces_warning(UserWarning):
  653:             returned = df.groupby("classroom").boxplot(
  654:                 column=["height", "weight", "category"], return_type="axes", ax=axes[1]
  655:             )
  656:         returned = np.array(list(returned.values))
  657:         _check_axes_shape(returned, axes_num=3, layout=(1, 3))
  658:         tm.assert_numpy_array_equal(returned, axes[1])
  659:         assert returned[0].figure is fig
  660: 
  661:     @pytest.mark.slow
  662:     def test_grouped_box_multiple_axes_ax_error(self, hist_df):
  663:         # GH 6970, GH 7069
  664:         df = hist_df
  665:         msg = "The number of passed axes must be 3, the same as the output plot"
  666:         with pytest.raises(ValueError, match=msg):
  667:             fig, axes = mpl.pyplot.subplots(2, 3)
  668:             # pass different number of axes from required
  669:             with tm.assert_produces_warning(UserWarning):
  670:                 axes = df.groupby("classroom").boxplot(ax=axes)
  671: 
  672:     def test_fontsize(self):
  673:         df = DataFrame({"a": [1, 2, 3, 4, 5, 6], "b": [0, 0, 0, 1, 1, 1]})
  674:         _check_ticks_props(
  675:             df.boxplot("a", by="b", fontsize=16), xlabelsize=16, ylabelsize=16
  676:         )
  677: 
  678:     @pytest.mark.parametrize(
  679:         "col, expected_xticklabel",
  680:         [
  681:             ("v", ["(a, v)", "(b, v)", "(c, v)", "(d, v)", "(e, v)"]),
  682:             (["v"], ["(a, v)", "(b, v)", "(c, v)", "(d, v)", "(e, v)"]),
  683:             ("v1", ["(a, v1)", "(b, v1)", "(c, v1)", "(d, v1)", "(e, v1)"]),
  684:             (
  685:                 ["v", "v1"],
  686:                 [
  687:                     "(a, v)",
  688:                     "(a, v1)",
  689:                     "(b, v)",
  690:                     "(b, v1)",
  691:                     "(c, v)",
  692:                     "(c, v1)",
  693:                     "(d, v)",
  694:                     "(d, v1)",
  695:                     "(e, v)",
  696:                     "(e, v1)",
  697:                 ],
  698:             ),
  699:             (
  700:                 None,
  701:                 [
  702:                     "(a, v)",
  703:                     "(a, v1)",
  704:                     "(b, v)",
  705:                     "(b, v1)",
  706:                     "(c, v)",
  707:                     "(c, v1)",
  708:                     "(d, v)",
  709:                     "(d, v1)",
  710:                     "(e, v)",
  711:                     "(e, v1)",
  712:                 ],
  713:             ),
  714:         ],
  715:     )
  716:     def test_groupby_boxplot_subplots_false(self, col, expected_xticklabel):
  717:         # GH 16748
  718:         df = DataFrame(
  719:             {
  720:                 "cat": np.random.default_rng(2).choice(list("abcde"), 100),
  721:                 "v": np.random.default_rng(2).random(100),
  722:                 "v1": np.random.default_rng(2).random(100),
  723:             }
  724:         )
  725:         grouped = df.groupby("cat")
  726: 
  727:         axes = _check_plot_works(
  728:             grouped.boxplot, subplots=False, column=col, return_type="axes"
  729:         )
  730: 
  731:         result_xticklabel = [x.get_text() for x in axes.get_xticklabels()]
  732:         assert expected_xticklabel == result_xticklabel
  733: 
  734:     def test_groupby_boxplot_object(self, hist_df):
  735:         # GH 43480
  736:         df = hist_df.astype("object")
  737:         grouped = df.groupby("gender")
  738:         msg = "boxplot method requires numerical columns, nothing to plot"
  739:         with pytest.raises(ValueError, match=msg):
  740:             _check_plot_works(grouped.boxplot, subplots=False)
  741: 
  742:     def test_boxplot_multiindex_column(self):
  743:         # GH 16748
  744:         arrays = [
  745:             ["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"],
  746:             ["one", "two", "one", "two", "one", "two", "one", "two"],
  747:         ]
  748:         tuples = list(zip(*arrays))
  749:         index = MultiIndex.from_tuples(tuples, names=["first", "second"])
  750:         df = DataFrame(
  751:             np.random.default_rng(2).standard_normal((3, 8)),
  752:             index=["A", "B", "C"],
  753:             columns=index,
  754:         )
  755: 
  756:         col = [("bar", "one"), ("bar", "two")]
  757:         axes = _check_plot_works(df.boxplot, column=col, return_type="axes")
  758: 
  759:         expected_xticklabel = ["(bar, one)", "(bar, two)"]
  760:         result_xticklabel = [x.get_text() for x in axes.get_xticklabels()]
  761:         assert expected_xticklabel == result_xticklabel
