    1: """ Test cases for Series.plot """
    2: from datetime import datetime
    3: from itertools import chain
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas.compat import is_platform_linux
    9: from pandas.compat.numpy import np_version_gte1p24
   10: import pandas.util._test_decorators as td
   11: 
   12: import pandas as pd
   13: from pandas import (
   14:     DataFrame,
   15:     Series,
   16:     date_range,
   17:     period_range,
   18:     plotting,
   19: )
   20: import pandas._testing as tm
   21: from pandas.tests.plotting.common import (
   22:     _check_ax_scales,
   23:     _check_axes_shape,
   24:     _check_colors,
   25:     _check_grid_settings,
   26:     _check_has_errorbars,
   27:     _check_legend_labels,
   28:     _check_plot_works,
   29:     _check_text_labels,
   30:     _check_ticks_props,
   31:     _unpack_cycler,
   32:     get_y_axis,
   33: )
   34: 
   35: mpl = pytest.importorskip("matplotlib")
   36: plt = pytest.importorskip("matplotlib.pyplot")
   37: 
   38: 
   39: @pytest.fixture
   40: def ts():
   41:     return Series(
   42:         np.arange(10, dtype=np.float64),
   43:         index=date_range("2020-01-01", periods=10),
   44:         name="ts",
   45:     )
   46: 
   47: 
   48: @pytest.fixture
   49: def series():
   50:     return Series(
   51:         range(20), dtype=np.float64, name="series", index=[f"i_{i}" for i in range(20)]
   52:     )
   53: 
   54: 
   55: class TestSeriesPlots:
   56:     @pytest.mark.slow
   57:     @pytest.mark.parametrize("kwargs", [{"label": "foo"}, {"use_index": False}])
   58:     def test_plot(self, ts, kwargs):
   59:         _check_plot_works(ts.plot, **kwargs)
   60: 
   61:     @pytest.mark.slow
   62:     def test_plot_tick_props(self, ts):
   63:         axes = _check_plot_works(ts.plot, rot=0)
   64:         _check_ticks_props(axes, xrot=0)
   65: 
   66:     @pytest.mark.slow
   67:     @pytest.mark.parametrize(
   68:         "scale, exp_scale",
   69:         [
   70:             [{"logy": True}, {"yaxis": "log"}],
   71:             [{"logx": True}, {"xaxis": "log"}],
   72:             [{"loglog": True}, {"xaxis": "log", "yaxis": "log"}],
   73:         ],
   74:     )
   75:     def test_plot_scales(self, ts, scale, exp_scale):
   76:         ax = _check_plot_works(ts.plot, style=".", **scale)
   77:         _check_ax_scales(ax, **exp_scale)
   78: 
   79:     @pytest.mark.slow
   80:     def test_plot_ts_bar(self, ts):
   81:         _check_plot_works(ts[:10].plot.bar)
   82: 
   83:     @pytest.mark.slow
   84:     def test_plot_ts_area_stacked(self, ts):
   85:         _check_plot_works(ts.plot.area, stacked=False)
   86: 
   87:     def test_plot_iseries(self):
   88:         ser = Series(range(5), period_range("2020-01-01", periods=5))
   89:         _check_plot_works(ser.plot)
   90: 
   91:     @pytest.mark.parametrize(
   92:         "kind",
   93:         [
   94:             "line",
   95:             "bar",
   96:             "barh",
   97:             pytest.param("kde", marks=td.skip_if_no("scipy")),
   98:             "hist",
   99:             "box",
  100:         ],
  101:     )
  102:     def test_plot_series_kinds(self, series, kind):
  103:         _check_plot_works(series[:5].plot, kind=kind)
  104: 
  105:     def test_plot_series_barh(self, series):
  106:         _check_plot_works(series[:10].plot.barh)
  107: 
  108:     def test_plot_series_bar_ax(self):
  109:         ax = _check_plot_works(
  110:             Series(np.random.default_rng(2).standard_normal(10)).plot.bar, color="black"
  111:         )
  112:         _check_colors([ax.patches[0]], facecolors=["black"])
  113: 
  114:     @pytest.mark.parametrize("kwargs", [{}, {"layout": (-1, 1)}, {"layout": (1, -1)}])
  115:     def test_plot_6951(self, ts, kwargs):
  116:         # GH 6951
  117:         ax = _check_plot_works(ts.plot, subplots=True, **kwargs)
  118:         _check_axes_shape(ax, axes_num=1, layout=(1, 1))
  119: 
  120:     def test_plot_figsize_and_title(self, series):
  121:         # figsize and title
  122:         _, ax = mpl.pyplot.subplots()
  123:         ax = series.plot(title="Test", figsize=(16, 8), ax=ax)
  124:         _check_text_labels(ax.title, "Test")
  125:         _check_axes_shape(ax, axes_num=1, layout=(1, 1), figsize=(16, 8))
  126: 
  127:     def test_dont_modify_rcParams(self):
  128:         # GH 8242
  129:         key = "axes.prop_cycle"
  130:         colors = mpl.pyplot.rcParams[key]
  131:         _, ax = mpl.pyplot.subplots()
  132:         Series([1, 2, 3]).plot(ax=ax)
  133:         assert colors == mpl.pyplot.rcParams[key]
  134: 
  135:     @pytest.mark.parametrize("kwargs", [{}, {"secondary_y": True}])
  136:     def test_ts_line_lim(self, ts, kwargs):
  137:         _, ax = mpl.pyplot.subplots()
  138:         ax = ts.plot(ax=ax, **kwargs)
  139:         xmin, xmax = ax.get_xlim()
  140:         lines = ax.get_lines()
  141:         assert xmin <= lines[0].get_data(orig=False)[0][0]
  142:         assert xmax >= lines[0].get_data(orig=False)[0][-1]
  143: 
  144:     def test_ts_area_lim(self, ts):
  145:         _, ax = mpl.pyplot.subplots()
  146:         ax = ts.plot.area(stacked=False, ax=ax)
  147:         xmin, xmax = ax.get_xlim()
  148:         line = ax.get_lines()[0].get_data(orig=False)[0]
  149:         assert xmin <= line[0]
  150:         assert xmax >= line[-1]
  151:         _check_ticks_props(ax, xrot=0)
  152: 
  153:     def test_ts_area_lim_xcompat(self, ts):
  154:         # GH 7471
  155:         _, ax = mpl.pyplot.subplots()
  156:         ax = ts.plot.area(stacked=False, x_compat=True, ax=ax)
  157:         xmin, xmax = ax.get_xlim()
  158:         line = ax.get_lines()[0].get_data(orig=False)[0]
  159:         assert xmin <= line[0]
  160:         assert xmax >= line[-1]
  161:         _check_ticks_props(ax, xrot=30)
  162: 
  163:     def test_ts_tz_area_lim_xcompat(self, ts):
  164:         tz_ts = ts.copy()
  165:         tz_ts.index = tz_ts.tz_localize("GMT").tz_convert("CET")
  166:         _, ax = mpl.pyplot.subplots()
  167:         ax = tz_ts.plot.area(stacked=False, x_compat=True, ax=ax)
  168:         xmin, xmax = ax.get_xlim()
  169:         line = ax.get_lines()[0].get_data(orig=False)[0]
  170:         assert xmin <= line[0]
  171:         assert xmax >= line[-1]
  172:         _check_ticks_props(ax, xrot=0)
  173: 
  174:     def test_ts_tz_area_lim_xcompat_secondary_y(self, ts):
  175:         tz_ts = ts.copy()
  176:         tz_ts.index = tz_ts.tz_localize("GMT").tz_convert("CET")
  177:         _, ax = mpl.pyplot.subplots()
  178:         ax = tz_ts.plot.area(stacked=False, secondary_y=True, ax=ax)
  179:         xmin, xmax = ax.get_xlim()
  180:         line = ax.get_lines()[0].get_data(orig=False)[0]
  181:         assert xmin <= line[0]
  182:         assert xmax >= line[-1]
  183:         _check_ticks_props(ax, xrot=0)
  184: 
  185:     def test_area_sharey_dont_overwrite(self, ts):
  186:         # GH37942
  187:         fig, (ax1, ax2) = mpl.pyplot.subplots(1, 2, sharey=True)
  188: 
  189:         abs(ts).plot(ax=ax1, kind="area")
  190:         abs(ts).plot(ax=ax2, kind="area")
  191: 
  192:         assert get_y_axis(ax1).joined(ax1, ax2)
  193:         assert get_y_axis(ax2).joined(ax1, ax2)
  194:         plt.close(fig)
  195: 
  196:     def test_label(self):
  197:         s = Series([1, 2])
  198:         _, ax = mpl.pyplot.subplots()
  199:         ax = s.plot(label="LABEL", legend=True, ax=ax)
  200:         _check_legend_labels(ax, labels=["LABEL"])
  201:         mpl.pyplot.close("all")
  202: 
  203:     def test_label_none(self):
  204:         s = Series([1, 2])
  205:         _, ax = mpl.pyplot.subplots()
  206:         ax = s.plot(legend=True, ax=ax)
  207:         _check_legend_labels(ax, labels=[""])
  208:         mpl.pyplot.close("all")
  209: 
  210:     def test_label_ser_name(self):
  211:         s = Series([1, 2], name="NAME")
  212:         _, ax = mpl.pyplot.subplots()
  213:         ax = s.plot(legend=True, ax=ax)
  214:         _check_legend_labels(ax, labels=["NAME"])
  215:         mpl.pyplot.close("all")
  216: 
  217:     def test_label_ser_name_override(self):
  218:         s = Series([1, 2], name="NAME")
  219:         # override the default
  220:         _, ax = mpl.pyplot.subplots()
  221:         ax = s.plot(legend=True, label="LABEL", ax=ax)
  222:         _check_legend_labels(ax, labels=["LABEL"])
  223:         mpl.pyplot.close("all")
  224: 
  225:     def test_label_ser_name_override_dont_draw(self):
  226:         s = Series([1, 2], name="NAME")
  227:         # Add lebel info, but don't draw
  228:         _, ax = mpl.pyplot.subplots()
  229:         ax = s.plot(legend=False, label="LABEL", ax=ax)
  230:         assert ax.get_legend() is None  # Hasn't been drawn
  231:         ax.legend()  # draw it
  232:         _check_legend_labels(ax, labels=["LABEL"])
  233:         mpl.pyplot.close("all")
  234: 
  235:     def test_boolean(self):
  236:         # GH 23719
  237:         s = Series([False, False, True])
  238:         _check_plot_works(s.plot, include_bool=True)
  239: 
  240:         msg = "no numeric data to plot"
  241:         with pytest.raises(TypeError, match=msg):
  242:             _check_plot_works(s.plot)
  243: 
  244:     @pytest.mark.parametrize("index", [None, date_range("2020-01-01", periods=4)])
  245:     def test_line_area_nan_series(self, index):
  246:         values = [1, 2, np.nan, 3]
  247:         d = Series(values, index=index)
  248:         ax = _check_plot_works(d.plot)
  249:         masked = ax.lines[0].get_ydata()
  250:         # remove nan for comparison purpose
  251:         exp = np.array([1, 2, 3], dtype=np.float64)
  252:         tm.assert_numpy_array_equal(np.delete(masked.data, 2), exp)
  253:         tm.assert_numpy_array_equal(masked.mask, np.array([False, False, True, False]))
  254: 
  255:         expected = np.array([1, 2, 0, 3], dtype=np.float64)
  256:         ax = _check_plot_works(d.plot, stacked=True)
  257:         tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)
  258:         ax = _check_plot_works(d.plot.area)
  259:         tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)
  260:         ax = _check_plot_works(d.plot.area, stacked=False)
  261:         tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)
  262: 
  263:     def test_line_use_index_false(self):
  264:         s = Series([1, 2, 3], index=["a", "b", "c"])
  265:         s.index.name = "The Index"
  266:         _, ax = mpl.pyplot.subplots()
  267:         ax = s.plot(use_index=False, ax=ax)
  268:         label = ax.get_xlabel()
  269:         assert label == ""
  270: 
  271:     def test_line_use_index_false_diff_var(self):
  272:         s = Series([1, 2, 3], index=["a", "b", "c"])
  273:         s.index.name = "The Index"
  274:         _, ax = mpl.pyplot.subplots()
  275:         ax2 = s.plot.bar(use_index=False, ax=ax)
  276:         label2 = ax2.get_xlabel()
  277:         assert label2 == ""
  278: 
  279:     @pytest.mark.xfail(
  280:         np_version_gte1p24 and is_platform_linux(),
  281:         reason="Weird rounding problems",
  282:         strict=False,
  283:     )
  284:     @pytest.mark.parametrize("axis, meth", [("yaxis", "bar"), ("xaxis", "barh")])
  285:     def test_bar_log(self, axis, meth):
  286:         expected = np.array([1e-1, 1e0, 1e1, 1e2, 1e3, 1e4])
  287: 
  288:         _, ax = mpl.pyplot.subplots()
  289:         ax = getattr(Series([200, 500]).plot, meth)(log=True, ax=ax)
  290:         tm.assert_numpy_array_equal(getattr(ax, axis).get_ticklocs(), expected)
  291: 
  292:     @pytest.mark.xfail(
  293:         np_version_gte1p24 and is_platform_linux(),
  294:         reason="Weird rounding problems",
  295:         strict=False,
  296:     )
  297:     @pytest.mark.parametrize(
  298:         "axis, kind, res_meth",
  299:         [["yaxis", "bar", "get_ylim"], ["xaxis", "barh", "get_xlim"]],
  300:     )
  301:     def test_bar_log_kind_bar(self, axis, kind, res_meth):
  302:         # GH 9905
  303:         expected = np.array([1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0, 1e1])
  304: 
  305:         _, ax = mpl.pyplot.subplots()
  306:         ax = Series([0.1, 0.01, 0.001]).plot(log=True, kind=kind, ax=ax)
  307:         ymin = 0.0007943282347242822
  308:         ymax = 0.12589254117941673
  309:         res = getattr(ax, res_meth)()
  310:         tm.assert_almost_equal(res[0], ymin)
  311:         tm.assert_almost_equal(res[1], ymax)
  312:         tm.assert_numpy_array_equal(getattr(ax, axis).get_ticklocs(), expected)
  313: 
  314:     def test_bar_ignore_index(self):
  315:         df = Series([1, 2, 3, 4], index=["a", "b", "c", "d"])
  316:         _, ax = mpl.pyplot.subplots()
  317:         ax = df.plot.bar(use_index=False, ax=ax)
  318:         _check_text_labels(ax.get_xticklabels(), ["0", "1", "2", "3"])
  319: 
  320:     def test_bar_user_colors(self):
  321:         s = Series([1, 2, 3, 4])
  322:         ax = s.plot.bar(color=["red", "blue", "blue", "red"])
  323:         result = [p.get_facecolor() for p in ax.patches]
  324:         expected = [
  325:             (1.0, 0.0, 0.0, 1.0),
  326:             (0.0, 0.0, 1.0, 1.0),
  327:             (0.0, 0.0, 1.0, 1.0),
  328:             (1.0, 0.0, 0.0, 1.0),
  329:         ]
  330:         assert result == expected
  331: 
  332:     def test_rotation_default(self):
  333:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)))
  334:         # Default rot 0
  335:         _, ax = mpl.pyplot.subplots()
  336:         axes = df.plot(ax=ax)
  337:         _check_ticks_props(axes, xrot=0)
  338: 
  339:     def test_rotation_30(self):
  340:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)))
  341:         _, ax = mpl.pyplot.subplots()
  342:         axes = df.plot(rot=30, ax=ax)
  343:         _check_ticks_props(axes, xrot=30)
  344: 
  345:     def test_irregular_datetime(self):
  346:         from pandas.plotting._matplotlib.converter import DatetimeConverter
  347: 
  348:         rng = date_range("1/1/2000", "3/1/2000")
  349:         rng = rng[[0, 1, 2, 3, 5, 9, 10, 11, 12]]
  350:         ser = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  351:         _, ax = mpl.pyplot.subplots()
  352:         ax = ser.plot(ax=ax)
  353:         xp = DatetimeConverter.convert(datetime(1999, 1, 1), "", ax)
  354:         ax.set_xlim("1/1/1999", "1/1/2001")
  355:         assert xp == ax.get_xlim()[0]
  356:         _check_ticks_props(ax, xrot=30)
  357: 
  358:     def test_unsorted_index_xlim(self):
  359:         ser = Series(
  360:             [0.0, 1.0, np.nan, 3.0, 4.0, 5.0, 6.0],
  361:             index=[1.0, 0.0, 3.0, 2.0, np.nan, 3.0, 2.0],
  362:         )
  363:         _, ax = mpl.pyplot.subplots()
  364:         ax = ser.plot(ax=ax)
  365:         xmin, xmax = ax.get_xlim()
  366:         lines = ax.get_lines()
  367:         assert xmin <= np.nanmin(lines[0].get_data(orig=False)[0])
  368:         assert xmax >= np.nanmax(lines[0].get_data(orig=False)[0])
  369: 
  370:     def test_pie_series(self):
  371:         # if sum of values is less than 1.0, pie handle them as rate and draw
  372:         # semicircle.
  373:         series = Series(
  374:             np.random.default_rng(2).integers(1, 5),
  375:             index=["a", "b", "c", "d", "e"],
  376:             name="YLABEL",
  377:         )
  378:         ax = _check_plot_works(series.plot.pie)
  379:         _check_text_labels(ax.texts, series.index)
  380:         assert ax.get_ylabel() == "YLABEL"
  381: 
  382:     def test_pie_series_no_label(self):
  383:         series = Series(
  384:             np.random.default_rng(2).integers(1, 5),
  385:             index=["a", "b", "c", "d", "e"],
  386:             name="YLABEL",
  387:         )
  388:         ax = _check_plot_works(series.plot.pie, labels=None)
  389:         _check_text_labels(ax.texts, [""] * 5)
  390: 
  391:     def test_pie_series_less_colors_than_elements(self):
  392:         series = Series(
  393:             np.random.default_rng(2).integers(1, 5),
  394:             index=["a", "b", "c", "d", "e"],
  395:             name="YLABEL",
  396:         )
  397:         color_args = ["r", "g", "b"]
  398:         ax = _check_plot_works(series.plot.pie, colors=color_args)
  399: 
  400:         color_expected = ["r", "g", "b", "r", "g"]
  401:         _check_colors(ax.patches, facecolors=color_expected)
  402: 
  403:     def test_pie_series_labels_and_colors(self):
  404:         series = Series(
  405:             np.random.default_rng(2).integers(1, 5),
  406:             index=["a", "b", "c", "d", "e"],
  407:             name="YLABEL",
  408:         )
  409:         # with labels and colors
  410:         labels = ["A", "B", "C", "D", "E"]
  411:         color_args = ["r", "g", "b", "c", "m"]
  412:         ax = _check_plot_works(series.plot.pie, labels=labels, colors=color_args)
  413:         _check_text_labels(ax.texts, labels)
  414:         _check_colors(ax.patches, facecolors=color_args)
  415: 
  416:     def test_pie_series_autopct_and_fontsize(self):
  417:         series = Series(
  418:             np.random.default_rng(2).integers(1, 5),
  419:             index=["a", "b", "c", "d", "e"],
  420:             name="YLABEL",
  421:         )
  422:         color_args = ["r", "g", "b", "c", "m"]
  423:         ax = _check_plot_works(
  424:             series.plot.pie, colors=color_args, autopct="%.2f", fontsize=7
  425:         )
  426:         pcts = [f"{s*100:.2f}" for s in series.values / series.sum()]
  427:         expected_texts = list(chain.from_iterable(zip(series.index, pcts)))
  428:         _check_text_labels(ax.texts, expected_texts)
  429:         for t in ax.texts:
  430:             assert t.get_fontsize() == 7
  431: 
  432:     def test_pie_series_negative_raises(self):
  433:         # includes negative value
  434:         series = Series([1, 2, 0, 4, -1], index=["a", "b", "c", "d", "e"])
  435:         with pytest.raises(ValueError, match="pie plot doesn't allow negative values"):
  436:             series.plot.pie()
  437: 
  438:     def test_pie_series_nan(self):
  439:         # includes nan
  440:         series = Series([1, 2, np.nan, 4], index=["a", "b", "c", "d"], name="YLABEL")
  441:         ax = _check_plot_works(series.plot.pie)
  442:         _check_text_labels(ax.texts, ["a", "b", "", "d"])
  443: 
  444:     def test_pie_nan(self):
  445:         s = Series([1, np.nan, 1, 1])
  446:         _, ax = mpl.pyplot.subplots()
  447:         ax = s.plot.pie(legend=True, ax=ax)
  448:         expected = ["0", "", "2", "3"]
  449:         result = [x.get_text() for x in ax.texts]
  450:         assert result == expected
  451: 
  452:     def test_df_series_secondary_legend(self):
  453:         # GH 9779
  454:         df = DataFrame(
  455:             np.random.default_rng(2).standard_normal((30, 3)), columns=list("abc")
  456:         )
  457:         s = Series(np.random.default_rng(2).standard_normal(30), name="x")
  458: 
  459:         # primary -> secondary (without passing ax)
  460:         _, ax = mpl.pyplot.subplots()
  461:         ax = df.plot(ax=ax)
  462:         s.plot(legend=True, secondary_y=True, ax=ax)
  463:         # both legends are drawn on left ax
  464:         # left and right axis must be visible
  465:         _check_legend_labels(ax, labels=["a", "b", "c", "x (right)"])
  466:         assert ax.get_yaxis().get_visible()
  467:         assert ax.right_ax.get_yaxis().get_visible()
  468: 
  469:     def test_df_series_secondary_legend_with_axes(self):
  470:         # GH 9779
  471:         df = DataFrame(
  472:             np.random.default_rng(2).standard_normal((30, 3)), columns=list("abc")
  473:         )
  474:         s = Series(np.random.default_rng(2).standard_normal(30), name="x")
  475:         # primary -> secondary (with passing ax)
  476:         _, ax = mpl.pyplot.subplots()
  477:         ax = df.plot(ax=ax)
  478:         s.plot(ax=ax, legend=True, secondary_y=True)
  479:         # both legends are drawn on left ax
  480:         # left and right axis must be visible
  481:         _check_legend_labels(ax, labels=["a", "b", "c", "x (right)"])
  482:         assert ax.get_yaxis().get_visible()
  483:         assert ax.right_ax.get_yaxis().get_visible()
  484: 
  485:     def test_df_series_secondary_legend_both(self):
  486:         # GH 9779
  487:         df = DataFrame(
  488:             np.random.default_rng(2).standard_normal((30, 3)), columns=list("abc")
  489:         )
  490:         s = Series(np.random.default_rng(2).standard_normal(30), name="x")
  491:         # secondary -> secondary (without passing ax)
  492:         _, ax = mpl.pyplot.subplots()
  493:         ax = df.plot(secondary_y=True, ax=ax)
  494:         s.plot(legend=True, secondary_y=True, ax=ax)
  495:         # both legends are drawn on left ax
  496:         # left axis must be invisible and right axis must be visible
  497:         expected = ["a (right)", "b (right)", "c (right)", "x (right)"]
  498:         _check_legend_labels(ax.left_ax, labels=expected)
  499:         assert not ax.left_ax.get_yaxis().get_visible()
  500:         assert ax.get_yaxis().get_visible()
  501: 
  502:     def test_df_series_secondary_legend_both_with_axis(self):
  503:         # GH 9779
  504:         df = DataFrame(
  505:             np.random.default_rng(2).standard_normal((30, 3)), columns=list("abc")
  506:         )
  507:         s = Series(np.random.default_rng(2).standard_normal(30), name="x")
  508:         # secondary -> secondary (with passing ax)
  509:         _, ax = mpl.pyplot.subplots()
  510:         ax = df.plot(secondary_y=True, ax=ax)
  511:         s.plot(ax=ax, legend=True, secondary_y=True)
  512:         # both legends are drawn on left ax
  513:         # left axis must be invisible and right axis must be visible
  514:         expected = ["a (right)", "b (right)", "c (right)", "x (right)"]
  515:         _check_legend_labels(ax.left_ax, expected)
  516:         assert not ax.left_ax.get_yaxis().get_visible()
  517:         assert ax.get_yaxis().get_visible()
  518: 
  519:     def test_df_series_secondary_legend_both_with_axis_2(self):
  520:         # GH 9779
  521:         df = DataFrame(
  522:             np.random.default_rng(2).standard_normal((30, 3)), columns=list("abc")
  523:         )
  524:         s = Series(np.random.default_rng(2).standard_normal(30), name="x")
  525:         # secondary -> secondary (with passing ax)
  526:         _, ax = mpl.pyplot.subplots()
  527:         ax = df.plot(secondary_y=True, mark_right=False, ax=ax)
  528:         s.plot(ax=ax, legend=True, secondary_y=True)
  529:         # both legends are drawn on left ax
  530:         # left axis must be invisible and right axis must be visible
  531:         expected = ["a", "b", "c", "x (right)"]
  532:         _check_legend_labels(ax.left_ax, expected)
  533:         assert not ax.left_ax.get_yaxis().get_visible()
  534:         assert ax.get_yaxis().get_visible()
  535: 
  536:     @pytest.mark.parametrize(
  537:         "input_logy, expected_scale", [(True, "log"), ("sym", "symlog")]
  538:     )
  539:     def test_secondary_logy(self, input_logy, expected_scale):
  540:         # GH 25545
  541:         s1 = Series(np.random.default_rng(2).standard_normal(100))
  542:         s2 = Series(np.random.default_rng(2).standard_normal(100))
  543: 
  544:         # GH 24980
  545:         ax1 = s1.plot(logy=input_logy)
  546:         ax2 = s2.plot(secondary_y=True, logy=input_logy)
  547: 
  548:         assert ax1.get_yscale() == expected_scale
  549:         assert ax2.get_yscale() == expected_scale
  550: 
  551:     def test_plot_fails_with_dupe_color_and_style(self):
  552:         x = Series(np.random.default_rng(2).standard_normal(2))
  553:         _, ax = mpl.pyplot.subplots()
  554:         msg = (
  555:             "Cannot pass 'style' string with a color symbol and 'color' keyword "
  556:             "argument. Please use one or the other or pass 'style' without a color "
  557:             "symbol"
  558:         )
  559:         with pytest.raises(ValueError, match=msg):
  560:             x.plot(style="k--", color="k", ax=ax)
  561: 
  562:     @pytest.mark.parametrize(
  563:         "bw_method, ind",
  564:         [
  565:             ["scott", 20],
  566:             [None, 20],
  567:             [None, np.int_(20)],
  568:             [0.5, np.linspace(-100, 100, 20)],
  569:         ],
  570:     )
  571:     def test_kde_kwargs(self, ts, bw_method, ind):
  572:         pytest.importorskip("scipy")
  573:         _check_plot_works(ts.plot.kde, bw_method=bw_method, ind=ind)
  574: 
  575:     def test_density_kwargs(self, ts):
  576:         pytest.importorskip("scipy")
  577:         sample_points = np.linspace(-100, 100, 20)
  578:         _check_plot_works(ts.plot.density, bw_method=0.5, ind=sample_points)
  579: 
  580:     def test_kde_kwargs_check_axes(self, ts):
  581:         pytest.importorskip("scipy")
  582:         _, ax = mpl.pyplot.subplots()
  583:         sample_points = np.linspace(-100, 100, 20)
  584:         ax = ts.plot.kde(logy=True, bw_method=0.5, ind=sample_points, ax=ax)
  585:         _check_ax_scales(ax, yaxis="log")
  586:         _check_text_labels(ax.yaxis.get_label(), "Density")
  587: 
  588:     def test_kde_missing_vals(self):
  589:         pytest.importorskip("scipy")
  590:         s = Series(np.random.default_rng(2).uniform(size=50))
  591:         s[0] = np.nan
  592:         axes = _check_plot_works(s.plot.kde)
  593: 
  594:         # gh-14821: check if the values have any missing values
  595:         assert any(~np.isnan(axes.lines[0].get_xdata()))
  596: 
  597:     @pytest.mark.xfail(reason="Api changed in 3.6.0")
  598:     def test_boxplot_series(self, ts):
  599:         _, ax = mpl.pyplot.subplots()
  600:         ax = ts.plot.box(logy=True, ax=ax)
  601:         _check_ax_scales(ax, yaxis="log")
  602:         xlabels = ax.get_xticklabels()
  603:         _check_text_labels(xlabels, [ts.name])
  604:         ylabels = ax.get_yticklabels()
  605:         _check_text_labels(ylabels, [""] * len(ylabels))
  606: 
  607:     @pytest.mark.parametrize(
  608:         "kind",
  609:         plotting.PlotAccessor._common_kinds + plotting.PlotAccessor._series_kinds,
  610:     )
  611:     def test_kind_kwarg(self, kind):
  612:         pytest.importorskip("scipy")
  613:         s = Series(range(3))
  614:         _, ax = mpl.pyplot.subplots()
  615:         s.plot(kind=kind, ax=ax)
  616:         mpl.pyplot.close()
  617: 
  618:     @pytest.mark.parametrize(
  619:         "kind",
  620:         plotting.PlotAccessor._common_kinds + plotting.PlotAccessor._series_kinds,
  621:     )
  622:     def test_kind_attr(self, kind):
  623:         pytest.importorskip("scipy")
  624:         s = Series(range(3))
  625:         _, ax = mpl.pyplot.subplots()
  626:         getattr(s.plot, kind)()
  627:         mpl.pyplot.close()
  628: 
  629:     @pytest.mark.parametrize("kind", plotting.PlotAccessor._common_kinds)
  630:     def test_invalid_plot_data(self, kind):
  631:         s = Series(list("abcd"))
  632:         _, ax = mpl.pyplot.subplots()
  633:         msg = "no numeric data to plot"
  634:         with pytest.raises(TypeError, match=msg):
  635:             s.plot(kind=kind, ax=ax)
  636: 
  637:     @pytest.mark.parametrize("kind", plotting.PlotAccessor._common_kinds)
  638:     def test_valid_object_plot(self, kind):
  639:         pytest.importorskip("scipy")
  640:         s = Series(range(10), dtype=object)
  641:         _check_plot_works(s.plot, kind=kind)
  642: 
  643:     @pytest.mark.parametrize("kind", plotting.PlotAccessor._common_kinds)
  644:     def test_partially_invalid_plot_data(self, kind):
  645:         s = Series(["a", "b", 1.0, 2])
  646:         _, ax = mpl.pyplot.subplots()
  647:         msg = "no numeric data to plot"
  648:         with pytest.raises(TypeError, match=msg):
  649:             s.plot(kind=kind, ax=ax)
  650: 
  651:     def test_invalid_kind(self):
  652:         s = Series([1, 2])
  653:         with pytest.raises(ValueError, match="invalid_kind is not a valid plot kind"):
  654:             s.plot(kind="invalid_kind")
  655: 
  656:     def test_dup_datetime_index_plot(self):
  657:         dr1 = date_range("1/1/2009", periods=4)
  658:         dr2 = date_range("1/2/2009", periods=4)
  659:         index = dr1.append(dr2)
  660:         values = np.random.default_rng(2).standard_normal(index.size)
  661:         s = Series(values, index=index)
  662:         _check_plot_works(s.plot)
  663: 
  664:     def test_errorbar_asymmetrical(self):
  665:         # GH9536
  666:         s = Series(np.arange(10), name="x")
  667:         err = np.random.default_rng(2).random((2, 10))
  668: 
  669:         ax = s.plot(yerr=err, xerr=err)
  670: 
  671:         result = np.vstack([i.vertices[:, 1] for i in ax.collections[1].get_paths()])
  672:         expected = (err.T * np.array([-1, 1])) + s.to_numpy().reshape(-1, 1)
  673:         tm.assert_numpy_array_equal(result, expected)
  674: 
  675:         msg = (
  676:             "Asymmetrical error bars should be provided "
  677:             f"with the shape \\(2, {len(s)}\\)"
  678:         )
  679:         with pytest.raises(ValueError, match=msg):
  680:             s.plot(yerr=np.random.default_rng(2).random((2, 11)))
  681: 
  682:     @pytest.mark.slow
  683:     @pytest.mark.parametrize("kind", ["line", "bar"])
  684:     @pytest.mark.parametrize(
  685:         "yerr",
  686:         [
  687:             Series(np.abs(np.random.default_rng(2).standard_normal(10))),
  688:             np.abs(np.random.default_rng(2).standard_normal(10)),
  689:             list(np.abs(np.random.default_rng(2).standard_normal(10))),
  690:             DataFrame(
  691:                 np.abs(np.random.default_rng(2).standard_normal((10, 2))),
  692:                 columns=["x", "y"],
  693:             ),
  694:         ],
  695:     )
  696:     def test_errorbar_plot(self, kind, yerr):
  697:         s = Series(np.arange(10), name="x")
  698:         ax = _check_plot_works(s.plot, yerr=yerr, kind=kind)
  699:         _check_has_errorbars(ax, xerr=0, yerr=1)
  700: 
  701:     @pytest.mark.slow
  702:     def test_errorbar_plot_yerr_0(self):
  703:         s = Series(np.arange(10), name="x")
  704:         s_err = np.abs(np.random.default_rng(2).standard_normal(10))
  705:         ax = _check_plot_works(s.plot, xerr=s_err)
  706:         _check_has_errorbars(ax, xerr=1, yerr=0)
  707: 
  708:     @pytest.mark.slow
  709:     @pytest.mark.parametrize(
  710:         "yerr",
  711:         [
  712:             Series(np.abs(np.random.default_rng(2).standard_normal(12))),
  713:             DataFrame(
  714:                 np.abs(np.random.default_rng(2).standard_normal((12, 2))),
  715:                 columns=["x", "y"],
  716:             ),
  717:         ],
  718:     )
  719:     def test_errorbar_plot_ts(self, yerr):
  720:         # test time series plotting
  721:         ix = date_range("1/1/2000", "1/1/2001", freq="ME")
  722:         ts = Series(np.arange(12), index=ix, name="x")
  723:         yerr.index = ix
  724: 
  725:         ax = _check_plot_works(ts.plot, yerr=yerr)
  726:         _check_has_errorbars(ax, xerr=0, yerr=1)
  727: 
  728:     @pytest.mark.slow
  729:     def test_errorbar_plot_invalid_yerr_shape(self):
  730:         s = Series(np.arange(10), name="x")
  731:         # check incorrect lengths and types
  732:         with tm.external_error_raised(ValueError):
  733:             s.plot(yerr=np.arange(11))
  734: 
  735:     @pytest.mark.slow
  736:     def test_errorbar_plot_invalid_yerr(self):
  737:         s = Series(np.arange(10), name="x")
  738:         s_err = ["zzz"] * 10
  739:         with tm.external_error_raised(TypeError):
  740:             s.plot(yerr=s_err)
  741: 
  742:     @pytest.mark.slow
  743:     def test_table_true(self, series):
  744:         _check_plot_works(series.plot, table=True)
  745: 
  746:     @pytest.mark.slow
  747:     def test_table_self(self, series):
  748:         _check_plot_works(series.plot, table=series)
  749: 
  750:     @pytest.mark.slow
  751:     def test_series_grid_settings(self):
  752:         # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792
  753:         pytest.importorskip("scipy")
  754:         _check_grid_settings(
  755:             Series([1, 2, 3]),
  756:             plotting.PlotAccessor._series_kinds + plotting.PlotAccessor._common_kinds,
  757:         )
  758: 
  759:     @pytest.mark.parametrize("c", ["r", "red", "green", "#FF0000"])
  760:     def test_standard_colors(self, c):
  761:         from pandas.plotting._matplotlib.style import get_standard_colors
  762: 
  763:         result = get_standard_colors(1, color=c)
  764:         assert result == [c]
  765: 
  766:         result = get_standard_colors(1, color=[c])
  767:         assert result == [c]
  768: 
  769:         result = get_standard_colors(3, color=c)
  770:         assert result == [c] * 3
  771: 
  772:         result = get_standard_colors(3, color=[c])
  773:         assert result == [c] * 3
  774: 
  775:     def test_standard_colors_all(self):
  776:         from matplotlib import colors
  777: 
  778:         from pandas.plotting._matplotlib.style import get_standard_colors
  779: 
  780:         # multiple colors like mediumaquamarine
  781:         for c in colors.cnames:
  782:             result = get_standard_colors(num_colors=1, color=c)
  783:             assert result == [c]
  784: 
  785:             result = get_standard_colors(num_colors=1, color=[c])
  786:             assert result == [c]
  787: 
  788:             result = get_standard_colors(num_colors=3, color=c)
  789:             assert result == [c] * 3
  790: 
  791:             result = get_standard_colors(num_colors=3, color=[c])
  792:             assert result == [c] * 3
  793: 
  794:         # single letter colors like k
  795:         for c in colors.ColorConverter.colors:
  796:             result = get_standard_colors(num_colors=1, color=c)
  797:             assert result == [c]
  798: 
  799:             result = get_standard_colors(num_colors=1, color=[c])
  800:             assert result == [c]
  801: 
  802:             result = get_standard_colors(num_colors=3, color=c)
  803:             assert result == [c] * 3
  804: 
  805:             result = get_standard_colors(num_colors=3, color=[c])
  806:             assert result == [c] * 3
  807: 
  808:     def test_series_plot_color_kwargs(self):
  809:         # GH1890
  810:         _, ax = mpl.pyplot.subplots()
  811:         ax = Series(np.arange(12) + 1).plot(color="green", ax=ax)
  812:         _check_colors(ax.get_lines(), linecolors=["green"])
  813: 
  814:     def test_time_series_plot_color_kwargs(self):
  815:         # #1890
  816:         _, ax = mpl.pyplot.subplots()
  817:         ax = Series(np.arange(12) + 1, index=date_range("1/1/2000", periods=12)).plot(
  818:             color="green", ax=ax
  819:         )
  820:         _check_colors(ax.get_lines(), linecolors=["green"])
  821: 
  822:     def test_time_series_plot_color_with_empty_kwargs(self):
  823:         import matplotlib as mpl
  824: 
  825:         def_colors = _unpack_cycler(mpl.rcParams)
  826:         index = date_range("1/1/2000", periods=12)
  827:         s = Series(np.arange(1, 13), index=index)
  828: 
  829:         ncolors = 3
  830: 
  831:         _, ax = mpl.pyplot.subplots()
  832:         for i in range(ncolors):
  833:             ax = s.plot(ax=ax)
  834:         _check_colors(ax.get_lines(), linecolors=def_colors[:ncolors])
  835: 
  836:     def test_xticklabels(self):
  837:         # GH11529
  838:         s = Series(np.arange(10), index=[f"P{i:02d}" for i in range(10)])
  839:         _, ax = mpl.pyplot.subplots()
  840:         ax = s.plot(xticks=[0, 3, 5, 9], ax=ax)
  841:         exp = [f"P{i:02d}" for i in [0, 3, 5, 9]]
  842:         _check_text_labels(ax.get_xticklabels(), exp)
  843: 
  844:     def test_xtick_barPlot(self):
  845:         # GH28172
  846:         s = Series(range(10), index=[f"P{i:02d}" for i in range(10)])
  847:         ax = s.plot.bar(xticks=range(0, 11, 2))
  848:         exp = np.array(list(range(0, 11, 2)))
  849:         tm.assert_numpy_array_equal(exp, ax.get_xticks())
  850: 
  851:     def test_custom_business_day_freq(self):
  852:         # GH7222
  853:         from pandas.tseries.offsets import CustomBusinessDay
  854: 
  855:         s = Series(
  856:             range(100, 121),
  857:             index=pd.bdate_range(
  858:                 start="2014-05-01",
  859:                 end="2014-06-01",
  860:                 freq=CustomBusinessDay(holidays=["2014-05-26"]),
  861:             ),
  862:         )
  863: 
  864:         _check_plot_works(s.plot)
  865: 
  866:     @pytest.mark.xfail(
  867:         reason="GH#24426, see also "
  868:         "github.com/pandas-dev/pandas/commit/"
  869:         "ef1bd69fa42bbed5d09dd17f08c44fc8bfc2b685#r61470674"
  870:     )
  871:     def test_plot_accessor_updates_on_inplace(self):
  872:         ser = Series([1, 2, 3, 4])
  873:         _, ax = mpl.pyplot.subplots()
  874:         ax = ser.plot(ax=ax)
  875:         before = ax.xaxis.get_ticklocs()
  876: 
  877:         ser.drop([0, 1], inplace=True)
  878:         _, ax = mpl.pyplot.subplots()
  879:         after = ax.xaxis.get_ticklocs()
  880:         tm.assert_numpy_array_equal(before, after)
  881: 
  882:     @pytest.mark.parametrize("kind", ["line", "area"])
  883:     def test_plot_xlim_for_series(self, kind):
  884:         # test if xlim is also correctly plotted in Series for line and area
  885:         # GH 27686
  886:         s = Series([2, 3])
  887:         _, ax = mpl.pyplot.subplots()
  888:         s.plot(kind=kind, ax=ax)
  889:         xlims = ax.get_xlim()
  890: 
  891:         assert xlims[0] < 0
  892:         assert xlims[1] > 1
  893: 
  894:     def test_plot_no_rows(self):
  895:         # GH 27758
  896:         df = Series(dtype=int)
  897:         assert df.empty
  898:         ax = df.plot()
  899:         assert len(ax.get_lines()) == 1
  900:         line = ax.get_lines()[0]
  901:         assert len(line.get_xdata()) == 0
  902:         assert len(line.get_ydata()) == 0
  903: 
  904:     def test_plot_no_numeric_data(self):
  905:         df = Series(["a", "b", "c"])
  906:         with pytest.raises(TypeError, match="no numeric data to plot"):
  907:             df.plot()
  908: 
  909:     @pytest.mark.parametrize(
  910:         "data, index",
  911:         [
  912:             ([1, 2, 3, 4], [3, 2, 1, 0]),
  913:             ([10, 50, 20, 30], [1910, 1920, 1980, 1950]),
  914:         ],
  915:     )
  916:     def test_plot_order(self, data, index):
  917:         # GH38865 Verify plot order of a Series
  918:         ser = Series(data=data, index=index)
  919:         ax = ser.plot(kind="bar")
  920: 
  921:         expected = ser.tolist()
  922:         result = [
  923:             patch.get_bbox().ymax
  924:             for patch in sorted(ax.patches, key=lambda patch: patch.get_bbox().xmax)
  925:         ]
  926:         assert expected == result
  927: 
  928:     def test_style_single_ok(self):
  929:         s = Series([1, 2])
  930:         ax = s.plot(style="s", color="C3")
  931:         assert ax.lines[0].get_color() == "C3"
  932: 
  933:     @pytest.mark.parametrize(
  934:         "index_name, old_label, new_label",
  935:         [(None, "", "new"), ("old", "old", "new"), (None, "", "")],
  936:     )
  937:     @pytest.mark.parametrize("kind", ["line", "area", "bar", "barh", "hist"])
  938:     def test_xlabel_ylabel_series(self, kind, index_name, old_label, new_label):
  939:         # GH 9093
  940:         ser = Series([1, 2, 3, 4])
  941:         ser.index.name = index_name
  942: 
  943:         # default is the ylabel is not shown and xlabel is index name (reverse for barh)
  944:         ax = ser.plot(kind=kind)
  945:         if kind == "barh":
  946:             assert ax.get_xlabel() == ""
  947:             assert ax.get_ylabel() == old_label
  948:         elif kind == "hist":
  949:             assert ax.get_xlabel() == ""
  950:             assert ax.get_ylabel() == "Frequency"
  951:         else:
  952:             assert ax.get_ylabel() == ""
  953:             assert ax.get_xlabel() == old_label
  954: 
  955:         # old xlabel will be overridden and assigned ylabel will be used as ylabel
  956:         ax = ser.plot(kind=kind, ylabel=new_label, xlabel=new_label)
  957:         assert ax.get_ylabel() == new_label
  958:         assert ax.get_xlabel() == new_label
  959: 
  960:     @pytest.mark.parametrize(
  961:         "index",
  962:         [
  963:             pd.timedelta_range(start=0, periods=2, freq="D"),
  964:             [pd.Timedelta(days=1), pd.Timedelta(days=2)],
  965:         ],
  966:     )
  967:     def test_timedelta_index(self, index):
  968:         # GH37454
  969:         xlims = (3, 1)
  970:         ax = Series([1, 2], index=index).plot(xlim=(xlims))
  971:         assert ax.get_xlim() == (3, 1)
  972: 
  973:     def test_series_none_color(self):
  974:         # GH51953
  975:         series = Series([1, 2, 3])
  976:         ax = series.plot(color=None)
  977:         expected = _unpack_cycler(mpl.pyplot.rcParams)[:1]
  978:         _check_colors(ax.get_lines(), linecolors=expected)
  979: 
  980:     @pytest.mark.slow
  981:     def test_plot_no_warning(self, ts):
  982:         # GH 55138
  983:         # TODO(3.0): this can be removed once Period[B] deprecation is enforced
  984:         with tm.assert_produces_warning(False):
  985:             _ = ts.plot()
