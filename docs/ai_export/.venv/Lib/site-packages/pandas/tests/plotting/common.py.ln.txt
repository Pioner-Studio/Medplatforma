    1: """
    2: Module consolidating common testing functions for checking plotting.
    3: """
    4: 
    5: from __future__ import annotations
    6: 
    7: from typing import TYPE_CHECKING
    8: 
    9: import numpy as np
   10: 
   11: from pandas.core.dtypes.api import is_list_like
   12: 
   13: import pandas as pd
   14: from pandas import Series
   15: import pandas._testing as tm
   16: 
   17: if TYPE_CHECKING:
   18:     from collections.abc import Sequence
   19: 
   20:     from matplotlib.axes import Axes
   21: 
   22: 
   23: def _check_legend_labels(axes, labels=None, visible=True):
   24:     """
   25:     Check each axes has expected legend labels
   26: 
   27:     Parameters
   28:     ----------
   29:     axes : matplotlib Axes object, or its list-like
   30:     labels : list-like
   31:         expected legend labels
   32:     visible : bool
   33:         expected legend visibility. labels are checked only when visible is
   34:         True
   35:     """
   36:     if visible and (labels is None):
   37:         raise ValueError("labels must be specified when visible is True")
   38:     axes = _flatten_visible(axes)
   39:     for ax in axes:
   40:         if visible:
   41:             assert ax.get_legend() is not None
   42:             _check_text_labels(ax.get_legend().get_texts(), labels)
   43:         else:
   44:             assert ax.get_legend() is None
   45: 
   46: 
   47: def _check_legend_marker(ax, expected_markers=None, visible=True):
   48:     """
   49:     Check ax has expected legend markers
   50: 
   51:     Parameters
   52:     ----------
   53:     ax : matplotlib Axes object
   54:     expected_markers : list-like
   55:         expected legend markers
   56:     visible : bool
   57:         expected legend visibility. labels are checked only when visible is
   58:         True
   59:     """
   60:     if visible and (expected_markers is None):
   61:         raise ValueError("Markers must be specified when visible is True")
   62:     if visible:
   63:         handles, _ = ax.get_legend_handles_labels()
   64:         markers = [handle.get_marker() for handle in handles]
   65:         assert markers == expected_markers
   66:     else:
   67:         assert ax.get_legend() is None
   68: 
   69: 
   70: def _check_data(xp, rs):
   71:     """
   72:     Check each axes has identical lines
   73: 
   74:     Parameters
   75:     ----------
   76:     xp : matplotlib Axes object
   77:     rs : matplotlib Axes object
   78:     """
   79:     import matplotlib.pyplot as plt
   80: 
   81:     xp_lines = xp.get_lines()
   82:     rs_lines = rs.get_lines()
   83: 
   84:     assert len(xp_lines) == len(rs_lines)
   85:     for xpl, rsl in zip(xp_lines, rs_lines):
   86:         xpdata = xpl.get_xydata()
   87:         rsdata = rsl.get_xydata()
   88:         tm.assert_almost_equal(xpdata, rsdata)
   89: 
   90:     plt.close("all")
   91: 
   92: 
   93: def _check_visible(collections, visible=True):
   94:     """
   95:     Check each artist is visible or not
   96: 
   97:     Parameters
   98:     ----------
   99:     collections : matplotlib Artist or its list-like
  100:         target Artist or its list or collection
  101:     visible : bool
  102:         expected visibility
  103:     """
  104:     from matplotlib.collections import Collection
  105: 
  106:     if not isinstance(collections, Collection) and not is_list_like(collections):
  107:         collections = [collections]
  108: 
  109:     for patch in collections:
  110:         assert patch.get_visible() == visible
  111: 
  112: 
  113: def _check_patches_all_filled(axes: Axes | Sequence[Axes], filled: bool = True) -> None:
  114:     """
  115:     Check for each artist whether it is filled or not
  116: 
  117:     Parameters
  118:     ----------
  119:     axes : matplotlib Axes object, or its list-like
  120:     filled : bool
  121:         expected filling
  122:     """
  123: 
  124:     axes = _flatten_visible(axes)
  125:     for ax in axes:
  126:         for patch in ax.patches:
  127:             assert patch.fill == filled
  128: 
  129: 
  130: def _get_colors_mapped(series, colors):
  131:     unique = series.unique()
  132:     # unique and colors length can be differed
  133:     # depending on slice value
  134:     mapped = dict(zip(unique, colors))
  135:     return [mapped[v] for v in series.values]
  136: 
  137: 
  138: def _check_colors(collections, linecolors=None, facecolors=None, mapping=None):
  139:     """
  140:     Check each artist has expected line colors and face colors
  141: 
  142:     Parameters
  143:     ----------
  144:     collections : list-like
  145:         list or collection of target artist
  146:     linecolors : list-like which has the same length as collections
  147:         list of expected line colors
  148:     facecolors : list-like which has the same length as collections
  149:         list of expected face colors
  150:     mapping : Series
  151:         Series used for color grouping key
  152:         used for andrew_curves, parallel_coordinates, radviz test
  153:     """
  154:     from matplotlib import colors
  155:     from matplotlib.collections import (
  156:         Collection,
  157:         LineCollection,
  158:         PolyCollection,
  159:     )
  160:     from matplotlib.lines import Line2D
  161: 
  162:     conv = colors.ColorConverter
  163:     if linecolors is not None:
  164:         if mapping is not None:
  165:             linecolors = _get_colors_mapped(mapping, linecolors)
  166:             linecolors = linecolors[: len(collections)]
  167: 
  168:         assert len(collections) == len(linecolors)
  169:         for patch, color in zip(collections, linecolors):
  170:             if isinstance(patch, Line2D):
  171:                 result = patch.get_color()
  172:                 # Line2D may contains string color expression
  173:                 result = conv.to_rgba(result)
  174:             elif isinstance(patch, (PolyCollection, LineCollection)):
  175:                 result = tuple(patch.get_edgecolor()[0])
  176:             else:
  177:                 result = patch.get_edgecolor()
  178: 
  179:             expected = conv.to_rgba(color)
  180:             assert result == expected
  181: 
  182:     if facecolors is not None:
  183:         if mapping is not None:
  184:             facecolors = _get_colors_mapped(mapping, facecolors)
  185:             facecolors = facecolors[: len(collections)]
  186: 
  187:         assert len(collections) == len(facecolors)
  188:         for patch, color in zip(collections, facecolors):
  189:             if isinstance(patch, Collection):
  190:                 # returned as list of np.array
  191:                 result = patch.get_facecolor()[0]
  192:             else:
  193:                 result = patch.get_facecolor()
  194: 
  195:             if isinstance(result, np.ndarray):
  196:                 result = tuple(result)
  197: 
  198:             expected = conv.to_rgba(color)
  199:             assert result == expected
  200: 
  201: 
  202: def _check_text_labels(texts, expected):
  203:     """
  204:     Check each text has expected labels
  205: 
  206:     Parameters
  207:     ----------
  208:     texts : matplotlib Text object, or its list-like
  209:         target text, or its list
  210:     expected : str or list-like which has the same length as texts
  211:         expected text label, or its list
  212:     """
  213:     if not is_list_like(texts):
  214:         assert texts.get_text() == expected
  215:     else:
  216:         labels = [t.get_text() for t in texts]
  217:         assert len(labels) == len(expected)
  218:         for label, e in zip(labels, expected):
  219:             assert label == e
  220: 
  221: 
  222: def _check_ticks_props(axes, xlabelsize=None, xrot=None, ylabelsize=None, yrot=None):
  223:     """
  224:     Check each axes has expected tick properties
  225: 
  226:     Parameters
  227:     ----------
  228:     axes : matplotlib Axes object, or its list-like
  229:     xlabelsize : number
  230:         expected xticks font size
  231:     xrot : number
  232:         expected xticks rotation
  233:     ylabelsize : number
  234:         expected yticks font size
  235:     yrot : number
  236:         expected yticks rotation
  237:     """
  238:     from matplotlib.ticker import NullFormatter
  239: 
  240:     axes = _flatten_visible(axes)
  241:     for ax in axes:
  242:         if xlabelsize is not None or xrot is not None:
  243:             if isinstance(ax.xaxis.get_minor_formatter(), NullFormatter):
  244:                 # If minor ticks has NullFormatter, rot / fontsize are not
  245:                 # retained
  246:                 labels = ax.get_xticklabels()
  247:             else:
  248:                 labels = ax.get_xticklabels() + ax.get_xticklabels(minor=True)
  249: 
  250:             for label in labels:
  251:                 if xlabelsize is not None:
  252:                     tm.assert_almost_equal(label.get_fontsize(), xlabelsize)
  253:                 if xrot is not None:
  254:                     tm.assert_almost_equal(label.get_rotation(), xrot)
  255: 
  256:         if ylabelsize is not None or yrot is not None:
  257:             if isinstance(ax.yaxis.get_minor_formatter(), NullFormatter):
  258:                 labels = ax.get_yticklabels()
  259:             else:
  260:                 labels = ax.get_yticklabels() + ax.get_yticklabels(minor=True)
  261: 
  262:             for label in labels:
  263:                 if ylabelsize is not None:
  264:                     tm.assert_almost_equal(label.get_fontsize(), ylabelsize)
  265:                 if yrot is not None:
  266:                     tm.assert_almost_equal(label.get_rotation(), yrot)
  267: 
  268: 
  269: def _check_ax_scales(axes, xaxis="linear", yaxis="linear"):
  270:     """
  271:     Check each axes has expected scales
  272: 
  273:     Parameters
  274:     ----------
  275:     axes : matplotlib Axes object, or its list-like
  276:     xaxis : {'linear', 'log'}
  277:         expected xaxis scale
  278:     yaxis : {'linear', 'log'}
  279:         expected yaxis scale
  280:     """
  281:     axes = _flatten_visible(axes)
  282:     for ax in axes:
  283:         assert ax.xaxis.get_scale() == xaxis
  284:         assert ax.yaxis.get_scale() == yaxis
  285: 
  286: 
  287: def _check_axes_shape(axes, axes_num=None, layout=None, figsize=None):
  288:     """
  289:     Check expected number of axes is drawn in expected layout
  290: 
  291:     Parameters
  292:     ----------
  293:     axes : matplotlib Axes object, or its list-like
  294:     axes_num : number
  295:         expected number of axes. Unnecessary axes should be set to
  296:         invisible.
  297:     layout : tuple
  298:         expected layout, (expected number of rows , columns)
  299:     figsize : tuple
  300:         expected figsize. default is matplotlib default
  301:     """
  302:     from pandas.plotting._matplotlib.tools import flatten_axes
  303: 
  304:     if figsize is None:
  305:         figsize = (6.4, 4.8)
  306:     visible_axes = _flatten_visible(axes)
  307: 
  308:     if axes_num is not None:
  309:         assert len(visible_axes) == axes_num
  310:         for ax in visible_axes:
  311:             # check something drawn on visible axes
  312:             assert len(ax.get_children()) > 0
  313: 
  314:     if layout is not None:
  315:         x_set = set()
  316:         y_set = set()
  317:         for ax in flatten_axes(axes):
  318:             # check axes coordinates to estimate layout
  319:             points = ax.get_position().get_points()
  320:             x_set.add(points[0][0])
  321:             y_set.add(points[0][1])
  322:         result = (len(y_set), len(x_set))
  323:         assert result == layout
  324: 
  325:     tm.assert_numpy_array_equal(
  326:         visible_axes[0].figure.get_size_inches(),
  327:         np.array(figsize, dtype=np.float64),
  328:     )
  329: 
  330: 
  331: def _flatten_visible(axes: Axes | Sequence[Axes]) -> Sequence[Axes]:
  332:     """
  333:     Flatten axes, and filter only visible
  334: 
  335:     Parameters
  336:     ----------
  337:     axes : matplotlib Axes object, or its list-like
  338: 
  339:     """
  340:     from pandas.plotting._matplotlib.tools import flatten_axes
  341: 
  342:     axes_ndarray = flatten_axes(axes)
  343:     axes = [ax for ax in axes_ndarray if ax.get_visible()]
  344:     return axes
  345: 
  346: 
  347: def _check_has_errorbars(axes, xerr=0, yerr=0):
  348:     """
  349:     Check axes has expected number of errorbars
  350: 
  351:     Parameters
  352:     ----------
  353:     axes : matplotlib Axes object, or its list-like
  354:     xerr : number
  355:         expected number of x errorbar
  356:     yerr : number
  357:         expected number of y errorbar
  358:     """
  359:     axes = _flatten_visible(axes)
  360:     for ax in axes:
  361:         containers = ax.containers
  362:         xerr_count = 0
  363:         yerr_count = 0
  364:         for c in containers:
  365:             has_xerr = getattr(c, "has_xerr", False)
  366:             has_yerr = getattr(c, "has_yerr", False)
  367:             if has_xerr:
  368:                 xerr_count += 1
  369:             if has_yerr:
  370:                 yerr_count += 1
  371:         assert xerr == xerr_count
  372:         assert yerr == yerr_count
  373: 
  374: 
  375: def _check_box_return_type(
  376:     returned, return_type, expected_keys=None, check_ax_title=True
  377: ):
  378:     """
  379:     Check box returned type is correct
  380: 
  381:     Parameters
  382:     ----------
  383:     returned : object to be tested, returned from boxplot
  384:     return_type : str
  385:         return_type passed to boxplot
  386:     expected_keys : list-like, optional
  387:         group labels in subplot case. If not passed,
  388:         the function checks assuming boxplot uses single ax
  389:     check_ax_title : bool
  390:         Whether to check the ax.title is the same as expected_key
  391:         Intended to be checked by calling from ``boxplot``.
  392:         Normal ``plot`` doesn't attach ``ax.title``, it must be disabled.
  393:     """
  394:     from matplotlib.axes import Axes
  395: 
  396:     types = {"dict": dict, "axes": Axes, "both": tuple}
  397:     if expected_keys is None:
  398:         # should be fixed when the returning default is changed
  399:         if return_type is None:
  400:             return_type = "dict"
  401: 
  402:         assert isinstance(returned, types[return_type])
  403:         if return_type == "both":
  404:             assert isinstance(returned.ax, Axes)
  405:             assert isinstance(returned.lines, dict)
  406:     else:
  407:         # should be fixed when the returning default is changed
  408:         if return_type is None:
  409:             for r in _flatten_visible(returned):
  410:                 assert isinstance(r, Axes)
  411:             return
  412: 
  413:         assert isinstance(returned, Series)
  414: 
  415:         assert sorted(returned.keys()) == sorted(expected_keys)
  416:         for key, value in returned.items():
  417:             assert isinstance(value, types[return_type])
  418:             # check returned dict has correct mapping
  419:             if return_type == "axes":
  420:                 if check_ax_title:
  421:                     assert value.get_title() == key
  422:             elif return_type == "both":
  423:                 if check_ax_title:
  424:                     assert value.ax.get_title() == key
  425:                 assert isinstance(value.ax, Axes)
  426:                 assert isinstance(value.lines, dict)
  427:             elif return_type == "dict":
  428:                 line = value["medians"][0]
  429:                 axes = line.axes
  430:                 if check_ax_title:
  431:                     assert axes.get_title() == key
  432:             else:
  433:                 raise AssertionError
  434: 
  435: 
  436: def _check_grid_settings(obj, kinds, kws={}):
  437:     # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792
  438: 
  439:     import matplotlib as mpl
  440: 
  441:     def is_grid_on():
  442:         xticks = mpl.pyplot.gca().xaxis.get_major_ticks()
  443:         yticks = mpl.pyplot.gca().yaxis.get_major_ticks()
  444:         xoff = all(not g.gridline.get_visible() for g in xticks)
  445:         yoff = all(not g.gridline.get_visible() for g in yticks)
  446: 
  447:         return not (xoff and yoff)
  448: 
  449:     spndx = 1
  450:     for kind in kinds:
  451:         mpl.pyplot.subplot(1, 4 * len(kinds), spndx)
  452:         spndx += 1
  453:         mpl.rc("axes", grid=False)
  454:         obj.plot(kind=kind, **kws)
  455:         assert not is_grid_on()
  456:         mpl.pyplot.clf()
  457: 
  458:         mpl.pyplot.subplot(1, 4 * len(kinds), spndx)
  459:         spndx += 1
  460:         mpl.rc("axes", grid=True)
  461:         obj.plot(kind=kind, grid=False, **kws)
  462:         assert not is_grid_on()
  463:         mpl.pyplot.clf()
  464: 
  465:         if kind not in ["pie", "hexbin", "scatter"]:
  466:             mpl.pyplot.subplot(1, 4 * len(kinds), spndx)
  467:             spndx += 1
  468:             mpl.rc("axes", grid=True)
  469:             obj.plot(kind=kind, **kws)
  470:             assert is_grid_on()
  471:             mpl.pyplot.clf()
  472: 
  473:             mpl.pyplot.subplot(1, 4 * len(kinds), spndx)
  474:             spndx += 1
  475:             mpl.rc("axes", grid=False)
  476:             obj.plot(kind=kind, grid=True, **kws)
  477:             assert is_grid_on()
  478:             mpl.pyplot.clf()
  479: 
  480: 
  481: def _unpack_cycler(rcParams, field="color"):
  482:     """
  483:     Auxiliary function for correctly unpacking cycler after MPL >= 1.5
  484:     """
  485:     return [v[field] for v in rcParams["axes.prop_cycle"]]
  486: 
  487: 
  488: def get_x_axis(ax):
  489:     return ax._shared_axes["x"]
  490: 
  491: 
  492: def get_y_axis(ax):
  493:     return ax._shared_axes["y"]
  494: 
  495: 
  496: def _check_plot_works(f, default_axes=False, **kwargs):
  497:     """
  498:     Create plot and ensure that plot return object is valid.
  499: 
  500:     Parameters
  501:     ----------
  502:     f : func
  503:         Plotting function.
  504:     default_axes : bool, optional
  505:         If False (default):
  506:             - If `ax` not in `kwargs`, then create subplot(211) and plot there
  507:             - Create new subplot(212) and plot there as well
  508:             - Mind special corner case for bootstrap_plot (see `_gen_two_subplots`)
  509:         If True:
  510:             - Simply run plotting function with kwargs provided
  511:             - All required axes instances will be created automatically
  512:             - It is recommended to use it when the plotting function
  513:             creates multiple axes itself. It helps avoid warnings like
  514:             'UserWarning: To output multiple subplots,
  515:             the figure containing the passed axes is being cleared'
  516:     **kwargs
  517:         Keyword arguments passed to the plotting function.
  518: 
  519:     Returns
  520:     -------
  521:     Plot object returned by the last plotting.
  522:     """
  523:     import matplotlib.pyplot as plt
  524: 
  525:     if default_axes:
  526:         gen_plots = _gen_default_plot
  527:     else:
  528:         gen_plots = _gen_two_subplots
  529: 
  530:     ret = None
  531:     try:
  532:         fig = kwargs.get("figure", plt.gcf())
  533:         plt.clf()
  534: 
  535:         for ret in gen_plots(f, fig, **kwargs):
  536:             tm.assert_is_valid_plot_return_object(ret)
  537: 
  538:     finally:
  539:         plt.close(fig)
  540: 
  541:     return ret
  542: 
  543: 
  544: def _gen_default_plot(f, fig, **kwargs):
  545:     """
  546:     Create plot in a default way.
  547:     """
  548:     yield f(**kwargs)
  549: 
  550: 
  551: def _gen_two_subplots(f, fig, **kwargs):
  552:     """
  553:     Create plot on two subplots forcefully created.
  554:     """
  555:     if "ax" not in kwargs:
  556:         fig.add_subplot(211)
  557:     yield f(**kwargs)
  558: 
  559:     if f is pd.plotting.bootstrap_plot:
  560:         assert "ax" not in kwargs
  561:     else:
  562:         kwargs["ax"] = fig.add_subplot(212)
  563:     yield f(**kwargs)
