    1: """ Test cases for DataFrame.plot """
    2: from datetime import (
    3:     date,
    4:     datetime,
    5: )
    6: import gc
    7: import itertools
    8: import re
    9: import string
   10: import weakref
   11: 
   12: import numpy as np
   13: import pytest
   14: 
   15: import pandas.util._test_decorators as td
   16: 
   17: from pandas.core.dtypes.api import is_list_like
   18: 
   19: import pandas as pd
   20: from pandas import (
   21:     DataFrame,
   22:     Index,
   23:     MultiIndex,
   24:     PeriodIndex,
   25:     Series,
   26:     bdate_range,
   27:     date_range,
   28:     option_context,
   29:     plotting,
   30: )
   31: import pandas._testing as tm
   32: from pandas.tests.plotting.common import (
   33:     _check_ax_scales,
   34:     _check_axes_shape,
   35:     _check_box_return_type,
   36:     _check_colors,
   37:     _check_data,
   38:     _check_grid_settings,
   39:     _check_has_errorbars,
   40:     _check_legend_labels,
   41:     _check_plot_works,
   42:     _check_text_labels,
   43:     _check_ticks_props,
   44:     _check_visible,
   45:     get_y_axis,
   46: )
   47: 
   48: from pandas.io.formats.printing import pprint_thing
   49: 
   50: mpl = pytest.importorskip("matplotlib")
   51: plt = pytest.importorskip("matplotlib.pyplot")
   52: 
   53: 
   54: class TestDataFramePlots:
   55:     @pytest.mark.slow
   56:     def test_plot(self):
   57:         df = DataFrame(
   58:             np.random.default_rng(2).standard_normal((10, 4)),
   59:             columns=Index(list("ABCD"), dtype=object),
   60:             index=date_range("2000-01-01", periods=10, freq="B"),
   61:         )
   62:         _check_plot_works(df.plot, grid=False)
   63: 
   64:     @pytest.mark.slow
   65:     def test_plot_subplots(self):
   66:         df = DataFrame(
   67:             np.random.default_rng(2).standard_normal((10, 4)),
   68:             columns=Index(list("ABCD"), dtype=object),
   69:             index=date_range("2000-01-01", periods=10, freq="B"),
   70:         )
   71:         # _check_plot_works adds an ax so use default_axes=True to avoid warning
   72:         axes = _check_plot_works(df.plot, default_axes=True, subplots=True)
   73:         _check_axes_shape(axes, axes_num=4, layout=(4, 1))
   74: 
   75:     @pytest.mark.slow
   76:     def test_plot_subplots_negative_layout(self):
   77:         df = DataFrame(
   78:             np.random.default_rng(2).standard_normal((10, 4)),
   79:             columns=Index(list("ABCD"), dtype=object),
   80:             index=date_range("2000-01-01", periods=10, freq="B"),
   81:         )
   82:         axes = _check_plot_works(
   83:             df.plot,
   84:             default_axes=True,
   85:             subplots=True,
   86:             layout=(-1, 2),
   87:         )
   88:         _check_axes_shape(axes, axes_num=4, layout=(2, 2))
   89: 
   90:     @pytest.mark.slow
   91:     def test_plot_subplots_use_index(self):
   92:         df = DataFrame(
   93:             np.random.default_rng(2).standard_normal((10, 4)),
   94:             columns=Index(list("ABCD"), dtype=object),
   95:             index=date_range("2000-01-01", periods=10, freq="B"),
   96:         )
   97:         axes = _check_plot_works(
   98:             df.plot,
   99:             default_axes=True,
  100:             subplots=True,
  101:             use_index=False,
  102:         )
  103:         _check_ticks_props(axes, xrot=0)
  104:         _check_axes_shape(axes, axes_num=4, layout=(4, 1))
  105: 
  106:     @pytest.mark.xfail(reason="Api changed in 3.6.0")
  107:     @pytest.mark.slow
  108:     def test_plot_invalid_arg(self):
  109:         df = DataFrame({"x": [1, 2], "y": [3, 4]})
  110:         msg = "'Line2D' object has no property 'blarg'"
  111:         with pytest.raises(AttributeError, match=msg):
  112:             df.plot.line(blarg=True)
  113: 
  114:     @pytest.mark.slow
  115:     def test_plot_tick_props(self):
  116:         df = DataFrame(
  117:             np.random.default_rng(2).random((10, 3)),
  118:             index=list(string.ascii_letters[:10]),
  119:         )
  120: 
  121:         ax = _check_plot_works(df.plot, use_index=True)
  122:         _check_ticks_props(ax, xrot=0)
  123: 
  124:     @pytest.mark.slow
  125:     @pytest.mark.parametrize(
  126:         "kwargs",
  127:         [
  128:             {"yticks": [1, 5, 10]},
  129:             {"xticks": [1, 5, 10]},
  130:             {"ylim": (-100, 100), "xlim": (-100, 100)},
  131:             {"default_axes": True, "subplots": True, "title": "blah"},
  132:         ],
  133:     )
  134:     def test_plot_other_args(self, kwargs):
  135:         df = DataFrame(
  136:             np.random.default_rng(2).random((10, 3)),
  137:             index=list(string.ascii_letters[:10]),
  138:         )
  139:         _check_plot_works(df.plot, **kwargs)
  140: 
  141:     @pytest.mark.slow
  142:     def test_plot_visible_ax(self):
  143:         df = DataFrame(
  144:             np.random.default_rng(2).random((10, 3)),
  145:             index=list(string.ascii_letters[:10]),
  146:         )
  147:         # We have to redo it here because _check_plot_works does two plots,
  148:         # once without an ax kwarg and once with an ax kwarg and the new sharex
  149:         # behaviour does not remove the visibility of the latter axis (as ax is
  150:         # present).  see: https://github.com/pandas-dev/pandas/issues/9737
  151: 
  152:         axes = df.plot(subplots=True, title="blah")
  153:         _check_axes_shape(axes, axes_num=3, layout=(3, 1))
  154:         for ax in axes[:2]:
  155:             _check_visible(ax.xaxis)  # xaxis must be visible for grid
  156:             _check_visible(ax.get_xticklabels(), visible=False)
  157:             _check_visible(ax.get_xticklabels(minor=True), visible=False)
  158:             _check_visible([ax.xaxis.get_label()], visible=False)
  159:         for ax in [axes[2]]:
  160:             _check_visible(ax.xaxis)
  161:             _check_visible(ax.get_xticklabels())
  162:             _check_visible([ax.xaxis.get_label()])
  163:             _check_ticks_props(ax, xrot=0)
  164: 
  165:     @pytest.mark.slow
  166:     def test_plot_title(self):
  167:         df = DataFrame(
  168:             np.random.default_rng(2).random((10, 3)),
  169:             index=list(string.ascii_letters[:10]),
  170:         )
  171:         _check_plot_works(df.plot, title="blah")
  172: 
  173:     @pytest.mark.slow
  174:     def test_plot_multiindex(self):
  175:         tuples = zip(string.ascii_letters[:10], range(10))
  176:         df = DataFrame(
  177:             np.random.default_rng(2).random((10, 3)),
  178:             index=MultiIndex.from_tuples(tuples),
  179:         )
  180:         ax = _check_plot_works(df.plot, use_index=True)
  181:         _check_ticks_props(ax, xrot=0)
  182: 
  183:     @pytest.mark.slow
  184:     def test_plot_multiindex_unicode(self):
  185:         # unicode
  186:         index = MultiIndex.from_tuples(
  187:             [
  188:                 ("\u03b1", 0),
  189:                 ("\u03b1", 1),
  190:                 ("\u03b2", 2),
  191:                 ("\u03b2", 3),
  192:                 ("\u03b3", 4),
  193:                 ("\u03b3", 5),
  194:                 ("\u03b4", 6),
  195:                 ("\u03b4", 7),
  196:             ],
  197:             names=["i0", "i1"],
  198:         )
  199:         columns = MultiIndex.from_tuples(
  200:             [("bar", "\u0394"), ("bar", "\u0395")], names=["c0", "c1"]
  201:         )
  202:         df = DataFrame(
  203:             np.random.default_rng(2).integers(0, 10, (8, 2)),
  204:             columns=columns,
  205:             index=index,
  206:         )
  207:         _check_plot_works(df.plot, title="\u03A3")
  208: 
  209:     @pytest.mark.slow
  210:     @pytest.mark.parametrize("layout", [None, (-1, 1)])
  211:     def test_plot_single_column_bar(self, layout):
  212:         # GH 6951
  213:         # Test with single column
  214:         df = DataFrame({"x": np.random.default_rng(2).random(10)})
  215:         axes = _check_plot_works(df.plot.bar, subplots=True, layout=layout)
  216:         _check_axes_shape(axes, axes_num=1, layout=(1, 1))
  217: 
  218:     @pytest.mark.slow
  219:     def test_plot_passed_ax(self):
  220:         # When ax is supplied and required number of axes is 1,
  221:         # passed ax should be used:
  222:         df = DataFrame({"x": np.random.default_rng(2).random(10)})
  223:         _, ax = mpl.pyplot.subplots()
  224:         axes = df.plot.bar(subplots=True, ax=ax)
  225:         assert len(axes) == 1
  226:         result = ax.axes
  227:         assert result is axes[0]
  228: 
  229:     @pytest.mark.parametrize(
  230:         "cols, x, y",
  231:         [
  232:             [list("ABCDE"), "A", "B"],
  233:             [["A", "B"], "A", "B"],
  234:             [["C", "A"], "C", "A"],
  235:             [["A", "C"], "A", "C"],
  236:             [["B", "C"], "B", "C"],
  237:             [["A", "D"], "A", "D"],
  238:             [["A", "E"], "A", "E"],
  239:         ],
  240:     )
  241:     def test_nullable_int_plot(self, cols, x, y):
  242:         # GH 32073
  243:         dates = ["2008", "2009", None, "2011", "2012"]
  244:         df = DataFrame(
  245:             {
  246:                 "A": [1, 2, 3, 4, 5],
  247:                 "B": [1, 2, 3, 4, 5],
  248:                 "C": np.array([7, 5, np.nan, 3, 2], dtype=object),
  249:                 "D": pd.to_datetime(dates, format="%Y").view("i8"),
  250:                 "E": pd.to_datetime(dates, format="%Y", utc=True).view("i8"),
  251:             }
  252:         )
  253: 
  254:         _check_plot_works(df[cols].plot, x=x, y=y)
  255: 
  256:     @pytest.mark.slow
  257:     @pytest.mark.parametrize("plot", ["line", "bar", "hist", "pie"])
  258:     def test_integer_array_plot_series(self, plot):
  259:         # GH 25587
  260:         arr = pd.array([1, 2, 3, 4], dtype="UInt32")
  261: 
  262:         s = Series(arr)
  263:         _check_plot_works(getattr(s.plot, plot))
  264: 
  265:     @pytest.mark.slow
  266:     @pytest.mark.parametrize(
  267:         "plot, kwargs",
  268:         [
  269:             ["line", {}],
  270:             ["bar", {}],
  271:             ["hist", {}],
  272:             ["pie", {"y": "y"}],
  273:             ["scatter", {"x": "x", "y": "y"}],
  274:             ["hexbin", {"x": "x", "y": "y"}],
  275:         ],
  276:     )
  277:     def test_integer_array_plot_df(self, plot, kwargs):
  278:         # GH 25587
  279:         arr = pd.array([1, 2, 3, 4], dtype="UInt32")
  280:         df = DataFrame({"x": arr, "y": arr})
  281:         _check_plot_works(getattr(df.plot, plot), **kwargs)
  282: 
  283:     def test_nonnumeric_exclude(self):
  284:         df = DataFrame({"A": ["x", "y", "z"], "B": [1, 2, 3]})
  285:         ax = df.plot()
  286:         assert len(ax.get_lines()) == 1  # B was plotted
  287: 
  288:     def test_implicit_label(self):
  289:         df = DataFrame(
  290:             np.random.default_rng(2).standard_normal((10, 3)), columns=["a", "b", "c"]
  291:         )
  292:         ax = df.plot(x="a", y="b")
  293:         _check_text_labels(ax.xaxis.get_label(), "a")
  294: 
  295:     def test_donot_overwrite_index_name(self):
  296:         # GH 8494
  297:         df = DataFrame(
  298:             np.random.default_rng(2).standard_normal((2, 2)), columns=["a", "b"]
  299:         )
  300:         df.index.name = "NAME"
  301:         df.plot(y="b", label="LABEL")
  302:         assert df.index.name == "NAME"
  303: 
  304:     def test_plot_xy(self):
  305:         # columns.inferred_type == 'string'
  306:         df = DataFrame(
  307:             np.random.default_rng(2).standard_normal((5, 4)),
  308:             columns=Index(list("ABCD"), dtype=object),
  309:             index=date_range("2000-01-01", periods=5, freq="B"),
  310:         )
  311:         _check_data(df.plot(x=0, y=1), df.set_index("A")["B"].plot())
  312:         _check_data(df.plot(x=0), df.set_index("A").plot())
  313:         _check_data(df.plot(y=0), df.B.plot())
  314:         _check_data(df.plot(x="A", y="B"), df.set_index("A").B.plot())
  315:         _check_data(df.plot(x="A"), df.set_index("A").plot())
  316:         _check_data(df.plot(y="B"), df.B.plot())
  317: 
  318:     def test_plot_xy_int_cols(self):
  319:         df = DataFrame(
  320:             np.random.default_rng(2).standard_normal((5, 4)),
  321:             columns=Index(list("ABCD"), dtype=object),
  322:             index=date_range("2000-01-01", periods=5, freq="B"),
  323:         )
  324:         # columns.inferred_type == 'integer'
  325:         df.columns = np.arange(1, len(df.columns) + 1)
  326:         _check_data(df.plot(x=1, y=2), df.set_index(1)[2].plot())
  327:         _check_data(df.plot(x=1), df.set_index(1).plot())
  328:         _check_data(df.plot(y=1), df[1].plot())
  329: 
  330:     def test_plot_xy_figsize_and_title(self):
  331:         df = DataFrame(
  332:             np.random.default_rng(2).standard_normal((5, 4)),
  333:             columns=Index(list("ABCD"), dtype=object),
  334:             index=date_range("2000-01-01", periods=5, freq="B"),
  335:         )
  336:         # figsize and title
  337:         ax = df.plot(x=1, y=2, title="Test", figsize=(16, 8))
  338:         _check_text_labels(ax.title, "Test")
  339:         _check_axes_shape(ax, axes_num=1, layout=(1, 1), figsize=(16.0, 8.0))
  340: 
  341:         # columns.inferred_type == 'mixed'
  342:         # TODO add MultiIndex test
  343: 
  344:     @pytest.mark.parametrize(
  345:         "input_log, expected_log", [(True, "log"), ("sym", "symlog")]
  346:     )
  347:     def test_logscales(self, input_log, expected_log):
  348:         df = DataFrame({"a": np.arange(100)}, index=np.arange(100))
  349: 
  350:         ax = df.plot(logy=input_log)
  351:         _check_ax_scales(ax, yaxis=expected_log)
  352:         assert ax.get_yscale() == expected_log
  353: 
  354:         ax = df.plot(logx=input_log)
  355:         _check_ax_scales(ax, xaxis=expected_log)
  356:         assert ax.get_xscale() == expected_log
  357: 
  358:         ax = df.plot(loglog=input_log)
  359:         _check_ax_scales(ax, xaxis=expected_log, yaxis=expected_log)
  360:         assert ax.get_xscale() == expected_log
  361:         assert ax.get_yscale() == expected_log
  362: 
  363:     @pytest.mark.parametrize("input_param", ["logx", "logy", "loglog"])
  364:     def test_invalid_logscale(self, input_param):
  365:         # GH: 24867
  366:         df = DataFrame({"a": np.arange(100)}, index=np.arange(100))
  367: 
  368:         msg = f"keyword '{input_param}' should be bool, None, or 'sym', not 'sm'"
  369:         with pytest.raises(ValueError, match=msg):
  370:             df.plot(**{input_param: "sm"})
  371: 
  372:         msg = f"PiePlot ignores the '{input_param}' keyword"
  373:         with tm.assert_produces_warning(UserWarning, match=msg):
  374:             df.plot.pie(subplots=True, **{input_param: True})
  375: 
  376:     def test_xcompat(self):
  377:         df = DataFrame(
  378:             np.random.default_rng(2).standard_normal((10, 4)),
  379:             columns=Index(list("ABCD"), dtype=object),
  380:             index=date_range("2000-01-01", periods=10, freq="B"),
  381:         )
  382:         ax = df.plot(x_compat=True)
  383:         lines = ax.get_lines()
  384:         assert not isinstance(lines[0].get_xdata(), PeriodIndex)
  385:         _check_ticks_props(ax, xrot=30)
  386: 
  387:     def test_xcompat_plot_params(self):
  388:         df = DataFrame(
  389:             np.random.default_rng(2).standard_normal((10, 4)),
  390:             columns=Index(list("ABCD"), dtype=object),
  391:             index=date_range("2000-01-01", periods=10, freq="B"),
  392:         )
  393:         plotting.plot_params["xaxis.compat"] = True
  394:         ax = df.plot()
  395:         lines = ax.get_lines()
  396:         assert not isinstance(lines[0].get_xdata(), PeriodIndex)
  397:         _check_ticks_props(ax, xrot=30)
  398: 
  399:     def test_xcompat_plot_params_x_compat(self):
  400:         df = DataFrame(
  401:             np.random.default_rng(2).standard_normal((10, 4)),
  402:             columns=Index(list("ABCD"), dtype=object),
  403:             index=date_range("2000-01-01", periods=10, freq="B"),
  404:         )
  405:         plotting.plot_params["x_compat"] = False
  406: 
  407:         ax = df.plot()
  408:         lines = ax.get_lines()
  409:         assert not isinstance(lines[0].get_xdata(), PeriodIndex)
  410:         msg = r"PeriodDtype\[B\] is deprecated"
  411:         with tm.assert_produces_warning(FutureWarning, match=msg):
  412:             assert isinstance(PeriodIndex(lines[0].get_xdata()), PeriodIndex)
  413: 
  414:     def test_xcompat_plot_params_context_manager(self):
  415:         df = DataFrame(
  416:             np.random.default_rng(2).standard_normal((10, 4)),
  417:             columns=Index(list("ABCD"), dtype=object),
  418:             index=date_range("2000-01-01", periods=10, freq="B"),
  419:         )
  420:         # useful if you're plotting a bunch together
  421:         with plotting.plot_params.use("x_compat", True):
  422:             ax = df.plot()
  423:             lines = ax.get_lines()
  424:             assert not isinstance(lines[0].get_xdata(), PeriodIndex)
  425:             _check_ticks_props(ax, xrot=30)
  426: 
  427:     def test_xcompat_plot_period(self):
  428:         df = DataFrame(
  429:             np.random.default_rng(2).standard_normal((10, 4)),
  430:             columns=Index(list("ABCD"), dtype=object),
  431:             index=date_range("2000-01-01", periods=10, freq="B"),
  432:         )
  433:         ax = df.plot()
  434:         lines = ax.get_lines()
  435:         assert not isinstance(lines[0].get_xdata(), PeriodIndex)
  436:         msg = r"PeriodDtype\[B\] is deprecated "
  437:         with tm.assert_produces_warning(FutureWarning, match=msg):
  438:             assert isinstance(PeriodIndex(lines[0].get_xdata()), PeriodIndex)
  439:         _check_ticks_props(ax, xrot=0)
  440: 
  441:     def test_period_compat(self):
  442:         # GH 9012
  443:         # period-array conversions
  444:         df = DataFrame(
  445:             np.random.default_rng(2).random((21, 2)),
  446:             index=bdate_range(datetime(2000, 1, 1), datetime(2000, 1, 31)),
  447:             columns=["a", "b"],
  448:         )
  449: 
  450:         df.plot()
  451:         mpl.pyplot.axhline(y=0)
  452: 
  453:     @pytest.mark.parametrize("index_dtype", [np.int64, np.float64])
  454:     def test_unsorted_index(self, index_dtype):
  455:         df = DataFrame(
  456:             {"y": np.arange(100)},
  457:             index=Index(np.arange(99, -1, -1), dtype=index_dtype),
  458:             dtype=np.int64,
  459:         )
  460:         ax = df.plot()
  461:         lines = ax.get_lines()[0]
  462:         rs = lines.get_xydata()
  463:         rs = Series(rs[:, 1], rs[:, 0], dtype=np.int64, name="y")
  464:         tm.assert_series_equal(rs, df.y, check_index_type=False)
  465: 
  466:     @pytest.mark.parametrize(
  467:         "df",
  468:         [
  469:             DataFrame({"y": [0.0, 1.0, 2.0, 3.0]}, index=[1.0, 0.0, 3.0, 2.0]),
  470:             DataFrame(
  471:                 {"y": [0.0, 1.0, np.nan, 3.0, 4.0, 5.0, 6.0]},
  472:                 index=[1.0, 0.0, 3.0, 2.0, np.nan, 3.0, 2.0],
  473:             ),
  474:         ],
  475:     )
  476:     def test_unsorted_index_lims(self, df):
  477:         ax = df.plot()
  478:         xmin, xmax = ax.get_xlim()
  479:         lines = ax.get_lines()
  480:         assert xmin <= np.nanmin(lines[0].get_data()[0])
  481:         assert xmax >= np.nanmax(lines[0].get_data()[0])
  482: 
  483:     def test_unsorted_index_lims_x_y(self):
  484:         df = DataFrame({"y": [0.0, 1.0, 2.0, 3.0], "z": [91.0, 90.0, 93.0, 92.0]})
  485:         ax = df.plot(x="z", y="y")
  486:         xmin, xmax = ax.get_xlim()
  487:         lines = ax.get_lines()
  488:         assert xmin <= np.nanmin(lines[0].get_data()[0])
  489:         assert xmax >= np.nanmax(lines[0].get_data()[0])
  490: 
  491:     def test_negative_log(self):
  492:         df = -DataFrame(
  493:             np.random.default_rng(2).random((6, 4)),
  494:             index=list(string.ascii_letters[:6]),
  495:             columns=["x", "y", "z", "four"],
  496:         )
  497:         msg = "Log-y scales are not supported in area plot"
  498:         with pytest.raises(ValueError, match=msg):
  499:             df.plot.area(logy=True)
  500:         with pytest.raises(ValueError, match=msg):
  501:             df.plot.area(loglog=True)
  502: 
  503:     def _compare_stacked_y_cood(self, normal_lines, stacked_lines):
  504:         base = np.zeros(len(normal_lines[0].get_data()[1]))
  505:         for nl, sl in zip(normal_lines, stacked_lines):
  506:             base += nl.get_data()[1]  # get y coordinates
  507:             sy = sl.get_data()[1]
  508:             tm.assert_numpy_array_equal(base, sy)
  509: 
  510:     @pytest.mark.parametrize("kind", ["line", "area"])
  511:     @pytest.mark.parametrize("mult", [1, -1])
  512:     def test_line_area_stacked(self, kind, mult):
  513:         df = mult * DataFrame(
  514:             np.random.default_rng(2).random((6, 4)), columns=["w", "x", "y", "z"]
  515:         )
  516: 
  517:         ax1 = _check_plot_works(df.plot, kind=kind, stacked=False)
  518:         ax2 = _check_plot_works(df.plot, kind=kind, stacked=True)
  519:         self._compare_stacked_y_cood(ax1.lines, ax2.lines)
  520: 
  521:     @pytest.mark.parametrize("kind", ["line", "area"])
  522:     def test_line_area_stacked_sep_df(self, kind):
  523:         # each column has either positive or negative value
  524:         sep_df = DataFrame(
  525:             {
  526:                 "w": np.random.default_rng(2).random(6),
  527:                 "x": np.random.default_rng(2).random(6),
  528:                 "y": -np.random.default_rng(2).random(6),
  529:                 "z": -np.random.default_rng(2).random(6),
  530:             }
  531:         )
  532:         ax1 = _check_plot_works(sep_df.plot, kind=kind, stacked=False)
  533:         ax2 = _check_plot_works(sep_df.plot, kind=kind, stacked=True)
  534:         self._compare_stacked_y_cood(ax1.lines[:2], ax2.lines[:2])
  535:         self._compare_stacked_y_cood(ax1.lines[2:], ax2.lines[2:])
  536: 
  537:     def test_line_area_stacked_mixed(self):
  538:         mixed_df = DataFrame(
  539:             np.random.default_rng(2).standard_normal((6, 4)),
  540:             index=list(string.ascii_letters[:6]),
  541:             columns=["w", "x", "y", "z"],
  542:         )
  543:         _check_plot_works(mixed_df.plot, stacked=False)
  544: 
  545:         msg = (
  546:             "When stacked is True, each column must be either all positive or "
  547:             "all negative. Column 'w' contains both positive and negative "
  548:             "values"
  549:         )
  550:         with pytest.raises(ValueError, match=msg):
  551:             mixed_df.plot(stacked=True)
  552: 
  553:     @pytest.mark.parametrize("kind", ["line", "area"])
  554:     def test_line_area_stacked_positive_idx(self, kind):
  555:         df = DataFrame(
  556:             np.random.default_rng(2).random((6, 4)), columns=["w", "x", "y", "z"]
  557:         )
  558:         # Use an index with strictly positive values, preventing
  559:         #  matplotlib from warning about ignoring xlim
  560:         df2 = df.set_index(df.index + 1)
  561:         _check_plot_works(df2.plot, kind=kind, logx=True, stacked=True)
  562: 
  563:     @pytest.mark.parametrize(
  564:         "idx", [range(4), date_range("2023-01-1", freq="D", periods=4)]
  565:     )
  566:     def test_line_area_nan_df(self, idx):
  567:         values1 = [1, 2, np.nan, 3]
  568:         values2 = [3, np.nan, 2, 1]
  569:         df = DataFrame({"a": values1, "b": values2}, index=idx)
  570: 
  571:         ax = _check_plot_works(df.plot)
  572:         masked1 = ax.lines[0].get_ydata()
  573:         masked2 = ax.lines[1].get_ydata()
  574:         # remove nan for comparison purpose
  575: 
  576:         exp = np.array([1, 2, 3], dtype=np.float64)
  577:         tm.assert_numpy_array_equal(np.delete(masked1.data, 2), exp)
  578: 
  579:         exp = np.array([3, 2, 1], dtype=np.float64)
  580:         tm.assert_numpy_array_equal(np.delete(masked2.data, 1), exp)
  581:         tm.assert_numpy_array_equal(masked1.mask, np.array([False, False, True, False]))
  582:         tm.assert_numpy_array_equal(masked2.mask, np.array([False, True, False, False]))
  583: 
  584:     @pytest.mark.parametrize(
  585:         "idx", [range(4), date_range("2023-01-1", freq="D", periods=4)]
  586:     )
  587:     def test_line_area_nan_df_stacked(self, idx):
  588:         values1 = [1, 2, np.nan, 3]
  589:         values2 = [3, np.nan, 2, 1]
  590:         df = DataFrame({"a": values1, "b": values2}, index=idx)
  591: 
  592:         expected1 = np.array([1, 2, 0, 3], dtype=np.float64)
  593:         expected2 = np.array([3, 0, 2, 1], dtype=np.float64)
  594: 
  595:         ax = _check_plot_works(df.plot, stacked=True)
  596:         tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected1)
  597:         tm.assert_numpy_array_equal(ax.lines[1].get_ydata(), expected1 + expected2)
  598: 
  599:     @pytest.mark.parametrize(
  600:         "idx", [range(4), date_range("2023-01-1", freq="D", periods=4)]
  601:     )
  602:     @pytest.mark.parametrize("kwargs", [{}, {"stacked": False}])
  603:     def test_line_area_nan_df_stacked_area(self, idx, kwargs):
  604:         values1 = [1, 2, np.nan, 3]
  605:         values2 = [3, np.nan, 2, 1]
  606:         df = DataFrame({"a": values1, "b": values2}, index=idx)
  607: 
  608:         expected1 = np.array([1, 2, 0, 3], dtype=np.float64)
  609:         expected2 = np.array([3, 0, 2, 1], dtype=np.float64)
  610: 
  611:         ax = _check_plot_works(df.plot.area, **kwargs)
  612:         tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected1)
  613:         if kwargs:
  614:             tm.assert_numpy_array_equal(ax.lines[1].get_ydata(), expected2)
  615:         else:
  616:             tm.assert_numpy_array_equal(ax.lines[1].get_ydata(), expected1 + expected2)
  617: 
  618:         ax = _check_plot_works(df.plot.area, stacked=False)
  619:         tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected1)
  620:         tm.assert_numpy_array_equal(ax.lines[1].get_ydata(), expected2)
  621: 
  622:     @pytest.mark.parametrize("kwargs", [{}, {"secondary_y": True}])
  623:     def test_line_lim(self, kwargs):
  624:         df = DataFrame(np.random.default_rng(2).random((6, 3)), columns=["x", "y", "z"])
  625:         ax = df.plot(**kwargs)
  626:         xmin, xmax = ax.get_xlim()
  627:         lines = ax.get_lines()
  628:         assert xmin <= lines[0].get_data()[0][0]
  629:         assert xmax >= lines[0].get_data()[0][-1]
  630: 
  631:     def test_line_lim_subplots(self):
  632:         df = DataFrame(np.random.default_rng(2).random((6, 3)), columns=["x", "y", "z"])
  633:         axes = df.plot(secondary_y=True, subplots=True)
  634:         _check_axes_shape(axes, axes_num=3, layout=(3, 1))
  635:         for ax in axes:
  636:             assert hasattr(ax, "left_ax")
  637:             assert not hasattr(ax, "right_ax")
  638:             xmin, xmax = ax.get_xlim()
  639:             lines = ax.get_lines()
  640:             assert xmin <= lines[0].get_data()[0][0]
  641:             assert xmax >= lines[0].get_data()[0][-1]
  642: 
  643:     @pytest.mark.xfail(
  644:         strict=False,
  645:         reason="2020-12-01 this has been failing periodically on the "
  646:         "ymin==0 assertion for a week or so.",
  647:     )
  648:     @pytest.mark.parametrize("stacked", [True, False])
  649:     def test_area_lim(self, stacked):
  650:         df = DataFrame(
  651:             np.random.default_rng(2).random((6, 4)), columns=["x", "y", "z", "four"]
  652:         )
  653: 
  654:         neg_df = -df
  655: 
  656:         ax = _check_plot_works(df.plot.area, stacked=stacked)
  657:         xmin, xmax = ax.get_xlim()
  658:         ymin, ymax = ax.get_ylim()
  659:         lines = ax.get_lines()
  660:         assert xmin <= lines[0].get_data()[0][0]
  661:         assert xmax >= lines[0].get_data()[0][-1]
  662:         assert ymin == 0
  663: 
  664:         ax = _check_plot_works(neg_df.plot.area, stacked=stacked)
  665:         ymin, ymax = ax.get_ylim()
  666:         assert ymax == 0
  667: 
  668:     def test_area_sharey_dont_overwrite(self):
  669:         # GH37942
  670:         df = DataFrame(np.random.default_rng(2).random((4, 2)), columns=["x", "y"])
  671:         fig, (ax1, ax2) = mpl.pyplot.subplots(1, 2, sharey=True)
  672: 
  673:         df.plot(ax=ax1, kind="area")
  674:         df.plot(ax=ax2, kind="area")
  675: 
  676:         assert get_y_axis(ax1).joined(ax1, ax2)
  677:         assert get_y_axis(ax2).joined(ax1, ax2)
  678: 
  679:     @pytest.mark.parametrize("stacked", [True, False])
  680:     def test_bar_linewidth(self, stacked):
  681:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)))
  682: 
  683:         ax = df.plot.bar(stacked=stacked, linewidth=2)
  684:         for r in ax.patches:
  685:             assert r.get_linewidth() == 2
  686: 
  687:     def test_bar_linewidth_subplots(self):
  688:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)))
  689:         # subplots
  690:         axes = df.plot.bar(linewidth=2, subplots=True)
  691:         _check_axes_shape(axes, axes_num=5, layout=(5, 1))
  692:         for ax in axes:
  693:             for r in ax.patches:
  694:                 assert r.get_linewidth() == 2
  695: 
  696:     @pytest.mark.parametrize(
  697:         "meth, dim", [("bar", "get_width"), ("barh", "get_height")]
  698:     )
  699:     @pytest.mark.parametrize("stacked", [True, False])
  700:     def test_bar_barwidth(self, meth, dim, stacked):
  701:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)))
  702: 
  703:         width = 0.9
  704: 
  705:         ax = getattr(df.plot, meth)(stacked=stacked, width=width)
  706:         for r in ax.patches:
  707:             if not stacked:
  708:                 assert getattr(r, dim)() == width / len(df.columns)
  709:             else:
  710:                 assert getattr(r, dim)() == width
  711: 
  712:     @pytest.mark.parametrize(
  713:         "meth, dim", [("bar", "get_width"), ("barh", "get_height")]
  714:     )
  715:     def test_barh_barwidth_subplots(self, meth, dim):
  716:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)))
  717: 
  718:         width = 0.9
  719: 
  720:         axes = getattr(df.plot, meth)(width=width, subplots=True)
  721:         for ax in axes:
  722:             for r in ax.patches:
  723:                 assert getattr(r, dim)() == width
  724: 
  725:     def test_bar_bottom_left_bottom(self):
  726:         df = DataFrame(np.random.default_rng(2).random((5, 5)))
  727:         ax = df.plot.bar(stacked=False, bottom=1)
  728:         result = [p.get_y() for p in ax.patches]
  729:         assert result == [1] * 25
  730: 
  731:         ax = df.plot.bar(stacked=True, bottom=[-1, -2, -3, -4, -5])
  732:         result = [p.get_y() for p in ax.patches[:5]]
  733:         assert result == [-1, -2, -3, -4, -5]
  734: 
  735:     def test_bar_bottom_left_left(self):
  736:         df = DataFrame(np.random.default_rng(2).random((5, 5)))
  737:         ax = df.plot.barh(stacked=False, left=np.array([1, 1, 1, 1, 1]))
  738:         result = [p.get_x() for p in ax.patches]
  739:         assert result == [1] * 25
  740: 
  741:         ax = df.plot.barh(stacked=True, left=[1, 2, 3, 4, 5])
  742:         result = [p.get_x() for p in ax.patches[:5]]
  743:         assert result == [1, 2, 3, 4, 5]
  744: 
  745:     def test_bar_bottom_left_subplots(self):
  746:         df = DataFrame(np.random.default_rng(2).random((5, 5)))
  747:         axes = df.plot.bar(subplots=True, bottom=-1)
  748:         for ax in axes:
  749:             result = [p.get_y() for p in ax.patches]
  750:             assert result == [-1] * 5
  751: 
  752:         axes = df.plot.barh(subplots=True, left=np.array([1, 1, 1, 1, 1]))
  753:         for ax in axes:
  754:             result = [p.get_x() for p in ax.patches]
  755:             assert result == [1] * 5
  756: 
  757:     def test_bar_nan(self):
  758:         df = DataFrame({"A": [10, np.nan, 20], "B": [5, 10, 20], "C": [1, 2, 3]})
  759:         ax = df.plot.bar()
  760:         expected = [10, 0, 20, 5, 10, 20, 1, 2, 3]
  761:         result = [p.get_height() for p in ax.patches]
  762:         assert result == expected
  763: 
  764:     def test_bar_nan_stacked(self):
  765:         df = DataFrame({"A": [10, np.nan, 20], "B": [5, 10, 20], "C": [1, 2, 3]})
  766:         ax = df.plot.bar(stacked=True)
  767:         expected = [10, 0, 20, 5, 10, 20, 1, 2, 3]
  768:         result = [p.get_height() for p in ax.patches]
  769:         assert result == expected
  770: 
  771:         result = [p.get_y() for p in ax.patches]
  772:         expected = [0.0, 0.0, 0.0, 10.0, 0.0, 20.0, 15.0, 10.0, 40.0]
  773:         assert result == expected
  774: 
  775:     @pytest.mark.parametrize("idx", [Index, pd.CategoricalIndex])
  776:     def test_bar_categorical(self, idx):
  777:         # GH 13019
  778:         df = DataFrame(
  779:             np.random.default_rng(2).standard_normal((6, 5)),
  780:             index=idx(list("ABCDEF")),
  781:             columns=idx(list("abcde")),
  782:         )
  783: 
  784:         ax = df.plot.bar()
  785:         ticks = ax.xaxis.get_ticklocs()
  786:         tm.assert_numpy_array_equal(ticks, np.array([0, 1, 2, 3, 4, 5]))
  787:         assert ax.get_xlim() == (-0.5, 5.5)
  788:         # check left-edge of bars
  789:         assert ax.patches[0].get_x() == -0.25
  790:         assert ax.patches[-1].get_x() == 5.15
  791: 
  792:         ax = df.plot.bar(stacked=True)
  793:         tm.assert_numpy_array_equal(ticks, np.array([0, 1, 2, 3, 4, 5]))
  794:         assert ax.get_xlim() == (-0.5, 5.5)
  795:         assert ax.patches[0].get_x() == -0.25
  796:         assert ax.patches[-1].get_x() == 4.75
  797: 
  798:     @pytest.mark.parametrize("x, y", [("x", "y"), (1, 2)])
  799:     def test_plot_scatter(self, x, y):
  800:         df = DataFrame(
  801:             np.random.default_rng(2).standard_normal((6, 4)),
  802:             index=list(string.ascii_letters[:6]),
  803:             columns=["x", "y", "z", "four"],
  804:         )
  805: 
  806:         _check_plot_works(df.plot.scatter, x=x, y=y)
  807: 
  808:     def test_plot_scatter_error(self):
  809:         df = DataFrame(
  810:             np.random.default_rng(2).standard_normal((6, 4)),
  811:             index=list(string.ascii_letters[:6]),
  812:             columns=["x", "y", "z", "four"],
  813:         )
  814:         msg = re.escape("scatter() missing 1 required positional argument: 'y'")
  815:         with pytest.raises(TypeError, match=msg):
  816:             df.plot.scatter(x="x")
  817:         msg = re.escape("scatter() missing 1 required positional argument: 'x'")
  818:         with pytest.raises(TypeError, match=msg):
  819:             df.plot.scatter(y="y")
  820: 
  821:     def test_plot_scatter_shape(self):
  822:         df = DataFrame(
  823:             np.random.default_rng(2).standard_normal((6, 4)),
  824:             index=list(string.ascii_letters[:6]),
  825:             columns=["x", "y", "z", "four"],
  826:         )
  827:         # GH 6951
  828:         axes = df.plot(x="x", y="y", kind="scatter", subplots=True)
  829:         _check_axes_shape(axes, axes_num=1, layout=(1, 1))
  830: 
  831:     def test_raise_error_on_datetime_time_data(self):
  832:         # GH 8113, datetime.time type is not supported by matplotlib in scatter
  833:         df = DataFrame(np.random.default_rng(2).standard_normal(10), columns=["a"])
  834:         df["dtime"] = date_range(start="2014-01-01", freq="h", periods=10).time
  835:         msg = "must be a string or a (real )?number, not 'datetime.time'"
  836: 
  837:         with pytest.raises(TypeError, match=msg):
  838:             df.plot(kind="scatter", x="dtime", y="a")
  839: 
  840:     @pytest.mark.parametrize("x, y", [("dates", "vals"), (0, 1)])
  841:     def test_scatterplot_datetime_data(self, x, y):
  842:         # GH 30391
  843:         dates = date_range(start=date(2019, 1, 1), periods=12, freq="W")
  844:         vals = np.random.default_rng(2).normal(0, 1, len(dates))
  845:         df = DataFrame({"dates": dates, "vals": vals})
  846: 
  847:         _check_plot_works(df.plot.scatter, x=x, y=y)
  848: 
  849:     @pytest.mark.parametrize(
  850:         "infer_string", [False, pytest.param(True, marks=td.skip_if_no("pyarrow"))]
  851:     )
  852:     @pytest.mark.parametrize("x, y", [("a", "b"), (0, 1)])
  853:     @pytest.mark.parametrize("b_col", [[2, 3, 4], ["a", "b", "c"]])
  854:     def test_scatterplot_object_data(self, b_col, x, y, infer_string):
  855:         # GH 18755
  856:         with option_context("future.infer_string", infer_string):
  857:             df = DataFrame({"a": ["A", "B", "C"], "b": b_col})
  858: 
  859:             _check_plot_works(df.plot.scatter, x=x, y=y)
  860: 
  861:     @pytest.mark.parametrize("ordered", [True, False])
  862:     @pytest.mark.parametrize(
  863:         "categories",
  864:         (["setosa", "versicolor", "virginica"], ["versicolor", "virginica", "setosa"]),
  865:     )
  866:     def test_scatterplot_color_by_categorical(self, ordered, categories):
  867:         df = DataFrame(
  868:             [[5.1, 3.5], [4.9, 3.0], [7.0, 3.2], [6.4, 3.2], [5.9, 3.0]],
  869:             columns=["length", "width"],
  870:         )
  871:         df["species"] = pd.Categorical(
  872:             ["setosa", "setosa", "virginica", "virginica", "versicolor"],
  873:             ordered=ordered,
  874:             categories=categories,
  875:         )
  876:         ax = df.plot.scatter(x=0, y=1, c="species")
  877:         (colorbar_collection,) = ax.collections
  878:         colorbar = colorbar_collection.colorbar
  879: 
  880:         expected_ticks = np.array([0.5, 1.5, 2.5])
  881:         result_ticks = colorbar.get_ticks()
  882:         tm.assert_numpy_array_equal(result_ticks, expected_ticks)
  883: 
  884:         expected_boundaries = np.array([0.0, 1.0, 2.0, 3.0])
  885:         result_boundaries = colorbar._boundaries
  886:         tm.assert_numpy_array_equal(result_boundaries, expected_boundaries)
  887: 
  888:         expected_yticklabels = categories
  889:         result_yticklabels = [i.get_text() for i in colorbar.ax.get_ymajorticklabels()]
  890:         assert all(i == j for i, j in zip(result_yticklabels, expected_yticklabels))
  891: 
  892:     @pytest.mark.parametrize("x, y", [("x", "y"), ("y", "x"), ("y", "y")])
  893:     def test_plot_scatter_with_categorical_data(self, x, y):
  894:         # after fixing GH 18755, should be able to plot categorical data
  895:         df = DataFrame({"x": [1, 2, 3, 4], "y": pd.Categorical(["a", "b", "a", "c"])})
  896: 
  897:         _check_plot_works(df.plot.scatter, x=x, y=y)
  898: 
  899:     @pytest.mark.parametrize("x, y, c", [("x", "y", "z"), (0, 1, 2)])
  900:     def test_plot_scatter_with_c(self, x, y, c):
  901:         df = DataFrame(
  902:             np.random.default_rng(2).integers(low=0, high=100, size=(6, 4)),
  903:             index=list(string.ascii_letters[:6]),
  904:             columns=["x", "y", "z", "four"],
  905:         )
  906: 
  907:         ax = df.plot.scatter(x=x, y=y, c=c)
  908:         # default to Greys
  909:         assert ax.collections[0].cmap.name == "Greys"
  910: 
  911:         assert ax.collections[0].colorbar.ax.get_ylabel() == "z"
  912: 
  913:     def test_plot_scatter_with_c_props(self):
  914:         df = DataFrame(
  915:             np.random.default_rng(2).integers(low=0, high=100, size=(6, 4)),
  916:             index=list(string.ascii_letters[:6]),
  917:             columns=["x", "y", "z", "four"],
  918:         )
  919:         cm = "cubehelix"
  920:         ax = df.plot.scatter(x="x", y="y", c="z", colormap=cm)
  921:         assert ax.collections[0].cmap.name == cm
  922: 
  923:         # verify turning off colorbar works
  924:         ax = df.plot.scatter(x="x", y="y", c="z", colorbar=False)
  925:         assert ax.collections[0].colorbar is None
  926: 
  927:         # verify that we can still plot a solid color
  928:         ax = df.plot.scatter(x=0, y=1, c="red")
  929:         assert ax.collections[0].colorbar is None
  930:         _check_colors(ax.collections, facecolors=["r"])
  931: 
  932:     def test_plot_scatter_with_c_array(self):
  933:         # Ensure that we can pass an np.array straight through to matplotlib,
  934:         # this functionality was accidentally removed previously.
  935:         # See https://github.com/pandas-dev/pandas/issues/8852 for bug report
  936:         #
  937:         # Exercise colormap path and non-colormap path as they are independent
  938:         #
  939:         df = DataFrame({"A": [1, 2], "B": [3, 4]})
  940:         red_rgba = [1.0, 0.0, 0.0, 1.0]
  941:         green_rgba = [0.0, 1.0, 0.0, 1.0]
  942:         rgba_array = np.array([red_rgba, green_rgba])
  943:         ax = df.plot.scatter(x="A", y="B", c=rgba_array)
  944:         # expect the face colors of the points in the non-colormap path to be
  945:         # identical to the values we supplied, normally we'd be on shaky ground
  946:         # comparing floats for equality but here we expect them to be
  947:         # identical.
  948:         tm.assert_numpy_array_equal(ax.collections[0].get_facecolor(), rgba_array)
  949:         # we don't test the colors of the faces in this next plot because they
  950:         # are dependent on the spring colormap, which may change its colors
  951:         # later.
  952:         float_array = np.array([0.0, 1.0])
  953:         df.plot.scatter(x="A", y="B", c=float_array, cmap="spring")
  954: 
  955:     def test_plot_scatter_with_s(self):
  956:         # this refers to GH 32904
  957:         df = DataFrame(
  958:             np.random.default_rng(2).random((10, 3)) * 100, columns=["a", "b", "c"]
  959:         )
  960: 
  961:         ax = df.plot.scatter(x="a", y="b", s="c")
  962:         tm.assert_numpy_array_equal(df["c"].values, right=ax.collections[0].get_sizes())
  963: 
  964:     def test_plot_scatter_with_norm(self):
  965:         # added while fixing GH 45809
  966:         df = DataFrame(
  967:             np.random.default_rng(2).random((10, 3)) * 100, columns=["a", "b", "c"]
  968:         )
  969:         norm = mpl.colors.LogNorm()
  970:         ax = df.plot.scatter(x="a", y="b", c="c", norm=norm)
  971:         assert ax.collections[0].norm is norm
  972: 
  973:     def test_plot_scatter_without_norm(self):
  974:         # added while fixing GH 45809
  975:         df = DataFrame(
  976:             np.random.default_rng(2).random((10, 3)) * 100, columns=["a", "b", "c"]
  977:         )
  978:         ax = df.plot.scatter(x="a", y="b", c="c")
  979:         plot_norm = ax.collections[0].norm
  980:         color_min_max = (df.c.min(), df.c.max())
  981:         default_norm = mpl.colors.Normalize(*color_min_max)
  982:         for value in df.c:
  983:             assert plot_norm(value) == default_norm(value)
  984: 
  985:     @pytest.mark.slow
  986:     @pytest.mark.parametrize(
  987:         "kwargs",
  988:         [
  989:             {},
  990:             {"legend": False},
  991:             {"default_axes": True, "subplots": True},
  992:             {"stacked": True},
  993:         ],
  994:     )
  995:     def test_plot_bar(self, kwargs):
  996:         df = DataFrame(
  997:             np.random.default_rng(2).standard_normal((6, 4)),
  998:             index=list(string.ascii_letters[:6]),
  999:             columns=["one", "two", "three", "four"],
 1000:         )
 1001: 
 1002:         _check_plot_works(df.plot.bar, **kwargs)
 1003: 
 1004:     @pytest.mark.slow
 1005:     def test_plot_bar_int_col(self):
 1006:         df = DataFrame(
 1007:             np.random.default_rng(2).standard_normal((10, 15)),
 1008:             index=list(string.ascii_letters[:10]),
 1009:             columns=range(15),
 1010:         )
 1011:         _check_plot_works(df.plot.bar)
 1012: 
 1013:     @pytest.mark.slow
 1014:     def test_plot_bar_ticks(self):
 1015:         df = DataFrame({"a": [0, 1], "b": [1, 0]})
 1016:         ax = _check_plot_works(df.plot.bar)
 1017:         _check_ticks_props(ax, xrot=90)
 1018: 
 1019:         ax = df.plot.bar(rot=35, fontsize=10)
 1020:         _check_ticks_props(ax, xrot=35, xlabelsize=10, ylabelsize=10)
 1021: 
 1022:     @pytest.mark.slow
 1023:     def test_plot_barh_ticks(self):
 1024:         df = DataFrame({"a": [0, 1], "b": [1, 0]})
 1025:         ax = _check_plot_works(df.plot.barh)
 1026:         _check_ticks_props(ax, yrot=0)
 1027: 
 1028:         ax = df.plot.barh(rot=55, fontsize=11)
 1029:         _check_ticks_props(ax, yrot=55, ylabelsize=11, xlabelsize=11)
 1030: 
 1031:     def test_boxplot(self, hist_df):
 1032:         df = hist_df
 1033:         numeric_cols = df._get_numeric_data().columns
 1034:         labels = [pprint_thing(c) for c in numeric_cols]
 1035: 
 1036:         ax = _check_plot_works(df.plot.box)
 1037:         _check_text_labels(ax.get_xticklabels(), labels)
 1038:         tm.assert_numpy_array_equal(
 1039:             ax.xaxis.get_ticklocs(), np.arange(1, len(numeric_cols) + 1)
 1040:         )
 1041:         assert len(ax.lines) == 7 * len(numeric_cols)
 1042: 
 1043:     def test_boxplot_series(self, hist_df):
 1044:         df = hist_df
 1045:         series = df["height"]
 1046:         axes = series.plot.box(rot=40)
 1047:         _check_ticks_props(axes, xrot=40, yrot=0)
 1048: 
 1049:         _check_plot_works(series.plot.box)
 1050: 
 1051:     def test_boxplot_series_positions(self, hist_df):
 1052:         df = hist_df
 1053:         positions = np.array([1, 6, 7])
 1054:         ax = df.plot.box(positions=positions)
 1055:         numeric_cols = df._get_numeric_data().columns
 1056:         labels = [pprint_thing(c) for c in numeric_cols]
 1057:         _check_text_labels(ax.get_xticklabels(), labels)
 1058:         tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), positions)
 1059:         assert len(ax.lines) == 7 * len(numeric_cols)
 1060: 
 1061:     def test_boxplot_vertical(self, hist_df):
 1062:         df = hist_df
 1063:         numeric_cols = df._get_numeric_data().columns
 1064:         labels = [pprint_thing(c) for c in numeric_cols]
 1065: 
 1066:         # if horizontal, yticklabels are rotated
 1067:         ax = df.plot.box(rot=50, fontsize=8, vert=False)
 1068:         _check_ticks_props(ax, xrot=0, yrot=50, ylabelsize=8)
 1069:         _check_text_labels(ax.get_yticklabels(), labels)
 1070:         assert len(ax.lines) == 7 * len(numeric_cols)
 1071: 
 1072:     @pytest.mark.filterwarnings("ignore:Attempt:UserWarning")
 1073:     def test_boxplot_vertical_subplots(self, hist_df):
 1074:         df = hist_df
 1075:         numeric_cols = df._get_numeric_data().columns
 1076:         labels = [pprint_thing(c) for c in numeric_cols]
 1077:         axes = _check_plot_works(
 1078:             df.plot.box,
 1079:             default_axes=True,
 1080:             subplots=True,
 1081:             vert=False,
 1082:             logx=True,
 1083:         )
 1084:         _check_axes_shape(axes, axes_num=3, layout=(1, 3))
 1085:         _check_ax_scales(axes, xaxis="log")
 1086:         for ax, label in zip(axes, labels):
 1087:             _check_text_labels(ax.get_yticklabels(), [label])
 1088:             assert len(ax.lines) == 7
 1089: 
 1090:     def test_boxplot_vertical_positions(self, hist_df):
 1091:         df = hist_df
 1092:         numeric_cols = df._get_numeric_data().columns
 1093:         labels = [pprint_thing(c) for c in numeric_cols]
 1094:         positions = np.array([3, 2, 8])
 1095:         ax = df.plot.box(positions=positions, vert=False)
 1096:         _check_text_labels(ax.get_yticklabels(), labels)
 1097:         tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), positions)
 1098:         assert len(ax.lines) == 7 * len(numeric_cols)
 1099: 
 1100:     def test_boxplot_return_type_invalid(self):
 1101:         df = DataFrame(
 1102:             np.random.default_rng(2).standard_normal((6, 4)),
 1103:             index=list(string.ascii_letters[:6]),
 1104:             columns=["one", "two", "three", "four"],
 1105:         )
 1106:         msg = "return_type must be {None, 'axes', 'dict', 'both'}"
 1107:         with pytest.raises(ValueError, match=msg):
 1108:             df.plot.box(return_type="not_a_type")
 1109: 
 1110:     @pytest.mark.parametrize("return_type", ["dict", "axes", "both"])
 1111:     def test_boxplot_return_type_invalid_type(self, return_type):
 1112:         df = DataFrame(
 1113:             np.random.default_rng(2).standard_normal((6, 4)),
 1114:             index=list(string.ascii_letters[:6]),
 1115:             columns=["one", "two", "three", "four"],
 1116:         )
 1117:         result = df.plot.box(return_type=return_type)
 1118:         _check_box_return_type(result, return_type)
 1119: 
 1120:     def test_kde_df(self):
 1121:         pytest.importorskip("scipy")
 1122:         df = DataFrame(np.random.default_rng(2).standard_normal((100, 4)))
 1123:         ax = _check_plot_works(df.plot, kind="kde")
 1124:         expected = [pprint_thing(c) for c in df.columns]
 1125:         _check_legend_labels(ax, labels=expected)
 1126:         _check_ticks_props(ax, xrot=0)
 1127: 
 1128:     def test_kde_df_rot(self):
 1129:         pytest.importorskip("scipy")
 1130:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))
 1131:         ax = df.plot(kind="kde", rot=20, fontsize=5)
 1132:         _check_ticks_props(ax, xrot=20, xlabelsize=5, ylabelsize=5)
 1133: 
 1134:     def test_kde_df_subplots(self):
 1135:         pytest.importorskip("scipy")
 1136:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))
 1137:         axes = _check_plot_works(
 1138:             df.plot,
 1139:             default_axes=True,
 1140:             kind="kde",
 1141:             subplots=True,
 1142:         )
 1143:         _check_axes_shape(axes, axes_num=4, layout=(4, 1))
 1144: 
 1145:     def test_kde_df_logy(self):
 1146:         pytest.importorskip("scipy")
 1147:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))
 1148:         axes = df.plot(kind="kde", logy=True, subplots=True)
 1149:         _check_ax_scales(axes, yaxis="log")
 1150: 
 1151:     def test_kde_missing_vals(self):
 1152:         pytest.importorskip("scipy")
 1153:         df = DataFrame(np.random.default_rng(2).uniform(size=(100, 4)))
 1154:         df.loc[0, 0] = np.nan
 1155:         _check_plot_works(df.plot, kind="kde")
 1156: 
 1157:     def test_hist_df(self):
 1158:         df = DataFrame(np.random.default_rng(2).standard_normal((100, 4)))
 1159: 
 1160:         ax = _check_plot_works(df.plot.hist)
 1161:         expected = [pprint_thing(c) for c in df.columns]
 1162:         _check_legend_labels(ax, labels=expected)
 1163: 
 1164:         axes = _check_plot_works(
 1165:             df.plot.hist,
 1166:             default_axes=True,
 1167:             subplots=True,
 1168:             logy=True,
 1169:         )
 1170:         _check_axes_shape(axes, axes_num=4, layout=(4, 1))
 1171:         _check_ax_scales(axes, yaxis="log")
 1172: 
 1173:     def test_hist_df_series(self):
 1174:         series = Series(np.random.default_rng(2).random(10))
 1175:         axes = series.plot.hist(rot=40)
 1176:         _check_ticks_props(axes, xrot=40, yrot=0)
 1177: 
 1178:     def test_hist_df_series_cumulative_density(self):
 1179:         from matplotlib.patches import Rectangle
 1180: 
 1181:         series = Series(np.random.default_rng(2).random(10))
 1182:         ax = series.plot.hist(cumulative=True, bins=4, density=True)
 1183:         # height of last bin (index 5) must be 1.0
 1184:         rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
 1185:         tm.assert_almost_equal(rects[-1].get_height(), 1.0)
 1186: 
 1187:     def test_hist_df_series_cumulative(self):
 1188:         from matplotlib.patches import Rectangle
 1189: 
 1190:         series = Series(np.random.default_rng(2).random(10))
 1191:         ax = series.plot.hist(cumulative=True, bins=4)
 1192:         rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
 1193: 
 1194:         tm.assert_almost_equal(rects[-2].get_height(), 10.0)
 1195: 
 1196:     def test_hist_df_orientation(self):
 1197:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))
 1198:         # if horizontal, yticklabels are rotated
 1199:         axes = df.plot.hist(rot=50, fontsize=8, orientation="horizontal")
 1200:         _check_ticks_props(axes, xrot=0, yrot=50, ylabelsize=8)
 1201: 
 1202:     @pytest.mark.parametrize(
 1203:         "weights", [0.1 * np.ones(shape=(100,)), 0.1 * np.ones(shape=(100, 2))]
 1204:     )
 1205:     def test_hist_weights(self, weights):
 1206:         # GH 33173
 1207: 
 1208:         df = DataFrame(
 1209:             dict(zip(["A", "B"], np.random.default_rng(2).standard_normal((2, 100))))
 1210:         )
 1211: 
 1212:         ax1 = _check_plot_works(df.plot, kind="hist", weights=weights)
 1213:         ax2 = _check_plot_works(df.plot, kind="hist")
 1214: 
 1215:         patch_height_with_weights = [patch.get_height() for patch in ax1.patches]
 1216: 
 1217:         # original heights with no weights, and we manually multiply with example
 1218:         # weights, so after multiplication, they should be almost same
 1219:         expected_patch_height = [0.1 * patch.get_height() for patch in ax2.patches]
 1220: 
 1221:         tm.assert_almost_equal(patch_height_with_weights, expected_patch_height)
 1222: 
 1223:     def _check_box_coord(
 1224:         self,
 1225:         patches,
 1226:         expected_y=None,
 1227:         expected_h=None,
 1228:         expected_x=None,
 1229:         expected_w=None,
 1230:     ):
 1231:         result_y = np.array([p.get_y() for p in patches])
 1232:         result_height = np.array([p.get_height() for p in patches])
 1233:         result_x = np.array([p.get_x() for p in patches])
 1234:         result_width = np.array([p.get_width() for p in patches])
 1235:         # dtype is depending on above values, no need to check
 1236: 
 1237:         if expected_y is not None:
 1238:             tm.assert_numpy_array_equal(result_y, expected_y, check_dtype=False)
 1239:         if expected_h is not None:
 1240:             tm.assert_numpy_array_equal(result_height, expected_h, check_dtype=False)
 1241:         if expected_x is not None:
 1242:             tm.assert_numpy_array_equal(result_x, expected_x, check_dtype=False)
 1243:         if expected_w is not None:
 1244:             tm.assert_numpy_array_equal(result_width, expected_w, check_dtype=False)
 1245: 
 1246:     @pytest.mark.parametrize(
 1247:         "data",
 1248:         [
 1249:             {
 1250:                 "A": np.repeat(np.array([1, 2, 3, 4, 5]), np.array([10, 9, 8, 7, 6])),
 1251:                 "B": np.repeat(np.array([1, 2, 3, 4, 5]), np.array([8, 8, 8, 8, 8])),
 1252:                 "C": np.repeat(np.array([1, 2, 3, 4, 5]), np.array([6, 7, 8, 9, 10])),
 1253:             },
 1254:             {
 1255:                 "A": np.repeat(
 1256:                     np.array([np.nan, 1, 2, 3, 4, 5]), np.array([3, 10, 9, 8, 7, 6])
 1257:                 ),
 1258:                 "B": np.repeat(
 1259:                     np.array([1, np.nan, 2, 3, 4, 5]), np.array([8, 3, 8, 8, 8, 8])
 1260:                 ),
 1261:                 "C": np.repeat(
 1262:                     np.array([1, 2, 3, np.nan, 4, 5]), np.array([6, 7, 8, 3, 9, 10])
 1263:                 ),
 1264:             },
 1265:         ],
 1266:     )
 1267:     def test_hist_df_coord(self, data):
 1268:         df = DataFrame(data)
 1269: 
 1270:         ax = df.plot.hist(bins=5)
 1271:         self._check_box_coord(
 1272:             ax.patches[:5],
 1273:             expected_y=np.array([0, 0, 0, 0, 0]),
 1274:             expected_h=np.array([10, 9, 8, 7, 6]),
 1275:         )
 1276:         self._check_box_coord(
 1277:             ax.patches[5:10],
 1278:             expected_y=np.array([0, 0, 0, 0, 0]),
 1279:             expected_h=np.array([8, 8, 8, 8, 8]),
 1280:         )
 1281:         self._check_box_coord(
 1282:             ax.patches[10:],
 1283:             expected_y=np.array([0, 0, 0, 0, 0]),
 1284:             expected_h=np.array([6, 7, 8, 9, 10]),
 1285:         )
 1286: 
 1287:         ax = df.plot.hist(bins=5, stacked=True)
 1288:         self._check_box_coord(
 1289:             ax.patches[:5],
 1290:             expected_y=np.array([0, 0, 0, 0, 0]),
 1291:             expected_h=np.array([10, 9, 8, 7, 6]),
 1292:         )
 1293:         self._check_box_coord(
 1294:             ax.patches[5:10],
 1295:             expected_y=np.array([10, 9, 8, 7, 6]),
 1296:             expected_h=np.array([8, 8, 8, 8, 8]),
 1297:         )
 1298:         self._check_box_coord(
 1299:             ax.patches[10:],
 1300:             expected_y=np.array([18, 17, 16, 15, 14]),
 1301:             expected_h=np.array([6, 7, 8, 9, 10]),
 1302:         )
 1303: 
 1304:         axes = df.plot.hist(bins=5, stacked=True, subplots=True)
 1305:         self._check_box_coord(
 1306:             axes[0].patches,
 1307:             expected_y=np.array([0, 0, 0, 0, 0]),
 1308:             expected_h=np.array([10, 9, 8, 7, 6]),
 1309:         )
 1310:         self._check_box_coord(
 1311:             axes[1].patches,
 1312:             expected_y=np.array([0, 0, 0, 0, 0]),
 1313:             expected_h=np.array([8, 8, 8, 8, 8]),
 1314:         )
 1315:         self._check_box_coord(
 1316:             axes[2].patches,
 1317:             expected_y=np.array([0, 0, 0, 0, 0]),
 1318:             expected_h=np.array([6, 7, 8, 9, 10]),
 1319:         )
 1320: 
 1321:         # horizontal
 1322:         ax = df.plot.hist(bins=5, orientation="horizontal")
 1323:         self._check_box_coord(
 1324:             ax.patches[:5],
 1325:             expected_x=np.array([0, 0, 0, 0, 0]),
 1326:             expected_w=np.array([10, 9, 8, 7, 6]),
 1327:         )
 1328:         self._check_box_coord(
 1329:             ax.patches[5:10],
 1330:             expected_x=np.array([0, 0, 0, 0, 0]),
 1331:             expected_w=np.array([8, 8, 8, 8, 8]),
 1332:         )
 1333:         self._check_box_coord(
 1334:             ax.patches[10:],
 1335:             expected_x=np.array([0, 0, 0, 0, 0]),
 1336:             expected_w=np.array([6, 7, 8, 9, 10]),
 1337:         )
 1338: 
 1339:         ax = df.plot.hist(bins=5, stacked=True, orientation="horizontal")
 1340:         self._check_box_coord(
 1341:             ax.patches[:5],
 1342:             expected_x=np.array([0, 0, 0, 0, 0]),
 1343:             expected_w=np.array([10, 9, 8, 7, 6]),
 1344:         )
 1345:         self._check_box_coord(
 1346:             ax.patches[5:10],
 1347:             expected_x=np.array([10, 9, 8, 7, 6]),
 1348:             expected_w=np.array([8, 8, 8, 8, 8]),
 1349:         )
 1350:         self._check_box_coord(
 1351:             ax.patches[10:],
 1352:             expected_x=np.array([18, 17, 16, 15, 14]),
 1353:             expected_w=np.array([6, 7, 8, 9, 10]),
 1354:         )
 1355: 
 1356:         axes = df.plot.hist(
 1357:             bins=5, stacked=True, subplots=True, orientation="horizontal"
 1358:         )
 1359:         self._check_box_coord(
 1360:             axes[0].patches,
 1361:             expected_x=np.array([0, 0, 0, 0, 0]),
 1362:             expected_w=np.array([10, 9, 8, 7, 6]),
 1363:         )
 1364:         self._check_box_coord(
 1365:             axes[1].patches,
 1366:             expected_x=np.array([0, 0, 0, 0, 0]),
 1367:             expected_w=np.array([8, 8, 8, 8, 8]),
 1368:         )
 1369:         self._check_box_coord(
 1370:             axes[2].patches,
 1371:             expected_x=np.array([0, 0, 0, 0, 0]),
 1372:             expected_w=np.array([6, 7, 8, 9, 10]),
 1373:         )
 1374: 
 1375:     def test_plot_int_columns(self):
 1376:         df = DataFrame(np.random.default_rng(2).standard_normal((100, 4))).cumsum()
 1377:         _check_plot_works(df.plot, legend=True)
 1378: 
 1379:     @pytest.mark.parametrize(
 1380:         "markers",
 1381:         [
 1382:             {0: "^", 1: "+", 2: "o"},
 1383:             {0: "^", 1: "+"},
 1384:             ["^", "+", "o"],
 1385:             ["^", "+"],
 1386:         ],
 1387:     )
 1388:     def test_style_by_column(self, markers):
 1389:         import matplotlib.pyplot as plt
 1390: 
 1391:         fig = plt.gcf()
 1392:         fig.clf()
 1393:         fig.add_subplot(111)
 1394:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 3)))
 1395:         ax = df.plot(style=markers)
 1396:         for idx, line in enumerate(ax.get_lines()[: len(markers)]):
 1397:             assert line.get_marker() == markers[idx]
 1398: 
 1399:     def test_line_label_none(self):
 1400:         s = Series([1, 2])
 1401:         ax = s.plot()
 1402:         assert ax.get_legend() is None
 1403: 
 1404:         ax = s.plot(legend=True)
 1405:         assert ax.get_legend().get_texts()[0].get_text() == ""
 1406: 
 1407:     @pytest.mark.parametrize(
 1408:         "props, expected",
 1409:         [
 1410:             ("boxprops", "boxes"),
 1411:             ("whiskerprops", "whiskers"),
 1412:             ("capprops", "caps"),
 1413:             ("medianprops", "medians"),
 1414:         ],
 1415:     )
 1416:     def test_specified_props_kwd_plot_box(self, props, expected):
 1417:         # GH 30346
 1418:         df = DataFrame({k: np.random.default_rng(2).random(100) for k in "ABC"})
 1419:         kwd = {props: {"color": "C1"}}
 1420:         result = df.plot.box(return_type="dict", **kwd)
 1421: 
 1422:         assert result[expected][0].get_color() == "C1"
 1423: 
 1424:     def test_unordered_ts(self):
 1425:         # GH#2609, GH#55906
 1426:         index = [date(2012, 10, 1), date(2012, 9, 1), date(2012, 8, 1)]
 1427:         values = [3.0, 2.0, 1.0]
 1428:         df = DataFrame(
 1429:             np.array(values),
 1430:             index=index,
 1431:             columns=["test"],
 1432:         )
 1433:         ax = df.plot()
 1434:         xticks = ax.lines[0].get_xdata()
 1435:         tm.assert_numpy_array_equal(xticks, np.array(index, dtype=object))
 1436:         ydata = ax.lines[0].get_ydata()
 1437:         tm.assert_numpy_array_equal(ydata, np.array(values))
 1438: 
 1439:         # even though we don't sort the data before passing it to matplotlib,
 1440:         # the ticks are sorted
 1441:         xticks = ax.xaxis.get_ticklabels()
 1442:         xlocs = [x.get_position()[0] for x in xticks]
 1443:         assert Index(xlocs).is_monotonic_increasing
 1444:         xlabels = [x.get_text() for x in xticks]
 1445:         assert pd.to_datetime(xlabels, format="%Y-%m-%d").is_monotonic_increasing
 1446: 
 1447:     @pytest.mark.parametrize("kind", plotting.PlotAccessor._common_kinds)
 1448:     def test_kind_both_ways(self, kind):
 1449:         pytest.importorskip("scipy")
 1450:         df = DataFrame({"x": [1, 2, 3]})
 1451:         df.plot(kind=kind)
 1452:         getattr(df.plot, kind)()
 1453: 
 1454:     @pytest.mark.parametrize("kind", ["scatter", "hexbin"])
 1455:     def test_kind_both_ways_x_y(self, kind):
 1456:         pytest.importorskip("scipy")
 1457:         df = DataFrame({"x": [1, 2, 3]})
 1458:         df.plot("x", "x", kind=kind)
 1459:         getattr(df.plot, kind)("x", "x")
 1460: 
 1461:     @pytest.mark.parametrize("kind", plotting.PlotAccessor._common_kinds)
 1462:     def test_all_invalid_plot_data(self, kind):
 1463:         df = DataFrame(list("abcd"))
 1464:         msg = "no numeric data to plot"
 1465:         with pytest.raises(TypeError, match=msg):
 1466:             df.plot(kind=kind)
 1467: 
 1468:     @pytest.mark.parametrize(
 1469:         "kind", list(plotting.PlotAccessor._common_kinds) + ["area"]
 1470:     )
 1471:     def test_partially_invalid_plot_data_numeric(self, kind):
 1472:         df = DataFrame(
 1473:             np.random.default_rng(2).standard_normal((10, 2)),
 1474:             dtype=object,
 1475:         )
 1476:         df[np.random.default_rng(2).random(df.shape[0]) > 0.5] = "a"
 1477:         msg = "no numeric data to plot"
 1478:         with pytest.raises(TypeError, match=msg):
 1479:             df.plot(kind=kind)
 1480: 
 1481:     def test_invalid_kind(self):
 1482:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)))
 1483:         msg = "invalid_plot_kind is not a valid plot kind"
 1484:         with pytest.raises(ValueError, match=msg):
 1485:             df.plot(kind="invalid_plot_kind")
 1486: 
 1487:     @pytest.mark.parametrize(
 1488:         "x,y,lbl",
 1489:         [
 1490:             (["B", "C"], "A", "a"),
 1491:             (["A"], ["B", "C"], ["b", "c"]),
 1492:         ],
 1493:     )
 1494:     def test_invalid_xy_args(self, x, y, lbl):
 1495:         # GH 18671, 19699 allows y to be list-like but not x
 1496:         df = DataFrame({"A": [1, 2], "B": [3, 4], "C": [5, 6]})
 1497:         with pytest.raises(ValueError, match="x must be a label or position"):
 1498:             df.plot(x=x, y=y, label=lbl)
 1499: 
 1500:     def test_bad_label(self):
 1501:         df = DataFrame({"A": [1, 2], "B": [3, 4], "C": [5, 6]})
 1502:         msg = "label should be list-like and same length as y"
 1503:         with pytest.raises(ValueError, match=msg):
 1504:             df.plot(x="A", y=["B", "C"], label="bad_label")
 1505: 
 1506:     @pytest.mark.parametrize("x,y", [("A", "B"), (["A"], "B")])
 1507:     def test_invalid_xy_args_dup_cols(self, x, y):
 1508:         # GH 18671, 19699 allows y to be list-like but not x
 1509:         df = DataFrame([[1, 3, 5], [2, 4, 6]], columns=list("AAB"))
 1510:         with pytest.raises(ValueError, match="x must be a label or position"):
 1511:             df.plot(x=x, y=y)
 1512: 
 1513:     @pytest.mark.parametrize(
 1514:         "x,y,lbl,colors",
 1515:         [
 1516:             ("A", ["B"], ["b"], ["red"]),
 1517:             ("A", ["B", "C"], ["b", "c"], ["red", "blue"]),
 1518:             (0, [1, 2], ["bokeh", "cython"], ["green", "yellow"]),
 1519:         ],
 1520:     )
 1521:     def test_y_listlike(self, x, y, lbl, colors):
 1522:         # GH 19699: tests list-like y and verifies lbls & colors
 1523:         df = DataFrame({"A": [1, 2], "B": [3, 4], "C": [5, 6]})
 1524:         _check_plot_works(df.plot, x="A", y=y, label=lbl)
 1525: 
 1526:         ax = df.plot(x=x, y=y, label=lbl, color=colors)
 1527:         assert len(ax.lines) == len(y)
 1528:         _check_colors(ax.get_lines(), linecolors=colors)
 1529: 
 1530:     @pytest.mark.parametrize("x,y,colnames", [(0, 1, ["A", "B"]), (1, 0, [0, 1])])
 1531:     def test_xy_args_integer(self, x, y, colnames):
 1532:         # GH 20056: tests integer args for xy and checks col names
 1533:         df = DataFrame({"A": [1, 2], "B": [3, 4]})
 1534:         df.columns = colnames
 1535:         _check_plot_works(df.plot, x=x, y=y)
 1536: 
 1537:     def test_hexbin_basic(self):
 1538:         df = DataFrame(
 1539:             {
 1540:                 "A": np.random.default_rng(2).uniform(size=20),
 1541:                 "B": np.random.default_rng(2).uniform(size=20),
 1542:                 "C": np.arange(20) + np.random.default_rng(2).uniform(size=20),
 1543:             }
 1544:         )
 1545: 
 1546:         ax = df.plot.hexbin(x="A", y="B", gridsize=10)
 1547:         # TODO: need better way to test. This just does existence.
 1548:         assert len(ax.collections) == 1
 1549: 
 1550:     def test_hexbin_basic_subplots(self):
 1551:         df = DataFrame(
 1552:             {
 1553:                 "A": np.random.default_rng(2).uniform(size=20),
 1554:                 "B": np.random.default_rng(2).uniform(size=20),
 1555:                 "C": np.arange(20) + np.random.default_rng(2).uniform(size=20),
 1556:             }
 1557:         )
 1558:         # GH 6951
 1559:         axes = df.plot.hexbin(x="A", y="B", subplots=True)
 1560:         # hexbin should have 2 axes in the figure, 1 for plotting and another
 1561:         # is colorbar
 1562:         assert len(axes[0].figure.axes) == 2
 1563:         # return value is single axes
 1564:         _check_axes_shape(axes, axes_num=1, layout=(1, 1))
 1565: 
 1566:     @pytest.mark.parametrize("reduce_C", [None, np.std])
 1567:     def test_hexbin_with_c(self, reduce_C):
 1568:         df = DataFrame(
 1569:             {
 1570:                 "A": np.random.default_rng(2).uniform(size=20),
 1571:                 "B": np.random.default_rng(2).uniform(size=20),
 1572:                 "C": np.arange(20) + np.random.default_rng(2).uniform(size=20),
 1573:             }
 1574:         )
 1575: 
 1576:         ax = df.plot.hexbin(x="A", y="B", C="C", reduce_C_function=reduce_C)
 1577:         assert len(ax.collections) == 1
 1578: 
 1579:     @pytest.mark.parametrize(
 1580:         "kwargs, expected",
 1581:         [
 1582:             ({}, "BuGn"),  # default cmap
 1583:             ({"colormap": "cubehelix"}, "cubehelix"),
 1584:             ({"cmap": "YlGn"}, "YlGn"),
 1585:         ],
 1586:     )
 1587:     def test_hexbin_cmap(self, kwargs, expected):
 1588:         df = DataFrame(
 1589:             {
 1590:                 "A": np.random.default_rng(2).uniform(size=20),
 1591:                 "B": np.random.default_rng(2).uniform(size=20),
 1592:                 "C": np.arange(20) + np.random.default_rng(2).uniform(size=20),
 1593:             }
 1594:         )
 1595:         ax = df.plot.hexbin(x="A", y="B", **kwargs)
 1596:         assert ax.collections[0].cmap.name == expected
 1597: 
 1598:     def test_pie_df_err(self):
 1599:         df = DataFrame(
 1600:             np.random.default_rng(2).random((5, 3)),
 1601:             columns=["X", "Y", "Z"],
 1602:             index=["a", "b", "c", "d", "e"],
 1603:         )
 1604:         msg = "pie requires either y column or 'subplots=True'"
 1605:         with pytest.raises(ValueError, match=msg):
 1606:             df.plot.pie()
 1607: 
 1608:     @pytest.mark.parametrize("y", ["Y", 2])
 1609:     def test_pie_df(self, y):
 1610:         df = DataFrame(
 1611:             np.random.default_rng(2).random((5, 3)),
 1612:             columns=["X", "Y", "Z"],
 1613:             index=["a", "b", "c", "d", "e"],
 1614:         )
 1615:         ax = _check_plot_works(df.plot.pie, y=y)
 1616:         _check_text_labels(ax.texts, df.index)
 1617: 
 1618:     def test_pie_df_subplots(self):
 1619:         df = DataFrame(
 1620:             np.random.default_rng(2).random((5, 3)),
 1621:             columns=["X", "Y", "Z"],
 1622:             index=["a", "b", "c", "d", "e"],
 1623:         )
 1624:         axes = _check_plot_works(
 1625:             df.plot.pie,
 1626:             default_axes=True,
 1627:             subplots=True,
 1628:         )
 1629:         assert len(axes) == len(df.columns)
 1630:         for ax in axes:
 1631:             _check_text_labels(ax.texts, df.index)
 1632:         for ax, ylabel in zip(axes, df.columns):
 1633:             assert ax.get_ylabel() == ylabel
 1634: 
 1635:     def test_pie_df_labels_colors(self):
 1636:         df = DataFrame(
 1637:             np.random.default_rng(2).random((5, 3)),
 1638:             columns=["X", "Y", "Z"],
 1639:             index=["a", "b", "c", "d", "e"],
 1640:         )
 1641:         labels = ["A", "B", "C", "D", "E"]
 1642:         color_args = ["r", "g", "b", "c", "m"]
 1643:         axes = _check_plot_works(
 1644:             df.plot.pie,
 1645:             default_axes=True,
 1646:             subplots=True,
 1647:             labels=labels,
 1648:             colors=color_args,
 1649:         )
 1650:         assert len(axes) == len(df.columns)
 1651: 
 1652:         for ax in axes:
 1653:             _check_text_labels(ax.texts, labels)
 1654:             _check_colors(ax.patches, facecolors=color_args)
 1655: 
 1656:     def test_pie_df_nan(self):
 1657:         df = DataFrame(np.random.default_rng(2).random((4, 4)))
 1658:         for i in range(4):
 1659:             df.iloc[i, i] = np.nan
 1660:         _, axes = mpl.pyplot.subplots(ncols=4)
 1661: 
 1662:         # GH 37668
 1663:         kwargs = {"normalize": True}
 1664: 
 1665:         with tm.assert_produces_warning(None):
 1666:             df.plot.pie(subplots=True, ax=axes, legend=True, **kwargs)
 1667: 
 1668:         base_expected = ["0", "1", "2", "3"]
 1669:         for i, ax in enumerate(axes):
 1670:             expected = list(base_expected)  # force copy
 1671:             expected[i] = ""
 1672:             result = [x.get_text() for x in ax.texts]
 1673:             assert result == expected
 1674: 
 1675:             # legend labels
 1676:             # NaN's not included in legend with subplots
 1677:             # see https://github.com/pandas-dev/pandas/issues/8390
 1678:             result_labels = [x.get_text() for x in ax.get_legend().get_texts()]
 1679:             expected_labels = base_expected[:i] + base_expected[i + 1 :]
 1680:             assert result_labels == expected_labels
 1681: 
 1682:     @pytest.mark.slow
 1683:     @pytest.mark.parametrize(
 1684:         "kwargs",
 1685:         [
 1686:             {"logy": True},
 1687:             {"logx": True, "logy": True},
 1688:             {"loglog": True},
 1689:         ],
 1690:     )
 1691:     def test_errorbar_plot(self, kwargs):
 1692:         d = {"x": np.arange(12), "y": np.arange(12, 0, -1)}
 1693:         df = DataFrame(d)
 1694:         d_err = {"x": np.ones(12) * 0.2, "y": np.ones(12) * 0.4}
 1695:         df_err = DataFrame(d_err)
 1696: 
 1697:         # check line plots
 1698:         ax = _check_plot_works(df.plot, yerr=df_err, **kwargs)
 1699:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1700: 
 1701:     @pytest.mark.slow
 1702:     def test_errorbar_plot_bar(self):
 1703:         d = {"x": np.arange(12), "y": np.arange(12, 0, -1)}
 1704:         df = DataFrame(d)
 1705:         d_err = {"x": np.ones(12) * 0.2, "y": np.ones(12) * 0.4}
 1706:         df_err = DataFrame(d_err)
 1707:         ax = _check_plot_works(
 1708:             (df + 1).plot, yerr=df_err, xerr=df_err, kind="bar", log=True
 1709:         )
 1710:         _check_has_errorbars(ax, xerr=2, yerr=2)
 1711: 
 1712:     @pytest.mark.slow
 1713:     def test_errorbar_plot_yerr_array(self):
 1714:         d = {"x": np.arange(12), "y": np.arange(12, 0, -1)}
 1715:         df = DataFrame(d)
 1716:         # yerr is raw error values
 1717:         ax = _check_plot_works(df["y"].plot, yerr=np.ones(12) * 0.4)
 1718:         _check_has_errorbars(ax, xerr=0, yerr=1)
 1719: 
 1720:         ax = _check_plot_works(df.plot, yerr=np.ones((2, 12)) * 0.4)
 1721:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1722: 
 1723:     @pytest.mark.slow
 1724:     @pytest.mark.parametrize("yerr", ["yerr", "иЄ¤е·®"])
 1725:     def test_errorbar_plot_column_name(self, yerr):
 1726:         d = {"x": np.arange(12), "y": np.arange(12, 0, -1)}
 1727:         df = DataFrame(d)
 1728:         df[yerr] = np.ones(12) * 0.2
 1729: 
 1730:         ax = _check_plot_works(df.plot, yerr=yerr)
 1731:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1732: 
 1733:         ax = _check_plot_works(df.plot, y="y", x="x", yerr=yerr)
 1734:         _check_has_errorbars(ax, xerr=0, yerr=1)
 1735: 
 1736:     @pytest.mark.slow
 1737:     def test_errorbar_plot_external_valueerror(self):
 1738:         d = {"x": np.arange(12), "y": np.arange(12, 0, -1)}
 1739:         df = DataFrame(d)
 1740:         with tm.external_error_raised(ValueError):
 1741:             df.plot(yerr=np.random.default_rng(2).standard_normal(11))
 1742: 
 1743:     @pytest.mark.slow
 1744:     def test_errorbar_plot_external_typeerror(self):
 1745:         d = {"x": np.arange(12), "y": np.arange(12, 0, -1)}
 1746:         df = DataFrame(d)
 1747:         df_err = DataFrame({"x": ["zzz"] * 12, "y": ["zzz"] * 12})
 1748:         with tm.external_error_raised(TypeError):
 1749:             df.plot(yerr=df_err)
 1750: 
 1751:     @pytest.mark.slow
 1752:     @pytest.mark.parametrize("kind", ["line", "bar", "barh"])
 1753:     @pytest.mark.parametrize(
 1754:         "y_err",
 1755:         [
 1756:             Series(np.ones(12) * 0.2, name="x"),
 1757:             DataFrame({"x": np.ones(12) * 0.2, "y": np.ones(12) * 0.4}),
 1758:         ],
 1759:     )
 1760:     def test_errorbar_plot_different_yerr(self, kind, y_err):
 1761:         df = DataFrame({"x": np.arange(12), "y": np.arange(12, 0, -1)})
 1762: 
 1763:         ax = _check_plot_works(df.plot, yerr=y_err, kind=kind)
 1764:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1765: 
 1766:     @pytest.mark.slow
 1767:     @pytest.mark.parametrize("kind", ["line", "bar", "barh"])
 1768:     @pytest.mark.parametrize(
 1769:         "y_err, x_err",
 1770:         [
 1771:             (
 1772:                 DataFrame({"x": np.ones(12) * 0.2, "y": np.ones(12) * 0.4}),
 1773:                 DataFrame({"x": np.ones(12) * 0.2, "y": np.ones(12) * 0.4}),
 1774:             ),
 1775:             (Series(np.ones(12) * 0.2, name="x"), Series(np.ones(12) * 0.2, name="x")),
 1776:             (0.2, 0.2),
 1777:         ],
 1778:     )
 1779:     def test_errorbar_plot_different_yerr_xerr(self, kind, y_err, x_err):
 1780:         df = DataFrame({"x": np.arange(12), "y": np.arange(12, 0, -1)})
 1781:         ax = _check_plot_works(df.plot, yerr=y_err, xerr=x_err, kind=kind)
 1782:         _check_has_errorbars(ax, xerr=2, yerr=2)
 1783: 
 1784:     @pytest.mark.slow
 1785:     @pytest.mark.parametrize("kind", ["line", "bar", "barh"])
 1786:     def test_errorbar_plot_different_yerr_xerr_subplots(self, kind):
 1787:         df = DataFrame({"x": np.arange(12), "y": np.arange(12, 0, -1)})
 1788:         df_err = DataFrame({"x": np.ones(12) * 0.2, "y": np.ones(12) * 0.4})
 1789:         axes = _check_plot_works(
 1790:             df.plot,
 1791:             default_axes=True,
 1792:             yerr=df_err,
 1793:             xerr=df_err,
 1794:             subplots=True,
 1795:             kind=kind,
 1796:         )
 1797:         _check_has_errorbars(axes, xerr=1, yerr=1)
 1798: 
 1799:     @pytest.mark.xfail(reason="Iterator is consumed", raises=ValueError)
 1800:     def test_errorbar_plot_iterator(self):
 1801:         d = {"x": np.arange(12), "y": np.arange(12, 0, -1)}
 1802:         df = DataFrame(d)
 1803: 
 1804:         # yerr is iterator
 1805:         ax = _check_plot_works(df.plot, yerr=itertools.repeat(0.1, len(df)))
 1806:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1807: 
 1808:     def test_errorbar_with_integer_column_names(self):
 1809:         # test with integer column names
 1810:         df = DataFrame(np.abs(np.random.default_rng(2).standard_normal((10, 2))))
 1811:         df_err = DataFrame(np.abs(np.random.default_rng(2).standard_normal((10, 2))))
 1812:         ax = _check_plot_works(df.plot, yerr=df_err)
 1813:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1814:         ax = _check_plot_works(df.plot, y=0, yerr=1)
 1815:         _check_has_errorbars(ax, xerr=0, yerr=1)
 1816: 
 1817:     @pytest.mark.slow
 1818:     @pytest.mark.parametrize("kind", ["line", "bar"])
 1819:     def test_errorbar_with_partial_columns_kind(self, kind):
 1820:         df = DataFrame(np.abs(np.random.default_rng(2).standard_normal((10, 3))))
 1821:         df_err = DataFrame(
 1822:             np.abs(np.random.default_rng(2).standard_normal((10, 2))), columns=[0, 2]
 1823:         )
 1824:         ax = _check_plot_works(df.plot, yerr=df_err, kind=kind)
 1825:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1826: 
 1827:     @pytest.mark.slow
 1828:     def test_errorbar_with_partial_columns_dti(self):
 1829:         df = DataFrame(np.abs(np.random.default_rng(2).standard_normal((10, 3))))
 1830:         df_err = DataFrame(
 1831:             np.abs(np.random.default_rng(2).standard_normal((10, 2))), columns=[0, 2]
 1832:         )
 1833:         ix = date_range("1/1/2000", periods=10, freq="ME")
 1834:         df.set_index(ix, inplace=True)
 1835:         df_err.set_index(ix, inplace=True)
 1836:         ax = _check_plot_works(df.plot, yerr=df_err, kind="line")
 1837:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1838: 
 1839:     @pytest.mark.slow
 1840:     @pytest.mark.parametrize("err_box", [lambda x: x, DataFrame])
 1841:     def test_errorbar_with_partial_columns_box(self, err_box):
 1842:         d = {"x": np.arange(12), "y": np.arange(12, 0, -1)}
 1843:         df = DataFrame(d)
 1844:         err = err_box({"x": np.ones(12) * 0.2, "z": np.ones(12) * 0.4})
 1845:         ax = _check_plot_works(df.plot, yerr=err)
 1846:         _check_has_errorbars(ax, xerr=0, yerr=1)
 1847: 
 1848:     @pytest.mark.parametrize("kind", ["line", "bar", "barh"])
 1849:     def test_errorbar_timeseries(self, kind):
 1850:         d = {"x": np.arange(12), "y": np.arange(12, 0, -1)}
 1851:         d_err = {"x": np.ones(12) * 0.2, "y": np.ones(12) * 0.4}
 1852: 
 1853:         # check time-series plots
 1854:         ix = date_range("1/1/2000", "1/1/2001", freq="ME")
 1855:         tdf = DataFrame(d, index=ix)
 1856:         tdf_err = DataFrame(d_err, index=ix)
 1857: 
 1858:         ax = _check_plot_works(tdf.plot, yerr=tdf_err, kind=kind)
 1859:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1860: 
 1861:         ax = _check_plot_works(tdf.plot, yerr=d_err, kind=kind)
 1862:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1863: 
 1864:         ax = _check_plot_works(tdf.plot, y="y", yerr=tdf_err["x"], kind=kind)
 1865:         _check_has_errorbars(ax, xerr=0, yerr=1)
 1866: 
 1867:         ax = _check_plot_works(tdf.plot, y="y", yerr="x", kind=kind)
 1868:         _check_has_errorbars(ax, xerr=0, yerr=1)
 1869: 
 1870:         ax = _check_plot_works(tdf.plot, yerr=tdf_err, kind=kind)
 1871:         _check_has_errorbars(ax, xerr=0, yerr=2)
 1872: 
 1873:         axes = _check_plot_works(
 1874:             tdf.plot,
 1875:             default_axes=True,
 1876:             kind=kind,
 1877:             yerr=tdf_err,
 1878:             subplots=True,
 1879:         )
 1880:         _check_has_errorbars(axes, xerr=0, yerr=1)
 1881: 
 1882:     def test_errorbar_asymmetrical(self):
 1883:         err = np.random.default_rng(2).random((3, 2, 5))
 1884: 
 1885:         # each column is [0, 1, 2, 3, 4], [3, 4, 5, 6, 7]...
 1886:         df = DataFrame(np.arange(15).reshape(3, 5)).T
 1887: 
 1888:         ax = df.plot(yerr=err, xerr=err / 2)
 1889: 
 1890:         yerr_0_0 = ax.collections[1].get_paths()[0].vertices[:, 1]
 1891:         expected_0_0 = err[0, :, 0] * np.array([-1, 1])
 1892:         tm.assert_almost_equal(yerr_0_0, expected_0_0)
 1893: 
 1894:         msg = re.escape(
 1895:             "Asymmetrical error bars should be provided with the shape (3, 2, 5)"
 1896:         )
 1897:         with pytest.raises(ValueError, match=msg):
 1898:             df.plot(yerr=err.T)
 1899: 
 1900:     def test_table(self):
 1901:         df = DataFrame(
 1902:             np.random.default_rng(2).random((10, 3)),
 1903:             index=list(string.ascii_letters[:10]),
 1904:         )
 1905:         _check_plot_works(df.plot, table=True)
 1906:         _check_plot_works(df.plot, table=df)
 1907: 
 1908:         # GH 35945 UserWarning
 1909:         with tm.assert_produces_warning(None):
 1910:             ax = df.plot()
 1911:             assert len(ax.tables) == 0
 1912:             plotting.table(ax, df.T)
 1913:             assert len(ax.tables) == 1
 1914: 
 1915:     def test_errorbar_scatter(self):
 1916:         df = DataFrame(
 1917:             np.abs(np.random.default_rng(2).standard_normal((5, 2))),
 1918:             index=range(5),
 1919:             columns=["x", "y"],
 1920:         )
 1921:         df_err = DataFrame(
 1922:             np.abs(np.random.default_rng(2).standard_normal((5, 2))) / 5,
 1923:             index=range(5),
 1924:             columns=["x", "y"],
 1925:         )
 1926: 
 1927:         ax = _check_plot_works(df.plot.scatter, x="x", y="y")
 1928:         _check_has_errorbars(ax, xerr=0, yerr=0)
 1929:         ax = _check_plot_works(df.plot.scatter, x="x", y="y", xerr=df_err)
 1930:         _check_has_errorbars(ax, xerr=1, yerr=0)
 1931: 
 1932:         ax = _check_plot_works(df.plot.scatter, x="x", y="y", yerr=df_err)
 1933:         _check_has_errorbars(ax, xerr=0, yerr=1)
 1934:         ax = _check_plot_works(df.plot.scatter, x="x", y="y", xerr=df_err, yerr=df_err)
 1935:         _check_has_errorbars(ax, xerr=1, yerr=1)
 1936: 
 1937:     def test_errorbar_scatter_color(self):
 1938:         def _check_errorbar_color(containers, expected, has_err="has_xerr"):
 1939:             lines = []
 1940:             errs = next(c.lines for c in ax.containers if getattr(c, has_err, False))
 1941:             for el in errs:
 1942:                 if is_list_like(el):
 1943:                     lines.extend(el)
 1944:                 else:
 1945:                     lines.append(el)
 1946:             err_lines = [x for x in lines if x in ax.collections]
 1947:             _check_colors(err_lines, linecolors=np.array([expected] * len(err_lines)))
 1948: 
 1949:         # GH 8081
 1950:         df = DataFrame(
 1951:             np.abs(np.random.default_rng(2).standard_normal((10, 5))),
 1952:             columns=["a", "b", "c", "d", "e"],
 1953:         )
 1954:         ax = df.plot.scatter(x="a", y="b", xerr="d", yerr="e", c="red")
 1955:         _check_has_errorbars(ax, xerr=1, yerr=1)
 1956:         _check_errorbar_color(ax.containers, "red", has_err="has_xerr")
 1957:         _check_errorbar_color(ax.containers, "red", has_err="has_yerr")
 1958: 
 1959:         ax = df.plot.scatter(x="a", y="b", yerr="e", color="green")
 1960:         _check_has_errorbars(ax, xerr=0, yerr=1)
 1961:         _check_errorbar_color(ax.containers, "green", has_err="has_yerr")
 1962: 
 1963:     def test_scatter_unknown_colormap(self):
 1964:         # GH#48726
 1965:         df = DataFrame({"a": [1, 2, 3], "b": 4})
 1966:         with pytest.raises((ValueError, KeyError), match="'unknown' is not a"):
 1967:             df.plot(x="a", y="b", colormap="unknown", kind="scatter")
 1968: 
 1969:     def test_sharex_and_ax(self):
 1970:         # https://github.com/pandas-dev/pandas/issues/9737 using gridspec,
 1971:         # the axis in fig.get_axis() are sorted differently than pandas
 1972:         # expected them, so make sure that only the right ones are removed
 1973:         import matplotlib.pyplot as plt
 1974: 
 1975:         plt.close("all")
 1976:         gs, axes = _generate_4_axes_via_gridspec()
 1977: 
 1978:         df = DataFrame(
 1979:             {
 1980:                 "a": [1, 2, 3, 4, 5, 6],
 1981:                 "b": [1, 2, 3, 4, 5, 6],
 1982:                 "c": [1, 2, 3, 4, 5, 6],
 1983:                 "d": [1, 2, 3, 4, 5, 6],
 1984:             }
 1985:         )
 1986: 
 1987:         def _check(axes):
 1988:             for ax in axes:
 1989:                 assert len(ax.lines) == 1
 1990:                 _check_visible(ax.get_yticklabels(), visible=True)
 1991:             for ax in [axes[0], axes[2]]:
 1992:                 _check_visible(ax.get_xticklabels(), visible=False)
 1993:                 _check_visible(ax.get_xticklabels(minor=True), visible=False)
 1994:             for ax in [axes[1], axes[3]]:
 1995:                 _check_visible(ax.get_xticklabels(), visible=True)
 1996:                 _check_visible(ax.get_xticklabels(minor=True), visible=True)
 1997: 
 1998:         for ax in axes:
 1999:             df.plot(x="a", y="b", title="title", ax=ax, sharex=True)
 2000:         gs.tight_layout(plt.gcf())
 2001:         _check(axes)
 2002:         plt.close("all")
 2003: 
 2004:         gs, axes = _generate_4_axes_via_gridspec()
 2005:         with tm.assert_produces_warning(UserWarning):
 2006:             axes = df.plot(subplots=True, ax=axes, sharex=True)
 2007:         _check(axes)
 2008: 
 2009:     def test_sharex_false_and_ax(self):
 2010:         # https://github.com/pandas-dev/pandas/issues/9737 using gridspec,
 2011:         # the axis in fig.get_axis() are sorted differently than pandas
 2012:         # expected them, so make sure that only the right ones are removed
 2013:         import matplotlib.pyplot as plt
 2014: 
 2015:         df = DataFrame(
 2016:             {
 2017:                 "a": [1, 2, 3, 4, 5, 6],
 2018:                 "b": [1, 2, 3, 4, 5, 6],
 2019:                 "c": [1, 2, 3, 4, 5, 6],
 2020:                 "d": [1, 2, 3, 4, 5, 6],
 2021:             }
 2022:         )
 2023:         gs, axes = _generate_4_axes_via_gridspec()
 2024:         # without sharex, no labels should be touched!
 2025:         for ax in axes:
 2026:             df.plot(x="a", y="b", title="title", ax=ax)
 2027: 
 2028:         gs.tight_layout(plt.gcf())
 2029:         for ax in axes:
 2030:             assert len(ax.lines) == 1
 2031:             _check_visible(ax.get_yticklabels(), visible=True)
 2032:             _check_visible(ax.get_xticklabels(), visible=True)
 2033:             _check_visible(ax.get_xticklabels(minor=True), visible=True)
 2034: 
 2035:     def test_sharey_and_ax(self):
 2036:         # https://github.com/pandas-dev/pandas/issues/9737 using gridspec,
 2037:         # the axis in fig.get_axis() are sorted differently than pandas
 2038:         # expected them, so make sure that only the right ones are removed
 2039:         import matplotlib.pyplot as plt
 2040: 
 2041:         gs, axes = _generate_4_axes_via_gridspec()
 2042: 
 2043:         df = DataFrame(
 2044:             {
 2045:                 "a": [1, 2, 3, 4, 5, 6],
 2046:                 "b": [1, 2, 3, 4, 5, 6],
 2047:                 "c": [1, 2, 3, 4, 5, 6],
 2048:                 "d": [1, 2, 3, 4, 5, 6],
 2049:             }
 2050:         )
 2051: 
 2052:         def _check(axes):
 2053:             for ax in axes:
 2054:                 assert len(ax.lines) == 1
 2055:                 _check_visible(ax.get_xticklabels(), visible=True)
 2056:                 _check_visible(ax.get_xticklabels(minor=True), visible=True)
 2057:             for ax in [axes[0], axes[1]]:
 2058:                 _check_visible(ax.get_yticklabels(), visible=True)
 2059:             for ax in [axes[2], axes[3]]:
 2060:                 _check_visible(ax.get_yticklabels(), visible=False)
 2061: 
 2062:         for ax in axes:
 2063:             df.plot(x="a", y="b", title="title", ax=ax, sharey=True)
 2064:         gs.tight_layout(plt.gcf())
 2065:         _check(axes)
 2066:         plt.close("all")
 2067: 
 2068:         gs, axes = _generate_4_axes_via_gridspec()
 2069:         with tm.assert_produces_warning(UserWarning):
 2070:             axes = df.plot(subplots=True, ax=axes, sharey=True)
 2071: 
 2072:         gs.tight_layout(plt.gcf())
 2073:         _check(axes)
 2074: 
 2075:     def test_sharey_and_ax_tight(self):
 2076:         # https://github.com/pandas-dev/pandas/issues/9737 using gridspec,
 2077:         import matplotlib.pyplot as plt
 2078: 
 2079:         df = DataFrame(
 2080:             {
 2081:                 "a": [1, 2, 3, 4, 5, 6],
 2082:                 "b": [1, 2, 3, 4, 5, 6],
 2083:                 "c": [1, 2, 3, 4, 5, 6],
 2084:                 "d": [1, 2, 3, 4, 5, 6],
 2085:             }
 2086:         )
 2087:         gs, axes = _generate_4_axes_via_gridspec()
 2088:         # without sharex, no labels should be touched!
 2089:         for ax in axes:
 2090:             df.plot(x="a", y="b", title="title", ax=ax)
 2091: 
 2092:         gs.tight_layout(plt.gcf())
 2093:         for ax in axes:
 2094:             assert len(ax.lines) == 1
 2095:             _check_visible(ax.get_yticklabels(), visible=True)
 2096:             _check_visible(ax.get_xticklabels(), visible=True)
 2097:             _check_visible(ax.get_xticklabels(minor=True), visible=True)
 2098: 
 2099:     @pytest.mark.parametrize("kind", plotting.PlotAccessor._all_kinds)
 2100:     def test_memory_leak(self, kind):
 2101:         """Check that every plot type gets properly collected."""
 2102:         pytest.importorskip("scipy")
 2103:         args = {}
 2104:         if kind in ["hexbin", "scatter", "pie"]:
 2105:             df = DataFrame(
 2106:                 {
 2107:                     "A": np.random.default_rng(2).uniform(size=20),
 2108:                     "B": np.random.default_rng(2).uniform(size=20),
 2109:                     "C": np.arange(20) + np.random.default_rng(2).uniform(size=20),
 2110:                 }
 2111:             )
 2112:             args = {"x": "A", "y": "B"}
 2113:         elif kind == "area":
 2114:             df = DataFrame(
 2115:                 np.random.default_rng(2).standard_normal((10, 4)),
 2116:                 columns=Index(list("ABCD"), dtype=object),
 2117:                 index=date_range("2000-01-01", periods=10, freq="B"),
 2118:             ).abs()
 2119:         else:
 2120:             df = DataFrame(
 2121:                 np.random.default_rng(2).standard_normal((10, 4)),
 2122:                 columns=Index(list("ABCD"), dtype=object),
 2123:                 index=date_range("2000-01-01", periods=10, freq="B"),
 2124:             )
 2125: 
 2126:         # Use a weakref so we can see if the object gets collected without
 2127:         # also preventing it from being collected
 2128:         ref = weakref.ref(df.plot(kind=kind, **args))
 2129: 
 2130:         # have matplotlib delete all the figures
 2131:         plt.close("all")
 2132:         # force a garbage collection
 2133:         gc.collect()
 2134:         assert ref() is None
 2135: 
 2136:     def test_df_gridspec_patterns_vert_horiz(self):
 2137:         # GH 10819
 2138:         from matplotlib import gridspec
 2139:         import matplotlib.pyplot as plt
 2140: 
 2141:         ts = Series(
 2142:             np.random.default_rng(2).standard_normal(10),
 2143:             index=date_range("1/1/2000", periods=10),
 2144:         )
 2145: 
 2146:         df = DataFrame(
 2147:             np.random.default_rng(2).standard_normal((10, 2)),
 2148:             index=ts.index,
 2149:             columns=list("AB"),
 2150:         )
 2151: 
 2152:         def _get_vertical_grid():
 2153:             gs = gridspec.GridSpec(3, 1)
 2154:             fig = plt.figure()
 2155:             ax1 = fig.add_subplot(gs[:2, :])
 2156:             ax2 = fig.add_subplot(gs[2, :])
 2157:             return ax1, ax2
 2158: 
 2159:         def _get_horizontal_grid():
 2160:             gs = gridspec.GridSpec(1, 3)
 2161:             fig = plt.figure()
 2162:             ax1 = fig.add_subplot(gs[:, :2])
 2163:             ax2 = fig.add_subplot(gs[:, 2])
 2164:             return ax1, ax2
 2165: 
 2166:         for ax1, ax2 in [_get_vertical_grid(), _get_horizontal_grid()]:
 2167:             ax1 = ts.plot(ax=ax1)
 2168:             assert len(ax1.lines) == 1
 2169:             ax2 = df.plot(ax=ax2)
 2170:             assert len(ax2.lines) == 2
 2171:             for ax in [ax1, ax2]:
 2172:                 _check_visible(ax.get_yticklabels(), visible=True)
 2173:                 _check_visible(ax.get_xticklabels(), visible=True)
 2174:                 _check_visible(ax.get_xticklabels(minor=True), visible=True)
 2175:             plt.close("all")
 2176: 
 2177:         # subplots=True
 2178:         for ax1, ax2 in [_get_vertical_grid(), _get_horizontal_grid()]:
 2179:             axes = df.plot(subplots=True, ax=[ax1, ax2])
 2180:             assert len(ax1.lines) == 1
 2181:             assert len(ax2.lines) == 1
 2182:             for ax in axes:
 2183:                 _check_visible(ax.get_yticklabels(), visible=True)
 2184:                 _check_visible(ax.get_xticklabels(), visible=True)
 2185:                 _check_visible(ax.get_xticklabels(minor=True), visible=True)
 2186:             plt.close("all")
 2187: 
 2188:         # vertical / subplots / sharex=True / sharey=True
 2189:         ax1, ax2 = _get_vertical_grid()
 2190:         with tm.assert_produces_warning(UserWarning):
 2191:             axes = df.plot(subplots=True, ax=[ax1, ax2], sharex=True, sharey=True)
 2192:         assert len(axes[0].lines) == 1
 2193:         assert len(axes[1].lines) == 1
 2194:         for ax in [ax1, ax2]:
 2195:             # yaxis are visible because there is only one column
 2196:             _check_visible(ax.get_yticklabels(), visible=True)
 2197:         # xaxis of axes0 (top) are hidden
 2198:         _check_visible(axes[0].get_xticklabels(), visible=False)
 2199:         _check_visible(axes[0].get_xticklabels(minor=True), visible=False)
 2200:         _check_visible(axes[1].get_xticklabels(), visible=True)
 2201:         _check_visible(axes[1].get_xticklabels(minor=True), visible=True)
 2202:         plt.close("all")
 2203: 
 2204:         # horizontal / subplots / sharex=True / sharey=True
 2205:         ax1, ax2 = _get_horizontal_grid()
 2206:         with tm.assert_produces_warning(UserWarning):
 2207:             axes = df.plot(subplots=True, ax=[ax1, ax2], sharex=True, sharey=True)
 2208:         assert len(axes[0].lines) == 1
 2209:         assert len(axes[1].lines) == 1
 2210:         _check_visible(axes[0].get_yticklabels(), visible=True)
 2211:         # yaxis of axes1 (right) are hidden
 2212:         _check_visible(axes[1].get_yticklabels(), visible=False)
 2213:         for ax in [ax1, ax2]:
 2214:             # xaxis are visible because there is only one column
 2215:             _check_visible(ax.get_xticklabels(), visible=True)
 2216:             _check_visible(ax.get_xticklabels(minor=True), visible=True)
 2217:         plt.close("all")
 2218: 
 2219:     def test_df_gridspec_patterns_boxed(self):
 2220:         # GH 10819
 2221:         from matplotlib import gridspec
 2222:         import matplotlib.pyplot as plt
 2223: 
 2224:         ts = Series(
 2225:             np.random.default_rng(2).standard_normal(10),
 2226:             index=date_range("1/1/2000", periods=10),
 2227:         )
 2228: 
 2229:         # boxed
 2230:         def _get_boxed_grid():
 2231:             gs = gridspec.GridSpec(3, 3)
 2232:             fig = plt.figure()
 2233:             ax1 = fig.add_subplot(gs[:2, :2])
 2234:             ax2 = fig.add_subplot(gs[:2, 2])
 2235:             ax3 = fig.add_subplot(gs[2, :2])
 2236:             ax4 = fig.add_subplot(gs[2, 2])
 2237:             return ax1, ax2, ax3, ax4
 2238: 
 2239:         axes = _get_boxed_grid()
 2240:         df = DataFrame(
 2241:             np.random.default_rng(2).standard_normal((10, 4)),
 2242:             index=ts.index,
 2243:             columns=list("ABCD"),
 2244:         )
 2245:         axes = df.plot(subplots=True, ax=axes)
 2246:         for ax in axes:
 2247:             assert len(ax.lines) == 1
 2248:             # axis are visible because these are not shared
 2249:             _check_visible(ax.get_yticklabels(), visible=True)
 2250:             _check_visible(ax.get_xticklabels(), visible=True)
 2251:             _check_visible(ax.get_xticklabels(minor=True), visible=True)
 2252:         plt.close("all")
 2253: 
 2254:         # subplots / sharex=True / sharey=True
 2255:         axes = _get_boxed_grid()
 2256:         with tm.assert_produces_warning(UserWarning):
 2257:             axes = df.plot(subplots=True, ax=axes, sharex=True, sharey=True)
 2258:         for ax in axes:
 2259:             assert len(ax.lines) == 1
 2260:         for ax in [axes[0], axes[2]]:  # left column
 2261:             _check_visible(ax.get_yticklabels(), visible=True)
 2262:         for ax in [axes[1], axes[3]]:  # right column
 2263:             _check_visible(ax.get_yticklabels(), visible=False)
 2264:         for ax in [axes[0], axes[1]]:  # top row
 2265:             _check_visible(ax.get_xticklabels(), visible=False)
 2266:             _check_visible(ax.get_xticklabels(minor=True), visible=False)
 2267:         for ax in [axes[2], axes[3]]:  # bottom row
 2268:             _check_visible(ax.get_xticklabels(), visible=True)
 2269:             _check_visible(ax.get_xticklabels(minor=True), visible=True)
 2270:         plt.close("all")
 2271: 
 2272:     def test_df_grid_settings(self):
 2273:         # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792
 2274:         _check_grid_settings(
 2275:             DataFrame({"a": [1, 2, 3], "b": [2, 3, 4]}),
 2276:             plotting.PlotAccessor._dataframe_kinds,
 2277:             kws={"x": "a", "y": "b"},
 2278:         )
 2279: 
 2280:     def test_plain_axes(self):
 2281:         # supplied ax itself is a SubplotAxes, but figure contains also
 2282:         # a plain Axes object (GH11556)
 2283:         fig, ax = mpl.pyplot.subplots()
 2284:         fig.add_axes([0.2, 0.2, 0.2, 0.2])
 2285:         Series(np.random.default_rng(2).random(10)).plot(ax=ax)
 2286: 
 2287:     def test_plain_axes_df(self):
 2288:         # supplied ax itself is a plain Axes, but because the cmap keyword
 2289:         # a new ax is created for the colorbar -> also multiples axes (GH11520)
 2290:         df = DataFrame(
 2291:             {
 2292:                 "a": np.random.default_rng(2).standard_normal(8),
 2293:                 "b": np.random.default_rng(2).standard_normal(8),
 2294:             }
 2295:         )
 2296:         fig = mpl.pyplot.figure()
 2297:         ax = fig.add_axes((0, 0, 1, 1))
 2298:         df.plot(kind="scatter", ax=ax, x="a", y="b", c="a", cmap="hsv")
 2299: 
 2300:     def test_plain_axes_make_axes_locatable(self):
 2301:         # other examples
 2302:         fig, ax = mpl.pyplot.subplots()
 2303:         from mpl_toolkits.axes_grid1 import make_axes_locatable
 2304: 
 2305:         divider = make_axes_locatable(ax)
 2306:         cax = divider.append_axes("right", size="5%", pad=0.05)
 2307:         Series(np.random.default_rng(2).random(10)).plot(ax=ax)
 2308:         Series(np.random.default_rng(2).random(10)).plot(ax=cax)
 2309: 
 2310:     def test_plain_axes_make_inset_axes(self):
 2311:         fig, ax = mpl.pyplot.subplots()
 2312:         from mpl_toolkits.axes_grid1.inset_locator import inset_axes
 2313: 
 2314:         iax = inset_axes(ax, width="30%", height=1.0, loc=3)
 2315:         Series(np.random.default_rng(2).random(10)).plot(ax=ax)
 2316:         Series(np.random.default_rng(2).random(10)).plot(ax=iax)
 2317: 
 2318:     @pytest.mark.parametrize("method", ["line", "barh", "bar"])
 2319:     def test_secondary_axis_font_size(self, method):
 2320:         # GH: 12565
 2321:         df = (
 2322:             DataFrame(
 2323:                 np.random.default_rng(2).standard_normal((15, 2)), columns=list("AB")
 2324:             )
 2325:             .assign(C=lambda df: df.B.cumsum())
 2326:             .assign(D=lambda df: df.C * 1.1)
 2327:         )
 2328: 
 2329:         fontsize = 20
 2330:         sy = ["C", "D"]
 2331: 
 2332:         kwargs = {"secondary_y": sy, "fontsize": fontsize, "mark_right": True}
 2333:         ax = getattr(df.plot, method)(**kwargs)
 2334:         _check_ticks_props(axes=ax.right_ax, ylabelsize=fontsize)
 2335: 
 2336:     def test_x_string_values_ticks(self):
 2337:         # Test if string plot index have a fixed xtick position
 2338:         # GH: 7612, GH: 22334
 2339:         df = DataFrame(
 2340:             {
 2341:                 "sales": [3, 2, 3],
 2342:                 "visits": [20, 42, 28],
 2343:                 "day": ["Monday", "Tuesday", "Wednesday"],
 2344:             }
 2345:         )
 2346:         ax = df.plot.area(x="day")
 2347:         ax.set_xlim(-1, 3)
 2348:         xticklabels = [t.get_text() for t in ax.get_xticklabels()]
 2349:         labels_position = dict(zip(xticklabels, ax.get_xticks()))
 2350:         # Testing if the label stayed at the right position
 2351:         assert labels_position["Monday"] == 0.0
 2352:         assert labels_position["Tuesday"] == 1.0
 2353:         assert labels_position["Wednesday"] == 2.0
 2354: 
 2355:     def test_x_multiindex_values_ticks(self):
 2356:         # Test if multiindex plot index have a fixed xtick position
 2357:         # GH: 15912
 2358:         index = MultiIndex.from_product([[2012, 2013], [1, 2]])
 2359:         df = DataFrame(
 2360:             np.random.default_rng(2).standard_normal((4, 2)),
 2361:             columns=["A", "B"],
 2362:             index=index,
 2363:         )
 2364:         ax = df.plot()
 2365:         ax.set_xlim(-1, 4)
 2366:         xticklabels = [t.get_text() for t in ax.get_xticklabels()]
 2367:         labels_position = dict(zip(xticklabels, ax.get_xticks()))
 2368:         # Testing if the label stayed at the right position
 2369:         assert labels_position["(2012, 1)"] == 0.0
 2370:         assert labels_position["(2012, 2)"] == 1.0
 2371:         assert labels_position["(2013, 1)"] == 2.0
 2372:         assert labels_position["(2013, 2)"] == 3.0
 2373: 
 2374:     @pytest.mark.parametrize("kind", ["line", "area"])
 2375:     def test_xlim_plot_line(self, kind):
 2376:         # test if xlim is set correctly in plot.line and plot.area
 2377:         # GH 27686
 2378:         df = DataFrame([2, 4], index=[1, 2])
 2379:         ax = df.plot(kind=kind)
 2380:         xlims = ax.get_xlim()
 2381:         assert xlims[0] < 1
 2382:         assert xlims[1] > 2
 2383: 
 2384:     def test_xlim_plot_line_correctly_in_mixed_plot_type(self):
 2385:         # test if xlim is set correctly when ax contains multiple different kinds
 2386:         # of plots, GH 27686
 2387:         fig, ax = mpl.pyplot.subplots()
 2388: 
 2389:         indexes = ["k1", "k2", "k3", "k4"]
 2390:         df = DataFrame(
 2391:             {
 2392:                 "s1": [1000, 2000, 1500, 2000],
 2393:                 "s2": [900, 1400, 2000, 3000],
 2394:                 "s3": [1500, 1500, 1600, 1200],
 2395:                 "secondary_y": [1, 3, 4, 3],
 2396:             },
 2397:             index=indexes,
 2398:         )
 2399:         df[["s1", "s2", "s3"]].plot.bar(ax=ax, stacked=False)
 2400:         df[["secondary_y"]].plot(ax=ax, secondary_y=True)
 2401: 
 2402:         xlims = ax.get_xlim()
 2403:         assert xlims[0] < 0
 2404:         assert xlims[1] > 3
 2405: 
 2406:         # make sure axis labels are plotted correctly as well
 2407:         xticklabels = [t.get_text() for t in ax.get_xticklabels()]
 2408:         assert xticklabels == indexes
 2409: 
 2410:     def test_plot_no_rows(self):
 2411:         # GH 27758
 2412:         df = DataFrame(columns=["foo"], dtype=int)
 2413:         assert df.empty
 2414:         ax = df.plot()
 2415:         assert len(ax.get_lines()) == 1
 2416:         line = ax.get_lines()[0]
 2417:         assert len(line.get_xdata()) == 0
 2418:         assert len(line.get_ydata()) == 0
 2419: 
 2420:     def test_plot_no_numeric_data(self):
 2421:         df = DataFrame(["a", "b", "c"])
 2422:         with pytest.raises(TypeError, match="no numeric data to plot"):
 2423:             df.plot()
 2424: 
 2425:     @pytest.mark.parametrize(
 2426:         "kind", ("line", "bar", "barh", "hist", "kde", "density", "area", "pie")
 2427:     )
 2428:     def test_group_subplot(self, kind):
 2429:         pytest.importorskip("scipy")
 2430:         d = {
 2431:             "a": np.arange(10),
 2432:             "b": np.arange(10) + 1,
 2433:             "c": np.arange(10) + 1,
 2434:             "d": np.arange(10),
 2435:             "e": np.arange(10),
 2436:         }
 2437:         df = DataFrame(d)
 2438: 
 2439:         axes = df.plot(subplots=[("b", "e"), ("c", "d")], kind=kind)
 2440:         assert len(axes) == 3  # 2 groups + single column a
 2441: 
 2442:         expected_labels = (["b", "e"], ["c", "d"], ["a"])
 2443:         for ax, labels in zip(axes, expected_labels):
 2444:             if kind != "pie":
 2445:                 _check_legend_labels(ax, labels=labels)
 2446:             if kind == "line":
 2447:                 assert len(ax.lines) == len(labels)
 2448: 
 2449:     def test_group_subplot_series_notimplemented(self):
 2450:         ser = Series(range(1))
 2451:         msg = "An iterable subplots for a Series"
 2452:         with pytest.raises(NotImplementedError, match=msg):
 2453:             ser.plot(subplots=[("a",)])
 2454: 
 2455:     def test_group_subplot_multiindex_notimplemented(self):
 2456:         df = DataFrame(np.eye(2), columns=MultiIndex.from_tuples([(0, 1), (1, 2)]))
 2457:         msg = "An iterable subplots for a DataFrame with a MultiIndex"
 2458:         with pytest.raises(NotImplementedError, match=msg):
 2459:             df.plot(subplots=[(0, 1)])
 2460: 
 2461:     def test_group_subplot_nonunique_cols_notimplemented(self):
 2462:         df = DataFrame(np.eye(2), columns=["a", "a"])
 2463:         msg = "An iterable subplots for a DataFrame with non-unique"
 2464:         with pytest.raises(NotImplementedError, match=msg):
 2465:             df.plot(subplots=[("a",)])
 2466: 
 2467:     @pytest.mark.parametrize(
 2468:         "subplots, expected_msg",
 2469:         [
 2470:             (123, "subplots should be a bool or an iterable"),
 2471:             ("a", "each entry should be a list/tuple"),  # iterable of non-iterable
 2472:             ((1,), "each entry should be a list/tuple"),  # iterable of non-iterable
 2473:             (("a",), "each entry should be a list/tuple"),  # iterable of strings
 2474:         ],
 2475:     )
 2476:     def test_group_subplot_bad_input(self, subplots, expected_msg):
 2477:         # Make sure error is raised when subplots is not a properly
 2478:         # formatted iterable. Only iterables of iterables are permitted, and
 2479:         # entries should not be strings.
 2480:         d = {"a": np.arange(10), "b": np.arange(10)}
 2481:         df = DataFrame(d)
 2482: 
 2483:         with pytest.raises(ValueError, match=expected_msg):
 2484:             df.plot(subplots=subplots)
 2485: 
 2486:     def test_group_subplot_invalid_column_name(self):
 2487:         d = {"a": np.arange(10), "b": np.arange(10)}
 2488:         df = DataFrame(d)
 2489: 
 2490:         with pytest.raises(ValueError, match=r"Column label\(s\) \['bad_name'\]"):
 2491:             df.plot(subplots=[("a", "bad_name")])
 2492: 
 2493:     def test_group_subplot_duplicated_column(self):
 2494:         d = {"a": np.arange(10), "b": np.arange(10), "c": np.arange(10)}
 2495:         df = DataFrame(d)
 2496: 
 2497:         with pytest.raises(ValueError, match="should be in only one subplot"):
 2498:             df.plot(subplots=[("a", "b"), ("a", "c")])
 2499: 
 2500:     @pytest.mark.parametrize("kind", ("box", "scatter", "hexbin"))
 2501:     def test_group_subplot_invalid_kind(self, kind):
 2502:         d = {"a": np.arange(10), "b": np.arange(10)}
 2503:         df = DataFrame(d)
 2504:         with pytest.raises(
 2505:             ValueError, match="When subplots is an iterable, kind must be one of"
 2506:         ):
 2507:             df.plot(subplots=[("a", "b")], kind=kind)
 2508: 
 2509:     @pytest.mark.parametrize(
 2510:         "index_name, old_label, new_label",
 2511:         [
 2512:             (None, "", "new"),
 2513:             ("old", "old", "new"),
 2514:             (None, "", ""),
 2515:             (None, "", 1),
 2516:             (None, "", [1, 2]),
 2517:         ],
 2518:     )
 2519:     @pytest.mark.parametrize("kind", ["line", "area", "bar"])
 2520:     def test_xlabel_ylabel_dataframe_single_plot(
 2521:         self, kind, index_name, old_label, new_label
 2522:     ):
 2523:         # GH 9093
 2524:         df = DataFrame([[1, 2], [2, 5]], columns=["Type A", "Type B"])
 2525:         df.index.name = index_name
 2526: 
 2527:         # default is the ylabel is not shown and xlabel is index name
 2528:         ax = df.plot(kind=kind)
 2529:         assert ax.get_xlabel() == old_label
 2530:         assert ax.get_ylabel() == ""
 2531: 
 2532:         # old xlabel will be overridden and assigned ylabel will be used as ylabel
 2533:         ax = df.plot(kind=kind, ylabel=new_label, xlabel=new_label)
 2534:         assert ax.get_ylabel() == str(new_label)
 2535:         assert ax.get_xlabel() == str(new_label)
 2536: 
 2537:     @pytest.mark.parametrize(
 2538:         "xlabel, ylabel",
 2539:         [
 2540:             (None, None),
 2541:             ("X Label", None),
 2542:             (None, "Y Label"),
 2543:             ("X Label", "Y Label"),
 2544:         ],
 2545:     )
 2546:     @pytest.mark.parametrize("kind", ["scatter", "hexbin"])
 2547:     def test_xlabel_ylabel_dataframe_plane_plot(self, kind, xlabel, ylabel):
 2548:         # GH 37001
 2549:         xcol = "Type A"
 2550:         ycol = "Type B"
 2551:         df = DataFrame([[1, 2], [2, 5]], columns=[xcol, ycol])
 2552: 
 2553:         # default is the labels are column names
 2554:         ax = df.plot(kind=kind, x=xcol, y=ycol, xlabel=xlabel, ylabel=ylabel)
 2555:         assert ax.get_xlabel() == (xcol if xlabel is None else xlabel)
 2556:         assert ax.get_ylabel() == (ycol if ylabel is None else ylabel)
 2557: 
 2558:     @pytest.mark.parametrize("secondary_y", (False, True))
 2559:     def test_secondary_y(self, secondary_y):
 2560:         ax_df = DataFrame([0]).plot(
 2561:             secondary_y=secondary_y, ylabel="Y", ylim=(0, 100), yticks=[99]
 2562:         )
 2563:         for ax in ax_df.figure.axes:
 2564:             if ax.yaxis.get_visible():
 2565:                 assert ax.get_ylabel() == "Y"
 2566:                 assert ax.get_ylim() == (0, 100)
 2567:                 assert ax.get_yticks()[0] == 99
 2568: 
 2569:     @pytest.mark.slow
 2570:     def test_plot_no_warning(self):
 2571:         # GH 55138
 2572:         # TODO(3.0): this can be removed once Period[B] deprecation is enforced
 2573:         df = DataFrame(
 2574:             np.random.default_rng(2).standard_normal((10, 4)),
 2575:             columns=Index(list("ABCD"), dtype=object),
 2576:             index=date_range("2000-01-01", periods=10, freq="B"),
 2577:         )
 2578:         with tm.assert_produces_warning(False):
 2579:             _ = df.plot()
 2580:             _ = df.T.plot()
 2581: 
 2582: 
 2583: def _generate_4_axes_via_gridspec():
 2584:     import matplotlib.pyplot as plt
 2585: 
 2586:     gs = mpl.gridspec.GridSpec(2, 2)
 2587:     ax_tl = plt.subplot(gs[0, 0])
 2588:     ax_ll = plt.subplot(gs[1, 0])
 2589:     ax_tr = plt.subplot(gs[0, 1])
 2590:     ax_lr = plt.subplot(gs[1, 1])
 2591: 
 2592:     return gs, [ax_tl, ax_ll, ax_tr, ax_lr]
