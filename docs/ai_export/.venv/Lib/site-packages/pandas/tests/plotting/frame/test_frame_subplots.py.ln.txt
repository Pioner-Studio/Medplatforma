    1: """ Test cases for DataFrame.plot """
    2: 
    3: import string
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas.compat import is_platform_linux
    9: from pandas.compat.numpy import np_version_gte1p24
   10: 
   11: import pandas as pd
   12: from pandas import (
   13:     DataFrame,
   14:     Series,
   15:     date_range,
   16: )
   17: import pandas._testing as tm
   18: from pandas.tests.plotting.common import (
   19:     _check_axes_shape,
   20:     _check_box_return_type,
   21:     _check_legend_labels,
   22:     _check_ticks_props,
   23:     _check_visible,
   24:     _flatten_visible,
   25: )
   26: 
   27: from pandas.io.formats.printing import pprint_thing
   28: 
   29: mpl = pytest.importorskip("matplotlib")
   30: plt = pytest.importorskip("matplotlib.pyplot")
   31: 
   32: 
   33: class TestDataFramePlotsSubplots:
   34:     @pytest.mark.slow
   35:     @pytest.mark.parametrize("kind", ["bar", "barh", "line", "area"])
   36:     def test_subplots(self, kind):
   37:         df = DataFrame(
   38:             np.random.default_rng(2).random((10, 3)),
   39:             index=list(string.ascii_letters[:10]),
   40:         )
   41: 
   42:         axes = df.plot(kind=kind, subplots=True, sharex=True, legend=True)
   43:         _check_axes_shape(axes, axes_num=3, layout=(3, 1))
   44:         assert axes.shape == (3,)
   45: 
   46:         for ax, column in zip(axes, df.columns):
   47:             _check_legend_labels(ax, labels=[pprint_thing(column)])
   48: 
   49:         for ax in axes[:-2]:
   50:             _check_visible(ax.xaxis)  # xaxis must be visible for grid
   51:             _check_visible(ax.get_xticklabels(), visible=False)
   52:             if kind != "bar":
   53:                 # change https://github.com/pandas-dev/pandas/issues/26714
   54:                 _check_visible(ax.get_xticklabels(minor=True), visible=False)
   55:             _check_visible(ax.xaxis.get_label(), visible=False)
   56:             _check_visible(ax.get_yticklabels())
   57: 
   58:         _check_visible(axes[-1].xaxis)
   59:         _check_visible(axes[-1].get_xticklabels())
   60:         _check_visible(axes[-1].get_xticklabels(minor=True))
   61:         _check_visible(axes[-1].xaxis.get_label())
   62:         _check_visible(axes[-1].get_yticklabels())
   63: 
   64:     @pytest.mark.slow
   65:     @pytest.mark.parametrize("kind", ["bar", "barh", "line", "area"])
   66:     def test_subplots_no_share_x(self, kind):
   67:         df = DataFrame(
   68:             np.random.default_rng(2).random((10, 3)),
   69:             index=list(string.ascii_letters[:10]),
   70:         )
   71:         axes = df.plot(kind=kind, subplots=True, sharex=False)
   72:         for ax in axes:
   73:             _check_visible(ax.xaxis)
   74:             _check_visible(ax.get_xticklabels())
   75:             _check_visible(ax.get_xticklabels(minor=True))
   76:             _check_visible(ax.xaxis.get_label())
   77:             _check_visible(ax.get_yticklabels())
   78: 
   79:     @pytest.mark.slow
   80:     @pytest.mark.parametrize("kind", ["bar", "barh", "line", "area"])
   81:     def test_subplots_no_legend(self, kind):
   82:         df = DataFrame(
   83:             np.random.default_rng(2).random((10, 3)),
   84:             index=list(string.ascii_letters[:10]),
   85:         )
   86:         axes = df.plot(kind=kind, subplots=True, legend=False)
   87:         for ax in axes:
   88:             assert ax.get_legend() is None
   89: 
   90:     @pytest.mark.parametrize("kind", ["line", "area"])
   91:     def test_subplots_timeseries(self, kind):
   92:         idx = date_range(start="2014-07-01", freq="ME", periods=10)
   93:         df = DataFrame(np.random.default_rng(2).random((10, 3)), index=idx)
   94: 
   95:         axes = df.plot(kind=kind, subplots=True, sharex=True)
   96:         _check_axes_shape(axes, axes_num=3, layout=(3, 1))
   97: 
   98:         for ax in axes[:-2]:
   99:             # GH 7801
  100:             _check_visible(ax.xaxis)  # xaxis must be visible for grid
  101:             _check_visible(ax.get_xticklabels(), visible=False)
  102:             _check_visible(ax.get_xticklabels(minor=True), visible=False)
  103:             _check_visible(ax.xaxis.get_label(), visible=False)
  104:             _check_visible(ax.get_yticklabels())
  105: 
  106:         _check_visible(axes[-1].xaxis)
  107:         _check_visible(axes[-1].get_xticklabels())
  108:         _check_visible(axes[-1].get_xticklabels(minor=True))
  109:         _check_visible(axes[-1].xaxis.get_label())
  110:         _check_visible(axes[-1].get_yticklabels())
  111:         _check_ticks_props(axes, xrot=0)
  112: 
  113:     @pytest.mark.parametrize("kind", ["line", "area"])
  114:     def test_subplots_timeseries_rot(self, kind):
  115:         idx = date_range(start="2014-07-01", freq="ME", periods=10)
  116:         df = DataFrame(np.random.default_rng(2).random((10, 3)), index=idx)
  117:         axes = df.plot(kind=kind, subplots=True, sharex=False, rot=45, fontsize=7)
  118:         for ax in axes:
  119:             _check_visible(ax.xaxis)
  120:             _check_visible(ax.get_xticklabels())
  121:             _check_visible(ax.get_xticklabels(minor=True))
  122:             _check_visible(ax.xaxis.get_label())
  123:             _check_visible(ax.get_yticklabels())
  124:             _check_ticks_props(ax, xlabelsize=7, xrot=45, ylabelsize=7)
  125: 
  126:     @pytest.mark.parametrize(
  127:         "col", ["numeric", "timedelta", "datetime_no_tz", "datetime_all_tz"]
  128:     )
  129:     def test_subplots_timeseries_y_axis(self, col):
  130:         # GH16953
  131:         data = {
  132:             "numeric": np.array([1, 2, 5]),
  133:             "timedelta": [
  134:                 pd.Timedelta(-10, unit="s"),
  135:                 pd.Timedelta(10, unit="m"),
  136:                 pd.Timedelta(10, unit="h"),
  137:             ],
  138:             "datetime_no_tz": [
  139:                 pd.to_datetime("2017-08-01 00:00:00"),
  140:                 pd.to_datetime("2017-08-01 02:00:00"),
  141:                 pd.to_datetime("2017-08-02 00:00:00"),
  142:             ],
  143:             "datetime_all_tz": [
  144:                 pd.to_datetime("2017-08-01 00:00:00", utc=True),
  145:                 pd.to_datetime("2017-08-01 02:00:00", utc=True),
  146:                 pd.to_datetime("2017-08-02 00:00:00", utc=True),
  147:             ],
  148:             "text": ["This", "should", "fail"],
  149:         }
  150:         testdata = DataFrame(data)
  151: 
  152:         ax = testdata.plot(y=col)
  153:         result = ax.get_lines()[0].get_data()[1]
  154:         expected = testdata[col].values
  155:         assert (result == expected).all()
  156: 
  157:     def test_subplots_timeseries_y_text_error(self):
  158:         # GH16953
  159:         data = {
  160:             "numeric": np.array([1, 2, 5]),
  161:             "text": ["This", "should", "fail"],
  162:         }
  163:         testdata = DataFrame(data)
  164:         msg = "no numeric data to plot"
  165:         with pytest.raises(TypeError, match=msg):
  166:             testdata.plot(y="text")
  167: 
  168:     @pytest.mark.xfail(reason="not support for period, categorical, datetime_mixed_tz")
  169:     def test_subplots_timeseries_y_axis_not_supported(self):
  170:         """
  171:         This test will fail for:
  172:             period:
  173:                 since period isn't yet implemented in ``select_dtypes``
  174:                 and because it will need a custom value converter +
  175:                 tick formatter (as was done for x-axis plots)
  176: 
  177:             categorical:
  178:                  because it will need a custom value converter +
  179:                  tick formatter (also doesn't work for x-axis, as of now)
  180: 
  181:             datetime_mixed_tz:
  182:                 because of the way how pandas handles ``Series`` of
  183:                 ``datetime`` objects with different timezone,
  184:                 generally converting ``datetime`` objects in a tz-aware
  185:                 form could help with this problem
  186:         """
  187:         data = {
  188:             "numeric": np.array([1, 2, 5]),
  189:             "period": [
  190:                 pd.Period("2017-08-01 00:00:00", freq="H"),
  191:                 pd.Period("2017-08-01 02:00", freq="H"),
  192:                 pd.Period("2017-08-02 00:00:00", freq="H"),
  193:             ],
  194:             "categorical": pd.Categorical(
  195:                 ["c", "b", "a"], categories=["a", "b", "c"], ordered=False
  196:             ),
  197:             "datetime_mixed_tz": [
  198:                 pd.to_datetime("2017-08-01 00:00:00", utc=True),
  199:                 pd.to_datetime("2017-08-01 02:00:00"),
  200:                 pd.to_datetime("2017-08-02 00:00:00"),
  201:             ],
  202:         }
  203:         testdata = DataFrame(data)
  204:         ax_period = testdata.plot(x="numeric", y="period")
  205:         assert (
  206:             ax_period.get_lines()[0].get_data()[1] == testdata["period"].values
  207:         ).all()
  208:         ax_categorical = testdata.plot(x="numeric", y="categorical")
  209:         assert (
  210:             ax_categorical.get_lines()[0].get_data()[1]
  211:             == testdata["categorical"].values
  212:         ).all()
  213:         ax_datetime_mixed_tz = testdata.plot(x="numeric", y="datetime_mixed_tz")
  214:         assert (
  215:             ax_datetime_mixed_tz.get_lines()[0].get_data()[1]
  216:             == testdata["datetime_mixed_tz"].values
  217:         ).all()
  218: 
  219:     @pytest.mark.parametrize(
  220:         "layout, exp_layout",
  221:         [
  222:             [(2, 2), (2, 2)],
  223:             [(-1, 2), (2, 2)],
  224:             [(2, -1), (2, 2)],
  225:             [(1, 4), (1, 4)],
  226:             [(-1, 4), (1, 4)],
  227:             [(4, -1), (4, 1)],
  228:         ],
  229:     )
  230:     def test_subplots_layout_multi_column(self, layout, exp_layout):
  231:         # GH 6667
  232:         df = DataFrame(
  233:             np.random.default_rng(2).random((10, 3)),
  234:             index=list(string.ascii_letters[:10]),
  235:         )
  236: 
  237:         axes = df.plot(subplots=True, layout=layout)
  238:         _check_axes_shape(axes, axes_num=3, layout=exp_layout)
  239:         assert axes.shape == exp_layout
  240: 
  241:     def test_subplots_layout_multi_column_error(self):
  242:         # GH 6667
  243:         df = DataFrame(
  244:             np.random.default_rng(2).random((10, 3)),
  245:             index=list(string.ascii_letters[:10]),
  246:         )
  247:         msg = "Layout of 1x1 must be larger than required size 3"
  248: 
  249:         with pytest.raises(ValueError, match=msg):
  250:             df.plot(subplots=True, layout=(1, 1))
  251: 
  252:         msg = "At least one dimension of layout must be positive"
  253:         with pytest.raises(ValueError, match=msg):
  254:             df.plot(subplots=True, layout=(-1, -1))
  255: 
  256:     @pytest.mark.parametrize(
  257:         "kwargs, expected_axes_num, expected_layout, expected_shape",
  258:         [
  259:             ({}, 1, (1, 1), (1,)),
  260:             ({"layout": (3, 3)}, 1, (3, 3), (3, 3)),
  261:         ],
  262:     )
  263:     def test_subplots_layout_single_column(
  264:         self, kwargs, expected_axes_num, expected_layout, expected_shape
  265:     ):
  266:         # GH 6667
  267:         df = DataFrame(
  268:             np.random.default_rng(2).random((10, 1)),
  269:             index=list(string.ascii_letters[:10]),
  270:         )
  271:         axes = df.plot(subplots=True, **kwargs)
  272:         _check_axes_shape(
  273:             axes,
  274:             axes_num=expected_axes_num,
  275:             layout=expected_layout,
  276:         )
  277:         assert axes.shape == expected_shape
  278: 
  279:     @pytest.mark.slow
  280:     @pytest.mark.parametrize("idx", [range(5), date_range("1/1/2000", periods=5)])
  281:     def test_subplots_warnings(self, idx):
  282:         # GH 9464
  283:         with tm.assert_produces_warning(None):
  284:             df = DataFrame(np.random.default_rng(2).standard_normal((5, 4)), index=idx)
  285:             df.plot(subplots=True, layout=(3, 2))
  286: 
  287:     def test_subplots_multiple_axes(self):
  288:         # GH 5353, 6970, GH 7069
  289:         fig, axes = mpl.pyplot.subplots(2, 3)
  290:         df = DataFrame(
  291:             np.random.default_rng(2).random((10, 3)),
  292:             index=list(string.ascii_letters[:10]),
  293:         )
  294: 
  295:         returned = df.plot(subplots=True, ax=axes[0], sharex=False, sharey=False)
  296:         _check_axes_shape(returned, axes_num=3, layout=(1, 3))
  297:         assert returned.shape == (3,)
  298:         assert returned[0].figure is fig
  299:         # draw on second row
  300:         returned = df.plot(subplots=True, ax=axes[1], sharex=False, sharey=False)
  301:         _check_axes_shape(returned, axes_num=3, layout=(1, 3))
  302:         assert returned.shape == (3,)
  303:         assert returned[0].figure is fig
  304:         _check_axes_shape(axes, axes_num=6, layout=(2, 3))
  305: 
  306:     def test_subplots_multiple_axes_error(self):
  307:         # GH 5353, 6970, GH 7069
  308:         df = DataFrame(
  309:             np.random.default_rng(2).random((10, 3)),
  310:             index=list(string.ascii_letters[:10]),
  311:         )
  312:         msg = "The number of passed axes must be 3, the same as the output plot"
  313:         _, axes = mpl.pyplot.subplots(2, 3)
  314: 
  315:         with pytest.raises(ValueError, match=msg):
  316:             # pass different number of axes from required
  317:             df.plot(subplots=True, ax=axes)
  318: 
  319:     @pytest.mark.parametrize(
  320:         "layout, exp_layout",
  321:         [
  322:             [(2, 1), (2, 2)],
  323:             [(2, -1), (2, 2)],
  324:             [(-1, 2), (2, 2)],
  325:         ],
  326:     )
  327:     def test_subplots_multiple_axes_2_dim(self, layout, exp_layout):
  328:         # GH 5353, 6970, GH 7069
  329:         # pass 2-dim axes and invalid layout
  330:         # invalid lauout should not affect to input and return value
  331:         # (show warning is tested in
  332:         # TestDataFrameGroupByPlots.test_grouped_box_multiple_axes
  333:         _, axes = mpl.pyplot.subplots(2, 2)
  334:         df = DataFrame(
  335:             np.random.default_rng(2).random((10, 4)),
  336:             index=list(string.ascii_letters[:10]),
  337:         )
  338:         with tm.assert_produces_warning(UserWarning):
  339:             returned = df.plot(
  340:                 subplots=True, ax=axes, layout=layout, sharex=False, sharey=False
  341:             )
  342:             _check_axes_shape(returned, axes_num=4, layout=exp_layout)
  343:             assert returned.shape == (4,)
  344: 
  345:     def test_subplots_multiple_axes_single_col(self):
  346:         # GH 5353, 6970, GH 7069
  347:         # single column
  348:         _, axes = mpl.pyplot.subplots(1, 1)
  349:         df = DataFrame(
  350:             np.random.default_rng(2).random((10, 1)),
  351:             index=list(string.ascii_letters[:10]),
  352:         )
  353: 
  354:         axes = df.plot(subplots=True, ax=[axes], sharex=False, sharey=False)
  355:         _check_axes_shape(axes, axes_num=1, layout=(1, 1))
  356:         assert axes.shape == (1,)
  357: 
  358:     def test_subplots_ts_share_axes(self):
  359:         # GH 3964
  360:         _, axes = mpl.pyplot.subplots(3, 3, sharex=True, sharey=True)
  361:         mpl.pyplot.subplots_adjust(left=0.05, right=0.95, hspace=0.3, wspace=0.3)
  362:         df = DataFrame(
  363:             np.random.default_rng(2).standard_normal((10, 9)),
  364:             index=date_range(start="2014-07-01", freq="ME", periods=10),
  365:         )
  366:         for i, ax in enumerate(axes.ravel()):
  367:             df[i].plot(ax=ax, fontsize=5)
  368: 
  369:         # Rows other than bottom should not be visible
  370:         for ax in axes[0:-1].ravel():
  371:             _check_visible(ax.get_xticklabels(), visible=False)
  372: 
  373:         # Bottom row should be visible
  374:         for ax in axes[-1].ravel():
  375:             _check_visible(ax.get_xticklabels(), visible=True)
  376: 
  377:         # First column should be visible
  378:         for ax in axes[[0, 1, 2], [0]].ravel():
  379:             _check_visible(ax.get_yticklabels(), visible=True)
  380: 
  381:         # Other columns should not be visible
  382:         for ax in axes[[0, 1, 2], [1]].ravel():
  383:             _check_visible(ax.get_yticklabels(), visible=False)
  384:         for ax in axes[[0, 1, 2], [2]].ravel():
  385:             _check_visible(ax.get_yticklabels(), visible=False)
  386: 
  387:     def test_subplots_sharex_axes_existing_axes(self):
  388:         # GH 9158
  389:         d = {"A": [1.0, 2.0, 3.0, 4.0], "B": [4.0, 3.0, 2.0, 1.0], "C": [5, 1, 3, 4]}
  390:         df = DataFrame(d, index=date_range("2014 10 11", "2014 10 14"))
  391: 
  392:         axes = df[["A", "B"]].plot(subplots=True)
  393:         df["C"].plot(ax=axes[0], secondary_y=True)
  394: 
  395:         _check_visible(axes[0].get_xticklabels(), visible=False)
  396:         _check_visible(axes[1].get_xticklabels(), visible=True)
  397:         for ax in axes.ravel():
  398:             _check_visible(ax.get_yticklabels(), visible=True)
  399: 
  400:     def test_subplots_dup_columns(self):
  401:         # GH 10962
  402:         df = DataFrame(np.random.default_rng(2).random((5, 5)), columns=list("aaaaa"))
  403:         axes = df.plot(subplots=True)
  404:         for ax in axes:
  405:             _check_legend_labels(ax, labels=["a"])
  406:             assert len(ax.lines) == 1
  407: 
  408:     def test_subplots_dup_columns_secondary_y(self):
  409:         # GH 10962
  410:         df = DataFrame(np.random.default_rng(2).random((5, 5)), columns=list("aaaaa"))
  411:         axes = df.plot(subplots=True, secondary_y="a")
  412:         for ax in axes:
  413:             # (right) is only attached when subplots=False
  414:             _check_legend_labels(ax, labels=["a"])
  415:             assert len(ax.lines) == 1
  416: 
  417:     def test_subplots_dup_columns_secondary_y_no_subplot(self):
  418:         # GH 10962
  419:         df = DataFrame(np.random.default_rng(2).random((5, 5)), columns=list("aaaaa"))
  420:         ax = df.plot(secondary_y="a")
  421:         _check_legend_labels(ax, labels=["a (right)"] * 5)
  422:         assert len(ax.lines) == 0
  423:         assert len(ax.right_ax.lines) == 5
  424: 
  425:     @pytest.mark.xfail(
  426:         np_version_gte1p24 and is_platform_linux(),
  427:         reason="Weird rounding problems",
  428:         strict=False,
  429:     )
  430:     def test_bar_log_no_subplots(self):
  431:         # GH3254, GH3298 matplotlib/matplotlib#1882, #1892
  432:         # regressions in 1.2.1
  433:         expected = np.array([0.1, 1.0, 10.0, 100])
  434: 
  435:         # no subplots
  436:         df = DataFrame({"A": [3] * 5, "B": list(range(1, 6))}, index=range(5))
  437:         ax = df.plot.bar(grid=True, log=True)
  438:         tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), expected)
  439: 
  440:     @pytest.mark.xfail(
  441:         np_version_gte1p24 and is_platform_linux(),
  442:         reason="Weird rounding problems",
  443:         strict=False,
  444:     )
  445:     def test_bar_log_subplots(self):
  446:         expected = np.array([0.1, 1.0, 10.0, 100.0, 1000.0, 1e4])
  447: 
  448:         ax = DataFrame([Series([200, 300]), Series([300, 500])]).plot.bar(
  449:             log=True, subplots=True
  450:         )
  451: 
  452:         tm.assert_numpy_array_equal(ax[0].yaxis.get_ticklocs(), expected)
  453:         tm.assert_numpy_array_equal(ax[1].yaxis.get_ticklocs(), expected)
  454: 
  455:     def test_boxplot_subplots_return_type_default(self, hist_df):
  456:         df = hist_df
  457: 
  458:         # normal style: return_type=None
  459:         result = df.plot.box(subplots=True)
  460:         assert isinstance(result, Series)
  461:         _check_box_return_type(
  462:             result, None, expected_keys=["height", "weight", "category"]
  463:         )
  464: 
  465:     @pytest.mark.parametrize("rt", ["dict", "axes", "both"])
  466:     def test_boxplot_subplots_return_type(self, hist_df, rt):
  467:         df = hist_df
  468:         returned = df.plot.box(return_type=rt, subplots=True)
  469:         _check_box_return_type(
  470:             returned,
  471:             rt,
  472:             expected_keys=["height", "weight", "category"],
  473:             check_ax_title=False,
  474:         )
  475: 
  476:     def test_df_subplots_patterns_minorticks(self):
  477:         # GH 10657
  478:         df = DataFrame(
  479:             np.random.default_rng(2).standard_normal((10, 2)),
  480:             index=date_range("1/1/2000", periods=10),
  481:             columns=list("AB"),
  482:         )
  483: 
  484:         # shared subplots
  485:         _, axes = plt.subplots(2, 1, sharex=True)
  486:         axes = df.plot(subplots=True, ax=axes)
  487:         for ax in axes:
  488:             assert len(ax.lines) == 1
  489:             _check_visible(ax.get_yticklabels(), visible=True)
  490:         # xaxis of 1st ax must be hidden
  491:         _check_visible(axes[0].get_xticklabels(), visible=False)
  492:         _check_visible(axes[0].get_xticklabels(minor=True), visible=False)
  493:         _check_visible(axes[1].get_xticklabels(), visible=True)
  494:         _check_visible(axes[1].get_xticklabels(minor=True), visible=True)
  495: 
  496:     def test_df_subplots_patterns_minorticks_1st_ax_hidden(self):
  497:         # GH 10657
  498:         df = DataFrame(
  499:             np.random.default_rng(2).standard_normal((10, 2)),
  500:             index=date_range("1/1/2000", periods=10),
  501:             columns=list("AB"),
  502:         )
  503:         _, axes = plt.subplots(2, 1)
  504:         with tm.assert_produces_warning(UserWarning):
  505:             axes = df.plot(subplots=True, ax=axes, sharex=True)
  506:         for ax in axes:
  507:             assert len(ax.lines) == 1
  508:             _check_visible(ax.get_yticklabels(), visible=True)
  509:         # xaxis of 1st ax must be hidden
  510:         _check_visible(axes[0].get_xticklabels(), visible=False)
  511:         _check_visible(axes[0].get_xticklabels(minor=True), visible=False)
  512:         _check_visible(axes[1].get_xticklabels(), visible=True)
  513:         _check_visible(axes[1].get_xticklabels(minor=True), visible=True)
  514: 
  515:     def test_df_subplots_patterns_minorticks_not_shared(self):
  516:         # GH 10657
  517:         df = DataFrame(
  518:             np.random.default_rng(2).standard_normal((10, 2)),
  519:             index=date_range("1/1/2000", periods=10),
  520:             columns=list("AB"),
  521:         )
  522:         # not shared
  523:         _, axes = plt.subplots(2, 1)
  524:         axes = df.plot(subplots=True, ax=axes)
  525:         for ax in axes:
  526:             assert len(ax.lines) == 1
  527:             _check_visible(ax.get_yticklabels(), visible=True)
  528:             _check_visible(ax.get_xticklabels(), visible=True)
  529:             _check_visible(ax.get_xticklabels(minor=True), visible=True)
  530: 
  531:     def test_subplots_sharex_false(self):
  532:         # test when sharex is set to False, two plots should have different
  533:         # labels, GH 25160
  534:         df = DataFrame(np.random.default_rng(2).random((10, 2)))
  535:         df.iloc[5:, 1] = np.nan
  536:         df.iloc[:5, 0] = np.nan
  537: 
  538:         _, axs = mpl.pyplot.subplots(2, 1)
  539:         df.plot.line(ax=axs, subplots=True, sharex=False)
  540: 
  541:         expected_ax1 = np.arange(4.5, 10, 0.5)
  542:         expected_ax2 = np.arange(-0.5, 5, 0.5)
  543: 
  544:         tm.assert_numpy_array_equal(axs[0].get_xticks(), expected_ax1)
  545:         tm.assert_numpy_array_equal(axs[1].get_xticks(), expected_ax2)
  546: 
  547:     def test_subplots_constrained_layout(self):
  548:         # GH 25261
  549:         idx = date_range(start="now", periods=10)
  550:         df = DataFrame(np.random.default_rng(2).random((10, 3)), index=idx)
  551:         kwargs = {}
  552:         if hasattr(mpl.pyplot.Figure, "get_constrained_layout"):
  553:             kwargs["constrained_layout"] = True
  554:         _, axes = mpl.pyplot.subplots(2, **kwargs)
  555:         with tm.assert_produces_warning(None):
  556:             df.plot(ax=axes[0])
  557:             with tm.ensure_clean(return_filelike=True) as path:
  558:                 mpl.pyplot.savefig(path)
  559: 
  560:     @pytest.mark.parametrize(
  561:         "index_name, old_label, new_label",
  562:         [
  563:             (None, "", "new"),
  564:             ("old", "old", "new"),
  565:             (None, "", ""),
  566:             (None, "", 1),
  567:             (None, "", [1, 2]),
  568:         ],
  569:     )
  570:     @pytest.mark.parametrize("kind", ["line", "area", "bar"])
  571:     def test_xlabel_ylabel_dataframe_subplots(
  572:         self, kind, index_name, old_label, new_label
  573:     ):
  574:         # GH 9093
  575:         df = DataFrame([[1, 2], [2, 5]], columns=["Type A", "Type B"])
  576:         df.index.name = index_name
  577: 
  578:         # default is the ylabel is not shown and xlabel is index name
  579:         axes = df.plot(kind=kind, subplots=True)
  580:         assert all(ax.get_ylabel() == "" for ax in axes)
  581:         assert all(ax.get_xlabel() == old_label for ax in axes)
  582: 
  583:         # old xlabel will be overridden and assigned ylabel will be used as ylabel
  584:         axes = df.plot(kind=kind, ylabel=new_label, xlabel=new_label, subplots=True)
  585:         assert all(ax.get_ylabel() == str(new_label) for ax in axes)
  586:         assert all(ax.get_xlabel() == str(new_label) for ax in axes)
  587: 
  588:     @pytest.mark.parametrize(
  589:         "kwargs",
  590:         [
  591:             # stacked center
  592:             {"kind": "bar", "stacked": True},
  593:             {"kind": "bar", "stacked": True, "width": 0.9},
  594:             {"kind": "barh", "stacked": True},
  595:             {"kind": "barh", "stacked": True, "width": 0.9},
  596:             # center
  597:             {"kind": "bar", "stacked": False},
  598:             {"kind": "bar", "stacked": False, "width": 0.9},
  599:             {"kind": "barh", "stacked": False},
  600:             {"kind": "barh", "stacked": False, "width": 0.9},
  601:             # subplots center
  602:             {"kind": "bar", "subplots": True},
  603:             {"kind": "bar", "subplots": True, "width": 0.9},
  604:             {"kind": "barh", "subplots": True},
  605:             {"kind": "barh", "subplots": True, "width": 0.9},
  606:             # align edge
  607:             {"kind": "bar", "stacked": True, "align": "edge"},
  608:             {"kind": "bar", "stacked": True, "width": 0.9, "align": "edge"},
  609:             {"kind": "barh", "stacked": True, "align": "edge"},
  610:             {"kind": "barh", "stacked": True, "width": 0.9, "align": "edge"},
  611:             {"kind": "bar", "stacked": False, "align": "edge"},
  612:             {"kind": "bar", "stacked": False, "width": 0.9, "align": "edge"},
  613:             {"kind": "barh", "stacked": False, "align": "edge"},
  614:             {"kind": "barh", "stacked": False, "width": 0.9, "align": "edge"},
  615:             {"kind": "bar", "subplots": True, "align": "edge"},
  616:             {"kind": "bar", "subplots": True, "width": 0.9, "align": "edge"},
  617:             {"kind": "barh", "subplots": True, "align": "edge"},
  618:             {"kind": "barh", "subplots": True, "width": 0.9, "align": "edge"},
  619:         ],
  620:     )
  621:     def test_bar_align_multiple_columns(self, kwargs):
  622:         # GH2157
  623:         df = DataFrame({"A": [3] * 5, "B": list(range(5))}, index=range(5))
  624:         self._check_bar_alignment(df, **kwargs)
  625: 
  626:     @pytest.mark.parametrize(
  627:         "kwargs",
  628:         [
  629:             {"kind": "bar", "stacked": False},
  630:             {"kind": "bar", "stacked": True},
  631:             {"kind": "barh", "stacked": False},
  632:             {"kind": "barh", "stacked": True},
  633:             {"kind": "bar", "subplots": True},
  634:             {"kind": "barh", "subplots": True},
  635:         ],
  636:     )
  637:     def test_bar_align_single_column(self, kwargs):
  638:         df = DataFrame(np.random.default_rng(2).standard_normal(5))
  639:         self._check_bar_alignment(df, **kwargs)
  640: 
  641:     @pytest.mark.parametrize(
  642:         "kwargs",
  643:         [
  644:             {"kind": "bar", "stacked": False},
  645:             {"kind": "bar", "stacked": True},
  646:             {"kind": "barh", "stacked": False},
  647:             {"kind": "barh", "stacked": True},
  648:             {"kind": "bar", "subplots": True},
  649:             {"kind": "barh", "subplots": True},
  650:         ],
  651:     )
  652:     def test_bar_barwidth_position(self, kwargs):
  653:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)))
  654:         self._check_bar_alignment(df, width=0.9, position=0.2, **kwargs)
  655: 
  656:     @pytest.mark.parametrize("w", [1, 1.0])
  657:     def test_bar_barwidth_position_int(self, w):
  658:         # GH 12979
  659:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)))
  660:         ax = df.plot.bar(stacked=True, width=w)
  661:         ticks = ax.xaxis.get_ticklocs()
  662:         tm.assert_numpy_array_equal(ticks, np.array([0, 1, 2, 3, 4]))
  663:         assert ax.get_xlim() == (-0.75, 4.75)
  664:         # check left-edge of bars
  665:         assert ax.patches[0].get_x() == -0.5
  666:         assert ax.patches[-1].get_x() == 3.5
  667: 
  668:     @pytest.mark.parametrize(
  669:         "kind, kwargs",
  670:         [
  671:             ["bar", {"stacked": True}],
  672:             ["barh", {"stacked": False}],
  673:             ["barh", {"stacked": True}],
  674:             ["bar", {"subplots": True}],
  675:             ["barh", {"subplots": True}],
  676:         ],
  677:     )
  678:     def test_bar_barwidth_position_int_width_1(self, kind, kwargs):
  679:         # GH 12979
  680:         df = DataFrame(np.random.default_rng(2).standard_normal((5, 5)))
  681:         self._check_bar_alignment(df, kind=kind, width=1, **kwargs)
  682: 
  683:     def _check_bar_alignment(
  684:         self,
  685:         df,
  686:         kind="bar",
  687:         stacked=False,
  688:         subplots=False,
  689:         align="center",
  690:         width=0.5,
  691:         position=0.5,
  692:     ):
  693:         axes = df.plot(
  694:             kind=kind,
  695:             stacked=stacked,
  696:             subplots=subplots,
  697:             align=align,
  698:             width=width,
  699:             position=position,
  700:             grid=True,
  701:         )
  702: 
  703:         axes = _flatten_visible(axes)
  704: 
  705:         for ax in axes:
  706:             if kind == "bar":
  707:                 axis = ax.xaxis
  708:                 ax_min, ax_max = ax.get_xlim()
  709:                 min_edge = min(p.get_x() for p in ax.patches)
  710:                 max_edge = max(p.get_x() + p.get_width() for p in ax.patches)
  711:             elif kind == "barh":
  712:                 axis = ax.yaxis
  713:                 ax_min, ax_max = ax.get_ylim()
  714:                 min_edge = min(p.get_y() for p in ax.patches)
  715:                 max_edge = max(p.get_y() + p.get_height() for p in ax.patches)
  716:             else:
  717:                 raise ValueError
  718: 
  719:             # GH 7498
  720:             # compare margins between lim and bar edges
  721:             tm.assert_almost_equal(ax_min, min_edge - 0.25)
  722:             tm.assert_almost_equal(ax_max, max_edge + 0.25)
  723: 
  724:             p = ax.patches[0]
  725:             if kind == "bar" and (stacked is True or subplots is True):
  726:                 edge = p.get_x()
  727:                 center = edge + p.get_width() * position
  728:             elif kind == "bar" and stacked is False:
  729:                 center = p.get_x() + p.get_width() * len(df.columns) * position
  730:                 edge = p.get_x()
  731:             elif kind == "barh" and (stacked is True or subplots is True):
  732:                 center = p.get_y() + p.get_height() * position
  733:                 edge = p.get_y()
  734:             elif kind == "barh" and stacked is False:
  735:                 center = p.get_y() + p.get_height() * len(df.columns) * position
  736:                 edge = p.get_y()
  737:             else:
  738:                 raise ValueError
  739: 
  740:             # Check the ticks locates on integer
  741:             assert (axis.get_ticklocs() == np.arange(len(df))).all()
  742: 
  743:             if align == "center":
  744:                 # Check whether the bar locates on center
  745:                 tm.assert_almost_equal(axis.get_ticklocs()[0], center)
  746:             elif align == "edge":
  747:                 # Check whether the bar's edge starts from the tick
  748:                 tm.assert_almost_equal(axis.get_ticklocs()[0], edge)
  749:             else:
  750:                 raise ValueError
  751: 
  752:         return axes
