    1: """ Test cases for time series specific (freq conversion, etc) """
    2: from datetime import (
    3:     date,
    4:     datetime,
    5:     time,
    6:     timedelta,
    7: )
    8: import pickle
    9: 
   10: import numpy as np
   11: import pytest
   12: 
   13: from pandas._libs.tslibs import (
   14:     BaseOffset,
   15:     to_offset,
   16: )
   17: from pandas._libs.tslibs.dtypes import freq_to_period_freqstr
   18: 
   19: from pandas import (
   20:     DataFrame,
   21:     Index,
   22:     NaT,
   23:     Series,
   24:     concat,
   25:     isna,
   26:     to_datetime,
   27: )
   28: import pandas._testing as tm
   29: from pandas.core.indexes.datetimes import (
   30:     DatetimeIndex,
   31:     bdate_range,
   32:     date_range,
   33: )
   34: from pandas.core.indexes.period import (
   35:     Period,
   36:     PeriodIndex,
   37:     period_range,
   38: )
   39: from pandas.core.indexes.timedeltas import timedelta_range
   40: from pandas.tests.plotting.common import _check_ticks_props
   41: 
   42: from pandas.tseries.offsets import WeekOfMonth
   43: 
   44: mpl = pytest.importorskip("matplotlib")
   45: 
   46: 
   47: class TestTSPlot:
   48:     @pytest.mark.filterwarnings("ignore::UserWarning")
   49:     def test_ts_plot_with_tz(self, tz_aware_fixture):
   50:         # GH2877, GH17173, GH31205, GH31580
   51:         tz = tz_aware_fixture
   52:         index = date_range("1/1/2011", periods=2, freq="h", tz=tz)
   53:         ts = Series([188.5, 328.25], index=index)
   54:         _check_plot_works(ts.plot)
   55:         ax = ts.plot()
   56:         xdata = next(iter(ax.get_lines())).get_xdata()
   57:         # Check first and last points' labels are correct
   58:         assert (xdata[0].hour, xdata[0].minute) == (0, 0)
   59:         assert (xdata[-1].hour, xdata[-1].minute) == (1, 0)
   60: 
   61:     def test_fontsize_set_correctly(self):
   62:         # For issue #8765
   63:         df = DataFrame(
   64:             np.random.default_rng(2).standard_normal((10, 9)), index=range(10)
   65:         )
   66:         _, ax = mpl.pyplot.subplots()
   67:         df.plot(fontsize=2, ax=ax)
   68:         for label in ax.get_xticklabels() + ax.get_yticklabels():
   69:             assert label.get_fontsize() == 2
   70: 
   71:     def test_frame_inferred(self):
   72:         # inferred freq
   73:         idx = date_range("1/1/1987", freq="MS", periods=100)
   74:         idx = DatetimeIndex(idx.values, freq=None)
   75: 
   76:         df = DataFrame(
   77:             np.random.default_rng(2).standard_normal((len(idx), 3)), index=idx
   78:         )
   79:         _check_plot_works(df.plot)
   80: 
   81:         # axes freq
   82:         idx = idx[0:40].union(idx[45:99])
   83:         df2 = DataFrame(
   84:             np.random.default_rng(2).standard_normal((len(idx), 3)), index=idx
   85:         )
   86:         _check_plot_works(df2.plot)
   87: 
   88:     def test_frame_inferred_n_gt_1(self):
   89:         # N > 1
   90:         idx = date_range("2008-1-1 00:15:00", freq="15min", periods=10)
   91:         idx = DatetimeIndex(idx.values, freq=None)
   92:         df = DataFrame(
   93:             np.random.default_rng(2).standard_normal((len(idx), 3)), index=idx
   94:         )
   95:         _check_plot_works(df.plot)
   96: 
   97:     def test_is_error_nozeroindex(self):
   98:         # GH11858
   99:         i = np.array([1, 2, 3])
  100:         a = DataFrame(i, index=i)
  101:         _check_plot_works(a.plot, xerr=a)
  102:         _check_plot_works(a.plot, yerr=a)
  103: 
  104:     def test_nonnumeric_exclude(self):
  105:         idx = date_range("1/1/1987", freq="YE", periods=3)
  106:         df = DataFrame({"A": ["x", "y", "z"], "B": [1, 2, 3]}, idx)
  107: 
  108:         fig, ax = mpl.pyplot.subplots()
  109:         df.plot(ax=ax)  # it works
  110:         assert len(ax.get_lines()) == 1  # B was plotted
  111:         mpl.pyplot.close(fig)
  112: 
  113:     def test_nonnumeric_exclude_error(self):
  114:         idx = date_range("1/1/1987", freq="YE", periods=3)
  115:         df = DataFrame({"A": ["x", "y", "z"], "B": [1, 2, 3]}, idx)
  116:         msg = "no numeric data to plot"
  117:         with pytest.raises(TypeError, match=msg):
  118:             df["A"].plot()
  119: 
  120:     @pytest.mark.parametrize("freq", ["s", "min", "h", "D", "W", "M", "Q", "Y"])
  121:     def test_tsplot_period(self, freq):
  122:         idx = period_range("12/31/1999", freq=freq, periods=100)
  123:         ser = Series(np.random.default_rng(2).standard_normal(len(idx)), idx)
  124:         _, ax = mpl.pyplot.subplots()
  125:         _check_plot_works(ser.plot, ax=ax)
  126: 
  127:     @pytest.mark.parametrize(
  128:         "freq", ["s", "min", "h", "D", "W", "ME", "QE-DEC", "YE", "1B30Min"]
  129:     )
  130:     def test_tsplot_datetime(self, freq):
  131:         idx = date_range("12/31/1999", freq=freq, periods=100)
  132:         ser = Series(np.random.default_rng(2).standard_normal(len(idx)), idx)
  133:         _, ax = mpl.pyplot.subplots()
  134:         _check_plot_works(ser.plot, ax=ax)
  135: 
  136:     def test_tsplot(self):
  137:         ts = Series(
  138:             np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
  139:         )
  140:         _, ax = mpl.pyplot.subplots()
  141:         ts.plot(style="k", ax=ax)
  142:         color = (0.0, 0.0, 0.0, 1)
  143:         assert color == ax.get_lines()[0].get_color()
  144: 
  145:     def test_both_style_and_color(self):
  146:         ts = Series(
  147:             np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
  148:         )
  149:         msg = (
  150:             "Cannot pass 'style' string with a color symbol and 'color' "
  151:             "keyword argument. Please use one or the other or pass 'style' "
  152:             "without a color symbol"
  153:         )
  154:         with pytest.raises(ValueError, match=msg):
  155:             ts.plot(style="b-", color="#000099")
  156: 
  157:         s = ts.reset_index(drop=True)
  158:         with pytest.raises(ValueError, match=msg):
  159:             s.plot(style="b-", color="#000099")
  160: 
  161:     @pytest.mark.parametrize("freq", ["ms", "us"])
  162:     def test_high_freq(self, freq):
  163:         _, ax = mpl.pyplot.subplots()
  164:         rng = date_range("1/1/2012", periods=100, freq=freq)
  165:         ser = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  166:         _check_plot_works(ser.plot, ax=ax)
  167: 
  168:     def test_get_datevalue(self):
  169:         from pandas.plotting._matplotlib.converter import get_datevalue
  170: 
  171:         assert get_datevalue(None, "D") is None
  172:         assert get_datevalue(1987, "Y") == 1987
  173:         assert get_datevalue(Period(1987, "Y"), "M") == Period("1987-12", "M").ordinal
  174:         assert get_datevalue("1/1/1987", "D") == Period("1987-1-1", "D").ordinal
  175: 
  176:     def test_ts_plot_format_coord(self):
  177:         def check_format_of_first_point(ax, expected_string):
  178:             first_line = ax.get_lines()[0]
  179:             first_x = first_line.get_xdata()[0].ordinal
  180:             first_y = first_line.get_ydata()[0]
  181:             assert expected_string == ax.format_coord(first_x, first_y)
  182: 
  183:         annual = Series(1, index=date_range("2014-01-01", periods=3, freq="YE-DEC"))
  184:         _, ax = mpl.pyplot.subplots()
  185:         annual.plot(ax=ax)
  186:         check_format_of_first_point(ax, "t = 2014  y = 1.000000")
  187: 
  188:         # note this is added to the annual plot already in existence, and
  189:         # changes its freq field
  190:         daily = Series(1, index=date_range("2014-01-01", periods=3, freq="D"))
  191:         daily.plot(ax=ax)
  192:         check_format_of_first_point(ax, "t = 2014-01-01  y = 1.000000")
  193: 
  194:     @pytest.mark.parametrize("freq", ["s", "min", "h", "D", "W", "M", "Q", "Y"])
  195:     def test_line_plot_period_series(self, freq):
  196:         idx = period_range("12/31/1999", freq=freq, periods=100)
  197:         ser = Series(np.random.default_rng(2).standard_normal(len(idx)), idx)
  198:         _check_plot_works(ser.plot, ser.index.freq)
  199: 
  200:     @pytest.mark.parametrize(
  201:         "frqncy", ["1s", "3s", "5min", "7h", "4D", "8W", "11M", "3Y"]
  202:     )
  203:     def test_line_plot_period_mlt_series(self, frqncy):
  204:         # test period index line plot for series with multiples (`mlt`) of the
  205:         # frequency (`frqncy`) rule code. tests resolution of issue #14763
  206:         idx = period_range("12/31/1999", freq=frqncy, periods=100)
  207:         s = Series(np.random.default_rng(2).standard_normal(len(idx)), idx)
  208:         _check_plot_works(s.plot, s.index.freq.rule_code)
  209: 
  210:     @pytest.mark.parametrize(
  211:         "freq", ["s", "min", "h", "D", "W", "ME", "QE-DEC", "YE", "1B30Min"]
  212:     )
  213:     def test_line_plot_datetime_series(self, freq):
  214:         idx = date_range("12/31/1999", freq=freq, periods=100)
  215:         ser = Series(np.random.default_rng(2).standard_normal(len(idx)), idx)
  216:         _check_plot_works(ser.plot, ser.index.freq.rule_code)
  217: 
  218:     @pytest.mark.parametrize("freq", ["s", "min", "h", "D", "W", "ME", "QE", "YE"])
  219:     def test_line_plot_period_frame(self, freq):
  220:         idx = date_range("12/31/1999", freq=freq, periods=100)
  221:         df = DataFrame(
  222:             np.random.default_rng(2).standard_normal((len(idx), 3)),
  223:             index=idx,
  224:             columns=["A", "B", "C"],
  225:         )
  226:         _check_plot_works(df.plot, df.index.freq)
  227: 
  228:     @pytest.mark.parametrize(
  229:         "frqncy", ["1s", "3s", "5min", "7h", "4D", "8W", "11M", "3Y"]
  230:     )
  231:     def test_line_plot_period_mlt_frame(self, frqncy):
  232:         # test period index line plot for DataFrames with multiples (`mlt`)
  233:         # of the frequency (`frqncy`) rule code. tests resolution of issue
  234:         # #14763
  235:         idx = period_range("12/31/1999", freq=frqncy, periods=100)
  236:         df = DataFrame(
  237:             np.random.default_rng(2).standard_normal((len(idx), 3)),
  238:             index=idx,
  239:             columns=["A", "B", "C"],
  240:         )
  241:         freq = freq_to_period_freqstr(1, df.index.freq.rule_code)
  242:         freq = df.index.asfreq(freq).freq
  243:         _check_plot_works(df.plot, freq)
  244: 
  245:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  246:     @pytest.mark.parametrize(
  247:         "freq", ["s", "min", "h", "D", "W", "ME", "QE-DEC", "YE", "1B30Min"]
  248:     )
  249:     def test_line_plot_datetime_frame(self, freq):
  250:         idx = date_range("12/31/1999", freq=freq, periods=100)
  251:         df = DataFrame(
  252:             np.random.default_rng(2).standard_normal((len(idx), 3)),
  253:             index=idx,
  254:             columns=["A", "B", "C"],
  255:         )
  256:         freq = freq_to_period_freqstr(1, df.index.freq.rule_code)
  257:         freq = df.index.to_period(freq).freq
  258:         _check_plot_works(df.plot, freq)
  259: 
  260:     @pytest.mark.parametrize(
  261:         "freq", ["s", "min", "h", "D", "W", "ME", "QE-DEC", "YE", "1B30Min"]
  262:     )
  263:     def test_line_plot_inferred_freq(self, freq):
  264:         idx = date_range("12/31/1999", freq=freq, periods=100)
  265:         ser = Series(np.random.default_rng(2).standard_normal(len(idx)), idx)
  266:         ser = Series(ser.values, Index(np.asarray(ser.index)))
  267:         _check_plot_works(ser.plot, ser.index.inferred_freq)
  268: 
  269:         ser = ser.iloc[[0, 3, 5, 6]]
  270:         _check_plot_works(ser.plot)
  271: 
  272:     def test_fake_inferred_business(self):
  273:         _, ax = mpl.pyplot.subplots()
  274:         rng = date_range("2001-1-1", "2001-1-10")
  275:         ts = Series(range(len(rng)), index=rng)
  276:         ts = concat([ts[:3], ts[5:]])
  277:         ts.plot(ax=ax)
  278:         assert not hasattr(ax, "freq")
  279: 
  280:     def test_plot_offset_freq(self):
  281:         ser = Series(
  282:             np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
  283:         )
  284:         _check_plot_works(ser.plot)
  285: 
  286:     def test_plot_offset_freq_business(self):
  287:         dr = date_range("2023-01-01", freq="BQS", periods=10)
  288:         ser = Series(np.random.default_rng(2).standard_normal(len(dr)), index=dr)
  289:         _check_plot_works(ser.plot)
  290: 
  291:     def test_plot_multiple_inferred_freq(self):
  292:         dr = Index([datetime(2000, 1, 1), datetime(2000, 1, 6), datetime(2000, 1, 11)])
  293:         ser = Series(np.random.default_rng(2).standard_normal(len(dr)), index=dr)
  294:         _check_plot_works(ser.plot)
  295: 
  296:     @pytest.mark.xfail(reason="Api changed in 3.6.0")
  297:     def test_uhf(self):
  298:         import pandas.plotting._matplotlib.converter as conv
  299: 
  300:         idx = date_range("2012-6-22 21:59:51.960928", freq="ms", periods=500)
  301:         df = DataFrame(
  302:             np.random.default_rng(2).standard_normal((len(idx), 2)), index=idx
  303:         )
  304: 
  305:         _, ax = mpl.pyplot.subplots()
  306:         df.plot(ax=ax)
  307:         axis = ax.get_xaxis()
  308: 
  309:         tlocs = axis.get_ticklocs()
  310:         tlabels = axis.get_ticklabels()
  311:         for loc, label in zip(tlocs, tlabels):
  312:             xp = conv._from_ordinal(loc).strftime("%H:%M:%S.%f")
  313:             rs = str(label.get_text())
  314:             if len(rs):
  315:                 assert xp == rs
  316: 
  317:     def test_irreg_hf(self):
  318:         idx = date_range("2012-6-22 21:59:51", freq="s", periods=10)
  319:         df = DataFrame(
  320:             np.random.default_rng(2).standard_normal((len(idx), 2)), index=idx
  321:         )
  322: 
  323:         irreg = df.iloc[[0, 1, 3, 4]]
  324:         _, ax = mpl.pyplot.subplots()
  325:         irreg.plot(ax=ax)
  326:         diffs = Series(ax.get_lines()[0].get_xydata()[:, 0]).diff()
  327: 
  328:         sec = 1.0 / 24 / 60 / 60
  329:         assert (np.fabs(diffs[1:] - [sec, sec * 2, sec]) < 1e-8).all()
  330: 
  331:     def test_irreg_hf_object(self):
  332:         idx = date_range("2012-6-22 21:59:51", freq="s", periods=10)
  333:         df2 = DataFrame(
  334:             np.random.default_rng(2).standard_normal((len(idx), 2)), index=idx
  335:         )
  336:         _, ax = mpl.pyplot.subplots()
  337:         df2.index = df2.index.astype(object)
  338:         df2.plot(ax=ax)
  339:         diffs = Series(ax.get_lines()[0].get_xydata()[:, 0]).diff()
  340:         sec = 1.0 / 24 / 60 / 60
  341:         assert (np.fabs(diffs[1:] - sec) < 1e-8).all()
  342: 
  343:     def test_irregular_datetime64_repr_bug(self):
  344:         ser = Series(
  345:             np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
  346:         )
  347:         ser = ser.iloc[[0, 1, 2, 7]]
  348: 
  349:         _, ax = mpl.pyplot.subplots()
  350: 
  351:         ret = ser.plot(ax=ax)
  352:         assert ret is not None
  353: 
  354:         for rs, xp in zip(ax.get_lines()[0].get_xdata(), ser.index):
  355:             assert rs == xp
  356: 
  357:     def test_business_freq(self):
  358:         bts = Series(range(5), period_range("2020-01-01", periods=5))
  359:         msg = r"PeriodDtype\[B\] is deprecated"
  360:         dt = bts.index[0].to_timestamp()
  361:         with tm.assert_produces_warning(FutureWarning, match=msg):
  362:             bts.index = period_range(start=dt, periods=len(bts), freq="B")
  363:         _, ax = mpl.pyplot.subplots()
  364:         bts.plot(ax=ax)
  365:         assert ax.get_lines()[0].get_xydata()[0, 0] == bts.index[0].ordinal
  366:         idx = ax.get_lines()[0].get_xdata()
  367:         with tm.assert_produces_warning(FutureWarning, match=msg):
  368:             assert PeriodIndex(data=idx).freqstr == "B"
  369: 
  370:     def test_business_freq_convert(self):
  371:         bts = Series(
  372:             np.arange(300, dtype=np.float64),
  373:             index=date_range("2020-01-01", periods=300, freq="B"),
  374:         ).asfreq("BME")
  375:         ts = bts.to_period("M")
  376:         _, ax = mpl.pyplot.subplots()
  377:         bts.plot(ax=ax)
  378:         assert ax.get_lines()[0].get_xydata()[0, 0] == ts.index[0].ordinal
  379:         idx = ax.get_lines()[0].get_xdata()
  380:         assert PeriodIndex(data=idx).freqstr == "M"
  381: 
  382:     def test_freq_with_no_period_alias(self):
  383:         # GH34487
  384:         freq = WeekOfMonth()
  385:         bts = Series(
  386:             np.arange(10, dtype=np.float64), index=date_range("2020-01-01", periods=10)
  387:         ).asfreq(freq)
  388:         _, ax = mpl.pyplot.subplots()
  389:         bts.plot(ax=ax)
  390: 
  391:         idx = ax.get_lines()[0].get_xdata()
  392:         msg = "freq not specified and cannot be inferred"
  393:         with pytest.raises(ValueError, match=msg):
  394:             PeriodIndex(data=idx)
  395: 
  396:     def test_nonzero_base(self):
  397:         # GH2571
  398:         idx = date_range("2012-12-20", periods=24, freq="h") + timedelta(minutes=30)
  399:         df = DataFrame(np.arange(24), index=idx)
  400:         _, ax = mpl.pyplot.subplots()
  401:         df.plot(ax=ax)
  402:         rs = ax.get_lines()[0].get_xdata()
  403:         assert not Index(rs).is_normalized
  404: 
  405:     def test_dataframe(self):
  406:         bts = DataFrame(
  407:             {
  408:                 "a": Series(
  409:                     np.arange(10, dtype=np.float64),
  410:                     index=date_range("2020-01-01", periods=10),
  411:                 )
  412:             }
  413:         )
  414:         _, ax = mpl.pyplot.subplots()
  415:         bts.plot(ax=ax)
  416:         idx = ax.get_lines()[0].get_xdata()
  417:         tm.assert_index_equal(bts.index.to_period(), PeriodIndex(idx))
  418: 
  419:     @pytest.mark.filterwarnings(
  420:         "ignore:Period with BDay freq is deprecated:FutureWarning"
  421:     )
  422:     @pytest.mark.parametrize(
  423:         "obj",
  424:         [
  425:             Series(
  426:                 np.arange(10, dtype=np.float64),
  427:                 index=date_range("2020-01-01", periods=10),
  428:             ),
  429:             DataFrame(
  430:                 {
  431:                     "a": Series(
  432:                         np.arange(10, dtype=np.float64),
  433:                         index=date_range("2020-01-01", periods=10),
  434:                     ),
  435:                     "b": Series(
  436:                         np.arange(10, dtype=np.float64),
  437:                         index=date_range("2020-01-01", periods=10),
  438:                     )
  439:                     + 1,
  440:                 }
  441:             ),
  442:         ],
  443:     )
  444:     def test_axis_limits(self, obj):
  445:         _, ax = mpl.pyplot.subplots()
  446:         obj.plot(ax=ax)
  447:         xlim = ax.get_xlim()
  448:         ax.set_xlim(xlim[0] - 5, xlim[1] + 10)
  449:         result = ax.get_xlim()
  450:         assert result[0] == xlim[0] - 5
  451:         assert result[1] == xlim[1] + 10
  452: 
  453:         # string
  454:         expected = (Period("1/1/2000", ax.freq), Period("4/1/2000", ax.freq))
  455:         ax.set_xlim("1/1/2000", "4/1/2000")
  456:         result = ax.get_xlim()
  457:         assert int(result[0]) == expected[0].ordinal
  458:         assert int(result[1]) == expected[1].ordinal
  459: 
  460:         # datetime
  461:         expected = (Period("1/1/2000", ax.freq), Period("4/1/2000", ax.freq))
  462:         ax.set_xlim(datetime(2000, 1, 1), datetime(2000, 4, 1))
  463:         result = ax.get_xlim()
  464:         assert int(result[0]) == expected[0].ordinal
  465:         assert int(result[1]) == expected[1].ordinal
  466:         fig = ax.get_figure()
  467:         mpl.pyplot.close(fig)
  468: 
  469:     def test_get_finder(self):
  470:         import pandas.plotting._matplotlib.converter as conv
  471: 
  472:         assert conv.get_finder(to_offset("B")) == conv._daily_finder
  473:         assert conv.get_finder(to_offset("D")) == conv._daily_finder
  474:         assert conv.get_finder(to_offset("ME")) == conv._monthly_finder
  475:         assert conv.get_finder(to_offset("QE")) == conv._quarterly_finder
  476:         assert conv.get_finder(to_offset("YE")) == conv._annual_finder
  477:         assert conv.get_finder(to_offset("W")) == conv._daily_finder
  478: 
  479:     def test_finder_daily(self):
  480:         day_lst = [10, 40, 252, 400, 950, 2750, 10000]
  481: 
  482:         msg = "Period with BDay freq is deprecated"
  483:         with tm.assert_produces_warning(FutureWarning, match=msg):
  484:             xpl1 = xpl2 = [Period("1999-1-1", freq="B").ordinal] * len(day_lst)
  485:         rs1 = []
  486:         rs2 = []
  487:         for n in day_lst:
  488:             rng = bdate_range("1999-1-1", periods=n)
  489:             ser = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  490:             _, ax = mpl.pyplot.subplots()
  491:             ser.plot(ax=ax)
  492:             xaxis = ax.get_xaxis()
  493:             rs1.append(xaxis.get_majorticklocs()[0])
  494: 
  495:             vmin, vmax = ax.get_xlim()
  496:             ax.set_xlim(vmin + 0.9, vmax)
  497:             rs2.append(xaxis.get_majorticklocs()[0])
  498:             mpl.pyplot.close(ax.get_figure())
  499: 
  500:         assert rs1 == xpl1
  501:         assert rs2 == xpl2
  502: 
  503:     def test_finder_quarterly(self):
  504:         yrs = [3.5, 11]
  505: 
  506:         xpl1 = xpl2 = [Period("1988Q1").ordinal] * len(yrs)
  507:         rs1 = []
  508:         rs2 = []
  509:         for n in yrs:
  510:             rng = period_range("1987Q2", periods=int(n * 4), freq="Q")
  511:             ser = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  512:             _, ax = mpl.pyplot.subplots()
  513:             ser.plot(ax=ax)
  514:             xaxis = ax.get_xaxis()
  515:             rs1.append(xaxis.get_majorticklocs()[0])
  516: 
  517:             (vmin, vmax) = ax.get_xlim()
  518:             ax.set_xlim(vmin + 0.9, vmax)
  519:             rs2.append(xaxis.get_majorticklocs()[0])
  520:             mpl.pyplot.close(ax.get_figure())
  521: 
  522:         assert rs1 == xpl1
  523:         assert rs2 == xpl2
  524: 
  525:     def test_finder_monthly(self):
  526:         yrs = [1.15, 2.5, 4, 11]
  527: 
  528:         xpl1 = xpl2 = [Period("Jan 1988").ordinal] * len(yrs)
  529:         rs1 = []
  530:         rs2 = []
  531:         for n in yrs:
  532:             rng = period_range("1987Q2", periods=int(n * 12), freq="M")
  533:             ser = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  534:             _, ax = mpl.pyplot.subplots()
  535:             ser.plot(ax=ax)
  536:             xaxis = ax.get_xaxis()
  537:             rs1.append(xaxis.get_majorticklocs()[0])
  538: 
  539:             vmin, vmax = ax.get_xlim()
  540:             ax.set_xlim(vmin + 0.9, vmax)
  541:             rs2.append(xaxis.get_majorticklocs()[0])
  542:             mpl.pyplot.close(ax.get_figure())
  543: 
  544:         assert rs1 == xpl1
  545:         assert rs2 == xpl2
  546: 
  547:     def test_finder_monthly_long(self):
  548:         rng = period_range("1988Q1", periods=24 * 12, freq="M")
  549:         ser = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  550:         _, ax = mpl.pyplot.subplots()
  551:         ser.plot(ax=ax)
  552:         xaxis = ax.get_xaxis()
  553:         rs = xaxis.get_majorticklocs()[0]
  554:         xp = Period("1989Q1", "M").ordinal
  555:         assert rs == xp
  556: 
  557:     def test_finder_annual(self):
  558:         xp = [1987, 1988, 1990, 1990, 1995, 2020, 2070, 2170]
  559:         xp = [Period(x, freq="Y").ordinal for x in xp]
  560:         rs = []
  561:         for nyears in [5, 10, 19, 49, 99, 199, 599, 1001]:
  562:             rng = period_range("1987", periods=nyears, freq="Y")
  563:             ser = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  564:             _, ax = mpl.pyplot.subplots()
  565:             ser.plot(ax=ax)
  566:             xaxis = ax.get_xaxis()
  567:             rs.append(xaxis.get_majorticklocs()[0])
  568:             mpl.pyplot.close(ax.get_figure())
  569: 
  570:         assert rs == xp
  571: 
  572:     @pytest.mark.slow
  573:     def test_finder_minutely(self):
  574:         nminutes = 50 * 24 * 60
  575:         rng = date_range("1/1/1999", freq="Min", periods=nminutes)
  576:         ser = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  577:         _, ax = mpl.pyplot.subplots()
  578:         ser.plot(ax=ax)
  579:         xaxis = ax.get_xaxis()
  580:         rs = xaxis.get_majorticklocs()[0]
  581:         xp = Period("1/1/1999", freq="Min").ordinal
  582: 
  583:         assert rs == xp
  584: 
  585:     def test_finder_hourly(self):
  586:         nhours = 23
  587:         rng = date_range("1/1/1999", freq="h", periods=nhours)
  588:         ser = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  589:         _, ax = mpl.pyplot.subplots()
  590:         ser.plot(ax=ax)
  591:         xaxis = ax.get_xaxis()
  592:         rs = xaxis.get_majorticklocs()[0]
  593:         xp = Period("1/1/1999", freq="h").ordinal
  594: 
  595:         assert rs == xp
  596: 
  597:     def test_gaps(self):
  598:         ts = Series(
  599:             np.arange(30, dtype=np.float64), index=date_range("2020-01-01", periods=30)
  600:         )
  601:         ts.iloc[5:25] = np.nan
  602:         _, ax = mpl.pyplot.subplots()
  603:         ts.plot(ax=ax)
  604:         lines = ax.get_lines()
  605:         assert len(lines) == 1
  606:         line = lines[0]
  607:         data = line.get_xydata()
  608: 
  609:         data = np.ma.MaskedArray(data, mask=isna(data), fill_value=np.nan)
  610: 
  611:         assert isinstance(data, np.ma.core.MaskedArray)
  612:         mask = data.mask
  613:         assert mask[5:25, 1].all()
  614:         mpl.pyplot.close(ax.get_figure())
  615: 
  616:     def test_gaps_irregular(self):
  617:         # irregular
  618:         ts = Series(
  619:             np.arange(30, dtype=np.float64), index=date_range("2020-01-01", periods=30)
  620:         )
  621:         ts = ts.iloc[[0, 1, 2, 5, 7, 9, 12, 15, 20]]
  622:         ts.iloc[2:5] = np.nan
  623:         _, ax = mpl.pyplot.subplots()
  624:         ax = ts.plot(ax=ax)
  625:         lines = ax.get_lines()
  626:         assert len(lines) == 1
  627:         line = lines[0]
  628:         data = line.get_xydata()
  629: 
  630:         data = np.ma.MaskedArray(data, mask=isna(data), fill_value=np.nan)
  631: 
  632:         assert isinstance(data, np.ma.core.MaskedArray)
  633:         mask = data.mask
  634:         assert mask[2:5, 1].all()
  635:         mpl.pyplot.close(ax.get_figure())
  636: 
  637:     def test_gaps_non_ts(self):
  638:         # non-ts
  639:         idx = [0, 1, 2, 5, 7, 9, 12, 15, 20]
  640:         ser = Series(np.random.default_rng(2).standard_normal(len(idx)), idx)
  641:         ser.iloc[2:5] = np.nan
  642:         _, ax = mpl.pyplot.subplots()
  643:         ser.plot(ax=ax)
  644:         lines = ax.get_lines()
  645:         assert len(lines) == 1
  646:         line = lines[0]
  647:         data = line.get_xydata()
  648:         data = np.ma.MaskedArray(data, mask=isna(data), fill_value=np.nan)
  649: 
  650:         assert isinstance(data, np.ma.core.MaskedArray)
  651:         mask = data.mask
  652:         assert mask[2:5, 1].all()
  653: 
  654:     def test_gap_upsample(self):
  655:         low = Series(
  656:             np.arange(30, dtype=np.float64), index=date_range("2020-01-01", periods=30)
  657:         )
  658:         low.iloc[5:25] = np.nan
  659:         _, ax = mpl.pyplot.subplots()
  660:         low.plot(ax=ax)
  661: 
  662:         idxh = date_range(low.index[0], low.index[-1], freq="12h")
  663:         s = Series(np.random.default_rng(2).standard_normal(len(idxh)), idxh)
  664:         s.plot(secondary_y=True)
  665:         lines = ax.get_lines()
  666:         assert len(lines) == 1
  667:         assert len(ax.right_ax.get_lines()) == 1
  668: 
  669:         line = lines[0]
  670:         data = line.get_xydata()
  671:         data = np.ma.MaskedArray(data, mask=isna(data), fill_value=np.nan)
  672: 
  673:         assert isinstance(data, np.ma.core.MaskedArray)
  674:         mask = data.mask
  675:         assert mask[5:25, 1].all()
  676: 
  677:     def test_secondary_y(self):
  678:         ser = Series(np.random.default_rng(2).standard_normal(10))
  679:         fig, _ = mpl.pyplot.subplots()
  680:         ax = ser.plot(secondary_y=True)
  681:         assert hasattr(ax, "left_ax")
  682:         assert not hasattr(ax, "right_ax")
  683:         axes = fig.get_axes()
  684:         line = ax.get_lines()[0]
  685:         xp = Series(line.get_ydata(), line.get_xdata())
  686:         tm.assert_series_equal(ser, xp)
  687:         assert ax.get_yaxis().get_ticks_position() == "right"
  688:         assert not axes[0].get_yaxis().get_visible()
  689:         mpl.pyplot.close(fig)
  690: 
  691:     def test_secondary_y_yaxis(self):
  692:         Series(np.random.default_rng(2).standard_normal(10))
  693:         ser2 = Series(np.random.default_rng(2).standard_normal(10))
  694:         _, ax2 = mpl.pyplot.subplots()
  695:         ser2.plot(ax=ax2)
  696:         assert ax2.get_yaxis().get_ticks_position() == "left"
  697:         mpl.pyplot.close(ax2.get_figure())
  698: 
  699:     def test_secondary_both(self):
  700:         ser = Series(np.random.default_rng(2).standard_normal(10))
  701:         ser2 = Series(np.random.default_rng(2).standard_normal(10))
  702:         ax = ser2.plot()
  703:         ax2 = ser.plot(secondary_y=True)
  704:         assert ax.get_yaxis().get_visible()
  705:         assert not hasattr(ax, "left_ax")
  706:         assert hasattr(ax, "right_ax")
  707:         assert hasattr(ax2, "left_ax")
  708:         assert not hasattr(ax2, "right_ax")
  709: 
  710:     def test_secondary_y_ts(self):
  711:         idx = date_range("1/1/2000", periods=10)
  712:         ser = Series(np.random.default_rng(2).standard_normal(10), idx)
  713:         fig, _ = mpl.pyplot.subplots()
  714:         ax = ser.plot(secondary_y=True)
  715:         assert hasattr(ax, "left_ax")
  716:         assert not hasattr(ax, "right_ax")
  717:         axes = fig.get_axes()
  718:         line = ax.get_lines()[0]
  719:         xp = Series(line.get_ydata(), line.get_xdata()).to_timestamp()
  720:         tm.assert_series_equal(ser, xp)
  721:         assert ax.get_yaxis().get_ticks_position() == "right"
  722:         assert not axes[0].get_yaxis().get_visible()
  723:         mpl.pyplot.close(fig)
  724: 
  725:     def test_secondary_y_ts_yaxis(self):
  726:         idx = date_range("1/1/2000", periods=10)
  727:         ser2 = Series(np.random.default_rng(2).standard_normal(10), idx)
  728:         _, ax2 = mpl.pyplot.subplots()
  729:         ser2.plot(ax=ax2)
  730:         assert ax2.get_yaxis().get_ticks_position() == "left"
  731:         mpl.pyplot.close(ax2.get_figure())
  732: 
  733:     def test_secondary_y_ts_visible(self):
  734:         idx = date_range("1/1/2000", periods=10)
  735:         ser2 = Series(np.random.default_rng(2).standard_normal(10), idx)
  736:         ax = ser2.plot()
  737:         assert ax.get_yaxis().get_visible()
  738: 
  739:     def test_secondary_kde(self):
  740:         pytest.importorskip("scipy")
  741:         ser = Series(np.random.default_rng(2).standard_normal(10))
  742:         fig, ax = mpl.pyplot.subplots()
  743:         ax = ser.plot(secondary_y=True, kind="density", ax=ax)
  744:         assert hasattr(ax, "left_ax")
  745:         assert not hasattr(ax, "right_ax")
  746:         axes = fig.get_axes()
  747:         assert axes[1].get_yaxis().get_ticks_position() == "right"
  748: 
  749:     def test_secondary_bar(self):
  750:         ser = Series(np.random.default_rng(2).standard_normal(10))
  751:         fig, ax = mpl.pyplot.subplots()
  752:         ser.plot(secondary_y=True, kind="bar", ax=ax)
  753:         axes = fig.get_axes()
  754:         assert axes[1].get_yaxis().get_ticks_position() == "right"
  755: 
  756:     def test_secondary_frame(self):
  757:         df = DataFrame(
  758:             np.random.default_rng(2).standard_normal((5, 3)), columns=["a", "b", "c"]
  759:         )
  760:         axes = df.plot(secondary_y=["a", "c"], subplots=True)
  761:         assert axes[0].get_yaxis().get_ticks_position() == "right"
  762:         assert axes[1].get_yaxis().get_ticks_position() == "left"
  763:         assert axes[2].get_yaxis().get_ticks_position() == "right"
  764: 
  765:     def test_secondary_bar_frame(self):
  766:         df = DataFrame(
  767:             np.random.default_rng(2).standard_normal((5, 3)), columns=["a", "b", "c"]
  768:         )
  769:         axes = df.plot(kind="bar", secondary_y=["a", "c"], subplots=True)
  770:         assert axes[0].get_yaxis().get_ticks_position() == "right"
  771:         assert axes[1].get_yaxis().get_ticks_position() == "left"
  772:         assert axes[2].get_yaxis().get_ticks_position() == "right"
  773: 
  774:     def test_mixed_freq_regular_first(self):
  775:         # TODO
  776:         s1 = Series(
  777:             np.arange(20, dtype=np.float64),
  778:             index=date_range("2020-01-01", periods=20, freq="B"),
  779:         )
  780:         s2 = s1.iloc[[0, 5, 10, 11, 12, 13, 14, 15]]
  781: 
  782:         # it works!
  783:         _, ax = mpl.pyplot.subplots()
  784:         s1.plot(ax=ax)
  785: 
  786:         ax2 = s2.plot(style="g", ax=ax)
  787:         lines = ax2.get_lines()
  788:         msg = r"PeriodDtype\[B\] is deprecated"
  789:         with tm.assert_produces_warning(FutureWarning, match=msg):
  790:             idx1 = PeriodIndex(lines[0].get_xdata())
  791:             idx2 = PeriodIndex(lines[1].get_xdata())
  792: 
  793:             tm.assert_index_equal(idx1, s1.index.to_period("B"))
  794:             tm.assert_index_equal(idx2, s2.index.to_period("B"))
  795: 
  796:             left, right = ax2.get_xlim()
  797:             pidx = s1.index.to_period()
  798:         assert left <= pidx[0].ordinal
  799:         assert right >= pidx[-1].ordinal
  800: 
  801:     def test_mixed_freq_irregular_first(self):
  802:         s1 = Series(
  803:             np.arange(20, dtype=np.float64), index=date_range("2020-01-01", periods=20)
  804:         )
  805:         s2 = s1.iloc[[0, 5, 10, 11, 12, 13, 14, 15]]
  806:         _, ax = mpl.pyplot.subplots()
  807:         s2.plot(style="g", ax=ax)
  808:         s1.plot(ax=ax)
  809:         assert not hasattr(ax, "freq")
  810:         lines = ax.get_lines()
  811:         x1 = lines[0].get_xdata()
  812:         tm.assert_numpy_array_equal(x1, s2.index.astype(object).values)
  813:         x2 = lines[1].get_xdata()
  814:         tm.assert_numpy_array_equal(x2, s1.index.astype(object).values)
  815: 
  816:     def test_mixed_freq_regular_first_df(self):
  817:         # GH 9852
  818:         s1 = Series(
  819:             np.arange(20, dtype=np.float64),
  820:             index=date_range("2020-01-01", periods=20, freq="B"),
  821:         ).to_frame()
  822:         s2 = s1.iloc[[0, 5, 10, 11, 12, 13, 14, 15], :]
  823:         _, ax = mpl.pyplot.subplots()
  824:         s1.plot(ax=ax)
  825:         ax2 = s2.plot(style="g", ax=ax)
  826:         lines = ax2.get_lines()
  827:         msg = r"PeriodDtype\[B\] is deprecated"
  828:         with tm.assert_produces_warning(FutureWarning, match=msg):
  829:             idx1 = PeriodIndex(lines[0].get_xdata())
  830:             idx2 = PeriodIndex(lines[1].get_xdata())
  831:             assert idx1.equals(s1.index.to_period("B"))
  832:             assert idx2.equals(s2.index.to_period("B"))
  833:             left, right = ax2.get_xlim()
  834:             pidx = s1.index.to_period()
  835:         assert left <= pidx[0].ordinal
  836:         assert right >= pidx[-1].ordinal
  837: 
  838:     def test_mixed_freq_irregular_first_df(self):
  839:         # GH 9852
  840:         s1 = Series(
  841:             np.arange(20, dtype=np.float64), index=date_range("2020-01-01", periods=20)
  842:         ).to_frame()
  843:         s2 = s1.iloc[[0, 5, 10, 11, 12, 13, 14, 15], :]
  844:         _, ax = mpl.pyplot.subplots()
  845:         s2.plot(style="g", ax=ax)
  846:         s1.plot(ax=ax)
  847:         assert not hasattr(ax, "freq")
  848:         lines = ax.get_lines()
  849:         x1 = lines[0].get_xdata()
  850:         tm.assert_numpy_array_equal(x1, s2.index.astype(object).values)
  851:         x2 = lines[1].get_xdata()
  852:         tm.assert_numpy_array_equal(x2, s1.index.astype(object).values)
  853: 
  854:     def test_mixed_freq_hf_first(self):
  855:         idxh = date_range("1/1/1999", periods=365, freq="D")
  856:         idxl = date_range("1/1/1999", periods=12, freq="ME")
  857:         high = Series(np.random.default_rng(2).standard_normal(len(idxh)), idxh)
  858:         low = Series(np.random.default_rng(2).standard_normal(len(idxl)), idxl)
  859:         _, ax = mpl.pyplot.subplots()
  860:         high.plot(ax=ax)
  861:         low.plot(ax=ax)
  862:         for line in ax.get_lines():
  863:             assert PeriodIndex(data=line.get_xdata()).freq == "D"
  864: 
  865:     def test_mixed_freq_alignment(self):
  866:         ts_ind = date_range("2012-01-01 13:00", "2012-01-02", freq="h")
  867:         ts_data = np.random.default_rng(2).standard_normal(12)
  868: 
  869:         ts = Series(ts_data, index=ts_ind)
  870:         ts2 = ts.asfreq("min").interpolate()
  871: 
  872:         _, ax = mpl.pyplot.subplots()
  873:         ax = ts.plot(ax=ax)
  874:         ts2.plot(style="r", ax=ax)
  875: 
  876:         assert ax.lines[0].get_xdata()[0] == ax.lines[1].get_xdata()[0]
  877: 
  878:     def test_mixed_freq_lf_first(self):
  879:         idxh = date_range("1/1/1999", periods=365, freq="D")
  880:         idxl = date_range("1/1/1999", periods=12, freq="ME")
  881:         high = Series(np.random.default_rng(2).standard_normal(len(idxh)), idxh)
  882:         low = Series(np.random.default_rng(2).standard_normal(len(idxl)), idxl)
  883:         _, ax = mpl.pyplot.subplots()
  884:         low.plot(legend=True, ax=ax)
  885:         high.plot(legend=True, ax=ax)
  886:         for line in ax.get_lines():
  887:             assert PeriodIndex(data=line.get_xdata()).freq == "D"
  888:         leg = ax.get_legend()
  889:         assert len(leg.texts) == 2
  890:         mpl.pyplot.close(ax.get_figure())
  891: 
  892:     def test_mixed_freq_lf_first_hourly(self):
  893:         idxh = date_range("1/1/1999", periods=240, freq="min")
  894:         idxl = date_range("1/1/1999", periods=4, freq="h")
  895:         high = Series(np.random.default_rng(2).standard_normal(len(idxh)), idxh)
  896:         low = Series(np.random.default_rng(2).standard_normal(len(idxl)), idxl)
  897:         _, ax = mpl.pyplot.subplots()
  898:         low.plot(ax=ax)
  899:         high.plot(ax=ax)
  900:         for line in ax.get_lines():
  901:             assert PeriodIndex(data=line.get_xdata()).freq == "min"
  902: 
  903:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  904:     def test_mixed_freq_irreg_period(self):
  905:         ts = Series(
  906:             np.arange(30, dtype=np.float64), index=date_range("2020-01-01", periods=30)
  907:         )
  908:         irreg = ts.iloc[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 16, 17, 18, 29]]
  909:         msg = r"PeriodDtype\[B\] is deprecated"
  910:         with tm.assert_produces_warning(FutureWarning, match=msg):
  911:             rng = period_range("1/3/2000", periods=30, freq="B")
  912:         ps = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  913:         _, ax = mpl.pyplot.subplots()
  914:         irreg.plot(ax=ax)
  915:         ps.plot(ax=ax)
  916: 
  917:     def test_mixed_freq_shared_ax(self):
  918:         # GH13341, using sharex=True
  919:         idx1 = date_range("2015-01-01", periods=3, freq="ME")
  920:         idx2 = idx1[:1].union(idx1[2:])
  921:         s1 = Series(range(len(idx1)), idx1)
  922:         s2 = Series(range(len(idx2)), idx2)
  923: 
  924:         _, (ax1, ax2) = mpl.pyplot.subplots(nrows=2, sharex=True)
  925:         s1.plot(ax=ax1)
  926:         s2.plot(ax=ax2)
  927: 
  928:         assert ax1.freq == "M"
  929:         assert ax2.freq == "M"
  930:         assert ax1.lines[0].get_xydata()[0, 0] == ax2.lines[0].get_xydata()[0, 0]
  931: 
  932:     def test_mixed_freq_shared_ax_twin_x(self):
  933:         # GH13341, using sharex=True
  934:         idx1 = date_range("2015-01-01", periods=3, freq="ME")
  935:         idx2 = idx1[:1].union(idx1[2:])
  936:         s1 = Series(range(len(idx1)), idx1)
  937:         s2 = Series(range(len(idx2)), idx2)
  938:         # using twinx
  939:         _, ax1 = mpl.pyplot.subplots()
  940:         ax2 = ax1.twinx()
  941:         s1.plot(ax=ax1)
  942:         s2.plot(ax=ax2)
  943: 
  944:         assert ax1.lines[0].get_xydata()[0, 0] == ax2.lines[0].get_xydata()[0, 0]
  945: 
  946:     @pytest.mark.xfail(reason="TODO (GH14330, GH14322)")
  947:     def test_mixed_freq_shared_ax_twin_x_irregular_first(self):
  948:         # GH13341, using sharex=True
  949:         idx1 = date_range("2015-01-01", periods=3, freq="M")
  950:         idx2 = idx1[:1].union(idx1[2:])
  951:         s1 = Series(range(len(idx1)), idx1)
  952:         s2 = Series(range(len(idx2)), idx2)
  953:         _, ax1 = mpl.pyplot.subplots()
  954:         ax2 = ax1.twinx()
  955:         s2.plot(ax=ax1)
  956:         s1.plot(ax=ax2)
  957:         assert ax1.lines[0].get_xydata()[0, 0] == ax2.lines[0].get_xydata()[0, 0]
  958: 
  959:     def test_nat_handling(self):
  960:         _, ax = mpl.pyplot.subplots()
  961: 
  962:         dti = DatetimeIndex(["2015-01-01", NaT, "2015-01-03"])
  963:         s = Series(range(len(dti)), dti)
  964:         s.plot(ax=ax)
  965:         xdata = ax.get_lines()[0].get_xdata()
  966:         # plot x data is bounded by index values
  967:         assert s.index.min() <= Series(xdata).min()
  968:         assert Series(xdata).max() <= s.index.max()
  969: 
  970:     def test_to_weekly_resampling_disallow_how_kwd(self):
  971:         idxh = date_range("1/1/1999", periods=52, freq="W")
  972:         idxl = date_range("1/1/1999", periods=12, freq="ME")
  973:         high = Series(np.random.default_rng(2).standard_normal(len(idxh)), idxh)
  974:         low = Series(np.random.default_rng(2).standard_normal(len(idxl)), idxl)
  975:         _, ax = mpl.pyplot.subplots()
  976:         high.plot(ax=ax)
  977: 
  978:         msg = (
  979:             "'how' is not a valid keyword for plotting functions. If plotting "
  980:             "multiple objects on shared axes, resample manually first."
  981:         )
  982:         with pytest.raises(ValueError, match=msg):
  983:             low.plot(ax=ax, how="foo")
  984: 
  985:     def test_to_weekly_resampling(self):
  986:         idxh = date_range("1/1/1999", periods=52, freq="W")
  987:         idxl = date_range("1/1/1999", periods=12, freq="ME")
  988:         high = Series(np.random.default_rng(2).standard_normal(len(idxh)), idxh)
  989:         low = Series(np.random.default_rng(2).standard_normal(len(idxl)), idxl)
  990:         _, ax = mpl.pyplot.subplots()
  991:         high.plot(ax=ax)
  992:         low.plot(ax=ax)
  993:         for line in ax.get_lines():
  994:             assert PeriodIndex(data=line.get_xdata()).freq == idxh.freq
  995: 
  996:     def test_from_weekly_resampling(self):
  997:         idxh = date_range("1/1/1999", periods=52, freq="W")
  998:         idxl = date_range("1/1/1999", periods=12, freq="ME")
  999:         high = Series(np.random.default_rng(2).standard_normal(len(idxh)), idxh)
 1000:         low = Series(np.random.default_rng(2).standard_normal(len(idxl)), idxl)
 1001:         _, ax = mpl.pyplot.subplots()
 1002:         low.plot(ax=ax)
 1003:         high.plot(ax=ax)
 1004: 
 1005:         expected_h = idxh.to_period().asi8.astype(np.float64)
 1006:         expected_l = np.array(
 1007:             [1514, 1519, 1523, 1527, 1531, 1536, 1540, 1544, 1549, 1553, 1558, 1562],
 1008:             dtype=np.float64,
 1009:         )
 1010:         for line in ax.get_lines():
 1011:             assert PeriodIndex(data=line.get_xdata()).freq == idxh.freq
 1012:             xdata = line.get_xdata(orig=False)
 1013:             if len(xdata) == 12:  # idxl lines
 1014:                 tm.assert_numpy_array_equal(xdata, expected_l)
 1015:             else:
 1016:                 tm.assert_numpy_array_equal(xdata, expected_h)
 1017: 
 1018:     @pytest.mark.parametrize("kind1, kind2", [("line", "area"), ("area", "line")])
 1019:     def test_from_resampling_area_line_mixed(self, kind1, kind2):
 1020:         idxh = date_range("1/1/1999", periods=52, freq="W")
 1021:         idxl = date_range("1/1/1999", periods=12, freq="ME")
 1022:         high = DataFrame(
 1023:             np.random.default_rng(2).random((len(idxh), 3)),
 1024:             index=idxh,
 1025:             columns=[0, 1, 2],
 1026:         )
 1027:         low = DataFrame(
 1028:             np.random.default_rng(2).random((len(idxl), 3)),
 1029:             index=idxl,
 1030:             columns=[0, 1, 2],
 1031:         )
 1032: 
 1033:         _, ax = mpl.pyplot.subplots()
 1034:         low.plot(kind=kind1, stacked=True, ax=ax)
 1035:         high.plot(kind=kind2, stacked=True, ax=ax)
 1036: 
 1037:         # check low dataframe result
 1038:         expected_x = np.array(
 1039:             [
 1040:                 1514,
 1041:                 1519,
 1042:                 1523,
 1043:                 1527,
 1044:                 1531,
 1045:                 1536,
 1046:                 1540,
 1047:                 1544,
 1048:                 1549,
 1049:                 1553,
 1050:                 1558,
 1051:                 1562,
 1052:             ],
 1053:             dtype=np.float64,
 1054:         )
 1055:         expected_y = np.zeros(len(expected_x), dtype=np.float64)
 1056:         for i in range(3):
 1057:             line = ax.lines[i]
 1058:             assert PeriodIndex(line.get_xdata()).freq == idxh.freq
 1059:             tm.assert_numpy_array_equal(line.get_xdata(orig=False), expected_x)
 1060:             # check stacked values are correct
 1061:             expected_y += low[i].values
 1062:             tm.assert_numpy_array_equal(line.get_ydata(orig=False), expected_y)
 1063: 
 1064:         # check high dataframe result
 1065:         expected_x = idxh.to_period().asi8.astype(np.float64)
 1066:         expected_y = np.zeros(len(expected_x), dtype=np.float64)
 1067:         for i in range(3):
 1068:             line = ax.lines[3 + i]
 1069:             assert PeriodIndex(data=line.get_xdata()).freq == idxh.freq
 1070:             tm.assert_numpy_array_equal(line.get_xdata(orig=False), expected_x)
 1071:             expected_y += high[i].values
 1072:             tm.assert_numpy_array_equal(line.get_ydata(orig=False), expected_y)
 1073: 
 1074:     @pytest.mark.parametrize("kind1, kind2", [("line", "area"), ("area", "line")])
 1075:     def test_from_resampling_area_line_mixed_high_to_low(self, kind1, kind2):
 1076:         idxh = date_range("1/1/1999", periods=52, freq="W")
 1077:         idxl = date_range("1/1/1999", periods=12, freq="ME")
 1078:         high = DataFrame(
 1079:             np.random.default_rng(2).random((len(idxh), 3)),
 1080:             index=idxh,
 1081:             columns=[0, 1, 2],
 1082:         )
 1083:         low = DataFrame(
 1084:             np.random.default_rng(2).random((len(idxl), 3)),
 1085:             index=idxl,
 1086:             columns=[0, 1, 2],
 1087:         )
 1088:         _, ax = mpl.pyplot.subplots()
 1089:         high.plot(kind=kind1, stacked=True, ax=ax)
 1090:         low.plot(kind=kind2, stacked=True, ax=ax)
 1091: 
 1092:         # check high dataframe result
 1093:         expected_x = idxh.to_period().asi8.astype(np.float64)
 1094:         expected_y = np.zeros(len(expected_x), dtype=np.float64)
 1095:         for i in range(3):
 1096:             line = ax.lines[i]
 1097:             assert PeriodIndex(data=line.get_xdata()).freq == idxh.freq
 1098:             tm.assert_numpy_array_equal(line.get_xdata(orig=False), expected_x)
 1099:             expected_y += high[i].values
 1100:             tm.assert_numpy_array_equal(line.get_ydata(orig=False), expected_y)
 1101: 
 1102:         # check low dataframe result
 1103:         expected_x = np.array(
 1104:             [
 1105:                 1514,
 1106:                 1519,
 1107:                 1523,
 1108:                 1527,
 1109:                 1531,
 1110:                 1536,
 1111:                 1540,
 1112:                 1544,
 1113:                 1549,
 1114:                 1553,
 1115:                 1558,
 1116:                 1562,
 1117:             ],
 1118:             dtype=np.float64,
 1119:         )
 1120:         expected_y = np.zeros(len(expected_x), dtype=np.float64)
 1121:         for i in range(3):
 1122:             lines = ax.lines[3 + i]
 1123:             assert PeriodIndex(data=lines.get_xdata()).freq == idxh.freq
 1124:             tm.assert_numpy_array_equal(lines.get_xdata(orig=False), expected_x)
 1125:             expected_y += low[i].values
 1126:             tm.assert_numpy_array_equal(lines.get_ydata(orig=False), expected_y)
 1127: 
 1128:     def test_mixed_freq_second_millisecond(self):
 1129:         # GH 7772, GH 7760
 1130:         idxh = date_range("2014-07-01 09:00", freq="s", periods=50)
 1131:         idxl = date_range("2014-07-01 09:00", freq="100ms", periods=500)
 1132:         high = Series(np.random.default_rng(2).standard_normal(len(idxh)), idxh)
 1133:         low = Series(np.random.default_rng(2).standard_normal(len(idxl)), idxl)
 1134:         # high to low
 1135:         _, ax = mpl.pyplot.subplots()
 1136:         high.plot(ax=ax)
 1137:         low.plot(ax=ax)
 1138:         assert len(ax.get_lines()) == 2
 1139:         for line in ax.get_lines():
 1140:             assert PeriodIndex(data=line.get_xdata()).freq == "ms"
 1141: 
 1142:     def test_mixed_freq_second_millisecond_low_to_high(self):
 1143:         # GH 7772, GH 7760
 1144:         idxh = date_range("2014-07-01 09:00", freq="s", periods=50)
 1145:         idxl = date_range("2014-07-01 09:00", freq="100ms", periods=500)
 1146:         high = Series(np.random.default_rng(2).standard_normal(len(idxh)), idxh)
 1147:         low = Series(np.random.default_rng(2).standard_normal(len(idxl)), idxl)
 1148:         # low to high
 1149:         _, ax = mpl.pyplot.subplots()
 1150:         low.plot(ax=ax)
 1151:         high.plot(ax=ax)
 1152:         assert len(ax.get_lines()) == 2
 1153:         for line in ax.get_lines():
 1154:             assert PeriodIndex(data=line.get_xdata()).freq == "ms"
 1155: 
 1156:     def test_irreg_dtypes(self):
 1157:         # date
 1158:         idx = [date(2000, 1, 1), date(2000, 1, 5), date(2000, 1, 20)]
 1159:         df = DataFrame(
 1160:             np.random.default_rng(2).standard_normal((len(idx), 3)),
 1161:             Index(idx, dtype=object),
 1162:         )
 1163:         _check_plot_works(df.plot)
 1164: 
 1165:     def test_irreg_dtypes_dt64(self):
 1166:         # np.datetime64
 1167:         idx = date_range("1/1/2000", periods=10)
 1168:         idx = idx[[0, 2, 5, 9]].astype(object)
 1169:         df = DataFrame(np.random.default_rng(2).standard_normal((len(idx), 3)), idx)
 1170:         _, ax = mpl.pyplot.subplots()
 1171:         _check_plot_works(df.plot, ax=ax)
 1172: 
 1173:     def test_time(self):
 1174:         t = datetime(1, 1, 1, 3, 30, 0)
 1175:         deltas = np.random.default_rng(2).integers(1, 20, 3).cumsum()
 1176:         ts = np.array([(t + timedelta(minutes=int(x))).time() for x in deltas])
 1177:         df = DataFrame(
 1178:             {
 1179:                 "a": np.random.default_rng(2).standard_normal(len(ts)),
 1180:                 "b": np.random.default_rng(2).standard_normal(len(ts)),
 1181:             },
 1182:             index=ts,
 1183:         )
 1184:         _, ax = mpl.pyplot.subplots()
 1185:         df.plot(ax=ax)
 1186: 
 1187:         # verify tick labels
 1188:         ticks = ax.get_xticks()
 1189:         labels = ax.get_xticklabels()
 1190:         for _tick, _label in zip(ticks, labels):
 1191:             m, s = divmod(int(_tick), 60)
 1192:             h, m = divmod(m, 60)
 1193:             rs = _label.get_text()
 1194:             if len(rs) > 0:
 1195:                 if s != 0:
 1196:                     xp = time(h, m, s).strftime("%H:%M:%S")
 1197:                 else:
 1198:                     xp = time(h, m, s).strftime("%H:%M")
 1199:                 assert xp == rs
 1200: 
 1201:     def test_time_change_xlim(self):
 1202:         t = datetime(1, 1, 1, 3, 30, 0)
 1203:         deltas = np.random.default_rng(2).integers(1, 20, 3).cumsum()
 1204:         ts = np.array([(t + timedelta(minutes=int(x))).time() for x in deltas])
 1205:         df = DataFrame(
 1206:             {
 1207:                 "a": np.random.default_rng(2).standard_normal(len(ts)),
 1208:                 "b": np.random.default_rng(2).standard_normal(len(ts)),
 1209:             },
 1210:             index=ts,
 1211:         )
 1212:         _, ax = mpl.pyplot.subplots()
 1213:         df.plot(ax=ax)
 1214: 
 1215:         # verify tick labels
 1216:         ticks = ax.get_xticks()
 1217:         labels = ax.get_xticklabels()
 1218:         for _tick, _label in zip(ticks, labels):
 1219:             m, s = divmod(int(_tick), 60)
 1220:             h, m = divmod(m, 60)
 1221:             rs = _label.get_text()
 1222:             if len(rs) > 0:
 1223:                 if s != 0:
 1224:                     xp = time(h, m, s).strftime("%H:%M:%S")
 1225:                 else:
 1226:                     xp = time(h, m, s).strftime("%H:%M")
 1227:                 assert xp == rs
 1228: 
 1229:         # change xlim
 1230:         ax.set_xlim("1:30", "5:00")
 1231: 
 1232:         # check tick labels again
 1233:         ticks = ax.get_xticks()
 1234:         labels = ax.get_xticklabels()
 1235:         for _tick, _label in zip(ticks, labels):
 1236:             m, s = divmod(int(_tick), 60)
 1237:             h, m = divmod(m, 60)
 1238:             rs = _label.get_text()
 1239:             if len(rs) > 0:
 1240:                 if s != 0:
 1241:                     xp = time(h, m, s).strftime("%H:%M:%S")
 1242:                 else:
 1243:                     xp = time(h, m, s).strftime("%H:%M")
 1244:                 assert xp == rs
 1245: 
 1246:     def test_time_musec(self):
 1247:         t = datetime(1, 1, 1, 3, 30, 0)
 1248:         deltas = np.random.default_rng(2).integers(1, 20, 3).cumsum()
 1249:         ts = np.array([(t + timedelta(microseconds=int(x))).time() for x in deltas])
 1250:         df = DataFrame(
 1251:             {
 1252:                 "a": np.random.default_rng(2).standard_normal(len(ts)),
 1253:                 "b": np.random.default_rng(2).standard_normal(len(ts)),
 1254:             },
 1255:             index=ts,
 1256:         )
 1257:         _, ax = mpl.pyplot.subplots()
 1258:         ax = df.plot(ax=ax)
 1259: 
 1260:         # verify tick labels
 1261:         ticks = ax.get_xticks()
 1262:         labels = ax.get_xticklabels()
 1263:         for _tick, _label in zip(ticks, labels):
 1264:             m, s = divmod(int(_tick), 60)
 1265: 
 1266:             us = round((_tick - int(_tick)) * 1e6)
 1267: 
 1268:             h, m = divmod(m, 60)
 1269:             rs = _label.get_text()
 1270:             if len(rs) > 0:
 1271:                 if (us % 1000) != 0:
 1272:                     xp = time(h, m, s, us).strftime("%H:%M:%S.%f")
 1273:                 elif (us // 1000) != 0:
 1274:                     xp = time(h, m, s, us).strftime("%H:%M:%S.%f")[:-3]
 1275:                 elif s != 0:
 1276:                     xp = time(h, m, s, us).strftime("%H:%M:%S")
 1277:                 else:
 1278:                     xp = time(h, m, s, us).strftime("%H:%M")
 1279:                 assert xp == rs
 1280: 
 1281:     def test_secondary_upsample(self):
 1282:         idxh = date_range("1/1/1999", periods=365, freq="D")
 1283:         idxl = date_range("1/1/1999", periods=12, freq="ME")
 1284:         high = Series(np.random.default_rng(2).standard_normal(len(idxh)), idxh)
 1285:         low = Series(np.random.default_rng(2).standard_normal(len(idxl)), idxl)
 1286:         _, ax = mpl.pyplot.subplots()
 1287:         low.plot(ax=ax)
 1288:         ax = high.plot(secondary_y=True, ax=ax)
 1289:         for line in ax.get_lines():
 1290:             assert PeriodIndex(line.get_xdata()).freq == "D"
 1291:         assert hasattr(ax, "left_ax")
 1292:         assert not hasattr(ax, "right_ax")
 1293:         for line in ax.left_ax.get_lines():
 1294:             assert PeriodIndex(line.get_xdata()).freq == "D"
 1295: 
 1296:     def test_secondary_legend(self):
 1297:         fig = mpl.pyplot.figure()
 1298:         ax = fig.add_subplot(211)
 1299: 
 1300:         # ts
 1301:         df = DataFrame(
 1302:             np.random.default_rng(2).standard_normal((10, 4)),
 1303:             columns=Index(list("ABCD"), dtype=object),
 1304:             index=date_range("2000-01-01", periods=10, freq="B"),
 1305:         )
 1306:         df.plot(secondary_y=["A", "B"], ax=ax)
 1307:         leg = ax.get_legend()
 1308:         assert len(leg.get_lines()) == 4
 1309:         assert leg.get_texts()[0].get_text() == "A (right)"
 1310:         assert leg.get_texts()[1].get_text() == "B (right)"
 1311:         assert leg.get_texts()[2].get_text() == "C"
 1312:         assert leg.get_texts()[3].get_text() == "D"
 1313:         assert ax.right_ax.get_legend() is None
 1314:         colors = set()
 1315:         for line in leg.get_lines():
 1316:             colors.add(line.get_color())
 1317: 
 1318:         # TODO: color cycle problems
 1319:         assert len(colors) == 4
 1320:         mpl.pyplot.close(fig)
 1321: 
 1322:     def test_secondary_legend_right(self):
 1323:         df = DataFrame(
 1324:             np.random.default_rng(2).standard_normal((10, 4)),
 1325:             columns=Index(list("ABCD"), dtype=object),
 1326:             index=date_range("2000-01-01", periods=10, freq="B"),
 1327:         )
 1328:         fig = mpl.pyplot.figure()
 1329:         ax = fig.add_subplot(211)
 1330:         df.plot(secondary_y=["A", "C"], mark_right=False, ax=ax)
 1331:         leg = ax.get_legend()
 1332:         assert len(leg.get_lines()) == 4
 1333:         assert leg.get_texts()[0].get_text() == "A"
 1334:         assert leg.get_texts()[1].get_text() == "B"
 1335:         assert leg.get_texts()[2].get_text() == "C"
 1336:         assert leg.get_texts()[3].get_text() == "D"
 1337:         mpl.pyplot.close(fig)
 1338: 
 1339:     def test_secondary_legend_bar(self):
 1340:         df = DataFrame(
 1341:             np.random.default_rng(2).standard_normal((10, 4)),
 1342:             columns=Index(list("ABCD"), dtype=object),
 1343:             index=date_range("2000-01-01", periods=10, freq="B"),
 1344:         )
 1345:         fig, ax = mpl.pyplot.subplots()
 1346:         df.plot(kind="bar", secondary_y=["A"], ax=ax)
 1347:         leg = ax.get_legend()
 1348:         assert leg.get_texts()[0].get_text() == "A (right)"
 1349:         assert leg.get_texts()[1].get_text() == "B"
 1350:         mpl.pyplot.close(fig)
 1351: 
 1352:     def test_secondary_legend_bar_right(self):
 1353:         df = DataFrame(
 1354:             np.random.default_rng(2).standard_normal((10, 4)),
 1355:             columns=Index(list("ABCD"), dtype=object),
 1356:             index=date_range("2000-01-01", periods=10, freq="B"),
 1357:         )
 1358:         fig, ax = mpl.pyplot.subplots()
 1359:         df.plot(kind="bar", secondary_y=["A"], mark_right=False, ax=ax)
 1360:         leg = ax.get_legend()
 1361:         assert leg.get_texts()[0].get_text() == "A"
 1362:         assert leg.get_texts()[1].get_text() == "B"
 1363:         mpl.pyplot.close(fig)
 1364: 
 1365:     def test_secondary_legend_multi_col(self):
 1366:         df = DataFrame(
 1367:             np.random.default_rng(2).standard_normal((10, 4)),
 1368:             columns=Index(list("ABCD"), dtype=object),
 1369:             index=date_range("2000-01-01", periods=10, freq="B"),
 1370:         )
 1371:         fig = mpl.pyplot.figure()
 1372:         ax = fig.add_subplot(211)
 1373:         df = DataFrame(
 1374:             np.random.default_rng(2).standard_normal((10, 4)),
 1375:             columns=Index(list("ABCD"), dtype=object),
 1376:             index=date_range("2000-01-01", periods=10, freq="B"),
 1377:         )
 1378:         ax = df.plot(secondary_y=["C", "D"], ax=ax)
 1379:         leg = ax.get_legend()
 1380:         assert len(leg.get_lines()) == 4
 1381:         assert ax.right_ax.get_legend() is None
 1382:         colors = set()
 1383:         for line in leg.get_lines():
 1384:             colors.add(line.get_color())
 1385: 
 1386:         # TODO: color cycle problems
 1387:         assert len(colors) == 4
 1388:         mpl.pyplot.close(fig)
 1389: 
 1390:     def test_secondary_legend_nonts(self):
 1391:         # non-ts
 1392:         df = DataFrame(
 1393:             1.1 * np.arange(120).reshape((30, 4)),
 1394:             columns=Index(list("ABCD"), dtype=object),
 1395:             index=Index([f"i-{i}" for i in range(30)], dtype=object),
 1396:         )
 1397:         fig = mpl.pyplot.figure()
 1398:         ax = fig.add_subplot(211)
 1399:         ax = df.plot(secondary_y=["A", "B"], ax=ax)
 1400:         leg = ax.get_legend()
 1401:         assert len(leg.get_lines()) == 4
 1402:         assert ax.right_ax.get_legend() is None
 1403:         colors = set()
 1404:         for line in leg.get_lines():
 1405:             colors.add(line.get_color())
 1406: 
 1407:         # TODO: color cycle problems
 1408:         assert len(colors) == 4
 1409:         mpl.pyplot.close()
 1410: 
 1411:     def test_secondary_legend_nonts_multi_col(self):
 1412:         # non-ts
 1413:         df = DataFrame(
 1414:             1.1 * np.arange(120).reshape((30, 4)),
 1415:             columns=Index(list("ABCD"), dtype=object),
 1416:             index=Index([f"i-{i}" for i in range(30)], dtype=object),
 1417:         )
 1418:         fig = mpl.pyplot.figure()
 1419:         ax = fig.add_subplot(211)
 1420:         ax = df.plot(secondary_y=["C", "D"], ax=ax)
 1421:         leg = ax.get_legend()
 1422:         assert len(leg.get_lines()) == 4
 1423:         assert ax.right_ax.get_legend() is None
 1424:         colors = set()
 1425:         for line in leg.get_lines():
 1426:             colors.add(line.get_color())
 1427: 
 1428:         # TODO: color cycle problems
 1429:         assert len(colors) == 4
 1430: 
 1431:     @pytest.mark.xfail(reason="Api changed in 3.6.0")
 1432:     def test_format_date_axis(self):
 1433:         rng = date_range("1/1/2012", periods=12, freq="ME")
 1434:         df = DataFrame(np.random.default_rng(2).standard_normal((len(rng), 3)), rng)
 1435:         _, ax = mpl.pyplot.subplots()
 1436:         ax = df.plot(ax=ax)
 1437:         xaxis = ax.get_xaxis()
 1438:         for line in xaxis.get_ticklabels():
 1439:             if len(line.get_text()) > 0:
 1440:                 assert line.get_rotation() == 30
 1441: 
 1442:     def test_ax_plot(self):
 1443:         x = date_range(start="2012-01-02", periods=10, freq="D")
 1444:         y = list(range(len(x)))
 1445:         _, ax = mpl.pyplot.subplots()
 1446:         lines = ax.plot(x, y, label="Y")
 1447:         tm.assert_index_equal(DatetimeIndex(lines[0].get_xdata()), x)
 1448: 
 1449:     def test_mpl_nopandas(self):
 1450:         dates = [date(2008, 12, 31), date(2009, 1, 31)]
 1451:         values1 = np.arange(10.0, 11.0, 0.5)
 1452:         values2 = np.arange(11.0, 12.0, 0.5)
 1453: 
 1454:         kw = {"fmt": "-", "lw": 4}
 1455: 
 1456:         _, ax = mpl.pyplot.subplots()
 1457:         ax.plot_date([x.toordinal() for x in dates], values1, **kw)
 1458:         ax.plot_date([x.toordinal() for x in dates], values2, **kw)
 1459: 
 1460:         line1, line2 = ax.get_lines()
 1461: 
 1462:         exp = np.array([x.toordinal() for x in dates], dtype=np.float64)
 1463:         tm.assert_numpy_array_equal(line1.get_xydata()[:, 0], exp)
 1464:         exp = np.array([x.toordinal() for x in dates], dtype=np.float64)
 1465:         tm.assert_numpy_array_equal(line2.get_xydata()[:, 0], exp)
 1466: 
 1467:     def test_irregular_ts_shared_ax_xlim(self):
 1468:         # GH 2960
 1469:         from pandas.plotting._matplotlib.converter import DatetimeConverter
 1470: 
 1471:         ts = Series(
 1472:             np.arange(20, dtype=np.float64), index=date_range("2020-01-01", periods=20)
 1473:         )
 1474:         ts_irregular = ts.iloc[[1, 4, 5, 6, 8, 9, 10, 12, 13, 14, 15, 17, 18]]
 1475: 
 1476:         # plot the left section of the irregular series, then the right section
 1477:         _, ax = mpl.pyplot.subplots()
 1478:         ts_irregular[:5].plot(ax=ax)
 1479:         ts_irregular[5:].plot(ax=ax)
 1480: 
 1481:         # check that axis limits are correct
 1482:         left, right = ax.get_xlim()
 1483:         assert left <= DatetimeConverter.convert(ts_irregular.index.min(), "", ax)
 1484:         assert right >= DatetimeConverter.convert(ts_irregular.index.max(), "", ax)
 1485: 
 1486:     def test_secondary_y_non_ts_xlim(self):
 1487:         # GH 3490 - non-timeseries with secondary y
 1488:         index_1 = [1, 2, 3, 4]
 1489:         index_2 = [5, 6, 7, 8]
 1490:         s1 = Series(1, index=index_1)
 1491:         s2 = Series(2, index=index_2)
 1492: 
 1493:         _, ax = mpl.pyplot.subplots()
 1494:         s1.plot(ax=ax)
 1495:         left_before, right_before = ax.get_xlim()
 1496:         s2.plot(secondary_y=True, ax=ax)
 1497:         left_after, right_after = ax.get_xlim()
 1498: 
 1499:         assert left_before >= left_after
 1500:         assert right_before < right_after
 1501: 
 1502:     def test_secondary_y_regular_ts_xlim(self):
 1503:         # GH 3490 - regular-timeseries with secondary y
 1504:         index_1 = date_range(start="2000-01-01", periods=4, freq="D")
 1505:         index_2 = date_range(start="2000-01-05", periods=4, freq="D")
 1506:         s1 = Series(1, index=index_1)
 1507:         s2 = Series(2, index=index_2)
 1508: 
 1509:         _, ax = mpl.pyplot.subplots()
 1510:         s1.plot(ax=ax)
 1511:         left_before, right_before = ax.get_xlim()
 1512:         s2.plot(secondary_y=True, ax=ax)
 1513:         left_after, right_after = ax.get_xlim()
 1514: 
 1515:         assert left_before >= left_after
 1516:         assert right_before < right_after
 1517: 
 1518:     def test_secondary_y_mixed_freq_ts_xlim(self):
 1519:         # GH 3490 - mixed frequency timeseries with secondary y
 1520:         rng = date_range("2000-01-01", periods=10000, freq="min")
 1521:         ts = Series(1, index=rng)
 1522: 
 1523:         _, ax = mpl.pyplot.subplots()
 1524:         ts.plot(ax=ax)
 1525:         left_before, right_before = ax.get_xlim()
 1526:         ts.resample("D").mean().plot(secondary_y=True, ax=ax)
 1527:         left_after, right_after = ax.get_xlim()
 1528: 
 1529:         # a downsample should not have changed either limit
 1530:         assert left_before == left_after
 1531:         assert right_before == right_after
 1532: 
 1533:     def test_secondary_y_irregular_ts_xlim(self):
 1534:         # GH 3490 - irregular-timeseries with secondary y
 1535:         from pandas.plotting._matplotlib.converter import DatetimeConverter
 1536: 
 1537:         ts = Series(
 1538:             np.arange(20, dtype=np.float64), index=date_range("2020-01-01", periods=20)
 1539:         )
 1540:         ts_irregular = ts.iloc[[1, 4, 5, 6, 8, 9, 10, 12, 13, 14, 15, 17, 18]]
 1541: 
 1542:         _, ax = mpl.pyplot.subplots()
 1543:         ts_irregular[:5].plot(ax=ax)
 1544:         # plot higher-x values on secondary axis
 1545:         ts_irregular[5:].plot(secondary_y=True, ax=ax)
 1546:         # ensure secondary limits aren't overwritten by plot on primary
 1547:         ts_irregular[:5].plot(ax=ax)
 1548: 
 1549:         left, right = ax.get_xlim()
 1550:         assert left <= DatetimeConverter.convert(ts_irregular.index.min(), "", ax)
 1551:         assert right >= DatetimeConverter.convert(ts_irregular.index.max(), "", ax)
 1552: 
 1553:     def test_plot_outofbounds_datetime(self):
 1554:         # 2579 - checking this does not raise
 1555:         values = [date(1677, 1, 1), date(1677, 1, 2)]
 1556:         _, ax = mpl.pyplot.subplots()
 1557:         ax.plot(values)
 1558: 
 1559:         values = [datetime(1677, 1, 1, 12), datetime(1677, 1, 2, 12)]
 1560:         ax.plot(values)
 1561: 
 1562:     def test_format_timedelta_ticks_narrow(self):
 1563:         expected_labels = [f"00:00:00.0000000{i:0>2d}" for i in np.arange(10)]
 1564: 
 1565:         rng = timedelta_range("0", periods=10, freq="ns")
 1566:         df = DataFrame(np.random.default_rng(2).standard_normal((len(rng), 3)), rng)
 1567:         _, ax = mpl.pyplot.subplots()
 1568:         df.plot(fontsize=2, ax=ax)
 1569:         mpl.pyplot.draw()
 1570:         labels = ax.get_xticklabels()
 1571: 
 1572:         result_labels = [x.get_text() for x in labels]
 1573:         assert len(result_labels) == len(expected_labels)
 1574:         assert result_labels == expected_labels
 1575: 
 1576:     def test_format_timedelta_ticks_wide(self):
 1577:         expected_labels = [
 1578:             "00:00:00",
 1579:             "1 days 03:46:40",
 1580:             "2 days 07:33:20",
 1581:             "3 days 11:20:00",
 1582:             "4 days 15:06:40",
 1583:             "5 days 18:53:20",
 1584:             "6 days 22:40:00",
 1585:             "8 days 02:26:40",
 1586:             "9 days 06:13:20",
 1587:         ]
 1588: 
 1589:         rng = timedelta_range("0", periods=10, freq="1 d")
 1590:         df = DataFrame(np.random.default_rng(2).standard_normal((len(rng), 3)), rng)
 1591:         _, ax = mpl.pyplot.subplots()
 1592:         ax = df.plot(fontsize=2, ax=ax)
 1593:         mpl.pyplot.draw()
 1594:         labels = ax.get_xticklabels()
 1595: 
 1596:         result_labels = [x.get_text() for x in labels]
 1597:         assert len(result_labels) == len(expected_labels)
 1598:         assert result_labels == expected_labels
 1599: 
 1600:     def test_timedelta_plot(self):
 1601:         # test issue #8711
 1602:         s = Series(range(5), timedelta_range("1day", periods=5))
 1603:         _, ax = mpl.pyplot.subplots()
 1604:         _check_plot_works(s.plot, ax=ax)
 1605: 
 1606:     def test_timedelta_long_period(self):
 1607:         # test long period
 1608:         index = timedelta_range("1 day 2 hr 30 min 10 s", periods=10, freq="1 d")
 1609:         s = Series(np.random.default_rng(2).standard_normal(len(index)), index)
 1610:         _, ax = mpl.pyplot.subplots()
 1611:         _check_plot_works(s.plot, ax=ax)
 1612: 
 1613:     def test_timedelta_short_period(self):
 1614:         # test short period
 1615:         index = timedelta_range("1 day 2 hr 30 min 10 s", periods=10, freq="1 ns")
 1616:         s = Series(np.random.default_rng(2).standard_normal(len(index)), index)
 1617:         _, ax = mpl.pyplot.subplots()
 1618:         _check_plot_works(s.plot, ax=ax)
 1619: 
 1620:     def test_hist(self):
 1621:         # https://github.com/matplotlib/matplotlib/issues/8459
 1622:         rng = date_range("1/1/2011", periods=10, freq="h")
 1623:         x = rng
 1624:         w1 = np.arange(0, 1, 0.1)
 1625:         w2 = np.arange(0, 1, 0.1)[::-1]
 1626:         _, ax = mpl.pyplot.subplots()
 1627:         ax.hist([x, x], weights=[w1, w2])
 1628: 
 1629:     def test_overlapping_datetime(self):
 1630:         # GB 6608
 1631:         s1 = Series(
 1632:             [1, 2, 3],
 1633:             index=[
 1634:                 datetime(1995, 12, 31),
 1635:                 datetime(2000, 12, 31),
 1636:                 datetime(2005, 12, 31),
 1637:             ],
 1638:         )
 1639:         s2 = Series(
 1640:             [1, 2, 3],
 1641:             index=[
 1642:                 datetime(1997, 12, 31),
 1643:                 datetime(2003, 12, 31),
 1644:                 datetime(2008, 12, 31),
 1645:             ],
 1646:         )
 1647: 
 1648:         # plot first series, then add the second series to those axes,
 1649:         # then try adding the first series again
 1650:         _, ax = mpl.pyplot.subplots()
 1651:         s1.plot(ax=ax)
 1652:         s2.plot(ax=ax)
 1653:         s1.plot(ax=ax)
 1654: 
 1655:     @pytest.mark.xfail(reason="GH9053 matplotlib does not use ax.xaxis.converter")
 1656:     def test_add_matplotlib_datetime64(self):
 1657:         # GH9053 - ensure that a plot with PeriodConverter still understands
 1658:         # datetime64 data. This still fails because matplotlib overrides the
 1659:         # ax.xaxis.converter with a DatetimeConverter
 1660:         s = Series(
 1661:             np.random.default_rng(2).standard_normal(10),
 1662:             index=date_range("1970-01-02", periods=10),
 1663:         )
 1664:         ax = s.plot()
 1665:         with tm.assert_produces_warning(DeprecationWarning):
 1666:             # multi-dimensional indexing
 1667:             ax.plot(s.index, s.values, color="g")
 1668:         l1, l2 = ax.lines
 1669:         tm.assert_numpy_array_equal(l1.get_xydata(), l2.get_xydata())
 1670: 
 1671:     def test_matplotlib_scatter_datetime64(self):
 1672:         # https://github.com/matplotlib/matplotlib/issues/11391
 1673:         df = DataFrame(np.random.default_rng(2).random((10, 2)), columns=["x", "y"])
 1674:         df["time"] = date_range("2018-01-01", periods=10, freq="D")
 1675:         _, ax = mpl.pyplot.subplots()
 1676:         ax.scatter(x="time", y="y", data=df)
 1677:         mpl.pyplot.draw()
 1678:         label = ax.get_xticklabels()[0]
 1679:         expected = "2018-01-01"
 1680:         assert label.get_text() == expected
 1681: 
 1682:     def test_check_xticks_rot(self):
 1683:         # https://github.com/pandas-dev/pandas/issues/29460
 1684:         # regular time series
 1685:         x = to_datetime(["2020-05-01", "2020-05-02", "2020-05-03"])
 1686:         df = DataFrame({"x": x, "y": [1, 2, 3]})
 1687:         axes = df.plot(x="x", y="y")
 1688:         _check_ticks_props(axes, xrot=0)
 1689: 
 1690:     def test_check_xticks_rot_irregular(self):
 1691:         # irregular time series
 1692:         x = to_datetime(["2020-05-01", "2020-05-02", "2020-05-04"])
 1693:         df = DataFrame({"x": x, "y": [1, 2, 3]})
 1694:         axes = df.plot(x="x", y="y")
 1695:         _check_ticks_props(axes, xrot=30)
 1696: 
 1697:     def test_check_xticks_rot_use_idx(self):
 1698:         # irregular time series
 1699:         x = to_datetime(["2020-05-01", "2020-05-02", "2020-05-04"])
 1700:         df = DataFrame({"x": x, "y": [1, 2, 3]})
 1701:         # use timeseries index or not
 1702:         axes = df.set_index("x").plot(y="y", use_index=True)
 1703:         _check_ticks_props(axes, xrot=30)
 1704:         axes = df.set_index("x").plot(y="y", use_index=False)
 1705:         _check_ticks_props(axes, xrot=0)
 1706: 
 1707:     def test_check_xticks_rot_sharex(self):
 1708:         # irregular time series
 1709:         x = to_datetime(["2020-05-01", "2020-05-02", "2020-05-04"])
 1710:         df = DataFrame({"x": x, "y": [1, 2, 3]})
 1711:         # separate subplots
 1712:         axes = df.plot(x="x", y="y", subplots=True, sharex=True)
 1713:         _check_ticks_props(axes, xrot=30)
 1714:         axes = df.plot(x="x", y="y", subplots=True, sharex=False)
 1715:         _check_ticks_props(axes, xrot=0)
 1716: 
 1717: 
 1718: def _check_plot_works(f, freq=None, series=None, *args, **kwargs):
 1719:     import matplotlib.pyplot as plt
 1720: 
 1721:     fig = plt.gcf()
 1722: 
 1723:     try:
 1724:         plt.clf()
 1725:         ax = fig.add_subplot(211)
 1726:         orig_ax = kwargs.pop("ax", plt.gca())
 1727:         orig_axfreq = getattr(orig_ax, "freq", None)
 1728: 
 1729:         ret = f(*args, **kwargs)
 1730:         assert ret is not None  # do something more intelligent
 1731: 
 1732:         ax = kwargs.pop("ax", plt.gca())
 1733:         if series is not None:
 1734:             dfreq = series.index.freq
 1735:             if isinstance(dfreq, BaseOffset):
 1736:                 dfreq = dfreq.rule_code
 1737:             if orig_axfreq is None:
 1738:                 assert ax.freq == dfreq
 1739: 
 1740:         if freq is not None:
 1741:             ax_freq = to_offset(ax.freq, is_period=True)
 1742:         if freq is not None and orig_axfreq is None:
 1743:             assert ax_freq == freq
 1744: 
 1745:         ax = fig.add_subplot(212)
 1746:         kwargs["ax"] = ax
 1747:         ret = f(*args, **kwargs)
 1748:         assert ret is not None  # TODO: do something more intelligent
 1749: 
 1750:         # GH18439, GH#24088, statsmodels#4772
 1751:         with tm.ensure_clean(return_filelike=True) as path:
 1752:             pickle.dump(fig, path)
 1753:     finally:
 1754:         plt.close(fig)
