    1: """ Test cases for .hist method """
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas import (
    8:     DataFrame,
    9:     Index,
   10:     Series,
   11:     date_range,
   12:     to_datetime,
   13: )
   14: import pandas._testing as tm
   15: from pandas.tests.plotting.common import (
   16:     _check_ax_scales,
   17:     _check_axes_shape,
   18:     _check_colors,
   19:     _check_legend_labels,
   20:     _check_patches_all_filled,
   21:     _check_plot_works,
   22:     _check_text_labels,
   23:     _check_ticks_props,
   24:     get_x_axis,
   25:     get_y_axis,
   26: )
   27: 
   28: mpl = pytest.importorskip("matplotlib")
   29: 
   30: 
   31: @pytest.fixture
   32: def ts():
   33:     return Series(
   34:         np.arange(30, dtype=np.float64),
   35:         index=date_range("2020-01-01", periods=30, freq="B"),
   36:         name="ts",
   37:     )
   38: 
   39: 
   40: class TestSeriesPlots:
   41:     @pytest.mark.parametrize("kwargs", [{}, {"grid": False}, {"figsize": (8, 10)}])
   42:     def test_hist_legacy_kwargs(self, ts, kwargs):
   43:         _check_plot_works(ts.hist, **kwargs)
   44: 
   45:     @pytest.mark.parametrize("kwargs", [{}, {"bins": 5}])
   46:     def test_hist_legacy_kwargs_warning(self, ts, kwargs):
   47:         # _check_plot_works adds an ax so catch warning. see GH #13188
   48:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
   49:             _check_plot_works(ts.hist, by=ts.index.month, **kwargs)
   50: 
   51:     def test_hist_legacy_ax(self, ts):
   52:         fig, ax = mpl.pyplot.subplots(1, 1)
   53:         _check_plot_works(ts.hist, ax=ax, default_axes=True)
   54: 
   55:     def test_hist_legacy_ax_and_fig(self, ts):
   56:         fig, ax = mpl.pyplot.subplots(1, 1)
   57:         _check_plot_works(ts.hist, ax=ax, figure=fig, default_axes=True)
   58: 
   59:     def test_hist_legacy_fig(self, ts):
   60:         fig, _ = mpl.pyplot.subplots(1, 1)
   61:         _check_plot_works(ts.hist, figure=fig, default_axes=True)
   62: 
   63:     def test_hist_legacy_multi_ax(self, ts):
   64:         fig, (ax1, ax2) = mpl.pyplot.subplots(1, 2)
   65:         _check_plot_works(ts.hist, figure=fig, ax=ax1, default_axes=True)
   66:         _check_plot_works(ts.hist, figure=fig, ax=ax2, default_axes=True)
   67: 
   68:     def test_hist_legacy_by_fig_error(self, ts):
   69:         fig, _ = mpl.pyplot.subplots(1, 1)
   70:         msg = (
   71:             "Cannot pass 'figure' when using the 'by' argument, since a new 'Figure' "
   72:             "instance will be created"
   73:         )
   74:         with pytest.raises(ValueError, match=msg):
   75:             ts.hist(by=ts.index, figure=fig)
   76: 
   77:     def test_hist_bins_legacy(self):
   78:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)))
   79:         ax = df.hist(bins=2)[0][0]
   80:         assert len(ax.patches) == 2
   81: 
   82:     def test_hist_layout(self, hist_df):
   83:         df = hist_df
   84:         msg = "The 'layout' keyword is not supported when 'by' is None"
   85:         with pytest.raises(ValueError, match=msg):
   86:             df.height.hist(layout=(1, 1))
   87: 
   88:         with pytest.raises(ValueError, match=msg):
   89:             df.height.hist(layout=[1, 1])
   90: 
   91:     @pytest.mark.slow
   92:     @pytest.mark.parametrize(
   93:         "by, layout, axes_num, res_layout",
   94:         [
   95:             ["gender", (2, 1), 2, (2, 1)],
   96:             ["gender", (3, -1), 2, (3, 1)],
   97:             ["category", (4, 1), 4, (4, 1)],
   98:             ["category", (2, -1), 4, (2, 2)],
   99:             ["category", (3, -1), 4, (3, 2)],
  100:             ["category", (-1, 4), 4, (1, 4)],
  101:             ["classroom", (2, 2), 3, (2, 2)],
  102:         ],
  103:     )
  104:     def test_hist_layout_with_by(self, hist_df, by, layout, axes_num, res_layout):
  105:         df = hist_df
  106: 
  107:         # _check_plot_works adds an `ax` kwarg to the method call
  108:         # so we get a warning about an axis being cleared, even
  109:         # though we don't explicing pass one, see GH #13188
  110:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  111:             axes = _check_plot_works(df.height.hist, by=getattr(df, by), layout=layout)
  112:         _check_axes_shape(axes, axes_num=axes_num, layout=res_layout)
  113: 
  114:     def test_hist_layout_with_by_shape(self, hist_df):
  115:         df = hist_df
  116: 
  117:         axes = df.height.hist(by=df.category, layout=(4, 2), figsize=(12, 7))
  118:         _check_axes_shape(axes, axes_num=4, layout=(4, 2), figsize=(12, 7))
  119: 
  120:     def test_hist_no_overlap(self):
  121:         from matplotlib.pyplot import (
  122:             gcf,
  123:             subplot,
  124:         )
  125: 
  126:         x = Series(np.random.default_rng(2).standard_normal(2))
  127:         y = Series(np.random.default_rng(2).standard_normal(2))
  128:         subplot(121)
  129:         x.hist()
  130:         subplot(122)
  131:         y.hist()
  132:         fig = gcf()
  133:         axes = fig.axes
  134:         assert len(axes) == 2
  135: 
  136:     def test_hist_by_no_extra_plots(self, hist_df):
  137:         df = hist_df
  138:         df.height.hist(by=df.gender)
  139:         assert len(mpl.pyplot.get_fignums()) == 1
  140: 
  141:     def test_plot_fails_when_ax_differs_from_figure(self, ts):
  142:         from pylab import figure
  143: 
  144:         fig1 = figure()
  145:         fig2 = figure()
  146:         ax1 = fig1.add_subplot(111)
  147:         msg = "passed axis not bound to passed figure"
  148:         with pytest.raises(AssertionError, match=msg):
  149:             ts.hist(ax=ax1, figure=fig2)
  150: 
  151:     @pytest.mark.parametrize(
  152:         "histtype, expected",
  153:         [
  154:             ("bar", True),
  155:             ("barstacked", True),
  156:             ("step", False),
  157:             ("stepfilled", True),
  158:         ],
  159:     )
  160:     def test_histtype_argument(self, histtype, expected):
  161:         # GH23992 Verify functioning of histtype argument
  162:         ser = Series(np.random.default_rng(2).integers(1, 10))
  163:         ax = ser.hist(histtype=histtype)
  164:         _check_patches_all_filled(ax, filled=expected)
  165: 
  166:     @pytest.mark.parametrize(
  167:         "by, expected_axes_num, expected_layout", [(None, 1, (1, 1)), ("b", 2, (1, 2))]
  168:     )
  169:     def test_hist_with_legend(self, by, expected_axes_num, expected_layout):
  170:         # GH 6279 - Series histogram can have a legend
  171:         index = 15 * ["1"] + 15 * ["2"]
  172:         s = Series(np.random.default_rng(2).standard_normal(30), index=index, name="a")
  173:         s.index.name = "b"
  174: 
  175:         # Use default_axes=True when plotting method generate subplots itself
  176:         axes = _check_plot_works(s.hist, default_axes=True, legend=True, by=by)
  177:         _check_axes_shape(axes, axes_num=expected_axes_num, layout=expected_layout)
  178:         _check_legend_labels(axes, "a")
  179: 
  180:     @pytest.mark.parametrize("by", [None, "b"])
  181:     def test_hist_with_legend_raises(self, by):
  182:         # GH 6279 - Series histogram with legend and label raises
  183:         index = 15 * ["1"] + 15 * ["2"]
  184:         s = Series(np.random.default_rng(2).standard_normal(30), index=index, name="a")
  185:         s.index.name = "b"
  186: 
  187:         with pytest.raises(ValueError, match="Cannot use both legend and label"):
  188:             s.hist(legend=True, by=by, label="c")
  189: 
  190:     def test_hist_kwargs(self, ts):
  191:         _, ax = mpl.pyplot.subplots()
  192:         ax = ts.plot.hist(bins=5, ax=ax)
  193:         assert len(ax.patches) == 5
  194:         _check_text_labels(ax.yaxis.get_label(), "Frequency")
  195: 
  196:     def test_hist_kwargs_horizontal(self, ts):
  197:         _, ax = mpl.pyplot.subplots()
  198:         ax = ts.plot.hist(bins=5, ax=ax)
  199:         ax = ts.plot.hist(orientation="horizontal", ax=ax)
  200:         _check_text_labels(ax.xaxis.get_label(), "Frequency")
  201: 
  202:     def test_hist_kwargs_align(self, ts):
  203:         _, ax = mpl.pyplot.subplots()
  204:         ax = ts.plot.hist(bins=5, ax=ax)
  205:         ax = ts.plot.hist(align="left", stacked=True, ax=ax)
  206: 
  207:     @pytest.mark.xfail(reason="Api changed in 3.6.0")
  208:     def test_hist_kde(self, ts):
  209:         pytest.importorskip("scipy")
  210:         _, ax = mpl.pyplot.subplots()
  211:         ax = ts.plot.hist(logy=True, ax=ax)
  212:         _check_ax_scales(ax, yaxis="log")
  213:         xlabels = ax.get_xticklabels()
  214:         # ticks are values, thus ticklabels are blank
  215:         _check_text_labels(xlabels, [""] * len(xlabels))
  216:         ylabels = ax.get_yticklabels()
  217:         _check_text_labels(ylabels, [""] * len(ylabels))
  218: 
  219:     def test_hist_kde_plot_works(self, ts):
  220:         pytest.importorskip("scipy")
  221:         _check_plot_works(ts.plot.kde)
  222: 
  223:     def test_hist_kde_density_works(self, ts):
  224:         pytest.importorskip("scipy")
  225:         _check_plot_works(ts.plot.density)
  226: 
  227:     @pytest.mark.xfail(reason="Api changed in 3.6.0")
  228:     def test_hist_kde_logy(self, ts):
  229:         pytest.importorskip("scipy")
  230:         _, ax = mpl.pyplot.subplots()
  231:         ax = ts.plot.kde(logy=True, ax=ax)
  232:         _check_ax_scales(ax, yaxis="log")
  233:         xlabels = ax.get_xticklabels()
  234:         _check_text_labels(xlabels, [""] * len(xlabels))
  235:         ylabels = ax.get_yticklabels()
  236:         _check_text_labels(ylabels, [""] * len(ylabels))
  237: 
  238:     def test_hist_kde_color_bins(self, ts):
  239:         pytest.importorskip("scipy")
  240:         _, ax = mpl.pyplot.subplots()
  241:         ax = ts.plot.hist(logy=True, bins=10, color="b", ax=ax)
  242:         _check_ax_scales(ax, yaxis="log")
  243:         assert len(ax.patches) == 10
  244:         _check_colors(ax.patches, facecolors=["b"] * 10)
  245: 
  246:     def test_hist_kde_color(self, ts):
  247:         pytest.importorskip("scipy")
  248:         _, ax = mpl.pyplot.subplots()
  249:         ax = ts.plot.kde(logy=True, color="r", ax=ax)
  250:         _check_ax_scales(ax, yaxis="log")
  251:         lines = ax.get_lines()
  252:         assert len(lines) == 1
  253:         _check_colors(lines, ["r"])
  254: 
  255: 
  256: class TestDataFramePlots:
  257:     @pytest.mark.slow
  258:     def test_hist_df_legacy(self, hist_df):
  259:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  260:             _check_plot_works(hist_df.hist)
  261: 
  262:     @pytest.mark.slow
  263:     def test_hist_df_legacy_layout(self):
  264:         # make sure layout is handled
  265:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)))
  266:         df[2] = to_datetime(
  267:             np.random.default_rng(2).integers(
  268:                 812419200000000000,
  269:                 819331200000000000,
  270:                 size=10,
  271:                 dtype=np.int64,
  272:             )
  273:         )
  274:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  275:             axes = _check_plot_works(df.hist, grid=False)
  276:         _check_axes_shape(axes, axes_num=3, layout=(2, 2))
  277:         assert not axes[1, 1].get_visible()
  278: 
  279:         _check_plot_works(df[[2]].hist)
  280: 
  281:     @pytest.mark.slow
  282:     def test_hist_df_legacy_layout2(self):
  283:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 1)))
  284:         _check_plot_works(df.hist)
  285: 
  286:     @pytest.mark.slow
  287:     def test_hist_df_legacy_layout3(self):
  288:         # make sure layout is handled
  289:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 5)))
  290:         df[5] = to_datetime(
  291:             np.random.default_rng(2).integers(
  292:                 812419200000000000,
  293:                 819331200000000000,
  294:                 size=10,
  295:                 dtype=np.int64,
  296:             )
  297:         )
  298:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  299:             axes = _check_plot_works(df.hist, layout=(4, 2))
  300:         _check_axes_shape(axes, axes_num=6, layout=(4, 2))
  301: 
  302:     @pytest.mark.slow
  303:     @pytest.mark.parametrize(
  304:         "kwargs", [{"sharex": True, "sharey": True}, {"figsize": (8, 10)}, {"bins": 5}]
  305:     )
  306:     def test_hist_df_legacy_layout_kwargs(self, kwargs):
  307:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 5)))
  308:         df[5] = to_datetime(
  309:             np.random.default_rng(2).integers(
  310:                 812419200000000000,
  311:                 819331200000000000,
  312:                 size=10,
  313:                 dtype=np.int64,
  314:             )
  315:         )
  316:         # make sure sharex, sharey is handled
  317:         # handle figsize arg
  318:         # check bins argument
  319:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  320:             _check_plot_works(df.hist, **kwargs)
  321: 
  322:     @pytest.mark.slow
  323:     def test_hist_df_legacy_layout_labelsize_rot(self, frame_or_series):
  324:         # make sure xlabelsize and xrot are handled
  325:         obj = frame_or_series(range(10))
  326:         xf, yf = 20, 18
  327:         xrot, yrot = 30, 40
  328:         axes = obj.hist(xlabelsize=xf, xrot=xrot, ylabelsize=yf, yrot=yrot)
  329:         _check_ticks_props(axes, xlabelsize=xf, xrot=xrot, ylabelsize=yf, yrot=yrot)
  330: 
  331:     @pytest.mark.slow
  332:     def test_hist_df_legacy_rectangles(self):
  333:         from matplotlib.patches import Rectangle
  334: 
  335:         ser = Series(range(10))
  336:         ax = ser.hist(cumulative=True, bins=4, density=True)
  337:         # height of last bin (index 5) must be 1.0
  338:         rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
  339:         tm.assert_almost_equal(rects[-1].get_height(), 1.0)
  340: 
  341:     @pytest.mark.slow
  342:     def test_hist_df_legacy_scale(self):
  343:         ser = Series(range(10))
  344:         ax = ser.hist(log=True)
  345:         # scale of y must be 'log'
  346:         _check_ax_scales(ax, yaxis="log")
  347: 
  348:     @pytest.mark.slow
  349:     def test_hist_df_legacy_external_error(self):
  350:         ser = Series(range(10))
  351:         # propagate attr exception from matplotlib.Axes.hist
  352:         with tm.external_error_raised(AttributeError):
  353:             ser.hist(foo="bar")
  354: 
  355:     def test_hist_non_numerical_or_datetime_raises(self):
  356:         # gh-10444, GH32590
  357:         df = DataFrame(
  358:             {
  359:                 "a": np.random.default_rng(2).random(10),
  360:                 "b": np.random.default_rng(2).integers(0, 10, 10),
  361:                 "c": to_datetime(
  362:                     np.random.default_rng(2).integers(
  363:                         1582800000000000000, 1583500000000000000, 10, dtype=np.int64
  364:                     )
  365:                 ),
  366:                 "d": to_datetime(
  367:                     np.random.default_rng(2).integers(
  368:                         1582800000000000000, 1583500000000000000, 10, dtype=np.int64
  369:                     ),
  370:                     utc=True,
  371:                 ),
  372:             }
  373:         )
  374:         df_o = df.astype(object)
  375: 
  376:         msg = "hist method requires numerical or datetime columns, nothing to plot."
  377:         with pytest.raises(ValueError, match=msg):
  378:             df_o.hist()
  379: 
  380:     @pytest.mark.parametrize(
  381:         "layout_test",
  382:         (
  383:             {"layout": None, "expected_size": (2, 2)},  # default is 2x2
  384:             {"layout": (2, 2), "expected_size": (2, 2)},
  385:             {"layout": (4, 1), "expected_size": (4, 1)},
  386:             {"layout": (1, 4), "expected_size": (1, 4)},
  387:             {"layout": (3, 3), "expected_size": (3, 3)},
  388:             {"layout": (-1, 4), "expected_size": (1, 4)},
  389:             {"layout": (4, -1), "expected_size": (4, 1)},
  390:             {"layout": (-1, 2), "expected_size": (2, 2)},
  391:             {"layout": (2, -1), "expected_size": (2, 2)},
  392:         ),
  393:     )
  394:     def test_hist_layout(self, layout_test):
  395:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)))
  396:         df[2] = to_datetime(
  397:             np.random.default_rng(2).integers(
  398:                 812419200000000000,
  399:                 819331200000000000,
  400:                 size=10,
  401:                 dtype=np.int64,
  402:             )
  403:         )
  404:         axes = df.hist(layout=layout_test["layout"])
  405:         expected = layout_test["expected_size"]
  406:         _check_axes_shape(axes, axes_num=3, layout=expected)
  407: 
  408:     def test_hist_layout_error(self):
  409:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)))
  410:         df[2] = to_datetime(
  411:             np.random.default_rng(2).integers(
  412:                 812419200000000000,
  413:                 819331200000000000,
  414:                 size=10,
  415:                 dtype=np.int64,
  416:             )
  417:         )
  418:         # layout too small for all 4 plots
  419:         msg = "Layout of 1x1 must be larger than required size 3"
  420:         with pytest.raises(ValueError, match=msg):
  421:             df.hist(layout=(1, 1))
  422: 
  423:         # invalid format for layout
  424:         msg = re.escape("Layout must be a tuple of (rows, columns)")
  425:         with pytest.raises(ValueError, match=msg):
  426:             df.hist(layout=(1,))
  427:         msg = "At least one dimension of layout must be positive"
  428:         with pytest.raises(ValueError, match=msg):
  429:             df.hist(layout=(-1, -1))
  430: 
  431:     # GH 9351
  432:     def test_tight_layout(self):
  433:         df = DataFrame(np.random.default_rng(2).standard_normal((100, 2)))
  434:         df[2] = to_datetime(
  435:             np.random.default_rng(2).integers(
  436:                 812419200000000000,
  437:                 819331200000000000,
  438:                 size=100,
  439:                 dtype=np.int64,
  440:             )
  441:         )
  442:         # Use default_axes=True when plotting method generate subplots itself
  443:         _check_plot_works(df.hist, default_axes=True)
  444:         mpl.pyplot.tight_layout()
  445: 
  446:     def test_hist_subplot_xrot(self):
  447:         # GH 30288
  448:         df = DataFrame(
  449:             {
  450:                 "length": [1.5, 0.5, 1.2, 0.9, 3],
  451:                 "animal": ["pig", "rabbit", "pig", "pig", "rabbit"],
  452:             }
  453:         )
  454:         # Use default_axes=True when plotting method generate subplots itself
  455:         axes = _check_plot_works(
  456:             df.hist,
  457:             default_axes=True,
  458:             column="length",
  459:             by="animal",
  460:             bins=5,
  461:             xrot=0,
  462:         )
  463:         _check_ticks_props(axes, xrot=0)
  464: 
  465:     @pytest.mark.parametrize(
  466:         "column, expected",
  467:         [
  468:             (None, ["width", "length", "height"]),
  469:             (["length", "width", "height"], ["length", "width", "height"]),
  470:         ],
  471:     )
  472:     def test_hist_column_order_unchanged(self, column, expected):
  473:         # GH29235
  474: 
  475:         df = DataFrame(
  476:             {
  477:                 "width": [0.7, 0.2, 0.15, 0.2, 1.1],
  478:                 "length": [1.5, 0.5, 1.2, 0.9, 3],
  479:                 "height": [3, 0.5, 3.4, 2, 1],
  480:             },
  481:             index=["pig", "rabbit", "duck", "chicken", "horse"],
  482:         )
  483: 
  484:         # Use default_axes=True when plotting method generate subplots itself
  485:         axes = _check_plot_works(
  486:             df.hist,
  487:             default_axes=True,
  488:             column=column,
  489:             layout=(1, 3),
  490:         )
  491:         result = [axes[0, i].get_title() for i in range(3)]
  492:         assert result == expected
  493: 
  494:     @pytest.mark.parametrize(
  495:         "histtype, expected",
  496:         [
  497:             ("bar", True),
  498:             ("barstacked", True),
  499:             ("step", False),
  500:             ("stepfilled", True),
  501:         ],
  502:     )
  503:     def test_histtype_argument(self, histtype, expected):
  504:         # GH23992 Verify functioning of histtype argument
  505:         df = DataFrame(
  506:             np.random.default_rng(2).integers(1, 10, size=(100, 2)), columns=["a", "b"]
  507:         )
  508:         ax = df.hist(histtype=histtype)
  509:         _check_patches_all_filled(ax, filled=expected)
  510: 
  511:     @pytest.mark.parametrize("by", [None, "c"])
  512:     @pytest.mark.parametrize("column", [None, "b"])
  513:     def test_hist_with_legend(self, by, column):
  514:         # GH 6279 - DataFrame histogram can have a legend
  515:         expected_axes_num = 1 if by is None and column is not None else 2
  516:         expected_layout = (1, expected_axes_num)
  517:         expected_labels = column or ["a", "b"]
  518:         if by is not None:
  519:             expected_labels = [expected_labels] * 2
  520: 
  521:         index = Index(15 * ["1"] + 15 * ["2"], name="c")
  522:         df = DataFrame(
  523:             np.random.default_rng(2).standard_normal((30, 2)),
  524:             index=index,
  525:             columns=["a", "b"],
  526:         )
  527: 
  528:         # Use default_axes=True when plotting method generate subplots itself
  529:         axes = _check_plot_works(
  530:             df.hist,
  531:             default_axes=True,
  532:             legend=True,
  533:             by=by,
  534:             column=column,
  535:         )
  536: 
  537:         _check_axes_shape(axes, axes_num=expected_axes_num, layout=expected_layout)
  538:         if by is None and column is None:
  539:             axes = axes[0]
  540:         for expected_label, ax in zip(expected_labels, axes):
  541:             _check_legend_labels(ax, expected_label)
  542: 
  543:     @pytest.mark.parametrize("by", [None, "c"])
  544:     @pytest.mark.parametrize("column", [None, "b"])
  545:     def test_hist_with_legend_raises(self, by, column):
  546:         # GH 6279 - DataFrame histogram with legend and label raises
  547:         index = Index(15 * ["1"] + 15 * ["2"], name="c")
  548:         df = DataFrame(
  549:             np.random.default_rng(2).standard_normal((30, 2)),
  550:             index=index,
  551:             columns=["a", "b"],
  552:         )
  553: 
  554:         with pytest.raises(ValueError, match="Cannot use both legend and label"):
  555:             df.hist(legend=True, by=by, column=column, label="d")
  556: 
  557:     def test_hist_df_kwargs(self):
  558:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 2)))
  559:         _, ax = mpl.pyplot.subplots()
  560:         ax = df.plot.hist(bins=5, ax=ax)
  561:         assert len(ax.patches) == 10
  562: 
  563:     def test_hist_df_with_nonnumerics(self):
  564:         # GH 9853
  565:         df = DataFrame(
  566:             np.random.default_rng(2).standard_normal((10, 4)),
  567:             columns=["A", "B", "C", "D"],
  568:         )
  569:         df["E"] = ["x", "y"] * 5
  570:         _, ax = mpl.pyplot.subplots()
  571:         ax = df.plot.hist(bins=5, ax=ax)
  572:         assert len(ax.patches) == 20
  573: 
  574:     def test_hist_df_with_nonnumerics_no_bins(self):
  575:         # GH 9853
  576:         df = DataFrame(
  577:             np.random.default_rng(2).standard_normal((10, 4)),
  578:             columns=["A", "B", "C", "D"],
  579:         )
  580:         df["E"] = ["x", "y"] * 5
  581:         _, ax = mpl.pyplot.subplots()
  582:         ax = df.plot.hist(ax=ax)  # bins=10
  583:         assert len(ax.patches) == 40
  584: 
  585:     def test_hist_secondary_legend(self):
  586:         # GH 9610
  587:         df = DataFrame(
  588:             np.random.default_rng(2).standard_normal((30, 4)), columns=list("abcd")
  589:         )
  590: 
  591:         # primary -> secondary
  592:         _, ax = mpl.pyplot.subplots()
  593:         ax = df["a"].plot.hist(legend=True, ax=ax)
  594:         df["b"].plot.hist(ax=ax, legend=True, secondary_y=True)
  595:         # both legends are drawn on left ax
  596:         # left and right axis must be visible
  597:         _check_legend_labels(ax, labels=["a", "b (right)"])
  598:         assert ax.get_yaxis().get_visible()
  599:         assert ax.right_ax.get_yaxis().get_visible()
  600: 
  601:     def test_hist_secondary_secondary(self):
  602:         # GH 9610
  603:         df = DataFrame(
  604:             np.random.default_rng(2).standard_normal((30, 4)), columns=list("abcd")
  605:         )
  606:         # secondary -> secondary
  607:         _, ax = mpl.pyplot.subplots()
  608:         ax = df["a"].plot.hist(legend=True, secondary_y=True, ax=ax)
  609:         df["b"].plot.hist(ax=ax, legend=True, secondary_y=True)
  610:         # both legends are draw on left ax
  611:         # left axis must be invisible, right axis must be visible
  612:         _check_legend_labels(ax.left_ax, labels=["a (right)", "b (right)"])
  613:         assert not ax.left_ax.get_yaxis().get_visible()
  614:         assert ax.get_yaxis().get_visible()
  615: 
  616:     def test_hist_secondary_primary(self):
  617:         # GH 9610
  618:         df = DataFrame(
  619:             np.random.default_rng(2).standard_normal((30, 4)), columns=list("abcd")
  620:         )
  621:         # secondary -> primary
  622:         _, ax = mpl.pyplot.subplots()
  623:         ax = df["a"].plot.hist(legend=True, secondary_y=True, ax=ax)
  624:         # right axes is returned
  625:         df["b"].plot.hist(ax=ax, legend=True)
  626:         # both legends are draw on left ax
  627:         # left and right axis must be visible
  628:         _check_legend_labels(ax.left_ax, labels=["a (right)", "b"])
  629:         assert ax.left_ax.get_yaxis().get_visible()
  630:         assert ax.get_yaxis().get_visible()
  631: 
  632:     def test_hist_with_nans_and_weights(self):
  633:         # GH 48884
  634:         mpl_patches = pytest.importorskip("matplotlib.patches")
  635:         df = DataFrame(
  636:             [[np.nan, 0.2, 0.3], [0.4, np.nan, np.nan], [0.7, 0.8, 0.9]],
  637:             columns=list("abc"),
  638:         )
  639:         weights = np.array([0.25, 0.3, 0.45])
  640:         no_nan_df = DataFrame([[0.4, 0.2, 0.3], [0.7, 0.8, 0.9]], columns=list("abc"))
  641:         no_nan_weights = np.array([[0.3, 0.25, 0.25], [0.45, 0.45, 0.45]])
  642: 
  643:         _, ax0 = mpl.pyplot.subplots()
  644:         df.plot.hist(ax=ax0, weights=weights)
  645:         rects = [x for x in ax0.get_children() if isinstance(x, mpl_patches.Rectangle)]
  646:         heights = [rect.get_height() for rect in rects]
  647:         _, ax1 = mpl.pyplot.subplots()
  648:         no_nan_df.plot.hist(ax=ax1, weights=no_nan_weights)
  649:         no_nan_rects = [
  650:             x for x in ax1.get_children() if isinstance(x, mpl_patches.Rectangle)
  651:         ]
  652:         no_nan_heights = [rect.get_height() for rect in no_nan_rects]
  653:         assert all(h0 == h1 for h0, h1 in zip(heights, no_nan_heights))
  654: 
  655:         idxerror_weights = np.array([[0.3, 0.25], [0.45, 0.45]])
  656: 
  657:         msg = "weights must have the same shape as data, or be a single column"
  658:         with pytest.raises(ValueError, match=msg):
  659:             _, ax2 = mpl.pyplot.subplots()
  660:             no_nan_df.plot.hist(ax=ax2, weights=idxerror_weights)
  661: 
  662: 
  663: class TestDataFrameGroupByPlots:
  664:     def test_grouped_hist_legacy(self):
  665:         from pandas.plotting._matplotlib.hist import _grouped_hist
  666: 
  667:         rs = np.random.default_rng(10)
  668:         df = DataFrame(rs.standard_normal((10, 1)), columns=["A"])
  669:         df["B"] = to_datetime(
  670:             rs.integers(
  671:                 812419200000000000,
  672:                 819331200000000000,
  673:                 size=10,
  674:                 dtype=np.int64,
  675:             )
  676:         )
  677:         df["C"] = rs.integers(0, 4, 10)
  678:         df["D"] = ["X"] * 10
  679: 
  680:         axes = _grouped_hist(df.A, by=df.C)
  681:         _check_axes_shape(axes, axes_num=4, layout=(2, 2))
  682: 
  683:     def test_grouped_hist_legacy_axes_shape_no_col(self):
  684:         rs = np.random.default_rng(10)
  685:         df = DataFrame(rs.standard_normal((10, 1)), columns=["A"])
  686:         df["B"] = to_datetime(
  687:             rs.integers(
  688:                 812419200000000000,
  689:                 819331200000000000,
  690:                 size=10,
  691:                 dtype=np.int64,
  692:             )
  693:         )
  694:         df["C"] = rs.integers(0, 4, 10)
  695:         df["D"] = ["X"] * 10
  696:         axes = df.hist(by=df.C)
  697:         _check_axes_shape(axes, axes_num=4, layout=(2, 2))
  698: 
  699:     def test_grouped_hist_legacy_single_key(self):
  700:         rs = np.random.default_rng(2)
  701:         df = DataFrame(rs.standard_normal((10, 1)), columns=["A"])
  702:         df["B"] = to_datetime(
  703:             rs.integers(
  704:                 812419200000000000,
  705:                 819331200000000000,
  706:                 size=10,
  707:                 dtype=np.int64,
  708:             )
  709:         )
  710:         df["C"] = rs.integers(0, 4, 10)
  711:         df["D"] = ["X"] * 10
  712:         # group by a key with single value
  713:         axes = df.hist(by="D", rot=30)
  714:         _check_axes_shape(axes, axes_num=1, layout=(1, 1))
  715:         _check_ticks_props(axes, xrot=30)
  716: 
  717:     def test_grouped_hist_legacy_grouped_hist_kwargs(self):
  718:         from matplotlib.patches import Rectangle
  719: 
  720:         from pandas.plotting._matplotlib.hist import _grouped_hist
  721: 
  722:         rs = np.random.default_rng(2)
  723:         df = DataFrame(rs.standard_normal((10, 1)), columns=["A"])
  724:         df["B"] = to_datetime(
  725:             rs.integers(
  726:                 812419200000000000,
  727:                 819331200000000000,
  728:                 size=10,
  729:                 dtype=np.int64,
  730:             )
  731:         )
  732:         df["C"] = rs.integers(0, 4, 10)
  733:         # make sure kwargs to hist are handled
  734:         xf, yf = 20, 18
  735:         xrot, yrot = 30, 40
  736: 
  737:         axes = _grouped_hist(
  738:             df.A,
  739:             by=df.C,
  740:             cumulative=True,
  741:             bins=4,
  742:             xlabelsize=xf,
  743:             xrot=xrot,
  744:             ylabelsize=yf,
  745:             yrot=yrot,
  746:             density=True,
  747:         )
  748:         # height of last bin (index 5) must be 1.0
  749:         for ax in axes.ravel():
  750:             rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
  751:             height = rects[-1].get_height()
  752:             tm.assert_almost_equal(height, 1.0)
  753:         _check_ticks_props(axes, xlabelsize=xf, xrot=xrot, ylabelsize=yf, yrot=yrot)
  754: 
  755:     def test_grouped_hist_legacy_grouped_hist(self):
  756:         from pandas.plotting._matplotlib.hist import _grouped_hist
  757: 
  758:         rs = np.random.default_rng(2)
  759:         df = DataFrame(rs.standard_normal((10, 1)), columns=["A"])
  760:         df["B"] = to_datetime(
  761:             rs.integers(
  762:                 812419200000000000,
  763:                 819331200000000000,
  764:                 size=10,
  765:                 dtype=np.int64,
  766:             )
  767:         )
  768:         df["C"] = rs.integers(0, 4, 10)
  769:         df["D"] = ["X"] * 10
  770:         axes = _grouped_hist(df.A, by=df.C, log=True)
  771:         # scale of y must be 'log'
  772:         _check_ax_scales(axes, yaxis="log")
  773: 
  774:     def test_grouped_hist_legacy_external_err(self):
  775:         from pandas.plotting._matplotlib.hist import _grouped_hist
  776: 
  777:         rs = np.random.default_rng(2)
  778:         df = DataFrame(rs.standard_normal((10, 1)), columns=["A"])
  779:         df["B"] = to_datetime(
  780:             rs.integers(
  781:                 812419200000000000,
  782:                 819331200000000000,
  783:                 size=10,
  784:                 dtype=np.int64,
  785:             )
  786:         )
  787:         df["C"] = rs.integers(0, 4, 10)
  788:         df["D"] = ["X"] * 10
  789:         # propagate attr exception from matplotlib.Axes.hist
  790:         with tm.external_error_raised(AttributeError):
  791:             _grouped_hist(df.A, by=df.C, foo="bar")
  792: 
  793:     def test_grouped_hist_legacy_figsize_err(self):
  794:         rs = np.random.default_rng(2)
  795:         df = DataFrame(rs.standard_normal((10, 1)), columns=["A"])
  796:         df["B"] = to_datetime(
  797:             rs.integers(
  798:                 812419200000000000,
  799:                 819331200000000000,
  800:                 size=10,
  801:                 dtype=np.int64,
  802:             )
  803:         )
  804:         df["C"] = rs.integers(0, 4, 10)
  805:         df["D"] = ["X"] * 10
  806:         msg = "Specify figure size by tuple instead"
  807:         with pytest.raises(ValueError, match=msg):
  808:             df.hist(by="C", figsize="default")
  809: 
  810:     def test_grouped_hist_legacy2(self):
  811:         n = 10
  812:         weight = Series(np.random.default_rng(2).normal(166, 20, size=n))
  813:         height = Series(np.random.default_rng(2).normal(60, 10, size=n))
  814:         gender_int = np.random.default_rng(2).choice([0, 1], size=n)
  815:         df_int = DataFrame({"height": height, "weight": weight, "gender": gender_int})
  816:         gb = df_int.groupby("gender")
  817:         axes = gb.hist()
  818:         assert len(axes) == 2
  819:         assert len(mpl.pyplot.get_fignums()) == 2
  820: 
  821:     @pytest.mark.slow
  822:     @pytest.mark.parametrize(
  823:         "msg, plot_col, by_col, layout",
  824:         [
  825:             [
  826:                 "Layout of 1x1 must be larger than required size 2",
  827:                 "weight",
  828:                 "gender",
  829:                 (1, 1),
  830:             ],
  831:             [
  832:                 "Layout of 1x3 must be larger than required size 4",
  833:                 "height",
  834:                 "category",
  835:                 (1, 3),
  836:             ],
  837:             [
  838:                 "At least one dimension of layout must be positive",
  839:                 "height",
  840:                 "category",
  841:                 (-1, -1),
  842:             ],
  843:         ],
  844:     )
  845:     def test_grouped_hist_layout_error(self, hist_df, msg, plot_col, by_col, layout):
  846:         df = hist_df
  847:         with pytest.raises(ValueError, match=msg):
  848:             df.hist(column=plot_col, by=getattr(df, by_col), layout=layout)
  849: 
  850:     @pytest.mark.slow
  851:     def test_grouped_hist_layout_warning(self, hist_df):
  852:         df = hist_df
  853:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  854:             axes = _check_plot_works(
  855:                 df.hist, column="height", by=df.gender, layout=(2, 1)
  856:             )
  857:         _check_axes_shape(axes, axes_num=2, layout=(2, 1))
  858: 
  859:     @pytest.mark.slow
  860:     @pytest.mark.parametrize(
  861:         "layout, check_layout, figsize",
  862:         [[(4, 1), (4, 1), None], [(-1, 1), (4, 1), None], [(4, 2), (4, 2), (12, 8)]],
  863:     )
  864:     def test_grouped_hist_layout_figsize(self, hist_df, layout, check_layout, figsize):
  865:         df = hist_df
  866:         axes = df.hist(column="height", by=df.category, layout=layout, figsize=figsize)
  867:         _check_axes_shape(axes, axes_num=4, layout=check_layout, figsize=figsize)
  868: 
  869:     @pytest.mark.slow
  870:     @pytest.mark.parametrize("kwargs", [{}, {"column": "height", "layout": (2, 2)}])
  871:     def test_grouped_hist_layout_by_warning(self, hist_df, kwargs):
  872:         df = hist_df
  873:         # GH 6769
  874:         with tm.assert_produces_warning(UserWarning, check_stacklevel=False):
  875:             axes = _check_plot_works(df.hist, by="classroom", **kwargs)
  876:         _check_axes_shape(axes, axes_num=3, layout=(2, 2))
  877: 
  878:     @pytest.mark.slow
  879:     @pytest.mark.parametrize(
  880:         "kwargs, axes_num, layout",
  881:         [
  882:             [{"by": "gender", "layout": (3, 5)}, 2, (3, 5)],
  883:             [{"column": ["height", "weight", "category"]}, 3, (2, 2)],
  884:         ],
  885:     )
  886:     def test_grouped_hist_layout_axes(self, hist_df, kwargs, axes_num, layout):
  887:         df = hist_df
  888:         axes = df.hist(**kwargs)
  889:         _check_axes_shape(axes, axes_num=axes_num, layout=layout)
  890: 
  891:     def test_grouped_hist_multiple_axes(self, hist_df):
  892:         # GH 6970, GH 7069
  893:         df = hist_df
  894: 
  895:         fig, axes = mpl.pyplot.subplots(2, 3)
  896:         returned = df.hist(column=["height", "weight", "category"], ax=axes[0])
  897:         _check_axes_shape(returned, axes_num=3, layout=(1, 3))
  898:         tm.assert_numpy_array_equal(returned, axes[0])
  899:         assert returned[0].figure is fig
  900: 
  901:     def test_grouped_hist_multiple_axes_no_cols(self, hist_df):
  902:         # GH 6970, GH 7069
  903:         df = hist_df
  904: 
  905:         fig, axes = mpl.pyplot.subplots(2, 3)
  906:         returned = df.hist(by="classroom", ax=axes[1])
  907:         _check_axes_shape(returned, axes_num=3, layout=(1, 3))
  908:         tm.assert_numpy_array_equal(returned, axes[1])
  909:         assert returned[0].figure is fig
  910: 
  911:     def test_grouped_hist_multiple_axes_error(self, hist_df):
  912:         # GH 6970, GH 7069
  913:         df = hist_df
  914:         fig, axes = mpl.pyplot.subplots(2, 3)
  915:         # pass different number of axes from required
  916:         msg = "The number of passed axes must be 1, the same as the output plot"
  917:         with pytest.raises(ValueError, match=msg):
  918:             axes = df.hist(column="height", ax=axes)
  919: 
  920:     def test_axis_share_x(self, hist_df):
  921:         df = hist_df
  922:         # GH4089
  923:         ax1, ax2 = df.hist(column="height", by=df.gender, sharex=True)
  924: 
  925:         # share x
  926:         assert get_x_axis(ax1).joined(ax1, ax2)
  927:         assert get_x_axis(ax2).joined(ax1, ax2)
  928: 
  929:         # don't share y
  930:         assert not get_y_axis(ax1).joined(ax1, ax2)
  931:         assert not get_y_axis(ax2).joined(ax1, ax2)
  932: 
  933:     def test_axis_share_y(self, hist_df):
  934:         df = hist_df
  935:         ax1, ax2 = df.hist(column="height", by=df.gender, sharey=True)
  936: 
  937:         # share y
  938:         assert get_y_axis(ax1).joined(ax1, ax2)
  939:         assert get_y_axis(ax2).joined(ax1, ax2)
  940: 
  941:         # don't share x
  942:         assert not get_x_axis(ax1).joined(ax1, ax2)
  943:         assert not get_x_axis(ax2).joined(ax1, ax2)
  944: 
  945:     def test_axis_share_xy(self, hist_df):
  946:         df = hist_df
  947:         ax1, ax2 = df.hist(column="height", by=df.gender, sharex=True, sharey=True)
  948: 
  949:         # share both x and y
  950:         assert get_x_axis(ax1).joined(ax1, ax2)
  951:         assert get_x_axis(ax2).joined(ax1, ax2)
  952: 
  953:         assert get_y_axis(ax1).joined(ax1, ax2)
  954:         assert get_y_axis(ax2).joined(ax1, ax2)
  955: 
  956:     @pytest.mark.parametrize(
  957:         "histtype, expected",
  958:         [
  959:             ("bar", True),
  960:             ("barstacked", True),
  961:             ("step", False),
  962:             ("stepfilled", True),
  963:         ],
  964:     )
  965:     def test_histtype_argument(self, histtype, expected):
  966:         # GH23992 Verify functioning of histtype argument
  967:         df = DataFrame(
  968:             np.random.default_rng(2).integers(1, 10, size=(10, 2)), columns=["a", "b"]
  969:         )
  970:         ax = df.hist(by="a", histtype=histtype)
  971:         _check_patches_all_filled(ax, filled=expected)
