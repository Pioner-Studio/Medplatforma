    1: from datetime import (
    2:     date,
    3:     datetime,
    4: )
    5: import subprocess
    6: import sys
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: import pandas._config.config as cf
   12: 
   13: from pandas._libs.tslibs import to_offset
   14: 
   15: from pandas import (
   16:     Index,
   17:     Period,
   18:     PeriodIndex,
   19:     Series,
   20:     Timestamp,
   21:     arrays,
   22:     date_range,
   23: )
   24: import pandas._testing as tm
   25: 
   26: from pandas.plotting import (
   27:     deregister_matplotlib_converters,
   28:     register_matplotlib_converters,
   29: )
   30: from pandas.tseries.offsets import (
   31:     Day,
   32:     Micro,
   33:     Milli,
   34:     Second,
   35: )
   36: 
   37: try:
   38:     from pandas.plotting._matplotlib import converter
   39: except ImportError:
   40:     # try / except, rather than skip, to avoid internal refactoring
   41:     # causing an improper skip
   42:     pass
   43: 
   44: pytest.importorskip("matplotlib.pyplot")
   45: dates = pytest.importorskip("matplotlib.dates")
   46: 
   47: 
   48: @pytest.mark.single_cpu
   49: def test_registry_mpl_resets():
   50:     # Check that Matplotlib converters are properly reset (see issue #27481)
   51:     code = (
   52:         "import matplotlib.units as units; "
   53:         "import matplotlib.dates as mdates; "
   54:         "n_conv = len(units.registry); "
   55:         "import pandas as pd; "
   56:         "pd.plotting.register_matplotlib_converters(); "
   57:         "pd.plotting.deregister_matplotlib_converters(); "
   58:         "assert len(units.registry) == n_conv"
   59:     )
   60:     call = [sys.executable, "-c", code]
   61:     subprocess.check_output(call)
   62: 
   63: 
   64: def test_timtetonum_accepts_unicode():
   65:     assert converter.time2num("00:01") == converter.time2num("00:01")
   66: 
   67: 
   68: class TestRegistration:
   69:     @pytest.mark.single_cpu
   70:     def test_dont_register_by_default(self):
   71:         # Run in subprocess to ensure a clean state
   72:         code = (
   73:             "import matplotlib.units; "
   74:             "import pandas as pd; "
   75:             "units = dict(matplotlib.units.registry); "
   76:             "assert pd.Timestamp not in units"
   77:         )
   78:         call = [sys.executable, "-c", code]
   79:         assert subprocess.check_call(call) == 0
   80: 
   81:     def test_registering_no_warning(self):
   82:         plt = pytest.importorskip("matplotlib.pyplot")
   83:         s = Series(range(12), index=date_range("2017", periods=12))
   84:         _, ax = plt.subplots()
   85: 
   86:         # Set to the "warn" state, in case this isn't the first test run
   87:         register_matplotlib_converters()
   88:         ax.plot(s.index, s.values)
   89:         plt.close()
   90: 
   91:     def test_pandas_plots_register(self):
   92:         plt = pytest.importorskip("matplotlib.pyplot")
   93:         s = Series(range(12), index=date_range("2017", periods=12))
   94:         # Set to the "warn" state, in case this isn't the first test run
   95:         with tm.assert_produces_warning(None) as w:
   96:             s.plot()
   97: 
   98:         try:
   99:             assert len(w) == 0
  100:         finally:
  101:             plt.close()
  102: 
  103:     def test_matplotlib_formatters(self):
  104:         units = pytest.importorskip("matplotlib.units")
  105: 
  106:         # Can't make any assertion about the start state.
  107:         # We we check that toggling converters off removes it, and toggling it
  108:         # on restores it.
  109: 
  110:         with cf.option_context("plotting.matplotlib.register_converters", True):
  111:             with cf.option_context("plotting.matplotlib.register_converters", False):
  112:                 assert Timestamp not in units.registry
  113:             assert Timestamp in units.registry
  114: 
  115:     def test_option_no_warning(self):
  116:         pytest.importorskip("matplotlib.pyplot")
  117:         ctx = cf.option_context("plotting.matplotlib.register_converters", False)
  118:         plt = pytest.importorskip("matplotlib.pyplot")
  119:         s = Series(range(12), index=date_range("2017", periods=12))
  120:         _, ax = plt.subplots()
  121: 
  122:         # Test without registering first, no warning
  123:         with ctx:
  124:             ax.plot(s.index, s.values)
  125: 
  126:         # Now test with registering
  127:         register_matplotlib_converters()
  128:         with ctx:
  129:             ax.plot(s.index, s.values)
  130:         plt.close()
  131: 
  132:     def test_registry_resets(self):
  133:         units = pytest.importorskip("matplotlib.units")
  134:         dates = pytest.importorskip("matplotlib.dates")
  135: 
  136:         # make a copy, to reset to
  137:         original = dict(units.registry)
  138: 
  139:         try:
  140:             # get to a known state
  141:             units.registry.clear()
  142:             date_converter = dates.DateConverter()
  143:             units.registry[datetime] = date_converter
  144:             units.registry[date] = date_converter
  145: 
  146:             register_matplotlib_converters()
  147:             assert units.registry[date] is not date_converter
  148:             deregister_matplotlib_converters()
  149:             assert units.registry[date] is date_converter
  150: 
  151:         finally:
  152:             # restore original stater
  153:             units.registry.clear()
  154:             for k, v in original.items():
  155:                 units.registry[k] = v
  156: 
  157: 
  158: class TestDateTimeConverter:
  159:     @pytest.fixture
  160:     def dtc(self):
  161:         return converter.DatetimeConverter()
  162: 
  163:     def test_convert_accepts_unicode(self, dtc):
  164:         r1 = dtc.convert("2000-01-01 12:22", None, None)
  165:         r2 = dtc.convert("2000-01-01 12:22", None, None)
  166:         assert r1 == r2, "DatetimeConverter.convert should accept unicode"
  167: 
  168:     def test_conversion(self, dtc):
  169:         rs = dtc.convert(["2012-1-1"], None, None)[0]
  170:         xp = dates.date2num(datetime(2012, 1, 1))
  171:         assert rs == xp
  172: 
  173:         rs = dtc.convert("2012-1-1", None, None)
  174:         assert rs == xp
  175: 
  176:         rs = dtc.convert(date(2012, 1, 1), None, None)
  177:         assert rs == xp
  178: 
  179:         rs = dtc.convert("2012-1-1", None, None)
  180:         assert rs == xp
  181: 
  182:         rs = dtc.convert(Timestamp("2012-1-1"), None, None)
  183:         assert rs == xp
  184: 
  185:         # also testing datetime64 dtype (GH8614)
  186:         rs = dtc.convert("2012-01-01", None, None)
  187:         assert rs == xp
  188: 
  189:         rs = dtc.convert("2012-01-01 00:00:00+0000", None, None)
  190:         assert rs == xp
  191: 
  192:         rs = dtc.convert(
  193:             np.array(["2012-01-01 00:00:00+0000", "2012-01-02 00:00:00+0000"]),
  194:             None,
  195:             None,
  196:         )
  197:         assert rs[0] == xp
  198: 
  199:         # we have a tz-aware date (constructed to that when we turn to utc it
  200:         # is the same as our sample)
  201:         ts = Timestamp("2012-01-01").tz_localize("UTC").tz_convert("US/Eastern")
  202:         rs = dtc.convert(ts, None, None)
  203:         assert rs == xp
  204: 
  205:         rs = dtc.convert(ts.to_pydatetime(), None, None)
  206:         assert rs == xp
  207: 
  208:         rs = dtc.convert(Index([ts - Day(1), ts]), None, None)
  209:         assert rs[1] == xp
  210: 
  211:         rs = dtc.convert(Index([ts - Day(1), ts]).to_pydatetime(), None, None)
  212:         assert rs[1] == xp
  213: 
  214:     def test_conversion_float(self, dtc):
  215:         rtol = 0.5 * 10**-9
  216: 
  217:         rs = dtc.convert(Timestamp("2012-1-1 01:02:03", tz="UTC"), None, None)
  218:         xp = converter.mdates.date2num(Timestamp("2012-1-1 01:02:03", tz="UTC"))
  219:         tm.assert_almost_equal(rs, xp, rtol=rtol)
  220: 
  221:         rs = dtc.convert(
  222:             Timestamp("2012-1-1 09:02:03", tz="Asia/Hong_Kong"), None, None
  223:         )
  224:         tm.assert_almost_equal(rs, xp, rtol=rtol)
  225: 
  226:         rs = dtc.convert(datetime(2012, 1, 1, 1, 2, 3), None, None)
  227:         tm.assert_almost_equal(rs, xp, rtol=rtol)
  228: 
  229:     @pytest.mark.parametrize(
  230:         "values",
  231:         [
  232:             [date(1677, 1, 1), date(1677, 1, 2)],
  233:             [datetime(1677, 1, 1, 12), datetime(1677, 1, 2, 12)],
  234:         ],
  235:     )
  236:     def test_conversion_outofbounds_datetime(self, dtc, values):
  237:         # 2579
  238:         rs = dtc.convert(values, None, None)
  239:         xp = converter.mdates.date2num(values)
  240:         tm.assert_numpy_array_equal(rs, xp)
  241:         rs = dtc.convert(values[0], None, None)
  242:         xp = converter.mdates.date2num(values[0])
  243:         assert rs == xp
  244: 
  245:     @pytest.mark.parametrize(
  246:         "time,format_expected",
  247:         [
  248:             (0, "00:00"),  # time2num(datetime.time.min)
  249:             (86399.999999, "23:59:59.999999"),  # time2num(datetime.time.max)
  250:             (90000, "01:00"),
  251:             (3723, "01:02:03"),
  252:             (39723.2, "11:02:03.200"),
  253:         ],
  254:     )
  255:     def test_time_formatter(self, time, format_expected):
  256:         # issue 18478
  257:         result = converter.TimeFormatter(None)(time)
  258:         assert result == format_expected
  259: 
  260:     @pytest.mark.parametrize("freq", ("B", "ms", "s"))
  261:     def test_dateindex_conversion(self, freq, dtc):
  262:         rtol = 10**-9
  263:         dateindex = date_range("2020-01-01", periods=10, freq=freq)
  264:         rs = dtc.convert(dateindex, None, None)
  265:         xp = converter.mdates.date2num(dateindex._mpl_repr())
  266:         tm.assert_almost_equal(rs, xp, rtol=rtol)
  267: 
  268:     @pytest.mark.parametrize("offset", [Second(), Milli(), Micro(50)])
  269:     def test_resolution(self, offset, dtc):
  270:         # Matplotlib's time representation using floats cannot distinguish
  271:         # intervals smaller than ~10 microsecond in the common range of years.
  272:         ts1 = Timestamp("2012-1-1")
  273:         ts2 = ts1 + offset
  274:         val1 = dtc.convert(ts1, None, None)
  275:         val2 = dtc.convert(ts2, None, None)
  276:         if not val1 < val2:
  277:             raise AssertionError(f"{val1} is not less than {val2}.")
  278: 
  279:     def test_convert_nested(self, dtc):
  280:         inner = [Timestamp("2017-01-01"), Timestamp("2017-01-02")]
  281:         data = [inner, inner]
  282:         result = dtc.convert(data, None, None)
  283:         expected = [dtc.convert(x, None, None) for x in data]
  284:         assert (np.array(result) == expected).all()
  285: 
  286: 
  287: class TestPeriodConverter:
  288:     @pytest.fixture
  289:     def pc(self):
  290:         return converter.PeriodConverter()
  291: 
  292:     @pytest.fixture
  293:     def axis(self):
  294:         class Axis:
  295:             pass
  296: 
  297:         axis = Axis()
  298:         axis.freq = "D"
  299:         return axis
  300: 
  301:     def test_convert_accepts_unicode(self, pc, axis):
  302:         r1 = pc.convert("2012-1-1", None, axis)
  303:         r2 = pc.convert("2012-1-1", None, axis)
  304:         assert r1 == r2
  305: 
  306:     def test_conversion(self, pc, axis):
  307:         rs = pc.convert(["2012-1-1"], None, axis)[0]
  308:         xp = Period("2012-1-1").ordinal
  309:         assert rs == xp
  310: 
  311:         rs = pc.convert("2012-1-1", None, axis)
  312:         assert rs == xp
  313: 
  314:         rs = pc.convert([date(2012, 1, 1)], None, axis)[0]
  315:         assert rs == xp
  316: 
  317:         rs = pc.convert(date(2012, 1, 1), None, axis)
  318:         assert rs == xp
  319: 
  320:         rs = pc.convert([Timestamp("2012-1-1")], None, axis)[0]
  321:         assert rs == xp
  322: 
  323:         rs = pc.convert(Timestamp("2012-1-1"), None, axis)
  324:         assert rs == xp
  325: 
  326:         rs = pc.convert("2012-01-01", None, axis)
  327:         assert rs == xp
  328: 
  329:         rs = pc.convert("2012-01-01 00:00:00+0000", None, axis)
  330:         assert rs == xp
  331: 
  332:         rs = pc.convert(
  333:             np.array(
  334:                 ["2012-01-01 00:00:00", "2012-01-02 00:00:00"],
  335:                 dtype="datetime64[ns]",
  336:             ),
  337:             None,
  338:             axis,
  339:         )
  340:         assert rs[0] == xp
  341: 
  342:     def test_integer_passthrough(self, pc, axis):
  343:         # GH9012
  344:         rs = pc.convert([0, 1], None, axis)
  345:         xp = [0, 1]
  346:         assert rs == xp
  347: 
  348:     def test_convert_nested(self, pc, axis):
  349:         data = ["2012-1-1", "2012-1-2"]
  350:         r1 = pc.convert([data, data], None, axis)
  351:         r2 = [pc.convert(data, None, axis) for _ in range(2)]
  352:         assert r1 == r2
  353: 
  354: 
  355: class TestTimeDeltaConverter:
  356:     """Test timedelta converter"""
  357: 
  358:     @pytest.mark.parametrize(
  359:         "x, decimal, format_expected",
  360:         [
  361:             (0.0, 0, "00:00:00"),
  362:             (3972320000000, 1, "01:06:12.3"),
  363:             (713233432000000, 2, "8 days 06:07:13.43"),
  364:             (32423432000000, 4, "09:00:23.4320"),
  365:         ],
  366:     )
  367:     def test_format_timedelta_ticks(self, x, decimal, format_expected):
  368:         tdc = converter.TimeSeries_TimedeltaFormatter
  369:         result = tdc.format_timedelta_ticks(x, pos=None, n_decimals=decimal)
  370:         assert result == format_expected
  371: 
  372:     @pytest.mark.parametrize("view_interval", [(1, 2), (2, 1)])
  373:     def test_call_w_different_view_intervals(self, view_interval, monkeypatch):
  374:         # previously broke on reversed xlmits; see GH37454
  375:         class mock_axis:
  376:             def get_view_interval(self):
  377:                 return view_interval
  378: 
  379:         tdc = converter.TimeSeries_TimedeltaFormatter()
  380:         monkeypatch.setattr(tdc, "axis", mock_axis())
  381:         tdc(0.0, 0)
  382: 
  383: 
  384: @pytest.mark.parametrize("year_span", [11.25, 30, 80, 150, 400, 800, 1500, 2500, 3500])
  385: # The range is limited to 11.25 at the bottom by if statements in
  386: # the _quarterly_finder() function
  387: def test_quarterly_finder(year_span):
  388:     vmin = -1000
  389:     vmax = vmin + year_span * 4
  390:     span = vmax - vmin + 1
  391:     if span < 45:
  392:         pytest.skip("the quarterly finder is only invoked if the span is >= 45")
  393:     nyears = span / 4
  394:     (min_anndef, maj_anndef) = converter._get_default_annual_spacing(nyears)
  395:     result = converter._quarterly_finder(vmin, vmax, to_offset("QE"))
  396:     quarters = PeriodIndex(
  397:         arrays.PeriodArray(np.array([x[0] for x in result]), dtype="period[Q]")
  398:     )
  399:     majors = np.array([x[1] for x in result])
  400:     minors = np.array([x[2] for x in result])
  401:     major_quarters = quarters[majors]
  402:     minor_quarters = quarters[minors]
  403:     check_major_years = major_quarters.year % maj_anndef == 0
  404:     check_minor_years = minor_quarters.year % min_anndef == 0
  405:     check_major_quarters = major_quarters.quarter == 1
  406:     check_minor_quarters = minor_quarters.quarter == 1
  407:     assert np.all(check_major_years)
  408:     assert np.all(check_minor_years)
  409:     assert np.all(check_major_quarters)
  410:     assert np.all(check_minor_quarters)
