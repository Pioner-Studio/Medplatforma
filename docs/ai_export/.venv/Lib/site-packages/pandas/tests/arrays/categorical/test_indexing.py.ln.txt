    1: import math
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas import (
    7:     NA,
    8:     Categorical,
    9:     CategoricalIndex,
   10:     Index,
   11:     Interval,
   12:     IntervalIndex,
   13:     NaT,
   14:     PeriodIndex,
   15:     Series,
   16:     Timedelta,
   17:     Timestamp,
   18: )
   19: import pandas._testing as tm
   20: import pandas.core.common as com
   21: 
   22: 
   23: class TestCategoricalIndexingWithFactor:
   24:     def test_getitem(self):
   25:         factor = Categorical(["a", "b", "b", "a", "a", "c", "c", "c"], ordered=True)
   26:         assert factor[0] == "a"
   27:         assert factor[-1] == "c"
   28: 
   29:         subf = factor[[0, 1, 2]]
   30:         tm.assert_numpy_array_equal(subf._codes, np.array([0, 1, 1], dtype=np.int8))
   31: 
   32:         subf = factor[np.asarray(factor) == "c"]
   33:         tm.assert_numpy_array_equal(subf._codes, np.array([2, 2, 2], dtype=np.int8))
   34: 
   35:     def test_setitem(self):
   36:         factor = Categorical(["a", "b", "b", "a", "a", "c", "c", "c"], ordered=True)
   37:         # int/positional
   38:         c = factor.copy()
   39:         c[0] = "b"
   40:         assert c[0] == "b"
   41:         c[-1] = "a"
   42:         assert c[-1] == "a"
   43: 
   44:         # boolean
   45:         c = factor.copy()
   46:         indexer = np.zeros(len(c), dtype="bool")
   47:         indexer[0] = True
   48:         indexer[-1] = True
   49:         c[indexer] = "c"
   50:         expected = Categorical(["c", "b", "b", "a", "a", "c", "c", "c"], ordered=True)
   51: 
   52:         tm.assert_categorical_equal(c, expected)
   53: 
   54:     @pytest.mark.parametrize(
   55:         "other",
   56:         [Categorical(["b", "a"]), Categorical(["b", "a"], categories=["b", "a"])],
   57:     )
   58:     def test_setitem_same_but_unordered(self, other):
   59:         # GH-24142
   60:         target = Categorical(["a", "b"], categories=["a", "b"])
   61:         mask = np.array([True, False])
   62:         target[mask] = other[mask]
   63:         expected = Categorical(["b", "b"], categories=["a", "b"])
   64:         tm.assert_categorical_equal(target, expected)
   65: 
   66:     @pytest.mark.parametrize(
   67:         "other",
   68:         [
   69:             Categorical(["b", "a"], categories=["b", "a", "c"]),
   70:             Categorical(["b", "a"], categories=["a", "b", "c"]),
   71:             Categorical(["a", "a"], categories=["a"]),
   72:             Categorical(["b", "b"], categories=["b"]),
   73:         ],
   74:     )
   75:     def test_setitem_different_unordered_raises(self, other):
   76:         # GH-24142
   77:         target = Categorical(["a", "b"], categories=["a", "b"])
   78:         mask = np.array([True, False])
   79:         msg = "Cannot set a Categorical with another, without identical categories"
   80:         with pytest.raises(TypeError, match=msg):
   81:             target[mask] = other[mask]
   82: 
   83:     @pytest.mark.parametrize(
   84:         "other",
   85:         [
   86:             Categorical(["b", "a"]),
   87:             Categorical(["b", "a"], categories=["b", "a"], ordered=True),
   88:             Categorical(["b", "a"], categories=["a", "b", "c"], ordered=True),
   89:         ],
   90:     )
   91:     def test_setitem_same_ordered_raises(self, other):
   92:         # Gh-24142
   93:         target = Categorical(["a", "b"], categories=["a", "b"], ordered=True)
   94:         mask = np.array([True, False])
   95:         msg = "Cannot set a Categorical with another, without identical categories"
   96:         with pytest.raises(TypeError, match=msg):
   97:             target[mask] = other[mask]
   98: 
   99:     def test_setitem_tuple(self):
  100:         # GH#20439
  101:         cat = Categorical([(0, 1), (0, 2), (0, 1)])
  102: 
  103:         # This should not raise
  104:         cat[1] = cat[0]
  105:         assert cat[1] == (0, 1)
  106: 
  107:     def test_setitem_listlike(self):
  108:         # GH#9469
  109:         # properly coerce the input indexers
  110: 
  111:         cat = Categorical(
  112:             np.random.default_rng(2).integers(0, 5, size=150000).astype(np.int8)
  113:         ).add_categories([-1000])
  114:         indexer = np.array([100000]).astype(np.int64)
  115:         cat[indexer] = -1000
  116: 
  117:         # we are asserting the code result here
  118:         # which maps to the -1000 category
  119:         result = cat.codes[np.array([100000]).astype(np.int64)]
  120:         tm.assert_numpy_array_equal(result, np.array([5], dtype="int8"))
  121: 
  122: 
  123: class TestCategoricalIndexing:
  124:     def test_getitem_slice(self):
  125:         cat = Categorical(["a", "b", "c", "d", "a", "b", "c"])
  126:         sliced = cat[3]
  127:         assert sliced == "d"
  128: 
  129:         sliced = cat[3:5]
  130:         expected = Categorical(["d", "a"], categories=["a", "b", "c", "d"])
  131:         tm.assert_categorical_equal(sliced, expected)
  132: 
  133:     def test_getitem_listlike(self):
  134:         # GH 9469
  135:         # properly coerce the input indexers
  136: 
  137:         c = Categorical(
  138:             np.random.default_rng(2).integers(0, 5, size=150000).astype(np.int8)
  139:         )
  140:         result = c.codes[np.array([100000]).astype(np.int64)]
  141:         expected = c[np.array([100000]).astype(np.int64)].codes
  142:         tm.assert_numpy_array_equal(result, expected)
  143: 
  144:     def test_periodindex(self):
  145:         idx1 = PeriodIndex(
  146:             ["2014-01", "2014-01", "2014-02", "2014-02", "2014-03", "2014-03"],
  147:             freq="M",
  148:         )
  149: 
  150:         cat1 = Categorical(idx1)
  151:         str(cat1)
  152:         exp_arr = np.array([0, 0, 1, 1, 2, 2], dtype=np.int8)
  153:         exp_idx = PeriodIndex(["2014-01", "2014-02", "2014-03"], freq="M")
  154:         tm.assert_numpy_array_equal(cat1._codes, exp_arr)
  155:         tm.assert_index_equal(cat1.categories, exp_idx)
  156: 
  157:         idx2 = PeriodIndex(
  158:             ["2014-03", "2014-03", "2014-02", "2014-01", "2014-03", "2014-01"],
  159:             freq="M",
  160:         )
  161:         cat2 = Categorical(idx2, ordered=True)
  162:         str(cat2)
  163:         exp_arr = np.array([2, 2, 1, 0, 2, 0], dtype=np.int8)
  164:         exp_idx2 = PeriodIndex(["2014-01", "2014-02", "2014-03"], freq="M")
  165:         tm.assert_numpy_array_equal(cat2._codes, exp_arr)
  166:         tm.assert_index_equal(cat2.categories, exp_idx2)
  167: 
  168:         idx3 = PeriodIndex(
  169:             [
  170:                 "2013-12",
  171:                 "2013-11",
  172:                 "2013-10",
  173:                 "2013-09",
  174:                 "2013-08",
  175:                 "2013-07",
  176:                 "2013-05",
  177:             ],
  178:             freq="M",
  179:         )
  180:         cat3 = Categorical(idx3, ordered=True)
  181:         exp_arr = np.array([6, 5, 4, 3, 2, 1, 0], dtype=np.int8)
  182:         exp_idx = PeriodIndex(
  183:             [
  184:                 "2013-05",
  185:                 "2013-07",
  186:                 "2013-08",
  187:                 "2013-09",
  188:                 "2013-10",
  189:                 "2013-11",
  190:                 "2013-12",
  191:             ],
  192:             freq="M",
  193:         )
  194:         tm.assert_numpy_array_equal(cat3._codes, exp_arr)
  195:         tm.assert_index_equal(cat3.categories, exp_idx)
  196: 
  197:     @pytest.mark.parametrize(
  198:         "null_val",
  199:         [None, np.nan, NaT, NA, math.nan, "NaT", "nat", "NAT", "nan", "NaN", "NAN"],
  200:     )
  201:     def test_periodindex_on_null_types(self, null_val):
  202:         # GH 46673
  203:         result = PeriodIndex(["2022-04-06", "2022-04-07", null_val], freq="D")
  204:         expected = PeriodIndex(["2022-04-06", "2022-04-07", "NaT"], dtype="period[D]")
  205:         assert result[2] is NaT
  206:         tm.assert_index_equal(result, expected)
  207: 
  208:     @pytest.mark.parametrize("new_categories", [[1, 2, 3, 4], [1, 2]])
  209:     def test_categories_assignments_wrong_length_raises(self, new_categories):
  210:         cat = Categorical(["a", "b", "c", "a"])
  211:         msg = (
  212:             "new categories need to have the same number of items "
  213:             "as the old categories!"
  214:         )
  215:         with pytest.raises(ValueError, match=msg):
  216:             cat.rename_categories(new_categories)
  217: 
  218:     # Combinations of sorted/unique:
  219:     @pytest.mark.parametrize(
  220:         "idx_values", [[1, 2, 3, 4], [1, 3, 2, 4], [1, 3, 3, 4], [1, 2, 2, 4]]
  221:     )
  222:     # Combinations of missing/unique
  223:     @pytest.mark.parametrize("key_values", [[1, 2], [1, 5], [1, 1], [5, 5]])
  224:     @pytest.mark.parametrize("key_class", [Categorical, CategoricalIndex])
  225:     @pytest.mark.parametrize("dtype", [None, "category", "key"])
  226:     def test_get_indexer_non_unique(self, idx_values, key_values, key_class, dtype):
  227:         # GH 21448
  228:         key = key_class(key_values, categories=range(1, 5))
  229: 
  230:         if dtype == "key":
  231:             dtype = key.dtype
  232: 
  233:         # Test for flat index and CategoricalIndex with same/different cats:
  234:         idx = Index(idx_values, dtype=dtype)
  235:         expected, exp_miss = idx.get_indexer_non_unique(key_values)
  236:         result, res_miss = idx.get_indexer_non_unique(key)
  237: 
  238:         tm.assert_numpy_array_equal(expected, result)
  239:         tm.assert_numpy_array_equal(exp_miss, res_miss)
  240: 
  241:         exp_unique = idx.unique().get_indexer(key_values)
  242:         res_unique = idx.unique().get_indexer(key)
  243:         tm.assert_numpy_array_equal(res_unique, exp_unique)
  244: 
  245:     def test_where_unobserved_nan(self):
  246:         ser = Series(Categorical(["a", "b"]))
  247:         result = ser.where([True, False])
  248:         expected = Series(Categorical(["a", None], categories=["a", "b"]))
  249:         tm.assert_series_equal(result, expected)
  250: 
  251:         # all NA
  252:         ser = Series(Categorical(["a", "b"]))
  253:         result = ser.where([False, False])
  254:         expected = Series(Categorical([None, None], categories=["a", "b"]))
  255:         tm.assert_series_equal(result, expected)
  256: 
  257:     def test_where_unobserved_categories(self):
  258:         ser = Series(Categorical(["a", "b", "c"], categories=["d", "c", "b", "a"]))
  259:         result = ser.where([True, True, False], other="b")
  260:         expected = Series(Categorical(["a", "b", "b"], categories=ser.cat.categories))
  261:         tm.assert_series_equal(result, expected)
  262: 
  263:     def test_where_other_categorical(self):
  264:         ser = Series(Categorical(["a", "b", "c"], categories=["d", "c", "b", "a"]))
  265:         other = Categorical(["b", "c", "a"], categories=["a", "c", "b", "d"])
  266:         result = ser.where([True, False, True], other)
  267:         expected = Series(Categorical(["a", "c", "c"], dtype=ser.dtype))
  268:         tm.assert_series_equal(result, expected)
  269: 
  270:     def test_where_new_category_raises(self):
  271:         ser = Series(Categorical(["a", "b", "c"]))
  272:         msg = "Cannot setitem on a Categorical with a new category"
  273:         with pytest.raises(TypeError, match=msg):
  274:             ser.where([True, False, True], "d")
  275: 
  276:     def test_where_ordered_differs_rasies(self):
  277:         ser = Series(
  278:             Categorical(["a", "b", "c"], categories=["d", "c", "b", "a"], ordered=True)
  279:         )
  280:         other = Categorical(
  281:             ["b", "c", "a"], categories=["a", "c", "b", "d"], ordered=True
  282:         )
  283:         with pytest.raises(TypeError, match="without identical categories"):
  284:             ser.where([True, False, True], other)
  285: 
  286: 
  287: class TestContains:
  288:     def test_contains(self):
  289:         # GH#21508
  290:         cat = Categorical(list("aabbca"), categories=list("cab"))
  291: 
  292:         assert "b" in cat
  293:         assert "z" not in cat
  294:         assert np.nan not in cat
  295:         with pytest.raises(TypeError, match="unhashable type: 'list'"):
  296:             assert [1] in cat
  297: 
  298:         # assert codes NOT in index
  299:         assert 0 not in cat
  300:         assert 1 not in cat
  301: 
  302:         cat = Categorical(list("aabbca") + [np.nan], categories=list("cab"))
  303:         assert np.nan in cat
  304: 
  305:     @pytest.mark.parametrize(
  306:         "item, expected",
  307:         [
  308:             (Interval(0, 1), True),
  309:             (1.5, True),
  310:             (Interval(0.5, 1.5), False),
  311:             ("a", False),
  312:             (Timestamp(1), False),
  313:             (Timedelta(1), False),
  314:         ],
  315:         ids=str,
  316:     )
  317:     def test_contains_interval(self, item, expected):
  318:         # GH#23705
  319:         cat = Categorical(IntervalIndex.from_breaks(range(3)))
  320:         result = item in cat
  321:         assert result is expected
  322: 
  323:     def test_contains_list(self):
  324:         # GH#21729
  325:         cat = Categorical([1, 2, 3])
  326: 
  327:         assert "a" not in cat
  328: 
  329:         with pytest.raises(TypeError, match="unhashable type"):
  330:             ["a"] in cat
  331: 
  332:         with pytest.raises(TypeError, match="unhashable type"):
  333:             ["a", "b"] in cat
  334: 
  335: 
  336: @pytest.mark.parametrize("index", [True, False])
  337: def test_mask_with_boolean(index):
  338:     ser = Series(range(3))
  339:     idx = Categorical([True, False, True])
  340:     if index:
  341:         idx = CategoricalIndex(idx)
  342: 
  343:     assert com.is_bool_indexer(idx)
  344:     result = ser[idx]
  345:     expected = ser[idx.astype("object")]
  346:     tm.assert_series_equal(result, expected)
  347: 
  348: 
  349: @pytest.mark.parametrize("index", [True, False])
  350: def test_mask_with_boolean_na_treated_as_false(index):
  351:     # https://github.com/pandas-dev/pandas/issues/31503
  352:     ser = Series(range(3))
  353:     idx = Categorical([True, False, None])
  354:     if index:
  355:         idx = CategoricalIndex(idx)
  356: 
  357:     result = ser[idx]
  358:     expected = ser[idx.fillna(False)]
  359: 
  360:     tm.assert_series_equal(result, expected)
  361: 
  362: 
  363: @pytest.fixture
  364: def non_coercible_categorical(monkeypatch):
  365:     """
  366:     Monkeypatch Categorical.__array__ to ensure no implicit conversion.
  367: 
  368:     Raises
  369:     ------
  370:     ValueError
  371:         When Categorical.__array__ is called.
  372:     """
  373: 
  374:     # TODO(Categorical): identify other places where this may be
  375:     # useful and move to a conftest.py
  376:     def array(self, dtype=None):
  377:         raise ValueError("I cannot be converted.")
  378: 
  379:     with monkeypatch.context() as m:
  380:         m.setattr(Categorical, "__array__", array)
  381:         yield
  382: 
  383: 
  384: def test_series_at():
  385:     arr = Categorical(["a", "b", "c"])
  386:     ser = Series(arr)
  387:     result = ser.at[0]
  388:     assert result == "a"
