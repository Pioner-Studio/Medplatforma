    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     NaT,
    6:     SparseDtype,
    7:     Timestamp,
    8:     isna,
    9: )
   10: from pandas.core.arrays.sparse import SparseArray
   11: 
   12: 
   13: class TestReductions:
   14:     @pytest.mark.parametrize(
   15:         "data,pos,neg",
   16:         [
   17:             ([True, True, True], True, False),
   18:             ([1, 2, 1], 1, 0),
   19:             ([1.0, 2.0, 1.0], 1.0, 0.0),
   20:         ],
   21:     )
   22:     def test_all(self, data, pos, neg):
   23:         # GH#17570
   24:         out = SparseArray(data).all()
   25:         assert out
   26: 
   27:         out = SparseArray(data, fill_value=pos).all()
   28:         assert out
   29: 
   30:         data[1] = neg
   31:         out = SparseArray(data).all()
   32:         assert not out
   33: 
   34:         out = SparseArray(data, fill_value=pos).all()
   35:         assert not out
   36: 
   37:     @pytest.mark.parametrize(
   38:         "data,pos,neg",
   39:         [
   40:             ([True, True, True], True, False),
   41:             ([1, 2, 1], 1, 0),
   42:             ([1.0, 2.0, 1.0], 1.0, 0.0),
   43:         ],
   44:     )
   45:     def test_numpy_all(self, data, pos, neg):
   46:         # GH#17570
   47:         out = np.all(SparseArray(data))
   48:         assert out
   49: 
   50:         out = np.all(SparseArray(data, fill_value=pos))
   51:         assert out
   52: 
   53:         data[1] = neg
   54:         out = np.all(SparseArray(data))
   55:         assert not out
   56: 
   57:         out = np.all(SparseArray(data, fill_value=pos))
   58:         assert not out
   59: 
   60:         # raises with a different message on py2.
   61:         msg = "the 'out' parameter is not supported"
   62:         with pytest.raises(ValueError, match=msg):
   63:             np.all(SparseArray(data), out=np.array([]))
   64: 
   65:     @pytest.mark.parametrize(
   66:         "data,pos,neg",
   67:         [
   68:             ([False, True, False], True, False),
   69:             ([0, 2, 0], 2, 0),
   70:             ([0.0, 2.0, 0.0], 2.0, 0.0),
   71:         ],
   72:     )
   73:     def test_any(self, data, pos, neg):
   74:         # GH#17570
   75:         out = SparseArray(data).any()
   76:         assert out
   77: 
   78:         out = SparseArray(data, fill_value=pos).any()
   79:         assert out
   80: 
   81:         data[1] = neg
   82:         out = SparseArray(data).any()
   83:         assert not out
   84: 
   85:         out = SparseArray(data, fill_value=pos).any()
   86:         assert not out
   87: 
   88:     @pytest.mark.parametrize(
   89:         "data,pos,neg",
   90:         [
   91:             ([False, True, False], True, False),
   92:             ([0, 2, 0], 2, 0),
   93:             ([0.0, 2.0, 0.0], 2.0, 0.0),
   94:         ],
   95:     )
   96:     def test_numpy_any(self, data, pos, neg):
   97:         # GH#17570
   98:         out = np.any(SparseArray(data))
   99:         assert out
  100: 
  101:         out = np.any(SparseArray(data, fill_value=pos))
  102:         assert out
  103: 
  104:         data[1] = neg
  105:         out = np.any(SparseArray(data))
  106:         assert not out
  107: 
  108:         out = np.any(SparseArray(data, fill_value=pos))
  109:         assert not out
  110: 
  111:         msg = "the 'out' parameter is not supported"
  112:         with pytest.raises(ValueError, match=msg):
  113:             np.any(SparseArray(data), out=out)
  114: 
  115:     def test_sum(self):
  116:         data = np.arange(10).astype(float)
  117:         out = SparseArray(data).sum()
  118:         assert out == 45.0
  119: 
  120:         data[5] = np.nan
  121:         out = SparseArray(data, fill_value=2).sum()
  122:         assert out == 40.0
  123: 
  124:         out = SparseArray(data, fill_value=np.nan).sum()
  125:         assert out == 40.0
  126: 
  127:     @pytest.mark.parametrize(
  128:         "arr",
  129:         [np.array([0, 1, np.nan, 1]), np.array([0, 1, 1])],
  130:     )
  131:     @pytest.mark.parametrize("fill_value", [0, 1, np.nan])
  132:     @pytest.mark.parametrize("min_count, expected", [(3, 2), (4, np.nan)])
  133:     def test_sum_min_count(self, arr, fill_value, min_count, expected):
  134:         # GH#25777
  135:         sparray = SparseArray(arr, fill_value=fill_value)
  136:         result = sparray.sum(min_count=min_count)
  137:         if np.isnan(expected):
  138:             assert np.isnan(result)
  139:         else:
  140:             assert result == expected
  141: 
  142:     def test_bool_sum_min_count(self):
  143:         spar_bool = SparseArray([False, True] * 5, dtype=np.bool_, fill_value=True)
  144:         res = spar_bool.sum(min_count=1)
  145:         assert res == 5
  146:         res = spar_bool.sum(min_count=11)
  147:         assert isna(res)
  148: 
  149:     def test_numpy_sum(self):
  150:         data = np.arange(10).astype(float)
  151:         out = np.sum(SparseArray(data))
  152:         assert out == 45.0
  153: 
  154:         data[5] = np.nan
  155:         out = np.sum(SparseArray(data, fill_value=2))
  156:         assert out == 40.0
  157: 
  158:         out = np.sum(SparseArray(data, fill_value=np.nan))
  159:         assert out == 40.0
  160: 
  161:         msg = "the 'dtype' parameter is not supported"
  162:         with pytest.raises(ValueError, match=msg):
  163:             np.sum(SparseArray(data), dtype=np.int64)
  164: 
  165:         msg = "the 'out' parameter is not supported"
  166:         with pytest.raises(ValueError, match=msg):
  167:             np.sum(SparseArray(data), out=out)
  168: 
  169:     def test_mean(self):
  170:         data = np.arange(10).astype(float)
  171:         out = SparseArray(data).mean()
  172:         assert out == 4.5
  173: 
  174:         data[5] = np.nan
  175:         out = SparseArray(data).mean()
  176:         assert out == 40.0 / 9
  177: 
  178:     def test_numpy_mean(self):
  179:         data = np.arange(10).astype(float)
  180:         out = np.mean(SparseArray(data))
  181:         assert out == 4.5
  182: 
  183:         data[5] = np.nan
  184:         out = np.mean(SparseArray(data))
  185:         assert out == 40.0 / 9
  186: 
  187:         msg = "the 'dtype' parameter is not supported"
  188:         with pytest.raises(ValueError, match=msg):
  189:             np.mean(SparseArray(data), dtype=np.int64)
  190: 
  191:         msg = "the 'out' parameter is not supported"
  192:         with pytest.raises(ValueError, match=msg):
  193:             np.mean(SparseArray(data), out=out)
  194: 
  195: 
  196: class TestMinMax:
  197:     @pytest.mark.parametrize(
  198:         "raw_data,max_expected,min_expected",
  199:         [
  200:             (np.arange(5.0), [4], [0]),
  201:             (-np.arange(5.0), [0], [-4]),
  202:             (np.array([0, 1, 2, np.nan, 4]), [4], [0]),
  203:             (np.array([np.nan] * 5), [np.nan], [np.nan]),
  204:             (np.array([]), [np.nan], [np.nan]),
  205:         ],
  206:     )
  207:     def test_nan_fill_value(self, raw_data, max_expected, min_expected):
  208:         arr = SparseArray(raw_data)
  209:         max_result = arr.max()
  210:         min_result = arr.min()
  211:         assert max_result in max_expected
  212:         assert min_result in min_expected
  213: 
  214:         max_result = arr.max(skipna=False)
  215:         min_result = arr.min(skipna=False)
  216:         if np.isnan(raw_data).any():
  217:             assert np.isnan(max_result)
  218:             assert np.isnan(min_result)
  219:         else:
  220:             assert max_result in max_expected
  221:             assert min_result in min_expected
  222: 
  223:     @pytest.mark.parametrize(
  224:         "fill_value,max_expected,min_expected",
  225:         [
  226:             (100, 100, 0),
  227:             (-100, 1, -100),
  228:         ],
  229:     )
  230:     def test_fill_value(self, fill_value, max_expected, min_expected):
  231:         arr = SparseArray(
  232:             np.array([fill_value, 0, 1]), dtype=SparseDtype("int", fill_value)
  233:         )
  234:         max_result = arr.max()
  235:         assert max_result == max_expected
  236: 
  237:         min_result = arr.min()
  238:         assert min_result == min_expected
  239: 
  240:     def test_only_fill_value(self):
  241:         fv = 100
  242:         arr = SparseArray(np.array([fv, fv, fv]), dtype=SparseDtype("int", fv))
  243:         assert len(arr._valid_sp_values) == 0
  244: 
  245:         assert arr.max() == fv
  246:         assert arr.min() == fv
  247:         assert arr.max(skipna=False) == fv
  248:         assert arr.min(skipna=False) == fv
  249: 
  250:     @pytest.mark.parametrize("func", ["min", "max"])
  251:     @pytest.mark.parametrize("data", [np.array([]), np.array([np.nan, np.nan])])
  252:     @pytest.mark.parametrize(
  253:         "dtype,expected",
  254:         [
  255:             (SparseDtype(np.float64, np.nan), np.nan),
  256:             (SparseDtype(np.float64, 5.0), np.nan),
  257:             (SparseDtype("datetime64[ns]", NaT), NaT),
  258:             (SparseDtype("datetime64[ns]", Timestamp("2018-05-05")), NaT),
  259:         ],
  260:     )
  261:     def test_na_value_if_no_valid_values(self, func, data, dtype, expected):
  262:         arr = SparseArray(data, dtype=dtype)
  263:         result = getattr(arr, func)()
  264:         if expected is NaT:
  265:             # TODO: pin down whether we wrap datetime64("NaT")
  266:             assert result is NaT or np.isnat(result)
  267:         else:
  268:             assert np.isnan(result)
  269: 
  270: 
  271: class TestArgmaxArgmin:
  272:     @pytest.mark.parametrize(
  273:         "arr,argmax_expected,argmin_expected",
  274:         [
  275:             (SparseArray([1, 2, 0, 1, 2]), 1, 2),
  276:             (SparseArray([-1, -2, 0, -1, -2]), 2, 1),
  277:             (SparseArray([np.nan, 1, 0, 0, np.nan, -1]), 1, 5),
  278:             (SparseArray([np.nan, 1, 0, 0, np.nan, 2]), 5, 2),
  279:             (SparseArray([np.nan, 1, 0, 0, np.nan, 2], fill_value=-1), 5, 2),
  280:             (SparseArray([np.nan, 1, 0, 0, np.nan, 2], fill_value=0), 5, 2),
  281:             (SparseArray([np.nan, 1, 0, 0, np.nan, 2], fill_value=1), 5, 2),
  282:             (SparseArray([np.nan, 1, 0, 0, np.nan, 2], fill_value=2), 5, 2),
  283:             (SparseArray([np.nan, 1, 0, 0, np.nan, 2], fill_value=3), 5, 2),
  284:             (SparseArray([0] * 10 + [-1], fill_value=0), 0, 10),
  285:             (SparseArray([0] * 10 + [-1], fill_value=-1), 0, 10),
  286:             (SparseArray([0] * 10 + [-1], fill_value=1), 0, 10),
  287:             (SparseArray([-1] + [0] * 10, fill_value=0), 1, 0),
  288:             (SparseArray([1] + [0] * 10, fill_value=0), 0, 1),
  289:             (SparseArray([-1] + [0] * 10, fill_value=-1), 1, 0),
  290:             (SparseArray([1] + [0] * 10, fill_value=1), 0, 1),
  291:         ],
  292:     )
  293:     def test_argmax_argmin(self, arr, argmax_expected, argmin_expected):
  294:         argmax_result = arr.argmax()
  295:         argmin_result = arr.argmin()
  296:         assert argmax_result == argmax_expected
  297:         assert argmin_result == argmin_expected
  298: 
  299:     @pytest.mark.parametrize(
  300:         "arr,method",
  301:         [(SparseArray([]), "argmax"), (SparseArray([]), "argmin")],
  302:     )
  303:     def test_empty_array(self, arr, method):
  304:         msg = f"attempt to get {method} of an empty sequence"
  305:         with pytest.raises(ValueError, match=msg):
  306:             arr.argmax() if method == "argmax" else arr.argmin()
