    1: import re
    2: import warnings
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas as pd
    8: from pandas import SparseDtype
    9: 
   10: 
   11: @pytest.mark.parametrize(
   12:     "dtype, fill_value",
   13:     [
   14:         ("int", 0),
   15:         ("float", np.nan),
   16:         ("bool", False),
   17:         ("object", np.nan),
   18:         ("datetime64[ns]", np.datetime64("NaT", "ns")),
   19:         ("timedelta64[ns]", np.timedelta64("NaT", "ns")),
   20:     ],
   21: )
   22: def test_inferred_dtype(dtype, fill_value):
   23:     sparse_dtype = SparseDtype(dtype)
   24:     result = sparse_dtype.fill_value
   25:     if pd.isna(fill_value):
   26:         assert pd.isna(result) and type(result) == type(fill_value)
   27:     else:
   28:         assert result == fill_value
   29: 
   30: 
   31: def test_from_sparse_dtype():
   32:     dtype = SparseDtype("float", 0)
   33:     result = SparseDtype(dtype)
   34:     assert result.fill_value == 0
   35: 
   36: 
   37: def test_from_sparse_dtype_fill_value():
   38:     dtype = SparseDtype("int", 1)
   39:     result = SparseDtype(dtype, fill_value=2)
   40:     expected = SparseDtype("int", 2)
   41:     assert result == expected
   42: 
   43: 
   44: @pytest.mark.parametrize(
   45:     "dtype, fill_value",
   46:     [
   47:         ("int", None),
   48:         ("float", None),
   49:         ("bool", None),
   50:         ("object", None),
   51:         ("datetime64[ns]", None),
   52:         ("timedelta64[ns]", None),
   53:         ("int", np.nan),
   54:         ("float", 0),
   55:     ],
   56: )
   57: def test_equal(dtype, fill_value):
   58:     a = SparseDtype(dtype, fill_value)
   59:     b = SparseDtype(dtype, fill_value)
   60:     assert a == b
   61:     assert b == a
   62: 
   63: 
   64: def test_nans_equal():
   65:     a = SparseDtype(float, float("nan"))
   66:     b = SparseDtype(float, np.nan)
   67:     assert a == b
   68:     assert b == a
   69: 
   70: 
   71: with warnings.catch_warnings():
   72:     msg = "Allowing arbitrary scalar fill_value in SparseDtype is deprecated"
   73:     warnings.filterwarnings("ignore", msg, category=FutureWarning)
   74: 
   75:     tups = [
   76:         (SparseDtype("float64"), SparseDtype("float32")),
   77:         (SparseDtype("float64"), SparseDtype("float64", 0)),
   78:         (SparseDtype("float64"), SparseDtype("datetime64[ns]", np.nan)),
   79:         (SparseDtype(int, pd.NaT), SparseDtype(float, pd.NaT)),
   80:         (SparseDtype("float64"), np.dtype("float64")),
   81:     ]
   82: 
   83: 
   84: @pytest.mark.parametrize(
   85:     "a, b",
   86:     tups,
   87: )
   88: def test_not_equal(a, b):
   89:     assert a != b
   90: 
   91: 
   92: def test_construct_from_string_raises():
   93:     with pytest.raises(
   94:         TypeError, match="Cannot construct a 'SparseDtype' from 'not a dtype'"
   95:     ):
   96:         SparseDtype.construct_from_string("not a dtype")
   97: 
   98: 
   99: @pytest.mark.parametrize(
  100:     "dtype, expected",
  101:     [
  102:         (SparseDtype(int), True),
  103:         (SparseDtype(float), True),
  104:         (SparseDtype(bool), True),
  105:         (SparseDtype(object), False),
  106:         (SparseDtype(str), False),
  107:     ],
  108: )
  109: def test_is_numeric(dtype, expected):
  110:     assert dtype._is_numeric is expected
  111: 
  112: 
  113: def test_str_uses_object():
  114:     result = SparseDtype(str).subtype
  115:     assert result == np.dtype("object")
  116: 
  117: 
  118: @pytest.mark.parametrize(
  119:     "string, expected",
  120:     [
  121:         ("Sparse[float64]", SparseDtype(np.dtype("float64"))),
  122:         ("Sparse[float32]", SparseDtype(np.dtype("float32"))),
  123:         ("Sparse[int]", SparseDtype(np.dtype("int"))),
  124:         ("Sparse[str]", SparseDtype(np.dtype("str"))),
  125:         ("Sparse[datetime64[ns]]", SparseDtype(np.dtype("datetime64[ns]"))),
  126:         ("Sparse", SparseDtype(np.dtype("float"), np.nan)),
  127:     ],
  128: )
  129: def test_construct_from_string(string, expected):
  130:     result = SparseDtype.construct_from_string(string)
  131:     assert result == expected
  132: 
  133: 
  134: @pytest.mark.parametrize(
  135:     "a, b, expected",
  136:     [
  137:         (SparseDtype(float, 0.0), SparseDtype(np.dtype("float"), 0.0), True),
  138:         (SparseDtype(int, 0), SparseDtype(int, 0), True),
  139:         (SparseDtype(float, float("nan")), SparseDtype(float, np.nan), True),
  140:         (SparseDtype(float, 0), SparseDtype(float, np.nan), False),
  141:         (SparseDtype(int, 0.0), SparseDtype(float, 0.0), False),
  142:     ],
  143: )
  144: def test_hash_equal(a, b, expected):
  145:     result = a == b
  146:     assert result is expected
  147: 
  148:     result = hash(a) == hash(b)
  149:     assert result is expected
  150: 
  151: 
  152: @pytest.mark.parametrize(
  153:     "string, expected",
  154:     [
  155:         ("Sparse[int]", "int"),
  156:         ("Sparse[int, 0]", "int"),
  157:         ("Sparse[int64]", "int64"),
  158:         ("Sparse[int64, 0]", "int64"),
  159:         ("Sparse[datetime64[ns], 0]", "datetime64[ns]"),
  160:     ],
  161: )
  162: def test_parse_subtype(string, expected):
  163:     subtype, _ = SparseDtype._parse_subtype(string)
  164:     assert subtype == expected
  165: 
  166: 
  167: @pytest.mark.parametrize(
  168:     "string", ["Sparse[int, 1]", "Sparse[float, 0.0]", "Sparse[bool, True]"]
  169: )
  170: def test_construct_from_string_fill_value_raises(string):
  171:     with pytest.raises(TypeError, match="fill_value in the string is not"):
  172:         SparseDtype.construct_from_string(string)
  173: 
  174: 
  175: @pytest.mark.parametrize(
  176:     "original, dtype, expected",
  177:     [
  178:         (SparseDtype(int, 0), float, SparseDtype(float, 0.0)),
  179:         (SparseDtype(int, 1), float, SparseDtype(float, 1.0)),
  180:         (SparseDtype(int, 1), str, SparseDtype(object, "1")),
  181:         (SparseDtype(float, 1.5), int, SparseDtype(int, 1)),
  182:     ],
  183: )
  184: def test_update_dtype(original, dtype, expected):
  185:     result = original.update_dtype(dtype)
  186:     assert result == expected
  187: 
  188: 
  189: @pytest.mark.parametrize(
  190:     "original, dtype, expected_error_msg",
  191:     [
  192:         (
  193:             SparseDtype(float, np.nan),
  194:             int,
  195:             re.escape("Cannot convert non-finite values (NA or inf) to integer"),
  196:         ),
  197:         (
  198:             SparseDtype(str, "abc"),
  199:             int,
  200:             r"invalid literal for int\(\) with base 10: ('abc'|np\.str_\('abc'\))",
  201:         ),
  202:     ],
  203: )
  204: def test_update_dtype_raises(original, dtype, expected_error_msg):
  205:     with pytest.raises(ValueError, match=expected_error_msg):
  206:         original.update_dtype(dtype)
  207: 
  208: 
  209: def test_repr():
  210:     # GH-34352
  211:     result = str(SparseDtype("int64", fill_value=0))
  212:     expected = "Sparse[int64, 0]"
  213:     assert result == expected
  214: 
  215:     result = str(SparseDtype(object, fill_value="0"))
  216:     expected = "Sparse[object, '0']"
  217:     assert result == expected
  218: 
  219: 
  220: def test_sparse_dtype_subtype_must_be_numpy_dtype():
  221:     # GH#53160
  222:     msg = "SparseDtype subtype must be a numpy dtype"
  223:     with pytest.raises(TypeError, match=msg):
  224:         SparseDtype("category", fill_value="c")
