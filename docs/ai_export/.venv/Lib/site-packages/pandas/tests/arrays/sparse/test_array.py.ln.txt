    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas._libs.sparse import IntIndex
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     SparseDtype,
   11:     isna,
   12: )
   13: import pandas._testing as tm
   14: from pandas.core.arrays.sparse import SparseArray
   15: 
   16: 
   17: @pytest.fixture
   18: def arr_data():
   19:     """Fixture returning numpy array with valid and missing entries"""
   20:     return np.array([np.nan, np.nan, 1, 2, 3, np.nan, 4, 5, np.nan, 6])
   21: 
   22: 
   23: @pytest.fixture
   24: def arr(arr_data):
   25:     """Fixture returning SparseArray from 'arr_data'"""
   26:     return SparseArray(arr_data)
   27: 
   28: 
   29: @pytest.fixture
   30: def zarr():
   31:     """Fixture returning SparseArray with integer entries and 'fill_value=0'"""
   32:     return SparseArray([0, 0, 1, 2, 3, 0, 4, 5, 0, 6], fill_value=0)
   33: 
   34: 
   35: class TestSparseArray:
   36:     @pytest.mark.parametrize("fill_value", [0, None, np.nan])
   37:     def test_shift_fill_value(self, fill_value):
   38:         # GH #24128
   39:         sparse = SparseArray(np.array([1, 0, 0, 3, 0]), fill_value=8.0)
   40:         res = sparse.shift(1, fill_value=fill_value)
   41:         if isna(fill_value):
   42:             fill_value = res.dtype.na_value
   43:         exp = SparseArray(np.array([fill_value, 1, 0, 0, 3]), fill_value=8.0)
   44:         tm.assert_sp_array_equal(res, exp)
   45: 
   46:     def test_set_fill_value(self):
   47:         arr = SparseArray([1.0, np.nan, 2.0], fill_value=np.nan)
   48:         arr.fill_value = 2
   49:         assert arr.fill_value == 2
   50: 
   51:         arr = SparseArray([1, 0, 2], fill_value=0, dtype=np.int64)
   52:         arr.fill_value = 2
   53:         assert arr.fill_value == 2
   54: 
   55:         msg = "Allowing arbitrary scalar fill_value in SparseDtype is deprecated"
   56:         with tm.assert_produces_warning(FutureWarning, match=msg):
   57:             arr.fill_value = 3.1
   58:         assert arr.fill_value == 3.1
   59: 
   60:         arr.fill_value = np.nan
   61:         assert np.isnan(arr.fill_value)
   62: 
   63:         arr = SparseArray([True, False, True], fill_value=False, dtype=np.bool_)
   64:         arr.fill_value = True
   65:         assert arr.fill_value is True
   66: 
   67:         with tm.assert_produces_warning(FutureWarning, match=msg):
   68:             arr.fill_value = 0
   69: 
   70:         arr.fill_value = np.nan
   71:         assert np.isnan(arr.fill_value)
   72: 
   73:     @pytest.mark.parametrize("val", [[1, 2, 3], np.array([1, 2]), (1, 2, 3)])
   74:     def test_set_fill_invalid_non_scalar(self, val):
   75:         arr = SparseArray([True, False, True], fill_value=False, dtype=np.bool_)
   76:         msg = "fill_value must be a scalar"
   77: 
   78:         with pytest.raises(ValueError, match=msg):
   79:             arr.fill_value = val
   80: 
   81:     def test_copy(self, arr):
   82:         arr2 = arr.copy()
   83:         assert arr2.sp_values is not arr.sp_values
   84:         assert arr2.sp_index is arr.sp_index
   85: 
   86:     def test_values_asarray(self, arr_data, arr):
   87:         tm.assert_almost_equal(arr.to_dense(), arr_data)
   88: 
   89:     @pytest.mark.parametrize(
   90:         "data,shape,dtype",
   91:         [
   92:             ([0, 0, 0, 0, 0], (5,), None),
   93:             ([], (0,), None),
   94:             ([0], (1,), None),
   95:             (["A", "A", np.nan, "B"], (4,), object),
   96:         ],
   97:     )
   98:     def test_shape(self, data, shape, dtype):
   99:         # GH 21126
  100:         out = SparseArray(data, dtype=dtype)
  101:         assert out.shape == shape
  102: 
  103:     @pytest.mark.parametrize(
  104:         "vals",
  105:         [
  106:             [np.nan, np.nan, np.nan, np.nan, np.nan],
  107:             [1, np.nan, np.nan, 3, np.nan],
  108:             [1, np.nan, 0, 3, 0],
  109:         ],
  110:     )
  111:     @pytest.mark.parametrize("fill_value", [None, 0])
  112:     def test_dense_repr(self, vals, fill_value):
  113:         vals = np.array(vals)
  114:         arr = SparseArray(vals, fill_value=fill_value)
  115: 
  116:         res = arr.to_dense()
  117:         tm.assert_numpy_array_equal(res, vals)
  118: 
  119:     @pytest.mark.parametrize("fix", ["arr", "zarr"])
  120:     def test_pickle(self, fix, request):
  121:         obj = request.getfixturevalue(fix)
  122:         unpickled = tm.round_trip_pickle(obj)
  123:         tm.assert_sp_array_equal(unpickled, obj)
  124: 
  125:     def test_generator_warnings(self):
  126:         sp_arr = SparseArray([1, 2, 3])
  127:         with tm.assert_produces_warning(None):
  128:             for _ in sp_arr:
  129:                 pass
  130: 
  131:     def test_where_retain_fill_value(self):
  132:         # GH#45691 don't lose fill_value on _where
  133:         arr = SparseArray([np.nan, 1.0], fill_value=0)
  134: 
  135:         mask = np.array([True, False])
  136: 
  137:         res = arr._where(~mask, 1)
  138:         exp = SparseArray([1, 1.0], fill_value=0)
  139:         tm.assert_sp_array_equal(res, exp)
  140: 
  141:         ser = pd.Series(arr)
  142:         res = ser.where(~mask, 1)
  143:         tm.assert_series_equal(res, pd.Series(exp))
  144: 
  145:     def test_fillna(self):
  146:         s = SparseArray([1, np.nan, np.nan, 3, np.nan])
  147:         res = s.fillna(-1)
  148:         exp = SparseArray([1, -1, -1, 3, -1], fill_value=-1, dtype=np.float64)
  149:         tm.assert_sp_array_equal(res, exp)
  150: 
  151:         s = SparseArray([1, np.nan, np.nan, 3, np.nan], fill_value=0)
  152:         res = s.fillna(-1)
  153:         exp = SparseArray([1, -1, -1, 3, -1], fill_value=0, dtype=np.float64)
  154:         tm.assert_sp_array_equal(res, exp)
  155: 
  156:         s = SparseArray([1, np.nan, 0, 3, 0])
  157:         res = s.fillna(-1)
  158:         exp = SparseArray([1, -1, 0, 3, 0], fill_value=-1, dtype=np.float64)
  159:         tm.assert_sp_array_equal(res, exp)
  160: 
  161:         s = SparseArray([1, np.nan, 0, 3, 0], fill_value=0)
  162:         res = s.fillna(-1)
  163:         exp = SparseArray([1, -1, 0, 3, 0], fill_value=0, dtype=np.float64)
  164:         tm.assert_sp_array_equal(res, exp)
  165: 
  166:         s = SparseArray([np.nan, np.nan, np.nan, np.nan])
  167:         res = s.fillna(-1)
  168:         exp = SparseArray([-1, -1, -1, -1], fill_value=-1, dtype=np.float64)
  169:         tm.assert_sp_array_equal(res, exp)
  170: 
  171:         s = SparseArray([np.nan, np.nan, np.nan, np.nan], fill_value=0)
  172:         res = s.fillna(-1)
  173:         exp = SparseArray([-1, -1, -1, -1], fill_value=0, dtype=np.float64)
  174:         tm.assert_sp_array_equal(res, exp)
  175: 
  176:         # float dtype's fill_value is np.nan, replaced by -1
  177:         s = SparseArray([0.0, 0.0, 0.0, 0.0])
  178:         res = s.fillna(-1)
  179:         exp = SparseArray([0.0, 0.0, 0.0, 0.0], fill_value=-1)
  180:         tm.assert_sp_array_equal(res, exp)
  181: 
  182:         # int dtype shouldn't have missing. No changes.
  183:         s = SparseArray([0, 0, 0, 0])
  184:         assert s.dtype == SparseDtype(np.int64)
  185:         assert s.fill_value == 0
  186:         res = s.fillna(-1)
  187:         tm.assert_sp_array_equal(res, s)
  188: 
  189:         s = SparseArray([0, 0, 0, 0], fill_value=0)
  190:         assert s.dtype == SparseDtype(np.int64)
  191:         assert s.fill_value == 0
  192:         res = s.fillna(-1)
  193:         exp = SparseArray([0, 0, 0, 0], fill_value=0)
  194:         tm.assert_sp_array_equal(res, exp)
  195: 
  196:         # fill_value can be nan if there is no missing hole.
  197:         # only fill_value will be changed
  198:         s = SparseArray([0, 0, 0, 0], fill_value=np.nan)
  199:         assert s.dtype == SparseDtype(np.int64, fill_value=np.nan)
  200:         assert np.isnan(s.fill_value)
  201:         res = s.fillna(-1)
  202:         exp = SparseArray([0, 0, 0, 0], fill_value=-1)
  203:         tm.assert_sp_array_equal(res, exp)
  204: 
  205:     def test_fillna_overlap(self):
  206:         s = SparseArray([1, np.nan, np.nan, 3, np.nan])
  207:         # filling with existing value doesn't replace existing value with
  208:         # fill_value, i.e. existing 3 remains in sp_values
  209:         res = s.fillna(3)
  210:         exp = np.array([1, 3, 3, 3, 3], dtype=np.float64)
  211:         tm.assert_numpy_array_equal(res.to_dense(), exp)
  212: 
  213:         s = SparseArray([1, np.nan, np.nan, 3, np.nan], fill_value=0)
  214:         res = s.fillna(3)
  215:         exp = SparseArray([1, 3, 3, 3, 3], fill_value=0, dtype=np.float64)
  216:         tm.assert_sp_array_equal(res, exp)
  217: 
  218:     def test_nonzero(self):
  219:         # Tests regression #21172.
  220:         sa = SparseArray([float("nan"), float("nan"), 1, 0, 0, 2, 0, 0, 0, 3, 0, 0])
  221:         expected = np.array([2, 5, 9], dtype=np.int32)
  222:         (result,) = sa.nonzero()
  223:         tm.assert_numpy_array_equal(expected, result)
  224: 
  225:         sa = SparseArray([0, 0, 1, 0, 0, 2, 0, 0, 0, 3, 0, 0])
  226:         (result,) = sa.nonzero()
  227:         tm.assert_numpy_array_equal(expected, result)
  228: 
  229: 
  230: class TestSparseArrayAnalytics:
  231:     @pytest.mark.parametrize(
  232:         "data,expected",
  233:         [
  234:             (
  235:                 np.array([1, 2, 3, 4, 5], dtype=float),  # non-null data
  236:                 SparseArray(np.array([1.0, 3.0, 6.0, 10.0, 15.0])),
  237:             ),
  238:             (
  239:                 np.array([1, 2, np.nan, 4, 5], dtype=float),  # null data
  240:                 SparseArray(np.array([1.0, 3.0, np.nan, 7.0, 12.0])),
  241:             ),
  242:         ],
  243:     )
  244:     @pytest.mark.parametrize("numpy", [True, False])
  245:     def test_cumsum(self, data, expected, numpy):
  246:         cumsum = np.cumsum if numpy else lambda s: s.cumsum()
  247: 
  248:         out = cumsum(SparseArray(data))
  249:         tm.assert_sp_array_equal(out, expected)
  250: 
  251:         out = cumsum(SparseArray(data, fill_value=np.nan))
  252:         tm.assert_sp_array_equal(out, expected)
  253: 
  254:         out = cumsum(SparseArray(data, fill_value=2))
  255:         tm.assert_sp_array_equal(out, expected)
  256: 
  257:         if numpy:  # numpy compatibility checks.
  258:             msg = "the 'dtype' parameter is not supported"
  259:             with pytest.raises(ValueError, match=msg):
  260:                 np.cumsum(SparseArray(data), dtype=np.int64)
  261: 
  262:             msg = "the 'out' parameter is not supported"
  263:             with pytest.raises(ValueError, match=msg):
  264:                 np.cumsum(SparseArray(data), out=out)
  265:         else:
  266:             axis = 1  # SparseArray currently 1-D, so only axis = 0 is valid.
  267:             msg = re.escape(f"axis(={axis}) out of bounds")
  268:             with pytest.raises(ValueError, match=msg):
  269:                 SparseArray(data).cumsum(axis=axis)
  270: 
  271:     def test_ufunc(self):
  272:         # GH 13853 make sure ufunc is applied to fill_value
  273:         sparse = SparseArray([1, np.nan, 2, np.nan, -2])
  274:         result = SparseArray([1, np.nan, 2, np.nan, 2])
  275:         tm.assert_sp_array_equal(abs(sparse), result)
  276:         tm.assert_sp_array_equal(np.abs(sparse), result)
  277: 
  278:         sparse = SparseArray([1, -1, 2, -2], fill_value=1)
  279:         result = SparseArray([1, 2, 2], sparse_index=sparse.sp_index, fill_value=1)
  280:         tm.assert_sp_array_equal(abs(sparse), result)
  281:         tm.assert_sp_array_equal(np.abs(sparse), result)
  282: 
  283:         sparse = SparseArray([1, -1, 2, -2], fill_value=-1)
  284:         exp = SparseArray([1, 1, 2, 2], fill_value=1)
  285:         tm.assert_sp_array_equal(abs(sparse), exp)
  286:         tm.assert_sp_array_equal(np.abs(sparse), exp)
  287: 
  288:         sparse = SparseArray([1, np.nan, 2, np.nan, -2])
  289:         result = SparseArray(np.sin([1, np.nan, 2, np.nan, -2]))
  290:         tm.assert_sp_array_equal(np.sin(sparse), result)
  291: 
  292:         sparse = SparseArray([1, -1, 2, -2], fill_value=1)
  293:         result = SparseArray(np.sin([1, -1, 2, -2]), fill_value=np.sin(1))
  294:         tm.assert_sp_array_equal(np.sin(sparse), result)
  295: 
  296:         sparse = SparseArray([1, -1, 0, -2], fill_value=0)
  297:         result = SparseArray(np.sin([1, -1, 0, -2]), fill_value=np.sin(0))
  298:         tm.assert_sp_array_equal(np.sin(sparse), result)
  299: 
  300:     def test_ufunc_args(self):
  301:         # GH 13853 make sure ufunc is applied to fill_value, including its arg
  302:         sparse = SparseArray([1, np.nan, 2, np.nan, -2])
  303:         result = SparseArray([2, np.nan, 3, np.nan, -1])
  304:         tm.assert_sp_array_equal(np.add(sparse, 1), result)
  305: 
  306:         sparse = SparseArray([1, -1, 2, -2], fill_value=1)
  307:         result = SparseArray([2, 0, 3, -1], fill_value=2)
  308:         tm.assert_sp_array_equal(np.add(sparse, 1), result)
  309: 
  310:         sparse = SparseArray([1, -1, 0, -2], fill_value=0)
  311:         result = SparseArray([2, 0, 1, -1], fill_value=1)
  312:         tm.assert_sp_array_equal(np.add(sparse, 1), result)
  313: 
  314:     @pytest.mark.parametrize("fill_value", [0.0, np.nan])
  315:     def test_modf(self, fill_value):
  316:         # https://github.com/pandas-dev/pandas/issues/26946
  317:         sparse = SparseArray([fill_value] * 10 + [1.1, 2.2], fill_value=fill_value)
  318:         r1, r2 = np.modf(sparse)
  319:         e1, e2 = np.modf(np.asarray(sparse))
  320:         tm.assert_sp_array_equal(r1, SparseArray(e1, fill_value=fill_value))
  321:         tm.assert_sp_array_equal(r2, SparseArray(e2, fill_value=fill_value))
  322: 
  323:     def test_nbytes_integer(self):
  324:         arr = SparseArray([1, 0, 0, 0, 2], kind="integer")
  325:         result = arr.nbytes
  326:         # (2 * 8) + 2 * 4
  327:         assert result == 24
  328: 
  329:     def test_nbytes_block(self):
  330:         arr = SparseArray([1, 2, 0, 0, 0], kind="block")
  331:         result = arr.nbytes
  332:         # (2 * 8) + 4 + 4
  333:         # sp_values, blocs, blengths
  334:         assert result == 24
  335: 
  336:     def test_asarray_datetime64(self):
  337:         s = SparseArray(pd.to_datetime(["2012", None, None, "2013"]))
  338:         np.asarray(s)
  339: 
  340:     def test_density(self):
  341:         arr = SparseArray([0, 1])
  342:         assert arr.density == 0.5
  343: 
  344:     def test_npoints(self):
  345:         arr = SparseArray([0, 1])
  346:         assert arr.npoints == 1
  347: 
  348: 
  349: def test_setting_fill_value_fillna_still_works():
  350:     # This is why letting users update fill_value / dtype is bad
  351:     # astype has the same problem.
  352:     arr = SparseArray([1.0, np.nan, 1.0], fill_value=0.0)
  353:     arr.fill_value = np.nan
  354:     result = arr.isna()
  355:     # Can't do direct comparison, since the sp_index will be different
  356:     # So let's convert to ndarray and check there.
  357:     result = np.asarray(result)
  358: 
  359:     expected = np.array([False, True, False])
  360:     tm.assert_numpy_array_equal(result, expected)
  361: 
  362: 
  363: def test_setting_fill_value_updates():
  364:     arr = SparseArray([0.0, np.nan], fill_value=0)
  365:     arr.fill_value = np.nan
  366:     # use private constructor to get the index right
  367:     # otherwise both nans would be un-stored.
  368:     expected = SparseArray._simple_new(
  369:         sparse_array=np.array([np.nan]),
  370:         sparse_index=IntIndex(2, [1]),
  371:         dtype=SparseDtype(float, np.nan),
  372:     )
  373:     tm.assert_sp_array_equal(arr, expected)
  374: 
  375: 
  376: @pytest.mark.parametrize(
  377:     "arr,fill_value,loc",
  378:     [
  379:         ([None, 1, 2], None, 0),
  380:         ([0, None, 2], None, 1),
  381:         ([0, 1, None], None, 2),
  382:         ([0, 1, 1, None, None], None, 3),
  383:         ([1, 1, 1, 2], None, -1),
  384:         ([], None, -1),
  385:         ([None, 1, 0, 0, None, 2], None, 0),
  386:         ([None, 1, 0, 0, None, 2], 1, 1),
  387:         ([None, 1, 0, 0, None, 2], 2, 5),
  388:         ([None, 1, 0, 0, None, 2], 3, -1),
  389:         ([None, 0, 0, 1, 2, 1], 0, 1),
  390:         ([None, 0, 0, 1, 2, 1], 1, 3),
  391:     ],
  392: )
  393: def test_first_fill_value_loc(arr, fill_value, loc):
  394:     result = SparseArray(arr, fill_value=fill_value)._first_fill_value_loc()
  395:     assert result == loc
  396: 
  397: 
  398: @pytest.mark.parametrize(
  399:     "arr",
  400:     [
  401:         [1, 2, np.nan, np.nan],
  402:         [1, np.nan, 2, np.nan],
  403:         [1, 2, np.nan],
  404:         [np.nan, 1, 0, 0, np.nan, 2],
  405:         [np.nan, 0, 0, 1, 2, 1],
  406:     ],
  407: )
  408: @pytest.mark.parametrize("fill_value", [np.nan, 0, 1])
  409: def test_unique_na_fill(arr, fill_value):
  410:     a = SparseArray(arr, fill_value=fill_value).unique()
  411:     b = pd.Series(arr).unique()
  412:     assert isinstance(a, SparseArray)
  413:     a = np.asarray(a)
  414:     tm.assert_numpy_array_equal(a, b)
  415: 
  416: 
  417: def test_unique_all_sparse():
  418:     # https://github.com/pandas-dev/pandas/issues/23168
  419:     arr = SparseArray([0, 0])
  420:     result = arr.unique()
  421:     expected = SparseArray([0])
  422:     tm.assert_sp_array_equal(result, expected)
  423: 
  424: 
  425: def test_map():
  426:     arr = SparseArray([0, 1, 2])
  427:     expected = SparseArray([10, 11, 12], fill_value=10)
  428: 
  429:     # dict
  430:     result = arr.map({0: 10, 1: 11, 2: 12})
  431:     tm.assert_sp_array_equal(result, expected)
  432: 
  433:     # series
  434:     result = arr.map(pd.Series({0: 10, 1: 11, 2: 12}))
  435:     tm.assert_sp_array_equal(result, expected)
  436: 
  437:     # function
  438:     result = arr.map(pd.Series({0: 10, 1: 11, 2: 12}))
  439:     expected = SparseArray([10, 11, 12], fill_value=10)
  440:     tm.assert_sp_array_equal(result, expected)
  441: 
  442: 
  443: def test_map_missing():
  444:     arr = SparseArray([0, 1, 2])
  445:     expected = SparseArray([10, 11, None], fill_value=10)
  446: 
  447:     result = arr.map({0: 10, 1: 11})
  448:     tm.assert_sp_array_equal(result, expected)
  449: 
  450: 
  451: @pytest.mark.parametrize("fill_value", [np.nan, 1])
  452: def test_dropna(fill_value):
  453:     # GH-28287
  454:     arr = SparseArray([np.nan, 1], fill_value=fill_value)
  455:     exp = SparseArray([1.0], fill_value=fill_value)
  456:     tm.assert_sp_array_equal(arr.dropna(), exp)
  457: 
  458:     df = pd.DataFrame({"a": [0, 1], "b": arr})
  459:     expected_df = pd.DataFrame({"a": [1], "b": exp}, index=pd.Index([1]))
  460:     tm.assert_equal(df.dropna(), expected_df)
  461: 
  462: 
  463: def test_drop_duplicates_fill_value():
  464:     # GH 11726
  465:     df = pd.DataFrame(np.zeros((5, 5))).apply(lambda x: SparseArray(x, fill_value=0))
  466:     result = df.drop_duplicates()
  467:     expected = pd.DataFrame({i: SparseArray([0.0], fill_value=0) for i in range(5)})
  468:     tm.assert_frame_equal(result, expected)
  469: 
  470: 
  471: def test_zero_sparse_column():
  472:     # GH 27781
  473:     df1 = pd.DataFrame({"A": SparseArray([0, 0, 0]), "B": [1, 2, 3]})
  474:     df2 = pd.DataFrame({"A": SparseArray([0, 1, 0]), "B": [1, 2, 3]})
  475:     result = df1.loc[df1["B"] != 2]
  476:     expected = df2.loc[df2["B"] != 2]
  477:     tm.assert_frame_equal(result, expected)
  478: 
  479:     expected = pd.DataFrame({"A": SparseArray([0, 0]), "B": [1, 3]}, index=[0, 2])
  480:     tm.assert_frame_equal(result, expected)
