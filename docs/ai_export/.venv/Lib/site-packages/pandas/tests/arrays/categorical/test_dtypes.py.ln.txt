    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.core.dtypes.dtypes import CategoricalDtype
    5: 
    6: from pandas import (
    7:     Categorical,
    8:     CategoricalIndex,
    9:     Index,
   10:     IntervalIndex,
   11:     Series,
   12:     Timestamp,
   13: )
   14: import pandas._testing as tm
   15: 
   16: 
   17: class TestCategoricalDtypes:
   18:     def test_categories_match_up_to_permutation(self):
   19:         # test dtype comparisons between cats
   20: 
   21:         c1 = Categorical(list("aabca"), categories=list("abc"), ordered=False)
   22:         c2 = Categorical(list("aabca"), categories=list("cab"), ordered=False)
   23:         c3 = Categorical(list("aabca"), categories=list("cab"), ordered=True)
   24:         assert c1._categories_match_up_to_permutation(c1)
   25:         assert c2._categories_match_up_to_permutation(c2)
   26:         assert c3._categories_match_up_to_permutation(c3)
   27:         assert c1._categories_match_up_to_permutation(c2)
   28:         assert not c1._categories_match_up_to_permutation(c3)
   29:         assert not c1._categories_match_up_to_permutation(Index(list("aabca")))
   30:         assert not c1._categories_match_up_to_permutation(c1.astype(object))
   31:         assert c1._categories_match_up_to_permutation(CategoricalIndex(c1))
   32:         assert c1._categories_match_up_to_permutation(
   33:             CategoricalIndex(c1, categories=list("cab"))
   34:         )
   35:         assert not c1._categories_match_up_to_permutation(
   36:             CategoricalIndex(c1, ordered=True)
   37:         )
   38: 
   39:         # GH 16659
   40:         s1 = Series(c1)
   41:         s2 = Series(c2)
   42:         s3 = Series(c3)
   43:         assert c1._categories_match_up_to_permutation(s1)
   44:         assert c2._categories_match_up_to_permutation(s2)
   45:         assert c3._categories_match_up_to_permutation(s3)
   46:         assert c1._categories_match_up_to_permutation(s2)
   47:         assert not c1._categories_match_up_to_permutation(s3)
   48:         assert not c1._categories_match_up_to_permutation(s1.astype(object))
   49: 
   50:     def test_set_dtype_same(self):
   51:         c = Categorical(["a", "b", "c"])
   52:         result = c._set_dtype(CategoricalDtype(["a", "b", "c"]))
   53:         tm.assert_categorical_equal(result, c)
   54: 
   55:     def test_set_dtype_new_categories(self):
   56:         c = Categorical(["a", "b", "c"])
   57:         result = c._set_dtype(CategoricalDtype(list("abcd")))
   58:         tm.assert_numpy_array_equal(result.codes, c.codes)
   59:         tm.assert_index_equal(result.dtype.categories, Index(list("abcd")))
   60: 
   61:     @pytest.mark.parametrize(
   62:         "values, categories, new_categories",
   63:         [
   64:             # No NaNs, same cats, same order
   65:             (["a", "b", "a"], ["a", "b"], ["a", "b"]),
   66:             # No NaNs, same cats, different order
   67:             (["a", "b", "a"], ["a", "b"], ["b", "a"]),
   68:             # Same, unsorted
   69:             (["b", "a", "a"], ["a", "b"], ["a", "b"]),
   70:             # No NaNs, same cats, different order
   71:             (["b", "a", "a"], ["a", "b"], ["b", "a"]),
   72:             # NaNs
   73:             (["a", "b", "c"], ["a", "b"], ["a", "b"]),
   74:             (["a", "b", "c"], ["a", "b"], ["b", "a"]),
   75:             (["b", "a", "c"], ["a", "b"], ["a", "b"]),
   76:             (["b", "a", "c"], ["a", "b"], ["a", "b"]),
   77:             # Introduce NaNs
   78:             (["a", "b", "c"], ["a", "b"], ["a"]),
   79:             (["a", "b", "c"], ["a", "b"], ["b"]),
   80:             (["b", "a", "c"], ["a", "b"], ["a"]),
   81:             (["b", "a", "c"], ["a", "b"], ["a"]),
   82:             # No overlap
   83:             (["a", "b", "c"], ["a", "b"], ["d", "e"]),
   84:         ],
   85:     )
   86:     @pytest.mark.parametrize("ordered", [True, False])
   87:     def test_set_dtype_many(self, values, categories, new_categories, ordered):
   88:         c = Categorical(values, categories)
   89:         expected = Categorical(values, new_categories, ordered)
   90:         result = c._set_dtype(expected.dtype)
   91:         tm.assert_categorical_equal(result, expected)
   92: 
   93:     def test_set_dtype_no_overlap(self):
   94:         c = Categorical(["a", "b", "c"], ["d", "e"])
   95:         result = c._set_dtype(CategoricalDtype(["a", "b"]))
   96:         expected = Categorical([None, None, None], categories=["a", "b"])
   97:         tm.assert_categorical_equal(result, expected)
   98: 
   99:     def test_codes_dtypes(self):
  100:         # GH 8453
  101:         result = Categorical(["foo", "bar", "baz"])
  102:         assert result.codes.dtype == "int8"
  103: 
  104:         result = Categorical([f"foo{i:05d}" for i in range(400)])
  105:         assert result.codes.dtype == "int16"
  106: 
  107:         result = Categorical([f"foo{i:05d}" for i in range(40000)])
  108:         assert result.codes.dtype == "int32"
  109: 
  110:         # adding cats
  111:         result = Categorical(["foo", "bar", "baz"])
  112:         assert result.codes.dtype == "int8"
  113:         result = result.add_categories([f"foo{i:05d}" for i in range(400)])
  114:         assert result.codes.dtype == "int16"
  115: 
  116:         # removing cats
  117:         result = result.remove_categories([f"foo{i:05d}" for i in range(300)])
  118:         assert result.codes.dtype == "int8"
  119: 
  120:     def test_iter_python_types(self):
  121:         # GH-19909
  122:         cat = Categorical([1, 2])
  123:         assert isinstance(next(iter(cat)), int)
  124:         assert isinstance(cat.tolist()[0], int)
  125: 
  126:     def test_iter_python_types_datetime(self):
  127:         cat = Categorical([Timestamp("2017-01-01"), Timestamp("2017-01-02")])
  128:         assert isinstance(next(iter(cat)), Timestamp)
  129:         assert isinstance(cat.tolist()[0], Timestamp)
  130: 
  131:     def test_interval_index_category(self):
  132:         # GH 38316
  133:         index = IntervalIndex.from_breaks(np.arange(3, dtype="uint64"))
  134: 
  135:         result = CategoricalIndex(index).dtype.categories
  136:         expected = IntervalIndex.from_arrays(
  137:             [0, 1], [1, 2], dtype="interval[uint64, right]"
  138:         )
  139:         tm.assert_index_equal(result, expected)
