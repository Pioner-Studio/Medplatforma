    1: import re
    2: import sys
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas.compat import PYPY
    8: 
    9: from pandas import (
   10:     Categorical,
   11:     CategoricalDtype,
   12:     DataFrame,
   13:     Index,
   14:     NaT,
   15:     Series,
   16:     date_range,
   17: )
   18: import pandas._testing as tm
   19: from pandas.api.types import is_scalar
   20: 
   21: 
   22: class TestCategoricalAnalytics:
   23:     @pytest.mark.parametrize("aggregation", ["min", "max"])
   24:     def test_min_max_not_ordered_raises(self, aggregation):
   25:         # unordered cats have no min/max
   26:         cat = Categorical(["a", "b", "c", "d"], ordered=False)
   27:         msg = f"Categorical is not ordered for operation {aggregation}"
   28:         agg_func = getattr(cat, aggregation)
   29: 
   30:         with pytest.raises(TypeError, match=msg):
   31:             agg_func()
   32: 
   33:         ufunc = np.minimum if aggregation == "min" else np.maximum
   34:         with pytest.raises(TypeError, match=msg):
   35:             ufunc.reduce(cat)
   36: 
   37:     def test_min_max_ordered(self, index_or_series_or_array):
   38:         cat = Categorical(["a", "b", "c", "d"], ordered=True)
   39:         obj = index_or_series_or_array(cat)
   40:         _min = obj.min()
   41:         _max = obj.max()
   42:         assert _min == "a"
   43:         assert _max == "d"
   44: 
   45:         assert np.minimum.reduce(obj) == "a"
   46:         assert np.maximum.reduce(obj) == "d"
   47:         # TODO: raises if we pass axis=0  (on Index and Categorical, not Series)
   48: 
   49:         cat = Categorical(
   50:             ["a", "b", "c", "d"], categories=["d", "c", "b", "a"], ordered=True
   51:         )
   52:         obj = index_or_series_or_array(cat)
   53:         _min = obj.min()
   54:         _max = obj.max()
   55:         assert _min == "d"
   56:         assert _max == "a"
   57:         assert np.minimum.reduce(obj) == "d"
   58:         assert np.maximum.reduce(obj) == "a"
   59: 
   60:     def test_min_max_reduce(self):
   61:         # GH52788
   62:         cat = Categorical(["a", "b", "c", "d"], ordered=True)
   63:         df = DataFrame(cat)
   64: 
   65:         result_max = df.agg("max")
   66:         expected_max = Series(Categorical(["d"], dtype=cat.dtype))
   67:         tm.assert_series_equal(result_max, expected_max)
   68: 
   69:         result_min = df.agg("min")
   70:         expected_min = Series(Categorical(["a"], dtype=cat.dtype))
   71:         tm.assert_series_equal(result_min, expected_min)
   72: 
   73:     @pytest.mark.parametrize(
   74:         "categories,expected",
   75:         [
   76:             (list("ABC"), np.nan),
   77:             ([1, 2, 3], np.nan),
   78:             pytest.param(
   79:                 Series(date_range("2020-01-01", periods=3), dtype="category"),
   80:                 NaT,
   81:                 marks=pytest.mark.xfail(
   82:                     reason="https://github.com/pandas-dev/pandas/issues/29962"
   83:                 ),
   84:             ),
   85:         ],
   86:     )
   87:     @pytest.mark.parametrize("aggregation", ["min", "max"])
   88:     def test_min_max_ordered_empty(self, categories, expected, aggregation):
   89:         # GH 30227
   90:         cat = Categorical([], categories=categories, ordered=True)
   91: 
   92:         agg_func = getattr(cat, aggregation)
   93:         result = agg_func()
   94:         assert result is expected
   95: 
   96:     @pytest.mark.parametrize(
   97:         "values, categories",
   98:         [(["a", "b", "c", np.nan], list("cba")), ([1, 2, 3, np.nan], [3, 2, 1])],
   99:     )
  100:     @pytest.mark.parametrize("skipna", [True, False])
  101:     @pytest.mark.parametrize("function", ["min", "max"])
  102:     def test_min_max_with_nan(self, values, categories, function, skipna):
  103:         # GH 25303
  104:         cat = Categorical(values, categories=categories, ordered=True)
  105:         result = getattr(cat, function)(skipna=skipna)
  106: 
  107:         if skipna is False:
  108:             assert result is np.nan
  109:         else:
  110:             expected = categories[0] if function == "min" else categories[2]
  111:             assert result == expected
  112: 
  113:     @pytest.mark.parametrize("function", ["min", "max"])
  114:     @pytest.mark.parametrize("skipna", [True, False])
  115:     def test_min_max_only_nan(self, function, skipna):
  116:         # https://github.com/pandas-dev/pandas/issues/33450
  117:         cat = Categorical([np.nan], categories=[1, 2], ordered=True)
  118:         result = getattr(cat, function)(skipna=skipna)
  119:         assert result is np.nan
  120: 
  121:     @pytest.mark.parametrize("method", ["min", "max"])
  122:     def test_numeric_only_min_max_raises(self, method):
  123:         # GH 25303
  124:         cat = Categorical(
  125:             [np.nan, 1, 2, np.nan], categories=[5, 4, 3, 2, 1], ordered=True
  126:         )
  127:         with pytest.raises(TypeError, match=".* got an unexpected keyword"):
  128:             getattr(cat, method)(numeric_only=True)
  129: 
  130:     @pytest.mark.parametrize("method", ["min", "max"])
  131:     def test_numpy_min_max_raises(self, method):
  132:         cat = Categorical(["a", "b", "c", "b"], ordered=False)
  133:         msg = (
  134:             f"Categorical is not ordered for operation {method}\n"
  135:             "you can use .as_ordered() to change the Categorical to an ordered one"
  136:         )
  137:         method = getattr(np, method)
  138:         with pytest.raises(TypeError, match=re.escape(msg)):
  139:             method(cat)
  140: 
  141:     @pytest.mark.parametrize("kwarg", ["axis", "out", "keepdims"])
  142:     @pytest.mark.parametrize("method", ["min", "max"])
  143:     def test_numpy_min_max_unsupported_kwargs_raises(self, method, kwarg):
  144:         cat = Categorical(["a", "b", "c", "b"], ordered=True)
  145:         msg = (
  146:             f"the '{kwarg}' parameter is not supported in the pandas implementation "
  147:             f"of {method}"
  148:         )
  149:         if kwarg == "axis":
  150:             msg = r"`axis` must be fewer than the number of dimensions \(1\)"
  151:         kwargs = {kwarg: 42}
  152:         method = getattr(np, method)
  153:         with pytest.raises(ValueError, match=msg):
  154:             method(cat, **kwargs)
  155: 
  156:     @pytest.mark.parametrize("method, expected", [("min", "a"), ("max", "c")])
  157:     def test_numpy_min_max_axis_equals_none(self, method, expected):
  158:         cat = Categorical(["a", "b", "c", "b"], ordered=True)
  159:         method = getattr(np, method)
  160:         result = method(cat, axis=None)
  161:         assert result == expected
  162: 
  163:     @pytest.mark.parametrize(
  164:         "values,categories,exp_mode",
  165:         [
  166:             ([1, 1, 2, 4, 5, 5, 5], [5, 4, 3, 2, 1], [5]),
  167:             ([1, 1, 1, 4, 5, 5, 5], [5, 4, 3, 2, 1], [5, 1]),
  168:             ([1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [5, 4, 3, 2, 1]),
  169:             ([np.nan, np.nan, np.nan, 4, 5], [5, 4, 3, 2, 1], [5, 4]),
  170:             ([np.nan, np.nan, np.nan, 4, 5, 4], [5, 4, 3, 2, 1], [4]),
  171:             ([np.nan, np.nan, 4, 5, 4], [5, 4, 3, 2, 1], [4]),
  172:         ],
  173:     )
  174:     def test_mode(self, values, categories, exp_mode):
  175:         cat = Categorical(values, categories=categories, ordered=True)
  176:         res = Series(cat).mode()._values
  177:         exp = Categorical(exp_mode, categories=categories, ordered=True)
  178:         tm.assert_categorical_equal(res, exp)
  179: 
  180:     def test_searchsorted(self, ordered):
  181:         # https://github.com/pandas-dev/pandas/issues/8420
  182:         # https://github.com/pandas-dev/pandas/issues/14522
  183: 
  184:         cat = Categorical(
  185:             ["cheese", "milk", "apple", "bread", "bread"],
  186:             categories=["cheese", "milk", "apple", "bread"],
  187:             ordered=ordered,
  188:         )
  189:         ser = Series(cat)
  190: 
  191:         # Searching for single item argument, side='left' (default)
  192:         res_cat = cat.searchsorted("apple")
  193:         assert res_cat == 2
  194:         assert is_scalar(res_cat)
  195: 
  196:         res_ser = ser.searchsorted("apple")
  197:         assert res_ser == 2
  198:         assert is_scalar(res_ser)
  199: 
  200:         # Searching for single item array, side='left' (default)
  201:         res_cat = cat.searchsorted(["bread"])
  202:         res_ser = ser.searchsorted(["bread"])
  203:         exp = np.array([3], dtype=np.intp)
  204:         tm.assert_numpy_array_equal(res_cat, exp)
  205:         tm.assert_numpy_array_equal(res_ser, exp)
  206: 
  207:         # Searching for several items array, side='right'
  208:         res_cat = cat.searchsorted(["apple", "bread"], side="right")
  209:         res_ser = ser.searchsorted(["apple", "bread"], side="right")
  210:         exp = np.array([3, 5], dtype=np.intp)
  211:         tm.assert_numpy_array_equal(res_cat, exp)
  212:         tm.assert_numpy_array_equal(res_ser, exp)
  213: 
  214:         # Searching for a single value that is not from the Categorical
  215:         with pytest.raises(TypeError, match="cucumber"):
  216:             cat.searchsorted("cucumber")
  217:         with pytest.raises(TypeError, match="cucumber"):
  218:             ser.searchsorted("cucumber")
  219: 
  220:         # Searching for multiple values one of each is not from the Categorical
  221:         msg = (
  222:             "Cannot setitem on a Categorical with a new category, "
  223:             "set the categories first"
  224:         )
  225:         with pytest.raises(TypeError, match=msg):
  226:             cat.searchsorted(["bread", "cucumber"])
  227:         with pytest.raises(TypeError, match=msg):
  228:             ser.searchsorted(["bread", "cucumber"])
  229: 
  230:     def test_unique(self, ordered):
  231:         # GH38140
  232:         dtype = CategoricalDtype(["a", "b", "c"], ordered=ordered)
  233: 
  234:         # categories are reordered based on value when ordered=False
  235:         cat = Categorical(["a", "b", "c"], dtype=dtype)
  236:         res = cat.unique()
  237:         tm.assert_categorical_equal(res, cat)
  238: 
  239:         cat = Categorical(["a", "b", "a", "a"], dtype=dtype)
  240:         res = cat.unique()
  241:         tm.assert_categorical_equal(res, Categorical(["a", "b"], dtype=dtype))
  242: 
  243:         cat = Categorical(["c", "a", "b", "a", "a"], dtype=dtype)
  244:         res = cat.unique()
  245:         exp_cat = Categorical(["c", "a", "b"], dtype=dtype)
  246:         tm.assert_categorical_equal(res, exp_cat)
  247: 
  248:         # nan must be removed
  249:         cat = Categorical(["b", np.nan, "b", np.nan, "a"], dtype=dtype)
  250:         res = cat.unique()
  251:         exp_cat = Categorical(["b", np.nan, "a"], dtype=dtype)
  252:         tm.assert_categorical_equal(res, exp_cat)
  253: 
  254:     def test_unique_index_series(self, ordered):
  255:         # GH38140
  256:         dtype = CategoricalDtype([3, 2, 1], ordered=ordered)
  257: 
  258:         c = Categorical([3, 1, 2, 2, 1], dtype=dtype)
  259:         # Categorical.unique sorts categories by appearance order
  260:         # if ordered=False
  261:         exp = Categorical([3, 1, 2], dtype=dtype)
  262:         tm.assert_categorical_equal(c.unique(), exp)
  263: 
  264:         tm.assert_index_equal(Index(c).unique(), Index(exp))
  265:         tm.assert_categorical_equal(Series(c).unique(), exp)
  266: 
  267:         c = Categorical([1, 1, 2, 2], dtype=dtype)
  268:         exp = Categorical([1, 2], dtype=dtype)
  269:         tm.assert_categorical_equal(c.unique(), exp)
  270:         tm.assert_index_equal(Index(c).unique(), Index(exp))
  271:         tm.assert_categorical_equal(Series(c).unique(), exp)
  272: 
  273:     def test_shift(self):
  274:         # GH 9416
  275:         cat = Categorical(["a", "b", "c", "d", "a"])
  276: 
  277:         # shift forward
  278:         sp1 = cat.shift(1)
  279:         xp1 = Categorical([np.nan, "a", "b", "c", "d"])
  280:         tm.assert_categorical_equal(sp1, xp1)
  281:         tm.assert_categorical_equal(cat[:-1], sp1[1:])
  282: 
  283:         # shift back
  284:         sn2 = cat.shift(-2)
  285:         xp2 = Categorical(
  286:             ["c", "d", "a", np.nan, np.nan], categories=["a", "b", "c", "d"]
  287:         )
  288:         tm.assert_categorical_equal(sn2, xp2)
  289:         tm.assert_categorical_equal(cat[2:], sn2[:-2])
  290: 
  291:         # shift by zero
  292:         tm.assert_categorical_equal(cat, cat.shift(0))
  293: 
  294:     def test_nbytes(self):
  295:         cat = Categorical([1, 2, 3])
  296:         exp = 3 + 3 * 8  # 3 int8s for values + 3 int64s for categories
  297:         assert cat.nbytes == exp
  298: 
  299:     def test_memory_usage(self):
  300:         cat = Categorical([1, 2, 3])
  301: 
  302:         # .categories is an index, so we include the hashtable
  303:         assert 0 < cat.nbytes <= cat.memory_usage()
  304:         assert 0 < cat.nbytes <= cat.memory_usage(deep=True)
  305: 
  306:         cat = Categorical(["foo", "foo", "bar"])
  307:         assert cat.memory_usage(deep=True) > cat.nbytes
  308: 
  309:         if not PYPY:
  310:             # sys.getsizeof will call the .memory_usage with
  311:             # deep=True, and add on some GC overhead
  312:             diff = cat.memory_usage(deep=True) - sys.getsizeof(cat)
  313:             assert abs(diff) < 100
  314: 
  315:     def test_map(self):
  316:         c = Categorical(list("ABABC"), categories=list("CBA"), ordered=True)
  317:         result = c.map(lambda x: x.lower(), na_action=None)
  318:         exp = Categorical(list("ababc"), categories=list("cba"), ordered=True)
  319:         tm.assert_categorical_equal(result, exp)
  320: 
  321:         c = Categorical(list("ABABC"), categories=list("ABC"), ordered=False)
  322:         result = c.map(lambda x: x.lower(), na_action=None)
  323:         exp = Categorical(list("ababc"), categories=list("abc"), ordered=False)
  324:         tm.assert_categorical_equal(result, exp)
  325: 
  326:         result = c.map(lambda x: 1, na_action=None)
  327:         # GH 12766: Return an index not an array
  328:         tm.assert_index_equal(result, Index(np.array([1] * 5, dtype=np.int64)))
  329: 
  330:     @pytest.mark.parametrize("value", [1, "True", [1, 2, 3], 5.0])
  331:     def test_validate_inplace_raises(self, value):
  332:         cat = Categorical(["A", "B", "B", "C", "A"])
  333:         msg = (
  334:             'For argument "inplace" expected type bool, '
  335:             f"received type {type(value).__name__}"
  336:         )
  337: 
  338:         with pytest.raises(ValueError, match=msg):
  339:             cat.sort_values(inplace=value)
  340: 
  341:     def test_quantile_empty(self):
  342:         # make sure we have correct itemsize on resulting codes
  343:         cat = Categorical(["A", "B"])
  344:         idx = Index([0.0, 0.5])
  345:         result = cat[:0]._quantile(idx, interpolation="linear")
  346:         assert result._codes.dtype == np.int8
  347: 
  348:         expected = cat.take([-1, -1], allow_fill=True)
  349:         tm.assert_extension_array_equal(result, expected)
