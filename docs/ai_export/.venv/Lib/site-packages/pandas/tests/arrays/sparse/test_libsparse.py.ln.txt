    1: import operator
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas._libs.sparse as splib
    7: import pandas.util._test_decorators as td
    8: 
    9: from pandas import Series
   10: import pandas._testing as tm
   11: from pandas.core.arrays.sparse import (
   12:     BlockIndex,
   13:     IntIndex,
   14:     make_sparse_index,
   15: )
   16: 
   17: 
   18: @pytest.fixture
   19: def test_length():
   20:     return 20
   21: 
   22: 
   23: @pytest.fixture(
   24:     params=[
   25:         [
   26:             [0, 7, 15],
   27:             [3, 5, 5],
   28:             [2, 9, 14],
   29:             [2, 3, 5],
   30:             [2, 9, 15],
   31:             [1, 3, 4],
   32:         ],
   33:         [
   34:             [0, 5],
   35:             [4, 4],
   36:             [1],
   37:             [4],
   38:             [1],
   39:             [3],
   40:         ],
   41:         [
   42:             [0],
   43:             [10],
   44:             [0, 5],
   45:             [3, 7],
   46:             [0, 5],
   47:             [3, 5],
   48:         ],
   49:         [
   50:             [10],
   51:             [5],
   52:             [0, 12],
   53:             [5, 3],
   54:             [12],
   55:             [3],
   56:         ],
   57:         [
   58:             [0, 10],
   59:             [4, 6],
   60:             [5, 17],
   61:             [4, 2],
   62:             [],
   63:             [],
   64:         ],
   65:         [
   66:             [0],
   67:             [5],
   68:             [],
   69:             [],
   70:             [],
   71:             [],
   72:         ],
   73:     ],
   74:     ids=[
   75:         "plain_case",
   76:         "delete_blocks",
   77:         "split_blocks",
   78:         "skip_block",
   79:         "no_intersect",
   80:         "one_empty",
   81:     ],
   82: )
   83: def cases(request):
   84:     return request.param
   85: 
   86: 
   87: class TestSparseIndexUnion:
   88:     @pytest.mark.parametrize(
   89:         "xloc, xlen, yloc, ylen, eloc, elen",
   90:         [
   91:             [[0], [5], [5], [4], [0], [9]],
   92:             [[0, 10], [5, 5], [2, 17], [5, 2], [0, 10, 17], [7, 5, 2]],
   93:             [[1], [5], [3], [5], [1], [7]],
   94:             [[2, 10], [4, 4], [4], [8], [2], [12]],
   95:             [[0, 5], [3, 5], [0], [7], [0], [10]],
   96:             [[2, 10], [4, 4], [4, 13], [8, 4], [2], [15]],
   97:             [[2], [15], [4, 9, 14], [3, 2, 2], [2], [15]],
   98:             [[0, 10], [3, 3], [5, 15], [2, 2], [0, 5, 10, 15], [3, 2, 3, 2]],
   99:         ],
  100:     )
  101:     def test_index_make_union(self, xloc, xlen, yloc, ylen, eloc, elen, test_length):
  102:         # Case 1
  103:         # x: ----
  104:         # y:     ----
  105:         # r: --------
  106:         # Case 2
  107:         # x: -----     -----
  108:         # y:   -----          --
  109:         # Case 3
  110:         # x: ------
  111:         # y:    -------
  112:         # r: ----------
  113:         # Case 4
  114:         # x: ------  -----
  115:         # y:    -------
  116:         # r: -------------
  117:         # Case 5
  118:         # x: ---  -----
  119:         # y: -------
  120:         # r: -------------
  121:         # Case 6
  122:         # x: ------  -----
  123:         # y:    -------  ---
  124:         # r: -------------
  125:         # Case 7
  126:         # x: ----------------------
  127:         # y:   ----  ----   ---
  128:         # r: ----------------------
  129:         # Case 8
  130:         # x: ----       ---
  131:         # y:       ---       ---
  132:         xindex = BlockIndex(test_length, xloc, xlen)
  133:         yindex = BlockIndex(test_length, yloc, ylen)
  134:         bresult = xindex.make_union(yindex)
  135:         assert isinstance(bresult, BlockIndex)
  136:         tm.assert_numpy_array_equal(bresult.blocs, np.array(eloc, dtype=np.int32))
  137:         tm.assert_numpy_array_equal(bresult.blengths, np.array(elen, dtype=np.int32))
  138: 
  139:         ixindex = xindex.to_int_index()
  140:         iyindex = yindex.to_int_index()
  141:         iresult = ixindex.make_union(iyindex)
  142:         assert isinstance(iresult, IntIndex)
  143:         tm.assert_numpy_array_equal(iresult.indices, bresult.to_int_index().indices)
  144: 
  145:     def test_int_index_make_union(self):
  146:         a = IntIndex(5, np.array([0, 3, 4], dtype=np.int32))
  147:         b = IntIndex(5, np.array([0, 2], dtype=np.int32))
  148:         res = a.make_union(b)
  149:         exp = IntIndex(5, np.array([0, 2, 3, 4], np.int32))
  150:         assert res.equals(exp)
  151: 
  152:         a = IntIndex(5, np.array([], dtype=np.int32))
  153:         b = IntIndex(5, np.array([0, 2], dtype=np.int32))
  154:         res = a.make_union(b)
  155:         exp = IntIndex(5, np.array([0, 2], np.int32))
  156:         assert res.equals(exp)
  157: 
  158:         a = IntIndex(5, np.array([], dtype=np.int32))
  159:         b = IntIndex(5, np.array([], dtype=np.int32))
  160:         res = a.make_union(b)
  161:         exp = IntIndex(5, np.array([], np.int32))
  162:         assert res.equals(exp)
  163: 
  164:         a = IntIndex(5, np.array([0, 1, 2, 3, 4], dtype=np.int32))
  165:         b = IntIndex(5, np.array([0, 1, 2, 3, 4], dtype=np.int32))
  166:         res = a.make_union(b)
  167:         exp = IntIndex(5, np.array([0, 1, 2, 3, 4], np.int32))
  168:         assert res.equals(exp)
  169: 
  170:         a = IntIndex(5, np.array([0, 1], dtype=np.int32))
  171:         b = IntIndex(4, np.array([0, 1], dtype=np.int32))
  172: 
  173:         msg = "Indices must reference same underlying length"
  174:         with pytest.raises(ValueError, match=msg):
  175:             a.make_union(b)
  176: 
  177: 
  178: class TestSparseIndexIntersect:
  179:     @td.skip_if_windows
  180:     def test_intersect(self, cases, test_length):
  181:         xloc, xlen, yloc, ylen, eloc, elen = cases
  182:         xindex = BlockIndex(test_length, xloc, xlen)
  183:         yindex = BlockIndex(test_length, yloc, ylen)
  184:         expected = BlockIndex(test_length, eloc, elen)
  185:         longer_index = BlockIndex(test_length + 1, yloc, ylen)
  186: 
  187:         result = xindex.intersect(yindex)
  188:         assert result.equals(expected)
  189:         result = xindex.to_int_index().intersect(yindex.to_int_index())
  190:         assert result.equals(expected.to_int_index())
  191: 
  192:         msg = "Indices must reference same underlying length"
  193:         with pytest.raises(Exception, match=msg):
  194:             xindex.intersect(longer_index)
  195:         with pytest.raises(Exception, match=msg):
  196:             xindex.to_int_index().intersect(longer_index.to_int_index())
  197: 
  198:     def test_intersect_empty(self):
  199:         xindex = IntIndex(4, np.array([], dtype=np.int32))
  200:         yindex = IntIndex(4, np.array([2, 3], dtype=np.int32))
  201:         assert xindex.intersect(yindex).equals(xindex)
  202:         assert yindex.intersect(xindex).equals(xindex)
  203: 
  204:         xindex = xindex.to_block_index()
  205:         yindex = yindex.to_block_index()
  206:         assert xindex.intersect(yindex).equals(xindex)
  207:         assert yindex.intersect(xindex).equals(xindex)
  208: 
  209:     @pytest.mark.parametrize(
  210:         "case",
  211:         [
  212:             # Argument 2 to "IntIndex" has incompatible type "ndarray[Any,
  213:             # dtype[signedinteger[_32Bit]]]"; expected "Sequence[int]"
  214:             IntIndex(5, np.array([1, 2], dtype=np.int32)),  # type: ignore[arg-type]
  215:             IntIndex(5, np.array([0, 2, 4], dtype=np.int32)),  # type: ignore[arg-type]
  216:             IntIndex(0, np.array([], dtype=np.int32)),  # type: ignore[arg-type]
  217:             IntIndex(5, np.array([], dtype=np.int32)),  # type: ignore[arg-type]
  218:         ],
  219:     )
  220:     def test_intersect_identical(self, case):
  221:         assert case.intersect(case).equals(case)
  222:         case = case.to_block_index()
  223:         assert case.intersect(case).equals(case)
  224: 
  225: 
  226: class TestSparseIndexCommon:
  227:     def test_int_internal(self):
  228:         idx = make_sparse_index(4, np.array([2, 3], dtype=np.int32), kind="integer")
  229:         assert isinstance(idx, IntIndex)
  230:         assert idx.npoints == 2
  231:         tm.assert_numpy_array_equal(idx.indices, np.array([2, 3], dtype=np.int32))
  232: 
  233:         idx = make_sparse_index(4, np.array([], dtype=np.int32), kind="integer")
  234:         assert isinstance(idx, IntIndex)
  235:         assert idx.npoints == 0
  236:         tm.assert_numpy_array_equal(idx.indices, np.array([], dtype=np.int32))
  237: 
  238:         idx = make_sparse_index(
  239:             4, np.array([0, 1, 2, 3], dtype=np.int32), kind="integer"
  240:         )
  241:         assert isinstance(idx, IntIndex)
  242:         assert idx.npoints == 4
  243:         tm.assert_numpy_array_equal(idx.indices, np.array([0, 1, 2, 3], dtype=np.int32))
  244: 
  245:     def test_block_internal(self):
  246:         idx = make_sparse_index(4, np.array([2, 3], dtype=np.int32), kind="block")
  247:         assert isinstance(idx, BlockIndex)
  248:         assert idx.npoints == 2
  249:         tm.assert_numpy_array_equal(idx.blocs, np.array([2], dtype=np.int32))
  250:         tm.assert_numpy_array_equal(idx.blengths, np.array([2], dtype=np.int32))
  251: 
  252:         idx = make_sparse_index(4, np.array([], dtype=np.int32), kind="block")
  253:         assert isinstance(idx, BlockIndex)
  254:         assert idx.npoints == 0
  255:         tm.assert_numpy_array_equal(idx.blocs, np.array([], dtype=np.int32))
  256:         tm.assert_numpy_array_equal(idx.blengths, np.array([], dtype=np.int32))
  257: 
  258:         idx = make_sparse_index(4, np.array([0, 1, 2, 3], dtype=np.int32), kind="block")
  259:         assert isinstance(idx, BlockIndex)
  260:         assert idx.npoints == 4
  261:         tm.assert_numpy_array_equal(idx.blocs, np.array([0], dtype=np.int32))
  262:         tm.assert_numpy_array_equal(idx.blengths, np.array([4], dtype=np.int32))
  263: 
  264:         idx = make_sparse_index(4, np.array([0, 2, 3], dtype=np.int32), kind="block")
  265:         assert isinstance(idx, BlockIndex)
  266:         assert idx.npoints == 3
  267:         tm.assert_numpy_array_equal(idx.blocs, np.array([0, 2], dtype=np.int32))
  268:         tm.assert_numpy_array_equal(idx.blengths, np.array([1, 2], dtype=np.int32))
  269: 
  270:     @pytest.mark.parametrize("kind", ["integer", "block"])
  271:     def test_lookup(self, kind):
  272:         idx = make_sparse_index(4, np.array([2, 3], dtype=np.int32), kind=kind)
  273:         assert idx.lookup(-1) == -1
  274:         assert idx.lookup(0) == -1
  275:         assert idx.lookup(1) == -1
  276:         assert idx.lookup(2) == 0
  277:         assert idx.lookup(3) == 1
  278:         assert idx.lookup(4) == -1
  279: 
  280:         idx = make_sparse_index(4, np.array([], dtype=np.int32), kind=kind)
  281: 
  282:         for i in range(-1, 5):
  283:             assert idx.lookup(i) == -1
  284: 
  285:         idx = make_sparse_index(4, np.array([0, 1, 2, 3], dtype=np.int32), kind=kind)
  286:         assert idx.lookup(-1) == -1
  287:         assert idx.lookup(0) == 0
  288:         assert idx.lookup(1) == 1
  289:         assert idx.lookup(2) == 2
  290:         assert idx.lookup(3) == 3
  291:         assert idx.lookup(4) == -1
  292: 
  293:         idx = make_sparse_index(4, np.array([0, 2, 3], dtype=np.int32), kind=kind)
  294:         assert idx.lookup(-1) == -1
  295:         assert idx.lookup(0) == 0
  296:         assert idx.lookup(1) == -1
  297:         assert idx.lookup(2) == 1
  298:         assert idx.lookup(3) == 2
  299:         assert idx.lookup(4) == -1
  300: 
  301:     @pytest.mark.parametrize("kind", ["integer", "block"])
  302:     def test_lookup_array(self, kind):
  303:         idx = make_sparse_index(4, np.array([2, 3], dtype=np.int32), kind=kind)
  304: 
  305:         res = idx.lookup_array(np.array([-1, 0, 2], dtype=np.int32))
  306:         exp = np.array([-1, -1, 0], dtype=np.int32)
  307:         tm.assert_numpy_array_equal(res, exp)
  308: 
  309:         res = idx.lookup_array(np.array([4, 2, 1, 3], dtype=np.int32))
  310:         exp = np.array([-1, 0, -1, 1], dtype=np.int32)
  311:         tm.assert_numpy_array_equal(res, exp)
  312: 
  313:         idx = make_sparse_index(4, np.array([], dtype=np.int32), kind=kind)
  314:         res = idx.lookup_array(np.array([-1, 0, 2, 4], dtype=np.int32))
  315:         exp = np.array([-1, -1, -1, -1], dtype=np.int32)
  316:         tm.assert_numpy_array_equal(res, exp)
  317: 
  318:         idx = make_sparse_index(4, np.array([0, 1, 2, 3], dtype=np.int32), kind=kind)
  319:         res = idx.lookup_array(np.array([-1, 0, 2], dtype=np.int32))
  320:         exp = np.array([-1, 0, 2], dtype=np.int32)
  321:         tm.assert_numpy_array_equal(res, exp)
  322: 
  323:         res = idx.lookup_array(np.array([4, 2, 1, 3], dtype=np.int32))
  324:         exp = np.array([-1, 2, 1, 3], dtype=np.int32)
  325:         tm.assert_numpy_array_equal(res, exp)
  326: 
  327:         idx = make_sparse_index(4, np.array([0, 2, 3], dtype=np.int32), kind=kind)
  328:         res = idx.lookup_array(np.array([2, 1, 3, 0], dtype=np.int32))
  329:         exp = np.array([1, -1, 2, 0], dtype=np.int32)
  330:         tm.assert_numpy_array_equal(res, exp)
  331: 
  332:         res = idx.lookup_array(np.array([1, 4, 2, 5], dtype=np.int32))
  333:         exp = np.array([-1, -1, 1, -1], dtype=np.int32)
  334:         tm.assert_numpy_array_equal(res, exp)
  335: 
  336:     @pytest.mark.parametrize(
  337:         "idx, expected",
  338:         [
  339:             [0, -1],
  340:             [5, 0],
  341:             [7, 2],
  342:             [8, -1],
  343:             [9, -1],
  344:             [10, -1],
  345:             [11, -1],
  346:             [12, 3],
  347:             [17, 8],
  348:             [18, -1],
  349:         ],
  350:     )
  351:     def test_lookup_basics(self, idx, expected):
  352:         bindex = BlockIndex(20, [5, 12], [3, 6])
  353:         assert bindex.lookup(idx) == expected
  354: 
  355:         iindex = bindex.to_int_index()
  356:         assert iindex.lookup(idx) == expected
  357: 
  358: 
  359: class TestBlockIndex:
  360:     def test_block_internal(self):
  361:         idx = make_sparse_index(4, np.array([2, 3], dtype=np.int32), kind="block")
  362:         assert isinstance(idx, BlockIndex)
  363:         assert idx.npoints == 2
  364:         tm.assert_numpy_array_equal(idx.blocs, np.array([2], dtype=np.int32))
  365:         tm.assert_numpy_array_equal(idx.blengths, np.array([2], dtype=np.int32))
  366: 
  367:         idx = make_sparse_index(4, np.array([], dtype=np.int32), kind="block")
  368:         assert isinstance(idx, BlockIndex)
  369:         assert idx.npoints == 0
  370:         tm.assert_numpy_array_equal(idx.blocs, np.array([], dtype=np.int32))
  371:         tm.assert_numpy_array_equal(idx.blengths, np.array([], dtype=np.int32))
  372: 
  373:         idx = make_sparse_index(4, np.array([0, 1, 2, 3], dtype=np.int32), kind="block")
  374:         assert isinstance(idx, BlockIndex)
  375:         assert idx.npoints == 4
  376:         tm.assert_numpy_array_equal(idx.blocs, np.array([0], dtype=np.int32))
  377:         tm.assert_numpy_array_equal(idx.blengths, np.array([4], dtype=np.int32))
  378: 
  379:         idx = make_sparse_index(4, np.array([0, 2, 3], dtype=np.int32), kind="block")
  380:         assert isinstance(idx, BlockIndex)
  381:         assert idx.npoints == 3
  382:         tm.assert_numpy_array_equal(idx.blocs, np.array([0, 2], dtype=np.int32))
  383:         tm.assert_numpy_array_equal(idx.blengths, np.array([1, 2], dtype=np.int32))
  384: 
  385:     @pytest.mark.parametrize("i", [5, 10, 100, 101])
  386:     def test_make_block_boundary(self, i):
  387:         idx = make_sparse_index(i, np.arange(0, i, 2, dtype=np.int32), kind="block")
  388: 
  389:         exp = np.arange(0, i, 2, dtype=np.int32)
  390:         tm.assert_numpy_array_equal(idx.blocs, exp)
  391:         tm.assert_numpy_array_equal(idx.blengths, np.ones(len(exp), dtype=np.int32))
  392: 
  393:     def test_equals(self):
  394:         index = BlockIndex(10, [0, 4], [2, 5])
  395: 
  396:         assert index.equals(index)
  397:         assert not index.equals(BlockIndex(10, [0, 4], [2, 6]))
  398: 
  399:     def test_check_integrity(self):
  400:         locs = []
  401:         lengths = []
  402: 
  403:         # 0-length OK
  404:         BlockIndex(0, locs, lengths)
  405: 
  406:         # also OK even though empty
  407:         BlockIndex(1, locs, lengths)
  408: 
  409:         msg = "Block 0 extends beyond end"
  410:         with pytest.raises(ValueError, match=msg):
  411:             BlockIndex(10, [5], [10])
  412: 
  413:         msg = "Block 0 overlaps"
  414:         with pytest.raises(ValueError, match=msg):
  415:             BlockIndex(10, [2, 5], [5, 3])
  416: 
  417:     def test_to_int_index(self):
  418:         locs = [0, 10]
  419:         lengths = [4, 6]
  420:         exp_inds = [0, 1, 2, 3, 10, 11, 12, 13, 14, 15]
  421: 
  422:         block = BlockIndex(20, locs, lengths)
  423:         dense = block.to_int_index()
  424: 
  425:         tm.assert_numpy_array_equal(dense.indices, np.array(exp_inds, dtype=np.int32))
  426: 
  427:     def test_to_block_index(self):
  428:         index = BlockIndex(10, [0, 5], [4, 5])
  429:         assert index.to_block_index() is index
  430: 
  431: 
  432: class TestIntIndex:
  433:     def test_check_integrity(self):
  434:         # Too many indices than specified in self.length
  435:         msg = "Too many indices"
  436: 
  437:         with pytest.raises(ValueError, match=msg):
  438:             IntIndex(length=1, indices=[1, 2, 3])
  439: 
  440:         # No index can be negative.
  441:         msg = "No index can be less than zero"
  442: 
  443:         with pytest.raises(ValueError, match=msg):
  444:             IntIndex(length=5, indices=[1, -2, 3])
  445: 
  446:         # No index can be negative.
  447:         msg = "No index can be less than zero"
  448: 
  449:         with pytest.raises(ValueError, match=msg):
  450:             IntIndex(length=5, indices=[1, -2, 3])
  451: 
  452:         # All indices must be less than the length.
  453:         msg = "All indices must be less than the length"
  454: 
  455:         with pytest.raises(ValueError, match=msg):
  456:             IntIndex(length=5, indices=[1, 2, 5])
  457: 
  458:         with pytest.raises(ValueError, match=msg):
  459:             IntIndex(length=5, indices=[1, 2, 6])
  460: 
  461:         # Indices must be strictly ascending.
  462:         msg = "Indices must be strictly increasing"
  463: 
  464:         with pytest.raises(ValueError, match=msg):
  465:             IntIndex(length=5, indices=[1, 3, 2])
  466: 
  467:         with pytest.raises(ValueError, match=msg):
  468:             IntIndex(length=5, indices=[1, 3, 3])
  469: 
  470:     def test_int_internal(self):
  471:         idx = make_sparse_index(4, np.array([2, 3], dtype=np.int32), kind="integer")
  472:         assert isinstance(idx, IntIndex)
  473:         assert idx.npoints == 2
  474:         tm.assert_numpy_array_equal(idx.indices, np.array([2, 3], dtype=np.int32))
  475: 
  476:         idx = make_sparse_index(4, np.array([], dtype=np.int32), kind="integer")
  477:         assert isinstance(idx, IntIndex)
  478:         assert idx.npoints == 0
  479:         tm.assert_numpy_array_equal(idx.indices, np.array([], dtype=np.int32))
  480: 
  481:         idx = make_sparse_index(
  482:             4, np.array([0, 1, 2, 3], dtype=np.int32), kind="integer"
  483:         )
  484:         assert isinstance(idx, IntIndex)
  485:         assert idx.npoints == 4
  486:         tm.assert_numpy_array_equal(idx.indices, np.array([0, 1, 2, 3], dtype=np.int32))
  487: 
  488:     def test_equals(self):
  489:         index = IntIndex(10, [0, 1, 2, 3, 4])
  490:         assert index.equals(index)
  491:         assert not index.equals(IntIndex(10, [0, 1, 2, 3]))
  492: 
  493:     def test_to_block_index(self, cases, test_length):
  494:         xloc, xlen, yloc, ylen, _, _ = cases
  495:         xindex = BlockIndex(test_length, xloc, xlen)
  496:         yindex = BlockIndex(test_length, yloc, ylen)
  497: 
  498:         # see if survive the round trip
  499:         xbindex = xindex.to_int_index().to_block_index()
  500:         ybindex = yindex.to_int_index().to_block_index()
  501:         assert isinstance(xbindex, BlockIndex)
  502:         assert xbindex.equals(xindex)
  503:         assert ybindex.equals(yindex)
  504: 
  505:     def test_to_int_index(self):
  506:         index = IntIndex(10, [2, 3, 4, 5, 6])
  507:         assert index.to_int_index() is index
  508: 
  509: 
  510: class TestSparseOperators:
  511:     @pytest.mark.parametrize("opname", ["add", "sub", "mul", "truediv", "floordiv"])
  512:     def test_op(self, opname, cases, test_length):
  513:         xloc, xlen, yloc, ylen, _, _ = cases
  514:         sparse_op = getattr(splib, f"sparse_{opname}_float64")
  515:         python_op = getattr(operator, opname)
  516: 
  517:         xindex = BlockIndex(test_length, xloc, xlen)
  518:         yindex = BlockIndex(test_length, yloc, ylen)
  519: 
  520:         xdindex = xindex.to_int_index()
  521:         ydindex = yindex.to_int_index()
  522: 
  523:         x = np.arange(xindex.npoints) * 10.0 + 1
  524:         y = np.arange(yindex.npoints) * 100.0 + 1
  525: 
  526:         xfill = 0
  527:         yfill = 2
  528: 
  529:         result_block_vals, rb_index, bfill = sparse_op(
  530:             x, xindex, xfill, y, yindex, yfill
  531:         )
  532:         result_int_vals, ri_index, ifill = sparse_op(
  533:             x, xdindex, xfill, y, ydindex, yfill
  534:         )
  535: 
  536:         assert rb_index.to_int_index().equals(ri_index)
  537:         tm.assert_numpy_array_equal(result_block_vals, result_int_vals)
  538:         assert bfill == ifill
  539: 
  540:         # check versus Series...
  541:         xseries = Series(x, xdindex.indices)
  542:         xseries = xseries.reindex(np.arange(test_length)).fillna(xfill)
  543: 
  544:         yseries = Series(y, ydindex.indices)
  545:         yseries = yseries.reindex(np.arange(test_length)).fillna(yfill)
  546: 
  547:         series_result = python_op(xseries, yseries)
  548:         series_result = series_result.reindex(ri_index.indices)
  549: 
  550:         tm.assert_numpy_array_equal(result_block_vals, series_result.values)
  551:         tm.assert_numpy_array_equal(result_int_vals, series_result.values)
