    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.compat import PY311
    7: 
    8: from pandas import (
    9:     Categorical,
   10:     CategoricalIndex,
   11:     DataFrame,
   12:     Index,
   13:     Series,
   14:     StringDtype,
   15: )
   16: import pandas._testing as tm
   17: from pandas.core.arrays.categorical import recode_for_categories
   18: 
   19: 
   20: class TestCategoricalAPI:
   21:     def test_to_list_deprecated(self):
   22:         # GH#51254
   23:         cat1 = Categorical(list("acb"), ordered=False)
   24:         msg = "Categorical.to_list is deprecated and will be removed"
   25:         with tm.assert_produces_warning(FutureWarning, match=msg):
   26:             cat1.to_list()
   27: 
   28:     def test_ordered_api(self):
   29:         # GH 9347
   30:         cat1 = Categorical(list("acb"), ordered=False)
   31:         tm.assert_index_equal(cat1.categories, Index(["a", "b", "c"]))
   32:         assert not cat1.ordered
   33: 
   34:         cat2 = Categorical(list("acb"), categories=list("bca"), ordered=False)
   35:         tm.assert_index_equal(cat2.categories, Index(["b", "c", "a"]))
   36:         assert not cat2.ordered
   37: 
   38:         cat3 = Categorical(list("acb"), ordered=True)
   39:         tm.assert_index_equal(cat3.categories, Index(["a", "b", "c"]))
   40:         assert cat3.ordered
   41: 
   42:         cat4 = Categorical(list("acb"), categories=list("bca"), ordered=True)
   43:         tm.assert_index_equal(cat4.categories, Index(["b", "c", "a"]))
   44:         assert cat4.ordered
   45: 
   46:     def test_set_ordered(self):
   47:         cat = Categorical(["a", "b", "c", "a"], ordered=True)
   48:         cat2 = cat.as_unordered()
   49:         assert not cat2.ordered
   50:         cat2 = cat.as_ordered()
   51:         assert cat2.ordered
   52: 
   53:         assert cat2.set_ordered(True).ordered
   54:         assert not cat2.set_ordered(False).ordered
   55: 
   56:         # removed in 0.19.0
   57:         msg = (
   58:             "property 'ordered' of 'Categorical' object has no setter"
   59:             if PY311
   60:             else "can't set attribute"
   61:         )
   62:         with pytest.raises(AttributeError, match=msg):
   63:             cat.ordered = True
   64:         with pytest.raises(AttributeError, match=msg):
   65:             cat.ordered = False
   66: 
   67:     def test_rename_categories(self):
   68:         cat = Categorical(["a", "b", "c", "a"])
   69: 
   70:         # inplace=False: the old one must not be changed
   71:         res = cat.rename_categories([1, 2, 3])
   72:         tm.assert_numpy_array_equal(
   73:             res.__array__(), np.array([1, 2, 3, 1], dtype=np.int64)
   74:         )
   75:         tm.assert_index_equal(res.categories, Index([1, 2, 3]))
   76: 
   77:         exp_cat = np.array(["a", "b", "c", "a"], dtype=np.object_)
   78:         tm.assert_numpy_array_equal(cat.__array__(), exp_cat)
   79: 
   80:         exp_cat = Index(["a", "b", "c"])
   81:         tm.assert_index_equal(cat.categories, exp_cat)
   82: 
   83:         # GH18862 (let rename_categories take callables)
   84:         result = cat.rename_categories(lambda x: x.upper())
   85:         expected = Categorical(["A", "B", "C", "A"])
   86:         tm.assert_categorical_equal(result, expected)
   87: 
   88:     @pytest.mark.parametrize("new_categories", [[1, 2, 3, 4], [1, 2]])
   89:     def test_rename_categories_wrong_length_raises(self, new_categories):
   90:         cat = Categorical(["a", "b", "c", "a"])
   91:         msg = (
   92:             "new categories need to have the same number of items as the "
   93:             "old categories!"
   94:         )
   95:         with pytest.raises(ValueError, match=msg):
   96:             cat.rename_categories(new_categories)
   97: 
   98:     def test_rename_categories_series(self):
   99:         # https://github.com/pandas-dev/pandas/issues/17981
  100:         c = Categorical(["a", "b"])
  101:         result = c.rename_categories(Series([0, 1], index=["a", "b"]))
  102:         expected = Categorical([0, 1])
  103:         tm.assert_categorical_equal(result, expected)
  104: 
  105:     def test_rename_categories_dict(self):
  106:         # GH 17336
  107:         cat = Categorical(["a", "b", "c", "d"])
  108:         res = cat.rename_categories({"a": 4, "b": 3, "c": 2, "d": 1})
  109:         expected = Index([4, 3, 2, 1])
  110:         tm.assert_index_equal(res.categories, expected)
  111: 
  112:         # Test for dicts of smaller length
  113:         cat = Categorical(["a", "b", "c", "d"])
  114:         res = cat.rename_categories({"a": 1, "c": 3})
  115: 
  116:         expected = Index([1, "b", 3, "d"])
  117:         tm.assert_index_equal(res.categories, expected)
  118: 
  119:         # Test for dicts with bigger length
  120:         cat = Categorical(["a", "b", "c", "d"])
  121:         res = cat.rename_categories({"a": 1, "b": 2, "c": 3, "d": 4, "e": 5, "f": 6})
  122:         expected = Index([1, 2, 3, 4])
  123:         tm.assert_index_equal(res.categories, expected)
  124: 
  125:         # Test for dicts with no items from old categories
  126:         cat = Categorical(["a", "b", "c", "d"])
  127:         res = cat.rename_categories({"f": 1, "g": 3})
  128: 
  129:         expected = Index(["a", "b", "c", "d"])
  130:         tm.assert_index_equal(res.categories, expected)
  131: 
  132:     def test_reorder_categories(self):
  133:         cat = Categorical(["a", "b", "c", "a"], ordered=True)
  134:         old = cat.copy()
  135:         new = Categorical(
  136:             ["a", "b", "c", "a"], categories=["c", "b", "a"], ordered=True
  137:         )
  138: 
  139:         res = cat.reorder_categories(["c", "b", "a"])
  140:         # cat must be the same as before
  141:         tm.assert_categorical_equal(cat, old)
  142:         # only res is changed
  143:         tm.assert_categorical_equal(res, new)
  144: 
  145:     @pytest.mark.parametrize(
  146:         "new_categories",
  147:         [
  148:             ["a"],  # not all "old" included in "new"
  149:             ["a", "b", "d"],  # still not all "old" in "new"
  150:             ["a", "b", "c", "d"],  # all "old" included in "new", but too long
  151:         ],
  152:     )
  153:     def test_reorder_categories_raises(self, new_categories):
  154:         cat = Categorical(["a", "b", "c", "a"], ordered=True)
  155:         msg = "items in new_categories are not the same as in old categories"
  156:         with pytest.raises(ValueError, match=msg):
  157:             cat.reorder_categories(new_categories)
  158: 
  159:     def test_add_categories(self):
  160:         cat = Categorical(["a", "b", "c", "a"], ordered=True)
  161:         old = cat.copy()
  162:         new = Categorical(
  163:             ["a", "b", "c", "a"], categories=["a", "b", "c", "d"], ordered=True
  164:         )
  165: 
  166:         res = cat.add_categories("d")
  167:         tm.assert_categorical_equal(cat, old)
  168:         tm.assert_categorical_equal(res, new)
  169: 
  170:         res = cat.add_categories(["d"])
  171:         tm.assert_categorical_equal(cat, old)
  172:         tm.assert_categorical_equal(res, new)
  173: 
  174:         # GH 9927
  175:         cat = Categorical(list("abc"), ordered=True)
  176:         expected = Categorical(list("abc"), categories=list("abcde"), ordered=True)
  177:         # test with Series, np.array, index, list
  178:         res = cat.add_categories(Series(["d", "e"]))
  179:         tm.assert_categorical_equal(res, expected)
  180:         res = cat.add_categories(np.array(["d", "e"]))
  181:         tm.assert_categorical_equal(res, expected)
  182:         res = cat.add_categories(Index(["d", "e"]))
  183:         tm.assert_categorical_equal(res, expected)
  184:         res = cat.add_categories(["d", "e"])
  185:         tm.assert_categorical_equal(res, expected)
  186: 
  187:     def test_add_categories_existing_raises(self):
  188:         # new is in old categories
  189:         cat = Categorical(["a", "b", "c", "d"], ordered=True)
  190:         msg = re.escape("new categories must not include old categories: {'d'}")
  191:         with pytest.raises(ValueError, match=msg):
  192:             cat.add_categories(["d"])
  193: 
  194:     def test_add_categories_losing_dtype_information(self):
  195:         # GH#48812
  196:         cat = Categorical(Series([1, 2], dtype="Int64"))
  197:         ser = Series([4], dtype="Int64")
  198:         result = cat.add_categories(ser)
  199:         expected = Categorical(
  200:             Series([1, 2], dtype="Int64"), categories=Series([1, 2, 4], dtype="Int64")
  201:         )
  202:         tm.assert_categorical_equal(result, expected)
  203: 
  204:         cat = Categorical(Series(["a", "b", "a"], dtype=StringDtype()))
  205:         ser = Series(["d"], dtype=StringDtype())
  206:         result = cat.add_categories(ser)
  207:         expected = Categorical(
  208:             Series(["a", "b", "a"], dtype=StringDtype()),
  209:             categories=Series(["a", "b", "d"], dtype=StringDtype()),
  210:         )
  211:         tm.assert_categorical_equal(result, expected)
  212: 
  213:     def test_set_categories(self):
  214:         cat = Categorical(["a", "b", "c", "a"], ordered=True)
  215:         exp_categories = Index(["c", "b", "a"])
  216:         exp_values = np.array(["a", "b", "c", "a"], dtype=np.object_)
  217: 
  218:         cat = cat.set_categories(["c", "b", "a"])
  219:         res = cat.set_categories(["a", "b", "c"])
  220:         # cat must be the same as before
  221:         tm.assert_index_equal(cat.categories, exp_categories)
  222:         tm.assert_numpy_array_equal(cat.__array__(), exp_values)
  223:         # only res is changed
  224:         exp_categories_back = Index(["a", "b", "c"])
  225:         tm.assert_index_equal(res.categories, exp_categories_back)
  226:         tm.assert_numpy_array_equal(res.__array__(), exp_values)
  227: 
  228:         # not all "old" included in "new" -> all not included ones are now
  229:         # np.nan
  230:         cat = Categorical(["a", "b", "c", "a"], ordered=True)
  231:         res = cat.set_categories(["a"])
  232:         tm.assert_numpy_array_equal(res.codes, np.array([0, -1, -1, 0], dtype=np.int8))
  233: 
  234:         # still not all "old" in "new"
  235:         res = cat.set_categories(["a", "b", "d"])
  236:         tm.assert_numpy_array_equal(res.codes, np.array([0, 1, -1, 0], dtype=np.int8))
  237:         tm.assert_index_equal(res.categories, Index(["a", "b", "d"]))
  238: 
  239:         # all "old" included in "new"
  240:         cat = cat.set_categories(["a", "b", "c", "d"])
  241:         exp_categories = Index(["a", "b", "c", "d"])
  242:         tm.assert_index_equal(cat.categories, exp_categories)
  243: 
  244:         # internals...
  245:         c = Categorical([1, 2, 3, 4, 1], categories=[1, 2, 3, 4], ordered=True)
  246:         tm.assert_numpy_array_equal(c._codes, np.array([0, 1, 2, 3, 0], dtype=np.int8))
  247:         tm.assert_index_equal(c.categories, Index([1, 2, 3, 4]))
  248: 
  249:         exp = np.array([1, 2, 3, 4, 1], dtype=np.int64)
  250:         tm.assert_numpy_array_equal(np.asarray(c), exp)
  251: 
  252:         # all "pointers" to '4' must be changed from 3 to 0,...
  253:         c = c.set_categories([4, 3, 2, 1])
  254: 
  255:         # positions are changed
  256:         tm.assert_numpy_array_equal(c._codes, np.array([3, 2, 1, 0, 3], dtype=np.int8))
  257: 
  258:         # categories are now in new order
  259:         tm.assert_index_equal(c.categories, Index([4, 3, 2, 1]))
  260: 
  261:         # output is the same
  262:         exp = np.array([1, 2, 3, 4, 1], dtype=np.int64)
  263:         tm.assert_numpy_array_equal(np.asarray(c), exp)
  264:         assert c.min() == 4
  265:         assert c.max() == 1
  266: 
  267:         # set_categories should set the ordering if specified
  268:         c2 = c.set_categories([4, 3, 2, 1], ordered=False)
  269:         assert not c2.ordered
  270: 
  271:         tm.assert_numpy_array_equal(np.asarray(c), np.asarray(c2))
  272: 
  273:         # set_categories should pass thru the ordering
  274:         c2 = c.set_ordered(False).set_categories([4, 3, 2, 1])
  275:         assert not c2.ordered
  276: 
  277:         tm.assert_numpy_array_equal(np.asarray(c), np.asarray(c2))
  278: 
  279:     @pytest.mark.parametrize(
  280:         "values, categories, new_categories",
  281:         [
  282:             # No NaNs, same cats, same order
  283:             (["a", "b", "a"], ["a", "b"], ["a", "b"]),
  284:             # No NaNs, same cats, different order
  285:             (["a", "b", "a"], ["a", "b"], ["b", "a"]),
  286:             # Same, unsorted
  287:             (["b", "a", "a"], ["a", "b"], ["a", "b"]),
  288:             # No NaNs, same cats, different order
  289:             (["b", "a", "a"], ["a", "b"], ["b", "a"]),
  290:             # NaNs
  291:             (["a", "b", "c"], ["a", "b"], ["a", "b"]),
  292:             (["a", "b", "c"], ["a", "b"], ["b", "a"]),
  293:             (["b", "a", "c"], ["a", "b"], ["a", "b"]),
  294:             (["b", "a", "c"], ["a", "b"], ["a", "b"]),
  295:             # Introduce NaNs
  296:             (["a", "b", "c"], ["a", "b"], ["a"]),
  297:             (["a", "b", "c"], ["a", "b"], ["b"]),
  298:             (["b", "a", "c"], ["a", "b"], ["a"]),
  299:             (["b", "a", "c"], ["a", "b"], ["a"]),
  300:             # No overlap
  301:             (["a", "b", "c"], ["a", "b"], ["d", "e"]),
  302:         ],
  303:     )
  304:     @pytest.mark.parametrize("ordered", [True, False])
  305:     def test_set_categories_many(self, values, categories, new_categories, ordered):
  306:         c = Categorical(values, categories)
  307:         expected = Categorical(values, new_categories, ordered)
  308:         result = c.set_categories(new_categories, ordered=ordered)
  309:         tm.assert_categorical_equal(result, expected)
  310: 
  311:     def test_set_categories_rename_less(self):
  312:         # GH 24675
  313:         cat = Categorical(["A", "B"])
  314:         result = cat.set_categories(["A"], rename=True)
  315:         expected = Categorical(["A", np.nan])
  316:         tm.assert_categorical_equal(result, expected)
  317: 
  318:     def test_set_categories_private(self):
  319:         cat = Categorical(["a", "b", "c"], categories=["a", "b", "c", "d"])
  320:         cat._set_categories(["a", "c", "d", "e"])
  321:         expected = Categorical(["a", "c", "d"], categories=list("acde"))
  322:         tm.assert_categorical_equal(cat, expected)
  323: 
  324:         # fastpath
  325:         cat = Categorical(["a", "b", "c"], categories=["a", "b", "c", "d"])
  326:         cat._set_categories(["a", "c", "d", "e"], fastpath=True)
  327:         expected = Categorical(["a", "c", "d"], categories=list("acde"))
  328:         tm.assert_categorical_equal(cat, expected)
  329: 
  330:     def test_remove_categories(self):
  331:         cat = Categorical(["a", "b", "c", "a"], ordered=True)
  332:         old = cat.copy()
  333:         new = Categorical(["a", "b", np.nan, "a"], categories=["a", "b"], ordered=True)
  334: 
  335:         res = cat.remove_categories("c")
  336:         tm.assert_categorical_equal(cat, old)
  337:         tm.assert_categorical_equal(res, new)
  338: 
  339:         res = cat.remove_categories(["c"])
  340:         tm.assert_categorical_equal(cat, old)
  341:         tm.assert_categorical_equal(res, new)
  342: 
  343:     @pytest.mark.parametrize("removals", [["c"], ["c", np.nan], "c", ["c", "c"]])
  344:     def test_remove_categories_raises(self, removals):
  345:         cat = Categorical(["a", "b", "a"])
  346:         message = re.escape("removals must all be in old categories: {'c'}")
  347: 
  348:         with pytest.raises(ValueError, match=message):
  349:             cat.remove_categories(removals)
  350: 
  351:     def test_remove_unused_categories(self):
  352:         c = Categorical(["a", "b", "c", "d", "a"], categories=["a", "b", "c", "d", "e"])
  353:         exp_categories_all = Index(["a", "b", "c", "d", "e"])
  354:         exp_categories_dropped = Index(["a", "b", "c", "d"])
  355: 
  356:         tm.assert_index_equal(c.categories, exp_categories_all)
  357: 
  358:         res = c.remove_unused_categories()
  359:         tm.assert_index_equal(res.categories, exp_categories_dropped)
  360:         tm.assert_index_equal(c.categories, exp_categories_all)
  361: 
  362:         # with NaN values (GH11599)
  363:         c = Categorical(["a", "b", "c", np.nan], categories=["a", "b", "c", "d", "e"])
  364:         res = c.remove_unused_categories()
  365:         tm.assert_index_equal(res.categories, Index(np.array(["a", "b", "c"])))
  366:         exp_codes = np.array([0, 1, 2, -1], dtype=np.int8)
  367:         tm.assert_numpy_array_equal(res.codes, exp_codes)
  368:         tm.assert_index_equal(c.categories, exp_categories_all)
  369: 
  370:         val = ["F", np.nan, "D", "B", "D", "F", np.nan]
  371:         cat = Categorical(values=val, categories=list("ABCDEFG"))
  372:         out = cat.remove_unused_categories()
  373:         tm.assert_index_equal(out.categories, Index(["B", "D", "F"]))
  374:         exp_codes = np.array([2, -1, 1, 0, 1, 2, -1], dtype=np.int8)
  375:         tm.assert_numpy_array_equal(out.codes, exp_codes)
  376:         assert out.tolist() == val
  377: 
  378:         alpha = list("abcdefghijklmnopqrstuvwxyz")
  379:         val = np.random.default_rng(2).choice(alpha[::2], 10000).astype("object")
  380:         val[np.random.default_rng(2).choice(len(val), 100)] = np.nan
  381: 
  382:         cat = Categorical(values=val, categories=alpha)
  383:         out = cat.remove_unused_categories()
  384:         assert out.tolist() == val.tolist()
  385: 
  386: 
  387: class TestCategoricalAPIWithFactor:
  388:     def test_describe(self):
  389:         factor = Categorical(["a", "b", "b", "a", "a", "c", "c", "c"], ordered=True)
  390:         # string type
  391:         desc = factor.describe()
  392:         assert factor.ordered
  393:         exp_index = CategoricalIndex(
  394:             ["a", "b", "c"], name="categories", ordered=factor.ordered
  395:         )
  396:         expected = DataFrame(
  397:             {"counts": [3, 2, 3], "freqs": [3 / 8.0, 2 / 8.0, 3 / 8.0]}, index=exp_index
  398:         )
  399:         tm.assert_frame_equal(desc, expected)
  400: 
  401:         # check unused categories
  402:         cat = factor.copy()
  403:         cat = cat.set_categories(["a", "b", "c", "d"])
  404:         desc = cat.describe()
  405: 
  406:         exp_index = CategoricalIndex(
  407:             list("abcd"), ordered=factor.ordered, name="categories"
  408:         )
  409:         expected = DataFrame(
  410:             {"counts": [3, 2, 3, 0], "freqs": [3 / 8.0, 2 / 8.0, 3 / 8.0, 0]},
  411:             index=exp_index,
  412:         )
  413:         tm.assert_frame_equal(desc, expected)
  414: 
  415:         # check an integer one
  416:         cat = Categorical([1, 2, 3, 1, 2, 3, 3, 2, 1, 1, 1])
  417:         desc = cat.describe()
  418:         exp_index = CategoricalIndex([1, 2, 3], ordered=cat.ordered, name="categories")
  419:         expected = DataFrame(
  420:             {"counts": [5, 3, 3], "freqs": [5 / 11.0, 3 / 11.0, 3 / 11.0]},
  421:             index=exp_index,
  422:         )
  423:         tm.assert_frame_equal(desc, expected)
  424: 
  425:         # https://github.com/pandas-dev/pandas/issues/3678
  426:         # describe should work with NaN
  427:         cat = Categorical([np.nan, 1, 2, 2])
  428:         desc = cat.describe()
  429:         expected = DataFrame(
  430:             {"counts": [1, 2, 1], "freqs": [1 / 4.0, 2 / 4.0, 1 / 4.0]},
  431:             index=CategoricalIndex(
  432:                 [1, 2, np.nan], categories=[1, 2], name="categories"
  433:             ),
  434:         )
  435:         tm.assert_frame_equal(desc, expected)
  436: 
  437: 
  438: class TestPrivateCategoricalAPI:
  439:     def test_codes_immutable(self):
  440:         # Codes should be read only
  441:         c = Categorical(["a", "b", "c", "a", np.nan])
  442:         exp = np.array([0, 1, 2, 0, -1], dtype="int8")
  443:         tm.assert_numpy_array_equal(c.codes, exp)
  444: 
  445:         # Assignments to codes should raise
  446:         msg = (
  447:             "property 'codes' of 'Categorical' object has no setter"
  448:             if PY311
  449:             else "can't set attribute"
  450:         )
  451:         with pytest.raises(AttributeError, match=msg):
  452:             c.codes = np.array([0, 1, 2, 0, 1], dtype="int8")
  453: 
  454:         # changes in the codes array should raise
  455:         codes = c.codes
  456: 
  457:         with pytest.raises(ValueError, match="assignment destination is read-only"):
  458:             codes[4] = 1
  459: 
  460:         # But even after getting the codes, the original array should still be
  461:         # writeable!
  462:         c[4] = "a"
  463:         exp = np.array([0, 1, 2, 0, 0], dtype="int8")
  464:         tm.assert_numpy_array_equal(c.codes, exp)
  465:         c._codes[4] = 2
  466:         exp = np.array([0, 1, 2, 0, 2], dtype="int8")
  467:         tm.assert_numpy_array_equal(c.codes, exp)
  468: 
  469:     @pytest.mark.parametrize(
  470:         "codes, old, new, expected",
  471:         [
  472:             ([0, 1], ["a", "b"], ["a", "b"], [0, 1]),
  473:             ([0, 1], ["b", "a"], ["b", "a"], [0, 1]),
  474:             ([0, 1], ["a", "b"], ["b", "a"], [1, 0]),
  475:             ([0, 1], ["b", "a"], ["a", "b"], [1, 0]),
  476:             ([0, 1, 0, 1], ["a", "b"], ["a", "b", "c"], [0, 1, 0, 1]),
  477:             ([0, 1, 2, 2], ["a", "b", "c"], ["a", "b"], [0, 1, -1, -1]),
  478:             ([0, 1, -1], ["a", "b", "c"], ["a", "b", "c"], [0, 1, -1]),
  479:             ([0, 1, -1], ["a", "b", "c"], ["b"], [-1, 0, -1]),
  480:             ([0, 1, -1], ["a", "b", "c"], ["d"], [-1, -1, -1]),
  481:             ([0, 1, -1], ["a", "b", "c"], [], [-1, -1, -1]),
  482:             ([-1, -1], [], ["a", "b"], [-1, -1]),
  483:             ([1, 0], ["b", "a"], ["a", "b"], [0, 1]),
  484:         ],
  485:     )
  486:     def test_recode_to_categories(self, codes, old, new, expected):
  487:         codes = np.asanyarray(codes, dtype=np.int8)
  488:         expected = np.asanyarray(expected, dtype=np.int8)
  489:         old = Index(old)
  490:         new = Index(new)
  491:         result = recode_for_categories(codes, old, new)
  492:         tm.assert_numpy_array_equal(result, expected)
  493: 
  494:     def test_recode_to_categories_large(self):
  495:         N = 1000
  496:         codes = np.arange(N)
  497:         old = Index(codes)
  498:         expected = np.arange(N - 1, -1, -1, dtype=np.int16)
  499:         new = Index(expected)
  500:         result = recode_for_categories(codes, old, new)
  501:         tm.assert_numpy_array_equal(result, expected)
