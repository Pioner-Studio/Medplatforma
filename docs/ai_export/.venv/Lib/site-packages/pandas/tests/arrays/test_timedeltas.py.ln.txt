    1: from datetime import timedelta
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import Timedelta
    8: import pandas._testing as tm
    9: from pandas.core.arrays import (
   10:     DatetimeArray,
   11:     TimedeltaArray,
   12: )
   13: 
   14: 
   15: class TestNonNano:
   16:     @pytest.fixture(params=["s", "ms", "us"])
   17:     def unit(self, request):
   18:         return request.param
   19: 
   20:     @pytest.fixture
   21:     def tda(self, unit):
   22:         arr = np.arange(5, dtype=np.int64).view(f"m8[{unit}]")
   23:         return TimedeltaArray._simple_new(arr, dtype=arr.dtype)
   24: 
   25:     def test_non_nano(self, unit):
   26:         arr = np.arange(5, dtype=np.int64).view(f"m8[{unit}]")
   27:         tda = TimedeltaArray._simple_new(arr, dtype=arr.dtype)
   28: 
   29:         assert tda.dtype == arr.dtype
   30:         assert tda[0].unit == unit
   31: 
   32:     def test_as_unit_raises(self, tda):
   33:         # GH#50616
   34:         with pytest.raises(ValueError, match="Supported units"):
   35:             tda.as_unit("D")
   36: 
   37:         tdi = pd.Index(tda)
   38:         with pytest.raises(ValueError, match="Supported units"):
   39:             tdi.as_unit("D")
   40: 
   41:     @pytest.mark.parametrize("field", TimedeltaArray._field_ops)
   42:     def test_fields(self, tda, field):
   43:         as_nano = tda._ndarray.astype("m8[ns]")
   44:         tda_nano = TimedeltaArray._simple_new(as_nano, dtype=as_nano.dtype)
   45: 
   46:         result = getattr(tda, field)
   47:         expected = getattr(tda_nano, field)
   48:         tm.assert_numpy_array_equal(result, expected)
   49: 
   50:     def test_to_pytimedelta(self, tda):
   51:         as_nano = tda._ndarray.astype("m8[ns]")
   52:         tda_nano = TimedeltaArray._simple_new(as_nano, dtype=as_nano.dtype)
   53: 
   54:         result = tda.to_pytimedelta()
   55:         expected = tda_nano.to_pytimedelta()
   56:         tm.assert_numpy_array_equal(result, expected)
   57: 
   58:     def test_total_seconds(self, unit, tda):
   59:         as_nano = tda._ndarray.astype("m8[ns]")
   60:         tda_nano = TimedeltaArray._simple_new(as_nano, dtype=as_nano.dtype)
   61: 
   62:         result = tda.total_seconds()
   63:         expected = tda_nano.total_seconds()
   64:         tm.assert_numpy_array_equal(result, expected)
   65: 
   66:     def test_timedelta_array_total_seconds(self):
   67:         # GH34290
   68:         expected = Timedelta("2 min").total_seconds()
   69: 
   70:         result = pd.array([Timedelta("2 min")]).total_seconds()[0]
   71:         assert result == expected
   72: 
   73:     def test_total_seconds_nanoseconds(self):
   74:         # issue #48521
   75:         start_time = pd.Series(["2145-11-02 06:00:00"]).astype("datetime64[ns]")
   76:         end_time = pd.Series(["2145-11-02 07:06:00"]).astype("datetime64[ns]")
   77:         expected = (end_time - start_time).values / np.timedelta64(1, "s")
   78:         result = (end_time - start_time).dt.total_seconds().values
   79:         assert result == expected
   80: 
   81:     @pytest.mark.parametrize(
   82:         "nat", [np.datetime64("NaT", "ns"), np.datetime64("NaT", "us")]
   83:     )
   84:     def test_add_nat_datetimelike_scalar(self, nat, tda):
   85:         result = tda + nat
   86:         assert isinstance(result, DatetimeArray)
   87:         assert result._creso == tda._creso
   88:         assert result.isna().all()
   89: 
   90:         result = nat + tda
   91:         assert isinstance(result, DatetimeArray)
   92:         assert result._creso == tda._creso
   93:         assert result.isna().all()
   94: 
   95:     def test_add_pdnat(self, tda):
   96:         result = tda + pd.NaT
   97:         assert isinstance(result, TimedeltaArray)
   98:         assert result._creso == tda._creso
   99:         assert result.isna().all()
  100: 
  101:         result = pd.NaT + tda
  102:         assert isinstance(result, TimedeltaArray)
  103:         assert result._creso == tda._creso
  104:         assert result.isna().all()
  105: 
  106:     # TODO: 2022-07-11 this is the only test that gets to DTA.tz_convert
  107:     #  or tz_localize with non-nano; implement tests specific to that.
  108:     def test_add_datetimelike_scalar(self, tda, tz_naive_fixture):
  109:         ts = pd.Timestamp("2016-01-01", tz=tz_naive_fixture).as_unit("ns")
  110: 
  111:         expected = tda.as_unit("ns") + ts
  112:         res = tda + ts
  113:         tm.assert_extension_array_equal(res, expected)
  114:         res = ts + tda
  115:         tm.assert_extension_array_equal(res, expected)
  116: 
  117:         ts += Timedelta(1)  # case where we can't cast losslessly
  118: 
  119:         exp_values = tda._ndarray + ts.asm8
  120:         expected = (
  121:             DatetimeArray._simple_new(exp_values, dtype=exp_values.dtype)
  122:             .tz_localize("UTC")
  123:             .tz_convert(ts.tz)
  124:         )
  125: 
  126:         result = tda + ts
  127:         tm.assert_extension_array_equal(result, expected)
  128: 
  129:         result = ts + tda
  130:         tm.assert_extension_array_equal(result, expected)
  131: 
  132:     def test_mul_scalar(self, tda):
  133:         other = 2
  134:         result = tda * other
  135:         expected = TimedeltaArray._simple_new(tda._ndarray * other, dtype=tda.dtype)
  136:         tm.assert_extension_array_equal(result, expected)
  137:         assert result._creso == tda._creso
  138: 
  139:     def test_mul_listlike(self, tda):
  140:         other = np.arange(len(tda))
  141:         result = tda * other
  142:         expected = TimedeltaArray._simple_new(tda._ndarray * other, dtype=tda.dtype)
  143:         tm.assert_extension_array_equal(result, expected)
  144:         assert result._creso == tda._creso
  145: 
  146:     def test_mul_listlike_object(self, tda):
  147:         other = np.arange(len(tda))
  148:         result = tda * other.astype(object)
  149:         expected = TimedeltaArray._simple_new(tda._ndarray * other, dtype=tda.dtype)
  150:         tm.assert_extension_array_equal(result, expected)
  151:         assert result._creso == tda._creso
  152: 
  153:     def test_div_numeric_scalar(self, tda):
  154:         other = 2
  155:         result = tda / other
  156:         expected = TimedeltaArray._simple_new(tda._ndarray / other, dtype=tda.dtype)
  157:         tm.assert_extension_array_equal(result, expected)
  158:         assert result._creso == tda._creso
  159: 
  160:     def test_div_td_scalar(self, tda):
  161:         other = timedelta(seconds=1)
  162:         result = tda / other
  163:         expected = tda._ndarray / np.timedelta64(1, "s")
  164:         tm.assert_numpy_array_equal(result, expected)
  165: 
  166:     def test_div_numeric_array(self, tda):
  167:         other = np.arange(len(tda))
  168:         result = tda / other
  169:         expected = TimedeltaArray._simple_new(tda._ndarray / other, dtype=tda.dtype)
  170:         tm.assert_extension_array_equal(result, expected)
  171:         assert result._creso == tda._creso
  172: 
  173:     def test_div_td_array(self, tda):
  174:         other = tda._ndarray + tda._ndarray[-1]
  175:         result = tda / other
  176:         expected = tda._ndarray / other
  177:         tm.assert_numpy_array_equal(result, expected)
  178: 
  179:     def test_add_timedeltaarraylike(self, tda):
  180:         tda_nano = tda.astype("m8[ns]")
  181: 
  182:         expected = tda_nano * 2
  183:         res = tda_nano + tda
  184:         tm.assert_extension_array_equal(res, expected)
  185:         res = tda + tda_nano
  186:         tm.assert_extension_array_equal(res, expected)
  187: 
  188:         expected = tda_nano * 0
  189:         res = tda - tda_nano
  190:         tm.assert_extension_array_equal(res, expected)
  191: 
  192:         res = tda_nano - tda
  193:         tm.assert_extension_array_equal(res, expected)
  194: 
  195: 
  196: class TestTimedeltaArray:
  197:     @pytest.mark.parametrize("dtype", [int, np.int32, np.int64, "uint32", "uint64"])
  198:     def test_astype_int(self, dtype):
  199:         arr = TimedeltaArray._from_sequence(
  200:             [Timedelta("1h"), Timedelta("2h")], dtype="m8[ns]"
  201:         )
  202: 
  203:         if np.dtype(dtype) != np.int64:
  204:             with pytest.raises(TypeError, match=r"Do obj.astype\('int64'\)"):
  205:                 arr.astype(dtype)
  206:             return
  207: 
  208:         result = arr.astype(dtype)
  209:         expected = arr._ndarray.view("i8")
  210:         tm.assert_numpy_array_equal(result, expected)
  211: 
  212:     def test_setitem_clears_freq(self):
  213:         a = pd.timedelta_range("1h", periods=2, freq="h")._data
  214:         a[0] = Timedelta("1h")
  215:         assert a.freq is None
  216: 
  217:     @pytest.mark.parametrize(
  218:         "obj",
  219:         [
  220:             Timedelta(seconds=1),
  221:             Timedelta(seconds=1).to_timedelta64(),
  222:             Timedelta(seconds=1).to_pytimedelta(),
  223:         ],
  224:     )
  225:     def test_setitem_objects(self, obj):
  226:         # make sure we accept timedelta64 and timedelta in addition to Timedelta
  227:         tdi = pd.timedelta_range("2 Days", periods=4, freq="h")
  228:         arr = tdi._data
  229: 
  230:         arr[0] = obj
  231:         assert arr[0] == Timedelta(seconds=1)
  232: 
  233:     @pytest.mark.parametrize(
  234:         "other",
  235:         [
  236:             1,
  237:             np.int64(1),
  238:             1.0,
  239:             np.datetime64("NaT"),
  240:             pd.Timestamp("2021-01-01"),
  241:             "invalid",
  242:             np.arange(10, dtype="i8") * 24 * 3600 * 10**9,
  243:             (np.arange(10) * 24 * 3600 * 10**9).view("datetime64[ns]"),
  244:             pd.Timestamp("2021-01-01").to_period("D"),
  245:         ],
  246:     )
  247:     @pytest.mark.parametrize("index", [True, False])
  248:     def test_searchsorted_invalid_types(self, other, index):
  249:         data = np.arange(10, dtype="i8") * 24 * 3600 * 10**9
  250:         arr = pd.TimedeltaIndex(data, freq="D")._data
  251:         if index:
  252:             arr = pd.Index(arr)
  253: 
  254:         msg = "|".join(
  255:             [
  256:                 "searchsorted requires compatible dtype or scalar",
  257:                 "value should be a 'Timedelta', 'NaT', or array of those. Got",
  258:             ]
  259:         )
  260:         with pytest.raises(TypeError, match=msg):
  261:             arr.searchsorted(other)
  262: 
  263: 
  264: class TestUnaryOps:
  265:     def test_abs(self):
  266:         vals = np.array([-3600 * 10**9, "NaT", 7200 * 10**9], dtype="m8[ns]")
  267:         arr = TimedeltaArray._from_sequence(vals)
  268: 
  269:         evals = np.array([3600 * 10**9, "NaT", 7200 * 10**9], dtype="m8[ns]")
  270:         expected = TimedeltaArray._from_sequence(evals)
  271: 
  272:         result = abs(arr)
  273:         tm.assert_timedelta_array_equal(result, expected)
  274: 
  275:         result2 = np.abs(arr)
  276:         tm.assert_timedelta_array_equal(result2, expected)
  277: 
  278:     def test_pos(self):
  279:         vals = np.array([-3600 * 10**9, "NaT", 7200 * 10**9], dtype="m8[ns]")
  280:         arr = TimedeltaArray._from_sequence(vals)
  281: 
  282:         result = +arr
  283:         tm.assert_timedelta_array_equal(result, arr)
  284:         assert not tm.shares_memory(result, arr)
  285: 
  286:         result2 = np.positive(arr)
  287:         tm.assert_timedelta_array_equal(result2, arr)
  288:         assert not tm.shares_memory(result2, arr)
  289: 
  290:     def test_neg(self):
  291:         vals = np.array([-3600 * 10**9, "NaT", 7200 * 10**9], dtype="m8[ns]")
  292:         arr = TimedeltaArray._from_sequence(vals)
  293: 
  294:         evals = np.array([3600 * 10**9, "NaT", -7200 * 10**9], dtype="m8[ns]")
  295:         expected = TimedeltaArray._from_sequence(evals)
  296: 
  297:         result = -arr
  298:         tm.assert_timedelta_array_equal(result, expected)
  299: 
  300:         result2 = np.negative(arr)
  301:         tm.assert_timedelta_array_equal(result2, expected)
  302: 
  303:     def test_neg_freq(self):
  304:         tdi = pd.timedelta_range("2 Days", periods=4, freq="h")
  305:         arr = tdi._data
  306: 
  307:         expected = -tdi._data
  308: 
  309:         result = -arr
  310:         tm.assert_timedelta_array_equal(result, expected)
  311: 
  312:         result2 = np.negative(arr)
  313:         tm.assert_timedelta_array_equal(result2, expected)
