    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.compat import IS64
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: 
    9: 
   10: @pytest.mark.parametrize("ufunc", [np.abs, np.sign])
   11: # np.sign emits a warning with nans, <https://github.com/numpy/numpy/issues/15127>
   12: @pytest.mark.filterwarnings("ignore:invalid value encountered in sign:RuntimeWarning")
   13: def test_ufuncs_single(ufunc):
   14:     a = pd.array([1, 2, -3, np.nan], dtype="Float64")
   15:     result = ufunc(a)
   16:     expected = pd.array(ufunc(a.astype(float)), dtype="Float64")
   17:     tm.assert_extension_array_equal(result, expected)
   18: 
   19:     s = pd.Series(a)
   20:     result = ufunc(s)
   21:     expected = pd.Series(expected)
   22:     tm.assert_series_equal(result, expected)
   23: 
   24: 
   25: @pytest.mark.parametrize("ufunc", [np.log, np.exp, np.sin, np.cos, np.sqrt])
   26: def test_ufuncs_single_float(ufunc):
   27:     a = pd.array([1.0, 0.2, 3.0, np.nan], dtype="Float64")
   28:     with np.errstate(invalid="ignore"):
   29:         result = ufunc(a)
   30:         expected = pd.array(ufunc(a.astype(float)), dtype="Float64")
   31:     tm.assert_extension_array_equal(result, expected)
   32: 
   33:     s = pd.Series(a)
   34:     with np.errstate(invalid="ignore"):
   35:         result = ufunc(s)
   36:         expected = pd.Series(ufunc(s.astype(float)), dtype="Float64")
   37:     tm.assert_series_equal(result, expected)
   38: 
   39: 
   40: @pytest.mark.parametrize("ufunc", [np.add, np.subtract])
   41: def test_ufuncs_binary_float(ufunc):
   42:     # two FloatingArrays
   43:     a = pd.array([1, 0.2, -3, np.nan], dtype="Float64")
   44:     result = ufunc(a, a)
   45:     expected = pd.array(ufunc(a.astype(float), a.astype(float)), dtype="Float64")
   46:     tm.assert_extension_array_equal(result, expected)
   47: 
   48:     # FloatingArray with numpy array
   49:     arr = np.array([1, 2, 3, 4])
   50:     result = ufunc(a, arr)
   51:     expected = pd.array(ufunc(a.astype(float), arr), dtype="Float64")
   52:     tm.assert_extension_array_equal(result, expected)
   53: 
   54:     result = ufunc(arr, a)
   55:     expected = pd.array(ufunc(arr, a.astype(float)), dtype="Float64")
   56:     tm.assert_extension_array_equal(result, expected)
   57: 
   58:     # FloatingArray with scalar
   59:     result = ufunc(a, 1)
   60:     expected = pd.array(ufunc(a.astype(float), 1), dtype="Float64")
   61:     tm.assert_extension_array_equal(result, expected)
   62: 
   63:     result = ufunc(1, a)
   64:     expected = pd.array(ufunc(1, a.astype(float)), dtype="Float64")
   65:     tm.assert_extension_array_equal(result, expected)
   66: 
   67: 
   68: @pytest.mark.parametrize("values", [[0, 1], [0, None]])
   69: def test_ufunc_reduce_raises(values):
   70:     arr = pd.array(values, dtype="Float64")
   71: 
   72:     res = np.add.reduce(arr)
   73:     expected = arr.sum(skipna=False)
   74:     tm.assert_almost_equal(res, expected)
   75: 
   76: 
   77: @pytest.mark.skipif(not IS64, reason="GH 36579: fail on 32-bit system")
   78: @pytest.mark.parametrize(
   79:     "pandasmethname, kwargs",
   80:     [
   81:         ("var", {"ddof": 0}),
   82:         ("var", {"ddof": 1}),
   83:         ("std", {"ddof": 0}),
   84:         ("std", {"ddof": 1}),
   85:         ("kurtosis", {}),
   86:         ("skew", {}),
   87:         ("sem", {}),
   88:     ],
   89: )
   90: def test_stat_method(pandasmethname, kwargs):
   91:     s = pd.Series(data=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, np.nan, np.nan], dtype="Float64")
   92:     pandasmeth = getattr(s, pandasmethname)
   93:     result = pandasmeth(**kwargs)
   94:     s2 = pd.Series(data=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6], dtype="float64")
   95:     pandasmeth = getattr(s2, pandasmethname)
   96:     expected = pandasmeth(**kwargs)
   97:     assert expected == result
   98: 
   99: 
  100: def test_value_counts_na():
  101:     arr = pd.array([0.1, 0.2, 0.1, pd.NA], dtype="Float64")
  102:     result = arr.value_counts(dropna=False)
  103:     idx = pd.Index([0.1, 0.2, pd.NA], dtype=arr.dtype)
  104:     assert idx.dtype == arr.dtype
  105:     expected = pd.Series([2, 1, 1], index=idx, dtype="Int64", name="count")
  106:     tm.assert_series_equal(result, expected)
  107: 
  108:     result = arr.value_counts(dropna=True)
  109:     expected = pd.Series([2, 1], index=idx[:-1], dtype="Int64", name="count")
  110:     tm.assert_series_equal(result, expected)
  111: 
  112: 
  113: def test_value_counts_empty():
  114:     ser = pd.Series([], dtype="Float64")
  115:     result = ser.value_counts()
  116:     idx = pd.Index([], dtype="Float64")
  117:     assert idx.dtype == "Float64"
  118:     expected = pd.Series([], index=idx, dtype="Int64", name="count")
  119:     tm.assert_series_equal(result, expected)
  120: 
  121: 
  122: def test_value_counts_with_normalize():
  123:     ser = pd.Series([0.1, 0.2, 0.1, pd.NA], dtype="Float64")
  124:     result = ser.value_counts(normalize=True)
  125:     expected = pd.Series([2, 1], index=ser[:2], dtype="Float64", name="proportion") / 3
  126:     assert expected.index.dtype == ser.dtype
  127:     tm.assert_series_equal(result, expected)
  128: 
  129: 
  130: @pytest.mark.parametrize("skipna", [True, False])
  131: @pytest.mark.parametrize("min_count", [0, 4])
  132: def test_floating_array_sum(skipna, min_count, dtype):
  133:     arr = pd.array([1, 2, 3, None], dtype=dtype)
  134:     result = arr.sum(skipna=skipna, min_count=min_count)
  135:     if skipna and min_count == 0:
  136:         assert result == 6.0
  137:     else:
  138:         assert result is pd.NA
  139: 
  140: 
  141: @pytest.mark.parametrize(
  142:     "values, expected", [([1, 2, 3], 6.0), ([1, 2, 3, None], 6.0), ([None], 0.0)]
  143: )
  144: def test_floating_array_numpy_sum(values, expected):
  145:     arr = pd.array(values, dtype="Float64")
  146:     result = np.sum(arr)
  147:     assert result == expected
  148: 
  149: 
  150: @pytest.mark.parametrize("op", ["sum", "min", "max", "prod"])
  151: def test_preserve_dtypes(op):
  152:     df = pd.DataFrame(
  153:         {
  154:             "A": ["a", "b", "b"],
  155:             "B": [1, None, 3],
  156:             "C": pd.array([0.1, None, 3.0], dtype="Float64"),
  157:         }
  158:     )
  159: 
  160:     # op
  161:     result = getattr(df.C, op)()
  162:     assert isinstance(result, np.float64)
  163: 
  164:     # groupby
  165:     result = getattr(df.groupby("A"), op)()
  166: 
  167:     expected = pd.DataFrame(
  168:         {"B": np.array([1.0, 3.0]), "C": pd.array([0.1, 3], dtype="Float64")},
  169:         index=pd.Index(["a", "b"], name="A"),
  170:     )
  171:     tm.assert_frame_equal(result, expected)
  172: 
  173: 
  174: @pytest.mark.parametrize("skipna", [True, False])
  175: @pytest.mark.parametrize("method", ["min", "max"])
  176: def test_floating_array_min_max(skipna, method, dtype):
  177:     arr = pd.array([0.0, 1.0, None], dtype=dtype)
  178:     func = getattr(arr, method)
  179:     result = func(skipna=skipna)
  180:     if skipna:
  181:         assert result == (0 if method == "min" else 1)
  182:     else:
  183:         assert result is pd.NA
  184: 
  185: 
  186: @pytest.mark.parametrize("skipna", [True, False])
  187: @pytest.mark.parametrize("min_count", [0, 9])
  188: def test_floating_array_prod(skipna, min_count, dtype):
  189:     arr = pd.array([1.0, 2.0, None], dtype=dtype)
  190:     result = arr.prod(skipna=skipna, min_count=min_count)
  191:     if skipna and min_count == 0:
  192:         assert result == 2
  193:     else:
  194:         assert result is pd.NA
