    1: """
    2: Tests shared by MaskedArray subclasses.
    3: """
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas as pd
    8: import pandas._testing as tm
    9: from pandas.tests.extension.base import BaseOpsUtil
   10: 
   11: 
   12: class ComparisonOps(BaseOpsUtil):
   13:     def _compare_other(self, data, op, other):
   14:         # array
   15:         result = pd.Series(op(data, other))
   16:         expected = pd.Series(op(data._data, other), dtype="boolean")
   17: 
   18:         # fill the nan locations
   19:         expected[data._mask] = pd.NA
   20: 
   21:         tm.assert_series_equal(result, expected)
   22: 
   23:         # series
   24:         ser = pd.Series(data)
   25:         result = op(ser, other)
   26: 
   27:         # Set nullable dtype here to avoid upcasting when setting to pd.NA below
   28:         expected = op(pd.Series(data._data), other).astype("boolean")
   29: 
   30:         # fill the nan locations
   31:         expected[data._mask] = pd.NA
   32: 
   33:         tm.assert_series_equal(result, expected)
   34: 
   35:     # subclass will override to parametrize 'other'
   36:     def test_scalar(self, other, comparison_op, dtype):
   37:         op = comparison_op
   38:         left = pd.array([1, 0, None], dtype=dtype)
   39: 
   40:         result = op(left, other)
   41: 
   42:         if other is pd.NA:
   43:             expected = pd.array([None, None, None], dtype="boolean")
   44:         else:
   45:             values = op(left._data, other)
   46:             expected = pd.arrays.BooleanArray(values, left._mask, copy=True)
   47:         tm.assert_extension_array_equal(result, expected)
   48: 
   49:         # ensure we haven't mutated anything inplace
   50:         result[0] = pd.NA
   51:         tm.assert_extension_array_equal(left, pd.array([1, 0, None], dtype=dtype))
   52: 
   53: 
   54: class NumericOps:
   55:     # Shared by IntegerArray and FloatingArray, not BooleanArray
   56: 
   57:     def test_searchsorted_nan(self, dtype):
   58:         # The base class casts to object dtype, for which searchsorted returns
   59:         #  0 from the left and 10 from the right.
   60:         arr = pd.array(range(10), dtype=dtype)
   61: 
   62:         assert arr.searchsorted(np.nan, side="left") == 10
   63:         assert arr.searchsorted(np.nan, side="right") == 10
   64: 
   65:     def test_no_shared_mask(self, data):
   66:         result = data + 1
   67:         assert not tm.shares_memory(result, data)
   68: 
   69:     def test_array(self, comparison_op, dtype):
   70:         op = comparison_op
   71: 
   72:         left = pd.array([0, 1, 2, None, None, None], dtype=dtype)
   73:         right = pd.array([0, 1, None, 0, 1, None], dtype=dtype)
   74: 
   75:         result = op(left, right)
   76:         values = op(left._data, right._data)
   77:         mask = left._mask | right._mask
   78: 
   79:         expected = pd.arrays.BooleanArray(values, mask)
   80:         tm.assert_extension_array_equal(result, expected)
   81: 
   82:         # ensure we haven't mutated anything inplace
   83:         result[0] = pd.NA
   84:         tm.assert_extension_array_equal(
   85:             left, pd.array([0, 1, 2, None, None, None], dtype=dtype)
   86:         )
   87:         tm.assert_extension_array_equal(
   88:             right, pd.array([0, 1, None, 0, 1, None], dtype=dtype)
   89:         )
   90: 
   91:     def test_compare_with_booleanarray(self, comparison_op, dtype):
   92:         op = comparison_op
   93: 
   94:         left = pd.array([True, False, None] * 3, dtype="boolean")
   95:         right = pd.array([0] * 3 + [1] * 3 + [None] * 3, dtype=dtype)
   96:         other = pd.array([False] * 3 + [True] * 3 + [None] * 3, dtype="boolean")
   97: 
   98:         expected = op(left, other)
   99:         result = op(left, right)
  100:         tm.assert_extension_array_equal(result, expected)
  101: 
  102:         # reversed op
  103:         expected = op(other, left)
  104:         result = op(right, left)
  105:         tm.assert_extension_array_equal(result, expected)
  106: 
  107:     def test_compare_to_string(self, dtype):
  108:         # GH#28930
  109:         ser = pd.Series([1, None], dtype=dtype)
  110:         result = ser == "a"
  111:         expected = pd.Series([False, pd.NA], dtype="boolean")
  112: 
  113:         tm.assert_series_equal(result, expected)
  114: 
  115:     def test_ufunc_with_out(self, dtype):
  116:         arr = pd.array([1, 2, 3], dtype=dtype)
  117:         arr2 = pd.array([1, 2, pd.NA], dtype=dtype)
  118: 
  119:         mask = arr == arr
  120:         mask2 = arr2 == arr2
  121: 
  122:         result = np.zeros(3, dtype=bool)
  123:         result |= mask
  124:         # If MaskedArray.__array_ufunc__ handled "out" appropriately,
  125:         #  `result` should still be an ndarray.
  126:         assert isinstance(result, np.ndarray)
  127:         assert result.all()
  128: 
  129:         # result |= mask worked because mask could be cast losslessly to
  130:         #  boolean ndarray. mask2 can't, so this raises
  131:         result = np.zeros(3, dtype=bool)
  132:         msg = "Specify an appropriate 'na_value' for this dtype"
  133:         with pytest.raises(ValueError, match=msg):
  134:             result |= mask2
  135: 
  136:         # addition
  137:         res = np.add(arr, arr2)
  138:         expected = pd.array([2, 4, pd.NA], dtype=dtype)
  139:         tm.assert_extension_array_equal(res, expected)
  140: 
  141:         # when passing out=arr, we will modify 'arr' inplace.
  142:         res = np.add(arr, arr2, out=arr)
  143:         assert res is arr
  144:         tm.assert_extension_array_equal(res, expected)
  145:         tm.assert_extension_array_equal(arr, expected)
  146: 
  147:     def test_mul_td64_array(self, dtype):
  148:         # GH#45622
  149:         arr = pd.array([1, 2, pd.NA], dtype=dtype)
  150:         other = np.arange(3, dtype=np.int64).view("m8[ns]")
  151: 
  152:         result = arr * other
  153:         expected = pd.array([pd.Timedelta(0), pd.Timedelta(2), pd.NaT])
  154:         tm.assert_extension_array_equal(result, expected)
