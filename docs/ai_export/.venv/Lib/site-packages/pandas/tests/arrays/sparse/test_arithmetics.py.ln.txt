    1: import operator
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import SparseDtype
    8: import pandas._testing as tm
    9: from pandas.core.arrays.sparse import SparseArray
   10: 
   11: 
   12: @pytest.fixture(params=["integer", "block"])
   13: def kind(request):
   14:     """kind kwarg to pass to SparseArray"""
   15:     return request.param
   16: 
   17: 
   18: @pytest.fixture(params=[True, False])
   19: def mix(request):
   20:     """
   21:     Fixture returning True or False, determining whether to operate
   22:     op(sparse, dense) instead of op(sparse, sparse)
   23:     """
   24:     return request.param
   25: 
   26: 
   27: class TestSparseArrayArithmetics:
   28:     def _assert(self, a, b):
   29:         # We have to use tm.assert_sp_array_equal. See GH #45126
   30:         tm.assert_numpy_array_equal(a, b)
   31: 
   32:     def _check_numeric_ops(self, a, b, a_dense, b_dense, mix: bool, op):
   33:         # Check that arithmetic behavior matches non-Sparse Series arithmetic
   34: 
   35:         if isinstance(a_dense, np.ndarray):
   36:             expected = op(pd.Series(a_dense), b_dense).values
   37:         elif isinstance(b_dense, np.ndarray):
   38:             expected = op(a_dense, pd.Series(b_dense)).values
   39:         else:
   40:             raise NotImplementedError
   41: 
   42:         with np.errstate(invalid="ignore", divide="ignore"):
   43:             if mix:
   44:                 result = op(a, b_dense).to_dense()
   45:             else:
   46:                 result = op(a, b).to_dense()
   47: 
   48:         self._assert(result, expected)
   49: 
   50:     def _check_bool_result(self, res):
   51:         assert isinstance(res, SparseArray)
   52:         assert isinstance(res.dtype, SparseDtype)
   53:         assert res.dtype.subtype == np.bool_
   54:         assert isinstance(res.fill_value, bool)
   55: 
   56:     def _check_comparison_ops(self, a, b, a_dense, b_dense):
   57:         with np.errstate(invalid="ignore"):
   58:             # Unfortunately, trying to wrap the computation of each expected
   59:             # value is with np.errstate() is too tedious.
   60:             #
   61:             # sparse & sparse
   62:             self._check_bool_result(a == b)
   63:             self._assert((a == b).to_dense(), a_dense == b_dense)
   64: 
   65:             self._check_bool_result(a != b)
   66:             self._assert((a != b).to_dense(), a_dense != b_dense)
   67: 
   68:             self._check_bool_result(a >= b)
   69:             self._assert((a >= b).to_dense(), a_dense >= b_dense)
   70: 
   71:             self._check_bool_result(a <= b)
   72:             self._assert((a <= b).to_dense(), a_dense <= b_dense)
   73: 
   74:             self._check_bool_result(a > b)
   75:             self._assert((a > b).to_dense(), a_dense > b_dense)
   76: 
   77:             self._check_bool_result(a < b)
   78:             self._assert((a < b).to_dense(), a_dense < b_dense)
   79: 
   80:             # sparse & dense
   81:             self._check_bool_result(a == b_dense)
   82:             self._assert((a == b_dense).to_dense(), a_dense == b_dense)
   83: 
   84:             self._check_bool_result(a != b_dense)
   85:             self._assert((a != b_dense).to_dense(), a_dense != b_dense)
   86: 
   87:             self._check_bool_result(a >= b_dense)
   88:             self._assert((a >= b_dense).to_dense(), a_dense >= b_dense)
   89: 
   90:             self._check_bool_result(a <= b_dense)
   91:             self._assert((a <= b_dense).to_dense(), a_dense <= b_dense)
   92: 
   93:             self._check_bool_result(a > b_dense)
   94:             self._assert((a > b_dense).to_dense(), a_dense > b_dense)
   95: 
   96:             self._check_bool_result(a < b_dense)
   97:             self._assert((a < b_dense).to_dense(), a_dense < b_dense)
   98: 
   99:     def _check_logical_ops(self, a, b, a_dense, b_dense):
  100:         # sparse & sparse
  101:         self._check_bool_result(a & b)
  102:         self._assert((a & b).to_dense(), a_dense & b_dense)
  103: 
  104:         self._check_bool_result(a | b)
  105:         self._assert((a | b).to_dense(), a_dense | b_dense)
  106:         # sparse & dense
  107:         self._check_bool_result(a & b_dense)
  108:         self._assert((a & b_dense).to_dense(), a_dense & b_dense)
  109: 
  110:         self._check_bool_result(a | b_dense)
  111:         self._assert((a | b_dense).to_dense(), a_dense | b_dense)
  112: 
  113:     @pytest.mark.parametrize("scalar", [0, 1, 3])
  114:     @pytest.mark.parametrize("fill_value", [None, 0, 2])
  115:     def test_float_scalar(
  116:         self, kind, mix, all_arithmetic_functions, fill_value, scalar, request
  117:     ):
  118:         op = all_arithmetic_functions
  119:         values = np.array([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
  120:         a = SparseArray(values, kind=kind, fill_value=fill_value)
  121:         self._check_numeric_ops(a, scalar, values, scalar, mix, op)
  122: 
  123:     def test_float_scalar_comparison(self, kind):
  124:         values = np.array([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
  125: 
  126:         a = SparseArray(values, kind=kind)
  127:         self._check_comparison_ops(a, 1, values, 1)
  128:         self._check_comparison_ops(a, 0, values, 0)
  129:         self._check_comparison_ops(a, 3, values, 3)
  130: 
  131:         a = SparseArray(values, kind=kind, fill_value=0)
  132:         self._check_comparison_ops(a, 1, values, 1)
  133:         self._check_comparison_ops(a, 0, values, 0)
  134:         self._check_comparison_ops(a, 3, values, 3)
  135: 
  136:         a = SparseArray(values, kind=kind, fill_value=2)
  137:         self._check_comparison_ops(a, 1, values, 1)
  138:         self._check_comparison_ops(a, 0, values, 0)
  139:         self._check_comparison_ops(a, 3, values, 3)
  140: 
  141:     def test_float_same_index_without_nans(self, kind, mix, all_arithmetic_functions):
  142:         # when sp_index are the same
  143:         op = all_arithmetic_functions
  144: 
  145:         values = np.array([0.0, 1.0, 2.0, 6.0, 0.0, 0.0, 1.0, 2.0, 1.0, 0.0])
  146:         rvalues = np.array([0.0, 2.0, 3.0, 4.0, 0.0, 0.0, 1.0, 3.0, 2.0, 0.0])
  147: 
  148:         a = SparseArray(values, kind=kind, fill_value=0)
  149:         b = SparseArray(rvalues, kind=kind, fill_value=0)
  150:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  151: 
  152:     def test_float_same_index_with_nans(
  153:         self, kind, mix, all_arithmetic_functions, request
  154:     ):
  155:         # when sp_index are the same
  156:         op = all_arithmetic_functions
  157:         values = np.array([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
  158:         rvalues = np.array([np.nan, 2, 3, 4, np.nan, 0, 1, 3, 2, np.nan])
  159: 
  160:         a = SparseArray(values, kind=kind)
  161:         b = SparseArray(rvalues, kind=kind)
  162:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  163: 
  164:     def test_float_same_index_comparison(self, kind):
  165:         # when sp_index are the same
  166:         values = np.array([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
  167:         rvalues = np.array([np.nan, 2, 3, 4, np.nan, 0, 1, 3, 2, np.nan])
  168: 
  169:         a = SparseArray(values, kind=kind)
  170:         b = SparseArray(rvalues, kind=kind)
  171:         self._check_comparison_ops(a, b, values, rvalues)
  172: 
  173:         values = np.array([0.0, 1.0, 2.0, 6.0, 0.0, 0.0, 1.0, 2.0, 1.0, 0.0])
  174:         rvalues = np.array([0.0, 2.0, 3.0, 4.0, 0.0, 0.0, 1.0, 3.0, 2.0, 0.0])
  175: 
  176:         a = SparseArray(values, kind=kind, fill_value=0)
  177:         b = SparseArray(rvalues, kind=kind, fill_value=0)
  178:         self._check_comparison_ops(a, b, values, rvalues)
  179: 
  180:     def test_float_array(self, kind, mix, all_arithmetic_functions):
  181:         op = all_arithmetic_functions
  182: 
  183:         values = np.array([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
  184:         rvalues = np.array([2, np.nan, 2, 3, np.nan, 0, 1, 5, 2, np.nan])
  185: 
  186:         a = SparseArray(values, kind=kind)
  187:         b = SparseArray(rvalues, kind=kind)
  188:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  189:         self._check_numeric_ops(a, b * 0, values, rvalues * 0, mix, op)
  190: 
  191:         a = SparseArray(values, kind=kind, fill_value=0)
  192:         b = SparseArray(rvalues, kind=kind)
  193:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  194: 
  195:         a = SparseArray(values, kind=kind, fill_value=0)
  196:         b = SparseArray(rvalues, kind=kind, fill_value=0)
  197:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  198: 
  199:         a = SparseArray(values, kind=kind, fill_value=1)
  200:         b = SparseArray(rvalues, kind=kind, fill_value=2)
  201:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  202: 
  203:     def test_float_array_different_kind(self, mix, all_arithmetic_functions):
  204:         op = all_arithmetic_functions
  205: 
  206:         values = np.array([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
  207:         rvalues = np.array([2, np.nan, 2, 3, np.nan, 0, 1, 5, 2, np.nan])
  208: 
  209:         a = SparseArray(values, kind="integer")
  210:         b = SparseArray(rvalues, kind="block")
  211:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  212:         self._check_numeric_ops(a, b * 0, values, rvalues * 0, mix, op)
  213: 
  214:         a = SparseArray(values, kind="integer", fill_value=0)
  215:         b = SparseArray(rvalues, kind="block")
  216:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  217: 
  218:         a = SparseArray(values, kind="integer", fill_value=0)
  219:         b = SparseArray(rvalues, kind="block", fill_value=0)
  220:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  221: 
  222:         a = SparseArray(values, kind="integer", fill_value=1)
  223:         b = SparseArray(rvalues, kind="block", fill_value=2)
  224:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  225: 
  226:     def test_float_array_comparison(self, kind):
  227:         values = np.array([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
  228:         rvalues = np.array([2, np.nan, 2, 3, np.nan, 0, 1, 5, 2, np.nan])
  229: 
  230:         a = SparseArray(values, kind=kind)
  231:         b = SparseArray(rvalues, kind=kind)
  232:         self._check_comparison_ops(a, b, values, rvalues)
  233:         self._check_comparison_ops(a, b * 0, values, rvalues * 0)
  234: 
  235:         a = SparseArray(values, kind=kind, fill_value=0)
  236:         b = SparseArray(rvalues, kind=kind)
  237:         self._check_comparison_ops(a, b, values, rvalues)
  238: 
  239:         a = SparseArray(values, kind=kind, fill_value=0)
  240:         b = SparseArray(rvalues, kind=kind, fill_value=0)
  241:         self._check_comparison_ops(a, b, values, rvalues)
  242: 
  243:         a = SparseArray(values, kind=kind, fill_value=1)
  244:         b = SparseArray(rvalues, kind=kind, fill_value=2)
  245:         self._check_comparison_ops(a, b, values, rvalues)
  246: 
  247:     def test_int_array(self, kind, mix, all_arithmetic_functions):
  248:         op = all_arithmetic_functions
  249: 
  250:         # have to specify dtype explicitly until fixing GH 667
  251:         dtype = np.int64
  252: 
  253:         values = np.array([0, 1, 2, 0, 0, 0, 1, 2, 1, 0], dtype=dtype)
  254:         rvalues = np.array([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=dtype)
  255: 
  256:         a = SparseArray(values, dtype=dtype, kind=kind)
  257:         assert a.dtype == SparseDtype(dtype)
  258:         b = SparseArray(rvalues, dtype=dtype, kind=kind)
  259:         assert b.dtype == SparseDtype(dtype)
  260: 
  261:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  262:         self._check_numeric_ops(a, b * 0, values, rvalues * 0, mix, op)
  263: 
  264:         a = SparseArray(values, fill_value=0, dtype=dtype, kind=kind)
  265:         assert a.dtype == SparseDtype(dtype)
  266:         b = SparseArray(rvalues, dtype=dtype, kind=kind)
  267:         assert b.dtype == SparseDtype(dtype)
  268: 
  269:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  270: 
  271:         a = SparseArray(values, fill_value=0, dtype=dtype, kind=kind)
  272:         assert a.dtype == SparseDtype(dtype)
  273:         b = SparseArray(rvalues, fill_value=0, dtype=dtype, kind=kind)
  274:         assert b.dtype == SparseDtype(dtype)
  275:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  276: 
  277:         a = SparseArray(values, fill_value=1, dtype=dtype, kind=kind)
  278:         assert a.dtype == SparseDtype(dtype, fill_value=1)
  279:         b = SparseArray(rvalues, fill_value=2, dtype=dtype, kind=kind)
  280:         assert b.dtype == SparseDtype(dtype, fill_value=2)
  281:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  282: 
  283:     def test_int_array_comparison(self, kind):
  284:         dtype = "int64"
  285:         # int32 NI ATM
  286: 
  287:         values = np.array([0, 1, 2, 0, 0, 0, 1, 2, 1, 0], dtype=dtype)
  288:         rvalues = np.array([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=dtype)
  289: 
  290:         a = SparseArray(values, dtype=dtype, kind=kind)
  291:         b = SparseArray(rvalues, dtype=dtype, kind=kind)
  292:         self._check_comparison_ops(a, b, values, rvalues)
  293:         self._check_comparison_ops(a, b * 0, values, rvalues * 0)
  294: 
  295:         a = SparseArray(values, dtype=dtype, kind=kind, fill_value=0)
  296:         b = SparseArray(rvalues, dtype=dtype, kind=kind)
  297:         self._check_comparison_ops(a, b, values, rvalues)
  298: 
  299:         a = SparseArray(values, dtype=dtype, kind=kind, fill_value=0)
  300:         b = SparseArray(rvalues, dtype=dtype, kind=kind, fill_value=0)
  301:         self._check_comparison_ops(a, b, values, rvalues)
  302: 
  303:         a = SparseArray(values, dtype=dtype, kind=kind, fill_value=1)
  304:         b = SparseArray(rvalues, dtype=dtype, kind=kind, fill_value=2)
  305:         self._check_comparison_ops(a, b, values, rvalues)
  306: 
  307:     @pytest.mark.parametrize("fill_value", [True, False, np.nan])
  308:     def test_bool_same_index(self, kind, fill_value):
  309:         # GH 14000
  310:         # when sp_index are the same
  311:         values = np.array([True, False, True, True], dtype=np.bool_)
  312:         rvalues = np.array([True, False, True, True], dtype=np.bool_)
  313: 
  314:         a = SparseArray(values, kind=kind, dtype=np.bool_, fill_value=fill_value)
  315:         b = SparseArray(rvalues, kind=kind, dtype=np.bool_, fill_value=fill_value)
  316:         self._check_logical_ops(a, b, values, rvalues)
  317: 
  318:     @pytest.mark.parametrize("fill_value", [True, False, np.nan])
  319:     def test_bool_array_logical(self, kind, fill_value):
  320:         # GH 14000
  321:         # when sp_index are the same
  322:         values = np.array([True, False, True, False, True, True], dtype=np.bool_)
  323:         rvalues = np.array([True, False, False, True, False, True], dtype=np.bool_)
  324: 
  325:         a = SparseArray(values, kind=kind, dtype=np.bool_, fill_value=fill_value)
  326:         b = SparseArray(rvalues, kind=kind, dtype=np.bool_, fill_value=fill_value)
  327:         self._check_logical_ops(a, b, values, rvalues)
  328: 
  329:     def test_mixed_array_float_int(self, kind, mix, all_arithmetic_functions, request):
  330:         op = all_arithmetic_functions
  331:         rdtype = "int64"
  332:         values = np.array([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
  333:         rvalues = np.array([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=rdtype)
  334: 
  335:         a = SparseArray(values, kind=kind)
  336:         b = SparseArray(rvalues, kind=kind)
  337:         assert b.dtype == SparseDtype(rdtype)
  338: 
  339:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  340:         self._check_numeric_ops(a, b * 0, values, rvalues * 0, mix, op)
  341: 
  342:         a = SparseArray(values, kind=kind, fill_value=0)
  343:         b = SparseArray(rvalues, kind=kind)
  344:         assert b.dtype == SparseDtype(rdtype)
  345:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  346: 
  347:         a = SparseArray(values, kind=kind, fill_value=0)
  348:         b = SparseArray(rvalues, kind=kind, fill_value=0)
  349:         assert b.dtype == SparseDtype(rdtype)
  350:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  351: 
  352:         a = SparseArray(values, kind=kind, fill_value=1)
  353:         b = SparseArray(rvalues, kind=kind, fill_value=2)
  354:         assert b.dtype == SparseDtype(rdtype, fill_value=2)
  355:         self._check_numeric_ops(a, b, values, rvalues, mix, op)
  356: 
  357:     def test_mixed_array_comparison(self, kind):
  358:         rdtype = "int64"
  359:         # int32 NI ATM
  360: 
  361:         values = np.array([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
  362:         rvalues = np.array([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=rdtype)
  363: 
  364:         a = SparseArray(values, kind=kind)
  365:         b = SparseArray(rvalues, kind=kind)
  366:         assert b.dtype == SparseDtype(rdtype)
  367: 
  368:         self._check_comparison_ops(a, b, values, rvalues)
  369:         self._check_comparison_ops(a, b * 0, values, rvalues * 0)
  370: 
  371:         a = SparseArray(values, kind=kind, fill_value=0)
  372:         b = SparseArray(rvalues, kind=kind)
  373:         assert b.dtype == SparseDtype(rdtype)
  374:         self._check_comparison_ops(a, b, values, rvalues)
  375: 
  376:         a = SparseArray(values, kind=kind, fill_value=0)
  377:         b = SparseArray(rvalues, kind=kind, fill_value=0)
  378:         assert b.dtype == SparseDtype(rdtype)
  379:         self._check_comparison_ops(a, b, values, rvalues)
  380: 
  381:         a = SparseArray(values, kind=kind, fill_value=1)
  382:         b = SparseArray(rvalues, kind=kind, fill_value=2)
  383:         assert b.dtype == SparseDtype(rdtype, fill_value=2)
  384:         self._check_comparison_ops(a, b, values, rvalues)
  385: 
  386:     def test_xor(self):
  387:         s = SparseArray([True, True, False, False])
  388:         t = SparseArray([True, False, True, False])
  389:         result = s ^ t
  390:         sp_index = pd.core.arrays.sparse.IntIndex(4, np.array([0, 1, 2], dtype="int32"))
  391:         expected = SparseArray([False, True, True], sparse_index=sp_index)
  392:         tm.assert_sp_array_equal(result, expected)
  393: 
  394: 
  395: @pytest.mark.parametrize("op", [operator.eq, operator.add])
  396: def test_with_list(op):
  397:     arr = SparseArray([0, 1], fill_value=0)
  398:     result = op(arr, [0, 1])
  399:     expected = op(arr, SparseArray([0, 1]))
  400:     tm.assert_sp_array_equal(result, expected)
  401: 
  402: 
  403: def test_with_dataframe():
  404:     # GH#27910
  405:     arr = SparseArray([0, 1], fill_value=0)
  406:     df = pd.DataFrame([[1, 2], [3, 4]])
  407:     result = arr.__add__(df)
  408:     assert result is NotImplemented
  409: 
  410: 
  411: def test_with_zerodim_ndarray():
  412:     # GH#27910
  413:     arr = SparseArray([0, 1], fill_value=0)
  414: 
  415:     result = arr * np.array(2)
  416:     expected = arr * 2
  417:     tm.assert_sp_array_equal(result, expected)
  418: 
  419: 
  420: @pytest.mark.parametrize("ufunc", [np.abs, np.exp])
  421: @pytest.mark.parametrize(
  422:     "arr", [SparseArray([0, 0, -1, 1]), SparseArray([None, None, -1, 1])]
  423: )
  424: def test_ufuncs(ufunc, arr):
  425:     result = ufunc(arr)
  426:     fill_value = ufunc(arr.fill_value)
  427:     expected = SparseArray(ufunc(np.asarray(arr)), fill_value=fill_value)
  428:     tm.assert_sp_array_equal(result, expected)
  429: 
  430: 
  431: @pytest.mark.parametrize(
  432:     "a, b",
  433:     [
  434:         (SparseArray([0, 0, 0]), np.array([0, 1, 2])),
  435:         (SparseArray([0, 0, 0], fill_value=1), np.array([0, 1, 2])),
  436:         (SparseArray([0, 0, 0], fill_value=1), np.array([0, 1, 2])),
  437:         (SparseArray([0, 0, 0], fill_value=1), np.array([0, 1, 2])),
  438:         (SparseArray([0, 0, 0], fill_value=1), np.array([0, 1, 2])),
  439:     ],
  440: )
  441: @pytest.mark.parametrize("ufunc", [np.add, np.greater])
  442: def test_binary_ufuncs(ufunc, a, b):
  443:     # can't say anything about fill value here.
  444:     result = ufunc(a, b)
  445:     expected = ufunc(np.asarray(a), np.asarray(b))
  446:     assert isinstance(result, SparseArray)
  447:     tm.assert_numpy_array_equal(np.asarray(result), expected)
  448: 
  449: 
  450: def test_ndarray_inplace():
  451:     sparray = SparseArray([0, 2, 0, 0])
  452:     ndarray = np.array([0, 1, 2, 3])
  453:     ndarray += sparray
  454:     expected = np.array([0, 3, 2, 3])
  455:     tm.assert_numpy_array_equal(ndarray, expected)
  456: 
  457: 
  458: def test_sparray_inplace():
  459:     sparray = SparseArray([0, 2, 0, 0])
  460:     ndarray = np.array([0, 1, 2, 3])
  461:     sparray += ndarray
  462:     expected = SparseArray([0, 3, 2, 3], fill_value=0)
  463:     tm.assert_sp_array_equal(sparray, expected)
  464: 
  465: 
  466: @pytest.mark.parametrize("cons", [list, np.array, SparseArray])
  467: def test_mismatched_length_cmp_op(cons):
  468:     left = SparseArray([True, True])
  469:     right = cons([True, True, True])
  470:     with pytest.raises(ValueError, match="operands have mismatched length"):
  471:         left & right
  472: 
  473: 
  474: @pytest.mark.parametrize("op", ["add", "sub", "mul", "truediv", "floordiv", "pow"])
  475: @pytest.mark.parametrize("fill_value", [np.nan, 3])
  476: def test_binary_operators(op, fill_value):
  477:     op = getattr(operator, op)
  478:     data1 = np.random.default_rng(2).standard_normal(20)
  479:     data2 = np.random.default_rng(2).standard_normal(20)
  480: 
  481:     data1[::2] = fill_value
  482:     data2[::3] = fill_value
  483: 
  484:     first = SparseArray(data1, fill_value=fill_value)
  485:     second = SparseArray(data2, fill_value=fill_value)
  486: 
  487:     with np.errstate(all="ignore"):
  488:         res = op(first, second)
  489:         exp = SparseArray(
  490:             op(first.to_dense(), second.to_dense()), fill_value=first.fill_value
  491:         )
  492:         assert isinstance(res, SparseArray)
  493:         tm.assert_almost_equal(res.to_dense(), exp.to_dense())
  494: 
  495:         res2 = op(first, second.to_dense())
  496:         assert isinstance(res2, SparseArray)
  497:         tm.assert_sp_array_equal(res, res2)
  498: 
  499:         res3 = op(first.to_dense(), second)
  500:         assert isinstance(res3, SparseArray)
  501:         tm.assert_sp_array_equal(res, res3)
  502: 
  503:         res4 = op(first, 4)
  504:         assert isinstance(res4, SparseArray)
  505: 
  506:         # Ignore this if the actual op raises (e.g. pow).
  507:         try:
  508:             exp = op(first.to_dense(), 4)
  509:             exp_fv = op(first.fill_value, 4)
  510:         except ValueError:
  511:             pass
  512:         else:
  513:             tm.assert_almost_equal(res4.fill_value, exp_fv)
  514:             tm.assert_almost_equal(res4.to_dense(), exp)
