    1: from __future__ import annotations
    2: 
    3: from typing import Any
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: import pandas as pd
    9: import pandas._testing as tm
   10: 
   11: # integer dtypes
   12: arrays = [pd.array([1, 2, 3, None], dtype=dtype) for dtype in tm.ALL_INT_EA_DTYPES]
   13: scalars: list[Any] = [2] * len(arrays)
   14: # floating dtypes
   15: arrays += [pd.array([0.1, 0.2, 0.3, None], dtype=dtype) for dtype in tm.FLOAT_EA_DTYPES]
   16: scalars += [0.2, 0.2]
   17: # boolean
   18: arrays += [pd.array([True, False, True, None], dtype="boolean")]
   19: scalars += [False]
   20: 
   21: 
   22: @pytest.fixture(params=zip(arrays, scalars), ids=[a.dtype.name for a in arrays])
   23: def data(request):
   24:     """Fixture returning parametrized (array, scalar) tuple.
   25: 
   26:     Used to test equivalence of scalars, numpy arrays with array ops, and the
   27:     equivalence of DataFrame and Series ops.
   28:     """
   29:     return request.param
   30: 
   31: 
   32: def check_skip(data, op_name):
   33:     if isinstance(data.dtype, pd.BooleanDtype) and "sub" in op_name:
   34:         pytest.skip("subtract not implemented for boolean")
   35: 
   36: 
   37: def is_bool_not_implemented(data, op_name):
   38:     # match non-masked behavior
   39:     return data.dtype.kind == "b" and op_name.strip("_").lstrip("r") in [
   40:         "pow",
   41:         "truediv",
   42:         "floordiv",
   43:     ]
   44: 
   45: 
   46: # Test equivalence of scalars, numpy arrays with array ops
   47: # -----------------------------------------------------------------------------
   48: 
   49: 
   50: def test_array_scalar_like_equivalence(data, all_arithmetic_operators):
   51:     data, scalar = data
   52:     op = tm.get_op_from_name(all_arithmetic_operators)
   53:     check_skip(data, all_arithmetic_operators)
   54: 
   55:     scalar_array = pd.array([scalar] * len(data), dtype=data.dtype)
   56: 
   57:     # TODO also add len-1 array (np.array([scalar], dtype=data.dtype.numpy_dtype))
   58:     for scalar in [scalar, data.dtype.type(scalar)]:
   59:         if is_bool_not_implemented(data, all_arithmetic_operators):
   60:             msg = "operator '.*' not implemented for bool dtypes"
   61:             with pytest.raises(NotImplementedError, match=msg):
   62:                 op(data, scalar)
   63:             with pytest.raises(NotImplementedError, match=msg):
   64:                 op(data, scalar_array)
   65:         else:
   66:             result = op(data, scalar)
   67:             expected = op(data, scalar_array)
   68:             tm.assert_extension_array_equal(result, expected)
   69: 
   70: 
   71: def test_array_NA(data, all_arithmetic_operators):
   72:     data, _ = data
   73:     op = tm.get_op_from_name(all_arithmetic_operators)
   74:     check_skip(data, all_arithmetic_operators)
   75: 
   76:     scalar = pd.NA
   77:     scalar_array = pd.array([pd.NA] * len(data), dtype=data.dtype)
   78: 
   79:     mask = data._mask.copy()
   80: 
   81:     if is_bool_not_implemented(data, all_arithmetic_operators):
   82:         msg = "operator '.*' not implemented for bool dtypes"
   83:         with pytest.raises(NotImplementedError, match=msg):
   84:             op(data, scalar)
   85:         # GH#45421 check op doesn't alter data._mask inplace
   86:         tm.assert_numpy_array_equal(mask, data._mask)
   87:         return
   88: 
   89:     result = op(data, scalar)
   90:     # GH#45421 check op doesn't alter data._mask inplace
   91:     tm.assert_numpy_array_equal(mask, data._mask)
   92: 
   93:     expected = op(data, scalar_array)
   94:     tm.assert_numpy_array_equal(mask, data._mask)
   95: 
   96:     tm.assert_extension_array_equal(result, expected)
   97: 
   98: 
   99: def test_numpy_array_equivalence(data, all_arithmetic_operators):
  100:     data, scalar = data
  101:     op = tm.get_op_from_name(all_arithmetic_operators)
  102:     check_skip(data, all_arithmetic_operators)
  103: 
  104:     numpy_array = np.array([scalar] * len(data), dtype=data.dtype.numpy_dtype)
  105:     pd_array = pd.array(numpy_array, dtype=data.dtype)
  106: 
  107:     if is_bool_not_implemented(data, all_arithmetic_operators):
  108:         msg = "operator '.*' not implemented for bool dtypes"
  109:         with pytest.raises(NotImplementedError, match=msg):
  110:             op(data, numpy_array)
  111:         with pytest.raises(NotImplementedError, match=msg):
  112:             op(data, pd_array)
  113:         return
  114: 
  115:     result = op(data, numpy_array)
  116:     expected = op(data, pd_array)
  117:     tm.assert_extension_array_equal(result, expected)
  118: 
  119: 
  120: # Test equivalence with Series and DataFrame ops
  121: # -----------------------------------------------------------------------------
  122: 
  123: 
  124: def test_frame(data, all_arithmetic_operators):
  125:     data, scalar = data
  126:     op = tm.get_op_from_name(all_arithmetic_operators)
  127:     check_skip(data, all_arithmetic_operators)
  128: 
  129:     # DataFrame with scalar
  130:     df = pd.DataFrame({"A": data})
  131: 
  132:     if is_bool_not_implemented(data, all_arithmetic_operators):
  133:         msg = "operator '.*' not implemented for bool dtypes"
  134:         with pytest.raises(NotImplementedError, match=msg):
  135:             op(df, scalar)
  136:         with pytest.raises(NotImplementedError, match=msg):
  137:             op(data, scalar)
  138:         return
  139: 
  140:     result = op(df, scalar)
  141:     expected = pd.DataFrame({"A": op(data, scalar)})
  142:     tm.assert_frame_equal(result, expected)
  143: 
  144: 
  145: def test_series(data, all_arithmetic_operators):
  146:     data, scalar = data
  147:     op = tm.get_op_from_name(all_arithmetic_operators)
  148:     check_skip(data, all_arithmetic_operators)
  149: 
  150:     ser = pd.Series(data)
  151: 
  152:     others = [
  153:         scalar,
  154:         np.array([scalar] * len(data), dtype=data.dtype.numpy_dtype),
  155:         pd.array([scalar] * len(data), dtype=data.dtype),
  156:         pd.Series([scalar] * len(data), dtype=data.dtype),
  157:     ]
  158: 
  159:     for other in others:
  160:         if is_bool_not_implemented(data, all_arithmetic_operators):
  161:             msg = "operator '.*' not implemented for bool dtypes"
  162:             with pytest.raises(NotImplementedError, match=msg):
  163:                 op(ser, other)
  164: 
  165:         else:
  166:             result = op(ser, other)
  167:             expected = pd.Series(op(data, other))
  168:             tm.assert_series_equal(result, expected)
  169: 
  170: 
  171: # Test generic characteristics / errors
  172: # -----------------------------------------------------------------------------
  173: 
  174: 
  175: def test_error_invalid_object(data, all_arithmetic_operators):
  176:     data, _ = data
  177: 
  178:     op = all_arithmetic_operators
  179:     opa = getattr(data, op)
  180: 
  181:     # 2d -> return NotImplemented
  182:     result = opa(pd.DataFrame({"A": data}))
  183:     assert result is NotImplemented
  184: 
  185:     msg = r"can only perform ops with 1-d structures"
  186:     with pytest.raises(NotImplementedError, match=msg):
  187:         opa(np.arange(len(data)).reshape(-1, len(data)))
  188: 
  189: 
  190: def test_error_len_mismatch(data, all_arithmetic_operators):
  191:     # operating with a list-like with non-matching length raises
  192:     data, scalar = data
  193:     op = tm.get_op_from_name(all_arithmetic_operators)
  194: 
  195:     other = [scalar] * (len(data) - 1)
  196: 
  197:     err = ValueError
  198:     msg = "|".join(
  199:         [
  200:             r"operands could not be broadcast together with shapes \(3,\) \(4,\)",
  201:             r"operands could not be broadcast together with shapes \(4,\) \(3,\)",
  202:         ]
  203:     )
  204:     if data.dtype.kind == "b" and all_arithmetic_operators.strip("_") in [
  205:         "sub",
  206:         "rsub",
  207:     ]:
  208:         err = TypeError
  209:         msg = (
  210:             r"numpy boolean subtract, the `\-` operator, is not supported, use "
  211:             r"the bitwise_xor, the `\^` operator, or the logical_xor function instead"
  212:         )
  213:     elif is_bool_not_implemented(data, all_arithmetic_operators):
  214:         msg = "operator '.*' not implemented for bool dtypes"
  215:         err = NotImplementedError
  216: 
  217:     for other in [other, np.array(other)]:
  218:         with pytest.raises(err, match=msg):
  219:             op(data, other)
  220: 
  221:         s = pd.Series(data)
  222:         with pytest.raises(err, match=msg):
  223:             op(s, other)
  224: 
  225: 
  226: @pytest.mark.parametrize("op", ["__neg__", "__abs__", "__invert__"])
  227: def test_unary_op_does_not_propagate_mask(data, op):
  228:     # https://github.com/pandas-dev/pandas/issues/39943
  229:     data, _ = data
  230:     ser = pd.Series(data)
  231: 
  232:     if op == "__invert__" and data.dtype.kind == "f":
  233:         # we follow numpy in raising
  234:         msg = "ufunc 'invert' not supported for the input types"
  235:         with pytest.raises(TypeError, match=msg):
  236:             getattr(ser, op)()
  237:         with pytest.raises(TypeError, match=msg):
  238:             getattr(data, op)()
  239:         with pytest.raises(TypeError, match=msg):
  240:             # Check that this is still the numpy behavior
  241:             getattr(data._data, op)()
  242: 
  243:         return
  244: 
  245:     result = getattr(ser, op)()
  246:     expected = result.copy(deep=True)
  247:     ser[0] = None
  248:     tm.assert_series_equal(result, expected)
