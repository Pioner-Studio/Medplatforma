    1: """
    2: Tests for DatetimeArray
    3: """
    4: from __future__ import annotations
    5: 
    6: from datetime import timedelta
    7: import operator
    8: 
    9: try:
   10:     from zoneinfo import ZoneInfo
   11: except ImportError:
   12:     # Cannot assign to a type
   13:     ZoneInfo = None  # type: ignore[misc, assignment]
   14: 
   15: import numpy as np
   16: import pytest
   17: 
   18: from pandas._libs.tslibs import tz_compare
   19: 
   20: from pandas.core.dtypes.dtypes import DatetimeTZDtype
   21: 
   22: import pandas as pd
   23: import pandas._testing as tm
   24: from pandas.core.arrays import (
   25:     DatetimeArray,
   26:     TimedeltaArray,
   27: )
   28: 
   29: 
   30: class TestNonNano:
   31:     @pytest.fixture(params=["s", "ms", "us"])
   32:     def unit(self, request):
   33:         """Fixture returning parametrized time units"""
   34:         return request.param
   35: 
   36:     @pytest.fixture
   37:     def dtype(self, unit, tz_naive_fixture):
   38:         tz = tz_naive_fixture
   39:         if tz is None:
   40:             return np.dtype(f"datetime64[{unit}]")
   41:         else:
   42:             return DatetimeTZDtype(unit=unit, tz=tz)
   43: 
   44:     @pytest.fixture
   45:     def dta_dti(self, unit, dtype):
   46:         tz = getattr(dtype, "tz", None)
   47: 
   48:         dti = pd.date_range("2016-01-01", periods=55, freq="D", tz=tz)
   49:         if tz is None:
   50:             arr = np.asarray(dti).astype(f"M8[{unit}]")
   51:         else:
   52:             arr = np.asarray(dti.tz_convert("UTC").tz_localize(None)).astype(
   53:                 f"M8[{unit}]"
   54:             )
   55: 
   56:         dta = DatetimeArray._simple_new(arr, dtype=dtype)
   57:         return dta, dti
   58: 
   59:     @pytest.fixture
   60:     def dta(self, dta_dti):
   61:         dta, dti = dta_dti
   62:         return dta
   63: 
   64:     def test_non_nano(self, unit, dtype):
   65:         arr = np.arange(5, dtype=np.int64).view(f"M8[{unit}]")
   66:         dta = DatetimeArray._simple_new(arr, dtype=dtype)
   67: 
   68:         assert dta.dtype == dtype
   69:         assert dta[0].unit == unit
   70:         assert tz_compare(dta.tz, dta[0].tz)
   71:         assert (dta[0] == dta[:1]).all()
   72: 
   73:     @pytest.mark.parametrize(
   74:         "field", DatetimeArray._field_ops + DatetimeArray._bool_ops
   75:     )
   76:     def test_fields(self, unit, field, dtype, dta_dti):
   77:         dta, dti = dta_dti
   78: 
   79:         assert (dti == dta).all()
   80: 
   81:         res = getattr(dta, field)
   82:         expected = getattr(dti._data, field)
   83:         tm.assert_numpy_array_equal(res, expected)
   84: 
   85:     def test_normalize(self, unit):
   86:         dti = pd.date_range("2016-01-01 06:00:00", periods=55, freq="D")
   87:         arr = np.asarray(dti).astype(f"M8[{unit}]")
   88: 
   89:         dta = DatetimeArray._simple_new(arr, dtype=arr.dtype)
   90: 
   91:         assert not dta.is_normalized
   92: 
   93:         # TODO: simplify once we can just .astype to other unit
   94:         exp = np.asarray(dti.normalize()).astype(f"M8[{unit}]")
   95:         expected = DatetimeArray._simple_new(exp, dtype=exp.dtype)
   96: 
   97:         res = dta.normalize()
   98:         tm.assert_extension_array_equal(res, expected)
   99: 
  100:     def test_simple_new_requires_match(self, unit):
  101:         arr = np.arange(5, dtype=np.int64).view(f"M8[{unit}]")
  102:         dtype = DatetimeTZDtype(unit, "UTC")
  103: 
  104:         dta = DatetimeArray._simple_new(arr, dtype=dtype)
  105:         assert dta.dtype == dtype
  106: 
  107:         wrong = DatetimeTZDtype("ns", "UTC")
  108:         with pytest.raises(AssertionError, match=""):
  109:             DatetimeArray._simple_new(arr, dtype=wrong)
  110: 
  111:     def test_std_non_nano(self, unit):
  112:         dti = pd.date_range("2016-01-01", periods=55, freq="D")
  113:         arr = np.asarray(dti).astype(f"M8[{unit}]")
  114: 
  115:         dta = DatetimeArray._simple_new(arr, dtype=arr.dtype)
  116: 
  117:         # we should match the nano-reso std, but floored to our reso.
  118:         res = dta.std()
  119:         assert res._creso == dta._creso
  120:         assert res == dti.std().floor(unit)
  121: 
  122:     @pytest.mark.filterwarnings("ignore:Converting to PeriodArray.*:UserWarning")
  123:     def test_to_period(self, dta_dti):
  124:         dta, dti = dta_dti
  125:         result = dta.to_period("D")
  126:         expected = dti._data.to_period("D")
  127: 
  128:         tm.assert_extension_array_equal(result, expected)
  129: 
  130:     def test_iter(self, dta):
  131:         res = next(iter(dta))
  132:         expected = dta[0]
  133: 
  134:         assert type(res) is pd.Timestamp
  135:         assert res._value == expected._value
  136:         assert res._creso == expected._creso
  137:         assert res == expected
  138: 
  139:     def test_astype_object(self, dta):
  140:         result = dta.astype(object)
  141:         assert all(x._creso == dta._creso for x in result)
  142:         assert all(x == y for x, y in zip(result, dta))
  143: 
  144:     def test_to_pydatetime(self, dta_dti):
  145:         dta, dti = dta_dti
  146: 
  147:         result = dta.to_pydatetime()
  148:         expected = dti.to_pydatetime()
  149:         tm.assert_numpy_array_equal(result, expected)
  150: 
  151:     @pytest.mark.parametrize("meth", ["time", "timetz", "date"])
  152:     def test_time_date(self, dta_dti, meth):
  153:         dta, dti = dta_dti
  154: 
  155:         result = getattr(dta, meth)
  156:         expected = getattr(dti, meth)
  157:         tm.assert_numpy_array_equal(result, expected)
  158: 
  159:     def test_format_native_types(self, unit, dtype, dta_dti):
  160:         # In this case we should get the same formatted values with our nano
  161:         #  version dti._data as we do with the non-nano dta
  162:         dta, dti = dta_dti
  163: 
  164:         res = dta._format_native_types()
  165:         exp = dti._data._format_native_types()
  166:         tm.assert_numpy_array_equal(res, exp)
  167: 
  168:     def test_repr(self, dta_dti, unit):
  169:         dta, dti = dta_dti
  170: 
  171:         assert repr(dta) == repr(dti._data).replace("[ns", f"[{unit}")
  172: 
  173:     # TODO: tests with td64
  174:     def test_compare_mismatched_resolutions(self, comparison_op):
  175:         # comparison that numpy gets wrong bc of silent overflows
  176:         op = comparison_op
  177: 
  178:         iinfo = np.iinfo(np.int64)
  179:         vals = np.array([iinfo.min, iinfo.min + 1, iinfo.max], dtype=np.int64)
  180: 
  181:         # Construct so that arr2[1] < arr[1] < arr[2] < arr2[2]
  182:         arr = np.array(vals).view("M8[ns]")
  183:         arr2 = arr.view("M8[s]")
  184: 
  185:         left = DatetimeArray._simple_new(arr, dtype=arr.dtype)
  186:         right = DatetimeArray._simple_new(arr2, dtype=arr2.dtype)
  187: 
  188:         if comparison_op is operator.eq:
  189:             expected = np.array([False, False, False])
  190:         elif comparison_op is operator.ne:
  191:             expected = np.array([True, True, True])
  192:         elif comparison_op in [operator.lt, operator.le]:
  193:             expected = np.array([False, False, True])
  194:         else:
  195:             expected = np.array([False, True, False])
  196: 
  197:         result = op(left, right)
  198:         tm.assert_numpy_array_equal(result, expected)
  199: 
  200:         result = op(left[1], right)
  201:         tm.assert_numpy_array_equal(result, expected)
  202: 
  203:         if op not in [operator.eq, operator.ne]:
  204:             # check that numpy still gets this wrong; if it is fixed we may be
  205:             #  able to remove compare_mismatched_resolutions
  206:             np_res = op(left._ndarray, right._ndarray)
  207:             tm.assert_numpy_array_equal(np_res[1:], ~expected[1:])
  208: 
  209:     def test_add_mismatched_reso_doesnt_downcast(self):
  210:         # https://github.com/pandas-dev/pandas/pull/48748#issuecomment-1260181008
  211:         td = pd.Timedelta(microseconds=1)
  212:         dti = pd.date_range("2016-01-01", periods=3) - td
  213:         dta = dti._data.as_unit("us")
  214: 
  215:         res = dta + td.as_unit("us")
  216:         # even though the result is an even number of days
  217:         #  (so we _could_ downcast to unit="s"), we do not.
  218:         assert res.unit == "us"
  219: 
  220:     @pytest.mark.parametrize(
  221:         "scalar",
  222:         [
  223:             timedelta(hours=2),
  224:             pd.Timedelta(hours=2),
  225:             np.timedelta64(2, "h"),
  226:             np.timedelta64(2 * 3600 * 1000, "ms"),
  227:             pd.offsets.Minute(120),
  228:             pd.offsets.Hour(2),
  229:         ],
  230:     )
  231:     def test_add_timedeltalike_scalar_mismatched_reso(self, dta_dti, scalar):
  232:         dta, dti = dta_dti
  233: 
  234:         td = pd.Timedelta(scalar)
  235:         exp_unit = tm.get_finest_unit(dta.unit, td.unit)
  236: 
  237:         expected = (dti + td)._data.as_unit(exp_unit)
  238:         result = dta + scalar
  239:         tm.assert_extension_array_equal(result, expected)
  240: 
  241:         result = scalar + dta
  242:         tm.assert_extension_array_equal(result, expected)
  243: 
  244:         expected = (dti - td)._data.as_unit(exp_unit)
  245:         result = dta - scalar
  246:         tm.assert_extension_array_equal(result, expected)
  247: 
  248:     def test_sub_datetimelike_scalar_mismatch(self):
  249:         dti = pd.date_range("2016-01-01", periods=3)
  250:         dta = dti._data.as_unit("us")
  251: 
  252:         ts = dta[0].as_unit("s")
  253: 
  254:         result = dta - ts
  255:         expected = (dti - dti[0])._data.as_unit("us")
  256:         assert result.dtype == "m8[us]"
  257:         tm.assert_extension_array_equal(result, expected)
  258: 
  259:     def test_sub_datetime64_reso_mismatch(self):
  260:         dti = pd.date_range("2016-01-01", periods=3)
  261:         left = dti._data.as_unit("s")
  262:         right = left.as_unit("ms")
  263: 
  264:         result = left - right
  265:         exp_values = np.array([0, 0, 0], dtype="m8[ms]")
  266:         expected = TimedeltaArray._simple_new(
  267:             exp_values,
  268:             dtype=exp_values.dtype,
  269:         )
  270:         tm.assert_extension_array_equal(result, expected)
  271:         result2 = right - left
  272:         tm.assert_extension_array_equal(result2, expected)
  273: 
  274: 
  275: class TestDatetimeArrayComparisons:
  276:     # TODO: merge this into tests/arithmetic/test_datetime64 once it is
  277:     #  sufficiently robust
  278: 
  279:     def test_cmp_dt64_arraylike_tznaive(self, comparison_op):
  280:         # arbitrary tz-naive DatetimeIndex
  281:         op = comparison_op
  282: 
  283:         dti = pd.date_range("2016-01-1", freq="MS", periods=9, tz=None)
  284:         arr = dti._data
  285:         assert arr.freq == dti.freq
  286:         assert arr.tz == dti.tz
  287: 
  288:         right = dti
  289: 
  290:         expected = np.ones(len(arr), dtype=bool)
  291:         if comparison_op.__name__ in ["ne", "gt", "lt"]:
  292:             # for these the comparisons should be all-False
  293:             expected = ~expected
  294: 
  295:         result = op(arr, arr)
  296:         tm.assert_numpy_array_equal(result, expected)
  297:         for other in [
  298:             right,
  299:             np.array(right),
  300:             list(right),
  301:             tuple(right),
  302:             right.astype(object),
  303:         ]:
  304:             result = op(arr, other)
  305:             tm.assert_numpy_array_equal(result, expected)
  306: 
  307:             result = op(other, arr)
  308:             tm.assert_numpy_array_equal(result, expected)
  309: 
  310: 
  311: class TestDatetimeArray:
  312:     def test_astype_ns_to_ms_near_bounds(self):
  313:         # GH#55979
  314:         ts = pd.Timestamp("1677-09-21 00:12:43.145225")
  315:         target = ts.as_unit("ms")
  316: 
  317:         dta = DatetimeArray._from_sequence([ts], dtype="M8[ns]")
  318:         assert (dta.view("i8") == ts.as_unit("ns").value).all()
  319: 
  320:         result = dta.astype("M8[ms]")
  321:         assert result[0] == target
  322: 
  323:         expected = DatetimeArray._from_sequence([ts], dtype="M8[ms]")
  324:         assert (expected.view("i8") == target._value).all()
  325: 
  326:         tm.assert_datetime_array_equal(result, expected)
  327: 
  328:     def test_astype_non_nano_tznaive(self):
  329:         dti = pd.date_range("2016-01-01", periods=3)
  330: 
  331:         res = dti.astype("M8[s]")
  332:         assert res.dtype == "M8[s]"
  333: 
  334:         dta = dti._data
  335:         res = dta.astype("M8[s]")
  336:         assert res.dtype == "M8[s]"
  337:         assert isinstance(res, pd.core.arrays.DatetimeArray)  # used to be ndarray
  338: 
  339:     def test_astype_non_nano_tzaware(self):
  340:         dti = pd.date_range("2016-01-01", periods=3, tz="UTC")
  341: 
  342:         res = dti.astype("M8[s, US/Pacific]")
  343:         assert res.dtype == "M8[s, US/Pacific]"
  344: 
  345:         dta = dti._data
  346:         res = dta.astype("M8[s, US/Pacific]")
  347:         assert res.dtype == "M8[s, US/Pacific]"
  348: 
  349:         # from non-nano to non-nano, preserving reso
  350:         res2 = res.astype("M8[s, UTC]")
  351:         assert res2.dtype == "M8[s, UTC]"
  352:         assert not tm.shares_memory(res2, res)
  353: 
  354:         res3 = res.astype("M8[s, UTC]", copy=False)
  355:         assert res2.dtype == "M8[s, UTC]"
  356:         assert tm.shares_memory(res3, res)
  357: 
  358:     def test_astype_to_same(self):
  359:         arr = DatetimeArray._from_sequence(
  360:             ["2000"], dtype=DatetimeTZDtype(tz="US/Central")
  361:         )
  362:         result = arr.astype(DatetimeTZDtype(tz="US/Central"), copy=False)
  363:         assert result is arr
  364: 
  365:     @pytest.mark.parametrize("dtype", ["datetime64[ns]", "datetime64[ns, UTC]"])
  366:     @pytest.mark.parametrize(
  367:         "other", ["datetime64[ns]", "datetime64[ns, UTC]", "datetime64[ns, CET]"]
  368:     )
  369:     def test_astype_copies(self, dtype, other):
  370:         # https://github.com/pandas-dev/pandas/pull/32490
  371:         ser = pd.Series([1, 2], dtype=dtype)
  372:         orig = ser.copy()
  373: 
  374:         err = False
  375:         if (dtype == "datetime64[ns]") ^ (other == "datetime64[ns]"):
  376:             # deprecated in favor of tz_localize
  377:             err = True
  378: 
  379:         if err:
  380:             if dtype == "datetime64[ns]":
  381:                 msg = "Use obj.tz_localize instead or series.dt.tz_localize instead"
  382:             else:
  383:                 msg = "from timezone-aware dtype to timezone-naive dtype"
  384:             with pytest.raises(TypeError, match=msg):
  385:                 ser.astype(other)
  386:         else:
  387:             t = ser.astype(other)
  388:             t[:] = pd.NaT
  389:             tm.assert_series_equal(ser, orig)
  390: 
  391:     @pytest.mark.parametrize("dtype", [int, np.int32, np.int64, "uint32", "uint64"])
  392:     def test_astype_int(self, dtype):
  393:         arr = DatetimeArray._from_sequence(
  394:             [pd.Timestamp("2000"), pd.Timestamp("2001")], dtype="M8[ns]"
  395:         )
  396: 
  397:         if np.dtype(dtype) != np.int64:
  398:             with pytest.raises(TypeError, match=r"Do obj.astype\('int64'\)"):
  399:                 arr.astype(dtype)
  400:             return
  401: 
  402:         result = arr.astype(dtype)
  403:         expected = arr._ndarray.view("i8")
  404:         tm.assert_numpy_array_equal(result, expected)
  405: 
  406:     def test_astype_to_sparse_dt64(self):
  407:         # GH#50082
  408:         dti = pd.date_range("2016-01-01", periods=4)
  409:         dta = dti._data
  410:         result = dta.astype("Sparse[datetime64[ns]]")
  411: 
  412:         assert result.dtype == "Sparse[datetime64[ns]]"
  413:         assert (result == dta).all()
  414: 
  415:     def test_tz_setter_raises(self):
  416:         arr = DatetimeArray._from_sequence(
  417:             ["2000"], dtype=DatetimeTZDtype(tz="US/Central")
  418:         )
  419:         with pytest.raises(AttributeError, match="tz_localize"):
  420:             arr.tz = "UTC"
  421: 
  422:     def test_setitem_str_impute_tz(self, tz_naive_fixture):
  423:         # Like for getitem, if we are passed a naive-like string, we impute
  424:         #  our own timezone.
  425:         tz = tz_naive_fixture
  426: 
  427:         data = np.array([1, 2, 3], dtype="M8[ns]")
  428:         dtype = data.dtype if tz is None else DatetimeTZDtype(tz=tz)
  429:         arr = DatetimeArray._from_sequence(data, dtype=dtype)
  430:         expected = arr.copy()
  431: 
  432:         ts = pd.Timestamp("2020-09-08 16:50").tz_localize(tz)
  433:         setter = str(ts.tz_localize(None))
  434: 
  435:         # Setting a scalar tznaive string
  436:         expected[0] = ts
  437:         arr[0] = setter
  438:         tm.assert_equal(arr, expected)
  439: 
  440:         # Setting a listlike of tznaive strings
  441:         expected[1] = ts
  442:         arr[:2] = [setter, setter]
  443:         tm.assert_equal(arr, expected)
  444: 
  445:     def test_setitem_different_tz_raises(self):
  446:         # pre-2.0 we required exact tz match, in 2.0 we require only
  447:         #  tzawareness-match
  448:         data = np.array([1, 2, 3], dtype="M8[ns]")
  449:         arr = DatetimeArray._from_sequence(
  450:             data, copy=False, dtype=DatetimeTZDtype(tz="US/Central")
  451:         )
  452:         with pytest.raises(TypeError, match="Cannot compare tz-naive and tz-aware"):
  453:             arr[0] = pd.Timestamp("2000")
  454: 
  455:         ts = pd.Timestamp("2000", tz="US/Eastern")
  456:         arr[0] = ts
  457:         assert arr[0] == ts.tz_convert("US/Central")
  458: 
  459:     def test_setitem_clears_freq(self):
  460:         a = pd.date_range("2000", periods=2, freq="D", tz="US/Central")._data
  461:         a[0] = pd.Timestamp("2000", tz="US/Central")
  462:         assert a.freq is None
  463: 
  464:     @pytest.mark.parametrize(
  465:         "obj",
  466:         [
  467:             pd.Timestamp("2021-01-01"),
  468:             pd.Timestamp("2021-01-01").to_datetime64(),
  469:             pd.Timestamp("2021-01-01").to_pydatetime(),
  470:         ],
  471:     )
  472:     def test_setitem_objects(self, obj):
  473:         # make sure we accept datetime64 and datetime in addition to Timestamp
  474:         dti = pd.date_range("2000", periods=2, freq="D")
  475:         arr = dti._data
  476: 
  477:         arr[0] = obj
  478:         assert arr[0] == obj
  479: 
  480:     def test_repeat_preserves_tz(self):
  481:         dti = pd.date_range("2000", periods=2, freq="D", tz="US/Central")
  482:         arr = dti._data
  483: 
  484:         repeated = arr.repeat([1, 1])
  485: 
  486:         # preserves tz and values, but not freq
  487:         expected = DatetimeArray._from_sequence(arr.asi8, dtype=arr.dtype)
  488:         tm.assert_equal(repeated, expected)
  489: 
  490:     def test_value_counts_preserves_tz(self):
  491:         dti = pd.date_range("2000", periods=2, freq="D", tz="US/Central")
  492:         arr = dti._data.repeat([4, 3])
  493: 
  494:         result = arr.value_counts()
  495: 
  496:         # Note: not tm.assert_index_equal, since `freq`s do not match
  497:         assert result.index.equals(dti)
  498: 
  499:         arr[-2] = pd.NaT
  500:         result = arr.value_counts(dropna=False)
  501:         expected = pd.Series([4, 2, 1], index=[dti[0], dti[1], pd.NaT], name="count")
  502:         tm.assert_series_equal(result, expected)
  503: 
  504:     @pytest.mark.parametrize("method", ["pad", "backfill"])
  505:     def test_fillna_preserves_tz(self, method):
  506:         dti = pd.date_range("2000-01-01", periods=5, freq="D", tz="US/Central")
  507:         arr = DatetimeArray._from_sequence(dti, copy=True)
  508:         arr[2] = pd.NaT
  509: 
  510:         fill_val = dti[1] if method == "pad" else dti[3]
  511:         expected = DatetimeArray._from_sequence(
  512:             [dti[0], dti[1], fill_val, dti[3], dti[4]],
  513:             dtype=DatetimeTZDtype(tz="US/Central"),
  514:         )
  515: 
  516:         result = arr._pad_or_backfill(method=method)
  517:         tm.assert_extension_array_equal(result, expected)
  518: 
  519:         # assert that arr and dti were not modified in-place
  520:         assert arr[2] is pd.NaT
  521:         assert dti[2] == pd.Timestamp("2000-01-03", tz="US/Central")
  522: 
  523:     def test_fillna_2d(self):
  524:         dti = pd.date_range("2016-01-01", periods=6, tz="US/Pacific")
  525:         dta = dti._data.reshape(3, 2).copy()
  526:         dta[0, 1] = pd.NaT
  527:         dta[1, 0] = pd.NaT
  528: 
  529:         res1 = dta._pad_or_backfill(method="pad")
  530:         expected1 = dta.copy()
  531:         expected1[1, 0] = dta[0, 0]
  532:         tm.assert_extension_array_equal(res1, expected1)
  533: 
  534:         res2 = dta._pad_or_backfill(method="backfill")
  535:         expected2 = dta.copy()
  536:         expected2 = dta.copy()
  537:         expected2[1, 0] = dta[2, 0]
  538:         expected2[0, 1] = dta[1, 1]
  539:         tm.assert_extension_array_equal(res2, expected2)
  540: 
  541:         # with different ordering for underlying ndarray; behavior should
  542:         #  be unchanged
  543:         dta2 = dta._from_backing_data(dta._ndarray.copy(order="F"))
  544:         assert dta2._ndarray.flags["F_CONTIGUOUS"]
  545:         assert not dta2._ndarray.flags["C_CONTIGUOUS"]
  546:         tm.assert_extension_array_equal(dta, dta2)
  547: 
  548:         res3 = dta2._pad_or_backfill(method="pad")
  549:         tm.assert_extension_array_equal(res3, expected1)
  550: 
  551:         res4 = dta2._pad_or_backfill(method="backfill")
  552:         tm.assert_extension_array_equal(res4, expected2)
  553: 
  554:         # test the DataFrame method while we're here
  555:         df = pd.DataFrame(dta)
  556:         res = df.ffill()
  557:         expected = pd.DataFrame(expected1)
  558:         tm.assert_frame_equal(res, expected)
  559: 
  560:         res = df.bfill()
  561:         expected = pd.DataFrame(expected2)
  562:         tm.assert_frame_equal(res, expected)
  563: 
  564:     def test_array_interface_tz(self):
  565:         tz = "US/Central"
  566:         data = pd.date_range("2017", periods=2, tz=tz)._data
  567:         result = np.asarray(data)
  568: 
  569:         expected = np.array(
  570:             [
  571:                 pd.Timestamp("2017-01-01T00:00:00", tz=tz),
  572:                 pd.Timestamp("2017-01-02T00:00:00", tz=tz),
  573:             ],
  574:             dtype=object,
  575:         )
  576:         tm.assert_numpy_array_equal(result, expected)
  577: 
  578:         result = np.asarray(data, dtype=object)
  579:         tm.assert_numpy_array_equal(result, expected)
  580: 
  581:         result = np.asarray(data, dtype="M8[ns]")
  582: 
  583:         expected = np.array(
  584:             ["2017-01-01T06:00:00", "2017-01-02T06:00:00"], dtype="M8[ns]"
  585:         )
  586:         tm.assert_numpy_array_equal(result, expected)
  587: 
  588:     def test_array_interface(self):
  589:         data = pd.date_range("2017", periods=2)._data
  590:         expected = np.array(
  591:             ["2017-01-01T00:00:00", "2017-01-02T00:00:00"], dtype="datetime64[ns]"
  592:         )
  593: 
  594:         result = np.asarray(data)
  595:         tm.assert_numpy_array_equal(result, expected)
  596: 
  597:         result = np.asarray(data, dtype=object)
  598:         expected = np.array(
  599:             [pd.Timestamp("2017-01-01T00:00:00"), pd.Timestamp("2017-01-02T00:00:00")],
  600:             dtype=object,
  601:         )
  602:         tm.assert_numpy_array_equal(result, expected)
  603: 
  604:     @pytest.mark.parametrize("index", [True, False])
  605:     def test_searchsorted_different_tz(self, index):
  606:         data = np.arange(10, dtype="i8") * 24 * 3600 * 10**9
  607:         arr = pd.DatetimeIndex(data, freq="D")._data.tz_localize("Asia/Tokyo")
  608:         if index:
  609:             arr = pd.Index(arr)
  610: 
  611:         expected = arr.searchsorted(arr[2])
  612:         result = arr.searchsorted(arr[2].tz_convert("UTC"))
  613:         assert result == expected
  614: 
  615:         expected = arr.searchsorted(arr[2:6])
  616:         result = arr.searchsorted(arr[2:6].tz_convert("UTC"))
  617:         tm.assert_equal(result, expected)
  618: 
  619:     @pytest.mark.parametrize("index", [True, False])
  620:     def test_searchsorted_tzawareness_compat(self, index):
  621:         data = np.arange(10, dtype="i8") * 24 * 3600 * 10**9
  622:         arr = pd.DatetimeIndex(data, freq="D")._data
  623:         if index:
  624:             arr = pd.Index(arr)
  625: 
  626:         mismatch = arr.tz_localize("Asia/Tokyo")
  627: 
  628:         msg = "Cannot compare tz-naive and tz-aware datetime-like objects"
  629:         with pytest.raises(TypeError, match=msg):
  630:             arr.searchsorted(mismatch[0])
  631:         with pytest.raises(TypeError, match=msg):
  632:             arr.searchsorted(mismatch)
  633: 
  634:         with pytest.raises(TypeError, match=msg):
  635:             mismatch.searchsorted(arr[0])
  636:         with pytest.raises(TypeError, match=msg):
  637:             mismatch.searchsorted(arr)
  638: 
  639:     @pytest.mark.parametrize(
  640:         "other",
  641:         [
  642:             1,
  643:             np.int64(1),
  644:             1.0,
  645:             np.timedelta64("NaT"),
  646:             pd.Timedelta(days=2),
  647:             "invalid",
  648:             np.arange(10, dtype="i8") * 24 * 3600 * 10**9,
  649:             np.arange(10).view("timedelta64[ns]") * 24 * 3600 * 10**9,
  650:             pd.Timestamp("2021-01-01").to_period("D"),
  651:         ],
  652:     )
  653:     @pytest.mark.parametrize("index", [True, False])
  654:     def test_searchsorted_invalid_types(self, other, index):
  655:         data = np.arange(10, dtype="i8") * 24 * 3600 * 10**9
  656:         arr = pd.DatetimeIndex(data, freq="D")._data
  657:         if index:
  658:             arr = pd.Index(arr)
  659: 
  660:         msg = "|".join(
  661:             [
  662:                 "searchsorted requires compatible dtype or scalar",
  663:                 "value should be a 'Timestamp', 'NaT', or array of those. Got",
  664:             ]
  665:         )
  666:         with pytest.raises(TypeError, match=msg):
  667:             arr.searchsorted(other)
  668: 
  669:     def test_shift_fill_value(self):
  670:         dti = pd.date_range("2016-01-01", periods=3)
  671: 
  672:         dta = dti._data
  673:         expected = DatetimeArray._from_sequence(np.roll(dta._ndarray, 1))
  674: 
  675:         fv = dta[-1]
  676:         for fill_value in [fv, fv.to_pydatetime(), fv.to_datetime64()]:
  677:             result = dta.shift(1, fill_value=fill_value)
  678:             tm.assert_datetime_array_equal(result, expected)
  679: 
  680:         dta = dta.tz_localize("UTC")
  681:         expected = expected.tz_localize("UTC")
  682:         fv = dta[-1]
  683:         for fill_value in [fv, fv.to_pydatetime()]:
  684:             result = dta.shift(1, fill_value=fill_value)
  685:             tm.assert_datetime_array_equal(result, expected)
  686: 
  687:     def test_shift_value_tzawareness_mismatch(self):
  688:         dti = pd.date_range("2016-01-01", periods=3)
  689: 
  690:         dta = dti._data
  691: 
  692:         fv = dta[-1].tz_localize("UTC")
  693:         for invalid in [fv, fv.to_pydatetime()]:
  694:             with pytest.raises(TypeError, match="Cannot compare"):
  695:                 dta.shift(1, fill_value=invalid)
  696: 
  697:         dta = dta.tz_localize("UTC")
  698:         fv = dta[-1].tz_localize(None)
  699:         for invalid in [fv, fv.to_pydatetime(), fv.to_datetime64()]:
  700:             with pytest.raises(TypeError, match="Cannot compare"):
  701:                 dta.shift(1, fill_value=invalid)
  702: 
  703:     def test_shift_requires_tzmatch(self):
  704:         # pre-2.0 we required exact tz match, in 2.0 we require just
  705:         #  matching tzawareness
  706:         dti = pd.date_range("2016-01-01", periods=3, tz="UTC")
  707:         dta = dti._data
  708: 
  709:         fill_value = pd.Timestamp("2020-10-18 18:44", tz="US/Pacific")
  710: 
  711:         result = dta.shift(1, fill_value=fill_value)
  712:         expected = dta.shift(1, fill_value=fill_value.tz_convert("UTC"))
  713:         tm.assert_equal(result, expected)
  714: 
  715:     def test_tz_localize_t2d(self):
  716:         dti = pd.date_range("1994-05-12", periods=12, tz="US/Pacific")
  717:         dta = dti._data.reshape(3, 4)
  718:         result = dta.tz_localize(None)
  719: 
  720:         expected = dta.ravel().tz_localize(None).reshape(dta.shape)
  721:         tm.assert_datetime_array_equal(result, expected)
  722: 
  723:         roundtrip = expected.tz_localize("US/Pacific")
  724:         tm.assert_datetime_array_equal(roundtrip, dta)
  725: 
  726:     easts = ["US/Eastern", "dateutil/US/Eastern"]
  727:     if ZoneInfo is not None:
  728:         try:
  729:             tz = ZoneInfo("US/Eastern")
  730:         except KeyError:
  731:             # no tzdata
  732:             pass
  733:         else:
  734:             # Argument 1 to "append" of "list" has incompatible type "ZoneInfo";
  735:             # expected "str"
  736:             easts.append(tz)  # type: ignore[arg-type]
  737: 
  738:     @pytest.mark.parametrize("tz", easts)
  739:     def test_iter_zoneinfo_fold(self, tz):
  740:         # GH#49684
  741:         utc_vals = np.array(
  742:             [1320552000, 1320555600, 1320559200, 1320562800], dtype=np.int64
  743:         )
  744:         utc_vals *= 1_000_000_000
  745: 
  746:         dta = DatetimeArray._from_sequence(utc_vals).tz_localize("UTC").tz_convert(tz)
  747: 
  748:         left = dta[2]
  749:         right = list(dta)[2]
  750:         assert str(left) == str(right)
  751:         # previously there was a bug where with non-pytz right would be
  752:         #  Timestamp('2011-11-06 01:00:00-0400', tz='US/Eastern')
  753:         # while left would be
  754:         #  Timestamp('2011-11-06 01:00:00-0500', tz='US/Eastern')
  755:         # The .value's would match (so they would compare as equal),
  756:         #  but the folds would not
  757:         assert left.utcoffset() == right.utcoffset()
  758: 
  759:         # The same bug in ints_to_pydatetime affected .astype, so we test
  760:         #  that here.
  761:         right2 = dta.astype(object)[2]
  762:         assert str(left) == str(right2)
  763:         assert left.utcoffset() == right2.utcoffset()
  764: 
  765:     @pytest.mark.parametrize(
  766:         "freq, freq_depr",
  767:         [
  768:             ("2ME", "2M"),
  769:             ("2SME", "2SM"),
  770:             ("2SME", "2sm"),
  771:             ("2QE", "2Q"),
  772:             ("2QE-SEP", "2Q-SEP"),
  773:             ("1YE", "1Y"),
  774:             ("2YE-MAR", "2Y-MAR"),
  775:             ("1YE", "1A"),
  776:             ("2YE-MAR", "2A-MAR"),
  777:             ("2ME", "2m"),
  778:             ("2QE-SEP", "2q-sep"),
  779:             ("2YE-MAR", "2a-mar"),
  780:             ("2YE", "2y"),
  781:         ],
  782:     )
  783:     def test_date_range_frequency_M_Q_Y_A_deprecated(self, freq, freq_depr):
  784:         # GH#9586, GH#54275
  785:         depr_msg = f"'{freq_depr[1:]}' is deprecated and will be removed "
  786:         f"in a future version, please use '{freq[1:]}' instead."
  787: 
  788:         expected = pd.date_range("1/1/2000", periods=4, freq=freq)
  789:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  790:             result = pd.date_range("1/1/2000", periods=4, freq=freq_depr)
  791:         tm.assert_index_equal(result, expected)
  792: 
  793:     @pytest.mark.parametrize("freq_depr", ["2H", "2CBH", "2MIN", "2S", "2mS", "2Us"])
  794:     def test_date_range_uppercase_frequency_deprecated(self, freq_depr):
  795:         # GH#9586, GH#54939
  796:         depr_msg = f"'{freq_depr[1:]}' is deprecated and will be removed in a "
  797:         f"future version. Please use '{freq_depr.lower()[1:]}' instead."
  798: 
  799:         expected = pd.date_range("1/1/2000", periods=4, freq=freq_depr.lower())
  800:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  801:             result = pd.date_range("1/1/2000", periods=4, freq=freq_depr)
  802:         tm.assert_index_equal(result, expected)
  803: 
  804:     @pytest.mark.parametrize(
  805:         "freq_depr",
  806:         [
  807:             "2ye-mar",
  808:             "2ys",
  809:             "2qe",
  810:             "2qs-feb",
  811:             "2bqs",
  812:             "2sms",
  813:             "2bms",
  814:             "2cbme",
  815:             "2me",
  816:             "2w",
  817:         ],
  818:     )
  819:     def test_date_range_lowercase_frequency_deprecated(self, freq_depr):
  820:         # GH#9586, GH#54939
  821:         depr_msg = f"'{freq_depr[1:]}' is deprecated and will be removed in a "
  822:         f"future version, please use '{freq_depr.upper()[1:]}' instead."
  823: 
  824:         expected = pd.date_range("1/1/2000", periods=4, freq=freq_depr.upper())
  825:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  826:             result = pd.date_range("1/1/2000", periods=4, freq=freq_depr)
  827:         tm.assert_index_equal(result, expected)
  828: 
  829: 
  830: def test_factorize_sort_without_freq():
  831:     dta = DatetimeArray._from_sequence([0, 2, 1], dtype="M8[ns]")
  832: 
  833:     msg = r"call pd.factorize\(obj, sort=True\) instead"
  834:     with pytest.raises(NotImplementedError, match=msg):
  835:         dta.factorize(sort=True)
  836: 
  837:     # Do TimedeltaArray while we're here
  838:     tda = dta - dta[0]
  839:     with pytest.raises(NotImplementedError, match=msg):
  840:         tda.factorize(sort=True)
