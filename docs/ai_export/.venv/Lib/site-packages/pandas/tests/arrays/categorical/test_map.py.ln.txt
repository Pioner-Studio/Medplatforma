    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Categorical,
    7:     Index,
    8:     Series,
    9: )
   10: import pandas._testing as tm
   11: 
   12: 
   13: @pytest.fixture(params=[None, "ignore"])
   14: def na_action(request):
   15:     return request.param
   16: 
   17: 
   18: @pytest.mark.parametrize(
   19:     "data, categories",
   20:     [
   21:         (list("abcbca"), list("cab")),
   22:         (pd.interval_range(0, 3).repeat(3), pd.interval_range(0, 3)),
   23:     ],
   24:     ids=["string", "interval"],
   25: )
   26: def test_map_str(data, categories, ordered, na_action):
   27:     # GH 31202 - override base class since we want to maintain categorical/ordered
   28:     cat = Categorical(data, categories=categories, ordered=ordered)
   29:     result = cat.map(str, na_action=na_action)
   30:     expected = Categorical(
   31:         map(str, data), categories=map(str, categories), ordered=ordered
   32:     )
   33:     tm.assert_categorical_equal(result, expected)
   34: 
   35: 
   36: def test_map(na_action):
   37:     cat = Categorical(list("ABABC"), categories=list("CBA"), ordered=True)
   38:     result = cat.map(lambda x: x.lower(), na_action=na_action)
   39:     exp = Categorical(list("ababc"), categories=list("cba"), ordered=True)
   40:     tm.assert_categorical_equal(result, exp)
   41: 
   42:     cat = Categorical(list("ABABC"), categories=list("BAC"), ordered=False)
   43:     result = cat.map(lambda x: x.lower(), na_action=na_action)
   44:     exp = Categorical(list("ababc"), categories=list("bac"), ordered=False)
   45:     tm.assert_categorical_equal(result, exp)
   46: 
   47:     # GH 12766: Return an index not an array
   48:     result = cat.map(lambda x: 1, na_action=na_action)
   49:     exp = Index(np.array([1] * 5, dtype=np.int64))
   50:     tm.assert_index_equal(result, exp)
   51: 
   52:     # change categories dtype
   53:     cat = Categorical(list("ABABC"), categories=list("BAC"), ordered=False)
   54: 
   55:     def f(x):
   56:         return {"A": 10, "B": 20, "C": 30}.get(x)
   57: 
   58:     result = cat.map(f, na_action=na_action)
   59:     exp = Categorical([10, 20, 10, 20, 30], categories=[20, 10, 30], ordered=False)
   60:     tm.assert_categorical_equal(result, exp)
   61: 
   62:     mapper = Series([10, 20, 30], index=["A", "B", "C"])
   63:     result = cat.map(mapper, na_action=na_action)
   64:     tm.assert_categorical_equal(result, exp)
   65: 
   66:     result = cat.map({"A": 10, "B": 20, "C": 30}, na_action=na_action)
   67:     tm.assert_categorical_equal(result, exp)
   68: 
   69: 
   70: @pytest.mark.parametrize(
   71:     ("data", "f", "expected"),
   72:     (
   73:         ([1, 1, np.nan], pd.isna, Index([False, False, True])),
   74:         ([1, 2, np.nan], pd.isna, Index([False, False, True])),
   75:         ([1, 1, np.nan], {1: False}, Categorical([False, False, np.nan])),
   76:         ([1, 2, np.nan], {1: False, 2: False}, Index([False, False, np.nan])),
   77:         (
   78:             [1, 1, np.nan],
   79:             Series([False, False]),
   80:             Categorical([False, False, np.nan]),
   81:         ),
   82:         (
   83:             [1, 2, np.nan],
   84:             Series([False] * 3),
   85:             Index([False, False, np.nan]),
   86:         ),
   87:     ),
   88: )
   89: def test_map_with_nan_none(data, f, expected):  # GH 24241
   90:     values = Categorical(data)
   91:     result = values.map(f, na_action=None)
   92:     if isinstance(expected, Categorical):
   93:         tm.assert_categorical_equal(result, expected)
   94:     else:
   95:         tm.assert_index_equal(result, expected)
   96: 
   97: 
   98: @pytest.mark.parametrize(
   99:     ("data", "f", "expected"),
  100:     (
  101:         ([1, 1, np.nan], pd.isna, Categorical([False, False, np.nan])),
  102:         ([1, 2, np.nan], pd.isna, Index([False, False, np.nan])),
  103:         ([1, 1, np.nan], {1: False}, Categorical([False, False, np.nan])),
  104:         ([1, 2, np.nan], {1: False, 2: False}, Index([False, False, np.nan])),
  105:         (
  106:             [1, 1, np.nan],
  107:             Series([False, False]),
  108:             Categorical([False, False, np.nan]),
  109:         ),
  110:         (
  111:             [1, 2, np.nan],
  112:             Series([False, False, False]),
  113:             Index([False, False, np.nan]),
  114:         ),
  115:     ),
  116: )
  117: def test_map_with_nan_ignore(data, f, expected):  # GH 24241
  118:     values = Categorical(data)
  119:     result = values.map(f, na_action="ignore")
  120:     if data[1] == 1:
  121:         tm.assert_categorical_equal(result, expected)
  122:     else:
  123:         tm.assert_index_equal(result, expected)
  124: 
  125: 
  126: def test_map_with_dict_or_series(na_action):
  127:     orig_values = ["a", "B", 1, "a"]
  128:     new_values = ["one", 2, 3.0, "one"]
  129:     cat = Categorical(orig_values)
  130: 
  131:     mapper = Series(new_values[:-1], index=orig_values[:-1])
  132:     result = cat.map(mapper, na_action=na_action)
  133: 
  134:     # Order of categories in result can be different
  135:     expected = Categorical(new_values, categories=[3.0, 2, "one"])
  136:     tm.assert_categorical_equal(result, expected)
  137: 
  138:     mapper = dict(zip(orig_values[:-1], new_values[:-1]))
  139:     result = cat.map(mapper, na_action=na_action)
  140:     # Order of categories in result can be different
  141:     tm.assert_categorical_equal(result, expected)
  142: 
  143: 
  144: def test_map_na_action_no_default_deprecated():
  145:     # GH51645
  146:     cat = Categorical(["a", "b", "c"])
  147:     msg = (
  148:         "The default value of 'ignore' for the `na_action` parameter in "
  149:         "pandas.Categorical.map is deprecated and will be "
  150:         "changed to 'None' in a future version. Please set na_action to the "
  151:         "desired value to avoid seeing this warning"
  152:     )
  153:     with tm.assert_produces_warning(FutureWarning, match=msg):
  154:         cat.map(lambda x: x)
