    1: from __future__ import annotations
    2: 
    3: import re
    4: import warnings
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas._libs import (
   10:     NaT,
   11:     OutOfBoundsDatetime,
   12:     Timestamp,
   13: )
   14: from pandas._libs.tslibs.dtypes import freq_to_period_freqstr
   15: from pandas.compat.numpy import np_version_gt2
   16: 
   17: import pandas as pd
   18: from pandas import (
   19:     DatetimeIndex,
   20:     Period,
   21:     PeriodIndex,
   22:     TimedeltaIndex,
   23: )
   24: import pandas._testing as tm
   25: from pandas.core.arrays import (
   26:     DatetimeArray,
   27:     NumpyExtensionArray,
   28:     PeriodArray,
   29:     TimedeltaArray,
   30: )
   31: 
   32: 
   33: # TODO: more freq variants
   34: @pytest.fixture(params=["D", "B", "W", "ME", "QE", "YE"])
   35: def freqstr(request):
   36:     """Fixture returning parametrized frequency in string format."""
   37:     return request.param
   38: 
   39: 
   40: @pytest.fixture
   41: def period_index(freqstr):
   42:     """
   43:     A fixture to provide PeriodIndex objects with different frequencies.
   44: 
   45:     Most PeriodArray behavior is already tested in PeriodIndex tests,
   46:     so here we just test that the PeriodArray behavior matches
   47:     the PeriodIndex behavior.
   48:     """
   49:     # TODO: non-monotone indexes; NaTs, different start dates
   50:     with warnings.catch_warnings():
   51:         # suppress deprecation of Period[B]
   52:         warnings.filterwarnings(
   53:             "ignore", message="Period with BDay freq", category=FutureWarning
   54:         )
   55:         freqstr = freq_to_period_freqstr(1, freqstr)
   56:         pi = pd.period_range(start=Timestamp("2000-01-01"), periods=100, freq=freqstr)
   57:     return pi
   58: 
   59: 
   60: @pytest.fixture
   61: def datetime_index(freqstr):
   62:     """
   63:     A fixture to provide DatetimeIndex objects with different frequencies.
   64: 
   65:     Most DatetimeArray behavior is already tested in DatetimeIndex tests,
   66:     so here we just test that the DatetimeArray behavior matches
   67:     the DatetimeIndex behavior.
   68:     """
   69:     # TODO: non-monotone indexes; NaTs, different start dates, timezones
   70:     dti = pd.date_range(start=Timestamp("2000-01-01"), periods=100, freq=freqstr)
   71:     return dti
   72: 
   73: 
   74: @pytest.fixture
   75: def timedelta_index():
   76:     """
   77:     A fixture to provide TimedeltaIndex objects with different frequencies.
   78:      Most TimedeltaArray behavior is already tested in TimedeltaIndex tests,
   79:     so here we just test that the TimedeltaArray behavior matches
   80:     the TimedeltaIndex behavior.
   81:     """
   82:     # TODO: flesh this out
   83:     return TimedeltaIndex(["1 Day", "3 Hours", "NaT"])
   84: 
   85: 
   86: class SharedTests:
   87:     index_cls: type[DatetimeIndex | PeriodIndex | TimedeltaIndex]
   88: 
   89:     @pytest.fixture
   90:     def arr1d(self):
   91:         """Fixture returning DatetimeArray with daily frequency."""
   92:         data = np.arange(10, dtype="i8") * 24 * 3600 * 10**9
   93:         if self.array_cls is PeriodArray:
   94:             arr = self.array_cls(data, freq="D")
   95:         else:
   96:             arr = self.index_cls(data, freq="D")._data
   97:         return arr
   98: 
   99:     def test_compare_len1_raises(self, arr1d):
  100:         # make sure we raise when comparing with different lengths, specific
  101:         #  to the case where one has length-1, which numpy would broadcast
  102:         arr = arr1d
  103:         idx = self.index_cls(arr)
  104: 
  105:         with pytest.raises(ValueError, match="Lengths must match"):
  106:             arr == arr[:1]
  107: 
  108:         # test the index classes while we're at it, GH#23078
  109:         with pytest.raises(ValueError, match="Lengths must match"):
  110:             idx <= idx[[0]]
  111: 
  112:     @pytest.mark.parametrize(
  113:         "result",
  114:         [
  115:             pd.date_range("2020", periods=3),
  116:             pd.date_range("2020", periods=3, tz="UTC"),
  117:             pd.timedelta_range("0 days", periods=3),
  118:             pd.period_range("2020Q1", periods=3, freq="Q"),
  119:         ],
  120:     )
  121:     def test_compare_with_Categorical(self, result):
  122:         expected = pd.Categorical(result)
  123:         assert all(result == expected)
  124:         assert not any(result != expected)
  125: 
  126:     @pytest.mark.parametrize("reverse", [True, False])
  127:     @pytest.mark.parametrize("as_index", [True, False])
  128:     def test_compare_categorical_dtype(self, arr1d, as_index, reverse, ordered):
  129:         other = pd.Categorical(arr1d, ordered=ordered)
  130:         if as_index:
  131:             other = pd.CategoricalIndex(other)
  132: 
  133:         left, right = arr1d, other
  134:         if reverse:
  135:             left, right = right, left
  136: 
  137:         ones = np.ones(arr1d.shape, dtype=bool)
  138:         zeros = ~ones
  139: 
  140:         result = left == right
  141:         tm.assert_numpy_array_equal(result, ones)
  142: 
  143:         result = left != right
  144:         tm.assert_numpy_array_equal(result, zeros)
  145: 
  146:         if not reverse and not as_index:
  147:             # Otherwise Categorical raises TypeError bc it is not ordered
  148:             # TODO: we should probably get the same behavior regardless?
  149:             result = left < right
  150:             tm.assert_numpy_array_equal(result, zeros)
  151: 
  152:             result = left <= right
  153:             tm.assert_numpy_array_equal(result, ones)
  154: 
  155:             result = left > right
  156:             tm.assert_numpy_array_equal(result, zeros)
  157: 
  158:             result = left >= right
  159:             tm.assert_numpy_array_equal(result, ones)
  160: 
  161:     def test_take(self):
  162:         data = np.arange(100, dtype="i8") * 24 * 3600 * 10**9
  163:         np.random.default_rng(2).shuffle(data)
  164: 
  165:         if self.array_cls is PeriodArray:
  166:             arr = PeriodArray(data, dtype="period[D]")
  167:         else:
  168:             arr = self.index_cls(data)._data
  169:         idx = self.index_cls._simple_new(arr)
  170: 
  171:         takers = [1, 4, 94]
  172:         result = arr.take(takers)
  173:         expected = idx.take(takers)
  174: 
  175:         tm.assert_index_equal(self.index_cls(result), expected)
  176: 
  177:         takers = np.array([1, 4, 94])
  178:         result = arr.take(takers)
  179:         expected = idx.take(takers)
  180: 
  181:         tm.assert_index_equal(self.index_cls(result), expected)
  182: 
  183:     @pytest.mark.parametrize("fill_value", [2, 2.0, Timestamp(2021, 1, 1, 12).time])
  184:     def test_take_fill_raises(self, fill_value, arr1d):
  185:         msg = f"value should be a '{arr1d._scalar_type.__name__}' or 'NaT'. Got"
  186:         with pytest.raises(TypeError, match=msg):
  187:             arr1d.take([0, 1], allow_fill=True, fill_value=fill_value)
  188: 
  189:     def test_take_fill(self, arr1d):
  190:         arr = arr1d
  191: 
  192:         result = arr.take([-1, 1], allow_fill=True, fill_value=None)
  193:         assert result[0] is NaT
  194: 
  195:         result = arr.take([-1, 1], allow_fill=True, fill_value=np.nan)
  196:         assert result[0] is NaT
  197: 
  198:         result = arr.take([-1, 1], allow_fill=True, fill_value=NaT)
  199:         assert result[0] is NaT
  200: 
  201:     @pytest.mark.filterwarnings(
  202:         "ignore:Period with BDay freq is deprecated:FutureWarning"
  203:     )
  204:     def test_take_fill_str(self, arr1d):
  205:         # Cast str fill_value matching other fill_value-taking methods
  206:         result = arr1d.take([-1, 1], allow_fill=True, fill_value=str(arr1d[-1]))
  207:         expected = arr1d[[-1, 1]]
  208:         tm.assert_equal(result, expected)
  209: 
  210:         msg = f"value should be a '{arr1d._scalar_type.__name__}' or 'NaT'. Got"
  211:         with pytest.raises(TypeError, match=msg):
  212:             arr1d.take([-1, 1], allow_fill=True, fill_value="foo")
  213: 
  214:     def test_concat_same_type(self, arr1d):
  215:         arr = arr1d
  216:         idx = self.index_cls(arr)
  217:         idx = idx.insert(0, NaT)
  218:         arr = arr1d
  219: 
  220:         result = arr._concat_same_type([arr[:-1], arr[1:], arr])
  221:         arr2 = arr.astype(object)
  222:         expected = self.index_cls(np.concatenate([arr2[:-1], arr2[1:], arr2]))
  223: 
  224:         tm.assert_index_equal(self.index_cls(result), expected)
  225: 
  226:     def test_unbox_scalar(self, arr1d):
  227:         result = arr1d._unbox_scalar(arr1d[0])
  228:         expected = arr1d._ndarray.dtype.type
  229:         assert isinstance(result, expected)
  230: 
  231:         result = arr1d._unbox_scalar(NaT)
  232:         assert isinstance(result, expected)
  233: 
  234:         msg = f"'value' should be a {self.scalar_type.__name__}."
  235:         with pytest.raises(ValueError, match=msg):
  236:             arr1d._unbox_scalar("foo")
  237: 
  238:     def test_check_compatible_with(self, arr1d):
  239:         arr1d._check_compatible_with(arr1d[0])
  240:         arr1d._check_compatible_with(arr1d[:1])
  241:         arr1d._check_compatible_with(NaT)
  242: 
  243:     def test_scalar_from_string(self, arr1d):
  244:         result = arr1d._scalar_from_string(str(arr1d[0]))
  245:         assert result == arr1d[0]
  246: 
  247:     def test_reduce_invalid(self, arr1d):
  248:         msg = "does not support reduction 'not a method'"
  249:         with pytest.raises(TypeError, match=msg):
  250:             arr1d._reduce("not a method")
  251: 
  252:     @pytest.mark.parametrize("method", ["pad", "backfill"])
  253:     def test_fillna_method_doesnt_change_orig(self, method):
  254:         data = np.arange(10, dtype="i8") * 24 * 3600 * 10**9
  255:         if self.array_cls is PeriodArray:
  256:             arr = self.array_cls(data, dtype="period[D]")
  257:         else:
  258:             arr = self.array_cls._from_sequence(data)
  259:         arr[4] = NaT
  260: 
  261:         fill_value = arr[3] if method == "pad" else arr[5]
  262: 
  263:         result = arr._pad_or_backfill(method=method)
  264:         assert result[4] == fill_value
  265: 
  266:         # check that the original was not changed
  267:         assert arr[4] is NaT
  268: 
  269:     def test_searchsorted(self):
  270:         data = np.arange(10, dtype="i8") * 24 * 3600 * 10**9
  271:         if self.array_cls is PeriodArray:
  272:             arr = self.array_cls(data, dtype="period[D]")
  273:         else:
  274:             arr = self.array_cls._from_sequence(data)
  275: 
  276:         # scalar
  277:         result = arr.searchsorted(arr[1])
  278:         assert result == 1
  279: 
  280:         result = arr.searchsorted(arr[2], side="right")
  281:         assert result == 3
  282: 
  283:         # own-type
  284:         result = arr.searchsorted(arr[1:3])
  285:         expected = np.array([1, 2], dtype=np.intp)
  286:         tm.assert_numpy_array_equal(result, expected)
  287: 
  288:         result = arr.searchsorted(arr[1:3], side="right")
  289:         expected = np.array([2, 3], dtype=np.intp)
  290:         tm.assert_numpy_array_equal(result, expected)
  291: 
  292:         # GH#29884 match numpy convention on whether NaT goes
  293:         #  at the end or the beginning
  294:         result = arr.searchsorted(NaT)
  295:         assert result == 10
  296: 
  297:     @pytest.mark.parametrize("box", [None, "index", "series"])
  298:     def test_searchsorted_castable_strings(self, arr1d, box, string_storage):
  299:         arr = arr1d
  300:         if box is None:
  301:             pass
  302:         elif box == "index":
  303:             # Test the equivalent Index.searchsorted method while we're here
  304:             arr = self.index_cls(arr)
  305:         else:
  306:             # Test the equivalent Series.searchsorted method while we're here
  307:             arr = pd.Series(arr)
  308: 
  309:         # scalar
  310:         result = arr.searchsorted(str(arr[1]))
  311:         assert result == 1
  312: 
  313:         result = arr.searchsorted(str(arr[2]), side="right")
  314:         assert result == 3
  315: 
  316:         result = arr.searchsorted([str(x) for x in arr[1:3]])
  317:         expected = np.array([1, 2], dtype=np.intp)
  318:         tm.assert_numpy_array_equal(result, expected)
  319: 
  320:         with pytest.raises(
  321:             TypeError,
  322:             match=re.escape(
  323:                 f"value should be a '{arr1d._scalar_type.__name__}', 'NaT', "
  324:                 "or array of those. Got 'str' instead."
  325:             ),
  326:         ):
  327:             arr.searchsorted("foo")
  328: 
  329:         with pd.option_context("string_storage", string_storage):
  330:             with pytest.raises(
  331:                 TypeError,
  332:                 match=re.escape(
  333:                     f"value should be a '{arr1d._scalar_type.__name__}', 'NaT', "
  334:                     "or array of those. Got string array instead."
  335:                 ),
  336:             ):
  337:                 arr.searchsorted([str(arr[1]), "baz"])
  338: 
  339:     def test_getitem_near_implementation_bounds(self):
  340:         # We only check tz-naive for DTA bc the bounds are slightly different
  341:         #  for other tzs
  342:         i8vals = np.asarray([NaT._value + n for n in range(1, 5)], dtype="i8")
  343:         if self.array_cls is PeriodArray:
  344:             arr = self.array_cls(i8vals, dtype="period[ns]")
  345:         else:
  346:             arr = self.index_cls(i8vals, freq="ns")._data
  347:         arr[0]  # should not raise OutOfBoundsDatetime
  348: 
  349:         index = pd.Index(arr)
  350:         index[0]  # should not raise OutOfBoundsDatetime
  351: 
  352:         ser = pd.Series(arr)
  353:         ser[0]  # should not raise OutOfBoundsDatetime
  354: 
  355:     def test_getitem_2d(self, arr1d):
  356:         # 2d slicing on a 1D array
  357:         expected = type(arr1d)._simple_new(
  358:             arr1d._ndarray[:, np.newaxis], dtype=arr1d.dtype
  359:         )
  360:         result = arr1d[:, np.newaxis]
  361:         tm.assert_equal(result, expected)
  362: 
  363:         # Lookup on a 2D array
  364:         arr2d = expected
  365:         expected = type(arr2d)._simple_new(arr2d._ndarray[:3, 0], dtype=arr2d.dtype)
  366:         result = arr2d[:3, 0]
  367:         tm.assert_equal(result, expected)
  368: 
  369:         # Scalar lookup
  370:         result = arr2d[-1, 0]
  371:         expected = arr1d[-1]
  372:         assert result == expected
  373: 
  374:     def test_iter_2d(self, arr1d):
  375:         data2d = arr1d._ndarray[:3, np.newaxis]
  376:         arr2d = type(arr1d)._simple_new(data2d, dtype=arr1d.dtype)
  377:         result = list(arr2d)
  378:         assert len(result) == 3
  379:         for x in result:
  380:             assert isinstance(x, type(arr1d))
  381:             assert x.ndim == 1
  382:             assert x.dtype == arr1d.dtype
  383: 
  384:     def test_repr_2d(self, arr1d):
  385:         data2d = arr1d._ndarray[:3, np.newaxis]
  386:         arr2d = type(arr1d)._simple_new(data2d, dtype=arr1d.dtype)
  387: 
  388:         result = repr(arr2d)
  389: 
  390:         if isinstance(arr2d, TimedeltaArray):
  391:             expected = (
  392:                 f"<{type(arr2d).__name__}>\n"
  393:                 "[\n"
  394:                 f"['{arr1d[0]._repr_base()}'],\n"
  395:                 f"['{arr1d[1]._repr_base()}'],\n"
  396:                 f"['{arr1d[2]._repr_base()}']\n"
  397:                 "]\n"
  398:                 f"Shape: (3, 1), dtype: {arr1d.dtype}"
  399:             )
  400:         else:
  401:             expected = (
  402:                 f"<{type(arr2d).__name__}>\n"
  403:                 "[\n"
  404:                 f"['{arr1d[0]}'],\n"
  405:                 f"['{arr1d[1]}'],\n"
  406:                 f"['{arr1d[2]}']\n"
  407:                 "]\n"
  408:                 f"Shape: (3, 1), dtype: {arr1d.dtype}"
  409:             )
  410: 
  411:         assert result == expected
  412: 
  413:     def test_setitem(self):
  414:         data = np.arange(10, dtype="i8") * 24 * 3600 * 10**9
  415:         if self.array_cls is PeriodArray:
  416:             arr = self.array_cls(data, dtype="period[D]")
  417:         else:
  418:             arr = self.index_cls(data, freq="D")._data
  419: 
  420:         arr[0] = arr[1]
  421:         expected = np.arange(10, dtype="i8") * 24 * 3600 * 10**9
  422:         expected[0] = expected[1]
  423: 
  424:         tm.assert_numpy_array_equal(arr.asi8, expected)
  425: 
  426:         arr[:2] = arr[-2:]
  427:         expected[:2] = expected[-2:]
  428:         tm.assert_numpy_array_equal(arr.asi8, expected)
  429: 
  430:     @pytest.mark.parametrize(
  431:         "box",
  432:         [
  433:             pd.Index,
  434:             pd.Series,
  435:             np.array,
  436:             list,
  437:             NumpyExtensionArray,
  438:         ],
  439:     )
  440:     def test_setitem_object_dtype(self, box, arr1d):
  441:         expected = arr1d.copy()[::-1]
  442:         if expected.dtype.kind in ["m", "M"]:
  443:             expected = expected._with_freq(None)
  444: 
  445:         vals = expected
  446:         if box is list:
  447:             vals = list(vals)
  448:         elif box is np.array:
  449:             # if we do np.array(x).astype(object) then dt64 and td64 cast to ints
  450:             vals = np.array(vals.astype(object))
  451:         elif box is NumpyExtensionArray:
  452:             vals = box(np.asarray(vals, dtype=object))
  453:         else:
  454:             vals = box(vals).astype(object)
  455: 
  456:         arr1d[:] = vals
  457: 
  458:         tm.assert_equal(arr1d, expected)
  459: 
  460:     def test_setitem_strs(self, arr1d):
  461:         # Check that we parse strs in both scalar and listlike
  462: 
  463:         # Setting list-like of strs
  464:         expected = arr1d.copy()
  465:         expected[[0, 1]] = arr1d[-2:]
  466: 
  467:         result = arr1d.copy()
  468:         result[:2] = [str(x) for x in arr1d[-2:]]
  469:         tm.assert_equal(result, expected)
  470: 
  471:         # Same thing but now for just a scalar str
  472:         expected = arr1d.copy()
  473:         expected[0] = arr1d[-1]
  474: 
  475:         result = arr1d.copy()
  476:         result[0] = str(arr1d[-1])
  477:         tm.assert_equal(result, expected)
  478: 
  479:     @pytest.mark.parametrize("as_index", [True, False])
  480:     def test_setitem_categorical(self, arr1d, as_index):
  481:         expected = arr1d.copy()[::-1]
  482:         if not isinstance(expected, PeriodArray):
  483:             expected = expected._with_freq(None)
  484: 
  485:         cat = pd.Categorical(arr1d)
  486:         if as_index:
  487:             cat = pd.CategoricalIndex(cat)
  488: 
  489:         arr1d[:] = cat[::-1]
  490: 
  491:         tm.assert_equal(arr1d, expected)
  492: 
  493:     def test_setitem_raises(self, arr1d):
  494:         arr = arr1d[:10]
  495:         val = arr[0]
  496: 
  497:         with pytest.raises(IndexError, match="index 12 is out of bounds"):
  498:             arr[12] = val
  499: 
  500:         with pytest.raises(TypeError, match="value should be a.* 'object'"):
  501:             arr[0] = object()
  502: 
  503:         msg = "cannot set using a list-like indexer with a different length"
  504:         with pytest.raises(ValueError, match=msg):
  505:             # GH#36339
  506:             arr[[]] = [arr[1]]
  507: 
  508:         msg = "cannot set using a slice indexer with a different length than"
  509:         with pytest.raises(ValueError, match=msg):
  510:             # GH#36339
  511:             arr[1:1] = arr[:3]
  512: 
  513:     @pytest.mark.parametrize("box", [list, np.array, pd.Index, pd.Series])
  514:     def test_setitem_numeric_raises(self, arr1d, box):
  515:         # We dont case e.g. int64 to our own dtype for setitem
  516: 
  517:         msg = (
  518:             f"value should be a '{arr1d._scalar_type.__name__}', "
  519:             "'NaT', or array of those. Got"
  520:         )
  521:         with pytest.raises(TypeError, match=msg):
  522:             arr1d[:2] = box([0, 1])
  523: 
  524:         with pytest.raises(TypeError, match=msg):
  525:             arr1d[:2] = box([0.0, 1.0])
  526: 
  527:     def test_inplace_arithmetic(self):
  528:         # GH#24115 check that iadd and isub are actually in-place
  529:         data = np.arange(10, dtype="i8") * 24 * 3600 * 10**9
  530:         if self.array_cls is PeriodArray:
  531:             arr = self.array_cls(data, dtype="period[D]")
  532:         else:
  533:             arr = self.index_cls(data, freq="D")._data
  534: 
  535:         expected = arr + pd.Timedelta(days=1)
  536:         arr += pd.Timedelta(days=1)
  537:         tm.assert_equal(arr, expected)
  538: 
  539:         expected = arr - pd.Timedelta(days=1)
  540:         arr -= pd.Timedelta(days=1)
  541:         tm.assert_equal(arr, expected)
  542: 
  543:     def test_shift_fill_int_deprecated(self, arr1d):
  544:         # GH#31971, enforced in 2.0
  545:         with pytest.raises(TypeError, match="value should be a"):
  546:             arr1d.shift(1, fill_value=1)
  547: 
  548:     def test_median(self, arr1d):
  549:         arr = arr1d
  550:         if len(arr) % 2 == 0:
  551:             # make it easier to define `expected`
  552:             arr = arr[:-1]
  553: 
  554:         expected = arr[len(arr) // 2]
  555: 
  556:         result = arr.median()
  557:         assert type(result) is type(expected)
  558:         assert result == expected
  559: 
  560:         arr[len(arr) // 2] = NaT
  561:         if not isinstance(expected, Period):
  562:             expected = arr[len(arr) // 2 - 1 : len(arr) // 2 + 2].mean()
  563: 
  564:         assert arr.median(skipna=False) is NaT
  565: 
  566:         result = arr.median()
  567:         assert type(result) is type(expected)
  568:         assert result == expected
  569: 
  570:         assert arr[:0].median() is NaT
  571:         assert arr[:0].median(skipna=False) is NaT
  572: 
  573:         # 2d Case
  574:         arr2 = arr.reshape(-1, 1)
  575: 
  576:         result = arr2.median(axis=None)
  577:         assert type(result) is type(expected)
  578:         assert result == expected
  579: 
  580:         assert arr2.median(axis=None, skipna=False) is NaT
  581: 
  582:         result = arr2.median(axis=0)
  583:         expected2 = type(arr)._from_sequence([expected], dtype=arr.dtype)
  584:         tm.assert_equal(result, expected2)
  585: 
  586:         result = arr2.median(axis=0, skipna=False)
  587:         expected2 = type(arr)._from_sequence([NaT], dtype=arr.dtype)
  588:         tm.assert_equal(result, expected2)
  589: 
  590:         result = arr2.median(axis=1)
  591:         tm.assert_equal(result, arr)
  592: 
  593:         result = arr2.median(axis=1, skipna=False)
  594:         tm.assert_equal(result, arr)
  595: 
  596:     def test_from_integer_array(self):
  597:         arr = np.array([1, 2, 3], dtype=np.int64)
  598:         data = pd.array(arr, dtype="Int64")
  599:         if self.array_cls is PeriodArray:
  600:             expected = self.array_cls(arr, dtype=self.example_dtype)
  601:             result = self.array_cls(data, dtype=self.example_dtype)
  602:         else:
  603:             expected = self.array_cls._from_sequence(arr, dtype=self.example_dtype)
  604:             result = self.array_cls._from_sequence(data, dtype=self.example_dtype)
  605: 
  606:         tm.assert_extension_array_equal(result, expected)
  607: 
  608: 
  609: class TestDatetimeArray(SharedTests):
  610:     index_cls = DatetimeIndex
  611:     array_cls = DatetimeArray
  612:     scalar_type = Timestamp
  613:     example_dtype = "M8[ns]"
  614: 
  615:     @pytest.fixture
  616:     def arr1d(self, tz_naive_fixture, freqstr):
  617:         """
  618:         Fixture returning DatetimeArray with parametrized frequency and
  619:         timezones
  620:         """
  621:         tz = tz_naive_fixture
  622:         dti = pd.date_range("2016-01-01 01:01:00", periods=5, freq=freqstr, tz=tz)
  623:         dta = dti._data
  624:         return dta
  625: 
  626:     def test_round(self, arr1d):
  627:         # GH#24064
  628:         dti = self.index_cls(arr1d)
  629: 
  630:         result = dti.round(freq="2min")
  631:         expected = dti - pd.Timedelta(minutes=1)
  632:         expected = expected._with_freq(None)
  633:         tm.assert_index_equal(result, expected)
  634: 
  635:         dta = dti._data
  636:         result = dta.round(freq="2min")
  637:         expected = expected._data._with_freq(None)
  638:         tm.assert_datetime_array_equal(result, expected)
  639: 
  640:     def test_array_interface(self, datetime_index):
  641:         arr = datetime_index._data
  642:         copy_false = None if np_version_gt2 else False
  643: 
  644:         # default asarray gives the same underlying data (for tz naive)
  645:         result = np.asarray(arr)
  646:         expected = arr._ndarray
  647:         assert result is expected
  648:         tm.assert_numpy_array_equal(result, expected)
  649:         result = np.array(arr, copy=copy_false)
  650:         assert result is expected
  651:         tm.assert_numpy_array_equal(result, expected)
  652: 
  653:         # specifying M8[ns] gives the same result as default
  654:         result = np.asarray(arr, dtype="datetime64[ns]")
  655:         expected = arr._ndarray
  656:         assert result is expected
  657:         tm.assert_numpy_array_equal(result, expected)
  658:         result = np.array(arr, dtype="datetime64[ns]", copy=copy_false)
  659:         assert result is expected
  660:         tm.assert_numpy_array_equal(result, expected)
  661:         result = np.array(arr, dtype="datetime64[ns]")
  662:         assert result is not expected
  663:         tm.assert_numpy_array_equal(result, expected)
  664: 
  665:         # to object dtype
  666:         result = np.asarray(arr, dtype=object)
  667:         expected = np.array(list(arr), dtype=object)
  668:         tm.assert_numpy_array_equal(result, expected)
  669: 
  670:         # to other dtype always copies
  671:         result = np.asarray(arr, dtype="int64")
  672:         assert result is not arr.asi8
  673:         assert not np.may_share_memory(arr, result)
  674:         expected = arr.asi8.copy()
  675:         tm.assert_numpy_array_equal(result, expected)
  676: 
  677:         # other dtypes handled by numpy
  678:         for dtype in ["float64", str]:
  679:             result = np.asarray(arr, dtype=dtype)
  680:             expected = np.asarray(arr).astype(dtype)
  681:             tm.assert_numpy_array_equal(result, expected)
  682: 
  683:     def test_array_object_dtype(self, arr1d):
  684:         # GH#23524
  685:         arr = arr1d
  686:         dti = self.index_cls(arr1d)
  687: 
  688:         expected = np.array(list(dti))
  689: 
  690:         result = np.array(arr, dtype=object)
  691:         tm.assert_numpy_array_equal(result, expected)
  692: 
  693:         # also test the DatetimeIndex method while we're at it
  694:         result = np.array(dti, dtype=object)
  695:         tm.assert_numpy_array_equal(result, expected)
  696: 
  697:     def test_array_tz(self, arr1d):
  698:         # GH#23524
  699:         arr = arr1d
  700:         dti = self.index_cls(arr1d)
  701:         copy_false = None if np_version_gt2 else False
  702: 
  703:         expected = dti.asi8.view("M8[ns]")
  704:         result = np.array(arr, dtype="M8[ns]")
  705:         tm.assert_numpy_array_equal(result, expected)
  706: 
  707:         result = np.array(arr, dtype="datetime64[ns]")
  708:         tm.assert_numpy_array_equal(result, expected)
  709: 
  710:         # check that we are not making copies when setting copy=copy_false
  711:         result = np.array(arr, dtype="M8[ns]", copy=copy_false)
  712:         assert result.base is expected.base
  713:         assert result.base is not None
  714:         result = np.array(arr, dtype="datetime64[ns]", copy=copy_false)
  715:         assert result.base is expected.base
  716:         assert result.base is not None
  717: 
  718:     def test_array_i8_dtype(self, arr1d):
  719:         arr = arr1d
  720:         dti = self.index_cls(arr1d)
  721:         copy_false = None if np_version_gt2 else False
  722: 
  723:         expected = dti.asi8
  724:         result = np.array(arr, dtype="i8")
  725:         tm.assert_numpy_array_equal(result, expected)
  726: 
  727:         result = np.array(arr, dtype=np.int64)
  728:         tm.assert_numpy_array_equal(result, expected)
  729: 
  730:         # check that we are still making copies when setting copy=copy_false
  731:         result = np.array(arr, dtype="i8", copy=copy_false)
  732:         assert result.base is not expected.base
  733:         assert result.base is None
  734: 
  735:     def test_from_array_keeps_base(self):
  736:         # Ensure that DatetimeArray._ndarray.base isn't lost.
  737:         arr = np.array(["2000-01-01", "2000-01-02"], dtype="M8[ns]")
  738:         dta = DatetimeArray._from_sequence(arr)
  739: 
  740:         assert dta._ndarray is arr
  741:         dta = DatetimeArray._from_sequence(arr[:0])
  742:         assert dta._ndarray.base is arr
  743: 
  744:     def test_from_dti(self, arr1d):
  745:         arr = arr1d
  746:         dti = self.index_cls(arr1d)
  747:         assert list(dti) == list(arr)
  748: 
  749:         # Check that Index.__new__ knows what to do with DatetimeArray
  750:         dti2 = pd.Index(arr)
  751:         assert isinstance(dti2, DatetimeIndex)
  752:         assert list(dti2) == list(arr)
  753: 
  754:     def test_astype_object(self, arr1d):
  755:         arr = arr1d
  756:         dti = self.index_cls(arr1d)
  757: 
  758:         asobj = arr.astype("O")
  759:         assert isinstance(asobj, np.ndarray)
  760:         assert asobj.dtype == "O"
  761:         assert list(asobj) == list(dti)
  762: 
  763:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  764:     def test_to_period(self, datetime_index, freqstr):
  765:         dti = datetime_index
  766:         arr = dti._data
  767: 
  768:         freqstr = freq_to_period_freqstr(1, freqstr)
  769:         expected = dti.to_period(freq=freqstr)
  770:         result = arr.to_period(freq=freqstr)
  771:         assert isinstance(result, PeriodArray)
  772: 
  773:         tm.assert_equal(result, expected._data)
  774: 
  775:     def test_to_period_2d(self, arr1d):
  776:         arr2d = arr1d.reshape(1, -1)
  777: 
  778:         warn = None if arr1d.tz is None else UserWarning
  779:         with tm.assert_produces_warning(warn):
  780:             result = arr2d.to_period("D")
  781:             expected = arr1d.to_period("D").reshape(1, -1)
  782:         tm.assert_period_array_equal(result, expected)
  783: 
  784:     @pytest.mark.parametrize("propname", DatetimeArray._bool_ops)
  785:     def test_bool_properties(self, arr1d, propname):
  786:         # in this case _bool_ops is just `is_leap_year`
  787:         dti = self.index_cls(arr1d)
  788:         arr = arr1d
  789:         assert dti.freq == arr.freq
  790: 
  791:         result = getattr(arr, propname)
  792:         expected = np.array(getattr(dti, propname), dtype=result.dtype)
  793: 
  794:         tm.assert_numpy_array_equal(result, expected)
  795: 
  796:     @pytest.mark.parametrize("propname", DatetimeArray._field_ops)
  797:     def test_int_properties(self, arr1d, propname):
  798:         dti = self.index_cls(arr1d)
  799:         arr = arr1d
  800: 
  801:         result = getattr(arr, propname)
  802:         expected = np.array(getattr(dti, propname), dtype=result.dtype)
  803: 
  804:         tm.assert_numpy_array_equal(result, expected)
  805: 
  806:     def test_take_fill_valid(self, arr1d, fixed_now_ts):
  807:         arr = arr1d
  808:         dti = self.index_cls(arr1d)
  809: 
  810:         now = fixed_now_ts.tz_localize(dti.tz)
  811:         result = arr.take([-1, 1], allow_fill=True, fill_value=now)
  812:         assert result[0] == now
  813: 
  814:         msg = f"value should be a '{arr1d._scalar_type.__name__}' or 'NaT'. Got"
  815:         with pytest.raises(TypeError, match=msg):
  816:             # fill_value Timedelta invalid
  817:             arr.take([-1, 1], allow_fill=True, fill_value=now - now)
  818: 
  819:         with pytest.raises(TypeError, match=msg):
  820:             # fill_value Period invalid
  821:             arr.take([-1, 1], allow_fill=True, fill_value=Period("2014Q1"))
  822: 
  823:         tz = None if dti.tz is not None else "US/Eastern"
  824:         now = fixed_now_ts.tz_localize(tz)
  825:         msg = "Cannot compare tz-naive and tz-aware datetime-like objects"
  826:         with pytest.raises(TypeError, match=msg):
  827:             # Timestamp with mismatched tz-awareness
  828:             arr.take([-1, 1], allow_fill=True, fill_value=now)
  829: 
  830:         value = NaT._value
  831:         msg = f"value should be a '{arr1d._scalar_type.__name__}' or 'NaT'. Got"
  832:         with pytest.raises(TypeError, match=msg):
  833:             # require NaT, not iNaT, as it could be confused with an integer
  834:             arr.take([-1, 1], allow_fill=True, fill_value=value)
  835: 
  836:         value = np.timedelta64("NaT", "ns")
  837:         with pytest.raises(TypeError, match=msg):
  838:             # require appropriate-dtype if we have a NA value
  839:             arr.take([-1, 1], allow_fill=True, fill_value=value)
  840: 
  841:         if arr.tz is not None:
  842:             # GH#37356
  843:             # Assuming here that arr1d fixture does not include Australia/Melbourne
  844:             value = fixed_now_ts.tz_localize("Australia/Melbourne")
  845:             result = arr.take([-1, 1], allow_fill=True, fill_value=value)
  846: 
  847:             expected = arr.take(
  848:                 [-1, 1],
  849:                 allow_fill=True,
  850:                 fill_value=value.tz_convert(arr.dtype.tz),
  851:             )
  852:             tm.assert_equal(result, expected)
  853: 
  854:     def test_concat_same_type_invalid(self, arr1d):
  855:         # different timezones
  856:         arr = arr1d
  857: 
  858:         if arr.tz is None:
  859:             other = arr.tz_localize("UTC")
  860:         else:
  861:             other = arr.tz_localize(None)
  862: 
  863:         with pytest.raises(ValueError, match="to_concat must have the same"):
  864:             arr._concat_same_type([arr, other])
  865: 
  866:     def test_concat_same_type_different_freq(self, unit):
  867:         # we *can* concatenate DTI with different freqs.
  868:         a = pd.date_range("2000", periods=2, freq="D", tz="US/Central", unit=unit)._data
  869:         b = pd.date_range("2000", periods=2, freq="h", tz="US/Central", unit=unit)._data
  870:         result = DatetimeArray._concat_same_type([a, b])
  871:         expected = (
  872:             pd.to_datetime(
  873:                 [
  874:                     "2000-01-01 00:00:00",
  875:                     "2000-01-02 00:00:00",
  876:                     "2000-01-01 00:00:00",
  877:                     "2000-01-01 01:00:00",
  878:                 ]
  879:             )
  880:             .tz_localize("US/Central")
  881:             .as_unit(unit)
  882:             ._data
  883:         )
  884: 
  885:         tm.assert_datetime_array_equal(result, expected)
  886: 
  887:     def test_strftime(self, arr1d):
  888:         arr = arr1d
  889: 
  890:         result = arr.strftime("%Y %b")
  891:         expected = np.array([ts.strftime("%Y %b") for ts in arr], dtype=object)
  892:         tm.assert_numpy_array_equal(result, expected)
  893: 
  894:     def test_strftime_nat(self):
  895:         # GH 29578
  896:         arr = DatetimeIndex(["2019-01-01", NaT])._data
  897: 
  898:         result = arr.strftime("%Y-%m-%d")
  899:         expected = np.array(["2019-01-01", np.nan], dtype=object)
  900:         tm.assert_numpy_array_equal(result, expected)
  901: 
  902: 
  903: class TestTimedeltaArray(SharedTests):
  904:     index_cls = TimedeltaIndex
  905:     array_cls = TimedeltaArray
  906:     scalar_type = pd.Timedelta
  907:     example_dtype = "m8[ns]"
  908: 
  909:     def test_from_tdi(self):
  910:         tdi = TimedeltaIndex(["1 Day", "3 Hours"])
  911:         arr = tdi._data
  912:         assert list(arr) == list(tdi)
  913: 
  914:         # Check that Index.__new__ knows what to do with TimedeltaArray
  915:         tdi2 = pd.Index(arr)
  916:         assert isinstance(tdi2, TimedeltaIndex)
  917:         assert list(tdi2) == list(arr)
  918: 
  919:     def test_astype_object(self):
  920:         tdi = TimedeltaIndex(["1 Day", "3 Hours"])
  921:         arr = tdi._data
  922:         asobj = arr.astype("O")
  923:         assert isinstance(asobj, np.ndarray)
  924:         assert asobj.dtype == "O"
  925:         assert list(asobj) == list(tdi)
  926: 
  927:     def test_to_pytimedelta(self, timedelta_index):
  928:         tdi = timedelta_index
  929:         arr = tdi._data
  930: 
  931:         expected = tdi.to_pytimedelta()
  932:         result = arr.to_pytimedelta()
  933: 
  934:         tm.assert_numpy_array_equal(result, expected)
  935: 
  936:     def test_total_seconds(self, timedelta_index):
  937:         tdi = timedelta_index
  938:         arr = tdi._data
  939: 
  940:         expected = tdi.total_seconds()
  941:         result = arr.total_seconds()
  942: 
  943:         tm.assert_numpy_array_equal(result, expected.values)
  944: 
  945:     @pytest.mark.parametrize("propname", TimedeltaArray._field_ops)
  946:     def test_int_properties(self, timedelta_index, propname):
  947:         tdi = timedelta_index
  948:         arr = tdi._data
  949: 
  950:         result = getattr(arr, propname)
  951:         expected = np.array(getattr(tdi, propname), dtype=result.dtype)
  952: 
  953:         tm.assert_numpy_array_equal(result, expected)
  954: 
  955:     def test_array_interface(self, timedelta_index):
  956:         arr = timedelta_index._data
  957:         copy_false = None if np_version_gt2 else False
  958: 
  959:         # default asarray gives the same underlying data
  960:         result = np.asarray(arr)
  961:         expected = arr._ndarray
  962:         assert result is expected
  963:         tm.assert_numpy_array_equal(result, expected)
  964:         result = np.array(arr, copy=copy_false)
  965:         assert result is expected
  966:         tm.assert_numpy_array_equal(result, expected)
  967: 
  968:         # specifying m8[ns] gives the same result as default
  969:         result = np.asarray(arr, dtype="timedelta64[ns]")
  970:         expected = arr._ndarray
  971:         assert result is expected
  972:         tm.assert_numpy_array_equal(result, expected)
  973:         result = np.array(arr, dtype="timedelta64[ns]", copy=copy_false)
  974:         assert result is expected
  975:         tm.assert_numpy_array_equal(result, expected)
  976:         result = np.array(arr, dtype="timedelta64[ns]")
  977:         assert result is not expected
  978:         tm.assert_numpy_array_equal(result, expected)
  979: 
  980:         # to object dtype
  981:         result = np.asarray(arr, dtype=object)
  982:         expected = np.array(list(arr), dtype=object)
  983:         tm.assert_numpy_array_equal(result, expected)
  984: 
  985:         # to other dtype always copies
  986:         result = np.asarray(arr, dtype="int64")
  987:         assert result is not arr.asi8
  988:         assert not np.may_share_memory(arr, result)
  989:         expected = arr.asi8.copy()
  990:         tm.assert_numpy_array_equal(result, expected)
  991: 
  992:         # other dtypes handled by numpy
  993:         for dtype in ["float64", str]:
  994:             result = np.asarray(arr, dtype=dtype)
  995:             expected = np.asarray(arr).astype(dtype)
  996:             tm.assert_numpy_array_equal(result, expected)
  997: 
  998:     def test_take_fill_valid(self, timedelta_index, fixed_now_ts):
  999:         tdi = timedelta_index
 1000:         arr = tdi._data
 1001: 
 1002:         td1 = pd.Timedelta(days=1)
 1003:         result = arr.take([-1, 1], allow_fill=True, fill_value=td1)
 1004:         assert result[0] == td1
 1005: 
 1006:         value = fixed_now_ts
 1007:         msg = f"value should be a '{arr._scalar_type.__name__}' or 'NaT'. Got"
 1008:         with pytest.raises(TypeError, match=msg):
 1009:             # fill_value Timestamp invalid
 1010:             arr.take([0, 1], allow_fill=True, fill_value=value)
 1011: 
 1012:         value = fixed_now_ts.to_period("D")
 1013:         with pytest.raises(TypeError, match=msg):
 1014:             # fill_value Period invalid
 1015:             arr.take([0, 1], allow_fill=True, fill_value=value)
 1016: 
 1017:         value = np.datetime64("NaT", "ns")
 1018:         with pytest.raises(TypeError, match=msg):
 1019:             # require appropriate-dtype if we have a NA value
 1020:             arr.take([-1, 1], allow_fill=True, fill_value=value)
 1021: 
 1022: 
 1023: @pytest.mark.filterwarnings(r"ignore:Period with BDay freq is deprecated:FutureWarning")
 1024: @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
 1025: class TestPeriodArray(SharedTests):
 1026:     index_cls = PeriodIndex
 1027:     array_cls = PeriodArray
 1028:     scalar_type = Period
 1029:     example_dtype = PeriodIndex([], freq="W").dtype
 1030: 
 1031:     @pytest.fixture
 1032:     def arr1d(self, period_index):
 1033:         """
 1034:         Fixture returning DatetimeArray from parametrized PeriodIndex objects
 1035:         """
 1036:         return period_index._data
 1037: 
 1038:     def test_from_pi(self, arr1d):
 1039:         pi = self.index_cls(arr1d)
 1040:         arr = arr1d
 1041:         assert list(arr) == list(pi)
 1042: 
 1043:         # Check that Index.__new__ knows what to do with PeriodArray
 1044:         pi2 = pd.Index(arr)
 1045:         assert isinstance(pi2, PeriodIndex)
 1046:         assert list(pi2) == list(arr)
 1047: 
 1048:     def test_astype_object(self, arr1d):
 1049:         pi = self.index_cls(arr1d)
 1050:         arr = arr1d
 1051:         asobj = arr.astype("O")
 1052:         assert isinstance(asobj, np.ndarray)
 1053:         assert asobj.dtype == "O"
 1054:         assert list(asobj) == list(pi)
 1055: 
 1056:     def test_take_fill_valid(self, arr1d):
 1057:         arr = arr1d
 1058: 
 1059:         value = NaT._value
 1060:         msg = f"value should be a '{arr1d._scalar_type.__name__}' or 'NaT'. Got"
 1061:         with pytest.raises(TypeError, match=msg):
 1062:             # require NaT, not iNaT, as it could be confused with an integer
 1063:             arr.take([-1, 1], allow_fill=True, fill_value=value)
 1064: 
 1065:         value = np.timedelta64("NaT", "ns")
 1066:         with pytest.raises(TypeError, match=msg):
 1067:             # require appropriate-dtype if we have a NA value
 1068:             arr.take([-1, 1], allow_fill=True, fill_value=value)
 1069: 
 1070:     @pytest.mark.parametrize("how", ["S", "E"])
 1071:     def test_to_timestamp(self, how, arr1d):
 1072:         pi = self.index_cls(arr1d)
 1073:         arr = arr1d
 1074: 
 1075:         expected = DatetimeIndex(pi.to_timestamp(how=how))._data
 1076:         result = arr.to_timestamp(how=how)
 1077:         assert isinstance(result, DatetimeArray)
 1078: 
 1079:         tm.assert_equal(result, expected)
 1080: 
 1081:     def test_to_timestamp_roundtrip_bday(self):
 1082:         # Case where infer_freq inside would choose "D" instead of "B"
 1083:         dta = pd.date_range("2021-10-18", periods=3, freq="B")._data
 1084:         parr = dta.to_period()
 1085:         result = parr.to_timestamp()
 1086:         assert result.freq == "B"
 1087:         tm.assert_extension_array_equal(result, dta)
 1088: 
 1089:         dta2 = dta[::2]
 1090:         parr2 = dta2.to_period()
 1091:         result2 = parr2.to_timestamp()
 1092:         assert result2.freq == "2B"
 1093:         tm.assert_extension_array_equal(result2, dta2)
 1094: 
 1095:         parr3 = dta.to_period("2B")
 1096:         result3 = parr3.to_timestamp()
 1097:         assert result3.freq == "B"
 1098:         tm.assert_extension_array_equal(result3, dta)
 1099: 
 1100:     def test_to_timestamp_out_of_bounds(self):
 1101:         # GH#19643 previously overflowed silently
 1102:         pi = pd.period_range("1500", freq="Y", periods=3)
 1103:         msg = "Out of bounds nanosecond timestamp: 1500-01-01 00:00:00"
 1104:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 1105:             pi.to_timestamp()
 1106: 
 1107:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 1108:             pi._data.to_timestamp()
 1109: 
 1110:     @pytest.mark.parametrize("propname", PeriodArray._bool_ops)
 1111:     def test_bool_properties(self, arr1d, propname):
 1112:         # in this case _bool_ops is just `is_leap_year`
 1113:         pi = self.index_cls(arr1d)
 1114:         arr = arr1d
 1115: 
 1116:         result = getattr(arr, propname)
 1117:         expected = np.array(getattr(pi, propname))
 1118: 
 1119:         tm.assert_numpy_array_equal(result, expected)
 1120: 
 1121:     @pytest.mark.parametrize("propname", PeriodArray._field_ops)
 1122:     def test_int_properties(self, arr1d, propname):
 1123:         pi = self.index_cls(arr1d)
 1124:         arr = arr1d
 1125: 
 1126:         result = getattr(arr, propname)
 1127:         expected = np.array(getattr(pi, propname))
 1128: 
 1129:         tm.assert_numpy_array_equal(result, expected)
 1130: 
 1131:     def test_array_interface(self, arr1d):
 1132:         arr = arr1d
 1133: 
 1134:         # default asarray gives objects
 1135:         result = np.asarray(arr)
 1136:         expected = np.array(list(arr), dtype=object)
 1137:         tm.assert_numpy_array_equal(result, expected)
 1138: 
 1139:         # to object dtype (same as default)
 1140:         result = np.asarray(arr, dtype=object)
 1141:         tm.assert_numpy_array_equal(result, expected)
 1142: 
 1143:         result = np.asarray(arr, dtype="int64")
 1144:         tm.assert_numpy_array_equal(result, arr.asi8)
 1145: 
 1146:         # to other dtypes
 1147:         msg = r"float\(\) argument must be a string or a( real)? number, not 'Period'"
 1148:         with pytest.raises(TypeError, match=msg):
 1149:             np.asarray(arr, dtype="float64")
 1150: 
 1151:         result = np.asarray(arr, dtype="S20")
 1152:         expected = np.asarray(arr).astype("S20")
 1153:         tm.assert_numpy_array_equal(result, expected)
 1154: 
 1155:     def test_strftime(self, arr1d):
 1156:         arr = arr1d
 1157: 
 1158:         result = arr.strftime("%Y")
 1159:         expected = np.array([per.strftime("%Y") for per in arr], dtype=object)
 1160:         tm.assert_numpy_array_equal(result, expected)
 1161: 
 1162:     def test_strftime_nat(self):
 1163:         # GH 29578
 1164:         arr = PeriodArray(PeriodIndex(["2019-01-01", NaT], dtype="period[D]"))
 1165: 
 1166:         result = arr.strftime("%Y-%m-%d")
 1167:         expected = np.array(["2019-01-01", np.nan], dtype=object)
 1168:         tm.assert_numpy_array_equal(result, expected)
 1169: 
 1170: 
 1171: @pytest.mark.parametrize(
 1172:     "arr,casting_nats",
 1173:     [
 1174:         (
 1175:             TimedeltaIndex(["1 Day", "3 Hours", "NaT"])._data,
 1176:             (NaT, np.timedelta64("NaT", "ns")),
 1177:         ),
 1178:         (
 1179:             pd.date_range("2000-01-01", periods=3, freq="D")._data,
 1180:             (NaT, np.datetime64("NaT", "ns")),
 1181:         ),
 1182:         (pd.period_range("2000-01-01", periods=3, freq="D")._data, (NaT,)),
 1183:     ],
 1184:     ids=lambda x: type(x).__name__,
 1185: )
 1186: def test_casting_nat_setitem_array(arr, casting_nats):
 1187:     expected = type(arr)._from_sequence([NaT, arr[1], arr[2]], dtype=arr.dtype)
 1188: 
 1189:     for nat in casting_nats:
 1190:         arr = arr.copy()
 1191:         arr[0] = nat
 1192:         tm.assert_equal(arr, expected)
 1193: 
 1194: 
 1195: @pytest.mark.parametrize(
 1196:     "arr,non_casting_nats",
 1197:     [
 1198:         (
 1199:             TimedeltaIndex(["1 Day", "3 Hours", "NaT"])._data,
 1200:             (np.datetime64("NaT", "ns"), NaT._value),
 1201:         ),
 1202:         (
 1203:             pd.date_range("2000-01-01", periods=3, freq="D")._data,
 1204:             (np.timedelta64("NaT", "ns"), NaT._value),
 1205:         ),
 1206:         (
 1207:             pd.period_range("2000-01-01", periods=3, freq="D")._data,
 1208:             (np.datetime64("NaT", "ns"), np.timedelta64("NaT", "ns"), NaT._value),
 1209:         ),
 1210:     ],
 1211:     ids=lambda x: type(x).__name__,
 1212: )
 1213: def test_invalid_nat_setitem_array(arr, non_casting_nats):
 1214:     msg = (
 1215:         "value should be a '(Timestamp|Timedelta|Period)', 'NaT', or array of those. "
 1216:         "Got '(timedelta64|datetime64|int)' instead."
 1217:     )
 1218: 
 1219:     for nat in non_casting_nats:
 1220:         with pytest.raises(TypeError, match=msg):
 1221:             arr[0] = nat
 1222: 
 1223: 
 1224: @pytest.mark.parametrize(
 1225:     "arr",
 1226:     [
 1227:         pd.date_range("2000", periods=4).array,
 1228:         pd.timedelta_range("2000", periods=4).array,
 1229:     ],
 1230: )
 1231: def test_to_numpy_extra(arr):
 1232:     arr[0] = NaT
 1233:     original = arr.copy()
 1234: 
 1235:     result = arr.to_numpy()
 1236:     assert np.isnan(result[0])
 1237: 
 1238:     result = arr.to_numpy(dtype="int64")
 1239:     assert result[0] == -9223372036854775808
 1240: 
 1241:     result = arr.to_numpy(dtype="int64", na_value=0)
 1242:     assert result[0] == 0
 1243: 
 1244:     result = arr.to_numpy(na_value=arr[1].to_numpy())
 1245:     assert result[0] == result[1]
 1246: 
 1247:     result = arr.to_numpy(na_value=arr[1].to_numpy(copy=False))
 1248:     assert result[0] == result[1]
 1249: 
 1250:     tm.assert_equal(arr, original)
 1251: 
 1252: 
 1253: @pytest.mark.parametrize("as_index", [True, False])
 1254: @pytest.mark.parametrize(
 1255:     "values",
 1256:     [
 1257:         pd.to_datetime(["2020-01-01", "2020-02-01"]),
 1258:         pd.to_timedelta([1, 2], unit="D"),
 1259:         PeriodIndex(["2020-01-01", "2020-02-01"], freq="D"),
 1260:     ],
 1261: )
 1262: @pytest.mark.parametrize(
 1263:     "klass",
 1264:     [
 1265:         list,
 1266:         np.array,
 1267:         pd.array,
 1268:         pd.Series,
 1269:         pd.Index,
 1270:         pd.Categorical,
 1271:         pd.CategoricalIndex,
 1272:     ],
 1273: )
 1274: def test_searchsorted_datetimelike_with_listlike(values, klass, as_index):
 1275:     # https://github.com/pandas-dev/pandas/issues/32762
 1276:     if not as_index:
 1277:         values = values._data
 1278: 
 1279:     result = values.searchsorted(klass(values))
 1280:     expected = np.array([0, 1], dtype=result.dtype)
 1281: 
 1282:     tm.assert_numpy_array_equal(result, expected)
 1283: 
 1284: 
 1285: @pytest.mark.parametrize(
 1286:     "values",
 1287:     [
 1288:         pd.to_datetime(["2020-01-01", "2020-02-01"]),
 1289:         pd.to_timedelta([1, 2], unit="D"),
 1290:         PeriodIndex(["2020-01-01", "2020-02-01"], freq="D"),
 1291:     ],
 1292: )
 1293: @pytest.mark.parametrize(
 1294:     "arg", [[1, 2], ["a", "b"], [Timestamp("2020-01-01", tz="Europe/London")] * 2]
 1295: )
 1296: def test_searchsorted_datetimelike_with_listlike_invalid_dtype(values, arg):
 1297:     # https://github.com/pandas-dev/pandas/issues/32762
 1298:     msg = "[Unexpected type|Cannot compare]"
 1299:     with pytest.raises(TypeError, match=msg):
 1300:         values.searchsorted(arg)
 1301: 
 1302: 
 1303: @pytest.mark.parametrize("klass", [list, tuple, np.array, pd.Series])
 1304: def test_period_index_construction_from_strings(klass):
 1305:     # https://github.com/pandas-dev/pandas/issues/26109
 1306:     strings = ["2020Q1", "2020Q2"] * 2
 1307:     data = klass(strings)
 1308:     result = PeriodIndex(data, freq="Q")
 1309:     expected = PeriodIndex([Period(s) for s in strings])
 1310:     tm.assert_index_equal(result, expected)
 1311: 
 1312: 
 1313: @pytest.mark.parametrize("dtype", ["M8[ns]", "m8[ns]"])
 1314: def test_from_pandas_array(dtype):
 1315:     # GH#24615
 1316:     data = np.array([1, 2, 3], dtype=dtype)
 1317:     arr = NumpyExtensionArray(data)
 1318: 
 1319:     cls = {"M8[ns]": DatetimeArray, "m8[ns]": TimedeltaArray}[dtype]
 1320: 
 1321:     depr_msg = f"{cls.__name__}.__init__ is deprecated"
 1322:     with tm.assert_produces_warning(FutureWarning, match=depr_msg):
 1323:         result = cls(arr)
 1324:         expected = cls(data)
 1325:     tm.assert_extension_array_equal(result, expected)
 1326: 
 1327:     result = cls._from_sequence(arr, dtype=dtype)
 1328:     expected = cls._from_sequence(data, dtype=dtype)
 1329:     tm.assert_extension_array_equal(result, expected)
 1330: 
 1331:     func = {"M8[ns]": pd.to_datetime, "m8[ns]": pd.to_timedelta}[dtype]
 1332:     result = func(arr).array
 1333:     expected = func(data).array
 1334:     tm.assert_equal(result, expected)
 1335: 
 1336:     # Let's check the Indexes while we're here
 1337:     idx_cls = {"M8[ns]": DatetimeIndex, "m8[ns]": TimedeltaIndex}[dtype]
 1338:     result = idx_cls(arr)
 1339:     expected = idx_cls(data)
 1340:     tm.assert_index_equal(result, expected)
