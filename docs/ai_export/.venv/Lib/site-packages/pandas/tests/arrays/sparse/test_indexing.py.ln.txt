    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import SparseDtype
    6: import pandas._testing as tm
    7: from pandas.core.arrays.sparse import SparseArray
    8: 
    9: 
   10: @pytest.fixture
   11: def arr_data():
   12:     return np.array([np.nan, np.nan, 1, 2, 3, np.nan, 4, 5, np.nan, 6])
   13: 
   14: 
   15: @pytest.fixture
   16: def arr(arr_data):
   17:     return SparseArray(arr_data)
   18: 
   19: 
   20: class TestGetitem:
   21:     def test_getitem(self, arr):
   22:         dense = arr.to_dense()
   23:         for i, value in enumerate(arr):
   24:             tm.assert_almost_equal(value, dense[i])
   25:             tm.assert_almost_equal(arr[-i], dense[-i])
   26: 
   27:     def test_getitem_arraylike_mask(self, arr):
   28:         arr = SparseArray([0, 1, 2])
   29:         result = arr[[True, False, True]]
   30:         expected = SparseArray([0, 2])
   31:         tm.assert_sp_array_equal(result, expected)
   32: 
   33:     @pytest.mark.parametrize(
   34:         "slc",
   35:         [
   36:             np.s_[:],
   37:             np.s_[1:10],
   38:             np.s_[1:100],
   39:             np.s_[10:1],
   40:             np.s_[:-3],
   41:             np.s_[-5:-4],
   42:             np.s_[:-12],
   43:             np.s_[-12:],
   44:             np.s_[2:],
   45:             np.s_[2::3],
   46:             np.s_[::2],
   47:             np.s_[::-1],
   48:             np.s_[::-2],
   49:             np.s_[1:6:2],
   50:             np.s_[:-6:-2],
   51:         ],
   52:     )
   53:     @pytest.mark.parametrize(
   54:         "as_dense", [[np.nan] * 10, [1] * 10, [np.nan] * 5 + [1] * 5, []]
   55:     )
   56:     def test_getslice(self, slc, as_dense):
   57:         as_dense = np.array(as_dense)
   58:         arr = SparseArray(as_dense)
   59: 
   60:         result = arr[slc]
   61:         expected = SparseArray(as_dense[slc])
   62: 
   63:         tm.assert_sp_array_equal(result, expected)
   64: 
   65:     def test_getslice_tuple(self):
   66:         dense = np.array([np.nan, 0, 3, 4, 0, 5, np.nan, np.nan, 0])
   67: 
   68:         sparse = SparseArray(dense)
   69:         res = sparse[(slice(4, None),)]
   70:         exp = SparseArray(dense[4:])
   71:         tm.assert_sp_array_equal(res, exp)
   72: 
   73:         sparse = SparseArray(dense, fill_value=0)
   74:         res = sparse[(slice(4, None),)]
   75:         exp = SparseArray(dense[4:], fill_value=0)
   76:         tm.assert_sp_array_equal(res, exp)
   77: 
   78:         msg = "too many indices for array"
   79:         with pytest.raises(IndexError, match=msg):
   80:             sparse[4:, :]
   81: 
   82:         with pytest.raises(IndexError, match=msg):
   83:             # check numpy compat
   84:             dense[4:, :]
   85: 
   86:     def test_boolean_slice_empty(self):
   87:         arr = SparseArray([0, 1, 2])
   88:         res = arr[[False, False, False]]
   89:         assert res.dtype == arr.dtype
   90: 
   91:     def test_getitem_bool_sparse_array(self, arr):
   92:         # GH 23122
   93:         spar_bool = SparseArray([False, True] * 5, dtype=np.bool_, fill_value=True)
   94:         exp = SparseArray([np.nan, 2, np.nan, 5, 6])
   95:         tm.assert_sp_array_equal(arr[spar_bool], exp)
   96: 
   97:         spar_bool = ~spar_bool
   98:         res = arr[spar_bool]
   99:         exp = SparseArray([np.nan, 1, 3, 4, np.nan])
  100:         tm.assert_sp_array_equal(res, exp)
  101: 
  102:         spar_bool = SparseArray(
  103:             [False, True, np.nan] * 3, dtype=np.bool_, fill_value=np.nan
  104:         )
  105:         res = arr[spar_bool]
  106:         exp = SparseArray([np.nan, 3, 5])
  107:         tm.assert_sp_array_equal(res, exp)
  108: 
  109:     def test_getitem_bool_sparse_array_as_comparison(self):
  110:         # GH 45110
  111:         arr = SparseArray([1, 2, 3, 4, np.nan, np.nan], fill_value=np.nan)
  112:         res = arr[arr > 2]
  113:         exp = SparseArray([3.0, 4.0], fill_value=np.nan)
  114:         tm.assert_sp_array_equal(res, exp)
  115: 
  116:     def test_get_item(self, arr):
  117:         zarr = SparseArray([0, 0, 1, 2, 3, 0, 4, 5, 0, 6], fill_value=0)
  118: 
  119:         assert np.isnan(arr[1])
  120:         assert arr[2] == 1
  121:         assert arr[7] == 5
  122: 
  123:         assert zarr[0] == 0
  124:         assert zarr[2] == 1
  125:         assert zarr[7] == 5
  126: 
  127:         errmsg = "must be an integer between -10 and 10"
  128: 
  129:         with pytest.raises(IndexError, match=errmsg):
  130:             arr[11]
  131: 
  132:         with pytest.raises(IndexError, match=errmsg):
  133:             arr[-11]
  134: 
  135:         assert arr[-1] == arr[len(arr) - 1]
  136: 
  137: 
  138: class TestSetitem:
  139:     def test_set_item(self, arr_data):
  140:         arr = SparseArray(arr_data).copy()
  141: 
  142:         def setitem():
  143:             arr[5] = 3
  144: 
  145:         def setslice():
  146:             arr[1:5] = 2
  147: 
  148:         with pytest.raises(TypeError, match="assignment via setitem"):
  149:             setitem()
  150: 
  151:         with pytest.raises(TypeError, match="assignment via setitem"):
  152:             setslice()
  153: 
  154: 
  155: class TestTake:
  156:     def test_take_scalar_raises(self, arr):
  157:         msg = "'indices' must be an array, not a scalar '2'."
  158:         with pytest.raises(ValueError, match=msg):
  159:             arr.take(2)
  160: 
  161:     def test_take(self, arr_data, arr):
  162:         exp = SparseArray(np.take(arr_data, [2, 3]))
  163:         tm.assert_sp_array_equal(arr.take([2, 3]), exp)
  164: 
  165:         exp = SparseArray(np.take(arr_data, [0, 1, 2]))
  166:         tm.assert_sp_array_equal(arr.take([0, 1, 2]), exp)
  167: 
  168:     def test_take_all_empty(self):
  169:         sparse = pd.array([0, 0], dtype=SparseDtype("int64"))
  170:         result = sparse.take([0, 1], allow_fill=True, fill_value=np.nan)
  171:         tm.assert_sp_array_equal(sparse, result)
  172: 
  173:     def test_take_different_fill_value(self):
  174:         # Take with a different fill value shouldn't overwrite the original
  175:         sparse = pd.array([0.0], dtype=SparseDtype("float64", fill_value=0.0))
  176:         result = sparse.take([0, -1], allow_fill=True, fill_value=np.nan)
  177:         expected = pd.array([0, np.nan], dtype=sparse.dtype)
  178:         tm.assert_sp_array_equal(expected, result)
  179: 
  180:     def test_take_fill_value(self):
  181:         data = np.array([1, np.nan, 0, 3, 0])
  182:         sparse = SparseArray(data, fill_value=0)
  183: 
  184:         exp = SparseArray(np.take(data, [0]), fill_value=0)
  185:         tm.assert_sp_array_equal(sparse.take([0]), exp)
  186: 
  187:         exp = SparseArray(np.take(data, [1, 3, 4]), fill_value=0)
  188:         tm.assert_sp_array_equal(sparse.take([1, 3, 4]), exp)
  189: 
  190:     def test_take_negative(self, arr_data, arr):
  191:         exp = SparseArray(np.take(arr_data, [-1]))
  192:         tm.assert_sp_array_equal(arr.take([-1]), exp)
  193: 
  194:         exp = SparseArray(np.take(arr_data, [-4, -3, -2]))
  195:         tm.assert_sp_array_equal(arr.take([-4, -3, -2]), exp)
  196: 
  197:     def test_bad_take(self, arr):
  198:         with pytest.raises(IndexError, match="bounds"):
  199:             arr.take([11])
  200: 
  201:     def test_take_filling(self):
  202:         # similar tests as GH 12631
  203:         sparse = SparseArray([np.nan, np.nan, 1, np.nan, 4])
  204:         result = sparse.take(np.array([1, 0, -1]))
  205:         expected = SparseArray([np.nan, np.nan, 4])
  206:         tm.assert_sp_array_equal(result, expected)
  207: 
  208:         # TODO: actionable?
  209:         # XXX: test change: fill_value=True -> allow_fill=True
  210:         result = sparse.take(np.array([1, 0, -1]), allow_fill=True)
  211:         expected = SparseArray([np.nan, np.nan, np.nan])
  212:         tm.assert_sp_array_equal(result, expected)
  213: 
  214:         # allow_fill=False
  215:         result = sparse.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
  216:         expected = SparseArray([np.nan, np.nan, 4])
  217:         tm.assert_sp_array_equal(result, expected)
  218: 
  219:         msg = "Invalid value in 'indices'"
  220:         with pytest.raises(ValueError, match=msg):
  221:             sparse.take(np.array([1, 0, -2]), allow_fill=True)
  222: 
  223:         with pytest.raises(ValueError, match=msg):
  224:             sparse.take(np.array([1, 0, -5]), allow_fill=True)
  225: 
  226:         msg = "out of bounds value in 'indices'"
  227:         with pytest.raises(IndexError, match=msg):
  228:             sparse.take(np.array([1, -6]))
  229:         with pytest.raises(IndexError, match=msg):
  230:             sparse.take(np.array([1, 5]))
  231:         with pytest.raises(IndexError, match=msg):
  232:             sparse.take(np.array([1, 5]), allow_fill=True)
  233: 
  234:     def test_take_filling_fill_value(self):
  235:         # same tests as GH#12631
  236:         sparse = SparseArray([np.nan, 0, 1, 0, 4], fill_value=0)
  237:         result = sparse.take(np.array([1, 0, -1]))
  238:         expected = SparseArray([0, np.nan, 4], fill_value=0)
  239:         tm.assert_sp_array_equal(result, expected)
  240: 
  241:         # fill_value
  242:         result = sparse.take(np.array([1, 0, -1]), allow_fill=True)
  243:         # TODO: actionable?
  244:         # XXX: behavior change.
  245:         # the old way of filling self.fill_value doesn't follow EA rules.
  246:         # It's supposed to be self.dtype.na_value (nan in this case)
  247:         expected = SparseArray([0, np.nan, np.nan], fill_value=0)
  248:         tm.assert_sp_array_equal(result, expected)
  249: 
  250:         # allow_fill=False
  251:         result = sparse.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
  252:         expected = SparseArray([0, np.nan, 4], fill_value=0)
  253:         tm.assert_sp_array_equal(result, expected)
  254: 
  255:         msg = "Invalid value in 'indices'."
  256:         with pytest.raises(ValueError, match=msg):
  257:             sparse.take(np.array([1, 0, -2]), allow_fill=True)
  258:         with pytest.raises(ValueError, match=msg):
  259:             sparse.take(np.array([1, 0, -5]), allow_fill=True)
  260: 
  261:         msg = "out of bounds value in 'indices'"
  262:         with pytest.raises(IndexError, match=msg):
  263:             sparse.take(np.array([1, -6]))
  264:         with pytest.raises(IndexError, match=msg):
  265:             sparse.take(np.array([1, 5]))
  266:         with pytest.raises(IndexError, match=msg):
  267:             sparse.take(np.array([1, 5]), fill_value=True)
  268: 
  269:     @pytest.mark.parametrize("kind", ["block", "integer"])
  270:     def test_take_filling_all_nan(self, kind):
  271:         sparse = SparseArray([np.nan, np.nan, np.nan, np.nan, np.nan], kind=kind)
  272:         result = sparse.take(np.array([1, 0, -1]))
  273:         expected = SparseArray([np.nan, np.nan, np.nan], kind=kind)
  274:         tm.assert_sp_array_equal(result, expected)
  275: 
  276:         result = sparse.take(np.array([1, 0, -1]), fill_value=True)
  277:         expected = SparseArray([np.nan, np.nan, np.nan], kind=kind)
  278:         tm.assert_sp_array_equal(result, expected)
  279: 
  280:         msg = "out of bounds value in 'indices'"
  281:         with pytest.raises(IndexError, match=msg):
  282:             sparse.take(np.array([1, -6]))
  283:         with pytest.raises(IndexError, match=msg):
  284:             sparse.take(np.array([1, 5]))
  285:         with pytest.raises(IndexError, match=msg):
  286:             sparse.take(np.array([1, 5]), fill_value=True)
  287: 
  288: 
  289: class TestWhere:
  290:     def test_where_retain_fill_value(self):
  291:         # GH#45691 don't lose fill_value on _where
  292:         arr = SparseArray([np.nan, 1.0], fill_value=0)
  293: 
  294:         mask = np.array([True, False])
  295: 
  296:         res = arr._where(~mask, 1)
  297:         exp = SparseArray([1, 1.0], fill_value=0)
  298:         tm.assert_sp_array_equal(res, exp)
  299: 
  300:         ser = pd.Series(arr)
  301:         res = ser.where(~mask, 1)
  302:         tm.assert_series_equal(res, pd.Series(exp))
