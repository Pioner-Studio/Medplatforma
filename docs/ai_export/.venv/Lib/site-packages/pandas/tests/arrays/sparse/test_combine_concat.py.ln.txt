    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: import pandas._testing as tm
    6: from pandas.core.arrays.sparse import SparseArray
    7: 
    8: 
    9: class TestSparseArrayConcat:
   10:     @pytest.mark.parametrize("kind", ["integer", "block"])
   11:     def test_basic(self, kind):
   12:         a = SparseArray([1, 0, 0, 2], kind=kind)
   13:         b = SparseArray([1, 0, 2, 2], kind=kind)
   14: 
   15:         result = SparseArray._concat_same_type([a, b])
   16:         # Can't make any assertions about the sparse index itself
   17:         # since we aren't don't merge sparse blocs across arrays
   18:         # in to_concat
   19:         expected = np.array([1, 2, 1, 2, 2], dtype="int64")
   20:         tm.assert_numpy_array_equal(result.sp_values, expected)
   21:         assert result.kind == kind
   22: 
   23:     @pytest.mark.parametrize("kind", ["integer", "block"])
   24:     def test_uses_first_kind(self, kind):
   25:         other = "integer" if kind == "block" else "block"
   26:         a = SparseArray([1, 0, 0, 2], kind=kind)
   27:         b = SparseArray([1, 0, 2, 2], kind=other)
   28: 
   29:         result = SparseArray._concat_same_type([a, b])
   30:         expected = np.array([1, 2, 1, 2, 2], dtype="int64")
   31:         tm.assert_numpy_array_equal(result.sp_values, expected)
   32:         assert result.kind == kind
   33: 
   34: 
   35: @pytest.mark.parametrize(
   36:     "other, expected_dtype",
   37:     [
   38:         # compatible dtype -> preserve sparse
   39:         (pd.Series([3, 4, 5], dtype="int64"), pd.SparseDtype("int64", 0)),
   40:         # (pd.Series([3, 4, 5], dtype="Int64"), pd.SparseDtype("int64", 0)),
   41:         # incompatible dtype -> Sparse[common dtype]
   42:         (pd.Series([1.5, 2.5, 3.5], dtype="float64"), pd.SparseDtype("float64", 0)),
   43:         # incompatible dtype -> Sparse[object] dtype
   44:         (pd.Series(["a", "b", "c"], dtype=object), pd.SparseDtype(object, 0)),
   45:         # categorical with compatible categories -> dtype of the categories
   46:         (pd.Series([3, 4, 5], dtype="category"), np.dtype("int64")),
   47:         (pd.Series([1.5, 2.5, 3.5], dtype="category"), np.dtype("float64")),
   48:         # categorical with incompatible categories -> object dtype
   49:         (pd.Series(["a", "b", "c"], dtype="category"), np.dtype(object)),
   50:     ],
   51: )
   52: def test_concat_with_non_sparse(other, expected_dtype):
   53:     # https://github.com/pandas-dev/pandas/issues/34336
   54:     s_sparse = pd.Series([1, 0, 2], dtype=pd.SparseDtype("int64", 0))
   55: 
   56:     result = pd.concat([s_sparse, other], ignore_index=True)
   57:     expected = pd.Series(list(s_sparse) + list(other)).astype(expected_dtype)
   58:     tm.assert_series_equal(result, expected)
   59: 
   60:     result = pd.concat([other, s_sparse], ignore_index=True)
   61:     expected = pd.Series(list(other) + list(s_sparse)).astype(expected_dtype)
   62:     tm.assert_series_equal(result, expected)
