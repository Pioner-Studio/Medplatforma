    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: import pandas._testing as tm
    6: 
    7: pytestmark = pytest.mark.filterwarnings(
    8:     "ignore:Passing a BlockManager to DataFrame:DeprecationWarning"
    9: )
   10: 
   11: pa = pytest.importorskip("pyarrow")
   12: 
   13: from pandas.core.arrays.arrow._arrow_utils import pyarrow_array_to_numpy_and_mask
   14: 
   15: arrays = [pd.array([1, 2, 3, None], dtype=dtype) for dtype in tm.ALL_INT_EA_DTYPES]
   16: arrays += [pd.array([0.1, 0.2, 0.3, None], dtype=dtype) for dtype in tm.FLOAT_EA_DTYPES]
   17: arrays += [pd.array([True, False, True, None], dtype="boolean")]
   18: 
   19: 
   20: @pytest.fixture(params=arrays, ids=[a.dtype.name for a in arrays])
   21: def data(request):
   22:     """
   23:     Fixture returning parametrized array from given dtype, including integer,
   24:     float and boolean
   25:     """
   26:     return request.param
   27: 
   28: 
   29: def test_arrow_array(data):
   30:     arr = pa.array(data)
   31:     expected = pa.array(
   32:         data.to_numpy(object, na_value=None),
   33:         type=pa.from_numpy_dtype(data.dtype.numpy_dtype),
   34:     )
   35:     assert arr.equals(expected)
   36: 
   37: 
   38: def test_arrow_roundtrip(data):
   39:     df = pd.DataFrame({"a": data})
   40:     table = pa.table(df)
   41:     assert table.field("a").type == str(data.dtype.numpy_dtype)
   42: 
   43:     result = table.to_pandas()
   44:     assert result["a"].dtype == data.dtype
   45:     tm.assert_frame_equal(result, df)
   46: 
   47: 
   48: def test_dataframe_from_arrow_types_mapper():
   49:     def types_mapper(arrow_type):
   50:         if pa.types.is_boolean(arrow_type):
   51:             return pd.BooleanDtype()
   52:         elif pa.types.is_integer(arrow_type):
   53:             return pd.Int64Dtype()
   54: 
   55:     bools_array = pa.array([True, None, False], type=pa.bool_())
   56:     ints_array = pa.array([1, None, 2], type=pa.int64())
   57:     small_ints_array = pa.array([-1, 0, 7], type=pa.int8())
   58:     record_batch = pa.RecordBatch.from_arrays(
   59:         [bools_array, ints_array, small_ints_array], ["bools", "ints", "small_ints"]
   60:     )
   61:     result = record_batch.to_pandas(types_mapper=types_mapper)
   62:     bools = pd.Series([True, None, False], dtype="boolean")
   63:     ints = pd.Series([1, None, 2], dtype="Int64")
   64:     small_ints = pd.Series([-1, 0, 7], dtype="Int64")
   65:     expected = pd.DataFrame({"bools": bools, "ints": ints, "small_ints": small_ints})
   66:     tm.assert_frame_equal(result, expected)
   67: 
   68: 
   69: def test_arrow_load_from_zero_chunks(data):
   70:     # GH-41040
   71: 
   72:     df = pd.DataFrame({"a": data[0:0]})
   73:     table = pa.table(df)
   74:     assert table.field("a").type == str(data.dtype.numpy_dtype)
   75:     table = pa.table(
   76:         [pa.chunked_array([], type=table.field("a").type)], schema=table.schema
   77:     )
   78:     result = table.to_pandas()
   79:     assert result["a"].dtype == data.dtype
   80:     tm.assert_frame_equal(result, df)
   81: 
   82: 
   83: def test_arrow_from_arrow_uint():
   84:     # https://github.com/pandas-dev/pandas/issues/31896
   85:     # possible mismatch in types
   86: 
   87:     dtype = pd.UInt32Dtype()
   88:     result = dtype.__from_arrow__(pa.array([1, 2, 3, 4, None], type="int64"))
   89:     expected = pd.array([1, 2, 3, 4, None], dtype="UInt32")
   90: 
   91:     tm.assert_extension_array_equal(result, expected)
   92: 
   93: 
   94: def test_arrow_sliced(data):
   95:     # https://github.com/pandas-dev/pandas/issues/38525
   96: 
   97:     df = pd.DataFrame({"a": data})
   98:     table = pa.table(df)
   99:     result = table.slice(2, None).to_pandas()
  100:     expected = df.iloc[2:].reset_index(drop=True)
  101:     tm.assert_frame_equal(result, expected)
  102: 
  103:     # no missing values
  104:     df2 = df.fillna(data[0])
  105:     table = pa.table(df2)
  106:     result = table.slice(2, None).to_pandas()
  107:     expected = df2.iloc[2:].reset_index(drop=True)
  108:     tm.assert_frame_equal(result, expected)
  109: 
  110: 
  111: @pytest.fixture
  112: def np_dtype_to_arrays(any_real_numpy_dtype):
  113:     """
  114:     Fixture returning actual and expected dtype, pandas and numpy arrays and
  115:     mask from a given numpy dtype
  116:     """
  117:     np_dtype = np.dtype(any_real_numpy_dtype)
  118:     pa_type = pa.from_numpy_dtype(np_dtype)
  119: 
  120:     # None ensures the creation of a bitmask buffer.
  121:     pa_array = pa.array([0, 1, 2, None], type=pa_type)
  122:     # Since masked Arrow buffer slots are not required to contain a specific
  123:     # value, assert only the first three values of the created np.array
  124:     np_expected = np.array([0, 1, 2], dtype=np_dtype)
  125:     mask_expected = np.array([True, True, True, False])
  126:     return np_dtype, pa_array, np_expected, mask_expected
  127: 
  128: 
  129: def test_pyarrow_array_to_numpy_and_mask(np_dtype_to_arrays):
  130:     """
  131:     Test conversion from pyarrow array to numpy array.
  132: 
  133:     Modifies the pyarrow buffer to contain padding and offset, which are
  134:     considered valid buffers by pyarrow.
  135: 
  136:     Also tests empty pyarrow arrays with non empty buffers.
  137:     See https://github.com/pandas-dev/pandas/issues/40896
  138:     """
  139:     np_dtype, pa_array, np_expected, mask_expected = np_dtype_to_arrays
  140:     data, mask = pyarrow_array_to_numpy_and_mask(pa_array, np_dtype)
  141:     tm.assert_numpy_array_equal(data[:3], np_expected)
  142:     tm.assert_numpy_array_equal(mask, mask_expected)
  143: 
  144:     mask_buffer = pa_array.buffers()[0]
  145:     data_buffer = pa_array.buffers()[1]
  146:     data_buffer_bytes = pa_array.buffers()[1].to_pybytes()
  147: 
  148:     # Add trailing padding to the buffer.
  149:     data_buffer_trail = pa.py_buffer(data_buffer_bytes + b"\x00")
  150:     pa_array_trail = pa.Array.from_buffers(
  151:         type=pa_array.type,
  152:         length=len(pa_array),
  153:         buffers=[mask_buffer, data_buffer_trail],
  154:         offset=pa_array.offset,
  155:     )
  156:     pa_array_trail.validate()
  157:     data, mask = pyarrow_array_to_numpy_and_mask(pa_array_trail, np_dtype)
  158:     tm.assert_numpy_array_equal(data[:3], np_expected)
  159:     tm.assert_numpy_array_equal(mask, mask_expected)
  160: 
  161:     # Add offset to the buffer.
  162:     offset = b"\x00" * (pa_array.type.bit_width // 8)
  163:     data_buffer_offset = pa.py_buffer(offset + data_buffer_bytes)
  164:     mask_buffer_offset = pa.py_buffer(b"\x0E")
  165:     pa_array_offset = pa.Array.from_buffers(
  166:         type=pa_array.type,
  167:         length=len(pa_array),
  168:         buffers=[mask_buffer_offset, data_buffer_offset],
  169:         offset=pa_array.offset + 1,
  170:     )
  171:     pa_array_offset.validate()
  172:     data, mask = pyarrow_array_to_numpy_and_mask(pa_array_offset, np_dtype)
  173:     tm.assert_numpy_array_equal(data[:3], np_expected)
  174:     tm.assert_numpy_array_equal(mask, mask_expected)
  175: 
  176:     # Empty array
  177:     np_expected_empty = np.array([], dtype=np_dtype)
  178:     mask_expected_empty = np.array([], dtype=np.bool_)
  179: 
  180:     pa_array_offset = pa.Array.from_buffers(
  181:         type=pa_array.type,
  182:         length=0,
  183:         buffers=[mask_buffer, data_buffer],
  184:         offset=pa_array.offset,
  185:     )
  186:     pa_array_offset.validate()
  187:     data, mask = pyarrow_array_to_numpy_and_mask(pa_array_offset, np_dtype)
  188:     tm.assert_numpy_array_equal(data[:3], np_expected_empty)
  189:     tm.assert_numpy_array_equal(mask, mask_expected_empty)
  190: 
  191: 
  192: @pytest.mark.parametrize(
  193:     "arr", [pa.nulls(10), pa.chunked_array([pa.nulls(4), pa.nulls(6)])]
  194: )
  195: def test_from_arrow_null(data, arr):
  196:     res = data.dtype.__from_arrow__(arr)
  197:     assert res.isna().all()
  198:     assert len(res) == 10
  199: 
  200: 
  201: def test_from_arrow_type_error(data):
  202:     # ensure that __from_arrow__ returns a TypeError when getting a wrong
  203:     # array type
  204: 
  205:     arr = pa.array(data).cast("string")
  206:     with pytest.raises(TypeError, match=None):
  207:         # we don't test the exact error message, only the fact that it raises
  208:         # a TypeError is relevant
  209:         data.dtype.__from_arrow__(arr)
