    1: """
    2: This module tests the functionality of StringArray and ArrowStringArray.
    3: Tests for the str accessors are in pandas/tests/strings/test_string_array.py
    4: """
    5: import operator
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: from pandas.compat.pyarrow import pa_version_under12p0
   11: 
   12: from pandas.core.dtypes.common import is_dtype_equal
   13: 
   14: import pandas as pd
   15: import pandas._testing as tm
   16: from pandas.core.arrays.string_arrow import (
   17:     ArrowStringArray,
   18:     ArrowStringArrayNumpySemantics,
   19: )
   20: 
   21: 
   22: def na_val(dtype):
   23:     if dtype.storage == "pyarrow_numpy":
   24:         return np.nan
   25:     else:
   26:         return pd.NA
   27: 
   28: 
   29: @pytest.fixture
   30: def dtype(string_storage):
   31:     """Fixture giving StringDtype from parametrized 'string_storage'"""
   32:     return pd.StringDtype(storage=string_storage)
   33: 
   34: 
   35: @pytest.fixture
   36: def cls(dtype):
   37:     """Fixture giving array type from parametrized 'dtype'"""
   38:     return dtype.construct_array_type()
   39: 
   40: 
   41: def test_repr(dtype):
   42:     df = pd.DataFrame({"A": pd.array(["a", pd.NA, "b"], dtype=dtype)})
   43:     if dtype.storage == "pyarrow_numpy":
   44:         expected = "     A\n0    a\n1  NaN\n2    b"
   45:     else:
   46:         expected = "      A\n0     a\n1  <NA>\n2     b"
   47:     assert repr(df) == expected
   48: 
   49:     if dtype.storage == "pyarrow_numpy":
   50:         expected = "0      a\n1    NaN\n2      b\nName: A, dtype: string"
   51:     else:
   52:         expected = "0       a\n1    <NA>\n2       b\nName: A, dtype: string"
   53:     assert repr(df.A) == expected
   54: 
   55:     if dtype.storage == "pyarrow":
   56:         arr_name = "ArrowStringArray"
   57:         expected = f"<{arr_name}>\n['a', <NA>, 'b']\nLength: 3, dtype: string"
   58:     elif dtype.storage == "pyarrow_numpy":
   59:         arr_name = "ArrowStringArrayNumpySemantics"
   60:         expected = f"<{arr_name}>\n['a', nan, 'b']\nLength: 3, dtype: string"
   61:     else:
   62:         arr_name = "StringArray"
   63:         expected = f"<{arr_name}>\n['a', <NA>, 'b']\nLength: 3, dtype: string"
   64:     assert repr(df.A.array) == expected
   65: 
   66: 
   67: def test_none_to_nan(cls, dtype):
   68:     a = cls._from_sequence(["a", None, "b"], dtype=dtype)
   69:     assert a[1] is not None
   70:     assert a[1] is na_val(a.dtype)
   71: 
   72: 
   73: def test_setitem_validates(cls, dtype):
   74:     arr = cls._from_sequence(["a", "b"], dtype=dtype)
   75: 
   76:     if cls is pd.arrays.StringArray:
   77:         msg = "Cannot set non-string value '10' into a StringArray."
   78:     else:
   79:         msg = "Scalar must be NA or str"
   80:     with pytest.raises(TypeError, match=msg):
   81:         arr[0] = 10
   82: 
   83:     if cls is pd.arrays.StringArray:
   84:         msg = "Must provide strings."
   85:     else:
   86:         msg = "Scalar must be NA or str"
   87:     with pytest.raises(TypeError, match=msg):
   88:         arr[:] = np.array([1, 2])
   89: 
   90: 
   91: def test_setitem_with_scalar_string(dtype):
   92:     # is_float_dtype considers some strings, like 'd', to be floats
   93:     # which can cause issues.
   94:     arr = pd.array(["a", "c"], dtype=dtype)
   95:     arr[0] = "d"
   96:     expected = pd.array(["d", "c"], dtype=dtype)
   97:     tm.assert_extension_array_equal(arr, expected)
   98: 
   99: 
  100: def test_setitem_with_array_with_missing(dtype):
  101:     # ensure that when setting with an array of values, we don't mutate the
  102:     # array `value` in __setitem__(self, key, value)
  103:     arr = pd.array(["a", "b", "c"], dtype=dtype)
  104:     value = np.array(["A", None])
  105:     value_orig = value.copy()
  106:     arr[[0, 1]] = value
  107: 
  108:     expected = pd.array(["A", pd.NA, "c"], dtype=dtype)
  109:     tm.assert_extension_array_equal(arr, expected)
  110:     tm.assert_numpy_array_equal(value, value_orig)
  111: 
  112: 
  113: def test_astype_roundtrip(dtype):
  114:     ser = pd.Series(pd.date_range("2000", periods=12))
  115:     ser[0] = None
  116: 
  117:     casted = ser.astype(dtype)
  118:     assert is_dtype_equal(casted.dtype, dtype)
  119: 
  120:     result = casted.astype("datetime64[ns]")
  121:     tm.assert_series_equal(result, ser)
  122: 
  123:     # GH#38509 same thing for timedelta64
  124:     ser2 = ser - ser.iloc[-1]
  125:     casted2 = ser2.astype(dtype)
  126:     assert is_dtype_equal(casted2.dtype, dtype)
  127: 
  128:     result2 = casted2.astype(ser2.dtype)
  129:     tm.assert_series_equal(result2, ser2)
  130: 
  131: 
  132: def test_add(dtype):
  133:     a = pd.Series(["a", "b", "c", None, None], dtype=dtype)
  134:     b = pd.Series(["x", "y", None, "z", None], dtype=dtype)
  135: 
  136:     result = a + b
  137:     expected = pd.Series(["ax", "by", None, None, None], dtype=dtype)
  138:     tm.assert_series_equal(result, expected)
  139: 
  140:     result = a.add(b)
  141:     tm.assert_series_equal(result, expected)
  142: 
  143:     result = a.radd(b)
  144:     expected = pd.Series(["xa", "yb", None, None, None], dtype=dtype)
  145:     tm.assert_series_equal(result, expected)
  146: 
  147:     result = a.add(b, fill_value="-")
  148:     expected = pd.Series(["ax", "by", "c-", "-z", None], dtype=dtype)
  149:     tm.assert_series_equal(result, expected)
  150: 
  151: 
  152: def test_add_2d(dtype, request, arrow_string_storage):
  153:     if dtype.storage in arrow_string_storage:
  154:         reason = "Failed: DID NOT RAISE <class 'ValueError'>"
  155:         mark = pytest.mark.xfail(raises=None, reason=reason)
  156:         request.applymarker(mark)
  157: 
  158:     a = pd.array(["a", "b", "c"], dtype=dtype)
  159:     b = np.array([["a", "b", "c"]], dtype=object)
  160:     with pytest.raises(ValueError, match="3 != 1"):
  161:         a + b
  162: 
  163:     s = pd.Series(a)
  164:     with pytest.raises(ValueError, match="3 != 1"):
  165:         s + b
  166: 
  167: 
  168: def test_add_sequence(dtype):
  169:     a = pd.array(["a", "b", None, None], dtype=dtype)
  170:     other = ["x", None, "y", None]
  171: 
  172:     result = a + other
  173:     expected = pd.array(["ax", None, None, None], dtype=dtype)
  174:     tm.assert_extension_array_equal(result, expected)
  175: 
  176:     result = other + a
  177:     expected = pd.array(["xa", None, None, None], dtype=dtype)
  178:     tm.assert_extension_array_equal(result, expected)
  179: 
  180: 
  181: def test_mul(dtype):
  182:     a = pd.array(["a", "b", None], dtype=dtype)
  183:     result = a * 2
  184:     expected = pd.array(["aa", "bb", None], dtype=dtype)
  185:     tm.assert_extension_array_equal(result, expected)
  186: 
  187:     result = 2 * a
  188:     tm.assert_extension_array_equal(result, expected)
  189: 
  190: 
  191: @pytest.mark.xfail(reason="GH-28527")
  192: def test_add_strings(dtype):
  193:     arr = pd.array(["a", "b", "c", "d"], dtype=dtype)
  194:     df = pd.DataFrame([["t", "y", "v", "w"]], dtype=object)
  195:     assert arr.__add__(df) is NotImplemented
  196: 
  197:     result = arr + df
  198:     expected = pd.DataFrame([["at", "by", "cv", "dw"]]).astype(dtype)
  199:     tm.assert_frame_equal(result, expected)
  200: 
  201:     result = df + arr
  202:     expected = pd.DataFrame([["ta", "yb", "vc", "wd"]]).astype(dtype)
  203:     tm.assert_frame_equal(result, expected)
  204: 
  205: 
  206: @pytest.mark.xfail(reason="GH-28527")
  207: def test_add_frame(dtype):
  208:     arr = pd.array(["a", "b", np.nan, np.nan], dtype=dtype)
  209:     df = pd.DataFrame([["x", np.nan, "y", np.nan]])
  210: 
  211:     assert arr.__add__(df) is NotImplemented
  212: 
  213:     result = arr + df
  214:     expected = pd.DataFrame([["ax", np.nan, np.nan, np.nan]]).astype(dtype)
  215:     tm.assert_frame_equal(result, expected)
  216: 
  217:     result = df + arr
  218:     expected = pd.DataFrame([["xa", np.nan, np.nan, np.nan]]).astype(dtype)
  219:     tm.assert_frame_equal(result, expected)
  220: 
  221: 
  222: def test_comparison_methods_scalar(comparison_op, dtype):
  223:     op_name = f"__{comparison_op.__name__}__"
  224:     a = pd.array(["a", None, "c"], dtype=dtype)
  225:     other = "a"
  226:     result = getattr(a, op_name)(other)
  227:     if dtype.storage == "pyarrow_numpy":
  228:         expected = np.array([getattr(item, op_name)(other) for item in a])
  229:         if comparison_op == operator.ne:
  230:             expected[1] = True
  231:         else:
  232:             expected[1] = False
  233:         tm.assert_numpy_array_equal(result, expected.astype(np.bool_))
  234:     else:
  235:         expected_dtype = "boolean[pyarrow]" if dtype.storage == "pyarrow" else "boolean"
  236:         expected = np.array([getattr(item, op_name)(other) for item in a], dtype=object)
  237:         expected = pd.array(expected, dtype=expected_dtype)
  238:         tm.assert_extension_array_equal(result, expected)
  239: 
  240: 
  241: def test_comparison_methods_scalar_pd_na(comparison_op, dtype):
  242:     op_name = f"__{comparison_op.__name__}__"
  243:     a = pd.array(["a", None, "c"], dtype=dtype)
  244:     result = getattr(a, op_name)(pd.NA)
  245: 
  246:     if dtype.storage == "pyarrow_numpy":
  247:         if operator.ne == comparison_op:
  248:             expected = np.array([True, True, True])
  249:         else:
  250:             expected = np.array([False, False, False])
  251:         tm.assert_numpy_array_equal(result, expected)
  252:     else:
  253:         expected_dtype = "boolean[pyarrow]" if dtype.storage == "pyarrow" else "boolean"
  254:         expected = pd.array([None, None, None], dtype=expected_dtype)
  255:         tm.assert_extension_array_equal(result, expected)
  256:         tm.assert_extension_array_equal(result, expected)
  257: 
  258: 
  259: def test_comparison_methods_scalar_not_string(comparison_op, dtype):
  260:     op_name = f"__{comparison_op.__name__}__"
  261: 
  262:     a = pd.array(["a", None, "c"], dtype=dtype)
  263:     other = 42
  264: 
  265:     if op_name not in ["__eq__", "__ne__"]:
  266:         with pytest.raises(TypeError, match="Invalid comparison|not supported between"):
  267:             getattr(a, op_name)(other)
  268: 
  269:         return
  270: 
  271:     result = getattr(a, op_name)(other)
  272: 
  273:     if dtype.storage == "pyarrow_numpy":
  274:         expected_data = {
  275:             "__eq__": [False, False, False],
  276:             "__ne__": [True, True, True],
  277:         }[op_name]
  278:         expected = np.array(expected_data)
  279:         tm.assert_numpy_array_equal(result, expected)
  280:     else:
  281:         expected_data = {"__eq__": [False, None, False], "__ne__": [True, None, True]}[
  282:             op_name
  283:         ]
  284:         expected_dtype = "boolean[pyarrow]" if dtype.storage == "pyarrow" else "boolean"
  285:         expected = pd.array(expected_data, dtype=expected_dtype)
  286:         tm.assert_extension_array_equal(result, expected)
  287: 
  288: 
  289: def test_comparison_methods_array(comparison_op, dtype):
  290:     op_name = f"__{comparison_op.__name__}__"
  291: 
  292:     a = pd.array(["a", None, "c"], dtype=dtype)
  293:     other = [None, None, "c"]
  294:     result = getattr(a, op_name)(other)
  295:     if dtype.storage == "pyarrow_numpy":
  296:         if operator.ne == comparison_op:
  297:             expected = np.array([True, True, False])
  298:         else:
  299:             expected = np.array([False, False, False])
  300:             expected[-1] = getattr(other[-1], op_name)(a[-1])
  301:         tm.assert_numpy_array_equal(result, expected)
  302: 
  303:         result = getattr(a, op_name)(pd.NA)
  304:         if operator.ne == comparison_op:
  305:             expected = np.array([True, True, True])
  306:         else:
  307:             expected = np.array([False, False, False])
  308:         tm.assert_numpy_array_equal(result, expected)
  309: 
  310:     else:
  311:         expected_dtype = "boolean[pyarrow]" if dtype.storage == "pyarrow" else "boolean"
  312:         expected = np.full(len(a), fill_value=None, dtype="object")
  313:         expected[-1] = getattr(other[-1], op_name)(a[-1])
  314:         expected = pd.array(expected, dtype=expected_dtype)
  315:         tm.assert_extension_array_equal(result, expected)
  316: 
  317:         result = getattr(a, op_name)(pd.NA)
  318:         expected = pd.array([None, None, None], dtype=expected_dtype)
  319:         tm.assert_extension_array_equal(result, expected)
  320: 
  321: 
  322: def test_constructor_raises(cls):
  323:     if cls is pd.arrays.StringArray:
  324:         msg = "StringArray requires a sequence of strings or pandas.NA"
  325:     else:
  326:         msg = "Unsupported type '<class 'numpy.ndarray'>' for ArrowExtensionArray"
  327: 
  328:     with pytest.raises(ValueError, match=msg):
  329:         cls(np.array(["a", "b"], dtype="S1"))
  330: 
  331:     with pytest.raises(ValueError, match=msg):
  332:         cls(np.array([]))
  333: 
  334:     if cls is pd.arrays.StringArray:
  335:         # GH#45057 np.nan and None do NOT raise, as they are considered valid NAs
  336:         #  for string dtype
  337:         cls(np.array(["a", np.nan], dtype=object))
  338:         cls(np.array(["a", None], dtype=object))
  339:     else:
  340:         with pytest.raises(ValueError, match=msg):
  341:             cls(np.array(["a", np.nan], dtype=object))
  342:         with pytest.raises(ValueError, match=msg):
  343:             cls(np.array(["a", None], dtype=object))
  344: 
  345:     with pytest.raises(ValueError, match=msg):
  346:         cls(np.array(["a", pd.NaT], dtype=object))
  347: 
  348:     with pytest.raises(ValueError, match=msg):
  349:         cls(np.array(["a", np.datetime64("NaT", "ns")], dtype=object))
  350: 
  351:     with pytest.raises(ValueError, match=msg):
  352:         cls(np.array(["a", np.timedelta64("NaT", "ns")], dtype=object))
  353: 
  354: 
  355: @pytest.mark.parametrize("na", [np.nan, np.float64("nan"), float("nan"), None, pd.NA])
  356: def test_constructor_nan_like(na):
  357:     expected = pd.arrays.StringArray(np.array(["a", pd.NA]))
  358:     tm.assert_extension_array_equal(
  359:         pd.arrays.StringArray(np.array(["a", na], dtype="object")), expected
  360:     )
  361: 
  362: 
  363: @pytest.mark.parametrize("copy", [True, False])
  364: def test_from_sequence_no_mutate(copy, cls, dtype):
  365:     nan_arr = np.array(["a", np.nan], dtype=object)
  366:     expected_input = nan_arr.copy()
  367:     na_arr = np.array(["a", pd.NA], dtype=object)
  368: 
  369:     result = cls._from_sequence(nan_arr, dtype=dtype, copy=copy)
  370: 
  371:     if cls in (ArrowStringArray, ArrowStringArrayNumpySemantics):
  372:         import pyarrow as pa
  373: 
  374:         expected = cls(pa.array(na_arr, type=pa.string(), from_pandas=True))
  375:     else:
  376:         expected = cls(na_arr)
  377: 
  378:     tm.assert_extension_array_equal(result, expected)
  379:     tm.assert_numpy_array_equal(nan_arr, expected_input)
  380: 
  381: 
  382: def test_astype_int(dtype):
  383:     arr = pd.array(["1", "2", "3"], dtype=dtype)
  384:     result = arr.astype("int64")
  385:     expected = np.array([1, 2, 3], dtype="int64")
  386:     tm.assert_numpy_array_equal(result, expected)
  387: 
  388:     arr = pd.array(["1", pd.NA, "3"], dtype=dtype)
  389:     if dtype.storage == "pyarrow_numpy":
  390:         err = ValueError
  391:         msg = "cannot convert float NaN to integer"
  392:     else:
  393:         err = TypeError
  394:         msg = (
  395:             r"int\(\) argument must be a string, a bytes-like "
  396:             r"object or a( real)? number"
  397:         )
  398:     with pytest.raises(err, match=msg):
  399:         arr.astype("int64")
  400: 
  401: 
  402: def test_astype_nullable_int(dtype):
  403:     arr = pd.array(["1", pd.NA, "3"], dtype=dtype)
  404: 
  405:     result = arr.astype("Int64")
  406:     expected = pd.array([1, pd.NA, 3], dtype="Int64")
  407:     tm.assert_extension_array_equal(result, expected)
  408: 
  409: 
  410: def test_astype_float(dtype, any_float_dtype):
  411:     # Don't compare arrays (37974)
  412:     ser = pd.Series(["1.1", pd.NA, "3.3"], dtype=dtype)
  413:     result = ser.astype(any_float_dtype)
  414:     expected = pd.Series([1.1, np.nan, 3.3], dtype=any_float_dtype)
  415:     tm.assert_series_equal(result, expected)
  416: 
  417: 
  418: @pytest.mark.parametrize("skipna", [True, False])
  419: @pytest.mark.xfail(reason="Not implemented StringArray.sum")
  420: def test_reduce(skipna, dtype):
  421:     arr = pd.Series(["a", "b", "c"], dtype=dtype)
  422:     result = arr.sum(skipna=skipna)
  423:     assert result == "abc"
  424: 
  425: 
  426: @pytest.mark.parametrize("skipna", [True, False])
  427: @pytest.mark.xfail(reason="Not implemented StringArray.sum")
  428: def test_reduce_missing(skipna, dtype):
  429:     arr = pd.Series([None, "a", None, "b", "c", None], dtype=dtype)
  430:     result = arr.sum(skipna=skipna)
  431:     if skipna:
  432:         assert result == "abc"
  433:     else:
  434:         assert pd.isna(result)
  435: 
  436: 
  437: @pytest.mark.parametrize("method", ["min", "max"])
  438: @pytest.mark.parametrize("skipna", [True, False])
  439: def test_min_max(method, skipna, dtype):
  440:     arr = pd.Series(["a", "b", "c", None], dtype=dtype)
  441:     result = getattr(arr, method)(skipna=skipna)
  442:     if skipna:
  443:         expected = "a" if method == "min" else "c"
  444:         assert result == expected
  445:     else:
  446:         assert result is na_val(arr.dtype)
  447: 
  448: 
  449: @pytest.mark.parametrize("method", ["min", "max"])
  450: @pytest.mark.parametrize("box", [pd.Series, pd.array])
  451: def test_min_max_numpy(method, box, dtype, request, arrow_string_storage):
  452:     if dtype.storage in arrow_string_storage and box is pd.array:
  453:         if box is pd.array:
  454:             reason = "'<=' not supported between instances of 'str' and 'NoneType'"
  455:         else:
  456:             reason = "'ArrowStringArray' object has no attribute 'max'"
  457:         mark = pytest.mark.xfail(raises=TypeError, reason=reason)
  458:         request.applymarker(mark)
  459: 
  460:     arr = box(["a", "b", "c", None], dtype=dtype)
  461:     result = getattr(np, method)(arr)
  462:     expected = "a" if method == "min" else "c"
  463:     assert result == expected
  464: 
  465: 
  466: def test_fillna_args(dtype, arrow_string_storage):
  467:     # GH 37987
  468: 
  469:     arr = pd.array(["a", pd.NA], dtype=dtype)
  470: 
  471:     res = arr.fillna(value="b")
  472:     expected = pd.array(["a", "b"], dtype=dtype)
  473:     tm.assert_extension_array_equal(res, expected)
  474: 
  475:     res = arr.fillna(value=np.str_("b"))
  476:     expected = pd.array(["a", "b"], dtype=dtype)
  477:     tm.assert_extension_array_equal(res, expected)
  478: 
  479:     if dtype.storage in arrow_string_storage:
  480:         msg = "Invalid value '1' for dtype string"
  481:     else:
  482:         msg = "Cannot set non-string value '1' into a StringArray."
  483:     with pytest.raises(TypeError, match=msg):
  484:         arr.fillna(value=1)
  485: 
  486: 
  487: def test_arrow_array(dtype):
  488:     # protocol added in 0.15.0
  489:     pa = pytest.importorskip("pyarrow")
  490:     import pyarrow.compute as pc
  491: 
  492:     data = pd.array(["a", "b", "c"], dtype=dtype)
  493:     arr = pa.array(data)
  494:     expected = pa.array(list(data), type=pa.large_string(), from_pandas=True)
  495:     if dtype.storage in ("pyarrow", "pyarrow_numpy") and pa_version_under12p0:
  496:         expected = pa.chunked_array(expected)
  497:     if dtype.storage == "python":
  498:         expected = pc.cast(expected, pa.string())
  499:     assert arr.equals(expected)
  500: 
  501: 
  502: @pytest.mark.filterwarnings("ignore:Passing a BlockManager:DeprecationWarning")
  503: def test_arrow_roundtrip(dtype, string_storage2, request, using_infer_string):
  504:     # roundtrip possible from arrow 1.0.0
  505:     pa = pytest.importorskip("pyarrow")
  506: 
  507:     if using_infer_string and string_storage2 != "pyarrow_numpy":
  508:         request.applymarker(
  509:             pytest.mark.xfail(
  510:                 reason="infer_string takes precedence over string storage"
  511:             )
  512:         )
  513: 
  514:     data = pd.array(["a", "b", None], dtype=dtype)
  515:     df = pd.DataFrame({"a": data})
  516:     table = pa.table(df)
  517:     if dtype.storage == "python":
  518:         assert table.field("a").type == "string"
  519:     else:
  520:         assert table.field("a").type == "large_string"
  521:     with pd.option_context("string_storage", string_storage2):
  522:         result = table.to_pandas()
  523:     assert isinstance(result["a"].dtype, pd.StringDtype)
  524:     expected = df.astype(f"string[{string_storage2}]")
  525:     tm.assert_frame_equal(result, expected)
  526:     # ensure the missing value is represented by NA and not np.nan or None
  527:     assert result.loc[2, "a"] is na_val(result["a"].dtype)
  528: 
  529: 
  530: @pytest.mark.filterwarnings("ignore:Passing a BlockManager:DeprecationWarning")
  531: def test_arrow_load_from_zero_chunks(
  532:     dtype, string_storage2, request, using_infer_string
  533: ):
  534:     # GH-41040
  535:     pa = pytest.importorskip("pyarrow")
  536: 
  537:     if using_infer_string and string_storage2 != "pyarrow_numpy":
  538:         request.applymarker(
  539:             pytest.mark.xfail(
  540:                 reason="infer_string takes precedence over string storage"
  541:             )
  542:         )
  543: 
  544:     data = pd.array([], dtype=dtype)
  545:     df = pd.DataFrame({"a": data})
  546:     table = pa.table(df)
  547:     if dtype.storage == "python":
  548:         assert table.field("a").type == "string"
  549:     else:
  550:         assert table.field("a").type == "large_string"
  551:     # Instantiate the same table with no chunks at all
  552:     table = pa.table([pa.chunked_array([], type=pa.string())], schema=table.schema)
  553:     with pd.option_context("string_storage", string_storage2):
  554:         result = table.to_pandas()
  555:     assert isinstance(result["a"].dtype, pd.StringDtype)
  556:     expected = df.astype(f"string[{string_storage2}]")
  557:     tm.assert_frame_equal(result, expected)
  558: 
  559: 
  560: def test_value_counts_na(dtype):
  561:     if getattr(dtype, "storage", "") == "pyarrow":
  562:         exp_dtype = "int64[pyarrow]"
  563:     elif getattr(dtype, "storage", "") == "pyarrow_numpy":
  564:         exp_dtype = "int64"
  565:     else:
  566:         exp_dtype = "Int64"
  567:     arr = pd.array(["a", "b", "a", pd.NA], dtype=dtype)
  568:     result = arr.value_counts(dropna=False)
  569:     expected = pd.Series([2, 1, 1], index=arr[[0, 1, 3]], dtype=exp_dtype, name="count")
  570:     tm.assert_series_equal(result, expected)
  571: 
  572:     result = arr.value_counts(dropna=True)
  573:     expected = pd.Series([2, 1], index=arr[:2], dtype=exp_dtype, name="count")
  574:     tm.assert_series_equal(result, expected)
  575: 
  576: 
  577: def test_value_counts_with_normalize(dtype):
  578:     if getattr(dtype, "storage", "") == "pyarrow":
  579:         exp_dtype = "double[pyarrow]"
  580:     elif getattr(dtype, "storage", "") == "pyarrow_numpy":
  581:         exp_dtype = np.float64
  582:     else:
  583:         exp_dtype = "Float64"
  584:     ser = pd.Series(["a", "b", "a", pd.NA], dtype=dtype)
  585:     result = ser.value_counts(normalize=True)
  586:     expected = pd.Series([2, 1], index=ser[:2], dtype=exp_dtype, name="proportion") / 3
  587:     tm.assert_series_equal(result, expected)
  588: 
  589: 
  590: @pytest.mark.parametrize(
  591:     "values, expected",
  592:     [
  593:         (["a", "b", "c"], np.array([False, False, False])),
  594:         (["a", "b", None], np.array([False, False, True])),
  595:     ],
  596: )
  597: def test_use_inf_as_na(values, expected, dtype):
  598:     # https://github.com/pandas-dev/pandas/issues/33655
  599:     values = pd.array(values, dtype=dtype)
  600:     msg = "use_inf_as_na option is deprecated"
  601:     with tm.assert_produces_warning(FutureWarning, match=msg):
  602:         with pd.option_context("mode.use_inf_as_na", True):
  603:             result = values.isna()
  604:             tm.assert_numpy_array_equal(result, expected)
  605: 
  606:             result = pd.Series(values).isna()
  607:             expected = pd.Series(expected)
  608:             tm.assert_series_equal(result, expected)
  609: 
  610:             result = pd.DataFrame(values).isna()
  611:             expected = pd.DataFrame(expected)
  612:             tm.assert_frame_equal(result, expected)
  613: 
  614: 
  615: def test_memory_usage(dtype, arrow_string_storage):
  616:     # GH 33963
  617: 
  618:     if dtype.storage in arrow_string_storage:
  619:         pytest.skip(f"not applicable for {dtype.storage}")
  620: 
  621:     series = pd.Series(["a", "b", "c"], dtype=dtype)
  622: 
  623:     assert 0 < series.nbytes <= series.memory_usage() < series.memory_usage(deep=True)
  624: 
  625: 
  626: @pytest.mark.parametrize("float_dtype", [np.float16, np.float32, np.float64])
  627: def test_astype_from_float_dtype(float_dtype, dtype):
  628:     # https://github.com/pandas-dev/pandas/issues/36451
  629:     ser = pd.Series([0.1], dtype=float_dtype)
  630:     result = ser.astype(dtype)
  631:     expected = pd.Series(["0.1"], dtype=dtype)
  632:     tm.assert_series_equal(result, expected)
  633: 
  634: 
  635: def test_to_numpy_returns_pdna_default(dtype):
  636:     arr = pd.array(["a", pd.NA, "b"], dtype=dtype)
  637:     result = np.array(arr)
  638:     expected = np.array(["a", na_val(dtype), "b"], dtype=object)
  639:     tm.assert_numpy_array_equal(result, expected)
  640: 
  641: 
  642: def test_to_numpy_na_value(dtype, nulls_fixture):
  643:     na_value = nulls_fixture
  644:     arr = pd.array(["a", pd.NA, "b"], dtype=dtype)
  645:     result = arr.to_numpy(na_value=na_value)
  646:     expected = np.array(["a", na_value, "b"], dtype=object)
  647:     tm.assert_numpy_array_equal(result, expected)
  648: 
  649: 
  650: def test_isin(dtype, fixed_now_ts):
  651:     s = pd.Series(["a", "b", None], dtype=dtype)
  652: 
  653:     result = s.isin(["a", "c"])
  654:     expected = pd.Series([True, False, False])
  655:     tm.assert_series_equal(result, expected)
  656: 
  657:     result = s.isin(["a", pd.NA])
  658:     expected = pd.Series([True, False, True])
  659:     tm.assert_series_equal(result, expected)
  660: 
  661:     result = s.isin([])
  662:     expected = pd.Series([False, False, False])
  663:     tm.assert_series_equal(result, expected)
  664: 
  665:     result = s.isin(["a", fixed_now_ts])
  666:     expected = pd.Series([True, False, False])
  667:     tm.assert_series_equal(result, expected)
  668: 
  669: 
  670: def test_setitem_scalar_with_mask_validation(dtype):
  671:     # https://github.com/pandas-dev/pandas/issues/47628
  672:     # setting None with a boolean mask (through _putmaks) should still result
  673:     # in pd.NA values in the underlying array
  674:     ser = pd.Series(["a", "b", "c"], dtype=dtype)
  675:     mask = np.array([False, True, False])
  676: 
  677:     ser[mask] = None
  678:     assert ser.array[1] is na_val(ser.dtype)
  679: 
  680:     # for other non-string we should also raise an error
  681:     ser = pd.Series(["a", "b", "c"], dtype=dtype)
  682:     if type(ser.array) is pd.arrays.StringArray:
  683:         msg = "Cannot set non-string value"
  684:     else:
  685:         msg = "Scalar must be NA or str"
  686:     with pytest.raises(TypeError, match=msg):
  687:         ser[mask] = 1
  688: 
  689: 
  690: def test_from_numpy_str(dtype):
  691:     vals = ["a", "b", "c"]
  692:     arr = np.array(vals, dtype=np.str_)
  693:     result = pd.array(arr, dtype=dtype)
  694:     expected = pd.array(vals, dtype=dtype)
  695:     tm.assert_extension_array_equal(result, expected)
  696: 
  697: 
  698: def test_tolist(dtype):
  699:     vals = ["a", "b", "c"]
  700:     arr = pd.array(vals, dtype=dtype)
  701:     result = arr.tolist()
  702:     expected = vals
  703:     tm.assert_equal(result, expected)
