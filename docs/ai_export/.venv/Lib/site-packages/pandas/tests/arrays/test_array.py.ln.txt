    1: import datetime
    2: import decimal
    3: import re
    4: 
    5: import numpy as np
    6: import pytest
    7: import pytz
    8: 
    9: import pandas as pd
   10: import pandas._testing as tm
   11: from pandas.api.extensions import register_extension_dtype
   12: from pandas.arrays import (
   13:     BooleanArray,
   14:     DatetimeArray,
   15:     FloatingArray,
   16:     IntegerArray,
   17:     IntervalArray,
   18:     SparseArray,
   19:     TimedeltaArray,
   20: )
   21: from pandas.core.arrays import (
   22:     NumpyExtensionArray,
   23:     period_array,
   24: )
   25: from pandas.tests.extension.decimal import (
   26:     DecimalArray,
   27:     DecimalDtype,
   28:     to_decimal,
   29: )
   30: 
   31: 
   32: @pytest.mark.parametrize("dtype_unit", ["M8[h]", "M8[m]", "m8[h]", "M8[m]"])
   33: def test_dt64_array(dtype_unit):
   34:     # PR 53817
   35:     dtype_var = np.dtype(dtype_unit)
   36:     msg = (
   37:         r"datetime64 and timedelta64 dtype resolutions other than "
   38:         r"'s', 'ms', 'us', and 'ns' are deprecated. "
   39:         r"In future releases passing unsupported resolutions will "
   40:         r"raise an exception."
   41:     )
   42:     with tm.assert_produces_warning(FutureWarning, match=re.escape(msg)):
   43:         pd.array([], dtype=dtype_var)
   44: 
   45: 
   46: @pytest.mark.parametrize(
   47:     "data, dtype, expected",
   48:     [
   49:         # Basic NumPy defaults.
   50:         ([], None, FloatingArray._from_sequence([], dtype="Float64")),
   51:         ([1, 2], None, IntegerArray._from_sequence([1, 2], dtype="Int64")),
   52:         ([1, 2], object, NumpyExtensionArray(np.array([1, 2], dtype=object))),
   53:         (
   54:             [1, 2],
   55:             np.dtype("float32"),
   56:             NumpyExtensionArray(np.array([1.0, 2.0], dtype=np.dtype("float32"))),
   57:         ),
   58:         (
   59:             np.array([], dtype=object),
   60:             None,
   61:             NumpyExtensionArray(np.array([], dtype=object)),
   62:         ),
   63:         (
   64:             np.array([1, 2], dtype="int64"),
   65:             None,
   66:             IntegerArray._from_sequence([1, 2], dtype="Int64"),
   67:         ),
   68:         (
   69:             np.array([1.0, 2.0], dtype="float64"),
   70:             None,
   71:             FloatingArray._from_sequence([1.0, 2.0], dtype="Float64"),
   72:         ),
   73:         # String alias passes through to NumPy
   74:         ([1, 2], "float32", NumpyExtensionArray(np.array([1, 2], dtype="float32"))),
   75:         ([1, 2], "int64", NumpyExtensionArray(np.array([1, 2], dtype=np.int64))),
   76:         # GH#44715 FloatingArray does not support float16, so fall
   77:         #  back to NumpyExtensionArray
   78:         (
   79:             np.array([1, 2], dtype=np.float16),
   80:             None,
   81:             NumpyExtensionArray(np.array([1, 2], dtype=np.float16)),
   82:         ),
   83:         # idempotency with e.g. pd.array(pd.array([1, 2], dtype="int64"))
   84:         (
   85:             NumpyExtensionArray(np.array([1, 2], dtype=np.int32)),
   86:             None,
   87:             NumpyExtensionArray(np.array([1, 2], dtype=np.int32)),
   88:         ),
   89:         # Period alias
   90:         (
   91:             [pd.Period("2000", "D"), pd.Period("2001", "D")],
   92:             "Period[D]",
   93:             period_array(["2000", "2001"], freq="D"),
   94:         ),
   95:         # Period dtype
   96:         (
   97:             [pd.Period("2000", "D")],
   98:             pd.PeriodDtype("D"),
   99:             period_array(["2000"], freq="D"),
  100:         ),
  101:         # Datetime (naive)
  102:         (
  103:             [1, 2],
  104:             np.dtype("datetime64[ns]"),
  105:             DatetimeArray._from_sequence(
  106:                 np.array([1, 2], dtype="M8[ns]"), dtype="M8[ns]"
  107:             ),
  108:         ),
  109:         (
  110:             [1, 2],
  111:             np.dtype("datetime64[s]"),
  112:             DatetimeArray._from_sequence(
  113:                 np.array([1, 2], dtype="M8[s]"), dtype="M8[s]"
  114:             ),
  115:         ),
  116:         (
  117:             np.array([1, 2], dtype="datetime64[ns]"),
  118:             None,
  119:             DatetimeArray._from_sequence(
  120:                 np.array([1, 2], dtype="M8[ns]"), dtype="M8[ns]"
  121:             ),
  122:         ),
  123:         (
  124:             pd.DatetimeIndex(["2000", "2001"]),
  125:             np.dtype("datetime64[ns]"),
  126:             DatetimeArray._from_sequence(["2000", "2001"], dtype="M8[ns]"),
  127:         ),
  128:         (
  129:             pd.DatetimeIndex(["2000", "2001"]),
  130:             None,
  131:             DatetimeArray._from_sequence(["2000", "2001"], dtype="M8[ns]"),
  132:         ),
  133:         (
  134:             ["2000", "2001"],
  135:             np.dtype("datetime64[ns]"),
  136:             DatetimeArray._from_sequence(["2000", "2001"], dtype="M8[ns]"),
  137:         ),
  138:         # Datetime (tz-aware)
  139:         (
  140:             ["2000", "2001"],
  141:             pd.DatetimeTZDtype(tz="CET"),
  142:             DatetimeArray._from_sequence(
  143:                 ["2000", "2001"], dtype=pd.DatetimeTZDtype(tz="CET")
  144:             ),
  145:         ),
  146:         # Timedelta
  147:         (
  148:             ["1h", "2h"],
  149:             np.dtype("timedelta64[ns]"),
  150:             TimedeltaArray._from_sequence(["1h", "2h"], dtype="m8[ns]"),
  151:         ),
  152:         (
  153:             pd.TimedeltaIndex(["1h", "2h"]),
  154:             np.dtype("timedelta64[ns]"),
  155:             TimedeltaArray._from_sequence(["1h", "2h"], dtype="m8[ns]"),
  156:         ),
  157:         (
  158:             np.array([1, 2], dtype="m8[s]"),
  159:             np.dtype("timedelta64[s]"),
  160:             TimedeltaArray._from_sequence(
  161:                 np.array([1, 2], dtype="m8[s]"), dtype="m8[s]"
  162:             ),
  163:         ),
  164:         (
  165:             pd.TimedeltaIndex(["1h", "2h"]),
  166:             None,
  167:             TimedeltaArray._from_sequence(["1h", "2h"], dtype="m8[ns]"),
  168:         ),
  169:         (
  170:             # preserve non-nano, i.e. don't cast to NumpyExtensionArray
  171:             TimedeltaArray._simple_new(
  172:                 np.arange(5, dtype=np.int64).view("m8[s]"), dtype=np.dtype("m8[s]")
  173:             ),
  174:             None,
  175:             TimedeltaArray._simple_new(
  176:                 np.arange(5, dtype=np.int64).view("m8[s]"), dtype=np.dtype("m8[s]")
  177:             ),
  178:         ),
  179:         (
  180:             # preserve non-nano, i.e. don't cast to NumpyExtensionArray
  181:             TimedeltaArray._simple_new(
  182:                 np.arange(5, dtype=np.int64).view("m8[s]"), dtype=np.dtype("m8[s]")
  183:             ),
  184:             np.dtype("m8[s]"),
  185:             TimedeltaArray._simple_new(
  186:                 np.arange(5, dtype=np.int64).view("m8[s]"), dtype=np.dtype("m8[s]")
  187:             ),
  188:         ),
  189:         # Category
  190:         (["a", "b"], "category", pd.Categorical(["a", "b"])),
  191:         (
  192:             ["a", "b"],
  193:             pd.CategoricalDtype(None, ordered=True),
  194:             pd.Categorical(["a", "b"], ordered=True),
  195:         ),
  196:         # Interval
  197:         (
  198:             [pd.Interval(1, 2), pd.Interval(3, 4)],
  199:             "interval",
  200:             IntervalArray.from_tuples([(1, 2), (3, 4)]),
  201:         ),
  202:         # Sparse
  203:         ([0, 1], "Sparse[int64]", SparseArray([0, 1], dtype="int64")),
  204:         # IntegerNA
  205:         ([1, None], "Int16", pd.array([1, None], dtype="Int16")),
  206:         (
  207:             pd.Series([1, 2]),
  208:             None,
  209:             NumpyExtensionArray(np.array([1, 2], dtype=np.int64)),
  210:         ),
  211:         # String
  212:         (
  213:             ["a", None],
  214:             "string",
  215:             pd.StringDtype()
  216:             .construct_array_type()
  217:             ._from_sequence(["a", None], dtype=pd.StringDtype()),
  218:         ),
  219:         (
  220:             ["a", None],
  221:             pd.StringDtype(),
  222:             pd.StringDtype()
  223:             .construct_array_type()
  224:             ._from_sequence(["a", None], dtype=pd.StringDtype()),
  225:         ),
  226:         # Boolean
  227:         (
  228:             [True, None],
  229:             "boolean",
  230:             BooleanArray._from_sequence([True, None], dtype="boolean"),
  231:         ),
  232:         (
  233:             [True, None],
  234:             pd.BooleanDtype(),
  235:             BooleanArray._from_sequence([True, None], dtype="boolean"),
  236:         ),
  237:         # Index
  238:         (pd.Index([1, 2]), None, NumpyExtensionArray(np.array([1, 2], dtype=np.int64))),
  239:         # Series[EA] returns the EA
  240:         (
  241:             pd.Series(pd.Categorical(["a", "b"], categories=["a", "b", "c"])),
  242:             None,
  243:             pd.Categorical(["a", "b"], categories=["a", "b", "c"]),
  244:         ),
  245:         # "3rd party" EAs work
  246:         ([decimal.Decimal(0), decimal.Decimal(1)], "decimal", to_decimal([0, 1])),
  247:         # pass an ExtensionArray, but a different dtype
  248:         (
  249:             period_array(["2000", "2001"], freq="D"),
  250:             "category",
  251:             pd.Categorical([pd.Period("2000", "D"), pd.Period("2001", "D")]),
  252:         ),
  253:     ],
  254: )
  255: def test_array(data, dtype, expected):
  256:     result = pd.array(data, dtype=dtype)
  257:     tm.assert_equal(result, expected)
  258: 
  259: 
  260: def test_array_copy():
  261:     a = np.array([1, 2])
  262:     # default is to copy
  263:     b = pd.array(a, dtype=a.dtype)
  264:     assert not tm.shares_memory(a, b)
  265: 
  266:     # copy=True
  267:     b = pd.array(a, dtype=a.dtype, copy=True)
  268:     assert not tm.shares_memory(a, b)
  269: 
  270:     # copy=False
  271:     b = pd.array(a, dtype=a.dtype, copy=False)
  272:     assert tm.shares_memory(a, b)
  273: 
  274: 
  275: cet = pytz.timezone("CET")
  276: 
  277: 
  278: @pytest.mark.parametrize(
  279:     "data, expected",
  280:     [
  281:         # period
  282:         (
  283:             [pd.Period("2000", "D"), pd.Period("2001", "D")],
  284:             period_array(["2000", "2001"], freq="D"),
  285:         ),
  286:         # interval
  287:         ([pd.Interval(0, 1), pd.Interval(1, 2)], IntervalArray.from_breaks([0, 1, 2])),
  288:         # datetime
  289:         (
  290:             [pd.Timestamp("2000"), pd.Timestamp("2001")],
  291:             DatetimeArray._from_sequence(["2000", "2001"], dtype="M8[ns]"),
  292:         ),
  293:         (
  294:             [datetime.datetime(2000, 1, 1), datetime.datetime(2001, 1, 1)],
  295:             DatetimeArray._from_sequence(["2000", "2001"], dtype="M8[ns]"),
  296:         ),
  297:         (
  298:             np.array([1, 2], dtype="M8[ns]"),
  299:             DatetimeArray._from_sequence(np.array([1, 2], dtype="M8[ns]")),
  300:         ),
  301:         (
  302:             np.array([1, 2], dtype="M8[us]"),
  303:             DatetimeArray._simple_new(
  304:                 np.array([1, 2], dtype="M8[us]"), dtype=np.dtype("M8[us]")
  305:             ),
  306:         ),
  307:         # datetimetz
  308:         (
  309:             [pd.Timestamp("2000", tz="CET"), pd.Timestamp("2001", tz="CET")],
  310:             DatetimeArray._from_sequence(
  311:                 ["2000", "2001"], dtype=pd.DatetimeTZDtype(tz="CET", unit="ns")
  312:             ),
  313:         ),
  314:         (
  315:             [
  316:                 datetime.datetime(2000, 1, 1, tzinfo=cet),
  317:                 datetime.datetime(2001, 1, 1, tzinfo=cet),
  318:             ],
  319:             DatetimeArray._from_sequence(
  320:                 ["2000", "2001"], dtype=pd.DatetimeTZDtype(tz=cet, unit="ns")
  321:             ),
  322:         ),
  323:         # timedelta
  324:         (
  325:             [pd.Timedelta("1h"), pd.Timedelta("2h")],
  326:             TimedeltaArray._from_sequence(["1h", "2h"], dtype="m8[ns]"),
  327:         ),
  328:         (
  329:             np.array([1, 2], dtype="m8[ns]"),
  330:             TimedeltaArray._from_sequence(np.array([1, 2], dtype="m8[ns]")),
  331:         ),
  332:         (
  333:             np.array([1, 2], dtype="m8[us]"),
  334:             TimedeltaArray._from_sequence(np.array([1, 2], dtype="m8[us]")),
  335:         ),
  336:         # integer
  337:         ([1, 2], IntegerArray._from_sequence([1, 2], dtype="Int64")),
  338:         ([1, None], IntegerArray._from_sequence([1, None], dtype="Int64")),
  339:         ([1, pd.NA], IntegerArray._from_sequence([1, pd.NA], dtype="Int64")),
  340:         ([1, np.nan], IntegerArray._from_sequence([1, np.nan], dtype="Int64")),
  341:         # float
  342:         ([0.1, 0.2], FloatingArray._from_sequence([0.1, 0.2], dtype="Float64")),
  343:         ([0.1, None], FloatingArray._from_sequence([0.1, pd.NA], dtype="Float64")),
  344:         ([0.1, np.nan], FloatingArray._from_sequence([0.1, pd.NA], dtype="Float64")),
  345:         ([0.1, pd.NA], FloatingArray._from_sequence([0.1, pd.NA], dtype="Float64")),
  346:         # integer-like float
  347:         ([1.0, 2.0], FloatingArray._from_sequence([1.0, 2.0], dtype="Float64")),
  348:         ([1.0, None], FloatingArray._from_sequence([1.0, pd.NA], dtype="Float64")),
  349:         ([1.0, np.nan], FloatingArray._from_sequence([1.0, pd.NA], dtype="Float64")),
  350:         ([1.0, pd.NA], FloatingArray._from_sequence([1.0, pd.NA], dtype="Float64")),
  351:         # mixed-integer-float
  352:         ([1, 2.0], FloatingArray._from_sequence([1.0, 2.0], dtype="Float64")),
  353:         (
  354:             [1, np.nan, 2.0],
  355:             FloatingArray._from_sequence([1.0, None, 2.0], dtype="Float64"),
  356:         ),
  357:         # string
  358:         (
  359:             ["a", "b"],
  360:             pd.StringDtype()
  361:             .construct_array_type()
  362:             ._from_sequence(["a", "b"], dtype=pd.StringDtype()),
  363:         ),
  364:         (
  365:             ["a", None],
  366:             pd.StringDtype()
  367:             .construct_array_type()
  368:             ._from_sequence(["a", None], dtype=pd.StringDtype()),
  369:         ),
  370:         # Boolean
  371:         ([True, False], BooleanArray._from_sequence([True, False], dtype="boolean")),
  372:         ([True, None], BooleanArray._from_sequence([True, None], dtype="boolean")),
  373:     ],
  374: )
  375: def test_array_inference(data, expected):
  376:     result = pd.array(data)
  377:     tm.assert_equal(result, expected)
  378: 
  379: 
  380: @pytest.mark.parametrize(
  381:     "data",
  382:     [
  383:         # mix of frequencies
  384:         [pd.Period("2000", "D"), pd.Period("2001", "Y")],
  385:         # mix of closed
  386:         [pd.Interval(0, 1, closed="left"), pd.Interval(1, 2, closed="right")],
  387:         # Mix of timezones
  388:         [pd.Timestamp("2000", tz="CET"), pd.Timestamp("2000", tz="UTC")],
  389:         # Mix of tz-aware and tz-naive
  390:         [pd.Timestamp("2000", tz="CET"), pd.Timestamp("2000")],
  391:         np.array([pd.Timestamp("2000"), pd.Timestamp("2000", tz="CET")]),
  392:     ],
  393: )
  394: def test_array_inference_fails(data):
  395:     result = pd.array(data)
  396:     expected = NumpyExtensionArray(np.array(data, dtype=object))
  397:     tm.assert_extension_array_equal(result, expected)
  398: 
  399: 
  400: @pytest.mark.parametrize("data", [np.array(0)])
  401: def test_nd_raises(data):
  402:     with pytest.raises(ValueError, match="NumpyExtensionArray must be 1-dimensional"):
  403:         pd.array(data, dtype="int64")
  404: 
  405: 
  406: def test_scalar_raises():
  407:     with pytest.raises(ValueError, match="Cannot pass scalar '1'"):
  408:         pd.array(1)
  409: 
  410: 
  411: def test_dataframe_raises():
  412:     # GH#51167 don't accidentally cast to StringArray by doing inference on columns
  413:     df = pd.DataFrame([[1, 2], [3, 4]], columns=["A", "B"])
  414:     msg = "Cannot pass DataFrame to 'pandas.array'"
  415:     with pytest.raises(TypeError, match=msg):
  416:         pd.array(df)
  417: 
  418: 
  419: def test_bounds_check():
  420:     # GH21796
  421:     with pytest.raises(
  422:         TypeError, match=r"cannot safely cast non-equivalent int(32|64) to uint16"
  423:     ):
  424:         pd.array([-1, 2, 3], dtype="UInt16")
  425: 
  426: 
  427: # ---------------------------------------------------------------------------
  428: # A couple dummy classes to ensure that Series and Indexes are unboxed before
  429: # getting to the EA classes.
  430: 
  431: 
  432: @register_extension_dtype
  433: class DecimalDtype2(DecimalDtype):
  434:     name = "decimal2"
  435: 
  436:     @classmethod
  437:     def construct_array_type(cls):
  438:         """
  439:         Return the array type associated with this dtype.
  440: 
  441:         Returns
  442:         -------
  443:         type
  444:         """
  445:         return DecimalArray2
  446: 
  447: 
  448: class DecimalArray2(DecimalArray):
  449:     @classmethod
  450:     def _from_sequence(cls, scalars, *, dtype=None, copy=False):
  451:         if isinstance(scalars, (pd.Series, pd.Index)):
  452:             raise TypeError("scalars should not be of type pd.Series or pd.Index")
  453: 
  454:         return super()._from_sequence(scalars, dtype=dtype, copy=copy)
  455: 
  456: 
  457: def test_array_unboxes(index_or_series):
  458:     box = index_or_series
  459: 
  460:     data = box([decimal.Decimal("1"), decimal.Decimal("2")])
  461:     dtype = DecimalDtype2()
  462:     # make sure it works
  463:     with pytest.raises(
  464:         TypeError, match="scalars should not be of type pd.Series or pd.Index"
  465:     ):
  466:         DecimalArray2._from_sequence(data, dtype=dtype)
  467: 
  468:     result = pd.array(data, dtype="decimal2")
  469:     expected = DecimalArray2._from_sequence(data.values, dtype=dtype)
  470:     tm.assert_equal(result, expected)
  471: 
  472: 
  473: def test_array_to_numpy_na():
  474:     # GH#40638
  475:     arr = pd.array([pd.NA, 1], dtype="string[python]")
  476:     result = arr.to_numpy(na_value=True, dtype=bool)
  477:     expected = np.array([True, True])
  478:     tm.assert_numpy_array_equal(result, expected)
