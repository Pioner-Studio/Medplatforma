    1: import collections
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.core.dtypes.dtypes import CategoricalDtype
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     Categorical,
   11:     DataFrame,
   12:     Index,
   13:     Series,
   14:     isna,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: class TestCategoricalMissing:
   20:     def test_isna(self):
   21:         exp = np.array([False, False, True])
   22:         cat = Categorical(["a", "b", np.nan])
   23:         res = cat.isna()
   24: 
   25:         tm.assert_numpy_array_equal(res, exp)
   26: 
   27:     def test_na_flags_int_categories(self):
   28:         # #1457
   29: 
   30:         categories = list(range(10))
   31:         labels = np.random.default_rng(2).integers(0, 10, 20)
   32:         labels[::5] = -1
   33: 
   34:         cat = Categorical(labels, categories)
   35:         repr(cat)
   36: 
   37:         tm.assert_numpy_array_equal(isna(cat), labels == -1)
   38: 
   39:     def test_nan_handling(self):
   40:         # Nans are represented as -1 in codes
   41:         c = Categorical(["a", "b", np.nan, "a"])
   42:         tm.assert_index_equal(c.categories, Index(["a", "b"]))
   43:         tm.assert_numpy_array_equal(c._codes, np.array([0, 1, -1, 0], dtype=np.int8))
   44:         c[1] = np.nan
   45:         tm.assert_index_equal(c.categories, Index(["a", "b"]))
   46:         tm.assert_numpy_array_equal(c._codes, np.array([0, -1, -1, 0], dtype=np.int8))
   47: 
   48:         # Adding nan to categories should make assigned nan point to the
   49:         # category!
   50:         c = Categorical(["a", "b", np.nan, "a"])
   51:         tm.assert_index_equal(c.categories, Index(["a", "b"]))
   52:         tm.assert_numpy_array_equal(c._codes, np.array([0, 1, -1, 0], dtype=np.int8))
   53: 
   54:     def test_set_dtype_nans(self):
   55:         c = Categorical(["a", "b", np.nan])
   56:         result = c._set_dtype(CategoricalDtype(["a", "c"]))
   57:         tm.assert_numpy_array_equal(result.codes, np.array([0, -1, -1], dtype="int8"))
   58: 
   59:     def test_set_item_nan(self):
   60:         cat = Categorical([1, 2, 3])
   61:         cat[1] = np.nan
   62: 
   63:         exp = Categorical([1, np.nan, 3], categories=[1, 2, 3])
   64:         tm.assert_categorical_equal(cat, exp)
   65: 
   66:     @pytest.mark.parametrize(
   67:         "fillna_kwargs, msg",
   68:         [
   69:             (
   70:                 {"value": 1, "method": "ffill"},
   71:                 "Cannot specify both 'value' and 'method'.",
   72:             ),
   73:             ({}, "Must specify a fill 'value' or 'method'."),
   74:             ({"method": "bad"}, "Invalid fill method. Expecting .* bad"),
   75:             (
   76:                 {"value": Series([1, 2, 3, 4, "a"])},
   77:                 "Cannot setitem on a Categorical with a new category",
   78:             ),
   79:         ],
   80:     )
   81:     def test_fillna_raises(self, fillna_kwargs, msg):
   82:         # https://github.com/pandas-dev/pandas/issues/19682
   83:         # https://github.com/pandas-dev/pandas/issues/13628
   84:         cat = Categorical([1, 2, 3, None, None])
   85: 
   86:         if len(fillna_kwargs) == 1 and "value" in fillna_kwargs:
   87:             err = TypeError
   88:         else:
   89:             err = ValueError
   90: 
   91:         with pytest.raises(err, match=msg):
   92:             cat.fillna(**fillna_kwargs)
   93: 
   94:     @pytest.mark.parametrize("named", [True, False])
   95:     def test_fillna_iterable_category(self, named):
   96:         # https://github.com/pandas-dev/pandas/issues/21097
   97:         if named:
   98:             Point = collections.namedtuple("Point", "x y")
   99:         else:
  100:             Point = lambda *args: args  # tuple
  101:         cat = Categorical(np.array([Point(0, 0), Point(0, 1), None], dtype=object))
  102:         result = cat.fillna(Point(0, 0))
  103:         expected = Categorical([Point(0, 0), Point(0, 1), Point(0, 0)])
  104: 
  105:         tm.assert_categorical_equal(result, expected)
  106: 
  107:         # Case where the Point is not among our categories; we want ValueError,
  108:         #  not NotImplementedError GH#41914
  109:         cat = Categorical(np.array([Point(1, 0), Point(0, 1), None], dtype=object))
  110:         msg = "Cannot setitem on a Categorical with a new category"
  111:         with pytest.raises(TypeError, match=msg):
  112:             cat.fillna(Point(0, 0))
  113: 
  114:     def test_fillna_array(self):
  115:         # accept Categorical or ndarray value if it holds appropriate values
  116:         cat = Categorical(["A", "B", "C", None, None])
  117: 
  118:         other = cat.fillna("C")
  119:         result = cat.fillna(other)
  120:         tm.assert_categorical_equal(result, other)
  121:         assert isna(cat[-1])  # didn't modify original inplace
  122: 
  123:         other = np.array(["A", "B", "C", "B", "A"])
  124:         result = cat.fillna(other)
  125:         expected = Categorical(["A", "B", "C", "B", "A"], dtype=cat.dtype)
  126:         tm.assert_categorical_equal(result, expected)
  127:         assert isna(cat[-1])  # didn't modify original inplace
  128: 
  129:     @pytest.mark.parametrize(
  130:         "values, expected",
  131:         [
  132:             ([1, 2, 3], np.array([False, False, False])),
  133:             ([1, 2, np.nan], np.array([False, False, True])),
  134:             ([1, 2, np.inf], np.array([False, False, True])),
  135:             ([1, 2, pd.NA], np.array([False, False, True])),
  136:         ],
  137:     )
  138:     def test_use_inf_as_na(self, values, expected):
  139:         # https://github.com/pandas-dev/pandas/issues/33594
  140:         msg = "use_inf_as_na option is deprecated"
  141:         with tm.assert_produces_warning(FutureWarning, match=msg):
  142:             with pd.option_context("mode.use_inf_as_na", True):
  143:                 cat = Categorical(values)
  144:                 result = cat.isna()
  145:                 tm.assert_numpy_array_equal(result, expected)
  146: 
  147:                 result = Series(cat).isna()
  148:                 expected = Series(expected)
  149:                 tm.assert_series_equal(result, expected)
  150: 
  151:                 result = DataFrame(cat).isna()
  152:                 expected = DataFrame(expected)
  153:                 tm.assert_frame_equal(result, expected)
  154: 
  155:     @pytest.mark.parametrize(
  156:         "values, expected",
  157:         [
  158:             ([1, 2, 3], np.array([False, False, False])),
  159:             ([1, 2, np.nan], np.array([False, False, True])),
  160:             ([1, 2, np.inf], np.array([False, False, True])),
  161:             ([1, 2, pd.NA], np.array([False, False, True])),
  162:         ],
  163:     )
  164:     def test_use_inf_as_na_outside_context(self, values, expected):
  165:         # https://github.com/pandas-dev/pandas/issues/33594
  166:         # Using isna directly for Categorical will fail in general here
  167:         cat = Categorical(values)
  168: 
  169:         msg = "use_inf_as_na option is deprecated"
  170:         with tm.assert_produces_warning(FutureWarning, match=msg):
  171:             with pd.option_context("mode.use_inf_as_na", True):
  172:                 result = isna(cat)
  173:                 tm.assert_numpy_array_equal(result, expected)
  174: 
  175:                 result = isna(Series(cat))
  176:                 expected = Series(expected)
  177:                 tm.assert_series_equal(result, expected)
  178: 
  179:                 result = isna(DataFrame(cat))
  180:                 expected = DataFrame(expected)
  181:                 tm.assert_frame_equal(result, expected)
  182: 
  183:     @pytest.mark.parametrize(
  184:         "a1, a2, categories",
  185:         [
  186:             (["a", "b", "c"], [np.nan, "a", "b"], ["a", "b", "c"]),
  187:             ([1, 2, 3], [np.nan, 1, 2], [1, 2, 3]),
  188:         ],
  189:     )
  190:     def test_compare_categorical_with_missing(self, a1, a2, categories):
  191:         # GH 28384
  192:         cat_type = CategoricalDtype(categories)
  193: 
  194:         # !=
  195:         result = Series(a1, dtype=cat_type) != Series(a2, dtype=cat_type)
  196:         expected = Series(a1) != Series(a2)
  197:         tm.assert_series_equal(result, expected)
  198: 
  199:         # ==
  200:         result = Series(a1, dtype=cat_type) == Series(a2, dtype=cat_type)
  201:         expected = Series(a1) == Series(a2)
  202:         tm.assert_series_equal(result, expected)
  203: 
  204:     @pytest.mark.parametrize(
  205:         "na_value, dtype",
  206:         [
  207:             (pd.NaT, "datetime64[ns]"),
  208:             (None, "float64"),
  209:             (np.nan, "float64"),
  210:             (pd.NA, "float64"),
  211:         ],
  212:     )
  213:     def test_categorical_only_missing_values_no_cast(self, na_value, dtype):
  214:         # GH#44900
  215:         result = Categorical([na_value, na_value])
  216:         tm.assert_index_equal(result.categories, Index([], dtype=dtype))
