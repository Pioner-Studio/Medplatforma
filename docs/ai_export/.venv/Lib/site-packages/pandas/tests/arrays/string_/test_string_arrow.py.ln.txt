    1: import pickle
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas.util._test_decorators as td
    8: 
    9: import pandas as pd
   10: import pandas._testing as tm
   11: from pandas.core.arrays.string_ import (
   12:     StringArray,
   13:     StringDtype,
   14: )
   15: from pandas.core.arrays.string_arrow import (
   16:     ArrowStringArray,
   17:     ArrowStringArrayNumpySemantics,
   18: )
   19: 
   20: 
   21: def test_eq_all_na():
   22:     pytest.importorskip("pyarrow")
   23:     a = pd.array([pd.NA, pd.NA], dtype=StringDtype("pyarrow"))
   24:     result = a == a
   25:     expected = pd.array([pd.NA, pd.NA], dtype="boolean[pyarrow]")
   26:     tm.assert_extension_array_equal(result, expected)
   27: 
   28: 
   29: def test_config(string_storage, request, using_infer_string):
   30:     if using_infer_string and string_storage != "pyarrow_numpy":
   31:         request.applymarker(pytest.mark.xfail(reason="infer string takes precedence"))
   32:     with pd.option_context("string_storage", string_storage):
   33:         assert StringDtype().storage == string_storage
   34:         result = pd.array(["a", "b"])
   35:         assert result.dtype.storage == string_storage
   36: 
   37:     dtype = StringDtype(string_storage)
   38:     expected = dtype.construct_array_type()._from_sequence(["a", "b"], dtype=dtype)
   39:     tm.assert_equal(result, expected)
   40: 
   41: 
   42: def test_config_bad_storage_raises():
   43:     msg = re.escape("Value must be one of python|pyarrow")
   44:     with pytest.raises(ValueError, match=msg):
   45:         pd.options.mode.string_storage = "foo"
   46: 
   47: 
   48: @pytest.mark.parametrize("chunked", [True, False])
   49: @pytest.mark.parametrize("array", ["numpy", "pyarrow"])
   50: def test_constructor_not_string_type_raises(array, chunked, arrow_string_storage):
   51:     pa = pytest.importorskip("pyarrow")
   52: 
   53:     array = pa if array in arrow_string_storage else np
   54: 
   55:     arr = array.array([1, 2, 3])
   56:     if chunked:
   57:         if array is np:
   58:             pytest.skip("chunked not applicable to numpy array")
   59:         arr = pa.chunked_array(arr)
   60:     if array is np:
   61:         msg = "Unsupported type '<class 'numpy.ndarray'>' for ArrowExtensionArray"
   62:     else:
   63:         msg = re.escape(
   64:             "ArrowStringArray requires a PyArrow (chunked) array of large_string type"
   65:         )
   66:     with pytest.raises(ValueError, match=msg):
   67:         ArrowStringArray(arr)
   68: 
   69: 
   70: @pytest.mark.parametrize("chunked", [True, False])
   71: def test_constructor_not_string_type_value_dictionary_raises(chunked):
   72:     pa = pytest.importorskip("pyarrow")
   73: 
   74:     arr = pa.array([1, 2, 3], pa.dictionary(pa.int32(), pa.int32()))
   75:     if chunked:
   76:         arr = pa.chunked_array(arr)
   77: 
   78:     msg = re.escape(
   79:         "ArrowStringArray requires a PyArrow (chunked) array of large_string type"
   80:     )
   81:     with pytest.raises(ValueError, match=msg):
   82:         ArrowStringArray(arr)
   83: 
   84: 
   85: @pytest.mark.xfail(
   86:     reason="dict conversion does not seem to be implemented for large string in arrow"
   87: )
   88: @pytest.mark.parametrize("chunked", [True, False])
   89: def test_constructor_valid_string_type_value_dictionary(chunked):
   90:     pa = pytest.importorskip("pyarrow")
   91: 
   92:     arr = pa.array(["1", "2", "3"], pa.large_string()).dictionary_encode()
   93:     if chunked:
   94:         arr = pa.chunked_array(arr)
   95: 
   96:     arr = ArrowStringArray(arr)
   97:     assert pa.types.is_string(arr._pa_array.type.value_type)
   98: 
   99: 
  100: def test_constructor_from_list():
  101:     # GH#27673
  102:     pytest.importorskip("pyarrow")
  103:     result = pd.Series(["E"], dtype=StringDtype(storage="pyarrow"))
  104:     assert isinstance(result.dtype, StringDtype)
  105:     assert result.dtype.storage == "pyarrow"
  106: 
  107: 
  108: def test_from_sequence_wrong_dtype_raises(using_infer_string):
  109:     pytest.importorskip("pyarrow")
  110:     with pd.option_context("string_storage", "python"):
  111:         ArrowStringArray._from_sequence(["a", None, "c"], dtype="string")
  112: 
  113:     with pd.option_context("string_storage", "pyarrow"):
  114:         ArrowStringArray._from_sequence(["a", None, "c"], dtype="string")
  115: 
  116:     with pytest.raises(AssertionError, match=None):
  117:         ArrowStringArray._from_sequence(["a", None, "c"], dtype="string[python]")
  118: 
  119:     ArrowStringArray._from_sequence(["a", None, "c"], dtype="string[pyarrow]")
  120: 
  121:     if not using_infer_string:
  122:         with pytest.raises(AssertionError, match=None):
  123:             with pd.option_context("string_storage", "python"):
  124:                 ArrowStringArray._from_sequence(["a", None, "c"], dtype=StringDtype())
  125: 
  126:     with pd.option_context("string_storage", "pyarrow"):
  127:         ArrowStringArray._from_sequence(["a", None, "c"], dtype=StringDtype())
  128: 
  129:     if not using_infer_string:
  130:         with pytest.raises(AssertionError, match=None):
  131:             ArrowStringArray._from_sequence(
  132:                 ["a", None, "c"], dtype=StringDtype("python")
  133:             )
  134: 
  135:     ArrowStringArray._from_sequence(["a", None, "c"], dtype=StringDtype("pyarrow"))
  136: 
  137:     with pd.option_context("string_storage", "python"):
  138:         StringArray._from_sequence(["a", None, "c"], dtype="string")
  139: 
  140:     with pd.option_context("string_storage", "pyarrow"):
  141:         StringArray._from_sequence(["a", None, "c"], dtype="string")
  142: 
  143:     StringArray._from_sequence(["a", None, "c"], dtype="string[python]")
  144: 
  145:     with pytest.raises(AssertionError, match=None):
  146:         StringArray._from_sequence(["a", None, "c"], dtype="string[pyarrow]")
  147: 
  148:     if not using_infer_string:
  149:         with pd.option_context("string_storage", "python"):
  150:             StringArray._from_sequence(["a", None, "c"], dtype=StringDtype())
  151: 
  152:     if not using_infer_string:
  153:         with pytest.raises(AssertionError, match=None):
  154:             with pd.option_context("string_storage", "pyarrow"):
  155:                 StringArray._from_sequence(["a", None, "c"], dtype=StringDtype())
  156: 
  157:     StringArray._from_sequence(["a", None, "c"], dtype=StringDtype("python"))
  158: 
  159:     with pytest.raises(AssertionError, match=None):
  160:         StringArray._from_sequence(["a", None, "c"], dtype=StringDtype("pyarrow"))
  161: 
  162: 
  163: @td.skip_if_installed("pyarrow")
  164: def test_pyarrow_not_installed_raises():
  165:     msg = re.escape("pyarrow>=10.0.1 is required for PyArrow backed")
  166: 
  167:     with pytest.raises(ImportError, match=msg):
  168:         StringDtype(storage="pyarrow")
  169: 
  170:     with pytest.raises(ImportError, match=msg):
  171:         ArrowStringArray([])
  172: 
  173:     with pytest.raises(ImportError, match=msg):
  174:         ArrowStringArrayNumpySemantics([])
  175: 
  176:     with pytest.raises(ImportError, match=msg):
  177:         ArrowStringArray._from_sequence(["a", None, "b"])
  178: 
  179: 
  180: @pytest.mark.parametrize("multiple_chunks", [False, True])
  181: @pytest.mark.parametrize(
  182:     "key, value, expected",
  183:     [
  184:         (-1, "XX", ["a", "b", "c", "d", "XX"]),
  185:         (1, "XX", ["a", "XX", "c", "d", "e"]),
  186:         (1, None, ["a", None, "c", "d", "e"]),
  187:         (1, pd.NA, ["a", None, "c", "d", "e"]),
  188:         ([1, 3], "XX", ["a", "XX", "c", "XX", "e"]),
  189:         ([1, 3], ["XX", "YY"], ["a", "XX", "c", "YY", "e"]),
  190:         ([1, 3], ["XX", None], ["a", "XX", "c", None, "e"]),
  191:         ([1, 3], ["XX", pd.NA], ["a", "XX", "c", None, "e"]),
  192:         ([0, -1], ["XX", "YY"], ["XX", "b", "c", "d", "YY"]),
  193:         ([-1, 0], ["XX", "YY"], ["YY", "b", "c", "d", "XX"]),
  194:         (slice(3, None), "XX", ["a", "b", "c", "XX", "XX"]),
  195:         (slice(2, 4), ["XX", "YY"], ["a", "b", "XX", "YY", "e"]),
  196:         (slice(3, 1, -1), ["XX", "YY"], ["a", "b", "YY", "XX", "e"]),
  197:         (slice(None), "XX", ["XX", "XX", "XX", "XX", "XX"]),
  198:         ([False, True, False, True, False], ["XX", "YY"], ["a", "XX", "c", "YY", "e"]),
  199:     ],
  200: )
  201: def test_setitem(multiple_chunks, key, value, expected):
  202:     pa = pytest.importorskip("pyarrow")
  203: 
  204:     result = pa.array(list("abcde"))
  205:     expected = pa.array(expected)
  206: 
  207:     if multiple_chunks:
  208:         result = pa.chunked_array([result[:3], result[3:]])
  209:         expected = pa.chunked_array([expected[:3], expected[3:]])
  210: 
  211:     result = ArrowStringArray(result)
  212:     expected = ArrowStringArray(expected)
  213: 
  214:     result[key] = value
  215:     tm.assert_equal(result, expected)
  216: 
  217: 
  218: def test_setitem_invalid_indexer_raises():
  219:     pa = pytest.importorskip("pyarrow")
  220: 
  221:     arr = ArrowStringArray(pa.array(list("abcde")))
  222: 
  223:     with pytest.raises(IndexError, match=None):
  224:         arr[5] = "foo"
  225: 
  226:     with pytest.raises(IndexError, match=None):
  227:         arr[-6] = "foo"
  228: 
  229:     with pytest.raises(IndexError, match=None):
  230:         arr[[0, 5]] = "foo"
  231: 
  232:     with pytest.raises(IndexError, match=None):
  233:         arr[[0, -6]] = "foo"
  234: 
  235:     with pytest.raises(IndexError, match=None):
  236:         arr[[True, True, False]] = "foo"
  237: 
  238:     with pytest.raises(ValueError, match=None):
  239:         arr[[0, 1]] = ["foo", "bar", "baz"]
  240: 
  241: 
  242: @pytest.mark.parametrize("dtype", ["string[pyarrow]", "string[pyarrow_numpy]"])
  243: def test_pickle_roundtrip(dtype):
  244:     # GH 42600
  245:     pytest.importorskip("pyarrow")
  246:     expected = pd.Series(range(10), dtype=dtype)
  247:     expected_sliced = expected.head(2)
  248:     full_pickled = pickle.dumps(expected)
  249:     sliced_pickled = pickle.dumps(expected_sliced)
  250: 
  251:     assert len(full_pickled) > len(sliced_pickled)
  252: 
  253:     result = pickle.loads(full_pickled)
  254:     tm.assert_series_equal(result, expected)
  255: 
  256:     result_sliced = pickle.loads(sliced_pickled)
  257:     tm.assert_series_equal(result_sliced, expected_sliced)
  258: 
  259: 
  260: def test_string_dtype_error_message():
  261:     # GH#55051
  262:     pytest.importorskip("pyarrow")
  263:     msg = "Storage must be 'python', 'pyarrow' or 'pyarrow_numpy'."
  264:     with pytest.raises(ValueError, match=msg):
  265:         StringDtype("bla")
