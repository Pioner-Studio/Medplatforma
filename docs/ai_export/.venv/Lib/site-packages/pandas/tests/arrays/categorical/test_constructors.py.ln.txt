    1: from datetime import (
    2:     date,
    3:     datetime,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas._config import using_pyarrow_string_dtype
   10: 
   11: from pandas.core.dtypes.common import (
   12:     is_float_dtype,
   13:     is_integer_dtype,
   14: )
   15: from pandas.core.dtypes.dtypes import CategoricalDtype
   16: 
   17: import pandas as pd
   18: from pandas import (
   19:     Categorical,
   20:     CategoricalIndex,
   21:     DatetimeIndex,
   22:     Index,
   23:     Interval,
   24:     IntervalIndex,
   25:     MultiIndex,
   26:     NaT,
   27:     Series,
   28:     Timestamp,
   29:     date_range,
   30:     period_range,
   31:     timedelta_range,
   32: )
   33: import pandas._testing as tm
   34: 
   35: 
   36: class TestCategoricalConstructors:
   37:     def test_fastpath_deprecated(self):
   38:         codes = np.array([1, 2, 3])
   39:         dtype = CategoricalDtype(categories=["a", "b", "c", "d"], ordered=False)
   40:         msg = "The 'fastpath' keyword in Categorical is deprecated"
   41:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
   42:             Categorical(codes, dtype=dtype, fastpath=True)
   43: 
   44:     def test_categorical_from_cat_and_dtype_str_preserve_ordered(self):
   45:         # GH#49309 we should preserve orderedness in `res`
   46:         cat = Categorical([3, 1], categories=[3, 2, 1], ordered=True)
   47: 
   48:         res = Categorical(cat, dtype="category")
   49:         assert res.dtype.ordered
   50: 
   51:     def test_categorical_disallows_scalar(self):
   52:         # GH#38433
   53:         with pytest.raises(TypeError, match="Categorical input must be list-like"):
   54:             Categorical("A", categories=["A", "B"])
   55: 
   56:     def test_categorical_1d_only(self):
   57:         # ndim > 1
   58:         msg = "> 1 ndim Categorical are not supported at this time"
   59:         with pytest.raises(NotImplementedError, match=msg):
   60:             Categorical(np.array([list("abcd")]))
   61: 
   62:     def test_validate_ordered(self):
   63:         # see gh-14058
   64:         exp_msg = "'ordered' must either be 'True' or 'False'"
   65:         exp_err = TypeError
   66: 
   67:         # This should be a boolean.
   68:         ordered = np.array([0, 1, 2])
   69: 
   70:         with pytest.raises(exp_err, match=exp_msg):
   71:             Categorical([1, 2, 3], ordered=ordered)
   72: 
   73:         with pytest.raises(exp_err, match=exp_msg):
   74:             Categorical.from_codes(
   75:                 [0, 0, 1], categories=["a", "b", "c"], ordered=ordered
   76:             )
   77: 
   78:     def test_constructor_empty(self):
   79:         # GH 17248
   80:         c = Categorical([])
   81:         expected = Index([])
   82:         tm.assert_index_equal(c.categories, expected)
   83: 
   84:         c = Categorical([], categories=[1, 2, 3])
   85:         expected = Index([1, 2, 3], dtype=np.int64)
   86:         tm.assert_index_equal(c.categories, expected)
   87: 
   88:     def test_constructor_empty_boolean(self):
   89:         # see gh-22702
   90:         cat = Categorical([], categories=[True, False])
   91:         categories = sorted(cat.categories.tolist())
   92:         assert categories == [False, True]
   93: 
   94:     def test_constructor_tuples(self):
   95:         values = np.array([(1,), (1, 2), (1,), (1, 2)], dtype=object)
   96:         result = Categorical(values)
   97:         expected = Index([(1,), (1, 2)], tupleize_cols=False)
   98:         tm.assert_index_equal(result.categories, expected)
   99:         assert result.ordered is False
  100: 
  101:     def test_constructor_tuples_datetimes(self):
  102:         # numpy will auto reshape when all of the tuples are the
  103:         # same len, so add an extra one with 2 items and slice it off
  104:         values = np.array(
  105:             [
  106:                 (Timestamp("2010-01-01"),),
  107:                 (Timestamp("2010-01-02"),),
  108:                 (Timestamp("2010-01-01"),),
  109:                 (Timestamp("2010-01-02"),),
  110:                 ("a", "b"),
  111:             ],
  112:             dtype=object,
  113:         )[:-1]
  114:         result = Categorical(values)
  115:         expected = Index(
  116:             [(Timestamp("2010-01-01"),), (Timestamp("2010-01-02"),)],
  117:             tupleize_cols=False,
  118:         )
  119:         tm.assert_index_equal(result.categories, expected)
  120: 
  121:     def test_constructor_unsortable(self):
  122:         # it works!
  123:         arr = np.array([1, 2, 3, datetime.now()], dtype="O")
  124:         factor = Categorical(arr, ordered=False)
  125:         assert not factor.ordered
  126: 
  127:         # this however will raise as cannot be sorted
  128:         msg = (
  129:             "'values' is not ordered, please explicitly specify the "
  130:             "categories order by passing in a categories argument."
  131:         )
  132:         with pytest.raises(TypeError, match=msg):
  133:             Categorical(arr, ordered=True)
  134: 
  135:     def test_constructor_interval(self):
  136:         result = Categorical(
  137:             [Interval(1, 2), Interval(2, 3), Interval(3, 6)], ordered=True
  138:         )
  139:         ii = IntervalIndex([Interval(1, 2), Interval(2, 3), Interval(3, 6)])
  140:         exp = Categorical(ii, ordered=True)
  141:         tm.assert_categorical_equal(result, exp)
  142:         tm.assert_index_equal(result.categories, ii)
  143: 
  144:     def test_constructor(self):
  145:         exp_arr = np.array(["a", "b", "c", "a", "b", "c"], dtype=np.object_)
  146:         c1 = Categorical(exp_arr)
  147:         tm.assert_numpy_array_equal(c1.__array__(), exp_arr)
  148:         c2 = Categorical(exp_arr, categories=["a", "b", "c"])
  149:         tm.assert_numpy_array_equal(c2.__array__(), exp_arr)
  150:         c2 = Categorical(exp_arr, categories=["c", "b", "a"])
  151:         tm.assert_numpy_array_equal(c2.__array__(), exp_arr)
  152: 
  153:         # categories must be unique
  154:         msg = "Categorical categories must be unique"
  155:         with pytest.raises(ValueError, match=msg):
  156:             Categorical([1, 2], [1, 2, 2])
  157: 
  158:         with pytest.raises(ValueError, match=msg):
  159:             Categorical(["a", "b"], ["a", "b", "b"])
  160: 
  161:         # The default should be unordered
  162:         c1 = Categorical(["a", "b", "c", "a"])
  163:         assert not c1.ordered
  164: 
  165:         # Categorical as input
  166:         c1 = Categorical(["a", "b", "c", "a"])
  167:         c2 = Categorical(c1)
  168:         tm.assert_categorical_equal(c1, c2)
  169: 
  170:         c1 = Categorical(["a", "b", "c", "a"], categories=["a", "b", "c", "d"])
  171:         c2 = Categorical(c1)
  172:         tm.assert_categorical_equal(c1, c2)
  173: 
  174:         c1 = Categorical(["a", "b", "c", "a"], categories=["a", "c", "b"])
  175:         c2 = Categorical(c1)
  176:         tm.assert_categorical_equal(c1, c2)
  177: 
  178:         c1 = Categorical(["a", "b", "c", "a"], categories=["a", "c", "b"])
  179:         c2 = Categorical(c1, categories=["a", "b", "c"])
  180:         tm.assert_numpy_array_equal(c1.__array__(), c2.__array__())
  181:         tm.assert_index_equal(c2.categories, Index(["a", "b", "c"]))
  182: 
  183:         # Series of dtype category
  184:         c1 = Categorical(["a", "b", "c", "a"], categories=["a", "b", "c", "d"])
  185:         c2 = Categorical(Series(c1))
  186:         tm.assert_categorical_equal(c1, c2)
  187: 
  188:         c1 = Categorical(["a", "b", "c", "a"], categories=["a", "c", "b"])
  189:         c2 = Categorical(Series(c1))
  190:         tm.assert_categorical_equal(c1, c2)
  191: 
  192:         # Series
  193:         c1 = Categorical(["a", "b", "c", "a"])
  194:         c2 = Categorical(Series(["a", "b", "c", "a"]))
  195:         tm.assert_categorical_equal(c1, c2)
  196: 
  197:         c1 = Categorical(["a", "b", "c", "a"], categories=["a", "b", "c", "d"])
  198:         c2 = Categorical(Series(["a", "b", "c", "a"]), categories=["a", "b", "c", "d"])
  199:         tm.assert_categorical_equal(c1, c2)
  200: 
  201:         # This should result in integer categories, not float!
  202:         cat = Categorical([1, 2, 3, np.nan], categories=[1, 2, 3])
  203:         assert is_integer_dtype(cat.categories)
  204: 
  205:         # https://github.com/pandas-dev/pandas/issues/3678
  206:         cat = Categorical([np.nan, 1, 2, 3])
  207:         assert is_integer_dtype(cat.categories)
  208: 
  209:         # this should result in floats
  210:         cat = Categorical([np.nan, 1, 2.0, 3])
  211:         assert is_float_dtype(cat.categories)
  212: 
  213:         cat = Categorical([np.nan, 1.0, 2.0, 3.0])
  214:         assert is_float_dtype(cat.categories)
  215: 
  216:         # This doesn't work -> this would probably need some kind of "remember
  217:         # the original type" feature to try to cast the array interface result
  218:         # to...
  219: 
  220:         # vals = np.asarray(cat[cat.notna()])
  221:         # assert is_integer_dtype(vals)
  222: 
  223:         # corner cases
  224:         cat = Categorical([1])
  225:         assert len(cat.categories) == 1
  226:         assert cat.categories[0] == 1
  227:         assert len(cat.codes) == 1
  228:         assert cat.codes[0] == 0
  229: 
  230:         cat = Categorical(["a"])
  231:         assert len(cat.categories) == 1
  232:         assert cat.categories[0] == "a"
  233:         assert len(cat.codes) == 1
  234:         assert cat.codes[0] == 0
  235: 
  236:         # two arrays
  237:         #  - when the first is an integer dtype and the second is not
  238:         #  - when the resulting codes are all -1/NaN
  239:         with tm.assert_produces_warning(None):
  240:             Categorical([0, 1, 2, 0, 1, 2], categories=["a", "b", "c"])
  241: 
  242:         with tm.assert_produces_warning(None):
  243:             Categorical([0, 1, 2, 0, 1, 2], categories=[3, 4, 5])
  244: 
  245:         # the next one are from the old docs
  246:         with tm.assert_produces_warning(None):
  247:             Categorical([0, 1, 2, 0, 1, 2], [1, 2, 3])
  248:             cat = Categorical([1, 2], categories=[1, 2, 3])
  249: 
  250:         # this is a legitimate constructor
  251:         with tm.assert_produces_warning(None):
  252:             Categorical(np.array([], dtype="int64"), categories=[3, 2, 1], ordered=True)
  253: 
  254:     def test_constructor_with_existing_categories(self):
  255:         # GH25318: constructing with pd.Series used to bogusly skip recoding
  256:         # categories
  257:         c0 = Categorical(["a", "b", "c", "a"])
  258:         c1 = Categorical(["a", "b", "c", "a"], categories=["b", "c"])
  259: 
  260:         c2 = Categorical(c0, categories=c1.categories)
  261:         tm.assert_categorical_equal(c1, c2)
  262: 
  263:         c3 = Categorical(Series(c0), categories=c1.categories)
  264:         tm.assert_categorical_equal(c1, c3)
  265: 
  266:     def test_constructor_not_sequence(self):
  267:         # https://github.com/pandas-dev/pandas/issues/16022
  268:         msg = r"^Parameter 'categories' must be list-like, was"
  269:         with pytest.raises(TypeError, match=msg):
  270:             Categorical(["a", "b"], categories="a")
  271: 
  272:     def test_constructor_with_null(self):
  273:         # Cannot have NaN in categories
  274:         msg = "Categorical categories cannot be null"
  275:         with pytest.raises(ValueError, match=msg):
  276:             Categorical([np.nan, "a", "b", "c"], categories=[np.nan, "a", "b", "c"])
  277: 
  278:         with pytest.raises(ValueError, match=msg):
  279:             Categorical([None, "a", "b", "c"], categories=[None, "a", "b", "c"])
  280: 
  281:         with pytest.raises(ValueError, match=msg):
  282:             Categorical(
  283:                 DatetimeIndex(["nat", "20160101"]),
  284:                 categories=[NaT, Timestamp("20160101")],
  285:             )
  286: 
  287:     def test_constructor_with_index(self):
  288:         ci = CategoricalIndex(list("aabbca"), categories=list("cab"))
  289:         tm.assert_categorical_equal(ci.values, Categorical(ci))
  290: 
  291:         ci = CategoricalIndex(list("aabbca"), categories=list("cab"))
  292:         tm.assert_categorical_equal(
  293:             ci.values, Categorical(ci.astype(object), categories=ci.categories)
  294:         )
  295: 
  296:     def test_constructor_with_generator(self):
  297:         # This was raising an Error in isna(single_val).any() because isna
  298:         # returned a scalar for a generator
  299: 
  300:         exp = Categorical([0, 1, 2])
  301:         cat = Categorical(x for x in [0, 1, 2])
  302:         tm.assert_categorical_equal(cat, exp)
  303:         cat = Categorical(range(3))
  304:         tm.assert_categorical_equal(cat, exp)
  305: 
  306:         MultiIndex.from_product([range(5), ["a", "b", "c"]])
  307: 
  308:         # check that categories accept generators and sequences
  309:         cat = Categorical([0, 1, 2], categories=(x for x in [0, 1, 2]))
  310:         tm.assert_categorical_equal(cat, exp)
  311:         cat = Categorical([0, 1, 2], categories=range(3))
  312:         tm.assert_categorical_equal(cat, exp)
  313: 
  314:     def test_constructor_with_rangeindex(self):
  315:         # RangeIndex is preserved in Categories
  316:         rng = Index(range(3))
  317: 
  318:         cat = Categorical(rng)
  319:         tm.assert_index_equal(cat.categories, rng, exact=True)
  320: 
  321:         cat = Categorical([1, 2, 0], categories=rng)
  322:         tm.assert_index_equal(cat.categories, rng, exact=True)
  323: 
  324:     @pytest.mark.parametrize(
  325:         "dtl",
  326:         [
  327:             date_range("1995-01-01 00:00:00", periods=5, freq="s"),
  328:             date_range("1995-01-01 00:00:00", periods=5, freq="s", tz="US/Eastern"),
  329:             timedelta_range("1 day", periods=5, freq="s"),
  330:         ],
  331:     )
  332:     def test_constructor_with_datetimelike(self, dtl):
  333:         # see gh-12077
  334:         # constructor with a datetimelike and NaT
  335: 
  336:         s = Series(dtl)
  337:         c = Categorical(s)
  338: 
  339:         expected = type(dtl)(s)
  340:         expected._data.freq = None
  341: 
  342:         tm.assert_index_equal(c.categories, expected)
  343:         tm.assert_numpy_array_equal(c.codes, np.arange(5, dtype="int8"))
  344: 
  345:         # with NaT
  346:         s2 = s.copy()
  347:         s2.iloc[-1] = NaT
  348:         c = Categorical(s2)
  349: 
  350:         expected = type(dtl)(s2.dropna())
  351:         expected._data.freq = None
  352: 
  353:         tm.assert_index_equal(c.categories, expected)
  354: 
  355:         exp = np.array([0, 1, 2, 3, -1], dtype=np.int8)
  356:         tm.assert_numpy_array_equal(c.codes, exp)
  357: 
  358:         result = repr(c)
  359:         assert "NaT" in result
  360: 
  361:     def test_constructor_from_index_series_datetimetz(self):
  362:         idx = date_range("2015-01-01 10:00", freq="D", periods=3, tz="US/Eastern")
  363:         idx = idx._with_freq(None)  # freq not preserved in result.categories
  364:         result = Categorical(idx)
  365:         tm.assert_index_equal(result.categories, idx)
  366: 
  367:         result = Categorical(Series(idx))
  368:         tm.assert_index_equal(result.categories, idx)
  369: 
  370:     def test_constructor_date_objects(self):
  371:         # we dont cast date objects to timestamps, matching Index constructor
  372:         v = date.today()
  373: 
  374:         cat = Categorical([v, v])
  375:         assert cat.categories.dtype == object
  376:         assert type(cat.categories[0]) is date
  377: 
  378:     def test_constructor_from_index_series_timedelta(self):
  379:         idx = timedelta_range("1 days", freq="D", periods=3)
  380:         idx = idx._with_freq(None)  # freq not preserved in result.categories
  381:         result = Categorical(idx)
  382:         tm.assert_index_equal(result.categories, idx)
  383: 
  384:         result = Categorical(Series(idx))
  385:         tm.assert_index_equal(result.categories, idx)
  386: 
  387:     def test_constructor_from_index_series_period(self):
  388:         idx = period_range("2015-01-01", freq="D", periods=3)
  389:         result = Categorical(idx)
  390:         tm.assert_index_equal(result.categories, idx)
  391: 
  392:         result = Categorical(Series(idx))
  393:         tm.assert_index_equal(result.categories, idx)
  394: 
  395:     @pytest.mark.parametrize(
  396:         "values",
  397:         [
  398:             np.array([1.0, 1.2, 1.8, np.nan]),
  399:             np.array([1, 2, 3], dtype="int64"),
  400:             ["a", "b", "c", np.nan],
  401:             [pd.Period("2014-01"), pd.Period("2014-02"), NaT],
  402:             [Timestamp("2014-01-01"), Timestamp("2014-01-02"), NaT],
  403:             [
  404:                 Timestamp("2014-01-01", tz="US/Eastern"),
  405:                 Timestamp("2014-01-02", tz="US/Eastern"),
  406:                 NaT,
  407:             ],
  408:         ],
  409:     )
  410:     def test_constructor_invariant(self, values):
  411:         # GH 14190
  412:         c = Categorical(values)
  413:         c2 = Categorical(c)
  414:         tm.assert_categorical_equal(c, c2)
  415: 
  416:     @pytest.mark.parametrize("ordered", [True, False])
  417:     def test_constructor_with_dtype(self, ordered):
  418:         categories = ["b", "a", "c"]
  419:         dtype = CategoricalDtype(categories, ordered=ordered)
  420:         result = Categorical(["a", "b", "a", "c"], dtype=dtype)
  421:         expected = Categorical(
  422:             ["a", "b", "a", "c"], categories=categories, ordered=ordered
  423:         )
  424:         tm.assert_categorical_equal(result, expected)
  425:         assert result.ordered is ordered
  426: 
  427:     def test_constructor_dtype_and_others_raises(self):
  428:         dtype = CategoricalDtype(["a", "b"], ordered=True)
  429:         msg = "Cannot specify `categories` or `ordered` together with `dtype`."
  430:         with pytest.raises(ValueError, match=msg):
  431:             Categorical(["a", "b"], categories=["a", "b"], dtype=dtype)
  432: 
  433:         with pytest.raises(ValueError, match=msg):
  434:             Categorical(["a", "b"], ordered=True, dtype=dtype)
  435: 
  436:         with pytest.raises(ValueError, match=msg):
  437:             Categorical(["a", "b"], ordered=False, dtype=dtype)
  438: 
  439:     @pytest.mark.parametrize("categories", [None, ["a", "b"], ["a", "c"]])
  440:     @pytest.mark.parametrize("ordered", [True, False])
  441:     def test_constructor_str_category(self, categories, ordered):
  442:         result = Categorical(
  443:             ["a", "b"], categories=categories, ordered=ordered, dtype="category"
  444:         )
  445:         expected = Categorical(["a", "b"], categories=categories, ordered=ordered)
  446:         tm.assert_categorical_equal(result, expected)
  447: 
  448:     def test_constructor_str_unknown(self):
  449:         with pytest.raises(ValueError, match="Unknown dtype"):
  450:             Categorical([1, 2], dtype="foo")
  451: 
  452:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="Can't be NumPy strings")
  453:     def test_constructor_np_strs(self):
  454:         # GH#31499 Hashtable.map_locations needs to work on np.str_ objects
  455:         cat = Categorical(["1", "0", "1"], [np.str_("0"), np.str_("1")])
  456:         assert all(isinstance(x, np.str_) for x in cat.categories)
  457: 
  458:     def test_constructor_from_categorical_with_dtype(self):
  459:         dtype = CategoricalDtype(["a", "b", "c"], ordered=True)
  460:         values = Categorical(["a", "b", "d"])
  461:         result = Categorical(values, dtype=dtype)
  462:         # We use dtype.categories, not values.categories
  463:         expected = Categorical(
  464:             ["a", "b", "d"], categories=["a", "b", "c"], ordered=True
  465:         )
  466:         tm.assert_categorical_equal(result, expected)
  467: 
  468:     def test_constructor_from_categorical_with_unknown_dtype(self):
  469:         dtype = CategoricalDtype(None, ordered=True)
  470:         values = Categorical(["a", "b", "d"])
  471:         result = Categorical(values, dtype=dtype)
  472:         # We use values.categories, not dtype.categories
  473:         expected = Categorical(
  474:             ["a", "b", "d"], categories=["a", "b", "d"], ordered=True
  475:         )
  476:         tm.assert_categorical_equal(result, expected)
  477: 
  478:     def test_constructor_from_categorical_string(self):
  479:         values = Categorical(["a", "b", "d"])
  480:         # use categories, ordered
  481:         result = Categorical(
  482:             values, categories=["a", "b", "c"], ordered=True, dtype="category"
  483:         )
  484:         expected = Categorical(
  485:             ["a", "b", "d"], categories=["a", "b", "c"], ordered=True
  486:         )
  487:         tm.assert_categorical_equal(result, expected)
  488: 
  489:         # No string
  490:         result = Categorical(values, categories=["a", "b", "c"], ordered=True)
  491:         tm.assert_categorical_equal(result, expected)
  492: 
  493:     def test_constructor_with_categorical_categories(self):
  494:         # GH17884
  495:         expected = Categorical(["a", "b"], categories=["a", "b", "c"])
  496: 
  497:         result = Categorical(["a", "b"], categories=Categorical(["a", "b", "c"]))
  498:         tm.assert_categorical_equal(result, expected)
  499: 
  500:         result = Categorical(["a", "b"], categories=CategoricalIndex(["a", "b", "c"]))
  501:         tm.assert_categorical_equal(result, expected)
  502: 
  503:     @pytest.mark.parametrize("klass", [lambda x: np.array(x, dtype=object), list])
  504:     def test_construction_with_null(self, klass, nulls_fixture):
  505:         # https://github.com/pandas-dev/pandas/issues/31927
  506:         values = klass(["a", nulls_fixture, "b"])
  507:         result = Categorical(values)
  508: 
  509:         dtype = CategoricalDtype(["a", "b"])
  510:         codes = [0, -1, 1]
  511:         expected = Categorical.from_codes(codes=codes, dtype=dtype)
  512: 
  513:         tm.assert_categorical_equal(result, expected)
  514: 
  515:     @pytest.mark.parametrize("validate", [True, False])
  516:     def test_from_codes_nullable_int_categories(self, any_numeric_ea_dtype, validate):
  517:         # GH#39649
  518:         cats = pd.array(range(5), dtype=any_numeric_ea_dtype)
  519:         codes = np.random.default_rng(2).integers(5, size=3)
  520:         dtype = CategoricalDtype(cats)
  521:         arr = Categorical.from_codes(codes, dtype=dtype, validate=validate)
  522:         assert arr.categories.dtype == cats.dtype
  523:         tm.assert_index_equal(arr.categories, Index(cats))
  524: 
  525:     def test_from_codes_empty(self):
  526:         cat = ["a", "b", "c"]
  527:         result = Categorical.from_codes([], categories=cat)
  528:         expected = Categorical([], categories=cat)
  529: 
  530:         tm.assert_categorical_equal(result, expected)
  531: 
  532:     @pytest.mark.parametrize("validate", [True, False])
  533:     def test_from_codes_validate(self, validate):
  534:         # GH53122
  535:         dtype = CategoricalDtype(["a", "b"])
  536:         if validate:
  537:             with pytest.raises(ValueError, match="codes need to be between "):
  538:                 Categorical.from_codes([4, 5], dtype=dtype, validate=validate)
  539:         else:
  540:             # passes, though has incorrect codes, but that's the user responsibility
  541:             Categorical.from_codes([4, 5], dtype=dtype, validate=validate)
  542: 
  543:     def test_from_codes_too_few_categories(self):
  544:         dtype = CategoricalDtype(categories=[1, 2])
  545:         msg = "codes need to be between "
  546:         with pytest.raises(ValueError, match=msg):
  547:             Categorical.from_codes([1, 2], categories=dtype.categories)
  548:         with pytest.raises(ValueError, match=msg):
  549:             Categorical.from_codes([1, 2], dtype=dtype)
  550: 
  551:     def test_from_codes_non_int_codes(self):
  552:         dtype = CategoricalDtype(categories=[1, 2])
  553:         msg = "codes need to be array-like integers"
  554:         with pytest.raises(ValueError, match=msg):
  555:             Categorical.from_codes(["a"], categories=dtype.categories)
  556:         with pytest.raises(ValueError, match=msg):
  557:             Categorical.from_codes(["a"], dtype=dtype)
  558: 
  559:     def test_from_codes_non_unique_categories(self):
  560:         with pytest.raises(ValueError, match="Categorical categories must be unique"):
  561:             Categorical.from_codes([0, 1, 2], categories=["a", "a", "b"])
  562: 
  563:     def test_from_codes_nan_cat_included(self):
  564:         with pytest.raises(ValueError, match="Categorical categories cannot be null"):
  565:             Categorical.from_codes([0, 1, 2], categories=["a", "b", np.nan])
  566: 
  567:     def test_from_codes_too_negative(self):
  568:         dtype = CategoricalDtype(categories=["a", "b", "c"])
  569:         msg = r"codes need to be between -1 and len\(categories\)-1"
  570:         with pytest.raises(ValueError, match=msg):
  571:             Categorical.from_codes([-2, 1, 2], categories=dtype.categories)
  572:         with pytest.raises(ValueError, match=msg):
  573:             Categorical.from_codes([-2, 1, 2], dtype=dtype)
  574: 
  575:     def test_from_codes(self):
  576:         dtype = CategoricalDtype(categories=["a", "b", "c"])
  577:         exp = Categorical(["a", "b", "c"], ordered=False)
  578:         res = Categorical.from_codes([0, 1, 2], categories=dtype.categories)
  579:         tm.assert_categorical_equal(exp, res)
  580: 
  581:         res = Categorical.from_codes([0, 1, 2], dtype=dtype)
  582:         tm.assert_categorical_equal(exp, res)
  583: 
  584:     @pytest.mark.parametrize("klass", [Categorical, CategoricalIndex])
  585:     def test_from_codes_with_categorical_categories(self, klass):
  586:         # GH17884
  587:         expected = Categorical(["a", "b"], categories=["a", "b", "c"])
  588: 
  589:         result = Categorical.from_codes([0, 1], categories=klass(["a", "b", "c"]))
  590:         tm.assert_categorical_equal(result, expected)
  591: 
  592:     @pytest.mark.parametrize("klass", [Categorical, CategoricalIndex])
  593:     def test_from_codes_with_non_unique_categorical_categories(self, klass):
  594:         with pytest.raises(ValueError, match="Categorical categories must be unique"):
  595:             Categorical.from_codes([0, 1], klass(["a", "b", "a"]))
  596: 
  597:     def test_from_codes_with_nan_code(self):
  598:         # GH21767
  599:         codes = [1, 2, np.nan]
  600:         dtype = CategoricalDtype(categories=["a", "b", "c"])
  601:         with pytest.raises(ValueError, match="codes need to be array-like integers"):
  602:             Categorical.from_codes(codes, categories=dtype.categories)
  603:         with pytest.raises(ValueError, match="codes need to be array-like integers"):
  604:             Categorical.from_codes(codes, dtype=dtype)
  605: 
  606:     @pytest.mark.parametrize("codes", [[1.0, 2.0, 0], [1.1, 2.0, 0]])
  607:     def test_from_codes_with_float(self, codes):
  608:         # GH21767
  609:         # float codes should raise even if values are equal to integers
  610:         dtype = CategoricalDtype(categories=["a", "b", "c"])
  611: 
  612:         msg = "codes need to be array-like integers"
  613:         with pytest.raises(ValueError, match=msg):
  614:             Categorical.from_codes(codes, dtype.categories)
  615:         with pytest.raises(ValueError, match=msg):
  616:             Categorical.from_codes(codes, dtype=dtype)
  617: 
  618:     def test_from_codes_with_dtype_raises(self):
  619:         msg = "Cannot specify"
  620:         with pytest.raises(ValueError, match=msg):
  621:             Categorical.from_codes(
  622:                 [0, 1], categories=["a", "b"], dtype=CategoricalDtype(["a", "b"])
  623:             )
  624: 
  625:         with pytest.raises(ValueError, match=msg):
  626:             Categorical.from_codes(
  627:                 [0, 1], ordered=True, dtype=CategoricalDtype(["a", "b"])
  628:             )
  629: 
  630:     def test_from_codes_neither(self):
  631:         msg = "Both were None"
  632:         with pytest.raises(ValueError, match=msg):
  633:             Categorical.from_codes([0, 1])
  634: 
  635:     def test_from_codes_with_nullable_int(self):
  636:         codes = pd.array([0, 1], dtype="Int64")
  637:         categories = ["a", "b"]
  638: 
  639:         result = Categorical.from_codes(codes, categories=categories)
  640:         expected = Categorical.from_codes(codes.to_numpy(int), categories=categories)
  641: 
  642:         tm.assert_categorical_equal(result, expected)
  643: 
  644:     def test_from_codes_with_nullable_int_na_raises(self):
  645:         codes = pd.array([0, None], dtype="Int64")
  646:         categories = ["a", "b"]
  647: 
  648:         msg = "codes cannot contain NA values"
  649:         with pytest.raises(ValueError, match=msg):
  650:             Categorical.from_codes(codes, categories=categories)
  651: 
  652:     @pytest.mark.parametrize("dtype", [None, "category"])
  653:     def test_from_inferred_categories(self, dtype):
  654:         cats = ["a", "b"]
  655:         codes = np.array([0, 0, 1, 1], dtype="i8")
  656:         result = Categorical._from_inferred_categories(cats, codes, dtype)
  657:         expected = Categorical.from_codes(codes, cats)
  658:         tm.assert_categorical_equal(result, expected)
  659: 
  660:     @pytest.mark.parametrize("dtype", [None, "category"])
  661:     def test_from_inferred_categories_sorts(self, dtype):
  662:         cats = ["b", "a"]
  663:         codes = np.array([0, 1, 1, 1], dtype="i8")
  664:         result = Categorical._from_inferred_categories(cats, codes, dtype)
  665:         expected = Categorical.from_codes([1, 0, 0, 0], ["a", "b"])
  666:         tm.assert_categorical_equal(result, expected)
  667: 
  668:     def test_from_inferred_categories_dtype(self):
  669:         cats = ["a", "b", "d"]
  670:         codes = np.array([0, 1, 0, 2], dtype="i8")
  671:         dtype = CategoricalDtype(["c", "b", "a"], ordered=True)
  672:         result = Categorical._from_inferred_categories(cats, codes, dtype)
  673:         expected = Categorical(
  674:             ["a", "b", "a", "d"], categories=["c", "b", "a"], ordered=True
  675:         )
  676:         tm.assert_categorical_equal(result, expected)
  677: 
  678:     def test_from_inferred_categories_coerces(self):
  679:         cats = ["1", "2", "bad"]
  680:         codes = np.array([0, 0, 1, 2], dtype="i8")
  681:         dtype = CategoricalDtype([1, 2])
  682:         result = Categorical._from_inferred_categories(cats, codes, dtype)
  683:         expected = Categorical([1, 1, 2, np.nan])
  684:         tm.assert_categorical_equal(result, expected)
  685: 
  686:     @pytest.mark.parametrize("ordered", [None, True, False])
  687:     def test_construction_with_ordered(self, ordered):
  688:         # GH 9347, 9190
  689:         cat = Categorical([0, 1, 2], ordered=ordered)
  690:         assert cat.ordered == bool(ordered)
  691: 
  692:     def test_constructor_imaginary(self):
  693:         values = [1, 2, 3 + 1j]
  694:         c1 = Categorical(values)
  695:         tm.assert_index_equal(c1.categories, Index(values))
  696:         tm.assert_numpy_array_equal(np.array(c1), np.array(values))
  697: 
  698:     def test_constructor_string_and_tuples(self):
  699:         # GH 21416
  700:         c = Categorical(np.array(["c", ("a", "b"), ("b", "a"), "c"], dtype=object))
  701:         expected_index = Index([("a", "b"), ("b", "a"), "c"])
  702:         assert c.categories.equals(expected_index)
  703: 
  704:     def test_interval(self):
  705:         idx = pd.interval_range(0, 10, periods=10)
  706:         cat = Categorical(idx, categories=idx)
  707:         expected_codes = np.arange(10, dtype="int8")
  708:         tm.assert_numpy_array_equal(cat.codes, expected_codes)
  709:         tm.assert_index_equal(cat.categories, idx)
  710: 
  711:         # infer categories
  712:         cat = Categorical(idx)
  713:         tm.assert_numpy_array_equal(cat.codes, expected_codes)
  714:         tm.assert_index_equal(cat.categories, idx)
  715: 
  716:         # list values
  717:         cat = Categorical(list(idx))
  718:         tm.assert_numpy_array_equal(cat.codes, expected_codes)
  719:         tm.assert_index_equal(cat.categories, idx)
  720: 
  721:         # list values, categories
  722:         cat = Categorical(list(idx), categories=list(idx))
  723:         tm.assert_numpy_array_equal(cat.codes, expected_codes)
  724:         tm.assert_index_equal(cat.categories, idx)
  725: 
  726:         # shuffled
  727:         values = idx.take([1, 2, 0])
  728:         cat = Categorical(values, categories=idx)
  729:         tm.assert_numpy_array_equal(cat.codes, np.array([1, 2, 0], dtype="int8"))
  730:         tm.assert_index_equal(cat.categories, idx)
  731: 
  732:         # extra
  733:         values = pd.interval_range(8, 11, periods=3)
  734:         cat = Categorical(values, categories=idx)
  735:         expected_codes = np.array([8, 9, -1], dtype="int8")
  736:         tm.assert_numpy_array_equal(cat.codes, expected_codes)
  737:         tm.assert_index_equal(cat.categories, idx)
  738: 
  739:         # overlapping
  740:         idx = IntervalIndex([Interval(0, 2), Interval(0, 1)])
  741:         cat = Categorical(idx, categories=idx)
  742:         expected_codes = np.array([0, 1], dtype="int8")
  743:         tm.assert_numpy_array_equal(cat.codes, expected_codes)
  744:         tm.assert_index_equal(cat.categories, idx)
  745: 
  746:     def test_categorical_extension_array_nullable(self, nulls_fixture):
  747:         # GH:
  748:         arr = pd.arrays.StringArray._from_sequence(
  749:             [nulls_fixture] * 2, dtype=pd.StringDtype()
  750:         )
  751:         result = Categorical(arr)
  752:         assert arr.dtype == result.categories.dtype
  753:         expected = Categorical(Series([pd.NA, pd.NA], dtype=arr.dtype))
  754:         tm.assert_categorical_equal(result, expected)
  755: 
  756:     def test_from_sequence_copy(self):
  757:         cat = Categorical(np.arange(5).repeat(2))
  758:         result = Categorical._from_sequence(cat, dtype=cat.dtype, copy=False)
  759: 
  760:         # more generally, we'd be OK with a view
  761:         assert result._codes is cat._codes
  762: 
  763:         result = Categorical._from_sequence(cat, dtype=cat.dtype, copy=True)
  764: 
  765:         assert not tm.shares_memory(result, cat)
  766: 
  767:     def test_constructor_datetime64_non_nano(self):
  768:         categories = np.arange(10).view("M8[D]")
  769:         values = categories[::2].copy()
  770: 
  771:         cat = Categorical(values, categories=categories)
  772:         assert (cat == values).all()
  773: 
  774:     def test_constructor_preserves_freq(self):
  775:         # GH33830 freq retention in categorical
  776:         dti = date_range("2016-01-01", periods=5)
  777: 
  778:         expected = dti.freq
  779: 
  780:         cat = Categorical(dti)
  781:         result = cat.categories.freq
  782: 
  783:         assert expected == result
