    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Categorical,
    7:     DataFrame,
    8:     Series,
    9:     Timestamp,
   10:     date_range,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: class TestCategoricalOpsWithFactor:
   16:     def test_categories_none_comparisons(self):
   17:         factor = Categorical(["a", "b", "b", "a", "a", "c", "c", "c"], ordered=True)
   18:         tm.assert_categorical_equal(factor, factor)
   19: 
   20:     def test_comparisons(self):
   21:         factor = Categorical(["a", "b", "b", "a", "a", "c", "c", "c"], ordered=True)
   22:         result = factor[factor == "a"]
   23:         expected = factor[np.asarray(factor) == "a"]
   24:         tm.assert_categorical_equal(result, expected)
   25: 
   26:         result = factor[factor != "a"]
   27:         expected = factor[np.asarray(factor) != "a"]
   28:         tm.assert_categorical_equal(result, expected)
   29: 
   30:         result = factor[factor < "c"]
   31:         expected = factor[np.asarray(factor) < "c"]
   32:         tm.assert_categorical_equal(result, expected)
   33: 
   34:         result = factor[factor > "a"]
   35:         expected = factor[np.asarray(factor) > "a"]
   36:         tm.assert_categorical_equal(result, expected)
   37: 
   38:         result = factor[factor >= "b"]
   39:         expected = factor[np.asarray(factor) >= "b"]
   40:         tm.assert_categorical_equal(result, expected)
   41: 
   42:         result = factor[factor <= "b"]
   43:         expected = factor[np.asarray(factor) <= "b"]
   44:         tm.assert_categorical_equal(result, expected)
   45: 
   46:         n = len(factor)
   47: 
   48:         other = factor[np.random.default_rng(2).permutation(n)]
   49:         result = factor == other
   50:         expected = np.asarray(factor) == np.asarray(other)
   51:         tm.assert_numpy_array_equal(result, expected)
   52: 
   53:         result = factor == "d"
   54:         expected = np.zeros(len(factor), dtype=bool)
   55:         tm.assert_numpy_array_equal(result, expected)
   56: 
   57:         # comparisons with categoricals
   58:         cat_rev = Categorical(["a", "b", "c"], categories=["c", "b", "a"], ordered=True)
   59:         cat_rev_base = Categorical(
   60:             ["b", "b", "b"], categories=["c", "b", "a"], ordered=True
   61:         )
   62:         cat = Categorical(["a", "b", "c"], ordered=True)
   63:         cat_base = Categorical(["b", "b", "b"], categories=cat.categories, ordered=True)
   64: 
   65:         # comparisons need to take categories ordering into account
   66:         res_rev = cat_rev > cat_rev_base
   67:         exp_rev = np.array([True, False, False])
   68:         tm.assert_numpy_array_equal(res_rev, exp_rev)
   69: 
   70:         res_rev = cat_rev < cat_rev_base
   71:         exp_rev = np.array([False, False, True])
   72:         tm.assert_numpy_array_equal(res_rev, exp_rev)
   73: 
   74:         res = cat > cat_base
   75:         exp = np.array([False, False, True])
   76:         tm.assert_numpy_array_equal(res, exp)
   77: 
   78:         # Only categories with same categories can be compared
   79:         msg = "Categoricals can only be compared if 'categories' are the same"
   80:         with pytest.raises(TypeError, match=msg):
   81:             cat > cat_rev
   82: 
   83:         cat_rev_base2 = Categorical(["b", "b", "b"], categories=["c", "b", "a", "d"])
   84: 
   85:         with pytest.raises(TypeError, match=msg):
   86:             cat_rev > cat_rev_base2
   87: 
   88:         # Only categories with same ordering information can be compared
   89:         cat_unordered = cat.set_ordered(False)
   90:         assert not (cat > cat).any()
   91: 
   92:         with pytest.raises(TypeError, match=msg):
   93:             cat > cat_unordered
   94: 
   95:         # comparison (in both directions) with Series will raise
   96:         s = Series(["b", "b", "b"], dtype=object)
   97:         msg = (
   98:             "Cannot compare a Categorical for op __gt__ with type "
   99:             r"<class 'numpy\.ndarray'>"
  100:         )
  101:         with pytest.raises(TypeError, match=msg):
  102:             cat > s
  103:         with pytest.raises(TypeError, match=msg):
  104:             cat_rev > s
  105:         with pytest.raises(TypeError, match=msg):
  106:             s < cat
  107:         with pytest.raises(TypeError, match=msg):
  108:             s < cat_rev
  109: 
  110:         # comparison with numpy.array will raise in both direction, but only on
  111:         # newer numpy versions
  112:         a = np.array(["b", "b", "b"], dtype=object)
  113:         with pytest.raises(TypeError, match=msg):
  114:             cat > a
  115:         with pytest.raises(TypeError, match=msg):
  116:             cat_rev > a
  117: 
  118:         # Make sure that unequal comparison take the categories order in
  119:         # account
  120:         cat_rev = Categorical(list("abc"), categories=list("cba"), ordered=True)
  121:         exp = np.array([True, False, False])
  122:         res = cat_rev > "b"
  123:         tm.assert_numpy_array_equal(res, exp)
  124: 
  125:         # check that zero-dim array gets unboxed
  126:         res = cat_rev > np.array("b")
  127:         tm.assert_numpy_array_equal(res, exp)
  128: 
  129: 
  130: class TestCategoricalOps:
  131:     @pytest.mark.parametrize(
  132:         "categories",
  133:         [["a", "b"], [0, 1], [Timestamp("2019"), Timestamp("2020")]],
  134:     )
  135:     def test_not_equal_with_na(self, categories):
  136:         # https://github.com/pandas-dev/pandas/issues/32276
  137:         c1 = Categorical.from_codes([-1, 0], categories=categories)
  138:         c2 = Categorical.from_codes([0, 1], categories=categories)
  139: 
  140:         result = c1 != c2
  141: 
  142:         assert result.all()
  143: 
  144:     def test_compare_frame(self):
  145:         # GH#24282 check that Categorical.__cmp__(DataFrame) defers to frame
  146:         data = ["a", "b", 2, "a"]
  147:         cat = Categorical(data)
  148: 
  149:         df = DataFrame(cat)
  150: 
  151:         result = cat == df.T
  152:         expected = DataFrame([[True, True, True, True]])
  153:         tm.assert_frame_equal(result, expected)
  154: 
  155:         result = cat[::-1] != df.T
  156:         expected = DataFrame([[False, True, True, False]])
  157:         tm.assert_frame_equal(result, expected)
  158: 
  159:     def test_compare_frame_raises(self, comparison_op):
  160:         # alignment raises unless we transpose
  161:         op = comparison_op
  162:         cat = Categorical(["a", "b", 2, "a"])
  163:         df = DataFrame(cat)
  164:         msg = "Unable to coerce to Series, length must be 1: given 4"
  165:         with pytest.raises(ValueError, match=msg):
  166:             op(cat, df)
  167: 
  168:     def test_datetime_categorical_comparison(self):
  169:         dt_cat = Categorical(date_range("2014-01-01", periods=3), ordered=True)
  170:         tm.assert_numpy_array_equal(dt_cat > dt_cat[0], np.array([False, True, True]))
  171:         tm.assert_numpy_array_equal(dt_cat[0] < dt_cat, np.array([False, True, True]))
  172: 
  173:     def test_reflected_comparison_with_scalars(self):
  174:         # GH8658
  175:         cat = Categorical([1, 2, 3], ordered=True)
  176:         tm.assert_numpy_array_equal(cat > cat[0], np.array([False, True, True]))
  177:         tm.assert_numpy_array_equal(cat[0] < cat, np.array([False, True, True]))
  178: 
  179:     def test_comparison_with_unknown_scalars(self):
  180:         # https://github.com/pandas-dev/pandas/issues/9836#issuecomment-92123057
  181:         # and following comparisons with scalars not in categories should raise
  182:         # for unequal comps, but not for equal/not equal
  183:         cat = Categorical([1, 2, 3], ordered=True)
  184: 
  185:         msg = "Invalid comparison between dtype=category and int"
  186:         with pytest.raises(TypeError, match=msg):
  187:             cat < 4
  188:         with pytest.raises(TypeError, match=msg):
  189:             cat > 4
  190:         with pytest.raises(TypeError, match=msg):
  191:             4 < cat
  192:         with pytest.raises(TypeError, match=msg):
  193:             4 > cat
  194: 
  195:         tm.assert_numpy_array_equal(cat == 4, np.array([False, False, False]))
  196:         tm.assert_numpy_array_equal(cat != 4, np.array([True, True, True]))
  197: 
  198:     def test_comparison_with_tuple(self):
  199:         cat = Categorical(np.array(["foo", (0, 1), 3, (0, 1)], dtype=object))
  200: 
  201:         result = cat == "foo"
  202:         expected = np.array([True, False, False, False], dtype=bool)
  203:         tm.assert_numpy_array_equal(result, expected)
  204: 
  205:         result = cat == (0, 1)
  206:         expected = np.array([False, True, False, True], dtype=bool)
  207:         tm.assert_numpy_array_equal(result, expected)
  208: 
  209:         result = cat != (0, 1)
  210:         tm.assert_numpy_array_equal(result, ~expected)
  211: 
  212:     @pytest.mark.filterwarnings("ignore::RuntimeWarning")
  213:     def test_comparison_of_ordered_categorical_with_nan_to_scalar(
  214:         self, compare_operators_no_eq_ne
  215:     ):
  216:         # https://github.com/pandas-dev/pandas/issues/26504
  217:         # BUG: fix ordered categorical comparison with missing values (#26504 )
  218:         # and following comparisons with scalars in categories with missing
  219:         # values should be evaluated as False
  220: 
  221:         cat = Categorical([1, 2, 3, None], categories=[1, 2, 3], ordered=True)
  222:         scalar = 2
  223:         expected = getattr(np.array(cat), compare_operators_no_eq_ne)(scalar)
  224:         actual = getattr(cat, compare_operators_no_eq_ne)(scalar)
  225:         tm.assert_numpy_array_equal(actual, expected)
  226: 
  227:     @pytest.mark.filterwarnings("ignore::RuntimeWarning")
  228:     def test_comparison_of_ordered_categorical_with_nan_to_listlike(
  229:         self, compare_operators_no_eq_ne
  230:     ):
  231:         # https://github.com/pandas-dev/pandas/issues/26504
  232:         # and following comparisons of missing values in ordered Categorical
  233:         # with listlike should be evaluated as False
  234: 
  235:         cat = Categorical([1, 2, 3, None], categories=[1, 2, 3], ordered=True)
  236:         other = Categorical([2, 2, 2, 2], categories=[1, 2, 3], ordered=True)
  237:         expected = getattr(np.array(cat), compare_operators_no_eq_ne)(2)
  238:         actual = getattr(cat, compare_operators_no_eq_ne)(other)
  239:         tm.assert_numpy_array_equal(actual, expected)
  240: 
  241:     @pytest.mark.parametrize(
  242:         "data,reverse,base",
  243:         [(list("abc"), list("cba"), list("bbb")), ([1, 2, 3], [3, 2, 1], [2, 2, 2])],
  244:     )
  245:     def test_comparisons(self, data, reverse, base):
  246:         cat_rev = Series(Categorical(data, categories=reverse, ordered=True))
  247:         cat_rev_base = Series(Categorical(base, categories=reverse, ordered=True))
  248:         cat = Series(Categorical(data, ordered=True))
  249:         cat_base = Series(
  250:             Categorical(base, categories=cat.cat.categories, ordered=True)
  251:         )
  252:         s = Series(base, dtype=object if base == list("bbb") else None)
  253:         a = np.array(base)
  254: 
  255:         # comparisons need to take categories ordering into account
  256:         res_rev = cat_rev > cat_rev_base
  257:         exp_rev = Series([True, False, False])
  258:         tm.assert_series_equal(res_rev, exp_rev)
  259: 
  260:         res_rev = cat_rev < cat_rev_base
  261:         exp_rev = Series([False, False, True])
  262:         tm.assert_series_equal(res_rev, exp_rev)
  263: 
  264:         res = cat > cat_base
  265:         exp = Series([False, False, True])
  266:         tm.assert_series_equal(res, exp)
  267: 
  268:         scalar = base[1]
  269:         res = cat > scalar
  270:         exp = Series([False, False, True])
  271:         exp2 = cat.values > scalar
  272:         tm.assert_series_equal(res, exp)
  273:         tm.assert_numpy_array_equal(res.values, exp2)
  274:         res_rev = cat_rev > scalar
  275:         exp_rev = Series([True, False, False])
  276:         exp_rev2 = cat_rev.values > scalar
  277:         tm.assert_series_equal(res_rev, exp_rev)
  278:         tm.assert_numpy_array_equal(res_rev.values, exp_rev2)
  279: 
  280:         # Only categories with same categories can be compared
  281:         msg = "Categoricals can only be compared if 'categories' are the same"
  282:         with pytest.raises(TypeError, match=msg):
  283:             cat > cat_rev
  284: 
  285:         # categorical cannot be compared to Series or numpy array, and also
  286:         # not the other way around
  287:         msg = (
  288:             "Cannot compare a Categorical for op __gt__ with type "
  289:             r"<class 'numpy\.ndarray'>"
  290:         )
  291:         with pytest.raises(TypeError, match=msg):
  292:             cat > s
  293:         with pytest.raises(TypeError, match=msg):
  294:             cat_rev > s
  295:         with pytest.raises(TypeError, match=msg):
  296:             cat > a
  297:         with pytest.raises(TypeError, match=msg):
  298:             cat_rev > a
  299: 
  300:         with pytest.raises(TypeError, match=msg):
  301:             s < cat
  302:         with pytest.raises(TypeError, match=msg):
  303:             s < cat_rev
  304: 
  305:         with pytest.raises(TypeError, match=msg):
  306:             a < cat
  307:         with pytest.raises(TypeError, match=msg):
  308:             a < cat_rev
  309: 
  310:     @pytest.mark.parametrize(
  311:         "ctor",
  312:         [
  313:             lambda *args, **kwargs: Categorical(*args, **kwargs),
  314:             lambda *args, **kwargs: Series(Categorical(*args, **kwargs)),
  315:         ],
  316:     )
  317:     def test_unordered_different_order_equal(self, ctor):
  318:         # https://github.com/pandas-dev/pandas/issues/16014
  319:         c1 = ctor(["a", "b"], categories=["a", "b"], ordered=False)
  320:         c2 = ctor(["a", "b"], categories=["b", "a"], ordered=False)
  321:         assert (c1 == c2).all()
  322: 
  323:         c1 = ctor(["a", "b"], categories=["a", "b"], ordered=False)
  324:         c2 = ctor(["b", "a"], categories=["b", "a"], ordered=False)
  325:         assert (c1 != c2).all()
  326: 
  327:         c1 = ctor(["a", "a"], categories=["a", "b"], ordered=False)
  328:         c2 = ctor(["b", "b"], categories=["b", "a"], ordered=False)
  329:         assert (c1 != c2).all()
  330: 
  331:         c1 = ctor(["a", "a"], categories=["a", "b"], ordered=False)
  332:         c2 = ctor(["a", "b"], categories=["b", "a"], ordered=False)
  333:         result = c1 == c2
  334:         tm.assert_numpy_array_equal(np.array(result), np.array([True, False]))
  335: 
  336:     def test_unordered_different_categories_raises(self):
  337:         c1 = Categorical(["a", "b"], categories=["a", "b"], ordered=False)
  338:         c2 = Categorical(["a", "c"], categories=["c", "a"], ordered=False)
  339: 
  340:         with pytest.raises(TypeError, match=("Categoricals can only be compared")):
  341:             c1 == c2
  342: 
  343:     def test_compare_different_lengths(self):
  344:         c1 = Categorical([], categories=["a", "b"])
  345:         c2 = Categorical([], categories=["a"])
  346: 
  347:         msg = "Categoricals can only be compared if 'categories' are the same."
  348:         with pytest.raises(TypeError, match=msg):
  349:             c1 == c2
  350: 
  351:     def test_compare_unordered_different_order(self):
  352:         # https://github.com/pandas-dev/pandas/issues/16603#issuecomment-
  353:         # 349290078
  354:         a = Categorical(["a"], categories=["a", "b"])
  355:         b = Categorical(["b"], categories=["b", "a"])
  356:         assert not a.equals(b)
  357: 
  358:     def test_numeric_like_ops(self):
  359:         df = DataFrame({"value": np.random.default_rng(2).integers(0, 10000, 100)})
  360:         labels = [f"{i} - {i + 499}" for i in range(0, 10000, 500)]
  361:         cat_labels = Categorical(labels, labels)
  362: 
  363:         df = df.sort_values(by=["value"], ascending=True)
  364:         df["value_group"] = pd.cut(
  365:             df.value, range(0, 10500, 500), right=False, labels=cat_labels
  366:         )
  367: 
  368:         # numeric ops should not succeed
  369:         for op, str_rep in [
  370:             ("__add__", r"\+"),
  371:             ("__sub__", "-"),
  372:             ("__mul__", r"\*"),
  373:             ("__truediv__", "/"),
  374:         ]:
  375:             msg = f"Series cannot perform the operation {str_rep}|unsupported operand"
  376:             with pytest.raises(TypeError, match=msg):
  377:                 getattr(df, op)(df)
  378: 
  379:         # reduction ops should not succeed (unless specifically defined, e.g.
  380:         # min/max)
  381:         s = df["value_group"]
  382:         for op in ["kurt", "skew", "var", "std", "mean", "sum", "median"]:
  383:             msg = f"does not support reduction '{op}'"
  384:             with pytest.raises(TypeError, match=msg):
  385:                 getattr(s, op)(numeric_only=False)
  386: 
  387:     def test_numeric_like_ops_series(self):
  388:         # numpy ops
  389:         s = Series(Categorical([1, 2, 3, 4]))
  390:         with pytest.raises(TypeError, match="does not support reduction 'sum'"):
  391:             np.sum(s)
  392: 
  393:     @pytest.mark.parametrize(
  394:         "op, str_rep",
  395:         [
  396:             ("__add__", r"\+"),
  397:             ("__sub__", "-"),
  398:             ("__mul__", r"\*"),
  399:             ("__truediv__", "/"),
  400:         ],
  401:     )
  402:     def test_numeric_like_ops_series_arith(self, op, str_rep):
  403:         # numeric ops on a Series
  404:         s = Series(Categorical([1, 2, 3, 4]))
  405:         msg = f"Series cannot perform the operation {str_rep}|unsupported operand"
  406:         with pytest.raises(TypeError, match=msg):
  407:             getattr(s, op)(2)
  408: 
  409:     def test_numeric_like_ops_series_invalid(self):
  410:         # invalid ufunc
  411:         s = Series(Categorical([1, 2, 3, 4]))
  412:         msg = "Object with dtype category cannot perform the numpy op log"
  413:         with pytest.raises(TypeError, match=msg):
  414:             np.log(s)
