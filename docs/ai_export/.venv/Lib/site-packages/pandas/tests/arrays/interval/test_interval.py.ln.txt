    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Index,
    7:     Interval,
    8:     IntervalIndex,
    9:     Timedelta,
   10:     Timestamp,
   11:     date_range,
   12:     timedelta_range,
   13: )
   14: import pandas._testing as tm
   15: from pandas.core.arrays import IntervalArray
   16: 
   17: 
   18: @pytest.fixture(
   19:     params=[
   20:         (Index([0, 2, 4]), Index([1, 3, 5])),
   21:         (Index([0.0, 1.0, 2.0]), Index([1.0, 2.0, 3.0])),
   22:         (timedelta_range("0 days", periods=3), timedelta_range("1 day", periods=3)),
   23:         (date_range("20170101", periods=3), date_range("20170102", periods=3)),
   24:         (
   25:             date_range("20170101", periods=3, tz="US/Eastern"),
   26:             date_range("20170102", periods=3, tz="US/Eastern"),
   27:         ),
   28:     ],
   29:     ids=lambda x: str(x[0].dtype),
   30: )
   31: def left_right_dtypes(request):
   32:     """
   33:     Fixture for building an IntervalArray from various dtypes
   34:     """
   35:     return request.param
   36: 
   37: 
   38: class TestAttributes:
   39:     @pytest.mark.parametrize(
   40:         "left, right",
   41:         [
   42:             (0, 1),
   43:             (Timedelta("0 days"), Timedelta("1 day")),
   44:             (Timestamp("2018-01-01"), Timestamp("2018-01-02")),
   45:             (
   46:                 Timestamp("2018-01-01", tz="US/Eastern"),
   47:                 Timestamp("2018-01-02", tz="US/Eastern"),
   48:             ),
   49:         ],
   50:     )
   51:     @pytest.mark.parametrize("constructor", [IntervalArray, IntervalIndex])
   52:     def test_is_empty(self, constructor, left, right, closed):
   53:         # GH27219
   54:         tuples = [(left, left), (left, right), np.nan]
   55:         expected = np.array([closed != "both", False, False])
   56:         result = constructor.from_tuples(tuples, closed=closed).is_empty
   57:         tm.assert_numpy_array_equal(result, expected)
   58: 
   59: 
   60: class TestMethods:
   61:     @pytest.mark.parametrize("new_closed", ["left", "right", "both", "neither"])
   62:     def test_set_closed(self, closed, new_closed):
   63:         # GH 21670
   64:         array = IntervalArray.from_breaks(range(10), closed=closed)
   65:         result = array.set_closed(new_closed)
   66:         expected = IntervalArray.from_breaks(range(10), closed=new_closed)
   67:         tm.assert_extension_array_equal(result, expected)
   68: 
   69:     @pytest.mark.parametrize(
   70:         "other",
   71:         [
   72:             Interval(0, 1, closed="right"),
   73:             IntervalArray.from_breaks([1, 2, 3, 4], closed="right"),
   74:         ],
   75:     )
   76:     def test_where_raises(self, other):
   77:         # GH#45768 The IntervalArray methods raises; the Series method coerces
   78:         ser = pd.Series(IntervalArray.from_breaks([1, 2, 3, 4], closed="left"))
   79:         mask = np.array([True, False, True])
   80:         match = "'value.closed' is 'right', expected 'left'."
   81:         with pytest.raises(ValueError, match=match):
   82:             ser.array._where(mask, other)
   83: 
   84:         res = ser.where(mask, other=other)
   85:         expected = ser.astype(object).where(mask, other)
   86:         tm.assert_series_equal(res, expected)
   87: 
   88:     def test_shift(self):
   89:         # https://github.com/pandas-dev/pandas/issues/31495, GH#22428, GH#31502
   90:         a = IntervalArray.from_breaks([1, 2, 3])
   91:         result = a.shift()
   92:         # int -> float
   93:         expected = IntervalArray.from_tuples([(np.nan, np.nan), (1.0, 2.0)])
   94:         tm.assert_interval_array_equal(result, expected)
   95: 
   96:         msg = "can only insert Interval objects and NA into an IntervalArray"
   97:         with pytest.raises(TypeError, match=msg):
   98:             a.shift(1, fill_value=pd.NaT)
   99: 
  100:     def test_shift_datetime(self):
  101:         # GH#31502, GH#31504
  102:         a = IntervalArray.from_breaks(date_range("2000", periods=4))
  103:         result = a.shift(2)
  104:         expected = a.take([-1, -1, 0], allow_fill=True)
  105:         tm.assert_interval_array_equal(result, expected)
  106: 
  107:         result = a.shift(-1)
  108:         expected = a.take([1, 2, -1], allow_fill=True)
  109:         tm.assert_interval_array_equal(result, expected)
  110: 
  111:         msg = "can only insert Interval objects and NA into an IntervalArray"
  112:         with pytest.raises(TypeError, match=msg):
  113:             a.shift(1, fill_value=np.timedelta64("NaT", "ns"))
  114: 
  115: 
  116: class TestSetitem:
  117:     def test_set_na(self, left_right_dtypes):
  118:         left, right = left_right_dtypes
  119:         left = left.copy(deep=True)
  120:         right = right.copy(deep=True)
  121:         result = IntervalArray.from_arrays(left, right)
  122: 
  123:         if result.dtype.subtype.kind not in ["m", "M"]:
  124:             msg = "'value' should be an interval type, got <.*NaTType'> instead."
  125:             with pytest.raises(TypeError, match=msg):
  126:                 result[0] = pd.NaT
  127:         if result.dtype.subtype.kind in ["i", "u"]:
  128:             msg = "Cannot set float NaN to integer-backed IntervalArray"
  129:             # GH#45484 TypeError, not ValueError, matches what we get with
  130:             # non-NA un-holdable value.
  131:             with pytest.raises(TypeError, match=msg):
  132:                 result[0] = np.nan
  133:             return
  134: 
  135:         result[0] = np.nan
  136: 
  137:         expected_left = Index([left._na_value] + list(left[1:]))
  138:         expected_right = Index([right._na_value] + list(right[1:]))
  139:         expected = IntervalArray.from_arrays(expected_left, expected_right)
  140: 
  141:         tm.assert_extension_array_equal(result, expected)
  142: 
  143:     def test_setitem_mismatched_closed(self):
  144:         arr = IntervalArray.from_breaks(range(4))
  145:         orig = arr.copy()
  146:         other = arr.set_closed("both")
  147: 
  148:         msg = "'value.closed' is 'both', expected 'right'"
  149:         with pytest.raises(ValueError, match=msg):
  150:             arr[0] = other[0]
  151:         with pytest.raises(ValueError, match=msg):
  152:             arr[:1] = other[:1]
  153:         with pytest.raises(ValueError, match=msg):
  154:             arr[:0] = other[:0]
  155:         with pytest.raises(ValueError, match=msg):
  156:             arr[:] = other[::-1]
  157:         with pytest.raises(ValueError, match=msg):
  158:             arr[:] = list(other[::-1])
  159:         with pytest.raises(ValueError, match=msg):
  160:             arr[:] = other[::-1].astype(object)
  161:         with pytest.raises(ValueError, match=msg):
  162:             arr[:] = other[::-1].astype("category")
  163: 
  164:         # empty list should be no-op
  165:         arr[:0] = []
  166:         tm.assert_interval_array_equal(arr, orig)
  167: 
  168: 
  169: class TestReductions:
  170:     def test_min_max_invalid_axis(self, left_right_dtypes):
  171:         left, right = left_right_dtypes
  172:         left = left.copy(deep=True)
  173:         right = right.copy(deep=True)
  174:         arr = IntervalArray.from_arrays(left, right)
  175: 
  176:         msg = "`axis` must be fewer than the number of dimensions"
  177:         for axis in [-2, 1]:
  178:             with pytest.raises(ValueError, match=msg):
  179:                 arr.min(axis=axis)
  180:             with pytest.raises(ValueError, match=msg):
  181:                 arr.max(axis=axis)
  182: 
  183:         msg = "'>=' not supported between"
  184:         with pytest.raises(TypeError, match=msg):
  185:             arr.min(axis="foo")
  186:         with pytest.raises(TypeError, match=msg):
  187:             arr.max(axis="foo")
  188: 
  189:     def test_min_max(self, left_right_dtypes, index_or_series_or_array):
  190:         # GH#44746
  191:         left, right = left_right_dtypes
  192:         left = left.copy(deep=True)
  193:         right = right.copy(deep=True)
  194:         arr = IntervalArray.from_arrays(left, right)
  195: 
  196:         # The expected results below are only valid if monotonic
  197:         assert left.is_monotonic_increasing
  198:         assert Index(arr).is_monotonic_increasing
  199: 
  200:         MIN = arr[0]
  201:         MAX = arr[-1]
  202: 
  203:         indexer = np.arange(len(arr))
  204:         np.random.default_rng(2).shuffle(indexer)
  205:         arr = arr.take(indexer)
  206: 
  207:         arr_na = arr.insert(2, np.nan)
  208: 
  209:         arr = index_or_series_or_array(arr)
  210:         arr_na = index_or_series_or_array(arr_na)
  211: 
  212:         for skipna in [True, False]:
  213:             res = arr.min(skipna=skipna)
  214:             assert res == MIN
  215:             assert type(res) == type(MIN)
  216: 
  217:             res = arr.max(skipna=skipna)
  218:             assert res == MAX
  219:             assert type(res) == type(MAX)
  220: 
  221:         res = arr_na.min(skipna=False)
  222:         assert np.isnan(res)
  223:         res = arr_na.max(skipna=False)
  224:         assert np.isnan(res)
  225: 
  226:         res = arr_na.min(skipna=True)
  227:         assert res == MIN
  228:         assert type(res) == type(MIN)
  229:         res = arr_na.max(skipna=True)
  230:         assert res == MAX
  231:         assert type(res) == type(MAX)
