    1: import operator
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: from pandas.core.arrays import FloatingArray
    9: 
   10: # Basic test for the arithmetic array ops
   11: # -----------------------------------------------------------------------------
   12: 
   13: 
   14: @pytest.mark.parametrize(
   15:     "opname, exp",
   16:     [
   17:         ("add", [1.1, 2.2, None, None, 5.5]),
   18:         ("mul", [0.1, 0.4, None, None, 2.5]),
   19:         ("sub", [0.9, 1.8, None, None, 4.5]),
   20:         ("truediv", [10.0, 10.0, None, None, 10.0]),
   21:         ("floordiv", [9.0, 9.0, None, None, 10.0]),
   22:         ("mod", [0.1, 0.2, None, None, 0.0]),
   23:     ],
   24:     ids=["add", "mul", "sub", "div", "floordiv", "mod"],
   25: )
   26: def test_array_op(dtype, opname, exp):
   27:     a = pd.array([1.0, 2.0, None, 4.0, 5.0], dtype=dtype)
   28:     b = pd.array([0.1, 0.2, 0.3, None, 0.5], dtype=dtype)
   29: 
   30:     op = getattr(operator, opname)
   31: 
   32:     result = op(a, b)
   33:     expected = pd.array(exp, dtype=dtype)
   34:     tm.assert_extension_array_equal(result, expected)
   35: 
   36: 
   37: @pytest.mark.parametrize("zero, negative", [(0, False), (0.0, False), (-0.0, True)])
   38: def test_divide_by_zero(dtype, zero, negative):
   39:     # TODO pending NA/NaN discussion
   40:     # https://github.com/pandas-dev/pandas/issues/32265/
   41:     a = pd.array([0, 1, -1, None], dtype=dtype)
   42:     result = a / zero
   43:     expected = FloatingArray(
   44:         np.array([np.nan, np.inf, -np.inf, np.nan], dtype=dtype.numpy_dtype),
   45:         np.array([False, False, False, True]),
   46:     )
   47:     if negative:
   48:         expected *= -1
   49:     tm.assert_extension_array_equal(result, expected)
   50: 
   51: 
   52: def test_pow_scalar(dtype):
   53:     a = pd.array([-1, 0, 1, None, 2], dtype=dtype)
   54:     result = a**0
   55:     expected = pd.array([1, 1, 1, 1, 1], dtype=dtype)
   56:     tm.assert_extension_array_equal(result, expected)
   57: 
   58:     result = a**1
   59:     expected = pd.array([-1, 0, 1, None, 2], dtype=dtype)
   60:     tm.assert_extension_array_equal(result, expected)
   61: 
   62:     result = a**pd.NA
   63:     expected = pd.array([None, None, 1, None, None], dtype=dtype)
   64:     tm.assert_extension_array_equal(result, expected)
   65: 
   66:     result = a**np.nan
   67:     # TODO np.nan should be converted to pd.NA / missing before operation?
   68:     expected = FloatingArray(
   69:         np.array([np.nan, np.nan, 1, np.nan, np.nan], dtype=dtype.numpy_dtype),
   70:         mask=a._mask,
   71:     )
   72:     tm.assert_extension_array_equal(result, expected)
   73: 
   74:     # reversed
   75:     a = a[1:]  # Can't raise integers to negative powers.
   76: 
   77:     result = 0**a
   78:     expected = pd.array([1, 0, None, 0], dtype=dtype)
   79:     tm.assert_extension_array_equal(result, expected)
   80: 
   81:     result = 1**a
   82:     expected = pd.array([1, 1, 1, 1], dtype=dtype)
   83:     tm.assert_extension_array_equal(result, expected)
   84: 
   85:     result = pd.NA**a
   86:     expected = pd.array([1, None, None, None], dtype=dtype)
   87:     tm.assert_extension_array_equal(result, expected)
   88: 
   89:     result = np.nan**a
   90:     expected = FloatingArray(
   91:         np.array([1, np.nan, np.nan, np.nan], dtype=dtype.numpy_dtype), mask=a._mask
   92:     )
   93:     tm.assert_extension_array_equal(result, expected)
   94: 
   95: 
   96: def test_pow_array(dtype):
   97:     a = pd.array([0, 0, 0, 1, 1, 1, None, None, None], dtype=dtype)
   98:     b = pd.array([0, 1, None, 0, 1, None, 0, 1, None], dtype=dtype)
   99:     result = a**b
  100:     expected = pd.array([1, 0, None, 1, 1, 1, 1, None, None], dtype=dtype)
  101:     tm.assert_extension_array_equal(result, expected)
  102: 
  103: 
  104: def test_rpow_one_to_na():
  105:     # https://github.com/pandas-dev/pandas/issues/22022
  106:     # https://github.com/pandas-dev/pandas/issues/29997
  107:     arr = pd.array([np.nan, np.nan], dtype="Float64")
  108:     result = np.array([1.0, 2.0]) ** arr
  109:     expected = pd.array([1.0, np.nan], dtype="Float64")
  110:     tm.assert_extension_array_equal(result, expected)
  111: 
  112: 
  113: @pytest.mark.parametrize("other", [0, 0.5])
  114: def test_arith_zero_dim_ndarray(other):
  115:     arr = pd.array([1, None, 2], dtype="Float64")
  116:     result = arr + np.array(other)
  117:     expected = arr + other
  118:     tm.assert_equal(result, expected)
  119: 
  120: 
  121: # Test generic characteristics / errors
  122: # -----------------------------------------------------------------------------
  123: 
  124: 
  125: def test_error_invalid_values(data, all_arithmetic_operators, using_infer_string):
  126:     op = all_arithmetic_operators
  127:     s = pd.Series(data)
  128:     ops = getattr(s, op)
  129: 
  130:     if using_infer_string:
  131:         import pyarrow as pa
  132: 
  133:         errs = (TypeError, pa.lib.ArrowNotImplementedError, NotImplementedError)
  134:     else:
  135:         errs = TypeError
  136: 
  137:     # invalid scalars
  138:     msg = "|".join(
  139:         [
  140:             r"can only perform ops with numeric values",
  141:             r"FloatingArray cannot perform the operation mod",
  142:             "unsupported operand type",
  143:             "not all arguments converted during string formatting",
  144:             "can't multiply sequence by non-int of type 'float'",
  145:             "ufunc 'subtract' cannot use operands with types dtype",
  146:             r"can only concatenate str \(not \"float\"\) to str",
  147:             "ufunc '.*' not supported for the input types, and the inputs could not",
  148:             "ufunc '.*' did not contain a loop with signature matching types",
  149:             "Concatenation operation is not implemented for NumPy arrays",
  150:             "has no kernel",
  151:             "not implemented",
  152:         ]
  153:     )
  154:     with pytest.raises(errs, match=msg):
  155:         ops("foo")
  156:     with pytest.raises(errs, match=msg):
  157:         ops(pd.Timestamp("20180101"))
  158: 
  159:     # invalid array-likes
  160:     with pytest.raises(errs, match=msg):
  161:         ops(pd.Series("foo", index=s.index))
  162: 
  163:     msg = "|".join(
  164:         [
  165:             "can only perform ops with numeric values",
  166:             "cannot perform .* with this index type: DatetimeArray",
  167:             "Addition/subtraction of integers and integer-arrays "
  168:             "with DatetimeArray is no longer supported. *",
  169:             "unsupported operand type",
  170:             "not all arguments converted during string formatting",
  171:             "can't multiply sequence by non-int of type 'float'",
  172:             "ufunc 'subtract' cannot use operands with types dtype",
  173:             (
  174:                 "ufunc 'add' cannot use operands with types "
  175:                 rf"dtype\('{tm.ENDIAN}M8\[ns\]'\)"
  176:             ),
  177:             r"ufunc 'add' cannot use operands with types dtype\('float\d{2}'\)",
  178:             "cannot subtract DatetimeArray from ndarray",
  179:             "has no kernel",
  180:             "not implemented",
  181:         ]
  182:     )
  183:     with pytest.raises(errs, match=msg):
  184:         ops(pd.Series(pd.date_range("20180101", periods=len(s))))
  185: 
  186: 
  187: # Various
  188: # -----------------------------------------------------------------------------
  189: 
  190: 
  191: def test_cross_type_arithmetic():
  192:     df = pd.DataFrame(
  193:         {
  194:             "A": pd.array([1, 2, np.nan], dtype="Float64"),
  195:             "B": pd.array([1, np.nan, 3], dtype="Float32"),
  196:             "C": np.array([1, 2, 3], dtype="float64"),
  197:         }
  198:     )
  199: 
  200:     result = df.A + df.C
  201:     expected = pd.Series([2, 4, np.nan], dtype="Float64")
  202:     tm.assert_series_equal(result, expected)
  203: 
  204:     result = (df.A + df.C) * 3 == 12
  205:     expected = pd.Series([False, True, None], dtype="boolean")
  206:     tm.assert_series_equal(result, expected)
  207: 
  208:     result = df.A + df.B
  209:     expected = pd.Series([2, np.nan, np.nan], dtype="Float64")
  210:     tm.assert_series_equal(result, expected)
  211: 
  212: 
  213: @pytest.mark.parametrize(
  214:     "source, neg_target, abs_target",
  215:     [
  216:         ([1.1, 2.2, 3.3], [-1.1, -2.2, -3.3], [1.1, 2.2, 3.3]),
  217:         ([1.1, 2.2, None], [-1.1, -2.2, None], [1.1, 2.2, None]),
  218:         ([-1.1, 0.0, 1.1], [1.1, 0.0, -1.1], [1.1, 0.0, 1.1]),
  219:     ],
  220: )
  221: def test_unary_float_operators(float_ea_dtype, source, neg_target, abs_target):
  222:     # GH38794
  223:     dtype = float_ea_dtype
  224:     arr = pd.array(source, dtype=dtype)
  225:     neg_result, pos_result, abs_result = -arr, +arr, abs(arr)
  226:     neg_target = pd.array(neg_target, dtype=dtype)
  227:     abs_target = pd.array(abs_target, dtype=dtype)
  228: 
  229:     tm.assert_extension_array_equal(neg_result, neg_target)
  230:     tm.assert_extension_array_equal(pos_result, arr)
  231:     assert not tm.shares_memory(pos_result, arr)
  232:     tm.assert_extension_array_equal(abs_result, abs_target)
  233: 
  234: 
  235: def test_bitwise(dtype):
  236:     left = pd.array([1, None, 3, 4], dtype=dtype)
  237:     right = pd.array([None, 3, 5, 4], dtype=dtype)
  238: 
  239:     with pytest.raises(TypeError, match="unsupported operand type"):
  240:         left | right
  241:     with pytest.raises(TypeError, match="unsupported operand type"):
  242:         left & right
  243:     with pytest.raises(TypeError, match="unsupported operand type"):
  244:         left ^ right
