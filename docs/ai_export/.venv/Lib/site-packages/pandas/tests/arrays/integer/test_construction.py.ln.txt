    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: import pandas._testing as tm
    6: from pandas.api.types import is_integer
    7: from pandas.core.arrays import IntegerArray
    8: from pandas.core.arrays.integer import (
    9:     Int8Dtype,
   10:     Int32Dtype,
   11:     Int64Dtype,
   12: )
   13: 
   14: 
   15: @pytest.fixture(params=[pd.array, IntegerArray._from_sequence])
   16: def constructor(request):
   17:     """Fixture returning parametrized IntegerArray from given sequence.
   18: 
   19:     Used to test dtype conversions.
   20:     """
   21:     return request.param
   22: 
   23: 
   24: def test_uses_pandas_na():
   25:     a = pd.array([1, None], dtype=Int64Dtype())
   26:     assert a[1] is pd.NA
   27: 
   28: 
   29: def test_from_dtype_from_float(data):
   30:     # construct from our dtype & string dtype
   31:     dtype = data.dtype
   32: 
   33:     # from float
   34:     expected = pd.Series(data)
   35:     result = pd.Series(data.to_numpy(na_value=np.nan, dtype="float"), dtype=str(dtype))
   36:     tm.assert_series_equal(result, expected)
   37: 
   38:     # from int / list
   39:     expected = pd.Series(data)
   40:     result = pd.Series(np.array(data).tolist(), dtype=str(dtype))
   41:     tm.assert_series_equal(result, expected)
   42: 
   43:     # from int / array
   44:     expected = pd.Series(data).dropna().reset_index(drop=True)
   45:     dropped = np.array(data.dropna()).astype(np.dtype(dtype.type))
   46:     result = pd.Series(dropped, dtype=str(dtype))
   47:     tm.assert_series_equal(result, expected)
   48: 
   49: 
   50: def test_conversions(data_missing):
   51:     # astype to object series
   52:     df = pd.DataFrame({"A": data_missing})
   53:     result = df["A"].astype("object")
   54:     expected = pd.Series(np.array([pd.NA, 1], dtype=object), name="A")
   55:     tm.assert_series_equal(result, expected)
   56: 
   57:     # convert to object ndarray
   58:     # we assert that we are exactly equal
   59:     # including type conversions of scalars
   60:     result = df["A"].astype("object").values
   61:     expected = np.array([pd.NA, 1], dtype=object)
   62:     tm.assert_numpy_array_equal(result, expected)
   63: 
   64:     for r, e in zip(result, expected):
   65:         if pd.isnull(r):
   66:             assert pd.isnull(e)
   67:         elif is_integer(r):
   68:             assert r == e
   69:             assert is_integer(e)
   70:         else:
   71:             assert r == e
   72:             assert type(r) == type(e)
   73: 
   74: 
   75: def test_integer_array_constructor():
   76:     values = np.array([1, 2, 3, 4], dtype="int64")
   77:     mask = np.array([False, False, False, True], dtype="bool")
   78: 
   79:     result = IntegerArray(values, mask)
   80:     expected = pd.array([1, 2, 3, np.nan], dtype="Int64")
   81:     tm.assert_extension_array_equal(result, expected)
   82: 
   83:     msg = r".* should be .* numpy array. Use the 'pd.array' function instead"
   84:     with pytest.raises(TypeError, match=msg):
   85:         IntegerArray(values.tolist(), mask)
   86: 
   87:     with pytest.raises(TypeError, match=msg):
   88:         IntegerArray(values, mask.tolist())
   89: 
   90:     with pytest.raises(TypeError, match=msg):
   91:         IntegerArray(values.astype(float), mask)
   92:     msg = r"__init__\(\) missing 1 required positional argument: 'mask'"
   93:     with pytest.raises(TypeError, match=msg):
   94:         IntegerArray(values)
   95: 
   96: 
   97: def test_integer_array_constructor_copy():
   98:     values = np.array([1, 2, 3, 4], dtype="int64")
   99:     mask = np.array([False, False, False, True], dtype="bool")
  100: 
  101:     result = IntegerArray(values, mask)
  102:     assert result._data is values
  103:     assert result._mask is mask
  104: 
  105:     result = IntegerArray(values, mask, copy=True)
  106:     assert result._data is not values
  107:     assert result._mask is not mask
  108: 
  109: 
  110: @pytest.mark.parametrize(
  111:     "a, b",
  112:     [
  113:         ([1, None], [1, np.nan]),
  114:         ([None], [np.nan]),
  115:         ([None, np.nan], [np.nan, np.nan]),
  116:         ([np.nan, np.nan], [np.nan, np.nan]),
  117:     ],
  118: )
  119: def test_to_integer_array_none_is_nan(a, b):
  120:     result = pd.array(a, dtype="Int64")
  121:     expected = pd.array(b, dtype="Int64")
  122:     tm.assert_extension_array_equal(result, expected)
  123: 
  124: 
  125: @pytest.mark.parametrize(
  126:     "values",
  127:     [
  128:         ["foo", "bar"],
  129:         "foo",
  130:         1,
  131:         1.0,
  132:         pd.date_range("20130101", periods=2),
  133:         np.array(["foo"]),
  134:         [[1, 2], [3, 4]],
  135:         [np.nan, {"a": 1}],
  136:     ],
  137: )
  138: def test_to_integer_array_error(values):
  139:     # error in converting existing arrays to IntegerArrays
  140:     msg = "|".join(
  141:         [
  142:             r"cannot be converted to IntegerDtype",
  143:             r"invalid literal for int\(\) with base 10:",
  144:             r"values must be a 1D list-like",
  145:             r"Cannot pass scalar",
  146:             r"int\(\) argument must be a string",
  147:         ]
  148:     )
  149:     with pytest.raises((ValueError, TypeError), match=msg):
  150:         pd.array(values, dtype="Int64")
  151: 
  152:     with pytest.raises((ValueError, TypeError), match=msg):
  153:         IntegerArray._from_sequence(values)
  154: 
  155: 
  156: def test_to_integer_array_inferred_dtype(constructor):
  157:     # if values has dtype -> respect it
  158:     result = constructor(np.array([1, 2], dtype="int8"))
  159:     assert result.dtype == Int8Dtype()
  160:     result = constructor(np.array([1, 2], dtype="int32"))
  161:     assert result.dtype == Int32Dtype()
  162: 
  163:     # if values have no dtype -> always int64
  164:     result = constructor([1, 2])
  165:     assert result.dtype == Int64Dtype()
  166: 
  167: 
  168: def test_to_integer_array_dtype_keyword(constructor):
  169:     result = constructor([1, 2], dtype="Int8")
  170:     assert result.dtype == Int8Dtype()
  171: 
  172:     # if values has dtype -> override it
  173:     result = constructor(np.array([1, 2], dtype="int8"), dtype="Int32")
  174:     assert result.dtype == Int32Dtype()
  175: 
  176: 
  177: def test_to_integer_array_float():
  178:     result = IntegerArray._from_sequence([1.0, 2.0], dtype="Int64")
  179:     expected = pd.array([1, 2], dtype="Int64")
  180:     tm.assert_extension_array_equal(result, expected)
  181: 
  182:     with pytest.raises(TypeError, match="cannot safely cast non-equivalent"):
  183:         IntegerArray._from_sequence([1.5, 2.0], dtype="Int64")
  184: 
  185:     # for float dtypes, the itemsize is not preserved
  186:     result = IntegerArray._from_sequence(
  187:         np.array([1.0, 2.0], dtype="float32"), dtype="Int64"
  188:     )
  189:     assert result.dtype == Int64Dtype()
  190: 
  191: 
  192: def test_to_integer_array_str():
  193:     result = IntegerArray._from_sequence(["1", "2", None], dtype="Int64")
  194:     expected = pd.array([1, 2, np.nan], dtype="Int64")
  195:     tm.assert_extension_array_equal(result, expected)
  196: 
  197:     with pytest.raises(
  198:         ValueError, match=r"invalid literal for int\(\) with base 10: .*"
  199:     ):
  200:         IntegerArray._from_sequence(["1", "2", ""], dtype="Int64")
  201: 
  202:     with pytest.raises(
  203:         ValueError, match=r"invalid literal for int\(\) with base 10: .*"
  204:     ):
  205:         IntegerArray._from_sequence(["1.5", "2.0"], dtype="Int64")
  206: 
  207: 
  208: @pytest.mark.parametrize(
  209:     "bool_values, int_values, target_dtype, expected_dtype",
  210:     [
  211:         ([False, True], [0, 1], Int64Dtype(), Int64Dtype()),
  212:         ([False, True], [0, 1], "Int64", Int64Dtype()),
  213:         ([False, True, np.nan], [0, 1, np.nan], Int64Dtype(), Int64Dtype()),
  214:     ],
  215: )
  216: def test_to_integer_array_bool(
  217:     constructor, bool_values, int_values, target_dtype, expected_dtype
  218: ):
  219:     result = constructor(bool_values, dtype=target_dtype)
  220:     assert result.dtype == expected_dtype
  221:     expected = pd.array(int_values, dtype=target_dtype)
  222:     tm.assert_extension_array_equal(result, expected)
  223: 
  224: 
  225: @pytest.mark.parametrize(
  226:     "values, to_dtype, result_dtype",
  227:     [
  228:         (np.array([1], dtype="int64"), None, Int64Dtype),
  229:         (np.array([1, np.nan]), None, Int64Dtype),
  230:         (np.array([1, np.nan]), "int8", Int8Dtype),
  231:     ],
  232: )
  233: def test_to_integer_array(values, to_dtype, result_dtype):
  234:     # convert existing arrays to IntegerArrays
  235:     result = IntegerArray._from_sequence(values, dtype=to_dtype)
  236:     assert result.dtype == result_dtype()
  237:     expected = pd.array(values, dtype=result_dtype())
  238:     tm.assert_extension_array_equal(result, expected)
  239: 
  240: 
  241: def test_integer_array_from_boolean():
  242:     # GH31104
  243:     expected = pd.array(np.array([True, False]), dtype="Int64")
  244:     result = pd.array(np.array([True, False], dtype=object), dtype="Int64")
  245:     tm.assert_extension_array_equal(result, expected)
