    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: import pandas._testing as tm
    6: from pandas.core.arrays import FloatingArray
    7: 
    8: 
    9: @pytest.mark.parametrize("ufunc", [np.abs, np.sign])
   10: # np.sign emits a warning with nans, <https://github.com/numpy/numpy/issues/15127>
   11: @pytest.mark.filterwarnings("ignore:invalid value encountered in sign:RuntimeWarning")
   12: def test_ufuncs_single_int(ufunc):
   13:     a = pd.array([1, 2, -3, np.nan])
   14:     result = ufunc(a)
   15:     expected = pd.array(ufunc(a.astype(float)), dtype="Int64")
   16:     tm.assert_extension_array_equal(result, expected)
   17: 
   18:     s = pd.Series(a)
   19:     result = ufunc(s)
   20:     expected = pd.Series(pd.array(ufunc(a.astype(float)), dtype="Int64"))
   21:     tm.assert_series_equal(result, expected)
   22: 
   23: 
   24: @pytest.mark.parametrize("ufunc", [np.log, np.exp, np.sin, np.cos, np.sqrt])
   25: def test_ufuncs_single_float(ufunc):
   26:     a = pd.array([1, 2, -3, np.nan])
   27:     with np.errstate(invalid="ignore"):
   28:         result = ufunc(a)
   29:         expected = FloatingArray(ufunc(a.astype(float)), mask=a._mask)
   30:     tm.assert_extension_array_equal(result, expected)
   31: 
   32:     s = pd.Series(a)
   33:     with np.errstate(invalid="ignore"):
   34:         result = ufunc(s)
   35:     expected = pd.Series(expected)
   36:     tm.assert_series_equal(result, expected)
   37: 
   38: 
   39: @pytest.mark.parametrize("ufunc", [np.add, np.subtract])
   40: def test_ufuncs_binary_int(ufunc):
   41:     # two IntegerArrays
   42:     a = pd.array([1, 2, -3, np.nan])
   43:     result = ufunc(a, a)
   44:     expected = pd.array(ufunc(a.astype(float), a.astype(float)), dtype="Int64")
   45:     tm.assert_extension_array_equal(result, expected)
   46: 
   47:     # IntegerArray with numpy array
   48:     arr = np.array([1, 2, 3, 4])
   49:     result = ufunc(a, arr)
   50:     expected = pd.array(ufunc(a.astype(float), arr), dtype="Int64")
   51:     tm.assert_extension_array_equal(result, expected)
   52: 
   53:     result = ufunc(arr, a)
   54:     expected = pd.array(ufunc(arr, a.astype(float)), dtype="Int64")
   55:     tm.assert_extension_array_equal(result, expected)
   56: 
   57:     # IntegerArray with scalar
   58:     result = ufunc(a, 1)
   59:     expected = pd.array(ufunc(a.astype(float), 1), dtype="Int64")
   60:     tm.assert_extension_array_equal(result, expected)
   61: 
   62:     result = ufunc(1, a)
   63:     expected = pd.array(ufunc(1, a.astype(float)), dtype="Int64")
   64:     tm.assert_extension_array_equal(result, expected)
   65: 
   66: 
   67: def test_ufunc_binary_output():
   68:     a = pd.array([1, 2, np.nan])
   69:     result = np.modf(a)
   70:     expected = np.modf(a.to_numpy(na_value=np.nan, dtype="float"))
   71:     expected = (pd.array(expected[0]), pd.array(expected[1]))
   72: 
   73:     assert isinstance(result, tuple)
   74:     assert len(result) == 2
   75: 
   76:     for x, y in zip(result, expected):
   77:         tm.assert_extension_array_equal(x, y)
   78: 
   79: 
   80: @pytest.mark.parametrize("values", [[0, 1], [0, None]])
   81: def test_ufunc_reduce_raises(values):
   82:     arr = pd.array(values)
   83: 
   84:     res = np.add.reduce(arr)
   85:     expected = arr.sum(skipna=False)
   86:     tm.assert_almost_equal(res, expected)
   87: 
   88: 
   89: @pytest.mark.parametrize(
   90:     "pandasmethname, kwargs",
   91:     [
   92:         ("var", {"ddof": 0}),
   93:         ("var", {"ddof": 1}),
   94:         ("std", {"ddof": 0}),
   95:         ("std", {"ddof": 1}),
   96:         ("kurtosis", {}),
   97:         ("skew", {}),
   98:         ("sem", {}),
   99:     ],
  100: )
  101: def test_stat_method(pandasmethname, kwargs):
  102:     s = pd.Series(data=[1, 2, 3, 4, 5, 6, np.nan, np.nan], dtype="Int64")
  103:     pandasmeth = getattr(s, pandasmethname)
  104:     result = pandasmeth(**kwargs)
  105:     s2 = pd.Series(data=[1, 2, 3, 4, 5, 6], dtype="Int64")
  106:     pandasmeth = getattr(s2, pandasmethname)
  107:     expected = pandasmeth(**kwargs)
  108:     assert expected == result
  109: 
  110: 
  111: def test_value_counts_na():
  112:     arr = pd.array([1, 2, 1, pd.NA], dtype="Int64")
  113:     result = arr.value_counts(dropna=False)
  114:     ex_index = pd.Index([1, 2, pd.NA], dtype="Int64")
  115:     assert ex_index.dtype == "Int64"
  116:     expected = pd.Series([2, 1, 1], index=ex_index, dtype="Int64", name="count")
  117:     tm.assert_series_equal(result, expected)
  118: 
  119:     result = arr.value_counts(dropna=True)
  120:     expected = pd.Series([2, 1], index=arr[:2], dtype="Int64", name="count")
  121:     assert expected.index.dtype == arr.dtype
  122:     tm.assert_series_equal(result, expected)
  123: 
  124: 
  125: def test_value_counts_empty():
  126:     # https://github.com/pandas-dev/pandas/issues/33317
  127:     ser = pd.Series([], dtype="Int64")
  128:     result = ser.value_counts()
  129:     idx = pd.Index([], dtype=ser.dtype)
  130:     assert idx.dtype == ser.dtype
  131:     expected = pd.Series([], index=idx, dtype="Int64", name="count")
  132:     tm.assert_series_equal(result, expected)
  133: 
  134: 
  135: def test_value_counts_with_normalize():
  136:     # GH 33172
  137:     ser = pd.Series([1, 2, 1, pd.NA], dtype="Int64")
  138:     result = ser.value_counts(normalize=True)
  139:     expected = pd.Series([2, 1], index=ser[:2], dtype="Float64", name="proportion") / 3
  140:     assert expected.index.dtype == ser.dtype
  141:     tm.assert_series_equal(result, expected)
  142: 
  143: 
  144: @pytest.mark.parametrize("skipna", [True, False])
  145: @pytest.mark.parametrize("min_count", [0, 4])
  146: def test_integer_array_sum(skipna, min_count, any_int_ea_dtype):
  147:     dtype = any_int_ea_dtype
  148:     arr = pd.array([1, 2, 3, None], dtype=dtype)
  149:     result = arr.sum(skipna=skipna, min_count=min_count)
  150:     if skipna and min_count == 0:
  151:         assert result == 6
  152:     else:
  153:         assert result is pd.NA
  154: 
  155: 
  156: @pytest.mark.parametrize("skipna", [True, False])
  157: @pytest.mark.parametrize("method", ["min", "max"])
  158: def test_integer_array_min_max(skipna, method, any_int_ea_dtype):
  159:     dtype = any_int_ea_dtype
  160:     arr = pd.array([0, 1, None], dtype=dtype)
  161:     func = getattr(arr, method)
  162:     result = func(skipna=skipna)
  163:     if skipna:
  164:         assert result == (0 if method == "min" else 1)
  165:     else:
  166:         assert result is pd.NA
  167: 
  168: 
  169: @pytest.mark.parametrize("skipna", [True, False])
  170: @pytest.mark.parametrize("min_count", [0, 9])
  171: def test_integer_array_prod(skipna, min_count, any_int_ea_dtype):
  172:     dtype = any_int_ea_dtype
  173:     arr = pd.array([1, 2, None], dtype=dtype)
  174:     result = arr.prod(skipna=skipna, min_count=min_count)
  175:     if skipna and min_count == 0:
  176:         assert result == 2
  177:     else:
  178:         assert result is pd.NA
  179: 
  180: 
  181: @pytest.mark.parametrize(
  182:     "values, expected", [([1, 2, 3], 6), ([1, 2, 3, None], 6), ([None], 0)]
  183: )
  184: def test_integer_array_numpy_sum(values, expected):
  185:     arr = pd.array(values, dtype="Int64")
  186:     result = np.sum(arr)
  187:     assert result == expected
  188: 
  189: 
  190: @pytest.mark.parametrize("op", ["sum", "prod", "min", "max"])
  191: def test_dataframe_reductions(op):
  192:     # https://github.com/pandas-dev/pandas/pull/32867
  193:     # ensure the integers are not cast to float during reductions
  194:     df = pd.DataFrame({"a": pd.array([1, 2], dtype="Int64")})
  195:     result = df.max()
  196:     assert isinstance(result["a"], np.int64)
  197: 
  198: 
  199: # TODO(jreback) - these need testing / are broken
  200: 
  201: # shift
  202: 
  203: # set_index (destroys type)
