    1: import operator
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: from pandas.arrays import BooleanArray
    9: from pandas.core.ops.mask_ops import (
   10:     kleene_and,
   11:     kleene_or,
   12:     kleene_xor,
   13: )
   14: from pandas.tests.extension.base import BaseOpsUtil
   15: 
   16: 
   17: class TestLogicalOps(BaseOpsUtil):
   18:     def test_numpy_scalars_ok(self, all_logical_operators):
   19:         a = pd.array([True, False, None], dtype="boolean")
   20:         op = getattr(a, all_logical_operators)
   21: 
   22:         tm.assert_extension_array_equal(op(True), op(np.bool_(True)))
   23:         tm.assert_extension_array_equal(op(False), op(np.bool_(False)))
   24: 
   25:     def get_op_from_name(self, op_name):
   26:         short_opname = op_name.strip("_")
   27:         short_opname = short_opname if "xor" in short_opname else short_opname + "_"
   28:         try:
   29:             op = getattr(operator, short_opname)
   30:         except AttributeError:
   31:             # Assume it is the reverse operator
   32:             rop = getattr(operator, short_opname[1:])
   33:             op = lambda x, y: rop(y, x)
   34: 
   35:         return op
   36: 
   37:     def test_empty_ok(self, all_logical_operators):
   38:         a = pd.array([], dtype="boolean")
   39:         op_name = all_logical_operators
   40:         result = getattr(a, op_name)(True)
   41:         tm.assert_extension_array_equal(a, result)
   42: 
   43:         result = getattr(a, op_name)(False)
   44:         tm.assert_extension_array_equal(a, result)
   45: 
   46:         result = getattr(a, op_name)(pd.NA)
   47:         tm.assert_extension_array_equal(a, result)
   48: 
   49:     @pytest.mark.parametrize(
   50:         "other", ["a", pd.Timestamp(2017, 1, 1, 12), np.timedelta64(4)]
   51:     )
   52:     def test_eq_mismatched_type(self, other):
   53:         # GH-44499
   54:         arr = pd.array([True, False])
   55:         result = arr == other
   56:         expected = pd.array([False, False])
   57:         tm.assert_extension_array_equal(result, expected)
   58: 
   59:         result = arr != other
   60:         expected = pd.array([True, True])
   61:         tm.assert_extension_array_equal(result, expected)
   62: 
   63:     def test_logical_length_mismatch_raises(self, all_logical_operators):
   64:         op_name = all_logical_operators
   65:         a = pd.array([True, False, None], dtype="boolean")
   66:         msg = "Lengths must match"
   67: 
   68:         with pytest.raises(ValueError, match=msg):
   69:             getattr(a, op_name)([True, False])
   70: 
   71:         with pytest.raises(ValueError, match=msg):
   72:             getattr(a, op_name)(np.array([True, False]))
   73: 
   74:         with pytest.raises(ValueError, match=msg):
   75:             getattr(a, op_name)(pd.array([True, False], dtype="boolean"))
   76: 
   77:     def test_logical_nan_raises(self, all_logical_operators):
   78:         op_name = all_logical_operators
   79:         a = pd.array([True, False, None], dtype="boolean")
   80:         msg = "Got float instead"
   81: 
   82:         with pytest.raises(TypeError, match=msg):
   83:             getattr(a, op_name)(np.nan)
   84: 
   85:     @pytest.mark.parametrize("other", ["a", 1])
   86:     def test_non_bool_or_na_other_raises(self, other, all_logical_operators):
   87:         a = pd.array([True, False], dtype="boolean")
   88:         with pytest.raises(TypeError, match=str(type(other).__name__)):
   89:             getattr(a, all_logical_operators)(other)
   90: 
   91:     def test_kleene_or(self):
   92:         # A clear test of behavior.
   93:         a = pd.array([True] * 3 + [False] * 3 + [None] * 3, dtype="boolean")
   94:         b = pd.array([True, False, None] * 3, dtype="boolean")
   95:         result = a | b
   96:         expected = pd.array(
   97:             [True, True, True, True, False, None, True, None, None], dtype="boolean"
   98:         )
   99:         tm.assert_extension_array_equal(result, expected)
  100: 
  101:         result = b | a
  102:         tm.assert_extension_array_equal(result, expected)
  103: 
  104:         # ensure we haven't mutated anything inplace
  105:         tm.assert_extension_array_equal(
  106:             a, pd.array([True] * 3 + [False] * 3 + [None] * 3, dtype="boolean")
  107:         )
  108:         tm.assert_extension_array_equal(
  109:             b, pd.array([True, False, None] * 3, dtype="boolean")
  110:         )
  111: 
  112:     @pytest.mark.parametrize(
  113:         "other, expected",
  114:         [
  115:             (pd.NA, [True, None, None]),
  116:             (True, [True, True, True]),
  117:             (np.bool_(True), [True, True, True]),
  118:             (False, [True, False, None]),
  119:             (np.bool_(False), [True, False, None]),
  120:         ],
  121:     )
  122:     def test_kleene_or_scalar(self, other, expected):
  123:         # TODO: test True & False
  124:         a = pd.array([True, False, None], dtype="boolean")
  125:         result = a | other
  126:         expected = pd.array(expected, dtype="boolean")
  127:         tm.assert_extension_array_equal(result, expected)
  128: 
  129:         result = other | a
  130:         tm.assert_extension_array_equal(result, expected)
  131: 
  132:         # ensure we haven't mutated anything inplace
  133:         tm.assert_extension_array_equal(
  134:             a, pd.array([True, False, None], dtype="boolean")
  135:         )
  136: 
  137:     def test_kleene_and(self):
  138:         # A clear test of behavior.
  139:         a = pd.array([True] * 3 + [False] * 3 + [None] * 3, dtype="boolean")
  140:         b = pd.array([True, False, None] * 3, dtype="boolean")
  141:         result = a & b
  142:         expected = pd.array(
  143:             [True, False, None, False, False, False, None, False, None], dtype="boolean"
  144:         )
  145:         tm.assert_extension_array_equal(result, expected)
  146: 
  147:         result = b & a
  148:         tm.assert_extension_array_equal(result, expected)
  149: 
  150:         # ensure we haven't mutated anything inplace
  151:         tm.assert_extension_array_equal(
  152:             a, pd.array([True] * 3 + [False] * 3 + [None] * 3, dtype="boolean")
  153:         )
  154:         tm.assert_extension_array_equal(
  155:             b, pd.array([True, False, None] * 3, dtype="boolean")
  156:         )
  157: 
  158:     @pytest.mark.parametrize(
  159:         "other, expected",
  160:         [
  161:             (pd.NA, [None, False, None]),
  162:             (True, [True, False, None]),
  163:             (False, [False, False, False]),
  164:             (np.bool_(True), [True, False, None]),
  165:             (np.bool_(False), [False, False, False]),
  166:         ],
  167:     )
  168:     def test_kleene_and_scalar(self, other, expected):
  169:         a = pd.array([True, False, None], dtype="boolean")
  170:         result = a & other
  171:         expected = pd.array(expected, dtype="boolean")
  172:         tm.assert_extension_array_equal(result, expected)
  173: 
  174:         result = other & a
  175:         tm.assert_extension_array_equal(result, expected)
  176: 
  177:         # ensure we haven't mutated anything inplace
  178:         tm.assert_extension_array_equal(
  179:             a, pd.array([True, False, None], dtype="boolean")
  180:         )
  181: 
  182:     def test_kleene_xor(self):
  183:         a = pd.array([True] * 3 + [False] * 3 + [None] * 3, dtype="boolean")
  184:         b = pd.array([True, False, None] * 3, dtype="boolean")
  185:         result = a ^ b
  186:         expected = pd.array(
  187:             [False, True, None, True, False, None, None, None, None], dtype="boolean"
  188:         )
  189:         tm.assert_extension_array_equal(result, expected)
  190: 
  191:         result = b ^ a
  192:         tm.assert_extension_array_equal(result, expected)
  193: 
  194:         # ensure we haven't mutated anything inplace
  195:         tm.assert_extension_array_equal(
  196:             a, pd.array([True] * 3 + [False] * 3 + [None] * 3, dtype="boolean")
  197:         )
  198:         tm.assert_extension_array_equal(
  199:             b, pd.array([True, False, None] * 3, dtype="boolean")
  200:         )
  201: 
  202:     @pytest.mark.parametrize(
  203:         "other, expected",
  204:         [
  205:             (pd.NA, [None, None, None]),
  206:             (True, [False, True, None]),
  207:             (np.bool_(True), [False, True, None]),
  208:             (np.bool_(False), [True, False, None]),
  209:         ],
  210:     )
  211:     def test_kleene_xor_scalar(self, other, expected):
  212:         a = pd.array([True, False, None], dtype="boolean")
  213:         result = a ^ other
  214:         expected = pd.array(expected, dtype="boolean")
  215:         tm.assert_extension_array_equal(result, expected)
  216: 
  217:         result = other ^ a
  218:         tm.assert_extension_array_equal(result, expected)
  219: 
  220:         # ensure we haven't mutated anything inplace
  221:         tm.assert_extension_array_equal(
  222:             a, pd.array([True, False, None], dtype="boolean")
  223:         )
  224: 
  225:     @pytest.mark.parametrize("other", [True, False, pd.NA, [True, False, None] * 3])
  226:     def test_no_masked_assumptions(self, other, all_logical_operators):
  227:         # The logical operations should not assume that masked values are False!
  228:         a = pd.arrays.BooleanArray(
  229:             np.array([True, True, True, False, False, False, True, False, True]),
  230:             np.array([False] * 6 + [True, True, True]),
  231:         )
  232:         b = pd.array([True] * 3 + [False] * 3 + [None] * 3, dtype="boolean")
  233:         if isinstance(other, list):
  234:             other = pd.array(other, dtype="boolean")
  235: 
  236:         result = getattr(a, all_logical_operators)(other)
  237:         expected = getattr(b, all_logical_operators)(other)
  238:         tm.assert_extension_array_equal(result, expected)
  239: 
  240:         if isinstance(other, BooleanArray):
  241:             other._data[other._mask] = True
  242:             a._data[a._mask] = False
  243: 
  244:             result = getattr(a, all_logical_operators)(other)
  245:             expected = getattr(b, all_logical_operators)(other)
  246:             tm.assert_extension_array_equal(result, expected)
  247: 
  248: 
  249: @pytest.mark.parametrize("operation", [kleene_or, kleene_xor, kleene_and])
  250: def test_error_both_scalar(operation):
  251:     msg = r"Either `left` or `right` need to be a np\.ndarray."
  252:     with pytest.raises(TypeError, match=msg):
  253:         # masks need to be non-None, otherwise it ends up in an infinite recursion
  254:         operation(True, True, np.zeros(1), np.zeros(1))
