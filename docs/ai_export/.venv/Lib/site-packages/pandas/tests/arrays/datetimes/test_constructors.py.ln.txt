    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._libs import iNaT
    5: 
    6: from pandas.core.dtypes.dtypes import DatetimeTZDtype
    7: 
    8: import pandas as pd
    9: import pandas._testing as tm
   10: from pandas.core.arrays import DatetimeArray
   11: 
   12: 
   13: class TestDatetimeArrayConstructor:
   14:     def test_from_sequence_invalid_type(self):
   15:         mi = pd.MultiIndex.from_product([np.arange(5), np.arange(5)])
   16:         with pytest.raises(TypeError, match="Cannot create a DatetimeArray"):
   17:             DatetimeArray._from_sequence(mi, dtype="M8[ns]")
   18: 
   19:     def test_only_1dim_accepted(self):
   20:         arr = np.array([0, 1, 2, 3], dtype="M8[h]").astype("M8[ns]")
   21: 
   22:         depr_msg = "DatetimeArray.__init__ is deprecated"
   23:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   24:             with pytest.raises(ValueError, match="Only 1-dimensional"):
   25:                 # 3-dim, we allow 2D to sneak in for ops purposes GH#29853
   26:                 DatetimeArray(arr.reshape(2, 2, 1))
   27: 
   28:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   29:             with pytest.raises(ValueError, match="Only 1-dimensional"):
   30:                 # 0-dim
   31:                 DatetimeArray(arr[[0]].squeeze())
   32: 
   33:     def test_freq_validation(self):
   34:         # GH#24623 check that invalid instances cannot be created with the
   35:         #  public constructor
   36:         arr = np.arange(5, dtype=np.int64) * 3600 * 10**9
   37: 
   38:         msg = (
   39:             "Inferred frequency h from passed values does not "
   40:             "conform to passed frequency W-SUN"
   41:         )
   42:         depr_msg = "DatetimeArray.__init__ is deprecated"
   43:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   44:             with pytest.raises(ValueError, match=msg):
   45:                 DatetimeArray(arr, freq="W")
   46: 
   47:     @pytest.mark.parametrize(
   48:         "meth",
   49:         [
   50:             DatetimeArray._from_sequence,
   51:             pd.to_datetime,
   52:             pd.DatetimeIndex,
   53:         ],
   54:     )
   55:     def test_mixing_naive_tzaware_raises(self, meth):
   56:         # GH#24569
   57:         arr = np.array([pd.Timestamp("2000"), pd.Timestamp("2000", tz="CET")])
   58: 
   59:         msg = (
   60:             "Cannot mix tz-aware with tz-naive values|"
   61:             "Tz-aware datetime.datetime cannot be converted "
   62:             "to datetime64 unless utc=True"
   63:         )
   64: 
   65:         for obj in [arr, arr[::-1]]:
   66:             # check that we raise regardless of whether naive is found
   67:             #  before aware or vice-versa
   68:             with pytest.raises(ValueError, match=msg):
   69:                 meth(obj)
   70: 
   71:     def test_from_pandas_array(self):
   72:         arr = pd.array(np.arange(5, dtype=np.int64)) * 3600 * 10**9
   73: 
   74:         result = DatetimeArray._from_sequence(arr, dtype="M8[ns]")._with_freq("infer")
   75: 
   76:         expected = pd.date_range("1970-01-01", periods=5, freq="h")._data
   77:         tm.assert_datetime_array_equal(result, expected)
   78: 
   79:     def test_mismatched_timezone_raises(self):
   80:         depr_msg = "DatetimeArray.__init__ is deprecated"
   81:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   82:             arr = DatetimeArray(
   83:                 np.array(["2000-01-01T06:00:00"], dtype="M8[ns]"),
   84:                 dtype=DatetimeTZDtype(tz="US/Central"),
   85:             )
   86:         dtype = DatetimeTZDtype(tz="US/Eastern")
   87:         msg = r"dtype=datetime64\[ns.*\] does not match data dtype datetime64\[ns.*\]"
   88:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   89:             with pytest.raises(TypeError, match=msg):
   90:                 DatetimeArray(arr, dtype=dtype)
   91: 
   92:         # also with mismatched tzawareness
   93:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   94:             with pytest.raises(TypeError, match=msg):
   95:                 DatetimeArray(arr, dtype=np.dtype("M8[ns]"))
   96:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   97:             with pytest.raises(TypeError, match=msg):
   98:                 DatetimeArray(arr.tz_localize(None), dtype=arr.dtype)
   99: 
  100:     def test_non_array_raises(self):
  101:         depr_msg = "DatetimeArray.__init__ is deprecated"
  102:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  103:             with pytest.raises(ValueError, match="list"):
  104:                 DatetimeArray([1, 2, 3])
  105: 
  106:     def test_bool_dtype_raises(self):
  107:         arr = np.array([1, 2, 3], dtype="bool")
  108: 
  109:         depr_msg = "DatetimeArray.__init__ is deprecated"
  110:         msg = "Unexpected value for 'dtype': 'bool'. Must be"
  111:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  112:             with pytest.raises(ValueError, match=msg):
  113:                 DatetimeArray(arr)
  114: 
  115:         msg = r"dtype bool cannot be converted to datetime64\[ns\]"
  116:         with pytest.raises(TypeError, match=msg):
  117:             DatetimeArray._from_sequence(arr, dtype="M8[ns]")
  118: 
  119:         with pytest.raises(TypeError, match=msg):
  120:             pd.DatetimeIndex(arr)
  121: 
  122:         with pytest.raises(TypeError, match=msg):
  123:             pd.to_datetime(arr)
  124: 
  125:     def test_incorrect_dtype_raises(self):
  126:         depr_msg = "DatetimeArray.__init__ is deprecated"
  127:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  128:             with pytest.raises(ValueError, match="Unexpected value for 'dtype'."):
  129:                 DatetimeArray(np.array([1, 2, 3], dtype="i8"), dtype="category")
  130: 
  131:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  132:             with pytest.raises(ValueError, match="Unexpected value for 'dtype'."):
  133:                 DatetimeArray(np.array([1, 2, 3], dtype="i8"), dtype="m8[s]")
  134: 
  135:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  136:             with pytest.raises(ValueError, match="Unexpected value for 'dtype'."):
  137:                 DatetimeArray(np.array([1, 2, 3], dtype="i8"), dtype="M8[D]")
  138: 
  139:     def test_mismatched_values_dtype_units(self):
  140:         arr = np.array([1, 2, 3], dtype="M8[s]")
  141:         dtype = np.dtype("M8[ns]")
  142:         msg = "Values resolution does not match dtype."
  143:         depr_msg = "DatetimeArray.__init__ is deprecated"
  144: 
  145:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  146:             with pytest.raises(ValueError, match=msg):
  147:                 DatetimeArray(arr, dtype=dtype)
  148: 
  149:         dtype2 = DatetimeTZDtype(tz="UTC", unit="ns")
  150:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  151:             with pytest.raises(ValueError, match=msg):
  152:                 DatetimeArray(arr, dtype=dtype2)
  153: 
  154:     def test_freq_infer_raises(self):
  155:         depr_msg = "DatetimeArray.__init__ is deprecated"
  156:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  157:             with pytest.raises(ValueError, match="Frequency inference"):
  158:                 DatetimeArray(np.array([1, 2, 3], dtype="i8"), freq="infer")
  159: 
  160:     def test_copy(self):
  161:         data = np.array([1, 2, 3], dtype="M8[ns]")
  162:         arr = DatetimeArray._from_sequence(data, copy=False)
  163:         assert arr._ndarray is data
  164: 
  165:         arr = DatetimeArray._from_sequence(data, copy=True)
  166:         assert arr._ndarray is not data
  167: 
  168:     @pytest.mark.parametrize("unit", ["s", "ms", "us", "ns"])
  169:     def test_numpy_datetime_unit(self, unit):
  170:         data = np.array([1, 2, 3], dtype=f"M8[{unit}]")
  171:         arr = DatetimeArray._from_sequence(data)
  172:         assert arr.unit == unit
  173:         assert arr[0].unit == unit
  174: 
  175: 
  176: class TestSequenceToDT64NS:
  177:     def test_tz_dtype_mismatch_raises(self):
  178:         arr = DatetimeArray._from_sequence(
  179:             ["2000"], dtype=DatetimeTZDtype(tz="US/Central")
  180:         )
  181:         with pytest.raises(TypeError, match="data is already tz-aware"):
  182:             DatetimeArray._from_sequence(arr, dtype=DatetimeTZDtype(tz="UTC"))
  183: 
  184:     def test_tz_dtype_matches(self):
  185:         dtype = DatetimeTZDtype(tz="US/Central")
  186:         arr = DatetimeArray._from_sequence(["2000"], dtype=dtype)
  187:         result = DatetimeArray._from_sequence(arr, dtype=dtype)
  188:         tm.assert_equal(arr, result)
  189: 
  190:     @pytest.mark.parametrize("order", ["F", "C"])
  191:     def test_2d(self, order):
  192:         dti = pd.date_range("2016-01-01", periods=6, tz="US/Pacific")
  193:         arr = np.array(dti, dtype=object).reshape(3, 2)
  194:         if order == "F":
  195:             arr = arr.T
  196: 
  197:         res = DatetimeArray._from_sequence(arr, dtype=dti.dtype)
  198:         expected = DatetimeArray._from_sequence(arr.ravel(), dtype=dti.dtype).reshape(
  199:             arr.shape
  200:         )
  201:         tm.assert_datetime_array_equal(res, expected)
  202: 
  203: 
  204: # ----------------------------------------------------------------------------
  205: # Arrow interaction
  206: 
  207: 
  208: EXTREME_VALUES = [0, 123456789, None, iNaT, 2**63 - 1, -(2**63) + 1]
  209: FINE_TO_COARSE_SAFE = [123_000_000_000, None, -123_000_000_000]
  210: COARSE_TO_FINE_SAFE = [123, None, -123]
  211: 
  212: 
  213: @pytest.mark.parametrize(
  214:     ("pa_unit", "pd_unit", "pa_tz", "pd_tz", "data"),
  215:     [
  216:         ("s", "s", "UTC", "UTC", EXTREME_VALUES),
  217:         ("ms", "ms", "UTC", "Europe/Berlin", EXTREME_VALUES),
  218:         ("us", "us", "US/Eastern", "UTC", EXTREME_VALUES),
  219:         ("ns", "ns", "US/Central", "Asia/Kolkata", EXTREME_VALUES),
  220:         ("ns", "s", "UTC", "UTC", FINE_TO_COARSE_SAFE),
  221:         ("us", "ms", "UTC", "Europe/Berlin", FINE_TO_COARSE_SAFE),
  222:         ("ms", "us", "US/Eastern", "UTC", COARSE_TO_FINE_SAFE),
  223:         ("s", "ns", "US/Central", "Asia/Kolkata", COARSE_TO_FINE_SAFE),
  224:     ],
  225: )
  226: def test_from_arrow_with_different_units_and_timezones_with(
  227:     pa_unit, pd_unit, pa_tz, pd_tz, data
  228: ):
  229:     pa = pytest.importorskip("pyarrow")
  230: 
  231:     pa_type = pa.timestamp(pa_unit, tz=pa_tz)
  232:     arr = pa.array(data, type=pa_type)
  233:     dtype = DatetimeTZDtype(unit=pd_unit, tz=pd_tz)
  234: 
  235:     result = dtype.__from_arrow__(arr)
  236:     expected = DatetimeArray._from_sequence(data, dtype=f"M8[{pa_unit}, UTC]").astype(
  237:         dtype, copy=False
  238:     )
  239:     tm.assert_extension_array_equal(result, expected)
  240: 
  241:     result = dtype.__from_arrow__(pa.chunked_array([arr]))
  242:     tm.assert_extension_array_equal(result, expected)
  243: 
  244: 
  245: @pytest.mark.parametrize(
  246:     ("unit", "tz"),
  247:     [
  248:         ("s", "UTC"),
  249:         ("ms", "Europe/Berlin"),
  250:         ("us", "US/Eastern"),
  251:         ("ns", "Asia/Kolkata"),
  252:         ("ns", "UTC"),
  253:     ],
  254: )
  255: def test_from_arrow_from_empty(unit, tz):
  256:     pa = pytest.importorskip("pyarrow")
  257: 
  258:     data = []
  259:     arr = pa.array(data)
  260:     dtype = DatetimeTZDtype(unit=unit, tz=tz)
  261: 
  262:     result = dtype.__from_arrow__(arr)
  263:     expected = DatetimeArray._from_sequence(np.array(data, dtype=f"datetime64[{unit}]"))
  264:     expected = expected.tz_localize(tz=tz)
  265:     tm.assert_extension_array_equal(result, expected)
  266: 
  267:     result = dtype.__from_arrow__(pa.chunked_array([arr]))
  268:     tm.assert_extension_array_equal(result, expected)
  269: 
  270: 
  271: def test_from_arrow_from_integers():
  272:     pa = pytest.importorskip("pyarrow")
  273: 
  274:     data = [0, 123456789, None, 2**63 - 1, iNaT, -123456789]
  275:     arr = pa.array(data)
  276:     dtype = DatetimeTZDtype(unit="ns", tz="UTC")
  277: 
  278:     result = dtype.__from_arrow__(arr)
  279:     expected = DatetimeArray._from_sequence(np.array(data, dtype="datetime64[ns]"))
  280:     expected = expected.tz_localize("UTC")
  281:     tm.assert_extension_array_equal(result, expected)
  282: 
  283:     result = dtype.__from_arrow__(pa.chunked_array([arr]))
  284:     tm.assert_extension_array_equal(result, expected)
