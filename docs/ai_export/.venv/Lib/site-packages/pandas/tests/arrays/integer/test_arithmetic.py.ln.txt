    1: import operator
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: from pandas.core import ops
    9: from pandas.core.arrays import FloatingArray
   10: 
   11: # Basic test for the arithmetic array ops
   12: # -----------------------------------------------------------------------------
   13: 
   14: 
   15: @pytest.mark.parametrize(
   16:     "opname, exp",
   17:     [("add", [1, 3, None, None, 9]), ("mul", [0, 2, None, None, 20])],
   18:     ids=["add", "mul"],
   19: )
   20: def test_add_mul(dtype, opname, exp):
   21:     a = pd.array([0, 1, None, 3, 4], dtype=dtype)
   22:     b = pd.array([1, 2, 3, None, 5], dtype=dtype)
   23: 
   24:     # array / array
   25:     expected = pd.array(exp, dtype=dtype)
   26: 
   27:     op = getattr(operator, opname)
   28:     result = op(a, b)
   29:     tm.assert_extension_array_equal(result, expected)
   30: 
   31:     op = getattr(ops, "r" + opname)
   32:     result = op(a, b)
   33:     tm.assert_extension_array_equal(result, expected)
   34: 
   35: 
   36: def test_sub(dtype):
   37:     a = pd.array([1, 2, 3, None, 5], dtype=dtype)
   38:     b = pd.array([0, 1, None, 3, 4], dtype=dtype)
   39: 
   40:     result = a - b
   41:     expected = pd.array([1, 1, None, None, 1], dtype=dtype)
   42:     tm.assert_extension_array_equal(result, expected)
   43: 
   44: 
   45: def test_div(dtype):
   46:     a = pd.array([1, 2, 3, None, 5], dtype=dtype)
   47:     b = pd.array([0, 1, None, 3, 4], dtype=dtype)
   48: 
   49:     result = a / b
   50:     expected = pd.array([np.inf, 2, None, None, 1.25], dtype="Float64")
   51:     tm.assert_extension_array_equal(result, expected)
   52: 
   53: 
   54: @pytest.mark.parametrize("zero, negative", [(0, False), (0.0, False), (-0.0, True)])
   55: def test_divide_by_zero(zero, negative):
   56:     # https://github.com/pandas-dev/pandas/issues/27398, GH#22793
   57:     a = pd.array([0, 1, -1, None], dtype="Int64")
   58:     result = a / zero
   59:     expected = FloatingArray(
   60:         np.array([np.nan, np.inf, -np.inf, 1], dtype="float64"),
   61:         np.array([False, False, False, True]),
   62:     )
   63:     if negative:
   64:         expected *= -1
   65:     tm.assert_extension_array_equal(result, expected)
   66: 
   67: 
   68: def test_floordiv(dtype):
   69:     a = pd.array([1, 2, 3, None, 5], dtype=dtype)
   70:     b = pd.array([0, 1, None, 3, 4], dtype=dtype)
   71: 
   72:     result = a // b
   73:     # Series op sets 1//0 to np.inf, which IntegerArray does not do (yet)
   74:     expected = pd.array([0, 2, None, None, 1], dtype=dtype)
   75:     tm.assert_extension_array_equal(result, expected)
   76: 
   77: 
   78: def test_floordiv_by_int_zero_no_mask(any_int_ea_dtype):
   79:     # GH 48223: Aligns with non-masked floordiv
   80:     # but differs from numpy
   81:     # https://github.com/pandas-dev/pandas/issues/30188#issuecomment-564452740
   82:     ser = pd.Series([0, 1], dtype=any_int_ea_dtype)
   83:     result = 1 // ser
   84:     expected = pd.Series([np.inf, 1.0], dtype="Float64")
   85:     tm.assert_series_equal(result, expected)
   86: 
   87:     ser_non_nullable = ser.astype(ser.dtype.numpy_dtype)
   88:     result = 1 // ser_non_nullable
   89:     expected = expected.astype(np.float64)
   90:     tm.assert_series_equal(result, expected)
   91: 
   92: 
   93: def test_mod(dtype):
   94:     a = pd.array([1, 2, 3, None, 5], dtype=dtype)
   95:     b = pd.array([0, 1, None, 3, 4], dtype=dtype)
   96: 
   97:     result = a % b
   98:     expected = pd.array([0, 0, None, None, 1], dtype=dtype)
   99:     tm.assert_extension_array_equal(result, expected)
  100: 
  101: 
  102: def test_pow_scalar():
  103:     a = pd.array([-1, 0, 1, None, 2], dtype="Int64")
  104:     result = a**0
  105:     expected = pd.array([1, 1, 1, 1, 1], dtype="Int64")
  106:     tm.assert_extension_array_equal(result, expected)
  107: 
  108:     result = a**1
  109:     expected = pd.array([-1, 0, 1, None, 2], dtype="Int64")
  110:     tm.assert_extension_array_equal(result, expected)
  111: 
  112:     result = a**pd.NA
  113:     expected = pd.array([None, None, 1, None, None], dtype="Int64")
  114:     tm.assert_extension_array_equal(result, expected)
  115: 
  116:     result = a**np.nan
  117:     expected = FloatingArray(
  118:         np.array([np.nan, np.nan, 1, np.nan, np.nan], dtype="float64"),
  119:         np.array([False, False, False, True, False]),
  120:     )
  121:     tm.assert_extension_array_equal(result, expected)
  122: 
  123:     # reversed
  124:     a = a[1:]  # Can't raise integers to negative powers.
  125: 
  126:     result = 0**a
  127:     expected = pd.array([1, 0, None, 0], dtype="Int64")
  128:     tm.assert_extension_array_equal(result, expected)
  129: 
  130:     result = 1**a
  131:     expected = pd.array([1, 1, 1, 1], dtype="Int64")
  132:     tm.assert_extension_array_equal(result, expected)
  133: 
  134:     result = pd.NA**a
  135:     expected = pd.array([1, None, None, None], dtype="Int64")
  136:     tm.assert_extension_array_equal(result, expected)
  137: 
  138:     result = np.nan**a
  139:     expected = FloatingArray(
  140:         np.array([1, np.nan, np.nan, np.nan], dtype="float64"),
  141:         np.array([False, False, True, False]),
  142:     )
  143:     tm.assert_extension_array_equal(result, expected)
  144: 
  145: 
  146: def test_pow_array():
  147:     a = pd.array([0, 0, 0, 1, 1, 1, None, None, None])
  148:     b = pd.array([0, 1, None, 0, 1, None, 0, 1, None])
  149:     result = a**b
  150:     expected = pd.array([1, 0, None, 1, 1, 1, 1, None, None])
  151:     tm.assert_extension_array_equal(result, expected)
  152: 
  153: 
  154: def test_rpow_one_to_na():
  155:     # https://github.com/pandas-dev/pandas/issues/22022
  156:     # https://github.com/pandas-dev/pandas/issues/29997
  157:     arr = pd.array([np.nan, np.nan], dtype="Int64")
  158:     result = np.array([1.0, 2.0]) ** arr
  159:     expected = pd.array([1.0, np.nan], dtype="Float64")
  160:     tm.assert_extension_array_equal(result, expected)
  161: 
  162: 
  163: @pytest.mark.parametrize("other", [0, 0.5])
  164: def test_numpy_zero_dim_ndarray(other):
  165:     arr = pd.array([1, None, 2])
  166:     result = arr + np.array(other)
  167:     expected = arr + other
  168:     tm.assert_equal(result, expected)
  169: 
  170: 
  171: # Test generic characteristics / errors
  172: # -----------------------------------------------------------------------------
  173: 
  174: 
  175: def test_error_invalid_values(data, all_arithmetic_operators, using_infer_string):
  176:     op = all_arithmetic_operators
  177:     s = pd.Series(data)
  178:     ops = getattr(s, op)
  179: 
  180:     if using_infer_string:
  181:         import pyarrow as pa
  182: 
  183:         errs = (TypeError, pa.lib.ArrowNotImplementedError, NotImplementedError)
  184:     else:
  185:         errs = TypeError
  186: 
  187:     # invalid scalars
  188:     msg = "|".join(
  189:         [
  190:             r"can only perform ops with numeric values",
  191:             r"IntegerArray cannot perform the operation mod",
  192:             r"unsupported operand type",
  193:             r"can only concatenate str \(not \"int\"\) to str",
  194:             "not all arguments converted during string",
  195:             "ufunc '.*' not supported for the input types, and the inputs could not",
  196:             "ufunc '.*' did not contain a loop with signature matching types",
  197:             "Addition/subtraction of integers and integer-arrays with Timestamp",
  198:             "has no kernel",
  199:             "not implemented",
  200:             "The 'out' kwarg is necessary. Use numpy.strings.multiply without it.",
  201:         ]
  202:     )
  203:     with pytest.raises(errs, match=msg):
  204:         ops("foo")
  205:     with pytest.raises(errs, match=msg):
  206:         ops(pd.Timestamp("20180101"))
  207: 
  208:     # invalid array-likes
  209:     str_ser = pd.Series("foo", index=s.index)
  210:     # with pytest.raises(TypeError, match=msg):
  211:     if (
  212:         all_arithmetic_operators
  213:         in [
  214:             "__mul__",
  215:             "__rmul__",
  216:         ]
  217:         and not using_infer_string
  218:     ):  # (data[~data.isna()] >= 0).all():
  219:         res = ops(str_ser)
  220:         expected = pd.Series(["foo" * x for x in data], index=s.index)
  221:         expected = expected.fillna(np.nan)
  222:         # TODO: doing this fillna to keep tests passing as we make
  223:         #  assert_almost_equal stricter, but the expected with pd.NA seems
  224:         #  more-correct than np.nan here.
  225:         tm.assert_series_equal(res, expected)
  226:     else:
  227:         with pytest.raises(errs, match=msg):
  228:             ops(str_ser)
  229: 
  230:     msg = "|".join(
  231:         [
  232:             "can only perform ops with numeric values",
  233:             "cannot perform .* with this index type: DatetimeArray",
  234:             "Addition/subtraction of integers and integer-arrays "
  235:             "with DatetimeArray is no longer supported. *",
  236:             "unsupported operand type",
  237:             r"can only concatenate str \(not \"int\"\) to str",
  238:             "not all arguments converted during string",
  239:             "cannot subtract DatetimeArray from ndarray",
  240:             "has no kernel",
  241:             "not implemented",
  242:         ]
  243:     )
  244:     with pytest.raises(errs, match=msg):
  245:         ops(pd.Series(pd.date_range("20180101", periods=len(s))))
  246: 
  247: 
  248: # Various
  249: # -----------------------------------------------------------------------------
  250: 
  251: 
  252: # TODO test unsigned overflow
  253: 
  254: 
  255: def test_arith_coerce_scalar(data, all_arithmetic_operators):
  256:     op = tm.get_op_from_name(all_arithmetic_operators)
  257:     s = pd.Series(data)
  258:     other = 0.01
  259: 
  260:     result = op(s, other)
  261:     expected = op(s.astype(float), other)
  262:     expected = expected.astype("Float64")
  263: 
  264:     # rmod results in NaN that wasn't NA in original nullable Series -> unmask it
  265:     if all_arithmetic_operators == "__rmod__":
  266:         mask = (s == 0).fillna(False).to_numpy(bool)
  267:         expected.array._mask[mask] = False
  268: 
  269:     tm.assert_series_equal(result, expected)
  270: 
  271: 
  272: @pytest.mark.parametrize("other", [1.0, np.array(1.0)])
  273: def test_arithmetic_conversion(all_arithmetic_operators, other):
  274:     # if we have a float operand we should have a float result
  275:     # if that is equal to an integer
  276:     op = tm.get_op_from_name(all_arithmetic_operators)
  277: 
  278:     s = pd.Series([1, 2, 3], dtype="Int64")
  279:     result = op(s, other)
  280:     assert result.dtype == "Float64"
  281: 
  282: 
  283: def test_cross_type_arithmetic():
  284:     df = pd.DataFrame(
  285:         {
  286:             "A": pd.Series([1, 2, np.nan], dtype="Int64"),
  287:             "B": pd.Series([1, np.nan, 3], dtype="UInt8"),
  288:             "C": [1, 2, 3],
  289:         }
  290:     )
  291: 
  292:     result = df.A + df.C
  293:     expected = pd.Series([2, 4, np.nan], dtype="Int64")
  294:     tm.assert_series_equal(result, expected)
  295: 
  296:     result = (df.A + df.C) * 3 == 12
  297:     expected = pd.Series([False, True, None], dtype="boolean")
  298:     tm.assert_series_equal(result, expected)
  299: 
  300:     result = df.A + df.B
  301:     expected = pd.Series([2, np.nan, np.nan], dtype="Int64")
  302:     tm.assert_series_equal(result, expected)
  303: 
  304: 
  305: @pytest.mark.parametrize("op", ["mean"])
  306: def test_reduce_to_float(op):
  307:     # some reduce ops always return float, even if the result
  308:     # is a rounded number
  309:     df = pd.DataFrame(
  310:         {
  311:             "A": ["a", "b", "b"],
  312:             "B": [1, None, 3],
  313:             "C": pd.array([1, None, 3], dtype="Int64"),
  314:         }
  315:     )
  316: 
  317:     # op
  318:     result = getattr(df.C, op)()
  319:     assert isinstance(result, float)
  320: 
  321:     # groupby
  322:     result = getattr(df.groupby("A"), op)()
  323: 
  324:     expected = pd.DataFrame(
  325:         {"B": np.array([1.0, 3.0]), "C": pd.array([1, 3], dtype="Float64")},
  326:         index=pd.Index(["a", "b"], name="A"),
  327:     )
  328:     tm.assert_frame_equal(result, expected)
  329: 
  330: 
  331: @pytest.mark.parametrize(
  332:     "source, neg_target, abs_target",
  333:     [
  334:         ([1, 2, 3], [-1, -2, -3], [1, 2, 3]),
  335:         ([1, 2, None], [-1, -2, None], [1, 2, None]),
  336:         ([-1, 0, 1], [1, 0, -1], [1, 0, 1]),
  337:     ],
  338: )
  339: def test_unary_int_operators(any_signed_int_ea_dtype, source, neg_target, abs_target):
  340:     dtype = any_signed_int_ea_dtype
  341:     arr = pd.array(source, dtype=dtype)
  342:     neg_result, pos_result, abs_result = -arr, +arr, abs(arr)
  343:     neg_target = pd.array(neg_target, dtype=dtype)
  344:     abs_target = pd.array(abs_target, dtype=dtype)
  345: 
  346:     tm.assert_extension_array_equal(neg_result, neg_target)
  347:     tm.assert_extension_array_equal(pos_result, arr)
  348:     assert not tm.shares_memory(pos_result, arr)
  349:     tm.assert_extension_array_equal(abs_result, abs_target)
  350: 
  351: 
  352: def test_values_multiplying_large_series_by_NA():
  353:     # GH#33701
  354: 
  355:     result = pd.NA * pd.Series(np.zeros(10001))
  356:     expected = pd.Series([pd.NA] * 10001)
  357: 
  358:     tm.assert_series_equal(result, expected)
  359: 
  360: 
  361: def test_bitwise(dtype):
  362:     left = pd.array([1, None, 3, 4], dtype=dtype)
  363:     right = pd.array([None, 3, 5, 4], dtype=dtype)
  364: 
  365:     result = left | right
  366:     expected = pd.array([None, None, 3 | 5, 4 | 4], dtype=dtype)
  367:     tm.assert_extension_array_equal(result, expected)
  368: 
  369:     result = left & right
  370:     expected = pd.array([None, None, 3 & 5, 4 & 4], dtype=dtype)
  371:     tm.assert_extension_array_equal(result, expected)
  372: 
  373:     result = left ^ right
  374:     expected = pd.array([None, None, 3 ^ 5, 4 ^ 4], dtype=dtype)
  375:     tm.assert_extension_array_equal(result, expected)
  376: 
  377:     # TODO: desired behavior when operating with boolean?  defer?
  378: 
  379:     floats = right.astype("Float64")
  380:     with pytest.raises(TypeError, match="unsupported operand type"):
  381:         left | floats
  382:     with pytest.raises(TypeError, match="unsupported operand type"):
  383:         left & floats
  384:     with pytest.raises(TypeError, match="unsupported operand type"):
  385:         left ^ floats
