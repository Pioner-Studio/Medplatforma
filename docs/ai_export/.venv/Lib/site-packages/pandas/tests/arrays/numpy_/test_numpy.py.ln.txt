    1: """
    2: Additional tests for NumpyExtensionArray that aren't covered by
    3: the interface tests.
    4: """
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas.core.dtypes.dtypes import NumpyEADtype
    9: 
   10: import pandas as pd
   11: import pandas._testing as tm
   12: from pandas.arrays import NumpyExtensionArray
   13: 
   14: 
   15: @pytest.fixture(
   16:     params=[
   17:         np.array(["a", "b"], dtype=object),
   18:         np.array([0, 1], dtype=float),
   19:         np.array([0, 1], dtype=int),
   20:         np.array([0, 1 + 2j], dtype=complex),
   21:         np.array([True, False], dtype=bool),
   22:         np.array([0, 1], dtype="datetime64[ns]"),
   23:         np.array([0, 1], dtype="timedelta64[ns]"),
   24:     ]
   25: )
   26: def any_numpy_array(request):
   27:     """
   28:     Parametrized fixture for NumPy arrays with different dtypes.
   29: 
   30:     This excludes string and bytes.
   31:     """
   32:     return request.param
   33: 
   34: 
   35: # ----------------------------------------------------------------------------
   36: # NumpyEADtype
   37: 
   38: 
   39: @pytest.mark.parametrize(
   40:     "dtype, expected",
   41:     [
   42:         ("bool", True),
   43:         ("int", True),
   44:         ("uint", True),
   45:         ("float", True),
   46:         ("complex", True),
   47:         ("str", False),
   48:         ("bytes", False),
   49:         ("datetime64[ns]", False),
   50:         ("object", False),
   51:         ("void", False),
   52:     ],
   53: )
   54: def test_is_numeric(dtype, expected):
   55:     dtype = NumpyEADtype(dtype)
   56:     assert dtype._is_numeric is expected
   57: 
   58: 
   59: @pytest.mark.parametrize(
   60:     "dtype, expected",
   61:     [
   62:         ("bool", True),
   63:         ("int", False),
   64:         ("uint", False),
   65:         ("float", False),
   66:         ("complex", False),
   67:         ("str", False),
   68:         ("bytes", False),
   69:         ("datetime64[ns]", False),
   70:         ("object", False),
   71:         ("void", False),
   72:     ],
   73: )
   74: def test_is_boolean(dtype, expected):
   75:     dtype = NumpyEADtype(dtype)
   76:     assert dtype._is_boolean is expected
   77: 
   78: 
   79: def test_repr():
   80:     dtype = NumpyEADtype(np.dtype("int64"))
   81:     assert repr(dtype) == "NumpyEADtype('int64')"
   82: 
   83: 
   84: def test_constructor_from_string():
   85:     result = NumpyEADtype.construct_from_string("int64")
   86:     expected = NumpyEADtype(np.dtype("int64"))
   87:     assert result == expected
   88: 
   89: 
   90: def test_dtype_idempotent(any_numpy_dtype):
   91:     dtype = NumpyEADtype(any_numpy_dtype)
   92: 
   93:     result = NumpyEADtype(dtype)
   94:     assert result == dtype
   95: 
   96: 
   97: # ----------------------------------------------------------------------------
   98: # Construction
   99: 
  100: 
  101: def test_constructor_no_coercion():
  102:     with pytest.raises(ValueError, match="NumPy array"):
  103:         NumpyExtensionArray([1, 2, 3])
  104: 
  105: 
  106: def test_series_constructor_with_copy():
  107:     ndarray = np.array([1, 2, 3])
  108:     ser = pd.Series(NumpyExtensionArray(ndarray), copy=True)
  109: 
  110:     assert ser.values is not ndarray
  111: 
  112: 
  113: def test_series_constructor_with_astype():
  114:     ndarray = np.array([1, 2, 3])
  115:     result = pd.Series(NumpyExtensionArray(ndarray), dtype="float64")
  116:     expected = pd.Series([1.0, 2.0, 3.0], dtype="float64")
  117:     tm.assert_series_equal(result, expected)
  118: 
  119: 
  120: def test_from_sequence_dtype():
  121:     arr = np.array([1, 2, 3], dtype="int64")
  122:     result = NumpyExtensionArray._from_sequence(arr, dtype="uint64")
  123:     expected = NumpyExtensionArray(np.array([1, 2, 3], dtype="uint64"))
  124:     tm.assert_extension_array_equal(result, expected)
  125: 
  126: 
  127: def test_constructor_copy():
  128:     arr = np.array([0, 1])
  129:     result = NumpyExtensionArray(arr, copy=True)
  130: 
  131:     assert not tm.shares_memory(result, arr)
  132: 
  133: 
  134: def test_constructor_with_data(any_numpy_array):
  135:     nparr = any_numpy_array
  136:     arr = NumpyExtensionArray(nparr)
  137:     assert arr.dtype.numpy_dtype == nparr.dtype
  138: 
  139: 
  140: # ----------------------------------------------------------------------------
  141: # Conversion
  142: 
  143: 
  144: def test_to_numpy():
  145:     arr = NumpyExtensionArray(np.array([1, 2, 3]))
  146:     result = arr.to_numpy()
  147:     assert result is arr._ndarray
  148: 
  149:     result = arr.to_numpy(copy=True)
  150:     assert result is not arr._ndarray
  151: 
  152:     result = arr.to_numpy(dtype="f8")
  153:     expected = np.array([1, 2, 3], dtype="f8")
  154:     tm.assert_numpy_array_equal(result, expected)
  155: 
  156: 
  157: # ----------------------------------------------------------------------------
  158: # Setitem
  159: 
  160: 
  161: def test_setitem_series():
  162:     ser = pd.Series([1, 2, 3])
  163:     ser.array[0] = 10
  164:     expected = pd.Series([10, 2, 3])
  165:     tm.assert_series_equal(ser, expected)
  166: 
  167: 
  168: def test_setitem(any_numpy_array):
  169:     nparr = any_numpy_array
  170:     arr = NumpyExtensionArray(nparr, copy=True)
  171: 
  172:     arr[0] = arr[1]
  173:     nparr[0] = nparr[1]
  174: 
  175:     tm.assert_numpy_array_equal(arr.to_numpy(), nparr)
  176: 
  177: 
  178: # ----------------------------------------------------------------------------
  179: # Reductions
  180: 
  181: 
  182: def test_bad_reduce_raises():
  183:     arr = np.array([1, 2, 3], dtype="int64")
  184:     arr = NumpyExtensionArray(arr)
  185:     msg = "cannot perform not_a_method with type int"
  186:     with pytest.raises(TypeError, match=msg):
  187:         arr._reduce(msg)
  188: 
  189: 
  190: def test_validate_reduction_keyword_args():
  191:     arr = NumpyExtensionArray(np.array([1, 2, 3]))
  192:     msg = "the 'keepdims' parameter is not supported .*all"
  193:     with pytest.raises(ValueError, match=msg):
  194:         arr.all(keepdims=True)
  195: 
  196: 
  197: def test_np_max_nested_tuples():
  198:     # case where checking in ufunc.nout works while checking for tuples
  199:     #  does not
  200:     vals = [
  201:         (("j", "k"), ("l", "m")),
  202:         (("l", "m"), ("o", "p")),
  203:         (("o", "p"), ("j", "k")),
  204:     ]
  205:     ser = pd.Series(vals)
  206:     arr = ser.array
  207: 
  208:     assert arr.max() is arr[2]
  209:     assert ser.max() is arr[2]
  210: 
  211:     result = np.maximum.reduce(arr)
  212:     assert result == arr[2]
  213: 
  214:     result = np.maximum.reduce(ser)
  215:     assert result == arr[2]
  216: 
  217: 
  218: def test_np_reduce_2d():
  219:     raw = np.arange(12).reshape(4, 3)
  220:     arr = NumpyExtensionArray(raw)
  221: 
  222:     res = np.maximum.reduce(arr, axis=0)
  223:     tm.assert_extension_array_equal(res, arr[-1])
  224: 
  225:     alt = arr.max(axis=0)
  226:     tm.assert_extension_array_equal(alt, arr[-1])
  227: 
  228: 
  229: # ----------------------------------------------------------------------------
  230: # Ops
  231: 
  232: 
  233: @pytest.mark.parametrize("ufunc", [np.abs, np.negative, np.positive])
  234: def test_ufunc_unary(ufunc):
  235:     arr = NumpyExtensionArray(np.array([-1.0, 0.0, 1.0]))
  236:     result = ufunc(arr)
  237:     expected = NumpyExtensionArray(ufunc(arr._ndarray))
  238:     tm.assert_extension_array_equal(result, expected)
  239: 
  240:     # same thing but with the 'out' keyword
  241:     out = NumpyExtensionArray(np.array([-9.0, -9.0, -9.0]))
  242:     ufunc(arr, out=out)
  243:     tm.assert_extension_array_equal(out, expected)
  244: 
  245: 
  246: def test_ufunc():
  247:     arr = NumpyExtensionArray(np.array([-1.0, 0.0, 1.0]))
  248: 
  249:     r1, r2 = np.divmod(arr, np.add(arr, 2))
  250:     e1, e2 = np.divmod(arr._ndarray, np.add(arr._ndarray, 2))
  251:     e1 = NumpyExtensionArray(e1)
  252:     e2 = NumpyExtensionArray(e2)
  253:     tm.assert_extension_array_equal(r1, e1)
  254:     tm.assert_extension_array_equal(r2, e2)
  255: 
  256: 
  257: def test_basic_binop():
  258:     # Just a basic smoke test. The EA interface tests exercise this
  259:     # more thoroughly.
  260:     x = NumpyExtensionArray(np.array([1, 2, 3]))
  261:     result = x + x
  262:     expected = NumpyExtensionArray(np.array([2, 4, 6]))
  263:     tm.assert_extension_array_equal(result, expected)
  264: 
  265: 
  266: @pytest.mark.parametrize("dtype", [None, object])
  267: def test_setitem_object_typecode(dtype):
  268:     arr = NumpyExtensionArray(np.array(["a", "b", "c"], dtype=dtype))
  269:     arr[0] = "t"
  270:     expected = NumpyExtensionArray(np.array(["t", "b", "c"], dtype=dtype))
  271:     tm.assert_extension_array_equal(arr, expected)
  272: 
  273: 
  274: def test_setitem_no_coercion():
  275:     # https://github.com/pandas-dev/pandas/issues/28150
  276:     arr = NumpyExtensionArray(np.array([1, 2, 3]))
  277:     with pytest.raises(ValueError, match="int"):
  278:         arr[0] = "a"
  279: 
  280:     # With a value that we do coerce, check that we coerce the value
  281:     #  and not the underlying array.
  282:     arr[0] = 2.5
  283:     assert isinstance(arr[0], (int, np.integer)), type(arr[0])
  284: 
  285: 
  286: def test_setitem_preserves_views():
  287:     # GH#28150, see also extension test of the same name
  288:     arr = NumpyExtensionArray(np.array([1, 2, 3]))
  289:     view1 = arr.view()
  290:     view2 = arr[:]
  291:     view3 = np.asarray(arr)
  292: 
  293:     arr[0] = 9
  294:     assert view1[0] == 9
  295:     assert view2[0] == 9
  296:     assert view3[0] == 9
  297: 
  298:     arr[-1] = 2.5
  299:     view1[-1] = 5
  300:     assert arr[-1] == 5
  301: 
  302: 
  303: @pytest.mark.parametrize("dtype", [np.int64, np.uint64])
  304: def test_quantile_empty(dtype):
  305:     # we should get back np.nans, not -1s
  306:     arr = NumpyExtensionArray(np.array([], dtype=dtype))
  307:     idx = pd.Index([0.0, 0.5])
  308: 
  309:     result = arr._quantile(idx, interpolation="linear")
  310:     expected = NumpyExtensionArray(np.array([np.nan, np.nan]))
  311:     tm.assert_extension_array_equal(result, expected)
  312: 
  313: 
  314: def test_factorize_unsigned():
  315:     # don't raise when calling factorize on unsigned int NumpyExtensionArray
  316:     arr = np.array([1, 2, 3], dtype=np.uint64)
  317:     obj = NumpyExtensionArray(arr)
  318: 
  319:     res_codes, res_unique = obj.factorize()
  320:     exp_codes, exp_unique = pd.factorize(arr)
  321: 
  322:     tm.assert_numpy_array_equal(res_codes, exp_codes)
  323: 
  324:     tm.assert_extension_array_equal(res_unique, NumpyExtensionArray(exp_unique))
