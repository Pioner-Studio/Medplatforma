    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import Categorical
    5: import pandas._testing as tm
    6: 
    7: 
    8: @pytest.fixture(params=[True, False])
    9: def allow_fill(request):
   10:     """Boolean 'allow_fill' parameter for Categorical.take"""
   11:     return request.param
   12: 
   13: 
   14: class TestTake:
   15:     # https://github.com/pandas-dev/pandas/issues/20664
   16: 
   17:     def test_take_default_allow_fill(self):
   18:         cat = Categorical(["a", "b"])
   19:         with tm.assert_produces_warning(None):
   20:             result = cat.take([0, -1])
   21: 
   22:         assert result.equals(cat)
   23: 
   24:     def test_take_positive_no_warning(self):
   25:         cat = Categorical(["a", "b"])
   26:         with tm.assert_produces_warning(None):
   27:             cat.take([0, 0])
   28: 
   29:     def test_take_bounds(self, allow_fill):
   30:         # https://github.com/pandas-dev/pandas/issues/20664
   31:         cat = Categorical(["a", "b", "a"])
   32:         if allow_fill:
   33:             msg = "indices are out-of-bounds"
   34:         else:
   35:             msg = "index 4 is out of bounds for( axis 0 with)? size 3"
   36:         with pytest.raises(IndexError, match=msg):
   37:             cat.take([4, 5], allow_fill=allow_fill)
   38: 
   39:     def test_take_empty(self, allow_fill):
   40:         # https://github.com/pandas-dev/pandas/issues/20664
   41:         cat = Categorical([], categories=["a", "b"])
   42:         if allow_fill:
   43:             msg = "indices are out-of-bounds"
   44:         else:
   45:             msg = "cannot do a non-empty take from an empty axes"
   46:         with pytest.raises(IndexError, match=msg):
   47:             cat.take([0], allow_fill=allow_fill)
   48: 
   49:     def test_positional_take(self, ordered):
   50:         cat = Categorical(["a", "a", "b", "b"], categories=["b", "a"], ordered=ordered)
   51:         result = cat.take([0, 1, 2], allow_fill=False)
   52:         expected = Categorical(
   53:             ["a", "a", "b"], categories=cat.categories, ordered=ordered
   54:         )
   55:         tm.assert_categorical_equal(result, expected)
   56: 
   57:     def test_positional_take_unobserved(self, ordered):
   58:         cat = Categorical(["a", "b"], categories=["a", "b", "c"], ordered=ordered)
   59:         result = cat.take([1, 0], allow_fill=False)
   60:         expected = Categorical(["b", "a"], categories=cat.categories, ordered=ordered)
   61:         tm.assert_categorical_equal(result, expected)
   62: 
   63:     def test_take_allow_fill(self):
   64:         # https://github.com/pandas-dev/pandas/issues/23296
   65:         cat = Categorical(["a", "a", "b"])
   66:         result = cat.take([0, -1, -1], allow_fill=True)
   67:         expected = Categorical(["a", np.nan, np.nan], categories=["a", "b"])
   68:         tm.assert_categorical_equal(result, expected)
   69: 
   70:     def test_take_fill_with_negative_one(self):
   71:         # -1 was a category
   72:         cat = Categorical([-1, 0, 1])
   73:         result = cat.take([0, -1, 1], allow_fill=True, fill_value=-1)
   74:         expected = Categorical([-1, -1, 0], categories=[-1, 0, 1])
   75:         tm.assert_categorical_equal(result, expected)
   76: 
   77:     def test_take_fill_value(self):
   78:         # https://github.com/pandas-dev/pandas/issues/23296
   79:         cat = Categorical(["a", "b", "c"])
   80:         result = cat.take([0, 1, -1], fill_value="a", allow_fill=True)
   81:         expected = Categorical(["a", "b", "a"], categories=["a", "b", "c"])
   82:         tm.assert_categorical_equal(result, expected)
   83: 
   84:     def test_take_fill_value_new_raises(self):
   85:         # https://github.com/pandas-dev/pandas/issues/23296
   86:         cat = Categorical(["a", "b", "c"])
   87:         xpr = r"Cannot setitem on a Categorical with a new category \(d\)"
   88:         with pytest.raises(TypeError, match=xpr):
   89:             cat.take([0, 1, -1], fill_value="d", allow_fill=True)
