    1: """
    2: Tests for statistical reductions of 2nd moment or higher: var, skew, kurt, ...
    3: """
    4: import inspect
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: import pandas as pd
   10: from pandas import (
   11:     DataFrame,
   12:     Series,
   13:     date_range,
   14: )
   15: import pandas._testing as tm
   16: 
   17: 
   18: class TestDatetimeLikeStatReductions:
   19:     @pytest.mark.parametrize("box", [Series, pd.Index, pd.array])
   20:     def test_dt64_mean(self, tz_naive_fixture, box):
   21:         tz = tz_naive_fixture
   22: 
   23:         dti = date_range("2001-01-01", periods=11, tz=tz)
   24:         # shuffle so that we are not just working with monotone-increasing
   25:         dti = dti.take([4, 1, 3, 10, 9, 7, 8, 5, 0, 2, 6])
   26:         dtarr = dti._data
   27: 
   28:         obj = box(dtarr)
   29:         assert obj.mean() == pd.Timestamp("2001-01-06", tz=tz)
   30:         assert obj.mean(skipna=False) == pd.Timestamp("2001-01-06", tz=tz)
   31: 
   32:         # dtarr[-2] will be the first date 2001-01-1
   33:         dtarr[-2] = pd.NaT
   34: 
   35:         obj = box(dtarr)
   36:         assert obj.mean() == pd.Timestamp("2001-01-06 07:12:00", tz=tz)
   37:         assert obj.mean(skipna=False) is pd.NaT
   38: 
   39:     @pytest.mark.parametrize("box", [Series, pd.Index, pd.array])
   40:     @pytest.mark.parametrize("freq", ["s", "h", "D", "W", "B"])
   41:     def test_period_mean(self, box, freq):
   42:         # GH#24757
   43:         dti = date_range("2001-01-01", periods=11)
   44:         # shuffle so that we are not just working with monotone-increasing
   45:         dti = dti.take([4, 1, 3, 10, 9, 7, 8, 5, 0, 2, 6])
   46: 
   47:         warn = FutureWarning if freq == "B" else None
   48:         msg = r"PeriodDtype\[B\] is deprecated"
   49:         with tm.assert_produces_warning(warn, match=msg):
   50:             parr = dti._data.to_period(freq)
   51:         obj = box(parr)
   52:         with pytest.raises(TypeError, match="ambiguous"):
   53:             obj.mean()
   54:         with pytest.raises(TypeError, match="ambiguous"):
   55:             obj.mean(skipna=True)
   56: 
   57:         # parr[-2] will be the first date 2001-01-1
   58:         parr[-2] = pd.NaT
   59: 
   60:         with pytest.raises(TypeError, match="ambiguous"):
   61:             obj.mean()
   62:         with pytest.raises(TypeError, match="ambiguous"):
   63:             obj.mean(skipna=True)
   64: 
   65:     @pytest.mark.parametrize("box", [Series, pd.Index, pd.array])
   66:     def test_td64_mean(self, box):
   67:         m8values = np.array([0, 3, -2, -7, 1, 2, -1, 3, 5, -2, 4], "m8[D]")
   68:         tdi = pd.TimedeltaIndex(m8values).as_unit("ns")
   69: 
   70:         tdarr = tdi._data
   71:         obj = box(tdarr, copy=False)
   72: 
   73:         result = obj.mean()
   74:         expected = np.array(tdarr).mean()
   75:         assert result == expected
   76: 
   77:         tdarr[0] = pd.NaT
   78:         assert obj.mean(skipna=False) is pd.NaT
   79: 
   80:         result2 = obj.mean(skipna=True)
   81:         assert result2 == tdi[1:].mean()
   82: 
   83:         # exact equality fails by 1 nanosecond
   84:         assert result2.round("us") == (result * 11.0 / 10).round("us")
   85: 
   86: 
   87: class TestSeriesStatReductions:
   88:     # Note: the name TestSeriesStatReductions indicates these tests
   89:     #  were moved from a series-specific test file, _not_ that these tests are
   90:     #  intended long-term to be series-specific
   91: 
   92:     def _check_stat_op(
   93:         self, name, alternate, string_series_, check_objects=False, check_allna=False
   94:     ):
   95:         with pd.option_context("use_bottleneck", False):
   96:             f = getattr(Series, name)
   97: 
   98:             # add some NaNs
   99:             string_series_[5:15] = np.nan
  100: 
  101:             # mean, idxmax, idxmin, min, and max are valid for dates
  102:             if name not in ["max", "min", "mean", "median", "std"]:
  103:                 ds = Series(date_range("1/1/2001", periods=10))
  104:                 msg = f"does not support reduction '{name}'"
  105:                 with pytest.raises(TypeError, match=msg):
  106:                     f(ds)
  107: 
  108:             # skipna or no
  109:             assert pd.notna(f(string_series_))
  110:             assert pd.isna(f(string_series_, skipna=False))
  111: 
  112:             # check the result is correct
  113:             nona = string_series_.dropna()
  114:             tm.assert_almost_equal(f(nona), alternate(nona.values))
  115:             tm.assert_almost_equal(f(string_series_), alternate(nona.values))
  116: 
  117:             allna = string_series_ * np.nan
  118: 
  119:             if check_allna:
  120:                 assert np.isnan(f(allna))
  121: 
  122:             # dtype=object with None, it works!
  123:             s = Series([1, 2, 3, None, 5])
  124:             f(s)
  125: 
  126:             # GH#2888
  127:             items = [0]
  128:             items.extend(range(2**40, 2**40 + 1000))
  129:             s = Series(items, dtype="int64")
  130:             tm.assert_almost_equal(float(f(s)), float(alternate(s.values)))
  131: 
  132:             # check date range
  133:             if check_objects:
  134:                 s = Series(pd.bdate_range("1/1/2000", periods=10))
  135:                 res = f(s)
  136:                 exp = alternate(s)
  137:                 assert res == exp
  138: 
  139:             # check on string data
  140:             if name not in ["sum", "min", "max"]:
  141:                 with pytest.raises(TypeError, match=None):
  142:                     f(Series(list("abc")))
  143: 
  144:             # Invalid axis.
  145:             msg = "No axis named 1 for object type Series"
  146:             with pytest.raises(ValueError, match=msg):
  147:                 f(string_series_, axis=1)
  148: 
  149:             if "numeric_only" in inspect.getfullargspec(f).args:
  150:                 # only the index is string; dtype is float
  151:                 f(string_series_, numeric_only=True)
  152: 
  153:     def test_sum(self):
  154:         string_series = Series(range(20), dtype=np.float64, name="series")
  155:         self._check_stat_op("sum", np.sum, string_series, check_allna=False)
  156: 
  157:     def test_mean(self):
  158:         string_series = Series(range(20), dtype=np.float64, name="series")
  159:         self._check_stat_op("mean", np.mean, string_series)
  160: 
  161:     def test_median(self):
  162:         string_series = Series(range(20), dtype=np.float64, name="series")
  163:         self._check_stat_op("median", np.median, string_series)
  164: 
  165:         # test with integers, test failure
  166:         int_ts = Series(np.ones(10, dtype=int), index=range(10))
  167:         tm.assert_almost_equal(np.median(int_ts), int_ts.median())
  168: 
  169:     def test_prod(self):
  170:         string_series = Series(range(20), dtype=np.float64, name="series")
  171:         self._check_stat_op("prod", np.prod, string_series)
  172: 
  173:     def test_min(self):
  174:         string_series = Series(range(20), dtype=np.float64, name="series")
  175:         self._check_stat_op("min", np.min, string_series, check_objects=True)
  176: 
  177:     def test_max(self):
  178:         string_series = Series(range(20), dtype=np.float64, name="series")
  179:         self._check_stat_op("max", np.max, string_series, check_objects=True)
  180: 
  181:     def test_var_std(self):
  182:         string_series = Series(range(20), dtype=np.float64, name="series")
  183:         datetime_series = Series(
  184:             np.arange(10, dtype=np.float64),
  185:             index=date_range("2020-01-01", periods=10),
  186:             name="ts",
  187:         )
  188: 
  189:         alt = lambda x: np.std(x, ddof=1)
  190:         self._check_stat_op("std", alt, string_series)
  191: 
  192:         alt = lambda x: np.var(x, ddof=1)
  193:         self._check_stat_op("var", alt, string_series)
  194: 
  195:         result = datetime_series.std(ddof=4)
  196:         expected = np.std(datetime_series.values, ddof=4)
  197:         tm.assert_almost_equal(result, expected)
  198: 
  199:         result = datetime_series.var(ddof=4)
  200:         expected = np.var(datetime_series.values, ddof=4)
  201:         tm.assert_almost_equal(result, expected)
  202: 
  203:         # 1 - element series with ddof=1
  204:         s = datetime_series.iloc[[0]]
  205:         result = s.var(ddof=1)
  206:         assert pd.isna(result)
  207: 
  208:         result = s.std(ddof=1)
  209:         assert pd.isna(result)
  210: 
  211:     def test_sem(self):
  212:         string_series = Series(range(20), dtype=np.float64, name="series")
  213:         datetime_series = Series(
  214:             np.arange(10, dtype=np.float64),
  215:             index=date_range("2020-01-01", periods=10),
  216:             name="ts",
  217:         )
  218: 
  219:         alt = lambda x: np.std(x, ddof=1) / np.sqrt(len(x))
  220:         self._check_stat_op("sem", alt, string_series)
  221: 
  222:         result = datetime_series.sem(ddof=4)
  223:         expected = np.std(datetime_series.values, ddof=4) / np.sqrt(
  224:             len(datetime_series.values)
  225:         )
  226:         tm.assert_almost_equal(result, expected)
  227: 
  228:         # 1 - element series with ddof=1
  229:         s = datetime_series.iloc[[0]]
  230:         result = s.sem(ddof=1)
  231:         assert pd.isna(result)
  232: 
  233:     def test_skew(self):
  234:         sp_stats = pytest.importorskip("scipy.stats")
  235: 
  236:         string_series = Series(range(20), dtype=np.float64, name="series")
  237: 
  238:         alt = lambda x: sp_stats.skew(x, bias=False)
  239:         self._check_stat_op("skew", alt, string_series)
  240: 
  241:         # test corner cases, skew() returns NaN unless there's at least 3
  242:         # values
  243:         min_N = 3
  244:         for i in range(1, min_N + 1):
  245:             s = Series(np.ones(i))
  246:             df = DataFrame(np.ones((i, i)))
  247:             if i < min_N:
  248:                 assert np.isnan(s.skew())
  249:                 assert np.isnan(df.skew()).all()
  250:             else:
  251:                 assert 0 == s.skew()
  252:                 assert isinstance(s.skew(), np.float64)  # GH53482
  253:                 assert (df.skew() == 0).all()
  254: 
  255:     def test_kurt(self):
  256:         sp_stats = pytest.importorskip("scipy.stats")
  257: 
  258:         string_series = Series(range(20), dtype=np.float64, name="series")
  259: 
  260:         alt = lambda x: sp_stats.kurtosis(x, bias=False)
  261:         self._check_stat_op("kurt", alt, string_series)
  262: 
  263:     def test_kurt_corner(self):
  264:         # test corner cases, kurt() returns NaN unless there's at least 4
  265:         # values
  266:         min_N = 4
  267:         for i in range(1, min_N + 1):
  268:             s = Series(np.ones(i))
  269:             df = DataFrame(np.ones((i, i)))
  270:             if i < min_N:
  271:                 assert np.isnan(s.kurt())
  272:                 assert np.isnan(df.kurt()).all()
  273:             else:
  274:                 assert 0 == s.kurt()
  275:                 assert isinstance(s.kurt(), np.float64)  # GH53482
  276:                 assert (df.kurt() == 0).all()
