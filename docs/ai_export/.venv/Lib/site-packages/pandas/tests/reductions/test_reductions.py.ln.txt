    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: from decimal import Decimal
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: import pandas as pd
   11: from pandas import (
   12:     Categorical,
   13:     DataFrame,
   14:     DatetimeIndex,
   15:     Index,
   16:     NaT,
   17:     Period,
   18:     PeriodIndex,
   19:     RangeIndex,
   20:     Series,
   21:     Timedelta,
   22:     TimedeltaIndex,
   23:     Timestamp,
   24:     date_range,
   25:     isna,
   26:     period_range,
   27:     timedelta_range,
   28:     to_timedelta,
   29: )
   30: import pandas._testing as tm
   31: from pandas.core import nanops
   32: from pandas.core.arrays.string_arrow import ArrowStringArrayNumpySemantics
   33: 
   34: 
   35: def get_objs():
   36:     indexes = [
   37:         Index([True, False] * 5, name="a"),
   38:         Index(np.arange(10), dtype=np.int64, name="a"),
   39:         Index(np.arange(10), dtype=np.float64, name="a"),
   40:         DatetimeIndex(date_range("2020-01-01", periods=10), name="a"),
   41:         DatetimeIndex(date_range("2020-01-01", periods=10), name="a").tz_localize(
   42:             tz="US/Eastern"
   43:         ),
   44:         PeriodIndex(period_range("2020-01-01", periods=10, freq="D"), name="a"),
   45:         Index([str(i) for i in range(10)], name="a"),
   46:     ]
   47: 
   48:     arr = np.random.default_rng(2).standard_normal(10)
   49:     series = [Series(arr, index=idx, name="a") for idx in indexes]
   50: 
   51:     objs = indexes + series
   52:     return objs
   53: 
   54: 
   55: class TestReductions:
   56:     @pytest.mark.filterwarnings(
   57:         "ignore:Period with BDay freq is deprecated:FutureWarning"
   58:     )
   59:     @pytest.mark.parametrize("opname", ["max", "min"])
   60:     @pytest.mark.parametrize("obj", get_objs())
   61:     def test_ops(self, opname, obj):
   62:         result = getattr(obj, opname)()
   63:         if not isinstance(obj, PeriodIndex):
   64:             if isinstance(obj.values, ArrowStringArrayNumpySemantics):
   65:                 # max not on the interface
   66:                 expected = getattr(np.array(obj.values), opname)()
   67:             else:
   68:                 expected = getattr(obj.values, opname)()
   69:         else:
   70:             expected = Period(ordinal=getattr(obj.asi8, opname)(), freq=obj.freq)
   71: 
   72:         if getattr(obj, "tz", None) is not None:
   73:             # We need to de-localize before comparing to the numpy-produced result
   74:             expected = expected.astype("M8[ns]").astype("int64")
   75:             assert result._value == expected
   76:         else:
   77:             assert result == expected
   78: 
   79:     @pytest.mark.parametrize("opname", ["max", "min"])
   80:     @pytest.mark.parametrize(
   81:         "dtype, val",
   82:         [
   83:             ("object", 2.0),
   84:             ("float64", 2.0),
   85:             ("datetime64[ns]", datetime(2011, 11, 1)),
   86:             ("Int64", 2),
   87:             ("boolean", True),
   88:         ],
   89:     )
   90:     def test_nanminmax(self, opname, dtype, val, index_or_series):
   91:         # GH#7261
   92:         klass = index_or_series
   93: 
   94:         def check_missing(res):
   95:             if dtype == "datetime64[ns]":
   96:                 return res is NaT
   97:             elif dtype in ["Int64", "boolean"]:
   98:                 return res is pd.NA
   99:             else:
  100:                 return isna(res)
  101: 
  102:         obj = klass([None], dtype=dtype)
  103:         assert check_missing(getattr(obj, opname)())
  104:         assert check_missing(getattr(obj, opname)(skipna=False))
  105: 
  106:         obj = klass([], dtype=dtype)
  107:         assert check_missing(getattr(obj, opname)())
  108:         assert check_missing(getattr(obj, opname)(skipna=False))
  109: 
  110:         if dtype == "object":
  111:             # generic test with object only works for empty / all NaN
  112:             return
  113: 
  114:         obj = klass([None, val], dtype=dtype)
  115:         assert getattr(obj, opname)() == val
  116:         assert check_missing(getattr(obj, opname)(skipna=False))
  117: 
  118:         obj = klass([None, val, None], dtype=dtype)
  119:         assert getattr(obj, opname)() == val
  120:         assert check_missing(getattr(obj, opname)(skipna=False))
  121: 
  122:     @pytest.mark.parametrize("opname", ["max", "min"])
  123:     def test_nanargminmax(self, opname, index_or_series):
  124:         # GH#7261
  125:         klass = index_or_series
  126:         arg_op = "arg" + opname if klass is Index else "idx" + opname
  127: 
  128:         obj = klass([NaT, datetime(2011, 11, 1)])
  129:         assert getattr(obj, arg_op)() == 1
  130: 
  131:         msg = (
  132:             "The behavior of (DatetimeIndex|Series).argmax/argmin with "
  133:             "skipna=False and NAs"
  134:         )
  135:         if klass is Series:
  136:             msg = "The behavior of Series.(idxmax|idxmin) with all-NA"
  137:         with tm.assert_produces_warning(FutureWarning, match=msg):
  138:             result = getattr(obj, arg_op)(skipna=False)
  139:         if klass is Series:
  140:             assert np.isnan(result)
  141:         else:
  142:             assert result == -1
  143: 
  144:         obj = klass([NaT, datetime(2011, 11, 1), NaT])
  145:         # check DatetimeIndex non-monotonic path
  146:         assert getattr(obj, arg_op)() == 1
  147:         with tm.assert_produces_warning(FutureWarning, match=msg):
  148:             result = getattr(obj, arg_op)(skipna=False)
  149:         if klass is Series:
  150:             assert np.isnan(result)
  151:         else:
  152:             assert result == -1
  153: 
  154:     @pytest.mark.parametrize("opname", ["max", "min"])
  155:     @pytest.mark.parametrize("dtype", ["M8[ns]", "datetime64[ns, UTC]"])
  156:     def test_nanops_empty_object(self, opname, index_or_series, dtype):
  157:         klass = index_or_series
  158:         arg_op = "arg" + opname if klass is Index else "idx" + opname
  159: 
  160:         obj = klass([], dtype=dtype)
  161: 
  162:         assert getattr(obj, opname)() is NaT
  163:         assert getattr(obj, opname)(skipna=False) is NaT
  164: 
  165:         with pytest.raises(ValueError, match="empty sequence"):
  166:             getattr(obj, arg_op)()
  167:         with pytest.raises(ValueError, match="empty sequence"):
  168:             getattr(obj, arg_op)(skipna=False)
  169: 
  170:     def test_argminmax(self):
  171:         obj = Index(np.arange(5, dtype="int64"))
  172:         assert obj.argmin() == 0
  173:         assert obj.argmax() == 4
  174: 
  175:         obj = Index([np.nan, 1, np.nan, 2])
  176:         assert obj.argmin() == 1
  177:         assert obj.argmax() == 3
  178:         msg = "The behavior of Index.argmax/argmin with skipna=False and NAs"
  179:         with tm.assert_produces_warning(FutureWarning, match=msg):
  180:             assert obj.argmin(skipna=False) == -1
  181:         with tm.assert_produces_warning(FutureWarning, match=msg):
  182:             assert obj.argmax(skipna=False) == -1
  183: 
  184:         obj = Index([np.nan])
  185:         with tm.assert_produces_warning(FutureWarning, match=msg):
  186:             assert obj.argmin() == -1
  187:         with tm.assert_produces_warning(FutureWarning, match=msg):
  188:             assert obj.argmax() == -1
  189:         with tm.assert_produces_warning(FutureWarning, match=msg):
  190:             assert obj.argmin(skipna=False) == -1
  191:         with tm.assert_produces_warning(FutureWarning, match=msg):
  192:             assert obj.argmax(skipna=False) == -1
  193: 
  194:         msg = "The behavior of DatetimeIndex.argmax/argmin with skipna=False and NAs"
  195:         obj = Index([NaT, datetime(2011, 11, 1), datetime(2011, 11, 2), NaT])
  196:         assert obj.argmin() == 1
  197:         assert obj.argmax() == 2
  198:         with tm.assert_produces_warning(FutureWarning, match=msg):
  199:             assert obj.argmin(skipna=False) == -1
  200:         with tm.assert_produces_warning(FutureWarning, match=msg):
  201:             assert obj.argmax(skipna=False) == -1
  202: 
  203:         obj = Index([NaT])
  204:         with tm.assert_produces_warning(FutureWarning, match=msg):
  205:             assert obj.argmin() == -1
  206:         with tm.assert_produces_warning(FutureWarning, match=msg):
  207:             assert obj.argmax() == -1
  208:         with tm.assert_produces_warning(FutureWarning, match=msg):
  209:             assert obj.argmin(skipna=False) == -1
  210:         with tm.assert_produces_warning(FutureWarning, match=msg):
  211:             assert obj.argmax(skipna=False) == -1
  212: 
  213:     @pytest.mark.parametrize("op, expected_col", [["max", "a"], ["min", "b"]])
  214:     def test_same_tz_min_max_axis_1(self, op, expected_col):
  215:         # GH 10390
  216:         df = DataFrame(
  217:             date_range("2016-01-01 00:00:00", periods=3, tz="UTC"), columns=["a"]
  218:         )
  219:         df["b"] = df.a.subtract(Timedelta(seconds=3600))
  220:         result = getattr(df, op)(axis=1)
  221:         expected = df[expected_col].rename(None)
  222:         tm.assert_series_equal(result, expected)
  223: 
  224:     @pytest.mark.parametrize("func", ["maximum", "minimum"])
  225:     def test_numpy_reduction_with_tz_aware_dtype(self, tz_aware_fixture, func):
  226:         # GH 15552
  227:         tz = tz_aware_fixture
  228:         arg = pd.to_datetime(["2019"]).tz_localize(tz)
  229:         expected = Series(arg)
  230:         result = getattr(np, func)(expected, expected)
  231:         tm.assert_series_equal(result, expected)
  232: 
  233:     def test_nan_int_timedelta_sum(self):
  234:         # GH 27185
  235:         df = DataFrame(
  236:             {
  237:                 "A": Series([1, 2, NaT], dtype="timedelta64[ns]"),
  238:                 "B": Series([1, 2, np.nan], dtype="Int64"),
  239:             }
  240:         )
  241:         expected = Series({"A": Timedelta(3), "B": 3})
  242:         result = df.sum()
  243:         tm.assert_series_equal(result, expected)
  244: 
  245: 
  246: class TestIndexReductions:
  247:     # Note: the name TestIndexReductions indicates these tests
  248:     #  were moved from a Index-specific test file, _not_ that these tests are
  249:     #  intended long-term to be Index-specific
  250: 
  251:     @pytest.mark.parametrize(
  252:         "start,stop,step",
  253:         [
  254:             (0, 400, 3),
  255:             (500, 0, -6),
  256:             (-(10**6), 10**6, 4),
  257:             (10**6, -(10**6), -4),
  258:             (0, 10, 20),
  259:         ],
  260:     )
  261:     def test_max_min_range(self, start, stop, step):
  262:         # GH#17607
  263:         idx = RangeIndex(start, stop, step)
  264:         expected = idx._values.max()
  265:         result = idx.max()
  266:         assert result == expected
  267: 
  268:         # skipna should be irrelevant since RangeIndex should never have NAs
  269:         result2 = idx.max(skipna=False)
  270:         assert result2 == expected
  271: 
  272:         expected = idx._values.min()
  273:         result = idx.min()
  274:         assert result == expected
  275: 
  276:         # skipna should be irrelevant since RangeIndex should never have NAs
  277:         result2 = idx.min(skipna=False)
  278:         assert result2 == expected
  279: 
  280:         # empty
  281:         idx = RangeIndex(start, stop, -step)
  282:         assert isna(idx.max())
  283:         assert isna(idx.min())
  284: 
  285:     def test_minmax_timedelta64(self):
  286:         # monotonic
  287:         idx1 = TimedeltaIndex(["1 days", "2 days", "3 days"])
  288:         assert idx1.is_monotonic_increasing
  289: 
  290:         # non-monotonic
  291:         idx2 = TimedeltaIndex(["1 days", np.nan, "3 days", "NaT"])
  292:         assert not idx2.is_monotonic_increasing
  293: 
  294:         for idx in [idx1, idx2]:
  295:             assert idx.min() == Timedelta("1 days")
  296:             assert idx.max() == Timedelta("3 days")
  297:             assert idx.argmin() == 0
  298:             assert idx.argmax() == 2
  299: 
  300:     @pytest.mark.parametrize("op", ["min", "max"])
  301:     def test_minmax_timedelta_empty_or_na(self, op):
  302:         # Return NaT
  303:         obj = TimedeltaIndex([])
  304:         assert getattr(obj, op)() is NaT
  305: 
  306:         obj = TimedeltaIndex([NaT])
  307:         assert getattr(obj, op)() is NaT
  308: 
  309:         obj = TimedeltaIndex([NaT, NaT, NaT])
  310:         assert getattr(obj, op)() is NaT
  311: 
  312:     def test_numpy_minmax_timedelta64(self):
  313:         td = timedelta_range("16815 days", "16820 days", freq="D")
  314: 
  315:         assert np.min(td) == Timedelta("16815 days")
  316:         assert np.max(td) == Timedelta("16820 days")
  317: 
  318:         errmsg = "the 'out' parameter is not supported"
  319:         with pytest.raises(ValueError, match=errmsg):
  320:             np.min(td, out=0)
  321:         with pytest.raises(ValueError, match=errmsg):
  322:             np.max(td, out=0)
  323: 
  324:         assert np.argmin(td) == 0
  325:         assert np.argmax(td) == 5
  326: 
  327:         errmsg = "the 'out' parameter is not supported"
  328:         with pytest.raises(ValueError, match=errmsg):
  329:             np.argmin(td, out=0)
  330:         with pytest.raises(ValueError, match=errmsg):
  331:             np.argmax(td, out=0)
  332: 
  333:     def test_timedelta_ops(self):
  334:         # GH#4984
  335:         # make sure ops return Timedelta
  336:         s = Series(
  337:             [Timestamp("20130101") + timedelta(seconds=i * i) for i in range(10)]
  338:         )
  339:         td = s.diff()
  340: 
  341:         result = td.mean()
  342:         expected = to_timedelta(timedelta(seconds=9))
  343:         assert result == expected
  344: 
  345:         result = td.to_frame().mean()
  346:         assert result[0] == expected
  347: 
  348:         result = td.quantile(0.1)
  349:         expected = Timedelta(np.timedelta64(2600, "ms"))
  350:         assert result == expected
  351: 
  352:         result = td.median()
  353:         expected = to_timedelta("00:00:09")
  354:         assert result == expected
  355: 
  356:         result = td.to_frame().median()
  357:         assert result[0] == expected
  358: 
  359:         # GH#6462
  360:         # consistency in returned values for sum
  361:         result = td.sum()
  362:         expected = to_timedelta("00:01:21")
  363:         assert result == expected
  364: 
  365:         result = td.to_frame().sum()
  366:         assert result[0] == expected
  367: 
  368:         # std
  369:         result = td.std()
  370:         expected = to_timedelta(Series(td.dropna().values).std())
  371:         assert result == expected
  372: 
  373:         result = td.to_frame().std()
  374:         assert result[0] == expected
  375: 
  376:         # GH#10040
  377:         # make sure NaT is properly handled by median()
  378:         s = Series([Timestamp("2015-02-03"), Timestamp("2015-02-07")])
  379:         assert s.diff().median() == timedelta(days=4)
  380: 
  381:         s = Series(
  382:             [Timestamp("2015-02-03"), Timestamp("2015-02-07"), Timestamp("2015-02-15")]
  383:         )
  384:         assert s.diff().median() == timedelta(days=6)
  385: 
  386:     @pytest.mark.parametrize("opname", ["skew", "kurt", "sem", "prod", "var"])
  387:     def test_invalid_td64_reductions(self, opname):
  388:         s = Series(
  389:             [Timestamp("20130101") + timedelta(seconds=i * i) for i in range(10)]
  390:         )
  391:         td = s.diff()
  392: 
  393:         msg = "|".join(
  394:             [
  395:                 f"reduction operation '{opname}' not allowed for this dtype",
  396:                 rf"cannot perform {opname} with type timedelta64\[ns\]",
  397:                 f"does not support reduction '{opname}'",
  398:             ]
  399:         )
  400: 
  401:         with pytest.raises(TypeError, match=msg):
  402:             getattr(td, opname)()
  403: 
  404:         with pytest.raises(TypeError, match=msg):
  405:             getattr(td.to_frame(), opname)(numeric_only=False)
  406: 
  407:     def test_minmax_tz(self, tz_naive_fixture):
  408:         tz = tz_naive_fixture
  409:         # monotonic
  410:         idx1 = DatetimeIndex(["2011-01-01", "2011-01-02", "2011-01-03"], tz=tz)
  411:         assert idx1.is_monotonic_increasing
  412: 
  413:         # non-monotonic
  414:         idx2 = DatetimeIndex(
  415:             ["2011-01-01", NaT, "2011-01-03", "2011-01-02", NaT], tz=tz
  416:         )
  417:         assert not idx2.is_monotonic_increasing
  418: 
  419:         for idx in [idx1, idx2]:
  420:             assert idx.min() == Timestamp("2011-01-01", tz=tz)
  421:             assert idx.max() == Timestamp("2011-01-03", tz=tz)
  422:             assert idx.argmin() == 0
  423:             assert idx.argmax() == 2
  424: 
  425:     @pytest.mark.parametrize("op", ["min", "max"])
  426:     def test_minmax_nat_datetime64(self, op):
  427:         # Return NaT
  428:         obj = DatetimeIndex([])
  429:         assert isna(getattr(obj, op)())
  430: 
  431:         obj = DatetimeIndex([NaT])
  432:         assert isna(getattr(obj, op)())
  433: 
  434:         obj = DatetimeIndex([NaT, NaT, NaT])
  435:         assert isna(getattr(obj, op)())
  436: 
  437:     def test_numpy_minmax_integer(self):
  438:         # GH#26125
  439:         idx = Index([1, 2, 3])
  440: 
  441:         expected = idx.values.max()
  442:         result = np.max(idx)
  443:         assert result == expected
  444: 
  445:         expected = idx.values.min()
  446:         result = np.min(idx)
  447:         assert result == expected
  448: 
  449:         errmsg = "the 'out' parameter is not supported"
  450:         with pytest.raises(ValueError, match=errmsg):
  451:             np.min(idx, out=0)
  452:         with pytest.raises(ValueError, match=errmsg):
  453:             np.max(idx, out=0)
  454: 
  455:         expected = idx.values.argmax()
  456:         result = np.argmax(idx)
  457:         assert result == expected
  458: 
  459:         expected = idx.values.argmin()
  460:         result = np.argmin(idx)
  461:         assert result == expected
  462: 
  463:         errmsg = "the 'out' parameter is not supported"
  464:         with pytest.raises(ValueError, match=errmsg):
  465:             np.argmin(idx, out=0)
  466:         with pytest.raises(ValueError, match=errmsg):
  467:             np.argmax(idx, out=0)
  468: 
  469:     def test_numpy_minmax_range(self):
  470:         # GH#26125
  471:         idx = RangeIndex(0, 10, 3)
  472: 
  473:         result = np.max(idx)
  474:         assert result == 9
  475: 
  476:         result = np.min(idx)
  477:         assert result == 0
  478: 
  479:         errmsg = "the 'out' parameter is not supported"
  480:         with pytest.raises(ValueError, match=errmsg):
  481:             np.min(idx, out=0)
  482:         with pytest.raises(ValueError, match=errmsg):
  483:             np.max(idx, out=0)
  484: 
  485:         # No need to test again argmax/argmin compat since the implementation
  486:         # is the same as basic integer index
  487: 
  488:     def test_numpy_minmax_datetime64(self):
  489:         dr = date_range(start="2016-01-15", end="2016-01-20")
  490: 
  491:         assert np.min(dr) == Timestamp("2016-01-15 00:00:00")
  492:         assert np.max(dr) == Timestamp("2016-01-20 00:00:00")
  493: 
  494:         errmsg = "the 'out' parameter is not supported"
  495:         with pytest.raises(ValueError, match=errmsg):
  496:             np.min(dr, out=0)
  497: 
  498:         with pytest.raises(ValueError, match=errmsg):
  499:             np.max(dr, out=0)
  500: 
  501:         assert np.argmin(dr) == 0
  502:         assert np.argmax(dr) == 5
  503: 
  504:         errmsg = "the 'out' parameter is not supported"
  505:         with pytest.raises(ValueError, match=errmsg):
  506:             np.argmin(dr, out=0)
  507: 
  508:         with pytest.raises(ValueError, match=errmsg):
  509:             np.argmax(dr, out=0)
  510: 
  511:     def test_minmax_period(self):
  512:         # monotonic
  513:         idx1 = PeriodIndex([NaT, "2011-01-01", "2011-01-02", "2011-01-03"], freq="D")
  514:         assert not idx1.is_monotonic_increasing
  515:         assert idx1[1:].is_monotonic_increasing
  516: 
  517:         # non-monotonic
  518:         idx2 = PeriodIndex(
  519:             ["2011-01-01", NaT, "2011-01-03", "2011-01-02", NaT], freq="D"
  520:         )
  521:         assert not idx2.is_monotonic_increasing
  522: 
  523:         for idx in [idx1, idx2]:
  524:             assert idx.min() == Period("2011-01-01", freq="D")
  525:             assert idx.max() == Period("2011-01-03", freq="D")
  526:         assert idx1.argmin() == 1
  527:         assert idx2.argmin() == 0
  528:         assert idx1.argmax() == 3
  529:         assert idx2.argmax() == 2
  530: 
  531:     @pytest.mark.parametrize("op", ["min", "max"])
  532:     @pytest.mark.parametrize("data", [[], [NaT], [NaT, NaT, NaT]])
  533:     def test_minmax_period_empty_nat(self, op, data):
  534:         # Return NaT
  535:         obj = PeriodIndex(data, freq="M")
  536:         result = getattr(obj, op)()
  537:         assert result is NaT
  538: 
  539:     def test_numpy_minmax_period(self):
  540:         pr = period_range(start="2016-01-15", end="2016-01-20")
  541: 
  542:         assert np.min(pr) == Period("2016-01-15", freq="D")
  543:         assert np.max(pr) == Period("2016-01-20", freq="D")
  544: 
  545:         errmsg = "the 'out' parameter is not supported"
  546:         with pytest.raises(ValueError, match=errmsg):
  547:             np.min(pr, out=0)
  548:         with pytest.raises(ValueError, match=errmsg):
  549:             np.max(pr, out=0)
  550: 
  551:         assert np.argmin(pr) == 0
  552:         assert np.argmax(pr) == 5
  553: 
  554:         errmsg = "the 'out' parameter is not supported"
  555:         with pytest.raises(ValueError, match=errmsg):
  556:             np.argmin(pr, out=0)
  557:         with pytest.raises(ValueError, match=errmsg):
  558:             np.argmax(pr, out=0)
  559: 
  560:     def test_min_max_categorical(self):
  561:         ci = pd.CategoricalIndex(list("aabbca"), categories=list("cab"), ordered=False)
  562:         msg = (
  563:             r"Categorical is not ordered for operation min\n"
  564:             r"you can use .as_ordered\(\) to change the Categorical to an ordered one\n"
  565:         )
  566:         with pytest.raises(TypeError, match=msg):
  567:             ci.min()
  568:         msg = (
  569:             r"Categorical is not ordered for operation max\n"
  570:             r"you can use .as_ordered\(\) to change the Categorical to an ordered one\n"
  571:         )
  572:         with pytest.raises(TypeError, match=msg):
  573:             ci.max()
  574: 
  575:         ci = pd.CategoricalIndex(list("aabbca"), categories=list("cab"), ordered=True)
  576:         assert ci.min() == "c"
  577:         assert ci.max() == "b"
  578: 
  579: 
  580: class TestSeriesReductions:
  581:     # Note: the name TestSeriesReductions indicates these tests
  582:     #  were moved from a series-specific test file, _not_ that these tests are
  583:     #  intended long-term to be series-specific
  584: 
  585:     def test_sum_inf(self):
  586:         s = Series(np.random.default_rng(2).standard_normal(10))
  587:         s2 = s.copy()
  588: 
  589:         s[5:8] = np.inf
  590:         s2[5:8] = np.nan
  591: 
  592:         assert np.isinf(s.sum())
  593: 
  594:         arr = np.random.default_rng(2).standard_normal((100, 100)).astype("f4")
  595:         arr[:, 2] = np.inf
  596: 
  597:         msg = "use_inf_as_na option is deprecated"
  598:         with tm.assert_produces_warning(FutureWarning, match=msg):
  599:             with pd.option_context("mode.use_inf_as_na", True):
  600:                 tm.assert_almost_equal(s.sum(), s2.sum())
  601: 
  602:         res = nanops.nansum(arr, axis=1)
  603:         assert np.isinf(res).all()
  604: 
  605:     @pytest.mark.parametrize(
  606:         "dtype", ["float64", "Float32", "Int64", "boolean", "object"]
  607:     )
  608:     @pytest.mark.parametrize("use_bottleneck", [True, False])
  609:     @pytest.mark.parametrize("method, unit", [("sum", 0.0), ("prod", 1.0)])
  610:     def test_empty(self, method, unit, use_bottleneck, dtype):
  611:         with pd.option_context("use_bottleneck", use_bottleneck):
  612:             # GH#9422 / GH#18921
  613:             # Entirely empty
  614:             s = Series([], dtype=dtype)
  615:             # NA by default
  616:             result = getattr(s, method)()
  617:             assert result == unit
  618: 
  619:             # Explicit
  620:             result = getattr(s, method)(min_count=0)
  621:             assert result == unit
  622: 
  623:             result = getattr(s, method)(min_count=1)
  624:             assert isna(result)
  625: 
  626:             # Skipna, default
  627:             result = getattr(s, method)(skipna=True)
  628:             result == unit
  629: 
  630:             # Skipna, explicit
  631:             result = getattr(s, method)(skipna=True, min_count=0)
  632:             assert result == unit
  633: 
  634:             result = getattr(s, method)(skipna=True, min_count=1)
  635:             assert isna(result)
  636: 
  637:             result = getattr(s, method)(skipna=False, min_count=0)
  638:             assert result == unit
  639: 
  640:             result = getattr(s, method)(skipna=False, min_count=1)
  641:             assert isna(result)
  642: 
  643:             # All-NA
  644:             s = Series([np.nan], dtype=dtype)
  645:             # NA by default
  646:             result = getattr(s, method)()
  647:             assert result == unit
  648: 
  649:             # Explicit
  650:             result = getattr(s, method)(min_count=0)
  651:             assert result == unit
  652: 
  653:             result = getattr(s, method)(min_count=1)
  654:             assert isna(result)
  655: 
  656:             # Skipna, default
  657:             result = getattr(s, method)(skipna=True)
  658:             result == unit
  659: 
  660:             # skipna, explicit
  661:             result = getattr(s, method)(skipna=True, min_count=0)
  662:             assert result == unit
  663: 
  664:             result = getattr(s, method)(skipna=True, min_count=1)
  665:             assert isna(result)
  666: 
  667:             # Mix of valid, empty
  668:             s = Series([np.nan, 1], dtype=dtype)
  669:             # Default
  670:             result = getattr(s, method)()
  671:             assert result == 1.0
  672: 
  673:             # Explicit
  674:             result = getattr(s, method)(min_count=0)
  675:             assert result == 1.0
  676: 
  677:             result = getattr(s, method)(min_count=1)
  678:             assert result == 1.0
  679: 
  680:             # Skipna
  681:             result = getattr(s, method)(skipna=True)
  682:             assert result == 1.0
  683: 
  684:             result = getattr(s, method)(skipna=True, min_count=0)
  685:             assert result == 1.0
  686: 
  687:             # GH#844 (changed in GH#9422)
  688:             df = DataFrame(np.empty((10, 0)), dtype=dtype)
  689:             assert (getattr(df, method)(1) == unit).all()
  690: 
  691:             s = Series([1], dtype=dtype)
  692:             result = getattr(s, method)(min_count=2)
  693:             assert isna(result)
  694: 
  695:             result = getattr(s, method)(skipna=False, min_count=2)
  696:             assert isna(result)
  697: 
  698:             s = Series([np.nan], dtype=dtype)
  699:             result = getattr(s, method)(min_count=2)
  700:             assert isna(result)
  701: 
  702:             s = Series([np.nan, 1], dtype=dtype)
  703:             result = getattr(s, method)(min_count=2)
  704:             assert isna(result)
  705: 
  706:     @pytest.mark.parametrize("method", ["mean", "var"])
  707:     @pytest.mark.parametrize("dtype", ["Float64", "Int64", "boolean"])
  708:     def test_ops_consistency_on_empty_nullable(self, method, dtype):
  709:         # GH#34814
  710:         # consistency for nullable dtypes on empty or ALL-NA mean
  711: 
  712:         # empty series
  713:         eser = Series([], dtype=dtype)
  714:         result = getattr(eser, method)()
  715:         assert result is pd.NA
  716: 
  717:         # ALL-NA series
  718:         nser = Series([np.nan], dtype=dtype)
  719:         result = getattr(nser, method)()
  720:         assert result is pd.NA
  721: 
  722:     @pytest.mark.parametrize("method", ["mean", "median", "std", "var"])
  723:     def test_ops_consistency_on_empty(self, method):
  724:         # GH#7869
  725:         # consistency on empty
  726: 
  727:         # float
  728:         result = getattr(Series(dtype=float), method)()
  729:         assert isna(result)
  730: 
  731:         # timedelta64[ns]
  732:         tdser = Series([], dtype="m8[ns]")
  733:         if method == "var":
  734:             msg = "|".join(
  735:                 [
  736:                     "operation 'var' not allowed",
  737:                     r"cannot perform var with type timedelta64\[ns\]",
  738:                     "does not support reduction 'var'",
  739:                 ]
  740:             )
  741:             with pytest.raises(TypeError, match=msg):
  742:                 getattr(tdser, method)()
  743:         else:
  744:             result = getattr(tdser, method)()
  745:             assert result is NaT
  746: 
  747:     def test_nansum_buglet(self):
  748:         ser = Series([1.0, np.nan], index=[0, 1])
  749:         result = np.nansum(ser)
  750:         tm.assert_almost_equal(result, 1)
  751: 
  752:     @pytest.mark.parametrize("use_bottleneck", [True, False])
  753:     @pytest.mark.parametrize("dtype", ["int32", "int64"])
  754:     def test_sum_overflow_int(self, use_bottleneck, dtype):
  755:         with pd.option_context("use_bottleneck", use_bottleneck):
  756:             # GH#6915
  757:             # overflowing on the smaller int dtypes
  758:             v = np.arange(5000000, dtype=dtype)
  759:             s = Series(v)
  760: 
  761:             result = s.sum(skipna=False)
  762:             assert int(result) == v.sum(dtype="int64")
  763:             result = s.min(skipna=False)
  764:             assert int(result) == 0
  765:             result = s.max(skipna=False)
  766:             assert int(result) == v[-1]
  767: 
  768:     @pytest.mark.parametrize("use_bottleneck", [True, False])
  769:     @pytest.mark.parametrize("dtype", ["float32", "float64"])
  770:     def test_sum_overflow_float(self, use_bottleneck, dtype):
  771:         with pd.option_context("use_bottleneck", use_bottleneck):
  772:             v = np.arange(5000000, dtype=dtype)
  773:             s = Series(v)
  774: 
  775:             result = s.sum(skipna=False)
  776:             assert result == v.sum(dtype=dtype)
  777:             result = s.min(skipna=False)
  778:             assert np.allclose(float(result), 0.0)
  779:             result = s.max(skipna=False)
  780:             assert np.allclose(float(result), v[-1])
  781: 
  782:     def test_mean_masked_overflow(self):
  783:         # GH#48378
  784:         val = 100_000_000_000_000_000
  785:         n_elements = 100
  786:         na = np.array([val] * n_elements)
  787:         ser = Series([val] * n_elements, dtype="Int64")
  788: 
  789:         result_numpy = np.mean(na)
  790:         result_masked = ser.mean()
  791:         assert result_masked - result_numpy == 0
  792:         assert result_masked == 1e17
  793: 
  794:     @pytest.mark.parametrize("ddof, exp", [(1, 2.5), (0, 2.0)])
  795:     def test_var_masked_array(self, ddof, exp):
  796:         # GH#48379
  797:         ser = Series([1, 2, 3, 4, 5], dtype="Int64")
  798:         ser_numpy_dtype = Series([1, 2, 3, 4, 5], dtype="int64")
  799:         result = ser.var(ddof=ddof)
  800:         result_numpy_dtype = ser_numpy_dtype.var(ddof=ddof)
  801:         assert result == result_numpy_dtype
  802:         assert result == exp
  803: 
  804:     @pytest.mark.parametrize("dtype", ("m8[ns]", "m8[ns]", "M8[ns]", "M8[ns, UTC]"))
  805:     @pytest.mark.parametrize("skipna", [True, False])
  806:     def test_empty_timeseries_reductions_return_nat(self, dtype, skipna):
  807:         # covers GH#11245
  808:         assert Series([], dtype=dtype).min(skipna=skipna) is NaT
  809:         assert Series([], dtype=dtype).max(skipna=skipna) is NaT
  810: 
  811:     def test_numpy_argmin(self):
  812:         # See GH#16830
  813:         data = np.arange(1, 11)
  814: 
  815:         s = Series(data, index=data)
  816:         result = np.argmin(s)
  817: 
  818:         expected = np.argmin(data)
  819:         assert result == expected
  820: 
  821:         result = s.argmin()
  822: 
  823:         assert result == expected
  824: 
  825:         msg = "the 'out' parameter is not supported"
  826:         with pytest.raises(ValueError, match=msg):
  827:             np.argmin(s, out=data)
  828: 
  829:     def test_numpy_argmax(self):
  830:         # See GH#16830
  831:         data = np.arange(1, 11)
  832: 
  833:         ser = Series(data, index=data)
  834:         result = np.argmax(ser)
  835:         expected = np.argmax(data)
  836:         assert result == expected
  837: 
  838:         result = ser.argmax()
  839: 
  840:         assert result == expected
  841: 
  842:         msg = "the 'out' parameter is not supported"
  843:         with pytest.raises(ValueError, match=msg):
  844:             np.argmax(ser, out=data)
  845: 
  846:     def test_idxmin_dt64index(self, unit):
  847:         # GH#43587 should have NaT instead of NaN
  848:         dti = DatetimeIndex(["NaT", "2015-02-08", "NaT"]).as_unit(unit)
  849:         ser = Series([1.0, 2.0, np.nan], index=dti)
  850:         msg = "The behavior of Series.idxmin with all-NA values"
  851:         with tm.assert_produces_warning(FutureWarning, match=msg):
  852:             res = ser.idxmin(skipna=False)
  853:         assert res is NaT
  854:         msg = "The behavior of Series.idxmax with all-NA values"
  855:         with tm.assert_produces_warning(FutureWarning, match=msg):
  856:             res = ser.idxmax(skipna=False)
  857:         assert res is NaT
  858: 
  859:         df = ser.to_frame()
  860:         msg = "The behavior of DataFrame.idxmin with all-NA values"
  861:         with tm.assert_produces_warning(FutureWarning, match=msg):
  862:             res = df.idxmin(skipna=False)
  863:         assert res.dtype == f"M8[{unit}]"
  864:         assert res.isna().all()
  865:         msg = "The behavior of DataFrame.idxmax with all-NA values"
  866:         with tm.assert_produces_warning(FutureWarning, match=msg):
  867:             res = df.idxmax(skipna=False)
  868:         assert res.dtype == f"M8[{unit}]"
  869:         assert res.isna().all()
  870: 
  871:     def test_idxmin(self):
  872:         # test idxmin
  873:         # _check_stat_op approach can not be used here because of isna check.
  874:         string_series = Series(range(20), dtype=np.float64, name="series")
  875: 
  876:         # add some NaNs
  877:         string_series[5:15] = np.nan
  878: 
  879:         # skipna or no
  880:         assert string_series[string_series.idxmin()] == string_series.min()
  881:         msg = "The behavior of Series.idxmin"
  882:         with tm.assert_produces_warning(FutureWarning, match=msg):
  883:             assert isna(string_series.idxmin(skipna=False))
  884: 
  885:         # no NaNs
  886:         nona = string_series.dropna()
  887:         assert nona[nona.idxmin()] == nona.min()
  888:         assert nona.index.values.tolist().index(nona.idxmin()) == nona.values.argmin()
  889: 
  890:         # all NaNs
  891:         allna = string_series * np.nan
  892:         with tm.assert_produces_warning(FutureWarning, match=msg):
  893:             assert isna(allna.idxmin())
  894: 
  895:         # datetime64[ns]
  896:         s = Series(date_range("20130102", periods=6))
  897:         result = s.idxmin()
  898:         assert result == 0
  899: 
  900:         s[0] = np.nan
  901:         result = s.idxmin()
  902:         assert result == 1
  903: 
  904:     def test_idxmax(self):
  905:         # test idxmax
  906:         # _check_stat_op approach can not be used here because of isna check.
  907:         string_series = Series(range(20), dtype=np.float64, name="series")
  908: 
  909:         # add some NaNs
  910:         string_series[5:15] = np.nan
  911: 
  912:         # skipna or no
  913:         assert string_series[string_series.idxmax()] == string_series.max()
  914:         msg = "The behavior of Series.idxmax with all-NA values"
  915:         with tm.assert_produces_warning(FutureWarning, match=msg):
  916:             assert isna(string_series.idxmax(skipna=False))
  917: 
  918:         # no NaNs
  919:         nona = string_series.dropna()
  920:         assert nona[nona.idxmax()] == nona.max()
  921:         assert nona.index.values.tolist().index(nona.idxmax()) == nona.values.argmax()
  922: 
  923:         # all NaNs
  924:         allna = string_series * np.nan
  925:         msg = "The behavior of Series.idxmax with all-NA values"
  926:         with tm.assert_produces_warning(FutureWarning, match=msg):
  927:             assert isna(allna.idxmax())
  928: 
  929:         s = Series(date_range("20130102", periods=6))
  930:         result = s.idxmax()
  931:         assert result == 5
  932: 
  933:         s[5] = np.nan
  934:         result = s.idxmax()
  935:         assert result == 4
  936: 
  937:         # Index with float64 dtype
  938:         # GH#5914
  939:         s = Series([1, 2, 3], [1.1, 2.1, 3.1])
  940:         result = s.idxmax()
  941:         assert result == 3.1
  942:         result = s.idxmin()
  943:         assert result == 1.1
  944: 
  945:         s = Series(s.index, s.index)
  946:         result = s.idxmax()
  947:         assert result == 3.1
  948:         result = s.idxmin()
  949:         assert result == 1.1
  950: 
  951:     def test_all_any(self):
  952:         ts = Series(
  953:             np.arange(10, dtype=np.float64),
  954:             index=date_range("2020-01-01", periods=10),
  955:             name="ts",
  956:         )
  957:         bool_series = ts > 0
  958:         assert not bool_series.all()
  959:         assert bool_series.any()
  960: 
  961:         # Alternative types, with implicit 'object' dtype.
  962:         s = Series(["abc", True])
  963:         assert s.any()
  964: 
  965:     def test_numpy_all_any(self, index_or_series):
  966:         # GH#40180
  967:         idx = index_or_series([0, 1, 2])
  968:         assert not np.all(idx)
  969:         assert np.any(idx)
  970:         idx = Index([1, 2, 3])
  971:         assert np.all(idx)
  972: 
  973:     def test_all_any_skipna(self):
  974:         # Check skipna, with implicit 'object' dtype.
  975:         s1 = Series([np.nan, True])
  976:         s2 = Series([np.nan, False])
  977:         assert s1.all(skipna=False)  # nan && True => True
  978:         assert s1.all(skipna=True)
  979:         assert s2.any(skipna=False)
  980:         assert not s2.any(skipna=True)
  981: 
  982:     def test_all_any_bool_only(self):
  983:         s = Series([False, False, True, True, False, True], index=[0, 0, 1, 1, 2, 2])
  984: 
  985:         # GH#47500 - test bool_only works
  986:         assert s.any(bool_only=True)
  987:         assert not s.all(bool_only=True)
  988: 
  989:     @pytest.mark.parametrize("bool_agg_func", ["any", "all"])
  990:     @pytest.mark.parametrize("skipna", [True, False])
  991:     def test_any_all_object_dtype(self, bool_agg_func, skipna):
  992:         # GH#12863
  993:         ser = Series(["a", "b", "c", "d", "e"], dtype=object)
  994:         result = getattr(ser, bool_agg_func)(skipna=skipna)
  995:         expected = True
  996: 
  997:         assert result == expected
  998: 
  999:     @pytest.mark.parametrize("bool_agg_func", ["any", "all"])
 1000:     @pytest.mark.parametrize(
 1001:         "data", [[False, None], [None, False], [False, np.nan], [np.nan, False]]
 1002:     )
 1003:     def test_any_all_object_dtype_missing(self, data, bool_agg_func):
 1004:         # GH#27709
 1005:         ser = Series(data)
 1006:         result = getattr(ser, bool_agg_func)(skipna=False)
 1007: 
 1008:         # None is treated is False, but np.nan is treated as True
 1009:         expected = bool_agg_func == "any" and None not in data
 1010:         assert result == expected
 1011: 
 1012:     @pytest.mark.parametrize("dtype", ["boolean", "Int64", "UInt64", "Float64"])
 1013:     @pytest.mark.parametrize("bool_agg_func", ["any", "all"])
 1014:     @pytest.mark.parametrize("skipna", [True, False])
 1015:     @pytest.mark.parametrize(
 1016:         # expected_data indexed as [[skipna=False/any, skipna=False/all],
 1017:         #                           [skipna=True/any, skipna=True/all]]
 1018:         "data,expected_data",
 1019:         [
 1020:             ([0, 0, 0], [[False, False], [False, False]]),
 1021:             ([1, 1, 1], [[True, True], [True, True]]),
 1022:             ([pd.NA, pd.NA, pd.NA], [[pd.NA, pd.NA], [False, True]]),
 1023:             ([0, pd.NA, 0], [[pd.NA, False], [False, False]]),
 1024:             ([1, pd.NA, 1], [[True, pd.NA], [True, True]]),
 1025:             ([1, pd.NA, 0], [[True, False], [True, False]]),
 1026:         ],
 1027:     )
 1028:     def test_any_all_nullable_kleene_logic(
 1029:         self, bool_agg_func, skipna, data, dtype, expected_data
 1030:     ):
 1031:         # GH-37506, GH-41967
 1032:         ser = Series(data, dtype=dtype)
 1033:         expected = expected_data[skipna][bool_agg_func == "all"]
 1034: 
 1035:         result = getattr(ser, bool_agg_func)(skipna=skipna)
 1036:         assert (result is pd.NA and expected is pd.NA) or result == expected
 1037: 
 1038:     def test_any_axis1_bool_only(self):
 1039:         # GH#32432
 1040:         df = DataFrame({"A": [True, False], "B": [1, 2]})
 1041:         result = df.any(axis=1, bool_only=True)
 1042:         expected = Series([True, False])
 1043:         tm.assert_series_equal(result, expected)
 1044: 
 1045:     def test_any_all_datetimelike(self):
 1046:         # GH#38723 these may not be the desired long-term behavior (GH#34479)
 1047:         #  but in the interim should be internally consistent
 1048:         dta = date_range("1995-01-02", periods=3)._data
 1049:         ser = Series(dta)
 1050:         df = DataFrame(ser)
 1051: 
 1052:         msg = "'(any|all)' with datetime64 dtypes is deprecated"
 1053:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1054:             # GH#34479
 1055:             assert dta.all()
 1056:             assert dta.any()
 1057: 
 1058:             assert ser.all()
 1059:             assert ser.any()
 1060: 
 1061:             assert df.any().all()
 1062:             assert df.all().all()
 1063: 
 1064:         dta = dta.tz_localize("UTC")
 1065:         ser = Series(dta)
 1066:         df = DataFrame(ser)
 1067: 
 1068:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1069:             # GH#34479
 1070:             assert dta.all()
 1071:             assert dta.any()
 1072: 
 1073:             assert ser.all()
 1074:             assert ser.any()
 1075: 
 1076:             assert df.any().all()
 1077:             assert df.all().all()
 1078: 
 1079:         tda = dta - dta[0]
 1080:         ser = Series(tda)
 1081:         df = DataFrame(ser)
 1082: 
 1083:         assert tda.any()
 1084:         assert not tda.all()
 1085: 
 1086:         assert ser.any()
 1087:         assert not ser.all()
 1088: 
 1089:         assert df.any().all()
 1090:         assert not df.all().any()
 1091: 
 1092:     def test_any_all_pyarrow_string(self):
 1093:         # GH#54591
 1094:         pytest.importorskip("pyarrow")
 1095:         ser = Series(["", "a"], dtype="string[pyarrow_numpy]")
 1096:         assert ser.any()
 1097:         assert not ser.all()
 1098: 
 1099:         ser = Series([None, "a"], dtype="string[pyarrow_numpy]")
 1100:         assert ser.any()
 1101:         assert ser.all()
 1102:         assert not ser.all(skipna=False)
 1103: 
 1104:         ser = Series([None, ""], dtype="string[pyarrow_numpy]")
 1105:         assert not ser.any()
 1106:         assert not ser.all()
 1107: 
 1108:         ser = Series(["a", "b"], dtype="string[pyarrow_numpy]")
 1109:         assert ser.any()
 1110:         assert ser.all()
 1111: 
 1112:     def test_timedelta64_analytics(self):
 1113:         # index min/max
 1114:         dti = date_range("2012-1-1", periods=3, freq="D")
 1115:         td = Series(dti) - Timestamp("20120101")
 1116: 
 1117:         result = td.idxmin()
 1118:         assert result == 0
 1119: 
 1120:         result = td.idxmax()
 1121:         assert result == 2
 1122: 
 1123:         # GH#2982
 1124:         # with NaT
 1125:         td[0] = np.nan
 1126: 
 1127:         result = td.idxmin()
 1128:         assert result == 1
 1129: 
 1130:         result = td.idxmax()
 1131:         assert result == 2
 1132: 
 1133:         # abs
 1134:         s1 = Series(date_range("20120101", periods=3))
 1135:         s2 = Series(date_range("20120102", periods=3))
 1136:         expected = Series(s2 - s1)
 1137: 
 1138:         result = np.abs(s1 - s2)
 1139:         tm.assert_series_equal(result, expected)
 1140: 
 1141:         result = (s1 - s2).abs()
 1142:         tm.assert_series_equal(result, expected)
 1143: 
 1144:         # max/min
 1145:         result = td.max()
 1146:         expected = Timedelta("2 days")
 1147:         assert result == expected
 1148: 
 1149:         result = td.min()
 1150:         expected = Timedelta("1 days")
 1151:         assert result == expected
 1152: 
 1153:     @pytest.mark.parametrize(
 1154:         "test_input,error_type",
 1155:         [
 1156:             (Series([], dtype="float64"), ValueError),
 1157:             # For strings, or any Series with dtype 'O'
 1158:             (Series(["foo", "bar", "baz"]), TypeError),
 1159:             (Series([(1,), (2,)]), TypeError),
 1160:             # For mixed data types
 1161:             (Series(["foo", "foo", "bar", "bar", None, np.nan, "baz"]), TypeError),
 1162:         ],
 1163:     )
 1164:     def test_assert_idxminmax_empty_raises(self, test_input, error_type):
 1165:         """
 1166:         Cases where ``Series.argmax`` and related should raise an exception
 1167:         """
 1168:         test_input = Series([], dtype="float64")
 1169:         msg = "attempt to get argmin of an empty sequence"
 1170:         with pytest.raises(ValueError, match=msg):
 1171:             test_input.idxmin()
 1172:         with pytest.raises(ValueError, match=msg):
 1173:             test_input.idxmin(skipna=False)
 1174:         msg = "attempt to get argmax of an empty sequence"
 1175:         with pytest.raises(ValueError, match=msg):
 1176:             test_input.idxmax()
 1177:         with pytest.raises(ValueError, match=msg):
 1178:             test_input.idxmax(skipna=False)
 1179: 
 1180:     def test_idxminmax_object_dtype(self, using_infer_string):
 1181:         # pre-2.1 object-dtype was disallowed for argmin/max
 1182:         ser = Series(["foo", "bar", "baz"])
 1183:         assert ser.idxmax() == 0
 1184:         assert ser.idxmax(skipna=False) == 0
 1185:         assert ser.idxmin() == 1
 1186:         assert ser.idxmin(skipna=False) == 1
 1187: 
 1188:         ser2 = Series([(1,), (2,)])
 1189:         assert ser2.idxmax() == 1
 1190:         assert ser2.idxmax(skipna=False) == 1
 1191:         assert ser2.idxmin() == 0
 1192:         assert ser2.idxmin(skipna=False) == 0
 1193: 
 1194:         if not using_infer_string:
 1195:             # attempting to compare np.nan with string raises
 1196:             ser3 = Series(["foo", "foo", "bar", "bar", None, np.nan, "baz"])
 1197:             msg = "'>' not supported between instances of 'float' and 'str'"
 1198:             with pytest.raises(TypeError, match=msg):
 1199:                 ser3.idxmax()
 1200:             with pytest.raises(TypeError, match=msg):
 1201:                 ser3.idxmax(skipna=False)
 1202:             msg = "'<' not supported between instances of 'float' and 'str'"
 1203:             with pytest.raises(TypeError, match=msg):
 1204:                 ser3.idxmin()
 1205:             with pytest.raises(TypeError, match=msg):
 1206:                 ser3.idxmin(skipna=False)
 1207: 
 1208:     def test_idxminmax_object_frame(self):
 1209:         # GH#4279
 1210:         df = DataFrame([["zimm", 2.5], ["biff", 1.0], ["bid", 12.0]])
 1211:         res = df.idxmax()
 1212:         exp = Series([0, 2])
 1213:         tm.assert_series_equal(res, exp)
 1214: 
 1215:     def test_idxminmax_object_tuples(self):
 1216:         # GH#43697
 1217:         ser = Series([(1, 3), (2, 2), (3, 1)])
 1218:         assert ser.idxmax() == 2
 1219:         assert ser.idxmin() == 0
 1220:         assert ser.idxmax(skipna=False) == 2
 1221:         assert ser.idxmin(skipna=False) == 0
 1222: 
 1223:     def test_idxminmax_object_decimals(self):
 1224:         # GH#40685
 1225:         df = DataFrame(
 1226:             {
 1227:                 "idx": [0, 1],
 1228:                 "x": [Decimal("8.68"), Decimal("42.23")],
 1229:                 "y": [Decimal("7.11"), Decimal("79.61")],
 1230:             }
 1231:         )
 1232:         res = df.idxmax()
 1233:         exp = Series({"idx": 1, "x": 1, "y": 1})
 1234:         tm.assert_series_equal(res, exp)
 1235: 
 1236:         res2 = df.idxmin()
 1237:         exp2 = exp - 1
 1238:         tm.assert_series_equal(res2, exp2)
 1239: 
 1240:     def test_argminmax_object_ints(self):
 1241:         # GH#18021
 1242:         ser = Series([0, 1], dtype="object")
 1243:         assert ser.argmax() == 1
 1244:         assert ser.argmin() == 0
 1245:         assert ser.argmax(skipna=False) == 1
 1246:         assert ser.argmin(skipna=False) == 0
 1247: 
 1248:     def test_idxminmax_with_inf(self):
 1249:         # For numeric data with NA and Inf (GH #13595)
 1250:         s = Series([0, -np.inf, np.inf, np.nan])
 1251: 
 1252:         assert s.idxmin() == 1
 1253:         msg = "The behavior of Series.idxmin with all-NA values"
 1254:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1255:             assert np.isnan(s.idxmin(skipna=False))
 1256: 
 1257:         assert s.idxmax() == 2
 1258:         msg = "The behavior of Series.idxmax with all-NA values"
 1259:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1260:             assert np.isnan(s.idxmax(skipna=False))
 1261: 
 1262:         msg = "use_inf_as_na option is deprecated"
 1263:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1264:             # Using old-style behavior that treats floating point nan, -inf, and
 1265:             # +inf as missing
 1266:             with pd.option_context("mode.use_inf_as_na", True):
 1267:                 assert s.idxmin() == 0
 1268:                 assert np.isnan(s.idxmin(skipna=False))
 1269:                 assert s.idxmax() == 0
 1270:                 np.isnan(s.idxmax(skipna=False))
 1271: 
 1272:     def test_sum_uint64(self):
 1273:         # GH 53401
 1274:         s = Series([10000000000000000000], dtype="uint64")
 1275:         result = s.sum()
 1276:         expected = np.uint64(10000000000000000000)
 1277:         tm.assert_almost_equal(result, expected)
 1278: 
 1279: 
 1280: class TestDatetime64SeriesReductions:
 1281:     # Note: the name TestDatetime64SeriesReductions indicates these tests
 1282:     #  were moved from a series-specific test file, _not_ that these tests are
 1283:     #  intended long-term to be series-specific
 1284: 
 1285:     @pytest.mark.parametrize(
 1286:         "nat_ser",
 1287:         [
 1288:             Series([NaT, NaT]),
 1289:             Series([NaT, Timedelta("nat")]),
 1290:             Series([Timedelta("nat"), Timedelta("nat")]),
 1291:         ],
 1292:     )
 1293:     def test_minmax_nat_series(self, nat_ser):
 1294:         # GH#23282
 1295:         assert nat_ser.min() is NaT
 1296:         assert nat_ser.max() is NaT
 1297:         assert nat_ser.min(skipna=False) is NaT
 1298:         assert nat_ser.max(skipna=False) is NaT
 1299: 
 1300:     @pytest.mark.parametrize(
 1301:         "nat_df",
 1302:         [
 1303:             DataFrame([NaT, NaT]),
 1304:             DataFrame([NaT, Timedelta("nat")]),
 1305:             DataFrame([Timedelta("nat"), Timedelta("nat")]),
 1306:         ],
 1307:     )
 1308:     def test_minmax_nat_dataframe(self, nat_df):
 1309:         # GH#23282
 1310:         assert nat_df.min()[0] is NaT
 1311:         assert nat_df.max()[0] is NaT
 1312:         assert nat_df.min(skipna=False)[0] is NaT
 1313:         assert nat_df.max(skipna=False)[0] is NaT
 1314: 
 1315:     def test_min_max(self):
 1316:         rng = date_range("1/1/2000", "12/31/2000")
 1317:         rng2 = rng.take(np.random.default_rng(2).permutation(len(rng)))
 1318: 
 1319:         the_min = rng2.min()
 1320:         the_max = rng2.max()
 1321:         assert isinstance(the_min, Timestamp)
 1322:         assert isinstance(the_max, Timestamp)
 1323:         assert the_min == rng[0]
 1324:         assert the_max == rng[-1]
 1325: 
 1326:         assert rng.min() == rng[0]
 1327:         assert rng.max() == rng[-1]
 1328: 
 1329:     def test_min_max_series(self):
 1330:         rng = date_range("1/1/2000", periods=10, freq="4h")
 1331:         lvls = ["A", "A", "A", "B", "B", "B", "C", "C", "C", "C"]
 1332:         df = DataFrame(
 1333:             {
 1334:                 "TS": rng,
 1335:                 "V": np.random.default_rng(2).standard_normal(len(rng)),
 1336:                 "L": lvls,
 1337:             }
 1338:         )
 1339: 
 1340:         result = df.TS.max()
 1341:         exp = Timestamp(df.TS.iat[-1])
 1342:         assert isinstance(result, Timestamp)
 1343:         assert result == exp
 1344: 
 1345:         result = df.TS.min()
 1346:         exp = Timestamp(df.TS.iat[0])
 1347:         assert isinstance(result, Timestamp)
 1348:         assert result == exp
 1349: 
 1350: 
 1351: class TestCategoricalSeriesReductions:
 1352:     # Note: the name TestCategoricalSeriesReductions indicates these tests
 1353:     #  were moved from a series-specific test file, _not_ that these tests are
 1354:     #  intended long-term to be series-specific
 1355: 
 1356:     @pytest.mark.parametrize("function", ["min", "max"])
 1357:     def test_min_max_unordered_raises(self, function):
 1358:         # unordered cats have no min/max
 1359:         cat = Series(Categorical(["a", "b", "c", "d"], ordered=False))
 1360:         msg = f"Categorical is not ordered for operation {function}"
 1361:         with pytest.raises(TypeError, match=msg):
 1362:             getattr(cat, function)()
 1363: 
 1364:     @pytest.mark.parametrize(
 1365:         "values, categories",
 1366:         [
 1367:             (list("abc"), list("abc")),
 1368:             (list("abc"), list("cba")),
 1369:             (list("abc") + [np.nan], list("cba")),
 1370:             ([1, 2, 3], [3, 2, 1]),
 1371:             ([1, 2, 3, np.nan], [3, 2, 1]),
 1372:         ],
 1373:     )
 1374:     @pytest.mark.parametrize("function", ["min", "max"])
 1375:     def test_min_max_ordered(self, values, categories, function):
 1376:         # GH 25303
 1377:         cat = Series(Categorical(values, categories=categories, ordered=True))
 1378:         result = getattr(cat, function)(skipna=True)
 1379:         expected = categories[0] if function == "min" else categories[2]
 1380:         assert result == expected
 1381: 
 1382:     @pytest.mark.parametrize("function", ["min", "max"])
 1383:     @pytest.mark.parametrize("skipna", [True, False])
 1384:     def test_min_max_ordered_with_nan_only(self, function, skipna):
 1385:         # https://github.com/pandas-dev/pandas/issues/33450
 1386:         cat = Series(Categorical([np.nan], categories=[1, 2], ordered=True))
 1387:         result = getattr(cat, function)(skipna=skipna)
 1388:         assert result is np.nan
 1389: 
 1390:     @pytest.mark.parametrize("function", ["min", "max"])
 1391:     @pytest.mark.parametrize("skipna", [True, False])
 1392:     def test_min_max_skipna(self, function, skipna):
 1393:         cat = Series(
 1394:             Categorical(["a", "b", np.nan, "a"], categories=["b", "a"], ordered=True)
 1395:         )
 1396:         result = getattr(cat, function)(skipna=skipna)
 1397: 
 1398:         if skipna is True:
 1399:             expected = "b" if function == "min" else "a"
 1400:             assert result == expected
 1401:         else:
 1402:             assert result is np.nan
 1403: 
 1404: 
 1405: class TestSeriesMode:
 1406:     # Note: the name TestSeriesMode indicates these tests
 1407:     #  were moved from a series-specific test file, _not_ that these tests are
 1408:     #  intended long-term to be series-specific
 1409: 
 1410:     @pytest.mark.parametrize(
 1411:         "dropna, expected",
 1412:         [(True, Series([], dtype=np.float64)), (False, Series([], dtype=np.float64))],
 1413:     )
 1414:     def test_mode_empty(self, dropna, expected):
 1415:         s = Series([], dtype=np.float64)
 1416:         result = s.mode(dropna)
 1417:         tm.assert_series_equal(result, expected)
 1418: 
 1419:     @pytest.mark.parametrize(
 1420:         "dropna, data, expected",
 1421:         [
 1422:             (True, [1, 1, 1, 2], [1]),
 1423:             (True, [1, 1, 1, 2, 3, 3, 3], [1, 3]),
 1424:             (False, [1, 1, 1, 2], [1]),
 1425:             (False, [1, 1, 1, 2, 3, 3, 3], [1, 3]),
 1426:         ],
 1427:     )
 1428:     @pytest.mark.parametrize(
 1429:         "dt", list(np.typecodes["AllInteger"] + np.typecodes["Float"])
 1430:     )
 1431:     def test_mode_numerical(self, dropna, data, expected, dt):
 1432:         s = Series(data, dtype=dt)
 1433:         result = s.mode(dropna)
 1434:         expected = Series(expected, dtype=dt)
 1435:         tm.assert_series_equal(result, expected)
 1436: 
 1437:     @pytest.mark.parametrize("dropna, expected", [(True, [1.0]), (False, [1, np.nan])])
 1438:     def test_mode_numerical_nan(self, dropna, expected):
 1439:         s = Series([1, 1, 2, np.nan, np.nan])
 1440:         result = s.mode(dropna)
 1441:         expected = Series(expected)
 1442:         tm.assert_series_equal(result, expected)
 1443: 
 1444:     @pytest.mark.parametrize(
 1445:         "dropna, expected1, expected2, expected3",
 1446:         [(True, ["b"], ["bar"], ["nan"]), (False, ["b"], [np.nan], ["nan"])],
 1447:     )
 1448:     def test_mode_str_obj(self, dropna, expected1, expected2, expected3):
 1449:         # Test string and object types.
 1450:         data = ["a"] * 2 + ["b"] * 3
 1451: 
 1452:         s = Series(data, dtype="c")
 1453:         result = s.mode(dropna)
 1454:         expected1 = Series(expected1, dtype="c")
 1455:         tm.assert_series_equal(result, expected1)
 1456: 
 1457:         data = ["foo", "bar", "bar", np.nan, np.nan, np.nan]
 1458: 
 1459:         s = Series(data, dtype=object)
 1460:         result = s.mode(dropna)
 1461:         expected2 = Series(expected2, dtype=None if expected2 == ["bar"] else object)
 1462:         tm.assert_series_equal(result, expected2)
 1463: 
 1464:         data = ["foo", "bar", "bar", np.nan, np.nan, np.nan]
 1465: 
 1466:         s = Series(data, dtype=object).astype(str)
 1467:         result = s.mode(dropna)
 1468:         expected3 = Series(expected3)
 1469:         tm.assert_series_equal(result, expected3)
 1470: 
 1471:     @pytest.mark.parametrize(
 1472:         "dropna, expected1, expected2",
 1473:         [(True, ["foo"], ["foo"]), (False, ["foo"], [np.nan])],
 1474:     )
 1475:     def test_mode_mixeddtype(self, dropna, expected1, expected2):
 1476:         s = Series([1, "foo", "foo"])
 1477:         result = s.mode(dropna)
 1478:         expected = Series(expected1)
 1479:         tm.assert_series_equal(result, expected)
 1480: 
 1481:         s = Series([1, "foo", "foo", np.nan, np.nan, np.nan])
 1482:         result = s.mode(dropna)
 1483:         expected = Series(expected2, dtype=None if expected2 == ["foo"] else object)
 1484:         tm.assert_series_equal(result, expected)
 1485: 
 1486:     @pytest.mark.parametrize(
 1487:         "dropna, expected1, expected2",
 1488:         [
 1489:             (
 1490:                 True,
 1491:                 ["1900-05-03", "2011-01-03", "2013-01-02"],
 1492:                 ["2011-01-03", "2013-01-02"],
 1493:             ),
 1494:             (False, [np.nan], [np.nan, "2011-01-03", "2013-01-02"]),
 1495:         ],
 1496:     )
 1497:     def test_mode_datetime(self, dropna, expected1, expected2):
 1498:         s = Series(
 1499:             ["2011-01-03", "2013-01-02", "1900-05-03", "nan", "nan"], dtype="M8[ns]"
 1500:         )
 1501:         result = s.mode(dropna)
 1502:         expected1 = Series(expected1, dtype="M8[ns]")
 1503:         tm.assert_series_equal(result, expected1)
 1504: 
 1505:         s = Series(
 1506:             [
 1507:                 "2011-01-03",
 1508:                 "2013-01-02",
 1509:                 "1900-05-03",
 1510:                 "2011-01-03",
 1511:                 "2013-01-02",
 1512:                 "nan",
 1513:                 "nan",
 1514:             ],
 1515:             dtype="M8[ns]",
 1516:         )
 1517:         result = s.mode(dropna)
 1518:         expected2 = Series(expected2, dtype="M8[ns]")
 1519:         tm.assert_series_equal(result, expected2)
 1520: 
 1521:     @pytest.mark.parametrize(
 1522:         "dropna, expected1, expected2",
 1523:         [
 1524:             (True, ["-1 days", "0 days", "1 days"], ["2 min", "1 day"]),
 1525:             (False, [np.nan], [np.nan, "2 min", "1 day"]),
 1526:         ],
 1527:     )
 1528:     def test_mode_timedelta(self, dropna, expected1, expected2):
 1529:         # gh-5986: Test timedelta types.
 1530: 
 1531:         s = Series(
 1532:             ["1 days", "-1 days", "0 days", "nan", "nan"], dtype="timedelta64[ns]"
 1533:         )
 1534:         result = s.mode(dropna)
 1535:         expected1 = Series(expected1, dtype="timedelta64[ns]")
 1536:         tm.assert_series_equal(result, expected1)
 1537: 
 1538:         s = Series(
 1539:             [
 1540:                 "1 day",
 1541:                 "1 day",
 1542:                 "-1 day",
 1543:                 "-1 day 2 min",
 1544:                 "2 min",
 1545:                 "2 min",
 1546:                 "nan",
 1547:                 "nan",
 1548:             ],
 1549:             dtype="timedelta64[ns]",
 1550:         )
 1551:         result = s.mode(dropna)
 1552:         expected2 = Series(expected2, dtype="timedelta64[ns]")
 1553:         tm.assert_series_equal(result, expected2)
 1554: 
 1555:     @pytest.mark.parametrize(
 1556:         "dropna, expected1, expected2, expected3",
 1557:         [
 1558:             (
 1559:                 True,
 1560:                 Categorical([1, 2], categories=[1, 2]),
 1561:                 Categorical(["a"], categories=[1, "a"]),
 1562:                 Categorical([3, 1], categories=[3, 2, 1], ordered=True),
 1563:             ),
 1564:             (
 1565:                 False,
 1566:                 Categorical([np.nan], categories=[1, 2]),
 1567:                 Categorical([np.nan, "a"], categories=[1, "a"]),
 1568:                 Categorical([np.nan, 3, 1], categories=[3, 2, 1], ordered=True),
 1569:             ),
 1570:         ],
 1571:     )
 1572:     def test_mode_category(self, dropna, expected1, expected2, expected3):
 1573:         s = Series(Categorical([1, 2, np.nan, np.nan]))
 1574:         result = s.mode(dropna)
 1575:         expected1 = Series(expected1, dtype="category")
 1576:         tm.assert_series_equal(result, expected1)
 1577: 
 1578:         s = Series(Categorical([1, "a", "a", np.nan, np.nan]))
 1579:         result = s.mode(dropna)
 1580:         expected2 = Series(expected2, dtype="category")
 1581:         tm.assert_series_equal(result, expected2)
 1582: 
 1583:         s = Series(
 1584:             Categorical(
 1585:                 [1, 1, 2, 3, 3, np.nan, np.nan], categories=[3, 2, 1], ordered=True
 1586:             )
 1587:         )
 1588:         result = s.mode(dropna)
 1589:         expected3 = Series(expected3, dtype="category")
 1590:         tm.assert_series_equal(result, expected3)
 1591: 
 1592:     @pytest.mark.parametrize(
 1593:         "dropna, expected1, expected2",
 1594:         [(True, [2**63], [1, 2**63]), (False, [2**63], [1, 2**63])],
 1595:     )
 1596:     def test_mode_intoverflow(self, dropna, expected1, expected2):
 1597:         # Test for uint64 overflow.
 1598:         s = Series([1, 2**63, 2**63], dtype=np.uint64)
 1599:         result = s.mode(dropna)
 1600:         expected1 = Series(expected1, dtype=np.uint64)
 1601:         tm.assert_series_equal(result, expected1)
 1602: 
 1603:         s = Series([1, 2**63], dtype=np.uint64)
 1604:         result = s.mode(dropna)
 1605:         expected2 = Series(expected2, dtype=np.uint64)
 1606:         tm.assert_series_equal(result, expected2)
 1607: 
 1608:     def test_mode_sortwarning(self):
 1609:         # Check for the warning that is raised when the mode
 1610:         # results cannot be sorted
 1611: 
 1612:         expected = Series(["foo", np.nan])
 1613:         s = Series([1, "foo", "foo", np.nan, np.nan])
 1614: 
 1615:         with tm.assert_produces_warning(UserWarning):
 1616:             result = s.mode(dropna=False)
 1617:             result = result.sort_values().reset_index(drop=True)
 1618: 
 1619:         tm.assert_series_equal(result, expected)
 1620: 
 1621:     def test_mode_boolean_with_na(self):
 1622:         # GH#42107
 1623:         ser = Series([True, False, True, pd.NA], dtype="boolean")
 1624:         result = ser.mode()
 1625:         expected = Series({0: True}, dtype="boolean")
 1626:         tm.assert_series_equal(result, expected)
 1627: 
 1628:     @pytest.mark.parametrize(
 1629:         "array,expected,dtype",
 1630:         [
 1631:             (
 1632:                 [0, 1j, 1, 1, 1 + 1j, 1 + 2j],
 1633:                 Series([1], dtype=np.complex128),
 1634:                 np.complex128,
 1635:             ),
 1636:             (
 1637:                 [0, 1j, 1, 1, 1 + 1j, 1 + 2j],
 1638:                 Series([1], dtype=np.complex64),
 1639:                 np.complex64,
 1640:             ),
 1641:             (
 1642:                 [1 + 1j, 2j, 1 + 1j],
 1643:                 Series([1 + 1j], dtype=np.complex128),
 1644:                 np.complex128,
 1645:             ),
 1646:         ],
 1647:     )
 1648:     def test_single_mode_value_complex(self, array, expected, dtype):
 1649:         result = Series(array, dtype=dtype).mode()
 1650:         tm.assert_series_equal(result, expected)
 1651: 
 1652:     @pytest.mark.parametrize(
 1653:         "array,expected,dtype",
 1654:         [
 1655:             (
 1656:                 # no modes
 1657:                 [0, 1j, 1, 1 + 1j, 1 + 2j],
 1658:                 Series([0j, 1j, 1 + 0j, 1 + 1j, 1 + 2j], dtype=np.complex128),
 1659:                 np.complex128,
 1660:             ),
 1661:             (
 1662:                 [1 + 1j, 2j, 1 + 1j, 2j, 3],
 1663:                 Series([2j, 1 + 1j], dtype=np.complex64),
 1664:                 np.complex64,
 1665:             ),
 1666:         ],
 1667:     )
 1668:     def test_multimode_complex(self, array, expected, dtype):
 1669:         # GH 17927
 1670:         # mode tries to sort multimodal series.
 1671:         # Complex numbers are sorted by their magnitude
 1672:         result = Series(array, dtype=dtype).mode()
 1673:         tm.assert_series_equal(result, expected)
