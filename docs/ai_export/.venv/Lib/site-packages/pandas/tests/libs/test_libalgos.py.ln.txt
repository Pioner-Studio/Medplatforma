    1: from datetime import datetime
    2: from itertools import permutations
    3: 
    4: import numpy as np
    5: 
    6: from pandas._libs import algos as libalgos
    7: 
    8: import pandas._testing as tm
    9: 
   10: 
   11: def test_ensure_platform_int():
   12:     arr = np.arange(100, dtype=np.intp)
   13: 
   14:     result = libalgos.ensure_platform_int(arr)
   15:     assert result is arr
   16: 
   17: 
   18: def test_is_lexsorted():
   19:     failure = [
   20:         np.array(
   21:             ([3] * 32) + ([2] * 32) + ([1] * 32) + ([0] * 32),
   22:             dtype="int64",
   23:         ),
   24:         np.array(
   25:             list(range(31))[::-1] * 4,
   26:             dtype="int64",
   27:         ),
   28:     ]
   29: 
   30:     assert not libalgos.is_lexsorted(failure)
   31: 
   32: 
   33: def test_groupsort_indexer():
   34:     a = np.random.default_rng(2).integers(0, 1000, 100).astype(np.intp)
   35:     b = np.random.default_rng(2).integers(0, 1000, 100).astype(np.intp)
   36: 
   37:     result = libalgos.groupsort_indexer(a, 1000)[0]
   38: 
   39:     # need to use a stable sort
   40:     # np.argsort returns int, groupsort_indexer
   41:     # always returns intp
   42:     expected = np.argsort(a, kind="mergesort")
   43:     expected = expected.astype(np.intp)
   44: 
   45:     tm.assert_numpy_array_equal(result, expected)
   46: 
   47:     # compare with lexsort
   48:     # np.lexsort returns int, groupsort_indexer
   49:     # always returns intp
   50:     key = a * 1000 + b
   51:     result = libalgos.groupsort_indexer(key, 1000000)[0]
   52:     expected = np.lexsort((b, a))
   53:     expected = expected.astype(np.intp)
   54: 
   55:     tm.assert_numpy_array_equal(result, expected)
   56: 
   57: 
   58: class TestPadBackfill:
   59:     def test_backfill(self):
   60:         old = np.array([1, 5, 10], dtype=np.int64)
   61:         new = np.array(list(range(12)), dtype=np.int64)
   62: 
   63:         filler = libalgos.backfill["int64_t"](old, new)
   64: 
   65:         expect_filler = np.array([0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, -1], dtype=np.intp)
   66:         tm.assert_numpy_array_equal(filler, expect_filler)
   67: 
   68:         # corner case
   69:         old = np.array([1, 4], dtype=np.int64)
   70:         new = np.array(list(range(5, 10)), dtype=np.int64)
   71:         filler = libalgos.backfill["int64_t"](old, new)
   72: 
   73:         expect_filler = np.array([-1, -1, -1, -1, -1], dtype=np.intp)
   74:         tm.assert_numpy_array_equal(filler, expect_filler)
   75: 
   76:     def test_pad(self):
   77:         old = np.array([1, 5, 10], dtype=np.int64)
   78:         new = np.array(list(range(12)), dtype=np.int64)
   79: 
   80:         filler = libalgos.pad["int64_t"](old, new)
   81: 
   82:         expect_filler = np.array([-1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2], dtype=np.intp)
   83:         tm.assert_numpy_array_equal(filler, expect_filler)
   84: 
   85:         # corner case
   86:         old = np.array([5, 10], dtype=np.int64)
   87:         new = np.arange(5, dtype=np.int64)
   88:         filler = libalgos.pad["int64_t"](old, new)
   89:         expect_filler = np.array([-1, -1, -1, -1, -1], dtype=np.intp)
   90:         tm.assert_numpy_array_equal(filler, expect_filler)
   91: 
   92:     def test_pad_backfill_object_segfault(self):
   93:         old = np.array([], dtype="O")
   94:         new = np.array([datetime(2010, 12, 31)], dtype="O")
   95: 
   96:         result = libalgos.pad["object"](old, new)
   97:         expected = np.array([-1], dtype=np.intp)
   98:         tm.assert_numpy_array_equal(result, expected)
   99: 
  100:         result = libalgos.pad["object"](new, old)
  101:         expected = np.array([], dtype=np.intp)
  102:         tm.assert_numpy_array_equal(result, expected)
  103: 
  104:         result = libalgos.backfill["object"](old, new)
  105:         expected = np.array([-1], dtype=np.intp)
  106:         tm.assert_numpy_array_equal(result, expected)
  107: 
  108:         result = libalgos.backfill["object"](new, old)
  109:         expected = np.array([], dtype=np.intp)
  110:         tm.assert_numpy_array_equal(result, expected)
  111: 
  112: 
  113: class TestInfinity:
  114:     def test_infinity_sort(self):
  115:         # GH#13445
  116:         # numpy's argsort can be unhappy if something is less than
  117:         # itself.  Instead, let's give our infinities a self-consistent
  118:         # ordering, but outside the float extended real line.
  119: 
  120:         Inf = libalgos.Infinity()
  121:         NegInf = libalgos.NegInfinity()
  122: 
  123:         ref_nums = [NegInf, float("-inf"), -1e100, 0, 1e100, float("inf"), Inf]
  124: 
  125:         assert all(Inf >= x for x in ref_nums)
  126:         assert all(Inf > x or x is Inf for x in ref_nums)
  127:         assert Inf >= Inf and Inf == Inf
  128:         assert not Inf < Inf and not Inf > Inf
  129:         assert libalgos.Infinity() == libalgos.Infinity()
  130:         assert not libalgos.Infinity() != libalgos.Infinity()
  131: 
  132:         assert all(NegInf <= x for x in ref_nums)
  133:         assert all(NegInf < x or x is NegInf for x in ref_nums)
  134:         assert NegInf <= NegInf and NegInf == NegInf
  135:         assert not NegInf < NegInf and not NegInf > NegInf
  136:         assert libalgos.NegInfinity() == libalgos.NegInfinity()
  137:         assert not libalgos.NegInfinity() != libalgos.NegInfinity()
  138: 
  139:         for perm in permutations(ref_nums):
  140:             assert sorted(perm) == ref_nums
  141: 
  142:         # smoke tests
  143:         np.array([libalgos.Infinity()] * 32).argsort()
  144:         np.array([libalgos.NegInfinity()] * 32).argsort()
  145: 
  146:     def test_infinity_against_nan(self):
  147:         Inf = libalgos.Infinity()
  148:         NegInf = libalgos.NegInfinity()
  149: 
  150:         assert not Inf > np.nan
  151:         assert not Inf >= np.nan
  152:         assert not Inf < np.nan
  153:         assert not Inf <= np.nan
  154:         assert not Inf == np.nan
  155:         assert Inf != np.nan
  156: 
  157:         assert not NegInf > np.nan
  158:         assert not NegInf >= np.nan
  159:         assert not NegInf < np.nan
  160:         assert not NegInf <= np.nan
  161:         assert not NegInf == np.nan
  162:         assert NegInf != np.nan
