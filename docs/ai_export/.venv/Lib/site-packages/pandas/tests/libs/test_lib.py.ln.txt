    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._libs import (
    5:     Timedelta,
    6:     lib,
    7:     writers as libwriters,
    8: )
    9: from pandas.compat import IS64
   10: 
   11: from pandas import Index
   12: import pandas._testing as tm
   13: 
   14: 
   15: class TestMisc:
   16:     def test_max_len_string_array(self):
   17:         arr = a = np.array(["foo", "b", np.nan], dtype="object")
   18:         assert libwriters.max_len_string_array(arr) == 3
   19: 
   20:         # unicode
   21:         arr = a.astype("U").astype(object)
   22:         assert libwriters.max_len_string_array(arr) == 3
   23: 
   24:         # bytes for python3
   25:         arr = a.astype("S").astype(object)
   26:         assert libwriters.max_len_string_array(arr) == 3
   27: 
   28:         # raises
   29:         msg = "No matching signature found"
   30:         with pytest.raises(TypeError, match=msg):
   31:             libwriters.max_len_string_array(arr.astype("U"))
   32: 
   33:     def test_fast_unique_multiple_list_gen_sort(self):
   34:         keys = [["p", "a"], ["n", "d"], ["a", "s"]]
   35: 
   36:         gen = (key for key in keys)
   37:         expected = np.array(["a", "d", "n", "p", "s"])
   38:         out = lib.fast_unique_multiple_list_gen(gen, sort=True)
   39:         tm.assert_numpy_array_equal(np.array(out), expected)
   40: 
   41:         gen = (key for key in keys)
   42:         expected = np.array(["p", "a", "n", "d", "s"])
   43:         out = lib.fast_unique_multiple_list_gen(gen, sort=False)
   44:         tm.assert_numpy_array_equal(np.array(out), expected)
   45: 
   46:     def test_fast_multiget_timedelta_resos(self):
   47:         # This will become relevant for test_constructor_dict_timedelta64_index
   48:         #  once Timedelta constructor preserves reso when passed a
   49:         #  np.timedelta64 object
   50:         td = Timedelta(days=1)
   51: 
   52:         mapping1 = {td: 1}
   53:         mapping2 = {td.as_unit("s"): 1}
   54: 
   55:         oindex = Index([td * n for n in range(3)])._values.astype(object)
   56: 
   57:         expected = lib.fast_multiget(mapping1, oindex)
   58:         result = lib.fast_multiget(mapping2, oindex)
   59:         tm.assert_numpy_array_equal(result, expected)
   60: 
   61:         # case that can't be cast to td64ns
   62:         td = Timedelta(np.timedelta64(146000, "D"))
   63:         assert hash(td) == hash(td.as_unit("ms"))
   64:         assert hash(td) == hash(td.as_unit("us"))
   65:         mapping1 = {td: 1}
   66:         mapping2 = {td.as_unit("ms"): 1}
   67: 
   68:         oindex = Index([td * n for n in range(3)])._values.astype(object)
   69: 
   70:         expected = lib.fast_multiget(mapping1, oindex)
   71:         result = lib.fast_multiget(mapping2, oindex)
   72:         tm.assert_numpy_array_equal(result, expected)
   73: 
   74: 
   75: class TestIndexing:
   76:     def test_maybe_indices_to_slice_left_edge(self):
   77:         target = np.arange(100)
   78: 
   79:         # slice
   80:         indices = np.array([], dtype=np.intp)
   81:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
   82: 
   83:         assert isinstance(maybe_slice, slice)
   84:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
   85: 
   86:     @pytest.mark.parametrize("end", [1, 2, 5, 20, 99])
   87:     @pytest.mark.parametrize("step", [1, 2, 4])
   88:     def test_maybe_indices_to_slice_left_edge_not_slice_end_steps(self, end, step):
   89:         target = np.arange(100)
   90:         indices = np.arange(0, end, step, dtype=np.intp)
   91:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
   92: 
   93:         assert isinstance(maybe_slice, slice)
   94:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
   95: 
   96:         # reverse
   97:         indices = indices[::-1]
   98:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
   99: 
  100:         assert isinstance(maybe_slice, slice)
  101:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  102: 
  103:     @pytest.mark.parametrize(
  104:         "case", [[2, 1, 2, 0], [2, 2, 1, 0], [0, 1, 2, 1], [-2, 0, 2], [2, 0, -2]]
  105:     )
  106:     def test_maybe_indices_to_slice_left_edge_not_slice(self, case):
  107:         # not slice
  108:         target = np.arange(100)
  109:         indices = np.array(case, dtype=np.intp)
  110:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  111: 
  112:         assert not isinstance(maybe_slice, slice)
  113:         tm.assert_numpy_array_equal(maybe_slice, indices)
  114:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  115: 
  116:     @pytest.mark.parametrize("start", [0, 2, 5, 20, 97, 98])
  117:     @pytest.mark.parametrize("step", [1, 2, 4])
  118:     def test_maybe_indices_to_slice_right_edge(self, start, step):
  119:         target = np.arange(100)
  120: 
  121:         # slice
  122:         indices = np.arange(start, 99, step, dtype=np.intp)
  123:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  124: 
  125:         assert isinstance(maybe_slice, slice)
  126:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  127: 
  128:         # reverse
  129:         indices = indices[::-1]
  130:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  131: 
  132:         assert isinstance(maybe_slice, slice)
  133:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  134: 
  135:     def test_maybe_indices_to_slice_right_edge_not_slice(self):
  136:         # not slice
  137:         target = np.arange(100)
  138:         indices = np.array([97, 98, 99, 100], dtype=np.intp)
  139:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  140: 
  141:         assert not isinstance(maybe_slice, slice)
  142:         tm.assert_numpy_array_equal(maybe_slice, indices)
  143: 
  144:         msg = "index 100 is out of bounds for axis (0|1) with size 100"
  145: 
  146:         with pytest.raises(IndexError, match=msg):
  147:             target[indices]
  148:         with pytest.raises(IndexError, match=msg):
  149:             target[maybe_slice]
  150: 
  151:         indices = np.array([100, 99, 98, 97], dtype=np.intp)
  152:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  153: 
  154:         assert not isinstance(maybe_slice, slice)
  155:         tm.assert_numpy_array_equal(maybe_slice, indices)
  156: 
  157:         with pytest.raises(IndexError, match=msg):
  158:             target[indices]
  159:         with pytest.raises(IndexError, match=msg):
  160:             target[maybe_slice]
  161: 
  162:     @pytest.mark.parametrize(
  163:         "case", [[99, 97, 99, 96], [99, 99, 98, 97], [98, 98, 97, 96]]
  164:     )
  165:     def test_maybe_indices_to_slice_right_edge_cases(self, case):
  166:         target = np.arange(100)
  167:         indices = np.array(case, dtype=np.intp)
  168:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  169: 
  170:         assert not isinstance(maybe_slice, slice)
  171:         tm.assert_numpy_array_equal(maybe_slice, indices)
  172:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  173: 
  174:     @pytest.mark.parametrize("step", [1, 2, 4, 5, 8, 9])
  175:     def test_maybe_indices_to_slice_both_edges(self, step):
  176:         target = np.arange(10)
  177: 
  178:         # slice
  179:         indices = np.arange(0, 9, step, dtype=np.intp)
  180:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  181:         assert isinstance(maybe_slice, slice)
  182:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  183: 
  184:         # reverse
  185:         indices = indices[::-1]
  186:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  187:         assert isinstance(maybe_slice, slice)
  188:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  189: 
  190:     @pytest.mark.parametrize("case", [[4, 2, 0, -2], [2, 2, 1, 0], [0, 1, 2, 1]])
  191:     def test_maybe_indices_to_slice_both_edges_not_slice(self, case):
  192:         # not slice
  193:         target = np.arange(10)
  194:         indices = np.array(case, dtype=np.intp)
  195:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  196:         assert not isinstance(maybe_slice, slice)
  197:         tm.assert_numpy_array_equal(maybe_slice, indices)
  198:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  199: 
  200:     @pytest.mark.parametrize("start, end", [(2, 10), (5, 25), (65, 97)])
  201:     @pytest.mark.parametrize("step", [1, 2, 4, 20])
  202:     def test_maybe_indices_to_slice_middle(self, start, end, step):
  203:         target = np.arange(100)
  204: 
  205:         # slice
  206:         indices = np.arange(start, end, step, dtype=np.intp)
  207:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  208: 
  209:         assert isinstance(maybe_slice, slice)
  210:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  211: 
  212:         # reverse
  213:         indices = indices[::-1]
  214:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  215: 
  216:         assert isinstance(maybe_slice, slice)
  217:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  218: 
  219:     @pytest.mark.parametrize(
  220:         "case", [[14, 12, 10, 12], [12, 12, 11, 10], [10, 11, 12, 11]]
  221:     )
  222:     def test_maybe_indices_to_slice_middle_not_slice(self, case):
  223:         # not slice
  224:         target = np.arange(100)
  225:         indices = np.array(case, dtype=np.intp)
  226:         maybe_slice = lib.maybe_indices_to_slice(indices, len(target))
  227: 
  228:         assert not isinstance(maybe_slice, slice)
  229:         tm.assert_numpy_array_equal(maybe_slice, indices)
  230:         tm.assert_numpy_array_equal(target[indices], target[maybe_slice])
  231: 
  232:     def test_maybe_booleans_to_slice(self):
  233:         arr = np.array([0, 0, 1, 1, 1, 0, 1], dtype=np.uint8)
  234:         result = lib.maybe_booleans_to_slice(arr)
  235:         assert result.dtype == np.bool_
  236: 
  237:         result = lib.maybe_booleans_to_slice(arr[:0])
  238:         assert result == slice(0, 0)
  239: 
  240:     def test_get_reverse_indexer(self):
  241:         indexer = np.array([-1, -1, 1, 2, 0, -1, 3, 4], dtype=np.intp)
  242:         result = lib.get_reverse_indexer(indexer, 5)
  243:         expected = np.array([4, 2, 3, 6, 7], dtype=np.intp)
  244:         tm.assert_numpy_array_equal(result, expected)
  245: 
  246:     @pytest.mark.parametrize("dtype", ["int64", "int32"])
  247:     def test_is_range_indexer(self, dtype):
  248:         # GH#50592
  249:         left = np.arange(0, 100, dtype=dtype)
  250:         assert lib.is_range_indexer(left, 100)
  251: 
  252:     @pytest.mark.skipif(
  253:         not IS64,
  254:         reason="2**31 is too big for Py_ssize_t on 32-bit. "
  255:         "It doesn't matter though since you cannot create an array that long on 32-bit",
  256:     )
  257:     @pytest.mark.parametrize("dtype", ["int64", "int32"])
  258:     def test_is_range_indexer_big_n(self, dtype):
  259:         # GH53616
  260:         left = np.arange(0, 100, dtype=dtype)
  261: 
  262:         assert not lib.is_range_indexer(left, 2**31)
  263: 
  264:     @pytest.mark.parametrize("dtype", ["int64", "int32"])
  265:     def test_is_range_indexer_not_equal(self, dtype):
  266:         # GH#50592
  267:         left = np.array([1, 2], dtype=dtype)
  268:         assert not lib.is_range_indexer(left, 2)
  269: 
  270:     @pytest.mark.parametrize("dtype", ["int64", "int32"])
  271:     def test_is_range_indexer_not_equal_shape(self, dtype):
  272:         # GH#50592
  273:         left = np.array([0, 1, 2], dtype=dtype)
  274:         assert not lib.is_range_indexer(left, 2)
  275: 
  276: 
  277: def test_cache_readonly_preserve_docstrings():
  278:     # GH18197
  279:     assert Index.hasnans.__doc__ is not None
  280: 
  281: 
  282: def test_no_default_pickle():
  283:     # GH#40397
  284:     obj = tm.round_trip_pickle(lib.no_default)
  285:     assert obj is lib.no_default
