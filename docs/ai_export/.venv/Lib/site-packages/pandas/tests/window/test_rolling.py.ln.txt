    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas.compat import (
   10:     IS64,
   11:     is_platform_arm,
   12:     is_platform_power,
   13: )
   14: 
   15: from pandas import (
   16:     DataFrame,
   17:     DatetimeIndex,
   18:     MultiIndex,
   19:     Series,
   20:     Timedelta,
   21:     Timestamp,
   22:     date_range,
   23:     period_range,
   24:     to_datetime,
   25:     to_timedelta,
   26: )
   27: import pandas._testing as tm
   28: from pandas.api.indexers import BaseIndexer
   29: from pandas.core.indexers.objects import VariableOffsetWindowIndexer
   30: 
   31: from pandas.tseries.offsets import BusinessDay
   32: 
   33: 
   34: def test_doc_string():
   35:     df = DataFrame({"B": [0, 1, 2, np.nan, 4]})
   36:     df
   37:     df.rolling(2).sum()
   38:     df.rolling(2, min_periods=1).sum()
   39: 
   40: 
   41: def test_constructor(frame_or_series):
   42:     # GH 12669
   43: 
   44:     c = frame_or_series(range(5)).rolling
   45: 
   46:     # valid
   47:     c(0)
   48:     c(window=2)
   49:     c(window=2, min_periods=1)
   50:     c(window=2, min_periods=1, center=True)
   51:     c(window=2, min_periods=1, center=False)
   52: 
   53:     # GH 13383
   54: 
   55:     msg = "window must be an integer 0 or greater"
   56: 
   57:     with pytest.raises(ValueError, match=msg):
   58:         c(-1)
   59: 
   60: 
   61: @pytest.mark.parametrize("w", [2.0, "foo", np.array([2])])
   62: def test_invalid_constructor(frame_or_series, w):
   63:     # not valid
   64: 
   65:     c = frame_or_series(range(5)).rolling
   66: 
   67:     msg = "|".join(
   68:         [
   69:             "window must be an integer",
   70:             "passed window foo is not compatible with a datetimelike index",
   71:         ]
   72:     )
   73:     with pytest.raises(ValueError, match=msg):
   74:         c(window=w)
   75: 
   76:     msg = "min_periods must be an integer"
   77:     with pytest.raises(ValueError, match=msg):
   78:         c(window=2, min_periods=w)
   79: 
   80:     msg = "center must be a boolean"
   81:     with pytest.raises(ValueError, match=msg):
   82:         c(window=2, min_periods=1, center=w)
   83: 
   84: 
   85: @pytest.mark.parametrize(
   86:     "window",
   87:     [
   88:         timedelta(days=3),
   89:         Timedelta(days=3),
   90:         "3D",
   91:         VariableOffsetWindowIndexer(
   92:             index=date_range("2015-12-25", periods=5), offset=BusinessDay(1)
   93:         ),
   94:     ],
   95: )
   96: def test_freq_window_not_implemented(window):
   97:     # GH 15354
   98:     df = DataFrame(
   99:         np.arange(10),
  100:         index=date_range("2015-12-24", periods=10, freq="D"),
  101:     )
  102:     with pytest.raises(
  103:         NotImplementedError, match="^step (not implemented|is not supported)"
  104:     ):
  105:         df.rolling(window, step=3).sum()
  106: 
  107: 
  108: @pytest.mark.parametrize("agg", ["cov", "corr"])
  109: def test_step_not_implemented_for_cov_corr(agg):
  110:     # GH 15354
  111:     roll = DataFrame(range(2)).rolling(1, step=2)
  112:     with pytest.raises(NotImplementedError, match="step not implemented"):
  113:         getattr(roll, agg)()
  114: 
  115: 
  116: @pytest.mark.parametrize("window", [timedelta(days=3), Timedelta(days=3)])
  117: def test_constructor_with_timedelta_window(window):
  118:     # GH 15440
  119:     n = 10
  120:     df = DataFrame(
  121:         {"value": np.arange(n)},
  122:         index=date_range("2015-12-24", periods=n, freq="D"),
  123:     )
  124:     expected_data = np.append([0.0, 1.0], np.arange(3.0, 27.0, 3))
  125: 
  126:     result = df.rolling(window=window).sum()
  127:     expected = DataFrame(
  128:         {"value": expected_data},
  129:         index=date_range("2015-12-24", periods=n, freq="D"),
  130:     )
  131:     tm.assert_frame_equal(result, expected)
  132:     expected = df.rolling("3D").sum()
  133:     tm.assert_frame_equal(result, expected)
  134: 
  135: 
  136: @pytest.mark.parametrize("window", [timedelta(days=3), Timedelta(days=3), "3D"])
  137: def test_constructor_timedelta_window_and_minperiods(window, raw):
  138:     # GH 15305
  139:     n = 10
  140:     df = DataFrame(
  141:         {"value": np.arange(n)},
  142:         index=date_range("2017-08-08", periods=n, freq="D"),
  143:     )
  144:     expected = DataFrame(
  145:         {"value": np.append([np.nan, 1.0], np.arange(3.0, 27.0, 3))},
  146:         index=date_range("2017-08-08", periods=n, freq="D"),
  147:     )
  148:     result_roll_sum = df.rolling(window=window, min_periods=2).sum()
  149:     result_roll_generic = df.rolling(window=window, min_periods=2).apply(sum, raw=raw)
  150:     tm.assert_frame_equal(result_roll_sum, expected)
  151:     tm.assert_frame_equal(result_roll_generic, expected)
  152: 
  153: 
  154: def test_closed_fixed(closed, arithmetic_win_operators):
  155:     # GH 34315
  156:     func_name = arithmetic_win_operators
  157:     df_fixed = DataFrame({"A": [0, 1, 2, 3, 4]})
  158:     df_time = DataFrame({"A": [0, 1, 2, 3, 4]}, index=date_range("2020", periods=5))
  159: 
  160:     result = getattr(
  161:         df_fixed.rolling(2, closed=closed, min_periods=1),
  162:         func_name,
  163:     )()
  164:     expected = getattr(
  165:         df_time.rolling("2D", closed=closed, min_periods=1),
  166:         func_name,
  167:     )().reset_index(drop=True)
  168: 
  169:     tm.assert_frame_equal(result, expected)
  170: 
  171: 
  172: @pytest.mark.parametrize(
  173:     "closed, window_selections",
  174:     [
  175:         (
  176:             "both",
  177:             [
  178:                 [True, True, False, False, False],
  179:                 [True, True, True, False, False],
  180:                 [False, True, True, True, False],
  181:                 [False, False, True, True, True],
  182:                 [False, False, False, True, True],
  183:             ],
  184:         ),
  185:         (
  186:             "left",
  187:             [
  188:                 [True, False, False, False, False],
  189:                 [True, True, False, False, False],
  190:                 [False, True, True, False, False],
  191:                 [False, False, True, True, False],
  192:                 [False, False, False, True, True],
  193:             ],
  194:         ),
  195:         (
  196:             "right",
  197:             [
  198:                 [True, True, False, False, False],
  199:                 [False, True, True, False, False],
  200:                 [False, False, True, True, False],
  201:                 [False, False, False, True, True],
  202:                 [False, False, False, False, True],
  203:             ],
  204:         ),
  205:         (
  206:             "neither",
  207:             [
  208:                 [True, False, False, False, False],
  209:                 [False, True, False, False, False],
  210:                 [False, False, True, False, False],
  211:                 [False, False, False, True, False],
  212:                 [False, False, False, False, True],
  213:             ],
  214:         ),
  215:     ],
  216: )
  217: def test_datetimelike_centered_selections(
  218:     closed, window_selections, arithmetic_win_operators
  219: ):
  220:     # GH 34315
  221:     func_name = arithmetic_win_operators
  222:     df_time = DataFrame(
  223:         {"A": [0.0, 1.0, 2.0, 3.0, 4.0]}, index=date_range("2020", periods=5)
  224:     )
  225: 
  226:     expected = DataFrame(
  227:         {"A": [getattr(df_time["A"].iloc[s], func_name)() for s in window_selections]},
  228:         index=date_range("2020", periods=5),
  229:     )
  230: 
  231:     if func_name == "sem":
  232:         kwargs = {"ddof": 0}
  233:     else:
  234:         kwargs = {}
  235: 
  236:     result = getattr(
  237:         df_time.rolling("2D", closed=closed, min_periods=1, center=True),
  238:         func_name,
  239:     )(**kwargs)
  240: 
  241:     tm.assert_frame_equal(result, expected, check_dtype=False)
  242: 
  243: 
  244: @pytest.mark.parametrize(
  245:     "window,closed,expected",
  246:     [
  247:         ("3s", "right", [3.0, 3.0, 3.0]),
  248:         ("3s", "both", [3.0, 3.0, 3.0]),
  249:         ("3s", "left", [3.0, 3.0, 3.0]),
  250:         ("3s", "neither", [3.0, 3.0, 3.0]),
  251:         ("2s", "right", [3.0, 2.0, 2.0]),
  252:         ("2s", "both", [3.0, 3.0, 3.0]),
  253:         ("2s", "left", [1.0, 3.0, 3.0]),
  254:         ("2s", "neither", [1.0, 2.0, 2.0]),
  255:     ],
  256: )
  257: def test_datetimelike_centered_offset_covers_all(
  258:     window, closed, expected, frame_or_series
  259: ):
  260:     # GH 42753
  261: 
  262:     index = [
  263:         Timestamp("20130101 09:00:01"),
  264:         Timestamp("20130101 09:00:02"),
  265:         Timestamp("20130101 09:00:02"),
  266:     ]
  267:     df = frame_or_series([1, 1, 1], index=index)
  268: 
  269:     result = df.rolling(window, closed=closed, center=True).sum()
  270:     expected = frame_or_series(expected, index=index)
  271:     tm.assert_equal(result, expected)
  272: 
  273: 
  274: @pytest.mark.parametrize(
  275:     "window,closed,expected",
  276:     [
  277:         ("2D", "right", [4, 4, 4, 4, 4, 4, 2, 2]),
  278:         ("2D", "left", [2, 2, 4, 4, 4, 4, 4, 4]),
  279:         ("2D", "both", [4, 4, 6, 6, 6, 6, 4, 4]),
  280:         ("2D", "neither", [2, 2, 2, 2, 2, 2, 2, 2]),
  281:     ],
  282: )
  283: def test_datetimelike_nonunique_index_centering(
  284:     window, closed, expected, frame_or_series
  285: ):
  286:     index = DatetimeIndex(
  287:         [
  288:             "2020-01-01",
  289:             "2020-01-01",
  290:             "2020-01-02",
  291:             "2020-01-02",
  292:             "2020-01-03",
  293:             "2020-01-03",
  294:             "2020-01-04",
  295:             "2020-01-04",
  296:         ]
  297:     )
  298: 
  299:     df = frame_or_series([1] * 8, index=index, dtype=float)
  300:     expected = frame_or_series(expected, index=index, dtype=float)
  301: 
  302:     result = df.rolling(window, center=True, closed=closed).sum()
  303: 
  304:     tm.assert_equal(result, expected)
  305: 
  306: 
  307: @pytest.mark.parametrize(
  308:     "closed,expected",
  309:     [
  310:         ("left", [np.nan, np.nan, 1, 1, 1, 10, 14, 14, 18, 21]),
  311:         ("neither", [np.nan, np.nan, 1, 1, 1, 9, 5, 5, 13, 8]),
  312:         ("right", [0, 1, 3, 6, 10, 14, 11, 18, 21, 17]),
  313:         ("both", [0, 1, 3, 6, 10, 15, 20, 27, 26, 30]),
  314:     ],
  315: )
  316: def test_variable_window_nonunique(closed, expected, frame_or_series):
  317:     # GH 20712
  318:     index = DatetimeIndex(
  319:         [
  320:             "2011-01-01",
  321:             "2011-01-01",
  322:             "2011-01-02",
  323:             "2011-01-02",
  324:             "2011-01-02",
  325:             "2011-01-03",
  326:             "2011-01-04",
  327:             "2011-01-04",
  328:             "2011-01-05",
  329:             "2011-01-06",
  330:         ]
  331:     )
  332: 
  333:     df = frame_or_series(range(10), index=index, dtype=float)
  334:     expected = frame_or_series(expected, index=index, dtype=float)
  335: 
  336:     result = df.rolling("2D", closed=closed).sum()
  337: 
  338:     tm.assert_equal(result, expected)
  339: 
  340: 
  341: @pytest.mark.parametrize(
  342:     "closed,expected",
  343:     [
  344:         ("left", [np.nan, np.nan, 1, 1, 1, 10, 15, 15, 18, 21]),
  345:         ("neither", [np.nan, np.nan, 1, 1, 1, 10, 15, 15, 13, 8]),
  346:         ("right", [0, 1, 3, 6, 10, 15, 21, 28, 21, 17]),
  347:         ("both", [0, 1, 3, 6, 10, 15, 21, 28, 26, 30]),
  348:     ],
  349: )
  350: def test_variable_offset_window_nonunique(closed, expected, frame_or_series):
  351:     # GH 20712
  352:     index = DatetimeIndex(
  353:         [
  354:             "2011-01-01",
  355:             "2011-01-01",
  356:             "2011-01-02",
  357:             "2011-01-02",
  358:             "2011-01-02",
  359:             "2011-01-03",
  360:             "2011-01-04",
  361:             "2011-01-04",
  362:             "2011-01-05",
  363:             "2011-01-06",
  364:         ]
  365:     )
  366: 
  367:     df = frame_or_series(range(10), index=index, dtype=float)
  368:     expected = frame_or_series(expected, index=index, dtype=float)
  369: 
  370:     offset = BusinessDay(2)
  371:     indexer = VariableOffsetWindowIndexer(index=index, offset=offset)
  372:     result = df.rolling(indexer, closed=closed, min_periods=1).sum()
  373: 
  374:     tm.assert_equal(result, expected)
  375: 
  376: 
  377: def test_even_number_window_alignment():
  378:     # see discussion in GH 38780
  379:     s = Series(range(3), index=date_range(start="2020-01-01", freq="D", periods=3))
  380: 
  381:     # behavior of index- and datetime-based windows differs here!
  382:     # s.rolling(window=2, min_periods=1, center=True).mean()
  383: 
  384:     result = s.rolling(window="2D", min_periods=1, center=True).mean()
  385: 
  386:     expected = Series([0.5, 1.5, 2], index=s.index)
  387: 
  388:     tm.assert_series_equal(result, expected)
  389: 
  390: 
  391: def test_closed_fixed_binary_col(center, step):
  392:     # GH 34315
  393:     data = [0, 1, 1, 0, 0, 1, 0, 1]
  394:     df = DataFrame(
  395:         {"binary_col": data},
  396:         index=date_range(start="2020-01-01", freq="min", periods=len(data)),
  397:     )
  398: 
  399:     if center:
  400:         expected_data = [2 / 3, 0.5, 0.4, 0.5, 0.428571, 0.5, 0.571429, 0.5]
  401:     else:
  402:         expected_data = [np.nan, 0, 0.5, 2 / 3, 0.5, 0.4, 0.5, 0.428571]
  403: 
  404:     expected = DataFrame(
  405:         expected_data,
  406:         columns=["binary_col"],
  407:         index=date_range(start="2020-01-01", freq="min", periods=len(expected_data)),
  408:     )[::step]
  409: 
  410:     rolling = df.rolling(
  411:         window=len(df), closed="left", min_periods=1, center=center, step=step
  412:     )
  413:     result = rolling.mean()
  414:     tm.assert_frame_equal(result, expected)
  415: 
  416: 
  417: @pytest.mark.parametrize("closed", ["neither", "left"])
  418: def test_closed_empty(closed, arithmetic_win_operators):
  419:     # GH 26005
  420:     func_name = arithmetic_win_operators
  421:     ser = Series(data=np.arange(5), index=date_range("2000", periods=5, freq="2D"))
  422:     roll = ser.rolling("1D", closed=closed)
  423: 
  424:     result = getattr(roll, func_name)()
  425:     expected = Series([np.nan] * 5, index=ser.index)
  426:     tm.assert_series_equal(result, expected)
  427: 
  428: 
  429: @pytest.mark.parametrize("func", ["min", "max"])
  430: def test_closed_one_entry(func):
  431:     # GH24718
  432:     ser = Series(data=[2], index=date_range("2000", periods=1))
  433:     result = getattr(ser.rolling("10D", closed="left"), func)()
  434:     tm.assert_series_equal(result, Series([np.nan], index=ser.index))
  435: 
  436: 
  437: @pytest.mark.parametrize("func", ["min", "max"])
  438: def test_closed_one_entry_groupby(func):
  439:     # GH24718
  440:     ser = DataFrame(
  441:         data={"A": [1, 1, 2], "B": [3, 2, 1]},
  442:         index=date_range("2000", periods=3),
  443:     )
  444:     result = getattr(
  445:         ser.groupby("A", sort=False)["B"].rolling("10D", closed="left"), func
  446:     )()
  447:     exp_idx = MultiIndex.from_arrays(arrays=[[1, 1, 2], ser.index], names=("A", None))
  448:     expected = Series(data=[np.nan, 3, np.nan], index=exp_idx, name="B")
  449:     tm.assert_series_equal(result, expected)
  450: 
  451: 
  452: @pytest.mark.parametrize("input_dtype", ["int", "float"])
  453: @pytest.mark.parametrize(
  454:     "func,closed,expected",
  455:     [
  456:         ("min", "right", [0.0, 0, 0, 1, 2, 3, 4, 5, 6, 7]),
  457:         ("min", "both", [0.0, 0, 0, 0, 1, 2, 3, 4, 5, 6]),
  458:         ("min", "neither", [np.nan, 0, 0, 1, 2, 3, 4, 5, 6, 7]),
  459:         ("min", "left", [np.nan, 0, 0, 0, 1, 2, 3, 4, 5, 6]),
  460:         ("max", "right", [0.0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),
  461:         ("max", "both", [0.0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),
  462:         ("max", "neither", [np.nan, 0, 1, 2, 3, 4, 5, 6, 7, 8]),
  463:         ("max", "left", [np.nan, 0, 1, 2, 3, 4, 5, 6, 7, 8]),
  464:     ],
  465: )
  466: def test_closed_min_max_datetime(input_dtype, func, closed, expected):
  467:     # see gh-21704
  468:     ser = Series(
  469:         data=np.arange(10).astype(input_dtype),
  470:         index=date_range("2000", periods=10),
  471:     )
  472: 
  473:     result = getattr(ser.rolling("3D", closed=closed), func)()
  474:     expected = Series(expected, index=ser.index)
  475:     tm.assert_series_equal(result, expected)
  476: 
  477: 
  478: def test_closed_uneven():
  479:     # see gh-21704
  480:     ser = Series(data=np.arange(10), index=date_range("2000", periods=10))
  481: 
  482:     # uneven
  483:     ser = ser.drop(index=ser.index[[1, 5]])
  484:     result = ser.rolling("3D", closed="left").min()
  485:     expected = Series([np.nan, 0, 0, 2, 3, 4, 6, 6], index=ser.index)
  486:     tm.assert_series_equal(result, expected)
  487: 
  488: 
  489: @pytest.mark.parametrize(
  490:     "func,closed,expected",
  491:     [
  492:         ("min", "right", [np.nan, 0, 0, 1, 2, 3, 4, 5, np.nan, np.nan]),
  493:         ("min", "both", [np.nan, 0, 0, 0, 1, 2, 3, 4, 5, np.nan]),
  494:         ("min", "neither", [np.nan, np.nan, 0, 1, 2, 3, 4, 5, np.nan, np.nan]),
  495:         ("min", "left", [np.nan, np.nan, 0, 0, 1, 2, 3, 4, 5, np.nan]),
  496:         ("max", "right", [np.nan, 1, 2, 3, 4, 5, 6, 6, np.nan, np.nan]),
  497:         ("max", "both", [np.nan, 1, 2, 3, 4, 5, 6, 6, 6, np.nan]),
  498:         ("max", "neither", [np.nan, np.nan, 1, 2, 3, 4, 5, 6, np.nan, np.nan]),
  499:         ("max", "left", [np.nan, np.nan, 1, 2, 3, 4, 5, 6, 6, np.nan]),
  500:     ],
  501: )
  502: def test_closed_min_max_minp(func, closed, expected):
  503:     # see gh-21704
  504:     ser = Series(data=np.arange(10), index=date_range("2000", periods=10))
  505:     # Explicit cast to float to avoid implicit cast when setting nan
  506:     ser = ser.astype("float")
  507:     ser[ser.index[-3:]] = np.nan
  508:     result = getattr(ser.rolling("3D", min_periods=2, closed=closed), func)()
  509:     expected = Series(expected, index=ser.index)
  510:     tm.assert_series_equal(result, expected)
  511: 
  512: 
  513: @pytest.mark.parametrize(
  514:     "closed,expected",
  515:     [
  516:         ("right", [0, 0.5, 1, 2, 3, 4, 5, 6, 7, 8]),
  517:         ("both", [0, 0.5, 1, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]),
  518:         ("neither", [np.nan, 0, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]),
  519:         ("left", [np.nan, 0, 0.5, 1, 2, 3, 4, 5, 6, 7]),
  520:     ],
  521: )
  522: def test_closed_median_quantile(closed, expected):
  523:     # GH 26005
  524:     ser = Series(data=np.arange(10), index=date_range("2000", periods=10))
  525:     roll = ser.rolling("3D", closed=closed)
  526:     expected = Series(expected, index=ser.index)
  527: 
  528:     result = roll.median()
  529:     tm.assert_series_equal(result, expected)
  530: 
  531:     result = roll.quantile(0.5)
  532:     tm.assert_series_equal(result, expected)
  533: 
  534: 
  535: @pytest.mark.parametrize("roller", ["1s", 1])
  536: def tests_empty_df_rolling(roller):
  537:     # GH 15819 Verifies that datetime and integer rolling windows can be
  538:     # applied to empty DataFrames
  539:     expected = DataFrame()
  540:     result = DataFrame().rolling(roller).sum()
  541:     tm.assert_frame_equal(result, expected)
  542: 
  543:     # Verifies that datetime and integer rolling windows can be applied to
  544:     # empty DataFrames with datetime index
  545:     expected = DataFrame(index=DatetimeIndex([]))
  546:     result = DataFrame(index=DatetimeIndex([])).rolling(roller).sum()
  547:     tm.assert_frame_equal(result, expected)
  548: 
  549: 
  550: def test_empty_window_median_quantile():
  551:     # GH 26005
  552:     expected = Series([np.nan, np.nan, np.nan])
  553:     roll = Series(np.arange(3)).rolling(0)
  554: 
  555:     result = roll.median()
  556:     tm.assert_series_equal(result, expected)
  557: 
  558:     result = roll.quantile(0.1)
  559:     tm.assert_series_equal(result, expected)
  560: 
  561: 
  562: def test_missing_minp_zero():
  563:     # https://github.com/pandas-dev/pandas/pull/18921
  564:     # minp=0
  565:     x = Series([np.nan])
  566:     result = x.rolling(1, min_periods=0).sum()
  567:     expected = Series([0.0])
  568:     tm.assert_series_equal(result, expected)
  569: 
  570:     # minp=1
  571:     result = x.rolling(1, min_periods=1).sum()
  572:     expected = Series([np.nan])
  573:     tm.assert_series_equal(result, expected)
  574: 
  575: 
  576: def test_missing_minp_zero_variable():
  577:     # https://github.com/pandas-dev/pandas/pull/18921
  578:     x = Series(
  579:         [np.nan] * 4,
  580:         index=DatetimeIndex(["2017-01-01", "2017-01-04", "2017-01-06", "2017-01-07"]),
  581:     )
  582:     result = x.rolling(Timedelta("2d"), min_periods=0).sum()
  583:     expected = Series(0.0, index=x.index)
  584:     tm.assert_series_equal(result, expected)
  585: 
  586: 
  587: def test_multi_index_names():
  588:     # GH 16789, 16825
  589:     cols = MultiIndex.from_product([["A", "B"], ["C", "D", "E"]], names=["1", "2"])
  590:     df = DataFrame(np.ones((10, 6)), columns=cols)
  591:     result = df.rolling(3).cov()
  592: 
  593:     tm.assert_index_equal(result.columns, df.columns)
  594:     assert result.index.names == [None, "1", "2"]
  595: 
  596: 
  597: def test_rolling_axis_sum(axis_frame):
  598:     # see gh-23372.
  599:     df = DataFrame(np.ones((10, 20)))
  600:     axis = df._get_axis_number(axis_frame)
  601: 
  602:     if axis == 0:
  603:         msg = "The 'axis' keyword in DataFrame.rolling"
  604:         expected = DataFrame({i: [np.nan] * 2 + [3.0] * 8 for i in range(20)})
  605:     else:
  606:         # axis == 1
  607:         msg = "Support for axis=1 in DataFrame.rolling is deprecated"
  608:         expected = DataFrame([[np.nan] * 2 + [3.0] * 18] * 10)
  609: 
  610:     with tm.assert_produces_warning(FutureWarning, match=msg):
  611:         result = df.rolling(3, axis=axis_frame).sum()
  612:     tm.assert_frame_equal(result, expected)
  613: 
  614: 
  615: def test_rolling_axis_count(axis_frame):
  616:     # see gh-26055
  617:     df = DataFrame({"x": range(3), "y": range(3)})
  618: 
  619:     axis = df._get_axis_number(axis_frame)
  620: 
  621:     if axis in [0, "index"]:
  622:         msg = "The 'axis' keyword in DataFrame.rolling"
  623:         expected = DataFrame({"x": [1.0, 2.0, 2.0], "y": [1.0, 2.0, 2.0]})
  624:     else:
  625:         msg = "Support for axis=1 in DataFrame.rolling is deprecated"
  626:         expected = DataFrame({"x": [1.0, 1.0, 1.0], "y": [2.0, 2.0, 2.0]})
  627: 
  628:     with tm.assert_produces_warning(FutureWarning, match=msg):
  629:         result = df.rolling(2, axis=axis_frame, min_periods=0).count()
  630:     tm.assert_frame_equal(result, expected)
  631: 
  632: 
  633: def test_readonly_array():
  634:     # GH-27766
  635:     arr = np.array([1, 3, np.nan, 3, 5])
  636:     arr.setflags(write=False)
  637:     result = Series(arr).rolling(2).mean()
  638:     expected = Series([np.nan, 2, np.nan, np.nan, 4])
  639:     tm.assert_series_equal(result, expected)
  640: 
  641: 
  642: def test_rolling_datetime(axis_frame, tz_naive_fixture):
  643:     # GH-28192
  644:     tz = tz_naive_fixture
  645:     df = DataFrame(
  646:         {i: [1] * 2 for i in date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)}
  647:     )
  648: 
  649:     if axis_frame in [0, "index"]:
  650:         msg = "The 'axis' keyword in DataFrame.rolling"
  651:         with tm.assert_produces_warning(FutureWarning, match=msg):
  652:             result = df.T.rolling("2D", axis=axis_frame).sum().T
  653:     else:
  654:         msg = "Support for axis=1 in DataFrame.rolling"
  655:         with tm.assert_produces_warning(FutureWarning, match=msg):
  656:             result = df.rolling("2D", axis=axis_frame).sum()
  657:     expected = DataFrame(
  658:         {
  659:             **{
  660:                 i: [1.0] * 2
  661:                 for i in date_range("2019-8-01", periods=1, freq="D", tz=tz)
  662:             },
  663:             **{
  664:                 i: [2.0] * 2
  665:                 for i in date_range("2019-8-02", "2019-8-03", freq="D", tz=tz)
  666:             },
  667:         }
  668:     )
  669:     tm.assert_frame_equal(result, expected)
  670: 
  671: 
  672: @pytest.mark.parametrize("center", [True, False])
  673: def test_rolling_window_as_string(center):
  674:     # see gh-22590
  675:     date_today = datetime.now()
  676:     days = date_range(date_today, date_today + timedelta(365), freq="D")
  677: 
  678:     data = np.ones(len(days))
  679:     df = DataFrame({"DateCol": days, "metric": data})
  680: 
  681:     df.set_index("DateCol", inplace=True)
  682:     result = df.rolling(window="21D", min_periods=2, closed="left", center=center)[
  683:         "metric"
  684:     ].agg("max")
  685: 
  686:     index = days.rename("DateCol")
  687:     index = index._with_freq(None)
  688:     expected_data = np.ones(len(days), dtype=np.float64)
  689:     if not center:
  690:         expected_data[:2] = np.nan
  691:     expected = Series(expected_data, index=index, name="metric")
  692:     tm.assert_series_equal(result, expected)
  693: 
  694: 
  695: def test_min_periods1():
  696:     # GH#6795
  697:     df = DataFrame([0, 1, 2, 1, 0], columns=["a"])
  698:     result = df["a"].rolling(3, center=True, min_periods=1).max()
  699:     expected = Series([1.0, 2.0, 2.0, 2.0, 1.0], name="a")
  700:     tm.assert_series_equal(result, expected)
  701: 
  702: 
  703: def test_rolling_count_with_min_periods(frame_or_series):
  704:     # GH 26996
  705:     result = frame_or_series(range(5)).rolling(3, min_periods=3).count()
  706:     expected = frame_or_series([np.nan, np.nan, 3.0, 3.0, 3.0])
  707:     tm.assert_equal(result, expected)
  708: 
  709: 
  710: def test_rolling_count_default_min_periods_with_null_values(frame_or_series):
  711:     # GH 26996
  712:     values = [1, 2, 3, np.nan, 4, 5, 6]
  713:     expected_counts = [1.0, 2.0, 3.0, 2.0, 2.0, 2.0, 3.0]
  714: 
  715:     # GH 31302
  716:     result = frame_or_series(values).rolling(3, min_periods=0).count()
  717:     expected = frame_or_series(expected_counts)
  718:     tm.assert_equal(result, expected)
  719: 
  720: 
  721: @pytest.mark.parametrize(
  722:     "df,expected,window,min_periods",
  723:     [
  724:         (
  725:             DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}),
  726:             [
  727:                 ({"A": [1], "B": [4]}, [0]),
  728:                 ({"A": [1, 2], "B": [4, 5]}, [0, 1]),
  729:                 ({"A": [1, 2, 3], "B": [4, 5, 6]}, [0, 1, 2]),
  730:             ],
  731:             3,
  732:             None,
  733:         ),
  734:         (
  735:             DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}),
  736:             [
  737:                 ({"A": [1], "B": [4]}, [0]),
  738:                 ({"A": [1, 2], "B": [4, 5]}, [0, 1]),
  739:                 ({"A": [2, 3], "B": [5, 6]}, [1, 2]),
  740:             ],
  741:             2,
  742:             1,
  743:         ),
  744:         (
  745:             DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}),
  746:             [
  747:                 ({"A": [1], "B": [4]}, [0]),
  748:                 ({"A": [1, 2], "B": [4, 5]}, [0, 1]),
  749:                 ({"A": [2, 3], "B": [5, 6]}, [1, 2]),
  750:             ],
  751:             2,
  752:             2,
  753:         ),
  754:         (
  755:             DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}),
  756:             [
  757:                 ({"A": [1], "B": [4]}, [0]),
  758:                 ({"A": [2], "B": [5]}, [1]),
  759:                 ({"A": [3], "B": [6]}, [2]),
  760:             ],
  761:             1,
  762:             1,
  763:         ),
  764:         (
  765:             DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}),
  766:             [
  767:                 ({"A": [1], "B": [4]}, [0]),
  768:                 ({"A": [2], "B": [5]}, [1]),
  769:                 ({"A": [3], "B": [6]}, [2]),
  770:             ],
  771:             1,
  772:             0,
  773:         ),
  774:         (DataFrame({"A": [1], "B": [4]}), [], 2, None),
  775:         (DataFrame({"A": [1], "B": [4]}), [], 2, 1),
  776:         (DataFrame(), [({}, [])], 2, None),
  777:         (
  778:             DataFrame({"A": [1, np.nan, 3], "B": [np.nan, 5, 6]}),
  779:             [
  780:                 ({"A": [1.0], "B": [np.nan]}, [0]),
  781:                 ({"A": [1, np.nan], "B": [np.nan, 5]}, [0, 1]),
  782:                 ({"A": [1, np.nan, 3], "B": [np.nan, 5, 6]}, [0, 1, 2]),
  783:             ],
  784:             3,
  785:             2,
  786:         ),
  787:     ],
  788: )
  789: def test_iter_rolling_dataframe(df, expected, window, min_periods):
  790:     # GH 11704
  791:     expected = [DataFrame(values, index=index) for (values, index) in expected]
  792: 
  793:     for expected, actual in zip(expected, df.rolling(window, min_periods=min_periods)):
  794:         tm.assert_frame_equal(actual, expected)
  795: 
  796: 
  797: @pytest.mark.parametrize(
  798:     "expected,window",
  799:     [
  800:         (
  801:             [
  802:                 ({"A": [1], "B": [4]}, [0]),
  803:                 ({"A": [1, 2], "B": [4, 5]}, [0, 1]),
  804:                 ({"A": [2, 3], "B": [5, 6]}, [1, 2]),
  805:             ],
  806:             "2D",
  807:         ),
  808:         (
  809:             [
  810:                 ({"A": [1], "B": [4]}, [0]),
  811:                 ({"A": [1, 2], "B": [4, 5]}, [0, 1]),
  812:                 ({"A": [1, 2, 3], "B": [4, 5, 6]}, [0, 1, 2]),
  813:             ],
  814:             "3D",
  815:         ),
  816:         (
  817:             [
  818:                 ({"A": [1], "B": [4]}, [0]),
  819:                 ({"A": [2], "B": [5]}, [1]),
  820:                 ({"A": [3], "B": [6]}, [2]),
  821:             ],
  822:             "1D",
  823:         ),
  824:     ],
  825: )
  826: def test_iter_rolling_on_dataframe(expected, window):
  827:     # GH 11704, 40373
  828:     df = DataFrame(
  829:         {
  830:             "A": [1, 2, 3, 4, 5],
  831:             "B": [4, 5, 6, 7, 8],
  832:             "C": date_range(start="2016-01-01", periods=5, freq="D"),
  833:         }
  834:     )
  835: 
  836:     expected = [
  837:         DataFrame(values, index=df.loc[index, "C"]) for (values, index) in expected
  838:     ]
  839:     for expected, actual in zip(expected, df.rolling(window, on="C")):
  840:         tm.assert_frame_equal(actual, expected)
  841: 
  842: 
  843: def test_iter_rolling_on_dataframe_unordered():
  844:     # GH 43386
  845:     df = DataFrame({"a": ["x", "y", "x"], "b": [0, 1, 2]})
  846:     results = list(df.groupby("a").rolling(2))
  847:     expecteds = [df.iloc[idx, [1]] for idx in [[0], [0, 2], [1]]]
  848:     for result, expected in zip(results, expecteds):
  849:         tm.assert_frame_equal(result, expected)
  850: 
  851: 
  852: @pytest.mark.parametrize(
  853:     "ser,expected,window, min_periods",
  854:     [
  855:         (
  856:             Series([1, 2, 3]),
  857:             [([1], [0]), ([1, 2], [0, 1]), ([1, 2, 3], [0, 1, 2])],
  858:             3,
  859:             None,
  860:         ),
  861:         (
  862:             Series([1, 2, 3]),
  863:             [([1], [0]), ([1, 2], [0, 1]), ([1, 2, 3], [0, 1, 2])],
  864:             3,
  865:             1,
  866:         ),
  867:         (
  868:             Series([1, 2, 3]),
  869:             [([1], [0]), ([1, 2], [0, 1]), ([2, 3], [1, 2])],
  870:             2,
  871:             1,
  872:         ),
  873:         (
  874:             Series([1, 2, 3]),
  875:             [([1], [0]), ([1, 2], [0, 1]), ([2, 3], [1, 2])],
  876:             2,
  877:             2,
  878:         ),
  879:         (Series([1, 2, 3]), [([1], [0]), ([2], [1]), ([3], [2])], 1, 0),
  880:         (Series([1, 2, 3]), [([1], [0]), ([2], [1]), ([3], [2])], 1, 1),
  881:         (Series([1, 2]), [([1], [0]), ([1, 2], [0, 1])], 2, 0),
  882:         (Series([], dtype="int64"), [], 2, 1),
  883:     ],
  884: )
  885: def test_iter_rolling_series(ser, expected, window, min_periods):
  886:     # GH 11704
  887:     expected = [Series(values, index=index) for (values, index) in expected]
  888: 
  889:     for expected, actual in zip(expected, ser.rolling(window, min_periods=min_periods)):
  890:         tm.assert_series_equal(actual, expected)
  891: 
  892: 
  893: @pytest.mark.parametrize(
  894:     "expected,expected_index,window",
  895:     [
  896:         (
  897:             [[0], [1], [2], [3], [4]],
  898:             [
  899:                 date_range("2020-01-01", periods=1, freq="D"),
  900:                 date_range("2020-01-02", periods=1, freq="D"),
  901:                 date_range("2020-01-03", periods=1, freq="D"),
  902:                 date_range("2020-01-04", periods=1, freq="D"),
  903:                 date_range("2020-01-05", periods=1, freq="D"),
  904:             ],
  905:             "1D",
  906:         ),
  907:         (
  908:             [[0], [0, 1], [1, 2], [2, 3], [3, 4]],
  909:             [
  910:                 date_range("2020-01-01", periods=1, freq="D"),
  911:                 date_range("2020-01-01", periods=2, freq="D"),
  912:                 date_range("2020-01-02", periods=2, freq="D"),
  913:                 date_range("2020-01-03", periods=2, freq="D"),
  914:                 date_range("2020-01-04", periods=2, freq="D"),
  915:             ],
  916:             "2D",
  917:         ),
  918:         (
  919:             [[0], [0, 1], [0, 1, 2], [1, 2, 3], [2, 3, 4]],
  920:             [
  921:                 date_range("2020-01-01", periods=1, freq="D"),
  922:                 date_range("2020-01-01", periods=2, freq="D"),
  923:                 date_range("2020-01-01", periods=3, freq="D"),
  924:                 date_range("2020-01-02", periods=3, freq="D"),
  925:                 date_range("2020-01-03", periods=3, freq="D"),
  926:             ],
  927:             "3D",
  928:         ),
  929:     ],
  930: )
  931: def test_iter_rolling_datetime(expected, expected_index, window):
  932:     # GH 11704
  933:     ser = Series(range(5), index=date_range(start="2020-01-01", periods=5, freq="D"))
  934: 
  935:     expected = [
  936:         Series(values, index=idx) for (values, idx) in zip(expected, expected_index)
  937:     ]
  938: 
  939:     for expected, actual in zip(expected, ser.rolling(window)):
  940:         tm.assert_series_equal(actual, expected)
  941: 
  942: 
  943: @pytest.mark.parametrize(
  944:     "grouping,_index",
  945:     [
  946:         (
  947:             {"level": 0},
  948:             MultiIndex.from_tuples(
  949:                 [(0, 0), (0, 0), (1, 1), (1, 1), (1, 1)], names=[None, None]
  950:             ),
  951:         ),
  952:         (
  953:             {"by": "X"},
  954:             MultiIndex.from_tuples(
  955:                 [(0, 0), (1, 0), (2, 1), (3, 1), (4, 1)], names=["X", None]
  956:             ),
  957:         ),
  958:     ],
  959: )
  960: def test_rolling_positional_argument(grouping, _index, raw):
  961:     # GH 34605
  962: 
  963:     def scaled_sum(*args):
  964:         if len(args) < 2:
  965:             raise ValueError("The function needs two arguments")
  966:         array, scale = args
  967:         return array.sum() / scale
  968: 
  969:     df = DataFrame(data={"X": range(5)}, index=[0, 0, 1, 1, 1])
  970: 
  971:     expected = DataFrame(data={"X": [0.0, 0.5, 1.0, 1.5, 2.0]}, index=_index)
  972:     # GH 40341
  973:     if "by" in grouping:
  974:         expected = expected.drop(columns="X", errors="ignore")
  975:     result = df.groupby(**grouping).rolling(1).apply(scaled_sum, raw=raw, args=(2,))
  976:     tm.assert_frame_equal(result, expected)
  977: 
  978: 
  979: @pytest.mark.parametrize("add", [0.0, 2.0])
  980: def test_rolling_numerical_accuracy_kahan_mean(add, unit):
  981:     # GH: 36031 implementing kahan summation
  982:     dti = DatetimeIndex(
  983:         [
  984:             Timestamp("19700101 09:00:00"),
  985:             Timestamp("19700101 09:00:03"),
  986:             Timestamp("19700101 09:00:06"),
  987:         ]
  988:     ).as_unit(unit)
  989:     df = DataFrame(
  990:         {"A": [3002399751580331.0 + add, -0.0, -0.0]},
  991:         index=dti,
  992:     )
  993:     result = (
  994:         df.resample("1s").ffill().rolling("3s", closed="left", min_periods=3).mean()
  995:     )
  996:     dates = date_range("19700101 09:00:00", periods=7, freq="s", unit=unit)
  997:     expected = DataFrame(
  998:         {
  999:             "A": [
 1000:                 np.nan,
 1001:                 np.nan,
 1002:                 np.nan,
 1003:                 3002399751580330.5,
 1004:                 2001599834386887.25,
 1005:                 1000799917193443.625,
 1006:                 0.0,
 1007:             ]
 1008:         },
 1009:         index=dates,
 1010:     )
 1011:     tm.assert_frame_equal(result, expected)
 1012: 
 1013: 
 1014: def test_rolling_numerical_accuracy_kahan_sum():
 1015:     # GH: 13254
 1016:     df = DataFrame([2.186, -1.647, 0.0, 0.0, 0.0, 0.0], columns=["x"])
 1017:     result = df["x"].rolling(3).sum()
 1018:     expected = Series([np.nan, np.nan, 0.539, -1.647, 0.0, 0.0], name="x")
 1019:     tm.assert_series_equal(result, expected)
 1020: 
 1021: 
 1022: def test_rolling_numerical_accuracy_jump():
 1023:     # GH: 32761
 1024:     index = date_range(start="2020-01-01", end="2020-01-02", freq="60s").append(
 1025:         DatetimeIndex(["2020-01-03"])
 1026:     )
 1027:     data = np.random.default_rng(2).random(len(index))
 1028: 
 1029:     df = DataFrame({"data": data}, index=index)
 1030:     result = df.rolling("60s").mean()
 1031:     tm.assert_frame_equal(result, df[["data"]])
 1032: 
 1033: 
 1034: def test_rolling_numerical_accuracy_small_values():
 1035:     # GH: 10319
 1036:     s = Series(
 1037:         data=[0.00012456, 0.0003, -0.0, -0.0],
 1038:         index=date_range("1999-02-03", "1999-02-06"),
 1039:     )
 1040:     result = s.rolling(1).mean()
 1041:     tm.assert_series_equal(result, s)
 1042: 
 1043: 
 1044: def test_rolling_numerical_too_large_numbers():
 1045:     # GH: 11645
 1046:     dates = date_range("2015-01-01", periods=10, freq="D")
 1047:     ds = Series(data=range(10), index=dates, dtype=np.float64)
 1048:     ds.iloc[2] = -9e33
 1049:     result = ds.rolling(5).mean()
 1050:     expected = Series(
 1051:         [
 1052:             np.nan,
 1053:             np.nan,
 1054:             np.nan,
 1055:             np.nan,
 1056:             -1.8e33,
 1057:             -1.8e33,
 1058:             -1.8e33,
 1059:             5.0,
 1060:             6.0,
 1061:             7.0,
 1062:         ],
 1063:         index=dates,
 1064:     )
 1065:     tm.assert_series_equal(result, expected)
 1066: 
 1067: 
 1068: @pytest.mark.parametrize(
 1069:     ("func", "value"),
 1070:     [("sum", 2.0), ("max", 1.0), ("min", 1.0), ("mean", 1.0), ("median", 1.0)],
 1071: )
 1072: def test_rolling_mixed_dtypes_axis_1(func, value):
 1073:     # GH: 20649
 1074:     df = DataFrame(1, index=[1, 2], columns=["a", "b", "c"])
 1075:     df["c"] = 1.0
 1076:     msg = "Support for axis=1 in DataFrame.rolling is deprecated"
 1077:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1078:         roll = df.rolling(window=2, min_periods=1, axis=1)
 1079:     result = getattr(roll, func)()
 1080:     expected = DataFrame(
 1081:         {"a": [1.0, 1.0], "b": [value, value], "c": [value, value]},
 1082:         index=[1, 2],
 1083:     )
 1084:     tm.assert_frame_equal(result, expected)
 1085: 
 1086: 
 1087: def test_rolling_axis_one_with_nan():
 1088:     # GH: 35596
 1089:     df = DataFrame(
 1090:         [
 1091:             [0, 1, 2, 4, np.nan, np.nan, np.nan],
 1092:             [0, 1, 2, np.nan, np.nan, np.nan, np.nan],
 1093:             [0, 2, 2, np.nan, 2, np.nan, 1],
 1094:         ]
 1095:     )
 1096:     msg = "Support for axis=1 in DataFrame.rolling is deprecated"
 1097:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1098:         result = df.rolling(window=7, min_periods=1, axis="columns").sum()
 1099:     expected = DataFrame(
 1100:         [
 1101:             [0.0, 1.0, 3.0, 7.0, 7.0, 7.0, 7.0],
 1102:             [0.0, 1.0, 3.0, 3.0, 3.0, 3.0, 3.0],
 1103:             [0.0, 2.0, 4.0, 4.0, 6.0, 6.0, 7.0],
 1104:         ]
 1105:     )
 1106:     tm.assert_frame_equal(result, expected)
 1107: 
 1108: 
 1109: @pytest.mark.parametrize(
 1110:     "value",
 1111:     ["test", to_datetime("2019-12-31"), to_timedelta("1 days 06:05:01.00003")],
 1112: )
 1113: def test_rolling_axis_1_non_numeric_dtypes(value):
 1114:     # GH: 20649
 1115:     df = DataFrame({"a": [1, 2]})
 1116:     df["b"] = value
 1117:     msg = "Support for axis=1 in DataFrame.rolling is deprecated"
 1118:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1119:         result = df.rolling(window=2, min_periods=1, axis=1).sum()
 1120:     expected = DataFrame({"a": [1.0, 2.0]})
 1121:     tm.assert_frame_equal(result, expected)
 1122: 
 1123: 
 1124: def test_rolling_on_df_transposed():
 1125:     # GH: 32724
 1126:     df = DataFrame({"A": [1, None], "B": [4, 5], "C": [7, 8]})
 1127:     expected = DataFrame({"A": [1.0, np.nan], "B": [5.0, 5.0], "C": [11.0, 13.0]})
 1128:     msg = "Support for axis=1 in DataFrame.rolling is deprecated"
 1129:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1130:         result = df.rolling(min_periods=1, window=2, axis=1).sum()
 1131:     tm.assert_frame_equal(result, expected)
 1132: 
 1133:     result = df.T.rolling(min_periods=1, window=2).sum().T
 1134:     tm.assert_frame_equal(result, expected)
 1135: 
 1136: 
 1137: @pytest.mark.parametrize(
 1138:     ("index", "window"),
 1139:     [
 1140:         (
 1141:             period_range(start="2020-01-01 08:00", end="2020-01-01 08:08", freq="min"),
 1142:             "2min",
 1143:         ),
 1144:         (
 1145:             period_range(
 1146:                 start="2020-01-01 08:00", end="2020-01-01 12:00", freq="30min"
 1147:             ),
 1148:             "1h",
 1149:         ),
 1150:     ],
 1151: )
 1152: @pytest.mark.parametrize(
 1153:     ("func", "values"),
 1154:     [
 1155:         ("min", [np.nan, 0, 0, 1, 2, 3, 4, 5, 6]),
 1156:         ("max", [np.nan, 0, 1, 2, 3, 4, 5, 6, 7]),
 1157:         ("sum", [np.nan, 0, 1, 3, 5, 7, 9, 11, 13]),
 1158:     ],
 1159: )
 1160: def test_rolling_period_index(index, window, func, values):
 1161:     # GH: 34225
 1162:     ds = Series([0, 1, 2, 3, 4, 5, 6, 7, 8], index=index)
 1163:     result = getattr(ds.rolling(window, closed="left"), func)()
 1164:     expected = Series(values, index=index)
 1165:     tm.assert_series_equal(result, expected)
 1166: 
 1167: 
 1168: def test_rolling_sem(frame_or_series):
 1169:     # GH: 26476
 1170:     obj = frame_or_series([0, 1, 2])
 1171:     result = obj.rolling(2, min_periods=1).sem()
 1172:     if isinstance(result, DataFrame):
 1173:         result = Series(result[0].values)
 1174:     expected = Series([np.nan] + [0.7071067811865476] * 2)
 1175:     tm.assert_series_equal(result, expected)
 1176: 
 1177: 
 1178: @pytest.mark.xfail(
 1179:     is_platform_arm() or is_platform_power(),
 1180:     reason="GH 38921",
 1181: )
 1182: @pytest.mark.parametrize(
 1183:     ("func", "third_value", "values"),
 1184:     [
 1185:         ("var", 1, [5e33, 0, 0.5, 0.5, 2, 0]),
 1186:         ("std", 1, [7.071068e16, 0, 0.7071068, 0.7071068, 1.414214, 0]),
 1187:         ("var", 2, [5e33, 0.5, 0, 0.5, 2, 0]),
 1188:         ("std", 2, [7.071068e16, 0.7071068, 0, 0.7071068, 1.414214, 0]),
 1189:     ],
 1190: )
 1191: def test_rolling_var_numerical_issues(func, third_value, values):
 1192:     # GH: 37051
 1193:     ds = Series([99999999999999999, 1, third_value, 2, 3, 1, 1])
 1194:     result = getattr(ds.rolling(2), func)()
 1195:     expected = Series([np.nan] + values)
 1196:     tm.assert_series_equal(result, expected)
 1197:     # GH 42064
 1198:     # new `roll_var` will output 0.0 correctly
 1199:     tm.assert_series_equal(result == 0, expected == 0)
 1200: 
 1201: 
 1202: def test_timeoffset_as_window_parameter_for_corr(unit):
 1203:     # GH: 28266
 1204:     dti = DatetimeIndex(
 1205:         [
 1206:             Timestamp("20130101 09:00:00"),
 1207:             Timestamp("20130102 09:00:02"),
 1208:             Timestamp("20130103 09:00:03"),
 1209:             Timestamp("20130105 09:00:05"),
 1210:             Timestamp("20130106 09:00:06"),
 1211:         ]
 1212:     ).as_unit(unit)
 1213:     mi = MultiIndex.from_product([dti, ["B", "A"]])
 1214: 
 1215:     exp = DataFrame(
 1216:         {
 1217:             "B": [
 1218:                 np.nan,
 1219:                 np.nan,
 1220:                 0.9999999999999998,
 1221:                 -1.0,
 1222:                 1.0,
 1223:                 -0.3273268353539892,
 1224:                 0.9999999999999998,
 1225:                 1.0,
 1226:                 0.9999999999999998,
 1227:                 1.0,
 1228:             ],
 1229:             "A": [
 1230:                 np.nan,
 1231:                 np.nan,
 1232:                 -1.0,
 1233:                 1.0000000000000002,
 1234:                 -0.3273268353539892,
 1235:                 0.9999999999999966,
 1236:                 1.0,
 1237:                 1.0000000000000002,
 1238:                 1.0,
 1239:                 1.0000000000000002,
 1240:             ],
 1241:         },
 1242:         index=mi,
 1243:     )
 1244: 
 1245:     df = DataFrame(
 1246:         {"B": [0, 1, 2, 4, 3], "A": [7, 4, 6, 9, 3]},
 1247:         index=dti,
 1248:     )
 1249: 
 1250:     res = df.rolling(window="3d").corr()
 1251: 
 1252:     tm.assert_frame_equal(exp, res)
 1253: 
 1254: 
 1255: @pytest.mark.parametrize("method", ["var", "sum", "mean", "skew", "kurt", "min", "max"])
 1256: def test_rolling_decreasing_indices(method):
 1257:     """
 1258:     Make sure that decreasing indices give the same results as increasing indices.
 1259: 
 1260:     GH 36933
 1261:     """
 1262:     df = DataFrame({"values": np.arange(-15, 10) ** 2})
 1263:     df_reverse = DataFrame({"values": df["values"][::-1]}, index=df.index[::-1])
 1264: 
 1265:     increasing = getattr(df.rolling(window=5), method)()
 1266:     decreasing = getattr(df_reverse.rolling(window=5), method)()
 1267: 
 1268:     assert np.abs(decreasing.values[::-1][:-4] - increasing.values[4:]).max() < 1e-12
 1269: 
 1270: 
 1271: @pytest.mark.parametrize(
 1272:     "window,closed,expected",
 1273:     [
 1274:         ("2s", "right", [1.0, 3.0, 5.0, 3.0]),
 1275:         ("2s", "left", [0.0, 1.0, 3.0, 5.0]),
 1276:         ("2s", "both", [1.0, 3.0, 6.0, 5.0]),
 1277:         ("2s", "neither", [0.0, 1.0, 2.0, 3.0]),
 1278:         ("3s", "right", [1.0, 3.0, 6.0, 5.0]),
 1279:         ("3s", "left", [1.0, 3.0, 6.0, 5.0]),
 1280:         ("3s", "both", [1.0, 3.0, 6.0, 5.0]),
 1281:         ("3s", "neither", [1.0, 3.0, 6.0, 5.0]),
 1282:     ],
 1283: )
 1284: def test_rolling_decreasing_indices_centered(window, closed, expected, frame_or_series):
 1285:     """
 1286:     Ensure that a symmetrical inverted index return same result as non-inverted.
 1287:     """
 1288:     #  GH 43927
 1289: 
 1290:     index = date_range("2020", periods=4, freq="1s")
 1291:     df_inc = frame_or_series(range(4), index=index)
 1292:     df_dec = frame_or_series(range(4), index=index[::-1])
 1293: 
 1294:     expected_inc = frame_or_series(expected, index=index)
 1295:     expected_dec = frame_or_series(expected, index=index[::-1])
 1296: 
 1297:     result_inc = df_inc.rolling(window, closed=closed, center=True).sum()
 1298:     result_dec = df_dec.rolling(window, closed=closed, center=True).sum()
 1299: 
 1300:     tm.assert_equal(result_inc, expected_inc)
 1301:     tm.assert_equal(result_dec, expected_dec)
 1302: 
 1303: 
 1304: @pytest.mark.parametrize(
 1305:     "window,expected",
 1306:     [
 1307:         ("1ns", [1.0, 1.0, 1.0, 1.0]),
 1308:         ("3ns", [2.0, 3.0, 3.0, 2.0]),
 1309:     ],
 1310: )
 1311: def test_rolling_center_nanosecond_resolution(
 1312:     window, closed, expected, frame_or_series
 1313: ):
 1314:     index = date_range("2020", periods=4, freq="1ns")
 1315:     df = frame_or_series([1, 1, 1, 1], index=index, dtype=float)
 1316:     expected = frame_or_series(expected, index=index, dtype=float)
 1317:     result = df.rolling(window, closed=closed, center=True).sum()
 1318:     tm.assert_equal(result, expected)
 1319: 
 1320: 
 1321: @pytest.mark.parametrize(
 1322:     "method,expected",
 1323:     [
 1324:         (
 1325:             "var",
 1326:             [
 1327:                 float("nan"),
 1328:                 43.0,
 1329:                 float("nan"),
 1330:                 136.333333,
 1331:                 43.5,
 1332:                 94.966667,
 1333:                 182.0,
 1334:                 318.0,
 1335:             ],
 1336:         ),
 1337:         (
 1338:             "mean",
 1339:             [float("nan"), 7.5, float("nan"), 21.5, 6.0, 9.166667, 13.0, 17.5],
 1340:         ),
 1341:         (
 1342:             "sum",
 1343:             [float("nan"), 30.0, float("nan"), 86.0, 30.0, 55.0, 91.0, 140.0],
 1344:         ),
 1345:         (
 1346:             "skew",
 1347:             [
 1348:                 float("nan"),
 1349:                 0.709296,
 1350:                 float("nan"),
 1351:                 0.407073,
 1352:                 0.984656,
 1353:                 0.919184,
 1354:                 0.874674,
 1355:                 0.842418,
 1356:             ],
 1357:         ),
 1358:         (
 1359:             "kurt",
 1360:             [
 1361:                 float("nan"),
 1362:                 -0.5916711736073559,
 1363:                 float("nan"),
 1364:                 -1.0028993131317954,
 1365:                 -0.06103844629409494,
 1366:                 -0.254143227116194,
 1367:                 -0.37362637362637585,
 1368:                 -0.45439658241367054,
 1369:             ],
 1370:         ),
 1371:     ],
 1372: )
 1373: def test_rolling_non_monotonic(method, expected):
 1374:     """
 1375:     Make sure the (rare) branch of non-monotonic indices is covered by a test.
 1376: 
 1377:     output from 1.1.3 is assumed to be the expected output. Output of sum/mean has
 1378:     manually been verified.
 1379: 
 1380:     GH 36933.
 1381:     """
 1382:     # Based on an example found in computation.rst
 1383:     use_expanding = [True, False, True, False, True, True, True, True]
 1384:     df = DataFrame({"values": np.arange(len(use_expanding)) ** 2})
 1385: 
 1386:     class CustomIndexer(BaseIndexer):
 1387:         def get_window_bounds(self, num_values, min_periods, center, closed, step):
 1388:             start = np.empty(num_values, dtype=np.int64)
 1389:             end = np.empty(num_values, dtype=np.int64)
 1390:             for i in range(num_values):
 1391:                 if self.use_expanding[i]:
 1392:                     start[i] = 0
 1393:                     end[i] = i + 1
 1394:                 else:
 1395:                     start[i] = i
 1396:                     end[i] = i + self.window_size
 1397:             return start, end
 1398: 
 1399:     indexer = CustomIndexer(window_size=4, use_expanding=use_expanding)
 1400: 
 1401:     result = getattr(df.rolling(indexer), method)()
 1402:     expected = DataFrame({"values": expected})
 1403:     tm.assert_frame_equal(result, expected)
 1404: 
 1405: 
 1406: @pytest.mark.parametrize(
 1407:     ("index", "window"),
 1408:     [
 1409:         ([0, 1, 2, 3, 4], 2),
 1410:         (date_range("2001-01-01", freq="D", periods=5), "2D"),
 1411:     ],
 1412: )
 1413: def test_rolling_corr_timedelta_index(index, window):
 1414:     # GH: 31286
 1415:     x = Series([1, 2, 3, 4, 5], index=index)
 1416:     y = x.copy()
 1417:     x.iloc[0:2] = 0.0
 1418:     result = x.rolling(window).corr(y)
 1419:     expected = Series([np.nan, np.nan, 1, 1, 1], index=index)
 1420:     tm.assert_almost_equal(result, expected)
 1421: 
 1422: 
 1423: def test_groupby_rolling_nan_included():
 1424:     # GH 35542
 1425:     data = {"group": ["g1", np.nan, "g1", "g2", np.nan], "B": [0, 1, 2, 3, 4]}
 1426:     df = DataFrame(data)
 1427:     result = df.groupby("group", dropna=False).rolling(1, min_periods=1).mean()
 1428:     expected = DataFrame(
 1429:         {"B": [0.0, 2.0, 3.0, 1.0, 4.0]},
 1430:         # GH-38057 from_tuples puts the NaNs in the codes, result expects them
 1431:         # to be in the levels, at the moment
 1432:         # index=MultiIndex.from_tuples(
 1433:         #     [("g1", 0), ("g1", 2), ("g2", 3), (np.nan, 1), (np.nan, 4)],
 1434:         #     names=["group", None],
 1435:         # ),
 1436:         index=MultiIndex(
 1437:             [["g1", "g2", np.nan], [0, 1, 2, 3, 4]],
 1438:             [[0, 0, 1, 2, 2], [0, 2, 3, 1, 4]],
 1439:             names=["group", None],
 1440:         ),
 1441:     )
 1442:     tm.assert_frame_equal(result, expected)
 1443: 
 1444: 
 1445: @pytest.mark.parametrize("method", ["skew", "kurt"])
 1446: def test_rolling_skew_kurt_numerical_stability(method):
 1447:     # GH#6929
 1448:     ser = Series(np.random.default_rng(2).random(10))
 1449:     ser_copy = ser.copy()
 1450:     expected = getattr(ser.rolling(3), method)()
 1451:     tm.assert_series_equal(ser, ser_copy)
 1452:     ser = ser + 50000
 1453:     result = getattr(ser.rolling(3), method)()
 1454:     tm.assert_series_equal(result, expected)
 1455: 
 1456: 
 1457: @pytest.mark.parametrize(
 1458:     ("method", "values"),
 1459:     [
 1460:         ("skew", [2.0, 0.854563, 0.0, 1.999984]),
 1461:         ("kurt", [4.0, -1.289256, -1.2, 3.999946]),
 1462:     ],
 1463: )
 1464: def test_rolling_skew_kurt_large_value_range(method, values):
 1465:     # GH: 37557
 1466:     s = Series([3000000, 1, 1, 2, 3, 4, 999])
 1467:     result = getattr(s.rolling(4), method)()
 1468:     expected = Series([np.nan] * 3 + values)
 1469:     tm.assert_series_equal(result, expected)
 1470: 
 1471: 
 1472: def test_invalid_method():
 1473:     with pytest.raises(ValueError, match="method must be 'table' or 'single"):
 1474:         Series(range(1)).rolling(1, method="foo")
 1475: 
 1476: 
 1477: @pytest.mark.parametrize("window", [1, "1d"])
 1478: def test_rolling_descending_date_order_with_offset(window, frame_or_series):
 1479:     # GH#40002
 1480:     idx = date_range(start="2020-01-01", end="2020-01-03", freq="1d")
 1481:     obj = frame_or_series(range(1, 4), index=idx)
 1482:     result = obj.rolling("1d", closed="left").sum()
 1483:     expected = frame_or_series([np.nan, 1, 2], index=idx)
 1484:     tm.assert_equal(result, expected)
 1485: 
 1486:     result = obj.iloc[::-1].rolling("1d", closed="left").sum()
 1487:     idx = date_range(start="2020-01-03", end="2020-01-01", freq="-1d")
 1488:     expected = frame_or_series([np.nan, 3, 2], index=idx)
 1489:     tm.assert_equal(result, expected)
 1490: 
 1491: 
 1492: def test_rolling_var_floating_artifact_precision():
 1493:     # GH 37051
 1494:     s = Series([7, 5, 5, 5])
 1495:     result = s.rolling(3).var()
 1496:     expected = Series([np.nan, np.nan, 4 / 3, 0])
 1497:     tm.assert_series_equal(result, expected, atol=1.0e-15, rtol=1.0e-15)
 1498:     # GH 42064
 1499:     # new `roll_var` will output 0.0 correctly
 1500:     tm.assert_series_equal(result == 0, expected == 0)
 1501: 
 1502: 
 1503: def test_rolling_std_small_values():
 1504:     # GH 37051
 1505:     s = Series(
 1506:         [
 1507:             0.00000054,
 1508:             0.00000053,
 1509:             0.00000054,
 1510:         ]
 1511:     )
 1512:     result = s.rolling(2).std()
 1513:     expected = Series([np.nan, 7.071068e-9, 7.071068e-9])
 1514:     tm.assert_series_equal(result, expected, atol=1.0e-15, rtol=1.0e-15)
 1515: 
 1516: 
 1517: @pytest.mark.parametrize(
 1518:     "start, exp_values",
 1519:     [
 1520:         (1, [0.03, 0.0155, 0.0155, 0.011, 0.01025]),
 1521:         (2, [0.001, 0.001, 0.0015, 0.00366666]),
 1522:     ],
 1523: )
 1524: def test_rolling_mean_all_nan_window_floating_artifacts(start, exp_values):
 1525:     # GH#41053
 1526:     df = DataFrame(
 1527:         [
 1528:             0.03,
 1529:             0.03,
 1530:             0.001,
 1531:             np.nan,
 1532:             0.002,
 1533:             0.008,
 1534:             np.nan,
 1535:             np.nan,
 1536:             np.nan,
 1537:             np.nan,
 1538:             np.nan,
 1539:             np.nan,
 1540:             0.005,
 1541:             0.2,
 1542:         ]
 1543:     )
 1544: 
 1545:     values = exp_values + [
 1546:         0.00366666,
 1547:         0.005,
 1548:         0.005,
 1549:         0.008,
 1550:         np.nan,
 1551:         np.nan,
 1552:         0.005,
 1553:         0.102500,
 1554:     ]
 1555:     expected = DataFrame(
 1556:         values,
 1557:         index=list(range(start, len(values) + start)),
 1558:     )
 1559:     result = df.iloc[start:].rolling(5, min_periods=0).mean()
 1560:     tm.assert_frame_equal(result, expected)
 1561: 
 1562: 
 1563: def test_rolling_sum_all_nan_window_floating_artifacts():
 1564:     # GH#41053
 1565:     df = DataFrame([0.002, 0.008, 0.005, np.nan, np.nan, np.nan])
 1566:     result = df.rolling(3, min_periods=0).sum()
 1567:     expected = DataFrame([0.002, 0.010, 0.015, 0.013, 0.005, 0.0])
 1568:     tm.assert_frame_equal(result, expected)
 1569: 
 1570: 
 1571: def test_rolling_zero_window():
 1572:     # GH 22719
 1573:     s = Series(range(1))
 1574:     result = s.rolling(0).min()
 1575:     expected = Series([np.nan])
 1576:     tm.assert_series_equal(result, expected)
 1577: 
 1578: 
 1579: def test_rolling_float_dtype(float_numpy_dtype):
 1580:     # GH#42452
 1581:     df = DataFrame({"A": range(5), "B": range(10, 15)}, dtype=float_numpy_dtype)
 1582:     expected = DataFrame(
 1583:         {"A": [np.nan] * 5, "B": range(10, 20, 2)},
 1584:         dtype=float_numpy_dtype,
 1585:     )
 1586:     msg = "Support for axis=1 in DataFrame.rolling is deprecated"
 1587:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1588:         result = df.rolling(2, axis=1).sum()
 1589:     tm.assert_frame_equal(result, expected, check_dtype=False)
 1590: 
 1591: 
 1592: def test_rolling_numeric_dtypes():
 1593:     # GH#41779
 1594:     df = DataFrame(np.arange(40).reshape(4, 10), columns=list("abcdefghij")).astype(
 1595:         {
 1596:             "a": "float16",
 1597:             "b": "float32",
 1598:             "c": "float64",
 1599:             "d": "int8",
 1600:             "e": "int16",
 1601:             "f": "int32",
 1602:             "g": "uint8",
 1603:             "h": "uint16",
 1604:             "i": "uint32",
 1605:             "j": "uint64",
 1606:         }
 1607:     )
 1608:     msg = "Support for axis=1 in DataFrame.rolling is deprecated"
 1609:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1610:         result = df.rolling(window=2, min_periods=1, axis=1).min()
 1611:     expected = DataFrame(
 1612:         {
 1613:             "a": range(0, 40, 10),
 1614:             "b": range(0, 40, 10),
 1615:             "c": range(1, 40, 10),
 1616:             "d": range(2, 40, 10),
 1617:             "e": range(3, 40, 10),
 1618:             "f": range(4, 40, 10),
 1619:             "g": range(5, 40, 10),
 1620:             "h": range(6, 40, 10),
 1621:             "i": range(7, 40, 10),
 1622:             "j": range(8, 40, 10),
 1623:         },
 1624:         dtype="float64",
 1625:     )
 1626:     tm.assert_frame_equal(result, expected)
 1627: 
 1628: 
 1629: @pytest.mark.parametrize("window", [1, 3, 10, 20])
 1630: @pytest.mark.parametrize("method", ["min", "max", "average"])
 1631: @pytest.mark.parametrize("pct", [True, False])
 1632: @pytest.mark.parametrize("ascending", [True, False])
 1633: @pytest.mark.parametrize("test_data", ["default", "duplicates", "nans"])
 1634: def test_rank(window, method, pct, ascending, test_data):
 1635:     length = 20
 1636:     if test_data == "default":
 1637:         ser = Series(data=np.random.default_rng(2).random(length))
 1638:     elif test_data == "duplicates":
 1639:         ser = Series(data=np.random.default_rng(2).choice(3, length))
 1640:     elif test_data == "nans":
 1641:         ser = Series(
 1642:             data=np.random.default_rng(2).choice(
 1643:                 [1.0, 0.25, 0.75, np.nan, np.inf, -np.inf], length
 1644:             )
 1645:         )
 1646: 
 1647:     expected = ser.rolling(window).apply(
 1648:         lambda x: x.rank(method=method, pct=pct, ascending=ascending).iloc[-1]
 1649:     )
 1650:     result = ser.rolling(window).rank(method=method, pct=pct, ascending=ascending)
 1651: 
 1652:     tm.assert_series_equal(result, expected)
 1653: 
 1654: 
 1655: def test_rolling_quantile_np_percentile():
 1656:     # #9413: Tests that rolling window's quantile default behavior
 1657:     # is analogous to Numpy's percentile
 1658:     row = 10
 1659:     col = 5
 1660:     idx = date_range("20100101", periods=row, freq="B")
 1661:     df = DataFrame(
 1662:         np.random.default_rng(2).random(row * col).reshape((row, -1)), index=idx
 1663:     )
 1664: 
 1665:     df_quantile = df.quantile([0.25, 0.5, 0.75], axis=0)
 1666:     np_percentile = np.percentile(df, [25, 50, 75], axis=0)
 1667: 
 1668:     tm.assert_almost_equal(df_quantile.values, np.array(np_percentile))
 1669: 
 1670: 
 1671: @pytest.mark.parametrize("quantile", [0.0, 0.1, 0.45, 0.5, 1])
 1672: @pytest.mark.parametrize(
 1673:     "interpolation", ["linear", "lower", "higher", "nearest", "midpoint"]
 1674: )
 1675: @pytest.mark.parametrize(
 1676:     "data",
 1677:     [
 1678:         [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0],
 1679:         [8.0, 1.0, 3.0, 4.0, 5.0, 2.0, 6.0, 7.0],
 1680:         [0.0, np.nan, 0.2, np.nan, 0.4],
 1681:         [np.nan, np.nan, np.nan, np.nan],
 1682:         [np.nan, 0.1, np.nan, 0.3, 0.4, 0.5],
 1683:         [0.5],
 1684:         [np.nan, 0.7, 0.6],
 1685:     ],
 1686: )
 1687: def test_rolling_quantile_interpolation_options(quantile, interpolation, data):
 1688:     # Tests that rolling window's quantile behavior is analogous to
 1689:     # Series' quantile for each interpolation option
 1690:     s = Series(data)
 1691: 
 1692:     q1 = s.quantile(quantile, interpolation)
 1693:     q2 = s.expanding(min_periods=1).quantile(quantile, interpolation).iloc[-1]
 1694: 
 1695:     if np.isnan(q1):
 1696:         assert np.isnan(q2)
 1697:     else:
 1698:         if not IS64:
 1699:             # Less precision on 32-bit
 1700:             assert np.allclose([q1], [q2], rtol=1e-07, atol=0)
 1701:         else:
 1702:             assert q1 == q2
 1703: 
 1704: 
 1705: def test_invalid_quantile_value():
 1706:     data = np.arange(5)
 1707:     s = Series(data)
 1708: 
 1709:     msg = "Interpolation 'invalid' is not supported"
 1710:     with pytest.raises(ValueError, match=msg):
 1711:         s.rolling(len(data), min_periods=1).quantile(0.5, interpolation="invalid")
 1712: 
 1713: 
 1714: def test_rolling_quantile_param():
 1715:     ser = Series([0.0, 0.1, 0.5, 0.9, 1.0])
 1716:     msg = "quantile value -0.1 not in \\[0, 1\\]"
 1717:     with pytest.raises(ValueError, match=msg):
 1718:         ser.rolling(3).quantile(-0.1)
 1719: 
 1720:     msg = "quantile value 10.0 not in \\[0, 1\\]"
 1721:     with pytest.raises(ValueError, match=msg):
 1722:         ser.rolling(3).quantile(10.0)
 1723: 
 1724:     msg = "must be real number, not str"
 1725:     with pytest.raises(TypeError, match=msg):
 1726:         ser.rolling(3).quantile("foo")
 1727: 
 1728: 
 1729: def test_rolling_std_1obs():
 1730:     vals = Series([1.0, 2.0, 3.0, 4.0, 5.0])
 1731: 
 1732:     result = vals.rolling(1, min_periods=1).std()
 1733:     expected = Series([np.nan] * 5)
 1734:     tm.assert_series_equal(result, expected)
 1735: 
 1736:     result = vals.rolling(1, min_periods=1).std(ddof=0)
 1737:     expected = Series([0.0] * 5)
 1738:     tm.assert_series_equal(result, expected)
 1739: 
 1740:     result = Series([np.nan, np.nan, 3, 4, 5]).rolling(3, min_periods=2).std()
 1741:     assert np.isnan(result[2])
 1742: 
 1743: 
 1744: def test_rolling_std_neg_sqrt():
 1745:     # unit test from Bottleneck
 1746: 
 1747:     # Test move_nanstd for neg sqrt.
 1748: 
 1749:     a = Series(
 1750:         [
 1751:             0.0011448196318903589,
 1752:             0.00028718669878572767,
 1753:             0.00028718669878572767,
 1754:             0.00028718669878572767,
 1755:             0.00028718669878572767,
 1756:         ]
 1757:     )
 1758:     b = a.rolling(window=3).std()
 1759:     assert np.isfinite(b[2:]).all()
 1760: 
 1761:     b = a.ewm(span=3).std()
 1762:     assert np.isfinite(b[2:]).all()
 1763: 
 1764: 
 1765: def test_step_not_integer_raises():
 1766:     with pytest.raises(ValueError, match="step must be an integer"):
 1767:         DataFrame(range(2)).rolling(1, step="foo")
 1768: 
 1769: 
 1770: def test_step_not_positive_raises():
 1771:     with pytest.raises(ValueError, match="step must be >= 0"):
 1772:         DataFrame(range(2)).rolling(1, step=-1)
 1773: 
 1774: 
 1775: @pytest.mark.parametrize(
 1776:     ["values", "window", "min_periods", "expected"],
 1777:     [
 1778:         [
 1779:             [20, 10, 10, np.inf, 1, 1, 2, 3],
 1780:             3,
 1781:             1,
 1782:             [np.nan, 50, 100 / 3, 0, 40.5, 0, 1 / 3, 1],
 1783:         ],
 1784:         [
 1785:             [20, 10, 10, np.nan, 10, 1, 2, 3],
 1786:             3,
 1787:             1,
 1788:             [np.nan, 50, 100 / 3, 0, 0, 40.5, 73 / 3, 1],
 1789:         ],
 1790:         [
 1791:             [np.nan, 5, 6, 7, 5, 5, 5],
 1792:             3,
 1793:             3,
 1794:             [np.nan] * 3 + [1, 1, 4 / 3, 0],
 1795:         ],
 1796:         [
 1797:             [5, 7, 7, 7, np.nan, np.inf, 4, 3, 3, 3],
 1798:             3,
 1799:             3,
 1800:             [np.nan] * 2 + [4 / 3, 0] + [np.nan] * 4 + [1 / 3, 0],
 1801:         ],
 1802:         [
 1803:             [5, 7, 7, 7, np.nan, np.inf, 7, 3, 3, 3],
 1804:             3,
 1805:             3,
 1806:             [np.nan] * 2 + [4 / 3, 0] + [np.nan] * 4 + [16 / 3, 0],
 1807:         ],
 1808:         [
 1809:             [5, 7] * 4,
 1810:             3,
 1811:             3,
 1812:             [np.nan] * 2 + [4 / 3] * 6,
 1813:         ],
 1814:         [
 1815:             [5, 7, 5, np.nan, 7, 5, 7],
 1816:             3,
 1817:             2,
 1818:             [np.nan, 2, 4 / 3] + [2] * 3 + [4 / 3],
 1819:         ],
 1820:     ],
 1821: )
 1822: def test_rolling_var_same_value_count_logic(values, window, min_periods, expected):
 1823:     # GH 42064.
 1824: 
 1825:     expected = Series(expected)
 1826:     sr = Series(values)
 1827: 
 1828:     # With new algo implemented, result will be set to .0 in rolling var
 1829:     # if sufficient amount of consecutively same values are found.
 1830:     result_var = sr.rolling(window, min_periods=min_periods).var()
 1831: 
 1832:     # use `assert_series_equal` twice to check for equality,
 1833:     # because `check_exact=True` will fail in 32-bit tests due to
 1834:     # precision loss.
 1835: 
 1836:     # 1. result should be close to correct value
 1837:     # non-zero values can still differ slightly from "truth"
 1838:     # as the result of online algorithm
 1839:     tm.assert_series_equal(result_var, expected)
 1840:     # 2. zeros should be exactly the same since the new algo takes effect here
 1841:     tm.assert_series_equal(expected == 0, result_var == 0)
 1842: 
 1843:     # std should also pass as it's just a sqrt of var
 1844:     result_std = sr.rolling(window, min_periods=min_periods).std()
 1845:     tm.assert_series_equal(result_std, np.sqrt(expected))
 1846:     tm.assert_series_equal(expected == 0, result_std == 0)
 1847: 
 1848: 
 1849: def test_rolling_mean_sum_floating_artifacts():
 1850:     # GH 42064.
 1851: 
 1852:     sr = Series([1 / 3, 4, 0, 0, 0, 0, 0])
 1853:     r = sr.rolling(3)
 1854:     result = r.mean()
 1855:     assert (result[-3:] == 0).all()
 1856:     result = r.sum()
 1857:     assert (result[-3:] == 0).all()
 1858: 
 1859: 
 1860: def test_rolling_skew_kurt_floating_artifacts():
 1861:     # GH 42064 46431
 1862: 
 1863:     sr = Series([1 / 3, 4, 0, 0, 0, 0, 0])
 1864:     r = sr.rolling(4)
 1865:     result = r.skew()
 1866:     assert (result[-2:] == 0).all()
 1867:     result = r.kurt()
 1868:     assert (result[-2:] == -3).all()
 1869: 
 1870: 
 1871: def test_numeric_only_frame(arithmetic_win_operators, numeric_only):
 1872:     # GH#46560
 1873:     kernel = arithmetic_win_operators
 1874:     df = DataFrame({"a": [1], "b": 2, "c": 3})
 1875:     df["c"] = df["c"].astype(object)
 1876:     rolling = df.rolling(2, min_periods=1)
 1877:     op = getattr(rolling, kernel)
 1878:     result = op(numeric_only=numeric_only)
 1879: 
 1880:     columns = ["a", "b"] if numeric_only else ["a", "b", "c"]
 1881:     expected = df[columns].agg([kernel]).reset_index(drop=True).astype(float)
 1882:     assert list(expected.columns) == columns
 1883: 
 1884:     tm.assert_frame_equal(result, expected)
 1885: 
 1886: 
 1887: @pytest.mark.parametrize("kernel", ["corr", "cov"])
 1888: @pytest.mark.parametrize("use_arg", [True, False])
 1889: def test_numeric_only_corr_cov_frame(kernel, numeric_only, use_arg):
 1890:     # GH#46560
 1891:     df = DataFrame({"a": [1, 2, 3], "b": 2, "c": 3})
 1892:     df["c"] = df["c"].astype(object)
 1893:     arg = (df,) if use_arg else ()
 1894:     rolling = df.rolling(2, min_periods=1)
 1895:     op = getattr(rolling, kernel)
 1896:     result = op(*arg, numeric_only=numeric_only)
 1897: 
 1898:     # Compare result to op using float dtypes, dropping c when numeric_only is True
 1899:     columns = ["a", "b"] if numeric_only else ["a", "b", "c"]
 1900:     df2 = df[columns].astype(float)
 1901:     arg2 = (df2,) if use_arg else ()
 1902:     rolling2 = df2.rolling(2, min_periods=1)
 1903:     op2 = getattr(rolling2, kernel)
 1904:     expected = op2(*arg2, numeric_only=numeric_only)
 1905: 
 1906:     tm.assert_frame_equal(result, expected)
 1907: 
 1908: 
 1909: @pytest.mark.parametrize("dtype", [int, object])
 1910: def test_numeric_only_series(arithmetic_win_operators, numeric_only, dtype):
 1911:     # GH#46560
 1912:     kernel = arithmetic_win_operators
 1913:     ser = Series([1], dtype=dtype)
 1914:     rolling = ser.rolling(2, min_periods=1)
 1915:     op = getattr(rolling, kernel)
 1916:     if numeric_only and dtype is object:
 1917:         msg = f"Rolling.{kernel} does not implement numeric_only"
 1918:         with pytest.raises(NotImplementedError, match=msg):
 1919:             op(numeric_only=numeric_only)
 1920:     else:
 1921:         result = op(numeric_only=numeric_only)
 1922:         expected = ser.agg([kernel]).reset_index(drop=True).astype(float)
 1923:         tm.assert_series_equal(result, expected)
 1924: 
 1925: 
 1926: @pytest.mark.parametrize("kernel", ["corr", "cov"])
 1927: @pytest.mark.parametrize("use_arg", [True, False])
 1928: @pytest.mark.parametrize("dtype", [int, object])
 1929: def test_numeric_only_corr_cov_series(kernel, use_arg, numeric_only, dtype):
 1930:     # GH#46560
 1931:     ser = Series([1, 2, 3], dtype=dtype)
 1932:     arg = (ser,) if use_arg else ()
 1933:     rolling = ser.rolling(2, min_periods=1)
 1934:     op = getattr(rolling, kernel)
 1935:     if numeric_only and dtype is object:
 1936:         msg = f"Rolling.{kernel} does not implement numeric_only"
 1937:         with pytest.raises(NotImplementedError, match=msg):
 1938:             op(*arg, numeric_only=numeric_only)
 1939:     else:
 1940:         result = op(*arg, numeric_only=numeric_only)
 1941: 
 1942:         ser2 = ser.astype(float)
 1943:         arg2 = (ser2,) if use_arg else ()
 1944:         rolling2 = ser2.rolling(2, min_periods=1)
 1945:         op2 = getattr(rolling2, kernel)
 1946:         expected = op2(*arg2, numeric_only=numeric_only)
 1947:         tm.assert_series_equal(result, expected)
 1948: 
 1949: 
 1950: @pytest.mark.parametrize("unit", ["s", "ms", "us", "ns"])
 1951: @pytest.mark.parametrize("tz", [None, "UTC", "Europe/Prague"])
 1952: def test_rolling_timedelta_window_non_nanoseconds(unit, tz):
 1953:     # Test Sum, GH#55106
 1954:     df_time = DataFrame(
 1955:         {"A": range(5)}, index=date_range("2013-01-01", freq="1s", periods=5, tz=tz)
 1956:     )
 1957:     sum_in_nanosecs = df_time.rolling("1s").sum()
 1958:     # microseconds / milliseconds should not break the correct rolling
 1959:     df_time.index = df_time.index.as_unit(unit)
 1960:     sum_in_microsecs = df_time.rolling("1s").sum()
 1961:     sum_in_microsecs.index = sum_in_microsecs.index.as_unit("ns")
 1962:     tm.assert_frame_equal(sum_in_nanosecs, sum_in_microsecs)
 1963: 
 1964:     # Test max, GH#55026
 1965:     ref_dates = date_range("2023-01-01", "2023-01-10", unit="ns", tz=tz)
 1966:     ref_series = Series(0, index=ref_dates)
 1967:     ref_series.iloc[0] = 1
 1968:     ref_max_series = ref_series.rolling(Timedelta(days=4)).max()
 1969: 
 1970:     dates = date_range("2023-01-01", "2023-01-10", unit=unit, tz=tz)
 1971:     series = Series(0, index=dates)
 1972:     series.iloc[0] = 1
 1973:     max_series = series.rolling(Timedelta(days=4)).max()
 1974: 
 1975:     ref_df = DataFrame(ref_max_series)
 1976:     df = DataFrame(max_series)
 1977:     df.index = df.index.as_unit("ns")
 1978: 
 1979:     tm.assert_frame_equal(ref_df, df)
