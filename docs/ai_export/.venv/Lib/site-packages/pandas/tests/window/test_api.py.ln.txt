    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import (
    5:     DataError,
    6:     SpecificationError,
    7: )
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     Index,
   12:     MultiIndex,
   13:     Period,
   14:     Series,
   15:     Timestamp,
   16:     concat,
   17:     date_range,
   18:     timedelta_range,
   19: )
   20: import pandas._testing as tm
   21: 
   22: 
   23: def test_getitem(step):
   24:     frame = DataFrame(np.random.default_rng(2).standard_normal((5, 5)))
   25:     r = frame.rolling(window=5, step=step)
   26:     tm.assert_index_equal(r._selected_obj.columns, frame[::step].columns)
   27: 
   28:     r = frame.rolling(window=5, step=step)[1]
   29:     assert r._selected_obj.name == frame[::step].columns[1]
   30: 
   31:     # technically this is allowed
   32:     r = frame.rolling(window=5, step=step)[1, 3]
   33:     tm.assert_index_equal(r._selected_obj.columns, frame[::step].columns[[1, 3]])
   34: 
   35:     r = frame.rolling(window=5, step=step)[[1, 3]]
   36:     tm.assert_index_equal(r._selected_obj.columns, frame[::step].columns[[1, 3]])
   37: 
   38: 
   39: def test_select_bad_cols():
   40:     df = DataFrame([[1, 2]], columns=["A", "B"])
   41:     g = df.rolling(window=5)
   42:     with pytest.raises(KeyError, match="Columns not found: 'C'"):
   43:         g[["C"]]
   44:     with pytest.raises(KeyError, match="^[^A]+$"):
   45:         # A should not be referenced as a bad column...
   46:         # will have to rethink regex if you change message!
   47:         g[["A", "C"]]
   48: 
   49: 
   50: def test_attribute_access():
   51:     df = DataFrame([[1, 2]], columns=["A", "B"])
   52:     r = df.rolling(window=5)
   53:     tm.assert_series_equal(r.A.sum(), r["A"].sum())
   54:     msg = "'Rolling' object has no attribute 'F'"
   55:     with pytest.raises(AttributeError, match=msg):
   56:         r.F
   57: 
   58: 
   59: def tests_skip_nuisance(step):
   60:     df = DataFrame({"A": range(5), "B": range(5, 10), "C": "foo"})
   61:     r = df.rolling(window=3, step=step)
   62:     result = r[["A", "B"]].sum()
   63:     expected = DataFrame(
   64:         {"A": [np.nan, np.nan, 3, 6, 9], "B": [np.nan, np.nan, 18, 21, 24]},
   65:         columns=list("AB"),
   66:     )[::step]
   67:     tm.assert_frame_equal(result, expected)
   68: 
   69: 
   70: def test_sum_object_str_raises(step):
   71:     df = DataFrame({"A": range(5), "B": range(5, 10), "C": "foo"})
   72:     r = df.rolling(window=3, step=step)
   73:     with pytest.raises(
   74:         DataError, match="Cannot aggregate non-numeric type: object|string"
   75:     ):
   76:         # GH#42738, enforced in 2.0
   77:         r.sum()
   78: 
   79: 
   80: def test_agg(step):
   81:     df = DataFrame({"A": range(5), "B": range(0, 10, 2)})
   82: 
   83:     r = df.rolling(window=3, step=step)
   84:     a_mean = r["A"].mean()
   85:     a_std = r["A"].std()
   86:     a_sum = r["A"].sum()
   87:     b_mean = r["B"].mean()
   88:     b_std = r["B"].std()
   89: 
   90:     with tm.assert_produces_warning(FutureWarning, match="using Rolling.[mean|std]"):
   91:         result = r.aggregate([np.mean, np.std])
   92:     expected = concat([a_mean, a_std, b_mean, b_std], axis=1)
   93:     expected.columns = MultiIndex.from_product([["A", "B"], ["mean", "std"]])
   94:     tm.assert_frame_equal(result, expected)
   95: 
   96:     with tm.assert_produces_warning(FutureWarning, match="using Rolling.[mean|std]"):
   97:         result = r.aggregate({"A": np.mean, "B": np.std})
   98: 
   99:     expected = concat([a_mean, b_std], axis=1)
  100:     tm.assert_frame_equal(result, expected, check_like=True)
  101: 
  102:     result = r.aggregate({"A": ["mean", "std"]})
  103:     expected = concat([a_mean, a_std], axis=1)
  104:     expected.columns = MultiIndex.from_tuples([("A", "mean"), ("A", "std")])
  105:     tm.assert_frame_equal(result, expected)
  106: 
  107:     result = r["A"].aggregate(["mean", "sum"])
  108:     expected = concat([a_mean, a_sum], axis=1)
  109:     expected.columns = ["mean", "sum"]
  110:     tm.assert_frame_equal(result, expected)
  111: 
  112:     msg = "nested renamer is not supported"
  113:     with pytest.raises(SpecificationError, match=msg):
  114:         # using a dict with renaming
  115:         r.aggregate({"A": {"mean": "mean", "sum": "sum"}})
  116: 
  117:     with pytest.raises(SpecificationError, match=msg):
  118:         r.aggregate(
  119:             {"A": {"mean": "mean", "sum": "sum"}, "B": {"mean2": "mean", "sum2": "sum"}}
  120:         )
  121: 
  122:     result = r.aggregate({"A": ["mean", "std"], "B": ["mean", "std"]})
  123:     expected = concat([a_mean, a_std, b_mean, b_std], axis=1)
  124: 
  125:     exp_cols = [("A", "mean"), ("A", "std"), ("B", "mean"), ("B", "std")]
  126:     expected.columns = MultiIndex.from_tuples(exp_cols)
  127:     tm.assert_frame_equal(result, expected, check_like=True)
  128: 
  129: 
  130: @pytest.mark.parametrize(
  131:     "func", [["min"], ["mean", "max"], {"b": "sum"}, {"b": "prod", "c": "median"}]
  132: )
  133: def test_multi_axis_1_raises(func):
  134:     # GH#46904
  135:     df = DataFrame({"a": [1, 1, 2], "b": [3, 4, 5], "c": [6, 7, 8]})
  136:     msg = "Support for axis=1 in DataFrame.rolling is deprecated"
  137:     with tm.assert_produces_warning(FutureWarning, match=msg):
  138:         r = df.rolling(window=3, axis=1)
  139:     with pytest.raises(NotImplementedError, match="axis other than 0 is not supported"):
  140:         r.agg(func)
  141: 
  142: 
  143: def test_agg_apply(raw):
  144:     # passed lambda
  145:     df = DataFrame({"A": range(5), "B": range(0, 10, 2)})
  146: 
  147:     r = df.rolling(window=3)
  148:     a_sum = r["A"].sum()
  149: 
  150:     with tm.assert_produces_warning(FutureWarning, match="using Rolling.[sum|std]"):
  151:         result = r.agg({"A": np.sum, "B": lambda x: np.std(x, ddof=1)})
  152:     rcustom = r["B"].apply(lambda x: np.std(x, ddof=1), raw=raw)
  153:     expected = concat([a_sum, rcustom], axis=1)
  154:     tm.assert_frame_equal(result, expected, check_like=True)
  155: 
  156: 
  157: def test_agg_consistency(step):
  158:     df = DataFrame({"A": range(5), "B": range(0, 10, 2)})
  159:     r = df.rolling(window=3, step=step)
  160: 
  161:     with tm.assert_produces_warning(FutureWarning, match="using Rolling.[sum|mean]"):
  162:         result = r.agg([np.sum, np.mean]).columns
  163:     expected = MultiIndex.from_product([list("AB"), ["sum", "mean"]])
  164:     tm.assert_index_equal(result, expected)
  165: 
  166:     with tm.assert_produces_warning(FutureWarning, match="using Rolling.[sum|mean]"):
  167:         result = r["A"].agg([np.sum, np.mean]).columns
  168:     expected = Index(["sum", "mean"])
  169:     tm.assert_index_equal(result, expected)
  170: 
  171:     with tm.assert_produces_warning(FutureWarning, match="using Rolling.[sum|mean]"):
  172:         result = r.agg({"A": [np.sum, np.mean]}).columns
  173:     expected = MultiIndex.from_tuples([("A", "sum"), ("A", "mean")])
  174:     tm.assert_index_equal(result, expected)
  175: 
  176: 
  177: def test_agg_nested_dicts():
  178:     # API change for disallowing these types of nested dicts
  179:     df = DataFrame({"A": range(5), "B": range(0, 10, 2)})
  180:     r = df.rolling(window=3)
  181: 
  182:     msg = "nested renamer is not supported"
  183:     with pytest.raises(SpecificationError, match=msg):
  184:         r.aggregate({"r1": {"A": ["mean", "sum"]}, "r2": {"B": ["mean", "sum"]}})
  185: 
  186:     expected = concat(
  187:         [r["A"].mean(), r["A"].std(), r["B"].mean(), r["B"].std()], axis=1
  188:     )
  189:     expected.columns = MultiIndex.from_tuples(
  190:         [("ra", "mean"), ("ra", "std"), ("rb", "mean"), ("rb", "std")]
  191:     )
  192:     with pytest.raises(SpecificationError, match=msg):
  193:         r[["A", "B"]].agg({"A": {"ra": ["mean", "std"]}, "B": {"rb": ["mean", "std"]}})
  194: 
  195:     with pytest.raises(SpecificationError, match=msg):
  196:         r.agg({"A": {"ra": ["mean", "std"]}, "B": {"rb": ["mean", "std"]}})
  197: 
  198: 
  199: def test_count_nonnumeric_types(step):
  200:     # GH12541
  201:     cols = [
  202:         "int",
  203:         "float",
  204:         "string",
  205:         "datetime",
  206:         "timedelta",
  207:         "periods",
  208:         "fl_inf",
  209:         "fl_nan",
  210:         "str_nan",
  211:         "dt_nat",
  212:         "periods_nat",
  213:     ]
  214:     dt_nat_col = [Timestamp("20170101"), Timestamp("20170203"), Timestamp(None)]
  215: 
  216:     df = DataFrame(
  217:         {
  218:             "int": [1, 2, 3],
  219:             "float": [4.0, 5.0, 6.0],
  220:             "string": list("abc"),
  221:             "datetime": date_range("20170101", periods=3),
  222:             "timedelta": timedelta_range("1 s", periods=3, freq="s"),
  223:             "periods": [
  224:                 Period("2012-01"),
  225:                 Period("2012-02"),
  226:                 Period("2012-03"),
  227:             ],
  228:             "fl_inf": [1.0, 2.0, np.inf],
  229:             "fl_nan": [1.0, 2.0, np.nan],
  230:             "str_nan": ["aa", "bb", np.nan],
  231:             "dt_nat": dt_nat_col,
  232:             "periods_nat": [
  233:                 Period("2012-01"),
  234:                 Period("2012-02"),
  235:                 Period(None),
  236:             ],
  237:         },
  238:         columns=cols,
  239:     )
  240: 
  241:     expected = DataFrame(
  242:         {
  243:             "int": [1.0, 2.0, 2.0],
  244:             "float": [1.0, 2.0, 2.0],
  245:             "string": [1.0, 2.0, 2.0],
  246:             "datetime": [1.0, 2.0, 2.0],
  247:             "timedelta": [1.0, 2.0, 2.0],
  248:             "periods": [1.0, 2.0, 2.0],
  249:             "fl_inf": [1.0, 2.0, 2.0],
  250:             "fl_nan": [1.0, 2.0, 1.0],
  251:             "str_nan": [1.0, 2.0, 1.0],
  252:             "dt_nat": [1.0, 2.0, 1.0],
  253:             "periods_nat": [1.0, 2.0, 1.0],
  254:         },
  255:         columns=cols,
  256:     )[::step]
  257: 
  258:     result = df.rolling(window=2, min_periods=0, step=step).count()
  259:     tm.assert_frame_equal(result, expected)
  260: 
  261:     result = df.rolling(1, min_periods=0, step=step).count()
  262:     expected = df.notna().astype(float)[::step]
  263:     tm.assert_frame_equal(result, expected)
  264: 
  265: 
  266: def test_preserve_metadata():
  267:     # GH 10565
  268:     s = Series(np.arange(100), name="foo")
  269: 
  270:     s2 = s.rolling(30).sum()
  271:     s3 = s.rolling(20).sum()
  272:     assert s2.name == "foo"
  273:     assert s3.name == "foo"
  274: 
  275: 
  276: @pytest.mark.parametrize(
  277:     "func,window_size,expected_vals",
  278:     [
  279:         (
  280:             "rolling",
  281:             2,
  282:             [
  283:                 [np.nan, np.nan, np.nan, np.nan],
  284:                 [15.0, 20.0, 25.0, 20.0],
  285:                 [25.0, 30.0, 35.0, 30.0],
  286:                 [np.nan, np.nan, np.nan, np.nan],
  287:                 [20.0, 30.0, 35.0, 30.0],
  288:                 [35.0, 40.0, 60.0, 40.0],
  289:                 [60.0, 80.0, 85.0, 80],
  290:             ],
  291:         ),
  292:         (
  293:             "expanding",
  294:             None,
  295:             [
  296:                 [10.0, 10.0, 20.0, 20.0],
  297:                 [15.0, 20.0, 25.0, 20.0],
  298:                 [20.0, 30.0, 30.0, 20.0],
  299:                 [10.0, 10.0, 30.0, 30.0],
  300:                 [20.0, 30.0, 35.0, 30.0],
  301:                 [26.666667, 40.0, 50.0, 30.0],
  302:                 [40.0, 80.0, 60.0, 30.0],
  303:             ],
  304:         ),
  305:     ],
  306: )
  307: def test_multiple_agg_funcs(func, window_size, expected_vals):
  308:     # GH 15072
  309:     df = DataFrame(
  310:         [
  311:             ["A", 10, 20],
  312:             ["A", 20, 30],
  313:             ["A", 30, 40],
  314:             ["B", 10, 30],
  315:             ["B", 30, 40],
  316:             ["B", 40, 80],
  317:             ["B", 80, 90],
  318:         ],
  319:         columns=["stock", "low", "high"],
  320:     )
  321: 
  322:     f = getattr(df.groupby("stock"), func)
  323:     if window_size:
  324:         window = f(window_size)
  325:     else:
  326:         window = f()
  327: 
  328:     index = MultiIndex.from_tuples(
  329:         [("A", 0), ("A", 1), ("A", 2), ("B", 3), ("B", 4), ("B", 5), ("B", 6)],
  330:         names=["stock", None],
  331:     )
  332:     columns = MultiIndex.from_tuples(
  333:         [("low", "mean"), ("low", "max"), ("high", "mean"), ("high", "min")]
  334:     )
  335:     expected = DataFrame(expected_vals, index=index, columns=columns)
  336: 
  337:     result = window.agg({"low": ["mean", "max"], "high": ["mean", "min"]})
  338: 
  339:     tm.assert_frame_equal(result, expected)
  340: 
  341: 
  342: def test_dont_modify_attributes_after_methods(
  343:     arithmetic_win_operators, closed, center, min_periods, step
  344: ):
  345:     # GH 39554
  346:     roll_obj = Series(range(1)).rolling(
  347:         1, center=center, closed=closed, min_periods=min_periods, step=step
  348:     )
  349:     expected = {attr: getattr(roll_obj, attr) for attr in roll_obj._attributes}
  350:     getattr(roll_obj, arithmetic_win_operators)()
  351:     result = {attr: getattr(roll_obj, attr) for attr in roll_obj._attributes}
  352:     assert result == expected
  353: 
  354: 
  355: def test_centered_axis_validation(step):
  356:     # ok
  357:     msg = "The 'axis' keyword in Series.rolling is deprecated"
  358:     with tm.assert_produces_warning(FutureWarning, match=msg):
  359:         Series(np.ones(10)).rolling(window=3, center=True, axis=0, step=step).mean()
  360: 
  361:     # bad axis
  362:     msg = "No axis named 1 for object type Series"
  363:     with pytest.raises(ValueError, match=msg):
  364:         Series(np.ones(10)).rolling(window=3, center=True, axis=1, step=step).mean()
  365: 
  366:     # ok ok
  367:     df = DataFrame(np.ones((10, 10)))
  368:     msg = "The 'axis' keyword in DataFrame.rolling is deprecated"
  369:     with tm.assert_produces_warning(FutureWarning, match=msg):
  370:         df.rolling(window=3, center=True, axis=0, step=step).mean()
  371:     msg = "Support for axis=1 in DataFrame.rolling is deprecated"
  372:     with tm.assert_produces_warning(FutureWarning, match=msg):
  373:         df.rolling(window=3, center=True, axis=1, step=step).mean()
  374: 
  375:     # bad axis
  376:     msg = "No axis named 2 for object type DataFrame"
  377:     with pytest.raises(ValueError, match=msg):
  378:         (df.rolling(window=3, center=True, axis=2, step=step).mean())
  379: 
  380: 
  381: def test_rolling_min_min_periods(step):
  382:     a = Series([1, 2, 3, 4, 5])
  383:     result = a.rolling(window=100, min_periods=1, step=step).min()
  384:     expected = Series(np.ones(len(a)))[::step]
  385:     tm.assert_series_equal(result, expected)
  386:     msg = "min_periods 5 must be <= window 3"
  387:     with pytest.raises(ValueError, match=msg):
  388:         Series([1, 2, 3]).rolling(window=3, min_periods=5, step=step).min()
  389: 
  390: 
  391: def test_rolling_max_min_periods(step):
  392:     a = Series([1, 2, 3, 4, 5], dtype=np.float64)
  393:     result = a.rolling(window=100, min_periods=1, step=step).max()
  394:     expected = a[::step]
  395:     tm.assert_almost_equal(result, expected)
  396:     msg = "min_periods 5 must be <= window 3"
  397:     with pytest.raises(ValueError, match=msg):
  398:         Series([1, 2, 3]).rolling(window=3, min_periods=5, step=step).max()
