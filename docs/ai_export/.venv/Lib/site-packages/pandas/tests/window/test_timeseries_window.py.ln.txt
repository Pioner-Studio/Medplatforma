    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: from pandas import (
    7:     DataFrame,
    8:     DatetimeIndex,
    9:     Index,
   10:     MultiIndex,
   11:     NaT,
   12:     Series,
   13:     Timestamp,
   14:     date_range,
   15: )
   16: import pandas._testing as tm
   17: 
   18: from pandas.tseries import offsets
   19: 
   20: 
   21: @pytest.fixture
   22: def regular():
   23:     return DataFrame(
   24:         {"A": date_range("20130101", periods=5, freq="s"), "B": range(5)}
   25:     ).set_index("A")
   26: 
   27: 
   28: @pytest.fixture
   29: def ragged():
   30:     df = DataFrame({"B": range(5)})
   31:     df.index = [
   32:         Timestamp("20130101 09:00:00"),
   33:         Timestamp("20130101 09:00:02"),
   34:         Timestamp("20130101 09:00:03"),
   35:         Timestamp("20130101 09:00:05"),
   36:         Timestamp("20130101 09:00:06"),
   37:     ]
   38:     return df
   39: 
   40: 
   41: class TestRollingTS:
   42:     # rolling time-series friendly
   43:     # xref GH13327
   44: 
   45:     def test_doc_string(self):
   46:         df = DataFrame(
   47:             {"B": [0, 1, 2, np.nan, 4]},
   48:             index=[
   49:                 Timestamp("20130101 09:00:00"),
   50:                 Timestamp("20130101 09:00:02"),
   51:                 Timestamp("20130101 09:00:03"),
   52:                 Timestamp("20130101 09:00:05"),
   53:                 Timestamp("20130101 09:00:06"),
   54:             ],
   55:         )
   56:         df
   57:         df.rolling("2s").sum()
   58: 
   59:     def test_invalid_window_non_int(self, regular):
   60:         # not a valid freq
   61:         msg = "passed window foobar is not compatible with a datetimelike index"
   62:         with pytest.raises(ValueError, match=msg):
   63:             regular.rolling(window="foobar")
   64:         # not a datetimelike index
   65:         msg = "window must be an integer"
   66:         with pytest.raises(ValueError, match=msg):
   67:             regular.reset_index().rolling(window="foobar")
   68: 
   69:     @pytest.mark.parametrize("freq", ["2MS", offsets.MonthBegin(2)])
   70:     def test_invalid_window_nonfixed(self, freq, regular):
   71:         # non-fixed freqs
   72:         msg = "\\<2 \\* MonthBegins\\> is a non-fixed frequency"
   73:         with pytest.raises(ValueError, match=msg):
   74:             regular.rolling(window=freq)
   75: 
   76:     @pytest.mark.parametrize("freq", ["1D", offsets.Day(2), "2ms"])
   77:     def test_valid_window(self, freq, regular):
   78:         regular.rolling(window=freq)
   79: 
   80:     @pytest.mark.parametrize("minp", [1.0, "foo", np.array([1, 2, 3])])
   81:     def test_invalid_minp(self, minp, regular):
   82:         # non-integer min_periods
   83:         msg = (
   84:             r"local variable 'minp' referenced before assignment|"
   85:             "min_periods must be an integer"
   86:         )
   87:         with pytest.raises(ValueError, match=msg):
   88:             regular.rolling(window="1D", min_periods=minp)
   89: 
   90:     def test_on(self, regular):
   91:         df = regular
   92: 
   93:         # not a valid column
   94:         msg = (
   95:             r"invalid on specified as foobar, must be a column "
   96:             "\\(of DataFrame\\), an Index or None"
   97:         )
   98:         with pytest.raises(ValueError, match=msg):
   99:             df.rolling(window="2s", on="foobar")
  100: 
  101:         # column is valid
  102:         df = df.copy()
  103:         df["C"] = date_range("20130101", periods=len(df))
  104:         df.rolling(window="2d", on="C").sum()
  105: 
  106:         # invalid columns
  107:         msg = "window must be an integer"
  108:         with pytest.raises(ValueError, match=msg):
  109:             df.rolling(window="2d", on="B")
  110: 
  111:         # ok even though on non-selected
  112:         df.rolling(window="2d", on="C").B.sum()
  113: 
  114:     def test_monotonic_on(self):
  115:         # on/index must be monotonic
  116:         df = DataFrame(
  117:             {"A": date_range("20130101", periods=5, freq="s"), "B": range(5)}
  118:         )
  119: 
  120:         assert df.A.is_monotonic_increasing
  121:         df.rolling("2s", on="A").sum()
  122: 
  123:         df = df.set_index("A")
  124:         assert df.index.is_monotonic_increasing
  125:         df.rolling("2s").sum()
  126: 
  127:     def test_non_monotonic_on(self):
  128:         # GH 19248
  129:         df = DataFrame(
  130:             {"A": date_range("20130101", periods=5, freq="s"), "B": range(5)}
  131:         )
  132:         df = df.set_index("A")
  133:         non_monotonic_index = df.index.to_list()
  134:         non_monotonic_index[0] = non_monotonic_index[3]
  135:         df.index = non_monotonic_index
  136: 
  137:         assert not df.index.is_monotonic_increasing
  138: 
  139:         msg = "index values must be monotonic"
  140:         with pytest.raises(ValueError, match=msg):
  141:             df.rolling("2s").sum()
  142: 
  143:         df = df.reset_index()
  144: 
  145:         msg = (
  146:             r"invalid on specified as A, must be a column "
  147:             "\\(of DataFrame\\), an Index or None"
  148:         )
  149:         with pytest.raises(ValueError, match=msg):
  150:             df.rolling("2s", on="A").sum()
  151: 
  152:     def test_frame_on(self):
  153:         df = DataFrame(
  154:             {"B": range(5), "C": date_range("20130101 09:00:00", periods=5, freq="3s")}
  155:         )
  156: 
  157:         df["A"] = [
  158:             Timestamp("20130101 09:00:00"),
  159:             Timestamp("20130101 09:00:02"),
  160:             Timestamp("20130101 09:00:03"),
  161:             Timestamp("20130101 09:00:05"),
  162:             Timestamp("20130101 09:00:06"),
  163:         ]
  164: 
  165:         # we are doing simulating using 'on'
  166:         expected = df.set_index("A").rolling("2s").B.sum().reset_index(drop=True)
  167: 
  168:         result = df.rolling("2s", on="A").B.sum()
  169:         tm.assert_series_equal(result, expected)
  170: 
  171:         # test as a frame
  172:         # we should be ignoring the 'on' as an aggregation column
  173:         # note that the expected is setting, computing, and resetting
  174:         # so the columns need to be switched compared
  175:         # to the actual result where they are ordered as in the
  176:         # original
  177:         expected = (
  178:             df.set_index("A").rolling("2s")[["B"]].sum().reset_index()[["B", "A"]]
  179:         )
  180: 
  181:         result = df.rolling("2s", on="A")[["B"]].sum()
  182:         tm.assert_frame_equal(result, expected)
  183: 
  184:     def test_frame_on2(self, unit):
  185:         # using multiple aggregation columns
  186:         dti = DatetimeIndex(
  187:             [
  188:                 Timestamp("20130101 09:00:00"),
  189:                 Timestamp("20130101 09:00:02"),
  190:                 Timestamp("20130101 09:00:03"),
  191:                 Timestamp("20130101 09:00:05"),
  192:                 Timestamp("20130101 09:00:06"),
  193:             ]
  194:         ).as_unit(unit)
  195:         df = DataFrame(
  196:             {
  197:                 "A": [0, 1, 2, 3, 4],
  198:                 "B": [0, 1, 2, np.nan, 4],
  199:                 "C": dti,
  200:             },
  201:             columns=["A", "C", "B"],
  202:         )
  203: 
  204:         expected1 = DataFrame(
  205:             {"A": [0.0, 1, 3, 3, 7], "B": [0, 1, 3, np.nan, 4], "C": df["C"]},
  206:             columns=["A", "C", "B"],
  207:         )
  208: 
  209:         result = df.rolling("2s", on="C").sum()
  210:         expected = expected1
  211:         tm.assert_frame_equal(result, expected)
  212: 
  213:         expected = Series([0, 1, 3, np.nan, 4], name="B")
  214:         result = df.rolling("2s", on="C").B.sum()
  215:         tm.assert_series_equal(result, expected)
  216: 
  217:         expected = expected1[["A", "B", "C"]]
  218:         result = df.rolling("2s", on="C")[["A", "B", "C"]].sum()
  219:         tm.assert_frame_equal(result, expected)
  220: 
  221:     def test_basic_regular(self, regular):
  222:         df = regular.copy()
  223: 
  224:         df.index = date_range("20130101", periods=5, freq="D")
  225:         expected = df.rolling(window=1, min_periods=1).sum()
  226:         result = df.rolling(window="1D").sum()
  227:         tm.assert_frame_equal(result, expected)
  228: 
  229:         df.index = date_range("20130101", periods=5, freq="2D")
  230:         expected = df.rolling(window=1, min_periods=1).sum()
  231:         result = df.rolling(window="2D", min_periods=1).sum()
  232:         tm.assert_frame_equal(result, expected)
  233: 
  234:         expected = df.rolling(window=1, min_periods=1).sum()
  235:         result = df.rolling(window="2D", min_periods=1).sum()
  236:         tm.assert_frame_equal(result, expected)
  237: 
  238:         expected = df.rolling(window=1).sum()
  239:         result = df.rolling(window="2D").sum()
  240:         tm.assert_frame_equal(result, expected)
  241: 
  242:     def test_min_periods(self, regular):
  243:         # compare for min_periods
  244:         df = regular
  245: 
  246:         # these slightly different
  247:         expected = df.rolling(2, min_periods=1).sum()
  248:         result = df.rolling("2s").sum()
  249:         tm.assert_frame_equal(result, expected)
  250: 
  251:         expected = df.rolling(2, min_periods=1).sum()
  252:         result = df.rolling("2s", min_periods=1).sum()
  253:         tm.assert_frame_equal(result, expected)
  254: 
  255:     def test_closed(self, regular, unit):
  256:         # xref GH13965
  257: 
  258:         dti = DatetimeIndex(
  259:             [
  260:                 Timestamp("20130101 09:00:01"),
  261:                 Timestamp("20130101 09:00:02"),
  262:                 Timestamp("20130101 09:00:03"),
  263:                 Timestamp("20130101 09:00:04"),
  264:                 Timestamp("20130101 09:00:06"),
  265:             ]
  266:         ).as_unit(unit)
  267: 
  268:         df = DataFrame(
  269:             {"A": [1] * 5},
  270:             index=dti,
  271:         )
  272: 
  273:         # closed must be 'right', 'left', 'both', 'neither'
  274:         msg = "closed must be 'right', 'left', 'both' or 'neither'"
  275:         with pytest.raises(ValueError, match=msg):
  276:             regular.rolling(window="2s", closed="blabla")
  277: 
  278:         expected = df.copy()
  279:         expected["A"] = [1.0, 2, 2, 2, 1]
  280:         result = df.rolling("2s", closed="right").sum()
  281:         tm.assert_frame_equal(result, expected)
  282: 
  283:         # default should be 'right'
  284:         result = df.rolling("2s").sum()
  285:         tm.assert_frame_equal(result, expected)
  286: 
  287:         expected = df.copy()
  288:         expected["A"] = [1.0, 2, 3, 3, 2]
  289:         result = df.rolling("2s", closed="both").sum()
  290:         tm.assert_frame_equal(result, expected)
  291: 
  292:         expected = df.copy()
  293:         expected["A"] = [np.nan, 1.0, 2, 2, 1]
  294:         result = df.rolling("2s", closed="left").sum()
  295:         tm.assert_frame_equal(result, expected)
  296: 
  297:         expected = df.copy()
  298:         expected["A"] = [np.nan, 1.0, 1, 1, np.nan]
  299:         result = df.rolling("2s", closed="neither").sum()
  300:         tm.assert_frame_equal(result, expected)
  301: 
  302:     def test_ragged_sum(self, ragged):
  303:         df = ragged
  304:         result = df.rolling(window="1s", min_periods=1).sum()
  305:         expected = df.copy()
  306:         expected["B"] = [0.0, 1, 2, 3, 4]
  307:         tm.assert_frame_equal(result, expected)
  308: 
  309:         result = df.rolling(window="2s", min_periods=1).sum()
  310:         expected = df.copy()
  311:         expected["B"] = [0.0, 1, 3, 3, 7]
  312:         tm.assert_frame_equal(result, expected)
  313: 
  314:         result = df.rolling(window="2s", min_periods=2).sum()
  315:         expected = df.copy()
  316:         expected["B"] = [np.nan, np.nan, 3, np.nan, 7]
  317:         tm.assert_frame_equal(result, expected)
  318: 
  319:         result = df.rolling(window="3s", min_periods=1).sum()
  320:         expected = df.copy()
  321:         expected["B"] = [0.0, 1, 3, 5, 7]
  322:         tm.assert_frame_equal(result, expected)
  323: 
  324:         result = df.rolling(window="3s").sum()
  325:         expected = df.copy()
  326:         expected["B"] = [0.0, 1, 3, 5, 7]
  327:         tm.assert_frame_equal(result, expected)
  328: 
  329:         result = df.rolling(window="4s", min_periods=1).sum()
  330:         expected = df.copy()
  331:         expected["B"] = [0.0, 1, 3, 6, 9]
  332:         tm.assert_frame_equal(result, expected)
  333: 
  334:         result = df.rolling(window="4s", min_periods=3).sum()
  335:         expected = df.copy()
  336:         expected["B"] = [np.nan, np.nan, 3, 6, 9]
  337:         tm.assert_frame_equal(result, expected)
  338: 
  339:         result = df.rolling(window="5s", min_periods=1).sum()
  340:         expected = df.copy()
  341:         expected["B"] = [0.0, 1, 3, 6, 10]
  342:         tm.assert_frame_equal(result, expected)
  343: 
  344:     def test_ragged_mean(self, ragged):
  345:         df = ragged
  346:         result = df.rolling(window="1s", min_periods=1).mean()
  347:         expected = df.copy()
  348:         expected["B"] = [0.0, 1, 2, 3, 4]
  349:         tm.assert_frame_equal(result, expected)
  350: 
  351:         result = df.rolling(window="2s", min_periods=1).mean()
  352:         expected = df.copy()
  353:         expected["B"] = [0.0, 1, 1.5, 3.0, 3.5]
  354:         tm.assert_frame_equal(result, expected)
  355: 
  356:     def test_ragged_median(self, ragged):
  357:         df = ragged
  358:         result = df.rolling(window="1s", min_periods=1).median()
  359:         expected = df.copy()
  360:         expected["B"] = [0.0, 1, 2, 3, 4]
  361:         tm.assert_frame_equal(result, expected)
  362: 
  363:         result = df.rolling(window="2s", min_periods=1).median()
  364:         expected = df.copy()
  365:         expected["B"] = [0.0, 1, 1.5, 3.0, 3.5]
  366:         tm.assert_frame_equal(result, expected)
  367: 
  368:     def test_ragged_quantile(self, ragged):
  369:         df = ragged
  370:         result = df.rolling(window="1s", min_periods=1).quantile(0.5)
  371:         expected = df.copy()
  372:         expected["B"] = [0.0, 1, 2, 3, 4]
  373:         tm.assert_frame_equal(result, expected)
  374: 
  375:         result = df.rolling(window="2s", min_periods=1).quantile(0.5)
  376:         expected = df.copy()
  377:         expected["B"] = [0.0, 1, 1.5, 3.0, 3.5]
  378:         tm.assert_frame_equal(result, expected)
  379: 
  380:     def test_ragged_std(self, ragged):
  381:         df = ragged
  382:         result = df.rolling(window="1s", min_periods=1).std(ddof=0)
  383:         expected = df.copy()
  384:         expected["B"] = [0.0] * 5
  385:         tm.assert_frame_equal(result, expected)
  386: 
  387:         result = df.rolling(window="1s", min_periods=1).std(ddof=1)
  388:         expected = df.copy()
  389:         expected["B"] = [np.nan] * 5
  390:         tm.assert_frame_equal(result, expected)
  391: 
  392:         result = df.rolling(window="3s", min_periods=1).std(ddof=0)
  393:         expected = df.copy()
  394:         expected["B"] = [0.0] + [0.5] * 4
  395:         tm.assert_frame_equal(result, expected)
  396: 
  397:         result = df.rolling(window="5s", min_periods=1).std(ddof=1)
  398:         expected = df.copy()
  399:         expected["B"] = [np.nan, 0.707107, 1.0, 1.0, 1.290994]
  400:         tm.assert_frame_equal(result, expected)
  401: 
  402:     def test_ragged_var(self, ragged):
  403:         df = ragged
  404:         result = df.rolling(window="1s", min_periods=1).var(ddof=0)
  405:         expected = df.copy()
  406:         expected["B"] = [0.0] * 5
  407:         tm.assert_frame_equal(result, expected)
  408: 
  409:         result = df.rolling(window="1s", min_periods=1).var(ddof=1)
  410:         expected = df.copy()
  411:         expected["B"] = [np.nan] * 5
  412:         tm.assert_frame_equal(result, expected)
  413: 
  414:         result = df.rolling(window="3s", min_periods=1).var(ddof=0)
  415:         expected = df.copy()
  416:         expected["B"] = [0.0] + [0.25] * 4
  417:         tm.assert_frame_equal(result, expected)
  418: 
  419:         result = df.rolling(window="5s", min_periods=1).var(ddof=1)
  420:         expected = df.copy()
  421:         expected["B"] = [np.nan, 0.5, 1.0, 1.0, 1 + 2 / 3.0]
  422:         tm.assert_frame_equal(result, expected)
  423: 
  424:     def test_ragged_skew(self, ragged):
  425:         df = ragged
  426:         result = df.rolling(window="3s", min_periods=1).skew()
  427:         expected = df.copy()
  428:         expected["B"] = [np.nan] * 5
  429:         tm.assert_frame_equal(result, expected)
  430: 
  431:         result = df.rolling(window="5s", min_periods=1).skew()
  432:         expected = df.copy()
  433:         expected["B"] = [np.nan] * 2 + [0.0, 0.0, 0.0]
  434:         tm.assert_frame_equal(result, expected)
  435: 
  436:     def test_ragged_kurt(self, ragged):
  437:         df = ragged
  438:         result = df.rolling(window="3s", min_periods=1).kurt()
  439:         expected = df.copy()
  440:         expected["B"] = [np.nan] * 5
  441:         tm.assert_frame_equal(result, expected)
  442: 
  443:         result = df.rolling(window="5s", min_periods=1).kurt()
  444:         expected = df.copy()
  445:         expected["B"] = [np.nan] * 4 + [-1.2]
  446:         tm.assert_frame_equal(result, expected)
  447: 
  448:     def test_ragged_count(self, ragged):
  449:         df = ragged
  450:         result = df.rolling(window="1s", min_periods=1).count()
  451:         expected = df.copy()
  452:         expected["B"] = [1.0, 1, 1, 1, 1]
  453:         tm.assert_frame_equal(result, expected)
  454: 
  455:         df = ragged
  456:         result = df.rolling(window="1s").count()
  457:         tm.assert_frame_equal(result, expected)
  458: 
  459:         result = df.rolling(window="2s", min_periods=1).count()
  460:         expected = df.copy()
  461:         expected["B"] = [1.0, 1, 2, 1, 2]
  462:         tm.assert_frame_equal(result, expected)
  463: 
  464:         result = df.rolling(window="2s", min_periods=2).count()
  465:         expected = df.copy()
  466:         expected["B"] = [np.nan, np.nan, 2, np.nan, 2]
  467:         tm.assert_frame_equal(result, expected)
  468: 
  469:     def test_regular_min(self):
  470:         df = DataFrame(
  471:             {"A": date_range("20130101", periods=5, freq="s"), "B": [0.0, 1, 2, 3, 4]}
  472:         ).set_index("A")
  473:         result = df.rolling("1s").min()
  474:         expected = df.copy()
  475:         expected["B"] = [0.0, 1, 2, 3, 4]
  476:         tm.assert_frame_equal(result, expected)
  477: 
  478:         df = DataFrame(
  479:             {"A": date_range("20130101", periods=5, freq="s"), "B": [5, 4, 3, 4, 5]}
  480:         ).set_index("A")
  481: 
  482:         tm.assert_frame_equal(result, expected)
  483:         result = df.rolling("2s").min()
  484:         expected = df.copy()
  485:         expected["B"] = [5.0, 4, 3, 3, 4]
  486:         tm.assert_frame_equal(result, expected)
  487: 
  488:         result = df.rolling("5s").min()
  489:         expected = df.copy()
  490:         expected["B"] = [5.0, 4, 3, 3, 3]
  491:         tm.assert_frame_equal(result, expected)
  492: 
  493:     def test_ragged_min(self, ragged):
  494:         df = ragged
  495: 
  496:         result = df.rolling(window="1s", min_periods=1).min()
  497:         expected = df.copy()
  498:         expected["B"] = [0.0, 1, 2, 3, 4]
  499:         tm.assert_frame_equal(result, expected)
  500: 
  501:         result = df.rolling(window="2s", min_periods=1).min()
  502:         expected = df.copy()
  503:         expected["B"] = [0.0, 1, 1, 3, 3]
  504:         tm.assert_frame_equal(result, expected)
  505: 
  506:         result = df.rolling(window="5s", min_periods=1).min()
  507:         expected = df.copy()
  508:         expected["B"] = [0.0, 0, 0, 1, 1]
  509:         tm.assert_frame_equal(result, expected)
  510: 
  511:     def test_perf_min(self):
  512:         N = 10000
  513: 
  514:         dfp = DataFrame(
  515:             {"B": np.random.default_rng(2).standard_normal(N)},
  516:             index=date_range("20130101", periods=N, freq="s"),
  517:         )
  518:         expected = dfp.rolling(2, min_periods=1).min()
  519:         result = dfp.rolling("2s").min()
  520:         assert ((result - expected) < 0.01).all().all()
  521: 
  522:         expected = dfp.rolling(200, min_periods=1).min()
  523:         result = dfp.rolling("200s").min()
  524:         assert ((result - expected) < 0.01).all().all()
  525: 
  526:     def test_ragged_max(self, ragged):
  527:         df = ragged
  528: 
  529:         result = df.rolling(window="1s", min_periods=1).max()
  530:         expected = df.copy()
  531:         expected["B"] = [0.0, 1, 2, 3, 4]
  532:         tm.assert_frame_equal(result, expected)
  533: 
  534:         result = df.rolling(window="2s", min_periods=1).max()
  535:         expected = df.copy()
  536:         expected["B"] = [0.0, 1, 2, 3, 4]
  537:         tm.assert_frame_equal(result, expected)
  538: 
  539:         result = df.rolling(window="5s", min_periods=1).max()
  540:         expected = df.copy()
  541:         expected["B"] = [0.0, 1, 2, 3, 4]
  542:         tm.assert_frame_equal(result, expected)
  543: 
  544:     @pytest.mark.parametrize(
  545:         "freq, op, result_data",
  546:         [
  547:             ("ms", "min", [0.0] * 10),
  548:             ("ms", "mean", [0.0] * 9 + [2.0 / 9]),
  549:             ("ms", "max", [0.0] * 9 + [2.0]),
  550:             ("s", "min", [0.0] * 10),
  551:             ("s", "mean", [0.0] * 9 + [2.0 / 9]),
  552:             ("s", "max", [0.0] * 9 + [2.0]),
  553:             ("min", "min", [0.0] * 10),
  554:             ("min", "mean", [0.0] * 9 + [2.0 / 9]),
  555:             ("min", "max", [0.0] * 9 + [2.0]),
  556:             ("h", "min", [0.0] * 10),
  557:             ("h", "mean", [0.0] * 9 + [2.0 / 9]),
  558:             ("h", "max", [0.0] * 9 + [2.0]),
  559:             ("D", "min", [0.0] * 10),
  560:             ("D", "mean", [0.0] * 9 + [2.0 / 9]),
  561:             ("D", "max", [0.0] * 9 + [2.0]),
  562:         ],
  563:     )
  564:     def test_freqs_ops(self, freq, op, result_data):
  565:         # GH 21096
  566:         index = date_range(start="2018-1-1 01:00:00", freq=f"1{freq}", periods=10)
  567:         # Explicit cast to float to avoid implicit cast when setting nan
  568:         s = Series(data=0, index=index, dtype="float")
  569:         s.iloc[1] = np.nan
  570:         s.iloc[-1] = 2
  571:         result = getattr(s.rolling(window=f"10{freq}"), op)()
  572:         expected = Series(data=result_data, index=index)
  573: 
  574:         tm.assert_series_equal(result, expected)
  575: 
  576:     @pytest.mark.parametrize(
  577:         "f",
  578:         [
  579:             "sum",
  580:             "mean",
  581:             "count",
  582:             "median",
  583:             "std",
  584:             "var",
  585:             "kurt",
  586:             "skew",
  587:             "min",
  588:             "max",
  589:         ],
  590:     )
  591:     def test_all(self, f, regular):
  592:         # simple comparison of integer vs time-based windowing
  593:         df = regular * 2
  594:         er = df.rolling(window=1)
  595:         r = df.rolling(window="1s")
  596: 
  597:         result = getattr(r, f)()
  598:         expected = getattr(er, f)()
  599:         tm.assert_frame_equal(result, expected)
  600: 
  601:         result = r.quantile(0.5)
  602:         expected = er.quantile(0.5)
  603:         tm.assert_frame_equal(result, expected)
  604: 
  605:     def test_all2(self, arithmetic_win_operators):
  606:         f = arithmetic_win_operators
  607:         # more sophisticated comparison of integer vs.
  608:         # time-based windowing
  609:         df = DataFrame(
  610:             {"B": np.arange(50)}, index=date_range("20130101", periods=50, freq="h")
  611:         )
  612:         # in-range data
  613:         dft = df.between_time("09:00", "16:00")
  614: 
  615:         r = dft.rolling(window="5h")
  616: 
  617:         result = getattr(r, f)()
  618: 
  619:         # we need to roll the days separately
  620:         # to compare with a time-based roll
  621:         # finally groupby-apply will return a multi-index
  622:         # so we need to drop the day
  623:         def agg_by_day(x):
  624:             x = x.between_time("09:00", "16:00")
  625:             return getattr(x.rolling(5, min_periods=1), f)()
  626: 
  627:         expected = (
  628:             df.groupby(df.index.day).apply(agg_by_day).reset_index(level=0, drop=True)
  629:         )
  630: 
  631:         tm.assert_frame_equal(result, expected)
  632: 
  633:     def test_rolling_cov_offset(self):
  634:         # GH16058
  635: 
  636:         idx = date_range("2017-01-01", periods=24, freq="1h")
  637:         ss = Series(np.arange(len(idx)), index=idx)
  638: 
  639:         result = ss.rolling("2h").cov()
  640:         expected = Series([np.nan] + [0.5] * (len(idx) - 1), index=idx)
  641:         tm.assert_series_equal(result, expected)
  642: 
  643:         expected2 = ss.rolling(2, min_periods=1).cov()
  644:         tm.assert_series_equal(result, expected2)
  645: 
  646:         result = ss.rolling("3h").cov()
  647:         expected = Series([np.nan, 0.5] + [1.0] * (len(idx) - 2), index=idx)
  648:         tm.assert_series_equal(result, expected)
  649: 
  650:         expected2 = ss.rolling(3, min_periods=1).cov()
  651:         tm.assert_series_equal(result, expected2)
  652: 
  653:     def test_rolling_on_decreasing_index(self, unit):
  654:         # GH-19248, GH-32385
  655:         index = DatetimeIndex(
  656:             [
  657:                 Timestamp("20190101 09:00:30"),
  658:                 Timestamp("20190101 09:00:27"),
  659:                 Timestamp("20190101 09:00:20"),
  660:                 Timestamp("20190101 09:00:18"),
  661:                 Timestamp("20190101 09:00:10"),
  662:             ]
  663:         ).as_unit(unit)
  664: 
  665:         df = DataFrame({"column": [3, 4, 4, 5, 6]}, index=index)
  666:         result = df.rolling("5s").min()
  667:         expected = DataFrame({"column": [3.0, 3.0, 4.0, 4.0, 6.0]}, index=index)
  668:         tm.assert_frame_equal(result, expected)
  669: 
  670:     def test_rolling_on_empty(self):
  671:         # GH-32385
  672:         df = DataFrame({"column": []}, index=[])
  673:         result = df.rolling("5s").min()
  674:         expected = DataFrame({"column": []}, index=[])
  675:         tm.assert_frame_equal(result, expected)
  676: 
  677:     def test_rolling_on_multi_index_level(self):
  678:         # GH-15584
  679:         df = DataFrame(
  680:             {"column": range(6)},
  681:             index=MultiIndex.from_product(
  682:                 [date_range("20190101", periods=3), range(2)], names=["date", "seq"]
  683:             ),
  684:         )
  685:         result = df.rolling("10d", on=df.index.get_level_values("date")).sum()
  686:         expected = DataFrame(
  687:             {"column": [0.0, 1.0, 3.0, 6.0, 10.0, 15.0]}, index=df.index
  688:         )
  689:         tm.assert_frame_equal(result, expected)
  690: 
  691: 
  692: @pytest.mark.parametrize("msg, axis", [["column", 1], ["index", 0]])
  693: def test_nat_axis_error(msg, axis):
  694:     idx = [Timestamp("2020"), NaT]
  695:     kwargs = {"columns" if axis == 1 else "index": idx}
  696:     df = DataFrame(np.eye(2), **kwargs)
  697:     warn_msg = "The 'axis' keyword in DataFrame.rolling is deprecated"
  698:     if axis == 1:
  699:         warn_msg = "Support for axis=1 in DataFrame.rolling is deprecated"
  700:     with pytest.raises(ValueError, match=f"{msg} values must not have NaT"):
  701:         with tm.assert_produces_warning(FutureWarning, match=warn_msg):
  702:             df.rolling("D", axis=axis).mean()
  703: 
  704: 
  705: @td.skip_if_no("pyarrow")
  706: def test_arrow_datetime_axis():
  707:     # GH 55849
  708:     expected = Series(
  709:         np.arange(5, dtype=np.float64),
  710:         index=Index(
  711:             date_range("2020-01-01", periods=5), dtype="timestamp[ns][pyarrow]"
  712:         ),
  713:     )
  714:     result = expected.rolling("1D").sum()
  715:     tm.assert_series_equal(result, expected)
