    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     DatetimeIndex,
    7:     Index,
    8:     MultiIndex,
    9:     Series,
   10:     isna,
   11:     notna,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: def test_doc_string():
   17:     df = DataFrame({"B": [0, 1, 2, np.nan, 4]})
   18:     df
   19:     df.expanding(2).sum()
   20: 
   21: 
   22: def test_constructor(frame_or_series):
   23:     # GH 12669
   24: 
   25:     c = frame_or_series(range(5)).expanding
   26: 
   27:     # valid
   28:     c(min_periods=1)
   29: 
   30: 
   31: @pytest.mark.parametrize("w", [2.0, "foo", np.array([2])])
   32: def test_constructor_invalid(frame_or_series, w):
   33:     # not valid
   34: 
   35:     c = frame_or_series(range(5)).expanding
   36:     msg = "min_periods must be an integer"
   37:     with pytest.raises(ValueError, match=msg):
   38:         c(min_periods=w)
   39: 
   40: 
   41: @pytest.mark.parametrize(
   42:     "expander",
   43:     [
   44:         1,
   45:         pytest.param(
   46:             "ls",
   47:             marks=pytest.mark.xfail(
   48:                 reason="GH#16425 expanding with offset not supported"
   49:             ),
   50:         ),
   51:     ],
   52: )
   53: def test_empty_df_expanding(expander):
   54:     # GH 15819 Verifies that datetime and integer expanding windows can be
   55:     # applied to empty DataFrames
   56: 
   57:     expected = DataFrame()
   58:     result = DataFrame().expanding(expander).sum()
   59:     tm.assert_frame_equal(result, expected)
   60: 
   61:     # Verifies that datetime and integer expanding windows can be applied
   62:     # to empty DataFrames with datetime index
   63:     expected = DataFrame(index=DatetimeIndex([]))
   64:     result = DataFrame(index=DatetimeIndex([])).expanding(expander).sum()
   65:     tm.assert_frame_equal(result, expected)
   66: 
   67: 
   68: def test_missing_minp_zero():
   69:     # https://github.com/pandas-dev/pandas/pull/18921
   70:     # minp=0
   71:     x = Series([np.nan])
   72:     result = x.expanding(min_periods=0).sum()
   73:     expected = Series([0.0])
   74:     tm.assert_series_equal(result, expected)
   75: 
   76:     # minp=1
   77:     result = x.expanding(min_periods=1).sum()
   78:     expected = Series([np.nan])
   79:     tm.assert_series_equal(result, expected)
   80: 
   81: 
   82: def test_expanding_axis(axis_frame):
   83:     # see gh-23372.
   84:     df = DataFrame(np.ones((10, 20)))
   85:     axis = df._get_axis_number(axis_frame)
   86: 
   87:     if axis == 0:
   88:         msg = "The 'axis' keyword in DataFrame.expanding is deprecated"
   89:         expected = DataFrame(
   90:             {i: [np.nan] * 2 + [float(j) for j in range(3, 11)] for i in range(20)}
   91:         )
   92:     else:
   93:         # axis == 1
   94:         msg = "Support for axis=1 in DataFrame.expanding is deprecated"
   95:         expected = DataFrame([[np.nan] * 2 + [float(i) for i in range(3, 21)]] * 10)
   96: 
   97:     with tm.assert_produces_warning(FutureWarning, match=msg):
   98:         result = df.expanding(3, axis=axis_frame).sum()
   99:     tm.assert_frame_equal(result, expected)
  100: 
  101: 
  102: def test_expanding_count_with_min_periods(frame_or_series):
  103:     # GH 26996
  104:     result = frame_or_series(range(5)).expanding(min_periods=3).count()
  105:     expected = frame_or_series([np.nan, np.nan, 3.0, 4.0, 5.0])
  106:     tm.assert_equal(result, expected)
  107: 
  108: 
  109: def test_expanding_count_default_min_periods_with_null_values(frame_or_series):
  110:     # GH 26996
  111:     values = [1, 2, 3, np.nan, 4, 5, 6]
  112:     expected_counts = [1.0, 2.0, 3.0, 3.0, 4.0, 5.0, 6.0]
  113: 
  114:     result = frame_or_series(values).expanding().count()
  115:     expected = frame_or_series(expected_counts)
  116:     tm.assert_equal(result, expected)
  117: 
  118: 
  119: def test_expanding_count_with_min_periods_exceeding_series_length(frame_or_series):
  120:     # GH 25857
  121:     result = frame_or_series(range(5)).expanding(min_periods=6).count()
  122:     expected = frame_or_series([np.nan, np.nan, np.nan, np.nan, np.nan])
  123:     tm.assert_equal(result, expected)
  124: 
  125: 
  126: @pytest.mark.parametrize(
  127:     "df,expected,min_periods",
  128:     [
  129:         (
  130:             DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}),
  131:             [
  132:                 ({"A": [1], "B": [4]}, [0]),
  133:                 ({"A": [1, 2], "B": [4, 5]}, [0, 1]),
  134:                 ({"A": [1, 2, 3], "B": [4, 5, 6]}, [0, 1, 2]),
  135:             ],
  136:             3,
  137:         ),
  138:         (
  139:             DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}),
  140:             [
  141:                 ({"A": [1], "B": [4]}, [0]),
  142:                 ({"A": [1, 2], "B": [4, 5]}, [0, 1]),
  143:                 ({"A": [1, 2, 3], "B": [4, 5, 6]}, [0, 1, 2]),
  144:             ],
  145:             2,
  146:         ),
  147:         (
  148:             DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}),
  149:             [
  150:                 ({"A": [1], "B": [4]}, [0]),
  151:                 ({"A": [1, 2], "B": [4, 5]}, [0, 1]),
  152:                 ({"A": [1, 2, 3], "B": [4, 5, 6]}, [0, 1, 2]),
  153:             ],
  154:             1,
  155:         ),
  156:         (DataFrame({"A": [1], "B": [4]}), [], 2),
  157:         (DataFrame(), [({}, [])], 1),
  158:         (
  159:             DataFrame({"A": [1, np.nan, 3], "B": [np.nan, 5, 6]}),
  160:             [
  161:                 ({"A": [1.0], "B": [np.nan]}, [0]),
  162:                 ({"A": [1, np.nan], "B": [np.nan, 5]}, [0, 1]),
  163:                 ({"A": [1, np.nan, 3], "B": [np.nan, 5, 6]}, [0, 1, 2]),
  164:             ],
  165:             3,
  166:         ),
  167:         (
  168:             DataFrame({"A": [1, np.nan, 3], "B": [np.nan, 5, 6]}),
  169:             [
  170:                 ({"A": [1.0], "B": [np.nan]}, [0]),
  171:                 ({"A": [1, np.nan], "B": [np.nan, 5]}, [0, 1]),
  172:                 ({"A": [1, np.nan, 3], "B": [np.nan, 5, 6]}, [0, 1, 2]),
  173:             ],
  174:             2,
  175:         ),
  176:         (
  177:             DataFrame({"A": [1, np.nan, 3], "B": [np.nan, 5, 6]}),
  178:             [
  179:                 ({"A": [1.0], "B": [np.nan]}, [0]),
  180:                 ({"A": [1, np.nan], "B": [np.nan, 5]}, [0, 1]),
  181:                 ({"A": [1, np.nan, 3], "B": [np.nan, 5, 6]}, [0, 1, 2]),
  182:             ],
  183:             1,
  184:         ),
  185:     ],
  186: )
  187: def test_iter_expanding_dataframe(df, expected, min_periods):
  188:     # GH 11704
  189:     expected = [DataFrame(values, index=index) for (values, index) in expected]
  190: 
  191:     for expected, actual in zip(expected, df.expanding(min_periods)):
  192:         tm.assert_frame_equal(actual, expected)
  193: 
  194: 
  195: @pytest.mark.parametrize(
  196:     "ser,expected,min_periods",
  197:     [
  198:         (Series([1, 2, 3]), [([1], [0]), ([1, 2], [0, 1]), ([1, 2, 3], [0, 1, 2])], 3),
  199:         (Series([1, 2, 3]), [([1], [0]), ([1, 2], [0, 1]), ([1, 2, 3], [0, 1, 2])], 2),
  200:         (Series([1, 2, 3]), [([1], [0]), ([1, 2], [0, 1]), ([1, 2, 3], [0, 1, 2])], 1),
  201:         (Series([1, 2]), [([1], [0]), ([1, 2], [0, 1])], 2),
  202:         (Series([np.nan, 2]), [([np.nan], [0]), ([np.nan, 2], [0, 1])], 2),
  203:         (Series([], dtype="int64"), [], 2),
  204:     ],
  205: )
  206: def test_iter_expanding_series(ser, expected, min_periods):
  207:     # GH 11704
  208:     expected = [Series(values, index=index) for (values, index) in expected]
  209: 
  210:     for expected, actual in zip(expected, ser.expanding(min_periods)):
  211:         tm.assert_series_equal(actual, expected)
  212: 
  213: 
  214: def test_center_invalid():
  215:     # GH 20647
  216:     df = DataFrame()
  217:     with pytest.raises(TypeError, match=".* got an unexpected keyword"):
  218:         df.expanding(center=True)
  219: 
  220: 
  221: def test_expanding_sem(frame_or_series):
  222:     # GH: 26476
  223:     obj = frame_or_series([0, 1, 2])
  224:     result = obj.expanding().sem()
  225:     if isinstance(result, DataFrame):
  226:         result = Series(result[0].values)
  227:     expected = Series([np.nan] + [0.707107] * 2)
  228:     tm.assert_series_equal(result, expected)
  229: 
  230: 
  231: @pytest.mark.parametrize("method", ["skew", "kurt"])
  232: def test_expanding_skew_kurt_numerical_stability(method):
  233:     # GH: 6929
  234:     s = Series(np.random.default_rng(2).random(10))
  235:     expected = getattr(s.expanding(3), method)()
  236:     s = s + 5000
  237:     result = getattr(s.expanding(3), method)()
  238:     tm.assert_series_equal(result, expected)
  239: 
  240: 
  241: @pytest.mark.parametrize("window", [1, 3, 10, 20])
  242: @pytest.mark.parametrize("method", ["min", "max", "average"])
  243: @pytest.mark.parametrize("pct", [True, False])
  244: @pytest.mark.parametrize("ascending", [True, False])
  245: @pytest.mark.parametrize("test_data", ["default", "duplicates", "nans"])
  246: def test_rank(window, method, pct, ascending, test_data):
  247:     length = 20
  248:     if test_data == "default":
  249:         ser = Series(data=np.random.default_rng(2).random(length))
  250:     elif test_data == "duplicates":
  251:         ser = Series(data=np.random.default_rng(2).choice(3, length))
  252:     elif test_data == "nans":
  253:         ser = Series(
  254:             data=np.random.default_rng(2).choice(
  255:                 [1.0, 0.25, 0.75, np.nan, np.inf, -np.inf], length
  256:             )
  257:         )
  258: 
  259:     expected = ser.expanding(window).apply(
  260:         lambda x: x.rank(method=method, pct=pct, ascending=ascending).iloc[-1]
  261:     )
  262:     result = ser.expanding(window).rank(method=method, pct=pct, ascending=ascending)
  263: 
  264:     tm.assert_series_equal(result, expected)
  265: 
  266: 
  267: def test_expanding_corr(series):
  268:     A = series.dropna()
  269:     B = (A + np.random.default_rng(2).standard_normal(len(A)))[:-5]
  270: 
  271:     result = A.expanding().corr(B)
  272: 
  273:     rolling_result = A.rolling(window=len(A), min_periods=1).corr(B)
  274: 
  275:     tm.assert_almost_equal(rolling_result, result)
  276: 
  277: 
  278: def test_expanding_count(series):
  279:     result = series.expanding(min_periods=0).count()
  280:     tm.assert_almost_equal(
  281:         result, series.rolling(window=len(series), min_periods=0).count()
  282:     )
  283: 
  284: 
  285: def test_expanding_quantile(series):
  286:     result = series.expanding().quantile(0.5)
  287: 
  288:     rolling_result = series.rolling(window=len(series), min_periods=1).quantile(0.5)
  289: 
  290:     tm.assert_almost_equal(result, rolling_result)
  291: 
  292: 
  293: def test_expanding_cov(series):
  294:     A = series
  295:     B = (A + np.random.default_rng(2).standard_normal(len(A)))[:-5]
  296: 
  297:     result = A.expanding().cov(B)
  298: 
  299:     rolling_result = A.rolling(window=len(A), min_periods=1).cov(B)
  300: 
  301:     tm.assert_almost_equal(rolling_result, result)
  302: 
  303: 
  304: def test_expanding_cov_pairwise(frame):
  305:     result = frame.expanding().cov()
  306: 
  307:     rolling_result = frame.rolling(window=len(frame), min_periods=1).cov()
  308: 
  309:     tm.assert_frame_equal(result, rolling_result)
  310: 
  311: 
  312: def test_expanding_corr_pairwise(frame):
  313:     result = frame.expanding().corr()
  314: 
  315:     rolling_result = frame.rolling(window=len(frame), min_periods=1).corr()
  316:     tm.assert_frame_equal(result, rolling_result)
  317: 
  318: 
  319: @pytest.mark.parametrize(
  320:     "func,static_comp",
  321:     [
  322:         ("sum", np.sum),
  323:         ("mean", lambda x: np.mean(x, axis=0)),
  324:         ("max", lambda x: np.max(x, axis=0)),
  325:         ("min", lambda x: np.min(x, axis=0)),
  326:     ],
  327:     ids=["sum", "mean", "max", "min"],
  328: )
  329: def test_expanding_func(func, static_comp, frame_or_series):
  330:     data = frame_or_series(np.array(list(range(10)) + [np.nan] * 10))
  331: 
  332:     msg = "The 'axis' keyword in (Series|DataFrame).expanding is deprecated"
  333:     with tm.assert_produces_warning(FutureWarning, match=msg):
  334:         obj = data.expanding(min_periods=1, axis=0)
  335:     result = getattr(obj, func)()
  336:     assert isinstance(result, frame_or_series)
  337: 
  338:     msg = "The behavior of DataFrame.sum with axis=None is deprecated"
  339:     warn = None
  340:     if frame_or_series is DataFrame and static_comp is np.sum:
  341:         warn = FutureWarning
  342:     with tm.assert_produces_warning(warn, match=msg, check_stacklevel=False):
  343:         expected = static_comp(data[:11])
  344:     if frame_or_series is Series:
  345:         tm.assert_almost_equal(result[10], expected)
  346:     else:
  347:         tm.assert_series_equal(result.iloc[10], expected, check_names=False)
  348: 
  349: 
  350: @pytest.mark.parametrize(
  351:     "func,static_comp",
  352:     [("sum", np.sum), ("mean", np.mean), ("max", np.max), ("min", np.min)],
  353:     ids=["sum", "mean", "max", "min"],
  354: )
  355: def test_expanding_min_periods(func, static_comp):
  356:     ser = Series(np.random.default_rng(2).standard_normal(50))
  357: 
  358:     msg = "The 'axis' keyword in Series.expanding is deprecated"
  359:     with tm.assert_produces_warning(FutureWarning, match=msg):
  360:         result = getattr(ser.expanding(min_periods=30, axis=0), func)()
  361:     assert result[:29].isna().all()
  362:     tm.assert_almost_equal(result.iloc[-1], static_comp(ser[:50]))
  363: 
  364:     # min_periods is working correctly
  365:     with tm.assert_produces_warning(FutureWarning, match=msg):
  366:         result = getattr(ser.expanding(min_periods=15, axis=0), func)()
  367:     assert isna(result.iloc[13])
  368:     assert notna(result.iloc[14])
  369: 
  370:     ser2 = Series(np.random.default_rng(2).standard_normal(20))
  371:     with tm.assert_produces_warning(FutureWarning, match=msg):
  372:         result = getattr(ser2.expanding(min_periods=5, axis=0), func)()
  373:     assert isna(result[3])
  374:     assert notna(result[4])
  375: 
  376:     # min_periods=0
  377:     with tm.assert_produces_warning(FutureWarning, match=msg):
  378:         result0 = getattr(ser.expanding(min_periods=0, axis=0), func)()
  379:     with tm.assert_produces_warning(FutureWarning, match=msg):
  380:         result1 = getattr(ser.expanding(min_periods=1, axis=0), func)()
  381:     tm.assert_almost_equal(result0, result1)
  382: 
  383:     with tm.assert_produces_warning(FutureWarning, match=msg):
  384:         result = getattr(ser.expanding(min_periods=1, axis=0), func)()
  385:     tm.assert_almost_equal(result.iloc[-1], static_comp(ser[:50]))
  386: 
  387: 
  388: def test_expanding_apply(engine_and_raw, frame_or_series):
  389:     engine, raw = engine_and_raw
  390:     data = frame_or_series(np.array(list(range(10)) + [np.nan] * 10))
  391:     result = data.expanding(min_periods=1).apply(
  392:         lambda x: x.mean(), raw=raw, engine=engine
  393:     )
  394:     assert isinstance(result, frame_or_series)
  395: 
  396:     if frame_or_series is Series:
  397:         tm.assert_almost_equal(result[9], np.mean(data[:11], axis=0))
  398:     else:
  399:         tm.assert_series_equal(
  400:             result.iloc[9], np.mean(data[:11], axis=0), check_names=False
  401:         )
  402: 
  403: 
  404: def test_expanding_min_periods_apply(engine_and_raw):
  405:     engine, raw = engine_and_raw
  406:     ser = Series(np.random.default_rng(2).standard_normal(50))
  407: 
  408:     result = ser.expanding(min_periods=30).apply(
  409:         lambda x: x.mean(), raw=raw, engine=engine
  410:     )
  411:     assert result[:29].isna().all()
  412:     tm.assert_almost_equal(result.iloc[-1], np.mean(ser[:50]))
  413: 
  414:     # min_periods is working correctly
  415:     result = ser.expanding(min_periods=15).apply(
  416:         lambda x: x.mean(), raw=raw, engine=engine
  417:     )
  418:     assert isna(result.iloc[13])
  419:     assert notna(result.iloc[14])
  420: 
  421:     ser2 = Series(np.random.default_rng(2).standard_normal(20))
  422:     result = ser2.expanding(min_periods=5).apply(
  423:         lambda x: x.mean(), raw=raw, engine=engine
  424:     )
  425:     assert isna(result[3])
  426:     assert notna(result[4])
  427: 
  428:     # min_periods=0
  429:     result0 = ser.expanding(min_periods=0).apply(
  430:         lambda x: x.mean(), raw=raw, engine=engine
  431:     )
  432:     result1 = ser.expanding(min_periods=1).apply(
  433:         lambda x: x.mean(), raw=raw, engine=engine
  434:     )
  435:     tm.assert_almost_equal(result0, result1)
  436: 
  437:     result = ser.expanding(min_periods=1).apply(
  438:         lambda x: x.mean(), raw=raw, engine=engine
  439:     )
  440:     tm.assert_almost_equal(result.iloc[-1], np.mean(ser[:50]))
  441: 
  442: 
  443: @pytest.mark.parametrize(
  444:     "f",
  445:     [
  446:         lambda x: (x.expanding(min_periods=5).cov(x, pairwise=True)),
  447:         lambda x: (x.expanding(min_periods=5).corr(x, pairwise=True)),
  448:     ],
  449: )
  450: def test_moment_functions_zero_length_pairwise(f):
  451:     df1 = DataFrame()
  452:     df2 = DataFrame(columns=Index(["a"], name="foo"), index=Index([], name="bar"))
  453:     df2["a"] = df2["a"].astype("float64")
  454: 
  455:     df1_expected = DataFrame(index=MultiIndex.from_product([df1.index, df1.columns]))
  456:     df2_expected = DataFrame(
  457:         index=MultiIndex.from_product([df2.index, df2.columns], names=["bar", "foo"]),
  458:         columns=Index(["a"], name="foo"),
  459:         dtype="float64",
  460:     )
  461: 
  462:     df1_result = f(df1)
  463:     tm.assert_frame_equal(df1_result, df1_expected)
  464: 
  465:     df2_result = f(df2)
  466:     tm.assert_frame_equal(df2_result, df2_expected)
  467: 
  468: 
  469: @pytest.mark.parametrize(
  470:     "f",
  471:     [
  472:         lambda x: x.expanding().count(),
  473:         lambda x: x.expanding(min_periods=5).cov(x, pairwise=False),
  474:         lambda x: x.expanding(min_periods=5).corr(x, pairwise=False),
  475:         lambda x: x.expanding(min_periods=5).max(),
  476:         lambda x: x.expanding(min_periods=5).min(),
  477:         lambda x: x.expanding(min_periods=5).sum(),
  478:         lambda x: x.expanding(min_periods=5).mean(),
  479:         lambda x: x.expanding(min_periods=5).std(),
  480:         lambda x: x.expanding(min_periods=5).var(),
  481:         lambda x: x.expanding(min_periods=5).skew(),
  482:         lambda x: x.expanding(min_periods=5).kurt(),
  483:         lambda x: x.expanding(min_periods=5).quantile(0.5),
  484:         lambda x: x.expanding(min_periods=5).median(),
  485:         lambda x: x.expanding(min_periods=5).apply(sum, raw=False),
  486:         lambda x: x.expanding(min_periods=5).apply(sum, raw=True),
  487:     ],
  488: )
  489: def test_moment_functions_zero_length(f):
  490:     # GH 8056
  491:     s = Series(dtype=np.float64)
  492:     s_expected = s
  493:     df1 = DataFrame()
  494:     df1_expected = df1
  495:     df2 = DataFrame(columns=["a"])
  496:     df2["a"] = df2["a"].astype("float64")
  497:     df2_expected = df2
  498: 
  499:     s_result = f(s)
  500:     tm.assert_series_equal(s_result, s_expected)
  501: 
  502:     df1_result = f(df1)
  503:     tm.assert_frame_equal(df1_result, df1_expected)
  504: 
  505:     df2_result = f(df2)
  506:     tm.assert_frame_equal(df2_result, df2_expected)
  507: 
  508: 
  509: def test_expanding_apply_empty_series(engine_and_raw):
  510:     engine, raw = engine_and_raw
  511:     ser = Series([], dtype=np.float64)
  512:     tm.assert_series_equal(
  513:         ser, ser.expanding().apply(lambda x: x.mean(), raw=raw, engine=engine)
  514:     )
  515: 
  516: 
  517: def test_expanding_apply_min_periods_0(engine_and_raw):
  518:     # GH 8080
  519:     engine, raw = engine_and_raw
  520:     s = Series([None, None, None])
  521:     result = s.expanding(min_periods=0).apply(lambda x: len(x), raw=raw, engine=engine)
  522:     expected = Series([1.0, 2.0, 3.0])
  523:     tm.assert_series_equal(result, expected)
  524: 
  525: 
  526: def test_expanding_cov_diff_index():
  527:     # GH 7512
  528:     s1 = Series([1, 2, 3], index=[0, 1, 2])
  529:     s2 = Series([1, 3], index=[0, 2])
  530:     result = s1.expanding().cov(s2)
  531:     expected = Series([None, None, 2.0])
  532:     tm.assert_series_equal(result, expected)
  533: 
  534:     s2a = Series([1, None, 3], index=[0, 1, 2])
  535:     result = s1.expanding().cov(s2a)
  536:     tm.assert_series_equal(result, expected)
  537: 
  538:     s1 = Series([7, 8, 10], index=[0, 1, 3])
  539:     s2 = Series([7, 9, 10], index=[0, 2, 3])
  540:     result = s1.expanding().cov(s2)
  541:     expected = Series([None, None, None, 4.5])
  542:     tm.assert_series_equal(result, expected)
  543: 
  544: 
  545: def test_expanding_corr_diff_index():
  546:     # GH 7512
  547:     s1 = Series([1, 2, 3], index=[0, 1, 2])
  548:     s2 = Series([1, 3], index=[0, 2])
  549:     result = s1.expanding().corr(s2)
  550:     expected = Series([None, None, 1.0])
  551:     tm.assert_series_equal(result, expected)
  552: 
  553:     s2a = Series([1, None, 3], index=[0, 1, 2])
  554:     result = s1.expanding().corr(s2a)
  555:     tm.assert_series_equal(result, expected)
  556: 
  557:     s1 = Series([7, 8, 10], index=[0, 1, 3])
  558:     s2 = Series([7, 9, 10], index=[0, 2, 3])
  559:     result = s1.expanding().corr(s2)
  560:     expected = Series([None, None, None, 1.0])
  561:     tm.assert_series_equal(result, expected)
  562: 
  563: 
  564: def test_expanding_cov_pairwise_diff_length():
  565:     # GH 7512
  566:     df1 = DataFrame([[1, 5], [3, 2], [3, 9]], columns=Index(["A", "B"], name="foo"))
  567:     df1a = DataFrame(
  568:         [[1, 5], [3, 9]], index=[0, 2], columns=Index(["A", "B"], name="foo")
  569:     )
  570:     df2 = DataFrame(
  571:         [[5, 6], [None, None], [2, 1]], columns=Index(["X", "Y"], name="foo")
  572:     )
  573:     df2a = DataFrame(
  574:         [[5, 6], [2, 1]], index=[0, 2], columns=Index(["X", "Y"], name="foo")
  575:     )
  576:     # TODO: xref gh-15826
  577:     # .loc is not preserving the names
  578:     result1 = df1.expanding().cov(df2, pairwise=True).loc[2]
  579:     result2 = df1.expanding().cov(df2a, pairwise=True).loc[2]
  580:     result3 = df1a.expanding().cov(df2, pairwise=True).loc[2]
  581:     result4 = df1a.expanding().cov(df2a, pairwise=True).loc[2]
  582:     expected = DataFrame(
  583:         [[-3.0, -6.0], [-5.0, -10.0]],
  584:         columns=Index(["A", "B"], name="foo"),
  585:         index=Index(["X", "Y"], name="foo"),
  586:     )
  587:     tm.assert_frame_equal(result1, expected)
  588:     tm.assert_frame_equal(result2, expected)
  589:     tm.assert_frame_equal(result3, expected)
  590:     tm.assert_frame_equal(result4, expected)
  591: 
  592: 
  593: def test_expanding_corr_pairwise_diff_length():
  594:     # GH 7512
  595:     df1 = DataFrame(
  596:         [[1, 2], [3, 2], [3, 4]], columns=["A", "B"], index=Index(range(3), name="bar")
  597:     )
  598:     df1a = DataFrame(
  599:         [[1, 2], [3, 4]], index=Index([0, 2], name="bar"), columns=["A", "B"]
  600:     )
  601:     df2 = DataFrame(
  602:         [[5, 6], [None, None], [2, 1]],
  603:         columns=["X", "Y"],
  604:         index=Index(range(3), name="bar"),
  605:     )
  606:     df2a = DataFrame(
  607:         [[5, 6], [2, 1]], index=Index([0, 2], name="bar"), columns=["X", "Y"]
  608:     )
  609:     result1 = df1.expanding().corr(df2, pairwise=True).loc[2]
  610:     result2 = df1.expanding().corr(df2a, pairwise=True).loc[2]
  611:     result3 = df1a.expanding().corr(df2, pairwise=True).loc[2]
  612:     result4 = df1a.expanding().corr(df2a, pairwise=True).loc[2]
  613:     expected = DataFrame(
  614:         [[-1.0, -1.0], [-1.0, -1.0]], columns=["A", "B"], index=Index(["X", "Y"])
  615:     )
  616:     tm.assert_frame_equal(result1, expected)
  617:     tm.assert_frame_equal(result2, expected)
  618:     tm.assert_frame_equal(result3, expected)
  619:     tm.assert_frame_equal(result4, expected)
  620: 
  621: 
  622: def test_expanding_apply_args_kwargs(engine_and_raw):
  623:     def mean_w_arg(x, const):
  624:         return np.mean(x) + const
  625: 
  626:     engine, raw = engine_and_raw
  627: 
  628:     df = DataFrame(np.random.default_rng(2).random((20, 3)))
  629: 
  630:     expected = df.expanding().apply(np.mean, engine=engine, raw=raw) + 20.0
  631: 
  632:     result = df.expanding().apply(mean_w_arg, engine=engine, raw=raw, args=(20,))
  633:     tm.assert_frame_equal(result, expected)
  634: 
  635:     result = df.expanding().apply(mean_w_arg, raw=raw, kwargs={"const": 20})
  636:     tm.assert_frame_equal(result, expected)
  637: 
  638: 
  639: def test_numeric_only_frame(arithmetic_win_operators, numeric_only):
  640:     # GH#46560
  641:     kernel = arithmetic_win_operators
  642:     df = DataFrame({"a": [1], "b": 2, "c": 3})
  643:     df["c"] = df["c"].astype(object)
  644:     expanding = df.expanding()
  645:     op = getattr(expanding, kernel, None)
  646:     if op is not None:
  647:         result = op(numeric_only=numeric_only)
  648: 
  649:         columns = ["a", "b"] if numeric_only else ["a", "b", "c"]
  650:         expected = df[columns].agg([kernel]).reset_index(drop=True).astype(float)
  651:         assert list(expected.columns) == columns
  652: 
  653:         tm.assert_frame_equal(result, expected)
  654: 
  655: 
  656: @pytest.mark.parametrize("kernel", ["corr", "cov"])
  657: @pytest.mark.parametrize("use_arg", [True, False])
  658: def test_numeric_only_corr_cov_frame(kernel, numeric_only, use_arg):
  659:     # GH#46560
  660:     df = DataFrame({"a": [1, 2, 3], "b": 2, "c": 3})
  661:     df["c"] = df["c"].astype(object)
  662:     arg = (df,) if use_arg else ()
  663:     expanding = df.expanding()
  664:     op = getattr(expanding, kernel)
  665:     result = op(*arg, numeric_only=numeric_only)
  666: 
  667:     # Compare result to op using float dtypes, dropping c when numeric_only is True
  668:     columns = ["a", "b"] if numeric_only else ["a", "b", "c"]
  669:     df2 = df[columns].astype(float)
  670:     arg2 = (df2,) if use_arg else ()
  671:     expanding2 = df2.expanding()
  672:     op2 = getattr(expanding2, kernel)
  673:     expected = op2(*arg2, numeric_only=numeric_only)
  674: 
  675:     tm.assert_frame_equal(result, expected)
  676: 
  677: 
  678: @pytest.mark.parametrize("dtype", [int, object])
  679: def test_numeric_only_series(arithmetic_win_operators, numeric_only, dtype):
  680:     # GH#46560
  681:     kernel = arithmetic_win_operators
  682:     ser = Series([1], dtype=dtype)
  683:     expanding = ser.expanding()
  684:     op = getattr(expanding, kernel)
  685:     if numeric_only and dtype is object:
  686:         msg = f"Expanding.{kernel} does not implement numeric_only"
  687:         with pytest.raises(NotImplementedError, match=msg):
  688:             op(numeric_only=numeric_only)
  689:     else:
  690:         result = op(numeric_only=numeric_only)
  691:         expected = ser.agg([kernel]).reset_index(drop=True).astype(float)
  692:         tm.assert_series_equal(result, expected)
  693: 
  694: 
  695: @pytest.mark.parametrize("kernel", ["corr", "cov"])
  696: @pytest.mark.parametrize("use_arg", [True, False])
  697: @pytest.mark.parametrize("dtype", [int, object])
  698: def test_numeric_only_corr_cov_series(kernel, use_arg, numeric_only, dtype):
  699:     # GH#46560
  700:     ser = Series([1, 2, 3], dtype=dtype)
  701:     arg = (ser,) if use_arg else ()
  702:     expanding = ser.expanding()
  703:     op = getattr(expanding, kernel)
  704:     if numeric_only and dtype is object:
  705:         msg = f"Expanding.{kernel} does not implement numeric_only"
  706:         with pytest.raises(NotImplementedError, match=msg):
  707:             op(*arg, numeric_only=numeric_only)
  708:     else:
  709:         result = op(*arg, numeric_only=numeric_only)
  710: 
  711:         ser2 = ser.astype(float)
  712:         arg2 = (ser2,) if use_arg else ()
  713:         expanding2 = ser2.expanding()
  714:         op2 = getattr(expanding2, kernel)
  715:         expected = op2(*arg2, numeric_only=numeric_only)
  716:         tm.assert_series_equal(result, expected)
  717: 
  718: 
  719: def test_keyword_quantile_deprecated():
  720:     # GH #52550
  721:     ser = Series([1, 2, 3, 4])
  722:     with tm.assert_produces_warning(FutureWarning):
  723:         ser.expanding().quantile(quantile=0.5)
