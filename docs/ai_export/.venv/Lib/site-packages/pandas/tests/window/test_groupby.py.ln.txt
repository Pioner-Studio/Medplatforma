    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     DatetimeIndex,
    7:     Index,
    8:     MultiIndex,
    9:     Series,
   10:     Timestamp,
   11:     date_range,
   12:     to_datetime,
   13: )
   14: import pandas._testing as tm
   15: from pandas.api.indexers import BaseIndexer
   16: from pandas.core.groupby.groupby import get_groupby
   17: 
   18: 
   19: @pytest.fixture
   20: def times_frame():
   21:     """Frame for testing times argument in EWM groupby."""
   22:     return DataFrame(
   23:         {
   24:             "A": ["a", "b", "c", "a", "b", "c", "a", "b", "c", "a"],
   25:             "B": [0, 0, 0, 1, 1, 1, 2, 2, 2, 3],
   26:             "C": to_datetime(
   27:                 [
   28:                     "2020-01-01",
   29:                     "2020-01-01",
   30:                     "2020-01-01",
   31:                     "2020-01-02",
   32:                     "2020-01-10",
   33:                     "2020-01-22",
   34:                     "2020-01-03",
   35:                     "2020-01-23",
   36:                     "2020-01-23",
   37:                     "2020-01-04",
   38:                 ]
   39:             ),
   40:         }
   41:     )
   42: 
   43: 
   44: @pytest.fixture
   45: def roll_frame():
   46:     return DataFrame({"A": [1] * 20 + [2] * 12 + [3] * 8, "B": np.arange(40)})
   47: 
   48: 
   49: class TestRolling:
   50:     def test_groupby_unsupported_argument(self, roll_frame):
   51:         msg = r"groupby\(\) got an unexpected keyword argument 'foo'"
   52:         with pytest.raises(TypeError, match=msg):
   53:             roll_frame.groupby("A", foo=1)
   54: 
   55:     def test_getitem(self, roll_frame):
   56:         g = roll_frame.groupby("A")
   57:         g_mutated = get_groupby(roll_frame, by="A")
   58: 
   59:         expected = g_mutated.B.apply(lambda x: x.rolling(2).mean())
   60: 
   61:         result = g.rolling(2).mean().B
   62:         tm.assert_series_equal(result, expected)
   63: 
   64:         result = g.rolling(2).B.mean()
   65:         tm.assert_series_equal(result, expected)
   66: 
   67:         result = g.B.rolling(2).mean()
   68:         tm.assert_series_equal(result, expected)
   69: 
   70:         result = roll_frame.B.groupby(roll_frame.A).rolling(2).mean()
   71:         tm.assert_series_equal(result, expected)
   72: 
   73:     def test_getitem_multiple(self, roll_frame):
   74:         # GH 13174
   75:         g = roll_frame.groupby("A")
   76:         r = g.rolling(2, min_periods=0)
   77:         g_mutated = get_groupby(roll_frame, by="A")
   78:         expected = g_mutated.B.apply(lambda x: x.rolling(2, min_periods=0).count())
   79: 
   80:         result = r.B.count()
   81:         tm.assert_series_equal(result, expected)
   82: 
   83:         result = r.B.count()
   84:         tm.assert_series_equal(result, expected)
   85: 
   86:     @pytest.mark.parametrize(
   87:         "f",
   88:         [
   89:             "sum",
   90:             "mean",
   91:             "min",
   92:             "max",
   93:             "count",
   94:             "kurt",
   95:             "skew",
   96:         ],
   97:     )
   98:     def test_rolling(self, f, roll_frame):
   99:         g = roll_frame.groupby("A", group_keys=False)
  100:         r = g.rolling(window=4)
  101: 
  102:         result = getattr(r, f)()
  103:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  104:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  105:             expected = g.apply(lambda x: getattr(x.rolling(4), f)())
  106:         # groupby.apply doesn't drop the grouped-by column
  107:         expected = expected.drop("A", axis=1)
  108:         # GH 39732
  109:         expected_index = MultiIndex.from_arrays([roll_frame["A"], range(40)])
  110:         expected.index = expected_index
  111:         tm.assert_frame_equal(result, expected)
  112: 
  113:     @pytest.mark.parametrize("f", ["std", "var"])
  114:     def test_rolling_ddof(self, f, roll_frame):
  115:         g = roll_frame.groupby("A", group_keys=False)
  116:         r = g.rolling(window=4)
  117: 
  118:         result = getattr(r, f)(ddof=1)
  119:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  120:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  121:             expected = g.apply(lambda x: getattr(x.rolling(4), f)(ddof=1))
  122:         # groupby.apply doesn't drop the grouped-by column
  123:         expected = expected.drop("A", axis=1)
  124:         # GH 39732
  125:         expected_index = MultiIndex.from_arrays([roll_frame["A"], range(40)])
  126:         expected.index = expected_index
  127:         tm.assert_frame_equal(result, expected)
  128: 
  129:     @pytest.mark.parametrize(
  130:         "interpolation", ["linear", "lower", "higher", "midpoint", "nearest"]
  131:     )
  132:     def test_rolling_quantile(self, interpolation, roll_frame):
  133:         g = roll_frame.groupby("A", group_keys=False)
  134:         r = g.rolling(window=4)
  135: 
  136:         result = r.quantile(0.4, interpolation=interpolation)
  137:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  138:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  139:             expected = g.apply(
  140:                 lambda x: x.rolling(4).quantile(0.4, interpolation=interpolation)
  141:             )
  142:         # groupby.apply doesn't drop the grouped-by column
  143:         expected = expected.drop("A", axis=1)
  144:         # GH 39732
  145:         expected_index = MultiIndex.from_arrays([roll_frame["A"], range(40)])
  146:         expected.index = expected_index
  147:         tm.assert_frame_equal(result, expected)
  148: 
  149:     @pytest.mark.parametrize("f, expected_val", [["corr", 1], ["cov", 0.5]])
  150:     def test_rolling_corr_cov_other_same_size_as_groups(self, f, expected_val):
  151:         # GH 42915
  152:         df = DataFrame(
  153:             {"value": range(10), "idx1": [1] * 5 + [2] * 5, "idx2": [1, 2, 3, 4, 5] * 2}
  154:         ).set_index(["idx1", "idx2"])
  155:         other = DataFrame({"value": range(5), "idx2": [1, 2, 3, 4, 5]}).set_index(
  156:             "idx2"
  157:         )
  158:         result = getattr(df.groupby(level=0).rolling(2), f)(other)
  159:         expected_data = ([np.nan] + [expected_val] * 4) * 2
  160:         expected = DataFrame(
  161:             expected_data,
  162:             columns=["value"],
  163:             index=MultiIndex.from_arrays(
  164:                 [
  165:                     [1] * 5 + [2] * 5,
  166:                     [1] * 5 + [2] * 5,
  167:                     list(range(1, 6)) * 2,
  168:                 ],
  169:                 names=["idx1", "idx1", "idx2"],
  170:             ),
  171:         )
  172:         tm.assert_frame_equal(result, expected)
  173: 
  174:     @pytest.mark.parametrize("f", ["corr", "cov"])
  175:     def test_rolling_corr_cov_other_diff_size_as_groups(self, f, roll_frame):
  176:         g = roll_frame.groupby("A")
  177:         r = g.rolling(window=4)
  178: 
  179:         result = getattr(r, f)(roll_frame)
  180: 
  181:         def func(x):
  182:             return getattr(x.rolling(4), f)(roll_frame)
  183: 
  184:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  185:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  186:             expected = g.apply(func)
  187:         # GH 39591: The grouped column should be all np.nan
  188:         # (groupby.apply inserts 0s for cov)
  189:         expected["A"] = np.nan
  190:         tm.assert_frame_equal(result, expected)
  191: 
  192:     @pytest.mark.parametrize("f", ["corr", "cov"])
  193:     def test_rolling_corr_cov_pairwise(self, f, roll_frame):
  194:         g = roll_frame.groupby("A")
  195:         r = g.rolling(window=4)
  196: 
  197:         result = getattr(r.B, f)(pairwise=True)
  198: 
  199:         def func(x):
  200:             return getattr(x.B.rolling(4), f)(pairwise=True)
  201: 
  202:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  203:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  204:             expected = g.apply(func)
  205:         tm.assert_series_equal(result, expected)
  206: 
  207:     @pytest.mark.parametrize(
  208:         "func, expected_values",
  209:         [("cov", [[1.0, 1.0], [1.0, 4.0]]), ("corr", [[1.0, 0.5], [0.5, 1.0]])],
  210:     )
  211:     def test_rolling_corr_cov_unordered(self, func, expected_values):
  212:         # GH 43386
  213:         df = DataFrame(
  214:             {
  215:                 "a": ["g1", "g2", "g1", "g1"],
  216:                 "b": [0, 0, 1, 2],
  217:                 "c": [2, 0, 6, 4],
  218:             }
  219:         )
  220:         rol = df.groupby("a").rolling(3)
  221:         result = getattr(rol, func)()
  222:         expected = DataFrame(
  223:             {
  224:                 "b": 4 * [np.nan] + expected_values[0] + 2 * [np.nan],
  225:                 "c": 4 * [np.nan] + expected_values[1] + 2 * [np.nan],
  226:             },
  227:             index=MultiIndex.from_tuples(
  228:                 [
  229:                     ("g1", 0, "b"),
  230:                     ("g1", 0, "c"),
  231:                     ("g1", 2, "b"),
  232:                     ("g1", 2, "c"),
  233:                     ("g1", 3, "b"),
  234:                     ("g1", 3, "c"),
  235:                     ("g2", 1, "b"),
  236:                     ("g2", 1, "c"),
  237:                 ],
  238:                 names=["a", None, None],
  239:             ),
  240:         )
  241:         tm.assert_frame_equal(result, expected)
  242: 
  243:     def test_rolling_apply(self, raw, roll_frame):
  244:         g = roll_frame.groupby("A", group_keys=False)
  245:         r = g.rolling(window=4)
  246: 
  247:         # reduction
  248:         result = r.apply(lambda x: x.sum(), raw=raw)
  249:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  250:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  251:             expected = g.apply(lambda x: x.rolling(4).apply(lambda y: y.sum(), raw=raw))
  252:         # groupby.apply doesn't drop the grouped-by column
  253:         expected = expected.drop("A", axis=1)
  254:         # GH 39732
  255:         expected_index = MultiIndex.from_arrays([roll_frame["A"], range(40)])
  256:         expected.index = expected_index
  257:         tm.assert_frame_equal(result, expected)
  258: 
  259:     def test_rolling_apply_mutability(self):
  260:         # GH 14013
  261:         df = DataFrame({"A": ["foo"] * 3 + ["bar"] * 3, "B": [1] * 6})
  262:         g = df.groupby("A")
  263: 
  264:         mi = MultiIndex.from_tuples(
  265:             [("bar", 3), ("bar", 4), ("bar", 5), ("foo", 0), ("foo", 1), ("foo", 2)]
  266:         )
  267: 
  268:         mi.names = ["A", None]
  269:         # Grouped column should not be a part of the output
  270:         expected = DataFrame([np.nan, 2.0, 2.0] * 2, columns=["B"], index=mi)
  271: 
  272:         result = g.rolling(window=2).sum()
  273:         tm.assert_frame_equal(result, expected)
  274: 
  275:         # Call an arbitrary function on the groupby
  276:         g.sum()
  277: 
  278:         # Make sure nothing has been mutated
  279:         result = g.rolling(window=2).sum()
  280:         tm.assert_frame_equal(result, expected)
  281: 
  282:     @pytest.mark.parametrize("expected_value,raw_value", [[1.0, True], [0.0, False]])
  283:     def test_groupby_rolling(self, expected_value, raw_value):
  284:         # GH 31754
  285: 
  286:         def isnumpyarray(x):
  287:             return int(isinstance(x, np.ndarray))
  288: 
  289:         df = DataFrame({"id": [1, 1, 1], "value": [1, 2, 3]})
  290:         result = df.groupby("id").value.rolling(1).apply(isnumpyarray, raw=raw_value)
  291:         expected = Series(
  292:             [expected_value] * 3,
  293:             index=MultiIndex.from_tuples(((1, 0), (1, 1), (1, 2)), names=["id", None]),
  294:             name="value",
  295:         )
  296:         tm.assert_series_equal(result, expected)
  297: 
  298:     def test_groupby_rolling_center_center(self):
  299:         # GH 35552
  300:         series = Series(range(1, 6))
  301:         result = series.groupby(series).rolling(center=True, window=3).mean()
  302:         expected = Series(
  303:             [np.nan] * 5,
  304:             index=MultiIndex.from_tuples(((1, 0), (2, 1), (3, 2), (4, 3), (5, 4))),
  305:         )
  306:         tm.assert_series_equal(result, expected)
  307: 
  308:         series = Series(range(1, 5))
  309:         result = series.groupby(series).rolling(center=True, window=3).mean()
  310:         expected = Series(
  311:             [np.nan] * 4,
  312:             index=MultiIndex.from_tuples(((1, 0), (2, 1), (3, 2), (4, 3))),
  313:         )
  314:         tm.assert_series_equal(result, expected)
  315: 
  316:         df = DataFrame({"a": ["a"] * 5 + ["b"] * 6, "b": range(11)})
  317:         result = df.groupby("a").rolling(center=True, window=3).mean()
  318:         expected = DataFrame(
  319:             [np.nan, 1, 2, 3, np.nan, np.nan, 6, 7, 8, 9, np.nan],
  320:             index=MultiIndex.from_tuples(
  321:                 (
  322:                     ("a", 0),
  323:                     ("a", 1),
  324:                     ("a", 2),
  325:                     ("a", 3),
  326:                     ("a", 4),
  327:                     ("b", 5),
  328:                     ("b", 6),
  329:                     ("b", 7),
  330:                     ("b", 8),
  331:                     ("b", 9),
  332:                     ("b", 10),
  333:                 ),
  334:                 names=["a", None],
  335:             ),
  336:             columns=["b"],
  337:         )
  338:         tm.assert_frame_equal(result, expected)
  339: 
  340:         df = DataFrame({"a": ["a"] * 5 + ["b"] * 5, "b": range(10)})
  341:         result = df.groupby("a").rolling(center=True, window=3).mean()
  342:         expected = DataFrame(
  343:             [np.nan, 1, 2, 3, np.nan, np.nan, 6, 7, 8, np.nan],
  344:             index=MultiIndex.from_tuples(
  345:                 (
  346:                     ("a", 0),
  347:                     ("a", 1),
  348:                     ("a", 2),
  349:                     ("a", 3),
  350:                     ("a", 4),
  351:                     ("b", 5),
  352:                     ("b", 6),
  353:                     ("b", 7),
  354:                     ("b", 8),
  355:                     ("b", 9),
  356:                 ),
  357:                 names=["a", None],
  358:             ),
  359:             columns=["b"],
  360:         )
  361:         tm.assert_frame_equal(result, expected)
  362: 
  363:     def test_groupby_rolling_center_on(self):
  364:         # GH 37141
  365:         df = DataFrame(
  366:             data={
  367:                 "Date": date_range("2020-01-01", "2020-01-10"),
  368:                 "gb": ["group_1"] * 6 + ["group_2"] * 4,
  369:                 "value": range(10),
  370:             }
  371:         )
  372:         result = (
  373:             df.groupby("gb")
  374:             .rolling(6, on="Date", center=True, min_periods=1)
  375:             .value.mean()
  376:         )
  377:         mi = MultiIndex.from_arrays([df["gb"], df["Date"]], names=["gb", "Date"])
  378:         expected = Series(
  379:             [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 7.0, 7.5, 7.5, 7.5],
  380:             name="value",
  381:             index=mi,
  382:         )
  383:         tm.assert_series_equal(result, expected)
  384: 
  385:     @pytest.mark.parametrize("min_periods", [5, 4, 3])
  386:     def test_groupby_rolling_center_min_periods(self, min_periods):
  387:         # GH 36040
  388:         df = DataFrame({"group": ["A"] * 10 + ["B"] * 10, "data": range(20)})
  389: 
  390:         window_size = 5
  391:         result = (
  392:             df.groupby("group")
  393:             .rolling(window_size, center=True, min_periods=min_periods)
  394:             .mean()
  395:         )
  396:         result = result.reset_index()[["group", "data"]]
  397: 
  398:         grp_A_mean = [1.0, 1.5, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 7.5, 8.0]
  399:         grp_B_mean = [x + 10.0 for x in grp_A_mean]
  400: 
  401:         num_nans = max(0, min_periods - 3)  # For window_size of 5
  402:         nans = [np.nan] * num_nans
  403:         grp_A_expected = nans + grp_A_mean[num_nans : 10 - num_nans] + nans
  404:         grp_B_expected = nans + grp_B_mean[num_nans : 10 - num_nans] + nans
  405: 
  406:         expected = DataFrame(
  407:             {"group": ["A"] * 10 + ["B"] * 10, "data": grp_A_expected + grp_B_expected}
  408:         )
  409: 
  410:         tm.assert_frame_equal(result, expected)
  411: 
  412:     def test_groupby_subselect_rolling(self):
  413:         # GH 35486
  414:         df = DataFrame(
  415:             {"a": [1, 2, 3, 2], "b": [4.0, 2.0, 3.0, 1.0], "c": [10, 20, 30, 20]}
  416:         )
  417:         result = df.groupby("a")[["b"]].rolling(2).max()
  418:         expected = DataFrame(
  419:             [np.nan, np.nan, 2.0, np.nan],
  420:             columns=["b"],
  421:             index=MultiIndex.from_tuples(
  422:                 ((1, 0), (2, 1), (2, 3), (3, 2)), names=["a", None]
  423:             ),
  424:         )
  425:         tm.assert_frame_equal(result, expected)
  426: 
  427:         result = df.groupby("a")["b"].rolling(2).max()
  428:         expected = Series(
  429:             [np.nan, np.nan, 2.0, np.nan],
  430:             index=MultiIndex.from_tuples(
  431:                 ((1, 0), (2, 1), (2, 3), (3, 2)), names=["a", None]
  432:             ),
  433:             name="b",
  434:         )
  435:         tm.assert_series_equal(result, expected)
  436: 
  437:     def test_groupby_rolling_custom_indexer(self):
  438:         # GH 35557
  439:         class SimpleIndexer(BaseIndexer):
  440:             def get_window_bounds(
  441:                 self,
  442:                 num_values=0,
  443:                 min_periods=None,
  444:                 center=None,
  445:                 closed=None,
  446:                 step=None,
  447:             ):
  448:                 min_periods = self.window_size if min_periods is None else 0
  449:                 end = np.arange(num_values, dtype=np.int64) + 1
  450:                 start = end.copy() - self.window_size
  451:                 start[start < 0] = min_periods
  452:                 return start, end
  453: 
  454:         df = DataFrame(
  455:             {"a": [1.0, 2.0, 3.0, 4.0, 5.0] * 3}, index=[0] * 5 + [1] * 5 + [2] * 5
  456:         )
  457:         result = (
  458:             df.groupby(df.index)
  459:             .rolling(SimpleIndexer(window_size=3), min_periods=1)
  460:             .sum()
  461:         )
  462:         expected = df.groupby(df.index).rolling(window=3, min_periods=1).sum()
  463:         tm.assert_frame_equal(result, expected)
  464: 
  465:     def test_groupby_rolling_subset_with_closed(self):
  466:         # GH 35549
  467:         df = DataFrame(
  468:             {
  469:                 "column1": range(8),
  470:                 "column2": range(8),
  471:                 "group": ["A"] * 4 + ["B"] * 4,
  472:                 "date": [
  473:                     Timestamp(date)
  474:                     for date in ["2019-01-01", "2019-01-01", "2019-01-02", "2019-01-02"]
  475:                 ]
  476:                 * 2,
  477:             }
  478:         )
  479:         result = (
  480:             df.groupby("group").rolling("1D", on="date", closed="left")["column1"].sum()
  481:         )
  482:         expected = Series(
  483:             [np.nan, np.nan, 1.0, 1.0, np.nan, np.nan, 9.0, 9.0],
  484:             index=MultiIndex.from_frame(
  485:                 df[["group", "date"]],
  486:                 names=["group", "date"],
  487:             ),
  488:             name="column1",
  489:         )
  490:         tm.assert_series_equal(result, expected)
  491: 
  492:     def test_groupby_subset_rolling_subset_with_closed(self):
  493:         # GH 35549
  494:         df = DataFrame(
  495:             {
  496:                 "column1": range(8),
  497:                 "column2": range(8),
  498:                 "group": ["A"] * 4 + ["B"] * 4,
  499:                 "date": [
  500:                     Timestamp(date)
  501:                     for date in ["2019-01-01", "2019-01-01", "2019-01-02", "2019-01-02"]
  502:                 ]
  503:                 * 2,
  504:             }
  505:         )
  506: 
  507:         result = (
  508:             df.groupby("group")[["column1", "date"]]
  509:             .rolling("1D", on="date", closed="left")["column1"]
  510:             .sum()
  511:         )
  512:         expected = Series(
  513:             [np.nan, np.nan, 1.0, 1.0, np.nan, np.nan, 9.0, 9.0],
  514:             index=MultiIndex.from_frame(
  515:                 df[["group", "date"]],
  516:                 names=["group", "date"],
  517:             ),
  518:             name="column1",
  519:         )
  520:         tm.assert_series_equal(result, expected)
  521: 
  522:     @pytest.mark.parametrize("func", ["max", "min"])
  523:     def test_groupby_rolling_index_changed(self, func):
  524:         # GH: #36018 nlevels of MultiIndex changed
  525:         ds = Series(
  526:             [1, 2, 2],
  527:             index=MultiIndex.from_tuples(
  528:                 [("a", "x"), ("a", "y"), ("c", "z")], names=["1", "2"]
  529:             ),
  530:             name="a",
  531:         )
  532: 
  533:         result = getattr(ds.groupby(ds).rolling(2), func)()
  534:         expected = Series(
  535:             [np.nan, np.nan, 2.0],
  536:             index=MultiIndex.from_tuples(
  537:                 [(1, "a", "x"), (2, "a", "y"), (2, "c", "z")], names=["a", "1", "2"]
  538:             ),
  539:             name="a",
  540:         )
  541:         tm.assert_series_equal(result, expected)
  542: 
  543:     def test_groupby_rolling_empty_frame(self):
  544:         # GH 36197
  545:         expected = DataFrame({"s1": []})
  546:         result = expected.groupby("s1").rolling(window=1).sum()
  547:         # GH 32262
  548:         expected = expected.drop(columns="s1")
  549:         # GH-38057 from_tuples gives empty object dtype, we now get float/int levels
  550:         # expected.index = MultiIndex.from_tuples([], names=["s1", None])
  551:         expected.index = MultiIndex.from_product(
  552:             [Index([], dtype="float64"), Index([], dtype="int64")], names=["s1", None]
  553:         )
  554:         tm.assert_frame_equal(result, expected)
  555: 
  556:         expected = DataFrame({"s1": [], "s2": []})
  557:         result = expected.groupby(["s1", "s2"]).rolling(window=1).sum()
  558:         # GH 32262
  559:         expected = expected.drop(columns=["s1", "s2"])
  560:         expected.index = MultiIndex.from_product(
  561:             [
  562:                 Index([], dtype="float64"),
  563:                 Index([], dtype="float64"),
  564:                 Index([], dtype="int64"),
  565:             ],
  566:             names=["s1", "s2", None],
  567:         )
  568:         tm.assert_frame_equal(result, expected)
  569: 
  570:     def test_groupby_rolling_string_index(self):
  571:         # GH: 36727
  572:         df = DataFrame(
  573:             [
  574:                 ["A", "group_1", Timestamp(2019, 1, 1, 9)],
  575:                 ["B", "group_1", Timestamp(2019, 1, 2, 9)],
  576:                 ["Z", "group_2", Timestamp(2019, 1, 3, 9)],
  577:                 ["H", "group_1", Timestamp(2019, 1, 6, 9)],
  578:                 ["E", "group_2", Timestamp(2019, 1, 20, 9)],
  579:             ],
  580:             columns=["index", "group", "eventTime"],
  581:         ).set_index("index")
  582: 
  583:         groups = df.groupby("group")
  584:         df["count_to_date"] = groups.cumcount()
  585:         rolling_groups = groups.rolling("10d", on="eventTime")
  586:         result = rolling_groups.apply(lambda df: df.shape[0])
  587:         expected = DataFrame(
  588:             [
  589:                 ["A", "group_1", Timestamp(2019, 1, 1, 9), 1.0],
  590:                 ["B", "group_1", Timestamp(2019, 1, 2, 9), 2.0],
  591:                 ["H", "group_1", Timestamp(2019, 1, 6, 9), 3.0],
  592:                 ["Z", "group_2", Timestamp(2019, 1, 3, 9), 1.0],
  593:                 ["E", "group_2", Timestamp(2019, 1, 20, 9), 1.0],
  594:             ],
  595:             columns=["index", "group", "eventTime", "count_to_date"],
  596:         ).set_index(["group", "index"])
  597:         tm.assert_frame_equal(result, expected)
  598: 
  599:     def test_groupby_rolling_no_sort(self):
  600:         # GH 36889
  601:         result = (
  602:             DataFrame({"foo": [2, 1], "bar": [2, 1]})
  603:             .groupby("foo", sort=False)
  604:             .rolling(1)
  605:             .min()
  606:         )
  607:         expected = DataFrame(
  608:             np.array([[2.0, 2.0], [1.0, 1.0]]),
  609:             columns=["foo", "bar"],
  610:             index=MultiIndex.from_tuples([(2, 0), (1, 1)], names=["foo", None]),
  611:         )
  612:         # GH 32262
  613:         expected = expected.drop(columns="foo")
  614:         tm.assert_frame_equal(result, expected)
  615: 
  616:     def test_groupby_rolling_count_closed_on(self, unit):
  617:         # GH 35869
  618:         df = DataFrame(
  619:             {
  620:                 "column1": range(6),
  621:                 "column2": range(6),
  622:                 "group": 3 * ["A", "B"],
  623:                 "date": date_range(end="20190101", periods=6, unit=unit),
  624:             }
  625:         )
  626:         result = (
  627:             df.groupby("group")
  628:             .rolling("3d", on="date", closed="left")["column1"]
  629:             .count()
  630:         )
  631:         dti = DatetimeIndex(
  632:             [
  633:                 "2018-12-27",
  634:                 "2018-12-29",
  635:                 "2018-12-31",
  636:                 "2018-12-28",
  637:                 "2018-12-30",
  638:                 "2019-01-01",
  639:             ],
  640:             dtype=f"M8[{unit}]",
  641:         )
  642:         mi = MultiIndex.from_arrays(
  643:             [
  644:                 ["A", "A", "A", "B", "B", "B"],
  645:                 dti,
  646:             ],
  647:             names=["group", "date"],
  648:         )
  649:         expected = Series(
  650:             [np.nan, 1.0, 1.0, np.nan, 1.0, 1.0],
  651:             name="column1",
  652:             index=mi,
  653:         )
  654:         tm.assert_series_equal(result, expected)
  655: 
  656:     @pytest.mark.parametrize(
  657:         ("func", "kwargs"),
  658:         [("rolling", {"window": 2, "min_periods": 1}), ("expanding", {})],
  659:     )
  660:     def test_groupby_rolling_sem(self, func, kwargs):
  661:         # GH: 26476
  662:         df = DataFrame(
  663:             [["a", 1], ["a", 2], ["b", 1], ["b", 2], ["b", 3]], columns=["a", "b"]
  664:         )
  665:         result = getattr(df.groupby("a"), func)(**kwargs).sem()
  666:         expected = DataFrame(
  667:             {"a": [np.nan] * 5, "b": [np.nan, 0.70711, np.nan, 0.70711, 0.70711]},
  668:             index=MultiIndex.from_tuples(
  669:                 [("a", 0), ("a", 1), ("b", 2), ("b", 3), ("b", 4)], names=["a", None]
  670:             ),
  671:         )
  672:         # GH 32262
  673:         expected = expected.drop(columns="a")
  674:         tm.assert_frame_equal(result, expected)
  675: 
  676:     @pytest.mark.parametrize(
  677:         ("rollings", "key"), [({"on": "a"}, "a"), ({"on": None}, "index")]
  678:     )
  679:     def test_groupby_rolling_nans_in_index(self, rollings, key):
  680:         # GH: 34617
  681:         df = DataFrame(
  682:             {
  683:                 "a": to_datetime(["2020-06-01 12:00", "2020-06-01 14:00", np.nan]),
  684:                 "b": [1, 2, 3],
  685:                 "c": [1, 1, 1],
  686:             }
  687:         )
  688:         if key == "index":
  689:             df = df.set_index("a")
  690:         with pytest.raises(ValueError, match=f"{key} values must not have NaT"):
  691:             df.groupby("c").rolling("60min", **rollings)
  692: 
  693:     @pytest.mark.parametrize("group_keys", [True, False])
  694:     def test_groupby_rolling_group_keys(self, group_keys):
  695:         # GH 37641
  696:         # GH 38523: GH 37641 actually was not a bug.
  697:         # group_keys only applies to groupby.apply directly
  698:         arrays = [["val1", "val1", "val2"], ["val1", "val1", "val2"]]
  699:         index = MultiIndex.from_arrays(arrays, names=("idx1", "idx2"))
  700: 
  701:         s = Series([1, 2, 3], index=index)
  702:         result = s.groupby(["idx1", "idx2"], group_keys=group_keys).rolling(1).mean()
  703:         expected = Series(
  704:             [1.0, 2.0, 3.0],
  705:             index=MultiIndex.from_tuples(
  706:                 [
  707:                     ("val1", "val1", "val1", "val1"),
  708:                     ("val1", "val1", "val1", "val1"),
  709:                     ("val2", "val2", "val2", "val2"),
  710:                 ],
  711:                 names=["idx1", "idx2", "idx1", "idx2"],
  712:             ),
  713:         )
  714:         tm.assert_series_equal(result, expected)
  715: 
  716:     def test_groupby_rolling_index_level_and_column_label(self):
  717:         # The groupby keys should not appear as a resulting column
  718:         arrays = [["val1", "val1", "val2"], ["val1", "val1", "val2"]]
  719:         index = MultiIndex.from_arrays(arrays, names=("idx1", "idx2"))
  720: 
  721:         df = DataFrame({"A": [1, 1, 2], "B": range(3)}, index=index)
  722:         result = df.groupby(["idx1", "A"]).rolling(1).mean()
  723:         expected = DataFrame(
  724:             {"B": [0.0, 1.0, 2.0]},
  725:             index=MultiIndex.from_tuples(
  726:                 [
  727:                     ("val1", 1, "val1", "val1"),
  728:                     ("val1", 1, "val1", "val1"),
  729:                     ("val2", 2, "val2", "val2"),
  730:                 ],
  731:                 names=["idx1", "A", "idx1", "idx2"],
  732:             ),
  733:         )
  734:         tm.assert_frame_equal(result, expected)
  735: 
  736:     def test_groupby_rolling_resulting_multiindex(self):
  737:         # a few different cases checking the created MultiIndex of the result
  738:         # https://github.com/pandas-dev/pandas/pull/38057
  739: 
  740:         # grouping by 1 columns -> 2-level MI as result
  741:         df = DataFrame({"a": np.arange(8.0), "b": [1, 2] * 4})
  742:         result = df.groupby("b").rolling(3).mean()
  743:         expected_index = MultiIndex.from_tuples(
  744:             [(1, 0), (1, 2), (1, 4), (1, 6), (2, 1), (2, 3), (2, 5), (2, 7)],
  745:             names=["b", None],
  746:         )
  747:         tm.assert_index_equal(result.index, expected_index)
  748: 
  749:     def test_groupby_rolling_resulting_multiindex2(self):
  750:         # grouping by 2 columns -> 3-level MI as result
  751:         df = DataFrame({"a": np.arange(12.0), "b": [1, 2] * 6, "c": [1, 2, 3, 4] * 3})
  752:         result = df.groupby(["b", "c"]).rolling(2).sum()
  753:         expected_index = MultiIndex.from_tuples(
  754:             [
  755:                 (1, 1, 0),
  756:                 (1, 1, 4),
  757:                 (1, 1, 8),
  758:                 (1, 3, 2),
  759:                 (1, 3, 6),
  760:                 (1, 3, 10),
  761:                 (2, 2, 1),
  762:                 (2, 2, 5),
  763:                 (2, 2, 9),
  764:                 (2, 4, 3),
  765:                 (2, 4, 7),
  766:                 (2, 4, 11),
  767:             ],
  768:             names=["b", "c", None],
  769:         )
  770:         tm.assert_index_equal(result.index, expected_index)
  771: 
  772:     def test_groupby_rolling_resulting_multiindex3(self):
  773:         # grouping with 1 level on dataframe with 2-level MI -> 3-level MI as result
  774:         df = DataFrame({"a": np.arange(8.0), "b": [1, 2] * 4, "c": [1, 2, 3, 4] * 2})
  775:         df = df.set_index("c", append=True)
  776:         result = df.groupby("b").rolling(3).mean()
  777:         expected_index = MultiIndex.from_tuples(
  778:             [
  779:                 (1, 0, 1),
  780:                 (1, 2, 3),
  781:                 (1, 4, 1),
  782:                 (1, 6, 3),
  783:                 (2, 1, 2),
  784:                 (2, 3, 4),
  785:                 (2, 5, 2),
  786:                 (2, 7, 4),
  787:             ],
  788:             names=["b", None, "c"],
  789:         )
  790:         tm.assert_index_equal(result.index, expected_index, exact="equiv")
  791: 
  792:     def test_groupby_rolling_object_doesnt_affect_groupby_apply(self, roll_frame):
  793:         # GH 39732
  794:         g = roll_frame.groupby("A", group_keys=False)
  795:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  796:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  797:             expected = g.apply(lambda x: x.rolling(4).sum()).index
  798:         _ = g.rolling(window=4)
  799:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  800:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  801:             result = g.apply(lambda x: x.rolling(4).sum()).index
  802:         tm.assert_index_equal(result, expected)
  803: 
  804:     @pytest.mark.parametrize(
  805:         ("window", "min_periods", "closed", "expected"),
  806:         [
  807:             (2, 0, "left", [None, 0.0, 1.0, 1.0, None, 0.0, 1.0, 1.0]),
  808:             (2, 2, "left", [None, None, 1.0, 1.0, None, None, 1.0, 1.0]),
  809:             (4, 4, "left", [None, None, None, None, None, None, None, None]),
  810:             (4, 4, "right", [None, None, None, 5.0, None, None, None, 5.0]),
  811:         ],
  812:     )
  813:     def test_groupby_rolling_var(self, window, min_periods, closed, expected):
  814:         df = DataFrame([1, 2, 3, 4, 5, 6, 7, 8])
  815:         result = (
  816:             df.groupby([1, 2, 1, 2, 1, 2, 1, 2])
  817:             .rolling(window=window, min_periods=min_periods, closed=closed)
  818:             .var(0)
  819:         )
  820:         expected_result = DataFrame(
  821:             np.array(expected, dtype="float64"),
  822:             index=MultiIndex(
  823:                 levels=[np.array([1, 2]), [0, 1, 2, 3, 4, 5, 6, 7]],
  824:                 codes=[[0, 0, 0, 0, 1, 1, 1, 1], [0, 2, 4, 6, 1, 3, 5, 7]],
  825:             ),
  826:         )
  827:         tm.assert_frame_equal(result, expected_result)
  828: 
  829:     @pytest.mark.parametrize(
  830:         "columns", [MultiIndex.from_tuples([("A", ""), ("B", "C")]), ["A", "B"]]
  831:     )
  832:     def test_by_column_not_in_values(self, columns):
  833:         # GH 32262
  834:         df = DataFrame([[1, 0]] * 20 + [[2, 0]] * 12 + [[3, 0]] * 8, columns=columns)
  835:         g = df.groupby("A")
  836:         original_obj = g.obj.copy(deep=True)
  837:         r = g.rolling(4)
  838:         result = r.sum()
  839:         assert "A" not in result.columns
  840:         tm.assert_frame_equal(g.obj, original_obj)
  841: 
  842:     def test_groupby_level(self):
  843:         # GH 38523, 38787
  844:         arrays = [
  845:             ["Falcon", "Falcon", "Parrot", "Parrot"],
  846:             ["Captive", "Wild", "Captive", "Wild"],
  847:         ]
  848:         index = MultiIndex.from_arrays(arrays, names=("Animal", "Type"))
  849:         df = DataFrame({"Max Speed": [390.0, 350.0, 30.0, 20.0]}, index=index)
  850:         result = df.groupby(level=0)["Max Speed"].rolling(2).sum()
  851:         expected = Series(
  852:             [np.nan, 740.0, np.nan, 50.0],
  853:             index=MultiIndex.from_tuples(
  854:                 [
  855:                     ("Falcon", "Falcon", "Captive"),
  856:                     ("Falcon", "Falcon", "Wild"),
  857:                     ("Parrot", "Parrot", "Captive"),
  858:                     ("Parrot", "Parrot", "Wild"),
  859:                 ],
  860:                 names=["Animal", "Animal", "Type"],
  861:             ),
  862:             name="Max Speed",
  863:         )
  864:         tm.assert_series_equal(result, expected)
  865: 
  866:     @pytest.mark.parametrize(
  867:         "by, expected_data",
  868:         [
  869:             [["id"], {"num": [100.0, 150.0, 150.0, 200.0]}],
  870:             [
  871:                 ["id", "index"],
  872:                 {
  873:                     "date": [
  874:                         Timestamp("2018-01-01"),
  875:                         Timestamp("2018-01-02"),
  876:                         Timestamp("2018-01-01"),
  877:                         Timestamp("2018-01-02"),
  878:                     ],
  879:                     "num": [100.0, 200.0, 150.0, 250.0],
  880:                 },
  881:             ],
  882:         ],
  883:     )
  884:     def test_as_index_false(self, by, expected_data, unit):
  885:         # GH 39433
  886:         data = [
  887:             ["A", "2018-01-01", 100.0],
  888:             ["A", "2018-01-02", 200.0],
  889:             ["B", "2018-01-01", 150.0],
  890:             ["B", "2018-01-02", 250.0],
  891:         ]
  892:         df = DataFrame(data, columns=["id", "date", "num"])
  893:         df["date"] = df["date"].astype(f"M8[{unit}]")
  894:         df = df.set_index(["date"])
  895: 
  896:         gp_by = [getattr(df, attr) for attr in by]
  897:         result = (
  898:             df.groupby(gp_by, as_index=False).rolling(window=2, min_periods=1).mean()
  899:         )
  900: 
  901:         expected = {"id": ["A", "A", "B", "B"]}
  902:         expected.update(expected_data)
  903:         expected = DataFrame(
  904:             expected,
  905:             index=df.index,
  906:         )
  907:         if "date" in expected_data:
  908:             expected["date"] = expected["date"].astype(f"M8[{unit}]")
  909:         tm.assert_frame_equal(result, expected)
  910: 
  911:     def test_nan_and_zero_endpoints(self, any_int_numpy_dtype):
  912:         # https://github.com/twosigma/pandas/issues/53
  913:         typ = np.dtype(any_int_numpy_dtype).type
  914:         size = 1000
  915:         idx = np.repeat(typ(0), size)
  916:         idx[-1] = 1
  917: 
  918:         val = 5e25
  919:         arr = np.repeat(val, size)
  920:         arr[0] = np.nan
  921:         arr[-1] = 0
  922: 
  923:         df = DataFrame(
  924:             {
  925:                 "index": idx,
  926:                 "adl2": arr,
  927:             }
  928:         ).set_index("index")
  929:         result = df.groupby("index")["adl2"].rolling(window=10, min_periods=1).mean()
  930:         expected = Series(
  931:             arr,
  932:             name="adl2",
  933:             index=MultiIndex.from_arrays(
  934:                 [
  935:                     Index([0] * 999 + [1], dtype=typ, name="index"),
  936:                     Index([0] * 999 + [1], dtype=typ, name="index"),
  937:                 ],
  938:             ),
  939:         )
  940:         tm.assert_series_equal(result, expected)
  941: 
  942:     def test_groupby_rolling_non_monotonic(self):
  943:         # GH 43909
  944: 
  945:         shuffled = [3, 0, 1, 2]
  946:         sec = 1_000
  947:         df = DataFrame(
  948:             [{"t": Timestamp(2 * x * sec), "x": x + 1, "c": 42} for x in shuffled]
  949:         )
  950:         with pytest.raises(ValueError, match=r".* must be monotonic"):
  951:             df.groupby("c").rolling(on="t", window="3s")
  952: 
  953:     def test_groupby_monotonic(self):
  954:         # GH 15130
  955:         # we don't need to validate monotonicity when grouping
  956: 
  957:         # GH 43909 we should raise an error here to match
  958:         # behaviour of non-groupby rolling.
  959: 
  960:         data = [
  961:             ["David", "1/1/2015", 100],
  962:             ["David", "1/5/2015", 500],
  963:             ["David", "5/30/2015", 50],
  964:             ["David", "7/25/2015", 50],
  965:             ["Ryan", "1/4/2014", 100],
  966:             ["Ryan", "1/19/2015", 500],
  967:             ["Ryan", "3/31/2016", 50],
  968:             ["Joe", "7/1/2015", 100],
  969:             ["Joe", "9/9/2015", 500],
  970:             ["Joe", "10/15/2015", 50],
  971:         ]
  972: 
  973:         df = DataFrame(data=data, columns=["name", "date", "amount"])
  974:         df["date"] = to_datetime(df["date"])
  975:         df = df.sort_values("date")
  976: 
  977:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  978:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  979:             expected = (
  980:                 df.set_index("date")
  981:                 .groupby("name")
  982:                 .apply(lambda x: x.rolling("180D")["amount"].sum())
  983:             )
  984:         result = df.groupby("name").rolling("180D", on="date")["amount"].sum()
  985:         tm.assert_series_equal(result, expected)
  986: 
  987:     def test_datelike_on_monotonic_within_each_group(self):
  988:         # GH 13966 (similar to #15130, closed by #15175)
  989: 
  990:         # superseded by 43909
  991:         # GH 46061: OK if the on is monotonic relative to each each group
  992: 
  993:         dates = date_range(start="2016-01-01 09:30:00", periods=20, freq="s")
  994:         df = DataFrame(
  995:             {
  996:                 "A": [1] * 20 + [2] * 12 + [3] * 8,
  997:                 "B": np.concatenate((dates, dates)),
  998:                 "C": np.arange(40),
  999:             }
 1000:         )
 1001: 
 1002:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1003:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1004:             expected = (
 1005:                 df.set_index("B")
 1006:                 .groupby("A")
 1007:                 .apply(lambda x: x.rolling("4s")["C"].mean())
 1008:             )
 1009:         result = df.groupby("A").rolling("4s", on="B").C.mean()
 1010:         tm.assert_series_equal(result, expected)
 1011: 
 1012:     def test_datelike_on_not_monotonic_within_each_group(self):
 1013:         # GH 46061
 1014:         df = DataFrame(
 1015:             {
 1016:                 "A": [1] * 3 + [2] * 3,
 1017:                 "B": [Timestamp(year, 1, 1) for year in [2020, 2021, 2019]] * 2,
 1018:                 "C": range(6),
 1019:             }
 1020:         )
 1021:         with pytest.raises(ValueError, match="Each group within B must be monotonic."):
 1022:             df.groupby("A").rolling("365D", on="B")
 1023: 
 1024: 
 1025: class TestExpanding:
 1026:     @pytest.fixture
 1027:     def frame(self):
 1028:         return DataFrame({"A": [1] * 20 + [2] * 12 + [3] * 8, "B": np.arange(40)})
 1029: 
 1030:     @pytest.mark.parametrize(
 1031:         "f", ["sum", "mean", "min", "max", "count", "kurt", "skew"]
 1032:     )
 1033:     def test_expanding(self, f, frame):
 1034:         g = frame.groupby("A", group_keys=False)
 1035:         r = g.expanding()
 1036: 
 1037:         result = getattr(r, f)()
 1038:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1039:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1040:             expected = g.apply(lambda x: getattr(x.expanding(), f)())
 1041:         # groupby.apply doesn't drop the grouped-by column
 1042:         expected = expected.drop("A", axis=1)
 1043:         # GH 39732
 1044:         expected_index = MultiIndex.from_arrays([frame["A"], range(40)])
 1045:         expected.index = expected_index
 1046:         tm.assert_frame_equal(result, expected)
 1047: 
 1048:     @pytest.mark.parametrize("f", ["std", "var"])
 1049:     def test_expanding_ddof(self, f, frame):
 1050:         g = frame.groupby("A", group_keys=False)
 1051:         r = g.expanding()
 1052: 
 1053:         result = getattr(r, f)(ddof=0)
 1054:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1055:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1056:             expected = g.apply(lambda x: getattr(x.expanding(), f)(ddof=0))
 1057:         # groupby.apply doesn't drop the grouped-by column
 1058:         expected = expected.drop("A", axis=1)
 1059:         # GH 39732
 1060:         expected_index = MultiIndex.from_arrays([frame["A"], range(40)])
 1061:         expected.index = expected_index
 1062:         tm.assert_frame_equal(result, expected)
 1063: 
 1064:     @pytest.mark.parametrize(
 1065:         "interpolation", ["linear", "lower", "higher", "midpoint", "nearest"]
 1066:     )
 1067:     def test_expanding_quantile(self, interpolation, frame):
 1068:         g = frame.groupby("A", group_keys=False)
 1069:         r = g.expanding()
 1070: 
 1071:         result = r.quantile(0.4, interpolation=interpolation)
 1072:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1073:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1074:             expected = g.apply(
 1075:                 lambda x: x.expanding().quantile(0.4, interpolation=interpolation)
 1076:             )
 1077:         # groupby.apply doesn't drop the grouped-by column
 1078:         expected = expected.drop("A", axis=1)
 1079:         # GH 39732
 1080:         expected_index = MultiIndex.from_arrays([frame["A"], range(40)])
 1081:         expected.index = expected_index
 1082:         tm.assert_frame_equal(result, expected)
 1083: 
 1084:     @pytest.mark.parametrize("f", ["corr", "cov"])
 1085:     def test_expanding_corr_cov(self, f, frame):
 1086:         g = frame.groupby("A")
 1087:         r = g.expanding()
 1088: 
 1089:         result = getattr(r, f)(frame)
 1090: 
 1091:         def func_0(x):
 1092:             return getattr(x.expanding(), f)(frame)
 1093: 
 1094:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1095:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1096:             expected = g.apply(func_0)
 1097:         # GH 39591: groupby.apply returns 1 instead of nan for windows
 1098:         # with all nan values
 1099:         null_idx = list(range(20, 61)) + list(range(72, 113))
 1100:         expected.iloc[null_idx, 1] = np.nan
 1101:         # GH 39591: The grouped column should be all np.nan
 1102:         # (groupby.apply inserts 0s for cov)
 1103:         expected["A"] = np.nan
 1104:         tm.assert_frame_equal(result, expected)
 1105: 
 1106:         result = getattr(r.B, f)(pairwise=True)
 1107: 
 1108:         def func_1(x):
 1109:             return getattr(x.B.expanding(), f)(pairwise=True)
 1110: 
 1111:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1112:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1113:             expected = g.apply(func_1)
 1114:         tm.assert_series_equal(result, expected)
 1115: 
 1116:     def test_expanding_apply(self, raw, frame):
 1117:         g = frame.groupby("A", group_keys=False)
 1118:         r = g.expanding()
 1119: 
 1120:         # reduction
 1121:         result = r.apply(lambda x: x.sum(), raw=raw)
 1122:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1123:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1124:             expected = g.apply(
 1125:                 lambda x: x.expanding().apply(lambda y: y.sum(), raw=raw)
 1126:             )
 1127:         # groupby.apply doesn't drop the grouped-by column
 1128:         expected = expected.drop("A", axis=1)
 1129:         # GH 39732
 1130:         expected_index = MultiIndex.from_arrays([frame["A"], range(40)])
 1131:         expected.index = expected_index
 1132:         tm.assert_frame_equal(result, expected)
 1133: 
 1134: 
 1135: class TestEWM:
 1136:     @pytest.mark.parametrize(
 1137:         "method, expected_data",
 1138:         [
 1139:             ["mean", [0.0, 0.6666666666666666, 1.4285714285714286, 2.2666666666666666]],
 1140:             ["std", [np.nan, 0.707107, 0.963624, 1.177164]],
 1141:             ["var", [np.nan, 0.5, 0.9285714285714286, 1.3857142857142857]],
 1142:         ],
 1143:     )
 1144:     def test_methods(self, method, expected_data):
 1145:         # GH 16037
 1146:         df = DataFrame({"A": ["a"] * 4, "B": range(4)})
 1147:         result = getattr(df.groupby("A").ewm(com=1.0), method)()
 1148:         expected = DataFrame(
 1149:             {"B": expected_data},
 1150:             index=MultiIndex.from_tuples(
 1151:                 [
 1152:                     ("a", 0),
 1153:                     ("a", 1),
 1154:                     ("a", 2),
 1155:                     ("a", 3),
 1156:                 ],
 1157:                 names=["A", None],
 1158:             ),
 1159:         )
 1160:         tm.assert_frame_equal(result, expected)
 1161: 
 1162:     @pytest.mark.parametrize(
 1163:         "method, expected_data",
 1164:         [["corr", [np.nan, 1.0, 1.0, 1]], ["cov", [np.nan, 0.5, 0.928571, 1.385714]]],
 1165:     )
 1166:     def test_pairwise_methods(self, method, expected_data):
 1167:         # GH 16037
 1168:         df = DataFrame({"A": ["a"] * 4, "B": range(4)})
 1169:         result = getattr(df.groupby("A").ewm(com=1.0), method)()
 1170:         expected = DataFrame(
 1171:             {"B": expected_data},
 1172:             index=MultiIndex.from_tuples(
 1173:                 [
 1174:                     ("a", 0, "B"),
 1175:                     ("a", 1, "B"),
 1176:                     ("a", 2, "B"),
 1177:                     ("a", 3, "B"),
 1178:                 ],
 1179:                 names=["A", None, None],
 1180:             ),
 1181:         )
 1182:         tm.assert_frame_equal(result, expected)
 1183: 
 1184:         expected = df.groupby("A")[["B"]].apply(
 1185:             lambda x: getattr(x.ewm(com=1.0), method)()
 1186:         )
 1187:         tm.assert_frame_equal(result, expected)
 1188: 
 1189:     def test_times(self, times_frame):
 1190:         # GH 40951
 1191:         halflife = "23 days"
 1192:         # GH#42738
 1193:         times = times_frame.pop("C")
 1194:         result = times_frame.groupby("A").ewm(halflife=halflife, times=times).mean()
 1195:         expected = DataFrame(
 1196:             {
 1197:                 "B": [
 1198:                     0.0,
 1199:                     0.507534,
 1200:                     1.020088,
 1201:                     1.537661,
 1202:                     0.0,
 1203:                     0.567395,
 1204:                     1.221209,
 1205:                     0.0,
 1206:                     0.653141,
 1207:                     1.195003,
 1208:                 ]
 1209:             },
 1210:             index=MultiIndex.from_tuples(
 1211:                 [
 1212:                     ("a", 0),
 1213:                     ("a", 3),
 1214:                     ("a", 6),
 1215:                     ("a", 9),
 1216:                     ("b", 1),
 1217:                     ("b", 4),
 1218:                     ("b", 7),
 1219:                     ("c", 2),
 1220:                     ("c", 5),
 1221:                     ("c", 8),
 1222:                 ],
 1223:                 names=["A", None],
 1224:             ),
 1225:         )
 1226:         tm.assert_frame_equal(result, expected)
 1227: 
 1228:     def test_times_array(self, times_frame):
 1229:         # GH 40951
 1230:         halflife = "23 days"
 1231:         times = times_frame.pop("C")
 1232:         gb = times_frame.groupby("A")
 1233:         result = gb.ewm(halflife=halflife, times=times).mean()
 1234:         expected = gb.ewm(halflife=halflife, times=times.values).mean()
 1235:         tm.assert_frame_equal(result, expected)
 1236: 
 1237:     def test_dont_mutate_obj_after_slicing(self):
 1238:         # GH 43355
 1239:         df = DataFrame(
 1240:             {
 1241:                 "id": ["a", "a", "b", "b", "b"],
 1242:                 "timestamp": date_range("2021-9-1", periods=5, freq="h"),
 1243:                 "y": range(5),
 1244:             }
 1245:         )
 1246:         grp = df.groupby("id").rolling("1h", on="timestamp")
 1247:         result = grp.count()
 1248:         expected_df = DataFrame(
 1249:             {
 1250:                 "timestamp": date_range("2021-9-1", periods=5, freq="h"),
 1251:                 "y": [1.0] * 5,
 1252:             },
 1253:             index=MultiIndex.from_arrays(
 1254:                 [["a", "a", "b", "b", "b"], list(range(5))], names=["id", None]
 1255:             ),
 1256:         )
 1257:         tm.assert_frame_equal(result, expected_df)
 1258: 
 1259:         result = grp["y"].count()
 1260:         expected_series = Series(
 1261:             [1.0] * 5,
 1262:             index=MultiIndex.from_arrays(
 1263:                 [
 1264:                     ["a", "a", "b", "b", "b"],
 1265:                     date_range("2021-9-1", periods=5, freq="h"),
 1266:                 ],
 1267:                 names=["id", "timestamp"],
 1268:             ),
 1269:             name="y",
 1270:         )
 1271:         tm.assert_series_equal(result, expected_series)
 1272:         # This is the key test
 1273:         result = grp.count()
 1274:         tm.assert_frame_equal(result, expected_df)
 1275: 
 1276: 
 1277: def test_rolling_corr_with_single_integer_in_index():
 1278:     # GH 44078
 1279:     df = DataFrame({"a": [(1,), (1,), (1,)], "b": [4, 5, 6]})
 1280:     gb = df.groupby(["a"])
 1281:     result = gb.rolling(2).corr(other=df)
 1282:     index = MultiIndex.from_tuples([((1,), 0), ((1,), 1), ((1,), 2)], names=["a", None])
 1283:     expected = DataFrame(
 1284:         {"a": [np.nan, np.nan, np.nan], "b": [np.nan, 1.0, 1.0]}, index=index
 1285:     )
 1286:     tm.assert_frame_equal(result, expected)
 1287: 
 1288: 
 1289: def test_rolling_corr_with_tuples_in_index():
 1290:     # GH 44078
 1291:     df = DataFrame(
 1292:         {
 1293:             "a": [
 1294:                 (
 1295:                     1,
 1296:                     2,
 1297:                 ),
 1298:                 (
 1299:                     1,
 1300:                     2,
 1301:                 ),
 1302:                 (
 1303:                     1,
 1304:                     2,
 1305:                 ),
 1306:             ],
 1307:             "b": [4, 5, 6],
 1308:         }
 1309:     )
 1310:     gb = df.groupby(["a"])
 1311:     result = gb.rolling(2).corr(other=df)
 1312:     index = MultiIndex.from_tuples(
 1313:         [((1, 2), 0), ((1, 2), 1), ((1, 2), 2)], names=["a", None]
 1314:     )
 1315:     expected = DataFrame(
 1316:         {"a": [np.nan, np.nan, np.nan], "b": [np.nan, 1.0, 1.0]}, index=index
 1317:     )
 1318:     tm.assert_frame_equal(result, expected)
