    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import Series
    5: import pandas._testing as tm
    6: 
    7: 
    8: def no_nans(x):
    9:     return x.notna().all().all()
   10: 
   11: 
   12: def all_na(x):
   13:     return x.isnull().all().all()
   14: 
   15: 
   16: @pytest.fixture(params=[(1, 0), (5, 1)])
   17: def rolling_consistency_cases(request):
   18:     """window, min_periods"""
   19:     return request.param
   20: 
   21: 
   22: @pytest.mark.parametrize("f", [lambda v: Series(v).sum(), np.nansum, np.sum])
   23: def test_rolling_apply_consistency_sum(
   24:     request, all_data, rolling_consistency_cases, center, f
   25: ):
   26:     window, min_periods = rolling_consistency_cases
   27: 
   28:     if f is np.sum:
   29:         if not no_nans(all_data) and not (
   30:             all_na(all_data) and not all_data.empty and min_periods > 0
   31:         ):
   32:             request.applymarker(
   33:                 pytest.mark.xfail(reason="np.sum has different behavior with NaNs")
   34:             )
   35:     rolling_f_result = all_data.rolling(
   36:         window=window, min_periods=min_periods, center=center
   37:     ).sum()
   38:     rolling_apply_f_result = all_data.rolling(
   39:         window=window, min_periods=min_periods, center=center
   40:     ).apply(func=f, raw=True)
   41:     tm.assert_equal(rolling_f_result, rolling_apply_f_result)
   42: 
   43: 
   44: @pytest.mark.parametrize("ddof", [0, 1])
   45: def test_moments_consistency_var(all_data, rolling_consistency_cases, center, ddof):
   46:     window, min_periods = rolling_consistency_cases
   47: 
   48:     var_x = all_data.rolling(window=window, min_periods=min_periods, center=center).var(
   49:         ddof=ddof
   50:     )
   51:     assert not (var_x < 0).any().any()
   52: 
   53:     if ddof == 0:
   54:         # check that biased var(x) == mean(x^2) - mean(x)^2
   55:         mean_x = all_data.rolling(
   56:             window=window, min_periods=min_periods, center=center
   57:         ).mean()
   58:         mean_x2 = (
   59:             (all_data * all_data)
   60:             .rolling(window=window, min_periods=min_periods, center=center)
   61:             .mean()
   62:         )
   63:         tm.assert_equal(var_x, mean_x2 - (mean_x * mean_x))
   64: 
   65: 
   66: @pytest.mark.parametrize("ddof", [0, 1])
   67: def test_moments_consistency_var_constant(
   68:     consistent_data, rolling_consistency_cases, center, ddof
   69: ):
   70:     window, min_periods = rolling_consistency_cases
   71: 
   72:     count_x = consistent_data.rolling(
   73:         window=window, min_periods=min_periods, center=center
   74:     ).count()
   75:     var_x = consistent_data.rolling(
   76:         window=window, min_periods=min_periods, center=center
   77:     ).var(ddof=ddof)
   78: 
   79:     # check that variance of constant series is identically 0
   80:     assert not (var_x > 0).any().any()
   81:     expected = consistent_data * np.nan
   82:     expected[count_x >= max(min_periods, 1)] = 0.0
   83:     if ddof == 1:
   84:         expected[count_x < 2] = np.nan
   85:     tm.assert_equal(var_x, expected)
   86: 
   87: 
   88: @pytest.mark.parametrize("ddof", [0, 1])
   89: def test_rolling_consistency_var_std_cov(
   90:     all_data, rolling_consistency_cases, center, ddof
   91: ):
   92:     window, min_periods = rolling_consistency_cases
   93: 
   94:     var_x = all_data.rolling(window=window, min_periods=min_periods, center=center).var(
   95:         ddof=ddof
   96:     )
   97:     assert not (var_x < 0).any().any()
   98: 
   99:     std_x = all_data.rolling(window=window, min_periods=min_periods, center=center).std(
  100:         ddof=ddof
  101:     )
  102:     assert not (std_x < 0).any().any()
  103: 
  104:     # check that var(x) == std(x)^2
  105:     tm.assert_equal(var_x, std_x * std_x)
  106: 
  107:     cov_x_x = all_data.rolling(
  108:         window=window, min_periods=min_periods, center=center
  109:     ).cov(all_data, ddof=ddof)
  110:     assert not (cov_x_x < 0).any().any()
  111: 
  112:     # check that var(x) == cov(x, x)
  113:     tm.assert_equal(var_x, cov_x_x)
  114: 
  115: 
  116: @pytest.mark.parametrize("ddof", [0, 1])
  117: def test_rolling_consistency_series_cov_corr(
  118:     series_data, rolling_consistency_cases, center, ddof
  119: ):
  120:     window, min_periods = rolling_consistency_cases
  121: 
  122:     var_x_plus_y = (
  123:         (series_data + series_data)
  124:         .rolling(window=window, min_periods=min_periods, center=center)
  125:         .var(ddof=ddof)
  126:     )
  127:     var_x = series_data.rolling(
  128:         window=window, min_periods=min_periods, center=center
  129:     ).var(ddof=ddof)
  130:     var_y = series_data.rolling(
  131:         window=window, min_periods=min_periods, center=center
  132:     ).var(ddof=ddof)
  133:     cov_x_y = series_data.rolling(
  134:         window=window, min_periods=min_periods, center=center
  135:     ).cov(series_data, ddof=ddof)
  136:     # check that cov(x, y) == (var(x+y) - var(x) -
  137:     # var(y)) / 2
  138:     tm.assert_equal(cov_x_y, 0.5 * (var_x_plus_y - var_x - var_y))
  139: 
  140:     # check that corr(x, y) == cov(x, y) / (std(x) *
  141:     # std(y))
  142:     corr_x_y = series_data.rolling(
  143:         window=window, min_periods=min_periods, center=center
  144:     ).corr(series_data)
  145:     std_x = series_data.rolling(
  146:         window=window, min_periods=min_periods, center=center
  147:     ).std(ddof=ddof)
  148:     std_y = series_data.rolling(
  149:         window=window, min_periods=min_periods, center=center
  150:     ).std(ddof=ddof)
  151:     tm.assert_equal(corr_x_y, cov_x_y / (std_x * std_y))
  152: 
  153:     if ddof == 0:
  154:         # check that biased cov(x, y) == mean(x*y) -
  155:         # mean(x)*mean(y)
  156:         mean_x = series_data.rolling(
  157:             window=window, min_periods=min_periods, center=center
  158:         ).mean()
  159:         mean_y = series_data.rolling(
  160:             window=window, min_periods=min_periods, center=center
  161:         ).mean()
  162:         mean_x_times_y = (
  163:             (series_data * series_data)
  164:             .rolling(window=window, min_periods=min_periods, center=center)
  165:             .mean()
  166:         )
  167:         tm.assert_equal(cov_x_y, mean_x_times_y - (mean_x * mean_y))
  168: 
  169: 
  170: def test_rolling_consistency_mean(all_data, rolling_consistency_cases, center):
  171:     window, min_periods = rolling_consistency_cases
  172: 
  173:     result = all_data.rolling(
  174:         window=window, min_periods=min_periods, center=center
  175:     ).mean()
  176:     expected = (
  177:         all_data.rolling(window=window, min_periods=min_periods, center=center)
  178:         .sum()
  179:         .divide(
  180:             all_data.rolling(
  181:                 window=window, min_periods=min_periods, center=center
  182:             ).count()
  183:         )
  184:     )
  185:     tm.assert_equal(result, expected.astype("float64"))
  186: 
  187: 
  188: def test_rolling_consistency_constant(
  189:     consistent_data, rolling_consistency_cases, center
  190: ):
  191:     window, min_periods = rolling_consistency_cases
  192: 
  193:     count_x = consistent_data.rolling(
  194:         window=window, min_periods=min_periods, center=center
  195:     ).count()
  196:     mean_x = consistent_data.rolling(
  197:         window=window, min_periods=min_periods, center=center
  198:     ).mean()
  199:     # check that correlation of a series with itself is either 1 or NaN
  200:     corr_x_x = consistent_data.rolling(
  201:         window=window, min_periods=min_periods, center=center
  202:     ).corr(consistent_data)
  203: 
  204:     exp = (
  205:         consistent_data.max()
  206:         if isinstance(consistent_data, Series)
  207:         else consistent_data.max().max()
  208:     )
  209: 
  210:     # check mean of constant series
  211:     expected = consistent_data * np.nan
  212:     expected[count_x >= max(min_periods, 1)] = exp
  213:     tm.assert_equal(mean_x, expected)
  214: 
  215:     # check correlation of constant series with itself is NaN
  216:     expected[:] = np.nan
  217:     tm.assert_equal(corr_x_x, expected)
  218: 
  219: 
  220: def test_rolling_consistency_var_debiasing_factors(
  221:     all_data, rolling_consistency_cases, center
  222: ):
  223:     window, min_periods = rolling_consistency_cases
  224: 
  225:     # check variance debiasing factors
  226:     var_unbiased_x = all_data.rolling(
  227:         window=window, min_periods=min_periods, center=center
  228:     ).var()
  229:     var_biased_x = all_data.rolling(
  230:         window=window, min_periods=min_periods, center=center
  231:     ).var(ddof=0)
  232:     var_debiasing_factors_x = (
  233:         all_data.rolling(window=window, min_periods=min_periods, center=center)
  234:         .count()
  235:         .divide(
  236:             (
  237:                 all_data.rolling(
  238:                     window=window, min_periods=min_periods, center=center
  239:                 ).count()
  240:                 - 1.0
  241:             ).replace(0.0, np.nan)
  242:         )
  243:     )
  244:     tm.assert_equal(var_unbiased_x, var_biased_x * var_debiasing_factors_x)
