    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import NumbaUtilError
    5: import pandas.util._test_decorators as td
    6: 
    7: from pandas import (
    8:     DataFrame,
    9:     Series,
   10:     option_context,
   11:     to_datetime,
   12: )
   13: import pandas._testing as tm
   14: 
   15: pytestmark = pytest.mark.single_cpu
   16: 
   17: 
   18: @pytest.fixture(params=["single", "table"])
   19: def method(request):
   20:     """method keyword in rolling/expanding/ewm constructor"""
   21:     return request.param
   22: 
   23: 
   24: @pytest.fixture(
   25:     params=[
   26:         ["sum", {}],
   27:         ["mean", {}],
   28:         ["median", {}],
   29:         ["max", {}],
   30:         ["min", {}],
   31:         ["var", {}],
   32:         ["var", {"ddof": 0}],
   33:         ["std", {}],
   34:         ["std", {"ddof": 0}],
   35:     ]
   36: )
   37: def arithmetic_numba_supported_operators(request):
   38:     return request.param
   39: 
   40: 
   41: @td.skip_if_no("numba")
   42: @pytest.mark.filterwarnings("ignore")
   43: # Filter warnings when parallel=True and the function can't be parallelized by Numba
   44: class TestEngine:
   45:     @pytest.mark.parametrize("jit", [True, False])
   46:     def test_numba_vs_cython_apply(self, jit, nogil, parallel, nopython, center, step):
   47:         def f(x, *args):
   48:             arg_sum = 0
   49:             for arg in args:
   50:                 arg_sum += arg
   51:             return np.mean(x) + arg_sum
   52: 
   53:         if jit:
   54:             import numba
   55: 
   56:             f = numba.jit(f)
   57: 
   58:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
   59:         args = (2,)
   60: 
   61:         s = Series(range(10))
   62:         result = s.rolling(2, center=center, step=step).apply(
   63:             f, args=args, engine="numba", engine_kwargs=engine_kwargs, raw=True
   64:         )
   65:         expected = s.rolling(2, center=center, step=step).apply(
   66:             f, engine="cython", args=args, raw=True
   67:         )
   68:         tm.assert_series_equal(result, expected)
   69: 
   70:     @pytest.mark.parametrize(
   71:         "data",
   72:         [
   73:             DataFrame(np.eye(5)),
   74:             DataFrame(
   75:                 [
   76:                     [5, 7, 7, 7, np.nan, np.inf, 4, 3, 3, 3],
   77:                     [5, 7, 7, 7, np.nan, np.inf, 7, 3, 3, 3],
   78:                     [np.nan, np.nan, 5, 6, 7, 5, 5, 5, 5, 5],
   79:                 ]
   80:             ).T,
   81:             Series(range(5), name="foo"),
   82:             Series([20, 10, 10, np.inf, 1, 1, 2, 3]),
   83:             Series([20, 10, 10, np.nan, 10, 1, 2, 3]),
   84:         ],
   85:     )
   86:     def test_numba_vs_cython_rolling_methods(
   87:         self,
   88:         data,
   89:         nogil,
   90:         parallel,
   91:         nopython,
   92:         arithmetic_numba_supported_operators,
   93:         step,
   94:     ):
   95:         method, kwargs = arithmetic_numba_supported_operators
   96: 
   97:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
   98: 
   99:         roll = data.rolling(3, step=step)
  100:         result = getattr(roll, method)(
  101:             engine="numba", engine_kwargs=engine_kwargs, **kwargs
  102:         )
  103:         expected = getattr(roll, method)(engine="cython", **kwargs)
  104:         tm.assert_equal(result, expected)
  105: 
  106:     @pytest.mark.parametrize(
  107:         "data", [DataFrame(np.eye(5)), Series(range(5), name="foo")]
  108:     )
  109:     def test_numba_vs_cython_expanding_methods(
  110:         self, data, nogil, parallel, nopython, arithmetic_numba_supported_operators
  111:     ):
  112:         method, kwargs = arithmetic_numba_supported_operators
  113: 
  114:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  115: 
  116:         data = DataFrame(np.eye(5))
  117:         expand = data.expanding()
  118:         result = getattr(expand, method)(
  119:             engine="numba", engine_kwargs=engine_kwargs, **kwargs
  120:         )
  121:         expected = getattr(expand, method)(engine="cython", **kwargs)
  122:         tm.assert_equal(result, expected)
  123: 
  124:     @pytest.mark.parametrize("jit", [True, False])
  125:     def test_cache_apply(self, jit, nogil, parallel, nopython, step):
  126:         # Test that the functions are cached correctly if we switch functions
  127:         def func_1(x):
  128:             return np.mean(x) + 4
  129: 
  130:         def func_2(x):
  131:             return np.std(x) * 5
  132: 
  133:         if jit:
  134:             import numba
  135: 
  136:             func_1 = numba.jit(func_1)
  137:             func_2 = numba.jit(func_2)
  138: 
  139:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  140: 
  141:         roll = Series(range(10)).rolling(2, step=step)
  142:         result = roll.apply(
  143:             func_1, engine="numba", engine_kwargs=engine_kwargs, raw=True
  144:         )
  145:         expected = roll.apply(func_1, engine="cython", raw=True)
  146:         tm.assert_series_equal(result, expected)
  147: 
  148:         result = roll.apply(
  149:             func_2, engine="numba", engine_kwargs=engine_kwargs, raw=True
  150:         )
  151:         expected = roll.apply(func_2, engine="cython", raw=True)
  152:         tm.assert_series_equal(result, expected)
  153:         # This run should use the cached func_1
  154:         result = roll.apply(
  155:             func_1, engine="numba", engine_kwargs=engine_kwargs, raw=True
  156:         )
  157:         expected = roll.apply(func_1, engine="cython", raw=True)
  158:         tm.assert_series_equal(result, expected)
  159: 
  160:     @pytest.mark.parametrize(
  161:         "window,window_kwargs",
  162:         [
  163:             ["rolling", {"window": 3, "min_periods": 0}],
  164:             ["expanding", {}],
  165:         ],
  166:     )
  167:     def test_dont_cache_args(
  168:         self, window, window_kwargs, nogil, parallel, nopython, method
  169:     ):
  170:         # GH 42287
  171: 
  172:         def add(values, x):
  173:             return np.sum(values) + x
  174: 
  175:         engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  176:         df = DataFrame({"value": [0, 0, 0]})
  177:         result = getattr(df, window)(method=method, **window_kwargs).apply(
  178:             add, raw=True, engine="numba", engine_kwargs=engine_kwargs, args=(1,)
  179:         )
  180:         expected = DataFrame({"value": [1.0, 1.0, 1.0]})
  181:         tm.assert_frame_equal(result, expected)
  182: 
  183:         result = getattr(df, window)(method=method, **window_kwargs).apply(
  184:             add, raw=True, engine="numba", engine_kwargs=engine_kwargs, args=(2,)
  185:         )
  186:         expected = DataFrame({"value": [2.0, 2.0, 2.0]})
  187:         tm.assert_frame_equal(result, expected)
  188: 
  189:     def test_dont_cache_engine_kwargs(self):
  190:         # If the user passes a different set of engine_kwargs don't return the same
  191:         # jitted function
  192:         nogil = False
  193:         parallel = True
  194:         nopython = True
  195: 
  196:         def func(x):
  197:             return nogil + parallel + nopython
  198: 
  199:         engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  200:         df = DataFrame({"value": [0, 0, 0]})
  201:         result = df.rolling(1).apply(
  202:             func, raw=True, engine="numba", engine_kwargs=engine_kwargs
  203:         )
  204:         expected = DataFrame({"value": [2.0, 2.0, 2.0]})
  205:         tm.assert_frame_equal(result, expected)
  206: 
  207:         parallel = False
  208:         engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  209:         result = df.rolling(1).apply(
  210:             func, raw=True, engine="numba", engine_kwargs=engine_kwargs
  211:         )
  212:         expected = DataFrame({"value": [1.0, 1.0, 1.0]})
  213:         tm.assert_frame_equal(result, expected)
  214: 
  215: 
  216: @td.skip_if_no("numba")
  217: class TestEWM:
  218:     @pytest.mark.parametrize(
  219:         "grouper", [lambda x: x, lambda x: x.groupby("A")], ids=["None", "groupby"]
  220:     )
  221:     @pytest.mark.parametrize("method", ["mean", "sum"])
  222:     def test_invalid_engine(self, grouper, method):
  223:         df = DataFrame({"A": ["a", "b", "a", "b"], "B": range(4)})
  224:         with pytest.raises(ValueError, match="engine must be either"):
  225:             getattr(grouper(df).ewm(com=1.0), method)(engine="foo")
  226: 
  227:     @pytest.mark.parametrize(
  228:         "grouper", [lambda x: x, lambda x: x.groupby("A")], ids=["None", "groupby"]
  229:     )
  230:     @pytest.mark.parametrize("method", ["mean", "sum"])
  231:     def test_invalid_engine_kwargs(self, grouper, method):
  232:         df = DataFrame({"A": ["a", "b", "a", "b"], "B": range(4)})
  233:         with pytest.raises(ValueError, match="cython engine does not"):
  234:             getattr(grouper(df).ewm(com=1.0), method)(
  235:                 engine="cython", engine_kwargs={"nopython": True}
  236:             )
  237: 
  238:     @pytest.mark.parametrize("grouper", ["None", "groupby"])
  239:     @pytest.mark.parametrize("method", ["mean", "sum"])
  240:     def test_cython_vs_numba(
  241:         self, grouper, method, nogil, parallel, nopython, ignore_na, adjust
  242:     ):
  243:         df = DataFrame({"B": range(4)})
  244:         if grouper == "None":
  245:             grouper = lambda x: x
  246:         else:
  247:             df["A"] = ["a", "b", "a", "b"]
  248:             grouper = lambda x: x.groupby("A")
  249:         if method == "sum":
  250:             adjust = True
  251:         ewm = grouper(df).ewm(com=1.0, adjust=adjust, ignore_na=ignore_na)
  252: 
  253:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  254:         result = getattr(ewm, method)(engine="numba", engine_kwargs=engine_kwargs)
  255:         expected = getattr(ewm, method)(engine="cython")
  256: 
  257:         tm.assert_frame_equal(result, expected)
  258: 
  259:     @pytest.mark.parametrize("grouper", ["None", "groupby"])
  260:     def test_cython_vs_numba_times(self, grouper, nogil, parallel, nopython, ignore_na):
  261:         # GH 40951
  262: 
  263:         df = DataFrame({"B": [0, 0, 1, 1, 2, 2]})
  264:         if grouper == "None":
  265:             grouper = lambda x: x
  266:         else:
  267:             grouper = lambda x: x.groupby("A")
  268:             df["A"] = ["a", "b", "a", "b", "b", "a"]
  269: 
  270:         halflife = "23 days"
  271:         times = to_datetime(
  272:             [
  273:                 "2020-01-01",
  274:                 "2020-01-01",
  275:                 "2020-01-02",
  276:                 "2020-01-10",
  277:                 "2020-02-23",
  278:                 "2020-01-03",
  279:             ]
  280:         )
  281:         ewm = grouper(df).ewm(
  282:             halflife=halflife, adjust=True, ignore_na=ignore_na, times=times
  283:         )
  284: 
  285:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  286: 
  287:         result = ewm.mean(engine="numba", engine_kwargs=engine_kwargs)
  288:         expected = ewm.mean(engine="cython")
  289: 
  290:         tm.assert_frame_equal(result, expected)
  291: 
  292: 
  293: @td.skip_if_no("numba")
  294: def test_use_global_config():
  295:     def f(x):
  296:         return np.mean(x) + 2
  297: 
  298:     s = Series(range(10))
  299:     with option_context("compute.use_numba", True):
  300:         result = s.rolling(2).apply(f, engine=None, raw=True)
  301:     expected = s.rolling(2).apply(f, engine="numba", raw=True)
  302:     tm.assert_series_equal(expected, result)
  303: 
  304: 
  305: @td.skip_if_no("numba")
  306: def test_invalid_kwargs_nopython():
  307:     with pytest.raises(NumbaUtilError, match="numba does not support kwargs with"):
  308:         Series(range(1)).rolling(1).apply(
  309:             lambda x: x, kwargs={"a": 1}, engine="numba", raw=True
  310:         )
  311: 
  312: 
  313: @td.skip_if_no("numba")
  314: @pytest.mark.slow
  315: @pytest.mark.filterwarnings("ignore")
  316: # Filter warnings when parallel=True and the function can't be parallelized by Numba
  317: class TestTableMethod:
  318:     def test_table_series_valueerror(self):
  319:         def f(x):
  320:             return np.sum(x, axis=0) + 1
  321: 
  322:         with pytest.raises(
  323:             ValueError, match="method='table' not applicable for Series objects."
  324:         ):
  325:             Series(range(1)).rolling(1, method="table").apply(
  326:                 f, engine="numba", raw=True
  327:             )
  328: 
  329:     def test_table_method_rolling_methods(
  330:         self,
  331:         axis,
  332:         nogil,
  333:         parallel,
  334:         nopython,
  335:         arithmetic_numba_supported_operators,
  336:         step,
  337:     ):
  338:         method, kwargs = arithmetic_numba_supported_operators
  339: 
  340:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  341: 
  342:         df = DataFrame(np.eye(3))
  343:         roll_table = df.rolling(2, method="table", axis=axis, min_periods=0, step=step)
  344:         if method in ("var", "std"):
  345:             with pytest.raises(NotImplementedError, match=f"{method} not supported"):
  346:                 getattr(roll_table, method)(
  347:                     engine_kwargs=engine_kwargs, engine="numba", **kwargs
  348:                 )
  349:         else:
  350:             roll_single = df.rolling(
  351:                 2, method="single", axis=axis, min_periods=0, step=step
  352:             )
  353:             result = getattr(roll_table, method)(
  354:                 engine_kwargs=engine_kwargs, engine="numba", **kwargs
  355:             )
  356:             expected = getattr(roll_single, method)(
  357:                 engine_kwargs=engine_kwargs, engine="numba", **kwargs
  358:             )
  359:             tm.assert_frame_equal(result, expected)
  360: 
  361:     def test_table_method_rolling_apply(self, axis, nogil, parallel, nopython, step):
  362:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  363: 
  364:         def f(x):
  365:             return np.sum(x, axis=0) + 1
  366: 
  367:         df = DataFrame(np.eye(3))
  368:         result = df.rolling(
  369:             2, method="table", axis=axis, min_periods=0, step=step
  370:         ).apply(f, raw=True, engine_kwargs=engine_kwargs, engine="numba")
  371:         expected = df.rolling(
  372:             2, method="single", axis=axis, min_periods=0, step=step
  373:         ).apply(f, raw=True, engine_kwargs=engine_kwargs, engine="numba")
  374:         tm.assert_frame_equal(result, expected)
  375: 
  376:     def test_table_method_rolling_weighted_mean(self, step):
  377:         def weighted_mean(x):
  378:             arr = np.ones((1, x.shape[1]))
  379:             arr[:, :2] = (x[:, :2] * x[:, 2]).sum(axis=0) / x[:, 2].sum()
  380:             return arr
  381: 
  382:         df = DataFrame([[1, 2, 0.6], [2, 3, 0.4], [3, 4, 0.2], [4, 5, 0.7]])
  383:         result = df.rolling(2, method="table", min_periods=0, step=step).apply(
  384:             weighted_mean, raw=True, engine="numba"
  385:         )
  386:         expected = DataFrame(
  387:             [
  388:                 [1.0, 2.0, 1.0],
  389:                 [1.8, 2.0, 1.0],
  390:                 [3.333333, 2.333333, 1.0],
  391:                 [1.555556, 7, 1.0],
  392:             ]
  393:         )[::step]
  394:         tm.assert_frame_equal(result, expected)
  395: 
  396:     def test_table_method_expanding_apply(self, axis, nogil, parallel, nopython):
  397:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  398: 
  399:         def f(x):
  400:             return np.sum(x, axis=0) + 1
  401: 
  402:         df = DataFrame(np.eye(3))
  403:         result = df.expanding(method="table", axis=axis).apply(
  404:             f, raw=True, engine_kwargs=engine_kwargs, engine="numba"
  405:         )
  406:         expected = df.expanding(method="single", axis=axis).apply(
  407:             f, raw=True, engine_kwargs=engine_kwargs, engine="numba"
  408:         )
  409:         tm.assert_frame_equal(result, expected)
  410: 
  411:     def test_table_method_expanding_methods(
  412:         self, axis, nogil, parallel, nopython, arithmetic_numba_supported_operators
  413:     ):
  414:         method, kwargs = arithmetic_numba_supported_operators
  415: 
  416:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  417: 
  418:         df = DataFrame(np.eye(3))
  419:         expand_table = df.expanding(method="table", axis=axis)
  420:         if method in ("var", "std"):
  421:             with pytest.raises(NotImplementedError, match=f"{method} not supported"):
  422:                 getattr(expand_table, method)(
  423:                     engine_kwargs=engine_kwargs, engine="numba", **kwargs
  424:                 )
  425:         else:
  426:             expand_single = df.expanding(method="single", axis=axis)
  427:             result = getattr(expand_table, method)(
  428:                 engine_kwargs=engine_kwargs, engine="numba", **kwargs
  429:             )
  430:             expected = getattr(expand_single, method)(
  431:                 engine_kwargs=engine_kwargs, engine="numba", **kwargs
  432:             )
  433:             tm.assert_frame_equal(result, expected)
  434: 
  435:     @pytest.mark.parametrize("data", [np.eye(3), np.ones((2, 3)), np.ones((3, 2))])
  436:     @pytest.mark.parametrize("method", ["mean", "sum"])
  437:     def test_table_method_ewm(self, data, method, axis, nogil, parallel, nopython):
  438:         engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  439: 
  440:         df = DataFrame(data)
  441: 
  442:         result = getattr(df.ewm(com=1, method="table", axis=axis), method)(
  443:             engine_kwargs=engine_kwargs, engine="numba"
  444:         )
  445:         expected = getattr(df.ewm(com=1, method="single", axis=axis), method)(
  446:             engine_kwargs=engine_kwargs, engine="numba"
  447:         )
  448:         tm.assert_frame_equal(result, expected)
  449: 
  450: 
  451: @td.skip_if_no("numba")
  452: def test_npfunc_no_warnings():
  453:     df = DataFrame({"col1": [1, 2, 3, 4, 5]})
  454:     with tm.assert_produces_warning(False):
  455:         df.col1.rolling(2).apply(np.prod, raw=True, engine="numba")
