    1: from functools import partial
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas import (
    7:     DataFrame,
    8:     Series,
    9:     concat,
   10:     isna,
   11:     notna,
   12: )
   13: import pandas._testing as tm
   14: 
   15: from pandas.tseries import offsets
   16: 
   17: 
   18: def scoreatpercentile(a, per):
   19:     values = np.sort(a, axis=0)
   20: 
   21:     idx = int(per / 1.0 * (values.shape[0] - 1))
   22: 
   23:     if idx == values.shape[0] - 1:
   24:         retval = values[-1]
   25: 
   26:     else:
   27:         qlow = idx / (values.shape[0] - 1)
   28:         qhig = (idx + 1) / (values.shape[0] - 1)
   29:         vlow = values[idx]
   30:         vhig = values[idx + 1]
   31:         retval = vlow + (vhig - vlow) * (per - qlow) / (qhig - qlow)
   32: 
   33:     return retval
   34: 
   35: 
   36: @pytest.mark.parametrize("q", [0.0, 0.1, 0.5, 0.9, 1.0])
   37: def test_series(series, q, step):
   38:     compare_func = partial(scoreatpercentile, per=q)
   39:     result = series.rolling(50, step=step).quantile(q)
   40:     assert isinstance(result, Series)
   41:     end = range(0, len(series), step or 1)[-1] + 1
   42:     tm.assert_almost_equal(result.iloc[-1], compare_func(series[end - 50 : end]))
   43: 
   44: 
   45: @pytest.mark.parametrize("q", [0.0, 0.1, 0.5, 0.9, 1.0])
   46: def test_frame(raw, frame, q, step):
   47:     compare_func = partial(scoreatpercentile, per=q)
   48:     result = frame.rolling(50, step=step).quantile(q)
   49:     assert isinstance(result, DataFrame)
   50:     end = range(0, len(frame), step or 1)[-1] + 1
   51:     tm.assert_series_equal(
   52:         result.iloc[-1, :],
   53:         frame.iloc[end - 50 : end, :].apply(compare_func, axis=0, raw=raw),
   54:         check_names=False,
   55:     )
   56: 
   57: 
   58: @pytest.mark.parametrize("q", [0.0, 0.1, 0.5, 0.9, 1.0])
   59: def test_time_rule_series(series, q):
   60:     compare_func = partial(scoreatpercentile, per=q)
   61:     win = 25
   62:     ser = series[::2].resample("B").mean()
   63:     series_result = ser.rolling(window=win, min_periods=10).quantile(q)
   64:     last_date = series_result.index[-1]
   65:     prev_date = last_date - 24 * offsets.BDay()
   66: 
   67:     trunc_series = series[::2].truncate(prev_date, last_date)
   68:     tm.assert_almost_equal(series_result.iloc[-1], compare_func(trunc_series))
   69: 
   70: 
   71: @pytest.mark.parametrize("q", [0.0, 0.1, 0.5, 0.9, 1.0])
   72: def test_time_rule_frame(raw, frame, q):
   73:     compare_func = partial(scoreatpercentile, per=q)
   74:     win = 25
   75:     frm = frame[::2].resample("B").mean()
   76:     frame_result = frm.rolling(window=win, min_periods=10).quantile(q)
   77:     last_date = frame_result.index[-1]
   78:     prev_date = last_date - 24 * offsets.BDay()
   79: 
   80:     trunc_frame = frame[::2].truncate(prev_date, last_date)
   81:     tm.assert_series_equal(
   82:         frame_result.xs(last_date),
   83:         trunc_frame.apply(compare_func, raw=raw),
   84:         check_names=False,
   85:     )
   86: 
   87: 
   88: @pytest.mark.parametrize("q", [0.0, 0.1, 0.5, 0.9, 1.0])
   89: def test_nans(q):
   90:     compare_func = partial(scoreatpercentile, per=q)
   91:     obj = Series(np.random.default_rng(2).standard_normal(50))
   92:     obj[:10] = np.nan
   93:     obj[-10:] = np.nan
   94: 
   95:     result = obj.rolling(50, min_periods=30).quantile(q)
   96:     tm.assert_almost_equal(result.iloc[-1], compare_func(obj[10:-10]))
   97: 
   98:     # min_periods is working correctly
   99:     result = obj.rolling(20, min_periods=15).quantile(q)
  100:     assert isna(result.iloc[23])
  101:     assert not isna(result.iloc[24])
  102: 
  103:     assert not isna(result.iloc[-6])
  104:     assert isna(result.iloc[-5])
  105: 
  106:     obj2 = Series(np.random.default_rng(2).standard_normal(20))
  107:     result = obj2.rolling(10, min_periods=5).quantile(q)
  108:     assert isna(result.iloc[3])
  109:     assert notna(result.iloc[4])
  110: 
  111:     result0 = obj.rolling(20, min_periods=0).quantile(q)
  112:     result1 = obj.rolling(20, min_periods=1).quantile(q)
  113:     tm.assert_almost_equal(result0, result1)
  114: 
  115: 
  116: @pytest.mark.parametrize("minp", [0, 99, 100])
  117: @pytest.mark.parametrize("q", [0.0, 0.1, 0.5, 0.9, 1.0])
  118: def test_min_periods(series, minp, q, step):
  119:     result = series.rolling(len(series) + 1, min_periods=minp, step=step).quantile(q)
  120:     expected = series.rolling(len(series), min_periods=minp, step=step).quantile(q)
  121:     nan_mask = isna(result)
  122:     tm.assert_series_equal(nan_mask, isna(expected))
  123: 
  124:     nan_mask = ~nan_mask
  125:     tm.assert_almost_equal(result[nan_mask], expected[nan_mask])
  126: 
  127: 
  128: @pytest.mark.parametrize("q", [0.0, 0.1, 0.5, 0.9, 1.0])
  129: def test_center(q):
  130:     obj = Series(np.random.default_rng(2).standard_normal(50))
  131:     obj[:10] = np.nan
  132:     obj[-10:] = np.nan
  133: 
  134:     result = obj.rolling(20, center=True).quantile(q)
  135:     expected = (
  136:         concat([obj, Series([np.nan] * 9)])
  137:         .rolling(20)
  138:         .quantile(q)
  139:         .iloc[9:]
  140:         .reset_index(drop=True)
  141:     )
  142:     tm.assert_series_equal(result, expected)
  143: 
  144: 
  145: @pytest.mark.parametrize("q", [0.0, 0.1, 0.5, 0.9, 1.0])
  146: def test_center_reindex_series(series, q):
  147:     # shifter index
  148:     s = [f"x{x:d}" for x in range(12)]
  149: 
  150:     series_xp = (
  151:         series.reindex(list(series.index) + s)
  152:         .rolling(window=25)
  153:         .quantile(q)
  154:         .shift(-12)
  155:         .reindex(series.index)
  156:     )
  157: 
  158:     series_rs = series.rolling(window=25, center=True).quantile(q)
  159:     tm.assert_series_equal(series_xp, series_rs)
  160: 
  161: 
  162: @pytest.mark.parametrize("q", [0.0, 0.1, 0.5, 0.9, 1.0])
  163: def test_center_reindex_frame(frame, q):
  164:     # shifter index
  165:     s = [f"x{x:d}" for x in range(12)]
  166: 
  167:     frame_xp = (
  168:         frame.reindex(list(frame.index) + s)
  169:         .rolling(window=25)
  170:         .quantile(q)
  171:         .shift(-12)
  172:         .reindex(frame.index)
  173:     )
  174:     frame_rs = frame.rolling(window=25, center=True).quantile(q)
  175:     tm.assert_frame_equal(frame_xp, frame_rs)
  176: 
  177: 
  178: def test_keyword_quantile_deprecated():
  179:     # GH #52550
  180:     s = Series([1, 2, 3, 4])
  181:     with tm.assert_produces_warning(FutureWarning):
  182:         s.rolling(2).quantile(quantile=0.4)
