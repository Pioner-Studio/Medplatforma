    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas.util._test_decorators as td
    7: 
    8: from pandas import (
    9:     DataFrame,
   10:     DatetimeIndex,
   11:     Series,
   12:     concat,
   13:     isna,
   14:     notna,
   15: )
   16: import pandas._testing as tm
   17: 
   18: from pandas.tseries import offsets
   19: 
   20: 
   21: @pytest.mark.parametrize(
   22:     "compare_func, roll_func, kwargs",
   23:     [
   24:         [np.mean, "mean", {}],
   25:         [np.nansum, "sum", {}],
   26:         [
   27:             lambda x: np.isfinite(x).astype(float).sum(),
   28:             "count",
   29:             {},
   30:         ],
   31:         [np.median, "median", {}],
   32:         [np.min, "min", {}],
   33:         [np.max, "max", {}],
   34:         [lambda x: np.std(x, ddof=1), "std", {}],
   35:         [lambda x: np.std(x, ddof=0), "std", {"ddof": 0}],
   36:         [lambda x: np.var(x, ddof=1), "var", {}],
   37:         [lambda x: np.var(x, ddof=0), "var", {"ddof": 0}],
   38:     ],
   39: )
   40: def test_series(series, compare_func, roll_func, kwargs, step):
   41:     result = getattr(series.rolling(50, step=step), roll_func)(**kwargs)
   42:     assert isinstance(result, Series)
   43:     end = range(0, len(series), step or 1)[-1] + 1
   44:     tm.assert_almost_equal(result.iloc[-1], compare_func(series[end - 50 : end]))
   45: 
   46: 
   47: @pytest.mark.parametrize(
   48:     "compare_func, roll_func, kwargs",
   49:     [
   50:         [np.mean, "mean", {}],
   51:         [np.nansum, "sum", {}],
   52:         [
   53:             lambda x: np.isfinite(x).astype(float).sum(),
   54:             "count",
   55:             {},
   56:         ],
   57:         [np.median, "median", {}],
   58:         [np.min, "min", {}],
   59:         [np.max, "max", {}],
   60:         [lambda x: np.std(x, ddof=1), "std", {}],
   61:         [lambda x: np.std(x, ddof=0), "std", {"ddof": 0}],
   62:         [lambda x: np.var(x, ddof=1), "var", {}],
   63:         [lambda x: np.var(x, ddof=0), "var", {"ddof": 0}],
   64:     ],
   65: )
   66: def test_frame(raw, frame, compare_func, roll_func, kwargs, step):
   67:     result = getattr(frame.rolling(50, step=step), roll_func)(**kwargs)
   68:     assert isinstance(result, DataFrame)
   69:     end = range(0, len(frame), step or 1)[-1] + 1
   70:     tm.assert_series_equal(
   71:         result.iloc[-1, :],
   72:         frame.iloc[end - 50 : end, :].apply(compare_func, axis=0, raw=raw),
   73:         check_names=False,
   74:     )
   75: 
   76: 
   77: @pytest.mark.parametrize(
   78:     "compare_func, roll_func, kwargs, minp",
   79:     [
   80:         [np.mean, "mean", {}, 10],
   81:         [np.nansum, "sum", {}, 10],
   82:         [lambda x: np.isfinite(x).astype(float).sum(), "count", {}, 0],
   83:         [np.median, "median", {}, 10],
   84:         [np.min, "min", {}, 10],
   85:         [np.max, "max", {}, 10],
   86:         [lambda x: np.std(x, ddof=1), "std", {}, 10],
   87:         [lambda x: np.std(x, ddof=0), "std", {"ddof": 0}, 10],
   88:         [lambda x: np.var(x, ddof=1), "var", {}, 10],
   89:         [lambda x: np.var(x, ddof=0), "var", {"ddof": 0}, 10],
   90:     ],
   91: )
   92: def test_time_rule_series(series, compare_func, roll_func, kwargs, minp):
   93:     win = 25
   94:     ser = series[::2].resample("B").mean()
   95:     series_result = getattr(ser.rolling(window=win, min_periods=minp), roll_func)(
   96:         **kwargs
   97:     )
   98:     last_date = series_result.index[-1]
   99:     prev_date = last_date - 24 * offsets.BDay()
  100: 
  101:     trunc_series = series[::2].truncate(prev_date, last_date)
  102:     tm.assert_almost_equal(series_result.iloc[-1], compare_func(trunc_series))
  103: 
  104: 
  105: @pytest.mark.parametrize(
  106:     "compare_func, roll_func, kwargs, minp",
  107:     [
  108:         [np.mean, "mean", {}, 10],
  109:         [np.nansum, "sum", {}, 10],
  110:         [lambda x: np.isfinite(x).astype(float).sum(), "count", {}, 0],
  111:         [np.median, "median", {}, 10],
  112:         [np.min, "min", {}, 10],
  113:         [np.max, "max", {}, 10],
  114:         [lambda x: np.std(x, ddof=1), "std", {}, 10],
  115:         [lambda x: np.std(x, ddof=0), "std", {"ddof": 0}, 10],
  116:         [lambda x: np.var(x, ddof=1), "var", {}, 10],
  117:         [lambda x: np.var(x, ddof=0), "var", {"ddof": 0}, 10],
  118:     ],
  119: )
  120: def test_time_rule_frame(raw, frame, compare_func, roll_func, kwargs, minp):
  121:     win = 25
  122:     frm = frame[::2].resample("B").mean()
  123:     frame_result = getattr(frm.rolling(window=win, min_periods=minp), roll_func)(
  124:         **kwargs
  125:     )
  126:     last_date = frame_result.index[-1]
  127:     prev_date = last_date - 24 * offsets.BDay()
  128: 
  129:     trunc_frame = frame[::2].truncate(prev_date, last_date)
  130:     tm.assert_series_equal(
  131:         frame_result.xs(last_date),
  132:         trunc_frame.apply(compare_func, raw=raw),
  133:         check_names=False,
  134:     )
  135: 
  136: 
  137: @pytest.mark.parametrize(
  138:     "compare_func, roll_func, kwargs",
  139:     [
  140:         [np.mean, "mean", {}],
  141:         [np.nansum, "sum", {}],
  142:         [np.median, "median", {}],
  143:         [np.min, "min", {}],
  144:         [np.max, "max", {}],
  145:         [lambda x: np.std(x, ddof=1), "std", {}],
  146:         [lambda x: np.std(x, ddof=0), "std", {"ddof": 0}],
  147:         [lambda x: np.var(x, ddof=1), "var", {}],
  148:         [lambda x: np.var(x, ddof=0), "var", {"ddof": 0}],
  149:     ],
  150: )
  151: def test_nans(compare_func, roll_func, kwargs):
  152:     obj = Series(np.random.default_rng(2).standard_normal(50))
  153:     obj[:10] = np.nan
  154:     obj[-10:] = np.nan
  155: 
  156:     result = getattr(obj.rolling(50, min_periods=30), roll_func)(**kwargs)
  157:     tm.assert_almost_equal(result.iloc[-1], compare_func(obj[10:-10]))
  158: 
  159:     # min_periods is working correctly
  160:     result = getattr(obj.rolling(20, min_periods=15), roll_func)(**kwargs)
  161:     assert isna(result.iloc[23])
  162:     assert not isna(result.iloc[24])
  163: 
  164:     assert not isna(result.iloc[-6])
  165:     assert isna(result.iloc[-5])
  166: 
  167:     obj2 = Series(np.random.default_rng(2).standard_normal(20))
  168:     result = getattr(obj2.rolling(10, min_periods=5), roll_func)(**kwargs)
  169:     assert isna(result.iloc[3])
  170:     assert notna(result.iloc[4])
  171: 
  172:     if roll_func != "sum":
  173:         result0 = getattr(obj.rolling(20, min_periods=0), roll_func)(**kwargs)
  174:         result1 = getattr(obj.rolling(20, min_periods=1), roll_func)(**kwargs)
  175:         tm.assert_almost_equal(result0, result1)
  176: 
  177: 
  178: def test_nans_count():
  179:     obj = Series(np.random.default_rng(2).standard_normal(50))
  180:     obj[:10] = np.nan
  181:     obj[-10:] = np.nan
  182:     result = obj.rolling(50, min_periods=30).count()
  183:     tm.assert_almost_equal(
  184:         result.iloc[-1], np.isfinite(obj[10:-10]).astype(float).sum()
  185:     )
  186: 
  187: 
  188: @pytest.mark.parametrize(
  189:     "roll_func, kwargs",
  190:     [
  191:         ["mean", {}],
  192:         ["sum", {}],
  193:         ["median", {}],
  194:         ["min", {}],
  195:         ["max", {}],
  196:         ["std", {}],
  197:         ["std", {"ddof": 0}],
  198:         ["var", {}],
  199:         ["var", {"ddof": 0}],
  200:     ],
  201: )
  202: @pytest.mark.parametrize("minp", [0, 99, 100])
  203: def test_min_periods(series, minp, roll_func, kwargs, step):
  204:     result = getattr(
  205:         series.rolling(len(series) + 1, min_periods=minp, step=step), roll_func
  206:     )(**kwargs)
  207:     expected = getattr(
  208:         series.rolling(len(series), min_periods=minp, step=step), roll_func
  209:     )(**kwargs)
  210:     nan_mask = isna(result)
  211:     tm.assert_series_equal(nan_mask, isna(expected))
  212: 
  213:     nan_mask = ~nan_mask
  214:     tm.assert_almost_equal(result[nan_mask], expected[nan_mask])
  215: 
  216: 
  217: def test_min_periods_count(series, step):
  218:     result = series.rolling(len(series) + 1, min_periods=0, step=step).count()
  219:     expected = series.rolling(len(series), min_periods=0, step=step).count()
  220:     nan_mask = isna(result)
  221:     tm.assert_series_equal(nan_mask, isna(expected))
  222: 
  223:     nan_mask = ~nan_mask
  224:     tm.assert_almost_equal(result[nan_mask], expected[nan_mask])
  225: 
  226: 
  227: @pytest.mark.parametrize(
  228:     "roll_func, kwargs, minp",
  229:     [
  230:         ["mean", {}, 15],
  231:         ["sum", {}, 15],
  232:         ["count", {}, 0],
  233:         ["median", {}, 15],
  234:         ["min", {}, 15],
  235:         ["max", {}, 15],
  236:         ["std", {}, 15],
  237:         ["std", {"ddof": 0}, 15],
  238:         ["var", {}, 15],
  239:         ["var", {"ddof": 0}, 15],
  240:     ],
  241: )
  242: def test_center(roll_func, kwargs, minp):
  243:     obj = Series(np.random.default_rng(2).standard_normal(50))
  244:     obj[:10] = np.nan
  245:     obj[-10:] = np.nan
  246: 
  247:     result = getattr(obj.rolling(20, min_periods=minp, center=True), roll_func)(
  248:         **kwargs
  249:     )
  250:     expected = (
  251:         getattr(
  252:             concat([obj, Series([np.nan] * 9)]).rolling(20, min_periods=minp), roll_func
  253:         )(**kwargs)
  254:         .iloc[9:]
  255:         .reset_index(drop=True)
  256:     )
  257:     tm.assert_series_equal(result, expected)
  258: 
  259: 
  260: @pytest.mark.parametrize(
  261:     "roll_func, kwargs, minp, fill_value",
  262:     [
  263:         ["mean", {}, 10, None],
  264:         ["sum", {}, 10, None],
  265:         ["count", {}, 0, 0],
  266:         ["median", {}, 10, None],
  267:         ["min", {}, 10, None],
  268:         ["max", {}, 10, None],
  269:         ["std", {}, 10, None],
  270:         ["std", {"ddof": 0}, 10, None],
  271:         ["var", {}, 10, None],
  272:         ["var", {"ddof": 0}, 10, None],
  273:     ],
  274: )
  275: def test_center_reindex_series(series, roll_func, kwargs, minp, fill_value):
  276:     # shifter index
  277:     s = [f"x{x:d}" for x in range(12)]
  278: 
  279:     series_xp = (
  280:         getattr(
  281:             series.reindex(list(series.index) + s).rolling(window=25, min_periods=minp),
  282:             roll_func,
  283:         )(**kwargs)
  284:         .shift(-12)
  285:         .reindex(series.index)
  286:     )
  287:     series_rs = getattr(
  288:         series.rolling(window=25, min_periods=minp, center=True), roll_func
  289:     )(**kwargs)
  290:     if fill_value is not None:
  291:         series_xp = series_xp.fillna(fill_value)
  292:     tm.assert_series_equal(series_xp, series_rs)
  293: 
  294: 
  295: @pytest.mark.parametrize(
  296:     "roll_func, kwargs, minp, fill_value",
  297:     [
  298:         ["mean", {}, 10, None],
  299:         ["sum", {}, 10, None],
  300:         ["count", {}, 0, 0],
  301:         ["median", {}, 10, None],
  302:         ["min", {}, 10, None],
  303:         ["max", {}, 10, None],
  304:         ["std", {}, 10, None],
  305:         ["std", {"ddof": 0}, 10, None],
  306:         ["var", {}, 10, None],
  307:         ["var", {"ddof": 0}, 10, None],
  308:     ],
  309: )
  310: def test_center_reindex_frame(frame, roll_func, kwargs, minp, fill_value):
  311:     # shifter index
  312:     s = [f"x{x:d}" for x in range(12)]
  313: 
  314:     frame_xp = (
  315:         getattr(
  316:             frame.reindex(list(frame.index) + s).rolling(window=25, min_periods=minp),
  317:             roll_func,
  318:         )(**kwargs)
  319:         .shift(-12)
  320:         .reindex(frame.index)
  321:     )
  322:     frame_rs = getattr(
  323:         frame.rolling(window=25, min_periods=minp, center=True), roll_func
  324:     )(**kwargs)
  325:     if fill_value is not None:
  326:         frame_xp = frame_xp.fillna(fill_value)
  327:     tm.assert_frame_equal(frame_xp, frame_rs)
  328: 
  329: 
  330: @pytest.mark.parametrize(
  331:     "f",
  332:     [
  333:         lambda x: x.rolling(window=10, min_periods=5).cov(x, pairwise=False),
  334:         lambda x: x.rolling(window=10, min_periods=5).corr(x, pairwise=False),
  335:         lambda x: x.rolling(window=10, min_periods=5).max(),
  336:         lambda x: x.rolling(window=10, min_periods=5).min(),
  337:         lambda x: x.rolling(window=10, min_periods=5).sum(),
  338:         lambda x: x.rolling(window=10, min_periods=5).mean(),
  339:         lambda x: x.rolling(window=10, min_periods=5).std(),
  340:         lambda x: x.rolling(window=10, min_periods=5).var(),
  341:         lambda x: x.rolling(window=10, min_periods=5).skew(),
  342:         lambda x: x.rolling(window=10, min_periods=5).kurt(),
  343:         lambda x: x.rolling(window=10, min_periods=5).quantile(q=0.5),
  344:         lambda x: x.rolling(window=10, min_periods=5).median(),
  345:         lambda x: x.rolling(window=10, min_periods=5).apply(sum, raw=False),
  346:         lambda x: x.rolling(window=10, min_periods=5).apply(sum, raw=True),
  347:         pytest.param(
  348:             lambda x: x.rolling(win_type="boxcar", window=10, min_periods=5).mean(),
  349:             marks=td.skip_if_no("scipy"),
  350:         ),
  351:     ],
  352: )
  353: def test_rolling_functions_window_non_shrinkage(f):
  354:     # GH 7764
  355:     s = Series(range(4))
  356:     s_expected = Series(np.nan, index=s.index)
  357:     df = DataFrame([[1, 5], [3, 2], [3, 9], [-1, 0]], columns=["A", "B"])
  358:     df_expected = DataFrame(np.nan, index=df.index, columns=df.columns)
  359: 
  360:     s_result = f(s)
  361:     tm.assert_series_equal(s_result, s_expected)
  362: 
  363:     df_result = f(df)
  364:     tm.assert_frame_equal(df_result, df_expected)
  365: 
  366: 
  367: def test_rolling_max_gh6297(step):
  368:     """Replicate result expected in GH #6297"""
  369:     indices = [datetime(1975, 1, i) for i in range(1, 6)]
  370:     # So that we can have 2 datapoints on one of the days
  371:     indices.append(datetime(1975, 1, 3, 6, 0))
  372:     series = Series(range(1, 7), index=indices)
  373:     # Use floats instead of ints as values
  374:     series = series.map(lambda x: float(x))
  375:     # Sort chronologically
  376:     series = series.sort_index()
  377: 
  378:     expected = Series(
  379:         [1.0, 2.0, 6.0, 4.0, 5.0],
  380:         index=DatetimeIndex([datetime(1975, 1, i, 0) for i in range(1, 6)], freq="D"),
  381:     )[::step]
  382:     x = series.resample("D").max().rolling(window=1, step=step).max()
  383:     tm.assert_series_equal(expected, x)
  384: 
  385: 
  386: def test_rolling_max_resample(step):
  387:     indices = [datetime(1975, 1, i) for i in range(1, 6)]
  388:     # So that we can have 3 datapoints on last day (4, 10, and 20)
  389:     indices.append(datetime(1975, 1, 5, 1))
  390:     indices.append(datetime(1975, 1, 5, 2))
  391:     series = Series(list(range(5)) + [10, 20], index=indices)
  392:     # Use floats instead of ints as values
  393:     series = series.map(lambda x: float(x))
  394:     # Sort chronologically
  395:     series = series.sort_index()
  396: 
  397:     # Default how should be max
  398:     expected = Series(
  399:         [0.0, 1.0, 2.0, 3.0, 20.0],
  400:         index=DatetimeIndex([datetime(1975, 1, i, 0) for i in range(1, 6)], freq="D"),
  401:     )[::step]
  402:     x = series.resample("D").max().rolling(window=1, step=step).max()
  403:     tm.assert_series_equal(expected, x)
  404: 
  405:     # Now specify median (10.0)
  406:     expected = Series(
  407:         [0.0, 1.0, 2.0, 3.0, 10.0],
  408:         index=DatetimeIndex([datetime(1975, 1, i, 0) for i in range(1, 6)], freq="D"),
  409:     )[::step]
  410:     x = series.resample("D").median().rolling(window=1, step=step).max()
  411:     tm.assert_series_equal(expected, x)
  412: 
  413:     # Now specify mean (4+10+20)/3
  414:     v = (4.0 + 10.0 + 20.0) / 3.0
  415:     expected = Series(
  416:         [0.0, 1.0, 2.0, 3.0, v],
  417:         index=DatetimeIndex([datetime(1975, 1, i, 0) for i in range(1, 6)], freq="D"),
  418:     )[::step]
  419:     x = series.resample("D").mean().rolling(window=1, step=step).max()
  420:     tm.assert_series_equal(expected, x)
  421: 
  422: 
  423: def test_rolling_min_resample(step):
  424:     indices = [datetime(1975, 1, i) for i in range(1, 6)]
  425:     # So that we can have 3 datapoints on last day (4, 10, and 20)
  426:     indices.append(datetime(1975, 1, 5, 1))
  427:     indices.append(datetime(1975, 1, 5, 2))
  428:     series = Series(list(range(5)) + [10, 20], index=indices)
  429:     # Use floats instead of ints as values
  430:     series = series.map(lambda x: float(x))
  431:     # Sort chronologically
  432:     series = series.sort_index()
  433: 
  434:     # Default how should be min
  435:     expected = Series(
  436:         [0.0, 1.0, 2.0, 3.0, 4.0],
  437:         index=DatetimeIndex([datetime(1975, 1, i, 0) for i in range(1, 6)], freq="D"),
  438:     )[::step]
  439:     r = series.resample("D").min().rolling(window=1, step=step)
  440:     tm.assert_series_equal(expected, r.min())
  441: 
  442: 
  443: def test_rolling_median_resample():
  444:     indices = [datetime(1975, 1, i) for i in range(1, 6)]
  445:     # So that we can have 3 datapoints on last day (4, 10, and 20)
  446:     indices.append(datetime(1975, 1, 5, 1))
  447:     indices.append(datetime(1975, 1, 5, 2))
  448:     series = Series(list(range(5)) + [10, 20], index=indices)
  449:     # Use floats instead of ints as values
  450:     series = series.map(lambda x: float(x))
  451:     # Sort chronologically
  452:     series = series.sort_index()
  453: 
  454:     # Default how should be median
  455:     expected = Series(
  456:         [0.0, 1.0, 2.0, 3.0, 10],
  457:         index=DatetimeIndex([datetime(1975, 1, i, 0) for i in range(1, 6)], freq="D"),
  458:     )
  459:     x = series.resample("D").median().rolling(window=1).median()
  460:     tm.assert_series_equal(expected, x)
  461: 
  462: 
  463: def test_rolling_median_memory_error():
  464:     # GH11722
  465:     n = 20000
  466:     Series(np.random.default_rng(2).standard_normal(n)).rolling(
  467:         window=2, center=False
  468:     ).median()
  469:     Series(np.random.default_rng(2).standard_normal(n)).rolling(
  470:         window=2, center=False
  471:     ).median()
  472: 
  473: 
  474: @pytest.mark.parametrize(
  475:     "data_type",
  476:     [np.dtype(f"f{width}") for width in [4, 8]]
  477:     + [np.dtype(f"{sign}{width}") for width in [1, 2, 4, 8] for sign in "ui"],
  478: )
  479: def test_rolling_min_max_numeric_types(data_type):
  480:     # GH12373
  481: 
  482:     # Just testing that these don't throw exceptions and that
  483:     # the return type is float64. Other tests will cover quantitative
  484:     # correctness
  485:     result = DataFrame(np.arange(20, dtype=data_type)).rolling(window=5).max()
  486:     assert result.dtypes[0] == np.dtype("f8")
  487:     result = DataFrame(np.arange(20, dtype=data_type)).rolling(window=5).min()
  488:     assert result.dtypes[0] == np.dtype("f8")
  489: 
  490: 
  491: @pytest.mark.parametrize(
  492:     "f",
  493:     [
  494:         lambda x: x.rolling(window=10, min_periods=0).count(),
  495:         lambda x: x.rolling(window=10, min_periods=5).cov(x, pairwise=False),
  496:         lambda x: x.rolling(window=10, min_periods=5).corr(x, pairwise=False),
  497:         lambda x: x.rolling(window=10, min_periods=5).max(),
  498:         lambda x: x.rolling(window=10, min_periods=5).min(),
  499:         lambda x: x.rolling(window=10, min_periods=5).sum(),
  500:         lambda x: x.rolling(window=10, min_periods=5).mean(),
  501:         lambda x: x.rolling(window=10, min_periods=5).std(),
  502:         lambda x: x.rolling(window=10, min_periods=5).var(),
  503:         lambda x: x.rolling(window=10, min_periods=5).skew(),
  504:         lambda x: x.rolling(window=10, min_periods=5).kurt(),
  505:         lambda x: x.rolling(window=10, min_periods=5).quantile(0.5),
  506:         lambda x: x.rolling(window=10, min_periods=5).median(),
  507:         lambda x: x.rolling(window=10, min_periods=5).apply(sum, raw=False),
  508:         lambda x: x.rolling(window=10, min_periods=5).apply(sum, raw=True),
  509:         pytest.param(
  510:             lambda x: x.rolling(win_type="boxcar", window=10, min_periods=5).mean(),
  511:             marks=td.skip_if_no("scipy"),
  512:         ),
  513:     ],
  514: )
  515: def test_moment_functions_zero_length(f):
  516:     # GH 8056
  517:     s = Series(dtype=np.float64)
  518:     s_expected = s
  519:     df1 = DataFrame()
  520:     df1_expected = df1
  521:     df2 = DataFrame(columns=["a"])
  522:     df2["a"] = df2["a"].astype("float64")
  523:     df2_expected = df2
  524: 
  525:     s_result = f(s)
  526:     tm.assert_series_equal(s_result, s_expected)
  527: 
  528:     df1_result = f(df1)
  529:     tm.assert_frame_equal(df1_result, df1_expected)
  530: 
  531:     df2_result = f(df2)
  532:     tm.assert_frame_equal(df2_result, df2_expected)
