    1: from functools import partial
    2: import sys
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas._libs.window.aggregations as window_aggregations
    8: 
    9: from pandas import Series
   10: import pandas._testing as tm
   11: 
   12: 
   13: def _get_rolling_aggregations():
   14:     # list pairs of name and function
   15:     # each function has this signature:
   16:     # (const float64_t[:] values, ndarray[int64_t] start,
   17:     #  ndarray[int64_t] end, int64_t minp) -> np.ndarray
   18:     named_roll_aggs = (
   19:         [
   20:             ("roll_sum", window_aggregations.roll_sum),
   21:             ("roll_mean", window_aggregations.roll_mean),
   22:         ]
   23:         + [
   24:             (f"roll_var({ddof})", partial(window_aggregations.roll_var, ddof=ddof))
   25:             for ddof in [0, 1]
   26:         ]
   27:         + [
   28:             ("roll_skew", window_aggregations.roll_skew),
   29:             ("roll_kurt", window_aggregations.roll_kurt),
   30:             ("roll_median_c", window_aggregations.roll_median_c),
   31:             ("roll_max", window_aggregations.roll_max),
   32:             ("roll_min", window_aggregations.roll_min),
   33:         ]
   34:         + [
   35:             (
   36:                 f"roll_quantile({quantile},{interpolation})",
   37:                 partial(
   38:                     window_aggregations.roll_quantile,
   39:                     quantile=quantile,
   40:                     interpolation=interpolation,
   41:                 ),
   42:             )
   43:             for quantile in [0.0001, 0.5, 0.9999]
   44:             for interpolation in window_aggregations.interpolation_types
   45:         ]
   46:         + [
   47:             (
   48:                 f"roll_rank({percentile},{method},{ascending})",
   49:                 partial(
   50:                     window_aggregations.roll_rank,
   51:                     percentile=percentile,
   52:                     method=method,
   53:                     ascending=ascending,
   54:                 ),
   55:             )
   56:             for percentile in [True, False]
   57:             for method in window_aggregations.rolling_rank_tiebreakers.keys()
   58:             for ascending in [True, False]
   59:         ]
   60:     )
   61:     # unzip to a list of 2 tuples, names and functions
   62:     unzipped = list(zip(*named_roll_aggs))
   63:     return {"ids": unzipped[0], "params": unzipped[1]}
   64: 
   65: 
   66: _rolling_aggregations = _get_rolling_aggregations()
   67: 
   68: 
   69: @pytest.fixture(
   70:     params=_rolling_aggregations["params"], ids=_rolling_aggregations["ids"]
   71: )
   72: def rolling_aggregation(request):
   73:     """Make a rolling aggregation function as fixture."""
   74:     return request.param
   75: 
   76: 
   77: def test_rolling_aggregation_boundary_consistency(rolling_aggregation):
   78:     # GH-45647
   79:     minp, step, width, size, selection = 0, 1, 3, 11, [2, 7]
   80:     values = np.arange(1, 1 + size, dtype=np.float64)
   81:     end = np.arange(width, size, step, dtype=np.int64)
   82:     start = end - width
   83:     selarr = np.array(selection, dtype=np.int32)
   84:     result = Series(rolling_aggregation(values, start[selarr], end[selarr], minp))
   85:     expected = Series(rolling_aggregation(values, start, end, minp)[selarr])
   86:     tm.assert_equal(expected, result)
   87: 
   88: 
   89: def test_rolling_aggregation_with_unused_elements(rolling_aggregation):
   90:     # GH-45647
   91:     minp, width = 0, 5  # width at least 4 for kurt
   92:     size = 2 * width + 5
   93:     values = np.arange(1, size + 1, dtype=np.float64)
   94:     values[width : width + 2] = sys.float_info.min
   95:     values[width + 2] = np.nan
   96:     values[width + 3 : width + 5] = sys.float_info.max
   97:     start = np.array([0, size - width], dtype=np.int64)
   98:     end = np.array([width, size], dtype=np.int64)
   99:     loc = np.array(
  100:         [j for i in range(len(start)) for j in range(start[i], end[i])],
  101:         dtype=np.int32,
  102:     )
  103:     result = Series(rolling_aggregation(values, start, end, minp))
  104:     compact_values = np.array(values[loc], dtype=np.float64)
  105:     compact_start = np.arange(0, len(start) * width, width, dtype=np.int64)
  106:     compact_end = compact_start + width
  107:     expected = Series(
  108:         rolling_aggregation(compact_values, compact_start, compact_end, minp)
  109:     )
  110:     assert np.isfinite(expected.values).all(), "Not all expected values are finite"
  111:     tm.assert_equal(expected, result)
