    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.compat import IS64
    5: 
    6: from pandas import (
    7:     DataFrame,
    8:     Index,
    9:     MultiIndex,
   10:     Series,
   11:     date_range,
   12: )
   13: import pandas._testing as tm
   14: from pandas.core.algorithms import safe_sort
   15: 
   16: 
   17: @pytest.fixture(
   18:     params=[
   19:         DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[1, 0]),
   20:         DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[1, 1]),
   21:         DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=["C", "C"]),
   22:         DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[1.0, 0]),
   23:         DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[0.0, 1]),
   24:         DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=["C", 1]),
   25:         DataFrame([[2.0, 4.0], [1.0, 2.0], [5.0, 2.0], [8.0, 1.0]], columns=[1, 0.0]),
   26:         DataFrame([[2, 4.0], [1, 2.0], [5, 2.0], [8, 1.0]], columns=[0, 1.0]),
   27:         DataFrame([[2, 4], [1, 2], [5, 2], [8, 1.0]], columns=[1.0, "X"]),
   28:     ]
   29: )
   30: def pairwise_frames(request):
   31:     """Pairwise frames test_pairwise"""
   32:     return request.param
   33: 
   34: 
   35: @pytest.fixture
   36: def pairwise_target_frame():
   37:     """Pairwise target frame for test_pairwise"""
   38:     return DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[0, 1])
   39: 
   40: 
   41: @pytest.fixture
   42: def pairwise_other_frame():
   43:     """Pairwise other frame for test_pairwise"""
   44:     return DataFrame(
   45:         [[None, 1, 1], [None, 1, 2], [None, 3, 2], [None, 8, 1]],
   46:         columns=["Y", "Z", "X"],
   47:     )
   48: 
   49: 
   50: def test_rolling_cov(series):
   51:     A = series
   52:     B = A + np.random.default_rng(2).standard_normal(len(A))
   53: 
   54:     result = A.rolling(window=50, min_periods=25).cov(B)
   55:     tm.assert_almost_equal(result.iloc[-1], np.cov(A[-50:], B[-50:])[0, 1])
   56: 
   57: 
   58: def test_rolling_corr(series):
   59:     A = series
   60:     B = A + np.random.default_rng(2).standard_normal(len(A))
   61: 
   62:     result = A.rolling(window=50, min_periods=25).corr(B)
   63:     tm.assert_almost_equal(result.iloc[-1], np.corrcoef(A[-50:], B[-50:])[0, 1])
   64: 
   65: 
   66: def test_rolling_corr_bias_correction():
   67:     # test for correct bias correction
   68:     a = Series(
   69:         np.arange(20, dtype=np.float64), index=date_range("2020-01-01", periods=20)
   70:     )
   71:     b = a.copy()
   72:     a[:5] = np.nan
   73:     b[:10] = np.nan
   74: 
   75:     result = a.rolling(window=len(a), min_periods=1).corr(b)
   76:     tm.assert_almost_equal(result.iloc[-1], a.corr(b))
   77: 
   78: 
   79: @pytest.mark.parametrize("func", ["cov", "corr"])
   80: def test_rolling_pairwise_cov_corr(func, frame):
   81:     result = getattr(frame.rolling(window=10, min_periods=5), func)()
   82:     result = result.loc[(slice(None), 1), 5]
   83:     result.index = result.index.droplevel(1)
   84:     expected = getattr(frame[1].rolling(window=10, min_periods=5), func)(frame[5])
   85:     tm.assert_series_equal(result, expected, check_names=False)
   86: 
   87: 
   88: @pytest.mark.parametrize("method", ["corr", "cov"])
   89: def test_flex_binary_frame(method, frame):
   90:     series = frame[1]
   91: 
   92:     res = getattr(series.rolling(window=10), method)(frame)
   93:     res2 = getattr(frame.rolling(window=10), method)(series)
   94:     exp = frame.apply(lambda x: getattr(series.rolling(window=10), method)(x))
   95: 
   96:     tm.assert_frame_equal(res, exp)
   97:     tm.assert_frame_equal(res2, exp)
   98: 
   99:     frame2 = frame.copy()
  100:     frame2 = DataFrame(
  101:         np.random.default_rng(2).standard_normal(frame2.shape),
  102:         index=frame2.index,
  103:         columns=frame2.columns,
  104:     )
  105: 
  106:     res3 = getattr(frame.rolling(window=10), method)(frame2)
  107:     exp = DataFrame(
  108:         {k: getattr(frame[k].rolling(window=10), method)(frame2[k]) for k in frame}
  109:     )
  110:     tm.assert_frame_equal(res3, exp)
  111: 
  112: 
  113: @pytest.mark.parametrize("window", range(7))
  114: def test_rolling_corr_with_zero_variance(window):
  115:     # GH 18430
  116:     s = Series(np.zeros(20))
  117:     other = Series(np.arange(20))
  118: 
  119:     assert s.rolling(window=window).corr(other=other).isna().all()
  120: 
  121: 
  122: def test_corr_sanity():
  123:     # GH 3155
  124:     df = DataFrame(
  125:         np.array(
  126:             [
  127:                 [0.87024726, 0.18505595],
  128:                 [0.64355431, 0.3091617],
  129:                 [0.92372966, 0.50552513],
  130:                 [0.00203756, 0.04520709],
  131:                 [0.84780328, 0.33394331],
  132:                 [0.78369152, 0.63919667],
  133:             ]
  134:         )
  135:     )
  136: 
  137:     res = df[0].rolling(5, center=True).corr(df[1])
  138:     assert all(np.abs(np.nan_to_num(x)) <= 1 for x in res)
  139: 
  140:     df = DataFrame(np.random.default_rng(2).random((30, 2)))
  141:     res = df[0].rolling(5, center=True).corr(df[1])
  142:     assert all(np.abs(np.nan_to_num(x)) <= 1 for x in res)
  143: 
  144: 
  145: def test_rolling_cov_diff_length():
  146:     # GH 7512
  147:     s1 = Series([1, 2, 3], index=[0, 1, 2])
  148:     s2 = Series([1, 3], index=[0, 2])
  149:     result = s1.rolling(window=3, min_periods=2).cov(s2)
  150:     expected = Series([None, None, 2.0])
  151:     tm.assert_series_equal(result, expected)
  152: 
  153:     s2a = Series([1, None, 3], index=[0, 1, 2])
  154:     result = s1.rolling(window=3, min_periods=2).cov(s2a)
  155:     tm.assert_series_equal(result, expected)
  156: 
  157: 
  158: def test_rolling_corr_diff_length():
  159:     # GH 7512
  160:     s1 = Series([1, 2, 3], index=[0, 1, 2])
  161:     s2 = Series([1, 3], index=[0, 2])
  162:     result = s1.rolling(window=3, min_periods=2).corr(s2)
  163:     expected = Series([None, None, 1.0])
  164:     tm.assert_series_equal(result, expected)
  165: 
  166:     s2a = Series([1, None, 3], index=[0, 1, 2])
  167:     result = s1.rolling(window=3, min_periods=2).corr(s2a)
  168:     tm.assert_series_equal(result, expected)
  169: 
  170: 
  171: @pytest.mark.parametrize(
  172:     "f",
  173:     [
  174:         lambda x: (x.rolling(window=10, min_periods=5).cov(x, pairwise=True)),
  175:         lambda x: (x.rolling(window=10, min_periods=5).corr(x, pairwise=True)),
  176:     ],
  177: )
  178: def test_rolling_functions_window_non_shrinkage_binary(f):
  179:     # corr/cov return a MI DataFrame
  180:     df = DataFrame(
  181:         [[1, 5], [3, 2], [3, 9], [-1, 0]],
  182:         columns=Index(["A", "B"], name="foo"),
  183:         index=Index(range(4), name="bar"),
  184:     )
  185:     df_expected = DataFrame(
  186:         columns=Index(["A", "B"], name="foo"),
  187:         index=MultiIndex.from_product([df.index, df.columns], names=["bar", "foo"]),
  188:         dtype="float64",
  189:     )
  190:     df_result = f(df)
  191:     tm.assert_frame_equal(df_result, df_expected)
  192: 
  193: 
  194: @pytest.mark.parametrize(
  195:     "f",
  196:     [
  197:         lambda x: (x.rolling(window=10, min_periods=5).cov(x, pairwise=True)),
  198:         lambda x: (x.rolling(window=10, min_periods=5).corr(x, pairwise=True)),
  199:     ],
  200: )
  201: def test_moment_functions_zero_length_pairwise(f):
  202:     df1 = DataFrame()
  203:     df2 = DataFrame(columns=Index(["a"], name="foo"), index=Index([], name="bar"))
  204:     df2["a"] = df2["a"].astype("float64")
  205: 
  206:     df1_expected = DataFrame(index=MultiIndex.from_product([df1.index, df1.columns]))
  207:     df2_expected = DataFrame(
  208:         index=MultiIndex.from_product([df2.index, df2.columns], names=["bar", "foo"]),
  209:         columns=Index(["a"], name="foo"),
  210:         dtype="float64",
  211:     )
  212: 
  213:     df1_result = f(df1)
  214:     tm.assert_frame_equal(df1_result, df1_expected)
  215: 
  216:     df2_result = f(df2)
  217:     tm.assert_frame_equal(df2_result, df2_expected)
  218: 
  219: 
  220: class TestPairwise:
  221:     # GH 7738
  222:     @pytest.mark.parametrize("f", [lambda x: x.cov(), lambda x: x.corr()])
  223:     def test_no_flex(self, pairwise_frames, pairwise_target_frame, f):
  224:         # DataFrame methods (which do not call flex_binary_moment())
  225: 
  226:         result = f(pairwise_frames)
  227:         tm.assert_index_equal(result.index, pairwise_frames.columns)
  228:         tm.assert_index_equal(result.columns, pairwise_frames.columns)
  229:         expected = f(pairwise_target_frame)
  230:         # since we have sorted the results
  231:         # we can only compare non-nans
  232:         result = result.dropna().values
  233:         expected = expected.dropna().values
  234: 
  235:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  236: 
  237:     @pytest.mark.parametrize(
  238:         "f",
  239:         [
  240:             lambda x: x.expanding().cov(pairwise=True),
  241:             lambda x: x.expanding().corr(pairwise=True),
  242:             lambda x: x.rolling(window=3).cov(pairwise=True),
  243:             lambda x: x.rolling(window=3).corr(pairwise=True),
  244:             lambda x: x.ewm(com=3).cov(pairwise=True),
  245:             lambda x: x.ewm(com=3).corr(pairwise=True),
  246:         ],
  247:     )
  248:     def test_pairwise_with_self(self, pairwise_frames, pairwise_target_frame, f):
  249:         # DataFrame with itself, pairwise=True
  250:         # note that we may construct the 1st level of the MI
  251:         # in a non-monotonic way, so compare accordingly
  252:         result = f(pairwise_frames)
  253:         tm.assert_index_equal(
  254:             result.index.levels[0], pairwise_frames.index, check_names=False
  255:         )
  256:         tm.assert_index_equal(
  257:             safe_sort(result.index.levels[1]),
  258:             safe_sort(pairwise_frames.columns.unique()),
  259:         )
  260:         tm.assert_index_equal(result.columns, pairwise_frames.columns)
  261:         expected = f(pairwise_target_frame)
  262:         # since we have sorted the results
  263:         # we can only compare non-nans
  264:         result = result.dropna().values
  265:         expected = expected.dropna().values
  266: 
  267:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  268: 
  269:     @pytest.mark.parametrize(
  270:         "f",
  271:         [
  272:             lambda x: x.expanding().cov(pairwise=False),
  273:             lambda x: x.expanding().corr(pairwise=False),
  274:             lambda x: x.rolling(window=3).cov(pairwise=False),
  275:             lambda x: x.rolling(window=3).corr(pairwise=False),
  276:             lambda x: x.ewm(com=3).cov(pairwise=False),
  277:             lambda x: x.ewm(com=3).corr(pairwise=False),
  278:         ],
  279:     )
  280:     def test_no_pairwise_with_self(self, pairwise_frames, pairwise_target_frame, f):
  281:         # DataFrame with itself, pairwise=False
  282:         result = f(pairwise_frames)
  283:         tm.assert_index_equal(result.index, pairwise_frames.index)
  284:         tm.assert_index_equal(result.columns, pairwise_frames.columns)
  285:         expected = f(pairwise_target_frame)
  286:         # since we have sorted the results
  287:         # we can only compare non-nans
  288:         result = result.dropna().values
  289:         expected = expected.dropna().values
  290: 
  291:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  292: 
  293:     @pytest.mark.parametrize(
  294:         "f",
  295:         [
  296:             lambda x, y: x.expanding().cov(y, pairwise=True),
  297:             lambda x, y: x.expanding().corr(y, pairwise=True),
  298:             lambda x, y: x.rolling(window=3).cov(y, pairwise=True),
  299:             # TODO: We're missing a flag somewhere in meson
  300:             pytest.param(
  301:                 lambda x, y: x.rolling(window=3).corr(y, pairwise=True),
  302:                 marks=pytest.mark.xfail(
  303:                     not IS64, reason="Precision issues on 32 bit", strict=False
  304:                 ),
  305:             ),
  306:             lambda x, y: x.ewm(com=3).cov(y, pairwise=True),
  307:             lambda x, y: x.ewm(com=3).corr(y, pairwise=True),
  308:         ],
  309:     )
  310:     def test_pairwise_with_other(
  311:         self, pairwise_frames, pairwise_target_frame, pairwise_other_frame, f
  312:     ):
  313:         # DataFrame with another DataFrame, pairwise=True
  314:         result = f(pairwise_frames, pairwise_other_frame)
  315:         tm.assert_index_equal(
  316:             result.index.levels[0], pairwise_frames.index, check_names=False
  317:         )
  318:         tm.assert_index_equal(
  319:             safe_sort(result.index.levels[1]),
  320:             safe_sort(pairwise_other_frame.columns.unique()),
  321:         )
  322:         expected = f(pairwise_target_frame, pairwise_other_frame)
  323:         # since we have sorted the results
  324:         # we can only compare non-nans
  325:         result = result.dropna().values
  326:         expected = expected.dropna().values
  327: 
  328:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  329: 
  330:     @pytest.mark.filterwarnings("ignore:RuntimeWarning")
  331:     @pytest.mark.parametrize(
  332:         "f",
  333:         [
  334:             lambda x, y: x.expanding().cov(y, pairwise=False),
  335:             lambda x, y: x.expanding().corr(y, pairwise=False),
  336:             lambda x, y: x.rolling(window=3).cov(y, pairwise=False),
  337:             lambda x, y: x.rolling(window=3).corr(y, pairwise=False),
  338:             lambda x, y: x.ewm(com=3).cov(y, pairwise=False),
  339:             lambda x, y: x.ewm(com=3).corr(y, pairwise=False),
  340:         ],
  341:     )
  342:     def test_no_pairwise_with_other(self, pairwise_frames, pairwise_other_frame, f):
  343:         # DataFrame with another DataFrame, pairwise=False
  344:         result = (
  345:             f(pairwise_frames, pairwise_other_frame)
  346:             if pairwise_frames.columns.is_unique
  347:             else None
  348:         )
  349:         if result is not None:
  350:             # we can have int and str columns
  351:             expected_index = pairwise_frames.index.union(pairwise_other_frame.index)
  352:             expected_columns = pairwise_frames.columns.union(
  353:                 pairwise_other_frame.columns
  354:             )
  355:             tm.assert_index_equal(result.index, expected_index)
  356:             tm.assert_index_equal(result.columns, expected_columns)
  357:         else:
  358:             with pytest.raises(ValueError, match="'arg1' columns are not unique"):
  359:                 f(pairwise_frames, pairwise_other_frame)
  360:             with pytest.raises(ValueError, match="'arg2' columns are not unique"):
  361:                 f(pairwise_other_frame, pairwise_frames)
  362: 
  363:     @pytest.mark.parametrize(
  364:         "f",
  365:         [
  366:             lambda x, y: x.expanding().cov(y),
  367:             lambda x, y: x.expanding().corr(y),
  368:             lambda x, y: x.rolling(window=3).cov(y),
  369:             lambda x, y: x.rolling(window=3).corr(y),
  370:             lambda x, y: x.ewm(com=3).cov(y),
  371:             lambda x, y: x.ewm(com=3).corr(y),
  372:         ],
  373:     )
  374:     def test_pairwise_with_series(self, pairwise_frames, pairwise_target_frame, f):
  375:         # DataFrame with a Series
  376:         result = f(pairwise_frames, Series([1, 1, 3, 8]))
  377:         tm.assert_index_equal(result.index, pairwise_frames.index)
  378:         tm.assert_index_equal(result.columns, pairwise_frames.columns)
  379:         expected = f(pairwise_target_frame, Series([1, 1, 3, 8]))
  380:         # since we have sorted the results
  381:         # we can only compare non-nans
  382:         result = result.dropna().values
  383:         expected = expected.dropna().values
  384:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  385: 
  386:         result = f(Series([1, 1, 3, 8]), pairwise_frames)
  387:         tm.assert_index_equal(result.index, pairwise_frames.index)
  388:         tm.assert_index_equal(result.columns, pairwise_frames.columns)
  389:         expected = f(Series([1, 1, 3, 8]), pairwise_target_frame)
  390:         # since we have sorted the results
  391:         # we can only compare non-nans
  392:         result = result.dropna().values
  393:         expected = expected.dropna().values
  394:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  395: 
  396:     def test_corr_freq_memory_error(self):
  397:         # GH 31789
  398:         s = Series(range(5), index=date_range("2020", periods=5))
  399:         result = s.rolling("12h").corr(s)
  400:         expected = Series([np.nan] * 5, index=date_range("2020", periods=5))
  401:         tm.assert_series_equal(result, expected)
  402: 
  403:     def test_cov_mulittindex(self):
  404:         # GH 34440
  405: 
  406:         columns = MultiIndex.from_product([list("ab"), list("xy"), list("AB")])
  407:         index = range(3)
  408:         df = DataFrame(np.arange(24).reshape(3, 8), index=index, columns=columns)
  409: 
  410:         result = df.ewm(alpha=0.1).cov()
  411: 
  412:         index = MultiIndex.from_product([range(3), list("ab"), list("xy"), list("AB")])
  413:         columns = MultiIndex.from_product([list("ab"), list("xy"), list("AB")])
  414:         expected = DataFrame(
  415:             np.vstack(
  416:                 (
  417:                     np.full((8, 8), np.nan),
  418:                     np.full((8, 8), 32.000000),
  419:                     np.full((8, 8), 63.881919),
  420:                 )
  421:             ),
  422:             index=index,
  423:             columns=columns,
  424:         )
  425: 
  426:         tm.assert_frame_equal(result, expected)
  427: 
  428:     def test_multindex_columns_pairwise_func(self):
  429:         # GH 21157
  430:         columns = MultiIndex.from_arrays([["M", "N"], ["P", "Q"]], names=["a", "b"])
  431:         df = DataFrame(np.ones((5, 2)), columns=columns)
  432:         result = df.rolling(3).corr()
  433:         expected = DataFrame(
  434:             np.nan,
  435:             index=MultiIndex.from_arrays(
  436:                 [
  437:                     np.repeat(np.arange(5, dtype=np.int64), 2),
  438:                     ["M", "N"] * 5,
  439:                     ["P", "Q"] * 5,
  440:                 ],
  441:                 names=[None, "a", "b"],
  442:             ),
  443:             columns=columns,
  444:         )
  445:         tm.assert_frame_equal(result, expected)
