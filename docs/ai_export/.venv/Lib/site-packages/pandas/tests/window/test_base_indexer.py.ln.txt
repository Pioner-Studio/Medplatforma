    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     MultiIndex,
    7:     Series,
    8:     concat,
    9:     date_range,
   10: )
   11: import pandas._testing as tm
   12: from pandas.api.indexers import (
   13:     BaseIndexer,
   14:     FixedForwardWindowIndexer,
   15: )
   16: from pandas.core.indexers.objects import (
   17:     ExpandingIndexer,
   18:     FixedWindowIndexer,
   19:     VariableOffsetWindowIndexer,
   20: )
   21: 
   22: from pandas.tseries.offsets import BusinessDay
   23: 
   24: 
   25: def test_bad_get_window_bounds_signature():
   26:     class BadIndexer(BaseIndexer):
   27:         def get_window_bounds(self):
   28:             return None
   29: 
   30:     indexer = BadIndexer()
   31:     with pytest.raises(ValueError, match="BadIndexer does not implement"):
   32:         Series(range(5)).rolling(indexer)
   33: 
   34: 
   35: def test_expanding_indexer():
   36:     s = Series(range(10))
   37:     indexer = ExpandingIndexer()
   38:     result = s.rolling(indexer).mean()
   39:     expected = s.expanding().mean()
   40:     tm.assert_series_equal(result, expected)
   41: 
   42: 
   43: def test_indexer_constructor_arg():
   44:     # Example found in computation.rst
   45:     use_expanding = [True, False, True, False, True]
   46:     df = DataFrame({"values": range(5)})
   47: 
   48:     class CustomIndexer(BaseIndexer):
   49:         def get_window_bounds(self, num_values, min_periods, center, closed, step):
   50:             start = np.empty(num_values, dtype=np.int64)
   51:             end = np.empty(num_values, dtype=np.int64)
   52:             for i in range(num_values):
   53:                 if self.use_expanding[i]:
   54:                     start[i] = 0
   55:                     end[i] = i + 1
   56:                 else:
   57:                     start[i] = i
   58:                     end[i] = i + self.window_size
   59:             return start, end
   60: 
   61:     indexer = CustomIndexer(window_size=1, use_expanding=use_expanding)
   62:     result = df.rolling(indexer).sum()
   63:     expected = DataFrame({"values": [0.0, 1.0, 3.0, 3.0, 10.0]})
   64:     tm.assert_frame_equal(result, expected)
   65: 
   66: 
   67: def test_indexer_accepts_rolling_args():
   68:     df = DataFrame({"values": range(5)})
   69: 
   70:     class CustomIndexer(BaseIndexer):
   71:         def get_window_bounds(self, num_values, min_periods, center, closed, step):
   72:             start = np.empty(num_values, dtype=np.int64)
   73:             end = np.empty(num_values, dtype=np.int64)
   74:             for i in range(num_values):
   75:                 if (
   76:                     center
   77:                     and min_periods == 1
   78:                     and closed == "both"
   79:                     and step == 1
   80:                     and i == 2
   81:                 ):
   82:                     start[i] = 0
   83:                     end[i] = num_values
   84:                 else:
   85:                     start[i] = i
   86:                     end[i] = i + self.window_size
   87:             return start, end
   88: 
   89:     indexer = CustomIndexer(window_size=1)
   90:     result = df.rolling(
   91:         indexer, center=True, min_periods=1, closed="both", step=1
   92:     ).sum()
   93:     expected = DataFrame({"values": [0.0, 1.0, 10.0, 3.0, 4.0]})
   94:     tm.assert_frame_equal(result, expected)
   95: 
   96: 
   97: @pytest.mark.parametrize(
   98:     "func,np_func,expected,np_kwargs",
   99:     [
  100:         ("count", len, [3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 2.0, np.nan], {}),
  101:         ("min", np.min, [0.0, 1.0, 2.0, 3.0, 4.0, 6.0, 6.0, 7.0, 8.0, np.nan], {}),
  102:         (
  103:             "max",
  104:             np.max,
  105:             [2.0, 3.0, 4.0, 100.0, 100.0, 100.0, 8.0, 9.0, 9.0, np.nan],
  106:             {},
  107:         ),
  108:         (
  109:             "std",
  110:             np.std,
  111:             [
  112:                 1.0,
  113:                 1.0,
  114:                 1.0,
  115:                 55.71654452,
  116:                 54.85739087,
  117:                 53.9845657,
  118:                 1.0,
  119:                 1.0,
  120:                 0.70710678,
  121:                 np.nan,
  122:             ],
  123:             {"ddof": 1},
  124:         ),
  125:         (
  126:             "var",
  127:             np.var,
  128:             [
  129:                 1.0,
  130:                 1.0,
  131:                 1.0,
  132:                 3104.333333,
  133:                 3009.333333,
  134:                 2914.333333,
  135:                 1.0,
  136:                 1.0,
  137:                 0.500000,
  138:                 np.nan,
  139:             ],
  140:             {"ddof": 1},
  141:         ),
  142:         (
  143:             "median",
  144:             np.median,
  145:             [1.0, 2.0, 3.0, 4.0, 6.0, 7.0, 7.0, 8.0, 8.5, np.nan],
  146:             {},
  147:         ),
  148:     ],
  149: )
  150: def test_rolling_forward_window(
  151:     frame_or_series, func, np_func, expected, np_kwargs, step
  152: ):
  153:     # GH 32865
  154:     values = np.arange(10.0)
  155:     values[5] = 100.0
  156: 
  157:     indexer = FixedForwardWindowIndexer(window_size=3)
  158: 
  159:     match = "Forward-looking windows can't have center=True"
  160:     with pytest.raises(ValueError, match=match):
  161:         rolling = frame_or_series(values).rolling(window=indexer, center=True)
  162:         getattr(rolling, func)()
  163: 
  164:     match = "Forward-looking windows don't support setting the closed argument"
  165:     with pytest.raises(ValueError, match=match):
  166:         rolling = frame_or_series(values).rolling(window=indexer, closed="right")
  167:         getattr(rolling, func)()
  168: 
  169:     rolling = frame_or_series(values).rolling(window=indexer, min_periods=2, step=step)
  170:     result = getattr(rolling, func)()
  171: 
  172:     # Check that the function output matches the explicitly provided array
  173:     expected = frame_or_series(expected)[::step]
  174:     tm.assert_equal(result, expected)
  175: 
  176:     # Check that the rolling function output matches applying an alternative
  177:     # function to the rolling window object
  178:     expected2 = frame_or_series(rolling.apply(lambda x: np_func(x, **np_kwargs)))
  179:     tm.assert_equal(result, expected2)
  180: 
  181:     # Check that the function output matches applying an alternative function
  182:     # if min_periods isn't specified
  183:     # GH 39604: After count-min_periods deprecation, apply(lambda x: len(x))
  184:     # is equivalent to count after setting min_periods=0
  185:     min_periods = 0 if func == "count" else None
  186:     rolling3 = frame_or_series(values).rolling(window=indexer, min_periods=min_periods)
  187:     result3 = getattr(rolling3, func)()
  188:     expected3 = frame_or_series(rolling3.apply(lambda x: np_func(x, **np_kwargs)))
  189:     tm.assert_equal(result3, expected3)
  190: 
  191: 
  192: def test_rolling_forward_skewness(frame_or_series, step):
  193:     values = np.arange(10.0)
  194:     values[5] = 100.0
  195: 
  196:     indexer = FixedForwardWindowIndexer(window_size=5)
  197:     rolling = frame_or_series(values).rolling(window=indexer, min_periods=3, step=step)
  198:     result = rolling.skew()
  199: 
  200:     expected = frame_or_series(
  201:         [
  202:             0.0,
  203:             2.232396,
  204:             2.229508,
  205:             2.228340,
  206:             2.229091,
  207:             2.231989,
  208:             0.0,
  209:             0.0,
  210:             np.nan,
  211:             np.nan,
  212:         ]
  213:     )[::step]
  214:     tm.assert_equal(result, expected)
  215: 
  216: 
  217: @pytest.mark.parametrize(
  218:     "func,expected",
  219:     [
  220:         ("cov", [2.0, 2.0, 2.0, 97.0, 2.0, -93.0, 2.0, 2.0, np.nan, np.nan]),
  221:         (
  222:             "corr",
  223:             [
  224:                 1.0,
  225:                 1.0,
  226:                 1.0,
  227:                 0.8704775290207161,
  228:                 0.018229084250926637,
  229:                 -0.861357304646493,
  230:                 1.0,
  231:                 1.0,
  232:                 np.nan,
  233:                 np.nan,
  234:             ],
  235:         ),
  236:     ],
  237: )
  238: def test_rolling_forward_cov_corr(func, expected):
  239:     values1 = np.arange(10).reshape(-1, 1)
  240:     values2 = values1 * 2
  241:     values1[5, 0] = 100
  242:     values = np.concatenate([values1, values2], axis=1)
  243: 
  244:     indexer = FixedForwardWindowIndexer(window_size=3)
  245:     rolling = DataFrame(values).rolling(window=indexer, min_periods=3)
  246:     # We are interested in checking only pairwise covariance / correlation
  247:     result = getattr(rolling, func)().loc[(slice(None), 1), 0]
  248:     result = result.reset_index(drop=True)
  249:     expected = Series(expected).reset_index(drop=True)
  250:     expected.name = result.name
  251:     tm.assert_equal(result, expected)
  252: 
  253: 
  254: @pytest.mark.parametrize(
  255:     "closed,expected_data",
  256:     [
  257:         ["right", [0.0, 1.0, 2.0, 3.0, 7.0, 12.0, 6.0, 7.0, 8.0, 9.0]],
  258:         ["left", [0.0, 0.0, 1.0, 2.0, 5.0, 9.0, 5.0, 6.0, 7.0, 8.0]],
  259:     ],
  260: )
  261: def test_non_fixed_variable_window_indexer(closed, expected_data):
  262:     index = date_range("2020", periods=10)
  263:     df = DataFrame(range(10), index=index)
  264:     offset = BusinessDay(1)
  265:     indexer = VariableOffsetWindowIndexer(index=index, offset=offset)
  266:     result = df.rolling(indexer, closed=closed).sum()
  267:     expected = DataFrame(expected_data, index=index)
  268:     tm.assert_frame_equal(result, expected)
  269: 
  270: 
  271: def test_variableoffsetwindowindexer_not_dti():
  272:     # GH 54379
  273:     with pytest.raises(ValueError, match="index must be a DatetimeIndex."):
  274:         VariableOffsetWindowIndexer(index="foo", offset=BusinessDay(1))
  275: 
  276: 
  277: def test_variableoffsetwindowindexer_not_offset():
  278:     # GH 54379
  279:     idx = date_range("2020", periods=10)
  280:     with pytest.raises(ValueError, match="offset must be a DateOffset-like object."):
  281:         VariableOffsetWindowIndexer(index=idx, offset="foo")
  282: 
  283: 
  284: def test_fixed_forward_indexer_count(step):
  285:     # GH: 35579
  286:     df = DataFrame({"b": [None, None, None, 7]})
  287:     indexer = FixedForwardWindowIndexer(window_size=2)
  288:     result = df.rolling(window=indexer, min_periods=0, step=step).count()
  289:     expected = DataFrame({"b": [0.0, 0.0, 1.0, 1.0]})[::step]
  290:     tm.assert_frame_equal(result, expected)
  291: 
  292: 
  293: @pytest.mark.parametrize(
  294:     ("end_value", "values"), [(1, [0.0, 1, 1, 3, 2]), (-1, [0.0, 1, 0, 3, 1])]
  295: )
  296: @pytest.mark.parametrize(("func", "args"), [("median", []), ("quantile", [0.5])])
  297: def test_indexer_quantile_sum(end_value, values, func, args):
  298:     # GH 37153
  299:     class CustomIndexer(BaseIndexer):
  300:         def get_window_bounds(self, num_values, min_periods, center, closed, step):
  301:             start = np.empty(num_values, dtype=np.int64)
  302:             end = np.empty(num_values, dtype=np.int64)
  303:             for i in range(num_values):
  304:                 if self.use_expanding[i]:
  305:                     start[i] = 0
  306:                     end[i] = max(i + end_value, 1)
  307:                 else:
  308:                     start[i] = i
  309:                     end[i] = i + self.window_size
  310:             return start, end
  311: 
  312:     use_expanding = [True, False, True, False, True]
  313:     df = DataFrame({"values": range(5)})
  314: 
  315:     indexer = CustomIndexer(window_size=1, use_expanding=use_expanding)
  316:     result = getattr(df.rolling(indexer), func)(*args)
  317:     expected = DataFrame({"values": values})
  318:     tm.assert_frame_equal(result, expected)
  319: 
  320: 
  321: @pytest.mark.parametrize(
  322:     "indexer_class", [FixedWindowIndexer, FixedForwardWindowIndexer, ExpandingIndexer]
  323: )
  324: @pytest.mark.parametrize("window_size", [1, 2, 12])
  325: @pytest.mark.parametrize(
  326:     "df_data",
  327:     [
  328:         {"a": [1, 1], "b": [0, 1]},
  329:         {"a": [1, 2], "b": [0, 1]},
  330:         {"a": [1] * 16, "b": [np.nan, 1, 2, np.nan] + list(range(4, 16))},
  331:     ],
  332: )
  333: def test_indexers_are_reusable_after_groupby_rolling(
  334:     indexer_class, window_size, df_data
  335: ):
  336:     # GH 43267
  337:     df = DataFrame(df_data)
  338:     num_trials = 3
  339:     indexer = indexer_class(window_size=window_size)
  340:     original_window_size = indexer.window_size
  341:     for i in range(num_trials):
  342:         df.groupby("a")["b"].rolling(window=indexer, min_periods=1).mean()
  343:         assert indexer.window_size == original_window_size
  344: 
  345: 
  346: @pytest.mark.parametrize(
  347:     "window_size, num_values, expected_start, expected_end",
  348:     [
  349:         (1, 1, [0], [1]),
  350:         (1, 2, [0, 1], [1, 2]),
  351:         (2, 1, [0], [1]),
  352:         (2, 2, [0, 1], [2, 2]),
  353:         (5, 12, range(12), list(range(5, 12)) + [12] * 5),
  354:         (12, 5, range(5), [5] * 5),
  355:         (0, 0, np.array([]), np.array([])),
  356:         (1, 0, np.array([]), np.array([])),
  357:         (0, 1, [0], [0]),
  358:     ],
  359: )
  360: def test_fixed_forward_indexer_bounds(
  361:     window_size, num_values, expected_start, expected_end, step
  362: ):
  363:     # GH 43267
  364:     indexer = FixedForwardWindowIndexer(window_size=window_size)
  365:     start, end = indexer.get_window_bounds(num_values=num_values, step=step)
  366: 
  367:     tm.assert_numpy_array_equal(
  368:         start, np.array(expected_start[::step]), check_dtype=False
  369:     )
  370:     tm.assert_numpy_array_equal(end, np.array(expected_end[::step]), check_dtype=False)
  371:     assert len(start) == len(end)
  372: 
  373: 
  374: @pytest.mark.parametrize(
  375:     "df, window_size, expected",
  376:     [
  377:         (
  378:             DataFrame({"b": [0, 1, 2], "a": [1, 2, 2]}),
  379:             2,
  380:             Series(
  381:                 [0, 1.5, 2.0],
  382:                 index=MultiIndex.from_arrays([[1, 2, 2], range(3)], names=["a", None]),
  383:                 name="b",
  384:                 dtype=np.float64,
  385:             ),
  386:         ),
  387:         (
  388:             DataFrame(
  389:                 {
  390:                     "b": [np.nan, 1, 2, np.nan] + list(range(4, 18)),
  391:                     "a": [1] * 7 + [2] * 11,
  392:                     "c": range(18),
  393:                 }
  394:             ),
  395:             12,
  396:             Series(
  397:                 [
  398:                     3.6,
  399:                     3.6,
  400:                     4.25,
  401:                     5.0,
  402:                     5.0,
  403:                     5.5,
  404:                     6.0,
  405:                     12.0,
  406:                     12.5,
  407:                     13.0,
  408:                     13.5,
  409:                     14.0,
  410:                     14.5,
  411:                     15.0,
  412:                     15.5,
  413:                     16.0,
  414:                     16.5,
  415:                     17.0,
  416:                 ],
  417:                 index=MultiIndex.from_arrays(
  418:                     [[1] * 7 + [2] * 11, range(18)], names=["a", None]
  419:                 ),
  420:                 name="b",
  421:                 dtype=np.float64,
  422:             ),
  423:         ),
  424:     ],
  425: )
  426: def test_rolling_groupby_with_fixed_forward_specific(df, window_size, expected):
  427:     # GH 43267
  428:     indexer = FixedForwardWindowIndexer(window_size=window_size)
  429:     result = df.groupby("a")["b"].rolling(window=indexer, min_periods=1).mean()
  430:     tm.assert_series_equal(result, expected)
  431: 
  432: 
  433: @pytest.mark.parametrize(
  434:     "group_keys",
  435:     [
  436:         (1,),
  437:         (1, 2),
  438:         (2, 1),
  439:         (1, 1, 2),
  440:         (1, 2, 1),
  441:         (1, 1, 2, 2),
  442:         (1, 2, 3, 2, 3),
  443:         (1, 1, 2) * 4,
  444:         (1, 2, 3) * 5,
  445:     ],
  446: )
  447: @pytest.mark.parametrize("window_size", [1, 2, 3, 4, 5, 8, 20])
  448: def test_rolling_groupby_with_fixed_forward_many(group_keys, window_size):
  449:     # GH 43267
  450:     df = DataFrame(
  451:         {
  452:             "a": np.array(list(group_keys)),
  453:             "b": np.arange(len(group_keys), dtype=np.float64) + 17,
  454:             "c": np.arange(len(group_keys), dtype=np.int64),
  455:         }
  456:     )
  457: 
  458:     indexer = FixedForwardWindowIndexer(window_size=window_size)
  459:     result = df.groupby("a")["b"].rolling(window=indexer, min_periods=1).sum()
  460:     result.index.names = ["a", "c"]
  461: 
  462:     groups = df.groupby("a")[["a", "b", "c"]]
  463:     manual = concat(
  464:         [
  465:             g.assign(
  466:                 b=[
  467:                     g["b"].iloc[i : i + window_size].sum(min_count=1)
  468:                     for i in range(len(g))
  469:                 ]
  470:             )
  471:             for _, g in groups
  472:         ]
  473:     )
  474:     manual = manual.set_index(["a", "c"])["b"]
  475: 
  476:     tm.assert_series_equal(result, manual)
  477: 
  478: 
  479: def test_unequal_start_end_bounds():
  480:     class CustomIndexer(BaseIndexer):
  481:         def get_window_bounds(self, num_values, min_periods, center, closed, step):
  482:             return np.array([1]), np.array([1, 2])
  483: 
  484:     indexer = CustomIndexer()
  485:     roll = Series(1).rolling(indexer)
  486:     match = "start"
  487:     with pytest.raises(ValueError, match=match):
  488:         roll.mean()
  489: 
  490:     with pytest.raises(ValueError, match=match):
  491:         next(iter(roll))
  492: 
  493:     with pytest.raises(ValueError, match=match):
  494:         roll.corr(pairwise=True)
  495: 
  496:     with pytest.raises(ValueError, match=match):
  497:         roll.cov(pairwise=True)
  498: 
  499: 
  500: def test_unequal_bounds_to_object():
  501:     # GH 44470
  502:     class CustomIndexer(BaseIndexer):
  503:         def get_window_bounds(self, num_values, min_periods, center, closed, step):
  504:             return np.array([1]), np.array([2])
  505: 
  506:     indexer = CustomIndexer()
  507:     roll = Series([1, 1]).rolling(indexer)
  508:     match = "start and end"
  509:     with pytest.raises(ValueError, match=match):
  510:         roll.mean()
  511: 
  512:     with pytest.raises(ValueError, match=match):
  513:         next(iter(roll))
  514: 
  515:     with pytest.raises(ValueError, match=match):
  516:         roll.corr(pairwise=True)
  517: 
  518:     with pytest.raises(ValueError, match=match):
  519:         roll.cov(pairwise=True)
