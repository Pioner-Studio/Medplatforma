    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     DatetimeIndex,
    7:     Series,
    8:     date_range,
    9: )
   10: import pandas._testing as tm
   11: 
   12: 
   13: def test_doc_string():
   14:     df = DataFrame({"B": [0, 1, 2, np.nan, 4]})
   15:     df
   16:     df.ewm(com=0.5).mean()
   17: 
   18: 
   19: def test_constructor(frame_or_series):
   20:     c = frame_or_series(range(5)).ewm
   21: 
   22:     # valid
   23:     c(com=0.5)
   24:     c(span=1.5)
   25:     c(alpha=0.5)
   26:     c(halflife=0.75)
   27:     c(com=0.5, span=None)
   28:     c(alpha=0.5, com=None)
   29:     c(halflife=0.75, alpha=None)
   30: 
   31:     # not valid: mutually exclusive
   32:     msg = "comass, span, halflife, and alpha are mutually exclusive"
   33:     with pytest.raises(ValueError, match=msg):
   34:         c(com=0.5, alpha=0.5)
   35:     with pytest.raises(ValueError, match=msg):
   36:         c(span=1.5, halflife=0.75)
   37:     with pytest.raises(ValueError, match=msg):
   38:         c(alpha=0.5, span=1.5)
   39: 
   40:     # not valid: com < 0
   41:     msg = "comass must satisfy: comass >= 0"
   42:     with pytest.raises(ValueError, match=msg):
   43:         c(com=-0.5)
   44: 
   45:     # not valid: span < 1
   46:     msg = "span must satisfy: span >= 1"
   47:     with pytest.raises(ValueError, match=msg):
   48:         c(span=0.5)
   49: 
   50:     # not valid: halflife <= 0
   51:     msg = "halflife must satisfy: halflife > 0"
   52:     with pytest.raises(ValueError, match=msg):
   53:         c(halflife=0)
   54: 
   55:     # not valid: alpha <= 0 or alpha > 1
   56:     msg = "alpha must satisfy: 0 < alpha <= 1"
   57:     for alpha in (-0.5, 1.5):
   58:         with pytest.raises(ValueError, match=msg):
   59:             c(alpha=alpha)
   60: 
   61: 
   62: def test_ewma_times_not_datetime_type():
   63:     msg = r"times must be datetime64 dtype."
   64:     with pytest.raises(ValueError, match=msg):
   65:         Series(range(5)).ewm(times=np.arange(5))
   66: 
   67: 
   68: def test_ewma_times_not_same_length():
   69:     msg = "times must be the same length as the object."
   70:     with pytest.raises(ValueError, match=msg):
   71:         Series(range(5)).ewm(times=np.arange(4).astype("datetime64[ns]"))
   72: 
   73: 
   74: def test_ewma_halflife_not_correct_type():
   75:     msg = "halflife must be a timedelta convertible object"
   76:     with pytest.raises(ValueError, match=msg):
   77:         Series(range(5)).ewm(halflife=1, times=np.arange(5).astype("datetime64[ns]"))
   78: 
   79: 
   80: def test_ewma_halflife_without_times(halflife_with_times):
   81:     msg = "halflife can only be a timedelta convertible argument if times is not None."
   82:     with pytest.raises(ValueError, match=msg):
   83:         Series(range(5)).ewm(halflife=halflife_with_times)
   84: 
   85: 
   86: @pytest.mark.parametrize(
   87:     "times",
   88:     [
   89:         np.arange(10).astype("datetime64[D]").astype("datetime64[ns]"),
   90:         date_range("2000", freq="D", periods=10),
   91:         date_range("2000", freq="D", periods=10).tz_localize("UTC"),
   92:     ],
   93: )
   94: @pytest.mark.parametrize("min_periods", [0, 2])
   95: def test_ewma_with_times_equal_spacing(halflife_with_times, times, min_periods):
   96:     halflife = halflife_with_times
   97:     data = np.arange(10.0)
   98:     data[::2] = np.nan
   99:     df = DataFrame({"A": data})
  100:     result = df.ewm(halflife=halflife, min_periods=min_periods, times=times).mean()
  101:     expected = df.ewm(halflife=1.0, min_periods=min_periods).mean()
  102:     tm.assert_frame_equal(result, expected)
  103: 
  104: 
  105: def test_ewma_with_times_variable_spacing(tz_aware_fixture, unit):
  106:     tz = tz_aware_fixture
  107:     halflife = "23 days"
  108:     times = (
  109:         DatetimeIndex(["2020-01-01", "2020-01-10T00:04:05", "2020-02-23T05:00:23"])
  110:         .tz_localize(tz)
  111:         .as_unit(unit)
  112:     )
  113:     data = np.arange(3)
  114:     df = DataFrame(data)
  115:     result = df.ewm(halflife=halflife, times=times).mean()
  116:     expected = DataFrame([0.0, 0.5674161888241773, 1.545239952073459])
  117:     tm.assert_frame_equal(result, expected)
  118: 
  119: 
  120: def test_ewm_with_nat_raises(halflife_with_times):
  121:     # GH#38535
  122:     ser = Series(range(1))
  123:     times = DatetimeIndex(["NaT"])
  124:     with pytest.raises(ValueError, match="Cannot convert NaT values to integer"):
  125:         ser.ewm(com=0.1, halflife=halflife_with_times, times=times)
  126: 
  127: 
  128: def test_ewm_with_times_getitem(halflife_with_times):
  129:     # GH 40164
  130:     halflife = halflife_with_times
  131:     data = np.arange(10.0)
  132:     data[::2] = np.nan
  133:     times = date_range("2000", freq="D", periods=10)
  134:     df = DataFrame({"A": data, "B": data})
  135:     result = df.ewm(halflife=halflife, times=times)["A"].mean()
  136:     expected = df.ewm(halflife=1.0)["A"].mean()
  137:     tm.assert_series_equal(result, expected)
  138: 
  139: 
  140: @pytest.mark.parametrize("arg", ["com", "halflife", "span", "alpha"])
  141: def test_ewm_getitem_attributes_retained(arg, adjust, ignore_na):
  142:     # GH 40164
  143:     kwargs = {arg: 1, "adjust": adjust, "ignore_na": ignore_na}
  144:     ewm = DataFrame({"A": range(1), "B": range(1)}).ewm(**kwargs)
  145:     expected = {attr: getattr(ewm, attr) for attr in ewm._attributes}
  146:     ewm_slice = ewm["A"]
  147:     result = {attr: getattr(ewm, attr) for attr in ewm_slice._attributes}
  148:     assert result == expected
  149: 
  150: 
  151: def test_ewma_times_adjust_false_raises():
  152:     # GH 40098
  153:     with pytest.raises(
  154:         NotImplementedError, match="times is not supported with adjust=False."
  155:     ):
  156:         Series(range(1)).ewm(
  157:             0.1, adjust=False, times=date_range("2000", freq="D", periods=1)
  158:         )
  159: 
  160: 
  161: @pytest.mark.parametrize(
  162:     "func, expected",
  163:     [
  164:         [
  165:             "mean",
  166:             DataFrame(
  167:                 {
  168:                     0: range(5),
  169:                     1: range(4, 9),
  170:                     2: [7.428571, 9, 10.571429, 12.142857, 13.714286],
  171:                 },
  172:                 dtype=float,
  173:             ),
  174:         ],
  175:         [
  176:             "std",
  177:             DataFrame(
  178:                 {
  179:                     0: [np.nan] * 5,
  180:                     1: [4.242641] * 5,
  181:                     2: [4.6291, 5.196152, 5.781745, 6.380775, 6.989788],
  182:                 }
  183:             ),
  184:         ],
  185:         [
  186:             "var",
  187:             DataFrame(
  188:                 {
  189:                     0: [np.nan] * 5,
  190:                     1: [18.0] * 5,
  191:                     2: [21.428571, 27, 33.428571, 40.714286, 48.857143],
  192:                 }
  193:             ),
  194:         ],
  195:     ],
  196: )
  197: def test_float_dtype_ewma(func, expected, float_numpy_dtype):
  198:     # GH#42452
  199: 
  200:     df = DataFrame(
  201:         {0: range(5), 1: range(6, 11), 2: range(10, 20, 2)}, dtype=float_numpy_dtype
  202:     )
  203:     msg = "Support for axis=1 in DataFrame.ewm is deprecated"
  204:     with tm.assert_produces_warning(FutureWarning, match=msg):
  205:         e = df.ewm(alpha=0.5, axis=1)
  206:     result = getattr(e, func)()
  207: 
  208:     tm.assert_frame_equal(result, expected)
  209: 
  210: 
  211: def test_times_string_col_raises():
  212:     # GH 43265
  213:     df = DataFrame(
  214:         {"A": np.arange(10.0), "time_col": date_range("2000", freq="D", periods=10)}
  215:     )
  216:     with pytest.raises(ValueError, match="times must be datetime64"):
  217:         df.ewm(halflife="1 day", min_periods=0, times="time_col")
  218: 
  219: 
  220: def test_ewm_sum_adjust_false_notimplemented():
  221:     data = Series(range(1)).ewm(com=1, adjust=False)
  222:     with pytest.raises(NotImplementedError, match="sum is not"):
  223:         data.sum()
  224: 
  225: 
  226: @pytest.mark.parametrize(
  227:     "expected_data, ignore",
  228:     [[[10.0, 5.0, 2.5, 11.25], False], [[10.0, 5.0, 5.0, 12.5], True]],
  229: )
  230: def test_ewm_sum(expected_data, ignore):
  231:     # xref from Numbagg tests
  232:     # https://github.com/numbagg/numbagg/blob/v0.2.1/numbagg/test/test_moving.py#L50
  233:     data = Series([10, 0, np.nan, 10])
  234:     result = data.ewm(alpha=0.5, ignore_na=ignore).sum()
  235:     expected = Series(expected_data)
  236:     tm.assert_series_equal(result, expected)
  237: 
  238: 
  239: def test_ewma_adjust():
  240:     vals = Series(np.zeros(1000))
  241:     vals[5] = 1
  242:     result = vals.ewm(span=100, adjust=False).mean().sum()
  243:     assert np.abs(result - 1) < 1e-2
  244: 
  245: 
  246: def test_ewma_cases(adjust, ignore_na):
  247:     # try adjust/ignore_na args matrix
  248: 
  249:     s = Series([1.0, 2.0, 4.0, 8.0])
  250: 
  251:     if adjust:
  252:         expected = Series([1.0, 1.6, 2.736842, 4.923077])
  253:     else:
  254:         expected = Series([1.0, 1.333333, 2.222222, 4.148148])
  255: 
  256:     result = s.ewm(com=2.0, adjust=adjust, ignore_na=ignore_na).mean()
  257:     tm.assert_series_equal(result, expected)
  258: 
  259: 
  260: def test_ewma_nan_handling():
  261:     s = Series([1.0] + [np.nan] * 5 + [1.0])
  262:     result = s.ewm(com=5).mean()
  263:     tm.assert_series_equal(result, Series([1.0] * len(s)))
  264: 
  265:     s = Series([np.nan] * 2 + [1.0] + [np.nan] * 2 + [1.0])
  266:     result = s.ewm(com=5).mean()
  267:     tm.assert_series_equal(result, Series([np.nan] * 2 + [1.0] * 4))
  268: 
  269: 
  270: @pytest.mark.parametrize(
  271:     "s, adjust, ignore_na, w",
  272:     [
  273:         (
  274:             Series([np.nan, 1.0, 101.0]),
  275:             True,
  276:             False,
  277:             [np.nan, (1.0 - (1.0 / (1.0 + 2.0))), 1.0],
  278:         ),
  279:         (
  280:             Series([np.nan, 1.0, 101.0]),
  281:             True,
  282:             True,
  283:             [np.nan, (1.0 - (1.0 / (1.0 + 2.0))), 1.0],
  284:         ),
  285:         (
  286:             Series([np.nan, 1.0, 101.0]),
  287:             False,
  288:             False,
  289:             [np.nan, (1.0 - (1.0 / (1.0 + 2.0))), (1.0 / (1.0 + 2.0))],
  290:         ),
  291:         (
  292:             Series([np.nan, 1.0, 101.0]),
  293:             False,
  294:             True,
  295:             [np.nan, (1.0 - (1.0 / (1.0 + 2.0))), (1.0 / (1.0 + 2.0))],
  296:         ),
  297:         (
  298:             Series([1.0, np.nan, 101.0]),
  299:             True,
  300:             False,
  301:             [(1.0 - (1.0 / (1.0 + 2.0))) ** 2, np.nan, 1.0],
  302:         ),
  303:         (
  304:             Series([1.0, np.nan, 101.0]),
  305:             True,
  306:             True,
  307:             [(1.0 - (1.0 / (1.0 + 2.0))), np.nan, 1.0],
  308:         ),
  309:         (
  310:             Series([1.0, np.nan, 101.0]),
  311:             False,
  312:             False,
  313:             [(1.0 - (1.0 / (1.0 + 2.0))) ** 2, np.nan, (1.0 / (1.0 + 2.0))],
  314:         ),
  315:         (
  316:             Series([1.0, np.nan, 101.0]),
  317:             False,
  318:             True,
  319:             [(1.0 - (1.0 / (1.0 + 2.0))), np.nan, (1.0 / (1.0 + 2.0))],
  320:         ),
  321:         (
  322:             Series([np.nan, 1.0, np.nan, np.nan, 101.0, np.nan]),
  323:             True,
  324:             False,
  325:             [np.nan, (1.0 - (1.0 / (1.0 + 2.0))) ** 3, np.nan, np.nan, 1.0, np.nan],
  326:         ),
  327:         (
  328:             Series([np.nan, 1.0, np.nan, np.nan, 101.0, np.nan]),
  329:             True,
  330:             True,
  331:             [np.nan, (1.0 - (1.0 / (1.0 + 2.0))), np.nan, np.nan, 1.0, np.nan],
  332:         ),
  333:         (
  334:             Series([np.nan, 1.0, np.nan, np.nan, 101.0, np.nan]),
  335:             False,
  336:             False,
  337:             [
  338:                 np.nan,
  339:                 (1.0 - (1.0 / (1.0 + 2.0))) ** 3,
  340:                 np.nan,
  341:                 np.nan,
  342:                 (1.0 / (1.0 + 2.0)),
  343:                 np.nan,
  344:             ],
  345:         ),
  346:         (
  347:             Series([np.nan, 1.0, np.nan, np.nan, 101.0, np.nan]),
  348:             False,
  349:             True,
  350:             [
  351:                 np.nan,
  352:                 (1.0 - (1.0 / (1.0 + 2.0))),
  353:                 np.nan,
  354:                 np.nan,
  355:                 (1.0 / (1.0 + 2.0)),
  356:                 np.nan,
  357:             ],
  358:         ),
  359:         (
  360:             Series([1.0, np.nan, 101.0, 50.0]),
  361:             True,
  362:             False,
  363:             [
  364:                 (1.0 - (1.0 / (1.0 + 2.0))) ** 3,
  365:                 np.nan,
  366:                 (1.0 - (1.0 / (1.0 + 2.0))),
  367:                 1.0,
  368:             ],
  369:         ),
  370:         (
  371:             Series([1.0, np.nan, 101.0, 50.0]),
  372:             True,
  373:             True,
  374:             [
  375:                 (1.0 - (1.0 / (1.0 + 2.0))) ** 2,
  376:                 np.nan,
  377:                 (1.0 - (1.0 / (1.0 + 2.0))),
  378:                 1.0,
  379:             ],
  380:         ),
  381:         (
  382:             Series([1.0, np.nan, 101.0, 50.0]),
  383:             False,
  384:             False,
  385:             [
  386:                 (1.0 - (1.0 / (1.0 + 2.0))) ** 3,
  387:                 np.nan,
  388:                 (1.0 - (1.0 / (1.0 + 2.0))) * (1.0 / (1.0 + 2.0)),
  389:                 (1.0 / (1.0 + 2.0))
  390:                 * ((1.0 - (1.0 / (1.0 + 2.0))) ** 2 + (1.0 / (1.0 + 2.0))),
  391:             ],
  392:         ),
  393:         (
  394:             Series([1.0, np.nan, 101.0, 50.0]),
  395:             False,
  396:             True,
  397:             [
  398:                 (1.0 - (1.0 / (1.0 + 2.0))) ** 2,
  399:                 np.nan,
  400:                 (1.0 - (1.0 / (1.0 + 2.0))) * (1.0 / (1.0 + 2.0)),
  401:                 (1.0 / (1.0 + 2.0)),
  402:             ],
  403:         ),
  404:     ],
  405: )
  406: def test_ewma_nan_handling_cases(s, adjust, ignore_na, w):
  407:     # GH 7603
  408:     expected = (s.multiply(w).cumsum() / Series(w).cumsum()).ffill()
  409:     result = s.ewm(com=2.0, adjust=adjust, ignore_na=ignore_na).mean()
  410: 
  411:     tm.assert_series_equal(result, expected)
  412:     if ignore_na is False:
  413:         # check that ignore_na defaults to False
  414:         result = s.ewm(com=2.0, adjust=adjust).mean()
  415:         tm.assert_series_equal(result, expected)
  416: 
  417: 
  418: def test_ewm_alpha():
  419:     # GH 10789
  420:     arr = np.random.default_rng(2).standard_normal(100)
  421:     locs = np.arange(20, 40)
  422:     arr[locs] = np.nan
  423: 
  424:     s = Series(arr)
  425:     a = s.ewm(alpha=0.61722699889169674).mean()
  426:     b = s.ewm(com=0.62014947789973052).mean()
  427:     c = s.ewm(span=2.240298955799461).mean()
  428:     d = s.ewm(halflife=0.721792864318).mean()
  429:     tm.assert_series_equal(a, b)
  430:     tm.assert_series_equal(a, c)
  431:     tm.assert_series_equal(a, d)
  432: 
  433: 
  434: def test_ewm_domain_checks():
  435:     # GH 12492
  436:     arr = np.random.default_rng(2).standard_normal(100)
  437:     locs = np.arange(20, 40)
  438:     arr[locs] = np.nan
  439: 
  440:     s = Series(arr)
  441:     msg = "comass must satisfy: comass >= 0"
  442:     with pytest.raises(ValueError, match=msg):
  443:         s.ewm(com=-0.1)
  444:     s.ewm(com=0.0)
  445:     s.ewm(com=0.1)
  446: 
  447:     msg = "span must satisfy: span >= 1"
  448:     with pytest.raises(ValueError, match=msg):
  449:         s.ewm(span=-0.1)
  450:     with pytest.raises(ValueError, match=msg):
  451:         s.ewm(span=0.0)
  452:     with pytest.raises(ValueError, match=msg):
  453:         s.ewm(span=0.9)
  454:     s.ewm(span=1.0)
  455:     s.ewm(span=1.1)
  456: 
  457:     msg = "halflife must satisfy: halflife > 0"
  458:     with pytest.raises(ValueError, match=msg):
  459:         s.ewm(halflife=-0.1)
  460:     with pytest.raises(ValueError, match=msg):
  461:         s.ewm(halflife=0.0)
  462:     s.ewm(halflife=0.1)
  463: 
  464:     msg = "alpha must satisfy: 0 < alpha <= 1"
  465:     with pytest.raises(ValueError, match=msg):
  466:         s.ewm(alpha=-0.1)
  467:     with pytest.raises(ValueError, match=msg):
  468:         s.ewm(alpha=0.0)
  469:     s.ewm(alpha=0.1)
  470:     s.ewm(alpha=1.0)
  471:     with pytest.raises(ValueError, match=msg):
  472:         s.ewm(alpha=1.1)
  473: 
  474: 
  475: @pytest.mark.parametrize("method", ["mean", "std", "var"])
  476: def test_ew_empty_series(method):
  477:     vals = Series([], dtype=np.float64)
  478: 
  479:     ewm = vals.ewm(3)
  480:     result = getattr(ewm, method)()
  481:     tm.assert_almost_equal(result, vals)
  482: 
  483: 
  484: @pytest.mark.parametrize("min_periods", [0, 1])
  485: @pytest.mark.parametrize("name", ["mean", "var", "std"])
  486: def test_ew_min_periods(min_periods, name):
  487:     # excluding NaNs correctly
  488:     arr = np.random.default_rng(2).standard_normal(50)
  489:     arr[:10] = np.nan
  490:     arr[-10:] = np.nan
  491:     s = Series(arr)
  492: 
  493:     # check min_periods
  494:     # GH 7898
  495:     result = getattr(s.ewm(com=50, min_periods=2), name)()
  496:     assert result[:11].isna().all()
  497:     assert not result[11:].isna().any()
  498: 
  499:     result = getattr(s.ewm(com=50, min_periods=min_periods), name)()
  500:     if name == "mean":
  501:         assert result[:10].isna().all()
  502:         assert not result[10:].isna().any()
  503:     else:
  504:         # ewm.std, ewm.var (with bias=False) require at least
  505:         # two values
  506:         assert result[:11].isna().all()
  507:         assert not result[11:].isna().any()
  508: 
  509:     # check series of length 0
  510:     result = getattr(Series(dtype=object).ewm(com=50, min_periods=min_periods), name)()
  511:     tm.assert_series_equal(result, Series(dtype="float64"))
  512: 
  513:     # check series of length 1
  514:     result = getattr(Series([1.0]).ewm(50, min_periods=min_periods), name)()
  515:     if name == "mean":
  516:         tm.assert_series_equal(result, Series([1.0]))
  517:     else:
  518:         # ewm.std, ewm.var with bias=False require at least
  519:         # two values
  520:         tm.assert_series_equal(result, Series([np.nan]))
  521: 
  522:     # pass in ints
  523:     result2 = getattr(Series(np.arange(50)).ewm(span=10), name)()
  524:     assert result2.dtype == np.float64
  525: 
  526: 
  527: @pytest.mark.parametrize("name", ["cov", "corr"])
  528: def test_ewm_corr_cov(name):
  529:     A = Series(np.random.default_rng(2).standard_normal(50), index=range(50))
  530:     B = A[2:] + np.random.default_rng(2).standard_normal(48)
  531: 
  532:     A[:10] = np.nan
  533:     B.iloc[-10:] = np.nan
  534: 
  535:     result = getattr(A.ewm(com=20, min_periods=5), name)(B)
  536:     assert np.isnan(result.values[:14]).all()
  537:     assert not np.isnan(result.values[14:]).any()
  538: 
  539: 
  540: @pytest.mark.parametrize("min_periods", [0, 1, 2])
  541: @pytest.mark.parametrize("name", ["cov", "corr"])
  542: def test_ewm_corr_cov_min_periods(name, min_periods):
  543:     # GH 7898
  544:     A = Series(np.random.default_rng(2).standard_normal(50), index=range(50))
  545:     B = A[2:] + np.random.default_rng(2).standard_normal(48)
  546: 
  547:     A[:10] = np.nan
  548:     B.iloc[-10:] = np.nan
  549: 
  550:     result = getattr(A.ewm(com=20, min_periods=min_periods), name)(B)
  551:     # binary functions (ewmcov, ewmcorr) with bias=False require at
  552:     # least two values
  553:     assert np.isnan(result.values[:11]).all()
  554:     assert not np.isnan(result.values[11:]).any()
  555: 
  556:     # check series of length 0
  557:     empty = Series([], dtype=np.float64)
  558:     result = getattr(empty.ewm(com=50, min_periods=min_periods), name)(empty)
  559:     tm.assert_series_equal(result, empty)
  560: 
  561:     # check series of length 1
  562:     result = getattr(Series([1.0]).ewm(com=50, min_periods=min_periods), name)(
  563:         Series([1.0])
  564:     )
  565:     tm.assert_series_equal(result, Series([np.nan]))
  566: 
  567: 
  568: @pytest.mark.parametrize("name", ["cov", "corr"])
  569: def test_different_input_array_raise_exception(name):
  570:     A = Series(np.random.default_rng(2).standard_normal(50), index=range(50))
  571:     A[:10] = np.nan
  572: 
  573:     msg = "other must be a DataFrame or Series"
  574:     # exception raised is Exception
  575:     with pytest.raises(ValueError, match=msg):
  576:         getattr(A.ewm(com=20, min_periods=5), name)(
  577:             np.random.default_rng(2).standard_normal(50)
  578:         )
  579: 
  580: 
  581: @pytest.mark.parametrize("name", ["var", "std", "mean"])
  582: def test_ewma_series(series, name):
  583:     series_result = getattr(series.ewm(com=10), name)()
  584:     assert isinstance(series_result, Series)
  585: 
  586: 
  587: @pytest.mark.parametrize("name", ["var", "std", "mean"])
  588: def test_ewma_frame(frame, name):
  589:     frame_result = getattr(frame.ewm(com=10), name)()
  590:     assert isinstance(frame_result, DataFrame)
  591: 
  592: 
  593: def test_ewma_span_com_args(series):
  594:     A = series.ewm(com=9.5).mean()
  595:     B = series.ewm(span=20).mean()
  596:     tm.assert_almost_equal(A, B)
  597:     msg = "comass, span, halflife, and alpha are mutually exclusive"
  598:     with pytest.raises(ValueError, match=msg):
  599:         series.ewm(com=9.5, span=20)
  600: 
  601:     msg = "Must pass one of comass, span, halflife, or alpha"
  602:     with pytest.raises(ValueError, match=msg):
  603:         series.ewm().mean()
  604: 
  605: 
  606: def test_ewma_halflife_arg(series):
  607:     A = series.ewm(com=13.932726172912965).mean()
  608:     B = series.ewm(halflife=10.0).mean()
  609:     tm.assert_almost_equal(A, B)
  610:     msg = "comass, span, halflife, and alpha are mutually exclusive"
  611:     with pytest.raises(ValueError, match=msg):
  612:         series.ewm(span=20, halflife=50)
  613:     with pytest.raises(ValueError, match=msg):
  614:         series.ewm(com=9.5, halflife=50)
  615:     with pytest.raises(ValueError, match=msg):
  616:         series.ewm(com=9.5, span=20, halflife=50)
  617:     msg = "Must pass one of comass, span, halflife, or alpha"
  618:     with pytest.raises(ValueError, match=msg):
  619:         series.ewm()
  620: 
  621: 
  622: def test_ewm_alpha_arg(series):
  623:     # GH 10789
  624:     s = series
  625:     msg = "Must pass one of comass, span, halflife, or alpha"
  626:     with pytest.raises(ValueError, match=msg):
  627:         s.ewm()
  628: 
  629:     msg = "comass, span, halflife, and alpha are mutually exclusive"
  630:     with pytest.raises(ValueError, match=msg):
  631:         s.ewm(com=10.0, alpha=0.5)
  632:     with pytest.raises(ValueError, match=msg):
  633:         s.ewm(span=10.0, alpha=0.5)
  634:     with pytest.raises(ValueError, match=msg):
  635:         s.ewm(halflife=10.0, alpha=0.5)
  636: 
  637: 
  638: @pytest.mark.parametrize("func", ["cov", "corr"])
  639: def test_ewm_pairwise_cov_corr(func, frame):
  640:     result = getattr(frame.ewm(span=10, min_periods=5), func)()
  641:     result = result.loc[(slice(None), 1), 5]
  642:     result.index = result.index.droplevel(1)
  643:     expected = getattr(frame[1].ewm(span=10, min_periods=5), func)(frame[5])
  644:     tm.assert_series_equal(result, expected, check_names=False)
  645: 
  646: 
  647: def test_numeric_only_frame(arithmetic_win_operators, numeric_only):
  648:     # GH#46560
  649:     kernel = arithmetic_win_operators
  650:     df = DataFrame({"a": [1], "b": 2, "c": 3})
  651:     df["c"] = df["c"].astype(object)
  652:     ewm = df.ewm(span=2, min_periods=1)
  653:     op = getattr(ewm, kernel, None)
  654:     if op is not None:
  655:         result = op(numeric_only=numeric_only)
  656: 
  657:         columns = ["a", "b"] if numeric_only else ["a", "b", "c"]
  658:         expected = df[columns].agg([kernel]).reset_index(drop=True).astype(float)
  659:         assert list(expected.columns) == columns
  660: 
  661:         tm.assert_frame_equal(result, expected)
  662: 
  663: 
  664: @pytest.mark.parametrize("kernel", ["corr", "cov"])
  665: @pytest.mark.parametrize("use_arg", [True, False])
  666: def test_numeric_only_corr_cov_frame(kernel, numeric_only, use_arg):
  667:     # GH#46560
  668:     df = DataFrame({"a": [1, 2, 3], "b": 2, "c": 3})
  669:     df["c"] = df["c"].astype(object)
  670:     arg = (df,) if use_arg else ()
  671:     ewm = df.ewm(span=2, min_periods=1)
  672:     op = getattr(ewm, kernel)
  673:     result = op(*arg, numeric_only=numeric_only)
  674: 
  675:     # Compare result to op using float dtypes, dropping c when numeric_only is True
  676:     columns = ["a", "b"] if numeric_only else ["a", "b", "c"]
  677:     df2 = df[columns].astype(float)
  678:     arg2 = (df2,) if use_arg else ()
  679:     ewm2 = df2.ewm(span=2, min_periods=1)
  680:     op2 = getattr(ewm2, kernel)
  681:     expected = op2(*arg2, numeric_only=numeric_only)
  682: 
  683:     tm.assert_frame_equal(result, expected)
  684: 
  685: 
  686: @pytest.mark.parametrize("dtype", [int, object])
  687: def test_numeric_only_series(arithmetic_win_operators, numeric_only, dtype):
  688:     # GH#46560
  689:     kernel = arithmetic_win_operators
  690:     ser = Series([1], dtype=dtype)
  691:     ewm = ser.ewm(span=2, min_periods=1)
  692:     op = getattr(ewm, kernel, None)
  693:     if op is None:
  694:         # Nothing to test
  695:         pytest.skip("No op to test")
  696:     if numeric_only and dtype is object:
  697:         msg = f"ExponentialMovingWindow.{kernel} does not implement numeric_only"
  698:         with pytest.raises(NotImplementedError, match=msg):
  699:             op(numeric_only=numeric_only)
  700:     else:
  701:         result = op(numeric_only=numeric_only)
  702:         expected = ser.agg([kernel]).reset_index(drop=True).astype(float)
  703:         tm.assert_series_equal(result, expected)
  704: 
  705: 
  706: @pytest.mark.parametrize("kernel", ["corr", "cov"])
  707: @pytest.mark.parametrize("use_arg", [True, False])
  708: @pytest.mark.parametrize("dtype", [int, object])
  709: def test_numeric_only_corr_cov_series(kernel, use_arg, numeric_only, dtype):
  710:     # GH#46560
  711:     ser = Series([1, 2, 3], dtype=dtype)
  712:     arg = (ser,) if use_arg else ()
  713:     ewm = ser.ewm(span=2, min_periods=1)
  714:     op = getattr(ewm, kernel)
  715:     if numeric_only and dtype is object:
  716:         msg = f"ExponentialMovingWindow.{kernel} does not implement numeric_only"
  717:         with pytest.raises(NotImplementedError, match=msg):
  718:             op(*arg, numeric_only=numeric_only)
  719:     else:
  720:         result = op(*arg, numeric_only=numeric_only)
  721: 
  722:         ser2 = ser.astype(float)
  723:         arg2 = (ser2,) if use_arg else ()
  724:         ewm2 = ser2.ewm(span=2, min_periods=1)
  725:         op2 = getattr(ewm2, kernel)
  726:         expected = op2(*arg2, numeric_only=numeric_only)
  727:         tm.assert_series_equal(result, expected)
