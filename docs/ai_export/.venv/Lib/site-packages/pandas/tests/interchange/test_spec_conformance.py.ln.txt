    1: """
    2: A verbatim copy (vendored) of the spec tests.
    3: Taken from https://github.com/data-apis/dataframe-api
    4: """
    5: import ctypes
    6: import math
    7: 
    8: import pytest
    9: 
   10: import pandas as pd
   11: 
   12: 
   13: @pytest.fixture
   14: def df_from_dict():
   15:     def maker(dct, is_categorical=False):
   16:         df = pd.DataFrame(dct)
   17:         return df.astype("category") if is_categorical else df
   18: 
   19:     return maker
   20: 
   21: 
   22: @pytest.mark.parametrize(
   23:     "test_data",
   24:     [
   25:         {"a": ["foo", "bar"], "b": ["baz", "qux"]},
   26:         {"a": [1.5, 2.5, 3.5], "b": [9.2, 10.5, 11.8]},
   27:         {"A": [1, 2, 3, 4], "B": [1, 2, 3, 4]},
   28:     ],
   29:     ids=["str_data", "float_data", "int_data"],
   30: )
   31: def test_only_one_dtype(test_data, df_from_dict):
   32:     columns = list(test_data.keys())
   33:     df = df_from_dict(test_data)
   34:     dfX = df.__dataframe__()
   35: 
   36:     column_size = len(test_data[columns[0]])
   37:     for column in columns:
   38:         null_count = dfX.get_column_by_name(column).null_count
   39:         assert null_count == 0
   40:         assert isinstance(null_count, int)
   41:         assert dfX.get_column_by_name(column).size() == column_size
   42:         assert dfX.get_column_by_name(column).offset == 0
   43: 
   44: 
   45: def test_mixed_dtypes(df_from_dict):
   46:     df = df_from_dict(
   47:         {
   48:             "a": [1, 2, 3],  # dtype kind INT = 0
   49:             "b": [3, 4, 5],  # dtype kind INT = 0
   50:             "c": [1.5, 2.5, 3.5],  # dtype kind FLOAT = 2
   51:             "d": [9, 10, 11],  # dtype kind INT = 0
   52:             "e": [True, False, True],  # dtype kind BOOLEAN = 20
   53:             "f": ["a", "", "c"],  # dtype kind STRING = 21
   54:         }
   55:     )
   56:     dfX = df.__dataframe__()
   57:     # for meanings of dtype[0] see the spec; we cannot import the spec here as this
   58:     # file is expected to be vendored *anywhere*;
   59:     # values for dtype[0] are explained above
   60:     columns = {"a": 0, "b": 0, "c": 2, "d": 0, "e": 20, "f": 21}
   61: 
   62:     for column, kind in columns.items():
   63:         colX = dfX.get_column_by_name(column)
   64:         assert colX.null_count == 0
   65:         assert isinstance(colX.null_count, int)
   66:         assert colX.size() == 3
   67:         assert colX.offset == 0
   68: 
   69:         assert colX.dtype[0] == kind
   70: 
   71:     assert dfX.get_column_by_name("c").dtype[1] == 64
   72: 
   73: 
   74: def test_na_float(df_from_dict):
   75:     df = df_from_dict({"a": [1.0, math.nan, 2.0]})
   76:     dfX = df.__dataframe__()
   77:     colX = dfX.get_column_by_name("a")
   78:     assert colX.null_count == 1
   79:     assert isinstance(colX.null_count, int)
   80: 
   81: 
   82: def test_noncategorical(df_from_dict):
   83:     df = df_from_dict({"a": [1, 2, 3]})
   84:     dfX = df.__dataframe__()
   85:     colX = dfX.get_column_by_name("a")
   86:     with pytest.raises(TypeError, match=".*categorical.*"):
   87:         colX.describe_categorical
   88: 
   89: 
   90: def test_categorical(df_from_dict):
   91:     df = df_from_dict(
   92:         {"weekday": ["Mon", "Tue", "Mon", "Wed", "Mon", "Thu", "Fri", "Sat", "Sun"]},
   93:         is_categorical=True,
   94:     )
   95: 
   96:     colX = df.__dataframe__().get_column_by_name("weekday")
   97:     categorical = colX.describe_categorical
   98:     assert isinstance(categorical["is_ordered"], bool)
   99:     assert isinstance(categorical["is_dictionary"], bool)
  100: 
  101: 
  102: def test_dataframe(df_from_dict):
  103:     df = df_from_dict(
  104:         {"x": [True, True, False], "y": [1, 2, 0], "z": [9.2, 10.5, 11.8]}
  105:     )
  106:     dfX = df.__dataframe__()
  107: 
  108:     assert dfX.num_columns() == 3
  109:     assert dfX.num_rows() == 3
  110:     assert dfX.num_chunks() == 1
  111:     assert list(dfX.column_names()) == ["x", "y", "z"]
  112:     assert list(dfX.select_columns((0, 2)).column_names()) == list(
  113:         dfX.select_columns_by_name(("x", "z")).column_names()
  114:     )
  115: 
  116: 
  117: @pytest.mark.parametrize(["size", "n_chunks"], [(10, 3), (12, 3), (12, 5)])
  118: def test_df_get_chunks(size, n_chunks, df_from_dict):
  119:     df = df_from_dict({"x": list(range(size))})
  120:     dfX = df.__dataframe__()
  121:     chunks = list(dfX.get_chunks(n_chunks))
  122:     assert len(chunks) == n_chunks
  123:     assert sum(chunk.num_rows() for chunk in chunks) == size
  124: 
  125: 
  126: @pytest.mark.parametrize(["size", "n_chunks"], [(10, 3), (12, 3), (12, 5)])
  127: def test_column_get_chunks(size, n_chunks, df_from_dict):
  128:     df = df_from_dict({"x": list(range(size))})
  129:     dfX = df.__dataframe__()
  130:     chunks = list(dfX.get_column(0).get_chunks(n_chunks))
  131:     assert len(chunks) == n_chunks
  132:     assert sum(chunk.size() for chunk in chunks) == size
  133: 
  134: 
  135: def test_get_columns(df_from_dict):
  136:     df = df_from_dict({"a": [0, 1], "b": [2.5, 3.5]})
  137:     dfX = df.__dataframe__()
  138:     for colX in dfX.get_columns():
  139:         assert colX.size() == 2
  140:         assert colX.num_chunks() == 1
  141:     # for meanings of dtype[0] see the spec; we cannot import the spec here as this
  142:     # file is expected to be vendored *anywhere*
  143:     assert dfX.get_column(0).dtype[0] == 0  # INT
  144:     assert dfX.get_column(1).dtype[0] == 2  # FLOAT
  145: 
  146: 
  147: def test_buffer(df_from_dict):
  148:     arr = [0, 1, -1]
  149:     df = df_from_dict({"a": arr})
  150:     dfX = df.__dataframe__()
  151:     colX = dfX.get_column(0)
  152:     bufX = colX.get_buffers()
  153: 
  154:     dataBuf, dataDtype = bufX["data"]
  155: 
  156:     assert dataBuf.bufsize > 0
  157:     assert dataBuf.ptr != 0
  158:     device, _ = dataBuf.__dlpack_device__()
  159: 
  160:     # for meanings of dtype[0] see the spec; we cannot import the spec here as this
  161:     # file is expected to be vendored *anywhere*
  162:     assert dataDtype[0] == 0  # INT
  163: 
  164:     if device == 1:  # CPU-only as we're going to directly read memory here
  165:         bitwidth = dataDtype[1]
  166:         ctype = {
  167:             8: ctypes.c_int8,
  168:             16: ctypes.c_int16,
  169:             32: ctypes.c_int32,
  170:             64: ctypes.c_int64,
  171:         }[bitwidth]
  172: 
  173:         for idx, truth in enumerate(arr):
  174:             val = ctype.from_address(dataBuf.ptr + idx * (bitwidth // 8)).value
  175:             assert val == truth, f"Buffer at index {idx} mismatch"
