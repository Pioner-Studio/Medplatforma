    1: from datetime import timedelta
    2: import re
    3: 
    4: from dateutil.tz import gettz
    5: import pytest
    6: import pytz
    7: from pytz.exceptions import (
    8:     AmbiguousTimeError,
    9:     NonExistentTimeError,
   10: )
   11: 
   12: from pandas._libs.tslibs.dtypes import NpyDatetimeUnit
   13: from pandas.errors import OutOfBoundsDatetime
   14: 
   15: from pandas import (
   16:     NaT,
   17:     Timestamp,
   18: )
   19: 
   20: try:
   21:     from zoneinfo import ZoneInfo
   22: except ImportError:
   23:     # Cannot assign to a type
   24:     ZoneInfo = None  # type: ignore[misc, assignment]
   25: 
   26: 
   27: class TestTimestampTZLocalize:
   28:     @pytest.mark.skip_ubsan
   29:     def test_tz_localize_pushes_out_of_bounds(self):
   30:         # GH#12677
   31:         # tz_localize that pushes away from the boundary is OK
   32:         msg = (
   33:             f"Converting {Timestamp.min.strftime('%Y-%m-%d %H:%M:%S')} "
   34:             f"underflows past {Timestamp.min}"
   35:         )
   36:         pac = Timestamp.min.tz_localize("US/Pacific")
   37:         assert pac._value > Timestamp.min._value
   38:         pac.tz_convert("Asia/Tokyo")  # tz_convert doesn't change value
   39:         with pytest.raises(OutOfBoundsDatetime, match=msg):
   40:             Timestamp.min.tz_localize("Asia/Tokyo")
   41: 
   42:         # tz_localize that pushes away from the boundary is OK
   43:         msg = (
   44:             f"Converting {Timestamp.max.strftime('%Y-%m-%d %H:%M:%S')} "
   45:             f"overflows past {Timestamp.max}"
   46:         )
   47:         tokyo = Timestamp.max.tz_localize("Asia/Tokyo")
   48:         assert tokyo._value < Timestamp.max._value
   49:         tokyo.tz_convert("US/Pacific")  # tz_convert doesn't change value
   50:         with pytest.raises(OutOfBoundsDatetime, match=msg):
   51:             Timestamp.max.tz_localize("US/Pacific")
   52: 
   53:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s"])
   54:     def test_tz_localize_ambiguous_bool(self, unit):
   55:         # make sure that we are correctly accepting bool values as ambiguous
   56:         # GH#14402
   57:         ts = Timestamp("2015-11-01 01:00:03").as_unit(unit)
   58:         expected0 = Timestamp("2015-11-01 01:00:03-0500", tz="US/Central")
   59:         expected1 = Timestamp("2015-11-01 01:00:03-0600", tz="US/Central")
   60: 
   61:         msg = "Cannot infer dst time from 2015-11-01 01:00:03"
   62:         with pytest.raises(pytz.AmbiguousTimeError, match=msg):
   63:             ts.tz_localize("US/Central")
   64: 
   65:         with pytest.raises(pytz.AmbiguousTimeError, match=msg):
   66:             ts.tz_localize("dateutil/US/Central")
   67: 
   68:         if ZoneInfo is not None:
   69:             try:
   70:                 tz = ZoneInfo("US/Central")
   71:             except KeyError:
   72:                 # no tzdata
   73:                 pass
   74:             else:
   75:                 with pytest.raises(pytz.AmbiguousTimeError, match=msg):
   76:                     ts.tz_localize(tz)
   77: 
   78:         result = ts.tz_localize("US/Central", ambiguous=True)
   79:         assert result == expected0
   80:         assert result._creso == getattr(NpyDatetimeUnit, f"NPY_FR_{unit}").value
   81: 
   82:         result = ts.tz_localize("US/Central", ambiguous=False)
   83:         assert result == expected1
   84:         assert result._creso == getattr(NpyDatetimeUnit, f"NPY_FR_{unit}").value
   85: 
   86:     def test_tz_localize_ambiguous(self):
   87:         ts = Timestamp("2014-11-02 01:00")
   88:         ts_dst = ts.tz_localize("US/Eastern", ambiguous=True)
   89:         ts_no_dst = ts.tz_localize("US/Eastern", ambiguous=False)
   90: 
   91:         assert ts_no_dst._value - ts_dst._value == 3600
   92:         msg = re.escape(
   93:             "'ambiguous' parameter must be one of: "
   94:             "True, False, 'NaT', 'raise' (default)"
   95:         )
   96:         with pytest.raises(ValueError, match=msg):
   97:             ts.tz_localize("US/Eastern", ambiguous="infer")
   98: 
   99:         # GH#8025
  100:         msg = "Cannot localize tz-aware Timestamp, use tz_convert for conversions"
  101:         with pytest.raises(TypeError, match=msg):
  102:             Timestamp("2011-01-01", tz="US/Eastern").tz_localize("Asia/Tokyo")
  103: 
  104:         msg = "Cannot convert tz-naive Timestamp, use tz_localize to localize"
  105:         with pytest.raises(TypeError, match=msg):
  106:             Timestamp("2011-01-01").tz_convert("Asia/Tokyo")
  107: 
  108:     @pytest.mark.parametrize(
  109:         "stamp, tz",
  110:         [
  111:             ("2015-03-08 02:00", "US/Eastern"),
  112:             ("2015-03-08 02:30", "US/Pacific"),
  113:             ("2015-03-29 02:00", "Europe/Paris"),
  114:             ("2015-03-29 02:30", "Europe/Belgrade"),
  115:         ],
  116:     )
  117:     def test_tz_localize_nonexistent(self, stamp, tz):
  118:         # GH#13057
  119:         ts = Timestamp(stamp)
  120:         with pytest.raises(NonExistentTimeError, match=stamp):
  121:             ts.tz_localize(tz)
  122:         # GH 22644
  123:         with pytest.raises(NonExistentTimeError, match=stamp):
  124:             ts.tz_localize(tz, nonexistent="raise")
  125:         assert ts.tz_localize(tz, nonexistent="NaT") is NaT
  126: 
  127:     @pytest.mark.parametrize(
  128:         "stamp, tz, forward_expected, backward_expected",
  129:         [
  130:             (
  131:                 "2015-03-29 02:00:00",
  132:                 "Europe/Warsaw",
  133:                 "2015-03-29 03:00:00",
  134:                 "2015-03-29 01:59:59",
  135:             ),  # utc+1 -> utc+2
  136:             (
  137:                 "2023-03-12 02:00:00",
  138:                 "America/Los_Angeles",
  139:                 "2023-03-12 03:00:00",
  140:                 "2023-03-12 01:59:59",
  141:             ),  # utc-8 -> utc-7
  142:             (
  143:                 "2023-03-26 01:00:00",
  144:                 "Europe/London",
  145:                 "2023-03-26 02:00:00",
  146:                 "2023-03-26 00:59:59",
  147:             ),  # utc+0 -> utc+1
  148:             (
  149:                 "2023-03-26 00:00:00",
  150:                 "Atlantic/Azores",
  151:                 "2023-03-26 01:00:00",
  152:                 "2023-03-25 23:59:59",
  153:             ),  # utc-1 -> utc+0
  154:         ],
  155:     )
  156:     def test_tz_localize_nonexistent_shift(
  157:         self, stamp, tz, forward_expected, backward_expected
  158:     ):
  159:         ts = Timestamp(stamp)
  160:         forward_ts = ts.tz_localize(tz, nonexistent="shift_forward")
  161:         assert forward_ts == Timestamp(forward_expected, tz=tz)
  162:         backward_ts = ts.tz_localize(tz, nonexistent="shift_backward")
  163:         assert backward_ts == Timestamp(backward_expected, tz=tz)
  164: 
  165:     def test_tz_localize_ambiguous_raise(self):
  166:         # GH#13057
  167:         ts = Timestamp("2015-11-1 01:00")
  168:         msg = "Cannot infer dst time from 2015-11-01 01:00:00,"
  169:         with pytest.raises(AmbiguousTimeError, match=msg):
  170:             ts.tz_localize("US/Pacific", ambiguous="raise")
  171: 
  172:     def test_tz_localize_nonexistent_invalid_arg(self, warsaw):
  173:         # GH 22644
  174:         tz = warsaw
  175:         ts = Timestamp("2015-03-29 02:00:00")
  176:         msg = (
  177:             "The nonexistent argument must be one of 'raise', 'NaT', "
  178:             "'shift_forward', 'shift_backward' or a timedelta object"
  179:         )
  180:         with pytest.raises(ValueError, match=msg):
  181:             ts.tz_localize(tz, nonexistent="foo")
  182: 
  183:     @pytest.mark.parametrize(
  184:         "stamp",
  185:         [
  186:             "2014-02-01 09:00",
  187:             "2014-07-08 09:00",
  188:             "2014-11-01 17:00",
  189:             "2014-11-05 00:00",
  190:         ],
  191:     )
  192:     def test_tz_localize_roundtrip(self, stamp, tz_aware_fixture):
  193:         tz = tz_aware_fixture
  194:         ts = Timestamp(stamp)
  195:         localized = ts.tz_localize(tz)
  196:         assert localized == Timestamp(stamp, tz=tz)
  197: 
  198:         msg = "Cannot localize tz-aware Timestamp"
  199:         with pytest.raises(TypeError, match=msg):
  200:             localized.tz_localize(tz)
  201: 
  202:         reset = localized.tz_localize(None)
  203:         assert reset == ts
  204:         assert reset.tzinfo is None
  205: 
  206:     def test_tz_localize_ambiguous_compat(self):
  207:         # validate that pytz and dateutil are compat for dst
  208:         # when the transition happens
  209:         naive = Timestamp("2013-10-27 01:00:00")
  210: 
  211:         pytz_zone = "Europe/London"
  212:         dateutil_zone = "dateutil/Europe/London"
  213:         result_pytz = naive.tz_localize(pytz_zone, ambiguous=False)
  214:         result_dateutil = naive.tz_localize(dateutil_zone, ambiguous=False)
  215:         assert result_pytz._value == result_dateutil._value
  216:         assert result_pytz._value == 1382835600
  217: 
  218:         # fixed ambiguous behavior
  219:         # see gh-14621, GH#45087
  220:         assert result_pytz.to_pydatetime().tzname() == "GMT"
  221:         assert result_dateutil.to_pydatetime().tzname() == "GMT"
  222:         assert str(result_pytz) == str(result_dateutil)
  223: 
  224:         # 1 hour difference
  225:         result_pytz = naive.tz_localize(pytz_zone, ambiguous=True)
  226:         result_dateutil = naive.tz_localize(dateutil_zone, ambiguous=True)
  227:         assert result_pytz._value == result_dateutil._value
  228:         assert result_pytz._value == 1382832000
  229: 
  230:         # see gh-14621
  231:         assert str(result_pytz) == str(result_dateutil)
  232:         assert (
  233:             result_pytz.to_pydatetime().tzname()
  234:             == result_dateutil.to_pydatetime().tzname()
  235:         )
  236: 
  237:     @pytest.mark.parametrize(
  238:         "tz",
  239:         [
  240:             pytz.timezone("US/Eastern"),
  241:             gettz("US/Eastern"),
  242:             "US/Eastern",
  243:             "dateutil/US/Eastern",
  244:         ],
  245:     )
  246:     def test_timestamp_tz_localize(self, tz):
  247:         stamp = Timestamp("3/11/2012 04:00")
  248: 
  249:         result = stamp.tz_localize(tz)
  250:         expected = Timestamp("3/11/2012 04:00", tz=tz)
  251:         assert result.hour == expected.hour
  252:         assert result == expected
  253: 
  254:     @pytest.mark.parametrize(
  255:         "start_ts, tz, end_ts, shift",
  256:         [
  257:             ["2015-03-29 02:20:00", "Europe/Warsaw", "2015-03-29 03:00:00", "forward"],
  258:             [
  259:                 "2015-03-29 02:20:00",
  260:                 "Europe/Warsaw",
  261:                 "2015-03-29 01:59:59.999999999",
  262:                 "backward",
  263:             ],
  264:             [
  265:                 "2015-03-29 02:20:00",
  266:                 "Europe/Warsaw",
  267:                 "2015-03-29 03:20:00",
  268:                 timedelta(hours=1),
  269:             ],
  270:             [
  271:                 "2015-03-29 02:20:00",
  272:                 "Europe/Warsaw",
  273:                 "2015-03-29 01:20:00",
  274:                 timedelta(hours=-1),
  275:             ],
  276:             ["2018-03-11 02:33:00", "US/Pacific", "2018-03-11 03:00:00", "forward"],
  277:             [
  278:                 "2018-03-11 02:33:00",
  279:                 "US/Pacific",
  280:                 "2018-03-11 01:59:59.999999999",
  281:                 "backward",
  282:             ],
  283:             [
  284:                 "2018-03-11 02:33:00",
  285:                 "US/Pacific",
  286:                 "2018-03-11 03:33:00",
  287:                 timedelta(hours=1),
  288:             ],
  289:             [
  290:                 "2018-03-11 02:33:00",
  291:                 "US/Pacific",
  292:                 "2018-03-11 01:33:00",
  293:                 timedelta(hours=-1),
  294:             ],
  295:         ],
  296:     )
  297:     @pytest.mark.parametrize("tz_type", ["", "dateutil/"])
  298:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s"])
  299:     def test_timestamp_tz_localize_nonexistent_shift(
  300:         self, start_ts, tz, end_ts, shift, tz_type, unit
  301:     ):
  302:         # GH 8917, 24466
  303:         tz = tz_type + tz
  304:         if isinstance(shift, str):
  305:             shift = "shift_" + shift
  306:         ts = Timestamp(start_ts).as_unit(unit)
  307:         result = ts.tz_localize(tz, nonexistent=shift)
  308:         expected = Timestamp(end_ts).tz_localize(tz)
  309: 
  310:         if unit == "us":
  311:             assert result == expected.replace(nanosecond=0)
  312:         elif unit == "ms":
  313:             micros = expected.microsecond - expected.microsecond % 1000
  314:             assert result == expected.replace(microsecond=micros, nanosecond=0)
  315:         elif unit == "s":
  316:             assert result == expected.replace(microsecond=0, nanosecond=0)
  317:         else:
  318:             assert result == expected
  319:         assert result._creso == getattr(NpyDatetimeUnit, f"NPY_FR_{unit}").value
  320: 
  321:     @pytest.mark.parametrize("offset", [-1, 1])
  322:     def test_timestamp_tz_localize_nonexistent_shift_invalid(self, offset, warsaw):
  323:         # GH 8917, 24466
  324:         tz = warsaw
  325:         ts = Timestamp("2015-03-29 02:20:00")
  326:         msg = "The provided timedelta will relocalize on a nonexistent time"
  327:         with pytest.raises(ValueError, match=msg):
  328:             ts.tz_localize(tz, nonexistent=timedelta(seconds=offset))
  329: 
  330:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s"])
  331:     def test_timestamp_tz_localize_nonexistent_NaT(self, warsaw, unit):
  332:         # GH 8917
  333:         tz = warsaw
  334:         ts = Timestamp("2015-03-29 02:20:00").as_unit(unit)
  335:         result = ts.tz_localize(tz, nonexistent="NaT")
  336:         assert result is NaT
  337: 
  338:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s"])
  339:     def test_timestamp_tz_localize_nonexistent_raise(self, warsaw, unit):
  340:         # GH 8917
  341:         tz = warsaw
  342:         ts = Timestamp("2015-03-29 02:20:00").as_unit(unit)
  343:         msg = "2015-03-29 02:20:00"
  344:         with pytest.raises(pytz.NonExistentTimeError, match=msg):
  345:             ts.tz_localize(tz, nonexistent="raise")
  346:         msg = (
  347:             "The nonexistent argument must be one of 'raise', 'NaT', "
  348:             "'shift_forward', 'shift_backward' or a timedelta object"
  349:         )
  350:         with pytest.raises(ValueError, match=msg):
  351:             ts.tz_localize(tz, nonexistent="foo")
