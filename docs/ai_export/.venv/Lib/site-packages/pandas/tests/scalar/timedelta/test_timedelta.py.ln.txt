    1: """ test the scalar Timedelta """
    2: from datetime import timedelta
    3: import sys
    4: 
    5: from hypothesis import (
    6:     given,
    7:     strategies as st,
    8: )
    9: import numpy as np
   10: import pytest
   11: 
   12: from pandas._libs import lib
   13: from pandas._libs.tslibs import (
   14:     NaT,
   15:     iNaT,
   16: )
   17: from pandas._libs.tslibs.dtypes import NpyDatetimeUnit
   18: from pandas.errors import OutOfBoundsTimedelta
   19: 
   20: from pandas import (
   21:     Timedelta,
   22:     to_timedelta,
   23: )
   24: import pandas._testing as tm
   25: 
   26: 
   27: class TestNonNano:
   28:     @pytest.fixture(params=["s", "ms", "us"])
   29:     def unit_str(self, request):
   30:         return request.param
   31: 
   32:     @pytest.fixture
   33:     def unit(self, unit_str):
   34:         # 7, 8, 9 correspond to second, millisecond, and microsecond, respectively
   35:         attr = f"NPY_FR_{unit_str}"
   36:         return getattr(NpyDatetimeUnit, attr).value
   37: 
   38:     @pytest.fixture
   39:     def val(self, unit):
   40:         # microsecond that would be just out of bounds for nano
   41:         us = 9223372800000000
   42:         if unit == NpyDatetimeUnit.NPY_FR_us.value:
   43:             value = us
   44:         elif unit == NpyDatetimeUnit.NPY_FR_ms.value:
   45:             value = us // 1000
   46:         else:
   47:             value = us // 1_000_000
   48:         return value
   49: 
   50:     @pytest.fixture
   51:     def td(self, unit, val):
   52:         return Timedelta._from_value_and_reso(val, unit)
   53: 
   54:     def test_from_value_and_reso(self, unit, val):
   55:         # Just checking that the fixture is giving us what we asked for
   56:         td = Timedelta._from_value_and_reso(val, unit)
   57:         assert td._value == val
   58:         assert td._creso == unit
   59:         assert td.days == 106752
   60: 
   61:     def test_unary_non_nano(self, td, unit):
   62:         assert abs(td)._creso == unit
   63:         assert (-td)._creso == unit
   64:         assert (+td)._creso == unit
   65: 
   66:     def test_sub_preserves_reso(self, td, unit):
   67:         res = td - td
   68:         expected = Timedelta._from_value_and_reso(0, unit)
   69:         assert res == expected
   70:         assert res._creso == unit
   71: 
   72:     def test_mul_preserves_reso(self, td, unit):
   73:         # The td fixture should always be far from the implementation
   74:         #  bound, so doubling does not risk overflow.
   75:         res = td * 2
   76:         assert res._value == td._value * 2
   77:         assert res._creso == unit
   78: 
   79:     def test_cmp_cross_reso(self, td):
   80:         # numpy gets this wrong because of silent overflow
   81:         other = Timedelta(days=106751, unit="ns")
   82:         assert other < td
   83:         assert td > other
   84:         assert not other == td
   85:         assert td != other
   86: 
   87:     def test_to_pytimedelta(self, td):
   88:         res = td.to_pytimedelta()
   89:         expected = timedelta(days=106752)
   90:         assert type(res) is timedelta
   91:         assert res == expected
   92: 
   93:     def test_to_timedelta64(self, td, unit):
   94:         for res in [td.to_timedelta64(), td.to_numpy(), td.asm8]:
   95:             assert isinstance(res, np.timedelta64)
   96:             assert res.view("i8") == td._value
   97:             if unit == NpyDatetimeUnit.NPY_FR_s.value:
   98:                 assert res.dtype == "m8[s]"
   99:             elif unit == NpyDatetimeUnit.NPY_FR_ms.value:
  100:                 assert res.dtype == "m8[ms]"
  101:             elif unit == NpyDatetimeUnit.NPY_FR_us.value:
  102:                 assert res.dtype == "m8[us]"
  103: 
  104:     def test_truediv_timedeltalike(self, td):
  105:         assert td / td == 1
  106:         assert (2.5 * td) / td == 2.5
  107: 
  108:         other = Timedelta(td._value)
  109:         msg = "Cannot cast 106752 days 00:00:00 to unit='ns' without overflow."
  110:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
  111:             td / other
  112: 
  113:         # Timedelta(other.to_pytimedelta()) has microsecond resolution,
  114:         #  so the division doesn't require casting all the way to nanos,
  115:         #  so succeeds
  116:         res = other.to_pytimedelta() / td
  117:         expected = other.to_pytimedelta() / td.to_pytimedelta()
  118:         assert res == expected
  119: 
  120:         # if there's no overflow, we cast to the higher reso
  121:         left = Timedelta._from_value_and_reso(50, NpyDatetimeUnit.NPY_FR_us.value)
  122:         right = Timedelta._from_value_and_reso(50, NpyDatetimeUnit.NPY_FR_ms.value)
  123:         result = left / right
  124:         assert result == 0.001
  125: 
  126:         result = right / left
  127:         assert result == 1000
  128: 
  129:     def test_truediv_numeric(self, td):
  130:         assert td / np.nan is NaT
  131: 
  132:         res = td / 2
  133:         assert res._value == td._value / 2
  134:         assert res._creso == td._creso
  135: 
  136:         res = td / 2.0
  137:         assert res._value == td._value / 2
  138:         assert res._creso == td._creso
  139: 
  140:     def test_floordiv_timedeltalike(self, td):
  141:         assert td // td == 1
  142:         assert (2.5 * td) // td == 2
  143: 
  144:         other = Timedelta(td._value)
  145:         msg = "Cannot cast 106752 days 00:00:00 to unit='ns' without overflow"
  146:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
  147:             td // other
  148: 
  149:         # Timedelta(other.to_pytimedelta()) has microsecond resolution,
  150:         #  so the floordiv doesn't require casting all the way to nanos,
  151:         #  so succeeds
  152:         res = other.to_pytimedelta() // td
  153:         assert res == 0
  154: 
  155:         # if there's no overflow, we cast to the higher reso
  156:         left = Timedelta._from_value_and_reso(50050, NpyDatetimeUnit.NPY_FR_us.value)
  157:         right = Timedelta._from_value_and_reso(50, NpyDatetimeUnit.NPY_FR_ms.value)
  158:         result = left // right
  159:         assert result == 1
  160:         result = right // left
  161:         assert result == 0
  162: 
  163:     def test_floordiv_numeric(self, td):
  164:         assert td // np.nan is NaT
  165: 
  166:         res = td // 2
  167:         assert res._value == td._value // 2
  168:         assert res._creso == td._creso
  169: 
  170:         res = td // 2.0
  171:         assert res._value == td._value // 2
  172:         assert res._creso == td._creso
  173: 
  174:         assert td // np.array(np.nan) is NaT
  175: 
  176:         res = td // np.array(2)
  177:         assert res._value == td._value // 2
  178:         assert res._creso == td._creso
  179: 
  180:         res = td // np.array(2.0)
  181:         assert res._value == td._value // 2
  182:         assert res._creso == td._creso
  183: 
  184:     def test_addsub_mismatched_reso(self, td):
  185:         # need to cast to since td is out of bounds for ns, so
  186:         #  so we would raise OverflowError without casting
  187:         other = Timedelta(days=1).as_unit("us")
  188: 
  189:         # td is out of bounds for ns
  190:         result = td + other
  191:         assert result._creso == other._creso
  192:         assert result.days == td.days + 1
  193: 
  194:         result = other + td
  195:         assert result._creso == other._creso
  196:         assert result.days == td.days + 1
  197: 
  198:         result = td - other
  199:         assert result._creso == other._creso
  200:         assert result.days == td.days - 1
  201: 
  202:         result = other - td
  203:         assert result._creso == other._creso
  204:         assert result.days == 1 - td.days
  205: 
  206:         other2 = Timedelta(500)
  207:         msg = "Cannot cast 106752 days 00:00:00 to unit='ns' without overflow"
  208:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
  209:             td + other2
  210:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
  211:             other2 + td
  212:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
  213:             td - other2
  214:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
  215:             other2 - td
  216: 
  217:     def test_min(self, td):
  218:         assert td.min <= td
  219:         assert td.min._creso == td._creso
  220:         assert td.min._value == NaT._value + 1
  221: 
  222:     def test_max(self, td):
  223:         assert td.max >= td
  224:         assert td.max._creso == td._creso
  225:         assert td.max._value == np.iinfo(np.int64).max
  226: 
  227:     def test_resolution(self, td):
  228:         expected = Timedelta._from_value_and_reso(1, td._creso)
  229:         result = td.resolution
  230:         assert result == expected
  231:         assert result._creso == expected._creso
  232: 
  233:     def test_hash(self) -> None:
  234:         # GH#54037
  235:         second_resolution_max = Timedelta(0).as_unit("s").max
  236: 
  237:         assert hash(second_resolution_max)
  238: 
  239: 
  240: def test_timedelta_class_min_max_resolution():
  241:     # when accessed on the class (as opposed to an instance), we default
  242:     #  to nanoseconds
  243:     assert Timedelta.min == Timedelta(NaT._value + 1)
  244:     assert Timedelta.min._creso == NpyDatetimeUnit.NPY_FR_ns.value
  245: 
  246:     assert Timedelta.max == Timedelta(np.iinfo(np.int64).max)
  247:     assert Timedelta.max._creso == NpyDatetimeUnit.NPY_FR_ns.value
  248: 
  249:     assert Timedelta.resolution == Timedelta(1)
  250:     assert Timedelta.resolution._creso == NpyDatetimeUnit.NPY_FR_ns.value
  251: 
  252: 
  253: class TestTimedeltaUnaryOps:
  254:     def test_invert(self):
  255:         td = Timedelta(10, unit="d")
  256: 
  257:         msg = "bad operand type for unary ~"
  258:         with pytest.raises(TypeError, match=msg):
  259:             ~td
  260: 
  261:         # check this matches pytimedelta and timedelta64
  262:         with pytest.raises(TypeError, match=msg):
  263:             ~(td.to_pytimedelta())
  264: 
  265:         umsg = "ufunc 'invert' not supported for the input types"
  266:         with pytest.raises(TypeError, match=umsg):
  267:             ~(td.to_timedelta64())
  268: 
  269:     def test_unary_ops(self):
  270:         td = Timedelta(10, unit="d")
  271: 
  272:         # __neg__, __pos__
  273:         assert -td == Timedelta(-10, unit="d")
  274:         assert -td == Timedelta("-10d")
  275:         assert +td == Timedelta(10, unit="d")
  276: 
  277:         # __abs__, __abs__(__neg__)
  278:         assert abs(td) == td
  279:         assert abs(-td) == td
  280:         assert abs(-td) == Timedelta("10d")
  281: 
  282: 
  283: class TestTimedeltas:
  284:     @pytest.mark.parametrize(
  285:         "unit, value, expected",
  286:         [
  287:             ("us", 9.999, 9999),
  288:             ("ms", 9.999999, 9999999),
  289:             ("s", 9.999999999, 9999999999),
  290:         ],
  291:     )
  292:     def test_rounding_on_int_unit_construction(self, unit, value, expected):
  293:         # GH 12690
  294:         result = Timedelta(value, unit=unit)
  295:         assert result._value == expected
  296:         result = Timedelta(str(value) + unit)
  297:         assert result._value == expected
  298: 
  299:     def test_total_seconds_scalar(self):
  300:         # see gh-10939
  301:         rng = Timedelta("1 days, 10:11:12.100123456")
  302:         expt = 1 * 86400 + 10 * 3600 + 11 * 60 + 12 + 100123456.0 / 1e9
  303:         tm.assert_almost_equal(rng.total_seconds(), expt)
  304: 
  305:         rng = Timedelta(np.nan)
  306:         assert np.isnan(rng.total_seconds())
  307: 
  308:     def test_conversion(self):
  309:         for td in [Timedelta(10, unit="d"), Timedelta("1 days, 10:11:12.012345")]:
  310:             pydt = td.to_pytimedelta()
  311:             assert td == Timedelta(pydt)
  312:             assert td == pydt
  313:             assert isinstance(pydt, timedelta) and not isinstance(pydt, Timedelta)
  314: 
  315:             assert td == np.timedelta64(td._value, "ns")
  316:             td64 = td.to_timedelta64()
  317: 
  318:             assert td64 == np.timedelta64(td._value, "ns")
  319:             assert td == td64
  320: 
  321:             assert isinstance(td64, np.timedelta64)
  322: 
  323:         # this is NOT equal and cannot be roundtripped (because of the nanos)
  324:         td = Timedelta("1 days, 10:11:12.012345678")
  325:         assert td != td.to_pytimedelta()
  326: 
  327:     def test_fields(self):
  328:         def check(value):
  329:             # that we are int
  330:             assert isinstance(value, int)
  331: 
  332:         # compat to datetime.timedelta
  333:         rng = to_timedelta("1 days, 10:11:12")
  334:         assert rng.days == 1
  335:         assert rng.seconds == 10 * 3600 + 11 * 60 + 12
  336:         assert rng.microseconds == 0
  337:         assert rng.nanoseconds == 0
  338: 
  339:         msg = "'Timedelta' object has no attribute '{}'"
  340:         with pytest.raises(AttributeError, match=msg.format("hours")):
  341:             rng.hours
  342:         with pytest.raises(AttributeError, match=msg.format("minutes")):
  343:             rng.minutes
  344:         with pytest.raises(AttributeError, match=msg.format("milliseconds")):
  345:             rng.milliseconds
  346: 
  347:         # GH 10050
  348:         check(rng.days)
  349:         check(rng.seconds)
  350:         check(rng.microseconds)
  351:         check(rng.nanoseconds)
  352: 
  353:         td = Timedelta("-1 days, 10:11:12")
  354:         assert abs(td) == Timedelta("13:48:48")
  355:         assert str(td) == "-1 days +10:11:12"
  356:         assert -td == Timedelta("0 days 13:48:48")
  357:         assert -Timedelta("-1 days, 10:11:12")._value == 49728000000000
  358:         assert Timedelta("-1 days, 10:11:12")._value == -49728000000000
  359: 
  360:         rng = to_timedelta("-1 days, 10:11:12.100123456")
  361:         assert rng.days == -1
  362:         assert rng.seconds == 10 * 3600 + 11 * 60 + 12
  363:         assert rng.microseconds == 100 * 1000 + 123
  364:         assert rng.nanoseconds == 456
  365:         msg = "'Timedelta' object has no attribute '{}'"
  366:         with pytest.raises(AttributeError, match=msg.format("hours")):
  367:             rng.hours
  368:         with pytest.raises(AttributeError, match=msg.format("minutes")):
  369:             rng.minutes
  370:         with pytest.raises(AttributeError, match=msg.format("milliseconds")):
  371:             rng.milliseconds
  372: 
  373:         # components
  374:         tup = to_timedelta(-1, "us").components
  375:         assert tup.days == -1
  376:         assert tup.hours == 23
  377:         assert tup.minutes == 59
  378:         assert tup.seconds == 59
  379:         assert tup.milliseconds == 999
  380:         assert tup.microseconds == 999
  381:         assert tup.nanoseconds == 0
  382: 
  383:         # GH 10050
  384:         check(tup.days)
  385:         check(tup.hours)
  386:         check(tup.minutes)
  387:         check(tup.seconds)
  388:         check(tup.milliseconds)
  389:         check(tup.microseconds)
  390:         check(tup.nanoseconds)
  391: 
  392:         tup = Timedelta("-1 days 1 us").components
  393:         assert tup.days == -2
  394:         assert tup.hours == 23
  395:         assert tup.minutes == 59
  396:         assert tup.seconds == 59
  397:         assert tup.milliseconds == 999
  398:         assert tup.microseconds == 999
  399:         assert tup.nanoseconds == 0
  400: 
  401:     # TODO: this is a test of to_timedelta string parsing
  402:     def test_iso_conversion(self):
  403:         # GH #21877
  404:         expected = Timedelta(1, unit="s")
  405:         assert to_timedelta("P0DT0H0M1S") == expected
  406: 
  407:     # TODO: this is a test of to_timedelta returning NaT
  408:     def test_nat_converters(self):
  409:         result = to_timedelta("nat").to_numpy()
  410:         assert result.dtype.kind == "M"
  411:         assert result.astype("int64") == iNaT
  412: 
  413:         result = to_timedelta("nan").to_numpy()
  414:         assert result.dtype.kind == "M"
  415:         assert result.astype("int64") == iNaT
  416: 
  417:     def test_numeric_conversions(self):
  418:         assert Timedelta(0) == np.timedelta64(0, "ns")
  419:         assert Timedelta(10) == np.timedelta64(10, "ns")
  420:         assert Timedelta(10, unit="ns") == np.timedelta64(10, "ns")
  421: 
  422:         assert Timedelta(10, unit="us") == np.timedelta64(10, "us")
  423:         assert Timedelta(10, unit="ms") == np.timedelta64(10, "ms")
  424:         assert Timedelta(10, unit="s") == np.timedelta64(10, "s")
  425:         assert Timedelta(10, unit="d") == np.timedelta64(10, "D")
  426: 
  427:     def test_timedelta_conversions(self):
  428:         assert Timedelta(timedelta(seconds=1)) == np.timedelta64(1, "s").astype(
  429:             "m8[ns]"
  430:         )
  431:         assert Timedelta(timedelta(microseconds=1)) == np.timedelta64(1, "us").astype(
  432:             "m8[ns]"
  433:         )
  434:         assert Timedelta(timedelta(days=1)) == np.timedelta64(1, "D").astype("m8[ns]")
  435: 
  436:     def test_to_numpy_alias(self):
  437:         # GH 24653: alias .to_numpy() for scalars
  438:         td = Timedelta("10m7s")
  439:         assert td.to_timedelta64() == td.to_numpy()
  440: 
  441:         # GH#44460
  442:         msg = "dtype and copy arguments are ignored"
  443:         with pytest.raises(ValueError, match=msg):
  444:             td.to_numpy("m8[s]")
  445:         with pytest.raises(ValueError, match=msg):
  446:             td.to_numpy(copy=True)
  447: 
  448:     def test_identity(self):
  449:         td = Timedelta(10, unit="d")
  450:         assert isinstance(td, Timedelta)
  451:         assert isinstance(td, timedelta)
  452: 
  453:     def test_short_format_converters(self):
  454:         def conv(v):
  455:             return v.astype("m8[ns]")
  456: 
  457:         assert Timedelta("10") == np.timedelta64(10, "ns")
  458:         assert Timedelta("10ns") == np.timedelta64(10, "ns")
  459:         assert Timedelta("100") == np.timedelta64(100, "ns")
  460:         assert Timedelta("100ns") == np.timedelta64(100, "ns")
  461: 
  462:         assert Timedelta("1000") == np.timedelta64(1000, "ns")
  463:         assert Timedelta("1000ns") == np.timedelta64(1000, "ns")
  464:         assert Timedelta("1000NS") == np.timedelta64(1000, "ns")
  465: 
  466:         assert Timedelta("10us") == np.timedelta64(10000, "ns")
  467:         assert Timedelta("100us") == np.timedelta64(100000, "ns")
  468:         assert Timedelta("1000us") == np.timedelta64(1000000, "ns")
  469:         assert Timedelta("1000Us") == np.timedelta64(1000000, "ns")
  470:         assert Timedelta("1000uS") == np.timedelta64(1000000, "ns")
  471: 
  472:         assert Timedelta("1ms") == np.timedelta64(1000000, "ns")
  473:         assert Timedelta("10ms") == np.timedelta64(10000000, "ns")
  474:         assert Timedelta("100ms") == np.timedelta64(100000000, "ns")
  475:         assert Timedelta("1000ms") == np.timedelta64(1000000000, "ns")
  476: 
  477:         assert Timedelta("-1s") == -np.timedelta64(1000000000, "ns")
  478:         assert Timedelta("1s") == np.timedelta64(1000000000, "ns")
  479:         assert Timedelta("10s") == np.timedelta64(10000000000, "ns")
  480:         assert Timedelta("100s") == np.timedelta64(100000000000, "ns")
  481:         assert Timedelta("1000s") == np.timedelta64(1000000000000, "ns")
  482: 
  483:         assert Timedelta("1d") == conv(np.timedelta64(1, "D"))
  484:         assert Timedelta("-1d") == -conv(np.timedelta64(1, "D"))
  485:         assert Timedelta("1D") == conv(np.timedelta64(1, "D"))
  486:         assert Timedelta("10D") == conv(np.timedelta64(10, "D"))
  487:         assert Timedelta("100D") == conv(np.timedelta64(100, "D"))
  488:         assert Timedelta("1000D") == conv(np.timedelta64(1000, "D"))
  489:         assert Timedelta("10000D") == conv(np.timedelta64(10000, "D"))
  490: 
  491:         # space
  492:         assert Timedelta(" 10000D ") == conv(np.timedelta64(10000, "D"))
  493:         assert Timedelta(" - 10000D ") == -conv(np.timedelta64(10000, "D"))
  494: 
  495:         # invalid
  496:         msg = "invalid unit abbreviation"
  497:         with pytest.raises(ValueError, match=msg):
  498:             Timedelta("1foo")
  499:         msg = "unit abbreviation w/o a number"
  500:         with pytest.raises(ValueError, match=msg):
  501:             Timedelta("foo")
  502: 
  503:     def test_full_format_converters(self):
  504:         def conv(v):
  505:             return v.astype("m8[ns]")
  506: 
  507:         d1 = np.timedelta64(1, "D")
  508: 
  509:         assert Timedelta("1days") == conv(d1)
  510:         assert Timedelta("1days,") == conv(d1)
  511:         assert Timedelta("- 1days,") == -conv(d1)
  512: 
  513:         assert Timedelta("00:00:01") == conv(np.timedelta64(1, "s"))
  514:         assert Timedelta("06:00:01") == conv(np.timedelta64(6 * 3600 + 1, "s"))
  515:         assert Timedelta("06:00:01.0") == conv(np.timedelta64(6 * 3600 + 1, "s"))
  516:         assert Timedelta("06:00:01.01") == conv(
  517:             np.timedelta64(1000 * (6 * 3600 + 1) + 10, "ms")
  518:         )
  519: 
  520:         assert Timedelta("- 1days, 00:00:01") == conv(-d1 + np.timedelta64(1, "s"))
  521:         assert Timedelta("1days, 06:00:01") == conv(
  522:             d1 + np.timedelta64(6 * 3600 + 1, "s")
  523:         )
  524:         assert Timedelta("1days, 06:00:01.01") == conv(
  525:             d1 + np.timedelta64(1000 * (6 * 3600 + 1) + 10, "ms")
  526:         )
  527: 
  528:         # invalid
  529:         msg = "have leftover units"
  530:         with pytest.raises(ValueError, match=msg):
  531:             Timedelta("- 1days, 00")
  532: 
  533:     def test_pickle(self):
  534:         v = Timedelta("1 days 10:11:12.0123456")
  535:         v_p = tm.round_trip_pickle(v)
  536:         assert v == v_p
  537: 
  538:     def test_timedelta_hash_equality(self):
  539:         # GH 11129
  540:         v = Timedelta(1, "D")
  541:         td = timedelta(days=1)
  542:         assert hash(v) == hash(td)
  543: 
  544:         d = {td: 2}
  545:         assert d[v] == 2
  546: 
  547:         tds = [Timedelta(seconds=1) + Timedelta(days=n) for n in range(20)]
  548:         assert all(hash(td) == hash(td.to_pytimedelta()) for td in tds)
  549: 
  550:         # python timedeltas drop ns resolution
  551:         ns_td = Timedelta(1, "ns")
  552:         assert hash(ns_td) != hash(ns_td.to_pytimedelta())
  553: 
  554:     @pytest.mark.skip_ubsan
  555:     @pytest.mark.xfail(
  556:         reason="pd.Timedelta violates the Python hash invariant (GH#44504).",
  557:     )
  558:     @given(
  559:         st.integers(
  560:             min_value=(-sys.maxsize - 1) // 500,
  561:             max_value=sys.maxsize // 500,
  562:         )
  563:     )
  564:     def test_hash_equality_invariance(self, half_microseconds: int) -> None:
  565:         # GH#44504
  566: 
  567:         nanoseconds = half_microseconds * 500
  568: 
  569:         pandas_timedelta = Timedelta(nanoseconds)
  570:         numpy_timedelta = np.timedelta64(nanoseconds)
  571: 
  572:         # See: https://docs.python.org/3/glossary.html#term-hashable
  573:         # Hashable objects which compare equal must have the same hash value.
  574:         assert pandas_timedelta != numpy_timedelta or hash(pandas_timedelta) == hash(
  575:             numpy_timedelta
  576:         )
  577: 
  578:     def test_implementation_limits(self):
  579:         min_td = Timedelta(Timedelta.min)
  580:         max_td = Timedelta(Timedelta.max)
  581: 
  582:         # GH 12727
  583:         # timedelta limits correspond to int64 boundaries
  584:         assert min_td._value == iNaT + 1
  585:         assert max_td._value == lib.i8max
  586: 
  587:         # Beyond lower limit, a NAT before the Overflow
  588:         assert (min_td - Timedelta(1, "ns")) is NaT
  589: 
  590:         msg = "int too (large|big) to convert"
  591:         with pytest.raises(OverflowError, match=msg):
  592:             min_td - Timedelta(2, "ns")
  593: 
  594:         with pytest.raises(OverflowError, match=msg):
  595:             max_td + Timedelta(1, "ns")
  596: 
  597:         # Same tests using the internal nanosecond values
  598:         td = Timedelta(min_td._value - 1, "ns")
  599:         assert td is NaT
  600: 
  601:         msg = "Cannot cast -9223372036854775809 from ns to 'ns' without overflow"
  602:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
  603:             Timedelta(min_td._value - 2, "ns")
  604: 
  605:         msg = "Cannot cast 9223372036854775808 from ns to 'ns' without overflow"
  606:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
  607:             Timedelta(max_td._value + 1, "ns")
  608: 
  609:     def test_total_seconds_precision(self):
  610:         # GH 19458
  611:         assert Timedelta("30s").total_seconds() == 30.0
  612:         assert Timedelta("0").total_seconds() == 0.0
  613:         assert Timedelta("-2s").total_seconds() == -2.0
  614:         assert Timedelta("5.324s").total_seconds() == 5.324
  615:         assert (Timedelta("30s").total_seconds() - 30.0) < 1e-20
  616:         assert (30.0 - Timedelta("30s").total_seconds()) < 1e-20
  617: 
  618:     def test_resolution_string(self):
  619:         assert Timedelta(days=1).resolution_string == "D"
  620:         assert Timedelta(days=1, hours=6).resolution_string == "h"
  621:         assert Timedelta(days=1, minutes=6).resolution_string == "min"
  622:         assert Timedelta(days=1, seconds=6).resolution_string == "s"
  623:         assert Timedelta(days=1, milliseconds=6).resolution_string == "ms"
  624:         assert Timedelta(days=1, microseconds=6).resolution_string == "us"
  625:         assert Timedelta(days=1, nanoseconds=6).resolution_string == "ns"
  626: 
  627:     def test_resolution_deprecated(self):
  628:         # GH#21344
  629:         td = Timedelta(days=4, hours=3)
  630:         result = td.resolution
  631:         assert result == Timedelta(nanoseconds=1)
  632: 
  633:         # Check that the attribute is available on the class, mirroring
  634:         #  the stdlib timedelta behavior
  635:         result = Timedelta.resolution
  636:         assert result == Timedelta(nanoseconds=1)
  637: 
  638: 
  639: @pytest.mark.parametrize(
  640:     "value, expected",
  641:     [
  642:         (Timedelta("10s"), True),
  643:         (Timedelta("-10s"), True),
  644:         (Timedelta(10, unit="ns"), True),
  645:         (Timedelta(0, unit="ns"), False),
  646:         (Timedelta(-10, unit="ns"), True),
  647:         (Timedelta(None), True),
  648:         (NaT, True),
  649:     ],
  650: )
  651: def test_truthiness(value, expected):
  652:     # https://github.com/pandas-dev/pandas/issues/21484
  653:     assert bool(value) is expected
  654: 
  655: 
  656: def test_timedelta_attribute_precision():
  657:     # GH 31354
  658:     td = Timedelta(1552211999999999872, unit="ns")
  659:     result = td.days * 86400
  660:     result += td.seconds
  661:     result *= 1000000
  662:     result += td.microseconds
  663:     result *= 1000
  664:     result += td.nanoseconds
  665:     expected = td._value
  666:     assert result == expected
