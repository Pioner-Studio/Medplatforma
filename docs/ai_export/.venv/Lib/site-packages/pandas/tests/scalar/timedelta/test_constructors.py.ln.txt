    1: from datetime import timedelta
    2: from itertools import product
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas._libs.tslibs import OutOfBoundsTimedelta
    8: from pandas._libs.tslibs.dtypes import NpyDatetimeUnit
    9: 
   10: from pandas import (
   11:     Index,
   12:     NaT,
   13:     Timedelta,
   14:     TimedeltaIndex,
   15:     offsets,
   16:     to_timedelta,
   17: )
   18: import pandas._testing as tm
   19: 
   20: 
   21: class TestTimedeltaConstructorUnitKeyword:
   22:     @pytest.mark.parametrize("unit", ["Y", "y", "M"])
   23:     def test_unit_m_y_raises(self, unit):
   24:         msg = "Units 'M', 'Y', and 'y' are no longer supported"
   25: 
   26:         with pytest.raises(ValueError, match=msg):
   27:             Timedelta(10, unit)
   28: 
   29:         with pytest.raises(ValueError, match=msg):
   30:             to_timedelta(10, unit)
   31: 
   32:         with pytest.raises(ValueError, match=msg):
   33:             to_timedelta([1, 2], unit)
   34: 
   35:     @pytest.mark.parametrize(
   36:         "unit,unit_depr",
   37:         [
   38:             ("h", "H"),
   39:             ("min", "T"),
   40:             ("s", "S"),
   41:             ("ms", "L"),
   42:             ("ns", "N"),
   43:             ("us", "U"),
   44:         ],
   45:     )
   46:     def test_units_H_T_S_L_N_U_deprecated(self, unit, unit_depr):
   47:         # GH#52536
   48:         msg = f"'{unit_depr}' is deprecated and will be removed in a future version."
   49: 
   50:         expected = Timedelta(1, unit=unit)
   51:         with tm.assert_produces_warning(FutureWarning, match=msg):
   52:             result = Timedelta(1, unit=unit_depr)
   53:         tm.assert_equal(result, expected)
   54: 
   55:     @pytest.mark.parametrize(
   56:         "unit, np_unit",
   57:         [(value, "W") for value in ["W", "w"]]
   58:         + [(value, "D") for value in ["D", "d", "days", "day", "Days", "Day"]]
   59:         + [
   60:             (value, "m")
   61:             for value in [
   62:                 "m",
   63:                 "minute",
   64:                 "min",
   65:                 "minutes",
   66:                 "Minute",
   67:                 "Min",
   68:                 "Minutes",
   69:             ]
   70:         ]
   71:         + [
   72:             (value, "s")
   73:             for value in [
   74:                 "s",
   75:                 "seconds",
   76:                 "sec",
   77:                 "second",
   78:                 "Seconds",
   79:                 "Sec",
   80:                 "Second",
   81:             ]
   82:         ]
   83:         + [
   84:             (value, "ms")
   85:             for value in [
   86:                 "ms",
   87:                 "milliseconds",
   88:                 "millisecond",
   89:                 "milli",
   90:                 "millis",
   91:                 "MS",
   92:                 "Milliseconds",
   93:                 "Millisecond",
   94:                 "Milli",
   95:                 "Millis",
   96:             ]
   97:         ]
   98:         + [
   99:             (value, "us")
  100:             for value in [
  101:                 "us",
  102:                 "microseconds",
  103:                 "microsecond",
  104:                 "micro",
  105:                 "micros",
  106:                 "u",
  107:                 "US",
  108:                 "Microseconds",
  109:                 "Microsecond",
  110:                 "Micro",
  111:                 "Micros",
  112:                 "U",
  113:             ]
  114:         ]
  115:         + [
  116:             (value, "ns")
  117:             for value in [
  118:                 "ns",
  119:                 "nanoseconds",
  120:                 "nanosecond",
  121:                 "nano",
  122:                 "nanos",
  123:                 "n",
  124:                 "NS",
  125:                 "Nanoseconds",
  126:                 "Nanosecond",
  127:                 "Nano",
  128:                 "Nanos",
  129:                 "N",
  130:             ]
  131:         ],
  132:     )
  133:     @pytest.mark.parametrize("wrapper", [np.array, list, Index])
  134:     def test_unit_parser(self, unit, np_unit, wrapper):
  135:         # validate all units, GH 6855, GH 21762
  136:         # array-likes
  137:         expected = TimedeltaIndex(
  138:             [np.timedelta64(i, np_unit) for i in np.arange(5).tolist()],
  139:             dtype="m8[ns]",
  140:         )
  141:         # TODO(2.0): the desired output dtype may have non-nano resolution
  142:         msg = f"'{unit}' is deprecated and will be removed in a future version."
  143: 
  144:         if (unit, np_unit) in (("u", "us"), ("U", "us"), ("n", "ns"), ("N", "ns")):
  145:             warn = FutureWarning
  146:         else:
  147:             warn = FutureWarning
  148:             msg = "The 'unit' keyword in TimedeltaIndex construction is deprecated"
  149:         with tm.assert_produces_warning(warn, match=msg):
  150:             result = to_timedelta(wrapper(range(5)), unit=unit)
  151:             tm.assert_index_equal(result, expected)
  152:             result = TimedeltaIndex(wrapper(range(5)), unit=unit)
  153:             tm.assert_index_equal(result, expected)
  154: 
  155:             str_repr = [f"{x}{unit}" for x in np.arange(5)]
  156:             result = to_timedelta(wrapper(str_repr))
  157:             tm.assert_index_equal(result, expected)
  158:             result = to_timedelta(wrapper(str_repr))
  159:             tm.assert_index_equal(result, expected)
  160: 
  161:             # scalar
  162:             expected = Timedelta(np.timedelta64(2, np_unit).astype("timedelta64[ns]"))
  163:             result = to_timedelta(2, unit=unit)
  164:             assert result == expected
  165:             result = Timedelta(2, unit=unit)
  166:             assert result == expected
  167: 
  168:             result = to_timedelta(f"2{unit}")
  169:             assert result == expected
  170:             result = Timedelta(f"2{unit}")
  171:             assert result == expected
  172: 
  173: 
  174: def test_construct_from_kwargs_overflow():
  175:     # GH#55503
  176:     msg = "seconds=86400000000000000000, milliseconds=0, microseconds=0, nanoseconds=0"
  177:     with pytest.raises(OutOfBoundsTimedelta, match=msg):
  178:         Timedelta(days=10**6)
  179:     msg = "seconds=60000000000000000000, milliseconds=0, microseconds=0, nanoseconds=0"
  180:     with pytest.raises(OutOfBoundsTimedelta, match=msg):
  181:         Timedelta(minutes=10**9)
  182: 
  183: 
  184: def test_construct_with_weeks_unit_overflow():
  185:     # GH#47268 don't silently wrap around
  186:     with pytest.raises(OutOfBoundsTimedelta, match="without overflow"):
  187:         Timedelta(1000000000000000000, unit="W")
  188: 
  189:     with pytest.raises(OutOfBoundsTimedelta, match="without overflow"):
  190:         Timedelta(1000000000000000000.0, unit="W")
  191: 
  192: 
  193: def test_construct_from_td64_with_unit():
  194:     # ignore the unit, as it may cause silently overflows leading to incorrect
  195:     #  results, and in non-overflow cases is irrelevant GH#46827
  196:     obj = np.timedelta64(123456789000000000, "h")
  197: 
  198:     with pytest.raises(OutOfBoundsTimedelta, match="123456789000000000 hours"):
  199:         Timedelta(obj, unit="ps")
  200: 
  201:     with pytest.raises(OutOfBoundsTimedelta, match="123456789000000000 hours"):
  202:         Timedelta(obj, unit="ns")
  203: 
  204:     with pytest.raises(OutOfBoundsTimedelta, match="123456789000000000 hours"):
  205:         Timedelta(obj)
  206: 
  207: 
  208: def test_from_td64_retain_resolution():
  209:     # case where we retain millisecond resolution
  210:     obj = np.timedelta64(12345, "ms")
  211: 
  212:     td = Timedelta(obj)
  213:     assert td._value == obj.view("i8")
  214:     assert td._creso == NpyDatetimeUnit.NPY_FR_ms.value
  215: 
  216:     # Case where we cast to nearest-supported reso
  217:     obj2 = np.timedelta64(1234, "D")
  218:     td2 = Timedelta(obj2)
  219:     assert td2._creso == NpyDatetimeUnit.NPY_FR_s.value
  220:     assert td2 == obj2
  221:     assert td2.days == 1234
  222: 
  223:     # Case that _would_ overflow if we didn't support non-nano
  224:     obj3 = np.timedelta64(1000000000000000000, "us")
  225:     td3 = Timedelta(obj3)
  226:     assert td3.total_seconds() == 1000000000000
  227:     assert td3._creso == NpyDatetimeUnit.NPY_FR_us.value
  228: 
  229: 
  230: def test_from_pytimedelta_us_reso():
  231:     # pytimedelta has microsecond resolution, so Timedelta(pytd) inherits that
  232:     td = timedelta(days=4, minutes=3)
  233:     result = Timedelta(td)
  234:     assert result.to_pytimedelta() == td
  235:     assert result._creso == NpyDatetimeUnit.NPY_FR_us.value
  236: 
  237: 
  238: def test_from_tick_reso():
  239:     tick = offsets.Nano()
  240:     assert Timedelta(tick)._creso == NpyDatetimeUnit.NPY_FR_ns.value
  241: 
  242:     tick = offsets.Micro()
  243:     assert Timedelta(tick)._creso == NpyDatetimeUnit.NPY_FR_us.value
  244: 
  245:     tick = offsets.Milli()
  246:     assert Timedelta(tick)._creso == NpyDatetimeUnit.NPY_FR_ms.value
  247: 
  248:     tick = offsets.Second()
  249:     assert Timedelta(tick)._creso == NpyDatetimeUnit.NPY_FR_s.value
  250: 
  251:     # everything above Second gets cast to the closest supported reso: second
  252:     tick = offsets.Minute()
  253:     assert Timedelta(tick)._creso == NpyDatetimeUnit.NPY_FR_s.value
  254: 
  255:     tick = offsets.Hour()
  256:     assert Timedelta(tick)._creso == NpyDatetimeUnit.NPY_FR_s.value
  257: 
  258:     tick = offsets.Day()
  259:     assert Timedelta(tick)._creso == NpyDatetimeUnit.NPY_FR_s.value
  260: 
  261: 
  262: def test_construction():
  263:     expected = np.timedelta64(10, "D").astype("m8[ns]").view("i8")
  264:     assert Timedelta(10, unit="d")._value == expected
  265:     assert Timedelta(10.0, unit="d")._value == expected
  266:     assert Timedelta("10 days")._value == expected
  267:     assert Timedelta(days=10)._value == expected
  268:     assert Timedelta(days=10.0)._value == expected
  269: 
  270:     expected += np.timedelta64(10, "s").astype("m8[ns]").view("i8")
  271:     assert Timedelta("10 days 00:00:10")._value == expected
  272:     assert Timedelta(days=10, seconds=10)._value == expected
  273:     assert Timedelta(days=10, milliseconds=10 * 1000)._value == expected
  274:     assert Timedelta(days=10, microseconds=10 * 1000 * 1000)._value == expected
  275: 
  276:     # rounding cases
  277:     assert Timedelta(82739999850000)._value == 82739999850000
  278:     assert "0 days 22:58:59.999850" in str(Timedelta(82739999850000))
  279:     assert Timedelta(123072001000000)._value == 123072001000000
  280:     assert "1 days 10:11:12.001" in str(Timedelta(123072001000000))
  281: 
  282:     # string conversion with/without leading zero
  283:     # GH#9570
  284:     assert Timedelta("0:00:00") == timedelta(hours=0)
  285:     assert Timedelta("00:00:00") == timedelta(hours=0)
  286:     assert Timedelta("-1:00:00") == -timedelta(hours=1)
  287:     assert Timedelta("-01:00:00") == -timedelta(hours=1)
  288: 
  289:     # more strings & abbrevs
  290:     # GH#8190
  291:     assert Timedelta("1 h") == timedelta(hours=1)
  292:     assert Timedelta("1 hour") == timedelta(hours=1)
  293:     assert Timedelta("1 hr") == timedelta(hours=1)
  294:     assert Timedelta("1 hours") == timedelta(hours=1)
  295:     assert Timedelta("-1 hours") == -timedelta(hours=1)
  296:     assert Timedelta("1 m") == timedelta(minutes=1)
  297:     assert Timedelta("1.5 m") == timedelta(seconds=90)
  298:     assert Timedelta("1 minute") == timedelta(minutes=1)
  299:     assert Timedelta("1 minutes") == timedelta(minutes=1)
  300:     assert Timedelta("1 s") == timedelta(seconds=1)
  301:     assert Timedelta("1 second") == timedelta(seconds=1)
  302:     assert Timedelta("1 seconds") == timedelta(seconds=1)
  303:     assert Timedelta("1 ms") == timedelta(milliseconds=1)
  304:     assert Timedelta("1 milli") == timedelta(milliseconds=1)
  305:     assert Timedelta("1 millisecond") == timedelta(milliseconds=1)
  306:     assert Timedelta("1 us") == timedelta(microseconds=1)
  307:     assert Timedelta("1 Вµs") == timedelta(microseconds=1)
  308:     assert Timedelta("1 micros") == timedelta(microseconds=1)
  309:     assert Timedelta("1 microsecond") == timedelta(microseconds=1)
  310:     assert Timedelta("1.5 microsecond") == Timedelta("00:00:00.000001500")
  311:     assert Timedelta("1 ns") == Timedelta("00:00:00.000000001")
  312:     assert Timedelta("1 nano") == Timedelta("00:00:00.000000001")
  313:     assert Timedelta("1 nanosecond") == Timedelta("00:00:00.000000001")
  314: 
  315:     # combos
  316:     assert Timedelta("10 days 1 hour") == timedelta(days=10, hours=1)
  317:     assert Timedelta("10 days 1 h") == timedelta(days=10, hours=1)
  318:     assert Timedelta("10 days 1 h 1m 1s") == timedelta(
  319:         days=10, hours=1, minutes=1, seconds=1
  320:     )
  321:     assert Timedelta("-10 days 1 h 1m 1s") == -timedelta(
  322:         days=10, hours=1, minutes=1, seconds=1
  323:     )
  324:     assert Timedelta("-10 days 1 h 1m 1s") == -timedelta(
  325:         days=10, hours=1, minutes=1, seconds=1
  326:     )
  327:     assert Timedelta("-10 days 1 h 1m 1s 3us") == -timedelta(
  328:         days=10, hours=1, minutes=1, seconds=1, microseconds=3
  329:     )
  330:     assert Timedelta("-10 days 1 h 1.5m 1s 3us") == -timedelta(
  331:         days=10, hours=1, minutes=1, seconds=31, microseconds=3
  332:     )
  333: 
  334:     # Currently invalid as it has a - on the hh:mm:dd part
  335:     # (only allowed on the days)
  336:     msg = "only leading negative signs are allowed"
  337:     with pytest.raises(ValueError, match=msg):
  338:         Timedelta("-10 days -1 h 1.5m 1s 3us")
  339: 
  340:     # only leading neg signs are allowed
  341:     with pytest.raises(ValueError, match=msg):
  342:         Timedelta("10 days -1 h 1.5m 1s 3us")
  343: 
  344:     # no units specified
  345:     msg = "no units specified"
  346:     with pytest.raises(ValueError, match=msg):
  347:         Timedelta("3.1415")
  348: 
  349:     # invalid construction
  350:     msg = "cannot construct a Timedelta"
  351:     with pytest.raises(ValueError, match=msg):
  352:         Timedelta()
  353: 
  354:     msg = "unit abbreviation w/o a number"
  355:     with pytest.raises(ValueError, match=msg):
  356:         Timedelta("foo")
  357: 
  358:     msg = (
  359:         "cannot construct a Timedelta from "
  360:         "the passed arguments, allowed keywords are "
  361:     )
  362:     with pytest.raises(ValueError, match=msg):
  363:         Timedelta(day=10)
  364: 
  365:     # floats
  366:     expected = np.timedelta64(10, "s").astype("m8[ns]").view("i8") + np.timedelta64(
  367:         500, "ms"
  368:     ).astype("m8[ns]").view("i8")
  369:     assert Timedelta(10.5, unit="s")._value == expected
  370: 
  371:     # offset
  372:     assert to_timedelta(offsets.Hour(2)) == Timedelta(hours=2)
  373:     assert Timedelta(offsets.Hour(2)) == Timedelta(hours=2)
  374:     assert Timedelta(offsets.Second(2)) == Timedelta(seconds=2)
  375: 
  376:     # GH#11995: unicode
  377:     expected = Timedelta("1h")
  378:     result = Timedelta("1h")
  379:     assert result == expected
  380:     assert to_timedelta(offsets.Hour(2)) == Timedelta("0 days, 02:00:00")
  381: 
  382:     msg = "unit abbreviation w/o a number"
  383:     with pytest.raises(ValueError, match=msg):
  384:         Timedelta("foo bar")
  385: 
  386: 
  387: @pytest.mark.parametrize(
  388:     "item",
  389:     list(
  390:         {
  391:             "days": "D",
  392:             "seconds": "s",
  393:             "microseconds": "us",
  394:             "milliseconds": "ms",
  395:             "minutes": "m",
  396:             "hours": "h",
  397:             "weeks": "W",
  398:         }.items()
  399:     ),
  400: )
  401: @pytest.mark.parametrize(
  402:     "npdtype", [np.int64, np.int32, np.int16, np.float64, np.float32, np.float16]
  403: )
  404: def test_td_construction_with_np_dtypes(npdtype, item):
  405:     # GH#8757: test construction with np dtypes
  406:     pykwarg, npkwarg = item
  407:     expected = np.timedelta64(1, npkwarg).astype("m8[ns]").view("i8")
  408:     assert Timedelta(**{pykwarg: npdtype(1)})._value == expected
  409: 
  410: 
  411: @pytest.mark.parametrize(
  412:     "val",
  413:     [
  414:         "1s",
  415:         "-1s",
  416:         "1us",
  417:         "-1us",
  418:         "1 day",
  419:         "-1 day",
  420:         "-23:59:59.999999",
  421:         "-1 days +23:59:59.999999",
  422:         "-1ns",
  423:         "1ns",
  424:         "-23:59:59.999999999",
  425:     ],
  426: )
  427: def test_td_from_repr_roundtrip(val):
  428:     # round-trip both for string and value
  429:     td = Timedelta(val)
  430:     assert Timedelta(td._value) == td
  431: 
  432:     assert Timedelta(str(td)) == td
  433:     assert Timedelta(td._repr_base(format="all")) == td
  434:     assert Timedelta(td._repr_base()) == td
  435: 
  436: 
  437: def test_overflow_on_construction():
  438:     # GH#3374
  439:     value = Timedelta("1day")._value * 20169940
  440:     msg = "Cannot cast 1742682816000000000000 from ns to 'ns' without overflow"
  441:     with pytest.raises(OutOfBoundsTimedelta, match=msg):
  442:         Timedelta(value)
  443: 
  444:     # xref GH#17637
  445:     msg = "Cannot cast 139993 from D to 'ns' without overflow"
  446:     with pytest.raises(OutOfBoundsTimedelta, match=msg):
  447:         Timedelta(7 * 19999, unit="D")
  448: 
  449:     # used to overflow before non-ns support
  450:     td = Timedelta(timedelta(days=13 * 19999))
  451:     assert td._creso == NpyDatetimeUnit.NPY_FR_us.value
  452:     assert td.days == 13 * 19999
  453: 
  454: 
  455: @pytest.mark.parametrize(
  456:     "val, unit",
  457:     [
  458:         (15251, "W"),  # 1
  459:         (106752, "D"),  # change from previous:
  460:         (2562048, "h"),  # 0 hours
  461:         (153722868, "m"),  # 13 minutes
  462:         (9223372037, "s"),  # 44 seconds
  463:     ],
  464: )
  465: def test_construction_out_of_bounds_td64ns(val, unit):
  466:     # TODO: parametrize over units just above/below the implementation bounds
  467:     #  once GH#38964 is resolved
  468: 
  469:     # Timedelta.max is just under 106752 days
  470:     td64 = np.timedelta64(val, unit)
  471:     assert td64.astype("m8[ns]").view("i8") < 0  # i.e. naive astype will be wrong
  472: 
  473:     td = Timedelta(td64)
  474:     if unit != "M":
  475:         # with unit="M" the conversion to "s" is poorly defined
  476:         #  (and numpy issues DeprecationWarning)
  477:         assert td.asm8 == td64
  478:     assert td.asm8.dtype == "m8[s]"
  479:     msg = r"Cannot cast 1067\d\d days .* to unit='ns' without overflow"
  480:     with pytest.raises(OutOfBoundsTimedelta, match=msg):
  481:         td.as_unit("ns")
  482: 
  483:     # But just back in bounds and we are OK
  484:     assert Timedelta(td64 - 1) == td64 - 1
  485: 
  486:     td64 *= -1
  487:     assert td64.astype("m8[ns]").view("i8") > 0  # i.e. naive astype will be wrong
  488: 
  489:     td2 = Timedelta(td64)
  490:     msg = r"Cannot cast -1067\d\d days .* to unit='ns' without overflow"
  491:     with pytest.raises(OutOfBoundsTimedelta, match=msg):
  492:         td2.as_unit("ns")
  493: 
  494:     # But just back in bounds and we are OK
  495:     assert Timedelta(td64 + 1) == td64 + 1
  496: 
  497: 
  498: @pytest.mark.parametrize(
  499:     "val, unit",
  500:     [
  501:         (15251 * 10**9, "W"),
  502:         (106752 * 10**9, "D"),
  503:         (2562048 * 10**9, "h"),
  504:         (153722868 * 10**9, "m"),
  505:     ],
  506: )
  507: def test_construction_out_of_bounds_td64s(val, unit):
  508:     td64 = np.timedelta64(val, unit)
  509:     with pytest.raises(OutOfBoundsTimedelta, match=str(td64)):
  510:         Timedelta(td64)
  511: 
  512:     # But just back in bounds and we are OK
  513:     assert Timedelta(td64 - 10**9) == td64 - 10**9
  514: 
  515: 
  516: @pytest.mark.parametrize(
  517:     "fmt,exp",
  518:     [
  519:         (
  520:             "P6DT0H50M3.010010012S",
  521:             Timedelta(
  522:                 days=6,
  523:                 minutes=50,
  524:                 seconds=3,
  525:                 milliseconds=10,
  526:                 microseconds=10,
  527:                 nanoseconds=12,
  528:             ),
  529:         ),
  530:         (
  531:             "P-6DT0H50M3.010010012S",
  532:             Timedelta(
  533:                 days=-6,
  534:                 minutes=50,
  535:                 seconds=3,
  536:                 milliseconds=10,
  537:                 microseconds=10,
  538:                 nanoseconds=12,
  539:             ),
  540:         ),
  541:         ("P4DT12H30M5S", Timedelta(days=4, hours=12, minutes=30, seconds=5)),
  542:         ("P0DT0H0M0.000000123S", Timedelta(nanoseconds=123)),
  543:         ("P0DT0H0M0.00001S", Timedelta(microseconds=10)),
  544:         ("P0DT0H0M0.001S", Timedelta(milliseconds=1)),
  545:         ("P0DT0H1M0S", Timedelta(minutes=1)),
  546:         ("P1DT25H61M61S", Timedelta(days=1, hours=25, minutes=61, seconds=61)),
  547:         ("PT1S", Timedelta(seconds=1)),
  548:         ("PT0S", Timedelta(seconds=0)),
  549:         ("P1WT0S", Timedelta(days=7, seconds=0)),
  550:         ("P1D", Timedelta(days=1)),
  551:         ("P1DT1H", Timedelta(days=1, hours=1)),
  552:         ("P1W", Timedelta(days=7)),
  553:         ("PT300S", Timedelta(seconds=300)),
  554:         ("P1DT0H0M00000000000S", Timedelta(days=1)),
  555:         ("PT-6H3M", Timedelta(hours=-6, minutes=3)),
  556:         ("-PT6H3M", Timedelta(hours=-6, minutes=-3)),
  557:         ("-PT-6H+3M", Timedelta(hours=6, minutes=-3)),
  558:     ],
  559: )
  560: def test_iso_constructor(fmt, exp):
  561:     assert Timedelta(fmt) == exp
  562: 
  563: 
  564: @pytest.mark.parametrize(
  565:     "fmt",
  566:     [
  567:         "PPPPPPPPPPPP",
  568:         "PDTHMS",
  569:         "P0DT999H999M999S",
  570:         "P1DT0H0M0.0000000000000S",
  571:         "P1DT0H0M0.S",
  572:         "P",
  573:         "-P",
  574:     ],
  575: )
  576: def test_iso_constructor_raises(fmt):
  577:     msg = f"Invalid ISO 8601 Duration format - {fmt}"
  578:     with pytest.raises(ValueError, match=msg):
  579:         Timedelta(fmt)
  580: 
  581: 
  582: @pytest.mark.parametrize(
  583:     "constructed_td, conversion",
  584:     [
  585:         (Timedelta(nanoseconds=100), "100ns"),
  586:         (
  587:             Timedelta(
  588:                 days=1,
  589:                 hours=1,
  590:                 minutes=1,
  591:                 weeks=1,
  592:                 seconds=1,
  593:                 milliseconds=1,
  594:                 microseconds=1,
  595:                 nanoseconds=1,
  596:             ),
  597:             694861001001001,
  598:         ),
  599:         (Timedelta(microseconds=1) + Timedelta(nanoseconds=1), "1us1ns"),
  600:         (Timedelta(microseconds=1) - Timedelta(nanoseconds=1), "999ns"),
  601:         (Timedelta(microseconds=1) + 5 * Timedelta(nanoseconds=-2), "990ns"),
  602:     ],
  603: )
  604: def test_td_constructor_on_nanoseconds(constructed_td, conversion):
  605:     # GH#9273
  606:     assert constructed_td == Timedelta(conversion)
  607: 
  608: 
  609: def test_td_constructor_value_error():
  610:     msg = "Invalid type <class 'str'>. Must be int or float."
  611:     with pytest.raises(TypeError, match=msg):
  612:         Timedelta(nanoseconds="abc")
  613: 
  614: 
  615: def test_timedelta_constructor_identity():
  616:     # Test for #30543
  617:     expected = Timedelta(np.timedelta64(1, "s"))
  618:     result = Timedelta(expected)
  619:     assert result is expected
  620: 
  621: 
  622: def test_timedelta_pass_td_and_kwargs_raises():
  623:     # don't silently ignore the kwargs GH#48898
  624:     td = Timedelta(days=1)
  625:     msg = (
  626:         "Cannot pass both a Timedelta input and timedelta keyword arguments, "
  627:         r"got \['days'\]"
  628:     )
  629:     with pytest.raises(ValueError, match=msg):
  630:         Timedelta(td, days=2)
  631: 
  632: 
  633: @pytest.mark.parametrize(
  634:     "constructor, value, unit, expectation",
  635:     [
  636:         (Timedelta, "10s", "ms", (ValueError, "unit must not be specified")),
  637:         (to_timedelta, "10s", "ms", (ValueError, "unit must not be specified")),
  638:         (to_timedelta, ["1", 2, 3], "s", (ValueError, "unit must not be specified")),
  639:     ],
  640: )
  641: def test_string_with_unit(constructor, value, unit, expectation):
  642:     exp, match = expectation
  643:     with pytest.raises(exp, match=match):
  644:         _ = constructor(value, unit=unit)
  645: 
  646: 
  647: @pytest.mark.parametrize(
  648:     "value",
  649:     [
  650:         "".join(elements)
  651:         for repetition in (1, 2)
  652:         for elements in product("+-, ", repeat=repetition)
  653:     ],
  654: )
  655: def test_string_without_numbers(value):
  656:     # GH39710 Timedelta input string with only symbols and no digits raises an error
  657:     msg = (
  658:         "symbols w/o a number"
  659:         if value != "--"
  660:         else "only leading negative signs are allowed"
  661:     )
  662:     with pytest.raises(ValueError, match=msg):
  663:         Timedelta(value)
  664: 
  665: 
  666: def test_timedelta_new_npnat():
  667:     # GH#48898
  668:     nat = np.timedelta64("NaT", "h")
  669:     assert Timedelta(nat) is NaT
  670: 
  671: 
  672: def test_subclass_respected():
  673:     # GH#49579
  674:     class MyCustomTimedelta(Timedelta):
  675:         pass
  676: 
  677:     td = MyCustomTimedelta("1 minute")
  678:     assert isinstance(td, MyCustomTimedelta)
  679: 
  680: 
  681: def test_non_nano_value():
  682:     # https://github.com/pandas-dev/pandas/issues/49076
  683:     result = Timedelta(10, unit="D").as_unit("s").value
  684:     # `.value` shows nanoseconds, even though unit is 's'
  685:     assert result == 864000000000000
  686: 
  687:     # out-of-nanoseconds-bounds `.value` raises informative message
  688:     msg = (
  689:         r"Cannot convert Timedelta to nanoseconds without overflow. "
  690:         r"Use `.asm8.view\('i8'\)` to cast represent Timedelta in its "
  691:         r"own unit \(here, s\).$"
  692:     )
  693:     td = Timedelta(1_000, "D").as_unit("s") * 1_000
  694:     with pytest.raises(OverflowError, match=msg):
  695:         td.value
  696:     # check that the suggested workaround actually works
  697:     result = td.asm8.view("i8")
  698:     assert result == 86400000000
