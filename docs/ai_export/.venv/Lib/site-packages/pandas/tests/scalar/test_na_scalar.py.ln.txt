    1: from datetime import (
    2:     date,
    3:     time,
    4:     timedelta,
    5: )
    6: import pickle
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas._libs.missing import NA
   12: 
   13: from pandas.core.dtypes.common import is_scalar
   14: 
   15: import pandas as pd
   16: import pandas._testing as tm
   17: 
   18: 
   19: def test_singleton():
   20:     assert NA is NA
   21:     new_NA = type(NA)()
   22:     assert new_NA is NA
   23: 
   24: 
   25: def test_repr():
   26:     assert repr(NA) == "<NA>"
   27:     assert str(NA) == "<NA>"
   28: 
   29: 
   30: def test_format():
   31:     # GH-34740
   32:     assert format(NA) == "<NA>"
   33:     assert format(NA, ">10") == "      <NA>"
   34:     assert format(NA, "xxx") == "<NA>"  # NA is flexible, accept any format spec
   35: 
   36:     assert f"{NA}" == "<NA>"
   37:     assert f"{NA:>10}" == "      <NA>"
   38:     assert f"{NA:xxx}" == "<NA>"
   39: 
   40: 
   41: def test_truthiness():
   42:     msg = "boolean value of NA is ambiguous"
   43: 
   44:     with pytest.raises(TypeError, match=msg):
   45:         bool(NA)
   46: 
   47:     with pytest.raises(TypeError, match=msg):
   48:         not NA
   49: 
   50: 
   51: def test_hashable():
   52:     assert hash(NA) == hash(NA)
   53:     d = {NA: "test"}
   54:     assert d[NA] == "test"
   55: 
   56: 
   57: @pytest.mark.parametrize(
   58:     "other", [NA, 1, 1.0, "a", b"a", np.int64(1), np.nan], ids=repr
   59: )
   60: def test_arithmetic_ops(all_arithmetic_functions, other):
   61:     op = all_arithmetic_functions
   62: 
   63:     if op.__name__ in ("pow", "rpow", "rmod") and isinstance(other, (str, bytes)):
   64:         pytest.skip(reason=f"{op.__name__} with NA and {other} not defined.")
   65:     if op.__name__ in ("divmod", "rdivmod"):
   66:         assert op(NA, other) is (NA, NA)
   67:     else:
   68:         if op.__name__ == "rpow":
   69:             # avoid special case
   70:             other += 1
   71:         assert op(NA, other) is NA
   72: 
   73: 
   74: @pytest.mark.parametrize(
   75:     "other",
   76:     [
   77:         NA,
   78:         1,
   79:         1.0,
   80:         "a",
   81:         b"a",
   82:         np.int64(1),
   83:         np.nan,
   84:         np.bool_(True),
   85:         time(0),
   86:         date(1, 2, 3),
   87:         timedelta(1),
   88:         pd.NaT,
   89:     ],
   90: )
   91: def test_comparison_ops(comparison_op, other):
   92:     assert comparison_op(NA, other) is NA
   93:     assert comparison_op(other, NA) is NA
   94: 
   95: 
   96: @pytest.mark.parametrize(
   97:     "value",
   98:     [
   99:         0,
  100:         0.0,
  101:         -0,
  102:         -0.0,
  103:         False,
  104:         np.bool_(False),
  105:         np.int_(0),
  106:         np.float64(0),
  107:         np.int_(-0),
  108:         np.float64(-0),
  109:     ],
  110: )
  111: @pytest.mark.parametrize("asarray", [True, False])
  112: def test_pow_special(value, asarray):
  113:     if asarray:
  114:         value = np.array([value])
  115:     result = NA**value
  116: 
  117:     if asarray:
  118:         result = result[0]
  119:     else:
  120:         # this assertion isn't possible for ndarray.
  121:         assert isinstance(result, type(value))
  122:     assert result == 1
  123: 
  124: 
  125: @pytest.mark.parametrize(
  126:     "value", [1, 1.0, True, np.bool_(True), np.int_(1), np.float64(1)]
  127: )
  128: @pytest.mark.parametrize("asarray", [True, False])
  129: def test_rpow_special(value, asarray):
  130:     if asarray:
  131:         value = np.array([value])
  132:     result = value**NA
  133: 
  134:     if asarray:
  135:         result = result[0]
  136:     elif not isinstance(value, (np.float64, np.bool_, np.int_)):
  137:         # this assertion isn't possible with asarray=True
  138:         assert isinstance(result, type(value))
  139: 
  140:     assert result == value
  141: 
  142: 
  143: @pytest.mark.parametrize("value", [-1, -1.0, np.int_(-1), np.float64(-1)])
  144: @pytest.mark.parametrize("asarray", [True, False])
  145: def test_rpow_minus_one(value, asarray):
  146:     if asarray:
  147:         value = np.array([value])
  148:     result = value**NA
  149: 
  150:     if asarray:
  151:         result = result[0]
  152: 
  153:     assert pd.isna(result)
  154: 
  155: 
  156: def test_unary_ops():
  157:     assert +NA is NA
  158:     assert -NA is NA
  159:     assert abs(NA) is NA
  160:     assert ~NA is NA
  161: 
  162: 
  163: def test_logical_and():
  164:     assert NA & True is NA
  165:     assert True & NA is NA
  166:     assert NA & False is False
  167:     assert False & NA is False
  168:     assert NA & NA is NA
  169: 
  170:     msg = "unsupported operand type"
  171:     with pytest.raises(TypeError, match=msg):
  172:         NA & 5
  173: 
  174: 
  175: def test_logical_or():
  176:     assert NA | True is True
  177:     assert True | NA is True
  178:     assert NA | False is NA
  179:     assert False | NA is NA
  180:     assert NA | NA is NA
  181: 
  182:     msg = "unsupported operand type"
  183:     with pytest.raises(TypeError, match=msg):
  184:         NA | 5
  185: 
  186: 
  187: def test_logical_xor():
  188:     assert NA ^ True is NA
  189:     assert True ^ NA is NA
  190:     assert NA ^ False is NA
  191:     assert False ^ NA is NA
  192:     assert NA ^ NA is NA
  193: 
  194:     msg = "unsupported operand type"
  195:     with pytest.raises(TypeError, match=msg):
  196:         NA ^ 5
  197: 
  198: 
  199: def test_logical_not():
  200:     assert ~NA is NA
  201: 
  202: 
  203: @pytest.mark.parametrize("shape", [(3,), (3, 3), (1, 2, 3)])
  204: def test_arithmetic_ndarray(shape, all_arithmetic_functions):
  205:     op = all_arithmetic_functions
  206:     a = np.zeros(shape)
  207:     if op.__name__ == "pow":
  208:         a += 5
  209:     result = op(NA, a)
  210:     expected = np.full(a.shape, NA, dtype=object)
  211:     tm.assert_numpy_array_equal(result, expected)
  212: 
  213: 
  214: def test_is_scalar():
  215:     assert is_scalar(NA) is True
  216: 
  217: 
  218: def test_isna():
  219:     assert pd.isna(NA) is True
  220:     assert pd.notna(NA) is False
  221: 
  222: 
  223: def test_series_isna():
  224:     s = pd.Series([1, NA], dtype=object)
  225:     expected = pd.Series([False, True])
  226:     tm.assert_series_equal(s.isna(), expected)
  227: 
  228: 
  229: def test_ufunc():
  230:     assert np.log(NA) is NA
  231:     assert np.add(NA, 1) is NA
  232:     result = np.divmod(NA, 1)
  233:     assert result[0] is NA and result[1] is NA
  234: 
  235:     result = np.frexp(NA)
  236:     assert result[0] is NA and result[1] is NA
  237: 
  238: 
  239: def test_ufunc_raises():
  240:     msg = "ufunc method 'at'"
  241:     with pytest.raises(ValueError, match=msg):
  242:         np.log.at(NA, 0)
  243: 
  244: 
  245: def test_binary_input_not_dunder():
  246:     a = np.array([1, 2, 3])
  247:     expected = np.array([NA, NA, NA], dtype=object)
  248:     result = np.logaddexp(a, NA)
  249:     tm.assert_numpy_array_equal(result, expected)
  250: 
  251:     result = np.logaddexp(NA, a)
  252:     tm.assert_numpy_array_equal(result, expected)
  253: 
  254:     # all NA, multiple inputs
  255:     assert np.logaddexp(NA, NA) is NA
  256: 
  257:     result = np.modf(NA, NA)
  258:     assert len(result) == 2
  259:     assert all(x is NA for x in result)
  260: 
  261: 
  262: def test_divmod_ufunc():
  263:     # binary in, binary out.
  264:     a = np.array([1, 2, 3])
  265:     expected = np.array([NA, NA, NA], dtype=object)
  266: 
  267:     result = np.divmod(a, NA)
  268:     assert isinstance(result, tuple)
  269:     for arr in result:
  270:         tm.assert_numpy_array_equal(arr, expected)
  271:         tm.assert_numpy_array_equal(arr, expected)
  272: 
  273:     result = np.divmod(NA, a)
  274:     for arr in result:
  275:         tm.assert_numpy_array_equal(arr, expected)
  276:         tm.assert_numpy_array_equal(arr, expected)
  277: 
  278: 
  279: def test_integer_hash_collision_dict():
  280:     # GH 30013
  281:     result = {NA: "foo", hash(NA): "bar"}
  282: 
  283:     assert result[NA] == "foo"
  284:     assert result[hash(NA)] == "bar"
  285: 
  286: 
  287: def test_integer_hash_collision_set():
  288:     # GH 30013
  289:     result = {NA, hash(NA)}
  290: 
  291:     assert len(result) == 2
  292:     assert NA in result
  293:     assert hash(NA) in result
  294: 
  295: 
  296: def test_pickle_roundtrip():
  297:     # https://github.com/pandas-dev/pandas/issues/31847
  298:     result = pickle.loads(pickle.dumps(NA))
  299:     assert result is NA
  300: 
  301: 
  302: def test_pickle_roundtrip_pandas():
  303:     result = tm.round_trip_pickle(NA)
  304:     assert result is NA
  305: 
  306: 
  307: @pytest.mark.parametrize(
  308:     "values, dtype", [([1, 2, NA], "Int64"), (["A", "B", NA], "string")]
  309: )
  310: @pytest.mark.parametrize("as_frame", [True, False])
  311: def test_pickle_roundtrip_containers(as_frame, values, dtype):
  312:     s = pd.Series(pd.array(values, dtype=dtype))
  313:     if as_frame:
  314:         s = s.to_frame(name="A")
  315:     result = tm.round_trip_pickle(s)
  316:     tm.assert_equal(result, s)
