    1: from datetime import (
    2:     date,
    3:     datetime,
    4:     timedelta,
    5: )
    6: import re
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas._libs.tslibs import iNaT
   12: from pandas._libs.tslibs.ccalendar import (
   13:     DAYS,
   14:     MONTHS,
   15: )
   16: from pandas._libs.tslibs.np_datetime import OutOfBoundsDatetime
   17: from pandas._libs.tslibs.parsing import DateParseError
   18: from pandas._libs.tslibs.period import INVALID_FREQ_ERR_MSG
   19: 
   20: from pandas import (
   21:     NaT,
   22:     Period,
   23:     Timedelta,
   24:     Timestamp,
   25:     offsets,
   26: )
   27: import pandas._testing as tm
   28: 
   29: bday_msg = "Period with BDay freq is deprecated"
   30: 
   31: 
   32: class TestPeriodDisallowedFreqs:
   33:     @pytest.mark.parametrize(
   34:         "freq, freq_msg",
   35:         [
   36:             (offsets.BYearBegin(), "BYearBegin"),
   37:             (offsets.YearBegin(2), "YearBegin"),
   38:             (offsets.QuarterBegin(startingMonth=12), "QuarterBegin"),
   39:             (offsets.BusinessMonthEnd(2), "BusinessMonthEnd"),
   40:         ],
   41:     )
   42:     def test_offsets_not_supported(self, freq, freq_msg):
   43:         # GH#55785
   44:         msg = re.escape(f"{freq} is not supported as period frequency")
   45:         with pytest.raises(ValueError, match=msg):
   46:             Period(year=2014, freq=freq)
   47: 
   48:     def test_custom_business_day_freq_raises(self):
   49:         # GH#52534
   50:         msg = "C is not supported as period frequency"
   51:         with pytest.raises(ValueError, match=msg):
   52:             Period("2023-04-10", freq="C")
   53:         msg = f"{offsets.CustomBusinessDay().base} is not supported as period frequency"
   54:         with pytest.raises(ValueError, match=msg):
   55:             Period("2023-04-10", freq=offsets.CustomBusinessDay())
   56: 
   57:     def test_invalid_frequency_error_message(self):
   58:         msg = "WOM-1MON is not supported as period frequency"
   59:         with pytest.raises(ValueError, match=msg):
   60:             Period("2012-01-02", freq="WOM-1MON")
   61: 
   62:     def test_invalid_frequency_period_error_message(self):
   63:         msg = "for Period, please use 'M' instead of 'ME'"
   64:         with pytest.raises(ValueError, match=msg):
   65:             Period("2012-01-02", freq="ME")
   66: 
   67: 
   68: class TestPeriodConstruction:
   69:     def test_from_td64nat_raises(self):
   70:         # GH#44507
   71:         td = NaT.to_numpy("m8[ns]")
   72: 
   73:         msg = "Value must be Period, string, integer, or datetime"
   74:         with pytest.raises(ValueError, match=msg):
   75:             Period(td)
   76: 
   77:         with pytest.raises(ValueError, match=msg):
   78:             Period(td, freq="D")
   79: 
   80:     def test_construction(self):
   81:         i1 = Period("1/1/2005", freq="M")
   82:         i2 = Period("Jan 2005")
   83: 
   84:         assert i1 == i2
   85: 
   86:         # GH#54105 - Period can be confusingly instantiated with lowercase freq
   87:         # TODO: raise in the future an error when passing lowercase freq
   88:         i1 = Period("2005", freq="Y")
   89:         i2 = Period("2005")
   90: 
   91:         assert i1 == i2
   92: 
   93:         i4 = Period("2005", freq="M")
   94:         assert i1 != i4
   95: 
   96:         i1 = Period.now(freq="Q")
   97:         i2 = Period(datetime.now(), freq="Q")
   98: 
   99:         assert i1 == i2
  100: 
  101:         # Pass in freq as a keyword argument sometimes as a test for
  102:         # https://github.com/pandas-dev/pandas/issues/53369
  103:         i1 = Period.now(freq="D")
  104:         i2 = Period(datetime.now(), freq="D")
  105:         i3 = Period.now(offsets.Day())
  106: 
  107:         assert i1 == i2
  108:         assert i1 == i3
  109: 
  110:         i1 = Period("1982", freq="min")
  111:         msg = "'MIN' is deprecated and will be removed in a future version."
  112:         with tm.assert_produces_warning(FutureWarning, match=msg):
  113:             i2 = Period("1982", freq="MIN")
  114:         assert i1 == i2
  115: 
  116:         i1 = Period(year=2005, month=3, day=1, freq="D")
  117:         i2 = Period("3/1/2005", freq="D")
  118:         assert i1 == i2
  119: 
  120:         i3 = Period(year=2005, month=3, day=1, freq="d")
  121:         assert i1 == i3
  122: 
  123:         i1 = Period("2007-01-01 09:00:00.001")
  124:         expected = Period(datetime(2007, 1, 1, 9, 0, 0, 1000), freq="ms")
  125:         assert i1 == expected
  126: 
  127:         expected = Period("2007-01-01 09:00:00.001", freq="ms")
  128:         assert i1 == expected
  129: 
  130:         i1 = Period("2007-01-01 09:00:00.00101")
  131:         expected = Period(datetime(2007, 1, 1, 9, 0, 0, 1010), freq="us")
  132:         assert i1 == expected
  133: 
  134:         expected = Period("2007-01-01 09:00:00.00101", freq="us")
  135:         assert i1 == expected
  136: 
  137:         msg = "Must supply freq for ordinal value"
  138:         with pytest.raises(ValueError, match=msg):
  139:             Period(ordinal=200701)
  140: 
  141:         msg = "Invalid frequency: X"
  142:         with pytest.raises(ValueError, match=msg):
  143:             Period("2007-1-1", freq="X")
  144: 
  145:     def test_tuple_freq_disallowed(self):
  146:         # GH#34703 tuple freq disallowed
  147:         with pytest.raises(TypeError, match="pass as a string instead"):
  148:             Period("1982", freq=("Min", 1))
  149: 
  150:         with pytest.raises(TypeError, match="pass as a string instead"):
  151:             Period("2006-12-31", ("w", 1))
  152: 
  153:     def test_construction_from_timestamp_nanos(self):
  154:         # GH#46811 don't drop nanos from Timestamp
  155:         ts = Timestamp("2022-04-20 09:23:24.123456789")
  156:         per = Period(ts, freq="ns")
  157: 
  158:         # should losslessly round-trip, not lose the 789
  159:         rt = per.to_timestamp()
  160:         assert rt == ts
  161: 
  162:         # same thing but from a datetime64 object
  163:         dt64 = ts.asm8
  164:         per2 = Period(dt64, freq="ns")
  165:         rt2 = per2.to_timestamp()
  166:         assert rt2.asm8 == dt64
  167: 
  168:     def test_construction_bday(self):
  169:         # Biz day construction, roll forward if non-weekday
  170:         with tm.assert_produces_warning(FutureWarning, match=bday_msg):
  171:             i1 = Period("3/10/12", freq="B")
  172:             i2 = Period("3/10/12", freq="D")
  173:             assert i1 == i2.asfreq("B")
  174:             i2 = Period("3/11/12", freq="D")
  175:             assert i1 == i2.asfreq("B")
  176:             i2 = Period("3/12/12", freq="D")
  177:             assert i1 == i2.asfreq("B")
  178: 
  179:             i3 = Period("3/10/12", freq="b")
  180:             assert i1 == i3
  181: 
  182:             i1 = Period(year=2012, month=3, day=10, freq="B")
  183:             i2 = Period("3/12/12", freq="B")
  184:             assert i1 == i2
  185: 
  186:     def test_construction_quarter(self):
  187:         i1 = Period(year=2005, quarter=1, freq="Q")
  188:         i2 = Period("1/1/2005", freq="Q")
  189:         assert i1 == i2
  190: 
  191:         i1 = Period(year=2005, quarter=3, freq="Q")
  192:         i2 = Period("9/1/2005", freq="Q")
  193:         assert i1 == i2
  194: 
  195:         i1 = Period("2005Q1")
  196:         i2 = Period(year=2005, quarter=1, freq="Q")
  197:         i3 = Period("2005q1")
  198:         assert i1 == i2
  199:         assert i1 == i3
  200: 
  201:         i1 = Period("05Q1")
  202:         assert i1 == i2
  203:         lower = Period("05q1")
  204:         assert i1 == lower
  205: 
  206:         i1 = Period("1Q2005")
  207:         assert i1 == i2
  208:         lower = Period("1q2005")
  209:         assert i1 == lower
  210: 
  211:         i1 = Period("1Q05")
  212:         assert i1 == i2
  213:         lower = Period("1q05")
  214:         assert i1 == lower
  215: 
  216:         i1 = Period("4Q1984")
  217:         assert i1.year == 1984
  218:         lower = Period("4q1984")
  219:         assert i1 == lower
  220: 
  221:     def test_construction_month(self):
  222:         expected = Period("2007-01", freq="M")
  223:         i1 = Period("200701", freq="M")
  224:         assert i1 == expected
  225: 
  226:         i1 = Period("200701", freq="M")
  227:         assert i1 == expected
  228: 
  229:         i1 = Period(200701, freq="M")
  230:         assert i1 == expected
  231: 
  232:         i1 = Period(ordinal=200701, freq="M")
  233:         assert i1.year == 18695
  234: 
  235:         i1 = Period(datetime(2007, 1, 1), freq="M")
  236:         i2 = Period("200701", freq="M")
  237:         assert i1 == i2
  238: 
  239:         i1 = Period(date(2007, 1, 1), freq="M")
  240:         i2 = Period(datetime(2007, 1, 1), freq="M")
  241:         i3 = Period(np.datetime64("2007-01-01"), freq="M")
  242:         i4 = Period("2007-01-01 00:00:00", freq="M")
  243:         i5 = Period("2007-01-01 00:00:00.000", freq="M")
  244:         assert i1 == i2
  245:         assert i1 == i3
  246:         assert i1 == i4
  247:         assert i1 == i5
  248: 
  249:     def test_period_constructor_offsets(self):
  250:         assert Period("1/1/2005", freq=offsets.MonthEnd()) == Period(
  251:             "1/1/2005", freq="M"
  252:         )
  253:         assert Period("2005", freq=offsets.YearEnd()) == Period("2005", freq="Y")
  254:         assert Period("2005", freq=offsets.MonthEnd()) == Period("2005", freq="M")
  255:         with tm.assert_produces_warning(FutureWarning, match=bday_msg):
  256:             assert Period("3/10/12", freq=offsets.BusinessDay()) == Period(
  257:                 "3/10/12", freq="B"
  258:             )
  259:         assert Period("3/10/12", freq=offsets.Day()) == Period("3/10/12", freq="D")
  260: 
  261:         assert Period(
  262:             year=2005, quarter=1, freq=offsets.QuarterEnd(startingMonth=12)
  263:         ) == Period(year=2005, quarter=1, freq="Q")
  264:         assert Period(
  265:             year=2005, quarter=2, freq=offsets.QuarterEnd(startingMonth=12)
  266:         ) == Period(year=2005, quarter=2, freq="Q")
  267: 
  268:         assert Period(year=2005, month=3, day=1, freq=offsets.Day()) == Period(
  269:             year=2005, month=3, day=1, freq="D"
  270:         )
  271:         with tm.assert_produces_warning(FutureWarning, match=bday_msg):
  272:             assert Period(year=2012, month=3, day=10, freq=offsets.BDay()) == Period(
  273:                 year=2012, month=3, day=10, freq="B"
  274:             )
  275: 
  276:         expected = Period("2005-03-01", freq="3D")
  277:         assert Period(year=2005, month=3, day=1, freq=offsets.Day(3)) == expected
  278:         assert Period(year=2005, month=3, day=1, freq="3D") == expected
  279: 
  280:         with tm.assert_produces_warning(FutureWarning, match=bday_msg):
  281:             assert Period(year=2012, month=3, day=10, freq=offsets.BDay(3)) == Period(
  282:                 year=2012, month=3, day=10, freq="3B"
  283:             )
  284: 
  285:         assert Period(200701, freq=offsets.MonthEnd()) == Period(200701, freq="M")
  286: 
  287:         i1 = Period(ordinal=200701, freq=offsets.MonthEnd())
  288:         i2 = Period(ordinal=200701, freq="M")
  289:         assert i1 == i2
  290:         assert i1.year == 18695
  291:         assert i2.year == 18695
  292: 
  293:         i1 = Period(datetime(2007, 1, 1), freq="M")
  294:         i2 = Period("200701", freq="M")
  295:         assert i1 == i2
  296: 
  297:         i1 = Period(date(2007, 1, 1), freq="M")
  298:         i2 = Period(datetime(2007, 1, 1), freq="M")
  299:         i3 = Period(np.datetime64("2007-01-01"), freq="M")
  300:         i4 = Period("2007-01-01 00:00:00", freq="M")
  301:         i5 = Period("2007-01-01 00:00:00.000", freq="M")
  302:         assert i1 == i2
  303:         assert i1 == i3
  304:         assert i1 == i4
  305:         assert i1 == i5
  306: 
  307:         i1 = Period("2007-01-01 09:00:00.001")
  308:         expected = Period(datetime(2007, 1, 1, 9, 0, 0, 1000), freq="ms")
  309:         assert i1 == expected
  310: 
  311:         expected = Period("2007-01-01 09:00:00.001", freq="ms")
  312:         assert i1 == expected
  313: 
  314:         i1 = Period("2007-01-01 09:00:00.00101")
  315:         expected = Period(datetime(2007, 1, 1, 9, 0, 0, 1010), freq="us")
  316:         assert i1 == expected
  317: 
  318:         expected = Period("2007-01-01 09:00:00.00101", freq="us")
  319:         assert i1 == expected
  320: 
  321:     def test_invalid_arguments(self):
  322:         msg = "Must supply freq for datetime value"
  323:         with pytest.raises(ValueError, match=msg):
  324:             Period(datetime.now())
  325:         with pytest.raises(ValueError, match=msg):
  326:             Period(datetime.now().date())
  327: 
  328:         msg = "Value must be Period, string, integer, or datetime"
  329:         with pytest.raises(ValueError, match=msg):
  330:             Period(1.6, freq="D")
  331:         msg = "Ordinal must be an integer"
  332:         with pytest.raises(ValueError, match=msg):
  333:             Period(ordinal=1.6, freq="D")
  334:         msg = "Only value or ordinal but not both should be given but not both"
  335:         with pytest.raises(ValueError, match=msg):
  336:             Period(ordinal=2, value=1, freq="D")
  337: 
  338:         msg = "If value is None, freq cannot be None"
  339:         with pytest.raises(ValueError, match=msg):
  340:             Period(month=1)
  341: 
  342:         msg = '^Given date string "-2000" not likely a datetime$'
  343:         with pytest.raises(ValueError, match=msg):
  344:             Period("-2000", "Y")
  345:         msg = "day is out of range for month"
  346:         with pytest.raises(DateParseError, match=msg):
  347:             Period("0", "Y")
  348:         msg = "Unknown datetime string format, unable to parse"
  349:         with pytest.raises(DateParseError, match=msg):
  350:             Period("1/1/-2000", "Y")
  351: 
  352:     def test_constructor_corner(self):
  353:         expected = Period("2007-01", freq="2M")
  354:         assert Period(year=2007, month=1, freq="2M") == expected
  355: 
  356:         assert Period(None) is NaT
  357: 
  358:         p = Period("2007-01-01", freq="D")
  359: 
  360:         result = Period(p, freq="Y")
  361:         exp = Period("2007", freq="Y")
  362:         assert result == exp
  363: 
  364:     def test_constructor_infer_freq(self):
  365:         p = Period("2007-01-01")
  366:         assert p.freq == "D"
  367: 
  368:         p = Period("2007-01-01 07")
  369:         assert p.freq == "h"
  370: 
  371:         p = Period("2007-01-01 07:10")
  372:         assert p.freq == "min"
  373: 
  374:         p = Period("2007-01-01 07:10:15")
  375:         assert p.freq == "s"
  376: 
  377:         p = Period("2007-01-01 07:10:15.123")
  378:         assert p.freq == "ms"
  379: 
  380:         # We see that there are 6 digits after the decimal, so get microsecond
  381:         #  even though they are all zeros.
  382:         p = Period("2007-01-01 07:10:15.123000")
  383:         assert p.freq == "us"
  384: 
  385:         p = Period("2007-01-01 07:10:15.123400")
  386:         assert p.freq == "us"
  387: 
  388:     def test_multiples(self):
  389:         result1 = Period("1989", freq="2Y")
  390:         result2 = Period("1989", freq="Y")
  391:         assert result1.ordinal == result2.ordinal
  392:         assert result1.freqstr == "2Y-DEC"
  393:         assert result2.freqstr == "Y-DEC"
  394:         assert result1.freq == offsets.YearEnd(2)
  395:         assert result2.freq == offsets.YearEnd()
  396: 
  397:         assert (result1 + 1).ordinal == result1.ordinal + 2
  398:         assert (1 + result1).ordinal == result1.ordinal + 2
  399:         assert (result1 - 1).ordinal == result2.ordinal - 2
  400:         assert (-1 + result1).ordinal == result2.ordinal - 2
  401: 
  402:     @pytest.mark.parametrize("month", MONTHS)
  403:     def test_period_cons_quarterly(self, month):
  404:         # bugs in scikits.timeseries
  405:         freq = f"Q-{month}"
  406:         exp = Period("1989Q3", freq=freq)
  407:         assert "1989Q3" in str(exp)
  408:         stamp = exp.to_timestamp("D", how="end")
  409:         p = Period(stamp, freq=freq)
  410:         assert p == exp
  411: 
  412:         stamp = exp.to_timestamp("3D", how="end")
  413:         p = Period(stamp, freq=freq)
  414:         assert p == exp
  415: 
  416:     @pytest.mark.parametrize("month", MONTHS)
  417:     def test_period_cons_annual(self, month):
  418:         # bugs in scikits.timeseries
  419:         freq = f"Y-{month}"
  420:         exp = Period("1989", freq=freq)
  421:         stamp = exp.to_timestamp("D", how="end") + timedelta(days=30)
  422:         p = Period(stamp, freq=freq)
  423: 
  424:         assert p == exp + 1
  425:         assert isinstance(p, Period)
  426: 
  427:     @pytest.mark.parametrize("day", DAYS)
  428:     @pytest.mark.parametrize("num", range(10, 17))
  429:     def test_period_cons_weekly(self, num, day):
  430:         daystr = f"2011-02-{num}"
  431:         freq = f"W-{day}"
  432: 
  433:         result = Period(daystr, freq=freq)
  434:         expected = Period(daystr, freq="D").asfreq(freq)
  435:         assert result == expected
  436:         assert isinstance(result, Period)
  437: 
  438:     def test_parse_week_str_roundstrip(self):
  439:         # GH#50803
  440:         per = Period("2017-01-23/2017-01-29")
  441:         assert per.freq.freqstr == "W-SUN"
  442: 
  443:         per = Period("2017-01-24/2017-01-30")
  444:         assert per.freq.freqstr == "W-MON"
  445: 
  446:         msg = "Could not parse as weekly-freq Period"
  447:         with pytest.raises(ValueError, match=msg):
  448:             # not 6 days apart
  449:             Period("2016-01-23/2017-01-29")
  450: 
  451:     def test_period_from_ordinal(self):
  452:         p = Period("2011-01", freq="M")
  453:         res = Period._from_ordinal(p.ordinal, freq=p.freq)
  454:         assert p == res
  455:         assert isinstance(res, Period)
  456: 
  457:     @pytest.mark.parametrize("freq", ["Y", "M", "D", "h"])
  458:     def test_construct_from_nat_string_and_freq(self, freq):
  459:         per = Period("NaT", freq=freq)
  460:         assert per is NaT
  461: 
  462:         per = Period("NaT", freq="2" + freq)
  463:         assert per is NaT
  464: 
  465:         per = Period("NaT", freq="3" + freq)
  466:         assert per is NaT
  467: 
  468:     def test_period_cons_nat(self):
  469:         p = Period("nat", freq="W-SUN")
  470:         assert p is NaT
  471: 
  472:         p = Period(iNaT, freq="D")
  473:         assert p is NaT
  474: 
  475:         p = Period(iNaT, freq="3D")
  476:         assert p is NaT
  477: 
  478:         p = Period(iNaT, freq="1D1h")
  479:         assert p is NaT
  480: 
  481:         p = Period("NaT")
  482:         assert p is NaT
  483: 
  484:         p = Period(iNaT)
  485:         assert p is NaT
  486: 
  487:     def test_period_cons_mult(self):
  488:         p1 = Period("2011-01", freq="3M")
  489:         p2 = Period("2011-01", freq="M")
  490:         assert p1.ordinal == p2.ordinal
  491: 
  492:         assert p1.freq == offsets.MonthEnd(3)
  493:         assert p1.freqstr == "3M"
  494: 
  495:         assert p2.freq == offsets.MonthEnd()
  496:         assert p2.freqstr == "M"
  497: 
  498:         result = p1 + 1
  499:         assert result.ordinal == (p2 + 3).ordinal
  500: 
  501:         assert result.freq == p1.freq
  502:         assert result.freqstr == "3M"
  503: 
  504:         result = p1 - 1
  505:         assert result.ordinal == (p2 - 3).ordinal
  506:         assert result.freq == p1.freq
  507:         assert result.freqstr == "3M"
  508: 
  509:         msg = "Frequency must be positive, because it represents span: -3M"
  510:         with pytest.raises(ValueError, match=msg):
  511:             Period("2011-01", freq="-3M")
  512: 
  513:         msg = "Frequency must be positive, because it represents span: 0M"
  514:         with pytest.raises(ValueError, match=msg):
  515:             Period("2011-01", freq="0M")
  516: 
  517:     def test_period_cons_combined(self):
  518:         p = [
  519:             (
  520:                 Period("2011-01", freq="1D1h"),
  521:                 Period("2011-01", freq="1h1D"),
  522:                 Period("2011-01", freq="h"),
  523:             ),
  524:             (
  525:                 Period(ordinal=1, freq="1D1h"),
  526:                 Period(ordinal=1, freq="1h1D"),
  527:                 Period(ordinal=1, freq="h"),
  528:             ),
  529:         ]
  530: 
  531:         for p1, p2, p3 in p:
  532:             assert p1.ordinal == p3.ordinal
  533:             assert p2.ordinal == p3.ordinal
  534: 
  535:             assert p1.freq == offsets.Hour(25)
  536:             assert p1.freqstr == "25h"
  537: 
  538:             assert p2.freq == offsets.Hour(25)
  539:             assert p2.freqstr == "25h"
  540: 
  541:             assert p3.freq == offsets.Hour()
  542:             assert p3.freqstr == "h"
  543: 
  544:             result = p1 + 1
  545:             assert result.ordinal == (p3 + 25).ordinal
  546:             assert result.freq == p1.freq
  547:             assert result.freqstr == "25h"
  548: 
  549:             result = p2 + 1
  550:             assert result.ordinal == (p3 + 25).ordinal
  551:             assert result.freq == p2.freq
  552:             assert result.freqstr == "25h"
  553: 
  554:             result = p1 - 1
  555:             assert result.ordinal == (p3 - 25).ordinal
  556:             assert result.freq == p1.freq
  557:             assert result.freqstr == "25h"
  558: 
  559:             result = p2 - 1
  560:             assert result.ordinal == (p3 - 25).ordinal
  561:             assert result.freq == p2.freq
  562:             assert result.freqstr == "25h"
  563: 
  564:         msg = "Frequency must be positive, because it represents span: -25h"
  565:         with pytest.raises(ValueError, match=msg):
  566:             Period("2011-01", freq="-1D1h")
  567:         with pytest.raises(ValueError, match=msg):
  568:             Period("2011-01", freq="-1h1D")
  569:         with pytest.raises(ValueError, match=msg):
  570:             Period(ordinal=1, freq="-1D1h")
  571:         with pytest.raises(ValueError, match=msg):
  572:             Period(ordinal=1, freq="-1h1D")
  573: 
  574:         msg = "Frequency must be positive, because it represents span: 0D"
  575:         with pytest.raises(ValueError, match=msg):
  576:             Period("2011-01", freq="0D0h")
  577:         with pytest.raises(ValueError, match=msg):
  578:             Period(ordinal=1, freq="0D0h")
  579: 
  580:         # You can only combine together day and intraday offsets
  581:         msg = "Invalid frequency: 1W1D"
  582:         with pytest.raises(ValueError, match=msg):
  583:             Period("2011-01", freq="1W1D")
  584:         msg = "Invalid frequency: 1D1W"
  585:         with pytest.raises(ValueError, match=msg):
  586:             Period("2011-01", freq="1D1W")
  587: 
  588:     @pytest.mark.parametrize("day", ["1970/01/01 ", "2020-12-31 ", "1981/09/13 "])
  589:     @pytest.mark.parametrize("hour", ["00:00:00", "00:00:01", "23:59:59", "12:00:59"])
  590:     @pytest.mark.parametrize(
  591:         "sec_float, expected",
  592:         [
  593:             (".000000001", 1),
  594:             (".000000999", 999),
  595:             (".123456789", 789),
  596:             (".999999999", 999),
  597:             (".999999000", 0),
  598:             # Test femtoseconds, attoseconds, picoseconds are dropped like Timestamp
  599:             (".999999001123", 1),
  600:             (".999999001123456", 1),
  601:             (".999999001123456789", 1),
  602:         ],
  603:     )
  604:     def test_period_constructor_nanosecond(self, day, hour, sec_float, expected):
  605:         # GH 34621
  606: 
  607:         assert Period(day + hour + sec_float).start_time.nanosecond == expected
  608: 
  609:     @pytest.mark.parametrize("hour", range(24))
  610:     def test_period_large_ordinal(self, hour):
  611:         # Issue #36430
  612:         # Integer overflow for Period over the maximum timestamp
  613:         p = Period(ordinal=2562048 + hour, freq="1h")
  614:         assert p.hour == hour
  615: 
  616: 
  617: class TestPeriodMethods:
  618:     def test_round_trip(self):
  619:         p = Period("2000Q1")
  620:         new_p = tm.round_trip_pickle(p)
  621:         assert new_p == p
  622: 
  623:     def test_hash(self):
  624:         assert hash(Period("2011-01", freq="M")) == hash(Period("2011-01", freq="M"))
  625: 
  626:         assert hash(Period("2011-01-01", freq="D")) != hash(Period("2011-01", freq="M"))
  627: 
  628:         assert hash(Period("2011-01", freq="3M")) != hash(Period("2011-01", freq="2M"))
  629: 
  630:         assert hash(Period("2011-01", freq="M")) != hash(Period("2011-02", freq="M"))
  631: 
  632:     # --------------------------------------------------------------
  633:     # to_timestamp
  634: 
  635:     def test_to_timestamp_mult(self):
  636:         p = Period("2011-01", freq="M")
  637:         assert p.to_timestamp(how="S") == Timestamp("2011-01-01")
  638:         expected = Timestamp("2011-02-01") - Timedelta(1, "ns")
  639:         assert p.to_timestamp(how="E") == expected
  640: 
  641:         p = Period("2011-01", freq="3M")
  642:         assert p.to_timestamp(how="S") == Timestamp("2011-01-01")
  643:         expected = Timestamp("2011-04-01") - Timedelta(1, "ns")
  644:         assert p.to_timestamp(how="E") == expected
  645: 
  646:     @pytest.mark.filterwarnings(
  647:         "ignore:Period with BDay freq is deprecated:FutureWarning"
  648:     )
  649:     def test_to_timestamp(self):
  650:         p = Period("1982", freq="Y")
  651:         start_ts = p.to_timestamp(how="S")
  652:         aliases = ["s", "StarT", "BEGIn"]
  653:         for a in aliases:
  654:             assert start_ts == p.to_timestamp("D", how=a)
  655:             # freq with mult should not affect to the result
  656:             assert start_ts == p.to_timestamp("3D", how=a)
  657: 
  658:         end_ts = p.to_timestamp(how="E")
  659:         aliases = ["e", "end", "FINIsH"]
  660:         for a in aliases:
  661:             assert end_ts == p.to_timestamp("D", how=a)
  662:             assert end_ts == p.to_timestamp("3D", how=a)
  663: 
  664:         from_lst = ["Y", "Q", "M", "W", "B", "D", "h", "Min", "s"]
  665: 
  666:         def _ex(p):
  667:             if p.freq == "B":
  668:                 return p.start_time + Timedelta(days=1, nanoseconds=-1)
  669:             return Timestamp((p + p.freq).start_time._value - 1)
  670: 
  671:         for fcode in from_lst:
  672:             p = Period("1982", freq=fcode)
  673:             result = p.to_timestamp().to_period(fcode)
  674:             assert result == p
  675: 
  676:             assert p.start_time == p.to_timestamp(how="S")
  677: 
  678:             assert p.end_time == _ex(p)
  679: 
  680:         # Frequency other than daily
  681: 
  682:         p = Period("1985", freq="Y")
  683: 
  684:         result = p.to_timestamp("h", how="end")
  685:         expected = Timestamp(1986, 1, 1) - Timedelta(1, "ns")
  686:         assert result == expected
  687:         result = p.to_timestamp("3h", how="end")
  688:         assert result == expected
  689: 
  690:         result = p.to_timestamp("min", how="end")
  691:         expected = Timestamp(1986, 1, 1) - Timedelta(1, "ns")
  692:         assert result == expected
  693:         result = p.to_timestamp("2min", how="end")
  694:         assert result == expected
  695: 
  696:         result = p.to_timestamp(how="end")
  697:         expected = Timestamp(1986, 1, 1) - Timedelta(1, "ns")
  698:         assert result == expected
  699: 
  700:         expected = datetime(1985, 1, 1)
  701:         result = p.to_timestamp("h", how="start")
  702:         assert result == expected
  703:         result = p.to_timestamp("min", how="start")
  704:         assert result == expected
  705:         result = p.to_timestamp("s", how="start")
  706:         assert result == expected
  707:         result = p.to_timestamp("3h", how="start")
  708:         assert result == expected
  709:         result = p.to_timestamp("5s", how="start")
  710:         assert result == expected
  711: 
  712:     def test_to_timestamp_business_end(self):
  713:         with tm.assert_produces_warning(FutureWarning, match=bday_msg):
  714:             per = Period("1990-01-05", "B")  # Friday
  715:             result = per.to_timestamp("B", how="E")
  716: 
  717:         expected = Timestamp("1990-01-06") - Timedelta(nanoseconds=1)
  718:         assert result == expected
  719: 
  720:     @pytest.mark.parametrize(
  721:         "ts, expected",
  722:         [
  723:             ("1970-01-01 00:00:00", 0),
  724:             ("1970-01-01 00:00:00.000001", 1),
  725:             ("1970-01-01 00:00:00.00001", 10),
  726:             ("1970-01-01 00:00:00.499", 499000),
  727:             ("1999-12-31 23:59:59.999", 999000),
  728:             ("1999-12-31 23:59:59.999999", 999999),
  729:             ("2050-12-31 23:59:59.5", 500000),
  730:             ("2050-12-31 23:59:59.500001", 500001),
  731:             ("2050-12-31 23:59:59.123456", 123456),
  732:         ],
  733:     )
  734:     @pytest.mark.parametrize("freq", [None, "us", "ns"])
  735:     def test_to_timestamp_microsecond(self, ts, expected, freq):
  736:         # GH 24444
  737:         result = Period(ts).to_timestamp(freq=freq).microsecond
  738:         assert result == expected
  739: 
  740:     # --------------------------------------------------------------
  741:     # Rendering: __repr__, strftime, etc
  742: 
  743:     @pytest.mark.parametrize(
  744:         "str_ts,freq,str_res,str_freq",
  745:         (
  746:             ("Jan-2000", None, "2000-01", "M"),
  747:             ("2000-12-15", None, "2000-12-15", "D"),
  748:             (
  749:                 "2000-12-15 13:45:26.123456789",
  750:                 "ns",
  751:                 "2000-12-15 13:45:26.123456789",
  752:                 "ns",
  753:             ),
  754:             ("2000-12-15 13:45:26.123456789", "us", "2000-12-15 13:45:26.123456", "us"),
  755:             ("2000-12-15 13:45:26.123456", None, "2000-12-15 13:45:26.123456", "us"),
  756:             ("2000-12-15 13:45:26.123456789", "ms", "2000-12-15 13:45:26.123", "ms"),
  757:             ("2000-12-15 13:45:26.123", None, "2000-12-15 13:45:26.123", "ms"),
  758:             ("2000-12-15 13:45:26", "s", "2000-12-15 13:45:26", "s"),
  759:             ("2000-12-15 13:45:26", "min", "2000-12-15 13:45", "min"),
  760:             ("2000-12-15 13:45:26", "h", "2000-12-15 13:00", "h"),
  761:             ("2000-12-15", "Y", "2000", "Y-DEC"),
  762:             ("2000-12-15", "Q", "2000Q4", "Q-DEC"),
  763:             ("2000-12-15", "M", "2000-12", "M"),
  764:             ("2000-12-15", "W", "2000-12-11/2000-12-17", "W-SUN"),
  765:             ("2000-12-15", "D", "2000-12-15", "D"),
  766:             ("2000-12-15", "B", "2000-12-15", "B"),
  767:         ),
  768:     )
  769:     @pytest.mark.filterwarnings(
  770:         "ignore:Period with BDay freq is deprecated:FutureWarning"
  771:     )
  772:     def test_repr(self, str_ts, freq, str_res, str_freq):
  773:         p = Period(str_ts, freq=freq)
  774:         assert str(p) == str_res
  775:         assert repr(p) == f"Period('{str_res}', '{str_freq}')"
  776: 
  777:     def test_repr_nat(self):
  778:         p = Period("nat", freq="M")
  779:         assert repr(NaT) in repr(p)
  780: 
  781:     def test_strftime(self):
  782:         # GH#3363
  783:         p = Period("2000-1-1 12:34:12", freq="s")
  784:         res = p.strftime("%Y-%m-%d %H:%M:%S")
  785:         assert res == "2000-01-01 12:34:12"
  786:         assert isinstance(res, str)
  787: 
  788: 
  789: class TestPeriodProperties:
  790:     """Test properties such as year, month, weekday, etc...."""
  791: 
  792:     @pytest.mark.parametrize("freq", ["Y", "M", "D", "h"])
  793:     def test_is_leap_year(self, freq):
  794:         # GH 13727
  795:         p = Period("2000-01-01 00:00:00", freq=freq)
  796:         assert p.is_leap_year
  797:         assert isinstance(p.is_leap_year, bool)
  798: 
  799:         p = Period("1999-01-01 00:00:00", freq=freq)
  800:         assert not p.is_leap_year
  801: 
  802:         p = Period("2004-01-01 00:00:00", freq=freq)
  803:         assert p.is_leap_year
  804: 
  805:         p = Period("2100-01-01 00:00:00", freq=freq)
  806:         assert not p.is_leap_year
  807: 
  808:     def test_quarterly_negative_ordinals(self):
  809:         p = Period(ordinal=-1, freq="Q-DEC")
  810:         assert p.year == 1969
  811:         assert p.quarter == 4
  812:         assert isinstance(p, Period)
  813: 
  814:         p = Period(ordinal=-2, freq="Q-DEC")
  815:         assert p.year == 1969
  816:         assert p.quarter == 3
  817:         assert isinstance(p, Period)
  818: 
  819:         p = Period(ordinal=-2, freq="M")
  820:         assert p.year == 1969
  821:         assert p.month == 11
  822:         assert isinstance(p, Period)
  823: 
  824:     def test_freq_str(self):
  825:         i1 = Period("1982", freq="Min")
  826:         assert i1.freq == offsets.Minute()
  827:         assert i1.freqstr == "min"
  828: 
  829:     @pytest.mark.filterwarnings(
  830:         "ignore:Period with BDay freq is deprecated:FutureWarning"
  831:     )
  832:     def test_period_deprecated_freq(self):
  833:         cases = {
  834:             "M": ["MTH", "MONTH", "MONTHLY", "Mth", "month", "monthly"],
  835:             "B": ["BUS", "BUSINESS", "BUSINESSLY", "WEEKDAY", "bus"],
  836:             "D": ["DAY", "DLY", "DAILY", "Day", "Dly", "Daily"],
  837:             "h": ["HR", "HOUR", "HRLY", "HOURLY", "hr", "Hour", "HRly"],
  838:             "min": ["minute", "MINUTE", "MINUTELY", "minutely"],
  839:             "s": ["sec", "SEC", "SECOND", "SECONDLY", "second"],
  840:             "ms": ["MILLISECOND", "MILLISECONDLY", "millisecond"],
  841:             "us": ["MICROSECOND", "MICROSECONDLY", "microsecond"],
  842:             "ns": ["NANOSECOND", "NANOSECONDLY", "nanosecond"],
  843:         }
  844: 
  845:         msg = INVALID_FREQ_ERR_MSG
  846:         for exp, freqs in cases.items():
  847:             for freq in freqs:
  848:                 with pytest.raises(ValueError, match=msg):
  849:                     Period("2016-03-01 09:00", freq=freq)
  850:                 with pytest.raises(ValueError, match=msg):
  851:                     Period(ordinal=1, freq=freq)
  852: 
  853:             # check supported freq-aliases still works
  854:             p1 = Period("2016-03-01 09:00", freq=exp)
  855:             p2 = Period(ordinal=1, freq=exp)
  856:             assert isinstance(p1, Period)
  857:             assert isinstance(p2, Period)
  858: 
  859:     @staticmethod
  860:     def _period_constructor(bound, offset):
  861:         return Period(
  862:             year=bound.year,
  863:             month=bound.month,
  864:             day=bound.day,
  865:             hour=bound.hour,
  866:             minute=bound.minute,
  867:             second=bound.second + offset,
  868:             freq="us",
  869:         )
  870: 
  871:     @pytest.mark.parametrize("bound, offset", [(Timestamp.min, -1), (Timestamp.max, 1)])
  872:     @pytest.mark.parametrize("period_property", ["start_time", "end_time"])
  873:     def test_outer_bounds_start_and_end_time(self, bound, offset, period_property):
  874:         # GH #13346
  875:         period = TestPeriodProperties._period_constructor(bound, offset)
  876:         with pytest.raises(OutOfBoundsDatetime, match="Out of bounds nanosecond"):
  877:             getattr(period, period_property)
  878: 
  879:     @pytest.mark.parametrize("bound, offset", [(Timestamp.min, -1), (Timestamp.max, 1)])
  880:     @pytest.mark.parametrize("period_property", ["start_time", "end_time"])
  881:     def test_inner_bounds_start_and_end_time(self, bound, offset, period_property):
  882:         # GH #13346
  883:         period = TestPeriodProperties._period_constructor(bound, -offset)
  884:         expected = period.to_timestamp().round(freq="s")
  885:         assert getattr(period, period_property).round(freq="s") == expected
  886:         expected = (bound - offset * Timedelta(1, unit="s")).floor("s")
  887:         assert getattr(period, period_property).floor("s") == expected
  888: 
  889:     def test_start_time(self):
  890:         freq_lst = ["Y", "Q", "M", "D", "h", "min", "s"]
  891:         xp = datetime(2012, 1, 1)
  892:         for f in freq_lst:
  893:             p = Period("2012", freq=f)
  894:             assert p.start_time == xp
  895:         with tm.assert_produces_warning(FutureWarning, match=bday_msg):
  896:             assert Period("2012", freq="B").start_time == datetime(2012, 1, 2)
  897:         assert Period("2012", freq="W").start_time == datetime(2011, 12, 26)
  898: 
  899:     def test_end_time(self):
  900:         p = Period("2012", freq="Y")
  901: 
  902:         def _ex(*args):
  903:             return Timestamp(Timestamp(datetime(*args)).as_unit("ns")._value - 1)
  904: 
  905:         xp = _ex(2013, 1, 1)
  906:         assert xp == p.end_time
  907: 
  908:         p = Period("2012", freq="Q")
  909:         xp = _ex(2012, 4, 1)
  910:         assert xp == p.end_time
  911: 
  912:         p = Period("2012", freq="M")
  913:         xp = _ex(2012, 2, 1)
  914:         assert xp == p.end_time
  915: 
  916:         p = Period("2012", freq="D")
  917:         xp = _ex(2012, 1, 2)
  918:         assert xp == p.end_time
  919: 
  920:         p = Period("2012", freq="h")
  921:         xp = _ex(2012, 1, 1, 1)
  922:         assert xp == p.end_time
  923: 
  924:         with tm.assert_produces_warning(FutureWarning, match=bday_msg):
  925:             p = Period("2012", freq="B")
  926:             xp = _ex(2012, 1, 3)
  927:             assert xp == p.end_time
  928: 
  929:         p = Period("2012", freq="W")
  930:         xp = _ex(2012, 1, 2)
  931:         assert xp == p.end_time
  932: 
  933:         # Test for GH 11738
  934:         p = Period("2012", freq="15D")
  935:         xp = _ex(2012, 1, 16)
  936:         assert xp == p.end_time
  937: 
  938:         p = Period("2012", freq="1D1h")
  939:         xp = _ex(2012, 1, 2, 1)
  940:         assert xp == p.end_time
  941: 
  942:         p = Period("2012", freq="1h1D")
  943:         xp = _ex(2012, 1, 2, 1)
  944:         assert xp == p.end_time
  945: 
  946:     def test_end_time_business_friday(self):
  947:         # GH#34449
  948:         with tm.assert_produces_warning(FutureWarning, match=bday_msg):
  949:             per = Period("1990-01-05", "B")
  950:             result = per.end_time
  951: 
  952:         expected = Timestamp("1990-01-06") - Timedelta(nanoseconds=1)
  953:         assert result == expected
  954: 
  955:     def test_anchor_week_end_time(self):
  956:         def _ex(*args):
  957:             return Timestamp(Timestamp(datetime(*args)).as_unit("ns")._value - 1)
  958: 
  959:         p = Period("2013-1-1", "W-SAT")
  960:         xp = _ex(2013, 1, 6)
  961:         assert p.end_time == xp
  962: 
  963:     def test_properties_annually(self):
  964:         # Test properties on Periods with annually frequency.
  965:         a_date = Period(freq="Y", year=2007)
  966:         assert a_date.year == 2007
  967: 
  968:     def test_properties_quarterly(self):
  969:         # Test properties on Periods with daily frequency.
  970:         qedec_date = Period(freq="Q-DEC", year=2007, quarter=1)
  971:         qejan_date = Period(freq="Q-JAN", year=2007, quarter=1)
  972:         qejun_date = Period(freq="Q-JUN", year=2007, quarter=1)
  973:         #
  974:         for x in range(3):
  975:             for qd in (qedec_date, qejan_date, qejun_date):
  976:                 assert (qd + x).qyear == 2007
  977:                 assert (qd + x).quarter == x + 1
  978: 
  979:     def test_properties_monthly(self):
  980:         # Test properties on Periods with daily frequency.
  981:         m_date = Period(freq="M", year=2007, month=1)
  982:         for x in range(11):
  983:             m_ival_x = m_date + x
  984:             assert m_ival_x.year == 2007
  985:             if 1 <= x + 1 <= 3:
  986:                 assert m_ival_x.quarter == 1
  987:             elif 4 <= x + 1 <= 6:
  988:                 assert m_ival_x.quarter == 2
  989:             elif 7 <= x + 1 <= 9:
  990:                 assert m_ival_x.quarter == 3
  991:             elif 10 <= x + 1 <= 12:
  992:                 assert m_ival_x.quarter == 4
  993:             assert m_ival_x.month == x + 1
  994: 
  995:     def test_properties_weekly(self):
  996:         # Test properties on Periods with daily frequency.
  997:         w_date = Period(freq="W", year=2007, month=1, day=7)
  998:         #
  999:         assert w_date.year == 2007
 1000:         assert w_date.quarter == 1
 1001:         assert w_date.month == 1
 1002:         assert w_date.week == 1
 1003:         assert (w_date - 1).week == 52
 1004:         assert w_date.days_in_month == 31
 1005:         assert Period(freq="W", year=2012, month=2, day=1).days_in_month == 29
 1006: 
 1007:     def test_properties_weekly_legacy(self):
 1008:         # Test properties on Periods with daily frequency.
 1009:         w_date = Period(freq="W", year=2007, month=1, day=7)
 1010:         assert w_date.year == 2007
 1011:         assert w_date.quarter == 1
 1012:         assert w_date.month == 1
 1013:         assert w_date.week == 1
 1014:         assert (w_date - 1).week == 52
 1015:         assert w_date.days_in_month == 31
 1016: 
 1017:         exp = Period(freq="W", year=2012, month=2, day=1)
 1018:         assert exp.days_in_month == 29
 1019: 
 1020:         msg = INVALID_FREQ_ERR_MSG
 1021:         with pytest.raises(ValueError, match=msg):
 1022:             Period(freq="WK", year=2007, month=1, day=7)
 1023: 
 1024:     def test_properties_daily(self):
 1025:         # Test properties on Periods with daily frequency.
 1026:         with tm.assert_produces_warning(FutureWarning, match=bday_msg):
 1027:             b_date = Period(freq="B", year=2007, month=1, day=1)
 1028:         #
 1029:         assert b_date.year == 2007
 1030:         assert b_date.quarter == 1
 1031:         assert b_date.month == 1
 1032:         assert b_date.day == 1
 1033:         assert b_date.weekday == 0
 1034:         assert b_date.dayofyear == 1
 1035:         assert b_date.days_in_month == 31
 1036:         with tm.assert_produces_warning(FutureWarning, match=bday_msg):
 1037:             assert Period(freq="B", year=2012, month=2, day=1).days_in_month == 29
 1038: 
 1039:         d_date = Period(freq="D", year=2007, month=1, day=1)
 1040: 
 1041:         assert d_date.year == 2007
 1042:         assert d_date.quarter == 1
 1043:         assert d_date.month == 1
 1044:         assert d_date.day == 1
 1045:         assert d_date.weekday == 0
 1046:         assert d_date.dayofyear == 1
 1047:         assert d_date.days_in_month == 31
 1048:         assert Period(freq="D", year=2012, month=2, day=1).days_in_month == 29
 1049: 
 1050:     def test_properties_hourly(self):
 1051:         # Test properties on Periods with hourly frequency.
 1052:         h_date1 = Period(freq="h", year=2007, month=1, day=1, hour=0)
 1053:         h_date2 = Period(freq="2h", year=2007, month=1, day=1, hour=0)
 1054: 
 1055:         for h_date in [h_date1, h_date2]:
 1056:             assert h_date.year == 2007
 1057:             assert h_date.quarter == 1
 1058:             assert h_date.month == 1
 1059:             assert h_date.day == 1
 1060:             assert h_date.weekday == 0
 1061:             assert h_date.dayofyear == 1
 1062:             assert h_date.hour == 0
 1063:             assert h_date.days_in_month == 31
 1064:             assert (
 1065:                 Period(freq="h", year=2012, month=2, day=1, hour=0).days_in_month == 29
 1066:             )
 1067: 
 1068:     def test_properties_minutely(self):
 1069:         # Test properties on Periods with minutely frequency.
 1070:         t_date = Period(freq="Min", year=2007, month=1, day=1, hour=0, minute=0)
 1071:         #
 1072:         assert t_date.quarter == 1
 1073:         assert t_date.month == 1
 1074:         assert t_date.day == 1
 1075:         assert t_date.weekday == 0
 1076:         assert t_date.dayofyear == 1
 1077:         assert t_date.hour == 0
 1078:         assert t_date.minute == 0
 1079:         assert t_date.days_in_month == 31
 1080:         assert (
 1081:             Period(freq="D", year=2012, month=2, day=1, hour=0, minute=0).days_in_month
 1082:             == 29
 1083:         )
 1084: 
 1085:     def test_properties_secondly(self):
 1086:         # Test properties on Periods with secondly frequency.
 1087:         s_date = Period(
 1088:             freq="Min", year=2007, month=1, day=1, hour=0, minute=0, second=0
 1089:         )
 1090:         #
 1091:         assert s_date.year == 2007
 1092:         assert s_date.quarter == 1
 1093:         assert s_date.month == 1
 1094:         assert s_date.day == 1
 1095:         assert s_date.weekday == 0
 1096:         assert s_date.dayofyear == 1
 1097:         assert s_date.hour == 0
 1098:         assert s_date.minute == 0
 1099:         assert s_date.second == 0
 1100:         assert s_date.days_in_month == 31
 1101:         assert (
 1102:             Period(
 1103:                 freq="Min", year=2012, month=2, day=1, hour=0, minute=0, second=0
 1104:             ).days_in_month
 1105:             == 29
 1106:         )
 1107: 
 1108: 
 1109: class TestPeriodComparisons:
 1110:     def test_sort_periods(self):
 1111:         jan = Period("2000-01", "M")
 1112:         feb = Period("2000-02", "M")
 1113:         mar = Period("2000-03", "M")
 1114:         periods = [mar, jan, feb]
 1115:         correctPeriods = [jan, feb, mar]
 1116:         assert sorted(periods) == correctPeriods
 1117: 
 1118: 
 1119: def test_period_immutable():
 1120:     # see gh-17116
 1121:     msg = "not writable"
 1122: 
 1123:     per = Period("2014Q1")
 1124:     with pytest.raises(AttributeError, match=msg):
 1125:         per.ordinal = 14
 1126: 
 1127:     freq = per.freq
 1128:     with pytest.raises(AttributeError, match=msg):
 1129:         per.freq = 2 * freq
 1130: 
 1131: 
 1132: def test_small_year_parsing():
 1133:     per1 = Period("0001-01-07", "D")
 1134:     assert per1.year == 1
 1135:     assert per1.day == 7
 1136: 
 1137: 
 1138: def test_negone_ordinals():
 1139:     freqs = ["Y", "M", "Q", "D", "h", "min", "s"]
 1140: 
 1141:     period = Period(ordinal=-1, freq="D")
 1142:     for freq in freqs:
 1143:         repr(period.asfreq(freq))
 1144: 
 1145:     for freq in freqs:
 1146:         period = Period(ordinal=-1, freq=freq)
 1147:         repr(period)
 1148:         assert period.year == 1969
 1149: 
 1150:     with tm.assert_produces_warning(FutureWarning, match=bday_msg):
 1151:         period = Period(ordinal=-1, freq="B")
 1152:     repr(period)
 1153:     period = Period(ordinal=-1, freq="W")
 1154:     repr(period)
