    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: import operator
    6: 
    7: import numpy as np
    8: import pytest
    9: import pytz
   10: 
   11: from pandas._libs.tslibs import iNaT
   12: from pandas.compat.numpy import np_version_gte1p24p3
   13: 
   14: from pandas import (
   15:     DatetimeIndex,
   16:     DatetimeTZDtype,
   17:     Index,
   18:     NaT,
   19:     Period,
   20:     Series,
   21:     Timedelta,
   22:     TimedeltaIndex,
   23:     Timestamp,
   24:     isna,
   25:     offsets,
   26: )
   27: import pandas._testing as tm
   28: from pandas.core import roperator
   29: from pandas.core.arrays import (
   30:     DatetimeArray,
   31:     PeriodArray,
   32:     TimedeltaArray,
   33: )
   34: 
   35: 
   36: class TestNaTFormatting:
   37:     def test_repr(self):
   38:         assert repr(NaT) == "NaT"
   39: 
   40:     def test_str(self):
   41:         assert str(NaT) == "NaT"
   42: 
   43:     def test_isoformat(self):
   44:         assert NaT.isoformat() == "NaT"
   45: 
   46: 
   47: @pytest.mark.parametrize(
   48:     "nat,idx",
   49:     [
   50:         (Timestamp("NaT"), DatetimeArray),
   51:         (Timedelta("NaT"), TimedeltaArray),
   52:         (Period("NaT", freq="M"), PeriodArray),
   53:     ],
   54: )
   55: def test_nat_fields(nat, idx):
   56:     for field in idx._field_ops:
   57:         # weekday is a property of DTI, but a method
   58:         # on NaT/Timestamp for compat with datetime
   59:         if field == "weekday":
   60:             continue
   61: 
   62:         result = getattr(NaT, field)
   63:         assert np.isnan(result)
   64: 
   65:         result = getattr(nat, field)
   66:         assert np.isnan(result)
   67: 
   68:     for field in idx._bool_ops:
   69:         result = getattr(NaT, field)
   70:         assert result is False
   71: 
   72:         result = getattr(nat, field)
   73:         assert result is False
   74: 
   75: 
   76: def test_nat_vector_field_access():
   77:     idx = DatetimeIndex(["1/1/2000", None, None, "1/4/2000"])
   78: 
   79:     for field in DatetimeArray._field_ops:
   80:         # weekday is a property of DTI, but a method
   81:         # on NaT/Timestamp for compat with datetime
   82:         if field == "weekday":
   83:             continue
   84: 
   85:         result = getattr(idx, field)
   86:         expected = Index([getattr(x, field) for x in idx])
   87:         tm.assert_index_equal(result, expected)
   88: 
   89:     ser = Series(idx)
   90: 
   91:     for field in DatetimeArray._field_ops:
   92:         # weekday is a property of DTI, but a method
   93:         # on NaT/Timestamp for compat with datetime
   94:         if field == "weekday":
   95:             continue
   96: 
   97:         result = getattr(ser.dt, field)
   98:         expected = [getattr(x, field) for x in idx]
   99:         tm.assert_series_equal(result, Series(expected))
  100: 
  101:     for field in DatetimeArray._bool_ops:
  102:         result = getattr(ser.dt, field)
  103:         expected = [getattr(x, field) for x in idx]
  104:         tm.assert_series_equal(result, Series(expected))
  105: 
  106: 
  107: @pytest.mark.parametrize("klass", [Timestamp, Timedelta, Period])
  108: @pytest.mark.parametrize(
  109:     "value", [None, np.nan, iNaT, float("nan"), NaT, "NaT", "nat", "", "NAT"]
  110: )
  111: def test_identity(klass, value):
  112:     assert klass(value) is NaT
  113: 
  114: 
  115: @pytest.mark.parametrize("klass", [Timestamp, Timedelta])
  116: @pytest.mark.parametrize("method", ["round", "floor", "ceil"])
  117: @pytest.mark.parametrize("freq", ["s", "5s", "min", "5min", "h", "5h"])
  118: def test_round_nat(klass, method, freq):
  119:     # see gh-14940
  120:     ts = klass("nat")
  121: 
  122:     round_method = getattr(ts, method)
  123:     assert round_method(freq) is ts
  124: 
  125: 
  126: @pytest.mark.parametrize(
  127:     "method",
  128:     [
  129:         "astimezone",
  130:         "combine",
  131:         "ctime",
  132:         "dst",
  133:         "fromordinal",
  134:         "fromtimestamp",
  135:         "fromisocalendar",
  136:         "isocalendar",
  137:         "strftime",
  138:         "strptime",
  139:         "time",
  140:         "timestamp",
  141:         "timetuple",
  142:         "timetz",
  143:         "toordinal",
  144:         "tzname",
  145:         "utcfromtimestamp",
  146:         "utcnow",
  147:         "utcoffset",
  148:         "utctimetuple",
  149:         "timestamp",
  150:     ],
  151: )
  152: def test_nat_methods_raise(method):
  153:     # see gh-9513, gh-17329
  154:     msg = f"NaTType does not support {method}"
  155: 
  156:     with pytest.raises(ValueError, match=msg):
  157:         getattr(NaT, method)()
  158: 
  159: 
  160: @pytest.mark.parametrize("method", ["weekday", "isoweekday"])
  161: def test_nat_methods_nan(method):
  162:     # see gh-9513, gh-17329
  163:     assert np.isnan(getattr(NaT, method)())
  164: 
  165: 
  166: @pytest.mark.parametrize(
  167:     "method", ["date", "now", "replace", "today", "tz_convert", "tz_localize"]
  168: )
  169: def test_nat_methods_nat(method):
  170:     # see gh-8254, gh-9513, gh-17329
  171:     assert getattr(NaT, method)() is NaT
  172: 
  173: 
  174: @pytest.mark.parametrize(
  175:     "get_nat", [lambda x: NaT, lambda x: Timedelta(x), lambda x: Timestamp(x)]
  176: )
  177: def test_nat_iso_format(get_nat):
  178:     # see gh-12300
  179:     assert get_nat("NaT").isoformat() == "NaT"
  180:     assert get_nat("NaT").isoformat(timespec="nanoseconds") == "NaT"
  181: 
  182: 
  183: @pytest.mark.parametrize(
  184:     "klass,expected",
  185:     [
  186:         (Timestamp, ["normalize", "to_julian_date", "to_period", "unit"]),
  187:         (
  188:             Timedelta,
  189:             [
  190:                 "components",
  191:                 "resolution_string",
  192:                 "to_pytimedelta",
  193:                 "to_timedelta64",
  194:                 "unit",
  195:                 "view",
  196:             ],
  197:         ),
  198:     ],
  199: )
  200: def test_missing_public_nat_methods(klass, expected):
  201:     # see gh-17327
  202:     #
  203:     # NaT should have *most* of the Timestamp and Timedelta methods.
  204:     # Here, we check which public methods NaT does not have. We
  205:     # ignore any missing private methods.
  206:     nat_names = dir(NaT)
  207:     klass_names = dir(klass)
  208: 
  209:     missing = [x for x in klass_names if x not in nat_names and not x.startswith("_")]
  210:     missing.sort()
  211: 
  212:     assert missing == expected
  213: 
  214: 
  215: def _get_overlap_public_nat_methods(klass, as_tuple=False):
  216:     """
  217:     Get overlapping public methods between NaT and another class.
  218: 
  219:     Parameters
  220:     ----------
  221:     klass : type
  222:         The class to compare with NaT
  223:     as_tuple : bool, default False
  224:         Whether to return a list of tuples of the form (klass, method).
  225: 
  226:     Returns
  227:     -------
  228:     overlap : list
  229:     """
  230:     nat_names = dir(NaT)
  231:     klass_names = dir(klass)
  232: 
  233:     overlap = [
  234:         x
  235:         for x in nat_names
  236:         if x in klass_names and not x.startswith("_") and callable(getattr(klass, x))
  237:     ]
  238: 
  239:     # Timestamp takes precedence over Timedelta in terms of overlap.
  240:     if klass is Timedelta:
  241:         ts_names = dir(Timestamp)
  242:         overlap = [x for x in overlap if x not in ts_names]
  243: 
  244:     if as_tuple:
  245:         overlap = [(klass, method) for method in overlap]
  246: 
  247:     overlap.sort()
  248:     return overlap
  249: 
  250: 
  251: @pytest.mark.parametrize(
  252:     "klass,expected",
  253:     [
  254:         (
  255:             Timestamp,
  256:             [
  257:                 "as_unit",
  258:                 "astimezone",
  259:                 "ceil",
  260:                 "combine",
  261:                 "ctime",
  262:                 "date",
  263:                 "day_name",
  264:                 "dst",
  265:                 "floor",
  266:                 "fromisocalendar",
  267:                 "fromisoformat",
  268:                 "fromordinal",
  269:                 "fromtimestamp",
  270:                 "isocalendar",
  271:                 "isoformat",
  272:                 "isoweekday",
  273:                 "month_name",
  274:                 "now",
  275:                 "replace",
  276:                 "round",
  277:                 "strftime",
  278:                 "strptime",
  279:                 "time",
  280:                 "timestamp",
  281:                 "timetuple",
  282:                 "timetz",
  283:                 "to_datetime64",
  284:                 "to_numpy",
  285:                 "to_pydatetime",
  286:                 "today",
  287:                 "toordinal",
  288:                 "tz_convert",
  289:                 "tz_localize",
  290:                 "tzname",
  291:                 "utcfromtimestamp",
  292:                 "utcnow",
  293:                 "utcoffset",
  294:                 "utctimetuple",
  295:                 "weekday",
  296:             ],
  297:         ),
  298:         (Timedelta, ["total_seconds"]),
  299:     ],
  300: )
  301: def test_overlap_public_nat_methods(klass, expected):
  302:     # see gh-17327
  303:     #
  304:     # NaT should have *most* of the Timestamp and Timedelta methods.
  305:     # In case when Timestamp, Timedelta, and NaT are overlap, the overlap
  306:     # is considered to be with Timestamp and NaT, not Timedelta.
  307:     assert _get_overlap_public_nat_methods(klass) == expected
  308: 
  309: 
  310: @pytest.mark.parametrize(
  311:     "compare",
  312:     (
  313:         _get_overlap_public_nat_methods(Timestamp, True)
  314:         + _get_overlap_public_nat_methods(Timedelta, True)
  315:     ),
  316:     ids=lambda x: f"{x[0].__name__}.{x[1]}",
  317: )
  318: def test_nat_doc_strings(compare):
  319:     # see gh-17327
  320:     #
  321:     # The docstrings for overlapping methods should match.
  322:     klass, method = compare
  323:     klass_doc = getattr(klass, method).__doc__
  324: 
  325:     if klass == Timestamp and method == "isoformat":
  326:         pytest.skip(
  327:             "Ignore differences with Timestamp.isoformat() as they're intentional"
  328:         )
  329: 
  330:     if method == "to_numpy":
  331:         # GH#44460 can return either dt64 or td64 depending on dtype,
  332:         #  different docstring is intentional
  333:         pytest.skip(f"different docstring for {method} is intentional")
  334: 
  335:     nat_doc = getattr(NaT, method).__doc__
  336:     assert klass_doc == nat_doc
  337: 
  338: 
  339: _ops = {
  340:     "left_plus_right": lambda a, b: a + b,
  341:     "right_plus_left": lambda a, b: b + a,
  342:     "left_minus_right": lambda a, b: a - b,
  343:     "right_minus_left": lambda a, b: b - a,
  344:     "left_times_right": lambda a, b: a * b,
  345:     "right_times_left": lambda a, b: b * a,
  346:     "left_div_right": lambda a, b: a / b,
  347:     "right_div_left": lambda a, b: b / a,
  348: }
  349: 
  350: 
  351: @pytest.mark.parametrize("op_name", list(_ops.keys()))
  352: @pytest.mark.parametrize(
  353:     "value,val_type",
  354:     [
  355:         (2, "scalar"),
  356:         (1.5, "floating"),
  357:         (np.nan, "floating"),
  358:         ("foo", "str"),
  359:         (timedelta(3600), "timedelta"),
  360:         (Timedelta("5s"), "timedelta"),
  361:         (datetime(2014, 1, 1), "timestamp"),
  362:         (Timestamp("2014-01-01"), "timestamp"),
  363:         (Timestamp("2014-01-01", tz="UTC"), "timestamp"),
  364:         (Timestamp("2014-01-01", tz="US/Eastern"), "timestamp"),
  365:         (pytz.timezone("Asia/Tokyo").localize(datetime(2014, 1, 1)), "timestamp"),
  366:     ],
  367: )
  368: def test_nat_arithmetic_scalar(op_name, value, val_type):
  369:     # see gh-6873
  370:     invalid_ops = {
  371:         "scalar": {"right_div_left"},
  372:         "floating": {
  373:             "right_div_left",
  374:             "left_minus_right",
  375:             "right_minus_left",
  376:             "left_plus_right",
  377:             "right_plus_left",
  378:         },
  379:         "str": set(_ops.keys()),
  380:         "timedelta": {"left_times_right", "right_times_left"},
  381:         "timestamp": {
  382:             "left_times_right",
  383:             "right_times_left",
  384:             "left_div_right",
  385:             "right_div_left",
  386:         },
  387:     }
  388: 
  389:     op = _ops[op_name]
  390: 
  391:     if op_name in invalid_ops.get(val_type, set()):
  392:         if (
  393:             val_type == "timedelta"
  394:             and "times" in op_name
  395:             and isinstance(value, Timedelta)
  396:         ):
  397:             typs = "(Timedelta|NaTType)"
  398:             msg = rf"unsupported operand type\(s\) for \*: '{typs}' and '{typs}'"
  399:         elif val_type == "str":
  400:             # un-specific check here because the message comes from str
  401:             #  and varies by method
  402:             msg = "|".join(
  403:                 [
  404:                     "can only concatenate str",
  405:                     "unsupported operand type",
  406:                     "can't multiply sequence",
  407:                     "Can't convert 'NaTType'",
  408:                     "must be str, not NaTType",
  409:                 ]
  410:             )
  411:         else:
  412:             msg = "unsupported operand type"
  413: 
  414:         with pytest.raises(TypeError, match=msg):
  415:             op(NaT, value)
  416:     else:
  417:         if val_type == "timedelta" and "div" in op_name:
  418:             expected = np.nan
  419:         else:
  420:             expected = NaT
  421: 
  422:         assert op(NaT, value) is expected
  423: 
  424: 
  425: @pytest.mark.parametrize(
  426:     "val,expected", [(np.nan, NaT), (NaT, np.nan), (np.timedelta64("NaT"), np.nan)]
  427: )
  428: def test_nat_rfloordiv_timedelta(val, expected):
  429:     # see gh-#18846
  430:     #
  431:     # See also test_timedelta.TestTimedeltaArithmetic.test_floordiv
  432:     td = Timedelta(hours=3, minutes=4)
  433:     assert td // val is expected
  434: 
  435: 
  436: @pytest.mark.parametrize(
  437:     "op_name",
  438:     ["left_plus_right", "right_plus_left", "left_minus_right", "right_minus_left"],
  439: )
  440: @pytest.mark.parametrize(
  441:     "value",
  442:     [
  443:         DatetimeIndex(["2011-01-01", "2011-01-02"], name="x"),
  444:         DatetimeIndex(["2011-01-01", "2011-01-02"], tz="US/Eastern", name="x"),
  445:         DatetimeArray._from_sequence(["2011-01-01", "2011-01-02"], dtype="M8[ns]"),
  446:         DatetimeArray._from_sequence(
  447:             ["2011-01-01", "2011-01-02"], dtype=DatetimeTZDtype(tz="US/Pacific")
  448:         ),
  449:         TimedeltaIndex(["1 day", "2 day"], name="x"),
  450:     ],
  451: )
  452: def test_nat_arithmetic_index(op_name, value):
  453:     # see gh-11718
  454:     exp_name = "x"
  455:     exp_data = [NaT] * 2
  456: 
  457:     if value.dtype.kind == "M" and "plus" in op_name:
  458:         expected = DatetimeIndex(exp_data, tz=value.tz, name=exp_name)
  459:     else:
  460:         expected = TimedeltaIndex(exp_data, name=exp_name)
  461:     expected = expected.as_unit(value.unit)
  462: 
  463:     if not isinstance(value, Index):
  464:         expected = expected.array
  465: 
  466:     op = _ops[op_name]
  467:     result = op(NaT, value)
  468:     tm.assert_equal(result, expected)
  469: 
  470: 
  471: @pytest.mark.parametrize(
  472:     "op_name",
  473:     ["left_plus_right", "right_plus_left", "left_minus_right", "right_minus_left"],
  474: )
  475: @pytest.mark.parametrize("box", [TimedeltaIndex, Series, TimedeltaArray._from_sequence])
  476: def test_nat_arithmetic_td64_vector(op_name, box):
  477:     # see gh-19124
  478:     vec = box(["1 day", "2 day"], dtype="timedelta64[ns]")
  479:     box_nat = box([NaT, NaT], dtype="timedelta64[ns]")
  480:     tm.assert_equal(_ops[op_name](vec, NaT), box_nat)
  481: 
  482: 
  483: @pytest.mark.parametrize(
  484:     "dtype,op,out_dtype",
  485:     [
  486:         ("datetime64[ns]", operator.add, "datetime64[ns]"),
  487:         ("datetime64[ns]", roperator.radd, "datetime64[ns]"),
  488:         ("datetime64[ns]", operator.sub, "timedelta64[ns]"),
  489:         ("datetime64[ns]", roperator.rsub, "timedelta64[ns]"),
  490:         ("timedelta64[ns]", operator.add, "datetime64[ns]"),
  491:         ("timedelta64[ns]", roperator.radd, "datetime64[ns]"),
  492:         ("timedelta64[ns]", operator.sub, "datetime64[ns]"),
  493:         ("timedelta64[ns]", roperator.rsub, "timedelta64[ns]"),
  494:     ],
  495: )
  496: def test_nat_arithmetic_ndarray(dtype, op, out_dtype):
  497:     other = np.arange(10).astype(dtype)
  498:     result = op(NaT, other)
  499: 
  500:     expected = np.empty(other.shape, dtype=out_dtype)
  501:     expected.fill("NaT")
  502:     tm.assert_numpy_array_equal(result, expected)
  503: 
  504: 
  505: def test_nat_pinned_docstrings():
  506:     # see gh-17327
  507:     assert NaT.ctime.__doc__ == Timestamp.ctime.__doc__
  508: 
  509: 
  510: def test_to_numpy_alias():
  511:     # GH 24653: alias .to_numpy() for scalars
  512:     expected = NaT.to_datetime64()
  513:     result = NaT.to_numpy()
  514: 
  515:     assert isna(expected) and isna(result)
  516: 
  517:     # GH#44460
  518:     result = NaT.to_numpy("M8[s]")
  519:     assert isinstance(result, np.datetime64)
  520:     assert result.dtype == "M8[s]"
  521: 
  522:     result = NaT.to_numpy("m8[ns]")
  523:     assert isinstance(result, np.timedelta64)
  524:     assert result.dtype == "m8[ns]"
  525: 
  526:     result = NaT.to_numpy("m8[s]")
  527:     assert isinstance(result, np.timedelta64)
  528:     assert result.dtype == "m8[s]"
  529: 
  530:     with pytest.raises(ValueError, match="NaT.to_numpy dtype must be a "):
  531:         NaT.to_numpy(np.int64)
  532: 
  533: 
  534: @pytest.mark.parametrize(
  535:     "other",
  536:     [
  537:         Timedelta(0),
  538:         Timedelta(0).to_pytimedelta(),
  539:         pytest.param(
  540:             Timedelta(0).to_timedelta64(),
  541:             marks=pytest.mark.xfail(
  542:                 not np_version_gte1p24p3,
  543:                 reason="td64 doesn't return NotImplemented, see numpy#17017",
  544:                 # When this xfail is fixed, test_nat_comparisons_numpy
  545:                 #  can be removed.
  546:             ),
  547:         ),
  548:         Timestamp(0),
  549:         Timestamp(0).to_pydatetime(),
  550:         pytest.param(
  551:             Timestamp(0).to_datetime64(),
  552:             marks=pytest.mark.xfail(
  553:                 not np_version_gte1p24p3,
  554:                 reason="dt64 doesn't return NotImplemented, see numpy#17017",
  555:             ),
  556:         ),
  557:         Timestamp(0).tz_localize("UTC"),
  558:         NaT,
  559:     ],
  560: )
  561: def test_nat_comparisons(compare_operators_no_eq_ne, other):
  562:     # GH 26039
  563:     opname = compare_operators_no_eq_ne
  564: 
  565:     assert getattr(NaT, opname)(other) is False
  566: 
  567:     op = getattr(operator, opname.strip("_"))
  568:     assert op(NaT, other) is False
  569:     assert op(other, NaT) is False
  570: 
  571: 
  572: @pytest.mark.parametrize("other", [np.timedelta64(0, "ns"), np.datetime64("now", "ns")])
  573: def test_nat_comparisons_numpy(other):
  574:     # Once numpy#17017 is fixed and the xfailed cases in test_nat_comparisons
  575:     #  pass, this test can be removed
  576:     assert not NaT == other
  577:     assert NaT != other
  578:     assert not NaT < other
  579:     assert not NaT > other
  580:     assert not NaT <= other
  581:     assert not NaT >= other
  582: 
  583: 
  584: @pytest.mark.parametrize("other_and_type", [("foo", "str"), (2, "int"), (2.0, "float")])
  585: @pytest.mark.parametrize(
  586:     "symbol_and_op",
  587:     [("<=", operator.le), ("<", operator.lt), (">=", operator.ge), (">", operator.gt)],
  588: )
  589: def test_nat_comparisons_invalid(other_and_type, symbol_and_op):
  590:     # GH#35585
  591:     other, other_type = other_and_type
  592:     symbol, op = symbol_and_op
  593: 
  594:     assert not NaT == other
  595:     assert not other == NaT
  596: 
  597:     assert NaT != other
  598:     assert other != NaT
  599: 
  600:     msg = f"'{symbol}' not supported between instances of 'NaTType' and '{other_type}'"
  601:     with pytest.raises(TypeError, match=msg):
  602:         op(NaT, other)
  603: 
  604:     msg = f"'{symbol}' not supported between instances of '{other_type}' and 'NaTType'"
  605:     with pytest.raises(TypeError, match=msg):
  606:         op(other, NaT)
  607: 
  608: 
  609: @pytest.mark.parametrize(
  610:     "other",
  611:     [
  612:         np.array(["foo"] * 2, dtype=object),
  613:         np.array([2, 3], dtype="int64"),
  614:         np.array([2.0, 3.5], dtype="float64"),
  615:     ],
  616:     ids=["str", "int", "float"],
  617: )
  618: def test_nat_comparisons_invalid_ndarray(other):
  619:     # GH#40722
  620:     expected = np.array([False, False])
  621:     result = NaT == other
  622:     tm.assert_numpy_array_equal(result, expected)
  623:     result = other == NaT
  624:     tm.assert_numpy_array_equal(result, expected)
  625: 
  626:     expected = np.array([True, True])
  627:     result = NaT != other
  628:     tm.assert_numpy_array_equal(result, expected)
  629:     result = other != NaT
  630:     tm.assert_numpy_array_equal(result, expected)
  631: 
  632:     for symbol, op in [
  633:         ("<=", operator.le),
  634:         ("<", operator.lt),
  635:         (">=", operator.ge),
  636:         (">", operator.gt),
  637:     ]:
  638:         msg = f"'{symbol}' not supported between"
  639: 
  640:         with pytest.raises(TypeError, match=msg):
  641:             op(NaT, other)
  642: 
  643:         if other.dtype == np.dtype("object"):
  644:             # uses the reverse operator, so symbol changes
  645:             msg = None
  646:         with pytest.raises(TypeError, match=msg):
  647:             op(other, NaT)
  648: 
  649: 
  650: def test_compare_date(fixed_now_ts):
  651:     # GH#39151 comparing NaT with date object is deprecated
  652:     # See also: tests.scalar.timestamps.test_comparisons::test_compare_date
  653: 
  654:     dt = fixed_now_ts.to_pydatetime().date()
  655: 
  656:     msg = "Cannot compare NaT with datetime.date object"
  657:     for left, right in [(NaT, dt), (dt, NaT)]:
  658:         assert not left == right
  659:         assert left != right
  660: 
  661:         with pytest.raises(TypeError, match=msg):
  662:             left < right
  663:         with pytest.raises(TypeError, match=msg):
  664:             left <= right
  665:         with pytest.raises(TypeError, match=msg):
  666:             left > right
  667:         with pytest.raises(TypeError, match=msg):
  668:             left >= right
  669: 
  670: 
  671: @pytest.mark.parametrize(
  672:     "obj",
  673:     [
  674:         offsets.YearEnd(2),
  675:         offsets.YearBegin(2),
  676:         offsets.MonthBegin(1),
  677:         offsets.MonthEnd(2),
  678:         offsets.MonthEnd(12),
  679:         offsets.Day(2),
  680:         offsets.Day(5),
  681:         offsets.Hour(24),
  682:         offsets.Hour(3),
  683:         offsets.Minute(),
  684:         np.timedelta64(3, "h"),
  685:         np.timedelta64(4, "h"),
  686:         np.timedelta64(3200, "s"),
  687:         np.timedelta64(3600, "s"),
  688:         np.timedelta64(3600 * 24, "s"),
  689:         np.timedelta64(2, "D"),
  690:         np.timedelta64(365, "D"),
  691:         timedelta(-2),
  692:         timedelta(365),
  693:         timedelta(minutes=120),
  694:         timedelta(days=4, minutes=180),
  695:         timedelta(hours=23),
  696:         timedelta(hours=23, minutes=30),
  697:         timedelta(hours=48),
  698:     ],
  699: )
  700: def test_nat_addsub_tdlike_scalar(obj):
  701:     assert NaT + obj is NaT
  702:     assert obj + NaT is NaT
  703:     assert NaT - obj is NaT
  704: 
  705: 
  706: def test_pickle():
  707:     # GH#4606
  708:     p = tm.round_trip_pickle(NaT)
  709:     assert p is NaT
