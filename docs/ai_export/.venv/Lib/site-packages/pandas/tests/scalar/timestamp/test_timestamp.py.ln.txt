    1: """ test the scalar Timestamp """
    2: 
    3: import calendar
    4: from datetime import (
    5:     datetime,
    6:     timedelta,
    7:     timezone,
    8: )
    9: import locale
   10: import time
   11: import unicodedata
   12: 
   13: from dateutil.tz import (
   14:     tzlocal,
   15:     tzutc,
   16: )
   17: from hypothesis import (
   18:     given,
   19:     strategies as st,
   20: )
   21: import numpy as np
   22: import pytest
   23: import pytz
   24: from pytz import utc
   25: 
   26: from pandas._libs.tslibs.dtypes import NpyDatetimeUnit
   27: from pandas._libs.tslibs.timezones import (
   28:     dateutil_gettz as gettz,
   29:     get_timezone,
   30:     maybe_get_tz,
   31:     tz_compare,
   32: )
   33: from pandas.compat import IS64
   34: 
   35: from pandas import (
   36:     NaT,
   37:     Timedelta,
   38:     Timestamp,
   39: )
   40: import pandas._testing as tm
   41: 
   42: from pandas.tseries import offsets
   43: from pandas.tseries.frequencies import to_offset
   44: 
   45: 
   46: class TestTimestampProperties:
   47:     def test_properties_business(self):
   48:         freq = to_offset("B")
   49: 
   50:         ts = Timestamp("2017-10-01")
   51:         assert ts.dayofweek == 6
   52:         assert ts.day_of_week == 6
   53:         assert ts.is_month_start  # not a weekday
   54:         assert not freq.is_month_start(ts)
   55:         assert freq.is_month_start(ts + Timedelta(days=1))
   56:         assert not freq.is_quarter_start(ts)
   57:         assert freq.is_quarter_start(ts + Timedelta(days=1))
   58: 
   59:         ts = Timestamp("2017-09-30")
   60:         assert ts.dayofweek == 5
   61:         assert ts.day_of_week == 5
   62:         assert ts.is_month_end
   63:         assert not freq.is_month_end(ts)
   64:         assert freq.is_month_end(ts - Timedelta(days=1))
   65:         assert ts.is_quarter_end
   66:         assert not freq.is_quarter_end(ts)
   67:         assert freq.is_quarter_end(ts - Timedelta(days=1))
   68: 
   69:     @pytest.mark.parametrize(
   70:         "attr, expected",
   71:         [
   72:             ["year", 2014],
   73:             ["month", 12],
   74:             ["day", 31],
   75:             ["hour", 23],
   76:             ["minute", 59],
   77:             ["second", 0],
   78:             ["microsecond", 0],
   79:             ["nanosecond", 0],
   80:             ["dayofweek", 2],
   81:             ["day_of_week", 2],
   82:             ["quarter", 4],
   83:             ["dayofyear", 365],
   84:             ["day_of_year", 365],
   85:             ["week", 1],
   86:             ["daysinmonth", 31],
   87:         ],
   88:     )
   89:     @pytest.mark.parametrize("tz", [None, "US/Eastern"])
   90:     def test_fields(self, attr, expected, tz):
   91:         # GH 10050
   92:         # GH 13303
   93:         ts = Timestamp("2014-12-31 23:59:00", tz=tz)
   94:         result = getattr(ts, attr)
   95:         # that we are int like
   96:         assert isinstance(result, int)
   97:         assert result == expected
   98: 
   99:     @pytest.mark.parametrize("tz", [None, "US/Eastern"])
  100:     def test_millisecond_raises(self, tz):
  101:         ts = Timestamp("2014-12-31 23:59:00", tz=tz)
  102:         msg = "'Timestamp' object has no attribute 'millisecond'"
  103:         with pytest.raises(AttributeError, match=msg):
  104:             ts.millisecond
  105: 
  106:     @pytest.mark.parametrize(
  107:         "start", ["is_month_start", "is_quarter_start", "is_year_start"]
  108:     )
  109:     @pytest.mark.parametrize("tz", [None, "US/Eastern"])
  110:     def test_is_start(self, start, tz):
  111:         ts = Timestamp("2014-01-01 00:00:00", tz=tz)
  112:         assert getattr(ts, start)
  113: 
  114:     @pytest.mark.parametrize("end", ["is_month_end", "is_year_end", "is_quarter_end"])
  115:     @pytest.mark.parametrize("tz", [None, "US/Eastern"])
  116:     def test_is_end(self, end, tz):
  117:         ts = Timestamp("2014-12-31 23:59:59", tz=tz)
  118:         assert getattr(ts, end)
  119: 
  120:     # GH 12806
  121:     @pytest.mark.parametrize(
  122:         "data",
  123:         [Timestamp("2017-08-28 23:00:00"), Timestamp("2017-08-28 23:00:00", tz="EST")],
  124:     )
  125:     # error: Unsupported operand types for + ("List[None]" and "List[str]")
  126:     @pytest.mark.parametrize(
  127:         "time_locale", [None] + tm.get_locales()  # type: ignore[operator]
  128:     )
  129:     def test_names(self, data, time_locale):
  130:         # GH 17354
  131:         # Test .day_name(), .month_name
  132:         if time_locale is None:
  133:             expected_day = "Monday"
  134:             expected_month = "August"
  135:         else:
  136:             with tm.set_locale(time_locale, locale.LC_TIME):
  137:                 expected_day = calendar.day_name[0].capitalize()
  138:                 expected_month = calendar.month_name[8].capitalize()
  139: 
  140:         result_day = data.day_name(time_locale)
  141:         result_month = data.month_name(time_locale)
  142: 
  143:         # Work around https://github.com/pandas-dev/pandas/issues/22342
  144:         # different normalizations
  145:         expected_day = unicodedata.normalize("NFD", expected_day)
  146:         expected_month = unicodedata.normalize("NFD", expected_month)
  147: 
  148:         result_day = unicodedata.normalize("NFD", result_day)
  149:         result_month = unicodedata.normalize("NFD", result_month)
  150: 
  151:         assert result_day == expected_day
  152:         assert result_month == expected_month
  153: 
  154:         # Test NaT
  155:         nan_ts = Timestamp(NaT)
  156:         assert np.isnan(nan_ts.day_name(time_locale))
  157:         assert np.isnan(nan_ts.month_name(time_locale))
  158: 
  159:     def test_is_leap_year(self, tz_naive_fixture):
  160:         tz = tz_naive_fixture
  161:         if not IS64 and tz == tzlocal():
  162:             # https://github.com/dateutil/dateutil/issues/197
  163:             pytest.skip(
  164:                 "tzlocal() on a 32 bit platform causes internal overflow errors"
  165:             )
  166:         # GH 13727
  167:         dt = Timestamp("2000-01-01 00:00:00", tz=tz)
  168:         assert dt.is_leap_year
  169:         assert isinstance(dt.is_leap_year, bool)
  170: 
  171:         dt = Timestamp("1999-01-01 00:00:00", tz=tz)
  172:         assert not dt.is_leap_year
  173: 
  174:         dt = Timestamp("2004-01-01 00:00:00", tz=tz)
  175:         assert dt.is_leap_year
  176: 
  177:         dt = Timestamp("2100-01-01 00:00:00", tz=tz)
  178:         assert not dt.is_leap_year
  179: 
  180:     def test_woy_boundary(self):
  181:         # make sure weeks at year boundaries are correct
  182:         d = datetime(2013, 12, 31)
  183:         result = Timestamp(d).week
  184:         expected = 1  # ISO standard
  185:         assert result == expected
  186: 
  187:         d = datetime(2008, 12, 28)
  188:         result = Timestamp(d).week
  189:         expected = 52  # ISO standard
  190:         assert result == expected
  191: 
  192:         d = datetime(2009, 12, 31)
  193:         result = Timestamp(d).week
  194:         expected = 53  # ISO standard
  195:         assert result == expected
  196: 
  197:         d = datetime(2010, 1, 1)
  198:         result = Timestamp(d).week
  199:         expected = 53  # ISO standard
  200:         assert result == expected
  201: 
  202:         d = datetime(2010, 1, 3)
  203:         result = Timestamp(d).week
  204:         expected = 53  # ISO standard
  205:         assert result == expected
  206: 
  207:         result = np.array(
  208:             [
  209:                 Timestamp(datetime(*args)).week
  210:                 for args in [(2000, 1, 1), (2000, 1, 2), (2005, 1, 1), (2005, 1, 2)]
  211:             ]
  212:         )
  213:         assert (result == [52, 52, 53, 53]).all()
  214: 
  215:     def test_resolution(self):
  216:         # GH#21336, GH#21365
  217:         dt = Timestamp("2100-01-01 00:00:00.000000000")
  218:         assert dt.resolution == Timedelta(nanoseconds=1)
  219: 
  220:         # Check that the attribute is available on the class, mirroring
  221:         #  the stdlib datetime behavior
  222:         assert Timestamp.resolution == Timedelta(nanoseconds=1)
  223: 
  224:         assert dt.as_unit("us").resolution == Timedelta(microseconds=1)
  225:         assert dt.as_unit("ms").resolution == Timedelta(milliseconds=1)
  226:         assert dt.as_unit("s").resolution == Timedelta(seconds=1)
  227: 
  228:     @pytest.mark.parametrize(
  229:         "date_string, expected",
  230:         [
  231:             ("0000-2-29", 1),
  232:             ("0000-3-1", 2),
  233:             ("1582-10-14", 3),
  234:             ("-0040-1-1", 4),
  235:             ("2023-06-18", 6),
  236:         ],
  237:     )
  238:     def test_dow_historic(self, date_string, expected):
  239:         # GH 53738
  240:         ts = Timestamp(date_string)
  241:         dow = ts.weekday()
  242:         assert dow == expected
  243: 
  244:     @given(
  245:         ts=st.datetimes(),
  246:         sign=st.sampled_from(["-", ""]),
  247:     )
  248:     def test_dow_parametric(self, ts, sign):
  249:         # GH 53738
  250:         ts = (
  251:             f"{sign}{str(ts.year).zfill(4)}"
  252:             f"-{str(ts.month).zfill(2)}"
  253:             f"-{str(ts.day).zfill(2)}"
  254:         )
  255:         result = Timestamp(ts).weekday()
  256:         expected = (
  257:             (np.datetime64(ts) - np.datetime64("1970-01-01")).astype("int64") - 4
  258:         ) % 7
  259:         assert result == expected
  260: 
  261: 
  262: class TestTimestamp:
  263:     @pytest.mark.parametrize("tz", [None, pytz.timezone("US/Pacific")])
  264:     def test_disallow_setting_tz(self, tz):
  265:         # GH#3746
  266:         ts = Timestamp("2010")
  267:         msg = "Cannot directly set timezone"
  268:         with pytest.raises(AttributeError, match=msg):
  269:             ts.tz = tz
  270: 
  271:     def test_default_to_stdlib_utc(self):
  272:         assert Timestamp.utcnow().tz is timezone.utc
  273:         assert Timestamp.now("UTC").tz is timezone.utc
  274:         assert Timestamp("2016-01-01", tz="UTC").tz is timezone.utc
  275: 
  276:     def test_tz(self):
  277:         tstr = "2014-02-01 09:00"
  278:         ts = Timestamp(tstr)
  279:         local = ts.tz_localize("Asia/Tokyo")
  280:         assert local.hour == 9
  281:         assert local == Timestamp(tstr, tz="Asia/Tokyo")
  282:         conv = local.tz_convert("US/Eastern")
  283:         assert conv == Timestamp("2014-01-31 19:00", tz="US/Eastern")
  284:         assert conv.hour == 19
  285: 
  286:         # preserves nanosecond
  287:         ts = Timestamp(tstr) + offsets.Nano(5)
  288:         local = ts.tz_localize("Asia/Tokyo")
  289:         assert local.hour == 9
  290:         assert local.nanosecond == 5
  291:         conv = local.tz_convert("US/Eastern")
  292:         assert conv.nanosecond == 5
  293:         assert conv.hour == 19
  294: 
  295:     def test_utc_z_designator(self):
  296:         assert get_timezone(Timestamp("2014-11-02 01:00Z").tzinfo) is timezone.utc
  297: 
  298:     def test_asm8(self):
  299:         ns = [Timestamp.min._value, Timestamp.max._value, 1000]
  300: 
  301:         for n in ns:
  302:             assert (
  303:                 Timestamp(n).asm8.view("i8") == np.datetime64(n, "ns").view("i8") == n
  304:             )
  305: 
  306:         assert Timestamp("nat").asm8.view("i8") == np.datetime64("nat", "ns").view("i8")
  307: 
  308:     def test_class_ops(self):
  309:         def compare(x, y):
  310:             assert int((Timestamp(x)._value - Timestamp(y)._value) / 1e9) == 0
  311: 
  312:         compare(Timestamp.now(), datetime.now())
  313:         compare(Timestamp.now("UTC"), datetime.now(pytz.timezone("UTC")))
  314:         compare(Timestamp.now("UTC"), datetime.now(tzutc()))
  315:         compare(Timestamp.utcnow(), datetime.now(timezone.utc))
  316:         compare(Timestamp.today(), datetime.today())
  317:         current_time = calendar.timegm(datetime.now().utctimetuple())
  318: 
  319:         ts_utc = Timestamp.utcfromtimestamp(current_time)
  320:         assert ts_utc.timestamp() == current_time
  321:         compare(
  322:             Timestamp.fromtimestamp(current_time), datetime.fromtimestamp(current_time)
  323:         )
  324:         compare(
  325:             # Support tz kwarg in Timestamp.fromtimestamp
  326:             Timestamp.fromtimestamp(current_time, "UTC"),
  327:             datetime.fromtimestamp(current_time, utc),
  328:         )
  329:         compare(
  330:             # Support tz kwarg in Timestamp.fromtimestamp
  331:             Timestamp.fromtimestamp(current_time, tz="UTC"),
  332:             datetime.fromtimestamp(current_time, utc),
  333:         )
  334: 
  335:         date_component = datetime.now(timezone.utc)
  336:         time_component = (date_component + timedelta(minutes=10)).time()
  337:         compare(
  338:             Timestamp.combine(date_component, time_component),
  339:             datetime.combine(date_component, time_component),
  340:         )
  341: 
  342:     def test_basics_nanos(self):
  343:         val = np.int64(946_684_800_000_000_000).view("M8[ns]")
  344:         stamp = Timestamp(val.view("i8") + 500)
  345:         assert stamp.year == 2000
  346:         assert stamp.month == 1
  347:         assert stamp.microsecond == 0
  348:         assert stamp.nanosecond == 500
  349: 
  350:         # GH 14415
  351:         val = np.iinfo(np.int64).min + 80_000_000_000_000
  352:         stamp = Timestamp(val)
  353:         assert stamp.year == 1677
  354:         assert stamp.month == 9
  355:         assert stamp.day == 21
  356:         assert stamp.microsecond == 145224
  357:         assert stamp.nanosecond == 192
  358: 
  359:     def test_roundtrip(self):
  360:         # test value to string and back conversions
  361:         # further test accessors
  362:         base = Timestamp("20140101 00:00:00").as_unit("ns")
  363: 
  364:         result = Timestamp(base._value + Timedelta("5ms")._value)
  365:         assert result == Timestamp(f"{base}.005000")
  366:         assert result.microsecond == 5000
  367: 
  368:         result = Timestamp(base._value + Timedelta("5us")._value)
  369:         assert result == Timestamp(f"{base}.000005")
  370:         assert result.microsecond == 5
  371: 
  372:         result = Timestamp(base._value + Timedelta("5ns")._value)
  373:         assert result == Timestamp(f"{base}.000000005")
  374:         assert result.nanosecond == 5
  375:         assert result.microsecond == 0
  376: 
  377:         result = Timestamp(base._value + Timedelta("6ms 5us")._value)
  378:         assert result == Timestamp(f"{base}.006005")
  379:         assert result.microsecond == 5 + 6 * 1000
  380: 
  381:         result = Timestamp(base._value + Timedelta("200ms 5us")._value)
  382:         assert result == Timestamp(f"{base}.200005")
  383:         assert result.microsecond == 5 + 200 * 1000
  384: 
  385:     def test_hash_equivalent(self):
  386:         d = {datetime(2011, 1, 1): 5}
  387:         stamp = Timestamp(datetime(2011, 1, 1))
  388:         assert d[stamp] == 5
  389: 
  390:     @pytest.mark.parametrize(
  391:         "timezone, year, month, day, hour",
  392:         [["America/Chicago", 2013, 11, 3, 1], ["America/Santiago", 2021, 4, 3, 23]],
  393:     )
  394:     def test_hash_timestamp_with_fold(self, timezone, year, month, day, hour):
  395:         # see gh-33931
  396:         test_timezone = gettz(timezone)
  397:         transition_1 = Timestamp(
  398:             year=year,
  399:             month=month,
  400:             day=day,
  401:             hour=hour,
  402:             minute=0,
  403:             fold=0,
  404:             tzinfo=test_timezone,
  405:         )
  406:         transition_2 = Timestamp(
  407:             year=year,
  408:             month=month,
  409:             day=day,
  410:             hour=hour,
  411:             minute=0,
  412:             fold=1,
  413:             tzinfo=test_timezone,
  414:         )
  415:         assert hash(transition_1) == hash(transition_2)
  416: 
  417: 
  418: class TestTimestampNsOperations:
  419:     def test_nanosecond_string_parsing(self):
  420:         ts = Timestamp("2013-05-01 07:15:45.123456789")
  421:         # GH 7878
  422:         expected_repr = "2013-05-01 07:15:45.123456789"
  423:         expected_value = 1_367_392_545_123_456_789
  424:         assert ts._value == expected_value
  425:         assert expected_repr in repr(ts)
  426: 
  427:         ts = Timestamp("2013-05-01 07:15:45.123456789+09:00", tz="Asia/Tokyo")
  428:         assert ts._value == expected_value - 9 * 3600 * 1_000_000_000
  429:         assert expected_repr in repr(ts)
  430: 
  431:         ts = Timestamp("2013-05-01 07:15:45.123456789", tz="UTC")
  432:         assert ts._value == expected_value
  433:         assert expected_repr in repr(ts)
  434: 
  435:         ts = Timestamp("2013-05-01 07:15:45.123456789", tz="US/Eastern")
  436:         assert ts._value == expected_value + 4 * 3600 * 1_000_000_000
  437:         assert expected_repr in repr(ts)
  438: 
  439:         # GH 10041
  440:         ts = Timestamp("20130501T071545.123456789")
  441:         assert ts._value == expected_value
  442:         assert expected_repr in repr(ts)
  443: 
  444:     def test_nanosecond_timestamp(self):
  445:         # GH 7610
  446:         expected = 1_293_840_000_000_000_005
  447:         t = Timestamp("2011-01-01") + offsets.Nano(5)
  448:         assert repr(t) == "Timestamp('2011-01-01 00:00:00.000000005')"
  449:         assert t._value == expected
  450:         assert t.nanosecond == 5
  451: 
  452:         t = Timestamp(t)
  453:         assert repr(t) == "Timestamp('2011-01-01 00:00:00.000000005')"
  454:         assert t._value == expected
  455:         assert t.nanosecond == 5
  456: 
  457:         t = Timestamp("2011-01-01 00:00:00.000000005")
  458:         assert repr(t) == "Timestamp('2011-01-01 00:00:00.000000005')"
  459:         assert t._value == expected
  460:         assert t.nanosecond == 5
  461: 
  462:         expected = 1_293_840_000_000_000_010
  463:         t = t + offsets.Nano(5)
  464:         assert repr(t) == "Timestamp('2011-01-01 00:00:00.000000010')"
  465:         assert t._value == expected
  466:         assert t.nanosecond == 10
  467: 
  468:         t = Timestamp(t)
  469:         assert repr(t) == "Timestamp('2011-01-01 00:00:00.000000010')"
  470:         assert t._value == expected
  471:         assert t.nanosecond == 10
  472: 
  473:         t = Timestamp("2011-01-01 00:00:00.000000010")
  474:         assert repr(t) == "Timestamp('2011-01-01 00:00:00.000000010')"
  475:         assert t._value == expected
  476:         assert t.nanosecond == 10
  477: 
  478: 
  479: class TestTimestampConversion:
  480:     def test_conversion(self):
  481:         # GH#9255
  482:         ts = Timestamp("2000-01-01").as_unit("ns")
  483: 
  484:         result = ts.to_pydatetime()
  485:         expected = datetime(2000, 1, 1)
  486:         assert result == expected
  487:         assert type(result) == type(expected)
  488: 
  489:         result = ts.to_datetime64()
  490:         expected = np.datetime64(ts._value, "ns")
  491:         assert result == expected
  492:         assert type(result) == type(expected)
  493:         assert result.dtype == expected.dtype
  494: 
  495:     def test_to_period_tz_warning(self):
  496:         # GH#21333 make sure a warning is issued when timezone
  497:         # info is lost
  498:         ts = Timestamp("2009-04-15 16:17:18", tz="US/Eastern")
  499:         with tm.assert_produces_warning(UserWarning):
  500:             # warning that timezone info will be lost
  501:             ts.to_period("D")
  502: 
  503:     def test_to_numpy_alias(self):
  504:         # GH 24653: alias .to_numpy() for scalars
  505:         ts = Timestamp(datetime.now())
  506:         assert ts.to_datetime64() == ts.to_numpy()
  507: 
  508:         # GH#44460
  509:         msg = "dtype and copy arguments are ignored"
  510:         with pytest.raises(ValueError, match=msg):
  511:             ts.to_numpy("M8[s]")
  512:         with pytest.raises(ValueError, match=msg):
  513:             ts.to_numpy(copy=True)
  514: 
  515: 
  516: class TestNonNano:
  517:     @pytest.fixture(params=["s", "ms", "us"])
  518:     def reso(self, request):
  519:         return request.param
  520: 
  521:     @pytest.fixture
  522:     def dt64(self, reso):
  523:         # cases that are in-bounds for nanosecond, so we can compare against
  524:         #  the existing implementation.
  525:         return np.datetime64("2016-01-01", reso)
  526: 
  527:     @pytest.fixture
  528:     def ts(self, dt64):
  529:         return Timestamp._from_dt64(dt64)
  530: 
  531:     @pytest.fixture
  532:     def ts_tz(self, ts, tz_aware_fixture):
  533:         tz = maybe_get_tz(tz_aware_fixture)
  534:         return Timestamp._from_value_and_reso(ts._value, ts._creso, tz)
  535: 
  536:     def test_non_nano_construction(self, dt64, ts, reso):
  537:         assert ts._value == dt64.view("i8")
  538: 
  539:         if reso == "s":
  540:             assert ts._creso == NpyDatetimeUnit.NPY_FR_s.value
  541:         elif reso == "ms":
  542:             assert ts._creso == NpyDatetimeUnit.NPY_FR_ms.value
  543:         elif reso == "us":
  544:             assert ts._creso == NpyDatetimeUnit.NPY_FR_us.value
  545: 
  546:     def test_non_nano_fields(self, dt64, ts):
  547:         alt = Timestamp(dt64)
  548: 
  549:         assert ts.year == alt.year
  550:         assert ts.month == alt.month
  551:         assert ts.day == alt.day
  552:         assert ts.hour == ts.minute == ts.second == ts.microsecond == 0
  553:         assert ts.nanosecond == 0
  554: 
  555:         assert ts.to_julian_date() == alt.to_julian_date()
  556:         assert ts.weekday() == alt.weekday()
  557:         assert ts.isoweekday() == alt.isoweekday()
  558: 
  559:     def test_start_end_fields(self, ts):
  560:         assert ts.is_year_start
  561:         assert ts.is_quarter_start
  562:         assert ts.is_month_start
  563:         assert not ts.is_year_end
  564:         assert not ts.is_month_end
  565:         assert not ts.is_month_end
  566: 
  567:         # 2016-01-01 is a Friday, so is year/quarter/month start with this freq
  568:         assert ts.is_year_start
  569:         assert ts.is_quarter_start
  570:         assert ts.is_month_start
  571:         assert not ts.is_year_end
  572:         assert not ts.is_month_end
  573:         assert not ts.is_month_end
  574: 
  575:     def test_day_name(self, dt64, ts):
  576:         alt = Timestamp(dt64)
  577:         assert ts.day_name() == alt.day_name()
  578: 
  579:     def test_month_name(self, dt64, ts):
  580:         alt = Timestamp(dt64)
  581:         assert ts.month_name() == alt.month_name()
  582: 
  583:     def test_tz_convert(self, ts):
  584:         ts = Timestamp._from_value_and_reso(ts._value, ts._creso, utc)
  585: 
  586:         tz = pytz.timezone("US/Pacific")
  587:         result = ts.tz_convert(tz)
  588: 
  589:         assert isinstance(result, Timestamp)
  590:         assert result._creso == ts._creso
  591:         assert tz_compare(result.tz, tz)
  592: 
  593:     def test_repr(self, dt64, ts):
  594:         alt = Timestamp(dt64)
  595: 
  596:         assert str(ts) == str(alt)
  597:         assert repr(ts) == repr(alt)
  598: 
  599:     def test_comparison(self, dt64, ts):
  600:         alt = Timestamp(dt64)
  601: 
  602:         assert ts == dt64
  603:         assert dt64 == ts
  604:         assert ts == alt
  605:         assert alt == ts
  606: 
  607:         assert not ts != dt64
  608:         assert not dt64 != ts
  609:         assert not ts != alt
  610:         assert not alt != ts
  611: 
  612:         assert not ts < dt64
  613:         assert not dt64 < ts
  614:         assert not ts < alt
  615:         assert not alt < ts
  616: 
  617:         assert not ts > dt64
  618:         assert not dt64 > ts
  619:         assert not ts > alt
  620:         assert not alt > ts
  621: 
  622:         assert ts >= dt64
  623:         assert dt64 >= ts
  624:         assert ts >= alt
  625:         assert alt >= ts
  626: 
  627:         assert ts <= dt64
  628:         assert dt64 <= ts
  629:         assert ts <= alt
  630:         assert alt <= ts
  631: 
  632:     def test_cmp_cross_reso(self):
  633:         # numpy gets this wrong because of silent overflow
  634:         dt64 = np.datetime64(9223372800, "s")  # won't fit in M8[ns]
  635:         ts = Timestamp._from_dt64(dt64)
  636: 
  637:         # subtracting 3600*24 gives a datetime64 that _can_ fit inside the
  638:         #  nanosecond implementation bounds.
  639:         other = Timestamp(dt64 - 3600 * 24).as_unit("ns")
  640:         assert other < ts
  641:         assert other.asm8 > ts.asm8  # <- numpy gets this wrong
  642:         assert ts > other
  643:         assert ts.asm8 < other.asm8  # <- numpy gets this wrong
  644:         assert not other == ts
  645:         assert ts != other
  646: 
  647:     @pytest.mark.xfail(reason="Dispatches to np.datetime64 which is wrong")
  648:     def test_cmp_cross_reso_reversed_dt64(self):
  649:         dt64 = np.datetime64(106752, "D")  # won't fit in M8[ns]
  650:         ts = Timestamp._from_dt64(dt64)
  651:         other = Timestamp(dt64 - 1)
  652: 
  653:         assert other.asm8 < ts
  654: 
  655:     def test_pickle(self, ts, tz_aware_fixture):
  656:         tz = tz_aware_fixture
  657:         tz = maybe_get_tz(tz)
  658:         ts = Timestamp._from_value_and_reso(ts._value, ts._creso, tz)
  659:         rt = tm.round_trip_pickle(ts)
  660:         assert rt._creso == ts._creso
  661:         assert rt == ts
  662: 
  663:     def test_normalize(self, dt64, ts):
  664:         alt = Timestamp(dt64)
  665:         result = ts.normalize()
  666:         assert result._creso == ts._creso
  667:         assert result == alt.normalize()
  668: 
  669:     def test_asm8(self, dt64, ts):
  670:         rt = ts.asm8
  671:         assert rt == dt64
  672:         assert rt.dtype == dt64.dtype
  673: 
  674:     def test_to_numpy(self, dt64, ts):
  675:         res = ts.to_numpy()
  676:         assert res == dt64
  677:         assert res.dtype == dt64.dtype
  678: 
  679:     def test_to_datetime64(self, dt64, ts):
  680:         res = ts.to_datetime64()
  681:         assert res == dt64
  682:         assert res.dtype == dt64.dtype
  683: 
  684:     def test_timestamp(self, dt64, ts):
  685:         alt = Timestamp(dt64)
  686:         assert ts.timestamp() == alt.timestamp()
  687: 
  688:     def test_to_period(self, dt64, ts):
  689:         alt = Timestamp(dt64)
  690:         assert ts.to_period("D") == alt.to_period("D")
  691: 
  692:     @pytest.mark.parametrize(
  693:         "td", [timedelta(days=4), Timedelta(days=4), np.timedelta64(4, "D")]
  694:     )
  695:     def test_addsub_timedeltalike_non_nano(self, dt64, ts, td):
  696:         exp_reso = max(ts._creso, Timedelta(td)._creso)
  697: 
  698:         result = ts - td
  699:         expected = Timestamp(dt64) - td
  700:         assert isinstance(result, Timestamp)
  701:         assert result._creso == exp_reso
  702:         assert result == expected
  703: 
  704:         result = ts + td
  705:         expected = Timestamp(dt64) + td
  706:         assert isinstance(result, Timestamp)
  707:         assert result._creso == exp_reso
  708:         assert result == expected
  709: 
  710:         result = td + ts
  711:         expected = td + Timestamp(dt64)
  712:         assert isinstance(result, Timestamp)
  713:         assert result._creso == exp_reso
  714:         assert result == expected
  715: 
  716:     def test_addsub_offset(self, ts_tz):
  717:         # specifically non-Tick offset
  718:         off = offsets.YearEnd(1)
  719:         result = ts_tz + off
  720: 
  721:         assert isinstance(result, Timestamp)
  722:         assert result._creso == ts_tz._creso
  723:         if ts_tz.month == 12 and ts_tz.day == 31:
  724:             assert result.year == ts_tz.year + 1
  725:         else:
  726:             assert result.year == ts_tz.year
  727:         assert result.day == 31
  728:         assert result.month == 12
  729:         assert tz_compare(result.tz, ts_tz.tz)
  730: 
  731:         result = ts_tz - off
  732: 
  733:         assert isinstance(result, Timestamp)
  734:         assert result._creso == ts_tz._creso
  735:         assert result.year == ts_tz.year - 1
  736:         assert result.day == 31
  737:         assert result.month == 12
  738:         assert tz_compare(result.tz, ts_tz.tz)
  739: 
  740:     def test_sub_datetimelike_mismatched_reso(self, ts_tz):
  741:         # case with non-lossy rounding
  742:         ts = ts_tz
  743: 
  744:         # choose a unit for `other` that doesn't match ts_tz's;
  745:         #  this construction ensures we get cases with other._creso < ts._creso
  746:         #  and cases with other._creso > ts._creso
  747:         unit = {
  748:             NpyDatetimeUnit.NPY_FR_us.value: "ms",
  749:             NpyDatetimeUnit.NPY_FR_ms.value: "s",
  750:             NpyDatetimeUnit.NPY_FR_s.value: "us",
  751:         }[ts._creso]
  752:         other = ts.as_unit(unit)
  753:         assert other._creso != ts._creso
  754: 
  755:         result = ts - other
  756:         assert isinstance(result, Timedelta)
  757:         assert result._value == 0
  758:         assert result._creso == max(ts._creso, other._creso)
  759: 
  760:         result = other - ts
  761:         assert isinstance(result, Timedelta)
  762:         assert result._value == 0
  763:         assert result._creso == max(ts._creso, other._creso)
  764: 
  765:         if ts._creso < other._creso:
  766:             # Case where rounding is lossy
  767:             other2 = other + Timedelta._from_value_and_reso(1, other._creso)
  768:             exp = ts.as_unit(other.unit) - other2
  769: 
  770:             res = ts - other2
  771:             assert res == exp
  772:             assert res._creso == max(ts._creso, other._creso)
  773: 
  774:             res = other2 - ts
  775:             assert res == -exp
  776:             assert res._creso == max(ts._creso, other._creso)
  777:         else:
  778:             ts2 = ts + Timedelta._from_value_and_reso(1, ts._creso)
  779:             exp = ts2 - other.as_unit(ts2.unit)
  780: 
  781:             res = ts2 - other
  782:             assert res == exp
  783:             assert res._creso == max(ts._creso, other._creso)
  784:             res = other - ts2
  785:             assert res == -exp
  786:             assert res._creso == max(ts._creso, other._creso)
  787: 
  788:     def test_sub_timedeltalike_mismatched_reso(self, ts_tz):
  789:         # case with non-lossy rounding
  790:         ts = ts_tz
  791: 
  792:         # choose a unit for `other` that doesn't match ts_tz's;
  793:         #  this construction ensures we get cases with other._creso < ts._creso
  794:         #  and cases with other._creso > ts._creso
  795:         unit = {
  796:             NpyDatetimeUnit.NPY_FR_us.value: "ms",
  797:             NpyDatetimeUnit.NPY_FR_ms.value: "s",
  798:             NpyDatetimeUnit.NPY_FR_s.value: "us",
  799:         }[ts._creso]
  800:         other = Timedelta(0).as_unit(unit)
  801:         assert other._creso != ts._creso
  802: 
  803:         result = ts + other
  804:         assert isinstance(result, Timestamp)
  805:         assert result == ts
  806:         assert result._creso == max(ts._creso, other._creso)
  807: 
  808:         result = other + ts
  809:         assert isinstance(result, Timestamp)
  810:         assert result == ts
  811:         assert result._creso == max(ts._creso, other._creso)
  812: 
  813:         if ts._creso < other._creso:
  814:             # Case where rounding is lossy
  815:             other2 = other + Timedelta._from_value_and_reso(1, other._creso)
  816:             exp = ts.as_unit(other.unit) + other2
  817:             res = ts + other2
  818:             assert res == exp
  819:             assert res._creso == max(ts._creso, other._creso)
  820:             res = other2 + ts
  821:             assert res == exp
  822:             assert res._creso == max(ts._creso, other._creso)
  823:         else:
  824:             ts2 = ts + Timedelta._from_value_and_reso(1, ts._creso)
  825:             exp = ts2 + other.as_unit(ts2.unit)
  826: 
  827:             res = ts2 + other
  828:             assert res == exp
  829:             assert res._creso == max(ts._creso, other._creso)
  830:             res = other + ts2
  831:             assert res == exp
  832:             assert res._creso == max(ts._creso, other._creso)
  833: 
  834:     def test_addition_doesnt_downcast_reso(self):
  835:         # https://github.com/pandas-dev/pandas/pull/48748#pullrequestreview-1122635413
  836:         ts = Timestamp(year=2022, month=1, day=1, microsecond=999999).as_unit("us")
  837:         td = Timedelta(microseconds=1).as_unit("us")
  838:         res = ts + td
  839:         assert res._creso == ts._creso
  840: 
  841:     def test_sub_timedelta64_mismatched_reso(self, ts_tz):
  842:         ts = ts_tz
  843: 
  844:         res = ts + np.timedelta64(1, "ns")
  845:         exp = ts.as_unit("ns") + np.timedelta64(1, "ns")
  846:         assert exp == res
  847:         assert exp._creso == NpyDatetimeUnit.NPY_FR_ns.value
  848: 
  849:     def test_min(self, ts):
  850:         assert ts.min <= ts
  851:         assert ts.min._creso == ts._creso
  852:         assert ts.min._value == NaT._value + 1
  853: 
  854:     def test_max(self, ts):
  855:         assert ts.max >= ts
  856:         assert ts.max._creso == ts._creso
  857:         assert ts.max._value == np.iinfo(np.int64).max
  858: 
  859:     def test_resolution(self, ts):
  860:         expected = Timedelta._from_value_and_reso(1, ts._creso)
  861:         result = ts.resolution
  862:         assert result == expected
  863:         assert result._creso == expected._creso
  864: 
  865:     def test_out_of_ns_bounds(self):
  866:         # https://github.com/pandas-dev/pandas/issues/51060
  867:         result = Timestamp(-52700112000, unit="s")
  868:         assert result == Timestamp("0300-01-01")
  869:         assert result.to_numpy() == np.datetime64("0300-01-01T00:00:00", "s")
  870: 
  871: 
  872: def test_timestamp_class_min_max_resolution():
  873:     # when accessed on the class (as opposed to an instance), we default
  874:     #  to nanoseconds
  875:     assert Timestamp.min == Timestamp(NaT._value + 1)
  876:     assert Timestamp.min._creso == NpyDatetimeUnit.NPY_FR_ns.value
  877: 
  878:     assert Timestamp.max == Timestamp(np.iinfo(np.int64).max)
  879:     assert Timestamp.max._creso == NpyDatetimeUnit.NPY_FR_ns.value
  880: 
  881:     assert Timestamp.resolution == Timedelta(1)
  882:     assert Timestamp.resolution._creso == NpyDatetimeUnit.NPY_FR_ns.value
  883: 
  884: 
  885: def test_delimited_date():
  886:     # https://github.com/pandas-dev/pandas/issues/50231
  887:     with tm.assert_produces_warning(None):
  888:         result = Timestamp("13-01-2000")
  889:     expected = Timestamp(2000, 1, 13)
  890:     assert result == expected
  891: 
  892: 
  893: def test_utctimetuple():
  894:     # GH 32174
  895:     ts = Timestamp("2000-01-01", tz="UTC")
  896:     result = ts.utctimetuple()
  897:     expected = time.struct_time((2000, 1, 1, 0, 0, 0, 5, 1, 0))
  898:     assert result == expected
  899: 
  900: 
  901: def test_negative_dates():
  902:     # https://github.com/pandas-dev/pandas/issues/50787
  903:     ts = Timestamp("-2000-01-01")
  904:     msg = (
  905:         " not yet supported on Timestamps which are outside the range of "
  906:         "Python's standard library. For now, please call the components you need "
  907:         r"\(such as `.year` and `.month`\) and construct your string from there.$"
  908:     )
  909:     func = "^strftime"
  910:     with pytest.raises(NotImplementedError, match=func + msg):
  911:         ts.strftime("%Y")
  912: 
  913:     msg = (
  914:         " not yet supported on Timestamps which "
  915:         "are outside the range of Python's standard library. "
  916:     )
  917:     func = "^date"
  918:     with pytest.raises(NotImplementedError, match=func + msg):
  919:         ts.date()
  920:     func = "^isocalendar"
  921:     with pytest.raises(NotImplementedError, match=func + msg):
  922:         ts.isocalendar()
  923:     func = "^timetuple"
  924:     with pytest.raises(NotImplementedError, match=func + msg):
  925:         ts.timetuple()
  926:     func = "^toordinal"
  927:     with pytest.raises(NotImplementedError, match=func + msg):
  928:         ts.toordinal()
