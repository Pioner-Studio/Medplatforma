    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: 
    6: import pytz
    7: 
    8: from pandas._libs.tslibs.timezones import dateutil_gettz as gettz
    9: import pandas.util._test_decorators as td
   10: 
   11: from pandas import Timestamp
   12: import pandas._testing as tm
   13: 
   14: 
   15: class TestTimestampToPyDatetime:
   16:     def test_to_pydatetime_fold(self):
   17:         # GH#45087
   18:         tzstr = "dateutil/usr/share/zoneinfo/America/Chicago"
   19:         ts = Timestamp(year=2013, month=11, day=3, hour=1, minute=0, fold=1, tz=tzstr)
   20:         dt = ts.to_pydatetime()
   21:         assert dt.fold == 1
   22: 
   23:     def test_to_pydatetime_nonzero_nano(self):
   24:         ts = Timestamp("2011-01-01 9:00:00.123456789")
   25: 
   26:         # Warn the user of data loss (nanoseconds).
   27:         with tm.assert_produces_warning(UserWarning):
   28:             expected = datetime(2011, 1, 1, 9, 0, 0, 123456)
   29:             result = ts.to_pydatetime()
   30:             assert result == expected
   31: 
   32:     def test_timestamp_to_datetime(self):
   33:         stamp = Timestamp("20090415", tz="US/Eastern")
   34:         dtval = stamp.to_pydatetime()
   35:         assert stamp == dtval
   36:         assert stamp.tzinfo == dtval.tzinfo
   37: 
   38:     def test_timestamp_to_pydatetime_dateutil(self):
   39:         stamp = Timestamp("20090415", tz="dateutil/US/Eastern")
   40:         dtval = stamp.to_pydatetime()
   41:         assert stamp == dtval
   42:         assert stamp.tzinfo == dtval.tzinfo
   43: 
   44:     def test_timestamp_to_pydatetime_explicit_pytz(self):
   45:         stamp = Timestamp("20090415", tz=pytz.timezone("US/Eastern"))
   46:         dtval = stamp.to_pydatetime()
   47:         assert stamp == dtval
   48:         assert stamp.tzinfo == dtval.tzinfo
   49: 
   50:     @td.skip_if_windows
   51:     def test_timestamp_to_pydatetime_explicit_dateutil(self):
   52:         stamp = Timestamp("20090415", tz=gettz("US/Eastern"))
   53:         dtval = stamp.to_pydatetime()
   54:         assert stamp == dtval
   55:         assert stamp.tzinfo == dtval.tzinfo
   56: 
   57:     def test_to_pydatetime_bijective(self):
   58:         # Ensure that converting to datetime and back only loses precision
   59:         # by going from nanoseconds to microseconds.
   60:         exp_warning = None if Timestamp.max.nanosecond == 0 else UserWarning
   61:         with tm.assert_produces_warning(exp_warning):
   62:             pydt_max = Timestamp.max.to_pydatetime()
   63: 
   64:         assert (
   65:             Timestamp(pydt_max).as_unit("ns")._value / 1000
   66:             == Timestamp.max._value / 1000
   67:         )
   68: 
   69:         exp_warning = None if Timestamp.min.nanosecond == 0 else UserWarning
   70:         with tm.assert_produces_warning(exp_warning):
   71:             pydt_min = Timestamp.min.to_pydatetime()
   72: 
   73:         # The next assertion can be enabled once GH#39221 is merged
   74:         #  assert pydt_min < Timestamp.min  # this is bc nanos are dropped
   75:         tdus = timedelta(microseconds=1)
   76:         assert pydt_min + tdus > Timestamp.min
   77: 
   78:         assert (
   79:             Timestamp(pydt_min + tdus).as_unit("ns")._value / 1000
   80:             == Timestamp.min._value / 1000
   81:         )
