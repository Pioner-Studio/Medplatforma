    1: import calendar
    2: from datetime import (
    3:     date,
    4:     datetime,
    5:     timedelta,
    6:     timezone,
    7: )
    8: import zoneinfo
    9: 
   10: import dateutil.tz
   11: from dateutil.tz import (
   12:     gettz,
   13:     tzoffset,
   14:     tzutc,
   15: )
   16: import numpy as np
   17: import pytest
   18: import pytz
   19: 
   20: from pandas._libs.tslibs.dtypes import NpyDatetimeUnit
   21: from pandas.compat import PY310
   22: from pandas.errors import OutOfBoundsDatetime
   23: 
   24: from pandas import (
   25:     NA,
   26:     NaT,
   27:     Period,
   28:     Timedelta,
   29:     Timestamp,
   30: )
   31: 
   32: 
   33: class TestTimestampConstructorUnitKeyword:
   34:     @pytest.mark.parametrize("typ", [int, float])
   35:     def test_constructor_int_float_with_YM_unit(self, typ):
   36:         # GH#47266 avoid the conversions in cast_from_unit
   37:         val = typ(150)
   38: 
   39:         ts = Timestamp(val, unit="Y")
   40:         expected = Timestamp("2120-01-01")
   41:         assert ts == expected
   42: 
   43:         ts = Timestamp(val, unit="M")
   44:         expected = Timestamp("1982-07-01")
   45:         assert ts == expected
   46: 
   47:     @pytest.mark.parametrize("typ", [int, float])
   48:     def test_construct_from_int_float_with_unit_out_of_bound_raises(self, typ):
   49:         # GH#50870  make sure we get a OutOfBoundsDatetime instead of OverflowError
   50:         val = typ(150000000000000)
   51: 
   52:         msg = f"cannot convert input {val} with the unit 'D'"
   53:         with pytest.raises(OutOfBoundsDatetime, match=msg):
   54:             Timestamp(val, unit="D")
   55: 
   56:     def test_constructor_float_not_round_with_YM_unit_raises(self):
   57:         # GH#47267 avoid the conversions in cast_from-unit
   58: 
   59:         msg = "Conversion of non-round float with unit=[MY] is ambiguous"
   60:         with pytest.raises(ValueError, match=msg):
   61:             Timestamp(150.5, unit="Y")
   62: 
   63:         with pytest.raises(ValueError, match=msg):
   64:             Timestamp(150.5, unit="M")
   65: 
   66:     @pytest.mark.parametrize(
   67:         "value, check_kwargs",
   68:         [
   69:             [946688461000000000, {}],
   70:             [946688461000000000 / 1000, {"unit": "us"}],
   71:             [946688461000000000 / 1_000_000, {"unit": "ms"}],
   72:             [946688461000000000 / 1_000_000_000, {"unit": "s"}],
   73:             [10957, {"unit": "D", "h": 0}],
   74:             [
   75:                 (946688461000000000 + 500000) / 1000000000,
   76:                 {"unit": "s", "us": 499, "ns": 964},
   77:             ],
   78:             [
   79:                 (946688461000000000 + 500000000) / 1000000000,
   80:                 {"unit": "s", "us": 500000},
   81:             ],
   82:             [(946688461000000000 + 500000) / 1000000, {"unit": "ms", "us": 500}],
   83:             [(946688461000000000 + 500000) / 1000, {"unit": "us", "us": 500}],
   84:             [(946688461000000000 + 500000000) / 1000000, {"unit": "ms", "us": 500000}],
   85:             [946688461000000000 / 1000.0 + 5, {"unit": "us", "us": 5}],
   86:             [946688461000000000 / 1000.0 + 5000, {"unit": "us", "us": 5000}],
   87:             [946688461000000000 / 1000000.0 + 0.5, {"unit": "ms", "us": 500}],
   88:             [946688461000000000 / 1000000.0 + 0.005, {"unit": "ms", "us": 5, "ns": 5}],
   89:             [946688461000000000 / 1000000000.0 + 0.5, {"unit": "s", "us": 500000}],
   90:             [10957 + 0.5, {"unit": "D", "h": 12}],
   91:         ],
   92:     )
   93:     def test_construct_with_unit(self, value, check_kwargs):
   94:         def check(value, unit=None, h=1, s=1, us=0, ns=0):
   95:             stamp = Timestamp(value, unit=unit)
   96:             assert stamp.year == 2000
   97:             assert stamp.month == 1
   98:             assert stamp.day == 1
   99:             assert stamp.hour == h
  100:             if unit != "D":
  101:                 assert stamp.minute == 1
  102:                 assert stamp.second == s
  103:                 assert stamp.microsecond == us
  104:             else:
  105:                 assert stamp.minute == 0
  106:                 assert stamp.second == 0
  107:                 assert stamp.microsecond == 0
  108:             assert stamp.nanosecond == ns
  109: 
  110:         check(value, **check_kwargs)
  111: 
  112: 
  113: class TestTimestampConstructorFoldKeyword:
  114:     def test_timestamp_constructor_invalid_fold_raise(self):
  115:         # Test for GH#25057
  116:         # Valid fold values are only [None, 0, 1]
  117:         msg = "Valid values for the fold argument are None, 0, or 1."
  118:         with pytest.raises(ValueError, match=msg):
  119:             Timestamp(123, fold=2)
  120: 
  121:     def test_timestamp_constructor_pytz_fold_raise(self):
  122:         # Test for GH#25057
  123:         # pytz doesn't support fold. Check that we raise
  124:         # if fold is passed with pytz
  125:         msg = "pytz timezones do not support fold. Please use dateutil timezones."
  126:         tz = pytz.timezone("Europe/London")
  127:         with pytest.raises(ValueError, match=msg):
  128:             Timestamp(datetime(2019, 10, 27, 0, 30, 0, 0), tz=tz, fold=0)
  129: 
  130:     @pytest.mark.parametrize("fold", [0, 1])
  131:     @pytest.mark.parametrize(
  132:         "ts_input",
  133:         [
  134:             1572136200000000000,
  135:             1572136200000000000.0,
  136:             np.datetime64(1572136200000000000, "ns"),
  137:             "2019-10-27 01:30:00+01:00",
  138:             datetime(2019, 10, 27, 0, 30, 0, 0, tzinfo=timezone.utc),
  139:         ],
  140:     )
  141:     def test_timestamp_constructor_fold_conflict(self, ts_input, fold):
  142:         # Test for GH#25057
  143:         # Check that we raise on fold conflict
  144:         msg = (
  145:             "Cannot pass fold with possibly unambiguous input: int, float, "
  146:             "numpy.datetime64, str, or timezone-aware datetime-like. "
  147:             "Pass naive datetime-like or build Timestamp from components."
  148:         )
  149:         with pytest.raises(ValueError, match=msg):
  150:             Timestamp(ts_input=ts_input, fold=fold)
  151: 
  152:     @pytest.mark.parametrize("tz", ["dateutil/Europe/London", None])
  153:     @pytest.mark.parametrize("fold", [0, 1])
  154:     def test_timestamp_constructor_retain_fold(self, tz, fold):
  155:         # Test for GH#25057
  156:         # Check that we retain fold
  157:         ts = Timestamp(year=2019, month=10, day=27, hour=1, minute=30, tz=tz, fold=fold)
  158:         result = ts.fold
  159:         expected = fold
  160:         assert result == expected
  161: 
  162:     try:
  163:         _tzs = [
  164:             "dateutil/Europe/London",
  165:             zoneinfo.ZoneInfo("Europe/London"),
  166:         ]
  167:     except zoneinfo.ZoneInfoNotFoundError:
  168:         _tzs = ["dateutil/Europe/London"]
  169: 
  170:     @pytest.mark.parametrize("tz", _tzs)
  171:     @pytest.mark.parametrize(
  172:         "ts_input,fold_out",
  173:         [
  174:             (1572136200000000000, 0),
  175:             (1572139800000000000, 1),
  176:             ("2019-10-27 01:30:00+01:00", 0),
  177:             ("2019-10-27 01:30:00+00:00", 1),
  178:             (datetime(2019, 10, 27, 1, 30, 0, 0, fold=0), 0),
  179:             (datetime(2019, 10, 27, 1, 30, 0, 0, fold=1), 1),
  180:         ],
  181:     )
  182:     def test_timestamp_constructor_infer_fold_from_value(self, tz, ts_input, fold_out):
  183:         # Test for GH#25057
  184:         # Check that we infer fold correctly based on timestamps since utc
  185:         # or strings
  186:         ts = Timestamp(ts_input, tz=tz)
  187:         result = ts.fold
  188:         expected = fold_out
  189:         assert result == expected
  190: 
  191:     @pytest.mark.parametrize("tz", ["dateutil/Europe/London"])
  192:     @pytest.mark.parametrize(
  193:         "ts_input,fold,value_out",
  194:         [
  195:             (datetime(2019, 10, 27, 1, 30, 0, 0), 0, 1572136200000000),
  196:             (datetime(2019, 10, 27, 1, 30, 0, 0), 1, 1572139800000000),
  197:         ],
  198:     )
  199:     def test_timestamp_constructor_adjust_value_for_fold(
  200:         self, tz, ts_input, fold, value_out
  201:     ):
  202:         # Test for GH#25057
  203:         # Check that we adjust value for fold correctly
  204:         # based on timestamps since utc
  205:         ts = Timestamp(ts_input, tz=tz, fold=fold)
  206:         result = ts._value
  207:         expected = value_out
  208:         assert result == expected
  209: 
  210: 
  211: class TestTimestampConstructorPositionalAndKeywordSupport:
  212:     def test_constructor_positional(self):
  213:         # see GH#10758
  214:         msg = (
  215:             "'NoneType' object cannot be interpreted as an integer"
  216:             if PY310
  217:             else "an integer is required"
  218:         )
  219:         with pytest.raises(TypeError, match=msg):
  220:             Timestamp(2000, 1)
  221: 
  222:         msg = "month must be in 1..12"
  223:         with pytest.raises(ValueError, match=msg):
  224:             Timestamp(2000, 0, 1)
  225:         with pytest.raises(ValueError, match=msg):
  226:             Timestamp(2000, 13, 1)
  227: 
  228:         msg = "day is out of range for month"
  229:         with pytest.raises(ValueError, match=msg):
  230:             Timestamp(2000, 1, 0)
  231:         with pytest.raises(ValueError, match=msg):
  232:             Timestamp(2000, 1, 32)
  233: 
  234:         # see gh-11630
  235:         assert repr(Timestamp(2015, 11, 12)) == repr(Timestamp("20151112"))
  236:         assert repr(Timestamp(2015, 11, 12, 1, 2, 3, 999999)) == repr(
  237:             Timestamp("2015-11-12 01:02:03.999999")
  238:         )
  239: 
  240:     def test_constructor_keyword(self):
  241:         # GH#10758
  242:         msg = "function missing required argument 'day'|Required argument 'day'"
  243:         with pytest.raises(TypeError, match=msg):
  244:             Timestamp(year=2000, month=1)
  245: 
  246:         msg = "month must be in 1..12"
  247:         with pytest.raises(ValueError, match=msg):
  248:             Timestamp(year=2000, month=0, day=1)
  249:         with pytest.raises(ValueError, match=msg):
  250:             Timestamp(year=2000, month=13, day=1)
  251: 
  252:         msg = "day is out of range for month"
  253:         with pytest.raises(ValueError, match=msg):
  254:             Timestamp(year=2000, month=1, day=0)
  255:         with pytest.raises(ValueError, match=msg):
  256:             Timestamp(year=2000, month=1, day=32)
  257: 
  258:         assert repr(Timestamp(year=2015, month=11, day=12)) == repr(
  259:             Timestamp("20151112")
  260:         )
  261: 
  262:         assert repr(
  263:             Timestamp(
  264:                 year=2015,
  265:                 month=11,
  266:                 day=12,
  267:                 hour=1,
  268:                 minute=2,
  269:                 second=3,
  270:                 microsecond=999999,
  271:             )
  272:         ) == repr(Timestamp("2015-11-12 01:02:03.999999"))
  273: 
  274:     @pytest.mark.parametrize(
  275:         "arg",
  276:         [
  277:             "year",
  278:             "month",
  279:             "day",
  280:             "hour",
  281:             "minute",
  282:             "second",
  283:             "microsecond",
  284:             "nanosecond",
  285:         ],
  286:     )
  287:     def test_invalid_date_kwarg_with_string_input(self, arg):
  288:         kwarg = {arg: 1}
  289:         msg = "Cannot pass a date attribute keyword argument"
  290:         with pytest.raises(ValueError, match=msg):
  291:             Timestamp("2010-10-10 12:59:59.999999999", **kwarg)
  292: 
  293:     @pytest.mark.parametrize("kwargs", [{}, {"year": 2020}, {"year": 2020, "month": 1}])
  294:     def test_constructor_missing_keyword(self, kwargs):
  295:         # GH#31200
  296: 
  297:         # The exact error message of datetime() depends on its version
  298:         msg1 = r"function missing required argument '(year|month|day)' \(pos [123]\)"
  299:         msg2 = r"Required argument '(year|month|day)' \(pos [123]\) not found"
  300:         msg = "|".join([msg1, msg2])
  301: 
  302:         with pytest.raises(TypeError, match=msg):
  303:             Timestamp(**kwargs)
  304: 
  305:     def test_constructor_positional_with_tzinfo(self):
  306:         # GH#31929
  307:         ts = Timestamp(2020, 12, 31, tzinfo=timezone.utc)
  308:         expected = Timestamp("2020-12-31", tzinfo=timezone.utc)
  309:         assert ts == expected
  310: 
  311:     @pytest.mark.parametrize("kwd", ["nanosecond", "microsecond", "second", "minute"])
  312:     def test_constructor_positional_keyword_mixed_with_tzinfo(self, kwd, request):
  313:         # TODO: if we passed microsecond with a keyword we would mess up
  314:         #  xref GH#45307
  315:         if kwd != "nanosecond":
  316:             # nanosecond is keyword-only as of 2.0, others are not
  317:             mark = pytest.mark.xfail(reason="GH#45307")
  318:             request.applymarker(mark)
  319: 
  320:         kwargs = {kwd: 4}
  321:         ts = Timestamp(2020, 12, 31, tzinfo=timezone.utc, **kwargs)
  322: 
  323:         td_kwargs = {kwd + "s": 4}
  324:         td = Timedelta(**td_kwargs)
  325:         expected = Timestamp("2020-12-31", tz=timezone.utc) + td
  326:         assert ts == expected
  327: 
  328: 
  329: class TestTimestampClassMethodConstructors:
  330:     # Timestamp constructors other than __new__
  331: 
  332:     def test_constructor_strptime(self):
  333:         # GH#25016
  334:         # Test support for Timestamp.strptime
  335:         fmt = "%Y%m%d-%H%M%S-%f%z"
  336:         ts = "20190129-235348-000001+0000"
  337:         msg = r"Timestamp.strptime\(\) is not implemented"
  338:         with pytest.raises(NotImplementedError, match=msg):
  339:             Timestamp.strptime(ts, fmt)
  340: 
  341:     def test_constructor_fromisocalendar(self):
  342:         # GH#30395
  343:         expected_timestamp = Timestamp("2000-01-03 00:00:00")
  344:         expected_stdlib = datetime.fromisocalendar(2000, 1, 1)
  345:         result = Timestamp.fromisocalendar(2000, 1, 1)
  346:         assert result == expected_timestamp
  347:         assert result == expected_stdlib
  348:         assert isinstance(result, Timestamp)
  349: 
  350:     def test_constructor_fromordinal(self):
  351:         base = datetime(2000, 1, 1)
  352: 
  353:         ts = Timestamp.fromordinal(base.toordinal())
  354:         assert base == ts
  355:         assert base.toordinal() == ts.toordinal()
  356: 
  357:         ts = Timestamp.fromordinal(base.toordinal(), tz="US/Eastern")
  358:         assert Timestamp("2000-01-01", tz="US/Eastern") == ts
  359:         assert base.toordinal() == ts.toordinal()
  360: 
  361:         # GH#3042
  362:         dt = datetime(2011, 4, 16, 0, 0)
  363:         ts = Timestamp.fromordinal(dt.toordinal())
  364:         assert ts.to_pydatetime() == dt
  365: 
  366:         # with a tzinfo
  367:         stamp = Timestamp("2011-4-16", tz="US/Eastern")
  368:         dt_tz = stamp.to_pydatetime()
  369:         ts = Timestamp.fromordinal(dt_tz.toordinal(), tz="US/Eastern")
  370:         assert ts.to_pydatetime() == dt_tz
  371: 
  372:     def test_now(self):
  373:         # GH#9000
  374:         ts_from_string = Timestamp("now")
  375:         ts_from_method = Timestamp.now()
  376:         ts_datetime = datetime.now()
  377: 
  378:         ts_from_string_tz = Timestamp("now", tz="US/Eastern")
  379:         ts_from_method_tz = Timestamp.now(tz="US/Eastern")
  380: 
  381:         # Check that the delta between the times is less than 1s (arbitrarily
  382:         # small)
  383:         delta = Timedelta(seconds=1)
  384:         assert abs(ts_from_method - ts_from_string) < delta
  385:         assert abs(ts_datetime - ts_from_method) < delta
  386:         assert abs(ts_from_method_tz - ts_from_string_tz) < delta
  387:         assert (
  388:             abs(
  389:                 ts_from_string_tz.tz_localize(None)
  390:                 - ts_from_method_tz.tz_localize(None)
  391:             )
  392:             < delta
  393:         )
  394: 
  395:     def test_today(self):
  396:         ts_from_string = Timestamp("today")
  397:         ts_from_method = Timestamp.today()
  398:         ts_datetime = datetime.today()
  399: 
  400:         ts_from_string_tz = Timestamp("today", tz="US/Eastern")
  401:         ts_from_method_tz = Timestamp.today(tz="US/Eastern")
  402: 
  403:         # Check that the delta between the times is less than 1s (arbitrarily
  404:         # small)
  405:         delta = Timedelta(seconds=1)
  406:         assert abs(ts_from_method - ts_from_string) < delta
  407:         assert abs(ts_datetime - ts_from_method) < delta
  408:         assert abs(ts_from_method_tz - ts_from_string_tz) < delta
  409:         assert (
  410:             abs(
  411:                 ts_from_string_tz.tz_localize(None)
  412:                 - ts_from_method_tz.tz_localize(None)
  413:             )
  414:             < delta
  415:         )
  416: 
  417: 
  418: class TestTimestampResolutionInference:
  419:     def test_construct_from_time_unit(self):
  420:         # GH#54097 only passing a time component, no date
  421:         ts = Timestamp("01:01:01.111")
  422:         assert ts.unit == "ms"
  423: 
  424:     def test_constructor_str_infer_reso(self):
  425:         # non-iso8601 path
  426: 
  427:         # _parse_delimited_date path
  428:         ts = Timestamp("01/30/2023")
  429:         assert ts.unit == "s"
  430: 
  431:         # _parse_dateabbr_string path
  432:         ts = Timestamp("2015Q1")
  433:         assert ts.unit == "s"
  434: 
  435:         # dateutil_parse path
  436:         ts = Timestamp("2016-01-01 1:30:01 PM")
  437:         assert ts.unit == "s"
  438: 
  439:         ts = Timestamp("2016 June 3 15:25:01.345")
  440:         assert ts.unit == "ms"
  441: 
  442:         ts = Timestamp("300-01-01")
  443:         assert ts.unit == "s"
  444: 
  445:         ts = Timestamp("300 June 1:30:01.300")
  446:         assert ts.unit == "ms"
  447: 
  448:         # dateutil path -> don't drop trailing zeros
  449:         ts = Timestamp("01-01-2013T00:00:00.000000000+0000")
  450:         assert ts.unit == "ns"
  451: 
  452:         ts = Timestamp("2016/01/02 03:04:05.001000 UTC")
  453:         assert ts.unit == "us"
  454: 
  455:         # higher-than-nanosecond -> we drop the trailing bits
  456:         ts = Timestamp("01-01-2013T00:00:00.000000002100+0000")
  457:         assert ts == Timestamp("01-01-2013T00:00:00.000000002+0000")
  458:         assert ts.unit == "ns"
  459: 
  460:         # GH#56208 minute reso through the ISO8601 path with tz offset
  461:         ts = Timestamp("2020-01-01 00:00+00:00")
  462:         assert ts.unit == "s"
  463: 
  464:         ts = Timestamp("2020-01-01 00+00:00")
  465:         assert ts.unit == "s"
  466: 
  467:     @pytest.mark.parametrize("method", ["now", "today"])
  468:     def test_now_today_unit(self, method):
  469:         # GH#55879
  470:         ts_from_method = getattr(Timestamp, method)()
  471:         ts_from_string = Timestamp(method)
  472:         assert ts_from_method.unit == ts_from_string.unit == "us"
  473: 
  474: 
  475: class TestTimestampConstructors:
  476:     def test_weekday_but_no_day_raises(self):
  477:         # GH#52659
  478:         msg = "Parsing datetimes with weekday but no day information is not supported"
  479:         with pytest.raises(ValueError, match=msg):
  480:             Timestamp("2023 Sept Thu")
  481: 
  482:     def test_construct_from_string_invalid_raises(self):
  483:         # dateutil (weirdly) parses "200622-12-31" as
  484:         #  datetime(2022, 6, 20, 12, 0, tzinfo=tzoffset(None, -111600)
  485:         #  which besides being mis-parsed, is a tzoffset that will cause
  486:         #  str(ts) to raise ValueError.  Ensure we raise in the constructor
  487:         #  instead.
  488:         # see test_to_datetime_malformed_raise for analogous to_datetime test
  489:         with pytest.raises(ValueError, match="gives an invalid tzoffset"):
  490:             Timestamp("200622-12-31")
  491: 
  492:     def test_constructor_from_iso8601_str_with_offset_reso(self):
  493:         # GH#49737
  494:         ts = Timestamp("2016-01-01 04:05:06-01:00")
  495:         assert ts.unit == "s"
  496: 
  497:         ts = Timestamp("2016-01-01 04:05:06.000-01:00")
  498:         assert ts.unit == "ms"
  499: 
  500:         ts = Timestamp("2016-01-01 04:05:06.000000-01:00")
  501:         assert ts.unit == "us"
  502: 
  503:         ts = Timestamp("2016-01-01 04:05:06.000000001-01:00")
  504:         assert ts.unit == "ns"
  505: 
  506:     def test_constructor_from_date_second_reso(self):
  507:         # GH#49034 constructing from a pydate object gets lowest supported
  508:         #  reso, i.e. seconds
  509:         obj = date(2012, 9, 1)
  510:         ts = Timestamp(obj)
  511:         assert ts.unit == "s"
  512: 
  513:     def test_constructor_datetime64_with_tz(self):
  514:         # GH#42288, GH#24559
  515:         dt = np.datetime64("1970-01-01 05:00:00")
  516:         tzstr = "UTC+05:00"
  517: 
  518:         # pre-2.0 this interpreted dt as a UTC time. in 2.0 this is treated
  519:         #  as a wall-time, consistent with DatetimeIndex behavior
  520:         ts = Timestamp(dt, tz=tzstr)
  521: 
  522:         alt = Timestamp(dt).tz_localize(tzstr)
  523:         assert ts == alt
  524:         assert ts.hour == 5
  525: 
  526:     def test_constructor(self):
  527:         base_str = "2014-07-01 09:00"
  528:         base_dt = datetime(2014, 7, 1, 9)
  529:         base_expected = 1_404_205_200_000_000_000
  530: 
  531:         # confirm base representation is correct
  532:         assert calendar.timegm(base_dt.timetuple()) * 1_000_000_000 == base_expected
  533: 
  534:         tests = [
  535:             (base_str, base_dt, base_expected),
  536:             (
  537:                 "2014-07-01 10:00",
  538:                 datetime(2014, 7, 1, 10),
  539:                 base_expected + 3600 * 1_000_000_000,
  540:             ),
  541:             (
  542:                 "2014-07-01 09:00:00.000008000",
  543:                 datetime(2014, 7, 1, 9, 0, 0, 8),
  544:                 base_expected + 8000,
  545:             ),
  546:             (
  547:                 "2014-07-01 09:00:00.000000005",
  548:                 Timestamp("2014-07-01 09:00:00.000000005"),
  549:                 base_expected + 5,
  550:             ),
  551:         ]
  552: 
  553:         timezones = [
  554:             (None, 0),
  555:             ("UTC", 0),
  556:             (pytz.utc, 0),
  557:             ("Asia/Tokyo", 9),
  558:             ("US/Eastern", -4),
  559:             ("dateutil/US/Pacific", -7),
  560:             (pytz.FixedOffset(-180), -3),
  561:             (dateutil.tz.tzoffset(None, 18000), 5),
  562:         ]
  563: 
  564:         for date_str, date_obj, expected in tests:
  565:             for result in [Timestamp(date_str), Timestamp(date_obj)]:
  566:                 result = result.as_unit("ns")  # test originally written before non-nano
  567:                 # only with timestring
  568:                 assert result.as_unit("ns")._value == expected
  569: 
  570:                 # re-creation shouldn't affect to internal value
  571:                 result = Timestamp(result)
  572:                 assert result.as_unit("ns")._value == expected
  573: 
  574:             # with timezone
  575:             for tz, offset in timezones:
  576:                 for result in [Timestamp(date_str, tz=tz), Timestamp(date_obj, tz=tz)]:
  577:                     result = result.as_unit(
  578:                         "ns"
  579:                     )  # test originally written before non-nano
  580:                     expected_tz = expected - offset * 3600 * 1_000_000_000
  581:                     assert result.as_unit("ns")._value == expected_tz
  582: 
  583:                     # should preserve tz
  584:                     result = Timestamp(result)
  585:                     assert result.as_unit("ns")._value == expected_tz
  586: 
  587:                     # should convert to UTC
  588:                     if tz is not None:
  589:                         result = Timestamp(result).tz_convert("UTC")
  590:                     else:
  591:                         result = Timestamp(result, tz="UTC")
  592:                     expected_utc = expected - offset * 3600 * 1_000_000_000
  593:                     assert result.as_unit("ns")._value == expected_utc
  594: 
  595:     def test_constructor_with_stringoffset(self):
  596:         # GH 7833
  597:         base_str = "2014-07-01 11:00:00+02:00"
  598:         base_dt = datetime(2014, 7, 1, 9)
  599:         base_expected = 1_404_205_200_000_000_000
  600: 
  601:         # confirm base representation is correct
  602:         assert calendar.timegm(base_dt.timetuple()) * 1_000_000_000 == base_expected
  603: 
  604:         tests = [
  605:             (base_str, base_expected),
  606:             ("2014-07-01 12:00:00+02:00", base_expected + 3600 * 1_000_000_000),
  607:             ("2014-07-01 11:00:00.000008000+02:00", base_expected + 8000),
  608:             ("2014-07-01 11:00:00.000000005+02:00", base_expected + 5),
  609:         ]
  610: 
  611:         timezones = [
  612:             (None, 0),
  613:             ("UTC", 0),
  614:             (pytz.utc, 0),
  615:             ("Asia/Tokyo", 9),
  616:             ("US/Eastern", -4),
  617:             ("dateutil/US/Pacific", -7),
  618:             (pytz.FixedOffset(-180), -3),
  619:             (dateutil.tz.tzoffset(None, 18000), 5),
  620:         ]
  621: 
  622:         for date_str, expected in tests:
  623:             for result in [Timestamp(date_str)]:
  624:                 # only with timestring
  625:                 assert result.as_unit("ns")._value == expected
  626: 
  627:                 # re-creation shouldn't affect to internal value
  628:                 result = Timestamp(result)
  629:                 assert result.as_unit("ns")._value == expected
  630: 
  631:             # with timezone
  632:             for tz, offset in timezones:
  633:                 result = Timestamp(date_str, tz=tz)
  634:                 expected_tz = expected
  635:                 assert result.as_unit("ns")._value == expected_tz
  636: 
  637:                 # should preserve tz
  638:                 result = Timestamp(result)
  639:                 assert result.as_unit("ns")._value == expected_tz
  640: 
  641:                 # should convert to UTC
  642:                 result = Timestamp(result).tz_convert("UTC")
  643:                 expected_utc = expected
  644:                 assert result.as_unit("ns")._value == expected_utc
  645: 
  646:         # This should be 2013-11-01 05:00 in UTC
  647:         # converted to Chicago tz
  648:         result = Timestamp("2013-11-01 00:00:00-0500", tz="America/Chicago")
  649:         assert result._value == Timestamp("2013-11-01 05:00")._value
  650:         expected = "Timestamp('2013-11-01 00:00:00-0500', tz='America/Chicago')"
  651:         assert repr(result) == expected
  652:         assert result == eval(repr(result))
  653: 
  654:         # This should be 2013-11-01 05:00 in UTC
  655:         # converted to Tokyo tz (+09:00)
  656:         result = Timestamp("2013-11-01 00:00:00-0500", tz="Asia/Tokyo")
  657:         assert result._value == Timestamp("2013-11-01 05:00")._value
  658:         expected = "Timestamp('2013-11-01 14:00:00+0900', tz='Asia/Tokyo')"
  659:         assert repr(result) == expected
  660:         assert result == eval(repr(result))
  661: 
  662:         # GH11708
  663:         # This should be 2015-11-18 10:00 in UTC
  664:         # converted to Asia/Katmandu
  665:         result = Timestamp("2015-11-18 15:45:00+05:45", tz="Asia/Katmandu")
  666:         assert result._value == Timestamp("2015-11-18 10:00")._value
  667:         expected = "Timestamp('2015-11-18 15:45:00+0545', tz='Asia/Katmandu')"
  668:         assert repr(result) == expected
  669:         assert result == eval(repr(result))
  670: 
  671:         # This should be 2015-11-18 10:00 in UTC
  672:         # converted to Asia/Kolkata
  673:         result = Timestamp("2015-11-18 15:30:00+05:30", tz="Asia/Kolkata")
  674:         assert result._value == Timestamp("2015-11-18 10:00")._value
  675:         expected = "Timestamp('2015-11-18 15:30:00+0530', tz='Asia/Kolkata')"
  676:         assert repr(result) == expected
  677:         assert result == eval(repr(result))
  678: 
  679:     def test_constructor_invalid(self):
  680:         msg = "Cannot convert input"
  681:         with pytest.raises(TypeError, match=msg):
  682:             Timestamp(slice(2))
  683:         msg = "Cannot convert Period"
  684:         with pytest.raises(ValueError, match=msg):
  685:             Timestamp(Period("1000-01-01"))
  686: 
  687:     def test_constructor_invalid_tz(self):
  688:         # GH#17690
  689:         msg = (
  690:             "Argument 'tzinfo' has incorrect type "
  691:             r"\(expected datetime.tzinfo, got str\)"
  692:         )
  693:         with pytest.raises(TypeError, match=msg):
  694:             Timestamp("2017-10-22", tzinfo="US/Eastern")
  695: 
  696:         msg = "at most one of"
  697:         with pytest.raises(ValueError, match=msg):
  698:             Timestamp("2017-10-22", tzinfo=pytz.utc, tz="UTC")
  699: 
  700:         msg = "Cannot pass a date attribute keyword argument when passing a date string"
  701:         with pytest.raises(ValueError, match=msg):
  702:             # GH#5168
  703:             # case where user tries to pass tz as an arg, not kwarg, gets
  704:             # interpreted as `year`
  705:             Timestamp("2012-01-01", "US/Pacific")
  706: 
  707:     def test_constructor_tz_or_tzinfo(self):
  708:         # GH#17943, GH#17690, GH#5168
  709:         stamps = [
  710:             Timestamp(year=2017, month=10, day=22, tz="UTC"),
  711:             Timestamp(year=2017, month=10, day=22, tzinfo=pytz.utc),
  712:             Timestamp(year=2017, month=10, day=22, tz=pytz.utc),
  713:             Timestamp(datetime(2017, 10, 22), tzinfo=pytz.utc),
  714:             Timestamp(datetime(2017, 10, 22), tz="UTC"),
  715:             Timestamp(datetime(2017, 10, 22), tz=pytz.utc),
  716:         ]
  717:         assert all(ts == stamps[0] for ts in stamps)
  718: 
  719:     @pytest.mark.parametrize(
  720:         "result",
  721:         [
  722:             Timestamp(datetime(2000, 1, 2, 3, 4, 5, 6), nanosecond=1),
  723:             Timestamp(
  724:                 year=2000,
  725:                 month=1,
  726:                 day=2,
  727:                 hour=3,
  728:                 minute=4,
  729:                 second=5,
  730:                 microsecond=6,
  731:                 nanosecond=1,
  732:             ),
  733:             Timestamp(
  734:                 year=2000,
  735:                 month=1,
  736:                 day=2,
  737:                 hour=3,
  738:                 minute=4,
  739:                 second=5,
  740:                 microsecond=6,
  741:                 nanosecond=1,
  742:                 tz="UTC",
  743:             ),
  744:             Timestamp(2000, 1, 2, 3, 4, 5, 6, None, nanosecond=1),
  745:             Timestamp(2000, 1, 2, 3, 4, 5, 6, tz=pytz.UTC, nanosecond=1),
  746:         ],
  747:     )
  748:     def test_constructor_nanosecond(self, result):
  749:         # GH 18898
  750:         # As of 2.0 (GH 49416), nanosecond should not be accepted positionally
  751:         expected = Timestamp(datetime(2000, 1, 2, 3, 4, 5, 6), tz=result.tz)
  752:         expected = expected + Timedelta(nanoseconds=1)
  753:         assert result == expected
  754: 
  755:     @pytest.mark.parametrize("z", ["Z0", "Z00"])
  756:     def test_constructor_invalid_Z0_isostring(self, z):
  757:         # GH 8910
  758:         msg = f"Unknown datetime string format, unable to parse: 2014-11-02 01:00{z}"
  759:         with pytest.raises(ValueError, match=msg):
  760:             Timestamp(f"2014-11-02 01:00{z}")
  761: 
  762:     def test_out_of_bounds_integer_value(self):
  763:         # GH#26651 check that we raise OutOfBoundsDatetime, not OverflowError
  764:         msg = str(Timestamp.max._value * 2)
  765:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  766:             Timestamp(Timestamp.max._value * 2)
  767:         msg = str(Timestamp.min._value * 2)
  768:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  769:             Timestamp(Timestamp.min._value * 2)
  770: 
  771:     def test_out_of_bounds_value(self):
  772:         one_us = np.timedelta64(1).astype("timedelta64[us]")
  773: 
  774:         # By definition we can't go out of bounds in [ns], so we
  775:         # convert the datetime64s to [us] so we can go out of bounds
  776:         min_ts_us = np.datetime64(Timestamp.min).astype("M8[us]") + one_us
  777:         max_ts_us = np.datetime64(Timestamp.max).astype("M8[us]")
  778: 
  779:         # No error for the min/max datetimes
  780:         Timestamp(min_ts_us)
  781:         Timestamp(max_ts_us)
  782: 
  783:         # We used to raise on these before supporting non-nano
  784:         us_val = NpyDatetimeUnit.NPY_FR_us.value
  785:         assert Timestamp(min_ts_us - one_us)._creso == us_val
  786:         assert Timestamp(max_ts_us + one_us)._creso == us_val
  787: 
  788:         # https://github.com/numpy/numpy/issues/22346 for why
  789:         #  we can't use the same construction as above with minute resolution
  790: 
  791:         # too_low, too_high are the _just_ outside the range of M8[s]
  792:         too_low = np.datetime64("-292277022657-01-27T08:29", "m")
  793:         too_high = np.datetime64("292277026596-12-04T15:31", "m")
  794: 
  795:         msg = "Out of bounds"
  796:         # One us less than the minimum is an error
  797:         with pytest.raises(ValueError, match=msg):
  798:             Timestamp(too_low)
  799: 
  800:         # One us more than the maximum is an error
  801:         with pytest.raises(ValueError, match=msg):
  802:             Timestamp(too_high)
  803: 
  804:     def test_out_of_bounds_string(self):
  805:         msg = "Cannot cast .* to unit='ns' without overflow"
  806:         with pytest.raises(ValueError, match=msg):
  807:             Timestamp("1676-01-01").as_unit("ns")
  808:         with pytest.raises(ValueError, match=msg):
  809:             Timestamp("2263-01-01").as_unit("ns")
  810: 
  811:         ts = Timestamp("2263-01-01")
  812:         assert ts.unit == "s"
  813: 
  814:         ts = Timestamp("1676-01-01")
  815:         assert ts.unit == "s"
  816: 
  817:     def test_barely_out_of_bounds(self):
  818:         # GH#19529
  819:         # GH#19382 close enough to bounds that dropping nanos would result
  820:         # in an in-bounds datetime
  821:         msg = "Out of bounds nanosecond timestamp: 2262-04-11 23:47:16"
  822:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  823:             Timestamp("2262-04-11 23:47:16.854775808")
  824: 
  825:     @pytest.mark.skip_ubsan
  826:     def test_bounds_with_different_units(self):
  827:         out_of_bounds_dates = ("1677-09-21", "2262-04-12")
  828: 
  829:         time_units = ("D", "h", "m", "s", "ms", "us")
  830: 
  831:         for date_string in out_of_bounds_dates:
  832:             for unit in time_units:
  833:                 dt64 = np.datetime64(date_string, unit)
  834:                 ts = Timestamp(dt64)
  835:                 if unit in ["s", "ms", "us"]:
  836:                     # We can preserve the input unit
  837:                     assert ts._value == dt64.view("i8")
  838:                 else:
  839:                     # we chose the closest unit that we _do_ support
  840:                     assert ts._creso == NpyDatetimeUnit.NPY_FR_s.value
  841: 
  842:         # With more extreme cases, we can't even fit inside second resolution
  843:         info = np.iinfo(np.int64)
  844:         msg = "Out of bounds second timestamp:"
  845:         for value in [info.min + 1, info.max]:
  846:             for unit in ["D", "h", "m"]:
  847:                 dt64 = np.datetime64(value, unit)
  848:                 with pytest.raises(OutOfBoundsDatetime, match=msg):
  849:                     Timestamp(dt64)
  850: 
  851:         in_bounds_dates = ("1677-09-23", "2262-04-11")
  852: 
  853:         for date_string in in_bounds_dates:
  854:             for unit in time_units:
  855:                 dt64 = np.datetime64(date_string, unit)
  856:                 Timestamp(dt64)
  857: 
  858:     @pytest.mark.parametrize("arg", ["001-01-01", "0001-01-01"])
  859:     def test_out_of_bounds_string_consistency(self, arg):
  860:         # GH 15829
  861:         msg = "Cannot cast 0001-01-01 00:00:00 to unit='ns' without overflow"
  862:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  863:             Timestamp(arg).as_unit("ns")
  864: 
  865:         ts = Timestamp(arg)
  866:         assert ts.unit == "s"
  867:         assert ts.year == ts.month == ts.day == 1
  868: 
  869:     def test_min_valid(self):
  870:         # Ensure that Timestamp.min is a valid Timestamp
  871:         Timestamp(Timestamp.min)
  872: 
  873:     def test_max_valid(self):
  874:         # Ensure that Timestamp.max is a valid Timestamp
  875:         Timestamp(Timestamp.max)
  876: 
  877:     @pytest.mark.parametrize("offset", ["+0300", "+0200"])
  878:     def test_construct_timestamp_near_dst(self, offset):
  879:         # GH 20854
  880:         expected = Timestamp(f"2016-10-30 03:00:00{offset}", tz="Europe/Helsinki")
  881:         result = Timestamp(expected).tz_convert("Europe/Helsinki")
  882:         assert result == expected
  883: 
  884:     @pytest.mark.parametrize(
  885:         "arg", ["2013/01/01 00:00:00+09:00", "2013-01-01 00:00:00+09:00"]
  886:     )
  887:     def test_construct_with_different_string_format(self, arg):
  888:         # GH 12064
  889:         result = Timestamp(arg)
  890:         expected = Timestamp(datetime(2013, 1, 1), tz=pytz.FixedOffset(540))
  891:         assert result == expected
  892: 
  893:     @pytest.mark.parametrize("box", [datetime, Timestamp])
  894:     def test_raise_tz_and_tzinfo_in_datetime_input(self, box):
  895:         # GH 23579
  896:         kwargs = {"year": 2018, "month": 1, "day": 1, "tzinfo": pytz.utc}
  897:         msg = "Cannot pass a datetime or Timestamp"
  898:         with pytest.raises(ValueError, match=msg):
  899:             Timestamp(box(**kwargs), tz="US/Pacific")
  900:         msg = "Cannot pass a datetime or Timestamp"
  901:         with pytest.raises(ValueError, match=msg):
  902:             Timestamp(box(**kwargs), tzinfo=pytz.timezone("US/Pacific"))
  903: 
  904:     def test_dont_convert_dateutil_utc_to_pytz_utc(self):
  905:         result = Timestamp(datetime(2018, 1, 1), tz=tzutc())
  906:         expected = Timestamp(datetime(2018, 1, 1)).tz_localize(tzutc())
  907:         assert result == expected
  908: 
  909:     def test_constructor_subclassed_datetime(self):
  910:         # GH 25851
  911:         # ensure that subclassed datetime works for
  912:         # Timestamp creation
  913:         class SubDatetime(datetime):
  914:             pass
  915: 
  916:         data = SubDatetime(2000, 1, 1)
  917:         result = Timestamp(data)
  918:         expected = Timestamp(2000, 1, 1)
  919:         assert result == expected
  920: 
  921:     def test_timestamp_constructor_tz_utc(self):
  922:         utc_stamp = Timestamp("3/11/2012 05:00", tz="utc")
  923:         assert utc_stamp.tzinfo is timezone.utc
  924:         assert utc_stamp.hour == 5
  925: 
  926:         utc_stamp = Timestamp("3/11/2012 05:00").tz_localize("utc")
  927:         assert utc_stamp.hour == 5
  928: 
  929:     def test_timestamp_to_datetime_tzoffset(self):
  930:         tzinfo = tzoffset(None, 7200)
  931:         expected = Timestamp("3/11/2012 04:00", tz=tzinfo)
  932:         result = Timestamp(expected.to_pydatetime())
  933:         assert expected == result
  934: 
  935:     def test_timestamp_constructor_near_dst_boundary(self):
  936:         # GH#11481 & GH#15777
  937:         # Naive string timestamps were being localized incorrectly
  938:         # with tz_convert_from_utc_single instead of tz_localize_to_utc
  939: 
  940:         for tz in ["Europe/Brussels", "Europe/Prague"]:
  941:             result = Timestamp("2015-10-25 01:00", tz=tz)
  942:             expected = Timestamp("2015-10-25 01:00").tz_localize(tz)
  943:             assert result == expected
  944: 
  945:             msg = "Cannot infer dst time from 2015-10-25 02:00:00"
  946:             with pytest.raises(pytz.AmbiguousTimeError, match=msg):
  947:                 Timestamp("2015-10-25 02:00", tz=tz)
  948: 
  949:         result = Timestamp("2017-03-26 01:00", tz="Europe/Paris")
  950:         expected = Timestamp("2017-03-26 01:00").tz_localize("Europe/Paris")
  951:         assert result == expected
  952: 
  953:         msg = "2017-03-26 02:00"
  954:         with pytest.raises(pytz.NonExistentTimeError, match=msg):
  955:             Timestamp("2017-03-26 02:00", tz="Europe/Paris")
  956: 
  957:         # GH#11708
  958:         naive = Timestamp("2015-11-18 10:00:00")
  959:         result = naive.tz_localize("UTC").tz_convert("Asia/Kolkata")
  960:         expected = Timestamp("2015-11-18 15:30:00+0530", tz="Asia/Kolkata")
  961:         assert result == expected
  962: 
  963:         # GH#15823
  964:         result = Timestamp("2017-03-26 00:00", tz="Europe/Paris")
  965:         expected = Timestamp("2017-03-26 00:00:00+0100", tz="Europe/Paris")
  966:         assert result == expected
  967: 
  968:         result = Timestamp("2017-03-26 01:00", tz="Europe/Paris")
  969:         expected = Timestamp("2017-03-26 01:00:00+0100", tz="Europe/Paris")
  970:         assert result == expected
  971: 
  972:         msg = "2017-03-26 02:00"
  973:         with pytest.raises(pytz.NonExistentTimeError, match=msg):
  974:             Timestamp("2017-03-26 02:00", tz="Europe/Paris")
  975: 
  976:         result = Timestamp("2017-03-26 02:00:00+0100", tz="Europe/Paris")
  977:         naive = Timestamp(result.as_unit("ns")._value)
  978:         expected = naive.tz_localize("UTC").tz_convert("Europe/Paris")
  979:         assert result == expected
  980: 
  981:         result = Timestamp("2017-03-26 03:00", tz="Europe/Paris")
  982:         expected = Timestamp("2017-03-26 03:00:00+0200", tz="Europe/Paris")
  983:         assert result == expected
  984: 
  985:     @pytest.mark.parametrize(
  986:         "tz",
  987:         [
  988:             pytz.timezone("US/Eastern"),
  989:             gettz("US/Eastern"),
  990:             "US/Eastern",
  991:             "dateutil/US/Eastern",
  992:         ],
  993:     )
  994:     def test_timestamp_constructed_by_date_and_tz(self, tz):
  995:         # GH#2993, Timestamp cannot be constructed by datetime.date
  996:         # and tz correctly
  997: 
  998:         result = Timestamp(date(2012, 3, 11), tz=tz)
  999: 
 1000:         expected = Timestamp("3/11/2012", tz=tz)
 1001:         assert result.hour == expected.hour
 1002:         assert result == expected
 1003: 
 1004: 
 1005: def test_constructor_ambiguous_dst():
 1006:     # GH 24329
 1007:     # Make sure that calling Timestamp constructor
 1008:     # on Timestamp created from ambiguous time
 1009:     # doesn't change Timestamp.value
 1010:     ts = Timestamp(1382835600000000000, tz="dateutil/Europe/London")
 1011:     expected = ts._value
 1012:     result = Timestamp(ts)._value
 1013:     assert result == expected
 1014: 
 1015: 
 1016: @pytest.mark.parametrize("epoch", [1552211999999999872, 1552211999999999999])
 1017: def test_constructor_before_dst_switch(epoch):
 1018:     # GH 31043
 1019:     # Make sure that calling Timestamp constructor
 1020:     # on time just before DST switch doesn't lead to
 1021:     # nonexistent time or value change
 1022:     ts = Timestamp(epoch, tz="dateutil/America/Los_Angeles")
 1023:     result = ts.tz.dst(ts)
 1024:     expected = timedelta(seconds=0)
 1025:     assert Timestamp(ts)._value == epoch
 1026:     assert result == expected
 1027: 
 1028: 
 1029: def test_timestamp_constructor_identity():
 1030:     # Test for #30543
 1031:     expected = Timestamp("2017-01-01T12")
 1032:     result = Timestamp(expected)
 1033:     assert result is expected
 1034: 
 1035: 
 1036: @pytest.mark.parametrize("nano", [-1, 1000])
 1037: def test_timestamp_nano_range(nano):
 1038:     # GH 48255
 1039:     with pytest.raises(ValueError, match="nanosecond must be in 0..999"):
 1040:         Timestamp(year=2022, month=1, day=1, nanosecond=nano)
 1041: 
 1042: 
 1043: def test_non_nano_value():
 1044:     # https://github.com/pandas-dev/pandas/issues/49076
 1045:     result = Timestamp("1800-01-01", unit="s").value
 1046:     # `.value` shows nanoseconds, even though unit is 's'
 1047:     assert result == -5364662400000000000
 1048: 
 1049:     # out-of-nanoseconds-bounds `.value` raises informative message
 1050:     msg = (
 1051:         r"Cannot convert Timestamp to nanoseconds without overflow. "
 1052:         r"Use `.asm8.view\('i8'\)` to cast represent Timestamp in its "
 1053:         r"own unit \(here, s\).$"
 1054:     )
 1055:     ts = Timestamp("0300-01-01")
 1056:     with pytest.raises(OverflowError, match=msg):
 1057:         ts.value
 1058:     # check that the suggested workaround actually works
 1059:     result = ts.asm8.view("i8")
 1060:     assert result == -52700112000
 1061: 
 1062: 
 1063: @pytest.mark.parametrize("na_value", [None, np.nan, np.datetime64("NaT"), NaT, NA])
 1064: def test_timestamp_constructor_na_value(na_value):
 1065:     # GH45481
 1066:     result = Timestamp(na_value)
 1067:     expected = NaT
 1068:     assert result is expected
