    1: from hypothesis import (
    2:     given,
    3:     strategies as st,
    4: )
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas._libs import lib
    9: from pandas._libs.tslibs import iNaT
   10: from pandas.errors import OutOfBoundsTimedelta
   11: 
   12: from pandas import Timedelta
   13: 
   14: 
   15: class TestTimedeltaRound:
   16:     @pytest.mark.parametrize(
   17:         "freq,s1,s2",
   18:         [
   19:             # This first case has s1, s2 being the same as t1,t2 below
   20:             (
   21:                 "ns",
   22:                 Timedelta("1 days 02:34:56.789123456"),
   23:                 Timedelta("-1 days 02:34:56.789123456"),
   24:             ),
   25:             (
   26:                 "us",
   27:                 Timedelta("1 days 02:34:56.789123000"),
   28:                 Timedelta("-1 days 02:34:56.789123000"),
   29:             ),
   30:             (
   31:                 "ms",
   32:                 Timedelta("1 days 02:34:56.789000000"),
   33:                 Timedelta("-1 days 02:34:56.789000000"),
   34:             ),
   35:             ("s", Timedelta("1 days 02:34:57"), Timedelta("-1 days 02:34:57")),
   36:             ("2s", Timedelta("1 days 02:34:56"), Timedelta("-1 days 02:34:56")),
   37:             ("5s", Timedelta("1 days 02:34:55"), Timedelta("-1 days 02:34:55")),
   38:             ("min", Timedelta("1 days 02:35:00"), Timedelta("-1 days 02:35:00")),
   39:             ("12min", Timedelta("1 days 02:36:00"), Timedelta("-1 days 02:36:00")),
   40:             ("h", Timedelta("1 days 03:00:00"), Timedelta("-1 days 03:00:00")),
   41:             ("d", Timedelta("1 days"), Timedelta("-1 days")),
   42:         ],
   43:     )
   44:     def test_round(self, freq, s1, s2):
   45:         t1 = Timedelta("1 days 02:34:56.789123456")
   46:         t2 = Timedelta("-1 days 02:34:56.789123456")
   47: 
   48:         r1 = t1.round(freq)
   49:         assert r1 == s1
   50:         r2 = t2.round(freq)
   51:         assert r2 == s2
   52: 
   53:     def test_round_invalid(self):
   54:         t1 = Timedelta("1 days 02:34:56.789123456")
   55: 
   56:         for freq, msg in [
   57:             ("YE", "<YearEnd: month=12> is a non-fixed frequency"),
   58:             ("ME", "<MonthEnd> is a non-fixed frequency"),
   59:             ("foobar", "Invalid frequency: foobar"),
   60:         ]:
   61:             with pytest.raises(ValueError, match=msg):
   62:                 t1.round(freq)
   63: 
   64:     @pytest.mark.skip_ubsan
   65:     def test_round_implementation_bounds(self):
   66:         # See also: analogous test for Timestamp
   67:         # GH#38964
   68:         result = Timedelta.min.ceil("s")
   69:         expected = Timedelta.min + Timedelta(seconds=1) - Timedelta(145224193)
   70:         assert result == expected
   71: 
   72:         result = Timedelta.max.floor("s")
   73:         expected = Timedelta.max - Timedelta(854775807)
   74:         assert result == expected
   75: 
   76:         msg = (
   77:             r"Cannot round -106752 days \+00:12:43.145224193 to freq=s without overflow"
   78:         )
   79:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
   80:             Timedelta.min.floor("s")
   81:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
   82:             Timedelta.min.round("s")
   83: 
   84:         msg = "Cannot round 106751 days 23:47:16.854775807 to freq=s without overflow"
   85:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
   86:             Timedelta.max.ceil("s")
   87:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
   88:             Timedelta.max.round("s")
   89: 
   90:     @pytest.mark.skip_ubsan
   91:     @given(val=st.integers(min_value=iNaT + 1, max_value=lib.i8max))
   92:     @pytest.mark.parametrize(
   93:         "method", [Timedelta.round, Timedelta.floor, Timedelta.ceil]
   94:     )
   95:     def test_round_sanity(self, val, method):
   96:         cls = Timedelta
   97:         err_cls = OutOfBoundsTimedelta
   98: 
   99:         val = np.int64(val)
  100:         td = cls(val)
  101: 
  102:         def checker(ts, nanos, unit):
  103:             # First check that we do raise in cases where we should
  104:             if nanos == 1:
  105:                 pass
  106:             else:
  107:                 div, mod = divmod(ts._value, nanos)
  108:                 diff = int(nanos - mod)
  109:                 lb = ts._value - mod
  110:                 assert lb <= ts._value  # i.e. no overflows with python ints
  111:                 ub = ts._value + diff
  112:                 assert ub > ts._value  # i.e. no overflows with python ints
  113: 
  114:                 msg = "without overflow"
  115:                 if mod == 0:
  116:                     # We should never be raising in this
  117:                     pass
  118:                 elif method is cls.ceil:
  119:                     if ub > cls.max._value:
  120:                         with pytest.raises(err_cls, match=msg):
  121:                             method(ts, unit)
  122:                         return
  123:                 elif method is cls.floor:
  124:                     if lb < cls.min._value:
  125:                         with pytest.raises(err_cls, match=msg):
  126:                             method(ts, unit)
  127:                         return
  128:                 elif mod >= diff:
  129:                     if ub > cls.max._value:
  130:                         with pytest.raises(err_cls, match=msg):
  131:                             method(ts, unit)
  132:                         return
  133:                 elif lb < cls.min._value:
  134:                     with pytest.raises(err_cls, match=msg):
  135:                         method(ts, unit)
  136:                     return
  137: 
  138:             res = method(ts, unit)
  139: 
  140:             td = res - ts
  141:             diff = abs(td._value)
  142:             assert diff < nanos
  143:             assert res._value % nanos == 0
  144: 
  145:             if method is cls.round:
  146:                 assert diff <= nanos / 2
  147:             elif method is cls.floor:
  148:                 assert res <= ts
  149:             elif method is cls.ceil:
  150:                 assert res >= ts
  151: 
  152:         nanos = 1
  153:         checker(td, nanos, "ns")
  154: 
  155:         nanos = 1000
  156:         checker(td, nanos, "us")
  157: 
  158:         nanos = 1_000_000
  159:         checker(td, nanos, "ms")
  160: 
  161:         nanos = 1_000_000_000
  162:         checker(td, nanos, "s")
  163: 
  164:         nanos = 60 * 1_000_000_000
  165:         checker(td, nanos, "min")
  166: 
  167:         nanos = 60 * 60 * 1_000_000_000
  168:         checker(td, nanos, "h")
  169: 
  170:         nanos = 24 * 60 * 60 * 1_000_000_000
  171:         checker(td, nanos, "D")
  172: 
  173:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s"])
  174:     def test_round_non_nano(self, unit):
  175:         td = Timedelta("1 days 02:34:57").as_unit(unit)
  176: 
  177:         res = td.round("min")
  178:         assert res == Timedelta("1 days 02:35:00")
  179:         assert res._creso == td._creso
  180: 
  181:         res = td.floor("min")
  182:         assert res == Timedelta("1 days 02:34:00")
  183:         assert res._creso == td._creso
  184: 
  185:         res = td.ceil("min")
  186:         assert res == Timedelta("1 days 02:35:00")
  187:         assert res._creso == td._creso
