    1: from hypothesis import (
    2:     given,
    3:     strategies as st,
    4: )
    5: import numpy as np
    6: import pytest
    7: import pytz
    8: 
    9: from pandas._libs import lib
   10: from pandas._libs.tslibs import (
   11:     NaT,
   12:     OutOfBoundsDatetime,
   13:     Timedelta,
   14:     Timestamp,
   15:     iNaT,
   16:     to_offset,
   17: )
   18: from pandas._libs.tslibs.dtypes import NpyDatetimeUnit
   19: from pandas._libs.tslibs.period import INVALID_FREQ_ERR_MSG
   20: 
   21: import pandas._testing as tm
   22: 
   23: 
   24: class TestTimestampRound:
   25:     def test_round_division_by_zero_raises(self):
   26:         ts = Timestamp("2016-01-01")
   27: 
   28:         msg = "Division by zero in rounding"
   29:         with pytest.raises(ValueError, match=msg):
   30:             ts.round("0ns")
   31: 
   32:     @pytest.mark.parametrize(
   33:         "timestamp, freq, expected",
   34:         [
   35:             ("20130101 09:10:11", "D", "20130101"),
   36:             ("20130101 19:10:11", "D", "20130102"),
   37:             ("20130201 12:00:00", "D", "20130202"),
   38:             ("20130104 12:00:00", "D", "20130105"),
   39:             ("2000-01-05 05:09:15.13", "D", "2000-01-05 00:00:00"),
   40:             ("2000-01-05 05:09:15.13", "h", "2000-01-05 05:00:00"),
   41:             ("2000-01-05 05:09:15.13", "s", "2000-01-05 05:09:15"),
   42:         ],
   43:     )
   44:     def test_round_frequencies(self, timestamp, freq, expected):
   45:         dt = Timestamp(timestamp)
   46:         result = dt.round(freq)
   47:         expected = Timestamp(expected)
   48:         assert result == expected
   49: 
   50:     def test_round_tzaware(self):
   51:         dt = Timestamp("20130101 09:10:11", tz="US/Eastern")
   52:         result = dt.round("D")
   53:         expected = Timestamp("20130101", tz="US/Eastern")
   54:         assert result == expected
   55: 
   56:         dt = Timestamp("20130101 09:10:11", tz="US/Eastern")
   57:         result = dt.round("s")
   58:         assert result == dt
   59: 
   60:     def test_round_30min(self):
   61:         # round
   62:         dt = Timestamp("20130104 12:32:00")
   63:         result = dt.round("30Min")
   64:         expected = Timestamp("20130104 12:30:00")
   65:         assert result == expected
   66: 
   67:     def test_round_subsecond(self):
   68:         # GH#14440 & GH#15578
   69:         result = Timestamp("2016-10-17 12:00:00.0015").round("ms")
   70:         expected = Timestamp("2016-10-17 12:00:00.002000")
   71:         assert result == expected
   72: 
   73:         result = Timestamp("2016-10-17 12:00:00.00149").round("ms")
   74:         expected = Timestamp("2016-10-17 12:00:00.001000")
   75:         assert result == expected
   76: 
   77:         ts = Timestamp("2016-10-17 12:00:00.0015")
   78:         for freq in ["us", "ns"]:
   79:             assert ts == ts.round(freq)
   80: 
   81:         result = Timestamp("2016-10-17 12:00:00.001501031").round("10ns")
   82:         expected = Timestamp("2016-10-17 12:00:00.001501030")
   83:         assert result == expected
   84: 
   85:     def test_round_nonstandard_freq(self):
   86:         with tm.assert_produces_warning(False):
   87:             Timestamp("2016-10-17 12:00:00.001501031").round("1010ns")
   88: 
   89:     def test_round_invalid_arg(self):
   90:         stamp = Timestamp("2000-01-05 05:09:15.13")
   91:         with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):
   92:             stamp.round("foo")
   93: 
   94:     @pytest.mark.parametrize(
   95:         "test_input, rounder, freq, expected",
   96:         [
   97:             ("2117-01-01 00:00:45", "floor", "15s", "2117-01-01 00:00:45"),
   98:             ("2117-01-01 00:00:45", "ceil", "15s", "2117-01-01 00:00:45"),
   99:             (
  100:                 "2117-01-01 00:00:45.000000012",
  101:                 "floor",
  102:                 "10ns",
  103:                 "2117-01-01 00:00:45.000000010",
  104:             ),
  105:             (
  106:                 "1823-01-01 00:00:01.000000012",
  107:                 "ceil",
  108:                 "10ns",
  109:                 "1823-01-01 00:00:01.000000020",
  110:             ),
  111:             ("1823-01-01 00:00:01", "floor", "1s", "1823-01-01 00:00:01"),
  112:             ("1823-01-01 00:00:01", "ceil", "1s", "1823-01-01 00:00:01"),
  113:             ("NaT", "floor", "1s", "NaT"),
  114:             ("NaT", "ceil", "1s", "NaT"),
  115:         ],
  116:     )
  117:     def test_ceil_floor_edge(self, test_input, rounder, freq, expected):
  118:         dt = Timestamp(test_input)
  119:         func = getattr(dt, rounder)
  120:         result = func(freq)
  121: 
  122:         if dt is NaT:
  123:             assert result is NaT
  124:         else:
  125:             expected = Timestamp(expected)
  126:             assert result == expected
  127: 
  128:     @pytest.mark.parametrize(
  129:         "test_input, freq, expected",
  130:         [
  131:             ("2018-01-01 00:02:06", "2s", "2018-01-01 00:02:06"),
  132:             ("2018-01-01 00:02:00", "2min", "2018-01-01 00:02:00"),
  133:             ("2018-01-01 00:04:00", "4min", "2018-01-01 00:04:00"),
  134:             ("2018-01-01 00:15:00", "15min", "2018-01-01 00:15:00"),
  135:             ("2018-01-01 00:20:00", "20min", "2018-01-01 00:20:00"),
  136:             ("2018-01-01 03:00:00", "3h", "2018-01-01 03:00:00"),
  137:         ],
  138:     )
  139:     @pytest.mark.parametrize("rounder", ["ceil", "floor", "round"])
  140:     def test_round_minute_freq(self, test_input, freq, expected, rounder):
  141:         # Ensure timestamps that shouldn't round dont!
  142:         # GH#21262
  143: 
  144:         dt = Timestamp(test_input)
  145:         expected = Timestamp(expected)
  146:         func = getattr(dt, rounder)
  147:         result = func(freq)
  148:         assert result == expected
  149: 
  150:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s"])
  151:     def test_ceil(self, unit):
  152:         dt = Timestamp("20130101 09:10:11").as_unit(unit)
  153:         result = dt.ceil("D")
  154:         expected = Timestamp("20130102")
  155:         assert result == expected
  156:         assert result._creso == dt._creso
  157: 
  158:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s"])
  159:     def test_floor(self, unit):
  160:         dt = Timestamp("20130101 09:10:11").as_unit(unit)
  161:         result = dt.floor("D")
  162:         expected = Timestamp("20130101")
  163:         assert result == expected
  164:         assert result._creso == dt._creso
  165: 
  166:     @pytest.mark.parametrize("method", ["ceil", "round", "floor"])
  167:     @pytest.mark.parametrize(
  168:         "unit",
  169:         ["ns", "us", "ms", "s"],
  170:     )
  171:     def test_round_dst_border_ambiguous(self, method, unit):
  172:         # GH 18946 round near "fall back" DST
  173:         ts = Timestamp("2017-10-29 00:00:00", tz="UTC").tz_convert("Europe/Madrid")
  174:         ts = ts.as_unit(unit)
  175:         #
  176:         result = getattr(ts, method)("h", ambiguous=True)
  177:         assert result == ts
  178:         assert result._creso == getattr(NpyDatetimeUnit, f"NPY_FR_{unit}").value
  179: 
  180:         result = getattr(ts, method)("h", ambiguous=False)
  181:         expected = Timestamp("2017-10-29 01:00:00", tz="UTC").tz_convert(
  182:             "Europe/Madrid"
  183:         )
  184:         assert result == expected
  185:         assert result._creso == getattr(NpyDatetimeUnit, f"NPY_FR_{unit}").value
  186: 
  187:         result = getattr(ts, method)("h", ambiguous="NaT")
  188:         assert result is NaT
  189: 
  190:         msg = "Cannot infer dst time"
  191:         with pytest.raises(pytz.AmbiguousTimeError, match=msg):
  192:             getattr(ts, method)("h", ambiguous="raise")
  193: 
  194:     @pytest.mark.parametrize(
  195:         "method, ts_str, freq",
  196:         [
  197:             ["ceil", "2018-03-11 01:59:00-0600", "5min"],
  198:             ["round", "2018-03-11 01:59:00-0600", "5min"],
  199:             ["floor", "2018-03-11 03:01:00-0500", "2h"],
  200:         ],
  201:     )
  202:     @pytest.mark.parametrize(
  203:         "unit",
  204:         ["ns", "us", "ms", "s"],
  205:     )
  206:     def test_round_dst_border_nonexistent(self, method, ts_str, freq, unit):
  207:         # GH 23324 round near "spring forward" DST
  208:         ts = Timestamp(ts_str, tz="America/Chicago").as_unit(unit)
  209:         result = getattr(ts, method)(freq, nonexistent="shift_forward")
  210:         expected = Timestamp("2018-03-11 03:00:00", tz="America/Chicago")
  211:         assert result == expected
  212:         assert result._creso == getattr(NpyDatetimeUnit, f"NPY_FR_{unit}").value
  213: 
  214:         result = getattr(ts, method)(freq, nonexistent="NaT")
  215:         assert result is NaT
  216: 
  217:         msg = "2018-03-11 02:00:00"
  218:         with pytest.raises(pytz.NonExistentTimeError, match=msg):
  219:             getattr(ts, method)(freq, nonexistent="raise")
  220: 
  221:     @pytest.mark.parametrize(
  222:         "timestamp",
  223:         [
  224:             "2018-01-01 0:0:0.124999360",
  225:             "2018-01-01 0:0:0.125000367",
  226:             "2018-01-01 0:0:0.125500",
  227:             "2018-01-01 0:0:0.126500",
  228:             "2018-01-01 12:00:00",
  229:             "2019-01-01 12:00:00",
  230:         ],
  231:     )
  232:     @pytest.mark.parametrize(
  233:         "freq",
  234:         [
  235:             "2ns",
  236:             "3ns",
  237:             "4ns",
  238:             "5ns",
  239:             "6ns",
  240:             "7ns",
  241:             "250ns",
  242:             "500ns",
  243:             "750ns",
  244:             "1us",
  245:             "19us",
  246:             "250us",
  247:             "500us",
  248:             "750us",
  249:             "1s",
  250:             "2s",
  251:             "3s",
  252:             "1D",
  253:         ],
  254:     )
  255:     def test_round_int64(self, timestamp, freq):
  256:         # check that all rounding modes are accurate to int64 precision
  257:         # see GH#22591
  258:         dt = Timestamp(timestamp).as_unit("ns")
  259:         unit = to_offset(freq).nanos
  260: 
  261:         # test floor
  262:         result = dt.floor(freq)
  263:         assert result._value % unit == 0, f"floor not a {freq} multiple"
  264:         assert 0 <= dt._value - result._value < unit, "floor error"
  265: 
  266:         # test ceil
  267:         result = dt.ceil(freq)
  268:         assert result._value % unit == 0, f"ceil not a {freq} multiple"
  269:         assert 0 <= result._value - dt._value < unit, "ceil error"
  270: 
  271:         # test round
  272:         result = dt.round(freq)
  273:         assert result._value % unit == 0, f"round not a {freq} multiple"
  274:         assert abs(result._value - dt._value) <= unit // 2, "round error"
  275:         if unit % 2 == 0 and abs(result._value - dt._value) == unit // 2:
  276:             # round half to even
  277:             assert result._value // unit % 2 == 0, "round half to even error"
  278: 
  279:     def test_round_implementation_bounds(self):
  280:         # See also: analogous test for Timedelta
  281:         result = Timestamp.min.ceil("s")
  282:         expected = Timestamp(1677, 9, 21, 0, 12, 44)
  283:         assert result == expected
  284: 
  285:         result = Timestamp.max.floor("s")
  286:         expected = Timestamp.max - Timedelta(854775807)
  287:         assert result == expected
  288: 
  289:         msg = "Cannot round 1677-09-21 00:12:43.145224193 to freq=<Second>"
  290:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  291:             Timestamp.min.floor("s")
  292: 
  293:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  294:             Timestamp.min.round("s")
  295: 
  296:         msg = "Cannot round 2262-04-11 23:47:16.854775807 to freq=<Second>"
  297:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  298:             Timestamp.max.ceil("s")
  299: 
  300:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  301:             Timestamp.max.round("s")
  302: 
  303:     @given(val=st.integers(iNaT + 1, lib.i8max))
  304:     @pytest.mark.parametrize(
  305:         "method", [Timestamp.round, Timestamp.floor, Timestamp.ceil]
  306:     )
  307:     def test_round_sanity(self, val, method):
  308:         cls = Timestamp
  309:         err_cls = OutOfBoundsDatetime
  310: 
  311:         val = np.int64(val)
  312:         ts = cls(val)
  313: 
  314:         def checker(ts, nanos, unit):
  315:             # First check that we do raise in cases where we should
  316:             if nanos == 1:
  317:                 pass
  318:             else:
  319:                 div, mod = divmod(ts._value, nanos)
  320:                 diff = int(nanos - mod)
  321:                 lb = ts._value - mod
  322:                 assert lb <= ts._value  # i.e. no overflows with python ints
  323:                 ub = ts._value + diff
  324:                 assert ub > ts._value  # i.e. no overflows with python ints
  325: 
  326:                 msg = "without overflow"
  327:                 if mod == 0:
  328:                     # We should never be raising in this
  329:                     pass
  330:                 elif method is cls.ceil:
  331:                     if ub > cls.max._value:
  332:                         with pytest.raises(err_cls, match=msg):
  333:                             method(ts, unit)
  334:                         return
  335:                 elif method is cls.floor:
  336:                     if lb < cls.min._value:
  337:                         with pytest.raises(err_cls, match=msg):
  338:                             method(ts, unit)
  339:                         return
  340:                 elif mod >= diff:
  341:                     if ub > cls.max._value:
  342:                         with pytest.raises(err_cls, match=msg):
  343:                             method(ts, unit)
  344:                         return
  345:                 elif lb < cls.min._value:
  346:                     with pytest.raises(err_cls, match=msg):
  347:                         method(ts, unit)
  348:                     return
  349: 
  350:             res = method(ts, unit)
  351: 
  352:             td = res - ts
  353:             diff = abs(td._value)
  354:             assert diff < nanos
  355:             assert res._value % nanos == 0
  356: 
  357:             if method is cls.round:
  358:                 assert diff <= nanos / 2
  359:             elif method is cls.floor:
  360:                 assert res <= ts
  361:             elif method is cls.ceil:
  362:                 assert res >= ts
  363: 
  364:         nanos = 1
  365:         checker(ts, nanos, "ns")
  366: 
  367:         nanos = 1000
  368:         checker(ts, nanos, "us")
  369: 
  370:         nanos = 1_000_000
  371:         checker(ts, nanos, "ms")
  372: 
  373:         nanos = 1_000_000_000
  374:         checker(ts, nanos, "s")
  375: 
  376:         nanos = 60 * 1_000_000_000
  377:         checker(ts, nanos, "min")
  378: 
  379:         nanos = 60 * 60 * 1_000_000_000
  380:         checker(ts, nanos, "h")
  381: 
  382:         nanos = 24 * 60 * 60 * 1_000_000_000
  383:         checker(ts, nanos, "D")
