    1: # Arithmetic tests for DataFrame/Series/Index/Array classes that should
    2: # behave identically.
    3: # Specifically for Period dtype
    4: import operator
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas._libs.tslibs import (
   10:     IncompatibleFrequency,
   11:     Period,
   12:     Timestamp,
   13:     to_offset,
   14: )
   15: from pandas.errors import PerformanceWarning
   16: 
   17: import pandas as pd
   18: from pandas import (
   19:     PeriodIndex,
   20:     Series,
   21:     Timedelta,
   22:     TimedeltaIndex,
   23:     period_range,
   24: )
   25: import pandas._testing as tm
   26: from pandas.core import ops
   27: from pandas.core.arrays import TimedeltaArray
   28: from pandas.tests.arithmetic.common import (
   29:     assert_invalid_addsub_type,
   30:     assert_invalid_comparison,
   31:     get_upcast_box,
   32: )
   33: 
   34: _common_mismatch = [
   35:     pd.offsets.YearBegin(2),
   36:     pd.offsets.MonthBegin(1),
   37:     pd.offsets.Minute(),
   38: ]
   39: 
   40: 
   41: @pytest.fixture(
   42:     params=[
   43:         Timedelta(minutes=30).to_pytimedelta(),
   44:         np.timedelta64(30, "s"),
   45:         Timedelta(seconds=30),
   46:     ]
   47:     + _common_mismatch
   48: )
   49: def not_hourly(request):
   50:     """
   51:     Several timedelta-like and DateOffset instances that are _not_
   52:     compatible with Hourly frequencies.
   53:     """
   54:     return request.param
   55: 
   56: 
   57: @pytest.fixture(
   58:     params=[
   59:         np.timedelta64(365, "D"),
   60:         Timedelta(days=365).to_pytimedelta(),
   61:         Timedelta(days=365),
   62:     ]
   63:     + _common_mismatch
   64: )
   65: def mismatched_freq(request):
   66:     """
   67:     Several timedelta-like and DateOffset instances that are _not_
   68:     compatible with Monthly or Annual frequencies.
   69:     """
   70:     return request.param
   71: 
   72: 
   73: # ------------------------------------------------------------------
   74: # Comparisons
   75: 
   76: 
   77: class TestPeriodArrayLikeComparisons:
   78:     # Comparison tests for PeriodDtype vectors fully parametrized over
   79:     #  DataFrame/Series/PeriodIndex/PeriodArray.  Ideally all comparison
   80:     #  tests will eventually end up here.
   81: 
   82:     @pytest.mark.parametrize("other", ["2017", Period("2017", freq="D")])
   83:     def test_eq_scalar(self, other, box_with_array):
   84:         idx = PeriodIndex(["2017", "2017", "2018"], freq="D")
   85:         idx = tm.box_expected(idx, box_with_array)
   86:         xbox = get_upcast_box(idx, other, True)
   87: 
   88:         expected = np.array([True, True, False])
   89:         expected = tm.box_expected(expected, xbox)
   90: 
   91:         result = idx == other
   92: 
   93:         tm.assert_equal(result, expected)
   94: 
   95:     def test_compare_zerodim(self, box_with_array):
   96:         # GH#26689 make sure we unbox zero-dimensional arrays
   97: 
   98:         pi = period_range("2000", periods=4)
   99:         other = np.array(pi.to_numpy()[0])
  100: 
  101:         pi = tm.box_expected(pi, box_with_array)
  102:         xbox = get_upcast_box(pi, other, True)
  103: 
  104:         result = pi <= other
  105:         expected = np.array([True, False, False, False])
  106:         expected = tm.box_expected(expected, xbox)
  107:         tm.assert_equal(result, expected)
  108: 
  109:     @pytest.mark.parametrize(
  110:         "scalar",
  111:         [
  112:             "foo",
  113:             Timestamp("2021-01-01"),
  114:             Timedelta(days=4),
  115:             9,
  116:             9.5,
  117:             2000,  # specifically don't consider 2000 to match Period("2000", "D")
  118:             False,
  119:             None,
  120:         ],
  121:     )
  122:     def test_compare_invalid_scalar(self, box_with_array, scalar):
  123:         # GH#28980
  124:         # comparison with scalar that cannot be interpreted as a Period
  125:         pi = period_range("2000", periods=4)
  126:         parr = tm.box_expected(pi, box_with_array)
  127:         assert_invalid_comparison(parr, scalar, box_with_array)
  128: 
  129:     @pytest.mark.parametrize(
  130:         "other",
  131:         [
  132:             pd.date_range("2000", periods=4).array,
  133:             pd.timedelta_range("1D", periods=4).array,
  134:             np.arange(4),
  135:             np.arange(4).astype(np.float64),
  136:             list(range(4)),
  137:             # match Period semantics by not treating integers as Periods
  138:             [2000, 2001, 2002, 2003],
  139:             np.arange(2000, 2004),
  140:             np.arange(2000, 2004).astype(object),
  141:             pd.Index([2000, 2001, 2002, 2003]),
  142:         ],
  143:     )
  144:     def test_compare_invalid_listlike(self, box_with_array, other):
  145:         pi = period_range("2000", periods=4)
  146:         parr = tm.box_expected(pi, box_with_array)
  147:         assert_invalid_comparison(parr, other, box_with_array)
  148: 
  149:     @pytest.mark.parametrize("other_box", [list, np.array, lambda x: x.astype(object)])
  150:     def test_compare_object_dtype(self, box_with_array, other_box):
  151:         pi = period_range("2000", periods=5)
  152:         parr = tm.box_expected(pi, box_with_array)
  153: 
  154:         other = other_box(pi)
  155:         xbox = get_upcast_box(parr, other, True)
  156: 
  157:         expected = np.array([True, True, True, True, True])
  158:         expected = tm.box_expected(expected, xbox)
  159: 
  160:         result = parr == other
  161:         tm.assert_equal(result, expected)
  162:         result = parr <= other
  163:         tm.assert_equal(result, expected)
  164:         result = parr >= other
  165:         tm.assert_equal(result, expected)
  166: 
  167:         result = parr != other
  168:         tm.assert_equal(result, ~expected)
  169:         result = parr < other
  170:         tm.assert_equal(result, ~expected)
  171:         result = parr > other
  172:         tm.assert_equal(result, ~expected)
  173: 
  174:         other = other_box(pi[::-1])
  175: 
  176:         expected = np.array([False, False, True, False, False])
  177:         expected = tm.box_expected(expected, xbox)
  178:         result = parr == other
  179:         tm.assert_equal(result, expected)
  180: 
  181:         expected = np.array([True, True, True, False, False])
  182:         expected = tm.box_expected(expected, xbox)
  183:         result = parr <= other
  184:         tm.assert_equal(result, expected)
  185: 
  186:         expected = np.array([False, False, True, True, True])
  187:         expected = tm.box_expected(expected, xbox)
  188:         result = parr >= other
  189:         tm.assert_equal(result, expected)
  190: 
  191:         expected = np.array([True, True, False, True, True])
  192:         expected = tm.box_expected(expected, xbox)
  193:         result = parr != other
  194:         tm.assert_equal(result, expected)
  195: 
  196:         expected = np.array([True, True, False, False, False])
  197:         expected = tm.box_expected(expected, xbox)
  198:         result = parr < other
  199:         tm.assert_equal(result, expected)
  200: 
  201:         expected = np.array([False, False, False, True, True])
  202:         expected = tm.box_expected(expected, xbox)
  203:         result = parr > other
  204:         tm.assert_equal(result, expected)
  205: 
  206: 
  207: class TestPeriodIndexComparisons:
  208:     # TODO: parameterize over boxes
  209: 
  210:     def test_pi_cmp_period(self):
  211:         idx = period_range("2007-01", periods=20, freq="M")
  212:         per = idx[10]
  213: 
  214:         result = idx < per
  215:         exp = idx.values < idx.values[10]
  216:         tm.assert_numpy_array_equal(result, exp)
  217: 
  218:         # Tests Period.__richcmp__ against ndarray[object, ndim=2]
  219:         result = idx.values.reshape(10, 2) < per
  220:         tm.assert_numpy_array_equal(result, exp.reshape(10, 2))
  221: 
  222:         # Tests Period.__richcmp__ against ndarray[object, ndim=0]
  223:         result = idx < np.array(per)
  224:         tm.assert_numpy_array_equal(result, exp)
  225: 
  226:     # TODO: moved from test_datetime64; de-duplicate with version below
  227:     def test_parr_cmp_period_scalar2(self, box_with_array):
  228:         pi = period_range("2000-01-01", periods=10, freq="D")
  229: 
  230:         val = pi[3]
  231:         expected = [x > val for x in pi]
  232: 
  233:         ser = tm.box_expected(pi, box_with_array)
  234:         xbox = get_upcast_box(ser, val, True)
  235: 
  236:         expected = tm.box_expected(expected, xbox)
  237:         result = ser > val
  238:         tm.assert_equal(result, expected)
  239: 
  240:         val = pi[5]
  241:         result = ser > val
  242:         expected = [x > val for x in pi]
  243:         expected = tm.box_expected(expected, xbox)
  244:         tm.assert_equal(result, expected)
  245: 
  246:     @pytest.mark.parametrize("freq", ["M", "2M", "3M"])
  247:     def test_parr_cmp_period_scalar(self, freq, box_with_array):
  248:         # GH#13200
  249:         base = PeriodIndex(["2011-01", "2011-02", "2011-03", "2011-04"], freq=freq)
  250:         base = tm.box_expected(base, box_with_array)
  251:         per = Period("2011-02", freq=freq)
  252:         xbox = get_upcast_box(base, per, True)
  253: 
  254:         exp = np.array([False, True, False, False])
  255:         exp = tm.box_expected(exp, xbox)
  256:         tm.assert_equal(base == per, exp)
  257:         tm.assert_equal(per == base, exp)
  258: 
  259:         exp = np.array([True, False, True, True])
  260:         exp = tm.box_expected(exp, xbox)
  261:         tm.assert_equal(base != per, exp)
  262:         tm.assert_equal(per != base, exp)
  263: 
  264:         exp = np.array([False, False, True, True])
  265:         exp = tm.box_expected(exp, xbox)
  266:         tm.assert_equal(base > per, exp)
  267:         tm.assert_equal(per < base, exp)
  268: 
  269:         exp = np.array([True, False, False, False])
  270:         exp = tm.box_expected(exp, xbox)
  271:         tm.assert_equal(base < per, exp)
  272:         tm.assert_equal(per > base, exp)
  273: 
  274:         exp = np.array([False, True, True, True])
  275:         exp = tm.box_expected(exp, xbox)
  276:         tm.assert_equal(base >= per, exp)
  277:         tm.assert_equal(per <= base, exp)
  278: 
  279:         exp = np.array([True, True, False, False])
  280:         exp = tm.box_expected(exp, xbox)
  281:         tm.assert_equal(base <= per, exp)
  282:         tm.assert_equal(per >= base, exp)
  283: 
  284:     @pytest.mark.parametrize("freq", ["M", "2M", "3M"])
  285:     def test_parr_cmp_pi(self, freq, box_with_array):
  286:         # GH#13200
  287:         base = PeriodIndex(["2011-01", "2011-02", "2011-03", "2011-04"], freq=freq)
  288:         base = tm.box_expected(base, box_with_array)
  289: 
  290:         # TODO: could also box idx?
  291:         idx = PeriodIndex(["2011-02", "2011-01", "2011-03", "2011-05"], freq=freq)
  292: 
  293:         xbox = get_upcast_box(base, idx, True)
  294: 
  295:         exp = np.array([False, False, True, False])
  296:         exp = tm.box_expected(exp, xbox)
  297:         tm.assert_equal(base == idx, exp)
  298: 
  299:         exp = np.array([True, True, False, True])
  300:         exp = tm.box_expected(exp, xbox)
  301:         tm.assert_equal(base != idx, exp)
  302: 
  303:         exp = np.array([False, True, False, False])
  304:         exp = tm.box_expected(exp, xbox)
  305:         tm.assert_equal(base > idx, exp)
  306: 
  307:         exp = np.array([True, False, False, True])
  308:         exp = tm.box_expected(exp, xbox)
  309:         tm.assert_equal(base < idx, exp)
  310: 
  311:         exp = np.array([False, True, True, False])
  312:         exp = tm.box_expected(exp, xbox)
  313:         tm.assert_equal(base >= idx, exp)
  314: 
  315:         exp = np.array([True, False, True, True])
  316:         exp = tm.box_expected(exp, xbox)
  317:         tm.assert_equal(base <= idx, exp)
  318: 
  319:     @pytest.mark.parametrize("freq", ["M", "2M", "3M"])
  320:     def test_parr_cmp_pi_mismatched_freq(self, freq, box_with_array):
  321:         # GH#13200
  322:         # different base freq
  323:         base = PeriodIndex(["2011-01", "2011-02", "2011-03", "2011-04"], freq=freq)
  324:         base = tm.box_expected(base, box_with_array)
  325: 
  326:         msg = rf"Invalid comparison between dtype=period\[{freq}\] and Period"
  327:         with pytest.raises(TypeError, match=msg):
  328:             base <= Period("2011", freq="Y")
  329: 
  330:         with pytest.raises(TypeError, match=msg):
  331:             Period("2011", freq="Y") >= base
  332: 
  333:         # TODO: Could parametrize over boxes for idx?
  334:         idx = PeriodIndex(["2011", "2012", "2013", "2014"], freq="Y")
  335:         rev_msg = r"Invalid comparison between dtype=period\[Y-DEC\] and PeriodArray"
  336:         idx_msg = rev_msg if box_with_array in [tm.to_array, pd.array] else msg
  337:         with pytest.raises(TypeError, match=idx_msg):
  338:             base <= idx
  339: 
  340:         # Different frequency
  341:         msg = rf"Invalid comparison between dtype=period\[{freq}\] and Period"
  342:         with pytest.raises(TypeError, match=msg):
  343:             base <= Period("2011", freq="4M")
  344: 
  345:         with pytest.raises(TypeError, match=msg):
  346:             Period("2011", freq="4M") >= base
  347: 
  348:         idx = PeriodIndex(["2011", "2012", "2013", "2014"], freq="4M")
  349:         rev_msg = r"Invalid comparison between dtype=period\[4M\] and PeriodArray"
  350:         idx_msg = rev_msg if box_with_array in [tm.to_array, pd.array] else msg
  351:         with pytest.raises(TypeError, match=idx_msg):
  352:             base <= idx
  353: 
  354:     @pytest.mark.parametrize("freq", ["M", "2M", "3M"])
  355:     def test_pi_cmp_nat(self, freq):
  356:         idx1 = PeriodIndex(["2011-01", "2011-02", "NaT", "2011-05"], freq=freq)
  357:         per = idx1[1]
  358: 
  359:         result = idx1 > per
  360:         exp = np.array([False, False, False, True])
  361:         tm.assert_numpy_array_equal(result, exp)
  362:         result = per < idx1
  363:         tm.assert_numpy_array_equal(result, exp)
  364: 
  365:         result = idx1 == pd.NaT
  366:         exp = np.array([False, False, False, False])
  367:         tm.assert_numpy_array_equal(result, exp)
  368:         result = pd.NaT == idx1
  369:         tm.assert_numpy_array_equal(result, exp)
  370: 
  371:         result = idx1 != pd.NaT
  372:         exp = np.array([True, True, True, True])
  373:         tm.assert_numpy_array_equal(result, exp)
  374:         result = pd.NaT != idx1
  375:         tm.assert_numpy_array_equal(result, exp)
  376: 
  377:         idx2 = PeriodIndex(["2011-02", "2011-01", "2011-04", "NaT"], freq=freq)
  378:         result = idx1 < idx2
  379:         exp = np.array([True, False, False, False])
  380:         tm.assert_numpy_array_equal(result, exp)
  381: 
  382:         result = idx1 == idx2
  383:         exp = np.array([False, False, False, False])
  384:         tm.assert_numpy_array_equal(result, exp)
  385: 
  386:         result = idx1 != idx2
  387:         exp = np.array([True, True, True, True])
  388:         tm.assert_numpy_array_equal(result, exp)
  389: 
  390:         result = idx1 == idx1
  391:         exp = np.array([True, True, False, True])
  392:         tm.assert_numpy_array_equal(result, exp)
  393: 
  394:         result = idx1 != idx1
  395:         exp = np.array([False, False, True, False])
  396:         tm.assert_numpy_array_equal(result, exp)
  397: 
  398:     @pytest.mark.parametrize("freq", ["M", "2M", "3M"])
  399:     def test_pi_cmp_nat_mismatched_freq_raises(self, freq):
  400:         idx1 = PeriodIndex(["2011-01", "2011-02", "NaT", "2011-05"], freq=freq)
  401: 
  402:         diff = PeriodIndex(["2011-02", "2011-01", "2011-04", "NaT"], freq="4M")
  403:         msg = rf"Invalid comparison between dtype=period\[{freq}\] and PeriodArray"
  404:         with pytest.raises(TypeError, match=msg):
  405:             idx1 > diff
  406: 
  407:         result = idx1 == diff
  408:         expected = np.array([False, False, False, False], dtype=bool)
  409:         tm.assert_numpy_array_equal(result, expected)
  410: 
  411:     # TODO: De-duplicate with test_pi_cmp_nat
  412:     @pytest.mark.parametrize("dtype", [object, None])
  413:     def test_comp_nat(self, dtype):
  414:         left = PeriodIndex([Period("2011-01-01"), pd.NaT, Period("2011-01-03")])
  415:         right = PeriodIndex([pd.NaT, pd.NaT, Period("2011-01-03")])
  416: 
  417:         if dtype is not None:
  418:             left = left.astype(dtype)
  419:             right = right.astype(dtype)
  420: 
  421:         result = left == right
  422:         expected = np.array([False, False, True])
  423:         tm.assert_numpy_array_equal(result, expected)
  424: 
  425:         result = left != right
  426:         expected = np.array([True, True, False])
  427:         tm.assert_numpy_array_equal(result, expected)
  428: 
  429:         expected = np.array([False, False, False])
  430:         tm.assert_numpy_array_equal(left == pd.NaT, expected)
  431:         tm.assert_numpy_array_equal(pd.NaT == right, expected)
  432: 
  433:         expected = np.array([True, True, True])
  434:         tm.assert_numpy_array_equal(left != pd.NaT, expected)
  435:         tm.assert_numpy_array_equal(pd.NaT != left, expected)
  436: 
  437:         expected = np.array([False, False, False])
  438:         tm.assert_numpy_array_equal(left < pd.NaT, expected)
  439:         tm.assert_numpy_array_equal(pd.NaT > left, expected)
  440: 
  441: 
  442: class TestPeriodSeriesComparisons:
  443:     def test_cmp_series_period_series_mixed_freq(self):
  444:         # GH#13200
  445:         base = Series(
  446:             [
  447:                 Period("2011", freq="Y"),
  448:                 Period("2011-02", freq="M"),
  449:                 Period("2013", freq="Y"),
  450:                 Period("2011-04", freq="M"),
  451:             ]
  452:         )
  453: 
  454:         ser = Series(
  455:             [
  456:                 Period("2012", freq="Y"),
  457:                 Period("2011-01", freq="M"),
  458:                 Period("2013", freq="Y"),
  459:                 Period("2011-05", freq="M"),
  460:             ]
  461:         )
  462: 
  463:         exp = Series([False, False, True, False])
  464:         tm.assert_series_equal(base == ser, exp)
  465: 
  466:         exp = Series([True, True, False, True])
  467:         tm.assert_series_equal(base != ser, exp)
  468: 
  469:         exp = Series([False, True, False, False])
  470:         tm.assert_series_equal(base > ser, exp)
  471: 
  472:         exp = Series([True, False, False, True])
  473:         tm.assert_series_equal(base < ser, exp)
  474: 
  475:         exp = Series([False, True, True, False])
  476:         tm.assert_series_equal(base >= ser, exp)
  477: 
  478:         exp = Series([True, False, True, True])
  479:         tm.assert_series_equal(base <= ser, exp)
  480: 
  481: 
  482: class TestPeriodIndexSeriesComparisonConsistency:
  483:     """Test PeriodIndex and Period Series Ops consistency"""
  484: 
  485:     # TODO: needs parametrization+de-duplication
  486: 
  487:     def _check(self, values, func, expected):
  488:         # Test PeriodIndex and Period Series Ops consistency
  489: 
  490:         idx = PeriodIndex(values)
  491:         result = func(idx)
  492: 
  493:         # check that we don't pass an unwanted type to tm.assert_equal
  494:         assert isinstance(expected, (pd.Index, np.ndarray))
  495:         tm.assert_equal(result, expected)
  496: 
  497:         s = Series(values)
  498:         result = func(s)
  499: 
  500:         exp = Series(expected, name=values.name)
  501:         tm.assert_series_equal(result, exp)
  502: 
  503:     def test_pi_comp_period(self):
  504:         idx = PeriodIndex(
  505:             ["2011-01", "2011-02", "2011-03", "2011-04"], freq="M", name="idx"
  506:         )
  507:         per = idx[2]
  508: 
  509:         f = lambda x: x == per
  510:         exp = np.array([False, False, True, False], dtype=np.bool_)
  511:         self._check(idx, f, exp)
  512:         f = lambda x: per == x
  513:         self._check(idx, f, exp)
  514: 
  515:         f = lambda x: x != per
  516:         exp = np.array([True, True, False, True], dtype=np.bool_)
  517:         self._check(idx, f, exp)
  518:         f = lambda x: per != x
  519:         self._check(idx, f, exp)
  520: 
  521:         f = lambda x: per >= x
  522:         exp = np.array([True, True, True, False], dtype=np.bool_)
  523:         self._check(idx, f, exp)
  524: 
  525:         f = lambda x: x > per
  526:         exp = np.array([False, False, False, True], dtype=np.bool_)
  527:         self._check(idx, f, exp)
  528: 
  529:         f = lambda x: per >= x
  530:         exp = np.array([True, True, True, False], dtype=np.bool_)
  531:         self._check(idx, f, exp)
  532: 
  533:     def test_pi_comp_period_nat(self):
  534:         idx = PeriodIndex(
  535:             ["2011-01", "NaT", "2011-03", "2011-04"], freq="M", name="idx"
  536:         )
  537:         per = idx[2]
  538: 
  539:         f = lambda x: x == per
  540:         exp = np.array([False, False, True, False], dtype=np.bool_)
  541:         self._check(idx, f, exp)
  542:         f = lambda x: per == x
  543:         self._check(idx, f, exp)
  544: 
  545:         f = lambda x: x == pd.NaT
  546:         exp = np.array([False, False, False, False], dtype=np.bool_)
  547:         self._check(idx, f, exp)
  548:         f = lambda x: pd.NaT == x
  549:         self._check(idx, f, exp)
  550: 
  551:         f = lambda x: x != per
  552:         exp = np.array([True, True, False, True], dtype=np.bool_)
  553:         self._check(idx, f, exp)
  554:         f = lambda x: per != x
  555:         self._check(idx, f, exp)
  556: 
  557:         f = lambda x: x != pd.NaT
  558:         exp = np.array([True, True, True, True], dtype=np.bool_)
  559:         self._check(idx, f, exp)
  560:         f = lambda x: pd.NaT != x
  561:         self._check(idx, f, exp)
  562: 
  563:         f = lambda x: per >= x
  564:         exp = np.array([True, False, True, False], dtype=np.bool_)
  565:         self._check(idx, f, exp)
  566: 
  567:         f = lambda x: x < per
  568:         exp = np.array([True, False, False, False], dtype=np.bool_)
  569:         self._check(idx, f, exp)
  570: 
  571:         f = lambda x: x > pd.NaT
  572:         exp = np.array([False, False, False, False], dtype=np.bool_)
  573:         self._check(idx, f, exp)
  574: 
  575:         f = lambda x: pd.NaT >= x
  576:         exp = np.array([False, False, False, False], dtype=np.bool_)
  577:         self._check(idx, f, exp)
  578: 
  579: 
  580: # ------------------------------------------------------------------
  581: # Arithmetic
  582: 
  583: 
  584: class TestPeriodFrameArithmetic:
  585:     def test_ops_frame_period(self):
  586:         # GH#13043
  587:         df = pd.DataFrame(
  588:             {
  589:                 "A": [Period("2015-01", freq="M"), Period("2015-02", freq="M")],
  590:                 "B": [Period("2014-01", freq="M"), Period("2014-02", freq="M")],
  591:             }
  592:         )
  593:         assert df["A"].dtype == "Period[M]"
  594:         assert df["B"].dtype == "Period[M]"
  595: 
  596:         p = Period("2015-03", freq="M")
  597:         off = p.freq
  598:         # dtype will be object because of original dtype
  599:         exp = pd.DataFrame(
  600:             {
  601:                 "A": np.array([2 * off, 1 * off], dtype=object),
  602:                 "B": np.array([14 * off, 13 * off], dtype=object),
  603:             }
  604:         )
  605:         tm.assert_frame_equal(p - df, exp)
  606:         tm.assert_frame_equal(df - p, -1 * exp)
  607: 
  608:         df2 = pd.DataFrame(
  609:             {
  610:                 "A": [Period("2015-05", freq="M"), Period("2015-06", freq="M")],
  611:                 "B": [Period("2015-05", freq="M"), Period("2015-06", freq="M")],
  612:             }
  613:         )
  614:         assert df2["A"].dtype == "Period[M]"
  615:         assert df2["B"].dtype == "Period[M]"
  616: 
  617:         exp = pd.DataFrame(
  618:             {
  619:                 "A": np.array([4 * off, 4 * off], dtype=object),
  620:                 "B": np.array([16 * off, 16 * off], dtype=object),
  621:             }
  622:         )
  623:         tm.assert_frame_equal(df2 - df, exp)
  624:         tm.assert_frame_equal(df - df2, -1 * exp)
  625: 
  626: 
  627: class TestPeriodIndexArithmetic:
  628:     # ---------------------------------------------------------------
  629:     # __add__/__sub__ with PeriodIndex
  630:     # PeriodIndex + other is defined for integers and timedelta-like others
  631:     # PeriodIndex - other is defined for integers, timedelta-like others,
  632:     #   and PeriodIndex (with matching freq)
  633: 
  634:     def test_parr_add_iadd_parr_raises(self, box_with_array):
  635:         rng = period_range("1/1/2000", freq="D", periods=5)
  636:         other = period_range("1/6/2000", freq="D", periods=5)
  637:         # TODO: parametrize over boxes for other?
  638: 
  639:         rng = tm.box_expected(rng, box_with_array)
  640:         # An earlier implementation of PeriodIndex addition performed
  641:         # a set operation (union).  This has since been changed to
  642:         # raise a TypeError. See GH#14164 and GH#13077 for historical
  643:         # reference.
  644:         msg = r"unsupported operand type\(s\) for \+: .* and .*"
  645:         with pytest.raises(TypeError, match=msg):
  646:             rng + other
  647: 
  648:         with pytest.raises(TypeError, match=msg):
  649:             rng += other
  650: 
  651:     def test_pi_sub_isub_pi(self):
  652:         # GH#20049
  653:         # For historical reference see GH#14164, GH#13077.
  654:         # PeriodIndex subtraction originally performed set difference,
  655:         # then changed to raise TypeError before being implemented in GH#20049
  656:         rng = period_range("1/1/2000", freq="D", periods=5)
  657:         other = period_range("1/6/2000", freq="D", periods=5)
  658: 
  659:         off = rng.freq
  660:         expected = pd.Index([-5 * off] * 5)
  661:         result = rng - other
  662:         tm.assert_index_equal(result, expected)
  663: 
  664:         rng -= other
  665:         tm.assert_index_equal(rng, expected)
  666: 
  667:     def test_pi_sub_pi_with_nat(self):
  668:         rng = period_range("1/1/2000", freq="D", periods=5)
  669:         other = rng[1:].insert(0, pd.NaT)
  670:         assert other[1:].equals(rng[1:])
  671: 
  672:         result = rng - other
  673:         off = rng.freq
  674:         expected = pd.Index([pd.NaT, 0 * off, 0 * off, 0 * off, 0 * off])
  675:         tm.assert_index_equal(result, expected)
  676: 
  677:     def test_parr_sub_pi_mismatched_freq(self, box_with_array, box_with_array2):
  678:         rng = period_range("1/1/2000", freq="D", periods=5)
  679:         other = period_range("1/6/2000", freq="h", periods=5)
  680: 
  681:         rng = tm.box_expected(rng, box_with_array)
  682:         other = tm.box_expected(other, box_with_array2)
  683:         msg = r"Input has different freq=[hD] from PeriodArray\(freq=[Dh]\)"
  684:         with pytest.raises(IncompatibleFrequency, match=msg):
  685:             rng - other
  686: 
  687:     @pytest.mark.parametrize("n", [1, 2, 3, 4])
  688:     def test_sub_n_gt_1_ticks(self, tick_classes, n):
  689:         # GH 23878
  690:         p1_d = "19910905"
  691:         p2_d = "19920406"
  692:         p1 = PeriodIndex([p1_d], freq=tick_classes(n))
  693:         p2 = PeriodIndex([p2_d], freq=tick_classes(n))
  694: 
  695:         expected = PeriodIndex([p2_d], freq=p2.freq.base) - PeriodIndex(
  696:             [p1_d], freq=p1.freq.base
  697:         )
  698: 
  699:         tm.assert_index_equal((p2 - p1), expected)
  700: 
  701:     @pytest.mark.parametrize("n", [1, 2, 3, 4])
  702:     @pytest.mark.parametrize(
  703:         "offset, kwd_name",
  704:         [
  705:             (pd.offsets.YearEnd, "month"),
  706:             (pd.offsets.QuarterEnd, "startingMonth"),
  707:             (pd.offsets.MonthEnd, None),
  708:             (pd.offsets.Week, "weekday"),
  709:         ],
  710:     )
  711:     def test_sub_n_gt_1_offsets(self, offset, kwd_name, n):
  712:         # GH 23878
  713:         kwds = {kwd_name: 3} if kwd_name is not None else {}
  714:         p1_d = "19910905"
  715:         p2_d = "19920406"
  716:         freq = offset(n, normalize=False, **kwds)
  717:         p1 = PeriodIndex([p1_d], freq=freq)
  718:         p2 = PeriodIndex([p2_d], freq=freq)
  719: 
  720:         result = p2 - p1
  721:         expected = PeriodIndex([p2_d], freq=freq.base) - PeriodIndex(
  722:             [p1_d], freq=freq.base
  723:         )
  724: 
  725:         tm.assert_index_equal(result, expected)
  726: 
  727:     # -------------------------------------------------------------
  728:     # Invalid Operations
  729: 
  730:     @pytest.mark.parametrize(
  731:         "other",
  732:         [
  733:             # datetime scalars
  734:             Timestamp("2016-01-01"),
  735:             Timestamp("2016-01-01").to_pydatetime(),
  736:             Timestamp("2016-01-01").to_datetime64(),
  737:             # datetime-like arrays
  738:             pd.date_range("2016-01-01", periods=3, freq="h"),
  739:             pd.date_range("2016-01-01", periods=3, tz="Europe/Brussels"),
  740:             pd.date_range("2016-01-01", periods=3, freq="s")._data,
  741:             pd.date_range("2016-01-01", periods=3, tz="Asia/Tokyo")._data,
  742:             # Miscellaneous invalid types
  743:             3.14,
  744:             np.array([2.0, 3.0, 4.0]),
  745:         ],
  746:     )
  747:     def test_parr_add_sub_invalid(self, other, box_with_array):
  748:         # GH#23215
  749:         rng = period_range("1/1/2000", freq="D", periods=3)
  750:         rng = tm.box_expected(rng, box_with_array)
  751: 
  752:         msg = "|".join(
  753:             [
  754:                 r"(:?cannot add PeriodArray and .*)",
  755:                 r"(:?cannot subtract .* from (:?a\s)?.*)",
  756:                 r"(:?unsupported operand type\(s\) for \+: .* and .*)",
  757:                 r"unsupported operand type\(s\) for [+-]: .* and .*",
  758:             ]
  759:         )
  760:         assert_invalid_addsub_type(rng, other, msg)
  761:         with pytest.raises(TypeError, match=msg):
  762:             rng + other
  763:         with pytest.raises(TypeError, match=msg):
  764:             other + rng
  765:         with pytest.raises(TypeError, match=msg):
  766:             rng - other
  767:         with pytest.raises(TypeError, match=msg):
  768:             other - rng
  769: 
  770:     # -----------------------------------------------------------------
  771:     # __add__/__sub__ with ndarray[datetime64] and ndarray[timedelta64]
  772: 
  773:     def test_pi_add_sub_td64_array_non_tick_raises(self):
  774:         rng = period_range("1/1/2000", freq="Q", periods=3)
  775:         tdi = TimedeltaIndex(["-1 Day", "-1 Day", "-1 Day"])
  776:         tdarr = tdi.values
  777: 
  778:         msg = r"Cannot add or subtract timedelta64\[ns\] dtype from period\[Q-DEC\]"
  779:         with pytest.raises(TypeError, match=msg):
  780:             rng + tdarr
  781:         with pytest.raises(TypeError, match=msg):
  782:             tdarr + rng
  783: 
  784:         with pytest.raises(TypeError, match=msg):
  785:             rng - tdarr
  786:         msg = r"cannot subtract PeriodArray from TimedeltaArray"
  787:         with pytest.raises(TypeError, match=msg):
  788:             tdarr - rng
  789: 
  790:     def test_pi_add_sub_td64_array_tick(self):
  791:         # PeriodIndex + Timedelta-like is allowed only with
  792:         #   tick-like frequencies
  793:         rng = period_range("1/1/2000", freq="90D", periods=3)
  794:         tdi = TimedeltaIndex(["-1 Day", "-1 Day", "-1 Day"])
  795:         tdarr = tdi.values
  796: 
  797:         expected = period_range("12/31/1999", freq="90D", periods=3)
  798:         result = rng + tdi
  799:         tm.assert_index_equal(result, expected)
  800:         result = rng + tdarr
  801:         tm.assert_index_equal(result, expected)
  802:         result = tdi + rng
  803:         tm.assert_index_equal(result, expected)
  804:         result = tdarr + rng
  805:         tm.assert_index_equal(result, expected)
  806: 
  807:         expected = period_range("1/2/2000", freq="90D", periods=3)
  808: 
  809:         result = rng - tdi
  810:         tm.assert_index_equal(result, expected)
  811:         result = rng - tdarr
  812:         tm.assert_index_equal(result, expected)
  813: 
  814:         msg = r"cannot subtract .* from .*"
  815:         with pytest.raises(TypeError, match=msg):
  816:             tdarr - rng
  817: 
  818:         with pytest.raises(TypeError, match=msg):
  819:             tdi - rng
  820: 
  821:     @pytest.mark.parametrize("pi_freq", ["D", "W", "Q", "h"])
  822:     @pytest.mark.parametrize("tdi_freq", [None, "h"])
  823:     def test_parr_sub_td64array(self, box_with_array, tdi_freq, pi_freq):
  824:         box = box_with_array
  825:         xbox = box if box not in [pd.array, tm.to_array] else pd.Index
  826: 
  827:         tdi = TimedeltaIndex(["1 hours", "2 hours"], freq=tdi_freq)
  828:         dti = Timestamp("2018-03-07 17:16:40") + tdi
  829:         pi = dti.to_period(pi_freq)
  830: 
  831:         # TODO: parametrize over box for pi?
  832:         td64obj = tm.box_expected(tdi, box)
  833: 
  834:         if pi_freq == "h":
  835:             result = pi - td64obj
  836:             expected = (pi.to_timestamp("s") - tdi).to_period(pi_freq)
  837:             expected = tm.box_expected(expected, xbox)
  838:             tm.assert_equal(result, expected)
  839: 
  840:             # Subtract from scalar
  841:             result = pi[0] - td64obj
  842:             expected = (pi[0].to_timestamp("s") - tdi).to_period(pi_freq)
  843:             expected = tm.box_expected(expected, box)
  844:             tm.assert_equal(result, expected)
  845: 
  846:         elif pi_freq == "D":
  847:             # Tick, but non-compatible
  848:             msg = (
  849:                 "Cannot add/subtract timedelta-like from PeriodArray that is "
  850:                 "not an integer multiple of the PeriodArray's freq."
  851:             )
  852:             with pytest.raises(IncompatibleFrequency, match=msg):
  853:                 pi - td64obj
  854: 
  855:             with pytest.raises(IncompatibleFrequency, match=msg):
  856:                 pi[0] - td64obj
  857: 
  858:         else:
  859:             # With non-Tick freq, we could not add timedelta64 array regardless
  860:             #  of what its resolution is
  861:             msg = "Cannot add or subtract timedelta64"
  862:             with pytest.raises(TypeError, match=msg):
  863:                 pi - td64obj
  864:             with pytest.raises(TypeError, match=msg):
  865:                 pi[0] - td64obj
  866: 
  867:     # -----------------------------------------------------------------
  868:     # operations with array/Index of DateOffset objects
  869: 
  870:     @pytest.mark.parametrize("box", [np.array, pd.Index])
  871:     def test_pi_add_offset_array(self, box):
  872:         # GH#18849
  873:         pi = PeriodIndex([Period("2015Q1"), Period("2016Q2")])
  874:         offs = box(
  875:             [
  876:                 pd.offsets.QuarterEnd(n=1, startingMonth=12),
  877:                 pd.offsets.QuarterEnd(n=-2, startingMonth=12),
  878:             ]
  879:         )
  880:         expected = PeriodIndex([Period("2015Q2"), Period("2015Q4")]).astype(object)
  881: 
  882:         with tm.assert_produces_warning(PerformanceWarning):
  883:             res = pi + offs
  884:         tm.assert_index_equal(res, expected)
  885: 
  886:         with tm.assert_produces_warning(PerformanceWarning):
  887:             res2 = offs + pi
  888:         tm.assert_index_equal(res2, expected)
  889: 
  890:         unanchored = np.array([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)])
  891:         # addition/subtraction ops with incompatible offsets should issue
  892:         # a PerformanceWarning and _then_ raise a TypeError.
  893:         msg = r"Input cannot be converted to Period\(freq=Q-DEC\)"
  894:         with pytest.raises(IncompatibleFrequency, match=msg):
  895:             with tm.assert_produces_warning(PerformanceWarning):
  896:                 pi + unanchored
  897:         with pytest.raises(IncompatibleFrequency, match=msg):
  898:             with tm.assert_produces_warning(PerformanceWarning):
  899:                 unanchored + pi
  900: 
  901:     @pytest.mark.parametrize("box", [np.array, pd.Index])
  902:     def test_pi_sub_offset_array(self, box):
  903:         # GH#18824
  904:         pi = PeriodIndex([Period("2015Q1"), Period("2016Q2")])
  905:         other = box(
  906:             [
  907:                 pd.offsets.QuarterEnd(n=1, startingMonth=12),
  908:                 pd.offsets.QuarterEnd(n=-2, startingMonth=12),
  909:             ]
  910:         )
  911: 
  912:         expected = PeriodIndex([pi[n] - other[n] for n in range(len(pi))])
  913:         expected = expected.astype(object)
  914: 
  915:         with tm.assert_produces_warning(PerformanceWarning):
  916:             res = pi - other
  917:         tm.assert_index_equal(res, expected)
  918: 
  919:         anchored = box([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])
  920: 
  921:         # addition/subtraction ops with anchored offsets should issue
  922:         # a PerformanceWarning and _then_ raise a TypeError.
  923:         msg = r"Input has different freq=-1M from Period\(freq=Q-DEC\)"
  924:         with pytest.raises(IncompatibleFrequency, match=msg):
  925:             with tm.assert_produces_warning(PerformanceWarning):
  926:                 pi - anchored
  927:         with pytest.raises(IncompatibleFrequency, match=msg):
  928:             with tm.assert_produces_warning(PerformanceWarning):
  929:                 anchored - pi
  930: 
  931:     def test_pi_add_iadd_int(self, one):
  932:         # Variants of `one` for #19012
  933:         rng = period_range("2000-01-01 09:00", freq="h", periods=10)
  934:         result = rng + one
  935:         expected = period_range("2000-01-01 10:00", freq="h", periods=10)
  936:         tm.assert_index_equal(result, expected)
  937:         rng += one
  938:         tm.assert_index_equal(rng, expected)
  939: 
  940:     def test_pi_sub_isub_int(self, one):
  941:         """
  942:         PeriodIndex.__sub__ and __isub__ with several representations of
  943:         the integer 1, e.g. int, np.int64, np.uint8, ...
  944:         """
  945:         rng = period_range("2000-01-01 09:00", freq="h", periods=10)
  946:         result = rng - one
  947:         expected = period_range("2000-01-01 08:00", freq="h", periods=10)
  948:         tm.assert_index_equal(result, expected)
  949:         rng -= one
  950:         tm.assert_index_equal(rng, expected)
  951: 
  952:     @pytest.mark.parametrize("five", [5, np.array(5, dtype=np.int64)])
  953:     def test_pi_sub_intlike(self, five):
  954:         rng = period_range("2007-01", periods=50)
  955: 
  956:         result = rng - five
  957:         exp = rng + (-five)
  958:         tm.assert_index_equal(result, exp)
  959: 
  960:     def test_pi_add_sub_int_array_freqn_gt1(self):
  961:         # GH#47209 test adding array of ints when freq.n > 1 matches
  962:         #  scalar behavior
  963:         pi = period_range("2016-01-01", periods=10, freq="2D")
  964:         arr = np.arange(10)
  965:         result = pi + arr
  966:         expected = pd.Index([x + y for x, y in zip(pi, arr)])
  967:         tm.assert_index_equal(result, expected)
  968: 
  969:         result = pi - arr
  970:         expected = pd.Index([x - y for x, y in zip(pi, arr)])
  971:         tm.assert_index_equal(result, expected)
  972: 
  973:     def test_pi_sub_isub_offset(self):
  974:         # offset
  975:         # DateOffset
  976:         rng = period_range("2014", "2024", freq="Y")
  977:         result = rng - pd.offsets.YearEnd(5)
  978:         expected = period_range("2009", "2019", freq="Y")
  979:         tm.assert_index_equal(result, expected)
  980:         rng -= pd.offsets.YearEnd(5)
  981:         tm.assert_index_equal(rng, expected)
  982: 
  983:         rng = period_range("2014-01", "2016-12", freq="M")
  984:         result = rng - pd.offsets.MonthEnd(5)
  985:         expected = period_range("2013-08", "2016-07", freq="M")
  986:         tm.assert_index_equal(result, expected)
  987: 
  988:         rng -= pd.offsets.MonthEnd(5)
  989:         tm.assert_index_equal(rng, expected)
  990: 
  991:     @pytest.mark.parametrize("transpose", [True, False])
  992:     def test_pi_add_offset_n_gt1(self, box_with_array, transpose):
  993:         # GH#23215
  994:         # add offset to PeriodIndex with freq.n > 1
  995: 
  996:         per = Period("2016-01", freq="2M")
  997:         pi = PeriodIndex([per])
  998: 
  999:         expected = PeriodIndex(["2016-03"], freq="2M")
 1000: 
 1001:         pi = tm.box_expected(pi, box_with_array, transpose=transpose)
 1002:         expected = tm.box_expected(expected, box_with_array, transpose=transpose)
 1003: 
 1004:         result = pi + per.freq
 1005:         tm.assert_equal(result, expected)
 1006: 
 1007:         result = per.freq + pi
 1008:         tm.assert_equal(result, expected)
 1009: 
 1010:     def test_pi_add_offset_n_gt1_not_divisible(self, box_with_array):
 1011:         # GH#23215
 1012:         # PeriodIndex with freq.n > 1 add offset with offset.n % freq.n != 0
 1013:         pi = PeriodIndex(["2016-01"], freq="2M")
 1014:         expected = PeriodIndex(["2016-04"], freq="2M")
 1015: 
 1016:         pi = tm.box_expected(pi, box_with_array)
 1017:         expected = tm.box_expected(expected, box_with_array)
 1018: 
 1019:         result = pi + to_offset("3ME")
 1020:         tm.assert_equal(result, expected)
 1021: 
 1022:         result = to_offset("3ME") + pi
 1023:         tm.assert_equal(result, expected)
 1024: 
 1025:     # ---------------------------------------------------------------
 1026:     # __add__/__sub__ with integer arrays
 1027: 
 1028:     @pytest.mark.parametrize("int_holder", [np.array, pd.Index])
 1029:     @pytest.mark.parametrize("op", [operator.add, ops.radd])
 1030:     def test_pi_add_intarray(self, int_holder, op):
 1031:         # GH#19959
 1032:         pi = PeriodIndex([Period("2015Q1"), Period("NaT")])
 1033:         other = int_holder([4, -1])
 1034: 
 1035:         result = op(pi, other)
 1036:         expected = PeriodIndex([Period("2016Q1"), Period("NaT")])
 1037:         tm.assert_index_equal(result, expected)
 1038: 
 1039:     @pytest.mark.parametrize("int_holder", [np.array, pd.Index])
 1040:     def test_pi_sub_intarray(self, int_holder):
 1041:         # GH#19959
 1042:         pi = PeriodIndex([Period("2015Q1"), Period("NaT")])
 1043:         other = int_holder([4, -1])
 1044: 
 1045:         result = pi - other
 1046:         expected = PeriodIndex([Period("2014Q1"), Period("NaT")])
 1047:         tm.assert_index_equal(result, expected)
 1048: 
 1049:         msg = r"bad operand type for unary -: 'PeriodArray'"
 1050:         with pytest.raises(TypeError, match=msg):
 1051:             other - pi
 1052: 
 1053:     # ---------------------------------------------------------------
 1054:     # Timedelta-like (timedelta, timedelta64, Timedelta, Tick)
 1055:     # TODO: Some of these are misnomers because of non-Tick DateOffsets
 1056: 
 1057:     def test_parr_add_timedeltalike_minute_gt1(self, three_days, box_with_array):
 1058:         # GH#23031 adding a time-delta-like offset to a PeriodArray that has
 1059:         # minute frequency with n != 1.  A more general case is tested below
 1060:         # in test_pi_add_timedeltalike_tick_gt1, but here we write out the
 1061:         # expected result more explicitly.
 1062:         other = three_days
 1063:         rng = period_range("2014-05-01", periods=3, freq="2D")
 1064:         rng = tm.box_expected(rng, box_with_array)
 1065: 
 1066:         expected = PeriodIndex(["2014-05-04", "2014-05-06", "2014-05-08"], freq="2D")
 1067:         expected = tm.box_expected(expected, box_with_array)
 1068: 
 1069:         result = rng + other
 1070:         tm.assert_equal(result, expected)
 1071: 
 1072:         result = other + rng
 1073:         tm.assert_equal(result, expected)
 1074: 
 1075:         # subtraction
 1076:         expected = PeriodIndex(["2014-04-28", "2014-04-30", "2014-05-02"], freq="2D")
 1077:         expected = tm.box_expected(expected, box_with_array)
 1078:         result = rng - other
 1079:         tm.assert_equal(result, expected)
 1080: 
 1081:         msg = "|".join(
 1082:             [
 1083:                 r"bad operand type for unary -: 'PeriodArray'",
 1084:                 r"cannot subtract PeriodArray from timedelta64\[[hD]\]",
 1085:             ]
 1086:         )
 1087:         with pytest.raises(TypeError, match=msg):
 1088:             other - rng
 1089: 
 1090:     @pytest.mark.parametrize("freqstr", ["5ns", "5us", "5ms", "5s", "5min", "5h", "5d"])
 1091:     def test_parr_add_timedeltalike_tick_gt1(self, three_days, freqstr, box_with_array):
 1092:         # GH#23031 adding a time-delta-like offset to a PeriodArray that has
 1093:         # tick-like frequency with n != 1
 1094:         other = three_days
 1095:         rng = period_range("2014-05-01", periods=6, freq=freqstr)
 1096:         first = rng[0]
 1097:         rng = tm.box_expected(rng, box_with_array)
 1098: 
 1099:         expected = period_range(first + other, periods=6, freq=freqstr)
 1100:         expected = tm.box_expected(expected, box_with_array)
 1101: 
 1102:         result = rng + other
 1103:         tm.assert_equal(result, expected)
 1104: 
 1105:         result = other + rng
 1106:         tm.assert_equal(result, expected)
 1107: 
 1108:         # subtraction
 1109:         expected = period_range(first - other, periods=6, freq=freqstr)
 1110:         expected = tm.box_expected(expected, box_with_array)
 1111:         result = rng - other
 1112:         tm.assert_equal(result, expected)
 1113:         msg = "|".join(
 1114:             [
 1115:                 r"bad operand type for unary -: 'PeriodArray'",
 1116:                 r"cannot subtract PeriodArray from timedelta64\[[hD]\]",
 1117:             ]
 1118:         )
 1119:         with pytest.raises(TypeError, match=msg):
 1120:             other - rng
 1121: 
 1122:     def test_pi_add_iadd_timedeltalike_daily(self, three_days):
 1123:         # Tick
 1124:         other = three_days
 1125:         rng = period_range("2014-05-01", "2014-05-15", freq="D")
 1126:         expected = period_range("2014-05-04", "2014-05-18", freq="D")
 1127: 
 1128:         result = rng + other
 1129:         tm.assert_index_equal(result, expected)
 1130: 
 1131:         rng += other
 1132:         tm.assert_index_equal(rng, expected)
 1133: 
 1134:     def test_pi_sub_isub_timedeltalike_daily(self, three_days):
 1135:         # Tick-like 3 Days
 1136:         other = three_days
 1137:         rng = period_range("2014-05-01", "2014-05-15", freq="D")
 1138:         expected = period_range("2014-04-28", "2014-05-12", freq="D")
 1139: 
 1140:         result = rng - other
 1141:         tm.assert_index_equal(result, expected)
 1142: 
 1143:         rng -= other
 1144:         tm.assert_index_equal(rng, expected)
 1145: 
 1146:     def test_parr_add_sub_timedeltalike_freq_mismatch_daily(
 1147:         self, not_daily, box_with_array
 1148:     ):
 1149:         other = not_daily
 1150:         rng = period_range("2014-05-01", "2014-05-15", freq="D")
 1151:         rng = tm.box_expected(rng, box_with_array)
 1152: 
 1153:         msg = "|".join(
 1154:             [
 1155:                 # non-timedelta-like DateOffset
 1156:                 "Input has different freq(=.+)? from Period.*?\\(freq=D\\)",
 1157:                 # timedelta/td64/Timedelta but not a multiple of 24H
 1158:                 "Cannot add/subtract timedelta-like from PeriodArray that is "
 1159:                 "not an integer multiple of the PeriodArray's freq.",
 1160:             ]
 1161:         )
 1162:         with pytest.raises(IncompatibleFrequency, match=msg):
 1163:             rng + other
 1164:         with pytest.raises(IncompatibleFrequency, match=msg):
 1165:             rng += other
 1166:         with pytest.raises(IncompatibleFrequency, match=msg):
 1167:             rng - other
 1168:         with pytest.raises(IncompatibleFrequency, match=msg):
 1169:             rng -= other
 1170: 
 1171:     def test_pi_add_iadd_timedeltalike_hourly(self, two_hours):
 1172:         other = two_hours
 1173:         rng = period_range("2014-01-01 10:00", "2014-01-05 10:00", freq="h")
 1174:         expected = period_range("2014-01-01 12:00", "2014-01-05 12:00", freq="h")
 1175: 
 1176:         result = rng + other
 1177:         tm.assert_index_equal(result, expected)
 1178: 
 1179:         rng += other
 1180:         tm.assert_index_equal(rng, expected)
 1181: 
 1182:     def test_parr_add_timedeltalike_mismatched_freq_hourly(
 1183:         self, not_hourly, box_with_array
 1184:     ):
 1185:         other = not_hourly
 1186:         rng = period_range("2014-01-01 10:00", "2014-01-05 10:00", freq="h")
 1187:         rng = tm.box_expected(rng, box_with_array)
 1188:         msg = "|".join(
 1189:             [
 1190:                 # non-timedelta-like DateOffset
 1191:                 "Input has different freq(=.+)? from Period.*?\\(freq=h\\)",
 1192:                 # timedelta/td64/Timedelta but not a multiple of 24H
 1193:                 "Cannot add/subtract timedelta-like from PeriodArray that is "
 1194:                 "not an integer multiple of the PeriodArray's freq.",
 1195:             ]
 1196:         )
 1197: 
 1198:         with pytest.raises(IncompatibleFrequency, match=msg):
 1199:             rng + other
 1200: 
 1201:         with pytest.raises(IncompatibleFrequency, match=msg):
 1202:             rng += other
 1203: 
 1204:     def test_pi_sub_isub_timedeltalike_hourly(self, two_hours):
 1205:         other = two_hours
 1206:         rng = period_range("2014-01-01 10:00", "2014-01-05 10:00", freq="h")
 1207:         expected = period_range("2014-01-01 08:00", "2014-01-05 08:00", freq="h")
 1208: 
 1209:         result = rng - other
 1210:         tm.assert_index_equal(result, expected)
 1211: 
 1212:         rng -= other
 1213:         tm.assert_index_equal(rng, expected)
 1214: 
 1215:     def test_add_iadd_timedeltalike_annual(self):
 1216:         # offset
 1217:         # DateOffset
 1218:         rng = period_range("2014", "2024", freq="Y")
 1219:         result = rng + pd.offsets.YearEnd(5)
 1220:         expected = period_range("2019", "2029", freq="Y")
 1221:         tm.assert_index_equal(result, expected)
 1222:         rng += pd.offsets.YearEnd(5)
 1223:         tm.assert_index_equal(rng, expected)
 1224: 
 1225:     def test_pi_add_sub_timedeltalike_freq_mismatch_annual(self, mismatched_freq):
 1226:         other = mismatched_freq
 1227:         rng = period_range("2014", "2024", freq="Y")
 1228:         msg = "Input has different freq(=.+)? from Period.*?\\(freq=Y-DEC\\)"
 1229:         with pytest.raises(IncompatibleFrequency, match=msg):
 1230:             rng + other
 1231:         with pytest.raises(IncompatibleFrequency, match=msg):
 1232:             rng += other
 1233:         with pytest.raises(IncompatibleFrequency, match=msg):
 1234:             rng - other
 1235:         with pytest.raises(IncompatibleFrequency, match=msg):
 1236:             rng -= other
 1237: 
 1238:     def test_pi_add_iadd_timedeltalike_M(self):
 1239:         rng = period_range("2014-01", "2016-12", freq="M")
 1240:         expected = period_range("2014-06", "2017-05", freq="M")
 1241: 
 1242:         result = rng + pd.offsets.MonthEnd(5)
 1243:         tm.assert_index_equal(result, expected)
 1244: 
 1245:         rng += pd.offsets.MonthEnd(5)
 1246:         tm.assert_index_equal(rng, expected)
 1247: 
 1248:     def test_pi_add_sub_timedeltalike_freq_mismatch_monthly(self, mismatched_freq):
 1249:         other = mismatched_freq
 1250:         rng = period_range("2014-01", "2016-12", freq="M")
 1251:         msg = "Input has different freq(=.+)? from Period.*?\\(freq=M\\)"
 1252:         with pytest.raises(IncompatibleFrequency, match=msg):
 1253:             rng + other
 1254:         with pytest.raises(IncompatibleFrequency, match=msg):
 1255:             rng += other
 1256:         with pytest.raises(IncompatibleFrequency, match=msg):
 1257:             rng - other
 1258:         with pytest.raises(IncompatibleFrequency, match=msg):
 1259:             rng -= other
 1260: 
 1261:     @pytest.mark.parametrize("transpose", [True, False])
 1262:     def test_parr_add_sub_td64_nat(self, box_with_array, transpose):
 1263:         # GH#23320 special handling for timedelta64("NaT")
 1264:         pi = period_range("1994-04-01", periods=9, freq="19D")
 1265:         other = np.timedelta64("NaT")
 1266:         expected = PeriodIndex(["NaT"] * 9, freq="19D")
 1267: 
 1268:         obj = tm.box_expected(pi, box_with_array, transpose=transpose)
 1269:         expected = tm.box_expected(expected, box_with_array, transpose=transpose)
 1270: 
 1271:         result = obj + other
 1272:         tm.assert_equal(result, expected)
 1273:         result = other + obj
 1274:         tm.assert_equal(result, expected)
 1275:         result = obj - other
 1276:         tm.assert_equal(result, expected)
 1277:         msg = r"cannot subtract .* from .*"
 1278:         with pytest.raises(TypeError, match=msg):
 1279:             other - obj
 1280: 
 1281:     @pytest.mark.parametrize(
 1282:         "other",
 1283:         [
 1284:             np.array(["NaT"] * 9, dtype="m8[ns]"),
 1285:             TimedeltaArray._from_sequence(["NaT"] * 9, dtype="m8[ns]"),
 1286:         ],
 1287:     )
 1288:     def test_parr_add_sub_tdt64_nat_array(self, box_with_array, other):
 1289:         pi = period_range("1994-04-01", periods=9, freq="19D")
 1290:         expected = PeriodIndex(["NaT"] * 9, freq="19D")
 1291: 
 1292:         obj = tm.box_expected(pi, box_with_array)
 1293:         expected = tm.box_expected(expected, box_with_array)
 1294: 
 1295:         result = obj + other
 1296:         tm.assert_equal(result, expected)
 1297:         result = other + obj
 1298:         tm.assert_equal(result, expected)
 1299:         result = obj - other
 1300:         tm.assert_equal(result, expected)
 1301:         msg = r"cannot subtract .* from .*"
 1302:         with pytest.raises(TypeError, match=msg):
 1303:             other - obj
 1304: 
 1305:         # some but not *all* NaT
 1306:         other = other.copy()
 1307:         other[0] = np.timedelta64(0, "ns")
 1308:         expected = PeriodIndex([pi[0]] + ["NaT"] * 8, freq="19D")
 1309:         expected = tm.box_expected(expected, box_with_array)
 1310: 
 1311:         result = obj + other
 1312:         tm.assert_equal(result, expected)
 1313:         result = other + obj
 1314:         tm.assert_equal(result, expected)
 1315:         result = obj - other
 1316:         tm.assert_equal(result, expected)
 1317:         with pytest.raises(TypeError, match=msg):
 1318:             other - obj
 1319: 
 1320:     # ---------------------------------------------------------------
 1321:     # Unsorted
 1322: 
 1323:     def test_parr_add_sub_index(self):
 1324:         # Check that PeriodArray defers to Index on arithmetic ops
 1325:         pi = period_range("2000-12-31", periods=3)
 1326:         parr = pi.array
 1327: 
 1328:         result = parr - pi
 1329:         expected = pi - pi
 1330:         tm.assert_index_equal(result, expected)
 1331: 
 1332:     def test_parr_add_sub_object_array(self):
 1333:         pi = period_range("2000-12-31", periods=3, freq="D")
 1334:         parr = pi.array
 1335: 
 1336:         other = np.array([Timedelta(days=1), pd.offsets.Day(2), 3])
 1337: 
 1338:         with tm.assert_produces_warning(PerformanceWarning):
 1339:             result = parr + other
 1340: 
 1341:         expected = PeriodIndex(
 1342:             ["2001-01-01", "2001-01-03", "2001-01-05"], freq="D"
 1343:         )._data.astype(object)
 1344:         tm.assert_equal(result, expected)
 1345: 
 1346:         with tm.assert_produces_warning(PerformanceWarning):
 1347:             result = parr - other
 1348: 
 1349:         expected = PeriodIndex(["2000-12-30"] * 3, freq="D")._data.astype(object)
 1350:         tm.assert_equal(result, expected)
 1351: 
 1352:     def test_period_add_timestamp_raises(self, box_with_array):
 1353:         # GH#17983
 1354:         ts = Timestamp("2017")
 1355:         per = Period("2017", freq="M")
 1356: 
 1357:         arr = pd.Index([per], dtype="Period[M]")
 1358:         arr = tm.box_expected(arr, box_with_array)
 1359: 
 1360:         msg = "cannot add PeriodArray and Timestamp"
 1361:         with pytest.raises(TypeError, match=msg):
 1362:             arr + ts
 1363:         with pytest.raises(TypeError, match=msg):
 1364:             ts + arr
 1365:         msg = "cannot add PeriodArray and DatetimeArray"
 1366:         with pytest.raises(TypeError, match=msg):
 1367:             arr + Series([ts])
 1368:         with pytest.raises(TypeError, match=msg):
 1369:             Series([ts]) + arr
 1370:         with pytest.raises(TypeError, match=msg):
 1371:             arr + pd.Index([ts])
 1372:         with pytest.raises(TypeError, match=msg):
 1373:             pd.Index([ts]) + arr
 1374: 
 1375:         if box_with_array is pd.DataFrame:
 1376:             msg = "cannot add PeriodArray and DatetimeArray"
 1377:         else:
 1378:             msg = r"unsupported operand type\(s\) for \+: 'Period' and 'DatetimeArray"
 1379:         with pytest.raises(TypeError, match=msg):
 1380:             arr + pd.DataFrame([ts])
 1381:         if box_with_array is pd.DataFrame:
 1382:             msg = "cannot add PeriodArray and DatetimeArray"
 1383:         else:
 1384:             msg = r"unsupported operand type\(s\) for \+: 'DatetimeArray' and 'Period'"
 1385:         with pytest.raises(TypeError, match=msg):
 1386:             pd.DataFrame([ts]) + arr
 1387: 
 1388: 
 1389: class TestPeriodSeriesArithmetic:
 1390:     def test_parr_add_timedeltalike_scalar(self, three_days, box_with_array):
 1391:         # GH#13043
 1392:         ser = Series(
 1393:             [Period("2015-01-01", freq="D"), Period("2015-01-02", freq="D")],
 1394:             name="xxx",
 1395:         )
 1396:         assert ser.dtype == "Period[D]"
 1397: 
 1398:         expected = Series(
 1399:             [Period("2015-01-04", freq="D"), Period("2015-01-05", freq="D")],
 1400:             name="xxx",
 1401:         )
 1402: 
 1403:         obj = tm.box_expected(ser, box_with_array)
 1404:         if box_with_array is pd.DataFrame:
 1405:             assert (obj.dtypes == "Period[D]").all()
 1406: 
 1407:         expected = tm.box_expected(expected, box_with_array)
 1408: 
 1409:         result = obj + three_days
 1410:         tm.assert_equal(result, expected)
 1411: 
 1412:         result = three_days + obj
 1413:         tm.assert_equal(result, expected)
 1414: 
 1415:     def test_ops_series_period(self):
 1416:         # GH#13043
 1417:         ser = Series(
 1418:             [Period("2015-01-01", freq="D"), Period("2015-01-02", freq="D")],
 1419:             name="xxx",
 1420:         )
 1421:         assert ser.dtype == "Period[D]"
 1422: 
 1423:         per = Period("2015-01-10", freq="D")
 1424:         off = per.freq
 1425:         # dtype will be object because of original dtype
 1426:         expected = Series([9 * off, 8 * off], name="xxx", dtype=object)
 1427:         tm.assert_series_equal(per - ser, expected)
 1428:         tm.assert_series_equal(ser - per, -1 * expected)
 1429: 
 1430:         s2 = Series(
 1431:             [Period("2015-01-05", freq="D"), Period("2015-01-04", freq="D")],
 1432:             name="xxx",
 1433:         )
 1434:         assert s2.dtype == "Period[D]"
 1435: 
 1436:         expected = Series([4 * off, 2 * off], name="xxx", dtype=object)
 1437:         tm.assert_series_equal(s2 - ser, expected)
 1438:         tm.assert_series_equal(ser - s2, -1 * expected)
 1439: 
 1440: 
 1441: class TestPeriodIndexSeriesMethods:
 1442:     """Test PeriodIndex and Period Series Ops consistency"""
 1443: 
 1444:     def _check(self, values, func, expected):
 1445:         idx = PeriodIndex(values)
 1446:         result = func(idx)
 1447:         tm.assert_equal(result, expected)
 1448: 
 1449:         ser = Series(values)
 1450:         result = func(ser)
 1451: 
 1452:         exp = Series(expected, name=values.name)
 1453:         tm.assert_series_equal(result, exp)
 1454: 
 1455:     def test_pi_ops(self):
 1456:         idx = PeriodIndex(
 1457:             ["2011-01", "2011-02", "2011-03", "2011-04"], freq="M", name="idx"
 1458:         )
 1459: 
 1460:         expected = PeriodIndex(
 1461:             ["2011-03", "2011-04", "2011-05", "2011-06"], freq="M", name="idx"
 1462:         )
 1463: 
 1464:         self._check(idx, lambda x: x + 2, expected)
 1465:         self._check(idx, lambda x: 2 + x, expected)
 1466: 
 1467:         self._check(idx + 2, lambda x: x - 2, idx)
 1468: 
 1469:         result = idx - Period("2011-01", freq="M")
 1470:         off = idx.freq
 1471:         exp = pd.Index([0 * off, 1 * off, 2 * off, 3 * off], name="idx")
 1472:         tm.assert_index_equal(result, exp)
 1473: 
 1474:         result = Period("2011-01", freq="M") - idx
 1475:         exp = pd.Index([0 * off, -1 * off, -2 * off, -3 * off], name="idx")
 1476:         tm.assert_index_equal(result, exp)
 1477: 
 1478:     @pytest.mark.parametrize("ng", ["str", 1.5])
 1479:     @pytest.mark.parametrize(
 1480:         "func",
 1481:         [
 1482:             lambda obj, ng: obj + ng,
 1483:             lambda obj, ng: ng + obj,
 1484:             lambda obj, ng: obj - ng,
 1485:             lambda obj, ng: ng - obj,
 1486:             lambda obj, ng: np.add(obj, ng),
 1487:             lambda obj, ng: np.add(ng, obj),
 1488:             lambda obj, ng: np.subtract(obj, ng),
 1489:             lambda obj, ng: np.subtract(ng, obj),
 1490:         ],
 1491:     )
 1492:     def test_parr_ops_errors(self, ng, func, box_with_array):
 1493:         idx = PeriodIndex(
 1494:             ["2011-01", "2011-02", "2011-03", "2011-04"], freq="M", name="idx"
 1495:         )
 1496:         obj = tm.box_expected(idx, box_with_array)
 1497:         msg = "|".join(
 1498:             [
 1499:                 r"unsupported operand type\(s\)",
 1500:                 "can only concatenate",
 1501:                 r"must be str",
 1502:                 "object to str implicitly",
 1503:             ]
 1504:         )
 1505: 
 1506:         with pytest.raises(TypeError, match=msg):
 1507:             func(obj, ng)
 1508: 
 1509:     def test_pi_ops_nat(self):
 1510:         idx = PeriodIndex(
 1511:             ["2011-01", "2011-02", "NaT", "2011-04"], freq="M", name="idx"
 1512:         )
 1513:         expected = PeriodIndex(
 1514:             ["2011-03", "2011-04", "NaT", "2011-06"], freq="M", name="idx"
 1515:         )
 1516: 
 1517:         self._check(idx, lambda x: x + 2, expected)
 1518:         self._check(idx, lambda x: 2 + x, expected)
 1519:         self._check(idx, lambda x: np.add(x, 2), expected)
 1520: 
 1521:         self._check(idx + 2, lambda x: x - 2, idx)
 1522:         self._check(idx + 2, lambda x: np.subtract(x, 2), idx)
 1523: 
 1524:         # freq with mult
 1525:         idx = PeriodIndex(
 1526:             ["2011-01", "2011-02", "NaT", "2011-04"], freq="2M", name="idx"
 1527:         )
 1528:         expected = PeriodIndex(
 1529:             ["2011-07", "2011-08", "NaT", "2011-10"], freq="2M", name="idx"
 1530:         )
 1531: 
 1532:         self._check(idx, lambda x: x + 3, expected)
 1533:         self._check(idx, lambda x: 3 + x, expected)
 1534:         self._check(idx, lambda x: np.add(x, 3), expected)
 1535: 
 1536:         self._check(idx + 3, lambda x: x - 3, idx)
 1537:         self._check(idx + 3, lambda x: np.subtract(x, 3), idx)
 1538: 
 1539:     def test_pi_ops_array_int(self):
 1540:         idx = PeriodIndex(
 1541:             ["2011-01", "2011-02", "NaT", "2011-04"], freq="M", name="idx"
 1542:         )
 1543:         f = lambda x: x + np.array([1, 2, 3, 4])
 1544:         exp = PeriodIndex(
 1545:             ["2011-02", "2011-04", "NaT", "2011-08"], freq="M", name="idx"
 1546:         )
 1547:         self._check(idx, f, exp)
 1548: 
 1549:         f = lambda x: np.add(x, np.array([4, -1, 1, 2]))
 1550:         exp = PeriodIndex(
 1551:             ["2011-05", "2011-01", "NaT", "2011-06"], freq="M", name="idx"
 1552:         )
 1553:         self._check(idx, f, exp)
 1554: 
 1555:         f = lambda x: x - np.array([1, 2, 3, 4])
 1556:         exp = PeriodIndex(
 1557:             ["2010-12", "2010-12", "NaT", "2010-12"], freq="M", name="idx"
 1558:         )
 1559:         self._check(idx, f, exp)
 1560: 
 1561:         f = lambda x: np.subtract(x, np.array([3, 2, 3, -2]))
 1562:         exp = PeriodIndex(
 1563:             ["2010-10", "2010-12", "NaT", "2011-06"], freq="M", name="idx"
 1564:         )
 1565:         self._check(idx, f, exp)
 1566: 
 1567:     def test_pi_ops_offset(self):
 1568:         idx = PeriodIndex(
 1569:             ["2011-01-01", "2011-02-01", "2011-03-01", "2011-04-01"],
 1570:             freq="D",
 1571:             name="idx",
 1572:         )
 1573:         f = lambda x: x + pd.offsets.Day()
 1574:         exp = PeriodIndex(
 1575:             ["2011-01-02", "2011-02-02", "2011-03-02", "2011-04-02"],
 1576:             freq="D",
 1577:             name="idx",
 1578:         )
 1579:         self._check(idx, f, exp)
 1580: 
 1581:         f = lambda x: x + pd.offsets.Day(2)
 1582:         exp = PeriodIndex(
 1583:             ["2011-01-03", "2011-02-03", "2011-03-03", "2011-04-03"],
 1584:             freq="D",
 1585:             name="idx",
 1586:         )
 1587:         self._check(idx, f, exp)
 1588: 
 1589:         f = lambda x: x - pd.offsets.Day(2)
 1590:         exp = PeriodIndex(
 1591:             ["2010-12-30", "2011-01-30", "2011-02-27", "2011-03-30"],
 1592:             freq="D",
 1593:             name="idx",
 1594:         )
 1595:         self._check(idx, f, exp)
 1596: 
 1597:     def test_pi_offset_errors(self):
 1598:         idx = PeriodIndex(
 1599:             ["2011-01-01", "2011-02-01", "2011-03-01", "2011-04-01"],
 1600:             freq="D",
 1601:             name="idx",
 1602:         )
 1603:         ser = Series(idx)
 1604: 
 1605:         msg = (
 1606:             "Cannot add/subtract timedelta-like from PeriodArray that is not "
 1607:             "an integer multiple of the PeriodArray's freq"
 1608:         )
 1609:         for obj in [idx, ser]:
 1610:             with pytest.raises(IncompatibleFrequency, match=msg):
 1611:                 obj + pd.offsets.Hour(2)
 1612: 
 1613:             with pytest.raises(IncompatibleFrequency, match=msg):
 1614:                 pd.offsets.Hour(2) + obj
 1615: 
 1616:             with pytest.raises(IncompatibleFrequency, match=msg):
 1617:                 obj - pd.offsets.Hour(2)
 1618: 
 1619:     def test_pi_sub_period(self):
 1620:         # GH#13071
 1621:         idx = PeriodIndex(
 1622:             ["2011-01", "2011-02", "2011-03", "2011-04"], freq="M", name="idx"
 1623:         )
 1624: 
 1625:         result = idx - Period("2012-01", freq="M")
 1626:         off = idx.freq
 1627:         exp = pd.Index([-12 * off, -11 * off, -10 * off, -9 * off], name="idx")
 1628:         tm.assert_index_equal(result, exp)
 1629: 
 1630:         result = np.subtract(idx, Period("2012-01", freq="M"))
 1631:         tm.assert_index_equal(result, exp)
 1632: 
 1633:         result = Period("2012-01", freq="M") - idx
 1634:         exp = pd.Index([12 * off, 11 * off, 10 * off, 9 * off], name="idx")
 1635:         tm.assert_index_equal(result, exp)
 1636: 
 1637:         result = np.subtract(Period("2012-01", freq="M"), idx)
 1638:         tm.assert_index_equal(result, exp)
 1639: 
 1640:         exp = TimedeltaIndex([np.nan, np.nan, np.nan, np.nan], name="idx")
 1641:         result = idx - Period("NaT", freq="M")
 1642:         tm.assert_index_equal(result, exp)
 1643:         assert result.freq == exp.freq
 1644: 
 1645:         result = Period("NaT", freq="M") - idx
 1646:         tm.assert_index_equal(result, exp)
 1647:         assert result.freq == exp.freq
 1648: 
 1649:     def test_pi_sub_pdnat(self):
 1650:         # GH#13071, GH#19389
 1651:         idx = PeriodIndex(
 1652:             ["2011-01", "2011-02", "NaT", "2011-04"], freq="M", name="idx"
 1653:         )
 1654:         exp = TimedeltaIndex([pd.NaT] * 4, name="idx")
 1655:         tm.assert_index_equal(pd.NaT - idx, exp)
 1656:         tm.assert_index_equal(idx - pd.NaT, exp)
 1657: 
 1658:     def test_pi_sub_period_nat(self):
 1659:         # GH#13071
 1660:         idx = PeriodIndex(
 1661:             ["2011-01", "NaT", "2011-03", "2011-04"], freq="M", name="idx"
 1662:         )
 1663: 
 1664:         result = idx - Period("2012-01", freq="M")
 1665:         off = idx.freq
 1666:         exp = pd.Index([-12 * off, pd.NaT, -10 * off, -9 * off], name="idx")
 1667:         tm.assert_index_equal(result, exp)
 1668: 
 1669:         result = Period("2012-01", freq="M") - idx
 1670:         exp = pd.Index([12 * off, pd.NaT, 10 * off, 9 * off], name="idx")
 1671:         tm.assert_index_equal(result, exp)
 1672: 
 1673:         exp = TimedeltaIndex([np.nan, np.nan, np.nan, np.nan], name="idx")
 1674:         tm.assert_index_equal(idx - Period("NaT", freq="M"), exp)
 1675:         tm.assert_index_equal(Period("NaT", freq="M") - idx, exp)
