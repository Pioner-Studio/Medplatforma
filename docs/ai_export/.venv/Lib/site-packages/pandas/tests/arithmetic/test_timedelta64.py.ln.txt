    1: # Arithmetic tests for DataFrame/Series/Index/Array classes that should
    2: # behave identically.
    3: from datetime import (
    4:     datetime,
    5:     timedelta,
    6: )
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas.errors import (
   12:     OutOfBoundsDatetime,
   13:     PerformanceWarning,
   14: )
   15: 
   16: import pandas as pd
   17: from pandas import (
   18:     DataFrame,
   19:     DatetimeIndex,
   20:     Index,
   21:     NaT,
   22:     Series,
   23:     Timedelta,
   24:     TimedeltaIndex,
   25:     Timestamp,
   26:     offsets,
   27:     timedelta_range,
   28: )
   29: import pandas._testing as tm
   30: from pandas.core.arrays import NumpyExtensionArray
   31: from pandas.tests.arithmetic.common import (
   32:     assert_invalid_addsub_type,
   33:     assert_invalid_comparison,
   34:     get_upcast_box,
   35: )
   36: 
   37: 
   38: def assert_dtype(obj, expected_dtype):
   39:     """
   40:     Helper to check the dtype for a Series, Index, or single-column DataFrame.
   41:     """
   42:     dtype = tm.get_dtype(obj)
   43: 
   44:     assert dtype == expected_dtype
   45: 
   46: 
   47: def get_expected_name(box, names):
   48:     if box is DataFrame:
   49:         # Since we are operating with a DataFrame and a non-DataFrame,
   50:         # the non-DataFrame is cast to Series and its name ignored.
   51:         exname = names[0]
   52:     elif box in [tm.to_array, pd.array]:
   53:         exname = names[1]
   54:     else:
   55:         exname = names[2]
   56:     return exname
   57: 
   58: 
   59: # ------------------------------------------------------------------
   60: # Timedelta64[ns] dtype Comparisons
   61: 
   62: 
   63: class TestTimedelta64ArrayLikeComparisons:
   64:     # Comparison tests for timedelta64[ns] vectors fully parametrized over
   65:     #  DataFrame/Series/TimedeltaIndex/TimedeltaArray.  Ideally all comparison
   66:     #  tests will eventually end up here.
   67: 
   68:     def test_compare_timedelta64_zerodim(self, box_with_array):
   69:         # GH#26689 should unbox when comparing with zerodim array
   70:         box = box_with_array
   71:         xbox = box_with_array if box_with_array not in [Index, pd.array] else np.ndarray
   72: 
   73:         tdi = timedelta_range("2h", periods=4)
   74:         other = np.array(tdi.to_numpy()[0])
   75: 
   76:         tdi = tm.box_expected(tdi, box)
   77:         res = tdi <= other
   78:         expected = np.array([True, False, False, False])
   79:         expected = tm.box_expected(expected, xbox)
   80:         tm.assert_equal(res, expected)
   81: 
   82:     @pytest.mark.parametrize(
   83:         "td_scalar",
   84:         [
   85:             timedelta(days=1),
   86:             Timedelta(days=1),
   87:             Timedelta(days=1).to_timedelta64(),
   88:             offsets.Hour(24),
   89:         ],
   90:     )
   91:     def test_compare_timedeltalike_scalar(self, box_with_array, td_scalar):
   92:         # regression test for GH#5963
   93:         box = box_with_array
   94:         xbox = box if box not in [Index, pd.array] else np.ndarray
   95: 
   96:         ser = Series([timedelta(days=1), timedelta(days=2)])
   97:         ser = tm.box_expected(ser, box)
   98:         actual = ser > td_scalar
   99:         expected = Series([False, True])
  100:         expected = tm.box_expected(expected, xbox)
  101:         tm.assert_equal(actual, expected)
  102: 
  103:     @pytest.mark.parametrize(
  104:         "invalid",
  105:         [
  106:             345600000000000,
  107:             "a",
  108:             Timestamp("2021-01-01"),
  109:             Timestamp("2021-01-01").now("UTC"),
  110:             Timestamp("2021-01-01").now().to_datetime64(),
  111:             Timestamp("2021-01-01").now().to_pydatetime(),
  112:             Timestamp("2021-01-01").date(),
  113:             np.array(4),  # zero-dim mismatched dtype
  114:         ],
  115:     )
  116:     def test_td64_comparisons_invalid(self, box_with_array, invalid):
  117:         # GH#13624 for str
  118:         box = box_with_array
  119: 
  120:         rng = timedelta_range("1 days", periods=10)
  121:         obj = tm.box_expected(rng, box)
  122: 
  123:         assert_invalid_comparison(obj, invalid, box)
  124: 
  125:     @pytest.mark.parametrize(
  126:         "other",
  127:         [
  128:             list(range(10)),
  129:             np.arange(10),
  130:             np.arange(10).astype(np.float32),
  131:             np.arange(10).astype(object),
  132:             pd.date_range("1970-01-01", periods=10, tz="UTC").array,
  133:             np.array(pd.date_range("1970-01-01", periods=10)),
  134:             list(pd.date_range("1970-01-01", periods=10)),
  135:             pd.date_range("1970-01-01", periods=10).astype(object),
  136:             pd.period_range("1971-01-01", freq="D", periods=10).array,
  137:             pd.period_range("1971-01-01", freq="D", periods=10).astype(object),
  138:         ],
  139:     )
  140:     def test_td64arr_cmp_arraylike_invalid(self, other, box_with_array):
  141:         # We don't parametrize this over box_with_array because listlike
  142:         #  other plays poorly with assert_invalid_comparison reversed checks
  143: 
  144:         rng = timedelta_range("1 days", periods=10)._data
  145:         rng = tm.box_expected(rng, box_with_array)
  146:         assert_invalid_comparison(rng, other, box_with_array)
  147: 
  148:     def test_td64arr_cmp_mixed_invalid(self):
  149:         rng = timedelta_range("1 days", periods=5)._data
  150:         other = np.array([0, 1, 2, rng[3], Timestamp("2021-01-01")])
  151: 
  152:         result = rng == other
  153:         expected = np.array([False, False, False, True, False])
  154:         tm.assert_numpy_array_equal(result, expected)
  155: 
  156:         result = rng != other
  157:         tm.assert_numpy_array_equal(result, ~expected)
  158: 
  159:         msg = "Invalid comparison between|Cannot compare type|not supported between"
  160:         with pytest.raises(TypeError, match=msg):
  161:             rng < other
  162:         with pytest.raises(TypeError, match=msg):
  163:             rng > other
  164:         with pytest.raises(TypeError, match=msg):
  165:             rng <= other
  166:         with pytest.raises(TypeError, match=msg):
  167:             rng >= other
  168: 
  169: 
  170: class TestTimedelta64ArrayComparisons:
  171:     # TODO: All of these need to be parametrized over box
  172: 
  173:     @pytest.mark.parametrize("dtype", [None, object])
  174:     def test_comp_nat(self, dtype):
  175:         left = TimedeltaIndex([Timedelta("1 days"), NaT, Timedelta("3 days")])
  176:         right = TimedeltaIndex([NaT, NaT, Timedelta("3 days")])
  177: 
  178:         lhs, rhs = left, right
  179:         if dtype is object:
  180:             lhs, rhs = left.astype(object), right.astype(object)
  181: 
  182:         result = rhs == lhs
  183:         expected = np.array([False, False, True])
  184:         tm.assert_numpy_array_equal(result, expected)
  185: 
  186:         result = rhs != lhs
  187:         expected = np.array([True, True, False])
  188:         tm.assert_numpy_array_equal(result, expected)
  189: 
  190:         expected = np.array([False, False, False])
  191:         tm.assert_numpy_array_equal(lhs == NaT, expected)
  192:         tm.assert_numpy_array_equal(NaT == rhs, expected)
  193: 
  194:         expected = np.array([True, True, True])
  195:         tm.assert_numpy_array_equal(lhs != NaT, expected)
  196:         tm.assert_numpy_array_equal(NaT != lhs, expected)
  197: 
  198:         expected = np.array([False, False, False])
  199:         tm.assert_numpy_array_equal(lhs < NaT, expected)
  200:         tm.assert_numpy_array_equal(NaT > lhs, expected)
  201: 
  202:     @pytest.mark.parametrize(
  203:         "idx2",
  204:         [
  205:             TimedeltaIndex(
  206:                 ["2 day", "2 day", NaT, NaT, "1 day 00:00:02", "5 days 00:00:03"]
  207:             ),
  208:             np.array(
  209:                 [
  210:                     np.timedelta64(2, "D"),
  211:                     np.timedelta64(2, "D"),
  212:                     np.timedelta64("nat"),
  213:                     np.timedelta64("nat"),
  214:                     np.timedelta64(1, "D") + np.timedelta64(2, "s"),
  215:                     np.timedelta64(5, "D") + np.timedelta64(3, "s"),
  216:                 ]
  217:             ),
  218:         ],
  219:     )
  220:     def test_comparisons_nat(self, idx2):
  221:         idx1 = TimedeltaIndex(
  222:             [
  223:                 "1 day",
  224:                 NaT,
  225:                 "1 day 00:00:01",
  226:                 NaT,
  227:                 "1 day 00:00:01",
  228:                 "5 day 00:00:03",
  229:             ]
  230:         )
  231:         # Check pd.NaT is handles as the same as np.nan
  232:         result = idx1 < idx2
  233:         expected = np.array([True, False, False, False, True, False])
  234:         tm.assert_numpy_array_equal(result, expected)
  235: 
  236:         result = idx2 > idx1
  237:         expected = np.array([True, False, False, False, True, False])
  238:         tm.assert_numpy_array_equal(result, expected)
  239: 
  240:         result = idx1 <= idx2
  241:         expected = np.array([True, False, False, False, True, True])
  242:         tm.assert_numpy_array_equal(result, expected)
  243: 
  244:         result = idx2 >= idx1
  245:         expected = np.array([True, False, False, False, True, True])
  246:         tm.assert_numpy_array_equal(result, expected)
  247: 
  248:         result = idx1 == idx2
  249:         expected = np.array([False, False, False, False, False, True])
  250:         tm.assert_numpy_array_equal(result, expected)
  251: 
  252:         result = idx1 != idx2
  253:         expected = np.array([True, True, True, True, True, False])
  254:         tm.assert_numpy_array_equal(result, expected)
  255: 
  256:     # TODO: better name
  257:     def test_comparisons_coverage(self):
  258:         rng = timedelta_range("1 days", periods=10)
  259: 
  260:         result = rng < rng[3]
  261:         expected = np.array([True, True, True] + [False] * 7)
  262:         tm.assert_numpy_array_equal(result, expected)
  263: 
  264:         result = rng == list(rng)
  265:         exp = rng == rng
  266:         tm.assert_numpy_array_equal(result, exp)
  267: 
  268: 
  269: # ------------------------------------------------------------------
  270: # Timedelta64[ns] dtype Arithmetic Operations
  271: 
  272: 
  273: class TestTimedelta64ArithmeticUnsorted:
  274:     # Tests moved from type-specific test files but not
  275:     #  yet sorted/parametrized/de-duplicated
  276: 
  277:     def test_ufunc_coercions(self):
  278:         # normal ops are also tested in tseries/test_timedeltas.py
  279:         idx = TimedeltaIndex(["2h", "4h", "6h", "8h", "10h"], freq="2h", name="x")
  280: 
  281:         for result in [idx * 2, np.multiply(idx, 2)]:
  282:             assert isinstance(result, TimedeltaIndex)
  283:             exp = TimedeltaIndex(["4h", "8h", "12h", "16h", "20h"], freq="4h", name="x")
  284:             tm.assert_index_equal(result, exp)
  285:             assert result.freq == "4h"
  286: 
  287:         for result in [idx / 2, np.divide(idx, 2)]:
  288:             assert isinstance(result, TimedeltaIndex)
  289:             exp = TimedeltaIndex(["1h", "2h", "3h", "4h", "5h"], freq="h", name="x")
  290:             tm.assert_index_equal(result, exp)
  291:             assert result.freq == "h"
  292: 
  293:         for result in [-idx, np.negative(idx)]:
  294:             assert isinstance(result, TimedeltaIndex)
  295:             exp = TimedeltaIndex(
  296:                 ["-2h", "-4h", "-6h", "-8h", "-10h"], freq="-2h", name="x"
  297:             )
  298:             tm.assert_index_equal(result, exp)
  299:             assert result.freq == "-2h"
  300: 
  301:         idx = TimedeltaIndex(["-2h", "-1h", "0h", "1h", "2h"], freq="h", name="x")
  302:         for result in [abs(idx), np.absolute(idx)]:
  303:             assert isinstance(result, TimedeltaIndex)
  304:             exp = TimedeltaIndex(["2h", "1h", "0h", "1h", "2h"], freq=None, name="x")
  305:             tm.assert_index_equal(result, exp)
  306:             assert result.freq is None
  307: 
  308:     def test_subtraction_ops(self):
  309:         # with datetimes/timedelta and tdi/dti
  310:         tdi = TimedeltaIndex(["1 days", NaT, "2 days"], name="foo")
  311:         dti = pd.date_range("20130101", periods=3, name="bar")
  312:         td = Timedelta("1 days")
  313:         dt = Timestamp("20130101")
  314: 
  315:         msg = "cannot subtract a datelike from a TimedeltaArray"
  316:         with pytest.raises(TypeError, match=msg):
  317:             tdi - dt
  318:         with pytest.raises(TypeError, match=msg):
  319:             tdi - dti
  320: 
  321:         msg = r"unsupported operand type\(s\) for -"
  322:         with pytest.raises(TypeError, match=msg):
  323:             td - dt
  324: 
  325:         msg = "(bad|unsupported) operand type for unary"
  326:         with pytest.raises(TypeError, match=msg):
  327:             td - dti
  328: 
  329:         result = dt - dti
  330:         expected = TimedeltaIndex(["0 days", "-1 days", "-2 days"], name="bar")
  331:         tm.assert_index_equal(result, expected)
  332: 
  333:         result = dti - dt
  334:         expected = TimedeltaIndex(["0 days", "1 days", "2 days"], name="bar")
  335:         tm.assert_index_equal(result, expected)
  336: 
  337:         result = tdi - td
  338:         expected = TimedeltaIndex(["0 days", NaT, "1 days"], name="foo")
  339:         tm.assert_index_equal(result, expected)
  340: 
  341:         result = td - tdi
  342:         expected = TimedeltaIndex(["0 days", NaT, "-1 days"], name="foo")
  343:         tm.assert_index_equal(result, expected)
  344: 
  345:         result = dti - td
  346:         expected = DatetimeIndex(
  347:             ["20121231", "20130101", "20130102"], dtype="M8[ns]", freq="D", name="bar"
  348:         )
  349:         tm.assert_index_equal(result, expected)
  350: 
  351:         result = dt - tdi
  352:         expected = DatetimeIndex(
  353:             ["20121231", NaT, "20121230"], dtype="M8[ns]", name="foo"
  354:         )
  355:         tm.assert_index_equal(result, expected)
  356: 
  357:     def test_subtraction_ops_with_tz(self, box_with_array):
  358:         # check that dt/dti subtraction ops with tz are validated
  359:         dti = pd.date_range("20130101", periods=3)
  360:         dti = tm.box_expected(dti, box_with_array)
  361:         ts = Timestamp("20130101")
  362:         dt = ts.to_pydatetime()
  363:         dti_tz = pd.date_range("20130101", periods=3).tz_localize("US/Eastern")
  364:         dti_tz = tm.box_expected(dti_tz, box_with_array)
  365:         ts_tz = Timestamp("20130101").tz_localize("US/Eastern")
  366:         ts_tz2 = Timestamp("20130101").tz_localize("CET")
  367:         dt_tz = ts_tz.to_pydatetime()
  368:         td = Timedelta("1 days")
  369: 
  370:         def _check(result, expected):
  371:             assert result == expected
  372:             assert isinstance(result, Timedelta)
  373: 
  374:         # scalars
  375:         result = ts - ts
  376:         expected = Timedelta("0 days")
  377:         _check(result, expected)
  378: 
  379:         result = dt_tz - ts_tz
  380:         expected = Timedelta("0 days")
  381:         _check(result, expected)
  382: 
  383:         result = ts_tz - dt_tz
  384:         expected = Timedelta("0 days")
  385:         _check(result, expected)
  386: 
  387:         # tz mismatches
  388:         msg = "Cannot subtract tz-naive and tz-aware datetime-like objects."
  389:         with pytest.raises(TypeError, match=msg):
  390:             dt_tz - ts
  391:         msg = "can't subtract offset-naive and offset-aware datetimes"
  392:         with pytest.raises(TypeError, match=msg):
  393:             dt_tz - dt
  394:         msg = "can't subtract offset-naive and offset-aware datetimes"
  395:         with pytest.raises(TypeError, match=msg):
  396:             dt - dt_tz
  397:         msg = "Cannot subtract tz-naive and tz-aware datetime-like objects."
  398:         with pytest.raises(TypeError, match=msg):
  399:             ts - dt_tz
  400:         with pytest.raises(TypeError, match=msg):
  401:             ts_tz2 - ts
  402:         with pytest.raises(TypeError, match=msg):
  403:             ts_tz2 - dt
  404: 
  405:         msg = "Cannot subtract tz-naive and tz-aware"
  406:         # with dti
  407:         with pytest.raises(TypeError, match=msg):
  408:             dti - ts_tz
  409:         with pytest.raises(TypeError, match=msg):
  410:             dti_tz - ts
  411: 
  412:         result = dti_tz - dt_tz
  413:         expected = TimedeltaIndex(["0 days", "1 days", "2 days"])
  414:         expected = tm.box_expected(expected, box_with_array)
  415:         tm.assert_equal(result, expected)
  416: 
  417:         result = dt_tz - dti_tz
  418:         expected = TimedeltaIndex(["0 days", "-1 days", "-2 days"])
  419:         expected = tm.box_expected(expected, box_with_array)
  420:         tm.assert_equal(result, expected)
  421: 
  422:         result = dti_tz - ts_tz
  423:         expected = TimedeltaIndex(["0 days", "1 days", "2 days"])
  424:         expected = tm.box_expected(expected, box_with_array)
  425:         tm.assert_equal(result, expected)
  426: 
  427:         result = ts_tz - dti_tz
  428:         expected = TimedeltaIndex(["0 days", "-1 days", "-2 days"])
  429:         expected = tm.box_expected(expected, box_with_array)
  430:         tm.assert_equal(result, expected)
  431: 
  432:         result = td - td
  433:         expected = Timedelta("0 days")
  434:         _check(result, expected)
  435: 
  436:         result = dti_tz - td
  437:         expected = DatetimeIndex(
  438:             ["20121231", "20130101", "20130102"], tz="US/Eastern"
  439:         ).as_unit("ns")
  440:         expected = tm.box_expected(expected, box_with_array)
  441:         tm.assert_equal(result, expected)
  442: 
  443:     def test_dti_tdi_numeric_ops(self):
  444:         # These are normally union/diff set-like ops
  445:         tdi = TimedeltaIndex(["1 days", NaT, "2 days"], name="foo")
  446:         dti = pd.date_range("20130101", periods=3, name="bar")
  447: 
  448:         result = tdi - tdi
  449:         expected = TimedeltaIndex(["0 days", NaT, "0 days"], name="foo")
  450:         tm.assert_index_equal(result, expected)
  451: 
  452:         result = tdi + tdi
  453:         expected = TimedeltaIndex(["2 days", NaT, "4 days"], name="foo")
  454:         tm.assert_index_equal(result, expected)
  455: 
  456:         result = dti - tdi  # name will be reset
  457:         expected = DatetimeIndex(["20121231", NaT, "20130101"], dtype="M8[ns]")
  458:         tm.assert_index_equal(result, expected)
  459: 
  460:     def test_addition_ops(self):
  461:         # with datetimes/timedelta and tdi/dti
  462:         tdi = TimedeltaIndex(["1 days", NaT, "2 days"], name="foo")
  463:         dti = pd.date_range("20130101", periods=3, name="bar")
  464:         td = Timedelta("1 days")
  465:         dt = Timestamp("20130101")
  466: 
  467:         result = tdi + dt
  468:         expected = DatetimeIndex(
  469:             ["20130102", NaT, "20130103"], dtype="M8[ns]", name="foo"
  470:         )
  471:         tm.assert_index_equal(result, expected)
  472: 
  473:         result = dt + tdi
  474:         expected = DatetimeIndex(
  475:             ["20130102", NaT, "20130103"], dtype="M8[ns]", name="foo"
  476:         )
  477:         tm.assert_index_equal(result, expected)
  478: 
  479:         result = td + tdi
  480:         expected = TimedeltaIndex(["2 days", NaT, "3 days"], name="foo")
  481:         tm.assert_index_equal(result, expected)
  482: 
  483:         result = tdi + td
  484:         expected = TimedeltaIndex(["2 days", NaT, "3 days"], name="foo")
  485:         tm.assert_index_equal(result, expected)
  486: 
  487:         # unequal length
  488:         msg = "cannot add indices of unequal length"
  489:         with pytest.raises(ValueError, match=msg):
  490:             tdi + dti[0:1]
  491:         with pytest.raises(ValueError, match=msg):
  492:             tdi[0:1] + dti
  493: 
  494:         # random indexes
  495:         msg = "Addition/subtraction of integers and integer-arrays"
  496:         with pytest.raises(TypeError, match=msg):
  497:             tdi + Index([1, 2, 3], dtype=np.int64)
  498: 
  499:         # this is a union!
  500:         # FIXME: don't leave commented-out
  501:         # pytest.raises(TypeError, lambda : Index([1,2,3]) + tdi)
  502: 
  503:         result = tdi + dti  # name will be reset
  504:         expected = DatetimeIndex(["20130102", NaT, "20130105"], dtype="M8[ns]")
  505:         tm.assert_index_equal(result, expected)
  506: 
  507:         result = dti + tdi  # name will be reset
  508:         expected = DatetimeIndex(["20130102", NaT, "20130105"], dtype="M8[ns]")
  509:         tm.assert_index_equal(result, expected)
  510: 
  511:         result = dt + td
  512:         expected = Timestamp("20130102")
  513:         assert result == expected
  514: 
  515:         result = td + dt
  516:         expected = Timestamp("20130102")
  517:         assert result == expected
  518: 
  519:     # TODO: Needs more informative name, probably split up into
  520:     # more targeted tests
  521:     @pytest.mark.parametrize("freq", ["D", "B"])
  522:     def test_timedelta(self, freq):
  523:         index = pd.date_range("1/1/2000", periods=50, freq=freq)
  524: 
  525:         shifted = index + timedelta(1)
  526:         back = shifted + timedelta(-1)
  527:         back = back._with_freq("infer")
  528:         tm.assert_index_equal(index, back)
  529: 
  530:         if freq == "D":
  531:             expected = pd.tseries.offsets.Day(1)
  532:             assert index.freq == expected
  533:             assert shifted.freq == expected
  534:             assert back.freq == expected
  535:         else:  # freq == 'B'
  536:             assert index.freq == pd.tseries.offsets.BusinessDay(1)
  537:             assert shifted.freq is None
  538:             assert back.freq == pd.tseries.offsets.BusinessDay(1)
  539: 
  540:         result = index - timedelta(1)
  541:         expected = index + timedelta(-1)
  542:         tm.assert_index_equal(result, expected)
  543: 
  544:     def test_timedelta_tick_arithmetic(self):
  545:         # GH#4134, buggy with timedeltas
  546:         rng = pd.date_range("2013", "2014")
  547:         s = Series(rng)
  548:         result1 = rng - offsets.Hour(1)
  549:         result2 = DatetimeIndex(s - np.timedelta64(100000000))
  550:         result3 = rng - np.timedelta64(100000000)
  551:         result4 = DatetimeIndex(s - offsets.Hour(1))
  552: 
  553:         assert result1.freq == rng.freq
  554:         result1 = result1._with_freq(None)
  555:         tm.assert_index_equal(result1, result4)
  556: 
  557:         assert result3.freq == rng.freq
  558:         result3 = result3._with_freq(None)
  559:         tm.assert_index_equal(result2, result3)
  560: 
  561:     def test_tda_add_sub_index(self):
  562:         # Check that TimedeltaArray defers to Index on arithmetic ops
  563:         tdi = TimedeltaIndex(["1 days", NaT, "2 days"])
  564:         tda = tdi.array
  565: 
  566:         dti = pd.date_range("1999-12-31", periods=3, freq="D")
  567: 
  568:         result = tda + dti
  569:         expected = tdi + dti
  570:         tm.assert_index_equal(result, expected)
  571: 
  572:         result = tda + tdi
  573:         expected = tdi + tdi
  574:         tm.assert_index_equal(result, expected)
  575: 
  576:         result = tda - tdi
  577:         expected = tdi - tdi
  578:         tm.assert_index_equal(result, expected)
  579: 
  580:     def test_tda_add_dt64_object_array(self, box_with_array, tz_naive_fixture):
  581:         # Result should be cast back to DatetimeArray
  582:         box = box_with_array
  583: 
  584:         dti = pd.date_range("2016-01-01", periods=3, tz=tz_naive_fixture)
  585:         dti = dti._with_freq(None)
  586:         tdi = dti - dti
  587: 
  588:         obj = tm.box_expected(tdi, box)
  589:         other = tm.box_expected(dti, box)
  590: 
  591:         with tm.assert_produces_warning(PerformanceWarning):
  592:             result = obj + other.astype(object)
  593:         tm.assert_equal(result, other.astype(object))
  594: 
  595:     # -------------------------------------------------------------
  596:     # Binary operations TimedeltaIndex and timedelta-like
  597: 
  598:     def test_tdi_iadd_timedeltalike(self, two_hours, box_with_array):
  599:         # only test adding/sub offsets as + is now numeric
  600:         rng = timedelta_range("1 days", "10 days")
  601:         expected = timedelta_range("1 days 02:00:00", "10 days 02:00:00", freq="D")
  602: 
  603:         rng = tm.box_expected(rng, box_with_array)
  604:         expected = tm.box_expected(expected, box_with_array)
  605: 
  606:         orig_rng = rng
  607:         rng += two_hours
  608:         tm.assert_equal(rng, expected)
  609:         if box_with_array is not Index:
  610:             # Check that operation is actually inplace
  611:             tm.assert_equal(orig_rng, expected)
  612: 
  613:     def test_tdi_isub_timedeltalike(self, two_hours, box_with_array):
  614:         # only test adding/sub offsets as - is now numeric
  615:         rng = timedelta_range("1 days", "10 days")
  616:         expected = timedelta_range("0 days 22:00:00", "9 days 22:00:00")
  617: 
  618:         rng = tm.box_expected(rng, box_with_array)
  619:         expected = tm.box_expected(expected, box_with_array)
  620: 
  621:         orig_rng = rng
  622:         rng -= two_hours
  623:         tm.assert_equal(rng, expected)
  624:         if box_with_array is not Index:
  625:             # Check that operation is actually inplace
  626:             tm.assert_equal(orig_rng, expected)
  627: 
  628:     # -------------------------------------------------------------
  629: 
  630:     def test_tdi_ops_attributes(self):
  631:         rng = timedelta_range("2 days", periods=5, freq="2D", name="x")
  632: 
  633:         result = rng + 1 * rng.freq
  634:         exp = timedelta_range("4 days", periods=5, freq="2D", name="x")
  635:         tm.assert_index_equal(result, exp)
  636:         assert result.freq == "2D"
  637: 
  638:         result = rng - 2 * rng.freq
  639:         exp = timedelta_range("-2 days", periods=5, freq="2D", name="x")
  640:         tm.assert_index_equal(result, exp)
  641:         assert result.freq == "2D"
  642: 
  643:         result = rng * 2
  644:         exp = timedelta_range("4 days", periods=5, freq="4D", name="x")
  645:         tm.assert_index_equal(result, exp)
  646:         assert result.freq == "4D"
  647: 
  648:         result = rng / 2
  649:         exp = timedelta_range("1 days", periods=5, freq="D", name="x")
  650:         tm.assert_index_equal(result, exp)
  651:         assert result.freq == "D"
  652: 
  653:         result = -rng
  654:         exp = timedelta_range("-2 days", periods=5, freq="-2D", name="x")
  655:         tm.assert_index_equal(result, exp)
  656:         assert result.freq == "-2D"
  657: 
  658:         rng = timedelta_range("-2 days", periods=5, freq="D", name="x")
  659: 
  660:         result = abs(rng)
  661:         exp = TimedeltaIndex(
  662:             ["2 days", "1 days", "0 days", "1 days", "2 days"], name="x"
  663:         )
  664:         tm.assert_index_equal(result, exp)
  665:         assert result.freq is None
  666: 
  667: 
  668: class TestAddSubNaTMasking:
  669:     # TODO: parametrize over boxes
  670: 
  671:     @pytest.mark.parametrize("str_ts", ["1950-01-01", "1980-01-01"])
  672:     def test_tdarr_add_timestamp_nat_masking(self, box_with_array, str_ts):
  673:         # GH#17991 checking for overflow-masking with NaT
  674:         tdinat = pd.to_timedelta(["24658 days 11:15:00", "NaT"])
  675:         tdobj = tm.box_expected(tdinat, box_with_array)
  676: 
  677:         ts = Timestamp(str_ts)
  678:         ts_variants = [
  679:             ts,
  680:             ts.to_pydatetime(),
  681:             ts.to_datetime64().astype("datetime64[ns]"),
  682:             ts.to_datetime64().astype("datetime64[D]"),
  683:         ]
  684: 
  685:         for variant in ts_variants:
  686:             res = tdobj + variant
  687:             if box_with_array is DataFrame:
  688:                 assert res.iloc[1, 1] is NaT
  689:             else:
  690:                 assert res[1] is NaT
  691: 
  692:     def test_tdi_add_overflow(self):
  693:         # See GH#14068
  694:         # preliminary test scalar analogue of vectorized tests below
  695:         # TODO: Make raised error message more informative and test
  696:         with pytest.raises(OutOfBoundsDatetime, match="10155196800000000000"):
  697:             pd.to_timedelta(106580, "D") + Timestamp("2000")
  698:         with pytest.raises(OutOfBoundsDatetime, match="10155196800000000000"):
  699:             Timestamp("2000") + pd.to_timedelta(106580, "D")
  700: 
  701:         _NaT = NaT._value + 1
  702:         msg = "Overflow in int64 addition"
  703:         with pytest.raises(OverflowError, match=msg):
  704:             pd.to_timedelta([106580], "D") + Timestamp("2000")
  705:         with pytest.raises(OverflowError, match=msg):
  706:             Timestamp("2000") + pd.to_timedelta([106580], "D")
  707:         with pytest.raises(OverflowError, match=msg):
  708:             pd.to_timedelta([_NaT]) - Timedelta("1 days")
  709:         with pytest.raises(OverflowError, match=msg):
  710:             pd.to_timedelta(["5 days", _NaT]) - Timedelta("1 days")
  711:         with pytest.raises(OverflowError, match=msg):
  712:             (
  713:                 pd.to_timedelta([_NaT, "5 days", "1 hours"])
  714:                 - pd.to_timedelta(["7 seconds", _NaT, "4 hours"])
  715:             )
  716: 
  717:         # These should not overflow!
  718:         exp = TimedeltaIndex([NaT])
  719:         result = pd.to_timedelta([NaT]) - Timedelta("1 days")
  720:         tm.assert_index_equal(result, exp)
  721: 
  722:         exp = TimedeltaIndex(["4 days", NaT])
  723:         result = pd.to_timedelta(["5 days", NaT]) - Timedelta("1 days")
  724:         tm.assert_index_equal(result, exp)
  725: 
  726:         exp = TimedeltaIndex([NaT, NaT, "5 hours"])
  727:         result = pd.to_timedelta([NaT, "5 days", "1 hours"]) + pd.to_timedelta(
  728:             ["7 seconds", NaT, "4 hours"]
  729:         )
  730:         tm.assert_index_equal(result, exp)
  731: 
  732: 
  733: class TestTimedeltaArraylikeAddSubOps:
  734:     # Tests for timedelta64[ns] __add__, __sub__, __radd__, __rsub__
  735: 
  736:     def test_sub_nat_retain_unit(self):
  737:         ser = pd.to_timedelta(Series(["00:00:01"])).astype("m8[s]")
  738: 
  739:         result = ser - NaT
  740:         expected = Series([NaT], dtype="m8[s]")
  741:         tm.assert_series_equal(result, expected)
  742: 
  743:     # TODO: moved from tests.indexes.timedeltas.test_arithmetic; needs
  744:     #  parametrization+de-duplication
  745:     def test_timedelta_ops_with_missing_values(self):
  746:         # setup
  747:         s1 = pd.to_timedelta(Series(["00:00:01"]))
  748:         s2 = pd.to_timedelta(Series(["00:00:02"]))
  749: 
  750:         sn = pd.to_timedelta(Series([NaT], dtype="m8[ns]"))
  751: 
  752:         df1 = DataFrame(["00:00:01"]).apply(pd.to_timedelta)
  753:         df2 = DataFrame(["00:00:02"]).apply(pd.to_timedelta)
  754: 
  755:         dfn = DataFrame([NaT._value]).apply(pd.to_timedelta)
  756: 
  757:         scalar1 = pd.to_timedelta("00:00:01")
  758:         scalar2 = pd.to_timedelta("00:00:02")
  759:         timedelta_NaT = pd.to_timedelta("NaT")
  760: 
  761:         actual = scalar1 + scalar1
  762:         assert actual == scalar2
  763:         actual = scalar2 - scalar1
  764:         assert actual == scalar1
  765: 
  766:         actual = s1 + s1
  767:         tm.assert_series_equal(actual, s2)
  768:         actual = s2 - s1
  769:         tm.assert_series_equal(actual, s1)
  770: 
  771:         actual = s1 + scalar1
  772:         tm.assert_series_equal(actual, s2)
  773:         actual = scalar1 + s1
  774:         tm.assert_series_equal(actual, s2)
  775:         actual = s2 - scalar1
  776:         tm.assert_series_equal(actual, s1)
  777:         actual = -scalar1 + s2
  778:         tm.assert_series_equal(actual, s1)
  779: 
  780:         actual = s1 + timedelta_NaT
  781:         tm.assert_series_equal(actual, sn)
  782:         actual = timedelta_NaT + s1
  783:         tm.assert_series_equal(actual, sn)
  784:         actual = s1 - timedelta_NaT
  785:         tm.assert_series_equal(actual, sn)
  786:         actual = -timedelta_NaT + s1
  787:         tm.assert_series_equal(actual, sn)
  788: 
  789:         msg = "unsupported operand type"
  790:         with pytest.raises(TypeError, match=msg):
  791:             s1 + np.nan
  792:         with pytest.raises(TypeError, match=msg):
  793:             np.nan + s1
  794:         with pytest.raises(TypeError, match=msg):
  795:             s1 - np.nan
  796:         with pytest.raises(TypeError, match=msg):
  797:             -np.nan + s1
  798: 
  799:         actual = s1 + NaT
  800:         tm.assert_series_equal(actual, sn)
  801:         actual = s2 - NaT
  802:         tm.assert_series_equal(actual, sn)
  803: 
  804:         actual = s1 + df1
  805:         tm.assert_frame_equal(actual, df2)
  806:         actual = s2 - df1
  807:         tm.assert_frame_equal(actual, df1)
  808:         actual = df1 + s1
  809:         tm.assert_frame_equal(actual, df2)
  810:         actual = df2 - s1
  811:         tm.assert_frame_equal(actual, df1)
  812: 
  813:         actual = df1 + df1
  814:         tm.assert_frame_equal(actual, df2)
  815:         actual = df2 - df1
  816:         tm.assert_frame_equal(actual, df1)
  817: 
  818:         actual = df1 + scalar1
  819:         tm.assert_frame_equal(actual, df2)
  820:         actual = df2 - scalar1
  821:         tm.assert_frame_equal(actual, df1)
  822: 
  823:         actual = df1 + timedelta_NaT
  824:         tm.assert_frame_equal(actual, dfn)
  825:         actual = df1 - timedelta_NaT
  826:         tm.assert_frame_equal(actual, dfn)
  827: 
  828:         msg = "cannot subtract a datelike from|unsupported operand type"
  829:         with pytest.raises(TypeError, match=msg):
  830:             df1 + np.nan
  831:         with pytest.raises(TypeError, match=msg):
  832:             df1 - np.nan
  833: 
  834:         actual = df1 + NaT  # NaT is datetime, not timedelta
  835:         tm.assert_frame_equal(actual, dfn)
  836:         actual = df1 - NaT
  837:         tm.assert_frame_equal(actual, dfn)
  838: 
  839:     # TODO: moved from tests.series.test_operators, needs splitting, cleanup,
  840:     # de-duplication, box-parametrization...
  841:     def test_operators_timedelta64(self):
  842:         # series ops
  843:         v1 = pd.date_range("2012-1-1", periods=3, freq="D")
  844:         v2 = pd.date_range("2012-1-2", periods=3, freq="D")
  845:         rs = Series(v2) - Series(v1)
  846:         xp = Series(1e9 * 3600 * 24, rs.index).astype("int64").astype("timedelta64[ns]")
  847:         tm.assert_series_equal(rs, xp)
  848:         assert rs.dtype == "timedelta64[ns]"
  849: 
  850:         df = DataFrame({"A": v1})
  851:         td = Series([timedelta(days=i) for i in range(3)])
  852:         assert td.dtype == "timedelta64[ns]"
  853: 
  854:         # series on the rhs
  855:         result = df["A"] - df["A"].shift()
  856:         assert result.dtype == "timedelta64[ns]"
  857: 
  858:         result = df["A"] + td
  859:         assert result.dtype == "M8[ns]"
  860: 
  861:         # scalar Timestamp on rhs
  862:         maxa = df["A"].max()
  863:         assert isinstance(maxa, Timestamp)
  864: 
  865:         resultb = df["A"] - df["A"].max()
  866:         assert resultb.dtype == "timedelta64[ns]"
  867: 
  868:         # timestamp on lhs
  869:         result = resultb + df["A"]
  870:         values = [Timestamp("20111230"), Timestamp("20120101"), Timestamp("20120103")]
  871:         expected = Series(values, dtype="M8[ns]", name="A")
  872:         tm.assert_series_equal(result, expected)
  873: 
  874:         # datetimes on rhs
  875:         result = df["A"] - datetime(2001, 1, 1)
  876:         expected = Series([timedelta(days=4017 + i) for i in range(3)], name="A")
  877:         tm.assert_series_equal(result, expected)
  878:         assert result.dtype == "m8[ns]"
  879: 
  880:         d = datetime(2001, 1, 1, 3, 4)
  881:         resulta = df["A"] - d
  882:         assert resulta.dtype == "m8[ns]"
  883: 
  884:         # roundtrip
  885:         resultb = resulta + d
  886:         tm.assert_series_equal(df["A"], resultb)
  887: 
  888:         # timedeltas on rhs
  889:         td = timedelta(days=1)
  890:         resulta = df["A"] + td
  891:         resultb = resulta - td
  892:         tm.assert_series_equal(resultb, df["A"])
  893:         assert resultb.dtype == "M8[ns]"
  894: 
  895:         # roundtrip
  896:         td = timedelta(minutes=5, seconds=3)
  897:         resulta = df["A"] + td
  898:         resultb = resulta - td
  899:         tm.assert_series_equal(df["A"], resultb)
  900:         assert resultb.dtype == "M8[ns]"
  901: 
  902:         # inplace
  903:         value = rs[2] + np.timedelta64(timedelta(minutes=5, seconds=1))
  904:         rs[2] += np.timedelta64(timedelta(minutes=5, seconds=1))
  905:         assert rs[2] == value
  906: 
  907:     def test_timedelta64_ops_nat(self):
  908:         # GH 11349
  909:         timedelta_series = Series([NaT, Timedelta("1s")])
  910:         nat_series_dtype_timedelta = Series([NaT, NaT], dtype="timedelta64[ns]")
  911:         single_nat_dtype_timedelta = Series([NaT], dtype="timedelta64[ns]")
  912: 
  913:         # subtraction
  914:         tm.assert_series_equal(timedelta_series - NaT, nat_series_dtype_timedelta)
  915:         tm.assert_series_equal(-NaT + timedelta_series, nat_series_dtype_timedelta)
  916: 
  917:         tm.assert_series_equal(
  918:             timedelta_series - single_nat_dtype_timedelta, nat_series_dtype_timedelta
  919:         )
  920:         tm.assert_series_equal(
  921:             -single_nat_dtype_timedelta + timedelta_series, nat_series_dtype_timedelta
  922:         )
  923: 
  924:         # addition
  925:         tm.assert_series_equal(
  926:             nat_series_dtype_timedelta + NaT, nat_series_dtype_timedelta
  927:         )
  928:         tm.assert_series_equal(
  929:             NaT + nat_series_dtype_timedelta, nat_series_dtype_timedelta
  930:         )
  931: 
  932:         tm.assert_series_equal(
  933:             nat_series_dtype_timedelta + single_nat_dtype_timedelta,
  934:             nat_series_dtype_timedelta,
  935:         )
  936:         tm.assert_series_equal(
  937:             single_nat_dtype_timedelta + nat_series_dtype_timedelta,
  938:             nat_series_dtype_timedelta,
  939:         )
  940: 
  941:         tm.assert_series_equal(timedelta_series + NaT, nat_series_dtype_timedelta)
  942:         tm.assert_series_equal(NaT + timedelta_series, nat_series_dtype_timedelta)
  943: 
  944:         tm.assert_series_equal(
  945:             timedelta_series + single_nat_dtype_timedelta, nat_series_dtype_timedelta
  946:         )
  947:         tm.assert_series_equal(
  948:             single_nat_dtype_timedelta + timedelta_series, nat_series_dtype_timedelta
  949:         )
  950: 
  951:         tm.assert_series_equal(
  952:             nat_series_dtype_timedelta + NaT, nat_series_dtype_timedelta
  953:         )
  954:         tm.assert_series_equal(
  955:             NaT + nat_series_dtype_timedelta, nat_series_dtype_timedelta
  956:         )
  957: 
  958:         tm.assert_series_equal(
  959:             nat_series_dtype_timedelta + single_nat_dtype_timedelta,
  960:             nat_series_dtype_timedelta,
  961:         )
  962:         tm.assert_series_equal(
  963:             single_nat_dtype_timedelta + nat_series_dtype_timedelta,
  964:             nat_series_dtype_timedelta,
  965:         )
  966: 
  967:         # multiplication
  968:         tm.assert_series_equal(
  969:             nat_series_dtype_timedelta * 1.0, nat_series_dtype_timedelta
  970:         )
  971:         tm.assert_series_equal(
  972:             1.0 * nat_series_dtype_timedelta, nat_series_dtype_timedelta
  973:         )
  974: 
  975:         tm.assert_series_equal(timedelta_series * 1, timedelta_series)
  976:         tm.assert_series_equal(1 * timedelta_series, timedelta_series)
  977: 
  978:         tm.assert_series_equal(timedelta_series * 1.5, Series([NaT, Timedelta("1.5s")]))
  979:         tm.assert_series_equal(1.5 * timedelta_series, Series([NaT, Timedelta("1.5s")]))
  980: 
  981:         tm.assert_series_equal(timedelta_series * np.nan, nat_series_dtype_timedelta)
  982:         tm.assert_series_equal(np.nan * timedelta_series, nat_series_dtype_timedelta)
  983: 
  984:         # division
  985:         tm.assert_series_equal(timedelta_series / 2, Series([NaT, Timedelta("0.5s")]))
  986:         tm.assert_series_equal(timedelta_series / 2.0, Series([NaT, Timedelta("0.5s")]))
  987:         tm.assert_series_equal(timedelta_series / np.nan, nat_series_dtype_timedelta)
  988: 
  989:     # -------------------------------------------------------------
  990:     # Binary operations td64 arraylike and datetime-like
  991: 
  992:     @pytest.mark.parametrize("cls", [Timestamp, datetime, np.datetime64])
  993:     def test_td64arr_add_sub_datetimelike_scalar(
  994:         self, cls, box_with_array, tz_naive_fixture
  995:     ):
  996:         # GH#11925, GH#29558, GH#23215
  997:         tz = tz_naive_fixture
  998: 
  999:         dt_scalar = Timestamp("2012-01-01", tz=tz)
 1000:         if cls is datetime:
 1001:             ts = dt_scalar.to_pydatetime()
 1002:         elif cls is np.datetime64:
 1003:             if tz_naive_fixture is not None:
 1004:                 pytest.skip(f"{cls} doesn support {tz_naive_fixture}")
 1005:             ts = dt_scalar.to_datetime64()
 1006:         else:
 1007:             ts = dt_scalar
 1008: 
 1009:         tdi = timedelta_range("1 day", periods=3)
 1010:         expected = pd.date_range("2012-01-02", periods=3, tz=tz)
 1011: 
 1012:         tdarr = tm.box_expected(tdi, box_with_array)
 1013:         expected = tm.box_expected(expected, box_with_array)
 1014: 
 1015:         tm.assert_equal(ts + tdarr, expected)
 1016:         tm.assert_equal(tdarr + ts, expected)
 1017: 
 1018:         expected2 = pd.date_range("2011-12-31", periods=3, freq="-1D", tz=tz)
 1019:         expected2 = tm.box_expected(expected2, box_with_array)
 1020: 
 1021:         tm.assert_equal(ts - tdarr, expected2)
 1022:         tm.assert_equal(ts + (-tdarr), expected2)
 1023: 
 1024:         msg = "cannot subtract a datelike"
 1025:         with pytest.raises(TypeError, match=msg):
 1026:             tdarr - ts
 1027: 
 1028:     def test_td64arr_add_datetime64_nat(self, box_with_array):
 1029:         # GH#23215
 1030:         other = np.datetime64("NaT")
 1031: 
 1032:         tdi = timedelta_range("1 day", periods=3)
 1033:         expected = DatetimeIndex(["NaT", "NaT", "NaT"], dtype="M8[ns]")
 1034: 
 1035:         tdser = tm.box_expected(tdi, box_with_array)
 1036:         expected = tm.box_expected(expected, box_with_array)
 1037: 
 1038:         tm.assert_equal(tdser + other, expected)
 1039:         tm.assert_equal(other + tdser, expected)
 1040: 
 1041:     def test_td64arr_sub_dt64_array(self, box_with_array):
 1042:         dti = pd.date_range("2016-01-01", periods=3)
 1043:         tdi = TimedeltaIndex(["-1 Day"] * 3)
 1044:         dtarr = dti.values
 1045:         expected = DatetimeIndex(dtarr) - tdi
 1046: 
 1047:         tdi = tm.box_expected(tdi, box_with_array)
 1048:         expected = tm.box_expected(expected, box_with_array)
 1049: 
 1050:         msg = "cannot subtract a datelike from"
 1051:         with pytest.raises(TypeError, match=msg):
 1052:             tdi - dtarr
 1053: 
 1054:         # TimedeltaIndex.__rsub__
 1055:         result = dtarr - tdi
 1056:         tm.assert_equal(result, expected)
 1057: 
 1058:     def test_td64arr_add_dt64_array(self, box_with_array):
 1059:         dti = pd.date_range("2016-01-01", periods=3)
 1060:         tdi = TimedeltaIndex(["-1 Day"] * 3)
 1061:         dtarr = dti.values
 1062:         expected = DatetimeIndex(dtarr) + tdi
 1063: 
 1064:         tdi = tm.box_expected(tdi, box_with_array)
 1065:         expected = tm.box_expected(expected, box_with_array)
 1066: 
 1067:         result = tdi + dtarr
 1068:         tm.assert_equal(result, expected)
 1069:         result = dtarr + tdi
 1070:         tm.assert_equal(result, expected)
 1071: 
 1072:     # ------------------------------------------------------------------
 1073:     # Invalid __add__/__sub__ operations
 1074: 
 1075:     @pytest.mark.parametrize("pi_freq", ["D", "W", "Q", "h"])
 1076:     @pytest.mark.parametrize("tdi_freq", [None, "h"])
 1077:     def test_td64arr_sub_periodlike(
 1078:         self, box_with_array, box_with_array2, tdi_freq, pi_freq
 1079:     ):
 1080:         # GH#20049 subtracting PeriodIndex should raise TypeError
 1081:         tdi = TimedeltaIndex(["1 hours", "2 hours"], freq=tdi_freq)
 1082:         dti = Timestamp("2018-03-07 17:16:40") + tdi
 1083:         pi = dti.to_period(pi_freq)
 1084:         per = pi[0]
 1085: 
 1086:         tdi = tm.box_expected(tdi, box_with_array)
 1087:         pi = tm.box_expected(pi, box_with_array2)
 1088:         msg = "cannot subtract|unsupported operand type"
 1089:         with pytest.raises(TypeError, match=msg):
 1090:             tdi - pi
 1091: 
 1092:         # GH#13078 subtraction of Period scalar not supported
 1093:         with pytest.raises(TypeError, match=msg):
 1094:             tdi - per
 1095: 
 1096:     @pytest.mark.parametrize(
 1097:         "other",
 1098:         [
 1099:             # GH#12624 for str case
 1100:             "a",
 1101:             # GH#19123
 1102:             1,
 1103:             1.5,
 1104:             np.array(2),
 1105:         ],
 1106:     )
 1107:     def test_td64arr_addsub_numeric_scalar_invalid(self, box_with_array, other):
 1108:         # vector-like others are tested in test_td64arr_add_sub_numeric_arr_invalid
 1109:         tdser = Series(["59 Days", "59 Days", "NaT"], dtype="m8[ns]")
 1110:         tdarr = tm.box_expected(tdser, box_with_array)
 1111: 
 1112:         assert_invalid_addsub_type(tdarr, other)
 1113: 
 1114:     @pytest.mark.parametrize(
 1115:         "vec",
 1116:         [
 1117:             np.array([1, 2, 3]),
 1118:             Index([1, 2, 3]),
 1119:             Series([1, 2, 3]),
 1120:             DataFrame([[1, 2, 3]]),
 1121:         ],
 1122:         ids=lambda x: type(x).__name__,
 1123:     )
 1124:     def test_td64arr_addsub_numeric_arr_invalid(
 1125:         self, box_with_array, vec, any_real_numpy_dtype
 1126:     ):
 1127:         tdser = Series(["59 Days", "59 Days", "NaT"], dtype="m8[ns]")
 1128:         tdarr = tm.box_expected(tdser, box_with_array)
 1129: 
 1130:         vector = vec.astype(any_real_numpy_dtype)
 1131:         assert_invalid_addsub_type(tdarr, vector)
 1132: 
 1133:     def test_td64arr_add_sub_int(self, box_with_array, one):
 1134:         # Variants of `one` for #19012, deprecated GH#22535
 1135:         rng = timedelta_range("1 days 09:00:00", freq="h", periods=10)
 1136:         tdarr = tm.box_expected(rng, box_with_array)
 1137: 
 1138:         msg = "Addition/subtraction of integers"
 1139:         assert_invalid_addsub_type(tdarr, one, msg)
 1140: 
 1141:         # TODO: get inplace ops into assert_invalid_addsub_type
 1142:         with pytest.raises(TypeError, match=msg):
 1143:             tdarr += one
 1144:         with pytest.raises(TypeError, match=msg):
 1145:             tdarr -= one
 1146: 
 1147:     def test_td64arr_add_sub_integer_array(self, box_with_array):
 1148:         # GH#19959, deprecated GH#22535
 1149:         # GH#22696 for DataFrame case, check that we don't dispatch to numpy
 1150:         #  implementation, which treats int64 as m8[ns]
 1151:         box = box_with_array
 1152:         xbox = np.ndarray if box is pd.array else box
 1153: 
 1154:         rng = timedelta_range("1 days 09:00:00", freq="h", periods=3)
 1155:         tdarr = tm.box_expected(rng, box)
 1156:         other = tm.box_expected([4, 3, 2], xbox)
 1157: 
 1158:         msg = "Addition/subtraction of integers and integer-arrays"
 1159:         assert_invalid_addsub_type(tdarr, other, msg)
 1160: 
 1161:     def test_td64arr_addsub_integer_array_no_freq(self, box_with_array):
 1162:         # GH#19959
 1163:         box = box_with_array
 1164:         xbox = np.ndarray if box is pd.array else box
 1165: 
 1166:         tdi = TimedeltaIndex(["1 Day", "NaT", "3 Hours"])
 1167:         tdarr = tm.box_expected(tdi, box)
 1168:         other = tm.box_expected([14, -1, 16], xbox)
 1169: 
 1170:         msg = "Addition/subtraction of integers"
 1171:         assert_invalid_addsub_type(tdarr, other, msg)
 1172: 
 1173:     # ------------------------------------------------------------------
 1174:     # Operations with timedelta-like others
 1175: 
 1176:     def test_td64arr_add_sub_td64_array(self, box_with_array):
 1177:         box = box_with_array
 1178:         dti = pd.date_range("2016-01-01", periods=3)
 1179:         tdi = dti - dti.shift(1)
 1180:         tdarr = tdi.values
 1181: 
 1182:         expected = 2 * tdi
 1183:         tdi = tm.box_expected(tdi, box)
 1184:         expected = tm.box_expected(expected, box)
 1185: 
 1186:         result = tdi + tdarr
 1187:         tm.assert_equal(result, expected)
 1188:         result = tdarr + tdi
 1189:         tm.assert_equal(result, expected)
 1190: 
 1191:         expected_sub = 0 * tdi
 1192:         result = tdi - tdarr
 1193:         tm.assert_equal(result, expected_sub)
 1194:         result = tdarr - tdi
 1195:         tm.assert_equal(result, expected_sub)
 1196: 
 1197:     def test_td64arr_add_sub_tdi(self, box_with_array, names):
 1198:         # GH#17250 make sure result dtype is correct
 1199:         # GH#19043 make sure names are propagated correctly
 1200:         box = box_with_array
 1201:         exname = get_expected_name(box, names)
 1202: 
 1203:         tdi = TimedeltaIndex(["0 days", "1 day"], name=names[1])
 1204:         tdi = np.array(tdi) if box in [tm.to_array, pd.array] else tdi
 1205:         ser = Series([Timedelta(hours=3), Timedelta(hours=4)], name=names[0])
 1206:         expected = Series([Timedelta(hours=3), Timedelta(days=1, hours=4)], name=exname)
 1207: 
 1208:         ser = tm.box_expected(ser, box)
 1209:         expected = tm.box_expected(expected, box)
 1210: 
 1211:         result = tdi + ser
 1212:         tm.assert_equal(result, expected)
 1213:         assert_dtype(result, "timedelta64[ns]")
 1214: 
 1215:         result = ser + tdi
 1216:         tm.assert_equal(result, expected)
 1217:         assert_dtype(result, "timedelta64[ns]")
 1218: 
 1219:         expected = Series(
 1220:             [Timedelta(hours=-3), Timedelta(days=1, hours=-4)], name=exname
 1221:         )
 1222:         expected = tm.box_expected(expected, box)
 1223: 
 1224:         result = tdi - ser
 1225:         tm.assert_equal(result, expected)
 1226:         assert_dtype(result, "timedelta64[ns]")
 1227: 
 1228:         result = ser - tdi
 1229:         tm.assert_equal(result, -expected)
 1230:         assert_dtype(result, "timedelta64[ns]")
 1231: 
 1232:     @pytest.mark.parametrize("tdnat", [np.timedelta64("NaT"), NaT])
 1233:     def test_td64arr_add_sub_td64_nat(self, box_with_array, tdnat):
 1234:         # GH#18808, GH#23320 special handling for timedelta64("NaT")
 1235:         box = box_with_array
 1236:         tdi = TimedeltaIndex([NaT, Timedelta("1s")])
 1237:         expected = TimedeltaIndex(["NaT"] * 2)
 1238: 
 1239:         obj = tm.box_expected(tdi, box)
 1240:         expected = tm.box_expected(expected, box)
 1241: 
 1242:         result = obj + tdnat
 1243:         tm.assert_equal(result, expected)
 1244:         result = tdnat + obj
 1245:         tm.assert_equal(result, expected)
 1246:         result = obj - tdnat
 1247:         tm.assert_equal(result, expected)
 1248:         result = tdnat - obj
 1249:         tm.assert_equal(result, expected)
 1250: 
 1251:     def test_td64arr_add_timedeltalike(self, two_hours, box_with_array):
 1252:         # only test adding/sub offsets as + is now numeric
 1253:         # GH#10699 for Tick cases
 1254:         box = box_with_array
 1255:         rng = timedelta_range("1 days", "10 days")
 1256:         expected = timedelta_range("1 days 02:00:00", "10 days 02:00:00", freq="D")
 1257:         rng = tm.box_expected(rng, box)
 1258:         expected = tm.box_expected(expected, box)
 1259: 
 1260:         result = rng + two_hours
 1261:         tm.assert_equal(result, expected)
 1262: 
 1263:         result = two_hours + rng
 1264:         tm.assert_equal(result, expected)
 1265: 
 1266:     def test_td64arr_sub_timedeltalike(self, two_hours, box_with_array):
 1267:         # only test adding/sub offsets as - is now numeric
 1268:         # GH#10699 for Tick cases
 1269:         box = box_with_array
 1270:         rng = timedelta_range("1 days", "10 days")
 1271:         expected = timedelta_range("0 days 22:00:00", "9 days 22:00:00")
 1272: 
 1273:         rng = tm.box_expected(rng, box)
 1274:         expected = tm.box_expected(expected, box)
 1275: 
 1276:         result = rng - two_hours
 1277:         tm.assert_equal(result, expected)
 1278: 
 1279:         result = two_hours - rng
 1280:         tm.assert_equal(result, -expected)
 1281: 
 1282:     # ------------------------------------------------------------------
 1283:     # __add__/__sub__ with DateOffsets and arrays of DateOffsets
 1284: 
 1285:     def test_td64arr_add_sub_offset_index(self, names, box_with_array):
 1286:         # GH#18849, GH#19744
 1287:         box = box_with_array
 1288:         exname = get_expected_name(box, names)
 1289: 
 1290:         tdi = TimedeltaIndex(["1 days 00:00:00", "3 days 04:00:00"], name=names[0])
 1291:         other = Index([offsets.Hour(n=1), offsets.Minute(n=-2)], name=names[1])
 1292:         other = np.array(other) if box in [tm.to_array, pd.array] else other
 1293: 
 1294:         expected = TimedeltaIndex(
 1295:             [tdi[n] + other[n] for n in range(len(tdi))], freq="infer", name=exname
 1296:         )
 1297:         expected_sub = TimedeltaIndex(
 1298:             [tdi[n] - other[n] for n in range(len(tdi))], freq="infer", name=exname
 1299:         )
 1300: 
 1301:         tdi = tm.box_expected(tdi, box)
 1302:         expected = tm.box_expected(expected, box).astype(object, copy=False)
 1303:         expected_sub = tm.box_expected(expected_sub, box).astype(object, copy=False)
 1304: 
 1305:         with tm.assert_produces_warning(PerformanceWarning):
 1306:             res = tdi + other
 1307:         tm.assert_equal(res, expected)
 1308: 
 1309:         with tm.assert_produces_warning(PerformanceWarning):
 1310:             res2 = other + tdi
 1311:         tm.assert_equal(res2, expected)
 1312: 
 1313:         with tm.assert_produces_warning(PerformanceWarning):
 1314:             res_sub = tdi - other
 1315:         tm.assert_equal(res_sub, expected_sub)
 1316: 
 1317:     def test_td64arr_add_sub_offset_array(self, box_with_array):
 1318:         # GH#18849, GH#18824
 1319:         box = box_with_array
 1320:         tdi = TimedeltaIndex(["1 days 00:00:00", "3 days 04:00:00"])
 1321:         other = np.array([offsets.Hour(n=1), offsets.Minute(n=-2)])
 1322: 
 1323:         expected = TimedeltaIndex(
 1324:             [tdi[n] + other[n] for n in range(len(tdi))], freq="infer"
 1325:         )
 1326:         expected_sub = TimedeltaIndex(
 1327:             [tdi[n] - other[n] for n in range(len(tdi))], freq="infer"
 1328:         )
 1329: 
 1330:         tdi = tm.box_expected(tdi, box)
 1331:         expected = tm.box_expected(expected, box).astype(object)
 1332: 
 1333:         with tm.assert_produces_warning(PerformanceWarning):
 1334:             res = tdi + other
 1335:         tm.assert_equal(res, expected)
 1336: 
 1337:         with tm.assert_produces_warning(PerformanceWarning):
 1338:             res2 = other + tdi
 1339:         tm.assert_equal(res2, expected)
 1340: 
 1341:         expected_sub = tm.box_expected(expected_sub, box_with_array).astype(object)
 1342:         with tm.assert_produces_warning(PerformanceWarning):
 1343:             res_sub = tdi - other
 1344:         tm.assert_equal(res_sub, expected_sub)
 1345: 
 1346:     def test_td64arr_with_offset_series(self, names, box_with_array):
 1347:         # GH#18849
 1348:         box = box_with_array
 1349:         box2 = Series if box in [Index, tm.to_array, pd.array] else box
 1350:         exname = get_expected_name(box, names)
 1351: 
 1352:         tdi = TimedeltaIndex(["1 days 00:00:00", "3 days 04:00:00"], name=names[0])
 1353:         other = Series([offsets.Hour(n=1), offsets.Minute(n=-2)], name=names[1])
 1354: 
 1355:         expected_add = Series(
 1356:             [tdi[n] + other[n] for n in range(len(tdi))], name=exname, dtype=object
 1357:         )
 1358:         obj = tm.box_expected(tdi, box)
 1359:         expected_add = tm.box_expected(expected_add, box2).astype(object)
 1360: 
 1361:         with tm.assert_produces_warning(PerformanceWarning):
 1362:             res = obj + other
 1363:         tm.assert_equal(res, expected_add)
 1364: 
 1365:         with tm.assert_produces_warning(PerformanceWarning):
 1366:             res2 = other + obj
 1367:         tm.assert_equal(res2, expected_add)
 1368: 
 1369:         expected_sub = Series(
 1370:             [tdi[n] - other[n] for n in range(len(tdi))], name=exname, dtype=object
 1371:         )
 1372:         expected_sub = tm.box_expected(expected_sub, box2).astype(object)
 1373: 
 1374:         with tm.assert_produces_warning(PerformanceWarning):
 1375:             res3 = obj - other
 1376:         tm.assert_equal(res3, expected_sub)
 1377: 
 1378:     @pytest.mark.parametrize("obox", [np.array, Index, Series])
 1379:     def test_td64arr_addsub_anchored_offset_arraylike(self, obox, box_with_array):
 1380:         # GH#18824
 1381:         tdi = TimedeltaIndex(["1 days 00:00:00", "3 days 04:00:00"])
 1382:         tdi = tm.box_expected(tdi, box_with_array)
 1383: 
 1384:         anchored = obox([offsets.MonthEnd(), offsets.Day(n=2)])
 1385: 
 1386:         # addition/subtraction ops with anchored offsets should issue
 1387:         # a PerformanceWarning and _then_ raise a TypeError.
 1388:         msg = "has incorrect type|cannot add the type MonthEnd"
 1389:         with pytest.raises(TypeError, match=msg):
 1390:             with tm.assert_produces_warning(PerformanceWarning):
 1391:                 tdi + anchored
 1392:         with pytest.raises(TypeError, match=msg):
 1393:             with tm.assert_produces_warning(PerformanceWarning):
 1394:                 anchored + tdi
 1395:         with pytest.raises(TypeError, match=msg):
 1396:             with tm.assert_produces_warning(PerformanceWarning):
 1397:                 tdi - anchored
 1398:         with pytest.raises(TypeError, match=msg):
 1399:             with tm.assert_produces_warning(PerformanceWarning):
 1400:                 anchored - tdi
 1401: 
 1402:     # ------------------------------------------------------------------
 1403:     # Unsorted
 1404: 
 1405:     def test_td64arr_add_sub_object_array(self, box_with_array):
 1406:         box = box_with_array
 1407:         xbox = np.ndarray if box is pd.array else box
 1408: 
 1409:         tdi = timedelta_range("1 day", periods=3, freq="D")
 1410:         tdarr = tm.box_expected(tdi, box)
 1411: 
 1412:         other = np.array([Timedelta(days=1), offsets.Day(2), Timestamp("2000-01-04")])
 1413: 
 1414:         with tm.assert_produces_warning(PerformanceWarning):
 1415:             result = tdarr + other
 1416: 
 1417:         expected = Index(
 1418:             [Timedelta(days=2), Timedelta(days=4), Timestamp("2000-01-07")]
 1419:         )
 1420:         expected = tm.box_expected(expected, xbox).astype(object)
 1421:         tm.assert_equal(result, expected)
 1422: 
 1423:         msg = "unsupported operand type|cannot subtract a datelike"
 1424:         with pytest.raises(TypeError, match=msg):
 1425:             with tm.assert_produces_warning(PerformanceWarning):
 1426:                 tdarr - other
 1427: 
 1428:         with tm.assert_produces_warning(PerformanceWarning):
 1429:             result = other - tdarr
 1430: 
 1431:         expected = Index([Timedelta(0), Timedelta(0), Timestamp("2000-01-01")])
 1432:         expected = tm.box_expected(expected, xbox).astype(object)
 1433:         tm.assert_equal(result, expected)
 1434: 
 1435: 
 1436: class TestTimedeltaArraylikeMulDivOps:
 1437:     # Tests for timedelta64[ns]
 1438:     # __mul__, __rmul__, __div__, __rdiv__, __floordiv__, __rfloordiv__
 1439: 
 1440:     # ------------------------------------------------------------------
 1441:     # Multiplication
 1442:     # organized with scalar others first, then array-like
 1443: 
 1444:     def test_td64arr_mul_int(self, box_with_array):
 1445:         idx = TimedeltaIndex(np.arange(5, dtype="int64"))
 1446:         idx = tm.box_expected(idx, box_with_array)
 1447: 
 1448:         result = idx * 1
 1449:         tm.assert_equal(result, idx)
 1450: 
 1451:         result = 1 * idx
 1452:         tm.assert_equal(result, idx)
 1453: 
 1454:     def test_td64arr_mul_tdlike_scalar_raises(self, two_hours, box_with_array):
 1455:         rng = timedelta_range("1 days", "10 days", name="foo")
 1456:         rng = tm.box_expected(rng, box_with_array)
 1457:         msg = "argument must be an integer|cannot use operands with types dtype"
 1458:         with pytest.raises(TypeError, match=msg):
 1459:             rng * two_hours
 1460: 
 1461:     def test_tdi_mul_int_array_zerodim(self, box_with_array):
 1462:         rng5 = np.arange(5, dtype="int64")
 1463:         idx = TimedeltaIndex(rng5)
 1464:         expected = TimedeltaIndex(rng5 * 5)
 1465: 
 1466:         idx = tm.box_expected(idx, box_with_array)
 1467:         expected = tm.box_expected(expected, box_with_array)
 1468: 
 1469:         result = idx * np.array(5, dtype="int64")
 1470:         tm.assert_equal(result, expected)
 1471: 
 1472:     def test_tdi_mul_int_array(self, box_with_array):
 1473:         rng5 = np.arange(5, dtype="int64")
 1474:         idx = TimedeltaIndex(rng5)
 1475:         expected = TimedeltaIndex(rng5**2)
 1476: 
 1477:         idx = tm.box_expected(idx, box_with_array)
 1478:         expected = tm.box_expected(expected, box_with_array)
 1479: 
 1480:         result = idx * rng5
 1481:         tm.assert_equal(result, expected)
 1482: 
 1483:     def test_tdi_mul_int_series(self, box_with_array):
 1484:         box = box_with_array
 1485:         xbox = Series if box in [Index, tm.to_array, pd.array] else box
 1486: 
 1487:         idx = TimedeltaIndex(np.arange(5, dtype="int64"))
 1488:         expected = TimedeltaIndex(np.arange(5, dtype="int64") ** 2)
 1489: 
 1490:         idx = tm.box_expected(idx, box)
 1491:         expected = tm.box_expected(expected, xbox)
 1492: 
 1493:         result = idx * Series(np.arange(5, dtype="int64"))
 1494:         tm.assert_equal(result, expected)
 1495: 
 1496:     def test_tdi_mul_float_series(self, box_with_array):
 1497:         box = box_with_array
 1498:         xbox = Series if box in [Index, tm.to_array, pd.array] else box
 1499: 
 1500:         idx = TimedeltaIndex(np.arange(5, dtype="int64"))
 1501:         idx = tm.box_expected(idx, box)
 1502: 
 1503:         rng5f = np.arange(5, dtype="float64")
 1504:         expected = TimedeltaIndex(rng5f * (rng5f + 1.0))
 1505:         expected = tm.box_expected(expected, xbox)
 1506: 
 1507:         result = idx * Series(rng5f + 1.0)
 1508:         tm.assert_equal(result, expected)
 1509: 
 1510:     # TODO: Put Series/DataFrame in others?
 1511:     @pytest.mark.parametrize(
 1512:         "other",
 1513:         [
 1514:             np.arange(1, 11),
 1515:             Index(np.arange(1, 11), np.int64),
 1516:             Index(range(1, 11), np.uint64),
 1517:             Index(range(1, 11), np.float64),
 1518:             pd.RangeIndex(1, 11),
 1519:         ],
 1520:         ids=lambda x: type(x).__name__,
 1521:     )
 1522:     def test_tdi_rmul_arraylike(self, other, box_with_array):
 1523:         box = box_with_array
 1524: 
 1525:         tdi = TimedeltaIndex(["1 Day"] * 10)
 1526:         expected = timedelta_range("1 days", "10 days")._with_freq(None)
 1527: 
 1528:         tdi = tm.box_expected(tdi, box)
 1529:         xbox = get_upcast_box(tdi, other)
 1530: 
 1531:         expected = tm.box_expected(expected, xbox)
 1532: 
 1533:         result = other * tdi
 1534:         tm.assert_equal(result, expected)
 1535:         commute = tdi * other
 1536:         tm.assert_equal(commute, expected)
 1537: 
 1538:     # ------------------------------------------------------------------
 1539:     # __div__, __rdiv__
 1540: 
 1541:     def test_td64arr_div_nat_invalid(self, box_with_array):
 1542:         # don't allow division by NaT (maybe could in the future)
 1543:         rng = timedelta_range("1 days", "10 days", name="foo")
 1544:         rng = tm.box_expected(rng, box_with_array)
 1545: 
 1546:         with pytest.raises(TypeError, match="unsupported operand type"):
 1547:             rng / NaT
 1548:         with pytest.raises(TypeError, match="Cannot divide NaTType by"):
 1549:             NaT / rng
 1550: 
 1551:         dt64nat = np.datetime64("NaT", "ns")
 1552:         msg = "|".join(
 1553:             [
 1554:                 # 'divide' on npdev as of 2021-12-18
 1555:                 "ufunc '(true_divide|divide)' cannot use operands",
 1556:                 "cannot perform __r?truediv__",
 1557:                 "Cannot divide datetime64 by TimedeltaArray",
 1558:             ]
 1559:         )
 1560:         with pytest.raises(TypeError, match=msg):
 1561:             rng / dt64nat
 1562:         with pytest.raises(TypeError, match=msg):
 1563:             dt64nat / rng
 1564: 
 1565:     def test_td64arr_div_td64nat(self, box_with_array):
 1566:         # GH#23829
 1567:         box = box_with_array
 1568:         xbox = np.ndarray if box is pd.array else box
 1569: 
 1570:         rng = timedelta_range("1 days", "10 days")
 1571:         rng = tm.box_expected(rng, box)
 1572: 
 1573:         other = np.timedelta64("NaT")
 1574: 
 1575:         expected = np.array([np.nan] * 10)
 1576:         expected = tm.box_expected(expected, xbox)
 1577: 
 1578:         result = rng / other
 1579:         tm.assert_equal(result, expected)
 1580: 
 1581:         result = other / rng
 1582:         tm.assert_equal(result, expected)
 1583: 
 1584:     def test_td64arr_div_int(self, box_with_array):
 1585:         idx = TimedeltaIndex(np.arange(5, dtype="int64"))
 1586:         idx = tm.box_expected(idx, box_with_array)
 1587: 
 1588:         result = idx / 1
 1589:         tm.assert_equal(result, idx)
 1590: 
 1591:         with pytest.raises(TypeError, match="Cannot divide"):
 1592:             # GH#23829
 1593:             1 / idx
 1594: 
 1595:     def test_td64arr_div_tdlike_scalar(self, two_hours, box_with_array):
 1596:         # GH#20088, GH#22163 ensure DataFrame returns correct dtype
 1597:         box = box_with_array
 1598:         xbox = np.ndarray if box is pd.array else box
 1599: 
 1600:         rng = timedelta_range("1 days", "10 days", name="foo")
 1601:         expected = Index((np.arange(10) + 1) * 12, dtype=np.float64, name="foo")
 1602: 
 1603:         rng = tm.box_expected(rng, box)
 1604:         expected = tm.box_expected(expected, xbox)
 1605: 
 1606:         result = rng / two_hours
 1607:         tm.assert_equal(result, expected)
 1608: 
 1609:         result = two_hours / rng
 1610:         expected = 1 / expected
 1611:         tm.assert_equal(result, expected)
 1612: 
 1613:     @pytest.mark.parametrize("m", [1, 3, 10])
 1614:     @pytest.mark.parametrize("unit", ["D", "h", "m", "s", "ms", "us", "ns"])
 1615:     def test_td64arr_div_td64_scalar(self, m, unit, box_with_array):
 1616:         box = box_with_array
 1617:         xbox = np.ndarray if box is pd.array else box
 1618: 
 1619:         ser = Series([Timedelta(days=59)] * 3)
 1620:         ser[2] = np.nan
 1621:         flat = ser
 1622:         ser = tm.box_expected(ser, box)
 1623: 
 1624:         # op
 1625:         expected = Series([x / np.timedelta64(m, unit) for x in flat])
 1626:         expected = tm.box_expected(expected, xbox)
 1627:         result = ser / np.timedelta64(m, unit)
 1628:         tm.assert_equal(result, expected)
 1629: 
 1630:         # reverse op
 1631:         expected = Series([Timedelta(np.timedelta64(m, unit)) / x for x in flat])
 1632:         expected = tm.box_expected(expected, xbox)
 1633:         result = np.timedelta64(m, unit) / ser
 1634:         tm.assert_equal(result, expected)
 1635: 
 1636:     def test_td64arr_div_tdlike_scalar_with_nat(self, two_hours, box_with_array):
 1637:         box = box_with_array
 1638:         xbox = np.ndarray if box is pd.array else box
 1639: 
 1640:         rng = TimedeltaIndex(["1 days", NaT, "2 days"], name="foo")
 1641:         expected = Index([12, np.nan, 24], dtype=np.float64, name="foo")
 1642: 
 1643:         rng = tm.box_expected(rng, box)
 1644:         expected = tm.box_expected(expected, xbox)
 1645: 
 1646:         result = rng / two_hours
 1647:         tm.assert_equal(result, expected)
 1648: 
 1649:         result = two_hours / rng
 1650:         expected = 1 / expected
 1651:         tm.assert_equal(result, expected)
 1652: 
 1653:     def test_td64arr_div_td64_ndarray(self, box_with_array):
 1654:         # GH#22631
 1655:         box = box_with_array
 1656:         xbox = np.ndarray if box is pd.array else box
 1657: 
 1658:         rng = TimedeltaIndex(["1 days", NaT, "2 days"])
 1659:         expected = Index([12, np.nan, 24], dtype=np.float64)
 1660: 
 1661:         rng = tm.box_expected(rng, box)
 1662:         expected = tm.box_expected(expected, xbox)
 1663: 
 1664:         other = np.array([2, 4, 2], dtype="m8[h]")
 1665:         result = rng / other
 1666:         tm.assert_equal(result, expected)
 1667: 
 1668:         result = rng / tm.box_expected(other, box)
 1669:         tm.assert_equal(result, expected)
 1670: 
 1671:         result = rng / other.astype(object)
 1672:         tm.assert_equal(result, expected.astype(object))
 1673: 
 1674:         result = rng / list(other)
 1675:         tm.assert_equal(result, expected)
 1676: 
 1677:         # reversed op
 1678:         expected = 1 / expected
 1679:         result = other / rng
 1680:         tm.assert_equal(result, expected)
 1681: 
 1682:         result = tm.box_expected(other, box) / rng
 1683:         tm.assert_equal(result, expected)
 1684: 
 1685:         result = other.astype(object) / rng
 1686:         tm.assert_equal(result, expected)
 1687: 
 1688:         result = list(other) / rng
 1689:         tm.assert_equal(result, expected)
 1690: 
 1691:     def test_tdarr_div_length_mismatch(self, box_with_array):
 1692:         rng = TimedeltaIndex(["1 days", NaT, "2 days"])
 1693:         mismatched = [1, 2, 3, 4]
 1694: 
 1695:         rng = tm.box_expected(rng, box_with_array)
 1696:         msg = "Cannot divide vectors|Unable to coerce to Series"
 1697:         for obj in [mismatched, mismatched[:2]]:
 1698:             # one shorter, one longer
 1699:             for other in [obj, np.array(obj), Index(obj)]:
 1700:                 with pytest.raises(ValueError, match=msg):
 1701:                     rng / other
 1702:                 with pytest.raises(ValueError, match=msg):
 1703:                     other / rng
 1704: 
 1705:     def test_td64_div_object_mixed_result(self, box_with_array):
 1706:         # Case where we having a NaT in the result inseat of timedelta64("NaT")
 1707:         #  is misleading
 1708:         orig = timedelta_range("1 Day", periods=3).insert(1, NaT)
 1709:         tdi = tm.box_expected(orig, box_with_array, transpose=False)
 1710: 
 1711:         other = np.array([orig[0], 1.5, 2.0, orig[2]], dtype=object)
 1712:         other = tm.box_expected(other, box_with_array, transpose=False)
 1713: 
 1714:         res = tdi / other
 1715: 
 1716:         expected = Index([1.0, np.timedelta64("NaT", "ns"), orig[0], 1.5], dtype=object)
 1717:         expected = tm.box_expected(expected, box_with_array, transpose=False)
 1718:         if isinstance(expected, NumpyExtensionArray):
 1719:             expected = expected.to_numpy()
 1720:         tm.assert_equal(res, expected)
 1721:         if box_with_array is DataFrame:
 1722:             # We have a np.timedelta64(NaT), not pd.NaT
 1723:             assert isinstance(res.iloc[1, 0], np.timedelta64)
 1724: 
 1725:         res = tdi // other
 1726: 
 1727:         expected = Index([1, np.timedelta64("NaT", "ns"), orig[0], 1], dtype=object)
 1728:         expected = tm.box_expected(expected, box_with_array, transpose=False)
 1729:         if isinstance(expected, NumpyExtensionArray):
 1730:             expected = expected.to_numpy()
 1731:         tm.assert_equal(res, expected)
 1732:         if box_with_array is DataFrame:
 1733:             # We have a np.timedelta64(NaT), not pd.NaT
 1734:             assert isinstance(res.iloc[1, 0], np.timedelta64)
 1735: 
 1736:     # ------------------------------------------------------------------
 1737:     # __floordiv__, __rfloordiv__
 1738: 
 1739:     def test_td64arr_floordiv_td64arr_with_nat(
 1740:         self, box_with_array, using_array_manager
 1741:     ):
 1742:         # GH#35529
 1743:         box = box_with_array
 1744:         xbox = np.ndarray if box is pd.array else box
 1745: 
 1746:         left = Series([1000, 222330, 30], dtype="timedelta64[ns]")
 1747:         right = Series([1000, 222330, None], dtype="timedelta64[ns]")
 1748: 
 1749:         left = tm.box_expected(left, box)
 1750:         right = tm.box_expected(right, box)
 1751: 
 1752:         expected = np.array([1.0, 1.0, np.nan], dtype=np.float64)
 1753:         expected = tm.box_expected(expected, xbox)
 1754:         if box is DataFrame and using_array_manager:
 1755:             # INFO(ArrayManager) floordiv returns integer, and ArrayManager
 1756:             # performs ops column-wise and thus preserves int64 dtype for
 1757:             # columns without missing values
 1758:             expected[[0, 1]] = expected[[0, 1]].astype("int64")
 1759: 
 1760:         with tm.maybe_produces_warning(
 1761:             RuntimeWarning, box is pd.array, check_stacklevel=False
 1762:         ):
 1763:             result = left // right
 1764: 
 1765:         tm.assert_equal(result, expected)
 1766: 
 1767:         # case that goes through __rfloordiv__ with arraylike
 1768:         with tm.maybe_produces_warning(
 1769:             RuntimeWarning, box is pd.array, check_stacklevel=False
 1770:         ):
 1771:             result = np.asarray(left) // right
 1772:         tm.assert_equal(result, expected)
 1773: 
 1774:     @pytest.mark.filterwarnings("ignore:invalid value encountered:RuntimeWarning")
 1775:     def test_td64arr_floordiv_tdscalar(self, box_with_array, scalar_td):
 1776:         # GH#18831, GH#19125
 1777:         box = box_with_array
 1778:         xbox = np.ndarray if box is pd.array else box
 1779:         td = Timedelta("5m3s")  # i.e. (scalar_td - 1sec) / 2
 1780: 
 1781:         td1 = Series([td, td, NaT], dtype="m8[ns]")
 1782:         td1 = tm.box_expected(td1, box, transpose=False)
 1783: 
 1784:         expected = Series([0, 0, np.nan])
 1785:         expected = tm.box_expected(expected, xbox, transpose=False)
 1786: 
 1787:         result = td1 // scalar_td
 1788:         tm.assert_equal(result, expected)
 1789: 
 1790:         # Reversed op
 1791:         expected = Series([2, 2, np.nan])
 1792:         expected = tm.box_expected(expected, xbox, transpose=False)
 1793: 
 1794:         result = scalar_td // td1
 1795:         tm.assert_equal(result, expected)
 1796: 
 1797:         # same thing buts let's be explicit about calling __rfloordiv__
 1798:         result = td1.__rfloordiv__(scalar_td)
 1799:         tm.assert_equal(result, expected)
 1800: 
 1801:     def test_td64arr_floordiv_int(self, box_with_array):
 1802:         idx = TimedeltaIndex(np.arange(5, dtype="int64"))
 1803:         idx = tm.box_expected(idx, box_with_array)
 1804:         result = idx // 1
 1805:         tm.assert_equal(result, idx)
 1806: 
 1807:         pattern = "floor_divide cannot use operands|Cannot divide int by Timedelta*"
 1808:         with pytest.raises(TypeError, match=pattern):
 1809:             1 // idx
 1810: 
 1811:     # ------------------------------------------------------------------
 1812:     # mod, divmod
 1813:     # TODO: operations with timedelta-like arrays, numeric arrays,
 1814:     #  reversed ops
 1815: 
 1816:     def test_td64arr_mod_tdscalar(self, box_with_array, three_days):
 1817:         tdi = timedelta_range("1 Day", "9 days")
 1818:         tdarr = tm.box_expected(tdi, box_with_array)
 1819: 
 1820:         expected = TimedeltaIndex(["1 Day", "2 Days", "0 Days"] * 3)
 1821:         expected = tm.box_expected(expected, box_with_array)
 1822: 
 1823:         result = tdarr % three_days
 1824:         tm.assert_equal(result, expected)
 1825: 
 1826:         warn = None
 1827:         if box_with_array is DataFrame and isinstance(three_days, pd.DateOffset):
 1828:             warn = PerformanceWarning
 1829:             # TODO: making expected be object here a result of DataFrame.__divmod__
 1830:             #  being defined in a naive way that does not dispatch to the underlying
 1831:             #  array's __divmod__
 1832:             expected = expected.astype(object)
 1833: 
 1834:         with tm.assert_produces_warning(warn):
 1835:             result = divmod(tdarr, three_days)
 1836: 
 1837:         tm.assert_equal(result[1], expected)
 1838:         tm.assert_equal(result[0], tdarr // three_days)
 1839: 
 1840:     def test_td64arr_mod_int(self, box_with_array):
 1841:         tdi = timedelta_range("1 ns", "10 ns", periods=10)
 1842:         tdarr = tm.box_expected(tdi, box_with_array)
 1843: 
 1844:         expected = TimedeltaIndex(["1 ns", "0 ns"] * 5)
 1845:         expected = tm.box_expected(expected, box_with_array)
 1846: 
 1847:         result = tdarr % 2
 1848:         tm.assert_equal(result, expected)
 1849: 
 1850:         msg = "Cannot divide int by"
 1851:         with pytest.raises(TypeError, match=msg):
 1852:             2 % tdarr
 1853: 
 1854:         result = divmod(tdarr, 2)
 1855:         tm.assert_equal(result[1], expected)
 1856:         tm.assert_equal(result[0], tdarr // 2)
 1857: 
 1858:     def test_td64arr_rmod_tdscalar(self, box_with_array, three_days):
 1859:         tdi = timedelta_range("1 Day", "9 days")
 1860:         tdarr = tm.box_expected(tdi, box_with_array)
 1861: 
 1862:         expected = ["0 Days", "1 Day", "0 Days"] + ["3 Days"] * 6
 1863:         expected = TimedeltaIndex(expected)
 1864:         expected = tm.box_expected(expected, box_with_array)
 1865: 
 1866:         result = three_days % tdarr
 1867:         tm.assert_equal(result, expected)
 1868: 
 1869:         result = divmod(three_days, tdarr)
 1870:         tm.assert_equal(result[1], expected)
 1871:         tm.assert_equal(result[0], three_days // tdarr)
 1872: 
 1873:     # ------------------------------------------------------------------
 1874:     # Operations with invalid others
 1875: 
 1876:     def test_td64arr_mul_tdscalar_invalid(self, box_with_array, scalar_td):
 1877:         td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
 1878:         td1.iloc[2] = np.nan
 1879: 
 1880:         td1 = tm.box_expected(td1, box_with_array)
 1881: 
 1882:         # check that we are getting a TypeError
 1883:         # with 'operate' (from core/ops.py) for the ops that are not
 1884:         # defined
 1885:         pattern = "operate|unsupported|cannot|not supported"
 1886:         with pytest.raises(TypeError, match=pattern):
 1887:             td1 * scalar_td
 1888:         with pytest.raises(TypeError, match=pattern):
 1889:             scalar_td * td1
 1890: 
 1891:     def test_td64arr_mul_too_short_raises(self, box_with_array):
 1892:         idx = TimedeltaIndex(np.arange(5, dtype="int64"))
 1893:         idx = tm.box_expected(idx, box_with_array)
 1894:         msg = "|".join(
 1895:             [
 1896:                 "cannot use operands with types dtype",
 1897:                 "Cannot multiply with unequal lengths",
 1898:                 "Unable to coerce to Series",
 1899:             ]
 1900:         )
 1901:         with pytest.raises(TypeError, match=msg):
 1902:             # length check before dtype check
 1903:             idx * idx[:3]
 1904:         with pytest.raises(ValueError, match=msg):
 1905:             idx * np.array([1, 2])
 1906: 
 1907:     def test_td64arr_mul_td64arr_raises(self, box_with_array):
 1908:         idx = TimedeltaIndex(np.arange(5, dtype="int64"))
 1909:         idx = tm.box_expected(idx, box_with_array)
 1910:         msg = "cannot use operands with types dtype"
 1911:         with pytest.raises(TypeError, match=msg):
 1912:             idx * idx
 1913: 
 1914:     # ------------------------------------------------------------------
 1915:     # Operations with numeric others
 1916: 
 1917:     def test_td64arr_mul_numeric_scalar(self, box_with_array, one):
 1918:         # GH#4521
 1919:         # divide/multiply by integers
 1920:         tdser = Series(["59 Days", "59 Days", "NaT"], dtype="m8[ns]")
 1921:         expected = Series(["-59 Days", "-59 Days", "NaT"], dtype="timedelta64[ns]")
 1922: 
 1923:         tdser = tm.box_expected(tdser, box_with_array)
 1924:         expected = tm.box_expected(expected, box_with_array)
 1925: 
 1926:         result = tdser * (-one)
 1927:         tm.assert_equal(result, expected)
 1928:         result = (-one) * tdser
 1929:         tm.assert_equal(result, expected)
 1930: 
 1931:         expected = Series(["118 Days", "118 Days", "NaT"], dtype="timedelta64[ns]")
 1932:         expected = tm.box_expected(expected, box_with_array)
 1933: 
 1934:         result = tdser * (2 * one)
 1935:         tm.assert_equal(result, expected)
 1936:         result = (2 * one) * tdser
 1937:         tm.assert_equal(result, expected)
 1938: 
 1939:     @pytest.mark.parametrize("two", [2, 2.0, np.array(2), np.array(2.0)])
 1940:     def test_td64arr_div_numeric_scalar(self, box_with_array, two):
 1941:         # GH#4521
 1942:         # divide/multiply by integers
 1943:         tdser = Series(["59 Days", "59 Days", "NaT"], dtype="m8[ns]")
 1944:         expected = Series(["29.5D", "29.5D", "NaT"], dtype="timedelta64[ns]")
 1945: 
 1946:         tdser = tm.box_expected(tdser, box_with_array)
 1947:         expected = tm.box_expected(expected, box_with_array)
 1948: 
 1949:         result = tdser / two
 1950:         tm.assert_equal(result, expected)
 1951: 
 1952:         with pytest.raises(TypeError, match="Cannot divide"):
 1953:             two / tdser
 1954: 
 1955:     @pytest.mark.parametrize("two", [2, 2.0, np.array(2), np.array(2.0)])
 1956:     def test_td64arr_floordiv_numeric_scalar(self, box_with_array, two):
 1957:         tdser = Series(["59 Days", "59 Days", "NaT"], dtype="m8[ns]")
 1958:         expected = Series(["29.5D", "29.5D", "NaT"], dtype="timedelta64[ns]")
 1959: 
 1960:         tdser = tm.box_expected(tdser, box_with_array)
 1961:         expected = tm.box_expected(expected, box_with_array)
 1962: 
 1963:         result = tdser // two
 1964:         tm.assert_equal(result, expected)
 1965: 
 1966:         with pytest.raises(TypeError, match="Cannot divide"):
 1967:             two // tdser
 1968: 
 1969:     @pytest.mark.parametrize(
 1970:         "vector",
 1971:         [np.array([20, 30, 40]), Index([20, 30, 40]), Series([20, 30, 40])],
 1972:         ids=lambda x: type(x).__name__,
 1973:     )
 1974:     def test_td64arr_rmul_numeric_array(
 1975:         self,
 1976:         box_with_array,
 1977:         vector,
 1978:         any_real_numpy_dtype,
 1979:     ):
 1980:         # GH#4521
 1981:         # divide/multiply by integers
 1982: 
 1983:         tdser = Series(["59 Days", "59 Days", "NaT"], dtype="m8[ns]")
 1984:         vector = vector.astype(any_real_numpy_dtype)
 1985: 
 1986:         expected = Series(["1180 Days", "1770 Days", "NaT"], dtype="timedelta64[ns]")
 1987: 
 1988:         tdser = tm.box_expected(tdser, box_with_array)
 1989:         xbox = get_upcast_box(tdser, vector)
 1990: 
 1991:         expected = tm.box_expected(expected, xbox)
 1992: 
 1993:         result = tdser * vector
 1994:         tm.assert_equal(result, expected)
 1995: 
 1996:         result = vector * tdser
 1997:         tm.assert_equal(result, expected)
 1998: 
 1999:     @pytest.mark.parametrize(
 2000:         "vector",
 2001:         [np.array([20, 30, 40]), Index([20, 30, 40]), Series([20, 30, 40])],
 2002:         ids=lambda x: type(x).__name__,
 2003:     )
 2004:     def test_td64arr_div_numeric_array(
 2005:         self, box_with_array, vector, any_real_numpy_dtype
 2006:     ):
 2007:         # GH#4521
 2008:         # divide/multiply by integers
 2009: 
 2010:         tdser = Series(["59 Days", "59 Days", "NaT"], dtype="m8[ns]")
 2011:         vector = vector.astype(any_real_numpy_dtype)
 2012: 
 2013:         expected = Series(["2.95D", "1D 23h 12m", "NaT"], dtype="timedelta64[ns]")
 2014: 
 2015:         tdser = tm.box_expected(tdser, box_with_array)
 2016:         xbox = get_upcast_box(tdser, vector)
 2017:         expected = tm.box_expected(expected, xbox)
 2018: 
 2019:         result = tdser / vector
 2020:         tm.assert_equal(result, expected)
 2021: 
 2022:         pattern = "|".join(
 2023:             [
 2024:                 "true_divide'? cannot use operands",
 2025:                 "cannot perform __div__",
 2026:                 "cannot perform __truediv__",
 2027:                 "unsupported operand",
 2028:                 "Cannot divide",
 2029:                 "ufunc 'divide' cannot use operands with types",
 2030:             ]
 2031:         )
 2032:         with pytest.raises(TypeError, match=pattern):
 2033:             vector / tdser
 2034: 
 2035:         result = tdser / vector.astype(object)
 2036:         if box_with_array is DataFrame:
 2037:             expected = [tdser.iloc[0, n] / vector[n] for n in range(len(vector))]
 2038:             expected = tm.box_expected(expected, xbox).astype(object)
 2039:             # We specifically expect timedelta64("NaT") here, not pd.NA
 2040:             msg = "The 'downcast' keyword in fillna"
 2041:             with tm.assert_produces_warning(FutureWarning, match=msg):
 2042:                 expected[2] = expected[2].fillna(
 2043:                     np.timedelta64("NaT", "ns"), downcast=False
 2044:                 )
 2045:         else:
 2046:             expected = [tdser[n] / vector[n] for n in range(len(tdser))]
 2047:             expected = [
 2048:                 x if x is not NaT else np.timedelta64("NaT", "ns") for x in expected
 2049:             ]
 2050:             if xbox is tm.to_array:
 2051:                 expected = tm.to_array(expected).astype(object)
 2052:             else:
 2053:                 expected = xbox(expected, dtype=object)
 2054: 
 2055:         tm.assert_equal(result, expected)
 2056: 
 2057:         with pytest.raises(TypeError, match=pattern):
 2058:             vector.astype(object) / tdser
 2059: 
 2060:     def test_td64arr_mul_int_series(self, box_with_array, names):
 2061:         # GH#19042 test for correct name attachment
 2062:         box = box_with_array
 2063:         exname = get_expected_name(box, names)
 2064: 
 2065:         tdi = TimedeltaIndex(
 2066:             ["0days", "1day", "2days", "3days", "4days"], name=names[0]
 2067:         )
 2068:         # TODO: Should we be parametrizing over types for `ser` too?
 2069:         ser = Series([0, 1, 2, 3, 4], dtype=np.int64, name=names[1])
 2070: 
 2071:         expected = Series(
 2072:             ["0days", "1day", "4days", "9days", "16days"],
 2073:             dtype="timedelta64[ns]",
 2074:             name=exname,
 2075:         )
 2076: 
 2077:         tdi = tm.box_expected(tdi, box)
 2078:         xbox = get_upcast_box(tdi, ser)
 2079: 
 2080:         expected = tm.box_expected(expected, xbox)
 2081: 
 2082:         result = ser * tdi
 2083:         tm.assert_equal(result, expected)
 2084: 
 2085:         result = tdi * ser
 2086:         tm.assert_equal(result, expected)
 2087: 
 2088:     # TODO: Should we be parametrizing over types for `ser` too?
 2089:     def test_float_series_rdiv_td64arr(self, box_with_array, names):
 2090:         # GH#19042 test for correct name attachment
 2091:         box = box_with_array
 2092:         tdi = TimedeltaIndex(
 2093:             ["0days", "1day", "2days", "3days", "4days"], name=names[0]
 2094:         )
 2095:         ser = Series([1.5, 3, 4.5, 6, 7.5], dtype=np.float64, name=names[1])
 2096: 
 2097:         xname = names[2] if box not in [tm.to_array, pd.array] else names[1]
 2098:         expected = Series(
 2099:             [tdi[n] / ser[n] for n in range(len(ser))],
 2100:             dtype="timedelta64[ns]",
 2101:             name=xname,
 2102:         )
 2103: 
 2104:         tdi = tm.box_expected(tdi, box)
 2105:         xbox = get_upcast_box(tdi, ser)
 2106:         expected = tm.box_expected(expected, xbox)
 2107: 
 2108:         result = ser.__rtruediv__(tdi)
 2109:         if box is DataFrame:
 2110:             assert result is NotImplemented
 2111:         else:
 2112:             tm.assert_equal(result, expected)
 2113: 
 2114:     def test_td64arr_all_nat_div_object_dtype_numeric(self, box_with_array):
 2115:         # GH#39750 make sure we infer the result as td64
 2116:         tdi = TimedeltaIndex([NaT, NaT])
 2117: 
 2118:         left = tm.box_expected(tdi, box_with_array)
 2119:         right = np.array([2, 2.0], dtype=object)
 2120: 
 2121:         tdnat = np.timedelta64("NaT", "ns")
 2122:         expected = Index([tdnat] * 2, dtype=object)
 2123:         if box_with_array is not Index:
 2124:             expected = tm.box_expected(expected, box_with_array).astype(object)
 2125:             if box_with_array in [Series, DataFrame]:
 2126:                 msg = "The 'downcast' keyword in fillna is deprecated"
 2127:                 with tm.assert_produces_warning(FutureWarning, match=msg):
 2128:                     expected = expected.fillna(tdnat, downcast=False)  # GH#18463
 2129: 
 2130:         result = left / right
 2131:         tm.assert_equal(result, expected)
 2132: 
 2133:         result = left // right
 2134:         tm.assert_equal(result, expected)
 2135: 
 2136: 
 2137: class TestTimedelta64ArrayLikeArithmetic:
 2138:     # Arithmetic tests for timedelta64[ns] vectors fully parametrized over
 2139:     #  DataFrame/Series/TimedeltaIndex/TimedeltaArray.  Ideally all arithmetic
 2140:     #  tests will eventually end up here.
 2141: 
 2142:     def test_td64arr_pow_invalid(self, scalar_td, box_with_array):
 2143:         td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
 2144:         td1.iloc[2] = np.nan
 2145: 
 2146:         td1 = tm.box_expected(td1, box_with_array)
 2147: 
 2148:         # check that we are getting a TypeError
 2149:         # with 'operate' (from core/ops.py) for the ops that are not
 2150:         # defined
 2151:         pattern = "operate|unsupported|cannot|not supported"
 2152:         with pytest.raises(TypeError, match=pattern):
 2153:             scalar_td**td1
 2154: 
 2155:         with pytest.raises(TypeError, match=pattern):
 2156:             td1**scalar_td
 2157: 
 2158: 
 2159: def test_add_timestamp_to_timedelta():
 2160:     # GH: 35897
 2161:     timestamp = Timestamp("2021-01-01")
 2162:     result = timestamp + timedelta_range("0s", "1s", periods=31)
 2163:     expected = DatetimeIndex(
 2164:         [
 2165:             timestamp
 2166:             + (
 2167:                 pd.to_timedelta("0.033333333s") * i
 2168:                 + pd.to_timedelta("0.000000001s") * divmod(i, 3)[0]
 2169:             )
 2170:             for i in range(31)
 2171:         ]
 2172:     )
 2173:     tm.assert_index_equal(result, expected)
