    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import Index
    6: 
    7: 
    8: @pytest.fixture(params=[1, np.array(1, dtype=np.int64)])
    9: def one(request):
   10:     """
   11:     Several variants of integer value 1. The zero-dim integer array
   12:     behaves like an integer.
   13: 
   14:     This fixture can be used to check that datetimelike indexes handle
   15:     addition and subtraction of integers and zero-dimensional arrays
   16:     of integers.
   17: 
   18:     Examples
   19:     --------
   20:     dti = pd.date_range('2016-01-01', periods=2, freq='h')
   21:     dti
   22:     DatetimeIndex(['2016-01-01 00:00:00', '2016-01-01 01:00:00'],
   23:     dtype='datetime64[ns]', freq='h')
   24:     dti + one
   25:     DatetimeIndex(['2016-01-01 01:00:00', '2016-01-01 02:00:00'],
   26:     dtype='datetime64[ns]', freq='h')
   27:     """
   28:     return request.param
   29: 
   30: 
   31: zeros = [
   32:     box_cls([0] * 5, dtype=dtype)
   33:     for box_cls in [Index, np.array, pd.array]
   34:     for dtype in [np.int64, np.uint64, np.float64]
   35: ]
   36: zeros.extend([box_cls([-0.0] * 5, dtype=np.float64) for box_cls in [Index, np.array]])
   37: zeros.extend([np.array(0, dtype=dtype) for dtype in [np.int64, np.uint64, np.float64]])
   38: zeros.extend([np.array(-0.0, dtype=np.float64)])
   39: zeros.extend([0, 0.0, -0.0])
   40: 
   41: 
   42: @pytest.fixture(params=zeros)
   43: def zero(request):
   44:     """
   45:     Several types of scalar zeros and length 5 vectors of zeros.
   46: 
   47:     This fixture can be used to check that numeric-dtype indexes handle
   48:     division by any zero numeric-dtype.
   49: 
   50:     Uses vector of length 5 for broadcasting with `numeric_idx` fixture,
   51:     which creates numeric-dtype vectors also of length 5.
   52: 
   53:     Examples
   54:     --------
   55:     arr = RangeIndex(5)
   56:     arr / zeros
   57:     Index([nan, inf, inf, inf, inf], dtype='float64')
   58:     """
   59:     return request.param
   60: 
   61: 
   62: # ------------------------------------------------------------------
   63: # Scalar Fixtures
   64: 
   65: 
   66: @pytest.fixture(
   67:     params=[
   68:         pd.Timedelta("10m7s").to_pytimedelta(),
   69:         pd.Timedelta("10m7s"),
   70:         pd.Timedelta("10m7s").to_timedelta64(),
   71:     ],
   72:     ids=lambda x: type(x).__name__,
   73: )
   74: def scalar_td(request):
   75:     """
   76:     Several variants of Timedelta scalars representing 10 minutes and 7 seconds.
   77:     """
   78:     return request.param
   79: 
   80: 
   81: @pytest.fixture(
   82:     params=[
   83:         pd.offsets.Day(3),
   84:         pd.offsets.Hour(72),
   85:         pd.Timedelta(days=3).to_pytimedelta(),
   86:         pd.Timedelta("72:00:00"),
   87:         np.timedelta64(3, "D"),
   88:         np.timedelta64(72, "h"),
   89:     ],
   90:     ids=lambda x: type(x).__name__,
   91: )
   92: def three_days(request):
   93:     """
   94:     Several timedelta-like and DateOffset objects that each represent
   95:     a 3-day timedelta
   96:     """
   97:     return request.param
   98: 
   99: 
  100: @pytest.fixture(
  101:     params=[
  102:         pd.offsets.Hour(2),
  103:         pd.offsets.Minute(120),
  104:         pd.Timedelta(hours=2).to_pytimedelta(),
  105:         pd.Timedelta(seconds=2 * 3600),
  106:         np.timedelta64(2, "h"),
  107:         np.timedelta64(120, "m"),
  108:     ],
  109:     ids=lambda x: type(x).__name__,
  110: )
  111: def two_hours(request):
  112:     """
  113:     Several timedelta-like and DateOffset objects that each represent
  114:     a 2-hour timedelta
  115:     """
  116:     return request.param
  117: 
  118: 
  119: _common_mismatch = [
  120:     pd.offsets.YearBegin(2),
  121:     pd.offsets.MonthBegin(1),
  122:     pd.offsets.Minute(),
  123: ]
  124: 
  125: 
  126: @pytest.fixture(
  127:     params=[
  128:         np.timedelta64(4, "h"),
  129:         pd.Timedelta(hours=23).to_pytimedelta(),
  130:         pd.Timedelta("23:00:00"),
  131:     ]
  132:     + _common_mismatch
  133: )
  134: def not_daily(request):
  135:     """
  136:     Several timedelta-like and DateOffset instances that are _not_
  137:     compatible with Daily frequencies.
  138:     """
  139:     return request.param
