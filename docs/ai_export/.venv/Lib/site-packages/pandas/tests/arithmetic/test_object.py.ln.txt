    1: # Arithmetic tests for DataFrame/Series/Index/Array classes that should
    2: # behave identically.
    3: # Specifically for object dtype
    4: import datetime
    5: from decimal import Decimal
    6: import operator
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas._config import using_pyarrow_string_dtype
   12: 
   13: import pandas.util._test_decorators as td
   14: 
   15: import pandas as pd
   16: from pandas import (
   17:     Series,
   18:     Timestamp,
   19:     option_context,
   20: )
   21: import pandas._testing as tm
   22: from pandas.core import ops
   23: 
   24: # ------------------------------------------------------------------
   25: # Comparisons
   26: 
   27: 
   28: class TestObjectComparisons:
   29:     def test_comparison_object_numeric_nas(self, comparison_op):
   30:         ser = Series(np.random.default_rng(2).standard_normal(10), dtype=object)
   31:         shifted = ser.shift(2)
   32: 
   33:         func = comparison_op
   34: 
   35:         result = func(ser, shifted)
   36:         expected = func(ser.astype(float), shifted.astype(float))
   37:         tm.assert_series_equal(result, expected)
   38: 
   39:     @pytest.mark.parametrize(
   40:         "infer_string", [False, pytest.param(True, marks=td.skip_if_no("pyarrow"))]
   41:     )
   42:     def test_object_comparisons(self, infer_string):
   43:         with option_context("future.infer_string", infer_string):
   44:             ser = Series(["a", "b", np.nan, "c", "a"])
   45: 
   46:             result = ser == "a"
   47:             expected = Series([True, False, False, False, True])
   48:             tm.assert_series_equal(result, expected)
   49: 
   50:             result = ser < "a"
   51:             expected = Series([False, False, False, False, False])
   52:             tm.assert_series_equal(result, expected)
   53: 
   54:             result = ser != "a"
   55:             expected = -(ser == "a")
   56:             tm.assert_series_equal(result, expected)
   57: 
   58:     @pytest.mark.parametrize("dtype", [None, object])
   59:     def test_more_na_comparisons(self, dtype):
   60:         left = Series(["a", np.nan, "c"], dtype=dtype)
   61:         right = Series(["a", np.nan, "d"], dtype=dtype)
   62: 
   63:         result = left == right
   64:         expected = Series([True, False, False])
   65:         tm.assert_series_equal(result, expected)
   66: 
   67:         result = left != right
   68:         expected = Series([False, True, True])
   69:         tm.assert_series_equal(result, expected)
   70: 
   71:         result = left == np.nan
   72:         expected = Series([False, False, False])
   73:         tm.assert_series_equal(result, expected)
   74: 
   75:         result = left != np.nan
   76:         expected = Series([True, True, True])
   77:         tm.assert_series_equal(result, expected)
   78: 
   79: 
   80: # ------------------------------------------------------------------
   81: # Arithmetic
   82: 
   83: 
   84: class TestArithmetic:
   85:     def test_add_period_to_array_of_offset(self):
   86:         # GH#50162
   87:         per = pd.Period("2012-1-1", freq="D")
   88:         pi = pd.period_range("2012-1-1", periods=10, freq="D")
   89:         idx = per - pi
   90: 
   91:         expected = pd.Index([x + per for x in idx], dtype=object)
   92:         result = idx + per
   93:         tm.assert_index_equal(result, expected)
   94: 
   95:         result = per + idx
   96:         tm.assert_index_equal(result, expected)
   97: 
   98:     # TODO: parametrize
   99:     def test_pow_ops_object(self):
  100:         # GH#22922
  101:         # pow is weird with masking & 1, so testing here
  102:         a = Series([1, np.nan, 1, np.nan], dtype=object)
  103:         b = Series([1, np.nan, np.nan, 1], dtype=object)
  104:         result = a**b
  105:         expected = Series(a.values**b.values, dtype=object)
  106:         tm.assert_series_equal(result, expected)
  107: 
  108:         result = b**a
  109:         expected = Series(b.values**a.values, dtype=object)
  110: 
  111:         tm.assert_series_equal(result, expected)
  112: 
  113:     @pytest.mark.parametrize("op", [operator.add, ops.radd])
  114:     @pytest.mark.parametrize("other", ["category", "Int64"])
  115:     def test_add_extension_scalar(self, other, box_with_array, op):
  116:         # GH#22378
  117:         # Check that scalars satisfying is_extension_array_dtype(obj)
  118:         # do not incorrectly try to dispatch to an ExtensionArray operation
  119: 
  120:         arr = Series(["a", "b", "c"])
  121:         expected = Series([op(x, other) for x in arr])
  122: 
  123:         arr = tm.box_expected(arr, box_with_array)
  124:         expected = tm.box_expected(expected, box_with_array)
  125: 
  126:         result = op(arr, other)
  127:         tm.assert_equal(result, expected)
  128: 
  129:     def test_objarr_add_str(self, box_with_array):
  130:         ser = Series(["x", np.nan, "x"])
  131:         expected = Series(["xa", np.nan, "xa"])
  132: 
  133:         ser = tm.box_expected(ser, box_with_array)
  134:         expected = tm.box_expected(expected, box_with_array)
  135: 
  136:         result = ser + "a"
  137:         tm.assert_equal(result, expected)
  138: 
  139:     def test_objarr_radd_str(self, box_with_array):
  140:         ser = Series(["x", np.nan, "x"])
  141:         expected = Series(["ax", np.nan, "ax"])
  142: 
  143:         ser = tm.box_expected(ser, box_with_array)
  144:         expected = tm.box_expected(expected, box_with_array)
  145: 
  146:         result = "a" + ser
  147:         tm.assert_equal(result, expected)
  148: 
  149:     @pytest.mark.parametrize(
  150:         "data",
  151:         [
  152:             [1, 2, 3],
  153:             [1.1, 2.2, 3.3],
  154:             [Timestamp("2011-01-01"), Timestamp("2011-01-02"), pd.NaT],
  155:             ["x", "y", 1],
  156:         ],
  157:     )
  158:     @pytest.mark.parametrize("dtype", [None, object])
  159:     def test_objarr_radd_str_invalid(self, dtype, data, box_with_array):
  160:         ser = Series(data, dtype=dtype)
  161: 
  162:         ser = tm.box_expected(ser, box_with_array)
  163:         msg = "|".join(
  164:             [
  165:                 "can only concatenate str",
  166:                 "did not contain a loop with signature matching types",
  167:                 "unsupported operand type",
  168:                 "must be str",
  169:             ]
  170:         )
  171:         with pytest.raises(TypeError, match=msg):
  172:             "foo_" + ser
  173: 
  174:     @pytest.mark.parametrize("op", [operator.add, ops.radd, operator.sub, ops.rsub])
  175:     def test_objarr_add_invalid(self, op, box_with_array):
  176:         # invalid ops
  177:         box = box_with_array
  178: 
  179:         obj_ser = Series(list("abc"), dtype=object, name="objects")
  180: 
  181:         obj_ser = tm.box_expected(obj_ser, box)
  182:         msg = "|".join(
  183:             [
  184:                 "can only concatenate str",
  185:                 "unsupported operand type",
  186:                 "must be str",
  187:                 "has no kernel",
  188:             ]
  189:         )
  190:         with pytest.raises(Exception, match=msg):
  191:             op(obj_ser, 1)
  192:         with pytest.raises(Exception, match=msg):
  193:             op(obj_ser, np.array(1, dtype=np.int64))
  194: 
  195:     # TODO: Moved from tests.series.test_operators; needs cleanup
  196:     def test_operators_na_handling(self):
  197:         ser = Series(["foo", "bar", "baz", np.nan])
  198:         result = "prefix_" + ser
  199:         expected = Series(["prefix_foo", "prefix_bar", "prefix_baz", np.nan])
  200:         tm.assert_series_equal(result, expected)
  201: 
  202:         result = ser + "_suffix"
  203:         expected = Series(["foo_suffix", "bar_suffix", "baz_suffix", np.nan])
  204:         tm.assert_series_equal(result, expected)
  205: 
  206:     # TODO: parametrize over box
  207:     @pytest.mark.parametrize("dtype", [None, object])
  208:     def test_series_with_dtype_radd_timedelta(self, dtype):
  209:         # note this test is _not_ aimed at timedelta64-dtyped Series
  210:         # as of 2.0 we retain object dtype when ser.dtype == object
  211:         ser = Series(
  212:             [pd.Timedelta("1 days"), pd.Timedelta("2 days"), pd.Timedelta("3 days")],
  213:             dtype=dtype,
  214:         )
  215:         expected = Series(
  216:             [pd.Timedelta("4 days"), pd.Timedelta("5 days"), pd.Timedelta("6 days")],
  217:             dtype=dtype,
  218:         )
  219: 
  220:         result = pd.Timedelta("3 days") + ser
  221:         tm.assert_series_equal(result, expected)
  222: 
  223:         result = ser + pd.Timedelta("3 days")
  224:         tm.assert_series_equal(result, expected)
  225: 
  226:     # TODO: cleanup & parametrize over box
  227:     def test_mixed_timezone_series_ops_object(self):
  228:         # GH#13043
  229:         ser = Series(
  230:             [
  231:                 Timestamp("2015-01-01", tz="US/Eastern"),
  232:                 Timestamp("2015-01-01", tz="Asia/Tokyo"),
  233:             ],
  234:             name="xxx",
  235:         )
  236:         assert ser.dtype == object
  237: 
  238:         exp = Series(
  239:             [
  240:                 Timestamp("2015-01-02", tz="US/Eastern"),
  241:                 Timestamp("2015-01-02", tz="Asia/Tokyo"),
  242:             ],
  243:             name="xxx",
  244:         )
  245:         tm.assert_series_equal(ser + pd.Timedelta("1 days"), exp)
  246:         tm.assert_series_equal(pd.Timedelta("1 days") + ser, exp)
  247: 
  248:         # object series & object series
  249:         ser2 = Series(
  250:             [
  251:                 Timestamp("2015-01-03", tz="US/Eastern"),
  252:                 Timestamp("2015-01-05", tz="Asia/Tokyo"),
  253:             ],
  254:             name="xxx",
  255:         )
  256:         assert ser2.dtype == object
  257:         exp = Series(
  258:             [pd.Timedelta("2 days"), pd.Timedelta("4 days")], name="xxx", dtype=object
  259:         )
  260:         tm.assert_series_equal(ser2 - ser, exp)
  261:         tm.assert_series_equal(ser - ser2, -exp)
  262: 
  263:         ser = Series(
  264:             [pd.Timedelta("01:00:00"), pd.Timedelta("02:00:00")],
  265:             name="xxx",
  266:             dtype=object,
  267:         )
  268:         assert ser.dtype == object
  269: 
  270:         exp = Series(
  271:             [pd.Timedelta("01:30:00"), pd.Timedelta("02:30:00")],
  272:             name="xxx",
  273:             dtype=object,
  274:         )
  275:         tm.assert_series_equal(ser + pd.Timedelta("00:30:00"), exp)
  276:         tm.assert_series_equal(pd.Timedelta("00:30:00") + ser, exp)
  277: 
  278:     # TODO: cleanup & parametrize over box
  279:     def test_iadd_preserves_name(self):
  280:         # GH#17067, GH#19723 __iadd__ and __isub__ should preserve index name
  281:         ser = Series([1, 2, 3])
  282:         ser.index.name = "foo"
  283: 
  284:         ser.index += 1
  285:         assert ser.index.name == "foo"
  286: 
  287:         ser.index -= 1
  288:         assert ser.index.name == "foo"
  289: 
  290:     def test_add_string(self):
  291:         # from bug report
  292:         index = pd.Index(["a", "b", "c"])
  293:         index2 = index + "foo"
  294: 
  295:         assert "a" not in index2
  296:         assert "afoo" in index2
  297: 
  298:     def test_iadd_string(self):
  299:         index = pd.Index(["a", "b", "c"])
  300:         # doesn't fail test unless there is a check before `+=`
  301:         assert "a" in index
  302: 
  303:         index += "_x"
  304:         assert "a_x" in index
  305: 
  306:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="add doesn't work")
  307:     def test_add(self):
  308:         index = pd.Index([str(i) for i in range(10)])
  309:         expected = pd.Index(index.values * 2)
  310:         tm.assert_index_equal(index + index, expected)
  311:         tm.assert_index_equal(index + index.tolist(), expected)
  312:         tm.assert_index_equal(index.tolist() + index, expected)
  313: 
  314:         # test add and radd
  315:         index = pd.Index(list("abc"))
  316:         expected = pd.Index(["a1", "b1", "c1"])
  317:         tm.assert_index_equal(index + "1", expected)
  318:         expected = pd.Index(["1a", "1b", "1c"])
  319:         tm.assert_index_equal("1" + index, expected)
  320: 
  321:     def test_sub_fail(self, using_infer_string):
  322:         index = pd.Index([str(i) for i in range(10)])
  323: 
  324:         if using_infer_string:
  325:             import pyarrow as pa
  326: 
  327:             err = pa.lib.ArrowNotImplementedError
  328:             msg = "has no kernel"
  329:         else:
  330:             err = TypeError
  331:             msg = "unsupported operand type|Cannot broadcast"
  332:         with pytest.raises(err, match=msg):
  333:             index - "a"
  334:         with pytest.raises(err, match=msg):
  335:             index - index
  336:         with pytest.raises(err, match=msg):
  337:             index - index.tolist()
  338:         with pytest.raises(err, match=msg):
  339:             index.tolist() - index
  340: 
  341:     def test_sub_object(self):
  342:         # GH#19369
  343:         index = pd.Index([Decimal(1), Decimal(2)])
  344:         expected = pd.Index([Decimal(0), Decimal(1)])
  345: 
  346:         result = index - Decimal(1)
  347:         tm.assert_index_equal(result, expected)
  348: 
  349:         result = index - pd.Index([Decimal(1), Decimal(1)])
  350:         tm.assert_index_equal(result, expected)
  351: 
  352:         msg = "unsupported operand type"
  353:         with pytest.raises(TypeError, match=msg):
  354:             index - "foo"
  355: 
  356:         with pytest.raises(TypeError, match=msg):
  357:             index - np.array([2, "foo"], dtype=object)
  358: 
  359:     def test_rsub_object(self, fixed_now_ts):
  360:         # GH#19369
  361:         index = pd.Index([Decimal(1), Decimal(2)])
  362:         expected = pd.Index([Decimal(1), Decimal(0)])
  363: 
  364:         result = Decimal(2) - index
  365:         tm.assert_index_equal(result, expected)
  366: 
  367:         result = np.array([Decimal(2), Decimal(2)]) - index
  368:         tm.assert_index_equal(result, expected)
  369: 
  370:         msg = "unsupported operand type"
  371:         with pytest.raises(TypeError, match=msg):
  372:             "foo" - index
  373: 
  374:         with pytest.raises(TypeError, match=msg):
  375:             np.array([True, fixed_now_ts]) - index
  376: 
  377: 
  378: class MyIndex(pd.Index):
  379:     # Simple index subclass that tracks ops calls.
  380: 
  381:     _calls: int
  382: 
  383:     @classmethod
  384:     def _simple_new(cls, values, name=None, dtype=None):
  385:         result = object.__new__(cls)
  386:         result._data = values
  387:         result._name = name
  388:         result._calls = 0
  389:         result._reset_identity()
  390: 
  391:         return result
  392: 
  393:     def __add__(self, other):
  394:         self._calls += 1
  395:         return self._simple_new(self._data)
  396: 
  397:     def __radd__(self, other):
  398:         return self.__add__(other)
  399: 
  400: 
  401: @pytest.mark.parametrize(
  402:     "other",
  403:     [
  404:         [datetime.timedelta(1), datetime.timedelta(2)],
  405:         [datetime.datetime(2000, 1, 1), datetime.datetime(2000, 1, 2)],
  406:         [pd.Period("2000"), pd.Period("2001")],
  407:         ["a", "b"],
  408:     ],
  409:     ids=["timedelta", "datetime", "period", "object"],
  410: )
  411: def test_index_ops_defer_to_unknown_subclasses(other):
  412:     # https://github.com/pandas-dev/pandas/issues/31109
  413:     values = np.array(
  414:         [datetime.date(2000, 1, 1), datetime.date(2000, 1, 2)], dtype=object
  415:     )
  416:     a = MyIndex._simple_new(values)
  417:     other = pd.Index(other)
  418:     result = other + a
  419:     assert isinstance(result, MyIndex)
  420:     assert a._calls == 1
