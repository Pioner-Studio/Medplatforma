    1: # Arithmetic tests for DataFrame/Series/Index/Array classes that should
    2: # behave identically.
    3: # Specifically for numeric dtypes
    4: from __future__ import annotations
    5: 
    6: from collections import abc
    7: from datetime import timedelta
    8: from decimal import Decimal
    9: import operator
   10: 
   11: import numpy as np
   12: import pytest
   13: 
   14: import pandas as pd
   15: from pandas import (
   16:     Index,
   17:     RangeIndex,
   18:     Series,
   19:     Timedelta,
   20:     TimedeltaIndex,
   21:     array,
   22:     date_range,
   23: )
   24: import pandas._testing as tm
   25: from pandas.core import ops
   26: from pandas.core.computation import expressions as expr
   27: from pandas.tests.arithmetic.common import (
   28:     assert_invalid_addsub_type,
   29:     assert_invalid_comparison,
   30: )
   31: 
   32: 
   33: @pytest.fixture(autouse=True, params=[0, 1000000], ids=["numexpr", "python"])
   34: def switch_numexpr_min_elements(request, monkeypatch):
   35:     with monkeypatch.context() as m:
   36:         m.setattr(expr, "_MIN_ELEMENTS", request.param)
   37:         yield request.param
   38: 
   39: 
   40: @pytest.fixture(params=[Index, Series, tm.to_array])
   41: def box_pandas_1d_array(request):
   42:     """
   43:     Fixture to test behavior for Index, Series and tm.to_array classes
   44:     """
   45:     return request.param
   46: 
   47: 
   48: @pytest.fixture(
   49:     params=[
   50:         # TODO: add more  dtypes here
   51:         Index(np.arange(5, dtype="float64")),
   52:         Index(np.arange(5, dtype="int64")),
   53:         Index(np.arange(5, dtype="uint64")),
   54:         RangeIndex(5),
   55:     ],
   56:     ids=lambda x: type(x).__name__,
   57: )
   58: def numeric_idx(request):
   59:     """
   60:     Several types of numeric-dtypes Index objects
   61:     """
   62:     return request.param
   63: 
   64: 
   65: @pytest.fixture(
   66:     params=[Index, Series, tm.to_array, np.array, list], ids=lambda x: x.__name__
   67: )
   68: def box_1d_array(request):
   69:     """
   70:     Fixture to test behavior for Index, Series, tm.to_array, numpy Array and list
   71:     classes
   72:     """
   73:     return request.param
   74: 
   75: 
   76: def adjust_negative_zero(zero, expected):
   77:     """
   78:     Helper to adjust the expected result if we are dividing by -0.0
   79:     as opposed to 0.0
   80:     """
   81:     if np.signbit(np.array(zero)).any():
   82:         # All entries in the `zero` fixture should be either
   83:         #  all-negative or no-negative.
   84:         assert np.signbit(np.array(zero)).all()
   85: 
   86:         expected *= -1
   87: 
   88:     return expected
   89: 
   90: 
   91: def compare_op(series, other, op):
   92:     left = np.abs(series) if op in (ops.rpow, operator.pow) else series
   93:     right = np.abs(other) if op in (ops.rpow, operator.pow) else other
   94: 
   95:     cython_or_numpy = op(left, right)
   96:     python = left.combine(right, op)
   97:     if isinstance(other, Series) and not other.index.equals(series.index):
   98:         python.index = python.index._with_freq(None)
   99:     tm.assert_series_equal(cython_or_numpy, python)
  100: 
  101: 
  102: # TODO: remove this kludge once mypy stops giving false positives here
  103: # List comprehension has incompatible type List[PandasObject]; expected List[RangeIndex]
  104: #  See GH#29725
  105: _ldtypes = ["i1", "i2", "i4", "i8", "u1", "u2", "u4", "u8", "f2", "f4", "f8"]
  106: lefts: list[Index | Series] = [RangeIndex(10, 40, 10)]
  107: lefts.extend([Series([10, 20, 30], dtype=dtype) for dtype in _ldtypes])
  108: lefts.extend([Index([10, 20, 30], dtype=dtype) for dtype in _ldtypes if dtype != "f2"])
  109: 
  110: # ------------------------------------------------------------------
  111: # Comparisons
  112: 
  113: 
  114: class TestNumericComparisons:
  115:     def test_operator_series_comparison_zerorank(self):
  116:         # GH#13006
  117:         result = np.float64(0) > Series([1, 2, 3])
  118:         expected = 0.0 > Series([1, 2, 3])
  119:         tm.assert_series_equal(result, expected)
  120:         result = Series([1, 2, 3]) < np.float64(0)
  121:         expected = Series([1, 2, 3]) < 0.0
  122:         tm.assert_series_equal(result, expected)
  123:         result = np.array([0, 1, 2])[0] > Series([0, 1, 2])
  124:         expected = 0.0 > Series([1, 2, 3])
  125:         tm.assert_series_equal(result, expected)
  126: 
  127:     def test_df_numeric_cmp_dt64_raises(self, box_with_array, fixed_now_ts):
  128:         # GH#8932, GH#22163
  129:         ts = fixed_now_ts
  130:         obj = np.array(range(5))
  131:         obj = tm.box_expected(obj, box_with_array)
  132: 
  133:         assert_invalid_comparison(obj, ts, box_with_array)
  134: 
  135:     def test_compare_invalid(self):
  136:         # GH#8058
  137:         # ops testing
  138:         a = Series(np.random.default_rng(2).standard_normal(5), name=0)
  139:         b = Series(np.random.default_rng(2).standard_normal(5))
  140:         b.name = pd.Timestamp("2000-01-01")
  141:         tm.assert_series_equal(a / b, 1 / (b / a))
  142: 
  143:     def test_numeric_cmp_string_numexpr_path(self, box_with_array, monkeypatch):
  144:         # GH#36377, GH#35700
  145:         box = box_with_array
  146:         xbox = box if box is not Index else np.ndarray
  147: 
  148:         obj = Series(np.random.default_rng(2).standard_normal(51))
  149:         obj = tm.box_expected(obj, box, transpose=False)
  150:         with monkeypatch.context() as m:
  151:             m.setattr(expr, "_MIN_ELEMENTS", 50)
  152:             result = obj == "a"
  153: 
  154:         expected = Series(np.zeros(51, dtype=bool))
  155:         expected = tm.box_expected(expected, xbox, transpose=False)
  156:         tm.assert_equal(result, expected)
  157: 
  158:         with monkeypatch.context() as m:
  159:             m.setattr(expr, "_MIN_ELEMENTS", 50)
  160:             result = obj != "a"
  161:         tm.assert_equal(result, ~expected)
  162: 
  163:         msg = "Invalid comparison between dtype=float64 and str"
  164:         with pytest.raises(TypeError, match=msg):
  165:             obj < "a"
  166: 
  167: 
  168: # ------------------------------------------------------------------
  169: # Numeric dtypes Arithmetic with Datetime/Timedelta Scalar
  170: 
  171: 
  172: class TestNumericArraylikeArithmeticWithDatetimeLike:
  173:     @pytest.mark.parametrize("box_cls", [np.array, Index, Series])
  174:     @pytest.mark.parametrize(
  175:         "left", lefts, ids=lambda x: type(x).__name__ + str(x.dtype)
  176:     )
  177:     def test_mul_td64arr(self, left, box_cls):
  178:         # GH#22390
  179:         right = np.array([1, 2, 3], dtype="m8[s]")
  180:         right = box_cls(right)
  181: 
  182:         expected = TimedeltaIndex(["10s", "40s", "90s"], dtype=right.dtype)
  183: 
  184:         if isinstance(left, Series) or box_cls is Series:
  185:             expected = Series(expected)
  186:         assert expected.dtype == right.dtype
  187: 
  188:         result = left * right
  189:         tm.assert_equal(result, expected)
  190: 
  191:         result = right * left
  192:         tm.assert_equal(result, expected)
  193: 
  194:     @pytest.mark.parametrize("box_cls", [np.array, Index, Series])
  195:     @pytest.mark.parametrize(
  196:         "left", lefts, ids=lambda x: type(x).__name__ + str(x.dtype)
  197:     )
  198:     def test_div_td64arr(self, left, box_cls):
  199:         # GH#22390
  200:         right = np.array([10, 40, 90], dtype="m8[s]")
  201:         right = box_cls(right)
  202: 
  203:         expected = TimedeltaIndex(["1s", "2s", "3s"], dtype=right.dtype)
  204:         if isinstance(left, Series) or box_cls is Series:
  205:             expected = Series(expected)
  206:         assert expected.dtype == right.dtype
  207: 
  208:         result = right / left
  209:         tm.assert_equal(result, expected)
  210: 
  211:         result = right // left
  212:         tm.assert_equal(result, expected)
  213: 
  214:         # (true_) needed for min-versions build 2022-12-26
  215:         msg = "ufunc '(true_)?divide' cannot use operands with types"
  216:         with pytest.raises(TypeError, match=msg):
  217:             left / right
  218: 
  219:         msg = "ufunc 'floor_divide' cannot use operands with types"
  220:         with pytest.raises(TypeError, match=msg):
  221:             left // right
  222: 
  223:     # TODO: also test Tick objects;
  224:     #  see test_numeric_arr_rdiv_tdscalar for note on these failing
  225:     @pytest.mark.parametrize(
  226:         "scalar_td",
  227:         [
  228:             Timedelta(days=1),
  229:             Timedelta(days=1).to_timedelta64(),
  230:             Timedelta(days=1).to_pytimedelta(),
  231:             Timedelta(days=1).to_timedelta64().astype("timedelta64[s]"),
  232:             Timedelta(days=1).to_timedelta64().astype("timedelta64[ms]"),
  233:         ],
  234:         ids=lambda x: type(x).__name__,
  235:     )
  236:     def test_numeric_arr_mul_tdscalar(self, scalar_td, numeric_idx, box_with_array):
  237:         # GH#19333
  238:         box = box_with_array
  239:         index = numeric_idx
  240:         expected = TimedeltaIndex([Timedelta(days=n) for n in range(len(index))])
  241:         if isinstance(scalar_td, np.timedelta64):
  242:             dtype = scalar_td.dtype
  243:             expected = expected.astype(dtype)
  244:         elif type(scalar_td) is timedelta:
  245:             expected = expected.astype("m8[us]")
  246: 
  247:         index = tm.box_expected(index, box)
  248:         expected = tm.box_expected(expected, box)
  249: 
  250:         result = index * scalar_td
  251:         tm.assert_equal(result, expected)
  252: 
  253:         commute = scalar_td * index
  254:         tm.assert_equal(commute, expected)
  255: 
  256:     @pytest.mark.parametrize(
  257:         "scalar_td",
  258:         [
  259:             Timedelta(days=1),
  260:             Timedelta(days=1).to_timedelta64(),
  261:             Timedelta(days=1).to_pytimedelta(),
  262:         ],
  263:         ids=lambda x: type(x).__name__,
  264:     )
  265:     @pytest.mark.parametrize("dtype", [np.int64, np.float64])
  266:     def test_numeric_arr_mul_tdscalar_numexpr_path(
  267:         self, dtype, scalar_td, box_with_array
  268:     ):
  269:         # GH#44772 for the float64 case
  270:         box = box_with_array
  271: 
  272:         arr_i8 = np.arange(2 * 10**4).astype(np.int64, copy=False)
  273:         arr = arr_i8.astype(dtype, copy=False)
  274:         obj = tm.box_expected(arr, box, transpose=False)
  275: 
  276:         expected = arr_i8.view("timedelta64[D]").astype("timedelta64[ns]")
  277:         if type(scalar_td) is timedelta:
  278:             expected = expected.astype("timedelta64[us]")
  279: 
  280:         expected = tm.box_expected(expected, box, transpose=False)
  281: 
  282:         result = obj * scalar_td
  283:         tm.assert_equal(result, expected)
  284: 
  285:         result = scalar_td * obj
  286:         tm.assert_equal(result, expected)
  287: 
  288:     def test_numeric_arr_rdiv_tdscalar(self, three_days, numeric_idx, box_with_array):
  289:         box = box_with_array
  290: 
  291:         index = numeric_idx[1:3]
  292: 
  293:         expected = TimedeltaIndex(["3 Days", "36 Hours"])
  294:         if isinstance(three_days, np.timedelta64):
  295:             dtype = three_days.dtype
  296:             if dtype < np.dtype("m8[s]"):
  297:                 # i.e. resolution is lower -> use lowest supported resolution
  298:                 dtype = np.dtype("m8[s]")
  299:             expected = expected.astype(dtype)
  300:         elif type(three_days) is timedelta:
  301:             expected = expected.astype("m8[us]")
  302:         elif isinstance(
  303:             three_days,
  304:             (pd.offsets.Day, pd.offsets.Hour, pd.offsets.Minute, pd.offsets.Second),
  305:         ):
  306:             # closest reso is Second
  307:             expected = expected.astype("m8[s]")
  308: 
  309:         index = tm.box_expected(index, box)
  310:         expected = tm.box_expected(expected, box)
  311: 
  312:         result = three_days / index
  313:         tm.assert_equal(result, expected)
  314: 
  315:         msg = "cannot use operands with types dtype"
  316:         with pytest.raises(TypeError, match=msg):
  317:             index / three_days
  318: 
  319:     @pytest.mark.parametrize(
  320:         "other",
  321:         [
  322:             Timedelta(hours=31),
  323:             Timedelta(hours=31).to_pytimedelta(),
  324:             Timedelta(hours=31).to_timedelta64(),
  325:             Timedelta(hours=31).to_timedelta64().astype("m8[h]"),
  326:             np.timedelta64("NaT"),
  327:             np.timedelta64("NaT", "D"),
  328:             pd.offsets.Minute(3),
  329:             pd.offsets.Second(0),
  330:             # GH#28080 numeric+datetimelike should raise; Timestamp used
  331:             #  to raise NullFrequencyError but that behavior was removed in 1.0
  332:             pd.Timestamp("2021-01-01", tz="Asia/Tokyo"),
  333:             pd.Timestamp("2021-01-01"),
  334:             pd.Timestamp("2021-01-01").to_pydatetime(),
  335:             pd.Timestamp("2021-01-01", tz="UTC").to_pydatetime(),
  336:             pd.Timestamp("2021-01-01").to_datetime64(),
  337:             np.datetime64("NaT", "ns"),
  338:             pd.NaT,
  339:         ],
  340:         ids=repr,
  341:     )
  342:     def test_add_sub_datetimedeltalike_invalid(
  343:         self, numeric_idx, other, box_with_array
  344:     ):
  345:         box = box_with_array
  346: 
  347:         left = tm.box_expected(numeric_idx, box)
  348:         msg = "|".join(
  349:             [
  350:                 "unsupported operand type",
  351:                 "Addition/subtraction of integers and integer-arrays",
  352:                 "Instead of adding/subtracting",
  353:                 "cannot use operands with types dtype",
  354:                 "Concatenation operation is not implemented for NumPy arrays",
  355:                 "Cannot (add|subtract) NaT (to|from) ndarray",
  356:                 # pd.array vs np.datetime64 case
  357:                 r"operand type\(s\) all returned NotImplemented from __array_ufunc__",
  358:                 "can only perform ops with numeric values",
  359:                 "cannot subtract DatetimeArray from ndarray",
  360:                 # pd.Timedelta(1) + Index([0, 1, 2])
  361:                 "Cannot add or subtract Timedelta from integers",
  362:             ]
  363:         )
  364:         assert_invalid_addsub_type(left, other, msg)
  365: 
  366: 
  367: # ------------------------------------------------------------------
  368: # Arithmetic
  369: 
  370: 
  371: class TestDivisionByZero:
  372:     def test_div_zero(self, zero, numeric_idx):
  373:         idx = numeric_idx
  374: 
  375:         expected = Index([np.nan, np.inf, np.inf, np.inf, np.inf], dtype=np.float64)
  376:         # We only adjust for Index, because Series does not yet apply
  377:         #  the adjustment correctly.
  378:         expected2 = adjust_negative_zero(zero, expected)
  379: 
  380:         result = idx / zero
  381:         tm.assert_index_equal(result, expected2)
  382:         ser_compat = Series(idx).astype("i8") / np.array(zero).astype("i8")
  383:         tm.assert_series_equal(ser_compat, Series(expected))
  384: 
  385:     def test_floordiv_zero(self, zero, numeric_idx):
  386:         idx = numeric_idx
  387: 
  388:         expected = Index([np.nan, np.inf, np.inf, np.inf, np.inf], dtype=np.float64)
  389:         # We only adjust for Index, because Series does not yet apply
  390:         #  the adjustment correctly.
  391:         expected2 = adjust_negative_zero(zero, expected)
  392: 
  393:         result = idx // zero
  394:         tm.assert_index_equal(result, expected2)
  395:         ser_compat = Series(idx).astype("i8") // np.array(zero).astype("i8")
  396:         tm.assert_series_equal(ser_compat, Series(expected))
  397: 
  398:     def test_mod_zero(self, zero, numeric_idx):
  399:         idx = numeric_idx
  400: 
  401:         expected = Index([np.nan, np.nan, np.nan, np.nan, np.nan], dtype=np.float64)
  402:         result = idx % zero
  403:         tm.assert_index_equal(result, expected)
  404:         ser_compat = Series(idx).astype("i8") % np.array(zero).astype("i8")
  405:         tm.assert_series_equal(ser_compat, Series(result))
  406: 
  407:     def test_divmod_zero(self, zero, numeric_idx):
  408:         idx = numeric_idx
  409: 
  410:         exleft = Index([np.nan, np.inf, np.inf, np.inf, np.inf], dtype=np.float64)
  411:         exright = Index([np.nan, np.nan, np.nan, np.nan, np.nan], dtype=np.float64)
  412:         exleft = adjust_negative_zero(zero, exleft)
  413: 
  414:         result = divmod(idx, zero)
  415:         tm.assert_index_equal(result[0], exleft)
  416:         tm.assert_index_equal(result[1], exright)
  417: 
  418:     @pytest.mark.parametrize("op", [operator.truediv, operator.floordiv])
  419:     def test_div_negative_zero(self, zero, numeric_idx, op):
  420:         # Check that -1 / -0.0 returns np.inf, not -np.inf
  421:         if numeric_idx.dtype == np.uint64:
  422:             pytest.skip(f"Div by negative 0 not relevant for {numeric_idx.dtype}")
  423:         idx = numeric_idx - 3
  424: 
  425:         expected = Index([-np.inf, -np.inf, -np.inf, np.nan, np.inf], dtype=np.float64)
  426:         expected = adjust_negative_zero(zero, expected)
  427: 
  428:         result = op(idx, zero)
  429:         tm.assert_index_equal(result, expected)
  430: 
  431:     # ------------------------------------------------------------------
  432: 
  433:     @pytest.mark.parametrize("dtype1", [np.int64, np.float64, np.uint64])
  434:     def test_ser_div_ser(
  435:         self,
  436:         switch_numexpr_min_elements,
  437:         dtype1,
  438:         any_real_numpy_dtype,
  439:     ):
  440:         # no longer do integer div for any ops, but deal with the 0's
  441:         dtype2 = any_real_numpy_dtype
  442: 
  443:         first = Series([3, 4, 5, 8], name="first").astype(dtype1)
  444:         second = Series([0, 0, 0, 3], name="second").astype(dtype2)
  445: 
  446:         with np.errstate(all="ignore"):
  447:             expected = Series(
  448:                 first.values.astype(np.float64) / second.values,
  449:                 dtype="float64",
  450:                 name=None,
  451:             )
  452:         expected.iloc[0:3] = np.inf
  453:         if first.dtype == "int64" and second.dtype == "float32":
  454:             # when using numexpr, the casting rules are slightly different
  455:             # and int64/float32 combo results in float32 instead of float64
  456:             if expr.USE_NUMEXPR and switch_numexpr_min_elements == 0:
  457:                 expected = expected.astype("float32")
  458: 
  459:         result = first / second
  460:         tm.assert_series_equal(result, expected)
  461:         assert not result.equals(second / first)
  462: 
  463:     @pytest.mark.parametrize("dtype1", [np.int64, np.float64, np.uint64])
  464:     def test_ser_divmod_zero(self, dtype1, any_real_numpy_dtype):
  465:         # GH#26987
  466:         dtype2 = any_real_numpy_dtype
  467:         left = Series([1, 1]).astype(dtype1)
  468:         right = Series([0, 2]).astype(dtype2)
  469: 
  470:         # GH#27321 pandas convention is to set 1 // 0 to np.inf, as opposed
  471:         #  to numpy which sets to np.nan; patch `expected[0]` below
  472:         expected = left // right, left % right
  473:         expected = list(expected)
  474:         expected[0] = expected[0].astype(np.float64)
  475:         expected[0][0] = np.inf
  476:         result = divmod(left, right)
  477: 
  478:         tm.assert_series_equal(result[0], expected[0])
  479:         tm.assert_series_equal(result[1], expected[1])
  480: 
  481:         # rdivmod case
  482:         result = divmod(left.values, right)
  483:         tm.assert_series_equal(result[0], expected[0])
  484:         tm.assert_series_equal(result[1], expected[1])
  485: 
  486:     def test_ser_divmod_inf(self):
  487:         left = Series([np.inf, 1.0])
  488:         right = Series([np.inf, 2.0])
  489: 
  490:         expected = left // right, left % right
  491:         result = divmod(left, right)
  492: 
  493:         tm.assert_series_equal(result[0], expected[0])
  494:         tm.assert_series_equal(result[1], expected[1])
  495: 
  496:         # rdivmod case
  497:         result = divmod(left.values, right)
  498:         tm.assert_series_equal(result[0], expected[0])
  499:         tm.assert_series_equal(result[1], expected[1])
  500: 
  501:     def test_rdiv_zero_compat(self):
  502:         # GH#8674
  503:         zero_array = np.array([0] * 5)
  504:         data = np.random.default_rng(2).standard_normal(5)
  505:         expected = Series([0.0] * 5)
  506: 
  507:         result = zero_array / Series(data)
  508:         tm.assert_series_equal(result, expected)
  509: 
  510:         result = Series(zero_array) / data
  511:         tm.assert_series_equal(result, expected)
  512: 
  513:         result = Series(zero_array) / Series(data)
  514:         tm.assert_series_equal(result, expected)
  515: 
  516:     def test_div_zero_inf_signs(self):
  517:         # GH#9144, inf signing
  518:         ser = Series([-1, 0, 1], name="first")
  519:         expected = Series([-np.inf, np.nan, np.inf], name="first")
  520: 
  521:         result = ser / 0
  522:         tm.assert_series_equal(result, expected)
  523: 
  524:     def test_rdiv_zero(self):
  525:         # GH#9144
  526:         ser = Series([-1, 0, 1], name="first")
  527:         expected = Series([0.0, np.nan, 0.0], name="first")
  528: 
  529:         result = 0 / ser
  530:         tm.assert_series_equal(result, expected)
  531: 
  532:     def test_floordiv_div(self):
  533:         # GH#9144
  534:         ser = Series([-1, 0, 1], name="first")
  535: 
  536:         result = ser // 0
  537:         expected = Series([-np.inf, np.nan, np.inf], name="first")
  538:         tm.assert_series_equal(result, expected)
  539: 
  540:     def test_df_div_zero_df(self):
  541:         # integer div, but deal with the 0's (GH#9144)
  542:         df = pd.DataFrame({"first": [3, 4, 5, 8], "second": [0, 0, 0, 3]})
  543:         result = df / df
  544: 
  545:         first = Series([1.0, 1.0, 1.0, 1.0])
  546:         second = Series([np.nan, np.nan, np.nan, 1])
  547:         expected = pd.DataFrame({"first": first, "second": second})
  548:         tm.assert_frame_equal(result, expected)
  549: 
  550:     def test_df_div_zero_array(self):
  551:         # integer div, but deal with the 0's (GH#9144)
  552:         df = pd.DataFrame({"first": [3, 4, 5, 8], "second": [0, 0, 0, 3]})
  553: 
  554:         first = Series([1.0, 1.0, 1.0, 1.0])
  555:         second = Series([np.nan, np.nan, np.nan, 1])
  556:         expected = pd.DataFrame({"first": first, "second": second})
  557: 
  558:         with np.errstate(all="ignore"):
  559:             arr = df.values.astype("float") / df.values
  560:         result = pd.DataFrame(arr, index=df.index, columns=df.columns)
  561:         tm.assert_frame_equal(result, expected)
  562: 
  563:     def test_df_div_zero_int(self):
  564:         # integer div, but deal with the 0's (GH#9144)
  565:         df = pd.DataFrame({"first": [3, 4, 5, 8], "second": [0, 0, 0, 3]})
  566: 
  567:         result = df / 0
  568:         expected = pd.DataFrame(np.inf, index=df.index, columns=df.columns)
  569:         expected.iloc[0:3, 1] = np.nan
  570:         tm.assert_frame_equal(result, expected)
  571: 
  572:         # numpy has a slightly different (wrong) treatment
  573:         with np.errstate(all="ignore"):
  574:             arr = df.values.astype("float64") / 0
  575:         result2 = pd.DataFrame(arr, index=df.index, columns=df.columns)
  576:         tm.assert_frame_equal(result2, expected)
  577: 
  578:     def test_df_div_zero_series_does_not_commute(self):
  579:         # integer div, but deal with the 0's (GH#9144)
  580:         df = pd.DataFrame(np.random.default_rng(2).standard_normal((10, 5)))
  581:         ser = df[0]
  582:         res = ser / df
  583:         res2 = df / ser
  584:         assert not res.fillna(0).equals(res2.fillna(0))
  585: 
  586:     # ------------------------------------------------------------------
  587:     # Mod By Zero
  588: 
  589:     def test_df_mod_zero_df(self, using_array_manager):
  590:         # GH#3590, modulo as ints
  591:         df = pd.DataFrame({"first": [3, 4, 5, 8], "second": [0, 0, 0, 3]})
  592:         # this is technically wrong, as the integer portion is coerced to float
  593:         first = Series([0, 0, 0, 0])
  594:         if not using_array_manager:
  595:             # INFO(ArrayManager) BlockManager doesn't preserve dtype per column
  596:             # while ArrayManager performs op column-wisedoes and thus preserves
  597:             # dtype if possible
  598:             first = first.astype("float64")
  599:         second = Series([np.nan, np.nan, np.nan, 0])
  600:         expected = pd.DataFrame({"first": first, "second": second})
  601:         result = df % df
  602:         tm.assert_frame_equal(result, expected)
  603: 
  604:         # GH#38939 If we dont pass copy=False, df is consolidated and
  605:         #  result["first"] is float64 instead of int64
  606:         df = pd.DataFrame({"first": [3, 4, 5, 8], "second": [0, 0, 0, 3]}, copy=False)
  607:         first = Series([0, 0, 0, 0], dtype="int64")
  608:         second = Series([np.nan, np.nan, np.nan, 0])
  609:         expected = pd.DataFrame({"first": first, "second": second})
  610:         result = df % df
  611:         tm.assert_frame_equal(result, expected)
  612: 
  613:     def test_df_mod_zero_array(self):
  614:         # GH#3590, modulo as ints
  615:         df = pd.DataFrame({"first": [3, 4, 5, 8], "second": [0, 0, 0, 3]})
  616: 
  617:         # this is technically wrong, as the integer portion is coerced to float
  618:         # ###
  619:         first = Series([0, 0, 0, 0], dtype="float64")
  620:         second = Series([np.nan, np.nan, np.nan, 0])
  621:         expected = pd.DataFrame({"first": first, "second": second})
  622: 
  623:         # numpy has a slightly different (wrong) treatment
  624:         with np.errstate(all="ignore"):
  625:             arr = df.values % df.values
  626:         result2 = pd.DataFrame(arr, index=df.index, columns=df.columns, dtype="float64")
  627:         result2.iloc[0:3, 1] = np.nan
  628:         tm.assert_frame_equal(result2, expected)
  629: 
  630:     def test_df_mod_zero_int(self):
  631:         # GH#3590, modulo as ints
  632:         df = pd.DataFrame({"first": [3, 4, 5, 8], "second": [0, 0, 0, 3]})
  633: 
  634:         result = df % 0
  635:         expected = pd.DataFrame(np.nan, index=df.index, columns=df.columns)
  636:         tm.assert_frame_equal(result, expected)
  637: 
  638:         # numpy has a slightly different (wrong) treatment
  639:         with np.errstate(all="ignore"):
  640:             arr = df.values.astype("float64") % 0
  641:         result2 = pd.DataFrame(arr, index=df.index, columns=df.columns)
  642:         tm.assert_frame_equal(result2, expected)
  643: 
  644:     def test_df_mod_zero_series_does_not_commute(self):
  645:         # GH#3590, modulo as ints
  646:         # not commutative with series
  647:         df = pd.DataFrame(np.random.default_rng(2).standard_normal((10, 5)))
  648:         ser = df[0]
  649:         res = ser % df
  650:         res2 = df % ser
  651:         assert not res.fillna(0).equals(res2.fillna(0))
  652: 
  653: 
  654: class TestMultiplicationDivision:
  655:     # __mul__, __rmul__, __div__, __rdiv__, __floordiv__, __rfloordiv__
  656:     # for non-timestamp/timedelta/period dtypes
  657: 
  658:     def test_divide_decimal(self, box_with_array):
  659:         # resolves issue GH#9787
  660:         box = box_with_array
  661:         ser = Series([Decimal(10)])
  662:         expected = Series([Decimal(5)])
  663: 
  664:         ser = tm.box_expected(ser, box)
  665:         expected = tm.box_expected(expected, box)
  666: 
  667:         result = ser / Decimal(2)
  668: 
  669:         tm.assert_equal(result, expected)
  670: 
  671:         result = ser // Decimal(2)
  672:         tm.assert_equal(result, expected)
  673: 
  674:     def test_div_equiv_binop(self):
  675:         # Test Series.div as well as Series.__div__
  676:         # float/integer issue
  677:         # GH#7785
  678:         first = Series([1, 0], name="first")
  679:         second = Series([-0.01, -0.02], name="second")
  680:         expected = Series([-0.01, -np.inf])
  681: 
  682:         result = second.div(first)
  683:         tm.assert_series_equal(result, expected, check_names=False)
  684: 
  685:         result = second / first
  686:         tm.assert_series_equal(result, expected)
  687: 
  688:     def test_div_int(self, numeric_idx):
  689:         idx = numeric_idx
  690:         result = idx / 1
  691:         expected = idx.astype("float64")
  692:         tm.assert_index_equal(result, expected)
  693: 
  694:         result = idx / 2
  695:         expected = Index(idx.values / 2)
  696:         tm.assert_index_equal(result, expected)
  697: 
  698:     @pytest.mark.parametrize("op", [operator.mul, ops.rmul, operator.floordiv])
  699:     def test_mul_int_identity(self, op, numeric_idx, box_with_array):
  700:         idx = numeric_idx
  701:         idx = tm.box_expected(idx, box_with_array)
  702: 
  703:         result = op(idx, 1)
  704:         tm.assert_equal(result, idx)
  705: 
  706:     def test_mul_int_array(self, numeric_idx):
  707:         idx = numeric_idx
  708:         didx = idx * idx
  709: 
  710:         result = idx * np.array(5, dtype="int64")
  711:         tm.assert_index_equal(result, idx * 5)
  712: 
  713:         arr_dtype = "uint64" if idx.dtype == np.uint64 else "int64"
  714:         result = idx * np.arange(5, dtype=arr_dtype)
  715:         tm.assert_index_equal(result, didx)
  716: 
  717:     def test_mul_int_series(self, numeric_idx):
  718:         idx = numeric_idx
  719:         didx = idx * idx
  720: 
  721:         arr_dtype = "uint64" if idx.dtype == np.uint64 else "int64"
  722:         result = idx * Series(np.arange(5, dtype=arr_dtype))
  723:         tm.assert_series_equal(result, Series(didx))
  724: 
  725:     def test_mul_float_series(self, numeric_idx):
  726:         idx = numeric_idx
  727:         rng5 = np.arange(5, dtype="float64")
  728: 
  729:         result = idx * Series(rng5 + 0.1)
  730:         expected = Series(rng5 * (rng5 + 0.1))
  731:         tm.assert_series_equal(result, expected)
  732: 
  733:     def test_mul_index(self, numeric_idx):
  734:         idx = numeric_idx
  735: 
  736:         result = idx * idx
  737:         tm.assert_index_equal(result, idx**2)
  738: 
  739:     def test_mul_datelike_raises(self, numeric_idx):
  740:         idx = numeric_idx
  741:         msg = "cannot perform __rmul__ with this index type"
  742:         with pytest.raises(TypeError, match=msg):
  743:             idx * date_range("20130101", periods=5)
  744: 
  745:     def test_mul_size_mismatch_raises(self, numeric_idx):
  746:         idx = numeric_idx
  747:         msg = "operands could not be broadcast together"
  748:         with pytest.raises(ValueError, match=msg):
  749:             idx * idx[0:3]
  750:         with pytest.raises(ValueError, match=msg):
  751:             idx * np.array([1, 2])
  752: 
  753:     @pytest.mark.parametrize("op", [operator.pow, ops.rpow])
  754:     def test_pow_float(self, op, numeric_idx, box_with_array):
  755:         # test power calculations both ways, GH#14973
  756:         box = box_with_array
  757:         idx = numeric_idx
  758:         expected = Index(op(idx.values, 2.0))
  759: 
  760:         idx = tm.box_expected(idx, box)
  761:         expected = tm.box_expected(expected, box)
  762: 
  763:         result = op(idx, 2.0)
  764:         tm.assert_equal(result, expected)
  765: 
  766:     def test_modulo(self, numeric_idx, box_with_array):
  767:         # GH#9244
  768:         box = box_with_array
  769:         idx = numeric_idx
  770:         expected = Index(idx.values % 2)
  771: 
  772:         idx = tm.box_expected(idx, box)
  773:         expected = tm.box_expected(expected, box)
  774: 
  775:         result = idx % 2
  776:         tm.assert_equal(result, expected)
  777: 
  778:     def test_divmod_scalar(self, numeric_idx):
  779:         idx = numeric_idx
  780: 
  781:         result = divmod(idx, 2)
  782:         with np.errstate(all="ignore"):
  783:             div, mod = divmod(idx.values, 2)
  784: 
  785:         expected = Index(div), Index(mod)
  786:         for r, e in zip(result, expected):
  787:             tm.assert_index_equal(r, e)
  788: 
  789:     def test_divmod_ndarray(self, numeric_idx):
  790:         idx = numeric_idx
  791:         other = np.ones(idx.values.shape, dtype=idx.values.dtype) * 2
  792: 
  793:         result = divmod(idx, other)
  794:         with np.errstate(all="ignore"):
  795:             div, mod = divmod(idx.values, other)
  796: 
  797:         expected = Index(div), Index(mod)
  798:         for r, e in zip(result, expected):
  799:             tm.assert_index_equal(r, e)
  800: 
  801:     def test_divmod_series(self, numeric_idx):
  802:         idx = numeric_idx
  803:         other = np.ones(idx.values.shape, dtype=idx.values.dtype) * 2
  804: 
  805:         result = divmod(idx, Series(other))
  806:         with np.errstate(all="ignore"):
  807:             div, mod = divmod(idx.values, other)
  808: 
  809:         expected = Series(div), Series(mod)
  810:         for r, e in zip(result, expected):
  811:             tm.assert_series_equal(r, e)
  812: 
  813:     @pytest.mark.parametrize("other", [np.nan, 7, -23, 2.718, -3.14, np.inf])
  814:     def test_ops_np_scalar(self, other):
  815:         vals = np.random.default_rng(2).standard_normal((5, 3))
  816:         f = lambda x: pd.DataFrame(
  817:             x, index=list("ABCDE"), columns=["jim", "joe", "jolie"]
  818:         )
  819: 
  820:         df = f(vals)
  821: 
  822:         tm.assert_frame_equal(df / np.array(other), f(vals / other))
  823:         tm.assert_frame_equal(np.array(other) * df, f(vals * other))
  824:         tm.assert_frame_equal(df + np.array(other), f(vals + other))
  825:         tm.assert_frame_equal(np.array(other) - df, f(other - vals))
  826: 
  827:     # TODO: This came from series.test.test_operators, needs cleanup
  828:     def test_operators_frame(self):
  829:         # rpow does not work with DataFrame
  830:         ts = Series(
  831:             np.arange(10, dtype=np.float64),
  832:             index=date_range("2020-01-01", periods=10),
  833:             name="ts",
  834:         )
  835:         ts.name = "ts"
  836: 
  837:         df = pd.DataFrame({"A": ts})
  838: 
  839:         tm.assert_series_equal(ts + ts, ts + df["A"], check_names=False)
  840:         tm.assert_series_equal(ts**ts, ts ** df["A"], check_names=False)
  841:         tm.assert_series_equal(ts < ts, ts < df["A"], check_names=False)
  842:         tm.assert_series_equal(ts / ts, ts / df["A"], check_names=False)
  843: 
  844:     # TODO: this came from tests.series.test_analytics, needs cleanup and
  845:     #  de-duplication with test_modulo above
  846:     def test_modulo2(self):
  847:         with np.errstate(all="ignore"):
  848:             # GH#3590, modulo as ints
  849:             p = pd.DataFrame({"first": [3, 4, 5, 8], "second": [0, 0, 0, 3]})
  850:             result = p["first"] % p["second"]
  851:             expected = Series(p["first"].values % p["second"].values, dtype="float64")
  852:             expected.iloc[0:3] = np.nan
  853:             tm.assert_series_equal(result, expected)
  854: 
  855:             result = p["first"] % 0
  856:             expected = Series(np.nan, index=p.index, name="first")
  857:             tm.assert_series_equal(result, expected)
  858: 
  859:             p = p.astype("float64")
  860:             result = p["first"] % p["second"]
  861:             expected = Series(p["first"].values % p["second"].values)
  862:             tm.assert_series_equal(result, expected)
  863: 
  864:             p = p.astype("float64")
  865:             result = p["first"] % p["second"]
  866:             result2 = p["second"] % p["first"]
  867:             assert not result.equals(result2)
  868: 
  869:     def test_modulo_zero_int(self):
  870:         # GH#9144
  871:         with np.errstate(all="ignore"):
  872:             s = Series([0, 1])
  873: 
  874:             result = s % 0
  875:             expected = Series([np.nan, np.nan])
  876:             tm.assert_series_equal(result, expected)
  877: 
  878:             result = 0 % s
  879:             expected = Series([np.nan, 0.0])
  880:             tm.assert_series_equal(result, expected)
  881: 
  882: 
  883: class TestAdditionSubtraction:
  884:     # __add__, __sub__, __radd__, __rsub__, __iadd__, __isub__
  885:     # for non-timestamp/timedelta/period dtypes
  886: 
  887:     @pytest.mark.parametrize(
  888:         "first, second, expected",
  889:         [
  890:             (
  891:                 Series([1, 2, 3], index=list("ABC"), name="x"),
  892:                 Series([2, 2, 2], index=list("ABD"), name="x"),
  893:                 Series([3.0, 4.0, np.nan, np.nan], index=list("ABCD"), name="x"),
  894:             ),
  895:             (
  896:                 Series([1, 2, 3], index=list("ABC"), name="x"),
  897:                 Series([2, 2, 2, 2], index=list("ABCD"), name="x"),
  898:                 Series([3, 4, 5, np.nan], index=list("ABCD"), name="x"),
  899:             ),
  900:         ],
  901:     )
  902:     def test_add_series(self, first, second, expected):
  903:         # GH#1134
  904:         tm.assert_series_equal(first + second, expected)
  905:         tm.assert_series_equal(second + first, expected)
  906: 
  907:     @pytest.mark.parametrize(
  908:         "first, second, expected",
  909:         [
  910:             (
  911:                 pd.DataFrame({"x": [1, 2, 3]}, index=list("ABC")),
  912:                 pd.DataFrame({"x": [2, 2, 2]}, index=list("ABD")),
  913:                 pd.DataFrame({"x": [3.0, 4.0, np.nan, np.nan]}, index=list("ABCD")),
  914:             ),
  915:             (
  916:                 pd.DataFrame({"x": [1, 2, 3]}, index=list("ABC")),
  917:                 pd.DataFrame({"x": [2, 2, 2, 2]}, index=list("ABCD")),
  918:                 pd.DataFrame({"x": [3, 4, 5, np.nan]}, index=list("ABCD")),
  919:             ),
  920:         ],
  921:     )
  922:     def test_add_frames(self, first, second, expected):
  923:         # GH#1134
  924:         tm.assert_frame_equal(first + second, expected)
  925:         tm.assert_frame_equal(second + first, expected)
  926: 
  927:     # TODO: This came from series.test.test_operators, needs cleanup
  928:     def test_series_frame_radd_bug(self, fixed_now_ts):
  929:         # GH#353
  930:         vals = Series([str(i) for i in range(5)])
  931:         result = "foo_" + vals
  932:         expected = vals.map(lambda x: "foo_" + x)
  933:         tm.assert_series_equal(result, expected)
  934: 
  935:         frame = pd.DataFrame({"vals": vals})
  936:         result = "foo_" + frame
  937:         expected = pd.DataFrame({"vals": vals.map(lambda x: "foo_" + x)})
  938:         tm.assert_frame_equal(result, expected)
  939: 
  940:         ts = Series(
  941:             np.arange(10, dtype=np.float64),
  942:             index=date_range("2020-01-01", periods=10),
  943:             name="ts",
  944:         )
  945: 
  946:         # really raise this time
  947:         fix_now = fixed_now_ts.to_pydatetime()
  948:         msg = "|".join(
  949:             [
  950:                 "unsupported operand type",
  951:                 # wrong error message, see https://github.com/numpy/numpy/issues/18832
  952:                 "Concatenation operation",
  953:             ]
  954:         )
  955:         with pytest.raises(TypeError, match=msg):
  956:             fix_now + ts
  957: 
  958:         with pytest.raises(TypeError, match=msg):
  959:             ts + fix_now
  960: 
  961:     # TODO: This came from series.test.test_operators, needs cleanup
  962:     def test_datetime64_with_index(self):
  963:         # arithmetic integer ops with an index
  964:         ser = Series(np.random.default_rng(2).standard_normal(5))
  965:         expected = ser - ser.index.to_series()
  966:         result = ser - ser.index
  967:         tm.assert_series_equal(result, expected)
  968: 
  969:         # GH#4629
  970:         # arithmetic datetime64 ops with an index
  971:         ser = Series(
  972:             date_range("20130101", periods=5),
  973:             index=date_range("20130101", periods=5),
  974:         )
  975:         expected = ser - ser.index.to_series()
  976:         result = ser - ser.index
  977:         tm.assert_series_equal(result, expected)
  978: 
  979:         msg = "cannot subtract PeriodArray from DatetimeArray"
  980:         with pytest.raises(TypeError, match=msg):
  981:             # GH#18850
  982:             result = ser - ser.index.to_period()
  983: 
  984:         df = pd.DataFrame(
  985:             np.random.default_rng(2).standard_normal((5, 2)),
  986:             index=date_range("20130101", periods=5),
  987:         )
  988:         df["date"] = pd.Timestamp("20130102")
  989:         df["expected"] = df["date"] - df.index.to_series()
  990:         df["result"] = df["date"] - df.index
  991:         tm.assert_series_equal(df["result"], df["expected"], check_names=False)
  992: 
  993:     # TODO: taken from tests.frame.test_operators, needs cleanup
  994:     def test_frame_operators(self, float_frame):
  995:         frame = float_frame
  996: 
  997:         garbage = np.random.default_rng(2).random(4)
  998:         colSeries = Series(garbage, index=np.array(frame.columns))
  999: 
 1000:         idSum = frame + frame
 1001:         seriesSum = frame + colSeries
 1002: 
 1003:         for col, series in idSum.items():
 1004:             for idx, val in series.items():
 1005:                 origVal = frame[col][idx] * 2
 1006:                 if not np.isnan(val):
 1007:                     assert val == origVal
 1008:                 else:
 1009:                     assert np.isnan(origVal)
 1010: 
 1011:         for col, series in seriesSum.items():
 1012:             for idx, val in series.items():
 1013:                 origVal = frame[col][idx] + colSeries[col]
 1014:                 if not np.isnan(val):
 1015:                     assert val == origVal
 1016:                 else:
 1017:                     assert np.isnan(origVal)
 1018: 
 1019:     def test_frame_operators_col_align(self, float_frame):
 1020:         frame2 = pd.DataFrame(float_frame, columns=["D", "C", "B", "A"])
 1021:         added = frame2 + frame2
 1022:         expected = frame2 * 2
 1023:         tm.assert_frame_equal(added, expected)
 1024: 
 1025:     def test_frame_operators_none_to_nan(self):
 1026:         df = pd.DataFrame({"a": ["a", None, "b"]})
 1027:         tm.assert_frame_equal(df + df, pd.DataFrame({"a": ["aa", np.nan, "bb"]}))
 1028: 
 1029:     @pytest.mark.parametrize("dtype", ("float", "int64"))
 1030:     def test_frame_operators_empty_like(self, dtype):
 1031:         # Test for issue #10181
 1032:         frames = [
 1033:             pd.DataFrame(dtype=dtype),
 1034:             pd.DataFrame(columns=["A"], dtype=dtype),
 1035:             pd.DataFrame(index=[0], dtype=dtype),
 1036:         ]
 1037:         for df in frames:
 1038:             assert (df + df).equals(df)
 1039:             tm.assert_frame_equal(df + df, df)
 1040: 
 1041:     @pytest.mark.parametrize(
 1042:         "func",
 1043:         [lambda x: x * 2, lambda x: x[::2], lambda x: 5],
 1044:         ids=["multiply", "slice", "constant"],
 1045:     )
 1046:     def test_series_operators_arithmetic(self, all_arithmetic_functions, func):
 1047:         op = all_arithmetic_functions
 1048:         series = Series(
 1049:             np.arange(10, dtype=np.float64),
 1050:             index=date_range("2020-01-01", periods=10),
 1051:             name="ts",
 1052:         )
 1053:         other = func(series)
 1054:         compare_op(series, other, op)
 1055: 
 1056:     @pytest.mark.parametrize(
 1057:         "func", [lambda x: x + 1, lambda x: 5], ids=["add", "constant"]
 1058:     )
 1059:     def test_series_operators_compare(self, comparison_op, func):
 1060:         op = comparison_op
 1061:         series = Series(
 1062:             np.arange(10, dtype=np.float64),
 1063:             index=date_range("2020-01-01", periods=10),
 1064:             name="ts",
 1065:         )
 1066:         other = func(series)
 1067:         compare_op(series, other, op)
 1068: 
 1069:     @pytest.mark.parametrize(
 1070:         "func",
 1071:         [lambda x: x * 2, lambda x: x[::2], lambda x: 5],
 1072:         ids=["multiply", "slice", "constant"],
 1073:     )
 1074:     def test_divmod(self, func):
 1075:         series = Series(
 1076:             np.arange(10, dtype=np.float64),
 1077:             index=date_range("2020-01-01", periods=10),
 1078:             name="ts",
 1079:         )
 1080:         other = func(series)
 1081:         results = divmod(series, other)
 1082:         if isinstance(other, abc.Iterable) and len(series) != len(other):
 1083:             # if the lengths don't match, this is the test where we use
 1084:             # `tser[::2]`. Pad every other value in `other_np` with nan.
 1085:             other_np = []
 1086:             for n in other:
 1087:                 other_np.append(n)
 1088:                 other_np.append(np.nan)
 1089:         else:
 1090:             other_np = other
 1091:         other_np = np.asarray(other_np)
 1092:         with np.errstate(all="ignore"):
 1093:             expecteds = divmod(series.values, np.asarray(other_np))
 1094: 
 1095:         for result, expected in zip(results, expecteds):
 1096:             # check the values, name, and index separately
 1097:             tm.assert_almost_equal(np.asarray(result), expected)
 1098: 
 1099:             assert result.name == series.name
 1100:             tm.assert_index_equal(result.index, series.index._with_freq(None))
 1101: 
 1102:     def test_series_divmod_zero(self):
 1103:         # Check that divmod uses pandas convention for division by zero,
 1104:         #  which does not match numpy.
 1105:         # pandas convention has
 1106:         #  1/0 == np.inf
 1107:         #  -1/0 == -np.inf
 1108:         #  1/-0.0 == -np.inf
 1109:         #  -1/-0.0 == np.inf
 1110:         tser = Series(
 1111:             np.arange(1, 11, dtype=np.float64),
 1112:             index=date_range("2020-01-01", periods=10),
 1113:             name="ts",
 1114:         )
 1115:         other = tser * 0
 1116: 
 1117:         result = divmod(tser, other)
 1118:         exp1 = Series([np.inf] * len(tser), index=tser.index, name="ts")
 1119:         exp2 = Series([np.nan] * len(tser), index=tser.index, name="ts")
 1120:         tm.assert_series_equal(result[0], exp1)
 1121:         tm.assert_series_equal(result[1], exp2)
 1122: 
 1123: 
 1124: class TestUFuncCompat:
 1125:     # TODO: add more dtypes
 1126:     @pytest.mark.parametrize("holder", [Index, RangeIndex, Series])
 1127:     @pytest.mark.parametrize("dtype", [np.int64, np.uint64, np.float64])
 1128:     def test_ufunc_compat(self, holder, dtype):
 1129:         box = Series if holder is Series else Index
 1130: 
 1131:         if holder is RangeIndex:
 1132:             if dtype != np.int64:
 1133:                 pytest.skip(f"dtype {dtype} not relevant for RangeIndex")
 1134:             idx = RangeIndex(0, 5, name="foo")
 1135:         else:
 1136:             idx = holder(np.arange(5, dtype=dtype), name="foo")
 1137:         result = np.sin(idx)
 1138:         expected = box(np.sin(np.arange(5, dtype=dtype)), name="foo")
 1139:         tm.assert_equal(result, expected)
 1140: 
 1141:     # TODO: add more dtypes
 1142:     @pytest.mark.parametrize("holder", [Index, Series])
 1143:     @pytest.mark.parametrize("dtype", [np.int64, np.uint64, np.float64])
 1144:     def test_ufunc_coercions(self, holder, dtype):
 1145:         idx = holder([1, 2, 3, 4, 5], dtype=dtype, name="x")
 1146:         box = Series if holder is Series else Index
 1147: 
 1148:         result = np.sqrt(idx)
 1149:         assert result.dtype == "f8" and isinstance(result, box)
 1150:         exp = Index(np.sqrt(np.array([1, 2, 3, 4, 5], dtype=np.float64)), name="x")
 1151:         exp = tm.box_expected(exp, box)
 1152:         tm.assert_equal(result, exp)
 1153: 
 1154:         result = np.divide(idx, 2.0)
 1155:         assert result.dtype == "f8" and isinstance(result, box)
 1156:         exp = Index([0.5, 1.0, 1.5, 2.0, 2.5], dtype=np.float64, name="x")
 1157:         exp = tm.box_expected(exp, box)
 1158:         tm.assert_equal(result, exp)
 1159: 
 1160:         # _evaluate_numeric_binop
 1161:         result = idx + 2.0
 1162:         assert result.dtype == "f8" and isinstance(result, box)
 1163:         exp = Index([3.0, 4.0, 5.0, 6.0, 7.0], dtype=np.float64, name="x")
 1164:         exp = tm.box_expected(exp, box)
 1165:         tm.assert_equal(result, exp)
 1166: 
 1167:         result = idx - 2.0
 1168:         assert result.dtype == "f8" and isinstance(result, box)
 1169:         exp = Index([-1.0, 0.0, 1.0, 2.0, 3.0], dtype=np.float64, name="x")
 1170:         exp = tm.box_expected(exp, box)
 1171:         tm.assert_equal(result, exp)
 1172: 
 1173:         result = idx * 1.0
 1174:         assert result.dtype == "f8" and isinstance(result, box)
 1175:         exp = Index([1.0, 2.0, 3.0, 4.0, 5.0], dtype=np.float64, name="x")
 1176:         exp = tm.box_expected(exp, box)
 1177:         tm.assert_equal(result, exp)
 1178: 
 1179:         result = idx / 2.0
 1180:         assert result.dtype == "f8" and isinstance(result, box)
 1181:         exp = Index([0.5, 1.0, 1.5, 2.0, 2.5], dtype=np.float64, name="x")
 1182:         exp = tm.box_expected(exp, box)
 1183:         tm.assert_equal(result, exp)
 1184: 
 1185:     # TODO: add more dtypes
 1186:     @pytest.mark.parametrize("holder", [Index, Series])
 1187:     @pytest.mark.parametrize("dtype", [np.int64, np.uint64, np.float64])
 1188:     def test_ufunc_multiple_return_values(self, holder, dtype):
 1189:         obj = holder([1, 2, 3], dtype=dtype, name="x")
 1190:         box = Series if holder is Series else Index
 1191: 
 1192:         result = np.modf(obj)
 1193:         assert isinstance(result, tuple)
 1194:         exp1 = Index([0.0, 0.0, 0.0], dtype=np.float64, name="x")
 1195:         exp2 = Index([1.0, 2.0, 3.0], dtype=np.float64, name="x")
 1196:         tm.assert_equal(result[0], tm.box_expected(exp1, box))
 1197:         tm.assert_equal(result[1], tm.box_expected(exp2, box))
 1198: 
 1199:     def test_ufunc_at(self):
 1200:         s = Series([0, 1, 2], index=[1, 2, 3], name="x")
 1201:         np.add.at(s, [0, 2], 10)
 1202:         expected = Series([10, 1, 12], index=[1, 2, 3], name="x")
 1203:         tm.assert_series_equal(s, expected)
 1204: 
 1205: 
 1206: class TestObjectDtypeEquivalence:
 1207:     # Tests that arithmetic operations match operations executed elementwise
 1208: 
 1209:     @pytest.mark.parametrize("dtype", [None, object])
 1210:     def test_numarr_with_dtype_add_nan(self, dtype, box_with_array):
 1211:         box = box_with_array
 1212:         ser = Series([1, 2, 3], dtype=dtype)
 1213:         expected = Series([np.nan, np.nan, np.nan], dtype=dtype)
 1214: 
 1215:         ser = tm.box_expected(ser, box)
 1216:         expected = tm.box_expected(expected, box)
 1217: 
 1218:         result = np.nan + ser
 1219:         tm.assert_equal(result, expected)
 1220: 
 1221:         result = ser + np.nan
 1222:         tm.assert_equal(result, expected)
 1223: 
 1224:     @pytest.mark.parametrize("dtype", [None, object])
 1225:     def test_numarr_with_dtype_add_int(self, dtype, box_with_array):
 1226:         box = box_with_array
 1227:         ser = Series([1, 2, 3], dtype=dtype)
 1228:         expected = Series([2, 3, 4], dtype=dtype)
 1229: 
 1230:         ser = tm.box_expected(ser, box)
 1231:         expected = tm.box_expected(expected, box)
 1232: 
 1233:         result = 1 + ser
 1234:         tm.assert_equal(result, expected)
 1235: 
 1236:         result = ser + 1
 1237:         tm.assert_equal(result, expected)
 1238: 
 1239:     # TODO: moved from tests.series.test_operators; needs cleanup
 1240:     @pytest.mark.parametrize(
 1241:         "op",
 1242:         [operator.add, operator.sub, operator.mul, operator.truediv, operator.floordiv],
 1243:     )
 1244:     def test_operators_reverse_object(self, op):
 1245:         # GH#56
 1246:         arr = Series(
 1247:             np.random.default_rng(2).standard_normal(10),
 1248:             index=np.arange(10),
 1249:             dtype=object,
 1250:         )
 1251: 
 1252:         result = op(1.0, arr)
 1253:         expected = op(1.0, arr.astype(float))
 1254:         tm.assert_series_equal(result.astype(float), expected)
 1255: 
 1256: 
 1257: class TestNumericArithmeticUnsorted:
 1258:     # Tests in this class have been moved from type-specific test modules
 1259:     #  but not yet sorted, parametrized, and de-duplicated
 1260:     @pytest.mark.parametrize(
 1261:         "op",
 1262:         [
 1263:             operator.add,
 1264:             operator.sub,
 1265:             operator.mul,
 1266:             operator.floordiv,
 1267:             operator.truediv,
 1268:         ],
 1269:     )
 1270:     @pytest.mark.parametrize(
 1271:         "idx1",
 1272:         [
 1273:             RangeIndex(0, 10, 1),
 1274:             RangeIndex(0, 20, 2),
 1275:             RangeIndex(-10, 10, 2),
 1276:             RangeIndex(5, -5, -1),
 1277:         ],
 1278:     )
 1279:     @pytest.mark.parametrize(
 1280:         "idx2",
 1281:         [
 1282:             RangeIndex(0, 10, 1),
 1283:             RangeIndex(0, 20, 2),
 1284:             RangeIndex(-10, 10, 2),
 1285:             RangeIndex(5, -5, -1),
 1286:         ],
 1287:     )
 1288:     def test_binops_index(self, op, idx1, idx2):
 1289:         idx1 = idx1._rename("foo")
 1290:         idx2 = idx2._rename("bar")
 1291:         result = op(idx1, idx2)
 1292:         expected = op(Index(idx1.to_numpy()), Index(idx2.to_numpy()))
 1293:         tm.assert_index_equal(result, expected, exact="equiv")
 1294: 
 1295:     @pytest.mark.parametrize(
 1296:         "op",
 1297:         [
 1298:             operator.add,
 1299:             operator.sub,
 1300:             operator.mul,
 1301:             operator.floordiv,
 1302:             operator.truediv,
 1303:         ],
 1304:     )
 1305:     @pytest.mark.parametrize(
 1306:         "idx",
 1307:         [
 1308:             RangeIndex(0, 10, 1),
 1309:             RangeIndex(0, 20, 2),
 1310:             RangeIndex(-10, 10, 2),
 1311:             RangeIndex(5, -5, -1),
 1312:         ],
 1313:     )
 1314:     @pytest.mark.parametrize("scalar", [-1, 1, 2])
 1315:     def test_binops_index_scalar(self, op, idx, scalar):
 1316:         result = op(idx, scalar)
 1317:         expected = op(Index(idx.to_numpy()), scalar)
 1318:         tm.assert_index_equal(result, expected, exact="equiv")
 1319: 
 1320:     @pytest.mark.parametrize("idx1", [RangeIndex(0, 10, 1), RangeIndex(0, 20, 2)])
 1321:     @pytest.mark.parametrize("idx2", [RangeIndex(0, 10, 1), RangeIndex(0, 20, 2)])
 1322:     def test_binops_index_pow(self, idx1, idx2):
 1323:         # numpy does not allow powers of negative integers so test separately
 1324:         # https://github.com/numpy/numpy/pull/8127
 1325:         idx1 = idx1._rename("foo")
 1326:         idx2 = idx2._rename("bar")
 1327:         result = pow(idx1, idx2)
 1328:         expected = pow(Index(idx1.to_numpy()), Index(idx2.to_numpy()))
 1329:         tm.assert_index_equal(result, expected, exact="equiv")
 1330: 
 1331:     @pytest.mark.parametrize("idx", [RangeIndex(0, 10, 1), RangeIndex(0, 20, 2)])
 1332:     @pytest.mark.parametrize("scalar", [1, 2])
 1333:     def test_binops_index_scalar_pow(self, idx, scalar):
 1334:         # numpy does not allow powers of negative integers so test separately
 1335:         # https://github.com/numpy/numpy/pull/8127
 1336:         result = pow(idx, scalar)
 1337:         expected = pow(Index(idx.to_numpy()), scalar)
 1338:         tm.assert_index_equal(result, expected, exact="equiv")
 1339: 
 1340:     # TODO: divmod?
 1341:     @pytest.mark.parametrize(
 1342:         "op",
 1343:         [
 1344:             operator.add,
 1345:             operator.sub,
 1346:             operator.mul,
 1347:             operator.floordiv,
 1348:             operator.truediv,
 1349:             operator.pow,
 1350:             operator.mod,
 1351:         ],
 1352:     )
 1353:     def test_arithmetic_with_frame_or_series(self, op):
 1354:         # check that we return NotImplemented when operating with Series
 1355:         # or DataFrame
 1356:         index = RangeIndex(5)
 1357:         other = Series(np.random.default_rng(2).standard_normal(5))
 1358: 
 1359:         expected = op(Series(index), other)
 1360:         result = op(index, other)
 1361:         tm.assert_series_equal(result, expected)
 1362: 
 1363:         other = pd.DataFrame(np.random.default_rng(2).standard_normal((2, 5)))
 1364:         expected = op(pd.DataFrame([index, index]), other)
 1365:         result = op(index, other)
 1366:         tm.assert_frame_equal(result, expected)
 1367: 
 1368:     def test_numeric_compat2(self):
 1369:         # validate that we are handling the RangeIndex overrides to numeric ops
 1370:         # and returning RangeIndex where possible
 1371: 
 1372:         idx = RangeIndex(0, 10, 2)
 1373: 
 1374:         result = idx * 2
 1375:         expected = RangeIndex(0, 20, 4)
 1376:         tm.assert_index_equal(result, expected, exact=True)
 1377: 
 1378:         result = idx + 2
 1379:         expected = RangeIndex(2, 12, 2)
 1380:         tm.assert_index_equal(result, expected, exact=True)
 1381: 
 1382:         result = idx - 2
 1383:         expected = RangeIndex(-2, 8, 2)
 1384:         tm.assert_index_equal(result, expected, exact=True)
 1385: 
 1386:         result = idx / 2
 1387:         expected = RangeIndex(0, 5, 1).astype("float64")
 1388:         tm.assert_index_equal(result, expected, exact=True)
 1389: 
 1390:         result = idx / 4
 1391:         expected = RangeIndex(0, 10, 2) / 4
 1392:         tm.assert_index_equal(result, expected, exact=True)
 1393: 
 1394:         result = idx // 1
 1395:         expected = idx
 1396:         tm.assert_index_equal(result, expected, exact=True)
 1397: 
 1398:         # __mul__
 1399:         result = idx * idx
 1400:         expected = Index(idx.values * idx.values)
 1401:         tm.assert_index_equal(result, expected, exact=True)
 1402: 
 1403:         # __pow__
 1404:         idx = RangeIndex(0, 1000, 2)
 1405:         result = idx**2
 1406:         expected = Index(idx._values) ** 2
 1407:         tm.assert_index_equal(Index(result.values), expected, exact=True)
 1408: 
 1409:     @pytest.mark.parametrize(
 1410:         "idx, div, expected",
 1411:         [
 1412:             # TODO: add more dtypes
 1413:             (RangeIndex(0, 1000, 2), 2, RangeIndex(0, 500, 1)),
 1414:             (RangeIndex(-99, -201, -3), -3, RangeIndex(33, 67, 1)),
 1415:             (
 1416:                 RangeIndex(0, 1000, 1),
 1417:                 2,
 1418:                 Index(RangeIndex(0, 1000, 1)._values) // 2,
 1419:             ),
 1420:             (
 1421:                 RangeIndex(0, 100, 1),
 1422:                 2.0,
 1423:                 Index(RangeIndex(0, 100, 1)._values) // 2.0,
 1424:             ),
 1425:             (RangeIndex(0), 50, RangeIndex(0)),
 1426:             (RangeIndex(2, 4, 2), 3, RangeIndex(0, 1, 1)),
 1427:             (RangeIndex(-5, -10, -6), 4, RangeIndex(-2, -1, 1)),
 1428:             (RangeIndex(-100, -200, 3), 2, RangeIndex(0)),
 1429:         ],
 1430:     )
 1431:     def test_numeric_compat2_floordiv(self, idx, div, expected):
 1432:         # __floordiv__
 1433:         tm.assert_index_equal(idx // div, expected, exact=True)
 1434: 
 1435:     @pytest.mark.parametrize("dtype", [np.int64, np.float64])
 1436:     @pytest.mark.parametrize("delta", [1, 0, -1])
 1437:     def test_addsub_arithmetic(self, dtype, delta):
 1438:         # GH#8142
 1439:         delta = dtype(delta)
 1440:         index = Index([10, 11, 12], dtype=dtype)
 1441:         result = index + delta
 1442:         expected = Index(index.values + delta, dtype=dtype)
 1443:         tm.assert_index_equal(result, expected)
 1444: 
 1445:         # this subtraction used to fail
 1446:         result = index - delta
 1447:         expected = Index(index.values - delta, dtype=dtype)
 1448:         tm.assert_index_equal(result, expected)
 1449: 
 1450:         tm.assert_index_equal(index + index, 2 * index)
 1451:         tm.assert_index_equal(index - index, 0 * index)
 1452:         assert not (index - index).empty
 1453: 
 1454:     def test_pow_nan_with_zero(self, box_with_array):
 1455:         left = Index([np.nan, np.nan, np.nan])
 1456:         right = Index([0, 0, 0])
 1457:         expected = Index([1.0, 1.0, 1.0])
 1458: 
 1459:         left = tm.box_expected(left, box_with_array)
 1460:         right = tm.box_expected(right, box_with_array)
 1461:         expected = tm.box_expected(expected, box_with_array)
 1462: 
 1463:         result = left**right
 1464:         tm.assert_equal(result, expected)
 1465: 
 1466: 
 1467: def test_fill_value_inf_masking():
 1468:     # GH #27464 make sure we mask 0/1 with Inf and not NaN
 1469:     df = pd.DataFrame({"A": [0, 1, 2], "B": [1.1, None, 1.1]})
 1470: 
 1471:     other = pd.DataFrame({"A": [1.1, 1.2, 1.3]}, index=[0, 2, 3])
 1472: 
 1473:     result = df.rfloordiv(other, fill_value=1)
 1474: 
 1475:     expected = pd.DataFrame(
 1476:         {"A": [np.inf, 1.0, 0.0, 1.0], "B": [0.0, np.nan, 0.0, np.nan]}
 1477:     )
 1478:     tm.assert_frame_equal(result, expected)
 1479: 
 1480: 
 1481: def test_dataframe_div_silenced():
 1482:     # GH#26793
 1483:     pdf1 = pd.DataFrame(
 1484:         {
 1485:             "A": np.arange(10),
 1486:             "B": [np.nan, 1, 2, 3, 4] * 2,
 1487:             "C": [np.nan] * 10,
 1488:             "D": np.arange(10),
 1489:         },
 1490:         index=list("abcdefghij"),
 1491:         columns=list("ABCD"),
 1492:     )
 1493:     pdf2 = pd.DataFrame(
 1494:         np.random.default_rng(2).standard_normal((10, 4)),
 1495:         index=list("abcdefghjk"),
 1496:         columns=list("ABCX"),
 1497:     )
 1498:     with tm.assert_produces_warning(None):
 1499:         pdf1.div(pdf2, fill_value=0)
 1500: 
 1501: 
 1502: @pytest.mark.parametrize(
 1503:     "data, expected_data",
 1504:     [([0, 1, 2], [0, 2, 4])],
 1505: )
 1506: def test_integer_array_add_list_like(
 1507:     box_pandas_1d_array, box_1d_array, data, expected_data
 1508: ):
 1509:     # GH22606 Verify operators with IntegerArray and list-likes
 1510:     arr = array(data, dtype="Int64")
 1511:     container = box_pandas_1d_array(arr)
 1512:     left = container + box_1d_array(data)
 1513:     right = box_1d_array(data) + container
 1514: 
 1515:     if Series in [box_1d_array, box_pandas_1d_array]:
 1516:         cls = Series
 1517:     elif Index in [box_1d_array, box_pandas_1d_array]:
 1518:         cls = Index
 1519:     else:
 1520:         cls = array
 1521: 
 1522:     expected = cls(expected_data, dtype="Int64")
 1523: 
 1524:     tm.assert_equal(left, expected)
 1525:     tm.assert_equal(right, expected)
 1526: 
 1527: 
 1528: def test_sub_multiindex_swapped_levels():
 1529:     # GH 9952
 1530:     df = pd.DataFrame(
 1531:         {"a": np.random.default_rng(2).standard_normal(6)},
 1532:         index=pd.MultiIndex.from_product(
 1533:             [["a", "b"], [0, 1, 2]], names=["levA", "levB"]
 1534:         ),
 1535:     )
 1536:     df2 = df.copy()
 1537:     df2.index = df2.index.swaplevel(0, 1)
 1538:     result = df - df2
 1539:     expected = pd.DataFrame([0.0] * 6, columns=["a"], index=df.index)
 1540:     tm.assert_frame_equal(result, expected)
 1541: 
 1542: 
 1543: @pytest.mark.parametrize("power", [1, 2, 5])
 1544: @pytest.mark.parametrize("string_size", [0, 1, 2, 5])
 1545: def test_empty_str_comparison(power, string_size):
 1546:     # GH 37348
 1547:     a = np.array(range(10**power))
 1548:     right = pd.DataFrame(a, dtype=np.int64)
 1549:     left = " " * string_size
 1550: 
 1551:     result = right == left
 1552:     expected = pd.DataFrame(np.zeros(right.shape, dtype=bool))
 1553:     tm.assert_frame_equal(result, expected)
 1554: 
 1555: 
 1556: def test_series_add_sub_with_UInt64():
 1557:     # GH 22023
 1558:     series1 = Series([1, 2, 3])
 1559:     series2 = Series([2, 1, 3], dtype="UInt64")
 1560: 
 1561:     result = series1 + series2
 1562:     expected = Series([3, 3, 6], dtype="Float64")
 1563:     tm.assert_series_equal(result, expected)
 1564: 
 1565:     result = series1 - series2
 1566:     expected = Series([-1, 1, 0], dtype="Float64")
 1567:     tm.assert_series_equal(result, expected)
