    1: import operator
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.core.dtypes.common import is_list_like
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     Categorical,
   11:     Index,
   12:     Interval,
   13:     IntervalIndex,
   14:     Period,
   15:     Series,
   16:     Timedelta,
   17:     Timestamp,
   18:     date_range,
   19:     period_range,
   20:     timedelta_range,
   21: )
   22: import pandas._testing as tm
   23: from pandas.core.arrays import (
   24:     BooleanArray,
   25:     IntervalArray,
   26: )
   27: from pandas.tests.arithmetic.common import get_upcast_box
   28: 
   29: 
   30: @pytest.fixture(
   31:     params=[
   32:         (Index([0, 2, 4, 4]), Index([1, 3, 5, 8])),
   33:         (Index([0.0, 1.0, 2.0, np.nan]), Index([1.0, 2.0, 3.0, np.nan])),
   34:         (
   35:             timedelta_range("0 days", periods=3).insert(3, pd.NaT),
   36:             timedelta_range("1 day", periods=3).insert(3, pd.NaT),
   37:         ),
   38:         (
   39:             date_range("20170101", periods=3).insert(3, pd.NaT),
   40:             date_range("20170102", periods=3).insert(3, pd.NaT),
   41:         ),
   42:         (
   43:             date_range("20170101", periods=3, tz="US/Eastern").insert(3, pd.NaT),
   44:             date_range("20170102", periods=3, tz="US/Eastern").insert(3, pd.NaT),
   45:         ),
   46:     ],
   47:     ids=lambda x: str(x[0].dtype),
   48: )
   49: def left_right_dtypes(request):
   50:     """
   51:     Fixture for building an IntervalArray from various dtypes
   52:     """
   53:     return request.param
   54: 
   55: 
   56: @pytest.fixture
   57: def interval_array(left_right_dtypes):
   58:     """
   59:     Fixture to generate an IntervalArray of various dtypes containing NA if possible
   60:     """
   61:     left, right = left_right_dtypes
   62:     return IntervalArray.from_arrays(left, right)
   63: 
   64: 
   65: def create_categorical_intervals(left, right, closed="right"):
   66:     return Categorical(IntervalIndex.from_arrays(left, right, closed))
   67: 
   68: 
   69: def create_series_intervals(left, right, closed="right"):
   70:     return Series(IntervalArray.from_arrays(left, right, closed))
   71: 
   72: 
   73: def create_series_categorical_intervals(left, right, closed="right"):
   74:     return Series(Categorical(IntervalIndex.from_arrays(left, right, closed)))
   75: 
   76: 
   77: class TestComparison:
   78:     @pytest.fixture(params=[operator.eq, operator.ne])
   79:     def op(self, request):
   80:         return request.param
   81: 
   82:     @pytest.fixture(
   83:         params=[
   84:             IntervalArray.from_arrays,
   85:             IntervalIndex.from_arrays,
   86:             create_categorical_intervals,
   87:             create_series_intervals,
   88:             create_series_categorical_intervals,
   89:         ],
   90:         ids=[
   91:             "IntervalArray",
   92:             "IntervalIndex",
   93:             "Categorical[Interval]",
   94:             "Series[Interval]",
   95:             "Series[Categorical[Interval]]",
   96:         ],
   97:     )
   98:     def interval_constructor(self, request):
   99:         """
  100:         Fixture for all pandas native interval constructors.
  101:         To be used as the LHS of IntervalArray comparisons.
  102:         """
  103:         return request.param
  104: 
  105:     def elementwise_comparison(self, op, interval_array, other):
  106:         """
  107:         Helper that performs elementwise comparisons between `array` and `other`
  108:         """
  109:         other = other if is_list_like(other) else [other] * len(interval_array)
  110:         expected = np.array([op(x, y) for x, y in zip(interval_array, other)])
  111:         if isinstance(other, Series):
  112:             return Series(expected, index=other.index)
  113:         return expected
  114: 
  115:     def test_compare_scalar_interval(self, op, interval_array):
  116:         # matches first interval
  117:         other = interval_array[0]
  118:         result = op(interval_array, other)
  119:         expected = self.elementwise_comparison(op, interval_array, other)
  120:         tm.assert_numpy_array_equal(result, expected)
  121: 
  122:         # matches on a single endpoint but not both
  123:         other = Interval(interval_array.left[0], interval_array.right[1])
  124:         result = op(interval_array, other)
  125:         expected = self.elementwise_comparison(op, interval_array, other)
  126:         tm.assert_numpy_array_equal(result, expected)
  127: 
  128:     def test_compare_scalar_interval_mixed_closed(self, op, closed, other_closed):
  129:         interval_array = IntervalArray.from_arrays(range(2), range(1, 3), closed=closed)
  130:         other = Interval(0, 1, closed=other_closed)
  131: 
  132:         result = op(interval_array, other)
  133:         expected = self.elementwise_comparison(op, interval_array, other)
  134:         tm.assert_numpy_array_equal(result, expected)
  135: 
  136:     def test_compare_scalar_na(self, op, interval_array, nulls_fixture, box_with_array):
  137:         box = box_with_array
  138:         obj = tm.box_expected(interval_array, box)
  139:         result = op(obj, nulls_fixture)
  140: 
  141:         if nulls_fixture is pd.NA:
  142:             # GH#31882
  143:             exp = np.ones(interval_array.shape, dtype=bool)
  144:             expected = BooleanArray(exp, exp)
  145:         else:
  146:             expected = self.elementwise_comparison(op, interval_array, nulls_fixture)
  147: 
  148:         if not (box is Index and nulls_fixture is pd.NA):
  149:             # don't cast expected from BooleanArray to ndarray[object]
  150:             xbox = get_upcast_box(obj, nulls_fixture, True)
  151:             expected = tm.box_expected(expected, xbox)
  152: 
  153:         tm.assert_equal(result, expected)
  154: 
  155:         rev = op(nulls_fixture, obj)
  156:         tm.assert_equal(rev, expected)
  157: 
  158:     @pytest.mark.parametrize(
  159:         "other",
  160:         [
  161:             0,
  162:             1.0,
  163:             True,
  164:             "foo",
  165:             Timestamp("2017-01-01"),
  166:             Timestamp("2017-01-01", tz="US/Eastern"),
  167:             Timedelta("0 days"),
  168:             Period("2017-01-01", "D"),
  169:         ],
  170:     )
  171:     def test_compare_scalar_other(self, op, interval_array, other):
  172:         result = op(interval_array, other)
  173:         expected = self.elementwise_comparison(op, interval_array, other)
  174:         tm.assert_numpy_array_equal(result, expected)
  175: 
  176:     def test_compare_list_like_interval(self, op, interval_array, interval_constructor):
  177:         # same endpoints
  178:         other = interval_constructor(interval_array.left, interval_array.right)
  179:         result = op(interval_array, other)
  180:         expected = self.elementwise_comparison(op, interval_array, other)
  181:         tm.assert_equal(result, expected)
  182: 
  183:         # different endpoints
  184:         other = interval_constructor(
  185:             interval_array.left[::-1], interval_array.right[::-1]
  186:         )
  187:         result = op(interval_array, other)
  188:         expected = self.elementwise_comparison(op, interval_array, other)
  189:         tm.assert_equal(result, expected)
  190: 
  191:         # all nan endpoints
  192:         other = interval_constructor([np.nan] * 4, [np.nan] * 4)
  193:         result = op(interval_array, other)
  194:         expected = self.elementwise_comparison(op, interval_array, other)
  195:         tm.assert_equal(result, expected)
  196: 
  197:     def test_compare_list_like_interval_mixed_closed(
  198:         self, op, interval_constructor, closed, other_closed
  199:     ):
  200:         interval_array = IntervalArray.from_arrays(range(2), range(1, 3), closed=closed)
  201:         other = interval_constructor(range(2), range(1, 3), closed=other_closed)
  202: 
  203:         result = op(interval_array, other)
  204:         expected = self.elementwise_comparison(op, interval_array, other)
  205:         tm.assert_equal(result, expected)
  206: 
  207:     @pytest.mark.parametrize(
  208:         "other",
  209:         [
  210:             (
  211:                 Interval(0, 1),
  212:                 Interval(Timedelta("1 day"), Timedelta("2 days")),
  213:                 Interval(4, 5, "both"),
  214:                 Interval(10, 20, "neither"),
  215:             ),
  216:             (0, 1.5, Timestamp("20170103"), np.nan),
  217:             (
  218:                 Timestamp("20170102", tz="US/Eastern"),
  219:                 Timedelta("2 days"),
  220:                 "baz",
  221:                 pd.NaT,
  222:             ),
  223:         ],
  224:     )
  225:     def test_compare_list_like_object(self, op, interval_array, other):
  226:         result = op(interval_array, other)
  227:         expected = self.elementwise_comparison(op, interval_array, other)
  228:         tm.assert_numpy_array_equal(result, expected)
  229: 
  230:     def test_compare_list_like_nan(self, op, interval_array, nulls_fixture):
  231:         other = [nulls_fixture] * 4
  232:         result = op(interval_array, other)
  233:         expected = self.elementwise_comparison(op, interval_array, other)
  234: 
  235:         tm.assert_equal(result, expected)
  236: 
  237:     @pytest.mark.parametrize(
  238:         "other",
  239:         [
  240:             np.arange(4, dtype="int64"),
  241:             np.arange(4, dtype="float64"),
  242:             date_range("2017-01-01", periods=4),
  243:             date_range("2017-01-01", periods=4, tz="US/Eastern"),
  244:             timedelta_range("0 days", periods=4),
  245:             period_range("2017-01-01", periods=4, freq="D"),
  246:             Categorical(list("abab")),
  247:             Categorical(date_range("2017-01-01", periods=4)),
  248:             pd.array(list("abcd")),
  249:             pd.array(["foo", 3.14, None, object()], dtype=object),
  250:         ],
  251:         ids=lambda x: str(x.dtype),
  252:     )
  253:     def test_compare_list_like_other(self, op, interval_array, other):
  254:         result = op(interval_array, other)
  255:         expected = self.elementwise_comparison(op, interval_array, other)
  256:         tm.assert_numpy_array_equal(result, expected)
  257: 
  258:     @pytest.mark.parametrize("length", [1, 3, 5])
  259:     @pytest.mark.parametrize("other_constructor", [IntervalArray, list])
  260:     def test_compare_length_mismatch_errors(self, op, other_constructor, length):
  261:         interval_array = IntervalArray.from_arrays(range(4), range(1, 5))
  262:         other = other_constructor([Interval(0, 1)] * length)
  263:         with pytest.raises(ValueError, match="Lengths must match to compare"):
  264:             op(interval_array, other)
  265: 
  266:     @pytest.mark.parametrize(
  267:         "constructor, expected_type, assert_func",
  268:         [
  269:             (IntervalIndex, np.array, tm.assert_numpy_array_equal),
  270:             (Series, Series, tm.assert_series_equal),
  271:         ],
  272:     )
  273:     def test_index_series_compat(self, op, constructor, expected_type, assert_func):
  274:         # IntervalIndex/Series that rely on IntervalArray for comparisons
  275:         breaks = range(4)
  276:         index = constructor(IntervalIndex.from_breaks(breaks))
  277: 
  278:         # scalar comparisons
  279:         other = index[0]
  280:         result = op(index, other)
  281:         expected = expected_type(self.elementwise_comparison(op, index, other))
  282:         assert_func(result, expected)
  283: 
  284:         other = breaks[0]
  285:         result = op(index, other)
  286:         expected = expected_type(self.elementwise_comparison(op, index, other))
  287:         assert_func(result, expected)
  288: 
  289:         # list-like comparisons
  290:         other = IntervalArray.from_breaks(breaks)
  291:         result = op(index, other)
  292:         expected = expected_type(self.elementwise_comparison(op, index, other))
  293:         assert_func(result, expected)
  294: 
  295:         other = [index[0], breaks[0], "foo"]
  296:         result = op(index, other)
  297:         expected = expected_type(self.elementwise_comparison(op, index, other))
  298:         assert_func(result, expected)
  299: 
  300:     @pytest.mark.parametrize("scalars", ["a", False, 1, 1.0, None])
  301:     def test_comparison_operations(self, scalars):
  302:         # GH #28981
  303:         expected = Series([False, False])
  304:         s = Series([Interval(0, 1), Interval(1, 2)], dtype="interval")
  305:         result = s == scalars
  306:         tm.assert_series_equal(result, expected)
