    1: 
    2: __all__ = ['BaseResolver', 'Resolver']
    3: 
    4: from .error import *
    5: from .nodes import *
    6: 
    7: import re
    8: 
    9: class ResolverError(YAMLError):
   10:     pass
   11: 
   12: class BaseResolver:
   13: 
   14:     DEFAULT_SCALAR_TAG = 'tag:yaml.org,2002:str'
   15:     DEFAULT_SEQUENCE_TAG = 'tag:yaml.org,2002:seq'
   16:     DEFAULT_MAPPING_TAG = 'tag:yaml.org,2002:map'
   17: 
   18:     yaml_implicit_resolvers = {}
   19:     yaml_path_resolvers = {}
   20: 
   21:     def __init__(self):
   22:         self.resolver_exact_paths = []
   23:         self.resolver_prefix_paths = []
   24: 
   25:     @classmethod
   26:     def add_implicit_resolver(cls, tag, regexp, first):
   27:         if not 'yaml_implicit_resolvers' in cls.__dict__:
   28:             implicit_resolvers = {}
   29:             for key in cls.yaml_implicit_resolvers:
   30:                 implicit_resolvers[key] = cls.yaml_implicit_resolvers[key][:]
   31:             cls.yaml_implicit_resolvers = implicit_resolvers
   32:         if first is None:
   33:             first = [None]
   34:         for ch in first:
   35:             cls.yaml_implicit_resolvers.setdefault(ch, []).append((tag, regexp))
   36: 
   37:     @classmethod
   38:     def add_path_resolver(cls, tag, path, kind=None):
   39:         # Note: `add_path_resolver` is experimental.  The API could be changed.
   40:         # `new_path` is a pattern that is matched against the path from the
   41:         # root to the node that is being considered.  `node_path` elements are
   42:         # tuples `(node_check, index_check)`.  `node_check` is a node class:
   43:         # `ScalarNode`, `SequenceNode`, `MappingNode` or `None`.  `None`
   44:         # matches any kind of a node.  `index_check` could be `None`, a boolean
   45:         # value, a string value, or a number.  `None` and `False` match against
   46:         # any _value_ of sequence and mapping nodes.  `True` matches against
   47:         # any _key_ of a mapping node.  A string `index_check` matches against
   48:         # a mapping value that corresponds to a scalar key which content is
   49:         # equal to the `index_check` value.  An integer `index_check` matches
   50:         # against a sequence value with the index equal to `index_check`.
   51:         if not 'yaml_path_resolvers' in cls.__dict__:
   52:             cls.yaml_path_resolvers = cls.yaml_path_resolvers.copy()
   53:         new_path = []
   54:         for element in path:
   55:             if isinstance(element, (list, tuple)):
   56:                 if len(element) == 2:
   57:                     node_check, index_check = element
   58:                 elif len(element) == 1:
   59:                     node_check = element[0]
   60:                     index_check = True
   61:                 else:
   62:                     raise ResolverError("Invalid path element: %s" % element)
   63:             else:
   64:                 node_check = None
   65:                 index_check = element
   66:             if node_check is str:
   67:                 node_check = ScalarNode
   68:             elif node_check is list:
   69:                 node_check = SequenceNode
   70:             elif node_check is dict:
   71:                 node_check = MappingNode
   72:             elif node_check not in [ScalarNode, SequenceNode, MappingNode]  \
   73:                     and not isinstance(node_check, str) \
   74:                     and node_check is not None:
   75:                 raise ResolverError("Invalid node checker: %s" % node_check)
   76:             if not isinstance(index_check, (str, int))  \
   77:                     and index_check is not None:
   78:                 raise ResolverError("Invalid index checker: %s" % index_check)
   79:             new_path.append((node_check, index_check))
   80:         if kind is str:
   81:             kind = ScalarNode
   82:         elif kind is list:
   83:             kind = SequenceNode
   84:         elif kind is dict:
   85:             kind = MappingNode
   86:         elif kind not in [ScalarNode, SequenceNode, MappingNode]    \
   87:                 and kind is not None:
   88:             raise ResolverError("Invalid node kind: %s" % kind)
   89:         cls.yaml_path_resolvers[tuple(new_path), kind] = tag
   90: 
   91:     def descend_resolver(self, current_node, current_index):
   92:         if not self.yaml_path_resolvers:
   93:             return
   94:         exact_paths = {}
   95:         prefix_paths = []
   96:         if current_node:
   97:             depth = len(self.resolver_prefix_paths)
   98:             for path, kind in self.resolver_prefix_paths[-1]:
   99:                 if self.check_resolver_prefix(depth, path, kind,
  100:                         current_node, current_index):
  101:                     if len(path) > depth:
  102:                         prefix_paths.append((path, kind))
  103:                     else:
  104:                         exact_paths[kind] = self.yaml_path_resolvers[path, kind]
  105:         else:
  106:             for path, kind in self.yaml_path_resolvers:
  107:                 if not path:
  108:                     exact_paths[kind] = self.yaml_path_resolvers[path, kind]
  109:                 else:
  110:                     prefix_paths.append((path, kind))
  111:         self.resolver_exact_paths.append(exact_paths)
  112:         self.resolver_prefix_paths.append(prefix_paths)
  113: 
  114:     def ascend_resolver(self):
  115:         if not self.yaml_path_resolvers:
  116:             return
  117:         self.resolver_exact_paths.pop()
  118:         self.resolver_prefix_paths.pop()
  119: 
  120:     def check_resolver_prefix(self, depth, path, kind,
  121:             current_node, current_index):
  122:         node_check, index_check = path[depth-1]
  123:         if isinstance(node_check, str):
  124:             if current_node.tag != node_check:
  125:                 return
  126:         elif node_check is not None:
  127:             if not isinstance(current_node, node_check):
  128:                 return
  129:         if index_check is True and current_index is not None:
  130:             return
  131:         if (index_check is False or index_check is None)    \
  132:                 and current_index is None:
  133:             return
  134:         if isinstance(index_check, str):
  135:             if not (isinstance(current_index, ScalarNode)
  136:                     and index_check == current_index.value):
  137:                 return
  138:         elif isinstance(index_check, int) and not isinstance(index_check, bool):
  139:             if index_check != current_index:
  140:                 return
  141:         return True
  142: 
  143:     def resolve(self, kind, value, implicit):
  144:         if kind is ScalarNode and implicit[0]:
  145:             if value == '':
  146:                 resolvers = self.yaml_implicit_resolvers.get('', [])
  147:             else:
  148:                 resolvers = self.yaml_implicit_resolvers.get(value[0], [])
  149:             wildcard_resolvers = self.yaml_implicit_resolvers.get(None, [])
  150:             for tag, regexp in resolvers + wildcard_resolvers:
  151:                 if regexp.match(value):
  152:                     return tag
  153:             implicit = implicit[1]
  154:         if self.yaml_path_resolvers:
  155:             exact_paths = self.resolver_exact_paths[-1]
  156:             if kind in exact_paths:
  157:                 return exact_paths[kind]
  158:             if None in exact_paths:
  159:                 return exact_paths[None]
  160:         if kind is ScalarNode:
  161:             return self.DEFAULT_SCALAR_TAG
  162:         elif kind is SequenceNode:
  163:             return self.DEFAULT_SEQUENCE_TAG
  164:         elif kind is MappingNode:
  165:             return self.DEFAULT_MAPPING_TAG
  166: 
  167: class Resolver(BaseResolver):
  168:     pass
  169: 
  170: Resolver.add_implicit_resolver(
  171:         'tag:yaml.org,2002:bool',
  172:         re.compile(r'''^(?:yes|Yes|YES|no|No|NO
  173:                     |true|True|TRUE|false|False|FALSE
  174:                     |on|On|ON|off|Off|OFF)$''', re.X),
  175:         list('yYnNtTfFoO'))
  176: 
  177: Resolver.add_implicit_resolver(
  178:         'tag:yaml.org,2002:float',
  179:         re.compile(r'''^(?:[-+]?(?:[0-9][0-9_]*)\.[0-9_]*(?:[eE][-+][0-9]+)?
  180:                     |\.[0-9][0-9_]*(?:[eE][-+][0-9]+)?
  181:                     |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*
  182:                     |[-+]?\.(?:inf|Inf|INF)
  183:                     |\.(?:nan|NaN|NAN))$''', re.X),
  184:         list('-+0123456789.'))
  185: 
  186: Resolver.add_implicit_resolver(
  187:         'tag:yaml.org,2002:int',
  188:         re.compile(r'''^(?:[-+]?0b[0-1_]+
  189:                     |[-+]?0[0-7_]+
  190:                     |[-+]?(?:0|[1-9][0-9_]*)
  191:                     |[-+]?0x[0-9a-fA-F_]+
  192:                     |[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$''', re.X),
  193:         list('-+0123456789'))
  194: 
  195: Resolver.add_implicit_resolver(
  196:         'tag:yaml.org,2002:merge',
  197:         re.compile(r'^(?:<<)$'),
  198:         ['<'])
  199: 
  200: Resolver.add_implicit_resolver(
  201:         'tag:yaml.org,2002:null',
  202:         re.compile(r'''^(?: ~
  203:                     |null|Null|NULL
  204:                     | )$''', re.X),
  205:         ['~', 'n', 'N', ''])
  206: 
  207: Resolver.add_implicit_resolver(
  208:         'tag:yaml.org,2002:timestamp',
  209:         re.compile(r'''^(?:[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]
  210:                     |[0-9][0-9][0-9][0-9] -[0-9][0-9]? -[0-9][0-9]?
  211:                      (?:[Tt]|[ \t]+)[0-9][0-9]?
  212:                      :[0-9][0-9] :[0-9][0-9] (?:\.[0-9]*)?
  213:                      (?:[ \t]*(?:Z|[-+][0-9][0-9]?(?::[0-9][0-9])?))?)$''', re.X),
  214:         list('0123456789'))
  215: 
  216: Resolver.add_implicit_resolver(
  217:         'tag:yaml.org,2002:value',
  218:         re.compile(r'^(?:=)$'),
  219:         ['='])
  220: 
  221: # The following resolver is only for documentation purposes. It cannot work
  222: # because plain scalars cannot start with '!', '&', or '*'.
  223: Resolver.add_implicit_resolver(
  224:         'tag:yaml.org,2002:yaml',
  225:         re.compile(r'^(?:!|&|\*)$'),
  226:         list('!&*'))
