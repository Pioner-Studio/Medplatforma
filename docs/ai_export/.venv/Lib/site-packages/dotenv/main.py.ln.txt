    1: import io
    2: import logging
    3: import os
    4: import pathlib
    5: import shutil
    6: import sys
    7: import tempfile
    8: from collections import OrderedDict
    9: from contextlib import contextmanager
   10: from typing import (IO, Dict, Iterable, Iterator, Mapping, Optional, Tuple,
   11:                     Union)
   12: 
   13: from .parser import Binding, parse_stream
   14: from .variables import parse_variables
   15: 
   16: # A type alias for a string path to be used for the paths in this file.
   17: # These paths may flow to `open()` and `shutil.move()`; `shutil.move()`
   18: # only accepts string paths, not byte paths or file descriptors. See
   19: # https://github.com/python/typeshed/pull/6832.
   20: StrPath = Union[str, 'os.PathLike[str]']
   21: 
   22: logger = logging.getLogger(__name__)
   23: 
   24: 
   25: def with_warn_for_invalid_lines(mappings: Iterator[Binding]) -> Iterator[Binding]:
   26:     for mapping in mappings:
   27:         if mapping.error:
   28:             logger.warning(
   29:                 "Python-dotenv could not parse statement starting at line %s",
   30:                 mapping.original.line,
   31:             )
   32:         yield mapping
   33: 
   34: 
   35: class DotEnv:
   36:     def __init__(
   37:         self,
   38:         dotenv_path: Optional[StrPath],
   39:         stream: Optional[IO[str]] = None,
   40:         verbose: bool = False,
   41:         encoding: Optional[str] = None,
   42:         interpolate: bool = True,
   43:         override: bool = True,
   44:     ) -> None:
   45:         self.dotenv_path: Optional[StrPath] = dotenv_path
   46:         self.stream: Optional[IO[str]] = stream
   47:         self._dict: Optional[Dict[str, Optional[str]]] = None
   48:         self.verbose: bool = verbose
   49:         self.encoding: Optional[str] = encoding
   50:         self.interpolate: bool = interpolate
   51:         self.override: bool = override
   52: 
   53:     @contextmanager
   54:     def _get_stream(self) -> Iterator[IO[str]]:
   55:         if self.dotenv_path and os.path.isfile(self.dotenv_path):
   56:             with open(self.dotenv_path, encoding=self.encoding) as stream:
   57:                 yield stream
   58:         elif self.stream is not None:
   59:             yield self.stream
   60:         else:
   61:             if self.verbose:
   62:                 logger.info(
   63:                     "Python-dotenv could not find configuration file %s.",
   64:                     self.dotenv_path or '.env',
   65:                 )
   66:             yield io.StringIO('')
   67: 
   68:     def dict(self) -> Dict[str, Optional[str]]:
   69:         """Return dotenv as dict"""
   70:         if self._dict:
   71:             return self._dict
   72: 
   73:         raw_values = self.parse()
   74: 
   75:         if self.interpolate:
   76:             self._dict = OrderedDict(resolve_variables(raw_values, override=self.override))
   77:         else:
   78:             self._dict = OrderedDict(raw_values)
   79: 
   80:         return self._dict
   81: 
   82:     def parse(self) -> Iterator[Tuple[str, Optional[str]]]:
   83:         with self._get_stream() as stream:
   84:             for mapping in with_warn_for_invalid_lines(parse_stream(stream)):
   85:                 if mapping.key is not None:
   86:                     yield mapping.key, mapping.value
   87: 
   88:     def set_as_environment_variables(self) -> bool:
   89:         """
   90:         Load the current dotenv as system environment variable.
   91:         """
   92:         if not self.dict():
   93:             return False
   94: 
   95:         for k, v in self.dict().items():
   96:             if k in os.environ and not self.override:
   97:                 continue
   98:             if v is not None:
   99:                 os.environ[k] = v
  100: 
  101:         return True
  102: 
  103:     def get(self, key: str) -> Optional[str]:
  104:         """
  105:         """
  106:         data = self.dict()
  107: 
  108:         if key in data:
  109:             return data[key]
  110: 
  111:         if self.verbose:
  112:             logger.warning("Key %s not found in %s.", key, self.dotenv_path)
  113: 
  114:         return None
  115: 
  116: 
  117: def get_key(
  118:     dotenv_path: StrPath,
  119:     key_to_get: str,
  120:     encoding: Optional[str] = "utf-8",
  121: ) -> Optional[str]:
  122:     """
  123:     Get the value of a given key from the given .env.
  124: 
  125:     Returns `None` if the key isn't found or doesn't have a value.
  126:     """
  127:     return DotEnv(dotenv_path, verbose=True, encoding=encoding).get(key_to_get)
  128: 
  129: 
  130: @contextmanager
  131: def rewrite(
  132:     path: StrPath,
  133:     encoding: Optional[str],
  134: ) -> Iterator[Tuple[IO[str], IO[str]]]:
  135:     pathlib.Path(path).touch()
  136: 
  137:     with tempfile.NamedTemporaryFile(mode="w", encoding=encoding, delete=False) as dest:
  138:         error = None
  139:         try:
  140:             with open(path, encoding=encoding) as source:
  141:                 yield (source, dest)
  142:         except BaseException as err:
  143:             error = err
  144: 
  145:     if error is None:
  146:         shutil.move(dest.name, path)
  147:     else:
  148:         os.unlink(dest.name)
  149:         raise error from None
  150: 
  151: 
  152: def set_key(
  153:     dotenv_path: StrPath,
  154:     key_to_set: str,
  155:     value_to_set: str,
  156:     quote_mode: str = "always",
  157:     export: bool = False,
  158:     encoding: Optional[str] = "utf-8",
  159: ) -> Tuple[Optional[bool], str, str]:
  160:     """
  161:     Adds or Updates a key/value to the given .env
  162: 
  163:     If the .env path given doesn't exist, fails instead of risking creating
  164:     an orphan .env somewhere in the filesystem
  165:     """
  166:     if quote_mode not in ("always", "auto", "never"):
  167:         raise ValueError(f"Unknown quote_mode: {quote_mode}")
  168: 
  169:     quote = (
  170:         quote_mode == "always"
  171:         or (quote_mode == "auto" and not value_to_set.isalnum())
  172:     )
  173: 
  174:     if quote:
  175:         value_out = "'{}'".format(value_to_set.replace("'", "\\'"))
  176:     else:
  177:         value_out = value_to_set
  178:     if export:
  179:         line_out = f'export {key_to_set}={value_out}\n'
  180:     else:
  181:         line_out = f"{key_to_set}={value_out}\n"
  182: 
  183:     with rewrite(dotenv_path, encoding=encoding) as (source, dest):
  184:         replaced = False
  185:         missing_newline = False
  186:         for mapping in with_warn_for_invalid_lines(parse_stream(source)):
  187:             if mapping.key == key_to_set:
  188:                 dest.write(line_out)
  189:                 replaced = True
  190:             else:
  191:                 dest.write(mapping.original.string)
  192:                 missing_newline = not mapping.original.string.endswith("\n")
  193:         if not replaced:
  194:             if missing_newline:
  195:                 dest.write("\n")
  196:             dest.write(line_out)
  197: 
  198:     return True, key_to_set, value_to_set
  199: 
  200: 
  201: def unset_key(
  202:     dotenv_path: StrPath,
  203:     key_to_unset: str,
  204:     quote_mode: str = "always",
  205:     encoding: Optional[str] = "utf-8",
  206: ) -> Tuple[Optional[bool], str]:
  207:     """
  208:     Removes a given key from the given `.env` file.
  209: 
  210:     If the .env path given doesn't exist, fails.
  211:     If the given key doesn't exist in the .env, fails.
  212:     """
  213:     if not os.path.exists(dotenv_path):
  214:         logger.warning("Can't delete from %s - it doesn't exist.", dotenv_path)
  215:         return None, key_to_unset
  216: 
  217:     removed = False
  218:     with rewrite(dotenv_path, encoding=encoding) as (source, dest):
  219:         for mapping in with_warn_for_invalid_lines(parse_stream(source)):
  220:             if mapping.key == key_to_unset:
  221:                 removed = True
  222:             else:
  223:                 dest.write(mapping.original.string)
  224: 
  225:     if not removed:
  226:         logger.warning("Key %s not removed from %s - key doesn't exist.", key_to_unset, dotenv_path)
  227:         return None, key_to_unset
  228: 
  229:     return removed, key_to_unset
  230: 
  231: 
  232: def resolve_variables(
  233:     values: Iterable[Tuple[str, Optional[str]]],
  234:     override: bool,
  235: ) -> Mapping[str, Optional[str]]:
  236:     new_values: Dict[str, Optional[str]] = {}
  237: 
  238:     for (name, value) in values:
  239:         if value is None:
  240:             result = None
  241:         else:
  242:             atoms = parse_variables(value)
  243:             env: Dict[str, Optional[str]] = {}
  244:             if override:
  245:                 env.update(os.environ)  # type: ignore
  246:                 env.update(new_values)
  247:             else:
  248:                 env.update(new_values)
  249:                 env.update(os.environ)  # type: ignore
  250:             result = "".join(atom.resolve(env) for atom in atoms)
  251: 
  252:         new_values[name] = result
  253: 
  254:     return new_values
  255: 
  256: 
  257: def _walk_to_root(path: str) -> Iterator[str]:
  258:     """
  259:     Yield directories starting from the given directory up to the root
  260:     """
  261:     if not os.path.exists(path):
  262:         raise IOError('Starting path not found')
  263: 
  264:     if os.path.isfile(path):
  265:         path = os.path.dirname(path)
  266: 
  267:     last_dir = None
  268:     current_dir = os.path.abspath(path)
  269:     while last_dir != current_dir:
  270:         yield current_dir
  271:         parent_dir = os.path.abspath(os.path.join(current_dir, os.path.pardir))
  272:         last_dir, current_dir = current_dir, parent_dir
  273: 
  274: 
  275: def find_dotenv(
  276:     filename: str = '.env',
  277:     raise_error_if_not_found: bool = False,
  278:     usecwd: bool = False,
  279: ) -> str:
  280:     """
  281:     Search in increasingly higher folders for the given file
  282: 
  283:     Returns path to the file if found, or an empty string otherwise
  284:     """
  285: 
  286:     def _is_interactive():
  287:         """ Decide whether this is running in a REPL or IPython notebook """
  288:         try:
  289:             main = __import__('__main__', None, None, fromlist=['__file__'])
  290:         except ModuleNotFoundError:
  291:             return False
  292:         return not hasattr(main, '__file__')
  293: 
  294:     if usecwd or _is_interactive() or getattr(sys, 'frozen', False):
  295:         # Should work without __file__, e.g. in REPL or IPython notebook.
  296:         path = os.getcwd()
  297:     else:
  298:         # will work for .py files
  299:         frame = sys._getframe()
  300:         current_file = __file__
  301: 
  302:         while frame.f_code.co_filename == current_file or not os.path.exists(
  303:             frame.f_code.co_filename
  304:         ):
  305:             assert frame.f_back is not None
  306:             frame = frame.f_back
  307:         frame_filename = frame.f_code.co_filename
  308:         path = os.path.dirname(os.path.abspath(frame_filename))
  309: 
  310:     for dirname in _walk_to_root(path):
  311:         check_path = os.path.join(dirname, filename)
  312:         if os.path.isfile(check_path):
  313:             return check_path
  314: 
  315:     if raise_error_if_not_found:
  316:         raise IOError('File not found')
  317: 
  318:     return ''
  319: 
  320: 
  321: def load_dotenv(
  322:     dotenv_path: Optional[StrPath] = None,
  323:     stream: Optional[IO[str]] = None,
  324:     verbose: bool = False,
  325:     override: bool = False,
  326:     interpolate: bool = True,
  327:     encoding: Optional[str] = "utf-8",
  328: ) -> bool:
  329:     """Parse a .env file and then load all the variables found as environment variables.
  330: 
  331:     Parameters:
  332:         dotenv_path: Absolute or relative path to .env file.
  333:         stream: Text stream (such as `io.StringIO`) with .env content, used if
  334:             `dotenv_path` is `None`.
  335:         verbose: Whether to output a warning the .env file is missing.
  336:         override: Whether to override the system environment variables with the variables
  337:             from the `.env` file.
  338:         encoding: Encoding to be used to read the file.
  339:     Returns:
  340:         Bool: True if at least one environment variable is set else False
  341: 
  342:     If both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the
  343:     .env file.
  344:     """
  345:     if dotenv_path is None and stream is None:
  346:         dotenv_path = find_dotenv()
  347: 
  348:     dotenv = DotEnv(
  349:         dotenv_path=dotenv_path,
  350:         stream=stream,
  351:         verbose=verbose,
  352:         interpolate=interpolate,
  353:         override=override,
  354:         encoding=encoding,
  355:     )
  356:     return dotenv.set_as_environment_variables()
  357: 
  358: 
  359: def dotenv_values(
  360:     dotenv_path: Optional[StrPath] = None,
  361:     stream: Optional[IO[str]] = None,
  362:     verbose: bool = False,
  363:     interpolate: bool = True,
  364:     encoding: Optional[str] = "utf-8",
  365: ) -> Dict[str, Optional[str]]:
  366:     """
  367:     Parse a .env file and return its content as a dict.
  368: 
  369:     The returned dict will have `None` values for keys without values in the .env file.
  370:     For example, `foo=bar` results in `{"foo": "bar"}` whereas `foo` alone results in
  371:     `{"foo": None}`
  372: 
  373:     Parameters:
  374:         dotenv_path: Absolute or relative path to the .env file.
  375:         stream: `StringIO` object with .env content, used if `dotenv_path` is `None`.
  376:         verbose: Whether to output a warning if the .env file is missing.
  377:         encoding: Encoding to be used to read the file.
  378: 
  379:     If both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the
  380:     .env file.
  381:     """
  382:     if dotenv_path is None and stream is None:
  383:         dotenv_path = find_dotenv()
  384: 
  385:     return DotEnv(
  386:         dotenv_path=dotenv_path,
  387:         stream=stream,
  388:         verbose=verbose,
  389:         interpolate=interpolate,
  390:         override=True,
  391:         encoding=encoding,
  392:     ).dict()
