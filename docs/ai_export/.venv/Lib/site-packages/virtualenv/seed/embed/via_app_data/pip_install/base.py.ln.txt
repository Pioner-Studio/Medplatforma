    1: from __future__ import annotations
    2: 
    3: import logging
    4: import os
    5: import re
    6: import zipfile
    7: from abc import ABC, abstractmethod
    8: from configparser import ConfigParser
    9: from itertools import chain
   10: from pathlib import Path
   11: from tempfile import mkdtemp
   12: 
   13: from distlib.scripts import ScriptMaker, enquote_executable
   14: 
   15: from virtualenv.util.path import safe_delete
   16: 
   17: LOGGER = logging.getLogger(__name__)
   18: 
   19: 
   20: class PipInstall(ABC):
   21:     def __init__(self, wheel, creator, image_folder) -> None:
   22:         self._wheel = wheel
   23:         self._creator = creator
   24:         self._image_dir = image_folder
   25:         self._extracted = False
   26:         self.__dist_info = None
   27:         self._console_entry_points = None
   28: 
   29:     @abstractmethod
   30:     def _sync(self, src, dst):
   31:         raise NotImplementedError
   32: 
   33:     def install(self, version_info):
   34:         self._extracted = True
   35:         self._uninstall_previous_version()
   36:         # sync image
   37:         for filename in self._image_dir.iterdir():
   38:             into = self._creator.purelib / filename.name
   39:             self._sync(filename, into)
   40:         # generate console executables
   41:         consoles = set()
   42:         script_dir = self._creator.script_dir
   43:         for name, module in self._console_scripts.items():
   44:             consoles.update(self._create_console_entry_point(name, module, script_dir, version_info))
   45:         LOGGER.debug("generated console scripts %s", " ".join(i.name for i in consoles))
   46: 
   47:     def build_image(self):
   48:         # 1. first extract the wheel
   49:         LOGGER.debug("build install image for %s to %s", self._wheel.name, self._image_dir)
   50:         with zipfile.ZipFile(str(self._wheel)) as zip_ref:
   51:             self._shorten_path_if_needed(zip_ref)
   52:             zip_ref.extractall(str(self._image_dir))
   53:             self._extracted = True
   54:         # 2. now add additional files not present in the distribution
   55:         new_files = self._generate_new_files()
   56:         # 3. finally fix the records file
   57:         self._fix_records(new_files)
   58: 
   59:     def _shorten_path_if_needed(self, zip_ref):
   60:         if os.name == "nt":
   61:             to_folder = str(self._image_dir)
   62:             # https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation
   63:             zip_max_len = max(len(i) for i in zip_ref.namelist())
   64:             path_len = zip_max_len + len(to_folder)
   65:             if path_len > 260:  # noqa: PLR2004
   66:                 self._image_dir.mkdir(exist_ok=True)  # to get a short path must exist
   67: 
   68:                 from virtualenv.util.path import get_short_path_name  # noqa: PLC0415
   69: 
   70:                 to_folder = get_short_path_name(to_folder)
   71:                 self._image_dir = Path(to_folder)
   72: 
   73:     def _records_text(self, files):
   74:         return "\n".join(f"{os.path.relpath(str(rec), str(self._image_dir))},," for rec in files)
   75: 
   76:     def _generate_new_files(self):
   77:         new_files = set()
   78:         installer = self._dist_info / "INSTALLER"
   79:         installer.write_text("pip\n", encoding="utf-8")
   80:         new_files.add(installer)
   81:         # inject a no-op root element, as workaround for bug in https://github.com/pypa/pip/issues/7226
   82:         marker = self._image_dir / f"{self._dist_info.stem}.virtualenv"
   83:         marker.write_text("", encoding="utf-8")
   84:         new_files.add(marker)
   85:         folder = mkdtemp()
   86:         try:
   87:             to_folder = Path(folder)
   88:             rel = os.path.relpath(str(self._creator.script_dir), str(self._creator.purelib))
   89:             version_info = self._creator.interpreter.version_info
   90:             for name, module in self._console_scripts.items():
   91:                 new_files.update(
   92:                     Path(os.path.normpath(str(self._image_dir / rel / i.name)))
   93:                     for i in self._create_console_entry_point(name, module, to_folder, version_info)
   94:                 )
   95:         finally:
   96:             safe_delete(folder)
   97:         return new_files
   98: 
   99:     @property
  100:     def _dist_info(self):
  101:         if self._extracted is False:
  102:             return None  # pragma: no cover
  103:         if self.__dist_info is None:
  104:             files = []
  105:             for filename in self._image_dir.iterdir():
  106:                 files.append(filename.name)
  107:                 if filename.suffix == ".dist-info":
  108:                     self.__dist_info = filename
  109:                     break
  110:             else:
  111:                 msg = f"no .dist-info at {self._image_dir}, has {', '.join(files)}"
  112:                 raise RuntimeError(msg)  # pragma: no cover
  113:         return self.__dist_info
  114: 
  115:     @abstractmethod
  116:     def _fix_records(self, extra_record_data):
  117:         raise NotImplementedError
  118: 
  119:     @property
  120:     def _console_scripts(self):
  121:         if self._extracted is False:
  122:             return None  # pragma: no cover
  123:         if self._console_entry_points is None:
  124:             self._console_entry_points = {}
  125:             entry_points = self._dist_info / "entry_points.txt"
  126:             if entry_points.exists():
  127:                 parser = ConfigParser()
  128:                 with entry_points.open(encoding="utf-8") as file_handler:
  129:                     parser.read_file(file_handler)
  130:                 if "console_scripts" in parser.sections():
  131:                     for name, value in parser.items("console_scripts"):
  132:                         match = re.match(r"(.*?)-?\d\.?\d*", name)
  133:                         our_name = match.groups(1)[0] if match else name
  134:                         self._console_entry_points[our_name] = value
  135:         return self._console_entry_points
  136: 
  137:     def _create_console_entry_point(self, name, value, to_folder, version_info):
  138:         result = []
  139:         maker = ScriptMakerCustom(to_folder, version_info, self._creator.exe, name)
  140:         specification = f"{name} = {value}"
  141:         new_files = maker.make(specification)
  142:         result.extend(Path(i) for i in new_files)
  143:         return result
  144: 
  145:     def _uninstall_previous_version(self):
  146:         dist_name = self._dist_info.stem.split("-")[0]
  147:         in_folders = chain.from_iterable([i.iterdir() for i in (self._creator.purelib, self._creator.platlib)])
  148:         paths = (p for p in in_folders if p.stem.split("-")[0] == dist_name and p.suffix == ".dist-info" and p.is_dir())
  149:         existing_dist = next(paths, None)
  150:         if existing_dist is not None:
  151:             self._uninstall_dist(existing_dist)
  152: 
  153:     @staticmethod
  154:     def _uninstall_dist(dist):
  155:         dist_base = dist.parent
  156:         LOGGER.debug("uninstall existing distribution %s from %s", dist.stem, dist_base)
  157: 
  158:         top_txt = dist / "top_level.txt"  # add top level packages at folder level
  159:         paths = (
  160:             {dist.parent / i.strip() for i in top_txt.read_text(encoding="utf-8").splitlines()}
  161:             if top_txt.exists()
  162:             else set()
  163:         )
  164:         paths.add(dist)  # add the dist-info folder itself
  165: 
  166:         base_dirs, record = paths.copy(), dist / "RECORD"  # collect entries in record that we did not register yet
  167:         for name in (
  168:             (i.split(",")[0] for i in record.read_text(encoding="utf-8").splitlines()) if record.exists() else ()
  169:         ):
  170:             path = dist_base / name
  171:             if not any(p in base_dirs for p in path.parents):  # only add if not already added as a base dir
  172:                 paths.add(path)
  173: 
  174:         for path in sorted(paths):  # actually remove stuff in a stable order
  175:             if path.exists():
  176:                 if path.is_dir() and not path.is_symlink():
  177:                     safe_delete(path)
  178:                 else:
  179:                     path.unlink()
  180: 
  181:     def clear(self):
  182:         if self._image_dir.exists():
  183:             safe_delete(self._image_dir)
  184: 
  185:     def has_image(self):
  186:         return self._image_dir.exists() and any(self._image_dir.iterdir())
  187: 
  188: 
  189: class ScriptMakerCustom(ScriptMaker):
  190:     def __init__(self, target_dir, version_info, executable, name) -> None:
  191:         super().__init__(None, str(target_dir))
  192:         self.clobber = True  # overwrite
  193:         self.set_mode = True  # ensure they are executable
  194:         self.executable = enquote_executable(str(executable))
  195:         self.version_info = version_info.major, version_info.minor
  196:         self.variants = {"", "X", "X.Y"}
  197:         self._name = name
  198: 
  199:     def _write_script(self, names, shebang, script_bytes, filenames, ext):
  200:         names.add(f"{self._name}{self.version_info[0]}.{self.version_info[1]}")
  201:         super()._write_script(names, shebang, script_bytes, filenames, ext)
  202: 
  203: 
  204: __all__ = [
  205:     "PipInstall",
  206: ]
