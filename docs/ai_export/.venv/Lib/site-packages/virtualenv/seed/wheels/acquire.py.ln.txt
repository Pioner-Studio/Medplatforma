    1: """Bootstrap."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import logging
    6: import sys
    7: from operator import eq, lt
    8: from pathlib import Path
    9: from subprocess import PIPE, CalledProcessError, Popen
   10: 
   11: from .bundle import from_bundle
   12: from .periodic_update import add_wheel_to_update_log
   13: from .util import Version, Wheel, discover_wheels
   14: 
   15: LOGGER = logging.getLogger(__name__)
   16: 
   17: 
   18: def get_wheel(  # noqa: PLR0913
   19:     distribution,
   20:     version,
   21:     for_py_version,
   22:     search_dirs,
   23:     download,
   24:     app_data,
   25:     do_periodic_update,
   26:     env,
   27: ):
   28:     """Get a wheel with the given distribution-version-for_py_version trio, by using the extra search dir + download."""
   29:     # not all wheels are compatible with all python versions, so we need to py version qualify it
   30:     wheel = None
   31: 
   32:     if not download or version != Version.bundle:
   33:         # 1. acquire from bundle
   34:         wheel = from_bundle(distribution, version, for_py_version, search_dirs, app_data, do_periodic_update, env)
   35: 
   36:     if download and wheel is None and version != Version.embed:
   37:         # 2. download from the internet
   38:         wheel = download_wheel(
   39:             distribution=distribution,
   40:             version_spec=Version.as_version_spec(version),
   41:             for_py_version=for_py_version,
   42:             search_dirs=search_dirs,
   43:             app_data=app_data,
   44:             to_folder=app_data.house,
   45:             env=env,
   46:         )
   47:         if wheel is not None and app_data.can_update:
   48:             add_wheel_to_update_log(wheel, for_py_version, app_data)
   49: 
   50:     return wheel
   51: 
   52: 
   53: def download_wheel(distribution, version_spec, for_py_version, search_dirs, app_data, to_folder, env):  # noqa: PLR0913
   54:     to_download = f"{distribution}{version_spec or ''}"
   55:     LOGGER.debug("download wheel %s %s to %s", to_download, for_py_version, to_folder)
   56:     cmd = [
   57:         sys.executable,
   58:         "-m",
   59:         "pip",
   60:         "download",
   61:         "--progress-bar",
   62:         "off",
   63:         "--disable-pip-version-check",
   64:         "--only-binary=:all:",
   65:         "--no-deps",
   66:         "--python-version",
   67:         for_py_version,
   68:         "-d",
   69:         str(to_folder),
   70:         to_download,
   71:     ]
   72:     # pip has no interface in python - must be a new sub-process
   73:     env = pip_wheel_env_run(search_dirs, app_data, env)
   74:     process = Popen(cmd, env=env, stdout=PIPE, stderr=PIPE, universal_newlines=True, encoding="utf-8")
   75:     out, err = process.communicate()
   76:     if process.returncode != 0:
   77:         kwargs = {"output": out, "stderr": err}
   78:         raise CalledProcessError(process.returncode, cmd, **kwargs)
   79:     result = _find_downloaded_wheel(distribution, version_spec, for_py_version, to_folder, out)
   80:     LOGGER.debug("downloaded wheel %s", result.name)
   81:     return result
   82: 
   83: 
   84: def _find_downloaded_wheel(distribution, version_spec, for_py_version, to_folder, out):
   85:     for line in out.splitlines():
   86:         stripped_line = line.lstrip()
   87:         for marker in ("Saved ", "File was already downloaded "):
   88:             if stripped_line.startswith(marker):
   89:                 return Wheel(Path(stripped_line[len(marker) :]).absolute())
   90:     # if for some reason the output does not match fallback to the latest version with that spec
   91:     return find_compatible_in_house(distribution, version_spec, for_py_version, to_folder)
   92: 
   93: 
   94: def find_compatible_in_house(distribution, version_spec, for_py_version, in_folder):
   95:     wheels = discover_wheels(in_folder, distribution, None, for_py_version)
   96:     start, end = 0, len(wheels)
   97:     if version_spec is not None and version_spec:
   98:         if version_spec.startswith("<"):
   99:             from_pos, op = 1, lt
  100:         elif version_spec.startswith("=="):
  101:             from_pos, op = 2, eq
  102:         else:
  103:             raise ValueError(version_spec)
  104:         version = Wheel.as_version_tuple(version_spec[from_pos:])
  105:         start = next((at for at, w in enumerate(wheels) if op(w.version_tuple, version)), len(wheels))
  106: 
  107:     return None if start == end else wheels[start]
  108: 
  109: 
  110: def pip_wheel_env_run(search_dirs, app_data, env):
  111:     env = env.copy()
  112:     env.update({"PIP_USE_WHEEL": "1", "PIP_USER": "0", "PIP_NO_INPUT": "1", "PYTHONIOENCODING": "utf-8"})
  113:     wheel = get_wheel(
  114:         distribution="pip",
  115:         version=None,
  116:         for_py_version=f"{sys.version_info.major}.{sys.version_info.minor}",
  117:         search_dirs=search_dirs,
  118:         download=False,
  119:         app_data=app_data,
  120:         do_periodic_update=False,
  121:         env=env,
  122:     )
  123:     if wheel is None:
  124:         msg = "could not find the embedded pip"
  125:         raise RuntimeError(msg)
  126:     env["PYTHONPATH"] = str(wheel.path)
  127:     return env
  128: 
  129: 
  130: __all__ = [
  131:     "download_wheel",
  132:     "get_wheel",
  133:     "pip_wheel_env_run",
  134: ]
