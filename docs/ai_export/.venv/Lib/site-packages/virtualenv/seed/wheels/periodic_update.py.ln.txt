    1: """Periodically update bundled versions."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import json
    6: import logging
    7: import os
    8: import ssl
    9: import sys
   10: from datetime import datetime, timedelta, timezone
   11: from itertools import groupby
   12: from pathlib import Path
   13: from shutil import copy2
   14: from subprocess import DEVNULL, Popen
   15: from textwrap import dedent
   16: from threading import Thread
   17: from urllib.error import URLError
   18: from urllib.request import urlopen
   19: 
   20: from virtualenv.app_data import AppDataDiskFolder
   21: from virtualenv.seed.wheels.embed import BUNDLE_SUPPORT
   22: from virtualenv.seed.wheels.util import Wheel
   23: from virtualenv.util.subprocess import CREATE_NO_WINDOW
   24: 
   25: LOGGER = logging.getLogger(__name__)
   26: GRACE_PERIOD_CI = timedelta(hours=1)  # prevent version switch in the middle of a CI run
   27: GRACE_PERIOD_MINOR = timedelta(days=28)
   28: UPDATE_PERIOD = timedelta(days=14)
   29: UPDATE_ABORTED_DELAY = timedelta(hours=1)
   30: 
   31: 
   32: def periodic_update(  # noqa: PLR0913
   33:     distribution,
   34:     of_version,
   35:     for_py_version,
   36:     wheel,
   37:     search_dirs,
   38:     app_data,
   39:     do_periodic_update,
   40:     env,
   41: ):
   42:     if do_periodic_update:
   43:         handle_auto_update(distribution, for_py_version, wheel, search_dirs, app_data, env)
   44: 
   45:     now = datetime.now(tz=timezone.utc)
   46: 
   47:     def _update_wheel(ver):
   48:         updated_wheel = Wheel(app_data.house / ver.filename)
   49:         LOGGER.debug("using %supdated wheel %s", "periodically " if updated_wheel else "", updated_wheel)
   50:         return updated_wheel
   51: 
   52:     u_log = UpdateLog.from_app_data(app_data, distribution, for_py_version)
   53:     if of_version is None:
   54:         for _, group in groupby(u_log.versions, key=lambda v: v.wheel.version_tuple[0:2]):
   55:             # use only latest patch version per minor, earlier assumed to be buggy
   56:             all_patches = list(group)
   57:             ignore_grace_period_minor = any(version for version in all_patches if version.use(now))
   58:             for version in all_patches:
   59:                 if wheel is not None and Path(version.filename).name == wheel.name:
   60:                     return wheel
   61:                 if version.use(now, ignore_grace_period_minor):
   62:                     return _update_wheel(version)
   63:     else:
   64:         for version in u_log.versions:
   65:             if version.wheel.version == of_version:
   66:                 return _update_wheel(version)
   67: 
   68:     return wheel
   69: 
   70: 
   71: def handle_auto_update(distribution, for_py_version, wheel, search_dirs, app_data, env):  # noqa: PLR0913
   72:     embed_update_log = app_data.embed_update_log(distribution, for_py_version)
   73:     u_log = UpdateLog.from_dict(embed_update_log.read())
   74:     if u_log.needs_update:
   75:         u_log.periodic = True
   76:         u_log.started = datetime.now(tz=timezone.utc)
   77:         embed_update_log.write(u_log.to_dict())
   78:         trigger_update(distribution, for_py_version, wheel, search_dirs, app_data, periodic=True, env=env)
   79: 
   80: 
   81: def add_wheel_to_update_log(wheel, for_py_version, app_data):
   82:     embed_update_log = app_data.embed_update_log(wheel.distribution, for_py_version)
   83:     LOGGER.debug("adding %s information to %s", wheel.name, embed_update_log.file)
   84:     u_log = UpdateLog.from_dict(embed_update_log.read())
   85:     if any(version.filename == wheel.name for version in u_log.versions):
   86:         LOGGER.warning("%s already present in %s", wheel.name, embed_update_log.file)
   87:         return
   88:     # we don't need a release date for sources other than "periodic"
   89:     version = NewVersion(wheel.name, datetime.now(tz=timezone.utc), None, "download")
   90:     u_log.versions.append(version)  # always write at the end for proper updates
   91:     embed_update_log.write(u_log.to_dict())
   92: 
   93: 
   94: DATETIME_FMT = "%Y-%m-%dT%H:%M:%S.%fZ"
   95: 
   96: 
   97: def dump_datetime(value):
   98:     return None if value is None else value.strftime(DATETIME_FMT)
   99: 
  100: 
  101: def load_datetime(value):
  102:     return None if value is None else datetime.strptime(value, DATETIME_FMT).replace(tzinfo=timezone.utc)
  103: 
  104: 
  105: class NewVersion:  # noqa: PLW1641
  106:     def __init__(self, filename, found_date, release_date, source) -> None:
  107:         self.filename = filename
  108:         self.found_date = found_date
  109:         self.release_date = release_date
  110:         self.source = source
  111: 
  112:     @classmethod
  113:     def from_dict(cls, dictionary):
  114:         return cls(
  115:             filename=dictionary["filename"],
  116:             found_date=load_datetime(dictionary["found_date"]),
  117:             release_date=load_datetime(dictionary["release_date"]),
  118:             source=dictionary["source"],
  119:         )
  120: 
  121:     def to_dict(self):
  122:         return {
  123:             "filename": self.filename,
  124:             "release_date": dump_datetime(self.release_date),
  125:             "found_date": dump_datetime(self.found_date),
  126:             "source": self.source,
  127:         }
  128: 
  129:     def use(self, now, ignore_grace_period_minor=False, ignore_grace_period_ci=False):  # noqa: FBT002
  130:         if self.source == "manual":
  131:             return True
  132:         if self.source == "periodic" and (self.found_date < now - GRACE_PERIOD_CI or ignore_grace_period_ci):
  133:             if not ignore_grace_period_minor:
  134:                 compare_from = self.release_date or self.found_date
  135:                 return now - compare_from >= GRACE_PERIOD_MINOR
  136:             return True
  137:         return False
  138: 
  139:     def __repr__(self) -> str:
  140:         return (
  141:             f"{self.__class__.__name__}(filename={self.filename}), found_date={self.found_date}, "
  142:             f"release_date={self.release_date}, source={self.source})"
  143:         )
  144: 
  145:     def __eq__(self, other):
  146:         return type(self) == type(other) and all(  # noqa: E721
  147:             getattr(self, k) == getattr(other, k) for k in ["filename", "release_date", "found_date", "source"]
  148:         )
  149: 
  150:     def __ne__(self, other):
  151:         return not (self == other)
  152: 
  153:     @property
  154:     def wheel(self):
  155:         return Wheel(Path(self.filename))
  156: 
  157: 
  158: class UpdateLog:
  159:     def __init__(self, started, completed, versions, periodic) -> None:
  160:         self.started = started
  161:         self.completed = completed
  162:         self.versions = versions
  163:         self.periodic = periodic
  164: 
  165:     @classmethod
  166:     def from_dict(cls, dictionary):
  167:         if dictionary is None:
  168:             dictionary = {}
  169:         return cls(
  170:             load_datetime(dictionary.get("started")),
  171:             load_datetime(dictionary.get("completed")),
  172:             [NewVersion.from_dict(v) for v in dictionary.get("versions", [])],
  173:             dictionary.get("periodic"),
  174:         )
  175: 
  176:     @classmethod
  177:     def from_app_data(cls, app_data, distribution, for_py_version):
  178:         raw_json = app_data.embed_update_log(distribution, for_py_version).read()
  179:         return cls.from_dict(raw_json)
  180: 
  181:     def to_dict(self):
  182:         return {
  183:             "started": dump_datetime(self.started),
  184:             "completed": dump_datetime(self.completed),
  185:             "periodic": self.periodic,
  186:             "versions": [r.to_dict() for r in self.versions],
  187:         }
  188: 
  189:     @property
  190:     def needs_update(self):
  191:         now = datetime.now(tz=timezone.utc)
  192:         if self.completed is None:  # never completed
  193:             return self._check_start(now)
  194:         if now - self.completed <= UPDATE_PERIOD:
  195:             return False
  196:         return self._check_start(now)
  197: 
  198:     def _check_start(self, now):
  199:         return self.started is None or now - self.started > UPDATE_ABORTED_DELAY
  200: 
  201: 
  202: def trigger_update(distribution, for_py_version, wheel, search_dirs, app_data, env, periodic):  # noqa: PLR0913
  203:     wheel_path = None if wheel is None else str(wheel.path)
  204:     cmd = [
  205:         sys.executable,
  206:         "-c",
  207:         dedent(
  208:             """
  209:         from virtualenv.report import setup_report, MAX_LEVEL
  210:         from virtualenv.seed.wheels.periodic_update import do_update
  211:         setup_report(MAX_LEVEL, show_pid=True)
  212:         do_update({!r}, {!r}, {!r}, {!r}, {!r}, {!r})
  213:         """,
  214:         )
  215:         .strip()
  216:         .format(distribution, for_py_version, wheel_path, str(app_data), [str(p) for p in search_dirs], periodic),
  217:     ]
  218:     debug = env.get("_VIRTUALENV_PERIODIC_UPDATE_INLINE") == "1"
  219:     pipe = None if debug else DEVNULL
  220:     kwargs = {"stdout": pipe, "stderr": pipe}
  221:     if not debug and sys.platform == "win32":
  222:         kwargs["creationflags"] = CREATE_NO_WINDOW
  223:     process = Popen(cmd, **kwargs)
  224:     LOGGER.info(
  225:         "triggered periodic upgrade of %s%s (for python %s) via background process having PID %d",
  226:         distribution,
  227:         "" if wheel is None else f"=={wheel.version}",
  228:         for_py_version,
  229:         process.pid,
  230:     )
  231:     if debug:
  232:         process.communicate()  # on purpose not called to make it a background process
  233:     else:
  234:         # set the returncode here -> no ResourceWarning on main process exit if the subprocess still runs
  235:         process.returncode = 0
  236: 
  237: 
  238: def do_update(distribution, for_py_version, embed_filename, app_data, search_dirs, periodic):  # noqa: PLR0913
  239:     versions = None
  240:     try:
  241:         versions = _run_do_update(app_data, distribution, embed_filename, for_py_version, periodic, search_dirs)
  242:     finally:
  243:         LOGGER.debug("done %s %s with %s", distribution, for_py_version, versions)
  244:     return versions
  245: 
  246: 
  247: def _run_do_update(  # noqa: C901, PLR0913
  248:     app_data,
  249:     distribution,
  250:     embed_filename,
  251:     for_py_version,
  252:     periodic,
  253:     search_dirs,
  254: ):
  255:     from virtualenv.seed.wheels import acquire  # noqa: PLC0415
  256: 
  257:     wheel_filename = None if embed_filename is None else Path(embed_filename)
  258:     embed_version = None if wheel_filename is None else Wheel(wheel_filename).version_tuple
  259:     app_data = AppDataDiskFolder(app_data) if isinstance(app_data, str) else app_data
  260:     search_dirs = [Path(p) if isinstance(p, str) else p for p in search_dirs]
  261:     wheelhouse = app_data.house
  262:     embed_update_log = app_data.embed_update_log(distribution, for_py_version)
  263:     u_log = UpdateLog.from_dict(embed_update_log.read())
  264:     now = datetime.now(tz=timezone.utc)
  265: 
  266:     update_versions, other_versions = [], []
  267:     for version in u_log.versions:
  268:         if version.source in {"periodic", "manual"}:
  269:             update_versions.append(version)
  270:         else:
  271:             other_versions.append(version)
  272: 
  273:     if periodic:
  274:         source = "periodic"
  275:     else:
  276:         source = "manual"
  277:         # mark the most recent one as source "manual"
  278:         if update_versions:
  279:             update_versions[0].source = source
  280: 
  281:     if wheel_filename is not None:
  282:         dest = wheelhouse / wheel_filename.name
  283:         if not dest.exists():
  284:             copy2(str(wheel_filename), str(wheelhouse))
  285:     last, last_version, versions, filenames = None, None, [], set()
  286:     while last is None or not last.use(now, ignore_grace_period_ci=True):
  287:         download_time = datetime.now(tz=timezone.utc)
  288:         dest = acquire.download_wheel(
  289:             distribution=distribution,
  290:             version_spec=None if last_version is None else f"<{last_version}",
  291:             for_py_version=for_py_version,
  292:             search_dirs=search_dirs,
  293:             app_data=app_data,
  294:             to_folder=wheelhouse,
  295:             env=os.environ,
  296:         )
  297:         if dest is None or (update_versions and update_versions[0].filename == dest.name):
  298:             break
  299:         release_date = release_date_for_wheel_path(dest.path)
  300:         last = NewVersion(filename=dest.path.name, release_date=release_date, found_date=download_time, source=source)
  301:         LOGGER.info("detected %s in %s", last, datetime.now(tz=timezone.utc) - download_time)
  302:         versions.append(last)
  303:         filenames.add(last.filename)
  304:         last_wheel = last.wheel
  305:         last_version = last_wheel.version
  306:         if embed_version is not None and embed_version >= last_wheel.version_tuple:
  307:             break  # stop download if we reach the embed version
  308:     u_log.periodic = periodic
  309:     if not u_log.periodic:
  310:         u_log.started = now
  311:     # update other_versions by removing version we just found
  312:     other_versions = [version for version in other_versions if version.filename not in filenames]
  313:     u_log.versions = versions + update_versions + other_versions
  314:     u_log.completed = datetime.now(tz=timezone.utc)
  315:     embed_update_log.write(u_log.to_dict())
  316:     return versions
  317: 
  318: 
  319: def release_date_for_wheel_path(dest):
  320:     wheel = Wheel(dest)
  321:     # the most accurate is to ask PyPi - e.g. https://pypi.org/pypi/pip/json,
  322:     # see https://warehouse.pypa.io/api-reference/json/ for more details
  323:     content = _pypi_get_distribution_info_cached(wheel.distribution)
  324:     if content is not None:
  325:         try:
  326:             upload_time = content["releases"][wheel.version][0]["upload_time"]
  327:             return datetime.strptime(upload_time, "%Y-%m-%dT%H:%M:%S").replace(tzinfo=timezone.utc)
  328:         except Exception as exception:  # noqa: BLE001
  329:             LOGGER.error("could not load release date %s because %r", content, exception)  # noqa: TRY400
  330:     return None
  331: 
  332: 
  333: def _request_context():
  334:     yield None
  335:     # fallback to non verified HTTPS (the information we request is not sensitive, so fallback)
  336:     yield ssl._create_unverified_context()  # noqa: S323, SLF001
  337: 
  338: 
  339: _PYPI_CACHE = {}
  340: 
  341: 
  342: def _pypi_get_distribution_info_cached(distribution):
  343:     if distribution not in _PYPI_CACHE:
  344:         _PYPI_CACHE[distribution] = _pypi_get_distribution_info(distribution)
  345:     return _PYPI_CACHE[distribution]
  346: 
  347: 
  348: def _pypi_get_distribution_info(distribution):
  349:     content, url = None, f"https://pypi.org/pypi/{distribution}/json"
  350:     try:
  351:         for context in _request_context():
  352:             try:
  353:                 with urlopen(url, context=context) as file_handler:  # noqa: S310
  354:                     content = json.load(file_handler)
  355:                 break
  356:             except URLError as exception:
  357:                 LOGGER.error("failed to access %s because %r", url, exception)  # noqa: TRY400
  358:     except Exception as exception:  # noqa: BLE001
  359:         LOGGER.error("failed to access %s because %r", url, exception)  # noqa: TRY400
  360:     return content
  361: 
  362: 
  363: def manual_upgrade(app_data, env):
  364:     threads = []
  365: 
  366:     for for_py_version, distribution_to_package in BUNDLE_SUPPORT.items():
  367:         # load extra search dir for the given for_py
  368:         for distribution in distribution_to_package:
  369:             thread = Thread(target=_run_manual_upgrade, args=(app_data, distribution, for_py_version, env))
  370:             thread.start()
  371:             threads.append(thread)
  372: 
  373:     for thread in threads:
  374:         thread.join()
  375: 
  376: 
  377: def _run_manual_upgrade(app_data, distribution, for_py_version, env):
  378:     start = datetime.now(tz=timezone.utc)
  379:     from .bundle import from_bundle  # noqa: PLC0415
  380: 
  381:     current = from_bundle(
  382:         distribution=distribution,
  383:         version=None,
  384:         for_py_version=for_py_version,
  385:         search_dirs=[],
  386:         app_data=app_data,
  387:         do_periodic_update=False,
  388:         env=env,
  389:     )
  390:     LOGGER.warning(
  391:         "upgrade %s for python %s with current %s",
  392:         distribution,
  393:         for_py_version,
  394:         "" if current is None else current.name,
  395:     )
  396:     versions = do_update(
  397:         distribution=distribution,
  398:         for_py_version=for_py_version,
  399:         embed_filename=current.path,
  400:         app_data=app_data,
  401:         search_dirs=[],
  402:         periodic=False,
  403:     )
  404: 
  405:     args = [
  406:         distribution,
  407:         for_py_version,
  408:         datetime.now(tz=timezone.utc) - start,
  409:     ]
  410:     if versions:
  411:         args.append("\n".join(f"\t{v}" for v in versions))
  412:     ver_update = "new entries found:\n%s" if versions else "no new versions found"
  413:     msg = f"upgraded %s for python %s in %s {ver_update}"
  414:     LOGGER.warning(msg, *args)
  415: 
  416: 
  417: __all__ = [
  418:     "NewVersion",
  419:     "UpdateLog",
  420:     "add_wheel_to_update_log",
  421:     "do_update",
  422:     "dump_datetime",
  423:     "load_datetime",
  424:     "manual_upgrade",
  425:     "periodic_update",
  426:     "release_date_for_wheel_path",
  427:     "trigger_update",
  428: ]
