    1: from __future__ import annotations
    2: 
    3: from operator import attrgetter
    4: from zipfile import ZipFile
    5: 
    6: 
    7: class Wheel:
    8:     def __init__(self, path) -> None:
    9:         # https://www.python.org/dev/peps/pep-0427/#file-name-convention
   10:         # The wheel filename is {distribution}-{version}(-{build tag})?-{python tag}-{abi tag}-{platform tag}.whl
   11:         self.path = path
   12:         self._parts = path.stem.split("-")
   13: 
   14:     @classmethod
   15:     def from_path(cls, path):
   16:         if path is not None and path.suffix == ".whl" and len(path.stem.split("-")) >= 5:  # noqa: PLR2004
   17:             return cls(path)
   18:         return None
   19: 
   20:     @property
   21:     def distribution(self):
   22:         return self._parts[0]
   23: 
   24:     @property
   25:     def version(self):
   26:         return self._parts[1]
   27: 
   28:     @property
   29:     def version_tuple(self):
   30:         return self.as_version_tuple(self.version)
   31: 
   32:     @staticmethod
   33:     def as_version_tuple(version):
   34:         result = []
   35:         for part in version.split(".")[0:3]:
   36:             try:
   37:                 result.append(int(part))
   38:             except ValueError:  # noqa: PERF203
   39:                 break
   40:         if not result:
   41:             raise ValueError(version)
   42:         return tuple(result)
   43: 
   44:     @property
   45:     def name(self):
   46:         return self.path.name
   47: 
   48:     def support_py(self, py_version):
   49:         name = f"{'-'.join(self.path.stem.split('-')[0:2])}.dist-info/METADATA"
   50:         with ZipFile(str(self.path), "r") as zip_file:
   51:             metadata = zip_file.read(name).decode("utf-8")
   52:         marker = "Requires-Python:"
   53:         requires = next((i[len(marker) :] for i in metadata.splitlines() if i.startswith(marker)), None)
   54:         if requires is None:  # if it does not specify a python requires the assumption is compatible
   55:             return True
   56:         py_version_int = tuple(int(i) for i in py_version.split("."))
   57:         for require in (i.strip() for i in requires.split(",")):
   58:             # https://www.python.org/dev/peps/pep-0345/#version-specifiers
   59:             for operator, check in [
   60:                 ("!=", lambda v: py_version_int != v),
   61:                 ("==", lambda v: py_version_int == v),
   62:                 ("<=", lambda v: py_version_int <= v),
   63:                 (">=", lambda v: py_version_int >= v),
   64:                 ("<", lambda v: py_version_int < v),
   65:                 (">", lambda v: py_version_int > v),
   66:             ]:
   67:                 if require.startswith(operator):
   68:                     ver_str = require[len(operator) :].strip()
   69:                     version = tuple((int(i) if i != "*" else None) for i in ver_str.split("."))[0:2]
   70:                     if not check(version):
   71:                         return False
   72:                     break
   73:         return True
   74: 
   75:     def __repr__(self) -> str:
   76:         return f"{self.__class__.__name__}({self.path})"
   77: 
   78:     def __str__(self) -> str:
   79:         return str(self.path)
   80: 
   81: 
   82: def discover_wheels(from_folder, distribution, version, for_py_version):
   83:     wheels = []
   84:     for filename in from_folder.iterdir():
   85:         wheel = Wheel.from_path(filename)
   86:         if (
   87:             wheel
   88:             and wheel.distribution == distribution
   89:             and (version is None or wheel.version == version)
   90:             and wheel.support_py(for_py_version)
   91:         ):
   92:             wheels.append(wheel)
   93:     return sorted(wheels, key=attrgetter("version_tuple", "distribution"), reverse=True)
   94: 
   95: 
   96: class Version:
   97:     #: the version bundled with virtualenv
   98:     bundle = "bundle"
   99:     embed = "embed"
  100:     #: custom version handlers
  101:     non_version = (bundle, embed)
  102: 
  103:     @staticmethod
  104:     def of_version(value):
  105:         return None if value in Version.non_version else value
  106: 
  107:     @staticmethod
  108:     def as_pip_req(distribution, version):
  109:         return f"{distribution}{Version.as_version_spec(version)}"
  110: 
  111:     @staticmethod
  112:     def as_version_spec(version):
  113:         of_version = Version.of_version(version)
  114:         return "" if of_version is None else f"=={of_version}"
  115: 
  116: 
  117: __all__ = [
  118:     "Version",
  119:     "Wheel",
  120:     "discover_wheels",
  121: ]
