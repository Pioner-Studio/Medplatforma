    1: from __future__ import annotations
    2: 
    3: import json
    4: import logging
    5: import os
    6: import sys
    7: import textwrap
    8: from abc import ABC, abstractmethod
    9: from argparse import ArgumentTypeError
   10: from ast import literal_eval
   11: from collections import OrderedDict
   12: from pathlib import Path
   13: 
   14: from virtualenv.discovery.cached_py_info import LogCmd
   15: from virtualenv.util.path import safe_delete
   16: from virtualenv.util.subprocess import run_cmd
   17: from virtualenv.version import __version__
   18: 
   19: from .pyenv_cfg import PyEnvCfg
   20: 
   21: HERE = Path(os.path.abspath(__file__)).parent
   22: DEBUG_SCRIPT = HERE / "debug.py"
   23: LOGGER = logging.getLogger(__name__)
   24: 
   25: 
   26: class CreatorMeta:
   27:     def __init__(self) -> None:
   28:         self.error = None
   29: 
   30: 
   31: class Creator(ABC):
   32:     """A class that given a python Interpreter creates a virtual environment."""
   33: 
   34:     def __init__(self, options, interpreter) -> None:
   35:         """
   36:         Construct a new virtual environment creator.
   37: 
   38:         :param options: the CLI option as parsed from :meth:`add_parser_arguments`
   39:         :param interpreter: the interpreter to create virtual environment from
   40:         """
   41:         self.interpreter = interpreter
   42:         self._debug = None
   43:         self.dest = Path(options.dest)
   44:         self.clear = options.clear
   45:         self.no_vcs_ignore = options.no_vcs_ignore
   46:         self.pyenv_cfg = PyEnvCfg.from_folder(self.dest)
   47:         self.app_data = options.app_data
   48:         self.env = options.env
   49: 
   50:     def __repr__(self) -> str:
   51:         return f"{self.__class__.__name__}({', '.join(f'{k}={v}' for k, v in self._args())})"
   52: 
   53:     def _args(self):
   54:         return [
   55:             ("dest", str(self.dest)),
   56:             ("clear", self.clear),
   57:             ("no_vcs_ignore", self.no_vcs_ignore),
   58:         ]
   59: 
   60:     @classmethod
   61:     def can_create(cls, interpreter):  # noqa: ARG003
   62:         """
   63:         Determine if we can create a virtual environment.
   64: 
   65:         :param interpreter: the interpreter in question
   66:         :return: ``None`` if we can't create, any other object otherwise that will be forwarded to \
   67:                   :meth:`add_parser_arguments`
   68:         """
   69:         return True
   70: 
   71:     @classmethod
   72:     def add_parser_arguments(cls, parser, interpreter, meta, app_data):  # noqa: ARG003
   73:         """
   74:         Add CLI arguments for the creator.
   75: 
   76:         :param parser: the CLI parser
   77:         :param app_data: the application data folder
   78:         :param interpreter: the interpreter we're asked to create virtual environment for
   79:         :param meta: value as returned by :meth:`can_create`
   80:         """
   81:         parser.add_argument(
   82:             "dest",
   83:             help="directory to create virtualenv at",
   84:             type=cls.validate_dest,
   85:         )
   86:         parser.add_argument(
   87:             "--clear",
   88:             dest="clear",
   89:             action="store_true",
   90:             help="remove the destination directory if exist before starting (will overwrite files otherwise)",
   91:             default=False,
   92:         )
   93:         parser.add_argument(
   94:             "--no-vcs-ignore",
   95:             dest="no_vcs_ignore",
   96:             action="store_true",
   97:             help="don't create VCS ignore directive in the destination directory",
   98:             default=False,
   99:         )
  100: 
  101:     @abstractmethod
  102:     def create(self):
  103:         """Perform the virtual environment creation."""
  104:         raise NotImplementedError
  105: 
  106:     @classmethod
  107:     def validate_dest(cls, raw_value):  # noqa: C901
  108:         """No path separator in the path, valid chars and must be write-able."""
  109: 
  110:         def non_write_able(dest, value):
  111:             common = Path(*os.path.commonprefix([value.parts, dest.parts]))
  112:             msg = f"the destination {dest.relative_to(common)} is not write-able at {common}"
  113:             raise ArgumentTypeError(msg)
  114: 
  115:         # the file system must be able to encode
  116:         # note in newer CPython this is always utf-8 https://www.python.org/dev/peps/pep-0529/
  117:         encoding = sys.getfilesystemencoding()
  118:         refused = OrderedDict()
  119:         kwargs = {"errors": "ignore"} if encoding != "mbcs" else {}
  120:         for char in str(raw_value):
  121:             try:
  122:                 trip = char.encode(encoding, **kwargs).decode(encoding)
  123:                 if trip == char:
  124:                     continue
  125:                 raise ValueError(trip)  # noqa: TRY301
  126:             except ValueError:
  127:                 refused[char] = None
  128:         if refused:
  129:             bad = "".join(refused.keys())
  130:             msg = f"the file system codec ({encoding}) cannot handle characters {bad!r} within {raw_value!r}"
  131:             raise ArgumentTypeError(msg)
  132:         if os.pathsep in raw_value:
  133:             msg = (
  134:                 f"destination {raw_value!r} must not contain the path separator ({os.pathsep})"
  135:                 f" as this would break the activation scripts"
  136:             )
  137:             raise ArgumentTypeError(msg)
  138: 
  139:         value = Path(raw_value)
  140:         if value.exists() and value.is_file():
  141:             msg = f"the destination {value} already exists and is a file"
  142:             raise ArgumentTypeError(msg)
  143:         dest = Path(os.path.abspath(str(value))).resolve()  # on Windows absolute does not imply resolve so use both
  144:         value = dest
  145:         while dest:
  146:             if dest.exists():
  147:                 if os.access(str(dest), os.W_OK):
  148:                     break
  149:                 non_write_able(dest, value)
  150:             base, _ = dest.parent, dest.name
  151:             if base == dest:
  152:                 non_write_able(dest, value)  # pragma: no cover
  153:             dest = base
  154:         return str(value)
  155: 
  156:     def run(self):
  157:         if self.dest.exists() and self.clear:
  158:             LOGGER.debug("delete %s", self.dest)
  159:             safe_delete(self.dest)
  160:         self.create()
  161:         self.add_cachedir_tag()
  162:         self.set_pyenv_cfg()
  163:         if not self.no_vcs_ignore:
  164:             self.setup_ignore_vcs()
  165: 
  166:     def add_cachedir_tag(self):
  167:         """Generate a file indicating that this is not meant to be backed up."""
  168:         cachedir_tag_file = self.dest / "CACHEDIR.TAG"
  169:         if not cachedir_tag_file.exists():
  170:             cachedir_tag_text = textwrap.dedent("""
  171:                 Signature: 8a477f597d28d172789f06886806bc55
  172:                 # This file is a cache directory tag created by Python virtualenv.
  173:                 # For information about cache directory tags, see:
  174:                 #   https://bford.info/cachedir/
  175:             """).strip()
  176:             cachedir_tag_file.write_text(cachedir_tag_text, encoding="utf-8")
  177: 
  178:     def set_pyenv_cfg(self):
  179:         self.pyenv_cfg.content = OrderedDict()
  180:         self.pyenv_cfg["home"] = os.path.dirname(os.path.abspath(self.interpreter.system_executable))
  181:         self.pyenv_cfg["implementation"] = self.interpreter.implementation
  182:         self.pyenv_cfg["version_info"] = ".".join(str(i) for i in self.interpreter.version_info)
  183:         self.pyenv_cfg["virtualenv"] = __version__
  184: 
  185:     def setup_ignore_vcs(self):
  186:         """Generate ignore instructions for version control systems."""
  187:         # mark this folder to be ignored by VCS, handle https://www.python.org/dev/peps/pep-0610/#registered-vcs
  188:         git_ignore = self.dest / ".gitignore"
  189:         if not git_ignore.exists():
  190:             git_ignore.write_text("# created by virtualenv automatically\n*\n", encoding="utf-8")
  191:         # Mercurial - does not support the .hgignore file inside a subdirectory directly, but only if included via the
  192:         # subinclude directive from root, at which point on might as well ignore the directory itself, see
  193:         # https://www.selenic.com/mercurial/hgignore.5.html for more details
  194:         # Bazaar - does not support ignore files in sub-directories, only at root level via .bzrignore
  195:         # Subversion - does not support ignore files, requires direct manipulation with the svn tool
  196: 
  197:     @property
  198:     def debug(self):
  199:         """:return: debug information about the virtual environment (only valid after :meth:`create` has run)"""
  200:         if self._debug is None and self.exe is not None:
  201:             self._debug = get_env_debug_info(self.exe, self.debug_script(), self.app_data, self.env)
  202:         return self._debug
  203: 
  204:     @staticmethod
  205:     def debug_script():
  206:         return DEBUG_SCRIPT
  207: 
  208: 
  209: def get_env_debug_info(env_exe, debug_script, app_data, env):
  210:     env = env.copy()
  211:     env.pop("PYTHONPATH", None)
  212: 
  213:     with app_data.ensure_extracted(debug_script) as debug_script_extracted:
  214:         cmd = [str(env_exe), str(debug_script_extracted)]
  215:         LOGGER.debug("debug via %r", LogCmd(cmd))
  216:         code, out, err = run_cmd(cmd)
  217: 
  218:     try:
  219:         if code != 0:
  220:             if out:
  221:                 result = literal_eval(out)
  222:             else:
  223:                 if code == 2 and "file" in err:  # noqa: PLR2004
  224:                     # Re-raise FileNotFoundError from `run_cmd()`
  225:                     raise OSError(err)  # noqa: TRY301
  226:                 raise Exception(err)  # noqa: TRY002, TRY301
  227:         else:
  228:             result = json.loads(out)
  229:         if err:
  230:             result["err"] = err
  231:     except Exception as exception:  # noqa: BLE001
  232:         return {"out": out, "err": err, "returncode": code, "exception": repr(exception)}
  233:     if "sys" in result and "path" in result["sys"]:
  234:         del result["sys"]["path"][0]
  235:     return result
  236: 
  237: 
  238: __all__ = [
  239:     "Creator",
  240:     "CreatorMeta",
  241: ]
