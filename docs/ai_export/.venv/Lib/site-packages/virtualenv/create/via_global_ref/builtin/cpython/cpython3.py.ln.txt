    1: from __future__ import annotations
    2: 
    3: import abc
    4: import fnmatch
    5: from itertools import chain
    6: from operator import methodcaller as method
    7: from pathlib import Path
    8: from textwrap import dedent
    9: 
   10: from virtualenv.create.describe import Python3Supports
   11: from virtualenv.create.via_global_ref.builtin.ref import ExePathRefToDest, PathRefToDest
   12: from virtualenv.create.via_global_ref.store import is_store_python
   13: 
   14: from .common import CPython, CPythonPosix, CPythonWindows, is_mac_os_framework, is_macos_brew
   15: 
   16: 
   17: class CPython3(CPython, Python3Supports, abc.ABC):
   18:     """CPython 3 or later."""
   19: 
   20: 
   21: class CPython3Posix(CPythonPosix, CPython3):
   22:     @classmethod
   23:     def can_describe(cls, interpreter):
   24:         return (
   25:             is_mac_os_framework(interpreter) is False
   26:             and is_macos_brew(interpreter) is False
   27:             and super().can_describe(interpreter)
   28:         )
   29: 
   30:     def env_patch_text(self):
   31:         text = super().env_patch_text()
   32:         if self.pyvenv_launch_patch_active(self.interpreter):
   33:             text += dedent(
   34:                 """
   35:                 # for https://github.com/python/cpython/pull/9516, see https://github.com/pypa/virtualenv/issues/1704
   36:                 import os
   37:                 if "__PYVENV_LAUNCHER__" in os.environ:
   38:                     del os.environ["__PYVENV_LAUNCHER__"]
   39:                 """,
   40:             )
   41:         return text
   42: 
   43:     @classmethod
   44:     def pyvenv_launch_patch_active(cls, interpreter):
   45:         ver = interpreter.version_info
   46:         return interpreter.platform == "darwin" and ((3, 7, 8) > ver >= (3, 7) or (3, 8, 3) > ver >= (3, 8))
   47: 
   48: 
   49: class CPython3Windows(CPythonWindows, CPython3):
   50:     """CPython 3 on Windows."""
   51: 
   52:     @classmethod
   53:     def setup_meta(cls, interpreter):
   54:         if is_store_python(interpreter):  # store python is not supported here
   55:             return None
   56:         return super().setup_meta(interpreter)
   57: 
   58:     @classmethod
   59:     def sources(cls, interpreter):
   60:         if cls.has_shim(interpreter):
   61:             refs = cls.executables(interpreter)
   62:         else:
   63:             refs = chain(
   64:                 cls.executables(interpreter),
   65:                 cls.dll_and_pyd(interpreter),
   66:                 cls.python_zip(interpreter),
   67:             )
   68:         yield from refs
   69: 
   70:     @classmethod
   71:     def executables(cls, interpreter):
   72:         sources = super().sources(interpreter)
   73:         if interpreter.version_info >= (3, 13):
   74:             # Create new refs with corrected launcher paths
   75:             updated_sources = []
   76:             for ref in sources:
   77:                 if ref.src.name == "python.exe":
   78:                     launcher_path = ref.src.with_name("venvlauncher.exe")
   79:                     if launcher_path.exists():
   80:                         new_ref = ExePathRefToDest(
   81:                             launcher_path, dest=ref.dest, targets=[ref.base, *ref.aliases], must=ref.must, when=ref.when
   82:                         )
   83:                         updated_sources.append(new_ref)
   84:                         continue
   85:                 elif ref.src.name == "pythonw.exe":
   86:                     w_launcher_path = ref.src.with_name("venvwlauncher.exe")
   87:                     if w_launcher_path.exists():
   88:                         new_ref = ExePathRefToDest(
   89:                             w_launcher_path,
   90:                             dest=ref.dest,
   91:                             targets=[ref.base, *ref.aliases],
   92:                             must=ref.must,
   93:                             when=ref.when,
   94:                         )
   95:                         updated_sources.append(new_ref)
   96:                         continue
   97:                 # Keep the original ref unchanged
   98:                 updated_sources.append(ref)
   99:             return updated_sources
  100:         return sources
  101: 
  102:     @classmethod
  103:     def has_shim(cls, interpreter):
  104:         return interpreter.version_info.minor >= 7 and cls.shim(interpreter) is not None  # noqa: PLR2004
  105: 
  106:     @classmethod
  107:     def shim(cls, interpreter):
  108:         root = Path(interpreter.system_stdlib) / "venv" / "scripts" / "nt"
  109:         # Before 3.13 the launcher was called python.exe, after is venvlauncher.exe
  110:         # https://github.com/python/cpython/issues/112984
  111:         exe_name = "venvlauncher.exe" if interpreter.version_info >= (3, 13) else "python.exe"
  112:         shim = root / exe_name
  113:         if shim.exists():
  114:             return shim
  115:         return None
  116: 
  117:     @classmethod
  118:     def host_python(cls, interpreter):
  119:         if cls.has_shim(interpreter):
  120:             # starting with CPython 3.7 Windows ships with a venvlauncher.exe that avoids the need for dll/pyd copies
  121:             # it also means the wrapper must be copied to avoid bugs such as https://bugs.python.org/issue42013
  122:             return cls.shim(interpreter)
  123:         return super().host_python(interpreter)
  124: 
  125:     @classmethod
  126:     def dll_and_pyd(cls, interpreter):
  127:         folders = [Path(interpreter.system_executable).parent]
  128: 
  129:         # May be missing on some Python hosts.
  130:         # See https://github.com/pypa/virtualenv/issues/2368
  131:         dll_folder = Path(interpreter.system_prefix) / "DLLs"
  132:         if dll_folder.is_dir():
  133:             folders.append(dll_folder)
  134: 
  135:         for folder in folders:
  136:             for file in folder.iterdir():
  137:                 if file.suffix in {".pyd", ".dll"}:
  138:                     yield PathRefToDest(file, cls.to_bin)
  139: 
  140:     @classmethod
  141:     def python_zip(cls, interpreter):
  142:         """
  143:         "python{VERSION}.zip" contains compiled *.pyc std lib packages, where
  144:         "VERSION" is `py_version_nodot` var from the `sysconfig` module.
  145:         :see: https://docs.python.org/3/using/windows.html#the-embeddable-package
  146:         :see: `discovery.py_info.PythonInfo` class (interpreter).
  147:         :see: `python -m sysconfig` output.
  148: 
  149:         :note: The embeddable Python distribution for Windows includes
  150:         "python{VERSION}.zip" and "python{VERSION}._pth" files. User can
  151:         move/rename *zip* file and edit `sys.path` by editing *_pth* file.
  152:         Here the `pattern` is used only for the default *zip* file name!
  153:         """  # noqa: D205
  154:         pattern = f"*python{interpreter.version_nodot}.zip"
  155:         matches = fnmatch.filter(interpreter.path, pattern)
  156:         matched_paths = map(Path, matches)
  157:         existing_paths = filter(method("exists"), matched_paths)
  158:         path = next(existing_paths, None)
  159:         if path is not None:
  160:             yield PathRefToDest(path, cls.to_bin)
  161: 
  162: 
  163: __all__ = [
  164:     "CPython3",
  165:     "CPython3Posix",
  166:     "CPython3Windows",
  167: ]
