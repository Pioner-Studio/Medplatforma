    1: """
    2: Virtual environments in the traditional sense are built as reference to the host python. This file allows declarative
    3: references to elements on the file system, allowing our system to automatically detect what modes it can support given
    4: the constraints: e.g. can the file system symlink, can the files be read, executed, etc.
    5: """  # noqa: D205
    6: 
    7: from __future__ import annotations
    8: 
    9: import os
   10: from abc import ABC, abstractmethod
   11: from collections import OrderedDict
   12: from stat import S_IXGRP, S_IXOTH, S_IXUSR
   13: 
   14: from virtualenv.info import fs_is_case_sensitive, fs_supports_symlink
   15: from virtualenv.util.path import copy, make_exe, symlink
   16: 
   17: 
   18: class RefMust:
   19:     NA = "NA"
   20:     COPY = "copy"
   21:     SYMLINK = "symlink"
   22: 
   23: 
   24: class RefWhen:
   25:     ANY = "ANY"
   26:     COPY = "copy"
   27:     SYMLINK = "symlink"
   28: 
   29: 
   30: class PathRef(ABC):
   31:     """Base class that checks if a file reference can be symlink/copied."""
   32: 
   33:     FS_SUPPORTS_SYMLINK = fs_supports_symlink()
   34:     FS_CASE_SENSITIVE = fs_is_case_sensitive()
   35: 
   36:     def __init__(self, src, must=RefMust.NA, when=RefWhen.ANY) -> None:
   37:         self.must = must
   38:         self.when = when
   39:         self.src = src
   40:         try:
   41:             self.exists = src.exists()
   42:         except OSError:
   43:             self.exists = False
   44:         self._can_read = None if self.exists else False
   45:         self._can_copy = None if self.exists else False
   46:         self._can_symlink = None if self.exists else False
   47: 
   48:     def __repr__(self) -> str:
   49:         return f"{self.__class__.__name__}(src={self.src})"
   50: 
   51:     @property
   52:     def can_read(self):
   53:         if self._can_read is None:
   54:             if self.src.is_file():
   55:                 try:
   56:                     with self.src.open("rb"):
   57:                         self._can_read = True
   58:                 except OSError:
   59:                     self._can_read = False
   60:             else:
   61:                 self._can_read = os.access(str(self.src), os.R_OK)
   62:         return self._can_read
   63: 
   64:     @property
   65:     def can_copy(self):
   66:         if self._can_copy is None:
   67:             if self.must == RefMust.SYMLINK:
   68:                 self._can_copy = self.can_symlink
   69:             else:
   70:                 self._can_copy = self.can_read
   71:         return self._can_copy
   72: 
   73:     @property
   74:     def can_symlink(self):
   75:         if self._can_symlink is None:
   76:             if self.must == RefMust.COPY:
   77:                 self._can_symlink = self.can_copy
   78:             else:
   79:                 self._can_symlink = self.FS_SUPPORTS_SYMLINK and self.can_read
   80:         return self._can_symlink
   81: 
   82:     @abstractmethod
   83:     def run(self, creator, symlinks):
   84:         raise NotImplementedError
   85: 
   86:     def method(self, symlinks):
   87:         if self.must == RefMust.SYMLINK:
   88:             return symlink
   89:         if self.must == RefMust.COPY:
   90:             return copy
   91:         return symlink if symlinks else copy
   92: 
   93: 
   94: class ExePathRef(PathRef, ABC):
   95:     """Base class that checks if a executable can be references via symlink/copy."""
   96: 
   97:     def __init__(self, src, must=RefMust.NA, when=RefWhen.ANY) -> None:
   98:         super().__init__(src, must, when)
   99:         self._can_run = None
  100: 
  101:     @property
  102:     def can_symlink(self):
  103:         if self.FS_SUPPORTS_SYMLINK:
  104:             return self.can_run
  105:         return False
  106: 
  107:     @property
  108:     def can_run(self):
  109:         if self._can_run is None:
  110:             mode = self.src.stat().st_mode
  111:             for key in [S_IXUSR, S_IXGRP, S_IXOTH]:
  112:                 if mode & key:
  113:                     self._can_run = True
  114:                 break
  115:             else:
  116:                 self._can_run = False
  117:         return self._can_run
  118: 
  119: 
  120: class PathRefToDest(PathRef):
  121:     """Link a path on the file system."""
  122: 
  123:     def __init__(self, src, dest, must=RefMust.NA, when=RefWhen.ANY) -> None:
  124:         super().__init__(src, must, when)
  125:         self.dest = dest
  126: 
  127:     def run(self, creator, symlinks):
  128:         dest = self.dest(creator, self.src)
  129:         method = self.method(symlinks)
  130:         dest_iterable = dest if isinstance(dest, list) else (dest,)
  131:         if not dest.parent.exists():
  132:             dest.parent.mkdir(parents=True, exist_ok=True)
  133:         for dst in dest_iterable:
  134:             method(self.src, dst)
  135: 
  136: 
  137: class ExePathRefToDest(PathRefToDest, ExePathRef):
  138:     """Link a exe path on the file system."""
  139: 
  140:     def __init__(self, src, targets, dest, must=RefMust.NA, when=RefWhen.ANY) -> None:
  141:         ExePathRef.__init__(self, src, must, when)
  142:         PathRefToDest.__init__(self, src, dest, must, when)
  143:         if not self.FS_CASE_SENSITIVE:
  144:             targets = list(OrderedDict((i.lower(), None) for i in targets).keys())
  145:         self.base = targets[0]
  146:         self.aliases = targets[1:]
  147:         self.dest = dest
  148: 
  149:     def run(self, creator, symlinks):
  150:         bin_dir = self.dest(creator, self.src).parent
  151:         dest = bin_dir / self.base
  152:         method = self.method(symlinks)
  153:         method(self.src, dest)
  154:         if not symlinks:
  155:             make_exe(dest)
  156:         for extra in self.aliases:
  157:             link_file = bin_dir / extra
  158:             if link_file.exists():
  159:                 link_file.unlink()
  160:             if symlinks:
  161:                 link_file.symlink_to(self.base)
  162:             else:
  163:                 copy(self.src, link_file)
  164:             if not symlinks:
  165:                 make_exe(link_file)
  166: 
  167:     def __repr__(self) -> str:
  168:         return f"{self.__class__.__name__}(src={self.src}, alias={self.aliases})"
  169: 
  170: 
  171: __all__ = [
  172:     "ExePathRef",
  173:     "ExePathRefToDest",
  174:     "PathRef",
  175:     "PathRefToDest",
  176:     "RefMust",
  177:     "RefWhen",
  178: ]
