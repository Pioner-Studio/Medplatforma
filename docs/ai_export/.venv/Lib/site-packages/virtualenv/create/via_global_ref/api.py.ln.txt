    1: from __future__ import annotations
    2: 
    3: import logging
    4: import os
    5: from abc import ABC
    6: from pathlib import Path
    7: 
    8: from virtualenv.create.creator import Creator, CreatorMeta
    9: from virtualenv.info import fs_supports_symlink
   10: 
   11: LOGGER = logging.getLogger(__name__)
   12: 
   13: 
   14: class ViaGlobalRefMeta(CreatorMeta):
   15:     def __init__(self) -> None:
   16:         super().__init__()
   17:         self.copy_error = None
   18:         self.symlink_error = None
   19:         if not fs_supports_symlink():
   20:             self.symlink_error = "the filesystem does not supports symlink"
   21: 
   22:     @property
   23:     def can_copy(self):
   24:         return not self.copy_error
   25: 
   26:     @property
   27:     def can_symlink(self):
   28:         return not self.symlink_error
   29: 
   30: 
   31: class ViaGlobalRefApi(Creator, ABC):
   32:     def __init__(self, options, interpreter) -> None:
   33:         super().__init__(options, interpreter)
   34:         self.symlinks = self._should_symlink(options)
   35:         self.enable_system_site_package = options.system_site
   36: 
   37:     @staticmethod
   38:     def _should_symlink(options):
   39:         # Priority of where the option is set to follow the order: CLI, env var, file, hardcoded.
   40:         # If both set at same level prefers copy over symlink.
   41:         copies, symlinks = getattr(options, "copies", False), getattr(options, "symlinks", False)
   42:         copy_src, sym_src = options.get_source("copies"), options.get_source("symlinks")
   43:         for level in ["cli", "env var", "file", "default"]:
   44:             s_opt = symlinks if sym_src == level else None
   45:             c_opt = copies if copy_src == level else None
   46:             if s_opt is True and c_opt is True:
   47:                 return False
   48:             if s_opt is True:
   49:                 return True
   50:             if c_opt is True:
   51:                 return False
   52:         return False  # fallback to copy
   53: 
   54:     @classmethod
   55:     def add_parser_arguments(cls, parser, interpreter, meta, app_data):
   56:         super().add_parser_arguments(parser, interpreter, meta, app_data)
   57:         parser.add_argument(
   58:             "--system-site-packages",
   59:             default=False,
   60:             action="store_true",
   61:             dest="system_site",
   62:             help="give the virtual environment access to the system site-packages dir",
   63:         )
   64:         if not meta.can_symlink and not meta.can_copy:
   65:             errors = []
   66:             if meta.symlink_error:
   67:                 errors.append(f"symlink: {meta.symlink_error}")
   68:             if meta.copy_error:
   69:                 errors.append(f"copy: {meta.copy_error}")
   70:             msg = f"neither symlink or copy method supported: {', '.join(errors)}"
   71:             raise RuntimeError(msg)
   72:         group = parser.add_mutually_exclusive_group()
   73:         if meta.can_symlink:
   74:             group.add_argument(
   75:                 "--symlinks",
   76:                 default=True,
   77:                 action="store_true",
   78:                 dest="symlinks",
   79:                 help="try to use symlinks rather than copies, when symlinks are not the default for the platform",
   80:             )
   81:         if meta.can_copy:
   82:             group.add_argument(
   83:                 "--copies",
   84:                 "--always-copy",
   85:                 default=not meta.can_symlink,
   86:                 action="store_true",
   87:                 dest="copies",
   88:                 help="try to use copies rather than symlinks, even when symlinks are the default for the platform",
   89:             )
   90: 
   91:     def create(self):
   92:         self.install_patch()
   93: 
   94:     def install_patch(self):
   95:         text = self.env_patch_text()
   96:         if text:
   97:             pth = self.purelib / "_virtualenv.pth"
   98:             LOGGER.debug("create virtualenv import hook file %s", pth)
   99:             pth.write_text("import _virtualenv", encoding="utf-8")
  100:             dest_path = self.purelib / "_virtualenv.py"
  101:             LOGGER.debug("create %s", dest_path)
  102:             dest_path.write_text(text, encoding="utf-8")
  103: 
  104:     def env_patch_text(self):
  105:         """Patch the distutils package to not be derailed by its configuration files."""
  106:         with self.app_data.ensure_extracted(Path(__file__).parent / "_virtualenv.py") as resolved_path:
  107:             text = resolved_path.read_text(encoding="utf-8")
  108:             return text.replace('"__SCRIPT_DIR__"', repr(os.path.relpath(str(self.script_dir), str(self.purelib))))
  109: 
  110:     def _args(self):
  111:         return [*super()._args(), ("global", self.enable_system_site_package)]
  112: 
  113:     def set_pyenv_cfg(self):
  114:         super().set_pyenv_cfg()
  115:         self.pyenv_cfg["include-system-site-packages"] = "true" if self.enable_system_site_package else "false"
  116: 
  117: 
  118: __all__ = [
  119:     "ViaGlobalRefApi",
  120:     "ViaGlobalRefMeta",
  121: ]
