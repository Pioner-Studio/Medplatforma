    1: from __future__ import annotations
    2: 
    3: from abc import ABC
    4: 
    5: from virtualenv.create.via_global_ref.api import ViaGlobalRefApi, ViaGlobalRefMeta
    6: from virtualenv.create.via_global_ref.builtin.ref import (
    7:     ExePathRefToDest,
    8:     RefMust,
    9:     RefWhen,
   10: )
   11: from virtualenv.util.path import ensure_dir
   12: 
   13: from .builtin_way import VirtualenvBuiltin
   14: 
   15: 
   16: class BuiltinViaGlobalRefMeta(ViaGlobalRefMeta):
   17:     def __init__(self) -> None:
   18:         super().__init__()
   19:         self.sources = []
   20: 
   21: 
   22: class ViaGlobalRefVirtualenvBuiltin(ViaGlobalRefApi, VirtualenvBuiltin, ABC):
   23:     def __init__(self, options, interpreter) -> None:
   24:         super().__init__(options, interpreter)
   25:         self._sources = getattr(options.meta, "sources", None)  # if we're created as a describer this might be missing
   26: 
   27:     @classmethod
   28:     def can_create(cls, interpreter):
   29:         """By default, all built-in methods assume that if we can describe it we can create it."""
   30:         # first we must be able to describe it
   31:         if not cls.can_describe(interpreter):
   32:             return None
   33:         meta = cls.setup_meta(interpreter)
   34:         if meta is not None and meta:
   35:             cls._sources_can_be_applied(interpreter, meta)
   36:         return meta
   37: 
   38:     @classmethod
   39:     def _sources_can_be_applied(cls, interpreter, meta):
   40:         for src in cls.sources(interpreter):
   41:             if src.exists:
   42:                 if meta.can_copy and not src.can_copy:
   43:                     meta.copy_error = f"cannot copy {src}"
   44:                 if meta.can_symlink and not src.can_symlink:
   45:                     meta.symlink_error = f"cannot symlink {src}"
   46:             else:
   47:                 msg = f"missing required file {src}"
   48:                 if src.when == RefMust.NA:
   49:                     meta.error = msg
   50:                 elif src.when == RefMust.COPY:
   51:                     meta.copy_error = msg
   52:                 elif src.when == RefMust.SYMLINK:
   53:                     meta.symlink_error = msg
   54:             if not meta.can_copy and not meta.can_symlink:
   55:                 meta.error = f"neither copy or symlink supported, copy: {meta.copy_error} symlink: {meta.symlink_error}"
   56:             if meta.error:
   57:                 break
   58:             meta.sources.append(src)
   59: 
   60:     @classmethod
   61:     def setup_meta(cls, interpreter):  # noqa: ARG003
   62:         return BuiltinViaGlobalRefMeta()
   63: 
   64:     @classmethod
   65:     def sources(cls, interpreter):
   66:         for host_exe, targets, must, when in cls._executables(interpreter):
   67:             yield ExePathRefToDest(host_exe, dest=cls.to_bin, targets=targets, must=must, when=when)
   68: 
   69:     def to_bin(self, src):
   70:         return self.bin_dir / src.name
   71: 
   72:     @classmethod
   73:     def _executables(cls, interpreter):
   74:         raise NotImplementedError
   75: 
   76:     def create(self):
   77:         dirs = self.ensure_directories()
   78:         for directory in list(dirs):
   79:             if any(i for i in dirs if i is not directory and directory.parts == i.parts[: len(directory.parts)]):
   80:                 dirs.remove(directory)
   81:         for directory in sorted(dirs):
   82:             ensure_dir(directory)
   83: 
   84:         self.set_pyenv_cfg()
   85:         self.pyenv_cfg.write()
   86:         true_system_site = self.enable_system_site_package
   87:         try:
   88:             self.enable_system_site_package = False
   89:             for src in self._sources:
   90:                 if (
   91:                     src.when == RefWhen.ANY
   92:                     or (src.when == RefWhen.SYMLINK and self.symlinks is True)
   93:                     or (src.when == RefWhen.COPY and self.symlinks is False)
   94:                 ):
   95:                     src.run(self, self.symlinks)
   96:         finally:
   97:             if true_system_site != self.enable_system_site_package:
   98:                 self.enable_system_site_package = true_system_site
   99:         super().create()
  100: 
  101:     def ensure_directories(self):
  102:         return {self.dest, self.bin_dir, self.script_dir, self.stdlib} | set(self.libs)
  103: 
  104:     def set_pyenv_cfg(self):
  105:         """
  106:         We directly inject the base prefix and base exec prefix to avoid site.py needing to discover these
  107:         from home (which usually is done within the interpreter itself).
  108:         """  # noqa: D205
  109:         super().set_pyenv_cfg()
  110:         self.pyenv_cfg["base-prefix"] = self.interpreter.system_prefix
  111:         self.pyenv_cfg["base-exec-prefix"] = self.interpreter.system_exec_prefix
  112:         self.pyenv_cfg["base-executable"] = self.interpreter.system_executable
  113: 
  114: 
  115: __all__ = [
  116:     "BuiltinViaGlobalRefMeta",
  117:     "ViaGlobalRefVirtualenvBuiltin",
  118: ]
