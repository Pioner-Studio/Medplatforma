    1: from __future__ import annotations
    2: 
    3: import abc
    4: from pathlib import Path
    5: 
    6: from virtualenv.create.describe import PosixSupports, Python3Supports, WindowsSupports
    7: from virtualenv.create.via_global_ref.builtin.ref import PathRefToDest
    8: 
    9: from .common import PyPy
   10: 
   11: 
   12: class PyPy3(PyPy, Python3Supports, abc.ABC):
   13:     @classmethod
   14:     def exe_stem(cls):
   15:         return "pypy3"
   16: 
   17:     @classmethod
   18:     def exe_names(cls, interpreter):
   19:         return super().exe_names(interpreter) | {"pypy"}
   20: 
   21: 
   22: class PyPy3Posix(PyPy3, PosixSupports):
   23:     """PyPy 3 on POSIX."""
   24: 
   25:     @classmethod
   26:     def _shared_libs(cls, python_dir):
   27:         # glob for libpypy3-c.so, libpypy3-c.dylib, libpypy3.9-c.so ...
   28:         return python_dir.glob("libpypy3*.*")
   29: 
   30:     def to_lib(self, src):
   31:         return self.dest / "lib" / src.name
   32: 
   33:     @classmethod
   34:     def sources(cls, interpreter):
   35:         yield from super().sources(interpreter)
   36:         # PyPy >= 3.8 supports a standard prefix installation, where older
   37:         # versions always used a portable/development style installation.
   38:         # If this is a standard prefix installation, skip the below:
   39:         if interpreter.system_prefix == "/usr":
   40:             return
   41:         # Also copy/symlink anything under prefix/lib, which, for "portable"
   42:         # PyPy builds, includes the tk,tcl runtime and a number of shared
   43:         # objects. In distro-specific builds or on conda this should be empty
   44:         # (on PyPy3.8+ it will, like on CPython, hold the stdlib).
   45:         host_lib = Path(interpreter.system_prefix) / "lib"
   46:         stdlib = Path(interpreter.system_stdlib)
   47:         if host_lib.exists() and host_lib.is_dir():
   48:             for path in host_lib.iterdir():
   49:                 if stdlib == path:
   50:                     # For PyPy3.8+ the stdlib lives in lib/pypy3.8
   51:                     # We need to avoid creating a symlink to it since that
   52:                     # will defeat the purpose of a virtualenv
   53:                     continue
   54:                 yield PathRefToDest(path, dest=cls.to_lib)
   55: 
   56: 
   57: class Pypy3Windows(PyPy3, WindowsSupports):
   58:     """PyPy 3 on Windows."""
   59: 
   60:     @property
   61:     def less_v37(self):
   62:         return self.interpreter.version_info.minor < 7  # noqa: PLR2004
   63: 
   64:     @classmethod
   65:     def _shared_libs(cls, python_dir):
   66:         # glob for libpypy*.dll and libffi*.dll
   67:         for pattern in ["libpypy*.dll", "libffi*.dll"]:
   68:             srcs = python_dir.glob(pattern)
   69:             yield from srcs
   70: 
   71: 
   72: __all__ = [
   73:     "PyPy3",
   74:     "PyPy3Posix",
   75:     "Pypy3Windows",
   76: ]
