    1: from __future__ import annotations
    2: 
    3: import logging
    4: from copy import copy
    5: 
    6: from virtualenv.create.via_global_ref.store import handle_store_python
    7: from virtualenv.discovery.py_info import PythonInfo
    8: from virtualenv.util.error import ProcessCallFailedError
    9: from virtualenv.util.path import ensure_dir
   10: from virtualenv.util.subprocess import run_cmd
   11: 
   12: from .api import ViaGlobalRefApi, ViaGlobalRefMeta
   13: from .builtin.cpython.mac_os import CPython3macOsBrew
   14: from .builtin.pypy.pypy3 import Pypy3Windows
   15: 
   16: LOGGER = logging.getLogger(__name__)
   17: 
   18: 
   19: class Venv(ViaGlobalRefApi):
   20:     def __init__(self, options, interpreter) -> None:
   21:         self.describe = options.describe
   22:         super().__init__(options, interpreter)
   23:         current = PythonInfo.current()
   24:         self.can_be_inline = interpreter is current and interpreter.executable == interpreter.system_executable
   25:         self._context = None
   26: 
   27:     def _args(self):
   28:         return super()._args() + ([("describe", self.describe.__class__.__name__)] if self.describe else [])
   29: 
   30:     @classmethod
   31:     def can_create(cls, interpreter):
   32:         if interpreter.has_venv:
   33:             if CPython3macOsBrew.can_describe(interpreter):
   34:                 return CPython3macOsBrew.setup_meta(interpreter)
   35:             meta = ViaGlobalRefMeta()
   36:             if interpreter.platform == "win32":
   37:                 meta = handle_store_python(meta, interpreter)
   38:             return meta
   39:         return None
   40: 
   41:     def create(self):
   42:         if self.can_be_inline:
   43:             self.create_inline()
   44:         else:
   45:             self.create_via_sub_process()
   46:         for lib in self.libs:
   47:             ensure_dir(lib)
   48:         super().create()
   49:         self.executables_for_win_pypy_less_v37()
   50: 
   51:     def executables_for_win_pypy_less_v37(self):
   52:         """
   53:         PyPy <= 3.6 (v7.3.3) for Windows contains only pypy3.exe and pypy3w.exe
   54:         Venv does not handle non-existing exe sources, e.g. python.exe, so this
   55:         patch does it.
   56:         """  # noqa: D205
   57:         creator = self.describe
   58:         if isinstance(creator, Pypy3Windows) and creator.less_v37:
   59:             for exe in creator.executables(self.interpreter):
   60:                 exe.run(creator, self.symlinks)
   61: 
   62:     def create_inline(self):
   63:         from venv import EnvBuilder  # noqa: PLC0415
   64: 
   65:         builder = EnvBuilder(
   66:             system_site_packages=self.enable_system_site_package,
   67:             clear=False,
   68:             symlinks=self.symlinks,
   69:             with_pip=False,
   70:         )
   71:         builder.create(str(self.dest))
   72: 
   73:     def create_via_sub_process(self):
   74:         cmd = self.get_host_create_cmd()
   75:         LOGGER.info("using host built-in venv to create via %s", " ".join(cmd))
   76:         code, out, err = run_cmd(cmd)
   77:         if code != 0:
   78:             raise ProcessCallFailedError(code, out, err, cmd)
   79: 
   80:     def get_host_create_cmd(self):
   81:         cmd = [self.interpreter.system_executable, "-m", "venv", "--without-pip"]
   82:         if self.enable_system_site_package:
   83:             cmd.append("--system-site-packages")
   84:         cmd.extend(("--symlinks" if self.symlinks else "--copies", str(self.dest)))
   85:         return cmd
   86: 
   87:     def set_pyenv_cfg(self):
   88:         # prefer venv options over ours, but keep our extra
   89:         venv_content = copy(self.pyenv_cfg.refresh())
   90:         super().set_pyenv_cfg()
   91:         self.pyenv_cfg.update(venv_content)
   92: 
   93:     def __getattribute__(self, item):
   94:         describe = object.__getattribute__(self, "describe")
   95:         if describe is not None and hasattr(describe, item):
   96:             element = getattr(describe, item)
   97:             if not callable(element) or item == "script":
   98:                 return element
   99:         return object.__getattribute__(self, item)
  100: 
  101: 
  102: __all__ = [
  103:     "Venv",
  104: ]
