    1: """The Apple Framework builds require their own customization."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import logging
    6: import os
    7: import struct
    8: import subprocess
    9: from abc import ABC, abstractmethod
   10: from pathlib import Path
   11: from textwrap import dedent
   12: 
   13: from virtualenv.create.via_global_ref.builtin.ref import (
   14:     ExePathRefToDest,
   15:     PathRefToDest,
   16:     RefMust,
   17: )
   18: from virtualenv.create.via_global_ref.builtin.via_global_self_do import BuiltinViaGlobalRefMeta
   19: 
   20: from .common import CPython, CPythonPosix, is_mac_os_framework, is_macos_brew
   21: from .cpython3 import CPython3
   22: 
   23: LOGGER = logging.getLogger(__name__)
   24: 
   25: 
   26: class CPythonmacOsFramework(CPython, ABC):
   27:     @classmethod
   28:     def can_describe(cls, interpreter):
   29:         return is_mac_os_framework(interpreter) and super().can_describe(interpreter)
   30: 
   31:     def create(self):
   32:         super().create()
   33: 
   34:         # change the install_name of the copied python executables
   35:         target = self.desired_mach_o_image_path()
   36:         current = self.current_mach_o_image_path()
   37:         for src in self._sources:
   38:             if isinstance(src, ExePathRefToDest) and (src.must == RefMust.COPY or not self.symlinks):
   39:                 exes = [self.bin_dir / src.base]
   40:                 if not self.symlinks:
   41:                     exes.extend(self.bin_dir / a for a in src.aliases)
   42:                 for exe in exes:
   43:                     fix_mach_o(str(exe), current, target, self.interpreter.max_size)
   44: 
   45:     @classmethod
   46:     def _executables(cls, interpreter):
   47:         for _, targets, must, when in super()._executables(interpreter):
   48:             # Make sure we use the embedded interpreter inside the framework, even if sys.executable points to the
   49:             # stub executable in ${sys.prefix}/bin.
   50:             # See http://groups.google.com/group/python-virtualenv/browse_thread/thread/17cab2f85da75951
   51:             fixed_host_exe = Path(interpreter.prefix) / "Resources" / "Python.app" / "Contents" / "MacOS" / "Python"
   52:             yield fixed_host_exe, targets, must, when
   53: 
   54:     @abstractmethod
   55:     def current_mach_o_image_path(self):
   56:         raise NotImplementedError
   57: 
   58:     @abstractmethod
   59:     def desired_mach_o_image_path(self):
   60:         raise NotImplementedError
   61: 
   62: 
   63: class CPython3macOsFramework(CPythonmacOsFramework, CPython3, CPythonPosix):
   64:     def current_mach_o_image_path(self):
   65:         return "@executable_path/../../../../Python3"
   66: 
   67:     def desired_mach_o_image_path(self):
   68:         return "@executable_path/../.Python"
   69: 
   70:     @classmethod
   71:     def sources(cls, interpreter):
   72:         yield from super().sources(interpreter)
   73: 
   74:         # add a symlink to the host python image
   75:         exe = Path(interpreter.prefix) / "Python3"
   76:         yield PathRefToDest(exe, dest=lambda self, _: self.dest / ".Python", must=RefMust.SYMLINK)
   77: 
   78:     @property
   79:     def reload_code(self):
   80:         result = super().reload_code
   81:         return dedent(
   82:             f"""
   83:         # the bundled site.py always adds the global site package if we're on python framework build, escape this
   84:         import sys
   85:         before = sys._framework
   86:         try:
   87:             sys._framework = None
   88:             {result}
   89:         finally:
   90:             sys._framework = before
   91:         """,
   92:         )
   93: 
   94: 
   95: def fix_mach_o(exe, current, new, max_size):
   96:     """
   97:     https://en.wikipedia.org/wiki/Mach-O.
   98: 
   99:     Mach-O, short for Mach object file format, is a file format for executables, object code, shared libraries,
  100:     dynamically-loaded code, and core dumps. A replacement for the a.out format, Mach-O offers more extensibility and
  101:     faster access to information in the symbol table.
  102: 
  103:     Each Mach-O file is made up of one Mach-O header, followed by a series of load commands, followed by one or more
  104:     segments, each of which contains between 0 and 255 sections. Mach-O uses the REL relocation format to handle
  105:     references to symbols. When looking up symbols Mach-O uses a two-level namespace that encodes each symbol into an
  106:     'object/symbol name' pair that is then linearly searched for by first the object and then the symbol name.
  107: 
  108:     The basic structureвЂ”a list of variable-length "load commands" that reference pages of data elsewhere in the fileвЂ”was
  109:     also used in the executable file format for Accent. The Accent file format was in turn, based on an idea from Spice
  110:     Lisp.
  111: 
  112:     With the introduction of Mac OS X 10.6 platform the Mach-O file underwent a significant modification that causes
  113:     binaries compiled on a computer running 10.6 or later to be (by default) executable only on computers running Mac
  114:     OS X 10.6 or later. The difference stems from load commands that the dynamic linker, in previous Mac OS X versions,
  115:     does not understand. Another significant change to the Mach-O format is the change in how the Link Edit tables
  116:     (found in the __LINKEDIT section) function. In 10.6 these new Link Edit tables are compressed by removing unused and
  117:     unneeded bits of information, however Mac OS X 10.5 and earlier cannot read this new Link Edit table format.
  118:     """
  119:     try:
  120:         LOGGER.debug("change Mach-O for %s from %s to %s", exe, current, new)
  121:         _builtin_change_mach_o(max_size)(exe, current, new)
  122:     except Exception as e:  # noqa: BLE001
  123:         LOGGER.warning("Could not call _builtin_change_mac_o: %s. Trying to call install_name_tool instead.", e)
  124:         try:
  125:             cmd = ["install_name_tool", "-change", current, new, exe]
  126:             subprocess.check_call(cmd)
  127:         except Exception:
  128:             logging.fatal("Could not call install_name_tool -- you must have Apple's development tools installed")
  129:             raise
  130: 
  131: 
  132: def _builtin_change_mach_o(maxint):  # noqa: C901
  133:     MH_MAGIC = 0xFEEDFACE  # noqa: N806
  134:     MH_CIGAM = 0xCEFAEDFE  # noqa: N806
  135:     MH_MAGIC_64 = 0xFEEDFACF  # noqa: N806
  136:     MH_CIGAM_64 = 0xCFFAEDFE  # noqa: N806
  137:     FAT_MAGIC = 0xCAFEBABE  # noqa: N806
  138:     BIG_ENDIAN = ">"  # noqa: N806
  139:     LITTLE_ENDIAN = "<"  # noqa: N806
  140:     LC_LOAD_DYLIB = 0xC  # noqa: N806
  141: 
  142:     class FileView:
  143:         """A proxy for file-like objects that exposes a given view of a file. Modified from macholib."""
  144: 
  145:         def __init__(self, file_obj, start=0, size=maxint) -> None:
  146:             if isinstance(file_obj, FileView):
  147:                 self._file_obj = file_obj._file_obj  # noqa: SLF001
  148:             else:
  149:                 self._file_obj = file_obj
  150:             self._start = start
  151:             self._end = start + size
  152:             self._pos = 0
  153: 
  154:         def __repr__(self) -> str:
  155:             return f"<fileview [{self._start:d}, {self._end:d}] {self._file_obj!r}>"
  156: 
  157:         def tell(self):
  158:             return self._pos
  159: 
  160:         def _checkwindow(self, seek_to, op):
  161:             if not (self._start <= seek_to <= self._end):
  162:                 msg = f"{op} to offset {seek_to:d} is outside window [{self._start:d}, {self._end:d}]"
  163:                 raise OSError(msg)
  164: 
  165:         def seek(self, offset, whence=0):
  166:             seek_to = offset
  167:             if whence == os.SEEK_SET:
  168:                 seek_to += self._start
  169:             elif whence == os.SEEK_CUR:
  170:                 seek_to += self._start + self._pos
  171:             elif whence == os.SEEK_END:
  172:                 seek_to += self._end
  173:             else:
  174:                 msg = f"Invalid whence argument to seek: {whence!r}"
  175:                 raise OSError(msg)
  176:             self._checkwindow(seek_to, "seek")
  177:             self._file_obj.seek(seek_to)
  178:             self._pos = seek_to - self._start
  179: 
  180:         def write(self, content):
  181:             here = self._start + self._pos
  182:             self._checkwindow(here, "write")
  183:             self._checkwindow(here + len(content), "write")
  184:             self._file_obj.seek(here, os.SEEK_SET)
  185:             self._file_obj.write(content)
  186:             self._pos += len(content)
  187: 
  188:         def read(self, size=maxint):
  189:             assert size >= 0  # noqa: S101
  190:             here = self._start + self._pos
  191:             self._checkwindow(here, "read")
  192:             size = min(size, self._end - here)
  193:             self._file_obj.seek(here, os.SEEK_SET)
  194:             read_bytes = self._file_obj.read(size)
  195:             self._pos += len(read_bytes)
  196:             return read_bytes
  197: 
  198:     def read_data(file, endian, num=1):
  199:         """Read a given number of 32-bits unsigned integers from the given file with the given endianness."""
  200:         res = struct.unpack(endian + "L" * num, file.read(num * 4))
  201:         if len(res) == 1:
  202:             return res[0]
  203:         return res
  204: 
  205:     def mach_o_change(at_path, what, value):  # noqa: C901
  206:         """
  207:         Replace a given name (what) in any LC_LOAD_DYLIB command found in the given binary with a new name (value),
  208:         provided it's shorter.
  209:         """  # noqa: D205
  210: 
  211:         def do_macho(file, bits, endian):
  212:             # Read Mach-O header (the magic number is assumed read by the caller)
  213:             _cpu_type, _cpu_sub_type, _file_type, n_commands, _size_of_commands, _flags = read_data(file, endian, 6)
  214:             # 64-bits header has one more field.
  215:             if bits == 64:  # noqa: PLR2004
  216:                 read_data(file, endian)
  217:             # The header is followed by n commands
  218:             for _ in range(n_commands):
  219:                 where = file.tell()
  220:                 # Read command header
  221:                 cmd, cmd_size = read_data(file, endian, 2)
  222:                 if cmd == LC_LOAD_DYLIB:
  223:                     # The first data field in LC_LOAD_DYLIB commands is the offset of the name, starting from the
  224:                     # beginning of the  command.
  225:                     name_offset = read_data(file, endian)
  226:                     file.seek(where + name_offset, os.SEEK_SET)
  227:                     # Read the NUL terminated string
  228:                     load = file.read(cmd_size - name_offset).decode()
  229:                     load = load[: load.index("\0")]
  230:                     # If the string is what is being replaced, overwrite it.
  231:                     if load == what:
  232:                         file.seek(where + name_offset, os.SEEK_SET)
  233:                         file.write(value.encode() + b"\0")
  234:                 # Seek to the next command
  235:                 file.seek(where + cmd_size, os.SEEK_SET)
  236: 
  237:         def do_file(file, offset=0, size=maxint):
  238:             file = FileView(file, offset, size)
  239:             # Read magic number
  240:             magic = read_data(file, BIG_ENDIAN)
  241:             if magic == FAT_MAGIC:
  242:                 # Fat binaries contain nfat_arch Mach-O binaries
  243:                 n_fat_arch = read_data(file, BIG_ENDIAN)
  244:                 for _ in range(n_fat_arch):
  245:                     # Read arch header
  246:                     _cpu_type, _cpu_sub_type, offset, size, _align = read_data(file, BIG_ENDIAN, 5)
  247:                     do_file(file, offset, size)
  248:             elif magic == MH_MAGIC:
  249:                 do_macho(file, 32, BIG_ENDIAN)
  250:             elif magic == MH_CIGAM:
  251:                 do_macho(file, 32, LITTLE_ENDIAN)
  252:             elif magic == MH_MAGIC_64:
  253:                 do_macho(file, 64, BIG_ENDIAN)
  254:             elif magic == MH_CIGAM_64:
  255:                 do_macho(file, 64, LITTLE_ENDIAN)
  256: 
  257:         assert len(what) >= len(value)  # noqa: S101
  258: 
  259:         with open(at_path, "r+b") as f:
  260:             do_file(f)
  261: 
  262:     return mach_o_change
  263: 
  264: 
  265: class CPython3macOsBrew(CPython3, CPythonPosix):
  266:     @classmethod
  267:     def can_describe(cls, interpreter):
  268:         return is_macos_brew(interpreter) and super().can_describe(interpreter)
  269: 
  270:     @classmethod
  271:     def setup_meta(cls, interpreter):  # noqa: ARG003
  272:         meta = BuiltinViaGlobalRefMeta()
  273:         meta.copy_error = "Brew disables copy creation: https://github.com/Homebrew/homebrew-core/issues/138159"
  274:         return meta
  275: 
  276: 
  277: __all__ = [
  278:     "CPython3macOsBrew",
  279:     "CPython3macOsFramework",
  280:     "CPythonmacOsFramework",
  281: ]
