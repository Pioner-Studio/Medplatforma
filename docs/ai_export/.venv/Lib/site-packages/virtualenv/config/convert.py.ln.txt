    1: from __future__ import annotations
    2: 
    3: import logging
    4: import os
    5: from typing import ClassVar
    6: 
    7: LOGGER = logging.getLogger(__name__)
    8: 
    9: 
   10: class TypeData:
   11:     def __init__(self, default_type, as_type) -> None:
   12:         self.default_type = default_type
   13:         self.as_type = as_type
   14: 
   15:     def __repr__(self) -> str:
   16:         return f"{self.__class__.__name__}(base={self.default_type}, as={self.as_type})"
   17: 
   18:     def convert(self, value):
   19:         return self.default_type(value)
   20: 
   21: 
   22: class BoolType(TypeData):
   23:     BOOLEAN_STATES: ClassVar[dict[str, bool]] = {
   24:         "1": True,
   25:         "yes": True,
   26:         "true": True,
   27:         "on": True,
   28:         "0": False,
   29:         "no": False,
   30:         "false": False,
   31:         "off": False,
   32:     }
   33: 
   34:     def convert(self, value):
   35:         if value.lower() not in self.BOOLEAN_STATES:
   36:             msg = f"Not a boolean: {value}"
   37:             raise ValueError(msg)
   38:         return self.BOOLEAN_STATES[value.lower()]
   39: 
   40: 
   41: class NoneType(TypeData):
   42:     def convert(self, value):
   43:         if not value:
   44:             return None
   45:         return str(value)
   46: 
   47: 
   48: class ListType(TypeData):
   49:     def _validate(self):
   50:         """no op."""
   51: 
   52:     def convert(self, value, flatten=True):  # noqa: ARG002, FBT002
   53:         values = self.split_values(value)
   54:         result = []
   55:         for a_value in values:
   56:             sub_values = a_value.split(os.pathsep)
   57:             result.extend(sub_values)
   58:         return [self.as_type(i) for i in result]
   59: 
   60:     def split_values(self, value):
   61:         """
   62:         Split the provided value into a list.
   63: 
   64:         First this is done by newlines. If there were no newlines in the text,
   65:         then we next try to split by comma.
   66:         """
   67:         if isinstance(value, (str, bytes)):
   68:             # Use `splitlines` rather than a custom check for whether there is
   69:             # more than one line. This ensures that the full `splitlines()`
   70:             # logic is supported here.
   71:             values = value.splitlines()
   72:             if len(values) <= 1:
   73:                 values = value.split(",")
   74:             values = filter(None, [x.strip() for x in values])
   75:         else:
   76:             values = list(value)
   77: 
   78:         return values
   79: 
   80: 
   81: def convert(value, as_type, source):
   82:     """Convert the value as a given type where the value comes from the given source."""
   83:     try:
   84:         return as_type.convert(value)
   85:     except Exception as exception:
   86:         LOGGER.warning("%s failed to convert %r as %r because %r", source, value, as_type, exception)
   87:         raise
   88: 
   89: 
   90: _CONVERT = {bool: BoolType, type(None): NoneType, list: ListType}
   91: 
   92: 
   93: def get_type(action):
   94:     default_type = type(action.default)
   95:     as_type = default_type if action.type is None else action.type
   96:     return _CONVERT.get(default_type, TypeData)(default_type, as_type)
   97: 
   98: 
   99: __all__ = [
  100:     "convert",
  101:     "get_type",
  102: ]
