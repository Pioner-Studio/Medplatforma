    1: """
    2: The PythonInfo contains information about a concrete instance of a Python interpreter.
    3: 
    4: Note: this file is also used to query target interpreters, so can only use standard library methods
    5: """
    6: 
    7: from __future__ import annotations
    8: 
    9: import json
   10: import logging
   11: import os
   12: import platform
   13: import re
   14: import struct
   15: import sys
   16: import sysconfig
   17: import warnings
   18: from collections import OrderedDict, namedtuple
   19: from string import digits
   20: 
   21: VersionInfo = namedtuple("VersionInfo", ["major", "minor", "micro", "releaselevel", "serial"])  # noqa: PYI024
   22: LOGGER = logging.getLogger(__name__)
   23: 
   24: 
   25: def _get_path_extensions():
   26:     return list(OrderedDict.fromkeys(["", *os.environ.get("PATHEXT", "").lower().split(os.pathsep)]))
   27: 
   28: 
   29: EXTENSIONS = _get_path_extensions()
   30: _CONF_VAR_RE = re.compile(r"\{\w+\}")
   31: 
   32: 
   33: class PythonInfo:
   34:     """Contains information for a Python interpreter."""
   35: 
   36:     def __init__(self) -> None:  # noqa: PLR0915
   37:         def abs_path(v):
   38:             return None if v is None else os.path.abspath(v)  # unroll relative elements from path (e.g. ..)
   39: 
   40:         # qualifies the python
   41:         self.platform = sys.platform
   42:         self.implementation = platform.python_implementation()
   43:         if self.implementation == "PyPy":
   44:             self.pypy_version_info = tuple(sys.pypy_version_info)
   45: 
   46:         # this is a tuple in earlier, struct later, unify to our own named tuple
   47:         self.version_info = VersionInfo(*sys.version_info)
   48:         # Use the same implementation as found in stdlib platform.architecture
   49:         # to account for platforms where the maximum integer is not equal the
   50:         # pointer size.
   51:         self.architecture = 32 if struct.calcsize("P") == 4 else 64  # noqa: PLR2004
   52: 
   53:         # Used to determine some file names.
   54:         # See `CPython3Windows.python_zip()`.
   55:         self.version_nodot = sysconfig.get_config_var("py_version_nodot")
   56: 
   57:         self.version = sys.version
   58:         self.os = os.name
   59:         self.free_threaded = sysconfig.get_config_var("Py_GIL_DISABLED") == 1
   60: 
   61:         # information about the prefix - determines python home
   62:         self.prefix = abs_path(getattr(sys, "prefix", None))  # prefix we think
   63:         self.base_prefix = abs_path(getattr(sys, "base_prefix", None))  # venv
   64:         self.real_prefix = abs_path(getattr(sys, "real_prefix", None))  # old virtualenv
   65: 
   66:         # information about the exec prefix - dynamic stdlib modules
   67:         self.base_exec_prefix = abs_path(getattr(sys, "base_exec_prefix", None))
   68:         self.exec_prefix = abs_path(getattr(sys, "exec_prefix", None))
   69: 
   70:         self.executable = abs_path(sys.executable)  # the executable we were invoked via
   71:         self.original_executable = abs_path(self.executable)  # the executable as known by the interpreter
   72:         self.system_executable = self._fast_get_system_executable()  # the executable we are based of (if available)
   73: 
   74:         try:
   75:             __import__("venv")
   76:             has = True
   77:         except ImportError:
   78:             has = False
   79:         self.has_venv = has
   80:         self.path = sys.path
   81:         self.file_system_encoding = sys.getfilesystemencoding()
   82:         self.stdout_encoding = getattr(sys.stdout, "encoding", None)
   83: 
   84:         scheme_names = sysconfig.get_scheme_names()
   85: 
   86:         if "venv" in scheme_names:
   87:             self.sysconfig_scheme = "venv"
   88:             self.sysconfig_paths = {
   89:                 i: sysconfig.get_path(i, expand=False, scheme=self.sysconfig_scheme) for i in sysconfig.get_path_names()
   90:             }
   91:             # we cannot use distutils at all if "venv" exists, distutils don't know it
   92:             self.distutils_install = {}
   93:         # debian / ubuntu python 3.10 without `python3-distutils` will report
   94:         # mangled `local/bin` / etc. names for the default prefix
   95:         # intentionally select `posix_prefix` which is the unaltered posix-like paths
   96:         elif sys.version_info[:2] == (3, 10) and "deb_system" in scheme_names:
   97:             self.sysconfig_scheme = "posix_prefix"
   98:             self.sysconfig_paths = {
   99:                 i: sysconfig.get_path(i, expand=False, scheme=self.sysconfig_scheme) for i in sysconfig.get_path_names()
  100:             }
  101:             # we cannot use distutils at all if "venv" exists, distutils don't know it
  102:             self.distutils_install = {}
  103:         else:
  104:             self.sysconfig_scheme = None
  105:             self.sysconfig_paths = {i: sysconfig.get_path(i, expand=False) for i in sysconfig.get_path_names()}
  106:             self.distutils_install = self._distutils_install().copy()
  107: 
  108:         # https://bugs.python.org/issue22199
  109:         makefile = getattr(sysconfig, "get_makefile_filename", getattr(sysconfig, "_get_makefile_filename", None))
  110:         self.sysconfig = {
  111:             k: v
  112:             for k, v in [
  113:                 # a list of content to store from sysconfig
  114:                 ("makefile_filename", makefile()),
  115:             ]
  116:             if k is not None
  117:         }
  118: 
  119:         config_var_keys = set()
  120:         for element in self.sysconfig_paths.values():
  121:             config_var_keys.update(k[1:-1] for k in _CONF_VAR_RE.findall(element))
  122:         config_var_keys.add("PYTHONFRAMEWORK")
  123: 
  124:         self.sysconfig_vars = {i: sysconfig.get_config_var(i or "") for i in config_var_keys}
  125: 
  126:         if "TCL_LIBRARY" in os.environ:
  127:             self.tcl_lib, self.tk_lib = self._get_tcl_tk_libs()
  128:         else:
  129:             self.tcl_lib, self.tk_lib = None, None
  130: 
  131:         confs = {
  132:             k: (self.system_prefix if v is not None and v.startswith(self.prefix) else v)
  133:             for k, v in self.sysconfig_vars.items()
  134:         }
  135:         self.system_stdlib = self.sysconfig_path("stdlib", confs)
  136:         self.system_stdlib_platform = self.sysconfig_path("platstdlib", confs)
  137:         self.max_size = getattr(sys, "maxsize", getattr(sys, "maxint", None))
  138: 
  139:     @staticmethod
  140:     def _get_tcl_tk_libs():
  141:         """
  142:         Detects the tcl and tk libraries using tkinter.
  143: 
  144:         This works reliably but spins up tkinter, which is heavy if you don't need it.
  145:         """
  146:         tcl_lib, tk_lib = None, None
  147:         try:
  148:             import tkinter as tk  # noqa: PLC0415
  149:         except ImportError:
  150:             pass
  151:         else:
  152:             try:
  153:                 tcl = tk.Tcl()
  154:                 tcl_lib = tcl.eval("info library")
  155: 
  156:                 # Try to get TK library path directly first
  157:                 try:
  158:                     tk_lib = tcl.eval("set tk_library")
  159:                     if tk_lib and os.path.isdir(tk_lib):
  160:                         pass  # We found it directly
  161:                     else:
  162:                         tk_lib = None  # Reset if invalid
  163:                 except tk.TclError:
  164:                     tk_lib = None
  165: 
  166:                 # If direct query failed, try constructing the path
  167:                 if tk_lib is None:
  168:                     tk_version = tcl.eval("package require Tk")
  169:                     tcl_parent = os.path.dirname(tcl_lib)
  170: 
  171:                     # Try different version formats
  172:                     version_variants = [
  173:                         tk_version,  # Full version like "8.6.12"
  174:                         ".".join(tk_version.split(".")[:2]),  # Major.minor like "8.6"
  175:                         tk_version.split(".")[0],  # Just major like "8"
  176:                     ]
  177: 
  178:                     for version in version_variants:
  179:                         tk_lib_path = os.path.join(tcl_parent, f"tk{version}")
  180:                         if not os.path.isdir(tk_lib_path):
  181:                             continue
  182:                         # Validate it's actually a TK directory
  183:                         if os.path.exists(os.path.join(tk_lib_path, "tk.tcl")):
  184:                             tk_lib = tk_lib_path
  185:                             break
  186: 
  187:             except tk.TclError:
  188:                 pass
  189: 
  190:         return tcl_lib, tk_lib
  191: 
  192:     def _fast_get_system_executable(self):
  193:         """Try to get the system executable by just looking at properties."""
  194:         # if we're not in a virtual environment, this is already a system python, so return the original executable
  195:         # note we must choose the original and not the pure executable as shim scripts might throw us off
  196:         if not (self.real_prefix or (self.base_prefix is not None and self.base_prefix != self.prefix)):
  197:             return self.original_executable
  198: 
  199:         # if this is NOT a virtual environment, can't determine easily, bail out
  200:         if self.real_prefix is not None:
  201:             return None
  202: 
  203:         base_executable = getattr(sys, "_base_executable", None)  # some platforms may set this to help us
  204:         if base_executable is None:  # use the saved system executable if present
  205:             return None
  206: 
  207:         # we know we're in a virtual environment, can not be us
  208:         if sys.executable == base_executable:
  209:             return None
  210: 
  211:         # We're not in a venv and base_executable exists; use it directly
  212:         if os.path.exists(base_executable):
  213:             return base_executable
  214: 
  215:         # Try fallback for POSIX virtual environments
  216:         return self._try_posix_fallback_executable(base_executable)
  217: 
  218:     def _try_posix_fallback_executable(self, base_executable):
  219:         """
  220:         Try to find a versioned Python binary as fallback for POSIX virtual environments.
  221: 
  222:         Python may return "python" because it was invoked from the POSIX virtual environment
  223:         however some installs/distributions do not provide a version-less "python" binary in
  224:         the system install location (see PEP 394) so try to fallback to a versioned binary.
  225: 
  226:         Gate this to Python 3.11 as `sys._base_executable` path resolution is now relative to
  227:         the 'home' key from pyvenv.cfg which often points to the system install location.
  228:         """
  229:         major, minor = self.version_info.major, self.version_info.minor
  230:         if self.os != "posix" or (major, minor) < (3, 11):
  231:             return None
  232: 
  233:         # search relative to the directory of sys._base_executable
  234:         base_dir = os.path.dirname(base_executable)
  235:         candidates = [f"python{major}", f"python{major}.{minor}"]
  236:         if self.implementation == "PyPy":
  237:             candidates.extend(["pypy", "pypy3", f"pypy{major}", f"pypy{major}.{minor}"])
  238: 
  239:         for candidate in candidates:
  240:             full_path = os.path.join(base_dir, candidate)
  241:             if os.path.exists(full_path):
  242:                 return full_path
  243: 
  244:         return None  # in this case we just can't tell easily without poking around FS and calling them, bail
  245: 
  246:     def install_path(self, key):
  247:         result = self.distutils_install.get(key)
  248:         if result is None:  # use sysconfig if sysconfig_scheme is set or distutils is unavailable
  249:             # set prefixes to empty => result is relative from cwd
  250:             prefixes = self.prefix, self.exec_prefix, self.base_prefix, self.base_exec_prefix
  251:             config_var = {k: "" if v in prefixes else v for k, v in self.sysconfig_vars.items()}
  252:             result = self.sysconfig_path(key, config_var=config_var).lstrip(os.sep)
  253:         return result
  254: 
  255:     @staticmethod
  256:     def _distutils_install():
  257:         # use distutils primarily because that's what pip does
  258:         # https://github.com/pypa/pip/blob/main/src/pip/_internal/locations.py#L95
  259:         # note here we don't import Distribution directly to allow setuptools to patch it
  260:         with warnings.catch_warnings():  # disable warning for PEP-632
  261:             warnings.simplefilter("ignore")
  262:             try:
  263:                 from distutils import dist  # noqa: PLC0415
  264:                 from distutils.command.install import SCHEME_KEYS  # noqa: PLC0415
  265:             except ImportError:  # if removed or not installed ignore
  266:                 return {}
  267: 
  268:         d = dist.Distribution({"script_args": "--no-user-cfg"})  # conf files not parsed so they do not hijack paths
  269:         if hasattr(sys, "_framework"):
  270:             sys._framework = None  # disable macOS static paths for framework  # noqa: SLF001
  271: 
  272:         with warnings.catch_warnings():  # disable warning for PEP-632
  273:             warnings.simplefilter("ignore")
  274:             i = d.get_command_obj("install", create=True)
  275: 
  276:         i.prefix = os.sep  # paths generated are relative to prefix that contains the path sep, this makes it relative
  277:         i.finalize_options()
  278:         return {key: (getattr(i, f"install_{key}")[1:]).lstrip(os.sep) for key in SCHEME_KEYS}
  279: 
  280:     @property
  281:     def version_str(self):
  282:         return ".".join(str(i) for i in self.version_info[0:3])
  283: 
  284:     @property
  285:     def version_release_str(self):
  286:         return ".".join(str(i) for i in self.version_info[0:2])
  287: 
  288:     @property
  289:     def python_name(self):
  290:         version_info = self.version_info
  291:         return f"python{version_info.major}.{version_info.minor}"
  292: 
  293:     @property
  294:     def is_old_virtualenv(self):
  295:         return self.real_prefix is not None
  296: 
  297:     @property
  298:     def is_venv(self):
  299:         return self.base_prefix is not None
  300: 
  301:     def sysconfig_path(self, key, config_var=None, sep=os.sep):
  302:         pattern = self.sysconfig_paths.get(key)
  303:         if pattern is None:
  304:             return ""
  305:         if config_var is None:
  306:             config_var = self.sysconfig_vars
  307:         else:
  308:             base = self.sysconfig_vars.copy()
  309:             base.update(config_var)
  310:             config_var = base
  311:         return pattern.format(**config_var).replace("/", sep)
  312: 
  313:     @property
  314:     def system_include(self):
  315:         path = self.sysconfig_path(
  316:             "include",
  317:             {
  318:                 k: (self.system_prefix if v is not None and v.startswith(self.prefix) else v)
  319:                 for k, v in self.sysconfig_vars.items()
  320:             },
  321:         )
  322:         if not os.path.exists(path):  # some broken packaging don't respect the sysconfig, fallback to distutils path
  323:             # the pattern include the distribution name too at the end, remove that via the parent call
  324:             fallback = os.path.join(self.prefix, os.path.dirname(self.install_path("headers")))
  325:             if os.path.exists(fallback):
  326:                 path = fallback
  327:         return path
  328: 
  329:     @property
  330:     def system_prefix(self):
  331:         return self.real_prefix or self.base_prefix or self.prefix
  332: 
  333:     @property
  334:     def system_exec_prefix(self):
  335:         return self.real_prefix or self.base_exec_prefix or self.exec_prefix
  336: 
  337:     def __repr__(self) -> str:
  338:         return "{}({!r})".format(
  339:             self.__class__.__name__,
  340:             {k: v for k, v in self.__dict__.items() if not k.startswith("_")},
  341:         )
  342: 
  343:     def __str__(self) -> str:
  344:         return "{}({})".format(
  345:             self.__class__.__name__,
  346:             ", ".join(
  347:                 f"{k}={v}"
  348:                 for k, v in (
  349:                     ("spec", self.spec),
  350:                     (
  351:                         "system"
  352:                         if self.system_executable is not None and self.system_executable != self.executable
  353:                         else None,
  354:                         self.system_executable,
  355:                     ),
  356:                     (
  357:                         "original"
  358:                         if self.original_executable not in {self.system_executable, self.executable}
  359:                         else None,
  360:                         self.original_executable,
  361:                     ),
  362:                     ("exe", self.executable),
  363:                     ("platform", self.platform),
  364:                     ("version", repr(self.version)),
  365:                     ("encoding_fs_io", f"{self.file_system_encoding}-{self.stdout_encoding}"),
  366:                 )
  367:                 if k is not None
  368:             ),
  369:         )
  370: 
  371:     @property
  372:     def spec(self):
  373:         return "{}{}{}-{}".format(
  374:             self.implementation,
  375:             ".".join(str(i) for i in self.version_info),
  376:             "t" if self.free_threaded else "",
  377:             self.architecture,
  378:         )
  379: 
  380:     @classmethod
  381:     def clear_cache(cls, app_data, cache=None):
  382:         # this method is not used by itself, so here and called functions can import stuff locally
  383:         from virtualenv.discovery.cached_py_info import clear  # noqa: PLC0415
  384: 
  385:         clear(app_data, cache)
  386:         cls._cache_exe_discovery.clear()
  387: 
  388:     def satisfies(self, spec, impl_must_match):  # noqa: C901, PLR0911
  389:         """Check if a given specification can be satisfied by the this python interpreter instance."""
  390:         if spec.path:
  391:             if self.executable == os.path.abspath(spec.path):
  392:                 return True  # if the path is a our own executable path we're done
  393:             if not spec.is_abs:
  394:                 # if path set, and is not our original executable name, this does not match
  395:                 basename = os.path.basename(self.original_executable)
  396:                 spec_path = spec.path
  397:                 if sys.platform == "win32":
  398:                     basename, suffix = os.path.splitext(basename)
  399:                     if spec_path.endswith(suffix):
  400:                         spec_path = spec_path[: -len(suffix)]
  401:                 if basename != spec_path:
  402:                     return False
  403: 
  404:         if (
  405:             impl_must_match
  406:             and spec.implementation is not None
  407:             and spec.implementation.lower() != self.implementation.lower()
  408:         ):
  409:             return False
  410: 
  411:         if spec.architecture is not None and spec.architecture != self.architecture:
  412:             return False
  413: 
  414:         if spec.free_threaded is not None and spec.free_threaded != self.free_threaded:
  415:             return False
  416: 
  417:         for our, req in zip(self.version_info[0:3], (spec.major, spec.minor, spec.micro)):
  418:             if req is not None and our is not None and our != req:
  419:                 return False
  420:         return True
  421: 
  422:     _current_system = None
  423:     _current = None
  424: 
  425:     @classmethod
  426:     def current(cls, app_data=None, cache=None):
  427:         """
  428:         This locates the current host interpreter information. This might be different than what we run into in case
  429:         the host python has been upgraded from underneath us.
  430:         """  # noqa: D205
  431:         if cls._current is None:
  432:             cls._current = cls.from_exe(
  433:                 sys.executable,
  434:                 app_data,
  435:                 raise_on_error=True,
  436:                 resolve_to_host=False,
  437:                 cache=cache,
  438:             )
  439:         return cls._current
  440: 
  441:     @classmethod
  442:     def current_system(cls, app_data=None, cache=None) -> PythonInfo:
  443:         """
  444:         This locates the current host interpreter information. This might be different than what we run into in case
  445:         the host python has been upgraded from underneath us.
  446:         """  # noqa: D205
  447:         if cls._current_system is None:
  448:             cls._current_system = cls.from_exe(
  449:                 sys.executable,
  450:                 app_data,
  451:                 raise_on_error=True,
  452:                 resolve_to_host=True,
  453:                 cache=cache,
  454:             )
  455:         return cls._current_system
  456: 
  457:     def _to_json(self):
  458:         # don't save calculated paths, as these are non primitive types
  459:         return json.dumps(self._to_dict(), indent=2)
  460: 
  461:     def _to_dict(self):
  462:         data = {var: getattr(self, var) for var in vars(self)}
  463:         data["version_info"] = data["version_info"]._asdict()  # namedtuple to dictionary
  464:         return data
  465: 
  466:     @classmethod
  467:     def from_exe(  # noqa: PLR0913
  468:         cls,
  469:         exe,
  470:         app_data=None,
  471:         raise_on_error=True,  # noqa: FBT002
  472:         ignore_cache=False,  # noqa: FBT002
  473:         resolve_to_host=True,  # noqa: FBT002
  474:         env=None,
  475:         cache=None,
  476:     ):
  477:         """Given a path to an executable get the python information."""
  478:         # this method is not used by itself, so here and called functions can import stuff locally
  479:         from virtualenv.discovery.cached_py_info import from_exe as from_exe_cache  # noqa: PLC0415
  480: 
  481:         env = os.environ if env is None else env
  482:         proposed = from_exe_cache(
  483:             cls,
  484:             app_data,
  485:             exe,
  486:             env=env,
  487:             raise_on_error=raise_on_error,
  488:             ignore_cache=ignore_cache,
  489:             cache=cache,
  490:         )
  491: 
  492:         if isinstance(proposed, PythonInfo) and resolve_to_host:
  493:             try:
  494:                 proposed = proposed._resolve_to_system(app_data, proposed, cache=cache)  # noqa: SLF001
  495:             except Exception as exception:
  496:                 if raise_on_error:
  497:                     raise
  498:                 LOGGER.info("ignore %s due cannot resolve system due to %r", proposed.original_executable, exception)
  499:                 proposed = None
  500:         return proposed
  501: 
  502:     @classmethod
  503:     def _from_json(cls, payload):
  504:         # the dictionary unroll here is to protect against pypy bug of interpreter crashing
  505:         raw = json.loads(payload)
  506:         return cls._from_dict(raw.copy())
  507: 
  508:     @classmethod
  509:     def _from_dict(cls, data):
  510:         data["version_info"] = VersionInfo(**data["version_info"])  # restore this to a named tuple structure
  511:         result = cls()
  512:         result.__dict__ = data.copy()
  513:         return result
  514: 
  515:     @classmethod
  516:     def _resolve_to_system(cls, app_data, target, cache=None):
  517:         start_executable = target.executable
  518:         prefixes = OrderedDict()
  519:         while target.system_executable is None:
  520:             prefix = target.real_prefix or target.base_prefix or target.prefix
  521:             if prefix in prefixes:
  522:                 if len(prefixes) == 1:
  523:                     # if we're linking back to ourselves accept ourselves with a WARNING
  524:                     LOGGER.info("%r links back to itself via prefixes", target)
  525:                     target.system_executable = target.executable
  526:                     break
  527:                 for at, (p, t) in enumerate(prefixes.items(), start=1):
  528:                     LOGGER.error("%d: prefix=%s, info=%r", at, p, t)
  529:                 LOGGER.error("%d: prefix=%s, info=%r", len(prefixes) + 1, prefix, target)
  530:                 msg = "prefixes are causing a circle {}".format("|".join(prefixes.keys()))
  531:                 raise RuntimeError(msg)
  532:             prefixes[prefix] = target
  533:             target = target.discover_exe(app_data, prefix=prefix, exact=False, cache=cache)
  534:         if target.executable != target.system_executable:
  535:             target = cls.from_exe(target.system_executable, app_data, cache=cache)
  536:         target.executable = start_executable
  537:         return target
  538: 
  539:     _cache_exe_discovery = {}  # noqa: RUF012
  540: 
  541:     def discover_exe(self, app_data, prefix, exact=True, env=None, cache=None):  # noqa: FBT002
  542:         key = prefix, exact
  543:         if key in self._cache_exe_discovery and prefix:
  544:             LOGGER.debug("discover exe from cache %s - exact %s: %r", prefix, exact, self._cache_exe_discovery[key])
  545:             return self._cache_exe_discovery[key]
  546:         LOGGER.debug("discover exe for %s in %s", self, prefix)
  547:         # we don't know explicitly here, do some guess work - our executable name should tell
  548:         possible_names = self._find_possible_exe_names()
  549:         possible_folders = self._find_possible_folders(prefix)
  550:         discovered = []
  551:         env = os.environ if env is None else env
  552:         for folder in possible_folders:
  553:             for name in possible_names:
  554:                 info = self._check_exe(app_data, folder, name, exact, discovered, env, cache)
  555:                 if info is not None:
  556:                     self._cache_exe_discovery[key] = info
  557:                     return info
  558:         if exact is False and discovered:
  559:             info = self._select_most_likely(discovered, self)
  560:             folders = os.pathsep.join(possible_folders)
  561:             self._cache_exe_discovery[key] = info
  562:             LOGGER.debug("no exact match found, chosen most similar of %s within base folders %s", info, folders)
  563:             return info
  564:         msg = "failed to detect {} in {}".format("|".join(possible_names), os.pathsep.join(possible_folders))
  565:         raise RuntimeError(msg)
  566: 
  567:     def _check_exe(self, app_data, folder, name, exact, discovered, env, cache):  # noqa: PLR0913
  568:         exe_path = os.path.join(folder, name)
  569:         if not os.path.exists(exe_path):
  570:             return None
  571:         info = self.from_exe(
  572:             exe_path,
  573:             app_data,
  574:             resolve_to_host=False,
  575:             raise_on_error=False,
  576:             env=env,
  577:             cache=cache,
  578:         )
  579:         if info is None:  # ignore if for some reason we can't query
  580:             return None
  581:         for item in ["implementation", "architecture", "version_info"]:
  582:             found = getattr(info, item)
  583:             searched = getattr(self, item)
  584:             if found != searched:
  585:                 if item == "version_info":
  586:                     found, searched = ".".join(str(i) for i in found), ".".join(str(i) for i in searched)
  587:                 executable = info.executable
  588:                 LOGGER.debug("refused interpreter %s because %s differs %s != %s", executable, item, found, searched)
  589:                 if exact is False:
  590:                     discovered.append(info)
  591:                 break
  592:         else:
  593:             return info
  594:         return None
  595: 
  596:     @staticmethod
  597:     def _select_most_likely(discovered, target):
  598:         # no exact match found, start relaxing our requirements then to facilitate system package upgrades that
  599:         # could cause this (when using copy strategy of the host python)
  600:         def sort_by(info):
  601:             # we need to setup some priority of traits, this is as follows:
  602:             # implementation, major, minor, micro, architecture, tag, serial
  603:             matches = [
  604:                 info.implementation == target.implementation,
  605:                 info.version_info.major == target.version_info.major,
  606:                 info.version_info.minor == target.version_info.minor,
  607:                 info.architecture == target.architecture,
  608:                 info.version_info.micro == target.version_info.micro,
  609:                 info.version_info.releaselevel == target.version_info.releaselevel,
  610:                 info.version_info.serial == target.version_info.serial,
  611:             ]
  612:             return sum((1 << pos if match else 0) for pos, match in enumerate(reversed(matches)))
  613: 
  614:         sorted_discovered = sorted(discovered, key=sort_by, reverse=True)  # sort by priority in decreasing order
  615:         return sorted_discovered[0]
  616: 
  617:     def _find_possible_folders(self, inside_folder):
  618:         candidate_folder = OrderedDict()
  619:         executables = OrderedDict()
  620:         executables[os.path.realpath(self.executable)] = None
  621:         executables[self.executable] = None
  622:         executables[os.path.realpath(self.original_executable)] = None
  623:         executables[self.original_executable] = None
  624:         for exe in executables:
  625:             base = os.path.dirname(exe)
  626:             # following path pattern of the current
  627:             if base.startswith(self.prefix):
  628:                 relative = base[len(self.prefix) :]
  629:                 candidate_folder[f"{inside_folder}{relative}"] = None
  630: 
  631:         # or at root level
  632:         candidate_folder[inside_folder] = None
  633:         return [i for i in candidate_folder if os.path.exists(i)]
  634: 
  635:     def _find_possible_exe_names(self):
  636:         name_candidate = OrderedDict()
  637:         for name in self._possible_base():
  638:             for at in (3, 2, 1, 0):
  639:                 version = ".".join(str(i) for i in self.version_info[:at])
  640:                 mods = [""]
  641:                 if self.free_threaded:
  642:                     mods.append("t")
  643:                 for mod in mods:
  644:                     for arch in [f"-{self.architecture}", ""]:
  645:                         for ext in EXTENSIONS:
  646:                             candidate = f"{name}{version}{mod}{arch}{ext}"
  647:                             name_candidate[candidate] = None
  648:         return list(name_candidate.keys())
  649: 
  650:     def _possible_base(self):
  651:         possible_base = OrderedDict()
  652:         basename = os.path.splitext(os.path.basename(self.executable))[0].rstrip(digits)
  653:         possible_base[basename] = None
  654:         possible_base[self.implementation] = None
  655:         # python is always the final option as in practice is used by multiple implementation as exe name
  656:         if "python" in possible_base:
  657:             del possible_base["python"]
  658:         possible_base["python"] = None
  659:         for base in possible_base:
  660:             lower = base.lower()
  661:             yield lower
  662: 
  663:             from .info import fs_is_case_sensitive  # noqa: PLC0415
  664: 
  665:             if fs_is_case_sensitive():
  666:                 if base != lower:
  667:                     yield base
  668:                 upper = base.upper()
  669:                 if upper != base:
  670:                     yield upper
  671: 
  672: 
  673: if __name__ == "__main__":
  674:     # dump a JSON representation of the current python
  675: 
  676:     argv = sys.argv[1:]
  677: 
  678:     if len(argv) >= 1:
  679:         start_cookie = argv[0]
  680:         argv = argv[1:]
  681:     else:
  682:         start_cookie = ""
  683: 
  684:     if len(argv) >= 1:
  685:         end_cookie = argv[0]
  686:         argv = argv[1:]
  687:     else:
  688:         end_cookie = ""
  689: 
  690:     sys.argv = sys.argv[:1] + argv
  691: 
  692:     info = PythonInfo()._to_json()  # noqa: SLF001
  693:     sys.stdout.write("".join((start_cookie[::-1], info, end_cookie[::-1])))
