    1: """
    2: 
    3: We acquire the python information by running an interrogation script via subprocess trigger. This operation is not
    4: cheap, especially not on Windows. To not have to pay this hefty cost every time we apply multiple levels of
    5: caching.
    6: """  # noqa: D205
    7: 
    8: from __future__ import annotations
    9: 
   10: import hashlib
   11: import importlib.util
   12: import logging
   13: import os
   14: import random
   15: import subprocess
   16: import sys
   17: from collections import OrderedDict
   18: from pathlib import Path
   19: from shlex import quote
   20: from string import ascii_lowercase, ascii_uppercase, digits
   21: from typing import TYPE_CHECKING
   22: 
   23: from virtualenv.app_data.na import AppDataDisabled
   24: from virtualenv.cache import FileCache
   25: 
   26: if TYPE_CHECKING:
   27:     from virtualenv.app_data.base import AppData
   28:     from virtualenv.cache import Cache
   29: from virtualenv.discovery.py_info import PythonInfo
   30: 
   31: _CACHE = OrderedDict()
   32: _CACHE[Path(sys.executable)] = PythonInfo()
   33: LOGGER = logging.getLogger(__name__)
   34: 
   35: 
   36: def from_exe(  # noqa: PLR0913
   37:     cls,
   38:     app_data,
   39:     exe,
   40:     env=None,
   41:     *,
   42:     raise_on_error=True,
   43:     ignore_cache=False,
   44:     cache: Cache | None = None,
   45: ) -> PythonInfo | None:
   46:     env = os.environ if env is None else env
   47:     if cache is None:
   48:         if app_data is None:
   49:             app_data = AppDataDisabled()
   50:         cache = FileCache(store_factory=app_data.py_info, clearer=app_data.py_info_clear)
   51:     result = _get_from_cache(cls, app_data, exe, env, cache, ignore_cache=ignore_cache)
   52:     if isinstance(result, Exception):
   53:         if raise_on_error:
   54:             raise result
   55:         LOGGER.info("%s", result)
   56:         result = None
   57:     return result
   58: 
   59: 
   60: def _get_from_cache(cls, app_data: AppData, exe: str, env, cache: Cache, *, ignore_cache: bool) -> PythonInfo:  # noqa: PLR0913
   61:     # note here we cannot resolve symlinks, as the symlink may trigger different prefix information if there's a
   62:     # pyenv.cfg somewhere alongside on python3.5+
   63:     exe_path = Path(exe)
   64:     if not ignore_cache and exe_path in _CACHE:  # check in the in-memory cache
   65:         result = _CACHE[exe_path]
   66:     else:  # otherwise go through the app data cache
   67:         result = _CACHE[exe_path] = _get_via_file_cache(cls, app_data, exe_path, exe, env, cache)
   68:     # independent if it was from the file or in-memory cache fix the original executable location
   69:     if isinstance(result, PythonInfo):
   70:         result.executable = exe
   71:     return result
   72: 
   73: 
   74: def _get_via_file_cache(cls, app_data: AppData, path: Path, exe: str, env, cache: Cache) -> PythonInfo:  # noqa: PLR0913
   75:     # 1. get the hash of the probing script
   76:     spec = importlib.util.find_spec("virtualenv.discovery.py_info")
   77:     script = Path(spec.origin)
   78:     try:
   79:         py_info_hash = hashlib.sha256(script.read_bytes()).hexdigest()
   80:     except OSError:
   81:         py_info_hash = None
   82: 
   83:     # 2. get the mtime of the python executable
   84:     try:
   85:         path_modified = path.stat().st_mtime
   86:     except OSError:
   87:         path_modified = -1
   88: 
   89:     # 3. check if we have a valid cache entry
   90:     py_info = None
   91:     data = cache.get(path)
   92:     if data is not None:
   93:         if data.get("path") == str(path) and data.get("st_mtime") == path_modified and data.get("hash") == py_info_hash:
   94:             py_info = cls._from_dict(data.get("content"))
   95:             sys_exe = py_info.system_executable
   96:             if sys_exe is not None and not os.path.exists(sys_exe):
   97:                 py_info = None  # if system executable is no longer there, this is not valid
   98:         if py_info is None:
   99:             cache.remove(path)  # if cache is invalid, remove it
  100: 
  101:     if py_info is None:  # if not loaded run and save
  102:         failure, py_info = _run_subprocess(cls, exe, app_data, env)
  103:         if failure is None:
  104:             data = {
  105:                 "st_mtime": path_modified,
  106:                 "path": str(path),
  107:                 "content": py_info._to_dict(),  # noqa: SLF001
  108:                 "hash": py_info_hash,
  109:             }
  110:             cache.set(path, data)
  111:         else:
  112:             py_info = failure
  113:     return py_info
  114: 
  115: 
  116: COOKIE_LENGTH: int = 32
  117: 
  118: 
  119: def gen_cookie():
  120:     return "".join(
  121:         random.choice(f"{ascii_lowercase}{ascii_uppercase}{digits}")  # noqa: S311
  122:         for _ in range(COOKIE_LENGTH)
  123:     )
  124: 
  125: 
  126: def _run_subprocess(cls, exe, app_data, env):
  127:     py_info_script = Path(os.path.abspath(__file__)).parent / "py_info.py"
  128:     # Cookies allow to split the serialized stdout output generated by the script collecting the info from the output
  129:     # generated by something else. The right way to deal with it is to create an anonymous pipe and pass its descriptor
  130:     # to the child and output to it. But AFAIK all of them are either not cross-platform or too big to implement and are
  131:     # not in the stdlib. So the easiest and the shortest way I could mind is just using the cookies.
  132:     # We generate pseudorandom cookies because it easy to implement and avoids breakage from outputting modules source
  133:     # code, i.e. by debug output libraries. We reverse the cookies to avoid breakages resulting from variable values
  134:     # appearing in debug output.
  135: 
  136:     start_cookie = gen_cookie()
  137:     end_cookie = gen_cookie()
  138:     if app_data is None:
  139:         app_data = AppDataDisabled()
  140:     with app_data.ensure_extracted(py_info_script) as py_info_script:
  141:         cmd = [exe, str(py_info_script), start_cookie, end_cookie]
  142:         # prevent sys.prefix from leaking into the child process - see https://bugs.python.org/issue22490
  143:         env = env.copy()
  144:         env.pop("__PYVENV_LAUNCHER__", None)
  145:         LOGGER.debug("get interpreter info via cmd: %s", LogCmd(cmd))
  146:         try:
  147:             process = subprocess.Popen(
  148:                 cmd,
  149:                 universal_newlines=True,
  150:                 stdin=subprocess.PIPE,
  151:                 stderr=subprocess.PIPE,
  152:                 stdout=subprocess.PIPE,
  153:                 env=env,
  154:                 encoding="utf-8",
  155:             )
  156:             out, err = process.communicate()
  157:             code = process.returncode
  158:         except OSError as os_error:
  159:             out, err, code = "", os_error.strerror, os_error.errno
  160:     result, failure = None, None
  161:     if code == 0:
  162:         out_starts = out.find(start_cookie[::-1])
  163: 
  164:         if out_starts > -1:
  165:             pre_cookie = out[:out_starts]
  166: 
  167:             if pre_cookie:
  168:                 sys.stdout.write(pre_cookie)
  169: 
  170:             out = out[out_starts + COOKIE_LENGTH :]
  171: 
  172:         out_ends = out.find(end_cookie[::-1])
  173: 
  174:         if out_ends > -1:
  175:             post_cookie = out[out_ends + COOKIE_LENGTH :]
  176: 
  177:             if post_cookie:
  178:                 sys.stdout.write(post_cookie)
  179: 
  180:             out = out[:out_ends]
  181: 
  182:         result = cls._from_json(out)
  183:         result.executable = exe  # keep original executable as this may contain initialization code
  184:     else:
  185:         msg = f"{exe} with code {code}{f' out: {out!r}' if out else ''}{f' err: {err!r}' if err else ''}"
  186:         failure = RuntimeError(f"failed to query {msg}")
  187:     return failure, result
  188: 
  189: 
  190: class LogCmd:
  191:     def __init__(self, cmd, env=None) -> None:
  192:         self.cmd = cmd
  193:         self.env = env
  194: 
  195:     def __repr__(self) -> str:
  196:         cmd_repr = " ".join(quote(str(c)) for c in self.cmd)
  197:         if self.env is not None:
  198:             cmd_repr = f"{cmd_repr} env of {self.env!r}"
  199:         return cmd_repr
  200: 
  201: 
  202: def clear(app_data=None, cache=None):
  203:     """Clear the cache."""
  204:     if cache is None and app_data is not None:
  205:         cache = FileCache(store_factory=app_data.py_info, clearer=app_data.py_info_clear)
  206:     if cache is not None:
  207:         cache.clear()
  208:     _CACHE.clear()
  209: 
  210: 
  211: ___all___ = [
  212:     "from_exe",
  213:     "clear",
  214:     "LogCmd",
  215: ]
