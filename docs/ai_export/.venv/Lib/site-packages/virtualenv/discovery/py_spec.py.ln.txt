    1: """A Python specification is an abstract requirement definition of an interpreter."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import os
    6: import re
    7: 
    8: PATTERN = re.compile(r"^(?P<impl>[a-zA-Z]+)?(?P<version>[0-9.]+)?(?P<threaded>t)?(?:-(?P<arch>32|64))?$")
    9: 
   10: 
   11: class PythonSpec:
   12:     """Contains specification about a Python Interpreter."""
   13: 
   14:     def __init__(  # noqa: PLR0913
   15:         self,
   16:         str_spec: str,
   17:         implementation: str | None,
   18:         major: int | None,
   19:         minor: int | None,
   20:         micro: int | None,
   21:         architecture: int | None,
   22:         path: str | None,
   23:         *,
   24:         free_threaded: bool | None = None,
   25:     ) -> None:
   26:         self.str_spec = str_spec
   27:         self.implementation = implementation
   28:         self.major = major
   29:         self.minor = minor
   30:         self.micro = micro
   31:         self.free_threaded = free_threaded
   32:         self.architecture = architecture
   33:         self.path = path
   34: 
   35:     @classmethod
   36:     def from_string_spec(cls, string_spec: str):  # noqa: C901, PLR0912
   37:         impl, major, minor, micro, threaded, arch, path = None, None, None, None, None, None, None
   38:         if os.path.isabs(string_spec):  # noqa: PLR1702
   39:             path = string_spec
   40:         else:
   41:             ok = False
   42:             match = re.match(PATTERN, string_spec)
   43:             if match:
   44: 
   45:                 def _int_or_none(val):
   46:                     return None if val is None else int(val)
   47: 
   48:                 try:
   49:                     groups = match.groupdict()
   50:                     version = groups["version"]
   51:                     if version is not None:
   52:                         versions = tuple(int(i) for i in version.split(".") if i)
   53:                         if len(versions) > 3:  # noqa: PLR2004
   54:                             raise ValueError  # noqa: TRY301
   55:                         if len(versions) == 3:  # noqa: PLR2004
   56:                             major, minor, micro = versions
   57:                         elif len(versions) == 2:  # noqa: PLR2004
   58:                             major, minor = versions
   59:                         elif len(versions) == 1:
   60:                             version_data = versions[0]
   61:                             major = int(str(version_data)[0])  # first digit major
   62:                             if version_data > 9:  # noqa: PLR2004
   63:                                 minor = int(str(version_data)[1:])
   64:                         threaded = bool(groups["threaded"])
   65:                     ok = True
   66:                 except ValueError:
   67:                     pass
   68:                 else:
   69:                     impl = groups["impl"]
   70:                     if impl in {"py", "python"}:
   71:                         impl = None
   72:                     arch = _int_or_none(groups["arch"])
   73: 
   74:             if not ok:
   75:                 path = string_spec
   76: 
   77:         return cls(string_spec, impl, major, minor, micro, arch, path, free_threaded=threaded)
   78: 
   79:     def generate_re(self, *, windows: bool) -> re.Pattern:
   80:         """Generate a regular expression for matching against a filename."""
   81:         version = r"{}(\.{}(\.{})?)?".format(
   82:             *(r"\d+" if v is None else v for v in (self.major, self.minor, self.micro))
   83:         )
   84:         impl = "python" if self.implementation is None else f"python|{re.escape(self.implementation)}"
   85:         mod = "t?" if self.free_threaded else ""
   86:         suffix = r"\.exe" if windows else ""
   87:         version_conditional = (
   88:             "?"
   89:             # Windows Python executables are almost always unversioned
   90:             if windows
   91:             # Spec is an empty string
   92:             or self.major is None
   93:             else ""
   94:         )
   95:         # Try matching `direct` first, so the `direct` group is filled when possible.
   96:         return re.compile(
   97:             rf"(?P<impl>{impl})(?P<v>{version}{mod}){version_conditional}{suffix}$",
   98:             flags=re.IGNORECASE,
   99:         )
  100: 
  101:     @property
  102:     def is_abs(self):
  103:         return self.path is not None and os.path.isabs(self.path)
  104: 
  105:     def satisfies(self, spec):
  106:         """Called when there's a candidate metadata spec to see if compatible - e.g. PEP-514 on Windows."""
  107:         if spec.is_abs and self.is_abs and self.path != spec.path:
  108:             return False
  109:         if spec.implementation is not None and spec.implementation.lower() != self.implementation.lower():
  110:             return False
  111:         if spec.architecture is not None and spec.architecture != self.architecture:
  112:             return False
  113:         if spec.free_threaded is not None and spec.free_threaded != self.free_threaded:
  114:             return False
  115: 
  116:         for our, req in zip((self.major, self.minor, self.micro), (spec.major, spec.minor, spec.micro)):
  117:             if req is not None and our is not None and our != req:
  118:                 return False
  119:         return True
  120: 
  121:     def __repr__(self) -> str:
  122:         name = type(self).__name__
  123:         params = "implementation", "major", "minor", "micro", "architecture", "path", "free_threaded"
  124:         return f"{name}({', '.join(f'{k}={getattr(self, k)}' for k in params if getattr(self, k) is not None)})"
  125: 
  126: 
  127: __all__ = [
  128:     "PythonSpec",
  129: ]
