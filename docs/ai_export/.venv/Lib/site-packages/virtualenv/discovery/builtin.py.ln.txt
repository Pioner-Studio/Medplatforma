    1: from __future__ import annotations
    2: 
    3: import logging
    4: import os
    5: import sys
    6: from contextlib import suppress
    7: from pathlib import Path
    8: from typing import TYPE_CHECKING
    9: 
   10: from platformdirs import user_data_path
   11: 
   12: from .discover import Discover
   13: from .info import IS_WIN, fs_path_id
   14: from .py_info import PythonInfo
   15: from .py_spec import PythonSpec
   16: 
   17: if TYPE_CHECKING:
   18:     from argparse import ArgumentParser
   19:     from collections.abc import Callable, Generator, Iterable, Mapping, Sequence
   20: 
   21:     from virtualenv.app_data.base import AppData
   22: LOGGER = logging.getLogger(__name__)
   23: 
   24: 
   25: class Builtin(Discover):
   26:     python_spec: Sequence[str]
   27:     app_data: AppData
   28:     try_first_with: Sequence[str]
   29: 
   30:     def __init__(self, options) -> None:
   31:         super().__init__(options)
   32:         self.python_spec = options.python or [sys.executable]
   33:         if self._env.get("VIRTUALENV_PYTHON"):
   34:             self.python_spec = self.python_spec[1:] + self.python_spec[:1]  # Rotate the list
   35:         self.app_data = options.app_data
   36:         self.try_first_with = options.try_first_with
   37: 
   38:     @classmethod
   39:     def add_parser_arguments(cls, parser: ArgumentParser) -> None:
   40:         parser.add_argument(
   41:             "-p",
   42:             "--python",
   43:             dest="python",
   44:             metavar="py",
   45:             type=str,
   46:             action="append",
   47:             default=[],
   48:             help="interpreter based on what to create environment (path/identifier) "
   49:             "- by default use the interpreter where the tool is installed - first found wins",
   50:         )
   51:         parser.add_argument(
   52:             "--try-first-with",
   53:             dest="try_first_with",
   54:             metavar="py_exe",
   55:             type=str,
   56:             action="append",
   57:             default=[],
   58:             help="try first these interpreters before starting the discovery",
   59:         )
   60: 
   61:     def run(self) -> PythonInfo | None:
   62:         for python_spec in self.python_spec:
   63:             result = get_interpreter(python_spec, self.try_first_with, self.app_data, self._env)
   64:             if result is not None:
   65:                 return result
   66:         return None
   67: 
   68:     def __repr__(self) -> str:
   69:         spec = self.python_spec[0] if len(self.python_spec) == 1 else self.python_spec
   70:         return f"{self.__class__.__name__} discover of python_spec={spec!r}"
   71: 
   72: 
   73: def get_interpreter(
   74:     key, try_first_with: Iterable[str], app_data: AppData | None = None, env: Mapping[str, str] | None = None
   75: ) -> PythonInfo | None:
   76:     spec = PythonSpec.from_string_spec(key)
   77:     LOGGER.info("find interpreter for spec %r", spec)
   78:     proposed_paths = set()
   79:     env = os.environ if env is None else env
   80:     for interpreter, impl_must_match in propose_interpreters(spec, try_first_with, app_data, env):
   81:         key = interpreter.system_executable, impl_must_match
   82:         if key in proposed_paths:
   83:             continue
   84:         LOGGER.info("proposed %s", interpreter)
   85:         if interpreter.satisfies(spec, impl_must_match):
   86:             LOGGER.debug("accepted %s", interpreter)
   87:             return interpreter
   88:         proposed_paths.add(key)
   89:     return None
   90: 
   91: 
   92: def propose_interpreters(  # noqa: C901, PLR0912, PLR0915
   93:     spec: PythonSpec,
   94:     try_first_with: Iterable[str],
   95:     app_data: AppData | None = None,
   96:     env: Mapping[str, str] | None = None,
   97: ) -> Generator[tuple[PythonInfo, bool], None, None]:
   98:     # 0. if it's a path and exists, and is absolute path, this is the only option we consider
   99:     env = os.environ if env is None else env
  100:     tested_exes: set[str] = set()
  101:     if spec.is_abs:
  102:         try:
  103:             os.lstat(spec.path)  # Windows Store Python does not work with os.path.exists, but does for os.lstat
  104:         except OSError:
  105:             pass
  106:         else:
  107:             exe_raw = os.path.abspath(spec.path)
  108:             exe_id = fs_path_id(exe_raw)
  109:             if exe_id not in tested_exes:
  110:                 tested_exes.add(exe_id)
  111:                 yield PythonInfo.from_exe(exe_raw, app_data, env=env), True
  112:         return
  113: 
  114:     # 1. try with first
  115:     for py_exe in try_first_with:
  116:         path = os.path.abspath(py_exe)
  117:         try:
  118:             os.lstat(path)  # Windows Store Python does not work with os.path.exists, but does for os.lstat
  119:         except OSError:
  120:             pass
  121:         else:
  122:             exe_raw = os.path.abspath(path)
  123:             exe_id = fs_path_id(exe_raw)
  124:             if exe_id in tested_exes:
  125:                 continue
  126:             tested_exes.add(exe_id)
  127:             yield PythonInfo.from_exe(exe_raw, app_data, env=env), True
  128: 
  129:     # 1. if it's a path and exists
  130:     if spec.path is not None:
  131:         try:
  132:             os.lstat(spec.path)  # Windows Store Python does not work with os.path.exists, but does for os.lstat
  133:         except OSError:
  134:             pass
  135:         else:
  136:             exe_raw = os.path.abspath(spec.path)
  137:             exe_id = fs_path_id(exe_raw)
  138:             if exe_id not in tested_exes:
  139:                 tested_exes.add(exe_id)
  140:                 yield PythonInfo.from_exe(exe_raw, app_data, env=env), True
  141:         if spec.is_abs:
  142:             return
  143:     else:
  144:         # 2. otherwise try with the current
  145:         current_python = PythonInfo.current_system(app_data)
  146:         exe_raw = str(current_python.executable)
  147:         exe_id = fs_path_id(exe_raw)
  148:         if exe_id not in tested_exes:
  149:             tested_exes.add(exe_id)
  150:             yield current_python, True
  151: 
  152:         # 3. otherwise fallback to platform default logic
  153:         if IS_WIN:
  154:             from .windows import propose_interpreters  # noqa: PLC0415
  155: 
  156:             for interpreter in propose_interpreters(spec, app_data, env):
  157:                 exe_raw = str(interpreter.executable)
  158:                 exe_id = fs_path_id(exe_raw)
  159:                 if exe_id in tested_exes:
  160:                     continue
  161:                 tested_exes.add(exe_id)
  162:                 yield interpreter, True
  163: 
  164:     # try to find on path, the path order matters (as the candidates are less easy to control by end user)
  165:     find_candidates = path_exe_finder(spec)
  166:     for pos, path in enumerate(get_paths(env)):
  167:         LOGGER.debug(LazyPathDump(pos, path, env))
  168:         for exe, impl_must_match in find_candidates(path):
  169:             exe_raw = str(exe)
  170:             exe_id = fs_path_id(exe_raw)
  171:             if exe_id in tested_exes:
  172:                 continue
  173:             tested_exes.add(exe_id)
  174:             interpreter = PathPythonInfo.from_exe(exe_raw, app_data, raise_on_error=False, env=env)
  175:             if interpreter is not None:
  176:                 yield interpreter, impl_must_match
  177: 
  178:     # otherwise try uv-managed python (~/.local/share/uv/python or platform equivalent)
  179:     if uv_python_dir := os.getenv("UV_PYTHON_INSTALL_DIR"):
  180:         uv_python_path = Path(uv_python_dir).expanduser()
  181:     elif xdg_data_home := os.getenv("XDG_DATA_HOME"):
  182:         uv_python_path = Path(xdg_data_home).expanduser() / "uv" / "python"
  183:     else:
  184:         uv_python_path = user_data_path("uv") / "python"
  185: 
  186:     for exe_path in uv_python_path.glob("*/bin/python"):
  187:         interpreter = PathPythonInfo.from_exe(str(exe_path), app_data, raise_on_error=False, env=env)
  188:         if interpreter is not None:
  189:             yield interpreter, True
  190: 
  191: 
  192: def get_paths(env: Mapping[str, str]) -> Generator[Path, None, None]:
  193:     path = env.get("PATH", None)
  194:     if path is None:
  195:         try:
  196:             path = os.confstr("CS_PATH")
  197:         except (AttributeError, ValueError):
  198:             path = os.defpath
  199:     if path:
  200:         for p in map(Path, path.split(os.pathsep)):
  201:             with suppress(OSError):
  202:                 if p.is_dir() and next(p.iterdir(), None):
  203:                     yield p
  204: 
  205: 
  206: class LazyPathDump:
  207:     def __init__(self, pos: int, path: Path, env: Mapping[str, str]) -> None:
  208:         self.pos = pos
  209:         self.path = path
  210:         self.env = env
  211: 
  212:     def __repr__(self) -> str:
  213:         content = f"discover PATH[{self.pos}]={self.path}"
  214:         if self.env.get("_VIRTUALENV_DEBUG"):  # this is the over the board debug
  215:             content += " with =>"
  216:             for file_path in self.path.iterdir():
  217:                 try:
  218:                     if file_path.is_dir():
  219:                         continue
  220:                     if IS_WIN:
  221:                         pathext = self.env.get("PATHEXT", ".COM;.EXE;.BAT;.CMD").split(";")
  222:                         if not any(file_path.name.upper().endswith(ext) for ext in pathext):
  223:                             continue
  224:                     elif not (file_path.stat().st_mode & os.X_OK):
  225:                         continue
  226:                 except OSError:
  227:                     pass
  228:                 content += " "
  229:                 content += file_path.name
  230:         return content
  231: 
  232: 
  233: def path_exe_finder(spec: PythonSpec) -> Callable[[Path], Generator[tuple[Path, bool], None, None]]:
  234:     """Given a spec, return a function that can be called on a path to find all matching files in it."""
  235:     pat = spec.generate_re(windows=sys.platform == "win32")
  236:     direct = spec.str_spec
  237:     if sys.platform == "win32":
  238:         direct = f"{direct}.exe"
  239: 
  240:     def path_exes(path: Path) -> Generator[tuple[Path, bool], None, None]:
  241:         # 4. then maybe it's something exact on PATH - if it was direct lookup implementation no longer counts
  242:         direct_path = path / direct
  243:         if direct_path.exists():
  244:             yield direct_path, False
  245: 
  246:         # 5. or from the spec we can deduce if a name on path matches
  247:         for exe in path.iterdir():
  248:             match = pat.fullmatch(exe.name)
  249:             if match:
  250:                 # the implementation must match when we find вЂњpython[ver]вЂќ
  251:                 yield exe.absolute(), match["impl"] == "python"
  252: 
  253:     return path_exes
  254: 
  255: 
  256: class PathPythonInfo(PythonInfo):
  257:     """python info from path."""
  258: 
  259: 
  260: __all__ = [
  261:     "Builtin",
  262:     "PathPythonInfo",
  263:     "get_interpreter",
  264: ]
