    1: """Implement https://www.python.org/dev/peps/pep-0514/ to discover interpreters - Windows only."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import os
    6: import re
    7: import winreg
    8: from logging import basicConfig, getLogger
    9: 
   10: LOGGER = getLogger(__name__)
   11: 
   12: 
   13: def enum_keys(key):
   14:     at = 0
   15:     while True:
   16:         try:
   17:             yield winreg.EnumKey(key, at)
   18:         except OSError:
   19:             break
   20:         at += 1
   21: 
   22: 
   23: def get_value(key, value_name):
   24:     try:
   25:         return winreg.QueryValueEx(key, value_name)[0]
   26:     except OSError:
   27:         return None
   28: 
   29: 
   30: def discover_pythons():
   31:     for hive, hive_name, key, flags, default_arch in [
   32:         (winreg.HKEY_CURRENT_USER, "HKEY_CURRENT_USER", r"Software\Python", 0, 64),
   33:         (winreg.HKEY_LOCAL_MACHINE, "HKEY_LOCAL_MACHINE", r"Software\Python", winreg.KEY_WOW64_64KEY, 64),
   34:         (winreg.HKEY_LOCAL_MACHINE, "HKEY_LOCAL_MACHINE", r"Software\Python", winreg.KEY_WOW64_32KEY, 32),
   35:     ]:
   36:         yield from process_set(hive, hive_name, key, flags, default_arch)
   37: 
   38: 
   39: def process_set(hive, hive_name, key, flags, default_arch):
   40:     try:
   41:         with winreg.OpenKeyEx(hive, key, 0, winreg.KEY_READ | flags) as root_key:
   42:             for company in enum_keys(root_key):
   43:                 if company == "PyLauncher":  # reserved
   44:                     continue
   45:                 yield from process_company(hive_name, company, root_key, default_arch)
   46:     except OSError:
   47:         pass
   48: 
   49: 
   50: def process_company(hive_name, company, root_key, default_arch):
   51:     with winreg.OpenKeyEx(root_key, company) as company_key:
   52:         for tag in enum_keys(company_key):
   53:             spec = process_tag(hive_name, company, company_key, tag, default_arch)
   54:             if spec is not None:
   55:                 yield spec
   56: 
   57: 
   58: def process_tag(hive_name, company, company_key, tag, default_arch):
   59:     with winreg.OpenKeyEx(company_key, tag) as tag_key:
   60:         version = load_version_data(hive_name, company, tag, tag_key)
   61:         if version is not None:  # if failed to get version bail
   62:             major, minor, _ = version
   63:             arch = load_arch_data(hive_name, company, tag, tag_key, default_arch)
   64:             if arch is not None:
   65:                 exe_data = load_exe(hive_name, company, company_key, tag)
   66:                 if exe_data is not None:
   67:                     exe, args = exe_data
   68:                     threaded = load_threaded(hive_name, company, tag, tag_key)
   69:                     return company, major, minor, arch, threaded, exe, args
   70:                 return None
   71:             return None
   72:         return None
   73: 
   74: 
   75: def load_exe(hive_name, company, company_key, tag):
   76:     key_path = f"{hive_name}/{company}/{tag}"
   77:     try:
   78:         with winreg.OpenKeyEx(company_key, rf"{tag}\InstallPath") as ip_key, ip_key:
   79:             exe = get_value(ip_key, "ExecutablePath")
   80:             if exe is None:
   81:                 ip = get_value(ip_key, None)
   82:                 if ip is None:
   83:                     msg(key_path, "no ExecutablePath or default for it")
   84: 
   85:                 else:
   86:                     exe = os.path.join(ip, "python.exe")
   87:             if exe is not None and os.path.exists(exe):
   88:                 args = get_value(ip_key, "ExecutableArguments")
   89:                 return exe, args
   90:             msg(key_path, f"could not load exe with value {exe}")
   91:     except OSError:
   92:         msg(f"{key_path}/InstallPath", "missing")
   93:     return None
   94: 
   95: 
   96: def load_arch_data(hive_name, company, tag, tag_key, default_arch):
   97:     arch_str = get_value(tag_key, "SysArchitecture")
   98:     if arch_str is not None:
   99:         key_path = f"{hive_name}/{company}/{tag}/SysArchitecture"
  100:         try:
  101:             return parse_arch(arch_str)
  102:         except ValueError as sys_arch:
  103:             msg(key_path, sys_arch)
  104:     return default_arch
  105: 
  106: 
  107: def parse_arch(arch_str):
  108:     if isinstance(arch_str, str):
  109:         match = re.match(r"^(\d+)bit$", arch_str)
  110:         if match:
  111:             return int(next(iter(match.groups())))
  112:         error = f"invalid format {arch_str}"
  113:     else:
  114:         error = f"arch is not string: {arch_str!r}"
  115:     raise ValueError(error)
  116: 
  117: 
  118: def load_version_data(hive_name, company, tag, tag_key):
  119:     for candidate, key_path in [
  120:         (get_value(tag_key, "SysVersion"), f"{hive_name}/{company}/{tag}/SysVersion"),
  121:         (tag, f"{hive_name}/{company}/{tag}"),
  122:     ]:
  123:         if candidate is not None:
  124:             try:
  125:                 return parse_version(candidate)
  126:             except ValueError as sys_version:
  127:                 msg(key_path, sys_version)
  128:     return None
  129: 
  130: 
  131: def parse_version(version_str):
  132:     if isinstance(version_str, str):
  133:         match = re.match(r"^(\d+)(?:\.(\d+))?(?:\.(\d+))?$", version_str)
  134:         if match:
  135:             return tuple(int(i) if i is not None else None for i in match.groups())
  136:         error = f"invalid format {version_str}"
  137:     else:
  138:         error = f"version is not string: {version_str!r}"
  139:     raise ValueError(error)
  140: 
  141: 
  142: def load_threaded(hive_name, company, tag, tag_key):
  143:     display_name = get_value(tag_key, "DisplayName")
  144:     if display_name is not None:
  145:         if isinstance(display_name, str):
  146:             if "freethreaded" in display_name.lower():
  147:                 return True
  148:         else:
  149:             key_path = f"{hive_name}/{company}/{tag}/DisplayName"
  150:             msg(key_path, f"display name is not string: {display_name!r}")
  151:     return bool(re.match(r"^\d+(\.\d+){0,2}t$", tag, flags=re.IGNORECASE))
  152: 
  153: 
  154: def msg(path, what):
  155:     LOGGER.warning("PEP-514 violation in Windows Registry at %s error: %s", path, what)
  156: 
  157: 
  158: def _run():
  159:     basicConfig()
  160:     interpreters = [repr(spec) for spec in discover_pythons()]
  161:     print("\n".join(sorted(interpreters)))  # noqa: T201
  162: 
  163: 
  164: if __name__ == "__main__":
  165:     _run()
