    1: """
    2: A rough layout of the current storage goes as:
    3: 
    4: virtualenv-app-data
    5: в”њв”Ђв”Ђ py - <version> <cache information about python interpreters>
    6: в”‚  в””в”Ђв”Ђ *.json/lock
    7: в”њв”Ђв”Ђ wheel <cache wheels used for seeding>
    8: в”‚   в”њв”Ђв”Ђ house
    9: в”‚   в”‚   в””в”Ђв”Ђ *.whl <wheels downloaded go here>
   10: в”‚   в””в”Ђв”Ђ <python major.minor> -> 3.9
   11: в”‚       в”њв”Ђв”Ђ img-<version>
   12: в”‚       в”‚   в””в”Ђв”Ђ image
   13: в”‚       в”‚           в””в”Ђв”Ђ <install class> -> CopyPipInstall / SymlinkPipInstall
   14: в”‚       в”‚               в””в”Ђв”Ђ <wheel name> -> pip-20.1.1-py2.py3-none-any
   15: в”‚       в””в”Ђв”Ђ embed
   16: в”‚           в””в”Ђв”Ђ 3 -> json format versioning
   17: в”‚               в””в”Ђв”Ђ *.json -> for every distribution contains data about newer embed versions and releases
   18: в””в”Ђв”Ђв”Ђ unzip <in zip app we cannot refer to some internal files, so first extract them>
   19:      в””в”Ђв”Ђ <virtualenv version>
   20:          в”њв”Ђв”Ђ py_info.py
   21:          в”њв”Ђв”Ђ debug.py
   22:          в””в”Ђв”Ђ _virtualenv.py
   23: """  # noqa: D415
   24: 
   25: from __future__ import annotations
   26: 
   27: import json
   28: import logging
   29: from abc import ABC
   30: from contextlib import contextmanager, suppress
   31: from hashlib import sha256
   32: 
   33: from virtualenv.util.lock import ReentrantFileLock
   34: from virtualenv.util.path import safe_delete
   35: from virtualenv.util.zipapp import extract
   36: from virtualenv.version import __version__
   37: 
   38: from .base import AppData, ContentStore
   39: 
   40: LOGGER = logging.getLogger(__name__)
   41: 
   42: 
   43: class AppDataDiskFolder(AppData):
   44:     """Store the application data on the disk within a folder layout."""
   45: 
   46:     transient = False
   47:     can_update = True
   48: 
   49:     def __init__(self, folder) -> None:
   50:         self.lock = ReentrantFileLock(folder)
   51: 
   52:     def __repr__(self) -> str:
   53:         return f"{type(self).__name__}({self.lock.path})"
   54: 
   55:     def __str__(self) -> str:
   56:         return str(self.lock.path)
   57: 
   58:     def reset(self):
   59:         LOGGER.debug("reset app data folder %s", self.lock.path)
   60:         safe_delete(self.lock.path)
   61: 
   62:     def close(self):
   63:         """Do nothing."""
   64: 
   65:     @contextmanager
   66:     def locked(self, path):
   67:         path_lock = self.lock / path
   68:         with path_lock:
   69:             yield path_lock.path
   70: 
   71:     @contextmanager
   72:     def extract(self, path, to_folder):
   73:         root = ReentrantFileLock(to_folder()) if to_folder is not None else self.lock / "unzip" / __version__
   74:         with root.lock_for_key(path.name):
   75:             dest = root.path / path.name
   76:             if not dest.exists():
   77:                 extract(path, dest)
   78:             yield dest
   79: 
   80:     @property
   81:     def py_info_at(self):
   82:         return self.lock / "py_info" / "2"
   83: 
   84:     def py_info(self, path):
   85:         return PyInfoStoreDisk(self.py_info_at, path)
   86: 
   87:     def py_info_clear(self):
   88:         """clear py info."""
   89:         py_info_folder = self.py_info_at
   90:         with py_info_folder:
   91:             for filename in py_info_folder.path.iterdir():
   92:                 if filename.suffix == ".json":
   93:                     with py_info_folder.lock_for_key(filename.stem):
   94:                         if filename.exists():
   95:                             filename.unlink()
   96: 
   97:     def embed_update_log(self, distribution, for_py_version):
   98:         return EmbedDistributionUpdateStoreDisk(self.lock / "wheel" / for_py_version / "embed" / "3", distribution)
   99: 
  100:     @property
  101:     def house(self):
  102:         path = self.lock.path / "wheel" / "house"
  103:         path.mkdir(parents=True, exist_ok=True)
  104:         return path
  105: 
  106:     def wheel_image(self, for_py_version, name):
  107:         return self.lock.path / "wheel" / for_py_version / "image" / "1" / name
  108: 
  109: 
  110: class JSONStoreDisk(ContentStore, ABC):
  111:     def __init__(self, in_folder, key, msg_args) -> None:
  112:         self.in_folder = in_folder
  113:         self.key = key
  114:         self.msg_args = (*msg_args, self.file)
  115: 
  116:     @property
  117:     def file(self):
  118:         return self.in_folder.path / f"{self.key}.json"
  119: 
  120:     def exists(self):
  121:         return self.file.exists()
  122: 
  123:     def read(self):
  124:         data, bad_format = None, False
  125:         try:
  126:             data = json.loads(self.file.read_text(encoding="utf-8"))
  127:         except ValueError:
  128:             bad_format = True
  129:         except Exception:  # noqa: BLE001, S110
  130:             pass
  131:         else:
  132:             LOGGER.debug("got %s %s from %s", *self.msg_args)
  133:             return data
  134:         if bad_format:
  135:             with suppress(OSError):  # reading and writing on the same file may cause race on multiple processes
  136:                 self.remove()
  137:         return None
  138: 
  139:     def remove(self):
  140:         self.file.unlink()
  141:         LOGGER.debug("removed %s %s at %s", *self.msg_args)
  142: 
  143:     @contextmanager
  144:     def locked(self):
  145:         with self.in_folder.lock_for_key(self.key):
  146:             yield
  147: 
  148:     def write(self, content):
  149:         folder = self.file.parent
  150:         folder.mkdir(parents=True, exist_ok=True)
  151:         self.file.write_text(json.dumps(content, sort_keys=True, indent=2), encoding="utf-8")
  152:         LOGGER.debug("wrote %s %s at %s", *self.msg_args)
  153: 
  154: 
  155: class PyInfoStoreDisk(JSONStoreDisk):
  156:     def __init__(self, in_folder, path) -> None:
  157:         key = sha256(str(path).encode("utf-8")).hexdigest()
  158:         super().__init__(in_folder, key, ("python info of", path))
  159: 
  160: 
  161: class EmbedDistributionUpdateStoreDisk(JSONStoreDisk):
  162:     def __init__(self, in_folder, distribution) -> None:
  163:         super().__init__(
  164:             in_folder,
  165:             distribution,
  166:             ("embed update of distribution", distribution),
  167:         )
  168: 
  169: 
  170: __all__ = [
  171:     "AppDataDiskFolder",
  172:     "JSONStoreDisk",
  173:     "PyInfoStoreDisk",
  174: ]
