    1: """holds locking functionality that works across processes."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import logging
    6: import os
    7: from abc import ABC, abstractmethod
    8: from contextlib import contextmanager, suppress
    9: from pathlib import Path
   10: from threading import Lock, RLock
   11: 
   12: from filelock import FileLock, Timeout
   13: 
   14: LOGGER = logging.getLogger(__name__)
   15: 
   16: 
   17: class _CountedFileLock(FileLock):
   18:     def __init__(self, lock_file) -> None:
   19:         parent = os.path.dirname(lock_file)
   20:         if not os.path.isdir(parent):
   21:             with suppress(OSError):
   22:                 os.makedirs(parent)
   23: 
   24:         super().__init__(lock_file)
   25:         self.count = 0
   26:         self.thread_safe = RLock()
   27: 
   28:     def acquire(self, timeout=None, poll_interval=0.05):
   29:         if not self.thread_safe.acquire(timeout=-1 if timeout is None else timeout):
   30:             raise Timeout(self.lock_file)
   31:         if self.count == 0:
   32:             try:
   33:                 super().acquire(timeout, poll_interval)
   34:             except BaseException:
   35:                 self.thread_safe.release()
   36:                 raise
   37:         self.count += 1
   38: 
   39:     def release(self, force=False):  # noqa: FBT002
   40:         with self.thread_safe:
   41:             if self.count > 0:
   42:                 if self.count == 1:
   43:                     super().release(force=force)
   44:                 self.count -= 1
   45:                 if self.count == 0:
   46:                     # if we have no more users of this lock, release the thread lock
   47:                     self.thread_safe.release()
   48: 
   49: 
   50: _lock_store = {}
   51: _store_lock = Lock()
   52: 
   53: 
   54: class PathLockBase(ABC):
   55:     def __init__(self, folder) -> None:
   56:         path = Path(folder)
   57:         self.path = path.resolve() if path.exists() else path
   58: 
   59:     def __repr__(self) -> str:
   60:         return f"{self.__class__.__name__}({self.path})"
   61: 
   62:     def __truediv__(self, other):
   63:         return type(self)(self.path / other)
   64: 
   65:     @abstractmethod
   66:     def __enter__(self):
   67:         raise NotImplementedError
   68: 
   69:     @abstractmethod
   70:     def __exit__(self, exc_type, exc_val, exc_tb):
   71:         raise NotImplementedError
   72: 
   73:     @abstractmethod
   74:     @contextmanager
   75:     def lock_for_key(self, name, no_block=False):  # noqa: FBT002
   76:         raise NotImplementedError
   77: 
   78:     @abstractmethod
   79:     @contextmanager
   80:     def non_reentrant_lock_for_key(self, name):
   81:         raise NotImplementedError
   82: 
   83: 
   84: class ReentrantFileLock(PathLockBase):
   85:     def __init__(self, folder) -> None:
   86:         super().__init__(folder)
   87:         self._lock = None
   88: 
   89:     def _create_lock(self, name=""):
   90:         lock_file = str(self.path / f"{name}.lock")
   91:         with _store_lock:
   92:             if lock_file not in _lock_store:
   93:                 _lock_store[lock_file] = _CountedFileLock(lock_file)
   94:             return _lock_store[lock_file]
   95: 
   96:     @staticmethod
   97:     def _del_lock(lock):
   98:         if lock is not None:
   99:             with _store_lock, lock.thread_safe:
  100:                 if lock.count == 0:
  101:                     _lock_store.pop(lock.lock_file, None)
  102: 
  103:     def __del__(self) -> None:
  104:         self._del_lock(self._lock)
  105: 
  106:     def __enter__(self):
  107:         self._lock = self._create_lock()
  108:         self._lock_file(self._lock)
  109: 
  110:     def __exit__(self, exc_type, exc_val, exc_tb):
  111:         self._release(self._lock)
  112:         self._del_lock(self._lock)
  113:         self._lock = None
  114: 
  115:     def _lock_file(self, lock, no_block=False):  # noqa: FBT002
  116:         # multiple processes might be trying to get a first lock... so we cannot check if this directory exist without
  117:         # a lock, but that lock might then become expensive, and it's not clear where that lock should live.
  118:         # Instead here we just ignore if we fail to create the directory.
  119:         with suppress(OSError):
  120:             os.makedirs(str(self.path))
  121: 
  122:         try:
  123:             lock.acquire(0.0001)
  124:         except Timeout:
  125:             if no_block:
  126:                 raise
  127:             LOGGER.debug("lock file %s present, will block until released", lock.lock_file)
  128:             lock.release()  # release the acquire try from above
  129:             lock.acquire()
  130: 
  131:     @staticmethod
  132:     def _release(lock):
  133:         lock.release()
  134: 
  135:     @contextmanager
  136:     def lock_for_key(self, name, no_block=False):  # noqa: FBT002
  137:         lock = self._create_lock(name)
  138:         try:
  139:             try:
  140:                 self._lock_file(lock, no_block)
  141:                 yield
  142:             finally:
  143:                 self._release(lock)
  144:         finally:
  145:             self._del_lock(lock)
  146:             lock = None
  147: 
  148:     @contextmanager
  149:     def non_reentrant_lock_for_key(self, name):
  150:         with _CountedFileLock(str(self.path / f"{name}.lock")):
  151:             yield
  152: 
  153: 
  154: class NoOpFileLock(PathLockBase):
  155:     def __enter__(self):
  156:         raise NotImplementedError
  157: 
  158:     def __exit__(self, exc_type, exc_val, exc_tb):
  159:         raise NotImplementedError
  160: 
  161:     @contextmanager
  162:     def lock_for_key(self, name, no_block=False):  # noqa: ARG002, FBT002
  163:         yield
  164: 
  165:     @contextmanager
  166:     def non_reentrant_lock_for_key(self, name):  # noqa: ARG002
  167:         yield
  168: 
  169: 
  170: __all__ = [
  171:     "NoOpFileLock",
  172:     "ReentrantFileLock",
  173:     "Timeout",
  174: ]
