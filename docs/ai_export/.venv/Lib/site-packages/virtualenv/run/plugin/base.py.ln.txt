    1: from __future__ import annotations
    2: 
    3: import sys
    4: from collections import OrderedDict
    5: from importlib.metadata import entry_points
    6: 
    7: importlib_metadata_version = ()
    8: 
    9: 
   10: class PluginLoader:
   11:     _OPTIONS = None
   12:     _ENTRY_POINTS = None
   13: 
   14:     @classmethod
   15:     def entry_points_for(cls, key):
   16:         if sys.version_info >= (3, 10) or importlib_metadata_version >= (3, 6):
   17:             return OrderedDict((e.name, e.load()) for e in cls.entry_points().select(group=key))
   18:         return OrderedDict((e.name, e.load()) for e in cls.entry_points().get(key, {}))
   19: 
   20:     @staticmethod
   21:     def entry_points():
   22:         if PluginLoader._ENTRY_POINTS is None:
   23:             PluginLoader._ENTRY_POINTS = entry_points()
   24:         return PluginLoader._ENTRY_POINTS
   25: 
   26: 
   27: class ComponentBuilder(PluginLoader):
   28:     def __init__(self, interpreter, parser, name, possible) -> None:
   29:         self.interpreter = interpreter
   30:         self.name = name
   31:         self._impl_class = None
   32:         self.possible = possible
   33:         self.parser = parser.add_argument_group(title=name)
   34:         self.add_selector_arg_parse(name, list(self.possible))
   35: 
   36:     @classmethod
   37:     def options(cls, key):
   38:         if cls._OPTIONS is None:
   39:             cls._OPTIONS = cls.entry_points_for(key)
   40:         return cls._OPTIONS
   41: 
   42:     def add_selector_arg_parse(self, name, choices):
   43:         raise NotImplementedError
   44: 
   45:     def handle_selected_arg_parse(self, options):
   46:         selected = getattr(options, self.name)
   47:         if selected not in self.possible:
   48:             msg = f"No implementation for {self.interpreter}"
   49:             raise RuntimeError(msg)
   50:         self._impl_class = self.possible[selected]
   51:         self.populate_selected_argparse(selected, options.app_data)
   52:         return selected
   53: 
   54:     def populate_selected_argparse(self, selected, app_data):
   55:         self.parser.description = f"options for {self.name} {selected}"
   56:         self._impl_class.add_parser_arguments(self.parser, self.interpreter, app_data)
   57: 
   58:     def create(self, options):
   59:         return self._impl_class(options, self.interpreter)
   60: 
   61: 
   62: __all__ = [
   63:     "ComponentBuilder",
   64:     "PluginLoader",
   65: ]
