    1: # Attribute List Extension for Python-Markdown
    2: # ============================================
    3: 
    4: # Adds attribute list syntax. Inspired by
    5: # [Maruku](http://maruku.rubyforge.org/proposal.html#attribute_lists)'s
    6: # feature of the same name.
    7: 
    8: # See https://Python-Markdown.github.io/extensions/attr_list
    9: # for documentation.
   10: 
   11: # Original code Copyright 2011 [Waylan Limberg](http://achinghead.com/).
   12: 
   13: # All changes Copyright 2011-2014 The Python Markdown Project
   14: 
   15: # License: [BSD](https://opensource.org/licenses/bsd-license.php)
   16: 
   17: """
   18:  Adds attribute list syntax. Inspired by
   19: [Maruku](http://maruku.rubyforge.org/proposal.html#attribute_lists)'s
   20: feature of the same name.
   21: 
   22: See the [documentation](https://Python-Markdown.github.io/extensions/attr_list)
   23: for details.
   24: """
   25: 
   26: from __future__ import annotations
   27: from typing import TYPE_CHECKING
   28: 
   29: from . import Extension
   30: from ..treeprocessors import Treeprocessor
   31: import re
   32: 
   33: if TYPE_CHECKING:  # pragma: no cover
   34:     from xml.etree.ElementTree import Element
   35: 
   36: 
   37: def _handle_double_quote(s, t):
   38:     k, v = t.split('=', 1)
   39:     return k, v.strip('"')
   40: 
   41: 
   42: def _handle_single_quote(s, t):
   43:     k, v = t.split('=', 1)
   44:     return k, v.strip("'")
   45: 
   46: 
   47: def _handle_key_value(s, t):
   48:     return t.split('=', 1)
   49: 
   50: 
   51: def _handle_word(s, t):
   52:     if t.startswith('.'):
   53:         return '.', t[1:]
   54:     if t.startswith('#'):
   55:         return 'id', t[1:]
   56:     return t, t
   57: 
   58: 
   59: _scanner = re.Scanner([
   60:     (r'[^ =}]+=".*?"', _handle_double_quote),
   61:     (r"[^ =}]+='.*?'", _handle_single_quote),
   62:     (r'[^ =}]+=[^ =}]+', _handle_key_value),
   63:     (r'[^ =}]+', _handle_word),
   64:     (r' ', None)
   65: ])
   66: 
   67: 
   68: def get_attrs_and_remainder(attrs_string: str) -> tuple[list[tuple[str, str]], str]:
   69:     """ Parse attribute list and return a list of attribute tuples.
   70: 
   71:     Additionally, return any text that remained after a curly brace. In typical cases, its presence
   72:     should mean that the input does not match the intended attribute list syntax.
   73:     """
   74:     attrs, remainder = _scanner.scan(attrs_string)
   75:     # To keep historic behavior, discard all unparsable text prior to '}'.
   76:     index = remainder.find('}')
   77:     remainder = remainder[index:] if index != -1 else ''
   78:     return attrs, remainder
   79: 
   80: 
   81: def get_attrs(str: str) -> list[tuple[str, str]]:  # pragma: no cover
   82:     """ Soft-deprecated. Prefer `get_attrs_and_remainder`. """
   83:     return get_attrs_and_remainder(str)[0]
   84: 
   85: 
   86: def isheader(elem: Element) -> bool:
   87:     return elem.tag in ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']
   88: 
   89: 
   90: class AttrListTreeprocessor(Treeprocessor):
   91: 
   92:     BASE_RE = r'\{\:?[ ]*([^\}\n ][^\n]*)[ ]*\}'
   93:     HEADER_RE = re.compile(r'[ ]+{}[ ]*$'.format(BASE_RE))
   94:     BLOCK_RE = re.compile(r'\n[ ]*{}[ ]*$'.format(BASE_RE))
   95:     INLINE_RE = re.compile(r'^{}'.format(BASE_RE))
   96:     NAME_RE = re.compile(r'[^A-Z_a-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02ff'
   97:                          r'\u0370-\u037d\u037f-\u1fff\u200c-\u200d'
   98:                          r'\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff'
   99:                          r'\uf900-\ufdcf\ufdf0-\ufffd'
  100:                          r'\:\-\.0-9\u00b7\u0300-\u036f\u203f-\u2040]+')
  101: 
  102:     def run(self, doc: Element) -> None:
  103:         for elem in doc.iter():
  104:             if self.md.is_block_level(elem.tag):
  105:                 # Block level: check for `attrs` on last line of text
  106:                 RE = self.BLOCK_RE
  107:                 if isheader(elem) or elem.tag in ['dt', 'td', 'th']:
  108:                     # header, def-term, or table cell: check for attributes at end of element
  109:                     RE = self.HEADER_RE
  110:                 if len(elem) and elem.tag == 'li':
  111:                     # special case list items. children may include a `ul` or `ol`.
  112:                     pos = None
  113:                     # find the `ul` or `ol` position
  114:                     for i, child in enumerate(elem):
  115:                         if child.tag in ['ul', 'ol']:
  116:                             pos = i
  117:                             break
  118:                     if pos is None and elem[-1].tail:
  119:                         # use tail of last child. no `ul` or `ol`.
  120:                         m = RE.search(elem[-1].tail)
  121:                         if m:
  122:                             if not self.assign_attrs(elem, m.group(1), strict=True):
  123:                                 elem[-1].tail = elem[-1].tail[:m.start()]
  124:                     elif pos is not None and pos > 0 and elem[pos-1].tail:
  125:                         # use tail of last child before `ul` or `ol`
  126:                         m = RE.search(elem[pos-1].tail)
  127:                         if m:
  128:                             if not self.assign_attrs(elem, m.group(1), strict=True):
  129:                                 elem[pos-1].tail = elem[pos-1].tail[:m.start()]
  130:                     elif elem.text:
  131:                         # use text. `ul` is first child.
  132:                         m = RE.search(elem.text)
  133:                         if m:
  134:                             if not self.assign_attrs(elem, m.group(1), strict=True):
  135:                                 elem.text = elem.text[:m.start()]
  136:                 elif len(elem) and elem[-1].tail:
  137:                     # has children. Get from tail of last child
  138:                     m = RE.search(elem[-1].tail)
  139:                     if m:
  140:                         if not self.assign_attrs(elem, m.group(1), strict=True):
  141:                             elem[-1].tail = elem[-1].tail[:m.start()]
  142:                             if isheader(elem):
  143:                                 # clean up trailing #s
  144:                                 elem[-1].tail = elem[-1].tail.rstrip('#').rstrip()
  145:                 elif elem.text:
  146:                     # no children. Get from text.
  147:                     m = RE.search(elem.text)
  148:                     if m:
  149:                         if not self.assign_attrs(elem, m.group(1), strict=True):
  150:                             elem.text = elem.text[:m.start()]
  151:                             if isheader(elem):
  152:                                 # clean up trailing #s
  153:                                 elem.text = elem.text.rstrip('#').rstrip()
  154:             else:
  155:                 # inline: check for `attrs` at start of tail
  156:                 if elem.tail:
  157:                     m = self.INLINE_RE.match(elem.tail)
  158:                     if m:
  159:                         remainder = self.assign_attrs(elem, m.group(1))
  160:                         elem.tail = elem.tail[m.end():] + remainder
  161: 
  162:     def assign_attrs(self, elem: Element, attrs_string: str, *, strict: bool = False) -> str:
  163:         """ Assign `attrs` to element.
  164: 
  165:         If the `attrs_string` has an extra closing curly brace, the remaining text is returned.
  166: 
  167:         The `strict` argument controls whether to still assign `attrs` if there is a remaining `}`.
  168:         """
  169:         attrs, remainder = get_attrs_and_remainder(attrs_string)
  170:         if strict and remainder:
  171:             return remainder
  172: 
  173:         for k, v in attrs:
  174:             if k == '.':
  175:                 # add to class
  176:                 cls = elem.get('class')
  177:                 if cls:
  178:                     elem.set('class', '{} {}'.format(cls, v))
  179:                 else:
  180:                     elem.set('class', v)
  181:             else:
  182:                 # assign attribute `k` with `v`
  183:                 elem.set(self.sanitize_name(k), v)
  184:         # The text that we initially over-matched will be put back.
  185:         return remainder
  186: 
  187:     def sanitize_name(self, name: str) -> str:
  188:         """
  189:         Sanitize name as 'an XML Name, minus the `:`.'
  190:         See <https://www.w3.org/TR/REC-xml-names/#NT-NCName>.
  191:         """
  192:         return self.NAME_RE.sub('_', name)
  193: 
  194: 
  195: class AttrListExtension(Extension):
  196:     """ Attribute List extension for Python-Markdown """
  197:     def extendMarkdown(self, md):
  198:         md.treeprocessors.register(AttrListTreeprocessor(md), 'attr_list', 8)
  199:         md.registerExtension(self)
  200: 
  201: 
  202: def makeExtension(**kwargs):  # pragma: no cover
  203:     return AttrListExtension(**kwargs)
