    1: # Abbreviation Extension for Python-Markdown
    2: # ==========================================
    3: 
    4: # This extension adds abbreviation handling to Python-Markdown.
    5: 
    6: # See https://Python-Markdown.github.io/extensions/abbreviations
    7: # for documentation.
    8: 
    9: # Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/)
   10: # and [Seemant Kulleen](http://www.kulleen.org/)
   11: 
   12: # All changes Copyright 2008-2014 The Python Markdown Project
   13: 
   14: # License: [BSD](https://opensource.org/licenses/bsd-license.php)
   15: 
   16: """
   17: This extension adds abbreviation handling to Python-Markdown.
   18: 
   19: See the [documentation](https://Python-Markdown.github.io/extensions/abbreviations)
   20: for details.
   21: """
   22: 
   23: from __future__ import annotations
   24: 
   25: from . import Extension
   26: from ..blockprocessors import BlockProcessor
   27: from ..inlinepatterns import InlineProcessor
   28: from ..util import AtomicString
   29: import re
   30: import xml.etree.ElementTree as etree
   31: 
   32: 
   33: class AbbrExtension(Extension):
   34:     """ Abbreviation Extension for Python-Markdown. """
   35: 
   36:     def extendMarkdown(self, md):
   37:         """ Insert `AbbrPreprocessor` before `ReferencePreprocessor`. """
   38:         md.parser.blockprocessors.register(AbbrPreprocessor(md.parser), 'abbr', 16)
   39: 
   40: 
   41: class AbbrPreprocessor(BlockProcessor):
   42:     """ Abbreviation Preprocessor - parse text for abbr references. """
   43: 
   44:     RE = re.compile(r'^[*]\[(?P<abbr>[^\\]*?)\][ ]?:[ ]*\n?[ ]*(?P<title>.*)$', re.MULTILINE)
   45: 
   46:     def test(self, parent: etree.Element, block: str) -> bool:
   47:         return True
   48: 
   49:     def run(self, parent: etree.Element, blocks: list[str]) -> bool:
   50:         """
   51:         Find and remove all Abbreviation references from the text.
   52:         Each reference is set as a new `AbbrPattern` in the markdown instance.
   53: 
   54:         """
   55:         block = blocks.pop(0)
   56:         m = self.RE.search(block)
   57:         if m:
   58:             abbr = m.group('abbr').strip()
   59:             title = m.group('title').strip()
   60:             self.parser.md.inlinePatterns.register(
   61:                 AbbrInlineProcessor(self._generate_pattern(abbr), title), 'abbr-%s' % abbr, 2
   62:             )
   63:             if block[m.end():].strip():
   64:                 # Add any content after match back to blocks as separate block
   65:                 blocks.insert(0, block[m.end():].lstrip('\n'))
   66:             if block[:m.start()].strip():
   67:                 # Add any content before match back to blocks as separate block
   68:                 blocks.insert(0, block[:m.start()].rstrip('\n'))
   69:             return True
   70:         # No match. Restore block.
   71:         blocks.insert(0, block)
   72:         return False
   73: 
   74:     def _generate_pattern(self, text: str) -> str:
   75:         """ Given a string, returns a regex pattern to match that string. """
   76:         return f"(?P<abbr>\\b{ re.escape(text) }\\b)"
   77: 
   78: 
   79: class AbbrInlineProcessor(InlineProcessor):
   80:     """ Abbreviation inline pattern. """
   81: 
   82:     def __init__(self, pattern: str, title: str):
   83:         super().__init__(pattern)
   84:         self.title = title
   85: 
   86:     def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:
   87:         abbr = etree.Element('abbr')
   88:         abbr.text = AtomicString(m.group('abbr'))
   89:         abbr.set('title', self.title)
   90:         return abbr, m.start(0), m.end(0)
   91: 
   92: 
   93: def makeExtension(**kwargs):  # pragma: no cover
   94:     return AbbrExtension(**kwargs)
