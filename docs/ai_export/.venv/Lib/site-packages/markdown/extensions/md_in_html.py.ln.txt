    1: # Python-Markdown Markdown in HTML Extension
    2: # ===============================
    3: 
    4: # An implementation of [PHP Markdown Extra](http://michelf.com/projects/php-markdown/extra/)'s
    5: # parsing of Markdown syntax in raw HTML.
    6: 
    7: # See https://Python-Markdown.github.io/extensions/raw_html
    8: # for documentation.
    9: 
   10: # Copyright The Python Markdown Project
   11: 
   12: # License: [BSD](https://opensource.org/licenses/bsd-license.php)
   13: 
   14: """
   15: An implementation of [PHP Markdown Extra](http://michelf.com/projects/php-markdown/extra/)'s
   16: parsing of Markdown syntax in raw HTML.
   17: 
   18: See the [documentation](https://Python-Markdown.github.io/extensions/raw_html)
   19: for details.
   20: """
   21: 
   22: from __future__ import annotations
   23: 
   24: from . import Extension
   25: from ..blockprocessors import BlockProcessor
   26: from ..preprocessors import Preprocessor
   27: from ..postprocessors import RawHtmlPostprocessor
   28: from .. import util
   29: from ..htmlparser import HTMLExtractor, blank_line_re
   30: import xml.etree.ElementTree as etree
   31: from typing import TYPE_CHECKING, Literal, Mapping
   32: 
   33: if TYPE_CHECKING:  # pragma: no cover
   34:     from markdown import Markdown
   35: 
   36: 
   37: class HTMLExtractorExtra(HTMLExtractor):
   38:     """
   39:     Override `HTMLExtractor` and create `etree` `Elements` for any elements which should have content parsed as
   40:     Markdown.
   41:     """
   42: 
   43:     def __init__(self, md: Markdown, *args, **kwargs):
   44:         # All block-level tags.
   45:         self.block_level_tags = set(md.block_level_elements.copy())
   46:         # Block-level tags in which the content only gets span level parsing
   47:         self.span_tags = set(
   48:             ['address', 'dd', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'legend', 'li', 'p', 'summary', 'td', 'th']
   49:         )
   50:         # Block-level tags which never get their content parsed.
   51:         self.raw_tags = set(['canvas', 'math', 'option', 'pre', 'script', 'style', 'textarea'])
   52: 
   53:         super().__init__(md, *args, **kwargs)
   54: 
   55:         # Block-level tags in which the content gets parsed as blocks
   56:         self.block_tags = set(self.block_level_tags) - (self.span_tags | self.raw_tags | self.empty_tags)
   57:         self.span_and_blocks_tags = self.block_tags | self.span_tags
   58: 
   59:     def reset(self):
   60:         """Reset this instance.  Loses all unprocessed data."""
   61:         self.mdstack: list[str] = []  # When markdown=1, stack contains a list of tags
   62:         self.treebuilder = etree.TreeBuilder()
   63:         self.mdstate: list[Literal['block', 'span', 'off', None]] = []
   64:         super().reset()
   65: 
   66:     def close(self):
   67:         """Handle any buffered data."""
   68:         super().close()
   69:         # Handle any unclosed tags.
   70:         if self.mdstack:
   71:             # Close the outermost parent. `handle_endtag` will close all unclosed children.
   72:             self.handle_endtag(self.mdstack[0])
   73: 
   74:     def get_element(self) -> etree.Element:
   75:         """ Return element from `treebuilder` and reset `treebuilder` for later use. """
   76:         element = self.treebuilder.close()
   77:         self.treebuilder = etree.TreeBuilder()
   78:         return element
   79: 
   80:     def get_state(self, tag, attrs: Mapping[str, str]) -> Literal['block', 'span', 'off', None]:
   81:         """ Return state from tag and `markdown` attribute. One of 'block', 'span', or 'off'. """
   82:         md_attr = attrs.get('markdown', '0')
   83:         if md_attr == 'markdown':
   84:             # `<tag markdown>` is the same as `<tag markdown='1'>`.
   85:             md_attr = '1'
   86:         parent_state = self.mdstate[-1] if self.mdstate else None
   87:         if parent_state == 'off' or (parent_state == 'span' and md_attr != '0'):
   88:             # Only use the parent state if it is more restrictive than the markdown attribute.
   89:             md_attr = parent_state
   90:         if ((md_attr == '1' and tag in self.block_tags) or
   91:                 (md_attr == 'block' and tag in self.span_and_blocks_tags)):
   92:             return 'block'
   93:         elif ((md_attr == '1' and tag in self.span_tags) or
   94:               (md_attr == 'span' and tag in self.span_and_blocks_tags)):
   95:             return 'span'
   96:         elif tag in self.block_level_tags:
   97:             return 'off'
   98:         else:  # pragma: no cover
   99:             return None
  100: 
  101:     def handle_starttag(self, tag, attrs):
  102:         # Handle tags that should always be empty and do not specify a closing tag
  103:         if tag in self.empty_tags and (self.at_line_start() or self.intail):
  104:             attrs = {key: value if value is not None else key for key, value in attrs}
  105:             if "markdown" in attrs:
  106:                 attrs.pop('markdown')
  107:                 element = etree.Element(tag, attrs)
  108:                 data = etree.tostring(element, encoding='unicode', method='html')
  109:             else:
  110:                 data = self.get_starttag_text()
  111:             self.handle_empty_tag(data, True)
  112:             return
  113: 
  114:         if tag in self.block_level_tags and (self.at_line_start() or self.intail):
  115:             # Valueless attribute (ex: `<tag checked>`) results in `[('checked', None)]`.
  116:             # Convert to `{'checked': 'checked'}`.
  117:             attrs = {key: value if value is not None else key for key, value in attrs}
  118:             state = self.get_state(tag, attrs)
  119:             if self.inraw or (state in [None, 'off'] and not self.mdstack):
  120:                 # fall back to default behavior
  121:                 attrs.pop('markdown', None)
  122:                 super().handle_starttag(tag, attrs)
  123:             else:
  124:                 if 'p' in self.mdstack and tag in self.block_level_tags:
  125:                     # Close unclosed 'p' tag
  126:                     self.handle_endtag('p')
  127:                 self.mdstate.append(state)
  128:                 self.mdstack.append(tag)
  129:                 attrs['markdown'] = state
  130:                 self.treebuilder.start(tag, attrs)
  131:         else:
  132:             # Span level tag
  133:             if self.inraw:
  134:                 super().handle_starttag(tag, attrs)
  135:             else:
  136:                 text = self.get_starttag_text()
  137:                 if self.mdstate and self.mdstate[-1] == "off":
  138:                     self.handle_data(self.md.htmlStash.store(text))
  139:                 else:
  140:                     self.handle_data(text)
  141:                 if tag in self.CDATA_CONTENT_ELEMENTS:
  142:                     # This is presumably a standalone tag in a code span (see #1036).
  143:                     self.clear_cdata_mode()
  144: 
  145:     def handle_endtag(self, tag):
  146:         if tag in self.block_level_tags:
  147:             if self.inraw:
  148:                 super().handle_endtag(tag)
  149:             elif tag in self.mdstack:
  150:                 # Close element and any unclosed children
  151:                 while self.mdstack:
  152:                     item = self.mdstack.pop()
  153:                     self.mdstate.pop()
  154:                     self.treebuilder.end(item)
  155:                     if item == tag:
  156:                         break
  157:                 if not self.mdstack:
  158:                     # Last item in stack is closed. Stash it
  159:                     element = self.get_element()
  160:                     # Get last entry to see if it ends in newlines
  161:                     # If it is an element, assume there is no newlines
  162:                     item = self.cleandoc[-1] if self.cleandoc else ''
  163:                     # If we only have one newline before block element, add another
  164:                     if not item.endswith('\n\n') and item.endswith('\n'):
  165:                         self.cleandoc.append('\n')
  166:                     self.cleandoc.append(self.md.htmlStash.store(element))
  167:                     self.cleandoc.append('\n\n')
  168:                     self.state = []
  169:                     # Check if element has a tail
  170:                     if not blank_line_re.match(
  171:                             self.rawdata[self.line_offset + self.offset + len(self.get_endtag_text(tag)):]):
  172:                         # More content exists after `endtag`.
  173:                         self.intail = True
  174:             else:
  175:                 # Treat orphan closing tag as a span level tag.
  176:                 text = self.get_endtag_text(tag)
  177:                 if self.mdstate and self.mdstate[-1] == "off":
  178:                     self.handle_data(self.md.htmlStash.store(text))
  179:                 else:
  180:                     self.handle_data(text)
  181:         else:
  182:             # Span level tag
  183:             if self.inraw:
  184:                 super().handle_endtag(tag)
  185:             else:
  186:                 text = self.get_endtag_text(tag)
  187:                 if self.mdstate and self.mdstate[-1] == "off":
  188:                     self.handle_data(self.md.htmlStash.store(text))
  189:                 else:
  190:                     self.handle_data(text)
  191: 
  192:     def handle_startendtag(self, tag, attrs):
  193:         if tag in self.empty_tags:
  194:             attrs = {key: value if value is not None else key for key, value in attrs}
  195:             if "markdown" in attrs:
  196:                 attrs.pop('markdown')
  197:                 element = etree.Element(tag, attrs)
  198:                 data = etree.tostring(element, encoding='unicode', method='html')
  199:             else:
  200:                 data = self.get_starttag_text()
  201:         else:
  202:             data = self.get_starttag_text()
  203:         self.handle_empty_tag(data, is_block=self.md.is_block_level(tag))
  204: 
  205:     def handle_data(self, data):
  206:         if self.intail and '\n' in data:
  207:             self.intail = False
  208:         if self.inraw or not self.mdstack:
  209:             super().handle_data(data)
  210:         else:
  211:             self.treebuilder.data(data)
  212: 
  213:     def handle_empty_tag(self, data, is_block):
  214:         if self.inraw or not self.mdstack:
  215:             super().handle_empty_tag(data, is_block)
  216:         else:
  217:             if self.at_line_start() and is_block:
  218:                 self.handle_data('\n' + self.md.htmlStash.store(data) + '\n\n')
  219:             else:
  220:                 self.handle_data(self.md.htmlStash.store(data))
  221: 
  222:     def parse_pi(self, i: int) -> int:
  223:         if self.at_line_start() or self.intail or self.mdstack:
  224:             # The same override exists in `HTMLExtractor` without the check
  225:             # for `mdstack`. Therefore, use parent of `HTMLExtractor` instead.
  226:             return super(HTMLExtractor, self).parse_pi(i)
  227:         # This is not the beginning of a raw block so treat as plain data
  228:         # and avoid consuming any tags which may follow (see #1066).
  229:         self.handle_data('<?')
  230:         return i + 2
  231: 
  232:     def parse_html_declaration(self, i: int) -> int:
  233:         if self.at_line_start() or self.intail or self.mdstack:
  234:             # The same override exists in `HTMLExtractor` without the check
  235:             # for `mdstack`. Therefore, use parent of `HTMLExtractor` instead.
  236:             return super(HTMLExtractor, self).parse_html_declaration(i)
  237:         # This is not the beginning of a raw block so treat as plain data
  238:         # and avoid consuming any tags which may follow (see #1066).
  239:         self.handle_data('<!')
  240:         return i + 2
  241: 
  242: 
  243: class HtmlBlockPreprocessor(Preprocessor):
  244:     """Remove html blocks from the text and store them for later retrieval."""
  245: 
  246:     def run(self, lines: list[str]) -> list[str]:
  247:         source = '\n'.join(lines)
  248:         parser = HTMLExtractorExtra(self.md)
  249:         parser.feed(source)
  250:         parser.close()
  251:         return ''.join(parser.cleandoc).split('\n')
  252: 
  253: 
  254: class MarkdownInHtmlProcessor(BlockProcessor):
  255:     """Process Markdown Inside HTML Blocks which have been stored in the `HtmlStash`."""
  256: 
  257:     def test(self, parent: etree.Element, block: str) -> bool:
  258:         # Always return True. `run` will return `False` it not a valid match.
  259:         return True
  260: 
  261:     def parse_element_content(self, element: etree.Element) -> None:
  262:         """
  263:         Recursively parse the text content of an `etree` Element as Markdown.
  264: 
  265:         Any block level elements generated from the Markdown will be inserted as children of the element in place
  266:         of the text content. All `markdown` attributes are removed. For any elements in which Markdown parsing has
  267:         been disabled, the text content of it and its children are wrapped in an `AtomicString`.
  268:         """
  269: 
  270:         md_attr = element.attrib.pop('markdown', 'off')
  271: 
  272:         if md_attr == 'block':
  273:             # Parse content as block level
  274:             # The order in which the different parts are parsed (text, children, tails) is important here as the
  275:             # order of elements needs to be preserved. We can't be inserting items at a later point in the current
  276:             # iteration as we don't want to do raw processing on elements created from parsing Markdown text (for
  277:             # example). Therefore, the order of operations is children, tails, text.
  278: 
  279:             # Recursively parse existing children from raw HTML
  280:             for child in list(element):
  281:                 self.parse_element_content(child)
  282: 
  283:             # Parse Markdown text in tail of children. Do this separate to avoid raw HTML parsing.
  284:             # Save the position of each item to be inserted later in reverse.
  285:             tails = []
  286:             for pos, child in enumerate(element):
  287:                 if child.tail:
  288:                     block = child.tail.rstrip('\n')
  289:                     child.tail = ''
  290:                     # Use a dummy placeholder element.
  291:                     dummy = etree.Element('div')
  292:                     self.parser.parseBlocks(dummy, block.split('\n\n'))
  293:                     children = list(dummy)
  294:                     children.reverse()
  295:                     tails.append((pos + 1, children))
  296: 
  297:             # Insert the elements created from the tails in reverse.
  298:             tails.reverse()
  299:             for pos, tail in tails:
  300:                 for item in tail:
  301:                     element.insert(pos, item)
  302: 
  303:             # Parse Markdown text content. Do this last to avoid raw HTML parsing.
  304:             if element.text:
  305:                 block = element.text.rstrip('\n')
  306:                 element.text = ''
  307:                 # Use a dummy placeholder element as the content needs to get inserted before existing children.
  308:                 dummy = etree.Element('div')
  309:                 self.parser.parseBlocks(dummy, block.split('\n\n'))
  310:                 children = list(dummy)
  311:                 children.reverse()
  312:                 for child in children:
  313:                     element.insert(0, child)
  314: 
  315:         elif md_attr == 'span':
  316:             # Span level parsing will be handled by inline processors.
  317:             # Walk children here to remove any `markdown` attributes.
  318:             for child in list(element):
  319:                 self.parse_element_content(child)
  320: 
  321:         else:
  322:             # Disable inline parsing for everything else
  323:             if element.text is None:
  324:                 element.text = ''
  325:             element.text = util.AtomicString(element.text)
  326:             for child in list(element):
  327:                 self.parse_element_content(child)
  328:                 if child.tail:
  329:                     child.tail = util.AtomicString(child.tail)
  330: 
  331:     def run(self, parent: etree.Element, blocks: list[str]) -> bool:
  332:         m = util.HTML_PLACEHOLDER_RE.match(blocks[0])
  333:         if m:
  334:             index = int(m.group(1))
  335:             element = self.parser.md.htmlStash.rawHtmlBlocks[index]
  336:             if isinstance(element, etree.Element):
  337:                 # We have a matched element. Process it.
  338:                 blocks.pop(0)
  339:                 self.parse_element_content(element)
  340:                 parent.append(element)
  341:                 # Cleanup stash. Replace element with empty string to avoid confusing postprocessor.
  342:                 self.parser.md.htmlStash.rawHtmlBlocks.pop(index)
  343:                 self.parser.md.htmlStash.rawHtmlBlocks.insert(index, '')
  344:                 # Confirm the match to the `blockparser`.
  345:                 return True
  346:         # No match found.
  347:         return False
  348: 
  349: 
  350: class MarkdownInHTMLPostprocessor(RawHtmlPostprocessor):
  351:     def stash_to_string(self, text: str | etree.Element) -> str:
  352:         """ Override default to handle any `etree` elements still in the stash. """
  353:         if isinstance(text, etree.Element):
  354:             return self.md.serializer(text)
  355:         else:
  356:             return str(text)
  357: 
  358: 
  359: class MarkdownInHtmlExtension(Extension):
  360:     """Add Markdown parsing in HTML to Markdown class."""
  361: 
  362:     def extendMarkdown(self, md):
  363:         """ Register extension instances. """
  364: 
  365:         # Replace raw HTML preprocessor
  366:         md.preprocessors.register(HtmlBlockPreprocessor(md), 'html_block', 20)
  367:         # Add `blockprocessor` which handles the placeholders for `etree` elements
  368:         md.parser.blockprocessors.register(
  369:             MarkdownInHtmlProcessor(md.parser), 'markdown_block', 105
  370:         )
  371:         # Replace raw HTML postprocessor
  372:         md.postprocessors.register(MarkdownInHTMLPostprocessor(md), 'raw_html', 30)
  373: 
  374: 
  375: def makeExtension(**kwargs):  # pragma: no cover
  376:     return MarkdownInHtmlExtension(**kwargs)
