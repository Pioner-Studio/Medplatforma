    1: # Admonition extension for Python-Markdown
    2: # ========================================
    3: 
    4: # Adds rST-style admonitions. Inspired by [rST][] feature with the same name.
    5: 
    6: # [rST]: http://docutils.sourceforge.net/docs/ref/rst/directives.html#specific-admonitions
    7: 
    8: # See https://Python-Markdown.github.io/extensions/admonition
    9: # for documentation.
   10: 
   11: # Original code Copyright [Tiago Serafim](https://www.tiagoserafim.com/).
   12: 
   13: # All changes Copyright The Python Markdown Project
   14: 
   15: # License: [BSD](https://opensource.org/licenses/bsd-license.php)
   16: 
   17: 
   18: """
   19: Adds rST-style admonitions. Inspired by [rST][] feature with the same name.
   20: 
   21: [rST]: http://docutils.sourceforge.net/docs/ref/rst/directives.html#specific-admonitions
   22: 
   23: See the [documentation](https://Python-Markdown.github.io/extensions/admonition)
   24: for details.
   25: """
   26: 
   27: from __future__ import annotations
   28: 
   29: from . import Extension
   30: from ..blockprocessors import BlockProcessor
   31: import xml.etree.ElementTree as etree
   32: import re
   33: from typing import TYPE_CHECKING
   34: 
   35: if TYPE_CHECKING:  # pragma: no cover
   36:     from markdown import blockparser
   37: 
   38: 
   39: class AdmonitionExtension(Extension):
   40:     """ Admonition extension for Python-Markdown. """
   41: 
   42:     def extendMarkdown(self, md):
   43:         """ Add Admonition to Markdown instance. """
   44:         md.registerExtension(self)
   45: 
   46:         md.parser.blockprocessors.register(AdmonitionProcessor(md.parser), 'admonition', 105)
   47: 
   48: 
   49: class AdmonitionProcessor(BlockProcessor):
   50: 
   51:     CLASSNAME = 'admonition'
   52:     CLASSNAME_TITLE = 'admonition-title'
   53:     RE = re.compile(r'(?:^|\n)!!! ?([\w\-]+(?: +[\w\-]+)*)(?: +"(.*?)")? *(?:\n|$)')
   54:     RE_SPACES = re.compile('  +')
   55: 
   56:     def __init__(self, parser: blockparser.BlockParser):
   57:         """Initialization."""
   58: 
   59:         super().__init__(parser)
   60: 
   61:         self.current_sibling: etree.Element | None = None
   62:         self.content_indent = 0
   63: 
   64:     def parse_content(self, parent: etree.Element, block: str) -> tuple[etree.Element | None, str, str]:
   65:         """Get sibling admonition.
   66: 
   67:         Retrieve the appropriate sibling element. This can get tricky when
   68:         dealing with lists.
   69: 
   70:         """
   71: 
   72:         old_block = block
   73:         the_rest = ''
   74: 
   75:         # We already acquired the block via test
   76:         if self.current_sibling is not None:
   77:             sibling = self.current_sibling
   78:             block, the_rest = self.detab(block, self.content_indent)
   79:             self.current_sibling = None
   80:             self.content_indent = 0
   81:             return sibling, block, the_rest
   82: 
   83:         sibling = self.lastChild(parent)
   84: 
   85:         if sibling is None or sibling.tag != 'div' or sibling.get('class', '').find(self.CLASSNAME) == -1:
   86:             sibling = None
   87:         else:
   88:             # If the last child is a list and the content is sufficiently indented
   89:             # to be under it, then the content's sibling is in the list.
   90:             last_child = self.lastChild(sibling)
   91:             indent = 0
   92:             while last_child is not None:
   93:                 if (
   94:                     sibling is not None and block.startswith(' ' * self.tab_length * 2) and
   95:                     last_child is not None and last_child.tag in ('ul', 'ol', 'dl')
   96:                 ):
   97: 
   98:                     # The expectation is that we'll find an `<li>` or `<dt>`.
   99:                     # We should get its last child as well.
  100:                     sibling = self.lastChild(last_child)
  101:                     last_child = self.lastChild(sibling) if sibling is not None else None
  102: 
  103:                     # Context has been lost at this point, so we must adjust the
  104:                     # text's indentation level so it will be evaluated correctly
  105:                     # under the list.
  106:                     block = block[self.tab_length:]
  107:                     indent += self.tab_length
  108:                 else:
  109:                     last_child = None
  110: 
  111:             if not block.startswith(' ' * self.tab_length):
  112:                 sibling = None
  113: 
  114:             if sibling is not None:
  115:                 indent += self.tab_length
  116:                 block, the_rest = self.detab(old_block, indent)
  117:                 self.current_sibling = sibling
  118:                 self.content_indent = indent
  119: 
  120:         return sibling, block, the_rest
  121: 
  122:     def test(self, parent: etree.Element, block: str) -> bool:
  123: 
  124:         if self.RE.search(block):
  125:             return True
  126:         else:
  127:             return self.parse_content(parent, block)[0] is not None
  128: 
  129:     def run(self, parent: etree.Element, blocks: list[str]) -> None:
  130:         block = blocks.pop(0)
  131:         m = self.RE.search(block)
  132: 
  133:         if m:
  134:             if m.start() > 0:
  135:                 self.parser.parseBlocks(parent, [block[:m.start()]])
  136:             block = block[m.end():]  # removes the first line
  137:             block, theRest = self.detab(block)
  138:         else:
  139:             sibling, block, theRest = self.parse_content(parent, block)
  140: 
  141:         if m:
  142:             klass, title = self.get_class_and_title(m)
  143:             div = etree.SubElement(parent, 'div')
  144:             div.set('class', '{} {}'.format(self.CLASSNAME, klass))
  145:             if title:
  146:                 p = etree.SubElement(div, 'p')
  147:                 p.text = title
  148:                 p.set('class', self.CLASSNAME_TITLE)
  149:         else:
  150:             # Sibling is a list item, but we need to wrap it's content should be wrapped in <p>
  151:             if sibling.tag in ('li', 'dd') and sibling.text:
  152:                 text = sibling.text
  153:                 sibling.text = ''
  154:                 p = etree.SubElement(sibling, 'p')
  155:                 p.text = text
  156: 
  157:             div = sibling
  158: 
  159:         self.parser.parseChunk(div, block)
  160: 
  161:         if theRest:
  162:             # This block contained unindented line(s) after the first indented
  163:             # line. Insert these lines as the first block of the master blocks
  164:             # list for future processing.
  165:             blocks.insert(0, theRest)
  166: 
  167:     def get_class_and_title(self, match: re.Match[str]) -> tuple[str, str | None]:
  168:         klass, title = match.group(1).lower(), match.group(2)
  169:         klass = self.RE_SPACES.sub(' ', klass)
  170:         if title is None:
  171:             # no title was provided, use the capitalized class name as title
  172:             # e.g.: `!!! note` will render
  173:             # `<p class="admonition-title">Note</p>`
  174:             title = klass.split(' ', 1)[0].capitalize()
  175:         elif title == '':
  176:             # an explicit blank title should not be rendered
  177:             # e.g.: `!!! warning ""` will *not* render `p` with a title
  178:             title = None
  179:         return klass, title
  180: 
  181: 
  182: def makeExtension(**kwargs):  # pragma: no cover
  183:     return AdmonitionExtension(**kwargs)
