    1: # -*- coding: utf-8 -*-
    2: #
    3: # Copyright (C) 2012-2023 Python Software Foundation.
    4: # See LICENSE.txt and CONTRIBUTORS.txt.
    5: #
    6: """
    7: Class representing the list of files in a distribution.
    8: 
    9: Equivalent to distutils.filelist, but fixes some problems.
   10: """
   11: import fnmatch
   12: import logging
   13: import os
   14: import re
   15: import sys
   16: 
   17: from . import DistlibException
   18: from .compat import fsdecode
   19: from .util import convert_path
   20: 
   21: 
   22: __all__ = ['Manifest']
   23: 
   24: logger = logging.getLogger(__name__)
   25: 
   26: # a \ followed by some spaces + EOL
   27: _COLLAPSE_PATTERN = re.compile('\\\\w*\n', re.M)
   28: _COMMENTED_LINE = re.compile('#.*?(?=\n)|\n(?=$)', re.M | re.S)
   29: 
   30: #
   31: # Due to the different results returned by fnmatch.translate, we need
   32: # to do slightly different processing for Python 2.7 and 3.2 ... this needed
   33: # to be brought in for Python 3.6 onwards.
   34: #
   35: _PYTHON_VERSION = sys.version_info[:2]
   36: 
   37: 
   38: class Manifest(object):
   39:     """
   40:     A list of files built by exploring the filesystem and filtered by applying various
   41:     patterns to what we find there.
   42:     """
   43: 
   44:     def __init__(self, base=None):
   45:         """
   46:         Initialise an instance.
   47: 
   48:         :param base: The base directory to explore under.
   49:         """
   50:         self.base = os.path.abspath(os.path.normpath(base or os.getcwd()))
   51:         self.prefix = self.base + os.sep
   52:         self.allfiles = None
   53:         self.files = set()
   54: 
   55:     #
   56:     # Public API
   57:     #
   58: 
   59:     def findall(self):
   60:         """Find all files under the base and set ``allfiles`` to the absolute
   61:         pathnames of files found.
   62:         """
   63:         from stat import S_ISREG, S_ISDIR, S_ISLNK
   64: 
   65:         self.allfiles = allfiles = []
   66:         root = self.base
   67:         stack = [root]
   68:         pop = stack.pop
   69:         push = stack.append
   70: 
   71:         while stack:
   72:             root = pop()
   73:             names = os.listdir(root)
   74: 
   75:             for name in names:
   76:                 fullname = os.path.join(root, name)
   77: 
   78:                 # Avoid excess stat calls -- just one will do, thank you!
   79:                 stat = os.stat(fullname)
   80:                 mode = stat.st_mode
   81:                 if S_ISREG(mode):
   82:                     allfiles.append(fsdecode(fullname))
   83:                 elif S_ISDIR(mode) and not S_ISLNK(mode):
   84:                     push(fullname)
   85: 
   86:     def add(self, item):
   87:         """
   88:         Add a file to the manifest.
   89: 
   90:         :param item: The pathname to add. This can be relative to the base.
   91:         """
   92:         if not item.startswith(self.prefix):
   93:             item = os.path.join(self.base, item)
   94:         self.files.add(os.path.normpath(item))
   95: 
   96:     def add_many(self, items):
   97:         """
   98:         Add a list of files to the manifest.
   99: 
  100:         :param items: The pathnames to add. These can be relative to the base.
  101:         """
  102:         for item in items:
  103:             self.add(item)
  104: 
  105:     def sorted(self, wantdirs=False):
  106:         """
  107:         Return sorted files in directory order
  108:         """
  109: 
  110:         def add_dir(dirs, d):
  111:             dirs.add(d)
  112:             logger.debug('add_dir added %s', d)
  113:             if d != self.base:
  114:                 parent, _ = os.path.split(d)
  115:                 assert parent not in ('', '/')
  116:                 add_dir(dirs, parent)
  117: 
  118:         result = set(self.files)    # make a copy!
  119:         if wantdirs:
  120:             dirs = set()
  121:             for f in result:
  122:                 add_dir(dirs, os.path.dirname(f))
  123:             result |= dirs
  124:         return [os.path.join(*path_tuple) for path_tuple in
  125:                 sorted(os.path.split(path) for path in result)]
  126: 
  127:     def clear(self):
  128:         """Clear all collected files."""
  129:         self.files = set()
  130:         self.allfiles = []
  131: 
  132:     def process_directive(self, directive):
  133:         """
  134:         Process a directive which either adds some files from ``allfiles`` to
  135:         ``files``, or removes some files from ``files``.
  136: 
  137:         :param directive: The directive to process. This should be in a format
  138:                      compatible with distutils ``MANIFEST.in`` files:
  139: 
  140:                      http://docs.python.org/distutils/sourcedist.html#commands
  141:         """
  142:         # Parse the line: split it up, make sure the right number of words
  143:         # is there, and return the relevant words.  'action' is always
  144:         # defined: it's the first word of the line.  Which of the other
  145:         # three are defined depends on the action; it'll be either
  146:         # patterns, (dir and patterns), or (dirpattern).
  147:         action, patterns, thedir, dirpattern = self._parse_directive(directive)
  148: 
  149:         # OK, now we know that the action is valid and we have the
  150:         # right number of words on the line for that action -- so we
  151:         # can proceed with minimal error-checking.
  152:         if action == 'include':
  153:             for pattern in patterns:
  154:                 if not self._include_pattern(pattern, anchor=True):
  155:                     logger.warning('no files found matching %r', pattern)
  156: 
  157:         elif action == 'exclude':
  158:             for pattern in patterns:
  159:                 self._exclude_pattern(pattern, anchor=True)
  160: 
  161:         elif action == 'global-include':
  162:             for pattern in patterns:
  163:                 if not self._include_pattern(pattern, anchor=False):
  164:                     logger.warning('no files found matching %r '
  165:                                    'anywhere in distribution', pattern)
  166: 
  167:         elif action == 'global-exclude':
  168:             for pattern in patterns:
  169:                 self._exclude_pattern(pattern, anchor=False)
  170: 
  171:         elif action == 'recursive-include':
  172:             for pattern in patterns:
  173:                 if not self._include_pattern(pattern, prefix=thedir):
  174:                     logger.warning('no files found matching %r '
  175:                                    'under directory %r', pattern, thedir)
  176: 
  177:         elif action == 'recursive-exclude':
  178:             for pattern in patterns:
  179:                 self._exclude_pattern(pattern, prefix=thedir)
  180: 
  181:         elif action == 'graft':
  182:             if not self._include_pattern(None, prefix=dirpattern):
  183:                 logger.warning('no directories found matching %r',
  184:                                dirpattern)
  185: 
  186:         elif action == 'prune':
  187:             if not self._exclude_pattern(None, prefix=dirpattern):
  188:                 logger.warning('no previously-included directories found '
  189:                                'matching %r', dirpattern)
  190:         else:   # pragma: no cover
  191:             # This should never happen, as it should be caught in
  192:             # _parse_template_line
  193:             raise DistlibException(
  194:                 'invalid action %r' % action)
  195: 
  196:     #
  197:     # Private API
  198:     #
  199: 
  200:     def _parse_directive(self, directive):
  201:         """
  202:         Validate a directive.
  203:         :param directive: The directive to validate.
  204:         :return: A tuple of action, patterns, thedir, dir_patterns
  205:         """
  206:         words = directive.split()
  207:         if len(words) == 1 and words[0] not in ('include', 'exclude',
  208:                                                 'global-include',
  209:                                                 'global-exclude',
  210:                                                 'recursive-include',
  211:                                                 'recursive-exclude',
  212:                                                 'graft', 'prune'):
  213:             # no action given, let's use the default 'include'
  214:             words.insert(0, 'include')
  215: 
  216:         action = words[0]
  217:         patterns = thedir = dir_pattern = None
  218: 
  219:         if action in ('include', 'exclude',
  220:                       'global-include', 'global-exclude'):
  221:             if len(words) < 2:
  222:                 raise DistlibException(
  223:                     '%r expects <pattern1> <pattern2> ...' % action)
  224: 
  225:             patterns = [convert_path(word) for word in words[1:]]
  226: 
  227:         elif action in ('recursive-include', 'recursive-exclude'):
  228:             if len(words) < 3:
  229:                 raise DistlibException(
  230:                     '%r expects <dir> <pattern1> <pattern2> ...' % action)
  231: 
  232:             thedir = convert_path(words[1])
  233:             patterns = [convert_path(word) for word in words[2:]]
  234: 
  235:         elif action in ('graft', 'prune'):
  236:             if len(words) != 2:
  237:                 raise DistlibException(
  238:                     '%r expects a single <dir_pattern>' % action)
  239: 
  240:             dir_pattern = convert_path(words[1])
  241: 
  242:         else:
  243:             raise DistlibException('unknown action %r' % action)
  244: 
  245:         return action, patterns, thedir, dir_pattern
  246: 
  247:     def _include_pattern(self, pattern, anchor=True, prefix=None,
  248:                          is_regex=False):
  249:         """Select strings (presumably filenames) from 'self.files' that
  250:         match 'pattern', a Unix-style wildcard (glob) pattern.
  251: 
  252:         Patterns are not quite the same as implemented by the 'fnmatch'
  253:         module: '*' and '?'  match non-special characters, where "special"
  254:         is platform-dependent: slash on Unix; colon, slash, and backslash on
  255:         DOS/Windows; and colon on Mac OS.
  256: 
  257:         If 'anchor' is true (the default), then the pattern match is more
  258:         stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
  259:         'anchor' is false, both of these will match.
  260: 
  261:         If 'prefix' is supplied, then only filenames starting with 'prefix'
  262:         (itself a pattern) and ending with 'pattern', with anything in between
  263:         them, will match.  'anchor' is ignored in this case.
  264: 
  265:         If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
  266:         'pattern' is assumed to be either a string containing a regex or a
  267:         regex object -- no translation is done, the regex is just compiled
  268:         and used as-is.
  269: 
  270:         Selected strings will be added to self.files.
  271: 
  272:         Return True if files are found.
  273:         """
  274:         # XXX docstring lying about what the special chars are?
  275:         found = False
  276:         pattern_re = self._translate_pattern(pattern, anchor, prefix, is_regex)
  277: 
  278:         # delayed loading of allfiles list
  279:         if self.allfiles is None:
  280:             self.findall()
  281: 
  282:         for name in self.allfiles:
  283:             if pattern_re.search(name):
  284:                 self.files.add(name)
  285:                 found = True
  286:         return found
  287: 
  288:     def _exclude_pattern(self, pattern, anchor=True, prefix=None,
  289:                          is_regex=False):
  290:         """Remove strings (presumably filenames) from 'files' that match
  291:         'pattern'.
  292: 
  293:         Other parameters are the same as for 'include_pattern()', above.
  294:         The list 'self.files' is modified in place. Return True if files are
  295:         found.
  296: 
  297:         This API is public to allow e.g. exclusion of SCM subdirs, e.g. when
  298:         packaging source distributions
  299:         """
  300:         found = False
  301:         pattern_re = self._translate_pattern(pattern, anchor, prefix, is_regex)
  302:         for f in list(self.files):
  303:             if pattern_re.search(f):
  304:                 self.files.remove(f)
  305:                 found = True
  306:         return found
  307: 
  308:     def _translate_pattern(self, pattern, anchor=True, prefix=None,
  309:                            is_regex=False):
  310:         """Translate a shell-like wildcard pattern to a compiled regular
  311:         expression.
  312: 
  313:         Return the compiled regex.  If 'is_regex' true,
  314:         then 'pattern' is directly compiled to a regex (if it's a string)
  315:         or just returned as-is (assumes it's a regex object).
  316:         """
  317:         if is_regex:
  318:             if isinstance(pattern, str):
  319:                 return re.compile(pattern)
  320:             else:
  321:                 return pattern
  322: 
  323:         if _PYTHON_VERSION > (3, 2):
  324:             # ditch start and end characters
  325:             start, _, end = self._glob_to_re('_').partition('_')
  326: 
  327:         if pattern:
  328:             pattern_re = self._glob_to_re(pattern)
  329:             if _PYTHON_VERSION > (3, 2):
  330:                 assert pattern_re.startswith(start) and pattern_re.endswith(end)
  331:         else:
  332:             pattern_re = ''
  333: 
  334:         base = re.escape(os.path.join(self.base, ''))
  335:         if prefix is not None:
  336:             # ditch end of pattern character
  337:             if _PYTHON_VERSION <= (3, 2):
  338:                 empty_pattern = self._glob_to_re('')
  339:                 prefix_re = self._glob_to_re(prefix)[:-len(empty_pattern)]
  340:             else:
  341:                 prefix_re = self._glob_to_re(prefix)
  342:                 assert prefix_re.startswith(start) and prefix_re.endswith(end)
  343:                 prefix_re = prefix_re[len(start): len(prefix_re) - len(end)]
  344:             sep = os.sep
  345:             if os.sep == '\\':
  346:                 sep = r'\\'
  347:             if _PYTHON_VERSION <= (3, 2):
  348:                 pattern_re = '^' + base + sep.join((prefix_re,
  349:                                                     '.*' + pattern_re))
  350:             else:
  351:                 pattern_re = pattern_re[len(start): len(pattern_re) - len(end)]
  352:                 pattern_re = r'%s%s%s%s.*%s%s' % (start, base, prefix_re, sep,
  353:                                                   pattern_re, end)
  354:         else:  # no prefix -- respect anchor flag
  355:             if anchor:
  356:                 if _PYTHON_VERSION <= (3, 2):
  357:                     pattern_re = '^' + base + pattern_re
  358:                 else:
  359:                     pattern_re = r'%s%s%s' % (start, base, pattern_re[len(start):])
  360: 
  361:         return re.compile(pattern_re)
  362: 
  363:     def _glob_to_re(self, pattern):
  364:         """Translate a shell-like glob pattern to a regular expression.
  365: 
  366:         Return a string containing the regex.  Differs from
  367:         'fnmatch.translate()' in that '*' does not match "special characters"
  368:         (which are platform-specific).
  369:         """
  370:         pattern_re = fnmatch.translate(pattern)
  371: 
  372:         # '?' and '*' in the glob pattern become '.' and '.*' in the RE, which
  373:         # IMHO is wrong -- '?' and '*' aren't supposed to match slash in Unix,
  374:         # and by extension they shouldn't match such "special characters" under
  375:         # any OS.  So change all non-escaped dots in the RE to match any
  376:         # character except the special characters (currently: just os.sep).
  377:         sep = os.sep
  378:         if os.sep == '\\':
  379:             # we're using a regex to manipulate a regex, so we need
  380:             # to escape the backslash twice
  381:             sep = r'\\\\'
  382:         escaped = r'\1[^%s]' % sep
  383:         pattern_re = re.sub(r'((?<!\\)(\\\\)*)\.', escaped, pattern_re)
  384:         return pattern_re
