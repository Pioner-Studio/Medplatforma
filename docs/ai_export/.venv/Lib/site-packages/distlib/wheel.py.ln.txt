    1: # -*- coding: utf-8 -*-
    2: #
    3: # Copyright (C) 2013-2023 Vinay Sajip.
    4: # Licensed to the Python Software Foundation under a contributor agreement.
    5: # See LICENSE.txt and CONTRIBUTORS.txt.
    6: #
    7: from __future__ import unicode_literals
    8: 
    9: import base64
   10: import codecs
   11: import datetime
   12: from email import message_from_file
   13: import hashlib
   14: import json
   15: import logging
   16: import os
   17: import posixpath
   18: import re
   19: import shutil
   20: import sys
   21: import tempfile
   22: import zipfile
   23: 
   24: from . import __version__, DistlibException
   25: from .compat import sysconfig, ZipFile, fsdecode, text_type, filter
   26: from .database import InstalledDistribution
   27: from .metadata import Metadata, WHEEL_METADATA_FILENAME, LEGACY_METADATA_FILENAME
   28: from .util import (FileOperator, convert_path, CSVReader, CSVWriter, Cache, cached_property, get_cache_base,
   29:                    read_exports, tempdir, get_platform)
   30: from .version import NormalizedVersion, UnsupportedVersionError
   31: 
   32: logger = logging.getLogger(__name__)
   33: 
   34: cache = None  # created when needed
   35: 
   36: if hasattr(sys, 'pypy_version_info'):  # pragma: no cover
   37:     IMP_PREFIX = 'pp'
   38: elif sys.platform.startswith('java'):  # pragma: no cover
   39:     IMP_PREFIX = 'jy'
   40: elif sys.platform == 'cli':  # pragma: no cover
   41:     IMP_PREFIX = 'ip'
   42: else:
   43:     IMP_PREFIX = 'cp'
   44: 
   45: VER_SUFFIX = sysconfig.get_config_var('py_version_nodot')
   46: if not VER_SUFFIX:  # pragma: no cover
   47:     VER_SUFFIX = '%s%s' % sys.version_info[:2]
   48: PYVER = 'py' + VER_SUFFIX
   49: IMPVER = IMP_PREFIX + VER_SUFFIX
   50: 
   51: ARCH = get_platform().replace('-', '_').replace('.', '_')
   52: 
   53: ABI = sysconfig.get_config_var('SOABI')
   54: if ABI and ABI.startswith('cpython-'):
   55:     ABI = ABI.replace('cpython-', 'cp').split('-')[0]
   56: else:
   57: 
   58:     def _derive_abi():
   59:         parts = ['cp', VER_SUFFIX]
   60:         if sysconfig.get_config_var('Py_DEBUG'):
   61:             parts.append('d')
   62:         if IMP_PREFIX == 'cp':
   63:             vi = sys.version_info[:2]
   64:             if vi < (3, 8):
   65:                 wpm = sysconfig.get_config_var('WITH_PYMALLOC')
   66:                 if wpm is None:
   67:                     wpm = True
   68:                 if wpm:
   69:                     parts.append('m')
   70:                 if vi < (3, 3):
   71:                     us = sysconfig.get_config_var('Py_UNICODE_SIZE')
   72:                     if us == 4 or (us is None and sys.maxunicode == 0x10FFFF):
   73:                         parts.append('u')
   74:             if bool(sysconfig.get_config_var("Py_GIL_DISABLED")):
   75:                 parts.append('t')
   76:         return ''.join(parts)
   77: 
   78:     ABI = _derive_abi()
   79:     del _derive_abi
   80: 
   81: FILENAME_RE = re.compile(
   82:     r'''
   83: (?P<nm>[^-]+)
   84: -(?P<vn>\d+[^-]*)
   85: (-(?P<bn>\d+[^-]*))?
   86: -(?P<py>\w+\d+(\.\w+\d+)*)
   87: -(?P<bi>\w+)
   88: -(?P<ar>\w+(\.\w+)*)
   89: \.whl$
   90: ''', re.IGNORECASE | re.VERBOSE)
   91: 
   92: NAME_VERSION_RE = re.compile(r'''
   93: (?P<nm>[^-]+)
   94: -(?P<vn>\d+[^-]*)
   95: (-(?P<bn>\d+[^-]*))?$
   96: ''', re.IGNORECASE | re.VERBOSE)
   97: 
   98: SHEBANG_RE = re.compile(br'\s*#![^\r\n]*')
   99: SHEBANG_DETAIL_RE = re.compile(br'^(\s*#!("[^"]+"|\S+))\s+(.*)$')
  100: SHEBANG_PYTHON = b'#!python'
  101: SHEBANG_PYTHONW = b'#!pythonw'
  102: 
  103: if os.sep == '/':
  104:     to_posix = lambda o: o
  105: else:
  106:     to_posix = lambda o: o.replace(os.sep, '/')
  107: 
  108: if sys.version_info[0] < 3:
  109:     import imp
  110: else:
  111:     imp = None
  112:     import importlib.machinery
  113:     import importlib.util
  114: 
  115: 
  116: def _get_suffixes():
  117:     if imp:
  118:         return [s[0] for s in imp.get_suffixes()]
  119:     else:
  120:         return importlib.machinery.EXTENSION_SUFFIXES
  121: 
  122: 
  123: def _load_dynamic(name, path):
  124:     # https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly
  125:     if imp:
  126:         return imp.load_dynamic(name, path)
  127:     else:
  128:         spec = importlib.util.spec_from_file_location(name, path)
  129:         module = importlib.util.module_from_spec(spec)
  130:         sys.modules[name] = module
  131:         spec.loader.exec_module(module)
  132:         return module
  133: 
  134: 
  135: class Mounter(object):
  136: 
  137:     def __init__(self):
  138:         self.impure_wheels = {}
  139:         self.libs = {}
  140: 
  141:     def add(self, pathname, extensions):
  142:         self.impure_wheels[pathname] = extensions
  143:         self.libs.update(extensions)
  144: 
  145:     def remove(self, pathname):
  146:         extensions = self.impure_wheels.pop(pathname)
  147:         for k, v in extensions:
  148:             if k in self.libs:
  149:                 del self.libs[k]
  150: 
  151:     def find_module(self, fullname, path=None):
  152:         if fullname in self.libs:
  153:             result = self
  154:         else:
  155:             result = None
  156:         return result
  157: 
  158:     def load_module(self, fullname):
  159:         if fullname in sys.modules:
  160:             result = sys.modules[fullname]
  161:         else:
  162:             if fullname not in self.libs:
  163:                 raise ImportError('unable to find extension for %s' % fullname)
  164:             result = _load_dynamic(fullname, self.libs[fullname])
  165:             result.__loader__ = self
  166:             parts = fullname.rsplit('.', 1)
  167:             if len(parts) > 1:
  168:                 result.__package__ = parts[0]
  169:         return result
  170: 
  171: 
  172: _hook = Mounter()
  173: 
  174: 
  175: class Wheel(object):
  176:     """
  177:     Class to build and install from Wheel files (PEP 427).
  178:     """
  179: 
  180:     wheel_version = (1, 1)
  181:     hash_kind = 'sha256'
  182: 
  183:     def __init__(self, filename=None, sign=False, verify=False):
  184:         """
  185:         Initialise an instance using a (valid) filename.
  186:         """
  187:         self.sign = sign
  188:         self.should_verify = verify
  189:         self.buildver = ''
  190:         self.pyver = [PYVER]
  191:         self.abi = ['none']
  192:         self.arch = ['any']
  193:         self.dirname = os.getcwd()
  194:         if filename is None:
  195:             self.name = 'dummy'
  196:             self.version = '0.1'
  197:             self._filename = self.filename
  198:         else:
  199:             m = NAME_VERSION_RE.match(filename)
  200:             if m:
  201:                 info = m.groupdict('')
  202:                 self.name = info['nm']
  203:                 # Reinstate the local version separator
  204:                 self.version = info['vn'].replace('_', '-')
  205:                 self.buildver = info['bn']
  206:                 self._filename = self.filename
  207:             else:
  208:                 dirname, filename = os.path.split(filename)
  209:                 m = FILENAME_RE.match(filename)
  210:                 if not m:
  211:                     raise DistlibException('Invalid name or '
  212:                                            'filename: %r' % filename)
  213:                 if dirname:
  214:                     self.dirname = os.path.abspath(dirname)
  215:                 self._filename = filename
  216:                 info = m.groupdict('')
  217:                 self.name = info['nm']
  218:                 self.version = info['vn']
  219:                 self.buildver = info['bn']
  220:                 self.pyver = info['py'].split('.')
  221:                 self.abi = info['bi'].split('.')
  222:                 self.arch = info['ar'].split('.')
  223: 
  224:     @property
  225:     def filename(self):
  226:         """
  227:         Build and return a filename from the various components.
  228:         """
  229:         if self.buildver:
  230:             buildver = '-' + self.buildver
  231:         else:
  232:             buildver = ''
  233:         pyver = '.'.join(self.pyver)
  234:         abi = '.'.join(self.abi)
  235:         arch = '.'.join(self.arch)
  236:         # replace - with _ as a local version separator
  237:         version = self.version.replace('-', '_')
  238:         return '%s-%s%s-%s-%s-%s.whl' % (self.name, version, buildver, pyver, abi, arch)
  239: 
  240:     @property
  241:     def exists(self):
  242:         path = os.path.join(self.dirname, self.filename)
  243:         return os.path.isfile(path)
  244: 
  245:     @property
  246:     def tags(self):
  247:         for pyver in self.pyver:
  248:             for abi in self.abi:
  249:                 for arch in self.arch:
  250:                     yield pyver, abi, arch
  251: 
  252:     @cached_property
  253:     def metadata(self):
  254:         pathname = os.path.join(self.dirname, self.filename)
  255:         name_ver = '%s-%s' % (self.name, self.version)
  256:         info_dir = '%s.dist-info' % name_ver
  257:         wrapper = codecs.getreader('utf-8')
  258:         with ZipFile(pathname, 'r') as zf:
  259:             self.get_wheel_metadata(zf)
  260:             # wv = wheel_metadata['Wheel-Version'].split('.', 1)
  261:             # file_version = tuple([int(i) for i in wv])
  262:             # if file_version < (1, 1):
  263:             # fns = [WHEEL_METADATA_FILENAME, METADATA_FILENAME,
  264:             # LEGACY_METADATA_FILENAME]
  265:             # else:
  266:             # fns = [WHEEL_METADATA_FILENAME, METADATA_FILENAME]
  267:             fns = [WHEEL_METADATA_FILENAME, LEGACY_METADATA_FILENAME]
  268:             result = None
  269:             for fn in fns:
  270:                 try:
  271:                     metadata_filename = posixpath.join(info_dir, fn)
  272:                     with zf.open(metadata_filename) as bf:
  273:                         wf = wrapper(bf)
  274:                         result = Metadata(fileobj=wf)
  275:                         if result:
  276:                             break
  277:                 except KeyError:
  278:                     pass
  279:             if not result:
  280:                 raise ValueError('Invalid wheel, because metadata is '
  281:                                  'missing: looked in %s' % ', '.join(fns))
  282:         return result
  283: 
  284:     def get_wheel_metadata(self, zf):
  285:         name_ver = '%s-%s' % (self.name, self.version)
  286:         info_dir = '%s.dist-info' % name_ver
  287:         metadata_filename = posixpath.join(info_dir, 'WHEEL')
  288:         with zf.open(metadata_filename) as bf:
  289:             wf = codecs.getreader('utf-8')(bf)
  290:             message = message_from_file(wf)
  291:         return dict(message)
  292: 
  293:     @cached_property
  294:     def info(self):
  295:         pathname = os.path.join(self.dirname, self.filename)
  296:         with ZipFile(pathname, 'r') as zf:
  297:             result = self.get_wheel_metadata(zf)
  298:         return result
  299: 
  300:     def process_shebang(self, data):
  301:         m = SHEBANG_RE.match(data)
  302:         if m:
  303:             end = m.end()
  304:             shebang, data_after_shebang = data[:end], data[end:]
  305:             # Preserve any arguments after the interpreter
  306:             if b'pythonw' in shebang.lower():
  307:                 shebang_python = SHEBANG_PYTHONW
  308:             else:
  309:                 shebang_python = SHEBANG_PYTHON
  310:             m = SHEBANG_DETAIL_RE.match(shebang)
  311:             if m:
  312:                 args = b' ' + m.groups()[-1]
  313:             else:
  314:                 args = b''
  315:             shebang = shebang_python + args
  316:             data = shebang + data_after_shebang
  317:         else:
  318:             cr = data.find(b'\r')
  319:             lf = data.find(b'\n')
  320:             if cr < 0 or cr > lf:
  321:                 term = b'\n'
  322:             else:
  323:                 if data[cr:cr + 2] == b'\r\n':
  324:                     term = b'\r\n'
  325:                 else:
  326:                     term = b'\r'
  327:             data = SHEBANG_PYTHON + term + data
  328:         return data
  329: 
  330:     def get_hash(self, data, hash_kind=None):
  331:         if hash_kind is None:
  332:             hash_kind = self.hash_kind
  333:         try:
  334:             hasher = getattr(hashlib, hash_kind)
  335:         except AttributeError:
  336:             raise DistlibException('Unsupported hash algorithm: %r' % hash_kind)
  337:         result = hasher(data).digest()
  338:         result = base64.urlsafe_b64encode(result).rstrip(b'=').decode('ascii')
  339:         return hash_kind, result
  340: 
  341:     def write_record(self, records, record_path, archive_record_path):
  342:         records = list(records)  # make a copy, as mutated
  343:         records.append((archive_record_path, '', ''))
  344:         with CSVWriter(record_path) as writer:
  345:             for row in records:
  346:                 writer.writerow(row)
  347: 
  348:     def write_records(self, info, libdir, archive_paths):
  349:         records = []
  350:         distinfo, info_dir = info
  351:         # hasher = getattr(hashlib, self.hash_kind)
  352:         for ap, p in archive_paths:
  353:             with open(p, 'rb') as f:
  354:                 data = f.read()
  355:             digest = '%s=%s' % self.get_hash(data)
  356:             size = os.path.getsize(p)
  357:             records.append((ap, digest, size))
  358: 
  359:         p = os.path.join(distinfo, 'RECORD')
  360:         ap = to_posix(os.path.join(info_dir, 'RECORD'))
  361:         self.write_record(records, p, ap)
  362:         archive_paths.append((ap, p))
  363: 
  364:     def build_zip(self, pathname, archive_paths):
  365:         with ZipFile(pathname, 'w', zipfile.ZIP_DEFLATED) as zf:
  366:             for ap, p in archive_paths:
  367:                 logger.debug('Wrote %s to %s in wheel', p, ap)
  368:                 zf.write(p, ap)
  369: 
  370:     def build(self, paths, tags=None, wheel_version=None):
  371:         """
  372:         Build a wheel from files in specified paths, and use any specified tags
  373:         when determining the name of the wheel.
  374:         """
  375:         if tags is None:
  376:             tags = {}
  377: 
  378:         libkey = list(filter(lambda o: o in paths, ('purelib', 'platlib')))[0]
  379:         if libkey == 'platlib':
  380:             is_pure = 'false'
  381:             default_pyver = [IMPVER]
  382:             default_abi = [ABI]
  383:             default_arch = [ARCH]
  384:         else:
  385:             is_pure = 'true'
  386:             default_pyver = [PYVER]
  387:             default_abi = ['none']
  388:             default_arch = ['any']
  389: 
  390:         self.pyver = tags.get('pyver', default_pyver)
  391:         self.abi = tags.get('abi', default_abi)
  392:         self.arch = tags.get('arch', default_arch)
  393: 
  394:         libdir = paths[libkey]
  395: 
  396:         name_ver = '%s-%s' % (self.name, self.version)
  397:         data_dir = '%s.data' % name_ver
  398:         info_dir = '%s.dist-info' % name_ver
  399: 
  400:         archive_paths = []
  401: 
  402:         # First, stuff which is not in site-packages
  403:         for key in ('data', 'headers', 'scripts'):
  404:             if key not in paths:
  405:                 continue
  406:             path = paths[key]
  407:             if os.path.isdir(path):
  408:                 for root, dirs, files in os.walk(path):
  409:                     for fn in files:
  410:                         p = fsdecode(os.path.join(root, fn))
  411:                         rp = os.path.relpath(p, path)
  412:                         ap = to_posix(os.path.join(data_dir, key, rp))
  413:                         archive_paths.append((ap, p))
  414:                         if key == 'scripts' and not p.endswith('.exe'):
  415:                             with open(p, 'rb') as f:
  416:                                 data = f.read()
  417:                             data = self.process_shebang(data)
  418:                             with open(p, 'wb') as f:
  419:                                 f.write(data)
  420: 
  421:         # Now, stuff which is in site-packages, other than the
  422:         # distinfo stuff.
  423:         path = libdir
  424:         distinfo = None
  425:         for root, dirs, files in os.walk(path):
  426:             if root == path:
  427:                 # At the top level only, save distinfo for later
  428:                 # and skip it for now
  429:                 for i, dn in enumerate(dirs):
  430:                     dn = fsdecode(dn)
  431:                     if dn.endswith('.dist-info'):
  432:                         distinfo = os.path.join(root, dn)
  433:                         del dirs[i]
  434:                         break
  435:                 assert distinfo, '.dist-info directory expected, not found'
  436: 
  437:             for fn in files:
  438:                 # comment out next suite to leave .pyc files in
  439:                 if fsdecode(fn).endswith(('.pyc', '.pyo')):
  440:                     continue
  441:                 p = os.path.join(root, fn)
  442:                 rp = to_posix(os.path.relpath(p, path))
  443:                 archive_paths.append((rp, p))
  444: 
  445:         # Now distinfo. It may contain subdirectories (e.g. PEP 639)
  446:         for root, _, files in os.walk(distinfo):
  447:             for fn in files:
  448:                 if fn not in ('RECORD', 'INSTALLER', 'SHARED', 'WHEEL'):
  449:                     p = fsdecode(os.path.join(root, fn))
  450:                     r = os.path.relpath(root, distinfo)
  451:                     ap = to_posix(os.path.normpath(os.path.join(info_dir, r, fn)))
  452:                     archive_paths.append((ap, p))
  453: 
  454:         wheel_metadata = [
  455:             'Wheel-Version: %d.%d' % (wheel_version or self.wheel_version),
  456:             'Generator: distlib %s' % __version__,
  457:             'Root-Is-Purelib: %s' % is_pure,
  458:         ]
  459:         if self.buildver:
  460:             wheel_metadata.append('Build: %s' % self.buildver)
  461:         for pyver, abi, arch in self.tags:
  462:             wheel_metadata.append('Tag: %s-%s-%s' % (pyver, abi, arch))
  463:         p = os.path.join(distinfo, 'WHEEL')
  464:         with open(p, 'w') as f:
  465:             f.write('\n'.join(wheel_metadata))
  466:         ap = to_posix(os.path.join(info_dir, 'WHEEL'))
  467:         archive_paths.append((ap, p))
  468: 
  469:         # sort the entries by archive path. Not needed by any spec, but it
  470:         # keeps the archive listing and RECORD tidier than they would otherwise
  471:         # be. Use the number of path segments to keep directory entries together,
  472:         # and keep the dist-info stuff at the end.
  473:         def sorter(t):
  474:             ap = t[0]
  475:             n = ap.count('/')
  476:             if '.dist-info' in ap:
  477:                 n += 10000
  478:             return (n, ap)
  479: 
  480:         archive_paths = sorted(archive_paths, key=sorter)
  481: 
  482:         # Now, at last, RECORD.
  483:         # Paths in here are archive paths - nothing else makes sense.
  484:         self.write_records((distinfo, info_dir), libdir, archive_paths)
  485:         # Now, ready to build the zip file
  486:         pathname = os.path.join(self.dirname, self.filename)
  487:         self.build_zip(pathname, archive_paths)
  488:         return pathname
  489: 
  490:     def skip_entry(self, arcname):
  491:         """
  492:         Determine whether an archive entry should be skipped when verifying
  493:         or installing.
  494:         """
  495:         # The signature file won't be in RECORD,
  496:         # and we  don't currently don't do anything with it
  497:         # We also skip directories, as they won't be in RECORD
  498:         # either. See:
  499:         #
  500:         # https://github.com/pypa/wheel/issues/294
  501:         # https://github.com/pypa/wheel/issues/287
  502:         # https://github.com/pypa/wheel/pull/289
  503:         #
  504:         return arcname.endswith(('/', '/RECORD.jws'))
  505: 
  506:     def install(self, paths, maker, **kwargs):
  507:         """
  508:         Install a wheel to the specified paths. If kwarg ``warner`` is
  509:         specified, it should be a callable, which will be called with two
  510:         tuples indicating the wheel version of this software and the wheel
  511:         version in the file, if there is a discrepancy in the versions.
  512:         This can be used to issue any warnings to raise any exceptions.
  513:         If kwarg ``lib_only`` is True, only the purelib/platlib files are
  514:         installed, and the headers, scripts, data and dist-info metadata are
  515:         not written. If kwarg ``bytecode_hashed_invalidation`` is True, written
  516:         bytecode will try to use file-hash based invalidation (PEP-552) on
  517:         supported interpreter versions (CPython 3.7+).
  518: 
  519:         The return value is a :class:`InstalledDistribution` instance unless
  520:         ``options.lib_only`` is True, in which case the return value is ``None``.
  521:         """
  522: 
  523:         dry_run = maker.dry_run
  524:         warner = kwargs.get('warner')
  525:         lib_only = kwargs.get('lib_only', False)
  526:         bc_hashed_invalidation = kwargs.get('bytecode_hashed_invalidation', False)
  527: 
  528:         pathname = os.path.join(self.dirname, self.filename)
  529:         name_ver = '%s-%s' % (self.name, self.version)
  530:         data_dir = '%s.data' % name_ver
  531:         info_dir = '%s.dist-info' % name_ver
  532: 
  533:         metadata_name = posixpath.join(info_dir, LEGACY_METADATA_FILENAME)
  534:         wheel_metadata_name = posixpath.join(info_dir, 'WHEEL')
  535:         record_name = posixpath.join(info_dir, 'RECORD')
  536: 
  537:         wrapper = codecs.getreader('utf-8')
  538: 
  539:         with ZipFile(pathname, 'r') as zf:
  540:             with zf.open(wheel_metadata_name) as bwf:
  541:                 wf = wrapper(bwf)
  542:                 message = message_from_file(wf)
  543:             wv = message['Wheel-Version'].split('.', 1)
  544:             file_version = tuple([int(i) for i in wv])
  545:             if (file_version != self.wheel_version) and warner:
  546:                 warner(self.wheel_version, file_version)
  547: 
  548:             if message['Root-Is-Purelib'] == 'true':
  549:                 libdir = paths['purelib']
  550:             else:
  551:                 libdir = paths['platlib']
  552: 
  553:             records = {}
  554:             with zf.open(record_name) as bf:
  555:                 with CSVReader(stream=bf) as reader:
  556:                     for row in reader:
  557:                         p = row[0]
  558:                         records[p] = row
  559: 
  560:             data_pfx = posixpath.join(data_dir, '')
  561:             info_pfx = posixpath.join(info_dir, '')
  562:             script_pfx = posixpath.join(data_dir, 'scripts', '')
  563: 
  564:             # make a new instance rather than a copy of maker's,
  565:             # as we mutate it
  566:             fileop = FileOperator(dry_run=dry_run)
  567:             fileop.record = True  # so we can rollback if needed
  568: 
  569:             bc = not sys.dont_write_bytecode  # Double negatives. Lovely!
  570: 
  571:             outfiles = []  # for RECORD writing
  572: 
  573:             # for script copying/shebang processing
  574:             workdir = tempfile.mkdtemp()
  575:             # set target dir later
  576:             # we default add_launchers to False, as the
  577:             # Python Launcher should be used instead
  578:             maker.source_dir = workdir
  579:             maker.target_dir = None
  580:             try:
  581:                 for zinfo in zf.infolist():
  582:                     arcname = zinfo.filename
  583:                     if isinstance(arcname, text_type):
  584:                         u_arcname = arcname
  585:                     else:
  586:                         u_arcname = arcname.decode('utf-8')
  587:                     if self.skip_entry(u_arcname):
  588:                         continue
  589:                     row = records[u_arcname]
  590:                     if row[2] and str(zinfo.file_size) != row[2]:
  591:                         raise DistlibException('size mismatch for '
  592:                                                '%s' % u_arcname)
  593:                     if row[1]:
  594:                         kind, value = row[1].split('=', 1)
  595:                         with zf.open(arcname) as bf:
  596:                             data = bf.read()
  597:                         _, digest = self.get_hash(data, kind)
  598:                         if digest != value:
  599:                             raise DistlibException('digest mismatch for '
  600:                                                    '%s' % arcname)
  601: 
  602:                     if lib_only and u_arcname.startswith((info_pfx, data_pfx)):
  603:                         logger.debug('lib_only: skipping %s', u_arcname)
  604:                         continue
  605:                     is_script = (u_arcname.startswith(script_pfx) and not u_arcname.endswith('.exe'))
  606: 
  607:                     if u_arcname.startswith(data_pfx):
  608:                         _, where, rp = u_arcname.split('/', 2)
  609:                         outfile = os.path.join(paths[where], convert_path(rp))
  610:                     else:
  611:                         # meant for site-packages.
  612:                         if u_arcname in (wheel_metadata_name, record_name):
  613:                             continue
  614:                         outfile = os.path.join(libdir, convert_path(u_arcname))
  615:                     if not is_script:
  616:                         with zf.open(arcname) as bf:
  617:                             fileop.copy_stream(bf, outfile)
  618:                         # Issue #147: permission bits aren't preserved. Using
  619:                         # zf.extract(zinfo, libdir) should have worked, but didn't,
  620:                         # see https://www.thetopsites.net/article/53834422.shtml
  621:                         # So ... manually preserve permission bits as given in zinfo
  622:                         if os.name == 'posix':
  623:                             # just set the normal permission bits
  624:                             os.chmod(outfile, (zinfo.external_attr >> 16) & 0x1FF)
  625:                         outfiles.append(outfile)
  626:                         # Double check the digest of the written file
  627:                         if not dry_run and row[1]:
  628:                             with open(outfile, 'rb') as bf:
  629:                                 data = bf.read()
  630:                                 _, newdigest = self.get_hash(data, kind)
  631:                                 if newdigest != digest:
  632:                                     raise DistlibException('digest mismatch '
  633:                                                            'on write for '
  634:                                                            '%s' % outfile)
  635:                         if bc and outfile.endswith('.py'):
  636:                             try:
  637:                                 pyc = fileop.byte_compile(outfile, hashed_invalidation=bc_hashed_invalidation)
  638:                                 outfiles.append(pyc)
  639:                             except Exception:
  640:                                 # Don't give up if byte-compilation fails,
  641:                                 # but log it and perhaps warn the user
  642:                                 logger.warning('Byte-compilation failed', exc_info=True)
  643:                     else:
  644:                         fn = os.path.basename(convert_path(arcname))
  645:                         workname = os.path.join(workdir, fn)
  646:                         with zf.open(arcname) as bf:
  647:                             fileop.copy_stream(bf, workname)
  648: 
  649:                         dn, fn = os.path.split(outfile)
  650:                         maker.target_dir = dn
  651:                         filenames = maker.make(fn)
  652:                         fileop.set_executable_mode(filenames)
  653:                         outfiles.extend(filenames)
  654: 
  655:                 if lib_only:
  656:                     logger.debug('lib_only: returning None')
  657:                     dist = None
  658:                 else:
  659:                     # Generate scripts
  660: 
  661:                     # Try to get pydist.json so we can see if there are
  662:                     # any commands to generate. If this fails (e.g. because
  663:                     # of a legacy wheel), log a warning but don't give up.
  664:                     commands = None
  665:                     file_version = self.info['Wheel-Version']
  666:                     if file_version == '1.0':
  667:                         # Use legacy info
  668:                         ep = posixpath.join(info_dir, 'entry_points.txt')
  669:                         try:
  670:                             with zf.open(ep) as bwf:
  671:                                 epdata = read_exports(bwf)
  672:                             commands = {}
  673:                             for key in ('console', 'gui'):
  674:                                 k = '%s_scripts' % key
  675:                                 if k in epdata:
  676:                                     commands['wrap_%s' % key] = d = {}
  677:                                     for v in epdata[k].values():
  678:                                         s = '%s:%s' % (v.prefix, v.suffix)
  679:                                         if v.flags:
  680:                                             s += ' [%s]' % ','.join(v.flags)
  681:                                         d[v.name] = s
  682:                         except Exception:
  683:                             logger.warning('Unable to read legacy script '
  684:                                            'metadata, so cannot generate '
  685:                                            'scripts')
  686:                     else:
  687:                         try:
  688:                             with zf.open(metadata_name) as bwf:
  689:                                 wf = wrapper(bwf)
  690:                                 commands = json.load(wf).get('extensions')
  691:                                 if commands:
  692:                                     commands = commands.get('python.commands')
  693:                         except Exception:
  694:                             logger.warning('Unable to read JSON metadata, so '
  695:                                            'cannot generate scripts')
  696:                     if commands:
  697:                         console_scripts = commands.get('wrap_console', {})
  698:                         gui_scripts = commands.get('wrap_gui', {})
  699:                         if console_scripts or gui_scripts:
  700:                             script_dir = paths.get('scripts', '')
  701:                             if not os.path.isdir(script_dir):
  702:                                 raise ValueError('Valid script path not '
  703:                                                  'specified')
  704:                             maker.target_dir = script_dir
  705:                             for k, v in console_scripts.items():
  706:                                 script = '%s = %s' % (k, v)
  707:                                 filenames = maker.make(script)
  708:                                 fileop.set_executable_mode(filenames)
  709: 
  710:                             if gui_scripts:
  711:                                 options = {'gui': True}
  712:                                 for k, v in gui_scripts.items():
  713:                                     script = '%s = %s' % (k, v)
  714:                                     filenames = maker.make(script, options)
  715:                                     fileop.set_executable_mode(filenames)
  716: 
  717:                     p = os.path.join(libdir, info_dir)
  718:                     dist = InstalledDistribution(p)
  719: 
  720:                     # Write SHARED
  721:                     paths = dict(paths)  # don't change passed in dict
  722:                     del paths['purelib']
  723:                     del paths['platlib']
  724:                     paths['lib'] = libdir
  725:                     p = dist.write_shared_locations(paths, dry_run)
  726:                     if p:
  727:                         outfiles.append(p)
  728: 
  729:                     # Write RECORD
  730:                     dist.write_installed_files(outfiles, paths['prefix'], dry_run)
  731:                 return dist
  732:             except Exception:  # pragma: no cover
  733:                 logger.exception('installation failed.')
  734:                 fileop.rollback()
  735:                 raise
  736:             finally:
  737:                 shutil.rmtree(workdir)
  738: 
  739:     def _get_dylib_cache(self):
  740:         global cache
  741:         if cache is None:
  742:             # Use native string to avoid issues on 2.x: see Python #20140.
  743:             base = os.path.join(get_cache_base(), str('dylib-cache'), '%s.%s' % sys.version_info[:2])
  744:             cache = Cache(base)
  745:         return cache
  746: 
  747:     def _get_extensions(self):
  748:         pathname = os.path.join(self.dirname, self.filename)
  749:         name_ver = '%s-%s' % (self.name, self.version)
  750:         info_dir = '%s.dist-info' % name_ver
  751:         arcname = posixpath.join(info_dir, 'EXTENSIONS')
  752:         wrapper = codecs.getreader('utf-8')
  753:         result = []
  754:         with ZipFile(pathname, 'r') as zf:
  755:             try:
  756:                 with zf.open(arcname) as bf:
  757:                     wf = wrapper(bf)
  758:                     extensions = json.load(wf)
  759:                     cache = self._get_dylib_cache()
  760:                     prefix = cache.prefix_to_dir(self.filename, use_abspath=False)
  761:                     cache_base = os.path.join(cache.base, prefix)
  762:                     if not os.path.isdir(cache_base):
  763:                         os.makedirs(cache_base)
  764:                     for name, relpath in extensions.items():
  765:                         dest = os.path.join(cache_base, convert_path(relpath))
  766:                         if not os.path.exists(dest):
  767:                             extract = True
  768:                         else:
  769:                             file_time = os.stat(dest).st_mtime
  770:                             file_time = datetime.datetime.fromtimestamp(file_time)
  771:                             info = zf.getinfo(relpath)
  772:                             wheel_time = datetime.datetime(*info.date_time)
  773:                             extract = wheel_time > file_time
  774:                         if extract:
  775:                             zf.extract(relpath, cache_base)
  776:                         result.append((name, dest))
  777:             except KeyError:
  778:                 pass
  779:         return result
  780: 
  781:     def is_compatible(self):
  782:         """
  783:         Determine if a wheel is compatible with the running system.
  784:         """
  785:         return is_compatible(self)
  786: 
  787:     def is_mountable(self):
  788:         """
  789:         Determine if a wheel is asserted as mountable by its metadata.
  790:         """
  791:         return True  # for now - metadata details TBD
  792: 
  793:     def mount(self, append=False):
  794:         pathname = os.path.abspath(os.path.join(self.dirname, self.filename))
  795:         if not self.is_compatible():
  796:             msg = 'Wheel %s not compatible with this Python.' % pathname
  797:             raise DistlibException(msg)
  798:         if not self.is_mountable():
  799:             msg = 'Wheel %s is marked as not mountable.' % pathname
  800:             raise DistlibException(msg)
  801:         if pathname in sys.path:
  802:             logger.debug('%s already in path', pathname)
  803:         else:
  804:             if append:
  805:                 sys.path.append(pathname)
  806:             else:
  807:                 sys.path.insert(0, pathname)
  808:             extensions = self._get_extensions()
  809:             if extensions:
  810:                 if _hook not in sys.meta_path:
  811:                     sys.meta_path.append(_hook)
  812:                 _hook.add(pathname, extensions)
  813: 
  814:     def unmount(self):
  815:         pathname = os.path.abspath(os.path.join(self.dirname, self.filename))
  816:         if pathname not in sys.path:
  817:             logger.debug('%s not in path', pathname)
  818:         else:
  819:             sys.path.remove(pathname)
  820:             if pathname in _hook.impure_wheels:
  821:                 _hook.remove(pathname)
  822:             if not _hook.impure_wheels:
  823:                 if _hook in sys.meta_path:
  824:                     sys.meta_path.remove(_hook)
  825: 
  826:     def verify(self):
  827:         pathname = os.path.join(self.dirname, self.filename)
  828:         name_ver = '%s-%s' % (self.name, self.version)
  829:         # data_dir = '%s.data' % name_ver
  830:         info_dir = '%s.dist-info' % name_ver
  831: 
  832:         # metadata_name = posixpath.join(info_dir, LEGACY_METADATA_FILENAME)
  833:         wheel_metadata_name = posixpath.join(info_dir, 'WHEEL')
  834:         record_name = posixpath.join(info_dir, 'RECORD')
  835: 
  836:         wrapper = codecs.getreader('utf-8')
  837: 
  838:         with ZipFile(pathname, 'r') as zf:
  839:             with zf.open(wheel_metadata_name) as bwf:
  840:                 wf = wrapper(bwf)
  841:                 message_from_file(wf)
  842:             # wv = message['Wheel-Version'].split('.', 1)
  843:             # file_version = tuple([int(i) for i in wv])
  844:             # TODO version verification
  845: 
  846:             records = {}
  847:             with zf.open(record_name) as bf:
  848:                 with CSVReader(stream=bf) as reader:
  849:                     for row in reader:
  850:                         p = row[0]
  851:                         records[p] = row
  852: 
  853:             for zinfo in zf.infolist():
  854:                 arcname = zinfo.filename
  855:                 if isinstance(arcname, text_type):
  856:                     u_arcname = arcname
  857:                 else:
  858:                     u_arcname = arcname.decode('utf-8')
  859:                 # See issue #115: some wheels have .. in their entries, but
  860:                 # in the filename ... e.g. __main__..py ! So the check is
  861:                 # updated to look for .. in the directory portions
  862:                 p = u_arcname.split('/')
  863:                 if '..' in p:
  864:                     raise DistlibException('invalid entry in '
  865:                                            'wheel: %r' % u_arcname)
  866: 
  867:                 if self.skip_entry(u_arcname):
  868:                     continue
  869:                 row = records[u_arcname]
  870:                 if row[2] and str(zinfo.file_size) != row[2]:
  871:                     raise DistlibException('size mismatch for '
  872:                                            '%s' % u_arcname)
  873:                 if row[1]:
  874:                     kind, value = row[1].split('=', 1)
  875:                     with zf.open(arcname) as bf:
  876:                         data = bf.read()
  877:                     _, digest = self.get_hash(data, kind)
  878:                     if digest != value:
  879:                         raise DistlibException('digest mismatch for '
  880:                                                '%s' % arcname)
  881: 
  882:     def update(self, modifier, dest_dir=None, **kwargs):
  883:         """
  884:         Update the contents of a wheel in a generic way. The modifier should
  885:         be a callable which expects a dictionary argument: its keys are
  886:         archive-entry paths, and its values are absolute filesystem paths
  887:         where the contents the corresponding archive entries can be found. The
  888:         modifier is free to change the contents of the files pointed to, add
  889:         new entries and remove entries, before returning. This method will
  890:         extract the entire contents of the wheel to a temporary location, call
  891:         the modifier, and then use the passed (and possibly updated)
  892:         dictionary to write a new wheel. If ``dest_dir`` is specified, the new
  893:         wheel is written there -- otherwise, the original wheel is overwritten.
  894: 
  895:         The modifier should return True if it updated the wheel, else False.
  896:         This method returns the same value the modifier returns.
  897:         """
  898: 
  899:         def get_version(path_map, info_dir):
  900:             version = path = None
  901:             key = '%s/%s' % (info_dir, LEGACY_METADATA_FILENAME)
  902:             if key not in path_map:
  903:                 key = '%s/PKG-INFO' % info_dir
  904:             if key in path_map:
  905:                 path = path_map[key]
  906:                 version = Metadata(path=path).version
  907:             return version, path
  908: 
  909:         def update_version(version, path):
  910:             updated = None
  911:             try:
  912:                 NormalizedVersion(version)
  913:                 i = version.find('-')
  914:                 if i < 0:
  915:                     updated = '%s+1' % version
  916:                 else:
  917:                     parts = [int(s) for s in version[i + 1:].split('.')]
  918:                     parts[-1] += 1
  919:                     updated = '%s+%s' % (version[:i], '.'.join(str(i) for i in parts))
  920:             except UnsupportedVersionError:
  921:                 logger.debug('Cannot update non-compliant (PEP-440) '
  922:                              'version %r', version)
  923:             if updated:
  924:                 md = Metadata(path=path)
  925:                 md.version = updated
  926:                 legacy = path.endswith(LEGACY_METADATA_FILENAME)
  927:                 md.write(path=path, legacy=legacy)
  928:                 logger.debug('Version updated from %r to %r', version, updated)
  929: 
  930:         pathname = os.path.join(self.dirname, self.filename)
  931:         name_ver = '%s-%s' % (self.name, self.version)
  932:         info_dir = '%s.dist-info' % name_ver
  933:         record_name = posixpath.join(info_dir, 'RECORD')
  934:         with tempdir() as workdir:
  935:             with ZipFile(pathname, 'r') as zf:
  936:                 path_map = {}
  937:                 for zinfo in zf.infolist():
  938:                     arcname = zinfo.filename
  939:                     if isinstance(arcname, text_type):
  940:                         u_arcname = arcname
  941:                     else:
  942:                         u_arcname = arcname.decode('utf-8')
  943:                     if u_arcname == record_name:
  944:                         continue
  945:                     if '..' in u_arcname:
  946:                         raise DistlibException('invalid entry in '
  947:                                                'wheel: %r' % u_arcname)
  948:                     zf.extract(zinfo, workdir)
  949:                     path = os.path.join(workdir, convert_path(u_arcname))
  950:                     path_map[u_arcname] = path
  951: 
  952:             # Remember the version.
  953:             original_version, _ = get_version(path_map, info_dir)
  954:             # Files extracted. Call the modifier.
  955:             modified = modifier(path_map, **kwargs)
  956:             if modified:
  957:                 # Something changed - need to build a new wheel.
  958:                 current_version, path = get_version(path_map, info_dir)
  959:                 if current_version and (current_version == original_version):
  960:                     # Add or update local version to signify changes.
  961:                     update_version(current_version, path)
  962:                 # Decide where the new wheel goes.
  963:                 if dest_dir is None:
  964:                     fd, newpath = tempfile.mkstemp(suffix='.whl', prefix='wheel-update-', dir=workdir)
  965:                     os.close(fd)
  966:                 else:
  967:                     if not os.path.isdir(dest_dir):
  968:                         raise DistlibException('Not a directory: %r' % dest_dir)
  969:                     newpath = os.path.join(dest_dir, self.filename)
  970:                 archive_paths = list(path_map.items())
  971:                 distinfo = os.path.join(workdir, info_dir)
  972:                 info = distinfo, info_dir
  973:                 self.write_records(info, workdir, archive_paths)
  974:                 self.build_zip(newpath, archive_paths)
  975:                 if dest_dir is None:
  976:                     shutil.copyfile(newpath, pathname)
  977:         return modified
  978: 
  979: 
  980: def _get_glibc_version():
  981:     import platform
  982:     ver = platform.libc_ver()
  983:     result = []
  984:     if ver[0] == 'glibc':
  985:         for s in ver[1].split('.'):
  986:             result.append(int(s) if s.isdigit() else 0)
  987:         result = tuple(result)
  988:     return result
  989: 
  990: 
  991: def compatible_tags():
  992:     """
  993:     Return (pyver, abi, arch) tuples compatible with this Python.
  994:     """
  995:     class _Version:
  996:         def __init__(self, major, minor):
  997:             self.major = major
  998:             self.major_minor = (major, minor)
  999:             self.string = ''.join((str(major), str(minor)))
 1000: 
 1001:         def __str__(self):
 1002:             return self.string
 1003: 
 1004: 
 1005:     versions = [
 1006:         _Version(sys.version_info.major, minor_version)
 1007:         for minor_version in range(sys.version_info.minor, -1, -1)
 1008:     ]
 1009:     abis = []
 1010:     for suffix in _get_suffixes():
 1011:         if suffix.startswith('.abi'):
 1012:             abis.append(suffix.split('.', 2)[1])
 1013:     abis.sort()
 1014:     if ABI != 'none':
 1015:         abis.insert(0, ABI)
 1016:     abis.append('none')
 1017:     result = []
 1018: 
 1019:     arches = [ARCH]
 1020:     if sys.platform == 'darwin':
 1021:         m = re.match(r'(\w+)_(\d+)_(\d+)_(\w+)$', ARCH)
 1022:         if m:
 1023:             name, major, minor, arch = m.groups()
 1024:             minor = int(minor)
 1025:             matches = [arch]
 1026:             if arch in ('i386', 'ppc'):
 1027:                 matches.append('fat')
 1028:             if arch in ('i386', 'ppc', 'x86_64'):
 1029:                 matches.append('fat3')
 1030:             if arch in ('ppc64', 'x86_64'):
 1031:                 matches.append('fat64')
 1032:             if arch in ('i386', 'x86_64'):
 1033:                 matches.append('intel')
 1034:             if arch in ('i386', 'x86_64', 'intel', 'ppc', 'ppc64'):
 1035:                 matches.append('universal')
 1036:             while minor >= 0:
 1037:                 for match in matches:
 1038:                     s = '%s_%s_%s_%s' % (name, major, minor, match)
 1039:                     if s != ARCH:  # already there
 1040:                         arches.append(s)
 1041:                 minor -= 1
 1042: 
 1043:     # Most specific - our Python version, ABI and arch
 1044:     for i, version_object in enumerate(versions):
 1045:         version = str(version_object)
 1046:         add_abis = []
 1047: 
 1048:         if i == 0:
 1049:             add_abis = abis
 1050: 
 1051:         if IMP_PREFIX == 'cp' and version_object.major_minor >= (3, 2):
 1052:             limited_api_abi = 'abi' + str(version_object.major)
 1053:             if limited_api_abi not in add_abis:
 1054:                 add_abis.append(limited_api_abi)
 1055: 
 1056:         for abi in add_abis:
 1057:             for arch in arches:
 1058:                 result.append((''.join((IMP_PREFIX, version)), abi, arch))
 1059:                 # manylinux
 1060:                 if abi != 'none' and sys.platform.startswith('linux'):
 1061:                     arch = arch.replace('linux_', '')
 1062:                     parts = _get_glibc_version()
 1063:                     if len(parts) == 2:
 1064:                         if parts >= (2, 5):
 1065:                             result.append((''.join((IMP_PREFIX, version)), abi, 'manylinux1_%s' % arch))
 1066:                         if parts >= (2, 12):
 1067:                             result.append((''.join((IMP_PREFIX, version)), abi, 'manylinux2010_%s' % arch))
 1068:                         if parts >= (2, 17):
 1069:                             result.append((''.join((IMP_PREFIX, version)), abi, 'manylinux2014_%s' % arch))
 1070:                         result.append((''.join(
 1071:                             (IMP_PREFIX, version)), abi, 'manylinux_%s_%s_%s' % (parts[0], parts[1], arch)))
 1072: 
 1073:     # where no ABI / arch dependency, but IMP_PREFIX dependency
 1074:     for i, version_object in enumerate(versions):
 1075:         version = str(version_object)
 1076:         result.append((''.join((IMP_PREFIX, version)), 'none', 'any'))
 1077:         if i == 0:
 1078:             result.append((''.join((IMP_PREFIX, version[0])), 'none', 'any'))
 1079: 
 1080:     # no IMP_PREFIX, ABI or arch dependency
 1081:     for i, version_object in enumerate(versions):
 1082:         version = str(version_object)
 1083:         result.append((''.join(('py', version)), 'none', 'any'))
 1084:         if i == 0:
 1085:             result.append((''.join(('py', version[0])), 'none', 'any'))
 1086: 
 1087:     return set(result)
 1088: 
 1089: 
 1090: COMPATIBLE_TAGS = compatible_tags()
 1091: 
 1092: del compatible_tags
 1093: 
 1094: 
 1095: def is_compatible(wheel, tags=None):
 1096:     if not isinstance(wheel, Wheel):
 1097:         wheel = Wheel(wheel)  # assume it's a filename
 1098:     result = False
 1099:     if tags is None:
 1100:         tags = COMPATIBLE_TAGS
 1101:     for ver, abi, arch in tags:
 1102:         if ver in wheel.pyver and abi in wheel.abi and arch in wheel.arch:
 1103:             result = True
 1104:             break
 1105:     return result
