    1: # -*- coding: utf-8 -*-
    2: #
    3: # Copyright (C) 2012-2023 The Python Software Foundation.
    4: # See LICENSE.txt and CONTRIBUTORS.txt.
    5: #
    6: """PEP 376 implementation."""
    7: 
    8: from __future__ import unicode_literals
    9: 
   10: import base64
   11: import codecs
   12: import contextlib
   13: import hashlib
   14: import logging
   15: import os
   16: import posixpath
   17: import sys
   18: import zipimport
   19: 
   20: from . import DistlibException, resources
   21: from .compat import StringIO
   22: from .version import get_scheme, UnsupportedVersionError
   23: from .metadata import (Metadata, METADATA_FILENAME, WHEEL_METADATA_FILENAME, LEGACY_METADATA_FILENAME)
   24: from .util import (parse_requirement, cached_property, parse_name_and_version, read_exports, write_exports, CSVReader,
   25:                    CSVWriter)
   26: 
   27: __all__ = [
   28:     'Distribution', 'BaseInstalledDistribution', 'InstalledDistribution', 'EggInfoDistribution', 'DistributionPath'
   29: ]
   30: 
   31: logger = logging.getLogger(__name__)
   32: 
   33: EXPORTS_FILENAME = 'pydist-exports.json'
   34: COMMANDS_FILENAME = 'pydist-commands.json'
   35: 
   36: DIST_FILES = ('INSTALLER', METADATA_FILENAME, 'RECORD', 'REQUESTED', 'RESOURCES', EXPORTS_FILENAME, 'SHARED')
   37: 
   38: DISTINFO_EXT = '.dist-info'
   39: 
   40: 
   41: class _Cache(object):
   42:     """
   43:     A simple cache mapping names and .dist-info paths to distributions
   44:     """
   45: 
   46:     def __init__(self):
   47:         """
   48:         Initialise an instance. There is normally one for each DistributionPath.
   49:         """
   50:         self.name = {}
   51:         self.path = {}
   52:         self.generated = False
   53: 
   54:     def clear(self):
   55:         """
   56:         Clear the cache, setting it to its initial state.
   57:         """
   58:         self.name.clear()
   59:         self.path.clear()
   60:         self.generated = False
   61: 
   62:     def add(self, dist):
   63:         """
   64:         Add a distribution to the cache.
   65:         :param dist: The distribution to add.
   66:         """
   67:         if dist.path not in self.path:
   68:             self.path[dist.path] = dist
   69:             self.name.setdefault(dist.key, []).append(dist)
   70: 
   71: 
   72: class DistributionPath(object):
   73:     """
   74:     Represents a set of distributions installed on a path (typically sys.path).
   75:     """
   76: 
   77:     def __init__(self, path=None, include_egg=False):
   78:         """
   79:         Create an instance from a path, optionally including legacy (distutils/
   80:         setuptools/distribute) distributions.
   81:         :param path: The path to use, as a list of directories. If not specified,
   82:                      sys.path is used.
   83:         :param include_egg: If True, this instance will look for and return legacy
   84:                             distributions as well as those based on PEP 376.
   85:         """
   86:         if path is None:
   87:             path = sys.path
   88:         self.path = path
   89:         self._include_dist = True
   90:         self._include_egg = include_egg
   91: 
   92:         self._cache = _Cache()
   93:         self._cache_egg = _Cache()
   94:         self._cache_enabled = True
   95:         self._scheme = get_scheme('default')
   96: 
   97:     def _get_cache_enabled(self):
   98:         return self._cache_enabled
   99: 
  100:     def _set_cache_enabled(self, value):
  101:         self._cache_enabled = value
  102: 
  103:     cache_enabled = property(_get_cache_enabled, _set_cache_enabled)
  104: 
  105:     def clear_cache(self):
  106:         """
  107:         Clears the internal cache.
  108:         """
  109:         self._cache.clear()
  110:         self._cache_egg.clear()
  111: 
  112:     def _yield_distributions(self):
  113:         """
  114:         Yield .dist-info and/or .egg(-info) distributions.
  115:         """
  116:         # We need to check if we've seen some resources already, because on
  117:         # some Linux systems (e.g. some Debian/Ubuntu variants) there are
  118:         # symlinks which alias other files in the environment.
  119:         seen = set()
  120:         for path in self.path:
  121:             finder = resources.finder_for_path(path)
  122:             if finder is None:
  123:                 continue
  124:             r = finder.find('')
  125:             if not r or not r.is_container:
  126:                 continue
  127:             rset = sorted(r.resources)
  128:             for entry in rset:
  129:                 r = finder.find(entry)
  130:                 if not r or r.path in seen:
  131:                     continue
  132:                 try:
  133:                     if self._include_dist and entry.endswith(DISTINFO_EXT):
  134:                         possible_filenames = [METADATA_FILENAME, WHEEL_METADATA_FILENAME, LEGACY_METADATA_FILENAME]
  135:                         for metadata_filename in possible_filenames:
  136:                             metadata_path = posixpath.join(entry, metadata_filename)
  137:                             pydist = finder.find(metadata_path)
  138:                             if pydist:
  139:                                 break
  140:                         else:
  141:                             continue
  142: 
  143:                         with contextlib.closing(pydist.as_stream()) as stream:
  144:                             metadata = Metadata(fileobj=stream, scheme='legacy')
  145:                         logger.debug('Found %s', r.path)
  146:                         seen.add(r.path)
  147:                         yield new_dist_class(r.path, metadata=metadata, env=self)
  148:                     elif self._include_egg and entry.endswith(('.egg-info', '.egg')):
  149:                         logger.debug('Found %s', r.path)
  150:                         seen.add(r.path)
  151:                         yield old_dist_class(r.path, self)
  152:                 except Exception as e:
  153:                     msg = 'Unable to read distribution at %s, perhaps due to bad metadata: %s'
  154:                     logger.warning(msg, r.path, e)
  155:                     import warnings
  156:                     warnings.warn(msg % (r.path, e), stacklevel=2)
  157: 
  158:     def _generate_cache(self):
  159:         """
  160:         Scan the path for distributions and populate the cache with
  161:         those that are found.
  162:         """
  163:         gen_dist = not self._cache.generated
  164:         gen_egg = self._include_egg and not self._cache_egg.generated
  165:         if gen_dist or gen_egg:
  166:             for dist in self._yield_distributions():
  167:                 if isinstance(dist, InstalledDistribution):
  168:                     self._cache.add(dist)
  169:                 else:
  170:                     self._cache_egg.add(dist)
  171: 
  172:             if gen_dist:
  173:                 self._cache.generated = True
  174:             if gen_egg:
  175:                 self._cache_egg.generated = True
  176: 
  177:     @classmethod
  178:     def distinfo_dirname(cls, name, version):
  179:         """
  180:         The *name* and *version* parameters are converted into their
  181:         filename-escaped form, i.e. any ``'-'`` characters are replaced
  182:         with ``'_'`` other than the one in ``'dist-info'`` and the one
  183:         separating the name from the version number.
  184: 
  185:         :parameter name: is converted to a standard distribution name by replacing
  186:                          any runs of non- alphanumeric characters with a single
  187:                          ``'-'``.
  188:         :type name: string
  189:         :parameter version: is converted to a standard version string. Spaces
  190:                             become dots, and all other non-alphanumeric characters
  191:                             (except dots) become dashes, with runs of multiple
  192:                             dashes condensed to a single dash.
  193:         :type version: string
  194:         :returns: directory name
  195:         :rtype: string"""
  196:         name = name.replace('-', '_')
  197:         return '-'.join([name, version]) + DISTINFO_EXT
  198: 
  199:     def get_distributions(self):
  200:         """
  201:         Provides an iterator that looks for distributions and returns
  202:         :class:`InstalledDistribution` or
  203:         :class:`EggInfoDistribution` instances for each one of them.
  204: 
  205:         :rtype: iterator of :class:`InstalledDistribution` and
  206:                 :class:`EggInfoDistribution` instances
  207:         """
  208:         if not self._cache_enabled:
  209:             for dist in self._yield_distributions():
  210:                 yield dist
  211:         else:
  212:             self._generate_cache()
  213: 
  214:             for dist in self._cache.path.values():
  215:                 yield dist
  216: 
  217:             if self._include_egg:
  218:                 for dist in self._cache_egg.path.values():
  219:                     yield dist
  220: 
  221:     def get_distribution(self, name):
  222:         """
  223:         Looks for a named distribution on the path.
  224: 
  225:         This function only returns the first result found, as no more than one
  226:         value is expected. If nothing is found, ``None`` is returned.
  227: 
  228:         :rtype: :class:`InstalledDistribution`, :class:`EggInfoDistribution`
  229:                 or ``None``
  230:         """
  231:         result = None
  232:         name = name.lower()
  233:         if not self._cache_enabled:
  234:             for dist in self._yield_distributions():
  235:                 if dist.key == name:
  236:                     result = dist
  237:                     break
  238:         else:
  239:             self._generate_cache()
  240: 
  241:             if name in self._cache.name:
  242:                 result = self._cache.name[name][0]
  243:             elif self._include_egg and name in self._cache_egg.name:
  244:                 result = self._cache_egg.name[name][0]
  245:         return result
  246: 
  247:     def provides_distribution(self, name, version=None):
  248:         """
  249:         Iterates over all distributions to find which distributions provide *name*.
  250:         If a *version* is provided, it will be used to filter the results.
  251: 
  252:         This function only returns the first result found, since no more than
  253:         one values are expected. If the directory is not found, returns ``None``.
  254: 
  255:         :parameter version: a version specifier that indicates the version
  256:                             required, conforming to the format in ``PEP-345``
  257: 
  258:         :type name: string
  259:         :type version: string
  260:         """
  261:         matcher = None
  262:         if version is not None:
  263:             try:
  264:                 matcher = self._scheme.matcher('%s (%s)' % (name, version))
  265:             except ValueError:
  266:                 raise DistlibException('invalid name or version: %r, %r' % (name, version))
  267: 
  268:         for dist in self.get_distributions():
  269:             # We hit a problem on Travis where enum34 was installed and doesn't
  270:             # have a provides attribute ...
  271:             if not hasattr(dist, 'provides'):
  272:                 logger.debug('No "provides": %s', dist)
  273:             else:
  274:                 provided = dist.provides
  275: 
  276:                 for p in provided:
  277:                     p_name, p_ver = parse_name_and_version(p)
  278:                     if matcher is None:
  279:                         if p_name == name:
  280:                             yield dist
  281:                             break
  282:                     else:
  283:                         if p_name == name and matcher.match(p_ver):
  284:                             yield dist
  285:                             break
  286: 
  287:     def get_file_path(self, name, relative_path):
  288:         """
  289:         Return the path to a resource file.
  290:         """
  291:         dist = self.get_distribution(name)
  292:         if dist is None:
  293:             raise LookupError('no distribution named %r found' % name)
  294:         return dist.get_resource_path(relative_path)
  295: 
  296:     def get_exported_entries(self, category, name=None):
  297:         """
  298:         Return all of the exported entries in a particular category.
  299: 
  300:         :param category: The category to search for entries.
  301:         :param name: If specified, only entries with that name are returned.
  302:         """
  303:         for dist in self.get_distributions():
  304:             r = dist.exports
  305:             if category in r:
  306:                 d = r[category]
  307:                 if name is not None:
  308:                     if name in d:
  309:                         yield d[name]
  310:                 else:
  311:                     for v in d.values():
  312:                         yield v
  313: 
  314: 
  315: class Distribution(object):
  316:     """
  317:     A base class for distributions, whether installed or from indexes.
  318:     Either way, it must have some metadata, so that's all that's needed
  319:     for construction.
  320:     """
  321: 
  322:     build_time_dependency = False
  323:     """
  324:     Set to True if it's known to be only a build-time dependency (i.e.
  325:     not needed after installation).
  326:     """
  327: 
  328:     requested = False
  329:     """A boolean that indicates whether the ``REQUESTED`` metadata file is
  330:     present (in other words, whether the package was installed by user
  331:     request or it was installed as a dependency)."""
  332: 
  333:     def __init__(self, metadata):
  334:         """
  335:         Initialise an instance.
  336:         :param metadata: The instance of :class:`Metadata` describing this
  337:         distribution.
  338:         """
  339:         self.metadata = metadata
  340:         self.name = metadata.name
  341:         self.key = self.name.lower()  # for case-insensitive comparisons
  342:         self.version = metadata.version
  343:         self.locator = None
  344:         self.digest = None
  345:         self.extras = None  # additional features requested
  346:         self.context = None  # environment marker overrides
  347:         self.download_urls = set()
  348:         self.digests = {}
  349: 
  350:     @property
  351:     def source_url(self):
  352:         """
  353:         The source archive download URL for this distribution.
  354:         """
  355:         return self.metadata.source_url
  356: 
  357:     download_url = source_url  # Backward compatibility
  358: 
  359:     @property
  360:     def name_and_version(self):
  361:         """
  362:         A utility property which displays the name and version in parentheses.
  363:         """
  364:         return '%s (%s)' % (self.name, self.version)
  365: 
  366:     @property
  367:     def provides(self):
  368:         """
  369:         A set of distribution names and versions provided by this distribution.
  370:         :return: A set of "name (version)" strings.
  371:         """
  372:         plist = self.metadata.provides
  373:         s = '%s (%s)' % (self.name, self.version)
  374:         if s not in plist:
  375:             plist.append(s)
  376:         return plist
  377: 
  378:     def _get_requirements(self, req_attr):
  379:         md = self.metadata
  380:         reqts = getattr(md, req_attr)
  381:         logger.debug('%s: got requirements %r from metadata: %r', self.name, req_attr, reqts)
  382:         return set(md.get_requirements(reqts, extras=self.extras, env=self.context))
  383: 
  384:     @property
  385:     def run_requires(self):
  386:         return self._get_requirements('run_requires')
  387: 
  388:     @property
  389:     def meta_requires(self):
  390:         return self._get_requirements('meta_requires')
  391: 
  392:     @property
  393:     def build_requires(self):
  394:         return self._get_requirements('build_requires')
  395: 
  396:     @property
  397:     def test_requires(self):
  398:         return self._get_requirements('test_requires')
  399: 
  400:     @property
  401:     def dev_requires(self):
  402:         return self._get_requirements('dev_requires')
  403: 
  404:     def matches_requirement(self, req):
  405:         """
  406:         Say if this instance matches (fulfills) a requirement.
  407:         :param req: The requirement to match.
  408:         :rtype req: str
  409:         :return: True if it matches, else False.
  410:         """
  411:         # Requirement may contain extras - parse to lose those
  412:         # from what's passed to the matcher
  413:         r = parse_requirement(req)
  414:         scheme = get_scheme(self.metadata.scheme)
  415:         try:
  416:             matcher = scheme.matcher(r.requirement)
  417:         except UnsupportedVersionError:
  418:             # XXX compat-mode if cannot read the version
  419:             logger.warning('could not read version %r - using name only', req)
  420:             name = req.split()[0]
  421:             matcher = scheme.matcher(name)
  422: 
  423:         name = matcher.key  # case-insensitive
  424: 
  425:         result = False
  426:         for p in self.provides:
  427:             p_name, p_ver = parse_name_and_version(p)
  428:             if p_name != name:
  429:                 continue
  430:             try:
  431:                 result = matcher.match(p_ver)
  432:                 break
  433:             except UnsupportedVersionError:
  434:                 pass
  435:         return result
  436: 
  437:     def __repr__(self):
  438:         """
  439:         Return a textual representation of this instance,
  440:         """
  441:         if self.source_url:
  442:             suffix = ' [%s]' % self.source_url
  443:         else:
  444:             suffix = ''
  445:         return '<Distribution %s (%s)%s>' % (self.name, self.version, suffix)
  446: 
  447:     def __eq__(self, other):
  448:         """
  449:         See if this distribution is the same as another.
  450:         :param other: The distribution to compare with. To be equal to one
  451:                       another. distributions must have the same type, name,
  452:                       version and source_url.
  453:         :return: True if it is the same, else False.
  454:         """
  455:         if type(other) is not type(self):
  456:             result = False
  457:         else:
  458:             result = (self.name == other.name and self.version == other.version and self.source_url == other.source_url)
  459:         return result
  460: 
  461:     def __hash__(self):
  462:         """
  463:         Compute hash in a way which matches the equality test.
  464:         """
  465:         return hash(self.name) + hash(self.version) + hash(self.source_url)
  466: 
  467: 
  468: class BaseInstalledDistribution(Distribution):
  469:     """
  470:     This is the base class for installed distributions (whether PEP 376 or
  471:     legacy).
  472:     """
  473: 
  474:     hasher = None
  475: 
  476:     def __init__(self, metadata, path, env=None):
  477:         """
  478:         Initialise an instance.
  479:         :param metadata: An instance of :class:`Metadata` which describes the
  480:                          distribution. This will normally have been initialised
  481:                          from a metadata file in the ``path``.
  482:         :param path:     The path of the ``.dist-info`` or ``.egg-info``
  483:                          directory for the distribution.
  484:         :param env:      This is normally the :class:`DistributionPath`
  485:                          instance where this distribution was found.
  486:         """
  487:         super(BaseInstalledDistribution, self).__init__(metadata)
  488:         self.path = path
  489:         self.dist_path = env
  490: 
  491:     def get_hash(self, data, hasher=None):
  492:         """
  493:         Get the hash of some data, using a particular hash algorithm, if
  494:         specified.
  495: 
  496:         :param data: The data to be hashed.
  497:         :type data: bytes
  498:         :param hasher: The name of a hash implementation, supported by hashlib,
  499:                        or ``None``. Examples of valid values are ``'sha1'``,
  500:                        ``'sha224'``, ``'sha384'``, '``sha256'``, ``'md5'`` and
  501:                        ``'sha512'``. If no hasher is specified, the ``hasher``
  502:                        attribute of the :class:`InstalledDistribution` instance
  503:                        is used. If the hasher is determined to be ``None``, MD5
  504:                        is used as the hashing algorithm.
  505:         :returns: The hash of the data. If a hasher was explicitly specified,
  506:                   the returned hash will be prefixed with the specified hasher
  507:                   followed by '='.
  508:         :rtype: str
  509:         """
  510:         if hasher is None:
  511:             hasher = self.hasher
  512:         if hasher is None:
  513:             hasher = hashlib.md5
  514:             prefix = ''
  515:         else:
  516:             hasher = getattr(hashlib, hasher)
  517:             prefix = '%s=' % self.hasher
  518:         digest = hasher(data).digest()
  519:         digest = base64.urlsafe_b64encode(digest).rstrip(b'=').decode('ascii')
  520:         return '%s%s' % (prefix, digest)
  521: 
  522: 
  523: class InstalledDistribution(BaseInstalledDistribution):
  524:     """
  525:     Created with the *path* of the ``.dist-info`` directory provided to the
  526:     constructor. It reads the metadata contained in ``pydist.json`` when it is
  527:     instantiated., or uses a passed in Metadata instance (useful for when
  528:     dry-run mode is being used).
  529:     """
  530: 
  531:     hasher = 'sha256'
  532: 
  533:     def __init__(self, path, metadata=None, env=None):
  534:         self.modules = []
  535:         self.finder = finder = resources.finder_for_path(path)
  536:         if finder is None:
  537:             raise ValueError('finder unavailable for %s' % path)
  538:         if env and env._cache_enabled and path in env._cache.path:
  539:             metadata = env._cache.path[path].metadata
  540:         elif metadata is None:
  541:             r = finder.find(METADATA_FILENAME)
  542:             # Temporary - for Wheel 0.23 support
  543:             if r is None:
  544:                 r = finder.find(WHEEL_METADATA_FILENAME)
  545:             # Temporary - for legacy support
  546:             if r is None:
  547:                 r = finder.find(LEGACY_METADATA_FILENAME)
  548:             if r is None:
  549:                 raise ValueError('no %s found in %s' % (METADATA_FILENAME, path))
  550:             with contextlib.closing(r.as_stream()) as stream:
  551:                 metadata = Metadata(fileobj=stream, scheme='legacy')
  552: 
  553:         super(InstalledDistribution, self).__init__(metadata, path, env)
  554: 
  555:         if env and env._cache_enabled:
  556:             env._cache.add(self)
  557: 
  558:         r = finder.find('REQUESTED')
  559:         self.requested = r is not None
  560:         p = os.path.join(path, 'top_level.txt')
  561:         if os.path.exists(p):
  562:             with open(p, 'rb') as f:
  563:                 data = f.read().decode('utf-8')
  564:             self.modules = data.splitlines()
  565: 
  566:     def __repr__(self):
  567:         return '<InstalledDistribution %r %s at %r>' % (self.name, self.version, self.path)
  568: 
  569:     def __str__(self):
  570:         return "%s %s" % (self.name, self.version)
  571: 
  572:     def _get_records(self):
  573:         """
  574:         Get the list of installed files for the distribution
  575:         :return: A list of tuples of path, hash and size. Note that hash and
  576:                  size might be ``None`` for some entries. The path is exactly
  577:                  as stored in the file (which is as in PEP 376).
  578:         """
  579:         results = []
  580:         r = self.get_distinfo_resource('RECORD')
  581:         with contextlib.closing(r.as_stream()) as stream:
  582:             with CSVReader(stream=stream) as record_reader:
  583:                 # Base location is parent dir of .dist-info dir
  584:                 # base_location = os.path.dirname(self.path)
  585:                 # base_location = os.path.abspath(base_location)
  586:                 for row in record_reader:
  587:                     missing = [None for i in range(len(row), 3)]
  588:                     path, checksum, size = row + missing
  589:                     # if not os.path.isabs(path):
  590:                     #     path = path.replace('/', os.sep)
  591:                     #     path = os.path.join(base_location, path)
  592:                     results.append((path, checksum, size))
  593:         return results
  594: 
  595:     @cached_property
  596:     def exports(self):
  597:         """
  598:         Return the information exported by this distribution.
  599:         :return: A dictionary of exports, mapping an export category to a dict
  600:                  of :class:`ExportEntry` instances describing the individual
  601:                  export entries, and keyed by name.
  602:         """
  603:         result = {}
  604:         r = self.get_distinfo_resource(EXPORTS_FILENAME)
  605:         if r:
  606:             result = self.read_exports()
  607:         return result
  608: 
  609:     def read_exports(self):
  610:         """
  611:         Read exports data from a file in .ini format.
  612: 
  613:         :return: A dictionary of exports, mapping an export category to a list
  614:                  of :class:`ExportEntry` instances describing the individual
  615:                  export entries.
  616:         """
  617:         result = {}
  618:         r = self.get_distinfo_resource(EXPORTS_FILENAME)
  619:         if r:
  620:             with contextlib.closing(r.as_stream()) as stream:
  621:                 result = read_exports(stream)
  622:         return result
  623: 
  624:     def write_exports(self, exports):
  625:         """
  626:         Write a dictionary of exports to a file in .ini format.
  627:         :param exports: A dictionary of exports, mapping an export category to
  628:                         a list of :class:`ExportEntry` instances describing the
  629:                         individual export entries.
  630:         """
  631:         rf = self.get_distinfo_file(EXPORTS_FILENAME)
  632:         with open(rf, 'w') as f:
  633:             write_exports(exports, f)
  634: 
  635:     def get_resource_path(self, relative_path):
  636:         """
  637:         NOTE: This API may change in the future.
  638: 
  639:         Return the absolute path to a resource file with the given relative
  640:         path.
  641: 
  642:         :param relative_path: The path, relative to .dist-info, of the resource
  643:                               of interest.
  644:         :return: The absolute path where the resource is to be found.
  645:         """
  646:         r = self.get_distinfo_resource('RESOURCES')
  647:         with contextlib.closing(r.as_stream()) as stream:
  648:             with CSVReader(stream=stream) as resources_reader:
  649:                 for relative, destination in resources_reader:
  650:                     if relative == relative_path:
  651:                         return destination
  652:         raise KeyError('no resource file with relative path %r '
  653:                        'is installed' % relative_path)
  654: 
  655:     def list_installed_files(self):
  656:         """
  657:         Iterates over the ``RECORD`` entries and returns a tuple
  658:         ``(path, hash, size)`` for each line.
  659: 
  660:         :returns: iterator of (path, hash, size)
  661:         """
  662:         for result in self._get_records():
  663:             yield result
  664: 
  665:     def write_installed_files(self, paths, prefix, dry_run=False):
  666:         """
  667:         Writes the ``RECORD`` file, using the ``paths`` iterable passed in. Any
  668:         existing ``RECORD`` file is silently overwritten.
  669: 
  670:         prefix is used to determine when to write absolute paths.
  671:         """
  672:         prefix = os.path.join(prefix, '')
  673:         base = os.path.dirname(self.path)
  674:         base_under_prefix = base.startswith(prefix)
  675:         base = os.path.join(base, '')
  676:         record_path = self.get_distinfo_file('RECORD')
  677:         logger.info('creating %s', record_path)
  678:         if dry_run:
  679:             return None
  680:         with CSVWriter(record_path) as writer:
  681:             for path in paths:
  682:                 if os.path.isdir(path) or path.endswith(('.pyc', '.pyo')):
  683:                     # do not put size and hash, as in PEP-376
  684:                     hash_value = size = ''
  685:                 else:
  686:                     size = '%d' % os.path.getsize(path)
  687:                     with open(path, 'rb') as fp:
  688:                         hash_value = self.get_hash(fp.read())
  689:                 if path.startswith(base) or (base_under_prefix and path.startswith(prefix)):
  690:                     path = os.path.relpath(path, base)
  691:                 writer.writerow((path, hash_value, size))
  692: 
  693:             # add the RECORD file itself
  694:             if record_path.startswith(base):
  695:                 record_path = os.path.relpath(record_path, base)
  696:             writer.writerow((record_path, '', ''))
  697:         return record_path
  698: 
  699:     def check_installed_files(self):
  700:         """
  701:         Checks that the hashes and sizes of the files in ``RECORD`` are
  702:         matched by the files themselves. Returns a (possibly empty) list of
  703:         mismatches. Each entry in the mismatch list will be a tuple consisting
  704:         of the path, 'exists', 'size' or 'hash' according to what didn't match
  705:         (existence is checked first, then size, then hash), the expected
  706:         value and the actual value.
  707:         """
  708:         mismatches = []
  709:         base = os.path.dirname(self.path)
  710:         record_path = self.get_distinfo_file('RECORD')
  711:         for path, hash_value, size in self.list_installed_files():
  712:             if not os.path.isabs(path):
  713:                 path = os.path.join(base, path)
  714:             if path == record_path:
  715:                 continue
  716:             if not os.path.exists(path):
  717:                 mismatches.append((path, 'exists', True, False))
  718:             elif os.path.isfile(path):
  719:                 actual_size = str(os.path.getsize(path))
  720:                 if size and actual_size != size:
  721:                     mismatches.append((path, 'size', size, actual_size))
  722:                 elif hash_value:
  723:                     if '=' in hash_value:
  724:                         hasher = hash_value.split('=', 1)[0]
  725:                     else:
  726:                         hasher = None
  727: 
  728:                     with open(path, 'rb') as f:
  729:                         actual_hash = self.get_hash(f.read(), hasher)
  730:                         if actual_hash != hash_value:
  731:                             mismatches.append((path, 'hash', hash_value, actual_hash))
  732:         return mismatches
  733: 
  734:     @cached_property
  735:     def shared_locations(self):
  736:         """
  737:         A dictionary of shared locations whose keys are in the set 'prefix',
  738:         'purelib', 'platlib', 'scripts', 'headers', 'data' and 'namespace'.
  739:         The corresponding value is the absolute path of that category for
  740:         this distribution, and takes into account any paths selected by the
  741:         user at installation time (e.g. via command-line arguments). In the
  742:         case of the 'namespace' key, this would be a list of absolute paths
  743:         for the roots of namespace packages in this distribution.
  744: 
  745:         The first time this property is accessed, the relevant information is
  746:         read from the SHARED file in the .dist-info directory.
  747:         """
  748:         result = {}
  749:         shared_path = os.path.join(self.path, 'SHARED')
  750:         if os.path.isfile(shared_path):
  751:             with codecs.open(shared_path, 'r', encoding='utf-8') as f:
  752:                 lines = f.read().splitlines()
  753:             for line in lines:
  754:                 key, value = line.split('=', 1)
  755:                 if key == 'namespace':
  756:                     result.setdefault(key, []).append(value)
  757:                 else:
  758:                     result[key] = value
  759:         return result
  760: 
  761:     def write_shared_locations(self, paths, dry_run=False):
  762:         """
  763:         Write shared location information to the SHARED file in .dist-info.
  764:         :param paths: A dictionary as described in the documentation for
  765:         :meth:`shared_locations`.
  766:         :param dry_run: If True, the action is logged but no file is actually
  767:                         written.
  768:         :return: The path of the file written to.
  769:         """
  770:         shared_path = os.path.join(self.path, 'SHARED')
  771:         logger.info('creating %s', shared_path)
  772:         if dry_run:
  773:             return None
  774:         lines = []
  775:         for key in ('prefix', 'lib', 'headers', 'scripts', 'data'):
  776:             path = paths[key]
  777:             if os.path.isdir(paths[key]):
  778:                 lines.append('%s=%s' % (key, path))
  779:         for ns in paths.get('namespace', ()):
  780:             lines.append('namespace=%s' % ns)
  781: 
  782:         with codecs.open(shared_path, 'w', encoding='utf-8') as f:
  783:             f.write('\n'.join(lines))
  784:         return shared_path
  785: 
  786:     def get_distinfo_resource(self, path):
  787:         if path not in DIST_FILES:
  788:             raise DistlibException('invalid path for a dist-info file: '
  789:                                    '%r at %r' % (path, self.path))
  790:         finder = resources.finder_for_path(self.path)
  791:         if finder is None:
  792:             raise DistlibException('Unable to get a finder for %s' % self.path)
  793:         return finder.find(path)
  794: 
  795:     def get_distinfo_file(self, path):
  796:         """
  797:         Returns a path located under the ``.dist-info`` directory. Returns a
  798:         string representing the path.
  799: 
  800:         :parameter path: a ``'/'``-separated path relative to the
  801:                          ``.dist-info`` directory or an absolute path;
  802:                          If *path* is an absolute path and doesn't start
  803:                          with the ``.dist-info`` directory path,
  804:                          a :class:`DistlibException` is raised
  805:         :type path: str
  806:         :rtype: str
  807:         """
  808:         # Check if it is an absolute path  # XXX use relpath, add tests
  809:         if path.find(os.sep) >= 0:
  810:             # it's an absolute path?
  811:             distinfo_dirname, path = path.split(os.sep)[-2:]
  812:             if distinfo_dirname != self.path.split(os.sep)[-1]:
  813:                 raise DistlibException('dist-info file %r does not belong to the %r %s '
  814:                                        'distribution' % (path, self.name, self.version))
  815: 
  816:         # The file must be relative
  817:         if path not in DIST_FILES:
  818:             raise DistlibException('invalid path for a dist-info file: '
  819:                                    '%r at %r' % (path, self.path))
  820: 
  821:         return os.path.join(self.path, path)
  822: 
  823:     def list_distinfo_files(self):
  824:         """
  825:         Iterates over the ``RECORD`` entries and returns paths for each line if
  826:         the path is pointing to a file located in the ``.dist-info`` directory
  827:         or one of its subdirectories.
  828: 
  829:         :returns: iterator of paths
  830:         """
  831:         base = os.path.dirname(self.path)
  832:         for path, checksum, size in self._get_records():
  833:             # XXX add separator or use real relpath algo
  834:             if not os.path.isabs(path):
  835:                 path = os.path.join(base, path)
  836:             if path.startswith(self.path):
  837:                 yield path
  838: 
  839:     def __eq__(self, other):
  840:         return (isinstance(other, InstalledDistribution) and self.path == other.path)
  841: 
  842:     # See http://docs.python.org/reference/datamodel#object.__hash__
  843:     __hash__ = object.__hash__
  844: 
  845: 
  846: class EggInfoDistribution(BaseInstalledDistribution):
  847:     """Created with the *path* of the ``.egg-info`` directory or file provided
  848:     to the constructor. It reads the metadata contained in the file itself, or
  849:     if the given path happens to be a directory, the metadata is read from the
  850:     file ``PKG-INFO`` under that directory."""
  851: 
  852:     requested = True  # as we have no way of knowing, assume it was
  853:     shared_locations = {}
  854: 
  855:     def __init__(self, path, env=None):
  856: 
  857:         def set_name_and_version(s, n, v):
  858:             s.name = n
  859:             s.key = n.lower()  # for case-insensitive comparisons
  860:             s.version = v
  861: 
  862:         self.path = path
  863:         self.dist_path = env
  864:         if env and env._cache_enabled and path in env._cache_egg.path:
  865:             metadata = env._cache_egg.path[path].metadata
  866:             set_name_and_version(self, metadata.name, metadata.version)
  867:         else:
  868:             metadata = self._get_metadata(path)
  869: 
  870:             # Need to be set before caching
  871:             set_name_and_version(self, metadata.name, metadata.version)
  872: 
  873:             if env and env._cache_enabled:
  874:                 env._cache_egg.add(self)
  875:         super(EggInfoDistribution, self).__init__(metadata, path, env)
  876: 
  877:     def _get_metadata(self, path):
  878:         requires = None
  879: 
  880:         def parse_requires_data(data):
  881:             """Create a list of dependencies from a requires.txt file.
  882: 
  883:             *data*: the contents of a setuptools-produced requires.txt file.
  884:             """
  885:             reqs = []
  886:             lines = data.splitlines()
  887:             for line in lines:
  888:                 line = line.strip()
  889:                 # sectioned files have bare newlines (separating sections)
  890:                 if not line:  # pragma: no cover
  891:                     continue
  892:                 if line.startswith('['):  # pragma: no cover
  893:                     logger.warning('Unexpected line: quitting requirement scan: %r', line)
  894:                     break
  895:                 r = parse_requirement(line)
  896:                 if not r:  # pragma: no cover
  897:                     logger.warning('Not recognised as a requirement: %r', line)
  898:                     continue
  899:                 if r.extras:  # pragma: no cover
  900:                     logger.warning('extra requirements in requires.txt are '
  901:                                    'not supported')
  902:                 if not r.constraints:
  903:                     reqs.append(r.name)
  904:                 else:
  905:                     cons = ', '.join('%s%s' % c for c in r.constraints)
  906:                     reqs.append('%s (%s)' % (r.name, cons))
  907:             return reqs
  908: 
  909:         def parse_requires_path(req_path):
  910:             """Create a list of dependencies from a requires.txt file.
  911: 
  912:             *req_path*: the path to a setuptools-produced requires.txt file.
  913:             """
  914: 
  915:             reqs = []
  916:             try:
  917:                 with codecs.open(req_path, 'r', 'utf-8') as fp:
  918:                     reqs = parse_requires_data(fp.read())
  919:             except IOError:
  920:                 pass
  921:             return reqs
  922: 
  923:         tl_path = tl_data = None
  924:         if path.endswith('.egg'):
  925:             if os.path.isdir(path):
  926:                 p = os.path.join(path, 'EGG-INFO')
  927:                 meta_path = os.path.join(p, 'PKG-INFO')
  928:                 metadata = Metadata(path=meta_path, scheme='legacy')
  929:                 req_path = os.path.join(p, 'requires.txt')
  930:                 tl_path = os.path.join(p, 'top_level.txt')
  931:                 requires = parse_requires_path(req_path)
  932:             else:
  933:                 # FIXME handle the case where zipfile is not available
  934:                 zipf = zipimport.zipimporter(path)
  935:                 fileobj = StringIO(zipf.get_data('EGG-INFO/PKG-INFO').decode('utf8'))
  936:                 metadata = Metadata(fileobj=fileobj, scheme='legacy')
  937:                 try:
  938:                     data = zipf.get_data('EGG-INFO/requires.txt')
  939:                     tl_data = zipf.get_data('EGG-INFO/top_level.txt').decode('utf-8')
  940:                     requires = parse_requires_data(data.decode('utf-8'))
  941:                 except IOError:
  942:                     requires = None
  943:         elif path.endswith('.egg-info'):
  944:             if os.path.isdir(path):
  945:                 req_path = os.path.join(path, 'requires.txt')
  946:                 requires = parse_requires_path(req_path)
  947:                 path = os.path.join(path, 'PKG-INFO')
  948:                 tl_path = os.path.join(path, 'top_level.txt')
  949:             metadata = Metadata(path=path, scheme='legacy')
  950:         else:
  951:             raise DistlibException('path must end with .egg-info or .egg, '
  952:                                    'got %r' % path)
  953: 
  954:         if requires:
  955:             metadata.add_requirements(requires)
  956:         # look for top-level modules in top_level.txt, if present
  957:         if tl_data is None:
  958:             if tl_path is not None and os.path.exists(tl_path):
  959:                 with open(tl_path, 'rb') as f:
  960:                     tl_data = f.read().decode('utf-8')
  961:         if not tl_data:
  962:             tl_data = []
  963:         else:
  964:             tl_data = tl_data.splitlines()
  965:         self.modules = tl_data
  966:         return metadata
  967: 
  968:     def __repr__(self):
  969:         return '<EggInfoDistribution %r %s at %r>' % (self.name, self.version, self.path)
  970: 
  971:     def __str__(self):
  972:         return "%s %s" % (self.name, self.version)
  973: 
  974:     def check_installed_files(self):
  975:         """
  976:         Checks that the hashes and sizes of the files in ``RECORD`` are
  977:         matched by the files themselves. Returns a (possibly empty) list of
  978:         mismatches. Each entry in the mismatch list will be a tuple consisting
  979:         of the path, 'exists', 'size' or 'hash' according to what didn't match
  980:         (existence is checked first, then size, then hash), the expected
  981:         value and the actual value.
  982:         """
  983:         mismatches = []
  984:         record_path = os.path.join(self.path, 'installed-files.txt')
  985:         if os.path.exists(record_path):
  986:             for path, _, _ in self.list_installed_files():
  987:                 if path == record_path:
  988:                     continue
  989:                 if not os.path.exists(path):
  990:                     mismatches.append((path, 'exists', True, False))
  991:         return mismatches
  992: 
  993:     def list_installed_files(self):
  994:         """
  995:         Iterates over the ``installed-files.txt`` entries and returns a tuple
  996:         ``(path, hash, size)`` for each line.
  997: 
  998:         :returns: a list of (path, hash, size)
  999:         """
 1000: 
 1001:         def _md5(path):
 1002:             f = open(path, 'rb')
 1003:             try:
 1004:                 content = f.read()
 1005:             finally:
 1006:                 f.close()
 1007:             return hashlib.md5(content).hexdigest()
 1008: 
 1009:         def _size(path):
 1010:             return os.stat(path).st_size
 1011: 
 1012:         record_path = os.path.join(self.path, 'installed-files.txt')
 1013:         result = []
 1014:         if os.path.exists(record_path):
 1015:             with codecs.open(record_path, 'r', encoding='utf-8') as f:
 1016:                 for line in f:
 1017:                     line = line.strip()
 1018:                     p = os.path.normpath(os.path.join(self.path, line))
 1019:                     # "./" is present as a marker between installed files
 1020:                     # and installation metadata files
 1021:                     if not os.path.exists(p):
 1022:                         logger.warning('Non-existent file: %s', p)
 1023:                         if p.endswith(('.pyc', '.pyo')):
 1024:                             continue
 1025:                         # otherwise fall through and fail
 1026:                     if not os.path.isdir(p):
 1027:                         result.append((p, _md5(p), _size(p)))
 1028:             result.append((record_path, None, None))
 1029:         return result
 1030: 
 1031:     def list_distinfo_files(self, absolute=False):
 1032:         """
 1033:         Iterates over the ``installed-files.txt`` entries and returns paths for
 1034:         each line if the path is pointing to a file located in the
 1035:         ``.egg-info`` directory or one of its subdirectories.
 1036: 
 1037:         :parameter absolute: If *absolute* is ``True``, each returned path is
 1038:                           transformed into a local absolute path. Otherwise the
 1039:                           raw value from ``installed-files.txt`` is returned.
 1040:         :type absolute: boolean
 1041:         :returns: iterator of paths
 1042:         """
 1043:         record_path = os.path.join(self.path, 'installed-files.txt')
 1044:         if os.path.exists(record_path):
 1045:             skip = True
 1046:             with codecs.open(record_path, 'r', encoding='utf-8') as f:
 1047:                 for line in f:
 1048:                     line = line.strip()
 1049:                     if line == './':
 1050:                         skip = False
 1051:                         continue
 1052:                     if not skip:
 1053:                         p = os.path.normpath(os.path.join(self.path, line))
 1054:                         if p.startswith(self.path):
 1055:                             if absolute:
 1056:                                 yield p
 1057:                             else:
 1058:                                 yield line
 1059: 
 1060:     def __eq__(self, other):
 1061:         return (isinstance(other, EggInfoDistribution) and self.path == other.path)
 1062: 
 1063:     # See http://docs.python.org/reference/datamodel#object.__hash__
 1064:     __hash__ = object.__hash__
 1065: 
 1066: 
 1067: new_dist_class = InstalledDistribution
 1068: old_dist_class = EggInfoDistribution
 1069: 
 1070: 
 1071: class DependencyGraph(object):
 1072:     """
 1073:     Represents a dependency graph between distributions.
 1074: 
 1075:     The dependency relationships are stored in an ``adjacency_list`` that maps
 1076:     distributions to a list of ``(other, label)`` tuples where  ``other``
 1077:     is a distribution and the edge is labeled with ``label`` (i.e. the version
 1078:     specifier, if such was provided). Also, for more efficient traversal, for
 1079:     every distribution ``x``, a list of predecessors is kept in
 1080:     ``reverse_list[x]``. An edge from distribution ``a`` to
 1081:     distribution ``b`` means that ``a`` depends on ``b``. If any missing
 1082:     dependencies are found, they are stored in ``missing``, which is a
 1083:     dictionary that maps distributions to a list of requirements that were not
 1084:     provided by any other distributions.
 1085:     """
 1086: 
 1087:     def __init__(self):
 1088:         self.adjacency_list = {}
 1089:         self.reverse_list = {}
 1090:         self.missing = {}
 1091: 
 1092:     def add_distribution(self, distribution):
 1093:         """Add the *distribution* to the graph.
 1094: 
 1095:         :type distribution: :class:`distutils2.database.InstalledDistribution`
 1096:                             or :class:`distutils2.database.EggInfoDistribution`
 1097:         """
 1098:         self.adjacency_list[distribution] = []
 1099:         self.reverse_list[distribution] = []
 1100:         # self.missing[distribution] = []
 1101: 
 1102:     def add_edge(self, x, y, label=None):
 1103:         """Add an edge from distribution *x* to distribution *y* with the given
 1104:         *label*.
 1105: 
 1106:         :type x: :class:`distutils2.database.InstalledDistribution` or
 1107:                  :class:`distutils2.database.EggInfoDistribution`
 1108:         :type y: :class:`distutils2.database.InstalledDistribution` or
 1109:                  :class:`distutils2.database.EggInfoDistribution`
 1110:         :type label: ``str`` or ``None``
 1111:         """
 1112:         self.adjacency_list[x].append((y, label))
 1113:         # multiple edges are allowed, so be careful
 1114:         if x not in self.reverse_list[y]:
 1115:             self.reverse_list[y].append(x)
 1116: 
 1117:     def add_missing(self, distribution, requirement):
 1118:         """
 1119:         Add a missing *requirement* for the given *distribution*.
 1120: 
 1121:         :type distribution: :class:`distutils2.database.InstalledDistribution`
 1122:                             or :class:`distutils2.database.EggInfoDistribution`
 1123:         :type requirement: ``str``
 1124:         """
 1125:         logger.debug('%s missing %r', distribution, requirement)
 1126:         self.missing.setdefault(distribution, []).append(requirement)
 1127: 
 1128:     def _repr_dist(self, dist):
 1129:         return '%s %s' % (dist.name, dist.version)
 1130: 
 1131:     def repr_node(self, dist, level=1):
 1132:         """Prints only a subgraph"""
 1133:         output = [self._repr_dist(dist)]
 1134:         for other, label in self.adjacency_list[dist]:
 1135:             dist = self._repr_dist(other)
 1136:             if label is not None:
 1137:                 dist = '%s [%s]' % (dist, label)
 1138:             output.append('    ' * level + str(dist))
 1139:             suboutput = self.repr_node(other, level + 1)
 1140:             subs = suboutput.split('\n')
 1141:             output.extend(subs[1:])
 1142:         return '\n'.join(output)
 1143: 
 1144:     def to_dot(self, f, skip_disconnected=True):
 1145:         """Writes a DOT output for the graph to the provided file *f*.
 1146: 
 1147:         If *skip_disconnected* is set to ``True``, then all distributions
 1148:         that are not dependent on any other distribution are skipped.
 1149: 
 1150:         :type f: has to support ``file``-like operations
 1151:         :type skip_disconnected: ``bool``
 1152:         """
 1153:         disconnected = []
 1154: 
 1155:         f.write("digraph dependencies {\n")
 1156:         for dist, adjs in self.adjacency_list.items():
 1157:             if len(adjs) == 0 and not skip_disconnected:
 1158:                 disconnected.append(dist)
 1159:             for other, label in adjs:
 1160:                 if label is not None:
 1161:                     f.write('"%s" -> "%s" [label="%s"]\n' % (dist.name, other.name, label))
 1162:                 else:
 1163:                     f.write('"%s" -> "%s"\n' % (dist.name, other.name))
 1164:         if not skip_disconnected and len(disconnected) > 0:
 1165:             f.write('subgraph disconnected {\n')
 1166:             f.write('label = "Disconnected"\n')
 1167:             f.write('bgcolor = red\n')
 1168: 
 1169:             for dist in disconnected:
 1170:                 f.write('"%s"' % dist.name)
 1171:                 f.write('\n')
 1172:             f.write('}\n')
 1173:         f.write('}\n')
 1174: 
 1175:     def topological_sort(self):
 1176:         """
 1177:         Perform a topological sort of the graph.
 1178:         :return: A tuple, the first element of which is a topologically sorted
 1179:                  list of distributions, and the second element of which is a
 1180:                  list of distributions that cannot be sorted because they have
 1181:                  circular dependencies and so form a cycle.
 1182:         """
 1183:         result = []
 1184:         # Make a shallow copy of the adjacency list
 1185:         alist = {}
 1186:         for k, v in self.adjacency_list.items():
 1187:             alist[k] = v[:]
 1188:         while True:
 1189:             # See what we can remove in this run
 1190:             to_remove = []
 1191:             for k, v in list(alist.items())[:]:
 1192:                 if not v:
 1193:                     to_remove.append(k)
 1194:                     del alist[k]
 1195:             if not to_remove:
 1196:                 # What's left in alist (if anything) is a cycle.
 1197:                 break
 1198:             # Remove from the adjacency list of others
 1199:             for k, v in alist.items():
 1200:                 alist[k] = [(d, r) for d, r in v if d not in to_remove]
 1201:             logger.debug('Moving to result: %s', ['%s (%s)' % (d.name, d.version) for d in to_remove])
 1202:             result.extend(to_remove)
 1203:         return result, list(alist.keys())
 1204: 
 1205:     def __repr__(self):
 1206:         """Representation of the graph"""
 1207:         output = []
 1208:         for dist, adjs in self.adjacency_list.items():
 1209:             output.append(self.repr_node(dist))
 1210:         return '\n'.join(output)
 1211: 
 1212: 
 1213: def make_graph(dists, scheme='default'):
 1214:     """Makes a dependency graph from the given distributions.
 1215: 
 1216:     :parameter dists: a list of distributions
 1217:     :type dists: list of :class:`distutils2.database.InstalledDistribution` and
 1218:                  :class:`distutils2.database.EggInfoDistribution` instances
 1219:     :rtype: a :class:`DependencyGraph` instance
 1220:     """
 1221:     scheme = get_scheme(scheme)
 1222:     graph = DependencyGraph()
 1223:     provided = {}  # maps names to lists of (version, dist) tuples
 1224: 
 1225:     # first, build the graph and find out what's provided
 1226:     for dist in dists:
 1227:         graph.add_distribution(dist)
 1228: 
 1229:         for p in dist.provides:
 1230:             name, version = parse_name_and_version(p)
 1231:             logger.debug('Add to provided: %s, %s, %s', name, version, dist)
 1232:             provided.setdefault(name, []).append((version, dist))
 1233: 
 1234:     # now make the edges
 1235:     for dist in dists:
 1236:         requires = (dist.run_requires | dist.meta_requires | dist.build_requires | dist.dev_requires)
 1237:         for req in requires:
 1238:             try:
 1239:                 matcher = scheme.matcher(req)
 1240:             except UnsupportedVersionError:
 1241:                 # XXX compat-mode if cannot read the version
 1242:                 logger.warning('could not read version %r - using name only', req)
 1243:                 name = req.split()[0]
 1244:                 matcher = scheme.matcher(name)
 1245: 
 1246:             name = matcher.key  # case-insensitive
 1247: 
 1248:             matched = False
 1249:             if name in provided:
 1250:                 for version, provider in provided[name]:
 1251:                     try:
 1252:                         match = matcher.match(version)
 1253:                     except UnsupportedVersionError:
 1254:                         match = False
 1255: 
 1256:                     if match:
 1257:                         graph.add_edge(dist, provider, req)
 1258:                         matched = True
 1259:                         break
 1260:             if not matched:
 1261:                 graph.add_missing(dist, req)
 1262:     return graph
 1263: 
 1264: 
 1265: def get_dependent_dists(dists, dist):
 1266:     """Recursively generate a list of distributions from *dists* that are
 1267:     dependent on *dist*.
 1268: 
 1269:     :param dists: a list of distributions
 1270:     :param dist: a distribution, member of *dists* for which we are interested
 1271:     """
 1272:     if dist not in dists:
 1273:         raise DistlibException('given distribution %r is not a member '
 1274:                                'of the list' % dist.name)
 1275:     graph = make_graph(dists)
 1276: 
 1277:     dep = [dist]  # dependent distributions
 1278:     todo = graph.reverse_list[dist]  # list of nodes we should inspect
 1279: 
 1280:     while todo:
 1281:         d = todo.pop()
 1282:         dep.append(d)
 1283:         for succ in graph.reverse_list[d]:
 1284:             if succ not in dep:
 1285:                 todo.append(succ)
 1286: 
 1287:     dep.pop(0)  # remove dist from dep, was there to prevent infinite loops
 1288:     return dep
 1289: 
 1290: 
 1291: def get_required_dists(dists, dist):
 1292:     """Recursively generate a list of distributions from *dists* that are
 1293:     required by *dist*.
 1294: 
 1295:     :param dists: a list of distributions
 1296:     :param dist: a distribution, member of *dists* for which we are interested
 1297:                  in finding the dependencies.
 1298:     """
 1299:     if dist not in dists:
 1300:         raise DistlibException('given distribution %r is not a member '
 1301:                                'of the list' % dist.name)
 1302:     graph = make_graph(dists)
 1303: 
 1304:     req = set()  # required distributions
 1305:     todo = graph.adjacency_list[dist]  # list of nodes we should inspect
 1306:     seen = set(t[0] for t in todo)  # already added to todo
 1307: 
 1308:     while todo:
 1309:         d = todo.pop()[0]
 1310:         req.add(d)
 1311:         pred_list = graph.adjacency_list[d]
 1312:         for pred in pred_list:
 1313:             d = pred[0]
 1314:             if d not in req and d not in seen:
 1315:                 seen.add(d)
 1316:                 todo.append(pred)
 1317:     return req
 1318: 
 1319: 
 1320: def make_dist(name, version, **kwargs):
 1321:     """
 1322:     A convenience method for making a dist given just a name and version.
 1323:     """
 1324:     summary = kwargs.pop('summary', 'Placeholder for summary')
 1325:     md = Metadata(**kwargs)
 1326:     md.name = name
 1327:     md.version = version
 1328:     md.summary = summary or 'Placeholder for summary'
 1329:     return Distribution(md)
