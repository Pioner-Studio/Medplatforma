    1: # -*- coding: utf-8 -*-
    2: #
    3: # Copyright (C) 2012 The Python Software Foundation.
    4: # See LICENSE.txt and CONTRIBUTORS.txt.
    5: #
    6: """Implementation of the Metadata for Python packages PEPs.
    7: 
    8: Supports all metadata formats (1.0, 1.1, 1.2, 1.3/2.1 and 2.2).
    9: """
   10: from __future__ import unicode_literals
   11: 
   12: import codecs
   13: from email import message_from_file
   14: import json
   15: import logging
   16: import re
   17: 
   18: from . import DistlibException, __version__
   19: from .compat import StringIO, string_types, text_type
   20: from .markers import interpret
   21: from .util import extract_by_key, get_extras
   22: from .version import get_scheme, PEP440_VERSION_RE
   23: 
   24: logger = logging.getLogger(__name__)
   25: 
   26: 
   27: class MetadataMissingError(DistlibException):
   28:     """A required metadata is missing"""
   29: 
   30: 
   31: class MetadataConflictError(DistlibException):
   32:     """Attempt to read or write metadata fields that are conflictual."""
   33: 
   34: 
   35: class MetadataUnrecognizedVersionError(DistlibException):
   36:     """Unknown metadata version number."""
   37: 
   38: 
   39: class MetadataInvalidError(DistlibException):
   40:     """A metadata value is invalid"""
   41: 
   42: 
   43: # public API of this module
   44: __all__ = ['Metadata', 'PKG_INFO_ENCODING', 'PKG_INFO_PREFERRED_VERSION']
   45: 
   46: # Encoding used for the PKG-INFO files
   47: PKG_INFO_ENCODING = 'utf-8'
   48: 
   49: # preferred version. Hopefully will be changed
   50: # to 1.2 once PEP 345 is supported everywhere
   51: PKG_INFO_PREFERRED_VERSION = '1.1'
   52: 
   53: _LINE_PREFIX_1_2 = re.compile('\n       \\|')
   54: _LINE_PREFIX_PRE_1_2 = re.compile('\n        ')
   55: _241_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform', 'Summary', 'Description', 'Keywords', 'Home-page',
   56:                'Author', 'Author-email', 'License')
   57: 
   58: _314_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform', 'Supported-Platform', 'Summary', 'Description',
   59:                'Keywords', 'Home-page', 'Author', 'Author-email', 'License', 'Classifier', 'Download-URL', 'Obsoletes',
   60:                'Provides', 'Requires')
   61: 
   62: _314_MARKERS = ('Obsoletes', 'Provides', 'Requires', 'Classifier', 'Download-URL')
   63: 
   64: _345_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform', 'Supported-Platform', 'Summary', 'Description',
   65:                'Keywords', 'Home-page', 'Author', 'Author-email', 'Maintainer', 'Maintainer-email', 'License',
   66:                'Classifier', 'Download-URL', 'Obsoletes-Dist', 'Project-URL', 'Provides-Dist', 'Requires-Dist',
   67:                'Requires-Python', 'Requires-External')
   68: 
   69: _345_MARKERS = ('Provides-Dist', 'Requires-Dist', 'Requires-Python', 'Obsoletes-Dist', 'Requires-External',
   70:                 'Maintainer', 'Maintainer-email', 'Project-URL')
   71: 
   72: _426_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform', 'Supported-Platform', 'Summary', 'Description',
   73:                'Keywords', 'Home-page', 'Author', 'Author-email', 'Maintainer', 'Maintainer-email', 'License',
   74:                'Classifier', 'Download-URL', 'Obsoletes-Dist', 'Project-URL', 'Provides-Dist', 'Requires-Dist',
   75:                'Requires-Python', 'Requires-External', 'Private-Version', 'Obsoleted-By', 'Setup-Requires-Dist',
   76:                'Extension', 'Provides-Extra')
   77: 
   78: _426_MARKERS = ('Private-Version', 'Provides-Extra', 'Obsoleted-By', 'Setup-Requires-Dist', 'Extension')
   79: 
   80: # See issue #106: Sometimes 'Requires' and 'Provides' occur wrongly in
   81: # the metadata. Include them in the tuple literal below to allow them
   82: # (for now).
   83: # Ditto for Obsoletes - see issue #140.
   84: _566_FIELDS = _426_FIELDS + ('Description-Content-Type', 'Requires', 'Provides', 'Obsoletes')
   85: 
   86: _566_MARKERS = ('Description-Content-Type', )
   87: 
   88: _643_MARKERS = ('Dynamic', 'License-File')
   89: 
   90: _643_FIELDS = _566_FIELDS + _643_MARKERS
   91: 
   92: _ALL_FIELDS = set()
   93: _ALL_FIELDS.update(_241_FIELDS)
   94: _ALL_FIELDS.update(_314_FIELDS)
   95: _ALL_FIELDS.update(_345_FIELDS)
   96: _ALL_FIELDS.update(_426_FIELDS)
   97: _ALL_FIELDS.update(_566_FIELDS)
   98: _ALL_FIELDS.update(_643_FIELDS)
   99: 
  100: EXTRA_RE = re.compile(r'''extra\s*==\s*("([^"]+)"|'([^']+)')''')
  101: 
  102: 
  103: def _version2fieldlist(version):
  104:     if version == '1.0':
  105:         return _241_FIELDS
  106:     elif version == '1.1':
  107:         return _314_FIELDS
  108:     elif version == '1.2':
  109:         return _345_FIELDS
  110:     elif version in ('1.3', '2.1'):
  111:         # avoid adding field names if already there
  112:         return _345_FIELDS + tuple(f for f in _566_FIELDS if f not in _345_FIELDS)
  113:     elif version == '2.0':
  114:         raise ValueError('Metadata 2.0 is withdrawn and not supported')
  115:         # return _426_FIELDS
  116:     elif version == '2.2':
  117:         return _643_FIELDS
  118:     raise MetadataUnrecognizedVersionError(version)
  119: 
  120: 
  121: def _best_version(fields):
  122:     """Detect the best version depending on the fields used."""
  123: 
  124:     def _has_marker(keys, markers):
  125:         return any(marker in keys for marker in markers)
  126: 
  127:     keys = [key for key, value in fields.items() if value not in ([], 'UNKNOWN', None)]
  128:     possible_versions = ['1.0', '1.1', '1.2', '1.3', '2.1', '2.2']  # 2.0 removed
  129: 
  130:     # first let's try to see if a field is not part of one of the version
  131:     for key in keys:
  132:         if key not in _241_FIELDS and '1.0' in possible_versions:
  133:             possible_versions.remove('1.0')
  134:             logger.debug('Removed 1.0 due to %s', key)
  135:         if key not in _314_FIELDS and '1.1' in possible_versions:
  136:             possible_versions.remove('1.1')
  137:             logger.debug('Removed 1.1 due to %s', key)
  138:         if key not in _345_FIELDS and '1.2' in possible_versions:
  139:             possible_versions.remove('1.2')
  140:             logger.debug('Removed 1.2 due to %s', key)
  141:         if key not in _566_FIELDS and '1.3' in possible_versions:
  142:             possible_versions.remove('1.3')
  143:             logger.debug('Removed 1.3 due to %s', key)
  144:         if key not in _566_FIELDS and '2.1' in possible_versions:
  145:             if key != 'Description':  # In 2.1, description allowed after headers
  146:                 possible_versions.remove('2.1')
  147:                 logger.debug('Removed 2.1 due to %s', key)
  148:         if key not in _643_FIELDS and '2.2' in possible_versions:
  149:             possible_versions.remove('2.2')
  150:             logger.debug('Removed 2.2 due to %s', key)
  151:         # if key not in _426_FIELDS and '2.0' in possible_versions:
  152:         # possible_versions.remove('2.0')
  153:         # logger.debug('Removed 2.0 due to %s', key)
  154: 
  155:     # possible_version contains qualified versions
  156:     if len(possible_versions) == 1:
  157:         return possible_versions[0]  # found !
  158:     elif len(possible_versions) == 0:
  159:         logger.debug('Out of options - unknown metadata set: %s', fields)
  160:         raise MetadataConflictError('Unknown metadata set')
  161: 
  162:     # let's see if one unique marker is found
  163:     is_1_1 = '1.1' in possible_versions and _has_marker(keys, _314_MARKERS)
  164:     is_1_2 = '1.2' in possible_versions and _has_marker(keys, _345_MARKERS)
  165:     is_2_1 = '2.1' in possible_versions and _has_marker(keys, _566_MARKERS)
  166:     # is_2_0 = '2.0' in possible_versions and _has_marker(keys, _426_MARKERS)
  167:     is_2_2 = '2.2' in possible_versions and _has_marker(keys, _643_MARKERS)
  168:     if int(is_1_1) + int(is_1_2) + int(is_2_1) + int(is_2_2) > 1:
  169:         raise MetadataConflictError('You used incompatible 1.1/1.2/2.1/2.2 fields')
  170: 
  171:     # we have the choice, 1.0, or 1.2, 2.1 or 2.2
  172:     #   - 1.0 has a broken Summary field but works with all tools
  173:     #   - 1.1 is to avoid
  174:     #   - 1.2 fixes Summary but has little adoption
  175:     #   - 2.1 adds more features
  176:     #   - 2.2 is the latest
  177:     if not is_1_1 and not is_1_2 and not is_2_1 and not is_2_2:
  178:         # we couldn't find any specific marker
  179:         if PKG_INFO_PREFERRED_VERSION in possible_versions:
  180:             return PKG_INFO_PREFERRED_VERSION
  181:     if is_1_1:
  182:         return '1.1'
  183:     if is_1_2:
  184:         return '1.2'
  185:     if is_2_1:
  186:         return '2.1'
  187:     # if is_2_2:
  188:     # return '2.2'
  189: 
  190:     return '2.2'
  191: 
  192: 
  193: # This follows the rules about transforming keys as described in
  194: # https://www.python.org/dev/peps/pep-0566/#id17
  195: _ATTR2FIELD = {name.lower().replace("-", "_"): name for name in _ALL_FIELDS}
  196: _FIELD2ATTR = {field: attr for attr, field in _ATTR2FIELD.items()}
  197: 
  198: _PREDICATE_FIELDS = ('Requires-Dist', 'Obsoletes-Dist', 'Provides-Dist')
  199: _VERSIONS_FIELDS = ('Requires-Python', )
  200: _VERSION_FIELDS = ('Version', )
  201: _LISTFIELDS = ('Platform', 'Classifier', 'Obsoletes', 'Requires', 'Provides', 'Obsoletes-Dist', 'Provides-Dist',
  202:                'Requires-Dist', 'Requires-External', 'Project-URL', 'Supported-Platform', 'Setup-Requires-Dist',
  203:                'Provides-Extra', 'Extension', 'License-File')
  204: _LISTTUPLEFIELDS = ('Project-URL', )
  205: 
  206: _ELEMENTSFIELD = ('Keywords', )
  207: 
  208: _UNICODEFIELDS = ('Author', 'Maintainer', 'Summary', 'Description')
  209: 
  210: _MISSING = object()
  211: 
  212: _FILESAFE = re.compile('[^A-Za-z0-9.]+')
  213: 
  214: 
  215: def _get_name_and_version(name, version, for_filename=False):
  216:     """Return the distribution name with version.
  217: 
  218:     If for_filename is true, return a filename-escaped form."""
  219:     if for_filename:
  220:         # For both name and version any runs of non-alphanumeric or '.'
  221:         # characters are replaced with a single '-'.  Additionally any
  222:         # spaces in the version string become '.'
  223:         name = _FILESAFE.sub('-', name)
  224:         version = _FILESAFE.sub('-', version.replace(' ', '.'))
  225:     return '%s-%s' % (name, version)
  226: 
  227: 
  228: class LegacyMetadata(object):
  229:     """The legacy metadata of a release.
  230: 
  231:     Supports versions 1.0, 1.1, 1.2, 2.0 and 1.3/2.1 (auto-detected). You can
  232:     instantiate the class with one of these arguments (or none):
  233:     - *path*, the path to a metadata file
  234:     - *fileobj* give a file-like object with metadata as content
  235:     - *mapping* is a dict-like object
  236:     - *scheme* is a version scheme name
  237:     """
  238: 
  239:     # TODO document the mapping API and UNKNOWN default key
  240: 
  241:     def __init__(self, path=None, fileobj=None, mapping=None, scheme='default'):
  242:         if [path, fileobj, mapping].count(None) < 2:
  243:             raise TypeError('path, fileobj and mapping are exclusive')
  244:         self._fields = {}
  245:         self.requires_files = []
  246:         self._dependencies = None
  247:         self.scheme = scheme
  248:         if path is not None:
  249:             self.read(path)
  250:         elif fileobj is not None:
  251:             self.read_file(fileobj)
  252:         elif mapping is not None:
  253:             self.update(mapping)
  254:             self.set_metadata_version()
  255: 
  256:     def set_metadata_version(self):
  257:         self._fields['Metadata-Version'] = _best_version(self._fields)
  258: 
  259:     def _write_field(self, fileobj, name, value):
  260:         fileobj.write('%s: %s\n' % (name, value))
  261: 
  262:     def __getitem__(self, name):
  263:         return self.get(name)
  264: 
  265:     def __setitem__(self, name, value):
  266:         return self.set(name, value)
  267: 
  268:     def __delitem__(self, name):
  269:         field_name = self._convert_name(name)
  270:         try:
  271:             del self._fields[field_name]
  272:         except KeyError:
  273:             raise KeyError(name)
  274: 
  275:     def __contains__(self, name):
  276:         return (name in self._fields or self._convert_name(name) in self._fields)
  277: 
  278:     def _convert_name(self, name):
  279:         if name in _ALL_FIELDS:
  280:             return name
  281:         name = name.replace('-', '_').lower()
  282:         return _ATTR2FIELD.get(name, name)
  283: 
  284:     def _default_value(self, name):
  285:         if name in _LISTFIELDS or name in _ELEMENTSFIELD:
  286:             return []
  287:         return 'UNKNOWN'
  288: 
  289:     def _remove_line_prefix(self, value):
  290:         if self.metadata_version in ('1.0', '1.1'):
  291:             return _LINE_PREFIX_PRE_1_2.sub('\n', value)
  292:         else:
  293:             return _LINE_PREFIX_1_2.sub('\n', value)
  294: 
  295:     def __getattr__(self, name):
  296:         if name in _ATTR2FIELD:
  297:             return self[name]
  298:         raise AttributeError(name)
  299: 
  300:     #
  301:     # Public API
  302:     #
  303: 
  304:     def get_fullname(self, filesafe=False):
  305:         """
  306:         Return the distribution name with version.
  307: 
  308:         If filesafe is true, return a filename-escaped form.
  309:         """
  310:         return _get_name_and_version(self['Name'], self['Version'], filesafe)
  311: 
  312:     def is_field(self, name):
  313:         """return True if name is a valid metadata key"""
  314:         name = self._convert_name(name)
  315:         return name in _ALL_FIELDS
  316: 
  317:     def is_multi_field(self, name):
  318:         name = self._convert_name(name)
  319:         return name in _LISTFIELDS
  320: 
  321:     def read(self, filepath):
  322:         """Read the metadata values from a file path."""
  323:         fp = codecs.open(filepath, 'r', encoding='utf-8')
  324:         try:
  325:             self.read_file(fp)
  326:         finally:
  327:             fp.close()
  328: 
  329:     def read_file(self, fileob):
  330:         """Read the metadata values from a file object."""
  331:         msg = message_from_file(fileob)
  332:         self._fields['Metadata-Version'] = msg['metadata-version']
  333: 
  334:         # When reading, get all the fields we can
  335:         for field in _ALL_FIELDS:
  336:             if field not in msg:
  337:                 continue
  338:             if field in _LISTFIELDS:
  339:                 # we can have multiple lines
  340:                 values = msg.get_all(field)
  341:                 if field in _LISTTUPLEFIELDS and values is not None:
  342:                     values = [tuple(value.split(',')) for value in values]
  343:                 self.set(field, values)
  344:             else:
  345:                 # single line
  346:                 value = msg[field]
  347:                 if value is not None and value != 'UNKNOWN':
  348:                     self.set(field, value)
  349: 
  350:         # PEP 566 specifies that the body be used for the description, if
  351:         # available
  352:         body = msg.get_payload()
  353:         self["Description"] = body if body else self["Description"]
  354:         # logger.debug('Attempting to set metadata for %s', self)
  355:         # self.set_metadata_version()
  356: 
  357:     def write(self, filepath, skip_unknown=False):
  358:         """Write the metadata fields to filepath."""
  359:         fp = codecs.open(filepath, 'w', encoding='utf-8')
  360:         try:
  361:             self.write_file(fp, skip_unknown)
  362:         finally:
  363:             fp.close()
  364: 
  365:     def write_file(self, fileobject, skip_unknown=False):
  366:         """Write the PKG-INFO format data to a file object."""
  367:         self.set_metadata_version()
  368: 
  369:         for field in _version2fieldlist(self['Metadata-Version']):
  370:             values = self.get(field)
  371:             if skip_unknown and values in ('UNKNOWN', [], ['UNKNOWN']):
  372:                 continue
  373:             if field in _ELEMENTSFIELD:
  374:                 self._write_field(fileobject, field, ','.join(values))
  375:                 continue
  376:             if field not in _LISTFIELDS:
  377:                 if field == 'Description':
  378:                     if self.metadata_version in ('1.0', '1.1'):
  379:                         values = values.replace('\n', '\n        ')
  380:                     else:
  381:                         values = values.replace('\n', '\n       |')
  382:                 values = [values]
  383: 
  384:             if field in _LISTTUPLEFIELDS:
  385:                 values = [','.join(value) for value in values]
  386: 
  387:             for value in values:
  388:                 self._write_field(fileobject, field, value)
  389: 
  390:     def update(self, other=None, **kwargs):
  391:         """Set metadata values from the given iterable `other` and kwargs.
  392: 
  393:         Behavior is like `dict.update`: If `other` has a ``keys`` method,
  394:         they are looped over and ``self[key]`` is assigned ``other[key]``.
  395:         Else, ``other`` is an iterable of ``(key, value)`` iterables.
  396: 
  397:         Keys that don't match a metadata field or that have an empty value are
  398:         dropped.
  399:         """
  400: 
  401:         def _set(key, value):
  402:             if key in _ATTR2FIELD and value:
  403:                 self.set(self._convert_name(key), value)
  404: 
  405:         if not other:
  406:             # other is None or empty container
  407:             pass
  408:         elif hasattr(other, 'keys'):
  409:             for k in other.keys():
  410:                 _set(k, other[k])
  411:         else:
  412:             for k, v in other:
  413:                 _set(k, v)
  414: 
  415:         if kwargs:
  416:             for k, v in kwargs.items():
  417:                 _set(k, v)
  418: 
  419:     def set(self, name, value):
  420:         """Control then set a metadata field."""
  421:         name = self._convert_name(name)
  422: 
  423:         if ((name in _ELEMENTSFIELD or name == 'Platform') and not isinstance(value, (list, tuple))):
  424:             if isinstance(value, string_types):
  425:                 value = [v.strip() for v in value.split(',')]
  426:             else:
  427:                 value = []
  428:         elif (name in _LISTFIELDS and not isinstance(value, (list, tuple))):
  429:             if isinstance(value, string_types):
  430:                 value = [value]
  431:             else:
  432:                 value = []
  433: 
  434:         if logger.isEnabledFor(logging.WARNING):
  435:             project_name = self['Name']
  436: 
  437:             scheme = get_scheme(self.scheme)
  438:             if name in _PREDICATE_FIELDS and value is not None:
  439:                 for v in value:
  440:                     # check that the values are valid
  441:                     if not scheme.is_valid_matcher(v.split(';')[0]):
  442:                         logger.warning("'%s': '%s' is not valid (field '%s')", project_name, v, name)
  443:             # FIXME this rejects UNKNOWN, is that right?
  444:             elif name in _VERSIONS_FIELDS and value is not None:
  445:                 if not scheme.is_valid_constraint_list(value):
  446:                     logger.warning("'%s': '%s' is not a valid version (field '%s')", project_name, value, name)
  447:             elif name in _VERSION_FIELDS and value is not None:
  448:                 if not scheme.is_valid_version(value):
  449:                     logger.warning("'%s': '%s' is not a valid version (field '%s')", project_name, value, name)
  450: 
  451:         if name in _UNICODEFIELDS:
  452:             if name == 'Description':
  453:                 value = self._remove_line_prefix(value)
  454: 
  455:         self._fields[name] = value
  456: 
  457:     def get(self, name, default=_MISSING):
  458:         """Get a metadata field."""
  459:         name = self._convert_name(name)
  460:         if name not in self._fields:
  461:             if default is _MISSING:
  462:                 default = self._default_value(name)
  463:             return default
  464:         if name in _UNICODEFIELDS:
  465:             value = self._fields[name]
  466:             return value
  467:         elif name in _LISTFIELDS:
  468:             value = self._fields[name]
  469:             if value is None:
  470:                 return []
  471:             res = []
  472:             for val in value:
  473:                 if name not in _LISTTUPLEFIELDS:
  474:                     res.append(val)
  475:                 else:
  476:                     # That's for Project-URL
  477:                     res.append((val[0], val[1]))
  478:             return res
  479: 
  480:         elif name in _ELEMENTSFIELD:
  481:             value = self._fields[name]
  482:             if isinstance(value, string_types):
  483:                 return value.split(',')
  484:         return self._fields[name]
  485: 
  486:     def check(self, strict=False):
  487:         """Check if the metadata is compliant. If strict is True then raise if
  488:         no Name or Version are provided"""
  489:         self.set_metadata_version()
  490: 
  491:         # XXX should check the versions (if the file was loaded)
  492:         missing, warnings = [], []
  493: 
  494:         for attr in ('Name', 'Version'):  # required by PEP 345
  495:             if attr not in self:
  496:                 missing.append(attr)
  497: 
  498:         if strict and missing != []:
  499:             msg = 'missing required metadata: %s' % ', '.join(missing)
  500:             raise MetadataMissingError(msg)
  501: 
  502:         for attr in ('Home-page', 'Author'):
  503:             if attr not in self:
  504:                 missing.append(attr)
  505: 
  506:         # checking metadata 1.2 (XXX needs to check 1.1, 1.0)
  507:         if self['Metadata-Version'] != '1.2':
  508:             return missing, warnings
  509: 
  510:         scheme = get_scheme(self.scheme)
  511: 
  512:         def are_valid_constraints(value):
  513:             for v in value:
  514:                 if not scheme.is_valid_matcher(v.split(';')[0]):
  515:                     return False
  516:             return True
  517: 
  518:         for fields, controller in ((_PREDICATE_FIELDS, are_valid_constraints),
  519:                                    (_VERSIONS_FIELDS, scheme.is_valid_constraint_list), (_VERSION_FIELDS,
  520:                                                                                          scheme.is_valid_version)):
  521:             for field in fields:
  522:                 value = self.get(field, None)
  523:                 if value is not None and not controller(value):
  524:                     warnings.append("Wrong value for '%s': %s" % (field, value))
  525: 
  526:         return missing, warnings
  527: 
  528:     def todict(self, skip_missing=False):
  529:         """Return fields as a dict.
  530: 
  531:         Field names will be converted to use the underscore-lowercase style
  532:         instead of hyphen-mixed case (i.e. home_page instead of Home-page).
  533:         This is as per https://www.python.org/dev/peps/pep-0566/#id17.
  534:         """
  535:         self.set_metadata_version()
  536: 
  537:         fields = _version2fieldlist(self['Metadata-Version'])
  538: 
  539:         data = {}
  540: 
  541:         for field_name in fields:
  542:             if not skip_missing or field_name in self._fields:
  543:                 key = _FIELD2ATTR[field_name]
  544:                 if key != 'project_url':
  545:                     data[key] = self[field_name]
  546:                 else:
  547:                     data[key] = [','.join(u) for u in self[field_name]]
  548: 
  549:         return data
  550: 
  551:     def add_requirements(self, requirements):
  552:         if self['Metadata-Version'] == '1.1':
  553:             # we can't have 1.1 metadata *and* Setuptools requires
  554:             for field in ('Obsoletes', 'Requires', 'Provides'):
  555:                 if field in self:
  556:                     del self[field]
  557:         self['Requires-Dist'] += requirements
  558: 
  559:     # Mapping API
  560:     # TODO could add iter* variants
  561: 
  562:     def keys(self):
  563:         return list(_version2fieldlist(self['Metadata-Version']))
  564: 
  565:     def __iter__(self):
  566:         for key in self.keys():
  567:             yield key
  568: 
  569:     def values(self):
  570:         return [self[key] for key in self.keys()]
  571: 
  572:     def items(self):
  573:         return [(key, self[key]) for key in self.keys()]
  574: 
  575:     def __repr__(self):
  576:         return '<%s %s %s>' % (self.__class__.__name__, self.name, self.version)
  577: 
  578: 
  579: METADATA_FILENAME = 'pydist.json'
  580: WHEEL_METADATA_FILENAME = 'metadata.json'
  581: LEGACY_METADATA_FILENAME = 'METADATA'
  582: 
  583: 
  584: class Metadata(object):
  585:     """
  586:     The metadata of a release. This implementation uses 2.1
  587:     metadata where possible. If not possible, it wraps a LegacyMetadata
  588:     instance which handles the key-value metadata format.
  589:     """
  590: 
  591:     METADATA_VERSION_MATCHER = re.compile(r'^\d+(\.\d+)*$')
  592: 
  593:     NAME_MATCHER = re.compile('^[0-9A-Z]([0-9A-Z_.-]*[0-9A-Z])?$', re.I)
  594: 
  595:     FIELDNAME_MATCHER = re.compile('^[A-Z]([0-9A-Z-]*[0-9A-Z])?$', re.I)
  596: 
  597:     VERSION_MATCHER = PEP440_VERSION_RE
  598: 
  599:     SUMMARY_MATCHER = re.compile('.{1,2047}')
  600: 
  601:     METADATA_VERSION = '2.0'
  602: 
  603:     GENERATOR = 'distlib (%s)' % __version__
  604: 
  605:     MANDATORY_KEYS = {
  606:         'name': (),
  607:         'version': (),
  608:         'summary': ('legacy', ),
  609:     }
  610: 
  611:     INDEX_KEYS = ('name version license summary description author '
  612:                   'author_email keywords platform home_page classifiers '
  613:                   'download_url')
  614: 
  615:     DEPENDENCY_KEYS = ('extras run_requires test_requires build_requires '
  616:                        'dev_requires provides meta_requires obsoleted_by '
  617:                        'supports_environments')
  618: 
  619:     SYNTAX_VALIDATORS = {
  620:         'metadata_version': (METADATA_VERSION_MATCHER, ()),
  621:         'name': (NAME_MATCHER, ('legacy', )),
  622:         'version': (VERSION_MATCHER, ('legacy', )),
  623:         'summary': (SUMMARY_MATCHER, ('legacy', )),
  624:         'dynamic': (FIELDNAME_MATCHER, ('legacy', )),
  625:     }
  626: 
  627:     __slots__ = ('_legacy', '_data', 'scheme')
  628: 
  629:     def __init__(self, path=None, fileobj=None, mapping=None, scheme='default'):
  630:         if [path, fileobj, mapping].count(None) < 2:
  631:             raise TypeError('path, fileobj and mapping are exclusive')
  632:         self._legacy = None
  633:         self._data = None
  634:         self.scheme = scheme
  635:         # import pdb; pdb.set_trace()
  636:         if mapping is not None:
  637:             try:
  638:                 self._validate_mapping(mapping, scheme)
  639:                 self._data = mapping
  640:             except MetadataUnrecognizedVersionError:
  641:                 self._legacy = LegacyMetadata(mapping=mapping, scheme=scheme)
  642:                 self.validate()
  643:         else:
  644:             data = None
  645:             if path:
  646:                 with open(path, 'rb') as f:
  647:                     data = f.read()
  648:             elif fileobj:
  649:                 data = fileobj.read()
  650:             if data is None:
  651:                 # Initialised with no args - to be added
  652:                 self._data = {
  653:                     'metadata_version': self.METADATA_VERSION,
  654:                     'generator': self.GENERATOR,
  655:                 }
  656:             else:
  657:                 if not isinstance(data, text_type):
  658:                     data = data.decode('utf-8')
  659:                 try:
  660:                     self._data = json.loads(data)
  661:                     self._validate_mapping(self._data, scheme)
  662:                 except ValueError:
  663:                     # Note: MetadataUnrecognizedVersionError does not
  664:                     # inherit from ValueError (it's a DistlibException,
  665:                     # which should not inherit from ValueError).
  666:                     # The ValueError comes from the json.load - if that
  667:                     # succeeds and we get a validation error, we want
  668:                     # that to propagate
  669:                     self._legacy = LegacyMetadata(fileobj=StringIO(data), scheme=scheme)
  670:                     self.validate()
  671: 
  672:     common_keys = set(('name', 'version', 'license', 'keywords', 'summary'))
  673: 
  674:     none_list = (None, list)
  675:     none_dict = (None, dict)
  676: 
  677:     mapped_keys = {
  678:         'run_requires': ('Requires-Dist', list),
  679:         'build_requires': ('Setup-Requires-Dist', list),
  680:         'dev_requires': none_list,
  681:         'test_requires': none_list,
  682:         'meta_requires': none_list,
  683:         'extras': ('Provides-Extra', list),
  684:         'modules': none_list,
  685:         'namespaces': none_list,
  686:         'exports': none_dict,
  687:         'commands': none_dict,
  688:         'classifiers': ('Classifier', list),
  689:         'source_url': ('Download-URL', None),
  690:         'metadata_version': ('Metadata-Version', None),
  691:     }
  692: 
  693:     del none_list, none_dict
  694: 
  695:     def __getattribute__(self, key):
  696:         common = object.__getattribute__(self, 'common_keys')
  697:         mapped = object.__getattribute__(self, 'mapped_keys')
  698:         if key in mapped:
  699:             lk, maker = mapped[key]
  700:             if self._legacy:
  701:                 if lk is None:
  702:                     result = None if maker is None else maker()
  703:                 else:
  704:                     result = self._legacy.get(lk)
  705:             else:
  706:                 value = None if maker is None else maker()
  707:                 if key not in ('commands', 'exports', 'modules', 'namespaces', 'classifiers'):
  708:                     result = self._data.get(key, value)
  709:                 else:
  710:                     # special cases for PEP 459
  711:                     sentinel = object()
  712:                     result = sentinel
  713:                     d = self._data.get('extensions')
  714:                     if d:
  715:                         if key == 'commands':
  716:                             result = d.get('python.commands', value)
  717:                         elif key == 'classifiers':
  718:                             d = d.get('python.details')
  719:                             if d:
  720:                                 result = d.get(key, value)
  721:                         else:
  722:                             d = d.get('python.exports')
  723:                             if not d:
  724:                                 d = self._data.get('python.exports')
  725:                             if d:
  726:                                 result = d.get(key, value)
  727:                     if result is sentinel:
  728:                         result = value
  729:         elif key not in common:
  730:             result = object.__getattribute__(self, key)
  731:         elif self._legacy:
  732:             result = self._legacy.get(key)
  733:         else:
  734:             result = self._data.get(key)
  735:         return result
  736: 
  737:     def _validate_value(self, key, value, scheme=None):
  738:         if key in self.SYNTAX_VALIDATORS:
  739:             pattern, exclusions = self.SYNTAX_VALIDATORS[key]
  740:             if (scheme or self.scheme) not in exclusions:
  741:                 m = pattern.match(value)
  742:                 if not m:
  743:                     raise MetadataInvalidError("'%s' is an invalid value for "
  744:                                                "the '%s' property" % (value, key))
  745: 
  746:     def __setattr__(self, key, value):
  747:         self._validate_value(key, value)
  748:         common = object.__getattribute__(self, 'common_keys')
  749:         mapped = object.__getattribute__(self, 'mapped_keys')
  750:         if key in mapped:
  751:             lk, _ = mapped[key]
  752:             if self._legacy:
  753:                 if lk is None:
  754:                     raise NotImplementedError
  755:                 self._legacy[lk] = value
  756:             elif key not in ('commands', 'exports', 'modules', 'namespaces', 'classifiers'):
  757:                 self._data[key] = value
  758:             else:
  759:                 # special cases for PEP 459
  760:                 d = self._data.setdefault('extensions', {})
  761:                 if key == 'commands':
  762:                     d['python.commands'] = value
  763:                 elif key == 'classifiers':
  764:                     d = d.setdefault('python.details', {})
  765:                     d[key] = value
  766:                 else:
  767:                     d = d.setdefault('python.exports', {})
  768:                     d[key] = value
  769:         elif key not in common:
  770:             object.__setattr__(self, key, value)
  771:         else:
  772:             if key == 'keywords':
  773:                 if isinstance(value, string_types):
  774:                     value = value.strip()
  775:                     if value:
  776:                         value = value.split()
  777:                     else:
  778:                         value = []
  779:             if self._legacy:
  780:                 self._legacy[key] = value
  781:             else:
  782:                 self._data[key] = value
  783: 
  784:     @property
  785:     def name_and_version(self):
  786:         return _get_name_and_version(self.name, self.version, True)
  787: 
  788:     @property
  789:     def provides(self):
  790:         if self._legacy:
  791:             result = self._legacy['Provides-Dist']
  792:         else:
  793:             result = self._data.setdefault('provides', [])
  794:         s = '%s (%s)' % (self.name, self.version)
  795:         if s not in result:
  796:             result.append(s)
  797:         return result
  798: 
  799:     @provides.setter
  800:     def provides(self, value):
  801:         if self._legacy:
  802:             self._legacy['Provides-Dist'] = value
  803:         else:
  804:             self._data['provides'] = value
  805: 
  806:     def get_requirements(self, reqts, extras=None, env=None):
  807:         """
  808:         Base method to get dependencies, given a set of extras
  809:         to satisfy and an optional environment context.
  810:         :param reqts: A list of sometimes-wanted dependencies,
  811:                       perhaps dependent on extras and environment.
  812:         :param extras: A list of optional components being requested.
  813:         :param env: An optional environment for marker evaluation.
  814:         """
  815:         if self._legacy:
  816:             result = reqts
  817:         else:
  818:             result = []
  819:             extras = get_extras(extras or [], self.extras)
  820:             for d in reqts:
  821:                 if 'extra' not in d and 'environment' not in d:
  822:                     # unconditional
  823:                     include = True
  824:                 else:
  825:                     if 'extra' not in d:
  826:                         # Not extra-dependent - only environment-dependent
  827:                         include = True
  828:                     else:
  829:                         include = d.get('extra') in extras
  830:                     if include:
  831:                         # Not excluded because of extras, check environment
  832:                         marker = d.get('environment')
  833:                         if marker:
  834:                             include = interpret(marker, env)
  835:                 if include:
  836:                     result.extend(d['requires'])
  837:             for key in ('build', 'dev', 'test'):
  838:                 e = ':%s:' % key
  839:                 if e in extras:
  840:                     extras.remove(e)
  841:                     # A recursive call, but it should terminate since 'test'
  842:                     # has been removed from the extras
  843:                     reqts = self._data.get('%s_requires' % key, [])
  844:                     result.extend(self.get_requirements(reqts, extras=extras, env=env))
  845:         return result
  846: 
  847:     @property
  848:     def dictionary(self):
  849:         if self._legacy:
  850:             return self._from_legacy()
  851:         return self._data
  852: 
  853:     @property
  854:     def dependencies(self):
  855:         if self._legacy:
  856:             raise NotImplementedError
  857:         else:
  858:             return extract_by_key(self._data, self.DEPENDENCY_KEYS)
  859: 
  860:     @dependencies.setter
  861:     def dependencies(self, value):
  862:         if self._legacy:
  863:             raise NotImplementedError
  864:         else:
  865:             self._data.update(value)
  866: 
  867:     def _validate_mapping(self, mapping, scheme):
  868:         if mapping.get('metadata_version') != self.METADATA_VERSION:
  869:             raise MetadataUnrecognizedVersionError()
  870:         missing = []
  871:         for key, exclusions in self.MANDATORY_KEYS.items():
  872:             if key not in mapping:
  873:                 if scheme not in exclusions:
  874:                     missing.append(key)
  875:         if missing:
  876:             msg = 'Missing metadata items: %s' % ', '.join(missing)
  877:             raise MetadataMissingError(msg)
  878:         for k, v in mapping.items():
  879:             self._validate_value(k, v, scheme)
  880: 
  881:     def validate(self):
  882:         if self._legacy:
  883:             missing, warnings = self._legacy.check(True)
  884:             if missing or warnings:
  885:                 logger.warning('Metadata: missing: %s, warnings: %s', missing, warnings)
  886:         else:
  887:             self._validate_mapping(self._data, self.scheme)
  888: 
  889:     def todict(self):
  890:         if self._legacy:
  891:             return self._legacy.todict(True)
  892:         else:
  893:             result = extract_by_key(self._data, self.INDEX_KEYS)
  894:             return result
  895: 
  896:     def _from_legacy(self):
  897:         assert self._legacy and not self._data
  898:         result = {
  899:             'metadata_version': self.METADATA_VERSION,
  900:             'generator': self.GENERATOR,
  901:         }
  902:         lmd = self._legacy.todict(True)  # skip missing ones
  903:         for k in ('name', 'version', 'license', 'summary', 'description', 'classifier'):
  904:             if k in lmd:
  905:                 if k == 'classifier':
  906:                     nk = 'classifiers'
  907:                 else:
  908:                     nk = k
  909:                 result[nk] = lmd[k]
  910:         kw = lmd.get('Keywords', [])
  911:         if kw == ['']:
  912:             kw = []
  913:         result['keywords'] = kw
  914:         keys = (('requires_dist', 'run_requires'), ('setup_requires_dist', 'build_requires'))
  915:         for ok, nk in keys:
  916:             if ok in lmd and lmd[ok]:
  917:                 result[nk] = [{'requires': lmd[ok]}]
  918:         result['provides'] = self.provides
  919:         # author = {}
  920:         # maintainer = {}
  921:         return result
  922: 
  923:     LEGACY_MAPPING = {
  924:         'name': 'Name',
  925:         'version': 'Version',
  926:         ('extensions', 'python.details', 'license'): 'License',
  927:         'summary': 'Summary',
  928:         'description': 'Description',
  929:         ('extensions', 'python.project', 'project_urls', 'Home'): 'Home-page',
  930:         ('extensions', 'python.project', 'contacts', 0, 'name'): 'Author',
  931:         ('extensions', 'python.project', 'contacts', 0, 'email'): 'Author-email',
  932:         'source_url': 'Download-URL',
  933:         ('extensions', 'python.details', 'classifiers'): 'Classifier',
  934:     }
  935: 
  936:     def _to_legacy(self):
  937: 
  938:         def process_entries(entries):
  939:             reqts = set()
  940:             for e in entries:
  941:                 extra = e.get('extra')
  942:                 env = e.get('environment')
  943:                 rlist = e['requires']
  944:                 for r in rlist:
  945:                     if not env and not extra:
  946:                         reqts.add(r)
  947:                     else:
  948:                         marker = ''
  949:                         if extra:
  950:                             marker = 'extra == "%s"' % extra
  951:                         if env:
  952:                             if marker:
  953:                                 marker = '(%s) and %s' % (env, marker)
  954:                             else:
  955:                                 marker = env
  956:                         reqts.add(';'.join((r, marker)))
  957:             return reqts
  958: 
  959:         assert self._data and not self._legacy
  960:         result = LegacyMetadata()
  961:         nmd = self._data
  962:         # import pdb; pdb.set_trace()
  963:         for nk, ok in self.LEGACY_MAPPING.items():
  964:             if not isinstance(nk, tuple):
  965:                 if nk in nmd:
  966:                     result[ok] = nmd[nk]
  967:             else:
  968:                 d = nmd
  969:                 found = True
  970:                 for k in nk:
  971:                     try:
  972:                         d = d[k]
  973:                     except (KeyError, IndexError):
  974:                         found = False
  975:                         break
  976:                 if found:
  977:                     result[ok] = d
  978:         r1 = process_entries(self.run_requires + self.meta_requires)
  979:         r2 = process_entries(self.build_requires + self.dev_requires)
  980:         if self.extras:
  981:             result['Provides-Extra'] = sorted(self.extras)
  982:         result['Requires-Dist'] = sorted(r1)
  983:         result['Setup-Requires-Dist'] = sorted(r2)
  984:         # TODO: any other fields wanted
  985:         return result
  986: 
  987:     def write(self, path=None, fileobj=None, legacy=False, skip_unknown=True):
  988:         if [path, fileobj].count(None) != 1:
  989:             raise ValueError('Exactly one of path and fileobj is needed')
  990:         self.validate()
  991:         if legacy:
  992:             if self._legacy:
  993:                 legacy_md = self._legacy
  994:             else:
  995:                 legacy_md = self._to_legacy()
  996:             if path:
  997:                 legacy_md.write(path, skip_unknown=skip_unknown)
  998:             else:
  999:                 legacy_md.write_file(fileobj, skip_unknown=skip_unknown)
 1000:         else:
 1001:             if self._legacy:
 1002:                 d = self._from_legacy()
 1003:             else:
 1004:                 d = self._data
 1005:             if fileobj:
 1006:                 json.dump(d, fileobj, ensure_ascii=True, indent=2, sort_keys=True)
 1007:             else:
 1008:                 with codecs.open(path, 'w', 'utf-8') as f:
 1009:                     json.dump(d, f, ensure_ascii=True, indent=2, sort_keys=True)
 1010: 
 1011:     def add_requirements(self, requirements):
 1012:         if self._legacy:
 1013:             self._legacy.add_requirements(requirements)
 1014:         else:
 1015:             run_requires = self._data.setdefault('run_requires', [])
 1016:             always = None
 1017:             for entry in run_requires:
 1018:                 if 'environment' not in entry and 'extra' not in entry:
 1019:                     always = entry
 1020:                     break
 1021:             if always is None:
 1022:                 always = {'requires': requirements}
 1023:                 run_requires.insert(0, always)
 1024:             else:
 1025:                 rset = set(always['requires']) | set(requirements)
 1026:                 always['requires'] = sorted(rset)
 1027: 
 1028:     def __repr__(self):
 1029:         name = self.name or '(no name)'
 1030:         version = self.version or 'no version'
 1031:         return '<%s %s %s (%s)>' % (self.__class__.__name__, self.metadata_version, name, version)
