    1: # Copyright 2009-2015 MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Tools for working with MongoDB ObjectIds."""
   16: from __future__ import annotations
   17: 
   18: import binascii
   19: import calendar
   20: import datetime
   21: import os
   22: import struct
   23: import threading
   24: import time
   25: from random import SystemRandom
   26: from typing import Any, NoReturn, Optional, Type, Union
   27: 
   28: from bson.errors import InvalidId
   29: from bson.tz_util import utc
   30: 
   31: _MAX_COUNTER_VALUE = 0xFFFFFF
   32: 
   33: 
   34: def _raise_invalid_id(oid: str) -> NoReturn:
   35:     raise InvalidId(
   36:         "%r is not a valid ObjectId, it must be a 12-byte input"
   37:         " or a 24-character hex string" % oid
   38:     )
   39: 
   40: 
   41: def _random_bytes() -> bytes:
   42:     """Get the 5-byte random field of an ObjectId."""
   43:     return os.urandom(5)
   44: 
   45: 
   46: class ObjectId:
   47:     """A MongoDB ObjectId."""
   48: 
   49:     _pid = os.getpid()
   50: 
   51:     _inc = SystemRandom().randint(0, _MAX_COUNTER_VALUE)
   52:     _inc_lock = threading.Lock()
   53: 
   54:     __random = _random_bytes()
   55: 
   56:     __slots__ = ("__id",)
   57: 
   58:     _type_marker = 7
   59: 
   60:     def __init__(self, oid: Optional[Union[str, ObjectId, bytes]] = None) -> None:
   61:         """Initialize a new ObjectId.
   62: 
   63:         An ObjectId is a 12-byte unique identifier consisting of:
   64: 
   65:           - a 4-byte value representing the seconds since the Unix epoch,
   66:           - a 5-byte random value,
   67:           - a 3-byte counter, starting with a random value.
   68: 
   69:         By default, ``ObjectId()`` creates a new unique identifier. The
   70:         optional parameter `oid` can be an :class:`ObjectId`, or any 12
   71:         :class:`bytes`.
   72: 
   73:         For example, the 12 bytes b'foo-bar-quux' do not follow the ObjectId
   74:         specification but they are acceptable input::
   75: 
   76:           >>> ObjectId(b'foo-bar-quux')
   77:           ObjectId('666f6f2d6261722d71757578')
   78: 
   79:         `oid` can also be a :class:`str` of 24 hex digits::
   80: 
   81:           >>> ObjectId('0123456789ab0123456789ab')
   82:           ObjectId('0123456789ab0123456789ab')
   83: 
   84:         Raises :class:`~bson.errors.InvalidId` if `oid` is not 12 bytes nor
   85:         24 hex digits, or :class:`TypeError` if `oid` is not an accepted type.
   86: 
   87:         :param oid: a valid ObjectId.
   88: 
   89:         .. seealso:: The MongoDB documentation on  `ObjectIds <http://dochub.mongodb.org/core/objectids>`_.
   90: 
   91:         .. versionchanged:: 3.8
   92:            :class:`~bson.objectid.ObjectId` now implements the `ObjectID
   93:            specification version 0.2
   94:            <https://github.com/mongodb/specifications/blob/master/source/
   95:            objectid.rst>`_.
   96:         """
   97:         if oid is None:
   98:             self.__generate()
   99:         elif isinstance(oid, bytes) and len(oid) == 12:
  100:             self.__id = oid
  101:         else:
  102:             self.__validate(oid)
  103: 
  104:     @classmethod
  105:     def from_datetime(cls: Type[ObjectId], generation_time: datetime.datetime) -> ObjectId:
  106:         """Create a dummy ObjectId instance with a specific generation time.
  107: 
  108:         This method is useful for doing range queries on a field
  109:         containing :class:`ObjectId` instances.
  110: 
  111:         .. warning::
  112:            It is not safe to insert a document containing an ObjectId
  113:            generated using this method. This method deliberately
  114:            eliminates the uniqueness guarantee that ObjectIds
  115:            generally provide. ObjectIds generated with this method
  116:            should be used exclusively in queries.
  117: 
  118:         `generation_time` will be converted to UTC. Naive datetime
  119:         instances will be treated as though they already contain UTC.
  120: 
  121:         An example using this helper to get documents where ``"_id"``
  122:         was generated before January 1, 2010 would be:
  123: 
  124:         >>> gen_time = datetime.datetime(2010, 1, 1)
  125:         >>> dummy_id = ObjectId.from_datetime(gen_time)
  126:         >>> result = collection.find({"_id": {"$lt": dummy_id}})
  127: 
  128:         :param generation_time: :class:`~datetime.datetime` to be used
  129:             as the generation time for the resulting ObjectId.
  130:         """
  131:         offset = generation_time.utcoffset()
  132:         if offset is not None:
  133:             generation_time = generation_time - offset
  134:         timestamp = calendar.timegm(generation_time.timetuple())
  135:         oid = struct.pack(">I", int(timestamp)) + b"\x00\x00\x00\x00\x00\x00\x00\x00"
  136:         return cls(oid)
  137: 
  138:     @classmethod
  139:     def is_valid(cls: Type[ObjectId], oid: Any) -> bool:
  140:         """Checks if a `oid` string is valid or not.
  141: 
  142:         :param oid: the object id to validate
  143: 
  144:         .. versionadded:: 2.3
  145:         """
  146:         if not oid:
  147:             return False
  148: 
  149:         try:
  150:             ObjectId(oid)
  151:             return True
  152:         except (InvalidId, TypeError):
  153:             return False
  154: 
  155:     @classmethod
  156:     def _random(cls) -> bytes:
  157:         """Generate a 5-byte random number once per process."""
  158:         pid = os.getpid()
  159:         if pid != cls._pid:
  160:             cls._pid = pid
  161:             cls.__random = _random_bytes()
  162:         return cls.__random
  163: 
  164:     def __generate(self) -> None:
  165:         """Generate a new value for this ObjectId."""
  166:         # 4 bytes current time
  167:         oid = struct.pack(">I", int(time.time()))
  168: 
  169:         # 5 bytes random
  170:         oid += ObjectId._random()
  171: 
  172:         # 3 bytes inc
  173:         with ObjectId._inc_lock:
  174:             oid += struct.pack(">I", ObjectId._inc)[1:4]
  175:             ObjectId._inc = (ObjectId._inc + 1) % (_MAX_COUNTER_VALUE + 1)
  176: 
  177:         self.__id = oid
  178: 
  179:     def __validate(self, oid: Any) -> None:
  180:         """Validate and use the given id for this ObjectId.
  181: 
  182:         Raises TypeError if id is not an instance of :class:`str`,
  183:         :class:`bytes`, or ObjectId. Raises InvalidId if it is not a
  184:         valid ObjectId.
  185: 
  186:         :param oid: a valid ObjectId
  187:         """
  188:         if isinstance(oid, ObjectId):
  189:             self.__id = oid.binary
  190:         elif isinstance(oid, str):
  191:             if len(oid) == 24:
  192:                 try:
  193:                     self.__id = bytes.fromhex(oid)
  194:                 except (TypeError, ValueError):
  195:                     _raise_invalid_id(oid)
  196:             else:
  197:                 _raise_invalid_id(oid)
  198:         else:
  199:             raise TypeError(f"id must be an instance of (bytes, str, ObjectId), not {type(oid)}")
  200: 
  201:     @property
  202:     def binary(self) -> bytes:
  203:         """12-byte binary representation of this ObjectId."""
  204:         return self.__id
  205: 
  206:     @property
  207:     def generation_time(self) -> datetime.datetime:
  208:         """A :class:`datetime.datetime` instance representing the time of
  209:         generation for this :class:`ObjectId`.
  210: 
  211:         The :class:`datetime.datetime` is timezone aware, and
  212:         represents the generation time in UTC. It is precise to the
  213:         second.
  214:         """
  215:         timestamp = struct.unpack(">I", self.__id[0:4])[0]
  216:         return datetime.datetime.fromtimestamp(timestamp, utc)
  217: 
  218:     def __getstate__(self) -> bytes:
  219:         """Return value of object for pickling.
  220:         needed explicitly because __slots__() defined.
  221:         """
  222:         return self.__id
  223: 
  224:     def __setstate__(self, value: Any) -> None:
  225:         """Explicit state set from pickling"""
  226:         # Provide backwards compatibility with OIDs
  227:         # pickled with pymongo-1.9 or older.
  228:         if isinstance(value, dict):
  229:             oid = value["_ObjectId__id"]
  230:         else:
  231:             oid = value
  232:         # ObjectIds pickled in python 2.x used `str` for __id.
  233:         # In python 3.x this has to be converted to `bytes`
  234:         # by encoding latin-1.
  235:         if isinstance(oid, str):
  236:             self.__id = oid.encode("latin-1")
  237:         else:
  238:             self.__id = oid
  239: 
  240:     def __str__(self) -> str:
  241:         return binascii.hexlify(self.__id).decode()
  242: 
  243:     def __repr__(self) -> str:
  244:         return f"ObjectId('{self!s}')"
  245: 
  246:     def __eq__(self, other: Any) -> bool:
  247:         if isinstance(other, ObjectId):
  248:             return self.__id == other.binary
  249:         return NotImplemented
  250: 
  251:     def __ne__(self, other: Any) -> bool:
  252:         if isinstance(other, ObjectId):
  253:             return self.__id != other.binary
  254:         return NotImplemented
  255: 
  256:     def __lt__(self, other: Any) -> bool:
  257:         if isinstance(other, ObjectId):
  258:             return self.__id < other.binary
  259:         return NotImplemented
  260: 
  261:     def __le__(self, other: Any) -> bool:
  262:         if isinstance(other, ObjectId):
  263:             return self.__id <= other.binary
  264:         return NotImplemented
  265: 
  266:     def __gt__(self, other: Any) -> bool:
  267:         if isinstance(other, ObjectId):
  268:             return self.__id > other.binary
  269:         return NotImplemented
  270: 
  271:     def __ge__(self, other: Any) -> bool:
  272:         if isinstance(other, ObjectId):
  273:             return self.__id >= other.binary
  274:         return NotImplemented
  275: 
  276:     def __hash__(self) -> int:
  277:         """Get a hash value for this :class:`ObjectId`."""
  278:         return hash(self.__id)
