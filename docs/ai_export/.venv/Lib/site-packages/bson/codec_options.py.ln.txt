    1: # Copyright 2014-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Tools for specifying BSON codec options."""
   16: from __future__ import annotations
   17: 
   18: import abc
   19: import datetime
   20: import enum
   21: from collections.abc import MutableMapping as _MutableMapping
   22: from typing import (
   23:     TYPE_CHECKING,
   24:     Any,
   25:     Callable,
   26:     Generic,
   27:     Iterable,
   28:     Mapping,
   29:     NamedTuple,
   30:     Optional,
   31:     Tuple,
   32:     Type,
   33:     Union,
   34:     cast,
   35: )
   36: 
   37: from bson.binary import (
   38:     ALL_UUID_REPRESENTATIONS,
   39:     UUID_REPRESENTATION_NAMES,
   40:     UuidRepresentation,
   41: )
   42: from bson.typings import _DocumentType
   43: 
   44: _RAW_BSON_DOCUMENT_MARKER = 101
   45: 
   46: 
   47: def _raw_document_class(document_class: Any) -> bool:
   48:     """Determine if a document_class is a RawBSONDocument class."""
   49:     marker = getattr(document_class, "_type_marker", None)
   50:     return marker == _RAW_BSON_DOCUMENT_MARKER
   51: 
   52: 
   53: class TypeEncoder(abc.ABC):
   54:     """Base class for defining type codec classes which describe how a
   55:     custom type can be transformed to one of the types BSON understands.
   56: 
   57:     Codec classes must implement the ``python_type`` attribute, and the
   58:     ``transform_python`` method to support encoding.
   59: 
   60:     See :ref:`custom-type-type-codec` documentation for an example.
   61:     """
   62: 
   63:     @abc.abstractproperty
   64:     def python_type(self) -> Any:
   65:         """The Python type to be converted into something serializable."""
   66: 
   67:     @abc.abstractmethod
   68:     def transform_python(self, value: Any) -> Any:
   69:         """Convert the given Python object into something serializable."""
   70: 
   71: 
   72: class TypeDecoder(abc.ABC):
   73:     """Base class for defining type codec classes which describe how a
   74:     BSON type can be transformed to a custom type.
   75: 
   76:     Codec classes must implement the ``bson_type`` attribute, and the
   77:     ``transform_bson`` method to support decoding.
   78: 
   79:     See :ref:`custom-type-type-codec` documentation for an example.
   80:     """
   81: 
   82:     @abc.abstractproperty
   83:     def bson_type(self) -> Any:
   84:         """The BSON type to be converted into our own type."""
   85: 
   86:     @abc.abstractmethod
   87:     def transform_bson(self, value: Any) -> Any:
   88:         """Convert the given BSON value into our own type."""
   89: 
   90: 
   91: class TypeCodec(TypeEncoder, TypeDecoder):
   92:     """Base class for defining type codec classes which describe how a
   93:     custom type can be transformed to/from one of the types :mod:`bson`
   94:     can already encode/decode.
   95: 
   96:     Codec classes must implement the ``python_type`` attribute, and the
   97:     ``transform_python`` method to support encoding, as well as the
   98:     ``bson_type`` attribute, and the ``transform_bson`` method to support
   99:     decoding.
  100: 
  101:     See :ref:`custom-type-type-codec` documentation for an example.
  102:     """
  103: 
  104: 
  105: _Codec = Union[TypeEncoder, TypeDecoder, TypeCodec]
  106: _Fallback = Callable[[Any], Any]
  107: 
  108: 
  109: class TypeRegistry:
  110:     """Encapsulates type codecs used in encoding and / or decoding BSON, as
  111:     well as the fallback encoder. Type registries cannot be modified after
  112:     instantiation.
  113: 
  114:     ``TypeRegistry`` can be initialized with an iterable of type codecs, and
  115:     a callable for the fallback encoder::
  116: 
  117:       >>> from bson.codec_options import TypeRegistry
  118:       >>> type_registry = TypeRegistry([Codec1, Codec2, Codec3, ...],
  119:       ...                              fallback_encoder)
  120: 
  121:     See :ref:`custom-type-type-registry` documentation for an example.
  122: 
  123:     :param type_codecs: iterable of type codec instances. If
  124:         ``type_codecs`` contains multiple codecs that transform a single
  125:         python or BSON type, the transformation specified by the type codec
  126:         occurring last prevails. A TypeError will be raised if one or more
  127:         type codecs modify the encoding behavior of a built-in :mod:`bson`
  128:         type.
  129:     :param fallback_encoder: callable that accepts a single,
  130:         unencodable python value and transforms it into a type that
  131:         :mod:`bson` can encode. See :ref:`fallback-encoder-callable`
  132:         documentation for an example.
  133:     """
  134: 
  135:     def __init__(
  136:         self,
  137:         type_codecs: Optional[Iterable[_Codec]] = None,
  138:         fallback_encoder: Optional[_Fallback] = None,
  139:     ) -> None:
  140:         self.__type_codecs = list(type_codecs or [])
  141:         self._fallback_encoder = fallback_encoder
  142:         self._encoder_map: dict[Any, Any] = {}
  143:         self._decoder_map: dict[Any, Any] = {}
  144: 
  145:         if self._fallback_encoder is not None:
  146:             if not callable(fallback_encoder):
  147:                 raise TypeError("fallback_encoder %r is not a callable" % (fallback_encoder))
  148: 
  149:         for codec in self.__type_codecs:
  150:             is_valid_codec = False
  151:             if isinstance(codec, TypeEncoder):
  152:                 self._validate_type_encoder(codec)
  153:                 is_valid_codec = True
  154:                 self._encoder_map[codec.python_type] = codec.transform_python
  155:             if isinstance(codec, TypeDecoder):
  156:                 is_valid_codec = True
  157:                 self._decoder_map[codec.bson_type] = codec.transform_bson
  158:             if not is_valid_codec:
  159:                 raise TypeError(
  160:                     f"Expected an instance of {TypeEncoder.__name__}, {TypeDecoder.__name__}, or {TypeCodec.__name__}, got {codec!r} instead"
  161:                 )
  162: 
  163:     def _validate_type_encoder(self, codec: _Codec) -> None:
  164:         from bson import _BUILT_IN_TYPES
  165: 
  166:         for pytype in _BUILT_IN_TYPES:
  167:             if issubclass(cast(TypeCodec, codec).python_type, pytype):
  168:                 err_msg = (
  169:                     "TypeEncoders cannot change how built-in types are "
  170:                     f"encoded (encoder {codec} transforms type {pytype})"
  171:                 )
  172:                 raise TypeError(err_msg)
  173: 
  174:     def __repr__(self) -> str:
  175:         return "{}(type_codecs={!r}, fallback_encoder={!r})".format(
  176:             self.__class__.__name__,
  177:             self.__type_codecs,
  178:             self._fallback_encoder,
  179:         )
  180: 
  181:     def __eq__(self, other: Any) -> Any:
  182:         if not isinstance(other, type(self)):
  183:             return NotImplemented
  184:         return (
  185:             (self._decoder_map == other._decoder_map)
  186:             and (self._encoder_map == other._encoder_map)
  187:             and (self._fallback_encoder == other._fallback_encoder)
  188:         )
  189: 
  190: 
  191: class DatetimeConversion(int, enum.Enum):
  192:     """Options for decoding BSON datetimes."""
  193: 
  194:     DATETIME = 1
  195:     """Decode a BSON UTC datetime as a :class:`datetime.datetime`.
  196: 
  197:     BSON UTC datetimes that cannot be represented as a
  198:     :class:`~datetime.datetime` will raise an :class:`OverflowError`
  199:     or a :class:`ValueError`.
  200: 
  201:     .. versionadded 4.3
  202:     """
  203: 
  204:     DATETIME_CLAMP = 2
  205:     """Decode a BSON UTC datetime as a :class:`datetime.datetime`, clamping
  206:     to :attr:`~datetime.datetime.min` and :attr:`~datetime.datetime.max`.
  207: 
  208:     .. versionadded 4.3
  209:     """
  210: 
  211:     DATETIME_MS = 3
  212:     """Decode a BSON UTC datetime as a :class:`~bson.datetime_ms.DatetimeMS`
  213:     object.
  214: 
  215:     .. versionadded 4.3
  216:     """
  217: 
  218:     DATETIME_AUTO = 4
  219:     """Decode a BSON UTC datetime as a :class:`datetime.datetime` if possible,
  220:     and a :class:`~bson.datetime_ms.DatetimeMS` if not.
  221: 
  222:     .. versionadded 4.3
  223:     """
  224: 
  225: 
  226: class _BaseCodecOptions(NamedTuple):
  227:     document_class: Type[Mapping[str, Any]]
  228:     tz_aware: bool
  229:     uuid_representation: int
  230:     unicode_decode_error_handler: str
  231:     tzinfo: Optional[datetime.tzinfo]
  232:     type_registry: TypeRegistry
  233:     datetime_conversion: Optional[DatetimeConversion]
  234: 
  235: 
  236: if TYPE_CHECKING:
  237: 
  238:     class CodecOptions(Tuple[_DocumentType], Generic[_DocumentType]):
  239:         document_class: Type[_DocumentType]
  240:         tz_aware: bool
  241:         uuid_representation: int
  242:         unicode_decode_error_handler: Optional[str]
  243:         tzinfo: Optional[datetime.tzinfo]
  244:         type_registry: TypeRegistry
  245:         datetime_conversion: Optional[int]
  246: 
  247:         def __new__(
  248:             cls: Type[CodecOptions[_DocumentType]],
  249:             document_class: Optional[Type[_DocumentType]] = ...,
  250:             tz_aware: bool = ...,
  251:             uuid_representation: Optional[int] = ...,
  252:             unicode_decode_error_handler: Optional[str] = ...,
  253:             tzinfo: Optional[datetime.tzinfo] = ...,
  254:             type_registry: Optional[TypeRegistry] = ...,
  255:             datetime_conversion: Optional[int] = ...,
  256:         ) -> CodecOptions[_DocumentType]:
  257:             ...
  258: 
  259:         # CodecOptions API
  260:         def with_options(self, **kwargs: Any) -> CodecOptions[Any]:
  261:             ...
  262: 
  263:         def _arguments_repr(self) -> str:
  264:             ...
  265: 
  266:         def _options_dict(self) -> dict[Any, Any]:
  267:             ...
  268: 
  269:         # NamedTuple API
  270:         @classmethod
  271:         def _make(cls, obj: Iterable[Any]) -> CodecOptions[_DocumentType]:
  272:             ...
  273: 
  274:         def _asdict(self) -> dict[str, Any]:
  275:             ...
  276: 
  277:         def _replace(self, **kwargs: Any) -> CodecOptions[_DocumentType]:
  278:             ...
  279: 
  280:         _source: str
  281:         _fields: Tuple[str]
  282: 
  283: else:
  284: 
  285:     class CodecOptions(_BaseCodecOptions):
  286:         """Encapsulates options used encoding and / or decoding BSON."""
  287: 
  288:         def __init__(self, *args, **kwargs):
  289:             """Encapsulates options used encoding and / or decoding BSON.
  290: 
  291:             The `document_class` option is used to define a custom type for use
  292:             decoding BSON documents. Access to the underlying raw BSON bytes for
  293:             a document is available using the :class:`~bson.raw_bson.RawBSONDocument`
  294:             type::
  295: 
  296:               >>> from bson.raw_bson import RawBSONDocument
  297:               >>> from bson.codec_options import CodecOptions
  298:               >>> codec_options = CodecOptions(document_class=RawBSONDocument)
  299:               >>> coll = db.get_collection('test', codec_options=codec_options)
  300:               >>> doc = coll.find_one()
  301:               >>> doc.raw
  302:               '\\x16\\x00\\x00\\x00\\x07_id\\x00[0\\x165\\x91\\x10\\xea\\x14\\xe8\\xc5\\x8b\\x93\\x00'
  303: 
  304:             The document class can be any type that inherits from
  305:             :class:`~collections.abc.MutableMapping`::
  306: 
  307:               >>> class AttributeDict(dict):
  308:               ...     # A dict that supports attribute access.
  309:               ...     def __getattr__(self, key):
  310:               ...         return self[key]
  311:               ...     def __setattr__(self, key, value):
  312:               ...         self[key] = value
  313:               ...
  314:               >>> codec_options = CodecOptions(document_class=AttributeDict)
  315:               >>> coll = db.get_collection('test', codec_options=codec_options)
  316:               >>> doc = coll.find_one()
  317:               >>> doc._id
  318:               ObjectId('5b3016359110ea14e8c58b93')
  319: 
  320:             See :doc:`/examples/datetimes` for examples using the `tz_aware` and
  321:             `tzinfo` options.
  322: 
  323:             See :doc:`/examples/uuid` for examples using the `uuid_representation`
  324:             option.
  325: 
  326:             :param document_class: BSON documents returned in queries will be decoded
  327:                 to an instance of this class. Must be a subclass of
  328:                 :class:`~collections.abc.MutableMapping`. Defaults to :class:`dict`.
  329:             :param tz_aware: If ``True``, BSON datetimes will be decoded to timezone
  330:                 aware instances of :class:`~datetime.datetime`. Otherwise they will be
  331:                 naive. Defaults to ``False``.
  332:             :param uuid_representation: The BSON representation to use when encoding
  333:                 and decoding instances of :class:`~uuid.UUID`. Defaults to
  334:                 :data:`~bson.binary.UuidRepresentation.UNSPECIFIED`. New
  335:                 applications should consider setting this to
  336:                 :data:`~bson.binary.UuidRepresentation.STANDARD` for cross language
  337:                 compatibility. See :ref:`handling-uuid-data-example` for details.
  338:             :param unicode_decode_error_handler: The error handler to apply when
  339:                 a Unicode-related error occurs during BSON decoding that would
  340:                 otherwise raise :exc:`UnicodeDecodeError`. Valid options include
  341:                 'strict', 'replace', 'backslashreplace', 'surrogateescape', and
  342:                 'ignore'. Defaults to 'strict'.
  343:             :param tzinfo: A :class:`~datetime.tzinfo` subclass that specifies the
  344:                 timezone to/from which :class:`~datetime.datetime` objects should be
  345:                 encoded/decoded.
  346:             :param type_registry: Instance of :class:`TypeRegistry` used to customize
  347:                 encoding and decoding behavior.
  348:             :param datetime_conversion: Specifies how UTC datetimes should be decoded
  349:                 within BSON. Valid options include 'datetime_ms' to return as a
  350:                 DatetimeMS, 'datetime' to return as a datetime.datetime and
  351:                 raising a ValueError for out-of-range values, 'datetime_auto' to
  352:                 return DatetimeMS objects when the underlying datetime is
  353:                 out-of-range and 'datetime_clamp' to clamp to the minimum and
  354:                 maximum possible datetimes. Defaults to 'datetime'.
  355: 
  356:             .. versionchanged:: 4.0
  357:                The default for `uuid_representation` was changed from
  358:                :const:`~bson.binary.UuidRepresentation.PYTHON_LEGACY` to
  359:                :const:`~bson.binary.UuidRepresentation.UNSPECIFIED`.
  360: 
  361:             .. versionadded:: 3.8
  362:                `type_registry` attribute.
  363: 
  364:             .. warning:: Care must be taken when changing
  365:                `unicode_decode_error_handler` from its default value ('strict').
  366:                The 'replace' and 'ignore' modes should not be used when documents
  367:                retrieved from the server will be modified in the client application
  368:                and stored back to the server.
  369:             """
  370:             super().__init__()
  371: 
  372:         def __new__(
  373:             cls: Type[CodecOptions],
  374:             document_class: Optional[Type[Mapping[str, Any]]] = None,
  375:             tz_aware: bool = False,
  376:             uuid_representation: Optional[int] = UuidRepresentation.UNSPECIFIED,
  377:             unicode_decode_error_handler: str = "strict",
  378:             tzinfo: Optional[datetime.tzinfo] = None,
  379:             type_registry: Optional[TypeRegistry] = None,
  380:             datetime_conversion: Optional[DatetimeConversion] = DatetimeConversion.DATETIME,
  381:         ) -> CodecOptions:
  382:             doc_class = document_class or dict
  383:             # issubclass can raise TypeError for generic aliases like SON[str, Any].
  384:             # In that case we can use the base class for the comparison.
  385:             is_mapping = False
  386:             try:
  387:                 is_mapping = issubclass(doc_class, _MutableMapping)
  388:             except TypeError:
  389:                 if hasattr(doc_class, "__origin__"):
  390:                     is_mapping = issubclass(doc_class.__origin__, _MutableMapping)
  391:             if not (is_mapping or _raw_document_class(doc_class)):
  392:                 raise TypeError(
  393:                     "document_class must be dict, bson.son.SON, "
  394:                     "bson.raw_bson.RawBSONDocument, or a "
  395:                     "subclass of collections.abc.MutableMapping"
  396:                 )
  397:             if not isinstance(tz_aware, bool):
  398:                 raise TypeError(f"tz_aware must be True or False, was: tz_aware={tz_aware}")
  399:             if uuid_representation not in ALL_UUID_REPRESENTATIONS:
  400:                 raise ValueError(
  401:                     "uuid_representation must be a value from bson.binary.UuidRepresentation"
  402:                 )
  403:             if not isinstance(unicode_decode_error_handler, str):
  404:                 raise ValueError("unicode_decode_error_handler must be a string")
  405:             if tzinfo is not None:
  406:                 if not isinstance(tzinfo, datetime.tzinfo):
  407:                     raise TypeError("tzinfo must be an instance of datetime.tzinfo")
  408:                 if not tz_aware:
  409:                     raise ValueError("cannot specify tzinfo without also setting tz_aware=True")
  410: 
  411:             type_registry = type_registry or TypeRegistry()
  412: 
  413:             if not isinstance(type_registry, TypeRegistry):
  414:                 raise TypeError("type_registry must be an instance of TypeRegistry")
  415: 
  416:             return tuple.__new__(
  417:                 cls,
  418:                 (
  419:                     doc_class,
  420:                     tz_aware,
  421:                     uuid_representation,
  422:                     unicode_decode_error_handler,
  423:                     tzinfo,
  424:                     type_registry,
  425:                     datetime_conversion,
  426:                 ),
  427:             )
  428: 
  429:         def _arguments_repr(self) -> str:
  430:             """Representation of the arguments used to create this object."""
  431:             document_class_repr = (
  432:                 "dict" if self.document_class is dict else repr(self.document_class)
  433:             )
  434: 
  435:             uuid_rep_repr = UUID_REPRESENTATION_NAMES.get(
  436:                 self.uuid_representation, self.uuid_representation
  437:             )
  438: 
  439:             return (
  440:                 "document_class={}, tz_aware={!r}, uuid_representation={}, "
  441:                 "unicode_decode_error_handler={!r}, tzinfo={!r}, "
  442:                 "type_registry={!r}, datetime_conversion={!s}".format(
  443:                     document_class_repr,
  444:                     self.tz_aware,
  445:                     uuid_rep_repr,
  446:                     self.unicode_decode_error_handler,
  447:                     self.tzinfo,
  448:                     self.type_registry,
  449:                     self.datetime_conversion,
  450:                 )
  451:             )
  452: 
  453:         def _options_dict(self) -> dict[str, Any]:
  454:             """Dictionary of the arguments used to create this object."""
  455:             # TODO: PYTHON-2442 use _asdict() instead
  456:             return {
  457:                 "document_class": self.document_class,
  458:                 "tz_aware": self.tz_aware,
  459:                 "uuid_representation": self.uuid_representation,
  460:                 "unicode_decode_error_handler": self.unicode_decode_error_handler,
  461:                 "tzinfo": self.tzinfo,
  462:                 "type_registry": self.type_registry,
  463:                 "datetime_conversion": self.datetime_conversion,
  464:             }
  465: 
  466:         def __repr__(self) -> str:
  467:             return f"{self.__class__.__name__}({self._arguments_repr()})"
  468: 
  469:         def with_options(self, **kwargs: Any) -> CodecOptions:
  470:             """Make a copy of this CodecOptions, overriding some options::
  471: 
  472:                 >>> from bson.codec_options import DEFAULT_CODEC_OPTIONS
  473:                 >>> DEFAULT_CODEC_OPTIONS.tz_aware
  474:                 False
  475:                 >>> options = DEFAULT_CODEC_OPTIONS.with_options(tz_aware=True)
  476:                 >>> options.tz_aware
  477:                 True
  478: 
  479:             .. versionadded:: 3.5
  480:             """
  481:             opts = self._options_dict()
  482:             opts.update(kwargs)
  483:             return CodecOptions(**opts)
  484: 
  485: 
  486: DEFAULT_CODEC_OPTIONS: CodecOptions[dict[str, Any]] = CodecOptions()
  487: 
  488: 
  489: def _parse_codec_options(options: Any) -> CodecOptions[Any]:
  490:     """Parse BSON codec options."""
  491:     kwargs = {}
  492:     for k in set(options) & {
  493:         "document_class",
  494:         "tz_aware",
  495:         "uuidrepresentation",
  496:         "unicode_decode_error_handler",
  497:         "tzinfo",
  498:         "type_registry",
  499:         "datetime_conversion",
  500:     }:
  501:         if k == "uuidrepresentation":
  502:             kwargs["uuid_representation"] = options[k]
  503:         else:
  504:             kwargs[k] = options[k]
  505:     return CodecOptions(**kwargs)
