    1: # Copyright 2022-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Tools for representing the BSON datetime type.
   16: 
   17: .. versionadded:: 4.3
   18: """
   19: from __future__ import annotations
   20: 
   21: import calendar
   22: import datetime
   23: import functools
   24: from typing import Any, Union, cast
   25: 
   26: from bson.codec_options import DEFAULT_CODEC_OPTIONS, CodecOptions, DatetimeConversion
   27: from bson.errors import InvalidBSON
   28: from bson.tz_util import utc
   29: 
   30: EPOCH_AWARE = datetime.datetime.fromtimestamp(0, utc)
   31: EPOCH_NAIVE = EPOCH_AWARE.replace(tzinfo=None)
   32: _DATETIME_ERROR_SUGGESTION = (
   33:     "(Consider Using CodecOptions(datetime_conversion=DATETIME_AUTO)"
   34:     " or MongoClient(datetime_conversion='DATETIME_AUTO'))."
   35:     " See: https://pymongo.readthedocs.io/en/stable/examples/datetimes.html#handling-out-of-range-datetimes"
   36: )
   37: 
   38: 
   39: class DatetimeMS:
   40:     """Represents a BSON UTC datetime."""
   41: 
   42:     __slots__ = ("_value",)
   43: 
   44:     def __init__(self, value: Union[int, datetime.datetime]):
   45:         """Represents a BSON UTC datetime.
   46: 
   47:         BSON UTC datetimes are defined as an int64 of milliseconds since the
   48:         Unix epoch. The principal use of DatetimeMS is to represent
   49:         datetimes outside the range of the Python builtin
   50:         :class:`~datetime.datetime` class when
   51:         encoding/decoding BSON.
   52: 
   53:         To decode UTC datetimes as a ``DatetimeMS``, `datetime_conversion` in
   54:         :class:`~bson.codec_options.CodecOptions` must be set to 'datetime_ms' or
   55:         'datetime_auto'. See :ref:`handling-out-of-range-datetimes` for
   56:         details.
   57: 
   58:         :param value: An instance of :class:`datetime.datetime` to be
   59:             represented as milliseconds since the Unix epoch, or int of
   60:             milliseconds since the Unix epoch.
   61:         """
   62:         if isinstance(value, int):
   63:             if not (-(2**63) <= value <= 2**63 - 1):
   64:                 raise OverflowError("Must be a 64-bit integer of milliseconds")
   65:             self._value = value
   66:         elif isinstance(value, datetime.datetime):
   67:             self._value = _datetime_to_millis(value)
   68:         else:
   69:             raise TypeError(f"{type(value)} is not a valid type for DatetimeMS")
   70: 
   71:     def __hash__(self) -> int:
   72:         return hash(self._value)
   73: 
   74:     def __repr__(self) -> str:
   75:         return type(self).__name__ + "(" + str(self._value) + ")"
   76: 
   77:     def __lt__(self, other: Union[DatetimeMS, int]) -> bool:
   78:         return self._value < other
   79: 
   80:     def __le__(self, other: Union[DatetimeMS, int]) -> bool:
   81:         return self._value <= other
   82: 
   83:     def __eq__(self, other: Any) -> bool:
   84:         if isinstance(other, DatetimeMS):
   85:             return self._value == other._value
   86:         return False
   87: 
   88:     def __ne__(self, other: Any) -> bool:
   89:         if isinstance(other, DatetimeMS):
   90:             return self._value != other._value
   91:         return True
   92: 
   93:     def __gt__(self, other: Union[DatetimeMS, int]) -> bool:
   94:         return self._value > other
   95: 
   96:     def __ge__(self, other: Union[DatetimeMS, int]) -> bool:
   97:         return self._value >= other
   98: 
   99:     _type_marker = 9
  100: 
  101:     def as_datetime(
  102:         self, codec_options: CodecOptions[Any] = DEFAULT_CODEC_OPTIONS
  103:     ) -> datetime.datetime:
  104:         """Create a Python :class:`~datetime.datetime` from this DatetimeMS object.
  105: 
  106:         :param codec_options: A CodecOptions instance for specifying how the
  107:             resulting DatetimeMS object will be formatted using ``tz_aware``
  108:             and ``tz_info``. Defaults to
  109:             :const:`~bson.codec_options.DEFAULT_CODEC_OPTIONS`.
  110:         """
  111:         return cast(datetime.datetime, _millis_to_datetime(self._value, codec_options))
  112: 
  113:     def __int__(self) -> int:
  114:         return self._value
  115: 
  116: 
  117: # Inclusive and exclusive min and max for timezones.
  118: # Timezones are hashed by their offset, which is a timedelta
  119: # and therefore there are more than 24 possible timezones.
  120: @functools.lru_cache(maxsize=None)
  121: def _min_datetime_ms(tz: datetime.timezone = datetime.timezone.utc) -> int:
  122:     return _datetime_to_millis(datetime.datetime.min.replace(tzinfo=tz))
  123: 
  124: 
  125: @functools.lru_cache(maxsize=None)
  126: def _max_datetime_ms(tz: datetime.timezone = datetime.timezone.utc) -> int:
  127:     return _datetime_to_millis(datetime.datetime.max.replace(tzinfo=tz))
  128: 
  129: 
  130: def _millis_to_datetime(
  131:     millis: int, opts: CodecOptions[Any]
  132: ) -> Union[datetime.datetime, DatetimeMS]:
  133:     """Convert milliseconds since epoch UTC to datetime."""
  134:     if (
  135:         opts.datetime_conversion == DatetimeConversion.DATETIME
  136:         or opts.datetime_conversion == DatetimeConversion.DATETIME_CLAMP
  137:         or opts.datetime_conversion == DatetimeConversion.DATETIME_AUTO
  138:     ):
  139:         tz = opts.tzinfo or datetime.timezone.utc
  140:         if opts.datetime_conversion == DatetimeConversion.DATETIME_CLAMP:
  141:             millis = max(_min_datetime_ms(tz), min(millis, _max_datetime_ms(tz)))
  142:         elif opts.datetime_conversion == DatetimeConversion.DATETIME_AUTO:
  143:             if not (_min_datetime_ms(tz) <= millis <= _max_datetime_ms(tz)):
  144:                 return DatetimeMS(millis)
  145: 
  146:         diff = ((millis % 1000) + 1000) % 1000
  147:         seconds = (millis - diff) // 1000
  148:         micros = diff * 1000
  149: 
  150:         try:
  151:             if opts.tz_aware:
  152:                 dt = EPOCH_AWARE + datetime.timedelta(seconds=seconds, microseconds=micros)
  153:                 if opts.tzinfo:
  154:                     dt = dt.astimezone(tz)
  155:                 return dt
  156:             else:
  157:                 return EPOCH_NAIVE + datetime.timedelta(seconds=seconds, microseconds=micros)
  158:         except ArithmeticError as err:
  159:             raise InvalidBSON(f"{err} {_DATETIME_ERROR_SUGGESTION}") from err
  160: 
  161:     elif opts.datetime_conversion == DatetimeConversion.DATETIME_MS:
  162:         return DatetimeMS(millis)
  163:     else:
  164:         raise ValueError("datetime_conversion must be an element of DatetimeConversion")
  165: 
  166: 
  167: def _datetime_to_millis(dtm: datetime.datetime) -> int:
  168:     """Convert datetime to milliseconds since epoch UTC."""
  169:     if dtm.utcoffset() is not None:
  170:         dtm = dtm - dtm.utcoffset()  # type: ignore
  171:     return int(calendar.timegm(dtm.timetuple()) * 1000 + dtm.microsecond // 1000)
