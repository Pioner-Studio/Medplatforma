    1: # Copyright 2016-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Tools for working with the BSON decimal128 type.
   16: 
   17: .. versionadded:: 3.4
   18: """
   19: from __future__ import annotations
   20: 
   21: import decimal
   22: import struct
   23: from typing import Any, Sequence, Tuple, Type, Union
   24: 
   25: _PACK_64 = struct.Struct("<Q").pack
   26: _UNPACK_64 = struct.Struct("<Q").unpack
   27: 
   28: _EXPONENT_MASK = 3 << 61
   29: _EXPONENT_BIAS = 6176
   30: _EXPONENT_MAX = 6144
   31: _EXPONENT_MIN = -6143
   32: _MAX_DIGITS = 34
   33: 
   34: _INF = 0x7800000000000000
   35: _NAN = 0x7C00000000000000
   36: _SNAN = 0x7E00000000000000
   37: _SIGN = 0x8000000000000000
   38: 
   39: _NINF = (_INF + _SIGN, 0)
   40: _PINF = (_INF, 0)
   41: _NNAN = (_NAN + _SIGN, 0)
   42: _PNAN = (_NAN, 0)
   43: _NSNAN = (_SNAN + _SIGN, 0)
   44: _PSNAN = (_SNAN, 0)
   45: 
   46: _CTX_OPTIONS = {
   47:     "prec": _MAX_DIGITS,
   48:     "rounding": decimal.ROUND_HALF_EVEN,
   49:     "Emin": _EXPONENT_MIN,
   50:     "Emax": _EXPONENT_MAX,
   51:     "capitals": 1,
   52:     "flags": [],
   53:     "traps": [decimal.InvalidOperation, decimal.Overflow, decimal.Inexact],
   54:     "clamp": 1,
   55: }
   56: 
   57: _DEC128_CTX = decimal.Context(**_CTX_OPTIONS.copy())  # type: ignore
   58: _VALUE_OPTIONS = Union[decimal.Decimal, float, str, Tuple[int, Sequence[int], int]]
   59: 
   60: 
   61: def create_decimal128_context() -> decimal.Context:
   62:     """Returns an instance of :class:`decimal.Context` appropriate
   63:     for working with IEEE-754 128-bit decimal floating point values.
   64:     """
   65:     opts = _CTX_OPTIONS.copy()
   66:     opts["traps"] = []
   67:     return decimal.Context(**opts)  # type: ignore
   68: 
   69: 
   70: def _decimal_to_128(value: _VALUE_OPTIONS) -> Tuple[int, int]:
   71:     """Converts a decimal.Decimal to BID (high bits, low bits).
   72: 
   73:     :param value: An instance of decimal.Decimal
   74:     """
   75:     with decimal.localcontext(_DEC128_CTX) as ctx:
   76:         value = ctx.create_decimal(value)
   77: 
   78:     if value.is_infinite():
   79:         return _NINF if value.is_signed() else _PINF
   80: 
   81:     sign, digits, exponent = value.as_tuple()
   82: 
   83:     if value.is_nan():
   84:         if digits:
   85:             raise ValueError("NaN with debug payload is not supported")
   86:         if value.is_snan():
   87:             return _NSNAN if value.is_signed() else _PSNAN
   88:         return _NNAN if value.is_signed() else _PNAN
   89: 
   90:     significand = int("".join([str(digit) for digit in digits]))
   91:     bit_length = significand.bit_length()
   92: 
   93:     high = 0
   94:     low = 0
   95:     for i in range(min(64, bit_length)):
   96:         if significand & (1 << i):
   97:             low |= 1 << i
   98: 
   99:     for i in range(64, bit_length):
  100:         if significand & (1 << i):
  101:             high |= 1 << (i - 64)
  102: 
  103:     biased_exponent = exponent + _EXPONENT_BIAS  # type: ignore[operator]
  104: 
  105:     if high >> 49 == 1:
  106:         high = high & 0x7FFFFFFFFFFF
  107:         high |= _EXPONENT_MASK
  108:         high |= (biased_exponent & 0x3FFF) << 47
  109:     else:
  110:         high |= biased_exponent << 49
  111: 
  112:     if sign:
  113:         high |= _SIGN
  114: 
  115:     return high, low
  116: 
  117: 
  118: class Decimal128:
  119:     """BSON Decimal128 type::
  120: 
  121:       >>> Decimal128(Decimal("0.0005"))
  122:       Decimal128('0.0005')
  123:       >>> Decimal128("0.0005")
  124:       Decimal128('0.0005')
  125:       >>> Decimal128((3474527112516337664, 5))
  126:       Decimal128('0.0005')
  127: 
  128:     :param value: An instance of :class:`decimal.Decimal`, string, or tuple of
  129:         (high bits, low bits) from Binary Integer Decimal (BID) format.
  130: 
  131:     .. note:: :class:`~Decimal128` uses an instance of :class:`decimal.Context`
  132:       configured for IEEE-754 Decimal128 when validating parameters.
  133:       Signals like :class:`decimal.InvalidOperation`, :class:`decimal.Inexact`,
  134:       and :class:`decimal.Overflow` are trapped and raised as exceptions::
  135: 
  136:         >>> Decimal128(".13.1")
  137:         Traceback (most recent call last):
  138:           File "<stdin>", line 1, in <module>
  139:           ...
  140:         decimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]
  141:         >>>
  142:         >>> Decimal128("1E-6177")
  143:         Traceback (most recent call last):
  144:           File "<stdin>", line 1, in <module>
  145:           ...
  146:         decimal.Inexact: [<class 'decimal.Inexact'>]
  147:         >>>
  148:         >>> Decimal128("1E6145")
  149:         Traceback (most recent call last):
  150:           File "<stdin>", line 1, in <module>
  151:           ...
  152:         decimal.Overflow: [<class 'decimal.Overflow'>, <class 'decimal.Rounded'>]
  153: 
  154:       To ensure the result of a calculation can always be stored as BSON
  155:       Decimal128 use the context returned by
  156:       :func:`create_decimal128_context`::
  157: 
  158:         >>> import decimal
  159:         >>> decimal128_ctx = create_decimal128_context()
  160:         >>> with decimal.localcontext(decimal128_ctx) as ctx:
  161:         ...     Decimal128(ctx.create_decimal(".13.3"))
  162:         ...
  163:         Decimal128('NaN')
  164:         >>>
  165:         >>> with decimal.localcontext(decimal128_ctx) as ctx:
  166:         ...     Decimal128(ctx.create_decimal("1E-6177"))
  167:         ...
  168:         Decimal128('0E-6176')
  169:         >>>
  170:         >>> with decimal.localcontext(DECIMAL128_CTX) as ctx:
  171:         ...     Decimal128(ctx.create_decimal("1E6145"))
  172:         ...
  173:         Decimal128('Infinity')
  174: 
  175:       To match the behavior of MongoDB's Decimal128 implementation
  176:       str(Decimal(value)) may not match str(Decimal128(value)) for NaN values::
  177: 
  178:         >>> Decimal128(Decimal('NaN'))
  179:         Decimal128('NaN')
  180:         >>> Decimal128(Decimal('-NaN'))
  181:         Decimal128('NaN')
  182:         >>> Decimal128(Decimal('sNaN'))
  183:         Decimal128('NaN')
  184:         >>> Decimal128(Decimal('-sNaN'))
  185:         Decimal128('NaN')
  186: 
  187:       However, :meth:`~Decimal128.to_decimal` will return the exact value::
  188: 
  189:         >>> Decimal128(Decimal('NaN')).to_decimal()
  190:         Decimal('NaN')
  191:         >>> Decimal128(Decimal('-NaN')).to_decimal()
  192:         Decimal('-NaN')
  193:         >>> Decimal128(Decimal('sNaN')).to_decimal()
  194:         Decimal('sNaN')
  195:         >>> Decimal128(Decimal('-sNaN')).to_decimal()
  196:         Decimal('-sNaN')
  197: 
  198:       Two instances of :class:`Decimal128` compare equal if their Binary
  199:       Integer Decimal encodings are equal::
  200: 
  201:         >>> Decimal128('NaN') == Decimal128('NaN')
  202:         True
  203:         >>> Decimal128('NaN').bid == Decimal128('NaN').bid
  204:         True
  205: 
  206:       This differs from :class:`decimal.Decimal` comparisons for NaN::
  207: 
  208:         >>> Decimal('NaN') == Decimal('NaN')
  209:         False
  210:     """
  211: 
  212:     __slots__ = ("__high", "__low")
  213: 
  214:     _type_marker = 19
  215: 
  216:     def __init__(self, value: _VALUE_OPTIONS) -> None:
  217:         if isinstance(value, (str, decimal.Decimal)):
  218:             self.__high, self.__low = _decimal_to_128(value)
  219:         elif isinstance(value, (list, tuple)):
  220:             if len(value) != 2:
  221:                 raise ValueError(
  222:                     "Invalid size for creation of Decimal128 "
  223:                     "from list or tuple. Must have exactly 2 "
  224:                     "elements."
  225:                 )
  226:             self.__high, self.__low = value  # type: ignore
  227:         else:
  228:             raise TypeError(f"Cannot convert {value!r} to Decimal128")
  229: 
  230:     def to_decimal(self) -> decimal.Decimal:
  231:         """Returns an instance of :class:`decimal.Decimal` for this
  232:         :class:`Decimal128`.
  233:         """
  234:         high = self.__high
  235:         low = self.__low
  236:         sign = 1 if (high & _SIGN) else 0
  237: 
  238:         if (high & _SNAN) == _SNAN:
  239:             return decimal.Decimal((sign, (), "N"))  # type: ignore
  240:         elif (high & _NAN) == _NAN:
  241:             return decimal.Decimal((sign, (), "n"))  # type: ignore
  242:         elif (high & _INF) == _INF:
  243:             return decimal.Decimal((sign, (), "F"))  # type: ignore
  244: 
  245:         if (high & _EXPONENT_MASK) == _EXPONENT_MASK:
  246:             exponent = ((high & 0x1FFFE00000000000) >> 47) - _EXPONENT_BIAS
  247:             return decimal.Decimal((sign, (0,), exponent))
  248:         else:
  249:             exponent = ((high & 0x7FFF800000000000) >> 49) - _EXPONENT_BIAS
  250: 
  251:         arr = bytearray(15)
  252:         mask = 0x00000000000000FF
  253:         for i in range(14, 6, -1):
  254:             arr[i] = (low & mask) >> ((14 - i) << 3)
  255:             mask = mask << 8
  256: 
  257:         mask = 0x00000000000000FF
  258:         for i in range(6, 0, -1):
  259:             arr[i] = (high & mask) >> ((6 - i) << 3)
  260:             mask = mask << 8
  261: 
  262:         mask = 0x0001000000000000
  263:         arr[0] = (high & mask) >> 48
  264: 
  265:         # cdecimal only accepts a tuple for digits.
  266:         digits = tuple(int(digit) for digit in str(int.from_bytes(arr, "big")))
  267: 
  268:         with decimal.localcontext(_DEC128_CTX) as ctx:
  269:             return ctx.create_decimal((sign, digits, exponent))
  270: 
  271:     @classmethod
  272:     def from_bid(cls: Type[Decimal128], value: bytes) -> Decimal128:
  273:         """Create an instance of :class:`Decimal128` from Binary Integer
  274:         Decimal string.
  275: 
  276:         :param value: 16 byte string (128-bit IEEE 754-2008 decimal floating
  277:             point in Binary Integer Decimal (BID) format).
  278:         """
  279:         if not isinstance(value, bytes):
  280:             raise TypeError("value must be an instance of bytes")
  281:         if len(value) != 16:
  282:             raise ValueError("value must be exactly 16 bytes")
  283:         return cls((_UNPACK_64(value[8:])[0], _UNPACK_64(value[:8])[0]))  # type: ignore
  284: 
  285:     @property
  286:     def bid(self) -> bytes:
  287:         """The Binary Integer Decimal (BID) encoding of this instance."""
  288:         return _PACK_64(self.__low) + _PACK_64(self.__high)
  289: 
  290:     def __str__(self) -> str:
  291:         dec = self.to_decimal()
  292:         if dec.is_nan():
  293:             # Required by the drivers spec to match MongoDB behavior.
  294:             return "NaN"
  295:         return str(dec)
  296: 
  297:     def __repr__(self) -> str:
  298:         return f"Decimal128('{self!s}')"
  299: 
  300:     def __setstate__(self, value: Tuple[int, int]) -> None:
  301:         self.__high, self.__low = value
  302: 
  303:     def __getstate__(self) -> Tuple[int, int]:
  304:         return self.__high, self.__low
  305: 
  306:     def __eq__(self, other: Any) -> bool:
  307:         if isinstance(other, Decimal128):
  308:             return self.bid == other.bid
  309:         return NotImplemented
  310: 
  311:     def __ne__(self, other: Any) -> bool:
  312:         return not self == other
