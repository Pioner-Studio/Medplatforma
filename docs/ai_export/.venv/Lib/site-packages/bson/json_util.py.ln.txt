    1: # Copyright 2009-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Tools for using Python's :mod:`json` module with BSON documents.
   16: 
   17: This module provides two helper methods `dumps` and `loads` that wrap the
   18: native :mod:`json` methods and provide explicit BSON conversion to and from
   19: JSON. :class:`~bson.json_util.JSONOptions` provides a way to control how JSON
   20: is emitted and parsed, with the default being the Relaxed Extended JSON format.
   21: :mod:`~bson.json_util` can also generate Canonical or legacy `Extended JSON`_
   22: when :const:`CANONICAL_JSON_OPTIONS` or :const:`LEGACY_JSON_OPTIONS` is
   23: provided, respectively.
   24: 
   25: .. _Extended JSON: https://github.com/mongodb/specifications/blob/master/source/extended-json.rst
   26: 
   27: Example usage (deserialization):
   28: 
   29: .. doctest::
   30: 
   31:    >>> from bson.json_util import loads
   32:    >>> loads(
   33:    ...     '[{"foo": [1, 2]}, {"bar": {"hello": "world"}}, {"code": {"$scope": {}, "$code": "function x() { return 1; }"}}, {"bin": {"$type": "80", "$binary": "AQIDBA=="}}]'
   34:    ... )
   35:    [{'foo': [1, 2]}, {'bar': {'hello': 'world'}}, {'code': Code('function x() { return 1; }', {})}, {'bin': Binary(b'...', 128)}]
   36: 
   37: Example usage with :const:`RELAXED_JSON_OPTIONS` (the default):
   38: 
   39: .. doctest::
   40: 
   41:    >>> from bson import Binary, Code
   42:    >>> from bson.json_util import dumps
   43:    >>> dumps(
   44:    ...     [
   45:    ...         {"foo": [1, 2]},
   46:    ...         {"bar": {"hello": "world"}},
   47:    ...         {"code": Code("function x() { return 1; }")},
   48:    ...         {"bin": Binary(b"\x01\x02\x03\x04")},
   49:    ...     ]
   50:    ... )
   51:    '[{"foo": [1, 2]}, {"bar": {"hello": "world"}}, {"code": {"$code": "function x() { return 1; }"}}, {"bin": {"$binary": {"base64": "AQIDBA==", "subType": "00"}}}]'
   52: 
   53: Example usage (with :const:`CANONICAL_JSON_OPTIONS`):
   54: 
   55: .. doctest::
   56: 
   57:    >>> from bson import Binary, Code
   58:    >>> from bson.json_util import dumps, CANONICAL_JSON_OPTIONS
   59:    >>> dumps(
   60:    ...     [
   61:    ...         {"foo": [1, 2]},
   62:    ...         {"bar": {"hello": "world"}},
   63:    ...         {"code": Code("function x() { return 1; }")},
   64:    ...         {"bin": Binary(b"\x01\x02\x03\x04")},
   65:    ...     ],
   66:    ...     json_options=CANONICAL_JSON_OPTIONS,
   67:    ... )
   68:    '[{"foo": [{"$numberInt": "1"}, {"$numberInt": "2"}]}, {"bar": {"hello": "world"}}, {"code": {"$code": "function x() { return 1; }"}}, {"bin": {"$binary": {"base64": "AQIDBA==", "subType": "00"}}}]'
   69: 
   70: Example usage (with :const:`LEGACY_JSON_OPTIONS`):
   71: 
   72: .. doctest::
   73: 
   74:    >>> from bson import Binary, Code
   75:    >>> from bson.json_util import dumps, LEGACY_JSON_OPTIONS
   76:    >>> dumps(
   77:    ...     [
   78:    ...         {"foo": [1, 2]},
   79:    ...         {"bar": {"hello": "world"}},
   80:    ...         {"code": Code("function x() { return 1; }", {})},
   81:    ...         {"bin": Binary(b"\x01\x02\x03\x04")},
   82:    ...     ],
   83:    ...     json_options=LEGACY_JSON_OPTIONS,
   84:    ... )
   85:    '[{"foo": [1, 2]}, {"bar": {"hello": "world"}}, {"code": {"$code": "function x() { return 1; }", "$scope": {}}}, {"bin": {"$binary": "AQIDBA==", "$type": "00"}}]'
   86: 
   87: Alternatively, you can manually pass the `default` to :func:`json.dumps`.
   88: It won't handle :class:`~bson.binary.Binary` and :class:`~bson.code.Code`
   89: instances (as they are extended strings you can't provide custom defaults),
   90: but it will be faster as there is less recursion.
   91: 
   92: .. note::
   93:    If your application does not need the flexibility offered by
   94:    :class:`JSONOptions` and spends a large amount of time in the `json_util`
   95:    module, look to
   96:    `python-bsonjs <https://pypi.python.org/pypi/python-bsonjs>`_ for a nice
   97:    performance improvement. `python-bsonjs` is a fast BSON to MongoDB
   98:    Extended JSON converter for Python built on top of
   99:    `libbson <https://github.com/mongodb/libbson>`_. `python-bsonjs` works best
  100:    with PyMongo when using :class:`~bson.raw_bson.RawBSONDocument`.
  101: """
  102: from __future__ import annotations
  103: 
  104: import base64
  105: import datetime
  106: import json
  107: import math
  108: import re
  109: import uuid
  110: from typing import (
  111:     TYPE_CHECKING,
  112:     Any,
  113:     Callable,
  114:     Mapping,
  115:     MutableMapping,
  116:     Optional,
  117:     Sequence,
  118:     Tuple,
  119:     Type,
  120:     Union,
  121:     cast,
  122: )
  123: 
  124: from bson.binary import ALL_UUID_SUBTYPES, UUID_SUBTYPE, Binary, UuidRepresentation
  125: from bson.code import Code
  126: from bson.codec_options import CodecOptions, DatetimeConversion
  127: from bson.datetime_ms import (
  128:     EPOCH_AWARE,
  129:     DatetimeMS,
  130:     _datetime_to_millis,
  131:     _max_datetime_ms,
  132:     _millis_to_datetime,
  133: )
  134: from bson.dbref import DBRef
  135: from bson.decimal128 import Decimal128
  136: from bson.int64 import Int64
  137: from bson.max_key import MaxKey
  138: from bson.min_key import MinKey
  139: from bson.objectid import ObjectId
  140: from bson.regex import Regex
  141: from bson.son import RE_TYPE
  142: from bson.timestamp import Timestamp
  143: from bson.tz_util import utc
  144: 
  145: _RE_OPT_TABLE = {
  146:     "i": re.I,
  147:     "l": re.L,
  148:     "m": re.M,
  149:     "s": re.S,
  150:     "u": re.U,
  151:     "x": re.X,
  152: }
  153: 
  154: 
  155: class DatetimeRepresentation:
  156:     LEGACY = 0
  157:     """Legacy MongoDB Extended JSON datetime representation.
  158: 
  159:     :class:`datetime.datetime` instances will be encoded to JSON in the
  160:     format `{"$date": <dateAsMilliseconds>}`, where `dateAsMilliseconds` is
  161:     a 64-bit signed integer giving the number of milliseconds since the Unix
  162:     epoch UTC. This was the default encoding before PyMongo version 3.4.
  163: 
  164:     .. versionadded:: 3.4
  165:     """
  166: 
  167:     NUMBERLONG = 1
  168:     """NumberLong datetime representation.
  169: 
  170:     :class:`datetime.datetime` instances will be encoded to JSON in the
  171:     format `{"$date": {"$numberLong": "<dateAsMilliseconds>"}}`,
  172:     where `dateAsMilliseconds` is the string representation of a 64-bit signed
  173:     integer giving the number of milliseconds since the Unix epoch UTC.
  174: 
  175:     .. versionadded:: 3.4
  176:     """
  177: 
  178:     ISO8601 = 2
  179:     """ISO-8601 datetime representation.
  180: 
  181:     :class:`datetime.datetime` instances greater than or equal to the Unix
  182:     epoch UTC will be encoded to JSON in the format `{"$date": "<ISO-8601>"}`.
  183:     :class:`datetime.datetime` instances before the Unix epoch UTC will be
  184:     encoded as if the datetime representation is
  185:     :const:`~DatetimeRepresentation.NUMBERLONG`.
  186: 
  187:     .. versionadded:: 3.4
  188:     """
  189: 
  190: 
  191: class JSONMode:
  192:     LEGACY = 0
  193:     """Legacy Extended JSON representation.
  194: 
  195:     In this mode, :func:`~bson.json_util.dumps` produces PyMongo's legacy
  196:     non-standard JSON output. Consider using
  197:     :const:`~bson.json_util.JSONMode.RELAXED` or
  198:     :const:`~bson.json_util.JSONMode.CANONICAL` instead.
  199: 
  200:     .. versionadded:: 3.5
  201:     """
  202: 
  203:     RELAXED = 1
  204:     """Relaxed Extended JSON representation.
  205: 
  206:     In this mode, :func:`~bson.json_util.dumps` produces Relaxed Extended JSON,
  207:     a mostly JSON-like format. Consider using this for things like a web API,
  208:     where one is sending a document (or a projection of a document) that only
  209:     uses ordinary JSON type primitives. In particular, the ``int``,
  210:     :class:`~bson.int64.Int64`, and ``float`` numeric types are represented in
  211:     the native JSON number format. This output is also the most human readable
  212:     and is useful for debugging and documentation.
  213: 
  214:     .. seealso:: The specification for Relaxed `Extended JSON`_.
  215: 
  216:     .. versionadded:: 3.5
  217:     """
  218: 
  219:     CANONICAL = 2
  220:     """Canonical Extended JSON representation.
  221: 
  222:     In this mode, :func:`~bson.json_util.dumps` produces Canonical Extended
  223:     JSON, a type preserving format. Consider using this for things like
  224:     testing, where one has to precisely specify expected types in JSON. In
  225:     particular, the ``int``, :class:`~bson.int64.Int64`, and ``float`` numeric
  226:     types are encoded with type wrappers.
  227: 
  228:     .. seealso:: The specification for Canonical `Extended JSON`_.
  229: 
  230:     .. versionadded:: 3.5
  231:     """
  232: 
  233: 
  234: if TYPE_CHECKING:
  235:     _BASE_CLASS = CodecOptions[MutableMapping[str, Any]]
  236: else:
  237:     _BASE_CLASS = CodecOptions
  238: 
  239: _INT32_MAX = 2**31
  240: 
  241: 
  242: class JSONOptions(_BASE_CLASS):
  243:     json_mode: int
  244:     strict_number_long: bool
  245:     datetime_representation: int
  246:     strict_uuid: bool
  247:     document_class: Type[MutableMapping[str, Any]]
  248: 
  249:     def __init__(self, *args: Any, **kwargs: Any):
  250:         """Encapsulates JSON options for :func:`dumps` and :func:`loads`.
  251: 
  252:         :param strict_number_long: If ``True``, :class:`~bson.int64.Int64` objects
  253:             are encoded to MongoDB Extended JSON's *Strict mode* type
  254:             `NumberLong`, ie ``'{"$numberLong": "<number>" }'``. Otherwise they
  255:             will be encoded as an `int`. Defaults to ``False``.
  256:         :param datetime_representation: The representation to use when encoding
  257:             instances of :class:`datetime.datetime`. Defaults to
  258:             :const:`~DatetimeRepresentation.LEGACY`.
  259:         :param strict_uuid: If ``True``, :class:`uuid.UUID` object are encoded to
  260:             MongoDB Extended JSON's *Strict mode* type `Binary`. Otherwise it
  261:             will be encoded as ``'{"$uuid": "<hex>" }'``. Defaults to ``False``.
  262:         :param json_mode: The :class:`JSONMode` to use when encoding BSON types to
  263:             Extended JSON. Defaults to :const:`~JSONMode.LEGACY`.
  264:         :param document_class: BSON documents returned by :func:`loads` will be
  265:             decoded to an instance of this class. Must be a subclass of
  266:             :class:`collections.MutableMapping`. Defaults to :class:`dict`.
  267:         :param uuid_representation: The :class:`~bson.binary.UuidRepresentation`
  268:             to use when encoding and decoding instances of :class:`uuid.UUID`.
  269:             Defaults to :const:`~bson.binary.UuidRepresentation.UNSPECIFIED`.
  270:         :param tz_aware: If ``True``, MongoDB Extended JSON's *Strict mode* type
  271:             `Date` will be decoded to timezone aware instances of
  272:             :class:`datetime.datetime`. Otherwise they will be naive. Defaults
  273:             to ``False``.
  274:         :param tzinfo: A :class:`datetime.tzinfo` subclass that specifies the
  275:             timezone from which :class:`~datetime.datetime` objects should be
  276:             decoded. Defaults to :const:`~bson.tz_util.utc`.
  277:         :param datetime_conversion: Specifies how UTC datetimes should be decoded
  278:             within BSON. Valid options include 'datetime_ms' to return as a
  279:             DatetimeMS, 'datetime' to return as a datetime.datetime and
  280:             raising a ValueError for out-of-range values, 'datetime_auto' to
  281:             return DatetimeMS objects when the underlying datetime is
  282:             out-of-range and 'datetime_clamp' to clamp to the minimum and
  283:             maximum possible datetimes. Defaults to 'datetime'. See
  284:             :ref:`handling-out-of-range-datetimes` for details.
  285:         :param args: arguments to :class:`~bson.codec_options.CodecOptions`
  286:         :param kwargs: arguments to :class:`~bson.codec_options.CodecOptions`
  287: 
  288:         .. seealso:: The specification for Relaxed and Canonical `Extended JSON`_.
  289: 
  290:         .. versionchanged:: 4.0
  291:            The default for `json_mode` was changed from :const:`JSONMode.LEGACY`
  292:            to :const:`JSONMode.RELAXED`.
  293:            The default for `uuid_representation` was changed from
  294:            :const:`~bson.binary.UuidRepresentation.PYTHON_LEGACY` to
  295:            :const:`~bson.binary.UuidRepresentation.UNSPECIFIED`.
  296: 
  297:         .. versionchanged:: 3.5
  298:            Accepts the optional parameter `json_mode`.
  299: 
  300:         .. versionchanged:: 4.0
  301:            Changed default value of `tz_aware` to False.
  302:         """
  303:         super().__init__()
  304: 
  305:     def __new__(
  306:         cls: Type[JSONOptions],
  307:         strict_number_long: Optional[bool] = None,
  308:         datetime_representation: Optional[int] = None,
  309:         strict_uuid: Optional[bool] = None,
  310:         json_mode: int = JSONMode.RELAXED,
  311:         *args: Any,
  312:         **kwargs: Any,
  313:     ) -> JSONOptions:
  314:         kwargs["tz_aware"] = kwargs.get("tz_aware", False)
  315:         if kwargs["tz_aware"]:
  316:             kwargs["tzinfo"] = kwargs.get("tzinfo", utc)
  317:         if datetime_representation not in (
  318:             DatetimeRepresentation.LEGACY,
  319:             DatetimeRepresentation.NUMBERLONG,
  320:             DatetimeRepresentation.ISO8601,
  321:             None,
  322:         ):
  323:             raise ValueError(
  324:                 "JSONOptions.datetime_representation must be one of LEGACY, "
  325:                 "NUMBERLONG, or ISO8601 from DatetimeRepresentation."
  326:             )
  327:         self = cast(JSONOptions, super().__new__(cls, *args, **kwargs))  # type:ignore[arg-type]
  328:         if json_mode not in (JSONMode.LEGACY, JSONMode.RELAXED, JSONMode.CANONICAL):
  329:             raise ValueError(
  330:                 "JSONOptions.json_mode must be one of LEGACY, RELAXED, "
  331:                 "or CANONICAL from JSONMode."
  332:             )
  333:         self.json_mode = json_mode
  334:         if self.json_mode == JSONMode.RELAXED:
  335:             if strict_number_long:
  336:                 raise ValueError("Cannot specify strict_number_long=True with JSONMode.RELAXED")
  337:             if datetime_representation not in (None, DatetimeRepresentation.ISO8601):
  338:                 raise ValueError(
  339:                     "datetime_representation must be DatetimeRepresentation."
  340:                     "ISO8601 or omitted with JSONMode.RELAXED"
  341:                 )
  342:             if strict_uuid not in (None, True):
  343:                 raise ValueError("Cannot specify strict_uuid=False with JSONMode.RELAXED")
  344:             self.strict_number_long = False
  345:             self.datetime_representation = DatetimeRepresentation.ISO8601
  346:             self.strict_uuid = True
  347:         elif self.json_mode == JSONMode.CANONICAL:
  348:             if strict_number_long not in (None, True):
  349:                 raise ValueError("Cannot specify strict_number_long=False with JSONMode.RELAXED")
  350:             if datetime_representation not in (None, DatetimeRepresentation.NUMBERLONG):
  351:                 raise ValueError(
  352:                     "datetime_representation must be DatetimeRepresentation."
  353:                     "NUMBERLONG or omitted with JSONMode.RELAXED"
  354:                 )
  355:             if strict_uuid not in (None, True):
  356:                 raise ValueError("Cannot specify strict_uuid=False with JSONMode.RELAXED")
  357:             self.strict_number_long = True
  358:             self.datetime_representation = DatetimeRepresentation.NUMBERLONG
  359:             self.strict_uuid = True
  360:         else:  # JSONMode.LEGACY
  361:             self.strict_number_long = False
  362:             self.datetime_representation = DatetimeRepresentation.LEGACY
  363:             self.strict_uuid = False
  364:             if strict_number_long is not None:
  365:                 self.strict_number_long = strict_number_long
  366:             if datetime_representation is not None:
  367:                 self.datetime_representation = datetime_representation
  368:             if strict_uuid is not None:
  369:                 self.strict_uuid = strict_uuid
  370:         return self
  371: 
  372:     def _arguments_repr(self) -> str:
  373:         return (
  374:             "strict_number_long={!r}, "
  375:             "datetime_representation={!r}, "
  376:             "strict_uuid={!r}, json_mode={!r}, {}".format(
  377:                 self.strict_number_long,
  378:                 self.datetime_representation,
  379:                 self.strict_uuid,
  380:                 self.json_mode,
  381:                 super()._arguments_repr(),
  382:             )
  383:         )
  384: 
  385:     def _options_dict(self) -> dict[Any, Any]:
  386:         # TODO: PYTHON-2442 use _asdict() instead
  387:         options_dict = super()._options_dict()
  388:         options_dict.update(
  389:             {
  390:                 "strict_number_long": self.strict_number_long,
  391:                 "datetime_representation": self.datetime_representation,
  392:                 "strict_uuid": self.strict_uuid,
  393:                 "json_mode": self.json_mode,
  394:             }
  395:         )
  396:         return options_dict
  397: 
  398:     def with_options(self, **kwargs: Any) -> JSONOptions:
  399:         """
  400:         Make a copy of this JSONOptions, overriding some options::
  401: 
  402:             >>> from bson.json_util import CANONICAL_JSON_OPTIONS
  403:             >>> CANONICAL_JSON_OPTIONS.tz_aware
  404:             True
  405:             >>> json_options = CANONICAL_JSON_OPTIONS.with_options(tz_aware=False, tzinfo=None)
  406:             >>> json_options.tz_aware
  407:             False
  408: 
  409:         .. versionadded:: 3.12
  410:         """
  411:         opts = self._options_dict()
  412:         for opt in ("strict_number_long", "datetime_representation", "strict_uuid", "json_mode"):
  413:             opts[opt] = kwargs.get(opt, getattr(self, opt))
  414:         opts.update(kwargs)
  415:         return JSONOptions(**opts)
  416: 
  417: 
  418: LEGACY_JSON_OPTIONS: JSONOptions = JSONOptions(json_mode=JSONMode.LEGACY)
  419: """:class:`JSONOptions` for encoding to PyMongo's legacy JSON format.
  420: 
  421: .. seealso:: The documentation for :const:`bson.json_util.JSONMode.LEGACY`.
  422: 
  423: .. versionadded:: 3.5
  424: """
  425: 
  426: CANONICAL_JSON_OPTIONS: JSONOptions = JSONOptions(json_mode=JSONMode.CANONICAL)
  427: """:class:`JSONOptions` for Canonical Extended JSON.
  428: 
  429: .. seealso:: The documentation for :const:`bson.json_util.JSONMode.CANONICAL`.
  430: 
  431: .. versionadded:: 3.5
  432: """
  433: 
  434: RELAXED_JSON_OPTIONS: JSONOptions = JSONOptions(json_mode=JSONMode.RELAXED)
  435: """:class:`JSONOptions` for Relaxed Extended JSON.
  436: 
  437: .. seealso:: The documentation for :const:`bson.json_util.JSONMode.RELAXED`.
  438: 
  439: .. versionadded:: 3.5
  440: """
  441: 
  442: DEFAULT_JSON_OPTIONS: JSONOptions = RELAXED_JSON_OPTIONS
  443: """The default :class:`JSONOptions` for JSON encoding/decoding.
  444: 
  445: The same as :const:`RELAXED_JSON_OPTIONS`.
  446: 
  447: .. versionchanged:: 4.0
  448:    Changed from :const:`LEGACY_JSON_OPTIONS` to
  449:    :const:`RELAXED_JSON_OPTIONS`.
  450: 
  451: .. versionadded:: 3.4
  452: """
  453: 
  454: 
  455: def dumps(obj: Any, *args: Any, **kwargs: Any) -> str:
  456:     """Helper function that wraps :func:`json.dumps`.
  457: 
  458:     Recursive function that handles all BSON types including
  459:     :class:`~bson.binary.Binary` and :class:`~bson.code.Code`.
  460: 
  461:     :param json_options: A :class:`JSONOptions` instance used to modify the
  462:         encoding of MongoDB Extended JSON types. Defaults to
  463:         :const:`DEFAULT_JSON_OPTIONS`.
  464: 
  465:     .. versionchanged:: 4.0
  466:        Now outputs MongoDB Relaxed Extended JSON by default (using
  467:        :const:`DEFAULT_JSON_OPTIONS`).
  468: 
  469:     .. versionchanged:: 3.4
  470:        Accepts optional parameter `json_options`. See :class:`JSONOptions`.
  471:     """
  472:     json_options = kwargs.pop("json_options", DEFAULT_JSON_OPTIONS)
  473:     return json.dumps(_json_convert(obj, json_options), *args, **kwargs)
  474: 
  475: 
  476: def loads(s: Union[str, bytes, bytearray], *args: Any, **kwargs: Any) -> Any:
  477:     """Helper function that wraps :func:`json.loads`.
  478: 
  479:     Automatically passes the object_hook for BSON type conversion.
  480: 
  481:     Raises ``TypeError``, ``ValueError``, ``KeyError``, or
  482:     :exc:`~bson.errors.InvalidId` on invalid MongoDB Extended JSON.
  483: 
  484:     :param json_options: A :class:`JSONOptions` instance used to modify the
  485:         decoding of MongoDB Extended JSON types. Defaults to
  486:         :const:`DEFAULT_JSON_OPTIONS`.
  487: 
  488:     .. versionchanged:: 4.0
  489:        Now loads :class:`datetime.datetime` instances as naive by default. To
  490:        load timezone aware instances utilize the `json_options` parameter.
  491:        See :ref:`tz_aware_default_change` for an example.
  492: 
  493:     .. versionchanged:: 3.5
  494:        Parses Relaxed and Canonical Extended JSON as well as PyMongo's legacy
  495:        format. Now raises ``TypeError`` or ``ValueError`` when parsing JSON
  496:        type wrappers with values of the wrong type or any extra keys.
  497: 
  498:     .. versionchanged:: 3.4
  499:        Accepts optional parameter `json_options`. See :class:`JSONOptions`.
  500:     """
  501:     json_options = kwargs.pop("json_options", DEFAULT_JSON_OPTIONS)
  502:     # Execution time optimization if json_options.document_class is dict
  503:     if json_options.document_class is dict:
  504:         kwargs["object_hook"] = lambda obj: object_hook(obj, json_options)
  505:     else:
  506:         kwargs["object_pairs_hook"] = lambda pairs: object_pairs_hook(pairs, json_options)
  507:     return json.loads(s, *args, **kwargs)
  508: 
  509: 
  510: def _json_convert(obj: Any, json_options: JSONOptions = DEFAULT_JSON_OPTIONS) -> Any:
  511:     """Recursive helper method that converts BSON types so they can be
  512:     converted into json.
  513:     """
  514:     if hasattr(obj, "items"):
  515:         return {k: _json_convert(v, json_options) for k, v in obj.items()}
  516:     elif hasattr(obj, "__iter__") and not isinstance(obj, (str, bytes)):
  517:         return [_json_convert(v, json_options) for v in obj]
  518:     try:
  519:         return default(obj, json_options)
  520:     except TypeError:
  521:         return obj
  522: 
  523: 
  524: def object_pairs_hook(
  525:     pairs: Sequence[Tuple[str, Any]], json_options: JSONOptions = DEFAULT_JSON_OPTIONS
  526: ) -> Any:
  527:     return object_hook(json_options.document_class(pairs), json_options)  # type:ignore[call-arg]
  528: 
  529: 
  530: def object_hook(dct: Mapping[str, Any], json_options: JSONOptions = DEFAULT_JSON_OPTIONS) -> Any:
  531:     match = None
  532:     for k in dct:
  533:         if k in _PARSERS_SET:
  534:             match = k
  535:             break
  536:     if match:
  537:         return _PARSERS[match](dct, json_options)
  538:     return dct
  539: 
  540: 
  541: def _parse_legacy_regex(doc: Any, dummy0: Any) -> Any:
  542:     pattern = doc["$regex"]
  543:     # Check if this is the $regex query operator.
  544:     if not isinstance(pattern, (str, bytes)):
  545:         return doc
  546:     flags = 0
  547:     # PyMongo always adds $options but some other tools may not.
  548:     for opt in doc.get("$options", ""):
  549:         flags |= _RE_OPT_TABLE.get(opt, 0)
  550:     return Regex(pattern, flags)
  551: 
  552: 
  553: def _parse_legacy_uuid(doc: Any, json_options: JSONOptions) -> Union[Binary, uuid.UUID]:
  554:     """Decode a JSON legacy $uuid to Python UUID."""
  555:     if len(doc) != 1:
  556:         raise TypeError(f"Bad $uuid, extra field(s): {doc}")
  557:     if not isinstance(doc["$uuid"], str):
  558:         raise TypeError(f"$uuid must be a string: {doc}")
  559:     if json_options.uuid_representation == UuidRepresentation.UNSPECIFIED:
  560:         return Binary.from_uuid(uuid.UUID(doc["$uuid"]))
  561:     else:
  562:         return uuid.UUID(doc["$uuid"])
  563: 
  564: 
  565: def _binary_or_uuid(data: Any, subtype: int, json_options: JSONOptions) -> Union[Binary, uuid.UUID]:
  566:     # special handling for UUID
  567:     if subtype in ALL_UUID_SUBTYPES:
  568:         uuid_representation = json_options.uuid_representation
  569:         binary_value = Binary(data, subtype)
  570:         if uuid_representation == UuidRepresentation.UNSPECIFIED:
  571:             return binary_value
  572:         if subtype == UUID_SUBTYPE:
  573:             # Legacy behavior: use STANDARD with binary subtype 4.
  574:             uuid_representation = UuidRepresentation.STANDARD
  575:         elif uuid_representation == UuidRepresentation.STANDARD:
  576:             # subtype == OLD_UUID_SUBTYPE
  577:             # Legacy behavior: STANDARD is the same as PYTHON_LEGACY.
  578:             uuid_representation = UuidRepresentation.PYTHON_LEGACY
  579:         return binary_value.as_uuid(uuid_representation)
  580: 
  581:     if subtype == 0:
  582:         return cast(uuid.UUID, data)
  583:     return Binary(data, subtype)
  584: 
  585: 
  586: def _parse_legacy_binary(doc: Any, json_options: JSONOptions) -> Union[Binary, uuid.UUID]:
  587:     if isinstance(doc["$type"], int):
  588:         doc["$type"] = "%02x" % doc["$type"]
  589:     subtype = int(doc["$type"], 16)
  590:     if subtype >= 0xFFFFFF80:  # Handle mongoexport values
  591:         subtype = int(doc["$type"][6:], 16)
  592:     data = base64.b64decode(doc["$binary"].encode())
  593:     return _binary_or_uuid(data, subtype, json_options)
  594: 
  595: 
  596: def _parse_canonical_binary(doc: Any, json_options: JSONOptions) -> Union[Binary, uuid.UUID]:
  597:     binary = doc["$binary"]
  598:     b64 = binary["base64"]
  599:     subtype = binary["subType"]
  600:     if not isinstance(b64, str):
  601:         raise TypeError(f"$binary base64 must be a string: {doc}")
  602:     if not isinstance(subtype, str) or len(subtype) > 2:
  603:         raise TypeError(f"$binary subType must be a string at most 2 characters: {doc}")
  604:     if len(binary) != 2:
  605:         raise TypeError(f'$binary must include only "base64" and "subType" components: {doc}')
  606: 
  607:     data = base64.b64decode(b64.encode())
  608:     return _binary_or_uuid(data, int(subtype, 16), json_options)
  609: 
  610: 
  611: def _parse_canonical_datetime(
  612:     doc: Any, json_options: JSONOptions
  613: ) -> Union[datetime.datetime, DatetimeMS]:
  614:     """Decode a JSON datetime to python datetime.datetime."""
  615:     dtm = doc["$date"]
  616:     if len(doc) != 1:
  617:         raise TypeError(f"Bad $date, extra field(s): {doc}")
  618:     # mongoexport 2.6 and newer
  619:     if isinstance(dtm, str):
  620:         # Parse offset
  621:         if dtm[-1] == "Z":
  622:             dt = dtm[:-1]
  623:             offset = "Z"
  624:         elif dtm[-6] in ("+", "-") and dtm[-3] == ":":
  625:             # (+|-)HH:MM
  626:             dt = dtm[:-6]
  627:             offset = dtm[-6:]
  628:         elif dtm[-5] in ("+", "-"):
  629:             # (+|-)HHMM
  630:             dt = dtm[:-5]
  631:             offset = dtm[-5:]
  632:         elif dtm[-3] in ("+", "-"):
  633:             # (+|-)HH
  634:             dt = dtm[:-3]
  635:             offset = dtm[-3:]
  636:         else:
  637:             dt = dtm
  638:             offset = ""
  639: 
  640:         # Parse the optional factional seconds portion.
  641:         dot_index = dt.rfind(".")
  642:         microsecond = 0
  643:         if dot_index != -1:
  644:             microsecond = int(float(dt[dot_index:]) * 1000000)
  645:             dt = dt[:dot_index]
  646: 
  647:         aware = datetime.datetime.strptime(dt, "%Y-%m-%dT%H:%M:%S").replace(
  648:             microsecond=microsecond, tzinfo=utc
  649:         )
  650: 
  651:         if offset and offset != "Z":
  652:             if len(offset) == 6:
  653:                 hours, minutes = offset[1:].split(":")
  654:                 secs = int(hours) * 3600 + int(minutes) * 60
  655:             elif len(offset) == 5:
  656:                 secs = int(offset[1:3]) * 3600 + int(offset[3:]) * 60
  657:             elif len(offset) == 3:
  658:                 secs = int(offset[1:3]) * 3600
  659:             if offset[0] == "-":
  660:                 secs *= -1
  661:             aware = aware - datetime.timedelta(seconds=secs)
  662: 
  663:         if json_options.tz_aware:
  664:             if json_options.tzinfo:
  665:                 aware = aware.astimezone(json_options.tzinfo)
  666:             if json_options.datetime_conversion == DatetimeConversion.DATETIME_MS:
  667:                 return DatetimeMS(aware)
  668:             return aware
  669:         else:
  670:             aware_tzinfo_none = aware.replace(tzinfo=None)
  671:             if json_options.datetime_conversion == DatetimeConversion.DATETIME_MS:
  672:                 return DatetimeMS(aware_tzinfo_none)
  673:             return aware_tzinfo_none
  674:     return _millis_to_datetime(int(dtm), cast("CodecOptions[Any]", json_options))
  675: 
  676: 
  677: def _parse_canonical_oid(doc: Any, dummy0: Any) -> ObjectId:
  678:     """Decode a JSON ObjectId to bson.objectid.ObjectId."""
  679:     if len(doc) != 1:
  680:         raise TypeError(f"Bad $oid, extra field(s): {doc}")
  681:     return ObjectId(doc["$oid"])
  682: 
  683: 
  684: def _parse_canonical_symbol(doc: Any, dummy0: Any) -> str:
  685:     """Decode a JSON symbol to Python string."""
  686:     symbol = doc["$symbol"]
  687:     if len(doc) != 1:
  688:         raise TypeError(f"Bad $symbol, extra field(s): {doc}")
  689:     return str(symbol)
  690: 
  691: 
  692: def _parse_canonical_code(doc: Any, dummy0: Any) -> Code:
  693:     """Decode a JSON code to bson.code.Code."""
  694:     for key in doc:
  695:         if key not in ("$code", "$scope"):
  696:             raise TypeError(f"Bad $code, extra field(s): {doc}")
  697:     return Code(doc["$code"], scope=doc.get("$scope"))
  698: 
  699: 
  700: def _parse_canonical_regex(doc: Any, dummy0: Any) -> Regex[str]:
  701:     """Decode a JSON regex to bson.regex.Regex."""
  702:     regex = doc["$regularExpression"]
  703:     if len(doc) != 1:
  704:         raise TypeError(f"Bad $regularExpression, extra field(s): {doc}")
  705:     if len(regex) != 2:
  706:         raise TypeError(
  707:             f'Bad $regularExpression must include only "pattern and "options" components: {doc}'
  708:         )
  709:     opts = regex["options"]
  710:     if not isinstance(opts, str):
  711:         raise TypeError(
  712:             "Bad $regularExpression options, options must be string, was type %s" % (type(opts))
  713:         )
  714:     return Regex(regex["pattern"], opts)
  715: 
  716: 
  717: def _parse_canonical_dbref(doc: Any, dummy0: Any) -> Any:
  718:     """Decode a JSON DBRef to bson.dbref.DBRef."""
  719:     if (
  720:         isinstance(doc.get("$ref"), str)
  721:         and "$id" in doc
  722:         and isinstance(doc.get("$db"), (str, type(None)))
  723:     ):
  724:         return DBRef(doc.pop("$ref"), doc.pop("$id"), database=doc.pop("$db", None), **doc)
  725:     return doc
  726: 
  727: 
  728: def _parse_canonical_dbpointer(doc: Any, dummy0: Any) -> Any:
  729:     """Decode a JSON (deprecated) DBPointer to bson.dbref.DBRef."""
  730:     dbref = doc["$dbPointer"]
  731:     if len(doc) != 1:
  732:         raise TypeError(f"Bad $dbPointer, extra field(s): {doc}")
  733:     if isinstance(dbref, DBRef):
  734:         dbref_doc = dbref.as_doc()
  735:         # DBPointer must not contain $db in its value.
  736:         if dbref.database is not None:
  737:             raise TypeError(f"Bad $dbPointer, extra field $db: {dbref_doc}")
  738:         if not isinstance(dbref.id, ObjectId):
  739:             raise TypeError(f"Bad $dbPointer, $id must be an ObjectId: {dbref_doc}")
  740:         if len(dbref_doc) != 2:
  741:             raise TypeError(f"Bad $dbPointer, extra field(s) in DBRef: {dbref_doc}")
  742:         return dbref
  743:     else:
  744:         raise TypeError(f"Bad $dbPointer, expected a DBRef: {doc}")
  745: 
  746: 
  747: def _parse_canonical_int32(doc: Any, dummy0: Any) -> int:
  748:     """Decode a JSON int32 to python int."""
  749:     i_str = doc["$numberInt"]
  750:     if len(doc) != 1:
  751:         raise TypeError(f"Bad $numberInt, extra field(s): {doc}")
  752:     if not isinstance(i_str, str):
  753:         raise TypeError(f"$numberInt must be string: {doc}")
  754:     return int(i_str)
  755: 
  756: 
  757: def _parse_canonical_int64(doc: Any, dummy0: Any) -> Int64:
  758:     """Decode a JSON int64 to bson.int64.Int64."""
  759:     l_str = doc["$numberLong"]
  760:     if len(doc) != 1:
  761:         raise TypeError(f"Bad $numberLong, extra field(s): {doc}")
  762:     return Int64(l_str)
  763: 
  764: 
  765: def _parse_canonical_double(doc: Any, dummy0: Any) -> float:
  766:     """Decode a JSON double to python float."""
  767:     d_str = doc["$numberDouble"]
  768:     if len(doc) != 1:
  769:         raise TypeError(f"Bad $numberDouble, extra field(s): {doc}")
  770:     if not isinstance(d_str, str):
  771:         raise TypeError(f"$numberDouble must be string: {doc}")
  772:     return float(d_str)
  773: 
  774: 
  775: def _parse_canonical_decimal128(doc: Any, dummy0: Any) -> Decimal128:
  776:     """Decode a JSON decimal128 to bson.decimal128.Decimal128."""
  777:     d_str = doc["$numberDecimal"]
  778:     if len(doc) != 1:
  779:         raise TypeError(f"Bad $numberDecimal, extra field(s): {doc}")
  780:     if not isinstance(d_str, str):
  781:         raise TypeError(f"$numberDecimal must be string: {doc}")
  782:     return Decimal128(d_str)
  783: 
  784: 
  785: def _parse_canonical_minkey(doc: Any, dummy0: Any) -> MinKey:
  786:     """Decode a JSON MinKey to bson.min_key.MinKey."""
  787:     if type(doc["$minKey"]) is not int or doc["$minKey"] != 1:  # noqa: E721
  788:         raise TypeError(f"$minKey value must be 1: {doc}")
  789:     if len(doc) != 1:
  790:         raise TypeError(f"Bad $minKey, extra field(s): {doc}")
  791:     return MinKey()
  792: 
  793: 
  794: def _parse_canonical_maxkey(doc: Any, dummy0: Any) -> MaxKey:
  795:     """Decode a JSON MaxKey to bson.max_key.MaxKey."""
  796:     if type(doc["$maxKey"]) is not int or doc["$maxKey"] != 1:  # noqa: E721
  797:         raise TypeError("$maxKey value must be 1: %s", (doc,))
  798:     if len(doc) != 1:
  799:         raise TypeError(f"Bad $minKey, extra field(s): {doc}")
  800:     return MaxKey()
  801: 
  802: 
  803: def _parse_binary(doc: Any, json_options: JSONOptions) -> Union[Binary, uuid.UUID]:
  804:     if "$type" in doc:
  805:         return _parse_legacy_binary(doc, json_options)
  806:     else:
  807:         return _parse_canonical_binary(doc, json_options)
  808: 
  809: 
  810: def _parse_timestamp(doc: Any, dummy0: Any) -> Timestamp:
  811:     tsp = doc["$timestamp"]
  812:     return Timestamp(tsp["t"], tsp["i"])
  813: 
  814: 
  815: _PARSERS: dict[str, Callable[[Any, JSONOptions], Any]] = {
  816:     "$oid": _parse_canonical_oid,
  817:     "$ref": _parse_canonical_dbref,
  818:     "$date": _parse_canonical_datetime,
  819:     "$regex": _parse_legacy_regex,
  820:     "$minKey": _parse_canonical_minkey,
  821:     "$maxKey": _parse_canonical_maxkey,
  822:     "$binary": _parse_binary,
  823:     "$code": _parse_canonical_code,
  824:     "$uuid": _parse_legacy_uuid,
  825:     "$undefined": lambda _, _1: None,
  826:     "$numberLong": _parse_canonical_int64,
  827:     "$timestamp": _parse_timestamp,
  828:     "$numberDecimal": _parse_canonical_decimal128,
  829:     "$dbPointer": _parse_canonical_dbpointer,
  830:     "$regularExpression": _parse_canonical_regex,
  831:     "$symbol": _parse_canonical_symbol,
  832:     "$numberInt": _parse_canonical_int32,
  833:     "$numberDouble": _parse_canonical_double,
  834: }
  835: _PARSERS_SET = set(_PARSERS)
  836: 
  837: 
  838: def _encode_binary(data: bytes, subtype: int, json_options: JSONOptions) -> Any:
  839:     if json_options.json_mode == JSONMode.LEGACY:
  840:         return {"$binary": base64.b64encode(data).decode(), "$type": "%02x" % subtype}
  841:     return {"$binary": {"base64": base64.b64encode(data).decode(), "subType": "%02x" % subtype}}
  842: 
  843: 
  844: def _encode_datetimems(obj: Any, json_options: JSONOptions) -> dict:
  845:     if (
  846:         json_options.datetime_representation == DatetimeRepresentation.ISO8601
  847:         and 0 <= int(obj) <= _max_datetime_ms()
  848:     ):
  849:         return _encode_datetime(obj.as_datetime(), json_options)
  850:     elif json_options.datetime_representation == DatetimeRepresentation.LEGACY:
  851:         return {"$date": str(int(obj))}
  852:     return {"$date": {"$numberLong": str(int(obj))}}
  853: 
  854: 
  855: def _encode_code(obj: Code, json_options: JSONOptions) -> dict:
  856:     if obj.scope is None:
  857:         return {"$code": str(obj)}
  858:     else:
  859:         return {"$code": str(obj), "$scope": _json_convert(obj.scope, json_options)}
  860: 
  861: 
  862: def _encode_int64(obj: Int64, json_options: JSONOptions) -> Any:
  863:     if json_options.strict_number_long:
  864:         return {"$numberLong": str(obj)}
  865:     else:
  866:         return int(obj)
  867: 
  868: 
  869: def _encode_noop(obj: Any, dummy0: Any) -> Any:
  870:     return obj
  871: 
  872: 
  873: def _encode_regex(obj: Any, json_options: JSONOptions) -> dict:
  874:     flags = ""
  875:     if obj.flags & re.IGNORECASE:
  876:         flags += "i"
  877:     if obj.flags & re.LOCALE:
  878:         flags += "l"
  879:     if obj.flags & re.MULTILINE:
  880:         flags += "m"
  881:     if obj.flags & re.DOTALL:
  882:         flags += "s"
  883:     if obj.flags & re.UNICODE:
  884:         flags += "u"
  885:     if obj.flags & re.VERBOSE:
  886:         flags += "x"
  887:     if isinstance(obj.pattern, str):
  888:         pattern = obj.pattern
  889:     else:
  890:         pattern = obj.pattern.decode("utf-8")
  891:     if json_options.json_mode == JSONMode.LEGACY:
  892:         return {"$regex": pattern, "$options": flags}
  893:     return {"$regularExpression": {"pattern": pattern, "options": flags}}
  894: 
  895: 
  896: def _encode_int(obj: int, json_options: JSONOptions) -> Any:
  897:     if json_options.json_mode == JSONMode.CANONICAL:
  898:         if -_INT32_MAX <= obj < _INT32_MAX:
  899:             return {"$numberInt": str(obj)}
  900:         return {"$numberLong": str(obj)}
  901:     return obj
  902: 
  903: 
  904: def _encode_float(obj: float, json_options: JSONOptions) -> Any:
  905:     if json_options.json_mode != JSONMode.LEGACY:
  906:         if math.isnan(obj):
  907:             return {"$numberDouble": "NaN"}
  908:         elif math.isinf(obj):
  909:             representation = "Infinity" if obj > 0 else "-Infinity"
  910:             return {"$numberDouble": representation}
  911:         elif json_options.json_mode == JSONMode.CANONICAL:
  912:             # repr() will return the shortest string guaranteed to produce the
  913:             # original value, when float() is called on it.
  914:             return {"$numberDouble": str(repr(obj))}
  915:     return obj
  916: 
  917: 
  918: def _encode_datetime(obj: datetime.datetime, json_options: JSONOptions) -> dict:
  919:     if json_options.datetime_representation == DatetimeRepresentation.ISO8601:
  920:         if not obj.tzinfo:
  921:             obj = obj.replace(tzinfo=utc)
  922:             assert obj.tzinfo is not None
  923:         if obj >= EPOCH_AWARE:
  924:             off = obj.tzinfo.utcoffset(obj)
  925:             if (off.days, off.seconds, off.microseconds) == (0, 0, 0):  # type: ignore
  926:                 tz_string = "Z"
  927:             else:
  928:                 tz_string = obj.strftime("%z")
  929:             millis = int(obj.microsecond / 1000)
  930:             fracsecs = ".%03d" % (millis,) if millis else ""
  931:             return {
  932:                 "$date": "{}{}{}".format(obj.strftime("%Y-%m-%dT%H:%M:%S"), fracsecs, tz_string)
  933:             }
  934: 
  935:     millis = _datetime_to_millis(obj)
  936:     if json_options.datetime_representation == DatetimeRepresentation.LEGACY:
  937:         return {"$date": millis}
  938:     return {"$date": {"$numberLong": str(millis)}}
  939: 
  940: 
  941: def _encode_bytes(obj: bytes, json_options: JSONOptions) -> dict:
  942:     return _encode_binary(obj, 0, json_options)
  943: 
  944: 
  945: def _encode_binary_obj(obj: Binary, json_options: JSONOptions) -> dict:
  946:     return _encode_binary(obj, obj.subtype, json_options)
  947: 
  948: 
  949: def _encode_uuid(obj: uuid.UUID, json_options: JSONOptions) -> dict:
  950:     if json_options.strict_uuid:
  951:         binval = Binary.from_uuid(obj, uuid_representation=json_options.uuid_representation)
  952:         return _encode_binary(binval, binval.subtype, json_options)
  953:     else:
  954:         return {"$uuid": obj.hex}
  955: 
  956: 
  957: def _encode_objectid(obj: ObjectId, dummy0: Any) -> dict:
  958:     return {"$oid": str(obj)}
  959: 
  960: 
  961: def _encode_timestamp(obj: Timestamp, dummy0: Any) -> dict:
  962:     return {"$timestamp": {"t": obj.time, "i": obj.inc}}
  963: 
  964: 
  965: def _encode_decimal128(obj: Timestamp, dummy0: Any) -> dict:
  966:     return {"$numberDecimal": str(obj)}
  967: 
  968: 
  969: def _encode_dbref(obj: DBRef, json_options: JSONOptions) -> dict:
  970:     return _json_convert(obj.as_doc(), json_options=json_options)
  971: 
  972: 
  973: def _encode_minkey(dummy0: Any, dummy1: Any) -> dict:
  974:     return {"$minKey": 1}
  975: 
  976: 
  977: def _encode_maxkey(dummy0: Any, dummy1: Any) -> dict:
  978:     return {"$maxKey": 1}
  979: 
  980: 
  981: # Encoders for BSON types
  982: # Each encoder function's signature is:
  983: #   - obj: a Python data type, e.g. a Python int for _encode_int
  984: #   - json_options: a JSONOptions
  985: _ENCODERS: dict[Type, Callable[[Any, JSONOptions], Any]] = {
  986:     bool: _encode_noop,
  987:     bytes: _encode_bytes,
  988:     datetime.datetime: _encode_datetime,
  989:     DatetimeMS: _encode_datetimems,
  990:     float: _encode_float,
  991:     int: _encode_int,
  992:     str: _encode_noop,
  993:     type(None): _encode_noop,
  994:     uuid.UUID: _encode_uuid,
  995:     Binary: _encode_binary_obj,
  996:     Int64: _encode_int64,
  997:     Code: _encode_code,
  998:     DBRef: _encode_dbref,
  999:     MaxKey: _encode_maxkey,
 1000:     MinKey: _encode_minkey,
 1001:     ObjectId: _encode_objectid,
 1002:     Regex: _encode_regex,
 1003:     RE_TYPE: _encode_regex,
 1004:     Timestamp: _encode_timestamp,
 1005:     Decimal128: _encode_decimal128,
 1006: }
 1007: 
 1008: # Map each _type_marker to its encoder for faster lookup.
 1009: _MARKERS: dict[int, Callable[[Any, JSONOptions], Any]] = {}
 1010: for _typ in _ENCODERS:
 1011:     if hasattr(_typ, "_type_marker"):
 1012:         _MARKERS[_typ._type_marker] = _ENCODERS[_typ]
 1013: 
 1014: _BUILT_IN_TYPES = tuple(t for t in _ENCODERS)
 1015: 
 1016: 
 1017: def default(obj: Any, json_options: JSONOptions = DEFAULT_JSON_OPTIONS) -> Any:
 1018:     # First see if the type is already cached. KeyError will only ever
 1019:     # happen once per subtype.
 1020:     try:
 1021:         return _ENCODERS[type(obj)](obj, json_options)
 1022:     except KeyError:
 1023:         pass
 1024: 
 1025:     # Second, fall back to trying _type_marker. This has to be done
 1026:     # before the loop below since users could subclass one of our
 1027:     # custom types that subclasses a python built-in (e.g. Binary)
 1028:     if hasattr(obj, "_type_marker"):
 1029:         marker = obj._type_marker
 1030:         if marker in _MARKERS:
 1031:             func = _MARKERS[marker]
 1032:             # Cache this type for faster subsequent lookup.
 1033:             _ENCODERS[type(obj)] = func
 1034:             return func(obj, json_options)
 1035: 
 1036:     # Third, test each base type. This will only happen once for
 1037:     # a subtype of a supported base type.
 1038:     for base in _BUILT_IN_TYPES:
 1039:         if isinstance(obj, base):
 1040:             func = _ENCODERS[base]
 1041:             # Cache this type for faster subsequent lookup.
 1042:             _ENCODERS[type(obj)] = func
 1043:             return func(obj, json_options)
 1044: 
 1045:     raise TypeError("%r is not JSON serializable" % obj)
 1046: 
 1047: 
 1048: def _get_str_size(obj: Any) -> int:
 1049:     return len(obj)
 1050: 
 1051: 
 1052: def _get_datetime_size(obj: datetime.datetime) -> int:
 1053:     return 5 + len(str(obj.time()))
 1054: 
 1055: 
 1056: def _get_regex_size(obj: Regex) -> int:
 1057:     return 18 + len(obj.pattern)
 1058: 
 1059: 
 1060: def _get_dbref_size(obj: DBRef) -> int:
 1061:     return 34 + len(obj.collection)
 1062: 
 1063: 
 1064: _CONSTANT_SIZE_TABLE: dict[Any, int] = {
 1065:     ObjectId: 28,
 1066:     int: 11,
 1067:     Int64: 11,
 1068:     Decimal128: 11,
 1069:     Timestamp: 14,
 1070:     MinKey: 8,
 1071:     MaxKey: 8,
 1072: }
 1073: 
 1074: _VARIABLE_SIZE_TABLE: dict[Any, Callable[[Any], int]] = {
 1075:     str: _get_str_size,
 1076:     bytes: _get_str_size,
 1077:     datetime.datetime: _get_datetime_size,
 1078:     Regex: _get_regex_size,
 1079:     DBRef: _get_dbref_size,
 1080: }
 1081: 
 1082: 
 1083: def get_size(obj: Any, max_size: int, current_size: int = 0) -> int:
 1084:     """Recursively finds size of objects"""
 1085:     if current_size >= max_size:
 1086:         return current_size
 1087: 
 1088:     obj_type = type(obj)
 1089: 
 1090:     # Check to see if the obj has a constant size estimate
 1091:     try:
 1092:         return _CONSTANT_SIZE_TABLE[obj_type]
 1093:     except KeyError:
 1094:         pass
 1095: 
 1096:     # Check to see if the obj has a variable but simple size estimate
 1097:     try:
 1098:         return _VARIABLE_SIZE_TABLE[obj_type](obj)
 1099:     except KeyError:
 1100:         pass
 1101: 
 1102:     # Special cases that require recursion
 1103:     if obj_type == Code:
 1104:         if obj.scope:
 1105:             current_size += (
 1106:                 5 + get_size(obj.scope, max_size, current_size) + len(obj) - len(obj.scope)
 1107:             )
 1108:         else:
 1109:             current_size += 5 + len(obj)
 1110:     elif obj_type == dict:
 1111:         for k, v in obj.items():
 1112:             current_size += get_size(k, max_size, current_size)
 1113:             current_size += get_size(v, max_size, current_size)
 1114:             if current_size >= max_size:
 1115:                 return current_size
 1116:     elif hasattr(obj, "__iter__"):
 1117:         for i in obj:
 1118:             current_size += get_size(i, max_size, current_size)
 1119:             if current_size >= max_size:
 1120:                 return current_size
 1121:     return current_size
 1122: 
 1123: 
 1124: def _truncate_documents(obj: Any, max_length: int) -> Tuple[Any, int]:
 1125:     """Recursively truncate documents as needed to fit inside max_length characters."""
 1126:     if max_length <= 0:
 1127:         return None, 0
 1128:     remaining = max_length
 1129:     if hasattr(obj, "items"):
 1130:         truncated: Any = {}
 1131:         for k, v in obj.items():
 1132:             truncated_v, remaining = _truncate_documents(v, remaining)
 1133:             if truncated_v:
 1134:                 truncated[k] = truncated_v
 1135:             if remaining <= 0:
 1136:                 break
 1137:         return truncated, remaining
 1138:     elif hasattr(obj, "__iter__") and not isinstance(obj, (str, bytes)):
 1139:         truncated: Any = []  # type:ignore[no-redef]
 1140:         for v in obj:
 1141:             truncated_v, remaining = _truncate_documents(v, remaining)
 1142:             if truncated_v:
 1143:                 truncated.append(truncated_v)
 1144:             if remaining <= 0:
 1145:                 break
 1146:         return truncated, remaining
 1147:     else:
 1148:         return _truncate(obj, remaining)
 1149: 
 1150: 
 1151: def _truncate(obj: Any, remaining: int) -> Tuple[Any, int]:
 1152:     size = get_size(obj, remaining)
 1153: 
 1154:     if size <= remaining:
 1155:         return obj, remaining - size
 1156:     else:
 1157:         try:
 1158:             truncated = obj[:remaining]
 1159:         except TypeError:
 1160:             truncated = obj
 1161:         return truncated, remaining - size
