    1: # Copyright 2009-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: from __future__ import annotations
   15: 
   16: from typing import TYPE_CHECKING, Any, Tuple, Type, Union
   17: from uuid import UUID
   18: 
   19: """Tools for representing BSON binary data.
   20: """
   21: 
   22: BINARY_SUBTYPE = 0
   23: """BSON binary subtype for binary data.
   24: 
   25: This is the default subtype for binary data.
   26: """
   27: 
   28: FUNCTION_SUBTYPE = 1
   29: """BSON binary subtype for functions.
   30: """
   31: 
   32: OLD_BINARY_SUBTYPE = 2
   33: """Old BSON binary subtype for binary data.
   34: 
   35: This is the old default subtype, the current
   36: default is :data:`BINARY_SUBTYPE`.
   37: """
   38: 
   39: OLD_UUID_SUBTYPE = 3
   40: """Old BSON binary subtype for a UUID.
   41: 
   42: :class:`uuid.UUID` instances will automatically be encoded
   43: by :mod:`bson` using this subtype when using
   44: :data:`UuidRepresentation.PYTHON_LEGACY`,
   45: :data:`UuidRepresentation.JAVA_LEGACY`, or
   46: :data:`UuidRepresentation.CSHARP_LEGACY`.
   47: 
   48: .. versionadded:: 2.1
   49: """
   50: 
   51: UUID_SUBTYPE = 4
   52: """BSON binary subtype for a UUID.
   53: 
   54: This is the standard BSON binary subtype for UUIDs.
   55: :class:`uuid.UUID` instances will automatically be encoded
   56: by :mod:`bson` using this subtype when using
   57: :data:`UuidRepresentation.STANDARD`.
   58: """
   59: 
   60: 
   61: if TYPE_CHECKING:
   62:     from array import array as _array
   63:     from mmap import mmap as _mmap
   64: 
   65: 
   66: class UuidRepresentation:
   67:     UNSPECIFIED = 0
   68:     """An unspecified UUID representation.
   69: 
   70:     When configured, :class:`uuid.UUID` instances will **not** be
   71:     automatically encoded to or decoded from :class:`~bson.binary.Binary`.
   72:     When encoding a :class:`uuid.UUID` instance, an error will be raised.
   73:     To encode a :class:`uuid.UUID` instance with this configuration, it must
   74:     be wrapped in the :class:`~bson.binary.Binary` class by the application
   75:     code. When decoding a BSON binary field with a UUID subtype, a
   76:     :class:`~bson.binary.Binary` instance will be returned instead of a
   77:     :class:`uuid.UUID` instance.
   78: 
   79:     See :ref:`unspecified-representation-details` for details.
   80: 
   81:     .. versionadded:: 3.11
   82:     """
   83: 
   84:     STANDARD = UUID_SUBTYPE
   85:     """The standard UUID representation.
   86: 
   87:     :class:`uuid.UUID` instances will automatically be encoded to
   88:     and decoded from BSON binary, using RFC-4122 byte order with
   89:     binary subtype :data:`UUID_SUBTYPE`.
   90: 
   91:     See :ref:`standard-representation-details` for details.
   92: 
   93:     .. versionadded:: 3.11
   94:     """
   95: 
   96:     PYTHON_LEGACY = OLD_UUID_SUBTYPE
   97:     """The Python legacy UUID representation.
   98: 
   99:     :class:`uuid.UUID` instances will automatically be encoded to
  100:     and decoded from BSON binary, using RFC-4122 byte order with
  101:     binary subtype :data:`OLD_UUID_SUBTYPE`.
  102: 
  103:     See :ref:`python-legacy-representation-details` for details.
  104: 
  105:     .. versionadded:: 3.11
  106:     """
  107: 
  108:     JAVA_LEGACY = 5
  109:     """The Java legacy UUID representation.
  110: 
  111:     :class:`uuid.UUID` instances will automatically be encoded to
  112:     and decoded from BSON binary subtype :data:`OLD_UUID_SUBTYPE`,
  113:     using the Java driver's legacy byte order.
  114: 
  115:     See :ref:`java-legacy-representation-details` for details.
  116: 
  117:     .. versionadded:: 3.11
  118:     """
  119: 
  120:     CSHARP_LEGACY = 6
  121:     """The C#/.net legacy UUID representation.
  122: 
  123:     :class:`uuid.UUID` instances will automatically be encoded to
  124:     and decoded from BSON binary subtype :data:`OLD_UUID_SUBTYPE`,
  125:     using the C# driver's legacy byte order.
  126: 
  127:     See :ref:`csharp-legacy-representation-details` for details.
  128: 
  129:     .. versionadded:: 3.11
  130:     """
  131: 
  132: 
  133: STANDARD = UuidRepresentation.STANDARD
  134: """An alias for :data:`UuidRepresentation.STANDARD`.
  135: 
  136: .. versionadded:: 3.0
  137: """
  138: 
  139: PYTHON_LEGACY = UuidRepresentation.PYTHON_LEGACY
  140: """An alias for :data:`UuidRepresentation.PYTHON_LEGACY`.
  141: 
  142: .. versionadded:: 3.0
  143: """
  144: 
  145: JAVA_LEGACY = UuidRepresentation.JAVA_LEGACY
  146: """An alias for :data:`UuidRepresentation.JAVA_LEGACY`.
  147: 
  148: .. versionchanged:: 3.6
  149:    BSON binary subtype 4 is decoded using RFC-4122 byte order.
  150: .. versionadded:: 2.3
  151: """
  152: 
  153: CSHARP_LEGACY = UuidRepresentation.CSHARP_LEGACY
  154: """An alias for :data:`UuidRepresentation.CSHARP_LEGACY`.
  155: 
  156: .. versionchanged:: 3.6
  157:    BSON binary subtype 4 is decoded using RFC-4122 byte order.
  158: .. versionadded:: 2.3
  159: """
  160: 
  161: ALL_UUID_SUBTYPES = (OLD_UUID_SUBTYPE, UUID_SUBTYPE)
  162: ALL_UUID_REPRESENTATIONS = (
  163:     UuidRepresentation.UNSPECIFIED,
  164:     UuidRepresentation.STANDARD,
  165:     UuidRepresentation.PYTHON_LEGACY,
  166:     UuidRepresentation.JAVA_LEGACY,
  167:     UuidRepresentation.CSHARP_LEGACY,
  168: )
  169: UUID_REPRESENTATION_NAMES = {
  170:     UuidRepresentation.UNSPECIFIED: "UuidRepresentation.UNSPECIFIED",
  171:     UuidRepresentation.STANDARD: "UuidRepresentation.STANDARD",
  172:     UuidRepresentation.PYTHON_LEGACY: "UuidRepresentation.PYTHON_LEGACY",
  173:     UuidRepresentation.JAVA_LEGACY: "UuidRepresentation.JAVA_LEGACY",
  174:     UuidRepresentation.CSHARP_LEGACY: "UuidRepresentation.CSHARP_LEGACY",
  175: }
  176: 
  177: MD5_SUBTYPE = 5
  178: """BSON binary subtype for an MD5 hash.
  179: """
  180: 
  181: COLUMN_SUBTYPE = 7
  182: """BSON binary subtype for columns.
  183: 
  184: .. versionadded:: 4.0
  185: """
  186: 
  187: SENSITIVE_SUBTYPE = 8
  188: """BSON binary subtype for sensitive data.
  189: 
  190: .. versionadded:: 4.5
  191: """
  192: 
  193: 
  194: USER_DEFINED_SUBTYPE = 128
  195: """BSON binary subtype for any user defined structure.
  196: """
  197: 
  198: 
  199: class Binary(bytes):
  200:     """Representation of BSON binary data.
  201: 
  202:     This is necessary because we want to represent Python strings as
  203:     the BSON string type. We need to wrap binary data so we can tell
  204:     the difference between what should be considered binary data and
  205:     what should be considered a string when we encode to BSON.
  206: 
  207:     Raises TypeError if `data` is not an instance of :class:`bytes`
  208:     or `subtype` is not an instance of :class:`int`.
  209:     Raises ValueError if `subtype` is not in [0, 256).
  210: 
  211:     .. note::
  212:       Instances of Binary with subtype 0 will be decoded directly to :class:`bytes`.
  213: 
  214:     :param data: the binary data to represent. Can be any bytes-like type
  215:         that implements the buffer protocol.
  216:     :param subtype: the `binary subtype
  217:         <https://bsonspec.org/spec.html>`_
  218:         to use
  219: 
  220:     .. versionchanged:: 3.9
  221:       Support any bytes-like type that implements the buffer protocol.
  222:     """
  223: 
  224:     _type_marker = 5
  225:     __subtype: int
  226: 
  227:     def __new__(
  228:         cls: Type[Binary],
  229:         data: Union[memoryview, bytes, _mmap, _array[Any]],
  230:         subtype: int = BINARY_SUBTYPE,
  231:     ) -> Binary:
  232:         if not isinstance(subtype, int):
  233:             raise TypeError("subtype must be an instance of int")
  234:         if subtype >= 256 or subtype < 0:
  235:             raise ValueError("subtype must be contained in [0, 256)")
  236:         # Support any type that implements the buffer protocol.
  237:         self = bytes.__new__(cls, memoryview(data).tobytes())
  238:         self.__subtype = subtype
  239:         return self
  240: 
  241:     @classmethod
  242:     def from_uuid(
  243:         cls: Type[Binary], uuid: UUID, uuid_representation: int = UuidRepresentation.STANDARD
  244:     ) -> Binary:
  245:         """Create a BSON Binary object from a Python UUID.
  246: 
  247:         Creates a :class:`~bson.binary.Binary` object from a
  248:         :class:`uuid.UUID` instance. Assumes that the native
  249:         :class:`uuid.UUID` instance uses the byte-order implied by the
  250:         provided ``uuid_representation``.
  251: 
  252:         Raises :exc:`TypeError` if `uuid` is not an instance of
  253:         :class:`~uuid.UUID`.
  254: 
  255:         :param uuid: A :class:`uuid.UUID` instance.
  256:         :param uuid_representation: A member of
  257:             :class:`~bson.binary.UuidRepresentation`. Default:
  258:             :const:`~bson.binary.UuidRepresentation.STANDARD`.
  259:             See :ref:`handling-uuid-data-example` for details.
  260: 
  261:         .. versionadded:: 3.11
  262:         """
  263:         if not isinstance(uuid, UUID):
  264:             raise TypeError("uuid must be an instance of uuid.UUID")
  265: 
  266:         if uuid_representation not in ALL_UUID_REPRESENTATIONS:
  267:             raise ValueError(
  268:                 "uuid_representation must be a value from bson.binary.UuidRepresentation"
  269:             )
  270: 
  271:         if uuid_representation == UuidRepresentation.UNSPECIFIED:
  272:             raise ValueError(
  273:                 "cannot encode native uuid.UUID with "
  274:                 "UuidRepresentation.UNSPECIFIED. UUIDs can be manually "
  275:                 "converted to bson.Binary instances using "
  276:                 "bson.Binary.from_uuid() or a different UuidRepresentation "
  277:                 "can be configured. See the documentation for "
  278:                 "UuidRepresentation for more information."
  279:             )
  280: 
  281:         subtype = OLD_UUID_SUBTYPE
  282:         if uuid_representation == UuidRepresentation.PYTHON_LEGACY:
  283:             payload = uuid.bytes
  284:         elif uuid_representation == UuidRepresentation.JAVA_LEGACY:
  285:             from_uuid = uuid.bytes
  286:             payload = from_uuid[0:8][::-1] + from_uuid[8:16][::-1]
  287:         elif uuid_representation == UuidRepresentation.CSHARP_LEGACY:
  288:             payload = uuid.bytes_le
  289:         else:
  290:             # uuid_representation == UuidRepresentation.STANDARD
  291:             subtype = UUID_SUBTYPE
  292:             payload = uuid.bytes
  293: 
  294:         return cls(payload, subtype)
  295: 
  296:     def as_uuid(self, uuid_representation: int = UuidRepresentation.STANDARD) -> UUID:
  297:         """Create a Python UUID from this BSON Binary object.
  298: 
  299:         Decodes this binary object as a native :class:`uuid.UUID` instance
  300:         with the provided ``uuid_representation``.
  301: 
  302:         Raises :exc:`ValueError` if this :class:`~bson.binary.Binary` instance
  303:         does not contain a UUID.
  304: 
  305:         :param uuid_representation: A member of
  306:             :class:`~bson.binary.UuidRepresentation`. Default:
  307:             :const:`~bson.binary.UuidRepresentation.STANDARD`.
  308:             See :ref:`handling-uuid-data-example` for details.
  309: 
  310:         .. versionadded:: 3.11
  311:         """
  312:         if self.subtype not in ALL_UUID_SUBTYPES:
  313:             raise ValueError(f"cannot decode subtype {self.subtype} as a uuid")
  314: 
  315:         if uuid_representation not in ALL_UUID_REPRESENTATIONS:
  316:             raise ValueError(
  317:                 "uuid_representation must be a value from bson.binary.UuidRepresentation"
  318:             )
  319: 
  320:         if uuid_representation == UuidRepresentation.UNSPECIFIED:
  321:             raise ValueError("uuid_representation cannot be UNSPECIFIED")
  322:         elif uuid_representation == UuidRepresentation.PYTHON_LEGACY:
  323:             if self.subtype == OLD_UUID_SUBTYPE:
  324:                 return UUID(bytes=self)
  325:         elif uuid_representation == UuidRepresentation.JAVA_LEGACY:
  326:             if self.subtype == OLD_UUID_SUBTYPE:
  327:                 return UUID(bytes=self[0:8][::-1] + self[8:16][::-1])
  328:         elif uuid_representation == UuidRepresentation.CSHARP_LEGACY:
  329:             if self.subtype == OLD_UUID_SUBTYPE:
  330:                 return UUID(bytes_le=self)
  331:         else:
  332:             # uuid_representation == UuidRepresentation.STANDARD
  333:             if self.subtype == UUID_SUBTYPE:
  334:                 return UUID(bytes=self)
  335: 
  336:         raise ValueError(
  337:             f"cannot decode subtype {self.subtype} to {UUID_REPRESENTATION_NAMES[uuid_representation]}"
  338:         )
  339: 
  340:     @property
  341:     def subtype(self) -> int:
  342:         """Subtype of this binary data."""
  343:         return self.__subtype
  344: 
  345:     def __getnewargs__(self) -> Tuple[bytes, int]:  # type: ignore[override]
  346:         # Work around http://bugs.python.org/issue7382
  347:         data = super().__getnewargs__()[0]
  348:         if not isinstance(data, bytes):
  349:             data = data.encode("latin-1")
  350:         return data, self.__subtype
  351: 
  352:     def __eq__(self, other: Any) -> bool:
  353:         if isinstance(other, Binary):
  354:             return (self.__subtype, bytes(self)) == (other.subtype, bytes(other))
  355:         # We don't return NotImplemented here because if we did then
  356:         # Binary("foo") == "foo" would return True, since Binary is a
  357:         # subclass of str...
  358:         return False
  359: 
  360:     def __hash__(self) -> int:
  361:         return super().__hash__() ^ hash(self.__subtype)
  362: 
  363:     def __ne__(self, other: Any) -> bool:
  364:         return not self == other
  365: 
  366:     def __repr__(self) -> str:
  367:         if self.__subtype == SENSITIVE_SUBTYPE:
  368:             return f"<Binary(REDACTED, {self.__subtype})>"
  369:         else:
  370:             return f"Binary({bytes.__repr__(self)}, {self.__subtype})"
