    1: # Copyright 2009-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Tools for creating and manipulating SON, the Serialized Ocument Notation.
   16: 
   17: Regular dictionaries can be used instead of SON objects, but not when the order
   18: of keys is important. A SON object can be used just like a normal Python
   19: dictionary.
   20: """
   21: from __future__ import annotations
   22: 
   23: import copy
   24: import re
   25: from collections.abc import Mapping as _Mapping
   26: from typing import (
   27:     Any,
   28:     Dict,
   29:     Iterable,
   30:     Iterator,
   31:     Mapping,
   32:     Optional,
   33:     Pattern,
   34:     Tuple,
   35:     Type,
   36:     TypeVar,
   37:     Union,
   38:     cast,
   39: )
   40: 
   41: # This sort of sucks, but seems to be as good as it gets...
   42: # This is essentially the same as re._pattern_type
   43: RE_TYPE: Type[Pattern[Any]] = type(re.compile(""))
   44: 
   45: _Key = TypeVar("_Key")
   46: _Value = TypeVar("_Value")
   47: _T = TypeVar("_T")
   48: 
   49: 
   50: class SON(Dict[_Key, _Value]):
   51:     """SON data.
   52: 
   53:     A subclass of dict that maintains ordering of keys and provides a
   54:     few extra niceties for dealing with SON. SON provides an API
   55:     similar to collections.OrderedDict.
   56:     """
   57: 
   58:     __keys: list[Any]
   59: 
   60:     def __init__(
   61:         self,
   62:         data: Optional[Union[Mapping[_Key, _Value], Iterable[Tuple[_Key, _Value]]]] = None,
   63:         **kwargs: Any,
   64:     ) -> None:
   65:         self.__keys = []
   66:         dict.__init__(self)
   67:         self.update(data)
   68:         self.update(kwargs)
   69: 
   70:     def __new__(cls: Type[SON[_Key, _Value]], *args: Any, **kwargs: Any) -> SON[_Key, _Value]:
   71:         instance = super().__new__(cls, *args, **kwargs)  # type: ignore[type-var]
   72:         instance.__keys = []
   73:         return instance
   74: 
   75:     def __repr__(self) -> str:
   76:         result = []
   77:         for key in self.__keys:
   78:             result.append(f"({key!r}, {self[key]!r})")
   79:         return "SON([%s])" % ", ".join(result)
   80: 
   81:     def __setitem__(self, key: _Key, value: _Value) -> None:
   82:         if key not in self.__keys:
   83:             self.__keys.append(key)
   84:         dict.__setitem__(self, key, value)
   85: 
   86:     def __delitem__(self, key: _Key) -> None:
   87:         self.__keys.remove(key)
   88:         dict.__delitem__(self, key)
   89: 
   90:     def copy(self) -> SON[_Key, _Value]:
   91:         other: SON[_Key, _Value] = SON()
   92:         other.update(self)
   93:         return other
   94: 
   95:     # TODO this is all from UserDict.DictMixin. it could probably be made more
   96:     # efficient.
   97:     # second level definitions support higher levels
   98:     def __iter__(self) -> Iterator[_Key]:
   99:         yield from self.__keys
  100: 
  101:     def has_key(self, key: _Key) -> bool:
  102:         return key in self.__keys
  103: 
  104:     def iterkeys(self) -> Iterator[_Key]:
  105:         return self.__iter__()
  106: 
  107:     # fourth level uses definitions from lower levels
  108:     def itervalues(self) -> Iterator[_Value]:
  109:         for _, v in self.items():
  110:             yield v
  111: 
  112:     def values(self) -> list[_Value]:  # type: ignore[override]
  113:         return [v for _, v in self.items()]
  114: 
  115:     def clear(self) -> None:
  116:         self.__keys = []
  117:         super().clear()
  118: 
  119:     def setdefault(self, key: _Key, default: _Value) -> _Value:
  120:         try:
  121:             return self[key]
  122:         except KeyError:
  123:             self[key] = default
  124:         return default
  125: 
  126:     def pop(self, key: _Key, *args: Union[_Value, _T]) -> Union[_Value, _T]:
  127:         if len(args) > 1:
  128:             raise TypeError("pop expected at most 2 arguments, got " + repr(1 + len(args)))
  129:         try:
  130:             value = self[key]
  131:         except KeyError:
  132:             if args:
  133:                 return args[0]
  134:             raise
  135:         del self[key]
  136:         return value
  137: 
  138:     def popitem(self) -> Tuple[_Key, _Value]:
  139:         try:
  140:             k, v = next(iter(self.items()))
  141:         except StopIteration:
  142:             raise KeyError("container is empty") from None
  143:         del self[k]
  144:         return (k, v)
  145: 
  146:     def update(self, other: Optional[Any] = None, **kwargs: _Value) -> None:  # type: ignore[override]
  147:         # Make progressively weaker assumptions about "other"
  148:         if other is None:
  149:             pass
  150:         elif hasattr(other, "items"):
  151:             for k, v in other.items():
  152:                 self[k] = v
  153:         elif hasattr(other, "keys"):
  154:             for k in other:
  155:                 self[k] = other[k]
  156:         else:
  157:             for k, v in other:
  158:                 self[k] = v
  159:         if kwargs:
  160:             self.update(kwargs)
  161: 
  162:     def get(  # type: ignore[override]
  163:         self, key: _Key, default: Optional[Union[_Value, _T]] = None
  164:     ) -> Union[_Value, _T, None]:
  165:         try:
  166:             return self[key]
  167:         except KeyError:
  168:             return default
  169: 
  170:     def __eq__(self, other: Any) -> bool:
  171:         """Comparison to another SON is order-sensitive while comparison to a
  172:         regular dictionary is order-insensitive.
  173:         """
  174:         if isinstance(other, SON):
  175:             return len(self) == len(other) and list(self.items()) == list(other.items())
  176:         return cast(bool, self.to_dict() == other)
  177: 
  178:     def __ne__(self, other: Any) -> bool:
  179:         return not self == other
  180: 
  181:     def __len__(self) -> int:
  182:         return len(self.__keys)
  183: 
  184:     def to_dict(self) -> dict[_Key, _Value]:
  185:         """Convert a SON document to a normal Python dictionary instance.
  186: 
  187:         This is trickier than just *dict(...)* because it needs to be
  188:         recursive.
  189:         """
  190: 
  191:         def transform_value(value: Any) -> Any:
  192:             if isinstance(value, list):
  193:                 return [transform_value(v) for v in value]
  194:             elif isinstance(value, _Mapping):
  195:                 return {k: transform_value(v) for k, v in value.items()}
  196:             else:
  197:                 return value
  198: 
  199:         return cast("dict[_Key, _Value]", transform_value(dict(self)))
  200: 
  201:     def __deepcopy__(self, memo: dict[int, SON[_Key, _Value]]) -> SON[_Key, _Value]:
  202:         out: SON[_Key, _Value] = SON()
  203:         val_id = id(self)
  204:         if val_id in memo:
  205:             return memo[val_id]
  206:         memo[val_id] = out
  207:         for k, v in self.items():
  208:             if not isinstance(v, RE_TYPE):
  209:                 v = copy.deepcopy(v, memo)  # noqa: PLW2901
  210:             out[k] = v
  211:         return out
