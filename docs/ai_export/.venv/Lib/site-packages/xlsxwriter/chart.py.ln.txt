    1: ###############################################################################
    2: #
    3: # Chart - A class for writing the Excel XLSX Worksheet file.
    4: #
    5: # SPDX-License-Identifier: BSD-2-Clause
    6: # Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
    7: #
    8: import re
    9: import copy
   10: from warnings import warn
   11: 
   12: from .shape import Shape
   13: from . import xmlwriter
   14: from .utility import get_rgb_color
   15: from .utility import xl_rowcol_to_cell
   16: from .utility import xl_range_formula
   17: from .utility import supported_datetime
   18: from .utility import datetime_to_excel_datetime
   19: from .utility import quote_sheetname
   20: 
   21: 
   22: class Chart(xmlwriter.XMLwriter):
   23:     """
   24:     A class for writing the Excel XLSX Chart file.
   25: 
   26: 
   27:     """
   28: 
   29:     ###########################################################################
   30:     #
   31:     # Public API.
   32:     #
   33:     ###########################################################################
   34: 
   35:     def __init__(self, options=None):
   36:         """
   37:         Constructor.
   38: 
   39:         """
   40: 
   41:         super(Chart, self).__init__()
   42: 
   43:         self.subtype = None
   44:         self.sheet_type = 0x0200
   45:         self.orientation = 0x0
   46:         self.series = []
   47:         self.embedded = 0
   48:         self.id = -1
   49:         self.series_index = 0
   50:         self.style_id = 2
   51:         self.axis_ids = []
   52:         self.axis2_ids = []
   53:         self.cat_has_num_fmt = 0
   54:         self.requires_category = False
   55:         self.legend = {}
   56:         self.cat_axis_position = "b"
   57:         self.val_axis_position = "l"
   58:         self.formula_ids = {}
   59:         self.formula_data = []
   60:         self.horiz_cat_axis = 0
   61:         self.horiz_val_axis = 1
   62:         self.protection = 0
   63:         self.chartarea = {}
   64:         self.plotarea = {}
   65:         self.x_axis = {}
   66:         self.y_axis = {}
   67:         self.y2_axis = {}
   68:         self.x2_axis = {}
   69:         self.chart_name = ""
   70:         self.show_blanks = "gap"
   71:         self.show_na_as_empty = False
   72:         self.show_hidden = False
   73:         self.show_crosses = 1
   74:         self.width = 480
   75:         self.height = 288
   76:         self.x_scale = 1
   77:         self.y_scale = 1
   78:         self.x_offset = 0
   79:         self.y_offset = 0
   80:         self.table = None
   81:         self.cross_between = "between"
   82:         self.default_marker = None
   83:         self.series_gap_1 = None
   84:         self.series_gap_2 = None
   85:         self.series_overlap_1 = None
   86:         self.series_overlap_2 = None
   87:         self.drop_lines = None
   88:         self.hi_low_lines = None
   89:         self.up_down_bars = None
   90:         self.smooth_allowed = False
   91:         self.title_font = None
   92:         self.title_name = None
   93:         self.title_formula = None
   94:         self.title_data_id = None
   95:         self.title_layout = None
   96:         self.title_overlay = None
   97:         self.title_none = False
   98:         self.date_category = False
   99:         self.date_1904 = False
  100:         self.remove_timezone = False
  101:         self.label_positions = {}
  102:         self.label_position_default = ""
  103:         self.already_inserted = False
  104:         self.combined = None
  105:         self.is_secondary = False
  106:         self.warn_sheetname = True
  107:         self._set_default_properties()
  108: 
  109:     def add_series(self, options=None):
  110:         """
  111:         Add a data series to a chart.
  112: 
  113:         Args:
  114:             options:  A dictionary of chart series options.
  115: 
  116:         Returns:
  117:             Nothing.
  118: 
  119:         """
  120:         # Add a series and it's properties to a chart.
  121:         if options is None:
  122:             options = {}
  123: 
  124:         # Check that the required input has been specified.
  125:         if "values" not in options:
  126:             warn("Must specify 'values' in add_series()")
  127:             return
  128: 
  129:         if self.requires_category and "categories" not in options:
  130:             warn("Must specify 'categories' in add_series() for this chart type")
  131:             return
  132: 
  133:         if len(self.series) == 255:
  134:             warn(
  135:                 "The maximum number of series that can be added to an "
  136:                 "Excel Chart is 255"
  137:             )
  138:             return
  139: 
  140:         # Convert list into a formula string.
  141:         values = self._list_to_formula(options.get("values"))
  142:         categories = self._list_to_formula(options.get("categories"))
  143: 
  144:         # Switch name and name_formula parameters if required.
  145:         name, name_formula = self._process_names(
  146:             options.get("name"), options.get("name_formula")
  147:         )
  148: 
  149:         # Get an id for the data equivalent to the range formula.
  150:         cat_id = self._get_data_id(categories, options.get("categories_data"))
  151:         val_id = self._get_data_id(values, options.get("values_data"))
  152:         name_id = self._get_data_id(name_formula, options.get("name_data"))
  153: 
  154:         # Set the line properties for the series.
  155:         line = Shape._get_line_properties(options.get("line"))
  156: 
  157:         # Allow 'border' as a synonym for 'line' in bar/column style charts.
  158:         if options.get("border"):
  159:             line = Shape._get_line_properties(options["border"])
  160: 
  161:         # Set the fill properties for the series.
  162:         fill = Shape._get_fill_properties(options.get("fill"))
  163: 
  164:         # Set the pattern fill properties for the series.
  165:         pattern = Shape._get_pattern_properties(options.get("pattern"))
  166: 
  167:         # Set the gradient fill properties for the series.
  168:         gradient = Shape._get_gradient_properties(options.get("gradient"))
  169: 
  170:         # Pattern fill overrides solid fill.
  171:         if pattern:
  172:             self.fill = None
  173: 
  174:         # Gradient fill overrides the solid and pattern fill.
  175:         if gradient:
  176:             pattern = None
  177:             fill = None
  178: 
  179:         # Set the marker properties for the series.
  180:         marker = self._get_marker_properties(options.get("marker"))
  181: 
  182:         # Set the trendline properties for the series.
  183:         trendline = self._get_trendline_properties(options.get("trendline"))
  184: 
  185:         # Set the line smooth property for the series.
  186:         smooth = options.get("smooth")
  187: 
  188:         # Set the error bars properties for the series.
  189:         y_error_bars = self._get_error_bars_props(options.get("y_error_bars"))
  190:         x_error_bars = self._get_error_bars_props(options.get("x_error_bars"))
  191: 
  192:         error_bars = {"x_error_bars": x_error_bars, "y_error_bars": y_error_bars}
  193: 
  194:         # Set the point properties for the series.
  195:         points = self._get_points_properties(options.get("points"))
  196: 
  197:         # Set the labels properties for the series.
  198:         labels = self._get_labels_properties(options.get("data_labels"))
  199: 
  200:         # Set the "invert if negative" fill property.
  201:         invert_if_neg = options.get("invert_if_negative", False)
  202:         inverted_color = options.get("invert_if_negative_color", False)
  203: 
  204:         # Set the secondary axis properties.
  205:         x2_axis = options.get("x2_axis")
  206:         y2_axis = options.get("y2_axis")
  207: 
  208:         # Store secondary status for combined charts.
  209:         if x2_axis or y2_axis:
  210:             self.is_secondary = True
  211: 
  212:         # Set the gap for Bar/Column charts.
  213:         if options.get("gap") is not None:
  214:             if y2_axis:
  215:                 self.series_gap_2 = options["gap"]
  216:             else:
  217:                 self.series_gap_1 = options["gap"]
  218: 
  219:         # Set the overlap for Bar/Column charts.
  220:         if options.get("overlap"):
  221:             if y2_axis:
  222:                 self.series_overlap_2 = options["overlap"]
  223:             else:
  224:                 self.series_overlap_1 = options["overlap"]
  225: 
  226:         # Add the user supplied data to the internal structures.
  227:         series = {
  228:             "values": values,
  229:             "categories": categories,
  230:             "name": name,
  231:             "name_formula": name_formula,
  232:             "name_id": name_id,
  233:             "val_data_id": val_id,
  234:             "cat_data_id": cat_id,
  235:             "line": line,
  236:             "fill": fill,
  237:             "pattern": pattern,
  238:             "gradient": gradient,
  239:             "marker": marker,
  240:             "trendline": trendline,
  241:             "labels": labels,
  242:             "invert_if_neg": invert_if_neg,
  243:             "inverted_color": inverted_color,
  244:             "x2_axis": x2_axis,
  245:             "y2_axis": y2_axis,
  246:             "points": points,
  247:             "error_bars": error_bars,
  248:             "smooth": smooth,
  249:         }
  250: 
  251:         self.series.append(series)
  252: 
  253:     def set_x_axis(self, options):
  254:         """
  255:         Set the chart X axis options.
  256: 
  257:         Args:
  258:             options:  A dictionary of axis options.
  259: 
  260:         Returns:
  261:             Nothing.
  262: 
  263:         """
  264:         axis = self._convert_axis_args(self.x_axis, options)
  265: 
  266:         self.x_axis = axis
  267: 
  268:     def set_y_axis(self, options):
  269:         """
  270:         Set the chart Y axis options.
  271: 
  272:         Args:
  273:             options: A dictionary of axis options.
  274: 
  275:         Returns:
  276:             Nothing.
  277: 
  278:         """
  279:         axis = self._convert_axis_args(self.y_axis, options)
  280: 
  281:         self.y_axis = axis
  282: 
  283:     def set_x2_axis(self, options):
  284:         """
  285:         Set the chart secondary X axis options.
  286: 
  287:         Args:
  288:             options: A dictionary of axis options.
  289: 
  290:         Returns:
  291:             Nothing.
  292: 
  293:         """
  294:         axis = self._convert_axis_args(self.x2_axis, options)
  295: 
  296:         self.x2_axis = axis
  297: 
  298:     def set_y2_axis(self, options):
  299:         """
  300:         Set the chart secondary Y axis options.
  301: 
  302:         Args:
  303:             options: A dictionary of axis options.
  304: 
  305:         Returns:
  306:             Nothing.
  307: 
  308:         """
  309:         axis = self._convert_axis_args(self.y2_axis, options)
  310: 
  311:         self.y2_axis = axis
  312: 
  313:     def set_title(self, options=None):
  314:         """
  315:         Set the chart title options.
  316: 
  317:         Args:
  318:             options: A dictionary of chart title options.
  319: 
  320:         Returns:
  321:             Nothing.
  322: 
  323:         """
  324:         if options is None:
  325:             options = {}
  326: 
  327:         name, name_formula = self._process_names(
  328:             options.get("name"), options.get("name_formula")
  329:         )
  330: 
  331:         data_id = self._get_data_id(name_formula, options.get("data"))
  332: 
  333:         self.title_name = name
  334:         self.title_formula = name_formula
  335:         self.title_data_id = data_id
  336: 
  337:         # Set the font properties if present.
  338:         self.title_font = self._convert_font_args(options.get("name_font"))
  339: 
  340:         # Set the axis name layout.
  341:         self.title_layout = self._get_layout_properties(options.get("layout"), True)
  342:         # Set the title overlay option.
  343:         self.title_overlay = options.get("overlay")
  344: 
  345:         # Set the automatic title option.
  346:         self.title_none = options.get("none")
  347: 
  348:     def set_legend(self, options):
  349:         """
  350:         Set the chart legend options.
  351: 
  352:         Args:
  353:             options: A dictionary of chart legend options.
  354: 
  355:         Returns:
  356:             Nothing.
  357:         """
  358:         # Convert the user defined properties to internal properties.
  359:         self.legend = self._get_legend_properties(options)
  360: 
  361:     def set_plotarea(self, options):
  362:         """
  363:         Set the chart plot area options.
  364: 
  365:         Args:
  366:             options: A dictionary of chart plot area options.
  367: 
  368:         Returns:
  369:             Nothing.
  370:         """
  371:         # Convert the user defined properties to internal properties.
  372:         self.plotarea = self._get_area_properties(options)
  373: 
  374:     def set_chartarea(self, options):
  375:         """
  376:         Set the chart area options.
  377: 
  378:         Args:
  379:             options: A dictionary of chart area options.
  380: 
  381:         Returns:
  382:             Nothing.
  383:         """
  384:         # Convert the user defined properties to internal properties.
  385:         self.chartarea = self._get_area_properties(options)
  386: 
  387:     def set_style(self, style_id):
  388:         """
  389:         Set the chart style type.
  390: 
  391:         Args:
  392:             style_id: An int representing the chart style.
  393: 
  394:         Returns:
  395:             Nothing.
  396:         """
  397:         # Set one of the 48 built-in Excel chart styles. The default is 2.
  398:         if style_id is None:
  399:             style_id = 2
  400: 
  401:         if style_id < 1 or style_id > 48:
  402:             style_id = 2
  403: 
  404:         self.style_id = style_id
  405: 
  406:     def show_blanks_as(self, option):
  407:         """
  408:         Set the option for displaying blank data in a chart.
  409: 
  410:         Args:
  411:             option: A string representing the display option.
  412: 
  413:         Returns:
  414:             Nothing.
  415:         """
  416:         if not option:
  417:             return
  418: 
  419:         valid_options = {
  420:             "gap": 1,
  421:             "zero": 1,
  422:             "span": 1,
  423:         }
  424: 
  425:         if option not in valid_options:
  426:             warn("Unknown show_blanks_as() option '%s'" % option)
  427:             return
  428: 
  429:         self.show_blanks = option
  430: 
  431:     def show_na_as_empty_cell(self):
  432:         """
  433:         Display ``#N/A`` on charts as blank/empty cells.
  434: 
  435:         Args:
  436:             None.
  437: 
  438:         Returns:
  439:             Nothing.
  440:         """
  441:         self.show_na_as_empty = True
  442: 
  443:     def show_hidden_data(self):
  444:         """
  445:         Display data on charts from hidden rows or columns.
  446: 
  447:         Args:
  448:             None.
  449: 
  450:         Returns:
  451:             Nothing.
  452:         """
  453:         self.show_hidden = True
  454: 
  455:     def set_size(self, options=None):
  456:         """
  457:         Set size or scale of the chart.
  458: 
  459:         Args:
  460:             options: A dictionary of chart size options.
  461: 
  462:         Returns:
  463:             Nothing.
  464:         """
  465:         if options is None:
  466:             options = {}
  467: 
  468:         # Set dimensions or scale for the chart.
  469:         self.width = options.get("width", self.width)
  470:         self.height = options.get("height", self.height)
  471:         self.x_scale = options.get("x_scale", 1)
  472:         self.y_scale = options.get("y_scale", 1)
  473:         self.x_offset = options.get("x_offset", 0)
  474:         self.y_offset = options.get("y_offset", 0)
  475: 
  476:     def set_table(self, options=None):
  477:         """
  478:         Set properties for an axis data table.
  479: 
  480:         Args:
  481:             options: A dictionary of axis table options.
  482: 
  483:         Returns:
  484:             Nothing.
  485: 
  486:         """
  487:         if options is None:
  488:             options = {}
  489: 
  490:         table = {}
  491: 
  492:         table["horizontal"] = options.get("horizontal", 1)
  493:         table["vertical"] = options.get("vertical", 1)
  494:         table["outline"] = options.get("outline", 1)
  495:         table["show_keys"] = options.get("show_keys", 0)
  496:         table["font"] = self._convert_font_args(options.get("font"))
  497: 
  498:         self.table = table
  499: 
  500:     def set_up_down_bars(self, options=None):
  501:         """
  502:         Set properties for the chart up-down bars.
  503: 
  504:         Args:
  505:             options: A dictionary of options.
  506: 
  507:         Returns:
  508:             Nothing.
  509: 
  510:         """
  511:         if options is None:
  512:             options = {}
  513: 
  514:         # Defaults.
  515:         up_line = None
  516:         up_fill = None
  517:         down_line = None
  518:         down_fill = None
  519: 
  520:         # Set properties for 'up' bar.
  521:         if options.get("up"):
  522:             if "border" in options["up"]:
  523:                 # Map border to line.
  524:                 up_line = Shape._get_line_properties(options["up"]["border"])
  525: 
  526:             if "line" in options["up"]:
  527:                 up_line = Shape._get_line_properties(options["up"]["line"])
  528: 
  529:             if "fill" in options["up"]:
  530:                 up_fill = Shape._get_fill_properties(options["up"]["fill"])
  531: 
  532:         # Set properties for 'down' bar.
  533:         if options.get("down"):
  534:             if "border" in options["down"]:
  535:                 # Map border to line.
  536:                 down_line = Shape._get_line_properties(options["down"]["border"])
  537: 
  538:             if "line" in options["down"]:
  539:                 down_line = Shape._get_line_properties(options["down"]["line"])
  540: 
  541:             if "fill" in options["down"]:
  542:                 down_fill = Shape._get_fill_properties(options["down"]["fill"])
  543: 
  544:         self.up_down_bars = {
  545:             "up": {
  546:                 "line": up_line,
  547:                 "fill": up_fill,
  548:             },
  549:             "down": {
  550:                 "line": down_line,
  551:                 "fill": down_fill,
  552:             },
  553:         }
  554: 
  555:     def set_drop_lines(self, options=None):
  556:         """
  557:         Set properties for the chart drop lines.
  558: 
  559:         Args:
  560:             options: A dictionary of options.
  561: 
  562:         Returns:
  563:             Nothing.
  564: 
  565:         """
  566:         if options is None:
  567:             options = {}
  568: 
  569:         line = Shape._get_line_properties(options.get("line"))
  570:         fill = Shape._get_fill_properties(options.get("fill"))
  571: 
  572:         # Set the pattern fill properties for the series.
  573:         pattern = Shape._get_pattern_properties(options.get("pattern"))
  574: 
  575:         # Set the gradient fill properties for the series.
  576:         gradient = Shape._get_gradient_properties(options.get("gradient"))
  577: 
  578:         # Pattern fill overrides solid fill.
  579:         if pattern:
  580:             self.fill = None
  581: 
  582:         # Gradient fill overrides the solid and pattern fill.
  583:         if gradient:
  584:             pattern = None
  585:             fill = None
  586: 
  587:         self.drop_lines = {
  588:             "line": line,
  589:             "fill": fill,
  590:             "pattern": pattern,
  591:             "gradient": gradient,
  592:         }
  593: 
  594:     def set_high_low_lines(self, options=None):
  595:         """
  596:         Set properties for the chart high-low lines.
  597: 
  598:         Args:
  599:             options: A dictionary of options.
  600: 
  601:         Returns:
  602:             Nothing.
  603: 
  604:         """
  605:         if options is None:
  606:             options = {}
  607: 
  608:         line = Shape._get_line_properties(options.get("line"))
  609:         fill = Shape._get_fill_properties(options.get("fill"))
  610: 
  611:         # Set the pattern fill properties for the series.
  612:         pattern = Shape._get_pattern_properties(options.get("pattern"))
  613: 
  614:         # Set the gradient fill properties for the series.
  615:         gradient = Shape._get_gradient_properties(options.get("gradient"))
  616: 
  617:         # Pattern fill overrides solid fill.
  618:         if pattern:
  619:             self.fill = None
  620: 
  621:         # Gradient fill overrides the solid and pattern fill.
  622:         if gradient:
  623:             pattern = None
  624:             fill = None
  625: 
  626:         self.hi_low_lines = {
  627:             "line": line,
  628:             "fill": fill,
  629:             "pattern": pattern,
  630:             "gradient": gradient,
  631:         }
  632: 
  633:     def combine(self, chart=None):
  634:         """
  635:         Create a combination chart with a secondary chart.
  636: 
  637:         Args:
  638:             chart: The secondary chart to combine with the primary chart.
  639: 
  640:         Returns:
  641:             Nothing.
  642: 
  643:         """
  644:         if chart is None:
  645:             return
  646: 
  647:         self.combined = chart
  648: 
  649:     ###########################################################################
  650:     #
  651:     # Private API.
  652:     #
  653:     ###########################################################################
  654: 
  655:     def _assemble_xml_file(self):
  656:         # Assemble and write the XML file.
  657: 
  658:         # Write the XML declaration.
  659:         self._xml_declaration()
  660: 
  661:         # Write the c:chartSpace element.
  662:         self._write_chart_space()
  663: 
  664:         # Write the c:lang element.
  665:         self._write_lang()
  666: 
  667:         # Write the c:style element.
  668:         self._write_style()
  669: 
  670:         # Write the c:protection element.
  671:         self._write_protection()
  672: 
  673:         # Write the c:chart element.
  674:         self._write_chart()
  675: 
  676:         # Write the c:spPr element for the chartarea formatting.
  677:         self._write_sp_pr(self.chartarea)
  678: 
  679:         # Write the c:printSettings element.
  680:         if self.embedded:
  681:             self._write_print_settings()
  682: 
  683:         # Close the worksheet tag.
  684:         self._xml_end_tag("c:chartSpace")
  685:         # Close the file.
  686:         self._xml_close()
  687: 
  688:     def _convert_axis_args(self, axis, user_options):
  689:         # Convert user defined axis values into private hash values.
  690:         options = axis["defaults"].copy()
  691:         options.update(user_options)
  692: 
  693:         name, name_formula = self._process_names(
  694:             options.get("name"), options.get("name_formula")
  695:         )
  696: 
  697:         data_id = self._get_data_id(name_formula, options.get("data"))
  698: 
  699:         axis = {
  700:             "defaults": axis["defaults"],
  701:             "name": name,
  702:             "formula": name_formula,
  703:             "data_id": data_id,
  704:             "reverse": options.get("reverse"),
  705:             "min": options.get("min"),
  706:             "max": options.get("max"),
  707:             "minor_unit": options.get("minor_unit"),
  708:             "major_unit": options.get("major_unit"),
  709:             "minor_unit_type": options.get("minor_unit_type"),
  710:             "major_unit_type": options.get("major_unit_type"),
  711:             "display_units": options.get("display_units"),
  712:             "log_base": options.get("log_base"),
  713:             "crossing": options.get("crossing"),
  714:             "position_axis": options.get("position_axis"),
  715:             "position": options.get("position"),
  716:             "label_position": options.get("label_position"),
  717:             "label_align": options.get("label_align"),
  718:             "num_format": options.get("num_format"),
  719:             "num_format_linked": options.get("num_format_linked"),
  720:             "interval_unit": options.get("interval_unit"),
  721:             "interval_tick": options.get("interval_tick"),
  722:             "text_axis": False,
  723:         }
  724: 
  725:         if "visible" in options:
  726:             axis["visible"] = options.get("visible")
  727:         else:
  728:             axis["visible"] = 1
  729: 
  730:         # Convert the display units.
  731:         axis["display_units"] = self._get_display_units(axis["display_units"])
  732:         axis["display_units_visible"] = options.get("display_units_visible", True)
  733: 
  734:         # Map major_gridlines properties.
  735:         if options.get("major_gridlines") and options["major_gridlines"]["visible"]:
  736:             axis["major_gridlines"] = self._get_gridline_properties(
  737:                 options["major_gridlines"]
  738:             )
  739: 
  740:         # Map minor_gridlines properties.
  741:         if options.get("minor_gridlines") and options["minor_gridlines"]["visible"]:
  742:             axis["minor_gridlines"] = self._get_gridline_properties(
  743:                 options["minor_gridlines"]
  744:             )
  745: 
  746:         # Only use the first letter of bottom, top, left or right.
  747:         if axis.get("position"):
  748:             axis["position"] = axis["position"].lower()[0]
  749: 
  750:         # Set the position for a category axis on or between the tick marks.
  751:         if axis.get("position_axis"):
  752:             if axis["position_axis"] == "on_tick":
  753:                 axis["position_axis"] = "midCat"
  754:             elif axis["position_axis"] == "between":
  755:                 # Doesn't need to be modified.
  756:                 pass
  757:             else:
  758:                 # Otherwise use the default value.
  759:                 axis["position_axis"] = None
  760: 
  761:         # Set the category axis as a date axis.
  762:         if options.get("date_axis"):
  763:             self.date_category = True
  764: 
  765:         # Set the category axis as a text axis.
  766:         if options.get("text_axis"):
  767:             self.date_category = False
  768:             axis["text_axis"] = True
  769: 
  770:         # Convert datetime args if required.
  771:         if axis.get("min") and supported_datetime(axis["min"]):
  772:             axis["min"] = datetime_to_excel_datetime(
  773:                 axis["min"], self.date_1904, self.remove_timezone
  774:             )
  775:         if axis.get("max") and supported_datetime(axis["max"]):
  776:             axis["max"] = datetime_to_excel_datetime(
  777:                 axis["max"], self.date_1904, self.remove_timezone
  778:             )
  779:         if axis.get("crossing") and supported_datetime(axis["crossing"]):
  780:             axis["crossing"] = datetime_to_excel_datetime(
  781:                 axis["crossing"], self.date_1904, self.remove_timezone
  782:             )
  783: 
  784:         # Set the font properties if present.
  785:         axis["num_font"] = self._convert_font_args(options.get("num_font"))
  786:         axis["name_font"] = self._convert_font_args(options.get("name_font"))
  787: 
  788:         # Set the axis name layout.
  789:         axis["name_layout"] = self._get_layout_properties(
  790:             options.get("name_layout"), True
  791:         )
  792: 
  793:         # Set the line properties for the axis.
  794:         axis["line"] = Shape._get_line_properties(options.get("line"))
  795: 
  796:         # Set the fill properties for the axis.
  797:         axis["fill"] = Shape._get_fill_properties(options.get("fill"))
  798: 
  799:         # Set the pattern fill properties for the series.
  800:         axis["pattern"] = Shape._get_pattern_properties(options.get("pattern"))
  801: 
  802:         # Set the gradient fill properties for the series.
  803:         axis["gradient"] = Shape._get_gradient_properties(options.get("gradient"))
  804: 
  805:         # Pattern fill overrides solid fill.
  806:         if axis.get("pattern"):
  807:             axis["fill"] = None
  808: 
  809:         # Gradient fill overrides the solid and pattern fill.
  810:         if axis.get("gradient"):
  811:             axis["pattern"] = None
  812:             axis["fill"] = None
  813: 
  814:         # Set the tick marker types.
  815:         axis["minor_tick_mark"] = self._get_tick_type(options.get("minor_tick_mark"))
  816:         axis["major_tick_mark"] = self._get_tick_type(options.get("major_tick_mark"))
  817: 
  818:         return axis
  819: 
  820:     def _convert_font_args(self, options):
  821:         # Convert user defined font values into private dict values.
  822:         if not options:
  823:             return
  824: 
  825:         font = {
  826:             "name": options.get("name"),
  827:             "color": options.get("color"),
  828:             "size": options.get("size"),
  829:             "bold": options.get("bold"),
  830:             "italic": options.get("italic"),
  831:             "underline": options.get("underline"),
  832:             "pitch_family": options.get("pitch_family"),
  833:             "charset": options.get("charset"),
  834:             "baseline": options.get("baseline", 0),
  835:             "rotation": options.get("rotation"),
  836:         }
  837: 
  838:         # Convert font size units.
  839:         if font["size"]:
  840:             font["size"] = int(font["size"] * 100)
  841: 
  842:         # Convert rotation into 60,000ths of a degree.
  843:         if font["rotation"]:
  844:             font["rotation"] = 60000 * int(font["rotation"])
  845: 
  846:         return font
  847: 
  848:     def _list_to_formula(self, data):
  849:         # Convert and list of row col values to a range formula.
  850: 
  851:         # If it isn't an array ref it is probably a formula already.
  852:         if not isinstance(data, list):
  853:             # Check for unquoted sheetnames.
  854:             if data and " " in data and "'" not in data and self.warn_sheetname:
  855:                 warn(
  856:                     "Sheetname in '%s' contains spaces but isn't quoted. "
  857:                     "This may cause errors in Excel." % data
  858:                 )
  859:             return data
  860: 
  861:         formula = xl_range_formula(*data)
  862: 
  863:         return formula
  864: 
  865:     def _process_names(self, name, name_formula):
  866:         # Switch name and name_formula parameters if required.
  867: 
  868:         if name is not None:
  869:             if isinstance(name, list):
  870:                 # Convert a list of values into a name formula.
  871:                 cell = xl_rowcol_to_cell(name[1], name[2], True, True)
  872:                 name_formula = quote_sheetname(name[0]) + "!" + cell
  873:                 name = ""
  874:             elif re.match(r"^=?[^!]+!\$?[A-Z]+\$?\d+", name):
  875:                 # Name looks like a formula, use it to set name_formula.
  876:                 name_formula = name
  877:                 name = ""
  878: 
  879:         return name, name_formula
  880: 
  881:     def _get_data_type(self, data):
  882:         # Find the overall type of the data associated with a series.
  883: 
  884:         # Check for no data in the series.
  885:         if data is None or len(data) == 0:
  886:             return "none"
  887: 
  888:         if isinstance(data[0], list):
  889:             return "multi_str"
  890: 
  891:         # Determine if data is numeric or strings.
  892:         for token in data:
  893:             if token is None:
  894:                 continue
  895: 
  896:             # Check for strings that would evaluate to float like
  897:             # '1.1_1' of ' 1'.
  898:             if isinstance(token, str) and re.search("[_ ]", token):
  899:                 # Assume entire data series is string data.
  900:                 return "str"
  901: 
  902:             try:
  903:                 float(token)
  904:             except ValueError:
  905:                 # Not a number. Assume entire data series is string data.
  906:                 return "str"
  907: 
  908:         # The series data was all numeric.
  909:         return "num"
  910: 
  911:     def _get_data_id(self, formula, data):
  912:         # Assign an id to a each unique series formula or title/axis formula.
  913:         # Repeated formulas such as for categories get the same id. If the
  914:         # series or title has user specified data associated with it then
  915:         # that is also stored. This data is used to populate cached Excel
  916:         # data when creating a chart. If there is no user defined data then
  917:         # it will be populated by the parent Workbook._add_chart_data().
  918: 
  919:         # Ignore series without a range formula.
  920:         if not formula:
  921:             return
  922: 
  923:         # Strip the leading '=' from the formula.
  924:         if formula.startswith("="):
  925:             formula = formula.lstrip("=")
  926: 
  927:         # Store the data id in a hash keyed by the formula and store the data
  928:         # in a separate array with the same id.
  929:         if formula not in self.formula_ids:
  930:             # Haven't seen this formula before.
  931:             formula_id = len(self.formula_data)
  932: 
  933:             self.formula_data.append(data)
  934:             self.formula_ids[formula] = formula_id
  935:         else:
  936:             # Formula already seen. Return existing id.
  937:             formula_id = self.formula_ids[formula]
  938: 
  939:             # Store user defined data if it isn't already there.
  940:             if self.formula_data[formula_id] is None:
  941:                 self.formula_data[formula_id] = data
  942: 
  943:         return formula_id
  944: 
  945:     def _get_marker_properties(self, marker):
  946:         # Convert user marker properties to the structure required internally.
  947: 
  948:         if not marker:
  949:             return
  950: 
  951:         # Copy the user defined properties since they will be modified.
  952:         marker = copy.deepcopy(marker)
  953: 
  954:         types = {
  955:             "automatic": "automatic",
  956:             "none": "none",
  957:             "square": "square",
  958:             "diamond": "diamond",
  959:             "triangle": "triangle",
  960:             "x": "x",
  961:             "star": "star",
  962:             "dot": "dot",
  963:             "short_dash": "dot",
  964:             "dash": "dash",
  965:             "long_dash": "dash",
  966:             "circle": "circle",
  967:             "plus": "plus",
  968:             "picture": "picture",
  969:         }
  970: 
  971:         # Check for valid types.
  972:         marker_type = marker.get("type")
  973: 
  974:         if marker_type is not None:
  975:             if marker_type in types:
  976:                 marker["type"] = types[marker_type]
  977:             else:
  978:                 warn("Unknown marker type '%s" % marker_type)
  979:                 return
  980: 
  981:         # Set the line properties for the marker.
  982:         line = Shape._get_line_properties(marker.get("line"))
  983: 
  984:         # Allow 'border' as a synonym for 'line'.
  985:         if "border" in marker:
  986:             line = Shape._get_line_properties(marker["border"])
  987: 
  988:         # Set the fill properties for the marker.
  989:         fill = Shape._get_fill_properties(marker.get("fill"))
  990: 
  991:         # Set the pattern fill properties for the series.
  992:         pattern = Shape._get_pattern_properties(marker.get("pattern"))
  993: 
  994:         # Set the gradient fill properties for the series.
  995:         gradient = Shape._get_gradient_properties(marker.get("gradient"))
  996: 
  997:         # Pattern fill overrides solid fill.
  998:         if pattern:
  999:             self.fill = None
 1000: 
 1001:         # Gradient fill overrides the solid and pattern fill.
 1002:         if gradient:
 1003:             pattern = None
 1004:             fill = None
 1005: 
 1006:         marker["line"] = line
 1007:         marker["fill"] = fill
 1008:         marker["pattern"] = pattern
 1009:         marker["gradient"] = gradient
 1010: 
 1011:         return marker
 1012: 
 1013:     def _get_trendline_properties(self, trendline):
 1014:         # Convert user trendline properties to structure required internally.
 1015: 
 1016:         if not trendline:
 1017:             return
 1018: 
 1019:         # Copy the user defined properties since they will be modified.
 1020:         trendline = copy.deepcopy(trendline)
 1021: 
 1022:         types = {
 1023:             "exponential": "exp",
 1024:             "linear": "linear",
 1025:             "log": "log",
 1026:             "moving_average": "movingAvg",
 1027:             "polynomial": "poly",
 1028:             "power": "power",
 1029:         }
 1030: 
 1031:         # Check the trendline type.
 1032:         trend_type = trendline.get("type")
 1033: 
 1034:         if trend_type in types:
 1035:             trendline["type"] = types[trend_type]
 1036:         else:
 1037:             warn("Unknown trendline type '%s'" % trend_type)
 1038:             return
 1039: 
 1040:         # Set the line properties for the trendline.
 1041:         line = Shape._get_line_properties(trendline.get("line"))
 1042: 
 1043:         # Allow 'border' as a synonym for 'line'.
 1044:         if "border" in trendline:
 1045:             line = Shape._get_line_properties(trendline["border"])
 1046: 
 1047:         # Set the fill properties for the trendline.
 1048:         fill = Shape._get_fill_properties(trendline.get("fill"))
 1049: 
 1050:         # Set the pattern fill properties for the trendline.
 1051:         pattern = Shape._get_pattern_properties(trendline.get("pattern"))
 1052: 
 1053:         # Set the gradient fill properties for the trendline.
 1054:         gradient = Shape._get_gradient_properties(trendline.get("gradient"))
 1055: 
 1056:         # Set the format properties for the trendline label.
 1057:         label = self._get_trendline_label_properties(trendline.get("label"))
 1058: 
 1059:         # Pattern fill overrides solid fill.
 1060:         if pattern:
 1061:             self.fill = None
 1062: 
 1063:         # Gradient fill overrides the solid and pattern fill.
 1064:         if gradient:
 1065:             pattern = None
 1066:             fill = None
 1067: 
 1068:         trendline["line"] = line
 1069:         trendline["fill"] = fill
 1070:         trendline["pattern"] = pattern
 1071:         trendline["gradient"] = gradient
 1072:         trendline["label"] = label
 1073: 
 1074:         return trendline
 1075: 
 1076:     def _get_trendline_label_properties(self, label):
 1077:         # Convert user trendline properties to structure required internally.
 1078: 
 1079:         if not label:
 1080:             return {}
 1081: 
 1082:         # Copy the user defined properties since they will be modified.
 1083:         label = copy.deepcopy(label)
 1084: 
 1085:         # Set the font properties if present.
 1086:         font = self._convert_font_args(label.get("font"))
 1087: 
 1088:         # Set the line properties for the label.
 1089:         line = Shape._get_line_properties(label.get("line"))
 1090: 
 1091:         # Allow 'border' as a synonym for 'line'.
 1092:         if "border" in label:
 1093:             line = Shape._get_line_properties(label["border"])
 1094: 
 1095:         # Set the fill properties for the label.
 1096:         fill = Shape._get_fill_properties(label.get("fill"))
 1097: 
 1098:         # Set the pattern fill properties for the label.
 1099:         pattern = Shape._get_pattern_properties(label.get("pattern"))
 1100: 
 1101:         # Set the gradient fill properties for the label.
 1102:         gradient = Shape._get_gradient_properties(label.get("gradient"))
 1103: 
 1104:         # Pattern fill overrides solid fill.
 1105:         if pattern:
 1106:             self.fill = None
 1107: 
 1108:         # Gradient fill overrides the solid and pattern fill.
 1109:         if gradient:
 1110:             pattern = None
 1111:             fill = None
 1112: 
 1113:         label["font"] = font
 1114:         label["line"] = line
 1115:         label["fill"] = fill
 1116:         label["pattern"] = pattern
 1117:         label["gradient"] = gradient
 1118: 
 1119:         return label
 1120: 
 1121:     def _get_error_bars_props(self, options):
 1122:         # Convert user error bars properties to structure required internally.
 1123:         if not options:
 1124:             return
 1125: 
 1126:         # Default values.
 1127:         error_bars = {"type": "fixedVal", "value": 1, "endcap": 1, "direction": "both"}
 1128: 
 1129:         types = {
 1130:             "fixed": "fixedVal",
 1131:             "percentage": "percentage",
 1132:             "standard_deviation": "stdDev",
 1133:             "standard_error": "stdErr",
 1134:             "custom": "cust",
 1135:         }
 1136: 
 1137:         # Check the error bars type.
 1138:         error_type = options["type"]
 1139: 
 1140:         if error_type in types:
 1141:             error_bars["type"] = types[error_type]
 1142:         else:
 1143:             warn("Unknown error bars type '%s" % error_type)
 1144:             return
 1145: 
 1146:         # Set the value for error types that require it.
 1147:         if "value" in options:
 1148:             error_bars["value"] = options["value"]
 1149: 
 1150:         # Set the end-cap style.
 1151:         if "end_style" in options:
 1152:             error_bars["endcap"] = options["end_style"]
 1153: 
 1154:         # Set the error bar direction.
 1155:         if "direction" in options:
 1156:             if options["direction"] == "minus":
 1157:                 error_bars["direction"] = "minus"
 1158:             elif options["direction"] == "plus":
 1159:                 error_bars["direction"] = "plus"
 1160:             else:
 1161:                 # Default to 'both'.
 1162:                 pass
 1163: 
 1164:         # Set any custom values.
 1165:         error_bars["plus_values"] = options.get("plus_values")
 1166:         error_bars["minus_values"] = options.get("minus_values")
 1167:         error_bars["plus_data"] = options.get("plus_data")
 1168:         error_bars["minus_data"] = options.get("minus_data")
 1169: 
 1170:         # Set the line properties for the error bars.
 1171:         error_bars["line"] = Shape._get_line_properties(options.get("line"))
 1172: 
 1173:         return error_bars
 1174: 
 1175:     def _get_gridline_properties(self, options):
 1176:         # Convert user gridline properties to structure required internally.
 1177: 
 1178:         # Set the visible property for the gridline.
 1179:         gridline = {"visible": options.get("visible")}
 1180: 
 1181:         # Set the line properties for the gridline.
 1182:         gridline["line"] = Shape._get_line_properties(options.get("line"))
 1183: 
 1184:         return gridline
 1185: 
 1186:     def _get_labels_properties(self, labels):
 1187:         # Convert user labels properties to the structure required internally.
 1188: 
 1189:         if not labels:
 1190:             return None
 1191: 
 1192:         # Copy the user defined properties since they will be modified.
 1193:         labels = copy.deepcopy(labels)
 1194: 
 1195:         # Map user defined label positions to Excel positions.
 1196:         position = labels.get("position")
 1197: 
 1198:         if position:
 1199:             if position in self.label_positions:
 1200:                 if position == self.label_position_default:
 1201:                     labels["position"] = None
 1202:                 else:
 1203:                     labels["position"] = self.label_positions[position]
 1204:             else:
 1205:                 warn("Unsupported label position '%s' for this chart type" % position)
 1206:                 return
 1207: 
 1208:         # Map the user defined label separator to the Excel separator.
 1209:         separator = labels.get("separator")
 1210:         separators = {
 1211:             ",": ", ",
 1212:             ";": "; ",
 1213:             ".": ". ",
 1214:             "\n": "\n",
 1215:             " ": " ",
 1216:         }
 1217: 
 1218:         if separator:
 1219:             if separator in separators:
 1220:                 labels["separator"] = separators[separator]
 1221:             else:
 1222:                 warn("Unsupported label separator")
 1223:                 return
 1224: 
 1225:         # Set the font properties if present.
 1226:         labels["font"] = self._convert_font_args(labels.get("font"))
 1227: 
 1228:         # Set the line properties for the labels.
 1229:         line = Shape._get_line_properties(labels.get("line"))
 1230: 
 1231:         # Allow 'border' as a synonym for 'line'.
 1232:         if "border" in labels:
 1233:             line = Shape._get_line_properties(labels["border"])
 1234: 
 1235:         # Set the fill properties for the labels.
 1236:         fill = Shape._get_fill_properties(labels.get("fill"))
 1237: 
 1238:         # Set the pattern fill properties for the labels.
 1239:         pattern = Shape._get_pattern_properties(labels.get("pattern"))
 1240: 
 1241:         # Set the gradient fill properties for the labels.
 1242:         gradient = Shape._get_gradient_properties(labels.get("gradient"))
 1243: 
 1244:         # Pattern fill overrides solid fill.
 1245:         if pattern:
 1246:             self.fill = None
 1247: 
 1248:         # Gradient fill overrides the solid and pattern fill.
 1249:         if gradient:
 1250:             pattern = None
 1251:             fill = None
 1252: 
 1253:         labels["line"] = line
 1254:         labels["fill"] = fill
 1255:         labels["pattern"] = pattern
 1256:         labels["gradient"] = gradient
 1257: 
 1258:         if labels.get("custom"):
 1259:             for label in labels["custom"]:
 1260:                 if label is None:
 1261:                     continue
 1262: 
 1263:                 value = label.get("value")
 1264:                 if value and re.match(r"^=?[^!]+!\$?[A-Z]+\$?\d+", str(value)):
 1265:                     label["formula"] = value
 1266: 
 1267:                 formula = label.get("formula")
 1268:                 if formula and formula.startswith("="):
 1269:                     label["formula"] = formula.lstrip("=")
 1270: 
 1271:                 data_id = self._get_data_id(formula, label.get("data"))
 1272:                 label["data_id"] = data_id
 1273: 
 1274:                 label["font"] = self._convert_font_args(label.get("font"))
 1275: 
 1276:                 # Set the line properties for the label.
 1277:                 line = Shape._get_line_properties(label.get("line"))
 1278: 
 1279:                 # Allow 'border' as a synonym for 'line'.
 1280:                 if "border" in label:
 1281:                     line = Shape._get_line_properties(label["border"])
 1282: 
 1283:                 # Set the fill properties for the label.
 1284:                 fill = Shape._get_fill_properties(label.get("fill"))
 1285: 
 1286:                 # Set the pattern fill properties for the label.
 1287:                 pattern = Shape._get_pattern_properties(label.get("pattern"))
 1288: 
 1289:                 # Set the gradient fill properties for the label.
 1290:                 gradient = Shape._get_gradient_properties(label.get("gradient"))
 1291: 
 1292:                 # Pattern fill overrides solid fill.
 1293:                 if pattern:
 1294:                     self.fill = None
 1295: 
 1296:                 # Gradient fill overrides the solid and pattern fill.
 1297:                 if gradient:
 1298:                     pattern = None
 1299:                     fill = None
 1300: 
 1301:                 label["line"] = line
 1302:                 label["fill"] = fill
 1303:                 label["pattern"] = pattern
 1304:                 label["gradient"] = gradient
 1305: 
 1306:         return labels
 1307: 
 1308:     def _get_area_properties(self, options):
 1309:         # Convert user area properties to the structure required internally.
 1310:         area = {}
 1311: 
 1312:         # Set the line properties for the chartarea.
 1313:         line = Shape._get_line_properties(options.get("line"))
 1314: 
 1315:         # Allow 'border' as a synonym for 'line'.
 1316:         if options.get("border"):
 1317:             line = Shape._get_line_properties(options["border"])
 1318: 
 1319:         # Set the fill properties for the chartarea.
 1320:         fill = Shape._get_fill_properties(options.get("fill"))
 1321: 
 1322:         # Set the pattern fill properties for the series.
 1323:         pattern = Shape._get_pattern_properties(options.get("pattern"))
 1324: 
 1325:         # Set the gradient fill properties for the series.
 1326:         gradient = Shape._get_gradient_properties(options.get("gradient"))
 1327: 
 1328:         # Pattern fill overrides solid fill.
 1329:         if pattern:
 1330:             self.fill = None
 1331: 
 1332:         # Gradient fill overrides the solid and pattern fill.
 1333:         if gradient:
 1334:             pattern = None
 1335:             fill = None
 1336: 
 1337:         # Set the plotarea layout.
 1338:         layout = self._get_layout_properties(options.get("layout"), False)
 1339: 
 1340:         area["line"] = line
 1341:         area["fill"] = fill
 1342:         area["pattern"] = pattern
 1343:         area["layout"] = layout
 1344:         area["gradient"] = gradient
 1345: 
 1346:         return area
 1347: 
 1348:     def _get_legend_properties(self, options=None):
 1349:         # Convert user legend properties to the structure required internally.
 1350:         legend = {}
 1351: 
 1352:         if options is None:
 1353:             options = {}
 1354: 
 1355:         legend["position"] = options.get("position", "right")
 1356:         legend["delete_series"] = options.get("delete_series")
 1357:         legend["font"] = self._convert_font_args(options.get("font"))
 1358:         legend["layout"] = self._get_layout_properties(options.get("layout"), False)
 1359: 
 1360:         # Turn off the legend.
 1361:         if options.get("none"):
 1362:             legend["position"] = "none"
 1363: 
 1364:         # Set the line properties for the legend.
 1365:         line = Shape._get_line_properties(options.get("line"))
 1366: 
 1367:         # Allow 'border' as a synonym for 'line'.
 1368:         if options.get("border"):
 1369:             line = Shape._get_line_properties(options["border"])
 1370: 
 1371:         # Set the fill properties for the legend.
 1372:         fill = Shape._get_fill_properties(options.get("fill"))
 1373: 
 1374:         # Set the pattern fill properties for the series.
 1375:         pattern = Shape._get_pattern_properties(options.get("pattern"))
 1376: 
 1377:         # Set the gradient fill properties for the series.
 1378:         gradient = Shape._get_gradient_properties(options.get("gradient"))
 1379: 
 1380:         # Pattern fill overrides solid fill.
 1381:         if pattern:
 1382:             self.fill = None
 1383: 
 1384:         # Gradient fill overrides the solid and pattern fill.
 1385:         if gradient:
 1386:             pattern = None
 1387:             fill = None
 1388: 
 1389:         # Set the legend layout.
 1390:         layout = self._get_layout_properties(options.get("layout"), False)
 1391: 
 1392:         legend["line"] = line
 1393:         legend["fill"] = fill
 1394:         legend["pattern"] = pattern
 1395:         legend["layout"] = layout
 1396:         legend["gradient"] = gradient
 1397: 
 1398:         return legend
 1399: 
 1400:     def _get_layout_properties(self, args, is_text):
 1401:         # Convert user defined layout properties to format used internally.
 1402:         layout = {}
 1403: 
 1404:         if not args:
 1405:             return
 1406: 
 1407:         if is_text:
 1408:             properties = ("x", "y")
 1409:         else:
 1410:             properties = ("x", "y", "width", "height")
 1411: 
 1412:         # Check for valid properties.
 1413:         for key in args.keys():
 1414:             if key not in properties:
 1415:                 warn("Property '%s' allowed not in layout options" % key)
 1416:                 return
 1417: 
 1418:         # Set the layout properties.
 1419:         for prop in properties:
 1420:             if prop not in args.keys():
 1421:                 warn("Property '%s' must be specified in layout options" % prop)
 1422:                 return
 1423: 
 1424:             value = args[prop]
 1425: 
 1426:             try:
 1427:                 float(value)
 1428:             except ValueError:
 1429:                 warn(
 1430:                     "Property '%s' value '%s' must be numeric in layout" % (prop, value)
 1431:                 )
 1432:                 return
 1433: 
 1434:             if value < 0 or value > 1:
 1435:                 warn(
 1436:                     "Property '%s' value '%s' must be in range "
 1437:                     "0 < x <= 1 in layout options" % (prop, value)
 1438:                 )
 1439:                 return
 1440: 
 1441:             # Convert to the format used by Excel for easier testing
 1442:             layout[prop] = "%.17g" % value
 1443: 
 1444:         return layout
 1445: 
 1446:     def _get_points_properties(self, user_points):
 1447:         # Convert user points properties to structure required internally.
 1448:         points = []
 1449: 
 1450:         if not user_points:
 1451:             return
 1452: 
 1453:         for user_point in user_points:
 1454:             point = {}
 1455: 
 1456:             if user_point is not None:
 1457:                 # Set the line properties for the point.
 1458:                 line = Shape._get_line_properties(user_point.get("line"))
 1459: 
 1460:                 # Allow 'border' as a synonym for 'line'.
 1461:                 if "border" in user_point:
 1462:                     line = Shape._get_line_properties(user_point["border"])
 1463: 
 1464:                 # Set the fill properties for the chartarea.
 1465:                 fill = Shape._get_fill_properties(user_point.get("fill"))
 1466: 
 1467:                 # Set the pattern fill properties for the series.
 1468:                 pattern = Shape._get_pattern_properties(user_point.get("pattern"))
 1469: 
 1470:                 # Set the gradient fill properties for the series.
 1471:                 gradient = Shape._get_gradient_properties(user_point.get("gradient"))
 1472: 
 1473:                 # Pattern fill overrides solid fill.
 1474:                 if pattern:
 1475:                     self.fill = None
 1476: 
 1477:                 # Gradient fill overrides the solid and pattern fill.
 1478:                 if gradient:
 1479:                     pattern = None
 1480:                     fill = None
 1481: 
 1482:                 point["line"] = line
 1483:                 point["fill"] = fill
 1484:                 point["pattern"] = pattern
 1485:                 point["gradient"] = gradient
 1486: 
 1487:             points.append(point)
 1488: 
 1489:         return points
 1490: 
 1491:     def _has_fill_formatting(self, element):
 1492:         # Check if a chart element has line, fill or gradient formatting.
 1493:         has_fill = False
 1494:         has_line = False
 1495:         has_pattern = element.get("pattern")
 1496:         has_gradient = element.get("gradient")
 1497: 
 1498:         if element.get("fill") and element["fill"]["defined"]:
 1499:             has_fill = True
 1500: 
 1501:         if element.get("line") and element["line"]["defined"]:
 1502:             has_line = True
 1503: 
 1504:         if not has_fill and not has_line and not has_pattern and not has_gradient:
 1505:             return False
 1506:         else:
 1507:             return True
 1508: 
 1509:     def _get_display_units(self, display_units):
 1510:         # Convert user defined display units to internal units.
 1511:         if not display_units:
 1512:             return
 1513: 
 1514:         types = {
 1515:             "hundreds": "hundreds",
 1516:             "thousands": "thousands",
 1517:             "ten_thousands": "tenThousands",
 1518:             "hundred_thousands": "hundredThousands",
 1519:             "millions": "millions",
 1520:             "ten_millions": "tenMillions",
 1521:             "hundred_millions": "hundredMillions",
 1522:             "billions": "billions",
 1523:             "trillions": "trillions",
 1524:         }
 1525: 
 1526:         if display_units in types:
 1527:             display_units = types[display_units]
 1528:         else:
 1529:             warn("Unknown display_units type '%s'" % display_units)
 1530:             return
 1531: 
 1532:         return display_units
 1533: 
 1534:     def _get_tick_type(self, tick_type):
 1535:         # Convert user defined display units to internal units.
 1536:         if not tick_type:
 1537:             return
 1538: 
 1539:         types = {
 1540:             "outside": "out",
 1541:             "inside": "in",
 1542:             "none": "none",
 1543:             "cross": "cross",
 1544:         }
 1545: 
 1546:         if tick_type in types:
 1547:             tick_type = types[tick_type]
 1548:         else:
 1549:             warn("Unknown tick_type  '%s'" % tick_type)
 1550:             return
 1551: 
 1552:         return tick_type
 1553: 
 1554:     def _get_primary_axes_series(self):
 1555:         # Returns series which use the primary axes.
 1556:         primary_axes_series = []
 1557: 
 1558:         for series in self.series:
 1559:             if not series["y2_axis"]:
 1560:                 primary_axes_series.append(series)
 1561: 
 1562:         return primary_axes_series
 1563: 
 1564:     def _get_secondary_axes_series(self):
 1565:         # Returns series which use the secondary axes.
 1566:         secondary_axes_series = []
 1567: 
 1568:         for series in self.series:
 1569:             if series["y2_axis"]:
 1570:                 secondary_axes_series.append(series)
 1571: 
 1572:         return secondary_axes_series
 1573: 
 1574:     def _add_axis_ids(self, args):
 1575:         # Add unique ids for primary or secondary axes
 1576:         chart_id = 5001 + int(self.id)
 1577:         axis_count = 1 + len(self.axis2_ids) + len(self.axis_ids)
 1578: 
 1579:         id1 = "%04d%04d" % (chart_id, axis_count)
 1580:         id2 = "%04d%04d" % (chart_id, axis_count + 1)
 1581: 
 1582:         if args["primary_axes"]:
 1583:             self.axis_ids.append(id1)
 1584:             self.axis_ids.append(id2)
 1585: 
 1586:         if not args["primary_axes"]:
 1587:             self.axis2_ids.append(id1)
 1588:             self.axis2_ids.append(id2)
 1589: 
 1590:     def _set_default_properties(self):
 1591:         # Setup the default properties for a chart.
 1592: 
 1593:         self.x_axis["defaults"] = {
 1594:             "num_format": "General",
 1595:             "major_gridlines": {"visible": 0},
 1596:         }
 1597: 
 1598:         self.y_axis["defaults"] = {
 1599:             "num_format": "General",
 1600:             "major_gridlines": {"visible": 1},
 1601:         }
 1602: 
 1603:         self.x2_axis["defaults"] = {
 1604:             "num_format": "General",
 1605:             "label_position": "none",
 1606:             "crossing": "max",
 1607:             "visible": 0,
 1608:         }
 1609: 
 1610:         self.y2_axis["defaults"] = {
 1611:             "num_format": "General",
 1612:             "major_gridlines": {"visible": 0},
 1613:             "position": "right",
 1614:             "visible": 1,
 1615:         }
 1616: 
 1617:         self.set_x_axis({})
 1618:         self.set_y_axis({})
 1619: 
 1620:         self.set_x2_axis({})
 1621:         self.set_y2_axis({})
 1622: 
 1623:     ###########################################################################
 1624:     #
 1625:     # XML methods.
 1626:     #
 1627:     ###########################################################################
 1628: 
 1629:     def _write_chart_space(self):
 1630:         # Write the <c:chartSpace> element.
 1631:         schema = "http://schemas.openxmlformats.org/"
 1632:         xmlns_c = schema + "drawingml/2006/chart"
 1633:         xmlns_a = schema + "drawingml/2006/main"
 1634:         xmlns_r = schema + "officeDocument/2006/relationships"
 1635: 
 1636:         attributes = [
 1637:             ("xmlns:c", xmlns_c),
 1638:             ("xmlns:a", xmlns_a),
 1639:             ("xmlns:r", xmlns_r),
 1640:         ]
 1641: 
 1642:         self._xml_start_tag("c:chartSpace", attributes)
 1643: 
 1644:     def _write_lang(self):
 1645:         # Write the <c:lang> element.
 1646:         val = "en-US"
 1647: 
 1648:         attributes = [("val", val)]
 1649: 
 1650:         self._xml_empty_tag("c:lang", attributes)
 1651: 
 1652:     def _write_style(self):
 1653:         # Write the <c:style> element.
 1654:         style_id = self.style_id
 1655: 
 1656:         # Don't write an element for the default style, 2.
 1657:         if style_id == 2:
 1658:             return
 1659: 
 1660:         attributes = [("val", style_id)]
 1661: 
 1662:         self._xml_empty_tag("c:style", attributes)
 1663: 
 1664:     def _write_chart(self):
 1665:         # Write the <c:chart> element.
 1666:         self._xml_start_tag("c:chart")
 1667: 
 1668:         if self.title_none:
 1669:             # Turn off the title.
 1670:             self._write_c_auto_title_deleted()
 1671:         else:
 1672:             # Write the chart title elements.
 1673:             if self.title_formula is not None:
 1674:                 self._write_title_formula(
 1675:                     self.title_formula,
 1676:                     self.title_data_id,
 1677:                     None,
 1678:                     self.title_font,
 1679:                     self.title_layout,
 1680:                     self.title_overlay,
 1681:                 )
 1682:             elif self.title_name is not None:
 1683:                 self._write_title_rich(
 1684:                     self.title_name,
 1685:                     None,
 1686:                     self.title_font,
 1687:                     self.title_layout,
 1688:                     self.title_overlay,
 1689:                 )
 1690: 
 1691:         # Write the c:plotArea element.
 1692:         self._write_plot_area()
 1693: 
 1694:         # Write the c:legend element.
 1695:         self._write_legend()
 1696: 
 1697:         # Write the c:plotVisOnly element.
 1698:         self._write_plot_vis_only()
 1699: 
 1700:         # Write the c:dispBlanksAs element.
 1701:         self._write_disp_blanks_as()
 1702: 
 1703:         # Write the c:extLst element.
 1704:         if self.show_na_as_empty:
 1705:             self._write_c_ext_lst_display_na()
 1706: 
 1707:         self._xml_end_tag("c:chart")
 1708: 
 1709:     def _write_disp_blanks_as(self):
 1710:         # Write the <c:dispBlanksAs> element.
 1711:         val = self.show_blanks
 1712: 
 1713:         # Ignore the default value.
 1714:         if val == "gap":
 1715:             return
 1716: 
 1717:         attributes = [("val", val)]
 1718: 
 1719:         self._xml_empty_tag("c:dispBlanksAs", attributes)
 1720: 
 1721:     def _write_plot_area(self):
 1722:         # Write the <c:plotArea> element.
 1723:         self._xml_start_tag("c:plotArea")
 1724: 
 1725:         # Write the c:layout element.
 1726:         self._write_layout(self.plotarea.get("layout"), "plot")
 1727: 
 1728:         # Write  subclass chart type elements for primary and secondary axes.
 1729:         self._write_chart_type({"primary_axes": True})
 1730:         self._write_chart_type({"primary_axes": False})
 1731: 
 1732:         # Configure a combined chart if present.
 1733:         second_chart = self.combined
 1734:         if second_chart:
 1735:             # Secondary axis has unique id otherwise use same as primary.
 1736:             if second_chart.is_secondary:
 1737:                 second_chart.id = 1000 + self.id
 1738:             else:
 1739:                 second_chart.id = self.id
 1740: 
 1741:             # Share the same filehandle for writing.
 1742:             second_chart.fh = self.fh
 1743: 
 1744:             # Share series index with primary chart.
 1745:             second_chart.series_index = self.series_index
 1746: 
 1747:             # Write the subclass chart type elements for combined chart.
 1748:             second_chart._write_chart_type({"primary_axes": True})
 1749:             second_chart._write_chart_type({"primary_axes": False})
 1750: 
 1751:         # Write the category and value elements for the primary axes.
 1752:         args = {"x_axis": self.x_axis, "y_axis": self.y_axis, "axis_ids": self.axis_ids}
 1753: 
 1754:         if self.date_category:
 1755:             self._write_date_axis(args)
 1756:         else:
 1757:             self._write_cat_axis(args)
 1758: 
 1759:         self._write_val_axis(args)
 1760: 
 1761:         # Write the category and value elements for the secondary axes.
 1762:         args = {
 1763:             "x_axis": self.x2_axis,
 1764:             "y_axis": self.y2_axis,
 1765:             "axis_ids": self.axis2_ids,
 1766:         }
 1767: 
 1768:         self._write_val_axis(args)
 1769: 
 1770:         # Write the secondary axis for the secondary chart.
 1771:         if second_chart and second_chart.is_secondary:
 1772:             args = {
 1773:                 "x_axis": second_chart.x2_axis,
 1774:                 "y_axis": second_chart.y2_axis,
 1775:                 "axis_ids": second_chart.axis2_ids,
 1776:             }
 1777: 
 1778:             second_chart._write_val_axis(args)
 1779: 
 1780:         if self.date_category:
 1781:             self._write_date_axis(args)
 1782:         else:
 1783:             self._write_cat_axis(args)
 1784: 
 1785:         # Write the c:dTable element.
 1786:         self._write_d_table()
 1787: 
 1788:         # Write the c:spPr element for the plotarea formatting.
 1789:         self._write_sp_pr(self.plotarea)
 1790: 
 1791:         self._xml_end_tag("c:plotArea")
 1792: 
 1793:     def _write_layout(self, layout, layout_type):
 1794:         # Write the <c:layout> element.
 1795: 
 1796:         if not layout:
 1797:             # Automatic layout.
 1798:             self._xml_empty_tag("c:layout")
 1799:         else:
 1800:             # User defined manual layout.
 1801:             self._xml_start_tag("c:layout")
 1802:             self._write_manual_layout(layout, layout_type)
 1803:             self._xml_end_tag("c:layout")
 1804: 
 1805:     def _write_manual_layout(self, layout, layout_type):
 1806:         # Write the <c:manualLayout> element.
 1807:         self._xml_start_tag("c:manualLayout")
 1808: 
 1809:         # Plotarea has a layoutTarget element.
 1810:         if layout_type == "plot":
 1811:             self._xml_empty_tag("c:layoutTarget", [("val", "inner")])
 1812: 
 1813:         # Set the x, y positions.
 1814:         self._xml_empty_tag("c:xMode", [("val", "edge")])
 1815:         self._xml_empty_tag("c:yMode", [("val", "edge")])
 1816:         self._xml_empty_tag("c:x", [("val", layout["x"])])
 1817:         self._xml_empty_tag("c:y", [("val", layout["y"])])
 1818: 
 1819:         # For plotarea and legend set the width and height.
 1820:         if layout_type != "text":
 1821:             self._xml_empty_tag("c:w", [("val", layout["width"])])
 1822:             self._xml_empty_tag("c:h", [("val", layout["height"])])
 1823: 
 1824:         self._xml_end_tag("c:manualLayout")
 1825: 
 1826:     def _write_chart_type(self, options):
 1827:         # Write the chart type element. This method should be overridden
 1828:         # by the subclasses.
 1829:         return
 1830: 
 1831:     def _write_grouping(self, val):
 1832:         # Write the <c:grouping> element.
 1833:         attributes = [("val", val)]
 1834: 
 1835:         self._xml_empty_tag("c:grouping", attributes)
 1836: 
 1837:     def _write_series(self, series):
 1838:         # Write the series elements.
 1839:         self._write_ser(series)
 1840: 
 1841:     def _write_ser(self, series):
 1842:         # Write the <c:ser> element.
 1843:         index = self.series_index
 1844:         self.series_index += 1
 1845: 
 1846:         self._xml_start_tag("c:ser")
 1847: 
 1848:         # Write the c:idx element.
 1849:         self._write_idx(index)
 1850: 
 1851:         # Write the c:order element.
 1852:         self._write_order(index)
 1853: 
 1854:         # Write the series name.
 1855:         self._write_series_name(series)
 1856: 
 1857:         # Write the c:spPr element.
 1858:         self._write_sp_pr(series)
 1859: 
 1860:         # Write the c:marker element.
 1861:         self._write_marker(series["marker"])
 1862: 
 1863:         # Write the c:invertIfNegative element.
 1864:         self._write_c_invert_if_negative(series["invert_if_neg"])
 1865: 
 1866:         # Write the c:dPt element.
 1867:         self._write_d_pt(series["points"])
 1868: 
 1869:         # Write the c:dLbls element.
 1870:         self._write_d_lbls(series["labels"])
 1871: 
 1872:         # Write the c:trendline element.
 1873:         self._write_trendline(series["trendline"])
 1874: 
 1875:         # Write the c:errBars element.
 1876:         self._write_error_bars(series["error_bars"])
 1877: 
 1878:         # Write the c:cat element.
 1879:         self._write_cat(series)
 1880: 
 1881:         # Write the c:val element.
 1882:         self._write_val(series)
 1883: 
 1884:         # Write the c:smooth element.
 1885:         if self.smooth_allowed:
 1886:             self._write_c_smooth(series["smooth"])
 1887: 
 1888:         # Write the c:extLst element.
 1889:         if series.get("inverted_color"):
 1890:             self._write_c_ext_lst_inverted_color(series["inverted_color"])
 1891: 
 1892:         self._xml_end_tag("c:ser")
 1893: 
 1894:     def _write_c_ext_lst_inverted_color(self, color):
 1895:         # Write the <c:extLst> element for the inverted fill color.
 1896: 
 1897:         uri = "{6F2FDCE9-48DA-4B69-8628-5D25D57E5C99}"
 1898:         xmlns_c_14 = "http://schemas.microsoft.com/office/drawing/2007/8/2/chart"
 1899: 
 1900:         attributes1 = [
 1901:             ("uri", uri),
 1902:             ("xmlns:c14", xmlns_c_14),
 1903:         ]
 1904: 
 1905:         attributes2 = [("xmlns:c14", xmlns_c_14)]
 1906: 
 1907:         self._xml_start_tag("c:extLst")
 1908:         self._xml_start_tag("c:ext", attributes1)
 1909:         self._xml_start_tag("c14:invertSolidFillFmt")
 1910:         self._xml_start_tag("c14:spPr", attributes2)
 1911: 
 1912:         self._write_a_solid_fill({"color": color})
 1913: 
 1914:         self._xml_end_tag("c14:spPr")
 1915:         self._xml_end_tag("c14:invertSolidFillFmt")
 1916:         self._xml_end_tag("c:ext")
 1917:         self._xml_end_tag("c:extLst")
 1918: 
 1919:     def _write_c_ext_lst_display_na(self):
 1920:         # Write the <c:extLst> element for the display NA as empty cell option.
 1921: 
 1922:         uri = "{56B9EC1D-385E-4148-901F-78D8002777C0}"
 1923:         xmlns_c_16 = "http://schemas.microsoft.com/office/drawing/2017/03/chart"
 1924: 
 1925:         attributes1 = [
 1926:             ("uri", uri),
 1927:             ("xmlns:c16r3", xmlns_c_16),
 1928:         ]
 1929: 
 1930:         attributes2 = [("val", 1)]
 1931: 
 1932:         self._xml_start_tag("c:extLst")
 1933:         self._xml_start_tag("c:ext", attributes1)
 1934:         self._xml_start_tag("c16r3:dataDisplayOptions16")
 1935:         self._xml_empty_tag("c16r3:dispNaAsBlank", attributes2)
 1936:         self._xml_end_tag("c16r3:dataDisplayOptions16")
 1937:         self._xml_end_tag("c:ext")
 1938:         self._xml_end_tag("c:extLst")
 1939: 
 1940:     def _write_idx(self, val):
 1941:         # Write the <c:idx> element.
 1942: 
 1943:         attributes = [("val", val)]
 1944: 
 1945:         self._xml_empty_tag("c:idx", attributes)
 1946: 
 1947:     def _write_order(self, val):
 1948:         # Write the <c:order> element.
 1949: 
 1950:         attributes = [("val", val)]
 1951: 
 1952:         self._xml_empty_tag("c:order", attributes)
 1953: 
 1954:     def _write_series_name(self, series):
 1955:         # Write the series name.
 1956: 
 1957:         if series["name_formula"] is not None:
 1958:             self._write_tx_formula(series["name_formula"], series["name_id"])
 1959:         elif series["name"] is not None:
 1960:             self._write_tx_value(series["name"])
 1961: 
 1962:     def _write_c_smooth(self, smooth):
 1963:         # Write the <c:smooth> element.
 1964: 
 1965:         if smooth:
 1966:             self._xml_empty_tag("c:smooth", [("val", "1")])
 1967: 
 1968:     def _write_cat(self, series):
 1969:         # Write the <c:cat> element.
 1970:         formula = series["categories"]
 1971:         data_id = series["cat_data_id"]
 1972:         data = None
 1973: 
 1974:         if data_id is not None:
 1975:             data = self.formula_data[data_id]
 1976: 
 1977:         # Ignore <c:cat> elements for charts without category values.
 1978:         if not formula:
 1979:             return
 1980: 
 1981:         self._xml_start_tag("c:cat")
 1982: 
 1983:         # Check the type of cached data.
 1984:         cat_type = self._get_data_type(data)
 1985: 
 1986:         if cat_type == "str":
 1987:             self.cat_has_num_fmt = 0
 1988:             # Write the c:numRef element.
 1989:             self._write_str_ref(formula, data, cat_type)
 1990: 
 1991:         elif cat_type == "multi_str":
 1992:             self.cat_has_num_fmt = 0
 1993:             # Write the c:numRef element.
 1994:             self._write_multi_lvl_str_ref(formula, data)
 1995: 
 1996:         else:
 1997:             self.cat_has_num_fmt = 1
 1998:             # Write the c:numRef element.
 1999:             self._write_num_ref(formula, data, cat_type)
 2000: 
 2001:         self._xml_end_tag("c:cat")
 2002: 
 2003:     def _write_val(self, series):
 2004:         # Write the <c:val> element.
 2005:         formula = series["values"]
 2006:         data_id = series["val_data_id"]
 2007:         data = self.formula_data[data_id]
 2008: 
 2009:         self._xml_start_tag("c:val")
 2010: 
 2011:         # Unlike Cat axes data should only be numeric.
 2012:         # Write the c:numRef element.
 2013:         self._write_num_ref(formula, data, "num")
 2014: 
 2015:         self._xml_end_tag("c:val")
 2016: 
 2017:     def _write_num_ref(self, formula, data, ref_type):
 2018:         # Write the <c:numRef> element.
 2019:         self._xml_start_tag("c:numRef")
 2020: 
 2021:         # Write the c:f element.
 2022:         self._write_series_formula(formula)
 2023: 
 2024:         if ref_type == "num":
 2025:             # Write the c:numCache element.
 2026:             self._write_num_cache(data)
 2027:         elif ref_type == "str":
 2028:             # Write the c:strCache element.
 2029:             self._write_str_cache(data)
 2030: 
 2031:         self._xml_end_tag("c:numRef")
 2032: 
 2033:     def _write_str_ref(self, formula, data, ref_type):
 2034:         # Write the <c:strRef> element.
 2035: 
 2036:         self._xml_start_tag("c:strRef")
 2037: 
 2038:         # Write the c:f element.
 2039:         self._write_series_formula(formula)
 2040: 
 2041:         if ref_type == "num":
 2042:             # Write the c:numCache element.
 2043:             self._write_num_cache(data)
 2044:         elif ref_type == "str":
 2045:             # Write the c:strCache element.
 2046:             self._write_str_cache(data)
 2047: 
 2048:         self._xml_end_tag("c:strRef")
 2049: 
 2050:     def _write_multi_lvl_str_ref(self, formula, data):
 2051:         # Write the <c:multiLvlStrRef> element.
 2052: 
 2053:         if not data:
 2054:             return
 2055: 
 2056:         self._xml_start_tag("c:multiLvlStrRef")
 2057: 
 2058:         # Write the c:f element.
 2059:         self._write_series_formula(formula)
 2060: 
 2061:         self._xml_start_tag("c:multiLvlStrCache")
 2062: 
 2063:         # Write the c:ptCount element.
 2064:         count = len(data[-1])
 2065:         self._write_pt_count(count)
 2066: 
 2067:         for cat_data in reversed(data):
 2068:             self._xml_start_tag("c:lvl")
 2069: 
 2070:             for i, point in enumerate(cat_data):
 2071:                 # Write the c:pt element.
 2072:                 self._write_pt(i, cat_data[i])
 2073: 
 2074:             self._xml_end_tag("c:lvl")
 2075: 
 2076:         self._xml_end_tag("c:multiLvlStrCache")
 2077:         self._xml_end_tag("c:multiLvlStrRef")
 2078: 
 2079:     def _write_series_formula(self, formula):
 2080:         # Write the <c:f> element.
 2081: 
 2082:         # Strip the leading '=' from the formula.
 2083:         if formula.startswith("="):
 2084:             formula = formula.lstrip("=")
 2085: 
 2086:         self._xml_data_element("c:f", formula)
 2087: 
 2088:     def _write_axis_ids(self, args):
 2089:         # Write the <c:axId> elements for the primary or secondary axes.
 2090: 
 2091:         # Generate the axis ids.
 2092:         self._add_axis_ids(args)
 2093: 
 2094:         if args["primary_axes"]:
 2095:             # Write the axis ids for the primary axes.
 2096:             self._write_axis_id(self.axis_ids[0])
 2097:             self._write_axis_id(self.axis_ids[1])
 2098:         else:
 2099:             # Write the axis ids for the secondary axes.
 2100:             self._write_axis_id(self.axis2_ids[0])
 2101:             self._write_axis_id(self.axis2_ids[1])
 2102: 
 2103:     def _write_axis_id(self, val):
 2104:         # Write the <c:axId> element.
 2105: 
 2106:         attributes = [("val", val)]
 2107: 
 2108:         self._xml_empty_tag("c:axId", attributes)
 2109: 
 2110:     def _write_cat_axis(self, args):
 2111:         # Write the <c:catAx> element. Usually the X axis.
 2112:         x_axis = args["x_axis"]
 2113:         y_axis = args["y_axis"]
 2114:         axis_ids = args["axis_ids"]
 2115: 
 2116:         # If there are no axis_ids then we don't need to write this element.
 2117:         if axis_ids is None or not len(axis_ids):
 2118:             return
 2119: 
 2120:         position = self.cat_axis_position
 2121:         is_y_axis = self.horiz_cat_axis
 2122: 
 2123:         # Overwrite the default axis position with a user supplied value.
 2124:         if x_axis.get("position"):
 2125:             position = x_axis["position"]
 2126: 
 2127:         self._xml_start_tag("c:catAx")
 2128: 
 2129:         self._write_axis_id(axis_ids[0])
 2130: 
 2131:         # Write the c:scaling element.
 2132:         self._write_scaling(x_axis.get("reverse"), None, None, None)
 2133: 
 2134:         if not x_axis.get("visible"):
 2135:             self._write_delete(1)
 2136: 
 2137:         # Write the c:axPos element.
 2138:         self._write_axis_pos(position, y_axis.get("reverse"))
 2139: 
 2140:         # Write the c:majorGridlines element.
 2141:         self._write_major_gridlines(x_axis.get("major_gridlines"))
 2142: 
 2143:         # Write the c:minorGridlines element.
 2144:         self._write_minor_gridlines(x_axis.get("minor_gridlines"))
 2145: 
 2146:         # Write the axis title elements.
 2147:         if x_axis["formula"] is not None:
 2148:             self._write_title_formula(
 2149:                 x_axis["formula"],
 2150:                 x_axis["data_id"],
 2151:                 is_y_axis,
 2152:                 x_axis["name_font"],
 2153:                 x_axis["name_layout"],
 2154:             )
 2155:         elif x_axis["name"] is not None:
 2156:             self._write_title_rich(
 2157:                 x_axis["name"], is_y_axis, x_axis["name_font"], x_axis["name_layout"]
 2158:             )
 2159: 
 2160:         # Write the c:numFmt element.
 2161:         self._write_cat_number_format(x_axis)
 2162: 
 2163:         # Write the c:majorTickMark element.
 2164:         self._write_major_tick_mark(x_axis.get("major_tick_mark"))
 2165: 
 2166:         # Write the c:minorTickMark element.
 2167:         self._write_minor_tick_mark(x_axis.get("minor_tick_mark"))
 2168: 
 2169:         # Write the c:tickLblPos element.
 2170:         self._write_tick_label_pos(x_axis.get("label_position"))
 2171: 
 2172:         # Write the c:spPr element for the axis line.
 2173:         self._write_sp_pr(x_axis)
 2174: 
 2175:         # Write the axis font elements.
 2176:         self._write_axis_font(x_axis.get("num_font"))
 2177: 
 2178:         # Write the c:crossAx element.
 2179:         self._write_cross_axis(axis_ids[1])
 2180: 
 2181:         if self.show_crosses or x_axis.get("visible"):
 2182:             # Note, the category crossing comes from the value axis.
 2183:             if (
 2184:                 y_axis.get("crossing") is None
 2185:                 or y_axis.get("crossing") == "max"
 2186:                 or y_axis["crossing"] == "min"
 2187:             ):
 2188:                 # Write the c:crosses element.
 2189:                 self._write_crosses(y_axis.get("crossing"))
 2190:             else:
 2191:                 # Write the c:crossesAt element.
 2192:                 self._write_c_crosses_at(y_axis.get("crossing"))
 2193: 
 2194:         # Write the c:auto element.
 2195:         if not x_axis.get("text_axis"):
 2196:             self._write_auto(1)
 2197: 
 2198:         # Write the c:labelAlign element.
 2199:         self._write_label_align(x_axis.get("label_align"))
 2200: 
 2201:         # Write the c:labelOffset element.
 2202:         self._write_label_offset(100)
 2203: 
 2204:         # Write the c:tickLblSkip element.
 2205:         self._write_c_tick_lbl_skip(x_axis.get("interval_unit"))
 2206: 
 2207:         # Write the c:tickMarkSkip element.
 2208:         self._write_c_tick_mark_skip(x_axis.get("interval_tick"))
 2209: 
 2210:         self._xml_end_tag("c:catAx")
 2211: 
 2212:     def _write_val_axis(self, args):
 2213:         # Write the <c:valAx> element. Usually the Y axis.
 2214:         x_axis = args["x_axis"]
 2215:         y_axis = args["y_axis"]
 2216:         axis_ids = args["axis_ids"]
 2217:         position = args.get("position", self.val_axis_position)
 2218:         is_y_axis = self.horiz_val_axis
 2219: 
 2220:         # If there are no axis_ids then we don't need to write this element.
 2221:         if axis_ids is None or not len(axis_ids):
 2222:             return
 2223: 
 2224:         # Overwrite the default axis position with a user supplied value.
 2225:         position = y_axis.get("position") or position
 2226: 
 2227:         self._xml_start_tag("c:valAx")
 2228: 
 2229:         self._write_axis_id(axis_ids[1])
 2230: 
 2231:         # Write the c:scaling element.
 2232:         self._write_scaling(
 2233:             y_axis.get("reverse"),
 2234:             y_axis.get("min"),
 2235:             y_axis.get("max"),
 2236:             y_axis.get("log_base"),
 2237:         )
 2238: 
 2239:         if not y_axis.get("visible"):
 2240:             self._write_delete(1)
 2241: 
 2242:         # Write the c:axPos element.
 2243:         self._write_axis_pos(position, x_axis.get("reverse"))
 2244: 
 2245:         # Write the c:majorGridlines element.
 2246:         self._write_major_gridlines(y_axis.get("major_gridlines"))
 2247: 
 2248:         # Write the c:minorGridlines element.
 2249:         self._write_minor_gridlines(y_axis.get("minor_gridlines"))
 2250: 
 2251:         # Write the axis title elements.
 2252:         if y_axis["formula"] is not None:
 2253:             self._write_title_formula(
 2254:                 y_axis["formula"],
 2255:                 y_axis["data_id"],
 2256:                 is_y_axis,
 2257:                 y_axis["name_font"],
 2258:                 y_axis["name_layout"],
 2259:             )
 2260:         elif y_axis["name"] is not None:
 2261:             self._write_title_rich(
 2262:                 y_axis["name"],
 2263:                 is_y_axis,
 2264:                 y_axis.get("name_font"),
 2265:                 y_axis.get("name_layout"),
 2266:             )
 2267: 
 2268:         # Write the c:numberFormat element.
 2269:         self._write_number_format(y_axis)
 2270: 
 2271:         # Write the c:majorTickMark element.
 2272:         self._write_major_tick_mark(y_axis.get("major_tick_mark"))
 2273: 
 2274:         # Write the c:minorTickMark element.
 2275:         self._write_minor_tick_mark(y_axis.get("minor_tick_mark"))
 2276: 
 2277:         # Write the c:tickLblPos element.
 2278:         self._write_tick_label_pos(y_axis.get("label_position"))
 2279: 
 2280:         # Write the c:spPr element for the axis line.
 2281:         self._write_sp_pr(y_axis)
 2282: 
 2283:         # Write the axis font elements.
 2284:         self._write_axis_font(y_axis.get("num_font"))
 2285: 
 2286:         # Write the c:crossAx element.
 2287:         self._write_cross_axis(axis_ids[0])
 2288: 
 2289:         # Note, the category crossing comes from the value axis.
 2290:         if (
 2291:             x_axis.get("crossing") is None
 2292:             or x_axis["crossing"] == "max"
 2293:             or x_axis["crossing"] == "min"
 2294:         ):
 2295:             # Write the c:crosses element.
 2296:             self._write_crosses(x_axis.get("crossing"))
 2297:         else:
 2298:             # Write the c:crossesAt element.
 2299:             self._write_c_crosses_at(x_axis.get("crossing"))
 2300: 
 2301:         # Write the c:crossBetween element.
 2302:         self._write_cross_between(x_axis.get("position_axis"))
 2303: 
 2304:         # Write the c:majorUnit element.
 2305:         self._write_c_major_unit(y_axis.get("major_unit"))
 2306: 
 2307:         # Write the c:minorUnit element.
 2308:         self._write_c_minor_unit(y_axis.get("minor_unit"))
 2309: 
 2310:         # Write the c:dispUnits element.
 2311:         self._write_disp_units(
 2312:             y_axis.get("display_units"), y_axis.get("display_units_visible")
 2313:         )
 2314: 
 2315:         self._xml_end_tag("c:valAx")
 2316: 
 2317:     def _write_cat_val_axis(self, args):
 2318:         # Write the <c:valAx> element. This is for the second valAx
 2319:         # in scatter plots. Usually the X axis.
 2320:         x_axis = args["x_axis"]
 2321:         y_axis = args["y_axis"]
 2322:         axis_ids = args["axis_ids"]
 2323:         position = args["position"] or self.val_axis_position
 2324:         is_y_axis = self.horiz_val_axis
 2325: 
 2326:         # If there are no axis_ids then we don't need to write this element.
 2327:         if axis_ids is None or not len(axis_ids):
 2328:             return
 2329: 
 2330:         # Overwrite the default axis position with a user supplied value.
 2331:         position = x_axis.get("position") or position
 2332: 
 2333:         self._xml_start_tag("c:valAx")
 2334: 
 2335:         self._write_axis_id(axis_ids[0])
 2336: 
 2337:         # Write the c:scaling element.
 2338:         self._write_scaling(
 2339:             x_axis.get("reverse"),
 2340:             x_axis.get("min"),
 2341:             x_axis.get("max"),
 2342:             x_axis.get("log_base"),
 2343:         )
 2344: 
 2345:         if not x_axis.get("visible"):
 2346:             self._write_delete(1)
 2347: 
 2348:         # Write the c:axPos element.
 2349:         self._write_axis_pos(position, y_axis.get("reverse"))
 2350: 
 2351:         # Write the c:majorGridlines element.
 2352:         self._write_major_gridlines(x_axis.get("major_gridlines"))
 2353: 
 2354:         # Write the c:minorGridlines element.
 2355:         self._write_minor_gridlines(x_axis.get("minor_gridlines"))
 2356: 
 2357:         # Write the axis title elements.
 2358:         if x_axis["formula"] is not None:
 2359:             self._write_title_formula(
 2360:                 x_axis["formula"],
 2361:                 x_axis["data_id"],
 2362:                 is_y_axis,
 2363:                 x_axis["name_font"],
 2364:                 x_axis["name_layout"],
 2365:             )
 2366:         elif x_axis["name"] is not None:
 2367:             self._write_title_rich(
 2368:                 x_axis["name"], is_y_axis, x_axis["name_font"], x_axis["name_layout"]
 2369:             )
 2370: 
 2371:         # Write the c:numberFormat element.
 2372:         self._write_number_format(x_axis)
 2373: 
 2374:         # Write the c:majorTickMark element.
 2375:         self._write_major_tick_mark(x_axis.get("major_tick_mark"))
 2376: 
 2377:         # Write the c:minorTickMark element.
 2378:         self._write_minor_tick_mark(x_axis.get("minor_tick_mark"))
 2379: 
 2380:         # Write the c:tickLblPos element.
 2381:         self._write_tick_label_pos(x_axis.get("label_position"))
 2382: 
 2383:         # Write the c:spPr element for the axis line.
 2384:         self._write_sp_pr(x_axis)
 2385: 
 2386:         # Write the axis font elements.
 2387:         self._write_axis_font(x_axis.get("num_font"))
 2388: 
 2389:         # Write the c:crossAx element.
 2390:         self._write_cross_axis(axis_ids[1])
 2391: 
 2392:         # Note, the category crossing comes from the value axis.
 2393:         if (
 2394:             y_axis.get("crossing") is None
 2395:             or y_axis["crossing"] == "max"
 2396:             or y_axis["crossing"] == "min"
 2397:         ):
 2398:             # Write the c:crosses element.
 2399:             self._write_crosses(y_axis.get("crossing"))
 2400:         else:
 2401:             # Write the c:crossesAt element.
 2402:             self._write_c_crosses_at(y_axis.get("crossing"))
 2403: 
 2404:         # Write the c:crossBetween element.
 2405:         self._write_cross_between(y_axis.get("position_axis"))
 2406: 
 2407:         # Write the c:majorUnit element.
 2408:         self._write_c_major_unit(x_axis.get("major_unit"))
 2409: 
 2410:         # Write the c:minorUnit element.
 2411:         self._write_c_minor_unit(x_axis.get("minor_unit"))
 2412: 
 2413:         # Write the c:dispUnits element.
 2414:         self._write_disp_units(
 2415:             x_axis.get("display_units"), x_axis.get("display_units_visible")
 2416:         )
 2417: 
 2418:         self._xml_end_tag("c:valAx")
 2419: 
 2420:     def _write_date_axis(self, args):
 2421:         # Write the <c:dateAx> element. Usually the X axis.
 2422:         x_axis = args["x_axis"]
 2423:         y_axis = args["y_axis"]
 2424:         axis_ids = args["axis_ids"]
 2425: 
 2426:         # If there are no axis_ids then we don't need to write this element.
 2427:         if axis_ids is None or not len(axis_ids):
 2428:             return
 2429: 
 2430:         position = self.cat_axis_position
 2431: 
 2432:         # Overwrite the default axis position with a user supplied value.
 2433:         position = x_axis.get("position") or position
 2434: 
 2435:         self._xml_start_tag("c:dateAx")
 2436: 
 2437:         self._write_axis_id(axis_ids[0])
 2438: 
 2439:         # Write the c:scaling element.
 2440:         self._write_scaling(
 2441:             x_axis.get("reverse"),
 2442:             x_axis.get("min"),
 2443:             x_axis.get("max"),
 2444:             x_axis.get("log_base"),
 2445:         )
 2446: 
 2447:         if not x_axis.get("visible"):
 2448:             self._write_delete(1)
 2449: 
 2450:         # Write the c:axPos element.
 2451:         self._write_axis_pos(position, y_axis.get("reverse"))
 2452: 
 2453:         # Write the c:majorGridlines element.
 2454:         self._write_major_gridlines(x_axis.get("major_gridlines"))
 2455: 
 2456:         # Write the c:minorGridlines element.
 2457:         self._write_minor_gridlines(x_axis.get("minor_gridlines"))
 2458: 
 2459:         # Write the axis title elements.
 2460:         if x_axis["formula"] is not None:
 2461:             self._write_title_formula(
 2462:                 x_axis["formula"],
 2463:                 x_axis["data_id"],
 2464:                 None,
 2465:                 x_axis["name_font"],
 2466:                 x_axis["name_layout"],
 2467:             )
 2468:         elif x_axis["name"] is not None:
 2469:             self._write_title_rich(
 2470:                 x_axis["name"], None, x_axis["name_font"], x_axis["name_layout"]
 2471:             )
 2472: 
 2473:         # Write the c:numFmt element.
 2474:         self._write_number_format(x_axis)
 2475: 
 2476:         # Write the c:majorTickMark element.
 2477:         self._write_major_tick_mark(x_axis.get("major_tick_mark"))
 2478: 
 2479:         # Write the c:minorTickMark element.
 2480:         self._write_minor_tick_mark(x_axis.get("minor_tick_mark"))
 2481: 
 2482:         # Write the c:tickLblPos element.
 2483:         self._write_tick_label_pos(x_axis.get("label_position"))
 2484: 
 2485:         # Write the c:spPr element for the axis line.
 2486:         self._write_sp_pr(x_axis)
 2487: 
 2488:         # Write the axis font elements.
 2489:         self._write_axis_font(x_axis.get("num_font"))
 2490: 
 2491:         # Write the c:crossAx element.
 2492:         self._write_cross_axis(axis_ids[1])
 2493: 
 2494:         if self.show_crosses or x_axis.get("visible"):
 2495:             # Note, the category crossing comes from the value axis.
 2496:             if (
 2497:                 y_axis.get("crossing") is None
 2498:                 or y_axis.get("crossing") == "max"
 2499:                 or y_axis["crossing"] == "min"
 2500:             ):
 2501:                 # Write the c:crosses element.
 2502:                 self._write_crosses(y_axis.get("crossing"))
 2503:             else:
 2504:                 # Write the c:crossesAt element.
 2505:                 self._write_c_crosses_at(y_axis.get("crossing"))
 2506: 
 2507:         # Write the c:auto element.
 2508:         self._write_auto(1)
 2509: 
 2510:         # Write the c:labelOffset element.
 2511:         self._write_label_offset(100)
 2512: 
 2513:         # Write the c:tickLblSkip element.
 2514:         self._write_c_tick_lbl_skip(x_axis.get("interval_unit"))
 2515: 
 2516:         # Write the c:tickMarkSkip element.
 2517:         self._write_c_tick_mark_skip(x_axis.get("interval_tick"))
 2518: 
 2519:         # Write the c:majorUnit element.
 2520:         self._write_c_major_unit(x_axis.get("major_unit"))
 2521: 
 2522:         # Write the c:majorTimeUnit element.
 2523:         if x_axis.get("major_unit"):
 2524:             self._write_c_major_time_unit(x_axis["major_unit_type"])
 2525: 
 2526:         # Write the c:minorUnit element.
 2527:         self._write_c_minor_unit(x_axis.get("minor_unit"))
 2528: 
 2529:         # Write the c:minorTimeUnit element.
 2530:         if x_axis.get("minor_unit"):
 2531:             self._write_c_minor_time_unit(x_axis["minor_unit_type"])
 2532: 
 2533:         self._xml_end_tag("c:dateAx")
 2534: 
 2535:     def _write_scaling(self, reverse, min_val, max_val, log_base):
 2536:         # Write the <c:scaling> element.
 2537: 
 2538:         self._xml_start_tag("c:scaling")
 2539: 
 2540:         # Write the c:logBase element.
 2541:         self._write_c_log_base(log_base)
 2542: 
 2543:         # Write the c:orientation element.
 2544:         self._write_orientation(reverse)
 2545: 
 2546:         # Write the c:max element.
 2547:         self._write_c_max(max_val)
 2548: 
 2549:         # Write the c:min element.
 2550:         self._write_c_min(min_val)
 2551: 
 2552:         self._xml_end_tag("c:scaling")
 2553: 
 2554:     def _write_c_log_base(self, val):
 2555:         # Write the <c:logBase> element.
 2556: 
 2557:         if not val:
 2558:             return
 2559: 
 2560:         attributes = [("val", val)]
 2561: 
 2562:         self._xml_empty_tag("c:logBase", attributes)
 2563: 
 2564:     def _write_orientation(self, reverse):
 2565:         # Write the <c:orientation> element.
 2566:         val = "minMax"
 2567: 
 2568:         if reverse:
 2569:             val = "maxMin"
 2570: 
 2571:         attributes = [("val", val)]
 2572: 
 2573:         self._xml_empty_tag("c:orientation", attributes)
 2574: 
 2575:     def _write_c_max(self, max_val):
 2576:         # Write the <c:max> element.
 2577: 
 2578:         if max_val is None:
 2579:             return
 2580: 
 2581:         attributes = [("val", max_val)]
 2582: 
 2583:         self._xml_empty_tag("c:max", attributes)
 2584: 
 2585:     def _write_c_min(self, min_val):
 2586:         # Write the <c:min> element.
 2587: 
 2588:         if min_val is None:
 2589:             return
 2590: 
 2591:         attributes = [("val", min_val)]
 2592: 
 2593:         self._xml_empty_tag("c:min", attributes)
 2594: 
 2595:     def _write_axis_pos(self, val, reverse):
 2596:         # Write the <c:axPos> element.
 2597: 
 2598:         if reverse:
 2599:             if val == "l":
 2600:                 val = "r"
 2601:             if val == "b":
 2602:                 val = "t"
 2603: 
 2604:         attributes = [("val", val)]
 2605: 
 2606:         self._xml_empty_tag("c:axPos", attributes)
 2607: 
 2608:     def _write_number_format(self, axis):
 2609:         # Write the <c:numberFormat> element. Note: It is assumed that if
 2610:         # a user defined number format is supplied (i.e., non-default) then
 2611:         # the sourceLinked attribute is 0.
 2612:         # The user can override this if required.
 2613:         format_code = axis.get("num_format")
 2614:         source_linked = 1
 2615: 
 2616:         # Check if a user defined number format has been set.
 2617:         if format_code is not None and format_code != axis["defaults"]["num_format"]:
 2618:             source_linked = 0
 2619: 
 2620:         # User override of sourceLinked.
 2621:         if axis.get("num_format_linked"):
 2622:             source_linked = 1
 2623: 
 2624:         attributes = [
 2625:             ("formatCode", format_code),
 2626:             ("sourceLinked", source_linked),
 2627:         ]
 2628: 
 2629:         self._xml_empty_tag("c:numFmt", attributes)
 2630: 
 2631:     def _write_cat_number_format(self, axis):
 2632:         # Write the <c:numFmt> element. Special case handler for category
 2633:         # axes which don't always have a number format.
 2634:         format_code = axis.get("num_format")
 2635:         source_linked = 1
 2636:         default_format = 1
 2637: 
 2638:         # Check if a user defined number format has been set.
 2639:         if format_code is not None and format_code != axis["defaults"]["num_format"]:
 2640:             source_linked = 0
 2641:             default_format = 0
 2642: 
 2643:         # User override of sourceLinked.
 2644:         if axis.get("num_format_linked"):
 2645:             source_linked = 1
 2646: 
 2647:         # Skip if cat doesn't have a num format (unless it is non-default).
 2648:         if not self.cat_has_num_fmt and default_format:
 2649:             return
 2650: 
 2651:         attributes = [
 2652:             ("formatCode", format_code),
 2653:             ("sourceLinked", source_linked),
 2654:         ]
 2655: 
 2656:         self._xml_empty_tag("c:numFmt", attributes)
 2657: 
 2658:     def _write_data_label_number_format(self, format_code):
 2659:         # Write the <c:numberFormat> element for data labels.
 2660:         source_linked = 0
 2661: 
 2662:         attributes = [
 2663:             ("formatCode", format_code),
 2664:             ("sourceLinked", source_linked),
 2665:         ]
 2666: 
 2667:         self._xml_empty_tag("c:numFmt", attributes)
 2668: 
 2669:     def _write_major_tick_mark(self, val):
 2670:         # Write the <c:majorTickMark> element.
 2671: 
 2672:         if not val:
 2673:             return
 2674: 
 2675:         attributes = [("val", val)]
 2676: 
 2677:         self._xml_empty_tag("c:majorTickMark", attributes)
 2678: 
 2679:     def _write_minor_tick_mark(self, val):
 2680:         # Write the <c:minorTickMark> element.
 2681: 
 2682:         if not val:
 2683:             return
 2684: 
 2685:         attributes = [("val", val)]
 2686: 
 2687:         self._xml_empty_tag("c:minorTickMark", attributes)
 2688: 
 2689:     def _write_tick_label_pos(self, val=None):
 2690:         # Write the <c:tickLblPos> element.
 2691:         if val is None or val == "next_to":
 2692:             val = "nextTo"
 2693: 
 2694:         attributes = [("val", val)]
 2695: 
 2696:         self._xml_empty_tag("c:tickLblPos", attributes)
 2697: 
 2698:     def _write_cross_axis(self, val):
 2699:         # Write the <c:crossAx> element.
 2700: 
 2701:         attributes = [("val", val)]
 2702: 
 2703:         self._xml_empty_tag("c:crossAx", attributes)
 2704: 
 2705:     def _write_crosses(self, val=None):
 2706:         # Write the <c:crosses> element.
 2707:         if val is None:
 2708:             val = "autoZero"
 2709: 
 2710:         attributes = [("val", val)]
 2711: 
 2712:         self._xml_empty_tag("c:crosses", attributes)
 2713: 
 2714:     def _write_c_crosses_at(self, val):
 2715:         # Write the <c:crossesAt> element.
 2716: 
 2717:         attributes = [("val", val)]
 2718: 
 2719:         self._xml_empty_tag("c:crossesAt", attributes)
 2720: 
 2721:     def _write_auto(self, val):
 2722:         # Write the <c:auto> element.
 2723: 
 2724:         attributes = [("val", val)]
 2725: 
 2726:         self._xml_empty_tag("c:auto", attributes)
 2727: 
 2728:     def _write_label_align(self, val=None):
 2729:         # Write the <c:labelAlign> element.
 2730: 
 2731:         if val is None:
 2732:             val = "ctr"
 2733: 
 2734:         if val == "right":
 2735:             val = "r"
 2736: 
 2737:         if val == "left":
 2738:             val = "l"
 2739: 
 2740:         attributes = [("val", val)]
 2741: 
 2742:         self._xml_empty_tag("c:lblAlgn", attributes)
 2743: 
 2744:     def _write_label_offset(self, val):
 2745:         # Write the <c:labelOffset> element.
 2746: 
 2747:         attributes = [("val", val)]
 2748: 
 2749:         self._xml_empty_tag("c:lblOffset", attributes)
 2750: 
 2751:     def _write_c_tick_lbl_skip(self, val):
 2752:         # Write the <c:tickLblSkip> element.
 2753:         if val is None:
 2754:             return
 2755: 
 2756:         attributes = [("val", val)]
 2757: 
 2758:         self._xml_empty_tag("c:tickLblSkip", attributes)
 2759: 
 2760:     def _write_c_tick_mark_skip(self, val):
 2761:         # Write the <c:tickMarkSkip> element.
 2762:         if val is None:
 2763:             return
 2764: 
 2765:         attributes = [("val", val)]
 2766: 
 2767:         self._xml_empty_tag("c:tickMarkSkip", attributes)
 2768: 
 2769:     def _write_major_gridlines(self, gridlines):
 2770:         # Write the <c:majorGridlines> element.
 2771: 
 2772:         if not gridlines:
 2773:             return
 2774: 
 2775:         if not gridlines["visible"]:
 2776:             return
 2777: 
 2778:         if gridlines["line"]["defined"]:
 2779:             self._xml_start_tag("c:majorGridlines")
 2780: 
 2781:             # Write the c:spPr element.
 2782:             self._write_sp_pr(gridlines)
 2783: 
 2784:             self._xml_end_tag("c:majorGridlines")
 2785:         else:
 2786:             self._xml_empty_tag("c:majorGridlines")
 2787: 
 2788:     def _write_minor_gridlines(self, gridlines):
 2789:         # Write the <c:minorGridlines> element.
 2790: 
 2791:         if not gridlines:
 2792:             return
 2793: 
 2794:         if not gridlines["visible"]:
 2795:             return
 2796: 
 2797:         if gridlines["line"]["defined"]:
 2798:             self._xml_start_tag("c:minorGridlines")
 2799: 
 2800:             # Write the c:spPr element.
 2801:             self._write_sp_pr(gridlines)
 2802: 
 2803:             self._xml_end_tag("c:minorGridlines")
 2804:         else:
 2805:             self._xml_empty_tag("c:minorGridlines")
 2806: 
 2807:     def _write_cross_between(self, val):
 2808:         # Write the <c:crossBetween> element.
 2809:         if val is None:
 2810:             val = self.cross_between
 2811: 
 2812:         attributes = [("val", val)]
 2813: 
 2814:         self._xml_empty_tag("c:crossBetween", attributes)
 2815: 
 2816:     def _write_c_major_unit(self, val):
 2817:         # Write the <c:majorUnit> element.
 2818: 
 2819:         if not val:
 2820:             return
 2821: 
 2822:         attributes = [("val", val)]
 2823: 
 2824:         self._xml_empty_tag("c:majorUnit", attributes)
 2825: 
 2826:     def _write_c_minor_unit(self, val):
 2827:         # Write the <c:minorUnit> element.
 2828: 
 2829:         if not val:
 2830:             return
 2831: 
 2832:         attributes = [("val", val)]
 2833: 
 2834:         self._xml_empty_tag("c:minorUnit", attributes)
 2835: 
 2836:     def _write_c_major_time_unit(self, val=None):
 2837:         # Write the <c:majorTimeUnit> element.
 2838:         if val is None:
 2839:             val = "days"
 2840: 
 2841:         attributes = [("val", val)]
 2842: 
 2843:         self._xml_empty_tag("c:majorTimeUnit", attributes)
 2844: 
 2845:     def _write_c_minor_time_unit(self, val=None):
 2846:         # Write the <c:minorTimeUnit> element.
 2847:         if val is None:
 2848:             val = "days"
 2849: 
 2850:         attributes = [("val", val)]
 2851: 
 2852:         self._xml_empty_tag("c:minorTimeUnit", attributes)
 2853: 
 2854:     def _write_legend(self):
 2855:         # Write the <c:legend> element.
 2856:         legend = self.legend
 2857:         position = legend.get("position", "right")
 2858:         font = legend.get("font")
 2859:         delete_series = []
 2860:         overlay = 0
 2861: 
 2862:         if legend.get("delete_series") and isinstance(legend["delete_series"], list):
 2863:             delete_series = legend["delete_series"]
 2864: 
 2865:         if position.startswith("overlay_"):
 2866:             position = position.replace("overlay_", "")
 2867:             overlay = 1
 2868: 
 2869:         allowed = {
 2870:             "right": "r",
 2871:             "left": "l",
 2872:             "top": "t",
 2873:             "bottom": "b",
 2874:             "top_right": "tr",
 2875:         }
 2876: 
 2877:         if position == "none":
 2878:             return
 2879: 
 2880:         if position not in allowed:
 2881:             return
 2882: 
 2883:         position = allowed[position]
 2884: 
 2885:         self._xml_start_tag("c:legend")
 2886: 
 2887:         # Write the c:legendPos element.
 2888:         self._write_legend_pos(position)
 2889: 
 2890:         # Remove series labels from the legend.
 2891:         for index in delete_series:
 2892:             # Write the c:legendEntry element.
 2893:             self._write_legend_entry(index)
 2894: 
 2895:         # Write the c:layout element.
 2896:         self._write_layout(legend.get("layout"), "legend")
 2897: 
 2898:         # Write the c:overlay element.
 2899:         if overlay:
 2900:             self._write_overlay()
 2901: 
 2902:         if font:
 2903:             self._write_tx_pr(font)
 2904: 
 2905:         # Write the c:spPr element.
 2906:         self._write_sp_pr(legend)
 2907: 
 2908:         self._xml_end_tag("c:legend")
 2909: 
 2910:     def _write_legend_pos(self, val):
 2911:         # Write the <c:legendPos> element.
 2912: 
 2913:         attributes = [("val", val)]
 2914: 
 2915:         self._xml_empty_tag("c:legendPos", attributes)
 2916: 
 2917:     def _write_legend_entry(self, index):
 2918:         # Write the <c:legendEntry> element.
 2919: 
 2920:         self._xml_start_tag("c:legendEntry")
 2921: 
 2922:         # Write the c:idx element.
 2923:         self._write_idx(index)
 2924: 
 2925:         # Write the c:delete element.
 2926:         self._write_delete(1)
 2927: 
 2928:         self._xml_end_tag("c:legendEntry")
 2929: 
 2930:     def _write_overlay(self):
 2931:         # Write the <c:overlay> element.
 2932:         val = 1
 2933: 
 2934:         attributes = [("val", val)]
 2935: 
 2936:         self._xml_empty_tag("c:overlay", attributes)
 2937: 
 2938:     def _write_plot_vis_only(self):
 2939:         # Write the <c:plotVisOnly> element.
 2940:         val = 1
 2941: 
 2942:         # Ignore this element if we are plotting hidden data.
 2943:         if self.show_hidden:
 2944:             return
 2945: 
 2946:         attributes = [("val", val)]
 2947: 
 2948:         self._xml_empty_tag("c:plotVisOnly", attributes)
 2949: 
 2950:     def _write_print_settings(self):
 2951:         # Write the <c:printSettings> element.
 2952:         self._xml_start_tag("c:printSettings")
 2953: 
 2954:         # Write the c:headerFooter element.
 2955:         self._write_header_footer()
 2956: 
 2957:         # Write the c:pageMargins element.
 2958:         self._write_page_margins()
 2959: 
 2960:         # Write the c:pageSetup element.
 2961:         self._write_page_setup()
 2962: 
 2963:         self._xml_end_tag("c:printSettings")
 2964: 
 2965:     def _write_header_footer(self):
 2966:         # Write the <c:headerFooter> element.
 2967:         self._xml_empty_tag("c:headerFooter")
 2968: 
 2969:     def _write_page_margins(self):
 2970:         # Write the <c:pageMargins> element.
 2971:         bottom = 0.75
 2972:         left = 0.7
 2973:         right = 0.7
 2974:         top = 0.75
 2975:         header = 0.3
 2976:         footer = 0.3
 2977: 
 2978:         attributes = [
 2979:             ("b", bottom),
 2980:             ("l", left),
 2981:             ("r", right),
 2982:             ("t", top),
 2983:             ("header", header),
 2984:             ("footer", footer),
 2985:         ]
 2986: 
 2987:         self._xml_empty_tag("c:pageMargins", attributes)
 2988: 
 2989:     def _write_page_setup(self):
 2990:         # Write the <c:pageSetup> element.
 2991:         self._xml_empty_tag("c:pageSetup")
 2992: 
 2993:     def _write_c_auto_title_deleted(self):
 2994:         # Write the <c:autoTitleDeleted> element.
 2995:         self._xml_empty_tag("c:autoTitleDeleted", [("val", 1)])
 2996: 
 2997:     def _write_title_rich(self, title, is_y_axis, font, layout, overlay=False):
 2998:         # Write the <c:title> element for a rich string.
 2999: 
 3000:         self._xml_start_tag("c:title")
 3001: 
 3002:         # Write the c:tx element.
 3003:         self._write_tx_rich(title, is_y_axis, font)
 3004: 
 3005:         # Write the c:layout element.
 3006:         self._write_layout(layout, "text")
 3007: 
 3008:         # Write the c:overlay element.
 3009:         if overlay:
 3010:             self._write_overlay()
 3011: 
 3012:         self._xml_end_tag("c:title")
 3013: 
 3014:     def _write_title_formula(
 3015:         self, title, data_id, is_y_axis, font, layout, overlay=False
 3016:     ):
 3017:         # Write the <c:title> element for a rich string.
 3018: 
 3019:         self._xml_start_tag("c:title")
 3020: 
 3021:         # Write the c:tx element.
 3022:         self._write_tx_formula(title, data_id)
 3023: 
 3024:         # Write the c:layout element.
 3025:         self._write_layout(layout, "text")
 3026: 
 3027:         # Write the c:overlay element.
 3028:         if overlay:
 3029:             self._write_overlay()
 3030: 
 3031:         # Write the c:txPr element.
 3032:         self._write_tx_pr(font, is_y_axis)
 3033: 
 3034:         self._xml_end_tag("c:title")
 3035: 
 3036:     def _write_tx_rich(self, title, is_y_axis, font):
 3037:         # Write the <c:tx> element.
 3038: 
 3039:         self._xml_start_tag("c:tx")
 3040: 
 3041:         # Write the c:rich element.
 3042:         self._write_rich(title, font, is_y_axis, ignore_rich_pr=False)
 3043: 
 3044:         self._xml_end_tag("c:tx")
 3045: 
 3046:     def _write_tx_value(self, title):
 3047:         # Write the <c:tx> element with a value such as for series names.
 3048: 
 3049:         self._xml_start_tag("c:tx")
 3050: 
 3051:         # Write the c:v element.
 3052:         self._write_v(title)
 3053: 
 3054:         self._xml_end_tag("c:tx")
 3055: 
 3056:     def _write_tx_formula(self, title, data_id):
 3057:         # Write the <c:tx> element.
 3058:         data = None
 3059: 
 3060:         if data_id is not None:
 3061:             data = self.formula_data[data_id]
 3062: 
 3063:         self._xml_start_tag("c:tx")
 3064: 
 3065:         # Write the c:strRef element.
 3066:         self._write_str_ref(title, data, "str")
 3067: 
 3068:         self._xml_end_tag("c:tx")
 3069: 
 3070:     def _write_rich(self, title, font, is_y_axis, ignore_rich_pr):
 3071:         # Write the <c:rich> element.
 3072: 
 3073:         if font and font.get("rotation") is not None:
 3074:             rotation = font["rotation"]
 3075:         else:
 3076:             rotation = None
 3077: 
 3078:         self._xml_start_tag("c:rich")
 3079: 
 3080:         # Write the a:bodyPr element.
 3081:         self._write_a_body_pr(rotation, is_y_axis)
 3082: 
 3083:         # Write the a:lstStyle element.
 3084:         self._write_a_lst_style()
 3085: 
 3086:         # Write the a:p element.
 3087:         self._write_a_p_rich(title, font, ignore_rich_pr)
 3088: 
 3089:         self._xml_end_tag("c:rich")
 3090: 
 3091:     def _write_a_body_pr(self, rotation, is_y_axis):
 3092:         # Write the <a:bodyPr> element.
 3093:         attributes = []
 3094: 
 3095:         if rotation is None and is_y_axis:
 3096:             rotation = -5400000
 3097: 
 3098:         if rotation is not None:
 3099:             if rotation == 16200000:
 3100:                 # 270 deg/stacked angle.
 3101:                 attributes.append(("rot", 0))
 3102:                 attributes.append(("vert", "wordArtVert"))
 3103:             elif rotation == 16260000:
 3104:                 # 271 deg/East Asian vertical.
 3105:                 attributes.append(("rot", 0))
 3106:                 attributes.append(("vert", "eaVert"))
 3107:             else:
 3108:                 attributes.append(("rot", rotation))
 3109:                 attributes.append(("vert", "horz"))
 3110: 
 3111:         self._xml_empty_tag("a:bodyPr", attributes)
 3112: 
 3113:     def _write_a_lst_style(self):
 3114:         # Write the <a:lstStyle> element.
 3115:         self._xml_empty_tag("a:lstStyle")
 3116: 
 3117:     def _write_a_p_rich(self, title, font, ignore_rich_pr):
 3118:         # Write the <a:p> element for rich string titles.
 3119: 
 3120:         self._xml_start_tag("a:p")
 3121: 
 3122:         # Write the a:pPr element.
 3123:         if not ignore_rich_pr:
 3124:             self._write_a_p_pr_rich(font)
 3125: 
 3126:         # Write the a:r element.
 3127:         self._write_a_r(title, font)
 3128: 
 3129:         self._xml_end_tag("a:p")
 3130: 
 3131:     def _write_a_p_formula(self, font):
 3132:         # Write the <a:p> element for formula titles.
 3133: 
 3134:         self._xml_start_tag("a:p")
 3135: 
 3136:         # Write the a:pPr element.
 3137:         self._write_a_p_pr_rich(font)
 3138: 
 3139:         # Write the a:endParaRPr element.
 3140:         self._write_a_end_para_rpr()
 3141: 
 3142:         self._xml_end_tag("a:p")
 3143: 
 3144:     def _write_a_p_pr_rich(self, font):
 3145:         # Write the <a:pPr> element for rich string titles.
 3146: 
 3147:         self._xml_start_tag("a:pPr")
 3148: 
 3149:         # Write the a:defRPr element.
 3150:         self._write_a_def_rpr(font)
 3151: 
 3152:         self._xml_end_tag("a:pPr")
 3153: 
 3154:     def _write_a_def_rpr(self, font):
 3155:         # Write the <a:defRPr> element.
 3156:         has_color = 0
 3157: 
 3158:         style_attributes = Shape._get_font_style_attributes(font)
 3159:         latin_attributes = Shape._get_font_latin_attributes(font)
 3160: 
 3161:         if font and font.get("color") is not None:
 3162:             has_color = 1
 3163: 
 3164:         if latin_attributes or has_color:
 3165:             self._xml_start_tag("a:defRPr", style_attributes)
 3166: 
 3167:             if has_color:
 3168:                 self._write_a_solid_fill({"color": font["color"]})
 3169: 
 3170:             if latin_attributes:
 3171:                 self._write_a_latin(latin_attributes)
 3172: 
 3173:             self._xml_end_tag("a:defRPr")
 3174:         else:
 3175:             self._xml_empty_tag("a:defRPr", style_attributes)
 3176: 
 3177:     def _write_a_end_para_rpr(self):
 3178:         # Write the <a:endParaRPr> element.
 3179:         lang = "en-US"
 3180: 
 3181:         attributes = [("lang", lang)]
 3182: 
 3183:         self._xml_empty_tag("a:endParaRPr", attributes)
 3184: 
 3185:     def _write_a_r(self, title, font):
 3186:         # Write the <a:r> element.
 3187: 
 3188:         self._xml_start_tag("a:r")
 3189: 
 3190:         # Write the a:rPr element.
 3191:         self._write_a_r_pr(font)
 3192: 
 3193:         # Write the a:t element.
 3194:         self._write_a_t(title)
 3195: 
 3196:         self._xml_end_tag("a:r")
 3197: 
 3198:     def _write_a_r_pr(self, font):
 3199:         # Write the <a:rPr> element.
 3200:         has_color = 0
 3201:         lang = "en-US"
 3202: 
 3203:         style_attributes = Shape._get_font_style_attributes(font)
 3204:         latin_attributes = Shape._get_font_latin_attributes(font)
 3205: 
 3206:         if font and font["color"] is not None:
 3207:             has_color = 1
 3208: 
 3209:         # Add the lang type to the attributes.
 3210:         style_attributes.insert(0, ("lang", lang))
 3211: 
 3212:         if latin_attributes or has_color:
 3213:             self._xml_start_tag("a:rPr", style_attributes)
 3214: 
 3215:             if has_color:
 3216:                 self._write_a_solid_fill({"color": font["color"]})
 3217: 
 3218:             if latin_attributes:
 3219:                 self._write_a_latin(latin_attributes)
 3220: 
 3221:             self._xml_end_tag("a:rPr")
 3222:         else:
 3223:             self._xml_empty_tag("a:rPr", style_attributes)
 3224: 
 3225:     def _write_a_t(self, title):
 3226:         # Write the <a:t> element.
 3227: 
 3228:         self._xml_data_element("a:t", title)
 3229: 
 3230:     def _write_tx_pr(self, font, is_y_axis=False):
 3231:         # Write the <c:txPr> element.
 3232: 
 3233:         if font and font.get("rotation") is not None:
 3234:             rotation = font["rotation"]
 3235:         else:
 3236:             rotation = None
 3237: 
 3238:         self._xml_start_tag("c:txPr")
 3239: 
 3240:         # Write the a:bodyPr element.
 3241:         self._write_a_body_pr(rotation, is_y_axis)
 3242: 
 3243:         # Write the a:lstStyle element.
 3244:         self._write_a_lst_style()
 3245: 
 3246:         # Write the a:p element.
 3247:         self._write_a_p_formula(font)
 3248: 
 3249:         self._xml_end_tag("c:txPr")
 3250: 
 3251:     def _write_marker(self, marker):
 3252:         # Write the <c:marker> element.
 3253:         if marker is None:
 3254:             marker = self.default_marker
 3255: 
 3256:         if not marker:
 3257:             return
 3258: 
 3259:         if marker["type"] == "automatic":
 3260:             return
 3261: 
 3262:         self._xml_start_tag("c:marker")
 3263: 
 3264:         # Write the c:symbol element.
 3265:         self._write_symbol(marker["type"])
 3266: 
 3267:         # Write the c:size element.
 3268:         if marker.get("size"):
 3269:             self._write_marker_size(marker["size"])
 3270: 
 3271:         # Write the c:spPr element.
 3272:         self._write_sp_pr(marker)
 3273: 
 3274:         self._xml_end_tag("c:marker")
 3275: 
 3276:     def _write_marker_size(self, val):
 3277:         # Write the <c:size> element.
 3278: 
 3279:         attributes = [("val", val)]
 3280: 
 3281:         self._xml_empty_tag("c:size", attributes)
 3282: 
 3283:     def _write_symbol(self, val):
 3284:         # Write the <c:symbol> element.
 3285: 
 3286:         attributes = [("val", val)]
 3287: 
 3288:         self._xml_empty_tag("c:symbol", attributes)
 3289: 
 3290:     def _write_sp_pr(self, series):
 3291:         # Write the <c:spPr> element.
 3292: 
 3293:         if not self._has_fill_formatting(series):
 3294:             return
 3295: 
 3296:         self._xml_start_tag("c:spPr")
 3297: 
 3298:         # Write the fill elements for solid charts such as pie and bar.
 3299:         if series.get("fill") and series["fill"]["defined"]:
 3300:             if "none" in series["fill"]:
 3301:                 # Write the a:noFill element.
 3302:                 self._write_a_no_fill()
 3303:             else:
 3304:                 # Write the a:solidFill element.
 3305:                 self._write_a_solid_fill(series["fill"])
 3306: 
 3307:         if series.get("pattern"):
 3308:             # Write the a:gradFill element.
 3309:             self._write_a_patt_fill(series["pattern"])
 3310: 
 3311:         if series.get("gradient"):
 3312:             # Write the a:gradFill element.
 3313:             self._write_a_grad_fill(series["gradient"])
 3314: 
 3315:         # Write the a:ln element.
 3316:         if series.get("line") and series["line"]["defined"]:
 3317:             self._write_a_ln(series["line"])
 3318: 
 3319:         self._xml_end_tag("c:spPr")
 3320: 
 3321:     def _write_a_ln(self, line):
 3322:         # Write the <a:ln> element.
 3323:         attributes = []
 3324: 
 3325:         # Add the line width as an attribute.
 3326:         width = line.get("width")
 3327: 
 3328:         if width is not None:
 3329:             # Round width to nearest 0.25, like Excel.
 3330:             width = int((width + 0.125) * 4) / 4.0
 3331: 
 3332:             # Convert to internal units.
 3333:             width = int(0.5 + (12700 * width))
 3334: 
 3335:             attributes = [("w", width)]
 3336: 
 3337:         if line.get("none") or line.get("color") or line.get("dash_type"):
 3338:             self._xml_start_tag("a:ln", attributes)
 3339: 
 3340:             # Write the line fill.
 3341:             if "none" in line:
 3342:                 # Write the a:noFill element.
 3343:                 self._write_a_no_fill()
 3344:             elif "color" in line:
 3345:                 # Write the a:solidFill element.
 3346:                 self._write_a_solid_fill(line)
 3347: 
 3348:             # Write the line/dash type.
 3349:             line_type = line.get("dash_type")
 3350:             if line_type:
 3351:                 # Write the a:prstDash element.
 3352:                 self._write_a_prst_dash(line_type)
 3353: 
 3354:             self._xml_end_tag("a:ln")
 3355:         else:
 3356:             self._xml_empty_tag("a:ln", attributes)
 3357: 
 3358:     def _write_a_no_fill(self):
 3359:         # Write the <a:noFill> element.
 3360:         self._xml_empty_tag("a:noFill")
 3361: 
 3362:     def _write_a_solid_fill(self, fill):
 3363:         # Write the <a:solidFill> element.
 3364: 
 3365:         self._xml_start_tag("a:solidFill")
 3366: 
 3367:         if "color" in fill:
 3368:             color = get_rgb_color(fill["color"])
 3369:             transparency = fill.get("transparency")
 3370:             # Write the a:srgbClr element.
 3371:             self._write_a_srgb_clr(color, transparency)
 3372: 
 3373:         self._xml_end_tag("a:solidFill")
 3374: 
 3375:     def _write_a_srgb_clr(self, val, transparency=None):
 3376:         # Write the <a:srgbClr> element.
 3377:         attributes = [("val", val)]
 3378: 
 3379:         if transparency:
 3380:             self._xml_start_tag("a:srgbClr", attributes)
 3381: 
 3382:             # Write the a:alpha element.
 3383:             self._write_a_alpha(transparency)
 3384: 
 3385:             self._xml_end_tag("a:srgbClr")
 3386:         else:
 3387:             self._xml_empty_tag("a:srgbClr", attributes)
 3388: 
 3389:     def _write_a_alpha(self, val):
 3390:         # Write the <a:alpha> element.
 3391: 
 3392:         val = int((100 - int(val)) * 1000)
 3393: 
 3394:         attributes = [("val", val)]
 3395: 
 3396:         self._xml_empty_tag("a:alpha", attributes)
 3397: 
 3398:     def _write_a_prst_dash(self, val):
 3399:         # Write the <a:prstDash> element.
 3400: 
 3401:         attributes = [("val", val)]
 3402: 
 3403:         self._xml_empty_tag("a:prstDash", attributes)
 3404: 
 3405:     def _write_trendline(self, trendline):
 3406:         # Write the <c:trendline> element.
 3407: 
 3408:         if not trendline:
 3409:             return
 3410: 
 3411:         self._xml_start_tag("c:trendline")
 3412: 
 3413:         # Write the c:name element.
 3414:         self._write_name(trendline.get("name"))
 3415: 
 3416:         # Write the c:spPr element.
 3417:         self._write_sp_pr(trendline)
 3418: 
 3419:         # Write the c:trendlineType element.
 3420:         self._write_trendline_type(trendline["type"])
 3421: 
 3422:         # Write the c:order element for polynomial trendlines.
 3423:         if trendline["type"] == "poly":
 3424:             self._write_trendline_order(trendline.get("order"))
 3425: 
 3426:         # Write the c:period element for moving average trendlines.
 3427:         if trendline["type"] == "movingAvg":
 3428:             self._write_period(trendline.get("period"))
 3429: 
 3430:         # Write the c:forward element.
 3431:         self._write_forward(trendline.get("forward"))
 3432: 
 3433:         # Write the c:backward element.
 3434:         self._write_backward(trendline.get("backward"))
 3435: 
 3436:         if "intercept" in trendline:
 3437:             # Write the c:intercept element.
 3438:             self._write_c_intercept(trendline["intercept"])
 3439: 
 3440:         if trendline.get("display_r_squared"):
 3441:             # Write the c:dispRSqr element.
 3442:             self._write_c_disp_rsqr()
 3443: 
 3444:         if trendline.get("display_equation"):
 3445:             # Write the c:dispEq element.
 3446:             self._write_c_disp_eq()
 3447: 
 3448:             # Write the c:trendlineLbl element.
 3449:             self._write_c_trendline_lbl(trendline)
 3450: 
 3451:         self._xml_end_tag("c:trendline")
 3452: 
 3453:     def _write_trendline_type(self, val):
 3454:         # Write the <c:trendlineType> element.
 3455: 
 3456:         attributes = [("val", val)]
 3457: 
 3458:         self._xml_empty_tag("c:trendlineType", attributes)
 3459: 
 3460:     def _write_name(self, data):
 3461:         # Write the <c:name> element.
 3462: 
 3463:         if data is None:
 3464:             return
 3465: 
 3466:         self._xml_data_element("c:name", data)
 3467: 
 3468:     def _write_trendline_order(self, val):
 3469:         # Write the <c:order> element.
 3470:         if val < 2:
 3471:             val = 2
 3472: 
 3473:         attributes = [("val", val)]
 3474: 
 3475:         self._xml_empty_tag("c:order", attributes)
 3476: 
 3477:     def _write_period(self, val):
 3478:         # Write the <c:period> element.
 3479:         if val < 2:
 3480:             val = 2
 3481: 
 3482:         attributes = [("val", val)]
 3483: 
 3484:         self._xml_empty_tag("c:period", attributes)
 3485: 
 3486:     def _write_forward(self, val):
 3487:         # Write the <c:forward> element.
 3488: 
 3489:         if not val:
 3490:             return
 3491: 
 3492:         attributes = [("val", val)]
 3493: 
 3494:         self._xml_empty_tag("c:forward", attributes)
 3495: 
 3496:     def _write_backward(self, val):
 3497:         # Write the <c:backward> element.
 3498: 
 3499:         if not val:
 3500:             return
 3501: 
 3502:         attributes = [("val", val)]
 3503: 
 3504:         self._xml_empty_tag("c:backward", attributes)
 3505: 
 3506:     def _write_c_intercept(self, val):
 3507:         # Write the <c:intercept> element.
 3508:         attributes = [("val", val)]
 3509: 
 3510:         self._xml_empty_tag("c:intercept", attributes)
 3511: 
 3512:     def _write_c_disp_eq(self):
 3513:         # Write the <c:dispEq> element.
 3514:         attributes = [("val", 1)]
 3515: 
 3516:         self._xml_empty_tag("c:dispEq", attributes)
 3517: 
 3518:     def _write_c_disp_rsqr(self):
 3519:         # Write the <c:dispRSqr> element.
 3520:         attributes = [("val", 1)]
 3521: 
 3522:         self._xml_empty_tag("c:dispRSqr", attributes)
 3523: 
 3524:     def _write_c_trendline_lbl(self, trendline):
 3525:         # Write the <c:trendlineLbl> element.
 3526:         self._xml_start_tag("c:trendlineLbl")
 3527: 
 3528:         # Write the c:layout element.
 3529:         self._write_layout(None, None)
 3530: 
 3531:         # Write the c:numFmt element.
 3532:         self._write_trendline_num_fmt()
 3533: 
 3534:         # Write the c:spPr element.
 3535:         self._write_sp_pr(trendline["label"])
 3536: 
 3537:         # Write the data label font elements.
 3538:         if trendline["label"]:
 3539:             font = trendline["label"].get("font")
 3540:             if font:
 3541:                 self._write_axis_font(font)
 3542: 
 3543:         self._xml_end_tag("c:trendlineLbl")
 3544: 
 3545:     def _write_trendline_num_fmt(self):
 3546:         # Write the <c:numFmt> element.
 3547:         attributes = [
 3548:             ("formatCode", "General"),
 3549:             ("sourceLinked", 0),
 3550:         ]
 3551: 
 3552:         self._xml_empty_tag("c:numFmt", attributes)
 3553: 
 3554:     def _write_hi_low_lines(self):
 3555:         # Write the <c:hiLowLines> element.
 3556:         hi_low_lines = self.hi_low_lines
 3557: 
 3558:         if hi_low_lines is None:
 3559:             return
 3560: 
 3561:         if "line" in hi_low_lines and hi_low_lines["line"]["defined"]:
 3562:             self._xml_start_tag("c:hiLowLines")
 3563: 
 3564:             # Write the c:spPr element.
 3565:             self._write_sp_pr(hi_low_lines)
 3566: 
 3567:             self._xml_end_tag("c:hiLowLines")
 3568:         else:
 3569:             self._xml_empty_tag("c:hiLowLines")
 3570: 
 3571:     def _write_drop_lines(self):
 3572:         # Write the <c:dropLines> element.
 3573:         drop_lines = self.drop_lines
 3574: 
 3575:         if drop_lines is None:
 3576:             return
 3577: 
 3578:         if drop_lines["line"]["defined"]:
 3579:             self._xml_start_tag("c:dropLines")
 3580: 
 3581:             # Write the c:spPr element.
 3582:             self._write_sp_pr(drop_lines)
 3583: 
 3584:             self._xml_end_tag("c:dropLines")
 3585:         else:
 3586:             self._xml_empty_tag("c:dropLines")
 3587: 
 3588:     def _write_overlap(self, val):
 3589:         # Write the <c:overlap> element.
 3590: 
 3591:         if val is None:
 3592:             return
 3593: 
 3594:         attributes = [("val", val)]
 3595: 
 3596:         self._xml_empty_tag("c:overlap", attributes)
 3597: 
 3598:     def _write_num_cache(self, data):
 3599:         # Write the <c:numCache> element.
 3600:         if data:
 3601:             count = len(data)
 3602:         else:
 3603:             count = 0
 3604: 
 3605:         self._xml_start_tag("c:numCache")
 3606: 
 3607:         # Write the c:formatCode element.
 3608:         self._write_format_code("General")
 3609: 
 3610:         # Write the c:ptCount element.
 3611:         self._write_pt_count(count)
 3612: 
 3613:         for i in range(count):
 3614:             token = data[i]
 3615: 
 3616:             if token is None:
 3617:                 continue
 3618: 
 3619:             try:
 3620:                 float(token)
 3621:             except ValueError:
 3622:                 # Write non-numeric data as 0.
 3623:                 token = 0
 3624: 
 3625:             # Write the c:pt element.
 3626:             self._write_pt(i, token)
 3627: 
 3628:         self._xml_end_tag("c:numCache")
 3629: 
 3630:     def _write_str_cache(self, data):
 3631:         # Write the <c:strCache> element.
 3632:         count = len(data)
 3633: 
 3634:         self._xml_start_tag("c:strCache")
 3635: 
 3636:         # Write the c:ptCount element.
 3637:         self._write_pt_count(count)
 3638: 
 3639:         for i in range(count):
 3640:             # Write the c:pt element.
 3641:             self._write_pt(i, data[i])
 3642: 
 3643:         self._xml_end_tag("c:strCache")
 3644: 
 3645:     def _write_format_code(self, data):
 3646:         # Write the <c:formatCode> element.
 3647: 
 3648:         self._xml_data_element("c:formatCode", data)
 3649: 
 3650:     def _write_pt_count(self, val):
 3651:         # Write the <c:ptCount> element.
 3652: 
 3653:         attributes = [("val", val)]
 3654: 
 3655:         self._xml_empty_tag("c:ptCount", attributes)
 3656: 
 3657:     def _write_pt(self, idx, value):
 3658:         # Write the <c:pt> element.
 3659: 
 3660:         if value is None:
 3661:             return
 3662: 
 3663:         attributes = [("idx", idx)]
 3664: 
 3665:         self._xml_start_tag("c:pt", attributes)
 3666: 
 3667:         # Write the c:v element.
 3668:         self._write_v(value)
 3669: 
 3670:         self._xml_end_tag("c:pt")
 3671: 
 3672:     def _write_v(self, data):
 3673:         # Write the <c:v> element.
 3674: 
 3675:         self._xml_data_element("c:v", data)
 3676: 
 3677:     def _write_protection(self):
 3678:         # Write the <c:protection> element.
 3679:         if not self.protection:
 3680:             return
 3681: 
 3682:         self._xml_empty_tag("c:protection")
 3683: 
 3684:     def _write_d_pt(self, points):
 3685:         # Write the <c:dPt> elements.
 3686:         index = -1
 3687: 
 3688:         if not points:
 3689:             return
 3690: 
 3691:         for point in points:
 3692:             index += 1
 3693:             if not point:
 3694:                 continue
 3695: 
 3696:             self._write_d_pt_point(index, point)
 3697: 
 3698:     def _write_d_pt_point(self, index, point):
 3699:         # Write an individual <c:dPt> element.
 3700: 
 3701:         self._xml_start_tag("c:dPt")
 3702: 
 3703:         # Write the c:idx element.
 3704:         self._write_idx(index)
 3705: 
 3706:         # Write the c:spPr element.
 3707:         self._write_sp_pr(point)
 3708: 
 3709:         self._xml_end_tag("c:dPt")
 3710: 
 3711:     def _write_d_lbls(self, labels):
 3712:         # Write the <c:dLbls> element.
 3713: 
 3714:         if not labels:
 3715:             return
 3716: 
 3717:         self._xml_start_tag("c:dLbls")
 3718: 
 3719:         # Write the custom c:dLbl elements.
 3720:         if labels.get("custom"):
 3721:             self._write_custom_labels(labels, labels["custom"])
 3722: 
 3723:         # Write the c:numFmt element.
 3724:         if labels.get("num_format"):
 3725:             self._write_data_label_number_format(labels["num_format"])
 3726: 
 3727:         # Write the c:spPr element for the plotarea formatting.
 3728:         self._write_sp_pr(labels)
 3729: 
 3730:         # Write the data label font elements.
 3731:         if labels.get("font"):
 3732:             self._write_axis_font(labels["font"])
 3733: 
 3734:         # Write the c:dLblPos element.
 3735:         if labels.get("position"):
 3736:             self._write_d_lbl_pos(labels["position"])
 3737: 
 3738:         # Write the c:showLegendKey element.
 3739:         if labels.get("legend_key"):
 3740:             self._write_show_legend_key()
 3741: 
 3742:         # Write the c:showVal element.
 3743:         if labels.get("value"):
 3744:             self._write_show_val()
 3745: 
 3746:         # Write the c:showCatName element.
 3747:         if labels.get("category"):
 3748:             self._write_show_cat_name()
 3749: 
 3750:         # Write the c:showSerName element.
 3751:         if labels.get("series_name"):
 3752:             self._write_show_ser_name()
 3753: 
 3754:         # Write the c:showPercent element.
 3755:         if labels.get("percentage"):
 3756:             self._write_show_percent()
 3757: 
 3758:         # Write the c:separator element.
 3759:         if labels.get("separator"):
 3760:             self._write_separator(labels["separator"])
 3761: 
 3762:         # Write the c:showLeaderLines element.
 3763:         if labels.get("leader_lines"):
 3764:             self._write_show_leader_lines()
 3765: 
 3766:         self._xml_end_tag("c:dLbls")
 3767: 
 3768:     def _write_custom_labels(self, parent, labels):
 3769:         # Write the <c:showLegendKey> element.
 3770:         index = 0
 3771: 
 3772:         for label in labels:
 3773:             index += 1
 3774: 
 3775:             if label is None:
 3776:                 continue
 3777: 
 3778:             self._xml_start_tag("c:dLbl")
 3779: 
 3780:             # Write the c:idx element.
 3781:             self._write_idx(index - 1)
 3782: 
 3783:             delete_label = label.get("delete")
 3784: 
 3785:             if delete_label:
 3786:                 self._write_delete(1)
 3787: 
 3788:             elif label.get("formula"):
 3789:                 self._write_custom_label_formula(label)
 3790: 
 3791:                 if parent.get("position"):
 3792:                     self._write_d_lbl_pos(parent["position"])
 3793: 
 3794:                 if parent.get("value"):
 3795:                     self._write_show_val()
 3796:                 if parent.get("category"):
 3797:                     self._write_show_cat_name()
 3798:                 if parent.get("series_name"):
 3799:                     self._write_show_ser_name()
 3800: 
 3801:             elif label.get("value"):
 3802:                 self._write_custom_label_str(label)
 3803: 
 3804:                 if parent.get("position"):
 3805:                     self._write_d_lbl_pos(parent["position"])
 3806: 
 3807:                 if parent.get("value"):
 3808:                     self._write_show_val()
 3809:                 if parent.get("category"):
 3810:                     self._write_show_cat_name()
 3811:                 if parent.get("series_name"):
 3812:                     self._write_show_ser_name()
 3813:             else:
 3814:                 self._write_custom_label_format_only(label)
 3815: 
 3816:             self._xml_end_tag("c:dLbl")
 3817: 
 3818:     def _write_custom_label_str(self, label):
 3819:         # Write parts of the <c:dLbl> element for strings.
 3820:         title = label.get("value")
 3821:         font = label.get("font")
 3822:         has_formatting = self._has_fill_formatting(label)
 3823: 
 3824:         # Write the c:layout element.
 3825:         self._write_layout(None, None)
 3826: 
 3827:         self._xml_start_tag("c:tx")
 3828: 
 3829:         # Write the c:rich element.
 3830:         self._write_rich(title, font, False, not has_formatting)
 3831: 
 3832:         self._xml_end_tag("c:tx")
 3833: 
 3834:         # Write the c:spPr element.
 3835:         self._write_sp_pr(label)
 3836: 
 3837:     def _write_custom_label_formula(self, label):
 3838:         # Write parts of the <c:dLbl> element for formulas.
 3839:         formula = label.get("formula")
 3840:         data_id = label.get("data_id")
 3841:         data = None
 3842: 
 3843:         if data_id is not None:
 3844:             data = self.formula_data[data_id]
 3845: 
 3846:         # Write the c:layout element.
 3847:         self._write_layout(None, None)
 3848: 
 3849:         self._xml_start_tag("c:tx")
 3850: 
 3851:         # Write the c:strRef element.
 3852:         self._write_str_ref(formula, data, "str")
 3853: 
 3854:         self._xml_end_tag("c:tx")
 3855: 
 3856:         # Write the data label formatting, if any.
 3857:         self._write_custom_label_format_only(label)
 3858: 
 3859:     def _write_custom_label_format_only(self, label):
 3860:         # Write parts of the <c:dLbl> labels with changed formatting.
 3861:         font = label.get("font")
 3862:         has_formatting = self._has_fill_formatting(label)
 3863: 
 3864:         if has_formatting:
 3865:             self._write_sp_pr(label)
 3866:             self._write_tx_pr(font)
 3867:         elif font:
 3868:             self._xml_empty_tag("c:spPr")
 3869:             self._write_tx_pr(font)
 3870: 
 3871:     def _write_show_legend_key(self):
 3872:         # Write the <c:showLegendKey> element.
 3873:         val = "1"
 3874: 
 3875:         attributes = [("val", val)]
 3876: 
 3877:         self._xml_empty_tag("c:showLegendKey", attributes)
 3878: 
 3879:     def _write_show_val(self):
 3880:         # Write the <c:showVal> element.
 3881:         val = 1
 3882: 
 3883:         attributes = [("val", val)]
 3884: 
 3885:         self._xml_empty_tag("c:showVal", attributes)
 3886: 
 3887:     def _write_show_cat_name(self):
 3888:         # Write the <c:showCatName> element.
 3889:         val = 1
 3890: 
 3891:         attributes = [("val", val)]
 3892: 
 3893:         self._xml_empty_tag("c:showCatName", attributes)
 3894: 
 3895:     def _write_show_ser_name(self):
 3896:         # Write the <c:showSerName> element.
 3897:         val = 1
 3898: 
 3899:         attributes = [("val", val)]
 3900: 
 3901:         self._xml_empty_tag("c:showSerName", attributes)
 3902: 
 3903:     def _write_show_percent(self):
 3904:         # Write the <c:showPercent> element.
 3905:         val = 1
 3906: 
 3907:         attributes = [("val", val)]
 3908: 
 3909:         self._xml_empty_tag("c:showPercent", attributes)
 3910: 
 3911:     def _write_separator(self, data):
 3912:         # Write the <c:separator> element.
 3913:         self._xml_data_element("c:separator", data)
 3914: 
 3915:     def _write_show_leader_lines(self):
 3916:         # Write the <c:showLeaderLines> element.
 3917:         #
 3918:         # This is different for Pie/Doughnut charts. Other chart types only
 3919:         # supported leader lines after Excel 2015 via an extension element.
 3920:         #
 3921:         uri = "{CE6537A1-D6FC-4f65-9D91-7224C49458BB}"
 3922:         xmlns_c_15 = "http://schemas.microsoft.com/office/drawing/2012/chart"
 3923: 
 3924:         attributes = [
 3925:             ("uri", uri),
 3926:             ("xmlns:c15", xmlns_c_15),
 3927:         ]
 3928: 
 3929:         self._xml_start_tag("c:extLst")
 3930:         self._xml_start_tag("c:ext", attributes)
 3931:         self._xml_empty_tag("c15:showLeaderLines", [("val", 1)])
 3932:         self._xml_end_tag("c:ext")
 3933:         self._xml_end_tag("c:extLst")
 3934: 
 3935:     def _write_d_lbl_pos(self, val):
 3936:         # Write the <c:dLblPos> element.
 3937: 
 3938:         attributes = [("val", val)]
 3939: 
 3940:         self._xml_empty_tag("c:dLblPos", attributes)
 3941: 
 3942:     def _write_delete(self, val):
 3943:         # Write the <c:delete> element.
 3944: 
 3945:         attributes = [("val", val)]
 3946: 
 3947:         self._xml_empty_tag("c:delete", attributes)
 3948: 
 3949:     def _write_c_invert_if_negative(self, invert):
 3950:         # Write the <c:invertIfNegative> element.
 3951:         val = 1
 3952: 
 3953:         if not invert:
 3954:             return
 3955: 
 3956:         attributes = [("val", val)]
 3957: 
 3958:         self._xml_empty_tag("c:invertIfNegative", attributes)
 3959: 
 3960:     def _write_axis_font(self, font):
 3961:         # Write the axis font elements.
 3962: 
 3963:         if not font:
 3964:             return
 3965: 
 3966:         self._xml_start_tag("c:txPr")
 3967:         self._write_a_body_pr(font.get("rotation"), None)
 3968:         self._write_a_lst_style()
 3969:         self._xml_start_tag("a:p")
 3970: 
 3971:         self._write_a_p_pr_rich(font)
 3972: 
 3973:         self._write_a_end_para_rpr()
 3974:         self._xml_end_tag("a:p")
 3975:         self._xml_end_tag("c:txPr")
 3976: 
 3977:     def _write_a_latin(self, attributes):
 3978:         # Write the <a:latin> element.
 3979:         self._xml_empty_tag("a:latin", attributes)
 3980: 
 3981:     def _write_d_table(self):
 3982:         # Write the <c:dTable> element.
 3983:         table = self.table
 3984: 
 3985:         if not table:
 3986:             return
 3987: 
 3988:         self._xml_start_tag("c:dTable")
 3989: 
 3990:         if table["horizontal"]:
 3991:             # Write the c:showHorzBorder element.
 3992:             self._write_show_horz_border()
 3993: 
 3994:         if table["vertical"]:
 3995:             # Write the c:showVertBorder element.
 3996:             self._write_show_vert_border()
 3997: 
 3998:         if table["outline"]:
 3999:             # Write the c:showOutline element.
 4000:             self._write_show_outline()
 4001: 
 4002:         if table["show_keys"]:
 4003:             # Write the c:showKeys element.
 4004:             self._write_show_keys()
 4005: 
 4006:         if table["font"]:
 4007:             # Write the table font.
 4008:             self._write_tx_pr(table["font"])
 4009: 
 4010:         self._xml_end_tag("c:dTable")
 4011: 
 4012:     def _write_show_horz_border(self):
 4013:         # Write the <c:showHorzBorder> element.
 4014:         attributes = [("val", 1)]
 4015: 
 4016:         self._xml_empty_tag("c:showHorzBorder", attributes)
 4017: 
 4018:     def _write_show_vert_border(self):
 4019:         # Write the <c:showVertBorder> element.
 4020:         attributes = [("val", 1)]
 4021: 
 4022:         self._xml_empty_tag("c:showVertBorder", attributes)
 4023: 
 4024:     def _write_show_outline(self):
 4025:         # Write the <c:showOutline> element.
 4026:         attributes = [("val", 1)]
 4027: 
 4028:         self._xml_empty_tag("c:showOutline", attributes)
 4029: 
 4030:     def _write_show_keys(self):
 4031:         # Write the <c:showKeys> element.
 4032:         attributes = [("val", 1)]
 4033: 
 4034:         self._xml_empty_tag("c:showKeys", attributes)
 4035: 
 4036:     def _write_error_bars(self, error_bars):
 4037:         # Write the X and Y error bars.
 4038: 
 4039:         if not error_bars:
 4040:             return
 4041: 
 4042:         if error_bars["x_error_bars"]:
 4043:             self._write_err_bars("x", error_bars["x_error_bars"])
 4044: 
 4045:         if error_bars["y_error_bars"]:
 4046:             self._write_err_bars("y", error_bars["y_error_bars"])
 4047: 
 4048:     def _write_err_bars(self, direction, error_bars):
 4049:         # Write the <c:errBars> element.
 4050: 
 4051:         if not error_bars:
 4052:             return
 4053: 
 4054:         self._xml_start_tag("c:errBars")
 4055: 
 4056:         # Write the c:errDir element.
 4057:         self._write_err_dir(direction)
 4058: 
 4059:         # Write the c:errBarType element.
 4060:         self._write_err_bar_type(error_bars["direction"])
 4061: 
 4062:         # Write the c:errValType element.
 4063:         self._write_err_val_type(error_bars["type"])
 4064: 
 4065:         if not error_bars["endcap"]:
 4066:             # Write the c:noEndCap element.
 4067:             self._write_no_end_cap()
 4068: 
 4069:         if error_bars["type"] == "stdErr":
 4070:             # Don't need to write a c:errValType tag.
 4071:             pass
 4072:         elif error_bars["type"] == "cust":
 4073:             # Write the custom error tags.
 4074:             self._write_custom_error(error_bars)
 4075:         else:
 4076:             # Write the c:val element.
 4077:             self._write_error_val(error_bars["value"])
 4078: 
 4079:         # Write the c:spPr element.
 4080:         self._write_sp_pr(error_bars)
 4081: 
 4082:         self._xml_end_tag("c:errBars")
 4083: 
 4084:     def _write_err_dir(self, val):
 4085:         # Write the <c:errDir> element.
 4086: 
 4087:         attributes = [("val", val)]
 4088: 
 4089:         self._xml_empty_tag("c:errDir", attributes)
 4090: 
 4091:     def _write_err_bar_type(self, val):
 4092:         # Write the <c:errBarType> element.
 4093: 
 4094:         attributes = [("val", val)]
 4095: 
 4096:         self._xml_empty_tag("c:errBarType", attributes)
 4097: 
 4098:     def _write_err_val_type(self, val):
 4099:         # Write the <c:errValType> element.
 4100: 
 4101:         attributes = [("val", val)]
 4102: 
 4103:         self._xml_empty_tag("c:errValType", attributes)
 4104: 
 4105:     def _write_no_end_cap(self):
 4106:         # Write the <c:noEndCap> element.
 4107:         attributes = [("val", 1)]
 4108: 
 4109:         self._xml_empty_tag("c:noEndCap", attributes)
 4110: 
 4111:     def _write_error_val(self, val):
 4112:         # Write the <c:val> element for error bars.
 4113: 
 4114:         attributes = [("val", val)]
 4115: 
 4116:         self._xml_empty_tag("c:val", attributes)
 4117: 
 4118:     def _write_custom_error(self, error_bars):
 4119:         # Write the custom error bars tags.
 4120: 
 4121:         if error_bars["plus_values"]:
 4122:             # Write the c:plus element.
 4123:             self._xml_start_tag("c:plus")
 4124: 
 4125:             if isinstance(error_bars["plus_values"], list):
 4126:                 self._write_num_lit(error_bars["plus_values"])
 4127:             else:
 4128:                 self._write_num_ref(
 4129:                     error_bars["plus_values"], error_bars["plus_data"], "num"
 4130:                 )
 4131:             self._xml_end_tag("c:plus")
 4132: 
 4133:         if error_bars["minus_values"]:
 4134:             # Write the c:minus element.
 4135:             self._xml_start_tag("c:minus")
 4136: 
 4137:             if isinstance(error_bars["minus_values"], list):
 4138:                 self._write_num_lit(error_bars["minus_values"])
 4139:             else:
 4140:                 self._write_num_ref(
 4141:                     error_bars["minus_values"], error_bars["minus_data"], "num"
 4142:                 )
 4143:             self._xml_end_tag("c:minus")
 4144: 
 4145:     def _write_num_lit(self, data):
 4146:         # Write the <c:numLit> element for literal number list elements.
 4147:         count = len(data)
 4148: 
 4149:         # Write the c:numLit element.
 4150:         self._xml_start_tag("c:numLit")
 4151: 
 4152:         # Write the c:formatCode element.
 4153:         self._write_format_code("General")
 4154: 
 4155:         # Write the c:ptCount element.
 4156:         self._write_pt_count(count)
 4157: 
 4158:         for i in range(count):
 4159:             token = data[i]
 4160: 
 4161:             if token is None:
 4162:                 continue
 4163: 
 4164:             try:
 4165:                 float(token)
 4166:             except ValueError:
 4167:                 # Write non-numeric data as 0.
 4168:                 token = 0
 4169: 
 4170:             # Write the c:pt element.
 4171:             self._write_pt(i, token)
 4172: 
 4173:         self._xml_end_tag("c:numLit")
 4174: 
 4175:     def _write_up_down_bars(self):
 4176:         # Write the <c:upDownBars> element.
 4177:         up_down_bars = self.up_down_bars
 4178: 
 4179:         if up_down_bars is None:
 4180:             return
 4181: 
 4182:         self._xml_start_tag("c:upDownBars")
 4183: 
 4184:         # Write the c:gapWidth element.
 4185:         self._write_gap_width(150)
 4186: 
 4187:         # Write the c:upBars element.
 4188:         self._write_up_bars(up_down_bars.get("up"))
 4189: 
 4190:         # Write the c:downBars element.
 4191:         self._write_down_bars(up_down_bars.get("down"))
 4192: 
 4193:         self._xml_end_tag("c:upDownBars")
 4194: 
 4195:     def _write_gap_width(self, val):
 4196:         # Write the <c:gapWidth> element.
 4197: 
 4198:         if val is None:
 4199:             return
 4200: 
 4201:         attributes = [("val", val)]
 4202: 
 4203:         self._xml_empty_tag("c:gapWidth", attributes)
 4204: 
 4205:     def _write_up_bars(self, bar_format):
 4206:         # Write the <c:upBars> element.
 4207: 
 4208:         if bar_format["line"] and bar_format["line"]["defined"]:
 4209:             self._xml_start_tag("c:upBars")
 4210: 
 4211:             # Write the c:spPr element.
 4212:             self._write_sp_pr(bar_format)
 4213: 
 4214:             self._xml_end_tag("c:upBars")
 4215:         else:
 4216:             self._xml_empty_tag("c:upBars")
 4217: 
 4218:     def _write_down_bars(self, bar_format):
 4219:         # Write the <c:downBars> element.
 4220: 
 4221:         if bar_format["line"] and bar_format["line"]["defined"]:
 4222:             self._xml_start_tag("c:downBars")
 4223: 
 4224:             # Write the c:spPr element.
 4225:             self._write_sp_pr(bar_format)
 4226: 
 4227:             self._xml_end_tag("c:downBars")
 4228:         else:
 4229:             self._xml_empty_tag("c:downBars")
 4230: 
 4231:     def _write_disp_units(self, units, display):
 4232:         # Write the <c:dispUnits> element.
 4233: 
 4234:         if not units:
 4235:             return
 4236: 
 4237:         attributes = [("val", units)]
 4238: 
 4239:         self._xml_start_tag("c:dispUnits")
 4240:         self._xml_empty_tag("c:builtInUnit", attributes)
 4241: 
 4242:         if display:
 4243:             self._xml_start_tag("c:dispUnitsLbl")
 4244:             self._xml_empty_tag("c:layout")
 4245:             self._xml_end_tag("c:dispUnitsLbl")
 4246: 
 4247:         self._xml_end_tag("c:dispUnits")
 4248: 
 4249:     def _write_a_grad_fill(self, gradient):
 4250:         # Write the <a:gradFill> element.
 4251: 
 4252:         attributes = [("flip", "none"), ("rotWithShape", "1")]
 4253: 
 4254:         if gradient["type"] == "linear":
 4255:             attributes = []
 4256: 
 4257:         self._xml_start_tag("a:gradFill", attributes)
 4258: 
 4259:         # Write the a:gsLst element.
 4260:         self._write_a_gs_lst(gradient)
 4261: 
 4262:         if gradient["type"] == "linear":
 4263:             # Write the a:lin element.
 4264:             self._write_a_lin(gradient["angle"])
 4265:         else:
 4266:             # Write the a:path element.
 4267:             self._write_a_path(gradient["type"])
 4268: 
 4269:             # Write the a:tileRect element.
 4270:             self._write_a_tile_rect(gradient["type"])
 4271: 
 4272:         self._xml_end_tag("a:gradFill")
 4273: 
 4274:     def _write_a_gs_lst(self, gradient):
 4275:         # Write the <a:gsLst> element.
 4276:         positions = gradient["positions"]
 4277:         colors = gradient["colors"]
 4278: 
 4279:         self._xml_start_tag("a:gsLst")
 4280: 
 4281:         for i in range(len(colors)):
 4282:             pos = int(positions[i] * 1000)
 4283:             attributes = [("pos", pos)]
 4284:             self._xml_start_tag("a:gs", attributes)
 4285: 
 4286:             # Write the a:srgbClr element.
 4287:             color = get_rgb_color(colors[i])
 4288:             self._write_a_srgb_clr(color)
 4289: 
 4290:             self._xml_end_tag("a:gs")
 4291: 
 4292:         self._xml_end_tag("a:gsLst")
 4293: 
 4294:     def _write_a_lin(self, angle):
 4295:         # Write the <a:lin> element.
 4296: 
 4297:         angle = int(60000 * angle)
 4298: 
 4299:         attributes = [
 4300:             ("ang", angle),
 4301:             ("scaled", "0"),
 4302:         ]
 4303: 
 4304:         self._xml_empty_tag("a:lin", attributes)
 4305: 
 4306:     def _write_a_path(self, gradient_type):
 4307:         # Write the <a:path> element.
 4308: 
 4309:         attributes = [("path", gradient_type)]
 4310: 
 4311:         self._xml_start_tag("a:path", attributes)
 4312: 
 4313:         # Write the a:fillToRect element.
 4314:         self._write_a_fill_to_rect(gradient_type)
 4315: 
 4316:         self._xml_end_tag("a:path")
 4317: 
 4318:     def _write_a_fill_to_rect(self, gradient_type):
 4319:         # Write the <a:fillToRect> element.
 4320: 
 4321:         if gradient_type == "shape":
 4322:             attributes = [
 4323:                 ("l", "50000"),
 4324:                 ("t", "50000"),
 4325:                 ("r", "50000"),
 4326:                 ("b", "50000"),
 4327:             ]
 4328:         else:
 4329:             attributes = [
 4330:                 ("l", "100000"),
 4331:                 ("t", "100000"),
 4332:             ]
 4333: 
 4334:         self._xml_empty_tag("a:fillToRect", attributes)
 4335: 
 4336:     def _write_a_tile_rect(self, gradient_type):
 4337:         # Write the <a:tileRect> element.
 4338: 
 4339:         if gradient_type == "shape":
 4340:             attributes = []
 4341:         else:
 4342:             attributes = [
 4343:                 ("r", "-100000"),
 4344:                 ("b", "-100000"),
 4345:             ]
 4346: 
 4347:         self._xml_empty_tag("a:tileRect", attributes)
 4348: 
 4349:     def _write_a_patt_fill(self, pattern):
 4350:         # Write the <a:pattFill> element.
 4351: 
 4352:         attributes = [("prst", pattern["pattern"])]
 4353: 
 4354:         self._xml_start_tag("a:pattFill", attributes)
 4355: 
 4356:         # Write the a:fgClr element.
 4357:         self._write_a_fg_clr(pattern["fg_color"])
 4358: 
 4359:         # Write the a:bgClr element.
 4360:         self._write_a_bg_clr(pattern["bg_color"])
 4361: 
 4362:         self._xml_end_tag("a:pattFill")
 4363: 
 4364:     def _write_a_fg_clr(self, color):
 4365:         # Write the <a:fgClr> element.
 4366: 
 4367:         color = get_rgb_color(color)
 4368: 
 4369:         self._xml_start_tag("a:fgClr")
 4370: 
 4371:         # Write the a:srgbClr element.
 4372:         self._write_a_srgb_clr(color)
 4373: 
 4374:         self._xml_end_tag("a:fgClr")
 4375: 
 4376:     def _write_a_bg_clr(self, color):
 4377:         # Write the <a:bgClr> element.
 4378: 
 4379:         color = get_rgb_color(color)
 4380: 
 4381:         self._xml_start_tag("a:bgClr")
 4382: 
 4383:         # Write the a:srgbClr element.
 4384:         self._write_a_srgb_clr(color)
 4385: 
 4386:         self._xml_end_tag("a:bgClr")
