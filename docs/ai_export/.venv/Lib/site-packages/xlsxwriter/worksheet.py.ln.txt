    1: ###############################################################################
    2: #
    3: # Worksheet - A class for writing the Excel XLSX Worksheet file.
    4: #
    5: # SPDX-License-Identifier: BSD-2-Clause
    6: # Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
    7: #
    8: 
    9: # Standard packages.
   10: import datetime
   11: import math
   12: import os
   13: import re
   14: import tempfile
   15: 
   16: from collections import defaultdict
   17: from collections import namedtuple
   18: from decimal import Decimal
   19: from fractions import Fraction
   20: from functools import wraps
   21: from io import StringIO
   22: from math import isinf
   23: from math import isnan
   24: from warnings import warn
   25: 
   26: # Package imports.
   27: from . import xmlwriter
   28: from .format import Format
   29: from .drawing import Drawing
   30: from .shape import Shape
   31: from .xmlwriter import XMLwriter
   32: from .utility import xl_rowcol_to_cell
   33: from .utility import xl_rowcol_to_cell_fast
   34: from .utility import xl_cell_to_rowcol
   35: from .utility import xl_col_to_name
   36: from .utility import xl_range
   37: from .utility import xl_color
   38: from .utility import xl_pixel_width
   39: from .utility import get_sparkline_style
   40: from .utility import supported_datetime
   41: from .utility import datetime_to_excel_datetime
   42: from .utility import get_image_properties
   43: from .utility import preserve_whitespace
   44: from .utility import quote_sheetname
   45: from .exceptions import DuplicateTableName
   46: from .exceptions import OverlappingRange
   47: 
   48: re_dynamic_function = re.compile(
   49:     r"""
   50:     \bANCHORARRAY\(    |
   51:     \bBYCOL\(          |
   52:     \bBYROW\(          |
   53:     \bCHOOSECOLS\(     |
   54:     \bCHOOSEROWS\(     |
   55:     \bDROP\(           |
   56:     \bEXPAND\(         |
   57:     \bFILTER\(         |
   58:     \bHSTACK\(         |
   59:     \bLAMBDA\(         |
   60:     \bMAKEARRAY\(      |
   61:     \bMAP\(            |
   62:     \bRANDARRAY\(      |
   63:     \bREDUCE\(         |
   64:     \bSCAN\(           |
   65:     \bSEQUENCE\(       |
   66:     \bSINGLE\(         |
   67:     \bSORT\(           |
   68:     \bSORTBY\(         |
   69:     \bSWITCH\(         |
   70:     \bTAKE\(           |
   71:     \bTEXTSPLIT\(      |
   72:     \bTOCOL\(          |
   73:     \bTOROW\(          |
   74:     \bUNIQUE\(         |
   75:     \bVSTACK\(         |
   76:     \bWRAPCOLS\(       |
   77:     \bWRAPROWS\(       |
   78:     \bXLOOKUP\(""",
   79:     re.VERBOSE,
   80: )
   81: 
   82: 
   83: ###############################################################################
   84: #
   85: # Decorator functions.
   86: #
   87: ###############################################################################
   88: def convert_cell_args(method):
   89:     """
   90:     Decorator function to convert A1 notation in cell method calls
   91:     to the default row/col notation.
   92: 
   93:     """
   94: 
   95:     @wraps(method)
   96:     def cell_wrapper(self, *args, **kwargs):
   97:         try:
   98:             # First arg is an int, default to row/col notation.
   99:             if args:
  100:                 first_arg = args[0]
  101:                 int(first_arg)
  102:         except ValueError:
  103:             # First arg isn't an int, convert to A1 notation.
  104:             new_args = xl_cell_to_rowcol(first_arg)
  105:             args = new_args + args[1:]
  106: 
  107:         return method(self, *args, **kwargs)
  108: 
  109:     return cell_wrapper
  110: 
  111: 
  112: def convert_range_args(method):
  113:     """
  114:     Decorator function to convert A1 notation in range method calls
  115:     to the default row/col notation.
  116: 
  117:     """
  118: 
  119:     @wraps(method)
  120:     def cell_wrapper(self, *args, **kwargs):
  121:         try:
  122:             # First arg is an int, default to row/col notation.
  123:             if args:
  124:                 int(args[0])
  125:         except ValueError:
  126:             # First arg isn't an int, convert to A1 notation.
  127:             if ":" in args[0]:
  128:                 cell_1, cell_2 = args[0].split(":")
  129:                 row_1, col_1 = xl_cell_to_rowcol(cell_1)
  130:                 row_2, col_2 = xl_cell_to_rowcol(cell_2)
  131:             else:
  132:                 row_1, col_1 = xl_cell_to_rowcol(args[0])
  133:                 row_2, col_2 = row_1, col_1
  134: 
  135:             new_args = [row_1, col_1, row_2, col_2]
  136:             new_args.extend(args[1:])
  137:             args = new_args
  138: 
  139:         return method(self, *args, **kwargs)
  140: 
  141:     return cell_wrapper
  142: 
  143: 
  144: def convert_column_args(method):
  145:     """
  146:     Decorator function to convert A1 notation in columns method calls
  147:     to the default row/col notation.
  148: 
  149:     """
  150: 
  151:     @wraps(method)
  152:     def column_wrapper(self, *args, **kwargs):
  153:         try:
  154:             # First arg is an int, default to row/col notation.
  155:             if args:
  156:                 int(args[0])
  157:         except ValueError:
  158:             # First arg isn't an int, convert to A1 notation.
  159:             cell_1, cell_2 = [col + "1" for col in args[0].split(":")]
  160:             _, col_1 = xl_cell_to_rowcol(cell_1)
  161:             _, col_2 = xl_cell_to_rowcol(cell_2)
  162:             new_args = [col_1, col_2]
  163:             new_args.extend(args[1:])
  164:             args = new_args
  165: 
  166:         return method(self, *args, **kwargs)
  167: 
  168:     return column_wrapper
  169: 
  170: 
  171: ###############################################################################
  172: #
  173: # Named tuples used for cell types.
  174: #
  175: ###############################################################################
  176: cell_string_tuple = namedtuple("String", "string, format")
  177: cell_number_tuple = namedtuple("Number", "number, format")
  178: cell_blank_tuple = namedtuple("Blank", "format")
  179: cell_boolean_tuple = namedtuple("Boolean", "boolean, format")
  180: cell_formula_tuple = namedtuple("Formula", "formula, format, value")
  181: cell_datetime_tuple = namedtuple("Datetime", "number, format")
  182: cell_arformula_tuple = namedtuple(
  183:     "ArrayFormula", "formula, format, value, range, atype"
  184: )
  185: cell_rich_string_tuple = namedtuple("RichString", "string, format, raw_string")
  186: cell_error_tuple = namedtuple("Error", "error, format, value")
  187: 
  188: 
  189: ###############################################################################
  190: #
  191: # Worksheet Class definition.
  192: #
  193: ###############################################################################
  194: class Worksheet(xmlwriter.XMLwriter):
  195:     """
  196:     A class for writing the Excel XLSX Worksheet file.
  197: 
  198:     """
  199: 
  200:     ###########################################################################
  201:     #
  202:     # Public API.
  203:     #
  204:     ###########################################################################
  205: 
  206:     def __init__(self):
  207:         """
  208:         Constructor.
  209: 
  210:         """
  211: 
  212:         super(Worksheet, self).__init__()
  213: 
  214:         self.name = None
  215:         self.index = None
  216:         self.str_table = None
  217:         self.palette = None
  218:         self.constant_memory = 0
  219:         self.tmpdir = None
  220:         self.is_chartsheet = False
  221: 
  222:         self.ext_sheets = []
  223:         self.fileclosed = 0
  224:         self.excel_version = 2007
  225:         self.excel2003_style = False
  226: 
  227:         self.xls_rowmax = 1048576
  228:         self.xls_colmax = 16384
  229:         self.xls_strmax = 32767
  230:         self.dim_rowmin = None
  231:         self.dim_rowmax = None
  232:         self.dim_colmin = None
  233:         self.dim_colmax = None
  234: 
  235:         self.col_info = {}
  236:         self.selections = []
  237:         self.hidden = 0
  238:         self.active = 0
  239:         self.tab_color = 0
  240:         self.top_left_cell = ""
  241: 
  242:         self.panes = []
  243:         self.active_pane = 3
  244:         self.selected = 0
  245: 
  246:         self.page_setup_changed = False
  247:         self.paper_size = 0
  248:         self.orientation = 1
  249: 
  250:         self.print_options_changed = False
  251:         self.hcenter = False
  252:         self.vcenter = False
  253:         self.print_gridlines = False
  254:         self.screen_gridlines = True
  255:         self.print_headers = False
  256:         self.row_col_headers = False
  257: 
  258:         self.header_footer_changed = False
  259:         self.header = ""
  260:         self.footer = ""
  261:         self.header_footer_aligns = True
  262:         self.header_footer_scales = True
  263:         self.header_images = []
  264:         self.footer_images = []
  265:         self.header_images_list = []
  266: 
  267:         self.margin_left = 0.7
  268:         self.margin_right = 0.7
  269:         self.margin_top = 0.75
  270:         self.margin_bottom = 0.75
  271:         self.margin_header = 0.3
  272:         self.margin_footer = 0.3
  273: 
  274:         self.repeat_row_range = ""
  275:         self.repeat_col_range = ""
  276:         self.print_area_range = ""
  277: 
  278:         self.page_order = 0
  279:         self.black_white = 0
  280:         self.draft_quality = 0
  281:         self.print_comments = 0
  282:         self.page_start = 0
  283: 
  284:         self.fit_page = 0
  285:         self.fit_width = 0
  286:         self.fit_height = 0
  287: 
  288:         self.hbreaks = []
  289:         self.vbreaks = []
  290: 
  291:         self.protect_options = {}
  292:         self.protected_ranges = []
  293:         self.num_protected_ranges = 0
  294:         self.set_cols = {}
  295:         self.set_rows = defaultdict(dict)
  296: 
  297:         self.zoom = 100
  298:         self.zoom_scale_normal = 1
  299:         self.print_scale = 100
  300:         self.is_right_to_left = 0
  301:         self.show_zeros = 1
  302:         self.leading_zeros = 0
  303: 
  304:         self.outline_row_level = 0
  305:         self.outline_col_level = 0
  306:         self.outline_style = 0
  307:         self.outline_below = 1
  308:         self.outline_right = 1
  309:         self.outline_on = 1
  310:         self.outline_changed = False
  311: 
  312:         self.original_row_height = 15
  313:         self.default_row_height = 15
  314:         self.default_row_pixels = 20
  315:         self.default_col_width = 8.43
  316:         self.default_col_pixels = 64
  317:         self.default_date_pixels = 68
  318:         self.default_row_zeroed = 0
  319: 
  320:         self.names = {}
  321:         self.write_match = []
  322:         self.table = defaultdict(dict)
  323:         self.merge = []
  324:         self.merged_cells = {}
  325:         self.table_cells = {}
  326:         self.row_spans = {}
  327: 
  328:         self.has_vml = False
  329:         self.has_header_vml = False
  330:         self.has_comments = False
  331:         self.comments = defaultdict(dict)
  332:         self.comments_list = []
  333:         self.comments_author = ""
  334:         self.comments_visible = 0
  335:         self.vml_shape_id = 1024
  336:         self.buttons_list = []
  337:         self.vml_header_id = 0
  338: 
  339:         self.autofilter_area = ""
  340:         self.autofilter_ref = None
  341:         self.filter_range = []
  342:         self.filter_on = 0
  343:         self.filter_cols = {}
  344:         self.filter_type = {}
  345:         self.filter_cells = {}
  346: 
  347:         self.row_sizes = {}
  348:         self.col_size_changed = False
  349:         self.row_size_changed = False
  350: 
  351:         self.last_shape_id = 1
  352:         self.rel_count = 0
  353:         self.hlink_count = 0
  354:         self.hlink_refs = []
  355:         self.external_hyper_links = []
  356:         self.external_drawing_links = []
  357:         self.external_comment_links = []
  358:         self.external_vml_links = []
  359:         self.external_table_links = []
  360:         self.external_background_links = []
  361:         self.drawing_links = []
  362:         self.vml_drawing_links = []
  363:         self.charts = []
  364:         self.images = []
  365:         self.tables = []
  366:         self.sparklines = []
  367:         self.shapes = []
  368:         self.shape_hash = {}
  369:         self.drawing = 0
  370:         self.drawing_rels = {}
  371:         self.drawing_rels_id = 0
  372:         self.vml_drawing_rels = {}
  373:         self.vml_drawing_rels_id = 0
  374:         self.background_image = None
  375:         self.background_bytes = False
  376: 
  377:         self.rstring = ""
  378:         self.previous_row = 0
  379: 
  380:         self.validations = []
  381:         self.cond_formats = {}
  382:         self.data_bars_2010 = []
  383:         self.use_data_bars_2010 = False
  384:         self.dxf_priority = 1
  385:         self.page_view = 0
  386: 
  387:         self.vba_codename = None
  388: 
  389:         self.date_1904 = False
  390:         self.hyperlinks = defaultdict(dict)
  391: 
  392:         self.strings_to_numbers = False
  393:         self.strings_to_urls = True
  394:         self.nan_inf_to_errors = False
  395:         self.strings_to_formulas = True
  396: 
  397:         self.default_date_format = None
  398:         self.default_url_format = None
  399:         self.remove_timezone = False
  400:         self.max_url_length = 2079
  401: 
  402:         self.row_data_filename = None
  403:         self.row_data_fh = None
  404:         self.worksheet_meta = None
  405:         self.vml_data_id = None
  406:         self.vml_shape_id = None
  407: 
  408:         self.row_data_filename = None
  409:         self.row_data_fh = None
  410:         self.row_data_fh_closed = False
  411: 
  412:         self.vertical_dpi = 0
  413:         self.horizontal_dpi = 0
  414: 
  415:         self.write_handlers = {}
  416: 
  417:         self.ignored_errors = None
  418: 
  419:         self.has_dynamic_arrays = False
  420:         self.use_future_functions = False
  421:         self.ignore_write_string = False
  422: 
  423:     # Utility function for writing different types of strings.
  424:     def _write_token_as_string(self, token, row, col, *args):
  425:         # Map the data to the appropriate write_*() method.
  426:         if token == "":
  427:             return self._write_blank(row, col, *args)
  428: 
  429:         if self.strings_to_formulas and token.startswith("="):
  430:             return self._write_formula(row, col, *args)
  431: 
  432:         if token.startswith("{=") and token.endswith("}"):
  433:             return self._write_formula(row, col, *args)
  434: 
  435:         if (
  436:             ":" in token
  437:             and self.strings_to_urls
  438:             and (
  439:                 re.match("(ftp|http)s?://", token)
  440:                 or re.match("mailto:", token)
  441:                 or re.match("(in|ex)ternal:", token)
  442:             )
  443:         ):
  444:             return self._write_url(row, col, *args)
  445: 
  446:         if self.strings_to_numbers:
  447:             try:
  448:                 f = float(token)
  449:                 if self.nan_inf_to_errors or (not isnan(f) and not isinf(f)):
  450:                     return self._write_number(row, col, f, *args[1:])
  451:             except ValueError:
  452:                 # Not a number, write as a string.
  453:                 pass
  454: 
  455:             return self._write_string(row, col, *args)
  456: 
  457:         else:
  458:             # We have a plain string.
  459:             return self._write_string(row, col, *args)
  460: 
  461:     @convert_cell_args
  462:     def write(self, row, col, *args):
  463:         """
  464:         Write data to a worksheet cell by calling the appropriate write_*()
  465:         method based on the type of data being passed.
  466: 
  467:         Args:
  468:             row:   The cell row (zero indexed).
  469:             col:   The cell column (zero indexed).
  470:             *args: Args to pass to sub functions.
  471: 
  472:         Returns:
  473:              0:    Success.
  474:             -1:    Row or column is out of worksheet bounds.
  475:             other: Return value of called method.
  476: 
  477:         """
  478:         return self._write(row, col, *args)
  479: 
  480:     # Undecorated version of write().
  481:     def _write(self, row, col, *args):
  482:         # Check the number of args passed.
  483:         if not args:
  484:             raise TypeError("write() takes at least 4 arguments (3 given)")
  485: 
  486:         # The first arg should be the token for all write calls.
  487:         token = args[0]
  488: 
  489:         # Avoid isinstance() for better performance.
  490:         token_type = token.__class__
  491: 
  492:         # Check for any user defined type handlers with callback functions.
  493:         if token_type in self.write_handlers:
  494:             write_handler = self.write_handlers[token_type]
  495:             function_return = write_handler(self, row, col, *args)
  496: 
  497:             # If the return value is None then the callback has returned
  498:             # control to this function and we should continue as
  499:             # normal. Otherwise we return the value to the caller and exit.
  500:             if function_return is None:
  501:                 pass
  502:             else:
  503:                 return function_return
  504: 
  505:         # Write None as a blank cell.
  506:         if token is None:
  507:             return self._write_blank(row, col, *args)
  508: 
  509:         # Check for standard Python types.
  510:         if token_type is bool:
  511:             return self._write_boolean(row, col, *args)
  512: 
  513:         if token_type in (float, int, Decimal, Fraction):
  514:             return self._write_number(row, col, *args)
  515: 
  516:         if token_type is str:
  517:             return self._write_token_as_string(token, row, col, *args)
  518: 
  519:         if token_type in (
  520:             datetime.datetime,
  521:             datetime.date,
  522:             datetime.time,
  523:             datetime.timedelta,
  524:         ):
  525:             return self._write_datetime(row, col, *args)
  526: 
  527:         # Resort to isinstance() for subclassed primitives.
  528: 
  529:         # Write number types.
  530:         if isinstance(token, (float, int, Decimal, Fraction)):
  531:             return self._write_number(row, col, *args)
  532: 
  533:         # Write string types.
  534:         if isinstance(token, str):
  535:             return self._write_token_as_string(token, row, col, *args)
  536: 
  537:         # Write boolean types.
  538:         if isinstance(token, bool):
  539:             return self._write_boolean(row, col, *args)
  540: 
  541:         # Write datetime objects.
  542:         if supported_datetime(token):
  543:             return self._write_datetime(row, col, *args)
  544: 
  545:         # We haven't matched a supported type. Try float.
  546:         try:
  547:             f = float(token)
  548:             return self._write_number(row, col, f, *args[1:])
  549:         except ValueError:
  550:             pass
  551:         except TypeError:
  552:             raise TypeError("Unsupported type %s in write()" % type(token))
  553: 
  554:         # Finally try string.
  555:         try:
  556:             str(token)
  557:             return self._write_string(row, col, *args)
  558:         except ValueError:
  559:             raise TypeError("Unsupported type %s in write()" % type(token))
  560: 
  561:     @convert_cell_args
  562:     def write_string(self, row, col, string, cell_format=None):
  563:         """
  564:         Write a string to a worksheet cell.
  565: 
  566:         Args:
  567:             row:    The cell row (zero indexed).
  568:             col:    The cell column (zero indexed).
  569:             string: Cell data. Str.
  570:             format: An optional cell Format object.
  571: 
  572:         Returns:
  573:             0:  Success.
  574:             -1: Row or column is out of worksheet bounds.
  575:             -2: String truncated to 32k characters.
  576: 
  577:         """
  578:         return self._write_string(row, col, string, cell_format)
  579: 
  580:     # Undecorated version of write_string().
  581:     def _write_string(self, row, col, string, cell_format=None):
  582:         str_error = 0
  583: 
  584:         # Check that row and col are valid and store max and min values.
  585:         if self._check_dimensions(row, col):
  586:             return -1
  587: 
  588:         # Check that the string is < 32767 chars.
  589:         if len(string) > self.xls_strmax:
  590:             string = string[: self.xls_strmax]
  591:             str_error = -2
  592: 
  593:         # Write a shared string or an in-line string in constant_memory mode.
  594:         if not self.constant_memory:
  595:             string_index = self.str_table._get_shared_string_index(string)
  596:         else:
  597:             string_index = string
  598: 
  599:         # Write previous row if in in-line string constant_memory mode.
  600:         if self.constant_memory and row > self.previous_row:
  601:             self._write_single_row(row)
  602: 
  603:         # Store the cell data in the worksheet data table.
  604:         self.table[row][col] = cell_string_tuple(string_index, cell_format)
  605: 
  606:         return str_error
  607: 
  608:     @convert_cell_args
  609:     def write_number(self, row, col, number, cell_format=None):
  610:         """
  611:         Write a number to a worksheet cell.
  612: 
  613:         Args:
  614:             row:         The cell row (zero indexed).
  615:             col:         The cell column (zero indexed).
  616:             number:      Cell data. Int or float.
  617:             cell_format: An optional cell Format object.
  618: 
  619:         Returns:
  620:             0:  Success.
  621:             -1: Row or column is out of worksheet bounds.
  622: 
  623:         """
  624:         return self._write_number(row, col, number, cell_format)
  625: 
  626:     # Undecorated version of write_number().
  627:     def _write_number(self, row, col, number, cell_format=None):
  628:         if isnan(number) or isinf(number):
  629:             if self.nan_inf_to_errors:
  630:                 if isnan(number):
  631:                     return self._write_formula(row, col, "#NUM!", cell_format, "#NUM!")
  632:                 elif number == math.inf:
  633:                     return self._write_formula(row, col, "1/0", cell_format, "#DIV/0!")
  634:                 elif number == -math.inf:
  635:                     return self._write_formula(row, col, "-1/0", cell_format, "#DIV/0!")
  636:             else:
  637:                 raise TypeError(
  638:                     "NAN/INF not supported in write_number() "
  639:                     "without 'nan_inf_to_errors' Workbook() option"
  640:                 )
  641: 
  642:         # Check that row and col are valid and store max and min values.
  643:         if self._check_dimensions(row, col):
  644:             return -1
  645: 
  646:         # Write previous row if in in-line string constant_memory mode.
  647:         if self.constant_memory and row > self.previous_row:
  648:             self._write_single_row(row)
  649: 
  650:         # Store the cell data in the worksheet data table.
  651:         self.table[row][col] = cell_number_tuple(number, cell_format)
  652: 
  653:         return 0
  654: 
  655:     @convert_cell_args
  656:     def write_blank(self, row, col, blank, cell_format=None):
  657:         """
  658:         Write a blank cell with formatting to a worksheet cell. The blank
  659:         token is ignored and the format only is written to the cell.
  660: 
  661:         Args:
  662:             row:         The cell row (zero indexed).
  663:             col:         The cell column (zero indexed).
  664:             blank:       Any value. It is ignored.
  665:             cell_format: An optional cell Format object.
  666: 
  667:         Returns:
  668:             0:  Success.
  669:             -1: Row or column is out of worksheet bounds.
  670: 
  671:         """
  672:         return self._write_blank(row, col, blank, cell_format)
  673: 
  674:     # Undecorated version of write_blank().
  675:     def _write_blank(self, row, col, blank, cell_format=None):
  676:         # Don't write a blank cell unless it has a format.
  677:         if cell_format is None:
  678:             return 0
  679: 
  680:         # Check that row and col are valid and store max and min values.
  681:         if self._check_dimensions(row, col):
  682:             return -1
  683: 
  684:         # Write previous row if in in-line string constant_memory mode.
  685:         if self.constant_memory and row > self.previous_row:
  686:             self._write_single_row(row)
  687: 
  688:         # Store the cell data in the worksheet data table.
  689:         self.table[row][col] = cell_blank_tuple(cell_format)
  690: 
  691:         return 0
  692: 
  693:     @convert_cell_args
  694:     def write_formula(self, row, col, formula, cell_format=None, value=0):
  695:         """
  696:         Write a formula to a worksheet cell.
  697: 
  698:         Args:
  699:             row:         The cell row (zero indexed).
  700:             col:         The cell column (zero indexed).
  701:             formula:     Cell formula.
  702:             cell_format: An optional cell Format object.
  703:             value:       An optional value for the formula. Default is 0.
  704: 
  705:         Returns:
  706:             0:  Success.
  707:             -1: Row or column is out of worksheet bounds.
  708:             -2: Formula can't be None or empty.
  709: 
  710:         """
  711:         # Check that row and col are valid and store max and min values.
  712:         return self._write_formula(row, col, formula, cell_format, value)
  713: 
  714:     # Undecorated version of write_formula().
  715:     def _write_formula(self, row, col, formula, cell_format=None, value=0):
  716:         if self._check_dimensions(row, col):
  717:             return -1
  718: 
  719:         if formula is None or formula == "":
  720:             warn("Formula can't be None or empty")
  721:             return -1
  722: 
  723:         # Check for dynamic array functions.
  724:         if re_dynamic_function.search(formula):
  725:             return self.write_dynamic_array_formula(
  726:                 row, col, row, col, formula, cell_format, value
  727:             )
  728: 
  729:         # Hand off array formulas.
  730:         if formula.startswith("{") and formula.endswith("}"):
  731:             return self._write_array_formula(
  732:                 row, col, row, col, formula, cell_format, value
  733:             )
  734: 
  735:         # Modify the formula string, as needed.
  736:         formula = self._prepare_formula(formula)
  737: 
  738:         # Write previous row if in in-line string constant_memory mode.
  739:         if self.constant_memory and row > self.previous_row:
  740:             self._write_single_row(row)
  741: 
  742:         # Store the cell data in the worksheet data table.
  743:         self.table[row][col] = cell_formula_tuple(formula, cell_format, value)
  744: 
  745:         return 0
  746: 
  747:     @convert_range_args
  748:     def write_array_formula(
  749:         self,
  750:         first_row,
  751:         first_col,
  752:         last_row,
  753:         last_col,
  754:         formula,
  755:         cell_format=None,
  756:         value=0,
  757:     ):
  758:         """
  759:         Write a formula to a worksheet cell/range.
  760: 
  761:         Args:
  762:             first_row:    The first row of the cell range. (zero indexed).
  763:             first_col:    The first column of the cell range.
  764:             last_row:     The last row of the cell range. (zero indexed).
  765:             last_col:     The last column of the cell range.
  766:             formula:      Cell formula.
  767:             cell_format:  An optional cell Format object.
  768:             value:        An optional value for the formula. Default is 0.
  769: 
  770:         Returns:
  771:             0:  Success.
  772:             -1: Row or column is out of worksheet bounds.
  773: 
  774:         """
  775:         # Check for dynamic array functions.
  776:         if re_dynamic_function.search(formula):
  777:             return self.write_dynamic_array_formula(
  778:                 first_row, first_col, last_row, last_col, formula, cell_format, value
  779:             )
  780: 
  781:         return self._write_array_formula(
  782:             first_row,
  783:             first_col,
  784:             last_row,
  785:             last_col,
  786:             formula,
  787:             cell_format,
  788:             value,
  789:             "static",
  790:         )
  791: 
  792:     @convert_range_args
  793:     def write_dynamic_array_formula(
  794:         self,
  795:         first_row,
  796:         first_col,
  797:         last_row,
  798:         last_col,
  799:         formula,
  800:         cell_format=None,
  801:         value=0,
  802:     ):
  803:         """
  804:         Write a dynamic array formula to a worksheet cell/range.
  805: 
  806:         Args:
  807:             first_row:    The first row of the cell range. (zero indexed).
  808:             first_col:    The first column of the cell range.
  809:             last_row:     The last row of the cell range. (zero indexed).
  810:             last_col:     The last column of the cell range.
  811:             formula:      Cell formula.
  812:             cell_format:  An optional cell Format object.
  813:             value:        An optional value for the formula. Default is 0.
  814: 
  815:         Returns:
  816:             0:  Success.
  817:             -1: Row or column is out of worksheet bounds.
  818: 
  819:         """
  820:         error = self._write_array_formula(
  821:             first_row,
  822:             first_col,
  823:             last_row,
  824:             last_col,
  825:             formula,
  826:             cell_format,
  827:             value,
  828:             "dynamic",
  829:         )
  830: 
  831:         if error == 0:
  832:             self.has_dynamic_arrays = True
  833: 
  834:         return error
  835: 
  836:     # Utility method to strip equal sign and array braces from a formula and
  837:     # also expand out future and dynamic array formulas.
  838:     def _prepare_formula(self, formula, expand_future_functions=False):
  839:         # Remove array formula braces and the leading =.
  840:         if formula.startswith("{"):
  841:             formula = formula[1:]
  842:         if formula.startswith("="):
  843:             formula = formula[1:]
  844:         if formula.endswith("}"):
  845:             formula = formula[:-1]
  846: 
  847:         # Check if formula is already expanded by the user.
  848:         if "_xlfn." in formula:
  849:             return formula
  850: 
  851:         # Expand dynamic formulas.
  852:         formula = re.sub(r"\bANCHORARRAY\(", "_xlfn.ANCHORARRAY(", formula)
  853:         formula = re.sub(r"\bBYCOL\(", "_xlfn.BYCOL(", formula)
  854:         formula = re.sub(r"\bBYROW\(", "_xlfn.BYROW(", formula)
  855:         formula = re.sub(r"\bCHOOSECOLS\(", "_xlfn.CHOOSECOLS(", formula)
  856:         formula = re.sub(r"\bCHOOSEROWS\(", "_xlfn.CHOOSEROWS(", formula)
  857:         formula = re.sub(r"\bDROP\(", "_xlfn.DROP(", formula)
  858:         formula = re.sub(r"\bEXPAND\(", "_xlfn.EXPAND(", formula)
  859:         formula = re.sub(r"\bFILTER\(", "_xlfn._xlws.FILTER(", formula)
  860:         formula = re.sub(r"\bHSTACK\(", "_xlfn.HSTACK(", formula)
  861:         formula = re.sub(r"\bLAMBDA\(", "_xlfn.LAMBDA(", formula)
  862:         formula = re.sub(r"\bMAKEARRAY\(", "_xlfn.MAKEARRAY(", formula)
  863:         formula = re.sub(r"\bMAP\(", "_xlfn.MAP(", formula)
  864:         formula = re.sub(r"\bRANDARRAY\(", "_xlfn.RANDARRAY(", formula)
  865:         formula = re.sub(r"\bREDUCE\(", "_xlfn.REDUCE(", formula)
  866:         formula = re.sub(r"\bSCAN\(", "_xlfn.SCAN(", formula)
  867:         formula = re.sub(r"\SINGLE\(", "_xlfn.SINGLE(", formula)
  868:         formula = re.sub(r"\bSEQUENCE\(", "_xlfn.SEQUENCE(", formula)
  869:         formula = re.sub(r"\bSORT\(", "_xlfn._xlws.SORT(", formula)
  870:         formula = re.sub(r"\bSORTBY\(", "_xlfn.SORTBY(", formula)
  871:         formula = re.sub(r"\bSWITCH\(", "_xlfn.SWITCH(", formula)
  872:         formula = re.sub(r"\bTAKE\(", "_xlfn.TAKE(", formula)
  873:         formula = re.sub(r"\bTEXTSPLIT\(", "_xlfn.TEXTSPLIT(", formula)
  874:         formula = re.sub(r"\bTOCOL\(", "_xlfn.TOCOL(", formula)
  875:         formula = re.sub(r"\bTOROW\(", "_xlfn.TOROW(", formula)
  876:         formula = re.sub(r"\bUNIQUE\(", "_xlfn.UNIQUE(", formula)
  877:         formula = re.sub(r"\bVSTACK\(", "_xlfn.VSTACK(", formula)
  878:         formula = re.sub(r"\bWRAPCOLS\(", "_xlfn.WRAPCOLS(", formula)
  879:         formula = re.sub(r"\bWRAPROWS\(", "_xlfn.WRAPROWS(", formula)
  880:         formula = re.sub(r"\bXLOOKUP\(", "_xlfn.XLOOKUP(", formula)
  881: 
  882:         if not self.use_future_functions and not expand_future_functions:
  883:             return formula
  884: 
  885:         formula = re.sub(r"\bACOTH\(", "_xlfn.ACOTH(", formula)
  886:         formula = re.sub(r"\bACOT\(", "_xlfn.ACOT(", formula)
  887:         formula = re.sub(r"\bAGGREGATE\(", "_xlfn.AGGREGATE(", formula)
  888:         formula = re.sub(r"\bARABIC\(", "_xlfn.ARABIC(", formula)
  889:         formula = re.sub(r"\bARRAYTOTEXT\(", "_xlfn.ARRAYTOTEXT(", formula)
  890:         formula = re.sub(r"\bBASE\(", "_xlfn.BASE(", formula)
  891:         formula = re.sub(r"\bBETA.DIST\(", "_xlfn.BETA.DIST(", formula)
  892:         formula = re.sub(r"\bBETA.INV\(", "_xlfn.BETA.INV(", formula)
  893:         formula = re.sub(r"\bBINOM.DIST.RANGE\(", "_xlfn.BINOM.DIST.RANGE(", formula)
  894:         formula = re.sub(r"\bBINOM.DIST\(", "_xlfn.BINOM.DIST(", formula)
  895:         formula = re.sub(r"\bBINOM.INV\(", "_xlfn.BINOM.INV(", formula)
  896:         formula = re.sub(r"\bBITAND\(", "_xlfn.BITAND(", formula)
  897:         formula = re.sub(r"\bBITLSHIFT\(", "_xlfn.BITLSHIFT(", formula)
  898:         formula = re.sub(r"\bBITOR\(", "_xlfn.BITOR(", formula)
  899:         formula = re.sub(r"\bBITRSHIFT\(", "_xlfn.BITRSHIFT(", formula)
  900:         formula = re.sub(r"\bBITXOR\(", "_xlfn.BITXOR(", formula)
  901:         formula = re.sub(r"\bCEILING.MATH\(", "_xlfn.CEILING.MATH(", formula)
  902:         formula = re.sub(r"\bCEILING.PRECISE\(", "_xlfn.CEILING.PRECISE(", formula)
  903:         formula = re.sub(r"\bCHISQ.DIST.RT\(", "_xlfn.CHISQ.DIST.RT(", formula)
  904:         formula = re.sub(r"\bCHISQ.DIST\(", "_xlfn.CHISQ.DIST(", formula)
  905:         formula = re.sub(r"\bCHISQ.INV.RT\(", "_xlfn.CHISQ.INV.RT(", formula)
  906:         formula = re.sub(r"\bCHISQ.INV\(", "_xlfn.CHISQ.INV(", formula)
  907:         formula = re.sub(r"\bCHISQ.TEST\(", "_xlfn.CHISQ.TEST(", formula)
  908:         formula = re.sub(r"\bCOMBINA\(", "_xlfn.COMBINA(", formula)
  909:         formula = re.sub(r"\bCONCAT\(", "_xlfn.CONCAT(", formula)
  910:         formula = re.sub(r"\bCONFIDENCE.NORM\(", "_xlfn.CONFIDENCE.NORM(", formula)
  911:         formula = re.sub(r"\bCONFIDENCE.T\(", "_xlfn.CONFIDENCE.T(", formula)
  912:         formula = re.sub(r"\bCOTH\(", "_xlfn.COTH(", formula)
  913:         formula = re.sub(r"\bCOT\(", "_xlfn.COT(", formula)
  914:         formula = re.sub(r"\bCOVARIANCE.P\(", "_xlfn.COVARIANCE.P(", formula)
  915:         formula = re.sub(r"\bCOVARIANCE.S\(", "_xlfn.COVARIANCE.S(", formula)
  916:         formula = re.sub(r"\bCSCH\(", "_xlfn.CSCH(", formula)
  917:         formula = re.sub(r"\bCSC\(", "_xlfn.CSC(", formula)
  918:         formula = re.sub(r"\bDAYS\(", "_xlfn.DAYS(", formula)
  919:         formula = re.sub(r"\bDECIMAL\(", "_xlfn.DECIMAL(", formula)
  920:         formula = re.sub(r"\bERF.PRECISE\(", "_xlfn.ERF.PRECISE(", formula)
  921:         formula = re.sub(r"\bERFC.PRECISE\(", "_xlfn.ERFC.PRECISE(", formula)
  922:         formula = re.sub(r"\bEXPON.DIST\(", "_xlfn.EXPON.DIST(", formula)
  923:         formula = re.sub(r"\bF.DIST.RT\(", "_xlfn.F.DIST.RT(", formula)
  924:         formula = re.sub(r"\bF.DIST\(", "_xlfn.F.DIST(", formula)
  925:         formula = re.sub(r"\bF.INV.RT\(", "_xlfn.F.INV.RT(", formula)
  926:         formula = re.sub(r"\bF.INV\(", "_xlfn.F.INV(", formula)
  927:         formula = re.sub(r"\bF.TEST\(", "_xlfn.F.TEST(", formula)
  928:         formula = re.sub(r"\bFILTERXML\(", "_xlfn.FILTERXML(", formula)
  929:         formula = re.sub(r"\bFLOOR.MATH\(", "_xlfn.FLOOR.MATH(", formula)
  930:         formula = re.sub(r"\bFLOOR.PRECISE\(", "_xlfn.FLOOR.PRECISE(", formula)
  931:         formula = re.sub(
  932:             r"\bFORECAST.ETS.CONFINT\(", "_xlfn.FORECAST.ETS.CONFINT(", formula
  933:         )
  934:         formula = re.sub(
  935:             r"\bFORECAST.ETS.SEASONALITY\(", "_xlfn.FORECAST.ETS.SEASONALITY(", formula
  936:         )
  937:         formula = re.sub(r"\bFORECAST.ETS.STAT\(", "_xlfn.FORECAST.ETS.STAT(", formula)
  938:         formula = re.sub(r"\bFORECAST.ETS\(", "_xlfn.FORECAST.ETS(", formula)
  939:         formula = re.sub(r"\bFORECAST.LINEAR\(", "_xlfn.FORECAST.LINEAR(", formula)
  940:         formula = re.sub(r"\bFORMULATEXT\(", "_xlfn.FORMULATEXT(", formula)
  941:         formula = re.sub(r"\bGAMMA.DIST\(", "_xlfn.GAMMA.DIST(", formula)
  942:         formula = re.sub(r"\bGAMMA.INV\(", "_xlfn.GAMMA.INV(", formula)
  943:         formula = re.sub(r"\bGAMMALN.PRECISE\(", "_xlfn.GAMMALN.PRECISE(", formula)
  944:         formula = re.sub(r"\bGAMMA\(", "_xlfn.GAMMA(", formula)
  945:         formula = re.sub(r"\bGAUSS\(", "_xlfn.GAUSS(", formula)
  946:         formula = re.sub(r"\bHYPGEOM.DIST\(", "_xlfn.HYPGEOM.DIST(", formula)
  947:         formula = re.sub(r"\bIFNA\(", "_xlfn.IFNA(", formula)
  948:         formula = re.sub(r"\bIFS\(", "_xlfn.IFS(", formula)
  949:         formula = re.sub(r"\bIMAGE\(", "_xlfn.IMAGE(", formula)
  950:         formula = re.sub(r"\bIMCOSH\(", "_xlfn.IMCOSH(", formula)
  951:         formula = re.sub(r"\bIMCOT\(", "_xlfn.IMCOT(", formula)
  952:         formula = re.sub(r"\bIMCSCH\(", "_xlfn.IMCSCH(", formula)
  953:         formula = re.sub(r"\bIMCSC\(", "_xlfn.IMCSC(", formula)
  954:         formula = re.sub(r"\bIMSECH\(", "_xlfn.IMSECH(", formula)
  955:         formula = re.sub(r"\bIMSEC\(", "_xlfn.IMSEC(", formula)
  956:         formula = re.sub(r"\bIMSINH\(", "_xlfn.IMSINH(", formula)
  957:         formula = re.sub(r"\bIMTAN\(", "_xlfn.IMTAN(", formula)
  958:         formula = re.sub(r"\bISFORMULA\(", "_xlfn.ISFORMULA(", formula)
  959:         formula = re.sub(r"\bISOMITTED\(", "_xlfn.ISOMITTED(", formula)
  960:         formula = re.sub(r"\bISOWEEKNUM\(", "_xlfn.ISOWEEKNUM(", formula)
  961:         formula = re.sub(r"\bLET\(", "_xlfn.LET(", formula)
  962:         formula = re.sub(r"\bLOGNORM.DIST\(", "_xlfn.LOGNORM.DIST(", formula)
  963:         formula = re.sub(r"\bLOGNORM.INV\(", "_xlfn.LOGNORM.INV(", formula)
  964:         formula = re.sub(r"\bMAXIFS\(", "_xlfn.MAXIFS(", formula)
  965:         formula = re.sub(r"\bMINIFS\(", "_xlfn.MINIFS(", formula)
  966:         formula = re.sub(r"\bMODE.MULT\(", "_xlfn.MODE.MULT(", formula)
  967:         formula = re.sub(r"\bMODE.SNGL\(", "_xlfn.MODE.SNGL(", formula)
  968:         formula = re.sub(r"\bMUNIT\(", "_xlfn.MUNIT(", formula)
  969:         formula = re.sub(r"\bNEGBINOM.DIST\(", "_xlfn.NEGBINOM.DIST(", formula)
  970:         formula = re.sub(r"\bNORM.DIST\(", "_xlfn.NORM.DIST(", formula)
  971:         formula = re.sub(r"\bNORM.INV\(", "_xlfn.NORM.INV(", formula)
  972:         formula = re.sub(r"\bNORM.S.DIST\(", "_xlfn.NORM.S.DIST(", formula)
  973:         formula = re.sub(r"\bNORM.S.INV\(", "_xlfn.NORM.S.INV(", formula)
  974:         formula = re.sub(r"\bNUMBERVALUE\(", "_xlfn.NUMBERVALUE(", formula)
  975:         formula = re.sub(r"\bPDURATION\(", "_xlfn.PDURATION(", formula)
  976:         formula = re.sub(r"\bPERCENTILE.EXC\(", "_xlfn.PERCENTILE.EXC(", formula)
  977:         formula = re.sub(r"\bPERCENTILE.INC\(", "_xlfn.PERCENTILE.INC(", formula)
  978:         formula = re.sub(r"\bPERCENTRANK.EXC\(", "_xlfn.PERCENTRANK.EXC(", formula)
  979:         formula = re.sub(r"\bPERCENTRANK.INC\(", "_xlfn.PERCENTRANK.INC(", formula)
  980:         formula = re.sub(r"\bPERMUTATIONA\(", "_xlfn.PERMUTATIONA(", formula)
  981:         formula = re.sub(r"\bPHI\(", "_xlfn.PHI(", formula)
  982:         formula = re.sub(r"\bPOISSON.DIST\(", "_xlfn.POISSON.DIST(", formula)
  983:         formula = re.sub(r"\bQUARTILE.EXC\(", "_xlfn.QUARTILE.EXC(", formula)
  984:         formula = re.sub(r"\bQUARTILE.INC\(", "_xlfn.QUARTILE.INC(", formula)
  985:         formula = re.sub(r"\bQUERYSTRING\(", "_xlfn.QUERYSTRING(", formula)
  986:         formula = re.sub(r"\bRANK.AVG\(", "_xlfn.RANK.AVG(", formula)
  987:         formula = re.sub(r"\bRANK.EQ\(", "_xlfn.RANK.EQ(", formula)
  988:         formula = re.sub(r"\bRRI\(", "_xlfn.RRI(", formula)
  989:         formula = re.sub(r"\bSECH\(", "_xlfn.SECH(", formula)
  990:         formula = re.sub(r"\bSEC\(", "_xlfn.SEC(", formula)
  991:         formula = re.sub(r"\bSHEETS\(", "_xlfn.SHEETS(", formula)
  992:         formula = re.sub(r"\bSHEET\(", "_xlfn.SHEET(", formula)
  993:         formula = re.sub(r"\bSKEW.P\(", "_xlfn.SKEW.P(", formula)
  994:         formula = re.sub(r"\bSTDEV.P\(", "_xlfn.STDEV.P(", formula)
  995:         formula = re.sub(r"\bSTDEV.S\(", "_xlfn.STDEV.S(", formula)
  996:         formula = re.sub(r"\bT.DIST.2T\(", "_xlfn.T.DIST.2T(", formula)
  997:         formula = re.sub(r"\bT.DIST.RT\(", "_xlfn.T.DIST.RT(", formula)
  998:         formula = re.sub(r"\bT.DIST\(", "_xlfn.T.DIST(", formula)
  999:         formula = re.sub(r"\bT.INV.2T\(", "_xlfn.T.INV.2T(", formula)
 1000:         formula = re.sub(r"\bT.INV\(", "_xlfn.T.INV(", formula)
 1001:         formula = re.sub(r"\bT.TEST\(", "_xlfn.T.TEST(", formula)
 1002:         formula = re.sub(r"\bTEXTAFTER\(", "_xlfn.TEXTAFTER(", formula)
 1003:         formula = re.sub(r"\bTEXTBEFORE\(", "_xlfn.TEXTBEFORE(", formula)
 1004:         formula = re.sub(r"\bTEXTJOIN\(", "_xlfn.TEXTJOIN(", formula)
 1005:         formula = re.sub(r"\bUNICHAR\(", "_xlfn.UNICHAR(", formula)
 1006:         formula = re.sub(r"\bUNICODE\(", "_xlfn.UNICODE(", formula)
 1007:         formula = re.sub(r"\bVALUETOTEXT\(", "_xlfn.VALUETOTEXT(", formula)
 1008:         formula = re.sub(r"\bVAR.P\(", "_xlfn.VAR.P(", formula)
 1009:         formula = re.sub(r"\bVAR.S\(", "_xlfn.VAR.S(", formula)
 1010:         formula = re.sub(r"\bWEBSERVICE\(", "_xlfn.WEBSERVICE(", formula)
 1011:         formula = re.sub(r"\bWEIBULL.DIST\(", "_xlfn.WEIBULL.DIST(", formula)
 1012:         formula = re.sub(r"\bXMATCH\(", "_xlfn.XMATCH(", formula)
 1013:         formula = re.sub(r"\bXOR\(", "_xlfn.XOR(", formula)
 1014:         formula = re.sub(r"\bZ.TEST\(", "_xlfn.Z.TEST(", formula)
 1015: 
 1016:         return formula
 1017: 
 1018:     # Undecorated version of write_array_formula() and
 1019:     # write_dynamic_array_formula().
 1020:     def _write_array_formula(
 1021:         self,
 1022:         first_row,
 1023:         first_col,
 1024:         last_row,
 1025:         last_col,
 1026:         formula,
 1027:         cell_format=None,
 1028:         value=0,
 1029:         atype="static",
 1030:     ):
 1031:         # Swap last row/col with first row/col as necessary.
 1032:         if first_row > last_row:
 1033:             first_row, last_row = last_row, first_row
 1034:         if first_col > last_col:
 1035:             first_col, last_col = last_col, first_col
 1036: 
 1037:         # Check that row and col are valid and store max and min values.
 1038:         if self._check_dimensions(first_row, first_col):
 1039:             return -1
 1040:         if self._check_dimensions(last_row, last_col):
 1041:             return -1
 1042: 
 1043:         # Define array range
 1044:         if first_row == last_row and first_col == last_col:
 1045:             cell_range = xl_rowcol_to_cell(first_row, first_col)
 1046:         else:
 1047:             cell_range = (
 1048:                 xl_rowcol_to_cell(first_row, first_col)
 1049:                 + ":"
 1050:                 + xl_rowcol_to_cell(last_row, last_col)
 1051:             )
 1052: 
 1053:         # Modify the formula string, as needed.
 1054:         formula = self._prepare_formula(formula)
 1055: 
 1056:         # Write previous row if in in-line string constant_memory mode.
 1057:         if self.constant_memory and first_row > self.previous_row:
 1058:             self._write_single_row(first_row)
 1059: 
 1060:         # Store the cell data in the worksheet data table.
 1061:         self.table[first_row][first_col] = cell_arformula_tuple(
 1062:             formula, cell_format, value, cell_range, atype
 1063:         )
 1064: 
 1065:         # Pad out the rest of the area with formatted zeroes.
 1066:         if not self.constant_memory:
 1067:             for row in range(first_row, last_row + 1):
 1068:                 for col in range(first_col, last_col + 1):
 1069:                     if row != first_row or col != first_col:
 1070:                         self._write_number(row, col, 0, cell_format)
 1071: 
 1072:         return 0
 1073: 
 1074:     @convert_cell_args
 1075:     def write_datetime(self, row, col, date, cell_format=None):
 1076:         """
 1077:         Write a date or time to a worksheet cell.
 1078: 
 1079:         Args:
 1080:             row:         The cell row (zero indexed).
 1081:             col:         The cell column (zero indexed).
 1082:             date:        Date and/or time as a datetime object.
 1083:             cell_format: A cell Format object.
 1084: 
 1085:         Returns:
 1086:             0:  Success.
 1087:             -1: Row or column is out of worksheet bounds.
 1088: 
 1089:         """
 1090:         return self._write_datetime(row, col, date, cell_format)
 1091: 
 1092:     # Undecorated version of write_datetime().
 1093:     def _write_datetime(self, row, col, date, cell_format=None):
 1094:         # Check that row and col are valid and store max and min values.
 1095:         if self._check_dimensions(row, col):
 1096:             return -1
 1097: 
 1098:         # Write previous row if in in-line string constant_memory mode.
 1099:         if self.constant_memory and row > self.previous_row:
 1100:             self._write_single_row(row)
 1101: 
 1102:         # Convert datetime to an Excel date.
 1103:         number = self._convert_date_time(date)
 1104: 
 1105:         # Add the default date format.
 1106:         if cell_format is None:
 1107:             cell_format = self.default_date_format
 1108: 
 1109:         # Store the cell data in the worksheet data table.
 1110:         self.table[row][col] = cell_datetime_tuple(number, cell_format)
 1111: 
 1112:         return 0
 1113: 
 1114:     @convert_cell_args
 1115:     def write_boolean(self, row, col, boolean, cell_format=None):
 1116:         """
 1117:         Write a boolean value to a worksheet cell.
 1118: 
 1119:         Args:
 1120:             row:         The cell row (zero indexed).
 1121:             col:         The cell column (zero indexed).
 1122:             boolean:     Cell data. bool type.
 1123:             cell_format: An optional cell Format object.
 1124: 
 1125:         Returns:
 1126:             0:  Success.
 1127:             -1: Row or column is out of worksheet bounds.
 1128: 
 1129:         """
 1130:         return self._write_boolean(row, col, boolean, cell_format)
 1131: 
 1132:     # Undecorated version of write_boolean().
 1133:     def _write_boolean(self, row, col, boolean, cell_format=None):
 1134:         # Check that row and col are valid and store max and min values.
 1135:         if self._check_dimensions(row, col):
 1136:             return -1
 1137: 
 1138:         # Write previous row if in in-line string constant_memory mode.
 1139:         if self.constant_memory and row > self.previous_row:
 1140:             self._write_single_row(row)
 1141: 
 1142:         if boolean:
 1143:             value = 1
 1144:         else:
 1145:             value = 0
 1146: 
 1147:         # Store the cell data in the worksheet data table.
 1148:         self.table[row][col] = cell_boolean_tuple(value, cell_format)
 1149: 
 1150:         return 0
 1151: 
 1152:     # Write a hyperlink. This is comprised of two elements: the displayed
 1153:     # string and the non-displayed link. The displayed string is the same as
 1154:     # the link unless an alternative string is specified. The display string
 1155:     # is written using the write_string() method. Therefore the max characters
 1156:     # string limit applies.
 1157:     #
 1158:     # The hyperlink can be to a http, ftp, mail, internal sheet, or external
 1159:     # directory urls.
 1160:     @convert_cell_args
 1161:     def write_url(self, row, col, url, cell_format=None, string=None, tip=None):
 1162:         """
 1163:         Write a hyperlink to a worksheet cell.
 1164: 
 1165:         Args:
 1166:             row:    The cell row (zero indexed).
 1167:             col:    The cell column (zero indexed).
 1168:             url:    Hyperlink url.
 1169:             format: An optional cell Format object.
 1170:             string: An optional display string for the hyperlink.
 1171:             tip:    An optional tooltip.
 1172:         Returns:
 1173:             0:  Success.
 1174:             -1: Row or column is out of worksheet bounds.
 1175:             -2: String longer than 32767 characters.
 1176:             -3: URL longer than Excel limit of 255 characters.
 1177:             -4: Exceeds Excel limit of 65,530 urls per worksheet.
 1178:         """
 1179:         return self._write_url(row, col, url, cell_format, string, tip)
 1180: 
 1181:     # Undecorated version of write_url().
 1182:     def _write_url(self, row, col, url, cell_format=None, string=None, tip=None):
 1183:         # Check that row and col are valid and store max and min values
 1184:         if self._check_dimensions(row, col):
 1185:             return -1
 1186: 
 1187:         # Set the displayed string to the URL unless defined by the user.
 1188:         if string is None:
 1189:             string = url
 1190: 
 1191:         # Default to external link type such as 'http://' or 'external:'.
 1192:         link_type = 1
 1193: 
 1194:         # Remove the URI scheme from internal links.
 1195:         if url.startswith("internal:"):
 1196:             url = url.replace("internal:", "")
 1197:             string = string.replace("internal:", "")
 1198:             link_type = 2
 1199: 
 1200:         # Remove the URI scheme from external links and change the directory
 1201:         # separator from Unix to Dos.
 1202:         external = False
 1203:         if url.startswith("external:"):
 1204:             url = url.replace("external:", "")
 1205:             url = url.replace("/", "\\")
 1206:             string = string.replace("external:", "")
 1207:             string = string.replace("/", "\\")
 1208:             external = True
 1209: 
 1210:         # Strip the mailto header.
 1211:         string = string.replace("mailto:", "")
 1212: 
 1213:         # Check that the string is < 32767 chars
 1214:         str_error = 0
 1215:         if len(string) > self.xls_strmax:
 1216:             warn(
 1217:                 "Ignoring URL since it exceeds Excel's string limit of "
 1218:                 "32767 characters"
 1219:             )
 1220:             return -2
 1221: 
 1222:         # Copy string for use in hyperlink elements.
 1223:         url_str = string
 1224: 
 1225:         # External links to URLs and to other Excel workbooks have slightly
 1226:         # different characteristics that we have to account for.
 1227:         if link_type == 1:
 1228:             # Split url into the link and optional anchor/location.
 1229:             if "#" in url:
 1230:                 url, url_str = url.split("#", 1)
 1231:             else:
 1232:                 url_str = None
 1233: 
 1234:             url = self._escape_url(url)
 1235: 
 1236:             if url_str is not None and not external:
 1237:                 url_str = self._escape_url(url_str)
 1238: 
 1239:             # Add the file:/// URI to the url for Windows style "C:/" link and
 1240:             # Network shares.
 1241:             if re.match(r"\w:", url) or re.match(r"\\", url):
 1242:                 url = "file:///" + url
 1243: 
 1244:             # Convert a .\dir\file.xlsx link to dir\file.xlsx.
 1245:             url = re.sub(r"^\.\\", "", url)
 1246: 
 1247:         # Excel limits the escaped URL and location/anchor to 255 characters.
 1248:         tmp_url_str = url_str or ""
 1249:         max_url = self.max_url_length
 1250:         if len(url) > max_url or len(tmp_url_str) > max_url:
 1251:             warn(
 1252:                 "Ignoring URL '%s' with link or location/anchor > %d "
 1253:                 "characters since it exceeds Excel's limit for URLS" % (url, max_url)
 1254:             )
 1255:             return -3
 1256: 
 1257:         # Check the limit of URLS per worksheet.
 1258:         self.hlink_count += 1
 1259: 
 1260:         if self.hlink_count > 65530:
 1261:             warn(
 1262:                 "Ignoring URL '%s' since it exceeds Excel's limit of "
 1263:                 "65,530 URLS per worksheet." % url
 1264:             )
 1265:             return -4
 1266: 
 1267:         # Add the default URL format.
 1268:         if cell_format is None:
 1269:             cell_format = self.default_url_format
 1270: 
 1271:         if not self.ignore_write_string:
 1272:             # Write previous row if in in-line string constant_memory mode.
 1273:             if self.constant_memory and row > self.previous_row:
 1274:                 self._write_single_row(row)
 1275: 
 1276:             # Write the hyperlink string.
 1277:             self._write_string(row, col, string, cell_format)
 1278: 
 1279:         # Store the hyperlink data in a separate structure.
 1280:         self.hyperlinks[row][col] = {
 1281:             "link_type": link_type,
 1282:             "url": url,
 1283:             "str": url_str,
 1284:             "tip": tip,
 1285:         }
 1286: 
 1287:         return str_error
 1288: 
 1289:     @convert_cell_args
 1290:     def write_rich_string(self, row, col, *args):
 1291:         """
 1292:         Write a "rich" string with multiple formats to a worksheet cell.
 1293: 
 1294:         Args:
 1295:             row:          The cell row (zero indexed).
 1296:             col:          The cell column (zero indexed).
 1297:             string_parts: String and format pairs.
 1298:             cell_format:  Optional Format object.
 1299: 
 1300:         Returns:
 1301:             0:  Success.
 1302:             -1: Row or column is out of worksheet bounds.
 1303:             -2: String truncated to 32k characters.
 1304:             -3: 2 consecutive formats used.
 1305:             -4: Empty string used.
 1306:             -5: Insufficient parameters.
 1307: 
 1308:         """
 1309: 
 1310:         return self._write_rich_string(row, col, *args)
 1311: 
 1312:     # Undecorated version of write_rich_string().
 1313:     def _write_rich_string(self, row, col, *args):
 1314:         tokens = list(args)
 1315:         cell_format = None
 1316:         string_index = 0
 1317:         raw_string = ""
 1318: 
 1319:         # Check that row and col are valid and store max and min values
 1320:         if self._check_dimensions(row, col):
 1321:             return -1
 1322: 
 1323:         # If the last arg is a format we use it as the cell format.
 1324:         if isinstance(tokens[-1], Format):
 1325:             cell_format = tokens.pop()
 1326: 
 1327:         # Create a temp XMLWriter object and use it to write the rich string
 1328:         # XML to a string.
 1329:         fh = StringIO()
 1330:         self.rstring = XMLwriter()
 1331:         self.rstring._set_filehandle(fh)
 1332: 
 1333:         # Create a temp format with the default font for unformatted fragments.
 1334:         default = Format()
 1335: 
 1336:         # Convert list of format, string tokens to pairs of (format, string)
 1337:         # except for the first string fragment which doesn't require a default
 1338:         # formatting run. Use the default for strings without a leading format.
 1339:         fragments = []
 1340:         previous = "format"
 1341:         pos = 0
 1342: 
 1343:         if len(tokens) <= 2:
 1344:             warn(
 1345:                 "You must specify more than 2 format/fragments for rich "
 1346:                 "strings. Ignoring input in write_rich_string()."
 1347:             )
 1348:             return -5
 1349: 
 1350:         for token in tokens:
 1351:             if not isinstance(token, Format):
 1352:                 # Token is a string.
 1353:                 if previous != "format":
 1354:                     # If previous token wasn't a format add one before string.
 1355:                     fragments.append(default)
 1356:                     fragments.append(token)
 1357:                 else:
 1358:                     # If previous token was a format just add the string.
 1359:                     fragments.append(token)
 1360: 
 1361:                 if token == "":
 1362:                     warn(
 1363:                         "Excel doesn't allow empty strings in rich strings. "
 1364:                         "Ignoring input in write_rich_string()."
 1365:                     )
 1366:                     return -4
 1367: 
 1368:                 # Keep track of unformatted string.
 1369:                 raw_string += token
 1370:                 previous = "string"
 1371:             else:
 1372:                 # Can't allow 2 formats in a row.
 1373:                 if previous == "format" and pos > 0:
 1374:                     warn(
 1375:                         "Excel doesn't allow 2 consecutive formats in rich "
 1376:                         "strings. Ignoring input in write_rich_string()."
 1377:                     )
 1378:                     return -3
 1379: 
 1380:                 # Token is a format object. Add it to the fragment list.
 1381:                 fragments.append(token)
 1382:                 previous = "format"
 1383: 
 1384:             pos += 1
 1385: 
 1386:         # If the first token is a string start the <r> element.
 1387:         if not isinstance(fragments[0], Format):
 1388:             self.rstring._xml_start_tag("r")
 1389: 
 1390:         # Write the XML elements for the $format $string fragments.
 1391:         for token in fragments:
 1392:             if isinstance(token, Format):
 1393:                 # Write the font run.
 1394:                 self.rstring._xml_start_tag("r")
 1395:                 self._write_font(token)
 1396:             else:
 1397:                 # Write the string fragment part, with whitespace handling.
 1398:                 attributes = []
 1399: 
 1400:                 if preserve_whitespace(token):
 1401:                     attributes.append(("xml:space", "preserve"))
 1402: 
 1403:                 self.rstring._xml_data_element("t", token, attributes)
 1404:                 self.rstring._xml_end_tag("r")
 1405: 
 1406:         # Read the in-memory string.
 1407:         string = self.rstring.fh.getvalue()
 1408: 
 1409:         # Check that the string is < 32767 chars.
 1410:         if len(raw_string) > self.xls_strmax:
 1411:             warn(
 1412:                 "String length must be less than or equal to Excel's limit "
 1413:                 "of 32,767 characters in write_rich_string()."
 1414:             )
 1415:             return -2
 1416: 
 1417:         # Write a shared string or an in-line string in constant_memory mode.
 1418:         if not self.constant_memory:
 1419:             string_index = self.str_table._get_shared_string_index(string)
 1420:         else:
 1421:             string_index = string
 1422: 
 1423:         # Write previous row if in in-line string constant_memory mode.
 1424:         if self.constant_memory and row > self.previous_row:
 1425:             self._write_single_row(row)
 1426: 
 1427:         # Store the cell data in the worksheet data table.
 1428:         self.table[row][col] = cell_rich_string_tuple(
 1429:             string_index, cell_format, raw_string
 1430:         )
 1431: 
 1432:         return 0
 1433: 
 1434:     def add_write_handler(self, user_type, user_function):
 1435:         """
 1436:         Add a callback function to the write() method to handle user defined
 1437:         types.
 1438: 
 1439:         Args:
 1440:             user_type:      The user type() to match on.
 1441:             user_function:  The user defined function to write the type data.
 1442:         Returns:
 1443:             Nothing.
 1444: 
 1445:         """
 1446: 
 1447:         self.write_handlers[user_type] = user_function
 1448: 
 1449:     @convert_cell_args
 1450:     def write_row(self, row, col, data, cell_format=None):
 1451:         """
 1452:         Write a row of data starting from (row, col).
 1453: 
 1454:         Args:
 1455:             row:    The cell row (zero indexed).
 1456:             col:    The cell column (zero indexed).
 1457:             data:   A list of tokens to be written with write().
 1458:             format: An optional cell Format object.
 1459:         Returns:
 1460:             0:  Success.
 1461:             other: Return value of write() method.
 1462: 
 1463:         """
 1464:         for token in data:
 1465:             error = self._write(row, col, token, cell_format)
 1466:             if error:
 1467:                 return error
 1468:             col += 1
 1469: 
 1470:         return 0
 1471: 
 1472:     @convert_cell_args
 1473:     def write_column(self, row, col, data, cell_format=None):
 1474:         """
 1475:         Write a column of data starting from (row, col).
 1476: 
 1477:         Args:
 1478:             row:    The cell row (zero indexed).
 1479:             col:    The cell column (zero indexed).
 1480:             data:   A list of tokens to be written with write().
 1481:             format: An optional cell Format object.
 1482:         Returns:
 1483:             0:  Success.
 1484:             other: Return value of write() method.
 1485: 
 1486:         """
 1487:         for token in data:
 1488:             error = self._write(row, col, token, cell_format)
 1489:             if error:
 1490:                 return error
 1491:             row += 1
 1492: 
 1493:         return 0
 1494: 
 1495:     @convert_cell_args
 1496:     def insert_image(self, row, col, filename, options=None):
 1497:         """
 1498:         Insert an image with its top-left corner in a worksheet cell.
 1499: 
 1500:         Args:
 1501:             row:      The cell row (zero indexed).
 1502:             col:      The cell column (zero indexed).
 1503:             filename: Path and filename for in supported formats.
 1504:             options:  Position, scale, url and data stream of the image.
 1505: 
 1506:         Returns:
 1507:             0:  Success.
 1508:             -1: Row or column is out of worksheet bounds.
 1509: 
 1510:         """
 1511:         # Check insert (row, col) without storing.
 1512:         if self._check_dimensions(row, col, True, True):
 1513:             warn("Cannot insert image at (%d, %d)." % (row, col))
 1514:             return -1
 1515: 
 1516:         if options is None:
 1517:             options = {}
 1518: 
 1519:         x_offset = options.get("x_offset", 0)
 1520:         y_offset = options.get("y_offset", 0)
 1521:         x_scale = options.get("x_scale", 1)
 1522:         y_scale = options.get("y_scale", 1)
 1523:         url = options.get("url", None)
 1524:         tip = options.get("tip", None)
 1525:         anchor = options.get("object_position", 2)
 1526:         image_data = options.get("image_data", None)
 1527:         description = options.get("description", None)
 1528:         decorative = options.get("decorative", False)
 1529: 
 1530:         # For backward compatibility with older parameter name.
 1531:         anchor = options.get("positioning", anchor)
 1532: 
 1533:         if not image_data and not os.path.exists(filename):
 1534:             warn("Image file '%s' not found." % filename)
 1535:             return -1
 1536: 
 1537:         self.images.append(
 1538:             [
 1539:                 row,
 1540:                 col,
 1541:                 filename,
 1542:                 x_offset,
 1543:                 y_offset,
 1544:                 x_scale,
 1545:                 y_scale,
 1546:                 url,
 1547:                 tip,
 1548:                 anchor,
 1549:                 image_data,
 1550:                 description,
 1551:                 decorative,
 1552:             ]
 1553:         )
 1554:         return 0
 1555: 
 1556:     @convert_cell_args
 1557:     def embed_image(self, row, col, filename, options=None):
 1558:         """
 1559:         Embed an image in a worksheet cell.
 1560: 
 1561:         Args:
 1562:             row:      The cell row (zero indexed).
 1563:             col:      The cell column (zero indexed).
 1564:             filename: Path and filename for in supported formats.
 1565:             options:  Url and data stream of the image.
 1566: 
 1567:         Returns:
 1568:             0:  Success.
 1569:             -1: Row or column is out of worksheet bounds.
 1570: 
 1571:         """
 1572:         # Check insert (row, col) without storing.
 1573:         if self._check_dimensions(row, col):
 1574:             warn("Cannot embed image at (%d, %d)." % (row, col))
 1575:             return -1
 1576: 
 1577:         if options is None:
 1578:             options = {}
 1579: 
 1580:         url = options.get("url", None)
 1581:         tip = options.get("tip", None)
 1582:         cell_format = options.get("cell_format", None)
 1583:         image_data = options.get("image_data", None)
 1584:         description = options.get("description", None)
 1585:         decorative = options.get("decorative", False)
 1586: 
 1587:         if not image_data and not os.path.exists(filename):
 1588:             warn("Image file '%s' not found." % filename)
 1589:             return -1
 1590: 
 1591:         if url:
 1592:             if cell_format is None:
 1593:                 cell_format = self.default_url_format
 1594: 
 1595:             self.ignore_write_string = True
 1596:             self.write_url(row, col, url, cell_format, None, tip)
 1597:             self.ignore_write_string = False
 1598: 
 1599:         # Get the image properties, for the type and checksum.
 1600:         (
 1601:             image_type,
 1602:             _,
 1603:             _,
 1604:             _,
 1605:             _,
 1606:             _,
 1607:             digest,
 1608:         ) = get_image_properties(filename, image_data)
 1609: 
 1610:         image = [filename, image_type, image_data, description, decorative]
 1611:         image_index = self.embedded_images.get_image_index(image, digest)
 1612: 
 1613:         # Store the cell error and image index in the worksheet data table.
 1614:         self.table[row][col] = cell_error_tuple("#VALUE!", cell_format, image_index)
 1615: 
 1616:         return 0
 1617: 
 1618:     @convert_cell_args
 1619:     def insert_textbox(self, row, col, text, options=None):
 1620:         """
 1621:         Insert an textbox with its top-left corner in a worksheet cell.
 1622: 
 1623:         Args:
 1624:             row:      The cell row (zero indexed).
 1625:             col:      The cell column (zero indexed).
 1626:             text:     The text for the textbox.
 1627:             options:  Textbox options.
 1628: 
 1629:         Returns:
 1630:             0:  Success.
 1631:             -1: Row or column is out of worksheet bounds.
 1632: 
 1633:         """
 1634:         # Check insert (row, col) without storing.
 1635:         if self._check_dimensions(row, col, True, True):
 1636:             warn("Cannot insert textbox at (%d, %d)." % (row, col))
 1637:             return -1
 1638: 
 1639:         if text is None:
 1640:             text = ""
 1641: 
 1642:         if options is None:
 1643:             options = {}
 1644: 
 1645:         x_offset = options.get("x_offset", 0)
 1646:         y_offset = options.get("y_offset", 0)
 1647:         x_scale = options.get("x_scale", 1)
 1648:         y_scale = options.get("y_scale", 1)
 1649:         anchor = options.get("object_position", 1)
 1650:         description = options.get("description", None)
 1651:         decorative = options.get("decorative", False)
 1652: 
 1653:         self.shapes.append(
 1654:             [
 1655:                 row,
 1656:                 col,
 1657:                 x_offset,
 1658:                 y_offset,
 1659:                 x_scale,
 1660:                 y_scale,
 1661:                 text,
 1662:                 anchor,
 1663:                 options,
 1664:                 description,
 1665:                 decorative,
 1666:             ]
 1667:         )
 1668:         return 0
 1669: 
 1670:     @convert_cell_args
 1671:     def insert_chart(self, row, col, chart, options=None):
 1672:         """
 1673:         Insert an chart with its top-left corner in a worksheet cell.
 1674: 
 1675:         Args:
 1676:             row:     The cell row (zero indexed).
 1677:             col:     The cell column (zero indexed).
 1678:             chart:   Chart object.
 1679:             options: Position and scale of the chart.
 1680: 
 1681:         Returns:
 1682:             0:  Success.
 1683:             -1: Row or column is out of worksheet bounds.
 1684: 
 1685:         """
 1686:         # Check insert (row, col) without storing.
 1687:         if self._check_dimensions(row, col, True, True):
 1688:             warn("Cannot insert chart at (%d, %d)." % (row, col))
 1689:             return -1
 1690: 
 1691:         if options is None:
 1692:             options = {}
 1693: 
 1694:         # Ensure a chart isn't inserted more than once.
 1695:         if chart.already_inserted or chart.combined and chart.combined.already_inserted:
 1696:             warn("Chart cannot be inserted in a worksheet more than once.")
 1697:             return
 1698:         else:
 1699:             chart.already_inserted = True
 1700: 
 1701:             if chart.combined:
 1702:                 chart.combined.already_inserted = True
 1703: 
 1704:         x_offset = options.get("x_offset", 0)
 1705:         y_offset = options.get("y_offset", 0)
 1706:         x_scale = options.get("x_scale", 1)
 1707:         y_scale = options.get("y_scale", 1)
 1708:         anchor = options.get("object_position", 1)
 1709:         description = options.get("description", None)
 1710:         decorative = options.get("decorative", False)
 1711: 
 1712:         # Allow Chart to override the scale and offset.
 1713:         if chart.x_scale != 1:
 1714:             x_scale = chart.x_scale
 1715: 
 1716:         if chart.y_scale != 1:
 1717:             y_scale = chart.y_scale
 1718: 
 1719:         if chart.x_offset:
 1720:             x_offset = chart.x_offset
 1721: 
 1722:         if chart.y_offset:
 1723:             y_offset = chart.y_offset
 1724: 
 1725:         self.charts.append(
 1726:             [
 1727:                 row,
 1728:                 col,
 1729:                 chart,
 1730:                 x_offset,
 1731:                 y_offset,
 1732:                 x_scale,
 1733:                 y_scale,
 1734:                 anchor,
 1735:                 description,
 1736:                 decorative,
 1737:             ]
 1738:         )
 1739:         return 0
 1740: 
 1741:     @convert_cell_args
 1742:     def write_comment(self, row, col, comment, options=None):
 1743:         """
 1744:         Write a comment to a worksheet cell.
 1745: 
 1746:         Args:
 1747:             row:     The cell row (zero indexed).
 1748:             col:     The cell column (zero indexed).
 1749:             comment: Cell comment. Str.
 1750:             options: Comment formatting options.
 1751: 
 1752:         Returns:
 1753:             0:  Success.
 1754:             -1: Row or column is out of worksheet bounds.
 1755:             -2: String longer than 32k characters.
 1756: 
 1757:         """
 1758:         if options is None:
 1759:             options = {}
 1760: 
 1761:         # Check that row and col are valid and store max and min values
 1762:         if self._check_dimensions(row, col):
 1763:             return -1
 1764: 
 1765:         # Check that the comment string is < 32767 chars.
 1766:         if len(comment) > self.xls_strmax:
 1767:             return -2
 1768: 
 1769:         self.has_vml = 1
 1770:         self.has_comments = 1
 1771: 
 1772:         # Store the options of the cell comment, to process on file close.
 1773:         self.comments[row][col] = [row, col, comment, options]
 1774: 
 1775:         return 0
 1776: 
 1777:     def show_comments(self):
 1778:         """
 1779:         Make any comments in the worksheet visible.
 1780: 
 1781:         Args:
 1782:             None.
 1783: 
 1784:         Returns:
 1785:             Nothing.
 1786: 
 1787:         """
 1788:         self.comments_visible = 1
 1789: 
 1790:     def set_background(self, filename, is_byte_stream=False):
 1791:         """
 1792:         Set a background image for a worksheet.
 1793: 
 1794:         Args:
 1795:             filename:       Path and filename for in supported formats.
 1796:             is_byte_stream: File is a stream of bytes.
 1797:         Returns:
 1798:             Nothing.
 1799: 
 1800:         """
 1801: 
 1802:         if not is_byte_stream and not os.path.exists(filename):
 1803:             warn("Image file '%s' not found." % filename)
 1804:             return -1
 1805: 
 1806:         self.background_bytes = is_byte_stream
 1807:         self.background_image = filename
 1808: 
 1809:     def set_comments_author(self, author):
 1810:         """
 1811:         Set the default author of the cell comments.
 1812: 
 1813:         Args:
 1814:             author: Comment author name. String.
 1815: 
 1816:         Returns:
 1817:             Nothing.
 1818: 
 1819:         """
 1820:         self.comments_author = author
 1821: 
 1822:     def get_name(self):
 1823:         """
 1824:         Retrieve the worksheet name.
 1825: 
 1826:         Args:
 1827:             None.
 1828: 
 1829:         Returns:
 1830:             Nothing.
 1831: 
 1832:         """
 1833:         # There is no set_name() method. Name must be set in add_worksheet().
 1834:         return self.name
 1835: 
 1836:     def activate(self):
 1837:         """
 1838:         Set this worksheet as the active worksheet, i.e. the worksheet that is
 1839:         displayed when the workbook is opened. Also set it as selected.
 1840: 
 1841:         Note: An active worksheet cannot be hidden.
 1842: 
 1843:         Args:
 1844:             None.
 1845: 
 1846:         Returns:
 1847:             Nothing.
 1848: 
 1849:         """
 1850:         self.hidden = 0
 1851:         self.selected = 1
 1852:         self.worksheet_meta.activesheet = self.index
 1853: 
 1854:     def select(self):
 1855:         """
 1856:         Set current worksheet as a selected worksheet, i.e. the worksheet
 1857:         has its tab highlighted.
 1858: 
 1859:         Note: A selected worksheet cannot be hidden.
 1860: 
 1861:         Args:
 1862:             None.
 1863: 
 1864:         Returns:
 1865:             Nothing.
 1866: 
 1867:         """
 1868:         self.selected = 1
 1869:         self.hidden = 0
 1870: 
 1871:     def hide(self):
 1872:         """
 1873:         Hide the current worksheet.
 1874: 
 1875:         Args:
 1876:             None.
 1877: 
 1878:         Returns:
 1879:             Nothing.
 1880: 
 1881:         """
 1882:         self.hidden = 1
 1883: 
 1884:         # A hidden worksheet shouldn't be active or selected.
 1885:         self.selected = 0
 1886: 
 1887:     def very_hidden(self):
 1888:         """
 1889:         Hide the current worksheet. This can only be unhidden by VBA.
 1890: 
 1891:         Args:
 1892:             None.
 1893: 
 1894:         Returns:
 1895:             Nothing.
 1896: 
 1897:         """
 1898:         self.hidden = 2
 1899: 
 1900:         # A hidden worksheet shouldn't be active or selected.
 1901:         self.selected = 0
 1902: 
 1903:     def set_first_sheet(self):
 1904:         """
 1905:         Set current worksheet as the first visible sheet. This is necessary
 1906:         when there are a large number of worksheets and the activated
 1907:         worksheet is not visible on the screen.
 1908: 
 1909:         Note: A selected worksheet cannot be hidden.
 1910: 
 1911:         Args:
 1912:             None.
 1913: 
 1914:         Returns:
 1915:             Nothing.
 1916: 
 1917:         """
 1918:         self.hidden = 0  # Active worksheet can't be hidden.
 1919:         self.worksheet_meta.firstsheet = self.index
 1920: 
 1921:     @convert_column_args
 1922:     def set_column(
 1923:         self, first_col, last_col, width=None, cell_format=None, options=None
 1924:     ):
 1925:         """
 1926:         Set the width, and other properties of a single column or a
 1927:         range of columns.
 1928: 
 1929:         Args:
 1930:             first_col:   First column (zero-indexed).
 1931:             last_col:    Last column (zero-indexed). Can be same as first_col.
 1932:             width:       Column width. (optional).
 1933:             cell_format: Column cell_format. (optional).
 1934:             options:     Dict of options such as hidden and level.
 1935: 
 1936:         Returns:
 1937:             0:  Success.
 1938:             -1: Column number is out of worksheet bounds.
 1939: 
 1940:         """
 1941:         if options is None:
 1942:             options = {}
 1943: 
 1944:         # Ensure 2nd col is larger than first.
 1945:         if first_col > last_col:
 1946:             (first_col, last_col) = (last_col, first_col)
 1947: 
 1948:         # Don't modify the row dimensions when checking the columns.
 1949:         ignore_row = True
 1950: 
 1951:         # Set optional column values.
 1952:         hidden = options.get("hidden", False)
 1953:         collapsed = options.get("collapsed", False)
 1954:         level = options.get("level", 0)
 1955: 
 1956:         # Store the column dimension only in some conditions.
 1957:         if cell_format or (width and hidden):
 1958:             ignore_col = False
 1959:         else:
 1960:             ignore_col = True
 1961: 
 1962:         # Check that each column is valid and store the max and min values.
 1963:         if self._check_dimensions(0, last_col, ignore_row, ignore_col):
 1964:             return -1
 1965:         if self._check_dimensions(0, first_col, ignore_row, ignore_col):
 1966:             return -1
 1967: 
 1968:         # Set the limits for the outline levels (0 <= x <= 7).
 1969:         if level < 0:
 1970:             level = 0
 1971:         if level > 7:
 1972:             level = 7
 1973: 
 1974:         if level > self.outline_col_level:
 1975:             self.outline_col_level = level
 1976: 
 1977:         # Store the column data.
 1978:         for col in range(first_col, last_col + 1):
 1979:             self.col_info[col] = [width, cell_format, hidden, level, collapsed, False]
 1980: 
 1981:         # Store the column change to allow optimizations.
 1982:         self.col_size_changed = True
 1983: 
 1984:         return 0
 1985: 
 1986:     @convert_column_args
 1987:     def set_column_pixels(
 1988:         self, first_col, last_col, width=None, cell_format=None, options=None
 1989:     ):
 1990:         """
 1991:         Set the width, and other properties of a single column or a
 1992:         range of columns, where column width is in pixels.
 1993: 
 1994:         Args:
 1995:             first_col:   First column (zero-indexed).
 1996:             last_col:    Last column (zero-indexed). Can be same as first_col.
 1997:             width:       Column width in pixels. (optional).
 1998:             cell_format: Column cell_format. (optional).
 1999:             options:     Dict of options such as hidden and level.
 2000: 
 2001:         Returns:
 2002:             0:  Success.
 2003:             -1: Column number is out of worksheet bounds.
 2004: 
 2005:         """
 2006:         if width is not None:
 2007:             width = self._pixels_to_width(width)
 2008: 
 2009:         return self.set_column(first_col, last_col, width, cell_format, options)
 2010: 
 2011:     def autofit(self):
 2012:         """
 2013:         Simulate autofit based on the data, and datatypes in each column.
 2014: 
 2015:         Args:
 2016:             None.
 2017: 
 2018:         Returns:
 2019:             Nothing.
 2020: 
 2021:         """
 2022:         if self.constant_memory:
 2023:             warn("Autofit is not supported in constant_memory mode.")
 2024:             return
 2025: 
 2026:         # No data written to the target sheet; nothing to autofit
 2027:         if self.dim_rowmax is None:
 2028:             return
 2029: 
 2030:         # Store the max pixel width for each column.
 2031:         col_width_max = {}
 2032: 
 2033:         # Create a reverse lookup for the share strings table so we can convert
 2034:         # the string id back to the original string.
 2035:         strings = sorted(
 2036:             self.str_table.string_table, key=self.str_table.string_table.__getitem__
 2037:         )
 2038: 
 2039:         for row_num in range(self.dim_rowmin, self.dim_rowmax + 1):
 2040:             if not self.table.get(row_num):
 2041:                 continue
 2042: 
 2043:             for col_num in range(self.dim_colmin, self.dim_colmax + 1):
 2044:                 if col_num in self.table[row_num]:
 2045:                     cell = self.table[row_num][col_num]
 2046:                     cell_type = cell.__class__.__name__
 2047:                     length = 0
 2048: 
 2049:                     if cell_type in ("String", "RichString"):
 2050:                         # Handle strings and rich strings.
 2051:                         #
 2052:                         # For standard shared strings we do a reverse lookup
 2053:                         # from the shared string id to the actual string. For
 2054:                         # rich strings we use the unformatted string. We also
 2055:                         # split multi-line strings and handle each part
 2056:                         # separately.
 2057:                         if cell_type == "String":
 2058:                             string_id = cell.string
 2059:                             string = strings[string_id]
 2060:                         else:
 2061:                             string = cell.raw_string
 2062: 
 2063:                         if "\n" not in string:
 2064:                             # Single line string.
 2065:                             length = xl_pixel_width(string)
 2066:                         else:
 2067:                             # Handle multi-line strings.
 2068:                             for string in string.split("\n"):
 2069:                                 seg_length = xl_pixel_width(string)
 2070:                                 if seg_length > length:
 2071:                                     length = seg_length
 2072: 
 2073:                     elif cell_type == "Number":
 2074:                         # Handle numbers.
 2075:                         #
 2076:                         # We use a workaround/optimization for numbers since
 2077:                         # digits all have a pixel width of 7. This gives a
 2078:                         # slightly greater width for the decimal place and
 2079:                         # minus sign but only by a few pixels and
 2080:                         # over-estimation is okay.
 2081:                         length = 7 * len(str(cell.number))
 2082: 
 2083:                     elif cell_type == "Datetime":
 2084:                         # Handle dates.
 2085:                         #
 2086:                         # The following uses the default width for mm/dd/yyyy
 2087:                         # dates. It isn't feasible to parse the number format
 2088:                         # to get the actual string width for all format types.
 2089:                         length = self.default_date_pixels
 2090: 
 2091:                     elif cell_type == "Boolean":
 2092:                         # Handle boolean values.
 2093:                         #
 2094:                         # Use the Excel standard widths for TRUE and FALSE.
 2095:                         if cell.boolean:
 2096:                             length = 31
 2097:                         else:
 2098:                             length = 36
 2099: 
 2100:                     elif cell_type == "Formula" or cell_type == "ArrayFormula":
 2101:                         # Handle formulas.
 2102:                         #
 2103:                         # We only try to autofit a formula if it has a
 2104:                         # non-zero value.
 2105:                         if isinstance(cell.value, (float, int)):
 2106:                             if cell.value > 0:
 2107:                                 length = 7 * len(str(cell.value))
 2108: 
 2109:                         elif isinstance(cell.value, str):
 2110:                             length = xl_pixel_width(cell.value)
 2111: 
 2112:                         elif isinstance(cell.value, bool):
 2113:                             if cell.value:
 2114:                                 length = 31
 2115:                             else:
 2116:                                 length = 36
 2117: 
 2118:                     # If the cell is in an autofilter header we add an
 2119:                     # additional 16 pixels for the dropdown arrow.
 2120:                     if self.filter_cells.get((row_num, col_num)) and length > 0:
 2121:                         length += 16
 2122: 
 2123:                     # Add the string length to the lookup table.
 2124:                     width_max = col_width_max.get(col_num, 0)
 2125:                     if length > width_max:
 2126:                         col_width_max[col_num] = length
 2127: 
 2128:         # Apply the width to the column.
 2129:         for col_num, pixel_width in col_width_max.items():
 2130:             # Convert the string pixel width to a character width using an
 2131:             # additional padding of 7 pixels, like Excel.
 2132:             width = self._pixels_to_width(pixel_width + 7)
 2133: 
 2134:             # The max column character width in Excel is 255.
 2135:             if width > 255.0:
 2136:                 width = 255.0
 2137: 
 2138:             # Add the width to an existing col info structure or add a new one.
 2139:             if self.col_info.get(col_num):
 2140:                 # We only update the width for an existing column if it is
 2141:                 # greater than the user defined value. This allows the user
 2142:                 # to pre-load a minimum col width.
 2143:                 col_info = self.col_info.get(col_num)
 2144:                 user_width = col_info[0]
 2145:                 hidden = col_info[5]
 2146:                 if user_width is not None and not hidden:
 2147:                     # Col info is user defined.
 2148:                     if width > user_width:
 2149:                         self.col_info[col_num][0] = width
 2150:                         self.col_info[col_num][5] = True
 2151:                 else:
 2152:                     self.col_info[col_num][0] = width
 2153:                     self.col_info[col_num][5] = True
 2154:             else:
 2155:                 self.col_info[col_num] = [width, None, False, 0, False, True]
 2156: 
 2157:     def set_row(self, row, height=None, cell_format=None, options=None):
 2158:         """
 2159:         Set the width, and other properties of a row.
 2160: 
 2161:         Args:
 2162:             row:         Row number (zero-indexed).
 2163:             height:      Row height. (optional).
 2164:             cell_format: Row cell_format. (optional).
 2165:             options:     Dict of options such as hidden, level and collapsed.
 2166: 
 2167:         Returns:
 2168:             0:  Success.
 2169:             -1: Row number is out of worksheet bounds.
 2170: 
 2171:         """
 2172:         if options is None:
 2173:             options = {}
 2174: 
 2175:         # Use minimum col in _check_dimensions().
 2176:         if self.dim_colmin is not None:
 2177:             min_col = self.dim_colmin
 2178:         else:
 2179:             min_col = 0
 2180: 
 2181:         # Check that row is valid.
 2182:         if self._check_dimensions(row, min_col):
 2183:             return -1
 2184: 
 2185:         if height is None:
 2186:             height = self.default_row_height
 2187: 
 2188:         # Set optional row values.
 2189:         hidden = options.get("hidden", False)
 2190:         collapsed = options.get("collapsed", False)
 2191:         level = options.get("level", 0)
 2192: 
 2193:         # If the height is 0 the row is hidden and the height is the default.
 2194:         if height == 0:
 2195:             hidden = 1
 2196:             height = self.default_row_height
 2197: 
 2198:         # Set the limits for the outline levels (0 <= x <= 7).
 2199:         if level < 0:
 2200:             level = 0
 2201:         if level > 7:
 2202:             level = 7
 2203: 
 2204:         if level > self.outline_row_level:
 2205:             self.outline_row_level = level
 2206: 
 2207:         # Store the row properties.
 2208:         self.set_rows[row] = [height, cell_format, hidden, level, collapsed]
 2209: 
 2210:         # Store the row change to allow optimizations.
 2211:         self.row_size_changed = True
 2212: 
 2213:         # Store the row sizes for use when calculating image vertices.
 2214:         self.row_sizes[row] = [height, hidden]
 2215: 
 2216:         return 0
 2217: 
 2218:     def set_row_pixels(self, row, height=None, cell_format=None, options=None):
 2219:         """
 2220:         Set the width (in pixels), and other properties of a row.
 2221: 
 2222:         Args:
 2223:             row:         Row number (zero-indexed).
 2224:             height:      Row height in pixels. (optional).
 2225:             cell_format: Row cell_format. (optional).
 2226:             options:     Dict of options such as hidden, level and collapsed.
 2227: 
 2228:         Returns:
 2229:             0:  Success.
 2230:             -1: Row number is out of worksheet bounds.
 2231: 
 2232:         """
 2233:         if height is not None:
 2234:             height = self._pixels_to_height(height)
 2235: 
 2236:         return self.set_row(row, height, cell_format, options)
 2237: 
 2238:     def set_default_row(self, height=None, hide_unused_rows=False):
 2239:         """
 2240:         Set the default row properties.
 2241: 
 2242:         Args:
 2243:             height:           Default height. Optional, defaults to 15.
 2244:             hide_unused_rows: Hide unused rows. Optional, defaults to False.
 2245: 
 2246:         Returns:
 2247:             Nothing.
 2248: 
 2249:         """
 2250:         if height is None:
 2251:             height = self.default_row_height
 2252: 
 2253:         if height != self.original_row_height:
 2254:             # Store the row change to allow optimizations.
 2255:             self.row_size_changed = True
 2256:             self.default_row_height = height
 2257: 
 2258:         if hide_unused_rows:
 2259:             self.default_row_zeroed = 1
 2260: 
 2261:     @convert_range_args
 2262:     def merge_range(
 2263:         self, first_row, first_col, last_row, last_col, data, cell_format=None
 2264:     ):
 2265:         """
 2266:         Merge a range of cells.
 2267: 
 2268:         Args:
 2269:             first_row:    The first row of the cell range. (zero indexed).
 2270:             first_col:    The first column of the cell range.
 2271:             last_row:     The last row of the cell range. (zero indexed).
 2272:             last_col:     The last column of the cell range.
 2273:             data:         Cell data.
 2274:             cell_format:  Cell Format object.
 2275: 
 2276:         Returns:
 2277:              0:    Success.
 2278:             -1:    Row or column is out of worksheet bounds.
 2279:             other: Return value of write().
 2280: 
 2281:         """
 2282:         # Merge a range of cells. The first cell should contain the data and
 2283:         # the others should be blank. All cells should have the same format.
 2284: 
 2285:         # Excel doesn't allow a single cell to be merged
 2286:         if first_row == last_row and first_col == last_col:
 2287:             warn("Can't merge single cell")
 2288:             return
 2289: 
 2290:         # Swap last row/col with first row/col as necessary
 2291:         if first_row > last_row:
 2292:             (first_row, last_row) = (last_row, first_row)
 2293:         if first_col > last_col:
 2294:             (first_col, last_col) = (last_col, first_col)
 2295: 
 2296:         # Check that row and col are valid and store max and min values.
 2297:         if self._check_dimensions(first_row, first_col):
 2298:             return -1
 2299:         if self._check_dimensions(last_row, last_col):
 2300:             return -1
 2301: 
 2302:         # Check if the merge range overlaps a previous merged or table range.
 2303:         # This is a critical file corruption error in Excel.
 2304:         cell_range = xl_range(first_row, first_col, last_row, last_col)
 2305:         for row in range(first_row, last_row + 1):
 2306:             for col in range(first_col, last_col + 1):
 2307:                 if self.merged_cells.get((row, col)):
 2308:                     previous_range = self.merged_cells.get((row, col))
 2309:                     raise OverlappingRange(
 2310:                         "Merge range '%s' overlaps previous merge range '%s'."
 2311:                         % (cell_range, previous_range)
 2312:                     )
 2313:                 elif self.table_cells.get((row, col)):
 2314:                     previous_range = self.table_cells.get((row, col))
 2315:                     raise OverlappingRange(
 2316:                         "Merge range '%s' overlaps previous table range '%s'."
 2317:                         % (cell_range, previous_range)
 2318:                     )
 2319:                 else:
 2320:                     self.merged_cells[(row, col)] = cell_range
 2321: 
 2322:         # Store the merge range.
 2323:         self.merge.append([first_row, first_col, last_row, last_col])
 2324: 
 2325:         # Write the first cell
 2326:         self._write(first_row, first_col, data, cell_format)
 2327: 
 2328:         # Pad out the rest of the area with formatted blank cells.
 2329:         for row in range(first_row, last_row + 1):
 2330:             for col in range(first_col, last_col + 1):
 2331:                 if row == first_row and col == first_col:
 2332:                     continue
 2333:                 self._write_blank(row, col, "", cell_format)
 2334: 
 2335:         return 0
 2336: 
 2337:     @convert_range_args
 2338:     def autofilter(self, first_row, first_col, last_row, last_col):
 2339:         """
 2340:         Set the autofilter area in the worksheet.
 2341: 
 2342:         Args:
 2343:             first_row:    The first row of the cell range. (zero indexed).
 2344:             first_col:    The first column of the cell range.
 2345:             last_row:     The last row of the cell range. (zero indexed).
 2346:             last_col:     The last column of the cell range.
 2347: 
 2348:         Returns:
 2349:              Nothing.
 2350: 
 2351:         """
 2352:         # Reverse max and min values if necessary.
 2353:         if last_row < first_row:
 2354:             (first_row, last_row) = (last_row, first_row)
 2355:         if last_col < first_col:
 2356:             (first_col, last_col) = (last_col, first_col)
 2357: 
 2358:         # Build up the print area range "Sheet1!$A$1:$C$13".
 2359:         area = self._convert_name_area(first_row, first_col, last_row, last_col)
 2360:         ref = xl_range(first_row, first_col, last_row, last_col)
 2361: 
 2362:         self.autofilter_area = area
 2363:         self.autofilter_ref = ref
 2364:         self.filter_range = [first_col, last_col]
 2365: 
 2366:         # Store the filter cell positions for use in the autofit calculation.
 2367:         for col in range(first_col, last_col + 1):
 2368:             self.filter_cells[(first_row, col)] = True
 2369: 
 2370:     def filter_column(self, col, criteria):
 2371:         """
 2372:         Set the column filter criteria.
 2373: 
 2374:         Args:
 2375:             col:       Filter column (zero-indexed).
 2376:             criteria:  Filter criteria.
 2377: 
 2378:         Returns:
 2379:              Nothing.
 2380: 
 2381:         """
 2382:         if not self.autofilter_area:
 2383:             warn("Must call autofilter() before filter_column()")
 2384:             return
 2385: 
 2386:         # Check for a column reference in A1 notation and substitute.
 2387:         try:
 2388:             int(col)
 2389:         except ValueError:
 2390:             # Convert col ref to a cell ref and then to a col number.
 2391:             col_letter = col
 2392:             (_, col) = xl_cell_to_rowcol(col + "1")
 2393: 
 2394:             if col >= self.xls_colmax:
 2395:                 warn("Invalid column '%s'" % col_letter)
 2396:                 return
 2397: 
 2398:         (col_first, col_last) = self.filter_range
 2399: 
 2400:         # Reject column if it is outside filter range.
 2401:         if col < col_first or col > col_last:
 2402:             warn(
 2403:                 "Column '%d' outside autofilter() column range (%d, %d)"
 2404:                 % (col, col_first, col_last)
 2405:             )
 2406:             return
 2407: 
 2408:         tokens = self._extract_filter_tokens(criteria)
 2409: 
 2410:         if len(tokens) not in (3, 7):
 2411:             warn("Incorrect number of tokens in criteria '%s'" % criteria)
 2412: 
 2413:         tokens = self._parse_filter_expression(criteria, tokens)
 2414: 
 2415:         # Excel handles single or double custom filters as default filters.
 2416:         #  We need to check for them and handle them accordingly.
 2417:         if len(tokens) == 2 and tokens[0] == 2:
 2418:             # Single equality.
 2419:             self.filter_column_list(col, [tokens[1]])
 2420:         elif len(tokens) == 5 and tokens[0] == 2 and tokens[2] == 1 and tokens[3] == 2:
 2421:             # Double equality with "or" operator.
 2422:             self.filter_column_list(col, [tokens[1], tokens[4]])
 2423:         else:
 2424:             # Non default custom filter.
 2425:             self.filter_cols[col] = tokens
 2426:             self.filter_type[col] = 0
 2427: 
 2428:         self.filter_on = 1
 2429: 
 2430:     def filter_column_list(self, col, filters):
 2431:         """
 2432:         Set the column filter criteria in Excel 2007 list style.
 2433: 
 2434:         Args:
 2435:             col:      Filter column (zero-indexed).
 2436:             filters:  List of filter criteria to match.
 2437: 
 2438:         Returns:
 2439:              Nothing.
 2440: 
 2441:         """
 2442:         if not self.autofilter_area:
 2443:             warn("Must call autofilter() before filter_column()")
 2444:             return
 2445: 
 2446:         # Check for a column reference in A1 notation and substitute.
 2447:         try:
 2448:             int(col)
 2449:         except ValueError:
 2450:             # Convert col ref to a cell ref and then to a col number.
 2451:             col_letter = col
 2452:             (_, col) = xl_cell_to_rowcol(col + "1")
 2453: 
 2454:             if col >= self.xls_colmax:
 2455:                 warn("Invalid column '%s'" % col_letter)
 2456:                 return
 2457: 
 2458:         (col_first, col_last) = self.filter_range
 2459: 
 2460:         # Reject column if it is outside filter range.
 2461:         if col < col_first or col > col_last:
 2462:             warn(
 2463:                 "Column '%d' outside autofilter() column range "
 2464:                 "(%d,%d)" % (col, col_first, col_last)
 2465:             )
 2466:             return
 2467: 
 2468:         self.filter_cols[col] = filters
 2469:         self.filter_type[col] = 1
 2470:         self.filter_on = 1
 2471: 
 2472:     @convert_range_args
 2473:     def data_validation(self, first_row, first_col, last_row, last_col, options=None):
 2474:         """
 2475:         Add a data validation to a worksheet.
 2476: 
 2477:         Args:
 2478:             first_row:    The first row of the cell range. (zero indexed).
 2479:             first_col:    The first column of the cell range.
 2480:             last_row:     The last row of the cell range. (zero indexed).
 2481:             last_col:     The last column of the cell range.
 2482:             options:      Data validation options.
 2483: 
 2484:         Returns:
 2485:             0:  Success.
 2486:             -1: Row or column is out of worksheet bounds.
 2487:             -2: Incorrect parameter or option.
 2488:         """
 2489:         # Check that row and col are valid without storing the values.
 2490:         if self._check_dimensions(first_row, first_col, True, True):
 2491:             return -1
 2492:         if self._check_dimensions(last_row, last_col, True, True):
 2493:             return -1
 2494: 
 2495:         if options is None:
 2496:             options = {}
 2497:         else:
 2498:             # Copy the user defined options so they aren't modified.
 2499:             options = options.copy()
 2500: 
 2501:         # Valid input parameters.
 2502:         valid_parameters = {
 2503:             "validate",
 2504:             "criteria",
 2505:             "value",
 2506:             "source",
 2507:             "minimum",
 2508:             "maximum",
 2509:             "ignore_blank",
 2510:             "dropdown",
 2511:             "show_input",
 2512:             "input_title",
 2513:             "input_message",
 2514:             "show_error",
 2515:             "error_title",
 2516:             "error_message",
 2517:             "error_type",
 2518:             "other_cells",
 2519:             "multi_range",
 2520:         }
 2521: 
 2522:         # Check for valid input parameters.
 2523:         for param_key in options.keys():
 2524:             if param_key not in valid_parameters:
 2525:                 warn("Unknown parameter '%s' in data_validation()" % param_key)
 2526:                 return -2
 2527: 
 2528:         # Map alternative parameter names 'source' or 'minimum' to 'value'.
 2529:         if "source" in options:
 2530:             options["value"] = options["source"]
 2531:         if "minimum" in options:
 2532:             options["value"] = options["minimum"]
 2533: 
 2534:         # 'validate' is a required parameter.
 2535:         if "validate" not in options:
 2536:             warn("Parameter 'validate' is required in data_validation()")
 2537:             return -2
 2538: 
 2539:         # List of  valid validation types.
 2540:         valid_types = {
 2541:             "any": "none",
 2542:             "any value": "none",
 2543:             "whole number": "whole",
 2544:             "whole": "whole",
 2545:             "integer": "whole",
 2546:             "decimal": "decimal",
 2547:             "list": "list",
 2548:             "date": "date",
 2549:             "time": "time",
 2550:             "text length": "textLength",
 2551:             "length": "textLength",
 2552:             "custom": "custom",
 2553:         }
 2554: 
 2555:         # Check for valid validation types.
 2556:         if options["validate"] not in valid_types:
 2557:             warn(
 2558:                 "Unknown validation type '%s' for parameter "
 2559:                 "'validate' in data_validation()" % options["validate"]
 2560:             )
 2561:             return -2
 2562:         else:
 2563:             options["validate"] = valid_types[options["validate"]]
 2564: 
 2565:         # No action is required for validation type 'any' if there are no
 2566:         # input messages to display.
 2567:         if (
 2568:             options["validate"] == "none"
 2569:             and options.get("input_title") is None
 2570:             and options.get("input_message") is None
 2571:         ):
 2572:             return -2
 2573: 
 2574:         # The any, list and custom validations don't have a criteria so we use
 2575:         # a default of 'between'.
 2576:         if (
 2577:             options["validate"] == "none"
 2578:             or options["validate"] == "list"
 2579:             or options["validate"] == "custom"
 2580:         ):
 2581:             options["criteria"] = "between"
 2582:             options["maximum"] = None
 2583: 
 2584:         # 'criteria' is a required parameter.
 2585:         if "criteria" not in options:
 2586:             warn("Parameter 'criteria' is required in data_validation()")
 2587:             return -2
 2588: 
 2589:         # Valid criteria types.
 2590:         criteria_types = {
 2591:             "between": "between",
 2592:             "not between": "notBetween",
 2593:             "equal to": "equal",
 2594:             "=": "equal",
 2595:             "==": "equal",
 2596:             "not equal to": "notEqual",
 2597:             "!=": "notEqual",
 2598:             "<>": "notEqual",
 2599:             "greater than": "greaterThan",
 2600:             ">": "greaterThan",
 2601:             "less than": "lessThan",
 2602:             "<": "lessThan",
 2603:             "greater than or equal to": "greaterThanOrEqual",
 2604:             ">=": "greaterThanOrEqual",
 2605:             "less than or equal to": "lessThanOrEqual",
 2606:             "<=": "lessThanOrEqual",
 2607:         }
 2608: 
 2609:         # Check for valid criteria types.
 2610:         if options["criteria"] not in criteria_types:
 2611:             warn(
 2612:                 "Unknown criteria type '%s' for parameter "
 2613:                 "'criteria' in data_validation()" % options["criteria"]
 2614:             )
 2615:             return -2
 2616:         else:
 2617:             options["criteria"] = criteria_types[options["criteria"]]
 2618: 
 2619:         # 'Between' and 'Not between' criteria require 2 values.
 2620:         if options["criteria"] == "between" or options["criteria"] == "notBetween":
 2621:             if "maximum" not in options:
 2622:                 warn(
 2623:                     "Parameter 'maximum' is required in data_validation() "
 2624:                     "when using 'between' or 'not between' criteria"
 2625:                 )
 2626:                 return -2
 2627:         else:
 2628:             options["maximum"] = None
 2629: 
 2630:         # Valid error dialog types.
 2631:         error_types = {
 2632:             "stop": 0,
 2633:             "warning": 1,
 2634:             "information": 2,
 2635:         }
 2636: 
 2637:         # Check for valid error dialog types.
 2638:         if "error_type" not in options:
 2639:             options["error_type"] = 0
 2640:         elif options["error_type"] not in error_types:
 2641:             warn(
 2642:                 "Unknown criteria type '%s' for parameter 'error_type' "
 2643:                 "in data_validation()" % options["error_type"]
 2644:             )
 2645:             return -2
 2646:         else:
 2647:             options["error_type"] = error_types[options["error_type"]]
 2648: 
 2649:         # Convert date/times value if required.
 2650:         if (
 2651:             options["validate"] in ("date", "time")
 2652:             and options["value"]
 2653:             and supported_datetime(options["value"])
 2654:         ):
 2655:             date_time = self._convert_date_time(options["value"])
 2656:             # Format date number to the same precision as Excel.
 2657:             options["value"] = "%.16g" % date_time
 2658: 
 2659:             if options["maximum"] and supported_datetime(options["maximum"]):
 2660:                 date_time = self._convert_date_time(options["maximum"])
 2661:                 options["maximum"] = "%.16g" % date_time
 2662: 
 2663:         # Check that the input title doesn't exceed the maximum length.
 2664:         if options.get("input_title") and len(options["input_title"]) > 32:
 2665:             warn(
 2666:                 "Length of input title '%s' exceeds Excel's limit of 32"
 2667:                 % options["input_title"]
 2668:             )
 2669:             return -2
 2670: 
 2671:         # Check that the error title doesn't exceed the maximum length.
 2672:         if options.get("error_title") and len(options["error_title"]) > 32:
 2673:             warn(
 2674:                 "Length of error title '%s' exceeds Excel's limit of 32"
 2675:                 % options["error_title"]
 2676:             )
 2677:             return -2
 2678: 
 2679:         # Check that the input message doesn't exceed the maximum length.
 2680:         if options.get("input_message") and len(options["input_message"]) > 255:
 2681:             warn(
 2682:                 "Length of input message '%s' exceeds Excel's limit of 255"
 2683:                 % options["input_message"]
 2684:             )
 2685:             return -2
 2686: 
 2687:         # Check that the error message doesn't exceed the maximum length.
 2688:         if options.get("error_message") and len(options["error_message"]) > 255:
 2689:             warn(
 2690:                 "Length of error message '%s' exceeds Excel's limit of 255"
 2691:                 % options["error_message"]
 2692:             )
 2693:             return -2
 2694: 
 2695:         # Check that the input list doesn't exceed the maximum length.
 2696:         if options["validate"] == "list" and isinstance(options["value"], list):
 2697:             formula = self._csv_join(*options["value"])
 2698:             if len(formula) > 255:
 2699:                 warn(
 2700:                     "Length of list items '%s' exceeds Excel's limit of "
 2701:                     "255, use a formula range instead" % formula
 2702:                 )
 2703:                 return -2
 2704: 
 2705:         # Set some defaults if they haven't been defined by the user.
 2706:         if "ignore_blank" not in options:
 2707:             options["ignore_blank"] = 1
 2708:         if "dropdown" not in options:
 2709:             options["dropdown"] = 1
 2710:         if "show_input" not in options:
 2711:             options["show_input"] = 1
 2712:         if "show_error" not in options:
 2713:             options["show_error"] = 1
 2714: 
 2715:         # These are the cells to which the validation is applied.
 2716:         options["cells"] = [[first_row, first_col, last_row, last_col]]
 2717: 
 2718:         # A (for now) undocumented parameter to pass additional cell ranges.
 2719:         if "other_cells" in options:
 2720:             options["cells"].extend(options["other_cells"])
 2721: 
 2722:         # Override with user defined multiple range if provided.
 2723:         if "multi_range" in options:
 2724:             options["multi_range"] = options["multi_range"].replace("$", "")
 2725: 
 2726:         # Store the validation information until we close the worksheet.
 2727:         self.validations.append(options)
 2728: 
 2729:         return 0
 2730: 
 2731:     @convert_range_args
 2732:     def conditional_format(
 2733:         self, first_row, first_col, last_row, last_col, options=None
 2734:     ):
 2735:         """
 2736:         Add a conditional format to a worksheet.
 2737: 
 2738:         Args:
 2739:             first_row:    The first row of the cell range. (zero indexed).
 2740:             first_col:    The first column of the cell range.
 2741:             last_row:     The last row of the cell range. (zero indexed).
 2742:             last_col:     The last column of the cell range.
 2743:             options:      Conditional format options.
 2744: 
 2745:         Returns:
 2746:             0:  Success.
 2747:             -1: Row or column is out of worksheet bounds.
 2748:             -2: Incorrect parameter or option.
 2749:         """
 2750:         # Check that row and col are valid without storing the values.
 2751:         if self._check_dimensions(first_row, first_col, True, True):
 2752:             return -1
 2753:         if self._check_dimensions(last_row, last_col, True, True):
 2754:             return -1
 2755: 
 2756:         if options is None:
 2757:             options = {}
 2758:         else:
 2759:             # Copy the user defined options so they aren't modified.
 2760:             options = options.copy()
 2761: 
 2762:         # Valid input parameters.
 2763:         valid_parameter = {
 2764:             "type",
 2765:             "format",
 2766:             "criteria",
 2767:             "value",
 2768:             "minimum",
 2769:             "maximum",
 2770:             "stop_if_true",
 2771:             "min_type",
 2772:             "mid_type",
 2773:             "max_type",
 2774:             "min_value",
 2775:             "mid_value",
 2776:             "max_value",
 2777:             "min_color",
 2778:             "mid_color",
 2779:             "max_color",
 2780:             "min_length",
 2781:             "max_length",
 2782:             "multi_range",
 2783:             "bar_color",
 2784:             "bar_negative_color",
 2785:             "bar_negative_color_same",
 2786:             "bar_solid",
 2787:             "bar_border_color",
 2788:             "bar_negative_border_color",
 2789:             "bar_negative_border_color_same",
 2790:             "bar_no_border",
 2791:             "bar_direction",
 2792:             "bar_axis_position",
 2793:             "bar_axis_color",
 2794:             "bar_only",
 2795:             "data_bar_2010",
 2796:             "icon_style",
 2797:             "reverse_icons",
 2798:             "icons_only",
 2799:             "icons",
 2800:         }
 2801: 
 2802:         # Check for valid input parameters.
 2803:         for param_key in options.keys():
 2804:             if param_key not in valid_parameter:
 2805:                 warn("Unknown parameter '%s' in conditional_format()" % param_key)
 2806:                 return -2
 2807: 
 2808:         # 'type' is a required parameter.
 2809:         if "type" not in options:
 2810:             warn("Parameter 'type' is required in conditional_format()")
 2811:             return -2
 2812: 
 2813:         # Valid types.
 2814:         valid_type = {
 2815:             "cell": "cellIs",
 2816:             "date": "date",
 2817:             "time": "time",
 2818:             "average": "aboveAverage",
 2819:             "duplicate": "duplicateValues",
 2820:             "unique": "uniqueValues",
 2821:             "top": "top10",
 2822:             "bottom": "top10",
 2823:             "text": "text",
 2824:             "time_period": "timePeriod",
 2825:             "blanks": "containsBlanks",
 2826:             "no_blanks": "notContainsBlanks",
 2827:             "errors": "containsErrors",
 2828:             "no_errors": "notContainsErrors",
 2829:             "2_color_scale": "2_color_scale",
 2830:             "3_color_scale": "3_color_scale",
 2831:             "data_bar": "dataBar",
 2832:             "formula": "expression",
 2833:             "icon_set": "iconSet",
 2834:         }
 2835: 
 2836:         # Check for valid types.
 2837:         if options["type"] not in valid_type:
 2838:             warn(
 2839:                 "Unknown value '%s' for parameter 'type' "
 2840:                 "in conditional_format()" % options["type"]
 2841:             )
 2842:             return -2
 2843:         else:
 2844:             if options["type"] == "bottom":
 2845:                 options["direction"] = "bottom"
 2846:             options["type"] = valid_type[options["type"]]
 2847: 
 2848:         # Valid criteria types.
 2849:         criteria_type = {
 2850:             "between": "between",
 2851:             "not between": "notBetween",
 2852:             "equal to": "equal",
 2853:             "=": "equal",
 2854:             "==": "equal",
 2855:             "not equal to": "notEqual",
 2856:             "!=": "notEqual",
 2857:             "<>": "notEqual",
 2858:             "greater than": "greaterThan",
 2859:             ">": "greaterThan",
 2860:             "less than": "lessThan",
 2861:             "<": "lessThan",
 2862:             "greater than or equal to": "greaterThanOrEqual",
 2863:             ">=": "greaterThanOrEqual",
 2864:             "less than or equal to": "lessThanOrEqual",
 2865:             "<=": "lessThanOrEqual",
 2866:             "containing": "containsText",
 2867:             "not containing": "notContains",
 2868:             "begins with": "beginsWith",
 2869:             "ends with": "endsWith",
 2870:             "yesterday": "yesterday",
 2871:             "today": "today",
 2872:             "last 7 days": "last7Days",
 2873:             "last week": "lastWeek",
 2874:             "this week": "thisWeek",
 2875:             "next week": "nextWeek",
 2876:             "last month": "lastMonth",
 2877:             "this month": "thisMonth",
 2878:             "next month": "nextMonth",
 2879:             # For legacy, but incorrect, support.
 2880:             "continue week": "nextWeek",
 2881:             "continue month": "nextMonth",
 2882:         }
 2883: 
 2884:         # Check for valid criteria types.
 2885:         if "criteria" in options and options["criteria"] in criteria_type:
 2886:             options["criteria"] = criteria_type[options["criteria"]]
 2887: 
 2888:         # Convert date/times value if required.
 2889:         if options["type"] in ("date", "time"):
 2890:             options["type"] = "cellIs"
 2891: 
 2892:             if "value" in options:
 2893:                 if not supported_datetime(options["value"]):
 2894:                     warn("Conditional format 'value' must be a datetime object.")
 2895:                     return -2
 2896:                 else:
 2897:                     date_time = self._convert_date_time(options["value"])
 2898:                     # Format date number to the same precision as Excel.
 2899:                     options["value"] = "%.16g" % date_time
 2900: 
 2901:             if "minimum" in options:
 2902:                 if not supported_datetime(options["minimum"]):
 2903:                     warn("Conditional format 'minimum' must be a datetime object.")
 2904:                     return -2
 2905:                 else:
 2906:                     date_time = self._convert_date_time(options["minimum"])
 2907:                     options["minimum"] = "%.16g" % date_time
 2908: 
 2909:             if "maximum" in options:
 2910:                 if not supported_datetime(options["maximum"]):
 2911:                     warn("Conditional format 'maximum' must be a datetime object.")
 2912:                     return -2
 2913:                 else:
 2914:                     date_time = self._convert_date_time(options["maximum"])
 2915:                     options["maximum"] = "%.16g" % date_time
 2916: 
 2917:         # Valid icon styles.
 2918:         valid_icons = {
 2919:             "3_arrows": "3Arrows",  # 1
 2920:             "3_flags": "3Flags",  # 2
 2921:             "3_traffic_lights_rimmed": "3TrafficLights2",  # 3
 2922:             "3_symbols_circled": "3Symbols",  # 4
 2923:             "4_arrows": "4Arrows",  # 5
 2924:             "4_red_to_black": "4RedToBlack",  # 6
 2925:             "4_traffic_lights": "4TrafficLights",  # 7
 2926:             "5_arrows_gray": "5ArrowsGray",  # 8
 2927:             "5_quarters": "5Quarters",  # 9
 2928:             "3_arrows_gray": "3ArrowsGray",  # 10
 2929:             "3_traffic_lights": "3TrafficLights",  # 11
 2930:             "3_signs": "3Signs",  # 12
 2931:             "3_symbols": "3Symbols2",  # 13
 2932:             "4_arrows_gray": "4ArrowsGray",  # 14
 2933:             "4_ratings": "4Rating",  # 15
 2934:             "5_arrows": "5Arrows",  # 16
 2935:             "5_ratings": "5Rating",
 2936:         }  # 17
 2937: 
 2938:         # Set the icon set properties.
 2939:         if options["type"] == "iconSet":
 2940:             # An icon_set must have an icon style.
 2941:             if not options.get("icon_style"):
 2942:                 warn(
 2943:                     "The 'icon_style' parameter must be specified when "
 2944:                     "'type' == 'icon_set' in conditional_format()"
 2945:                 )
 2946:                 return -3
 2947: 
 2948:             # Check for valid icon styles.
 2949:             if options["icon_style"] not in valid_icons:
 2950:                 warn(
 2951:                     "Unknown icon_style '%s' in conditional_format()"
 2952:                     % options["icon_style"]
 2953:                 )
 2954:                 return -2
 2955:             else:
 2956:                 options["icon_style"] = valid_icons[options["icon_style"]]
 2957: 
 2958:             # Set the number of icons for the icon style.
 2959:             options["total_icons"] = 3
 2960:             if options["icon_style"].startswith("4"):
 2961:                 options["total_icons"] = 4
 2962:             elif options["icon_style"].startswith("5"):
 2963:                 options["total_icons"] = 5
 2964: 
 2965:             options["icons"] = self._set_icon_props(
 2966:                 options.get("total_icons"), options.get("icons")
 2967:             )
 2968: 
 2969:         # Swap last row/col for first row/col as necessary
 2970:         if first_row > last_row:
 2971:             first_row, last_row = last_row, first_row
 2972: 
 2973:         if first_col > last_col:
 2974:             first_col, last_col = last_col, first_col
 2975: 
 2976:         # Set the formatting range.
 2977:         cell_range = xl_range(first_row, first_col, last_row, last_col)
 2978:         start_cell = xl_rowcol_to_cell(first_row, first_col)
 2979: 
 2980:         # Override with user defined multiple range if provided.
 2981:         if "multi_range" in options:
 2982:             cell_range = options["multi_range"]
 2983:             cell_range = cell_range.replace("$", "")
 2984: 
 2985:         # Get the dxf format index.
 2986:         if "format" in options and options["format"]:
 2987:             options["format"] = options["format"]._get_dxf_index()
 2988: 
 2989:         # Set the priority based on the order of adding.
 2990:         options["priority"] = self.dxf_priority
 2991:         self.dxf_priority += 1
 2992: 
 2993:         # Check for 2010 style data_bar parameters.
 2994:         if (
 2995:             self.use_data_bars_2010
 2996:             or options.get("data_bar_2010")
 2997:             or options.get("bar_solid")
 2998:             or options.get("bar_border_color")
 2999:             or options.get("bar_negative_color")
 3000:             or options.get("bar_negative_color_same")
 3001:             or options.get("bar_negative_border_color")
 3002:             or options.get("bar_negative_border_color_same")
 3003:             or options.get("bar_no_border")
 3004:             or options.get("bar_axis_position")
 3005:             or options.get("bar_axis_color")
 3006:             or options.get("bar_direction")
 3007:         ):
 3008:             options["is_data_bar_2010"] = True
 3009: 
 3010:         # Special handling of text criteria.
 3011:         if options["type"] == "text":
 3012:             if options["criteria"] == "containsText":
 3013:                 options["type"] = "containsText"
 3014:                 options["formula"] = 'NOT(ISERROR(SEARCH("%s",%s)))' % (
 3015:                     options["value"],
 3016:                     start_cell,
 3017:                 )
 3018:             elif options["criteria"] == "notContains":
 3019:                 options["type"] = "notContainsText"
 3020:                 options["formula"] = 'ISERROR(SEARCH("%s",%s))' % (
 3021:                     options["value"],
 3022:                     start_cell,
 3023:                 )
 3024:             elif options["criteria"] == "beginsWith":
 3025:                 options["type"] = "beginsWith"
 3026:                 options["formula"] = 'LEFT(%s,%d)="%s"' % (
 3027:                     start_cell,
 3028:                     len(options["value"]),
 3029:                     options["value"],
 3030:                 )
 3031:             elif options["criteria"] == "endsWith":
 3032:                 options["type"] = "endsWith"
 3033:                 options["formula"] = 'RIGHT(%s,%d)="%s"' % (
 3034:                     start_cell,
 3035:                     len(options["value"]),
 3036:                     options["value"],
 3037:                 )
 3038:             else:
 3039:                 warn(
 3040:                     "Invalid text criteria '%s' "
 3041:                     "in conditional_format()" % options["criteria"]
 3042:                 )
 3043: 
 3044:         # Special handling of time time_period criteria.
 3045:         if options["type"] == "timePeriod":
 3046:             if options["criteria"] == "yesterday":
 3047:                 options["formula"] = "FLOOR(%s,1)=TODAY()-1" % start_cell
 3048: 
 3049:             elif options["criteria"] == "today":
 3050:                 options["formula"] = "FLOOR(%s,1)=TODAY()" % start_cell
 3051: 
 3052:             elif options["criteria"] == "tomorrow":
 3053:                 options["formula"] = "FLOOR(%s,1)=TODAY()+1" % start_cell
 3054: 
 3055:             # fmt: off
 3056:             elif options["criteria"] == "last7Days":
 3057:                 options["formula"] = (
 3058:                     "AND(TODAY()-FLOOR(%s,1)<=6,FLOOR(%s,1)<=TODAY())"
 3059:                     % (start_cell, start_cell)
 3060:                 )
 3061:             # fmt: on
 3062: 
 3063:             elif options["criteria"] == "lastWeek":
 3064:                 options["formula"] = (
 3065:                     "AND(TODAY()-ROUNDDOWN(%s,0)>=(WEEKDAY(TODAY())),"
 3066:                     "TODAY()-ROUNDDOWN(%s,0)<(WEEKDAY(TODAY())+7))"
 3067:                     % (start_cell, start_cell)
 3068:                 )
 3069: 
 3070:             elif options["criteria"] == "thisWeek":
 3071:                 options["formula"] = (
 3072:                     "AND(TODAY()-ROUNDDOWN(%s,0)<=WEEKDAY(TODAY())-1,"
 3073:                     "ROUNDDOWN(%s,0)-TODAY()<=7-WEEKDAY(TODAY()))"
 3074:                     % (start_cell, start_cell)
 3075:                 )
 3076: 
 3077:             elif options["criteria"] == "nextWeek":
 3078:                 options["formula"] = (
 3079:                     "AND(ROUNDDOWN(%s,0)-TODAY()>(7-WEEKDAY(TODAY())),"
 3080:                     "ROUNDDOWN(%s,0)-TODAY()<(15-WEEKDAY(TODAY())))"
 3081:                     % (start_cell, start_cell)
 3082:                 )
 3083: 
 3084:             elif options["criteria"] == "lastMonth":
 3085:                 options["formula"] = (
 3086:                     "AND(MONTH(%s)=MONTH(TODAY())-1,OR(YEAR(%s)=YEAR("
 3087:                     "TODAY()),AND(MONTH(%s)=1,YEAR(A1)=YEAR(TODAY())-1)))"
 3088:                     % (start_cell, start_cell, start_cell)
 3089:                 )
 3090: 
 3091:             # fmt: off
 3092:             elif options["criteria"] == "thisMonth":
 3093:                 options["formula"] = (
 3094:                     "AND(MONTH(%s)=MONTH(TODAY()),YEAR(%s)=YEAR(TODAY()))"
 3095:                     % (start_cell, start_cell)
 3096:                 )
 3097:             # fmt: on
 3098: 
 3099:             elif options["criteria"] == "nextMonth":
 3100:                 options["formula"] = (
 3101:                     "AND(MONTH(%s)=MONTH(TODAY())+1,OR(YEAR(%s)=YEAR("
 3102:                     "TODAY()),AND(MONTH(%s)=12,YEAR(%s)=YEAR(TODAY())+1)))"
 3103:                     % (start_cell, start_cell, start_cell, start_cell)
 3104:                 )
 3105: 
 3106:             else:
 3107:                 warn(
 3108:                     "Invalid time_period criteria '%s' "
 3109:                     "in conditional_format()" % options["criteria"]
 3110:                 )
 3111: 
 3112:         # Special handling of blanks/error types.
 3113:         if options["type"] == "containsBlanks":
 3114:             options["formula"] = "LEN(TRIM(%s))=0" % start_cell
 3115: 
 3116:         if options["type"] == "notContainsBlanks":
 3117:             options["formula"] = "LEN(TRIM(%s))>0" % start_cell
 3118: 
 3119:         if options["type"] == "containsErrors":
 3120:             options["formula"] = "ISERROR(%s)" % start_cell
 3121: 
 3122:         if options["type"] == "notContainsErrors":
 3123:             options["formula"] = "NOT(ISERROR(%s))" % start_cell
 3124: 
 3125:         # Special handling for 2 color scale.
 3126:         if options["type"] == "2_color_scale":
 3127:             options["type"] = "colorScale"
 3128: 
 3129:             # Color scales don't use any additional formatting.
 3130:             options["format"] = None
 3131: 
 3132:             # Turn off 3 color parameters.
 3133:             options["mid_type"] = None
 3134:             options["mid_color"] = None
 3135: 
 3136:             options.setdefault("min_type", "min")
 3137:             options.setdefault("max_type", "max")
 3138:             options.setdefault("min_value", 0)
 3139:             options.setdefault("max_value", 0)
 3140:             options.setdefault("min_color", "#FF7128")
 3141:             options.setdefault("max_color", "#FFEF9C")
 3142: 
 3143:             options["min_color"] = xl_color(options["min_color"])
 3144:             options["max_color"] = xl_color(options["max_color"])
 3145: 
 3146:         # Special handling for 3 color scale.
 3147:         if options["type"] == "3_color_scale":
 3148:             options["type"] = "colorScale"
 3149: 
 3150:             # Color scales don't use any additional formatting.
 3151:             options["format"] = None
 3152: 
 3153:             options.setdefault("min_type", "min")
 3154:             options.setdefault("mid_type", "percentile")
 3155:             options.setdefault("max_type", "max")
 3156:             options.setdefault("min_value", 0)
 3157:             options.setdefault("max_value", 0)
 3158:             options.setdefault("min_color", "#F8696B")
 3159:             options.setdefault("mid_color", "#FFEB84")
 3160:             options.setdefault("max_color", "#63BE7B")
 3161: 
 3162:             options["min_color"] = xl_color(options["min_color"])
 3163:             options["mid_color"] = xl_color(options["mid_color"])
 3164:             options["max_color"] = xl_color(options["max_color"])
 3165: 
 3166:             # Set a default mid value.
 3167:             if "mid_value" not in options:
 3168:                 options["mid_value"] = 50
 3169: 
 3170:         # Special handling for data bar.
 3171:         if options["type"] == "dataBar":
 3172:             # Color scales don't use any additional formatting.
 3173:             options["format"] = None
 3174: 
 3175:             if not options.get("min_type"):
 3176:                 options["min_type"] = "min"
 3177:                 options["x14_min_type"] = "autoMin"
 3178:             else:
 3179:                 options["x14_min_type"] = options["min_type"]
 3180: 
 3181:             if not options.get("max_type"):
 3182:                 options["max_type"] = "max"
 3183:                 options["x14_max_type"] = "autoMax"
 3184:             else:
 3185:                 options["x14_max_type"] = options["max_type"]
 3186: 
 3187:             options.setdefault("min_value", 0)
 3188:             options.setdefault("max_value", 0)
 3189:             options.setdefault("bar_color", "#638EC6")
 3190:             options.setdefault("bar_border_color", options["bar_color"])
 3191:             options.setdefault("bar_only", False)
 3192:             options.setdefault("bar_no_border", False)
 3193:             options.setdefault("bar_solid", False)
 3194:             options.setdefault("bar_direction", "")
 3195:             options.setdefault("bar_negative_color", "#FF0000")
 3196:             options.setdefault("bar_negative_border_color", "#FF0000")
 3197:             options.setdefault("bar_negative_color_same", False)
 3198:             options.setdefault("bar_negative_border_color_same", False)
 3199:             options.setdefault("bar_axis_position", "")
 3200:             options.setdefault("bar_axis_color", "#000000")
 3201: 
 3202:             options["bar_color"] = xl_color(options["bar_color"])
 3203:             options["bar_border_color"] = xl_color(options["bar_border_color"])
 3204:             options["bar_axis_color"] = xl_color(options["bar_axis_color"])
 3205:             options["bar_negative_color"] = xl_color(options["bar_negative_color"])
 3206:             options["bar_negative_border_color"] = xl_color(
 3207:                 options["bar_negative_border_color"]
 3208:             )
 3209: 
 3210:         # Adjust for 2010 style data_bar parameters.
 3211:         if options.get("is_data_bar_2010"):
 3212:             self.excel_version = 2010
 3213: 
 3214:             if options["min_type"] == "min" and options["min_value"] == 0:
 3215:                 options["min_value"] = None
 3216: 
 3217:             if options["max_type"] == "max" and options["max_value"] == 0:
 3218:                 options["max_value"] = None
 3219: 
 3220:             options["range"] = cell_range
 3221: 
 3222:         # Strip the leading = from formulas.
 3223:         try:
 3224:             options["min_value"] = options["min_value"].lstrip("=")
 3225:         except (KeyError, AttributeError):
 3226:             pass
 3227:         try:
 3228:             options["mid_value"] = options["mid_value"].lstrip("=")
 3229:         except (KeyError, AttributeError):
 3230:             pass
 3231:         try:
 3232:             options["max_value"] = options["max_value"].lstrip("=")
 3233:         except (KeyError, AttributeError):
 3234:             pass
 3235: 
 3236:         # Store the conditional format until we close the worksheet.
 3237:         if cell_range in self.cond_formats:
 3238:             self.cond_formats[cell_range].append(options)
 3239:         else:
 3240:             self.cond_formats[cell_range] = [options]
 3241: 
 3242:         return 0
 3243: 
 3244:     @convert_range_args
 3245:     def add_table(self, first_row, first_col, last_row, last_col, options=None):
 3246:         """
 3247:         Add an Excel table to a worksheet.
 3248: 
 3249:         Args:
 3250:             first_row:    The first row of the cell range. (zero indexed).
 3251:             first_col:    The first column of the cell range.
 3252:             last_row:     The last row of the cell range. (zero indexed).
 3253:             last_col:     The last column of the cell range.
 3254:             options:      Table format options. (Optional)
 3255: 
 3256:         Returns:
 3257:             0:  Success.
 3258:             -1: Row or column is out of worksheet bounds.
 3259:             -2: Incorrect parameter or option.
 3260:             -3: Not supported in constant_memory mode.
 3261:         """
 3262:         table = {}
 3263:         col_formats = {}
 3264: 
 3265:         if options is None:
 3266:             options = {}
 3267:         else:
 3268:             # Copy the user defined options so they aren't modified.
 3269:             options = options.copy()
 3270: 
 3271:         if self.constant_memory:
 3272:             warn("add_table() isn't supported in 'constant_memory' mode")
 3273:             return -3
 3274: 
 3275:         # Check that row and col are valid without storing the values.
 3276:         if self._check_dimensions(first_row, first_col, True, True):
 3277:             return -1
 3278:         if self._check_dimensions(last_row, last_col, True, True):
 3279:             return -1
 3280: 
 3281:         # Swap last row/col for first row/col as necessary.
 3282:         if first_row > last_row:
 3283:             (first_row, last_row) = (last_row, first_row)
 3284:         if first_col > last_col:
 3285:             (first_col, last_col) = (last_col, first_col)
 3286: 
 3287:         # Check if the table range overlaps a previous merged or table range.
 3288:         # This is a critical file corruption error in Excel.
 3289:         cell_range = xl_range(first_row, first_col, last_row, last_col)
 3290:         for row in range(first_row, last_row + 1):
 3291:             for col in range(first_col, last_col + 1):
 3292:                 if self.table_cells.get((row, col)):
 3293:                     previous_range = self.table_cells.get((row, col))
 3294:                     raise OverlappingRange(
 3295:                         "Table range '%s' overlaps previous table range '%s'."
 3296:                         % (cell_range, previous_range)
 3297:                     )
 3298:                 elif self.merged_cells.get((row, col)):
 3299:                     previous_range = self.merged_cells.get((row, col))
 3300:                     raise OverlappingRange(
 3301:                         "Table range '%s' overlaps previous merge range '%s'."
 3302:                         % (cell_range, previous_range)
 3303:                     )
 3304:                 else:
 3305:                     self.table_cells[(row, col)] = cell_range
 3306: 
 3307:         # Valid input parameters.
 3308:         valid_parameter = {
 3309:             "autofilter",
 3310:             "banded_columns",
 3311:             "banded_rows",
 3312:             "columns",
 3313:             "data",
 3314:             "first_column",
 3315:             "header_row",
 3316:             "last_column",
 3317:             "name",
 3318:             "style",
 3319:             "total_row",
 3320:         }
 3321: 
 3322:         # Check for valid input parameters.
 3323:         for param_key in options.keys():
 3324:             if param_key not in valid_parameter:
 3325:                 warn("Unknown parameter '%s' in add_table()" % param_key)
 3326:                 return -2
 3327: 
 3328:         # Turn on Excel's defaults.
 3329:         options["banded_rows"] = options.get("banded_rows", True)
 3330:         options["header_row"] = options.get("header_row", True)
 3331:         options["autofilter"] = options.get("autofilter", True)
 3332: 
 3333:         # Check that there are enough rows.
 3334:         num_rows = last_row - first_row
 3335:         if options["header_row"]:
 3336:             num_rows -= 1
 3337: 
 3338:         if num_rows < 0:
 3339:             warn("Must have at least one data row in in add_table()")
 3340:             return -2
 3341: 
 3342:         # Set the table options.
 3343:         table["show_first_col"] = options.get("first_column", False)
 3344:         table["show_last_col"] = options.get("last_column", False)
 3345:         table["show_row_stripes"] = options.get("banded_rows", False)
 3346:         table["show_col_stripes"] = options.get("banded_columns", False)
 3347:         table["header_row_count"] = options.get("header_row", 0)
 3348:         table["totals_row_shown"] = options.get("total_row", False)
 3349: 
 3350:         # Set the table name.
 3351:         if "name" in options:
 3352:             name = options["name"]
 3353:             table["name"] = name
 3354: 
 3355:             if " " in name:
 3356:                 warn("Name '%s' in add_table() cannot contain spaces" % name)
 3357:                 return -2
 3358: 
 3359:             # Warn if the name contains invalid chars as defined by Excel.
 3360:             if not re.match(r"^[\w\\][\w\\.]*$", name, re.UNICODE) or re.match(
 3361:                 r"^\d", name
 3362:             ):
 3363:                 warn("Invalid Excel characters in add_table(): '%s'" % name)
 3364:                 return -2
 3365: 
 3366:             # Warn if the name looks like a cell name.
 3367:             if re.match(r"^[a-zA-Z][a-zA-Z]?[a-dA-D]?\d+$", name):
 3368:                 warn("Name looks like a cell name in add_table(): '%s'" % name)
 3369:                 return -2
 3370: 
 3371:             # Warn if the name looks like a R1C1 cell reference.
 3372:             if re.match(r"^[rcRC]$", name) or re.match(r"^[rcRC]\d+[rcRC]\d+$", name):
 3373:                 warn("Invalid name '%s' like a RC cell ref in add_table()" % name)
 3374:                 return -2
 3375: 
 3376:         # Set the table style.
 3377:         if "style" in options:
 3378:             table["style"] = options["style"]
 3379: 
 3380:             if table["style"] is None:
 3381:                 table["style"] = ""
 3382: 
 3383:             # Remove whitespace from style name.
 3384:             table["style"] = table["style"].replace(" ", "")
 3385:         else:
 3386:             table["style"] = "TableStyleMedium9"
 3387: 
 3388:         # Set the data range rows (without the header and footer).
 3389:         first_data_row = first_row
 3390:         last_data_row = last_row
 3391: 
 3392:         if options.get("header_row"):
 3393:             first_data_row += 1
 3394: 
 3395:         if options.get("total_row"):
 3396:             last_data_row -= 1
 3397: 
 3398:         # Set the table and autofilter ranges.
 3399:         table["range"] = xl_range(first_row, first_col, last_row, last_col)
 3400: 
 3401:         table["a_range"] = xl_range(first_row, first_col, last_data_row, last_col)
 3402: 
 3403:         # If the header row if off the default is to turn autofilter off.
 3404:         if not options["header_row"]:
 3405:             options["autofilter"] = 0
 3406: 
 3407:         # Set the autofilter range.
 3408:         if options["autofilter"]:
 3409:             table["autofilter"] = table["a_range"]
 3410: 
 3411:         # Add the table columns.
 3412:         col_id = 1
 3413:         table["columns"] = []
 3414:         seen_names = {}
 3415: 
 3416:         for col_num in range(first_col, last_col + 1):
 3417:             # Set up the default column data.
 3418:             col_data = {
 3419:                 "id": col_id,
 3420:                 "name": "Column" + str(col_id),
 3421:                 "total_string": "",
 3422:                 "total_function": "",
 3423:                 "custom_total": "",
 3424:                 "total_value": 0,
 3425:                 "formula": "",
 3426:                 "format": None,
 3427:                 "name_format": None,
 3428:             }
 3429: 
 3430:             # Overwrite the defaults with any user defined values.
 3431:             if "columns" in options:
 3432:                 # Check if there are user defined values for this column.
 3433:                 if col_id <= len(options["columns"]):
 3434:                     user_data = options["columns"][col_id - 1]
 3435:                 else:
 3436:                     user_data = None
 3437: 
 3438:                 if user_data:
 3439:                     # Get the column format.
 3440:                     xformat = user_data.get("format", None)
 3441: 
 3442:                     # Map user defined values to internal values.
 3443:                     if user_data.get("header"):
 3444:                         col_data["name"] = user_data["header"]
 3445: 
 3446:                     # Excel requires unique case insensitive header names.
 3447:                     header_name = col_data["name"]
 3448:                     name = header_name.lower()
 3449:                     if name in seen_names:
 3450:                         warn("Duplicate header name in add_table(): '%s'" % name)
 3451:                         return -2
 3452:                     else:
 3453:                         seen_names[name] = True
 3454: 
 3455:                     col_data["name_format"] = user_data.get("header_format")
 3456: 
 3457:                     # Handle the column formula.
 3458:                     if "formula" in user_data and user_data["formula"]:
 3459:                         formula = user_data["formula"]
 3460: 
 3461:                         # Remove the formula '=' sign if it exists.
 3462:                         if formula.startswith("="):
 3463:                             formula = formula.lstrip("=")
 3464: 
 3465:                         # Convert Excel 2010 "@" ref to 2007 "#This Row".
 3466:                         formula = formula.replace("@", "[#This Row],")
 3467: 
 3468:                         # Escape any future functions.
 3469:                         formula = self._prepare_formula(formula, True)
 3470: 
 3471:                         col_data["formula"] = formula
 3472:                         # We write the formulas below after the table data.
 3473: 
 3474:                     # Handle the function for the total row.
 3475:                     if user_data.get("total_function"):
 3476:                         function = user_data["total_function"]
 3477:                         if function == "count_nums":
 3478:                             function = "countNums"
 3479:                         if function == "std_dev":
 3480:                             function = "stdDev"
 3481: 
 3482:                         subtotals = set(
 3483:                             [
 3484:                                 "average",
 3485:                                 "countNums",
 3486:                                 "count",
 3487:                                 "max",
 3488:                                 "min",
 3489:                                 "stdDev",
 3490:                                 "sum",
 3491:                                 "var",
 3492:                             ]
 3493:                         )
 3494: 
 3495:                         if function in subtotals:
 3496:                             formula = self._table_function_to_formula(
 3497:                                 function, col_data["name"]
 3498:                             )
 3499:                         else:
 3500:                             formula = self._prepare_formula(function, True)
 3501:                             col_data["custom_total"] = formula
 3502:                             function = "custom"
 3503: 
 3504:                         col_data["total_function"] = function
 3505: 
 3506:                         value = user_data.get("total_value", 0)
 3507: 
 3508:                         self._write_formula(last_row, col_num, formula, xformat, value)
 3509: 
 3510:                     elif user_data.get("total_string"):
 3511:                         # Total label only (not a function).
 3512:                         total_string = user_data["total_string"]
 3513:                         col_data["total_string"] = total_string
 3514: 
 3515:                         self._write_string(
 3516:                             last_row, col_num, total_string, user_data.get("format")
 3517:                         )
 3518: 
 3519:                     # Get the dxf format index.
 3520:                     if xformat is not None:
 3521:                         col_data["format"] = xformat._get_dxf_index()
 3522: 
 3523:                     # Store the column format for writing the cell data.
 3524:                     # It doesn't matter if it is undefined.
 3525:                     col_formats[col_id - 1] = xformat
 3526: 
 3527:             # Store the column data.
 3528:             table["columns"].append(col_data)
 3529: 
 3530:             # Write the column headers to the worksheet.
 3531:             if options["header_row"]:
 3532:                 self._write_string(
 3533:                     first_row, col_num, col_data["name"], col_data["name_format"]
 3534:                 )
 3535: 
 3536:             col_id += 1
 3537: 
 3538:         # Write the cell data if supplied.
 3539:         if "data" in options:
 3540:             data = options["data"]
 3541: 
 3542:             i = 0  # For indexing the row data.
 3543:             for row in range(first_data_row, last_data_row + 1):
 3544:                 j = 0  # For indexing the col data.
 3545:                 for col in range(first_col, last_col + 1):
 3546:                     if i < len(data) and j < len(data[i]):
 3547:                         token = data[i][j]
 3548:                         if j in col_formats:
 3549:                             self._write(row, col, token, col_formats[j])
 3550:                         else:
 3551:                             self._write(row, col, token, None)
 3552:                     j += 1
 3553:                 i += 1
 3554: 
 3555:         # Write any columns formulas after the user supplied table data to
 3556:         # overwrite it if required.
 3557:         for col_id, col_num in enumerate(range(first_col, last_col + 1)):
 3558:             column_data = table["columns"][col_id]
 3559:             if column_data and column_data["formula"]:
 3560:                 formula_format = col_formats.get(col_id)
 3561:                 formula = column_data["formula"]
 3562: 
 3563:                 for row in range(first_data_row, last_data_row + 1):
 3564:                     self._write_formula(row, col_num, formula, formula_format)
 3565: 
 3566:         # Store the table data.
 3567:         self.tables.append(table)
 3568: 
 3569:         # Store the filter cell positions for use in the autofit calculation.
 3570:         if options["autofilter"]:
 3571:             for col in range(first_col, last_col + 1):
 3572:                 self.filter_cells[(first_row, col)] = True
 3573: 
 3574:         return 0
 3575: 
 3576:     @convert_cell_args
 3577:     def add_sparkline(self, row, col, options=None):
 3578:         """
 3579:         Add sparklines to the worksheet.
 3580: 
 3581:         Args:
 3582:             row:     The cell row (zero indexed).
 3583:             col:     The cell column (zero indexed).
 3584:             options: Sparkline formatting options.
 3585: 
 3586:         Returns:
 3587:             0:  Success.
 3588:             -1: Row or column is out of worksheet bounds.
 3589:             -2: Incorrect parameter or option.
 3590: 
 3591:         """
 3592: 
 3593:         # Check that row and col are valid without storing the values.
 3594:         if self._check_dimensions(row, col, True, True):
 3595:             return -1
 3596: 
 3597:         sparkline = {"locations": [xl_rowcol_to_cell(row, col)]}
 3598: 
 3599:         if options is None:
 3600:             options = {}
 3601: 
 3602:         # Valid input parameters.
 3603:         valid_parameters = {
 3604:             "location",
 3605:             "range",
 3606:             "type",
 3607:             "high_point",
 3608:             "low_point",
 3609:             "negative_points",
 3610:             "first_point",
 3611:             "last_point",
 3612:             "markers",
 3613:             "style",
 3614:             "series_color",
 3615:             "negative_color",
 3616:             "markers_color",
 3617:             "first_color",
 3618:             "last_color",
 3619:             "high_color",
 3620:             "low_color",
 3621:             "max",
 3622:             "min",
 3623:             "axis",
 3624:             "reverse",
 3625:             "empty_cells",
 3626:             "show_hidden",
 3627:             "plot_hidden",
 3628:             "date_axis",
 3629:             "weight",
 3630:         }
 3631: 
 3632:         # Check for valid input parameters.
 3633:         for param_key in options.keys():
 3634:             if param_key not in valid_parameters:
 3635:                 warn("Unknown parameter '%s' in add_sparkline()" % param_key)
 3636:                 return -1
 3637: 
 3638:         # 'range' is a required parameter.
 3639:         if "range" not in options:
 3640:             warn("Parameter 'range' is required in add_sparkline()")
 3641:             return -2
 3642: 
 3643:         # Handle the sparkline type.
 3644:         spark_type = options.get("type", "line")
 3645: 
 3646:         if spark_type not in ("line", "column", "win_loss"):
 3647:             warn(
 3648:                 "Parameter 'type' must be 'line', 'column' "
 3649:                 "or 'win_loss' in add_sparkline()"
 3650:             )
 3651:             return -2
 3652: 
 3653:         if spark_type == "win_loss":
 3654:             spark_type = "stacked"
 3655:         sparkline["type"] = spark_type
 3656: 
 3657:         # We handle single location/range values or list of values.
 3658:         if "location" in options:
 3659:             if isinstance(options["location"], list):
 3660:                 sparkline["locations"] = options["location"]
 3661:             else:
 3662:                 sparkline["locations"] = [options["location"]]
 3663: 
 3664:         if isinstance(options["range"], list):
 3665:             sparkline["ranges"] = options["range"]
 3666:         else:
 3667:             sparkline["ranges"] = [options["range"]]
 3668: 
 3669:         range_count = len(sparkline["ranges"])
 3670:         location_count = len(sparkline["locations"])
 3671: 
 3672:         # The ranges and locations must match.
 3673:         if range_count != location_count:
 3674:             warn(
 3675:                 "Must have the same number of location and range "
 3676:                 "parameters in add_sparkline()"
 3677:             )
 3678:             return -2
 3679: 
 3680:         # Store the count.
 3681:         sparkline["count"] = len(sparkline["locations"])
 3682: 
 3683:         # Get the worksheet name for the range conversion below.
 3684:         sheetname = quote_sheetname(self.name)
 3685: 
 3686:         # Cleanup the input ranges.
 3687:         new_ranges = []
 3688:         for spark_range in sparkline["ranges"]:
 3689:             # Remove the absolute reference $ symbols.
 3690:             spark_range = spark_range.replace("$", "")
 3691: 
 3692:             # Remove the = from formula.
 3693:             spark_range = spark_range.lstrip("=")
 3694: 
 3695:             # Convert a simple range into a full Sheet1!A1:D1 range.
 3696:             if "!" not in spark_range:
 3697:                 spark_range = sheetname + "!" + spark_range
 3698: 
 3699:             new_ranges.append(spark_range)
 3700: 
 3701:         sparkline["ranges"] = new_ranges
 3702: 
 3703:         # Cleanup the input locations.
 3704:         new_locations = []
 3705:         for location in sparkline["locations"]:
 3706:             location = location.replace("$", "")
 3707:             new_locations.append(location)
 3708: 
 3709:         sparkline["locations"] = new_locations
 3710: 
 3711:         # Map options.
 3712:         sparkline["high"] = options.get("high_point")
 3713:         sparkline["low"] = options.get("low_point")
 3714:         sparkline["negative"] = options.get("negative_points")
 3715:         sparkline["first"] = options.get("first_point")
 3716:         sparkline["last"] = options.get("last_point")
 3717:         sparkline["markers"] = options.get("markers")
 3718:         sparkline["min"] = options.get("min")
 3719:         sparkline["max"] = options.get("max")
 3720:         sparkline["axis"] = options.get("axis")
 3721:         sparkline["reverse"] = options.get("reverse")
 3722:         sparkline["hidden"] = options.get("show_hidden")
 3723:         sparkline["weight"] = options.get("weight")
 3724: 
 3725:         # Map empty cells options.
 3726:         empty = options.get("empty_cells", "")
 3727: 
 3728:         if empty == "zero":
 3729:             sparkline["empty"] = 0
 3730:         elif empty == "connect":
 3731:             sparkline["empty"] = "span"
 3732:         else:
 3733:             sparkline["empty"] = "gap"
 3734: 
 3735:         # Map the date axis range.
 3736:         date_range = options.get("date_axis")
 3737: 
 3738:         if date_range and "!" not in date_range:
 3739:             date_range = sheetname + "!" + date_range
 3740: 
 3741:         sparkline["date_axis"] = date_range
 3742: 
 3743:         # Set the sparkline styles.
 3744:         style_id = options.get("style", 0)
 3745:         style = get_sparkline_style(style_id)
 3746: 
 3747:         sparkline["series_color"] = style["series"]
 3748:         sparkline["negative_color"] = style["negative"]
 3749:         sparkline["markers_color"] = style["markers"]
 3750:         sparkline["first_color"] = style["first"]
 3751:         sparkline["last_color"] = style["last"]
 3752:         sparkline["high_color"] = style["high"]
 3753:         sparkline["low_color"] = style["low"]
 3754: 
 3755:         # Override the style colors with user defined colors.
 3756:         self._set_spark_color(sparkline, options, "series_color")
 3757:         self._set_spark_color(sparkline, options, "negative_color")
 3758:         self._set_spark_color(sparkline, options, "markers_color")
 3759:         self._set_spark_color(sparkline, options, "first_color")
 3760:         self._set_spark_color(sparkline, options, "last_color")
 3761:         self._set_spark_color(sparkline, options, "high_color")
 3762:         self._set_spark_color(sparkline, options, "low_color")
 3763: 
 3764:         self.sparklines.append(sparkline)
 3765: 
 3766:         return 0
 3767: 
 3768:     @convert_range_args
 3769:     def set_selection(self, first_row, first_col, last_row, last_col):
 3770:         """
 3771:         Set the selected cell or cells in a worksheet
 3772: 
 3773:         Args:
 3774:             first_row:    The first row of the cell range. (zero indexed).
 3775:             first_col:    The first column of the cell range.
 3776:             last_row:     The last row of the cell range. (zero indexed).
 3777:             last_col:     The last column of the cell range.
 3778: 
 3779:         Returns:
 3780:             0:  Nothing.
 3781:         """
 3782:         pane = None
 3783: 
 3784:         # Range selection. Do this before swapping max/min to allow the
 3785:         # selection direction to be reversed.
 3786:         active_cell = xl_rowcol_to_cell(first_row, first_col)
 3787: 
 3788:         # Swap last row/col for first row/col if necessary
 3789:         if first_row > last_row:
 3790:             (first_row, last_row) = (last_row, first_row)
 3791: 
 3792:         if first_col > last_col:
 3793:             (first_col, last_col) = (last_col, first_col)
 3794: 
 3795:         sqref = xl_range(first_row, first_col, last_row, last_col)
 3796: 
 3797:         # Selection isn't set for cell A1.
 3798:         if sqref == "A1":
 3799:             return
 3800: 
 3801:         self.selections = [[pane, active_cell, sqref]]
 3802: 
 3803:     @convert_cell_args
 3804:     def set_top_left_cell(self, row=0, col=0):
 3805:         """
 3806:         Set the first visible cell at the top left of a worksheet.
 3807: 
 3808:         Args:
 3809:             row: The cell row (zero indexed).
 3810:             col: The cell column (zero indexed).
 3811: 
 3812:         Returns:
 3813:             0:  Nothing.
 3814:         """
 3815: 
 3816:         if row == 0 and col == 0:
 3817:             return
 3818: 
 3819:         self.top_left_cell = xl_rowcol_to_cell(row, col)
 3820: 
 3821:     def outline_settings(
 3822:         self, visible=1, symbols_below=1, symbols_right=1, auto_style=0
 3823:     ):
 3824:         """
 3825:         Control outline settings.
 3826: 
 3827:         Args:
 3828:             visible:       Outlines are visible. Optional, defaults to True.
 3829:             symbols_below: Show row outline symbols below the outline bar.
 3830:                            Optional, defaults to True.
 3831:             symbols_right: Show column outline symbols to the right of the
 3832:                            outline bar. Optional, defaults to True.
 3833:             auto_style:    Use Automatic style. Optional, defaults to False.
 3834: 
 3835:         Returns:
 3836:             0:  Nothing.
 3837:         """
 3838:         self.outline_on = visible
 3839:         self.outline_below = symbols_below
 3840:         self.outline_right = symbols_right
 3841:         self.outline_style = auto_style
 3842: 
 3843:         self.outline_changed = True
 3844: 
 3845:     @convert_cell_args
 3846:     def freeze_panes(self, row, col, top_row=None, left_col=None, pane_type=0):
 3847:         """
 3848:         Create worksheet panes and mark them as frozen.
 3849: 
 3850:         Args:
 3851:             row:      The cell row (zero indexed).
 3852:             col:      The cell column (zero indexed).
 3853:             top_row:  Topmost visible row in scrolling region of pane.
 3854:             left_col: Leftmost visible row in scrolling region of pane.
 3855: 
 3856:         Returns:
 3857:             0:  Nothing.
 3858: 
 3859:         """
 3860:         if top_row is None:
 3861:             top_row = row
 3862: 
 3863:         if left_col is None:
 3864:             left_col = col
 3865: 
 3866:         self.panes = [row, col, top_row, left_col, pane_type]
 3867: 
 3868:     @convert_cell_args
 3869:     def split_panes(self, x, y, top_row=None, left_col=None):
 3870:         """
 3871:         Create worksheet panes and mark them as split.
 3872: 
 3873:         Args:
 3874:             x:        The position for the vertical split.
 3875:             y:        The position for the horizontal split.
 3876:             top_row:  Topmost visible row in scrolling region of pane.
 3877:             left_col: Leftmost visible row in scrolling region of pane.
 3878: 
 3879:         Returns:
 3880:             0:  Nothing.
 3881: 
 3882:         """
 3883:         # Same as freeze panes with a different pane type.
 3884:         self.freeze_panes(x, y, top_row, left_col, 2)
 3885: 
 3886:     def set_zoom(self, zoom=100):
 3887:         """
 3888:         Set the worksheet zoom factor.
 3889: 
 3890:         Args:
 3891:             zoom: Scale factor: 10 <= zoom <= 400.
 3892: 
 3893:         Returns:
 3894:             Nothing.
 3895: 
 3896:         """
 3897:         # Ensure the zoom scale is in Excel's range.
 3898:         if zoom < 10 or zoom > 400:
 3899:             warn("Zoom factor %d outside range: 10 <= zoom <= 400" % zoom)
 3900:             zoom = 100
 3901: 
 3902:         self.zoom = int(zoom)
 3903: 
 3904:     def right_to_left(self):
 3905:         """
 3906:         Display the worksheet right to left for some versions of Excel.
 3907: 
 3908:         Args:
 3909:             None.
 3910: 
 3911:         Returns:
 3912:             Nothing.
 3913: 
 3914:         """
 3915:         self.is_right_to_left = 1
 3916: 
 3917:     def hide_zero(self):
 3918:         """
 3919:         Hide zero values in worksheet cells.
 3920: 
 3921:         Args:
 3922:             None.
 3923: 
 3924:         Returns:
 3925:             Nothing.
 3926: 
 3927:         """
 3928:         self.show_zeros = 0
 3929: 
 3930:     def set_tab_color(self, color):
 3931:         """
 3932:         Set the color of the worksheet tab.
 3933: 
 3934:         Args:
 3935:             color: A #RGB color index.
 3936: 
 3937:         Returns:
 3938:             Nothing.
 3939: 
 3940:         """
 3941:         self.tab_color = xl_color(color)
 3942: 
 3943:     def protect(self, password="", options=None):
 3944:         """
 3945:         Set the password and protection options of the worksheet.
 3946: 
 3947:         Args:
 3948:             password: An optional password string.
 3949:             options:  A dictionary of worksheet objects to protect.
 3950: 
 3951:         Returns:
 3952:             Nothing.
 3953: 
 3954:         """
 3955:         if password != "":
 3956:             password = self._encode_password(password)
 3957: 
 3958:         if not options:
 3959:             options = {}
 3960: 
 3961:         # Default values for objects that can be protected.
 3962:         defaults = {
 3963:             "sheet": True,
 3964:             "content": False,
 3965:             "objects": False,
 3966:             "scenarios": False,
 3967:             "format_cells": False,
 3968:             "format_columns": False,
 3969:             "format_rows": False,
 3970:             "insert_columns": False,
 3971:             "insert_rows": False,
 3972:             "insert_hyperlinks": False,
 3973:             "delete_columns": False,
 3974:             "delete_rows": False,
 3975:             "select_locked_cells": True,
 3976:             "sort": False,
 3977:             "autofilter": False,
 3978:             "pivot_tables": False,
 3979:             "select_unlocked_cells": True,
 3980:         }
 3981: 
 3982:         # Overwrite the defaults with user specified values.
 3983:         for key in options.keys():
 3984:             if key in defaults:
 3985:                 defaults[key] = options[key]
 3986:             else:
 3987:                 warn("Unknown protection object: '%s'" % key)
 3988: 
 3989:         # Set the password after the user defined values.
 3990:         defaults["password"] = password
 3991: 
 3992:         self.protect_options = defaults
 3993: 
 3994:     def unprotect_range(self, cell_range, range_name=None, password=None):
 3995:         """
 3996:         Unprotect ranges within a protected worksheet.
 3997: 
 3998:         Args:
 3999:             cell_range: The cell or cell range to unprotect.
 4000:             range_name: An optional name for the range.
 4001:             password:   An optional password string. (undocumented)
 4002: 
 4003:         Returns:
 4004:             Nothing.
 4005: 
 4006:         """
 4007:         if cell_range is None:
 4008:             warn("Cell range must be specified in unprotect_range()")
 4009:             return -1
 4010: 
 4011:         # Sanitize the cell range.
 4012:         cell_range = cell_range.lstrip("=")
 4013:         cell_range = cell_range.replace("$", "")
 4014: 
 4015:         self.num_protected_ranges += 1
 4016: 
 4017:         if range_name is None:
 4018:             range_name = "Range" + str(self.num_protected_ranges)
 4019: 
 4020:         if password:
 4021:             password = self._encode_password(password)
 4022: 
 4023:         self.protected_ranges.append((cell_range, range_name, password))
 4024: 
 4025:     @convert_cell_args
 4026:     def insert_button(self, row, col, options=None):
 4027:         """
 4028:         Insert a button form object into the worksheet.
 4029: 
 4030:         Args:
 4031:             row:     The cell row (zero indexed).
 4032:             col:     The cell column (zero indexed).
 4033:             options: Button formatting options.
 4034: 
 4035:         Returns:
 4036:             0:  Success.
 4037:             -1: Row or column is out of worksheet bounds.
 4038: 
 4039:         """
 4040:         # Check insert (row, col) without storing.
 4041:         if self._check_dimensions(row, col, True, True):
 4042:             warn("Cannot insert button at (%d, %d)." % (row, col))
 4043:             return -1
 4044: 
 4045:         if options is None:
 4046:             options = {}
 4047: 
 4048:         button = self._button_params(row, col, options)
 4049: 
 4050:         self.buttons_list.append(button)
 4051: 
 4052:         self.has_vml = 1
 4053: 
 4054:         return 0
 4055: 
 4056:     ###########################################################################
 4057:     #
 4058:     # Public API. Page Setup methods.
 4059:     #
 4060:     ###########################################################################
 4061:     def set_landscape(self):
 4062:         """
 4063:         Set the page orientation as landscape.
 4064: 
 4065:         Args:
 4066:             None.
 4067: 
 4068:         Returns:
 4069:             Nothing.
 4070: 
 4071:         """
 4072:         self.orientation = 0
 4073:         self.page_setup_changed = True
 4074: 
 4075:     def set_portrait(self):
 4076:         """
 4077:         Set the page orientation as portrait.
 4078: 
 4079:         Args:
 4080:             None.
 4081: 
 4082:         Returns:
 4083:             Nothing.
 4084: 
 4085:         """
 4086:         self.orientation = 1
 4087:         self.page_setup_changed = True
 4088: 
 4089:     def set_page_view(self, view=1):
 4090:         """
 4091:         Set the page view mode.
 4092: 
 4093:         Args:
 4094:             0: Normal view mode
 4095:             1: Page view mode (the default)
 4096:             2: Page break view mode
 4097: 
 4098:         Returns:
 4099:             Nothing.
 4100: 
 4101:         """
 4102:         self.page_view = view
 4103: 
 4104:     def set_pagebreak_view(self, view=1):
 4105:         """
 4106:         Set the page view mode.
 4107: 
 4108:         Args:
 4109:             None.
 4110: 
 4111:         Returns:
 4112:             Nothing.
 4113: 
 4114:         """
 4115:         self.page_view = 2
 4116: 
 4117:     def set_paper(self, paper_size):
 4118:         """
 4119:         Set the paper type. US Letter = 1, A4 = 9.
 4120: 
 4121:         Args:
 4122:             paper_size: Paper index.
 4123: 
 4124:         Returns:
 4125:             Nothing.
 4126: 
 4127:         """
 4128:         if paper_size:
 4129:             self.paper_size = paper_size
 4130:             self.page_setup_changed = True
 4131: 
 4132:     def center_horizontally(self):
 4133:         """
 4134:         Center the page horizontally.
 4135: 
 4136:         Args:
 4137:             None.
 4138: 
 4139:         Returns:
 4140:             Nothing.
 4141: 
 4142:         """
 4143:         self.print_options_changed = True
 4144:         self.hcenter = 1
 4145: 
 4146:     def center_vertically(self):
 4147:         """
 4148:         Center the page vertically.
 4149: 
 4150:         Args:
 4151:             None.
 4152: 
 4153:         Returns:
 4154:             Nothing.
 4155: 
 4156:         """
 4157:         self.print_options_changed = True
 4158:         self.vcenter = 1
 4159: 
 4160:     def set_margins(self, left=0.7, right=0.7, top=0.75, bottom=0.75):
 4161:         """
 4162:         Set all the page margins in inches.
 4163: 
 4164:         Args:
 4165:             left:   Left margin.
 4166:             right:  Right margin.
 4167:             top:    Top margin.
 4168:             bottom: Bottom margin.
 4169: 
 4170:         Returns:
 4171:             Nothing.
 4172: 
 4173:         """
 4174:         self.margin_left = left
 4175:         self.margin_right = right
 4176:         self.margin_top = top
 4177:         self.margin_bottom = bottom
 4178: 
 4179:     def set_header(self, header="", options=None, margin=None):
 4180:         """
 4181:         Set the page header caption and optional margin.
 4182: 
 4183:         Args:
 4184:             header:  Header string.
 4185:             margin:  Header margin.
 4186:             options: Header options, mainly for images.
 4187: 
 4188:         Returns:
 4189:             Nothing.
 4190: 
 4191:         """
 4192:         header_orig = header
 4193:         header = header.replace("&[Picture]", "&G")
 4194: 
 4195:         if len(header) > 255:
 4196:             warn("Header string cannot be longer than Excel's limit of 255 characters")
 4197:             return
 4198: 
 4199:         if options is not None:
 4200:             # For backward compatibility allow options to be the margin.
 4201:             if not isinstance(options, dict):
 4202:                 options = {"margin": options}
 4203:         else:
 4204:             options = {}
 4205: 
 4206:         # Copy the user defined options so they aren't modified.
 4207:         options = options.copy()
 4208: 
 4209:         # For backward compatibility.
 4210:         if margin is not None:
 4211:             options["margin"] = margin
 4212: 
 4213:         # Reset the list in case the function is called more than once.
 4214:         self.header_images = []
 4215: 
 4216:         if options.get("image_left"):
 4217:             self.header_images.append(
 4218:                 [options.get("image_left"), options.get("image_data_left"), "LH"]
 4219:             )
 4220: 
 4221:         if options.get("image_center"):
 4222:             self.header_images.append(
 4223:                 [options.get("image_center"), options.get("image_data_center"), "CH"]
 4224:             )
 4225: 
 4226:         if options.get("image_right"):
 4227:             self.header_images.append(
 4228:                 [options.get("image_right"), options.get("image_data_right"), "RH"]
 4229:             )
 4230: 
 4231:         placeholder_count = header.count("&G")
 4232:         image_count = len(self.header_images)
 4233: 
 4234:         if placeholder_count != image_count:
 4235:             warn(
 4236:                 "Number of header images (%s) doesn't match placeholder "
 4237:                 "count (%s) in string: %s"
 4238:                 % (image_count, placeholder_count, header_orig)
 4239:             )
 4240:             self.header_images = []
 4241:             return
 4242: 
 4243:         if "align_with_margins" in options:
 4244:             self.header_footer_aligns = options["align_with_margins"]
 4245: 
 4246:         if "scale_with_doc" in options:
 4247:             self.header_footer_scales = options["scale_with_doc"]
 4248: 
 4249:         self.header = header
 4250:         self.margin_header = options.get("margin", 0.3)
 4251:         self.header_footer_changed = True
 4252: 
 4253:         if image_count:
 4254:             self.has_header_vml = True
 4255: 
 4256:     def set_footer(self, footer="", options=None, margin=None):
 4257:         """
 4258:         Set the page footer caption and optional margin.
 4259: 
 4260:         Args:
 4261:             footer:  Footer string.
 4262:             margin:  Footer margin.
 4263:             options: Footer options, mainly for images.
 4264: 
 4265:         Returns:
 4266:             Nothing.
 4267: 
 4268:         """
 4269:         footer_orig = footer
 4270:         footer = footer.replace("&[Picture]", "&G")
 4271: 
 4272:         if len(footer) > 255:
 4273:             warn("Footer string cannot be longer than Excel's limit of 255 characters")
 4274:             return
 4275: 
 4276:         if options is not None:
 4277:             # For backward compatibility allow options to be the margin.
 4278:             if not isinstance(options, dict):
 4279:                 options = {"margin": options}
 4280:         else:
 4281:             options = {}
 4282: 
 4283:         # Copy the user defined options so they aren't modified.
 4284:         options = options.copy()
 4285: 
 4286:         # For backward compatibility.
 4287:         if margin is not None:
 4288:             options["margin"] = margin
 4289: 
 4290:         # Reset the list in case the function is called more than once.
 4291:         self.footer_images = []
 4292: 
 4293:         if options.get("image_left"):
 4294:             self.footer_images.append(
 4295:                 [options.get("image_left"), options.get("image_data_left"), "LF"]
 4296:             )
 4297: 
 4298:         if options.get("image_center"):
 4299:             self.footer_images.append(
 4300:                 [options.get("image_center"), options.get("image_data_center"), "CF"]
 4301:             )
 4302: 
 4303:         if options.get("image_right"):
 4304:             self.footer_images.append(
 4305:                 [options.get("image_right"), options.get("image_data_right"), "RF"]
 4306:             )
 4307: 
 4308:         placeholder_count = footer.count("&G")
 4309:         image_count = len(self.footer_images)
 4310: 
 4311:         if placeholder_count != image_count:
 4312:             warn(
 4313:                 "Number of footer images (%s) doesn't match placeholder "
 4314:                 "count (%s) in string: %s"
 4315:                 % (image_count, placeholder_count, footer_orig)
 4316:             )
 4317:             self.footer_images = []
 4318:             return
 4319: 
 4320:         if "align_with_margins" in options:
 4321:             self.header_footer_aligns = options["align_with_margins"]
 4322: 
 4323:         if "scale_with_doc" in options:
 4324:             self.header_footer_scales = options["scale_with_doc"]
 4325: 
 4326:         self.footer = footer
 4327:         self.margin_footer = options.get("margin", 0.3)
 4328:         self.header_footer_changed = True
 4329: 
 4330:         if image_count:
 4331:             self.has_header_vml = True
 4332: 
 4333:     def repeat_rows(self, first_row, last_row=None):
 4334:         """
 4335:         Set the rows to repeat at the top of each printed page.
 4336: 
 4337:         Args:
 4338:             first_row: Start row for range.
 4339:             last_row: End row for range.
 4340: 
 4341:         Returns:
 4342:             Nothing.
 4343: 
 4344:         """
 4345:         if last_row is None:
 4346:             last_row = first_row
 4347: 
 4348:         # Convert rows to 1 based.
 4349:         first_row += 1
 4350:         last_row += 1
 4351: 
 4352:         # Create the row range area like: $1:$2.
 4353:         area = "$%d:$%d" % (first_row, last_row)
 4354: 
 4355:         # Build up the print titles area "Sheet1!$1:$2"
 4356:         sheetname = quote_sheetname(self.name)
 4357:         self.repeat_row_range = sheetname + "!" + area
 4358: 
 4359:     @convert_column_args
 4360:     def repeat_columns(self, first_col, last_col=None):
 4361:         """
 4362:         Set the columns to repeat at the left hand side of each printed page.
 4363: 
 4364:         Args:
 4365:             first_col: Start column for range.
 4366:             last_col: End column for range.
 4367: 
 4368:         Returns:
 4369:             Nothing.
 4370: 
 4371:         """
 4372:         if last_col is None:
 4373:             last_col = first_col
 4374: 
 4375:         # Convert to A notation.
 4376:         first_col = xl_col_to_name(first_col, 1)
 4377:         last_col = xl_col_to_name(last_col, 1)
 4378: 
 4379:         # Create a column range like $C:$D.
 4380:         area = first_col + ":" + last_col
 4381: 
 4382:         # Build up the print area range "=Sheet2!$C:$D"
 4383:         sheetname = quote_sheetname(self.name)
 4384:         self.repeat_col_range = sheetname + "!" + area
 4385: 
 4386:     def hide_gridlines(self, option=1):
 4387:         """
 4388:         Set the option to hide gridlines on the screen and the printed page.
 4389: 
 4390:         Args:
 4391:             option:    0 : Don't hide gridlines
 4392:                        1 : Hide printed gridlines only
 4393:                        2 : Hide screen and printed gridlines
 4394: 
 4395:         Returns:
 4396:             Nothing.
 4397: 
 4398:         """
 4399:         if option == 0:
 4400:             self.print_gridlines = 1
 4401:             self.screen_gridlines = 1
 4402:             self.print_options_changed = True
 4403:         elif option == 1:
 4404:             self.print_gridlines = 0
 4405:             self.screen_gridlines = 1
 4406:         else:
 4407:             self.print_gridlines = 0
 4408:             self.screen_gridlines = 0
 4409: 
 4410:     def print_row_col_headers(self):
 4411:         """
 4412:         Set the option to print the row and column headers on the printed page.
 4413: 
 4414:         Args:
 4415:             None.
 4416: 
 4417:         Returns:
 4418:             Nothing.
 4419: 
 4420:         """
 4421:         self.print_headers = True
 4422:         self.print_options_changed = True
 4423: 
 4424:     def hide_row_col_headers(self):
 4425:         """
 4426:         Set the option to hide the row and column headers on the worksheet.
 4427: 
 4428:         Args:
 4429:             None.
 4430: 
 4431:         Returns:
 4432:             Nothing.
 4433: 
 4434:         """
 4435:         self.row_col_headers = True
 4436: 
 4437:     @convert_range_args
 4438:     def print_area(self, first_row, first_col, last_row, last_col):
 4439:         """
 4440:         Set the print area in the current worksheet.
 4441: 
 4442:         Args:
 4443:             first_row:    The first row of the cell range. (zero indexed).
 4444:             first_col:    The first column of the cell range.
 4445:             last_row:     The last row of the cell range. (zero indexed).
 4446:             last_col:     The last column of the cell range.
 4447: 
 4448:         Returns:
 4449:             0:  Success.
 4450:             -1: Row or column is out of worksheet bounds.
 4451: 
 4452:         """
 4453:         # Set the print area in the current worksheet.
 4454: 
 4455:         # Ignore max print area since it is the same as no  area for Excel.
 4456:         if (
 4457:             first_row == 0
 4458:             and first_col == 0
 4459:             and last_row == self.xls_rowmax - 1
 4460:             and last_col == self.xls_colmax - 1
 4461:         ):
 4462:             return
 4463: 
 4464:         # Build up the print area range "Sheet1!$A$1:$C$13".
 4465:         area = self._convert_name_area(first_row, first_col, last_row, last_col)
 4466:         self.print_area_range = area
 4467: 
 4468:         return 0
 4469: 
 4470:     def print_across(self):
 4471:         """
 4472:         Set the order in which pages are printed.
 4473: 
 4474:         Args:
 4475:             None.
 4476: 
 4477:         Returns:
 4478:             Nothing.
 4479: 
 4480:         """
 4481:         self.page_order = 1
 4482:         self.page_setup_changed = True
 4483: 
 4484:     def fit_to_pages(self, width, height):
 4485:         """
 4486:         Fit the printed area to a specific number of pages both vertically and
 4487:         horizontally.
 4488: 
 4489:         Args:
 4490:             width:  Number of pages horizontally.
 4491:             height: Number of pages vertically.
 4492: 
 4493:         Returns:
 4494:             Nothing.
 4495: 
 4496:         """
 4497:         self.fit_page = 1
 4498:         self.fit_width = width
 4499:         self.fit_height = height
 4500:         self.page_setup_changed = True
 4501: 
 4502:     def set_start_page(self, start_page):
 4503:         """
 4504:         Set the start page number when printing.
 4505: 
 4506:         Args:
 4507:             start_page: Start page number.
 4508: 
 4509:         Returns:
 4510:             Nothing.
 4511: 
 4512:         """
 4513:         self.page_start = start_page
 4514: 
 4515:     def set_print_scale(self, scale):
 4516:         """
 4517:         Set the scale factor for the printed page.
 4518: 
 4519:         Args:
 4520:             scale: Print scale. 10 <= scale <= 400.
 4521: 
 4522:         Returns:
 4523:             Nothing.
 4524: 
 4525:         """
 4526:         # Confine the scale to Excel's range.
 4527:         if scale < 10 or scale > 400:
 4528:             warn("Print scale '%d' outside range: 10 <= scale <= 400" % scale)
 4529:             return
 4530: 
 4531:         # Turn off "fit to page" option when print scale is on.
 4532:         self.fit_page = 0
 4533: 
 4534:         self.print_scale = int(scale)
 4535:         self.page_setup_changed = True
 4536: 
 4537:     def print_black_and_white(self):
 4538:         """
 4539:         Set the option to print the worksheet in black and white.
 4540: 
 4541:         Args:
 4542:             None.
 4543: 
 4544:         Returns:
 4545:             Nothing.
 4546: 
 4547:         """
 4548:         self.black_white = True
 4549:         self.page_setup_changed = True
 4550: 
 4551:     def set_h_pagebreaks(self, breaks):
 4552:         """
 4553:         Set the horizontal page breaks on a worksheet.
 4554: 
 4555:         Args:
 4556:             breaks: List of rows where the page breaks should be added.
 4557: 
 4558:         Returns:
 4559:             Nothing.
 4560: 
 4561:         """
 4562:         self.hbreaks = breaks
 4563: 
 4564:     def set_v_pagebreaks(self, breaks):
 4565:         """
 4566:         Set the horizontal page breaks on a worksheet.
 4567: 
 4568:         Args:
 4569:             breaks: List of columns where the page breaks should be added.
 4570: 
 4571:         Returns:
 4572:             Nothing.
 4573: 
 4574:         """
 4575:         self.vbreaks = breaks
 4576: 
 4577:     def set_vba_name(self, name=None):
 4578:         """
 4579:         Set the VBA name for the worksheet. By default this is the
 4580:         same as the sheet name: i.e., Sheet1 etc.
 4581: 
 4582:         Args:
 4583:             name: The VBA name for the worksheet.
 4584: 
 4585:         Returns:
 4586:             Nothing.
 4587: 
 4588:         """
 4589:         if name is not None:
 4590:             self.vba_codename = name
 4591:         else:
 4592:             self.vba_codename = "Sheet" + str(self.index + 1)
 4593: 
 4594:     def ignore_errors(self, options=None):
 4595:         """
 4596:         Ignore various Excel errors/warnings in a worksheet for user defined
 4597:         ranges.
 4598: 
 4599:         Args:
 4600:             options: A dict of ignore errors keys with cell range values.
 4601: 
 4602:         Returns:
 4603:             0: Success.
 4604:            -1: Incorrect parameter or option.
 4605: 
 4606:         """
 4607:         if options is None:
 4608:             return -1
 4609:         else:
 4610:             # Copy the user defined options so they aren't modified.
 4611:             options = options.copy()
 4612: 
 4613:         # Valid input parameters.
 4614:         valid_parameters = {
 4615:             "number_stored_as_text",
 4616:             "eval_error",
 4617:             "formula_differs",
 4618:             "formula_range",
 4619:             "formula_unlocked",
 4620:             "empty_cell_reference",
 4621:             "list_data_validation",
 4622:             "calculated_column",
 4623:             "two_digit_text_year",
 4624:         }
 4625: 
 4626:         # Check for valid input parameters.
 4627:         for param_key in options.keys():
 4628:             if param_key not in valid_parameters:
 4629:                 warn("Unknown parameter '%s' in ignore_errors()" % param_key)
 4630:                 return -1
 4631: 
 4632:         self.ignored_errors = options
 4633: 
 4634:         return 0
 4635: 
 4636:     ###########################################################################
 4637:     #
 4638:     # Private API.
 4639:     #
 4640:     ###########################################################################
 4641:     def _initialize(self, init_data):
 4642:         self.name = init_data["name"]
 4643:         self.index = init_data["index"]
 4644:         self.str_table = init_data["str_table"]
 4645:         self.worksheet_meta = init_data["worksheet_meta"]
 4646:         self.constant_memory = init_data["constant_memory"]
 4647:         self.tmpdir = init_data["tmpdir"]
 4648:         self.date_1904 = init_data["date_1904"]
 4649:         self.strings_to_numbers = init_data["strings_to_numbers"]
 4650:         self.strings_to_formulas = init_data["strings_to_formulas"]
 4651:         self.strings_to_urls = init_data["strings_to_urls"]
 4652:         self.nan_inf_to_errors = init_data["nan_inf_to_errors"]
 4653:         self.default_date_format = init_data["default_date_format"]
 4654:         self.default_url_format = init_data["default_url_format"]
 4655:         self.excel2003_style = init_data["excel2003_style"]
 4656:         self.remove_timezone = init_data["remove_timezone"]
 4657:         self.max_url_length = init_data["max_url_length"]
 4658:         self.use_future_functions = init_data["use_future_functions"]
 4659:         self.embedded_images = init_data["embedded_images"]
 4660: 
 4661:         if self.excel2003_style:
 4662:             self.original_row_height = 12.75
 4663:             self.default_row_height = 12.75
 4664:             self.default_row_pixels = 17
 4665:             self.margin_left = 0.75
 4666:             self.margin_right = 0.75
 4667:             self.margin_top = 1
 4668:             self.margin_bottom = 1
 4669:             self.margin_header = 0.5
 4670:             self.margin_footer = 0.5
 4671:             self.header_footer_aligns = False
 4672: 
 4673:         # Open a temp filehandle to store row data in constant_memory mode.
 4674:         if self.constant_memory:
 4675:             # This is sub-optimal but we need to create a temp file
 4676:             # with utf8 encoding in Python < 3.
 4677:             (fd, filename) = tempfile.mkstemp(dir=self.tmpdir)
 4678:             os.close(fd)
 4679:             self.row_data_filename = filename
 4680:             self.row_data_fh = open(filename, mode="w+", encoding="utf-8")
 4681: 
 4682:             # Set as the worksheet filehandle until the file is assembled.
 4683:             self.fh = self.row_data_fh
 4684: 
 4685:     def _assemble_xml_file(self):
 4686:         # Assemble and write the XML file.
 4687: 
 4688:         # Write the XML declaration.
 4689:         self._xml_declaration()
 4690: 
 4691:         # Write the root worksheet element.
 4692:         self._write_worksheet()
 4693: 
 4694:         # Write the worksheet properties.
 4695:         self._write_sheet_pr()
 4696: 
 4697:         # Write the worksheet dimensions.
 4698:         self._write_dimension()
 4699: 
 4700:         # Write the sheet view properties.
 4701:         self._write_sheet_views()
 4702: 
 4703:         # Write the sheet format properties.
 4704:         self._write_sheet_format_pr()
 4705: 
 4706:         # Write the sheet column info.
 4707:         self._write_cols()
 4708: 
 4709:         # Write the worksheet data such as rows columns and cells.
 4710:         if not self.constant_memory:
 4711:             self._write_sheet_data()
 4712:         else:
 4713:             self._write_optimized_sheet_data()
 4714: 
 4715:         # Write the sheetProtection element.
 4716:         self._write_sheet_protection()
 4717: 
 4718:         # Write the protectedRanges element.
 4719:         self._write_protected_ranges()
 4720: 
 4721:         # Write the phoneticPr element.
 4722:         if self.excel2003_style:
 4723:             self._write_phonetic_pr()
 4724: 
 4725:         # Write the autoFilter element.
 4726:         self._write_auto_filter()
 4727: 
 4728:         # Write the mergeCells element.
 4729:         self._write_merge_cells()
 4730: 
 4731:         # Write the conditional formats.
 4732:         self._write_conditional_formats()
 4733: 
 4734:         # Write the dataValidations element.
 4735:         self._write_data_validations()
 4736: 
 4737:         # Write the hyperlink element.
 4738:         self._write_hyperlinks()
 4739: 
 4740:         # Write the printOptions element.
 4741:         self._write_print_options()
 4742: 
 4743:         # Write the worksheet page_margins.
 4744:         self._write_page_margins()
 4745: 
 4746:         # Write the worksheet page setup.
 4747:         self._write_page_setup()
 4748: 
 4749:         # Write the headerFooter element.
 4750:         self._write_header_footer()
 4751: 
 4752:         # Write the rowBreaks element.
 4753:         self._write_row_breaks()
 4754: 
 4755:         # Write the colBreaks element.
 4756:         self._write_col_breaks()
 4757: 
 4758:         # Write the ignoredErrors element.
 4759:         self._write_ignored_errors()
 4760: 
 4761:         # Write the drawing element.
 4762:         self._write_drawings()
 4763: 
 4764:         # Write the legacyDrawing element.
 4765:         self._write_legacy_drawing()
 4766: 
 4767:         # Write the legacyDrawingHF element.
 4768:         self._write_legacy_drawing_hf()
 4769: 
 4770:         # Write the picture element, for the background.
 4771:         self._write_picture()
 4772: 
 4773:         # Write the tableParts element.
 4774:         self._write_table_parts()
 4775: 
 4776:         # Write the extLst elements.
 4777:         self._write_ext_list()
 4778: 
 4779:         # Close the worksheet tag.
 4780:         self._xml_end_tag("worksheet")
 4781: 
 4782:         # Close the file.
 4783:         self._xml_close()
 4784: 
 4785:     def _check_dimensions(self, row, col, ignore_row=False, ignore_col=False):
 4786:         # Check that row and col are valid and store the max and min
 4787:         # values for use in other methods/elements. The ignore_row /
 4788:         # ignore_col flags is used to indicate that we wish to perform
 4789:         # the dimension check without storing the value. The ignore
 4790:         # flags are use by set_row() and data_validate.
 4791: 
 4792:         # Check that the row/col are within the worksheet bounds.
 4793:         if row < 0 or col < 0:
 4794:             return -1
 4795:         if row >= self.xls_rowmax or col >= self.xls_colmax:
 4796:             return -1
 4797: 
 4798:         # In constant_memory mode we don't change dimensions for rows
 4799:         # that are already written.
 4800:         if not ignore_row and not ignore_col and self.constant_memory:
 4801:             if row < self.previous_row:
 4802:                 return -2
 4803: 
 4804:         if not ignore_row:
 4805:             if self.dim_rowmin is None or row < self.dim_rowmin:
 4806:                 self.dim_rowmin = row
 4807:             if self.dim_rowmax is None or row > self.dim_rowmax:
 4808:                 self.dim_rowmax = row
 4809: 
 4810:         if not ignore_col:
 4811:             if self.dim_colmin is None or col < self.dim_colmin:
 4812:                 self.dim_colmin = col
 4813:             if self.dim_colmax is None or col > self.dim_colmax:
 4814:                 self.dim_colmax = col
 4815: 
 4816:         return 0
 4817: 
 4818:     def _convert_date_time(self, dt_obj):
 4819:         # Convert a datetime object to an Excel serial date and time.
 4820:         return datetime_to_excel_datetime(dt_obj, self.date_1904, self.remove_timezone)
 4821: 
 4822:     def _convert_name_area(self, row_num_1, col_num_1, row_num_2, col_num_2):
 4823:         # Convert zero indexed rows and columns to the format required by
 4824:         # worksheet named ranges, eg, "Sheet1!$A$1:$C$13".
 4825: 
 4826:         range1 = ""
 4827:         range2 = ""
 4828:         area = ""
 4829:         row_col_only = 0
 4830: 
 4831:         # Convert to A1 notation.
 4832:         col_char_1 = xl_col_to_name(col_num_1, 1)
 4833:         col_char_2 = xl_col_to_name(col_num_2, 1)
 4834:         row_char_1 = "$" + str(row_num_1 + 1)
 4835:         row_char_2 = "$" + str(row_num_2 + 1)
 4836: 
 4837:         # We need to handle special cases that refer to rows or columns only.
 4838:         if row_num_1 == 0 and row_num_2 == self.xls_rowmax - 1:
 4839:             range1 = col_char_1
 4840:             range2 = col_char_2
 4841:             row_col_only = 1
 4842:         elif col_num_1 == 0 and col_num_2 == self.xls_colmax - 1:
 4843:             range1 = row_char_1
 4844:             range2 = row_char_2
 4845:             row_col_only = 1
 4846:         else:
 4847:             range1 = col_char_1 + row_char_1
 4848:             range2 = col_char_2 + row_char_2
 4849: 
 4850:         # A repeated range is only written once (if it isn't a special case).
 4851:         if range1 == range2 and not row_col_only:
 4852:             area = range1
 4853:         else:
 4854:             area = range1 + ":" + range2
 4855: 
 4856:         # Build up the print area range "Sheet1!$A$1:$C$13".
 4857:         sheetname = quote_sheetname(self.name)
 4858:         area = sheetname + "!" + area
 4859: 
 4860:         return area
 4861: 
 4862:     def _sort_pagebreaks(self, breaks):
 4863:         # This is an internal method used to filter elements of a list of
 4864:         # pagebreaks used in the _store_hbreak() and _store_vbreak() methods.
 4865:         # It:
 4866:         #   1. Removes duplicate entries from the list.
 4867:         #   2. Sorts the list.
 4868:         #   3. Removes 0 from the list if present.
 4869:         if not breaks:
 4870:             return
 4871: 
 4872:         breaks_set = set(breaks)
 4873: 
 4874:         if 0 in breaks_set:
 4875:             breaks_set.remove(0)
 4876: 
 4877:         breaks_list = list(breaks_set)
 4878:         breaks_list.sort()
 4879: 
 4880:         # The Excel 2007 specification says that the maximum number of page
 4881:         # breaks is 1026. However, in practice it is actually 1023.
 4882:         max_num_breaks = 1023
 4883:         if len(breaks_list) > max_num_breaks:
 4884:             breaks_list = breaks_list[:max_num_breaks]
 4885: 
 4886:         return breaks_list
 4887: 
 4888:     def _extract_filter_tokens(self, expression):
 4889:         # Extract the tokens from the filter expression. The tokens are mainly
 4890:         # non-whitespace groups. The only tricky part is to extract string
 4891:         # tokens that contain whitespace and/or quoted double quotes (Excel's
 4892:         # escaped quotes).
 4893:         #
 4894:         # Examples: 'x <  2000'
 4895:         #           'x >  2000 and x <  5000'
 4896:         #           'x = "foo"'
 4897:         #           'x = "foo bar"'
 4898:         #           'x = "foo "" bar"'
 4899:         #
 4900:         if not expression:
 4901:             return []
 4902: 
 4903:         token_re = re.compile(r'"(?:[^"]|"")*"|\S+')
 4904:         tokens = token_re.findall(expression)
 4905: 
 4906:         new_tokens = []
 4907:         # Remove single leading and trailing quotes and un-escape other quotes.
 4908:         for token in tokens:
 4909:             if token.startswith('"'):
 4910:                 token = token[1:]
 4911: 
 4912:             if token.endswith('"'):
 4913:                 token = token[:-1]
 4914: 
 4915:             token = token.replace('""', '"')
 4916: 
 4917:             new_tokens.append(token)
 4918: 
 4919:         return new_tokens
 4920: 
 4921:     def _parse_filter_expression(self, expression, tokens):
 4922:         # Converts the tokens of a possibly conditional expression into 1 or 2
 4923:         # sub expressions for further parsing.
 4924:         #
 4925:         # Examples:
 4926:         #          ('x', '==', 2000) -> exp1
 4927:         #          ('x', '>',  2000, 'and', 'x', '<', 5000) -> exp1 and exp2
 4928: 
 4929:         if len(tokens) == 7:
 4930:             # The number of tokens will be either 3 (for 1 expression)
 4931:             # or 7 (for 2  expressions).
 4932:             conditional = tokens[3]
 4933: 
 4934:             if re.match("(and|&&)", conditional):
 4935:                 conditional = 0
 4936:             elif re.match(r"(or|\|\|)", conditional):
 4937:                 conditional = 1
 4938:             else:
 4939:                 warn(
 4940:                     "Token '%s' is not a valid conditional "
 4941:                     "in filter expression '%s'" % (conditional, expression)
 4942:                 )
 4943: 
 4944:             expression_1 = self._parse_filter_tokens(expression, tokens[0:3])
 4945:             expression_2 = self._parse_filter_tokens(expression, tokens[4:7])
 4946: 
 4947:             return expression_1 + [conditional] + expression_2
 4948:         else:
 4949:             return self._parse_filter_tokens(expression, tokens)
 4950: 
 4951:     def _parse_filter_tokens(self, expression, tokens):
 4952:         # Parse the 3 tokens of a filter expression and return the operator
 4953:         # and token. The use of numbers instead of operators is a legacy of
 4954:         # Spreadsheet::WriteExcel.
 4955:         operators = {
 4956:             "==": 2,
 4957:             "=": 2,
 4958:             "=~": 2,
 4959:             "eq": 2,
 4960:             "!=": 5,
 4961:             "!~": 5,
 4962:             "ne": 5,
 4963:             "<>": 5,
 4964:             "<": 1,
 4965:             "<=": 3,
 4966:             ">": 4,
 4967:             ">=": 6,
 4968:         }
 4969: 
 4970:         operator = operators.get(tokens[1], None)
 4971:         token = tokens[2]
 4972: 
 4973:         # Special handling of "Top" filter expressions.
 4974:         if re.match("top|bottom", tokens[0].lower()):
 4975:             value = int(tokens[1])
 4976: 
 4977:             if value < 1 or value > 500:
 4978:                 warn(
 4979:                     "The value '%d' in expression '%s' "
 4980:                     "must be in the range 1 to 500" % (value, expression)
 4981:                 )
 4982: 
 4983:             token = token.lower()
 4984: 
 4985:             if token != "items" and token != "%":
 4986:                 warn(
 4987:                     "The type '%s' in expression '%s' "
 4988:                     "must be either 'items' or '%%'" % (token, expression)
 4989:                 )
 4990: 
 4991:             if tokens[0].lower() == "top":
 4992:                 operator = 30
 4993:             else:
 4994:                 operator = 32
 4995: 
 4996:             if tokens[2] == "%":
 4997:                 operator += 1
 4998: 
 4999:             token = str(value)
 5000: 
 5001:         if not operator and tokens[0]:
 5002:             warn(
 5003:                 "Token '%s' is not a valid operator "
 5004:                 "in filter expression '%s'" % (token[0], expression)
 5005:             )
 5006: 
 5007:         # Special handling for Blanks/NonBlanks.
 5008:         if re.match("blanks|nonblanks", token.lower()):
 5009:             # Only allow Equals or NotEqual in this context.
 5010:             if operator != 2 and operator != 5:
 5011:                 warn(
 5012:                     "The operator '%s' in expression '%s' "
 5013:                     "is not valid in relation to Blanks/NonBlanks'"
 5014:                     % (tokens[1], expression)
 5015:                 )
 5016: 
 5017:             token = token.lower()
 5018: 
 5019:             # The operator should always be 2 (=) to flag a "simple" equality
 5020:             # in the binary record. Therefore we convert <> to =.
 5021:             if token == "blanks":
 5022:                 if operator == 5:
 5023:                     token = " "
 5024:             else:
 5025:                 if operator == 5:
 5026:                     operator = 2
 5027:                     token = "blanks"
 5028:                 else:
 5029:                     operator = 5
 5030:                     token = " "
 5031: 
 5032:         # if the string token contains an Excel match character then change the
 5033:         # operator type to indicate a non "simple" equality.
 5034:         if operator == 2 and re.search("[*?]", token):
 5035:             operator = 22
 5036: 
 5037:         return [operator, token]
 5038: 
 5039:     def _encode_password(self, password):
 5040:         # Hash a worksheet password. Based on the algorithm in
 5041:         # ECMA-376-4:2016, Office Open XML File Formats вЂ” Transitional
 5042:         # Migration Features, Additional attributes for workbookProtection
 5043:         # element (Part 1, В§18.2.29).
 5044:         hash = 0x0000
 5045: 
 5046:         for char in password[::-1]:
 5047:             hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7FFF)
 5048:             hash ^= ord(char)
 5049: 
 5050:         hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7FFF)
 5051:         hash ^= len(password)
 5052:         hash ^= 0xCE4B
 5053: 
 5054:         return "%X" % hash
 5055: 
 5056:     def _prepare_image(
 5057:         self,
 5058:         index,
 5059:         image_id,
 5060:         drawing_id,
 5061:         width,
 5062:         height,
 5063:         name,
 5064:         image_type,
 5065:         x_dpi,
 5066:         y_dpi,
 5067:         digest,
 5068:     ):
 5069:         # Set up images/drawings.
 5070:         drawing_type = 2
 5071:         (
 5072:             row,
 5073:             col,
 5074:             _,
 5075:             x_offset,
 5076:             y_offset,
 5077:             x_scale,
 5078:             y_scale,
 5079:             url,
 5080:             tip,
 5081:             anchor,
 5082:             _,
 5083:             description,
 5084:             decorative,
 5085:         ) = self.images[index]
 5086: 
 5087:         width *= x_scale
 5088:         height *= y_scale
 5089: 
 5090:         # Scale by non 96dpi resolutions.
 5091:         width *= 96.0 / x_dpi
 5092:         height *= 96.0 / y_dpi
 5093: 
 5094:         dimensions = self._position_object_emus(
 5095:             col, row, x_offset, y_offset, width, height, anchor
 5096:         )
 5097:         # Convert from pixels to emus.
 5098:         width = int(0.5 + (width * 9525))
 5099:         height = int(0.5 + (height * 9525))
 5100: 
 5101:         # Create a Drawing obj to use with worksheet unless one already exists.
 5102:         if not self.drawing:
 5103:             drawing = Drawing()
 5104:             drawing.embedded = 1
 5105:             self.drawing = drawing
 5106: 
 5107:             self.external_drawing_links.append(
 5108:                 ["/drawing", "../drawings/drawing" + str(drawing_id) + ".xml", None]
 5109:             )
 5110:         else:
 5111:             drawing = self.drawing
 5112: 
 5113:         drawing_object = drawing._add_drawing_object()
 5114:         drawing_object["type"] = drawing_type
 5115:         drawing_object["dimensions"] = dimensions
 5116:         drawing_object["width"] = width
 5117:         drawing_object["height"] = height
 5118:         drawing_object["description"] = name
 5119:         drawing_object["shape"] = None
 5120:         drawing_object["anchor"] = anchor
 5121:         drawing_object["rel_index"] = 0
 5122:         drawing_object["url_rel_index"] = 0
 5123:         drawing_object["tip"] = tip
 5124:         drawing_object["decorative"] = decorative
 5125: 
 5126:         if description is not None:
 5127:             drawing_object["description"] = description
 5128: 
 5129:         if url:
 5130:             target = None
 5131:             rel_type = "/hyperlink"
 5132:             target_mode = "External"
 5133: 
 5134:             if re.match("(ftp|http)s?://", url):
 5135:                 target = self._escape_url(url)
 5136: 
 5137:             if re.match("^mailto:", url):
 5138:                 target = self._escape_url(url)
 5139: 
 5140:             if re.match("external:", url):
 5141:                 target = url.replace("external:", "")
 5142:                 target = self._escape_url(target)
 5143:                 # Additional escape not required in worksheet hyperlinks.
 5144:                 target = target.replace("#", "%23")
 5145: 
 5146:                 if re.match(r"\w:", target) or re.match(r"\\", target):
 5147:                     target = "file:///" + target
 5148:                 else:
 5149:                     target = target.replace("\\", "/")
 5150: 
 5151:             if re.match("internal:", url):
 5152:                 target = url.replace("internal:", "#")
 5153:                 target_mode = None
 5154: 
 5155:             if target is not None:
 5156:                 if len(target) > self.max_url_length:
 5157:                     warn(
 5158:                         "Ignoring URL '%s' with link and/or anchor > %d "
 5159:                         "characters since it exceeds Excel's limit for URLS"
 5160:                         % (url, self.max_url_length)
 5161:                     )
 5162:                 else:
 5163:                     if not self.drawing_rels.get(url):
 5164:                         self.drawing_links.append([rel_type, target, target_mode])
 5165: 
 5166:                     drawing_object["url_rel_index"] = self._get_drawing_rel_index(url)
 5167: 
 5168:         if not self.drawing_rels.get(digest):
 5169:             self.drawing_links.append(
 5170:                 ["/image", "../media/image" + str(image_id) + "." + image_type]
 5171:             )
 5172: 
 5173:         drawing_object["rel_index"] = self._get_drawing_rel_index(digest)
 5174: 
 5175:     def _prepare_shape(self, index, drawing_id):
 5176:         # Set up shapes/drawings.
 5177:         drawing_type = 3
 5178: 
 5179:         (
 5180:             row,
 5181:             col,
 5182:             x_offset,
 5183:             y_offset,
 5184:             x_scale,
 5185:             y_scale,
 5186:             text,
 5187:             anchor,
 5188:             options,
 5189:             description,
 5190:             decorative,
 5191:         ) = self.shapes[index]
 5192: 
 5193:         width = options.get("width", self.default_col_pixels * 3)
 5194:         height = options.get("height", self.default_row_pixels * 6)
 5195: 
 5196:         width *= x_scale
 5197:         height *= y_scale
 5198: 
 5199:         dimensions = self._position_object_emus(
 5200:             col, row, x_offset, y_offset, width, height, anchor
 5201:         )
 5202: 
 5203:         # Convert from pixels to emus.
 5204:         width = int(0.5 + (width * 9525))
 5205:         height = int(0.5 + (height * 9525))
 5206: 
 5207:         # Create a Drawing obj to use with worksheet unless one already exists.
 5208:         if not self.drawing:
 5209:             drawing = Drawing()
 5210:             drawing.embedded = 1
 5211:             self.drawing = drawing
 5212: 
 5213:             self.external_drawing_links.append(
 5214:                 ["/drawing", "../drawings/drawing" + str(drawing_id) + ".xml", None]
 5215:             )
 5216:         else:
 5217:             drawing = self.drawing
 5218: 
 5219:         shape = Shape("rect", "TextBox", options)
 5220:         shape.text = text
 5221: 
 5222:         drawing_object = drawing._add_drawing_object()
 5223:         drawing_object["type"] = drawing_type
 5224:         drawing_object["dimensions"] = dimensions
 5225:         drawing_object["width"] = width
 5226:         drawing_object["height"] = height
 5227:         drawing_object["description"] = description
 5228:         drawing_object["shape"] = shape
 5229:         drawing_object["anchor"] = anchor
 5230:         drawing_object["rel_index"] = 0
 5231:         drawing_object["url_rel_index"] = 0
 5232:         drawing_object["tip"] = options.get("tip")
 5233:         drawing_object["decorative"] = decorative
 5234: 
 5235:         url = options.get("url", None)
 5236:         if url:
 5237:             target = None
 5238:             rel_type = "/hyperlink"
 5239:             target_mode = "External"
 5240: 
 5241:             if re.match("(ftp|http)s?://", url):
 5242:                 target = self._escape_url(url)
 5243: 
 5244:             if re.match("^mailto:", url):
 5245:                 target = self._escape_url(url)
 5246: 
 5247:             if re.match("external:", url):
 5248:                 target = url.replace("external:", "file:///")
 5249:                 target = self._escape_url(target)
 5250:                 # Additional escape not required in worksheet hyperlinks.
 5251:                 target = target.replace("#", "%23")
 5252: 
 5253:             if re.match("internal:", url):
 5254:                 target = url.replace("internal:", "#")
 5255:                 target_mode = None
 5256: 
 5257:             if target is not None:
 5258:                 if len(target) > self.max_url_length:
 5259:                     warn(
 5260:                         "Ignoring URL '%s' with link and/or anchor > %d "
 5261:                         "characters since it exceeds Excel's limit for URLS"
 5262:                         % (url, self.max_url_length)
 5263:                     )
 5264:                 else:
 5265:                     if not self.drawing_rels.get(url):
 5266:                         self.drawing_links.append([rel_type, target, target_mode])
 5267: 
 5268:                     drawing_object["url_rel_index"] = self._get_drawing_rel_index(url)
 5269: 
 5270:     def _prepare_header_image(
 5271:         self, image_id, width, height, name, image_type, position, x_dpi, y_dpi, digest
 5272:     ):
 5273:         # Set up an image without a drawing object for header/footer images.
 5274: 
 5275:         # Strip the extension from the filename.
 5276:         name = re.sub(r"\..*$", "", name)
 5277: 
 5278:         if not self.vml_drawing_rels.get(digest):
 5279:             self.vml_drawing_links.append(
 5280:                 ["/image", "../media/image" + str(image_id) + "." + image_type]
 5281:             )
 5282: 
 5283:         ref_id = self._get_vml_drawing_rel_index(digest)
 5284: 
 5285:         self.header_images_list.append(
 5286:             [width, height, name, position, x_dpi, y_dpi, ref_id]
 5287:         )
 5288: 
 5289:     def _prepare_background(self, image_id, image_type):
 5290:         # Set up an image without a drawing object for backgrounds.
 5291:         self.external_background_links.append(
 5292:             ["/image", "../media/image" + str(image_id) + "." + image_type]
 5293:         )
 5294: 
 5295:     def _prepare_chart(self, index, chart_id, drawing_id):
 5296:         # Set up chart/drawings.
 5297:         drawing_type = 1
 5298: 
 5299:         (
 5300:             row,
 5301:             col,
 5302:             chart,
 5303:             x_offset,
 5304:             y_offset,
 5305:             x_scale,
 5306:             y_scale,
 5307:             anchor,
 5308:             description,
 5309:             decorative,
 5310:         ) = self.charts[index]
 5311: 
 5312:         chart.id = chart_id - 1
 5313: 
 5314:         # Use user specified dimensions, if any.
 5315:         width = int(0.5 + (chart.width * x_scale))
 5316:         height = int(0.5 + (chart.height * y_scale))
 5317: 
 5318:         dimensions = self._position_object_emus(
 5319:             col, row, x_offset, y_offset, width, height, anchor
 5320:         )
 5321: 
 5322:         # Set the chart name for the embedded object if it has been specified.
 5323:         name = chart.chart_name
 5324: 
 5325:         # Create a Drawing obj to use with worksheet unless one already exists.
 5326:         if not self.drawing:
 5327:             drawing = Drawing()
 5328:             drawing.embedded = 1
 5329:             self.drawing = drawing
 5330: 
 5331:             self.external_drawing_links.append(
 5332:                 ["/drawing", "../drawings/drawing" + str(drawing_id) + ".xml"]
 5333:             )
 5334:         else:
 5335:             drawing = self.drawing
 5336: 
 5337:         drawing_object = drawing._add_drawing_object()
 5338:         drawing_object["type"] = drawing_type
 5339:         drawing_object["dimensions"] = dimensions
 5340:         drawing_object["width"] = width
 5341:         drawing_object["height"] = height
 5342:         drawing_object["name"] = name
 5343:         drawing_object["shape"] = None
 5344:         drawing_object["anchor"] = anchor
 5345:         drawing_object["rel_index"] = self._get_drawing_rel_index()
 5346:         drawing_object["url_rel_index"] = 0
 5347:         drawing_object["tip"] = None
 5348:         drawing_object["description"] = description
 5349:         drawing_object["decorative"] = decorative
 5350: 
 5351:         self.drawing_links.append(
 5352:             ["/chart", "../charts/chart" + str(chart_id) + ".xml"]
 5353:         )
 5354: 
 5355:     def _position_object_emus(
 5356:         self, col_start, row_start, x1, y1, width, height, anchor
 5357:     ):
 5358:         # Calculate the vertices that define the position of a graphical
 5359:         # object within the worksheet in EMUs.
 5360:         #
 5361:         # The vertices are expressed as English Metric Units (EMUs). There are
 5362:         # 12,700 EMUs per point. Therefore, 12,700 * 3 /4 = 9,525 EMUs per
 5363:         # pixel
 5364:         (
 5365:             col_start,
 5366:             row_start,
 5367:             x1,
 5368:             y1,
 5369:             col_end,
 5370:             row_end,
 5371:             x2,
 5372:             y2,
 5373:             x_abs,
 5374:             y_abs,
 5375:         ) = self._position_object_pixels(
 5376:             col_start, row_start, x1, y1, width, height, anchor
 5377:         )
 5378: 
 5379:         # Convert the pixel values to EMUs. See above.
 5380:         x1 = int(0.5 + 9525 * x1)
 5381:         y1 = int(0.5 + 9525 * y1)
 5382:         x2 = int(0.5 + 9525 * x2)
 5383:         y2 = int(0.5 + 9525 * y2)
 5384:         x_abs = int(0.5 + 9525 * x_abs)
 5385:         y_abs = int(0.5 + 9525 * y_abs)
 5386: 
 5387:         return (col_start, row_start, x1, y1, col_end, row_end, x2, y2, x_abs, y_abs)
 5388: 
 5389:     # Calculate the vertices that define the position of a graphical object
 5390:     # within the worksheet in pixels.
 5391:     #
 5392:     #         +------------+------------+
 5393:     #         |     A      |      B     |
 5394:     #   +-----+------------+------------+
 5395:     #   |     |(x1,y1)     |            |
 5396:     #   |  1  |(A1)._______|______      |
 5397:     #   |     |    |              |     |
 5398:     #   |     |    |              |     |
 5399:     #   +-----+----|    OBJECT    |-----+
 5400:     #   |     |    |              |     |
 5401:     #   |  2  |    |______________.     |
 5402:     #   |     |            |        (B2)|
 5403:     #   |     |            |     (x2,y2)|
 5404:     #   +---- +------------+------------+
 5405:     #
 5406:     # Example of an object that covers some of the area from cell A1 to  B2.
 5407:     #
 5408:     # Based on the width and height of the object we need to calculate 8 vars:
 5409:     #
 5410:     #     col_start, row_start, col_end, row_end, x1, y1, x2, y2.
 5411:     #
 5412:     # We also calculate the absolute x and y position of the top left vertex of
 5413:     # the object. This is required for images.
 5414:     #
 5415:     # The width and height of the cells that the object occupies can be
 5416:     # variable and have to be taken into account.
 5417:     #
 5418:     # The values of col_start and row_start are passed in from the calling
 5419:     # function. The values of col_end and row_end are calculated by
 5420:     # subtracting the width and height of the object from the width and
 5421:     # height of the underlying cells.
 5422:     #
 5423:     def _position_object_pixels(
 5424:         self, col_start, row_start, x1, y1, width, height, anchor
 5425:     ):
 5426:         # col_start       # Col containing upper left corner of object.
 5427:         # x1              # Distance to left side of object.
 5428:         #
 5429:         # row_start       # Row containing top left corner of object.
 5430:         # y1              # Distance to top of object.
 5431:         #
 5432:         # col_end         # Col containing lower right corner of object.
 5433:         # x2              # Distance to right side of object.
 5434:         #
 5435:         # row_end         # Row containing bottom right corner of object.
 5436:         # y2              # Distance to bottom of object.
 5437:         #
 5438:         # width           # Width of object frame.
 5439:         # height          # Height of object frame.
 5440:         #
 5441:         # x_abs           # Absolute distance to left side of object.
 5442:         # y_abs           # Absolute distance to top side of object.
 5443:         x_abs = 0
 5444:         y_abs = 0
 5445: 
 5446:         # Adjust start column for negative offsets.
 5447:         while x1 < 0 and col_start > 0:
 5448:             x1 += self._size_col(col_start - 1)
 5449:             col_start -= 1
 5450: 
 5451:         # Adjust start row for negative offsets.
 5452:         while y1 < 0 and row_start > 0:
 5453:             y1 += self._size_row(row_start - 1)
 5454:             row_start -= 1
 5455: 
 5456:         # Ensure that the image isn't shifted off the page at top left.
 5457:         if x1 < 0:
 5458:             x1 = 0
 5459: 
 5460:         if y1 < 0:
 5461:             y1 = 0
 5462: 
 5463:         # Calculate the absolute x offset of the top-left vertex.
 5464:         if self.col_size_changed:
 5465:             for col_id in range(col_start):
 5466:                 x_abs += self._size_col(col_id)
 5467:         else:
 5468:             # Optimization for when the column widths haven't changed.
 5469:             x_abs += self.default_col_pixels * col_start
 5470: 
 5471:         x_abs += x1
 5472: 
 5473:         # Calculate the absolute y offset of the top-left vertex.
 5474:         if self.row_size_changed:
 5475:             for row_id in range(row_start):
 5476:                 y_abs += self._size_row(row_id)
 5477:         else:
 5478:             # Optimization for when the row heights haven't changed.
 5479:             y_abs += self.default_row_pixels * row_start
 5480: 
 5481:         y_abs += y1
 5482: 
 5483:         # Adjust start column for offsets that are greater than the col width.
 5484:         while x1 >= self._size_col(col_start, anchor):
 5485:             x1 -= self._size_col(col_start)
 5486:             col_start += 1
 5487: 
 5488:         # Adjust start row for offsets that are greater than the row height.
 5489:         while y1 >= self._size_row(row_start, anchor):
 5490:             y1 -= self._size_row(row_start)
 5491:             row_start += 1
 5492: 
 5493:         # Initialize end cell to the same as the start cell.
 5494:         col_end = col_start
 5495:         row_end = row_start
 5496: 
 5497:         # Don't offset the image in the cell if the row/col is hidden.
 5498:         if self._size_col(col_start, anchor) > 0:
 5499:             width = width + x1
 5500:         if self._size_row(row_start, anchor) > 0:
 5501:             height = height + y1
 5502: 
 5503:         # Subtract the underlying cell widths to find end cell of the object.
 5504:         while width >= self._size_col(col_end, anchor):
 5505:             width -= self._size_col(col_end, anchor)
 5506:             col_end += 1
 5507: 
 5508:         # Subtract the underlying cell heights to find end cell of the object.
 5509:         while height >= self._size_row(row_end, anchor):
 5510:             height -= self._size_row(row_end, anchor)
 5511:             row_end += 1
 5512: 
 5513:         # The end vertices are whatever is left from the width and height.
 5514:         x2 = width
 5515:         y2 = height
 5516: 
 5517:         return [col_start, row_start, x1, y1, col_end, row_end, x2, y2, x_abs, y_abs]
 5518: 
 5519:     def _size_col(self, col, anchor=0):
 5520:         # Convert the width of a cell from character units to pixels. Excel
 5521:         # rounds the column width to the nearest pixel. If the width hasn't
 5522:         # been set by the user we use the default value. A hidden column is
 5523:         # treated as having a width of zero unless it has the special
 5524:         # "object_position" of 4 (size with cells).
 5525:         max_digit_width = 7  # For Calibri 11.
 5526:         padding = 5
 5527:         pixels = 0
 5528: 
 5529:         # Look up the cell value to see if it has been changed.
 5530:         if col in self.col_info:
 5531:             width = self.col_info[col][0]
 5532:             hidden = self.col_info[col][2]
 5533: 
 5534:             if width is None:
 5535:                 width = self.default_col_width
 5536: 
 5537:             # Convert to pixels.
 5538:             if hidden and anchor != 4:
 5539:                 pixels = 0
 5540:             elif width < 1:
 5541:                 pixels = int(width * (max_digit_width + padding) + 0.5)
 5542:             else:
 5543:                 pixels = int(width * max_digit_width + 0.5) + padding
 5544:         else:
 5545:             pixels = self.default_col_pixels
 5546: 
 5547:         return pixels
 5548: 
 5549:     def _size_row(self, row, anchor=0):
 5550:         # Convert the height of a cell from character units to pixels. If the
 5551:         # height hasn't been set by the user we use the default value. A
 5552:         # hidden row is treated as having a height of zero unless it has the
 5553:         # special "object_position" of 4 (size with cells).
 5554:         pixels = 0
 5555: 
 5556:         # Look up the cell value to see if it has been changed
 5557:         if row in self.row_sizes:
 5558:             height = self.row_sizes[row][0]
 5559:             hidden = self.row_sizes[row][1]
 5560: 
 5561:             if hidden and anchor != 4:
 5562:                 pixels = 0
 5563:             else:
 5564:                 pixels = int(4.0 / 3.0 * height)
 5565:         else:
 5566:             pixels = int(4.0 / 3.0 * self.default_row_height)
 5567: 
 5568:         return pixels
 5569: 
 5570:     def _pixels_to_width(self, pixels):
 5571:         # Convert the width of a cell from pixels to character units.
 5572:         max_digit_width = 7.0  # For Calabri 11.
 5573:         padding = 5.0
 5574: 
 5575:         if pixels <= 12:
 5576:             width = pixels / (max_digit_width + padding)
 5577:         else:
 5578:             width = (pixels - padding) / max_digit_width
 5579: 
 5580:         return width
 5581: 
 5582:     def _pixels_to_height(self, pixels):
 5583:         # Convert the height of a cell from pixels to character units.
 5584:         return 0.75 * pixels
 5585: 
 5586:     def _comment_params(self, row, col, string, options):
 5587:         # This method handles the additional optional parameters to
 5588:         # write_comment() as well as calculating the comment object
 5589:         # position and vertices.
 5590:         default_width = 128
 5591:         default_height = 74
 5592:         anchor = 0
 5593: 
 5594:         params = {
 5595:             "author": None,
 5596:             "color": "#ffffe1",
 5597:             "start_cell": None,
 5598:             "start_col": None,
 5599:             "start_row": None,
 5600:             "visible": None,
 5601:             "width": default_width,
 5602:             "height": default_height,
 5603:             "x_offset": None,
 5604:             "x_scale": 1,
 5605:             "y_offset": None,
 5606:             "y_scale": 1,
 5607:             "font_name": "Tahoma",
 5608:             "font_size": 8,
 5609:             "font_family": 2,
 5610:         }
 5611: 
 5612:         # Overwrite the defaults with any user supplied values. Incorrect or
 5613:         # misspelled parameters are silently ignored.
 5614:         for key in options.keys():
 5615:             params[key] = options[key]
 5616: 
 5617:         # Ensure that a width and height have been set.
 5618:         if not params["width"]:
 5619:             params["width"] = default_width
 5620:         if not params["height"]:
 5621:             params["height"] = default_height
 5622: 
 5623:         # Set the comment background color.
 5624:         params["color"] = xl_color(params["color"]).lower()
 5625: 
 5626:         # Convert from Excel XML style color to XML html style color.
 5627:         params["color"] = params["color"].replace("ff", "#", 1)
 5628: 
 5629:         # Convert a cell reference to a row and column.
 5630:         if params["start_cell"] is not None:
 5631:             (start_row, start_col) = xl_cell_to_rowcol(params["start_cell"])
 5632:             params["start_row"] = start_row
 5633:             params["start_col"] = start_col
 5634: 
 5635:         # Set the default start cell and offsets for the comment. These are
 5636:         # generally fixed in relation to the parent cell. However there are
 5637:         # some edge cases for cells at the, er, edges.
 5638:         row_max = self.xls_rowmax
 5639:         col_max = self.xls_colmax
 5640: 
 5641:         if params["start_row"] is None:
 5642:             if row == 0:
 5643:                 params["start_row"] = 0
 5644:             elif row == row_max - 3:
 5645:                 params["start_row"] = row_max - 7
 5646:             elif row == row_max - 2:
 5647:                 params["start_row"] = row_max - 6
 5648:             elif row == row_max - 1:
 5649:                 params["start_row"] = row_max - 5
 5650:             else:
 5651:                 params["start_row"] = row - 1
 5652: 
 5653:         if params["y_offset"] is None:
 5654:             if row == 0:
 5655:                 params["y_offset"] = 2
 5656:             elif row == row_max - 3:
 5657:                 params["y_offset"] = 16
 5658:             elif row == row_max - 2:
 5659:                 params["y_offset"] = 16
 5660:             elif row == row_max - 1:
 5661:                 params["y_offset"] = 14
 5662:             else:
 5663:                 params["y_offset"] = 10
 5664: 
 5665:         if params["start_col"] is None:
 5666:             if col == col_max - 3:
 5667:                 params["start_col"] = col_max - 6
 5668:             elif col == col_max - 2:
 5669:                 params["start_col"] = col_max - 5
 5670:             elif col == col_max - 1:
 5671:                 params["start_col"] = col_max - 4
 5672:             else:
 5673:                 params["start_col"] = col + 1
 5674: 
 5675:         if params["x_offset"] is None:
 5676:             if col == col_max - 3:
 5677:                 params["x_offset"] = 49
 5678:             elif col == col_max - 2:
 5679:                 params["x_offset"] = 49
 5680:             elif col == col_max - 1:
 5681:                 params["x_offset"] = 49
 5682:             else:
 5683:                 params["x_offset"] = 15
 5684: 
 5685:         # Scale the size of the comment box if required.
 5686:         if params["x_scale"]:
 5687:             params["width"] = params["width"] * params["x_scale"]
 5688: 
 5689:         if params["y_scale"]:
 5690:             params["height"] = params["height"] * params["y_scale"]
 5691: 
 5692:         # Round the dimensions to the nearest pixel.
 5693:         params["width"] = int(0.5 + params["width"])
 5694:         params["height"] = int(0.5 + params["height"])
 5695: 
 5696:         # Calculate the positions of the comment object.
 5697:         vertices = self._position_object_pixels(
 5698:             params["start_col"],
 5699:             params["start_row"],
 5700:             params["x_offset"],
 5701:             params["y_offset"],
 5702:             params["width"],
 5703:             params["height"],
 5704:             anchor,
 5705:         )
 5706: 
 5707:         # Add the width and height for VML.
 5708:         vertices.append(params["width"])
 5709:         vertices.append(params["height"])
 5710: 
 5711:         return [
 5712:             row,
 5713:             col,
 5714:             string,
 5715:             params["author"],
 5716:             params["visible"],
 5717:             params["color"],
 5718:             params["font_name"],
 5719:             params["font_size"],
 5720:             params["font_family"],
 5721:         ] + [vertices]
 5722: 
 5723:     def _button_params(self, row, col, options):
 5724:         # This method handles the parameters passed to insert_button() as well
 5725:         # as calculating the button object position and vertices.
 5726: 
 5727:         default_height = self.default_row_pixels
 5728:         default_width = self.default_col_pixels
 5729:         anchor = 0
 5730: 
 5731:         button_number = 1 + len(self.buttons_list)
 5732:         button = {"row": row, "col": col, "font": {}}
 5733:         params = {}
 5734: 
 5735:         # Overwrite the defaults with any user supplied values. Incorrect or
 5736:         # misspelled parameters are silently ignored.
 5737:         for key in options.keys():
 5738:             params[key] = options[key]
 5739: 
 5740:         # Set the button caption.
 5741:         caption = params.get("caption")
 5742: 
 5743:         # Set a default caption if none was specified by user.
 5744:         if caption is None:
 5745:             caption = "Button %d" % button_number
 5746: 
 5747:         button["font"]["caption"] = caption
 5748: 
 5749:         # Set the macro name.
 5750:         if params.get("macro"):
 5751:             button["macro"] = "[0]!" + params["macro"]
 5752:         else:
 5753:             button["macro"] = "[0]!Button%d_Click" % button_number
 5754: 
 5755:         # Set the alt text for the button.
 5756:         button["description"] = params.get("description")
 5757: 
 5758:         # Ensure that a width and height have been set.
 5759:         params["width"] = params.get("width", default_width)
 5760:         params["height"] = params.get("height", default_height)
 5761: 
 5762:         # Set the x/y offsets.
 5763:         params["x_offset"] = params.get("x_offset", 0)
 5764:         params["y_offset"] = params.get("y_offset", 0)
 5765: 
 5766:         # Scale the size of the button if required.
 5767:         params["width"] = params["width"] * params.get("x_scale", 1)
 5768:         params["height"] = params["height"] * params.get("y_scale", 1)
 5769: 
 5770:         # Round the dimensions to the nearest pixel.
 5771:         params["width"] = int(0.5 + params["width"])
 5772:         params["height"] = int(0.5 + params["height"])
 5773: 
 5774:         params["start_row"] = row
 5775:         params["start_col"] = col
 5776: 
 5777:         # Calculate the positions of the button object.
 5778:         vertices = self._position_object_pixels(
 5779:             params["start_col"],
 5780:             params["start_row"],
 5781:             params["x_offset"],
 5782:             params["y_offset"],
 5783:             params["width"],
 5784:             params["height"],
 5785:             anchor,
 5786:         )
 5787: 
 5788:         # Add the width and height for VML.
 5789:         vertices.append(params["width"])
 5790:         vertices.append(params["height"])
 5791: 
 5792:         button["vertices"] = vertices
 5793: 
 5794:         return button
 5795: 
 5796:     def _prepare_vml_objects(
 5797:         self, vml_data_id, vml_shape_id, vml_drawing_id, comment_id
 5798:     ):
 5799:         comments = []
 5800:         # Sort the comments into row/column order for easier comparison
 5801:         # testing and set the external links for comments and buttons.
 5802:         row_nums = sorted(self.comments.keys())
 5803: 
 5804:         for row in row_nums:
 5805:             col_nums = sorted(self.comments[row].keys())
 5806: 
 5807:             for col in col_nums:
 5808:                 user_options = self.comments[row][col]
 5809:                 params = self._comment_params(*user_options)
 5810:                 self.comments[row][col] = params
 5811: 
 5812:                 # Set comment visibility if required and not user defined.
 5813:                 if self.comments_visible:
 5814:                     if self.comments[row][col][4] is None:
 5815:                         self.comments[row][col][4] = 1
 5816: 
 5817:                 # Set comment author if not already user defined.
 5818:                 if self.comments[row][col][3] is None:
 5819:                     self.comments[row][col][3] = self.comments_author
 5820: 
 5821:                 comments.append(self.comments[row][col])
 5822: 
 5823:         self.external_vml_links.append(
 5824:             ["/vmlDrawing", "../drawings/vmlDrawing" + str(vml_drawing_id) + ".vml"]
 5825:         )
 5826: 
 5827:         if self.has_comments:
 5828:             self.comments_list = comments
 5829: 
 5830:             self.external_comment_links.append(
 5831:                 ["/comments", "../comments" + str(comment_id) + ".xml"]
 5832:             )
 5833: 
 5834:         count = len(comments)
 5835:         start_data_id = vml_data_id
 5836: 
 5837:         # The VML o:idmap data id contains a comma separated range when there
 5838:         # is more than one 1024 block of comments, like this: data="1,2".
 5839:         for i in range(int(count / 1024)):
 5840:             vml_data_id = "%s,%d" % (vml_data_id, start_data_id + i + 1)
 5841: 
 5842:         self.vml_data_id = vml_data_id
 5843:         self.vml_shape_id = vml_shape_id
 5844: 
 5845:         return count
 5846: 
 5847:     def _prepare_header_vml_objects(self, vml_header_id, vml_drawing_id):
 5848:         # Set up external linkage for VML header/footer images.
 5849: 
 5850:         self.vml_header_id = vml_header_id
 5851: 
 5852:         self.external_vml_links.append(
 5853:             ["/vmlDrawing", "../drawings/vmlDrawing" + str(vml_drawing_id) + ".vml"]
 5854:         )
 5855: 
 5856:     def _prepare_tables(self, table_id, seen):
 5857:         # Set the table ids for the worksheet tables.
 5858:         for table in self.tables:
 5859:             table["id"] = table_id
 5860: 
 5861:             if table.get("name") is None:
 5862:                 # Set a default name.
 5863:                 table["name"] = "Table" + str(table_id)
 5864: 
 5865:             # Check for duplicate table names.
 5866:             name = table["name"].lower()
 5867: 
 5868:             if name in seen:
 5869:                 raise DuplicateTableName(
 5870:                     "Duplicate name '%s' used in worksheet.add_table()." % table["name"]
 5871:                 )
 5872:             else:
 5873:                 seen[name] = True
 5874: 
 5875:             # Store the link used for the rels file.
 5876:             self.external_table_links.append(
 5877:                 ["/table", "../tables/table" + str(table_id) + ".xml"]
 5878:             )
 5879:             table_id += 1
 5880: 
 5881:     def _table_function_to_formula(self, function, col_name):
 5882:         # Convert a table total function to a worksheet formula.
 5883:         formula = ""
 5884: 
 5885:         # Escape special characters, as required by Excel.
 5886:         col_name = col_name.replace("'", "''")
 5887:         col_name = col_name.replace("#", "'#")
 5888:         col_name = col_name.replace("]", "']")
 5889:         col_name = col_name.replace("[", "'[")
 5890: 
 5891:         subtotals = {
 5892:             "average": 101,
 5893:             "countNums": 102,
 5894:             "count": 103,
 5895:             "max": 104,
 5896:             "min": 105,
 5897:             "stdDev": 107,
 5898:             "sum": 109,
 5899:             "var": 110,
 5900:         }
 5901: 
 5902:         if function in subtotals:
 5903:             func_num = subtotals[function]
 5904:             formula = "SUBTOTAL(%s,[%s])" % (func_num, col_name)
 5905:         else:
 5906:             warn("Unsupported function '%s' in add_table()" % function)
 5907: 
 5908:         return formula
 5909: 
 5910:     def _set_spark_color(self, sparkline, options, user_color):
 5911:         # Set the sparkline color.
 5912:         if user_color not in options:
 5913:             return
 5914: 
 5915:         sparkline[user_color] = {"rgb": xl_color(options[user_color])}
 5916: 
 5917:     def _get_range_data(self, row_start, col_start, row_end, col_end):
 5918:         # Returns a range of data from the worksheet _table to be used in
 5919:         # chart cached data. Strings are returned as SST ids and decoded
 5920:         # in the workbook. Return None for data that doesn't exist since
 5921:         # Excel can chart series with data missing.
 5922: 
 5923:         if self.constant_memory:
 5924:             return ()
 5925: 
 5926:         data = []
 5927: 
 5928:         # Iterate through the table data.
 5929:         for row_num in range(row_start, row_end + 1):
 5930:             # Store None if row doesn't exist.
 5931:             if row_num not in self.table:
 5932:                 data.append(None)
 5933:                 continue
 5934: 
 5935:             for col_num in range(col_start, col_end + 1):
 5936:                 if col_num in self.table[row_num]:
 5937:                     cell = self.table[row_num][col_num]
 5938: 
 5939:                     cell_type = cell.__class__.__name__
 5940: 
 5941:                     if cell_type in ("Number", "Datetime"):
 5942:                         # Return a number with Excel's precision.
 5943:                         data.append("%.16g" % cell.number)
 5944: 
 5945:                     elif cell_type == "String":
 5946:                         # Return a string from it's shared string index.
 5947:                         index = cell.string
 5948:                         string = self.str_table._get_shared_string(index)
 5949: 
 5950:                         data.append(string)
 5951: 
 5952:                     elif cell_type in ("Formula", "ArrayFormula"):
 5953:                         # Return the formula value.
 5954:                         value = cell.value
 5955: 
 5956:                         if value is None:
 5957:                             value = 0
 5958: 
 5959:                         data.append(value)
 5960: 
 5961:                     elif cell_type == "Blank":
 5962:                         # Return a empty cell.
 5963:                         data.append("")
 5964:                 else:
 5965:                     # Store None if column doesn't exist.
 5966:                     data.append(None)
 5967: 
 5968:         return data
 5969: 
 5970:     def _csv_join(self, *items):
 5971:         # Create a csv string for use with data validation formulas and lists.
 5972: 
 5973:         # Convert non string types to string.
 5974:         items = [str(item) if not isinstance(item, str) else item for item in items]
 5975: 
 5976:         return ",".join(items)
 5977: 
 5978:     def _escape_url(self, url):
 5979:         # Don't escape URL if it looks already escaped.
 5980:         if re.search("%[0-9a-fA-F]{2}", url):
 5981:             return url
 5982: 
 5983:         # Can't use url.quote() here because it doesn't match Excel.
 5984:         url = url.replace("%", "%25")
 5985:         url = url.replace('"', "%22")
 5986:         url = url.replace(" ", "%20")
 5987:         url = url.replace("<", "%3c")
 5988:         url = url.replace(">", "%3e")
 5989:         url = url.replace("[", "%5b")
 5990:         url = url.replace("]", "%5d")
 5991:         url = url.replace("^", "%5e")
 5992:         url = url.replace("`", "%60")
 5993:         url = url.replace("{", "%7b")
 5994:         url = url.replace("}", "%7d")
 5995: 
 5996:         return url
 5997: 
 5998:     def _get_drawing_rel_index(self, target=None):
 5999:         # Get the index used to address a drawing rel link.
 6000:         if target is None:
 6001:             self.drawing_rels_id += 1
 6002:             return self.drawing_rels_id
 6003:         elif self.drawing_rels.get(target):
 6004:             return self.drawing_rels[target]
 6005:         else:
 6006:             self.drawing_rels_id += 1
 6007:             self.drawing_rels[target] = self.drawing_rels_id
 6008:             return self.drawing_rels_id
 6009: 
 6010:     def _get_vml_drawing_rel_index(self, target=None):
 6011:         # Get the index used to address a vml drawing rel link.
 6012:         if self.vml_drawing_rels.get(target):
 6013:             return self.vml_drawing_rels[target]
 6014:         else:
 6015:             self.vml_drawing_rels_id += 1
 6016:             self.vml_drawing_rels[target] = self.vml_drawing_rels_id
 6017:             return self.vml_drawing_rels_id
 6018: 
 6019:     ###########################################################################
 6020:     #
 6021:     # The following font methods are, more or less, duplicated from the
 6022:     # Styles class. Not the cleanest version of reuse but works for now.
 6023:     #
 6024:     ###########################################################################
 6025:     def _write_font(self, xf_format):
 6026:         # Write the <font> element.
 6027:         xml_writer = self.rstring
 6028: 
 6029:         xml_writer._xml_start_tag("rPr")
 6030: 
 6031:         # Handle the main font properties.
 6032:         if xf_format.bold:
 6033:             xml_writer._xml_empty_tag("b")
 6034:         if xf_format.italic:
 6035:             xml_writer._xml_empty_tag("i")
 6036:         if xf_format.font_strikeout:
 6037:             xml_writer._xml_empty_tag("strike")
 6038:         if xf_format.font_outline:
 6039:             xml_writer._xml_empty_tag("outline")
 6040:         if xf_format.font_shadow:
 6041:             xml_writer._xml_empty_tag("shadow")
 6042: 
 6043:         # Handle the underline variants.
 6044:         if xf_format.underline:
 6045:             self._write_underline(xf_format.underline)
 6046: 
 6047:         # Handle super/subscript.
 6048:         if xf_format.font_script == 1:
 6049:             self._write_vert_align("superscript")
 6050:         if xf_format.font_script == 2:
 6051:             self._write_vert_align("subscript")
 6052: 
 6053:         # Write the font size
 6054:         xml_writer._xml_empty_tag("sz", [("val", xf_format.font_size)])
 6055: 
 6056:         # Handle colors.
 6057:         if xf_format.theme == -1:
 6058:             # Ignore for excel2003_style.
 6059:             pass
 6060:         elif xf_format.theme:
 6061:             self._write_color("theme", xf_format.theme)
 6062:         elif xf_format.color_indexed:
 6063:             self._write_color("indexed", xf_format.color_indexed)
 6064:         elif xf_format.font_color:
 6065:             color = self._get_palette_color(xf_format.font_color)
 6066:             self._write_rstring_color("rgb", color)
 6067:         else:
 6068:             self._write_rstring_color("theme", 1)
 6069: 
 6070:         # Write some other font properties related to font families.
 6071:         xml_writer._xml_empty_tag("rFont", [("val", xf_format.font_name)])
 6072:         xml_writer._xml_empty_tag("family", [("val", xf_format.font_family)])
 6073: 
 6074:         if xf_format.font_name == "Calibri" and not xf_format.hyperlink:
 6075:             xml_writer._xml_empty_tag("scheme", [("val", xf_format.font_scheme)])
 6076: 
 6077:         xml_writer._xml_end_tag("rPr")
 6078: 
 6079:     def _write_underline(self, underline):
 6080:         # Write the underline font element.
 6081:         attributes = []
 6082: 
 6083:         # Handle the underline variants.
 6084:         if underline == 2:
 6085:             attributes = [("val", "double")]
 6086:         elif underline == 33:
 6087:             attributes = [("val", "singleAccounting")]
 6088:         elif underline == 34:
 6089:             attributes = [("val", "doubleAccounting")]
 6090: 
 6091:         self.rstring._xml_empty_tag("u", attributes)
 6092: 
 6093:     def _write_vert_align(self, val):
 6094:         # Write the <vertAlign> font sub-element.
 6095:         attributes = [("val", val)]
 6096: 
 6097:         self.rstring._xml_empty_tag("vertAlign", attributes)
 6098: 
 6099:     def _write_rstring_color(self, name, value):
 6100:         # Write the <color> element.
 6101:         attributes = [(name, value)]
 6102: 
 6103:         self.rstring._xml_empty_tag("color", attributes)
 6104: 
 6105:     def _get_palette_color(self, color):
 6106:         # Convert the RGB color.
 6107:         if color[0] == "#":
 6108:             color = color[1:]
 6109: 
 6110:         return "FF" + color.upper()
 6111: 
 6112:     def _opt_close(self):
 6113:         # Close the row data filehandle in constant_memory mode.
 6114:         if not self.row_data_fh_closed:
 6115:             self.row_data_fh.close()
 6116:             self.row_data_fh_closed = True
 6117: 
 6118:     def _opt_reopen(self):
 6119:         # Reopen the row data filehandle in constant_memory mode.
 6120:         if self.row_data_fh_closed:
 6121:             filename = self.row_data_filename
 6122:             self.row_data_fh = open(filename, mode="a+", encoding="utf-8")
 6123:             self.row_data_fh_closed = False
 6124:             self.fh = self.row_data_fh
 6125: 
 6126:     def _set_icon_props(self, total_icons, user_props=None):
 6127:         # Set the sub-properties for icons.
 6128:         props = []
 6129: 
 6130:         # Set the defaults.
 6131:         for _ in range(total_icons):
 6132:             props.append({"criteria": False, "value": 0, "type": "percent"})
 6133: 
 6134:         # Set the default icon values based on the number of icons.
 6135:         if total_icons == 3:
 6136:             props[0]["value"] = 67
 6137:             props[1]["value"] = 33
 6138: 
 6139:         if total_icons == 4:
 6140:             props[0]["value"] = 75
 6141:             props[1]["value"] = 50
 6142:             props[2]["value"] = 25
 6143: 
 6144:         if total_icons == 5:
 6145:             props[0]["value"] = 80
 6146:             props[1]["value"] = 60
 6147:             props[2]["value"] = 40
 6148:             props[3]["value"] = 20
 6149: 
 6150:         # Overwrite default properties with user defined properties.
 6151:         if user_props:
 6152:             # Ensure we don't set user properties for lowest icon.
 6153:             max_data = len(user_props)
 6154:             if max_data >= total_icons:
 6155:                 max_data = total_icons - 1
 6156: 
 6157:             for i in range(max_data):
 6158:                 # Set the user defined 'value' property.
 6159:                 if user_props[i].get("value") is not None:
 6160:                     props[i]["value"] = user_props[i]["value"]
 6161: 
 6162:                     # Remove the formula '=' sign if it exists.
 6163:                     tmp = props[i]["value"]
 6164:                     if isinstance(tmp, str) and tmp.startswith("="):
 6165:                         props[i]["value"] = tmp.lstrip("=")
 6166: 
 6167:                 # Set the user defined 'type' property.
 6168:                 if user_props[i].get("type"):
 6169:                     valid_types = ("percent", "percentile", "number", "formula")
 6170: 
 6171:                     if user_props[i]["type"] not in valid_types:
 6172:                         warn(
 6173:                             "Unknown icon property type '%s' for sub-"
 6174:                             "property 'type' in conditional_format()"
 6175:                             % user_props[i]["type"]
 6176:                         )
 6177:                     else:
 6178:                         props[i]["type"] = user_props[i]["type"]
 6179: 
 6180:                         if props[i]["type"] == "number":
 6181:                             props[i]["type"] = "num"
 6182: 
 6183:                 # Set the user defined 'criteria' property.
 6184:                 criteria = user_props[i].get("criteria")
 6185:                 if criteria and criteria == ">":
 6186:                     props[i]["criteria"] = True
 6187: 
 6188:         return props
 6189: 
 6190:     ###########################################################################
 6191:     #
 6192:     # XML methods.
 6193:     #
 6194:     ###########################################################################
 6195: 
 6196:     def _write_worksheet(self):
 6197:         # Write the <worksheet> element. This is the root element.
 6198: 
 6199:         schema = "http://schemas.openxmlformats.org/"
 6200:         xmlns = schema + "spreadsheetml/2006/main"
 6201:         xmlns_r = schema + "officeDocument/2006/relationships"
 6202:         xmlns_mc = schema + "markup-compatibility/2006"
 6203:         ms_schema = "http://schemas.microsoft.com/"
 6204:         xmlns_x14ac = ms_schema + "office/spreadsheetml/2009/9/ac"
 6205: 
 6206:         attributes = [("xmlns", xmlns), ("xmlns:r", xmlns_r)]
 6207: 
 6208:         # Add some extra attributes for Excel 2010. Mainly for sparklines.
 6209:         if self.excel_version == 2010:
 6210:             attributes.append(("xmlns:mc", xmlns_mc))
 6211:             attributes.append(("xmlns:x14ac", xmlns_x14ac))
 6212:             attributes.append(("mc:Ignorable", "x14ac"))
 6213: 
 6214:         self._xml_start_tag("worksheet", attributes)
 6215: 
 6216:     def _write_dimension(self):
 6217:         # Write the <dimension> element. This specifies the range of
 6218:         # cells in the worksheet. As a special case, empty
 6219:         # spreadsheets use 'A1' as a range.
 6220: 
 6221:         if self.dim_rowmin is None and self.dim_colmin is None:
 6222:             # If the min dimensions are not defined then no dimensions
 6223:             # have been set and we use the default 'A1'.
 6224:             ref = "A1"
 6225: 
 6226:         elif self.dim_rowmin is None and self.dim_colmin is not None:
 6227:             # If the row dimensions aren't set but the column
 6228:             # dimensions are set then they have been changed via
 6229:             # set_column().
 6230: 
 6231:             if self.dim_colmin == self.dim_colmax:
 6232:                 # The dimensions are a single cell and not a range.
 6233:                 ref = xl_rowcol_to_cell(0, self.dim_colmin)
 6234:             else:
 6235:                 # The dimensions are a cell range.
 6236:                 cell_1 = xl_rowcol_to_cell(0, self.dim_colmin)
 6237:                 cell_2 = xl_rowcol_to_cell(0, self.dim_colmax)
 6238:                 ref = cell_1 + ":" + cell_2
 6239: 
 6240:         elif self.dim_rowmin == self.dim_rowmax and self.dim_colmin == self.dim_colmax:
 6241:             # The dimensions are a single cell and not a range.
 6242:             ref = xl_rowcol_to_cell(self.dim_rowmin, self.dim_colmin)
 6243:         else:
 6244:             # The dimensions are a cell range.
 6245:             cell_1 = xl_rowcol_to_cell(self.dim_rowmin, self.dim_colmin)
 6246:             cell_2 = xl_rowcol_to_cell(self.dim_rowmax, self.dim_colmax)
 6247:             ref = cell_1 + ":" + cell_2
 6248: 
 6249:         self._xml_empty_tag("dimension", [("ref", ref)])
 6250: 
 6251:     def _write_sheet_views(self):
 6252:         # Write the <sheetViews> element.
 6253:         self._xml_start_tag("sheetViews")
 6254: 
 6255:         # Write the sheetView element.
 6256:         self._write_sheet_view()
 6257: 
 6258:         self._xml_end_tag("sheetViews")
 6259: 
 6260:     def _write_sheet_view(self):
 6261:         # Write the <sheetViews> element.
 6262:         attributes = []
 6263: 
 6264:         # Hide screen gridlines if required.
 6265:         if not self.screen_gridlines:
 6266:             attributes.append(("showGridLines", 0))
 6267: 
 6268:         # Hide screen row/column headers.
 6269:         if self.row_col_headers:
 6270:             attributes.append(("showRowColHeaders", 0))
 6271: 
 6272:         # Hide zeroes in cells.
 6273:         if not self.show_zeros:
 6274:             attributes.append(("showZeros", 0))
 6275: 
 6276:         # Display worksheet right to left for Hebrew, Arabic and others.
 6277:         if self.is_right_to_left:
 6278:             attributes.append(("rightToLeft", 1))
 6279: 
 6280:         # Show that the sheet tab is selected.
 6281:         if self.selected:
 6282:             attributes.append(("tabSelected", 1))
 6283: 
 6284:         # Turn outlines off. Also required in the outlinePr element.
 6285:         if not self.outline_on:
 6286:             attributes.append(("showOutlineSymbols", 0))
 6287: 
 6288:         # Set the page view/layout mode if required.
 6289:         if self.page_view == 1:
 6290:             attributes.append(("view", "pageLayout"))
 6291:         elif self.page_view == 2:
 6292:             attributes.append(("view", "pageBreakPreview"))
 6293: 
 6294:         # Set the first visible cell.
 6295:         if self.top_left_cell != "":
 6296:             attributes.append(("topLeftCell", self.top_left_cell))
 6297: 
 6298:         # Set the zoom level.
 6299:         if self.zoom != 100:
 6300:             attributes.append(("zoomScale", self.zoom))
 6301: 
 6302:             if self.page_view == 0 and self.zoom_scale_normal:
 6303:                 attributes.append(("zoomScaleNormal", self.zoom))
 6304:             if self.page_view == 1:
 6305:                 attributes.append(("zoomScalePageLayoutView", self.zoom))
 6306:             if self.page_view == 2:
 6307:                 attributes.append(("zoomScaleSheetLayoutView", self.zoom))
 6308: 
 6309:         attributes.append(("workbookViewId", 0))
 6310: 
 6311:         if self.panes or len(self.selections):
 6312:             self._xml_start_tag("sheetView", attributes)
 6313:             self._write_panes()
 6314:             self._write_selections()
 6315:             self._xml_end_tag("sheetView")
 6316:         else:
 6317:             self._xml_empty_tag("sheetView", attributes)
 6318: 
 6319:     def _write_sheet_format_pr(self):
 6320:         # Write the <sheetFormatPr> element.
 6321:         default_row_height = self.default_row_height
 6322:         row_level = self.outline_row_level
 6323:         col_level = self.outline_col_level
 6324: 
 6325:         attributes = [("defaultRowHeight", default_row_height)]
 6326: 
 6327:         if self.default_row_height != self.original_row_height:
 6328:             attributes.append(("customHeight", 1))
 6329: 
 6330:         if self.default_row_zeroed:
 6331:             attributes.append(("zeroHeight", 1))
 6332: 
 6333:         if row_level:
 6334:             attributes.append(("outlineLevelRow", row_level))
 6335:         if col_level:
 6336:             attributes.append(("outlineLevelCol", col_level))
 6337: 
 6338:         if self.excel_version == 2010:
 6339:             attributes.append(("x14ac:dyDescent", "0.25"))
 6340: 
 6341:         self._xml_empty_tag("sheetFormatPr", attributes)
 6342: 
 6343:     def _write_cols(self):
 6344:         # Write the <cols> element and <col> sub elements.
 6345: 
 6346:         # Exit unless some column have been formatted.
 6347:         if not self.col_info:
 6348:             return
 6349: 
 6350:         self._xml_start_tag("cols")
 6351: 
 6352:         # Use the first element of the column information structures to set
 6353:         # the initial/previous properties.
 6354:         first_col = (sorted(self.col_info.keys()))[0]
 6355:         last_col = first_col
 6356:         prev_col_options = self.col_info[first_col]
 6357:         del self.col_info[first_col]
 6358:         deleted_col = first_col
 6359:         deleted_col_options = prev_col_options
 6360: 
 6361:         for col in sorted(self.col_info.keys()):
 6362:             col_options = self.col_info[col]
 6363:             # Check if the column number is contiguous with the previous
 6364:             # column and if the properties are the same.
 6365:             if col == last_col + 1 and col_options == prev_col_options:
 6366:                 last_col = col
 6367:             else:
 6368:                 # If not contiguous/equal then we write out the current range
 6369:                 # of columns and start again.
 6370:                 self._write_col_info(first_col, last_col, prev_col_options)
 6371:                 first_col = col
 6372:                 last_col = first_col
 6373:                 prev_col_options = col_options
 6374: 
 6375:         # We will exit the previous loop with one unhandled column range.
 6376:         self._write_col_info(first_col, last_col, prev_col_options)
 6377: 
 6378:         # Put back the deleted first column information structure.
 6379:         self.col_info[deleted_col] = deleted_col_options
 6380: 
 6381:         self._xml_end_tag("cols")
 6382: 
 6383:     def _write_col_info(self, col_min, col_max, col_info):
 6384:         # Write the <col> element.
 6385:         (width, cell_format, hidden, level, collapsed, autofit) = col_info
 6386: 
 6387:         custom_width = 1
 6388:         xf_index = 0
 6389: 
 6390:         # Get the cell_format index.
 6391:         if cell_format:
 6392:             xf_index = cell_format._get_xf_index()
 6393: 
 6394:         # Set the Excel default column width.
 6395:         if width is None:
 6396:             if not hidden:
 6397:                 width = 8.43
 6398:                 custom_width = 0
 6399:             else:
 6400:                 width = 0
 6401:         elif width == 8.43:
 6402:             # Width is defined but same as default.
 6403:             custom_width = 0
 6404: 
 6405:         # Convert column width from user units to character width.
 6406:         if width > 0:
 6407:             # For Calabri 11.
 6408:             max_digit_width = 7
 6409:             padding = 5
 6410: 
 6411:             if width < 1:
 6412:                 width = (
 6413:                     int(
 6414:                         (int(width * (max_digit_width + padding) + 0.5))
 6415:                         / float(max_digit_width)
 6416:                         * 256.0
 6417:                     )
 6418:                     / 256.0
 6419:                 )
 6420:             else:
 6421:                 width = (
 6422:                     int(
 6423:                         (int(width * max_digit_width + 0.5) + padding)
 6424:                         / float(max_digit_width)
 6425:                         * 256.0
 6426:                     )
 6427:                     / 256.0
 6428:                 )
 6429: 
 6430:         attributes = [
 6431:             ("min", col_min + 1),
 6432:             ("max", col_max + 1),
 6433:             ("width", "%.16g" % width),
 6434:         ]
 6435: 
 6436:         if xf_index:
 6437:             attributes.append(("style", xf_index))
 6438:         if hidden:
 6439:             attributes.append(("hidden", "1"))
 6440:         if autofit:
 6441:             attributes.append(("bestFit", "1"))
 6442:         if custom_width:
 6443:             attributes.append(("customWidth", "1"))
 6444:         if level:
 6445:             attributes.append(("outlineLevel", level))
 6446:         if collapsed:
 6447:             attributes.append(("collapsed", "1"))
 6448: 
 6449:         self._xml_empty_tag("col", attributes)
 6450: 
 6451:     def _write_sheet_data(self):
 6452:         # Write the <sheetData> element.
 6453:         if self.dim_rowmin is None:
 6454:             # If the dimensions aren't defined there is no data to write.
 6455:             self._xml_empty_tag("sheetData")
 6456:         else:
 6457:             self._xml_start_tag("sheetData")
 6458:             self._write_rows()
 6459:             self._xml_end_tag("sheetData")
 6460: 
 6461:     def _write_optimized_sheet_data(self):
 6462:         # Write the <sheetData> element when constant_memory is on. In this
 6463:         # case we read the data stored in the temp file and rewrite it to the
 6464:         # XML sheet file.
 6465:         if self.dim_rowmin is None:
 6466:             # If the dimensions aren't defined then there is no data to write.
 6467:             self._xml_empty_tag("sheetData")
 6468:         else:
 6469:             self._xml_start_tag("sheetData")
 6470: 
 6471:             # Rewind the filehandle that was used for temp row data.
 6472:             buff_size = 65536
 6473:             self.row_data_fh.seek(0)
 6474:             data = self.row_data_fh.read(buff_size)
 6475: 
 6476:             while data:
 6477:                 self.fh.write(data)
 6478:                 data = self.row_data_fh.read(buff_size)
 6479: 
 6480:             self.row_data_fh.close()
 6481:             os.unlink(self.row_data_filename)
 6482: 
 6483:             self._xml_end_tag("sheetData")
 6484: 
 6485:     def _write_page_margins(self):
 6486:         # Write the <pageMargins> element.
 6487:         attributes = [
 6488:             ("left", self.margin_left),
 6489:             ("right", self.margin_right),
 6490:             ("top", self.margin_top),
 6491:             ("bottom", self.margin_bottom),
 6492:             ("header", self.margin_header),
 6493:             ("footer", self.margin_footer),
 6494:         ]
 6495: 
 6496:         self._xml_empty_tag("pageMargins", attributes)
 6497: 
 6498:     def _write_page_setup(self):
 6499:         # Write the <pageSetup> element.
 6500:         #
 6501:         # The following is an example taken from Excel.
 6502:         #
 6503:         # <pageSetup
 6504:         #     paperSize="9"
 6505:         #     scale="110"
 6506:         #     fitToWidth="2"
 6507:         #     fitToHeight="2"
 6508:         #     pageOrder="overThenDown"
 6509:         #     orientation="portrait"
 6510:         #     blackAndWhite="1"
 6511:         #     draft="1"
 6512:         #     horizontalDpi="200"
 6513:         #     verticalDpi="200"
 6514:         #     r:id="rId1"
 6515:         # />
 6516:         #
 6517:         attributes = []
 6518: 
 6519:         # Skip this element if no page setup has changed.
 6520:         if not self.page_setup_changed:
 6521:             return
 6522: 
 6523:         # Set paper size.
 6524:         if self.paper_size:
 6525:             attributes.append(("paperSize", self.paper_size))
 6526: 
 6527:         # Set the print_scale.
 6528:         if self.print_scale != 100:
 6529:             attributes.append(("scale", self.print_scale))
 6530: 
 6531:         # Set the "Fit to page" properties.
 6532:         if self.fit_page and self.fit_width != 1:
 6533:             attributes.append(("fitToWidth", self.fit_width))
 6534: 
 6535:         if self.fit_page and self.fit_height != 1:
 6536:             attributes.append(("fitToHeight", self.fit_height))
 6537: 
 6538:         # Set the page print direction.
 6539:         if self.page_order:
 6540:             attributes.append(("pageOrder", "overThenDown"))
 6541: 
 6542:         # Set start page for printing.
 6543:         if self.page_start > 1:
 6544:             attributes.append(("firstPageNumber", self.page_start))
 6545: 
 6546:         # Set page orientation.
 6547:         if self.orientation:
 6548:             attributes.append(("orientation", "portrait"))
 6549:         else:
 6550:             attributes.append(("orientation", "landscape"))
 6551: 
 6552:         # Set the print in black and white option.
 6553:         if self.black_white:
 6554:             attributes.append(("blackAndWhite", "1"))
 6555: 
 6556:         # Set start page for printing.
 6557:         if self.page_start != 0:
 6558:             attributes.append(("useFirstPageNumber", "1"))
 6559: 
 6560:         # Set the DPI. Mainly only for testing.
 6561:         if self.is_chartsheet:
 6562:             if self.horizontal_dpi:
 6563:                 attributes.append(("horizontalDpi", self.horizontal_dpi))
 6564: 
 6565:             if self.vertical_dpi:
 6566:                 attributes.append(("verticalDpi", self.vertical_dpi))
 6567:         else:
 6568:             if self.vertical_dpi:
 6569:                 attributes.append(("verticalDpi", self.vertical_dpi))
 6570: 
 6571:             if self.horizontal_dpi:
 6572:                 attributes.append(("horizontalDpi", self.horizontal_dpi))
 6573: 
 6574:         self._xml_empty_tag("pageSetup", attributes)
 6575: 
 6576:     def _write_print_options(self):
 6577:         # Write the <printOptions> element.
 6578:         attributes = []
 6579: 
 6580:         if not self.print_options_changed:
 6581:             return
 6582: 
 6583:         # Set horizontal centering.
 6584:         if self.hcenter:
 6585:             attributes.append(("horizontalCentered", 1))
 6586: 
 6587:         # Set vertical centering.
 6588:         if self.vcenter:
 6589:             attributes.append(("verticalCentered", 1))
 6590: 
 6591:         # Enable row and column headers.
 6592:         if self.print_headers:
 6593:             attributes.append(("headings", 1))
 6594: 
 6595:         # Set printed gridlines.
 6596:         if self.print_gridlines:
 6597:             attributes.append(("gridLines", 1))
 6598: 
 6599:         self._xml_empty_tag("printOptions", attributes)
 6600: 
 6601:     def _write_header_footer(self):
 6602:         # Write the <headerFooter> element.
 6603:         attributes = []
 6604: 
 6605:         if not self.header_footer_scales:
 6606:             attributes.append(("scaleWithDoc", 0))
 6607: 
 6608:         if not self.header_footer_aligns:
 6609:             attributes.append(("alignWithMargins", 0))
 6610: 
 6611:         if self.header_footer_changed:
 6612:             self._xml_start_tag("headerFooter", attributes)
 6613:             if self.header:
 6614:                 self._write_odd_header()
 6615:             if self.footer:
 6616:                 self._write_odd_footer()
 6617:             self._xml_end_tag("headerFooter")
 6618:         elif self.excel2003_style:
 6619:             self._xml_empty_tag("headerFooter", attributes)
 6620: 
 6621:     def _write_odd_header(self):
 6622:         # Write the <headerFooter> element.
 6623:         self._xml_data_element("oddHeader", self.header)
 6624: 
 6625:     def _write_odd_footer(self):
 6626:         # Write the <headerFooter> element.
 6627:         self._xml_data_element("oddFooter", self.footer)
 6628: 
 6629:     def _write_rows(self):
 6630:         # Write out the worksheet data as a series of rows and cells.
 6631:         self._calculate_spans()
 6632: 
 6633:         for row_num in range(self.dim_rowmin, self.dim_rowmax + 1):
 6634:             if (
 6635:                 row_num in self.set_rows
 6636:                 or row_num in self.comments
 6637:                 or self.table[row_num]
 6638:             ):
 6639:                 # Only process rows with formatting, cell data and/or comments.
 6640: 
 6641:                 span_index = int(row_num / 16)
 6642: 
 6643:                 if span_index in self.row_spans:
 6644:                     span = self.row_spans[span_index]
 6645:                 else:
 6646:                     span = None
 6647: 
 6648:                 if self.table[row_num]:
 6649:                     # Write the cells if the row contains data.
 6650:                     if row_num not in self.set_rows:
 6651:                         self._write_row(row_num, span)
 6652:                     else:
 6653:                         self._write_row(row_num, span, self.set_rows[row_num])
 6654: 
 6655:                     for col_num in range(self.dim_colmin, self.dim_colmax + 1):
 6656:                         if col_num in self.table[row_num]:
 6657:                             col_ref = self.table[row_num][col_num]
 6658:                             self._write_cell(row_num, col_num, col_ref)
 6659: 
 6660:                     self._xml_end_tag("row")
 6661: 
 6662:                 elif row_num in self.comments:
 6663:                     # Row with comments in cells.
 6664:                     self._write_empty_row(row_num, span, self.set_rows[row_num])
 6665:                 else:
 6666:                     # Blank row with attributes only.
 6667:                     self._write_empty_row(row_num, span, self.set_rows[row_num])
 6668: 
 6669:     def _write_single_row(self, current_row_num=0):
 6670:         # Write out the worksheet data as a single row with cells.
 6671:         # This method is used when constant_memory is on. A single
 6672:         # row is written and the data table is reset. That way only
 6673:         # one row of data is kept in memory at any one time. We don't
 6674:         # write span data in the optimized case since it is optional.
 6675: 
 6676:         # Set the new previous row as the current row.
 6677:         row_num = self.previous_row
 6678:         self.previous_row = current_row_num
 6679: 
 6680:         if row_num in self.set_rows or row_num in self.comments or self.table[row_num]:
 6681:             # Only process rows with formatting, cell data and/or comments.
 6682: 
 6683:             # No span data in optimized mode.
 6684:             span = None
 6685: 
 6686:             if self.table[row_num]:
 6687:                 # Write the cells if the row contains data.
 6688:                 if row_num not in self.set_rows:
 6689:                     self._write_row(row_num, span)
 6690:                 else:
 6691:                     self._write_row(row_num, span, self.set_rows[row_num])
 6692: 
 6693:                 for col_num in range(self.dim_colmin, self.dim_colmax + 1):
 6694:                     if col_num in self.table[row_num]:
 6695:                         col_ref = self.table[row_num][col_num]
 6696:                         self._write_cell(row_num, col_num, col_ref)
 6697: 
 6698:                 self._xml_end_tag("row")
 6699:             else:
 6700:                 # Row attributes or comments only.
 6701:                 self._write_empty_row(row_num, span, self.set_rows[row_num])
 6702: 
 6703:         # Reset table.
 6704:         self.table.clear()
 6705: 
 6706:     def _calculate_spans(self):
 6707:         # Calculate the "spans" attribute of the <row> tag. This is an
 6708:         # XLSX optimization and isn't strictly required. However, it
 6709:         # makes comparing files easier. The span is the same for each
 6710:         # block of 16 rows.
 6711:         spans = {}
 6712:         span_min = None
 6713:         span_max = None
 6714: 
 6715:         for row_num in range(self.dim_rowmin, self.dim_rowmax + 1):
 6716:             if row_num in self.table:
 6717:                 # Calculate spans for cell data.
 6718:                 for col_num in range(self.dim_colmin, self.dim_colmax + 1):
 6719:                     if col_num in self.table[row_num]:
 6720:                         if span_min is None:
 6721:                             span_min = col_num
 6722:                             span_max = col_num
 6723:                         else:
 6724:                             if col_num < span_min:
 6725:                                 span_min = col_num
 6726:                             if col_num > span_max:
 6727:                                 span_max = col_num
 6728: 
 6729:             if row_num in self.comments:
 6730:                 # Calculate spans for comments.
 6731:                 for col_num in range(self.dim_colmin, self.dim_colmax + 1):
 6732:                     if row_num in self.comments and col_num in self.comments[row_num]:
 6733:                         if span_min is None:
 6734:                             span_min = col_num
 6735:                             span_max = col_num
 6736:                         else:
 6737:                             if col_num < span_min:
 6738:                                 span_min = col_num
 6739:                             if col_num > span_max:
 6740:                                 span_max = col_num
 6741: 
 6742:             if ((row_num + 1) % 16 == 0) or row_num == self.dim_rowmax:
 6743:                 span_index = int(row_num / 16)
 6744: 
 6745:                 if span_min is not None:
 6746:                     span_min += 1
 6747:                     span_max += 1
 6748:                     spans[span_index] = "%s:%s" % (span_min, span_max)
 6749:                     span_min = None
 6750: 
 6751:         self.row_spans = spans
 6752: 
 6753:     def _write_row(self, row, spans, properties=None, empty_row=False):
 6754:         # Write the <row> element.
 6755:         xf_index = 0
 6756: 
 6757:         if properties:
 6758:             height, cell_format, hidden, level, collapsed = properties
 6759:         else:
 6760:             height, cell_format, hidden, level, collapsed = None, None, 0, 0, 0
 6761: 
 6762:         if height is None:
 6763:             height = self.default_row_height
 6764: 
 6765:         attributes = [("r", row + 1)]
 6766: 
 6767:         # Get the cell_format index.
 6768:         if cell_format:
 6769:             xf_index = cell_format._get_xf_index()
 6770: 
 6771:         # Add row attributes where applicable.
 6772:         if spans:
 6773:             attributes.append(("spans", spans))
 6774: 
 6775:         if xf_index:
 6776:             attributes.append(("s", xf_index))
 6777: 
 6778:         if cell_format:
 6779:             attributes.append(("customFormat", 1))
 6780: 
 6781:         if height != self.original_row_height:
 6782:             attributes.append(("ht", "%g" % height))
 6783: 
 6784:         if hidden:
 6785:             attributes.append(("hidden", 1))
 6786: 
 6787:         if height != self.original_row_height:
 6788:             attributes.append(("customHeight", 1))
 6789: 
 6790:         if level:
 6791:             attributes.append(("outlineLevel", level))
 6792: 
 6793:         if collapsed:
 6794:             attributes.append(("collapsed", 1))
 6795: 
 6796:         if self.excel_version == 2010:
 6797:             attributes.append(("x14ac:dyDescent", "0.25"))
 6798: 
 6799:         if empty_row:
 6800:             self._xml_empty_tag_unencoded("row", attributes)
 6801:         else:
 6802:             self._xml_start_tag_unencoded("row", attributes)
 6803: 
 6804:     def _write_empty_row(self, row, spans, properties=None):
 6805:         # Write and empty <row> element.
 6806:         self._write_row(row, spans, properties, empty_row=True)
 6807: 
 6808:     def _write_cell(self, row, col, cell):
 6809:         # Write the <cell> element.
 6810:         # Note. This is the innermost loop so efficiency is important.
 6811: 
 6812:         cell_range = xl_rowcol_to_cell_fast(row, col)
 6813:         attributes = [("r", cell_range)]
 6814: 
 6815:         if cell.format:
 6816:             # Add the cell format index.
 6817:             xf_index = cell.format._get_xf_index()
 6818:             attributes.append(("s", xf_index))
 6819:         elif row in self.set_rows and self.set_rows[row][1]:
 6820:             # Add the row format.
 6821:             row_xf = self.set_rows[row][1]
 6822:             attributes.append(("s", row_xf._get_xf_index()))
 6823:         elif col in self.col_info:
 6824:             # Add the column format.
 6825:             col_xf = self.col_info[col][1]
 6826:             if col_xf is not None:
 6827:                 attributes.append(("s", col_xf._get_xf_index()))
 6828: 
 6829:         type_cell_name = cell.__class__.__name__
 6830: 
 6831:         # Write the various cell types.
 6832:         if type_cell_name in ("Number", "Datetime"):
 6833:             # Write a number.
 6834:             self._xml_number_element(cell.number, attributes)
 6835: 
 6836:         elif type_cell_name in ("String", "RichString"):
 6837:             # Write a string.
 6838:             string = cell.string
 6839: 
 6840:             if not self.constant_memory:
 6841:                 # Write a shared string.
 6842:                 self._xml_string_element(string, attributes)
 6843:             else:
 6844:                 # Write an optimized in-line string.
 6845: 
 6846:                 # Convert control character to a _xHHHH_ escape.
 6847:                 string = self._escape_control_characters(string)
 6848: 
 6849:                 # Write any rich strings without further tags.
 6850:                 if string.startswith("<r>") and string.endswith("</r>"):
 6851:                     self._xml_rich_inline_string(string, attributes)
 6852:                 else:
 6853:                     # Add attribute to preserve leading or trailing whitespace.
 6854:                     preserve = preserve_whitespace(string)
 6855:                     self._xml_inline_string(string, preserve, attributes)
 6856: 
 6857:         elif type_cell_name == "Formula":
 6858:             # Write a formula. First check the formula value type.
 6859:             value = cell.value
 6860:             if isinstance(cell.value, bool):
 6861:                 attributes.append(("t", "b"))
 6862:                 if cell.value:
 6863:                     value = 1
 6864:                 else:
 6865:                     value = 0
 6866: 
 6867:             elif isinstance(cell.value, str):
 6868:                 error_codes = (
 6869:                     "#DIV/0!",
 6870:                     "#N/A",
 6871:                     "#NAME?",
 6872:                     "#NULL!",
 6873:                     "#NUM!",
 6874:                     "#REF!",
 6875:                     "#VALUE!",
 6876:                 )
 6877: 
 6878:                 if cell.value == "":
 6879:                     # Allow blank to force recalc in some third party apps.
 6880:                     pass
 6881:                 elif cell.value in error_codes:
 6882:                     attributes.append(("t", "e"))
 6883:                 else:
 6884:                     attributes.append(("t", "str"))
 6885: 
 6886:             self._xml_formula_element(cell.formula, value, attributes)
 6887: 
 6888:         elif type_cell_name == "ArrayFormula":
 6889:             # Write a array formula.
 6890: 
 6891:             if cell.atype == "dynamic":
 6892:                 attributes.append(("cm", 1))
 6893: 
 6894:             # First check if the formula value is a string.
 6895:             try:
 6896:                 float(cell.value)
 6897:             except ValueError:
 6898:                 attributes.append(("t", "str"))
 6899: 
 6900:             # Write an array formula.
 6901:             self._xml_start_tag("c", attributes)
 6902: 
 6903:             self._write_cell_array_formula(cell.formula, cell.range)
 6904:             self._write_cell_value(cell.value)
 6905:             self._xml_end_tag("c")
 6906: 
 6907:         elif type_cell_name == "Blank":
 6908:             # Write a empty cell.
 6909:             self._xml_empty_tag("c", attributes)
 6910: 
 6911:         elif type_cell_name == "Boolean":
 6912:             # Write a boolean cell.
 6913:             attributes.append(("t", "b"))
 6914:             self._xml_start_tag("c", attributes)
 6915:             self._write_cell_value(cell.boolean)
 6916:             self._xml_end_tag("c")
 6917: 
 6918:         elif type_cell_name == "Error":
 6919:             # Write a boolean cell.
 6920:             attributes.append(("t", "e"))
 6921:             attributes.append(("vm", cell.value))
 6922:             self._xml_start_tag("c", attributes)
 6923:             self._write_cell_value(cell.error)
 6924:             self._xml_end_tag("c")
 6925: 
 6926:     def _write_cell_value(self, value):
 6927:         # Write the cell value <v> element.
 6928:         if value is None:
 6929:             value = ""
 6930: 
 6931:         self._xml_data_element("v", value)
 6932: 
 6933:     def _write_cell_array_formula(self, formula, cell_range):
 6934:         # Write the cell array formula <f> element.
 6935:         attributes = [("t", "array"), ("ref", cell_range)]
 6936: 
 6937:         self._xml_data_element("f", formula, attributes)
 6938: 
 6939:     def _write_sheet_pr(self):
 6940:         # Write the <sheetPr> element for Sheet level properties.
 6941:         attributes = []
 6942: 
 6943:         if (
 6944:             not self.fit_page
 6945:             and not self.filter_on
 6946:             and not self.tab_color
 6947:             and not self.outline_changed
 6948:             and not self.vba_codename
 6949:         ):
 6950:             return
 6951: 
 6952:         if self.vba_codename:
 6953:             attributes.append(("codeName", self.vba_codename))
 6954: 
 6955:         if self.filter_on:
 6956:             attributes.append(("filterMode", 1))
 6957: 
 6958:         if self.fit_page or self.tab_color or self.outline_changed:
 6959:             self._xml_start_tag("sheetPr", attributes)
 6960:             self._write_tab_color()
 6961:             self._write_outline_pr()
 6962:             self._write_page_set_up_pr()
 6963:             self._xml_end_tag("sheetPr")
 6964:         else:
 6965:             self._xml_empty_tag("sheetPr", attributes)
 6966: 
 6967:     def _write_page_set_up_pr(self):
 6968:         # Write the <pageSetUpPr> element.
 6969:         if not self.fit_page:
 6970:             return
 6971: 
 6972:         attributes = [("fitToPage", 1)]
 6973:         self._xml_empty_tag("pageSetUpPr", attributes)
 6974: 
 6975:     def _write_tab_color(self):
 6976:         # Write the <tabColor> element.
 6977:         color = self.tab_color
 6978: 
 6979:         if not color:
 6980:             return
 6981: 
 6982:         attributes = [("rgb", color)]
 6983: 
 6984:         self._xml_empty_tag("tabColor", attributes)
 6985: 
 6986:     def _write_outline_pr(self):
 6987:         # Write the <outlinePr> element.
 6988:         attributes = []
 6989: 
 6990:         if not self.outline_changed:
 6991:             return
 6992: 
 6993:         if self.outline_style:
 6994:             attributes.append(("applyStyles", 1))
 6995:         if not self.outline_below:
 6996:             attributes.append(("summaryBelow", 0))
 6997:         if not self.outline_right:
 6998:             attributes.append(("summaryRight", 0))
 6999:         if not self.outline_on:
 7000:             attributes.append(("showOutlineSymbols", 0))
 7001: 
 7002:         self._xml_empty_tag("outlinePr", attributes)
 7003: 
 7004:     def _write_row_breaks(self):
 7005:         # Write the <rowBreaks> element.
 7006:         page_breaks = self._sort_pagebreaks(self.hbreaks)
 7007: 
 7008:         if not page_breaks:
 7009:             return
 7010: 
 7011:         count = len(page_breaks)
 7012: 
 7013:         attributes = [
 7014:             ("count", count),
 7015:             ("manualBreakCount", count),
 7016:         ]
 7017: 
 7018:         self._xml_start_tag("rowBreaks", attributes)
 7019: 
 7020:         for row_num in page_breaks:
 7021:             self._write_brk(row_num, 16383)
 7022: 
 7023:         self._xml_end_tag("rowBreaks")
 7024: 
 7025:     def _write_col_breaks(self):
 7026:         # Write the <colBreaks> element.
 7027:         page_breaks = self._sort_pagebreaks(self.vbreaks)
 7028: 
 7029:         if not page_breaks:
 7030:             return
 7031: 
 7032:         count = len(page_breaks)
 7033: 
 7034:         attributes = [
 7035:             ("count", count),
 7036:             ("manualBreakCount", count),
 7037:         ]
 7038: 
 7039:         self._xml_start_tag("colBreaks", attributes)
 7040: 
 7041:         for col_num in page_breaks:
 7042:             self._write_brk(col_num, 1048575)
 7043: 
 7044:         self._xml_end_tag("colBreaks")
 7045: 
 7046:     def _write_brk(self, brk_id, brk_max):
 7047:         # Write the <brk> element.
 7048:         attributes = [("id", brk_id), ("max", brk_max), ("man", 1)]
 7049: 
 7050:         self._xml_empty_tag("brk", attributes)
 7051: 
 7052:     def _write_merge_cells(self):
 7053:         # Write the <mergeCells> element.
 7054:         merged_cells = self.merge
 7055:         count = len(merged_cells)
 7056: 
 7057:         if not count:
 7058:             return
 7059: 
 7060:         attributes = [("count", count)]
 7061: 
 7062:         self._xml_start_tag("mergeCells", attributes)
 7063: 
 7064:         for merged_range in merged_cells:
 7065:             # Write the mergeCell element.
 7066:             self._write_merge_cell(merged_range)
 7067: 
 7068:         self._xml_end_tag("mergeCells")
 7069: 
 7070:     def _write_merge_cell(self, merged_range):
 7071:         # Write the <mergeCell> element.
 7072:         (row_min, col_min, row_max, col_max) = merged_range
 7073: 
 7074:         # Convert the merge dimensions to a cell range.
 7075:         cell_1 = xl_rowcol_to_cell(row_min, col_min)
 7076:         cell_2 = xl_rowcol_to_cell(row_max, col_max)
 7077:         ref = cell_1 + ":" + cell_2
 7078: 
 7079:         attributes = [("ref", ref)]
 7080: 
 7081:         self._xml_empty_tag("mergeCell", attributes)
 7082: 
 7083:     def _write_hyperlinks(self):
 7084:         # Process any stored hyperlinks in row/col order and write the
 7085:         # <hyperlinks> element. The attributes are different for internal
 7086:         # and external links.
 7087:         hlink_refs = []
 7088:         display = None
 7089: 
 7090:         # Sort the hyperlinks into row order.
 7091:         row_nums = sorted(self.hyperlinks.keys())
 7092: 
 7093:         # Exit if there are no hyperlinks to process.
 7094:         if not row_nums:
 7095:             return
 7096: 
 7097:         # Iterate over the rows.
 7098:         for row_num in row_nums:
 7099:             # Sort the hyperlinks into column order.
 7100:             col_nums = sorted(self.hyperlinks[row_num].keys())
 7101: 
 7102:             # Iterate over the columns.
 7103:             for col_num in col_nums:
 7104:                 # Get the link data for this cell.
 7105:                 link = self.hyperlinks[row_num][col_num]
 7106:                 link_type = link["link_type"]
 7107: 
 7108:                 # If the cell isn't a string then we have to add the url as
 7109:                 # the string to display.
 7110:                 if self.table and self.table[row_num] and self.table[row_num][col_num]:
 7111:                     cell = self.table[row_num][col_num]
 7112:                     if cell.__class__.__name__ != "String":
 7113:                         display = link["url"]
 7114: 
 7115:                 if link_type == 1:
 7116:                     # External link with rel file relationship.
 7117:                     self.rel_count += 1
 7118: 
 7119:                     hlink_refs.append(
 7120:                         [
 7121:                             link_type,
 7122:                             row_num,
 7123:                             col_num,
 7124:                             self.rel_count,
 7125:                             link["str"],
 7126:                             display,
 7127:                             link["tip"],
 7128:                         ]
 7129:                     )
 7130: 
 7131:                     # Links for use by the packager.
 7132:                     self.external_hyper_links.append(
 7133:                         ["/hyperlink", link["url"], "External"]
 7134:                     )
 7135:                 else:
 7136:                     # Internal link with rel file relationship.
 7137:                     hlink_refs.append(
 7138:                         [
 7139:                             link_type,
 7140:                             row_num,
 7141:                             col_num,
 7142:                             link["url"],
 7143:                             link["str"],
 7144:                             link["tip"],
 7145:                         ]
 7146:                     )
 7147: 
 7148:         # Write the hyperlink elements.
 7149:         self._xml_start_tag("hyperlinks")
 7150: 
 7151:         for args in hlink_refs:
 7152:             link_type = args.pop(0)
 7153: 
 7154:             if link_type == 1:
 7155:                 self._write_hyperlink_external(*args)
 7156:             elif link_type == 2:
 7157:                 self._write_hyperlink_internal(*args)
 7158: 
 7159:         self._xml_end_tag("hyperlinks")
 7160: 
 7161:     def _write_hyperlink_external(
 7162:         self, row, col, id_num, location=None, display=None, tooltip=None
 7163:     ):
 7164:         # Write the <hyperlink> element for external links.
 7165:         ref = xl_rowcol_to_cell(row, col)
 7166:         r_id = "rId" + str(id_num)
 7167: 
 7168:         attributes = [("ref", ref), ("r:id", r_id)]
 7169: 
 7170:         if location is not None:
 7171:             attributes.append(("location", location))
 7172:         if display is not None:
 7173:             attributes.append(("display", display))
 7174:         if tooltip is not None:
 7175:             attributes.append(("tooltip", tooltip))
 7176: 
 7177:         self._xml_empty_tag("hyperlink", attributes)
 7178: 
 7179:     def _write_hyperlink_internal(
 7180:         self, row, col, location=None, display=None, tooltip=None
 7181:     ):
 7182:         # Write the <hyperlink> element for internal links.
 7183:         ref = xl_rowcol_to_cell(row, col)
 7184: 
 7185:         attributes = [("ref", ref), ("location", location)]
 7186: 
 7187:         if tooltip is not None:
 7188:             attributes.append(("tooltip", tooltip))
 7189:         attributes.append(("display", display))
 7190: 
 7191:         self._xml_empty_tag("hyperlink", attributes)
 7192: 
 7193:     def _write_auto_filter(self):
 7194:         # Write the <autoFilter> element.
 7195:         if not self.autofilter_ref:
 7196:             return
 7197: 
 7198:         attributes = [("ref", self.autofilter_ref)]
 7199: 
 7200:         if self.filter_on:
 7201:             # Autofilter defined active filters.
 7202:             self._xml_start_tag("autoFilter", attributes)
 7203:             self._write_autofilters()
 7204:             self._xml_end_tag("autoFilter")
 7205: 
 7206:         else:
 7207:             # Autofilter defined without active filters.
 7208:             self._xml_empty_tag("autoFilter", attributes)
 7209: 
 7210:     def _write_autofilters(self):
 7211:         # Function to iterate through the columns that form part of an
 7212:         # autofilter range and write the appropriate filters.
 7213:         (col1, col2) = self.filter_range
 7214: 
 7215:         for col in range(col1, col2 + 1):
 7216:             # Skip if column doesn't have an active filter.
 7217:             if col not in self.filter_cols:
 7218:                 continue
 7219: 
 7220:             # Retrieve the filter tokens and write the autofilter records.
 7221:             tokens = self.filter_cols[col]
 7222:             filter_type = self.filter_type[col]
 7223: 
 7224:             # Filters are relative to first column in the autofilter.
 7225:             self._write_filter_column(col - col1, filter_type, tokens)
 7226: 
 7227:     def _write_filter_column(self, col_id, filter_type, filters):
 7228:         # Write the <filterColumn> element.
 7229:         attributes = [("colId", col_id)]
 7230: 
 7231:         self._xml_start_tag("filterColumn", attributes)
 7232: 
 7233:         if filter_type == 1:
 7234:             # Type == 1 is the new XLSX style filter.
 7235:             self._write_filters(filters)
 7236:         else:
 7237:             # Type == 0 is the classic "custom" filter.
 7238:             self._write_custom_filters(filters)
 7239: 
 7240:         self._xml_end_tag("filterColumn")
 7241: 
 7242:     def _write_filters(self, filters):
 7243:         # Write the <filters> element.
 7244:         non_blanks = [filter for filter in filters if str(filter).lower() != "blanks"]
 7245:         attributes = []
 7246: 
 7247:         if len(filters) != len(non_blanks):
 7248:             attributes = [("blank", 1)]
 7249: 
 7250:         if len(filters) == 1 and len(non_blanks) == 0:
 7251:             # Special case for blank cells only.
 7252:             self._xml_empty_tag("filters", attributes)
 7253:         else:
 7254:             # General case.
 7255:             self._xml_start_tag("filters", attributes)
 7256: 
 7257:             for autofilter in sorted(non_blanks):
 7258:                 self._write_filter(autofilter)
 7259: 
 7260:             self._xml_end_tag("filters")
 7261: 
 7262:     def _write_filter(self, val):
 7263:         # Write the <filter> element.
 7264:         attributes = [("val", val)]
 7265: 
 7266:         self._xml_empty_tag("filter", attributes)
 7267: 
 7268:     def _write_custom_filters(self, tokens):
 7269:         # Write the <customFilters> element.
 7270:         if len(tokens) == 2:
 7271:             # One filter expression only.
 7272:             self._xml_start_tag("customFilters")
 7273:             self._write_custom_filter(*tokens)
 7274:             self._xml_end_tag("customFilters")
 7275:         else:
 7276:             # Two filter expressions.
 7277:             attributes = []
 7278: 
 7279:             # Check if the "join" operand is "and" or "or".
 7280:             if tokens[2] == 0:
 7281:                 attributes = [("and", 1)]
 7282:             else:
 7283:                 attributes = [("and", 0)]
 7284: 
 7285:             # Write the two custom filters.
 7286:             self._xml_start_tag("customFilters", attributes)
 7287:             self._write_custom_filter(tokens[0], tokens[1])
 7288:             self._write_custom_filter(tokens[3], tokens[4])
 7289:             self._xml_end_tag("customFilters")
 7290: 
 7291:     def _write_custom_filter(self, operator, val):
 7292:         # Write the <customFilter> element.
 7293:         attributes = []
 7294: 
 7295:         operators = {
 7296:             1: "lessThan",
 7297:             2: "equal",
 7298:             3: "lessThanOrEqual",
 7299:             4: "greaterThan",
 7300:             5: "notEqual",
 7301:             6: "greaterThanOrEqual",
 7302:             22: "equal",
 7303:         }
 7304: 
 7305:         # Convert the operator from a number to a descriptive string.
 7306:         if operators[operator] is not None:
 7307:             operator = operators[operator]
 7308:         else:
 7309:             warn("Unknown operator = %s" % operator)
 7310: 
 7311:         # The 'equal' operator is the default attribute and isn't stored.
 7312:         if operator != "equal":
 7313:             attributes.append(("operator", operator))
 7314:         attributes.append(("val", val))
 7315: 
 7316:         self._xml_empty_tag("customFilter", attributes)
 7317: 
 7318:     def _write_sheet_protection(self):
 7319:         # Write the <sheetProtection> element.
 7320:         attributes = []
 7321: 
 7322:         if not self.protect_options:
 7323:             return
 7324: 
 7325:         options = self.protect_options
 7326: 
 7327:         if options["password"]:
 7328:             attributes.append(("password", options["password"]))
 7329:         if options["sheet"]:
 7330:             attributes.append(("sheet", 1))
 7331:         if options["content"]:
 7332:             attributes.append(("content", 1))
 7333:         if not options["objects"]:
 7334:             attributes.append(("objects", 1))
 7335:         if not options["scenarios"]:
 7336:             attributes.append(("scenarios", 1))
 7337:         if options["format_cells"]:
 7338:             attributes.append(("formatCells", 0))
 7339:         if options["format_columns"]:
 7340:             attributes.append(("formatColumns", 0))
 7341:         if options["format_rows"]:
 7342:             attributes.append(("formatRows", 0))
 7343:         if options["insert_columns"]:
 7344:             attributes.append(("insertColumns", 0))
 7345:         if options["insert_rows"]:
 7346:             attributes.append(("insertRows", 0))
 7347:         if options["insert_hyperlinks"]:
 7348:             attributes.append(("insertHyperlinks", 0))
 7349:         if options["delete_columns"]:
 7350:             attributes.append(("deleteColumns", 0))
 7351:         if options["delete_rows"]:
 7352:             attributes.append(("deleteRows", 0))
 7353:         if not options["select_locked_cells"]:
 7354:             attributes.append(("selectLockedCells", 1))
 7355:         if options["sort"]:
 7356:             attributes.append(("sort", 0))
 7357:         if options["autofilter"]:
 7358:             attributes.append(("autoFilter", 0))
 7359:         if options["pivot_tables"]:
 7360:             attributes.append(("pivotTables", 0))
 7361:         if not options["select_unlocked_cells"]:
 7362:             attributes.append(("selectUnlockedCells", 1))
 7363: 
 7364:         self._xml_empty_tag("sheetProtection", attributes)
 7365: 
 7366:     def _write_protected_ranges(self):
 7367:         # Write the <protectedRanges> element.
 7368:         if self.num_protected_ranges == 0:
 7369:             return
 7370: 
 7371:         self._xml_start_tag("protectedRanges")
 7372: 
 7373:         for cell_range, range_name, password in self.protected_ranges:
 7374:             self._write_protected_range(cell_range, range_name, password)
 7375: 
 7376:         self._xml_end_tag("protectedRanges")
 7377: 
 7378:     def _write_protected_range(self, cell_range, range_name, password):
 7379:         # Write the <protectedRange> element.
 7380:         attributes = []
 7381: 
 7382:         if password:
 7383:             attributes.append(("password", password))
 7384: 
 7385:         attributes.append(("sqref", cell_range))
 7386:         attributes.append(("name", range_name))
 7387: 
 7388:         self._xml_empty_tag("protectedRange", attributes)
 7389: 
 7390:     def _write_drawings(self):
 7391:         # Write the <drawing> elements.
 7392:         if not self.drawing:
 7393:             return
 7394: 
 7395:         self.rel_count += 1
 7396:         self._write_drawing(self.rel_count)
 7397: 
 7398:     def _write_drawing(self, drawing_id):
 7399:         # Write the <drawing> element.
 7400:         r_id = "rId" + str(drawing_id)
 7401: 
 7402:         attributes = [("r:id", r_id)]
 7403: 
 7404:         self._xml_empty_tag("drawing", attributes)
 7405: 
 7406:     def _write_legacy_drawing(self):
 7407:         # Write the <legacyDrawing> element.
 7408:         if not self.has_vml:
 7409:             return
 7410: 
 7411:         # Increment the relationship id for any drawings or comments.
 7412:         self.rel_count += 1
 7413:         r_id = "rId" + str(self.rel_count)
 7414: 
 7415:         attributes = [("r:id", r_id)]
 7416: 
 7417:         self._xml_empty_tag("legacyDrawing", attributes)
 7418: 
 7419:     def _write_legacy_drawing_hf(self):
 7420:         # Write the <legacyDrawingHF> element.
 7421:         if not self.has_header_vml:
 7422:             return
 7423: 
 7424:         # Increment the relationship id for any drawings or comments.
 7425:         self.rel_count += 1
 7426:         r_id = "rId" + str(self.rel_count)
 7427: 
 7428:         attributes = [("r:id", r_id)]
 7429: 
 7430:         self._xml_empty_tag("legacyDrawingHF", attributes)
 7431: 
 7432:     def _write_picture(self):
 7433:         # Write the <picture> element.
 7434:         if not self.background_image:
 7435:             return
 7436: 
 7437:         # Increment the relationship id.
 7438:         self.rel_count += 1
 7439:         r_id = "rId" + str(self.rel_count)
 7440: 
 7441:         attributes = [("r:id", r_id)]
 7442: 
 7443:         self._xml_empty_tag("picture", attributes)
 7444: 
 7445:     def _write_data_validations(self):
 7446:         # Write the <dataValidations> element.
 7447:         validations = self.validations
 7448:         count = len(validations)
 7449: 
 7450:         if not count:
 7451:             return
 7452: 
 7453:         attributes = [("count", count)]
 7454: 
 7455:         self._xml_start_tag("dataValidations", attributes)
 7456: 
 7457:         for validation in validations:
 7458:             # Write the dataValidation element.
 7459:             self._write_data_validation(validation)
 7460: 
 7461:         self._xml_end_tag("dataValidations")
 7462: 
 7463:     def _write_data_validation(self, options):
 7464:         # Write the <dataValidation> element.
 7465:         sqref = ""
 7466:         attributes = []
 7467: 
 7468:         # Set the cell range(s) for the data validation.
 7469:         for cells in options["cells"]:
 7470:             # Add a space between multiple cell ranges.
 7471:             if sqref != "":
 7472:                 sqref += " "
 7473: 
 7474:             (row_first, col_first, row_last, col_last) = cells
 7475: 
 7476:             # Swap last row/col for first row/col as necessary
 7477:             if row_first > row_last:
 7478:                 (row_first, row_last) = (row_last, row_first)
 7479: 
 7480:             if col_first > col_last:
 7481:                 (col_first, col_last) = (col_last, col_first)
 7482: 
 7483:             sqref += xl_range(row_first, col_first, row_last, col_last)
 7484: 
 7485:         if options.get("multi_range"):
 7486:             sqref = options["multi_range"]
 7487: 
 7488:         if options["validate"] != "none":
 7489:             attributes.append(("type", options["validate"]))
 7490: 
 7491:             if options["criteria"] != "between":
 7492:                 attributes.append(("operator", options["criteria"]))
 7493: 
 7494:         if "error_type" in options:
 7495:             if options["error_type"] == 1:
 7496:                 attributes.append(("errorStyle", "warning"))
 7497:             if options["error_type"] == 2:
 7498:                 attributes.append(("errorStyle", "information"))
 7499: 
 7500:         if options["ignore_blank"]:
 7501:             attributes.append(("allowBlank", 1))
 7502: 
 7503:         if not options["dropdown"]:
 7504:             attributes.append(("showDropDown", 1))
 7505: 
 7506:         if options["show_input"]:
 7507:             attributes.append(("showInputMessage", 1))
 7508: 
 7509:         if options["show_error"]:
 7510:             attributes.append(("showErrorMessage", 1))
 7511: 
 7512:         if "error_title" in options:
 7513:             attributes.append(("errorTitle", options["error_title"]))
 7514: 
 7515:         if "error_message" in options:
 7516:             attributes.append(("error", options["error_message"]))
 7517: 
 7518:         if "input_title" in options:
 7519:             attributes.append(("promptTitle", options["input_title"]))
 7520: 
 7521:         if "input_message" in options:
 7522:             attributes.append(("prompt", options["input_message"]))
 7523: 
 7524:         attributes.append(("sqref", sqref))
 7525: 
 7526:         if options["validate"] == "none":
 7527:             self._xml_empty_tag("dataValidation", attributes)
 7528:         else:
 7529:             self._xml_start_tag("dataValidation", attributes)
 7530: 
 7531:             # Write the formula1 element.
 7532:             self._write_formula_1(options["value"])
 7533: 
 7534:             # Write the formula2 element.
 7535:             if options["maximum"] is not None:
 7536:                 self._write_formula_2(options["maximum"])
 7537: 
 7538:             self._xml_end_tag("dataValidation")
 7539: 
 7540:     def _write_formula_1(self, formula):
 7541:         # Write the <formula1> element.
 7542: 
 7543:         if isinstance(formula, list):
 7544:             formula = self._csv_join(*formula)
 7545:             formula = '"%s"' % formula
 7546:         else:
 7547:             # Check if the formula is a number.
 7548:             try:
 7549:                 float(formula)
 7550:             except ValueError:
 7551:                 # Not a number. Remove the formula '=' sign if it exists.
 7552:                 if formula.startswith("="):
 7553:                     formula = formula.lstrip("=")
 7554: 
 7555:         self._xml_data_element("formula1", formula)
 7556: 
 7557:     def _write_formula_2(self, formula):
 7558:         # Write the <formula2> element.
 7559: 
 7560:         # Check if the formula is a number.
 7561:         try:
 7562:             float(formula)
 7563:         except ValueError:
 7564:             # Not a number. Remove the formula '=' sign if it exists.
 7565:             if formula.startswith("="):
 7566:                 formula = formula.lstrip("=")
 7567: 
 7568:         self._xml_data_element("formula2", formula)
 7569: 
 7570:     def _write_conditional_formats(self):
 7571:         # Write the Worksheet conditional formats.
 7572:         ranges = sorted(self.cond_formats.keys())
 7573: 
 7574:         if not ranges:
 7575:             return
 7576: 
 7577:         for cond_range in ranges:
 7578:             self._write_conditional_formatting(
 7579:                 cond_range, self.cond_formats[cond_range]
 7580:             )
 7581: 
 7582:     def _write_conditional_formatting(self, cond_range, params):
 7583:         # Write the <conditionalFormatting> element.
 7584:         attributes = [("sqref", cond_range)]
 7585:         self._xml_start_tag("conditionalFormatting", attributes)
 7586:         for param in params:
 7587:             # Write the cfRule element.
 7588:             self._write_cf_rule(param)
 7589:         self._xml_end_tag("conditionalFormatting")
 7590: 
 7591:     def _write_cf_rule(self, params):
 7592:         # Write the <cfRule> element.
 7593:         attributes = [("type", params["type"])]
 7594: 
 7595:         if "format" in params and params["format"] is not None:
 7596:             attributes.append(("dxfId", params["format"]))
 7597: 
 7598:         attributes.append(("priority", params["priority"]))
 7599: 
 7600:         if params.get("stop_if_true"):
 7601:             attributes.append(("stopIfTrue", 1))
 7602: 
 7603:         if params["type"] == "cellIs":
 7604:             attributes.append(("operator", params["criteria"]))
 7605: 
 7606:             self._xml_start_tag("cfRule", attributes)
 7607: 
 7608:             if "minimum" in params and "maximum" in params:
 7609:                 self._write_formula_element(params["minimum"])
 7610:                 self._write_formula_element(params["maximum"])
 7611:             else:
 7612:                 self._write_formula_element(params["value"])
 7613: 
 7614:             self._xml_end_tag("cfRule")
 7615: 
 7616:         elif params["type"] == "aboveAverage":
 7617:             if re.search("below", params["criteria"]):
 7618:                 attributes.append(("aboveAverage", 0))
 7619: 
 7620:             if re.search("equal", params["criteria"]):
 7621:                 attributes.append(("equalAverage", 1))
 7622: 
 7623:             if re.search("[123] std dev", params["criteria"]):
 7624:                 match = re.search("([123]) std dev", params["criteria"])
 7625:                 attributes.append(("stdDev", match.group(1)))
 7626: 
 7627:             self._xml_empty_tag("cfRule", attributes)
 7628: 
 7629:         elif params["type"] == "top10":
 7630:             if "criteria" in params and params["criteria"] == "%":
 7631:                 attributes.append(("percent", 1))
 7632: 
 7633:             if "direction" in params:
 7634:                 attributes.append(("bottom", 1))
 7635: 
 7636:             rank = params["value"] or 10
 7637:             attributes.append(("rank", rank))
 7638: 
 7639:             self._xml_empty_tag("cfRule", attributes)
 7640: 
 7641:         elif params["type"] == "duplicateValues":
 7642:             self._xml_empty_tag("cfRule", attributes)
 7643: 
 7644:         elif params["type"] == "uniqueValues":
 7645:             self._xml_empty_tag("cfRule", attributes)
 7646: 
 7647:         elif (
 7648:             params["type"] == "containsText"
 7649:             or params["type"] == "notContainsText"
 7650:             or params["type"] == "beginsWith"
 7651:             or params["type"] == "endsWith"
 7652:         ):
 7653:             attributes.append(("operator", params["criteria"]))
 7654:             attributes.append(("text", params["value"]))
 7655:             self._xml_start_tag("cfRule", attributes)
 7656:             self._write_formula_element(params["formula"])
 7657:             self._xml_end_tag("cfRule")
 7658: 
 7659:         elif params["type"] == "timePeriod":
 7660:             attributes.append(("timePeriod", params["criteria"]))
 7661:             self._xml_start_tag("cfRule", attributes)
 7662:             self._write_formula_element(params["formula"])
 7663:             self._xml_end_tag("cfRule")
 7664: 
 7665:         elif (
 7666:             params["type"] == "containsBlanks"
 7667:             or params["type"] == "notContainsBlanks"
 7668:             or params["type"] == "containsErrors"
 7669:             or params["type"] == "notContainsErrors"
 7670:         ):
 7671:             self._xml_start_tag("cfRule", attributes)
 7672:             self._write_formula_element(params["formula"])
 7673:             self._xml_end_tag("cfRule")
 7674: 
 7675:         elif params["type"] == "colorScale":
 7676:             self._xml_start_tag("cfRule", attributes)
 7677:             self._write_color_scale(params)
 7678:             self._xml_end_tag("cfRule")
 7679: 
 7680:         elif params["type"] == "dataBar":
 7681:             self._xml_start_tag("cfRule", attributes)
 7682:             self._write_data_bar(params)
 7683: 
 7684:             if params.get("is_data_bar_2010"):
 7685:                 self._write_data_bar_ext(params)
 7686: 
 7687:             self._xml_end_tag("cfRule")
 7688: 
 7689:         elif params["type"] == "expression":
 7690:             self._xml_start_tag("cfRule", attributes)
 7691:             self._write_formula_element(params["criteria"])
 7692:             self._xml_end_tag("cfRule")
 7693: 
 7694:         elif params["type"] == "iconSet":
 7695:             self._xml_start_tag("cfRule", attributes)
 7696:             self._write_icon_set(params)
 7697:             self._xml_end_tag("cfRule")
 7698: 
 7699:     def _write_formula_element(self, formula):
 7700:         # Write the <formula> element.
 7701: 
 7702:         # Check if the formula is a number.
 7703:         try:
 7704:             float(formula)
 7705:         except ValueError:
 7706:             # Not a number. Remove the formula '=' sign if it exists.
 7707:             if formula.startswith("="):
 7708:                 formula = formula.lstrip("=")
 7709: 
 7710:         self._xml_data_element("formula", formula)
 7711: 
 7712:     def _write_color_scale(self, param):
 7713:         # Write the <colorScale> element.
 7714: 
 7715:         self._xml_start_tag("colorScale")
 7716: 
 7717:         self._write_cfvo(param["min_type"], param["min_value"])
 7718: 
 7719:         if param["mid_type"] is not None:
 7720:             self._write_cfvo(param["mid_type"], param["mid_value"])
 7721: 
 7722:         self._write_cfvo(param["max_type"], param["max_value"])
 7723: 
 7724:         self._write_color("rgb", param["min_color"])
 7725: 
 7726:         if param["mid_color"] is not None:
 7727:             self._write_color("rgb", param["mid_color"])
 7728: 
 7729:         self._write_color("rgb", param["max_color"])
 7730: 
 7731:         self._xml_end_tag("colorScale")
 7732: 
 7733:     def _write_data_bar(self, param):
 7734:         # Write the <dataBar> element.
 7735:         attributes = []
 7736: 
 7737:         # Min and max bar lengths in in the spec but not supported directly by
 7738:         # Excel.
 7739:         if param.get("min_length"):
 7740:             attributes.append(("minLength", param["min_length"]))
 7741: 
 7742:         if param.get("max_length"):
 7743:             attributes.append(("maxLength", param["max_length"]))
 7744: 
 7745:         if param.get("bar_only"):
 7746:             attributes.append(("showValue", 0))
 7747: 
 7748:         self._xml_start_tag("dataBar", attributes)
 7749: 
 7750:         self._write_cfvo(param["min_type"], param["min_value"])
 7751:         self._write_cfvo(param["max_type"], param["max_value"])
 7752:         self._write_color("rgb", param["bar_color"])
 7753: 
 7754:         self._xml_end_tag("dataBar")
 7755: 
 7756:     def _write_data_bar_ext(self, param):
 7757:         # Write the <extLst> dataBar extension element.
 7758: 
 7759:         # Create a pseudo GUID for each unique Excel 2010 data bar.
 7760:         worksheet_count = self.index + 1
 7761:         data_bar_count = len(self.data_bars_2010) + 1
 7762:         guid = "{DA7ABA51-AAAA-BBBB-%04X-%012X}" % (worksheet_count, data_bar_count)
 7763: 
 7764:         # Store the 2010 data bar parameters to write the extLst elements.
 7765:         param["guid"] = guid
 7766:         self.data_bars_2010.append(param)
 7767: 
 7768:         self._xml_start_tag("extLst")
 7769:         self._write_ext("{B025F937-C7B1-47D3-B67F-A62EFF666E3E}")
 7770:         self._xml_data_element("x14:id", guid)
 7771:         self._xml_end_tag("ext")
 7772:         self._xml_end_tag("extLst")
 7773: 
 7774:     def _write_icon_set(self, param):
 7775:         # Write the <iconSet> element.
 7776:         attributes = []
 7777: 
 7778:         # Don't set attribute for default style.
 7779:         if param["icon_style"] != "3TrafficLights":
 7780:             attributes = [("iconSet", param["icon_style"])]
 7781: 
 7782:         if param.get("icons_only"):
 7783:             attributes.append(("showValue", 0))
 7784: 
 7785:         if param.get("reverse_icons"):
 7786:             attributes.append(("reverse", 1))
 7787: 
 7788:         self._xml_start_tag("iconSet", attributes)
 7789: 
 7790:         # Write the properties for different icon styles.
 7791:         for icon in reversed(param["icons"]):
 7792:             self._write_cfvo(icon["type"], icon["value"], icon["criteria"])
 7793: 
 7794:         self._xml_end_tag("iconSet")
 7795: 
 7796:     def _write_cfvo(self, cf_type, val, criteria=None):
 7797:         # Write the <cfvo> element.
 7798:         attributes = [("type", cf_type)]
 7799: 
 7800:         if val is not None:
 7801:             attributes.append(("val", val))
 7802: 
 7803:         if criteria:
 7804:             attributes.append(("gte", 0))
 7805: 
 7806:         self._xml_empty_tag("cfvo", attributes)
 7807: 
 7808:     def _write_color(self, name, value):
 7809:         # Write the <color> element.
 7810:         attributes = [(name, value)]
 7811: 
 7812:         self._xml_empty_tag("color", attributes)
 7813: 
 7814:     def _write_selections(self):
 7815:         # Write the <selection> elements.
 7816:         for selection in self.selections:
 7817:             self._write_selection(*selection)
 7818: 
 7819:     def _write_selection(self, pane, active_cell, sqref):
 7820:         # Write the <selection> element.
 7821:         attributes = []
 7822: 
 7823:         if pane:
 7824:             attributes.append(("pane", pane))
 7825: 
 7826:         if active_cell:
 7827:             attributes.append(("activeCell", active_cell))
 7828: 
 7829:         if sqref:
 7830:             attributes.append(("sqref", sqref))
 7831: 
 7832:         self._xml_empty_tag("selection", attributes)
 7833: 
 7834:     def _write_panes(self):
 7835:         # Write the frozen or split <pane> elements.
 7836:         panes = self.panes
 7837: 
 7838:         if not len(panes):
 7839:             return
 7840: 
 7841:         if panes[4] == 2:
 7842:             self._write_split_panes(*panes)
 7843:         else:
 7844:             self._write_freeze_panes(*panes)
 7845: 
 7846:     def _write_freeze_panes(self, row, col, top_row, left_col, pane_type):
 7847:         # Write the <pane> element for freeze panes.
 7848:         attributes = []
 7849: 
 7850:         y_split = row
 7851:         x_split = col
 7852:         top_left_cell = xl_rowcol_to_cell(top_row, left_col)
 7853:         active_pane = ""
 7854:         state = ""
 7855:         active_cell = ""
 7856:         sqref = ""
 7857: 
 7858:         # Move user cell selection to the panes.
 7859:         if self.selections:
 7860:             (_, active_cell, sqref) = self.selections[0]
 7861:             self.selections = []
 7862: 
 7863:         # Set the active pane.
 7864:         if row and col:
 7865:             active_pane = "bottomRight"
 7866: 
 7867:             row_cell = xl_rowcol_to_cell(row, 0)
 7868:             col_cell = xl_rowcol_to_cell(0, col)
 7869: 
 7870:             self.selections.append(["topRight", col_cell, col_cell])
 7871:             self.selections.append(["bottomLeft", row_cell, row_cell])
 7872:             self.selections.append(["bottomRight", active_cell, sqref])
 7873: 
 7874:         elif col:
 7875:             active_pane = "topRight"
 7876:             self.selections.append(["topRight", active_cell, sqref])
 7877: 
 7878:         else:
 7879:             active_pane = "bottomLeft"
 7880:             self.selections.append(["bottomLeft", active_cell, sqref])
 7881: 
 7882:         # Set the pane type.
 7883:         if pane_type == 0:
 7884:             state = "frozen"
 7885:         elif pane_type == 1:
 7886:             state = "frozenSplit"
 7887:         else:
 7888:             state = "split"
 7889: 
 7890:         if x_split:
 7891:             attributes.append(("xSplit", x_split))
 7892: 
 7893:         if y_split:
 7894:             attributes.append(("ySplit", y_split))
 7895: 
 7896:         attributes.append(("topLeftCell", top_left_cell))
 7897:         attributes.append(("activePane", active_pane))
 7898:         attributes.append(("state", state))
 7899: 
 7900:         self._xml_empty_tag("pane", attributes)
 7901: 
 7902:     def _write_split_panes(self, row, col, top_row, left_col, pane_type):
 7903:         # Write the <pane> element for split panes.
 7904:         attributes = []
 7905:         has_selection = 0
 7906:         active_pane = ""
 7907:         active_cell = ""
 7908:         sqref = ""
 7909: 
 7910:         y_split = row
 7911:         x_split = col
 7912: 
 7913:         # Move user cell selection to the panes.
 7914:         if self.selections:
 7915:             (_, active_cell, sqref) = self.selections[0]
 7916:             self.selections = []
 7917:             has_selection = 1
 7918: 
 7919:         # Convert the row and col to 1/20 twip units with padding.
 7920:         if y_split:
 7921:             y_split = int(20 * y_split + 300)
 7922: 
 7923:         if x_split:
 7924:             x_split = self._calculate_x_split_width(x_split)
 7925: 
 7926:         # For non-explicit topLeft definitions, estimate the cell offset based
 7927:         # on the pixels dimensions. This is only a workaround and doesn't take
 7928:         # adjusted cell dimensions into account.
 7929:         if top_row == row and left_col == col:
 7930:             top_row = int(0.5 + (y_split - 300) / 20 / 15)
 7931:             left_col = int(0.5 + (x_split - 390) / 20 / 3 * 4 / 64)
 7932: 
 7933:         top_left_cell = xl_rowcol_to_cell(top_row, left_col)
 7934: 
 7935:         # If there is no selection set the active cell to the top left cell.
 7936:         if not has_selection:
 7937:             active_cell = top_left_cell
 7938:             sqref = top_left_cell
 7939: 
 7940:         # Set the Cell selections.
 7941:         if row and col:
 7942:             active_pane = "bottomRight"
 7943: 
 7944:             row_cell = xl_rowcol_to_cell(top_row, 0)
 7945:             col_cell = xl_rowcol_to_cell(0, left_col)
 7946: 
 7947:             self.selections.append(["topRight", col_cell, col_cell])
 7948:             self.selections.append(["bottomLeft", row_cell, row_cell])
 7949:             self.selections.append(["bottomRight", active_cell, sqref])
 7950: 
 7951:         elif col:
 7952:             active_pane = "topRight"
 7953:             self.selections.append(["topRight", active_cell, sqref])
 7954: 
 7955:         else:
 7956:             active_pane = "bottomLeft"
 7957:             self.selections.append(["bottomLeft", active_cell, sqref])
 7958: 
 7959:         # Format splits to the same precision as Excel.
 7960:         if x_split:
 7961:             attributes.append(("xSplit", "%.16g" % x_split))
 7962: 
 7963:         if y_split:
 7964:             attributes.append(("ySplit", "%.16g" % y_split))
 7965: 
 7966:         attributes.append(("topLeftCell", top_left_cell))
 7967: 
 7968:         if has_selection:
 7969:             attributes.append(("activePane", active_pane))
 7970: 
 7971:         self._xml_empty_tag("pane", attributes)
 7972: 
 7973:     def _calculate_x_split_width(self, width):
 7974:         # Convert column width from user units to pane split width.
 7975: 
 7976:         max_digit_width = 7  # For Calabri 11.
 7977:         padding = 5
 7978: 
 7979:         # Convert to pixels.
 7980:         if width < 1:
 7981:             pixels = int(width * (max_digit_width + padding) + 0.5)
 7982:         else:
 7983:             pixels = int(width * max_digit_width + 0.5) + padding
 7984: 
 7985:         # Convert to points.
 7986:         points = pixels * 3 / 4
 7987: 
 7988:         # Convert to twips (twentieths of a point).
 7989:         twips = points * 20
 7990: 
 7991:         # Add offset/padding.
 7992:         width = twips + 390
 7993: 
 7994:         return width
 7995: 
 7996:     def _write_table_parts(self):
 7997:         # Write the <tableParts> element.
 7998:         tables = self.tables
 7999:         count = len(tables)
 8000: 
 8001:         # Return if worksheet doesn't contain any tables.
 8002:         if not count:
 8003:             return
 8004: 
 8005:         attributes = [
 8006:             (
 8007:                 "count",
 8008:                 count,
 8009:             )
 8010:         ]
 8011: 
 8012:         self._xml_start_tag("tableParts", attributes)
 8013: 
 8014:         for _ in tables:
 8015:             # Write the tablePart element.
 8016:             self.rel_count += 1
 8017:             self._write_table_part(self.rel_count)
 8018: 
 8019:         self._xml_end_tag("tableParts")
 8020: 
 8021:     def _write_table_part(self, r_id):
 8022:         # Write the <tablePart> element.
 8023: 
 8024:         r_id = "rId" + str(r_id)
 8025: 
 8026:         attributes = [
 8027:             (
 8028:                 "r:id",
 8029:                 r_id,
 8030:             )
 8031:         ]
 8032: 
 8033:         self._xml_empty_tag("tablePart", attributes)
 8034: 
 8035:     def _write_ext_list(self):
 8036:         # Write the <extLst> element for data bars and sparklines.
 8037:         has_data_bars = len(self.data_bars_2010)
 8038:         has_sparklines = len(self.sparklines)
 8039: 
 8040:         if not has_data_bars and not has_sparklines:
 8041:             return
 8042: 
 8043:         # Write the extLst element.
 8044:         self._xml_start_tag("extLst")
 8045: 
 8046:         if has_data_bars:
 8047:             self._write_ext_list_data_bars()
 8048: 
 8049:         if has_sparklines:
 8050:             self._write_ext_list_sparklines()
 8051: 
 8052:         self._xml_end_tag("extLst")
 8053: 
 8054:     def _write_ext_list_data_bars(self):
 8055:         # Write the Excel 2010 data_bar subelements.
 8056:         self._write_ext("{78C0D931-6437-407d-A8EE-F0AAD7539E65}")
 8057: 
 8058:         self._xml_start_tag("x14:conditionalFormattings")
 8059: 
 8060:         # Write the Excel 2010 conditional formatting data bar elements.
 8061:         for data_bar in self.data_bars_2010:
 8062:             # Write the x14:conditionalFormatting element.
 8063:             self._write_conditional_formatting_2010(data_bar)
 8064: 
 8065:         self._xml_end_tag("x14:conditionalFormattings")
 8066:         self._xml_end_tag("ext")
 8067: 
 8068:     def _write_conditional_formatting_2010(self, data_bar):
 8069:         # Write the <x14:conditionalFormatting> element.
 8070:         xmlns_xm = "http://schemas.microsoft.com/office/excel/2006/main"
 8071: 
 8072:         attributes = [("xmlns:xm", xmlns_xm)]
 8073: 
 8074:         self._xml_start_tag("x14:conditionalFormatting", attributes)
 8075: 
 8076:         # Write the x14:cfRule element.
 8077:         self._write_x14_cf_rule(data_bar)
 8078: 
 8079:         # Write the x14:dataBar element.
 8080:         self._write_x14_data_bar(data_bar)
 8081: 
 8082:         # Write the x14 max and min data bars.
 8083:         self._write_x14_cfvo(data_bar["x14_min_type"], data_bar["min_value"])
 8084:         self._write_x14_cfvo(data_bar["x14_max_type"], data_bar["max_value"])
 8085: 
 8086:         if not data_bar["bar_no_border"]:
 8087:             # Write the x14:borderColor element.
 8088:             self._write_x14_border_color(data_bar["bar_border_color"])
 8089: 
 8090:         # Write the x14:negativeFillColor element.
 8091:         if not data_bar["bar_negative_color_same"]:
 8092:             self._write_x14_negative_fill_color(data_bar["bar_negative_color"])
 8093: 
 8094:         # Write the x14:negativeBorderColor element.
 8095:         if (
 8096:             not data_bar["bar_no_border"]
 8097:             and not data_bar["bar_negative_border_color_same"]
 8098:         ):
 8099:             self._write_x14_negative_border_color(data_bar["bar_negative_border_color"])
 8100: 
 8101:         # Write the x14:axisColor element.
 8102:         if data_bar["bar_axis_position"] != "none":
 8103:             self._write_x14_axis_color(data_bar["bar_axis_color"])
 8104: 
 8105:         self._xml_end_tag("x14:dataBar")
 8106:         self._xml_end_tag("x14:cfRule")
 8107: 
 8108:         # Write the xm:sqref element.
 8109:         self._xml_data_element("xm:sqref", data_bar["range"])
 8110: 
 8111:         self._xml_end_tag("x14:conditionalFormatting")
 8112: 
 8113:     def _write_x14_cf_rule(self, data_bar):
 8114:         # Write the <x14:cfRule> element.
 8115:         rule_type = "dataBar"
 8116:         guid = data_bar["guid"]
 8117:         attributes = [("type", rule_type), ("id", guid)]
 8118: 
 8119:         self._xml_start_tag("x14:cfRule", attributes)
 8120: 
 8121:     def _write_x14_data_bar(self, data_bar):
 8122:         # Write the <x14:dataBar> element.
 8123:         min_length = 0
 8124:         max_length = 100
 8125: 
 8126:         attributes = [
 8127:             ("minLength", min_length),
 8128:             ("maxLength", max_length),
 8129:         ]
 8130: 
 8131:         if not data_bar["bar_no_border"]:
 8132:             attributes.append(("border", 1))
 8133: 
 8134:         if data_bar["bar_solid"]:
 8135:             attributes.append(("gradient", 0))
 8136: 
 8137:         if data_bar["bar_direction"] == "left":
 8138:             attributes.append(("direction", "leftToRight"))
 8139: 
 8140:         if data_bar["bar_direction"] == "right":
 8141:             attributes.append(("direction", "rightToLeft"))
 8142: 
 8143:         if data_bar["bar_negative_color_same"]:
 8144:             attributes.append(("negativeBarColorSameAsPositive", 1))
 8145: 
 8146:         if (
 8147:             not data_bar["bar_no_border"]
 8148:             and not data_bar["bar_negative_border_color_same"]
 8149:         ):
 8150:             attributes.append(("negativeBarBorderColorSameAsPositive", 0))
 8151: 
 8152:         if data_bar["bar_axis_position"] == "middle":
 8153:             attributes.append(("axisPosition", "middle"))
 8154: 
 8155:         if data_bar["bar_axis_position"] == "none":
 8156:             attributes.append(("axisPosition", "none"))
 8157: 
 8158:         self._xml_start_tag("x14:dataBar", attributes)
 8159: 
 8160:     def _write_x14_cfvo(self, rule_type, value):
 8161:         # Write the <x14:cfvo> element.
 8162:         attributes = [("type", rule_type)]
 8163: 
 8164:         if rule_type in ("min", "max", "autoMin", "autoMax"):
 8165:             self._xml_empty_tag("x14:cfvo", attributes)
 8166:         else:
 8167:             self._xml_start_tag("x14:cfvo", attributes)
 8168:             self._xml_data_element("xm:f", value)
 8169:             self._xml_end_tag("x14:cfvo")
 8170: 
 8171:     def _write_x14_border_color(self, rgb):
 8172:         # Write the <x14:borderColor> element.
 8173:         attributes = [("rgb", rgb)]
 8174:         self._xml_empty_tag("x14:borderColor", attributes)
 8175: 
 8176:     def _write_x14_negative_fill_color(self, rgb):
 8177:         # Write the <x14:negativeFillColor> element.
 8178:         attributes = [("rgb", rgb)]
 8179:         self._xml_empty_tag("x14:negativeFillColor", attributes)
 8180: 
 8181:     def _write_x14_negative_border_color(self, rgb):
 8182:         # Write the <x14:negativeBorderColor> element.
 8183:         attributes = [("rgb", rgb)]
 8184:         self._xml_empty_tag("x14:negativeBorderColor", attributes)
 8185: 
 8186:     def _write_x14_axis_color(self, rgb):
 8187:         # Write the <x14:axisColor> element.
 8188:         attributes = [("rgb", rgb)]
 8189:         self._xml_empty_tag("x14:axisColor", attributes)
 8190: 
 8191:     def _write_ext_list_sparklines(self):
 8192:         # Write the sparkline extension sub-elements.
 8193:         self._write_ext("{05C60535-1F16-4fd2-B633-F4F36F0B64E0}")
 8194: 
 8195:         # Write the x14:sparklineGroups element.
 8196:         self._write_sparkline_groups()
 8197: 
 8198:         # Write the sparkline elements.
 8199:         for sparkline in reversed(self.sparklines):
 8200:             # Write the x14:sparklineGroup element.
 8201:             self._write_sparkline_group(sparkline)
 8202: 
 8203:             # Write the x14:colorSeries element.
 8204:             self._write_color_series(sparkline["series_color"])
 8205: 
 8206:             # Write the x14:colorNegative element.
 8207:             self._write_color_negative(sparkline["negative_color"])
 8208: 
 8209:             # Write the x14:colorAxis element.
 8210:             self._write_color_axis()
 8211: 
 8212:             # Write the x14:colorMarkers element.
 8213:             self._write_color_markers(sparkline["markers_color"])
 8214: 
 8215:             # Write the x14:colorFirst element.
 8216:             self._write_color_first(sparkline["first_color"])
 8217: 
 8218:             # Write the x14:colorLast element.
 8219:             self._write_color_last(sparkline["last_color"])
 8220: 
 8221:             # Write the x14:colorHigh element.
 8222:             self._write_color_high(sparkline["high_color"])
 8223: 
 8224:             # Write the x14:colorLow element.
 8225:             self._write_color_low(sparkline["low_color"])
 8226: 
 8227:             if sparkline["date_axis"]:
 8228:                 self._xml_data_element("xm:f", sparkline["date_axis"])
 8229: 
 8230:             self._write_sparklines(sparkline)
 8231: 
 8232:             self._xml_end_tag("x14:sparklineGroup")
 8233: 
 8234:         self._xml_end_tag("x14:sparklineGroups")
 8235:         self._xml_end_tag("ext")
 8236: 
 8237:     def _write_sparklines(self, sparkline):
 8238:         # Write the <x14:sparklines> element and <x14:sparkline> sub-elements.
 8239: 
 8240:         # Write the sparkline elements.
 8241:         self._xml_start_tag("x14:sparklines")
 8242: 
 8243:         for i in range(sparkline["count"]):
 8244:             spark_range = sparkline["ranges"][i]
 8245:             location = sparkline["locations"][i]
 8246: 
 8247:             self._xml_start_tag("x14:sparkline")
 8248:             self._xml_data_element("xm:f", spark_range)
 8249:             self._xml_data_element("xm:sqref", location)
 8250:             self._xml_end_tag("x14:sparkline")
 8251: 
 8252:         self._xml_end_tag("x14:sparklines")
 8253: 
 8254:     def _write_ext(self, uri):
 8255:         # Write the <ext> element.
 8256:         schema = "http://schemas.microsoft.com/office/"
 8257:         xmlns_x14 = schema + "spreadsheetml/2009/9/main"
 8258: 
 8259:         attributes = [
 8260:             ("xmlns:x14", xmlns_x14),
 8261:             ("uri", uri),
 8262:         ]
 8263: 
 8264:         self._xml_start_tag("ext", attributes)
 8265: 
 8266:     def _write_sparkline_groups(self):
 8267:         # Write the <x14:sparklineGroups> element.
 8268:         xmlns_xm = "http://schemas.microsoft.com/office/excel/2006/main"
 8269: 
 8270:         attributes = [("xmlns:xm", xmlns_xm)]
 8271: 
 8272:         self._xml_start_tag("x14:sparklineGroups", attributes)
 8273: 
 8274:     def _write_sparkline_group(self, options):
 8275:         # Write the <x14:sparklineGroup> element.
 8276:         #
 8277:         # Example for order.
 8278:         #
 8279:         # <x14:sparklineGroup
 8280:         #     manualMax="0"
 8281:         #     manualMin="0"
 8282:         #     lineWeight="2.25"
 8283:         #     type="column"
 8284:         #     dateAxis="1"
 8285:         #     displayEmptyCellsAs="span"
 8286:         #     markers="1"
 8287:         #     high="1"
 8288:         #     low="1"
 8289:         #     first="1"
 8290:         #     last="1"
 8291:         #     negative="1"
 8292:         #     displayXAxis="1"
 8293:         #     displayHidden="1"
 8294:         #     minAxisType="custom"
 8295:         #     maxAxisType="custom"
 8296:         #     rightToLeft="1">
 8297:         #
 8298:         empty = options.get("empty")
 8299:         attributes = []
 8300: 
 8301:         if options.get("max") is not None:
 8302:             if options["max"] == "group":
 8303:                 options["cust_max"] = "group"
 8304:             else:
 8305:                 attributes.append(("manualMax", options["max"]))
 8306:                 options["cust_max"] = "custom"
 8307: 
 8308:         if options.get("min") is not None:
 8309:             if options["min"] == "group":
 8310:                 options["cust_min"] = "group"
 8311:             else:
 8312:                 attributes.append(("manualMin", options["min"]))
 8313:                 options["cust_min"] = "custom"
 8314: 
 8315:         # Ignore the default type attribute (line).
 8316:         if options["type"] != "line":
 8317:             attributes.append(("type", options["type"]))
 8318: 
 8319:         if options.get("weight"):
 8320:             attributes.append(("lineWeight", options["weight"]))
 8321: 
 8322:         if options.get("date_axis"):
 8323:             attributes.append(("dateAxis", 1))
 8324: 
 8325:         if empty:
 8326:             attributes.append(("displayEmptyCellsAs", empty))
 8327: 
 8328:         if options.get("markers"):
 8329:             attributes.append(("markers", 1))
 8330: 
 8331:         if options.get("high"):
 8332:             attributes.append(("high", 1))
 8333: 
 8334:         if options.get("low"):
 8335:             attributes.append(("low", 1))
 8336: 
 8337:         if options.get("first"):
 8338:             attributes.append(("first", 1))
 8339: 
 8340:         if options.get("last"):
 8341:             attributes.append(("last", 1))
 8342: 
 8343:         if options.get("negative"):
 8344:             attributes.append(("negative", 1))
 8345: 
 8346:         if options.get("axis"):
 8347:             attributes.append(("displayXAxis", 1))
 8348: 
 8349:         if options.get("hidden"):
 8350:             attributes.append(("displayHidden", 1))
 8351: 
 8352:         if options.get("cust_min"):
 8353:             attributes.append(("minAxisType", options["cust_min"]))
 8354: 
 8355:         if options.get("cust_max"):
 8356:             attributes.append(("maxAxisType", options["cust_max"]))
 8357: 
 8358:         if options.get("reverse"):
 8359:             attributes.append(("rightToLeft", 1))
 8360: 
 8361:         self._xml_start_tag("x14:sparklineGroup", attributes)
 8362: 
 8363:     def _write_spark_color(self, element, color):
 8364:         # Helper function for the sparkline color functions below.
 8365:         attributes = []
 8366: 
 8367:         if color.get("rgb"):
 8368:             attributes.append(("rgb", color["rgb"]))
 8369: 
 8370:         if color.get("theme"):
 8371:             attributes.append(("theme", color["theme"]))
 8372: 
 8373:         if color.get("tint"):
 8374:             attributes.append(("tint", color["tint"]))
 8375: 
 8376:         self._xml_empty_tag(element, attributes)
 8377: 
 8378:     def _write_color_series(self, color):
 8379:         # Write the <x14:colorSeries> element.
 8380:         self._write_spark_color("x14:colorSeries", color)
 8381: 
 8382:     def _write_color_negative(self, color):
 8383:         # Write the <x14:colorNegative> element.
 8384:         self._write_spark_color("x14:colorNegative", color)
 8385: 
 8386:     def _write_color_axis(self):
 8387:         # Write the <x14:colorAxis> element.
 8388:         self._write_spark_color("x14:colorAxis", {"rgb": "FF000000"})
 8389: 
 8390:     def _write_color_markers(self, color):
 8391:         # Write the <x14:colorMarkers> element.
 8392:         self._write_spark_color("x14:colorMarkers", color)
 8393: 
 8394:     def _write_color_first(self, color):
 8395:         # Write the <x14:colorFirst> element.
 8396:         self._write_spark_color("x14:colorFirst", color)
 8397: 
 8398:     def _write_color_last(self, color):
 8399:         # Write the <x14:colorLast> element.
 8400:         self._write_spark_color("x14:colorLast", color)
 8401: 
 8402:     def _write_color_high(self, color):
 8403:         # Write the <x14:colorHigh> element.
 8404:         self._write_spark_color("x14:colorHigh", color)
 8405: 
 8406:     def _write_color_low(self, color):
 8407:         # Write the <x14:colorLow> element.
 8408:         self._write_spark_color("x14:colorLow", color)
 8409: 
 8410:     def _write_phonetic_pr(self):
 8411:         # Write the <phoneticPr> element.
 8412:         attributes = [
 8413:             ("fontId", "0"),
 8414:             ("type", "noConversion"),
 8415:         ]
 8416: 
 8417:         self._xml_empty_tag("phoneticPr", attributes)
 8418: 
 8419:     def _write_ignored_errors(self):
 8420:         # Write the <ignoredErrors> element.
 8421:         if not self.ignored_errors:
 8422:             return
 8423: 
 8424:         self._xml_start_tag("ignoredErrors")
 8425: 
 8426:         if self.ignored_errors.get("number_stored_as_text"):
 8427:             ignored_range = self.ignored_errors["number_stored_as_text"]
 8428:             self._write_ignored_error("numberStoredAsText", ignored_range)
 8429: 
 8430:         if self.ignored_errors.get("eval_error"):
 8431:             ignored_range = self.ignored_errors["eval_error"]
 8432:             self._write_ignored_error("evalError", ignored_range)
 8433: 
 8434:         if self.ignored_errors.get("formula_differs"):
 8435:             ignored_range = self.ignored_errors["formula_differs"]
 8436:             self._write_ignored_error("formula", ignored_range)
 8437: 
 8438:         if self.ignored_errors.get("formula_range"):
 8439:             ignored_range = self.ignored_errors["formula_range"]
 8440:             self._write_ignored_error("formulaRange", ignored_range)
 8441: 
 8442:         if self.ignored_errors.get("formula_unlocked"):
 8443:             ignored_range = self.ignored_errors["formula_unlocked"]
 8444:             self._write_ignored_error("unlockedFormula", ignored_range)
 8445: 
 8446:         if self.ignored_errors.get("empty_cell_reference"):
 8447:             ignored_range = self.ignored_errors["empty_cell_reference"]
 8448:             self._write_ignored_error("emptyCellReference", ignored_range)
 8449: 
 8450:         if self.ignored_errors.get("list_data_validation"):
 8451:             ignored_range = self.ignored_errors["list_data_validation"]
 8452:             self._write_ignored_error("listDataValidation", ignored_range)
 8453: 
 8454:         if self.ignored_errors.get("calculated_column"):
 8455:             ignored_range = self.ignored_errors["calculated_column"]
 8456:             self._write_ignored_error("calculatedColumn", ignored_range)
 8457: 
 8458:         if self.ignored_errors.get("two_digit_text_year"):
 8459:             ignored_range = self.ignored_errors["two_digit_text_year"]
 8460:             self._write_ignored_error("twoDigitTextYear", ignored_range)
 8461: 
 8462:         self._xml_end_tag("ignoredErrors")
 8463: 
 8464:     def _write_ignored_error(self, type, ignored_range):
 8465:         # Write the <ignoredError> element.
 8466:         attributes = [
 8467:             ("sqref", ignored_range),
 8468:             (type, 1),
 8469:         ]
 8470: 
 8471:         self._xml_empty_tag("ignoredError", attributes)
