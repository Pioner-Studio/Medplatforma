    1: """Module for parsing and testing package version predicate strings.
    2: """
    3: import re
    4: import distutils.version
    5: import operator
    6: 
    7: 
    8: re_validPackage = re.compile(r"(?i)^\s*([a-z_]\w*(?:\.[a-z_]\w*)*)(.*)", re.ASCII)
    9: # (package) (rest)
   10: 
   11: re_paren = re.compile(r"^\s*\((.*)\)\s*$")  # (list) inside of parentheses
   12: re_splitComparison = re.compile(r"^\s*(<=|>=|<|>|!=|==)\s*([^\s,]+)\s*$")
   13: # (comp) (version)
   14: 
   15: 
   16: def splitUp(pred):
   17:     """Parse a single version comparison.
   18: 
   19:     Return (comparison string, StrictVersion)
   20:     """
   21:     res = re_splitComparison.match(pred)
   22:     if not res:
   23:         raise ValueError("bad package restriction syntax: %r" % pred)
   24:     comp, verStr = res.groups()
   25:     with distutils.version.suppress_known_deprecation():
   26:         other = distutils.version.StrictVersion(verStr)
   27:     return (comp, other)
   28: 
   29: 
   30: compmap = {
   31:     "<": operator.lt,
   32:     "<=": operator.le,
   33:     "==": operator.eq,
   34:     ">": operator.gt,
   35:     ">=": operator.ge,
   36:     "!=": operator.ne,
   37: }
   38: 
   39: 
   40: class VersionPredicate:
   41:     """Parse and test package version predicates.
   42: 
   43:     >>> v = VersionPredicate('pyepat.abc (>1.0, <3333.3a1, !=1555.1b3)')
   44: 
   45:     The `name` attribute provides the full dotted name that is given::
   46: 
   47:     >>> v.name
   48:     'pyepat.abc'
   49: 
   50:     The str() of a `VersionPredicate` provides a normalized
   51:     human-readable version of the expression::
   52: 
   53:     >>> print(v)
   54:     pyepat.abc (> 1.0, < 3333.3a1, != 1555.1b3)
   55: 
   56:     The `satisfied_by()` method can be used to determine with a given
   57:     version number is included in the set described by the version
   58:     restrictions::
   59: 
   60:     >>> v.satisfied_by('1.1')
   61:     True
   62:     >>> v.satisfied_by('1.4')
   63:     True
   64:     >>> v.satisfied_by('1.0')
   65:     False
   66:     >>> v.satisfied_by('4444.4')
   67:     False
   68:     >>> v.satisfied_by('1555.1b3')
   69:     False
   70: 
   71:     `VersionPredicate` is flexible in accepting extra whitespace::
   72: 
   73:     >>> v = VersionPredicate(' pat( ==  0.1  )  ')
   74:     >>> v.name
   75:     'pat'
   76:     >>> v.satisfied_by('0.1')
   77:     True
   78:     >>> v.satisfied_by('0.2')
   79:     False
   80: 
   81:     If any version numbers passed in do not conform to the
   82:     restrictions of `StrictVersion`, a `ValueError` is raised::
   83: 
   84:     >>> v = VersionPredicate('p1.p2.p3.p4(>=1.0, <=1.3a1, !=1.2zb3)')
   85:     Traceback (most recent call last):
   86:       ...
   87:     ValueError: invalid version number '1.2zb3'
   88: 
   89:     It the module or package name given does not conform to what's
   90:     allowed as a legal module or package name, `ValueError` is
   91:     raised::
   92: 
   93:     >>> v = VersionPredicate('foo-bar')
   94:     Traceback (most recent call last):
   95:       ...
   96:     ValueError: expected parenthesized list: '-bar'
   97: 
   98:     >>> v = VersionPredicate('foo bar (12.21)')
   99:     Traceback (most recent call last):
  100:       ...
  101:     ValueError: expected parenthesized list: 'bar (12.21)'
  102: 
  103:     """
  104: 
  105:     def __init__(self, versionPredicateStr):
  106:         """Parse a version predicate string."""
  107:         # Fields:
  108:         #    name:  package name
  109:         #    pred:  list of (comparison string, StrictVersion)
  110: 
  111:         versionPredicateStr = versionPredicateStr.strip()
  112:         if not versionPredicateStr:
  113:             raise ValueError("empty package restriction")
  114:         match = re_validPackage.match(versionPredicateStr)
  115:         if not match:
  116:             raise ValueError("bad package name in %r" % versionPredicateStr)
  117:         self.name, paren = match.groups()
  118:         paren = paren.strip()
  119:         if paren:
  120:             match = re_paren.match(paren)
  121:             if not match:
  122:                 raise ValueError("expected parenthesized list: %r" % paren)
  123:             str = match.groups()[0]
  124:             self.pred = [splitUp(aPred) for aPred in str.split(",")]
  125:             if not self.pred:
  126:                 raise ValueError("empty parenthesized list in %r" % versionPredicateStr)
  127:         else:
  128:             self.pred = []
  129: 
  130:     def __str__(self):
  131:         if self.pred:
  132:             seq = [cond + " " + str(ver) for cond, ver in self.pred]
  133:             return self.name + " (" + ", ".join(seq) + ")"
  134:         else:
  135:             return self.name
  136: 
  137:     def satisfied_by(self, version):
  138:         """True if version is compatible with all the predicates in self.
  139:         The parameter version must be acceptable to the StrictVersion
  140:         constructor.  It may be either a string or StrictVersion.
  141:         """
  142:         for cond, ver in self.pred:
  143:             if not compmap[cond](version, ver):
  144:                 return False
  145:         return True
  146: 
  147: 
  148: _provision_rx = None
  149: 
  150: 
  151: def split_provision(value):
  152:     """Return the name and optional version number of a provision.
  153: 
  154:     The version number, if given, will be returned as a `StrictVersion`
  155:     instance, otherwise it will be `None`.
  156: 
  157:     >>> split_provision('mypkg')
  158:     ('mypkg', None)
  159:     >>> split_provision(' mypkg( 1.2 ) ')
  160:     ('mypkg', StrictVersion ('1.2'))
  161:     """
  162:     global _provision_rx
  163:     if _provision_rx is None:
  164:         _provision_rx = re.compile(
  165:             r"([a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*)(?:\s*\(\s*([^)\s]+)\s*\))?$", re.ASCII
  166:         )
  167:     value = value.strip()
  168:     m = _provision_rx.match(value)
  169:     if not m:
  170:         raise ValueError("illegal provides specification: %r" % value)
  171:     ver = m.group(2) or None
  172:     if ver:
  173:         with distutils.version.suppress_known_deprecation():
  174:             ver = distutils.version.StrictVersion(ver)
  175:     return m.group(1), ver
