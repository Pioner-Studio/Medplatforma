    1: """distutils.command.register
    2: 
    3: Implements the Distutils 'register' command (register with the repository).
    4: """
    5: 
    6: # created 2002/10/21, Richard Jones
    7: 
    8: import getpass
    9: import io
   10: import urllib.parse
   11: import urllib.request
   12: from warnings import warn
   13: 
   14: from distutils.core import PyPIRCCommand
   15: from distutils import log
   16: 
   17: 
   18: class register(PyPIRCCommand):
   19: 
   20:     description = "register the distribution with the Python package index"
   21:     user_options = PyPIRCCommand.user_options + [
   22:         ('list-classifiers', None, 'list the valid Trove classifiers'),
   23:         (
   24:             'strict',
   25:             None,
   26:             'Will stop the registering if the meta-data are not fully compliant',
   27:         ),
   28:     ]
   29:     boolean_options = PyPIRCCommand.boolean_options + [
   30:         'verify',
   31:         'list-classifiers',
   32:         'strict',
   33:     ]
   34: 
   35:     sub_commands = [('check', lambda self: True)]
   36: 
   37:     def initialize_options(self):
   38:         PyPIRCCommand.initialize_options(self)
   39:         self.list_classifiers = 0
   40:         self.strict = 0
   41: 
   42:     def finalize_options(self):
   43:         PyPIRCCommand.finalize_options(self)
   44:         # setting options for the `check` subcommand
   45:         check_options = {
   46:             'strict': ('register', self.strict),
   47:             'restructuredtext': ('register', 1),
   48:         }
   49:         self.distribution.command_options['check'] = check_options
   50: 
   51:     def run(self):
   52:         self.finalize_options()
   53:         self._set_config()
   54: 
   55:         # Run sub commands
   56:         for cmd_name in self.get_sub_commands():
   57:             self.run_command(cmd_name)
   58: 
   59:         if self.dry_run:
   60:             self.verify_metadata()
   61:         elif self.list_classifiers:
   62:             self.classifiers()
   63:         else:
   64:             self.send_metadata()
   65: 
   66:     def check_metadata(self):
   67:         """Deprecated API."""
   68:         warn(
   69:             "distutils.command.register.check_metadata is deprecated; "
   70:             "use the check command instead",
   71:             DeprecationWarning,
   72:         )
   73:         check = self.distribution.get_command_obj('check')
   74:         check.ensure_finalized()
   75:         check.strict = self.strict
   76:         check.restructuredtext = 1
   77:         check.run()
   78: 
   79:     def _set_config(self):
   80:         '''Reads the configuration file and set attributes.'''
   81:         config = self._read_pypirc()
   82:         if config != {}:
   83:             self.username = config['username']
   84:             self.password = config['password']
   85:             self.repository = config['repository']
   86:             self.realm = config['realm']
   87:             self.has_config = True
   88:         else:
   89:             if self.repository not in ('pypi', self.DEFAULT_REPOSITORY):
   90:                 raise ValueError('%s not found in .pypirc' % self.repository)
   91:             if self.repository == 'pypi':
   92:                 self.repository = self.DEFAULT_REPOSITORY
   93:             self.has_config = False
   94: 
   95:     def classifiers(self):
   96:         '''Fetch the list of classifiers from the server.'''
   97:         url = self.repository + '?:action=list_classifiers'
   98:         response = urllib.request.urlopen(url)
   99:         log.info(self._read_pypi_response(response))
  100: 
  101:     def verify_metadata(self):
  102:         '''Send the metadata to the package index server to be checked.'''
  103:         # send the info to the server and report the result
  104:         (code, result) = self.post_to_server(self.build_post_data('verify'))
  105:         log.info('Server response (%s): %s', code, result)
  106: 
  107:     def send_metadata(self):  # noqa: C901
  108:         '''Send the metadata to the package index server.
  109: 
  110:         Well, do the following:
  111:         1. figure who the user is, and then
  112:         2. send the data as a Basic auth'ed POST.
  113: 
  114:         First we try to read the username/password from $HOME/.pypirc,
  115:         which is a ConfigParser-formatted file with a section
  116:         [distutils] containing username and password entries (both
  117:         in clear text). Eg:
  118: 
  119:             [distutils]
  120:             index-servers =
  121:                 pypi
  122: 
  123:             [pypi]
  124:             username: fred
  125:             password: sekrit
  126: 
  127:         Otherwise, to figure who the user is, we offer the user three
  128:         choices:
  129: 
  130:          1. use existing login,
  131:          2. register as a new user, or
  132:          3. set the password to a random string and email the user.
  133: 
  134:         '''
  135:         # see if we can short-cut and get the username/password from the
  136:         # config
  137:         if self.has_config:
  138:             choice = '1'
  139:             username = self.username
  140:             password = self.password
  141:         else:
  142:             choice = 'x'
  143:             username = password = ''
  144: 
  145:         # get the user's login info
  146:         choices = '1 2 3 4'.split()
  147:         while choice not in choices:
  148:             self.announce(
  149:                 '''\
  150: We need to know who you are, so please choose either:
  151:  1. use your existing login,
  152:  2. register as a new user,
  153:  3. have the server generate a new password for you (and email it to you), or
  154:  4. quit
  155: Your selection [default 1]: ''',
  156:                 log.INFO,
  157:             )
  158:             choice = input()
  159:             if not choice:
  160:                 choice = '1'
  161:             elif choice not in choices:
  162:                 print('Please choose one of the four options!')
  163: 
  164:         if choice == '1':
  165:             # get the username and password
  166:             while not username:
  167:                 username = input('Username: ')
  168:             while not password:
  169:                 password = getpass.getpass('Password: ')
  170: 
  171:             # set up the authentication
  172:             auth = urllib.request.HTTPPasswordMgr()
  173:             host = urllib.parse.urlparse(self.repository)[1]
  174:             auth.add_password(self.realm, host, username, password)
  175:             # send the info to the server and report the result
  176:             code, result = self.post_to_server(self.build_post_data('submit'), auth)
  177:             self.announce('Server response ({}): {}'.format(code, result), log.INFO)
  178: 
  179:             # possibly save the login
  180:             if code == 200:
  181:                 if self.has_config:
  182:                     # sharing the password in the distribution instance
  183:                     # so the upload command can reuse it
  184:                     self.distribution.password = password
  185:                 else:
  186:                     self.announce(
  187:                         (
  188:                             'I can store your PyPI login so future '
  189:                             'submissions will be faster.'
  190:                         ),
  191:                         log.INFO,
  192:                     )
  193:                     self.announce(
  194:                         '(the login will be stored in %s)' % self._get_rc_file(),
  195:                         log.INFO,
  196:                     )
  197:                     choice = 'X'
  198:                     while choice.lower() not in 'yn':
  199:                         choice = input('Save your login (y/N)?')
  200:                         if not choice:
  201:                             choice = 'n'
  202:                     if choice.lower() == 'y':
  203:                         self._store_pypirc(username, password)
  204: 
  205:         elif choice == '2':
  206:             data = {':action': 'user'}
  207:             data['name'] = data['password'] = data['email'] = ''
  208:             data['confirm'] = None
  209:             while not data['name']:
  210:                 data['name'] = input('Username: ')
  211:             while data['password'] != data['confirm']:
  212:                 while not data['password']:
  213:                     data['password'] = getpass.getpass('Password: ')
  214:                 while not data['confirm']:
  215:                     data['confirm'] = getpass.getpass(' Confirm: ')
  216:                 if data['password'] != data['confirm']:
  217:                     data['password'] = ''
  218:                     data['confirm'] = None
  219:                     print("Password and confirm don't match!")
  220:             while not data['email']:
  221:                 data['email'] = input('   EMail: ')
  222:             code, result = self.post_to_server(data)
  223:             if code != 200:
  224:                 log.info('Server response (%s): %s', code, result)
  225:             else:
  226:                 log.info('You will receive an email shortly.')
  227:                 log.info('Follow the instructions in it to ' 'complete registration.')
  228:         elif choice == '3':
  229:             data = {':action': 'password_reset'}
  230:             data['email'] = ''
  231:             while not data['email']:
  232:                 data['email'] = input('Your email address: ')
  233:             code, result = self.post_to_server(data)
  234:             log.info('Server response (%s): %s', code, result)
  235: 
  236:     def build_post_data(self, action):
  237:         # figure the data to send - the metadata plus some additional
  238:         # information used by the package server
  239:         meta = self.distribution.metadata
  240:         data = {
  241:             ':action': action,
  242:             'metadata_version': '1.0',
  243:             'name': meta.get_name(),
  244:             'version': meta.get_version(),
  245:             'summary': meta.get_description(),
  246:             'home_page': meta.get_url(),
  247:             'author': meta.get_contact(),
  248:             'author_email': meta.get_contact_email(),
  249:             'license': meta.get_licence(),
  250:             'description': meta.get_long_description(),
  251:             'keywords': meta.get_keywords(),
  252:             'platform': meta.get_platforms(),
  253:             'classifiers': meta.get_classifiers(),
  254:             'download_url': meta.get_download_url(),
  255:             # PEP 314
  256:             'provides': meta.get_provides(),
  257:             'requires': meta.get_requires(),
  258:             'obsoletes': meta.get_obsoletes(),
  259:         }
  260:         if data['provides'] or data['requires'] or data['obsoletes']:
  261:             data['metadata_version'] = '1.1'
  262:         return data
  263: 
  264:     def post_to_server(self, data, auth=None):  # noqa: C901
  265:         '''Post a query to the server, and return a string response.'''
  266:         if 'name' in data:
  267:             self.announce(
  268:                 'Registering {} to {}'.format(data['name'], self.repository), log.INFO
  269:             )
  270:         # Build up the MIME payload for the urllib2 POST data
  271:         boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'
  272:         sep_boundary = '\n--' + boundary
  273:         end_boundary = sep_boundary + '--'
  274:         body = io.StringIO()
  275:         for key, value in data.items():
  276:             # handle multiple entries for the same name
  277:             if type(value) not in (type([]), type(())):
  278:                 value = [value]
  279:             for value in value:
  280:                 value = str(value)
  281:                 body.write(sep_boundary)
  282:                 body.write('\nContent-Disposition: form-data; name="%s"' % key)
  283:                 body.write("\n\n")
  284:                 body.write(value)
  285:                 if value and value[-1] == '\r':
  286:                     body.write('\n')  # write an extra newline (lurve Macs)
  287:         body.write(end_boundary)
  288:         body.write("\n")
  289:         body = body.getvalue().encode("utf-8")
  290: 
  291:         # build the Request
  292:         headers = {
  293:             'Content-type': 'multipart/form-data; boundary=%s; charset=utf-8'
  294:             % boundary,
  295:             'Content-length': str(len(body)),
  296:         }
  297:         req = urllib.request.Request(self.repository, body, headers)
  298: 
  299:         # handle HTTP and include the Basic Auth handler
  300:         opener = urllib.request.build_opener(
  301:             urllib.request.HTTPBasicAuthHandler(password_mgr=auth)
  302:         )
  303:         data = ''
  304:         try:
  305:             result = opener.open(req)
  306:         except urllib.error.HTTPError as e:
  307:             if self.show_response:
  308:                 data = e.fp.read()
  309:             result = e.code, e.msg
  310:         except urllib.error.URLError as e:
  311:             result = 500, str(e)
  312:         else:
  313:             if self.show_response:
  314:                 data = self._read_pypi_response(result)
  315:             result = 200, 'OK'
  316:         if self.show_response:
  317:             msg = '\n'.join(('-' * 75, data, '-' * 75))
  318:             self.announce(msg, log.INFO)
  319:         return result
