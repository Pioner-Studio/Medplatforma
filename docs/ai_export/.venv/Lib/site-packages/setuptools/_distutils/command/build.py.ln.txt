    1: """distutils.command.build
    2: 
    3: Implements the Distutils 'build' command."""
    4: 
    5: import sys
    6: import os
    7: from distutils.core import Command
    8: from distutils.errors import DistutilsOptionError
    9: from distutils.util import get_platform
   10: 
   11: 
   12: def show_compilers():
   13:     from distutils.ccompiler import show_compilers
   14: 
   15:     show_compilers()
   16: 
   17: 
   18: class build(Command):
   19: 
   20:     description = "build everything needed to install"
   21: 
   22:     user_options = [
   23:         ('build-base=', 'b', "base directory for build library"),
   24:         ('build-purelib=', None, "build directory for platform-neutral distributions"),
   25:         ('build-platlib=', None, "build directory for platform-specific distributions"),
   26:         (
   27:             'build-lib=',
   28:             None,
   29:             "build directory for all distribution (defaults to either "
   30:             + "build-purelib or build-platlib",
   31:         ),
   32:         ('build-scripts=', None, "build directory for scripts"),
   33:         ('build-temp=', 't', "temporary build directory"),
   34:         (
   35:             'plat-name=',
   36:             'p',
   37:             "platform name to build for, if supported "
   38:             "(default: %s)" % get_platform(),
   39:         ),
   40:         ('compiler=', 'c', "specify the compiler type"),
   41:         ('parallel=', 'j', "number of parallel build jobs"),
   42:         ('debug', 'g', "compile extensions and libraries with debugging information"),
   43:         ('force', 'f', "forcibly build everything (ignore file timestamps)"),
   44:         ('executable=', 'e', "specify final destination interpreter path (build.py)"),
   45:     ]
   46: 
   47:     boolean_options = ['debug', 'force']
   48: 
   49:     help_options = [
   50:         ('help-compiler', None, "list available compilers", show_compilers),
   51:     ]
   52: 
   53:     def initialize_options(self):
   54:         self.build_base = 'build'
   55:         # these are decided only after 'build_base' has its final value
   56:         # (unless overridden by the user or client)
   57:         self.build_purelib = None
   58:         self.build_platlib = None
   59:         self.build_lib = None
   60:         self.build_temp = None
   61:         self.build_scripts = None
   62:         self.compiler = None
   63:         self.plat_name = None
   64:         self.debug = None
   65:         self.force = 0
   66:         self.executable = None
   67:         self.parallel = None
   68: 
   69:     def finalize_options(self):  # noqa: C901
   70:         if self.plat_name is None:
   71:             self.plat_name = get_platform()
   72:         else:
   73:             # plat-name only supported for windows (other platforms are
   74:             # supported via ./configure flags, if at all).  Avoid misleading
   75:             # other platforms.
   76:             if os.name != 'nt':
   77:                 raise DistutilsOptionError(
   78:                     "--plat-name only supported on Windows (try "
   79:                     "using './configure --help' on your platform)"
   80:                 )
   81: 
   82:         plat_specifier = ".{}-{}".format(self.plat_name, sys.implementation.cache_tag)
   83: 
   84:         # Make it so Python 2.x and Python 2.x with --with-pydebug don't
   85:         # share the same build directories. Doing so confuses the build
   86:         # process for C modules
   87:         if hasattr(sys, 'gettotalrefcount'):
   88:             plat_specifier += '-pydebug'
   89: 
   90:         # 'build_purelib' and 'build_platlib' just default to 'lib' and
   91:         # 'lib.<plat>' under the base build directory.  We only use one of
   92:         # them for a given distribution, though --
   93:         if self.build_purelib is None:
   94:             self.build_purelib = os.path.join(self.build_base, 'lib')
   95:         if self.build_platlib is None:
   96:             self.build_platlib = os.path.join(self.build_base, 'lib' + plat_specifier)
   97: 
   98:         # 'build_lib' is the actual directory that we will use for this
   99:         # particular module distribution -- if user didn't supply it, pick
  100:         # one of 'build_purelib' or 'build_platlib'.
  101:         if self.build_lib is None:
  102:             if self.distribution.has_ext_modules():
  103:                 self.build_lib = self.build_platlib
  104:             else:
  105:                 self.build_lib = self.build_purelib
  106: 
  107:         # 'build_temp' -- temporary directory for compiler turds,
  108:         # "build/temp.<plat>"
  109:         if self.build_temp is None:
  110:             self.build_temp = os.path.join(self.build_base, 'temp' + plat_specifier)
  111:         if self.build_scripts is None:
  112:             self.build_scripts = os.path.join(
  113:                 self.build_base, 'scripts-%d.%d' % sys.version_info[:2]
  114:             )
  115: 
  116:         if self.executable is None and sys.executable:
  117:             self.executable = os.path.normpath(sys.executable)
  118: 
  119:         if isinstance(self.parallel, str):
  120:             try:
  121:                 self.parallel = int(self.parallel)
  122:             except ValueError:
  123:                 raise DistutilsOptionError("parallel should be an integer")
  124: 
  125:     def run(self):
  126:         # Run all relevant sub-commands.  This will be some subset of:
  127:         #  - build_py      - pure Python modules
  128:         #  - build_clib    - standalone C libraries
  129:         #  - build_ext     - Python extensions
  130:         #  - build_scripts - (Python) scripts
  131:         for cmd_name in self.get_sub_commands():
  132:             self.run_command(cmd_name)
  133: 
  134:     # -- Predicates for the sub-command list ---------------------------
  135: 
  136:     def has_pure_modules(self):
  137:         return self.distribution.has_pure_modules()
  138: 
  139:     def has_c_libraries(self):
  140:         return self.distribution.has_c_libraries()
  141: 
  142:     def has_ext_modules(self):
  143:         return self.distribution.has_ext_modules()
  144: 
  145:     def has_scripts(self):
  146:         return self.distribution.has_scripts()
  147: 
  148:     sub_commands = [
  149:         ('build_py', has_pure_modules),
  150:         ('build_clib', has_c_libraries),
  151:         ('build_ext', has_ext_modules),
  152:         ('build_scripts', has_scripts),
  153:     ]
