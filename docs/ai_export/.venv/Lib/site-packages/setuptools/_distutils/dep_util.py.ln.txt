    1: """distutils.dep_util
    2: 
    3: Utility functions for simple, timestamp-based dependency of files
    4: and groups of files; also, function based entirely on such
    5: timestamp dependency analysis."""
    6: 
    7: import os
    8: from distutils.errors import DistutilsFileError
    9: 
   10: 
   11: def newer(source, target):
   12:     """Return true if 'source' exists and is more recently modified than
   13:     'target', or if 'source' exists and 'target' doesn't.  Return false if
   14:     both exist and 'target' is the same age or younger than 'source'.
   15:     Raise DistutilsFileError if 'source' does not exist.
   16:     """
   17:     if not os.path.exists(source):
   18:         raise DistutilsFileError("file '%s' does not exist" % os.path.abspath(source))
   19:     if not os.path.exists(target):
   20:         return 1
   21: 
   22:     from stat import ST_MTIME
   23: 
   24:     mtime1 = os.stat(source)[ST_MTIME]
   25:     mtime2 = os.stat(target)[ST_MTIME]
   26: 
   27:     return mtime1 > mtime2
   28: 
   29: 
   30: # newer ()
   31: 
   32: 
   33: def newer_pairwise(sources, targets):
   34:     """Walk two filename lists in parallel, testing if each source is newer
   35:     than its corresponding target.  Return a pair of lists (sources,
   36:     targets) where source is newer than target, according to the semantics
   37:     of 'newer()'.
   38:     """
   39:     if len(sources) != len(targets):
   40:         raise ValueError("'sources' and 'targets' must be same length")
   41: 
   42:     # build a pair of lists (sources, targets) where  source is newer
   43:     n_sources = []
   44:     n_targets = []
   45:     for i in range(len(sources)):
   46:         if newer(sources[i], targets[i]):
   47:             n_sources.append(sources[i])
   48:             n_targets.append(targets[i])
   49: 
   50:     return (n_sources, n_targets)
   51: 
   52: 
   53: # newer_pairwise ()
   54: 
   55: 
   56: def newer_group(sources, target, missing='error'):
   57:     """Return true if 'target' is out-of-date with respect to any file
   58:     listed in 'sources'.  In other words, if 'target' exists and is newer
   59:     than every file in 'sources', return false; otherwise return true.
   60:     'missing' controls what we do when a source file is missing; the
   61:     default ("error") is to blow up with an OSError from inside 'stat()';
   62:     if it is "ignore", we silently drop any missing source files; if it is
   63:     "newer", any missing source files make us assume that 'target' is
   64:     out-of-date (this is handy in "dry-run" mode: it'll make you pretend to
   65:     carry out commands that wouldn't work because inputs are missing, but
   66:     that doesn't matter because you're not actually going to run the
   67:     commands).
   68:     """
   69:     # If the target doesn't even exist, then it's definitely out-of-date.
   70:     if not os.path.exists(target):
   71:         return 1
   72: 
   73:     # Otherwise we have to find out the hard way: if *any* source file
   74:     # is more recent than 'target', then 'target' is out-of-date and
   75:     # we can immediately return true.  If we fall through to the end
   76:     # of the loop, then 'target' is up-to-date and we return false.
   77:     from stat import ST_MTIME
   78: 
   79:     target_mtime = os.stat(target)[ST_MTIME]
   80:     for source in sources:
   81:         if not os.path.exists(source):
   82:             if missing == 'error':  # blow up when we stat() the file
   83:                 pass
   84:             elif missing == 'ignore':  # missing source dropped from
   85:                 continue  # target's dependency list
   86:             elif missing == 'newer':  # missing source means target is
   87:                 return 1  # out-of-date
   88: 
   89:         source_mtime = os.stat(source)[ST_MTIME]
   90:         if source_mtime > target_mtime:
   91:             return 1
   92:     else:
   93:         return 0
   94: 
   95: 
   96: # newer_group ()
