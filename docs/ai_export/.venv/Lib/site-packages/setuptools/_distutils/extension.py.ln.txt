    1: """distutils.extension
    2: 
    3: Provides the Extension class, used to describe C/C++ extension
    4: modules in setup scripts."""
    5: 
    6: import os
    7: import warnings
    8: 
    9: # This class is really only used by the "build_ext" command, so it might
   10: # make sense to put it in distutils.command.build_ext.  However, that
   11: # module is already big enough, and I want to make this class a bit more
   12: # complex to simplify some common cases ("foo" module in "foo.c") and do
   13: # better error-checking ("foo.c" actually exists).
   14: #
   15: # Also, putting this in build_ext.py means every setup script would have to
   16: # import that large-ish module (indirectly, through distutils.core) in
   17: # order to do anything.
   18: 
   19: 
   20: class Extension:
   21:     """Just a collection of attributes that describes an extension
   22:     module and everything needed to build it (hopefully in a portable
   23:     way, but there are hooks that let you be as unportable as you need).
   24: 
   25:     Instance attributes:
   26:       name : string
   27:         the full name of the extension, including any packages -- ie.
   28:         *not* a filename or pathname, but Python dotted name
   29:       sources : [string]
   30:         list of source filenames, relative to the distribution root
   31:         (where the setup script lives), in Unix form (slash-separated)
   32:         for portability.  Source files may be C, C++, SWIG (.i),
   33:         platform-specific resource files, or whatever else is recognized
   34:         by the "build_ext" command as source for a Python extension.
   35:       include_dirs : [string]
   36:         list of directories to search for C/C++ header files (in Unix
   37:         form for portability)
   38:       define_macros : [(name : string, value : string|None)]
   39:         list of macros to define; each macro is defined using a 2-tuple,
   40:         where 'value' is either the string to define it to or None to
   41:         define it without a particular value (equivalent of "#define
   42:         FOO" in source or -DFOO on Unix C compiler command line)
   43:       undef_macros : [string]
   44:         list of macros to undefine explicitly
   45:       library_dirs : [string]
   46:         list of directories to search for C/C++ libraries at link time
   47:       libraries : [string]
   48:         list of library names (not filenames or paths) to link against
   49:       runtime_library_dirs : [string]
   50:         list of directories to search for C/C++ libraries at run time
   51:         (for shared extensions, this is when the extension is loaded)
   52:       extra_objects : [string]
   53:         list of extra files to link with (eg. object files not implied
   54:         by 'sources', static library that must be explicitly specified,
   55:         binary resource files, etc.)
   56:       extra_compile_args : [string]
   57:         any extra platform- and compiler-specific information to use
   58:         when compiling the source files in 'sources'.  For platforms and
   59:         compilers where "command line" makes sense, this is typically a
   60:         list of command-line arguments, but for other platforms it could
   61:         be anything.
   62:       extra_link_args : [string]
   63:         any extra platform- and compiler-specific information to use
   64:         when linking object files together to create the extension (or
   65:         to create a new static Python interpreter).  Similar
   66:         interpretation as for 'extra_compile_args'.
   67:       export_symbols : [string]
   68:         list of symbols to be exported from a shared extension.  Not
   69:         used on all platforms, and not generally necessary for Python
   70:         extensions, which typically export exactly one symbol: "init" +
   71:         extension_name.
   72:       swig_opts : [string]
   73:         any extra options to pass to SWIG if a source file has the .i
   74:         extension.
   75:       depends : [string]
   76:         list of files that the extension depends on
   77:       language : string
   78:         extension language (i.e. "c", "c++", "objc"). Will be detected
   79:         from the source extensions if not provided.
   80:       optional : boolean
   81:         specifies that a build failure in the extension should not abort the
   82:         build process, but simply not install the failing extension.
   83:     """
   84: 
   85:     # When adding arguments to this constructor, be sure to update
   86:     # setup_keywords in core.py.
   87:     def __init__(
   88:         self,
   89:         name,
   90:         sources,
   91:         include_dirs=None,
   92:         define_macros=None,
   93:         undef_macros=None,
   94:         library_dirs=None,
   95:         libraries=None,
   96:         runtime_library_dirs=None,
   97:         extra_objects=None,
   98:         extra_compile_args=None,
   99:         extra_link_args=None,
  100:         export_symbols=None,
  101:         swig_opts=None,
  102:         depends=None,
  103:         language=None,
  104:         optional=None,
  105:         **kw  # To catch unknown keywords
  106:     ):
  107:         if not isinstance(name, str):
  108:             raise AssertionError("'name' must be a string")
  109:         if not (isinstance(sources, list) and all(isinstance(v, str) for v in sources)):
  110:             raise AssertionError("'sources' must be a list of strings")
  111: 
  112:         self.name = name
  113:         self.sources = sources
  114:         self.include_dirs = include_dirs or []
  115:         self.define_macros = define_macros or []
  116:         self.undef_macros = undef_macros or []
  117:         self.library_dirs = library_dirs or []
  118:         self.libraries = libraries or []
  119:         self.runtime_library_dirs = runtime_library_dirs or []
  120:         self.extra_objects = extra_objects or []
  121:         self.extra_compile_args = extra_compile_args or []
  122:         self.extra_link_args = extra_link_args or []
  123:         self.export_symbols = export_symbols or []
  124:         self.swig_opts = swig_opts or []
  125:         self.depends = depends or []
  126:         self.language = language
  127:         self.optional = optional
  128: 
  129:         # If there are unknown keyword options, warn about them
  130:         if len(kw) > 0:
  131:             options = [repr(option) for option in kw]
  132:             options = ', '.join(sorted(options))
  133:             msg = "Unknown Extension options: %s" % options
  134:             warnings.warn(msg)
  135: 
  136:     def __repr__(self):
  137:         return '<{}.{}({!r}) at {:#x}>'.format(
  138:             self.__class__.__module__,
  139:             self.__class__.__qualname__,
  140:             self.name,
  141:             id(self),
  142:         )
  143: 
  144: 
  145: def read_setup_file(filename):  # noqa: C901
  146:     """Reads a Setup file and returns Extension instances."""
  147:     from distutils.sysconfig import parse_makefile, expand_makefile_vars, _variable_rx
  148: 
  149:     from distutils.text_file import TextFile
  150:     from distutils.util import split_quoted
  151: 
  152:     # First pass over the file to gather "VAR = VALUE" assignments.
  153:     vars = parse_makefile(filename)
  154: 
  155:     # Second pass to gobble up the real content: lines of the form
  156:     #   <module> ... [<sourcefile> ...] [<cpparg> ...] [<library> ...]
  157:     file = TextFile(
  158:         filename,
  159:         strip_comments=1,
  160:         skip_blanks=1,
  161:         join_lines=1,
  162:         lstrip_ws=1,
  163:         rstrip_ws=1,
  164:     )
  165:     try:
  166:         extensions = []
  167: 
  168:         while True:
  169:             line = file.readline()
  170:             if line is None:  # eof
  171:                 break
  172:             if _variable_rx.match(line):  # VAR=VALUE, handled in first pass
  173:                 continue
  174: 
  175:             if line[0] == line[-1] == "*":
  176:                 file.warn("'%s' lines not handled yet" % line)
  177:                 continue
  178: 
  179:             line = expand_makefile_vars(line, vars)
  180:             words = split_quoted(line)
  181: 
  182:             # NB. this parses a slightly different syntax than the old
  183:             # makesetup script: here, there must be exactly one extension per
  184:             # line, and it must be the first word of the line.  I have no idea
  185:             # why the old syntax supported multiple extensions per line, as
  186:             # they all wind up being the same.
  187: 
  188:             module = words[0]
  189:             ext = Extension(module, [])
  190:             append_next_word = None
  191: 
  192:             for word in words[1:]:
  193:                 if append_next_word is not None:
  194:                     append_next_word.append(word)
  195:                     append_next_word = None
  196:                     continue
  197: 
  198:                 suffix = os.path.splitext(word)[1]
  199:                 switch = word[0:2]
  200:                 value = word[2:]
  201: 
  202:                 if suffix in (".c", ".cc", ".cpp", ".cxx", ".c++", ".m", ".mm"):
  203:                     # hmm, should we do something about C vs. C++ sources?
  204:                     # or leave it up to the CCompiler implementation to
  205:                     # worry about?
  206:                     ext.sources.append(word)
  207:                 elif switch == "-I":
  208:                     ext.include_dirs.append(value)
  209:                 elif switch == "-D":
  210:                     equals = value.find("=")
  211:                     if equals == -1:  # bare "-DFOO" -- no value
  212:                         ext.define_macros.append((value, None))
  213:                     else:  # "-DFOO=blah"
  214:                         ext.define_macros.append((value[0:equals], value[equals + 2 :]))
  215:                 elif switch == "-U":
  216:                     ext.undef_macros.append(value)
  217:                 elif switch == "-C":  # only here 'cause makesetup has it!
  218:                     ext.extra_compile_args.append(word)
  219:                 elif switch == "-l":
  220:                     ext.libraries.append(value)
  221:                 elif switch == "-L":
  222:                     ext.library_dirs.append(value)
  223:                 elif switch == "-R":
  224:                     ext.runtime_library_dirs.append(value)
  225:                 elif word == "-rpath":
  226:                     append_next_word = ext.runtime_library_dirs
  227:                 elif word == "-Xlinker":
  228:                     append_next_word = ext.extra_link_args
  229:                 elif word == "-Xcompiler":
  230:                     append_next_word = ext.extra_compile_args
  231:                 elif switch == "-u":
  232:                     ext.extra_link_args.append(word)
  233:                     if not value:
  234:                         append_next_word = ext.extra_link_args
  235:                 elif suffix in (".a", ".so", ".sl", ".o", ".dylib"):
  236:                     # NB. a really faithful emulation of makesetup would
  237:                     # append a .o file to extra_objects only if it
  238:                     # had a slash in it; otherwise, it would s/.o/.c/
  239:                     # and append it to sources.  Hmmmm.
  240:                     ext.extra_objects.append(word)
  241:                 else:
  242:                     file.warn("unrecognized argument '%s'" % word)
  243: 
  244:             extensions.append(ext)
  245:     finally:
  246:         file.close()
  247: 
  248:     return extensions
