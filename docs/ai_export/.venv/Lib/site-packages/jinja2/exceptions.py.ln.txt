    1: import typing as t
    2: 
    3: if t.TYPE_CHECKING:
    4:     from .runtime import Undefined
    5: 
    6: 
    7: class TemplateError(Exception):
    8:     """Baseclass for all template errors."""
    9: 
   10:     def __init__(self, message: t.Optional[str] = None) -> None:
   11:         super().__init__(message)
   12: 
   13:     @property
   14:     def message(self) -> t.Optional[str]:
   15:         return self.args[0] if self.args else None
   16: 
   17: 
   18: class TemplateNotFound(IOError, LookupError, TemplateError):
   19:     """Raised if a template does not exist.
   20: 
   21:     .. versionchanged:: 2.11
   22:         If the given name is :class:`Undefined` and no message was
   23:         provided, an :exc:`UndefinedError` is raised.
   24:     """
   25: 
   26:     # Silence the Python warning about message being deprecated since
   27:     # it's not valid here.
   28:     message: t.Optional[str] = None
   29: 
   30:     def __init__(
   31:         self,
   32:         name: t.Optional[t.Union[str, "Undefined"]],
   33:         message: t.Optional[str] = None,
   34:     ) -> None:
   35:         IOError.__init__(self, name)
   36: 
   37:         if message is None:
   38:             from .runtime import Undefined
   39: 
   40:             if isinstance(name, Undefined):
   41:                 name._fail_with_undefined_error()
   42: 
   43:             message = name
   44: 
   45:         self.message = message
   46:         self.name = name
   47:         self.templates = [name]
   48: 
   49:     def __str__(self) -> str:
   50:         return str(self.message)
   51: 
   52: 
   53: class TemplatesNotFound(TemplateNotFound):
   54:     """Like :class:`TemplateNotFound` but raised if multiple templates
   55:     are selected.  This is a subclass of :class:`TemplateNotFound`
   56:     exception, so just catching the base exception will catch both.
   57: 
   58:     .. versionchanged:: 2.11
   59:         If a name in the list of names is :class:`Undefined`, a message
   60:         about it being undefined is shown rather than the empty string.
   61: 
   62:     .. versionadded:: 2.2
   63:     """
   64: 
   65:     def __init__(
   66:         self,
   67:         names: t.Sequence[t.Union[str, "Undefined"]] = (),
   68:         message: t.Optional[str] = None,
   69:     ) -> None:
   70:         if message is None:
   71:             from .runtime import Undefined
   72: 
   73:             parts = []
   74: 
   75:             for name in names:
   76:                 if isinstance(name, Undefined):
   77:                     parts.append(name._undefined_message)
   78:                 else:
   79:                     parts.append(name)
   80: 
   81:             parts_str = ", ".join(map(str, parts))
   82:             message = f"none of the templates given were found: {parts_str}"
   83: 
   84:         super().__init__(names[-1] if names else None, message)
   85:         self.templates = list(names)
   86: 
   87: 
   88: class TemplateSyntaxError(TemplateError):
   89:     """Raised to tell the user that there is a problem with the template."""
   90: 
   91:     def __init__(
   92:         self,
   93:         message: str,
   94:         lineno: int,
   95:         name: t.Optional[str] = None,
   96:         filename: t.Optional[str] = None,
   97:     ) -> None:
   98:         super().__init__(message)
   99:         self.lineno = lineno
  100:         self.name = name
  101:         self.filename = filename
  102:         self.source: t.Optional[str] = None
  103: 
  104:         # this is set to True if the debug.translate_syntax_error
  105:         # function translated the syntax error into a new traceback
  106:         self.translated = False
  107: 
  108:     def __str__(self) -> str:
  109:         # for translated errors we only return the message
  110:         if self.translated:
  111:             return t.cast(str, self.message)
  112: 
  113:         # otherwise attach some stuff
  114:         location = f"line {self.lineno}"
  115:         name = self.filename or self.name
  116:         if name:
  117:             location = f'File "{name}", {location}'
  118:         lines = [t.cast(str, self.message), "  " + location]
  119: 
  120:         # if the source is set, add the line to the output
  121:         if self.source is not None:
  122:             try:
  123:                 line = self.source.splitlines()[self.lineno - 1]
  124:             except IndexError:
  125:                 pass
  126:             else:
  127:                 lines.append("    " + line.strip())
  128: 
  129:         return "\n".join(lines)
  130: 
  131:     def __reduce__(self):  # type: ignore
  132:         # https://bugs.python.org/issue1692335 Exceptions that take
  133:         # multiple required arguments have problems with pickling.
  134:         # Without this, raises TypeError: __init__() missing 1 required
  135:         # positional argument: 'lineno'
  136:         return self.__class__, (self.message, self.lineno, self.name, self.filename)
  137: 
  138: 
  139: class TemplateAssertionError(TemplateSyntaxError):
  140:     """Like a template syntax error, but covers cases where something in the
  141:     template caused an error at compile time that wasn't necessarily caused
  142:     by a syntax error.  However it's a direct subclass of
  143:     :exc:`TemplateSyntaxError` and has the same attributes.
  144:     """
  145: 
  146: 
  147: class TemplateRuntimeError(TemplateError):
  148:     """A generic runtime error in the template engine.  Under some situations
  149:     Jinja may raise this exception.
  150:     """
  151: 
  152: 
  153: class UndefinedError(TemplateRuntimeError):
  154:     """Raised if a template tries to operate on :class:`Undefined`."""
  155: 
  156: 
  157: class SecurityError(TemplateRuntimeError):
  158:     """Raised if a template tries to do something insecure if the
  159:     sandbox is enabled.
  160:     """
  161: 
  162: 
  163: class FilterArgumentError(TemplateRuntimeError):
  164:     """This error is raised if a filter was called with inappropriate
  165:     arguments
  166:     """
