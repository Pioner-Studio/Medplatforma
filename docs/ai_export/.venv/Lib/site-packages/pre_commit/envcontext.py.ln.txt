    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import enum
    5: import os
    6: from collections.abc import Generator
    7: from collections.abc import MutableMapping
    8: from typing import NamedTuple
    9: from typing import Union
   10: 
   11: _Unset = enum.Enum('_Unset', 'UNSET')
   12: UNSET = _Unset.UNSET
   13: 
   14: 
   15: class Var(NamedTuple):
   16:     name: str
   17:     default: str = ''
   18: 
   19: 
   20: SubstitutionT = tuple[Union[str, Var], ...]
   21: ValueT = Union[str, _Unset, SubstitutionT]
   22: PatchesT = tuple[tuple[str, ValueT], ...]
   23: 
   24: 
   25: def format_env(parts: SubstitutionT, env: MutableMapping[str, str]) -> str:
   26:     return ''.join(
   27:         env.get(part.name, part.default) if isinstance(part, Var) else part
   28:         for part in parts
   29:     )
   30: 
   31: 
   32: @contextlib.contextmanager
   33: def envcontext(
   34:         patch: PatchesT,
   35:         _env: MutableMapping[str, str] | None = None,
   36: ) -> Generator[None]:
   37:     """In this context, `os.environ` is modified according to `patch`.
   38: 
   39:     `patch` is an iterable of 2-tuples (key, value):
   40:         `key`: string
   41:         `value`:
   42:             - string: `environ[key] == value` inside the context.
   43:             - UNSET: `key not in environ` inside the context.
   44:             - template: A template is a tuple of strings and Var which will be
   45:               replaced with the previous environment
   46:     """
   47:     env = os.environ if _env is None else _env
   48:     before = dict(env)
   49: 
   50:     for k, v in patch:
   51:         if v is UNSET:
   52:             env.pop(k, None)
   53:         elif isinstance(v, tuple):
   54:             env[k] = format_env(v, before)
   55:         else:
   56:             env[k] = v
   57: 
   58:     try:
   59:         yield
   60:     finally:
   61:         env.clear()
   62:         env.update(before)
