    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import functools
    5: import os.path
    6: import sys
    7: import traceback
    8: from collections.abc import Generator
    9: from typing import IO
   10: 
   11: import pre_commit.constants as C
   12: from pre_commit import output
   13: from pre_commit.errors import FatalError
   14: from pre_commit.store import Store
   15: from pre_commit.util import cmd_output_b
   16: from pre_commit.util import force_bytes
   17: 
   18: 
   19: def _log_and_exit(
   20:     msg: str,
   21:     ret_code: int,
   22:     exc: BaseException,
   23:     formatted: str,
   24: ) -> None:
   25:     error_msg = f'{msg}: {type(exc).__name__}: '.encode() + force_bytes(exc)
   26:     output.write_line_b(error_msg)
   27: 
   28:     _, git_version_b, _ = cmd_output_b('git', '--version', check=False)
   29:     git_version = git_version_b.decode(errors='backslashreplace').rstrip()
   30: 
   31:     storedir = Store().directory
   32:     log_path = os.path.join(storedir, 'pre-commit.log')
   33:     with contextlib.ExitStack() as ctx:
   34:         if os.access(storedir, os.W_OK):
   35:             output.write_line(f'Check the log at {log_path}')
   36:             log: IO[bytes] = ctx.enter_context(open(log_path, 'wb'))
   37:         else:  # pragma: win32 no cover
   38:             output.write_line(f'Failed to write to log at {log_path}')
   39:             log = sys.stdout.buffer
   40: 
   41:         _log_line = functools.partial(output.write_line, stream=log)
   42:         _log_line_b = functools.partial(output.write_line_b, stream=log)
   43: 
   44:         _log_line('### version information')
   45:         _log_line()
   46:         _log_line('```')
   47:         _log_line(f'pre-commit version: {C.VERSION}')
   48:         _log_line(f'git --version: {git_version}')
   49:         _log_line('sys.version:')
   50:         for line in sys.version.splitlines():
   51:             _log_line(f'    {line}')
   52:         _log_line(f'sys.executable: {sys.executable}')
   53:         _log_line(f'os.name: {os.name}')
   54:         _log_line(f'sys.platform: {sys.platform}')
   55:         _log_line('```')
   56:         _log_line()
   57: 
   58:         _log_line('### error information')
   59:         _log_line()
   60:         _log_line('```')
   61:         _log_line_b(error_msg)
   62:         _log_line('```')
   63:         _log_line()
   64:         _log_line('```')
   65:         _log_line(formatted.rstrip())
   66:         _log_line('```')
   67:     raise SystemExit(ret_code)
   68: 
   69: 
   70: @contextlib.contextmanager
   71: def error_handler() -> Generator[None]:
   72:     try:
   73:         yield
   74:     except (Exception, KeyboardInterrupt) as e:
   75:         if isinstance(e, FatalError):
   76:             msg, ret_code = 'An error has occurred', 1
   77:         elif isinstance(e, KeyboardInterrupt):
   78:             msg, ret_code = 'Interrupted (^C)', 130
   79:         else:
   80:             msg, ret_code = 'An unexpected error has occurred', 3
   81:         _log_and_exit(msg, ret_code, e, traceback.format_exc())
