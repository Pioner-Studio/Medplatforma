    1: from __future__ import annotations
    2: 
    3: import logging
    4: import os.path
    5: import sys
    6: from collections.abc import Mapping
    7: 
    8: from pre_commit.errors import FatalError
    9: from pre_commit.util import CalledProcessError
   10: from pre_commit.util import cmd_output
   11: from pre_commit.util import cmd_output_b
   12: 
   13: logger = logging.getLogger(__name__)
   14: 
   15: # see #2046
   16: NO_FS_MONITOR = ('-c', 'core.useBuiltinFSMonitor=false')
   17: 
   18: 
   19: def zsplit(s: str) -> list[str]:
   20:     s = s.strip('\0')
   21:     if s:
   22:         return s.split('\0')
   23:     else:
   24:         return []
   25: 
   26: 
   27: def no_git_env(_env: Mapping[str, str] | None = None) -> dict[str, str]:
   28:     # Too many bugs dealing with environment variables and GIT:
   29:     # https://github.com/pre-commit/pre-commit/issues/300
   30:     # In git 2.6.3 (maybe others), git exports GIT_WORK_TREE while running
   31:     # pre-commit hooks
   32:     # In git 1.9.1 (maybe others), git exports GIT_DIR and GIT_INDEX_FILE
   33:     # while running pre-commit hooks in submodules.
   34:     # GIT_DIR: Causes git clone to clone wrong thing
   35:     # GIT_INDEX_FILE: Causes 'error invalid object ...' during commit
   36:     _env = _env if _env is not None else os.environ
   37:     return {
   38:         k: v for k, v in _env.items()
   39:         if not k.startswith('GIT_') or
   40:         k.startswith(('GIT_CONFIG_KEY_', 'GIT_CONFIG_VALUE_')) or
   41:         k in {
   42:             'GIT_EXEC_PATH', 'GIT_SSH', 'GIT_SSH_COMMAND', 'GIT_SSL_CAINFO',
   43:             'GIT_SSL_NO_VERIFY', 'GIT_CONFIG_COUNT',
   44:             'GIT_HTTP_PROXY_AUTHMETHOD',
   45:             'GIT_ALLOW_PROTOCOL',
   46:             'GIT_ASKPASS',
   47:         }
   48:     }
   49: 
   50: 
   51: def get_root() -> str:
   52:     # Git 2.25 introduced a change to "rev-parse --show-toplevel" that exposed
   53:     # underlying volumes for Windows drives mapped with SUBST.  We use
   54:     # "rev-parse --show-cdup" to get the appropriate path, but must perform
   55:     # an extra check to see if we are in the .git directory.
   56:     try:
   57:         root = os.path.abspath(
   58:             cmd_output('git', 'rev-parse', '--show-cdup')[1].strip(),
   59:         )
   60:         inside_git_dir = cmd_output(
   61:             'git', 'rev-parse', '--is-inside-git-dir',
   62:         )[1].strip()
   63:     except CalledProcessError:
   64:         raise FatalError(
   65:             'git failed. Is it installed, and are you in a Git repository '
   66:             'directory?',
   67:         )
   68:     if inside_git_dir != 'false':
   69:         raise FatalError(
   70:             'git toplevel unexpectedly empty! make sure you are not '
   71:             'inside the `.git` directory of your repository.',
   72:         )
   73:     return root
   74: 
   75: 
   76: def get_git_dir(git_root: str = '.') -> str:
   77:     opt = '--git-dir'
   78:     _, out, _ = cmd_output('git', 'rev-parse', opt, cwd=git_root)
   79:     git_dir = out.strip()
   80:     if git_dir != opt:
   81:         return os.path.normpath(os.path.join(git_root, git_dir))
   82:     else:
   83:         raise AssertionError('unreachable: no git dir')
   84: 
   85: 
   86: def get_git_common_dir(git_root: str = '.') -> str:
   87:     opt = '--git-common-dir'
   88:     _, out, _ = cmd_output('git', 'rev-parse', opt, cwd=git_root)
   89:     git_common_dir = out.strip()
   90:     if git_common_dir != opt:
   91:         return os.path.normpath(os.path.join(git_root, git_common_dir))
   92:     else:  # pragma: no cover (git < 2.5)
   93:         return get_git_dir(git_root)
   94: 
   95: 
   96: def is_in_merge_conflict() -> bool:
   97:     git_dir = get_git_dir('.')
   98:     return (
   99:         os.path.exists(os.path.join(git_dir, 'MERGE_MSG')) and
  100:         os.path.exists(os.path.join(git_dir, 'MERGE_HEAD'))
  101:     )
  102: 
  103: 
  104: def parse_merge_msg_for_conflicts(merge_msg: bytes) -> list[str]:
  105:     # Conflicted files start with tabs
  106:     return [
  107:         line.lstrip(b'#').strip().decode()
  108:         for line in merge_msg.splitlines()
  109:         # '#\t' for git 2.4.1
  110:         if line.startswith((b'\t', b'#\t'))
  111:     ]
  112: 
  113: 
  114: def get_conflicted_files() -> set[str]:
  115:     logger.info('Checking merge-conflict files only.')
  116:     # Need to get the conflicted files from the MERGE_MSG because they could
  117:     # have resolved the conflict by choosing one side or the other
  118:     with open(os.path.join(get_git_dir('.'), 'MERGE_MSG'), 'rb') as f:
  119:         merge_msg = f.read()
  120:     merge_conflict_filenames = parse_merge_msg_for_conflicts(merge_msg)
  121: 
  122:     # This will get the rest of the changes made after the merge.
  123:     # If they resolved the merge conflict by choosing a mesh of both sides
  124:     # this will also include the conflicted files
  125:     tree_hash = cmd_output('git', 'write-tree')[1].strip()
  126:     merge_diff_filenames = zsplit(
  127:         cmd_output(
  128:             'git', 'diff', '--name-only', '--no-ext-diff', '-z',
  129:             '-m', tree_hash, 'HEAD', 'MERGE_HEAD', '--',
  130:         )[1],
  131:     )
  132:     return set(merge_conflict_filenames) | set(merge_diff_filenames)
  133: 
  134: 
  135: def get_staged_files(cwd: str | None = None) -> list[str]:
  136:     return zsplit(
  137:         cmd_output(
  138:             'git', 'diff', '--staged', '--name-only', '--no-ext-diff', '-z',
  139:             # Everything except for D
  140:             '--diff-filter=ACMRTUXB',
  141:             cwd=cwd,
  142:         )[1],
  143:     )
  144: 
  145: 
  146: def intent_to_add_files() -> list[str]:
  147:     _, stdout, _ = cmd_output(
  148:         'git', 'diff', '--no-ext-diff', '--ignore-submodules',
  149:         '--diff-filter=A', '--name-only', '-z',
  150:     )
  151:     return zsplit(stdout)
  152: 
  153: 
  154: def get_all_files() -> list[str]:
  155:     return zsplit(cmd_output('git', 'ls-files', '-z')[1])
  156: 
  157: 
  158: def get_changed_files(old: str, new: str) -> list[str]:
  159:     diff_cmd = ('git', 'diff', '--name-only', '--no-ext-diff', '-z')
  160:     try:
  161:         _, out, _ = cmd_output(*diff_cmd, f'{old}...{new}')
  162:     except CalledProcessError:  # pragma: no cover (new git)
  163:         # on newer git where old and new do not have a merge base git fails
  164:         # so we try a full diff (this is what old git did for us!)
  165:         _, out, _ = cmd_output(*diff_cmd, f'{old}..{new}')
  166: 
  167:     return zsplit(out)
  168: 
  169: 
  170: def head_rev(remote: str) -> str:
  171:     _, out, _ = cmd_output('git', 'ls-remote', '--exit-code', remote, 'HEAD')
  172:     return out.split()[0]
  173: 
  174: 
  175: def has_diff(*args: str, repo: str = '.') -> bool:
  176:     cmd = ('git', 'diff', '--quiet', '--no-ext-diff', *args)
  177:     return cmd_output_b(*cmd, cwd=repo, check=False)[0] == 1
  178: 
  179: 
  180: def has_core_hookpaths_set() -> bool:
  181:     _, out, _ = cmd_output_b('git', 'config', 'core.hooksPath', check=False)
  182:     return bool(out.strip())
  183: 
  184: 
  185: def init_repo(path: str, remote: str) -> None:
  186:     if os.path.isdir(remote):
  187:         remote = os.path.abspath(remote)
  188: 
  189:     git = ('git', *NO_FS_MONITOR)
  190:     env = no_git_env()
  191:     # avoid the user's template so that hooks do not recurse
  192:     cmd_output_b(*git, 'init', '--template=', path, env=env)
  193:     cmd_output_b(*git, 'remote', 'add', 'origin', remote, cwd=path, env=env)
  194: 
  195: 
  196: def commit(repo: str = '.') -> None:
  197:     env = no_git_env()
  198:     name, email = 'pre-commit', 'asottile+pre-commit@umich.edu'
  199:     env['GIT_AUTHOR_NAME'] = env['GIT_COMMITTER_NAME'] = name
  200:     env['GIT_AUTHOR_EMAIL'] = env['GIT_COMMITTER_EMAIL'] = email
  201:     cmd = ('git', 'commit', '--no-edit', '--no-gpg-sign', '-n', '-minit')
  202:     cmd_output_b(*cmd, cwd=repo, env=env)
  203: 
  204: 
  205: def git_path(name: str, repo: str = '.') -> str:
  206:     _, out, _ = cmd_output('git', 'rev-parse', '--git-path', name, cwd=repo)
  207:     return os.path.join(repo, out.strip())
  208: 
  209: 
  210: def check_for_cygwin_mismatch() -> None:
  211:     """See https://github.com/pre-commit/pre-commit/issues/354"""
  212:     if sys.platform in ('cygwin', 'win32'):  # pragma: no cover (windows)
  213:         is_cygwin_python = sys.platform == 'cygwin'
  214:         try:
  215:             toplevel = get_root()
  216:         except FatalError:  # skip the check if we're not in a git repo
  217:             return
  218:         is_cygwin_git = toplevel.startswith('/')
  219: 
  220:         if is_cygwin_python ^ is_cygwin_git:
  221:             exe_type = {True: '(cygwin)', False: '(windows)'}
  222:             logger.warn(
  223:                 f'pre-commit has detected a mix of cygwin python / git\n'
  224:                 f'This combination is not supported, it is likely you will '
  225:                 f'receive an error later in the program.\n'
  226:                 f'Make sure to use cygwin git+python while using cygwin\n'
  227:                 f'These can be installed through the cygwin installer.\n'
  228:                 f' - python {exe_type[is_cygwin_python]}\n'
  229:                 f' - git {exe_type[is_cygwin_git]}\n',
  230:             )
  231: 
  232: 
  233: def get_best_candidate_tag(rev: str, git_repo: str) -> str:
  234:     """Get the best tag candidate.
  235: 
  236:     Multiple tags can exist on a SHA. Sometimes a moving tag is attached
  237:     to a version tag. Try to pick the tag that looks like a version.
  238:     """
  239:     tags = cmd_output(
  240:         'git', *NO_FS_MONITOR, 'tag', '--points-at', rev, cwd=git_repo,
  241:     )[1].splitlines()
  242:     for tag in tags:
  243:         if '.' in tag:
  244:             return tag
  245:     return rev
