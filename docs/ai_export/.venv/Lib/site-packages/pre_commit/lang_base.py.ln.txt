    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import os
    5: import random
    6: import re
    7: import shlex
    8: from collections.abc import Generator
    9: from collections.abc import Sequence
   10: from typing import Any
   11: from typing import ContextManager
   12: from typing import NoReturn
   13: from typing import Protocol
   14: 
   15: import pre_commit.constants as C
   16: from pre_commit import parse_shebang
   17: from pre_commit import xargs
   18: from pre_commit.prefix import Prefix
   19: from pre_commit.util import cmd_output_b
   20: 
   21: FIXED_RANDOM_SEED = 1542676187
   22: 
   23: SHIMS_RE = re.compile(r'[/\\]shims[/\\]')
   24: 
   25: 
   26: class Language(Protocol):
   27:     # Use `None` for no installation / environment
   28:     @property
   29:     def ENVIRONMENT_DIR(self) -> str | None: ...
   30:     # return a value to replace `'default` for `language_version`
   31:     def get_default_version(self) -> str: ...
   32:     # return whether the environment is healthy (or should be rebuilt)
   33:     def health_check(self, prefix: Prefix, version: str) -> str | None: ...
   34: 
   35:     # install a repository for the given language and language_version
   36:     def install_environment(
   37:             self,
   38:             prefix: Prefix,
   39:             version: str,
   40:             additional_dependencies: Sequence[str],
   41:     ) -> None:
   42:         ...
   43: 
   44:     # modify the environment for hook execution
   45:     def in_env(self, prefix: Prefix, version: str) -> ContextManager[None]: ...
   46: 
   47:     # execute a hook and return the exit code and output
   48:     def run_hook(
   49:             self,
   50:             prefix: Prefix,
   51:             entry: str,
   52:             args: Sequence[str],
   53:             file_args: Sequence[str],
   54:             *,
   55:             is_local: bool,
   56:             require_serial: bool,
   57:             color: bool,
   58:     ) -> tuple[int, bytes]:
   59:         ...
   60: 
   61: 
   62: def exe_exists(exe: str) -> bool:
   63:     found = parse_shebang.find_executable(exe)
   64:     if found is None:  # exe exists
   65:         return False
   66: 
   67:     homedir = os.path.expanduser('~')
   68:     try:
   69:         common: str | None = os.path.commonpath((found, homedir))
   70:     except ValueError:  # on windows, different drives raises ValueError
   71:         common = None
   72: 
   73:     return (
   74:         # it is not in a /shims/ directory
   75:         not SHIMS_RE.search(found) and
   76:         (
   77:             # the homedir is / (docker, service user, etc.)
   78:             os.path.dirname(homedir) == homedir or
   79:             # the exe is not contained in the home directory
   80:             common != homedir
   81:         )
   82:     )
   83: 
   84: 
   85: def setup_cmd(prefix: Prefix, cmd: tuple[str, ...], **kwargs: Any) -> None:
   86:     cmd_output_b(*cmd, cwd=prefix.prefix_dir, **kwargs)
   87: 
   88: 
   89: def environment_dir(prefix: Prefix, d: str, language_version: str) -> str:
   90:     return prefix.path(f'{d}-{language_version}')
   91: 
   92: 
   93: def assert_version_default(binary: str, version: str) -> None:
   94:     if version != C.DEFAULT:
   95:         raise AssertionError(
   96:             f'for now, pre-commit requires system-installed {binary} -- '
   97:             f'you selected `language_version: {version}`',
   98:         )
   99: 
  100: 
  101: def assert_no_additional_deps(
  102:         lang: str,
  103:         additional_deps: Sequence[str],
  104: ) -> None:
  105:     if additional_deps:
  106:         raise AssertionError(
  107:             f'for now, pre-commit does not support '
  108:             f'additional_dependencies for {lang} -- '
  109:             f'you selected `additional_dependencies: {additional_deps}`',
  110:         )
  111: 
  112: 
  113: def basic_get_default_version() -> str:
  114:     return C.DEFAULT
  115: 
  116: 
  117: def basic_health_check(prefix: Prefix, language_version: str) -> str | None:
  118:     return None
  119: 
  120: 
  121: def no_install(
  122:         prefix: Prefix,
  123:         version: str,
  124:         additional_dependencies: Sequence[str],
  125: ) -> NoReturn:
  126:     raise AssertionError('This language is not installable')
  127: 
  128: 
  129: @contextlib.contextmanager
  130: def no_env(prefix: Prefix, version: str) -> Generator[None]:
  131:     yield
  132: 
  133: 
  134: def target_concurrency() -> int:
  135:     if 'PRE_COMMIT_NO_CONCURRENCY' in os.environ:
  136:         return 1
  137:     else:
  138:         # Travis appears to have a bunch of CPUs, but we can't use them all.
  139:         if 'TRAVIS' in os.environ:
  140:             return 2
  141:         else:
  142:             return xargs.cpu_count()
  143: 
  144: 
  145: def _shuffled(seq: Sequence[str]) -> list[str]:
  146:     """Deterministically shuffle"""
  147:     fixed_random = random.Random()
  148:     fixed_random.seed(FIXED_RANDOM_SEED, version=1)
  149: 
  150:     seq = list(seq)
  151:     fixed_random.shuffle(seq)
  152:     return seq
  153: 
  154: 
  155: def run_xargs(
  156:         cmd: tuple[str, ...],
  157:         file_args: Sequence[str],
  158:         *,
  159:         require_serial: bool,
  160:         color: bool,
  161: ) -> tuple[int, bytes]:
  162:     if require_serial:
  163:         jobs = 1
  164:     else:
  165:         # Shuffle the files so that they more evenly fill out the xargs
  166:         # partitions, but do it deterministically in case a hook cares about
  167:         # ordering.
  168:         file_args = _shuffled(file_args)
  169:         jobs = target_concurrency()
  170:     return xargs.xargs(cmd, file_args, target_concurrency=jobs, color=color)
  171: 
  172: 
  173: def hook_cmd(entry: str, args: Sequence[str]) -> tuple[str, ...]:
  174:     return (*shlex.split(entry), *args)
  175: 
  176: 
  177: def basic_run_hook(
  178:         prefix: Prefix,
  179:         entry: str,
  180:         args: Sequence[str],
  181:         file_args: Sequence[str],
  182:         *,
  183:         is_local: bool,
  184:         require_serial: bool,
  185:         color: bool,
  186: ) -> tuple[int, bytes]:
  187:     return run_xargs(
  188:         hook_cmd(entry, args),
  189:         file_args,
  190:         require_serial=require_serial,
  191:         color=color,
  192:     )
