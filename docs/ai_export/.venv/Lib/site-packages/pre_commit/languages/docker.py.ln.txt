    1: from __future__ import annotations
    2: 
    3: import functools
    4: import hashlib
    5: import json
    6: import os
    7: from collections.abc import Sequence
    8: 
    9: from pre_commit import lang_base
   10: from pre_commit.prefix import Prefix
   11: from pre_commit.util import CalledProcessError
   12: from pre_commit.util import cmd_output_b
   13: 
   14: ENVIRONMENT_DIR = 'docker'
   15: PRE_COMMIT_LABEL = 'PRE_COMMIT'
   16: get_default_version = lang_base.basic_get_default_version
   17: health_check = lang_base.basic_health_check
   18: in_env = lang_base.no_env  # no special environment for docker
   19: 
   20: 
   21: def _is_in_docker() -> bool:
   22:     try:
   23:         with open('/proc/1/cgroup', 'rb') as f:
   24:             return b'docker' in f.read()
   25:     except FileNotFoundError:
   26:         return False
   27: 
   28: 
   29: def _get_container_id() -> str:
   30:     # It's assumed that we already check /proc/1/cgroup in _is_in_docker. The
   31:     # cpuset cgroup controller existed since cgroups were introduced so this
   32:     # way of getting the container ID is pretty reliable.
   33:     with open('/proc/1/cgroup', 'rb') as f:
   34:         for line in f.readlines():
   35:             if line.split(b':')[1] == b'cpuset':
   36:                 return os.path.basename(line.split(b':')[2]).strip().decode()
   37:     raise RuntimeError('Failed to find the container ID in /proc/1/cgroup.')
   38: 
   39: 
   40: def _get_docker_path(path: str) -> str:
   41:     if not _is_in_docker():
   42:         return path
   43: 
   44:     container_id = _get_container_id()
   45: 
   46:     try:
   47:         _, out, _ = cmd_output_b('docker', 'inspect', container_id)
   48:     except CalledProcessError:
   49:         # self-container was not visible from here (perhaps docker-in-docker)
   50:         return path
   51: 
   52:     container, = json.loads(out)
   53:     for mount in container['Mounts']:
   54:         src_path = mount['Source']
   55:         to_path = mount['Destination']
   56:         if os.path.commonpath((path, to_path)) == to_path:
   57:             # So there is something in common,
   58:             # and we can proceed remapping it
   59:             return path.replace(to_path, src_path)
   60:     # we're in Docker, but the path is not mounted, cannot really do anything,
   61:     # so fall back to original path
   62:     return path
   63: 
   64: 
   65: def md5(s: str) -> str:  # pragma: win32 no cover
   66:     return hashlib.md5(s.encode()).hexdigest()
   67: 
   68: 
   69: def docker_tag(prefix: Prefix) -> str:  # pragma: win32 no cover
   70:     md5sum = md5(os.path.basename(prefix.prefix_dir)).lower()
   71:     return f'pre-commit-{md5sum}'
   72: 
   73: 
   74: def build_docker_image(
   75:         prefix: Prefix,
   76:         *,
   77:         pull: bool,
   78: ) -> None:  # pragma: win32 no cover
   79:     cmd: tuple[str, ...] = (
   80:         'docker', 'build',
   81:         '--tag', docker_tag(prefix),
   82:         '--label', PRE_COMMIT_LABEL,
   83:     )
   84:     if pull:
   85:         cmd += ('--pull',)
   86:     # This must come last for old versions of docker.  See #477
   87:     cmd += ('.',)
   88:     lang_base.setup_cmd(prefix, cmd)
   89: 
   90: 
   91: def install_environment(
   92:         prefix: Prefix, version: str, additional_dependencies: Sequence[str],
   93: ) -> None:  # pragma: win32 no cover
   94:     lang_base.assert_version_default('docker', version)
   95:     lang_base.assert_no_additional_deps('docker', additional_dependencies)
   96: 
   97:     directory = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
   98: 
   99:     # Docker doesn't really have relevant disk environment, but pre-commit
  100:     # still needs to cleanup its state files on failure
  101:     build_docker_image(prefix, pull=True)
  102:     os.mkdir(directory)
  103: 
  104: 
  105: @functools.lru_cache(maxsize=1)
  106: def _is_rootless() -> bool:  # pragma: win32 no cover
  107:     retcode, out, _ = cmd_output_b(
  108:         'docker', 'system', 'info', '--format', '{{ json . }}',
  109:     )
  110:     if retcode != 0:
  111:         return False
  112: 
  113:     info = json.loads(out)
  114:     try:
  115:         return (
  116:             # docker:
  117:             # https://docs.docker.com/reference/api/engine/version/v1.48/#tag/System/operation/SystemInfo
  118:             'name=rootless' in info.get('SecurityOptions', ()) or
  119:             # podman:
  120:             # https://docs.podman.io/en/latest/_static/api.html?version=v5.4#tag/system/operation/SystemInfoLibpod
  121:             info['host']['security']['rootless']
  122:         )
  123:     except KeyError:
  124:         return False
  125: 
  126: 
  127: def get_docker_user() -> tuple[str, ...]:  # pragma: win32 no cover
  128:     if _is_rootless():
  129:         return ()
  130: 
  131:     try:
  132:         return ('-u', f'{os.getuid()}:{os.getgid()}')
  133:     except AttributeError:
  134:         return ()
  135: 
  136: 
  137: def get_docker_tty(*, color: bool) -> tuple[str, ...]:  # pragma: win32 no cover  # noqa: E501
  138:     return (('--tty',) if color else ())
  139: 
  140: 
  141: def docker_cmd(*, color: bool) -> tuple[str, ...]:  # pragma: win32 no cover
  142:     return (
  143:         'docker', 'run',
  144:         '--rm',
  145:         *get_docker_tty(color=color),
  146:         *get_docker_user(),
  147:         # https://docs.docker.com/engine/reference/commandline/run/#mount-volumes-from-container-volumes-from
  148:         # The `Z` option tells Docker to label the content with a private
  149:         # unshared label. Only the current container can use a private volume.
  150:         '-v', f'{_get_docker_path(os.getcwd())}:/src:rw,Z',
  151:         '--workdir', '/src',
  152:     )
  153: 
  154: 
  155: def run_hook(
  156:         prefix: Prefix,
  157:         entry: str,
  158:         args: Sequence[str],
  159:         file_args: Sequence[str],
  160:         *,
  161:         is_local: bool,
  162:         require_serial: bool,
  163:         color: bool,
  164: ) -> tuple[int, bytes]:  # pragma: win32 no cover
  165:     # Rebuild the docker image in case it has gone missing, as many people do
  166:     # automated cleanup of docker images.
  167:     build_docker_image(prefix, pull=False)
  168: 
  169:     entry_exe, *cmd_rest = lang_base.hook_cmd(entry, args)
  170: 
  171:     entry_tag = ('--entrypoint', entry_exe, docker_tag(prefix))
  172:     return lang_base.run_xargs(
  173:         (*docker_cmd(color=color), *entry_tag, *cmd_rest),
  174:         file_args,
  175:         require_serial=require_serial,
  176:         color=color,
  177:     )
