    1: from __future__ import annotations
    2: 
    3: import argparse
    4: import re
    5: import sys
    6: from collections.abc import Sequence
    7: from re import Pattern
    8: from typing import NamedTuple
    9: 
   10: from pre_commit import lang_base
   11: from pre_commit import output
   12: from pre_commit.prefix import Prefix
   13: from pre_commit.xargs import xargs
   14: 
   15: ENVIRONMENT_DIR = None
   16: get_default_version = lang_base.basic_get_default_version
   17: health_check = lang_base.basic_health_check
   18: install_environment = lang_base.no_install
   19: in_env = lang_base.no_env
   20: 
   21: 
   22: def _process_filename_by_line(pattern: Pattern[bytes], filename: str) -> int:
   23:     retv = 0
   24:     with open(filename, 'rb') as f:
   25:         for line_no, line in enumerate(f, start=1):
   26:             if pattern.search(line):
   27:                 retv = 1
   28:                 output.write(f'{filename}:{line_no}:')
   29:                 output.write_line_b(line.rstrip(b'\r\n'))
   30:     return retv
   31: 
   32: 
   33: def _process_filename_at_once(pattern: Pattern[bytes], filename: str) -> int:
   34:     retv = 0
   35:     with open(filename, 'rb') as f:
   36:         contents = f.read()
   37:         match = pattern.search(contents)
   38:         if match:
   39:             retv = 1
   40:             line_no = contents[:match.start()].count(b'\n')
   41:             output.write(f'{filename}:{line_no + 1}:')
   42: 
   43:             matched_lines = match[0].split(b'\n')
   44:             matched_lines[0] = contents.split(b'\n')[line_no]
   45: 
   46:             output.write_line_b(b'\n'.join(matched_lines))
   47:     return retv
   48: 
   49: 
   50: def _process_filename_by_line_negated(
   51:         pattern: Pattern[bytes],
   52:         filename: str,
   53: ) -> int:
   54:     with open(filename, 'rb') as f:
   55:         for line in f:
   56:             if pattern.search(line):
   57:                 return 0
   58:         else:
   59:             output.write_line(filename)
   60:             return 1
   61: 
   62: 
   63: def _process_filename_at_once_negated(
   64:         pattern: Pattern[bytes],
   65:         filename: str,
   66: ) -> int:
   67:     with open(filename, 'rb') as f:
   68:         contents = f.read()
   69:     match = pattern.search(contents)
   70:     if match:
   71:         return 0
   72:     else:
   73:         output.write_line(filename)
   74:         return 1
   75: 
   76: 
   77: class Choice(NamedTuple):
   78:     multiline: bool
   79:     negate: bool
   80: 
   81: 
   82: FNS = {
   83:     Choice(multiline=True, negate=True): _process_filename_at_once_negated,
   84:     Choice(multiline=True, negate=False): _process_filename_at_once,
   85:     Choice(multiline=False, negate=True): _process_filename_by_line_negated,
   86:     Choice(multiline=False, negate=False): _process_filename_by_line,
   87: }
   88: 
   89: 
   90: def run_hook(
   91:         prefix: Prefix,
   92:         entry: str,
   93:         args: Sequence[str],
   94:         file_args: Sequence[str],
   95:         *,
   96:         is_local: bool,
   97:         require_serial: bool,
   98:         color: bool,
   99: ) -> tuple[int, bytes]:
  100:     cmd = (sys.executable, '-m', __name__, *args, entry)
  101:     return xargs(cmd, file_args, color=color)
  102: 
  103: 
  104: def main(argv: Sequence[str] | None = None) -> int:
  105:     parser = argparse.ArgumentParser(
  106:         description=(
  107:             'grep-like finder using python regexes.  Unlike grep, this tool '
  108:             'returns nonzero when it finds a match and zero otherwise.  The '
  109:             'idea here being that matches are "problems".'
  110:         ),
  111:     )
  112:     parser.add_argument('-i', '--ignore-case', action='store_true')
  113:     parser.add_argument('--multiline', action='store_true')
  114:     parser.add_argument('--negate', action='store_true')
  115:     parser.add_argument('pattern', help='python regex pattern.')
  116:     parser.add_argument('filenames', nargs='*')
  117:     args = parser.parse_args(argv)
  118: 
  119:     flags = re.IGNORECASE if args.ignore_case else 0
  120:     if args.multiline:
  121:         flags |= re.MULTILINE | re.DOTALL
  122: 
  123:     pattern = re.compile(args.pattern.encode(), flags)
  124: 
  125:     retv = 0
  126:     process_fn = FNS[Choice(multiline=args.multiline, negate=args.negate)]
  127:     for filename in args.filenames:
  128:         retv |= process_fn(pattern, filename)
  129:     return retv
  130: 
  131: 
  132: if __name__ == '__main__':
  133:     raise SystemExit(main())
