    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import functools
    5: import os
    6: import sys
    7: from collections.abc import Generator
    8: from collections.abc import Sequence
    9: 
   10: import pre_commit.constants as C
   11: from pre_commit import lang_base
   12: from pre_commit.envcontext import envcontext
   13: from pre_commit.envcontext import PatchesT
   14: from pre_commit.envcontext import UNSET
   15: from pre_commit.envcontext import Var
   16: from pre_commit.parse_shebang import find_executable
   17: from pre_commit.prefix import Prefix
   18: from pre_commit.util import CalledProcessError
   19: from pre_commit.util import cmd_output
   20: from pre_commit.util import cmd_output_b
   21: from pre_commit.util import win_exe
   22: 
   23: ENVIRONMENT_DIR = 'py_env'
   24: run_hook = lang_base.basic_run_hook
   25: 
   26: 
   27: @functools.cache
   28: def _version_info(exe: str) -> str:
   29:     prog = 'import sys;print(".".join(str(p) for p in sys.version_info))'
   30:     try:
   31:         return cmd_output(exe, '-S', '-c', prog)[1].strip()
   32:     except CalledProcessError:
   33:         return f'<<error retrieving version from {exe}>>'
   34: 
   35: 
   36: def _read_pyvenv_cfg(filename: str) -> dict[str, str]:
   37:     ret = {}
   38:     with open(filename, encoding='UTF-8') as f:
   39:         for line in f:
   40:             try:
   41:                 k, v = line.split('=')
   42:             except ValueError:  # blank line / comment / etc.
   43:                 continue
   44:             else:
   45:                 ret[k.strip()] = v.strip()
   46:     return ret
   47: 
   48: 
   49: def bin_dir(venv: str) -> str:
   50:     """On windows there's a different directory for the virtualenv"""
   51:     bin_part = 'Scripts' if sys.platform == 'win32' else 'bin'
   52:     return os.path.join(venv, bin_part)
   53: 
   54: 
   55: def get_env_patch(venv: str) -> PatchesT:
   56:     return (
   57:         ('PIP_DISABLE_PIP_VERSION_CHECK', '1'),
   58:         ('PYTHONHOME', UNSET),
   59:         ('VIRTUAL_ENV', venv),
   60:         ('PATH', (bin_dir(venv), os.pathsep, Var('PATH'))),
   61:     )
   62: 
   63: 
   64: def _find_by_py_launcher(
   65:         version: str,
   66: ) -> str | None:  # pragma: no cover (windows only)
   67:     if version.startswith('python'):
   68:         num = version.removeprefix('python')
   69:         cmd = ('py', f'-{num}', '-c', 'import sys; print(sys.executable)')
   70:         env = dict(os.environ, PYTHONIOENCODING='UTF-8')
   71:         try:
   72:             return cmd_output(*cmd, env=env)[1].strip()
   73:         except CalledProcessError:
   74:             pass
   75:     return None
   76: 
   77: 
   78: def _impl_exe_name() -> str:
   79:     if sys.implementation.name == 'cpython':  # pragma: cpython cover
   80:         return 'python'
   81:     else:  # pragma: cpython no cover
   82:         return sys.implementation.name  # pypy mostly
   83: 
   84: 
   85: def _find_by_sys_executable() -> str | None:
   86:     def _norm(path: str) -> str | None:
   87:         _, exe = os.path.split(path.lower())
   88:         exe, _, _ = exe.partition('.exe')
   89:         if exe not in {'python', 'pythonw'} and find_executable(exe):
   90:             return exe
   91:         return None
   92: 
   93:     # On linux, I see these common sys.executables:
   94:     #
   95:     # system `python`: /usr/bin/python -> python2.7
   96:     # system `python2`: /usr/bin/python2 -> python2.7
   97:     # virtualenv v: v/bin/python (will not return from this loop)
   98:     # virtualenv v -ppython2: v/bin/python -> python2
   99:     # virtualenv v -ppython2.7: v/bin/python -> python2.7
  100:     # virtualenv v -ppypy: v/bin/python -> v/bin/pypy
  101:     for path in (sys.executable, os.path.realpath(sys.executable)):
  102:         exe = _norm(path)
  103:         if exe:
  104:             return exe
  105:     return None
  106: 
  107: 
  108: @functools.lru_cache(maxsize=1)
  109: def get_default_version() -> str:  # pragma: no cover (platform dependent)
  110:     v_major = f'{sys.version_info[0]}'
  111:     v_minor = f'{sys.version_info[0]}.{sys.version_info[1]}'
  112: 
  113:     # attempt the likely implementation exe
  114:     for potential in (v_minor, v_major):
  115:         exe = f'{_impl_exe_name()}{potential}'
  116:         if find_executable(exe):
  117:             return exe
  118: 
  119:     # next try `sys.executable` (or the realpath)
  120:     maybe_exe = _find_by_sys_executable()
  121:     if maybe_exe:
  122:         return maybe_exe
  123: 
  124:     # maybe on windows we can find it via py launcher?
  125:     if sys.platform == 'win32':  # pragma: win32 cover
  126:         exe = f'python{v_minor}'
  127:         if _find_by_py_launcher(exe):
  128:             return exe
  129: 
  130:     # We tried!
  131:     return C.DEFAULT
  132: 
  133: 
  134: def _sys_executable_matches(version: str) -> bool:
  135:     if version == 'python':
  136:         return True
  137:     elif not version.startswith('python'):
  138:         return False
  139: 
  140:     try:
  141:         info = tuple(int(p) for p in version.removeprefix('python').split('.'))
  142:     except ValueError:
  143:         return False
  144: 
  145:     return sys.version_info[:len(info)] == info
  146: 
  147: 
  148: def norm_version(version: str) -> str | None:
  149:     if version == C.DEFAULT:  # use virtualenv's default
  150:         return None
  151:     elif _sys_executable_matches(version):  # virtualenv defaults to our exe
  152:         return None
  153: 
  154:     if sys.platform == 'win32':  # pragma: no cover (windows)
  155:         version_exec = _find_by_py_launcher(version)
  156:         if version_exec:
  157:             return version_exec
  158: 
  159:         # Try looking up by name
  160:         version_exec = find_executable(version)
  161:         if version_exec and version_exec != version:
  162:             return version_exec
  163: 
  164:     # Otherwise assume it is a path
  165:     return os.path.expanduser(version)
  166: 
  167: 
  168: @contextlib.contextmanager
  169: def in_env(prefix: Prefix, version: str) -> Generator[None]:
  170:     envdir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
  171:     with envcontext(get_env_patch(envdir)):
  172:         yield
  173: 
  174: 
  175: def health_check(prefix: Prefix, version: str) -> str | None:
  176:     envdir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
  177:     pyvenv_cfg = os.path.join(envdir, 'pyvenv.cfg')
  178: 
  179:     # created with "old" virtualenv
  180:     if not os.path.exists(pyvenv_cfg):
  181:         return 'pyvenv.cfg does not exist (old virtualenv?)'
  182: 
  183:     exe_name = win_exe('python')
  184:     py_exe = prefix.path(bin_dir(envdir), exe_name)
  185:     cfg = _read_pyvenv_cfg(pyvenv_cfg)
  186: 
  187:     if 'version_info' not in cfg:
  188:         return "created virtualenv's pyvenv.cfg is missing `version_info`"
  189: 
  190:     # always use uncached lookup here in case we replaced an unhealthy env
  191:     virtualenv_version = _version_info.__wrapped__(py_exe)
  192:     if virtualenv_version != cfg['version_info']:
  193:         return (
  194:             f'virtualenv python version did not match created version:\n'
  195:             f'- actual version: {virtualenv_version}\n'
  196:             f'- expected version: {cfg["version_info"]}\n'
  197:         )
  198: 
  199:     # made with an older version of virtualenv? skip `base-executable` check
  200:     if 'base-executable' not in cfg:
  201:         return None
  202: 
  203:     base_exe_version = _version_info(cfg['base-executable'])
  204:     if base_exe_version != cfg['version_info']:
  205:         return (
  206:             f'base executable python version does not match created version:\n'
  207:             f'- base-executable version: {base_exe_version}\n'
  208:             f'- expected version: {cfg["version_info"]}\n'
  209:         )
  210:     else:
  211:         return None
  212: 
  213: 
  214: def install_environment(
  215:         prefix: Prefix,
  216:         version: str,
  217:         additional_dependencies: Sequence[str],
  218: ) -> None:
  219:     envdir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
  220:     venv_cmd = [sys.executable, '-mvirtualenv', envdir]
  221:     python = norm_version(version)
  222:     if python is not None:
  223:         venv_cmd.extend(('-p', python))
  224:     install_cmd = ('python', '-mpip', 'install', '.', *additional_dependencies)
  225: 
  226:     cmd_output_b(*venv_cmd, cwd='/')
  227:     with in_env(prefix, version):
  228:         lang_base.setup_cmd(prefix, install_cmd)
