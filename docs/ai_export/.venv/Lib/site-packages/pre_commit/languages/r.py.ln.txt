    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import os
    5: import shlex
    6: import shutil
    7: import tempfile
    8: import textwrap
    9: from collections.abc import Generator
   10: from collections.abc import Sequence
   11: 
   12: from pre_commit import lang_base
   13: from pre_commit.envcontext import envcontext
   14: from pre_commit.envcontext import PatchesT
   15: from pre_commit.envcontext import UNSET
   16: from pre_commit.prefix import Prefix
   17: from pre_commit.util import cmd_output
   18: from pre_commit.util import win_exe
   19: 
   20: ENVIRONMENT_DIR = 'renv'
   21: get_default_version = lang_base.basic_get_default_version
   22: 
   23: _RENV_ACTIVATED_OPTS = (
   24:     '--no-save', '--no-restore', '--no-site-file', '--no-environ',
   25: )
   26: 
   27: 
   28: def _execute_r(
   29:         code: str, *,
   30:         prefix: Prefix, version: str, args: Sequence[str] = (), cwd: str,
   31:         cli_opts: Sequence[str],
   32: ) -> str:
   33:     with in_env(prefix, version), _r_code_in_tempfile(code) as f:
   34:         _, out, _ = cmd_output(
   35:             _rscript_exec(), *cli_opts, f, *args, cwd=cwd,
   36:         )
   37:     return out.rstrip('\n')
   38: 
   39: 
   40: def _execute_r_in_renv(
   41:         code: str, *,
   42:         prefix: Prefix, version: str, args: Sequence[str] = (), cwd: str,
   43: ) -> str:
   44:     return _execute_r(
   45:         code=code, prefix=prefix, version=version, args=args, cwd=cwd,
   46:         cli_opts=_RENV_ACTIVATED_OPTS,
   47:     )
   48: 
   49: 
   50: def _execute_vanilla_r(
   51:         code: str, *,
   52:         prefix: Prefix, version: str, args: Sequence[str] = (), cwd: str,
   53: ) -> str:
   54:     return _execute_r(
   55:         code=code, prefix=prefix, version=version, args=args, cwd=cwd,
   56:         cli_opts=('--vanilla',),
   57:     )
   58: 
   59: 
   60: def _read_installed_version(envdir: str, prefix: Prefix, version: str) -> str:
   61:     return _execute_r_in_renv(
   62:         'cat(renv::settings$r.version())',
   63:         prefix=prefix, version=version,
   64:         cwd=envdir,
   65:     )
   66: 
   67: 
   68: def _read_executable_version(envdir: str, prefix: Prefix, version: str) -> str:
   69:     return _execute_r_in_renv(
   70:         'cat(as.character(getRversion()))',
   71:         prefix=prefix, version=version,
   72:         cwd=envdir,
   73:     )
   74: 
   75: 
   76: def _write_current_r_version(
   77:         envdir: str, prefix: Prefix, version: str,
   78: ) -> None:
   79:     _execute_r_in_renv(
   80:         'renv::settings$r.version(as.character(getRversion()))',
   81:         prefix=prefix, version=version,
   82:         cwd=envdir,
   83:     )
   84: 
   85: 
   86: def health_check(prefix: Prefix, version: str) -> str | None:
   87:     envdir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
   88: 
   89:     r_version_installation = _read_installed_version(
   90:         envdir=envdir, prefix=prefix, version=version,
   91:     )
   92:     r_version_current_executable = _read_executable_version(
   93:         envdir=envdir, prefix=prefix, version=version,
   94:     )
   95:     if r_version_installation in {'NULL', ''}:
   96:         return (
   97:             f'Hooks were installed with an unknown R version. R version for '
   98:             f'hook repo now set to {r_version_current_executable}'
   99:         )
  100:     elif r_version_installation != r_version_current_executable:
  101:         return (
  102:             f'Hooks were installed for R version {r_version_installation}, '
  103:             f'but current R executable has version '
  104:             f'{r_version_current_executable}'
  105:         )
  106: 
  107:     return None
  108: 
  109: 
  110: @contextlib.contextmanager
  111: def _r_code_in_tempfile(code: str) -> Generator[str]:
  112:     """
  113:     To avoid quoting and escaping issues, avoid `Rscript [options] -e {expr}`
  114:     but use `Rscript [options] path/to/file_with_expr.R`
  115:     """
  116:     with tempfile.TemporaryDirectory() as tmpdir:
  117:         fname = os.path.join(tmpdir, 'script.R')
  118:         with open(fname, 'w') as f:
  119:             f.write(_inline_r_setup(textwrap.dedent(code)))
  120:         yield fname
  121: 
  122: 
  123: def get_env_patch(venv: str) -> PatchesT:
  124:     return (
  125:         ('R_PROFILE_USER', os.path.join(venv, 'activate.R')),
  126:         ('RENV_PROJECT', UNSET),
  127:     )
  128: 
  129: 
  130: @contextlib.contextmanager
  131: def in_env(prefix: Prefix, version: str) -> Generator[None]:
  132:     envdir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
  133:     with envcontext(get_env_patch(envdir)):
  134:         yield
  135: 
  136: 
  137: def _prefix_if_file_entry(
  138:         entry: list[str],
  139:         prefix: Prefix,
  140:         *,
  141:         is_local: bool,
  142: ) -> Sequence[str]:
  143:     if entry[1] == '-e' or is_local:
  144:         return entry[1:]
  145:     else:
  146:         return (prefix.path(entry[1]),)
  147: 
  148: 
  149: def _rscript_exec() -> str:
  150:     r_home = os.environ.get('R_HOME')
  151:     if r_home is None:
  152:         return 'Rscript'
  153:     else:
  154:         return os.path.join(r_home, 'bin', win_exe('Rscript'))
  155: 
  156: 
  157: def _entry_validate(entry: list[str]) -> None:
  158:     """
  159:     Allowed entries:
  160:     # Rscript -e expr
  161:     # Rscript path/to/file
  162:     """
  163:     if entry[0] != 'Rscript':
  164:         raise ValueError('entry must start with `Rscript`.')
  165: 
  166:     if entry[1] == '-e':
  167:         if len(entry) > 3:
  168:             raise ValueError('You can supply at most one expression.')
  169:     elif len(entry) > 2:
  170:         raise ValueError(
  171:             'The only valid syntax is `Rscript -e {expr}`'
  172:             'or `Rscript path/to/hook/script`',
  173:         )
  174: 
  175: 
  176: def _cmd_from_hook(
  177:         prefix: Prefix,
  178:         entry: str,
  179:         args: Sequence[str],
  180:         *,
  181:         is_local: bool,
  182: ) -> tuple[str, ...]:
  183:     cmd = shlex.split(entry)
  184:     _entry_validate(cmd)
  185: 
  186:     cmd_part = _prefix_if_file_entry(cmd, prefix, is_local=is_local)
  187:     return (cmd[0], *_RENV_ACTIVATED_OPTS, *cmd_part, *args)
  188: 
  189: 
  190: def install_environment(
  191:         prefix: Prefix,
  192:         version: str,
  193:         additional_dependencies: Sequence[str],
  194: ) -> None:
  195:     lang_base.assert_version_default('r', version)
  196: 
  197:     env_dir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
  198:     os.makedirs(env_dir, exist_ok=True)
  199:     shutil.copy(prefix.path('renv.lock'), env_dir)
  200:     shutil.copytree(prefix.path('renv'), os.path.join(env_dir, 'renv'))
  201: 
  202:     r_code_inst_environment = f"""\
  203:         prefix_dir <- {prefix.prefix_dir!r}
  204:         options(
  205:             repos = c(CRAN = "https://cran.rstudio.com"),
  206:             renv.consent = TRUE
  207:         )
  208:         source("renv/activate.R")
  209:         renv::restore()
  210:         activate_statement <- paste0(
  211:           'suppressWarnings({{',
  212:           'old <- setwd("', getwd(), '"); ',
  213:           'source("renv/activate.R"); ',
  214:           'setwd(old); ',
  215:           'renv::load("', getwd(), '");}})'
  216:         )
  217:         writeLines(activate_statement, 'activate.R')
  218:         is_package <- tryCatch(
  219:           {{
  220:               path_desc <- file.path(prefix_dir, 'DESCRIPTION')
  221:               suppressWarnings(desc <- read.dcf(path_desc))
  222:               "Package" %in% colnames(desc)
  223:           }},
  224:           error = function(...) FALSE
  225:         )
  226:         if (is_package) {{
  227:             renv::install(prefix_dir)
  228:         }}
  229:         """
  230:     _execute_vanilla_r(
  231:         r_code_inst_environment,
  232:         prefix=prefix, version=version, cwd=env_dir,
  233:     )
  234: 
  235:     _write_current_r_version(envdir=env_dir, prefix=prefix, version=version)
  236:     if additional_dependencies:
  237:         r_code_inst_add = 'renv::install(commandArgs(trailingOnly = TRUE))'
  238:         _execute_r_in_renv(
  239:             code=r_code_inst_add, prefix=prefix, version=version,
  240:             args=additional_dependencies,
  241:             cwd=env_dir,
  242:         )
  243: 
  244: 
  245: def _inline_r_setup(code: str) -> str:
  246:     """
  247:     Some behaviour of R cannot be configured via env variables, but can
  248:     only be configured via R options once R has started. These are set here.
  249:     """
  250:     with_option = [
  251:         textwrap.dedent("""\
  252:         options(
  253:             install.packages.compile.from.source = "never",
  254:             pkgType = "binary"
  255:         )
  256:         """),
  257:         code,
  258:     ]
  259:     return '\n'.join(with_option)
  260: 
  261: 
  262: def run_hook(
  263:         prefix: Prefix,
  264:         entry: str,
  265:         args: Sequence[str],
  266:         file_args: Sequence[str],
  267:         *,
  268:         is_local: bool,
  269:         require_serial: bool,
  270:         color: bool,
  271: ) -> tuple[int, bytes]:
  272:     cmd = _cmd_from_hook(prefix, entry, args, is_local=is_local)
  273:     return lang_base.run_xargs(
  274:         cmd,
  275:         file_args,
  276:         require_serial=require_serial,
  277:         color=color,
  278:     )
