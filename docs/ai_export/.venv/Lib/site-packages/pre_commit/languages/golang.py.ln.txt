    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import functools
    5: import json
    6: import os.path
    7: import platform
    8: import shutil
    9: import sys
   10: import tarfile
   11: import tempfile
   12: import urllib.error
   13: import urllib.request
   14: import zipfile
   15: from collections.abc import Generator
   16: from collections.abc import Sequence
   17: from typing import ContextManager
   18: from typing import IO
   19: from typing import Protocol
   20: 
   21: import pre_commit.constants as C
   22: from pre_commit import lang_base
   23: from pre_commit.envcontext import envcontext
   24: from pre_commit.envcontext import PatchesT
   25: from pre_commit.envcontext import Var
   26: from pre_commit.git import no_git_env
   27: from pre_commit.prefix import Prefix
   28: from pre_commit.util import cmd_output
   29: from pre_commit.util import rmtree
   30: 
   31: ENVIRONMENT_DIR = 'golangenv'
   32: health_check = lang_base.basic_health_check
   33: run_hook = lang_base.basic_run_hook
   34: 
   35: _ARCH_ALIASES = {
   36:     'x86_64': 'amd64',
   37:     'i386': '386',
   38:     'aarch64': 'arm64',
   39:     'armv8': 'arm64',
   40:     'armv7l': 'armv6l',
   41: }
   42: _ARCH = platform.machine().lower()
   43: _ARCH = _ARCH_ALIASES.get(_ARCH, _ARCH)
   44: 
   45: 
   46: class ExtractAll(Protocol):
   47:     def extractall(self, path: str) -> None: ...
   48: 
   49: 
   50: if sys.platform == 'win32':  # pragma: win32 cover
   51:     _EXT = 'zip'
   52: 
   53:     def _open_archive(bio: IO[bytes]) -> ContextManager[ExtractAll]:
   54:         return zipfile.ZipFile(bio)
   55: else:  # pragma: win32 no cover
   56:     _EXT = 'tar.gz'
   57: 
   58:     def _open_archive(bio: IO[bytes]) -> ContextManager[ExtractAll]:
   59:         return tarfile.open(fileobj=bio)
   60: 
   61: 
   62: @functools.lru_cache(maxsize=1)
   63: def get_default_version() -> str:
   64:     if lang_base.exe_exists('go'):
   65:         return 'system'
   66:     else:
   67:         return C.DEFAULT
   68: 
   69: 
   70: def get_env_patch(venv: str, version: str) -> PatchesT:
   71:     if version == 'system':
   72:         return (
   73:             ('PATH', (os.path.join(venv, 'bin'), os.pathsep, Var('PATH'))),
   74:         )
   75: 
   76:     return (
   77:         ('GOROOT', os.path.join(venv, '.go')),
   78:         ('GOTOOLCHAIN', 'local'),
   79:         (
   80:             'PATH', (
   81:                 os.path.join(venv, 'bin'), os.pathsep,
   82:                 os.path.join(venv, '.go', 'bin'), os.pathsep, Var('PATH'),
   83:             ),
   84:         ),
   85:     )
   86: 
   87: 
   88: @functools.lru_cache
   89: def _infer_go_version(version: str) -> str:
   90:     if version != C.DEFAULT:
   91:         return version
   92:     resp = urllib.request.urlopen('https://go.dev/dl/?mode=json')
   93:     # TODO: 3.9+ .removeprefix('go')
   94:     return json.load(resp)[0]['version'][2:]
   95: 
   96: 
   97: def _get_url(version: str) -> str:
   98:     os_name = platform.system().lower()
   99:     version = _infer_go_version(version)
  100:     return f'https://dl.google.com/go/go{version}.{os_name}-{_ARCH}.{_EXT}'
  101: 
  102: 
  103: def _install_go(version: str, dest: str) -> None:
  104:     try:
  105:         resp = urllib.request.urlopen(_get_url(version))
  106:     except urllib.error.HTTPError as e:  # pragma: no cover
  107:         if e.code == 404:
  108:             raise ValueError(
  109:                 f'Could not find a version matching your system requirements '
  110:                 f'(os={platform.system().lower()}; arch={_ARCH})',
  111:             ) from e
  112:         else:
  113:             raise
  114:     else:
  115:         with tempfile.TemporaryFile() as f:
  116:             shutil.copyfileobj(resp, f)
  117:             f.seek(0)
  118: 
  119:             with _open_archive(f) as archive:
  120:                 archive.extractall(dest)
  121:         shutil.move(os.path.join(dest, 'go'), os.path.join(dest, '.go'))
  122: 
  123: 
  124: @contextlib.contextmanager
  125: def in_env(prefix: Prefix, version: str) -> Generator[None]:
  126:     envdir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
  127:     with envcontext(get_env_patch(envdir, version)):
  128:         yield
  129: 
  130: 
  131: def install_environment(
  132:         prefix: Prefix,
  133:         version: str,
  134:         additional_dependencies: Sequence[str],
  135: ) -> None:
  136:     env_dir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
  137: 
  138:     if version != 'system':
  139:         _install_go(version, env_dir)
  140: 
  141:     if sys.platform == 'cygwin':  # pragma: no cover
  142:         gopath = cmd_output('cygpath', '-w', env_dir)[1].strip()
  143:     else:
  144:         gopath = env_dir
  145: 
  146:     env = no_git_env(dict(os.environ, GOPATH=gopath))
  147:     env.pop('GOBIN', None)
  148:     if version != 'system':
  149:         env['GOTOOLCHAIN'] = 'local'
  150:         env['GOROOT'] = os.path.join(env_dir, '.go')
  151:         env['PATH'] = os.pathsep.join((
  152:             os.path.join(env_dir, '.go', 'bin'), os.environ['PATH'],
  153:         ))
  154: 
  155:     lang_base.setup_cmd(prefix, ('go', 'install', './...'), env=env)
  156:     for dependency in additional_dependencies:
  157:         lang_base.setup_cmd(prefix, ('go', 'install', dependency), env=env)
  158: 
  159:     # save some disk space -- we don't need this after installation
  160:     pkgdir = os.path.join(env_dir, 'pkg')
  161:     if os.path.exists(pkgdir):  # pragma: no branch (always true on windows?)
  162:         rmtree(pkgdir)
