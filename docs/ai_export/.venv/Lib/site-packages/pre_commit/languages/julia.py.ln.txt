    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import os
    5: import shutil
    6: from collections.abc import Generator
    7: from collections.abc import Sequence
    8: 
    9: from pre_commit import lang_base
   10: from pre_commit.envcontext import envcontext
   11: from pre_commit.envcontext import PatchesT
   12: from pre_commit.envcontext import UNSET
   13: from pre_commit.prefix import Prefix
   14: from pre_commit.util import cmd_output_b
   15: 
   16: ENVIRONMENT_DIR = 'juliaenv'
   17: health_check = lang_base.basic_health_check
   18: get_default_version = lang_base.basic_get_default_version
   19: 
   20: 
   21: def run_hook(
   22:         prefix: Prefix,
   23:         entry: str,
   24:         args: Sequence[str],
   25:         file_args: Sequence[str],
   26:         *,
   27:         is_local: bool,
   28:         require_serial: bool,
   29:         color: bool,
   30: ) -> tuple[int, bytes]:
   31:     # `entry` is a (hook-repo relative) file followed by (optional) args, e.g.
   32:     # `bin/id.jl` or `bin/hook.jl --arg1 --arg2` so we
   33:     # 1) shell parse it and join with args with hook_cmd
   34:     # 2) prepend the hooks prefix path to the first argument (the file), unless
   35:     #    it is a local script
   36:     # 3) prepend `julia` as the interpreter
   37: 
   38:     cmd = lang_base.hook_cmd(entry, args)
   39:     script = cmd[0] if is_local else prefix.path(cmd[0])
   40:     cmd = ('julia', '--startup-file=no', script, *cmd[1:])
   41:     return lang_base.run_xargs(
   42:         cmd,
   43:         file_args,
   44:         require_serial=require_serial,
   45:         color=color,
   46:     )
   47: 
   48: 
   49: def get_env_patch(target_dir: str, version: str) -> PatchesT:
   50:     return (
   51:         ('JULIA_LOAD_PATH', target_dir),
   52:         # May be set, remove it to not interfer with LOAD_PATH
   53:         ('JULIA_PROJECT', UNSET),
   54:     )
   55: 
   56: 
   57: @contextlib.contextmanager
   58: def in_env(prefix: Prefix, version: str) -> Generator[None]:
   59:     envdir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
   60:     with envcontext(get_env_patch(envdir, version)):
   61:         yield
   62: 
   63: 
   64: def install_environment(
   65:         prefix: Prefix,
   66:         version: str,
   67:         additional_dependencies: Sequence[str],
   68: ) -> None:
   69:     envdir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
   70:     with in_env(prefix, version):
   71:         # TODO: Support language_version with juliaup similar to rust via
   72:         # rustup
   73:         # if version != 'system':
   74:         #     ...
   75: 
   76:         # Copy Project.toml to hook env if it exist
   77:         os.makedirs(envdir, exist_ok=True)
   78:         project_names = ('JuliaProject.toml', 'Project.toml')
   79:         project_found = False
   80:         for project_name in project_names:
   81:             project_file = prefix.path(project_name)
   82:             if not os.path.isfile(project_file):
   83:                 continue
   84:             shutil.copy(project_file, envdir)
   85:             project_found = True
   86:             break
   87: 
   88:         # If no project file was found we create an empty one so that the
   89:         # package manager doesn't error
   90:         if not project_found:
   91:             open(os.path.join(envdir, 'Project.toml'), 'a').close()
   92: 
   93:         # Copy Manifest.toml to hook env if it exists
   94:         manifest_names = ('JuliaManifest.toml', 'Manifest.toml')
   95:         for manifest_name in manifest_names:
   96:             manifest_file = prefix.path(manifest_name)
   97:             if not os.path.isfile(manifest_file):
   98:                 continue
   99:             shutil.copy(manifest_file, envdir)
  100:             break
  101: 
  102:         # Julia code to instantiate the hook environment
  103:         julia_code = """
  104:         @assert length(ARGS) > 0
  105:         hook_env = ARGS[1]
  106:         deps = join(ARGS[2:end], " ")
  107: 
  108:         # We prepend @stdlib here so that we can load the package manager even
  109:         # though `get_env_patch` limits `JULIA_LOAD_PATH` to just the hook env.
  110:         pushfirst!(LOAD_PATH, "@stdlib")
  111:         using Pkg
  112:         popfirst!(LOAD_PATH)
  113: 
  114:         # Instantiate the environment shipped with the hook repo. If we have
  115:         # additional dependencies we disable precompilation in this step to
  116:         # avoid double work.
  117:         precompile = isempty(deps) ? "1" : "0"
  118:         withenv("JULIA_PKG_PRECOMPILE_AUTO" => precompile) do
  119:             Pkg.instantiate()
  120:         end
  121: 
  122:         # Add additional dependencies (with precompilation)
  123:         if !isempty(deps)
  124:             withenv("JULIA_PKG_PRECOMPILE_AUTO" => "1") do
  125:                 Pkg.REPLMode.pkgstr("add " * deps)
  126:             end
  127:         end
  128:         """
  129:         cmd_output_b(
  130:             'julia', '--startup-file=no', '-e', julia_code, '--', envdir,
  131:             *additional_dependencies,
  132:             cwd=prefix.prefix_dir,
  133:         )
