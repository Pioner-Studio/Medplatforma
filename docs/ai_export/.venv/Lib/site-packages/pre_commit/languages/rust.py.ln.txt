    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import functools
    5: import os.path
    6: import shutil
    7: import sys
    8: import tempfile
    9: import urllib.request
   10: from collections.abc import Generator
   11: from collections.abc import Sequence
   12: 
   13: import pre_commit.constants as C
   14: from pre_commit import lang_base
   15: from pre_commit import parse_shebang
   16: from pre_commit.envcontext import envcontext
   17: from pre_commit.envcontext import PatchesT
   18: from pre_commit.envcontext import Var
   19: from pre_commit.prefix import Prefix
   20: from pre_commit.util import cmd_output_b
   21: from pre_commit.util import make_executable
   22: from pre_commit.util import win_exe
   23: 
   24: ENVIRONMENT_DIR = 'rustenv'
   25: health_check = lang_base.basic_health_check
   26: run_hook = lang_base.basic_run_hook
   27: 
   28: 
   29: @functools.lru_cache(maxsize=1)
   30: def get_default_version() -> str:
   31:     # If rust is already installed, we can save a bunch of setup time by
   32:     # using the installed version.
   33:     #
   34:     # Just detecting the executable does not suffice, because if rustup is
   35:     # installed but no toolchain is available, then `cargo` exists but
   36:     # cannot be used without installing a toolchain first.
   37:     if cmd_output_b('cargo', '--version', check=False, cwd='/')[0] == 0:
   38:         return 'system'
   39:     else:
   40:         return C.DEFAULT
   41: 
   42: 
   43: def _rust_toolchain(language_version: str) -> str:
   44:     """Transform the language version into a rust toolchain version."""
   45:     if language_version == C.DEFAULT:
   46:         return 'stable'
   47:     else:
   48:         return language_version
   49: 
   50: 
   51: def get_env_patch(target_dir: str, version: str) -> PatchesT:
   52:     return (
   53:         ('PATH', (os.path.join(target_dir, 'bin'), os.pathsep, Var('PATH'))),
   54:         # Only set RUSTUP_TOOLCHAIN if we don't want use the system's default
   55:         # toolchain
   56:         *(
   57:             (('RUSTUP_TOOLCHAIN', _rust_toolchain(version)),)
   58:             if version != 'system' else ()
   59:         ),
   60:     )
   61: 
   62: 
   63: @contextlib.contextmanager
   64: def in_env(prefix: Prefix, version: str) -> Generator[None]:
   65:     envdir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
   66:     with envcontext(get_env_patch(envdir, version)):
   67:         yield
   68: 
   69: 
   70: def _add_dependencies(
   71:         prefix: Prefix,
   72:         additional_dependencies: set[str],
   73: ) -> None:
   74:     crates = []
   75:     for dep in additional_dependencies:
   76:         name, _, spec = dep.partition(':')
   77:         crate = f'{name}@{spec or "*"}'
   78:         crates.append(crate)
   79: 
   80:     lang_base.setup_cmd(prefix, ('cargo', 'add', *crates))
   81: 
   82: 
   83: def install_rust_with_toolchain(toolchain: str, envdir: str) -> None:
   84:     with tempfile.TemporaryDirectory() as rustup_dir:
   85:         with envcontext((('CARGO_HOME', envdir), ('RUSTUP_HOME', rustup_dir))):
   86:             # acquire `rustup` if not present
   87:             if parse_shebang.find_executable('rustup') is None:
   88:                 # We did not detect rustup and need to download it first.
   89:                 if sys.platform == 'win32':  # pragma: win32 cover
   90:                     url = 'https://win.rustup.rs/x86_64'
   91:                 else:  # pragma: win32 no cover
   92:                     url = 'https://sh.rustup.rs'
   93: 
   94:                 resp = urllib.request.urlopen(url)
   95: 
   96:                 rustup_init = os.path.join(rustup_dir, win_exe('rustup-init'))
   97:                 with open(rustup_init, 'wb') as f:
   98:                     shutil.copyfileobj(resp, f)
   99:                 make_executable(rustup_init)
  100: 
  101:                 # install rustup into `$CARGO_HOME/bin`
  102:                 cmd_output_b(
  103:                     rustup_init, '-y', '--quiet', '--no-modify-path',
  104:                     '--default-toolchain', 'none',
  105:                 )
  106: 
  107:             cmd_output_b(
  108:                 'rustup', 'toolchain', 'install', '--no-self-update',
  109:                 toolchain,
  110:             )
  111: 
  112: 
  113: def install_environment(
  114:         prefix: Prefix,
  115:         version: str,
  116:         additional_dependencies: Sequence[str],
  117: ) -> None:
  118:     envdir = lang_base.environment_dir(prefix, ENVIRONMENT_DIR, version)
  119: 
  120:     # There are two cases where we might want to specify more dependencies:
  121:     # as dependencies for the library being built, and as binary packages
  122:     # to be `cargo install`'d.
  123:     #
  124:     # Unlike e.g. Python, if we just `cargo install` a library, it won't be
  125:     # used for compilation. And if we add a crate providing a binary to the
  126:     # `Cargo.toml`, the binary won't be built.
  127:     #
  128:     # Because of this, we allow specifying "cli" dependencies by prefixing
  129:     # with 'cli:'.
  130:     cli_deps = {
  131:         dep for dep in additional_dependencies if dep.startswith('cli:')
  132:     }
  133:     lib_deps = set(additional_dependencies) - cli_deps
  134: 
  135:     packages_to_install: set[tuple[str, ...]] = {('--path', '.')}
  136:     for cli_dep in cli_deps:
  137:         cli_dep = cli_dep.removeprefix('cli:')
  138:         package, _, crate_version = cli_dep.partition(':')
  139:         if crate_version != '':
  140:             packages_to_install.add((package, '--version', crate_version))
  141:         else:
  142:             packages_to_install.add((package,))
  143: 
  144:     with contextlib.ExitStack() as ctx:
  145:         ctx.enter_context(in_env(prefix, version))
  146: 
  147:         if version != 'system':
  148:             install_rust_with_toolchain(_rust_toolchain(version), envdir)
  149: 
  150:             tmpdir = ctx.enter_context(tempfile.TemporaryDirectory())
  151:             ctx.enter_context(envcontext((('RUSTUP_HOME', tmpdir),)))
  152: 
  153:         if len(lib_deps) > 0:
  154:             _add_dependencies(prefix, lib_deps)
  155: 
  156:         for args in packages_to_install:
  157:             cmd_output_b(
  158:                 'cargo', 'install', '--bins', '--root', envdir, *args,
  159:                 cwd=prefix.prefix_dir,
  160:             )
