    1: from __future__ import annotations
    2: 
    3: import argparse
    4: import re
    5: from collections.abc import Iterable
    6: from collections.abc import Sequence
    7: 
    8: from cfgv import apply_defaults
    9: 
   10: import pre_commit.constants as C
   11: from pre_commit import git
   12: from pre_commit.clientlib import load_config
   13: from pre_commit.clientlib import MANIFEST_HOOK_DICT
   14: from pre_commit.commands.run import Classifier
   15: 
   16: 
   17: def exclude_matches_any(
   18:         filenames: Iterable[str],
   19:         include: str,
   20:         exclude: str,
   21: ) -> bool:
   22:     if exclude == '^$':
   23:         return True
   24:     include_re, exclude_re = re.compile(include), re.compile(exclude)
   25:     for filename in filenames:
   26:         if include_re.search(filename) and exclude_re.search(filename):
   27:             return True
   28:     return False
   29: 
   30: 
   31: def check_useless_excludes(config_file: str) -> int:
   32:     config = load_config(config_file)
   33:     filenames = git.get_all_files()
   34:     classifier = Classifier.from_config(
   35:         filenames, config['files'], config['exclude'],
   36:     )
   37:     retv = 0
   38: 
   39:     exclude = config['exclude']
   40:     if not exclude_matches_any(filenames, '', exclude):
   41:         print(
   42:             f'The global exclude pattern {exclude!r} does not match any files',
   43:         )
   44:         retv = 1
   45: 
   46:     for repo in config['repos']:
   47:         for hook in repo['hooks']:
   48:             # the default of manifest hooks is `types: [file]` but we may
   49:             # be configuring a symlink hook while there's a broken symlink
   50:             hook.setdefault('types', [])
   51:             # Not actually a manifest dict, but this more accurately reflects
   52:             # the defaults applied during runtime
   53:             hook = apply_defaults(hook, MANIFEST_HOOK_DICT)
   54:             names = classifier.by_types(
   55:                 classifier.filenames,
   56:                 hook['types'],
   57:                 hook['types_or'],
   58:                 hook['exclude_types'],
   59:             )
   60:             include, exclude = hook['files'], hook['exclude']
   61:             if not exclude_matches_any(names, include, exclude):
   62:                 print(
   63:                     f'The exclude pattern {exclude!r} for {hook["id"]} does '
   64:                     f'not match any files',
   65:                 )
   66:                 retv = 1
   67: 
   68:     return retv
   69: 
   70: 
   71: def main(argv: Sequence[str] | None = None) -> int:
   72:     parser = argparse.ArgumentParser()
   73:     parser.add_argument('filenames', nargs='*', default=[C.CONFIG_FILE])
   74:     args = parser.parse_args(argv)
   75: 
   76:     retv = 0
   77:     for filename in args.filenames:
   78:         retv |= check_useless_excludes(filename)
   79:     return retv
   80: 
   81: 
   82: if __name__ == '__main__':
   83:     raise SystemExit(main())
