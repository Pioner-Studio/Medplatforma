    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import logging
    5: import os.path
    6: import sqlite3
    7: import tempfile
    8: from collections.abc import Generator
    9: from collections.abc import Sequence
   10: from typing import Callable
   11: 
   12: import pre_commit.constants as C
   13: from pre_commit import clientlib
   14: from pre_commit import file_lock
   15: from pre_commit import git
   16: from pre_commit.util import CalledProcessError
   17: from pre_commit.util import clean_path_on_failure
   18: from pre_commit.util import cmd_output_b
   19: from pre_commit.util import resource_text
   20: from pre_commit.util import rmtree
   21: 
   22: 
   23: logger = logging.getLogger('pre_commit')
   24: 
   25: 
   26: def _get_default_directory() -> str:
   27:     """Returns the default directory for the Store.  This is intentionally
   28:     underscored to indicate that `Store.get_default_directory` is the intended
   29:     way to get this information.  This is also done so
   30:     `Store.get_default_directory` can be mocked in tests and
   31:     `_get_default_directory` can be tested.
   32:     """
   33:     ret = os.environ.get('PRE_COMMIT_HOME') or os.path.join(
   34:         os.environ.get('XDG_CACHE_HOME') or os.path.expanduser('~/.cache'),
   35:         'pre-commit',
   36:     )
   37:     return os.path.realpath(ret)
   38: 
   39: 
   40: _LOCAL_RESOURCES = (
   41:     'Cargo.toml', 'main.go', 'go.mod', 'main.rs', '.npmignore',
   42:     'package.json', 'pre-commit-package-dev-1.rockspec',
   43:     'pre_commit_placeholder_package.gemspec', 'setup.py',
   44:     'environment.yml', 'Makefile.PL', 'pubspec.yaml',
   45:     'renv.lock', 'renv/activate.R', 'renv/LICENSE.renv',
   46: )
   47: 
   48: 
   49: def _make_local_repo(directory: str) -> None:
   50:     for resource in _LOCAL_RESOURCES:
   51:         resource_dirname, resource_basename = os.path.split(resource)
   52:         contents = resource_text(f'empty_template_{resource_basename}')
   53:         target_dir = os.path.join(directory, resource_dirname)
   54:         target_file = os.path.join(target_dir, resource_basename)
   55:         os.makedirs(target_dir, exist_ok=True)
   56:         with open(target_file, 'w') as f:
   57:             f.write(contents)
   58: 
   59: 
   60: class Store:
   61:     get_default_directory = staticmethod(_get_default_directory)
   62: 
   63:     def __init__(self, directory: str | None = None) -> None:
   64:         self.directory = directory or Store.get_default_directory()
   65:         self.db_path = os.path.join(self.directory, 'db.db')
   66:         self.readonly = (
   67:             os.path.exists(self.directory) and
   68:             not os.access(self.directory, os.W_OK)
   69:         )
   70: 
   71:         if not os.path.exists(self.directory):
   72:             os.makedirs(self.directory, exist_ok=True)
   73:             with open(os.path.join(self.directory, 'README'), 'w') as f:
   74:                 f.write(
   75:                     'This directory is maintained by the pre-commit project.\n'
   76:                     'Learn more: https://github.com/pre-commit/pre-commit\n',
   77:                 )
   78: 
   79:         if os.path.exists(self.db_path):
   80:             return
   81:         with self.exclusive_lock():
   82:             # Another process may have already completed this work
   83:             if os.path.exists(self.db_path):  # pragma: no cover (race)
   84:                 return
   85:             # To avoid a race where someone ^Cs between db creation and
   86:             # execution of the CREATE TABLE statement
   87:             fd, tmpfile = tempfile.mkstemp(dir=self.directory)
   88:             # We'll be managing this file ourselves
   89:             os.close(fd)
   90:             with self.connect(db_path=tmpfile) as db:
   91:                 db.executescript(
   92:                     'CREATE TABLE repos ('
   93:                     '    repo TEXT NOT NULL,'
   94:                     '    ref TEXT NOT NULL,'
   95:                     '    path TEXT NOT NULL,'
   96:                     '    PRIMARY KEY (repo, ref)'
   97:                     ');',
   98:                 )
   99:                 self._create_config_table(db)
  100: 
  101:             # Atomic file move
  102:             os.replace(tmpfile, self.db_path)
  103: 
  104:     @contextlib.contextmanager
  105:     def exclusive_lock(self) -> Generator[None]:
  106:         def blocked_cb() -> None:  # pragma: no cover (tests are in-process)
  107:             logger.info('Locking pre-commit directory')
  108: 
  109:         with file_lock.lock(os.path.join(self.directory, '.lock'), blocked_cb):
  110:             yield
  111: 
  112:     @contextlib.contextmanager
  113:     def connect(
  114:             self,
  115:             db_path: str | None = None,
  116:     ) -> Generator[sqlite3.Connection]:
  117:         db_path = db_path or self.db_path
  118:         # sqlite doesn't close its fd with its contextmanager >.<
  119:         # contextlib.closing fixes this.
  120:         # See: https://stackoverflow.com/a/28032829/812183
  121:         with contextlib.closing(sqlite3.connect(db_path)) as db:
  122:             # this creates a transaction
  123:             with db:
  124:                 yield db
  125: 
  126:     @classmethod
  127:     def db_repo_name(cls, repo: str, deps: Sequence[str]) -> str:
  128:         if deps:
  129:             return f'{repo}:{",".join(deps)}'
  130:         else:
  131:             return repo
  132: 
  133:     def _new_repo(
  134:             self,
  135:             repo: str,
  136:             ref: str,
  137:             deps: Sequence[str],
  138:             make_strategy: Callable[[str], None],
  139:     ) -> str:
  140:         original_repo = repo
  141:         repo = self.db_repo_name(repo, deps)
  142: 
  143:         def _get_result() -> str | None:
  144:             # Check if we already exist
  145:             with self.connect() as db:
  146:                 result = db.execute(
  147:                     'SELECT path FROM repos WHERE repo = ? AND ref = ?',
  148:                     (repo, ref),
  149:                 ).fetchone()
  150:                 return result[0] if result else None
  151: 
  152:         result = _get_result()
  153:         if result:
  154:             return result
  155:         with self.exclusive_lock():
  156:             # Another process may have already completed this work
  157:             result = _get_result()
  158:             if result:  # pragma: no cover (race)
  159:                 return result
  160: 
  161:             logger.info(f'Initializing environment for {repo}.')
  162: 
  163:             directory = tempfile.mkdtemp(prefix='repo', dir=self.directory)
  164:             with clean_path_on_failure(directory):
  165:                 make_strategy(directory)
  166: 
  167:             # Update our db with the created repo
  168:             with self.connect() as db:
  169:                 db.execute(
  170:                     'INSERT INTO repos (repo, ref, path) VALUES (?, ?, ?)',
  171:                     [repo, ref, directory],
  172:                 )
  173: 
  174:             clientlib.warn_for_stages_on_repo_init(original_repo, directory)
  175: 
  176:         return directory
  177: 
  178:     def _complete_clone(self, ref: str, git_cmd: Callable[..., None]) -> None:
  179:         """Perform a complete clone of a repository and its submodules """
  180: 
  181:         git_cmd('fetch', 'origin', '--tags')
  182:         git_cmd('checkout', ref)
  183:         git_cmd('submodule', 'update', '--init', '--recursive')
  184: 
  185:     def _shallow_clone(self, ref: str, git_cmd: Callable[..., None]) -> None:
  186:         """Perform a shallow clone of a repository and its submodules """
  187: 
  188:         git_config = 'protocol.version=2'
  189:         git_cmd('-c', git_config, 'fetch', 'origin', ref, '--depth=1')
  190:         git_cmd('checkout', 'FETCH_HEAD')
  191:         git_cmd(
  192:             '-c', git_config, 'submodule', 'update', '--init', '--recursive',
  193:             '--depth=1',
  194:         )
  195: 
  196:     def clone(self, repo: str, ref: str, deps: Sequence[str] = ()) -> str:
  197:         """Clone the given url and checkout the specific ref."""
  198: 
  199:         def clone_strategy(directory: str) -> None:
  200:             git.init_repo(directory, repo)
  201:             env = git.no_git_env()
  202: 
  203:             def _git_cmd(*args: str) -> None:
  204:                 cmd_output_b('git', *args, cwd=directory, env=env)
  205: 
  206:             try:
  207:                 self._shallow_clone(ref, _git_cmd)
  208:             except CalledProcessError:
  209:                 self._complete_clone(ref, _git_cmd)
  210: 
  211:         return self._new_repo(repo, ref, deps, clone_strategy)
  212: 
  213:     def make_local(self, deps: Sequence[str]) -> str:
  214:         return self._new_repo(
  215:             'local', C.LOCAL_REPO_VERSION, deps, _make_local_repo,
  216:         )
  217: 
  218:     def _create_config_table(self, db: sqlite3.Connection) -> None:
  219:         db.executescript(
  220:             'CREATE TABLE IF NOT EXISTS configs ('
  221:             '   path TEXT NOT NULL,'
  222:             '   PRIMARY KEY (path)'
  223:             ');',
  224:         )
  225: 
  226:     def mark_config_used(self, path: str) -> None:
  227:         if self.readonly:  # pragma: win32 no cover
  228:             return
  229:         path = os.path.realpath(path)
  230:         # don't insert config files that do not exist
  231:         if not os.path.exists(path):
  232:             return
  233:         with self.connect() as db:
  234:             # TODO: eventually remove this and only create in _create
  235:             self._create_config_table(db)
  236:             db.execute('INSERT OR IGNORE INTO configs VALUES (?)', (path,))
  237: 
  238:     def select_all_configs(self) -> list[str]:
  239:         with self.connect() as db:
  240:             self._create_config_table(db)
  241:             rows = db.execute('SELECT path FROM configs').fetchall()
  242:             return [path for path, in rows]
  243: 
  244:     def delete_configs(self, configs: list[str]) -> None:
  245:         with self.connect() as db:
  246:             rows = [(path,) for path in configs]
  247:             db.executemany('DELETE FROM configs WHERE path = ?', rows)
  248: 
  249:     def select_all_repos(self) -> list[tuple[str, str, str]]:
  250:         with self.connect() as db:
  251:             return db.execute('SELECT repo, ref, path from repos').fetchall()
  252: 
  253:     def delete_repo(self, db_repo_name: str, ref: str, path: str) -> None:
  254:         with self.connect() as db:
  255:             db.execute(
  256:                 'DELETE FROM repos WHERE repo = ? and ref = ?',
  257:                 (db_repo_name, ref),
  258:             )
  259:         rmtree(path)
