    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import logging
    5: import os.path
    6: import time
    7: from collections.abc import Generator
    8: 
    9: from pre_commit import git
   10: from pre_commit.errors import FatalError
   11: from pre_commit.util import CalledProcessError
   12: from pre_commit.util import cmd_output
   13: from pre_commit.util import cmd_output_b
   14: from pre_commit.xargs import xargs
   15: 
   16: 
   17: logger = logging.getLogger('pre_commit')
   18: 
   19: # without forcing submodule.recurse=0, changes in nested submodules will be
   20: # discarded if `submodule.recurse=1` is configured
   21: # we choose this instead of `--no-recurse-submodules` because it works on
   22: # versions of git before that option was added to `git checkout`
   23: _CHECKOUT_CMD = ('git', '-c', 'submodule.recurse=0', 'checkout', '--', '.')
   24: 
   25: 
   26: def _git_apply(patch: str) -> None:
   27:     args = ('apply', '--whitespace=nowarn', patch)
   28:     try:
   29:         cmd_output_b('git', *args)
   30:     except CalledProcessError:
   31:         # Retry with autocrlf=false -- see #570
   32:         cmd_output_b('git', '-c', 'core.autocrlf=false', *args)
   33: 
   34: 
   35: @contextlib.contextmanager
   36: def _intent_to_add_cleared() -> Generator[None]:
   37:     intent_to_add = git.intent_to_add_files()
   38:     if intent_to_add:
   39:         logger.warning('Unstaged intent-to-add files detected.')
   40: 
   41:         xargs(('git', 'rm', '--cached', '--'), intent_to_add)
   42:         try:
   43:             yield
   44:         finally:
   45:             xargs(('git', 'add', '--intent-to-add', '--'), intent_to_add)
   46:     else:
   47:         yield
   48: 
   49: 
   50: @contextlib.contextmanager
   51: def _unstaged_changes_cleared(patch_dir: str) -> Generator[None]:
   52:     tree = cmd_output('git', 'write-tree')[1].strip()
   53:     diff_cmd = (
   54:         'git', 'diff-index', '--ignore-submodules', '--binary',
   55:         '--exit-code', '--no-color', '--no-ext-diff', tree, '--',
   56:     )
   57:     retcode, diff_stdout, diff_stderr = cmd_output_b(*diff_cmd, check=False)
   58:     if retcode == 0:
   59:         # There weren't any staged files so we don't need to do anything
   60:         # special
   61:         yield
   62:     elif retcode == 1 and not diff_stdout.strip():
   63:         # due to behaviour (probably a bug?) in git with crlf endings and
   64:         # autocrlf set to either `true` or `input` sometimes git will refuse
   65:         # to show a crlf-only diff to us :(
   66:         yield
   67:     elif retcode == 1 and diff_stdout.strip():
   68:         patch_filename = f'patch{int(time.time())}-{os.getpid()}'
   69:         patch_filename = os.path.join(patch_dir, patch_filename)
   70:         logger.warning('Unstaged files detected.')
   71:         logger.info(f'Stashing unstaged files to {patch_filename}.')
   72:         # Save the current unstaged changes as a patch
   73:         os.makedirs(patch_dir, exist_ok=True)
   74:         with open(patch_filename, 'wb') as patch_file:
   75:             patch_file.write(diff_stdout)
   76: 
   77:         # prevent recursive post-checkout hooks (#1418)
   78:         no_checkout_env = dict(os.environ, _PRE_COMMIT_SKIP_POST_CHECKOUT='1')
   79: 
   80:         try:
   81:             cmd_output_b(*_CHECKOUT_CMD, env=no_checkout_env)
   82:             yield
   83:         finally:
   84:             # Try to apply the patch we saved
   85:             try:
   86:                 _git_apply(patch_filename)
   87:             except CalledProcessError:
   88:                 logger.warning(
   89:                     'Stashed changes conflicted with hook auto-fixes... '
   90:                     'Rolling back fixes...',
   91:                 )
   92:                 # We failed to apply the patch, presumably due to fixes made
   93:                 # by hooks.
   94:                 # Roll back the changes made by hooks.
   95:                 cmd_output_b(*_CHECKOUT_CMD, env=no_checkout_env)
   96:                 _git_apply(patch_filename)
   97: 
   98:             logger.info(f'Restored changes from {patch_filename}.')
   99:     else:  # pragma: win32 no cover
  100:         # some error occurred while requesting the diff
  101:         e = CalledProcessError(retcode, diff_cmd, b'', diff_stderr)
  102:         raise FatalError(
  103:             f'pre-commit failed to diff -- perhaps due to permissions?\n\n{e}',
  104:         )
  105: 
  106: 
  107: @contextlib.contextmanager
  108: def staged_files_only(patch_dir: str) -> Generator[None]:
  109:     """Clear any unstaged changes from the git working directory inside this
  110:     context.
  111:     """
  112:     with _intent_to_add_cleared(), _unstaged_changes_cleared(patch_dir):
  113:         yield
