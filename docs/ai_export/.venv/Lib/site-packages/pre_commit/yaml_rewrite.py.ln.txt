    1: from __future__ import annotations
    2: 
    3: from collections.abc import Generator
    4: from collections.abc import Iterable
    5: from typing import NamedTuple
    6: from typing import Protocol
    7: 
    8: from yaml.nodes import MappingNode
    9: from yaml.nodes import Node
   10: from yaml.nodes import ScalarNode
   11: from yaml.nodes import SequenceNode
   12: 
   13: 
   14: class _Matcher(Protocol):
   15:     def match(self, n: Node) -> Generator[Node]: ...
   16: 
   17: 
   18: class MappingKey(NamedTuple):
   19:     k: str
   20: 
   21:     def match(self, n: Node) -> Generator[Node]:
   22:         if isinstance(n, MappingNode):
   23:             for k, _ in n.value:
   24:                 if k.value == self.k:
   25:                     yield k
   26: 
   27: 
   28: class MappingValue(NamedTuple):
   29:     k: str
   30: 
   31:     def match(self, n: Node) -> Generator[Node]:
   32:         if isinstance(n, MappingNode):
   33:             for k, v in n.value:
   34:                 if k.value == self.k:
   35:                     yield v
   36: 
   37: 
   38: class SequenceItem(NamedTuple):
   39:     def match(self, n: Node) -> Generator[Node]:
   40:         if isinstance(n, SequenceNode):
   41:             yield from n.value
   42: 
   43: 
   44: def _match(gen: Iterable[Node], m: _Matcher) -> Iterable[Node]:
   45:     return (n for src in gen for n in m.match(src))
   46: 
   47: 
   48: def match(n: Node, matcher: tuple[_Matcher, ...]) -> Generator[ScalarNode]:
   49:     gen: Iterable[Node] = (n,)
   50:     for m in matcher:
   51:         gen = _match(gen, m)
   52:     return (n for n in gen if isinstance(n, ScalarNode))
