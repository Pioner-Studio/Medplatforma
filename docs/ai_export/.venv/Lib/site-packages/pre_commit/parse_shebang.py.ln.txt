    1: from __future__ import annotations
    2: 
    3: import os.path
    4: from collections.abc import Mapping
    5: from typing import NoReturn
    6: 
    7: from identify.identify import parse_shebang_from_file
    8: 
    9: 
   10: class ExecutableNotFoundError(OSError):
   11:     def to_output(self) -> tuple[int, bytes, None]:
   12:         return (1, self.args[0].encode(), None)
   13: 
   14: 
   15: def parse_filename(filename: str) -> tuple[str, ...]:
   16:     if not os.path.exists(filename):
   17:         return ()
   18:     else:
   19:         return parse_shebang_from_file(filename)
   20: 
   21: 
   22: def find_executable(
   23:         exe: str, *, env: Mapping[str, str] | None = None,
   24: ) -> str | None:
   25:     exe = os.path.normpath(exe)
   26:     if os.sep in exe:
   27:         return exe
   28: 
   29:     environ = env if env is not None else os.environ
   30: 
   31:     if 'PATHEXT' in environ:
   32:         exts = environ['PATHEXT'].split(os.pathsep)
   33:         possible_exe_names = tuple(f'{exe}{ext}' for ext in exts) + (exe,)
   34:     else:
   35:         possible_exe_names = (exe,)
   36: 
   37:     for path in environ.get('PATH', '').split(os.pathsep):
   38:         for possible_exe_name in possible_exe_names:
   39:             joined = os.path.join(path, possible_exe_name)
   40:             if os.path.isfile(joined) and os.access(joined, os.X_OK):
   41:                 return joined
   42:     else:
   43:         return None
   44: 
   45: 
   46: def normexe(orig: str, *, env: Mapping[str, str] | None = None) -> str:
   47:     def _error(msg: str) -> NoReturn:
   48:         raise ExecutableNotFoundError(f'Executable `{orig}` {msg}')
   49: 
   50:     if os.sep not in orig and (not os.altsep or os.altsep not in orig):
   51:         exe = find_executable(orig, env=env)
   52:         if exe is None:
   53:             _error('not found')
   54:         return exe
   55:     elif os.path.isdir(orig):
   56:         _error('is a directory')
   57:     elif not os.path.isfile(orig):
   58:         _error('not found')
   59:     elif not os.access(orig, os.X_OK):  # pragma: win32 no cover
   60:         _error('is not executable')
   61:     else:
   62:         return orig
   63: 
   64: 
   65: def normalize_cmd(
   66:         cmd: tuple[str, ...],
   67:         *,
   68:         env: Mapping[str, str] | None = None,
   69: ) -> tuple[str, ...]:
   70:     """Fixes for the following issues on windows
   71:     - https://bugs.python.org/issue8557
   72:     - windows does not parse shebangs
   73: 
   74:     This function also makes deep-path shebangs work just fine
   75:     """
   76:     # Use PATH to determine the executable
   77:     exe = normexe(cmd[0], env=env)
   78: 
   79:     # Figure out the shebang from the resulting command
   80:     cmd = parse_filename(exe) + (exe,) + cmd[1:]
   81: 
   82:     # This could have given us back another bare executable
   83:     exe = normexe(cmd[0], env=env)
   84: 
   85:     return (exe,) + cmd[1:]
