    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import errno
    5: import sys
    6: from collections.abc import Generator
    7: from typing import Callable
    8: 
    9: 
   10: if sys.platform == 'win32':  # pragma: no cover (windows)
   11:     import msvcrt
   12: 
   13:     # https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/locking
   14: 
   15:     # on windows we lock "regions" of files, we don't care about the actual
   16:     # byte region so we'll just pick *some* number here.
   17:     _region = 0xffff
   18: 
   19:     @contextlib.contextmanager
   20:     def _locked(
   21:             fileno: int,
   22:             blocked_cb: Callable[[], None],
   23:     ) -> Generator[None]:
   24:         try:
   25:             msvcrt.locking(fileno, msvcrt.LK_NBLCK, _region)
   26:         except OSError:
   27:             blocked_cb()
   28:             while True:
   29:                 try:
   30:                     msvcrt.locking(fileno, msvcrt.LK_LOCK, _region)
   31:                 except OSError as e:
   32:                     # Locking violation. Returned when the _LK_LOCK or _LK_RLCK
   33:                     # flag is specified and the file cannot be locked after 10
   34:                     # attempts.
   35:                     if e.errno != errno.EDEADLOCK:
   36:                         raise
   37:                 else:
   38:                     break
   39: 
   40:         try:
   41:             yield
   42:         finally:
   43:             # From cursory testing, it seems to get unlocked when the file is
   44:             # closed so this may not be necessary.
   45:             # The documentation however states:
   46:             # "Regions should be locked only briefly and should be unlocked
   47:             # before closing a file or exiting the program."
   48:             msvcrt.locking(fileno, msvcrt.LK_UNLCK, _region)
   49: else:  # pragma: win32 no cover
   50:     import fcntl
   51: 
   52:     @contextlib.contextmanager
   53:     def _locked(
   54:             fileno: int,
   55:             blocked_cb: Callable[[], None],
   56:     ) -> Generator[None]:
   57:         try:
   58:             fcntl.flock(fileno, fcntl.LOCK_EX | fcntl.LOCK_NB)
   59:         except OSError:  # pragma: no cover (tests are single-threaded)
   60:             blocked_cb()
   61:             fcntl.flock(fileno, fcntl.LOCK_EX)
   62:         try:
   63:             yield
   64:         finally:
   65:             fcntl.flock(fileno, fcntl.LOCK_UN)
   66: 
   67: 
   68: @contextlib.contextmanager
   69: def lock(
   70:         path: str,
   71:         blocked_cb: Callable[[], None],
   72: ) -> Generator[None]:
   73:     with open(path, 'a+') as f:
   74:         with _locked(f.fileno(), blocked_cb):
   75:             yield
