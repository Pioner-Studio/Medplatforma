    1: from __future__ import annotations
    2: 
    3: import functools
    4: import logging
    5: import os.path
    6: import re
    7: import shlex
    8: import sys
    9: from collections.abc import Sequence
   10: from typing import Any
   11: from typing import NamedTuple
   12: 
   13: import cfgv
   14: from identify.identify import ALL_TAGS
   15: 
   16: import pre_commit.constants as C
   17: from pre_commit.all_languages import language_names
   18: from pre_commit.errors import FatalError
   19: from pre_commit.yaml import yaml_load
   20: 
   21: logger = logging.getLogger('pre_commit')
   22: 
   23: check_string_regex = cfgv.check_and(cfgv.check_string, cfgv.check_regex)
   24: 
   25: HOOK_TYPES = (
   26:     'commit-msg',
   27:     'post-checkout',
   28:     'post-commit',
   29:     'post-merge',
   30:     'post-rewrite',
   31:     'pre-commit',
   32:     'pre-merge-commit',
   33:     'pre-push',
   34:     'pre-rebase',
   35:     'prepare-commit-msg',
   36: )
   37: # `manual` is not invoked by any installed git hook.  See #719
   38: STAGES = (*HOOK_TYPES, 'manual')
   39: 
   40: 
   41: def check_type_tag(tag: str) -> None:
   42:     if tag not in ALL_TAGS:
   43:         raise cfgv.ValidationError(
   44:             f'Type tag {tag!r} is not recognized.  '
   45:             f'Try upgrading identify and pre-commit?',
   46:         )
   47: 
   48: 
   49: def parse_version(s: str) -> tuple[int, ...]:
   50:     """poor man's version comparison"""
   51:     return tuple(int(p) for p in s.split('.'))
   52: 
   53: 
   54: def check_min_version(version: str) -> None:
   55:     if parse_version(version) > parse_version(C.VERSION):
   56:         raise cfgv.ValidationError(
   57:             f'pre-commit version {version} is required but version '
   58:             f'{C.VERSION} is installed.  '
   59:             f'Perhaps run `pip install --upgrade pre-commit`.',
   60:         )
   61: 
   62: 
   63: _STAGES = {
   64:     'commit': 'pre-commit',
   65:     'merge-commit': 'pre-merge-commit',
   66:     'push': 'pre-push',
   67: }
   68: 
   69: 
   70: def transform_stage(stage: str) -> str:
   71:     return _STAGES.get(stage, stage)
   72: 
   73: 
   74: MINIMAL_MANIFEST_SCHEMA = cfgv.Array(
   75:     cfgv.Map(
   76:         'Hook', 'id',
   77:         cfgv.Required('id', cfgv.check_string),
   78:         cfgv.Optional('stages', cfgv.check_array(cfgv.check_string), []),
   79:     ),
   80: )
   81: 
   82: 
   83: def warn_for_stages_on_repo_init(repo: str, directory: str) -> None:
   84:     try:
   85:         manifest = cfgv.load_from_filename(
   86:             os.path.join(directory, C.MANIFEST_FILE),
   87:             schema=MINIMAL_MANIFEST_SCHEMA,
   88:             load_strategy=yaml_load,
   89:             exc_tp=InvalidManifestError,
   90:         )
   91:     except InvalidManifestError:
   92:         return  # they'll get a better error message when it actually loads!
   93: 
   94:     legacy_stages = {}  # sorted set
   95:     for hook in manifest:
   96:         for stage in hook.get('stages', ()):
   97:             if stage in _STAGES:
   98:                 legacy_stages[stage] = True
   99: 
  100:     if legacy_stages:
  101:         logger.warning(
  102:             f'repo `{repo}` uses deprecated stage names '
  103:             f'({", ".join(legacy_stages)}) which will be removed in a '
  104:             f'future version.  '
  105:             f'Hint: often `pre-commit autoupdate --repo {shlex.quote(repo)}` '
  106:             f'will fix this.  '
  107:             f'if it does not -- consider reporting an issue to that repo.',
  108:         )
  109: 
  110: 
  111: class StagesMigrationNoDefault(NamedTuple):
  112:     key: str
  113:     default: Sequence[str]
  114: 
  115:     def check(self, dct: dict[str, Any]) -> None:
  116:         if self.key not in dct:
  117:             return
  118: 
  119:         val = dct[self.key]
  120:         cfgv.check_array(cfgv.check_any)(val)
  121: 
  122:         val = [transform_stage(v) for v in val]
  123:         cfgv.check_array(cfgv.check_one_of(STAGES))(val)
  124: 
  125:     def apply_default(self, dct: dict[str, Any]) -> None:
  126:         if self.key not in dct:
  127:             return
  128:         dct[self.key] = [transform_stage(v) for v in dct[self.key]]
  129: 
  130:     def remove_default(self, dct: dict[str, Any]) -> None:
  131:         raise NotImplementedError
  132: 
  133: 
  134: class StagesMigration(StagesMigrationNoDefault):
  135:     def apply_default(self, dct: dict[str, Any]) -> None:
  136:         dct.setdefault(self.key, self.default)
  137:         super().apply_default(dct)
  138: 
  139: 
  140: class DeprecatedStagesWarning(NamedTuple):
  141:     key: str
  142: 
  143:     def check(self, dct: dict[str, Any]) -> None:
  144:         if self.key not in dct:
  145:             return
  146: 
  147:         val = dct[self.key]
  148:         cfgv.check_array(cfgv.check_any)(val)
  149: 
  150:         legacy_stages = [stage for stage in val if stage in _STAGES]
  151:         if legacy_stages:
  152:             logger.warning(
  153:                 f'hook id `{dct["id"]}` uses deprecated stage names '
  154:                 f'({", ".join(legacy_stages)}) which will be removed in a '
  155:                 f'future version.  '
  156:                 f'run: `pre-commit migrate-config` to automatically fix this.',
  157:             )
  158: 
  159:     def apply_default(self, dct: dict[str, Any]) -> None:
  160:         pass
  161: 
  162:     def remove_default(self, dct: dict[str, Any]) -> None:
  163:         raise NotImplementedError
  164: 
  165: 
  166: class DeprecatedDefaultStagesWarning(NamedTuple):
  167:     key: str
  168: 
  169:     def check(self, dct: dict[str, Any]) -> None:
  170:         if self.key not in dct:
  171:             return
  172: 
  173:         val = dct[self.key]
  174:         cfgv.check_array(cfgv.check_any)(val)
  175: 
  176:         legacy_stages = [stage for stage in val if stage in _STAGES]
  177:         if legacy_stages:
  178:             logger.warning(
  179:                 f'top-level `default_stages` uses deprecated stage names '
  180:                 f'({", ".join(legacy_stages)}) which will be removed in a '
  181:                 f'future version.  '
  182:                 f'run: `pre-commit migrate-config` to automatically fix this.',
  183:             )
  184: 
  185:     def apply_default(self, dct: dict[str, Any]) -> None:
  186:         pass
  187: 
  188:     def remove_default(self, dct: dict[str, Any]) -> None:
  189:         raise NotImplementedError
  190: 
  191: 
  192: MANIFEST_HOOK_DICT = cfgv.Map(
  193:     'Hook', 'id',
  194: 
  195:     # check first in case it uses some newer, incompatible feature
  196:     cfgv.Optional(
  197:         'minimum_pre_commit_version',
  198:         cfgv.check_and(cfgv.check_string, check_min_version),
  199:         '0',
  200:     ),
  201: 
  202:     cfgv.Required('id', cfgv.check_string),
  203:     cfgv.Required('name', cfgv.check_string),
  204:     cfgv.Required('entry', cfgv.check_string),
  205:     cfgv.Required('language', cfgv.check_one_of(language_names)),
  206:     cfgv.Optional('alias', cfgv.check_string, ''),
  207: 
  208:     cfgv.Optional('files', check_string_regex, ''),
  209:     cfgv.Optional('exclude', check_string_regex, '^$'),
  210:     cfgv.Optional('types', cfgv.check_array(check_type_tag), ['file']),
  211:     cfgv.Optional('types_or', cfgv.check_array(check_type_tag), []),
  212:     cfgv.Optional('exclude_types', cfgv.check_array(check_type_tag), []),
  213: 
  214:     cfgv.Optional(
  215:         'additional_dependencies', cfgv.check_array(cfgv.check_string), [],
  216:     ),
  217:     cfgv.Optional('args', cfgv.check_array(cfgv.check_string), []),
  218:     cfgv.Optional('always_run', cfgv.check_bool, False),
  219:     cfgv.Optional('fail_fast', cfgv.check_bool, False),
  220:     cfgv.Optional('pass_filenames', cfgv.check_bool, True),
  221:     cfgv.Optional('description', cfgv.check_string, ''),
  222:     cfgv.Optional('language_version', cfgv.check_string, C.DEFAULT),
  223:     cfgv.Optional('log_file', cfgv.check_string, ''),
  224:     cfgv.Optional('require_serial', cfgv.check_bool, False),
  225:     StagesMigration('stages', []),
  226:     cfgv.Optional('verbose', cfgv.check_bool, False),
  227: )
  228: MANIFEST_SCHEMA = cfgv.Array(MANIFEST_HOOK_DICT)
  229: 
  230: 
  231: class InvalidManifestError(FatalError):
  232:     pass
  233: 
  234: 
  235: load_manifest = functools.partial(
  236:     cfgv.load_from_filename,
  237:     schema=MANIFEST_SCHEMA,
  238:     load_strategy=yaml_load,
  239:     exc_tp=InvalidManifestError,
  240: )
  241: 
  242: 
  243: LOCAL = 'local'
  244: META = 'meta'
  245: 
  246: 
  247: class WarnMutableRev(cfgv.Conditional):
  248:     def check(self, dct: dict[str, Any]) -> None:
  249:         super().check(dct)
  250: 
  251:         if self.key in dct:
  252:             rev = dct[self.key]
  253: 
  254:             if '.' not in rev and not re.match(r'^[a-fA-F0-9]+$', rev):
  255:                 logger.warning(
  256:                     f'The {self.key!r} field of repo {dct["repo"]!r} '
  257:                     f'appears to be a mutable reference '
  258:                     f'(moving tag / branch).  Mutable references are never '
  259:                     f'updated after first install and are not supported.  '
  260:                     f'See https://pre-commit.com/#using-the-latest-version-for-a-repository '  # noqa: E501
  261:                     f'for more details.  '
  262:                     f'Hint: `pre-commit autoupdate` often fixes this.',
  263:                 )
  264: 
  265: 
  266: class OptionalSensibleRegexAtHook(cfgv.OptionalNoDefault):
  267:     def check(self, dct: dict[str, Any]) -> None:
  268:         super().check(dct)
  269: 
  270:         if '/*' in dct.get(self.key, ''):
  271:             logger.warning(
  272:                 f'The {self.key!r} field in hook {dct.get("id")!r} is a '
  273:                 f"regex, not a glob -- matching '/*' probably isn't what you "
  274:                 f'want here',
  275:             )
  276:         for fwd_slash_re in (r'[\\/]', r'[\/]', r'[/\\]'):
  277:             if fwd_slash_re in dct.get(self.key, ''):
  278:                 logger.warning(
  279:                     fr'pre-commit normalizes slashes in the {self.key!r} '
  280:                     fr'field in hook {dct.get("id")!r} to forward slashes, '
  281:                     fr'so you can use / instead of {fwd_slash_re}',
  282:                 )
  283: 
  284: 
  285: class OptionalSensibleRegexAtTop(cfgv.OptionalNoDefault):
  286:     def check(self, dct: dict[str, Any]) -> None:
  287:         super().check(dct)
  288: 
  289:         if '/*' in dct.get(self.key, ''):
  290:             logger.warning(
  291:                 f'The top-level {self.key!r} field is a regex, not a glob -- '
  292:                 f"matching '/*' probably isn't what you want here",
  293:             )
  294:         for fwd_slash_re in (r'[\\/]', r'[\/]', r'[/\\]'):
  295:             if fwd_slash_re in dct.get(self.key, ''):
  296:                 logger.warning(
  297:                     fr'pre-commit normalizes the slashes in the top-level '
  298:                     fr'{self.key!r} field to forward slashes, so you '
  299:                     fr'can use / instead of {fwd_slash_re}',
  300:                 )
  301: 
  302: 
  303: def _entry(modname: str) -> str:
  304:     """the hook `entry` is passed through `shlex.split()` by the command
  305:     runner, so to prevent issues with spaces and backslashes (on Windows)
  306:     it must be quoted here.
  307:     """
  308:     return f'{shlex.quote(sys.executable)} -m pre_commit.meta_hooks.{modname}'
  309: 
  310: 
  311: def warn_unknown_keys_root(
  312:         extra: Sequence[str],
  313:         orig_keys: Sequence[str],
  314:         dct: dict[str, str],
  315: ) -> None:
  316:     logger.warning(f'Unexpected key(s) present at root: {", ".join(extra)}')
  317: 
  318: 
  319: def warn_unknown_keys_repo(
  320:         extra: Sequence[str],
  321:         orig_keys: Sequence[str],
  322:         dct: dict[str, str],
  323: ) -> None:
  324:     logger.warning(
  325:         f'Unexpected key(s) present on {dct["repo"]}: {", ".join(extra)}',
  326:     )
  327: 
  328: 
  329: _meta = (
  330:     (
  331:         'check-hooks-apply', (
  332:             ('name', 'Check hooks apply to the repository'),
  333:             ('files', f'^{re.escape(C.CONFIG_FILE)}$'),
  334:             ('entry', _entry('check_hooks_apply')),
  335:         ),
  336:     ),
  337:     (
  338:         'check-useless-excludes', (
  339:             ('name', 'Check for useless excludes'),
  340:             ('files', f'^{re.escape(C.CONFIG_FILE)}$'),
  341:             ('entry', _entry('check_useless_excludes')),
  342:         ),
  343:     ),
  344:     (
  345:         'identity', (
  346:             ('name', 'identity'),
  347:             ('verbose', True),
  348:             ('entry', _entry('identity')),
  349:         ),
  350:     ),
  351: )
  352: 
  353: 
  354: class NotAllowed(cfgv.OptionalNoDefault):
  355:     def check(self, dct: dict[str, Any]) -> None:
  356:         if self.key in dct:
  357:             raise cfgv.ValidationError(f'{self.key!r} cannot be overridden')
  358: 
  359: 
  360: _COMMON_HOOK_WARNINGS = (
  361:     OptionalSensibleRegexAtHook('files', cfgv.check_string),
  362:     OptionalSensibleRegexAtHook('exclude', cfgv.check_string),
  363:     DeprecatedStagesWarning('stages'),
  364: )
  365: 
  366: META_HOOK_DICT = cfgv.Map(
  367:     'Hook', 'id',
  368:     cfgv.Required('id', cfgv.check_string),
  369:     cfgv.Required('id', cfgv.check_one_of(tuple(k for k, _ in _meta))),
  370:     # language must be system
  371:     cfgv.Optional('language', cfgv.check_one_of({'system'}), 'system'),
  372:     # entry cannot be overridden
  373:     NotAllowed('entry', cfgv.check_any),
  374:     *(
  375:         # default to the hook definition for the meta hooks
  376:         cfgv.ConditionalOptional(key, cfgv.check_any, value, 'id', hook_id)
  377:         for hook_id, values in _meta
  378:         for key, value in values
  379:     ),
  380:     *(
  381:         # default to the "manifest" parsing
  382:         cfgv.OptionalNoDefault(item.key, item.check_fn)
  383:         # these will always be defaulted above
  384:         if item.key in {'name', 'language', 'entry'} else
  385:         item
  386:         for item in MANIFEST_HOOK_DICT.items
  387:     ),
  388:     *_COMMON_HOOK_WARNINGS,
  389: )
  390: CONFIG_HOOK_DICT = cfgv.Map(
  391:     'Hook', 'id',
  392: 
  393:     cfgv.Required('id', cfgv.check_string),
  394: 
  395:     # All keys in manifest hook dict are valid in a config hook dict, but
  396:     # are optional.
  397:     # No defaults are provided here as the config is merged on top of the
  398:     # manifest.
  399:     *(
  400:         cfgv.OptionalNoDefault(item.key, item.check_fn)
  401:         for item in MANIFEST_HOOK_DICT.items
  402:         if item.key != 'id'
  403:         if item.key != 'stages'
  404:     ),
  405:     StagesMigrationNoDefault('stages', []),
  406:     *_COMMON_HOOK_WARNINGS,
  407: )
  408: LOCAL_HOOK_DICT = cfgv.Map(
  409:     'Hook', 'id',
  410: 
  411:     *MANIFEST_HOOK_DICT.items,
  412:     *_COMMON_HOOK_WARNINGS,
  413: )
  414: CONFIG_REPO_DICT = cfgv.Map(
  415:     'Repository', 'repo',
  416: 
  417:     cfgv.Required('repo', cfgv.check_string),
  418: 
  419:     cfgv.ConditionalRecurse(
  420:         'hooks', cfgv.Array(CONFIG_HOOK_DICT),
  421:         'repo', cfgv.NotIn(LOCAL, META),
  422:     ),
  423:     cfgv.ConditionalRecurse(
  424:         'hooks', cfgv.Array(LOCAL_HOOK_DICT),
  425:         'repo', LOCAL,
  426:     ),
  427:     cfgv.ConditionalRecurse(
  428:         'hooks', cfgv.Array(META_HOOK_DICT),
  429:         'repo', META,
  430:     ),
  431: 
  432:     WarnMutableRev(
  433:         'rev', cfgv.check_string,
  434:         condition_key='repo',
  435:         condition_value=cfgv.NotIn(LOCAL, META),
  436:         ensure_absent=True,
  437:     ),
  438:     cfgv.WarnAdditionalKeys(('repo', 'rev', 'hooks'), warn_unknown_keys_repo),
  439: )
  440: DEFAULT_LANGUAGE_VERSION = cfgv.Map(
  441:     'DefaultLanguageVersion', None,
  442:     cfgv.NoAdditionalKeys(language_names),
  443:     *(cfgv.Optional(x, cfgv.check_string, C.DEFAULT) for x in language_names),
  444: )
  445: CONFIG_SCHEMA = cfgv.Map(
  446:     'Config', None,
  447: 
  448:     # check first in case it uses some newer, incompatible feature
  449:     cfgv.Optional(
  450:         'minimum_pre_commit_version',
  451:         cfgv.check_and(cfgv.check_string, check_min_version),
  452:         '0',
  453:     ),
  454: 
  455:     cfgv.RequiredRecurse('repos', cfgv.Array(CONFIG_REPO_DICT)),
  456:     cfgv.Optional(
  457:         'default_install_hook_types',
  458:         cfgv.check_array(cfgv.check_one_of(HOOK_TYPES)),
  459:         ['pre-commit'],
  460:     ),
  461:     cfgv.OptionalRecurse(
  462:         'default_language_version', DEFAULT_LANGUAGE_VERSION, {},
  463:     ),
  464:     StagesMigration('default_stages', STAGES),
  465:     DeprecatedDefaultStagesWarning('default_stages'),
  466:     cfgv.Optional('files', check_string_regex, ''),
  467:     cfgv.Optional('exclude', check_string_regex, '^$'),
  468:     cfgv.Optional('fail_fast', cfgv.check_bool, False),
  469:     cfgv.WarnAdditionalKeys(
  470:         (
  471:             'repos',
  472:             'default_install_hook_types',
  473:             'default_language_version',
  474:             'default_stages',
  475:             'files',
  476:             'exclude',
  477:             'fail_fast',
  478:             'minimum_pre_commit_version',
  479:             'ci',
  480:         ),
  481:         warn_unknown_keys_root,
  482:     ),
  483:     OptionalSensibleRegexAtTop('files', cfgv.check_string),
  484:     OptionalSensibleRegexAtTop('exclude', cfgv.check_string),
  485: 
  486:     # do not warn about configuration for pre-commit.ci
  487:     cfgv.OptionalNoDefault('ci', cfgv.check_type(dict)),
  488: )
  489: 
  490: 
  491: class InvalidConfigError(FatalError):
  492:     pass
  493: 
  494: 
  495: load_config = functools.partial(
  496:     cfgv.load_from_filename,
  497:     schema=CONFIG_SCHEMA,
  498:     load_strategy=yaml_load,
  499:     exc_tp=InvalidConfigError,
  500: )
