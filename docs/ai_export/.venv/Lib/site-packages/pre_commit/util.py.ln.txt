    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import errno
    5: import importlib.resources
    6: import os.path
    7: import shutil
    8: import stat
    9: import subprocess
   10: import sys
   11: from collections.abc import Generator
   12: from types import TracebackType
   13: from typing import Any
   14: from typing import Callable
   15: 
   16: from pre_commit import parse_shebang
   17: 
   18: 
   19: def force_bytes(exc: Any) -> bytes:
   20:     with contextlib.suppress(TypeError):
   21:         return bytes(exc)
   22:     with contextlib.suppress(Exception):
   23:         return str(exc).encode()
   24:     return f'<unprintable {type(exc).__name__} object>'.encode()
   25: 
   26: 
   27: @contextlib.contextmanager
   28: def clean_path_on_failure(path: str) -> Generator[None]:
   29:     """Cleans up the directory on an exceptional failure."""
   30:     try:
   31:         yield
   32:     except BaseException:
   33:         if os.path.exists(path):
   34:             rmtree(path)
   35:         raise
   36: 
   37: 
   38: def resource_text(filename: str) -> str:
   39:     files = importlib.resources.files('pre_commit.resources')
   40:     return files.joinpath(filename).read_text()
   41: 
   42: 
   43: def make_executable(filename: str) -> None:
   44:     original_mode = os.stat(filename).st_mode
   45:     new_mode = original_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH
   46:     os.chmod(filename, new_mode)
   47: 
   48: 
   49: class CalledProcessError(RuntimeError):
   50:     def __init__(
   51:             self,
   52:             returncode: int,
   53:             cmd: tuple[str, ...],
   54:             stdout: bytes,
   55:             stderr: bytes | None,
   56:     ) -> None:
   57:         super().__init__(returncode, cmd, stdout, stderr)
   58:         self.returncode = returncode
   59:         self.cmd = cmd
   60:         self.stdout = stdout
   61:         self.stderr = stderr
   62: 
   63:     def __bytes__(self) -> bytes:
   64:         def _indent_or_none(part: bytes | None) -> bytes:
   65:             if part:
   66:                 return b'\n    ' + part.replace(b'\n', b'\n    ').rstrip()
   67:             else:
   68:                 return b' (none)'
   69: 
   70:         return b''.join((
   71:             f'command: {self.cmd!r}\n'.encode(),
   72:             f'return code: {self.returncode}\n'.encode(),
   73:             b'stdout:', _indent_or_none(self.stdout), b'\n',
   74:             b'stderr:', _indent_or_none(self.stderr),
   75:         ))
   76: 
   77:     def __str__(self) -> str:
   78:         return self.__bytes__().decode()
   79: 
   80: 
   81: def _setdefault_kwargs(kwargs: dict[str, Any]) -> None:
   82:     for arg in ('stdin', 'stdout', 'stderr'):
   83:         kwargs.setdefault(arg, subprocess.PIPE)
   84: 
   85: 
   86: def _oserror_to_output(e: OSError) -> tuple[int, bytes, None]:
   87:     return 1, force_bytes(e).rstrip(b'\n') + b'\n', None
   88: 
   89: 
   90: def cmd_output_b(
   91:         *cmd: str,
   92:         check: bool = True,
   93:         **kwargs: Any,
   94: ) -> tuple[int, bytes, bytes | None]:
   95:     _setdefault_kwargs(kwargs)
   96: 
   97:     try:
   98:         cmd = parse_shebang.normalize_cmd(cmd, env=kwargs.get('env'))
   99:     except parse_shebang.ExecutableNotFoundError as e:
  100:         returncode, stdout_b, stderr_b = e.to_output()
  101:     else:
  102:         try:
  103:             proc = subprocess.Popen(cmd, **kwargs)
  104:         except OSError as e:
  105:             returncode, stdout_b, stderr_b = _oserror_to_output(e)
  106:         else:
  107:             stdout_b, stderr_b = proc.communicate()
  108:             returncode = proc.returncode
  109: 
  110:     if check and returncode:
  111:         raise CalledProcessError(returncode, cmd, stdout_b, stderr_b)
  112: 
  113:     return returncode, stdout_b, stderr_b
  114: 
  115: 
  116: def cmd_output(*cmd: str, **kwargs: Any) -> tuple[int, str, str | None]:
  117:     returncode, stdout_b, stderr_b = cmd_output_b(*cmd, **kwargs)
  118:     stdout = stdout_b.decode() if stdout_b is not None else None
  119:     stderr = stderr_b.decode() if stderr_b is not None else None
  120:     return returncode, stdout, stderr
  121: 
  122: 
  123: if sys.platform != 'win32':  # pragma: win32 no cover
  124:     from os import openpty
  125:     import termios
  126: 
  127:     class Pty:
  128:         def __init__(self) -> None:
  129:             self.r: int | None = None
  130:             self.w: int | None = None
  131: 
  132:         def __enter__(self) -> Pty:
  133:             self.r, self.w = openpty()
  134: 
  135:             # tty flags normally change \n to \r\n
  136:             attrs = termios.tcgetattr(self.w)
  137:             assert isinstance(attrs[1], int)
  138:             attrs[1] &= ~(termios.ONLCR | termios.OPOST)
  139:             termios.tcsetattr(self.w, termios.TCSANOW, attrs)
  140: 
  141:             return self
  142: 
  143:         def close_w(self) -> None:
  144:             if self.w is not None:
  145:                 os.close(self.w)
  146:                 self.w = None
  147: 
  148:         def close_r(self) -> None:
  149:             assert self.r is not None
  150:             os.close(self.r)
  151:             self.r = None
  152: 
  153:         def __exit__(
  154:                 self,
  155:                 exc_type: type[BaseException] | None,
  156:                 exc_value: BaseException | None,
  157:                 traceback: TracebackType | None,
  158:         ) -> None:
  159:             self.close_w()
  160:             self.close_r()
  161: 
  162:     def cmd_output_p(
  163:             *cmd: str,
  164:             check: bool = True,
  165:             **kwargs: Any,
  166:     ) -> tuple[int, bytes, bytes | None]:
  167:         assert check is False
  168:         assert kwargs['stderr'] == subprocess.STDOUT, kwargs['stderr']
  169:         _setdefault_kwargs(kwargs)
  170: 
  171:         try:
  172:             cmd = parse_shebang.normalize_cmd(cmd)
  173:         except parse_shebang.ExecutableNotFoundError as e:
  174:             return e.to_output()
  175: 
  176:         with open(os.devnull) as devnull, Pty() as pty:
  177:             assert pty.r is not None
  178:             kwargs.update({'stdin': devnull, 'stdout': pty.w, 'stderr': pty.w})
  179:             try:
  180:                 proc = subprocess.Popen(cmd, **kwargs)
  181:             except OSError as e:
  182:                 return _oserror_to_output(e)
  183: 
  184:             pty.close_w()
  185: 
  186:             buf = b''
  187:             while True:
  188:                 try:
  189:                     bts = os.read(pty.r, 4096)
  190:                 except OSError as e:
  191:                     if e.errno == errno.EIO:
  192:                         bts = b''
  193:                     else:
  194:                         raise
  195:                 else:
  196:                     buf += bts
  197:                 if not bts:
  198:                     break
  199: 
  200:         return proc.wait(), buf, None
  201: else:  # pragma: no cover
  202:     cmd_output_p = cmd_output_b
  203: 
  204: 
  205: def _handle_readonly(
  206:         func: Callable[[str], object],
  207:         path: str,
  208:         exc: BaseException,
  209: ) -> None:
  210:     if (
  211:             func in (os.rmdir, os.remove, os.unlink) and
  212:             isinstance(exc, OSError) and
  213:             exc.errno in {errno.EACCES, errno.EPERM}
  214:     ):
  215:         for p in (path, os.path.dirname(path)):
  216:             os.chmod(p, os.stat(p).st_mode | stat.S_IWUSR)
  217:         func(path)
  218:     else:
  219:         raise
  220: 
  221: 
  222: if sys.version_info < (3, 12):  # pragma: <3.12 cover
  223:     def _handle_readonly_old(
  224:         func: Callable[[str], object],
  225:         path: str,
  226:         excinfo: tuple[type[BaseException], BaseException, TracebackType],
  227:     ) -> None:
  228:         return _handle_readonly(func, path, excinfo[1])
  229: 
  230:     def rmtree(path: str) -> None:
  231:         shutil.rmtree(path, ignore_errors=False, onerror=_handle_readonly_old)
  232: else:  # pragma: >=3.12 cover
  233:     def rmtree(path: str) -> None:
  234:         """On windows, rmtree fails for readonly dirs."""
  235:         shutil.rmtree(path, ignore_errors=False, onexc=_handle_readonly)
  236: 
  237: 
  238: def win_exe(s: str) -> str:
  239:     return s if sys.platform != 'win32' else f'{s}.exe'
