    1: from __future__ import annotations
    2: 
    3: import functools
    4: import itertools
    5: import textwrap
    6: from typing import Callable
    7: 
    8: import cfgv
    9: import yaml
   10: from yaml.nodes import ScalarNode
   11: 
   12: from pre_commit.clientlib import InvalidConfigError
   13: from pre_commit.yaml import yaml_compose
   14: from pre_commit.yaml import yaml_load
   15: from pre_commit.yaml_rewrite import MappingKey
   16: from pre_commit.yaml_rewrite import MappingValue
   17: from pre_commit.yaml_rewrite import match
   18: from pre_commit.yaml_rewrite import SequenceItem
   19: 
   20: 
   21: def _is_header_line(line: str) -> bool:
   22:     return line.startswith(('#', '---')) or not line.strip()
   23: 
   24: 
   25: def _migrate_map(contents: str) -> str:
   26:     if isinstance(yaml_load(contents), list):
   27:         # Find the first non-header line
   28:         lines = contents.splitlines(True)
   29:         i = 0
   30:         # Only loop on non empty configuration file
   31:         while i < len(lines) and _is_header_line(lines[i]):
   32:             i += 1
   33: 
   34:         header = ''.join(lines[:i])
   35:         rest = ''.join(lines[i:])
   36: 
   37:         # If they are using the "default" flow style of yaml, this operation
   38:         # will yield a valid configuration
   39:         try:
   40:             trial_contents = f'{header}repos:\n{rest}'
   41:             yaml_load(trial_contents)
   42:             contents = trial_contents
   43:         except yaml.YAMLError:
   44:             contents = f'{header}repos:\n{textwrap.indent(rest, " " * 4)}'
   45: 
   46:     return contents
   47: 
   48: 
   49: def _preserve_style(n: ScalarNode, *, s: str) -> str:
   50:     style = n.style or ''
   51:     return f'{style}{s}{style}'
   52: 
   53: 
   54: def _fix_stage(n: ScalarNode) -> str:
   55:     return _preserve_style(n, s=f'pre-{n.value}')
   56: 
   57: 
   58: def _migrate_composed(contents: str) -> str:
   59:     tree = yaml_compose(contents)
   60:     rewrites: list[tuple[ScalarNode, Callable[[ScalarNode], str]]] = []
   61: 
   62:     # sha -> rev
   63:     sha_to_rev_replace = functools.partial(_preserve_style, s='rev')
   64:     sha_to_rev_matcher = (
   65:         MappingValue('repos'),
   66:         SequenceItem(),
   67:         MappingKey('sha'),
   68:     )
   69:     for node in match(tree, sha_to_rev_matcher):
   70:         rewrites.append((node, sha_to_rev_replace))
   71: 
   72:     # python_venv -> python
   73:     language_matcher = (
   74:         MappingValue('repos'),
   75:         SequenceItem(),
   76:         MappingValue('hooks'),
   77:         SequenceItem(),
   78:         MappingValue('language'),
   79:     )
   80:     python_venv_replace = functools.partial(_preserve_style, s='python')
   81:     for node in match(tree, language_matcher):
   82:         if node.value == 'python_venv':
   83:             rewrites.append((node, python_venv_replace))
   84: 
   85:     # stages rewrites
   86:     default_stages_matcher = (MappingValue('default_stages'), SequenceItem())
   87:     default_stages_match = match(tree, default_stages_matcher)
   88:     hook_stages_matcher = (
   89:         MappingValue('repos'),
   90:         SequenceItem(),
   91:         MappingValue('hooks'),
   92:         SequenceItem(),
   93:         MappingValue('stages'),
   94:         SequenceItem(),
   95:     )
   96:     hook_stages_match = match(tree, hook_stages_matcher)
   97:     for node in itertools.chain(default_stages_match, hook_stages_match):
   98:         if node.value in {'commit', 'push', 'merge-commit'}:
   99:             rewrites.append((node, _fix_stage))
  100: 
  101:     rewrites.sort(reverse=True, key=lambda nf: nf[0].start_mark.index)
  102: 
  103:     src_parts = []
  104:     end: int | None = None
  105:     for node, func in rewrites:
  106:         src_parts.append(contents[node.end_mark.index:end])
  107:         src_parts.append(func(node))
  108:         end = node.start_mark.index
  109:     src_parts.append(contents[:end])
  110:     src_parts.reverse()
  111:     return ''.join(src_parts)
  112: 
  113: 
  114: def migrate_config(config_file: str, quiet: bool = False) -> int:
  115:     with open(config_file) as f:
  116:         orig_contents = contents = f.read()
  117: 
  118:     with cfgv.reraise_as(InvalidConfigError):
  119:         with cfgv.validate_context(f'File {config_file}'):
  120:             try:
  121:                 yaml_load(orig_contents)
  122:             except Exception as e:
  123:                 raise cfgv.ValidationError(str(e))
  124: 
  125:     contents = _migrate_map(contents)
  126:     contents = _migrate_composed(contents)
  127: 
  128:     if contents != orig_contents:
  129:         with open(config_file, 'w') as f:
  130:             f.write(contents)
  131: 
  132:         print('Configuration has been migrated.')
  133:     elif not quiet:
  134:         print('Configuration is already migrated.')
  135:     return 0
