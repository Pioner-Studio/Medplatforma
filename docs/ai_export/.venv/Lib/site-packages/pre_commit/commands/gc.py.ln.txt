    1: from __future__ import annotations
    2: 
    3: import os.path
    4: from typing import Any
    5: 
    6: import pre_commit.constants as C
    7: from pre_commit import output
    8: from pre_commit.clientlib import InvalidConfigError
    9: from pre_commit.clientlib import InvalidManifestError
   10: from pre_commit.clientlib import load_config
   11: from pre_commit.clientlib import load_manifest
   12: from pre_commit.clientlib import LOCAL
   13: from pre_commit.clientlib import META
   14: from pre_commit.store import Store
   15: 
   16: 
   17: def _mark_used_repos(
   18:         store: Store,
   19:         all_repos: dict[tuple[str, str], str],
   20:         unused_repos: set[tuple[str, str]],
   21:         repo: dict[str, Any],
   22: ) -> None:
   23:     if repo['repo'] == META:
   24:         return
   25:     elif repo['repo'] == LOCAL:
   26:         for hook in repo['hooks']:
   27:             deps = hook.get('additional_dependencies')
   28:             unused_repos.discard((
   29:                 store.db_repo_name(repo['repo'], deps), C.LOCAL_REPO_VERSION,
   30:             ))
   31:     else:
   32:         key = (repo['repo'], repo['rev'])
   33:         path = all_repos.get(key)
   34:         # can't inspect manifest if it isn't cloned
   35:         if path is None:
   36:             return
   37: 
   38:         try:
   39:             manifest = load_manifest(os.path.join(path, C.MANIFEST_FILE))
   40:         except InvalidManifestError:
   41:             return
   42:         else:
   43:             unused_repos.discard(key)
   44:             by_id = {hook['id']: hook for hook in manifest}
   45: 
   46:         for hook in repo['hooks']:
   47:             if hook['id'] not in by_id:
   48:                 continue
   49: 
   50:             deps = hook.get(
   51:                 'additional_dependencies',
   52:                 by_id[hook['id']]['additional_dependencies'],
   53:             )
   54:             unused_repos.discard((
   55:                 store.db_repo_name(repo['repo'], deps), repo['rev'],
   56:             ))
   57: 
   58: 
   59: def _gc_repos(store: Store) -> int:
   60:     configs = store.select_all_configs()
   61:     repos = store.select_all_repos()
   62: 
   63:     # delete config paths which do not exist
   64:     dead_configs = [p for p in configs if not os.path.exists(p)]
   65:     live_configs = [p for p in configs if os.path.exists(p)]
   66: 
   67:     all_repos = {(repo, ref): path for repo, ref, path in repos}
   68:     unused_repos = set(all_repos)
   69:     for config_path in live_configs:
   70:         try:
   71:             config = load_config(config_path)
   72:         except InvalidConfigError:
   73:             dead_configs.append(config_path)
   74:             continue
   75:         else:
   76:             for repo in config['repos']:
   77:                 _mark_used_repos(store, all_repos, unused_repos, repo)
   78: 
   79:     store.delete_configs(dead_configs)
   80:     for db_repo_name, ref in unused_repos:
   81:         store.delete_repo(db_repo_name, ref, all_repos[(db_repo_name, ref)])
   82:     return len(unused_repos)
   83: 
   84: 
   85: def gc(store: Store) -> int:
   86:     with store.exclusive_lock():
   87:         repos_removed = _gc_repos(store)
   88:     output.write_line(f'{repos_removed} repo(s) removed.')
   89:     return 0
