    1: from __future__ import annotations
    2: 
    3: import concurrent.futures
    4: import os.path
    5: import re
    6: import tempfile
    7: from collections.abc import Sequence
    8: from typing import Any
    9: from typing import NamedTuple
   10: 
   11: import pre_commit.constants as C
   12: from pre_commit import git
   13: from pre_commit import output
   14: from pre_commit import xargs
   15: from pre_commit.clientlib import InvalidManifestError
   16: from pre_commit.clientlib import load_config
   17: from pre_commit.clientlib import load_manifest
   18: from pre_commit.clientlib import LOCAL
   19: from pre_commit.clientlib import META
   20: from pre_commit.commands.migrate_config import migrate_config
   21: from pre_commit.util import CalledProcessError
   22: from pre_commit.util import cmd_output
   23: from pre_commit.util import cmd_output_b
   24: from pre_commit.yaml import yaml_dump
   25: from pre_commit.yaml import yaml_load
   26: 
   27: 
   28: class RevInfo(NamedTuple):
   29:     repo: str
   30:     rev: str
   31:     frozen: str | None = None
   32:     hook_ids: frozenset[str] = frozenset()
   33: 
   34:     @classmethod
   35:     def from_config(cls, config: dict[str, Any]) -> RevInfo:
   36:         return cls(config['repo'], config['rev'])
   37: 
   38:     def update(self, tags_only: bool, freeze: bool) -> RevInfo:
   39:         with tempfile.TemporaryDirectory() as tmp:
   40:             _git = ('git', *git.NO_FS_MONITOR, '-C', tmp)
   41: 
   42:             if tags_only:
   43:                 tag_opt = '--abbrev=0'
   44:             else:
   45:                 tag_opt = '--exact'
   46:             tag_cmd = (*_git, 'describe', 'FETCH_HEAD', '--tags', tag_opt)
   47: 
   48:             git.init_repo(tmp, self.repo)
   49:             cmd_output_b(*_git, 'config', 'extensions.partialClone', 'true')
   50:             cmd_output_b(
   51:                 *_git, 'fetch', 'origin', 'HEAD',
   52:                 '--quiet', '--filter=blob:none', '--tags',
   53:             )
   54: 
   55:             try:
   56:                 rev = cmd_output(*tag_cmd)[1].strip()
   57:             except CalledProcessError:
   58:                 rev = cmd_output(*_git, 'rev-parse', 'FETCH_HEAD')[1].strip()
   59:             else:
   60:                 if tags_only:
   61:                     rev = git.get_best_candidate_tag(rev, tmp)
   62: 
   63:             frozen = None
   64:             if freeze:
   65:                 exact = cmd_output(*_git, 'rev-parse', rev)[1].strip()
   66:                 if exact != rev:
   67:                     rev, frozen = exact, rev
   68: 
   69:             try:
   70:                 # workaround for windows -- see #2865
   71:                 cmd_output_b(*_git, 'show', f'{rev}:{C.MANIFEST_FILE}')
   72:                 cmd_output(*_git, 'checkout', rev, '--', C.MANIFEST_FILE)
   73:             except CalledProcessError:
   74:                 pass  # this will be caught by manifest validating code
   75:             try:
   76:                 manifest = load_manifest(os.path.join(tmp, C.MANIFEST_FILE))
   77:             except InvalidManifestError as e:
   78:                 raise RepositoryCannotBeUpdatedError(f'[{self.repo}] {e}')
   79:             else:
   80:                 hook_ids = frozenset(hook['id'] for hook in manifest)
   81: 
   82:         return self._replace(rev=rev, frozen=frozen, hook_ids=hook_ids)
   83: 
   84: 
   85: class RepositoryCannotBeUpdatedError(RuntimeError):
   86:     pass
   87: 
   88: 
   89: def _check_hooks_still_exist_at_rev(
   90:         repo_config: dict[str, Any],
   91:         info: RevInfo,
   92: ) -> None:
   93:     # See if any of our hooks were deleted with the new commits
   94:     hooks = {hook['id'] for hook in repo_config['hooks']}
   95:     hooks_missing = hooks - info.hook_ids
   96:     if hooks_missing:
   97:         raise RepositoryCannotBeUpdatedError(
   98:             f'[{info.repo}] Cannot update because the update target is '
   99:             f'missing these hooks: {", ".join(sorted(hooks_missing))}',
  100:         )
  101: 
  102: 
  103: def _update_one(
  104:         i: int,
  105:         repo: dict[str, Any],
  106:         *,
  107:         tags_only: bool,
  108:         freeze: bool,
  109: ) -> tuple[int, RevInfo, RevInfo]:
  110:     old = RevInfo.from_config(repo)
  111:     new = old.update(tags_only=tags_only, freeze=freeze)
  112:     _check_hooks_still_exist_at_rev(repo, new)
  113:     return i, old, new
  114: 
  115: 
  116: REV_LINE_RE = re.compile(r'^(\s+)rev:(\s*)([\'"]?)([^\s#]+)(.*)(\r?\n)$')
  117: 
  118: 
  119: def _original_lines(
  120:         path: str,
  121:         rev_infos: list[RevInfo | None],
  122:         retry: bool = False,
  123: ) -> tuple[list[str], list[int]]:
  124:     """detect `rev:` lines or reformat the file"""
  125:     with open(path, newline='') as f:
  126:         original = f.read()
  127: 
  128:     lines = original.splitlines(True)
  129:     idxs = [i for i, line in enumerate(lines) if REV_LINE_RE.match(line)]
  130:     if len(idxs) == len(rev_infos):
  131:         return lines, idxs
  132:     elif retry:
  133:         raise AssertionError('could not find rev lines')
  134:     else:
  135:         with open(path, 'w') as f:
  136:             f.write(yaml_dump(yaml_load(original)))
  137:         return _original_lines(path, rev_infos, retry=True)
  138: 
  139: 
  140: def _write_new_config(path: str, rev_infos: list[RevInfo | None]) -> None:
  141:     lines, idxs = _original_lines(path, rev_infos)
  142: 
  143:     for idx, rev_info in zip(idxs, rev_infos):
  144:         if rev_info is None:
  145:             continue
  146:         match = REV_LINE_RE.match(lines[idx])
  147:         assert match is not None
  148:         new_rev_s = yaml_dump({'rev': rev_info.rev}, default_style=match[3])
  149:         new_rev = new_rev_s.split(':', 1)[1].strip()
  150:         if rev_info.frozen is not None:
  151:             comment = f'  # frozen: {rev_info.frozen}'
  152:         elif match[5].strip().startswith('# frozen:'):
  153:             comment = ''
  154:         else:
  155:             comment = match[5]
  156:         lines[idx] = f'{match[1]}rev:{match[2]}{new_rev}{comment}{match[6]}'
  157: 
  158:     with open(path, 'w', newline='') as f:
  159:         f.write(''.join(lines))
  160: 
  161: 
  162: def autoupdate(
  163:         config_file: str,
  164:         tags_only: bool,
  165:         freeze: bool,
  166:         repos: Sequence[str] = (),
  167:         jobs: int = 1,
  168: ) -> int:
  169:     """Auto-update the pre-commit config to the latest versions of repos."""
  170:     migrate_config(config_file, quiet=True)
  171:     changed = False
  172:     retv = 0
  173: 
  174:     config_repos = [
  175:         repo for repo in load_config(config_file)['repos']
  176:         if repo['repo'] not in {LOCAL, META}
  177:     ]
  178: 
  179:     rev_infos: list[RevInfo | None] = [None] * len(config_repos)
  180:     jobs = jobs or xargs.cpu_count()  # 0 => number of cpus
  181:     jobs = min(jobs, len(repos) or len(config_repos))  # max 1-per-thread
  182:     jobs = max(jobs, 1)  # at least one thread
  183:     with concurrent.futures.ThreadPoolExecutor(jobs) as exe:
  184:         futures = [
  185:             exe.submit(
  186:                 _update_one,
  187:                 i, repo, tags_only=tags_only, freeze=freeze,
  188:             )
  189:             for i, repo in enumerate(config_repos)
  190:             if not repos or repo['repo'] in repos
  191:         ]
  192:         for future in concurrent.futures.as_completed(futures):
  193:             try:
  194:                 i, old, new = future.result()
  195:             except RepositoryCannotBeUpdatedError as e:
  196:                 output.write_line(str(e))
  197:                 retv = 1
  198:             else:
  199:                 if new.rev != old.rev:
  200:                     changed = True
  201:                     if new.frozen:
  202:                         new_s = f'{new.frozen} (frozen)'
  203:                     else:
  204:                         new_s = new.rev
  205:                     msg = f'updating {old.rev} -> {new_s}'
  206:                     rev_infos[i] = new
  207:                 else:
  208:                     msg = 'already up to date!'
  209: 
  210:                 output.write_line(f'[{old.repo}] {msg}')
  211: 
  212:     if changed:
  213:         _write_new_config(config_file, rev_infos)
  214: 
  215:     return retv
