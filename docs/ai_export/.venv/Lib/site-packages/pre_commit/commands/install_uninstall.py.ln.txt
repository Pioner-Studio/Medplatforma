    1: from __future__ import annotations
    2: 
    3: import logging
    4: import os.path
    5: import shlex
    6: import shutil
    7: import sys
    8: 
    9: from pre_commit import git
   10: from pre_commit import output
   11: from pre_commit.clientlib import InvalidConfigError
   12: from pre_commit.clientlib import load_config
   13: from pre_commit.repository import all_hooks
   14: from pre_commit.repository import install_hook_envs
   15: from pre_commit.store import Store
   16: from pre_commit.util import make_executable
   17: from pre_commit.util import resource_text
   18: 
   19: 
   20: logger = logging.getLogger(__name__)
   21: 
   22: # This is used to identify the hook file we install
   23: PRIOR_HASHES = (
   24:     b'4d9958c90bc262f47553e2c073f14cfe',
   25:     b'd8ee923c46731b42cd95cc869add4062',
   26:     b'49fd668cb42069aa1b6048464be5d395',
   27:     b'79f09a650522a87b0da915d0d983b2de',
   28:     b'e358c9dae00eac5d06b38dfdb1e33a8c',
   29: )
   30: CURRENT_HASH = b'138fd403232d2ddd5efb44317e38bf03'
   31: TEMPLATE_START = '# start templated\n'
   32: TEMPLATE_END = '# end templated\n'
   33: 
   34: 
   35: def _hook_types(cfg_filename: str, hook_types: list[str] | None) -> list[str]:
   36:     if hook_types is not None:
   37:         return hook_types
   38:     else:
   39:         try:
   40:             cfg = load_config(cfg_filename)
   41:         except InvalidConfigError:
   42:             return ['pre-commit']
   43:         else:
   44:             return cfg['default_install_hook_types']
   45: 
   46: 
   47: def _hook_paths(
   48:         hook_type: str,
   49:         git_dir: str | None = None,
   50: ) -> tuple[str, str]:
   51:     git_dir = git_dir if git_dir is not None else git.get_git_common_dir()
   52:     pth = os.path.join(git_dir, 'hooks', hook_type)
   53:     return pth, f'{pth}.legacy'
   54: 
   55: 
   56: def is_our_script(filename: str) -> bool:
   57:     if not os.path.exists(filename):  # pragma: win32 no cover (symlink)
   58:         return False
   59:     with open(filename, 'rb') as f:
   60:         contents = f.read()
   61:     return any(h in contents for h in (CURRENT_HASH,) + PRIOR_HASHES)
   62: 
   63: 
   64: def _install_hook_script(
   65:         config_file: str,
   66:         hook_type: str,
   67:         overwrite: bool = False,
   68:         skip_on_missing_config: bool = False,
   69:         git_dir: str | None = None,
   70: ) -> None:
   71:     hook_path, legacy_path = _hook_paths(hook_type, git_dir=git_dir)
   72: 
   73:     os.makedirs(os.path.dirname(hook_path), exist_ok=True)
   74: 
   75:     # If we have an existing hook, move it to pre-commit.legacy
   76:     if os.path.lexists(hook_path) and not is_our_script(hook_path):
   77:         shutil.move(hook_path, legacy_path)
   78: 
   79:     # If we specify overwrite, we simply delete the legacy file
   80:     if overwrite and os.path.exists(legacy_path):
   81:         os.remove(legacy_path)
   82:     elif os.path.exists(legacy_path):
   83:         output.write_line(
   84:             f'Running in migration mode with existing hooks at {legacy_path}\n'
   85:             f'Use -f to use only pre-commit.',
   86:         )
   87: 
   88:     args = ['hook-impl', f'--config={config_file}', f'--hook-type={hook_type}']
   89:     if skip_on_missing_config:
   90:         args.append('--skip-on-missing-config')
   91: 
   92:     with open(hook_path, 'w') as hook_file:
   93:         contents = resource_text('hook-tmpl')
   94:         before, rest = contents.split(TEMPLATE_START)
   95:         _, after = rest.split(TEMPLATE_END)
   96: 
   97:         # on windows always use `/bin/sh` since `bash` might not be on PATH
   98:         # though we use bash-specific features `sh` on windows is actually
   99:         # bash in "POSIXLY_CORRECT" mode which still supports the features we
  100:         # use: subshells / arrays
  101:         if sys.platform == 'win32':  # pragma: win32 cover
  102:             hook_file.write('#!/bin/sh\n')
  103: 
  104:         hook_file.write(before + TEMPLATE_START)
  105:         hook_file.write(f'INSTALL_PYTHON={shlex.quote(sys.executable)}\n')
  106:         args_s = shlex.join(args)
  107:         hook_file.write(f'ARGS=({args_s})\n')
  108:         hook_file.write(TEMPLATE_END + after)
  109:     make_executable(hook_path)
  110: 
  111:     output.write_line(f'pre-commit installed at {hook_path}')
  112: 
  113: 
  114: def install(
  115:         config_file: str,
  116:         store: Store,
  117:         hook_types: list[str] | None,
  118:         overwrite: bool = False,
  119:         hooks: bool = False,
  120:         skip_on_missing_config: bool = False,
  121:         git_dir: str | None = None,
  122: ) -> int:
  123:     if git_dir is None and git.has_core_hookpaths_set():
  124:         logger.error(
  125:             'Cowardly refusing to install hooks with `core.hooksPath` set.\n'
  126:             'hint: `git config --unset-all core.hooksPath`',
  127:         )
  128:         return 1
  129: 
  130:     for hook_type in _hook_types(config_file, hook_types):
  131:         _install_hook_script(
  132:             config_file, hook_type,
  133:             overwrite=overwrite,
  134:             skip_on_missing_config=skip_on_missing_config,
  135:             git_dir=git_dir,
  136:         )
  137: 
  138:     if hooks:
  139:         install_hooks(config_file, store)
  140: 
  141:     return 0
  142: 
  143: 
  144: def install_hooks(config_file: str, store: Store) -> int:
  145:     install_hook_envs(all_hooks(load_config(config_file), store), store)
  146:     return 0
  147: 
  148: 
  149: def _uninstall_hook_script(hook_type: str) -> None:
  150:     hook_path, legacy_path = _hook_paths(hook_type)
  151: 
  152:     # If our file doesn't exist or it isn't ours, gtfo.
  153:     if not os.path.exists(hook_path) or not is_our_script(hook_path):
  154:         return
  155: 
  156:     os.remove(hook_path)
  157:     output.write_line(f'{hook_type} uninstalled')
  158: 
  159:     if os.path.exists(legacy_path):
  160:         os.replace(legacy_path, hook_path)
  161:         output.write_line(f'Restored previous hooks to {hook_path}')
  162: 
  163: 
  164: def uninstall(config_file: str, hook_types: list[str] | None) -> int:
  165:     for hook_type in _hook_types(config_file, hook_types):
  166:         _uninstall_hook_script(hook_type)
  167:     return 0
