    1: from __future__ import annotations
    2: 
    3: import argparse
    4: import contextlib
    5: import functools
    6: import logging
    7: import os
    8: import re
    9: import subprocess
   10: import time
   11: import unicodedata
   12: from collections.abc import Generator
   13: from collections.abc import Iterable
   14: from collections.abc import MutableMapping
   15: from collections.abc import Sequence
   16: from typing import Any
   17: 
   18: from identify.identify import tags_from_path
   19: 
   20: from pre_commit import color
   21: from pre_commit import git
   22: from pre_commit import output
   23: from pre_commit.all_languages import languages
   24: from pre_commit.clientlib import load_config
   25: from pre_commit.hook import Hook
   26: from pre_commit.repository import all_hooks
   27: from pre_commit.repository import install_hook_envs
   28: from pre_commit.staged_files_only import staged_files_only
   29: from pre_commit.store import Store
   30: from pre_commit.util import cmd_output_b
   31: 
   32: 
   33: logger = logging.getLogger('pre_commit')
   34: 
   35: 
   36: def _len_cjk(msg: str) -> int:
   37:     widths = {'A': 1, 'F': 2, 'H': 1, 'N': 1, 'Na': 1, 'W': 2}
   38:     return sum(widths[unicodedata.east_asian_width(c)] for c in msg)
   39: 
   40: 
   41: def _start_msg(*, start: str, cols: int, end_len: int) -> str:
   42:     dots = '.' * (cols - _len_cjk(start) - end_len - 1)
   43:     return f'{start}{dots}'
   44: 
   45: 
   46: def _full_msg(
   47:         *,
   48:         start: str,
   49:         cols: int,
   50:         end_msg: str,
   51:         end_color: str,
   52:         use_color: bool,
   53:         postfix: str = '',
   54: ) -> str:
   55:     dots = '.' * (cols - _len_cjk(start) - len(postfix) - len(end_msg) - 1)
   56:     end = color.format_color(end_msg, end_color, use_color)
   57:     return f'{start}{dots}{postfix}{end}\n'
   58: 
   59: 
   60: def filter_by_include_exclude(
   61:         names: Iterable[str],
   62:         include: str,
   63:         exclude: str,
   64: ) -> Generator[str]:
   65:     include_re, exclude_re = re.compile(include), re.compile(exclude)
   66:     return (
   67:         filename for filename in names
   68:         if include_re.search(filename)
   69:         if not exclude_re.search(filename)
   70:     )
   71: 
   72: 
   73: class Classifier:
   74:     def __init__(self, filenames: Iterable[str]) -> None:
   75:         self.filenames = [f for f in filenames if os.path.lexists(f)]
   76: 
   77:     @functools.cache
   78:     def _types_for_file(self, filename: str) -> set[str]:
   79:         return tags_from_path(filename)
   80: 
   81:     def by_types(
   82:             self,
   83:             names: Iterable[str],
   84:             types: Iterable[str],
   85:             types_or: Iterable[str],
   86:             exclude_types: Iterable[str],
   87:     ) -> Generator[str]:
   88:         types = frozenset(types)
   89:         types_or = frozenset(types_or)
   90:         exclude_types = frozenset(exclude_types)
   91:         for filename in names:
   92:             tags = self._types_for_file(filename)
   93:             if (
   94:                     tags >= types and
   95:                     (not types_or or tags & types_or) and
   96:                     not tags & exclude_types
   97:             ):
   98:                 yield filename
   99: 
  100:     def filenames_for_hook(self, hook: Hook) -> Generator[str]:
  101:         return self.by_types(
  102:             filter_by_include_exclude(
  103:                 self.filenames,
  104:                 hook.files,
  105:                 hook.exclude,
  106:             ),
  107:             hook.types,
  108:             hook.types_or,
  109:             hook.exclude_types,
  110:         )
  111: 
  112:     @classmethod
  113:     def from_config(
  114:             cls,
  115:             filenames: Iterable[str],
  116:             include: str,
  117:             exclude: str,
  118:     ) -> Classifier:
  119:         # on windows we normalize all filenames to use forward slashes
  120:         # this makes it easier to filter using the `files:` regex
  121:         # this also makes improperly quoted shell-based hooks work better
  122:         # see #1173
  123:         if os.altsep == '/' and os.sep == '\\':
  124:             filenames = (f.replace(os.sep, os.altsep) for f in filenames)
  125:         filenames = filter_by_include_exclude(filenames, include, exclude)
  126:         return Classifier(filenames)
  127: 
  128: 
  129: def _get_skips(environ: MutableMapping[str, str]) -> set[str]:
  130:     skips = environ.get('SKIP', '')
  131:     return {skip.strip() for skip in skips.split(',') if skip.strip()}
  132: 
  133: 
  134: SKIPPED = 'Skipped'
  135: NO_FILES = '(no files to check)'
  136: 
  137: 
  138: def _subtle_line(s: str, use_color: bool) -> None:
  139:     output.write_line(color.format_color(s, color.SUBTLE, use_color))
  140: 
  141: 
  142: def _run_single_hook(
  143:         classifier: Classifier,
  144:         hook: Hook,
  145:         skips: set[str],
  146:         cols: int,
  147:         diff_before: bytes,
  148:         verbose: bool,
  149:         use_color: bool,
  150: ) -> tuple[bool, bytes]:
  151:     filenames = tuple(classifier.filenames_for_hook(hook))
  152: 
  153:     if hook.id in skips or hook.alias in skips:
  154:         output.write(
  155:             _full_msg(
  156:                 start=hook.name,
  157:                 end_msg=SKIPPED,
  158:                 end_color=color.YELLOW,
  159:                 use_color=use_color,
  160:                 cols=cols,
  161:             ),
  162:         )
  163:         duration = None
  164:         retcode = 0
  165:         diff_after = diff_before
  166:         files_modified = False
  167:         out = b''
  168:     elif not filenames and not hook.always_run:
  169:         output.write(
  170:             _full_msg(
  171:                 start=hook.name,
  172:                 postfix=NO_FILES,
  173:                 end_msg=SKIPPED,
  174:                 end_color=color.TURQUOISE,
  175:                 use_color=use_color,
  176:                 cols=cols,
  177:             ),
  178:         )
  179:         duration = None
  180:         retcode = 0
  181:         diff_after = diff_before
  182:         files_modified = False
  183:         out = b''
  184:     else:
  185:         # print hook and dots first in case the hook takes a while to run
  186:         output.write(_start_msg(start=hook.name, end_len=6, cols=cols))
  187: 
  188:         if not hook.pass_filenames:
  189:             filenames = ()
  190:         time_before = time.monotonic()
  191:         language = languages[hook.language]
  192:         with language.in_env(hook.prefix, hook.language_version):
  193:             retcode, out = language.run_hook(
  194:                 hook.prefix,
  195:                 hook.entry,
  196:                 hook.args,
  197:                 filenames,
  198:                 is_local=hook.src == 'local',
  199:                 require_serial=hook.require_serial,
  200:                 color=use_color,
  201:             )
  202:         duration = round(time.monotonic() - time_before, 2) or 0
  203:         diff_after = _get_diff()
  204: 
  205:         # if the hook makes changes, fail the commit
  206:         files_modified = diff_before != diff_after
  207: 
  208:         if retcode or files_modified:
  209:             print_color = color.RED
  210:             status = 'Failed'
  211:         else:
  212:             print_color = color.GREEN
  213:             status = 'Passed'
  214: 
  215:         output.write_line(color.format_color(status, print_color, use_color))
  216: 
  217:     if verbose or hook.verbose or retcode or files_modified:
  218:         _subtle_line(f'- hook id: {hook.id}', use_color)
  219: 
  220:         if (verbose or hook.verbose) and duration is not None:
  221:             _subtle_line(f'- duration: {duration}s', use_color)
  222: 
  223:         if retcode:
  224:             _subtle_line(f'- exit code: {retcode}', use_color)
  225: 
  226:         # Print a message if failing due to file modifications
  227:         if files_modified:
  228:             _subtle_line('- files were modified by this hook', use_color)
  229: 
  230:         if out.strip():
  231:             output.write_line()
  232:             output.write_line_b(out.strip(), logfile_name=hook.log_file)
  233:             output.write_line()
  234: 
  235:     return files_modified or bool(retcode), diff_after
  236: 
  237: 
  238: def _compute_cols(hooks: Sequence[Hook]) -> int:
  239:     """Compute the number of columns to display hook messages.  The widest
  240:     that will be displayed is in the no files skipped case:
  241: 
  242:         Hook name...(no files to check) Skipped
  243:     """
  244:     if hooks:
  245:         name_len = max(_len_cjk(hook.name) for hook in hooks)
  246:     else:
  247:         name_len = 0
  248: 
  249:     cols = name_len + 3 + len(NO_FILES) + 1 + len(SKIPPED)
  250:     return max(cols, 80)
  251: 
  252: 
  253: def _all_filenames(args: argparse.Namespace) -> Iterable[str]:
  254:     # these hooks do not operate on files
  255:     if args.hook_stage in {
  256:         'post-checkout', 'post-commit', 'post-merge', 'post-rewrite',
  257:         'pre-rebase',
  258:     }:
  259:         return ()
  260:     elif args.hook_stage in {'prepare-commit-msg', 'commit-msg'}:
  261:         return (args.commit_msg_filename,)
  262:     elif args.from_ref and args.to_ref:
  263:         return git.get_changed_files(args.from_ref, args.to_ref)
  264:     elif args.files:
  265:         return args.files
  266:     elif args.all_files:
  267:         return git.get_all_files()
  268:     elif git.is_in_merge_conflict():
  269:         return git.get_conflicted_files()
  270:     else:
  271:         return git.get_staged_files()
  272: 
  273: 
  274: def _get_diff() -> bytes:
  275:     _, out, _ = cmd_output_b(
  276:         'git', 'diff', '--no-ext-diff', '--no-textconv', '--ignore-submodules',
  277:         check=False,
  278:     )
  279:     return out
  280: 
  281: 
  282: def _run_hooks(
  283:         config: dict[str, Any],
  284:         hooks: Sequence[Hook],
  285:         skips: set[str],
  286:         args: argparse.Namespace,
  287: ) -> int:
  288:     """Actually run the hooks."""
  289:     cols = _compute_cols(hooks)
  290:     classifier = Classifier.from_config(
  291:         _all_filenames(args), config['files'], config['exclude'],
  292:     )
  293:     retval = 0
  294:     prior_diff = _get_diff()
  295:     for hook in hooks:
  296:         current_retval, prior_diff = _run_single_hook(
  297:             classifier, hook, skips, cols, prior_diff,
  298:             verbose=args.verbose, use_color=args.color,
  299:         )
  300:         retval |= current_retval
  301:         if current_retval and (config['fail_fast'] or hook.fail_fast):
  302:             break
  303:     if retval and args.show_diff_on_failure and prior_diff:
  304:         if args.all_files:
  305:             output.write_line(
  306:                 'pre-commit hook(s) made changes.\n'
  307:                 'If you are seeing this message in CI, '
  308:                 'reproduce locally with: `pre-commit run --all-files`.\n'
  309:                 'To run `pre-commit` as part of git workflow, use '
  310:                 '`pre-commit install`.',
  311:             )
  312:         output.write_line('All changes made by hooks:')
  313:         # args.color is a boolean.
  314:         # See user_color function in color.py
  315:         git_color_opt = 'always' if args.color else 'never'
  316:         subprocess.call((
  317:             'git', '--no-pager', 'diff', '--no-ext-diff',
  318:             f'--color={git_color_opt}',
  319:         ))
  320: 
  321:     return retval
  322: 
  323: 
  324: def _has_unmerged_paths() -> bool:
  325:     _, stdout, _ = cmd_output_b('git', 'ls-files', '--unmerged')
  326:     return bool(stdout.strip())
  327: 
  328: 
  329: def _has_unstaged_config(config_file: str) -> bool:
  330:     retcode, _, _ = cmd_output_b(
  331:         'git', 'diff', '--quiet', '--no-ext-diff', config_file, check=False,
  332:     )
  333:     # be explicit, other git errors don't mean it has an unstaged config.
  334:     return retcode == 1
  335: 
  336: 
  337: def run(
  338:         config_file: str,
  339:         store: Store,
  340:         args: argparse.Namespace,
  341:         environ: MutableMapping[str, str] = os.environ,
  342: ) -> int:
  343:     stash = not args.all_files and not args.files
  344: 
  345:     # Check if we have unresolved merge conflict files and fail fast.
  346:     if stash and _has_unmerged_paths():
  347:         logger.error('Unmerged files.  Resolve before committing.')
  348:         return 1
  349:     if bool(args.from_ref) != bool(args.to_ref):
  350:         logger.error('Specify both --from-ref and --to-ref.')
  351:         return 1
  352:     if stash and _has_unstaged_config(config_file):
  353:         logger.error(
  354:             f'Your pre-commit configuration is unstaged.\n'
  355:             f'`git add {config_file}` to fix this.',
  356:         )
  357:         return 1
  358:     if (
  359:             args.hook_stage in {'prepare-commit-msg', 'commit-msg'} and
  360:             not args.commit_msg_filename
  361:     ):
  362:         logger.error(
  363:             f'`--commit-msg-filename` is required for '
  364:             f'`--hook-stage {args.hook_stage}`',
  365:         )
  366:         return 1
  367:     # prevent recursive post-checkout hooks (#1418)
  368:     if (
  369:             args.hook_stage == 'post-checkout' and
  370:             environ.get('_PRE_COMMIT_SKIP_POST_CHECKOUT')
  371:     ):
  372:         return 0
  373: 
  374:     # Expose prepare_commit_message_source / commit_object_name
  375:     # as environment variables for the hooks
  376:     if args.prepare_commit_message_source:
  377:         environ['PRE_COMMIT_COMMIT_MSG_SOURCE'] = (
  378:             args.prepare_commit_message_source
  379:         )
  380: 
  381:     if args.commit_object_name:
  382:         environ['PRE_COMMIT_COMMIT_OBJECT_NAME'] = args.commit_object_name
  383: 
  384:     # Expose from-ref / to-ref as environment variables for hooks to consume
  385:     if args.from_ref and args.to_ref:
  386:         # legacy names
  387:         environ['PRE_COMMIT_ORIGIN'] = args.from_ref
  388:         environ['PRE_COMMIT_SOURCE'] = args.to_ref
  389:         # new names
  390:         environ['PRE_COMMIT_FROM_REF'] = args.from_ref
  391:         environ['PRE_COMMIT_TO_REF'] = args.to_ref
  392: 
  393:     if args.pre_rebase_upstream and args.pre_rebase_branch:
  394:         environ['PRE_COMMIT_PRE_REBASE_UPSTREAM'] = args.pre_rebase_upstream
  395:         environ['PRE_COMMIT_PRE_REBASE_BRANCH'] = args.pre_rebase_branch
  396: 
  397:     if (
  398:         args.remote_name and args.remote_url and
  399:         args.remote_branch and args.local_branch
  400:     ):
  401:         environ['PRE_COMMIT_LOCAL_BRANCH'] = args.local_branch
  402:         environ['PRE_COMMIT_REMOTE_BRANCH'] = args.remote_branch
  403:         environ['PRE_COMMIT_REMOTE_NAME'] = args.remote_name
  404:         environ['PRE_COMMIT_REMOTE_URL'] = args.remote_url
  405: 
  406:     if args.checkout_type:
  407:         environ['PRE_COMMIT_CHECKOUT_TYPE'] = args.checkout_type
  408: 
  409:     if args.is_squash_merge:
  410:         environ['PRE_COMMIT_IS_SQUASH_MERGE'] = args.is_squash_merge
  411: 
  412:     if args.rewrite_command:
  413:         environ['PRE_COMMIT_REWRITE_COMMAND'] = args.rewrite_command
  414: 
  415:     # Set pre_commit flag
  416:     environ['PRE_COMMIT'] = '1'
  417: 
  418:     with contextlib.ExitStack() as exit_stack:
  419:         if stash:
  420:             exit_stack.enter_context(staged_files_only(store.directory))
  421: 
  422:         config = load_config(config_file)
  423:         hooks = [
  424:             hook
  425:             for hook in all_hooks(config, store)
  426:             if not args.hook or hook.id == args.hook or hook.alias == args.hook
  427:             if args.hook_stage in hook.stages
  428:         ]
  429: 
  430:         if args.hook and not hooks:
  431:             output.write_line(
  432:                 f'No hook with id `{args.hook}` in stage `{args.hook_stage}`',
  433:             )
  434:             return 1
  435: 
  436:         skips = _get_skips(environ)
  437:         to_install = [
  438:             hook
  439:             for hook in hooks
  440:             if hook.id not in skips and hook.alias not in skips
  441:         ]
  442:         install_hook_envs(to_install, store)
  443: 
  444:         return _run_hooks(config, hooks, skips, args)
  445: 
  446:     # https://github.com/python/mypy/issues/7726
  447:     raise AssertionError('unreachable')
