    1: from __future__ import annotations
    2: 
    3: import argparse
    4: import os.path
    5: import subprocess
    6: import sys
    7: from collections.abc import Sequence
    8: 
    9: from pre_commit.commands.run import run
   10: from pre_commit.envcontext import envcontext
   11: from pre_commit.parse_shebang import normalize_cmd
   12: from pre_commit.store import Store
   13: 
   14: Z40 = '0' * 40
   15: 
   16: 
   17: def _run_legacy(
   18:         hook_type: str,
   19:         hook_dir: str,
   20:         args: Sequence[str],
   21: ) -> tuple[int, bytes]:
   22:     if os.environ.get('PRE_COMMIT_RUNNING_LEGACY'):
   23:         raise SystemExit(
   24:             f"bug: pre-commit's script is installed in migration mode\n"
   25:             f'run `pre-commit install -f --hook-type {hook_type}` to fix '
   26:             f'this\n\n'
   27:             f'Please report this bug at '
   28:             f'https://github.com/pre-commit/pre-commit/issues',
   29:         )
   30: 
   31:     if hook_type == 'pre-push':
   32:         stdin = sys.stdin.buffer.read()
   33:     else:
   34:         stdin = b''
   35: 
   36:     # not running in legacy mode
   37:     legacy_hook = os.path.join(hook_dir, f'{hook_type}.legacy')
   38:     if not os.access(legacy_hook, os.X_OK):
   39:         return 0, stdin
   40: 
   41:     with envcontext((('PRE_COMMIT_RUNNING_LEGACY', '1'),)):
   42:         cmd = normalize_cmd((legacy_hook, *args))
   43:         return subprocess.run(cmd, input=stdin).returncode, stdin
   44: 
   45: 
   46: def _validate_config(
   47:         retv: int,
   48:         config: str,
   49:         skip_on_missing_config: bool,
   50: ) -> None:
   51:     if not os.path.isfile(config):
   52:         if skip_on_missing_config or os.getenv('PRE_COMMIT_ALLOW_NO_CONFIG'):
   53:             print(f'`{config}` config file not found. Skipping `pre-commit`.')
   54:             raise SystemExit(retv)
   55:         else:
   56:             print(
   57:                 f'No {config} file was found\n'
   58:                 f'- To temporarily silence this, run '
   59:                 f'`PRE_COMMIT_ALLOW_NO_CONFIG=1 git ...`\n'
   60:                 f'- To permanently silence this, install pre-commit with the '
   61:                 f'--allow-missing-config option\n'
   62:                 f'- To uninstall pre-commit run `pre-commit uninstall`',
   63:             )
   64:             raise SystemExit(1)
   65: 
   66: 
   67: def _ns(
   68:         hook_type: str,
   69:         color: bool,
   70:         *,
   71:         all_files: bool = False,
   72:         remote_branch: str | None = None,
   73:         local_branch: str | None = None,
   74:         from_ref: str | None = None,
   75:         to_ref: str | None = None,
   76:         pre_rebase_upstream: str | None = None,
   77:         pre_rebase_branch: str | None = None,
   78:         remote_name: str | None = None,
   79:         remote_url: str | None = None,
   80:         commit_msg_filename: str | None = None,
   81:         prepare_commit_message_source: str | None = None,
   82:         commit_object_name: str | None = None,
   83:         checkout_type: str | None = None,
   84:         is_squash_merge: str | None = None,
   85:         rewrite_command: str | None = None,
   86: ) -> argparse.Namespace:
   87:     return argparse.Namespace(
   88:         color=color,
   89:         hook_stage=hook_type,
   90:         remote_branch=remote_branch,
   91:         local_branch=local_branch,
   92:         from_ref=from_ref,
   93:         to_ref=to_ref,
   94:         pre_rebase_upstream=pre_rebase_upstream,
   95:         pre_rebase_branch=pre_rebase_branch,
   96:         remote_name=remote_name,
   97:         remote_url=remote_url,
   98:         commit_msg_filename=commit_msg_filename,
   99:         prepare_commit_message_source=prepare_commit_message_source,
  100:         commit_object_name=commit_object_name,
  101:         all_files=all_files,
  102:         checkout_type=checkout_type,
  103:         is_squash_merge=is_squash_merge,
  104:         rewrite_command=rewrite_command,
  105:         files=(),
  106:         hook=None,
  107:         verbose=False,
  108:         show_diff_on_failure=False,
  109:     )
  110: 
  111: 
  112: def _rev_exists(rev: str) -> bool:
  113:     return not subprocess.call(('git', 'rev-list', '--quiet', rev))
  114: 
  115: 
  116: def _pre_push_ns(
  117:         color: bool,
  118:         args: Sequence[str],
  119:         stdin: bytes,
  120: ) -> argparse.Namespace | None:
  121:     remote_name = args[0]
  122:     remote_url = args[1]
  123: 
  124:     for line in stdin.decode().splitlines():
  125:         parts = line.rsplit(maxsplit=3)
  126:         local_branch, local_sha, remote_branch, remote_sha = parts
  127:         if local_sha == Z40:
  128:             continue
  129:         elif remote_sha != Z40 and _rev_exists(remote_sha):
  130:             return _ns(
  131:                 'pre-push', color,
  132:                 from_ref=remote_sha, to_ref=local_sha,
  133:                 remote_branch=remote_branch,
  134:                 local_branch=local_branch,
  135:                 remote_name=remote_name, remote_url=remote_url,
  136:             )
  137:         else:
  138:             # ancestors not found in remote
  139:             ancestors = subprocess.check_output((
  140:                 'git', 'rev-list', local_sha, '--topo-order', '--reverse',
  141:                 '--not', f'--remotes={remote_name}',
  142:             )).decode().strip()
  143:             if not ancestors:
  144:                 continue
  145:             else:
  146:                 first_ancestor = ancestors.splitlines()[0]
  147:                 cmd = ('git', 'rev-list', '--max-parents=0', local_sha)
  148:                 roots = set(subprocess.check_output(cmd).decode().splitlines())
  149:                 if first_ancestor in roots:
  150:                     # pushing the whole tree including root commit
  151:                     return _ns(
  152:                         'pre-push', color,
  153:                         all_files=True,
  154:                         remote_name=remote_name, remote_url=remote_url,
  155:                         remote_branch=remote_branch,
  156:                         local_branch=local_branch,
  157:                     )
  158:                 else:
  159:                     rev_cmd = ('git', 'rev-parse', f'{first_ancestor}^')
  160:                     source = subprocess.check_output(rev_cmd).decode().strip()
  161:                     return _ns(
  162:                         'pre-push', color,
  163:                         from_ref=source, to_ref=local_sha,
  164:                         remote_name=remote_name, remote_url=remote_url,
  165:                         remote_branch=remote_branch,
  166:                         local_branch=local_branch,
  167:                     )
  168: 
  169:     # nothing to push
  170:     return None
  171: 
  172: 
  173: _EXPECTED_ARG_LENGTH_BY_HOOK = {
  174:     'commit-msg': 1,
  175:     'post-checkout': 3,
  176:     'post-commit': 0,
  177:     'pre-commit': 0,
  178:     'pre-merge-commit': 0,
  179:     'post-merge': 1,
  180:     'post-rewrite': 1,
  181:     'pre-push': 2,
  182: }
  183: 
  184: 
  185: def _check_args_length(hook_type: str, args: Sequence[str]) -> None:
  186:     if hook_type == 'prepare-commit-msg':
  187:         if len(args) < 1 or len(args) > 3:
  188:             raise SystemExit(
  189:                 f'hook-impl for {hook_type} expected 1, 2, or 3 arguments '
  190:                 f'but got {len(args)}: {args}',
  191:             )
  192:     elif hook_type == 'pre-rebase':
  193:         if len(args) < 1 or len(args) > 2:
  194:             raise SystemExit(
  195:                 f'hook-impl for {hook_type} expected 1 or 2 arguments '
  196:                 f'but got {len(args)}: {args}',
  197:             )
  198:     elif hook_type in _EXPECTED_ARG_LENGTH_BY_HOOK:
  199:         expected = _EXPECTED_ARG_LENGTH_BY_HOOK[hook_type]
  200:         if len(args) != expected:
  201:             arguments_s = 'argument' if expected == 1 else 'arguments'
  202:             raise SystemExit(
  203:                 f'hook-impl for {hook_type} expected {expected} {arguments_s} '
  204:                 f'but got {len(args)}: {args}',
  205:             )
  206:     else:
  207:         raise AssertionError(f'unexpected hook type: {hook_type}')
  208: 
  209: 
  210: def _run_ns(
  211:         hook_type: str,
  212:         color: bool,
  213:         args: Sequence[str],
  214:         stdin: bytes,
  215: ) -> argparse.Namespace | None:
  216:     _check_args_length(hook_type, args)
  217:     if hook_type == 'pre-push':
  218:         return _pre_push_ns(color, args, stdin)
  219:     elif hook_type in 'commit-msg':
  220:         return _ns(hook_type, color, commit_msg_filename=args[0])
  221:     elif hook_type == 'prepare-commit-msg' and len(args) == 1:
  222:         return _ns(hook_type, color, commit_msg_filename=args[0])
  223:     elif hook_type == 'prepare-commit-msg' and len(args) == 2:
  224:         return _ns(
  225:             hook_type, color, commit_msg_filename=args[0],
  226:             prepare_commit_message_source=args[1],
  227:         )
  228:     elif hook_type == 'prepare-commit-msg' and len(args) == 3:
  229:         return _ns(
  230:             hook_type, color, commit_msg_filename=args[0],
  231:             prepare_commit_message_source=args[1], commit_object_name=args[2],
  232:         )
  233:     elif hook_type in {'post-commit', 'pre-merge-commit', 'pre-commit'}:
  234:         return _ns(hook_type, color)
  235:     elif hook_type == 'post-checkout':
  236:         return _ns(
  237:             hook_type, color,
  238:             from_ref=args[0], to_ref=args[1], checkout_type=args[2],
  239:         )
  240:     elif hook_type == 'post-merge':
  241:         return _ns(hook_type, color, is_squash_merge=args[0])
  242:     elif hook_type == 'post-rewrite':
  243:         return _ns(hook_type, color, rewrite_command=args[0])
  244:     elif hook_type == 'pre-rebase' and len(args) == 1:
  245:         return _ns(hook_type, color, pre_rebase_upstream=args[0])
  246:     elif hook_type == 'pre-rebase' and len(args) == 2:
  247:         return _ns(
  248:             hook_type, color, pre_rebase_upstream=args[0],
  249:             pre_rebase_branch=args[1],
  250:         )
  251:     else:
  252:         raise AssertionError(f'unexpected hook type: {hook_type}')
  253: 
  254: 
  255: def hook_impl(
  256:         store: Store,
  257:         *,
  258:         config: str,
  259:         color: bool,
  260:         hook_type: str,
  261:         hook_dir: str,
  262:         skip_on_missing_config: bool,
  263:         args: Sequence[str],
  264: ) -> int:
  265:     retv, stdin = _run_legacy(hook_type, hook_dir, args)
  266:     _validate_config(retv, config, skip_on_missing_config)
  267:     ns = _run_ns(hook_type, color, args, stdin)
  268:     if ns is None:
  269:         return retv
  270:     else:
  271:         return retv | run(config, store, ns)
