    1: from __future__ import annotations
    2: 
    3: import json
    4: import logging
    5: import os
    6: from collections.abc import Sequence
    7: from typing import Any
    8: 
    9: import pre_commit.constants as C
   10: from pre_commit.all_languages import languages
   11: from pre_commit.clientlib import load_manifest
   12: from pre_commit.clientlib import LOCAL
   13: from pre_commit.clientlib import META
   14: from pre_commit.hook import Hook
   15: from pre_commit.lang_base import environment_dir
   16: from pre_commit.prefix import Prefix
   17: from pre_commit.store import Store
   18: from pre_commit.util import clean_path_on_failure
   19: from pre_commit.util import rmtree
   20: 
   21: 
   22: logger = logging.getLogger('pre_commit')
   23: 
   24: 
   25: def _state_filename_v1(venv: str) -> str:
   26:     return os.path.join(venv, '.install_state_v1')
   27: 
   28: 
   29: def _state_filename_v2(venv: str) -> str:
   30:     return os.path.join(venv, '.install_state_v2')
   31: 
   32: 
   33: def _state(additional_deps: Sequence[str]) -> object:
   34:     return {'additional_dependencies': additional_deps}
   35: 
   36: 
   37: def _read_state(venv: str) -> object | None:
   38:     filename = _state_filename_v1(venv)
   39:     if not os.path.exists(filename):
   40:         return None
   41:     else:
   42:         with open(filename) as f:
   43:             return json.load(f)
   44: 
   45: 
   46: def _hook_installed(hook: Hook) -> bool:
   47:     lang = languages[hook.language]
   48:     if lang.ENVIRONMENT_DIR is None:
   49:         return True
   50: 
   51:     venv = environment_dir(
   52:         hook.prefix,
   53:         lang.ENVIRONMENT_DIR,
   54:         hook.language_version,
   55:     )
   56:     return (
   57:         (
   58:             os.path.exists(_state_filename_v2(venv)) or
   59:             _read_state(venv) == _state(hook.additional_dependencies)
   60:         ) and
   61:         not lang.health_check(hook.prefix, hook.language_version)
   62:     )
   63: 
   64: 
   65: def _hook_install(hook: Hook) -> None:
   66:     logger.info(f'Installing environment for {hook.src}.')
   67:     logger.info('Once installed this environment will be reused.')
   68:     logger.info('This may take a few minutes...')
   69: 
   70:     lang = languages[hook.language]
   71:     assert lang.ENVIRONMENT_DIR is not None
   72: 
   73:     venv = environment_dir(
   74:         hook.prefix,
   75:         lang.ENVIRONMENT_DIR,
   76:         hook.language_version,
   77:     )
   78: 
   79:     # There's potentially incomplete cleanup from previous runs
   80:     # Clean it up!
   81:     if os.path.exists(venv):
   82:         rmtree(venv)
   83: 
   84:     with clean_path_on_failure(venv):
   85:         lang.install_environment(
   86:             hook.prefix, hook.language_version, hook.additional_dependencies,
   87:         )
   88:         health_error = lang.health_check(hook.prefix, hook.language_version)
   89:         if health_error:
   90:             raise AssertionError(
   91:                 f'BUG: expected environment for {hook.language} to be healthy '
   92:                 f'immediately after install, please open an issue describing '
   93:                 f'your environment\n\n'
   94:                 f'more info:\n\n{health_error}',
   95:             )
   96: 
   97:         # TODO: remove v1 state writing, no longer needed after pre-commit 3.0
   98:         # Write our state to indicate we're installed
   99:         state_filename = _state_filename_v1(venv)
  100:         staging = f'{state_filename}staging'
  101:         with open(staging, 'w') as state_file:
  102:             state_file.write(json.dumps(_state(hook.additional_dependencies)))
  103:         # Move the file into place atomically to indicate we've installed
  104:         os.replace(staging, state_filename)
  105: 
  106:         open(_state_filename_v2(venv), 'a+').close()
  107: 
  108: 
  109: def _hook(
  110:         *hook_dicts: dict[str, Any],
  111:         root_config: dict[str, Any],
  112: ) -> dict[str, Any]:
  113:     ret, rest = dict(hook_dicts[0]), hook_dicts[1:]
  114:     for dct in rest:
  115:         ret.update(dct)
  116: 
  117:     lang = ret['language']
  118:     if ret['language_version'] == C.DEFAULT:
  119:         ret['language_version'] = root_config['default_language_version'][lang]
  120:     if ret['language_version'] == C.DEFAULT:
  121:         ret['language_version'] = languages[lang].get_default_version()
  122: 
  123:     if not ret['stages']:
  124:         ret['stages'] = root_config['default_stages']
  125: 
  126:     if languages[lang].ENVIRONMENT_DIR is None:
  127:         if ret['language_version'] != C.DEFAULT:
  128:             logger.error(
  129:                 f'The hook `{ret["id"]}` specifies `language_version` but is '
  130:                 f'using language `{lang}` which does not install an '
  131:                 f'environment.  '
  132:                 f'Perhaps you meant to use a specific language?',
  133:             )
  134:             exit(1)
  135:         if ret['additional_dependencies']:
  136:             logger.error(
  137:                 f'The hook `{ret["id"]}` specifies `additional_dependencies` '
  138:                 f'but is using language `{lang}` which does not install an '
  139:                 f'environment.  '
  140:                 f'Perhaps you meant to use a specific language?',
  141:             )
  142:             exit(1)
  143: 
  144:     return ret
  145: 
  146: 
  147: def _non_cloned_repository_hooks(
  148:         repo_config: dict[str, Any],
  149:         store: Store,
  150:         root_config: dict[str, Any],
  151: ) -> tuple[Hook, ...]:
  152:     def _prefix(language_name: str, deps: Sequence[str]) -> Prefix:
  153:         language = languages[language_name]
  154:         # pygrep / script / system / docker_image do not have
  155:         # environments so they work out of the current directory
  156:         if language.ENVIRONMENT_DIR is None:
  157:             return Prefix(os.getcwd())
  158:         else:
  159:             return Prefix(store.make_local(deps))
  160: 
  161:     return tuple(
  162:         Hook.create(
  163:             repo_config['repo'],
  164:             _prefix(hook['language'], hook['additional_dependencies']),
  165:             _hook(hook, root_config=root_config),
  166:         )
  167:         for hook in repo_config['hooks']
  168:     )
  169: 
  170: 
  171: def _cloned_repository_hooks(
  172:         repo_config: dict[str, Any],
  173:         store: Store,
  174:         root_config: dict[str, Any],
  175: ) -> tuple[Hook, ...]:
  176:     repo, rev = repo_config['repo'], repo_config['rev']
  177:     manifest_path = os.path.join(store.clone(repo, rev), C.MANIFEST_FILE)
  178:     by_id = {hook['id']: hook for hook in load_manifest(manifest_path)}
  179: 
  180:     for hook in repo_config['hooks']:
  181:         if hook['id'] not in by_id:
  182:             logger.error(
  183:                 f'`{hook["id"]}` is not present in repository {repo}.  '
  184:                 f'Typo? Perhaps it is introduced in a newer version?  '
  185:                 f'Often `pre-commit autoupdate` fixes this.',
  186:             )
  187:             exit(1)
  188: 
  189:     hook_dcts = [
  190:         _hook(by_id[hook['id']], hook, root_config=root_config)
  191:         for hook in repo_config['hooks']
  192:     ]
  193:     return tuple(
  194:         Hook.create(
  195:             repo_config['repo'],
  196:             Prefix(store.clone(repo, rev, hook['additional_dependencies'])),
  197:             hook,
  198:         )
  199:         for hook in hook_dcts
  200:     )
  201: 
  202: 
  203: def _repository_hooks(
  204:         repo_config: dict[str, Any],
  205:         store: Store,
  206:         root_config: dict[str, Any],
  207: ) -> tuple[Hook, ...]:
  208:     if repo_config['repo'] in {LOCAL, META}:
  209:         return _non_cloned_repository_hooks(repo_config, store, root_config)
  210:     else:
  211:         return _cloned_repository_hooks(repo_config, store, root_config)
  212: 
  213: 
  214: def install_hook_envs(hooks: Sequence[Hook], store: Store) -> None:
  215:     def _need_installed() -> list[Hook]:
  216:         seen: set[tuple[Prefix, str, str, tuple[str, ...]]] = set()
  217:         ret = []
  218:         for hook in hooks:
  219:             if hook.install_key not in seen and not _hook_installed(hook):
  220:                 ret.append(hook)
  221:             seen.add(hook.install_key)
  222:         return ret
  223: 
  224:     if not _need_installed():
  225:         return
  226:     with store.exclusive_lock():
  227:         # Another process may have already completed this work
  228:         for hook in _need_installed():
  229:             _hook_install(hook)
  230: 
  231: 
  232: def all_hooks(root_config: dict[str, Any], store: Store) -> tuple[Hook, ...]:
  233:     return tuple(
  234:         hook
  235:         for repo in root_config['repos']
  236:         for hook in _repository_hooks(repo, store, root_config)
  237:     )
