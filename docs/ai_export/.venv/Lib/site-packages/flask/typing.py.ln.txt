    1: from __future__ import annotations
    2: 
    3: import typing as t
    4: 
    5: if t.TYPE_CHECKING:  # pragma: no cover
    6:     from _typeshed.wsgi import WSGIApplication  # noqa: F401
    7:     from werkzeug.datastructures import Headers  # noqa: F401
    8:     from werkzeug.sansio.response import Response  # noqa: F401
    9: 
   10: # The possible types that are directly convertible or are a Response object.
   11: ResponseValue = t.Union[
   12:     "Response",
   13:     str,
   14:     bytes,
   15:     t.List[t.Any],
   16:     # Only dict is actually accepted, but Mapping allows for TypedDict.
   17:     t.Mapping[str, t.Any],
   18:     t.Iterator[str],
   19:     t.Iterator[bytes],
   20: ]
   21: 
   22: # the possible types for an individual HTTP header
   23: # This should be a Union, but mypy doesn't pass unless it's a TypeVar.
   24: HeaderValue = t.Union[str, t.List[str], t.Tuple[str, ...]]
   25: 
   26: # the possible types for HTTP headers
   27: HeadersValue = t.Union[
   28:     "Headers",
   29:     t.Mapping[str, HeaderValue],
   30:     t.Sequence[t.Tuple[str, HeaderValue]],
   31: ]
   32: 
   33: # The possible types returned by a route function.
   34: ResponseReturnValue = t.Union[
   35:     ResponseValue,
   36:     t.Tuple[ResponseValue, HeadersValue],
   37:     t.Tuple[ResponseValue, int],
   38:     t.Tuple[ResponseValue, int, HeadersValue],
   39:     "WSGIApplication",
   40: ]
   41: 
   42: # Allow any subclass of werkzeug.Response, such as the one from Flask,
   43: # as a callback argument. Using werkzeug.Response directly makes a
   44: # callback annotated with flask.Response fail type checking.
   45: ResponseClass = t.TypeVar("ResponseClass", bound="Response")
   46: 
   47: AppOrBlueprintKey = t.Optional[str]  # The App key is None, whereas blueprints are named
   48: AfterRequestCallable = t.Union[
   49:     t.Callable[[ResponseClass], ResponseClass],
   50:     t.Callable[[ResponseClass], t.Awaitable[ResponseClass]],
   51: ]
   52: BeforeFirstRequestCallable = t.Union[
   53:     t.Callable[[], None], t.Callable[[], t.Awaitable[None]]
   54: ]
   55: BeforeRequestCallable = t.Union[
   56:     t.Callable[[], t.Optional[ResponseReturnValue]],
   57:     t.Callable[[], t.Awaitable[t.Optional[ResponseReturnValue]]],
   58: ]
   59: ShellContextProcessorCallable = t.Callable[[], t.Dict[str, t.Any]]
   60: TeardownCallable = t.Union[
   61:     t.Callable[[t.Optional[BaseException]], None],
   62:     t.Callable[[t.Optional[BaseException]], t.Awaitable[None]],
   63: ]
   64: TemplateContextProcessorCallable = t.Union[
   65:     t.Callable[[], t.Dict[str, t.Any]],
   66:     t.Callable[[], t.Awaitable[t.Dict[str, t.Any]]],
   67: ]
   68: TemplateFilterCallable = t.Callable[..., t.Any]
   69: TemplateGlobalCallable = t.Callable[..., t.Any]
   70: TemplateTestCallable = t.Callable[..., bool]
   71: URLDefaultCallable = t.Callable[[str, t.Dict[str, t.Any]], None]
   72: URLValuePreprocessorCallable = t.Callable[
   73:     [t.Optional[str], t.Optional[t.Dict[str, t.Any]]], None
   74: ]
   75: 
   76: # This should take Exception, but that either breaks typing the argument
   77: # with a specific exception, or decorating multiple times with different
   78: # exceptions (and using a union type on the argument).
   79: # https://github.com/pallets/flask/issues/4095
   80: # https://github.com/pallets/flask/issues/4295
   81: # https://github.com/pallets/flask/issues/4297
   82: ErrorHandlerCallable = t.Union[
   83:     t.Callable[[t.Any], ResponseReturnValue],
   84:     t.Callable[[t.Any], t.Awaitable[ResponseReturnValue]],
   85: ]
   86: 
   87: RouteCallable = t.Union[
   88:     t.Callable[..., ResponseReturnValue],
   89:     t.Callable[..., t.Awaitable[ResponseReturnValue]],
   90: ]
