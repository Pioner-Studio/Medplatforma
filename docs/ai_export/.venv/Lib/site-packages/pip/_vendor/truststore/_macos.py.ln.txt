    1: import contextlib
    2: import ctypes
    3: import platform
    4: import ssl
    5: import typing
    6: from ctypes import (
    7:     CDLL,
    8:     POINTER,
    9:     c_bool,
   10:     c_char_p,
   11:     c_int32,
   12:     c_long,
   13:     c_uint32,
   14:     c_ulong,
   15:     c_void_p,
   16: )
   17: from ctypes.util import find_library
   18: 
   19: from ._ssl_constants import _set_ssl_context_verify_mode
   20: 
   21: _mac_version = platform.mac_ver()[0]
   22: _mac_version_info = tuple(map(int, _mac_version.split(".")))
   23: if _mac_version_info < (10, 8):
   24:     raise ImportError(
   25:         f"Only OS X 10.8 and newer are supported, not {_mac_version_info[0]}.{_mac_version_info[1]}"
   26:     )
   27: 
   28: _is_macos_version_10_14_or_later = _mac_version_info >= (10, 14)
   29: 
   30: 
   31: def _load_cdll(name: str, macos10_16_path: str) -> CDLL:
   32:     """Loads a CDLL by name, falling back to known path on 10.16+"""
   33:     try:
   34:         # Big Sur is technically 11 but we use 10.16 due to the Big Sur
   35:         # beta being labeled as 10.16.
   36:         path: str | None
   37:         if _mac_version_info >= (10, 16):
   38:             path = macos10_16_path
   39:         else:
   40:             path = find_library(name)
   41:         if not path:
   42:             raise OSError  # Caught and reraised as 'ImportError'
   43:         return CDLL(path, use_errno=True)
   44:     except OSError:
   45:         raise ImportError(f"The library {name} failed to load") from None
   46: 
   47: 
   48: Security = _load_cdll(
   49:     "Security", "/System/Library/Frameworks/Security.framework/Security"
   50: )
   51: CoreFoundation = _load_cdll(
   52:     "CoreFoundation",
   53:     "/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation",
   54: )
   55: 
   56: Boolean = c_bool
   57: CFIndex = c_long
   58: CFStringEncoding = c_uint32
   59: CFData = c_void_p
   60: CFString = c_void_p
   61: CFArray = c_void_p
   62: CFMutableArray = c_void_p
   63: CFError = c_void_p
   64: CFType = c_void_p
   65: CFTypeID = c_ulong
   66: CFTypeRef = POINTER(CFType)
   67: CFAllocatorRef = c_void_p
   68: 
   69: OSStatus = c_int32
   70: 
   71: CFErrorRef = POINTER(CFError)
   72: CFDataRef = POINTER(CFData)
   73: CFStringRef = POINTER(CFString)
   74: CFArrayRef = POINTER(CFArray)
   75: CFMutableArrayRef = POINTER(CFMutableArray)
   76: CFArrayCallBacks = c_void_p
   77: CFOptionFlags = c_uint32
   78: 
   79: SecCertificateRef = POINTER(c_void_p)
   80: SecPolicyRef = POINTER(c_void_p)
   81: SecTrustRef = POINTER(c_void_p)
   82: SecTrustResultType = c_uint32
   83: SecTrustOptionFlags = c_uint32
   84: 
   85: try:
   86:     Security.SecCertificateCreateWithData.argtypes = [CFAllocatorRef, CFDataRef]
   87:     Security.SecCertificateCreateWithData.restype = SecCertificateRef
   88: 
   89:     Security.SecCertificateCopyData.argtypes = [SecCertificateRef]
   90:     Security.SecCertificateCopyData.restype = CFDataRef
   91: 
   92:     Security.SecCopyErrorMessageString.argtypes = [OSStatus, c_void_p]
   93:     Security.SecCopyErrorMessageString.restype = CFStringRef
   94: 
   95:     Security.SecTrustSetAnchorCertificates.argtypes = [SecTrustRef, CFArrayRef]
   96:     Security.SecTrustSetAnchorCertificates.restype = OSStatus
   97: 
   98:     Security.SecTrustSetAnchorCertificatesOnly.argtypes = [SecTrustRef, Boolean]
   99:     Security.SecTrustSetAnchorCertificatesOnly.restype = OSStatus
  100: 
  101:     Security.SecPolicyCreateRevocation.argtypes = [CFOptionFlags]
  102:     Security.SecPolicyCreateRevocation.restype = SecPolicyRef
  103: 
  104:     Security.SecPolicyCreateSSL.argtypes = [Boolean, CFStringRef]
  105:     Security.SecPolicyCreateSSL.restype = SecPolicyRef
  106: 
  107:     Security.SecTrustCreateWithCertificates.argtypes = [
  108:         CFTypeRef,
  109:         CFTypeRef,
  110:         POINTER(SecTrustRef),
  111:     ]
  112:     Security.SecTrustCreateWithCertificates.restype = OSStatus
  113: 
  114:     Security.SecTrustGetTrustResult.argtypes = [
  115:         SecTrustRef,
  116:         POINTER(SecTrustResultType),
  117:     ]
  118:     Security.SecTrustGetTrustResult.restype = OSStatus
  119: 
  120:     Security.SecTrustEvaluate.argtypes = [
  121:         SecTrustRef,
  122:         POINTER(SecTrustResultType),
  123:     ]
  124:     Security.SecTrustEvaluate.restype = OSStatus
  125: 
  126:     Security.SecTrustRef = SecTrustRef  # type: ignore[attr-defined]
  127:     Security.SecTrustResultType = SecTrustResultType  # type: ignore[attr-defined]
  128:     Security.OSStatus = OSStatus  # type: ignore[attr-defined]
  129: 
  130:     kSecRevocationUseAnyAvailableMethod = 3
  131:     kSecRevocationRequirePositiveResponse = 8
  132: 
  133:     CoreFoundation.CFRelease.argtypes = [CFTypeRef]
  134:     CoreFoundation.CFRelease.restype = None
  135: 
  136:     CoreFoundation.CFGetTypeID.argtypes = [CFTypeRef]
  137:     CoreFoundation.CFGetTypeID.restype = CFTypeID
  138: 
  139:     CoreFoundation.CFStringCreateWithCString.argtypes = [
  140:         CFAllocatorRef,
  141:         c_char_p,
  142:         CFStringEncoding,
  143:     ]
  144:     CoreFoundation.CFStringCreateWithCString.restype = CFStringRef
  145: 
  146:     CoreFoundation.CFStringGetCStringPtr.argtypes = [CFStringRef, CFStringEncoding]
  147:     CoreFoundation.CFStringGetCStringPtr.restype = c_char_p
  148: 
  149:     CoreFoundation.CFStringGetCString.argtypes = [
  150:         CFStringRef,
  151:         c_char_p,
  152:         CFIndex,
  153:         CFStringEncoding,
  154:     ]
  155:     CoreFoundation.CFStringGetCString.restype = c_bool
  156: 
  157:     CoreFoundation.CFDataCreate.argtypes = [CFAllocatorRef, c_char_p, CFIndex]
  158:     CoreFoundation.CFDataCreate.restype = CFDataRef
  159: 
  160:     CoreFoundation.CFDataGetLength.argtypes = [CFDataRef]
  161:     CoreFoundation.CFDataGetLength.restype = CFIndex
  162: 
  163:     CoreFoundation.CFDataGetBytePtr.argtypes = [CFDataRef]
  164:     CoreFoundation.CFDataGetBytePtr.restype = c_void_p
  165: 
  166:     CoreFoundation.CFArrayCreate.argtypes = [
  167:         CFAllocatorRef,
  168:         POINTER(CFTypeRef),
  169:         CFIndex,
  170:         CFArrayCallBacks,
  171:     ]
  172:     CoreFoundation.CFArrayCreate.restype = CFArrayRef
  173: 
  174:     CoreFoundation.CFArrayCreateMutable.argtypes = [
  175:         CFAllocatorRef,
  176:         CFIndex,
  177:         CFArrayCallBacks,
  178:     ]
  179:     CoreFoundation.CFArrayCreateMutable.restype = CFMutableArrayRef
  180: 
  181:     CoreFoundation.CFArrayAppendValue.argtypes = [CFMutableArrayRef, c_void_p]
  182:     CoreFoundation.CFArrayAppendValue.restype = None
  183: 
  184:     CoreFoundation.CFArrayGetCount.argtypes = [CFArrayRef]
  185:     CoreFoundation.CFArrayGetCount.restype = CFIndex
  186: 
  187:     CoreFoundation.CFArrayGetValueAtIndex.argtypes = [CFArrayRef, CFIndex]
  188:     CoreFoundation.CFArrayGetValueAtIndex.restype = c_void_p
  189: 
  190:     CoreFoundation.CFErrorGetCode.argtypes = [CFErrorRef]
  191:     CoreFoundation.CFErrorGetCode.restype = CFIndex
  192: 
  193:     CoreFoundation.CFErrorCopyDescription.argtypes = [CFErrorRef]
  194:     CoreFoundation.CFErrorCopyDescription.restype = CFStringRef
  195: 
  196:     CoreFoundation.kCFAllocatorDefault = CFAllocatorRef.in_dll(  # type: ignore[attr-defined]
  197:         CoreFoundation, "kCFAllocatorDefault"
  198:     )
  199:     CoreFoundation.kCFTypeArrayCallBacks = c_void_p.in_dll(  # type: ignore[attr-defined]
  200:         CoreFoundation, "kCFTypeArrayCallBacks"
  201:     )
  202: 
  203:     CoreFoundation.CFTypeRef = CFTypeRef  # type: ignore[attr-defined]
  204:     CoreFoundation.CFArrayRef = CFArrayRef  # type: ignore[attr-defined]
  205:     CoreFoundation.CFStringRef = CFStringRef  # type: ignore[attr-defined]
  206:     CoreFoundation.CFErrorRef = CFErrorRef  # type: ignore[attr-defined]
  207: 
  208: except AttributeError as e:
  209:     raise ImportError(f"Error initializing ctypes: {e}") from None
  210: 
  211: # SecTrustEvaluateWithError is macOS 10.14+
  212: if _is_macos_version_10_14_or_later:
  213:     try:
  214:         Security.SecTrustEvaluateWithError.argtypes = [
  215:             SecTrustRef,
  216:             POINTER(CFErrorRef),
  217:         ]
  218:         Security.SecTrustEvaluateWithError.restype = c_bool
  219:     except AttributeError as e:
  220:         raise ImportError(f"Error initializing ctypes: {e}") from None
  221: 
  222: 
  223: def _handle_osstatus(result: OSStatus, _: typing.Any, args: typing.Any) -> typing.Any:
  224:     """
  225:     Raises an error if the OSStatus value is non-zero.
  226:     """
  227:     if int(result) == 0:
  228:         return args
  229: 
  230:     # Returns a CFString which we need to transform
  231:     # into a UTF-8 Python string.
  232:     error_message_cfstring = None
  233:     try:
  234:         error_message_cfstring = Security.SecCopyErrorMessageString(result, None)
  235: 
  236:         # First step is convert the CFString into a C string pointer.
  237:         # We try the fast no-copy way first.
  238:         error_message_cfstring_c_void_p = ctypes.cast(
  239:             error_message_cfstring, ctypes.POINTER(ctypes.c_void_p)
  240:         )
  241:         message = CoreFoundation.CFStringGetCStringPtr(
  242:             error_message_cfstring_c_void_p, CFConst.kCFStringEncodingUTF8
  243:         )
  244: 
  245:         # Quoting the Apple dev docs:
  246:         #
  247:         # "A pointer to a C string or NULL if the internal
  248:         # storage of theString does not allow this to be
  249:         # returned efficiently."
  250:         #
  251:         # So we need to get our hands dirty.
  252:         if message is None:
  253:             buffer = ctypes.create_string_buffer(1024)
  254:             result = CoreFoundation.CFStringGetCString(
  255:                 error_message_cfstring_c_void_p,
  256:                 buffer,
  257:                 1024,
  258:                 CFConst.kCFStringEncodingUTF8,
  259:             )
  260:             if not result:
  261:                 raise OSError("Error copying C string from CFStringRef")
  262:             message = buffer.value
  263: 
  264:     finally:
  265:         if error_message_cfstring is not None:
  266:             CoreFoundation.CFRelease(error_message_cfstring)
  267: 
  268:     # If no message can be found for this status we come
  269:     # up with a generic one that forwards the status code.
  270:     if message is None or message == "":
  271:         message = f"SecureTransport operation returned a non-zero OSStatus: {result}"
  272: 
  273:     raise ssl.SSLError(message)
  274: 
  275: 
  276: Security.SecTrustCreateWithCertificates.errcheck = _handle_osstatus  # type: ignore[assignment]
  277: Security.SecTrustSetAnchorCertificates.errcheck = _handle_osstatus  # type: ignore[assignment]
  278: Security.SecTrustSetAnchorCertificatesOnly.errcheck = _handle_osstatus  # type: ignore[assignment]
  279: Security.SecTrustGetTrustResult.errcheck = _handle_osstatus  # type: ignore[assignment]
  280: Security.SecTrustEvaluate.errcheck = _handle_osstatus  # type: ignore[assignment]
  281: 
  282: 
  283: class CFConst:
  284:     """CoreFoundation constants"""
  285: 
  286:     kCFStringEncodingUTF8 = CFStringEncoding(0x08000100)
  287: 
  288:     errSecIncompleteCertRevocationCheck = -67635
  289:     errSecHostNameMismatch = -67602
  290:     errSecCertificateExpired = -67818
  291:     errSecNotTrusted = -67843
  292: 
  293: 
  294: def _bytes_to_cf_data_ref(value: bytes) -> CFDataRef:  # type: ignore[valid-type]
  295:     return CoreFoundation.CFDataCreate(  # type: ignore[no-any-return]
  296:         CoreFoundation.kCFAllocatorDefault, value, len(value)
  297:     )
  298: 
  299: 
  300: def _bytes_to_cf_string(value: bytes) -> CFString:
  301:     """
  302:     Given a Python binary data, create a CFString.
  303:     The string must be CFReleased by the caller.
  304:     """
  305:     c_str = ctypes.c_char_p(value)
  306:     cf_str = CoreFoundation.CFStringCreateWithCString(
  307:         CoreFoundation.kCFAllocatorDefault,
  308:         c_str,
  309:         CFConst.kCFStringEncodingUTF8,
  310:     )
  311:     return cf_str  # type: ignore[no-any-return]
  312: 
  313: 
  314: def _cf_string_ref_to_str(cf_string_ref: CFStringRef) -> str | None:  # type: ignore[valid-type]
  315:     """
  316:     Creates a Unicode string from a CFString object. Used entirely for error
  317:     reporting.
  318:     Yes, it annoys me quite a lot that this function is this complex.
  319:     """
  320: 
  321:     string = CoreFoundation.CFStringGetCStringPtr(
  322:         cf_string_ref, CFConst.kCFStringEncodingUTF8
  323:     )
  324:     if string is None:
  325:         buffer = ctypes.create_string_buffer(1024)
  326:         result = CoreFoundation.CFStringGetCString(
  327:             cf_string_ref, buffer, 1024, CFConst.kCFStringEncodingUTF8
  328:         )
  329:         if not result:
  330:             raise OSError("Error copying C string from CFStringRef")
  331:         string = buffer.value
  332:     if string is not None:
  333:         string = string.decode("utf-8")
  334:     return string  # type: ignore[no-any-return]
  335: 
  336: 
  337: def _der_certs_to_cf_cert_array(certs: list[bytes]) -> CFMutableArrayRef:  # type: ignore[valid-type]
  338:     """Builds a CFArray of SecCertificateRefs from a list of DER-encoded certificates.
  339:     Responsibility of the caller to call CoreFoundation.CFRelease on the CFArray.
  340:     """
  341:     cf_array = CoreFoundation.CFArrayCreateMutable(
  342:         CoreFoundation.kCFAllocatorDefault,
  343:         0,
  344:         ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),
  345:     )
  346:     if not cf_array:
  347:         raise MemoryError("Unable to allocate memory!")
  348: 
  349:     for cert_data in certs:
  350:         cf_data = None
  351:         sec_cert_ref = None
  352:         try:
  353:             cf_data = _bytes_to_cf_data_ref(cert_data)
  354:             sec_cert_ref = Security.SecCertificateCreateWithData(
  355:                 CoreFoundation.kCFAllocatorDefault, cf_data
  356:             )
  357:             CoreFoundation.CFArrayAppendValue(cf_array, sec_cert_ref)
  358:         finally:
  359:             if cf_data:
  360:                 CoreFoundation.CFRelease(cf_data)
  361:             if sec_cert_ref:
  362:                 CoreFoundation.CFRelease(sec_cert_ref)
  363: 
  364:     return cf_array  # type: ignore[no-any-return]
  365: 
  366: 
  367: @contextlib.contextmanager
  368: def _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:
  369:     check_hostname = ctx.check_hostname
  370:     verify_mode = ctx.verify_mode
  371:     ctx.check_hostname = False
  372:     _set_ssl_context_verify_mode(ctx, ssl.CERT_NONE)
  373:     try:
  374:         yield
  375:     finally:
  376:         ctx.check_hostname = check_hostname
  377:         _set_ssl_context_verify_mode(ctx, verify_mode)
  378: 
  379: 
  380: def _verify_peercerts_impl(
  381:     ssl_context: ssl.SSLContext,
  382:     cert_chain: list[bytes],
  383:     server_hostname: str | None = None,
  384: ) -> None:
  385:     certs = None
  386:     policies = None
  387:     trust = None
  388:     try:
  389:         # Only set a hostname on the policy if we're verifying the hostname
  390:         # on the leaf certificate.
  391:         if server_hostname is not None and ssl_context.check_hostname:
  392:             cf_str_hostname = None
  393:             try:
  394:                 cf_str_hostname = _bytes_to_cf_string(server_hostname.encode("ascii"))
  395:                 ssl_policy = Security.SecPolicyCreateSSL(True, cf_str_hostname)
  396:             finally:
  397:                 if cf_str_hostname:
  398:                     CoreFoundation.CFRelease(cf_str_hostname)
  399:         else:
  400:             ssl_policy = Security.SecPolicyCreateSSL(True, None)
  401: 
  402:         policies = ssl_policy
  403:         if ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_CHAIN:
  404:             # Add explicit policy requiring positive revocation checks
  405:             policies = CoreFoundation.CFArrayCreateMutable(
  406:                 CoreFoundation.kCFAllocatorDefault,
  407:                 0,
  408:                 ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),
  409:             )
  410:             CoreFoundation.CFArrayAppendValue(policies, ssl_policy)
  411:             CoreFoundation.CFRelease(ssl_policy)
  412:             revocation_policy = Security.SecPolicyCreateRevocation(
  413:                 kSecRevocationUseAnyAvailableMethod
  414:                 | kSecRevocationRequirePositiveResponse
  415:             )
  416:             CoreFoundation.CFArrayAppendValue(policies, revocation_policy)
  417:             CoreFoundation.CFRelease(revocation_policy)
  418:         elif ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_LEAF:
  419:             raise NotImplementedError("VERIFY_CRL_CHECK_LEAF not implemented for macOS")
  420: 
  421:         certs = None
  422:         try:
  423:             certs = _der_certs_to_cf_cert_array(cert_chain)
  424: 
  425:             # Now that we have certificates loaded and a SecPolicy
  426:             # we can finally create a SecTrust object!
  427:             trust = Security.SecTrustRef()
  428:             Security.SecTrustCreateWithCertificates(
  429:                 certs, policies, ctypes.byref(trust)
  430:             )
  431: 
  432:         finally:
  433:             # The certs are now being held by SecTrust so we can
  434:             # release our handles for the array.
  435:             if certs:
  436:                 CoreFoundation.CFRelease(certs)
  437: 
  438:         # If there are additional trust anchors to load we need to transform
  439:         # the list of DER-encoded certificates into a CFArray.
  440:         ctx_ca_certs_der: list[bytes] | None = ssl_context.get_ca_certs(
  441:             binary_form=True
  442:         )
  443:         if ctx_ca_certs_der:
  444:             ctx_ca_certs = None
  445:             try:
  446:                 ctx_ca_certs = _der_certs_to_cf_cert_array(ctx_ca_certs_der)
  447:                 Security.SecTrustSetAnchorCertificates(trust, ctx_ca_certs)
  448:             finally:
  449:                 if ctx_ca_certs:
  450:                     CoreFoundation.CFRelease(ctx_ca_certs)
  451: 
  452:         # We always want system certificates.
  453:         Security.SecTrustSetAnchorCertificatesOnly(trust, False)
  454: 
  455:         # macOS 10.13 and earlier don't support SecTrustEvaluateWithError()
  456:         # so we use SecTrustEvaluate() which means we need to construct error
  457:         # messages ourselves.
  458:         if _is_macos_version_10_14_or_later:
  459:             _verify_peercerts_impl_macos_10_14(ssl_context, trust)
  460:         else:
  461:             _verify_peercerts_impl_macos_10_13(ssl_context, trust)
  462:     finally:
  463:         if policies:
  464:             CoreFoundation.CFRelease(policies)
  465:         if trust:
  466:             CoreFoundation.CFRelease(trust)
  467: 
  468: 
  469: def _verify_peercerts_impl_macos_10_13(
  470:     ssl_context: ssl.SSLContext, sec_trust_ref: typing.Any
  471: ) -> None:
  472:     """Verify using 'SecTrustEvaluate' API for macOS 10.13 and earlier.
  473:     macOS 10.14 added the 'SecTrustEvaluateWithError' API.
  474:     """
  475:     sec_trust_result_type = Security.SecTrustResultType()
  476:     Security.SecTrustEvaluate(sec_trust_ref, ctypes.byref(sec_trust_result_type))
  477: 
  478:     try:
  479:         sec_trust_result_type_as_int = int(sec_trust_result_type.value)
  480:     except (ValueError, TypeError):
  481:         sec_trust_result_type_as_int = -1
  482: 
  483:     # Apple doesn't document these values in their own API docs.
  484:     # See: https://github.com/xybp888/iOS-SDKs/blob/master/iPhoneOS13.0.sdk/System/Library/Frameworks/Security.framework/Headers/SecTrust.h#L84
  485:     if (
  486:         ssl_context.verify_mode == ssl.CERT_REQUIRED
  487:         and sec_trust_result_type_as_int not in (1, 4)
  488:     ):
  489:         # Note that we're not able to ignore only hostname errors
  490:         # for macOS 10.13 and earlier, so check_hostname=False will
  491:         # still return an error.
  492:         sec_trust_result_type_to_message = {
  493:             0: "Invalid trust result type",
  494:             # 1: "Trust evaluation succeeded",
  495:             2: "User confirmation required",
  496:             3: "User specified that certificate is not trusted",
  497:             # 4: "Trust result is unspecified",
  498:             5: "Recoverable trust failure occurred",
  499:             6: "Fatal trust failure occurred",
  500:             7: "Other error occurred, certificate may be revoked",
  501:         }
  502:         error_message = sec_trust_result_type_to_message.get(
  503:             sec_trust_result_type_as_int,
  504:             f"Unknown trust result: {sec_trust_result_type_as_int}",
  505:         )
  506: 
  507:         err = ssl.SSLCertVerificationError(error_message)
  508:         err.verify_message = error_message
  509:         err.verify_code = sec_trust_result_type_as_int
  510:         raise err
  511: 
  512: 
  513: def _verify_peercerts_impl_macos_10_14(
  514:     ssl_context: ssl.SSLContext, sec_trust_ref: typing.Any
  515: ) -> None:
  516:     """Verify using 'SecTrustEvaluateWithError' API for macOS 10.14+."""
  517:     cf_error = CoreFoundation.CFErrorRef()
  518:     sec_trust_eval_result = Security.SecTrustEvaluateWithError(
  519:         sec_trust_ref, ctypes.byref(cf_error)
  520:     )
  521:     # sec_trust_eval_result is a bool (0 or 1)
  522:     # where 1 means that the certs are trusted.
  523:     if sec_trust_eval_result == 1:
  524:         is_trusted = True
  525:     elif sec_trust_eval_result == 0:
  526:         is_trusted = False
  527:     else:
  528:         raise ssl.SSLError(
  529:             f"Unknown result from Security.SecTrustEvaluateWithError: {sec_trust_eval_result!r}"
  530:         )
  531: 
  532:     cf_error_code = 0
  533:     if not is_trusted:
  534:         cf_error_code = CoreFoundation.CFErrorGetCode(cf_error)
  535: 
  536:         # If the error is a known failure that we're
  537:         # explicitly okay with from SSLContext configuration
  538:         # we can set is_trusted accordingly.
  539:         if ssl_context.verify_mode != ssl.CERT_REQUIRED and (
  540:             cf_error_code == CFConst.errSecNotTrusted
  541:             or cf_error_code == CFConst.errSecCertificateExpired
  542:         ):
  543:             is_trusted = True
  544: 
  545:     # If we're still not trusted then we start to
  546:     # construct and raise the SSLCertVerificationError.
  547:     if not is_trusted:
  548:         cf_error_string_ref = None
  549:         try:
  550:             cf_error_string_ref = CoreFoundation.CFErrorCopyDescription(cf_error)
  551: 
  552:             # Can this ever return 'None' if there's a CFError?
  553:             cf_error_message = (
  554:                 _cf_string_ref_to_str(cf_error_string_ref)
  555:                 or "Certificate verification failed"
  556:             )
  557: 
  558:             # TODO: Not sure if we need the SecTrustResultType for anything?
  559:             # We only care whether or not it's a success or failure for now.
  560:             sec_trust_result_type = Security.SecTrustResultType()
  561:             Security.SecTrustGetTrustResult(
  562:                 sec_trust_ref, ctypes.byref(sec_trust_result_type)
  563:             )
  564: 
  565:             err = ssl.SSLCertVerificationError(cf_error_message)
  566:             err.verify_message = cf_error_message
  567:             err.verify_code = cf_error_code
  568:             raise err
  569:         finally:
  570:             if cf_error_string_ref:
  571:                 CoreFoundation.CFRelease(cf_error_string_ref)
