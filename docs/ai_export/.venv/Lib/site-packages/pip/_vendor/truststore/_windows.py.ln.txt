    1: import contextlib
    2: import ssl
    3: import typing
    4: from ctypes import WinDLL  # type: ignore
    5: from ctypes import WinError  # type: ignore
    6: from ctypes import (
    7:     POINTER,
    8:     Structure,
    9:     c_char_p,
   10:     c_ulong,
   11:     c_void_p,
   12:     c_wchar_p,
   13:     cast,
   14:     create_unicode_buffer,
   15:     pointer,
   16:     sizeof,
   17: )
   18: from ctypes.wintypes import (
   19:     BOOL,
   20:     DWORD,
   21:     HANDLE,
   22:     LONG,
   23:     LPCSTR,
   24:     LPCVOID,
   25:     LPCWSTR,
   26:     LPFILETIME,
   27:     LPSTR,
   28:     LPWSTR,
   29: )
   30: from typing import TYPE_CHECKING, Any
   31: 
   32: from ._ssl_constants import _set_ssl_context_verify_mode
   33: 
   34: HCERTCHAINENGINE = HANDLE
   35: HCERTSTORE = HANDLE
   36: HCRYPTPROV_LEGACY = HANDLE
   37: 
   38: 
   39: class CERT_CONTEXT(Structure):
   40:     _fields_ = (
   41:         ("dwCertEncodingType", DWORD),
   42:         ("pbCertEncoded", c_void_p),
   43:         ("cbCertEncoded", DWORD),
   44:         ("pCertInfo", c_void_p),
   45:         ("hCertStore", HCERTSTORE),
   46:     )
   47: 
   48: 
   49: PCERT_CONTEXT = POINTER(CERT_CONTEXT)
   50: PCCERT_CONTEXT = POINTER(PCERT_CONTEXT)
   51: 
   52: 
   53: class CERT_ENHKEY_USAGE(Structure):
   54:     _fields_ = (
   55:         ("cUsageIdentifier", DWORD),
   56:         ("rgpszUsageIdentifier", POINTER(LPSTR)),
   57:     )
   58: 
   59: 
   60: PCERT_ENHKEY_USAGE = POINTER(CERT_ENHKEY_USAGE)
   61: 
   62: 
   63: class CERT_USAGE_MATCH(Structure):
   64:     _fields_ = (
   65:         ("dwType", DWORD),
   66:         ("Usage", CERT_ENHKEY_USAGE),
   67:     )
   68: 
   69: 
   70: class CERT_CHAIN_PARA(Structure):
   71:     _fields_ = (
   72:         ("cbSize", DWORD),
   73:         ("RequestedUsage", CERT_USAGE_MATCH),
   74:         ("RequestedIssuancePolicy", CERT_USAGE_MATCH),
   75:         ("dwUrlRetrievalTimeout", DWORD),
   76:         ("fCheckRevocationFreshnessTime", BOOL),
   77:         ("dwRevocationFreshnessTime", DWORD),
   78:         ("pftCacheResync", LPFILETIME),
   79:         ("pStrongSignPara", c_void_p),
   80:         ("dwStrongSignFlags", DWORD),
   81:     )
   82: 
   83: 
   84: if TYPE_CHECKING:
   85:     PCERT_CHAIN_PARA = pointer[CERT_CHAIN_PARA]  # type: ignore[misc]
   86: else:
   87:     PCERT_CHAIN_PARA = POINTER(CERT_CHAIN_PARA)
   88: 
   89: 
   90: class CERT_TRUST_STATUS(Structure):
   91:     _fields_ = (
   92:         ("dwErrorStatus", DWORD),
   93:         ("dwInfoStatus", DWORD),
   94:     )
   95: 
   96: 
   97: class CERT_CHAIN_ELEMENT(Structure):
   98:     _fields_ = (
   99:         ("cbSize", DWORD),
  100:         ("pCertContext", PCERT_CONTEXT),
  101:         ("TrustStatus", CERT_TRUST_STATUS),
  102:         ("pRevocationInfo", c_void_p),
  103:         ("pIssuanceUsage", PCERT_ENHKEY_USAGE),
  104:         ("pApplicationUsage", PCERT_ENHKEY_USAGE),
  105:         ("pwszExtendedErrorInfo", LPCWSTR),
  106:     )
  107: 
  108: 
  109: PCERT_CHAIN_ELEMENT = POINTER(CERT_CHAIN_ELEMENT)
  110: 
  111: 
  112: class CERT_SIMPLE_CHAIN(Structure):
  113:     _fields_ = (
  114:         ("cbSize", DWORD),
  115:         ("TrustStatus", CERT_TRUST_STATUS),
  116:         ("cElement", DWORD),
  117:         ("rgpElement", POINTER(PCERT_CHAIN_ELEMENT)),
  118:         ("pTrustListInfo", c_void_p),
  119:         ("fHasRevocationFreshnessTime", BOOL),
  120:         ("dwRevocationFreshnessTime", DWORD),
  121:     )
  122: 
  123: 
  124: PCERT_SIMPLE_CHAIN = POINTER(CERT_SIMPLE_CHAIN)
  125: 
  126: 
  127: class CERT_CHAIN_CONTEXT(Structure):
  128:     _fields_ = (
  129:         ("cbSize", DWORD),
  130:         ("TrustStatus", CERT_TRUST_STATUS),
  131:         ("cChain", DWORD),
  132:         ("rgpChain", POINTER(PCERT_SIMPLE_CHAIN)),
  133:         ("cLowerQualityChainContext", DWORD),
  134:         ("rgpLowerQualityChainContext", c_void_p),
  135:         ("fHasRevocationFreshnessTime", BOOL),
  136:         ("dwRevocationFreshnessTime", DWORD),
  137:     )
  138: 
  139: 
  140: PCERT_CHAIN_CONTEXT = POINTER(CERT_CHAIN_CONTEXT)
  141: PCCERT_CHAIN_CONTEXT = POINTER(PCERT_CHAIN_CONTEXT)
  142: 
  143: 
  144: class SSL_EXTRA_CERT_CHAIN_POLICY_PARA(Structure):
  145:     _fields_ = (
  146:         ("cbSize", DWORD),
  147:         ("dwAuthType", DWORD),
  148:         ("fdwChecks", DWORD),
  149:         ("pwszServerName", LPCWSTR),
  150:     )
  151: 
  152: 
  153: class CERT_CHAIN_POLICY_PARA(Structure):
  154:     _fields_ = (
  155:         ("cbSize", DWORD),
  156:         ("dwFlags", DWORD),
  157:         ("pvExtraPolicyPara", c_void_p),
  158:     )
  159: 
  160: 
  161: PCERT_CHAIN_POLICY_PARA = POINTER(CERT_CHAIN_POLICY_PARA)
  162: 
  163: 
  164: class CERT_CHAIN_POLICY_STATUS(Structure):
  165:     _fields_ = (
  166:         ("cbSize", DWORD),
  167:         ("dwError", DWORD),
  168:         ("lChainIndex", LONG),
  169:         ("lElementIndex", LONG),
  170:         ("pvExtraPolicyStatus", c_void_p),
  171:     )
  172: 
  173: 
  174: PCERT_CHAIN_POLICY_STATUS = POINTER(CERT_CHAIN_POLICY_STATUS)
  175: 
  176: 
  177: class CERT_CHAIN_ENGINE_CONFIG(Structure):
  178:     _fields_ = (
  179:         ("cbSize", DWORD),
  180:         ("hRestrictedRoot", HCERTSTORE),
  181:         ("hRestrictedTrust", HCERTSTORE),
  182:         ("hRestrictedOther", HCERTSTORE),
  183:         ("cAdditionalStore", DWORD),
  184:         ("rghAdditionalStore", c_void_p),
  185:         ("dwFlags", DWORD),
  186:         ("dwUrlRetrievalTimeout", DWORD),
  187:         ("MaximumCachedCertificates", DWORD),
  188:         ("CycleDetectionModulus", DWORD),
  189:         ("hExclusiveRoot", HCERTSTORE),
  190:         ("hExclusiveTrustedPeople", HCERTSTORE),
  191:         ("dwExclusiveFlags", DWORD),
  192:     )
  193: 
  194: 
  195: PCERT_CHAIN_ENGINE_CONFIG = POINTER(CERT_CHAIN_ENGINE_CONFIG)
  196: PHCERTCHAINENGINE = POINTER(HCERTCHAINENGINE)
  197: 
  198: X509_ASN_ENCODING = 0x00000001
  199: PKCS_7_ASN_ENCODING = 0x00010000
  200: CERT_STORE_PROV_MEMORY = b"Memory"
  201: CERT_STORE_ADD_USE_EXISTING = 2
  202: USAGE_MATCH_TYPE_OR = 1
  203: OID_PKIX_KP_SERVER_AUTH = c_char_p(b"1.3.6.1.5.5.7.3.1")
  204: CERT_CHAIN_REVOCATION_CHECK_END_CERT = 0x10000000
  205: CERT_CHAIN_REVOCATION_CHECK_CHAIN = 0x20000000
  206: CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS = 0x00000007
  207: CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 0x00000008
  208: CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = 0x00000010
  209: CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = 0x00000040
  210: CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = 0x00000020
  211: CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = 0x00000080
  212: CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS = 0x00000F00
  213: CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG = 0x00008000
  214: CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG = 0x00004000
  215: SECURITY_FLAG_IGNORE_CERT_CN_INVALID = 0x00001000
  216: AUTHTYPE_SERVER = 2
  217: CERT_CHAIN_POLICY_SSL = 4
  218: FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
  219: FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200
  220: 
  221: # Flags to set for SSLContext.verify_mode=CERT_NONE
  222: CERT_CHAIN_POLICY_VERIFY_MODE_NONE_FLAGS = (
  223:     CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS
  224:     | CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG
  225:     | CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG
  226:     | CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG
  227:     | CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG
  228:     | CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG
  229:     | CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS
  230:     | CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG
  231:     | CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG
  232: )
  233: 
  234: wincrypt = WinDLL("crypt32.dll")
  235: kernel32 = WinDLL("kernel32.dll")
  236: 
  237: 
  238: def _handle_win_error(result: bool, _: Any, args: Any) -> Any:
  239:     if not result:
  240:         # Note, actually raises OSError after calling GetLastError and FormatMessage
  241:         raise WinError()
  242:     return args
  243: 
  244: 
  245: CertCreateCertificateChainEngine = wincrypt.CertCreateCertificateChainEngine
  246: CertCreateCertificateChainEngine.argtypes = (
  247:     PCERT_CHAIN_ENGINE_CONFIG,
  248:     PHCERTCHAINENGINE,
  249: )
  250: CertCreateCertificateChainEngine.errcheck = _handle_win_error
  251: 
  252: CertOpenStore = wincrypt.CertOpenStore
  253: CertOpenStore.argtypes = (LPCSTR, DWORD, HCRYPTPROV_LEGACY, DWORD, c_void_p)
  254: CertOpenStore.restype = HCERTSTORE
  255: CertOpenStore.errcheck = _handle_win_error
  256: 
  257: CertAddEncodedCertificateToStore = wincrypt.CertAddEncodedCertificateToStore
  258: CertAddEncodedCertificateToStore.argtypes = (
  259:     HCERTSTORE,
  260:     DWORD,
  261:     c_char_p,
  262:     DWORD,
  263:     DWORD,
  264:     PCCERT_CONTEXT,
  265: )
  266: CertAddEncodedCertificateToStore.restype = BOOL
  267: 
  268: CertCreateCertificateContext = wincrypt.CertCreateCertificateContext
  269: CertCreateCertificateContext.argtypes = (DWORD, c_char_p, DWORD)
  270: CertCreateCertificateContext.restype = PCERT_CONTEXT
  271: CertCreateCertificateContext.errcheck = _handle_win_error
  272: 
  273: CertGetCertificateChain = wincrypt.CertGetCertificateChain
  274: CertGetCertificateChain.argtypes = (
  275:     HCERTCHAINENGINE,
  276:     PCERT_CONTEXT,
  277:     LPFILETIME,
  278:     HCERTSTORE,
  279:     PCERT_CHAIN_PARA,
  280:     DWORD,
  281:     c_void_p,
  282:     PCCERT_CHAIN_CONTEXT,
  283: )
  284: CertGetCertificateChain.restype = BOOL
  285: CertGetCertificateChain.errcheck = _handle_win_error
  286: 
  287: CertVerifyCertificateChainPolicy = wincrypt.CertVerifyCertificateChainPolicy
  288: CertVerifyCertificateChainPolicy.argtypes = (
  289:     c_ulong,
  290:     PCERT_CHAIN_CONTEXT,
  291:     PCERT_CHAIN_POLICY_PARA,
  292:     PCERT_CHAIN_POLICY_STATUS,
  293: )
  294: CertVerifyCertificateChainPolicy.restype = BOOL
  295: 
  296: CertCloseStore = wincrypt.CertCloseStore
  297: CertCloseStore.argtypes = (HCERTSTORE, DWORD)
  298: CertCloseStore.restype = BOOL
  299: CertCloseStore.errcheck = _handle_win_error
  300: 
  301: CertFreeCertificateChain = wincrypt.CertFreeCertificateChain
  302: CertFreeCertificateChain.argtypes = (PCERT_CHAIN_CONTEXT,)
  303: 
  304: CertFreeCertificateContext = wincrypt.CertFreeCertificateContext
  305: CertFreeCertificateContext.argtypes = (PCERT_CONTEXT,)
  306: 
  307: CertFreeCertificateChainEngine = wincrypt.CertFreeCertificateChainEngine
  308: CertFreeCertificateChainEngine.argtypes = (HCERTCHAINENGINE,)
  309: 
  310: FormatMessageW = kernel32.FormatMessageW
  311: FormatMessageW.argtypes = (
  312:     DWORD,
  313:     LPCVOID,
  314:     DWORD,
  315:     DWORD,
  316:     LPWSTR,
  317:     DWORD,
  318:     c_void_p,
  319: )
  320: FormatMessageW.restype = DWORD
  321: 
  322: 
  323: def _verify_peercerts_impl(
  324:     ssl_context: ssl.SSLContext,
  325:     cert_chain: list[bytes],
  326:     server_hostname: str | None = None,
  327: ) -> None:
  328:     """Verify the cert_chain from the server using Windows APIs."""
  329: 
  330:     # If the peer didn't send any certificates then
  331:     # we can't do verification. Raise an error.
  332:     if not cert_chain:
  333:         raise ssl.SSLCertVerificationError("Peer sent no certificates to verify")
  334: 
  335:     pCertContext = None
  336:     hIntermediateCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, None, 0, None)
  337:     try:
  338:         # Add intermediate certs to an in-memory cert store
  339:         for cert_bytes in cert_chain[1:]:
  340:             CertAddEncodedCertificateToStore(
  341:                 hIntermediateCertStore,
  342:                 X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
  343:                 cert_bytes,
  344:                 len(cert_bytes),
  345:                 CERT_STORE_ADD_USE_EXISTING,
  346:                 None,
  347:             )
  348: 
  349:         # Cert context for leaf cert
  350:         leaf_cert = cert_chain[0]
  351:         pCertContext = CertCreateCertificateContext(
  352:             X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, leaf_cert, len(leaf_cert)
  353:         )
  354: 
  355:         # Chain params to match certs for serverAuth extended usage
  356:         cert_enhkey_usage = CERT_ENHKEY_USAGE()
  357:         cert_enhkey_usage.cUsageIdentifier = 1
  358:         cert_enhkey_usage.rgpszUsageIdentifier = (c_char_p * 1)(OID_PKIX_KP_SERVER_AUTH)
  359:         cert_usage_match = CERT_USAGE_MATCH()
  360:         cert_usage_match.Usage = cert_enhkey_usage
  361:         chain_params = CERT_CHAIN_PARA()
  362:         chain_params.RequestedUsage = cert_usage_match
  363:         chain_params.cbSize = sizeof(chain_params)
  364:         pChainPara = pointer(chain_params)
  365: 
  366:         if ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_CHAIN:
  367:             chain_flags = CERT_CHAIN_REVOCATION_CHECK_CHAIN
  368:         elif ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_LEAF:
  369:             chain_flags = CERT_CHAIN_REVOCATION_CHECK_END_CERT
  370:         else:
  371:             chain_flags = 0
  372: 
  373:         try:
  374:             # First attempt to verify using the default Windows system trust roots
  375:             # (default chain engine).
  376:             _get_and_verify_cert_chain(
  377:                 ssl_context,
  378:                 None,
  379:                 hIntermediateCertStore,
  380:                 pCertContext,
  381:                 pChainPara,
  382:                 server_hostname,
  383:                 chain_flags=chain_flags,
  384:             )
  385:         except ssl.SSLCertVerificationError as e:
  386:             # If that fails but custom CA certs have been added
  387:             # to the SSLContext using load_verify_locations,
  388:             # try verifying using a custom chain engine
  389:             # that trusts the custom CA certs.
  390:             custom_ca_certs: list[bytes] | None = ssl_context.get_ca_certs(
  391:                 binary_form=True
  392:             )
  393:             if custom_ca_certs:
  394:                 try:
  395:                     _verify_using_custom_ca_certs(
  396:                         ssl_context,
  397:                         custom_ca_certs,
  398:                         hIntermediateCertStore,
  399:                         pCertContext,
  400:                         pChainPara,
  401:                         server_hostname,
  402:                         chain_flags=chain_flags,
  403:                     )
  404:                 # Raise the original error, not the new error.
  405:                 except ssl.SSLCertVerificationError:
  406:                     raise e from None
  407:             else:
  408:                 raise
  409:     finally:
  410:         CertCloseStore(hIntermediateCertStore, 0)
  411:         if pCertContext:
  412:             CertFreeCertificateContext(pCertContext)
  413: 
  414: 
  415: def _get_and_verify_cert_chain(
  416:     ssl_context: ssl.SSLContext,
  417:     hChainEngine: HCERTCHAINENGINE | None,
  418:     hIntermediateCertStore: HCERTSTORE,
  419:     pPeerCertContext: c_void_p,
  420:     pChainPara: PCERT_CHAIN_PARA,  # type: ignore[valid-type]
  421:     server_hostname: str | None,
  422:     chain_flags: int,
  423: ) -> None:
  424:     ppChainContext = None
  425:     try:
  426:         # Get cert chain
  427:         ppChainContext = pointer(PCERT_CHAIN_CONTEXT())
  428:         CertGetCertificateChain(
  429:             hChainEngine,  # chain engine
  430:             pPeerCertContext,  # leaf cert context
  431:             None,  # current system time
  432:             hIntermediateCertStore,  # additional in-memory cert store
  433:             pChainPara,  # chain-building parameters
  434:             chain_flags,
  435:             None,  # reserved
  436:             ppChainContext,  # the resulting chain context
  437:         )
  438:         pChainContext = ppChainContext.contents
  439: 
  440:         # Verify cert chain
  441:         ssl_extra_cert_chain_policy_para = SSL_EXTRA_CERT_CHAIN_POLICY_PARA()
  442:         ssl_extra_cert_chain_policy_para.cbSize = sizeof(
  443:             ssl_extra_cert_chain_policy_para
  444:         )
  445:         ssl_extra_cert_chain_policy_para.dwAuthType = AUTHTYPE_SERVER
  446:         ssl_extra_cert_chain_policy_para.fdwChecks = 0
  447:         if ssl_context.check_hostname is False:
  448:             ssl_extra_cert_chain_policy_para.fdwChecks = (
  449:                 SECURITY_FLAG_IGNORE_CERT_CN_INVALID
  450:             )
  451:         if server_hostname:
  452:             ssl_extra_cert_chain_policy_para.pwszServerName = c_wchar_p(server_hostname)
  453: 
  454:         chain_policy = CERT_CHAIN_POLICY_PARA()
  455:         chain_policy.pvExtraPolicyPara = cast(
  456:             pointer(ssl_extra_cert_chain_policy_para), c_void_p
  457:         )
  458:         if ssl_context.verify_mode == ssl.CERT_NONE:
  459:             chain_policy.dwFlags |= CERT_CHAIN_POLICY_VERIFY_MODE_NONE_FLAGS
  460:         chain_policy.cbSize = sizeof(chain_policy)
  461: 
  462:         pPolicyPara = pointer(chain_policy)
  463:         policy_status = CERT_CHAIN_POLICY_STATUS()
  464:         policy_status.cbSize = sizeof(policy_status)
  465:         pPolicyStatus = pointer(policy_status)
  466:         CertVerifyCertificateChainPolicy(
  467:             CERT_CHAIN_POLICY_SSL,
  468:             pChainContext,
  469:             pPolicyPara,
  470:             pPolicyStatus,
  471:         )
  472: 
  473:         # Check status
  474:         error_code = policy_status.dwError
  475:         if error_code:
  476:             # Try getting a human readable message for an error code.
  477:             error_message_buf = create_unicode_buffer(1024)
  478:             error_message_chars = FormatMessageW(
  479:                 FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
  480:                 None,
  481:                 error_code,
  482:                 0,
  483:                 error_message_buf,
  484:                 sizeof(error_message_buf),
  485:                 None,
  486:             )
  487: 
  488:             # See if we received a message for the error,
  489:             # otherwise we use a generic error with the
  490:             # error code and hope that it's search-able.
  491:             if error_message_chars <= 0:
  492:                 error_message = f"Certificate chain policy error {error_code:#x} [{policy_status.lElementIndex}]"
  493:             else:
  494:                 error_message = error_message_buf.value.strip()
  495: 
  496:             err = ssl.SSLCertVerificationError(error_message)
  497:             err.verify_message = error_message
  498:             err.verify_code = error_code
  499:             raise err from None
  500:     finally:
  501:         if ppChainContext:
  502:             CertFreeCertificateChain(ppChainContext.contents)
  503: 
  504: 
  505: def _verify_using_custom_ca_certs(
  506:     ssl_context: ssl.SSLContext,
  507:     custom_ca_certs: list[bytes],
  508:     hIntermediateCertStore: HCERTSTORE,
  509:     pPeerCertContext: c_void_p,
  510:     pChainPara: PCERT_CHAIN_PARA,  # type: ignore[valid-type]
  511:     server_hostname: str | None,
  512:     chain_flags: int,
  513: ) -> None:
  514:     hChainEngine = None
  515:     hRootCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, None, 0, None)
  516:     try:
  517:         # Add custom CA certs to an in-memory cert store
  518:         for cert_bytes in custom_ca_certs:
  519:             CertAddEncodedCertificateToStore(
  520:                 hRootCertStore,
  521:                 X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
  522:                 cert_bytes,
  523:                 len(cert_bytes),
  524:                 CERT_STORE_ADD_USE_EXISTING,
  525:                 None,
  526:             )
  527: 
  528:         # Create a custom cert chain engine which exclusively trusts
  529:         # certs from our hRootCertStore
  530:         cert_chain_engine_config = CERT_CHAIN_ENGINE_CONFIG()
  531:         cert_chain_engine_config.cbSize = sizeof(cert_chain_engine_config)
  532:         cert_chain_engine_config.hExclusiveRoot = hRootCertStore
  533:         pConfig = pointer(cert_chain_engine_config)
  534:         phChainEngine = pointer(HCERTCHAINENGINE())
  535:         CertCreateCertificateChainEngine(
  536:             pConfig,
  537:             phChainEngine,
  538:         )
  539:         hChainEngine = phChainEngine.contents
  540: 
  541:         # Get and verify a cert chain using the custom chain engine
  542:         _get_and_verify_cert_chain(
  543:             ssl_context,
  544:             hChainEngine,
  545:             hIntermediateCertStore,
  546:             pPeerCertContext,
  547:             pChainPara,
  548:             server_hostname,
  549:             chain_flags,
  550:         )
  551:     finally:
  552:         if hChainEngine:
  553:             CertFreeCertificateChainEngine(hChainEngine)
  554:         CertCloseStore(hRootCertStore, 0)
  555: 
  556: 
  557: @contextlib.contextmanager
  558: def _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:
  559:     check_hostname = ctx.check_hostname
  560:     verify_mode = ctx.verify_mode
  561:     ctx.check_hostname = False
  562:     _set_ssl_context_verify_mode(ctx, ssl.CERT_NONE)
  563:     try:
  564:         yield
  565:     finally:
  566:         ctx.check_hostname = check_hostname
  567:         _set_ssl_context_verify_mode(ctx, verify_mode)
