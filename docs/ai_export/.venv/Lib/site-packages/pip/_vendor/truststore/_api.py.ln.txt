    1: import os
    2: import platform
    3: import socket
    4: import ssl
    5: import sys
    6: import typing
    7: 
    8: import _ssl
    9: 
   10: from ._ssl_constants import (
   11:     _original_SSLContext,
   12:     _original_super_SSLContext,
   13:     _truststore_SSLContext_dunder_class,
   14:     _truststore_SSLContext_super_class,
   15: )
   16: 
   17: if platform.system() == "Windows":
   18:     from ._windows import _configure_context, _verify_peercerts_impl
   19: elif platform.system() == "Darwin":
   20:     from ._macos import _configure_context, _verify_peercerts_impl
   21: else:
   22:     from ._openssl import _configure_context, _verify_peercerts_impl
   23: 
   24: if typing.TYPE_CHECKING:
   25:     from typing_extensions import Buffer
   26: 
   27: # From typeshed/stdlib/ssl.pyi
   28: _StrOrBytesPath: typing.TypeAlias = str | bytes | os.PathLike[str] | os.PathLike[bytes]
   29: _PasswordType: typing.TypeAlias = str | bytes | typing.Callable[[], str | bytes]
   30: 
   31: 
   32: def inject_into_ssl() -> None:
   33:     """Injects the :class:`truststore.SSLContext` into the ``ssl``
   34:     module by replacing :class:`ssl.SSLContext`.
   35:     """
   36:     setattr(ssl, "SSLContext", SSLContext)
   37:     # urllib3 holds on to its own reference of ssl.SSLContext
   38:     # so we need to replace that reference too.
   39:     try:
   40:         import pip._vendor.urllib3.util.ssl_ as urllib3_ssl
   41: 
   42:         setattr(urllib3_ssl, "SSLContext", SSLContext)
   43:     except ImportError:
   44:         pass
   45: 
   46:     # requests starting with 2.32.0 added a preloaded SSL context to improve concurrent performance;
   47:     # this unfortunately leads to a RecursionError, which can be avoided by patching the preloaded SSL context with
   48:     # the truststore patched instance
   49:     # also see https://github.com/psf/requests/pull/6667
   50:     try:
   51:         from pip._vendor.requests import adapters as requests_adapters
   52: 
   53:         preloaded_context = getattr(requests_adapters, "_preloaded_ssl_context", None)
   54:         if preloaded_context is not None:
   55:             setattr(
   56:                 requests_adapters,
   57:                 "_preloaded_ssl_context",
   58:                 SSLContext(ssl.PROTOCOL_TLS_CLIENT),
   59:             )
   60:     except ImportError:
   61:         pass
   62: 
   63: 
   64: def extract_from_ssl() -> None:
   65:     """Restores the :class:`ssl.SSLContext` class to its original state"""
   66:     setattr(ssl, "SSLContext", _original_SSLContext)
   67:     try:
   68:         import pip._vendor.urllib3.util.ssl_ as urllib3_ssl
   69: 
   70:         urllib3_ssl.SSLContext = _original_SSLContext  # type: ignore[assignment]
   71:     except ImportError:
   72:         pass
   73: 
   74: 
   75: class SSLContext(_truststore_SSLContext_super_class):  # type: ignore[misc]
   76:     """SSLContext API that uses system certificates on all platforms"""
   77: 
   78:     @property  # type: ignore[misc]
   79:     def __class__(self) -> type:
   80:         # Dirty hack to get around isinstance() checks
   81:         # for ssl.SSLContext instances in aiohttp/trustme
   82:         # when using non-CPython implementations.
   83:         return _truststore_SSLContext_dunder_class or SSLContext
   84: 
   85:     def __init__(self, protocol: int = None) -> None:  # type: ignore[assignment]
   86:         self._ctx = _original_SSLContext(protocol)
   87: 
   88:         class TruststoreSSLObject(ssl.SSLObject):
   89:             # This object exists because wrap_bio() doesn't
   90:             # immediately do the handshake so we need to do
   91:             # certificate verifications after SSLObject.do_handshake()
   92: 
   93:             def do_handshake(self) -> None:
   94:                 ret = super().do_handshake()
   95:                 _verify_peercerts(self, server_hostname=self.server_hostname)
   96:                 return ret
   97: 
   98:         self._ctx.sslobject_class = TruststoreSSLObject
   99: 
  100:     def wrap_socket(
  101:         self,
  102:         sock: socket.socket,
  103:         server_side: bool = False,
  104:         do_handshake_on_connect: bool = True,
  105:         suppress_ragged_eofs: bool = True,
  106:         server_hostname: str | None = None,
  107:         session: ssl.SSLSession | None = None,
  108:     ) -> ssl.SSLSocket:
  109:         # Use a context manager here because the
  110:         # inner SSLContext holds on to our state
  111:         # but also does the actual handshake.
  112:         with _configure_context(self._ctx):
  113:             ssl_sock = self._ctx.wrap_socket(
  114:                 sock,
  115:                 server_side=server_side,
  116:                 server_hostname=server_hostname,
  117:                 do_handshake_on_connect=do_handshake_on_connect,
  118:                 suppress_ragged_eofs=suppress_ragged_eofs,
  119:                 session=session,
  120:             )
  121:         try:
  122:             _verify_peercerts(ssl_sock, server_hostname=server_hostname)
  123:         except Exception:
  124:             ssl_sock.close()
  125:             raise
  126:         return ssl_sock
  127: 
  128:     def wrap_bio(
  129:         self,
  130:         incoming: ssl.MemoryBIO,
  131:         outgoing: ssl.MemoryBIO,
  132:         server_side: bool = False,
  133:         server_hostname: str | None = None,
  134:         session: ssl.SSLSession | None = None,
  135:     ) -> ssl.SSLObject:
  136:         with _configure_context(self._ctx):
  137:             ssl_obj = self._ctx.wrap_bio(
  138:                 incoming,
  139:                 outgoing,
  140:                 server_hostname=server_hostname,
  141:                 server_side=server_side,
  142:                 session=session,
  143:             )
  144:         return ssl_obj
  145: 
  146:     def load_verify_locations(
  147:         self,
  148:         cafile: str | bytes | os.PathLike[str] | os.PathLike[bytes] | None = None,
  149:         capath: str | bytes | os.PathLike[str] | os.PathLike[bytes] | None = None,
  150:         cadata: typing.Union[str, "Buffer", None] = None,
  151:     ) -> None:
  152:         return self._ctx.load_verify_locations(
  153:             cafile=cafile, capath=capath, cadata=cadata
  154:         )
  155: 
  156:     def load_cert_chain(
  157:         self,
  158:         certfile: _StrOrBytesPath,
  159:         keyfile: _StrOrBytesPath | None = None,
  160:         password: _PasswordType | None = None,
  161:     ) -> None:
  162:         return self._ctx.load_cert_chain(
  163:             certfile=certfile, keyfile=keyfile, password=password
  164:         )
  165: 
  166:     def load_default_certs(
  167:         self, purpose: ssl.Purpose = ssl.Purpose.SERVER_AUTH
  168:     ) -> None:
  169:         return self._ctx.load_default_certs(purpose)
  170: 
  171:     def set_alpn_protocols(self, alpn_protocols: typing.Iterable[str]) -> None:
  172:         return self._ctx.set_alpn_protocols(alpn_protocols)
  173: 
  174:     def set_npn_protocols(self, npn_protocols: typing.Iterable[str]) -> None:
  175:         return self._ctx.set_npn_protocols(npn_protocols)
  176: 
  177:     def set_ciphers(self, __cipherlist: str) -> None:
  178:         return self._ctx.set_ciphers(__cipherlist)
  179: 
  180:     def get_ciphers(self) -> typing.Any:
  181:         return self._ctx.get_ciphers()
  182: 
  183:     def session_stats(self) -> dict[str, int]:
  184:         return self._ctx.session_stats()
  185: 
  186:     def cert_store_stats(self) -> dict[str, int]:
  187:         raise NotImplementedError()
  188: 
  189:     def set_default_verify_paths(self) -> None:
  190:         self._ctx.set_default_verify_paths()
  191: 
  192:     @typing.overload
  193:     def get_ca_certs(
  194:         self, binary_form: typing.Literal[False] = ...
  195:     ) -> list[typing.Any]: ...
  196: 
  197:     @typing.overload
  198:     def get_ca_certs(self, binary_form: typing.Literal[True] = ...) -> list[bytes]: ...
  199: 
  200:     @typing.overload
  201:     def get_ca_certs(self, binary_form: bool = ...) -> typing.Any: ...
  202: 
  203:     def get_ca_certs(self, binary_form: bool = False) -> list[typing.Any] | list[bytes]:
  204:         raise NotImplementedError()
  205: 
  206:     @property
  207:     def check_hostname(self) -> bool:
  208:         return self._ctx.check_hostname
  209: 
  210:     @check_hostname.setter
  211:     def check_hostname(self, value: bool) -> None:
  212:         self._ctx.check_hostname = value
  213: 
  214:     @property
  215:     def hostname_checks_common_name(self) -> bool:
  216:         return self._ctx.hostname_checks_common_name
  217: 
  218:     @hostname_checks_common_name.setter
  219:     def hostname_checks_common_name(self, value: bool) -> None:
  220:         self._ctx.hostname_checks_common_name = value
  221: 
  222:     @property
  223:     def keylog_filename(self) -> str:
  224:         return self._ctx.keylog_filename
  225: 
  226:     @keylog_filename.setter
  227:     def keylog_filename(self, value: str) -> None:
  228:         self._ctx.keylog_filename = value
  229: 
  230:     @property
  231:     def maximum_version(self) -> ssl.TLSVersion:
  232:         return self._ctx.maximum_version
  233: 
  234:     @maximum_version.setter
  235:     def maximum_version(self, value: ssl.TLSVersion) -> None:
  236:         _original_super_SSLContext.maximum_version.__set__(  # type: ignore[attr-defined]
  237:             self._ctx, value
  238:         )
  239: 
  240:     @property
  241:     def minimum_version(self) -> ssl.TLSVersion:
  242:         return self._ctx.minimum_version
  243: 
  244:     @minimum_version.setter
  245:     def minimum_version(self, value: ssl.TLSVersion) -> None:
  246:         _original_super_SSLContext.minimum_version.__set__(  # type: ignore[attr-defined]
  247:             self._ctx, value
  248:         )
  249: 
  250:     @property
  251:     def options(self) -> ssl.Options:
  252:         return self._ctx.options
  253: 
  254:     @options.setter
  255:     def options(self, value: ssl.Options) -> None:
  256:         _original_super_SSLContext.options.__set__(  # type: ignore[attr-defined]
  257:             self._ctx, value
  258:         )
  259: 
  260:     @property
  261:     def post_handshake_auth(self) -> bool:
  262:         return self._ctx.post_handshake_auth
  263: 
  264:     @post_handshake_auth.setter
  265:     def post_handshake_auth(self, value: bool) -> None:
  266:         self._ctx.post_handshake_auth = value
  267: 
  268:     @property
  269:     def protocol(self) -> ssl._SSLMethod:
  270:         return self._ctx.protocol
  271: 
  272:     @property
  273:     def security_level(self) -> int:
  274:         return self._ctx.security_level
  275: 
  276:     @property
  277:     def verify_flags(self) -> ssl.VerifyFlags:
  278:         return self._ctx.verify_flags
  279: 
  280:     @verify_flags.setter
  281:     def verify_flags(self, value: ssl.VerifyFlags) -> None:
  282:         _original_super_SSLContext.verify_flags.__set__(  # type: ignore[attr-defined]
  283:             self._ctx, value
  284:         )
  285: 
  286:     @property
  287:     def verify_mode(self) -> ssl.VerifyMode:
  288:         return self._ctx.verify_mode
  289: 
  290:     @verify_mode.setter
  291:     def verify_mode(self, value: ssl.VerifyMode) -> None:
  292:         _original_super_SSLContext.verify_mode.__set__(  # type: ignore[attr-defined]
  293:             self._ctx, value
  294:         )
  295: 
  296: 
  297: # Python 3.13+ makes get_unverified_chain() a public API that only returns DER
  298: # encoded certificates. We detect whether we need to call public_bytes() for 3.10->3.12
  299: # Pre-3.13 returned None instead of an empty list from get_unverified_chain()
  300: if sys.version_info >= (3, 13):
  301: 
  302:     def _get_unverified_chain_bytes(sslobj: ssl.SSLObject) -> list[bytes]:
  303:         unverified_chain = sslobj.get_unverified_chain() or ()  # type: ignore[attr-defined]
  304:         return [
  305:             cert if isinstance(cert, bytes) else cert.public_bytes(_ssl.ENCODING_DER)
  306:             for cert in unverified_chain
  307:         ]
  308: 
  309: else:
  310: 
  311:     def _get_unverified_chain_bytes(sslobj: ssl.SSLObject) -> list[bytes]:
  312:         unverified_chain = sslobj.get_unverified_chain() or ()  # type: ignore[attr-defined]
  313:         return [cert.public_bytes(_ssl.ENCODING_DER) for cert in unverified_chain]
  314: 
  315: 
  316: def _verify_peercerts(
  317:     sock_or_sslobj: ssl.SSLSocket | ssl.SSLObject, server_hostname: str | None
  318: ) -> None:
  319:     """
  320:     Verifies the peer certificates from an SSLSocket or SSLObject
  321:     against the certificates in the OS trust store.
  322:     """
  323:     sslobj: ssl.SSLObject = sock_or_sslobj  # type: ignore[assignment]
  324:     try:
  325:         while not hasattr(sslobj, "get_unverified_chain"):
  326:             sslobj = sslobj._sslobj  # type: ignore[attr-defined]
  327:     except AttributeError:
  328:         pass
  329: 
  330:     cert_bytes = _get_unverified_chain_bytes(sslobj)
  331:     _verify_peercerts_impl(
  332:         sock_or_sslobj.context, cert_bytes, server_hostname=server_hostname
  333:     )
