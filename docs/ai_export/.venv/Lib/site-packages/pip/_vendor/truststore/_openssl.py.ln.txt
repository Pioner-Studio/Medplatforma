    1: import contextlib
    2: import os
    3: import re
    4: import ssl
    5: import typing
    6: 
    7: # candidates based on https://github.com/tiran/certifi-system-store by Christian Heimes
    8: _CA_FILE_CANDIDATES = [
    9:     # Alpine, Arch, Fedora 34+, OpenWRT, RHEL 9+, BSD
   10:     "/etc/ssl/cert.pem",
   11:     # Fedora <= 34, RHEL <= 9, CentOS <= 9
   12:     "/etc/pki/tls/cert.pem",
   13:     # Debian, Ubuntu (requires ca-certificates)
   14:     "/etc/ssl/certs/ca-certificates.crt",
   15:     # SUSE
   16:     "/etc/ssl/ca-bundle.pem",
   17: ]
   18: 
   19: _HASHED_CERT_FILENAME_RE = re.compile(r"^[0-9a-fA-F]{8}\.[0-9]$")
   20: 
   21: 
   22: @contextlib.contextmanager
   23: def _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:
   24:     # First, check whether the default locations from OpenSSL
   25:     # seem like they will give us a usable set of CA certs.
   26:     # ssl.get_default_verify_paths already takes care of:
   27:     # - getting cafile from either the SSL_CERT_FILE env var
   28:     #   or the path configured when OpenSSL was compiled,
   29:     #   and verifying that that path exists
   30:     # - getting capath from either the SSL_CERT_DIR env var
   31:     #   or the path configured when OpenSSL was compiled,
   32:     #   and verifying that that path exists
   33:     # In addition we'll check whether capath appears to contain certs.
   34:     defaults = ssl.get_default_verify_paths()
   35:     if defaults.cafile or (defaults.capath and _capath_contains_certs(defaults.capath)):
   36:         ctx.set_default_verify_paths()
   37:     else:
   38:         # cafile from OpenSSL doesn't exist
   39:         # and capath from OpenSSL doesn't contain certs.
   40:         # Let's search other common locations instead.
   41:         for cafile in _CA_FILE_CANDIDATES:
   42:             if os.path.isfile(cafile):
   43:                 ctx.load_verify_locations(cafile=cafile)
   44:                 break
   45: 
   46:     yield
   47: 
   48: 
   49: def _capath_contains_certs(capath: str) -> bool:
   50:     """Check whether capath exists and contains certs in the expected format."""
   51:     if not os.path.isdir(capath):
   52:         return False
   53:     for name in os.listdir(capath):
   54:         if _HASHED_CERT_FILENAME_RE.match(name):
   55:             return True
   56:     return False
   57: 
   58: 
   59: def _verify_peercerts_impl(
   60:     ssl_context: ssl.SSLContext,
   61:     cert_chain: list[bytes],
   62:     server_hostname: str | None = None,
   63: ) -> None:
   64:     # This is a no-op because we've enabled SSLContext's built-in
   65:     # verification via verify_mode=CERT_REQUIRED, and don't need to repeat it.
   66:     pass
