    1: """
    2: SecureTranport support for urllib3 via ctypes.
    3: 
    4: This makes platform-native TLS available to urllib3 users on macOS without the
    5: use of a compiler. This is an important feature because the Python Package
    6: Index is moving to become a TLSv1.2-or-higher server, and the default OpenSSL
    7: that ships with macOS is not capable of doing TLSv1.2. The only way to resolve
    8: this is to give macOS users an alternative solution to the problem, and that
    9: solution is to use SecureTransport.
   10: 
   11: We use ctypes here because this solution must not require a compiler. That's
   12: because pip is not allowed to require a compiler either.
   13: 
   14: This is not intended to be a seriously long-term solution to this problem.
   15: The hope is that PEP 543 will eventually solve this issue for us, at which
   16: point we can retire this contrib module. But in the short term, we need to
   17: solve the impending tire fire that is Python on Mac without this kind of
   18: contrib module. So...here we are.
   19: 
   20: To use this module, simply import and inject it::
   21: 
   22:     import pip._vendor.urllib3.contrib.securetransport as securetransport
   23:     securetransport.inject_into_urllib3()
   24: 
   25: Happy TLSing!
   26: 
   27: This code is a bastardised version of the code found in Will Bond's oscrypto
   28: library. An enormous debt is owed to him for blazing this trail for us. For
   29: that reason, this code should be considered to be covered both by urllib3's
   30: license and by oscrypto's:
   31: 
   32: .. code-block::
   33: 
   34:     Copyright (c) 2015-2016 Will Bond <will@wbond.net>
   35: 
   36:     Permission is hereby granted, free of charge, to any person obtaining a
   37:     copy of this software and associated documentation files (the "Software"),
   38:     to deal in the Software without restriction, including without limitation
   39:     the rights to use, copy, modify, merge, publish, distribute, sublicense,
   40:     and/or sell copies of the Software, and to permit persons to whom the
   41:     Software is furnished to do so, subject to the following conditions:
   42: 
   43:     The above copyright notice and this permission notice shall be included in
   44:     all copies or substantial portions of the Software.
   45: 
   46:     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   47:     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   48:     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   49:     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   50:     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   51:     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   52:     DEALINGS IN THE SOFTWARE.
   53: """
   54: from __future__ import absolute_import
   55: 
   56: import contextlib
   57: import ctypes
   58: import errno
   59: import os.path
   60: import shutil
   61: import socket
   62: import ssl
   63: import struct
   64: import threading
   65: import weakref
   66: 
   67: from .. import util
   68: from ..packages import six
   69: from ..util.ssl_ import PROTOCOL_TLS_CLIENT
   70: from ._securetransport.bindings import CoreFoundation, Security, SecurityConst
   71: from ._securetransport.low_level import (
   72:     _assert_no_error,
   73:     _build_tls_unknown_ca_alert,
   74:     _cert_array_from_pem,
   75:     _create_cfstring_array,
   76:     _load_client_cert_chain,
   77:     _temporary_keychain,
   78: )
   79: 
   80: try:  # Platform-specific: Python 2
   81:     from socket import _fileobject
   82: except ImportError:  # Platform-specific: Python 3
   83:     _fileobject = None
   84:     from ..packages.backports.makefile import backport_makefile
   85: 
   86: __all__ = ["inject_into_urllib3", "extract_from_urllib3"]
   87: 
   88: # SNI always works
   89: HAS_SNI = True
   90: 
   91: orig_util_HAS_SNI = util.HAS_SNI
   92: orig_util_SSLContext = util.ssl_.SSLContext
   93: 
   94: # This dictionary is used by the read callback to obtain a handle to the
   95: # calling wrapped socket. This is a pretty silly approach, but for now it'll
   96: # do. I feel like I should be able to smuggle a handle to the wrapped socket
   97: # directly in the SSLConnectionRef, but for now this approach will work I
   98: # guess.
   99: #
  100: # We need to lock around this structure for inserts, but we don't do it for
  101: # reads/writes in the callbacks. The reasoning here goes as follows:
  102: #
  103: #    1. It is not possible to call into the callbacks before the dictionary is
  104: #       populated, so once in the callback the id must be in the dictionary.
  105: #    2. The callbacks don't mutate the dictionary, they only read from it, and
  106: #       so cannot conflict with any of the insertions.
  107: #
  108: # This is good: if we had to lock in the callbacks we'd drastically slow down
  109: # the performance of this code.
  110: _connection_refs = weakref.WeakValueDictionary()
  111: _connection_ref_lock = threading.Lock()
  112: 
  113: # Limit writes to 16kB. This is OpenSSL's limit, but we'll cargo-cult it over
  114: # for no better reason than we need *a* limit, and this one is right there.
  115: SSL_WRITE_BLOCKSIZE = 16384
  116: 
  117: # This is our equivalent of util.ssl_.DEFAULT_CIPHERS, but expanded out to
  118: # individual cipher suites. We need to do this because this is how
  119: # SecureTransport wants them.
  120: CIPHER_SUITES = [
  121:     SecurityConst.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
  122:     SecurityConst.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
  123:     SecurityConst.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
  124:     SecurityConst.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
  125:     SecurityConst.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
  126:     SecurityConst.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
  127:     SecurityConst.TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,
  128:     SecurityConst.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
  129:     SecurityConst.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
  130:     SecurityConst.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
  131:     SecurityConst.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
  132:     SecurityConst.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
  133:     SecurityConst.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
  134:     SecurityConst.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
  135:     SecurityConst.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
  136:     SecurityConst.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
  137:     SecurityConst.TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
  138:     SecurityConst.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
  139:     SecurityConst.TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
  140:     SecurityConst.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
  141:     SecurityConst.TLS_AES_256_GCM_SHA384,
  142:     SecurityConst.TLS_AES_128_GCM_SHA256,
  143:     SecurityConst.TLS_RSA_WITH_AES_256_GCM_SHA384,
  144:     SecurityConst.TLS_RSA_WITH_AES_128_GCM_SHA256,
  145:     SecurityConst.TLS_AES_128_CCM_8_SHA256,
  146:     SecurityConst.TLS_AES_128_CCM_SHA256,
  147:     SecurityConst.TLS_RSA_WITH_AES_256_CBC_SHA256,
  148:     SecurityConst.TLS_RSA_WITH_AES_128_CBC_SHA256,
  149:     SecurityConst.TLS_RSA_WITH_AES_256_CBC_SHA,
  150:     SecurityConst.TLS_RSA_WITH_AES_128_CBC_SHA,
  151: ]
  152: 
  153: # Basically this is simple: for PROTOCOL_SSLv23 we turn it into a low of
  154: # TLSv1 and a high of TLSv1.2. For everything else, we pin to that version.
  155: # TLSv1 to 1.2 are supported on macOS 10.8+
  156: _protocol_to_min_max = {
  157:     util.PROTOCOL_TLS: (SecurityConst.kTLSProtocol1, SecurityConst.kTLSProtocol12),
  158:     PROTOCOL_TLS_CLIENT: (SecurityConst.kTLSProtocol1, SecurityConst.kTLSProtocol12),
  159: }
  160: 
  161: if hasattr(ssl, "PROTOCOL_SSLv2"):
  162:     _protocol_to_min_max[ssl.PROTOCOL_SSLv2] = (
  163:         SecurityConst.kSSLProtocol2,
  164:         SecurityConst.kSSLProtocol2,
  165:     )
  166: if hasattr(ssl, "PROTOCOL_SSLv3"):
  167:     _protocol_to_min_max[ssl.PROTOCOL_SSLv3] = (
  168:         SecurityConst.kSSLProtocol3,
  169:         SecurityConst.kSSLProtocol3,
  170:     )
  171: if hasattr(ssl, "PROTOCOL_TLSv1"):
  172:     _protocol_to_min_max[ssl.PROTOCOL_TLSv1] = (
  173:         SecurityConst.kTLSProtocol1,
  174:         SecurityConst.kTLSProtocol1,
  175:     )
  176: if hasattr(ssl, "PROTOCOL_TLSv1_1"):
  177:     _protocol_to_min_max[ssl.PROTOCOL_TLSv1_1] = (
  178:         SecurityConst.kTLSProtocol11,
  179:         SecurityConst.kTLSProtocol11,
  180:     )
  181: if hasattr(ssl, "PROTOCOL_TLSv1_2"):
  182:     _protocol_to_min_max[ssl.PROTOCOL_TLSv1_2] = (
  183:         SecurityConst.kTLSProtocol12,
  184:         SecurityConst.kTLSProtocol12,
  185:     )
  186: 
  187: 
  188: def inject_into_urllib3():
  189:     """
  190:     Monkey-patch urllib3 with SecureTransport-backed SSL-support.
  191:     """
  192:     util.SSLContext = SecureTransportContext
  193:     util.ssl_.SSLContext = SecureTransportContext
  194:     util.HAS_SNI = HAS_SNI
  195:     util.ssl_.HAS_SNI = HAS_SNI
  196:     util.IS_SECURETRANSPORT = True
  197:     util.ssl_.IS_SECURETRANSPORT = True
  198: 
  199: 
  200: def extract_from_urllib3():
  201:     """
  202:     Undo monkey-patching by :func:`inject_into_urllib3`.
  203:     """
  204:     util.SSLContext = orig_util_SSLContext
  205:     util.ssl_.SSLContext = orig_util_SSLContext
  206:     util.HAS_SNI = orig_util_HAS_SNI
  207:     util.ssl_.HAS_SNI = orig_util_HAS_SNI
  208:     util.IS_SECURETRANSPORT = False
  209:     util.ssl_.IS_SECURETRANSPORT = False
  210: 
  211: 
  212: def _read_callback(connection_id, data_buffer, data_length_pointer):
  213:     """
  214:     SecureTransport read callback. This is called by ST to request that data
  215:     be returned from the socket.
  216:     """
  217:     wrapped_socket = None
  218:     try:
  219:         wrapped_socket = _connection_refs.get(connection_id)
  220:         if wrapped_socket is None:
  221:             return SecurityConst.errSSLInternal
  222:         base_socket = wrapped_socket.socket
  223: 
  224:         requested_length = data_length_pointer[0]
  225: 
  226:         timeout = wrapped_socket.gettimeout()
  227:         error = None
  228:         read_count = 0
  229: 
  230:         try:
  231:             while read_count < requested_length:
  232:                 if timeout is None or timeout >= 0:
  233:                     if not util.wait_for_read(base_socket, timeout):
  234:                         raise socket.error(errno.EAGAIN, "timed out")
  235: 
  236:                 remaining = requested_length - read_count
  237:                 buffer = (ctypes.c_char * remaining).from_address(
  238:                     data_buffer + read_count
  239:                 )
  240:                 chunk_size = base_socket.recv_into(buffer, remaining)
  241:                 read_count += chunk_size
  242:                 if not chunk_size:
  243:                     if not read_count:
  244:                         return SecurityConst.errSSLClosedGraceful
  245:                     break
  246:         except (socket.error) as e:
  247:             error = e.errno
  248: 
  249:             if error is not None and error != errno.EAGAIN:
  250:                 data_length_pointer[0] = read_count
  251:                 if error == errno.ECONNRESET or error == errno.EPIPE:
  252:                     return SecurityConst.errSSLClosedAbort
  253:                 raise
  254: 
  255:         data_length_pointer[0] = read_count
  256: 
  257:         if read_count != requested_length:
  258:             return SecurityConst.errSSLWouldBlock
  259: 
  260:         return 0
  261:     except Exception as e:
  262:         if wrapped_socket is not None:
  263:             wrapped_socket._exception = e
  264:         return SecurityConst.errSSLInternal
  265: 
  266: 
  267: def _write_callback(connection_id, data_buffer, data_length_pointer):
  268:     """
  269:     SecureTransport write callback. This is called by ST to request that data
  270:     actually be sent on the network.
  271:     """
  272:     wrapped_socket = None
  273:     try:
  274:         wrapped_socket = _connection_refs.get(connection_id)
  275:         if wrapped_socket is None:
  276:             return SecurityConst.errSSLInternal
  277:         base_socket = wrapped_socket.socket
  278: 
  279:         bytes_to_write = data_length_pointer[0]
  280:         data = ctypes.string_at(data_buffer, bytes_to_write)
  281: 
  282:         timeout = wrapped_socket.gettimeout()
  283:         error = None
  284:         sent = 0
  285: 
  286:         try:
  287:             while sent < bytes_to_write:
  288:                 if timeout is None or timeout >= 0:
  289:                     if not util.wait_for_write(base_socket, timeout):
  290:                         raise socket.error(errno.EAGAIN, "timed out")
  291:                 chunk_sent = base_socket.send(data)
  292:                 sent += chunk_sent
  293: 
  294:                 # This has some needless copying here, but I'm not sure there's
  295:                 # much value in optimising this data path.
  296:                 data = data[chunk_sent:]
  297:         except (socket.error) as e:
  298:             error = e.errno
  299: 
  300:             if error is not None and error != errno.EAGAIN:
  301:                 data_length_pointer[0] = sent
  302:                 if error == errno.ECONNRESET or error == errno.EPIPE:
  303:                     return SecurityConst.errSSLClosedAbort
  304:                 raise
  305: 
  306:         data_length_pointer[0] = sent
  307: 
  308:         if sent != bytes_to_write:
  309:             return SecurityConst.errSSLWouldBlock
  310: 
  311:         return 0
  312:     except Exception as e:
  313:         if wrapped_socket is not None:
  314:             wrapped_socket._exception = e
  315:         return SecurityConst.errSSLInternal
  316: 
  317: 
  318: # We need to keep these two objects references alive: if they get GC'd while
  319: # in use then SecureTransport could attempt to call a function that is in freed
  320: # memory. That would be...uh...bad. Yeah, that's the word. Bad.
  321: _read_callback_pointer = Security.SSLReadFunc(_read_callback)
  322: _write_callback_pointer = Security.SSLWriteFunc(_write_callback)
  323: 
  324: 
  325: class WrappedSocket(object):
  326:     """
  327:     API-compatibility wrapper for Python's OpenSSL wrapped socket object.
  328: 
  329:     Note: _makefile_refs, _drop(), and _reuse() are needed for the garbage
  330:     collector of PyPy.
  331:     """
  332: 
  333:     def __init__(self, socket):
  334:         self.socket = socket
  335:         self.context = None
  336:         self._makefile_refs = 0
  337:         self._closed = False
  338:         self._exception = None
  339:         self._keychain = None
  340:         self._keychain_dir = None
  341:         self._client_cert_chain = None
  342: 
  343:         # We save off the previously-configured timeout and then set it to
  344:         # zero. This is done because we use select and friends to handle the
  345:         # timeouts, but if we leave the timeout set on the lower socket then
  346:         # Python will "kindly" call select on that socket again for us. Avoid
  347:         # that by forcing the timeout to zero.
  348:         self._timeout = self.socket.gettimeout()
  349:         self.socket.settimeout(0)
  350: 
  351:     @contextlib.contextmanager
  352:     def _raise_on_error(self):
  353:         """
  354:         A context manager that can be used to wrap calls that do I/O from
  355:         SecureTransport. If any of the I/O callbacks hit an exception, this
  356:         context manager will correctly propagate the exception after the fact.
  357:         This avoids silently swallowing those exceptions.
  358: 
  359:         It also correctly forces the socket closed.
  360:         """
  361:         self._exception = None
  362: 
  363:         # We explicitly don't catch around this yield because in the unlikely
  364:         # event that an exception was hit in the block we don't want to swallow
  365:         # it.
  366:         yield
  367:         if self._exception is not None:
  368:             exception, self._exception = self._exception, None
  369:             self.close()
  370:             raise exception
  371: 
  372:     def _set_ciphers(self):
  373:         """
  374:         Sets up the allowed ciphers. By default this matches the set in
  375:         util.ssl_.DEFAULT_CIPHERS, at least as supported by macOS. This is done
  376:         custom and doesn't allow changing at this time, mostly because parsing
  377:         OpenSSL cipher strings is going to be a freaking nightmare.
  378:         """
  379:         ciphers = (Security.SSLCipherSuite * len(CIPHER_SUITES))(*CIPHER_SUITES)
  380:         result = Security.SSLSetEnabledCiphers(
  381:             self.context, ciphers, len(CIPHER_SUITES)
  382:         )
  383:         _assert_no_error(result)
  384: 
  385:     def _set_alpn_protocols(self, protocols):
  386:         """
  387:         Sets up the ALPN protocols on the context.
  388:         """
  389:         if not protocols:
  390:             return
  391:         protocols_arr = _create_cfstring_array(protocols)
  392:         try:
  393:             result = Security.SSLSetALPNProtocols(self.context, protocols_arr)
  394:             _assert_no_error(result)
  395:         finally:
  396:             CoreFoundation.CFRelease(protocols_arr)
  397: 
  398:     def _custom_validate(self, verify, trust_bundle):
  399:         """
  400:         Called when we have set custom validation. We do this in two cases:
  401:         first, when cert validation is entirely disabled; and second, when
  402:         using a custom trust DB.
  403:         Raises an SSLError if the connection is not trusted.
  404:         """
  405:         # If we disabled cert validation, just say: cool.
  406:         if not verify:
  407:             return
  408: 
  409:         successes = (
  410:             SecurityConst.kSecTrustResultUnspecified,
  411:             SecurityConst.kSecTrustResultProceed,
  412:         )
  413:         try:
  414:             trust_result = self._evaluate_trust(trust_bundle)
  415:             if trust_result in successes:
  416:                 return
  417:             reason = "error code: %d" % (trust_result,)
  418:         except Exception as e:
  419:             # Do not trust on error
  420:             reason = "exception: %r" % (e,)
  421: 
  422:         # SecureTransport does not send an alert nor shuts down the connection.
  423:         rec = _build_tls_unknown_ca_alert(self.version())
  424:         self.socket.sendall(rec)
  425:         # close the connection immediately
  426:         # l_onoff = 1, activate linger
  427:         # l_linger = 0, linger for 0 seoncds
  428:         opts = struct.pack("ii", 1, 0)
  429:         self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, opts)
  430:         self.close()
  431:         raise ssl.SSLError("certificate verify failed, %s" % reason)
  432: 
  433:     def _evaluate_trust(self, trust_bundle):
  434:         # We want data in memory, so load it up.
  435:         if os.path.isfile(trust_bundle):
  436:             with open(trust_bundle, "rb") as f:
  437:                 trust_bundle = f.read()
  438: 
  439:         cert_array = None
  440:         trust = Security.SecTrustRef()
  441: 
  442:         try:
  443:             # Get a CFArray that contains the certs we want.
  444:             cert_array = _cert_array_from_pem(trust_bundle)
  445: 
  446:             # Ok, now the hard part. We want to get the SecTrustRef that ST has
  447:             # created for this connection, shove our CAs into it, tell ST to
  448:             # ignore everything else it knows, and then ask if it can build a
  449:             # chain. This is a buuuunch of code.
  450:             result = Security.SSLCopyPeerTrust(self.context, ctypes.byref(trust))
  451:             _assert_no_error(result)
  452:             if not trust:
  453:                 raise ssl.SSLError("Failed to copy trust reference")
  454: 
  455:             result = Security.SecTrustSetAnchorCertificates(trust, cert_array)
  456:             _assert_no_error(result)
  457: 
  458:             result = Security.SecTrustSetAnchorCertificatesOnly(trust, True)
  459:             _assert_no_error(result)
  460: 
  461:             trust_result = Security.SecTrustResultType()
  462:             result = Security.SecTrustEvaluate(trust, ctypes.byref(trust_result))
  463:             _assert_no_error(result)
  464:         finally:
  465:             if trust:
  466:                 CoreFoundation.CFRelease(trust)
  467: 
  468:             if cert_array is not None:
  469:                 CoreFoundation.CFRelease(cert_array)
  470: 
  471:         return trust_result.value
  472: 
  473:     def handshake(
  474:         self,
  475:         server_hostname,
  476:         verify,
  477:         trust_bundle,
  478:         min_version,
  479:         max_version,
  480:         client_cert,
  481:         client_key,
  482:         client_key_passphrase,
  483:         alpn_protocols,
  484:     ):
  485:         """
  486:         Actually performs the TLS handshake. This is run automatically by
  487:         wrapped socket, and shouldn't be needed in user code.
  488:         """
  489:         # First, we do the initial bits of connection setup. We need to create
  490:         # a context, set its I/O funcs, and set the connection reference.
  491:         self.context = Security.SSLCreateContext(
  492:             None, SecurityConst.kSSLClientSide, SecurityConst.kSSLStreamType
  493:         )
  494:         result = Security.SSLSetIOFuncs(
  495:             self.context, _read_callback_pointer, _write_callback_pointer
  496:         )
  497:         _assert_no_error(result)
  498: 
  499:         # Here we need to compute the handle to use. We do this by taking the
  500:         # id of self modulo 2**31 - 1. If this is already in the dictionary, we
  501:         # just keep incrementing by one until we find a free space.
  502:         with _connection_ref_lock:
  503:             handle = id(self) % 2147483647
  504:             while handle in _connection_refs:
  505:                 handle = (handle + 1) % 2147483647
  506:             _connection_refs[handle] = self
  507: 
  508:         result = Security.SSLSetConnection(self.context, handle)
  509:         _assert_no_error(result)
  510: 
  511:         # If we have a server hostname, we should set that too.
  512:         if server_hostname:
  513:             if not isinstance(server_hostname, bytes):
  514:                 server_hostname = server_hostname.encode("utf-8")
  515: 
  516:             result = Security.SSLSetPeerDomainName(
  517:                 self.context, server_hostname, len(server_hostname)
  518:             )
  519:             _assert_no_error(result)
  520: 
  521:         # Setup the ciphers.
  522:         self._set_ciphers()
  523: 
  524:         # Setup the ALPN protocols.
  525:         self._set_alpn_protocols(alpn_protocols)
  526: 
  527:         # Set the minimum and maximum TLS versions.
  528:         result = Security.SSLSetProtocolVersionMin(self.context, min_version)
  529:         _assert_no_error(result)
  530: 
  531:         result = Security.SSLSetProtocolVersionMax(self.context, max_version)
  532:         _assert_no_error(result)
  533: 
  534:         # If there's a trust DB, we need to use it. We do that by telling
  535:         # SecureTransport to break on server auth. We also do that if we don't
  536:         # want to validate the certs at all: we just won't actually do any
  537:         # authing in that case.
  538:         if not verify or trust_bundle is not None:
  539:             result = Security.SSLSetSessionOption(
  540:                 self.context, SecurityConst.kSSLSessionOptionBreakOnServerAuth, True
  541:             )
  542:             _assert_no_error(result)
  543: 
  544:         # If there's a client cert, we need to use it.
  545:         if client_cert:
  546:             self._keychain, self._keychain_dir = _temporary_keychain()
  547:             self._client_cert_chain = _load_client_cert_chain(
  548:                 self._keychain, client_cert, client_key
  549:             )
  550:             result = Security.SSLSetCertificate(self.context, self._client_cert_chain)
  551:             _assert_no_error(result)
  552: 
  553:         while True:
  554:             with self._raise_on_error():
  555:                 result = Security.SSLHandshake(self.context)
  556: 
  557:                 if result == SecurityConst.errSSLWouldBlock:
  558:                     raise socket.timeout("handshake timed out")
  559:                 elif result == SecurityConst.errSSLServerAuthCompleted:
  560:                     self._custom_validate(verify, trust_bundle)
  561:                     continue
  562:                 else:
  563:                     _assert_no_error(result)
  564:                     break
  565: 
  566:     def fileno(self):
  567:         return self.socket.fileno()
  568: 
  569:     # Copy-pasted from Python 3.5 source code
  570:     def _decref_socketios(self):
  571:         if self._makefile_refs > 0:
  572:             self._makefile_refs -= 1
  573:         if self._closed:
  574:             self.close()
  575: 
  576:     def recv(self, bufsiz):
  577:         buffer = ctypes.create_string_buffer(bufsiz)
  578:         bytes_read = self.recv_into(buffer, bufsiz)
  579:         data = buffer[:bytes_read]
  580:         return data
  581: 
  582:     def recv_into(self, buffer, nbytes=None):
  583:         # Read short on EOF.
  584:         if self._closed:
  585:             return 0
  586: 
  587:         if nbytes is None:
  588:             nbytes = len(buffer)
  589: 
  590:         buffer = (ctypes.c_char * nbytes).from_buffer(buffer)
  591:         processed_bytes = ctypes.c_size_t(0)
  592: 
  593:         with self._raise_on_error():
  594:             result = Security.SSLRead(
  595:                 self.context, buffer, nbytes, ctypes.byref(processed_bytes)
  596:             )
  597: 
  598:         # There are some result codes that we want to treat as "not always
  599:         # errors". Specifically, those are errSSLWouldBlock,
  600:         # errSSLClosedGraceful, and errSSLClosedNoNotify.
  601:         if result == SecurityConst.errSSLWouldBlock:
  602:             # If we didn't process any bytes, then this was just a time out.
  603:             # However, we can get errSSLWouldBlock in situations when we *did*
  604:             # read some data, and in those cases we should just read "short"
  605:             # and return.
  606:             if processed_bytes.value == 0:
  607:                 # Timed out, no data read.
  608:                 raise socket.timeout("recv timed out")
  609:         elif result in (
  610:             SecurityConst.errSSLClosedGraceful,
  611:             SecurityConst.errSSLClosedNoNotify,
  612:         ):
  613:             # The remote peer has closed this connection. We should do so as
  614:             # well. Note that we don't actually return here because in
  615:             # principle this could actually be fired along with return data.
  616:             # It's unlikely though.
  617:             self.close()
  618:         else:
  619:             _assert_no_error(result)
  620: 
  621:         # Ok, we read and probably succeeded. We should return whatever data
  622:         # was actually read.
  623:         return processed_bytes.value
  624: 
  625:     def settimeout(self, timeout):
  626:         self._timeout = timeout
  627: 
  628:     def gettimeout(self):
  629:         return self._timeout
  630: 
  631:     def send(self, data):
  632:         processed_bytes = ctypes.c_size_t(0)
  633: 
  634:         with self._raise_on_error():
  635:             result = Security.SSLWrite(
  636:                 self.context, data, len(data), ctypes.byref(processed_bytes)
  637:             )
  638: 
  639:         if result == SecurityConst.errSSLWouldBlock and processed_bytes.value == 0:
  640:             # Timed out
  641:             raise socket.timeout("send timed out")
  642:         else:
  643:             _assert_no_error(result)
  644: 
  645:         # We sent, and probably succeeded. Tell them how much we sent.
  646:         return processed_bytes.value
  647: 
  648:     def sendall(self, data):
  649:         total_sent = 0
  650:         while total_sent < len(data):
  651:             sent = self.send(data[total_sent : total_sent + SSL_WRITE_BLOCKSIZE])
  652:             total_sent += sent
  653: 
  654:     def shutdown(self):
  655:         with self._raise_on_error():
  656:             Security.SSLClose(self.context)
  657: 
  658:     def close(self):
  659:         # TODO: should I do clean shutdown here? Do I have to?
  660:         if self._makefile_refs < 1:
  661:             self._closed = True
  662:             if self.context:
  663:                 CoreFoundation.CFRelease(self.context)
  664:                 self.context = None
  665:             if self._client_cert_chain:
  666:                 CoreFoundation.CFRelease(self._client_cert_chain)
  667:                 self._client_cert_chain = None
  668:             if self._keychain:
  669:                 Security.SecKeychainDelete(self._keychain)
  670:                 CoreFoundation.CFRelease(self._keychain)
  671:                 shutil.rmtree(self._keychain_dir)
  672:                 self._keychain = self._keychain_dir = None
  673:             return self.socket.close()
  674:         else:
  675:             self._makefile_refs -= 1
  676: 
  677:     def getpeercert(self, binary_form=False):
  678:         # Urgh, annoying.
  679:         #
  680:         # Here's how we do this:
  681:         #
  682:         # 1. Call SSLCopyPeerTrust to get hold of the trust object for this
  683:         #    connection.
  684:         # 2. Call SecTrustGetCertificateAtIndex for index 0 to get the leaf.
  685:         # 3. To get the CN, call SecCertificateCopyCommonName and process that
  686:         #    string so that it's of the appropriate type.
  687:         # 4. To get the SAN, we need to do something a bit more complex:
  688:         #    a. Call SecCertificateCopyValues to get the data, requesting
  689:         #       kSecOIDSubjectAltName.
  690:         #    b. Mess about with this dictionary to try to get the SANs out.
  691:         #
  692:         # This is gross. Really gross. It's going to be a few hundred LoC extra
  693:         # just to repeat something that SecureTransport can *already do*. So my
  694:         # operating assumption at this time is that what we want to do is
  695:         # instead to just flag to urllib3 that it shouldn't do its own hostname
  696:         # validation when using SecureTransport.
  697:         if not binary_form:
  698:             raise ValueError("SecureTransport only supports dumping binary certs")
  699:         trust = Security.SecTrustRef()
  700:         certdata = None
  701:         der_bytes = None
  702: 
  703:         try:
  704:             # Grab the trust store.
  705:             result = Security.SSLCopyPeerTrust(self.context, ctypes.byref(trust))
  706:             _assert_no_error(result)
  707:             if not trust:
  708:                 # Probably we haven't done the handshake yet. No biggie.
  709:                 return None
  710: 
  711:             cert_count = Security.SecTrustGetCertificateCount(trust)
  712:             if not cert_count:
  713:                 # Also a case that might happen if we haven't handshaked.
  714:                 # Handshook? Handshaken?
  715:                 return None
  716: 
  717:             leaf = Security.SecTrustGetCertificateAtIndex(trust, 0)
  718:             assert leaf
  719: 
  720:             # Ok, now we want the DER bytes.
  721:             certdata = Security.SecCertificateCopyData(leaf)
  722:             assert certdata
  723: 
  724:             data_length = CoreFoundation.CFDataGetLength(certdata)
  725:             data_buffer = CoreFoundation.CFDataGetBytePtr(certdata)
  726:             der_bytes = ctypes.string_at(data_buffer, data_length)
  727:         finally:
  728:             if certdata:
  729:                 CoreFoundation.CFRelease(certdata)
  730:             if trust:
  731:                 CoreFoundation.CFRelease(trust)
  732: 
  733:         return der_bytes
  734: 
  735:     def version(self):
  736:         protocol = Security.SSLProtocol()
  737:         result = Security.SSLGetNegotiatedProtocolVersion(
  738:             self.context, ctypes.byref(protocol)
  739:         )
  740:         _assert_no_error(result)
  741:         if protocol.value == SecurityConst.kTLSProtocol13:
  742:             raise ssl.SSLError("SecureTransport does not support TLS 1.3")
  743:         elif protocol.value == SecurityConst.kTLSProtocol12:
  744:             return "TLSv1.2"
  745:         elif protocol.value == SecurityConst.kTLSProtocol11:
  746:             return "TLSv1.1"
  747:         elif protocol.value == SecurityConst.kTLSProtocol1:
  748:             return "TLSv1"
  749:         elif protocol.value == SecurityConst.kSSLProtocol3:
  750:             return "SSLv3"
  751:         elif protocol.value == SecurityConst.kSSLProtocol2:
  752:             return "SSLv2"
  753:         else:
  754:             raise ssl.SSLError("Unknown TLS version: %r" % protocol)
  755: 
  756:     def _reuse(self):
  757:         self._makefile_refs += 1
  758: 
  759:     def _drop(self):
  760:         if self._makefile_refs < 1:
  761:             self.close()
  762:         else:
  763:             self._makefile_refs -= 1
  764: 
  765: 
  766: if _fileobject:  # Platform-specific: Python 2
  767: 
  768:     def makefile(self, mode, bufsize=-1):
  769:         self._makefile_refs += 1
  770:         return _fileobject(self, mode, bufsize, close=True)
  771: 
  772: else:  # Platform-specific: Python 3
  773: 
  774:     def makefile(self, mode="r", buffering=None, *args, **kwargs):
  775:         # We disable buffering with SecureTransport because it conflicts with
  776:         # the buffering that ST does internally (see issue #1153 for more).
  777:         buffering = 0
  778:         return backport_makefile(self, mode, buffering, *args, **kwargs)
  779: 
  780: 
  781: WrappedSocket.makefile = makefile
  782: 
  783: 
  784: class SecureTransportContext(object):
  785:     """
  786:     I am a wrapper class for the SecureTransport library, to translate the
  787:     interface of the standard library ``SSLContext`` object to calls into
  788:     SecureTransport.
  789:     """
  790: 
  791:     def __init__(self, protocol):
  792:         self._min_version, self._max_version = _protocol_to_min_max[protocol]
  793:         self._options = 0
  794:         self._verify = False
  795:         self._trust_bundle = None
  796:         self._client_cert = None
  797:         self._client_key = None
  798:         self._client_key_passphrase = None
  799:         self._alpn_protocols = None
  800: 
  801:     @property
  802:     def check_hostname(self):
  803:         """
  804:         SecureTransport cannot have its hostname checking disabled. For more,
  805:         see the comment on getpeercert() in this file.
  806:         """
  807:         return True
  808: 
  809:     @check_hostname.setter
  810:     def check_hostname(self, value):
  811:         """
  812:         SecureTransport cannot have its hostname checking disabled. For more,
  813:         see the comment on getpeercert() in this file.
  814:         """
  815:         pass
  816: 
  817:     @property
  818:     def options(self):
  819:         # TODO: Well, crap.
  820:         #
  821:         # So this is the bit of the code that is the most likely to cause us
  822:         # trouble. Essentially we need to enumerate all of the SSL options that
  823:         # users might want to use and try to see if we can sensibly translate
  824:         # them, or whether we should just ignore them.
  825:         return self._options
  826: 
  827:     @options.setter
  828:     def options(self, value):
  829:         # TODO: Update in line with above.
  830:         self._options = value
  831: 
  832:     @property
  833:     def verify_mode(self):
  834:         return ssl.CERT_REQUIRED if self._verify else ssl.CERT_NONE
  835: 
  836:     @verify_mode.setter
  837:     def verify_mode(self, value):
  838:         self._verify = True if value == ssl.CERT_REQUIRED else False
  839: 
  840:     def set_default_verify_paths(self):
  841:         # So, this has to do something a bit weird. Specifically, what it does
  842:         # is nothing.
  843:         #
  844:         # This means that, if we had previously had load_verify_locations
  845:         # called, this does not undo that. We need to do that because it turns
  846:         # out that the rest of the urllib3 code will attempt to load the
  847:         # default verify paths if it hasn't been told about any paths, even if
  848:         # the context itself was sometime earlier. We resolve that by just
  849:         # ignoring it.
  850:         pass
  851: 
  852:     def load_default_certs(self):
  853:         return self.set_default_verify_paths()
  854: 
  855:     def set_ciphers(self, ciphers):
  856:         # For now, we just require the default cipher string.
  857:         if ciphers != util.ssl_.DEFAULT_CIPHERS:
  858:             raise ValueError("SecureTransport doesn't support custom cipher strings")
  859: 
  860:     def load_verify_locations(self, cafile=None, capath=None, cadata=None):
  861:         # OK, we only really support cadata and cafile.
  862:         if capath is not None:
  863:             raise ValueError("SecureTransport does not support cert directories")
  864: 
  865:         # Raise if cafile does not exist.
  866:         if cafile is not None:
  867:             with open(cafile):
  868:                 pass
  869: 
  870:         self._trust_bundle = cafile or cadata
  871: 
  872:     def load_cert_chain(self, certfile, keyfile=None, password=None):
  873:         self._client_cert = certfile
  874:         self._client_key = keyfile
  875:         self._client_cert_passphrase = password
  876: 
  877:     def set_alpn_protocols(self, protocols):
  878:         """
  879:         Sets the ALPN protocols that will later be set on the context.
  880: 
  881:         Raises a NotImplementedError if ALPN is not supported.
  882:         """
  883:         if not hasattr(Security, "SSLSetALPNProtocols"):
  884:             raise NotImplementedError(
  885:                 "SecureTransport supports ALPN only in macOS 10.12+"
  886:             )
  887:         self._alpn_protocols = [six.ensure_binary(p) for p in protocols]
  888: 
  889:     def wrap_socket(
  890:         self,
  891:         sock,
  892:         server_side=False,
  893:         do_handshake_on_connect=True,
  894:         suppress_ragged_eofs=True,
  895:         server_hostname=None,
  896:     ):
  897:         # So, what do we do here? Firstly, we assert some properties. This is a
  898:         # stripped down shim, so there is some functionality we don't support.
  899:         # See PEP 543 for the real deal.
  900:         assert not server_side
  901:         assert do_handshake_on_connect
  902:         assert suppress_ragged_eofs
  903: 
  904:         # Ok, we're good to go. Now we want to create the wrapped socket object
  905:         # and store it in the appropriate place.
  906:         wrapped_socket = WrappedSocket(sock)
  907: 
  908:         # Now we can handshake
  909:         wrapped_socket.handshake(
  910:             server_hostname,
  911:             self._verify,
  912:             self._trust_bundle,
  913:             self._min_version,
  914:             self._max_version,
  915:             self._client_cert,
  916:             self._client_key,
  917:             self._client_key_passphrase,
  918:             self._alpn_protocols,
  919:         )
  920:         return wrapped_socket
