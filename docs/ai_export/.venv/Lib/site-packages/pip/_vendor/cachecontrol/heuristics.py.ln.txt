    1: # SPDX-FileCopyrightText: 2015 Eric Larson
    2: #
    3: # SPDX-License-Identifier: Apache-2.0
    4: from __future__ import annotations
    5: 
    6: import calendar
    7: import time
    8: from datetime import datetime, timedelta, timezone
    9: from email.utils import formatdate, parsedate, parsedate_tz
   10: from typing import TYPE_CHECKING, Any, Mapping
   11: 
   12: if TYPE_CHECKING:
   13:     from pip._vendor.urllib3 import HTTPResponse
   14: 
   15: TIME_FMT = "%a, %d %b %Y %H:%M:%S GMT"
   16: 
   17: 
   18: def expire_after(delta: timedelta, date: datetime | None = None) -> datetime:
   19:     date = date or datetime.now(timezone.utc)
   20:     return date + delta
   21: 
   22: 
   23: def datetime_to_header(dt: datetime) -> str:
   24:     return formatdate(calendar.timegm(dt.timetuple()))
   25: 
   26: 
   27: class BaseHeuristic:
   28:     def warning(self, response: HTTPResponse) -> str | None:
   29:         """
   30:         Return a valid 1xx warning header value describing the cache
   31:         adjustments.
   32: 
   33:         The response is provided too allow warnings like 113
   34:         http://tools.ietf.org/html/rfc7234#section-5.5.4 where we need
   35:         to explicitly say response is over 24 hours old.
   36:         """
   37:         return '110 - "Response is Stale"'
   38: 
   39:     def update_headers(self, response: HTTPResponse) -> dict[str, str]:
   40:         """Update the response headers with any new headers.
   41: 
   42:         NOTE: This SHOULD always include some Warning header to
   43:               signify that the response was cached by the client, not
   44:               by way of the provided headers.
   45:         """
   46:         return {}
   47: 
   48:     def apply(self, response: HTTPResponse) -> HTTPResponse:
   49:         updated_headers = self.update_headers(response)
   50: 
   51:         if updated_headers:
   52:             response.headers.update(updated_headers)
   53:             warning_header_value = self.warning(response)
   54:             if warning_header_value is not None:
   55:                 response.headers.update({"Warning": warning_header_value})
   56: 
   57:         return response
   58: 
   59: 
   60: class OneDayCache(BaseHeuristic):
   61:     """
   62:     Cache the response by providing an expires 1 day in the
   63:     future.
   64:     """
   65: 
   66:     def update_headers(self, response: HTTPResponse) -> dict[str, str]:
   67:         headers = {}
   68: 
   69:         if "expires" not in response.headers:
   70:             date = parsedate(response.headers["date"])
   71:             expires = expire_after(
   72:                 timedelta(days=1),
   73:                 date=datetime(*date[:6], tzinfo=timezone.utc),  # type: ignore[index,misc]
   74:             )
   75:             headers["expires"] = datetime_to_header(expires)
   76:             headers["cache-control"] = "public"
   77:         return headers
   78: 
   79: 
   80: class ExpiresAfter(BaseHeuristic):
   81:     """
   82:     Cache **all** requests for a defined time period.
   83:     """
   84: 
   85:     def __init__(self, **kw: Any) -> None:
   86:         self.delta = timedelta(**kw)
   87: 
   88:     def update_headers(self, response: HTTPResponse) -> dict[str, str]:
   89:         expires = expire_after(self.delta)
   90:         return {"expires": datetime_to_header(expires), "cache-control": "public"}
   91: 
   92:     def warning(self, response: HTTPResponse) -> str | None:
   93:         tmpl = "110 - Automatically cached for %s. Response might be stale"
   94:         return tmpl % self.delta
   95: 
   96: 
   97: class LastModified(BaseHeuristic):
   98:     """
   99:     If there is no Expires header already, fall back on Last-Modified
  100:     using the heuristic from
  101:     http://tools.ietf.org/html/rfc7234#section-4.2.2
  102:     to calculate a reasonable value.
  103: 
  104:     Firefox also does something like this per
  105:     https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching_FAQ
  106:     http://lxr.mozilla.org/mozilla-release/source/netwerk/protocol/http/nsHttpResponseHead.cpp#397
  107:     Unlike mozilla we limit this to 24-hr.
  108:     """
  109: 
  110:     cacheable_by_default_statuses = {
  111:         200,
  112:         203,
  113:         204,
  114:         206,
  115:         300,
  116:         301,
  117:         404,
  118:         405,
  119:         410,
  120:         414,
  121:         501,
  122:     }
  123: 
  124:     def update_headers(self, resp: HTTPResponse) -> dict[str, str]:
  125:         headers: Mapping[str, str] = resp.headers
  126: 
  127:         if "expires" in headers:
  128:             return {}
  129: 
  130:         if "cache-control" in headers and headers["cache-control"] != "public":
  131:             return {}
  132: 
  133:         if resp.status not in self.cacheable_by_default_statuses:
  134:             return {}
  135: 
  136:         if "date" not in headers or "last-modified" not in headers:
  137:             return {}
  138: 
  139:         time_tuple = parsedate_tz(headers["date"])
  140:         assert time_tuple is not None
  141:         date = calendar.timegm(time_tuple[:6])
  142:         last_modified = parsedate(headers["last-modified"])
  143:         if last_modified is None:
  144:             return {}
  145: 
  146:         now = time.time()
  147:         current_age = max(0, now - date)
  148:         delta = date - calendar.timegm(last_modified)
  149:         freshness_lifetime = max(0, min(delta / 10, 24 * 3600))
  150:         if freshness_lifetime <= current_age:
  151:             return {}
  152: 
  153:         expires = date + freshness_lifetime
  154:         return {"expires": time.strftime(TIME_FMT, time.gmtime(expires))}
  155: 
  156:     def warning(self, resp: HTTPResponse) -> str | None:
  157:         return None
