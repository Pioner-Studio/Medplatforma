    1: # SPDX-FileCopyrightText: 2015 Eric Larson
    2: #
    3: # SPDX-License-Identifier: Apache-2.0
    4: from __future__ import annotations
    5: 
    6: import functools
    7: import types
    8: import weakref
    9: import zlib
   10: from typing import TYPE_CHECKING, Any, Collection, Mapping
   11: 
   12: from pip._vendor.requests.adapters import HTTPAdapter
   13: 
   14: from pip._vendor.cachecontrol.cache import DictCache
   15: from pip._vendor.cachecontrol.controller import PERMANENT_REDIRECT_STATUSES, CacheController
   16: from pip._vendor.cachecontrol.filewrapper import CallbackFileWrapper
   17: 
   18: if TYPE_CHECKING:
   19:     from pip._vendor.requests import PreparedRequest, Response
   20:     from pip._vendor.urllib3 import HTTPResponse
   21: 
   22:     from pip._vendor.cachecontrol.cache import BaseCache
   23:     from pip._vendor.cachecontrol.heuristics import BaseHeuristic
   24:     from pip._vendor.cachecontrol.serialize import Serializer
   25: 
   26: 
   27: class CacheControlAdapter(HTTPAdapter):
   28:     invalidating_methods = {"PUT", "PATCH", "DELETE"}
   29: 
   30:     def __init__(
   31:         self,
   32:         cache: BaseCache | None = None,
   33:         cache_etags: bool = True,
   34:         controller_class: type[CacheController] | None = None,
   35:         serializer: Serializer | None = None,
   36:         heuristic: BaseHeuristic | None = None,
   37:         cacheable_methods: Collection[str] | None = None,
   38:         *args: Any,
   39:         **kw: Any,
   40:     ) -> None:
   41:         super().__init__(*args, **kw)
   42:         self.cache = DictCache() if cache is None else cache
   43:         self.heuristic = heuristic
   44:         self.cacheable_methods = cacheable_methods or ("GET",)
   45: 
   46:         controller_factory = controller_class or CacheController
   47:         self.controller = controller_factory(
   48:             self.cache, cache_etags=cache_etags, serializer=serializer
   49:         )
   50: 
   51:     def send(
   52:         self,
   53:         request: PreparedRequest,
   54:         stream: bool = False,
   55:         timeout: None | float | tuple[float, float] | tuple[float, None] = None,
   56:         verify: bool | str = True,
   57:         cert: (None | bytes | str | tuple[bytes | str, bytes | str]) = None,
   58:         proxies: Mapping[str, str] | None = None,
   59:         cacheable_methods: Collection[str] | None = None,
   60:     ) -> Response:
   61:         """
   62:         Send a request. Use the request information to see if it
   63:         exists in the cache and cache the response if we need to and can.
   64:         """
   65:         cacheable = cacheable_methods or self.cacheable_methods
   66:         if request.method in cacheable:
   67:             try:
   68:                 cached_response = self.controller.cached_request(request)
   69:             except zlib.error:
   70:                 cached_response = None
   71:             if cached_response:
   72:                 return self.build_response(request, cached_response, from_cache=True)
   73: 
   74:             # check for etags and add headers if appropriate
   75:             request.headers.update(self.controller.conditional_headers(request))
   76: 
   77:         resp = super().send(request, stream, timeout, verify, cert, proxies)
   78: 
   79:         return resp
   80: 
   81:     def build_response(  # type: ignore[override]
   82:         self,
   83:         request: PreparedRequest,
   84:         response: HTTPResponse,
   85:         from_cache: bool = False,
   86:         cacheable_methods: Collection[str] | None = None,
   87:     ) -> Response:
   88:         """
   89:         Build a response by making a request or using the cache.
   90: 
   91:         This will end up calling send and returning a potentially
   92:         cached response
   93:         """
   94:         cacheable = cacheable_methods or self.cacheable_methods
   95:         if not from_cache and request.method in cacheable:
   96:             # Check for any heuristics that might update headers
   97:             # before trying to cache.
   98:             if self.heuristic:
   99:                 response = self.heuristic.apply(response)
  100: 
  101:             # apply any expiration heuristics
  102:             if response.status == 304:
  103:                 # We must have sent an ETag request. This could mean
  104:                 # that we've been expired already or that we simply
  105:                 # have an etag. In either case, we want to try and
  106:                 # update the cache if that is the case.
  107:                 cached_response = self.controller.update_cached_response(
  108:                     request, response
  109:                 )
  110: 
  111:                 if cached_response is not response:
  112:                     from_cache = True
  113: 
  114:                 # We are done with the server response, read a
  115:                 # possible response body (compliant servers will
  116:                 # not return one, but we cannot be 100% sure) and
  117:                 # release the connection back to the pool.
  118:                 response.read(decode_content=False)
  119:                 response.release_conn()
  120: 
  121:                 response = cached_response
  122: 
  123:             # We always cache the 301 responses
  124:             elif int(response.status) in PERMANENT_REDIRECT_STATUSES:
  125:                 self.controller.cache_response(request, response)
  126:             else:
  127:                 # Wrap the response file with a wrapper that will cache the
  128:                 #   response when the stream has been consumed.
  129:                 response._fp = CallbackFileWrapper(  # type: ignore[assignment]
  130:                     response._fp,  # type: ignore[arg-type]
  131:                     functools.partial(
  132:                         self.controller.cache_response, request, weakref.ref(response)
  133:                     ),
  134:                 )
  135:                 if response.chunked:
  136:                     super_update_chunk_length = response.__class__._update_chunk_length
  137: 
  138:                     def _update_chunk_length(
  139:                         weak_self: weakref.ReferenceType[HTTPResponse],
  140:                     ) -> None:
  141:                         self = weak_self()
  142:                         if self is None:
  143:                             return
  144: 
  145:                         super_update_chunk_length(self)
  146:                         if self.chunk_left == 0:
  147:                             self._fp._close()  # type: ignore[union-attr]
  148: 
  149:                     response._update_chunk_length = functools.partial(  # type: ignore[method-assign]
  150:                         _update_chunk_length, weakref.ref(response)
  151:                     )
  152: 
  153:         resp: Response = super().build_response(request, response)
  154: 
  155:         # See if we should invalidate the cache.
  156:         if request.method in self.invalidating_methods and resp.ok:
  157:             assert request.url is not None
  158:             cache_url = self.controller.cache_url(request.url)
  159:             self.cache.delete(cache_url)
  160: 
  161:         # Give the request a from_cache attr to let people use it
  162:         resp.from_cache = from_cache  # type: ignore[attr-defined]
  163: 
  164:         return resp
  165: 
  166:     def close(self) -> None:
  167:         self.cache.close()
  168:         super().close()  # type: ignore[no-untyped-call]
