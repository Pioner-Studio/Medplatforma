    1: """
    2: requests.models
    3: ~~~~~~~~~~~~~~~
    4: 
    5: This module contains the primary objects that power Requests.
    6: """
    7: 
    8: import datetime
    9: 
   10: # Import encoding now, to avoid implicit import later.
   11: # Implicit import within threads may cause LookupError when standard library is in a ZIP,
   12: # such as in Embedded Python. See https://github.com/psf/requests/issues/3578.
   13: import encodings.idna  # noqa: F401
   14: from io import UnsupportedOperation
   15: 
   16: from pip._vendor.urllib3.exceptions import (
   17:     DecodeError,
   18:     LocationParseError,
   19:     ProtocolError,
   20:     ReadTimeoutError,
   21:     SSLError,
   22: )
   23: from pip._vendor.urllib3.fields import RequestField
   24: from pip._vendor.urllib3.filepost import encode_multipart_formdata
   25: from pip._vendor.urllib3.util import parse_url
   26: 
   27: from ._internal_utils import to_native_string, unicode_is_ascii
   28: from .auth import HTTPBasicAuth
   29: from .compat import (
   30:     Callable,
   31:     JSONDecodeError,
   32:     Mapping,
   33:     basestring,
   34:     builtin_str,
   35:     chardet,
   36:     cookielib,
   37: )
   38: from .compat import json as complexjson
   39: from .compat import urlencode, urlsplit, urlunparse
   40: from .cookies import _copy_cookie_jar, cookiejar_from_dict, get_cookie_header
   41: from .exceptions import (
   42:     ChunkedEncodingError,
   43:     ConnectionError,
   44:     ContentDecodingError,
   45:     HTTPError,
   46:     InvalidJSONError,
   47:     InvalidURL,
   48: )
   49: from .exceptions import JSONDecodeError as RequestsJSONDecodeError
   50: from .exceptions import MissingSchema
   51: from .exceptions import SSLError as RequestsSSLError
   52: from .exceptions import StreamConsumedError
   53: from .hooks import default_hooks
   54: from .status_codes import codes
   55: from .structures import CaseInsensitiveDict
   56: from .utils import (
   57:     check_header_validity,
   58:     get_auth_from_url,
   59:     guess_filename,
   60:     guess_json_utf,
   61:     iter_slices,
   62:     parse_header_links,
   63:     requote_uri,
   64:     stream_decode_response_unicode,
   65:     super_len,
   66:     to_key_val_list,
   67: )
   68: 
   69: #: The set of HTTP status codes that indicate an automatically
   70: #: processable redirect.
   71: REDIRECT_STATI = (
   72:     codes.moved,  # 301
   73:     codes.found,  # 302
   74:     codes.other,  # 303
   75:     codes.temporary_redirect,  # 307
   76:     codes.permanent_redirect,  # 308
   77: )
   78: 
   79: DEFAULT_REDIRECT_LIMIT = 30
   80: CONTENT_CHUNK_SIZE = 10 * 1024
   81: ITER_CHUNK_SIZE = 512
   82: 
   83: 
   84: class RequestEncodingMixin:
   85:     @property
   86:     def path_url(self):
   87:         """Build the path URL to use."""
   88: 
   89:         url = []
   90: 
   91:         p = urlsplit(self.url)
   92: 
   93:         path = p.path
   94:         if not path:
   95:             path = "/"
   96: 
   97:         url.append(path)
   98: 
   99:         query = p.query
  100:         if query:
  101:             url.append("?")
  102:             url.append(query)
  103: 
  104:         return "".join(url)
  105: 
  106:     @staticmethod
  107:     def _encode_params(data):
  108:         """Encode parameters in a piece of data.
  109: 
  110:         Will successfully encode parameters when passed as a dict or a list of
  111:         2-tuples. Order is retained if data is a list of 2-tuples but arbitrary
  112:         if parameters are supplied as a dict.
  113:         """
  114: 
  115:         if isinstance(data, (str, bytes)):
  116:             return data
  117:         elif hasattr(data, "read"):
  118:             return data
  119:         elif hasattr(data, "__iter__"):
  120:             result = []
  121:             for k, vs in to_key_val_list(data):
  122:                 if isinstance(vs, basestring) or not hasattr(vs, "__iter__"):
  123:                     vs = [vs]
  124:                 for v in vs:
  125:                     if v is not None:
  126:                         result.append(
  127:                             (
  128:                                 k.encode("utf-8") if isinstance(k, str) else k,
  129:                                 v.encode("utf-8") if isinstance(v, str) else v,
  130:                             )
  131:                         )
  132:             return urlencode(result, doseq=True)
  133:         else:
  134:             return data
  135: 
  136:     @staticmethod
  137:     def _encode_files(files, data):
  138:         """Build the body for a multipart/form-data request.
  139: 
  140:         Will successfully encode files when passed as a dict or a list of
  141:         tuples. Order is retained if data is a list of tuples but arbitrary
  142:         if parameters are supplied as a dict.
  143:         The tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype)
  144:         or 4-tuples (filename, fileobj, contentype, custom_headers).
  145:         """
  146:         if not files:
  147:             raise ValueError("Files must be provided.")
  148:         elif isinstance(data, basestring):
  149:             raise ValueError("Data must not be a string.")
  150: 
  151:         new_fields = []
  152:         fields = to_key_val_list(data or {})
  153:         files = to_key_val_list(files or {})
  154: 
  155:         for field, val in fields:
  156:             if isinstance(val, basestring) or not hasattr(val, "__iter__"):
  157:                 val = [val]
  158:             for v in val:
  159:                 if v is not None:
  160:                     # Don't call str() on bytestrings: in Py3 it all goes wrong.
  161:                     if not isinstance(v, bytes):
  162:                         v = str(v)
  163: 
  164:                     new_fields.append(
  165:                         (
  166:                             field.decode("utf-8")
  167:                             if isinstance(field, bytes)
  168:                             else field,
  169:                             v.encode("utf-8") if isinstance(v, str) else v,
  170:                         )
  171:                     )
  172: 
  173:         for k, v in files:
  174:             # support for explicit filename
  175:             ft = None
  176:             fh = None
  177:             if isinstance(v, (tuple, list)):
  178:                 if len(v) == 2:
  179:                     fn, fp = v
  180:                 elif len(v) == 3:
  181:                     fn, fp, ft = v
  182:                 else:
  183:                     fn, fp, ft, fh = v
  184:             else:
  185:                 fn = guess_filename(v) or k
  186:                 fp = v
  187: 
  188:             if isinstance(fp, (str, bytes, bytearray)):
  189:                 fdata = fp
  190:             elif hasattr(fp, "read"):
  191:                 fdata = fp.read()
  192:             elif fp is None:
  193:                 continue
  194:             else:
  195:                 fdata = fp
  196: 
  197:             rf = RequestField(name=k, data=fdata, filename=fn, headers=fh)
  198:             rf.make_multipart(content_type=ft)
  199:             new_fields.append(rf)
  200: 
  201:         body, content_type = encode_multipart_formdata(new_fields)
  202: 
  203:         return body, content_type
  204: 
  205: 
  206: class RequestHooksMixin:
  207:     def register_hook(self, event, hook):
  208:         """Properly register a hook."""
  209: 
  210:         if event not in self.hooks:
  211:             raise ValueError(f'Unsupported event specified, with event name "{event}"')
  212: 
  213:         if isinstance(hook, Callable):
  214:             self.hooks[event].append(hook)
  215:         elif hasattr(hook, "__iter__"):
  216:             self.hooks[event].extend(h for h in hook if isinstance(h, Callable))
  217: 
  218:     def deregister_hook(self, event, hook):
  219:         """Deregister a previously registered hook.
  220:         Returns True if the hook existed, False if not.
  221:         """
  222: 
  223:         try:
  224:             self.hooks[event].remove(hook)
  225:             return True
  226:         except ValueError:
  227:             return False
  228: 
  229: 
  230: class Request(RequestHooksMixin):
  231:     """A user-created :class:`Request <Request>` object.
  232: 
  233:     Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.
  234: 
  235:     :param method: HTTP method to use.
  236:     :param url: URL to send.
  237:     :param headers: dictionary of headers to send.
  238:     :param files: dictionary of {filename: fileobject} files to multipart upload.
  239:     :param data: the body to attach to the request. If a dictionary or
  240:         list of tuples ``[(key, value)]`` is provided, form-encoding will
  241:         take place.
  242:     :param json: json for the body to attach to the request (if files or data is not specified).
  243:     :param params: URL parameters to append to the URL. If a dictionary or
  244:         list of tuples ``[(key, value)]`` is provided, form-encoding will
  245:         take place.
  246:     :param auth: Auth handler or (user, pass) tuple.
  247:     :param cookies: dictionary or CookieJar of cookies to attach to this request.
  248:     :param hooks: dictionary of callback hooks, for internal usage.
  249: 
  250:     Usage::
  251: 
  252:       >>> import requests
  253:       >>> req = requests.Request('GET', 'https://httpbin.org/get')
  254:       >>> req.prepare()
  255:       <PreparedRequest [GET]>
  256:     """
  257: 
  258:     def __init__(
  259:         self,
  260:         method=None,
  261:         url=None,
  262:         headers=None,
  263:         files=None,
  264:         data=None,
  265:         params=None,
  266:         auth=None,
  267:         cookies=None,
  268:         hooks=None,
  269:         json=None,
  270:     ):
  271:         # Default empty dicts for dict params.
  272:         data = [] if data is None else data
  273:         files = [] if files is None else files
  274:         headers = {} if headers is None else headers
  275:         params = {} if params is None else params
  276:         hooks = {} if hooks is None else hooks
  277: 
  278:         self.hooks = default_hooks()
  279:         for k, v in list(hooks.items()):
  280:             self.register_hook(event=k, hook=v)
  281: 
  282:         self.method = method
  283:         self.url = url
  284:         self.headers = headers
  285:         self.files = files
  286:         self.data = data
  287:         self.json = json
  288:         self.params = params
  289:         self.auth = auth
  290:         self.cookies = cookies
  291: 
  292:     def __repr__(self):
  293:         return f"<Request [{self.method}]>"
  294: 
  295:     def prepare(self):
  296:         """Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it."""
  297:         p = PreparedRequest()
  298:         p.prepare(
  299:             method=self.method,
  300:             url=self.url,
  301:             headers=self.headers,
  302:             files=self.files,
  303:             data=self.data,
  304:             json=self.json,
  305:             params=self.params,
  306:             auth=self.auth,
  307:             cookies=self.cookies,
  308:             hooks=self.hooks,
  309:         )
  310:         return p
  311: 
  312: 
  313: class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
  314:     """The fully mutable :class:`PreparedRequest <PreparedRequest>` object,
  315:     containing the exact bytes that will be sent to the server.
  316: 
  317:     Instances are generated from a :class:`Request <Request>` object, and
  318:     should not be instantiated manually; doing so may produce undesirable
  319:     effects.
  320: 
  321:     Usage::
  322: 
  323:       >>> import requests
  324:       >>> req = requests.Request('GET', 'https://httpbin.org/get')
  325:       >>> r = req.prepare()
  326:       >>> r
  327:       <PreparedRequest [GET]>
  328: 
  329:       >>> s = requests.Session()
  330:       >>> s.send(r)
  331:       <Response [200]>
  332:     """
  333: 
  334:     def __init__(self):
  335:         #: HTTP verb to send to the server.
  336:         self.method = None
  337:         #: HTTP URL to send the request to.
  338:         self.url = None
  339:         #: dictionary of HTTP headers.
  340:         self.headers = None
  341:         # The `CookieJar` used to create the Cookie header will be stored here
  342:         # after prepare_cookies is called
  343:         self._cookies = None
  344:         #: request body to send to the server.
  345:         self.body = None
  346:         #: dictionary of callback hooks, for internal usage.
  347:         self.hooks = default_hooks()
  348:         #: integer denoting starting position of a readable file-like body.
  349:         self._body_position = None
  350: 
  351:     def prepare(
  352:         self,
  353:         method=None,
  354:         url=None,
  355:         headers=None,
  356:         files=None,
  357:         data=None,
  358:         params=None,
  359:         auth=None,
  360:         cookies=None,
  361:         hooks=None,
  362:         json=None,
  363:     ):
  364:         """Prepares the entire request with the given parameters."""
  365: 
  366:         self.prepare_method(method)
  367:         self.prepare_url(url, params)
  368:         self.prepare_headers(headers)
  369:         self.prepare_cookies(cookies)
  370:         self.prepare_body(data, files, json)
  371:         self.prepare_auth(auth, url)
  372: 
  373:         # Note that prepare_auth must be last to enable authentication schemes
  374:         # such as OAuth to work on a fully prepared request.
  375: 
  376:         # This MUST go after prepare_auth. Authenticators could add a hook
  377:         self.prepare_hooks(hooks)
  378: 
  379:     def __repr__(self):
  380:         return f"<PreparedRequest [{self.method}]>"
  381: 
  382:     def copy(self):
  383:         p = PreparedRequest()
  384:         p.method = self.method
  385:         p.url = self.url
  386:         p.headers = self.headers.copy() if self.headers is not None else None
  387:         p._cookies = _copy_cookie_jar(self._cookies)
  388:         p.body = self.body
  389:         p.hooks = self.hooks
  390:         p._body_position = self._body_position
  391:         return p
  392: 
  393:     def prepare_method(self, method):
  394:         """Prepares the given HTTP method."""
  395:         self.method = method
  396:         if self.method is not None:
  397:             self.method = to_native_string(self.method.upper())
  398: 
  399:     @staticmethod
  400:     def _get_idna_encoded_host(host):
  401:         from pip._vendor import idna
  402: 
  403:         try:
  404:             host = idna.encode(host, uts46=True).decode("utf-8")
  405:         except idna.IDNAError:
  406:             raise UnicodeError
  407:         return host
  408: 
  409:     def prepare_url(self, url, params):
  410:         """Prepares the given HTTP URL."""
  411:         #: Accept objects that have string representations.
  412:         #: We're unable to blindly call unicode/str functions
  413:         #: as this will include the bytestring indicator (b'')
  414:         #: on python 3.x.
  415:         #: https://github.com/psf/requests/pull/2238
  416:         if isinstance(url, bytes):
  417:             url = url.decode("utf8")
  418:         else:
  419:             url = str(url)
  420: 
  421:         # Remove leading whitespaces from url
  422:         url = url.lstrip()
  423: 
  424:         # Don't do any URL preparation for non-HTTP schemes like `mailto`,
  425:         # `data` etc to work around exceptions from `url_parse`, which
  426:         # handles RFC 3986 only.
  427:         if ":" in url and not url.lower().startswith("http"):
  428:             self.url = url
  429:             return
  430: 
  431:         # Support for unicode domain names and paths.
  432:         try:
  433:             scheme, auth, host, port, path, query, fragment = parse_url(url)
  434:         except LocationParseError as e:
  435:             raise InvalidURL(*e.args)
  436: 
  437:         if not scheme:
  438:             raise MissingSchema(
  439:                 f"Invalid URL {url!r}: No scheme supplied. "
  440:                 f"Perhaps you meant https://{url}?"
  441:             )
  442: 
  443:         if not host:
  444:             raise InvalidURL(f"Invalid URL {url!r}: No host supplied")
  445: 
  446:         # In general, we want to try IDNA encoding the hostname if the string contains
  447:         # non-ASCII characters. This allows users to automatically get the correct IDNA
  448:         # behaviour. For strings containing only ASCII characters, we need to also verify
  449:         # it doesn't start with a wildcard (*), before allowing the unencoded hostname.
  450:         if not unicode_is_ascii(host):
  451:             try:
  452:                 host = self._get_idna_encoded_host(host)
  453:             except UnicodeError:
  454:                 raise InvalidURL("URL has an invalid label.")
  455:         elif host.startswith(("*", ".")):
  456:             raise InvalidURL("URL has an invalid label.")
  457: 
  458:         # Carefully reconstruct the network location
  459:         netloc = auth or ""
  460:         if netloc:
  461:             netloc += "@"
  462:         netloc += host
  463:         if port:
  464:             netloc += f":{port}"
  465: 
  466:         # Bare domains aren't valid URLs.
  467:         if not path:
  468:             path = "/"
  469: 
  470:         if isinstance(params, (str, bytes)):
  471:             params = to_native_string(params)
  472: 
  473:         enc_params = self._encode_params(params)
  474:         if enc_params:
  475:             if query:
  476:                 query = f"{query}&{enc_params}"
  477:             else:
  478:                 query = enc_params
  479: 
  480:         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))
  481:         self.url = url
  482: 
  483:     def prepare_headers(self, headers):
  484:         """Prepares the given HTTP headers."""
  485: 
  486:         self.headers = CaseInsensitiveDict()
  487:         if headers:
  488:             for header in headers.items():
  489:                 # Raise exception on invalid header value.
  490:                 check_header_validity(header)
  491:                 name, value = header
  492:                 self.headers[to_native_string(name)] = value
  493: 
  494:     def prepare_body(self, data, files, json=None):
  495:         """Prepares the given HTTP body data."""
  496: 
  497:         # Check if file, fo, generator, iterator.
  498:         # If not, run through normal process.
  499: 
  500:         # Nottin' on you.
  501:         body = None
  502:         content_type = None
  503: 
  504:         if not data and json is not None:
  505:             # urllib3 requires a bytes-like body. Python 2's json.dumps
  506:             # provides this natively, but Python 3 gives a Unicode string.
  507:             content_type = "application/json"
  508: 
  509:             try:
  510:                 body = complexjson.dumps(json, allow_nan=False)
  511:             except ValueError as ve:
  512:                 raise InvalidJSONError(ve, request=self)
  513: 
  514:             if not isinstance(body, bytes):
  515:                 body = body.encode("utf-8")
  516: 
  517:         is_stream = all(
  518:             [
  519:                 hasattr(data, "__iter__"),
  520:                 not isinstance(data, (basestring, list, tuple, Mapping)),
  521:             ]
  522:         )
  523: 
  524:         if is_stream:
  525:             try:
  526:                 length = super_len(data)
  527:             except (TypeError, AttributeError, UnsupportedOperation):
  528:                 length = None
  529: 
  530:             body = data
  531: 
  532:             if getattr(body, "tell", None) is not None:
  533:                 # Record the current file position before reading.
  534:                 # This will allow us to rewind a file in the event
  535:                 # of a redirect.
  536:                 try:
  537:                     self._body_position = body.tell()
  538:                 except OSError:
  539:                     # This differentiates from None, allowing us to catch
  540:                     # a failed `tell()` later when trying to rewind the body
  541:                     self._body_position = object()
  542: 
  543:             if files:
  544:                 raise NotImplementedError(
  545:                     "Streamed bodies and files are mutually exclusive."
  546:                 )
  547: 
  548:             if length:
  549:                 self.headers["Content-Length"] = builtin_str(length)
  550:             else:
  551:                 self.headers["Transfer-Encoding"] = "chunked"
  552:         else:
  553:             # Multi-part file uploads.
  554:             if files:
  555:                 (body, content_type) = self._encode_files(files, data)
  556:             else:
  557:                 if data:
  558:                     body = self._encode_params(data)
  559:                     if isinstance(data, basestring) or hasattr(data, "read"):
  560:                         content_type = None
  561:                     else:
  562:                         content_type = "application/x-www-form-urlencoded"
  563: 
  564:             self.prepare_content_length(body)
  565: 
  566:             # Add content-type if it wasn't explicitly provided.
  567:             if content_type and ("content-type" not in self.headers):
  568:                 self.headers["Content-Type"] = content_type
  569: 
  570:         self.body = body
  571: 
  572:     def prepare_content_length(self, body):
  573:         """Prepare Content-Length header based on request method and body"""
  574:         if body is not None:
  575:             length = super_len(body)
  576:             if length:
  577:                 # If length exists, set it. Otherwise, we fallback
  578:                 # to Transfer-Encoding: chunked.
  579:                 self.headers["Content-Length"] = builtin_str(length)
  580:         elif (
  581:             self.method not in ("GET", "HEAD")
  582:             and self.headers.get("Content-Length") is None
  583:         ):
  584:             # Set Content-Length to 0 for methods that can have a body
  585:             # but don't provide one. (i.e. not GET or HEAD)
  586:             self.headers["Content-Length"] = "0"
  587: 
  588:     def prepare_auth(self, auth, url=""):
  589:         """Prepares the given HTTP auth data."""
  590: 
  591:         # If no Auth is explicitly provided, extract it from the URL first.
  592:         if auth is None:
  593:             url_auth = get_auth_from_url(self.url)
  594:             auth = url_auth if any(url_auth) else None
  595: 
  596:         if auth:
  597:             if isinstance(auth, tuple) and len(auth) == 2:
  598:                 # special-case basic HTTP auth
  599:                 auth = HTTPBasicAuth(*auth)
  600: 
  601:             # Allow auth to make its changes.
  602:             r = auth(self)
  603: 
  604:             # Update self to reflect the auth changes.
  605:             self.__dict__.update(r.__dict__)
  606: 
  607:             # Recompute Content-Length
  608:             self.prepare_content_length(self.body)
  609: 
  610:     def prepare_cookies(self, cookies):
  611:         """Prepares the given HTTP cookie data.
  612: 
  613:         This function eventually generates a ``Cookie`` header from the
  614:         given cookies using cookielib. Due to cookielib's design, the header
  615:         will not be regenerated if it already exists, meaning this function
  616:         can only be called once for the life of the
  617:         :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls
  618:         to ``prepare_cookies`` will have no actual effect, unless the "Cookie"
  619:         header is removed beforehand.
  620:         """
  621:         if isinstance(cookies, cookielib.CookieJar):
  622:             self._cookies = cookies
  623:         else:
  624:             self._cookies = cookiejar_from_dict(cookies)
  625: 
  626:         cookie_header = get_cookie_header(self._cookies, self)
  627:         if cookie_header is not None:
  628:             self.headers["Cookie"] = cookie_header
  629: 
  630:     def prepare_hooks(self, hooks):
  631:         """Prepares the given hooks."""
  632:         # hooks can be passed as None to the prepare method and to this
  633:         # method. To prevent iterating over None, simply use an empty list
  634:         # if hooks is False-y
  635:         hooks = hooks or []
  636:         for event in hooks:
  637:             self.register_hook(event, hooks[event])
  638: 
  639: 
  640: class Response:
  641:     """The :class:`Response <Response>` object, which contains a
  642:     server's response to an HTTP request.
  643:     """
  644: 
  645:     __attrs__ = [
  646:         "_content",
  647:         "status_code",
  648:         "headers",
  649:         "url",
  650:         "history",
  651:         "encoding",
  652:         "reason",
  653:         "cookies",
  654:         "elapsed",
  655:         "request",
  656:     ]
  657: 
  658:     def __init__(self):
  659:         self._content = False
  660:         self._content_consumed = False
  661:         self._next = None
  662: 
  663:         #: Integer Code of responded HTTP Status, e.g. 404 or 200.
  664:         self.status_code = None
  665: 
  666:         #: Case-insensitive Dictionary of Response Headers.
  667:         #: For example, ``headers['content-encoding']`` will return the
  668:         #: value of a ``'Content-Encoding'`` response header.
  669:         self.headers = CaseInsensitiveDict()
  670: 
  671:         #: File-like object representation of response (for advanced usage).
  672:         #: Use of ``raw`` requires that ``stream=True`` be set on the request.
  673:         #: This requirement does not apply for use internally to Requests.
  674:         self.raw = None
  675: 
  676:         #: Final URL location of Response.
  677:         self.url = None
  678: 
  679:         #: Encoding to decode with when accessing r.text.
  680:         self.encoding = None
  681: 
  682:         #: A list of :class:`Response <Response>` objects from
  683:         #: the history of the Request. Any redirect responses will end
  684:         #: up here. The list is sorted from the oldest to the most recent request.
  685:         self.history = []
  686: 
  687:         #: Textual reason of responded HTTP Status, e.g. "Not Found" or "OK".
  688:         self.reason = None
  689: 
  690:         #: A CookieJar of Cookies the server sent back.
  691:         self.cookies = cookiejar_from_dict({})
  692: 
  693:         #: The amount of time elapsed between sending the request
  694:         #: and the arrival of the response (as a timedelta).
  695:         #: This property specifically measures the time taken between sending
  696:         #: the first byte of the request and finishing parsing the headers. It
  697:         #: is therefore unaffected by consuming the response content or the
  698:         #: value of the ``stream`` keyword argument.
  699:         self.elapsed = datetime.timedelta(0)
  700: 
  701:         #: The :class:`PreparedRequest <PreparedRequest>` object to which this
  702:         #: is a response.
  703:         self.request = None
  704: 
  705:     def __enter__(self):
  706:         return self
  707: 
  708:     def __exit__(self, *args):
  709:         self.close()
  710: 
  711:     def __getstate__(self):
  712:         # Consume everything; accessing the content attribute makes
  713:         # sure the content has been fully read.
  714:         if not self._content_consumed:
  715:             self.content
  716: 
  717:         return {attr: getattr(self, attr, None) for attr in self.__attrs__}
  718: 
  719:     def __setstate__(self, state):
  720:         for name, value in state.items():
  721:             setattr(self, name, value)
  722: 
  723:         # pickled objects do not have .raw
  724:         setattr(self, "_content_consumed", True)
  725:         setattr(self, "raw", None)
  726: 
  727:     def __repr__(self):
  728:         return f"<Response [{self.status_code}]>"
  729: 
  730:     def __bool__(self):
  731:         """Returns True if :attr:`status_code` is less than 400.
  732: 
  733:         This attribute checks if the status code of the response is between
  734:         400 and 600 to see if there was a client error or a server error. If
  735:         the status code, is between 200 and 400, this will return True. This
  736:         is **not** a check to see if the response code is ``200 OK``.
  737:         """
  738:         return self.ok
  739: 
  740:     def __nonzero__(self):
  741:         """Returns True if :attr:`status_code` is less than 400.
  742: 
  743:         This attribute checks if the status code of the response is between
  744:         400 and 600 to see if there was a client error or a server error. If
  745:         the status code, is between 200 and 400, this will return True. This
  746:         is **not** a check to see if the response code is ``200 OK``.
  747:         """
  748:         return self.ok
  749: 
  750:     def __iter__(self):
  751:         """Allows you to use a response as an iterator."""
  752:         return self.iter_content(128)
  753: 
  754:     @property
  755:     def ok(self):
  756:         """Returns True if :attr:`status_code` is less than 400, False if not.
  757: 
  758:         This attribute checks if the status code of the response is between
  759:         400 and 600 to see if there was a client error or a server error. If
  760:         the status code is between 200 and 400, this will return True. This
  761:         is **not** a check to see if the response code is ``200 OK``.
  762:         """
  763:         try:
  764:             self.raise_for_status()
  765:         except HTTPError:
  766:             return False
  767:         return True
  768: 
  769:     @property
  770:     def is_redirect(self):
  771:         """True if this Response is a well-formed HTTP redirect that could have
  772:         been processed automatically (by :meth:`Session.resolve_redirects`).
  773:         """
  774:         return "location" in self.headers and self.status_code in REDIRECT_STATI
  775: 
  776:     @property
  777:     def is_permanent_redirect(self):
  778:         """True if this Response one of the permanent versions of redirect."""
  779:         return "location" in self.headers and self.status_code in (
  780:             codes.moved_permanently,
  781:             codes.permanent_redirect,
  782:         )
  783: 
  784:     @property
  785:     def next(self):
  786:         """Returns a PreparedRequest for the next request in a redirect chain, if there is one."""
  787:         return self._next
  788: 
  789:     @property
  790:     def apparent_encoding(self):
  791:         """The apparent encoding, provided by the charset_normalizer or chardet libraries."""
  792:         if chardet is not None:
  793:             return chardet.detect(self.content)["encoding"]
  794:         else:
  795:             # If no character detection library is available, we'll fall back
  796:             # to a standard Python utf-8 str.
  797:             return "utf-8"
  798: 
  799:     def iter_content(self, chunk_size=1, decode_unicode=False):
  800:         """Iterates over the response data.  When stream=True is set on the
  801:         request, this avoids reading the content at once into memory for
  802:         large responses.  The chunk size is the number of bytes it should
  803:         read into memory.  This is not necessarily the length of each item
  804:         returned as decoding can take place.
  805: 
  806:         chunk_size must be of type int or None. A value of None will
  807:         function differently depending on the value of `stream`.
  808:         stream=True will read data as it arrives in whatever size the
  809:         chunks are received. If stream=False, data is returned as
  810:         a single chunk.
  811: 
  812:         If decode_unicode is True, content will be decoded using the best
  813:         available encoding based on the response.
  814:         """
  815: 
  816:         def generate():
  817:             # Special case for urllib3.
  818:             if hasattr(self.raw, "stream"):
  819:                 try:
  820:                     yield from self.raw.stream(chunk_size, decode_content=True)
  821:                 except ProtocolError as e:
  822:                     raise ChunkedEncodingError(e)
  823:                 except DecodeError as e:
  824:                     raise ContentDecodingError(e)
  825:                 except ReadTimeoutError as e:
  826:                     raise ConnectionError(e)
  827:                 except SSLError as e:
  828:                     raise RequestsSSLError(e)
  829:             else:
  830:                 # Standard file-like object.
  831:                 while True:
  832:                     chunk = self.raw.read(chunk_size)
  833:                     if not chunk:
  834:                         break
  835:                     yield chunk
  836: 
  837:             self._content_consumed = True
  838: 
  839:         if self._content_consumed and isinstance(self._content, bool):
  840:             raise StreamConsumedError()
  841:         elif chunk_size is not None and not isinstance(chunk_size, int):
  842:             raise TypeError(
  843:                 f"chunk_size must be an int, it is instead a {type(chunk_size)}."
  844:             )
  845:         # simulate reading small chunks of the content
  846:         reused_chunks = iter_slices(self._content, chunk_size)
  847: 
  848:         stream_chunks = generate()
  849: 
  850:         chunks = reused_chunks if self._content_consumed else stream_chunks
  851: 
  852:         if decode_unicode:
  853:             chunks = stream_decode_response_unicode(chunks, self)
  854: 
  855:         return chunks
  856: 
  857:     def iter_lines(
  858:         self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None
  859:     ):
  860:         """Iterates over the response data, one line at a time.  When
  861:         stream=True is set on the request, this avoids reading the
  862:         content at once into memory for large responses.
  863: 
  864:         .. note:: This method is not reentrant safe.
  865:         """
  866: 
  867:         pending = None
  868: 
  869:         for chunk in self.iter_content(
  870:             chunk_size=chunk_size, decode_unicode=decode_unicode
  871:         ):
  872:             if pending is not None:
  873:                 chunk = pending + chunk
  874: 
  875:             if delimiter:
  876:                 lines = chunk.split(delimiter)
  877:             else:
  878:                 lines = chunk.splitlines()
  879: 
  880:             if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:
  881:                 pending = lines.pop()
  882:             else:
  883:                 pending = None
  884: 
  885:             yield from lines
  886: 
  887:         if pending is not None:
  888:             yield pending
  889: 
  890:     @property
  891:     def content(self):
  892:         """Content of the response, in bytes."""
  893: 
  894:         if self._content is False:
  895:             # Read the contents.
  896:             if self._content_consumed:
  897:                 raise RuntimeError("The content for this response was already consumed")
  898: 
  899:             if self.status_code == 0 or self.raw is None:
  900:                 self._content = None
  901:             else:
  902:                 self._content = b"".join(self.iter_content(CONTENT_CHUNK_SIZE)) or b""
  903: 
  904:         self._content_consumed = True
  905:         # don't need to release the connection; that's been handled by urllib3
  906:         # since we exhausted the data.
  907:         return self._content
  908: 
  909:     @property
  910:     def text(self):
  911:         """Content of the response, in unicode.
  912: 
  913:         If Response.encoding is None, encoding will be guessed using
  914:         ``charset_normalizer`` or ``chardet``.
  915: 
  916:         The encoding of the response content is determined based solely on HTTP
  917:         headers, following RFC 2616 to the letter. If you can take advantage of
  918:         non-HTTP knowledge to make a better guess at the encoding, you should
  919:         set ``r.encoding`` appropriately before accessing this property.
  920:         """
  921: 
  922:         # Try charset from content-type
  923:         content = None
  924:         encoding = self.encoding
  925: 
  926:         if not self.content:
  927:             return ""
  928: 
  929:         # Fallback to auto-detected encoding.
  930:         if self.encoding is None:
  931:             encoding = self.apparent_encoding
  932: 
  933:         # Decode unicode from given encoding.
  934:         try:
  935:             content = str(self.content, encoding, errors="replace")
  936:         except (LookupError, TypeError):
  937:             # A LookupError is raised if the encoding was not found which could
  938:             # indicate a misspelling or similar mistake.
  939:             #
  940:             # A TypeError can be raised if encoding is None
  941:             #
  942:             # So we try blindly encoding.
  943:             content = str(self.content, errors="replace")
  944: 
  945:         return content
  946: 
  947:     def json(self, **kwargs):
  948:         r"""Decodes the JSON response body (if any) as a Python object.
  949: 
  950:         This may return a dictionary, list, etc. depending on what is in the response.
  951: 
  952:         :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
  953:         :raises requests.exceptions.JSONDecodeError: If the response body does not
  954:             contain valid json.
  955:         """
  956: 
  957:         if not self.encoding and self.content and len(self.content) > 3:
  958:             # No encoding set. JSON RFC 4627 section 3 states we should expect
  959:             # UTF-8, -16 or -32. Detect which one to use; If the detection or
  960:             # decoding fails, fall back to `self.text` (using charset_normalizer to make
  961:             # a best guess).
  962:             encoding = guess_json_utf(self.content)
  963:             if encoding is not None:
  964:                 try:
  965:                     return complexjson.loads(self.content.decode(encoding), **kwargs)
  966:                 except UnicodeDecodeError:
  967:                     # Wrong UTF codec detected; usually because it's not UTF-8
  968:                     # but some other 8-bit codec.  This is an RFC violation,
  969:                     # and the server didn't bother to tell us what codec *was*
  970:                     # used.
  971:                     pass
  972:                 except JSONDecodeError as e:
  973:                     raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
  974: 
  975:         try:
  976:             return complexjson.loads(self.text, **kwargs)
  977:         except JSONDecodeError as e:
  978:             # Catch JSON-related errors and raise as requests.JSONDecodeError
  979:             # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
  980:             raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
  981: 
  982:     @property
  983:     def links(self):
  984:         """Returns the parsed header links of the response, if any."""
  985: 
  986:         header = self.headers.get("link")
  987: 
  988:         resolved_links = {}
  989: 
  990:         if header:
  991:             links = parse_header_links(header)
  992: 
  993:             for link in links:
  994:                 key = link.get("rel") or link.get("url")
  995:                 resolved_links[key] = link
  996: 
  997:         return resolved_links
  998: 
  999:     def raise_for_status(self):
 1000:         """Raises :class:`HTTPError`, if one occurred."""
 1001: 
 1002:         http_error_msg = ""
 1003:         if isinstance(self.reason, bytes):
 1004:             # We attempt to decode utf-8 first because some servers
 1005:             # choose to localize their reason strings. If the string
 1006:             # isn't utf-8, we fall back to iso-8859-1 for all other
 1007:             # encodings. (See PR #3538)
 1008:             try:
 1009:                 reason = self.reason.decode("utf-8")
 1010:             except UnicodeDecodeError:
 1011:                 reason = self.reason.decode("iso-8859-1")
 1012:         else:
 1013:             reason = self.reason
 1014: 
 1015:         if 400 <= self.status_code < 500:
 1016:             http_error_msg = (
 1017:                 f"{self.status_code} Client Error: {reason} for url: {self.url}"
 1018:             )
 1019: 
 1020:         elif 500 <= self.status_code < 600:
 1021:             http_error_msg = (
 1022:                 f"{self.status_code} Server Error: {reason} for url: {self.url}"
 1023:             )
 1024: 
 1025:         if http_error_msg:
 1026:             raise HTTPError(http_error_msg, response=self)
 1027: 
 1028:     def close(self):
 1029:         """Releases the connection back to the pool. Once this method has been
 1030:         called the underlying ``raw`` object must not be accessed again.
 1031: 
 1032:         *Note: Should not normally need to be called explicitly.*
 1033:         """
 1034:         if not self._content_consumed:
 1035:             self.raw.close()
 1036: 
 1037:         release_conn = getattr(self.raw, "release_conn", None)
 1038:         if release_conn is not None:
 1039:             release_conn()
