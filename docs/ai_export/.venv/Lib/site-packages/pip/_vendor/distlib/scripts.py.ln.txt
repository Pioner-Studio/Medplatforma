    1: # -*- coding: utf-8 -*-
    2: #
    3: # Copyright (C) 2013-2023 Vinay Sajip.
    4: # Licensed to the Python Software Foundation under a contributor agreement.
    5: # See LICENSE.txt and CONTRIBUTORS.txt.
    6: #
    7: from io import BytesIO
    8: import logging
    9: import os
   10: import re
   11: import struct
   12: import sys
   13: import time
   14: from zipfile import ZipInfo
   15: 
   16: from .compat import sysconfig, detect_encoding, ZipFile
   17: from .resources import finder
   18: from .util import (FileOperator, get_export_entry, convert_path, get_executable, get_platform, in_venv)
   19: 
   20: logger = logging.getLogger(__name__)
   21: 
   22: _DEFAULT_MANIFEST = '''
   23: <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   24: <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
   25:  <assemblyIdentity version="1.0.0.0"
   26:  processorArchitecture="X86"
   27:  name="%s"
   28:  type="win32"/>
   29: 
   30:  <!-- Identify the application security requirements. -->
   31:  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
   32:  <security>
   33:  <requestedPrivileges>
   34:  <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
   35:  </requestedPrivileges>
   36:  </security>
   37:  </trustInfo>
   38: </assembly>'''.strip()
   39: 
   40: # check if Python is called on the first line with this expression
   41: FIRST_LINE_RE = re.compile(b'^#!.*pythonw?[0-9.]*([ \t].*)?$')
   42: SCRIPT_TEMPLATE = r'''# -*- coding: utf-8 -*-
   43: import re
   44: import sys
   45: if __name__ == '__main__':
   46:     from %(module)s import %(import_name)s
   47:     sys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0])
   48:     sys.exit(%(func)s())
   49: '''
   50: 
   51: # Pre-fetch the contents of all executable wrapper stubs.
   52: # This is to address https://github.com/pypa/pip/issues/12666.
   53: # When updating pip, we rename the old pip in place before installing the
   54: # new version. If we try to fetch a wrapper *after* that rename, the finder
   55: # machinery will be confused as the package is no longer available at the
   56: # location where it was imported from. So we load everything into memory in
   57: # advance.
   58: 
   59: if os.name == 'nt' or (os.name == 'java' and os._name == 'nt'):
   60:     # Issue 31: don't hardcode an absolute package name, but
   61:     # determine it relative to the current package
   62:     DISTLIB_PACKAGE = __name__.rsplit('.', 1)[0]
   63: 
   64:     WRAPPERS = {
   65:         r.name: r.bytes
   66:         for r in finder(DISTLIB_PACKAGE).iterator("")
   67:         if r.name.endswith(".exe")
   68:     }
   69: 
   70: 
   71: def enquote_executable(executable):
   72:     if ' ' in executable:
   73:         # make sure we quote only the executable in case of env
   74:         # for example /usr/bin/env "/dir with spaces/bin/jython"
   75:         # instead of "/usr/bin/env /dir with spaces/bin/jython"
   76:         # otherwise whole
   77:         if executable.startswith('/usr/bin/env '):
   78:             env, _executable = executable.split(' ', 1)
   79:             if ' ' in _executable and not _executable.startswith('"'):
   80:                 executable = '%s "%s"' % (env, _executable)
   81:         else:
   82:             if not executable.startswith('"'):
   83:                 executable = '"%s"' % executable
   84:     return executable
   85: 
   86: 
   87: # Keep the old name around (for now), as there is at least one project using it!
   88: _enquote_executable = enquote_executable
   89: 
   90: 
   91: class ScriptMaker(object):
   92:     """
   93:     A class to copy or create scripts from source scripts or callable
   94:     specifications.
   95:     """
   96:     script_template = SCRIPT_TEMPLATE
   97: 
   98:     executable = None  # for shebangs
   99: 
  100:     def __init__(self, source_dir, target_dir, add_launchers=True, dry_run=False, fileop=None):
  101:         self.source_dir = source_dir
  102:         self.target_dir = target_dir
  103:         self.add_launchers = add_launchers
  104:         self.force = False
  105:         self.clobber = False
  106:         # It only makes sense to set mode bits on POSIX.
  107:         self.set_mode = (os.name == 'posix') or (os.name == 'java' and os._name == 'posix')
  108:         self.variants = set(('', 'X.Y'))
  109:         self._fileop = fileop or FileOperator(dry_run)
  110: 
  111:         self._is_nt = os.name == 'nt' or (os.name == 'java' and os._name == 'nt')
  112:         self.version_info = sys.version_info
  113: 
  114:     def _get_alternate_executable(self, executable, options):
  115:         if options.get('gui', False) and self._is_nt:  # pragma: no cover
  116:             dn, fn = os.path.split(executable)
  117:             fn = fn.replace('python', 'pythonw')
  118:             executable = os.path.join(dn, fn)
  119:         return executable
  120: 
  121:     if sys.platform.startswith('java'):  # pragma: no cover
  122: 
  123:         def _is_shell(self, executable):
  124:             """
  125:             Determine if the specified executable is a script
  126:             (contains a #! line)
  127:             """
  128:             try:
  129:                 with open(executable) as fp:
  130:                     return fp.read(2) == '#!'
  131:             except (OSError, IOError):
  132:                 logger.warning('Failed to open %s', executable)
  133:                 return False
  134: 
  135:         def _fix_jython_executable(self, executable):
  136:             if self._is_shell(executable):
  137:                 # Workaround for Jython is not needed on Linux systems.
  138:                 import java
  139: 
  140:                 if java.lang.System.getProperty('os.name') == 'Linux':
  141:                     return executable
  142:             elif executable.lower().endswith('jython.exe'):
  143:                 # Use wrapper exe for Jython on Windows
  144:                 return executable
  145:             return '/usr/bin/env %s' % executable
  146: 
  147:     def _build_shebang(self, executable, post_interp):
  148:         """
  149:         Build a shebang line. In the simple case (on Windows, or a shebang line
  150:         which is not too long or contains spaces) use a simple formulation for
  151:         the shebang. Otherwise, use /bin/sh as the executable, with a contrived
  152:         shebang which allows the script to run either under Python or sh, using
  153:         suitable quoting. Thanks to Harald Nordgren for his input.
  154: 
  155:         See also: http://www.in-ulm.de/~mascheck/various/shebang/#length
  156:                   https://hg.mozilla.org/mozilla-central/file/tip/mach
  157:         """
  158:         if os.name != 'posix':
  159:             simple_shebang = True
  160:         elif getattr(sys, "cross_compiling", False):
  161:             # In a cross-compiling environment, the shebang will likely be a
  162:             # script; this *must* be invoked with the "safe" version of the
  163:             # shebang, or else using os.exec() to run the entry script will
  164:             # fail, raising "OSError 8 [Errno 8] Exec format error".
  165:             simple_shebang = False
  166:         else:
  167:             # Add 3 for '#!' prefix and newline suffix.
  168:             shebang_length = len(executable) + len(post_interp) + 3
  169:             if sys.platform == 'darwin':
  170:                 max_shebang_length = 512
  171:             else:
  172:                 max_shebang_length = 127
  173:             simple_shebang = ((b' ' not in executable) and (shebang_length <= max_shebang_length))
  174: 
  175:         if simple_shebang:
  176:             result = b'#!' + executable + post_interp + b'\n'
  177:         else:
  178:             result = b'#!/bin/sh\n'
  179:             result += b"'''exec' " + executable + post_interp + b' "$0" "$@"\n'
  180:             result += b"' '''\n"
  181:         return result
  182: 
  183:     def _get_shebang(self, encoding, post_interp=b'', options=None):
  184:         enquote = True
  185:         if self.executable:
  186:             executable = self.executable
  187:             enquote = False  # assume this will be taken care of
  188:         elif not sysconfig.is_python_build():
  189:             executable = get_executable()
  190:         elif in_venv():  # pragma: no cover
  191:             executable = os.path.join(sysconfig.get_path('scripts'), 'python%s' % sysconfig.get_config_var('EXE'))
  192:         else:  # pragma: no cover
  193:             if os.name == 'nt':
  194:                 # for Python builds from source on Windows, no Python executables with
  195:                 # a version suffix are created, so we use python.exe
  196:                 executable = os.path.join(sysconfig.get_config_var('BINDIR'),
  197:                                           'python%s' % (sysconfig.get_config_var('EXE')))
  198:             else:
  199:                 executable = os.path.join(
  200:                     sysconfig.get_config_var('BINDIR'),
  201:                     'python%s%s' % (sysconfig.get_config_var('VERSION'), sysconfig.get_config_var('EXE')))
  202:         if options:
  203:             executable = self._get_alternate_executable(executable, options)
  204: 
  205:         if sys.platform.startswith('java'):  # pragma: no cover
  206:             executable = self._fix_jython_executable(executable)
  207: 
  208:         # Normalise case for Windows - COMMENTED OUT
  209:         # executable = os.path.normcase(executable)
  210:         # N.B. The normalising operation above has been commented out: See
  211:         # issue #124. Although paths in Windows are generally case-insensitive,
  212:         # they aren't always. For example, a path containing a бєћ (which is a
  213:         # LATIN CAPITAL LETTER SHARP S - U+1E9E) is normcased to Гџ (which is a
  214:         # LATIN SMALL LETTER SHARP S' - U+00DF). The two are not considered by
  215:         # Windows as equivalent in path names.
  216: 
  217:         # If the user didn't specify an executable, it may be necessary to
  218:         # cater for executable paths with spaces (not uncommon on Windows)
  219:         if enquote:
  220:             executable = enquote_executable(executable)
  221:         # Issue #51: don't use fsencode, since we later try to
  222:         # check that the shebang is decodable using utf-8.
  223:         executable = executable.encode('utf-8')
  224:         # in case of IronPython, play safe and enable frames support
  225:         if (sys.platform == 'cli' and '-X:Frames' not in post_interp and
  226:                 '-X:FullFrames' not in post_interp):  # pragma: no cover
  227:             post_interp += b' -X:Frames'
  228:         shebang = self._build_shebang(executable, post_interp)
  229:         # Python parser starts to read a script using UTF-8 until
  230:         # it gets a #coding:xxx cookie. The shebang has to be the
  231:         # first line of a file, the #coding:xxx cookie cannot be
  232:         # written before. So the shebang has to be decodable from
  233:         # UTF-8.
  234:         try:
  235:             shebang.decode('utf-8')
  236:         except UnicodeDecodeError:  # pragma: no cover
  237:             raise ValueError('The shebang (%r) is not decodable from utf-8' % shebang)
  238:         # If the script is encoded to a custom encoding (use a
  239:         # #coding:xxx cookie), the shebang has to be decodable from
  240:         # the script encoding too.
  241:         if encoding != 'utf-8':
  242:             try:
  243:                 shebang.decode(encoding)
  244:             except UnicodeDecodeError:  # pragma: no cover
  245:                 raise ValueError('The shebang (%r) is not decodable '
  246:                                  'from the script encoding (%r)' % (shebang, encoding))
  247:         return shebang
  248: 
  249:     def _get_script_text(self, entry):
  250:         return self.script_template % dict(
  251:             module=entry.prefix, import_name=entry.suffix.split('.')[0], func=entry.suffix)
  252: 
  253:     manifest = _DEFAULT_MANIFEST
  254: 
  255:     def get_manifest(self, exename):
  256:         base = os.path.basename(exename)
  257:         return self.manifest % base
  258: 
  259:     def _write_script(self, names, shebang, script_bytes, filenames, ext):
  260:         use_launcher = self.add_launchers and self._is_nt
  261:         if not use_launcher:
  262:             script_bytes = shebang + script_bytes
  263:         else:  # pragma: no cover
  264:             if ext == 'py':
  265:                 launcher = self._get_launcher('t')
  266:             else:
  267:                 launcher = self._get_launcher('w')
  268:             stream = BytesIO()
  269:             with ZipFile(stream, 'w') as zf:
  270:                 source_date_epoch = os.environ.get('SOURCE_DATE_EPOCH')
  271:                 if source_date_epoch:
  272:                     date_time = time.gmtime(int(source_date_epoch))[:6]
  273:                     zinfo = ZipInfo(filename='__main__.py', date_time=date_time)
  274:                     zf.writestr(zinfo, script_bytes)
  275:                 else:
  276:                     zf.writestr('__main__.py', script_bytes)
  277:             zip_data = stream.getvalue()
  278:             script_bytes = launcher + shebang + zip_data
  279:         for name in names:
  280:             outname = os.path.join(self.target_dir, name)
  281:             if use_launcher:  # pragma: no cover
  282:                 n, e = os.path.splitext(outname)
  283:                 if e.startswith('.py'):
  284:                     outname = n
  285:                 outname = '%s.exe' % outname
  286:                 try:
  287:                     self._fileop.write_binary_file(outname, script_bytes)
  288:                 except Exception:
  289:                     # Failed writing an executable - it might be in use.
  290:                     logger.warning('Failed to write executable - trying to '
  291:                                    'use .deleteme logic')
  292:                     dfname = '%s.deleteme' % outname
  293:                     if os.path.exists(dfname):
  294:                         os.remove(dfname)  # Not allowed to fail here
  295:                     os.rename(outname, dfname)  # nor here
  296:                     self._fileop.write_binary_file(outname, script_bytes)
  297:                     logger.debug('Able to replace executable using '
  298:                                  '.deleteme logic')
  299:                     try:
  300:                         os.remove(dfname)
  301:                     except Exception:
  302:                         pass  # still in use - ignore error
  303:             else:
  304:                 if self._is_nt and not outname.endswith('.' + ext):  # pragma: no cover
  305:                     outname = '%s.%s' % (outname, ext)
  306:                 if os.path.exists(outname) and not self.clobber:
  307:                     logger.warning('Skipping existing file %s', outname)
  308:                     continue
  309:                 self._fileop.write_binary_file(outname, script_bytes)
  310:                 if self.set_mode:
  311:                     self._fileop.set_executable_mode([outname])
  312:             filenames.append(outname)
  313: 
  314:     variant_separator = '-'
  315: 
  316:     def get_script_filenames(self, name):
  317:         result = set()
  318:         if '' in self.variants:
  319:             result.add(name)
  320:         if 'X' in self.variants:
  321:             result.add('%s%s' % (name, self.version_info[0]))
  322:         if 'X.Y' in self.variants:
  323:             result.add('%s%s%s.%s' % (name, self.variant_separator, self.version_info[0], self.version_info[1]))
  324:         return result
  325: 
  326:     def _make_script(self, entry, filenames, options=None):
  327:         post_interp = b''
  328:         if options:
  329:             args = options.get('interpreter_args', [])
  330:             if args:
  331:                 args = ' %s' % ' '.join(args)
  332:                 post_interp = args.encode('utf-8')
  333:         shebang = self._get_shebang('utf-8', post_interp, options=options)
  334:         script = self._get_script_text(entry).encode('utf-8')
  335:         scriptnames = self.get_script_filenames(entry.name)
  336:         if options and options.get('gui', False):
  337:             ext = 'pyw'
  338:         else:
  339:             ext = 'py'
  340:         self._write_script(scriptnames, shebang, script, filenames, ext)
  341: 
  342:     def _copy_script(self, script, filenames):
  343:         adjust = False
  344:         script = os.path.join(self.source_dir, convert_path(script))
  345:         outname = os.path.join(self.target_dir, os.path.basename(script))
  346:         if not self.force and not self._fileop.newer(script, outname):
  347:             logger.debug('not copying %s (up-to-date)', script)
  348:             return
  349: 
  350:         # Always open the file, but ignore failures in dry-run mode --
  351:         # that way, we'll get accurate feedback if we can read the
  352:         # script.
  353:         try:
  354:             f = open(script, 'rb')
  355:         except IOError:  # pragma: no cover
  356:             if not self.dry_run:
  357:                 raise
  358:             f = None
  359:         else:
  360:             first_line = f.readline()
  361:             if not first_line:  # pragma: no cover
  362:                 logger.warning('%s is an empty file (skipping)', script)
  363:                 return
  364: 
  365:             match = FIRST_LINE_RE.match(first_line.replace(b'\r\n', b'\n'))
  366:             if match:
  367:                 adjust = True
  368:                 post_interp = match.group(1) or b''
  369: 
  370:         if not adjust:
  371:             if f:
  372:                 f.close()
  373:             self._fileop.copy_file(script, outname)
  374:             if self.set_mode:
  375:                 self._fileop.set_executable_mode([outname])
  376:             filenames.append(outname)
  377:         else:
  378:             logger.info('copying and adjusting %s -> %s', script, self.target_dir)
  379:             if not self._fileop.dry_run:
  380:                 encoding, lines = detect_encoding(f.readline)
  381:                 f.seek(0)
  382:                 shebang = self._get_shebang(encoding, post_interp)
  383:                 if b'pythonw' in first_line:  # pragma: no cover
  384:                     ext = 'pyw'
  385:                 else:
  386:                     ext = 'py'
  387:                 n = os.path.basename(outname)
  388:                 self._write_script([n], shebang, f.read(), filenames, ext)
  389:             if f:
  390:                 f.close()
  391: 
  392:     @property
  393:     def dry_run(self):
  394:         return self._fileop.dry_run
  395: 
  396:     @dry_run.setter
  397:     def dry_run(self, value):
  398:         self._fileop.dry_run = value
  399: 
  400:     if os.name == 'nt' or (os.name == 'java' and os._name == 'nt'):  # pragma: no cover
  401:         # Executable launcher support.
  402:         # Launchers are from https://bitbucket.org/vinay.sajip/simple_launcher/
  403: 
  404:         def _get_launcher(self, kind):
  405:             if struct.calcsize('P') == 8:  # 64-bit
  406:                 bits = '64'
  407:             else:
  408:                 bits = '32'
  409:             platform_suffix = '-arm' if get_platform() == 'win-arm64' else ''
  410:             name = '%s%s%s.exe' % (kind, bits, platform_suffix)
  411:             if name not in WRAPPERS:
  412:                 msg = ('Unable to find resource %s in package %s' %
  413:                        (name, DISTLIB_PACKAGE))
  414:                 raise ValueError(msg)
  415:             return WRAPPERS[name]
  416: 
  417:     # Public API follows
  418: 
  419:     def make(self, specification, options=None):
  420:         """
  421:         Make a script.
  422: 
  423:         :param specification: The specification, which is either a valid export
  424:                               entry specification (to make a script from a
  425:                               callable) or a filename (to make a script by
  426:                               copying from a source location).
  427:         :param options: A dictionary of options controlling script generation.
  428:         :return: A list of all absolute pathnames written to.
  429:         """
  430:         filenames = []
  431:         entry = get_export_entry(specification)
  432:         if entry is None:
  433:             self._copy_script(specification, filenames)
  434:         else:
  435:             self._make_script(entry, filenames, options=options)
  436:         return filenames
  437: 
  438:     def make_multiple(self, specifications, options=None):
  439:         """
  440:         Take a list of specifications and make scripts from them,
  441:         :param specifications: A list of specifications.
  442:         :return: A list of all absolute pathnames written to,
  443:         """
  444:         filenames = []
  445:         for specification in specifications:
  446:             filenames.extend(self.make(specification, options))
  447:         return filenames
