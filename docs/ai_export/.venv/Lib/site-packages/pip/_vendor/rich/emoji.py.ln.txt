    1: import sys
    2: from typing import TYPE_CHECKING, Optional, Union, Literal
    3: 
    4: from .jupyter import JupyterMixin
    5: from .segment import Segment
    6: from .style import Style
    7: from ._emoji_codes import EMOJI
    8: from ._emoji_replace import _emoji_replace
    9: 
   10: 
   11: if TYPE_CHECKING:
   12:     from .console import Console, ConsoleOptions, RenderResult
   13: 
   14: 
   15: EmojiVariant = Literal["emoji", "text"]
   16: 
   17: 
   18: class NoEmoji(Exception):
   19:     """No emoji by that name."""
   20: 
   21: 
   22: class Emoji(JupyterMixin):
   23:     __slots__ = ["name", "style", "_char", "variant"]
   24: 
   25:     VARIANTS = {"text": "\uFE0E", "emoji": "\uFE0F"}
   26: 
   27:     def __init__(
   28:         self,
   29:         name: str,
   30:         style: Union[str, Style] = "none",
   31:         variant: Optional[EmojiVariant] = None,
   32:     ) -> None:
   33:         """A single emoji character.
   34: 
   35:         Args:
   36:             name (str): Name of emoji.
   37:             style (Union[str, Style], optional): Optional style. Defaults to None.
   38: 
   39:         Raises:
   40:             NoEmoji: If the emoji doesn't exist.
   41:         """
   42:         self.name = name
   43:         self.style = style
   44:         self.variant = variant
   45:         try:
   46:             self._char = EMOJI[name]
   47:         except KeyError:
   48:             raise NoEmoji(f"No emoji called {name!r}")
   49:         if variant is not None:
   50:             self._char += self.VARIANTS.get(variant, "")
   51: 
   52:     @classmethod
   53:     def replace(cls, text: str) -> str:
   54:         """Replace emoji markup with corresponding unicode characters.
   55: 
   56:         Args:
   57:             text (str): A string with emojis codes, e.g. "Hello :smiley:!"
   58: 
   59:         Returns:
   60:             str: A string with emoji codes replaces with actual emoji.
   61:         """
   62:         return _emoji_replace(text)
   63: 
   64:     def __repr__(self) -> str:
   65:         return f"<emoji {self.name!r}>"
   66: 
   67:     def __str__(self) -> str:
   68:         return self._char
   69: 
   70:     def __rich_console__(
   71:         self, console: "Console", options: "ConsoleOptions"
   72:     ) -> "RenderResult":
   73:         yield Segment(self._char, console.get_style(self.style))
   74: 
   75: 
   76: if __name__ == "__main__":  # pragma: no cover
   77:     import sys
   78: 
   79:     from pip._vendor.rich.columns import Columns
   80:     from pip._vendor.rich.console import Console
   81: 
   82:     console = Console(record=True)
   83: 
   84:     columns = Columns(
   85:         (f":{name}: {name}" for name in sorted(EMOJI.keys()) if "\u200D" not in name),
   86:         column_first=True,
   87:     )
   88: 
   89:     console.print(columns)
   90:     if len(sys.argv) > 1:
   91:         console.save_html(sys.argv[1])
