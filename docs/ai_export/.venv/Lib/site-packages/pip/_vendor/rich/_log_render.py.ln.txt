    1: from datetime import datetime
    2: from typing import Iterable, List, Optional, TYPE_CHECKING, Union, Callable
    3: 
    4: 
    5: from .text import Text, TextType
    6: 
    7: if TYPE_CHECKING:
    8:     from .console import Console, ConsoleRenderable, RenderableType
    9:     from .table import Table
   10: 
   11: FormatTimeCallable = Callable[[datetime], Text]
   12: 
   13: 
   14: class LogRender:
   15:     def __init__(
   16:         self,
   17:         show_time: bool = True,
   18:         show_level: bool = False,
   19:         show_path: bool = True,
   20:         time_format: Union[str, FormatTimeCallable] = "[%x %X]",
   21:         omit_repeated_times: bool = True,
   22:         level_width: Optional[int] = 8,
   23:     ) -> None:
   24:         self.show_time = show_time
   25:         self.show_level = show_level
   26:         self.show_path = show_path
   27:         self.time_format = time_format
   28:         self.omit_repeated_times = omit_repeated_times
   29:         self.level_width = level_width
   30:         self._last_time: Optional[Text] = None
   31: 
   32:     def __call__(
   33:         self,
   34:         console: "Console",
   35:         renderables: Iterable["ConsoleRenderable"],
   36:         log_time: Optional[datetime] = None,
   37:         time_format: Optional[Union[str, FormatTimeCallable]] = None,
   38:         level: TextType = "",
   39:         path: Optional[str] = None,
   40:         line_no: Optional[int] = None,
   41:         link_path: Optional[str] = None,
   42:     ) -> "Table":
   43:         from .containers import Renderables
   44:         from .table import Table
   45: 
   46:         output = Table.grid(padding=(0, 1))
   47:         output.expand = True
   48:         if self.show_time:
   49:             output.add_column(style="log.time")
   50:         if self.show_level:
   51:             output.add_column(style="log.level", width=self.level_width)
   52:         output.add_column(ratio=1, style="log.message", overflow="fold")
   53:         if self.show_path and path:
   54:             output.add_column(style="log.path")
   55:         row: List["RenderableType"] = []
   56:         if self.show_time:
   57:             log_time = log_time or console.get_datetime()
   58:             time_format = time_format or self.time_format
   59:             if callable(time_format):
   60:                 log_time_display = time_format(log_time)
   61:             else:
   62:                 log_time_display = Text(log_time.strftime(time_format))
   63:             if log_time_display == self._last_time and self.omit_repeated_times:
   64:                 row.append(Text(" " * len(log_time_display)))
   65:             else:
   66:                 row.append(log_time_display)
   67:                 self._last_time = log_time_display
   68:         if self.show_level:
   69:             row.append(level)
   70: 
   71:         row.append(Renderables(renderables))
   72:         if self.show_path and path:
   73:             path_text = Text()
   74:             path_text.append(
   75:                 path, style=f"link file://{link_path}" if link_path else ""
   76:             )
   77:             if line_no:
   78:                 path_text.append(":")
   79:                 path_text.append(
   80:                     f"{line_no}",
   81:                     style=f"link file://{link_path}#{line_no}" if link_path else "",
   82:                 )
   83:             row.append(path_text)
   84: 
   85:         output.add_row(*row)
   86:         return output
   87: 
   88: 
   89: if __name__ == "__main__":  # pragma: no cover
   90:     from pip._vendor.rich.console import Console
   91: 
   92:     c = Console()
   93:     c.print("[on blue]Hello", justify="right")
   94:     c.log("[on blue]hello", justify="right")
