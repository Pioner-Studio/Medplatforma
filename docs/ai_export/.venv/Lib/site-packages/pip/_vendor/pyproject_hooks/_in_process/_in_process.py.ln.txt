    1: """This is invoked in a subprocess to call the build backend hooks.
    2: 
    3: It expects:
    4: - Command line args: hook_name, control_dir
    5: - Environment variables:
    6:       _PYPROJECT_HOOKS_BUILD_BACKEND=entry.point:spec
    7:       _PYPROJECT_HOOKS_BACKEND_PATH=paths (separated with os.pathsep)
    8: - control_dir/input.json:
    9:   - {"kwargs": {...}}
   10: 
   11: Results:
   12: - control_dir/output.json
   13:   - {"return_val": ...}
   14: """
   15: import json
   16: import os
   17: import os.path
   18: import re
   19: import shutil
   20: import sys
   21: import traceback
   22: from glob import glob
   23: from importlib import import_module
   24: from importlib.machinery import PathFinder
   25: from os.path import join as pjoin
   26: 
   27: # This file is run as a script, and `import wrappers` is not zip-safe, so we
   28: # include write_json() and read_json() from wrappers.py.
   29: 
   30: 
   31: def write_json(obj, path, **kwargs):
   32:     with open(path, "w", encoding="utf-8") as f:
   33:         json.dump(obj, f, **kwargs)
   34: 
   35: 
   36: def read_json(path):
   37:     with open(path, encoding="utf-8") as f:
   38:         return json.load(f)
   39: 
   40: 
   41: class BackendUnavailable(Exception):
   42:     """Raised if we cannot import the backend"""
   43: 
   44:     def __init__(self, message, traceback=None):
   45:         super().__init__(message)
   46:         self.message = message
   47:         self.traceback = traceback
   48: 
   49: 
   50: class HookMissing(Exception):
   51:     """Raised if a hook is missing and we are not executing the fallback"""
   52: 
   53:     def __init__(self, hook_name=None):
   54:         super().__init__(hook_name)
   55:         self.hook_name = hook_name
   56: 
   57: 
   58: def _build_backend():
   59:     """Find and load the build backend"""
   60:     backend_path = os.environ.get("_PYPROJECT_HOOKS_BACKEND_PATH")
   61:     ep = os.environ["_PYPROJECT_HOOKS_BUILD_BACKEND"]
   62:     mod_path, _, obj_path = ep.partition(":")
   63: 
   64:     if backend_path:
   65:         # Ensure in-tree backend directories have the highest priority when importing.
   66:         extra_pathitems = backend_path.split(os.pathsep)
   67:         sys.meta_path.insert(0, _BackendPathFinder(extra_pathitems, mod_path))
   68: 
   69:     try:
   70:         obj = import_module(mod_path)
   71:     except ImportError:
   72:         msg = f"Cannot import {mod_path!r}"
   73:         raise BackendUnavailable(msg, traceback.format_exc())
   74: 
   75:     if obj_path:
   76:         for path_part in obj_path.split("."):
   77:             obj = getattr(obj, path_part)
   78:     return obj
   79: 
   80: 
   81: class _BackendPathFinder:
   82:     """Implements the MetaPathFinder interface to locate modules in ``backend-path``.
   83: 
   84:     Since the environment provided by the frontend can contain all sorts of
   85:     MetaPathFinders, the only way to ensure the backend is loaded from the
   86:     right place is to prepend our own.
   87:     """
   88: 
   89:     def __init__(self, backend_path, backend_module):
   90:         self.backend_path = backend_path
   91:         self.backend_module = backend_module
   92:         self.backend_parent, _, _ = backend_module.partition(".")
   93: 
   94:     def find_spec(self, fullname, _path, _target=None):
   95:         if "." in fullname:
   96:             # Rely on importlib to find nested modules based on parent's path
   97:             return None
   98: 
   99:         # Ignore other items in _path or sys.path and use backend_path instead:
  100:         spec = PathFinder.find_spec(fullname, path=self.backend_path)
  101:         if spec is None and fullname == self.backend_parent:
  102:             # According to the spec, the backend MUST be loaded from backend-path.
  103:             # Therefore, we can halt the import machinery and raise a clean error.
  104:             msg = f"Cannot find module {self.backend_module!r} in {self.backend_path!r}"
  105:             raise BackendUnavailable(msg)
  106: 
  107:         return spec
  108: 
  109:     if sys.version_info >= (3, 8):
  110: 
  111:         def find_distributions(self, context=None):
  112:             # Delayed import: Python 3.7 does not contain importlib.metadata
  113:             from importlib.metadata import DistributionFinder, MetadataPathFinder
  114: 
  115:             context = DistributionFinder.Context(path=self.backend_path)
  116:             return MetadataPathFinder.find_distributions(context=context)
  117: 
  118: 
  119: def _supported_features():
  120:     """Return the list of options features supported by the backend.
  121: 
  122:     Returns a list of strings.
  123:     The only possible value is 'build_editable'.
  124:     """
  125:     backend = _build_backend()
  126:     features = []
  127:     if hasattr(backend, "build_editable"):
  128:         features.append("build_editable")
  129:     return features
  130: 
  131: 
  132: def get_requires_for_build_wheel(config_settings):
  133:     """Invoke the optional get_requires_for_build_wheel hook
  134: 
  135:     Returns [] if the hook is not defined.
  136:     """
  137:     backend = _build_backend()
  138:     try:
  139:         hook = backend.get_requires_for_build_wheel
  140:     except AttributeError:
  141:         return []
  142:     else:
  143:         return hook(config_settings)
  144: 
  145: 
  146: def get_requires_for_build_editable(config_settings):
  147:     """Invoke the optional get_requires_for_build_editable hook
  148: 
  149:     Returns [] if the hook is not defined.
  150:     """
  151:     backend = _build_backend()
  152:     try:
  153:         hook = backend.get_requires_for_build_editable
  154:     except AttributeError:
  155:         return []
  156:     else:
  157:         return hook(config_settings)
  158: 
  159: 
  160: def prepare_metadata_for_build_wheel(
  161:     metadata_directory, config_settings, _allow_fallback
  162: ):
  163:     """Invoke optional prepare_metadata_for_build_wheel
  164: 
  165:     Implements a fallback by building a wheel if the hook isn't defined,
  166:     unless _allow_fallback is False in which case HookMissing is raised.
  167:     """
  168:     backend = _build_backend()
  169:     try:
  170:         hook = backend.prepare_metadata_for_build_wheel
  171:     except AttributeError:
  172:         if not _allow_fallback:
  173:             raise HookMissing()
  174:     else:
  175:         return hook(metadata_directory, config_settings)
  176:     # fallback to build_wheel outside the try block to avoid exception chaining
  177:     # which can be confusing to users and is not relevant
  178:     whl_basename = backend.build_wheel(metadata_directory, config_settings)
  179:     return _get_wheel_metadata_from_wheel(
  180:         whl_basename, metadata_directory, config_settings
  181:     )
  182: 
  183: 
  184: def prepare_metadata_for_build_editable(
  185:     metadata_directory, config_settings, _allow_fallback
  186: ):
  187:     """Invoke optional prepare_metadata_for_build_editable
  188: 
  189:     Implements a fallback by building an editable wheel if the hook isn't
  190:     defined, unless _allow_fallback is False in which case HookMissing is
  191:     raised.
  192:     """
  193:     backend = _build_backend()
  194:     try:
  195:         hook = backend.prepare_metadata_for_build_editable
  196:     except AttributeError:
  197:         if not _allow_fallback:
  198:             raise HookMissing()
  199:         try:
  200:             build_hook = backend.build_editable
  201:         except AttributeError:
  202:             raise HookMissing(hook_name="build_editable")
  203:         else:
  204:             whl_basename = build_hook(metadata_directory, config_settings)
  205:             return _get_wheel_metadata_from_wheel(
  206:                 whl_basename, metadata_directory, config_settings
  207:             )
  208:     else:
  209:         return hook(metadata_directory, config_settings)
  210: 
  211: 
  212: WHEEL_BUILT_MARKER = "PYPROJECT_HOOKS_ALREADY_BUILT_WHEEL"
  213: 
  214: 
  215: def _dist_info_files(whl_zip):
  216:     """Identify the .dist-info folder inside a wheel ZipFile."""
  217:     res = []
  218:     for path in whl_zip.namelist():
  219:         m = re.match(r"[^/\\]+-[^/\\]+\.dist-info/", path)
  220:         if m:
  221:             res.append(path)
  222:     if res:
  223:         return res
  224:     raise Exception("No .dist-info folder found in wheel")
  225: 
  226: 
  227: def _get_wheel_metadata_from_wheel(whl_basename, metadata_directory, config_settings):
  228:     """Extract the metadata from a wheel.
  229: 
  230:     Fallback for when the build backend does not
  231:     define the 'get_wheel_metadata' hook.
  232:     """
  233:     from zipfile import ZipFile
  234: 
  235:     with open(os.path.join(metadata_directory, WHEEL_BUILT_MARKER), "wb"):
  236:         pass  # Touch marker file
  237: 
  238:     whl_file = os.path.join(metadata_directory, whl_basename)
  239:     with ZipFile(whl_file) as zipf:
  240:         dist_info = _dist_info_files(zipf)
  241:         zipf.extractall(path=metadata_directory, members=dist_info)
  242:     return dist_info[0].split("/")[0]
  243: 
  244: 
  245: def _find_already_built_wheel(metadata_directory):
  246:     """Check for a wheel already built during the get_wheel_metadata hook."""
  247:     if not metadata_directory:
  248:         return None
  249:     metadata_parent = os.path.dirname(metadata_directory)
  250:     if not os.path.isfile(pjoin(metadata_parent, WHEEL_BUILT_MARKER)):
  251:         return None
  252: 
  253:     whl_files = glob(os.path.join(metadata_parent, "*.whl"))
  254:     if not whl_files:
  255:         print("Found wheel built marker, but no .whl files")
  256:         return None
  257:     if len(whl_files) > 1:
  258:         print(
  259:             "Found multiple .whl files; unspecified behaviour. "
  260:             "Will call build_wheel."
  261:         )
  262:         return None
  263: 
  264:     # Exactly one .whl file
  265:     return whl_files[0]
  266: 
  267: 
  268: def build_wheel(wheel_directory, config_settings, metadata_directory=None):
  269:     """Invoke the mandatory build_wheel hook.
  270: 
  271:     If a wheel was already built in the
  272:     prepare_metadata_for_build_wheel fallback, this
  273:     will copy it rather than rebuilding the wheel.
  274:     """
  275:     prebuilt_whl = _find_already_built_wheel(metadata_directory)
  276:     if prebuilt_whl:
  277:         shutil.copy2(prebuilt_whl, wheel_directory)
  278:         return os.path.basename(prebuilt_whl)
  279: 
  280:     return _build_backend().build_wheel(
  281:         wheel_directory, config_settings, metadata_directory
  282:     )
  283: 
  284: 
  285: def build_editable(wheel_directory, config_settings, metadata_directory=None):
  286:     """Invoke the optional build_editable hook.
  287: 
  288:     If a wheel was already built in the
  289:     prepare_metadata_for_build_editable fallback, this
  290:     will copy it rather than rebuilding the wheel.
  291:     """
  292:     backend = _build_backend()
  293:     try:
  294:         hook = backend.build_editable
  295:     except AttributeError:
  296:         raise HookMissing()
  297:     else:
  298:         prebuilt_whl = _find_already_built_wheel(metadata_directory)
  299:         if prebuilt_whl:
  300:             shutil.copy2(prebuilt_whl, wheel_directory)
  301:             return os.path.basename(prebuilt_whl)
  302: 
  303:         return hook(wheel_directory, config_settings, metadata_directory)
  304: 
  305: 
  306: def get_requires_for_build_sdist(config_settings):
  307:     """Invoke the optional get_requires_for_build_wheel hook
  308: 
  309:     Returns [] if the hook is not defined.
  310:     """
  311:     backend = _build_backend()
  312:     try:
  313:         hook = backend.get_requires_for_build_sdist
  314:     except AttributeError:
  315:         return []
  316:     else:
  317:         return hook(config_settings)
  318: 
  319: 
  320: class _DummyException(Exception):
  321:     """Nothing should ever raise this exception"""
  322: 
  323: 
  324: class GotUnsupportedOperation(Exception):
  325:     """For internal use when backend raises UnsupportedOperation"""
  326: 
  327:     def __init__(self, traceback):
  328:         self.traceback = traceback
  329: 
  330: 
  331: def build_sdist(sdist_directory, config_settings):
  332:     """Invoke the mandatory build_sdist hook."""
  333:     backend = _build_backend()
  334:     try:
  335:         return backend.build_sdist(sdist_directory, config_settings)
  336:     except getattr(backend, "UnsupportedOperation", _DummyException):
  337:         raise GotUnsupportedOperation(traceback.format_exc())
  338: 
  339: 
  340: HOOK_NAMES = {
  341:     "get_requires_for_build_wheel",
  342:     "prepare_metadata_for_build_wheel",
  343:     "build_wheel",
  344:     "get_requires_for_build_editable",
  345:     "prepare_metadata_for_build_editable",
  346:     "build_editable",
  347:     "get_requires_for_build_sdist",
  348:     "build_sdist",
  349:     "_supported_features",
  350: }
  351: 
  352: 
  353: def main():
  354:     if len(sys.argv) < 3:
  355:         sys.exit("Needs args: hook_name, control_dir")
  356:     hook_name = sys.argv[1]
  357:     control_dir = sys.argv[2]
  358:     if hook_name not in HOOK_NAMES:
  359:         sys.exit("Unknown hook: %s" % hook_name)
  360: 
  361:     # Remove the parent directory from sys.path to avoid polluting the backend
  362:     # import namespace with this directory.
  363:     here = os.path.dirname(__file__)
  364:     if here in sys.path:
  365:         sys.path.remove(here)
  366: 
  367:     hook = globals()[hook_name]
  368: 
  369:     hook_input = read_json(pjoin(control_dir, "input.json"))
  370: 
  371:     json_out = {"unsupported": False, "return_val": None}
  372:     try:
  373:         json_out["return_val"] = hook(**hook_input["kwargs"])
  374:     except BackendUnavailable as e:
  375:         json_out["no_backend"] = True
  376:         json_out["traceback"] = e.traceback
  377:         json_out["backend_error"] = e.message
  378:     except GotUnsupportedOperation as e:
  379:         json_out["unsupported"] = True
  380:         json_out["traceback"] = e.traceback
  381:     except HookMissing as e:
  382:         json_out["hook_missing"] = True
  383:         json_out["missing_hook_name"] = e.hook_name or hook_name
  384: 
  385:     write_json(json_out, pjoin(control_dir, "output.json"), indent=2)
  386: 
  387: 
  388: if __name__ == "__main__":
  389:     main()
