    1: """
    2: certifi.py
    3: ~~~~~~~~~~
    4: 
    5: This module returns the installation location of cacert.pem or its contents.
    6: """
    7: import sys
    8: import atexit
    9: 
   10: def exit_cacert_ctx() -> None:
   11:     _CACERT_CTX.__exit__(None, None, None)  # type: ignore[union-attr]
   12: 
   13: 
   14: if sys.version_info >= (3, 11):
   15: 
   16:     from importlib.resources import as_file, files
   17: 
   18:     _CACERT_CTX = None
   19:     _CACERT_PATH = None
   20: 
   21:     def where() -> str:
   22:         # This is slightly terrible, but we want to delay extracting the file
   23:         # in cases where we're inside of a zipimport situation until someone
   24:         # actually calls where(), but we don't want to re-extract the file
   25:         # on every call of where(), so we'll do it once then store it in a
   26:         # global variable.
   27:         global _CACERT_CTX
   28:         global _CACERT_PATH
   29:         if _CACERT_PATH is None:
   30:             # This is slightly janky, the importlib.resources API wants you to
   31:             # manage the cleanup of this file, so it doesn't actually return a
   32:             # path, it returns a context manager that will give you the path
   33:             # when you enter it and will do any cleanup when you leave it. In
   34:             # the common case of not needing a temporary file, it will just
   35:             # return the file system location and the __exit__() is a no-op.
   36:             #
   37:             # We also have to hold onto the actual context manager, because
   38:             # it will do the cleanup whenever it gets garbage collected, so
   39:             # we will also store that at the global level as well.
   40:             _CACERT_CTX = as_file(files("pip._vendor.certifi").joinpath("cacert.pem"))
   41:             _CACERT_PATH = str(_CACERT_CTX.__enter__())
   42:             atexit.register(exit_cacert_ctx)
   43: 
   44:         return _CACERT_PATH
   45: 
   46:     def contents() -> str:
   47:         return files("pip._vendor.certifi").joinpath("cacert.pem").read_text(encoding="ascii")
   48: 
   49: else:
   50: 
   51:     from importlib.resources import path as get_path, read_text
   52: 
   53:     _CACERT_CTX = None
   54:     _CACERT_PATH = None
   55: 
   56:     def where() -> str:
   57:         # This is slightly terrible, but we want to delay extracting the
   58:         # file in cases where we're inside of a zipimport situation until
   59:         # someone actually calls where(), but we don't want to re-extract
   60:         # the file on every call of where(), so we'll do it once then store
   61:         # it in a global variable.
   62:         global _CACERT_CTX
   63:         global _CACERT_PATH
   64:         if _CACERT_PATH is None:
   65:             # This is slightly janky, the importlib.resources API wants you
   66:             # to manage the cleanup of this file, so it doesn't actually
   67:             # return a path, it returns a context manager that will give
   68:             # you the path when you enter it and will do any cleanup when
   69:             # you leave it. In the common case of not needing a temporary
   70:             # file, it will just return the file system location and the
   71:             # __exit__() is a no-op.
   72:             #
   73:             # We also have to hold onto the actual context manager, because
   74:             # it will do the cleanup whenever it gets garbage collected, so
   75:             # we will also store that at the global level as well.
   76:             _CACERT_CTX = get_path("pip._vendor.certifi", "cacert.pem")
   77:             _CACERT_PATH = str(_CACERT_CTX.__enter__())
   78:             atexit.register(exit_cacert_ctx)
   79: 
   80:         return _CACERT_PATH
   81: 
   82:     def contents() -> str:
   83:         return read_text("pip._vendor.certifi", "cacert.pem", encoding="ascii")
