    1: from __future__ import annotations
    2: 
    3: import dataclasses
    4: import re
    5: from collections.abc import Mapping
    6: 
    7: from pip._vendor.packaging.requirements import Requirement
    8: 
    9: 
   10: def _normalize_name(name: str) -> str:
   11:     return re.sub(r"[-_.]+", "-", name).lower()
   12: 
   13: 
   14: def _normalize_group_names(
   15:     dependency_groups: Mapping[str, str | Mapping[str, str]],
   16: ) -> Mapping[str, str | Mapping[str, str]]:
   17:     original_names: dict[str, list[str]] = {}
   18:     normalized_groups = {}
   19: 
   20:     for group_name, value in dependency_groups.items():
   21:         normed_group_name = _normalize_name(group_name)
   22:         original_names.setdefault(normed_group_name, []).append(group_name)
   23:         normalized_groups[normed_group_name] = value
   24: 
   25:     errors = []
   26:     for normed_name, names in original_names.items():
   27:         if len(names) > 1:
   28:             errors.append(f"{normed_name} ({', '.join(names)})")
   29:     if errors:
   30:         raise ValueError(f"Duplicate dependency group names: {', '.join(errors)}")
   31: 
   32:     return normalized_groups
   33: 
   34: 
   35: @dataclasses.dataclass
   36: class DependencyGroupInclude:
   37:     include_group: str
   38: 
   39: 
   40: class CyclicDependencyError(ValueError):
   41:     """
   42:     An error representing the detection of a cycle.
   43:     """
   44: 
   45:     def __init__(self, requested_group: str, group: str, include_group: str) -> None:
   46:         self.requested_group = requested_group
   47:         self.group = group
   48:         self.include_group = include_group
   49: 
   50:         if include_group == group:
   51:             reason = f"{group} includes itself"
   52:         else:
   53:             reason = f"{include_group} -> {group}, {group} -> {include_group}"
   54:         super().__init__(
   55:             "Cyclic dependency group include while resolving "
   56:             f"{requested_group}: {reason}"
   57:         )
   58: 
   59: 
   60: class DependencyGroupResolver:
   61:     """
   62:     A resolver for Dependency Group data.
   63: 
   64:     This class handles caching, name normalization, cycle detection, and other
   65:     parsing requirements. There are only two public methods for exploring the data:
   66:     ``lookup()`` and ``resolve()``.
   67: 
   68:     :param dependency_groups: A mapping, as provided via pyproject
   69:         ``[dependency-groups]``.
   70:     """
   71: 
   72:     def __init__(
   73:         self,
   74:         dependency_groups: Mapping[str, str | Mapping[str, str]],
   75:     ) -> None:
   76:         if not isinstance(dependency_groups, Mapping):
   77:             raise TypeError("Dependency Groups table is not a mapping")
   78:         self.dependency_groups = _normalize_group_names(dependency_groups)
   79:         # a map of group names to parsed data
   80:         self._parsed_groups: dict[
   81:             str, tuple[Requirement | DependencyGroupInclude, ...]
   82:         ] = {}
   83:         # a map of group names to their ancestors, used for cycle detection
   84:         self._include_graph_ancestors: dict[str, tuple[str, ...]] = {}
   85:         # a cache of completed resolutions to Requirement lists
   86:         self._resolve_cache: dict[str, tuple[Requirement, ...]] = {}
   87: 
   88:     def lookup(self, group: str) -> tuple[Requirement | DependencyGroupInclude, ...]:
   89:         """
   90:         Lookup a group name, returning the parsed dependency data for that group.
   91:         This will not resolve includes.
   92: 
   93:         :param group: the name of the group to lookup
   94: 
   95:         :raises ValueError: if the data does not appear to be valid dependency group
   96:             data
   97:         :raises TypeError: if the data is not a string
   98:         :raises LookupError: if group name is absent
   99:         :raises packaging.requirements.InvalidRequirement: if a specifier is not valid
  100:         """
  101:         if not isinstance(group, str):
  102:             raise TypeError("Dependency group name is not a str")
  103:         group = _normalize_name(group)
  104:         return self._parse_group(group)
  105: 
  106:     def resolve(self, group: str) -> tuple[Requirement, ...]:
  107:         """
  108:         Resolve a dependency group to a list of requirements.
  109: 
  110:         :param group: the name of the group to resolve
  111: 
  112:         :raises TypeError: if the inputs appear to be the wrong types
  113:         :raises ValueError: if the data does not appear to be valid dependency group
  114:             data
  115:         :raises LookupError: if group name is absent
  116:         :raises packaging.requirements.InvalidRequirement: if a specifier is not valid
  117:         """
  118:         if not isinstance(group, str):
  119:             raise TypeError("Dependency group name is not a str")
  120:         group = _normalize_name(group)
  121:         return self._resolve(group, group)
  122: 
  123:     def _parse_group(
  124:         self, group: str
  125:     ) -> tuple[Requirement | DependencyGroupInclude, ...]:
  126:         # short circuit -- never do the work twice
  127:         if group in self._parsed_groups:
  128:             return self._parsed_groups[group]
  129: 
  130:         if group not in self.dependency_groups:
  131:             raise LookupError(f"Dependency group '{group}' not found")
  132: 
  133:         raw_group = self.dependency_groups[group]
  134:         if not isinstance(raw_group, list):
  135:             raise TypeError(f"Dependency group '{group}' is not a list")
  136: 
  137:         elements: list[Requirement | DependencyGroupInclude] = []
  138:         for item in raw_group:
  139:             if isinstance(item, str):
  140:                 # packaging.requirements.Requirement parsing ensures that this is a
  141:                 # valid PEP 508 Dependency Specifier
  142:                 # raises InvalidRequirement on failure
  143:                 elements.append(Requirement(item))
  144:             elif isinstance(item, dict):
  145:                 if tuple(item.keys()) != ("include-group",):
  146:                     raise ValueError(f"Invalid dependency group item: {item}")
  147: 
  148:                 include_group = next(iter(item.values()))
  149:                 elements.append(DependencyGroupInclude(include_group=include_group))
  150:             else:
  151:                 raise ValueError(f"Invalid dependency group item: {item}")
  152: 
  153:         self._parsed_groups[group] = tuple(elements)
  154:         return self._parsed_groups[group]
  155: 
  156:     def _resolve(self, group: str, requested_group: str) -> tuple[Requirement, ...]:
  157:         """
  158:         This is a helper for cached resolution to strings.
  159: 
  160:         :param group: The name of the group to resolve.
  161:         :param requested_group: The group which was used in the original, user-facing
  162:             request.
  163:         """
  164:         if group in self._resolve_cache:
  165:             return self._resolve_cache[group]
  166: 
  167:         parsed = self._parse_group(group)
  168: 
  169:         resolved_group = []
  170:         for item in parsed:
  171:             if isinstance(item, Requirement):
  172:                 resolved_group.append(item)
  173:             elif isinstance(item, DependencyGroupInclude):
  174:                 include_group = _normalize_name(item.include_group)
  175:                 if include_group in self._include_graph_ancestors.get(group, ()):
  176:                     raise CyclicDependencyError(
  177:                         requested_group, group, item.include_group
  178:                     )
  179:                 self._include_graph_ancestors[include_group] = (
  180:                     *self._include_graph_ancestors.get(group, ()),
  181:                     group,
  182:                 )
  183:                 resolved_group.extend(self._resolve(include_group, requested_group))
  184:             else:  # unreachable
  185:                 raise NotImplementedError(
  186:                     f"Invalid dependency group item after parse: {item}"
  187:                 )
  188: 
  189:         self._resolve_cache[group] = tuple(resolved_group)
  190:         return self._resolve_cache[group]
  191: 
  192: 
  193: def resolve(
  194:     dependency_groups: Mapping[str, str | Mapping[str, str]], /, *groups: str
  195: ) -> tuple[str, ...]:
  196:     """
  197:     Resolve a dependency group to a tuple of requirements, as strings.
  198: 
  199:     :param dependency_groups: the parsed contents of the ``[dependency-groups]`` table
  200:         from ``pyproject.toml``
  201:     :param groups: the name of the group(s) to resolve
  202: 
  203:     :raises TypeError: if the inputs appear to be the wrong types
  204:     :raises ValueError: if the data does not appear to be valid dependency group data
  205:     :raises LookupError: if group name is absent
  206:     :raises packaging.requirements.InvalidRequirement: if a specifier is not valid
  207:     """
  208:     resolver = DependencyGroupResolver(dependency_groups)
  209:     return tuple(str(r) for group in groups for r in resolver.resolve(group))
