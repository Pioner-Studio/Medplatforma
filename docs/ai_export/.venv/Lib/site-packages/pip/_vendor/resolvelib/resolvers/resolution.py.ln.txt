    1: from __future__ import annotations
    2: 
    3: import collections
    4: import itertools
    5: import operator
    6: from typing import TYPE_CHECKING, Generic
    7: 
    8: from ..structs import (
    9:     CT,
   10:     KT,
   11:     RT,
   12:     DirectedGraph,
   13:     IterableView,
   14:     IteratorMapping,
   15:     RequirementInformation,
   16:     State,
   17:     build_iter_view,
   18: )
   19: from .abstract import AbstractResolver, Result
   20: from .criterion import Criterion
   21: from .exceptions import (
   22:     InconsistentCandidate,
   23:     RequirementsConflicted,
   24:     ResolutionImpossible,
   25:     ResolutionTooDeep,
   26:     ResolverException,
   27: )
   28: 
   29: if TYPE_CHECKING:
   30:     from collections.abc import Collection, Iterable, Mapping
   31: 
   32:     from ..providers import AbstractProvider, Preference
   33:     from ..reporters import BaseReporter
   34: 
   35: _OPTIMISTIC_BACKJUMPING_RATIO: float = 0.1
   36: 
   37: 
   38: def _build_result(state: State[RT, CT, KT]) -> Result[RT, CT, KT]:
   39:     mapping = state.mapping
   40:     all_keys: dict[int, KT | None] = {id(v): k for k, v in mapping.items()}
   41:     all_keys[id(None)] = None
   42: 
   43:     graph: DirectedGraph[KT | None] = DirectedGraph()
   44:     graph.add(None)  # Sentinel as root dependencies' parent.
   45: 
   46:     connected: set[KT | None] = {None}
   47:     for key, criterion in state.criteria.items():
   48:         if not _has_route_to_root(state.criteria, key, all_keys, connected):
   49:             continue
   50:         if key not in graph:
   51:             graph.add(key)
   52:         for p in criterion.iter_parent():
   53:             try:
   54:                 pkey = all_keys[id(p)]
   55:             except KeyError:
   56:                 continue
   57:             if pkey not in graph:
   58:                 graph.add(pkey)
   59:             graph.connect(pkey, key)
   60: 
   61:     return Result(
   62:         mapping={k: v for k, v in mapping.items() if k in connected},
   63:         graph=graph,
   64:         criteria=state.criteria,
   65:     )
   66: 
   67: 
   68: class Resolution(Generic[RT, CT, KT]):
   69:     """Stateful resolution object.
   70: 
   71:     This is designed as a one-off object that holds information to kick start
   72:     the resolution process, and holds the results afterwards.
   73:     """
   74: 
   75:     def __init__(
   76:         self,
   77:         provider: AbstractProvider[RT, CT, KT],
   78:         reporter: BaseReporter[RT, CT, KT],
   79:     ) -> None:
   80:         self._p = provider
   81:         self._r = reporter
   82:         self._states: list[State[RT, CT, KT]] = []
   83: 
   84:         # Optimistic backjumping variables
   85:         self._optimistic_backjumping_ratio = _OPTIMISTIC_BACKJUMPING_RATIO
   86:         self._save_states: list[State[RT, CT, KT]] | None = None
   87:         self._optimistic_start_round: int | None = None
   88: 
   89:     @property
   90:     def state(self) -> State[RT, CT, KT]:
   91:         try:
   92:             return self._states[-1]
   93:         except IndexError as e:
   94:             raise AttributeError("state") from e
   95: 
   96:     def _push_new_state(self) -> None:
   97:         """Push a new state into history.
   98: 
   99:         This new state will be used to hold resolution results of the next
  100:         coming round.
  101:         """
  102:         base = self._states[-1]
  103:         state = State(
  104:             mapping=base.mapping.copy(),
  105:             criteria=base.criteria.copy(),
  106:             backtrack_causes=base.backtrack_causes[:],
  107:         )
  108:         self._states.append(state)
  109: 
  110:     def _add_to_criteria(
  111:         self,
  112:         criteria: dict[KT, Criterion[RT, CT]],
  113:         requirement: RT,
  114:         parent: CT | None,
  115:     ) -> None:
  116:         self._r.adding_requirement(requirement=requirement, parent=parent)
  117: 
  118:         identifier = self._p.identify(requirement_or_candidate=requirement)
  119:         criterion = criteria.get(identifier)
  120:         if criterion:
  121:             incompatibilities = list(criterion.incompatibilities)
  122:         else:
  123:             incompatibilities = []
  124: 
  125:         matches = self._p.find_matches(
  126:             identifier=identifier,
  127:             requirements=IteratorMapping(
  128:                 criteria,
  129:                 operator.methodcaller("iter_requirement"),
  130:                 {identifier: [requirement]},
  131:             ),
  132:             incompatibilities=IteratorMapping(
  133:                 criteria,
  134:                 operator.attrgetter("incompatibilities"),
  135:                 {identifier: incompatibilities},
  136:             ),
  137:         )
  138: 
  139:         if criterion:
  140:             information = list(criterion.information)
  141:             information.append(RequirementInformation(requirement, parent))
  142:         else:
  143:             information = [RequirementInformation(requirement, parent)]
  144: 
  145:         criterion = Criterion(
  146:             candidates=build_iter_view(matches),
  147:             information=information,
  148:             incompatibilities=incompatibilities,
  149:         )
  150:         if not criterion.candidates:
  151:             raise RequirementsConflicted(criterion)
  152:         criteria[identifier] = criterion
  153: 
  154:     def _remove_information_from_criteria(
  155:         self, criteria: dict[KT, Criterion[RT, CT]], parents: Collection[KT]
  156:     ) -> None:
  157:         """Remove information from parents of criteria.
  158: 
  159:         Concretely, removes all values from each criterion's ``information``
  160:         field that have one of ``parents`` as provider of the requirement.
  161: 
  162:         :param criteria: The criteria to update.
  163:         :param parents: Identifiers for which to remove information from all criteria.
  164:         """
  165:         if not parents:
  166:             return
  167:         for key, criterion in criteria.items():
  168:             criteria[key] = Criterion(
  169:                 criterion.candidates,
  170:                 [
  171:                     information
  172:                     for information in criterion.information
  173:                     if (
  174:                         information.parent is None
  175:                         or self._p.identify(information.parent) not in parents
  176:                     )
  177:                 ],
  178:                 criterion.incompatibilities,
  179:             )
  180: 
  181:     def _get_preference(self, name: KT) -> Preference:
  182:         return self._p.get_preference(
  183:             identifier=name,
  184:             resolutions=self.state.mapping,
  185:             candidates=IteratorMapping(
  186:                 self.state.criteria,
  187:                 operator.attrgetter("candidates"),
  188:             ),
  189:             information=IteratorMapping(
  190:                 self.state.criteria,
  191:                 operator.attrgetter("information"),
  192:             ),
  193:             backtrack_causes=self.state.backtrack_causes,
  194:         )
  195: 
  196:     def _is_current_pin_satisfying(
  197:         self, name: KT, criterion: Criterion[RT, CT]
  198:     ) -> bool:
  199:         try:
  200:             current_pin = self.state.mapping[name]
  201:         except KeyError:
  202:             return False
  203:         return all(
  204:             self._p.is_satisfied_by(requirement=r, candidate=current_pin)
  205:             for r in criterion.iter_requirement()
  206:         )
  207: 
  208:     def _get_updated_criteria(self, candidate: CT) -> dict[KT, Criterion[RT, CT]]:
  209:         criteria = self.state.criteria.copy()
  210:         for requirement in self._p.get_dependencies(candidate=candidate):
  211:             self._add_to_criteria(criteria, requirement, parent=candidate)
  212:         return criteria
  213: 
  214:     def _attempt_to_pin_criterion(self, name: KT) -> list[Criterion[RT, CT]]:
  215:         criterion = self.state.criteria[name]
  216: 
  217:         causes: list[Criterion[RT, CT]] = []
  218:         for candidate in criterion.candidates:
  219:             try:
  220:                 criteria = self._get_updated_criteria(candidate)
  221:             except RequirementsConflicted as e:
  222:                 self._r.rejecting_candidate(e.criterion, candidate)
  223:                 causes.append(e.criterion)
  224:                 continue
  225: 
  226:             # Check the newly-pinned candidate actually works. This should
  227:             # always pass under normal circumstances, but in the case of a
  228:             # faulty provider, we will raise an error to notify the implementer
  229:             # to fix find_matches() and/or is_satisfied_by().
  230:             satisfied = all(
  231:                 self._p.is_satisfied_by(requirement=r, candidate=candidate)
  232:                 for r in criterion.iter_requirement()
  233:             )
  234:             if not satisfied:
  235:                 raise InconsistentCandidate(candidate, criterion)
  236: 
  237:             self._r.pinning(candidate=candidate)
  238:             self.state.criteria.update(criteria)
  239: 
  240:             # Put newly-pinned candidate at the end. This is essential because
  241:             # backtracking looks at this mapping to get the last pin.
  242:             self.state.mapping.pop(name, None)
  243:             self.state.mapping[name] = candidate
  244: 
  245:             return []
  246: 
  247:         # All candidates tried, nothing works. This criterion is a dead
  248:         # end, signal for backtracking.
  249:         return causes
  250: 
  251:     def _patch_criteria(
  252:         self, incompatibilities_from_broken: list[tuple[KT, list[CT]]]
  253:     ) -> bool:
  254:         # Create a new state from the last known-to-work one, and apply
  255:         # the previously gathered incompatibility information.
  256:         for k, incompatibilities in incompatibilities_from_broken:
  257:             if not incompatibilities:
  258:                 continue
  259:             try:
  260:                 criterion = self.state.criteria[k]
  261:             except KeyError:
  262:                 continue
  263:             matches = self._p.find_matches(
  264:                 identifier=k,
  265:                 requirements=IteratorMapping(
  266:                     self.state.criteria,
  267:                     operator.methodcaller("iter_requirement"),
  268:                 ),
  269:                 incompatibilities=IteratorMapping(
  270:                     self.state.criteria,
  271:                     operator.attrgetter("incompatibilities"),
  272:                     {k: incompatibilities},
  273:                 ),
  274:             )
  275:             candidates: IterableView[CT] = build_iter_view(matches)
  276:             if not candidates:
  277:                 return False
  278:             incompatibilities.extend(criterion.incompatibilities)
  279:             self.state.criteria[k] = Criterion(
  280:                 candidates=candidates,
  281:                 information=list(criterion.information),
  282:                 incompatibilities=incompatibilities,
  283:             )
  284:         return True
  285: 
  286:     def _save_state(self) -> None:
  287:         """Save states for potential rollback if optimistic backjumping fails."""
  288:         if self._save_states is None:
  289:             self._save_states = [
  290:                 State(
  291:                     mapping=s.mapping.copy(),
  292:                     criteria=s.criteria.copy(),
  293:                     backtrack_causes=s.backtrack_causes[:],
  294:                 )
  295:                 for s in self._states
  296:             ]
  297: 
  298:     def _rollback_states(self) -> None:
  299:         """Rollback states and disable optimistic backjumping."""
  300:         self._optimistic_backjumping_ratio = 0.0
  301:         if self._save_states:
  302:             self._states = self._save_states
  303:             self._save_states = None
  304: 
  305:     def _backjump(self, causes: list[RequirementInformation[RT, CT]]) -> bool:
  306:         """Perform backjumping.
  307: 
  308:         When we enter here, the stack is like this::
  309: 
  310:             [ state Z ]
  311:             [ state Y ]
  312:             [ state X ]
  313:             .... earlier states are irrelevant.
  314: 
  315:         1. No pins worked for Z, so it does not have a pin.
  316:         2. We want to reset state Y to unpinned, and pin another candidate.
  317:         3. State X holds what state Y was before the pin, but does not
  318:            have the incompatibility information gathered in state Y.
  319: 
  320:         Each iteration of the loop will:
  321: 
  322:         1.  Identify Z. The incompatibility is not always caused by the latest
  323:             state. For example, given three requirements A, B and C, with
  324:             dependencies A1, B1 and C1, where A1 and B1 are incompatible: the
  325:             last state might be related to C, so we want to discard the
  326:             previous state.
  327:         2.  Discard Z.
  328:         3.  Discard Y but remember its incompatibility information gathered
  329:             previously, and the failure we're dealing with right now.
  330:         4.  Push a new state Y' based on X, and apply the incompatibility
  331:             information from Y to Y'.
  332:         5a. If this causes Y' to conflict, we need to backtrack again. Make Y'
  333:             the new Z and go back to step 2.
  334:         5b. If the incompatibilities apply cleanly, end backtracking.
  335:         """
  336:         incompatible_reqs: Iterable[CT | RT] = itertools.chain(
  337:             (c.parent for c in causes if c.parent is not None),
  338:             (c.requirement for c in causes),
  339:         )
  340:         incompatible_deps = {self._p.identify(r) for r in incompatible_reqs}
  341:         while len(self._states) >= 3:
  342:             # Remove the state that triggered backtracking.
  343:             del self._states[-1]
  344: 
  345:             # Optimistically backtrack to a state that caused the incompatibility
  346:             broken_state = self.state
  347:             while True:
  348:                 # Retrieve the last candidate pin and known incompatibilities.
  349:                 try:
  350:                     broken_state = self._states.pop()
  351:                     name, candidate = broken_state.mapping.popitem()
  352:                 except (IndexError, KeyError):
  353:                     raise ResolutionImpossible(causes) from None
  354: 
  355:                 if (
  356:                     not self._optimistic_backjumping_ratio
  357:                     and name not in incompatible_deps
  358:                 ):
  359:                     # For safe backjumping only backjump if the current dependency
  360:                     # is not the same as the incompatible dependency
  361:                     break
  362: 
  363:                 # On the first time a non-safe backjump is done the state
  364:                 # is saved so we can restore it later if the resolution fails
  365:                 if (
  366:                     self._optimistic_backjumping_ratio
  367:                     and self._save_states is None
  368:                     and name not in incompatible_deps
  369:                 ):
  370:                     self._save_state()
  371: 
  372:                 # If the current dependencies and the incompatible dependencies
  373:                 # are overlapping then we have likely found a cause of the
  374:                 # incompatibility
  375:                 current_dependencies = {
  376:                     self._p.identify(d) for d in self._p.get_dependencies(candidate)
  377:                 }
  378:                 if not current_dependencies.isdisjoint(incompatible_deps):
  379:                     break
  380: 
  381:                 # Fallback: We should not backtrack to the point where
  382:                 # broken_state.mapping is empty, so stop backtracking for
  383:                 # a chance for the resolution to recover
  384:                 if not broken_state.mapping:
  385:                     break
  386: 
  387:             incompatibilities_from_broken = [
  388:                 (k, list(v.incompatibilities)) for k, v in broken_state.criteria.items()
  389:             ]
  390: 
  391:             # Also mark the newly known incompatibility.
  392:             incompatibilities_from_broken.append((name, [candidate]))
  393: 
  394:             self._push_new_state()
  395:             success = self._patch_criteria(incompatibilities_from_broken)
  396: 
  397:             # It works! Let's work on this new state.
  398:             if success:
  399:                 return True
  400: 
  401:             # State does not work after applying known incompatibilities.
  402:             # Try the still previous state.
  403: 
  404:         # No way to backtrack anymore.
  405:         return False
  406: 
  407:     def _extract_causes(
  408:         self, criteron: list[Criterion[RT, CT]]
  409:     ) -> list[RequirementInformation[RT, CT]]:
  410:         """Extract causes from list of criterion and deduplicate"""
  411:         return list({id(i): i for c in criteron for i in c.information}.values())
  412: 
  413:     def resolve(self, requirements: Iterable[RT], max_rounds: int) -> State[RT, CT, KT]:
  414:         if self._states:
  415:             raise RuntimeError("already resolved")
  416: 
  417:         self._r.starting()
  418: 
  419:         # Initialize the root state.
  420:         self._states = [
  421:             State(
  422:                 mapping=collections.OrderedDict(),
  423:                 criteria={},
  424:                 backtrack_causes=[],
  425:             )
  426:         ]
  427:         for r in requirements:
  428:             try:
  429:                 self._add_to_criteria(self.state.criteria, r, parent=None)
  430:             except RequirementsConflicted as e:
  431:                 raise ResolutionImpossible(e.criterion.information) from e
  432: 
  433:         # The root state is saved as a sentinel so the first ever pin can have
  434:         # something to backtrack to if it fails. The root state is basically
  435:         # pinning the virtual "root" package in the graph.
  436:         self._push_new_state()
  437: 
  438:         # Variables for optimistic backjumping
  439:         optimistic_rounds_cutoff: int | None = None
  440:         optimistic_backjumping_start_round: int | None = None
  441: 
  442:         for round_index in range(max_rounds):
  443:             self._r.starting_round(index=round_index)
  444: 
  445:             # Handle if optimistic backjumping has been running for too long
  446:             if self._optimistic_backjumping_ratio and self._save_states is not None:
  447:                 if optimistic_backjumping_start_round is None:
  448:                     optimistic_backjumping_start_round = round_index
  449:                     optimistic_rounds_cutoff = int(
  450:                         (max_rounds - round_index) * self._optimistic_backjumping_ratio
  451:                     )
  452: 
  453:                     if optimistic_rounds_cutoff <= 0:
  454:                         self._rollback_states()
  455:                         continue
  456:                 elif optimistic_rounds_cutoff is not None:
  457:                     if (
  458:                         round_index - optimistic_backjumping_start_round
  459:                         >= optimistic_rounds_cutoff
  460:                     ):
  461:                         self._rollback_states()
  462:                         continue
  463: 
  464:             unsatisfied_names = [
  465:                 key
  466:                 for key, criterion in self.state.criteria.items()
  467:                 if not self._is_current_pin_satisfying(key, criterion)
  468:             ]
  469: 
  470:             # All criteria are accounted for. Nothing more to pin, we are done!
  471:             if not unsatisfied_names:
  472:                 self._r.ending(state=self.state)
  473:                 return self.state
  474: 
  475:             # keep track of satisfied names to calculate diff after pinning
  476:             satisfied_names = set(self.state.criteria.keys()) - set(unsatisfied_names)
  477: 
  478:             if len(unsatisfied_names) > 1:
  479:                 narrowed_unstatisfied_names = list(
  480:                     self._p.narrow_requirement_selection(
  481:                         identifiers=unsatisfied_names,
  482:                         resolutions=self.state.mapping,
  483:                         candidates=IteratorMapping(
  484:                             self.state.criteria,
  485:                             operator.attrgetter("candidates"),
  486:                         ),
  487:                         information=IteratorMapping(
  488:                             self.state.criteria,
  489:                             operator.attrgetter("information"),
  490:                         ),
  491:                         backtrack_causes=self.state.backtrack_causes,
  492:                     )
  493:                 )
  494:             else:
  495:                 narrowed_unstatisfied_names = unsatisfied_names
  496: 
  497:             # If there are no unsatisfied names use unsatisfied names
  498:             if not narrowed_unstatisfied_names:
  499:                 raise RuntimeError("narrow_requirement_selection returned 0 names")
  500: 
  501:             # If there is only 1 unsatisfied name skip calling self._get_preference
  502:             if len(narrowed_unstatisfied_names) > 1:
  503:                 # Choose the most preferred unpinned criterion to try.
  504:                 name = min(narrowed_unstatisfied_names, key=self._get_preference)
  505:             else:
  506:                 name = narrowed_unstatisfied_names[0]
  507: 
  508:             failure_criterion = self._attempt_to_pin_criterion(name)
  509: 
  510:             if failure_criterion:
  511:                 causes = self._extract_causes(failure_criterion)
  512:                 # Backjump if pinning fails. The backjump process puts us in
  513:                 # an unpinned state, so we can work on it in the next round.
  514:                 self._r.resolving_conflicts(causes=causes)
  515: 
  516:                 try:
  517:                     success = self._backjump(causes)
  518:                 except ResolutionImpossible:
  519:                     if self._optimistic_backjumping_ratio and self._save_states:
  520:                         failed_optimistic_backjumping = True
  521:                     else:
  522:                         raise
  523:                 else:
  524:                     failed_optimistic_backjumping = bool(
  525:                         not success
  526:                         and self._optimistic_backjumping_ratio
  527:                         and self._save_states
  528:                     )
  529: 
  530:                 if failed_optimistic_backjumping and self._save_states:
  531:                     self._rollback_states()
  532:                 else:
  533:                     self.state.backtrack_causes[:] = causes
  534: 
  535:                     # Dead ends everywhere. Give up.
  536:                     if not success:
  537:                         raise ResolutionImpossible(self.state.backtrack_causes)
  538:             else:
  539:                 # discard as information sources any invalidated names
  540:                 # (unsatisfied names that were previously satisfied)
  541:                 newly_unsatisfied_names = {
  542:                     key
  543:                     for key, criterion in self.state.criteria.items()
  544:                     if key in satisfied_names
  545:                     and not self._is_current_pin_satisfying(key, criterion)
  546:                 }
  547:                 self._remove_information_from_criteria(
  548:                     self.state.criteria, newly_unsatisfied_names
  549:                 )
  550:                 # Pinning was successful. Push a new state to do another pin.
  551:                 self._push_new_state()
  552: 
  553:             self._r.ending_round(index=round_index, state=self.state)
  554: 
  555:         raise ResolutionTooDeep(max_rounds)
  556: 
  557: 
  558: class Resolver(AbstractResolver[RT, CT, KT]):
  559:     """The thing that performs the actual resolution work."""
  560: 
  561:     base_exception = ResolverException
  562: 
  563:     def resolve(  # type: ignore[override]
  564:         self,
  565:         requirements: Iterable[RT],
  566:         max_rounds: int = 100,
  567:     ) -> Result[RT, CT, KT]:
  568:         """Take a collection of constraints, spit out the resolution result.
  569: 
  570:         The return value is a representation to the final resolution result. It
  571:         is a tuple subclass with three public members:
  572: 
  573:         * `mapping`: A dict of resolved candidates. Each key is an identifier
  574:             of a requirement (as returned by the provider's `identify` method),
  575:             and the value is the resolved candidate.
  576:         * `graph`: A `DirectedGraph` instance representing the dependency tree.
  577:             The vertices are keys of `mapping`, and each edge represents *why*
  578:             a particular package is included. A special vertex `None` is
  579:             included to represent parents of user-supplied requirements.
  580:         * `criteria`: A dict of "criteria" that hold detailed information on
  581:             how edges in the graph are derived. Each key is an identifier of a
  582:             requirement, and the value is a `Criterion` instance.
  583: 
  584:         The following exceptions may be raised if a resolution cannot be found:
  585: 
  586:         * `ResolutionImpossible`: A resolution cannot be found for the given
  587:             combination of requirements. The `causes` attribute of the
  588:             exception is a list of (requirement, parent), giving the
  589:             requirements that could not be satisfied.
  590:         * `ResolutionTooDeep`: The dependency tree is too deeply nested and
  591:             the resolver gave up. This is usually caused by a circular
  592:             dependency, but you can try to resolve this by increasing the
  593:             `max_rounds` argument.
  594:         """
  595:         resolution = Resolution(self.provider, self.reporter)
  596:         state = resolution.resolve(requirements, max_rounds=max_rounds)
  597:         return _build_result(state)
  598: 
  599: 
  600: def _has_route_to_root(
  601:     criteria: Mapping[KT, Criterion[RT, CT]],
  602:     key: KT | None,
  603:     all_keys: dict[int, KT | None],
  604:     connected: set[KT | None],
  605: ) -> bool:
  606:     if key in connected:
  607:         return True
  608:     if key not in criteria:
  609:         return False
  610:     assert key is not None
  611:     for p in criteria[key].iter_parent():
  612:         try:
  613:             pkey = all_keys[id(p)]
  614:         except KeyError:
  615:             continue
  616:         if pkey in connected:
  617:             connected.add(key)
  618:             return True
  619:         if _has_route_to_root(criteria, pkey, all_keys, connected):
  620:             connected.add(key)
  621:             return True
  622:     return False
