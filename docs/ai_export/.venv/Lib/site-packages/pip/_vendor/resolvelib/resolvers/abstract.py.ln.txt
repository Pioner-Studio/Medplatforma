    1: from __future__ import annotations
    2: 
    3: import collections
    4: from typing import TYPE_CHECKING, Any, Generic, Iterable, Mapping, NamedTuple
    5: 
    6: from ..structs import CT, KT, RT, DirectedGraph
    7: 
    8: if TYPE_CHECKING:
    9:     from ..providers import AbstractProvider
   10:     from ..reporters import BaseReporter
   11:     from .criterion import Criterion
   12: 
   13:     class Result(NamedTuple, Generic[RT, CT, KT]):
   14:         mapping: Mapping[KT, CT]
   15:         graph: DirectedGraph[KT | None]
   16:         criteria: Mapping[KT, Criterion[RT, CT]]
   17: 
   18: else:
   19:     Result = collections.namedtuple("Result", ["mapping", "graph", "criteria"])
   20: 
   21: 
   22: class AbstractResolver(Generic[RT, CT, KT]):
   23:     """The thing that performs the actual resolution work."""
   24: 
   25:     base_exception = Exception
   26: 
   27:     def __init__(
   28:         self,
   29:         provider: AbstractProvider[RT, CT, KT],
   30:         reporter: BaseReporter[RT, CT, KT],
   31:     ) -> None:
   32:         self.provider = provider
   33:         self.reporter = reporter
   34: 
   35:     def resolve(self, requirements: Iterable[RT], **kwargs: Any) -> Result[RT, CT, KT]:
   36:         """Take a collection of constraints, spit out the resolution result.
   37: 
   38:         This returns a representation of the final resolution state, with one
   39:         guarenteed attribute ``mapping`` that contains resolved candidates as
   40:         values. The keys are their respective identifiers.
   41: 
   42:         :param requirements: A collection of constraints.
   43:         :param kwargs: Additional keyword arguments that subclasses may accept.
   44: 
   45:         :raises: ``self.base_exception`` or its subclass.
   46:         """
   47:         raise NotImplementedError
