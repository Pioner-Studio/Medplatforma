    1: from __future__ import annotations
    2: 
    3: from typing import TYPE_CHECKING, Collection, Generic
    4: 
    5: from .structs import CT, KT, RT, RequirementInformation, State
    6: 
    7: if TYPE_CHECKING:
    8:     from .resolvers import Criterion
    9: 
   10: 
   11: class BaseReporter(Generic[RT, CT, KT]):
   12:     """Delegate class to provide progress reporting for the resolver."""
   13: 
   14:     def starting(self) -> None:
   15:         """Called before the resolution actually starts."""
   16: 
   17:     def starting_round(self, index: int) -> None:
   18:         """Called before each round of resolution starts.
   19: 
   20:         The index is zero-based.
   21:         """
   22: 
   23:     def ending_round(self, index: int, state: State[RT, CT, KT]) -> None:
   24:         """Called before each round of resolution ends.
   25: 
   26:         This is NOT called if the resolution ends at this round. Use `ending`
   27:         if you want to report finalization. The index is zero-based.
   28:         """
   29: 
   30:     def ending(self, state: State[RT, CT, KT]) -> None:
   31:         """Called before the resolution ends successfully."""
   32: 
   33:     def adding_requirement(self, requirement: RT, parent: CT | None) -> None:
   34:         """Called when adding a new requirement into the resolve criteria.
   35: 
   36:         :param requirement: The additional requirement to be applied to filter
   37:             the available candidaites.
   38:         :param parent: The candidate that requires ``requirement`` as a
   39:             dependency, or None if ``requirement`` is one of the root
   40:             requirements passed in from ``Resolver.resolve()``.
   41:         """
   42: 
   43:     def resolving_conflicts(
   44:         self, causes: Collection[RequirementInformation[RT, CT]]
   45:     ) -> None:
   46:         """Called when starting to attempt requirement conflict resolution.
   47: 
   48:         :param causes: The information on the collision that caused the backtracking.
   49:         """
   50: 
   51:     def rejecting_candidate(self, criterion: Criterion[RT, CT], candidate: CT) -> None:
   52:         """Called when rejecting a candidate during backtracking."""
   53: 
   54:     def pinning(self, candidate: CT) -> None:
   55:         """Called when adding a candidate to the potential solution."""
