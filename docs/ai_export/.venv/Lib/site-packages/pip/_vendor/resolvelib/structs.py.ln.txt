    1: from __future__ import annotations
    2: 
    3: import itertools
    4: from collections import namedtuple
    5: from typing import (
    6:     TYPE_CHECKING,
    7:     Callable,
    8:     Generic,
    9:     Iterable,
   10:     Iterator,
   11:     Mapping,
   12:     NamedTuple,
   13:     Sequence,
   14:     TypeVar,
   15:     Union,
   16: )
   17: 
   18: KT = TypeVar("KT")  # Identifier.
   19: RT = TypeVar("RT")  # Requirement.
   20: CT = TypeVar("CT")  # Candidate.
   21: 
   22: Matches = Union[Iterable[CT], Callable[[], Iterable[CT]]]
   23: 
   24: if TYPE_CHECKING:
   25:     from .resolvers.criterion import Criterion
   26: 
   27:     class RequirementInformation(NamedTuple, Generic[RT, CT]):
   28:         requirement: RT
   29:         parent: CT | None
   30: 
   31:     class State(NamedTuple, Generic[RT, CT, KT]):
   32:         """Resolution state in a round."""
   33: 
   34:         mapping: dict[KT, CT]
   35:         criteria: dict[KT, Criterion[RT, CT]]
   36:         backtrack_causes: list[RequirementInformation[RT, CT]]
   37: 
   38: else:
   39:     RequirementInformation = namedtuple(
   40:         "RequirementInformation", ["requirement", "parent"]
   41:     )
   42:     State = namedtuple("State", ["mapping", "criteria", "backtrack_causes"])
   43: 
   44: 
   45: class DirectedGraph(Generic[KT]):
   46:     """A graph structure with directed edges."""
   47: 
   48:     def __init__(self) -> None:
   49:         self._vertices: set[KT] = set()
   50:         self._forwards: dict[KT, set[KT]] = {}  # <key> -> Set[<key>]
   51:         self._backwards: dict[KT, set[KT]] = {}  # <key> -> Set[<key>]
   52: 
   53:     def __iter__(self) -> Iterator[KT]:
   54:         return iter(self._vertices)
   55: 
   56:     def __len__(self) -> int:
   57:         return len(self._vertices)
   58: 
   59:     def __contains__(self, key: KT) -> bool:
   60:         return key in self._vertices
   61: 
   62:     def copy(self) -> DirectedGraph[KT]:
   63:         """Return a shallow copy of this graph."""
   64:         other = type(self)()
   65:         other._vertices = set(self._vertices)
   66:         other._forwards = {k: set(v) for k, v in self._forwards.items()}
   67:         other._backwards = {k: set(v) for k, v in self._backwards.items()}
   68:         return other
   69: 
   70:     def add(self, key: KT) -> None:
   71:         """Add a new vertex to the graph."""
   72:         if key in self._vertices:
   73:             raise ValueError("vertex exists")
   74:         self._vertices.add(key)
   75:         self._forwards[key] = set()
   76:         self._backwards[key] = set()
   77: 
   78:     def remove(self, key: KT) -> None:
   79:         """Remove a vertex from the graph, disconnecting all edges from/to it."""
   80:         self._vertices.remove(key)
   81:         for f in self._forwards.pop(key):
   82:             self._backwards[f].remove(key)
   83:         for t in self._backwards.pop(key):
   84:             self._forwards[t].remove(key)
   85: 
   86:     def connected(self, f: KT, t: KT) -> bool:
   87:         return f in self._backwards[t] and t in self._forwards[f]
   88: 
   89:     def connect(self, f: KT, t: KT) -> None:
   90:         """Connect two existing vertices.
   91: 
   92:         Nothing happens if the vertices are already connected.
   93:         """
   94:         if t not in self._vertices:
   95:             raise KeyError(t)
   96:         self._forwards[f].add(t)
   97:         self._backwards[t].add(f)
   98: 
   99:     def iter_edges(self) -> Iterator[tuple[KT, KT]]:
  100:         for f, children in self._forwards.items():
  101:             for t in children:
  102:                 yield f, t
  103: 
  104:     def iter_children(self, key: KT) -> Iterator[KT]:
  105:         return iter(self._forwards[key])
  106: 
  107:     def iter_parents(self, key: KT) -> Iterator[KT]:
  108:         return iter(self._backwards[key])
  109: 
  110: 
  111: class IteratorMapping(Mapping[KT, Iterator[CT]], Generic[RT, CT, KT]):
  112:     def __init__(
  113:         self,
  114:         mapping: Mapping[KT, RT],
  115:         accessor: Callable[[RT], Iterable[CT]],
  116:         appends: Mapping[KT, Iterable[CT]] | None = None,
  117:     ) -> None:
  118:         self._mapping = mapping
  119:         self._accessor = accessor
  120:         self._appends: Mapping[KT, Iterable[CT]] = appends or {}
  121: 
  122:     def __repr__(self) -> str:
  123:         return "IteratorMapping({!r}, {!r}, {!r})".format(
  124:             self._mapping,
  125:             self._accessor,
  126:             self._appends,
  127:         )
  128: 
  129:     def __bool__(self) -> bool:
  130:         return bool(self._mapping or self._appends)
  131: 
  132:     def __contains__(self, key: object) -> bool:
  133:         return key in self._mapping or key in self._appends
  134: 
  135:     def __getitem__(self, k: KT) -> Iterator[CT]:
  136:         try:
  137:             v = self._mapping[k]
  138:         except KeyError:
  139:             return iter(self._appends[k])
  140:         return itertools.chain(self._accessor(v), self._appends.get(k, ()))
  141: 
  142:     def __iter__(self) -> Iterator[KT]:
  143:         more = (k for k in self._appends if k not in self._mapping)
  144:         return itertools.chain(self._mapping, more)
  145: 
  146:     def __len__(self) -> int:
  147:         more = sum(1 for k in self._appends if k not in self._mapping)
  148:         return len(self._mapping) + more
  149: 
  150: 
  151: class _FactoryIterableView(Iterable[RT]):
  152:     """Wrap an iterator factory returned by `find_matches()`.
  153: 
  154:     Calling `iter()` on this class would invoke the underlying iterator
  155:     factory, making it a "collection with ordering" that can be iterated
  156:     through multiple times, but lacks random access methods presented in
  157:     built-in Python sequence types.
  158:     """
  159: 
  160:     def __init__(self, factory: Callable[[], Iterable[RT]]) -> None:
  161:         self._factory = factory
  162:         self._iterable: Iterable[RT] | None = None
  163: 
  164:     def __repr__(self) -> str:
  165:         return f"{type(self).__name__}({list(self)})"
  166: 
  167:     def __bool__(self) -> bool:
  168:         try:
  169:             next(iter(self))
  170:         except StopIteration:
  171:             return False
  172:         return True
  173: 
  174:     def __iter__(self) -> Iterator[RT]:
  175:         iterable = self._factory() if self._iterable is None else self._iterable
  176:         self._iterable, current = itertools.tee(iterable)
  177:         return current
  178: 
  179: 
  180: class _SequenceIterableView(Iterable[RT]):
  181:     """Wrap an iterable returned by find_matches().
  182: 
  183:     This is essentially just a proxy to the underlying sequence that provides
  184:     the same interface as `_FactoryIterableView`.
  185:     """
  186: 
  187:     def __init__(self, sequence: Sequence[RT]):
  188:         self._sequence = sequence
  189: 
  190:     def __repr__(self) -> str:
  191:         return f"{type(self).__name__}({self._sequence})"
  192: 
  193:     def __bool__(self) -> bool:
  194:         return bool(self._sequence)
  195: 
  196:     def __iter__(self) -> Iterator[RT]:
  197:         return iter(self._sequence)
  198: 
  199: 
  200: def build_iter_view(matches: Matches[CT]) -> Iterable[CT]:
  201:     """Build an iterable view from the value returned by `find_matches()`."""
  202:     if callable(matches):
  203:         return _FactoryIterableView(matches)
  204:     if not isinstance(matches, Sequence):
  205:         matches = list(matches)
  206:     return _SequenceIterableView(matches)
  207: 
  208: 
  209: IterableView = Iterable
