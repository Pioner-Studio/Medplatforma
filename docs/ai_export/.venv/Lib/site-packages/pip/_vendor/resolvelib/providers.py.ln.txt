    1: from __future__ import annotations
    2: 
    3: from typing import (
    4:     TYPE_CHECKING,
    5:     Generic,
    6:     Iterable,
    7:     Iterator,
    8:     Mapping,
    9:     Sequence,
   10: )
   11: 
   12: from .structs import CT, KT, RT, Matches, RequirementInformation
   13: 
   14: if TYPE_CHECKING:
   15:     from typing import Any, Protocol
   16: 
   17:     class Preference(Protocol):
   18:         def __lt__(self, __other: Any) -> bool: ...
   19: 
   20: 
   21: class AbstractProvider(Generic[RT, CT, KT]):
   22:     """Delegate class to provide the required interface for the resolver."""
   23: 
   24:     def identify(self, requirement_or_candidate: RT | CT) -> KT:
   25:         """Given a requirement or candidate, return an identifier for it.
   26: 
   27:         This is used to identify, e.g. whether two requirements
   28:         should have their specifier parts merged or a candidate matches a
   29:         requirement via ``find_matches()``.
   30:         """
   31:         raise NotImplementedError
   32: 
   33:     def get_preference(
   34:         self,
   35:         identifier: KT,
   36:         resolutions: Mapping[KT, CT],
   37:         candidates: Mapping[KT, Iterator[CT]],
   38:         information: Mapping[KT, Iterator[RequirementInformation[RT, CT]]],
   39:         backtrack_causes: Sequence[RequirementInformation[RT, CT]],
   40:     ) -> Preference:
   41:         """Produce a sort key for given requirement based on preference.
   42: 
   43:         As this is a sort key it will be called O(n) times per backtrack
   44:         step, where n is the number of `identifier`s, if you have a check
   45:         which is expensive in some sense. E.g. It needs to make O(n) checks
   46:         per call or takes significant wall clock time, consider using
   47:         `narrow_requirement_selection` to filter the `identifier`s, which
   48:         is applied before this sort key is called.
   49: 
   50:         The preference is defined as "I think this requirement should be
   51:         resolved first". The lower the return value is, the more preferred
   52:         this group of arguments is.
   53: 
   54:         :param identifier: An identifier as returned by ``identify()``. This
   55:             identifies the requirement being considered.
   56:         :param resolutions: Mapping of candidates currently pinned by the
   57:             resolver. Each key is an identifier, and the value is a candidate.
   58:             The candidate may conflict with requirements from ``information``.
   59:         :param candidates: Mapping of each dependency's possible candidates.
   60:             Each value is an iterator of candidates.
   61:         :param information: Mapping of requirement information of each package.
   62:             Each value is an iterator of *requirement information*.
   63:         :param backtrack_causes: Sequence of *requirement information* that are
   64:             the requirements that caused the resolver to most recently
   65:             backtrack.
   66: 
   67:         A *requirement information* instance is a named tuple with two members:
   68: 
   69:         * ``requirement`` specifies a requirement contributing to the current
   70:           list of candidates.
   71:         * ``parent`` specifies the candidate that provides (depended on) the
   72:           requirement, or ``None`` to indicate a root requirement.
   73: 
   74:         The preference could depend on various issues, including (not
   75:         necessarily in this order):
   76: 
   77:         * Is this package pinned in the current resolution result?
   78:         * How relaxed is the requirement? Stricter ones should probably be
   79:           worked on first? (I don't know, actually.)
   80:         * How many possibilities are there to satisfy this requirement? Those
   81:           with few left should likely be worked on first, I guess?
   82:         * Are there any known conflicts for this requirement? We should
   83:           probably work on those with the most known conflicts.
   84: 
   85:         A sortable value should be returned (this will be used as the ``key``
   86:         parameter of the built-in sorting function). The smaller the value is,
   87:         the more preferred this requirement is (i.e. the sorting function
   88:         is called with ``reverse=False``).
   89:         """
   90:         raise NotImplementedError
   91: 
   92:     def find_matches(
   93:         self,
   94:         identifier: KT,
   95:         requirements: Mapping[KT, Iterator[RT]],
   96:         incompatibilities: Mapping[KT, Iterator[CT]],
   97:     ) -> Matches[CT]:
   98:         """Find all possible candidates that satisfy the given constraints.
   99: 
  100:         :param identifier: An identifier as returned by ``identify()``. All
  101:             candidates returned by this method should produce the same
  102:             identifier.
  103:         :param requirements: A mapping of requirements that all returned
  104:             candidates must satisfy. Each key is an identifier, and the value
  105:             an iterator of requirements for that dependency.
  106:         :param incompatibilities: A mapping of known incompatibile candidates of
  107:             each dependency. Each key is an identifier, and the value an
  108:             iterator of incompatibilities known to the resolver. All
  109:             incompatibilities *must* be excluded from the return value.
  110: 
  111:         This should try to get candidates based on the requirements' types.
  112:         For VCS, local, and archive requirements, the one-and-only match is
  113:         returned, and for a "named" requirement, the index(es) should be
  114:         consulted to find concrete candidates for this requirement.
  115: 
  116:         The return value should produce candidates ordered by preference; the
  117:         most preferred candidate should come first. The return type may be one
  118:         of the following:
  119: 
  120:         * A callable that returns an iterator that yields candidates.
  121:         * An collection of candidates.
  122:         * An iterable of candidates. This will be consumed immediately into a
  123:           list of candidates.
  124:         """
  125:         raise NotImplementedError
  126: 
  127:     def is_satisfied_by(self, requirement: RT, candidate: CT) -> bool:
  128:         """Whether the given requirement can be satisfied by a candidate.
  129: 
  130:         The candidate is guaranteed to have been generated from the
  131:         requirement.
  132: 
  133:         A boolean should be returned to indicate whether ``candidate`` is a
  134:         viable solution to the requirement.
  135:         """
  136:         raise NotImplementedError
  137: 
  138:     def get_dependencies(self, candidate: CT) -> Iterable[RT]:
  139:         """Get dependencies of a candidate.
  140: 
  141:         This should return a collection of requirements that `candidate`
  142:         specifies as its dependencies.
  143:         """
  144:         raise NotImplementedError
  145: 
  146:     def narrow_requirement_selection(
  147:         self,
  148:         identifiers: Iterable[KT],
  149:         resolutions: Mapping[KT, CT],
  150:         candidates: Mapping[KT, Iterator[CT]],
  151:         information: Mapping[KT, Iterator[RequirementInformation[RT, CT]]],
  152:         backtrack_causes: Sequence[RequirementInformation[RT, CT]],
  153:     ) -> Iterable[KT]:
  154:         """
  155:         An optional method to narrow the selection of requirements being
  156:         considered during resolution. This method is called O(1) time per
  157:         backtrack step.
  158: 
  159:         :param identifiers: An iterable of `identifiers` as returned by
  160:             ``identify()``. These identify all requirements currently being
  161:             considered.
  162:         :param resolutions: A mapping of candidates currently pinned by the
  163:             resolver. Each key is an identifier, and the value is a candidate
  164:             that may conflict with requirements from ``information``.
  165:         :param candidates: A mapping of each dependency's possible candidates.
  166:             Each value is an iterator of candidates.
  167:         :param information: A mapping of requirement information for each package.
  168:             Each value is an iterator of *requirement information*.
  169:         :param backtrack_causes: A sequence of *requirement information* that are
  170:             the requirements causing the resolver to most recently
  171:             backtrack.
  172: 
  173:         A *requirement information* instance is a named tuple with two members:
  174: 
  175:         * ``requirement`` specifies a requirement contributing to the current
  176:           list of candidates.
  177:         * ``parent`` specifies the candidate that provides (is depended on for)
  178:           the requirement, or ``None`` to indicate a root requirement.
  179: 
  180:         Must return a non-empty subset of `identifiers`, with the default
  181:         implementation being to return `identifiers` unchanged. Those `identifiers`
  182:         will then be passed to the sort key `get_preference` to pick the most
  183:         prefered requirement to attempt to pin, unless `narrow_requirement_selection`
  184:         returns only 1 requirement, in which case that will be used without
  185:         calling the sort key `get_preference`.
  186: 
  187:         This method is designed to be used by the provider to optimize the
  188:         dependency resolution, e.g. if a check cost is O(m) and it can be done
  189:         against all identifiers at once then filtering the requirement selection
  190:         here will cost O(m) but making it part of the sort key in `get_preference`
  191:         will cost O(m*n), where n is the number of `identifiers`.
  192: 
  193:         Returns:
  194:             Iterable[KT]: A non-empty subset of `identifiers`.
  195:         """
  196:         return identifiers
