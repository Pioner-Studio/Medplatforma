    1: """PEP 656 support.
    2: 
    3: This module implements logic to detect if the currently running Python is
    4: linked against musl, and what musl version is used.
    5: """
    6: 
    7: from __future__ import annotations
    8: 
    9: import functools
   10: import re
   11: import subprocess
   12: import sys
   13: from typing import Iterator, NamedTuple, Sequence
   14: 
   15: from ._elffile import ELFFile
   16: 
   17: 
   18: class _MuslVersion(NamedTuple):
   19:     major: int
   20:     minor: int
   21: 
   22: 
   23: def _parse_musl_version(output: str) -> _MuslVersion | None:
   24:     lines = [n for n in (n.strip() for n in output.splitlines()) if n]
   25:     if len(lines) < 2 or lines[0][:4] != "musl":
   26:         return None
   27:     m = re.match(r"Version (\d+)\.(\d+)", lines[1])
   28:     if not m:
   29:         return None
   30:     return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))
   31: 
   32: 
   33: @functools.lru_cache
   34: def _get_musl_version(executable: str) -> _MuslVersion | None:
   35:     """Detect currently-running musl runtime version.
   36: 
   37:     This is done by checking the specified executable's dynamic linking
   38:     information, and invoking the loader to parse its output for a version
   39:     string. If the loader is musl, the output would be something like::
   40: 
   41:         musl libc (x86_64)
   42:         Version 1.2.2
   43:         Dynamic Program Loader
   44:     """
   45:     try:
   46:         with open(executable, "rb") as f:
   47:             ld = ELFFile(f).interpreter
   48:     except (OSError, TypeError, ValueError):
   49:         return None
   50:     if ld is None or "musl" not in ld:
   51:         return None
   52:     proc = subprocess.run([ld], stderr=subprocess.PIPE, text=True)
   53:     return _parse_musl_version(proc.stderr)
   54: 
   55: 
   56: def platform_tags(archs: Sequence[str]) -> Iterator[str]:
   57:     """Generate musllinux tags compatible to the current platform.
   58: 
   59:     :param archs: Sequence of compatible architectures.
   60:         The first one shall be the closest to the actual architecture and be the part of
   61:         platform tag after the ``linux_`` prefix, e.g. ``x86_64``.
   62:         The ``linux_`` prefix is assumed as a prerequisite for the current platform to
   63:         be musllinux-compatible.
   64: 
   65:     :returns: An iterator of compatible musllinux tags.
   66:     """
   67:     sys_musl = _get_musl_version(sys.executable)
   68:     if sys_musl is None:  # Python not dynamically linked against musl.
   69:         return
   70:     for arch in archs:
   71:         for minor in range(sys_musl.minor, -1, -1):
   72:             yield f"musllinux_{sys_musl.major}_{minor}_{arch}"
   73: 
   74: 
   75: if __name__ == "__main__":  # pragma: no cover
   76:     import sysconfig
   77: 
   78:     plat = sysconfig.get_platform()
   79:     assert plat.startswith("linux-"), "not linux"
   80: 
   81:     print("plat:", plat)
   82:     print("musl:", _get_musl_version(sys.executable))
   83:     print("tags:", end=" ")
   84:     for t in platform_tags(re.sub(r"[.-]", "_", plat.split("-", 1)[-1])):
   85:         print(t, end="\n      ")
