    1: # This file is dual licensed under the terms of the Apache License, Version
    2: # 2.0, and the BSD License. See the LICENSE file in the root of this repository
    3: # for complete details.
    4: 
    5: from __future__ import annotations
    6: 
    7: import operator
    8: import os
    9: import platform
   10: import sys
   11: from typing import AbstractSet, Any, Callable, Literal, TypedDict, Union, cast
   12: 
   13: from ._parser import MarkerAtom, MarkerList, Op, Value, Variable
   14: from ._parser import parse_marker as _parse_marker
   15: from ._tokenizer import ParserSyntaxError
   16: from .specifiers import InvalidSpecifier, Specifier
   17: from .utils import canonicalize_name
   18: 
   19: __all__ = [
   20:     "EvaluateContext",
   21:     "InvalidMarker",
   22:     "Marker",
   23:     "UndefinedComparison",
   24:     "UndefinedEnvironmentName",
   25:     "default_environment",
   26: ]
   27: 
   28: Operator = Callable[[str, Union[str, AbstractSet[str]]], bool]
   29: EvaluateContext = Literal["metadata", "lock_file", "requirement"]
   30: MARKERS_ALLOWING_SET = {"extras", "dependency_groups"}
   31: 
   32: 
   33: class InvalidMarker(ValueError):
   34:     """
   35:     An invalid marker was found, users should refer to PEP 508.
   36:     """
   37: 
   38: 
   39: class UndefinedComparison(ValueError):
   40:     """
   41:     An invalid operation was attempted on a value that doesn't support it.
   42:     """
   43: 
   44: 
   45: class UndefinedEnvironmentName(ValueError):
   46:     """
   47:     A name was attempted to be used that does not exist inside of the
   48:     environment.
   49:     """
   50: 
   51: 
   52: class Environment(TypedDict):
   53:     implementation_name: str
   54:     """The implementation's identifier, e.g. ``'cpython'``."""
   55: 
   56:     implementation_version: str
   57:     """
   58:     The implementation's version, e.g. ``'3.13.0a2'`` for CPython 3.13.0a2, or
   59:     ``'7.3.13'`` for PyPy3.10 v7.3.13.
   60:     """
   61: 
   62:     os_name: str
   63:     """
   64:     The value of :py:data:`os.name`. The name of the operating system dependent module
   65:     imported, e.g. ``'posix'``.
   66:     """
   67: 
   68:     platform_machine: str
   69:     """
   70:     Returns the machine type, e.g. ``'i386'``.
   71: 
   72:     An empty string if the value cannot be determined.
   73:     """
   74: 
   75:     platform_release: str
   76:     """
   77:     The system's release, e.g. ``'2.2.0'`` or ``'NT'``.
   78: 
   79:     An empty string if the value cannot be determined.
   80:     """
   81: 
   82:     platform_system: str
   83:     """
   84:     The system/OS name, e.g. ``'Linux'``, ``'Windows'`` or ``'Java'``.
   85: 
   86:     An empty string if the value cannot be determined.
   87:     """
   88: 
   89:     platform_version: str
   90:     """
   91:     The system's release version, e.g. ``'#3 on degas'``.
   92: 
   93:     An empty string if the value cannot be determined.
   94:     """
   95: 
   96:     python_full_version: str
   97:     """
   98:     The Python version as string ``'major.minor.patchlevel'``.
   99: 
  100:     Note that unlike the Python :py:data:`sys.version`, this value will always include
  101:     the patchlevel (it defaults to 0).
  102:     """
  103: 
  104:     platform_python_implementation: str
  105:     """
  106:     A string identifying the Python implementation, e.g. ``'CPython'``.
  107:     """
  108: 
  109:     python_version: str
  110:     """The Python version as string ``'major.minor'``."""
  111: 
  112:     sys_platform: str
  113:     """
  114:     This string contains a platform identifier that can be used to append
  115:     platform-specific components to :py:data:`sys.path`, for instance.
  116: 
  117:     For Unix systems, except on Linux and AIX, this is the lowercased OS name as
  118:     returned by ``uname -s`` with the first part of the version as returned by
  119:     ``uname -r`` appended, e.g. ``'sunos5'`` or ``'freebsd8'``, at the time when Python
  120:     was built.
  121:     """
  122: 
  123: 
  124: def _normalize_extra_values(results: Any) -> Any:
  125:     """
  126:     Normalize extra values.
  127:     """
  128:     if isinstance(results[0], tuple):
  129:         lhs, op, rhs = results[0]
  130:         if isinstance(lhs, Variable) and lhs.value == "extra":
  131:             normalized_extra = canonicalize_name(rhs.value)
  132:             rhs = Value(normalized_extra)
  133:         elif isinstance(rhs, Variable) and rhs.value == "extra":
  134:             normalized_extra = canonicalize_name(lhs.value)
  135:             lhs = Value(normalized_extra)
  136:         results[0] = lhs, op, rhs
  137:     return results
  138: 
  139: 
  140: def _format_marker(
  141:     marker: list[str] | MarkerAtom | str, first: bool | None = True
  142: ) -> str:
  143:     assert isinstance(marker, (list, tuple, str))
  144: 
  145:     # Sometimes we have a structure like [[...]] which is a single item list
  146:     # where the single item is itself it's own list. In that case we want skip
  147:     # the rest of this function so that we don't get extraneous () on the
  148:     # outside.
  149:     if (
  150:         isinstance(marker, list)
  151:         and len(marker) == 1
  152:         and isinstance(marker[0], (list, tuple))
  153:     ):
  154:         return _format_marker(marker[0])
  155: 
  156:     if isinstance(marker, list):
  157:         inner = (_format_marker(m, first=False) for m in marker)
  158:         if first:
  159:             return " ".join(inner)
  160:         else:
  161:             return "(" + " ".join(inner) + ")"
  162:     elif isinstance(marker, tuple):
  163:         return " ".join([m.serialize() for m in marker])
  164:     else:
  165:         return marker
  166: 
  167: 
  168: _operators: dict[str, Operator] = {
  169:     "in": lambda lhs, rhs: lhs in rhs,
  170:     "not in": lambda lhs, rhs: lhs not in rhs,
  171:     "<": operator.lt,
  172:     "<=": operator.le,
  173:     "==": operator.eq,
  174:     "!=": operator.ne,
  175:     ">=": operator.ge,
  176:     ">": operator.gt,
  177: }
  178: 
  179: 
  180: def _eval_op(lhs: str, op: Op, rhs: str | AbstractSet[str]) -> bool:
  181:     if isinstance(rhs, str):
  182:         try:
  183:             spec = Specifier("".join([op.serialize(), rhs]))
  184:         except InvalidSpecifier:
  185:             pass
  186:         else:
  187:             return spec.contains(lhs, prereleases=True)
  188: 
  189:     oper: Operator | None = _operators.get(op.serialize())
  190:     if oper is None:
  191:         raise UndefinedComparison(f"Undefined {op!r} on {lhs!r} and {rhs!r}.")
  192: 
  193:     return oper(lhs, rhs)
  194: 
  195: 
  196: def _normalize(
  197:     lhs: str, rhs: str | AbstractSet[str], key: str
  198: ) -> tuple[str, str | AbstractSet[str]]:
  199:     # PEP 685 вЂ“ Comparison of extra names for optional distribution dependencies
  200:     # https://peps.python.org/pep-0685/
  201:     # > When comparing extra names, tools MUST normalize the names being
  202:     # > compared using the semantics outlined in PEP 503 for names
  203:     if key == "extra":
  204:         assert isinstance(rhs, str), "extra value must be a string"
  205:         return (canonicalize_name(lhs), canonicalize_name(rhs))
  206:     if key in MARKERS_ALLOWING_SET:
  207:         if isinstance(rhs, str):  # pragma: no cover
  208:             return (canonicalize_name(lhs), canonicalize_name(rhs))
  209:         else:
  210:             return (canonicalize_name(lhs), {canonicalize_name(v) for v in rhs})
  211: 
  212:     # other environment markers don't have such standards
  213:     return lhs, rhs
  214: 
  215: 
  216: def _evaluate_markers(
  217:     markers: MarkerList, environment: dict[str, str | AbstractSet[str]]
  218: ) -> bool:
  219:     groups: list[list[bool]] = [[]]
  220: 
  221:     for marker in markers:
  222:         assert isinstance(marker, (list, tuple, str))
  223: 
  224:         if isinstance(marker, list):
  225:             groups[-1].append(_evaluate_markers(marker, environment))
  226:         elif isinstance(marker, tuple):
  227:             lhs, op, rhs = marker
  228: 
  229:             if isinstance(lhs, Variable):
  230:                 environment_key = lhs.value
  231:                 lhs_value = environment[environment_key]
  232:                 rhs_value = rhs.value
  233:             else:
  234:                 lhs_value = lhs.value
  235:                 environment_key = rhs.value
  236:                 rhs_value = environment[environment_key]
  237:             assert isinstance(lhs_value, str), "lhs must be a string"
  238:             lhs_value, rhs_value = _normalize(lhs_value, rhs_value, key=environment_key)
  239:             groups[-1].append(_eval_op(lhs_value, op, rhs_value))
  240:         else:
  241:             assert marker in ["and", "or"]
  242:             if marker == "or":
  243:                 groups.append([])
  244: 
  245:     return any(all(item) for item in groups)
  246: 
  247: 
  248: def format_full_version(info: sys._version_info) -> str:
  249:     version = f"{info.major}.{info.minor}.{info.micro}"
  250:     kind = info.releaselevel
  251:     if kind != "final":
  252:         version += kind[0] + str(info.serial)
  253:     return version
  254: 
  255: 
  256: def default_environment() -> Environment:
  257:     iver = format_full_version(sys.implementation.version)
  258:     implementation_name = sys.implementation.name
  259:     return {
  260:         "implementation_name": implementation_name,
  261:         "implementation_version": iver,
  262:         "os_name": os.name,
  263:         "platform_machine": platform.machine(),
  264:         "platform_release": platform.release(),
  265:         "platform_system": platform.system(),
  266:         "platform_version": platform.version(),
  267:         "python_full_version": platform.python_version(),
  268:         "platform_python_implementation": platform.python_implementation(),
  269:         "python_version": ".".join(platform.python_version_tuple()[:2]),
  270:         "sys_platform": sys.platform,
  271:     }
  272: 
  273: 
  274: class Marker:
  275:     def __init__(self, marker: str) -> None:
  276:         # Note: We create a Marker object without calling this constructor in
  277:         #       packaging.requirements.Requirement. If any additional logic is
  278:         #       added here, make sure to mirror/adapt Requirement.
  279:         try:
  280:             self._markers = _normalize_extra_values(_parse_marker(marker))
  281:             # The attribute `_markers` can be described in terms of a recursive type:
  282:             # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]
  283:             #
  284:             # For example, the following expression:
  285:             # python_version > "3.6" or (python_version == "3.6" and os_name == "unix")
  286:             #
  287:             # is parsed into:
  288:             # [
  289:             #     (<Variable('python_version')>, <Op('>')>, <Value('3.6')>),
  290:             #     'and',
  291:             #     [
  292:             #         (<Variable('python_version')>, <Op('==')>, <Value('3.6')>),
  293:             #         'or',
  294:             #         (<Variable('os_name')>, <Op('==')>, <Value('unix')>)
  295:             #     ]
  296:             # ]
  297:         except ParserSyntaxError as e:
  298:             raise InvalidMarker(str(e)) from e
  299: 
  300:     def __str__(self) -> str:
  301:         return _format_marker(self._markers)
  302: 
  303:     def __repr__(self) -> str:
  304:         return f"<Marker('{self}')>"
  305: 
  306:     def __hash__(self) -> int:
  307:         return hash((self.__class__.__name__, str(self)))
  308: 
  309:     def __eq__(self, other: Any) -> bool:
  310:         if not isinstance(other, Marker):
  311:             return NotImplemented
  312: 
  313:         return str(self) == str(other)
  314: 
  315:     def evaluate(
  316:         self,
  317:         environment: dict[str, str] | None = None,
  318:         context: EvaluateContext = "metadata",
  319:     ) -> bool:
  320:         """Evaluate a marker.
  321: 
  322:         Return the boolean from evaluating the given marker against the
  323:         environment. environment is an optional argument to override all or
  324:         part of the determined environment. The *context* parameter specifies what
  325:         context the markers are being evaluated for, which influences what markers
  326:         are considered valid. Acceptable values are "metadata" (for core metadata;
  327:         default), "lock_file", and "requirement" (i.e. all other situations).
  328: 
  329:         The environment is determined from the current Python process.
  330:         """
  331:         current_environment = cast(
  332:             "dict[str, str | AbstractSet[str]]", default_environment()
  333:         )
  334:         if context == "lock_file":
  335:             current_environment.update(
  336:                 extras=frozenset(), dependency_groups=frozenset()
  337:             )
  338:         elif context == "metadata":
  339:             current_environment["extra"] = ""
  340:         if environment is not None:
  341:             current_environment.update(environment)
  342:             # The API used to allow setting extra to None. We need to handle this
  343:             # case for backwards compatibility.
  344:             if "extra" in current_environment and current_environment["extra"] is None:
  345:                 current_environment["extra"] = ""
  346: 
  347:         return _evaluate_markers(
  348:             self._markers, _repair_python_full_version(current_environment)
  349:         )
  350: 
  351: 
  352: def _repair_python_full_version(
  353:     env: dict[str, str | AbstractSet[str]],
  354: ) -> dict[str, str | AbstractSet[str]]:
  355:     """
  356:     Work around platform.python_version() returning something that is not PEP 440
  357:     compliant for non-tagged Python builds.
  358:     """
  359:     python_full_version = cast(str, env["python_full_version"])
  360:     if python_full_version.endswith("+"):
  361:         env["python_full_version"] = f"{python_full_version}local"
  362:     return env
