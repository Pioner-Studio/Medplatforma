    1: """
    2: ELF file parser.
    3: 
    4: This provides a class ``ELFFile`` that parses an ELF executable in a similar
    5: interface to ``ZipFile``. Only the read interface is implemented.
    6: 
    7: Based on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca
    8: ELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html
    9: """
   10: 
   11: from __future__ import annotations
   12: 
   13: import enum
   14: import os
   15: import struct
   16: from typing import IO
   17: 
   18: 
   19: class ELFInvalid(ValueError):
   20:     pass
   21: 
   22: 
   23: class EIClass(enum.IntEnum):
   24:     C32 = 1
   25:     C64 = 2
   26: 
   27: 
   28: class EIData(enum.IntEnum):
   29:     Lsb = 1
   30:     Msb = 2
   31: 
   32: 
   33: class EMachine(enum.IntEnum):
   34:     I386 = 3
   35:     S390 = 22
   36:     Arm = 40
   37:     X8664 = 62
   38:     AArc64 = 183
   39: 
   40: 
   41: class ELFFile:
   42:     """
   43:     Representation of an ELF executable.
   44:     """
   45: 
   46:     def __init__(self, f: IO[bytes]) -> None:
   47:         self._f = f
   48: 
   49:         try:
   50:             ident = self._read("16B")
   51:         except struct.error as e:
   52:             raise ELFInvalid("unable to parse identification") from e
   53:         magic = bytes(ident[:4])
   54:         if magic != b"\x7fELF":
   55:             raise ELFInvalid(f"invalid magic: {magic!r}")
   56: 
   57:         self.capacity = ident[4]  # Format for program header (bitness).
   58:         self.encoding = ident[5]  # Data structure encoding (endianness).
   59: 
   60:         try:
   61:             # e_fmt: Format for program header.
   62:             # p_fmt: Format for section header.
   63:             # p_idx: Indexes to find p_type, p_offset, and p_filesz.
   64:             e_fmt, self._p_fmt, self._p_idx = {
   65:                 (1, 1): ("<HHIIIIIHHH", "<IIIIIIII", (0, 1, 4)),  # 32-bit LSB.
   66:                 (1, 2): (">HHIIIIIHHH", ">IIIIIIII", (0, 1, 4)),  # 32-bit MSB.
   67:                 (2, 1): ("<HHIQQQIHHH", "<IIQQQQQQ", (0, 2, 5)),  # 64-bit LSB.
   68:                 (2, 2): (">HHIQQQIHHH", ">IIQQQQQQ", (0, 2, 5)),  # 64-bit MSB.
   69:             }[(self.capacity, self.encoding)]
   70:         except KeyError as e:
   71:             raise ELFInvalid(
   72:                 f"unrecognized capacity ({self.capacity}) or encoding ({self.encoding})"
   73:             ) from e
   74: 
   75:         try:
   76:             (
   77:                 _,
   78:                 self.machine,  # Architecture type.
   79:                 _,
   80:                 _,
   81:                 self._e_phoff,  # Offset of program header.
   82:                 _,
   83:                 self.flags,  # Processor-specific flags.
   84:                 _,
   85:                 self._e_phentsize,  # Size of section.
   86:                 self._e_phnum,  # Number of sections.
   87:             ) = self._read(e_fmt)
   88:         except struct.error as e:
   89:             raise ELFInvalid("unable to parse machine and section information") from e
   90: 
   91:     def _read(self, fmt: str) -> tuple[int, ...]:
   92:         return struct.unpack(fmt, self._f.read(struct.calcsize(fmt)))
   93: 
   94:     @property
   95:     def interpreter(self) -> str | None:
   96:         """
   97:         The path recorded in the ``PT_INTERP`` section header.
   98:         """
   99:         for index in range(self._e_phnum):
  100:             self._f.seek(self._e_phoff + self._e_phentsize * index)
  101:             try:
  102:                 data = self._read(self._p_fmt)
  103:             except struct.error:
  104:                 continue
  105:             if data[self._p_idx[0]] != 3:  # Not PT_INTERP.
  106:                 continue
  107:             self._f.seek(data[self._p_idx[1]])
  108:             return os.fsdecode(self._f.read(data[self._p_idx[2]])).strip("\0")
  109:         return None
