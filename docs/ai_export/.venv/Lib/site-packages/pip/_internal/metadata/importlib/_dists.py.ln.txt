    1: from __future__ import annotations
    2: 
    3: import email.message
    4: import importlib.metadata
    5: import pathlib
    6: import zipfile
    7: from collections.abc import Collection, Iterable, Iterator, Mapping, Sequence
    8: from os import PathLike
    9: from typing import (
   10:     cast,
   11: )
   12: 
   13: from pip._vendor.packaging.requirements import Requirement
   14: from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
   15: from pip._vendor.packaging.version import Version
   16: from pip._vendor.packaging.version import parse as parse_version
   17: 
   18: from pip._internal.exceptions import InvalidWheel, UnsupportedWheel
   19: from pip._internal.metadata.base import (
   20:     BaseDistribution,
   21:     BaseEntryPoint,
   22:     InfoPath,
   23:     Wheel,
   24: )
   25: from pip._internal.utils.misc import normalize_path
   26: from pip._internal.utils.packaging import get_requirement
   27: from pip._internal.utils.temp_dir import TempDirectory
   28: from pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file
   29: 
   30: from ._compat import (
   31:     BasePath,
   32:     get_dist_canonical_name,
   33:     parse_name_and_version_from_info_directory,
   34: )
   35: 
   36: 
   37: class WheelDistribution(importlib.metadata.Distribution):
   38:     """An ``importlib.metadata.Distribution`` read from a wheel.
   39: 
   40:     Although ``importlib.metadata.PathDistribution`` accepts ``zipfile.Path``,
   41:     its implementation is too "lazy" for pip's needs (we can't keep the ZipFile
   42:     handle open for the entire lifetime of the distribution object).
   43: 
   44:     This implementation eagerly reads the entire metadata directory into the
   45:     memory instead, and operates from that.
   46:     """
   47: 
   48:     def __init__(
   49:         self,
   50:         files: Mapping[pathlib.PurePosixPath, bytes],
   51:         info_location: pathlib.PurePosixPath,
   52:     ) -> None:
   53:         self._files = files
   54:         self.info_location = info_location
   55: 
   56:     @classmethod
   57:     def from_zipfile(
   58:         cls,
   59:         zf: zipfile.ZipFile,
   60:         name: str,
   61:         location: str,
   62:     ) -> WheelDistribution:
   63:         info_dir, _ = parse_wheel(zf, name)
   64:         paths = (
   65:             (name, pathlib.PurePosixPath(name.split("/", 1)[-1]))
   66:             for name in zf.namelist()
   67:             if name.startswith(f"{info_dir}/")
   68:         )
   69:         files = {
   70:             relpath: read_wheel_metadata_file(zf, fullpath)
   71:             for fullpath, relpath in paths
   72:         }
   73:         info_location = pathlib.PurePosixPath(location, info_dir)
   74:         return cls(files, info_location)
   75: 
   76:     def iterdir(self, path: InfoPath) -> Iterator[pathlib.PurePosixPath]:
   77:         # Only allow iterating through the metadata directory.
   78:         if pathlib.PurePosixPath(str(path)) in self._files:
   79:             return iter(self._files)
   80:         raise FileNotFoundError(path)
   81: 
   82:     def read_text(self, filename: str) -> str | None:
   83:         try:
   84:             data = self._files[pathlib.PurePosixPath(filename)]
   85:         except KeyError:
   86:             return None
   87:         try:
   88:             text = data.decode("utf-8")
   89:         except UnicodeDecodeError as e:
   90:             wheel = self.info_location.parent
   91:             error = f"Error decoding metadata for {wheel}: {e} in {filename} file"
   92:             raise UnsupportedWheel(error)
   93:         return text
   94: 
   95:     def locate_file(self, path: str | PathLike[str]) -> pathlib.Path:
   96:         # This method doesn't make sense for our in-memory wheel, but the API
   97:         # requires us to define it.
   98:         raise NotImplementedError
   99: 
  100: 
  101: class Distribution(BaseDistribution):
  102:     def __init__(
  103:         self,
  104:         dist: importlib.metadata.Distribution,
  105:         info_location: BasePath | None,
  106:         installed_location: BasePath | None,
  107:     ) -> None:
  108:         self._dist = dist
  109:         self._info_location = info_location
  110:         self._installed_location = installed_location
  111: 
  112:     @classmethod
  113:     def from_directory(cls, directory: str) -> BaseDistribution:
  114:         info_location = pathlib.Path(directory)
  115:         dist = importlib.metadata.Distribution.at(info_location)
  116:         return cls(dist, info_location, info_location.parent)
  117: 
  118:     @classmethod
  119:     def from_metadata_file_contents(
  120:         cls,
  121:         metadata_contents: bytes,
  122:         filename: str,
  123:         project_name: str,
  124:     ) -> BaseDistribution:
  125:         # Generate temp dir to contain the metadata file, and write the file contents.
  126:         temp_dir = pathlib.Path(
  127:             TempDirectory(kind="metadata", globally_managed=True).path
  128:         )
  129:         metadata_path = temp_dir / "METADATA"
  130:         metadata_path.write_bytes(metadata_contents)
  131:         # Construct dist pointing to the newly created directory.
  132:         dist = importlib.metadata.Distribution.at(metadata_path.parent)
  133:         return cls(dist, metadata_path.parent, None)
  134: 
  135:     @classmethod
  136:     def from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:
  137:         try:
  138:             with wheel.as_zipfile() as zf:
  139:                 dist = WheelDistribution.from_zipfile(zf, name, wheel.location)
  140:         except zipfile.BadZipFile as e:
  141:             raise InvalidWheel(wheel.location, name) from e
  142:         return cls(dist, dist.info_location, pathlib.PurePosixPath(wheel.location))
  143: 
  144:     @property
  145:     def location(self) -> str | None:
  146:         if self._info_location is None:
  147:             return None
  148:         return str(self._info_location.parent)
  149: 
  150:     @property
  151:     def info_location(self) -> str | None:
  152:         if self._info_location is None:
  153:             return None
  154:         return str(self._info_location)
  155: 
  156:     @property
  157:     def installed_location(self) -> str | None:
  158:         if self._installed_location is None:
  159:             return None
  160:         return normalize_path(str(self._installed_location))
  161: 
  162:     @property
  163:     def canonical_name(self) -> NormalizedName:
  164:         return get_dist_canonical_name(self._dist)
  165: 
  166:     @property
  167:     def version(self) -> Version:
  168:         if version := parse_name_and_version_from_info_directory(self._dist)[1]:
  169:             return parse_version(version)
  170:         return parse_version(self._dist.version)
  171: 
  172:     @property
  173:     def raw_version(self) -> str:
  174:         return self._dist.version
  175: 
  176:     def is_file(self, path: InfoPath) -> bool:
  177:         return self._dist.read_text(str(path)) is not None
  178: 
  179:     def iter_distutils_script_names(self) -> Iterator[str]:
  180:         # A distutils installation is always "flat" (not in e.g. egg form), so
  181:         # if this distribution's info location is NOT a pathlib.Path (but e.g.
  182:         # zipfile.Path), it can never contain any distutils scripts.
  183:         if not isinstance(self._info_location, pathlib.Path):
  184:             return
  185:         for child in self._info_location.joinpath("scripts").iterdir():
  186:             yield child.name
  187: 
  188:     def read_text(self, path: InfoPath) -> str:
  189:         content = self._dist.read_text(str(path))
  190:         if content is None:
  191:             raise FileNotFoundError(path)
  192:         return content
  193: 
  194:     def iter_entry_points(self) -> Iterable[BaseEntryPoint]:
  195:         # importlib.metadata's EntryPoint structure satisfies BaseEntryPoint.
  196:         return self._dist.entry_points
  197: 
  198:     def _metadata_impl(self) -> email.message.Message:
  199:         # From Python 3.10+, importlib.metadata declares PackageMetadata as the
  200:         # return type. This protocol is unfortunately a disaster now and misses
  201:         # a ton of fields that we need, including get() and get_payload(). We
  202:         # rely on the implementation that the object is actually a Message now,
  203:         # until upstream can improve the protocol. (python/cpython#94952)
  204:         return cast(email.message.Message, self._dist.metadata)
  205: 
  206:     def iter_provided_extras(self) -> Iterable[NormalizedName]:
  207:         return [
  208:             canonicalize_name(extra)
  209:             for extra in self.metadata.get_all("Provides-Extra", [])
  210:         ]
  211: 
  212:     def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:
  213:         contexts: Sequence[dict[str, str]] = [{"extra": e} for e in extras]
  214:         for req_string in self.metadata.get_all("Requires-Dist", []):
  215:             # strip() because email.message.Message.get_all() may return a leading \n
  216:             # in case a long header was wrapped.
  217:             req = get_requirement(req_string.strip())
  218:             if not req.marker:
  219:                 yield req
  220:             elif not extras and req.marker.evaluate({"extra": ""}):
  221:                 yield req
  222:             elif any(req.marker.evaluate(context) for context in contexts):
  223:                 yield req
