    1: from __future__ import annotations
    2: 
    3: import importlib.metadata
    4: import logging
    5: import os
    6: import pathlib
    7: import sys
    8: import zipfile
    9: from collections.abc import Iterator, Sequence
   10: from typing import Optional
   11: 
   12: from pip._vendor.packaging.utils import (
   13:     InvalidWheelFilename,
   14:     NormalizedName,
   15:     canonicalize_name,
   16:     parse_wheel_filename,
   17: )
   18: 
   19: from pip._internal.metadata.base import BaseDistribution, BaseEnvironment
   20: from pip._internal.utils.filetypes import WHEEL_EXTENSION
   21: 
   22: from ._compat import BadMetadata, BasePath, get_dist_canonical_name, get_info_location
   23: from ._dists import Distribution
   24: 
   25: logger = logging.getLogger(__name__)
   26: 
   27: 
   28: def _looks_like_wheel(location: str) -> bool:
   29:     if not location.endswith(WHEEL_EXTENSION):
   30:         return False
   31:     if not os.path.isfile(location):
   32:         return False
   33:     try:
   34:         parse_wheel_filename(os.path.basename(location))
   35:     except InvalidWheelFilename:
   36:         return False
   37:     return zipfile.is_zipfile(location)
   38: 
   39: 
   40: class _DistributionFinder:
   41:     """Finder to locate distributions.
   42: 
   43:     The main purpose of this class is to memoize found distributions' names, so
   44:     only one distribution is returned for each package name. At lot of pip code
   45:     assumes this (because it is setuptools's behavior), and not doing the same
   46:     can potentially cause a distribution in lower precedence path to override a
   47:     higher precedence one if the caller is not careful.
   48: 
   49:     Eventually we probably want to make it possible to see lower precedence
   50:     installations as well. It's useful feature, after all.
   51:     """
   52: 
   53:     FoundResult = tuple[importlib.metadata.Distribution, Optional[BasePath]]
   54: 
   55:     def __init__(self) -> None:
   56:         self._found_names: set[NormalizedName] = set()
   57: 
   58:     def _find_impl(self, location: str) -> Iterator[FoundResult]:
   59:         """Find distributions in a location."""
   60:         # Skip looking inside a wheel. Since a package inside a wheel is not
   61:         # always valid (due to .data directories etc.), its .dist-info entry
   62:         # should not be considered an installed distribution.
   63:         if _looks_like_wheel(location):
   64:             return
   65:         # To know exactly where we find a distribution, we have to feed in the
   66:         # paths one by one, instead of dumping the list to importlib.metadata.
   67:         for dist in importlib.metadata.distributions(path=[location]):
   68:             info_location = get_info_location(dist)
   69:             try:
   70:                 name = get_dist_canonical_name(dist)
   71:             except BadMetadata as e:
   72:                 logger.warning("Skipping %s due to %s", info_location, e.reason)
   73:                 continue
   74:             if name in self._found_names:
   75:                 continue
   76:             self._found_names.add(name)
   77:             yield dist, info_location
   78: 
   79:     def find(self, location: str) -> Iterator[BaseDistribution]:
   80:         """Find distributions in a location.
   81: 
   82:         The path can be either a directory, or a ZIP archive.
   83:         """
   84:         for dist, info_location in self._find_impl(location):
   85:             if info_location is None:
   86:                 installed_location: BasePath | None = None
   87:             else:
   88:                 installed_location = info_location.parent
   89:             yield Distribution(dist, info_location, installed_location)
   90: 
   91:     def find_legacy_editables(self, location: str) -> Iterator[BaseDistribution]:
   92:         """Read location in egg-link files and return distributions in there.
   93: 
   94:         The path should be a directory; otherwise this returns nothing. This
   95:         follows how setuptools does this for compatibility. The first non-empty
   96:         line in the egg-link is read as a path (resolved against the egg-link's
   97:         containing directory if relative). Distributions found at that linked
   98:         location are returned.
   99:         """
  100:         path = pathlib.Path(location)
  101:         if not path.is_dir():
  102:             return
  103:         for child in path.iterdir():
  104:             if child.suffix != ".egg-link":
  105:                 continue
  106:             with child.open() as f:
  107:                 lines = (line.strip() for line in f)
  108:                 target_rel = next((line for line in lines if line), "")
  109:             if not target_rel:
  110:                 continue
  111:             target_location = str(path.joinpath(target_rel))
  112:             for dist, info_location in self._find_impl(target_location):
  113:                 yield Distribution(dist, info_location, path)
  114: 
  115: 
  116: class Environment(BaseEnvironment):
  117:     def __init__(self, paths: Sequence[str]) -> None:
  118:         self._paths = paths
  119: 
  120:     @classmethod
  121:     def default(cls) -> BaseEnvironment:
  122:         return cls(sys.path)
  123: 
  124:     @classmethod
  125:     def from_paths(cls, paths: list[str] | None) -> BaseEnvironment:
  126:         if paths is None:
  127:             return cls(sys.path)
  128:         return cls(paths)
  129: 
  130:     def _iter_distributions(self) -> Iterator[BaseDistribution]:
  131:         finder = _DistributionFinder()
  132:         for location in self._paths:
  133:             yield from finder.find(location)
  134:             yield from finder.find_legacy_editables(location)
  135: 
  136:     def get_distribution(self, name: str) -> BaseDistribution | None:
  137:         canonical_name = canonicalize_name(name)
  138:         matches = (
  139:             distribution
  140:             for distribution in self.iter_all_distributions()
  141:             if distribution.canonical_name == canonical_name
  142:         )
  143:         return next(matches, None)
