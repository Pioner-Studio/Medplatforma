    1: import sys
    2: from optparse import Values
    3: from pathlib import Path
    4: 
    5: from pip._internal.cache import WheelCache
    6: from pip._internal.cli import cmdoptions
    7: from pip._internal.cli.req_command import (
    8:     RequirementCommand,
    9:     with_cleanup,
   10: )
   11: from pip._internal.cli.status_codes import SUCCESS
   12: from pip._internal.models.pylock import Pylock, is_valid_pylock_file_name
   13: from pip._internal.operations.build.build_tracker import get_build_tracker
   14: from pip._internal.req.req_install import (
   15:     check_legacy_setup_py_options,
   16: )
   17: from pip._internal.utils.logging import getLogger
   18: from pip._internal.utils.misc import (
   19:     get_pip_version,
   20: )
   21: from pip._internal.utils.temp_dir import TempDirectory
   22: 
   23: logger = getLogger(__name__)
   24: 
   25: 
   26: class LockCommand(RequirementCommand):
   27:     """
   28:     EXPERIMENTAL - Lock packages and their dependencies from:
   29: 
   30:     - PyPI (and other indexes) using requirement specifiers.
   31:     - VCS project urls.
   32:     - Local project directories.
   33:     - Local or remote source archives.
   34: 
   35:     pip also supports locking from "requirements files", which provide an easy
   36:     way to specify a whole environment to be installed.
   37: 
   38:     The generated lock file is only guaranteed to be valid for the current
   39:     python version and platform.
   40:     """
   41: 
   42:     usage = """
   43:       %prog [options] [-e] <local project path> ...
   44:       %prog [options] <requirement specifier> [package-index-options] ...
   45:       %prog [options] -r <requirements file> [package-index-options] ...
   46:       %prog [options] <archive url/path> ..."""
   47: 
   48:     def add_options(self) -> None:
   49:         self.cmd_opts.add_option(
   50:             cmdoptions.PipOption(
   51:                 "--output",
   52:                 "-o",
   53:                 dest="output_file",
   54:                 metavar="path",
   55:                 type="path",
   56:                 default="pylock.toml",
   57:                 help="Lock file name (default=pylock.toml). Use - for stdout.",
   58:             )
   59:         )
   60:         self.cmd_opts.add_option(cmdoptions.requirements())
   61:         self.cmd_opts.add_option(cmdoptions.constraints())
   62:         self.cmd_opts.add_option(cmdoptions.no_deps())
   63:         self.cmd_opts.add_option(cmdoptions.pre())
   64: 
   65:         self.cmd_opts.add_option(cmdoptions.editable())
   66: 
   67:         self.cmd_opts.add_option(cmdoptions.src())
   68: 
   69:         self.cmd_opts.add_option(cmdoptions.ignore_requires_python())
   70:         self.cmd_opts.add_option(cmdoptions.no_build_isolation())
   71:         self.cmd_opts.add_option(cmdoptions.use_pep517())
   72:         self.cmd_opts.add_option(cmdoptions.no_use_pep517())
   73:         self.cmd_opts.add_option(cmdoptions.check_build_deps())
   74: 
   75:         self.cmd_opts.add_option(cmdoptions.config_settings())
   76: 
   77:         self.cmd_opts.add_option(cmdoptions.no_binary())
   78:         self.cmd_opts.add_option(cmdoptions.only_binary())
   79:         self.cmd_opts.add_option(cmdoptions.prefer_binary())
   80:         self.cmd_opts.add_option(cmdoptions.require_hashes())
   81:         self.cmd_opts.add_option(cmdoptions.progress_bar())
   82: 
   83:         index_opts = cmdoptions.make_option_group(
   84:             cmdoptions.index_group,
   85:             self.parser,
   86:         )
   87: 
   88:         self.parser.insert_option_group(0, index_opts)
   89:         self.parser.insert_option_group(0, self.cmd_opts)
   90: 
   91:     @with_cleanup
   92:     def run(self, options: Values, args: list[str]) -> int:
   93:         logger.verbose("Using %s", get_pip_version())
   94: 
   95:         logger.warning(
   96:             "pip lock is currently an experimental command. "
   97:             "It may be removed/changed in a future release "
   98:             "without prior warning."
   99:         )
  100: 
  101:         session = self.get_default_session(options)
  102: 
  103:         finder = self._build_package_finder(
  104:             options=options,
  105:             session=session,
  106:             ignore_requires_python=options.ignore_requires_python,
  107:         )
  108:         build_tracker = self.enter_context(get_build_tracker())
  109: 
  110:         directory = TempDirectory(
  111:             delete=not options.no_clean,
  112:             kind="install",
  113:             globally_managed=True,
  114:         )
  115: 
  116:         reqs = self.get_requirements(args, options, finder, session)
  117:         check_legacy_setup_py_options(options, reqs)
  118: 
  119:         wheel_cache = WheelCache(options.cache_dir)
  120: 
  121:         # Only when installing is it permitted to use PEP 660.
  122:         # In other circumstances (pip wheel, pip download) we generate
  123:         # regular (i.e. non editable) metadata and wheels.
  124:         for req in reqs:
  125:             req.permit_editable_wheels = True
  126: 
  127:         preparer = self.make_requirement_preparer(
  128:             temp_build_dir=directory,
  129:             options=options,
  130:             build_tracker=build_tracker,
  131:             session=session,
  132:             finder=finder,
  133:             use_user_site=False,
  134:             verbosity=self.verbosity,
  135:         )
  136:         resolver = self.make_resolver(
  137:             preparer=preparer,
  138:             finder=finder,
  139:             options=options,
  140:             wheel_cache=wheel_cache,
  141:             use_user_site=False,
  142:             ignore_installed=True,
  143:             ignore_requires_python=options.ignore_requires_python,
  144:             upgrade_strategy="to-satisfy-only",
  145:             use_pep517=options.use_pep517,
  146:         )
  147: 
  148:         self.trace_basic_info(finder)
  149: 
  150:         requirement_set = resolver.resolve(reqs, check_supported_wheels=True)
  151: 
  152:         if options.output_file == "-":
  153:             base_dir = Path.cwd()
  154:         else:
  155:             output_file_path = Path(options.output_file)
  156:             if not is_valid_pylock_file_name(output_file_path):
  157:                 logger.warning(
  158:                     "%s is not a valid lock file name.",
  159:                     output_file_path,
  160:                 )
  161:             base_dir = output_file_path.parent
  162:         pylock_toml = Pylock.from_install_requirements(
  163:             requirement_set.requirements.values(), base_dir=base_dir
  164:         ).as_toml()
  165:         if options.output_file == "-":
  166:             sys.stdout.write(pylock_toml)
  167:         else:
  168:             output_file_path.write_text(pylock_toml, encoding="utf-8")
  169: 
  170:         return SUCCESS
