    1: import logging
    2: import os
    3: from optparse import Values
    4: 
    5: from pip._internal.cli import cmdoptions
    6: from pip._internal.cli.cmdoptions import make_target_python
    7: from pip._internal.cli.req_command import RequirementCommand, with_cleanup
    8: from pip._internal.cli.status_codes import SUCCESS
    9: from pip._internal.operations.build.build_tracker import get_build_tracker
   10: from pip._internal.req.req_install import check_legacy_setup_py_options
   11: from pip._internal.utils.misc import ensure_dir, normalize_path, write_output
   12: from pip._internal.utils.temp_dir import TempDirectory
   13: 
   14: logger = logging.getLogger(__name__)
   15: 
   16: 
   17: class DownloadCommand(RequirementCommand):
   18:     """
   19:     Download packages from:
   20: 
   21:     - PyPI (and other indexes) using requirement specifiers.
   22:     - VCS project urls.
   23:     - Local project directories.
   24:     - Local or remote source archives.
   25: 
   26:     pip also supports downloading from "requirements files", which provide
   27:     an easy way to specify a whole environment to be downloaded.
   28:     """
   29: 
   30:     usage = """
   31:       %prog [options] <requirement specifier> [package-index-options] ...
   32:       %prog [options] -r <requirements file> [package-index-options] ...
   33:       %prog [options] <vcs project url> ...
   34:       %prog [options] <local project path> ...
   35:       %prog [options] <archive url/path> ..."""
   36: 
   37:     def add_options(self) -> None:
   38:         self.cmd_opts.add_option(cmdoptions.constraints())
   39:         self.cmd_opts.add_option(cmdoptions.requirements())
   40:         self.cmd_opts.add_option(cmdoptions.no_deps())
   41:         self.cmd_opts.add_option(cmdoptions.global_options())
   42:         self.cmd_opts.add_option(cmdoptions.no_binary())
   43:         self.cmd_opts.add_option(cmdoptions.only_binary())
   44:         self.cmd_opts.add_option(cmdoptions.prefer_binary())
   45:         self.cmd_opts.add_option(cmdoptions.src())
   46:         self.cmd_opts.add_option(cmdoptions.pre())
   47:         self.cmd_opts.add_option(cmdoptions.require_hashes())
   48:         self.cmd_opts.add_option(cmdoptions.progress_bar())
   49:         self.cmd_opts.add_option(cmdoptions.no_build_isolation())
   50:         self.cmd_opts.add_option(cmdoptions.use_pep517())
   51:         self.cmd_opts.add_option(cmdoptions.no_use_pep517())
   52:         self.cmd_opts.add_option(cmdoptions.check_build_deps())
   53:         self.cmd_opts.add_option(cmdoptions.ignore_requires_python())
   54: 
   55:         self.cmd_opts.add_option(
   56:             "-d",
   57:             "--dest",
   58:             "--destination-dir",
   59:             "--destination-directory",
   60:             dest="download_dir",
   61:             metavar="dir",
   62:             default=os.curdir,
   63:             help="Download packages into <dir>.",
   64:         )
   65: 
   66:         cmdoptions.add_target_python_options(self.cmd_opts)
   67: 
   68:         index_opts = cmdoptions.make_option_group(
   69:             cmdoptions.index_group,
   70:             self.parser,
   71:         )
   72: 
   73:         self.parser.insert_option_group(0, index_opts)
   74:         self.parser.insert_option_group(0, self.cmd_opts)
   75: 
   76:     @with_cleanup
   77:     def run(self, options: Values, args: list[str]) -> int:
   78:         options.ignore_installed = True
   79:         # editable doesn't really make sense for `pip download`, but the bowels
   80:         # of the RequirementSet code require that property.
   81:         options.editables = []
   82: 
   83:         cmdoptions.check_dist_restriction(options)
   84: 
   85:         options.download_dir = normalize_path(options.download_dir)
   86:         ensure_dir(options.download_dir)
   87: 
   88:         session = self.get_default_session(options)
   89: 
   90:         target_python = make_target_python(options)
   91:         finder = self._build_package_finder(
   92:             options=options,
   93:             session=session,
   94:             target_python=target_python,
   95:             ignore_requires_python=options.ignore_requires_python,
   96:         )
   97: 
   98:         build_tracker = self.enter_context(get_build_tracker())
   99: 
  100:         directory = TempDirectory(
  101:             delete=not options.no_clean,
  102:             kind="download",
  103:             globally_managed=True,
  104:         )
  105: 
  106:         reqs = self.get_requirements(args, options, finder, session)
  107:         check_legacy_setup_py_options(options, reqs)
  108: 
  109:         preparer = self.make_requirement_preparer(
  110:             temp_build_dir=directory,
  111:             options=options,
  112:             build_tracker=build_tracker,
  113:             session=session,
  114:             finder=finder,
  115:             download_dir=options.download_dir,
  116:             use_user_site=False,
  117:             verbosity=self.verbosity,
  118:         )
  119: 
  120:         resolver = self.make_resolver(
  121:             preparer=preparer,
  122:             finder=finder,
  123:             options=options,
  124:             ignore_requires_python=options.ignore_requires_python,
  125:             use_pep517=options.use_pep517,
  126:             py_version_info=options.python_version,
  127:         )
  128: 
  129:         self.trace_basic_info(finder)
  130: 
  131:         requirement_set = resolver.resolve(reqs, check_supported_wheels=True)
  132: 
  133:         downloaded: list[str] = []
  134:         for req in requirement_set.requirements.values():
  135:             if req.satisfied_by is None:
  136:                 assert req.name is not None
  137:                 preparer.save_linked_requirement(req)
  138:                 downloaded.append(req.name)
  139: 
  140:         preparer.prepare_linked_requirements_more(requirement_set.requirements.values())
  141: 
  142:         if downloaded:
  143:             write_output("Successfully downloaded %s", " ".join(downloaded))
  144: 
  145:         return SUCCESS
