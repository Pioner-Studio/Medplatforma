    1: from __future__ import annotations
    2: 
    3: import json
    4: import logging
    5: from collections.abc import Iterable
    6: from optparse import Values
    7: from typing import Any, Callable
    8: 
    9: from pip._vendor.packaging.version import Version
   10: 
   11: from pip._internal.cli import cmdoptions
   12: from pip._internal.cli.req_command import IndexGroupCommand
   13: from pip._internal.cli.status_codes import ERROR, SUCCESS
   14: from pip._internal.commands.search import (
   15:     get_installed_distribution,
   16:     print_dist_installation_info,
   17: )
   18: from pip._internal.exceptions import CommandError, DistributionNotFound, PipError
   19: from pip._internal.index.collector import LinkCollector
   20: from pip._internal.index.package_finder import PackageFinder
   21: from pip._internal.models.selection_prefs import SelectionPreferences
   22: from pip._internal.models.target_python import TargetPython
   23: from pip._internal.network.session import PipSession
   24: from pip._internal.utils.misc import write_output
   25: 
   26: logger = logging.getLogger(__name__)
   27: 
   28: 
   29: class IndexCommand(IndexGroupCommand):
   30:     """
   31:     Inspect information available from package indexes.
   32:     """
   33: 
   34:     ignore_require_venv = True
   35:     usage = """
   36:         %prog versions <package>
   37:     """
   38: 
   39:     def add_options(self) -> None:
   40:         cmdoptions.add_target_python_options(self.cmd_opts)
   41: 
   42:         self.cmd_opts.add_option(cmdoptions.ignore_requires_python())
   43:         self.cmd_opts.add_option(cmdoptions.pre())
   44:         self.cmd_opts.add_option(cmdoptions.json())
   45:         self.cmd_opts.add_option(cmdoptions.no_binary())
   46:         self.cmd_opts.add_option(cmdoptions.only_binary())
   47: 
   48:         index_opts = cmdoptions.make_option_group(
   49:             cmdoptions.index_group,
   50:             self.parser,
   51:         )
   52: 
   53:         self.parser.insert_option_group(0, index_opts)
   54:         self.parser.insert_option_group(0, self.cmd_opts)
   55: 
   56:     def handler_map(self) -> dict[str, Callable[[Values, list[str]], None]]:
   57:         return {
   58:             "versions": self.get_available_package_versions,
   59:         }
   60: 
   61:     def run(self, options: Values, args: list[str]) -> int:
   62:         handler_map = self.handler_map()
   63: 
   64:         # Determine action
   65:         if not args or args[0] not in handler_map:
   66:             logger.error(
   67:                 "Need an action (%s) to perform.",
   68:                 ", ".join(sorted(handler_map)),
   69:             )
   70:             return ERROR
   71: 
   72:         action = args[0]
   73: 
   74:         # Error handling happens here, not in the action-handlers.
   75:         try:
   76:             handler_map[action](options, args[1:])
   77:         except PipError as e:
   78:             logger.error(e.args[0])
   79:             return ERROR
   80: 
   81:         return SUCCESS
   82: 
   83:     def _build_package_finder(
   84:         self,
   85:         options: Values,
   86:         session: PipSession,
   87:         target_python: TargetPython | None = None,
   88:         ignore_requires_python: bool | None = None,
   89:     ) -> PackageFinder:
   90:         """
   91:         Create a package finder appropriate to the index command.
   92:         """
   93:         link_collector = LinkCollector.create(session, options=options)
   94: 
   95:         # Pass allow_yanked=False to ignore yanked versions.
   96:         selection_prefs = SelectionPreferences(
   97:             allow_yanked=False,
   98:             allow_all_prereleases=options.pre,
   99:             ignore_requires_python=ignore_requires_python,
  100:         )
  101: 
  102:         return PackageFinder.create(
  103:             link_collector=link_collector,
  104:             selection_prefs=selection_prefs,
  105:             target_python=target_python,
  106:         )
  107: 
  108:     def get_available_package_versions(self, options: Values, args: list[Any]) -> None:
  109:         if len(args) != 1:
  110:             raise CommandError("You need to specify exactly one argument")
  111: 
  112:         target_python = cmdoptions.make_target_python(options)
  113:         query = args[0]
  114: 
  115:         with self._build_session(options) as session:
  116:             finder = self._build_package_finder(
  117:                 options=options,
  118:                 session=session,
  119:                 target_python=target_python,
  120:                 ignore_requires_python=options.ignore_requires_python,
  121:             )
  122: 
  123:             versions: Iterable[Version] = (
  124:                 candidate.version for candidate in finder.find_all_candidates(query)
  125:             )
  126: 
  127:             if not options.pre:
  128:                 # Remove prereleases
  129:                 versions = (
  130:                     version for version in versions if not version.is_prerelease
  131:                 )
  132:             versions = set(versions)
  133: 
  134:             if not versions:
  135:                 raise DistributionNotFound(
  136:                     f"No matching distribution found for {query}"
  137:                 )
  138: 
  139:             formatted_versions = [str(ver) for ver in sorted(versions, reverse=True)]
  140:             latest = formatted_versions[0]
  141: 
  142:         dist = get_installed_distribution(query)
  143: 
  144:         if options.json:
  145:             structured_output = {
  146:                 "name": query,
  147:                 "versions": formatted_versions,
  148:                 "latest": latest,
  149:             }
  150: 
  151:             if dist is not None:
  152:                 structured_output["installed_version"] = str(dist.version)
  153: 
  154:             write_output(json.dumps(structured_output))
  155: 
  156:         else:
  157:             write_output(f"{query} ({latest})")
  158:             write_output("Available versions: {}".format(", ".join(formatted_versions)))
  159:             print_dist_installation_info(latest, dist)
