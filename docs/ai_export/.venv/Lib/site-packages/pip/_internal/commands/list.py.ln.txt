    1: from __future__ import annotations
    2: 
    3: import json
    4: import logging
    5: from collections.abc import Generator, Sequence
    6: from email.parser import Parser
    7: from optparse import Values
    8: from typing import TYPE_CHECKING, cast
    9: 
   10: from pip._vendor.packaging.utils import canonicalize_name
   11: from pip._vendor.packaging.version import InvalidVersion, Version
   12: 
   13: from pip._internal.cli import cmdoptions
   14: from pip._internal.cli.index_command import IndexGroupCommand
   15: from pip._internal.cli.status_codes import SUCCESS
   16: from pip._internal.exceptions import CommandError
   17: from pip._internal.metadata import BaseDistribution, get_environment
   18: from pip._internal.models.selection_prefs import SelectionPreferences
   19: from pip._internal.utils.compat import stdlib_pkgs
   20: from pip._internal.utils.misc import tabulate, write_output
   21: 
   22: if TYPE_CHECKING:
   23:     from pip._internal.index.package_finder import PackageFinder
   24:     from pip._internal.network.session import PipSession
   25: 
   26:     class _DistWithLatestInfo(BaseDistribution):
   27:         """Give the distribution object a couple of extra fields.
   28: 
   29:         These will be populated during ``get_outdated()``. This is dirty but
   30:         makes the rest of the code much cleaner.
   31:         """
   32: 
   33:         latest_version: Version
   34:         latest_filetype: str
   35: 
   36:     _ProcessedDists = Sequence[_DistWithLatestInfo]
   37: 
   38: 
   39: logger = logging.getLogger(__name__)
   40: 
   41: 
   42: class ListCommand(IndexGroupCommand):
   43:     """
   44:     List installed packages, including editables.
   45: 
   46:     Packages are listed in a case-insensitive sorted order.
   47:     """
   48: 
   49:     ignore_require_venv = True
   50:     usage = """
   51:       %prog [options]"""
   52: 
   53:     def add_options(self) -> None:
   54:         self.cmd_opts.add_option(
   55:             "-o",
   56:             "--outdated",
   57:             action="store_true",
   58:             default=False,
   59:             help="List outdated packages",
   60:         )
   61:         self.cmd_opts.add_option(
   62:             "-u",
   63:             "--uptodate",
   64:             action="store_true",
   65:             default=False,
   66:             help="List uptodate packages",
   67:         )
   68:         self.cmd_opts.add_option(
   69:             "-e",
   70:             "--editable",
   71:             action="store_true",
   72:             default=False,
   73:             help="List editable projects.",
   74:         )
   75:         self.cmd_opts.add_option(
   76:             "-l",
   77:             "--local",
   78:             action="store_true",
   79:             default=False,
   80:             help=(
   81:                 "If in a virtualenv that has global access, do not list "
   82:                 "globally-installed packages."
   83:             ),
   84:         )
   85:         self.cmd_opts.add_option(
   86:             "--user",
   87:             dest="user",
   88:             action="store_true",
   89:             default=False,
   90:             help="Only output packages installed in user-site.",
   91:         )
   92:         self.cmd_opts.add_option(cmdoptions.list_path())
   93:         self.cmd_opts.add_option(
   94:             "--pre",
   95:             action="store_true",
   96:             default=False,
   97:             help=(
   98:                 "Include pre-release and development versions. By default, "
   99:                 "pip only finds stable versions."
  100:             ),
  101:         )
  102: 
  103:         self.cmd_opts.add_option(
  104:             "--format",
  105:             action="store",
  106:             dest="list_format",
  107:             default="columns",
  108:             choices=("columns", "freeze", "json"),
  109:             help=(
  110:                 "Select the output format among: columns (default), freeze, or json. "
  111:                 "The 'freeze' format cannot be used with the --outdated option."
  112:             ),
  113:         )
  114: 
  115:         self.cmd_opts.add_option(
  116:             "--not-required",
  117:             action="store_true",
  118:             dest="not_required",
  119:             help="List packages that are not dependencies of installed packages.",
  120:         )
  121: 
  122:         self.cmd_opts.add_option(
  123:             "--exclude-editable",
  124:             action="store_false",
  125:             dest="include_editable",
  126:             help="Exclude editable package from output.",
  127:         )
  128:         self.cmd_opts.add_option(
  129:             "--include-editable",
  130:             action="store_true",
  131:             dest="include_editable",
  132:             help="Include editable package in output.",
  133:             default=True,
  134:         )
  135:         self.cmd_opts.add_option(cmdoptions.list_exclude())
  136:         index_opts = cmdoptions.make_option_group(cmdoptions.index_group, self.parser)
  137: 
  138:         self.parser.insert_option_group(0, index_opts)
  139:         self.parser.insert_option_group(0, self.cmd_opts)
  140: 
  141:     def handle_pip_version_check(self, options: Values) -> None:
  142:         if options.outdated or options.uptodate:
  143:             super().handle_pip_version_check(options)
  144: 
  145:     def _build_package_finder(
  146:         self, options: Values, session: PipSession
  147:     ) -> PackageFinder:
  148:         """
  149:         Create a package finder appropriate to this list command.
  150:         """
  151:         # Lazy import the heavy index modules as most list invocations won't need 'em.
  152:         from pip._internal.index.collector import LinkCollector
  153:         from pip._internal.index.package_finder import PackageFinder
  154: 
  155:         link_collector = LinkCollector.create(session, options=options)
  156: 
  157:         # Pass allow_yanked=False to ignore yanked versions.
  158:         selection_prefs = SelectionPreferences(
  159:             allow_yanked=False,
  160:             allow_all_prereleases=options.pre,
  161:         )
  162: 
  163:         return PackageFinder.create(
  164:             link_collector=link_collector,
  165:             selection_prefs=selection_prefs,
  166:         )
  167: 
  168:     def run(self, options: Values, args: list[str]) -> int:
  169:         if options.outdated and options.uptodate:
  170:             raise CommandError("Options --outdated and --uptodate cannot be combined.")
  171: 
  172:         if options.outdated and options.list_format == "freeze":
  173:             raise CommandError(
  174:                 "List format 'freeze' cannot be used with the --outdated option."
  175:             )
  176: 
  177:         cmdoptions.check_list_path_option(options)
  178: 
  179:         skip = set(stdlib_pkgs)
  180:         if options.excludes:
  181:             skip.update(canonicalize_name(n) for n in options.excludes)
  182: 
  183:         packages: _ProcessedDists = [
  184:             cast("_DistWithLatestInfo", d)
  185:             for d in get_environment(options.path).iter_installed_distributions(
  186:                 local_only=options.local,
  187:                 user_only=options.user,
  188:                 editables_only=options.editable,
  189:                 include_editables=options.include_editable,
  190:                 skip=skip,
  191:             )
  192:         ]
  193: 
  194:         # get_not_required must be called firstly in order to find and
  195:         # filter out all dependencies correctly. Otherwise a package
  196:         # can't be identified as requirement because some parent packages
  197:         # could be filtered out before.
  198:         if options.not_required:
  199:             packages = self.get_not_required(packages, options)
  200: 
  201:         if options.outdated:
  202:             packages = self.get_outdated(packages, options)
  203:         elif options.uptodate:
  204:             packages = self.get_uptodate(packages, options)
  205: 
  206:         self.output_package_listing(packages, options)
  207:         return SUCCESS
  208: 
  209:     def get_outdated(
  210:         self, packages: _ProcessedDists, options: Values
  211:     ) -> _ProcessedDists:
  212:         return [
  213:             dist
  214:             for dist in self.iter_packages_latest_infos(packages, options)
  215:             if dist.latest_version > dist.version
  216:         ]
  217: 
  218:     def get_uptodate(
  219:         self, packages: _ProcessedDists, options: Values
  220:     ) -> _ProcessedDists:
  221:         return [
  222:             dist
  223:             for dist in self.iter_packages_latest_infos(packages, options)
  224:             if dist.latest_version == dist.version
  225:         ]
  226: 
  227:     def get_not_required(
  228:         self, packages: _ProcessedDists, options: Values
  229:     ) -> _ProcessedDists:
  230:         dep_keys = {
  231:             canonicalize_name(dep.name)
  232:             for dist in packages
  233:             for dep in (dist.iter_dependencies() or ())
  234:         }
  235: 
  236:         # Create a set to remove duplicate packages, and cast it to a list
  237:         # to keep the return type consistent with get_outdated and
  238:         # get_uptodate
  239:         return list({pkg for pkg in packages if pkg.canonical_name not in dep_keys})
  240: 
  241:     def iter_packages_latest_infos(
  242:         self, packages: _ProcessedDists, options: Values
  243:     ) -> Generator[_DistWithLatestInfo, None, None]:
  244:         with self._build_session(options) as session:
  245:             finder = self._build_package_finder(options, session)
  246: 
  247:             def latest_info(
  248:                 dist: _DistWithLatestInfo,
  249:             ) -> _DistWithLatestInfo | None:
  250:                 all_candidates = finder.find_all_candidates(dist.canonical_name)
  251:                 if not options.pre:
  252:                     # Remove prereleases
  253:                     all_candidates = [
  254:                         candidate
  255:                         for candidate in all_candidates
  256:                         if not candidate.version.is_prerelease
  257:                     ]
  258: 
  259:                 evaluator = finder.make_candidate_evaluator(
  260:                     project_name=dist.canonical_name,
  261:                 )
  262:                 best_candidate = evaluator.sort_best_candidate(all_candidates)
  263:                 if best_candidate is None:
  264:                     return None
  265: 
  266:                 remote_version = best_candidate.version
  267:                 if best_candidate.link.is_wheel:
  268:                     typ = "wheel"
  269:                 else:
  270:                     typ = "sdist"
  271:                 dist.latest_version = remote_version
  272:                 dist.latest_filetype = typ
  273:                 return dist
  274: 
  275:             for dist in map(latest_info, packages):
  276:                 if dist is not None:
  277:                     yield dist
  278: 
  279:     def output_package_listing(
  280:         self, packages: _ProcessedDists, options: Values
  281:     ) -> None:
  282:         packages = sorted(
  283:             packages,
  284:             key=lambda dist: dist.canonical_name,
  285:         )
  286:         if options.list_format == "columns" and packages:
  287:             data, header = format_for_columns(packages, options)
  288:             self.output_package_listing_columns(data, header)
  289:         elif options.list_format == "freeze":
  290:             for dist in packages:
  291:                 try:
  292:                     req_string = f"{dist.raw_name}=={dist.version}"
  293:                 except InvalidVersion:
  294:                     req_string = f"{dist.raw_name}==={dist.raw_version}"
  295:                 if options.verbose >= 1:
  296:                     write_output("%s (%s)", req_string, dist.location)
  297:                 else:
  298:                     write_output(req_string)
  299:         elif options.list_format == "json":
  300:             write_output(format_for_json(packages, options))
  301: 
  302:     def output_package_listing_columns(
  303:         self, data: list[list[str]], header: list[str]
  304:     ) -> None:
  305:         # insert the header first: we need to know the size of column names
  306:         if len(data) > 0:
  307:             data.insert(0, header)
  308: 
  309:         pkg_strings, sizes = tabulate(data)
  310: 
  311:         # Create and add a separator.
  312:         if len(data) > 0:
  313:             pkg_strings.insert(1, " ".join("-" * x for x in sizes))
  314: 
  315:         for val in pkg_strings:
  316:             write_output(val)
  317: 
  318: 
  319: def format_for_columns(
  320:     pkgs: _ProcessedDists, options: Values
  321: ) -> tuple[list[list[str]], list[str]]:
  322:     """
  323:     Convert the package data into something usable
  324:     by output_package_listing_columns.
  325:     """
  326:     header = ["Package", "Version"]
  327: 
  328:     running_outdated = options.outdated
  329:     if running_outdated:
  330:         header.extend(["Latest", "Type"])
  331: 
  332:     def wheel_build_tag(dist: BaseDistribution) -> str | None:
  333:         try:
  334:             wheel_file = dist.read_text("WHEEL")
  335:         except FileNotFoundError:
  336:             return None
  337:         return Parser().parsestr(wheel_file).get("Build")
  338: 
  339:     build_tags = [wheel_build_tag(p) for p in pkgs]
  340:     has_build_tags = any(build_tags)
  341:     if has_build_tags:
  342:         header.append("Build")
  343: 
  344:     if options.verbose >= 1:
  345:         header.append("Location")
  346:     if options.verbose >= 1:
  347:         header.append("Installer")
  348: 
  349:     has_editables = any(x.editable for x in pkgs)
  350:     if has_editables:
  351:         header.append("Editable project location")
  352: 
  353:     data = []
  354:     for i, proj in enumerate(pkgs):
  355:         # if we're working on the 'outdated' list, separate out the
  356:         # latest_version and type
  357:         row = [proj.raw_name, proj.raw_version]
  358: 
  359:         if running_outdated:
  360:             row.append(str(proj.latest_version))
  361:             row.append(proj.latest_filetype)
  362: 
  363:         if has_build_tags:
  364:             row.append(build_tags[i] or "")
  365: 
  366:         if has_editables:
  367:             row.append(proj.editable_project_location or "")
  368: 
  369:         if options.verbose >= 1:
  370:             row.append(proj.location or "")
  371:         if options.verbose >= 1:
  372:             row.append(proj.installer)
  373: 
  374:         data.append(row)
  375: 
  376:     return data, header
  377: 
  378: 
  379: def format_for_json(packages: _ProcessedDists, options: Values) -> str:
  380:     data = []
  381:     for dist in packages:
  382:         try:
  383:             version = str(dist.version)
  384:         except InvalidVersion:
  385:             version = dist.raw_version
  386:         info = {
  387:             "name": dist.raw_name,
  388:             "version": version,
  389:         }
  390:         if options.verbose >= 1:
  391:             info["location"] = dist.location or ""
  392:             info["installer"] = dist.installer
  393:         if options.outdated:
  394:             info["latest_version"] = str(dist.latest_version)
  395:             info["latest_filetype"] = dist.latest_filetype
  396:         editable_project_location = dist.editable_project_location
  397:         if editable_project_location:
  398:             info["editable_project_location"] = editable_project_location
  399:         data.append(info)
  400:     return json.dumps(data)
