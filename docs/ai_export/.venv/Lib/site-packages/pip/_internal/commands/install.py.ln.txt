    1: from __future__ import annotations
    2: 
    3: import errno
    4: import json
    5: import operator
    6: import os
    7: import shutil
    8: import site
    9: from optparse import SUPPRESS_HELP, Values
   10: from pathlib import Path
   11: 
   12: from pip._vendor.packaging.utils import canonicalize_name
   13: from pip._vendor.requests.exceptions import InvalidProxyURL
   14: from pip._vendor.rich import print_json
   15: 
   16: # Eagerly import self_outdated_check to avoid crashes. Otherwise,
   17: # this module would be imported *after* pip was replaced, resulting
   18: # in crashes if the new self_outdated_check module was incompatible
   19: # with the rest of pip that's already imported, or allowing a
   20: # wheel to execute arbitrary code on install by replacing
   21: # self_outdated_check.
   22: import pip._internal.self_outdated_check  # noqa: F401
   23: from pip._internal.cache import WheelCache
   24: from pip._internal.cli import cmdoptions
   25: from pip._internal.cli.cmdoptions import make_target_python
   26: from pip._internal.cli.req_command import (
   27:     RequirementCommand,
   28:     with_cleanup,
   29: )
   30: from pip._internal.cli.status_codes import ERROR, SUCCESS
   31: from pip._internal.exceptions import (
   32:     CommandError,
   33:     InstallationError,
   34:     InstallWheelBuildError,
   35: )
   36: from pip._internal.locations import get_scheme
   37: from pip._internal.metadata import get_environment
   38: from pip._internal.models.installation_report import InstallationReport
   39: from pip._internal.operations.build.build_tracker import get_build_tracker
   40: from pip._internal.operations.check import ConflictDetails, check_install_conflicts
   41: from pip._internal.req import install_given_reqs
   42: from pip._internal.req.req_install import (
   43:     InstallRequirement,
   44:     check_legacy_setup_py_options,
   45: )
   46: from pip._internal.utils.compat import WINDOWS
   47: from pip._internal.utils.filesystem import test_writable_dir
   48: from pip._internal.utils.logging import getLogger
   49: from pip._internal.utils.misc import (
   50:     check_externally_managed,
   51:     ensure_dir,
   52:     get_pip_version,
   53:     protect_pip_from_modification_on_windows,
   54:     warn_if_run_as_root,
   55:     write_output,
   56: )
   57: from pip._internal.utils.temp_dir import TempDirectory
   58: from pip._internal.utils.virtualenv import (
   59:     running_under_virtualenv,
   60:     virtualenv_no_global,
   61: )
   62: from pip._internal.wheel_builder import build, should_build_for_install_command
   63: 
   64: logger = getLogger(__name__)
   65: 
   66: 
   67: class InstallCommand(RequirementCommand):
   68:     """
   69:     Install packages from:
   70: 
   71:     - PyPI (and other indexes) using requirement specifiers.
   72:     - VCS project urls.
   73:     - Local project directories.
   74:     - Local or remote source archives.
   75: 
   76:     pip also supports installing from "requirements files", which provide
   77:     an easy way to specify a whole environment to be installed.
   78:     """
   79: 
   80:     usage = """
   81:       %prog [options] <requirement specifier> [package-index-options] ...
   82:       %prog [options] -r <requirements file> [package-index-options] ...
   83:       %prog [options] [-e] <vcs project url> ...
   84:       %prog [options] [-e] <local project path> ...
   85:       %prog [options] <archive url/path> ..."""
   86: 
   87:     def add_options(self) -> None:
   88:         self.cmd_opts.add_option(cmdoptions.requirements())
   89:         self.cmd_opts.add_option(cmdoptions.constraints())
   90:         self.cmd_opts.add_option(cmdoptions.no_deps())
   91:         self.cmd_opts.add_option(cmdoptions.pre())
   92: 
   93:         self.cmd_opts.add_option(cmdoptions.editable())
   94:         self.cmd_opts.add_option(
   95:             "--dry-run",
   96:             action="store_true",
   97:             dest="dry_run",
   98:             default=False,
   99:             help=(
  100:                 "Don't actually install anything, just print what would be. "
  101:                 "Can be used in combination with --ignore-installed "
  102:                 "to 'resolve' the requirements."
  103:             ),
  104:         )
  105:         self.cmd_opts.add_option(
  106:             "-t",
  107:             "--target",
  108:             dest="target_dir",
  109:             metavar="dir",
  110:             default=None,
  111:             help=(
  112:                 "Install packages into <dir>. "
  113:                 "By default this will not replace existing files/folders in "
  114:                 "<dir>. Use --upgrade to replace existing packages in <dir> "
  115:                 "with new versions."
  116:             ),
  117:         )
  118:         cmdoptions.add_target_python_options(self.cmd_opts)
  119: 
  120:         self.cmd_opts.add_option(
  121:             "--user",
  122:             dest="use_user_site",
  123:             action="store_true",
  124:             help=(
  125:                 "Install to the Python user install directory for your "
  126:                 "platform. Typically ~/.local/, or %APPDATA%\\Python on "
  127:                 "Windows. (See the Python documentation for site.USER_BASE "
  128:                 "for full details.)"
  129:             ),
  130:         )
  131:         self.cmd_opts.add_option(
  132:             "--no-user",
  133:             dest="use_user_site",
  134:             action="store_false",
  135:             help=SUPPRESS_HELP,
  136:         )
  137:         self.cmd_opts.add_option(
  138:             "--root",
  139:             dest="root_path",
  140:             metavar="dir",
  141:             default=None,
  142:             help="Install everything relative to this alternate root directory.",
  143:         )
  144:         self.cmd_opts.add_option(
  145:             "--prefix",
  146:             dest="prefix_path",
  147:             metavar="dir",
  148:             default=None,
  149:             help=(
  150:                 "Installation prefix where lib, bin and other top-level "
  151:                 "folders are placed. Note that the resulting installation may "
  152:                 "contain scripts and other resources which reference the "
  153:                 "Python interpreter of pip, and not that of ``--prefix``. "
  154:                 "See also the ``--python`` option if the intention is to "
  155:                 "install packages into another (possibly pip-free) "
  156:                 "environment."
  157:             ),
  158:         )
  159: 
  160:         self.cmd_opts.add_option(cmdoptions.src())
  161: 
  162:         self.cmd_opts.add_option(
  163:             "-U",
  164:             "--upgrade",
  165:             dest="upgrade",
  166:             action="store_true",
  167:             help=(
  168:                 "Upgrade all specified packages to the newest available "
  169:                 "version. The handling of dependencies depends on the "
  170:                 "upgrade-strategy used."
  171:             ),
  172:         )
  173: 
  174:         self.cmd_opts.add_option(
  175:             "--upgrade-strategy",
  176:             dest="upgrade_strategy",
  177:             default="only-if-needed",
  178:             choices=["only-if-needed", "eager"],
  179:             help=(
  180:                 "Determines how dependency upgrading should be handled "
  181:                 "[default: %default]. "
  182:                 '"eager" - dependencies are upgraded regardless of '
  183:                 "whether the currently installed version satisfies the "
  184:                 "requirements of the upgraded package(s). "
  185:                 '"only-if-needed" -  are upgraded only when they do not '
  186:                 "satisfy the requirements of the upgraded package(s)."
  187:             ),
  188:         )
  189: 
  190:         self.cmd_opts.add_option(
  191:             "--force-reinstall",
  192:             dest="force_reinstall",
  193:             action="store_true",
  194:             help="Reinstall all packages even if they are already up-to-date.",
  195:         )
  196: 
  197:         self.cmd_opts.add_option(
  198:             "-I",
  199:             "--ignore-installed",
  200:             dest="ignore_installed",
  201:             action="store_true",
  202:             help=(
  203:                 "Ignore the installed packages, overwriting them. "
  204:                 "This can break your system if the existing package "
  205:                 "is of a different version or was installed "
  206:                 "with a different package manager!"
  207:             ),
  208:         )
  209: 
  210:         self.cmd_opts.add_option(cmdoptions.ignore_requires_python())
  211:         self.cmd_opts.add_option(cmdoptions.no_build_isolation())
  212:         self.cmd_opts.add_option(cmdoptions.use_pep517())
  213:         self.cmd_opts.add_option(cmdoptions.no_use_pep517())
  214:         self.cmd_opts.add_option(cmdoptions.check_build_deps())
  215:         self.cmd_opts.add_option(cmdoptions.override_externally_managed())
  216: 
  217:         self.cmd_opts.add_option(cmdoptions.config_settings())
  218:         self.cmd_opts.add_option(cmdoptions.global_options())
  219: 
  220:         self.cmd_opts.add_option(
  221:             "--compile",
  222:             action="store_true",
  223:             dest="compile",
  224:             default=True,
  225:             help="Compile Python source files to bytecode",
  226:         )
  227: 
  228:         self.cmd_opts.add_option(
  229:             "--no-compile",
  230:             action="store_false",
  231:             dest="compile",
  232:             help="Do not compile Python source files to bytecode",
  233:         )
  234: 
  235:         self.cmd_opts.add_option(
  236:             "--no-warn-script-location",
  237:             action="store_false",
  238:             dest="warn_script_location",
  239:             default=True,
  240:             help="Do not warn when installing scripts outside PATH",
  241:         )
  242:         self.cmd_opts.add_option(
  243:             "--no-warn-conflicts",
  244:             action="store_false",
  245:             dest="warn_about_conflicts",
  246:             default=True,
  247:             help="Do not warn about broken dependencies",
  248:         )
  249:         self.cmd_opts.add_option(cmdoptions.no_binary())
  250:         self.cmd_opts.add_option(cmdoptions.only_binary())
  251:         self.cmd_opts.add_option(cmdoptions.prefer_binary())
  252:         self.cmd_opts.add_option(cmdoptions.require_hashes())
  253:         self.cmd_opts.add_option(cmdoptions.progress_bar())
  254:         self.cmd_opts.add_option(cmdoptions.root_user_action())
  255: 
  256:         index_opts = cmdoptions.make_option_group(
  257:             cmdoptions.index_group,
  258:             self.parser,
  259:         )
  260: 
  261:         self.parser.insert_option_group(0, index_opts)
  262:         self.parser.insert_option_group(0, self.cmd_opts)
  263: 
  264:         self.cmd_opts.add_option(
  265:             "--report",
  266:             dest="json_report_file",
  267:             metavar="file",
  268:             default=None,
  269:             help=(
  270:                 "Generate a JSON file describing what pip did to install "
  271:                 "the provided requirements. "
  272:                 "Can be used in combination with --dry-run and --ignore-installed "
  273:                 "to 'resolve' the requirements. "
  274:                 "When - is used as file name it writes to stdout. "
  275:                 "When writing to stdout, please combine with the --quiet option "
  276:                 "to avoid mixing pip logging output with JSON output."
  277:             ),
  278:         )
  279: 
  280:     @with_cleanup
  281:     def run(self, options: Values, args: list[str]) -> int:
  282:         if options.use_user_site and options.target_dir is not None:
  283:             raise CommandError("Can not combine '--user' and '--target'")
  284: 
  285:         # Check whether the environment we're installing into is externally
  286:         # managed, as specified in PEP 668. Specifying --root, --target, or
  287:         # --prefix disables the check, since there's no reliable way to locate
  288:         # the EXTERNALLY-MANAGED file for those cases. An exception is also
  289:         # made specifically for "--dry-run --report" for convenience.
  290:         installing_into_current_environment = (
  291:             not (options.dry_run and options.json_report_file)
  292:             and options.root_path is None
  293:             and options.target_dir is None
  294:             and options.prefix_path is None
  295:         )
  296:         if (
  297:             installing_into_current_environment
  298:             and not options.override_externally_managed
  299:         ):
  300:             check_externally_managed()
  301: 
  302:         upgrade_strategy = "to-satisfy-only"
  303:         if options.upgrade:
  304:             upgrade_strategy = options.upgrade_strategy
  305: 
  306:         cmdoptions.check_dist_restriction(options, check_target=True)
  307: 
  308:         logger.verbose("Using %s", get_pip_version())
  309:         options.use_user_site = decide_user_install(
  310:             options.use_user_site,
  311:             prefix_path=options.prefix_path,
  312:             target_dir=options.target_dir,
  313:             root_path=options.root_path,
  314:             isolated_mode=options.isolated_mode,
  315:         )
  316: 
  317:         target_temp_dir: TempDirectory | None = None
  318:         target_temp_dir_path: str | None = None
  319:         if options.target_dir:
  320:             options.ignore_installed = True
  321:             options.target_dir = os.path.abspath(options.target_dir)
  322:             if (
  323:                 # fmt: off
  324:                 os.path.exists(options.target_dir) and
  325:                 not os.path.isdir(options.target_dir)
  326:                 # fmt: on
  327:             ):
  328:                 raise CommandError(
  329:                     "Target path exists but is not a directory, will not continue."
  330:                 )
  331: 
  332:             # Create a target directory for using with the target option
  333:             target_temp_dir = TempDirectory(kind="target")
  334:             target_temp_dir_path = target_temp_dir.path
  335:             self.enter_context(target_temp_dir)
  336: 
  337:         global_options = options.global_options or []
  338: 
  339:         session = self.get_default_session(options)
  340: 
  341:         target_python = make_target_python(options)
  342:         finder = self._build_package_finder(
  343:             options=options,
  344:             session=session,
  345:             target_python=target_python,
  346:             ignore_requires_python=options.ignore_requires_python,
  347:         )
  348:         build_tracker = self.enter_context(get_build_tracker())
  349: 
  350:         directory = TempDirectory(
  351:             delete=not options.no_clean,
  352:             kind="install",
  353:             globally_managed=True,
  354:         )
  355: 
  356:         try:
  357:             reqs = self.get_requirements(args, options, finder, session)
  358:             check_legacy_setup_py_options(options, reqs)
  359: 
  360:             wheel_cache = WheelCache(options.cache_dir)
  361: 
  362:             # Only when installing is it permitted to use PEP 660.
  363:             # In other circumstances (pip wheel, pip download) we generate
  364:             # regular (i.e. non editable) metadata and wheels.
  365:             for req in reqs:
  366:                 req.permit_editable_wheels = True
  367: 
  368:             preparer = self.make_requirement_preparer(
  369:                 temp_build_dir=directory,
  370:                 options=options,
  371:                 build_tracker=build_tracker,
  372:                 session=session,
  373:                 finder=finder,
  374:                 use_user_site=options.use_user_site,
  375:                 verbosity=self.verbosity,
  376:             )
  377:             resolver = self.make_resolver(
  378:                 preparer=preparer,
  379:                 finder=finder,
  380:                 options=options,
  381:                 wheel_cache=wheel_cache,
  382:                 use_user_site=options.use_user_site,
  383:                 ignore_installed=options.ignore_installed,
  384:                 ignore_requires_python=options.ignore_requires_python,
  385:                 force_reinstall=options.force_reinstall,
  386:                 upgrade_strategy=upgrade_strategy,
  387:                 use_pep517=options.use_pep517,
  388:                 py_version_info=options.python_version,
  389:             )
  390: 
  391:             self.trace_basic_info(finder)
  392: 
  393:             requirement_set = resolver.resolve(
  394:                 reqs, check_supported_wheels=not options.target_dir
  395:             )
  396: 
  397:             if options.json_report_file:
  398:                 report = InstallationReport(requirement_set.requirements_to_install)
  399:                 if options.json_report_file == "-":
  400:                     print_json(data=report.to_dict())
  401:                 else:
  402:                     with open(options.json_report_file, "w", encoding="utf-8") as f:
  403:                         json.dump(report.to_dict(), f, indent=2, ensure_ascii=False)
  404: 
  405:             if options.dry_run:
  406:                 would_install_items = sorted(
  407:                     (r.metadata["name"], r.metadata["version"])
  408:                     for r in requirement_set.requirements_to_install
  409:                 )
  410:                 if would_install_items:
  411:                     write_output(
  412:                         "Would install %s",
  413:                         " ".join("-".join(item) for item in would_install_items),
  414:                     )
  415:                 return SUCCESS
  416: 
  417:             try:
  418:                 pip_req = requirement_set.get_requirement("pip")
  419:             except KeyError:
  420:                 modifying_pip = False
  421:             else:
  422:                 # If we're not replacing an already installed pip,
  423:                 # we're not modifying it.
  424:                 modifying_pip = pip_req.satisfied_by is None
  425:             protect_pip_from_modification_on_windows(modifying_pip=modifying_pip)
  426: 
  427:             reqs_to_build = [
  428:                 r
  429:                 for r in requirement_set.requirements_to_install
  430:                 if should_build_for_install_command(r)
  431:             ]
  432: 
  433:             _, build_failures = build(
  434:                 reqs_to_build,
  435:                 wheel_cache=wheel_cache,
  436:                 verify=True,
  437:                 build_options=[],
  438:                 global_options=global_options,
  439:             )
  440: 
  441:             if build_failures:
  442:                 raise InstallWheelBuildError(build_failures)
  443: 
  444:             to_install = resolver.get_installation_order(requirement_set)
  445: 
  446:             # Check for conflicts in the package set we're installing.
  447:             conflicts: ConflictDetails | None = None
  448:             should_warn_about_conflicts = (
  449:                 not options.ignore_dependencies and options.warn_about_conflicts
  450:             )
  451:             if should_warn_about_conflicts:
  452:                 conflicts = self._determine_conflicts(to_install)
  453: 
  454:             # Don't warn about script install locations if
  455:             # --target or --prefix has been specified
  456:             warn_script_location = options.warn_script_location
  457:             if options.target_dir or options.prefix_path:
  458:                 warn_script_location = False
  459: 
  460:             installed = install_given_reqs(
  461:                 to_install,
  462:                 global_options,
  463:                 root=options.root_path,
  464:                 home=target_temp_dir_path,
  465:                 prefix=options.prefix_path,
  466:                 warn_script_location=warn_script_location,
  467:                 use_user_site=options.use_user_site,
  468:                 pycompile=options.compile,
  469:                 progress_bar=options.progress_bar,
  470:             )
  471: 
  472:             lib_locations = get_lib_location_guesses(
  473:                 user=options.use_user_site,
  474:                 home=target_temp_dir_path,
  475:                 root=options.root_path,
  476:                 prefix=options.prefix_path,
  477:                 isolated=options.isolated_mode,
  478:             )
  479:             env = get_environment(lib_locations)
  480: 
  481:             # Display a summary of installed packages, with extra care to
  482:             # display a package name as it was requested by the user.
  483:             installed.sort(key=operator.attrgetter("name"))
  484:             summary = []
  485:             installed_versions = {}
  486:             for distribution in env.iter_all_distributions():
  487:                 installed_versions[distribution.canonical_name] = distribution.version
  488:             for package in installed:
  489:                 display_name = package.name
  490:                 version = installed_versions.get(canonicalize_name(display_name), None)
  491:                 if version:
  492:                     text = f"{display_name}-{version}"
  493:                 else:
  494:                     text = display_name
  495:                 summary.append(text)
  496: 
  497:             if conflicts is not None:
  498:                 self._warn_about_conflicts(
  499:                     conflicts,
  500:                     resolver_variant=self.determine_resolver_variant(options),
  501:                 )
  502: 
  503:             installed_desc = " ".join(summary)
  504:             if installed_desc:
  505:                 write_output(
  506:                     "Successfully installed %s",
  507:                     installed_desc,
  508:                 )
  509:         except OSError as error:
  510:             show_traceback = self.verbosity >= 1
  511: 
  512:             message = create_os_error_message(
  513:                 error,
  514:                 show_traceback,
  515:                 options.use_user_site,
  516:             )
  517:             logger.error(message, exc_info=show_traceback)
  518: 
  519:             return ERROR
  520: 
  521:         if options.target_dir:
  522:             assert target_temp_dir
  523:             self._handle_target_dir(
  524:                 options.target_dir, target_temp_dir, options.upgrade
  525:             )
  526:         if options.root_user_action == "warn":
  527:             warn_if_run_as_root()
  528:         return SUCCESS
  529: 
  530:     def _handle_target_dir(
  531:         self, target_dir: str, target_temp_dir: TempDirectory, upgrade: bool
  532:     ) -> None:
  533:         ensure_dir(target_dir)
  534: 
  535:         # Checking both purelib and platlib directories for installed
  536:         # packages to be moved to target directory
  537:         lib_dir_list = []
  538: 
  539:         # Checking both purelib and platlib directories for installed
  540:         # packages to be moved to target directory
  541:         scheme = get_scheme("", home=target_temp_dir.path)
  542:         purelib_dir = scheme.purelib
  543:         platlib_dir = scheme.platlib
  544:         data_dir = scheme.data
  545: 
  546:         if os.path.exists(purelib_dir):
  547:             lib_dir_list.append(purelib_dir)
  548:         if os.path.exists(platlib_dir) and platlib_dir != purelib_dir:
  549:             lib_dir_list.append(platlib_dir)
  550:         if os.path.exists(data_dir):
  551:             lib_dir_list.append(data_dir)
  552: 
  553:         for lib_dir in lib_dir_list:
  554:             for item in os.listdir(lib_dir):
  555:                 if lib_dir == data_dir:
  556:                     ddir = os.path.join(data_dir, item)
  557:                     if any(s.startswith(ddir) for s in lib_dir_list[:-1]):
  558:                         continue
  559:                 target_item_dir = os.path.join(target_dir, item)
  560:                 if os.path.exists(target_item_dir):
  561:                     if not upgrade:
  562:                         logger.warning(
  563:                             "Target directory %s already exists. Specify "
  564:                             "--upgrade to force replacement.",
  565:                             target_item_dir,
  566:                         )
  567:                         continue
  568:                     if os.path.islink(target_item_dir):
  569:                         logger.warning(
  570:                             "Target directory %s already exists and is "
  571:                             "a link. pip will not automatically replace "
  572:                             "links, please remove if replacement is "
  573:                             "desired.",
  574:                             target_item_dir,
  575:                         )
  576:                         continue
  577:                     if os.path.isdir(target_item_dir):
  578:                         shutil.rmtree(target_item_dir)
  579:                     else:
  580:                         os.remove(target_item_dir)
  581: 
  582:                 shutil.move(os.path.join(lib_dir, item), target_item_dir)
  583: 
  584:     def _determine_conflicts(
  585:         self, to_install: list[InstallRequirement]
  586:     ) -> ConflictDetails | None:
  587:         try:
  588:             return check_install_conflicts(to_install)
  589:         except Exception:
  590:             logger.exception(
  591:                 "Error while checking for conflicts. Please file an issue on "
  592:                 "pip's issue tracker: https://github.com/pypa/pip/issues/new"
  593:             )
  594:             return None
  595: 
  596:     def _warn_about_conflicts(
  597:         self, conflict_details: ConflictDetails, resolver_variant: str
  598:     ) -> None:
  599:         package_set, (missing, conflicting) = conflict_details
  600:         if not missing and not conflicting:
  601:             return
  602: 
  603:         parts: list[str] = []
  604:         if resolver_variant == "legacy":
  605:             parts.append(
  606:                 "pip's legacy dependency resolver does not consider dependency "
  607:                 "conflicts when selecting packages. This behaviour is the "
  608:                 "source of the following dependency conflicts."
  609:             )
  610:         else:
  611:             assert resolver_variant == "resolvelib"
  612:             parts.append(
  613:                 "pip's dependency resolver does not currently take into account "
  614:                 "all the packages that are installed. This behaviour is the "
  615:                 "source of the following dependency conflicts."
  616:             )
  617: 
  618:         # NOTE: There is some duplication here, with commands/check.py
  619:         for project_name in missing:
  620:             version = package_set[project_name][0]
  621:             for dependency in missing[project_name]:
  622:                 message = (
  623:                     f"{project_name} {version} requires {dependency[1]}, "
  624:                     "which is not installed."
  625:                 )
  626:                 parts.append(message)
  627: 
  628:         for project_name in conflicting:
  629:             version = package_set[project_name][0]
  630:             for dep_name, dep_version, req in conflicting[project_name]:
  631:                 message = (
  632:                     "{name} {version} requires {requirement}, but {you} have "
  633:                     "{dep_name} {dep_version} which is incompatible."
  634:                 ).format(
  635:                     name=project_name,
  636:                     version=version,
  637:                     requirement=req,
  638:                     dep_name=dep_name,
  639:                     dep_version=dep_version,
  640:                     you=("you" if resolver_variant == "resolvelib" else "you'll"),
  641:                 )
  642:                 parts.append(message)
  643: 
  644:         logger.critical("\n".join(parts))
  645: 
  646: 
  647: def get_lib_location_guesses(
  648:     user: bool = False,
  649:     home: str | None = None,
  650:     root: str | None = None,
  651:     isolated: bool = False,
  652:     prefix: str | None = None,
  653: ) -> list[str]:
  654:     scheme = get_scheme(
  655:         "",
  656:         user=user,
  657:         home=home,
  658:         root=root,
  659:         isolated=isolated,
  660:         prefix=prefix,
  661:     )
  662:     return [scheme.purelib, scheme.platlib]
  663: 
  664: 
  665: def site_packages_writable(root: str | None, isolated: bool) -> bool:
  666:     return all(
  667:         test_writable_dir(d)
  668:         for d in set(get_lib_location_guesses(root=root, isolated=isolated))
  669:     )
  670: 
  671: 
  672: def decide_user_install(
  673:     use_user_site: bool | None,
  674:     prefix_path: str | None = None,
  675:     target_dir: str | None = None,
  676:     root_path: str | None = None,
  677:     isolated_mode: bool = False,
  678: ) -> bool:
  679:     """Determine whether to do a user install based on the input options.
  680: 
  681:     If use_user_site is False, no additional checks are done.
  682:     If use_user_site is True, it is checked for compatibility with other
  683:     options.
  684:     If use_user_site is None, the default behaviour depends on the environment,
  685:     which is provided by the other arguments.
  686:     """
  687:     # In some cases (config from tox), use_user_site can be set to an integer
  688:     # rather than a bool, which 'use_user_site is False' wouldn't catch.
  689:     if (use_user_site is not None) and (not use_user_site):
  690:         logger.debug("Non-user install by explicit request")
  691:         return False
  692: 
  693:     if use_user_site:
  694:         if prefix_path:
  695:             raise CommandError(
  696:                 "Can not combine '--user' and '--prefix' as they imply "
  697:                 "different installation locations"
  698:             )
  699:         if virtualenv_no_global():
  700:             raise InstallationError(
  701:                 "Can not perform a '--user' install. User site-packages "
  702:                 "are not visible in this virtualenv."
  703:             )
  704:         logger.debug("User install by explicit request")
  705:         return True
  706: 
  707:     # If we are here, user installs have not been explicitly requested/avoided
  708:     assert use_user_site is None
  709: 
  710:     # user install incompatible with --prefix/--target
  711:     if prefix_path or target_dir:
  712:         logger.debug("Non-user install due to --prefix or --target option")
  713:         return False
  714: 
  715:     # If user installs are not enabled, choose a non-user install
  716:     if not site.ENABLE_USER_SITE:
  717:         logger.debug("Non-user install because user site-packages disabled")
  718:         return False
  719: 
  720:     # If we have permission for a non-user install, do that,
  721:     # otherwise do a user install.
  722:     if site_packages_writable(root=root_path, isolated=isolated_mode):
  723:         logger.debug("Non-user install because site-packages writeable")
  724:         return False
  725: 
  726:     logger.info(
  727:         "Defaulting to user installation because normal site-packages "
  728:         "is not writeable"
  729:     )
  730:     return True
  731: 
  732: 
  733: def create_os_error_message(
  734:     error: OSError, show_traceback: bool, using_user_site: bool
  735: ) -> str:
  736:     """Format an error message for an OSError
  737: 
  738:     It may occur anytime during the execution of the install command.
  739:     """
  740:     parts = []
  741: 
  742:     # Mention the error if we are not going to show a traceback
  743:     parts.append("Could not install packages due to an OSError")
  744:     if not show_traceback:
  745:         parts.append(": ")
  746:         parts.append(str(error))
  747:     else:
  748:         parts.append(".")
  749: 
  750:     # Spilt the error indication from a helper message (if any)
  751:     parts[-1] += "\n"
  752: 
  753:     # Suggest useful actions to the user:
  754:     #  (1) using user site-packages or (2) verifying the permissions
  755:     if error.errno == errno.EACCES:
  756:         user_option_part = "Consider using the `--user` option"
  757:         permissions_part = "Check the permissions"
  758: 
  759:         if not running_under_virtualenv() and not using_user_site:
  760:             parts.extend(
  761:                 [
  762:                     user_option_part,
  763:                     " or ",
  764:                     permissions_part.lower(),
  765:                 ]
  766:             )
  767:         else:
  768:             parts.append(permissions_part)
  769:         parts.append(".\n")
  770: 
  771:     # Suggest to check "pip config debug" in case of invalid proxy
  772:     if type(error) is InvalidProxyURL:
  773:         parts.append(
  774:             'Consider checking your local proxy configuration with "pip config debug"'
  775:         )
  776:         parts.append(".\n")
  777: 
  778:     # On Windows, errors like EINVAL or ENOENT may occur
  779:     # if a file or folder name exceeds 255 characters,
  780:     # or if the full path exceeds 260 characters and long path support isn't enabled.
  781:     # This condition checks for such cases and adds a hint to the error output.
  782: 
  783:     if WINDOWS and error.errno in (errno.EINVAL, errno.ENOENT) and error.filename:
  784:         if any(len(part) > 255 for part in Path(error.filename).parts):
  785:             parts.append(
  786:                 "HINT: This error might be caused by a file or folder name exceeding "
  787:                 "255 characters, which is a Windows limitation even if long paths "
  788:                 "are enabled.\n "
  789:             )
  790:         if len(error.filename) > 260:
  791:             parts.append(
  792:                 "HINT: This error might have occurred since "
  793:                 "this system does not have Windows Long Path "
  794:                 "support enabled. You can find information on "
  795:                 "how to enable this at "
  796:                 "https://pip.pypa.io/warnings/enable-long-paths\n"
  797:             )
  798:     return "".join(parts).strip() + "\n"
