    1: from __future__ import annotations
    2: 
    3: import logging
    4: import string
    5: from collections.abc import Generator, Iterable, Iterator
    6: from optparse import Values
    7: from typing import NamedTuple
    8: 
    9: from pip._vendor.packaging.requirements import InvalidRequirement
   10: from pip._vendor.packaging.utils import canonicalize_name
   11: 
   12: from pip._internal.cli.base_command import Command
   13: from pip._internal.cli.status_codes import ERROR, SUCCESS
   14: from pip._internal.metadata import BaseDistribution, get_default_environment
   15: from pip._internal.utils.misc import write_output
   16: 
   17: logger = logging.getLogger(__name__)
   18: 
   19: 
   20: def normalize_project_url_label(label: str) -> str:
   21:     # This logic is from PEP 753 (Well-known Project URLs in Metadata).
   22:     chars_to_remove = string.punctuation + string.whitespace
   23:     removal_map = str.maketrans("", "", chars_to_remove)
   24:     return label.translate(removal_map).lower()
   25: 
   26: 
   27: class ShowCommand(Command):
   28:     """
   29:     Show information about one or more installed packages.
   30: 
   31:     The output is in RFC-compliant mail header format.
   32:     """
   33: 
   34:     usage = """
   35:       %prog [options] <package> ..."""
   36:     ignore_require_venv = True
   37: 
   38:     def add_options(self) -> None:
   39:         self.cmd_opts.add_option(
   40:             "-f",
   41:             "--files",
   42:             dest="files",
   43:             action="store_true",
   44:             default=False,
   45:             help="Show the full list of installed files for each package.",
   46:         )
   47: 
   48:         self.parser.insert_option_group(0, self.cmd_opts)
   49: 
   50:     def run(self, options: Values, args: list[str]) -> int:
   51:         if not args:
   52:             logger.warning("ERROR: Please provide a package name or names.")
   53:             return ERROR
   54:         query = args
   55: 
   56:         results = search_packages_info(query)
   57:         if not print_results(
   58:             results, list_files=options.files, verbose=options.verbose
   59:         ):
   60:             return ERROR
   61:         return SUCCESS
   62: 
   63: 
   64: class _PackageInfo(NamedTuple):
   65:     name: str
   66:     version: str
   67:     location: str
   68:     editable_project_location: str | None
   69:     requires: list[str]
   70:     required_by: list[str]
   71:     installer: str
   72:     metadata_version: str
   73:     classifiers: list[str]
   74:     summary: str
   75:     homepage: str
   76:     project_urls: list[str]
   77:     author: str
   78:     author_email: str
   79:     license: str
   80:     license_expression: str
   81:     entry_points: list[str]
   82:     files: list[str] | None
   83: 
   84: 
   85: def search_packages_info(query: list[str]) -> Generator[_PackageInfo, None, None]:
   86:     """
   87:     Gather details from installed distributions. Print distribution name,
   88:     version, location, and installed files. Installed files requires a
   89:     pip generated 'installed-files.txt' in the distributions '.egg-info'
   90:     directory.
   91:     """
   92:     env = get_default_environment()
   93: 
   94:     installed = {dist.canonical_name: dist for dist in env.iter_all_distributions()}
   95:     query_names = [canonicalize_name(name) for name in query]
   96:     missing = sorted(
   97:         [name for name, pkg in zip(query, query_names) if pkg not in installed]
   98:     )
   99:     if missing:
  100:         logger.warning("Package(s) not found: %s", ", ".join(missing))
  101: 
  102:     def _get_requiring_packages(current_dist: BaseDistribution) -> Iterator[str]:
  103:         return (
  104:             dist.metadata["Name"] or "UNKNOWN"
  105:             for dist in installed.values()
  106:             if current_dist.canonical_name
  107:             in {canonicalize_name(d.name) for d in dist.iter_dependencies()}
  108:         )
  109: 
  110:     for query_name in query_names:
  111:         try:
  112:             dist = installed[query_name]
  113:         except KeyError:
  114:             continue
  115: 
  116:         try:
  117:             requires = sorted(
  118:                 # Avoid duplicates in requirements (e.g. due to environment markers).
  119:                 {req.name for req in dist.iter_dependencies()},
  120:                 key=str.lower,
  121:             )
  122:         except InvalidRequirement:
  123:             requires = sorted(dist.iter_raw_dependencies(), key=str.lower)
  124: 
  125:         try:
  126:             required_by = sorted(_get_requiring_packages(dist), key=str.lower)
  127:         except InvalidRequirement:
  128:             required_by = ["#N/A"]
  129: 
  130:         try:
  131:             entry_points_text = dist.read_text("entry_points.txt")
  132:             entry_points = entry_points_text.splitlines(keepends=False)
  133:         except FileNotFoundError:
  134:             entry_points = []
  135: 
  136:         files_iter = dist.iter_declared_entries()
  137:         if files_iter is None:
  138:             files: list[str] | None = None
  139:         else:
  140:             files = sorted(files_iter)
  141: 
  142:         metadata = dist.metadata
  143: 
  144:         project_urls = metadata.get_all("Project-URL", [])
  145:         homepage = metadata.get("Home-page", "")
  146:         if not homepage:
  147:             # It's common that there is a "homepage" Project-URL, but Home-page
  148:             # remains unset (especially as PEP 621 doesn't surface the field).
  149:             for url in project_urls:
  150:                 url_label, url = url.split(",", maxsplit=1)
  151:                 normalized_label = normalize_project_url_label(url_label)
  152:                 if normalized_label == "homepage":
  153:                     homepage = url.strip()
  154:                     break
  155: 
  156:         yield _PackageInfo(
  157:             name=dist.raw_name,
  158:             version=dist.raw_version,
  159:             location=dist.location or "",
  160:             editable_project_location=dist.editable_project_location,
  161:             requires=requires,
  162:             required_by=required_by,
  163:             installer=dist.installer,
  164:             metadata_version=dist.metadata_version or "",
  165:             classifiers=metadata.get_all("Classifier", []),
  166:             summary=metadata.get("Summary", ""),
  167:             homepage=homepage,
  168:             project_urls=project_urls,
  169:             author=metadata.get("Author", ""),
  170:             author_email=metadata.get("Author-email", ""),
  171:             license=metadata.get("License", ""),
  172:             license_expression=metadata.get("License-Expression", ""),
  173:             entry_points=entry_points,
  174:             files=files,
  175:         )
  176: 
  177: 
  178: def print_results(
  179:     distributions: Iterable[_PackageInfo],
  180:     list_files: bool,
  181:     verbose: bool,
  182: ) -> bool:
  183:     """
  184:     Print the information from installed distributions found.
  185:     """
  186:     results_printed = False
  187:     for i, dist in enumerate(distributions):
  188:         results_printed = True
  189:         if i > 0:
  190:             write_output("---")
  191: 
  192:         metadata_version_tuple = tuple(map(int, dist.metadata_version.split(".")))
  193: 
  194:         write_output("Name: %s", dist.name)
  195:         write_output("Version: %s", dist.version)
  196:         write_output("Summary: %s", dist.summary)
  197:         write_output("Home-page: %s", dist.homepage)
  198:         write_output("Author: %s", dist.author)
  199:         write_output("Author-email: %s", dist.author_email)
  200:         if metadata_version_tuple >= (2, 4) and dist.license_expression:
  201:             write_output("License-Expression: %s", dist.license_expression)
  202:         else:
  203:             write_output("License: %s", dist.license)
  204:         write_output("Location: %s", dist.location)
  205:         if dist.editable_project_location is not None:
  206:             write_output(
  207:                 "Editable project location: %s", dist.editable_project_location
  208:             )
  209:         write_output("Requires: %s", ", ".join(dist.requires))
  210:         write_output("Required-by: %s", ", ".join(dist.required_by))
  211: 
  212:         if verbose:
  213:             write_output("Metadata-Version: %s", dist.metadata_version)
  214:             write_output("Installer: %s", dist.installer)
  215:             write_output("Classifiers:")
  216:             for classifier in dist.classifiers:
  217:                 write_output("  %s", classifier)
  218:             write_output("Entry-points:")
  219:             for entry in dist.entry_points:
  220:                 write_output("  %s", entry.strip())
  221:             write_output("Project-URLs:")
  222:             for project_url in dist.project_urls:
  223:                 write_output("  %s", project_url)
  224:         if list_files:
  225:             write_output("Files:")
  226:             if dist.files is None:
  227:                 write_output("Cannot locate RECORD or installed-files.txt")
  228:             else:
  229:                 for line in dist.files:
  230:                     write_output("  %s", line.strip())
  231:     return results_printed
