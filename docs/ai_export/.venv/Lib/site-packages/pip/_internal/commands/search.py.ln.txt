    1: from __future__ import annotations
    2: 
    3: import logging
    4: import shutil
    5: import sys
    6: import textwrap
    7: import xmlrpc.client
    8: from collections import OrderedDict
    9: from optparse import Values
   10: from typing import TypedDict
   11: 
   12: from pip._vendor.packaging.version import parse as parse_version
   13: 
   14: from pip._internal.cli.base_command import Command
   15: from pip._internal.cli.req_command import SessionCommandMixin
   16: from pip._internal.cli.status_codes import NO_MATCHES_FOUND, SUCCESS
   17: from pip._internal.exceptions import CommandError
   18: from pip._internal.metadata import get_default_environment
   19: from pip._internal.metadata.base import BaseDistribution
   20: from pip._internal.models.index import PyPI
   21: from pip._internal.network.xmlrpc import PipXmlrpcTransport
   22: from pip._internal.utils.logging import indent_log
   23: from pip._internal.utils.misc import write_output
   24: 
   25: 
   26: class TransformedHit(TypedDict):
   27:     name: str
   28:     summary: str
   29:     versions: list[str]
   30: 
   31: 
   32: logger = logging.getLogger(__name__)
   33: 
   34: 
   35: class SearchCommand(Command, SessionCommandMixin):
   36:     """Search for PyPI packages whose name or summary contains <query>."""
   37: 
   38:     usage = """
   39:       %prog [options] <query>"""
   40:     ignore_require_venv = True
   41: 
   42:     def add_options(self) -> None:
   43:         self.cmd_opts.add_option(
   44:             "-i",
   45:             "--index",
   46:             dest="index",
   47:             metavar="URL",
   48:             default=PyPI.pypi_url,
   49:             help="Base URL of Python Package Index (default %default)",
   50:         )
   51: 
   52:         self.parser.insert_option_group(0, self.cmd_opts)
   53: 
   54:     def run(self, options: Values, args: list[str]) -> int:
   55:         if not args:
   56:             raise CommandError("Missing required argument (search query).")
   57:         query = args
   58:         pypi_hits = self.search(query, options)
   59:         hits = transform_hits(pypi_hits)
   60: 
   61:         terminal_width = None
   62:         if sys.stdout.isatty():
   63:             terminal_width = shutil.get_terminal_size()[0]
   64: 
   65:         print_results(hits, terminal_width=terminal_width)
   66:         if pypi_hits:
   67:             return SUCCESS
   68:         return NO_MATCHES_FOUND
   69: 
   70:     def search(self, query: list[str], options: Values) -> list[dict[str, str]]:
   71:         index_url = options.index
   72: 
   73:         session = self.get_default_session(options)
   74: 
   75:         transport = PipXmlrpcTransport(index_url, session)
   76:         pypi = xmlrpc.client.ServerProxy(index_url, transport)
   77:         try:
   78:             hits = pypi.search({"name": query, "summary": query}, "or")
   79:         except xmlrpc.client.Fault as fault:
   80:             message = (
   81:                 f"XMLRPC request failed [code: {fault.faultCode}]\n{fault.faultString}"
   82:             )
   83:             raise CommandError(message)
   84:         assert isinstance(hits, list)
   85:         return hits
   86: 
   87: 
   88: def transform_hits(hits: list[dict[str, str]]) -> list[TransformedHit]:
   89:     """
   90:     The list from pypi is really a list of versions. We want a list of
   91:     packages with the list of versions stored inline. This converts the
   92:     list from pypi into one we can use.
   93:     """
   94:     packages: dict[str, TransformedHit] = OrderedDict()
   95:     for hit in hits:
   96:         name = hit["name"]
   97:         summary = hit["summary"]
   98:         version = hit["version"]
   99: 
  100:         if name not in packages.keys():
  101:             packages[name] = {
  102:                 "name": name,
  103:                 "summary": summary,
  104:                 "versions": [version],
  105:             }
  106:         else:
  107:             packages[name]["versions"].append(version)
  108: 
  109:             # if this is the highest version, replace summary and score
  110:             if version == highest_version(packages[name]["versions"]):
  111:                 packages[name]["summary"] = summary
  112: 
  113:     return list(packages.values())
  114: 
  115: 
  116: def print_dist_installation_info(latest: str, dist: BaseDistribution | None) -> None:
  117:     if dist is not None:
  118:         with indent_log():
  119:             if dist.version == latest:
  120:                 write_output("INSTALLED: %s (latest)", dist.version)
  121:             else:
  122:                 write_output("INSTALLED: %s", dist.version)
  123:                 if parse_version(latest).pre:
  124:                     write_output(
  125:                         "LATEST:    %s (pre-release; install"
  126:                         " with `pip install --pre`)",
  127:                         latest,
  128:                     )
  129:                 else:
  130:                     write_output("LATEST:    %s", latest)
  131: 
  132: 
  133: def get_installed_distribution(name: str) -> BaseDistribution | None:
  134:     env = get_default_environment()
  135:     return env.get_distribution(name)
  136: 
  137: 
  138: def print_results(
  139:     hits: list[TransformedHit],
  140:     name_column_width: int | None = None,
  141:     terminal_width: int | None = None,
  142: ) -> None:
  143:     if not hits:
  144:         return
  145:     if name_column_width is None:
  146:         name_column_width = (
  147:             max(
  148:                 [
  149:                     len(hit["name"]) + len(highest_version(hit.get("versions", ["-"])))
  150:                     for hit in hits
  151:                 ]
  152:             )
  153:             + 4
  154:         )
  155: 
  156:     for hit in hits:
  157:         name = hit["name"]
  158:         summary = hit["summary"] or ""
  159:         latest = highest_version(hit.get("versions", ["-"]))
  160:         if terminal_width is not None:
  161:             target_width = terminal_width - name_column_width - 5
  162:             if target_width > 10:
  163:                 # wrap and indent summary to fit terminal
  164:                 summary_lines = textwrap.wrap(summary, target_width)
  165:                 summary = ("\n" + " " * (name_column_width + 3)).join(summary_lines)
  166: 
  167:         name_latest = f"{name} ({latest})"
  168:         line = f"{name_latest:{name_column_width}} - {summary}"
  169:         try:
  170:             write_output(line)
  171:             dist = get_installed_distribution(name)
  172:             print_dist_installation_info(latest, dist)
  173:         except UnicodeEncodeError:
  174:             pass
  175: 
  176: 
  177: def highest_version(versions: list[str]) -> str:
  178:     return max(versions, key=parse_version)
