    1: from __future__ import annotations
    2: 
    3: import logging
    4: import os
    5: import subprocess
    6: from optparse import Values
    7: from typing import Any, Callable
    8: 
    9: from pip._internal.cli.base_command import Command
   10: from pip._internal.cli.status_codes import ERROR, SUCCESS
   11: from pip._internal.configuration import (
   12:     Configuration,
   13:     Kind,
   14:     get_configuration_files,
   15:     kinds,
   16: )
   17: from pip._internal.exceptions import PipError
   18: from pip._internal.utils.logging import indent_log
   19: from pip._internal.utils.misc import get_prog, write_output
   20: 
   21: logger = logging.getLogger(__name__)
   22: 
   23: 
   24: class ConfigurationCommand(Command):
   25:     """
   26:     Manage local and global configuration.
   27: 
   28:     Subcommands:
   29: 
   30:     - list: List the active configuration (or from the file specified)
   31:     - edit: Edit the configuration file in an editor
   32:     - get: Get the value associated with command.option
   33:     - set: Set the command.option=value
   34:     - unset: Unset the value associated with command.option
   35:     - debug: List the configuration files and values defined under them
   36: 
   37:     Configuration keys should be dot separated command and option name,
   38:     with the special prefix "global" affecting any command. For example,
   39:     "pip config set global.index-url https://example.org/" would configure
   40:     the index url for all commands, but "pip config set download.timeout 10"
   41:     would configure a 10 second timeout only for "pip download" commands.
   42: 
   43:     If none of --user, --global and --site are passed, a virtual
   44:     environment configuration file is used if one is active and the file
   45:     exists. Otherwise, all modifications happen to the user file by
   46:     default.
   47:     """
   48: 
   49:     ignore_require_venv = True
   50:     usage = """
   51:         %prog [<file-option>] list
   52:         %prog [<file-option>] [--editor <editor-path>] edit
   53: 
   54:         %prog [<file-option>] get command.option
   55:         %prog [<file-option>] set command.option value
   56:         %prog [<file-option>] unset command.option
   57:         %prog [<file-option>] debug
   58:     """
   59: 
   60:     def add_options(self) -> None:
   61:         self.cmd_opts.add_option(
   62:             "--editor",
   63:             dest="editor",
   64:             action="store",
   65:             default=None,
   66:             help=(
   67:                 "Editor to use to edit the file. Uses VISUAL or EDITOR "
   68:                 "environment variables if not provided."
   69:             ),
   70:         )
   71: 
   72:         self.cmd_opts.add_option(
   73:             "--global",
   74:             dest="global_file",
   75:             action="store_true",
   76:             default=False,
   77:             help="Use the system-wide configuration file only",
   78:         )
   79: 
   80:         self.cmd_opts.add_option(
   81:             "--user",
   82:             dest="user_file",
   83:             action="store_true",
   84:             default=False,
   85:             help="Use the user configuration file only",
   86:         )
   87: 
   88:         self.cmd_opts.add_option(
   89:             "--site",
   90:             dest="site_file",
   91:             action="store_true",
   92:             default=False,
   93:             help="Use the current environment configuration file only",
   94:         )
   95: 
   96:         self.parser.insert_option_group(0, self.cmd_opts)
   97: 
   98:     def handler_map(self) -> dict[str, Callable[[Values, list[str]], None]]:
   99:         return {
  100:             "list": self.list_values,
  101:             "edit": self.open_in_editor,
  102:             "get": self.get_name,
  103:             "set": self.set_name_value,
  104:             "unset": self.unset_name,
  105:             "debug": self.list_config_values,
  106:         }
  107: 
  108:     def run(self, options: Values, args: list[str]) -> int:
  109:         handler_map = self.handler_map()
  110: 
  111:         # Determine action
  112:         if not args or args[0] not in handler_map:
  113:             logger.error(
  114:                 "Need an action (%s) to perform.",
  115:                 ", ".join(sorted(handler_map)),
  116:             )
  117:             return ERROR
  118: 
  119:         action = args[0]
  120: 
  121:         # Determine which configuration files are to be loaded
  122:         #    Depends on whether the command is modifying.
  123:         try:
  124:             load_only = self._determine_file(
  125:                 options, need_value=(action in ["get", "set", "unset", "edit"])
  126:             )
  127:         except PipError as e:
  128:             logger.error(e.args[0])
  129:             return ERROR
  130: 
  131:         # Load a new configuration
  132:         self.configuration = Configuration(
  133:             isolated=options.isolated_mode, load_only=load_only
  134:         )
  135:         self.configuration.load()
  136: 
  137:         # Error handling happens here, not in the action-handlers.
  138:         try:
  139:             handler_map[action](options, args[1:])
  140:         except PipError as e:
  141:             logger.error(e.args[0])
  142:             return ERROR
  143: 
  144:         return SUCCESS
  145: 
  146:     def _determine_file(self, options: Values, need_value: bool) -> Kind | None:
  147:         file_options = [
  148:             key
  149:             for key, value in (
  150:                 (kinds.USER, options.user_file),
  151:                 (kinds.GLOBAL, options.global_file),
  152:                 (kinds.SITE, options.site_file),
  153:             )
  154:             if value
  155:         ]
  156: 
  157:         if not file_options:
  158:             if not need_value:
  159:                 return None
  160:             # Default to user, unless there's a site file.
  161:             elif any(
  162:                 os.path.exists(site_config_file)
  163:                 for site_config_file in get_configuration_files()[kinds.SITE]
  164:             ):
  165:                 return kinds.SITE
  166:             else:
  167:                 return kinds.USER
  168:         elif len(file_options) == 1:
  169:             return file_options[0]
  170: 
  171:         raise PipError(
  172:             "Need exactly one file to operate upon "
  173:             "(--user, --site, --global) to perform."
  174:         )
  175: 
  176:     def list_values(self, options: Values, args: list[str]) -> None:
  177:         self._get_n_args(args, "list", n=0)
  178: 
  179:         for key, value in sorted(self.configuration.items()):
  180:             for key, value in sorted(value.items()):
  181:                 write_output("%s=%r", key, value)
  182: 
  183:     def get_name(self, options: Values, args: list[str]) -> None:
  184:         key = self._get_n_args(args, "get [name]", n=1)
  185:         value = self.configuration.get_value(key)
  186: 
  187:         write_output("%s", value)
  188: 
  189:     def set_name_value(self, options: Values, args: list[str]) -> None:
  190:         key, value = self._get_n_args(args, "set [name] [value]", n=2)
  191:         self.configuration.set_value(key, value)
  192: 
  193:         self._save_configuration()
  194: 
  195:     def unset_name(self, options: Values, args: list[str]) -> None:
  196:         key = self._get_n_args(args, "unset [name]", n=1)
  197:         self.configuration.unset_value(key)
  198: 
  199:         self._save_configuration()
  200: 
  201:     def list_config_values(self, options: Values, args: list[str]) -> None:
  202:         """List config key-value pairs across different config files"""
  203:         self._get_n_args(args, "debug", n=0)
  204: 
  205:         self.print_env_var_values()
  206:         # Iterate over config files and print if they exist, and the
  207:         # key-value pairs present in them if they do
  208:         for variant, files in sorted(self.configuration.iter_config_files()):
  209:             write_output("%s:", variant)
  210:             for fname in files:
  211:                 with indent_log():
  212:                     file_exists = os.path.exists(fname)
  213:                     write_output("%s, exists: %r", fname, file_exists)
  214:                     if file_exists:
  215:                         self.print_config_file_values(variant, fname)
  216: 
  217:     def print_config_file_values(self, variant: Kind, fname: str) -> None:
  218:         """Get key-value pairs from the file of a variant"""
  219:         for name, value in self.configuration.get_values_in_config(variant).items():
  220:             with indent_log():
  221:                 if name == fname:
  222:                     for confname, confvalue in value.items():
  223:                         write_output("%s: %s", confname, confvalue)
  224: 
  225:     def print_env_var_values(self) -> None:
  226:         """Get key-values pairs present as environment variables"""
  227:         write_output("%s:", "env_var")
  228:         with indent_log():
  229:             for key, value in sorted(self.configuration.get_environ_vars()):
  230:                 env_var = f"PIP_{key.upper()}"
  231:                 write_output("%s=%r", env_var, value)
  232: 
  233:     def open_in_editor(self, options: Values, args: list[str]) -> None:
  234:         editor = self._determine_editor(options)
  235: 
  236:         fname = self.configuration.get_file_to_edit()
  237:         if fname is None:
  238:             raise PipError("Could not determine appropriate file.")
  239:         elif '"' in fname:
  240:             # This shouldn't happen, unless we see a username like that.
  241:             # If that happens, we'd appreciate a pull request fixing this.
  242:             raise PipError(
  243:                 f'Can not open an editor for a file name containing "\n{fname}'
  244:             )
  245: 
  246:         try:
  247:             subprocess.check_call(f'{editor} "{fname}"', shell=True)
  248:         except FileNotFoundError as e:
  249:             if not e.filename:
  250:                 e.filename = editor
  251:             raise
  252:         except subprocess.CalledProcessError as e:
  253:             raise PipError(f"Editor Subprocess exited with exit code {e.returncode}")
  254: 
  255:     def _get_n_args(self, args: list[str], example: str, n: int) -> Any:
  256:         """Helper to make sure the command got the right number of arguments"""
  257:         if len(args) != n:
  258:             msg = (
  259:                 f"Got unexpected number of arguments, expected {n}. "
  260:                 f'(example: "{get_prog()} config {example}")'
  261:             )
  262:             raise PipError(msg)
  263: 
  264:         if n == 1:
  265:             return args[0]
  266:         else:
  267:             return args
  268: 
  269:     def _save_configuration(self) -> None:
  270:         # We successfully ran a modifying command. Need to save the
  271:         # configuration.
  272:         try:
  273:             self.configuration.save()
  274:         except Exception:
  275:             logger.exception(
  276:                 "Unable to save configuration. Please report this as a bug."
  277:             )
  278:             raise PipError("Internal Error.")
  279: 
  280:     def _determine_editor(self, options: Values) -> str:
  281:         if options.editor is not None:
  282:             return options.editor
  283:         elif "VISUAL" in os.environ:
  284:             return os.environ["VISUAL"]
  285:         elif "EDITOR" in os.environ:
  286:             return os.environ["EDITOR"]
  287:         else:
  288:             raise PipError("Could not determine editor to use.")
