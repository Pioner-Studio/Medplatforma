    1: from __future__ import annotations
    2: 
    3: import locale
    4: import logging
    5: import os
    6: import sys
    7: from optparse import Values
    8: from types import ModuleType
    9: from typing import Any
   10: 
   11: import pip._vendor
   12: from pip._vendor.certifi import where
   13: from pip._vendor.packaging.version import parse as parse_version
   14: 
   15: from pip._internal.cli import cmdoptions
   16: from pip._internal.cli.base_command import Command
   17: from pip._internal.cli.cmdoptions import make_target_python
   18: from pip._internal.cli.status_codes import SUCCESS
   19: from pip._internal.configuration import Configuration
   20: from pip._internal.metadata import get_environment
   21: from pip._internal.utils.compat import open_text_resource
   22: from pip._internal.utils.logging import indent_log
   23: from pip._internal.utils.misc import get_pip_version
   24: 
   25: logger = logging.getLogger(__name__)
   26: 
   27: 
   28: def show_value(name: str, value: Any) -> None:
   29:     logger.info("%s: %s", name, value)
   30: 
   31: 
   32: def show_sys_implementation() -> None:
   33:     logger.info("sys.implementation:")
   34:     implementation_name = sys.implementation.name
   35:     with indent_log():
   36:         show_value("name", implementation_name)
   37: 
   38: 
   39: def create_vendor_txt_map() -> dict[str, str]:
   40:     with open_text_resource("pip._vendor", "vendor.txt") as f:
   41:         # Purge non version specifying lines.
   42:         # Also, remove any space prefix or suffixes (including comments).
   43:         lines = [
   44:             line.strip().split(" ", 1)[0] for line in f.readlines() if "==" in line
   45:         ]
   46: 
   47:     # Transform into "module" -> version dict.
   48:     return dict(line.split("==", 1) for line in lines)
   49: 
   50: 
   51: def get_module_from_module_name(module_name: str) -> ModuleType | None:
   52:     # Module name can be uppercase in vendor.txt for some reason...
   53:     module_name = module_name.lower().replace("-", "_")
   54:     # PATCH: setuptools is actually only pkg_resources.
   55:     if module_name == "setuptools":
   56:         module_name = "pkg_resources"
   57: 
   58:     try:
   59:         __import__(f"pip._vendor.{module_name}", globals(), locals(), level=0)
   60:         return getattr(pip._vendor, module_name)
   61:     except ImportError:
   62:         # We allow 'truststore' to fail to import due
   63:         # to being unavailable on Python 3.9 and earlier.
   64:         if module_name == "truststore" and sys.version_info < (3, 10):
   65:             return None
   66:         raise
   67: 
   68: 
   69: def get_vendor_version_from_module(module_name: str) -> str | None:
   70:     module = get_module_from_module_name(module_name)
   71:     version = getattr(module, "__version__", None)
   72: 
   73:     if module and not version:
   74:         # Try to find version in debundled module info.
   75:         assert module.__file__ is not None
   76:         env = get_environment([os.path.dirname(module.__file__)])
   77:         dist = env.get_distribution(module_name)
   78:         if dist:
   79:             version = str(dist.version)
   80: 
   81:     return version
   82: 
   83: 
   84: def show_actual_vendor_versions(vendor_txt_versions: dict[str, str]) -> None:
   85:     """Log the actual version and print extra info if there is
   86:     a conflict or if the actual version could not be imported.
   87:     """
   88:     for module_name, expected_version in vendor_txt_versions.items():
   89:         extra_message = ""
   90:         actual_version = get_vendor_version_from_module(module_name)
   91:         if not actual_version:
   92:             extra_message = (
   93:                 " (Unable to locate actual module version, using"
   94:                 " vendor.txt specified version)"
   95:             )
   96:             actual_version = expected_version
   97:         elif parse_version(actual_version) != parse_version(expected_version):
   98:             extra_message = (
   99:                 " (CONFLICT: vendor.txt suggests version should"
  100:                 f" be {expected_version})"
  101:             )
  102:         logger.info("%s==%s%s", module_name, actual_version, extra_message)
  103: 
  104: 
  105: def show_vendor_versions() -> None:
  106:     logger.info("vendored library versions:")
  107: 
  108:     vendor_txt_versions = create_vendor_txt_map()
  109:     with indent_log():
  110:         show_actual_vendor_versions(vendor_txt_versions)
  111: 
  112: 
  113: def show_tags(options: Values) -> None:
  114:     tag_limit = 10
  115: 
  116:     target_python = make_target_python(options)
  117:     tags = target_python.get_sorted_tags()
  118: 
  119:     # Display the target options that were explicitly provided.
  120:     formatted_target = target_python.format_given()
  121:     suffix = ""
  122:     if formatted_target:
  123:         suffix = f" (target: {formatted_target})"
  124: 
  125:     msg = f"Compatible tags: {len(tags)}{suffix}"
  126:     logger.info(msg)
  127: 
  128:     if options.verbose < 1 and len(tags) > tag_limit:
  129:         tags_limited = True
  130:         tags = tags[:tag_limit]
  131:     else:
  132:         tags_limited = False
  133: 
  134:     with indent_log():
  135:         for tag in tags:
  136:             logger.info(str(tag))
  137: 
  138:         if tags_limited:
  139:             msg = f"...\n[First {tag_limit} tags shown. Pass --verbose to show all.]"
  140:             logger.info(msg)
  141: 
  142: 
  143: def ca_bundle_info(config: Configuration) -> str:
  144:     levels = {key.split(".", 1)[0] for key, _ in config.items()}
  145:     if not levels:
  146:         return "Not specified"
  147: 
  148:     levels_that_override_global = ["install", "wheel", "download"]
  149:     global_overriding_level = [
  150:         level for level in levels if level in levels_that_override_global
  151:     ]
  152:     if not global_overriding_level:
  153:         return "global"
  154: 
  155:     if "global" in levels:
  156:         levels.remove("global")
  157:     return ", ".join(levels)
  158: 
  159: 
  160: class DebugCommand(Command):
  161:     """
  162:     Display debug information.
  163:     """
  164: 
  165:     usage = """
  166:       %prog <options>"""
  167:     ignore_require_venv = True
  168: 
  169:     def add_options(self) -> None:
  170:         cmdoptions.add_target_python_options(self.cmd_opts)
  171:         self.parser.insert_option_group(0, self.cmd_opts)
  172:         self.parser.config.load()
  173: 
  174:     def run(self, options: Values, args: list[str]) -> int:
  175:         logger.warning(
  176:             "This command is only meant for debugging. "
  177:             "Do not use this with automation for parsing and getting these "
  178:             "details, since the output and options of this command may "
  179:             "change without notice."
  180:         )
  181:         show_value("pip version", get_pip_version())
  182:         show_value("sys.version", sys.version)
  183:         show_value("sys.executable", sys.executable)
  184:         show_value("sys.getdefaultencoding", sys.getdefaultencoding())
  185:         show_value("sys.getfilesystemencoding", sys.getfilesystemencoding())
  186:         show_value(
  187:             "locale.getpreferredencoding",
  188:             locale.getpreferredencoding(),
  189:         )
  190:         show_value("sys.platform", sys.platform)
  191:         show_sys_implementation()
  192: 
  193:         show_value("'cert' config value", ca_bundle_info(self.parser.config))
  194:         show_value("REQUESTS_CA_BUNDLE", os.environ.get("REQUESTS_CA_BUNDLE"))
  195:         show_value("CURL_CA_BUNDLE", os.environ.get("CURL_CA_BUNDLE"))
  196:         show_value("pip._vendor.certifi.where()", where())
  197:         show_value("pip._vendor.DEBUNDLED", pip._vendor.DEBUNDLED)
  198: 
  199:         show_vendor_versions()
  200: 
  201:         show_tags(options)
  202: 
  203:         return SUCCESS
