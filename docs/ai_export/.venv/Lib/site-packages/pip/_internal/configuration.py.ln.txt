    1: """Configuration management setup
    2: 
    3: Some terminology:
    4: - name
    5:   As written in config files.
    6: - value
    7:   Value associated with a name
    8: - key
    9:   Name combined with it's section (section.name)
   10: - variant
   11:   A single word describing where the configuration key-value pair came from
   12: """
   13: 
   14: from __future__ import annotations
   15: 
   16: import configparser
   17: import locale
   18: import os
   19: import sys
   20: from collections.abc import Iterable
   21: from typing import Any, NewType
   22: 
   23: from pip._internal.exceptions import (
   24:     ConfigurationError,
   25:     ConfigurationFileCouldNotBeLoaded,
   26: )
   27: from pip._internal.utils import appdirs
   28: from pip._internal.utils.compat import WINDOWS
   29: from pip._internal.utils.logging import getLogger
   30: from pip._internal.utils.misc import ensure_dir, enum
   31: 
   32: RawConfigParser = configparser.RawConfigParser  # Shorthand
   33: Kind = NewType("Kind", str)
   34: 
   35: CONFIG_BASENAME = "pip.ini" if WINDOWS else "pip.conf"
   36: ENV_NAMES_IGNORED = "version", "help"
   37: 
   38: # The kinds of configurations there are.
   39: kinds = enum(
   40:     USER="user",  # User Specific
   41:     GLOBAL="global",  # System Wide
   42:     SITE="site",  # [Virtual] Environment Specific
   43:     ENV="env",  # from PIP_CONFIG_FILE
   44:     ENV_VAR="env-var",  # from Environment Variables
   45: )
   46: OVERRIDE_ORDER = kinds.GLOBAL, kinds.USER, kinds.SITE, kinds.ENV, kinds.ENV_VAR
   47: VALID_LOAD_ONLY = kinds.USER, kinds.GLOBAL, kinds.SITE
   48: 
   49: logger = getLogger(__name__)
   50: 
   51: 
   52: # NOTE: Maybe use the optionx attribute to normalize keynames.
   53: def _normalize_name(name: str) -> str:
   54:     """Make a name consistent regardless of source (environment or file)"""
   55:     name = name.lower().replace("_", "-")
   56:     if name.startswith("--"):
   57:         name = name[2:]  # only prefer long opts
   58:     return name
   59: 
   60: 
   61: def _disassemble_key(name: str) -> list[str]:
   62:     if "." not in name:
   63:         error_message = (
   64:             "Key does not contain dot separated section and key. "
   65:             f"Perhaps you wanted to use 'global.{name}' instead?"
   66:         )
   67:         raise ConfigurationError(error_message)
   68:     return name.split(".", 1)
   69: 
   70: 
   71: def get_configuration_files() -> dict[Kind, list[str]]:
   72:     global_config_files = [
   73:         os.path.join(path, CONFIG_BASENAME) for path in appdirs.site_config_dirs("pip")
   74:     ]
   75: 
   76:     site_config_file = os.path.join(sys.prefix, CONFIG_BASENAME)
   77:     legacy_config_file = os.path.join(
   78:         os.path.expanduser("~"),
   79:         "pip" if WINDOWS else ".pip",
   80:         CONFIG_BASENAME,
   81:     )
   82:     new_config_file = os.path.join(appdirs.user_config_dir("pip"), CONFIG_BASENAME)
   83:     return {
   84:         kinds.GLOBAL: global_config_files,
   85:         kinds.SITE: [site_config_file],
   86:         kinds.USER: [legacy_config_file, new_config_file],
   87:     }
   88: 
   89: 
   90: class Configuration:
   91:     """Handles management of configuration.
   92: 
   93:     Provides an interface to accessing and managing configuration files.
   94: 
   95:     This class converts provides an API that takes "section.key-name" style
   96:     keys and stores the value associated with it as "key-name" under the
   97:     section "section".
   98: 
   99:     This allows for a clean interface wherein the both the section and the
  100:     key-name are preserved in an easy to manage form in the configuration files
  101:     and the data stored is also nice.
  102:     """
  103: 
  104:     def __init__(self, isolated: bool, load_only: Kind | None = None) -> None:
  105:         super().__init__()
  106: 
  107:         if load_only is not None and load_only not in VALID_LOAD_ONLY:
  108:             raise ConfigurationError(
  109:                 "Got invalid value for load_only - should be one of {}".format(
  110:                     ", ".join(map(repr, VALID_LOAD_ONLY))
  111:                 )
  112:             )
  113:         self.isolated = isolated
  114:         self.load_only = load_only
  115: 
  116:         # Because we keep track of where we got the data from
  117:         self._parsers: dict[Kind, list[tuple[str, RawConfigParser]]] = {
  118:             variant: [] for variant in OVERRIDE_ORDER
  119:         }
  120:         self._config: dict[Kind, dict[str, dict[str, Any]]] = {
  121:             variant: {} for variant in OVERRIDE_ORDER
  122:         }
  123:         self._modified_parsers: list[tuple[str, RawConfigParser]] = []
  124: 
  125:     def load(self) -> None:
  126:         """Loads configuration from configuration files and environment"""
  127:         self._load_config_files()
  128:         if not self.isolated:
  129:             self._load_environment_vars()
  130: 
  131:     def get_file_to_edit(self) -> str | None:
  132:         """Returns the file with highest priority in configuration"""
  133:         assert self.load_only is not None, "Need to be specified a file to be editing"
  134: 
  135:         try:
  136:             return self._get_parser_to_modify()[0]
  137:         except IndexError:
  138:             return None
  139: 
  140:     def items(self) -> Iterable[tuple[str, Any]]:
  141:         """Returns key-value pairs like dict.items() representing the loaded
  142:         configuration
  143:         """
  144:         return self._dictionary.items()
  145: 
  146:     def get_value(self, key: str) -> Any:
  147:         """Get a value from the configuration."""
  148:         orig_key = key
  149:         key = _normalize_name(key)
  150:         try:
  151:             clean_config: dict[str, Any] = {}
  152:             for file_values in self._dictionary.values():
  153:                 clean_config.update(file_values)
  154:             return clean_config[key]
  155:         except KeyError:
  156:             # disassembling triggers a more useful error message than simply
  157:             # "No such key" in the case that the key isn't in the form command.option
  158:             _disassemble_key(key)
  159:             raise ConfigurationError(f"No such key - {orig_key}")
  160: 
  161:     def set_value(self, key: str, value: Any) -> None:
  162:         """Modify a value in the configuration."""
  163:         key = _normalize_name(key)
  164:         self._ensure_have_load_only()
  165: 
  166:         assert self.load_only
  167:         fname, parser = self._get_parser_to_modify()
  168: 
  169:         if parser is not None:
  170:             section, name = _disassemble_key(key)
  171: 
  172:             # Modify the parser and the configuration
  173:             if not parser.has_section(section):
  174:                 parser.add_section(section)
  175:             parser.set(section, name, value)
  176: 
  177:         self._config[self.load_only].setdefault(fname, {})
  178:         self._config[self.load_only][fname][key] = value
  179:         self._mark_as_modified(fname, parser)
  180: 
  181:     def unset_value(self, key: str) -> None:
  182:         """Unset a value in the configuration."""
  183:         orig_key = key
  184:         key = _normalize_name(key)
  185:         self._ensure_have_load_only()
  186: 
  187:         assert self.load_only
  188:         fname, parser = self._get_parser_to_modify()
  189: 
  190:         if (
  191:             key not in self._config[self.load_only][fname]
  192:             and key not in self._config[self.load_only]
  193:         ):
  194:             raise ConfigurationError(f"No such key - {orig_key}")
  195: 
  196:         if parser is not None:
  197:             section, name = _disassemble_key(key)
  198:             if not (
  199:                 parser.has_section(section) and parser.remove_option(section, name)
  200:             ):
  201:                 # The option was not removed.
  202:                 raise ConfigurationError(
  203:                     "Fatal Internal error [id=1]. Please report as a bug."
  204:                 )
  205: 
  206:             # The section may be empty after the option was removed.
  207:             if not parser.items(section):
  208:                 parser.remove_section(section)
  209:             self._mark_as_modified(fname, parser)
  210:         try:
  211:             del self._config[self.load_only][fname][key]
  212:         except KeyError:
  213:             del self._config[self.load_only][key]
  214: 
  215:     def save(self) -> None:
  216:         """Save the current in-memory state."""
  217:         self._ensure_have_load_only()
  218: 
  219:         for fname, parser in self._modified_parsers:
  220:             logger.info("Writing to %s", fname)
  221: 
  222:             # Ensure directory exists.
  223:             ensure_dir(os.path.dirname(fname))
  224: 
  225:             # Ensure directory's permission(need to be writeable)
  226:             try:
  227:                 with open(fname, "w") as f:
  228:                     parser.write(f)
  229:             except OSError as error:
  230:                 raise ConfigurationError(
  231:                     f"An error occurred while writing to the configuration file "
  232:                     f"{fname}: {error}"
  233:                 )
  234: 
  235:     #
  236:     # Private routines
  237:     #
  238: 
  239:     def _ensure_have_load_only(self) -> None:
  240:         if self.load_only is None:
  241:             raise ConfigurationError("Needed a specific file to be modifying.")
  242:         logger.debug("Will be working with %s variant only", self.load_only)
  243: 
  244:     @property
  245:     def _dictionary(self) -> dict[str, dict[str, Any]]:
  246:         """A dictionary representing the loaded configuration."""
  247:         # NOTE: Dictionaries are not populated if not loaded. So, conditionals
  248:         #       are not needed here.
  249:         retval = {}
  250: 
  251:         for variant in OVERRIDE_ORDER:
  252:             retval.update(self._config[variant])
  253: 
  254:         return retval
  255: 
  256:     def _load_config_files(self) -> None:
  257:         """Loads configuration from configuration files"""
  258:         config_files = dict(self.iter_config_files())
  259:         if config_files[kinds.ENV][0:1] == [os.devnull]:
  260:             logger.debug(
  261:                 "Skipping loading configuration files due to "
  262:                 "environment's PIP_CONFIG_FILE being os.devnull"
  263:             )
  264:             return
  265: 
  266:         for variant, files in config_files.items():
  267:             for fname in files:
  268:                 # If there's specific variant set in `load_only`, load only
  269:                 # that variant, not the others.
  270:                 if self.load_only is not None and variant != self.load_only:
  271:                     logger.debug("Skipping file '%s' (variant: %s)", fname, variant)
  272:                     continue
  273: 
  274:                 parser = self._load_file(variant, fname)
  275: 
  276:                 # Keeping track of the parsers used
  277:                 self._parsers[variant].append((fname, parser))
  278: 
  279:     def _load_file(self, variant: Kind, fname: str) -> RawConfigParser:
  280:         logger.verbose("For variant '%s', will try loading '%s'", variant, fname)
  281:         parser = self._construct_parser(fname)
  282: 
  283:         for section in parser.sections():
  284:             items = parser.items(section)
  285:             self._config[variant].setdefault(fname, {})
  286:             self._config[variant][fname].update(self._normalized_keys(section, items))
  287: 
  288:         return parser
  289: 
  290:     def _construct_parser(self, fname: str) -> RawConfigParser:
  291:         parser = configparser.RawConfigParser()
  292:         # If there is no such file, don't bother reading it but create the
  293:         # parser anyway, to hold the data.
  294:         # Doing this is useful when modifying and saving files, where we don't
  295:         # need to construct a parser.
  296:         if os.path.exists(fname):
  297:             locale_encoding = locale.getpreferredencoding(False)
  298:             try:
  299:                 parser.read(fname, encoding=locale_encoding)
  300:             except UnicodeDecodeError:
  301:                 # See https://github.com/pypa/pip/issues/4963
  302:                 raise ConfigurationFileCouldNotBeLoaded(
  303:                     reason=f"contains invalid {locale_encoding} characters",
  304:                     fname=fname,
  305:                 )
  306:             except configparser.Error as error:
  307:                 # See https://github.com/pypa/pip/issues/4893
  308:                 raise ConfigurationFileCouldNotBeLoaded(error=error)
  309:         return parser
  310: 
  311:     def _load_environment_vars(self) -> None:
  312:         """Loads configuration from environment variables"""
  313:         self._config[kinds.ENV_VAR].setdefault(":env:", {})
  314:         self._config[kinds.ENV_VAR][":env:"].update(
  315:             self._normalized_keys(":env:", self.get_environ_vars())
  316:         )
  317: 
  318:     def _normalized_keys(
  319:         self, section: str, items: Iterable[tuple[str, Any]]
  320:     ) -> dict[str, Any]:
  321:         """Normalizes items to construct a dictionary with normalized keys.
  322: 
  323:         This routine is where the names become keys and are made the same
  324:         regardless of source - configuration files or environment.
  325:         """
  326:         normalized = {}
  327:         for name, val in items:
  328:             key = section + "." + _normalize_name(name)
  329:             normalized[key] = val
  330:         return normalized
  331: 
  332:     def get_environ_vars(self) -> Iterable[tuple[str, str]]:
  333:         """Returns a generator with all environmental vars with prefix PIP_"""
  334:         for key, val in os.environ.items():
  335:             if key.startswith("PIP_"):
  336:                 name = key[4:].lower()
  337:                 if name not in ENV_NAMES_IGNORED:
  338:                     yield name, val
  339: 
  340:     # XXX: This is patched in the tests.
  341:     def iter_config_files(self) -> Iterable[tuple[Kind, list[str]]]:
  342:         """Yields variant and configuration files associated with it.
  343: 
  344:         This should be treated like items of a dictionary. The order
  345:         here doesn't affect what gets overridden. That is controlled
  346:         by OVERRIDE_ORDER. However this does control the order they are
  347:         displayed to the user. It's probably most ergonomic to display
  348:         things in the same order as OVERRIDE_ORDER
  349:         """
  350:         # SMELL: Move the conditions out of this function
  351: 
  352:         env_config_file = os.environ.get("PIP_CONFIG_FILE", None)
  353:         config_files = get_configuration_files()
  354: 
  355:         yield kinds.GLOBAL, config_files[kinds.GLOBAL]
  356: 
  357:         # per-user config is not loaded when env_config_file exists
  358:         should_load_user_config = not self.isolated and not (
  359:             env_config_file and os.path.exists(env_config_file)
  360:         )
  361:         if should_load_user_config:
  362:             # The legacy config file is overridden by the new config file
  363:             yield kinds.USER, config_files[kinds.USER]
  364: 
  365:         # virtualenv config
  366:         yield kinds.SITE, config_files[kinds.SITE]
  367: 
  368:         if env_config_file is not None:
  369:             yield kinds.ENV, [env_config_file]
  370:         else:
  371:             yield kinds.ENV, []
  372: 
  373:     def get_values_in_config(self, variant: Kind) -> dict[str, Any]:
  374:         """Get values present in a config file"""
  375:         return self._config[variant]
  376: 
  377:     def _get_parser_to_modify(self) -> tuple[str, RawConfigParser]:
  378:         # Determine which parser to modify
  379:         assert self.load_only
  380:         parsers = self._parsers[self.load_only]
  381:         if not parsers:
  382:             # This should not happen if everything works correctly.
  383:             raise ConfigurationError(
  384:                 "Fatal Internal error [id=2]. Please report as a bug."
  385:             )
  386: 
  387:         # Use the highest priority parser.
  388:         return parsers[-1]
  389: 
  390:     # XXX: This is patched in the tests.
  391:     def _mark_as_modified(self, fname: str, parser: RawConfigParser) -> None:
  392:         file_parser_tuple = (fname, parser)
  393:         if file_parser_tuple not in self._modified_parsers:
  394:             self._modified_parsers.append(file_parser_tuple)
  395: 
  396:     def __repr__(self) -> str:
  397:         return f"{self.__class__.__name__}({self._dictionary!r})"
