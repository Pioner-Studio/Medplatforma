    1: """Orchestrator for building wheels from InstallRequirements."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import logging
    6: import os.path
    7: import re
    8: import shutil
    9: from collections.abc import Iterable
   10: 
   11: from pip._vendor.packaging.utils import canonicalize_name, canonicalize_version
   12: from pip._vendor.packaging.version import InvalidVersion, Version
   13: 
   14: from pip._internal.cache import WheelCache
   15: from pip._internal.exceptions import InvalidWheelFilename, UnsupportedWheel
   16: from pip._internal.metadata import FilesystemWheel, get_wheel_distribution
   17: from pip._internal.models.link import Link
   18: from pip._internal.models.wheel import Wheel
   19: from pip._internal.operations.build.wheel import build_wheel_pep517
   20: from pip._internal.operations.build.wheel_editable import build_wheel_editable
   21: from pip._internal.operations.build.wheel_legacy import build_wheel_legacy
   22: from pip._internal.req.req_install import InstallRequirement
   23: from pip._internal.utils.logging import indent_log
   24: from pip._internal.utils.misc import ensure_dir, hash_file
   25: from pip._internal.utils.setuptools_build import make_setuptools_clean_args
   26: from pip._internal.utils.subprocess import call_subprocess
   27: from pip._internal.utils.temp_dir import TempDirectory
   28: from pip._internal.utils.urls import path_to_url
   29: from pip._internal.vcs import vcs
   30: 
   31: logger = logging.getLogger(__name__)
   32: 
   33: _egg_info_re = re.compile(r"([a-z0-9_.]+)-([a-z0-9_.!+-]+)", re.IGNORECASE)
   34: 
   35: BuildResult = tuple[list[InstallRequirement], list[InstallRequirement]]
   36: 
   37: 
   38: def _contains_egg_info(s: str) -> bool:
   39:     """Determine whether the string looks like an egg_info.
   40: 
   41:     :param s: The string to parse. E.g. foo-2.1
   42:     """
   43:     return bool(_egg_info_re.search(s))
   44: 
   45: 
   46: def _should_build(
   47:     req: InstallRequirement,
   48: ) -> bool:
   49:     """Return whether an InstallRequirement should be built into a wheel."""
   50:     assert not req.constraint
   51: 
   52:     if req.is_wheel:
   53:         return False
   54: 
   55:     assert req.source_dir
   56: 
   57:     if req.editable:
   58:         # we only build PEP 660 editable requirements
   59:         return req.supports_pyproject_editable
   60: 
   61:     return True
   62: 
   63: 
   64: def should_build_for_install_command(
   65:     req: InstallRequirement,
   66: ) -> bool:
   67:     return _should_build(req)
   68: 
   69: 
   70: def _should_cache(
   71:     req: InstallRequirement,
   72: ) -> bool | None:
   73:     """
   74:     Return whether a built InstallRequirement can be stored in the persistent
   75:     wheel cache, assuming the wheel cache is available, and _should_build()
   76:     has determined a wheel needs to be built.
   77:     """
   78:     if req.editable or not req.source_dir:
   79:         # never cache editable requirements
   80:         return False
   81: 
   82:     if req.link and req.link.is_vcs:
   83:         # VCS checkout. Do not cache
   84:         # unless it points to an immutable commit hash.
   85:         assert not req.editable
   86:         assert req.source_dir
   87:         vcs_backend = vcs.get_backend_for_scheme(req.link.scheme)
   88:         assert vcs_backend
   89:         if vcs_backend.is_immutable_rev_checkout(req.link.url, req.source_dir):
   90:             return True
   91:         return False
   92: 
   93:     assert req.link
   94:     base, ext = req.link.splitext()
   95:     if _contains_egg_info(base):
   96:         return True
   97: 
   98:     # Otherwise, do not cache.
   99:     return False
  100: 
  101: 
  102: def _get_cache_dir(
  103:     req: InstallRequirement,
  104:     wheel_cache: WheelCache,
  105: ) -> str:
  106:     """Return the persistent or temporary cache directory where the built
  107:     wheel need to be stored.
  108:     """
  109:     cache_available = bool(wheel_cache.cache_dir)
  110:     assert req.link
  111:     if cache_available and _should_cache(req):
  112:         cache_dir = wheel_cache.get_path_for_link(req.link)
  113:     else:
  114:         cache_dir = wheel_cache.get_ephem_path_for_link(req.link)
  115:     return cache_dir
  116: 
  117: 
  118: def _verify_one(req: InstallRequirement, wheel_path: str) -> None:
  119:     canonical_name = canonicalize_name(req.name or "")
  120:     w = Wheel(os.path.basename(wheel_path))
  121:     if canonicalize_name(w.name) != canonical_name:
  122:         raise InvalidWheelFilename(
  123:             f"Wheel has unexpected file name: expected {canonical_name!r}, "
  124:             f"got {w.name!r}",
  125:         )
  126:     dist = get_wheel_distribution(FilesystemWheel(wheel_path), canonical_name)
  127:     dist_verstr = str(dist.version)
  128:     if canonicalize_version(dist_verstr) != canonicalize_version(w.version):
  129:         raise InvalidWheelFilename(
  130:             f"Wheel has unexpected file name: expected {dist_verstr!r}, "
  131:             f"got {w.version!r}",
  132:         )
  133:     metadata_version_value = dist.metadata_version
  134:     if metadata_version_value is None:
  135:         raise UnsupportedWheel("Missing Metadata-Version")
  136:     try:
  137:         metadata_version = Version(metadata_version_value)
  138:     except InvalidVersion:
  139:         msg = f"Invalid Metadata-Version: {metadata_version_value}"
  140:         raise UnsupportedWheel(msg)
  141:     if metadata_version >= Version("1.2") and not isinstance(dist.version, Version):
  142:         raise UnsupportedWheel(
  143:             f"Metadata 1.2 mandates PEP 440 version, but {dist_verstr!r} is not"
  144:         )
  145: 
  146: 
  147: def _build_one(
  148:     req: InstallRequirement,
  149:     output_dir: str,
  150:     verify: bool,
  151:     build_options: list[str],
  152:     global_options: list[str],
  153:     editable: bool,
  154: ) -> str | None:
  155:     """Build one wheel.
  156: 
  157:     :return: The filename of the built wheel, or None if the build failed.
  158:     """
  159:     artifact = "editable" if editable else "wheel"
  160:     try:
  161:         ensure_dir(output_dir)
  162:     except OSError as e:
  163:         logger.warning(
  164:             "Building %s for %s failed: %s",
  165:             artifact,
  166:             req.name,
  167:             e,
  168:         )
  169:         return None
  170: 
  171:     # Install build deps into temporary directory (PEP 518)
  172:     with req.build_env:
  173:         wheel_path = _build_one_inside_env(
  174:             req, output_dir, build_options, global_options, editable
  175:         )
  176:     if wheel_path and verify:
  177:         try:
  178:             _verify_one(req, wheel_path)
  179:         except (InvalidWheelFilename, UnsupportedWheel) as e:
  180:             logger.warning("Built %s for %s is invalid: %s", artifact, req.name, e)
  181:             return None
  182:     return wheel_path
  183: 
  184: 
  185: def _build_one_inside_env(
  186:     req: InstallRequirement,
  187:     output_dir: str,
  188:     build_options: list[str],
  189:     global_options: list[str],
  190:     editable: bool,
  191: ) -> str | None:
  192:     with TempDirectory(kind="wheel") as temp_dir:
  193:         assert req.name
  194:         if req.use_pep517:
  195:             assert req.metadata_directory
  196:             assert req.pep517_backend
  197:             if global_options:
  198:                 logger.warning(
  199:                     "Ignoring --global-option when building %s using PEP 517", req.name
  200:                 )
  201:             if build_options:
  202:                 logger.warning(
  203:                     "Ignoring --build-option when building %s using PEP 517", req.name
  204:                 )
  205:             if editable:
  206:                 wheel_path = build_wheel_editable(
  207:                     name=req.name,
  208:                     backend=req.pep517_backend,
  209:                     metadata_directory=req.metadata_directory,
  210:                     tempd=temp_dir.path,
  211:                 )
  212:             else:
  213:                 wheel_path = build_wheel_pep517(
  214:                     name=req.name,
  215:                     backend=req.pep517_backend,
  216:                     metadata_directory=req.metadata_directory,
  217:                     tempd=temp_dir.path,
  218:                 )
  219:         else:
  220:             wheel_path = build_wheel_legacy(
  221:                 name=req.name,
  222:                 setup_py_path=req.setup_py_path,
  223:                 source_dir=req.unpacked_source_directory,
  224:                 global_options=global_options,
  225:                 build_options=build_options,
  226:                 tempd=temp_dir.path,
  227:             )
  228: 
  229:         if wheel_path is not None:
  230:             wheel_name = os.path.basename(wheel_path)
  231:             dest_path = os.path.join(output_dir, wheel_name)
  232:             try:
  233:                 wheel_hash, length = hash_file(wheel_path)
  234:                 shutil.move(wheel_path, dest_path)
  235:                 logger.info(
  236:                     "Created wheel for %s: filename=%s size=%d sha256=%s",
  237:                     req.name,
  238:                     wheel_name,
  239:                     length,
  240:                     wheel_hash.hexdigest(),
  241:                 )
  242:                 logger.info("Stored in directory: %s", output_dir)
  243:                 return dest_path
  244:             except Exception as e:
  245:                 logger.warning(
  246:                     "Building wheel for %s failed: %s",
  247:                     req.name,
  248:                     e,
  249:                 )
  250:         # Ignore return, we can't do anything else useful.
  251:         if not req.use_pep517:
  252:             _clean_one_legacy(req, global_options)
  253:         return None
  254: 
  255: 
  256: def _clean_one_legacy(req: InstallRequirement, global_options: list[str]) -> bool:
  257:     clean_args = make_setuptools_clean_args(
  258:         req.setup_py_path,
  259:         global_options=global_options,
  260:     )
  261: 
  262:     logger.info("Running setup.py clean for %s", req.name)
  263:     try:
  264:         call_subprocess(
  265:             clean_args, command_desc="python setup.py clean", cwd=req.source_dir
  266:         )
  267:         return True
  268:     except Exception:
  269:         logger.error("Failed cleaning build dir for %s", req.name)
  270:         return False
  271: 
  272: 
  273: def build(
  274:     requirements: Iterable[InstallRequirement],
  275:     wheel_cache: WheelCache,
  276:     verify: bool,
  277:     build_options: list[str],
  278:     global_options: list[str],
  279: ) -> BuildResult:
  280:     """Build wheels.
  281: 
  282:     :return: The list of InstallRequirement that succeeded to build and
  283:         the list of InstallRequirement that failed to build.
  284:     """
  285:     if not requirements:
  286:         return [], []
  287: 
  288:     # Build the wheels.
  289:     logger.info(
  290:         "Building wheels for collected packages: %s",
  291:         ", ".join(req.name for req in requirements),  # type: ignore
  292:     )
  293: 
  294:     with indent_log():
  295:         build_successes, build_failures = [], []
  296:         for req in requirements:
  297:             assert req.name
  298:             cache_dir = _get_cache_dir(req, wheel_cache)
  299:             wheel_file = _build_one(
  300:                 req,
  301:                 cache_dir,
  302:                 verify,
  303:                 build_options,
  304:                 global_options,
  305:                 req.editable and req.permit_editable_wheels,
  306:             )
  307:             if wheel_file:
  308:                 # Record the download origin in the cache
  309:                 if req.download_info is not None:
  310:                     # download_info is guaranteed to be set because when we build an
  311:                     # InstallRequirement it has been through the preparer before, but
  312:                     # let's be cautious.
  313:                     wheel_cache.record_download_origin(cache_dir, req.download_info)
  314:                 # Update the link for this.
  315:                 req.link = Link(path_to_url(wheel_file))
  316:                 req.local_file_path = req.link.file_path
  317:                 assert req.link.is_wheel
  318:                 build_successes.append(req)
  319:             else:
  320:                 build_failures.append(req)
  321: 
  322:     # notify success/failure
  323:     if build_successes:
  324:         logger.info(
  325:             "Successfully built %s",
  326:             " ".join([req.name for req in build_successes]),  # type: ignore
  327:         )
  328:     if build_failures:
  329:         logger.info(
  330:             "Failed to build %s",
  331:             " ".join([req.name for req in build_failures]),  # type: ignore
  332:         )
  333:     # Return a list of requirements that failed to build
  334:     return build_successes, build_failures
