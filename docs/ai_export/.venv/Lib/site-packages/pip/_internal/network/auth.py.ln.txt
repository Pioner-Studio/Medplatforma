    1: """Network Authentication Helpers
    2: 
    3: Contains interface (MultiDomainBasicAuth) and associated glue code for
    4: providing credentials in the context of network requests.
    5: """
    6: 
    7: from __future__ import annotations
    8: 
    9: import logging
   10: import os
   11: import shutil
   12: import subprocess
   13: import sysconfig
   14: import typing
   15: import urllib.parse
   16: from abc import ABC, abstractmethod
   17: from functools import cache
   18: from os.path import commonprefix
   19: from pathlib import Path
   20: from typing import Any, NamedTuple
   21: 
   22: from pip._vendor.requests.auth import AuthBase, HTTPBasicAuth
   23: from pip._vendor.requests.models import Request, Response
   24: from pip._vendor.requests.utils import get_netrc_auth
   25: 
   26: from pip._internal.utils.logging import getLogger
   27: from pip._internal.utils.misc import (
   28:     ask,
   29:     ask_input,
   30:     ask_password,
   31:     remove_auth_from_url,
   32:     split_auth_netloc_from_url,
   33: )
   34: from pip._internal.vcs.versioncontrol import AuthInfo
   35: 
   36: logger = getLogger(__name__)
   37: 
   38: KEYRING_DISABLED = False
   39: 
   40: 
   41: class Credentials(NamedTuple):
   42:     url: str
   43:     username: str
   44:     password: str
   45: 
   46: 
   47: class KeyRingBaseProvider(ABC):
   48:     """Keyring base provider interface"""
   49: 
   50:     has_keyring: bool
   51: 
   52:     @abstractmethod
   53:     def get_auth_info(self, url: str, username: str | None) -> AuthInfo | None: ...
   54: 
   55:     @abstractmethod
   56:     def save_auth_info(self, url: str, username: str, password: str) -> None: ...
   57: 
   58: 
   59: class KeyRingNullProvider(KeyRingBaseProvider):
   60:     """Keyring null provider"""
   61: 
   62:     has_keyring = False
   63: 
   64:     def get_auth_info(self, url: str, username: str | None) -> AuthInfo | None:
   65:         return None
   66: 
   67:     def save_auth_info(self, url: str, username: str, password: str) -> None:
   68:         return None
   69: 
   70: 
   71: class KeyRingPythonProvider(KeyRingBaseProvider):
   72:     """Keyring interface which uses locally imported `keyring`"""
   73: 
   74:     has_keyring = True
   75: 
   76:     def __init__(self) -> None:
   77:         import keyring
   78: 
   79:         self.keyring = keyring
   80: 
   81:     def get_auth_info(self, url: str, username: str | None) -> AuthInfo | None:
   82:         # Support keyring's get_credential interface which supports getting
   83:         # credentials without a username. This is only available for
   84:         # keyring>=15.2.0.
   85:         if hasattr(self.keyring, "get_credential"):
   86:             logger.debug("Getting credentials from keyring for %s", url)
   87:             cred = self.keyring.get_credential(url, username)
   88:             if cred is not None:
   89:                 return cred.username, cred.password
   90:             return None
   91: 
   92:         if username is not None:
   93:             logger.debug("Getting password from keyring for %s", url)
   94:             password = self.keyring.get_password(url, username)
   95:             if password:
   96:                 return username, password
   97:         return None
   98: 
   99:     def save_auth_info(self, url: str, username: str, password: str) -> None:
  100:         self.keyring.set_password(url, username, password)
  101: 
  102: 
  103: class KeyRingCliProvider(KeyRingBaseProvider):
  104:     """Provider which uses `keyring` cli
  105: 
  106:     Instead of calling the keyring package installed alongside pip
  107:     we call keyring on the command line which will enable pip to
  108:     use which ever installation of keyring is available first in
  109:     PATH.
  110:     """
  111: 
  112:     has_keyring = True
  113: 
  114:     def __init__(self, cmd: str) -> None:
  115:         self.keyring = cmd
  116: 
  117:     def get_auth_info(self, url: str, username: str | None) -> AuthInfo | None:
  118:         # This is the default implementation of keyring.get_credential
  119:         # https://github.com/jaraco/keyring/blob/97689324abcf01bd1793d49063e7ca01e03d7d07/keyring/backend.py#L134-L139
  120:         if username is not None:
  121:             password = self._get_password(url, username)
  122:             if password is not None:
  123:                 return username, password
  124:         return None
  125: 
  126:     def save_auth_info(self, url: str, username: str, password: str) -> None:
  127:         return self._set_password(url, username, password)
  128: 
  129:     def _get_password(self, service_name: str, username: str) -> str | None:
  130:         """Mirror the implementation of keyring.get_password using cli"""
  131:         if self.keyring is None:
  132:             return None
  133: 
  134:         cmd = [self.keyring, "get", service_name, username]
  135:         env = os.environ.copy()
  136:         env["PYTHONIOENCODING"] = "utf-8"
  137:         res = subprocess.run(
  138:             cmd,
  139:             stdin=subprocess.DEVNULL,
  140:             stdout=subprocess.PIPE,
  141:             env=env,
  142:         )
  143:         if res.returncode:
  144:             return None
  145:         return res.stdout.decode("utf-8").strip(os.linesep)
  146: 
  147:     def _set_password(self, service_name: str, username: str, password: str) -> None:
  148:         """Mirror the implementation of keyring.set_password using cli"""
  149:         if self.keyring is None:
  150:             return None
  151:         env = os.environ.copy()
  152:         env["PYTHONIOENCODING"] = "utf-8"
  153:         subprocess.run(
  154:             [self.keyring, "set", service_name, username],
  155:             input=f"{password}{os.linesep}".encode(),
  156:             env=env,
  157:             check=True,
  158:         )
  159:         return None
  160: 
  161: 
  162: @cache
  163: def get_keyring_provider(provider: str) -> KeyRingBaseProvider:
  164:     logger.verbose("Keyring provider requested: %s", provider)
  165: 
  166:     # keyring has previously failed and been disabled
  167:     if KEYRING_DISABLED:
  168:         provider = "disabled"
  169:     if provider in ["import", "auto"]:
  170:         try:
  171:             impl = KeyRingPythonProvider()
  172:             logger.verbose("Keyring provider set: import")
  173:             return impl
  174:         except ImportError:
  175:             pass
  176:         except Exception as exc:
  177:             # In the event of an unexpected exception
  178:             # we should warn the user
  179:             msg = "Installed copy of keyring fails with exception %s"
  180:             if provider == "auto":
  181:                 msg = msg + ", trying to find a keyring executable as a fallback"
  182:             logger.warning(msg, exc, exc_info=logger.isEnabledFor(logging.DEBUG))
  183:     if provider in ["subprocess", "auto"]:
  184:         cli = shutil.which("keyring")
  185:         if cli and cli.startswith(sysconfig.get_path("scripts")):
  186:             # all code within this function is stolen from shutil.which implementation
  187:             @typing.no_type_check
  188:             def PATH_as_shutil_which_determines_it() -> str:
  189:                 path = os.environ.get("PATH", None)
  190:                 if path is None:
  191:                     try:
  192:                         path = os.confstr("CS_PATH")
  193:                     except (AttributeError, ValueError):
  194:                         # os.confstr() or CS_PATH is not available
  195:                         path = os.defpath
  196:                 # bpo-35755: Don't use os.defpath if the PATH environment variable is
  197:                 # set to an empty string
  198: 
  199:                 return path
  200: 
  201:             scripts = Path(sysconfig.get_path("scripts"))
  202: 
  203:             paths = []
  204:             for path in PATH_as_shutil_which_determines_it().split(os.pathsep):
  205:                 p = Path(path)
  206:                 try:
  207:                     if not p.samefile(scripts):
  208:                         paths.append(path)
  209:                 except FileNotFoundError:
  210:                     pass
  211: 
  212:             path = os.pathsep.join(paths)
  213: 
  214:             cli = shutil.which("keyring", path=path)
  215: 
  216:         if cli:
  217:             logger.verbose("Keyring provider set: subprocess with executable %s", cli)
  218:             return KeyRingCliProvider(cli)
  219: 
  220:     logger.verbose("Keyring provider set: disabled")
  221:     return KeyRingNullProvider()
  222: 
  223: 
  224: class MultiDomainBasicAuth(AuthBase):
  225:     def __init__(
  226:         self,
  227:         prompting: bool = True,
  228:         index_urls: list[str] | None = None,
  229:         keyring_provider: str = "auto",
  230:     ) -> None:
  231:         self.prompting = prompting
  232:         self.index_urls = index_urls
  233:         self.keyring_provider = keyring_provider
  234:         self.passwords: dict[str, AuthInfo] = {}
  235:         # When the user is prompted to enter credentials and keyring is
  236:         # available, we will offer to save them. If the user accepts,
  237:         # this value is set to the credentials they entered. After the
  238:         # request authenticates, the caller should call
  239:         # ``save_credentials`` to save these.
  240:         self._credentials_to_save: Credentials | None = None
  241: 
  242:     @property
  243:     def keyring_provider(self) -> KeyRingBaseProvider:
  244:         return get_keyring_provider(self._keyring_provider)
  245: 
  246:     @keyring_provider.setter
  247:     def keyring_provider(self, provider: str) -> None:
  248:         # The free function get_keyring_provider has been decorated with
  249:         # functools.cache. If an exception occurs in get_keyring_auth that
  250:         # cache will be cleared and keyring disabled, take that into account
  251:         # if you want to remove this indirection.
  252:         self._keyring_provider = provider
  253: 
  254:     @property
  255:     def use_keyring(self) -> bool:
  256:         # We won't use keyring when --no-input is passed unless
  257:         # a specific provider is requested because it might require
  258:         # user interaction
  259:         return self.prompting or self._keyring_provider not in ["auto", "disabled"]
  260: 
  261:     def _get_keyring_auth(
  262:         self,
  263:         url: str | None,
  264:         username: str | None,
  265:     ) -> AuthInfo | None:
  266:         """Return the tuple auth for a given url from keyring."""
  267:         # Do nothing if no url was provided
  268:         if not url:
  269:             return None
  270: 
  271:         try:
  272:             return self.keyring_provider.get_auth_info(url, username)
  273:         except Exception as exc:
  274:             # Log the full exception (with stacktrace) at debug, so it'll only
  275:             # show up when running in verbose mode.
  276:             logger.debug("Keyring is skipped due to an exception", exc_info=True)
  277:             # Always log a shortened version of the exception.
  278:             logger.warning(
  279:                 "Keyring is skipped due to an exception: %s",
  280:                 str(exc),
  281:             )
  282:             global KEYRING_DISABLED
  283:             KEYRING_DISABLED = True
  284:             get_keyring_provider.cache_clear()
  285:             return None
  286: 
  287:     def _get_index_url(self, url: str) -> str | None:
  288:         """Return the original index URL matching the requested URL.
  289: 
  290:         Cached or dynamically generated credentials may work against
  291:         the original index URL rather than just the netloc.
  292: 
  293:         The provided url should have had its username and password
  294:         removed already. If the original index url had credentials then
  295:         they will be included in the return value.
  296: 
  297:         Returns None if no matching index was found, or if --no-index
  298:         was specified by the user.
  299:         """
  300:         if not url or not self.index_urls:
  301:             return None
  302: 
  303:         url = remove_auth_from_url(url).rstrip("/") + "/"
  304:         parsed_url = urllib.parse.urlsplit(url)
  305: 
  306:         candidates = []
  307: 
  308:         for index in self.index_urls:
  309:             index = index.rstrip("/") + "/"
  310:             parsed_index = urllib.parse.urlsplit(remove_auth_from_url(index))
  311:             if parsed_url == parsed_index:
  312:                 return index
  313: 
  314:             if parsed_url.netloc != parsed_index.netloc:
  315:                 continue
  316: 
  317:             candidate = urllib.parse.urlsplit(index)
  318:             candidates.append(candidate)
  319: 
  320:         if not candidates:
  321:             return None
  322: 
  323:         candidates.sort(
  324:             reverse=True,
  325:             key=lambda candidate: commonprefix(
  326:                 [
  327:                     parsed_url.path,
  328:                     candidate.path,
  329:                 ]
  330:             ).rfind("/"),
  331:         )
  332: 
  333:         return urllib.parse.urlunsplit(candidates[0])
  334: 
  335:     def _get_new_credentials(
  336:         self,
  337:         original_url: str,
  338:         *,
  339:         allow_netrc: bool = True,
  340:         allow_keyring: bool = False,
  341:     ) -> AuthInfo:
  342:         """Find and return credentials for the specified URL."""
  343:         # Split the credentials and netloc from the url.
  344:         url, netloc, url_user_password = split_auth_netloc_from_url(
  345:             original_url,
  346:         )
  347: 
  348:         # Start with the credentials embedded in the url
  349:         username, password = url_user_password
  350:         if username is not None and password is not None:
  351:             logger.debug("Found credentials in url for %s", netloc)
  352:             return url_user_password
  353: 
  354:         # Find a matching index url for this request
  355:         index_url = self._get_index_url(url)
  356:         if index_url:
  357:             # Split the credentials from the url.
  358:             index_info = split_auth_netloc_from_url(index_url)
  359:             if index_info:
  360:                 index_url, _, index_url_user_password = index_info
  361:                 logger.debug("Found index url %s", index_url)
  362: 
  363:         # If an index URL was found, try its embedded credentials
  364:         if index_url and index_url_user_password[0] is not None:
  365:             username, password = index_url_user_password
  366:             if username is not None and password is not None:
  367:                 logger.debug("Found credentials in index url for %s", netloc)
  368:                 return index_url_user_password
  369: 
  370:         # Get creds from netrc if we still don't have them
  371:         if allow_netrc:
  372:             netrc_auth = get_netrc_auth(original_url)
  373:             if netrc_auth:
  374:                 logger.debug("Found credentials in netrc for %s", netloc)
  375:                 return netrc_auth
  376: 
  377:         # If we don't have a password and keyring is available, use it.
  378:         if allow_keyring:
  379:             # The index url is more specific than the netloc, so try it first
  380:             # fmt: off
  381:             kr_auth = (
  382:                 self._get_keyring_auth(index_url, username) or
  383:                 self._get_keyring_auth(netloc, username)
  384:             )
  385:             # fmt: on
  386:             if kr_auth:
  387:                 logger.debug("Found credentials in keyring for %s", netloc)
  388:                 return kr_auth
  389: 
  390:         return username, password
  391: 
  392:     def _get_url_and_credentials(
  393:         self, original_url: str
  394:     ) -> tuple[str, str | None, str | None]:
  395:         """Return the credentials to use for the provided URL.
  396: 
  397:         If allowed, netrc and keyring may be used to obtain the
  398:         correct credentials.
  399: 
  400:         Returns (url_without_credentials, username, password). Note
  401:         that even if the original URL contains credentials, this
  402:         function may return a different username and password.
  403:         """
  404:         url, netloc, _ = split_auth_netloc_from_url(original_url)
  405: 
  406:         # Try to get credentials from original url
  407:         username, password = self._get_new_credentials(original_url)
  408: 
  409:         # If credentials not found, use any stored credentials for this netloc.
  410:         # Do this if either the username or the password is missing.
  411:         # This accounts for the situation in which the user has specified
  412:         # the username in the index url, but the password comes from keyring.
  413:         if (username is None or password is None) and netloc in self.passwords:
  414:             un, pw = self.passwords[netloc]
  415:             # It is possible that the cached credentials are for a different username,
  416:             # in which case the cache should be ignored.
  417:             if username is None or username == un:
  418:                 username, password = un, pw
  419: 
  420:         if username is not None or password is not None:
  421:             # Convert the username and password if they're None, so that
  422:             # this netloc will show up as "cached" in the conditional above.
  423:             # Further, HTTPBasicAuth doesn't accept None, so it makes sense to
  424:             # cache the value that is going to be used.
  425:             username = username or ""
  426:             password = password or ""
  427: 
  428:             # Store any acquired credentials.
  429:             self.passwords[netloc] = (username, password)
  430: 
  431:         assert (
  432:             # Credentials were found
  433:             (username is not None and password is not None)
  434:             # Credentials were not found
  435:             or (username is None and password is None)
  436:         ), f"Could not load credentials from url: {original_url}"
  437: 
  438:         return url, username, password
  439: 
  440:     def __call__(self, req: Request) -> Request:
  441:         # Get credentials for this request
  442:         url, username, password = self._get_url_and_credentials(req.url)
  443: 
  444:         # Set the url of the request to the url without any credentials
  445:         req.url = url
  446: 
  447:         if username is not None and password is not None:
  448:             # Send the basic auth with this request
  449:             req = HTTPBasicAuth(username, password)(req)
  450: 
  451:         # Attach a hook to handle 401 responses
  452:         req.register_hook("response", self.handle_401)
  453: 
  454:         return req
  455: 
  456:     # Factored out to allow for easy patching in tests
  457:     def _prompt_for_password(self, netloc: str) -> tuple[str | None, str | None, bool]:
  458:         username = ask_input(f"User for {netloc}: ") if self.prompting else None
  459:         if not username:
  460:             return None, None, False
  461:         if self.use_keyring:
  462:             auth = self._get_keyring_auth(netloc, username)
  463:             if auth and auth[0] is not None and auth[1] is not None:
  464:                 return auth[0], auth[1], False
  465:         password = ask_password("Password: ")
  466:         return username, password, True
  467: 
  468:     # Factored out to allow for easy patching in tests
  469:     def _should_save_password_to_keyring(self) -> bool:
  470:         if (
  471:             not self.prompting
  472:             or not self.use_keyring
  473:             or not self.keyring_provider.has_keyring
  474:         ):
  475:             return False
  476:         return ask("Save credentials to keyring [y/N]: ", ["y", "n"]) == "y"
  477: 
  478:     def handle_401(self, resp: Response, **kwargs: Any) -> Response:
  479:         # We only care about 401 responses, anything else we want to just
  480:         #   pass through the actual response
  481:         if resp.status_code != 401:
  482:             return resp
  483: 
  484:         username, password = None, None
  485: 
  486:         # Query the keyring for credentials:
  487:         if self.use_keyring:
  488:             username, password = self._get_new_credentials(
  489:                 resp.url,
  490:                 allow_netrc=False,
  491:                 allow_keyring=True,
  492:             )
  493: 
  494:         # We are not able to prompt the user so simply return the response
  495:         if not self.prompting and not username and not password:
  496:             return resp
  497: 
  498:         parsed = urllib.parse.urlparse(resp.url)
  499: 
  500:         # Prompt the user for a new username and password
  501:         save = False
  502:         if not username and not password:
  503:             username, password, save = self._prompt_for_password(parsed.netloc)
  504: 
  505:         # Store the new username and password to use for future requests
  506:         self._credentials_to_save = None
  507:         if username is not None and password is not None:
  508:             self.passwords[parsed.netloc] = (username, password)
  509: 
  510:             # Prompt to save the password to keyring
  511:             if save and self._should_save_password_to_keyring():
  512:                 self._credentials_to_save = Credentials(
  513:                     url=parsed.netloc,
  514:                     username=username,
  515:                     password=password,
  516:                 )
  517: 
  518:         # Consume content and release the original connection to allow our new
  519:         #   request to reuse the same one.
  520:         # The result of the assignment isn't used, it's just needed to consume
  521:         # the content.
  522:         _ = resp.content
  523:         resp.raw.release_conn()
  524: 
  525:         # Add our new username and password to the request
  526:         req = HTTPBasicAuth(username or "", password or "")(resp.request)
  527:         req.register_hook("response", self.warn_on_401)
  528: 
  529:         # On successful request, save the credentials that were used to
  530:         # keyring. (Note that if the user responded "no" above, this member
  531:         # is not set and nothing will be saved.)
  532:         if self._credentials_to_save:
  533:             req.register_hook("response", self.save_credentials)
  534: 
  535:         # Send our new request
  536:         new_resp = resp.connection.send(req, **kwargs)
  537:         new_resp.history.append(resp)
  538: 
  539:         return new_resp
  540: 
  541:     def warn_on_401(self, resp: Response, **kwargs: Any) -> None:
  542:         """Response callback to warn about incorrect credentials."""
  543:         if resp.status_code == 401:
  544:             logger.warning(
  545:                 "401 Error, Credentials not correct for %s",
  546:                 resp.request.url,
  547:             )
  548: 
  549:     def save_credentials(self, resp: Response, **kwargs: Any) -> None:
  550:         """Response callback to save credentials on success."""
  551:         assert (
  552:             self.keyring_provider.has_keyring
  553:         ), "should never reach here without keyring"
  554: 
  555:         creds = self._credentials_to_save
  556:         self._credentials_to_save = None
  557:         if creds and resp.status_code < 400:
  558:             try:
  559:                 logger.info("Saving credentials to keyring")
  560:                 self.keyring_provider.save_auth_info(
  561:                     creds.url, creds.username, creds.password
  562:                 )
  563:             except Exception:
  564:                 logger.exception("Failed to save credentials")
