    1: """Lazy ZIP over HTTP"""
    2: 
    3: from __future__ import annotations
    4: 
    5: __all__ = ["HTTPRangeRequestUnsupported", "dist_from_wheel_url"]
    6: 
    7: from bisect import bisect_left, bisect_right
    8: from collections.abc import Generator
    9: from contextlib import contextmanager
   10: from tempfile import NamedTemporaryFile
   11: from typing import Any
   12: from zipfile import BadZipFile, ZipFile
   13: 
   14: from pip._vendor.packaging.utils import canonicalize_name
   15: from pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response
   16: 
   17: from pip._internal.metadata import BaseDistribution, MemoryWheel, get_wheel_distribution
   18: from pip._internal.network.session import PipSession
   19: from pip._internal.network.utils import HEADERS, raise_for_status, response_chunks
   20: 
   21: 
   22: class HTTPRangeRequestUnsupported(Exception):
   23:     pass
   24: 
   25: 
   26: def dist_from_wheel_url(name: str, url: str, session: PipSession) -> BaseDistribution:
   27:     """Return a distribution object from the given wheel URL.
   28: 
   29:     This uses HTTP range requests to only fetch the portion of the wheel
   30:     containing metadata, just enough for the object to be constructed.
   31:     If such requests are not supported, HTTPRangeRequestUnsupported
   32:     is raised.
   33:     """
   34:     with LazyZipOverHTTP(url, session) as zf:
   35:         # For read-only ZIP files, ZipFile only needs methods read,
   36:         # seek, seekable and tell, not the whole IO protocol.
   37:         wheel = MemoryWheel(zf.name, zf)  # type: ignore
   38:         # After context manager exit, wheel.name
   39:         # is an invalid file by intention.
   40:         return get_wheel_distribution(wheel, canonicalize_name(name))
   41: 
   42: 
   43: class LazyZipOverHTTP:
   44:     """File-like object mapped to a ZIP file over HTTP.
   45: 
   46:     This uses HTTP range requests to lazily fetch the file's content,
   47:     which is supposed to be fed to ZipFile.  If such requests are not
   48:     supported by the server, raise HTTPRangeRequestUnsupported
   49:     during initialization.
   50:     """
   51: 
   52:     def __init__(
   53:         self, url: str, session: PipSession, chunk_size: int = CONTENT_CHUNK_SIZE
   54:     ) -> None:
   55:         head = session.head(url, headers=HEADERS)
   56:         raise_for_status(head)
   57:         assert head.status_code == 200
   58:         self._session, self._url, self._chunk_size = session, url, chunk_size
   59:         self._length = int(head.headers["Content-Length"])
   60:         self._file = NamedTemporaryFile()
   61:         self.truncate(self._length)
   62:         self._left: list[int] = []
   63:         self._right: list[int] = []
   64:         if "bytes" not in head.headers.get("Accept-Ranges", "none"):
   65:             raise HTTPRangeRequestUnsupported("range request is not supported")
   66:         self._check_zip()
   67: 
   68:     @property
   69:     def mode(self) -> str:
   70:         """Opening mode, which is always rb."""
   71:         return "rb"
   72: 
   73:     @property
   74:     def name(self) -> str:
   75:         """Path to the underlying file."""
   76:         return self._file.name
   77: 
   78:     def seekable(self) -> bool:
   79:         """Return whether random access is supported, which is True."""
   80:         return True
   81: 
   82:     def close(self) -> None:
   83:         """Close the file."""
   84:         self._file.close()
   85: 
   86:     @property
   87:     def closed(self) -> bool:
   88:         """Whether the file is closed."""
   89:         return self._file.closed
   90: 
   91:     def read(self, size: int = -1) -> bytes:
   92:         """Read up to size bytes from the object and return them.
   93: 
   94:         As a convenience, if size is unspecified or -1,
   95:         all bytes until EOF are returned.  Fewer than
   96:         size bytes may be returned if EOF is reached.
   97:         """
   98:         download_size = max(size, self._chunk_size)
   99:         start, length = self.tell(), self._length
  100:         stop = length if size < 0 else min(start + download_size, length)
  101:         start = max(0, stop - download_size)
  102:         self._download(start, stop - 1)
  103:         return self._file.read(size)
  104: 
  105:     def readable(self) -> bool:
  106:         """Return whether the file is readable, which is True."""
  107:         return True
  108: 
  109:     def seek(self, offset: int, whence: int = 0) -> int:
  110:         """Change stream position and return the new absolute position.
  111: 
  112:         Seek to offset relative position indicated by whence:
  113:         * 0: Start of stream (the default).  pos should be >= 0;
  114:         * 1: Current position - pos may be negative;
  115:         * 2: End of stream - pos usually negative.
  116:         """
  117:         return self._file.seek(offset, whence)
  118: 
  119:     def tell(self) -> int:
  120:         """Return the current position."""
  121:         return self._file.tell()
  122: 
  123:     def truncate(self, size: int | None = None) -> int:
  124:         """Resize the stream to the given size in bytes.
  125: 
  126:         If size is unspecified resize to the current position.
  127:         The current stream position isn't changed.
  128: 
  129:         Return the new file size.
  130:         """
  131:         return self._file.truncate(size)
  132: 
  133:     def writable(self) -> bool:
  134:         """Return False."""
  135:         return False
  136: 
  137:     def __enter__(self) -> LazyZipOverHTTP:
  138:         self._file.__enter__()
  139:         return self
  140: 
  141:     def __exit__(self, *exc: Any) -> None:
  142:         self._file.__exit__(*exc)
  143: 
  144:     @contextmanager
  145:     def _stay(self) -> Generator[None, None, None]:
  146:         """Return a context manager keeping the position.
  147: 
  148:         At the end of the block, seek back to original position.
  149:         """
  150:         pos = self.tell()
  151:         try:
  152:             yield
  153:         finally:
  154:             self.seek(pos)
  155: 
  156:     def _check_zip(self) -> None:
  157:         """Check and download until the file is a valid ZIP."""
  158:         end = self._length - 1
  159:         for start in reversed(range(0, end, self._chunk_size)):
  160:             self._download(start, end)
  161:             with self._stay():
  162:                 try:
  163:                     # For read-only ZIP files, ZipFile only needs
  164:                     # methods read, seek, seekable and tell.
  165:                     ZipFile(self)
  166:                 except BadZipFile:
  167:                     pass
  168:                 else:
  169:                     break
  170: 
  171:     def _stream_response(
  172:         self, start: int, end: int, base_headers: dict[str, str] = HEADERS
  173:     ) -> Response:
  174:         """Return HTTP response to a range request from start to end."""
  175:         headers = base_headers.copy()
  176:         headers["Range"] = f"bytes={start}-{end}"
  177:         # TODO: Get range requests to be correctly cached
  178:         headers["Cache-Control"] = "no-cache"
  179:         return self._session.get(self._url, headers=headers, stream=True)
  180: 
  181:     def _merge(
  182:         self, start: int, end: int, left: int, right: int
  183:     ) -> Generator[tuple[int, int], None, None]:
  184:         """Return a generator of intervals to be fetched.
  185: 
  186:         Args:
  187:             start (int): Start of needed interval
  188:             end (int): End of needed interval
  189:             left (int): Index of first overlapping downloaded data
  190:             right (int): Index after last overlapping downloaded data
  191:         """
  192:         lslice, rslice = self._left[left:right], self._right[left:right]
  193:         i = start = min([start] + lslice[:1])
  194:         end = max([end] + rslice[-1:])
  195:         for j, k in zip(lslice, rslice):
  196:             if j > i:
  197:                 yield i, j - 1
  198:             i = k + 1
  199:         if i <= end:
  200:             yield i, end
  201:         self._left[left:right], self._right[left:right] = [start], [end]
  202: 
  203:     def _download(self, start: int, end: int) -> None:
  204:         """Download bytes from start to end inclusively."""
  205:         with self._stay():
  206:             left = bisect_left(self._right, start)
  207:             right = bisect_right(self._left, end)
  208:             for start, end in self._merge(start, end, left, right):
  209:                 response = self._stream_response(start, end)
  210:                 response.raise_for_status()
  211:                 self.seek(start)
  212:                 for chunk in response_chunks(response, self._chunk_size):
  213:                     self._file.write(chunk)
