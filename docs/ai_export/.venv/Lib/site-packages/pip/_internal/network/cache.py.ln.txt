    1: """HTTP cache implementation."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import os
    6: import shutil
    7: from collections.abc import Generator
    8: from contextlib import contextmanager
    9: from datetime import datetime
   10: from typing import Any, BinaryIO, Callable
   11: 
   12: from pip._vendor.cachecontrol.cache import SeparateBodyBaseCache
   13: from pip._vendor.cachecontrol.caches import SeparateBodyFileCache
   14: from pip._vendor.requests.models import Response
   15: 
   16: from pip._internal.utils.filesystem import adjacent_tmp_file, replace
   17: from pip._internal.utils.misc import ensure_dir
   18: 
   19: 
   20: def is_from_cache(response: Response) -> bool:
   21:     return getattr(response, "from_cache", False)
   22: 
   23: 
   24: @contextmanager
   25: def suppressed_cache_errors() -> Generator[None, None, None]:
   26:     """If we can't access the cache then we can just skip caching and process
   27:     requests as if caching wasn't enabled.
   28:     """
   29:     try:
   30:         yield
   31:     except OSError:
   32:         pass
   33: 
   34: 
   35: class SafeFileCache(SeparateBodyBaseCache):
   36:     """
   37:     A file based cache which is safe to use even when the target directory may
   38:     not be accessible or writable.
   39: 
   40:     There is a race condition when two processes try to write and/or read the
   41:     same entry at the same time, since each entry consists of two separate
   42:     files (https://github.com/psf/cachecontrol/issues/324).  We therefore have
   43:     additional logic that makes sure that both files to be present before
   44:     returning an entry; this fixes the read side of the race condition.
   45: 
   46:     For the write side, we assume that the server will only ever return the
   47:     same data for the same URL, which ought to be the case for files pip is
   48:     downloading.  PyPI does not have a mechanism to swap out a wheel for
   49:     another wheel, for example.  If this assumption is not true, the
   50:     CacheControl issue will need to be fixed.
   51:     """
   52: 
   53:     def __init__(self, directory: str) -> None:
   54:         assert directory is not None, "Cache directory must not be None."
   55:         super().__init__()
   56:         self.directory = directory
   57: 
   58:     def _get_cache_path(self, name: str) -> str:
   59:         # From cachecontrol.caches.file_cache.FileCache._fn, brought into our
   60:         # class for backwards-compatibility and to avoid using a non-public
   61:         # method.
   62:         hashed = SeparateBodyFileCache.encode(name)
   63:         parts = list(hashed[:5]) + [hashed]
   64:         return os.path.join(self.directory, *parts)
   65: 
   66:     def get(self, key: str) -> bytes | None:
   67:         # The cache entry is only valid if both metadata and body exist.
   68:         metadata_path = self._get_cache_path(key)
   69:         body_path = metadata_path + ".body"
   70:         if not (os.path.exists(metadata_path) and os.path.exists(body_path)):
   71:             return None
   72:         with suppressed_cache_errors():
   73:             with open(metadata_path, "rb") as f:
   74:                 return f.read()
   75: 
   76:     def _write_to_file(self, path: str, writer_func: Callable[[BinaryIO], Any]) -> None:
   77:         """Common file writing logic with proper permissions and atomic replacement."""
   78:         with suppressed_cache_errors():
   79:             ensure_dir(os.path.dirname(path))
   80: 
   81:             with adjacent_tmp_file(path) as f:
   82:                 writer_func(f)
   83:                 # Inherit the read/write permissions of the cache directory
   84:                 # to enable multi-user cache use-cases.
   85:                 mode = (
   86:                     os.stat(self.directory).st_mode
   87:                     & 0o666  # select read/write permissions of cache directory
   88:                     | 0o600  # set owner read/write permissions
   89:                 )
   90:                 # Change permissions only if there is no risk of following a symlink.
   91:                 if os.chmod in os.supports_fd:
   92:                     os.chmod(f.fileno(), mode)
   93:                 elif os.chmod in os.supports_follow_symlinks:
   94:                     os.chmod(f.name, mode, follow_symlinks=False)
   95: 
   96:             replace(f.name, path)
   97: 
   98:     def _write(self, path: str, data: bytes) -> None:
   99:         self._write_to_file(path, lambda f: f.write(data))
  100: 
  101:     def _write_from_io(self, path: str, source_file: BinaryIO) -> None:
  102:         self._write_to_file(path, lambda f: shutil.copyfileobj(source_file, f))
  103: 
  104:     def set(
  105:         self, key: str, value: bytes, expires: int | datetime | None = None
  106:     ) -> None:
  107:         path = self._get_cache_path(key)
  108:         self._write(path, value)
  109: 
  110:     def delete(self, key: str) -> None:
  111:         path = self._get_cache_path(key)
  112:         with suppressed_cache_errors():
  113:             os.remove(path)
  114:         with suppressed_cache_errors():
  115:             os.remove(path + ".body")
  116: 
  117:     def get_body(self, key: str) -> BinaryIO | None:
  118:         # The cache entry is only valid if both metadata and body exist.
  119:         metadata_path = self._get_cache_path(key)
  120:         body_path = metadata_path + ".body"
  121:         if not (os.path.exists(metadata_path) and os.path.exists(body_path)):
  122:             return None
  123:         with suppressed_cache_errors():
  124:             return open(body_path, "rb")
  125: 
  126:     def set_body(self, key: str, body: bytes) -> None:
  127:         path = self._get_cache_path(key) + ".body"
  128:         self._write(path, body)
  129: 
  130:     def set_body_from_io(self, key: str, body_file: BinaryIO) -> None:
  131:         """Set the body of the cache entry from a file object."""
  132:         path = self._get_cache_path(key) + ".body"
  133:         self._write_from_io(path, body_file)
