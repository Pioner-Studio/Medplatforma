    1: from collections.abc import Generator
    2: 
    3: from pip._vendor.requests.models import Response
    4: 
    5: from pip._internal.exceptions import NetworkConnectionError
    6: 
    7: # The following comments and HTTP headers were originally added by
    8: # Donald Stufft in git commit 22c562429a61bb77172039e480873fb239dd8c03.
    9: #
   10: # We use Accept-Encoding: identity here because requests defaults to
   11: # accepting compressed responses. This breaks in a variety of ways
   12: # depending on how the server is configured.
   13: # - Some servers will notice that the file isn't a compressible file
   14: #   and will leave the file alone and with an empty Content-Encoding
   15: # - Some servers will notice that the file is already compressed and
   16: #   will leave the file alone, adding a Content-Encoding: gzip header
   17: # - Some servers won't notice anything at all and will take a file
   18: #   that's already been compressed and compress it again, and set
   19: #   the Content-Encoding: gzip header
   20: # By setting this to request only the identity encoding we're hoping
   21: # to eliminate the third case.  Hopefully there does not exist a server
   22: # which when given a file will notice it is already compressed and that
   23: # you're not asking for a compressed file and will then decompress it
   24: # before sending because if that's the case I don't think it'll ever be
   25: # possible to make this work.
   26: HEADERS: dict[str, str] = {"Accept-Encoding": "identity"}
   27: 
   28: DOWNLOAD_CHUNK_SIZE = 256 * 1024
   29: 
   30: 
   31: def raise_for_status(resp: Response) -> None:
   32:     http_error_msg = ""
   33:     if isinstance(resp.reason, bytes):
   34:         # We attempt to decode utf-8 first because some servers
   35:         # choose to localize their reason strings. If the string
   36:         # isn't utf-8, we fall back to iso-8859-1 for all other
   37:         # encodings.
   38:         try:
   39:             reason = resp.reason.decode("utf-8")
   40:         except UnicodeDecodeError:
   41:             reason = resp.reason.decode("iso-8859-1")
   42:     else:
   43:         reason = resp.reason
   44: 
   45:     if 400 <= resp.status_code < 500:
   46:         http_error_msg = (
   47:             f"{resp.status_code} Client Error: {reason} for url: {resp.url}"
   48:         )
   49: 
   50:     elif 500 <= resp.status_code < 600:
   51:         http_error_msg = (
   52:             f"{resp.status_code} Server Error: {reason} for url: {resp.url}"
   53:         )
   54: 
   55:     if http_error_msg:
   56:         raise NetworkConnectionError(http_error_msg, response=resp)
   57: 
   58: 
   59: def response_chunks(
   60:     response: Response, chunk_size: int = DOWNLOAD_CHUNK_SIZE
   61: ) -> Generator[bytes, None, None]:
   62:     """Given a requests Response, provide the data chunks."""
   63:     try:
   64:         # Special case for urllib3.
   65:         for chunk in response.raw.stream(
   66:             chunk_size,
   67:             # We use decode_content=False here because we don't
   68:             # want urllib3 to mess with the raw bytes we get
   69:             # from the server. If we decompress inside of
   70:             # urllib3 then we cannot verify the checksum
   71:             # because the checksum will be of the compressed
   72:             # file. This breakage will only occur if the
   73:             # server adds a Content-Encoding header, which
   74:             # depends on how the server was configured:
   75:             # - Some servers will notice that the file isn't a
   76:             #   compressible file and will leave the file alone
   77:             #   and with an empty Content-Encoding
   78:             # - Some servers will notice that the file is
   79:             #   already compressed and will leave the file
   80:             #   alone and will add a Content-Encoding: gzip
   81:             #   header
   82:             # - Some servers won't notice anything at all and
   83:             #   will take a file that's already been compressed
   84:             #   and compress it again and set the
   85:             #   Content-Encoding: gzip header
   86:             #
   87:             # By setting this not to decode automatically we
   88:             # hope to eliminate problems with the second case.
   89:             decode_content=False,
   90:         ):
   91:             yield chunk
   92:     except AttributeError:
   93:         # Standard file-like object.
   94:         while True:
   95:             chunk = response.raw.read(chunk_size)
   96:             if not chunk:
   97:                 break
   98:             yield chunk
