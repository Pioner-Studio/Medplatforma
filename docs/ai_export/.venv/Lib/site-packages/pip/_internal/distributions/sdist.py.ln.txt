    1: from __future__ import annotations
    2: 
    3: import logging
    4: from collections.abc import Iterable
    5: from typing import TYPE_CHECKING
    6: 
    7: from pip._internal.build_env import BuildEnvironment
    8: from pip._internal.distributions.base import AbstractDistribution
    9: from pip._internal.exceptions import InstallationError
   10: from pip._internal.metadata import BaseDistribution
   11: from pip._internal.utils.subprocess import runner_with_spinner_message
   12: 
   13: if TYPE_CHECKING:
   14:     from pip._internal.build_env import BuildEnvironmentInstaller
   15: 
   16: logger = logging.getLogger(__name__)
   17: 
   18: 
   19: class SourceDistribution(AbstractDistribution):
   20:     """Represents a source distribution.
   21: 
   22:     The preparation step for these needs metadata for the packages to be
   23:     generated, either using PEP 517 or using the legacy `setup.py egg_info`.
   24:     """
   25: 
   26:     @property
   27:     def build_tracker_id(self) -> str | None:
   28:         """Identify this requirement uniquely by its link."""
   29:         assert self.req.link
   30:         return self.req.link.url_without_fragment
   31: 
   32:     def get_metadata_distribution(self) -> BaseDistribution:
   33:         return self.req.get_dist()
   34: 
   35:     def prepare_distribution_metadata(
   36:         self,
   37:         build_env_installer: BuildEnvironmentInstaller,
   38:         build_isolation: bool,
   39:         check_build_deps: bool,
   40:     ) -> None:
   41:         # Load pyproject.toml, to determine whether PEP 517 is to be used
   42:         self.req.load_pyproject_toml()
   43: 
   44:         # Set up the build isolation, if this requirement should be isolated
   45:         should_isolate = self.req.use_pep517 and build_isolation
   46:         if should_isolate:
   47:             # Setup an isolated environment and install the build backend static
   48:             # requirements in it.
   49:             self._prepare_build_backend(build_env_installer)
   50:             # Check that if the requirement is editable, it either supports PEP 660 or
   51:             # has a setup.py or a setup.cfg. This cannot be done earlier because we need
   52:             # to setup the build backend to verify it supports build_editable, nor can
   53:             # it be done later, because we want to avoid installing build requirements
   54:             # needlessly. Doing it here also works around setuptools generating
   55:             # UNKNOWN.egg-info when running get_requires_for_build_wheel on a directory
   56:             # without setup.py nor setup.cfg.
   57:             self.req.isolated_editable_sanity_check()
   58:             # Install the dynamic build requirements.
   59:             self._install_build_reqs(build_env_installer)
   60:         # Check if the current environment provides build dependencies
   61:         should_check_deps = self.req.use_pep517 and check_build_deps
   62:         if should_check_deps:
   63:             pyproject_requires = self.req.pyproject_requires
   64:             assert pyproject_requires is not None
   65:             conflicting, missing = self.req.build_env.check_requirements(
   66:                 pyproject_requires
   67:             )
   68:             if conflicting:
   69:                 self._raise_conflicts("the backend dependencies", conflicting)
   70:             if missing:
   71:                 self._raise_missing_reqs(missing)
   72:         self.req.prepare_metadata()
   73: 
   74:     def _prepare_build_backend(
   75:         self, build_env_installer: BuildEnvironmentInstaller
   76:     ) -> None:
   77:         # Isolate in a BuildEnvironment and install the build-time
   78:         # requirements.
   79:         pyproject_requires = self.req.pyproject_requires
   80:         assert pyproject_requires is not None
   81: 
   82:         self.req.build_env = BuildEnvironment(build_env_installer)
   83:         self.req.build_env.install_requirements(
   84:             pyproject_requires, "overlay", kind="build dependencies", for_req=self.req
   85:         )
   86:         conflicting, missing = self.req.build_env.check_requirements(
   87:             self.req.requirements_to_check
   88:         )
   89:         if conflicting:
   90:             self._raise_conflicts("PEP 517/518 supported requirements", conflicting)
   91:         if missing:
   92:             logger.warning(
   93:                 "Missing build requirements in pyproject.toml for %s.",
   94:                 self.req,
   95:             )
   96:             logger.warning(
   97:                 "The project does not specify a build backend, and "
   98:                 "pip cannot fall back to setuptools without %s.",
   99:                 " and ".join(map(repr, sorted(missing))),
  100:             )
  101: 
  102:     def _get_build_requires_wheel(self) -> Iterable[str]:
  103:         with self.req.build_env:
  104:             runner = runner_with_spinner_message("Getting requirements to build wheel")
  105:             backend = self.req.pep517_backend
  106:             assert backend is not None
  107:             with backend.subprocess_runner(runner):
  108:                 return backend.get_requires_for_build_wheel()
  109: 
  110:     def _get_build_requires_editable(self) -> Iterable[str]:
  111:         with self.req.build_env:
  112:             runner = runner_with_spinner_message(
  113:                 "Getting requirements to build editable"
  114:             )
  115:             backend = self.req.pep517_backend
  116:             assert backend is not None
  117:             with backend.subprocess_runner(runner):
  118:                 return backend.get_requires_for_build_editable()
  119: 
  120:     def _install_build_reqs(
  121:         self, build_env_installer: BuildEnvironmentInstaller
  122:     ) -> None:
  123:         # Install any extra build dependencies that the backend requests.
  124:         # This must be done in a second pass, as the pyproject.toml
  125:         # dependencies must be installed before we can call the backend.
  126:         if (
  127:             self.req.editable
  128:             and self.req.permit_editable_wheels
  129:             and self.req.supports_pyproject_editable
  130:         ):
  131:             build_reqs = self._get_build_requires_editable()
  132:         else:
  133:             build_reqs = self._get_build_requires_wheel()
  134:         conflicting, missing = self.req.build_env.check_requirements(build_reqs)
  135:         if conflicting:
  136:             self._raise_conflicts("the backend dependencies", conflicting)
  137:         self.req.build_env.install_requirements(
  138:             missing, "normal", kind="backend dependencies", for_req=self.req
  139:         )
  140: 
  141:     def _raise_conflicts(
  142:         self, conflicting_with: str, conflicting_reqs: set[tuple[str, str]]
  143:     ) -> None:
  144:         format_string = (
  145:             "Some build dependencies for {requirement} "
  146:             "conflict with {conflicting_with}: {description}."
  147:         )
  148:         error_message = format_string.format(
  149:             requirement=self.req,
  150:             conflicting_with=conflicting_with,
  151:             description=", ".join(
  152:                 f"{installed} is incompatible with {wanted}"
  153:                 for installed, wanted in sorted(conflicting_reqs)
  154:             ),
  155:         )
  156:         raise InstallationError(error_message)
  157: 
  158:     def _raise_missing_reqs(self, missing: set[str]) -> None:
  159:         format_string = (
  160:             "Some build dependencies for {requirement} are missing: {missing}."
  161:         )
  162:         error_message = format_string.format(
  163:             requirement=self.req, missing=", ".join(map(repr, sorted(missing)))
  164:         )
  165:         raise InstallationError(error_message)
