    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import errno
    5: import logging
    6: import logging.handlers
    7: import os
    8: import sys
    9: import threading
   10: from collections.abc import Generator
   11: from dataclasses import dataclass
   12: from io import TextIOWrapper
   13: from logging import Filter
   14: from typing import Any, ClassVar
   15: 
   16: from pip._vendor.rich.console import (
   17:     Console,
   18:     ConsoleOptions,
   19:     ConsoleRenderable,
   20:     RenderableType,
   21:     RenderResult,
   22:     RichCast,
   23: )
   24: from pip._vendor.rich.highlighter import NullHighlighter
   25: from pip._vendor.rich.logging import RichHandler
   26: from pip._vendor.rich.segment import Segment
   27: from pip._vendor.rich.style import Style
   28: 
   29: from pip._internal.utils._log import VERBOSE, getLogger
   30: from pip._internal.utils.compat import WINDOWS
   31: from pip._internal.utils.deprecation import DEPRECATION_MSG_PREFIX
   32: from pip._internal.utils.misc import ensure_dir
   33: 
   34: _log_state = threading.local()
   35: _stdout_console = None
   36: _stderr_console = None
   37: subprocess_logger = getLogger("pip.subprocessor")
   38: 
   39: 
   40: class BrokenStdoutLoggingError(Exception):
   41:     """
   42:     Raised if BrokenPipeError occurs for the stdout stream while logging.
   43:     """
   44: 
   45: 
   46: def _is_broken_pipe_error(exc_class: type[BaseException], exc: BaseException) -> bool:
   47:     if exc_class is BrokenPipeError:
   48:         return True
   49: 
   50:     # On Windows, a broken pipe can show up as EINVAL rather than EPIPE:
   51:     # https://bugs.python.org/issue19612
   52:     # https://bugs.python.org/issue30418
   53:     if not WINDOWS:
   54:         return False
   55: 
   56:     return isinstance(exc, OSError) and exc.errno in (errno.EINVAL, errno.EPIPE)
   57: 
   58: 
   59: @contextlib.contextmanager
   60: def indent_log(num: int = 2) -> Generator[None, None, None]:
   61:     """
   62:     A context manager which will cause the log output to be indented for any
   63:     log messages emitted inside it.
   64:     """
   65:     # For thread-safety
   66:     _log_state.indentation = get_indentation()
   67:     _log_state.indentation += num
   68:     try:
   69:         yield
   70:     finally:
   71:         _log_state.indentation -= num
   72: 
   73: 
   74: def get_indentation() -> int:
   75:     return getattr(_log_state, "indentation", 0)
   76: 
   77: 
   78: class IndentingFormatter(logging.Formatter):
   79:     default_time_format = "%Y-%m-%dT%H:%M:%S"
   80: 
   81:     def __init__(
   82:         self,
   83:         *args: Any,
   84:         add_timestamp: bool = False,
   85:         **kwargs: Any,
   86:     ) -> None:
   87:         """
   88:         A logging.Formatter that obeys the indent_log() context manager.
   89: 
   90:         :param add_timestamp: A bool indicating output lines should be prefixed
   91:             with their record's timestamp.
   92:         """
   93:         self.add_timestamp = add_timestamp
   94:         super().__init__(*args, **kwargs)
   95: 
   96:     def get_message_start(self, formatted: str, levelno: int) -> str:
   97:         """
   98:         Return the start of the formatted log message (not counting the
   99:         prefix to add to each line).
  100:         """
  101:         if levelno < logging.WARNING:
  102:             return ""
  103:         if formatted.startswith(DEPRECATION_MSG_PREFIX):
  104:             # Then the message already has a prefix.  We don't want it to
  105:             # look like "WARNING: DEPRECATION: ...."
  106:             return ""
  107:         if levelno < logging.ERROR:
  108:             return "WARNING: "
  109: 
  110:         return "ERROR: "
  111: 
  112:     def format(self, record: logging.LogRecord) -> str:
  113:         """
  114:         Calls the standard formatter, but will indent all of the log message
  115:         lines by our current indentation level.
  116:         """
  117:         formatted = super().format(record)
  118:         message_start = self.get_message_start(formatted, record.levelno)
  119:         formatted = message_start + formatted
  120: 
  121:         prefix = ""
  122:         if self.add_timestamp:
  123:             prefix = f"{self.formatTime(record)} "
  124:         prefix += " " * get_indentation()
  125:         formatted = "".join([prefix + line for line in formatted.splitlines(True)])
  126:         return formatted
  127: 
  128: 
  129: @dataclass
  130: class IndentedRenderable:
  131:     renderable: RenderableType
  132:     indent: int
  133: 
  134:     def __rich_console__(
  135:         self, console: Console, options: ConsoleOptions
  136:     ) -> RenderResult:
  137:         segments = console.render(self.renderable, options)
  138:         lines = Segment.split_lines(segments)
  139:         for line in lines:
  140:             yield Segment(" " * self.indent)
  141:             yield from line
  142:             yield Segment("\n")
  143: 
  144: 
  145: class PipConsole(Console):
  146:     def on_broken_pipe(self) -> None:
  147:         # Reraise the original exception, rich 13.8.0+ exits by default
  148:         # instead, preventing our handler from firing.
  149:         raise BrokenPipeError() from None
  150: 
  151: 
  152: def get_console(*, stderr: bool = False) -> Console:
  153:     if stderr:
  154:         assert _stderr_console is not None, "stderr rich console is missing!"
  155:         return _stderr_console
  156:     else:
  157:         assert _stdout_console is not None, "stdout rich console is missing!"
  158:         return _stdout_console
  159: 
  160: 
  161: class RichPipStreamHandler(RichHandler):
  162:     KEYWORDS: ClassVar[list[str] | None] = []
  163: 
  164:     def __init__(self, console: Console) -> None:
  165:         super().__init__(
  166:             console=console,
  167:             show_time=False,
  168:             show_level=False,
  169:             show_path=False,
  170:             highlighter=NullHighlighter(),
  171:         )
  172: 
  173:     # Our custom override on Rich's logger, to make things work as we need them to.
  174:     def emit(self, record: logging.LogRecord) -> None:
  175:         style: Style | None = None
  176: 
  177:         # If we are given a diagnostic error to present, present it with indentation.
  178:         if getattr(record, "rich", False):
  179:             assert isinstance(record.args, tuple)
  180:             (rich_renderable,) = record.args
  181:             assert isinstance(
  182:                 rich_renderable, (ConsoleRenderable, RichCast, str)
  183:             ), f"{rich_renderable} is not rich-console-renderable"
  184: 
  185:             renderable: RenderableType = IndentedRenderable(
  186:                 rich_renderable, indent=get_indentation()
  187:             )
  188:         else:
  189:             message = self.format(record)
  190:             renderable = self.render_message(record, message)
  191:             if record.levelno is not None:
  192:                 if record.levelno >= logging.ERROR:
  193:                     style = Style(color="red")
  194:                 elif record.levelno >= logging.WARNING:
  195:                     style = Style(color="yellow")
  196: 
  197:         try:
  198:             self.console.print(renderable, overflow="ignore", crop=False, style=style)
  199:         except Exception:
  200:             self.handleError(record)
  201: 
  202:     def handleError(self, record: logging.LogRecord) -> None:
  203:         """Called when logging is unable to log some output."""
  204: 
  205:         exc_class, exc = sys.exc_info()[:2]
  206:         # If a broken pipe occurred while calling write() or flush() on the
  207:         # stdout stream in logging's Handler.emit(), then raise our special
  208:         # exception so we can handle it in main() instead of logging the
  209:         # broken pipe error and continuing.
  210:         if (
  211:             exc_class
  212:             and exc
  213:             and self.console.file is sys.stdout
  214:             and _is_broken_pipe_error(exc_class, exc)
  215:         ):
  216:             raise BrokenStdoutLoggingError()
  217: 
  218:         return super().handleError(record)
  219: 
  220: 
  221: class BetterRotatingFileHandler(logging.handlers.RotatingFileHandler):
  222:     def _open(self) -> TextIOWrapper:
  223:         ensure_dir(os.path.dirname(self.baseFilename))
  224:         return super()._open()
  225: 
  226: 
  227: class MaxLevelFilter(Filter):
  228:     def __init__(self, level: int) -> None:
  229:         self.level = level
  230: 
  231:     def filter(self, record: logging.LogRecord) -> bool:
  232:         return record.levelno < self.level
  233: 
  234: 
  235: class ExcludeLoggerFilter(Filter):
  236:     """
  237:     A logging Filter that excludes records from a logger (or its children).
  238:     """
  239: 
  240:     def filter(self, record: logging.LogRecord) -> bool:
  241:         # The base Filter class allows only records from a logger (or its
  242:         # children).
  243:         return not super().filter(record)
  244: 
  245: 
  246: def setup_logging(verbosity: int, no_color: bool, user_log_file: str | None) -> int:
  247:     """Configures and sets up all of the logging
  248: 
  249:     Returns the requested logging level, as its integer value.
  250:     """
  251: 
  252:     # Determine the level to be logging at.
  253:     if verbosity >= 2:
  254:         level_number = logging.DEBUG
  255:     elif verbosity == 1:
  256:         level_number = VERBOSE
  257:     elif verbosity == -1:
  258:         level_number = logging.WARNING
  259:     elif verbosity == -2:
  260:         level_number = logging.ERROR
  261:     elif verbosity <= -3:
  262:         level_number = logging.CRITICAL
  263:     else:
  264:         level_number = logging.INFO
  265: 
  266:     level = logging.getLevelName(level_number)
  267: 
  268:     # The "root" logger should match the "console" level *unless* we also need
  269:     # to log to a user log file.
  270:     include_user_log = user_log_file is not None
  271:     if include_user_log:
  272:         additional_log_file = user_log_file
  273:         root_level = "DEBUG"
  274:     else:
  275:         additional_log_file = "/dev/null"
  276:         root_level = level
  277: 
  278:     # Disable any logging besides WARNING unless we have DEBUG level logging
  279:     # enabled for vendored libraries.
  280:     vendored_log_level = "WARNING" if level in ["INFO", "ERROR"] else "DEBUG"
  281: 
  282:     # Shorthands for clarity
  283:     handler_classes = {
  284:         "stream": "pip._internal.utils.logging.RichPipStreamHandler",
  285:         "file": "pip._internal.utils.logging.BetterRotatingFileHandler",
  286:     }
  287:     handlers = ["console", "console_errors", "console_subprocess"] + (
  288:         ["user_log"] if include_user_log else []
  289:     )
  290:     global _stdout_console, stderr_console
  291:     _stdout_console = PipConsole(file=sys.stdout, no_color=no_color, soft_wrap=True)
  292:     _stderr_console = PipConsole(file=sys.stderr, no_color=no_color, soft_wrap=True)
  293: 
  294:     logging.config.dictConfig(
  295:         {
  296:             "version": 1,
  297:             "disable_existing_loggers": False,
  298:             "filters": {
  299:                 "exclude_warnings": {
  300:                     "()": "pip._internal.utils.logging.MaxLevelFilter",
  301:                     "level": logging.WARNING,
  302:                 },
  303:                 "restrict_to_subprocess": {
  304:                     "()": "logging.Filter",
  305:                     "name": subprocess_logger.name,
  306:                 },
  307:                 "exclude_subprocess": {
  308:                     "()": "pip._internal.utils.logging.ExcludeLoggerFilter",
  309:                     "name": subprocess_logger.name,
  310:                 },
  311:             },
  312:             "formatters": {
  313:                 "indent": {
  314:                     "()": IndentingFormatter,
  315:                     "format": "%(message)s",
  316:                 },
  317:                 "indent_with_timestamp": {
  318:                     "()": IndentingFormatter,
  319:                     "format": "%(message)s",
  320:                     "add_timestamp": True,
  321:                 },
  322:             },
  323:             "handlers": {
  324:                 "console": {
  325:                     "level": level,
  326:                     "class": handler_classes["stream"],
  327:                     "console": _stdout_console,
  328:                     "filters": ["exclude_subprocess", "exclude_warnings"],
  329:                     "formatter": "indent",
  330:                 },
  331:                 "console_errors": {
  332:                     "level": "WARNING",
  333:                     "class": handler_classes["stream"],
  334:                     "console": _stderr_console,
  335:                     "filters": ["exclude_subprocess"],
  336:                     "formatter": "indent",
  337:                 },
  338:                 # A handler responsible for logging to the console messages
  339:                 # from the "subprocessor" logger.
  340:                 "console_subprocess": {
  341:                     "level": level,
  342:                     "class": handler_classes["stream"],
  343:                     "console": _stderr_console,
  344:                     "filters": ["restrict_to_subprocess"],
  345:                     "formatter": "indent",
  346:                 },
  347:                 "user_log": {
  348:                     "level": "DEBUG",
  349:                     "class": handler_classes["file"],
  350:                     "filename": additional_log_file,
  351:                     "encoding": "utf-8",
  352:                     "delay": True,
  353:                     "formatter": "indent_with_timestamp",
  354:                 },
  355:             },
  356:             "root": {
  357:                 "level": root_level,
  358:                 "handlers": handlers,
  359:             },
  360:             "loggers": {"pip._vendor": {"level": vendored_log_level}},
  361:         }
  362:     )
  363: 
  364:     return level_number
