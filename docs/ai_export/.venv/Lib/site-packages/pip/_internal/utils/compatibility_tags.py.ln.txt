    1: """Generate and work with PEP 425 Compatibility Tags."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import re
    6: 
    7: from pip._vendor.packaging.tags import (
    8:     PythonVersion,
    9:     Tag,
   10:     android_platforms,
   11:     compatible_tags,
   12:     cpython_tags,
   13:     generic_tags,
   14:     interpreter_name,
   15:     interpreter_version,
   16:     ios_platforms,
   17:     mac_platforms,
   18: )
   19: 
   20: _apple_arch_pat = re.compile(r"(.+)_(\d+)_(\d+)_(.+)")
   21: 
   22: 
   23: def version_info_to_nodot(version_info: tuple[int, ...]) -> str:
   24:     # Only use up to the first two numbers.
   25:     return "".join(map(str, version_info[:2]))
   26: 
   27: 
   28: def _mac_platforms(arch: str) -> list[str]:
   29:     match = _apple_arch_pat.match(arch)
   30:     if match:
   31:         name, major, minor, actual_arch = match.groups()
   32:         mac_version = (int(major), int(minor))
   33:         arches = [
   34:             # Since we have always only checked that the platform starts
   35:             # with "macosx", for backwards-compatibility we extract the
   36:             # actual prefix provided by the user in case they provided
   37:             # something like "macosxcustom_". It may be good to remove
   38:             # this as undocumented or deprecate it in the future.
   39:             "{}_{}".format(name, arch[len("macosx_") :])
   40:             for arch in mac_platforms(mac_version, actual_arch)
   41:         ]
   42:     else:
   43:         # arch pattern didn't match (?!)
   44:         arches = [arch]
   45:     return arches
   46: 
   47: 
   48: def _ios_platforms(arch: str) -> list[str]:
   49:     match = _apple_arch_pat.match(arch)
   50:     if match:
   51:         name, major, minor, actual_multiarch = match.groups()
   52:         ios_version = (int(major), int(minor))
   53:         arches = [
   54:             # Since we have always only checked that the platform starts
   55:             # with "ios", for backwards-compatibility we extract the
   56:             # actual prefix provided by the user in case they provided
   57:             # something like "ioscustom_". It may be good to remove
   58:             # this as undocumented or deprecate it in the future.
   59:             "{}_{}".format(name, arch[len("ios_") :])
   60:             for arch in ios_platforms(ios_version, actual_multiarch)
   61:         ]
   62:     else:
   63:         # arch pattern didn't match (?!)
   64:         arches = [arch]
   65:     return arches
   66: 
   67: 
   68: def _android_platforms(arch: str) -> list[str]:
   69:     match = re.fullmatch(r"android_(\d+)_(.+)", arch)
   70:     if match:
   71:         api_level, abi = match.groups()
   72:         return list(android_platforms(int(api_level), abi))
   73:     else:
   74:         # arch pattern didn't match (?!)
   75:         return [arch]
   76: 
   77: 
   78: def _custom_manylinux_platforms(arch: str) -> list[str]:
   79:     arches = [arch]
   80:     arch_prefix, arch_sep, arch_suffix = arch.partition("_")
   81:     if arch_prefix == "manylinux2014":
   82:         # manylinux1/manylinux2010 wheels run on most manylinux2014 systems
   83:         # with the exception of wheels depending on ncurses. PEP 599 states
   84:         # manylinux1/manylinux2010 wheels should be considered
   85:         # manylinux2014 wheels:
   86:         # https://www.python.org/dev/peps/pep-0599/#backwards-compatibility-with-manylinux2010-wheels
   87:         if arch_suffix in {"i686", "x86_64"}:
   88:             arches.append("manylinux2010" + arch_sep + arch_suffix)
   89:             arches.append("manylinux1" + arch_sep + arch_suffix)
   90:     elif arch_prefix == "manylinux2010":
   91:         # manylinux1 wheels run on most manylinux2010 systems with the
   92:         # exception of wheels depending on ncurses. PEP 571 states
   93:         # manylinux1 wheels should be considered manylinux2010 wheels:
   94:         # https://www.python.org/dev/peps/pep-0571/#backwards-compatibility-with-manylinux1-wheels
   95:         arches.append("manylinux1" + arch_sep + arch_suffix)
   96:     return arches
   97: 
   98: 
   99: def _get_custom_platforms(arch: str) -> list[str]:
  100:     arch_prefix, arch_sep, arch_suffix = arch.partition("_")
  101:     if arch.startswith("macosx"):
  102:         arches = _mac_platforms(arch)
  103:     elif arch.startswith("ios"):
  104:         arches = _ios_platforms(arch)
  105:     elif arch_prefix == "android":
  106:         arches = _android_platforms(arch)
  107:     elif arch_prefix in ["manylinux2014", "manylinux2010"]:
  108:         arches = _custom_manylinux_platforms(arch)
  109:     else:
  110:         arches = [arch]
  111:     return arches
  112: 
  113: 
  114: def _expand_allowed_platforms(platforms: list[str] | None) -> list[str] | None:
  115:     if not platforms:
  116:         return None
  117: 
  118:     seen = set()
  119:     result = []
  120: 
  121:     for p in platforms:
  122:         if p in seen:
  123:             continue
  124:         additions = [c for c in _get_custom_platforms(p) if c not in seen]
  125:         seen.update(additions)
  126:         result.extend(additions)
  127: 
  128:     return result
  129: 
  130: 
  131: def _get_python_version(version: str) -> PythonVersion:
  132:     if len(version) > 1:
  133:         return int(version[0]), int(version[1:])
  134:     else:
  135:         return (int(version[0]),)
  136: 
  137: 
  138: def _get_custom_interpreter(
  139:     implementation: str | None = None, version: str | None = None
  140: ) -> str:
  141:     if implementation is None:
  142:         implementation = interpreter_name()
  143:     if version is None:
  144:         version = interpreter_version()
  145:     return f"{implementation}{version}"
  146: 
  147: 
  148: def get_supported(
  149:     version: str | None = None,
  150:     platforms: list[str] | None = None,
  151:     impl: str | None = None,
  152:     abis: list[str] | None = None,
  153: ) -> list[Tag]:
  154:     """Return a list of supported tags for each version specified in
  155:     `versions`.
  156: 
  157:     :param version: a string version, of the form "33" or "32",
  158:         or None. The version will be assumed to support our ABI.
  159:     :param platform: specify a list of platforms you want valid
  160:         tags for, or None. If None, use the local system platform.
  161:     :param impl: specify the exact implementation you want valid
  162:         tags for, or None. If None, use the local interpreter impl.
  163:     :param abis: specify a list of abis you want valid
  164:         tags for, or None. If None, use the local interpreter abi.
  165:     """
  166:     supported: list[Tag] = []
  167: 
  168:     python_version: PythonVersion | None = None
  169:     if version is not None:
  170:         python_version = _get_python_version(version)
  171: 
  172:     interpreter = _get_custom_interpreter(impl, version)
  173: 
  174:     platforms = _expand_allowed_platforms(platforms)
  175: 
  176:     is_cpython = (impl or interpreter_name()) == "cp"
  177:     if is_cpython:
  178:         supported.extend(
  179:             cpython_tags(
  180:                 python_version=python_version,
  181:                 abis=abis,
  182:                 platforms=platforms,
  183:             )
  184:         )
  185:     else:
  186:         supported.extend(
  187:             generic_tags(
  188:                 interpreter=interpreter,
  189:                 abis=abis,
  190:                 platforms=platforms,
  191:             )
  192:         )
  193:     supported.extend(
  194:         compatible_tags(
  195:             python_version=python_version,
  196:             interpreter=interpreter,
  197:             platforms=platforms,
  198:         )
  199:     )
  200: 
  201:     return supported
