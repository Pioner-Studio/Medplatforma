    1: from __future__ import annotations
    2: 
    3: import fnmatch
    4: import os
    5: import os.path
    6: import random
    7: import sys
    8: from collections.abc import Generator
    9: from contextlib import contextmanager
   10: from tempfile import NamedTemporaryFile
   11: from typing import Any, BinaryIO, cast
   12: 
   13: from pip._internal.utils.compat import get_path_uid
   14: from pip._internal.utils.misc import format_size
   15: from pip._internal.utils.retry import retry
   16: 
   17: 
   18: def check_path_owner(path: str) -> bool:
   19:     # If we don't have a way to check the effective uid of this process, then
   20:     # we'll just assume that we own the directory.
   21:     if sys.platform == "win32" or not hasattr(os, "geteuid"):
   22:         return True
   23: 
   24:     assert os.path.isabs(path)
   25: 
   26:     previous = None
   27:     while path != previous:
   28:         if os.path.lexists(path):
   29:             # Check if path is writable by current user.
   30:             if os.geteuid() == 0:
   31:                 # Special handling for root user in order to handle properly
   32:                 # cases where users use sudo without -H flag.
   33:                 try:
   34:                     path_uid = get_path_uid(path)
   35:                 except OSError:
   36:                     return False
   37:                 return path_uid == 0
   38:             else:
   39:                 return os.access(path, os.W_OK)
   40:         else:
   41:             previous, path = path, os.path.dirname(path)
   42:     return False  # assume we don't own the path
   43: 
   44: 
   45: @contextmanager
   46: def adjacent_tmp_file(path: str, **kwargs: Any) -> Generator[BinaryIO, None, None]:
   47:     """Return a file-like object pointing to a tmp file next to path.
   48: 
   49:     The file is created securely and is ensured to be written to disk
   50:     after the context reaches its end.
   51: 
   52:     kwargs will be passed to tempfile.NamedTemporaryFile to control
   53:     the way the temporary file will be opened.
   54:     """
   55:     with NamedTemporaryFile(
   56:         delete=False,
   57:         dir=os.path.dirname(path),
   58:         prefix=os.path.basename(path),
   59:         suffix=".tmp",
   60:         **kwargs,
   61:     ) as f:
   62:         result = cast(BinaryIO, f)
   63:         try:
   64:             yield result
   65:         finally:
   66:             result.flush()
   67:             os.fsync(result.fileno())
   68: 
   69: 
   70: replace = retry(stop_after_delay=1, wait=0.25)(os.replace)
   71: 
   72: 
   73: # test_writable_dir and _test_writable_dir_win are copied from Flit,
   74: # with the author's agreement to also place them under pip's license.
   75: def test_writable_dir(path: str) -> bool:
   76:     """Check if a directory is writable.
   77: 
   78:     Uses os.access() on POSIX, tries creating files on Windows.
   79:     """
   80:     # If the directory doesn't exist, find the closest parent that does.
   81:     while not os.path.isdir(path):
   82:         parent = os.path.dirname(path)
   83:         if parent == path:
   84:             break  # Should never get here, but infinite loops are bad
   85:         path = parent
   86: 
   87:     if os.name == "posix":
   88:         return os.access(path, os.W_OK)
   89: 
   90:     return _test_writable_dir_win(path)
   91: 
   92: 
   93: def _test_writable_dir_win(path: str) -> bool:
   94:     # os.access doesn't work on Windows: http://bugs.python.org/issue2528
   95:     # and we can't use tempfile: http://bugs.python.org/issue22107
   96:     basename = "accesstest_deleteme_fishfingers_custard_"
   97:     alphabet = "abcdefghijklmnopqrstuvwxyz0123456789"
   98:     for _ in range(10):
   99:         name = basename + "".join(random.choice(alphabet) for _ in range(6))
  100:         file = os.path.join(path, name)
  101:         try:
  102:             fd = os.open(file, os.O_RDWR | os.O_CREAT | os.O_EXCL)
  103:         except FileExistsError:
  104:             pass
  105:         except PermissionError:
  106:             # This could be because there's a directory with the same name.
  107:             # But it's highly unlikely there's a directory called that,
  108:             # so we'll assume it's because the parent dir is not writable.
  109:             # This could as well be because the parent dir is not readable,
  110:             # due to non-privileged user access.
  111:             return False
  112:         else:
  113:             os.close(fd)
  114:             os.unlink(file)
  115:             return True
  116: 
  117:     # This should never be reached
  118:     raise OSError("Unexpected condition testing for writable directory")
  119: 
  120: 
  121: def find_files(path: str, pattern: str) -> list[str]:
  122:     """Returns a list of absolute paths of files beneath path, recursively,
  123:     with filenames which match the UNIX-style shell glob pattern."""
  124:     result: list[str] = []
  125:     for root, _, files in os.walk(path):
  126:         matches = fnmatch.filter(files, pattern)
  127:         result.extend(os.path.join(root, f) for f in matches)
  128:     return result
  129: 
  130: 
  131: def file_size(path: str) -> int | float:
  132:     # If it's a symlink, return 0.
  133:     if os.path.islink(path):
  134:         return 0
  135:     return os.path.getsize(path)
  136: 
  137: 
  138: def format_file_size(path: str) -> str:
  139:     return format_size(file_size(path))
  140: 
  141: 
  142: def directory_size(path: str) -> int | float:
  143:     size = 0.0
  144:     for root, _dirs, files in os.walk(path):
  145:         for filename in files:
  146:             file_path = os.path.join(root, filename)
  147:             size += file_size(file_path)
  148:     return size
  149: 
  150: 
  151: def format_directory_size(path: str) -> str:
  152:     return format_size(directory_size(path))
