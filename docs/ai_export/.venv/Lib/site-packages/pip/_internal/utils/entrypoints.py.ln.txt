    1: from __future__ import annotations
    2: 
    3: import itertools
    4: import os
    5: import shutil
    6: import sys
    7: 
    8: from pip._internal.cli.main import main
    9: from pip._internal.utils.compat import WINDOWS
   10: 
   11: _EXECUTABLE_NAMES = [
   12:     "pip",
   13:     f"pip{sys.version_info.major}",
   14:     f"pip{sys.version_info.major}.{sys.version_info.minor}",
   15: ]
   16: if WINDOWS:
   17:     _allowed_extensions = {"", ".exe"}
   18:     _EXECUTABLE_NAMES = [
   19:         "".join(parts)
   20:         for parts in itertools.product(_EXECUTABLE_NAMES, _allowed_extensions)
   21:     ]
   22: 
   23: 
   24: def _wrapper(args: list[str] | None = None) -> int:
   25:     """Central wrapper for all old entrypoints.
   26: 
   27:     Historically pip has had several entrypoints defined. Because of issues
   28:     arising from PATH, sys.path, multiple Pythons, their interactions, and most
   29:     of them having a pip installed, users suffer every time an entrypoint gets
   30:     moved.
   31: 
   32:     To alleviate this pain, and provide a mechanism for warning users and
   33:     directing them to an appropriate place for help, we now define all of
   34:     our old entrypoints as wrappers for the current one.
   35:     """
   36:     sys.stderr.write(
   37:         "WARNING: pip is being invoked by an old script wrapper. This will "
   38:         "fail in a future version of pip.\n"
   39:         "Please see https://github.com/pypa/pip/issues/5599 for advice on "
   40:         "fixing the underlying issue.\n"
   41:         "To avoid this problem you can invoke Python with '-m pip' instead of "
   42:         "running pip directly.\n"
   43:     )
   44:     return main(args)
   45: 
   46: 
   47: def get_best_invocation_for_this_pip() -> str:
   48:     """Try to figure out the best way to invoke pip in the current environment."""
   49:     binary_directory = "Scripts" if WINDOWS else "bin"
   50:     binary_prefix = os.path.join(sys.prefix, binary_directory)
   51: 
   52:     # Try to use pip[X[.Y]] names, if those executables for this environment are
   53:     # the first on PATH with that name.
   54:     path_parts = os.path.normcase(os.environ.get("PATH", "")).split(os.pathsep)
   55:     exe_are_in_PATH = os.path.normcase(binary_prefix) in path_parts
   56:     if exe_are_in_PATH:
   57:         for exe_name in _EXECUTABLE_NAMES:
   58:             found_executable = shutil.which(exe_name)
   59:             binary_executable = os.path.join(binary_prefix, exe_name)
   60:             if (
   61:                 found_executable
   62:                 and os.path.exists(binary_executable)
   63:                 and os.path.samefile(
   64:                     found_executable,
   65:                     binary_executable,
   66:                 )
   67:             ):
   68:                 return exe_name
   69: 
   70:     # Use the `-m` invocation, if there's no "nice" invocation.
   71:     return f"{get_best_invocation_for_this_python()} -m pip"
   72: 
   73: 
   74: def get_best_invocation_for_this_python() -> str:
   75:     """Try to figure out the best way to invoke the current Python."""
   76:     exe = sys.executable
   77:     exe_name = os.path.basename(exe)
   78: 
   79:     # Try to use the basename, if it's the first executable.
   80:     found_executable = shutil.which(exe_name)
   81:     # Virtual environments often symlink to their parent Python binaries, but we don't
   82:     # want to treat the Python binaries as equivalent when the environment's Python is
   83:     # not on PATH (not activated). Thus, we don't follow symlinks.
   84:     if found_executable and os.path.samestat(os.lstat(found_executable), os.lstat(exe)):
   85:         return exe_name
   86: 
   87:     # Use the full executable name, because we couldn't find something simpler.
   88:     return exe
