    1: from __future__ import annotations
    2: 
    3: import errno
    4: import getpass
    5: import hashlib
    6: import logging
    7: import os
    8: import posixpath
    9: import shutil
   10: import stat
   11: import sys
   12: import sysconfig
   13: import urllib.parse
   14: from collections.abc import Generator, Iterable, Iterator, Mapping, Sequence
   15: from dataclasses import dataclass
   16: from functools import partial
   17: from io import StringIO
   18: from itertools import filterfalse, tee, zip_longest
   19: from pathlib import Path
   20: from types import FunctionType, TracebackType
   21: from typing import (
   22:     Any,
   23:     BinaryIO,
   24:     Callable,
   25:     Optional,
   26:     TextIO,
   27:     TypeVar,
   28:     cast,
   29: )
   30: 
   31: from pip._vendor.packaging.requirements import Requirement
   32: from pip._vendor.pyproject_hooks import BuildBackendHookCaller
   33: 
   34: from pip import __version__
   35: from pip._internal.exceptions import CommandError, ExternallyManagedEnvironment
   36: from pip._internal.locations import get_major_minor_version
   37: from pip._internal.utils.compat import WINDOWS
   38: from pip._internal.utils.retry import retry
   39: from pip._internal.utils.virtualenv import running_under_virtualenv
   40: 
   41: __all__ = [
   42:     "rmtree",
   43:     "display_path",
   44:     "backup_dir",
   45:     "ask",
   46:     "splitext",
   47:     "format_size",
   48:     "is_installable_dir",
   49:     "normalize_path",
   50:     "renames",
   51:     "get_prog",
   52:     "ensure_dir",
   53:     "remove_auth_from_url",
   54:     "check_externally_managed",
   55:     "ConfiguredBuildBackendHookCaller",
   56: ]
   57: 
   58: logger = logging.getLogger(__name__)
   59: 
   60: T = TypeVar("T")
   61: ExcInfo = tuple[type[BaseException], BaseException, TracebackType]
   62: VersionInfo = tuple[int, int, int]
   63: NetlocTuple = tuple[str, tuple[Optional[str], Optional[str]]]
   64: OnExc = Callable[[FunctionType, Path, BaseException], Any]
   65: OnErr = Callable[[FunctionType, Path, ExcInfo], Any]
   66: 
   67: FILE_CHUNK_SIZE = 1024 * 1024
   68: 
   69: 
   70: def get_pip_version() -> str:
   71:     pip_pkg_dir = os.path.join(os.path.dirname(__file__), "..", "..")
   72:     pip_pkg_dir = os.path.abspath(pip_pkg_dir)
   73: 
   74:     return f"pip {__version__} from {pip_pkg_dir} (python {get_major_minor_version()})"
   75: 
   76: 
   77: def normalize_version_info(py_version_info: tuple[int, ...]) -> tuple[int, int, int]:
   78:     """
   79:     Convert a tuple of ints representing a Python version to one of length
   80:     three.
   81: 
   82:     :param py_version_info: a tuple of ints representing a Python version,
   83:         or None to specify no version. The tuple can have any length.
   84: 
   85:     :return: a tuple of length three if `py_version_info` is non-None.
   86:         Otherwise, return `py_version_info` unchanged (i.e. None).
   87:     """
   88:     if len(py_version_info) < 3:
   89:         py_version_info += (3 - len(py_version_info)) * (0,)
   90:     elif len(py_version_info) > 3:
   91:         py_version_info = py_version_info[:3]
   92: 
   93:     return cast("VersionInfo", py_version_info)
   94: 
   95: 
   96: def ensure_dir(path: str) -> None:
   97:     """os.path.makedirs without EEXIST."""
   98:     try:
   99:         os.makedirs(path)
  100:     except OSError as e:
  101:         # Windows can raise spurious ENOTEMPTY errors. See #6426.
  102:         if e.errno != errno.EEXIST and e.errno != errno.ENOTEMPTY:
  103:             raise
  104: 
  105: 
  106: def get_prog() -> str:
  107:     try:
  108:         prog = os.path.basename(sys.argv[0])
  109:         if prog in ("__main__.py", "-c"):
  110:             return f"{sys.executable} -m pip"
  111:         else:
  112:             return prog
  113:     except (AttributeError, TypeError, IndexError):
  114:         pass
  115:     return "pip"
  116: 
  117: 
  118: # Retry every half second for up to 3 seconds
  119: @retry(stop_after_delay=3, wait=0.5)
  120: def rmtree(dir: str, ignore_errors: bool = False, onexc: OnExc | None = None) -> None:
  121:     if ignore_errors:
  122:         onexc = _onerror_ignore
  123:     if onexc is None:
  124:         onexc = _onerror_reraise
  125:     handler: OnErr = partial(rmtree_errorhandler, onexc=onexc)
  126:     if sys.version_info >= (3, 12):
  127:         # See https://docs.python.org/3.12/whatsnew/3.12.html#shutil.
  128:         shutil.rmtree(dir, onexc=handler)  # type: ignore
  129:     else:
  130:         shutil.rmtree(dir, onerror=handler)  # type: ignore
  131: 
  132: 
  133: def _onerror_ignore(*_args: Any) -> None:
  134:     pass
  135: 
  136: 
  137: def _onerror_reraise(*_args: Any) -> None:
  138:     raise  # noqa: PLE0704 - Bare exception used to reraise existing exception
  139: 
  140: 
  141: def rmtree_errorhandler(
  142:     func: FunctionType,
  143:     path: Path,
  144:     exc_info: ExcInfo | BaseException,
  145:     *,
  146:     onexc: OnExc = _onerror_reraise,
  147: ) -> None:
  148:     """
  149:     `rmtree` error handler to 'force' a file remove (i.e. like `rm -f`).
  150: 
  151:     * If a file is readonly then it's write flag is set and operation is
  152:       retried.
  153: 
  154:     * `onerror` is the original callback from `rmtree(... onerror=onerror)`
  155:       that is chained at the end if the "rm -f" still fails.
  156:     """
  157:     try:
  158:         st_mode = os.stat(path).st_mode
  159:     except OSError:
  160:         # it's equivalent to os.path.exists
  161:         return
  162: 
  163:     if not st_mode & stat.S_IWRITE:
  164:         # convert to read/write
  165:         try:
  166:             os.chmod(path, st_mode | stat.S_IWRITE)
  167:         except OSError:
  168:             pass
  169:         else:
  170:             # use the original function to repeat the operation
  171:             try:
  172:                 func(path)
  173:                 return
  174:             except OSError:
  175:                 pass
  176: 
  177:     if not isinstance(exc_info, BaseException):
  178:         _, exc_info, _ = exc_info
  179:     onexc(func, path, exc_info)
  180: 
  181: 
  182: def display_path(path: str) -> str:
  183:     """Gives the display value for a given path, making it relative to cwd
  184:     if possible."""
  185:     path = os.path.normcase(os.path.abspath(path))
  186:     if path.startswith(os.getcwd() + os.path.sep):
  187:         path = "." + path[len(os.getcwd()) :]
  188:     return path
  189: 
  190: 
  191: def backup_dir(dir: str, ext: str = ".bak") -> str:
  192:     """Figure out the name of a directory to back up the given dir to
  193:     (adding .bak, .bak2, etc)"""
  194:     n = 1
  195:     extension = ext
  196:     while os.path.exists(dir + extension):
  197:         n += 1
  198:         extension = ext + str(n)
  199:     return dir + extension
  200: 
  201: 
  202: def ask_path_exists(message: str, options: Iterable[str]) -> str:
  203:     for action in os.environ.get("PIP_EXISTS_ACTION", "").split():
  204:         if action in options:
  205:             return action
  206:     return ask(message, options)
  207: 
  208: 
  209: def _check_no_input(message: str) -> None:
  210:     """Raise an error if no input is allowed."""
  211:     if os.environ.get("PIP_NO_INPUT"):
  212:         raise Exception(
  213:             f"No input was expected ($PIP_NO_INPUT set); question: {message}"
  214:         )
  215: 
  216: 
  217: def ask(message: str, options: Iterable[str]) -> str:
  218:     """Ask the message interactively, with the given possible responses"""
  219:     while 1:
  220:         _check_no_input(message)
  221:         response = input(message)
  222:         response = response.strip().lower()
  223:         if response not in options:
  224:             print(
  225:                 "Your response ({!r}) was not one of the expected responses: "
  226:                 "{}".format(response, ", ".join(options))
  227:             )
  228:         else:
  229:             return response
  230: 
  231: 
  232: def ask_input(message: str) -> str:
  233:     """Ask for input interactively."""
  234:     _check_no_input(message)
  235:     return input(message)
  236: 
  237: 
  238: def ask_password(message: str) -> str:
  239:     """Ask for a password interactively."""
  240:     _check_no_input(message)
  241:     return getpass.getpass(message)
  242: 
  243: 
  244: def strtobool(val: str) -> int:
  245:     """Convert a string representation of truth to true (1) or false (0).
  246: 
  247:     True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
  248:     are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
  249:     'val' is anything else.
  250:     """
  251:     val = val.lower()
  252:     if val in ("y", "yes", "t", "true", "on", "1"):
  253:         return 1
  254:     elif val in ("n", "no", "f", "false", "off", "0"):
  255:         return 0
  256:     else:
  257:         raise ValueError(f"invalid truth value {val!r}")
  258: 
  259: 
  260: def format_size(bytes: float) -> str:
  261:     if bytes > 1000 * 1000:
  262:         return f"{bytes / 1000.0 / 1000:.1f} MB"
  263:     elif bytes > 10 * 1000:
  264:         return f"{int(bytes / 1000)} kB"
  265:     elif bytes > 1000:
  266:         return f"{bytes / 1000.0:.1f} kB"
  267:     else:
  268:         return f"{int(bytes)} bytes"
  269: 
  270: 
  271: def tabulate(rows: Iterable[Iterable[Any]]) -> tuple[list[str], list[int]]:
  272:     """Return a list of formatted rows and a list of column sizes.
  273: 
  274:     For example::
  275: 
  276:     >>> tabulate([['foobar', 2000], [0xdeadbeef]])
  277:     (['foobar     2000', '3735928559'], [10, 4])
  278:     """
  279:     rows = [tuple(map(str, row)) for row in rows]
  280:     sizes = [max(map(len, col)) for col in zip_longest(*rows, fillvalue="")]
  281:     table = [" ".join(map(str.ljust, row, sizes)).rstrip() for row in rows]
  282:     return table, sizes
  283: 
  284: 
  285: def is_installable_dir(path: str) -> bool:
  286:     """Is path is a directory containing pyproject.toml or setup.py?
  287: 
  288:     If pyproject.toml exists, this is a PEP 517 project. Otherwise we look for
  289:     a legacy setuptools layout by identifying setup.py. We don't check for the
  290:     setup.cfg because using it without setup.py is only available for PEP 517
  291:     projects, which are already covered by the pyproject.toml check.
  292:     """
  293:     if not os.path.isdir(path):
  294:         return False
  295:     if os.path.isfile(os.path.join(path, "pyproject.toml")):
  296:         return True
  297:     if os.path.isfile(os.path.join(path, "setup.py")):
  298:         return True
  299:     return False
  300: 
  301: 
  302: def read_chunks(
  303:     file: BinaryIO, size: int = FILE_CHUNK_SIZE
  304: ) -> Generator[bytes, None, None]:
  305:     """Yield pieces of data from a file-like object until EOF."""
  306:     while True:
  307:         chunk = file.read(size)
  308:         if not chunk:
  309:             break
  310:         yield chunk
  311: 
  312: 
  313: def normalize_path(path: str, resolve_symlinks: bool = True) -> str:
  314:     """
  315:     Convert a path to its canonical, case-normalized, absolute version.
  316: 
  317:     """
  318:     path = os.path.expanduser(path)
  319:     if resolve_symlinks:
  320:         path = os.path.realpath(path)
  321:     else:
  322:         path = os.path.abspath(path)
  323:     return os.path.normcase(path)
  324: 
  325: 
  326: def splitext(path: str) -> tuple[str, str]:
  327:     """Like os.path.splitext, but take off .tar too"""
  328:     base, ext = posixpath.splitext(path)
  329:     if base.lower().endswith(".tar"):
  330:         ext = base[-4:] + ext
  331:         base = base[:-4]
  332:     return base, ext
  333: 
  334: 
  335: def renames(old: str, new: str) -> None:
  336:     """Like os.renames(), but handles renaming across devices."""
  337:     # Implementation borrowed from os.renames().
  338:     head, tail = os.path.split(new)
  339:     if head and tail and not os.path.exists(head):
  340:         os.makedirs(head)
  341: 
  342:     shutil.move(old, new)
  343: 
  344:     head, tail = os.path.split(old)
  345:     if head and tail:
  346:         try:
  347:             os.removedirs(head)
  348:         except OSError:
  349:             pass
  350: 
  351: 
  352: def is_local(path: str) -> bool:
  353:     """
  354:     Return True if path is within sys.prefix, if we're running in a virtualenv.
  355: 
  356:     If we're not in a virtualenv, all paths are considered "local."
  357: 
  358:     Caution: this function assumes the head of path has been normalized
  359:     with normalize_path.
  360:     """
  361:     if not running_under_virtualenv():
  362:         return True
  363:     return path.startswith(normalize_path(sys.prefix))
  364: 
  365: 
  366: def write_output(msg: Any, *args: Any) -> None:
  367:     logger.info(msg, *args)
  368: 
  369: 
  370: class StreamWrapper(StringIO):
  371:     orig_stream: TextIO
  372: 
  373:     @classmethod
  374:     def from_stream(cls, orig_stream: TextIO) -> StreamWrapper:
  375:         ret = cls()
  376:         ret.orig_stream = orig_stream
  377:         return ret
  378: 
  379:     # compileall.compile_dir() needs stdout.encoding to print to stdout
  380:     # type ignore is because TextIOBase.encoding is writeable
  381:     @property
  382:     def encoding(self) -> str:  # type: ignore
  383:         return self.orig_stream.encoding
  384: 
  385: 
  386: # Simulates an enum
  387: def enum(*sequential: Any, **named: Any) -> type[Any]:
  388:     enums = dict(zip(sequential, range(len(sequential))), **named)
  389:     reverse = {value: key for key, value in enums.items()}
  390:     enums["reverse_mapping"] = reverse
  391:     return type("Enum", (), enums)
  392: 
  393: 
  394: def build_netloc(host: str, port: int | None) -> str:
  395:     """
  396:     Build a netloc from a host-port pair
  397:     """
  398:     if port is None:
  399:         return host
  400:     if ":" in host:
  401:         # Only wrap host with square brackets when it is IPv6
  402:         host = f"[{host}]"
  403:     return f"{host}:{port}"
  404: 
  405: 
  406: def build_url_from_netloc(netloc: str, scheme: str = "https") -> str:
  407:     """
  408:     Build a full URL from a netloc.
  409:     """
  410:     if netloc.count(":") >= 2 and "@" not in netloc and "[" not in netloc:
  411:         # It must be a bare IPv6 address, so wrap it with brackets.
  412:         netloc = f"[{netloc}]"
  413:     return f"{scheme}://{netloc}"
  414: 
  415: 
  416: def parse_netloc(netloc: str) -> tuple[str | None, int | None]:
  417:     """
  418:     Return the host-port pair from a netloc.
  419:     """
  420:     url = build_url_from_netloc(netloc)
  421:     parsed = urllib.parse.urlparse(url)
  422:     return parsed.hostname, parsed.port
  423: 
  424: 
  425: def split_auth_from_netloc(netloc: str) -> NetlocTuple:
  426:     """
  427:     Parse out and remove the auth information from a netloc.
  428: 
  429:     Returns: (netloc, (username, password)).
  430:     """
  431:     if "@" not in netloc:
  432:         return netloc, (None, None)
  433: 
  434:     # Split from the right because that's how urllib.parse.urlsplit()
  435:     # behaves if more than one @ is present (which can be checked using
  436:     # the password attribute of urlsplit()'s return value).
  437:     auth, netloc = netloc.rsplit("@", 1)
  438:     pw: str | None = None
  439:     if ":" in auth:
  440:         # Split from the left because that's how urllib.parse.urlsplit()
  441:         # behaves if more than one : is present (which again can be checked
  442:         # using the password attribute of the return value)
  443:         user, pw = auth.split(":", 1)
  444:     else:
  445:         user, pw = auth, None
  446: 
  447:     user = urllib.parse.unquote(user)
  448:     if pw is not None:
  449:         pw = urllib.parse.unquote(pw)
  450: 
  451:     return netloc, (user, pw)
  452: 
  453: 
  454: def redact_netloc(netloc: str) -> str:
  455:     """
  456:     Replace the sensitive data in a netloc with "****", if it exists.
  457: 
  458:     For example:
  459:         - "user:pass@example.com" returns "user:****@example.com"
  460:         - "accesstoken@example.com" returns "****@example.com"
  461:     """
  462:     netloc, (user, password) = split_auth_from_netloc(netloc)
  463:     if user is None:
  464:         return netloc
  465:     if password is None:
  466:         user = "****"
  467:         password = ""
  468:     else:
  469:         user = urllib.parse.quote(user)
  470:         password = ":****"
  471:     return f"{user}{password}@{netloc}"
  472: 
  473: 
  474: def _transform_url(
  475:     url: str, transform_netloc: Callable[[str], tuple[Any, ...]]
  476: ) -> tuple[str, NetlocTuple]:
  477:     """Transform and replace netloc in a url.
  478: 
  479:     transform_netloc is a function taking the netloc and returning a
  480:     tuple. The first element of this tuple is the new netloc. The
  481:     entire tuple is returned.
  482: 
  483:     Returns a tuple containing the transformed url as item 0 and the
  484:     original tuple returned by transform_netloc as item 1.
  485:     """
  486:     purl = urllib.parse.urlsplit(url)
  487:     netloc_tuple = transform_netloc(purl.netloc)
  488:     # stripped url
  489:     url_pieces = (purl.scheme, netloc_tuple[0], purl.path, purl.query, purl.fragment)
  490:     surl = urllib.parse.urlunsplit(url_pieces)
  491:     return surl, cast("NetlocTuple", netloc_tuple)
  492: 
  493: 
  494: def _get_netloc(netloc: str) -> NetlocTuple:
  495:     return split_auth_from_netloc(netloc)
  496: 
  497: 
  498: def _redact_netloc(netloc: str) -> tuple[str]:
  499:     return (redact_netloc(netloc),)
  500: 
  501: 
  502: def split_auth_netloc_from_url(
  503:     url: str,
  504: ) -> tuple[str, str, tuple[str | None, str | None]]:
  505:     """
  506:     Parse a url into separate netloc, auth, and url with no auth.
  507: 
  508:     Returns: (url_without_auth, netloc, (username, password))
  509:     """
  510:     url_without_auth, (netloc, auth) = _transform_url(url, _get_netloc)
  511:     return url_without_auth, netloc, auth
  512: 
  513: 
  514: def remove_auth_from_url(url: str) -> str:
  515:     """Return a copy of url with 'username:password@' removed."""
  516:     # username/pass params are passed to subversion through flags
  517:     # and are not recognized in the url.
  518:     return _transform_url(url, _get_netloc)[0]
  519: 
  520: 
  521: def redact_auth_from_url(url: str) -> str:
  522:     """Replace the password in a given url with ****."""
  523:     return _transform_url(url, _redact_netloc)[0]
  524: 
  525: 
  526: def redact_auth_from_requirement(req: Requirement) -> str:
  527:     """Replace the password in a given requirement url with ****."""
  528:     if not req.url:
  529:         return str(req)
  530:     return str(req).replace(req.url, redact_auth_from_url(req.url))
  531: 
  532: 
  533: @dataclass(frozen=True)
  534: class HiddenText:
  535:     secret: str
  536:     redacted: str
  537: 
  538:     def __repr__(self) -> str:
  539:         return f"<HiddenText {str(self)!r}>"
  540: 
  541:     def __str__(self) -> str:
  542:         return self.redacted
  543: 
  544:     # This is useful for testing.
  545:     def __eq__(self, other: Any) -> bool:
  546:         if type(self) is not type(other):
  547:             return False
  548: 
  549:         # The string being used for redaction doesn't also have to match,
  550:         # just the raw, original string.
  551:         return self.secret == other.secret
  552: 
  553: 
  554: def hide_value(value: str) -> HiddenText:
  555:     return HiddenText(value, redacted="****")
  556: 
  557: 
  558: def hide_url(url: str) -> HiddenText:
  559:     redacted = redact_auth_from_url(url)
  560:     return HiddenText(url, redacted=redacted)
  561: 
  562: 
  563: def protect_pip_from_modification_on_windows(modifying_pip: bool) -> None:
  564:     """Protection of pip.exe from modification on Windows
  565: 
  566:     On Windows, any operation modifying pip should be run as:
  567:         python -m pip ...
  568:     """
  569:     pip_names = [
  570:         "pip",
  571:         f"pip{sys.version_info.major}",
  572:         f"pip{sys.version_info.major}.{sys.version_info.minor}",
  573:     ]
  574: 
  575:     # See https://github.com/pypa/pip/issues/1299 for more discussion
  576:     should_show_use_python_msg = (
  577:         modifying_pip and WINDOWS and os.path.basename(sys.argv[0]) in pip_names
  578:     )
  579: 
  580:     if should_show_use_python_msg:
  581:         new_command = [sys.executable, "-m", "pip"] + sys.argv[1:]
  582:         raise CommandError(
  583:             "To modify pip, please run the following command:\n{}".format(
  584:                 " ".join(new_command)
  585:             )
  586:         )
  587: 
  588: 
  589: def check_externally_managed() -> None:
  590:     """Check whether the current environment is externally managed.
  591: 
  592:     If the ``EXTERNALLY-MANAGED`` config file is found, the current environment
  593:     is considered externally managed, and an ExternallyManagedEnvironment is
  594:     raised.
  595:     """
  596:     if running_under_virtualenv():
  597:         return
  598:     marker = os.path.join(sysconfig.get_path("stdlib"), "EXTERNALLY-MANAGED")
  599:     if not os.path.isfile(marker):
  600:         return
  601:     raise ExternallyManagedEnvironment.from_config(marker)
  602: 
  603: 
  604: def is_console_interactive() -> bool:
  605:     """Is this console interactive?"""
  606:     return sys.stdin is not None and sys.stdin.isatty()
  607: 
  608: 
  609: def hash_file(path: str, blocksize: int = 1 << 20) -> tuple[Any, int]:
  610:     """Return (hash, length) for path using hashlib.sha256()"""
  611: 
  612:     h = hashlib.sha256()
  613:     length = 0
  614:     with open(path, "rb") as f:
  615:         for block in read_chunks(f, size=blocksize):
  616:             length += len(block)
  617:             h.update(block)
  618:     return h, length
  619: 
  620: 
  621: def pairwise(iterable: Iterable[Any]) -> Iterator[tuple[Any, Any]]:
  622:     """
  623:     Return paired elements.
  624: 
  625:     For example:
  626:         s -> (s0, s1), (s2, s3), (s4, s5), ...
  627:     """
  628:     iterable = iter(iterable)
  629:     return zip_longest(iterable, iterable)
  630: 
  631: 
  632: def partition(
  633:     pred: Callable[[T], bool], iterable: Iterable[T]
  634: ) -> tuple[Iterable[T], Iterable[T]]:
  635:     """
  636:     Use a predicate to partition entries into false entries and true entries,
  637:     like
  638: 
  639:         partition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9
  640:     """
  641:     t1, t2 = tee(iterable)
  642:     return filterfalse(pred, t1), filter(pred, t2)
  643: 
  644: 
  645: class ConfiguredBuildBackendHookCaller(BuildBackendHookCaller):
  646:     def __init__(
  647:         self,
  648:         config_holder: Any,
  649:         source_dir: str,
  650:         build_backend: str,
  651:         backend_path: str | None = None,
  652:         runner: Callable[..., None] | None = None,
  653:         python_executable: str | None = None,
  654:     ):
  655:         super().__init__(
  656:             source_dir, build_backend, backend_path, runner, python_executable
  657:         )
  658:         self.config_holder = config_holder
  659: 
  660:     def build_wheel(
  661:         self,
  662:         wheel_directory: str,
  663:         config_settings: Mapping[str, Any] | None = None,
  664:         metadata_directory: str | None = None,
  665:     ) -> str:
  666:         cs = self.config_holder.config_settings
  667:         return super().build_wheel(
  668:             wheel_directory, config_settings=cs, metadata_directory=metadata_directory
  669:         )
  670: 
  671:     def build_sdist(
  672:         self,
  673:         sdist_directory: str,
  674:         config_settings: Mapping[str, Any] | None = None,
  675:     ) -> str:
  676:         cs = self.config_holder.config_settings
  677:         return super().build_sdist(sdist_directory, config_settings=cs)
  678: 
  679:     def build_editable(
  680:         self,
  681:         wheel_directory: str,
  682:         config_settings: Mapping[str, Any] | None = None,
  683:         metadata_directory: str | None = None,
  684:     ) -> str:
  685:         cs = self.config_holder.config_settings
  686:         return super().build_editable(
  687:             wheel_directory, config_settings=cs, metadata_directory=metadata_directory
  688:         )
  689: 
  690:     def get_requires_for_build_wheel(
  691:         self, config_settings: Mapping[str, Any] | None = None
  692:     ) -> Sequence[str]:
  693:         cs = self.config_holder.config_settings
  694:         return super().get_requires_for_build_wheel(config_settings=cs)
  695: 
  696:     def get_requires_for_build_sdist(
  697:         self, config_settings: Mapping[str, Any] | None = None
  698:     ) -> Sequence[str]:
  699:         cs = self.config_holder.config_settings
  700:         return super().get_requires_for_build_sdist(config_settings=cs)
  701: 
  702:     def get_requires_for_build_editable(
  703:         self, config_settings: Mapping[str, Any] | None = None
  704:     ) -> Sequence[str]:
  705:         cs = self.config_holder.config_settings
  706:         return super().get_requires_for_build_editable(config_settings=cs)
  707: 
  708:     def prepare_metadata_for_build_wheel(
  709:         self,
  710:         metadata_directory: str,
  711:         config_settings: Mapping[str, Any] | None = None,
  712:         _allow_fallback: bool = True,
  713:     ) -> str:
  714:         cs = self.config_holder.config_settings
  715:         return super().prepare_metadata_for_build_wheel(
  716:             metadata_directory=metadata_directory,
  717:             config_settings=cs,
  718:             _allow_fallback=_allow_fallback,
  719:         )
  720: 
  721:     def prepare_metadata_for_build_editable(
  722:         self,
  723:         metadata_directory: str,
  724:         config_settings: Mapping[str, Any] | None = None,
  725:         _allow_fallback: bool = True,
  726:     ) -> str | None:
  727:         cs = self.config_holder.config_settings
  728:         return super().prepare_metadata_for_build_editable(
  729:             metadata_directory=metadata_directory,
  730:             config_settings=cs,
  731:             _allow_fallback=_allow_fallback,
  732:         )
  733: 
  734: 
  735: def warn_if_run_as_root() -> None:
  736:     """Output a warning for sudo users on Unix.
  737: 
  738:     In a virtual environment, sudo pip still writes to virtualenv.
  739:     On Windows, users may run pip as Administrator without issues.
  740:     This warning only applies to Unix root users outside of virtualenv.
  741:     """
  742:     if running_under_virtualenv():
  743:         return
  744:     if not hasattr(os, "getuid"):
  745:         return
  746:     # On Windows, there are no "system managed" Python packages. Installing as
  747:     # Administrator via pip is the correct way of updating system environments.
  748:     #
  749:     # We choose sys.platform over utils.compat.WINDOWS here to enable Mypy platform
  750:     # checks: https://mypy.readthedocs.io/en/stable/common_issues.html
  751:     if sys.platform == "win32" or sys.platform == "cygwin":
  752:         return
  753: 
  754:     if os.getuid() != 0:
  755:         return
  756: 
  757:     logger.warning(
  758:         "Running pip as the 'root' user can result in broken permissions and "
  759:         "conflicting behaviour with the system package manager, possibly "
  760:         "rendering your system unusable. "
  761:         "It is recommended to use a virtual environment instead: "
  762:         "https://pip.pypa.io/warnings/venv. "
  763:         "Use the --root-user-action option if you know what you are doing and "
  764:         "want to suppress this warning."
  765:     )
