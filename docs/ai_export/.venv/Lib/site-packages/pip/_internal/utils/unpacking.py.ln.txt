    1: """Utilities related archives."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import logging
    6: import os
    7: import shutil
    8: import stat
    9: import sys
   10: import tarfile
   11: import zipfile
   12: from collections.abc import Iterable
   13: from zipfile import ZipInfo
   14: 
   15: from pip._internal.exceptions import InstallationError
   16: from pip._internal.utils.filetypes import (
   17:     BZ2_EXTENSIONS,
   18:     TAR_EXTENSIONS,
   19:     XZ_EXTENSIONS,
   20:     ZIP_EXTENSIONS,
   21: )
   22: from pip._internal.utils.misc import ensure_dir
   23: 
   24: logger = logging.getLogger(__name__)
   25: 
   26: 
   27: SUPPORTED_EXTENSIONS = ZIP_EXTENSIONS + TAR_EXTENSIONS
   28: 
   29: try:
   30:     import bz2  # noqa
   31: 
   32:     SUPPORTED_EXTENSIONS += BZ2_EXTENSIONS
   33: except ImportError:
   34:     logger.debug("bz2 module is not available")
   35: 
   36: try:
   37:     # Only for Python 3.3+
   38:     import lzma  # noqa
   39: 
   40:     SUPPORTED_EXTENSIONS += XZ_EXTENSIONS
   41: except ImportError:
   42:     logger.debug("lzma module is not available")
   43: 
   44: 
   45: def current_umask() -> int:
   46:     """Get the current umask which involves having to set it temporarily."""
   47:     mask = os.umask(0)
   48:     os.umask(mask)
   49:     return mask
   50: 
   51: 
   52: def split_leading_dir(path: str) -> list[str]:
   53:     path = path.lstrip("/").lstrip("\\")
   54:     if "/" in path and (
   55:         ("\\" in path and path.find("/") < path.find("\\")) or "\\" not in path
   56:     ):
   57:         return path.split("/", 1)
   58:     elif "\\" in path:
   59:         return path.split("\\", 1)
   60:     else:
   61:         return [path, ""]
   62: 
   63: 
   64: def has_leading_dir(paths: Iterable[str]) -> bool:
   65:     """Returns true if all the paths have the same leading path name
   66:     (i.e., everything is in one subdirectory in an archive)"""
   67:     common_prefix = None
   68:     for path in paths:
   69:         prefix, rest = split_leading_dir(path)
   70:         if not prefix:
   71:             return False
   72:         elif common_prefix is None:
   73:             common_prefix = prefix
   74:         elif prefix != common_prefix:
   75:             return False
   76:     return True
   77: 
   78: 
   79: def is_within_directory(directory: str, target: str) -> bool:
   80:     """
   81:     Return true if the absolute path of target is within the directory
   82:     """
   83:     abs_directory = os.path.abspath(directory)
   84:     abs_target = os.path.abspath(target)
   85: 
   86:     prefix = os.path.commonprefix([abs_directory, abs_target])
   87:     return prefix == abs_directory
   88: 
   89: 
   90: def _get_default_mode_plus_executable() -> int:
   91:     return 0o777 & ~current_umask() | 0o111
   92: 
   93: 
   94: def set_extracted_file_to_default_mode_plus_executable(path: str) -> None:
   95:     """
   96:     Make file present at path have execute for user/group/world
   97:     (chmod +x) is no-op on windows per python docs
   98:     """
   99:     os.chmod(path, _get_default_mode_plus_executable())
  100: 
  101: 
  102: def zip_item_is_executable(info: ZipInfo) -> bool:
  103:     mode = info.external_attr >> 16
  104:     # if mode and regular file and any execute permissions for
  105:     # user/group/world?
  106:     return bool(mode and stat.S_ISREG(mode) and mode & 0o111)
  107: 
  108: 
  109: def unzip_file(filename: str, location: str, flatten: bool = True) -> None:
  110:     """
  111:     Unzip the file (with path `filename`) to the destination `location`.  All
  112:     files are written based on system defaults and umask (i.e. permissions are
  113:     not preserved), except that regular file members with any execute
  114:     permissions (user, group, or world) have "chmod +x" applied after being
  115:     written. Note that for windows, any execute changes using os.chmod are
  116:     no-ops per the python docs.
  117:     """
  118:     ensure_dir(location)
  119:     zipfp = open(filename, "rb")
  120:     try:
  121:         zip = zipfile.ZipFile(zipfp, allowZip64=True)
  122:         leading = has_leading_dir(zip.namelist()) and flatten
  123:         for info in zip.infolist():
  124:             name = info.filename
  125:             fn = name
  126:             if leading:
  127:                 fn = split_leading_dir(name)[1]
  128:             fn = os.path.join(location, fn)
  129:             dir = os.path.dirname(fn)
  130:             if not is_within_directory(location, fn):
  131:                 message = (
  132:                     "The zip file ({}) has a file ({}) trying to install "
  133:                     "outside target directory ({})"
  134:                 )
  135:                 raise InstallationError(message.format(filename, fn, location))
  136:             if fn.endswith(("/", "\\")):
  137:                 # A directory
  138:                 ensure_dir(fn)
  139:             else:
  140:                 ensure_dir(dir)
  141:                 # Don't use read() to avoid allocating an arbitrarily large
  142:                 # chunk of memory for the file's content
  143:                 fp = zip.open(name)
  144:                 try:
  145:                     with open(fn, "wb") as destfp:
  146:                         shutil.copyfileobj(fp, destfp)
  147:                 finally:
  148:                     fp.close()
  149:                     if zip_item_is_executable(info):
  150:                         set_extracted_file_to_default_mode_plus_executable(fn)
  151:     finally:
  152:         zipfp.close()
  153: 
  154: 
  155: def untar_file(filename: str, location: str) -> None:
  156:     """
  157:     Untar the file (with path `filename`) to the destination `location`.
  158:     All files are written based on system defaults and umask (i.e. permissions
  159:     are not preserved), except that regular file members with any execute
  160:     permissions (user, group, or world) have "chmod +x" applied on top of the
  161:     default.  Note that for windows, any execute changes using os.chmod are
  162:     no-ops per the python docs.
  163:     """
  164:     ensure_dir(location)
  165:     if filename.lower().endswith(".gz") or filename.lower().endswith(".tgz"):
  166:         mode = "r:gz"
  167:     elif filename.lower().endswith(BZ2_EXTENSIONS):
  168:         mode = "r:bz2"
  169:     elif filename.lower().endswith(XZ_EXTENSIONS):
  170:         mode = "r:xz"
  171:     elif filename.lower().endswith(".tar"):
  172:         mode = "r"
  173:     else:
  174:         logger.warning(
  175:             "Cannot determine compression type for file %s",
  176:             filename,
  177:         )
  178:         mode = "r:*"
  179: 
  180:     tar = tarfile.open(filename, mode, encoding="utf-8")  # type: ignore
  181:     try:
  182:         leading = has_leading_dir([member.name for member in tar.getmembers()])
  183: 
  184:         # PEP 706 added `tarfile.data_filter`, and made some other changes to
  185:         # Python's tarfile module (see below). The features were backported to
  186:         # security releases.
  187:         try:
  188:             data_filter = tarfile.data_filter
  189:         except AttributeError:
  190:             _untar_without_filter(filename, location, tar, leading)
  191:         else:
  192:             default_mode_plus_executable = _get_default_mode_plus_executable()
  193: 
  194:             if leading:
  195:                 # Strip the leading directory from all files in the archive,
  196:                 # including hardlink targets (which are relative to the
  197:                 # unpack location).
  198:                 for member in tar.getmembers():
  199:                     name_lead, name_rest = split_leading_dir(member.name)
  200:                     member.name = name_rest
  201:                     if member.islnk():
  202:                         lnk_lead, lnk_rest = split_leading_dir(member.linkname)
  203:                         if lnk_lead == name_lead:
  204:                             member.linkname = lnk_rest
  205: 
  206:             def pip_filter(member: tarfile.TarInfo, path: str) -> tarfile.TarInfo:
  207:                 orig_mode = member.mode
  208:                 try:
  209:                     try:
  210:                         member = data_filter(member, location)
  211:                     except tarfile.LinkOutsideDestinationError:
  212:                         if sys.version_info[:3] in {
  213:                             (3, 9, 17),
  214:                             (3, 10, 12),
  215:                             (3, 11, 4),
  216:                         }:
  217:                             # The tarfile filter in specific Python versions
  218:                             # raises LinkOutsideDestinationError on valid input
  219:                             # (https://github.com/python/cpython/issues/107845)
  220:                             # Ignore the error there, but do use the
  221:                             # more lax `tar_filter`
  222:                             member = tarfile.tar_filter(member, location)
  223:                         else:
  224:                             raise
  225:                 except tarfile.TarError as exc:
  226:                     message = "Invalid member in the tar file {}: {}"
  227:                     # Filter error messages mention the member name.
  228:                     # No need to add it here.
  229:                     raise InstallationError(
  230:                         message.format(
  231:                             filename,
  232:                             exc,
  233:                         )
  234:                     )
  235:                 if member.isfile() and orig_mode & 0o111:
  236:                     member.mode = default_mode_plus_executable
  237:                 else:
  238:                     # See PEP 706 note above.
  239:                     # The PEP changed this from `int` to `Optional[int]`,
  240:                     # where None means "use the default". Mypy doesn't
  241:                     # know this yet.
  242:                     member.mode = None  # type: ignore [assignment]
  243:                 return member
  244: 
  245:             tar.extractall(location, filter=pip_filter)
  246: 
  247:     finally:
  248:         tar.close()
  249: 
  250: 
  251: def _untar_without_filter(
  252:     filename: str,
  253:     location: str,
  254:     tar: tarfile.TarFile,
  255:     leading: bool,
  256: ) -> None:
  257:     """Fallback for Python without tarfile.data_filter"""
  258:     for member in tar.getmembers():
  259:         fn = member.name
  260:         if leading:
  261:             fn = split_leading_dir(fn)[1]
  262:         path = os.path.join(location, fn)
  263:         if not is_within_directory(location, path):
  264:             message = (
  265:                 "The tar file ({}) has a file ({}) trying to install "
  266:                 "outside target directory ({})"
  267:             )
  268:             raise InstallationError(message.format(filename, path, location))
  269:         if member.isdir():
  270:             ensure_dir(path)
  271:         elif member.issym():
  272:             try:
  273:                 tar._extract_member(member, path)
  274:             except Exception as exc:
  275:                 # Some corrupt tar files seem to produce this
  276:                 # (specifically bad symlinks)
  277:                 logger.warning(
  278:                     "In the tar file %s the member %s is invalid: %s",
  279:                     filename,
  280:                     member.name,
  281:                     exc,
  282:                 )
  283:                 continue
  284:         else:
  285:             try:
  286:                 fp = tar.extractfile(member)
  287:             except (KeyError, AttributeError) as exc:
  288:                 # Some corrupt tar files seem to produce this
  289:                 # (specifically bad symlinks)
  290:                 logger.warning(
  291:                     "In the tar file %s the member %s is invalid: %s",
  292:                     filename,
  293:                     member.name,
  294:                     exc,
  295:                 )
  296:                 continue
  297:             ensure_dir(os.path.dirname(path))
  298:             assert fp is not None
  299:             with open(path, "wb") as destfp:
  300:                 shutil.copyfileobj(fp, destfp)
  301:             fp.close()
  302:             # Update the timestamp (useful for cython compiled files)
  303:             tar.utime(member, path)
  304:             # member have any execute permissions for user/group/world?
  305:             if member.mode & 0o111:
  306:                 set_extracted_file_to_default_mode_plus_executable(path)
  307: 
  308: 
  309: def unpack_file(
  310:     filename: str,
  311:     location: str,
  312:     content_type: str | None = None,
  313: ) -> None:
  314:     filename = os.path.realpath(filename)
  315:     if (
  316:         content_type == "application/zip"
  317:         or filename.lower().endswith(ZIP_EXTENSIONS)
  318:         or zipfile.is_zipfile(filename)
  319:     ):
  320:         unzip_file(filename, location, flatten=not filename.endswith(".whl"))
  321:     elif (
  322:         content_type == "application/x-gzip"
  323:         or tarfile.is_tarfile(filename)
  324:         or filename.lower().endswith(TAR_EXTENSIONS + BZ2_EXTENSIONS + XZ_EXTENSIONS)
  325:     ):
  326:         untar_file(filename, location)
  327:     else:
  328:         # FIXME: handle?
  329:         # FIXME: magic signatures?
  330:         logger.critical(
  331:             "Cannot unpack file %s (downloaded from %s, content-type: %s); "
  332:             "cannot detect archive format",
  333:             filename,
  334:             location,
  335:             content_type,
  336:         )
  337:         raise InstallationError(f"Cannot determine archive format of {location}")
