    1: """Exceptions used throughout package.
    2: 
    3: This module MUST NOT try to import from anything within `pip._internal` to
    4: operate. This is expected to be importable from any/all files within the
    5: subpackage and, thus, should not depend on them.
    6: """
    7: 
    8: from __future__ import annotations
    9: 
   10: import configparser
   11: import contextlib
   12: import locale
   13: import logging
   14: import pathlib
   15: import re
   16: import sys
   17: from collections.abc import Iterator
   18: from itertools import chain, groupby, repeat
   19: from typing import TYPE_CHECKING, Literal
   20: 
   21: from pip._vendor.packaging.requirements import InvalidRequirement
   22: from pip._vendor.packaging.version import InvalidVersion
   23: from pip._vendor.rich.console import Console, ConsoleOptions, RenderResult
   24: from pip._vendor.rich.markup import escape
   25: from pip._vendor.rich.text import Text
   26: 
   27: if TYPE_CHECKING:
   28:     from hashlib import _Hash
   29: 
   30:     from pip._vendor.requests.models import Request, Response
   31: 
   32:     from pip._internal.metadata import BaseDistribution
   33:     from pip._internal.network.download import _FileDownload
   34:     from pip._internal.req.req_install import InstallRequirement
   35: 
   36: logger = logging.getLogger(__name__)
   37: 
   38: 
   39: #
   40: # Scaffolding
   41: #
   42: def _is_kebab_case(s: str) -> bool:
   43:     return re.match(r"^[a-z]+(-[a-z]+)*$", s) is not None
   44: 
   45: 
   46: def _prefix_with_indent(
   47:     s: Text | str,
   48:     console: Console,
   49:     *,
   50:     prefix: str,
   51:     indent: str,
   52: ) -> Text:
   53:     if isinstance(s, Text):
   54:         text = s
   55:     else:
   56:         text = console.render_str(s)
   57: 
   58:     return console.render_str(prefix, overflow="ignore") + console.render_str(
   59:         f"\n{indent}", overflow="ignore"
   60:     ).join(text.split(allow_blank=True))
   61: 
   62: 
   63: class PipError(Exception):
   64:     """The base pip error."""
   65: 
   66: 
   67: class DiagnosticPipError(PipError):
   68:     """An error, that presents diagnostic information to the user.
   69: 
   70:     This contains a bunch of logic, to enable pretty presentation of our error
   71:     messages. Each error gets a unique reference. Each error can also include
   72:     additional context, a hint and/or a note -- which are presented with the
   73:     main error message in a consistent style.
   74: 
   75:     This is adapted from the error output styling in `sphinx-theme-builder`.
   76:     """
   77: 
   78:     reference: str
   79: 
   80:     def __init__(
   81:         self,
   82:         *,
   83:         kind: Literal["error", "warning"] = "error",
   84:         reference: str | None = None,
   85:         message: str | Text,
   86:         context: str | Text | None,
   87:         hint_stmt: str | Text | None,
   88:         note_stmt: str | Text | None = None,
   89:         link: str | None = None,
   90:     ) -> None:
   91:         # Ensure a proper reference is provided.
   92:         if reference is None:
   93:             assert hasattr(self, "reference"), "error reference not provided!"
   94:             reference = self.reference
   95:         assert _is_kebab_case(reference), "error reference must be kebab-case!"
   96: 
   97:         self.kind = kind
   98:         self.reference = reference
   99: 
  100:         self.message = message
  101:         self.context = context
  102: 
  103:         self.note_stmt = note_stmt
  104:         self.hint_stmt = hint_stmt
  105: 
  106:         self.link = link
  107: 
  108:         super().__init__(f"<{self.__class__.__name__}: {self.reference}>")
  109: 
  110:     def __repr__(self) -> str:
  111:         return (
  112:             f"<{self.__class__.__name__}("
  113:             f"reference={self.reference!r}, "
  114:             f"message={self.message!r}, "
  115:             f"context={self.context!r}, "
  116:             f"note_stmt={self.note_stmt!r}, "
  117:             f"hint_stmt={self.hint_stmt!r}"
  118:             ")>"
  119:         )
  120: 
  121:     def __rich_console__(
  122:         self,
  123:         console: Console,
  124:         options: ConsoleOptions,
  125:     ) -> RenderResult:
  126:         colour = "red" if self.kind == "error" else "yellow"
  127: 
  128:         yield f"[{colour} bold]{self.kind}[/]: [bold]{self.reference}[/]"
  129:         yield ""
  130: 
  131:         if not options.ascii_only:
  132:             # Present the main message, with relevant context indented.
  133:             if self.context is not None:
  134:                 yield _prefix_with_indent(
  135:                     self.message,
  136:                     console,
  137:                     prefix=f"[{colour}]Г—[/] ",
  138:                     indent=f"[{colour}]в”‚[/] ",
  139:                 )
  140:                 yield _prefix_with_indent(
  141:                     self.context,
  142:                     console,
  143:                     prefix=f"[{colour}]в•°в”Ђ>[/] ",
  144:                     indent=f"[{colour}]   [/] ",
  145:                 )
  146:             else:
  147:                 yield _prefix_with_indent(
  148:                     self.message,
  149:                     console,
  150:                     prefix="[red]Г—[/] ",
  151:                     indent="  ",
  152:                 )
  153:         else:
  154:             yield self.message
  155:             if self.context is not None:
  156:                 yield ""
  157:                 yield self.context
  158: 
  159:         if self.note_stmt is not None or self.hint_stmt is not None:
  160:             yield ""
  161: 
  162:         if self.note_stmt is not None:
  163:             yield _prefix_with_indent(
  164:                 self.note_stmt,
  165:                 console,
  166:                 prefix="[magenta bold]note[/]: ",
  167:                 indent="      ",
  168:             )
  169:         if self.hint_stmt is not None:
  170:             yield _prefix_with_indent(
  171:                 self.hint_stmt,
  172:                 console,
  173:                 prefix="[cyan bold]hint[/]: ",
  174:                 indent="      ",
  175:             )
  176: 
  177:         if self.link is not None:
  178:             yield ""
  179:             yield f"Link: {self.link}"
  180: 
  181: 
  182: #
  183: # Actual Errors
  184: #
  185: class ConfigurationError(PipError):
  186:     """General exception in configuration"""
  187: 
  188: 
  189: class InstallationError(PipError):
  190:     """General exception during installation"""
  191: 
  192: 
  193: class MissingPyProjectBuildRequires(DiagnosticPipError):
  194:     """Raised when pyproject.toml has `build-system`, but no `build-system.requires`."""
  195: 
  196:     reference = "missing-pyproject-build-system-requires"
  197: 
  198:     def __init__(self, *, package: str) -> None:
  199:         super().__init__(
  200:             message=f"Can not process {escape(package)}",
  201:             context=Text(
  202:                 "This package has an invalid pyproject.toml file.\n"
  203:                 "The [build-system] table is missing the mandatory `requires` key."
  204:             ),
  205:             note_stmt="This is an issue with the package mentioned above, not pip.",
  206:             hint_stmt=Text("See PEP 518 for the detailed specification."),
  207:         )
  208: 
  209: 
  210: class InvalidPyProjectBuildRequires(DiagnosticPipError):
  211:     """Raised when pyproject.toml an invalid `build-system.requires`."""
  212: 
  213:     reference = "invalid-pyproject-build-system-requires"
  214: 
  215:     def __init__(self, *, package: str, reason: str) -> None:
  216:         super().__init__(
  217:             message=f"Can not process {escape(package)}",
  218:             context=Text(
  219:                 "This package has an invalid `build-system.requires` key in "
  220:                 f"pyproject.toml.\n{reason}"
  221:             ),
  222:             note_stmt="This is an issue with the package mentioned above, not pip.",
  223:             hint_stmt=Text("See PEP 518 for the detailed specification."),
  224:         )
  225: 
  226: 
  227: class NoneMetadataError(PipError):
  228:     """Raised when accessing a Distribution's "METADATA" or "PKG-INFO".
  229: 
  230:     This signifies an inconsistency, when the Distribution claims to have
  231:     the metadata file (if not, raise ``FileNotFoundError`` instead), but is
  232:     not actually able to produce its content. This may be due to permission
  233:     errors.
  234:     """
  235: 
  236:     def __init__(
  237:         self,
  238:         dist: BaseDistribution,
  239:         metadata_name: str,
  240:     ) -> None:
  241:         """
  242:         :param dist: A Distribution object.
  243:         :param metadata_name: The name of the metadata being accessed
  244:             (can be "METADATA" or "PKG-INFO").
  245:         """
  246:         self.dist = dist
  247:         self.metadata_name = metadata_name
  248: 
  249:     def __str__(self) -> str:
  250:         # Use `dist` in the error message because its stringification
  251:         # includes more information, like the version and location.
  252:         return f"None {self.metadata_name} metadata found for distribution: {self.dist}"
  253: 
  254: 
  255: class UserInstallationInvalid(InstallationError):
  256:     """A --user install is requested on an environment without user site."""
  257: 
  258:     def __str__(self) -> str:
  259:         return "User base directory is not specified"
  260: 
  261: 
  262: class InvalidSchemeCombination(InstallationError):
  263:     def __str__(self) -> str:
  264:         before = ", ".join(str(a) for a in self.args[:-1])
  265:         return f"Cannot set {before} and {self.args[-1]} together"
  266: 
  267: 
  268: class DistributionNotFound(InstallationError):
  269:     """Raised when a distribution cannot be found to satisfy a requirement"""
  270: 
  271: 
  272: class RequirementsFileParseError(InstallationError):
  273:     """Raised when a general error occurs parsing a requirements file line."""
  274: 
  275: 
  276: class BestVersionAlreadyInstalled(PipError):
  277:     """Raised when the most up-to-date version of a package is already
  278:     installed."""
  279: 
  280: 
  281: class BadCommand(PipError):
  282:     """Raised when virtualenv or a command is not found"""
  283: 
  284: 
  285: class CommandError(PipError):
  286:     """Raised when there is an error in command-line arguments"""
  287: 
  288: 
  289: class PreviousBuildDirError(PipError):
  290:     """Raised when there's a previous conflicting build directory"""
  291: 
  292: 
  293: class NetworkConnectionError(PipError):
  294:     """HTTP connection error"""
  295: 
  296:     def __init__(
  297:         self,
  298:         error_msg: str,
  299:         response: Response | None = None,
  300:         request: Request | None = None,
  301:     ) -> None:
  302:         """
  303:         Initialize NetworkConnectionError with  `request` and `response`
  304:         objects.
  305:         """
  306:         self.response = response
  307:         self.request = request
  308:         self.error_msg = error_msg
  309:         if (
  310:             self.response is not None
  311:             and not self.request
  312:             and hasattr(response, "request")
  313:         ):
  314:             self.request = self.response.request
  315:         super().__init__(error_msg, response, request)
  316: 
  317:     def __str__(self) -> str:
  318:         return str(self.error_msg)
  319: 
  320: 
  321: class InvalidWheelFilename(InstallationError):
  322:     """Invalid wheel filename."""
  323: 
  324: 
  325: class UnsupportedWheel(InstallationError):
  326:     """Unsupported wheel."""
  327: 
  328: 
  329: class InvalidWheel(InstallationError):
  330:     """Invalid (e.g. corrupt) wheel."""
  331: 
  332:     def __init__(self, location: str, name: str):
  333:         self.location = location
  334:         self.name = name
  335: 
  336:     def __str__(self) -> str:
  337:         return f"Wheel '{self.name}' located at {self.location} is invalid."
  338: 
  339: 
  340: class MetadataInconsistent(InstallationError):
  341:     """Built metadata contains inconsistent information.
  342: 
  343:     This is raised when the metadata contains values (e.g. name and version)
  344:     that do not match the information previously obtained from sdist filename,
  345:     user-supplied ``#egg=`` value, or an install requirement name.
  346:     """
  347: 
  348:     def __init__(
  349:         self, ireq: InstallRequirement, field: str, f_val: str, m_val: str
  350:     ) -> None:
  351:         self.ireq = ireq
  352:         self.field = field
  353:         self.f_val = f_val
  354:         self.m_val = m_val
  355: 
  356:     def __str__(self) -> str:
  357:         return (
  358:             f"Requested {self.ireq} has inconsistent {self.field}: "
  359:             f"expected {self.f_val!r}, but metadata has {self.m_val!r}"
  360:         )
  361: 
  362: 
  363: class MetadataInvalid(InstallationError):
  364:     """Metadata is invalid."""
  365: 
  366:     def __init__(self, ireq: InstallRequirement, error: str) -> None:
  367:         self.ireq = ireq
  368:         self.error = error
  369: 
  370:     def __str__(self) -> str:
  371:         return f"Requested {self.ireq} has invalid metadata: {self.error}"
  372: 
  373: 
  374: class InstallationSubprocessError(DiagnosticPipError, InstallationError):
  375:     """A subprocess call failed."""
  376: 
  377:     reference = "subprocess-exited-with-error"
  378: 
  379:     def __init__(
  380:         self,
  381:         *,
  382:         command_description: str,
  383:         exit_code: int,
  384:         output_lines: list[str] | None,
  385:     ) -> None:
  386:         if output_lines is None:
  387:             output_prompt = Text("See above for output.")
  388:         else:
  389:             output_prompt = (
  390:                 Text.from_markup(f"[red][{len(output_lines)} lines of output][/]\n")
  391:                 + Text("".join(output_lines))
  392:                 + Text.from_markup(R"[red]\[end of output][/]")
  393:             )
  394: 
  395:         super().__init__(
  396:             message=(
  397:                 f"[green]{escape(command_description)}[/] did not run successfully.\n"
  398:                 f"exit code: {exit_code}"
  399:             ),
  400:             context=output_prompt,
  401:             hint_stmt=None,
  402:             note_stmt=(
  403:                 "This error originates from a subprocess, and is likely not a "
  404:                 "problem with pip."
  405:             ),
  406:         )
  407: 
  408:         self.command_description = command_description
  409:         self.exit_code = exit_code
  410: 
  411:     def __str__(self) -> str:
  412:         return f"{self.command_description} exited with {self.exit_code}"
  413: 
  414: 
  415: class MetadataGenerationFailed(InstallationSubprocessError, InstallationError):
  416:     reference = "metadata-generation-failed"
  417: 
  418:     def __init__(
  419:         self,
  420:         *,
  421:         package_details: str,
  422:     ) -> None:
  423:         super(InstallationSubprocessError, self).__init__(
  424:             message="Encountered error while generating package metadata.",
  425:             context=escape(package_details),
  426:             hint_stmt="See above for details.",
  427:             note_stmt="This is an issue with the package mentioned above, not pip.",
  428:         )
  429: 
  430:     def __str__(self) -> str:
  431:         return "metadata generation failed"
  432: 
  433: 
  434: class HashErrors(InstallationError):
  435:     """Multiple HashError instances rolled into one for reporting"""
  436: 
  437:     def __init__(self) -> None:
  438:         self.errors: list[HashError] = []
  439: 
  440:     def append(self, error: HashError) -> None:
  441:         self.errors.append(error)
  442: 
  443:     def __str__(self) -> str:
  444:         lines = []
  445:         self.errors.sort(key=lambda e: e.order)
  446:         for cls, errors_of_cls in groupby(self.errors, lambda e: e.__class__):
  447:             lines.append(cls.head)
  448:             lines.extend(e.body() for e in errors_of_cls)
  449:         if lines:
  450:             return "\n".join(lines)
  451:         return ""
  452: 
  453:     def __bool__(self) -> bool:
  454:         return bool(self.errors)
  455: 
  456: 
  457: class HashError(InstallationError):
  458:     """
  459:     A failure to verify a package against known-good hashes
  460: 
  461:     :cvar order: An int sorting hash exception classes by difficulty of
  462:         recovery (lower being harder), so the user doesn't bother fretting
  463:         about unpinned packages when he has deeper issues, like VCS
  464:         dependencies, to deal with. Also keeps error reports in a
  465:         deterministic order.
  466:     :cvar head: A section heading for display above potentially many
  467:         exceptions of this kind
  468:     :ivar req: The InstallRequirement that triggered this error. This is
  469:         pasted on after the exception is instantiated, because it's not
  470:         typically available earlier.
  471: 
  472:     """
  473: 
  474:     req: InstallRequirement | None = None
  475:     head = ""
  476:     order: int = -1
  477: 
  478:     def body(self) -> str:
  479:         """Return a summary of me for display under the heading.
  480: 
  481:         This default implementation simply prints a description of the
  482:         triggering requirement.
  483: 
  484:         :param req: The InstallRequirement that provoked this error, with
  485:             its link already populated by the resolver's _populate_link().
  486: 
  487:         """
  488:         return f"    {self._requirement_name()}"
  489: 
  490:     def __str__(self) -> str:
  491:         return f"{self.head}\n{self.body()}"
  492: 
  493:     def _requirement_name(self) -> str:
  494:         """Return a description of the requirement that triggered me.
  495: 
  496:         This default implementation returns long description of the req, with
  497:         line numbers
  498: 
  499:         """
  500:         return str(self.req) if self.req else "unknown package"
  501: 
  502: 
  503: class VcsHashUnsupported(HashError):
  504:     """A hash was provided for a version-control-system-based requirement, but
  505:     we don't have a method for hashing those."""
  506: 
  507:     order = 0
  508:     head = (
  509:         "Can't verify hashes for these requirements because we don't "
  510:         "have a way to hash version control repositories:"
  511:     )
  512: 
  513: 
  514: class DirectoryUrlHashUnsupported(HashError):
  515:     """A hash was provided for a version-control-system-based requirement, but
  516:     we don't have a method for hashing those."""
  517: 
  518:     order = 1
  519:     head = (
  520:         "Can't verify hashes for these file:// requirements because they "
  521:         "point to directories:"
  522:     )
  523: 
  524: 
  525: class HashMissing(HashError):
  526:     """A hash was needed for a requirement but is absent."""
  527: 
  528:     order = 2
  529:     head = (
  530:         "Hashes are required in --require-hashes mode, but they are "
  531:         "missing from some requirements. Here is a list of those "
  532:         "requirements along with the hashes their downloaded archives "
  533:         "actually had. Add lines like these to your requirements files to "
  534:         "prevent tampering. (If you did not enable --require-hashes "
  535:         "manually, note that it turns on automatically when any package "
  536:         "has a hash.)"
  537:     )
  538: 
  539:     def __init__(self, gotten_hash: str) -> None:
  540:         """
  541:         :param gotten_hash: The hash of the (possibly malicious) archive we
  542:             just downloaded
  543:         """
  544:         self.gotten_hash = gotten_hash
  545: 
  546:     def body(self) -> str:
  547:         # Dodge circular import.
  548:         from pip._internal.utils.hashes import FAVORITE_HASH
  549: 
  550:         package = None
  551:         if self.req:
  552:             # In the case of URL-based requirements, display the original URL
  553:             # seen in the requirements file rather than the package name,
  554:             # so the output can be directly copied into the requirements file.
  555:             package = (
  556:                 self.req.original_link
  557:                 if self.req.is_direct
  558:                 # In case someone feeds something downright stupid
  559:                 # to InstallRequirement's constructor.
  560:                 else getattr(self.req, "req", None)
  561:             )
  562:         return "    {} --hash={}:{}".format(
  563:             package or "unknown package", FAVORITE_HASH, self.gotten_hash
  564:         )
  565: 
  566: 
  567: class HashUnpinned(HashError):
  568:     """A requirement had a hash specified but was not pinned to a specific
  569:     version."""
  570: 
  571:     order = 3
  572:     head = (
  573:         "In --require-hashes mode, all requirements must have their "
  574:         "versions pinned with ==. These do not:"
  575:     )
  576: 
  577: 
  578: class HashMismatch(HashError):
  579:     """
  580:     Distribution file hash values don't match.
  581: 
  582:     :ivar package_name: The name of the package that triggered the hash
  583:         mismatch. Feel free to write to this after the exception is raise to
  584:         improve its error message.
  585: 
  586:     """
  587: 
  588:     order = 4
  589:     head = (
  590:         "THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS "
  591:         "FILE. If you have updated the package versions, please update "
  592:         "the hashes. Otherwise, examine the package contents carefully; "
  593:         "someone may have tampered with them."
  594:     )
  595: 
  596:     def __init__(self, allowed: dict[str, list[str]], gots: dict[str, _Hash]) -> None:
  597:         """
  598:         :param allowed: A dict of algorithm names pointing to lists of allowed
  599:             hex digests
  600:         :param gots: A dict of algorithm names pointing to hashes we
  601:             actually got from the files under suspicion
  602:         """
  603:         self.allowed = allowed
  604:         self.gots = gots
  605: 
  606:     def body(self) -> str:
  607:         return f"    {self._requirement_name()}:\n{self._hash_comparison()}"
  608: 
  609:     def _hash_comparison(self) -> str:
  610:         """
  611:         Return a comparison of actual and expected hash values.
  612: 
  613:         Example::
  614: 
  615:                Expected sha256 abcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcde
  616:                             or 123451234512345123451234512345123451234512345
  617:                     Got        bcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdef
  618: 
  619:         """
  620: 
  621:         def hash_then_or(hash_name: str) -> chain[str]:
  622:             # For now, all the decent hashes have 6-char names, so we can get
  623:             # away with hard-coding space literals.
  624:             return chain([hash_name], repeat("    or"))
  625: 
  626:         lines: list[str] = []
  627:         for hash_name, expecteds in self.allowed.items():
  628:             prefix = hash_then_or(hash_name)
  629:             lines.extend((f"        Expected {next(prefix)} {e}") for e in expecteds)
  630:             lines.append(
  631:                 f"             Got        {self.gots[hash_name].hexdigest()}\n"
  632:             )
  633:         return "\n".join(lines)
  634: 
  635: 
  636: class UnsupportedPythonVersion(InstallationError):
  637:     """Unsupported python version according to Requires-Python package
  638:     metadata."""
  639: 
  640: 
  641: class ConfigurationFileCouldNotBeLoaded(ConfigurationError):
  642:     """When there are errors while loading a configuration file"""
  643: 
  644:     def __init__(
  645:         self,
  646:         reason: str = "could not be loaded",
  647:         fname: str | None = None,
  648:         error: configparser.Error | None = None,
  649:     ) -> None:
  650:         super().__init__(error)
  651:         self.reason = reason
  652:         self.fname = fname
  653:         self.error = error
  654: 
  655:     def __str__(self) -> str:
  656:         if self.fname is not None:
  657:             message_part = f" in {self.fname}."
  658:         else:
  659:             assert self.error is not None
  660:             message_part = f".\n{self.error}\n"
  661:         return f"Configuration file {self.reason}{message_part}"
  662: 
  663: 
  664: _DEFAULT_EXTERNALLY_MANAGED_ERROR = f"""\
  665: The Python environment under {sys.prefix} is managed externally, and may not be
  666: manipulated by the user. Please use specific tooling from the distributor of
  667: the Python installation to interact with this environment instead.
  668: """
  669: 
  670: 
  671: class ExternallyManagedEnvironment(DiagnosticPipError):
  672:     """The current environment is externally managed.
  673: 
  674:     This is raised when the current environment is externally managed, as
  675:     defined by `PEP 668`_. The ``EXTERNALLY-MANAGED`` configuration is checked
  676:     and displayed when the error is bubbled up to the user.
  677: 
  678:     :param error: The error message read from ``EXTERNALLY-MANAGED``.
  679:     """
  680: 
  681:     reference = "externally-managed-environment"
  682: 
  683:     def __init__(self, error: str | None) -> None:
  684:         if error is None:
  685:             context = Text(_DEFAULT_EXTERNALLY_MANAGED_ERROR)
  686:         else:
  687:             context = Text(error)
  688:         super().__init__(
  689:             message="This environment is externally managed",
  690:             context=context,
  691:             note_stmt=(
  692:                 "If you believe this is a mistake, please contact your "
  693:                 "Python installation or OS distribution provider. "
  694:                 "You can override this, at the risk of breaking your Python "
  695:                 "installation or OS, by passing --break-system-packages."
  696:             ),
  697:             hint_stmt=Text("See PEP 668 for the detailed specification."),
  698:         )
  699: 
  700:     @staticmethod
  701:     def _iter_externally_managed_error_keys() -> Iterator[str]:
  702:         # LC_MESSAGES is in POSIX, but not the C standard. The most common
  703:         # platform that does not implement this category is Windows, where
  704:         # using other categories for console message localization is equally
  705:         # unreliable, so we fall back to the locale-less vendor message. This
  706:         # can always be re-evaluated when a vendor proposes a new alternative.
  707:         try:
  708:             category = locale.LC_MESSAGES
  709:         except AttributeError:
  710:             lang: str | None = None
  711:         else:
  712:             lang, _ = locale.getlocale(category)
  713:         if lang is not None:
  714:             yield f"Error-{lang}"
  715:             for sep in ("-", "_"):
  716:                 before, found, _ = lang.partition(sep)
  717:                 if not found:
  718:                     continue
  719:                 yield f"Error-{before}"
  720:         yield "Error"
  721: 
  722:     @classmethod
  723:     def from_config(
  724:         cls,
  725:         config: pathlib.Path | str,
  726:     ) -> ExternallyManagedEnvironment:
  727:         parser = configparser.ConfigParser(interpolation=None)
  728:         try:
  729:             parser.read(config, encoding="utf-8")
  730:             section = parser["externally-managed"]
  731:             for key in cls._iter_externally_managed_error_keys():
  732:                 with contextlib.suppress(KeyError):
  733:                     return cls(section[key])
  734:         except KeyError:
  735:             pass
  736:         except (OSError, UnicodeDecodeError, configparser.ParsingError):
  737:             from pip._internal.utils._log import VERBOSE
  738: 
  739:             exc_info = logger.isEnabledFor(VERBOSE)
  740:             logger.warning("Failed to read %s", config, exc_info=exc_info)
  741:         return cls(None)
  742: 
  743: 
  744: class UninstallMissingRecord(DiagnosticPipError):
  745:     reference = "uninstall-no-record-file"
  746: 
  747:     def __init__(self, *, distribution: BaseDistribution) -> None:
  748:         installer = distribution.installer
  749:         if not installer or installer == "pip":
  750:             dep = f"{distribution.raw_name}=={distribution.version}"
  751:             hint = Text.assemble(
  752:                 "You might be able to recover from this via: ",
  753:                 (f"pip install --force-reinstall --no-deps {dep}", "green"),
  754:             )
  755:         else:
  756:             hint = Text(
  757:                 f"The package was installed by {installer}. "
  758:                 "You should check if it can uninstall the package."
  759:             )
  760: 
  761:         super().__init__(
  762:             message=Text(f"Cannot uninstall {distribution}"),
  763:             context=(
  764:                 "The package's contents are unknown: "
  765:                 f"no RECORD file was found for {distribution.raw_name}."
  766:             ),
  767:             hint_stmt=hint,
  768:         )
  769: 
  770: 
  771: class LegacyDistutilsInstall(DiagnosticPipError):
  772:     reference = "uninstall-distutils-installed-package"
  773: 
  774:     def __init__(self, *, distribution: BaseDistribution) -> None:
  775:         super().__init__(
  776:             message=Text(f"Cannot uninstall {distribution}"),
  777:             context=(
  778:                 "It is a distutils installed project and thus we cannot accurately "
  779:                 "determine which files belong to it which would lead to only a partial "
  780:                 "uninstall."
  781:             ),
  782:             hint_stmt=None,
  783:         )
  784: 
  785: 
  786: class InvalidInstalledPackage(DiagnosticPipError):
  787:     reference = "invalid-installed-package"
  788: 
  789:     def __init__(
  790:         self,
  791:         *,
  792:         dist: BaseDistribution,
  793:         invalid_exc: InvalidRequirement | InvalidVersion,
  794:     ) -> None:
  795:         installed_location = dist.installed_location
  796: 
  797:         if isinstance(invalid_exc, InvalidRequirement):
  798:             invalid_type = "requirement"
  799:         else:
  800:             invalid_type = "version"
  801: 
  802:         super().__init__(
  803:             message=Text(
  804:                 f"Cannot process installed package {dist} "
  805:                 + (f"in {installed_location!r} " if installed_location else "")
  806:                 + f"because it has an invalid {invalid_type}:\n{invalid_exc.args[0]}"
  807:             ),
  808:             context=(
  809:                 "Starting with pip 24.1, packages with invalid "
  810:                 f"{invalid_type}s can not be processed."
  811:             ),
  812:             hint_stmt="To proceed this package must be uninstalled.",
  813:         )
  814: 
  815: 
  816: class IncompleteDownloadError(DiagnosticPipError):
  817:     """Raised when the downloader receives fewer bytes than advertised
  818:     in the Content-Length header."""
  819: 
  820:     reference = "incomplete-download"
  821: 
  822:     def __init__(self, download: _FileDownload) -> None:
  823:         # Dodge circular import.
  824:         from pip._internal.utils.misc import format_size
  825: 
  826:         assert download.size is not None
  827:         download_status = (
  828:             f"{format_size(download.bytes_received)}/{format_size(download.size)}"
  829:         )
  830:         if download.reattempts:
  831:             retry_status = f"after {download.reattempts + 1} attempts "
  832:             hint = "Use --resume-retries to configure resume attempt limit."
  833:         else:
  834:             # Download retrying is not enabled.
  835:             retry_status = ""
  836:             hint = "Consider using --resume-retries to enable download resumption."
  837:         message = Text(
  838:             f"Download failed {retry_status}because not enough bytes "
  839:             f"were received ({download_status})"
  840:         )
  841: 
  842:         super().__init__(
  843:             message=message,
  844:             context=f"URL: {download.link.redacted_url}",
  845:             hint_stmt=hint,
  846:             note_stmt="This is an issue with network connectivity, not pip.",
  847:         )
  848: 
  849: 
  850: class ResolutionTooDeepError(DiagnosticPipError):
  851:     """Raised when the dependency resolver exceeds the maximum recursion depth."""
  852: 
  853:     reference = "resolution-too-deep"
  854: 
  855:     def __init__(self) -> None:
  856:         super().__init__(
  857:             message="Dependency resolution exceeded maximum depth",
  858:             context=(
  859:                 "Pip cannot resolve the current dependencies as the dependency graph "
  860:                 "is too complex for pip to solve efficiently."
  861:             ),
  862:             hint_stmt=(
  863:                 "Try adding lower bounds to constrain your dependencies, "
  864:                 "for example: 'package>=2.0.0' instead of just 'package'. "
  865:             ),
  866:             link="https://pip.pypa.io/en/stable/topics/dependency-resolution/#handling-resolution-too-deep-errors",
  867:         )
  868: 
  869: 
  870: class InstallWheelBuildError(DiagnosticPipError):
  871:     reference = "failed-wheel-build-for-install"
  872: 
  873:     def __init__(self, failed: list[InstallRequirement]) -> None:
  874:         super().__init__(
  875:             message=(
  876:                 "Failed to build installable wheels for some "
  877:                 "pyproject.toml based projects"
  878:             ),
  879:             context=", ".join(r.name for r in failed),  # type: ignore
  880:             hint_stmt=None,
  881:         )
