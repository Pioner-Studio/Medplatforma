    1: from __future__ import annotations
    2: 
    3: import datetime
    4: import functools
    5: import hashlib
    6: import json
    7: import logging
    8: import optparse
    9: import os.path
   10: import sys
   11: from dataclasses import dataclass
   12: from typing import Any, Callable
   13: 
   14: from pip._vendor.packaging.version import Version
   15: from pip._vendor.packaging.version import parse as parse_version
   16: from pip._vendor.rich.console import Group
   17: from pip._vendor.rich.markup import escape
   18: from pip._vendor.rich.text import Text
   19: 
   20: from pip._internal.index.collector import LinkCollector
   21: from pip._internal.index.package_finder import PackageFinder
   22: from pip._internal.metadata import get_default_environment
   23: from pip._internal.models.selection_prefs import SelectionPreferences
   24: from pip._internal.network.session import PipSession
   25: from pip._internal.utils.compat import WINDOWS
   26: from pip._internal.utils.entrypoints import (
   27:     get_best_invocation_for_this_pip,
   28:     get_best_invocation_for_this_python,
   29: )
   30: from pip._internal.utils.filesystem import adjacent_tmp_file, check_path_owner, replace
   31: from pip._internal.utils.misc import (
   32:     ExternallyManagedEnvironment,
   33:     check_externally_managed,
   34:     ensure_dir,
   35: )
   36: 
   37: _WEEK = datetime.timedelta(days=7)
   38: 
   39: logger = logging.getLogger(__name__)
   40: 
   41: 
   42: def _get_statefile_name(key: str) -> str:
   43:     key_bytes = key.encode()
   44:     name = hashlib.sha224(key_bytes).hexdigest()
   45:     return name
   46: 
   47: 
   48: def _convert_date(isodate: str) -> datetime.datetime:
   49:     """Convert an ISO format string to a date.
   50: 
   51:     Handles the format 2020-01-22T14:24:01Z (trailing Z)
   52:     which is not supported by older versions of fromisoformat.
   53:     """
   54:     return datetime.datetime.fromisoformat(isodate.replace("Z", "+00:00"))
   55: 
   56: 
   57: class SelfCheckState:
   58:     def __init__(self, cache_dir: str) -> None:
   59:         self._state: dict[str, Any] = {}
   60:         self._statefile_path = None
   61: 
   62:         # Try to load the existing state
   63:         if cache_dir:
   64:             self._statefile_path = os.path.join(
   65:                 cache_dir, "selfcheck", _get_statefile_name(self.key)
   66:             )
   67:             try:
   68:                 with open(self._statefile_path, encoding="utf-8") as statefile:
   69:                     self._state = json.load(statefile)
   70:             except (OSError, ValueError, KeyError):
   71:                 # Explicitly suppressing exceptions, since we don't want to
   72:                 # error out if the cache file is invalid.
   73:                 pass
   74: 
   75:     @property
   76:     def key(self) -> str:
   77:         return sys.prefix
   78: 
   79:     def get(self, current_time: datetime.datetime) -> str | None:
   80:         """Check if we have a not-outdated version loaded already."""
   81:         if not self._state:
   82:             return None
   83: 
   84:         if "last_check" not in self._state:
   85:             return None
   86: 
   87:         if "pypi_version" not in self._state:
   88:             return None
   89: 
   90:         # Determine if we need to refresh the state
   91:         last_check = _convert_date(self._state["last_check"])
   92:         time_since_last_check = current_time - last_check
   93:         if time_since_last_check > _WEEK:
   94:             return None
   95: 
   96:         return self._state["pypi_version"]
   97: 
   98:     def set(self, pypi_version: str, current_time: datetime.datetime) -> None:
   99:         # If we do not have a path to cache in, don't bother saving.
  100:         if not self._statefile_path:
  101:             return
  102: 
  103:         # Check to make sure that we own the directory
  104:         if not check_path_owner(os.path.dirname(self._statefile_path)):
  105:             return
  106: 
  107:         # Now that we've ensured the directory is owned by this user, we'll go
  108:         # ahead and make sure that all our directories are created.
  109:         ensure_dir(os.path.dirname(self._statefile_path))
  110: 
  111:         state = {
  112:             # Include the key so it's easy to tell which pip wrote the
  113:             # file.
  114:             "key": self.key,
  115:             "last_check": current_time.isoformat(),
  116:             "pypi_version": pypi_version,
  117:         }
  118: 
  119:         text = json.dumps(state, sort_keys=True, separators=(",", ":"))
  120: 
  121:         with adjacent_tmp_file(self._statefile_path) as f:
  122:             f.write(text.encode())
  123: 
  124:         try:
  125:             # Since we have a prefix-specific state file, we can just
  126:             # overwrite whatever is there, no need to check.
  127:             replace(f.name, self._statefile_path)
  128:         except OSError:
  129:             # Best effort.
  130:             pass
  131: 
  132: 
  133: @dataclass
  134: class UpgradePrompt:
  135:     old: str
  136:     new: str
  137: 
  138:     def __rich__(self) -> Group:
  139:         if WINDOWS:
  140:             pip_cmd = f"{get_best_invocation_for_this_python()} -m pip"
  141:         else:
  142:             pip_cmd = get_best_invocation_for_this_pip()
  143: 
  144:         notice = "[bold][[reset][blue]notice[reset][bold]][reset]"
  145:         return Group(
  146:             Text(),
  147:             Text.from_markup(
  148:                 f"{notice} A new release of pip is available: "
  149:                 f"[red]{self.old}[reset] -> [green]{self.new}[reset]"
  150:             ),
  151:             Text.from_markup(
  152:                 f"{notice} To update, run: "
  153:                 f"[green]{escape(pip_cmd)} install --upgrade pip"
  154:             ),
  155:         )
  156: 
  157: 
  158: def was_installed_by_pip(pkg: str) -> bool:
  159:     """Checks whether pkg was installed by pip
  160: 
  161:     This is used not to display the upgrade message when pip is in fact
  162:     installed by system package manager, such as dnf on Fedora.
  163:     """
  164:     dist = get_default_environment().get_distribution(pkg)
  165:     return dist is not None and "pip" == dist.installer
  166: 
  167: 
  168: def _get_current_remote_pip_version(
  169:     session: PipSession, options: optparse.Values
  170: ) -> str | None:
  171:     # Lets use PackageFinder to see what the latest pip version is
  172:     link_collector = LinkCollector.create(
  173:         session,
  174:         options=options,
  175:         suppress_no_index=True,
  176:     )
  177: 
  178:     # Pass allow_yanked=False so we don't suggest upgrading to a
  179:     # yanked version.
  180:     selection_prefs = SelectionPreferences(
  181:         allow_yanked=False,
  182:         allow_all_prereleases=False,  # Explicitly set to False
  183:     )
  184: 
  185:     finder = PackageFinder.create(
  186:         link_collector=link_collector,
  187:         selection_prefs=selection_prefs,
  188:     )
  189:     best_candidate = finder.find_best_candidate("pip").best_candidate
  190:     if best_candidate is None:
  191:         return None
  192: 
  193:     return str(best_candidate.version)
  194: 
  195: 
  196: def _self_version_check_logic(
  197:     *,
  198:     state: SelfCheckState,
  199:     current_time: datetime.datetime,
  200:     local_version: Version,
  201:     get_remote_version: Callable[[], str | None],
  202: ) -> UpgradePrompt | None:
  203:     remote_version_str = state.get(current_time)
  204:     if remote_version_str is None:
  205:         remote_version_str = get_remote_version()
  206:         if remote_version_str is None:
  207:             logger.debug("No remote pip version found")
  208:             return None
  209:         state.set(remote_version_str, current_time)
  210: 
  211:     remote_version = parse_version(remote_version_str)
  212:     logger.debug("Remote version of pip: %s", remote_version)
  213:     logger.debug("Local version of pip:  %s", local_version)
  214: 
  215:     pip_installed_by_pip = was_installed_by_pip("pip")
  216:     logger.debug("Was pip installed by pip? %s", pip_installed_by_pip)
  217:     if not pip_installed_by_pip:
  218:         return None  # Only suggest upgrade if pip is installed by pip.
  219: 
  220:     local_version_is_older = (
  221:         local_version < remote_version
  222:         and local_version.base_version != remote_version.base_version
  223:     )
  224:     if local_version_is_older:
  225:         return UpgradePrompt(old=str(local_version), new=remote_version_str)
  226: 
  227:     return None
  228: 
  229: 
  230: def pip_self_version_check(session: PipSession, options: optparse.Values) -> None:
  231:     """Check for an update for pip.
  232: 
  233:     Limit the frequency of checks to once per week. State is stored either in
  234:     the active virtualenv or in the user's USER_CACHE_DIR keyed off the prefix
  235:     of the pip script path.
  236:     """
  237:     installed_dist = get_default_environment().get_distribution("pip")
  238:     if not installed_dist:
  239:         return
  240:     try:
  241:         check_externally_managed()
  242:     except ExternallyManagedEnvironment:
  243:         return
  244: 
  245:     upgrade_prompt = _self_version_check_logic(
  246:         state=SelfCheckState(cache_dir=options.cache_dir),
  247:         current_time=datetime.datetime.now(datetime.timezone.utc),
  248:         local_version=installed_dist.version,
  249:         get_remote_version=functools.partial(
  250:             _get_current_remote_pip_version, session, options
  251:         ),
  252:     )
  253:     if upgrade_prompt is not None:
  254:         logger.warning("%s", upgrade_prompt, extra={"rich": True})
