    1: from __future__ import annotations
    2: 
    3: import functools
    4: import logging
    5: import os
    6: import pathlib
    7: import sys
    8: import sysconfig
    9: from typing import Any
   10: 
   11: from pip._internal.models.scheme import SCHEME_KEYS, Scheme
   12: from pip._internal.utils.compat import WINDOWS
   13: from pip._internal.utils.deprecation import deprecated
   14: from pip._internal.utils.virtualenv import running_under_virtualenv
   15: 
   16: from . import _sysconfig
   17: from .base import (
   18:     USER_CACHE_DIR,
   19:     get_major_minor_version,
   20:     get_src_prefix,
   21:     is_osx_framework,
   22:     site_packages,
   23:     user_site,
   24: )
   25: 
   26: __all__ = [
   27:     "USER_CACHE_DIR",
   28:     "get_bin_prefix",
   29:     "get_bin_user",
   30:     "get_major_minor_version",
   31:     "get_platlib",
   32:     "get_purelib",
   33:     "get_scheme",
   34:     "get_src_prefix",
   35:     "site_packages",
   36:     "user_site",
   37: ]
   38: 
   39: 
   40: logger = logging.getLogger(__name__)
   41: 
   42: 
   43: _PLATLIBDIR: str = getattr(sys, "platlibdir", "lib")
   44: 
   45: _USE_SYSCONFIG_DEFAULT = sys.version_info >= (3, 10)
   46: 
   47: 
   48: def _should_use_sysconfig() -> bool:
   49:     """This function determines the value of _USE_SYSCONFIG.
   50: 
   51:     By default, pip uses sysconfig on Python 3.10+.
   52:     But Python distributors can override this decision by setting:
   53:         sysconfig._PIP_USE_SYSCONFIG = True / False
   54:     Rationale in https://github.com/pypa/pip/issues/10647
   55: 
   56:     This is a function for testability, but should be constant during any one
   57:     run.
   58:     """
   59:     return bool(getattr(sysconfig, "_PIP_USE_SYSCONFIG", _USE_SYSCONFIG_DEFAULT))
   60: 
   61: 
   62: _USE_SYSCONFIG = _should_use_sysconfig()
   63: 
   64: if not _USE_SYSCONFIG:
   65:     # Import distutils lazily to avoid deprecation warnings,
   66:     # but import it soon enough that it is in memory and available during
   67:     # a pip reinstall.
   68:     from . import _distutils
   69: 
   70: # Be noisy about incompatibilities if this platforms "should" be using
   71: # sysconfig, but is explicitly opting out and using distutils instead.
   72: if _USE_SYSCONFIG_DEFAULT and not _USE_SYSCONFIG:
   73:     _MISMATCH_LEVEL = logging.WARNING
   74: else:
   75:     _MISMATCH_LEVEL = logging.DEBUG
   76: 
   77: 
   78: def _looks_like_bpo_44860() -> bool:
   79:     """The resolution to bpo-44860 will change this incorrect platlib.
   80: 
   81:     See <https://bugs.python.org/issue44860>.
   82:     """
   83:     from distutils.command.install import INSTALL_SCHEMES
   84: 
   85:     try:
   86:         unix_user_platlib = INSTALL_SCHEMES["unix_user"]["platlib"]
   87:     except KeyError:
   88:         return False
   89:     return unix_user_platlib == "$usersite"
   90: 
   91: 
   92: def _looks_like_red_hat_patched_platlib_purelib(scheme: dict[str, str]) -> bool:
   93:     platlib = scheme["platlib"]
   94:     if "/$platlibdir/" in platlib:
   95:         platlib = platlib.replace("/$platlibdir/", f"/{_PLATLIBDIR}/")
   96:     if "/lib64/" not in platlib:
   97:         return False
   98:     unpatched = platlib.replace("/lib64/", "/lib/")
   99:     return unpatched.replace("$platbase/", "$base/") == scheme["purelib"]
  100: 
  101: 
  102: @functools.cache
  103: def _looks_like_red_hat_lib() -> bool:
  104:     """Red Hat patches platlib in unix_prefix and unix_home, but not purelib.
  105: 
  106:     This is the only way I can see to tell a Red Hat-patched Python.
  107:     """
  108:     from distutils.command.install import INSTALL_SCHEMES
  109: 
  110:     return all(
  111:         k in INSTALL_SCHEMES
  112:         and _looks_like_red_hat_patched_platlib_purelib(INSTALL_SCHEMES[k])
  113:         for k in ("unix_prefix", "unix_home")
  114:     )
  115: 
  116: 
  117: @functools.cache
  118: def _looks_like_debian_scheme() -> bool:
  119:     """Debian adds two additional schemes."""
  120:     from distutils.command.install import INSTALL_SCHEMES
  121: 
  122:     return "deb_system" in INSTALL_SCHEMES and "unix_local" in INSTALL_SCHEMES
  123: 
  124: 
  125: @functools.cache
  126: def _looks_like_red_hat_scheme() -> bool:
  127:     """Red Hat patches ``sys.prefix`` and ``sys.exec_prefix``.
  128: 
  129:     Red Hat's ``00251-change-user-install-location.patch`` changes the install
  130:     command's ``prefix`` and ``exec_prefix`` to append ``"/local"``. This is
  131:     (fortunately?) done quite unconditionally, so we create a default command
  132:     object without any configuration to detect this.
  133:     """
  134:     from distutils.command.install import install
  135:     from distutils.dist import Distribution
  136: 
  137:     cmd: Any = install(Distribution())
  138:     cmd.finalize_options()
  139:     return (
  140:         cmd.exec_prefix == f"{os.path.normpath(sys.exec_prefix)}/local"
  141:         and cmd.prefix == f"{os.path.normpath(sys.prefix)}/local"
  142:     )
  143: 
  144: 
  145: @functools.cache
  146: def _looks_like_slackware_scheme() -> bool:
  147:     """Slackware patches sysconfig but fails to patch distutils and site.
  148: 
  149:     Slackware changes sysconfig's user scheme to use ``"lib64"`` for the lib
  150:     path, but does not do the same to the site module.
  151:     """
  152:     if user_site is None:  # User-site not available.
  153:         return False
  154:     try:
  155:         paths = sysconfig.get_paths(scheme="posix_user", expand=False)
  156:     except KeyError:  # User-site not available.
  157:         return False
  158:     return "/lib64/" in paths["purelib"] and "/lib64/" not in user_site
  159: 
  160: 
  161: @functools.cache
  162: def _looks_like_msys2_mingw_scheme() -> bool:
  163:     """MSYS2 patches distutils and sysconfig to use a UNIX-like scheme.
  164: 
  165:     However, MSYS2 incorrectly patches sysconfig ``nt`` scheme. The fix is
  166:     likely going to be included in their 3.10 release, so we ignore the warning.
  167:     See msys2/MINGW-packages#9319.
  168: 
  169:     MSYS2 MINGW's patch uses lowercase ``"lib"`` instead of the usual uppercase,
  170:     and is missing the final ``"site-packages"``.
  171:     """
  172:     paths = sysconfig.get_paths("nt", expand=False)
  173:     return all(
  174:         "Lib" not in p and "lib" in p and not p.endswith("site-packages")
  175:         for p in (paths[key] for key in ("platlib", "purelib"))
  176:     )
  177: 
  178: 
  179: @functools.cache
  180: def _warn_mismatched(old: pathlib.Path, new: pathlib.Path, *, key: str) -> None:
  181:     issue_url = "https://github.com/pypa/pip/issues/10151"
  182:     message = (
  183:         "Value for %s does not match. Please report this to <%s>"
  184:         "\ndistutils: %s"
  185:         "\nsysconfig: %s"
  186:     )
  187:     logger.log(_MISMATCH_LEVEL, message, key, issue_url, old, new)
  188: 
  189: 
  190: def _warn_if_mismatch(old: pathlib.Path, new: pathlib.Path, *, key: str) -> bool:
  191:     if old == new:
  192:         return False
  193:     _warn_mismatched(old, new, key=key)
  194:     return True
  195: 
  196: 
  197: @functools.cache
  198: def _log_context(
  199:     *,
  200:     user: bool = False,
  201:     home: str | None = None,
  202:     root: str | None = None,
  203:     prefix: str | None = None,
  204: ) -> None:
  205:     parts = [
  206:         "Additional context:",
  207:         "user = %r",
  208:         "home = %r",
  209:         "root = %r",
  210:         "prefix = %r",
  211:     ]
  212: 
  213:     logger.log(_MISMATCH_LEVEL, "\n".join(parts), user, home, root, prefix)
  214: 
  215: 
  216: def get_scheme(
  217:     dist_name: str,
  218:     user: bool = False,
  219:     home: str | None = None,
  220:     root: str | None = None,
  221:     isolated: bool = False,
  222:     prefix: str | None = None,
  223: ) -> Scheme:
  224:     new = _sysconfig.get_scheme(
  225:         dist_name,
  226:         user=user,
  227:         home=home,
  228:         root=root,
  229:         isolated=isolated,
  230:         prefix=prefix,
  231:     )
  232:     if _USE_SYSCONFIG:
  233:         return new
  234: 
  235:     old = _distutils.get_scheme(
  236:         dist_name,
  237:         user=user,
  238:         home=home,
  239:         root=root,
  240:         isolated=isolated,
  241:         prefix=prefix,
  242:     )
  243: 
  244:     warning_contexts = []
  245:     for k in SCHEME_KEYS:
  246:         old_v = pathlib.Path(getattr(old, k))
  247:         new_v = pathlib.Path(getattr(new, k))
  248: 
  249:         if old_v == new_v:
  250:             continue
  251: 
  252:         # distutils incorrectly put PyPy packages under ``site-packages/python``
  253:         # in the ``posix_home`` scheme, but PyPy devs said they expect the
  254:         # directory name to be ``pypy`` instead. So we treat this as a bug fix
  255:         # and not warn about it. See bpo-43307 and python/cpython#24628.
  256:         skip_pypy_special_case = (
  257:             sys.implementation.name == "pypy"
  258:             and home is not None
  259:             and k in ("platlib", "purelib")
  260:             and old_v.parent == new_v.parent
  261:             and old_v.name.startswith("python")
  262:             and new_v.name.startswith("pypy")
  263:         )
  264:         if skip_pypy_special_case:
  265:             continue
  266: 
  267:         # sysconfig's ``osx_framework_user`` does not include ``pythonX.Y`` in
  268:         # the ``include`` value, but distutils's ``headers`` does. We'll let
  269:         # CPython decide whether this is a bug or feature. See bpo-43948.
  270:         skip_osx_framework_user_special_case = (
  271:             user
  272:             and is_osx_framework()
  273:             and k == "headers"
  274:             and old_v.parent.parent == new_v.parent
  275:             and old_v.parent.name.startswith("python")
  276:         )
  277:         if skip_osx_framework_user_special_case:
  278:             continue
  279: 
  280:         # On Red Hat and derived Linux distributions, distutils is patched to
  281:         # use "lib64" instead of "lib" for platlib.
  282:         if k == "platlib" and _looks_like_red_hat_lib():
  283:             continue
  284: 
  285:         # On Python 3.9+, sysconfig's posix_user scheme sets platlib against
  286:         # sys.platlibdir, but distutils's unix_user incorrectly continues
  287:         # using the same $usersite for both platlib and purelib. This creates a
  288:         # mismatch when sys.platlibdir is not "lib".
  289:         skip_bpo_44860 = (
  290:             user
  291:             and k == "platlib"
  292:             and not WINDOWS
  293:             and _PLATLIBDIR != "lib"
  294:             and _looks_like_bpo_44860()
  295:         )
  296:         if skip_bpo_44860:
  297:             continue
  298: 
  299:         # Slackware incorrectly patches posix_user to use lib64 instead of lib,
  300:         # but not usersite to match the location.
  301:         skip_slackware_user_scheme = (
  302:             user
  303:             and k in ("platlib", "purelib")
  304:             and not WINDOWS
  305:             and _looks_like_slackware_scheme()
  306:         )
  307:         if skip_slackware_user_scheme:
  308:             continue
  309: 
  310:         # Both Debian and Red Hat patch Python to place the system site under
  311:         # /usr/local instead of /usr. Debian also places lib in dist-packages
  312:         # instead of site-packages, but the /usr/local check should cover it.
  313:         skip_linux_system_special_case = (
  314:             not (user or home or prefix or running_under_virtualenv())
  315:             and old_v.parts[1:3] == ("usr", "local")
  316:             and len(new_v.parts) > 1
  317:             and new_v.parts[1] == "usr"
  318:             and (len(new_v.parts) < 3 or new_v.parts[2] != "local")
  319:             and (_looks_like_red_hat_scheme() or _looks_like_debian_scheme())
  320:         )
  321:         if skip_linux_system_special_case:
  322:             continue
  323: 
  324:         # MSYS2 MINGW's sysconfig patch does not include the "site-packages"
  325:         # part of the path. This is incorrect and will be fixed in MSYS.
  326:         skip_msys2_mingw_bug = (
  327:             WINDOWS and k in ("platlib", "purelib") and _looks_like_msys2_mingw_scheme()
  328:         )
  329:         if skip_msys2_mingw_bug:
  330:             continue
  331: 
  332:         # CPython's POSIX install script invokes pip (via ensurepip) against the
  333:         # interpreter located in the source tree, not the install site. This
  334:         # triggers special logic in sysconfig that's not present in distutils.
  335:         # https://github.com/python/cpython/blob/8c21941ddaf/Lib/sysconfig.py#L178-L194
  336:         skip_cpython_build = (
  337:             sysconfig.is_python_build(check_home=True)
  338:             and not WINDOWS
  339:             and k in ("headers", "include", "platinclude")
  340:         )
  341:         if skip_cpython_build:
  342:             continue
  343: 
  344:         warning_contexts.append((old_v, new_v, f"scheme.{k}"))
  345: 
  346:     if not warning_contexts:
  347:         return old
  348: 
  349:     # Check if this path mismatch is caused by distutils config files. Those
  350:     # files will no longer work once we switch to sysconfig, so this raises a
  351:     # deprecation message for them.
  352:     default_old = _distutils.distutils_scheme(
  353:         dist_name,
  354:         user,
  355:         home,
  356:         root,
  357:         isolated,
  358:         prefix,
  359:         ignore_config_files=True,
  360:     )
  361:     if any(default_old[k] != getattr(old, k) for k in SCHEME_KEYS):
  362:         deprecated(
  363:             reason=(
  364:                 "Configuring installation scheme with distutils config files "
  365:                 "is deprecated and will no longer work in the near future. If you "
  366:                 "are using a Homebrew or Linuxbrew Python, please see discussion "
  367:                 "at https://github.com/Homebrew/homebrew-core/issues/76621"
  368:             ),
  369:             replacement=None,
  370:             gone_in=None,
  371:         )
  372:         return old
  373: 
  374:     # Post warnings about this mismatch so user can report them back.
  375:     for old_v, new_v, key in warning_contexts:
  376:         _warn_mismatched(old_v, new_v, key=key)
  377:     _log_context(user=user, home=home, root=root, prefix=prefix)
  378: 
  379:     return old
  380: 
  381: 
  382: def get_bin_prefix() -> str:
  383:     new = _sysconfig.get_bin_prefix()
  384:     if _USE_SYSCONFIG:
  385:         return new
  386: 
  387:     old = _distutils.get_bin_prefix()
  388:     if _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key="bin_prefix"):
  389:         _log_context()
  390:     return old
  391: 
  392: 
  393: def get_bin_user() -> str:
  394:     return _sysconfig.get_scheme("", user=True).scripts
  395: 
  396: 
  397: def _looks_like_deb_system_dist_packages(value: str) -> bool:
  398:     """Check if the value is Debian's APT-controlled dist-packages.
  399: 
  400:     Debian's ``distutils.sysconfig.get_python_lib()`` implementation returns the
  401:     default package path controlled by APT, but does not patch ``sysconfig`` to
  402:     do the same. This is similar to the bug worked around in ``get_scheme()``,
  403:     but here the default is ``deb_system`` instead of ``unix_local``. Ultimately
  404:     we can't do anything about this Debian bug, and this detection allows us to
  405:     skip the warning when needed.
  406:     """
  407:     if not _looks_like_debian_scheme():
  408:         return False
  409:     if value == "/usr/lib/python3/dist-packages":
  410:         return True
  411:     return False
  412: 
  413: 
  414: def get_purelib() -> str:
  415:     """Return the default pure-Python lib location."""
  416:     new = _sysconfig.get_purelib()
  417:     if _USE_SYSCONFIG:
  418:         return new
  419: 
  420:     old = _distutils.get_purelib()
  421:     if _looks_like_deb_system_dist_packages(old):
  422:         return old
  423:     if _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key="purelib"):
  424:         _log_context()
  425:     return old
  426: 
  427: 
  428: def get_platlib() -> str:
  429:     """Return the default platform-shared lib location."""
  430:     new = _sysconfig.get_platlib()
  431:     if _USE_SYSCONFIG:
  432:         return new
  433: 
  434:     from . import _distutils
  435: 
  436:     old = _distutils.get_platlib()
  437:     if _looks_like_deb_system_dist_packages(old):
  438:         return old
  439:     if _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key="platlib"):
  440:         _log_context()
  441:     return old
