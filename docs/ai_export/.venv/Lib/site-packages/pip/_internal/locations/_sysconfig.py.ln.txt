    1: from __future__ import annotations
    2: 
    3: import logging
    4: import os
    5: import sys
    6: import sysconfig
    7: 
    8: from pip._internal.exceptions import InvalidSchemeCombination, UserInstallationInvalid
    9: from pip._internal.models.scheme import SCHEME_KEYS, Scheme
   10: from pip._internal.utils.virtualenv import running_under_virtualenv
   11: 
   12: from .base import change_root, get_major_minor_version, is_osx_framework
   13: 
   14: logger = logging.getLogger(__name__)
   15: 
   16: 
   17: # Notes on _infer_* functions.
   18: # Unfortunately ``get_default_scheme()`` didn't exist before 3.10, so there's no
   19: # way to ask things like "what is the '_prefix' scheme on this platform". These
   20: # functions try to answer that with some heuristics while accounting for ad-hoc
   21: # platforms not covered by CPython's default sysconfig implementation. If the
   22: # ad-hoc implementation does not fully implement sysconfig, we'll fall back to
   23: # a POSIX scheme.
   24: 
   25: _AVAILABLE_SCHEMES = set(sysconfig.get_scheme_names())
   26: 
   27: _PREFERRED_SCHEME_API = getattr(sysconfig, "get_preferred_scheme", None)
   28: 
   29: 
   30: def _should_use_osx_framework_prefix() -> bool:
   31:     """Check for Apple's ``osx_framework_library`` scheme.
   32: 
   33:     Python distributed by Apple's Command Line Tools has this special scheme
   34:     that's used when:
   35: 
   36:     * This is a framework build.
   37:     * We are installing into the system prefix.
   38: 
   39:     This does not account for ``pip install --prefix`` (also means we're not
   40:     installing to the system prefix), which should use ``posix_prefix``, but
   41:     logic here means ``_infer_prefix()`` outputs ``osx_framework_library``. But
   42:     since ``prefix`` is not available for ``sysconfig.get_default_scheme()``,
   43:     which is the stdlib replacement for ``_infer_prefix()``, presumably Apple
   44:     wouldn't be able to magically switch between ``osx_framework_library`` and
   45:     ``posix_prefix``. ``_infer_prefix()`` returning ``osx_framework_library``
   46:     means its behavior is consistent whether we use the stdlib implementation
   47:     or our own, and we deal with this special case in ``get_scheme()`` instead.
   48:     """
   49:     return (
   50:         "osx_framework_library" in _AVAILABLE_SCHEMES
   51:         and not running_under_virtualenv()
   52:         and is_osx_framework()
   53:     )
   54: 
   55: 
   56: def _infer_prefix() -> str:
   57:     """Try to find a prefix scheme for the current platform.
   58: 
   59:     This tries:
   60: 
   61:     * A special ``osx_framework_library`` for Python distributed by Apple's
   62:       Command Line Tools, when not running in a virtual environment.
   63:     * Implementation + OS, used by PyPy on Windows (``pypy_nt``).
   64:     * Implementation without OS, used by PyPy on POSIX (``pypy``).
   65:     * OS + "prefix", used by CPython on POSIX (``posix_prefix``).
   66:     * Just the OS name, used by CPython on Windows (``nt``).
   67: 
   68:     If none of the above works, fall back to ``posix_prefix``.
   69:     """
   70:     if _PREFERRED_SCHEME_API:
   71:         return _PREFERRED_SCHEME_API("prefix")
   72:     if _should_use_osx_framework_prefix():
   73:         return "osx_framework_library"
   74:     implementation_suffixed = f"{sys.implementation.name}_{os.name}"
   75:     if implementation_suffixed in _AVAILABLE_SCHEMES:
   76:         return implementation_suffixed
   77:     if sys.implementation.name in _AVAILABLE_SCHEMES:
   78:         return sys.implementation.name
   79:     suffixed = f"{os.name}_prefix"
   80:     if suffixed in _AVAILABLE_SCHEMES:
   81:         return suffixed
   82:     if os.name in _AVAILABLE_SCHEMES:  # On Windows, prefx is just called "nt".
   83:         return os.name
   84:     return "posix_prefix"
   85: 
   86: 
   87: def _infer_user() -> str:
   88:     """Try to find a user scheme for the current platform."""
   89:     if _PREFERRED_SCHEME_API:
   90:         return _PREFERRED_SCHEME_API("user")
   91:     if is_osx_framework() and not running_under_virtualenv():
   92:         suffixed = "osx_framework_user"
   93:     else:
   94:         suffixed = f"{os.name}_user"
   95:     if suffixed in _AVAILABLE_SCHEMES:
   96:         return suffixed
   97:     if "posix_user" not in _AVAILABLE_SCHEMES:  # User scheme unavailable.
   98:         raise UserInstallationInvalid()
   99:     return "posix_user"
  100: 
  101: 
  102: def _infer_home() -> str:
  103:     """Try to find a home for the current platform."""
  104:     if _PREFERRED_SCHEME_API:
  105:         return _PREFERRED_SCHEME_API("home")
  106:     suffixed = f"{os.name}_home"
  107:     if suffixed in _AVAILABLE_SCHEMES:
  108:         return suffixed
  109:     return "posix_home"
  110: 
  111: 
  112: # Update these keys if the user sets a custom home.
  113: _HOME_KEYS = [
  114:     "installed_base",
  115:     "base",
  116:     "installed_platbase",
  117:     "platbase",
  118:     "prefix",
  119:     "exec_prefix",
  120: ]
  121: if sysconfig.get_config_var("userbase") is not None:
  122:     _HOME_KEYS.append("userbase")
  123: 
  124: 
  125: def get_scheme(
  126:     dist_name: str,
  127:     user: bool = False,
  128:     home: str | None = None,
  129:     root: str | None = None,
  130:     isolated: bool = False,
  131:     prefix: str | None = None,
  132: ) -> Scheme:
  133:     """
  134:     Get the "scheme" corresponding to the input parameters.
  135: 
  136:     :param dist_name: the name of the package to retrieve the scheme for, used
  137:         in the headers scheme path
  138:     :param user: indicates to use the "user" scheme
  139:     :param home: indicates to use the "home" scheme
  140:     :param root: root under which other directories are re-based
  141:     :param isolated: ignored, but kept for distutils compatibility (where
  142:         this controls whether the user-site pydistutils.cfg is honored)
  143:     :param prefix: indicates to use the "prefix" scheme and provides the
  144:         base directory for the same
  145:     """
  146:     if user and prefix:
  147:         raise InvalidSchemeCombination("--user", "--prefix")
  148:     if home and prefix:
  149:         raise InvalidSchemeCombination("--home", "--prefix")
  150: 
  151:     if home is not None:
  152:         scheme_name = _infer_home()
  153:     elif user:
  154:         scheme_name = _infer_user()
  155:     else:
  156:         scheme_name = _infer_prefix()
  157: 
  158:     # Special case: When installing into a custom prefix, use posix_prefix
  159:     # instead of osx_framework_library. See _should_use_osx_framework_prefix()
  160:     # docstring for details.
  161:     if prefix is not None and scheme_name == "osx_framework_library":
  162:         scheme_name = "posix_prefix"
  163: 
  164:     if home is not None:
  165:         variables = {k: home for k in _HOME_KEYS}
  166:     elif prefix is not None:
  167:         variables = {k: prefix for k in _HOME_KEYS}
  168:     else:
  169:         variables = {}
  170: 
  171:     paths = sysconfig.get_paths(scheme=scheme_name, vars=variables)
  172: 
  173:     # Logic here is very arbitrary, we're doing it for compatibility, don't ask.
  174:     # 1. Pip historically uses a special header path in virtual environments.
  175:     # 2. If the distribution name is not known, distutils uses 'UNKNOWN'. We
  176:     #    only do the same when not running in a virtual environment because
  177:     #    pip's historical header path logic (see point 1) did not do this.
  178:     if running_under_virtualenv():
  179:         if user:
  180:             base = variables.get("userbase", sys.prefix)
  181:         else:
  182:             base = variables.get("base", sys.prefix)
  183:         python_xy = f"python{get_major_minor_version()}"
  184:         paths["include"] = os.path.join(base, "include", "site", python_xy)
  185:     elif not dist_name:
  186:         dist_name = "UNKNOWN"
  187: 
  188:     scheme = Scheme(
  189:         platlib=paths["platlib"],
  190:         purelib=paths["purelib"],
  191:         headers=os.path.join(paths["include"], dist_name),
  192:         scripts=paths["scripts"],
  193:         data=paths["data"],
  194:     )
  195:     if root is not None:
  196:         converted_keys = {}
  197:         for key in SCHEME_KEYS:
  198:             converted_keys[key] = change_root(root, getattr(scheme, key))
  199:         scheme = Scheme(**converted_keys)
  200:     return scheme
  201: 
  202: 
  203: def get_bin_prefix() -> str:
  204:     # Forcing to use /usr/local/bin for standard macOS framework installs.
  205:     if sys.platform[:6] == "darwin" and sys.prefix[:16] == "/System/Library/":
  206:         return "/usr/local/bin"
  207:     return sysconfig.get_paths()["scripts"]
  208: 
  209: 
  210: def get_purelib() -> str:
  211:     return sysconfig.get_paths()["purelib"]
  212: 
  213: 
  214: def get_platlib() -> str:
  215:     return sysconfig.get_paths()["platlib"]
