    1: """Backing implementation for InstallRequirement's various constructors
    2: 
    3: The idea here is that these formed a major chunk of InstallRequirement's size
    4: so, moving them and support code dedicated to them outside of that class
    5: helps creates for better understandability for the rest of the code.
    6: 
    7: These are meant to be used elsewhere within pip to create instances of
    8: InstallRequirement.
    9: """
   10: 
   11: from __future__ import annotations
   12: 
   13: import copy
   14: import logging
   15: import os
   16: import re
   17: from collections.abc import Collection
   18: from dataclasses import dataclass
   19: 
   20: from pip._vendor.packaging.markers import Marker
   21: from pip._vendor.packaging.requirements import InvalidRequirement, Requirement
   22: from pip._vendor.packaging.specifiers import Specifier
   23: 
   24: from pip._internal.exceptions import InstallationError
   25: from pip._internal.models.index import PyPI, TestPyPI
   26: from pip._internal.models.link import Link
   27: from pip._internal.models.wheel import Wheel
   28: from pip._internal.req.req_file import ParsedRequirement
   29: from pip._internal.req.req_install import InstallRequirement
   30: from pip._internal.utils.filetypes import is_archive_file
   31: from pip._internal.utils.misc import is_installable_dir
   32: from pip._internal.utils.packaging import get_requirement
   33: from pip._internal.utils.urls import path_to_url
   34: from pip._internal.vcs import is_url, vcs
   35: 
   36: __all__ = [
   37:     "install_req_from_editable",
   38:     "install_req_from_line",
   39:     "parse_editable",
   40: ]
   41: 
   42: logger = logging.getLogger(__name__)
   43: operators = Specifier._operators.keys()
   44: 
   45: 
   46: def _strip_extras(path: str) -> tuple[str, str | None]:
   47:     m = re.match(r"^(.+)(\[[^\]]+\])$", path)
   48:     extras = None
   49:     if m:
   50:         path_no_extras = m.group(1)
   51:         extras = m.group(2)
   52:     else:
   53:         path_no_extras = path
   54: 
   55:     return path_no_extras, extras
   56: 
   57: 
   58: def convert_extras(extras: str | None) -> set[str]:
   59:     if not extras:
   60:         return set()
   61:     return get_requirement("placeholder" + extras.lower()).extras
   62: 
   63: 
   64: def _set_requirement_extras(req: Requirement, new_extras: set[str]) -> Requirement:
   65:     """
   66:     Returns a new requirement based on the given one, with the supplied extras. If the
   67:     given requirement already has extras those are replaced (or dropped if no new extras
   68:     are given).
   69:     """
   70:     match: re.Match[str] | None = re.fullmatch(
   71:         # see https://peps.python.org/pep-0508/#complete-grammar
   72:         r"([\w\t .-]+)(\[[^\]]*\])?(.*)",
   73:         str(req),
   74:         flags=re.ASCII,
   75:     )
   76:     # ireq.req is a valid requirement so the regex should always match
   77:     assert (
   78:         match is not None
   79:     ), f"regex match on requirement {req} failed, this should never happen"
   80:     pre: str | None = match.group(1)
   81:     post: str | None = match.group(3)
   82:     assert (
   83:         pre is not None and post is not None
   84:     ), f"regex group selection for requirement {req} failed, this should never happen"
   85:     extras: str = "[{}]".format(",".join(sorted(new_extras)) if new_extras else "")
   86:     return get_requirement(f"{pre}{extras}{post}")
   87: 
   88: 
   89: def parse_editable(editable_req: str) -> tuple[str | None, str, set[str]]:
   90:     """Parses an editable requirement into:
   91:         - a requirement name
   92:         - an URL
   93:         - extras
   94:         - editable options
   95:     Accepted requirements:
   96:         svn+http://blahblah@rev#egg=Foobar[baz]&subdirectory=version_subdir
   97:         .[some_extra]
   98:     """
   99: 
  100:     url = editable_req
  101: 
  102:     # If a file path is specified with extras, strip off the extras.
  103:     url_no_extras, extras = _strip_extras(url)
  104: 
  105:     if os.path.isdir(url_no_extras):
  106:         # Treating it as code that has already been checked out
  107:         url_no_extras = path_to_url(url_no_extras)
  108: 
  109:     if url_no_extras.lower().startswith("file:"):
  110:         package_name = Link(url_no_extras).egg_fragment
  111:         if extras:
  112:             return (
  113:                 package_name,
  114:                 url_no_extras,
  115:                 get_requirement("placeholder" + extras.lower()).extras,
  116:             )
  117:         else:
  118:             return package_name, url_no_extras, set()
  119: 
  120:     for version_control in vcs:
  121:         if url.lower().startswith(f"{version_control}:"):
  122:             url = f"{version_control}+{url}"
  123:             break
  124: 
  125:     link = Link(url)
  126: 
  127:     if not link.is_vcs:
  128:         backends = ", ".join(vcs.all_schemes)
  129:         raise InstallationError(
  130:             f"{editable_req} is not a valid editable requirement. "
  131:             f"It should either be a path to a local project or a VCS URL "
  132:             f"(beginning with {backends})."
  133:         )
  134: 
  135:     package_name = link.egg_fragment
  136:     if not package_name:
  137:         raise InstallationError(
  138:             f"Could not detect requirement name for '{editable_req}', "
  139:             "please specify one with #egg=your_package_name"
  140:         )
  141:     return package_name, url, set()
  142: 
  143: 
  144: def check_first_requirement_in_file(filename: str) -> None:
  145:     """Check if file is parsable as a requirements file.
  146: 
  147:     This is heavily based on ``pkg_resources.parse_requirements``, but
  148:     simplified to just check the first meaningful line.
  149: 
  150:     :raises InvalidRequirement: If the first meaningful line cannot be parsed
  151:         as an requirement.
  152:     """
  153:     with open(filename, encoding="utf-8", errors="ignore") as f:
  154:         # Create a steppable iterator, so we can handle \-continuations.
  155:         lines = (
  156:             line
  157:             for line in (line.strip() for line in f)
  158:             if line and not line.startswith("#")  # Skip blank lines/comments.
  159:         )
  160: 
  161:         for line in lines:
  162:             # Drop comments -- a hash without a space may be in a URL.
  163:             if " #" in line:
  164:                 line = line[: line.find(" #")]
  165:             # If there is a line continuation, drop it, and append the next line.
  166:             if line.endswith("\\"):
  167:                 line = line[:-2].strip() + next(lines, "")
  168:             get_requirement(line)
  169:             return
  170: 
  171: 
  172: def deduce_helpful_msg(req: str) -> str:
  173:     """Returns helpful msg in case requirements file does not exist,
  174:     or cannot be parsed.
  175: 
  176:     :params req: Requirements file path
  177:     """
  178:     if not os.path.exists(req):
  179:         return f" File '{req}' does not exist."
  180:     msg = " The path does exist. "
  181:     # Try to parse and check if it is a requirements file.
  182:     try:
  183:         check_first_requirement_in_file(req)
  184:     except InvalidRequirement:
  185:         logger.debug("Cannot parse '%s' as requirements file", req)
  186:     else:
  187:         msg += (
  188:             f"The argument you provided "
  189:             f"({req}) appears to be a"
  190:             f" requirements file. If that is the"
  191:             f" case, use the '-r' flag to install"
  192:             f" the packages specified within it."
  193:         )
  194:     return msg
  195: 
  196: 
  197: @dataclass(frozen=True)
  198: class RequirementParts:
  199:     requirement: Requirement | None
  200:     link: Link | None
  201:     markers: Marker | None
  202:     extras: set[str]
  203: 
  204: 
  205: def parse_req_from_editable(editable_req: str) -> RequirementParts:
  206:     name, url, extras_override = parse_editable(editable_req)
  207: 
  208:     if name is not None:
  209:         try:
  210:             req: Requirement | None = get_requirement(name)
  211:         except InvalidRequirement as exc:
  212:             raise InstallationError(f"Invalid requirement: {name!r}: {exc}")
  213:     else:
  214:         req = None
  215: 
  216:     link = Link(url)
  217: 
  218:     return RequirementParts(req, link, None, extras_override)
  219: 
  220: 
  221: # ---- The actual constructors follow ----
  222: 
  223: 
  224: def install_req_from_editable(
  225:     editable_req: str,
  226:     comes_from: InstallRequirement | str | None = None,
  227:     *,
  228:     use_pep517: bool | None = None,
  229:     isolated: bool = False,
  230:     global_options: list[str] | None = None,
  231:     hash_options: dict[str, list[str]] | None = None,
  232:     constraint: bool = False,
  233:     user_supplied: bool = False,
  234:     permit_editable_wheels: bool = False,
  235:     config_settings: dict[str, str | list[str]] | None = None,
  236: ) -> InstallRequirement:
  237:     parts = parse_req_from_editable(editable_req)
  238: 
  239:     return InstallRequirement(
  240:         parts.requirement,
  241:         comes_from=comes_from,
  242:         user_supplied=user_supplied,
  243:         editable=True,
  244:         permit_editable_wheels=permit_editable_wheels,
  245:         link=parts.link,
  246:         constraint=constraint,
  247:         use_pep517=use_pep517,
  248:         isolated=isolated,
  249:         global_options=global_options,
  250:         hash_options=hash_options,
  251:         config_settings=config_settings,
  252:         extras=parts.extras,
  253:     )
  254: 
  255: 
  256: def _looks_like_path(name: str) -> bool:
  257:     """Checks whether the string "looks like" a path on the filesystem.
  258: 
  259:     This does not check whether the target actually exists, only judge from the
  260:     appearance.
  261: 
  262:     Returns true if any of the following conditions is true:
  263:     * a path separator is found (either os.path.sep or os.path.altsep);
  264:     * a dot is found (which represents the current directory).
  265:     """
  266:     if os.path.sep in name:
  267:         return True
  268:     if os.path.altsep is not None and os.path.altsep in name:
  269:         return True
  270:     if name.startswith("."):
  271:         return True
  272:     return False
  273: 
  274: 
  275: def _get_url_from_path(path: str, name: str) -> str | None:
  276:     """
  277:     First, it checks whether a provided path is an installable directory. If it
  278:     is, returns the path.
  279: 
  280:     If false, check if the path is an archive file (such as a .whl).
  281:     The function checks if the path is a file. If false, if the path has
  282:     an @, it will treat it as a PEP 440 URL requirement and return the path.
  283:     """
  284:     if _looks_like_path(name) and os.path.isdir(path):
  285:         if is_installable_dir(path):
  286:             return path_to_url(path)
  287:         # TODO: The is_installable_dir test here might not be necessary
  288:         #       now that it is done in load_pyproject_toml too.
  289:         raise InstallationError(
  290:             f"Directory {name!r} is not installable. Neither 'setup.py' "
  291:             "nor 'pyproject.toml' found."
  292:         )
  293:     if not is_archive_file(path):
  294:         return None
  295:     if os.path.isfile(path):
  296:         return path_to_url(path)
  297:     urlreq_parts = name.split("@", 1)
  298:     if len(urlreq_parts) >= 2 and not _looks_like_path(urlreq_parts[0]):
  299:         # If the path contains '@' and the part before it does not look
  300:         # like a path, try to treat it as a PEP 440 URL req instead.
  301:         return None
  302:     logger.warning(
  303:         "Requirement %r looks like a filename, but the file does not exist",
  304:         name,
  305:     )
  306:     return path_to_url(path)
  307: 
  308: 
  309: def parse_req_from_line(name: str, line_source: str | None) -> RequirementParts:
  310:     if is_url(name):
  311:         marker_sep = "; "
  312:     else:
  313:         marker_sep = ";"
  314:     if marker_sep in name:
  315:         name, markers_as_string = name.split(marker_sep, 1)
  316:         markers_as_string = markers_as_string.strip()
  317:         if not markers_as_string:
  318:             markers = None
  319:         else:
  320:             markers = Marker(markers_as_string)
  321:     else:
  322:         markers = None
  323:     name = name.strip()
  324:     req_as_string = None
  325:     path = os.path.normpath(os.path.abspath(name))
  326:     link = None
  327:     extras_as_string = None
  328: 
  329:     if is_url(name):
  330:         link = Link(name)
  331:     else:
  332:         p, extras_as_string = _strip_extras(path)
  333:         url = _get_url_from_path(p, name)
  334:         if url is not None:
  335:             link = Link(url)
  336: 
  337:     # it's a local file, dir, or url
  338:     if link:
  339:         # Handle relative file URLs
  340:         if link.scheme == "file" and re.search(r"\.\./", link.url):
  341:             link = Link(path_to_url(os.path.normpath(os.path.abspath(link.path))))
  342:         # wheel file
  343:         if link.is_wheel:
  344:             wheel = Wheel(link.filename)  # can raise InvalidWheelFilename
  345:             req_as_string = f"{wheel.name}=={wheel.version}"
  346:         else:
  347:             # set the req to the egg fragment.  when it's not there, this
  348:             # will become an 'unnamed' requirement
  349:             req_as_string = link.egg_fragment
  350: 
  351:     # a requirement specifier
  352:     else:
  353:         req_as_string = name
  354: 
  355:     extras = convert_extras(extras_as_string)
  356: 
  357:     def with_source(text: str) -> str:
  358:         if not line_source:
  359:             return text
  360:         return f"{text} (from {line_source})"
  361: 
  362:     def _parse_req_string(req_as_string: str) -> Requirement:
  363:         try:
  364:             return get_requirement(req_as_string)
  365:         except InvalidRequirement as exc:
  366:             if os.path.sep in req_as_string:
  367:                 add_msg = "It looks like a path."
  368:                 add_msg += deduce_helpful_msg(req_as_string)
  369:             elif "=" in req_as_string and not any(
  370:                 op in req_as_string for op in operators
  371:             ):
  372:                 add_msg = "= is not a valid operator. Did you mean == ?"
  373:             else:
  374:                 add_msg = ""
  375:             msg = with_source(f"Invalid requirement: {req_as_string!r}: {exc}")
  376:             if add_msg:
  377:                 msg += f"\nHint: {add_msg}"
  378:             raise InstallationError(msg)
  379: 
  380:     if req_as_string is not None:
  381:         req: Requirement | None = _parse_req_string(req_as_string)
  382:     else:
  383:         req = None
  384: 
  385:     return RequirementParts(req, link, markers, extras)
  386: 
  387: 
  388: def install_req_from_line(
  389:     name: str,
  390:     comes_from: str | InstallRequirement | None = None,
  391:     *,
  392:     use_pep517: bool | None = None,
  393:     isolated: bool = False,
  394:     global_options: list[str] | None = None,
  395:     hash_options: dict[str, list[str]] | None = None,
  396:     constraint: bool = False,
  397:     line_source: str | None = None,
  398:     user_supplied: bool = False,
  399:     config_settings: dict[str, str | list[str]] | None = None,
  400: ) -> InstallRequirement:
  401:     """Creates an InstallRequirement from a name, which might be a
  402:     requirement, directory containing 'setup.py', filename, or URL.
  403: 
  404:     :param line_source: An optional string describing where the line is from,
  405:         for logging purposes in case of an error.
  406:     """
  407:     parts = parse_req_from_line(name, line_source)
  408: 
  409:     return InstallRequirement(
  410:         parts.requirement,
  411:         comes_from,
  412:         link=parts.link,
  413:         markers=parts.markers,
  414:         use_pep517=use_pep517,
  415:         isolated=isolated,
  416:         global_options=global_options,
  417:         hash_options=hash_options,
  418:         config_settings=config_settings,
  419:         constraint=constraint,
  420:         extras=parts.extras,
  421:         user_supplied=user_supplied,
  422:     )
  423: 
  424: 
  425: def install_req_from_req_string(
  426:     req_string: str,
  427:     comes_from: InstallRequirement | None = None,
  428:     isolated: bool = False,
  429:     use_pep517: bool | None = None,
  430:     user_supplied: bool = False,
  431: ) -> InstallRequirement:
  432:     try:
  433:         req = get_requirement(req_string)
  434:     except InvalidRequirement as exc:
  435:         raise InstallationError(f"Invalid requirement: {req_string!r}: {exc}")
  436: 
  437:     domains_not_allowed = [
  438:         PyPI.file_storage_domain,
  439:         TestPyPI.file_storage_domain,
  440:     ]
  441:     if (
  442:         req.url
  443:         and comes_from
  444:         and comes_from.link
  445:         and comes_from.link.netloc in domains_not_allowed
  446:     ):
  447:         # Explicitly disallow pypi packages that depend on external urls
  448:         raise InstallationError(
  449:             "Packages installed from PyPI cannot depend on packages "
  450:             "which are not also hosted on PyPI.\n"
  451:             f"{comes_from.name} depends on {req} "
  452:         )
  453: 
  454:     return InstallRequirement(
  455:         req,
  456:         comes_from,
  457:         isolated=isolated,
  458:         use_pep517=use_pep517,
  459:         user_supplied=user_supplied,
  460:     )
  461: 
  462: 
  463: def install_req_from_parsed_requirement(
  464:     parsed_req: ParsedRequirement,
  465:     isolated: bool = False,
  466:     use_pep517: bool | None = None,
  467:     user_supplied: bool = False,
  468:     config_settings: dict[str, str | list[str]] | None = None,
  469: ) -> InstallRequirement:
  470:     if parsed_req.is_editable:
  471:         req = install_req_from_editable(
  472:             parsed_req.requirement,
  473:             comes_from=parsed_req.comes_from,
  474:             use_pep517=use_pep517,
  475:             constraint=parsed_req.constraint,
  476:             isolated=isolated,
  477:             user_supplied=user_supplied,
  478:             config_settings=config_settings,
  479:         )
  480: 
  481:     else:
  482:         req = install_req_from_line(
  483:             parsed_req.requirement,
  484:             comes_from=parsed_req.comes_from,
  485:             use_pep517=use_pep517,
  486:             isolated=isolated,
  487:             global_options=(
  488:                 parsed_req.options.get("global_options", [])
  489:                 if parsed_req.options
  490:                 else []
  491:             ),
  492:             hash_options=(
  493:                 parsed_req.options.get("hashes", {}) if parsed_req.options else {}
  494:             ),
  495:             constraint=parsed_req.constraint,
  496:             line_source=parsed_req.line_source,
  497:             user_supplied=user_supplied,
  498:             config_settings=config_settings,
  499:         )
  500:     return req
  501: 
  502: 
  503: def install_req_from_link_and_ireq(
  504:     link: Link, ireq: InstallRequirement
  505: ) -> InstallRequirement:
  506:     return InstallRequirement(
  507:         req=ireq.req,
  508:         comes_from=ireq.comes_from,
  509:         editable=ireq.editable,
  510:         link=link,
  511:         markers=ireq.markers,
  512:         use_pep517=ireq.use_pep517,
  513:         isolated=ireq.isolated,
  514:         global_options=ireq.global_options,
  515:         hash_options=ireq.hash_options,
  516:         config_settings=ireq.config_settings,
  517:         user_supplied=ireq.user_supplied,
  518:     )
  519: 
  520: 
  521: def install_req_drop_extras(ireq: InstallRequirement) -> InstallRequirement:
  522:     """
  523:     Creates a new InstallationRequirement using the given template but without
  524:     any extras. Sets the original requirement as the new one's parent
  525:     (comes_from).
  526:     """
  527:     return InstallRequirement(
  528:         req=(
  529:             _set_requirement_extras(ireq.req, set()) if ireq.req is not None else None
  530:         ),
  531:         comes_from=ireq,
  532:         editable=ireq.editable,
  533:         link=ireq.link,
  534:         markers=ireq.markers,
  535:         use_pep517=ireq.use_pep517,
  536:         isolated=ireq.isolated,
  537:         global_options=ireq.global_options,
  538:         hash_options=ireq.hash_options,
  539:         constraint=ireq.constraint,
  540:         extras=[],
  541:         config_settings=ireq.config_settings,
  542:         user_supplied=ireq.user_supplied,
  543:         permit_editable_wheels=ireq.permit_editable_wheels,
  544:     )
  545: 
  546: 
  547: def install_req_extend_extras(
  548:     ireq: InstallRequirement,
  549:     extras: Collection[str],
  550: ) -> InstallRequirement:
  551:     """
  552:     Returns a copy of an installation requirement with some additional extras.
  553:     Makes a shallow copy of the ireq object.
  554:     """
  555:     result = copy.copy(ireq)
  556:     result.extras = {*ireq.extras, *extras}
  557:     result.req = (
  558:         _set_requirement_extras(ireq.req, result.extras)
  559:         if ireq.req is not None
  560:         else None
  561:     )
  562:     return result
