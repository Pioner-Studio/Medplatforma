    1: """Routines related to PyPI, indexes"""
    2: 
    3: from __future__ import annotations
    4: 
    5: import enum
    6: import functools
    7: import itertools
    8: import logging
    9: import re
   10: from collections.abc import Iterable
   11: from dataclasses import dataclass
   12: from typing import (
   13:     TYPE_CHECKING,
   14:     Optional,
   15:     Union,
   16: )
   17: 
   18: from pip._vendor.packaging import specifiers
   19: from pip._vendor.packaging.tags import Tag
   20: from pip._vendor.packaging.utils import canonicalize_name
   21: from pip._vendor.packaging.version import InvalidVersion, _BaseVersion
   22: from pip._vendor.packaging.version import parse as parse_version
   23: 
   24: from pip._internal.exceptions import (
   25:     BestVersionAlreadyInstalled,
   26:     DistributionNotFound,
   27:     InvalidWheelFilename,
   28:     UnsupportedWheel,
   29: )
   30: from pip._internal.index.collector import LinkCollector, parse_links
   31: from pip._internal.models.candidate import InstallationCandidate
   32: from pip._internal.models.format_control import FormatControl
   33: from pip._internal.models.link import Link
   34: from pip._internal.models.search_scope import SearchScope
   35: from pip._internal.models.selection_prefs import SelectionPreferences
   36: from pip._internal.models.target_python import TargetPython
   37: from pip._internal.models.wheel import Wheel
   38: from pip._internal.req import InstallRequirement
   39: from pip._internal.utils._log import getLogger
   40: from pip._internal.utils.filetypes import WHEEL_EXTENSION
   41: from pip._internal.utils.hashes import Hashes
   42: from pip._internal.utils.logging import indent_log
   43: from pip._internal.utils.misc import build_netloc
   44: from pip._internal.utils.packaging import check_requires_python
   45: from pip._internal.utils.unpacking import SUPPORTED_EXTENSIONS
   46: 
   47: if TYPE_CHECKING:
   48:     from typing_extensions import TypeGuard
   49: 
   50: __all__ = ["FormatControl", "BestCandidateResult", "PackageFinder"]
   51: 
   52: 
   53: logger = getLogger(__name__)
   54: 
   55: BuildTag = Union[tuple[()], tuple[int, str]]
   56: CandidateSortingKey = tuple[int, int, int, _BaseVersion, Optional[int], BuildTag]
   57: 
   58: 
   59: def _check_link_requires_python(
   60:     link: Link,
   61:     version_info: tuple[int, int, int],
   62:     ignore_requires_python: bool = False,
   63: ) -> bool:
   64:     """
   65:     Return whether the given Python version is compatible with a link's
   66:     "Requires-Python" value.
   67: 
   68:     :param version_info: A 3-tuple of ints representing the Python
   69:         major-minor-micro version to check.
   70:     :param ignore_requires_python: Whether to ignore the "Requires-Python"
   71:         value if the given Python version isn't compatible.
   72:     """
   73:     try:
   74:         is_compatible = check_requires_python(
   75:             link.requires_python,
   76:             version_info=version_info,
   77:         )
   78:     except specifiers.InvalidSpecifier:
   79:         logger.debug(
   80:             "Ignoring invalid Requires-Python (%r) for link: %s",
   81:             link.requires_python,
   82:             link,
   83:         )
   84:     else:
   85:         if not is_compatible:
   86:             version = ".".join(map(str, version_info))
   87:             if not ignore_requires_python:
   88:                 logger.verbose(
   89:                     "Link requires a different Python (%s not in: %r): %s",
   90:                     version,
   91:                     link.requires_python,
   92:                     link,
   93:                 )
   94:                 return False
   95: 
   96:             logger.debug(
   97:                 "Ignoring failed Requires-Python check (%s not in: %r) for link: %s",
   98:                 version,
   99:                 link.requires_python,
  100:                 link,
  101:             )
  102: 
  103:     return True
  104: 
  105: 
  106: class LinkType(enum.Enum):
  107:     candidate = enum.auto()
  108:     different_project = enum.auto()
  109:     yanked = enum.auto()
  110:     format_unsupported = enum.auto()
  111:     format_invalid = enum.auto()
  112:     platform_mismatch = enum.auto()
  113:     requires_python_mismatch = enum.auto()
  114: 
  115: 
  116: class LinkEvaluator:
  117:     """
  118:     Responsible for evaluating links for a particular project.
  119:     """
  120: 
  121:     _py_version_re = re.compile(r"-py([123]\.?[0-9]?)$")
  122: 
  123:     # Don't include an allow_yanked default value to make sure each call
  124:     # site considers whether yanked releases are allowed. This also causes
  125:     # that decision to be made explicit in the calling code, which helps
  126:     # people when reading the code.
  127:     def __init__(
  128:         self,
  129:         project_name: str,
  130:         canonical_name: str,
  131:         formats: frozenset[str],
  132:         target_python: TargetPython,
  133:         allow_yanked: bool,
  134:         ignore_requires_python: bool | None = None,
  135:     ) -> None:
  136:         """
  137:         :param project_name: The user supplied package name.
  138:         :param canonical_name: The canonical package name.
  139:         :param formats: The formats allowed for this package. Should be a set
  140:             with 'binary' or 'source' or both in it.
  141:         :param target_python: The target Python interpreter to use when
  142:             evaluating link compatibility. This is used, for example, to
  143:             check wheel compatibility, as well as when checking the Python
  144:             version, e.g. the Python version embedded in a link filename
  145:             (or egg fragment) and against an HTML link's optional PEP 503
  146:             "data-requires-python" attribute.
  147:         :param allow_yanked: Whether files marked as yanked (in the sense
  148:             of PEP 592) are permitted to be candidates for install.
  149:         :param ignore_requires_python: Whether to ignore incompatible
  150:             PEP 503 "data-requires-python" values in HTML links. Defaults
  151:             to False.
  152:         """
  153:         if ignore_requires_python is None:
  154:             ignore_requires_python = False
  155: 
  156:         self._allow_yanked = allow_yanked
  157:         self._canonical_name = canonical_name
  158:         self._ignore_requires_python = ignore_requires_python
  159:         self._formats = formats
  160:         self._target_python = target_python
  161: 
  162:         self.project_name = project_name
  163: 
  164:     def evaluate_link(self, link: Link) -> tuple[LinkType, str]:
  165:         """
  166:         Determine whether a link is a candidate for installation.
  167: 
  168:         :return: A tuple (result, detail), where *result* is an enum
  169:             representing whether the evaluation found a candidate, or the reason
  170:             why one is not found. If a candidate is found, *detail* will be the
  171:             candidate's version string; if one is not found, it contains the
  172:             reason the link fails to qualify.
  173:         """
  174:         version = None
  175:         if link.is_yanked and not self._allow_yanked:
  176:             reason = link.yanked_reason or "<none given>"
  177:             return (LinkType.yanked, f"yanked for reason: {reason}")
  178: 
  179:         if link.egg_fragment:
  180:             egg_info = link.egg_fragment
  181:             ext = link.ext
  182:         else:
  183:             egg_info, ext = link.splitext()
  184:             if not ext:
  185:                 return (LinkType.format_unsupported, "not a file")
  186:             if ext not in SUPPORTED_EXTENSIONS:
  187:                 return (
  188:                     LinkType.format_unsupported,
  189:                     f"unsupported archive format: {ext}",
  190:                 )
  191:             if "binary" not in self._formats and ext == WHEEL_EXTENSION:
  192:                 reason = f"No binaries permitted for {self.project_name}"
  193:                 return (LinkType.format_unsupported, reason)
  194:             if "macosx10" in link.path and ext == ".zip":
  195:                 return (LinkType.format_unsupported, "macosx10 one")
  196:             if ext == WHEEL_EXTENSION:
  197:                 try:
  198:                     wheel = Wheel(link.filename)
  199:                 except InvalidWheelFilename:
  200:                     return (
  201:                         LinkType.format_invalid,
  202:                         "invalid wheel filename",
  203:                     )
  204:                 if canonicalize_name(wheel.name) != self._canonical_name:
  205:                     reason = f"wrong project name (not {self.project_name})"
  206:                     return (LinkType.different_project, reason)
  207: 
  208:                 supported_tags = self._target_python.get_unsorted_tags()
  209:                 if not wheel.supported(supported_tags):
  210:                     # Include the wheel's tags in the reason string to
  211:                     # simplify troubleshooting compatibility issues.
  212:                     file_tags = ", ".join(wheel.get_formatted_file_tags())
  213:                     reason = (
  214:                         f"none of the wheel's tags ({file_tags}) are compatible "
  215:                         f"(run pip debug --verbose to show compatible tags)"
  216:                     )
  217:                     return (LinkType.platform_mismatch, reason)
  218: 
  219:                 version = wheel.version
  220: 
  221:         # This should be up by the self.ok_binary check, but see issue 2700.
  222:         if "source" not in self._formats and ext != WHEEL_EXTENSION:
  223:             reason = f"No sources permitted for {self.project_name}"
  224:             return (LinkType.format_unsupported, reason)
  225: 
  226:         if not version:
  227:             version = _extract_version_from_fragment(
  228:                 egg_info,
  229:                 self._canonical_name,
  230:             )
  231:         if not version:
  232:             reason = f"Missing project version for {self.project_name}"
  233:             return (LinkType.format_invalid, reason)
  234: 
  235:         match = self._py_version_re.search(version)
  236:         if match:
  237:             version = version[: match.start()]
  238:             py_version = match.group(1)
  239:             if py_version != self._target_python.py_version:
  240:                 return (
  241:                     LinkType.platform_mismatch,
  242:                     "Python version is incorrect",
  243:                 )
  244: 
  245:         supports_python = _check_link_requires_python(
  246:             link,
  247:             version_info=self._target_python.py_version_info,
  248:             ignore_requires_python=self._ignore_requires_python,
  249:         )
  250:         if not supports_python:
  251:             requires_python = link.requires_python
  252:             if requires_python:
  253: 
  254:                 def get_version_sort_key(v: str) -> tuple[int, ...]:
  255:                     return tuple(int(s) for s in v.split(".") if s.isdigit())
  256: 
  257:                 requires_python = ",".join(
  258:                     sorted(
  259:                         (str(s) for s in specifiers.SpecifierSet(requires_python)),
  260:                         key=get_version_sort_key,
  261:                     )
  262:                 )
  263:             reason = f"{version} Requires-Python {requires_python}"
  264:             return (LinkType.requires_python_mismatch, reason)
  265: 
  266:         logger.debug("Found link %s, version: %s", link, version)
  267: 
  268:         return (LinkType.candidate, version)
  269: 
  270: 
  271: def filter_unallowed_hashes(
  272:     candidates: list[InstallationCandidate],
  273:     hashes: Hashes | None,
  274:     project_name: str,
  275: ) -> list[InstallationCandidate]:
  276:     """
  277:     Filter out candidates whose hashes aren't allowed, and return a new
  278:     list of candidates.
  279: 
  280:     If at least one candidate has an allowed hash, then all candidates with
  281:     either an allowed hash or no hash specified are returned.  Otherwise,
  282:     the given candidates are returned.
  283: 
  284:     Including the candidates with no hash specified when there is a match
  285:     allows a warning to be logged if there is a more preferred candidate
  286:     with no hash specified.  Returning all candidates in the case of no
  287:     matches lets pip report the hash of the candidate that would otherwise
  288:     have been installed (e.g. permitting the user to more easily update
  289:     their requirements file with the desired hash).
  290:     """
  291:     if not hashes:
  292:         logger.debug(
  293:             "Given no hashes to check %s links for project %r: "
  294:             "discarding no candidates",
  295:             len(candidates),
  296:             project_name,
  297:         )
  298:         # Make sure we're not returning back the given value.
  299:         return list(candidates)
  300: 
  301:     matches_or_no_digest = []
  302:     # Collect the non-matches for logging purposes.
  303:     non_matches = []
  304:     match_count = 0
  305:     for candidate in candidates:
  306:         link = candidate.link
  307:         if not link.has_hash:
  308:             pass
  309:         elif link.is_hash_allowed(hashes=hashes):
  310:             match_count += 1
  311:         else:
  312:             non_matches.append(candidate)
  313:             continue
  314: 
  315:         matches_or_no_digest.append(candidate)
  316: 
  317:     if match_count:
  318:         filtered = matches_or_no_digest
  319:     else:
  320:         # Make sure we're not returning back the given value.
  321:         filtered = list(candidates)
  322: 
  323:     if len(filtered) == len(candidates):
  324:         discard_message = "discarding no candidates"
  325:     else:
  326:         discard_message = "discarding {} non-matches:\n  {}".format(
  327:             len(non_matches),
  328:             "\n  ".join(str(candidate.link) for candidate in non_matches),
  329:         )
  330: 
  331:     logger.debug(
  332:         "Checked %s links for project %r against %s hashes "
  333:         "(%s matches, %s no digest): %s",
  334:         len(candidates),
  335:         project_name,
  336:         hashes.digest_count,
  337:         match_count,
  338:         len(matches_or_no_digest) - match_count,
  339:         discard_message,
  340:     )
  341: 
  342:     return filtered
  343: 
  344: 
  345: @dataclass
  346: class CandidatePreferences:
  347:     """
  348:     Encapsulates some of the preferences for filtering and sorting
  349:     InstallationCandidate objects.
  350:     """
  351: 
  352:     prefer_binary: bool = False
  353:     allow_all_prereleases: bool = False
  354: 
  355: 
  356: @dataclass(frozen=True)
  357: class BestCandidateResult:
  358:     """A collection of candidates, returned by `PackageFinder.find_best_candidate`.
  359: 
  360:     This class is only intended to be instantiated by CandidateEvaluator's
  361:     `compute_best_candidate()` method.
  362: 
  363:     :param all_candidates: A sequence of all available candidates found.
  364:     :param applicable_candidates: The applicable candidates.
  365:     :param best_candidate: The most preferred candidate found, or None
  366:         if no applicable candidates were found.
  367:     """
  368: 
  369:     all_candidates: list[InstallationCandidate]
  370:     applicable_candidates: list[InstallationCandidate]
  371:     best_candidate: InstallationCandidate | None
  372: 
  373:     def __post_init__(self) -> None:
  374:         assert set(self.applicable_candidates) <= set(self.all_candidates)
  375: 
  376:         if self.best_candidate is None:
  377:             assert not self.applicable_candidates
  378:         else:
  379:             assert self.best_candidate in self.applicable_candidates
  380: 
  381: 
  382: class CandidateEvaluator:
  383:     """
  384:     Responsible for filtering and sorting candidates for installation based
  385:     on what tags are valid.
  386:     """
  387: 
  388:     @classmethod
  389:     def create(
  390:         cls,
  391:         project_name: str,
  392:         target_python: TargetPython | None = None,
  393:         prefer_binary: bool = False,
  394:         allow_all_prereleases: bool = False,
  395:         specifier: specifiers.BaseSpecifier | None = None,
  396:         hashes: Hashes | None = None,
  397:     ) -> CandidateEvaluator:
  398:         """Create a CandidateEvaluator object.
  399: 
  400:         :param target_python: The target Python interpreter to use when
  401:             checking compatibility. If None (the default), a TargetPython
  402:             object will be constructed from the running Python.
  403:         :param specifier: An optional object implementing `filter`
  404:             (e.g. `packaging.specifiers.SpecifierSet`) to filter applicable
  405:             versions.
  406:         :param hashes: An optional collection of allowed hashes.
  407:         """
  408:         if target_python is None:
  409:             target_python = TargetPython()
  410:         if specifier is None:
  411:             specifier = specifiers.SpecifierSet()
  412: 
  413:         supported_tags = target_python.get_sorted_tags()
  414: 
  415:         return cls(
  416:             project_name=project_name,
  417:             supported_tags=supported_tags,
  418:             specifier=specifier,
  419:             prefer_binary=prefer_binary,
  420:             allow_all_prereleases=allow_all_prereleases,
  421:             hashes=hashes,
  422:         )
  423: 
  424:     def __init__(
  425:         self,
  426:         project_name: str,
  427:         supported_tags: list[Tag],
  428:         specifier: specifiers.BaseSpecifier,
  429:         prefer_binary: bool = False,
  430:         allow_all_prereleases: bool = False,
  431:         hashes: Hashes | None = None,
  432:     ) -> None:
  433:         """
  434:         :param supported_tags: The PEP 425 tags supported by the target
  435:             Python in order of preference (most preferred first).
  436:         """
  437:         self._allow_all_prereleases = allow_all_prereleases
  438:         self._hashes = hashes
  439:         self._prefer_binary = prefer_binary
  440:         self._project_name = project_name
  441:         self._specifier = specifier
  442:         self._supported_tags = supported_tags
  443:         # Since the index of the tag in the _supported_tags list is used
  444:         # as a priority, precompute a map from tag to index/priority to be
  445:         # used in wheel.find_most_preferred_tag.
  446:         self._wheel_tag_preferences = {
  447:             tag: idx for idx, tag in enumerate(supported_tags)
  448:         }
  449: 
  450:     def get_applicable_candidates(
  451:         self,
  452:         candidates: list[InstallationCandidate],
  453:     ) -> list[InstallationCandidate]:
  454:         """
  455:         Return the applicable candidates from a list of candidates.
  456:         """
  457:         # Using None infers from the specifier instead.
  458:         allow_prereleases = self._allow_all_prereleases or None
  459:         specifier = self._specifier
  460: 
  461:         # We turn the version object into a str here because otherwise
  462:         # when we're debundled but setuptools isn't, Python will see
  463:         # packaging.version.Version and
  464:         # pkg_resources._vendor.packaging.version.Version as different
  465:         # types. This way we'll use a str as a common data interchange
  466:         # format. If we stop using the pkg_resources provided specifier
  467:         # and start using our own, we can drop the cast to str().
  468:         candidates_and_versions = [(c, str(c.version)) for c in candidates]
  469:         versions = set(
  470:             specifier.filter(
  471:                 (v for _, v in candidates_and_versions),
  472:                 prereleases=allow_prereleases,
  473:             )
  474:         )
  475: 
  476:         applicable_candidates = [c for c, v in candidates_and_versions if v in versions]
  477:         filtered_applicable_candidates = filter_unallowed_hashes(
  478:             candidates=applicable_candidates,
  479:             hashes=self._hashes,
  480:             project_name=self._project_name,
  481:         )
  482: 
  483:         return sorted(filtered_applicable_candidates, key=self._sort_key)
  484: 
  485:     def _sort_key(self, candidate: InstallationCandidate) -> CandidateSortingKey:
  486:         """
  487:         Function to pass as the `key` argument to a call to sorted() to sort
  488:         InstallationCandidates by preference.
  489: 
  490:         Returns a tuple such that tuples sorting as greater using Python's
  491:         default comparison operator are more preferred.
  492: 
  493:         The preference is as follows:
  494: 
  495:         First and foremost, candidates with allowed (matching) hashes are
  496:         always preferred over candidates without matching hashes. This is
  497:         because e.g. if the only candidate with an allowed hash is yanked,
  498:         we still want to use that candidate.
  499: 
  500:         Second, excepting hash considerations, candidates that have been
  501:         yanked (in the sense of PEP 592) are always less preferred than
  502:         candidates that haven't been yanked. Then:
  503: 
  504:         If not finding wheels, they are sorted by version only.
  505:         If finding wheels, then the sort order is by version, then:
  506:           1. existing installs
  507:           2. wheels ordered via Wheel.support_index_min(self._supported_tags)
  508:           3. source archives
  509:         If prefer_binary was set, then all wheels are sorted above sources.
  510: 
  511:         Note: it was considered to embed this logic into the Link
  512:               comparison operators, but then different sdist links
  513:               with the same version, would have to be considered equal
  514:         """
  515:         valid_tags = self._supported_tags
  516:         support_num = len(valid_tags)
  517:         build_tag: BuildTag = ()
  518:         binary_preference = 0
  519:         link = candidate.link
  520:         if link.is_wheel:
  521:             # can raise InvalidWheelFilename
  522:             wheel = Wheel(link.filename)
  523:             try:
  524:                 pri = -(
  525:                     wheel.find_most_preferred_tag(
  526:                         valid_tags, self._wheel_tag_preferences
  527:                     )
  528:                 )
  529:             except ValueError:
  530:                 raise UnsupportedWheel(
  531:                     f"{wheel.filename} is not a supported wheel for this platform. It "
  532:                     "can't be sorted."
  533:                 )
  534:             if self._prefer_binary:
  535:                 binary_preference = 1
  536:             build_tag = wheel.build_tag
  537:         else:  # sdist
  538:             pri = -(support_num)
  539:         has_allowed_hash = int(link.is_hash_allowed(self._hashes))
  540:         yank_value = -1 * int(link.is_yanked)  # -1 for yanked.
  541:         return (
  542:             has_allowed_hash,
  543:             yank_value,
  544:             binary_preference,
  545:             candidate.version,
  546:             pri,
  547:             build_tag,
  548:         )
  549: 
  550:     def sort_best_candidate(
  551:         self,
  552:         candidates: list[InstallationCandidate],
  553:     ) -> InstallationCandidate | None:
  554:         """
  555:         Return the best candidate per the instance's sort order, or None if
  556:         no candidate is acceptable.
  557:         """
  558:         if not candidates:
  559:             return None
  560:         best_candidate = max(candidates, key=self._sort_key)
  561:         return best_candidate
  562: 
  563:     def compute_best_candidate(
  564:         self,
  565:         candidates: list[InstallationCandidate],
  566:     ) -> BestCandidateResult:
  567:         """
  568:         Compute and return a `BestCandidateResult` instance.
  569:         """
  570:         applicable_candidates = self.get_applicable_candidates(candidates)
  571: 
  572:         best_candidate = self.sort_best_candidate(applicable_candidates)
  573: 
  574:         return BestCandidateResult(
  575:             candidates,
  576:             applicable_candidates=applicable_candidates,
  577:             best_candidate=best_candidate,
  578:         )
  579: 
  580: 
  581: class PackageFinder:
  582:     """This finds packages.
  583: 
  584:     This is meant to match easy_install's technique for looking for
  585:     packages, by reading pages and looking for appropriate links.
  586:     """
  587: 
  588:     def __init__(
  589:         self,
  590:         link_collector: LinkCollector,
  591:         target_python: TargetPython,
  592:         allow_yanked: bool,
  593:         format_control: FormatControl | None = None,
  594:         candidate_prefs: CandidatePreferences | None = None,
  595:         ignore_requires_python: bool | None = None,
  596:     ) -> None:
  597:         """
  598:         This constructor is primarily meant to be used by the create() class
  599:         method and from tests.
  600: 
  601:         :param format_control: A FormatControl object, used to control
  602:             the selection of source packages / binary packages when consulting
  603:             the index and links.
  604:         :param candidate_prefs: Options to use when creating a
  605:             CandidateEvaluator object.
  606:         """
  607:         if candidate_prefs is None:
  608:             candidate_prefs = CandidatePreferences()
  609: 
  610:         format_control = format_control or FormatControl(set(), set())
  611: 
  612:         self._allow_yanked = allow_yanked
  613:         self._candidate_prefs = candidate_prefs
  614:         self._ignore_requires_python = ignore_requires_python
  615:         self._link_collector = link_collector
  616:         self._target_python = target_python
  617: 
  618:         self.format_control = format_control
  619: 
  620:         # These are boring links that have already been logged somehow.
  621:         self._logged_links: set[tuple[Link, LinkType, str]] = set()
  622: 
  623:         # Cache of the result of finding candidates
  624:         self._all_candidates: dict[str, list[InstallationCandidate]] = {}
  625:         self._best_candidates: dict[
  626:             tuple[str, specifiers.BaseSpecifier | None, Hashes | None],
  627:             BestCandidateResult,
  628:         ] = {}
  629: 
  630:     # Don't include an allow_yanked default value to make sure each call
  631:     # site considers whether yanked releases are allowed. This also causes
  632:     # that decision to be made explicit in the calling code, which helps
  633:     # people when reading the code.
  634:     @classmethod
  635:     def create(
  636:         cls,
  637:         link_collector: LinkCollector,
  638:         selection_prefs: SelectionPreferences,
  639:         target_python: TargetPython | None = None,
  640:     ) -> PackageFinder:
  641:         """Create a PackageFinder.
  642: 
  643:         :param selection_prefs: The candidate selection preferences, as a
  644:             SelectionPreferences object.
  645:         :param target_python: The target Python interpreter to use when
  646:             checking compatibility. If None (the default), a TargetPython
  647:             object will be constructed from the running Python.
  648:         """
  649:         if target_python is None:
  650:             target_python = TargetPython()
  651: 
  652:         candidate_prefs = CandidatePreferences(
  653:             prefer_binary=selection_prefs.prefer_binary,
  654:             allow_all_prereleases=selection_prefs.allow_all_prereleases,
  655:         )
  656: 
  657:         return cls(
  658:             candidate_prefs=candidate_prefs,
  659:             link_collector=link_collector,
  660:             target_python=target_python,
  661:             allow_yanked=selection_prefs.allow_yanked,
  662:             format_control=selection_prefs.format_control,
  663:             ignore_requires_python=selection_prefs.ignore_requires_python,
  664:         )
  665: 
  666:     @property
  667:     def target_python(self) -> TargetPython:
  668:         return self._target_python
  669: 
  670:     @property
  671:     def search_scope(self) -> SearchScope:
  672:         return self._link_collector.search_scope
  673: 
  674:     @search_scope.setter
  675:     def search_scope(self, search_scope: SearchScope) -> None:
  676:         self._link_collector.search_scope = search_scope
  677: 
  678:     @property
  679:     def find_links(self) -> list[str]:
  680:         return self._link_collector.find_links
  681: 
  682:     @property
  683:     def index_urls(self) -> list[str]:
  684:         return self.search_scope.index_urls
  685: 
  686:     @property
  687:     def proxy(self) -> str | None:
  688:         return self._link_collector.session.pip_proxy
  689: 
  690:     @property
  691:     def trusted_hosts(self) -> Iterable[str]:
  692:         for host_port in self._link_collector.session.pip_trusted_origins:
  693:             yield build_netloc(*host_port)
  694: 
  695:     @property
  696:     def custom_cert(self) -> str | None:
  697:         # session.verify is either a boolean (use default bundle/no SSL
  698:         # verification) or a string path to a custom CA bundle to use. We only
  699:         # care about the latter.
  700:         verify = self._link_collector.session.verify
  701:         return verify if isinstance(verify, str) else None
  702: 
  703:     @property
  704:     def client_cert(self) -> str | None:
  705:         cert = self._link_collector.session.cert
  706:         assert not isinstance(cert, tuple), "pip only supports PEM client certs"
  707:         return cert
  708: 
  709:     @property
  710:     def allow_all_prereleases(self) -> bool:
  711:         return self._candidate_prefs.allow_all_prereleases
  712: 
  713:     def set_allow_all_prereleases(self) -> None:
  714:         self._candidate_prefs.allow_all_prereleases = True
  715: 
  716:     @property
  717:     def prefer_binary(self) -> bool:
  718:         return self._candidate_prefs.prefer_binary
  719: 
  720:     def set_prefer_binary(self) -> None:
  721:         self._candidate_prefs.prefer_binary = True
  722: 
  723:     def requires_python_skipped_reasons(self) -> list[str]:
  724:         reasons = {
  725:             detail
  726:             for _, result, detail in self._logged_links
  727:             if result == LinkType.requires_python_mismatch
  728:         }
  729:         return sorted(reasons)
  730: 
  731:     def make_link_evaluator(self, project_name: str) -> LinkEvaluator:
  732:         canonical_name = canonicalize_name(project_name)
  733:         formats = self.format_control.get_allowed_formats(canonical_name)
  734: 
  735:         return LinkEvaluator(
  736:             project_name=project_name,
  737:             canonical_name=canonical_name,
  738:             formats=formats,
  739:             target_python=self._target_python,
  740:             allow_yanked=self._allow_yanked,
  741:             ignore_requires_python=self._ignore_requires_python,
  742:         )
  743: 
  744:     def _sort_links(self, links: Iterable[Link]) -> list[Link]:
  745:         """
  746:         Returns elements of links in order, non-egg links first, egg links
  747:         second, while eliminating duplicates
  748:         """
  749:         eggs, no_eggs = [], []
  750:         seen: set[Link] = set()
  751:         for link in links:
  752:             if link not in seen:
  753:                 seen.add(link)
  754:                 if link.egg_fragment:
  755:                     eggs.append(link)
  756:                 else:
  757:                     no_eggs.append(link)
  758:         return no_eggs + eggs
  759: 
  760:     def _log_skipped_link(self, link: Link, result: LinkType, detail: str) -> None:
  761:         entry = (link, result, detail)
  762:         if entry not in self._logged_links:
  763:             # Put the link at the end so the reason is more visible and because
  764:             # the link string is usually very long.
  765:             logger.debug("Skipping link: %s: %s", detail, link)
  766:             self._logged_links.add(entry)
  767: 
  768:     def get_install_candidate(
  769:         self, link_evaluator: LinkEvaluator, link: Link
  770:     ) -> InstallationCandidate | None:
  771:         """
  772:         If the link is a candidate for install, convert it to an
  773:         InstallationCandidate and return it. Otherwise, return None.
  774:         """
  775:         result, detail = link_evaluator.evaluate_link(link)
  776:         if result != LinkType.candidate:
  777:             self._log_skipped_link(link, result, detail)
  778:             return None
  779: 
  780:         try:
  781:             return InstallationCandidate(
  782:                 name=link_evaluator.project_name,
  783:                 link=link,
  784:                 version=detail,
  785:             )
  786:         except InvalidVersion:
  787:             return None
  788: 
  789:     def evaluate_links(
  790:         self, link_evaluator: LinkEvaluator, links: Iterable[Link]
  791:     ) -> list[InstallationCandidate]:
  792:         """
  793:         Convert links that are candidates to InstallationCandidate objects.
  794:         """
  795:         candidates = []
  796:         for link in self._sort_links(links):
  797:             candidate = self.get_install_candidate(link_evaluator, link)
  798:             if candidate is not None:
  799:                 candidates.append(candidate)
  800: 
  801:         return candidates
  802: 
  803:     def process_project_url(
  804:         self, project_url: Link, link_evaluator: LinkEvaluator
  805:     ) -> list[InstallationCandidate]:
  806:         logger.debug(
  807:             "Fetching project page and analyzing links: %s",
  808:             project_url,
  809:         )
  810:         index_response = self._link_collector.fetch_response(project_url)
  811:         if index_response is None:
  812:             return []
  813: 
  814:         page_links = list(parse_links(index_response))
  815: 
  816:         with indent_log():
  817:             package_links = self.evaluate_links(
  818:                 link_evaluator,
  819:                 links=page_links,
  820:             )
  821: 
  822:         return package_links
  823: 
  824:     def find_all_candidates(self, project_name: str) -> list[InstallationCandidate]:
  825:         """Find all available InstallationCandidate for project_name
  826: 
  827:         This checks index_urls and find_links.
  828:         All versions found are returned as an InstallationCandidate list.
  829: 
  830:         See LinkEvaluator.evaluate_link() for details on which files
  831:         are accepted.
  832:         """
  833:         if project_name in self._all_candidates:
  834:             return self._all_candidates[project_name]
  835: 
  836:         link_evaluator = self.make_link_evaluator(project_name)
  837: 
  838:         collected_sources = self._link_collector.collect_sources(
  839:             project_name=project_name,
  840:             candidates_from_page=functools.partial(
  841:                 self.process_project_url,
  842:                 link_evaluator=link_evaluator,
  843:             ),
  844:         )
  845: 
  846:         page_candidates_it = itertools.chain.from_iterable(
  847:             source.page_candidates()
  848:             for sources in collected_sources
  849:             for source in sources
  850:             if source is not None
  851:         )
  852:         page_candidates = list(page_candidates_it)
  853: 
  854:         file_links_it = itertools.chain.from_iterable(
  855:             source.file_links()
  856:             for sources in collected_sources
  857:             for source in sources
  858:             if source is not None
  859:         )
  860:         file_candidates = self.evaluate_links(
  861:             link_evaluator,
  862:             sorted(file_links_it, reverse=True),
  863:         )
  864: 
  865:         if logger.isEnabledFor(logging.DEBUG) and file_candidates:
  866:             paths = []
  867:             for candidate in file_candidates:
  868:                 assert candidate.link.url  # we need to have a URL
  869:                 try:
  870:                     paths.append(candidate.link.file_path)
  871:                 except Exception:
  872:                     paths.append(candidate.link.url)  # it's not a local file
  873: 
  874:             logger.debug("Local files found: %s", ", ".join(paths))
  875: 
  876:         # This is an intentional priority ordering
  877:         self._all_candidates[project_name] = file_candidates + page_candidates
  878: 
  879:         return self._all_candidates[project_name]
  880: 
  881:     def make_candidate_evaluator(
  882:         self,
  883:         project_name: str,
  884:         specifier: specifiers.BaseSpecifier | None = None,
  885:         hashes: Hashes | None = None,
  886:     ) -> CandidateEvaluator:
  887:         """Create a CandidateEvaluator object to use."""
  888:         candidate_prefs = self._candidate_prefs
  889:         return CandidateEvaluator.create(
  890:             project_name=project_name,
  891:             target_python=self._target_python,
  892:             prefer_binary=candidate_prefs.prefer_binary,
  893:             allow_all_prereleases=candidate_prefs.allow_all_prereleases,
  894:             specifier=specifier,
  895:             hashes=hashes,
  896:         )
  897: 
  898:     def find_best_candidate(
  899:         self,
  900:         project_name: str,
  901:         specifier: specifiers.BaseSpecifier | None = None,
  902:         hashes: Hashes | None = None,
  903:     ) -> BestCandidateResult:
  904:         """Find matches for the given project and specifier.
  905: 
  906:         :param specifier: An optional object implementing `filter`
  907:             (e.g. `packaging.specifiers.SpecifierSet`) to filter applicable
  908:             versions.
  909: 
  910:         :return: A `BestCandidateResult` instance.
  911:         """
  912:         if (project_name, specifier, hashes) in self._best_candidates:
  913:             return self._best_candidates[project_name, specifier, hashes]
  914: 
  915:         candidates = self.find_all_candidates(project_name)
  916:         candidate_evaluator = self.make_candidate_evaluator(
  917:             project_name=project_name,
  918:             specifier=specifier,
  919:             hashes=hashes,
  920:         )
  921:         self._best_candidates[project_name, specifier, hashes] = (
  922:             candidate_evaluator.compute_best_candidate(candidates)
  923:         )
  924: 
  925:         return self._best_candidates[project_name, specifier, hashes]
  926: 
  927:     def find_requirement(
  928:         self, req: InstallRequirement, upgrade: bool
  929:     ) -> InstallationCandidate | None:
  930:         """Try to find a Link matching req
  931: 
  932:         Expects req, an InstallRequirement and upgrade, a boolean
  933:         Returns a InstallationCandidate if found,
  934:         Raises DistributionNotFound or BestVersionAlreadyInstalled otherwise
  935:         """
  936:         name = req.name
  937:         assert name is not None, "find_requirement() called with no name"
  938: 
  939:         hashes = req.hashes(trust_internet=False)
  940:         best_candidate_result = self.find_best_candidate(
  941:             name,
  942:             specifier=req.specifier,
  943:             hashes=hashes,
  944:         )
  945:         best_candidate = best_candidate_result.best_candidate
  946: 
  947:         installed_version: _BaseVersion | None = None
  948:         if req.satisfied_by is not None:
  949:             installed_version = req.satisfied_by.version
  950: 
  951:         def _format_versions(cand_iter: Iterable[InstallationCandidate]) -> str:
  952:             # This repeated parse_version and str() conversion is needed to
  953:             # handle different vendoring sources from pip and pkg_resources.
  954:             # If we stop using the pkg_resources provided specifier and start
  955:             # using our own, we can drop the cast to str().
  956:             return (
  957:                 ", ".join(
  958:                     sorted(
  959:                         {str(c.version) for c in cand_iter},
  960:                         key=parse_version,
  961:                     )
  962:                 )
  963:                 or "none"
  964:             )
  965: 
  966:         if installed_version is None and best_candidate is None:
  967:             logger.critical(
  968:                 "Could not find a version that satisfies the requirement %s "
  969:                 "(from versions: %s)",
  970:                 req,
  971:                 _format_versions(best_candidate_result.all_candidates),
  972:             )
  973: 
  974:             raise DistributionNotFound(f"No matching distribution found for {req}")
  975: 
  976:         def _should_install_candidate(
  977:             candidate: InstallationCandidate | None,
  978:         ) -> TypeGuard[InstallationCandidate]:
  979:             if installed_version is None:
  980:                 return True
  981:             if best_candidate is None:
  982:                 return False
  983:             return best_candidate.version > installed_version
  984: 
  985:         if not upgrade and installed_version is not None:
  986:             if _should_install_candidate(best_candidate):
  987:                 logger.debug(
  988:                     "Existing installed version (%s) satisfies requirement "
  989:                     "(most up-to-date version is %s)",
  990:                     installed_version,
  991:                     best_candidate.version,
  992:                 )
  993:             else:
  994:                 logger.debug(
  995:                     "Existing installed version (%s) is most up-to-date and "
  996:                     "satisfies requirement",
  997:                     installed_version,
  998:                 )
  999:             return None
 1000: 
 1001:         if _should_install_candidate(best_candidate):
 1002:             logger.debug(
 1003:                 "Using version %s (newest of versions: %s)",
 1004:                 best_candidate.version,
 1005:                 _format_versions(best_candidate_result.applicable_candidates),
 1006:             )
 1007:             return best_candidate
 1008: 
 1009:         # We have an existing version, and its the best version
 1010:         logger.debug(
 1011:             "Installed version (%s) is most up-to-date (past versions: %s)",
 1012:             installed_version,
 1013:             _format_versions(best_candidate_result.applicable_candidates),
 1014:         )
 1015:         raise BestVersionAlreadyInstalled
 1016: 
 1017: 
 1018: def _find_name_version_sep(fragment: str, canonical_name: str) -> int:
 1019:     """Find the separator's index based on the package's canonical name.
 1020: 
 1021:     :param fragment: A <package>+<version> filename "fragment" (stem) or
 1022:         egg fragment.
 1023:     :param canonical_name: The package's canonical name.
 1024: 
 1025:     This function is needed since the canonicalized name does not necessarily
 1026:     have the same length as the egg info's name part. An example::
 1027: 
 1028:     >>> fragment = 'foo__bar-1.0'
 1029:     >>> canonical_name = 'foo-bar'
 1030:     >>> _find_name_version_sep(fragment, canonical_name)
 1031:     8
 1032:     """
 1033:     # Project name and version must be separated by one single dash. Find all
 1034:     # occurrences of dashes; if the string in front of it matches the canonical
 1035:     # name, this is the one separating the name and version parts.
 1036:     for i, c in enumerate(fragment):
 1037:         if c != "-":
 1038:             continue
 1039:         if canonicalize_name(fragment[:i]) == canonical_name:
 1040:             return i
 1041:     raise ValueError(f"{fragment} does not match {canonical_name}")
 1042: 
 1043: 
 1044: def _extract_version_from_fragment(fragment: str, canonical_name: str) -> str | None:
 1045:     """Parse the version string from a <package>+<version> filename
 1046:     "fragment" (stem) or egg fragment.
 1047: 
 1048:     :param fragment: The string to parse. E.g. foo-2.1
 1049:     :param canonical_name: The canonicalized name of the package this
 1050:         belongs to.
 1051:     """
 1052:     try:
 1053:         version_start = _find_name_version_sep(fragment, canonical_name) + 1
 1054:     except ValueError:
 1055:         return None
 1056:     version = fragment[version_start:]
 1057:     if not version:
 1058:         return None
 1059:     return version
