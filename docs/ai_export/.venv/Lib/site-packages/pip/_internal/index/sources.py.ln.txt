    1: from __future__ import annotations
    2: 
    3: import logging
    4: import mimetypes
    5: import os
    6: from collections import defaultdict
    7: from collections.abc import Iterable
    8: from typing import Callable
    9: 
   10: from pip._vendor.packaging.utils import (
   11:     InvalidSdistFilename,
   12:     InvalidWheelFilename,
   13:     canonicalize_name,
   14:     parse_sdist_filename,
   15:     parse_wheel_filename,
   16: )
   17: 
   18: from pip._internal.models.candidate import InstallationCandidate
   19: from pip._internal.models.link import Link
   20: from pip._internal.utils.urls import path_to_url, url_to_path
   21: from pip._internal.vcs import is_url
   22: 
   23: logger = logging.getLogger(__name__)
   24: 
   25: FoundCandidates = Iterable[InstallationCandidate]
   26: FoundLinks = Iterable[Link]
   27: CandidatesFromPage = Callable[[Link], Iterable[InstallationCandidate]]
   28: PageValidator = Callable[[Link], bool]
   29: 
   30: 
   31: class LinkSource:
   32:     @property
   33:     def link(self) -> Link | None:
   34:         """Returns the underlying link, if there's one."""
   35:         raise NotImplementedError()
   36: 
   37:     def page_candidates(self) -> FoundCandidates:
   38:         """Candidates found by parsing an archive listing HTML file."""
   39:         raise NotImplementedError()
   40: 
   41:     def file_links(self) -> FoundLinks:
   42:         """Links found by specifying archives directly."""
   43:         raise NotImplementedError()
   44: 
   45: 
   46: def _is_html_file(file_url: str) -> bool:
   47:     return mimetypes.guess_type(file_url, strict=False)[0] == "text/html"
   48: 
   49: 
   50: class _FlatDirectoryToUrls:
   51:     """Scans directory and caches results"""
   52: 
   53:     def __init__(self, path: str) -> None:
   54:         self._path = path
   55:         self._page_candidates: list[str] = []
   56:         self._project_name_to_urls: dict[str, list[str]] = defaultdict(list)
   57:         self._scanned_directory = False
   58: 
   59:     def _scan_directory(self) -> None:
   60:         """Scans directory once and populates both page_candidates
   61:         and project_name_to_urls at the same time
   62:         """
   63:         for entry in os.scandir(self._path):
   64:             url = path_to_url(entry.path)
   65:             if _is_html_file(url):
   66:                 self._page_candidates.append(url)
   67:                 continue
   68: 
   69:             # File must have a valid wheel or sdist name,
   70:             # otherwise not worth considering as a package
   71:             try:
   72:                 project_filename = parse_wheel_filename(entry.name)[0]
   73:             except InvalidWheelFilename:
   74:                 try:
   75:                     project_filename = parse_sdist_filename(entry.name)[0]
   76:                 except InvalidSdistFilename:
   77:                     continue
   78: 
   79:             self._project_name_to_urls[project_filename].append(url)
   80:         self._scanned_directory = True
   81: 
   82:     @property
   83:     def page_candidates(self) -> list[str]:
   84:         if not self._scanned_directory:
   85:             self._scan_directory()
   86: 
   87:         return self._page_candidates
   88: 
   89:     @property
   90:     def project_name_to_urls(self) -> dict[str, list[str]]:
   91:         if not self._scanned_directory:
   92:             self._scan_directory()
   93: 
   94:         return self._project_name_to_urls
   95: 
   96: 
   97: class _FlatDirectorySource(LinkSource):
   98:     """Link source specified by ``--find-links=<path-to-dir>``.
   99: 
  100:     This looks the content of the directory, and returns:
  101: 
  102:     * ``page_candidates``: Links listed on each HTML file in the directory.
  103:     * ``file_candidates``: Archives in the directory.
  104:     """
  105: 
  106:     _paths_to_urls: dict[str, _FlatDirectoryToUrls] = {}
  107: 
  108:     def __init__(
  109:         self,
  110:         candidates_from_page: CandidatesFromPage,
  111:         path: str,
  112:         project_name: str,
  113:     ) -> None:
  114:         self._candidates_from_page = candidates_from_page
  115:         self._project_name = canonicalize_name(project_name)
  116: 
  117:         # Get existing instance of _FlatDirectoryToUrls if it exists
  118:         if path in self._paths_to_urls:
  119:             self._path_to_urls = self._paths_to_urls[path]
  120:         else:
  121:             self._path_to_urls = _FlatDirectoryToUrls(path=path)
  122:             self._paths_to_urls[path] = self._path_to_urls
  123: 
  124:     @property
  125:     def link(self) -> Link | None:
  126:         return None
  127: 
  128:     def page_candidates(self) -> FoundCandidates:
  129:         for url in self._path_to_urls.page_candidates:
  130:             yield from self._candidates_from_page(Link(url))
  131: 
  132:     def file_links(self) -> FoundLinks:
  133:         for url in self._path_to_urls.project_name_to_urls[self._project_name]:
  134:             yield Link(url)
  135: 
  136: 
  137: class _LocalFileSource(LinkSource):
  138:     """``--find-links=<path-or-url>`` or ``--[extra-]index-url=<path-or-url>``.
  139: 
  140:     If a URL is supplied, it must be a ``file:`` URL. If a path is supplied to
  141:     the option, it is converted to a URL first. This returns:
  142: 
  143:     * ``page_candidates``: Links listed on an HTML file.
  144:     * ``file_candidates``: The non-HTML file.
  145:     """
  146: 
  147:     def __init__(
  148:         self,
  149:         candidates_from_page: CandidatesFromPage,
  150:         link: Link,
  151:     ) -> None:
  152:         self._candidates_from_page = candidates_from_page
  153:         self._link = link
  154: 
  155:     @property
  156:     def link(self) -> Link | None:
  157:         return self._link
  158: 
  159:     def page_candidates(self) -> FoundCandidates:
  160:         if not _is_html_file(self._link.url):
  161:             return
  162:         yield from self._candidates_from_page(self._link)
  163: 
  164:     def file_links(self) -> FoundLinks:
  165:         if _is_html_file(self._link.url):
  166:             return
  167:         yield self._link
  168: 
  169: 
  170: class _RemoteFileSource(LinkSource):
  171:     """``--find-links=<url>`` or ``--[extra-]index-url=<url>``.
  172: 
  173:     This returns:
  174: 
  175:     * ``page_candidates``: Links listed on an HTML file.
  176:     * ``file_candidates``: The non-HTML file.
  177:     """
  178: 
  179:     def __init__(
  180:         self,
  181:         candidates_from_page: CandidatesFromPage,
  182:         page_validator: PageValidator,
  183:         link: Link,
  184:     ) -> None:
  185:         self._candidates_from_page = candidates_from_page
  186:         self._page_validator = page_validator
  187:         self._link = link
  188: 
  189:     @property
  190:     def link(self) -> Link | None:
  191:         return self._link
  192: 
  193:     def page_candidates(self) -> FoundCandidates:
  194:         if not self._page_validator(self._link):
  195:             return
  196:         yield from self._candidates_from_page(self._link)
  197: 
  198:     def file_links(self) -> FoundLinks:
  199:         yield self._link
  200: 
  201: 
  202: class _IndexDirectorySource(LinkSource):
  203:     """``--[extra-]index-url=<path-to-directory>``.
  204: 
  205:     This is treated like a remote URL; ``candidates_from_page`` contains logic
  206:     for this by appending ``index.html`` to the link.
  207:     """
  208: 
  209:     def __init__(
  210:         self,
  211:         candidates_from_page: CandidatesFromPage,
  212:         link: Link,
  213:     ) -> None:
  214:         self._candidates_from_page = candidates_from_page
  215:         self._link = link
  216: 
  217:     @property
  218:     def link(self) -> Link | None:
  219:         return self._link
  220: 
  221:     def page_candidates(self) -> FoundCandidates:
  222:         yield from self._candidates_from_page(self._link)
  223: 
  224:     def file_links(self) -> FoundLinks:
  225:         return ()
  226: 
  227: 
  228: def build_source(
  229:     location: str,
  230:     *,
  231:     candidates_from_page: CandidatesFromPage,
  232:     page_validator: PageValidator,
  233:     expand_dir: bool,
  234:     cache_link_parsing: bool,
  235:     project_name: str,
  236: ) -> tuple[str | None, LinkSource | None]:
  237:     path: str | None = None
  238:     url: str | None = None
  239:     if os.path.exists(location):  # Is a local path.
  240:         url = path_to_url(location)
  241:         path = location
  242:     elif location.startswith("file:"):  # A file: URL.
  243:         url = location
  244:         path = url_to_path(location)
  245:     elif is_url(location):
  246:         url = location
  247: 
  248:     if url is None:
  249:         msg = (
  250:             "Location '%s' is ignored: "
  251:             "it is either a non-existing path or lacks a specific scheme."
  252:         )
  253:         logger.warning(msg, location)
  254:         return (None, None)
  255: 
  256:     if path is None:
  257:         source: LinkSource = _RemoteFileSource(
  258:             candidates_from_page=candidates_from_page,
  259:             page_validator=page_validator,
  260:             link=Link(url, cache_link_parsing=cache_link_parsing),
  261:         )
  262:         return (url, source)
  263: 
  264:     if os.path.isdir(path):
  265:         if expand_dir:
  266:             source = _FlatDirectorySource(
  267:                 candidates_from_page=candidates_from_page,
  268:                 path=path,
  269:                 project_name=project_name,
  270:             )
  271:         else:
  272:             source = _IndexDirectorySource(
  273:                 candidates_from_page=candidates_from_page,
  274:                 link=Link(url, cache_link_parsing=cache_link_parsing),
  275:             )
  276:         return (url, source)
  277:     elif os.path.isfile(path):
  278:         source = _LocalFileSource(
  279:             candidates_from_page=candidates_from_page,
  280:             link=Link(url, cache_link_parsing=cache_link_parsing),
  281:         )
  282:         return (url, source)
  283:     logger.warning(
  284:         "Location '%s' is ignored: it is neither a file nor a directory.",
  285:         location,
  286:     )
  287:     return (url, None)
