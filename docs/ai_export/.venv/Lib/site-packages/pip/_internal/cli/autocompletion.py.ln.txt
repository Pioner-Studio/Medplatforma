    1: """Logic that powers autocompletion installed by ``pip completion``."""
    2: 
    3: from __future__ import annotations
    4: 
    5: import optparse
    6: import os
    7: import sys
    8: from collections.abc import Iterable
    9: from itertools import chain
   10: from typing import Any
   11: 
   12: from pip._internal.cli.main_parser import create_main_parser
   13: from pip._internal.commands import commands_dict, create_command
   14: from pip._internal.metadata import get_default_environment
   15: 
   16: 
   17: def autocomplete() -> None:
   18:     """Entry Point for completion of main and subcommand options."""
   19:     # Don't complete if user hasn't sourced bash_completion file.
   20:     if "PIP_AUTO_COMPLETE" not in os.environ:
   21:         return
   22:     # Don't complete if autocompletion environment variables
   23:     # are not present
   24:     if not os.environ.get("COMP_WORDS") or not os.environ.get("COMP_CWORD"):
   25:         return
   26:     cwords = os.environ["COMP_WORDS"].split()[1:]
   27:     cword = int(os.environ["COMP_CWORD"])
   28:     try:
   29:         current = cwords[cword - 1]
   30:     except IndexError:
   31:         current = ""
   32: 
   33:     parser = create_main_parser()
   34:     subcommands = list(commands_dict)
   35:     options = []
   36: 
   37:     # subcommand
   38:     subcommand_name: str | None = None
   39:     for word in cwords:
   40:         if word in subcommands:
   41:             subcommand_name = word
   42:             break
   43:     # subcommand options
   44:     if subcommand_name is not None:
   45:         # special case: 'help' subcommand has no options
   46:         if subcommand_name == "help":
   47:             sys.exit(1)
   48:         # special case: list locally installed dists for show and uninstall
   49:         should_list_installed = not current.startswith("-") and subcommand_name in [
   50:             "show",
   51:             "uninstall",
   52:         ]
   53:         if should_list_installed:
   54:             env = get_default_environment()
   55:             lc = current.lower()
   56:             installed = [
   57:                 dist.canonical_name
   58:                 for dist in env.iter_installed_distributions(local_only=True)
   59:                 if dist.canonical_name.startswith(lc)
   60:                 and dist.canonical_name not in cwords[1:]
   61:             ]
   62:             # if there are no dists installed, fall back to option completion
   63:             if installed:
   64:                 for dist in installed:
   65:                     print(dist)
   66:                 sys.exit(1)
   67: 
   68:         should_list_installables = (
   69:             not current.startswith("-") and subcommand_name == "install"
   70:         )
   71:         if should_list_installables:
   72:             for path in auto_complete_paths(current, "path"):
   73:                 print(path)
   74:             sys.exit(1)
   75: 
   76:         subcommand = create_command(subcommand_name)
   77: 
   78:         for opt in subcommand.parser.option_list_all:
   79:             if opt.help != optparse.SUPPRESS_HELP:
   80:                 options += [
   81:                     (opt_str, opt.nargs) for opt_str in opt._long_opts + opt._short_opts
   82:                 ]
   83: 
   84:         # filter out previously specified options from available options
   85:         prev_opts = [x.split("=")[0] for x in cwords[1 : cword - 1]]
   86:         options = [(x, v) for (x, v) in options if x not in prev_opts]
   87:         # filter options by current input
   88:         options = [(k, v) for k, v in options if k.startswith(current)]
   89:         # get completion type given cwords and available subcommand options
   90:         completion_type = get_path_completion_type(
   91:             cwords,
   92:             cword,
   93:             subcommand.parser.option_list_all,
   94:         )
   95:         # get completion files and directories if ``completion_type`` is
   96:         # ``<file>``, ``<dir>`` or ``<path>``
   97:         if completion_type:
   98:             paths = auto_complete_paths(current, completion_type)
   99:             options = [(path, 0) for path in paths]
  100:         for option in options:
  101:             opt_label = option[0]
  102:             # append '=' to options which require args
  103:             if option[1] and option[0][:2] == "--":
  104:                 opt_label += "="
  105:             print(opt_label)
  106: 
  107:         # Complete sub-commands (unless one is already given).
  108:         if not any(name in cwords for name in subcommand.handler_map()):
  109:             for handler_name in subcommand.handler_map():
  110:                 if handler_name.startswith(current):
  111:                     print(handler_name)
  112:     else:
  113:         # show main parser options only when necessary
  114: 
  115:         opts = [i.option_list for i in parser.option_groups]
  116:         opts.append(parser.option_list)
  117:         flattened_opts = chain.from_iterable(opts)
  118:         if current.startswith("-"):
  119:             for opt in flattened_opts:
  120:                 if opt.help != optparse.SUPPRESS_HELP:
  121:                     subcommands += opt._long_opts + opt._short_opts
  122:         else:
  123:             # get completion type given cwords and all available options
  124:             completion_type = get_path_completion_type(cwords, cword, flattened_opts)
  125:             if completion_type:
  126:                 subcommands = list(auto_complete_paths(current, completion_type))
  127: 
  128:         print(" ".join([x for x in subcommands if x.startswith(current)]))
  129:     sys.exit(1)
  130: 
  131: 
  132: def get_path_completion_type(
  133:     cwords: list[str], cword: int, opts: Iterable[Any]
  134: ) -> str | None:
  135:     """Get the type of path completion (``file``, ``dir``, ``path`` or None)
  136: 
  137:     :param cwords: same as the environmental variable ``COMP_WORDS``
  138:     :param cword: same as the environmental variable ``COMP_CWORD``
  139:     :param opts: The available options to check
  140:     :return: path completion type (``file``, ``dir``, ``path`` or None)
  141:     """
  142:     if cword < 2 or not cwords[cword - 2].startswith("-"):
  143:         return None
  144:     for opt in opts:
  145:         if opt.help == optparse.SUPPRESS_HELP:
  146:             continue
  147:         for o in str(opt).split("/"):
  148:             if cwords[cword - 2].split("=")[0] == o:
  149:                 if not opt.metavar or any(
  150:                     x in ("path", "file", "dir") for x in opt.metavar.split("/")
  151:                 ):
  152:                     return opt.metavar
  153:     return None
  154: 
  155: 
  156: def auto_complete_paths(current: str, completion_type: str) -> Iterable[str]:
  157:     """If ``completion_type`` is ``file`` or ``path``, list all regular files
  158:     and directories starting with ``current``; otherwise only list directories
  159:     starting with ``current``.
  160: 
  161:     :param current: The word to be completed
  162:     :param completion_type: path completion type(``file``, ``path`` or ``dir``)
  163:     :return: A generator of regular files and/or directories
  164:     """
  165:     directory, filename = os.path.split(current)
  166:     current_path = os.path.abspath(directory)
  167:     # Don't complete paths if they can't be accessed
  168:     if not os.access(current_path, os.R_OK):
  169:         return
  170:     filename = os.path.normcase(filename)
  171:     # list all files that start with ``filename``
  172:     file_list = (
  173:         x for x in os.listdir(current_path) if os.path.normcase(x).startswith(filename)
  174:     )
  175:     for f in file_list:
  176:         opt = os.path.join(current_path, f)
  177:         comp_file = os.path.normcase(os.path.join(directory, f))
  178:         # complete regular files when there is not ``<dir>`` after option
  179:         # complete directories when there is ``<file>``, ``<path>`` or
  180:         # ``<dir>``after option
  181:         if completion_type != "dir" and os.path.isfile(opt):
  182:             yield comp_file
  183:         elif os.path.isdir(opt):
  184:             yield os.path.join(comp_file, "")
