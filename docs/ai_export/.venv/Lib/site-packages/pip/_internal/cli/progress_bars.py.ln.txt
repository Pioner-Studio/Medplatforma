    1: from __future__ import annotations
    2: 
    3: import functools
    4: import sys
    5: from collections.abc import Generator, Iterable, Iterator
    6: from typing import Callable, Literal, TypeVar
    7: 
    8: from pip._vendor.rich.progress import (
    9:     BarColumn,
   10:     DownloadColumn,
   11:     FileSizeColumn,
   12:     MofNCompleteColumn,
   13:     Progress,
   14:     ProgressColumn,
   15:     SpinnerColumn,
   16:     TextColumn,
   17:     TimeElapsedColumn,
   18:     TimeRemainingColumn,
   19:     TransferSpeedColumn,
   20: )
   21: 
   22: from pip._internal.cli.spinners import RateLimiter
   23: from pip._internal.req.req_install import InstallRequirement
   24: from pip._internal.utils.logging import get_console, get_indentation
   25: 
   26: T = TypeVar("T")
   27: ProgressRenderer = Callable[[Iterable[T]], Iterator[T]]
   28: BarType = Literal["on", "off", "raw"]
   29: 
   30: 
   31: def _rich_download_progress_bar(
   32:     iterable: Iterable[bytes],
   33:     *,
   34:     bar_type: BarType,
   35:     size: int | None,
   36:     initial_progress: int | None = None,
   37: ) -> Generator[bytes, None, None]:
   38:     assert bar_type == "on", "This should only be used in the default mode."
   39: 
   40:     if not size:
   41:         total = float("inf")
   42:         columns: tuple[ProgressColumn, ...] = (
   43:             TextColumn("[progress.description]{task.description}"),
   44:             SpinnerColumn("line", speed=1.5),
   45:             FileSizeColumn(),
   46:             TransferSpeedColumn(),
   47:             TimeElapsedColumn(),
   48:         )
   49:     else:
   50:         total = size
   51:         columns = (
   52:             TextColumn("[progress.description]{task.description}"),
   53:             BarColumn(),
   54:             DownloadColumn(),
   55:             TransferSpeedColumn(),
   56:             TextColumn("{task.fields[time_description]}"),
   57:             TimeRemainingColumn(elapsed_when_finished=True),
   58:         )
   59: 
   60:     progress = Progress(*columns, refresh_per_second=5)
   61:     task_id = progress.add_task(
   62:         " " * (get_indentation() + 2), total=total, time_description="eta"
   63:     )
   64:     if initial_progress is not None:
   65:         progress.update(task_id, advance=initial_progress)
   66:     with progress:
   67:         for chunk in iterable:
   68:             yield chunk
   69:             progress.update(task_id, advance=len(chunk))
   70:         progress.update(task_id, time_description="")
   71: 
   72: 
   73: def _rich_install_progress_bar(
   74:     iterable: Iterable[InstallRequirement], *, total: int
   75: ) -> Iterator[InstallRequirement]:
   76:     columns = (
   77:         TextColumn("{task.fields[indent]}"),
   78:         BarColumn(),
   79:         MofNCompleteColumn(),
   80:         TextColumn("{task.description}"),
   81:     )
   82:     console = get_console()
   83: 
   84:     bar = Progress(*columns, refresh_per_second=6, console=console, transient=True)
   85:     # Hiding the progress bar at initialization forces a refresh cycle to occur
   86:     # until the bar appears, avoiding very short flashes.
   87:     task = bar.add_task("", total=total, indent=" " * get_indentation(), visible=False)
   88:     with bar:
   89:         for req in iterable:
   90:             bar.update(task, description=rf"\[{req.name}]", visible=True)
   91:             yield req
   92:             bar.advance(task)
   93: 
   94: 
   95: def _raw_progress_bar(
   96:     iterable: Iterable[bytes],
   97:     *,
   98:     size: int | None,
   99:     initial_progress: int | None = None,
  100: ) -> Generator[bytes, None, None]:
  101:     def write_progress(current: int, total: int) -> None:
  102:         sys.stdout.write(f"Progress {current} of {total}\n")
  103:         sys.stdout.flush()
  104: 
  105:     current = initial_progress or 0
  106:     total = size or 0
  107:     rate_limiter = RateLimiter(0.25)
  108: 
  109:     write_progress(current, total)
  110:     for chunk in iterable:
  111:         current += len(chunk)
  112:         if rate_limiter.ready() or current == total:
  113:             write_progress(current, total)
  114:             rate_limiter.reset()
  115:         yield chunk
  116: 
  117: 
  118: def get_download_progress_renderer(
  119:     *, bar_type: BarType, size: int | None = None, initial_progress: int | None = None
  120: ) -> ProgressRenderer[bytes]:
  121:     """Get an object that can be used to render the download progress.
  122: 
  123:     Returns a callable, that takes an iterable to "wrap".
  124:     """
  125:     if bar_type == "on":
  126:         return functools.partial(
  127:             _rich_download_progress_bar,
  128:             bar_type=bar_type,
  129:             size=size,
  130:             initial_progress=initial_progress,
  131:         )
  132:     elif bar_type == "raw":
  133:         return functools.partial(
  134:             _raw_progress_bar,
  135:             size=size,
  136:             initial_progress=initial_progress,
  137:         )
  138:     else:
  139:         return iter  # no-op, when passed an iterator
  140: 
  141: 
  142: def get_install_progress_renderer(
  143:     *, bar_type: BarType, total: int
  144: ) -> ProgressRenderer[InstallRequirement]:
  145:     """Get an object that can be used to render the install progress.
  146:     Returns a callable, that takes an iterable to "wrap".
  147:     """
  148:     if bar_type == "on":
  149:         return functools.partial(_rich_install_progress_bar, total=total)
  150:     else:
  151:         return iter
