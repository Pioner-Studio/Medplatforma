    1: """A single place for constructing and exposing the main parser"""
    2: 
    3: from __future__ import annotations
    4: 
    5: import os
    6: import subprocess
    7: import sys
    8: 
    9: from pip._internal.build_env import get_runnable_pip
   10: from pip._internal.cli import cmdoptions
   11: from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
   12: from pip._internal.commands import commands_dict, get_similar_commands
   13: from pip._internal.exceptions import CommandError
   14: from pip._internal.utils.misc import get_pip_version, get_prog
   15: 
   16: __all__ = ["create_main_parser", "parse_command"]
   17: 
   18: 
   19: def create_main_parser() -> ConfigOptionParser:
   20:     """Creates and returns the main parser for pip's CLI"""
   21: 
   22:     parser = ConfigOptionParser(
   23:         usage="\n%prog <command> [options]",
   24:         add_help_option=False,
   25:         formatter=UpdatingDefaultsHelpFormatter(),
   26:         name="global",
   27:         prog=get_prog(),
   28:     )
   29:     parser.disable_interspersed_args()
   30: 
   31:     parser.version = get_pip_version()
   32: 
   33:     # add the general options
   34:     gen_opts = cmdoptions.make_option_group(cmdoptions.general_group, parser)
   35:     parser.add_option_group(gen_opts)
   36: 
   37:     # so the help formatter knows
   38:     parser.main = True  # type: ignore
   39: 
   40:     # create command listing for description
   41:     description = [""] + [
   42:         f"{name:27} {command_info.summary}"
   43:         for name, command_info in commands_dict.items()
   44:     ]
   45:     parser.description = "\n".join(description)
   46: 
   47:     return parser
   48: 
   49: 
   50: def identify_python_interpreter(python: str) -> str | None:
   51:     # If the named file exists, use it.
   52:     # If it's a directory, assume it's a virtual environment and
   53:     # look for the environment's Python executable.
   54:     if os.path.exists(python):
   55:         if os.path.isdir(python):
   56:             # bin/python for Unix, Scripts/python.exe for Windows
   57:             # Try both in case of odd cases like cygwin.
   58:             for exe in ("bin/python", "Scripts/python.exe"):
   59:                 py = os.path.join(python, exe)
   60:                 if os.path.exists(py):
   61:                     return py
   62:         else:
   63:             return python
   64: 
   65:     # Could not find the interpreter specified
   66:     return None
   67: 
   68: 
   69: def parse_command(args: list[str]) -> tuple[str, list[str]]:
   70:     parser = create_main_parser()
   71: 
   72:     # Note: parser calls disable_interspersed_args(), so the result of this
   73:     # call is to split the initial args into the general options before the
   74:     # subcommand and everything else.
   75:     # For example:
   76:     #  args: ['--timeout=5', 'install', '--user', 'INITools']
   77:     #  general_options: ['--timeout==5']
   78:     #  args_else: ['install', '--user', 'INITools']
   79:     general_options, args_else = parser.parse_args(args)
   80: 
   81:     # --python
   82:     if general_options.python and "_PIP_RUNNING_IN_SUBPROCESS" not in os.environ:
   83:         # Re-invoke pip using the specified Python interpreter
   84:         interpreter = identify_python_interpreter(general_options.python)
   85:         if interpreter is None:
   86:             raise CommandError(
   87:                 f"Could not locate Python interpreter {general_options.python}"
   88:             )
   89: 
   90:         pip_cmd = [
   91:             interpreter,
   92:             get_runnable_pip(),
   93:         ]
   94:         pip_cmd.extend(args)
   95: 
   96:         # Set a flag so the child doesn't re-invoke itself, causing
   97:         # an infinite loop.
   98:         os.environ["_PIP_RUNNING_IN_SUBPROCESS"] = "1"
   99:         returncode = 0
  100:         try:
  101:             proc = subprocess.run(pip_cmd)
  102:             returncode = proc.returncode
  103:         except (subprocess.SubprocessError, OSError) as exc:
  104:             raise CommandError(f"Failed to run pip under {interpreter}: {exc}")
  105:         sys.exit(returncode)
  106: 
  107:     # --version
  108:     if general_options.version:
  109:         sys.stdout.write(parser.version)
  110:         sys.stdout.write(os.linesep)
  111:         sys.exit()
  112: 
  113:     # pip || pip help -> print_help()
  114:     if not args_else or (args_else[0] == "help" and len(args_else) == 1):
  115:         parser.print_help()
  116:         sys.exit()
  117: 
  118:     # the subcommand name
  119:     cmd_name = args_else[0]
  120: 
  121:     if cmd_name not in commands_dict:
  122:         guess = get_similar_commands(cmd_name)
  123: 
  124:         msg = [f'unknown command "{cmd_name}"']
  125:         if guess:
  126:             msg.append(f'maybe you meant "{guess}"')
  127: 
  128:         raise CommandError(" - ".join(msg))
  129: 
  130:     # all the args without the subcommand
  131:     cmd_args = args[:]
  132:     cmd_args.remove(cmd_name)
  133: 
  134:     return cmd_name, cmd_args
