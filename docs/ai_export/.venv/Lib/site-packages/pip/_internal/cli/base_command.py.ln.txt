    1: """Base Command class, and related routines"""
    2: 
    3: from __future__ import annotations
    4: 
    5: import logging
    6: import logging.config
    7: import optparse
    8: import os
    9: import sys
   10: import traceback
   11: from optparse import Values
   12: from typing import Callable
   13: 
   14: from pip._vendor.rich import reconfigure
   15: from pip._vendor.rich import traceback as rich_traceback
   16: 
   17: from pip._internal.cli import cmdoptions
   18: from pip._internal.cli.command_context import CommandContextMixIn
   19: from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
   20: from pip._internal.cli.status_codes import (
   21:     ERROR,
   22:     PREVIOUS_BUILD_DIR_ERROR,
   23:     UNKNOWN_ERROR,
   24:     VIRTUALENV_NOT_FOUND,
   25: )
   26: from pip._internal.exceptions import (
   27:     BadCommand,
   28:     CommandError,
   29:     DiagnosticPipError,
   30:     InstallationError,
   31:     NetworkConnectionError,
   32:     PreviousBuildDirError,
   33: )
   34: from pip._internal.utils.filesystem import check_path_owner
   35: from pip._internal.utils.logging import BrokenStdoutLoggingError, setup_logging
   36: from pip._internal.utils.misc import get_prog, normalize_path
   37: from pip._internal.utils.temp_dir import TempDirectoryTypeRegistry as TempDirRegistry
   38: from pip._internal.utils.temp_dir import global_tempdir_manager, tempdir_registry
   39: from pip._internal.utils.virtualenv import running_under_virtualenv
   40: 
   41: __all__ = ["Command"]
   42: 
   43: logger = logging.getLogger(__name__)
   44: 
   45: 
   46: class Command(CommandContextMixIn):
   47:     usage: str = ""
   48:     ignore_require_venv: bool = False
   49: 
   50:     def __init__(self, name: str, summary: str, isolated: bool = False) -> None:
   51:         super().__init__()
   52: 
   53:         self.name = name
   54:         self.summary = summary
   55:         self.parser = ConfigOptionParser(
   56:             usage=self.usage,
   57:             prog=f"{get_prog()} {name}",
   58:             formatter=UpdatingDefaultsHelpFormatter(),
   59:             add_help_option=False,
   60:             name=name,
   61:             description=self.__doc__,
   62:             isolated=isolated,
   63:         )
   64: 
   65:         self.tempdir_registry: TempDirRegistry | None = None
   66: 
   67:         # Commands should add options to this option group
   68:         optgroup_name = f"{self.name.capitalize()} Options"
   69:         self.cmd_opts = optparse.OptionGroup(self.parser, optgroup_name)
   70: 
   71:         # Add the general options
   72:         gen_opts = cmdoptions.make_option_group(
   73:             cmdoptions.general_group,
   74:             self.parser,
   75:         )
   76:         self.parser.add_option_group(gen_opts)
   77: 
   78:         self.add_options()
   79: 
   80:     def add_options(self) -> None:
   81:         pass
   82: 
   83:     def handle_pip_version_check(self, options: Values) -> None:
   84:         """
   85:         This is a no-op so that commands by default do not do the pip version
   86:         check.
   87:         """
   88:         # Make sure we do the pip version check if the index_group options
   89:         # are present.
   90:         assert not hasattr(options, "no_index")
   91: 
   92:     def run(self, options: Values, args: list[str]) -> int:
   93:         raise NotImplementedError
   94: 
   95:     def _run_wrapper(self, level_number: int, options: Values, args: list[str]) -> int:
   96:         def _inner_run() -> int:
   97:             try:
   98:                 return self.run(options, args)
   99:             finally:
  100:                 self.handle_pip_version_check(options)
  101: 
  102:         if options.debug_mode:
  103:             rich_traceback.install(show_locals=True)
  104:             return _inner_run()
  105: 
  106:         try:
  107:             status = _inner_run()
  108:             assert isinstance(status, int)
  109:             return status
  110:         except DiagnosticPipError as exc:
  111:             logger.error("%s", exc, extra={"rich": True})
  112:             logger.debug("Exception information:", exc_info=True)
  113: 
  114:             return ERROR
  115:         except PreviousBuildDirError as exc:
  116:             logger.critical(str(exc))
  117:             logger.debug("Exception information:", exc_info=True)
  118: 
  119:             return PREVIOUS_BUILD_DIR_ERROR
  120:         except (
  121:             InstallationError,
  122:             BadCommand,
  123:             NetworkConnectionError,
  124:         ) as exc:
  125:             logger.critical(str(exc))
  126:             logger.debug("Exception information:", exc_info=True)
  127: 
  128:             return ERROR
  129:         except CommandError as exc:
  130:             logger.critical("%s", exc)
  131:             logger.debug("Exception information:", exc_info=True)
  132: 
  133:             return ERROR
  134:         except BrokenStdoutLoggingError:
  135:             # Bypass our logger and write any remaining messages to
  136:             # stderr because stdout no longer works.
  137:             print("ERROR: Pipe to stdout was broken", file=sys.stderr)
  138:             if level_number <= logging.DEBUG:
  139:                 traceback.print_exc(file=sys.stderr)
  140: 
  141:             return ERROR
  142:         except KeyboardInterrupt:
  143:             logger.critical("Operation cancelled by user")
  144:             logger.debug("Exception information:", exc_info=True)
  145: 
  146:             return ERROR
  147:         except BaseException:
  148:             logger.critical("Exception:", exc_info=True)
  149: 
  150:             return UNKNOWN_ERROR
  151: 
  152:     def parse_args(self, args: list[str]) -> tuple[Values, list[str]]:
  153:         # factored out for testability
  154:         return self.parser.parse_args(args)
  155: 
  156:     def main(self, args: list[str]) -> int:
  157:         try:
  158:             with self.main_context():
  159:                 return self._main(args)
  160:         finally:
  161:             logging.shutdown()
  162: 
  163:     def _main(self, args: list[str]) -> int:
  164:         # We must initialize this before the tempdir manager, otherwise the
  165:         # configuration would not be accessible by the time we clean up the
  166:         # tempdir manager.
  167:         self.tempdir_registry = self.enter_context(tempdir_registry())
  168:         # Intentionally set as early as possible so globally-managed temporary
  169:         # directories are available to the rest of the code.
  170:         self.enter_context(global_tempdir_manager())
  171: 
  172:         options, args = self.parse_args(args)
  173: 
  174:         # Set verbosity so that it can be used elsewhere.
  175:         self.verbosity = options.verbose - options.quiet
  176:         if options.debug_mode:
  177:             self.verbosity = 2
  178: 
  179:         if hasattr(options, "progress_bar") and options.progress_bar == "auto":
  180:             options.progress_bar = "on" if self.verbosity >= 0 else "off"
  181: 
  182:         reconfigure(no_color=options.no_color)
  183:         level_number = setup_logging(
  184:             verbosity=self.verbosity,
  185:             no_color=options.no_color,
  186:             user_log_file=options.log,
  187:         )
  188: 
  189:         always_enabled_features = set(options.features_enabled) & set(
  190:             cmdoptions.ALWAYS_ENABLED_FEATURES
  191:         )
  192:         if always_enabled_features:
  193:             logger.warning(
  194:                 "The following features are always enabled: %s. ",
  195:                 ", ".join(sorted(always_enabled_features)),
  196:             )
  197: 
  198:         # Make sure that the --python argument isn't specified after the
  199:         # subcommand. We can tell, because if --python was specified,
  200:         # we should only reach this point if we're running in the created
  201:         # subprocess, which has the _PIP_RUNNING_IN_SUBPROCESS environment
  202:         # variable set.
  203:         if options.python and "_PIP_RUNNING_IN_SUBPROCESS" not in os.environ:
  204:             logger.critical(
  205:                 "The --python option must be placed before the pip subcommand name"
  206:             )
  207:             sys.exit(ERROR)
  208: 
  209:         # TODO: Try to get these passing down from the command?
  210:         #       without resorting to os.environ to hold these.
  211:         #       This also affects isolated builds and it should.
  212: 
  213:         if options.no_input:
  214:             os.environ["PIP_NO_INPUT"] = "1"
  215: 
  216:         if options.exists_action:
  217:             os.environ["PIP_EXISTS_ACTION"] = " ".join(options.exists_action)
  218: 
  219:         if options.require_venv and not self.ignore_require_venv:
  220:             # If a venv is required check if it can really be found
  221:             if not running_under_virtualenv():
  222:                 logger.critical("Could not find an activated virtualenv (required).")
  223:                 sys.exit(VIRTUALENV_NOT_FOUND)
  224: 
  225:         if options.cache_dir:
  226:             options.cache_dir = normalize_path(options.cache_dir)
  227:             if not check_path_owner(options.cache_dir):
  228:                 logger.warning(
  229:                     "The directory '%s' or its parent directory is not owned "
  230:                     "or is not writable by the current user. The cache "
  231:                     "has been disabled. Check the permissions and owner of "
  232:                     "that directory. If executing pip with sudo, you should "
  233:                     "use sudo's -H flag.",
  234:                     options.cache_dir,
  235:                 )
  236:                 options.cache_dir = None
  237: 
  238:         return self._run_wrapper(level_number, options, args)
  239: 
  240:     def handler_map(self) -> dict[str, Callable[[Values, list[str]], None]]:
  241:         """
  242:         map of names to handler actions for commands with sub-actions
  243:         """
  244:         return {}
