    1: """
    2: shared options and groups
    3: 
    4: The principle here is to define options once, but *not* instantiate them
    5: globally. One reason being that options with action='append' can carry state
    6: between parses. pip parses general options twice internally, and shouldn't
    7: pass on state. To be consistent, all options will follow this design.
    8: """
    9: 
   10: # The following comment should be removed at some point in the future.
   11: # mypy: strict-optional=False
   12: from __future__ import annotations
   13: 
   14: import importlib.util
   15: import logging
   16: import os
   17: import pathlib
   18: import textwrap
   19: from functools import partial
   20: from optparse import SUPPRESS_HELP, Option, OptionGroup, OptionParser, Values
   21: from textwrap import dedent
   22: from typing import Any, Callable
   23: 
   24: from pip._vendor.packaging.utils import canonicalize_name
   25: 
   26: from pip._internal.cli.parser import ConfigOptionParser
   27: from pip._internal.exceptions import CommandError
   28: from pip._internal.locations import USER_CACHE_DIR, get_src_prefix
   29: from pip._internal.models.format_control import FormatControl
   30: from pip._internal.models.index import PyPI
   31: from pip._internal.models.target_python import TargetPython
   32: from pip._internal.utils.hashes import STRONG_HASHES
   33: from pip._internal.utils.misc import strtobool
   34: 
   35: logger = logging.getLogger(__name__)
   36: 
   37: 
   38: def raise_option_error(parser: OptionParser, option: Option, msg: str) -> None:
   39:     """
   40:     Raise an option parsing error using parser.error().
   41: 
   42:     Args:
   43:       parser: an OptionParser instance.
   44:       option: an Option instance.
   45:       msg: the error text.
   46:     """
   47:     msg = f"{option} error: {msg}"
   48:     msg = textwrap.fill(" ".join(msg.split()))
   49:     parser.error(msg)
   50: 
   51: 
   52: def make_option_group(group: dict[str, Any], parser: ConfigOptionParser) -> OptionGroup:
   53:     """
   54:     Return an OptionGroup object
   55:     group  -- assumed to be dict with 'name' and 'options' keys
   56:     parser -- an optparse Parser
   57:     """
   58:     option_group = OptionGroup(parser, group["name"])
   59:     for option in group["options"]:
   60:         option_group.add_option(option())
   61:     return option_group
   62: 
   63: 
   64: def check_dist_restriction(options: Values, check_target: bool = False) -> None:
   65:     """Function for determining if custom platform options are allowed.
   66: 
   67:     :param options: The OptionParser options.
   68:     :param check_target: Whether or not to check if --target is being used.
   69:     """
   70:     dist_restriction_set = any(
   71:         [
   72:             options.python_version,
   73:             options.platforms,
   74:             options.abis,
   75:             options.implementation,
   76:         ]
   77:     )
   78: 
   79:     binary_only = FormatControl(set(), {":all:"})
   80:     sdist_dependencies_allowed = (
   81:         options.format_control != binary_only and not options.ignore_dependencies
   82:     )
   83: 
   84:     # Installations or downloads using dist restrictions must not combine
   85:     # source distributions and dist-specific wheels, as they are not
   86:     # guaranteed to be locally compatible.
   87:     if dist_restriction_set and sdist_dependencies_allowed:
   88:         raise CommandError(
   89:             "When restricting platform and interpreter constraints using "
   90:             "--python-version, --platform, --abi, or --implementation, "
   91:             "either --no-deps must be set, or --only-binary=:all: must be "
   92:             "set and --no-binary must not be set (or must be set to "
   93:             ":none:)."
   94:         )
   95: 
   96:     if check_target:
   97:         if not options.dry_run and dist_restriction_set and not options.target_dir:
   98:             raise CommandError(
   99:                 "Can not use any platform or abi specific options unless "
  100:                 "installing via '--target' or using '--dry-run'"
  101:             )
  102: 
  103: 
  104: def _path_option_check(option: Option, opt: str, value: str) -> str:
  105:     return os.path.expanduser(value)
  106: 
  107: 
  108: def _package_name_option_check(option: Option, opt: str, value: str) -> str:
  109:     return canonicalize_name(value)
  110: 
  111: 
  112: class PipOption(Option):
  113:     TYPES = Option.TYPES + ("path", "package_name")
  114:     TYPE_CHECKER = Option.TYPE_CHECKER.copy()
  115:     TYPE_CHECKER["package_name"] = _package_name_option_check
  116:     TYPE_CHECKER["path"] = _path_option_check
  117: 
  118: 
  119: ###########
  120: # options #
  121: ###########
  122: 
  123: help_: Callable[..., Option] = partial(
  124:     Option,
  125:     "-h",
  126:     "--help",
  127:     dest="help",
  128:     action="help",
  129:     help="Show help.",
  130: )
  131: 
  132: debug_mode: Callable[..., Option] = partial(
  133:     Option,
  134:     "--debug",
  135:     dest="debug_mode",
  136:     action="store_true",
  137:     default=False,
  138:     help=(
  139:         "Let unhandled exceptions propagate outside the main subroutine, "
  140:         "instead of logging them to stderr."
  141:     ),
  142: )
  143: 
  144: isolated_mode: Callable[..., Option] = partial(
  145:     Option,
  146:     "--isolated",
  147:     dest="isolated_mode",
  148:     action="store_true",
  149:     default=False,
  150:     help=(
  151:         "Run pip in an isolated mode, ignoring environment variables and user "
  152:         "configuration."
  153:     ),
  154: )
  155: 
  156: require_virtualenv: Callable[..., Option] = partial(
  157:     Option,
  158:     "--require-virtualenv",
  159:     "--require-venv",
  160:     dest="require_venv",
  161:     action="store_true",
  162:     default=False,
  163:     help=(
  164:         "Allow pip to only run in a virtual environment; "
  165:         "exit with an error otherwise."
  166:     ),
  167: )
  168: 
  169: override_externally_managed: Callable[..., Option] = partial(
  170:     Option,
  171:     "--break-system-packages",
  172:     dest="override_externally_managed",
  173:     action="store_true",
  174:     help="Allow pip to modify an EXTERNALLY-MANAGED Python installation",
  175: )
  176: 
  177: python: Callable[..., Option] = partial(
  178:     Option,
  179:     "--python",
  180:     dest="python",
  181:     help="Run pip with the specified Python interpreter.",
  182: )
  183: 
  184: verbose: Callable[..., Option] = partial(
  185:     Option,
  186:     "-v",
  187:     "--verbose",
  188:     dest="verbose",
  189:     action="count",
  190:     default=0,
  191:     help="Give more output. Option is additive, and can be used up to 3 times.",
  192: )
  193: 
  194: no_color: Callable[..., Option] = partial(
  195:     Option,
  196:     "--no-color",
  197:     dest="no_color",
  198:     action="store_true",
  199:     default=False,
  200:     help="Suppress colored output.",
  201: )
  202: 
  203: version: Callable[..., Option] = partial(
  204:     Option,
  205:     "-V",
  206:     "--version",
  207:     dest="version",
  208:     action="store_true",
  209:     help="Show version and exit.",
  210: )
  211: 
  212: quiet: Callable[..., Option] = partial(
  213:     Option,
  214:     "-q",
  215:     "--quiet",
  216:     dest="quiet",
  217:     action="count",
  218:     default=0,
  219:     help=(
  220:         "Give less output. Option is additive, and can be used up to 3"
  221:         " times (corresponding to WARNING, ERROR, and CRITICAL logging"
  222:         " levels)."
  223:     ),
  224: )
  225: 
  226: progress_bar: Callable[..., Option] = partial(
  227:     Option,
  228:     "--progress-bar",
  229:     dest="progress_bar",
  230:     type="choice",
  231:     choices=["auto", "on", "off", "raw"],
  232:     default="auto",
  233:     help=(
  234:         "Specify whether the progress bar should be used. In 'auto'"
  235:         " mode, --quiet will suppress all progress bars."
  236:         " [auto, on, off, raw] (default: auto)"
  237:     ),
  238: )
  239: 
  240: log: Callable[..., Option] = partial(
  241:     PipOption,
  242:     "--log",
  243:     "--log-file",
  244:     "--local-log",
  245:     dest="log",
  246:     metavar="path",
  247:     type="path",
  248:     help="Path to a verbose appending log.",
  249: )
  250: 
  251: no_input: Callable[..., Option] = partial(
  252:     Option,
  253:     # Don't ask for input
  254:     "--no-input",
  255:     dest="no_input",
  256:     action="store_true",
  257:     default=False,
  258:     help="Disable prompting for input.",
  259: )
  260: 
  261: keyring_provider: Callable[..., Option] = partial(
  262:     Option,
  263:     "--keyring-provider",
  264:     dest="keyring_provider",
  265:     choices=["auto", "disabled", "import", "subprocess"],
  266:     default="auto",
  267:     help=(
  268:         "Enable the credential lookup via the keyring library if user input is allowed."
  269:         " Specify which mechanism to use [auto, disabled, import, subprocess]."
  270:         " (default: %default)"
  271:     ),
  272: )
  273: 
  274: proxy: Callable[..., Option] = partial(
  275:     Option,
  276:     "--proxy",
  277:     dest="proxy",
  278:     type="str",
  279:     default="",
  280:     help="Specify a proxy in the form scheme://[user:passwd@]proxy.server:port.",
  281: )
  282: 
  283: retries: Callable[..., Option] = partial(
  284:     Option,
  285:     "--retries",
  286:     dest="retries",
  287:     type="int",
  288:     default=5,
  289:     help="Maximum attempts to establish a new HTTP connection. (default: %default)",
  290: )
  291: 
  292: resume_retries: Callable[..., Option] = partial(
  293:     Option,
  294:     "--resume-retries",
  295:     dest="resume_retries",
  296:     type="int",
  297:     default=5,
  298:     help="Maximum attempts to resume or restart an incomplete download. "
  299:     "(default: %default)",
  300: )
  301: 
  302: timeout: Callable[..., Option] = partial(
  303:     Option,
  304:     "--timeout",
  305:     "--default-timeout",
  306:     metavar="sec",
  307:     dest="timeout",
  308:     type="float",
  309:     default=15,
  310:     help="Set the socket timeout (default %default seconds).",
  311: )
  312: 
  313: 
  314: def exists_action() -> Option:
  315:     return Option(
  316:         # Option when path already exist
  317:         "--exists-action",
  318:         dest="exists_action",
  319:         type="choice",
  320:         choices=["s", "i", "w", "b", "a"],
  321:         default=[],
  322:         action="append",
  323:         metavar="action",
  324:         help="Default action when a path already exists: "
  325:         "(s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort.",
  326:     )
  327: 
  328: 
  329: cert: Callable[..., Option] = partial(
  330:     PipOption,
  331:     "--cert",
  332:     dest="cert",
  333:     type="path",
  334:     metavar="path",
  335:     help=(
  336:         "Path to PEM-encoded CA certificate bundle. "
  337:         "If provided, overrides the default. "
  338:         "See 'SSL Certificate Verification' in pip documentation "
  339:         "for more information."
  340:     ),
  341: )
  342: 
  343: client_cert: Callable[..., Option] = partial(
  344:     PipOption,
  345:     "--client-cert",
  346:     dest="client_cert",
  347:     type="path",
  348:     default=None,
  349:     metavar="path",
  350:     help="Path to SSL client certificate, a single file containing the "
  351:     "private key and the certificate in PEM format.",
  352: )
  353: 
  354: index_url: Callable[..., Option] = partial(
  355:     Option,
  356:     "-i",
  357:     "--index-url",
  358:     "--pypi-url",
  359:     dest="index_url",
  360:     metavar="URL",
  361:     default=PyPI.simple_url,
  362:     help="Base URL of the Python Package Index (default %default). "
  363:     "This should point to a repository compliant with PEP 503 "
  364:     "(the simple repository API) or a local directory laid out "
  365:     "in the same format.",
  366: )
  367: 
  368: 
  369: def extra_index_url() -> Option:
  370:     return Option(
  371:         "--extra-index-url",
  372:         dest="extra_index_urls",
  373:         metavar="URL",
  374:         action="append",
  375:         default=[],
  376:         help="Extra URLs of package indexes to use in addition to "
  377:         "--index-url. Should follow the same rules as "
  378:         "--index-url.",
  379:     )
  380: 
  381: 
  382: no_index: Callable[..., Option] = partial(
  383:     Option,
  384:     "--no-index",
  385:     dest="no_index",
  386:     action="store_true",
  387:     default=False,
  388:     help="Ignore package index (only looking at --find-links URLs instead).",
  389: )
  390: 
  391: 
  392: def find_links() -> Option:
  393:     return Option(
  394:         "-f",
  395:         "--find-links",
  396:         dest="find_links",
  397:         action="append",
  398:         default=[],
  399:         metavar="url",
  400:         help="If a URL or path to an html file, then parse for links to "
  401:         "archives such as sdist (.tar.gz) or wheel (.whl) files. "
  402:         "If a local path or file:// URL that's a directory, "
  403:         "then look for archives in the directory listing. "
  404:         "Links to VCS project URLs are not supported.",
  405:     )
  406: 
  407: 
  408: def trusted_host() -> Option:
  409:     return Option(
  410:         "--trusted-host",
  411:         dest="trusted_hosts",
  412:         action="append",
  413:         metavar="HOSTNAME",
  414:         default=[],
  415:         help="Mark this host or host:port pair as trusted, even though it "
  416:         "does not have valid or any HTTPS.",
  417:     )
  418: 
  419: 
  420: def constraints() -> Option:
  421:     return Option(
  422:         "-c",
  423:         "--constraint",
  424:         dest="constraints",
  425:         action="append",
  426:         default=[],
  427:         metavar="file",
  428:         help="Constrain versions using the given constraints file. "
  429:         "This option can be used multiple times.",
  430:     )
  431: 
  432: 
  433: def requirements() -> Option:
  434:     return Option(
  435:         "-r",
  436:         "--requirement",
  437:         dest="requirements",
  438:         action="append",
  439:         default=[],
  440:         metavar="file",
  441:         help="Install from the given requirements file. "
  442:         "This option can be used multiple times.",
  443:     )
  444: 
  445: 
  446: def editable() -> Option:
  447:     return Option(
  448:         "-e",
  449:         "--editable",
  450:         dest="editables",
  451:         action="append",
  452:         default=[],
  453:         metavar="path/url",
  454:         help=(
  455:             "Install a project in editable mode (i.e. setuptools "
  456:             '"develop mode") from a local project path or a VCS url.'
  457:         ),
  458:     )
  459: 
  460: 
  461: def _handle_src(option: Option, opt_str: str, value: str, parser: OptionParser) -> None:
  462:     value = os.path.abspath(value)
  463:     setattr(parser.values, option.dest, value)
  464: 
  465: 
  466: src: Callable[..., Option] = partial(
  467:     PipOption,
  468:     "--src",
  469:     "--source",
  470:     "--source-dir",
  471:     "--source-directory",
  472:     dest="src_dir",
  473:     type="path",
  474:     metavar="dir",
  475:     default=get_src_prefix(),
  476:     action="callback",
  477:     callback=_handle_src,
  478:     help="Directory to check out editable projects into. "
  479:     'The default in a virtualenv is "<venv path>/src". '
  480:     'The default for global installs is "<current dir>/src".',
  481: )
  482: 
  483: 
  484: def _get_format_control(values: Values, option: Option) -> Any:
  485:     """Get a format_control object."""
  486:     return getattr(values, option.dest)
  487: 
  488: 
  489: def _handle_no_binary(
  490:     option: Option, opt_str: str, value: str, parser: OptionParser
  491: ) -> None:
  492:     existing = _get_format_control(parser.values, option)
  493:     FormatControl.handle_mutual_excludes(
  494:         value,
  495:         existing.no_binary,
  496:         existing.only_binary,
  497:     )
  498: 
  499: 
  500: def _handle_only_binary(
  501:     option: Option, opt_str: str, value: str, parser: OptionParser
  502: ) -> None:
  503:     existing = _get_format_control(parser.values, option)
  504:     FormatControl.handle_mutual_excludes(
  505:         value,
  506:         existing.only_binary,
  507:         existing.no_binary,
  508:     )
  509: 
  510: 
  511: def no_binary() -> Option:
  512:     format_control = FormatControl(set(), set())
  513:     return Option(
  514:         "--no-binary",
  515:         dest="format_control",
  516:         action="callback",
  517:         callback=_handle_no_binary,
  518:         type="str",
  519:         default=format_control,
  520:         help="Do not use binary packages. Can be supplied multiple times, and "
  521:         'each time adds to the existing value. Accepts either ":all:" to '
  522:         'disable all binary packages, ":none:" to empty the set (notice '
  523:         "the colons), or one or more package names with commas between "
  524:         "them (no colons). Note that some packages are tricky to compile "
  525:         "and may fail to install when this option is used on them.",
  526:     )
  527: 
  528: 
  529: def only_binary() -> Option:
  530:     format_control = FormatControl(set(), set())
  531:     return Option(
  532:         "--only-binary",
  533:         dest="format_control",
  534:         action="callback",
  535:         callback=_handle_only_binary,
  536:         type="str",
  537:         default=format_control,
  538:         help="Do not use source packages. Can be supplied multiple times, and "
  539:         'each time adds to the existing value. Accepts either ":all:" to '
  540:         'disable all source packages, ":none:" to empty the set, or one '
  541:         "or more package names with commas between them. Packages "
  542:         "without binary distributions will fail to install when this "
  543:         "option is used on them.",
  544:     )
  545: 
  546: 
  547: platforms: Callable[..., Option] = partial(
  548:     Option,
  549:     "--platform",
  550:     dest="platforms",
  551:     metavar="platform",
  552:     action="append",
  553:     default=None,
  554:     help=(
  555:         "Only use wheels compatible with <platform>. Defaults to the "
  556:         "platform of the running system. Use this option multiple times to "
  557:         "specify multiple platforms supported by the target interpreter."
  558:     ),
  559: )
  560: 
  561: 
  562: # This was made a separate function for unit-testing purposes.
  563: def _convert_python_version(value: str) -> tuple[tuple[int, ...], str | None]:
  564:     """
  565:     Convert a version string like "3", "37", or "3.7.3" into a tuple of ints.
  566: 
  567:     :return: A 2-tuple (version_info, error_msg), where `error_msg` is
  568:         non-None if and only if there was a parsing error.
  569:     """
  570:     if not value:
  571:         # The empty string is the same as not providing a value.
  572:         return (None, None)
  573: 
  574:     parts = value.split(".")
  575:     if len(parts) > 3:
  576:         return ((), "at most three version parts are allowed")
  577: 
  578:     if len(parts) == 1:
  579:         # Then we are in the case of "3" or "37".
  580:         value = parts[0]
  581:         if len(value) > 1:
  582:             parts = [value[0], value[1:]]
  583: 
  584:     try:
  585:         version_info = tuple(int(part) for part in parts)
  586:     except ValueError:
  587:         return ((), "each version part must be an integer")
  588: 
  589:     return (version_info, None)
  590: 
  591: 
  592: def _handle_python_version(
  593:     option: Option, opt_str: str, value: str, parser: OptionParser
  594: ) -> None:
  595:     """
  596:     Handle a provided --python-version value.
  597:     """
  598:     version_info, error_msg = _convert_python_version(value)
  599:     if error_msg is not None:
  600:         msg = f"invalid --python-version value: {value!r}: {error_msg}"
  601:         raise_option_error(parser, option=option, msg=msg)
  602: 
  603:     parser.values.python_version = version_info
  604: 
  605: 
  606: python_version: Callable[..., Option] = partial(
  607:     Option,
  608:     "--python-version",
  609:     dest="python_version",
  610:     metavar="python_version",
  611:     action="callback",
  612:     callback=_handle_python_version,
  613:     type="str",
  614:     default=None,
  615:     help=dedent(
  616:         """\
  617:     The Python interpreter version to use for wheel and "Requires-Python"
  618:     compatibility checks. Defaults to a version derived from the running
  619:     interpreter. The version can be specified using up to three dot-separated
  620:     integers (e.g. "3" for 3.0.0, "3.7" for 3.7.0, or "3.7.3"). A major-minor
  621:     version can also be given as a string without dots (e.g. "37" for 3.7.0).
  622:     """
  623:     ),
  624: )
  625: 
  626: 
  627: implementation: Callable[..., Option] = partial(
  628:     Option,
  629:     "--implementation",
  630:     dest="implementation",
  631:     metavar="implementation",
  632:     default=None,
  633:     help=(
  634:         "Only use wheels compatible with Python "
  635:         "implementation <implementation>, e.g. 'pp', 'jy', 'cp', "
  636:         " or 'ip'. If not specified, then the current "
  637:         "interpreter implementation is used.  Use 'py' to force "
  638:         "implementation-agnostic wheels."
  639:     ),
  640: )
  641: 
  642: 
  643: abis: Callable[..., Option] = partial(
  644:     Option,
  645:     "--abi",
  646:     dest="abis",
  647:     metavar="abi",
  648:     action="append",
  649:     default=None,
  650:     help=(
  651:         "Only use wheels compatible with Python abi <abi>, e.g. 'pypy_41'. "
  652:         "If not specified, then the current interpreter abi tag is used. "
  653:         "Use this option multiple times to specify multiple abis supported "
  654:         "by the target interpreter. Generally you will need to specify "
  655:         "--implementation, --platform, and --python-version when using this "
  656:         "option."
  657:     ),
  658: )
  659: 
  660: 
  661: def add_target_python_options(cmd_opts: OptionGroup) -> None:
  662:     cmd_opts.add_option(platforms())
  663:     cmd_opts.add_option(python_version())
  664:     cmd_opts.add_option(implementation())
  665:     cmd_opts.add_option(abis())
  666: 
  667: 
  668: def make_target_python(options: Values) -> TargetPython:
  669:     target_python = TargetPython(
  670:         platforms=options.platforms,
  671:         py_version_info=options.python_version,
  672:         abis=options.abis,
  673:         implementation=options.implementation,
  674:     )
  675: 
  676:     return target_python
  677: 
  678: 
  679: def prefer_binary() -> Option:
  680:     return Option(
  681:         "--prefer-binary",
  682:         dest="prefer_binary",
  683:         action="store_true",
  684:         default=False,
  685:         help=(
  686:             "Prefer binary packages over source packages, even if the "
  687:             "source packages are newer."
  688:         ),
  689:     )
  690: 
  691: 
  692: cache_dir: Callable[..., Option] = partial(
  693:     PipOption,
  694:     "--cache-dir",
  695:     dest="cache_dir",
  696:     default=USER_CACHE_DIR,
  697:     metavar="dir",
  698:     type="path",
  699:     help="Store the cache data in <dir>.",
  700: )
  701: 
  702: 
  703: def _handle_no_cache_dir(
  704:     option: Option, opt: str, value: str, parser: OptionParser
  705: ) -> None:
  706:     """
  707:     Process a value provided for the --no-cache-dir option.
  708: 
  709:     This is an optparse.Option callback for the --no-cache-dir option.
  710:     """
  711:     # The value argument will be None if --no-cache-dir is passed via the
  712:     # command-line, since the option doesn't accept arguments.  However,
  713:     # the value can be non-None if the option is triggered e.g. by an
  714:     # environment variable, like PIP_NO_CACHE_DIR=true.
  715:     if value is not None:
  716:         # Then parse the string value to get argument error-checking.
  717:         try:
  718:             strtobool(value)
  719:         except ValueError as exc:
  720:             raise_option_error(parser, option=option, msg=str(exc))
  721: 
  722:     # Originally, setting PIP_NO_CACHE_DIR to a value that strtobool()
  723:     # converted to 0 (like "false" or "no") caused cache_dir to be disabled
  724:     # rather than enabled (logic would say the latter).  Thus, we disable
  725:     # the cache directory not just on values that parse to True, but (for
  726:     # backwards compatibility reasons) also on values that parse to False.
  727:     # In other words, always set it to False if the option is provided in
  728:     # some (valid) form.
  729:     parser.values.cache_dir = False
  730: 
  731: 
  732: no_cache: Callable[..., Option] = partial(
  733:     Option,
  734:     "--no-cache-dir",
  735:     dest="cache_dir",
  736:     action="callback",
  737:     callback=_handle_no_cache_dir,
  738:     help="Disable the cache.",
  739: )
  740: 
  741: no_deps: Callable[..., Option] = partial(
  742:     Option,
  743:     "--no-deps",
  744:     "--no-dependencies",
  745:     dest="ignore_dependencies",
  746:     action="store_true",
  747:     default=False,
  748:     help="Don't install package dependencies.",
  749: )
  750: 
  751: 
  752: def _handle_dependency_group(
  753:     option: Option, opt: str, value: str, parser: OptionParser
  754: ) -> None:
  755:     """
  756:     Process a value provided for the --group option.
  757: 
  758:     Splits on the rightmost ":", and validates that the path (if present) ends
  759:     in `pyproject.toml`. Defaults the path to `pyproject.toml` when one is not given.
  760: 
  761:     `:` cannot appear in dependency group names, so this is a safe and simple parse.
  762: 
  763:     This is an optparse.Option callback for the dependency_groups option.
  764:     """
  765:     path, sep, groupname = value.rpartition(":")
  766:     if not sep:
  767:         path = "pyproject.toml"
  768:     else:
  769:         # check for 'pyproject.toml' filenames using pathlib
  770:         if pathlib.PurePath(path).name != "pyproject.toml":
  771:             msg = "group paths use 'pyproject.toml' filenames"
  772:             raise_option_error(parser, option=option, msg=msg)
  773: 
  774:     parser.values.dependency_groups.append((path, groupname))
  775: 
  776: 
  777: dependency_groups: Callable[..., Option] = partial(
  778:     Option,
  779:     "--group",
  780:     dest="dependency_groups",
  781:     default=[],
  782:     type=str,
  783:     action="callback",
  784:     callback=_handle_dependency_group,
  785:     metavar="[path:]group",
  786:     help='Install a named dependency-group from a "pyproject.toml" file. '
  787:     'If a path is given, the name of the file must be "pyproject.toml". '
  788:     'Defaults to using "pyproject.toml" in the current directory.',
  789: )
  790: 
  791: ignore_requires_python: Callable[..., Option] = partial(
  792:     Option,
  793:     "--ignore-requires-python",
  794:     dest="ignore_requires_python",
  795:     action="store_true",
  796:     help="Ignore the Requires-Python information.",
  797: )
  798: 
  799: no_build_isolation: Callable[..., Option] = partial(
  800:     Option,
  801:     "--no-build-isolation",
  802:     dest="build_isolation",
  803:     action="store_false",
  804:     default=True,
  805:     help="Disable isolation when building a modern source distribution. "
  806:     "Build dependencies specified by PEP 518 must be already installed "
  807:     "if this option is used.",
  808: )
  809: 
  810: check_build_deps: Callable[..., Option] = partial(
  811:     Option,
  812:     "--check-build-dependencies",
  813:     dest="check_build_deps",
  814:     action="store_true",
  815:     default=False,
  816:     help="Check the build dependencies when PEP517 is used.",
  817: )
  818: 
  819: 
  820: def _handle_no_use_pep517(
  821:     option: Option, opt: str, value: str, parser: OptionParser
  822: ) -> None:
  823:     """
  824:     Process a value provided for the --no-use-pep517 option.
  825: 
  826:     This is an optparse.Option callback for the no_use_pep517 option.
  827:     """
  828:     # Since --no-use-pep517 doesn't accept arguments, the value argument
  829:     # will be None if --no-use-pep517 is passed via the command-line.
  830:     # However, the value can be non-None if the option is triggered e.g.
  831:     # by an environment variable, for example "PIP_NO_USE_PEP517=true".
  832:     if value is not None:
  833:         msg = """A value was passed for --no-use-pep517,
  834:         probably using either the PIP_NO_USE_PEP517 environment variable
  835:         or the "no-use-pep517" config file option. Use an appropriate value
  836:         of the PIP_USE_PEP517 environment variable or the "use-pep517"
  837:         config file option instead.
  838:         """
  839:         raise_option_error(parser, option=option, msg=msg)
  840: 
  841:     # If user doesn't wish to use pep517, we check if setuptools is installed
  842:     # and raise error if it is not.
  843:     packages = ("setuptools",)
  844:     if not all(importlib.util.find_spec(package) for package in packages):
  845:         msg = (
  846:             f"It is not possible to use --no-use-pep517 "
  847:             f"without {' and '.join(packages)} installed."
  848:         )
  849:         raise_option_error(parser, option=option, msg=msg)
  850: 
  851:     # Otherwise, --no-use-pep517 was passed via the command-line.
  852:     parser.values.use_pep517 = False
  853: 
  854: 
  855: use_pep517: Any = partial(
  856:     Option,
  857:     "--use-pep517",
  858:     dest="use_pep517",
  859:     action="store_true",
  860:     default=None,
  861:     help="Use PEP 517 for building source distributions "
  862:     "(use --no-use-pep517 to force legacy behaviour).",
  863: )
  864: 
  865: no_use_pep517: Any = partial(
  866:     Option,
  867:     "--no-use-pep517",
  868:     dest="use_pep517",
  869:     action="callback",
  870:     callback=_handle_no_use_pep517,
  871:     default=None,
  872:     help=SUPPRESS_HELP,
  873: )
  874: 
  875: 
  876: def _handle_config_settings(
  877:     option: Option, opt_str: str, value: str, parser: OptionParser
  878: ) -> None:
  879:     key, sep, val = value.partition("=")
  880:     if sep != "=":
  881:         parser.error(f"Arguments to {opt_str} must be of the form KEY=VAL")
  882:     dest = getattr(parser.values, option.dest)
  883:     if dest is None:
  884:         dest = {}
  885:         setattr(parser.values, option.dest, dest)
  886:     if key in dest:
  887:         if isinstance(dest[key], list):
  888:             dest[key].append(val)
  889:         else:
  890:             dest[key] = [dest[key], val]
  891:     else:
  892:         dest[key] = val
  893: 
  894: 
  895: config_settings: Callable[..., Option] = partial(
  896:     Option,
  897:     "-C",
  898:     "--config-settings",
  899:     dest="config_settings",
  900:     type=str,
  901:     action="callback",
  902:     callback=_handle_config_settings,
  903:     metavar="settings",
  904:     help="Configuration settings to be passed to the PEP 517 build backend. "
  905:     "Settings take the form KEY=VALUE. Use multiple --config-settings options "
  906:     "to pass multiple keys to the backend.",
  907: )
  908: 
  909: build_options: Callable[..., Option] = partial(
  910:     Option,
  911:     "--build-option",
  912:     dest="build_options",
  913:     metavar="options",
  914:     action="append",
  915:     help="Extra arguments to be supplied to 'setup.py bdist_wheel'.",
  916: )
  917: 
  918: global_options: Callable[..., Option] = partial(
  919:     Option,
  920:     "--global-option",
  921:     dest="global_options",
  922:     action="append",
  923:     metavar="options",
  924:     help="Extra global options to be supplied to the setup.py "
  925:     "call before the install or bdist_wheel command.",
  926: )
  927: 
  928: no_clean: Callable[..., Option] = partial(
  929:     Option,
  930:     "--no-clean",
  931:     action="store_true",
  932:     default=False,
  933:     help="Don't clean up build directories.",
  934: )
  935: 
  936: pre: Callable[..., Option] = partial(
  937:     Option,
  938:     "--pre",
  939:     action="store_true",
  940:     default=False,
  941:     help="Include pre-release and development versions. By default, "
  942:     "pip only finds stable versions.",
  943: )
  944: 
  945: json: Callable[..., Option] = partial(
  946:     Option,
  947:     "--json",
  948:     action="store_true",
  949:     default=False,
  950:     help="Output data in a machine-readable JSON format.",
  951: )
  952: 
  953: disable_pip_version_check: Callable[..., Option] = partial(
  954:     Option,
  955:     "--disable-pip-version-check",
  956:     dest="disable_pip_version_check",
  957:     action="store_true",
  958:     default=False,
  959:     help="Don't periodically check PyPI to determine whether a new version "
  960:     "of pip is available for download. Implied with --no-index.",
  961: )
  962: 
  963: root_user_action: Callable[..., Option] = partial(
  964:     Option,
  965:     "--root-user-action",
  966:     dest="root_user_action",
  967:     default="warn",
  968:     choices=["warn", "ignore"],
  969:     help="Action if pip is run as a root user [warn, ignore] (default: warn)",
  970: )
  971: 
  972: 
  973: def _handle_merge_hash(
  974:     option: Option, opt_str: str, value: str, parser: OptionParser
  975: ) -> None:
  976:     """Given a value spelled "algo:digest", append the digest to a list
  977:     pointed to in a dict by the algo name."""
  978:     if not parser.values.hashes:
  979:         parser.values.hashes = {}
  980:     try:
  981:         algo, digest = value.split(":", 1)
  982:     except ValueError:
  983:         parser.error(
  984:             f"Arguments to {opt_str} must be a hash name "
  985:             "followed by a value, like --hash=sha256:"
  986:             "abcde..."
  987:         )
  988:     if algo not in STRONG_HASHES:
  989:         parser.error(
  990:             "Allowed hash algorithms for {} are {}.".format(
  991:                 opt_str, ", ".join(STRONG_HASHES)
  992:             )
  993:         )
  994:     parser.values.hashes.setdefault(algo, []).append(digest)
  995: 
  996: 
  997: hash: Callable[..., Option] = partial(
  998:     Option,
  999:     "--hash",
 1000:     # Hash values eventually end up in InstallRequirement.hashes due to
 1001:     # __dict__ copying in process_line().
 1002:     dest="hashes",
 1003:     action="callback",
 1004:     callback=_handle_merge_hash,
 1005:     type="string",
 1006:     help="Verify that the package's archive matches this "
 1007:     "hash before installing. Example: --hash=sha256:abcdef...",
 1008: )
 1009: 
 1010: 
 1011: require_hashes: Callable[..., Option] = partial(
 1012:     Option,
 1013:     "--require-hashes",
 1014:     dest="require_hashes",
 1015:     action="store_true",
 1016:     default=False,
 1017:     help="Require a hash to check each requirement against, for "
 1018:     "repeatable installs. This option is implied when any package in a "
 1019:     "requirements file has a --hash option.",
 1020: )
 1021: 
 1022: 
 1023: list_path: Callable[..., Option] = partial(
 1024:     PipOption,
 1025:     "--path",
 1026:     dest="path",
 1027:     type="path",
 1028:     action="append",
 1029:     help="Restrict to the specified installation path for listing "
 1030:     "packages (can be used multiple times).",
 1031: )
 1032: 
 1033: 
 1034: def check_list_path_option(options: Values) -> None:
 1035:     if options.path and (options.user or options.local):
 1036:         raise CommandError("Cannot combine '--path' with '--user' or '--local'")
 1037: 
 1038: 
 1039: list_exclude: Callable[..., Option] = partial(
 1040:     PipOption,
 1041:     "--exclude",
 1042:     dest="excludes",
 1043:     action="append",
 1044:     metavar="package",
 1045:     type="package_name",
 1046:     help="Exclude specified package from the output",
 1047: )
 1048: 
 1049: 
 1050: no_python_version_warning: Callable[..., Option] = partial(
 1051:     Option,
 1052:     "--no-python-version-warning",
 1053:     dest="no_python_version_warning",
 1054:     action="store_true",
 1055:     default=False,
 1056:     help=SUPPRESS_HELP,  # No-op, a hold-over from the Python 2->3 transition.
 1057: )
 1058: 
 1059: 
 1060: # Features that are now always on. A warning is printed if they are used.
 1061: ALWAYS_ENABLED_FEATURES = [
 1062:     "truststore",  # always on since 24.2
 1063:     "no-binary-enable-wheel-cache",  # always on since 23.1
 1064: ]
 1065: 
 1066: use_new_feature: Callable[..., Option] = partial(
 1067:     Option,
 1068:     "--use-feature",
 1069:     dest="features_enabled",
 1070:     metavar="feature",
 1071:     action="append",
 1072:     default=[],
 1073:     choices=[
 1074:         "fast-deps",
 1075:     ]
 1076:     + ALWAYS_ENABLED_FEATURES,
 1077:     help="Enable new functionality, that may be backward incompatible.",
 1078: )
 1079: 
 1080: use_deprecated_feature: Callable[..., Option] = partial(
 1081:     Option,
 1082:     "--use-deprecated",
 1083:     dest="deprecated_features_enabled",
 1084:     metavar="feature",
 1085:     action="append",
 1086:     default=[],
 1087:     choices=[
 1088:         "legacy-resolver",
 1089:         "legacy-certs",
 1090:     ],
 1091:     help=("Enable deprecated functionality, that will be removed in the future."),
 1092: )
 1093: 
 1094: ##########
 1095: # groups #
 1096: ##########
 1097: 
 1098: general_group: dict[str, Any] = {
 1099:     "name": "General Options",
 1100:     "options": [
 1101:         help_,
 1102:         debug_mode,
 1103:         isolated_mode,
 1104:         require_virtualenv,
 1105:         python,
 1106:         verbose,
 1107:         version,
 1108:         quiet,
 1109:         log,
 1110:         no_input,
 1111:         keyring_provider,
 1112:         proxy,
 1113:         retries,
 1114:         timeout,
 1115:         exists_action,
 1116:         trusted_host,
 1117:         cert,
 1118:         client_cert,
 1119:         cache_dir,
 1120:         no_cache,
 1121:         disable_pip_version_check,
 1122:         no_color,
 1123:         no_python_version_warning,
 1124:         use_new_feature,
 1125:         use_deprecated_feature,
 1126:         resume_retries,
 1127:     ],
 1128: }
 1129: 
 1130: index_group: dict[str, Any] = {
 1131:     "name": "Package Index Options",
 1132:     "options": [
 1133:         index_url,
 1134:         extra_index_url,
 1135:         no_index,
 1136:         find_links,
 1137:     ],
 1138: }
