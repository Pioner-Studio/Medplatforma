    1: """Base option parser setup"""
    2: 
    3: from __future__ import annotations
    4: 
    5: import logging
    6: import optparse
    7: import shutil
    8: import sys
    9: import textwrap
   10: from collections.abc import Generator
   11: from contextlib import suppress
   12: from typing import Any, NoReturn
   13: 
   14: from pip._internal.cli.status_codes import UNKNOWN_ERROR
   15: from pip._internal.configuration import Configuration, ConfigurationError
   16: from pip._internal.utils.misc import redact_auth_from_url, strtobool
   17: 
   18: logger = logging.getLogger(__name__)
   19: 
   20: 
   21: class PrettyHelpFormatter(optparse.IndentedHelpFormatter):
   22:     """A prettier/less verbose help formatter for optparse."""
   23: 
   24:     def __init__(self, *args: Any, **kwargs: Any) -> None:
   25:         # help position must be aligned with __init__.parseopts.description
   26:         kwargs["max_help_position"] = 30
   27:         kwargs["indent_increment"] = 1
   28:         kwargs["width"] = shutil.get_terminal_size()[0] - 2
   29:         super().__init__(*args, **kwargs)
   30: 
   31:     def format_option_strings(self, option: optparse.Option) -> str:
   32:         return self._format_option_strings(option)
   33: 
   34:     def _format_option_strings(
   35:         self, option: optparse.Option, mvarfmt: str = " <{}>", optsep: str = ", "
   36:     ) -> str:
   37:         """
   38:         Return a comma-separated list of option strings and metavars.
   39: 
   40:         :param option:  tuple of (short opt, long opt), e.g: ('-f', '--format')
   41:         :param mvarfmt: metavar format string
   42:         :param optsep:  separator
   43:         """
   44:         opts = []
   45: 
   46:         if option._short_opts:
   47:             opts.append(option._short_opts[0])
   48:         if option._long_opts:
   49:             opts.append(option._long_opts[0])
   50:         if len(opts) > 1:
   51:             opts.insert(1, optsep)
   52: 
   53:         if option.takes_value():
   54:             assert option.dest is not None
   55:             metavar = option.metavar or option.dest.lower()
   56:             opts.append(mvarfmt.format(metavar.lower()))
   57: 
   58:         return "".join(opts)
   59: 
   60:     def format_heading(self, heading: str) -> str:
   61:         if heading == "Options":
   62:             return ""
   63:         return heading + ":\n"
   64: 
   65:     def format_usage(self, usage: str) -> str:
   66:         """
   67:         Ensure there is only one newline between usage and the first heading
   68:         if there is no description.
   69:         """
   70:         msg = "\nUsage: {}\n".format(self.indent_lines(textwrap.dedent(usage), "  "))
   71:         return msg
   72: 
   73:     def format_description(self, description: str | None) -> str:
   74:         # leave full control over description to us
   75:         if description:
   76:             if hasattr(self.parser, "main"):
   77:                 label = "Commands"
   78:             else:
   79:                 label = "Description"
   80:             # some doc strings have initial newlines, some don't
   81:             description = description.lstrip("\n")
   82:             # some doc strings have final newlines and spaces, some don't
   83:             description = description.rstrip()
   84:             # dedent, then reindent
   85:             description = self.indent_lines(textwrap.dedent(description), "  ")
   86:             description = f"{label}:\n{description}\n"
   87:             return description
   88:         else:
   89:             return ""
   90: 
   91:     def format_epilog(self, epilog: str | None) -> str:
   92:         # leave full control over epilog to us
   93:         if epilog:
   94:             return epilog
   95:         else:
   96:             return ""
   97: 
   98:     def indent_lines(self, text: str, indent: str) -> str:
   99:         new_lines = [indent + line for line in text.split("\n")]
  100:         return "\n".join(new_lines)
  101: 
  102: 
  103: class UpdatingDefaultsHelpFormatter(PrettyHelpFormatter):
  104:     """Custom help formatter for use in ConfigOptionParser.
  105: 
  106:     This is updates the defaults before expanding them, allowing
  107:     them to show up correctly in the help listing.
  108: 
  109:     Also redact auth from url type options
  110:     """
  111: 
  112:     def expand_default(self, option: optparse.Option) -> str:
  113:         default_values = None
  114:         if self.parser is not None:
  115:             assert isinstance(self.parser, ConfigOptionParser)
  116:             self.parser._update_defaults(self.parser.defaults)
  117:             assert option.dest is not None
  118:             default_values = self.parser.defaults.get(option.dest)
  119:         help_text = super().expand_default(option)
  120: 
  121:         if default_values and option.metavar == "URL":
  122:             if isinstance(default_values, str):
  123:                 default_values = [default_values]
  124: 
  125:             # If its not a list, we should abort and just return the help text
  126:             if not isinstance(default_values, list):
  127:                 default_values = []
  128: 
  129:             for val in default_values:
  130:                 help_text = help_text.replace(val, redact_auth_from_url(val))
  131: 
  132:         return help_text
  133: 
  134: 
  135: class CustomOptionParser(optparse.OptionParser):
  136:     def insert_option_group(
  137:         self, idx: int, *args: Any, **kwargs: Any
  138:     ) -> optparse.OptionGroup:
  139:         """Insert an OptionGroup at a given position."""
  140:         group = self.add_option_group(*args, **kwargs)
  141: 
  142:         self.option_groups.pop()
  143:         self.option_groups.insert(idx, group)
  144: 
  145:         return group
  146: 
  147:     @property
  148:     def option_list_all(self) -> list[optparse.Option]:
  149:         """Get a list of all options, including those in option groups."""
  150:         res = self.option_list[:]
  151:         for i in self.option_groups:
  152:             res.extend(i.option_list)
  153: 
  154:         return res
  155: 
  156: 
  157: class ConfigOptionParser(CustomOptionParser):
  158:     """Custom option parser which updates its defaults by checking the
  159:     configuration files and environmental variables"""
  160: 
  161:     def __init__(
  162:         self,
  163:         *args: Any,
  164:         name: str,
  165:         isolated: bool = False,
  166:         **kwargs: Any,
  167:     ) -> None:
  168:         self.name = name
  169:         self.config = Configuration(isolated)
  170: 
  171:         assert self.name
  172:         super().__init__(*args, **kwargs)
  173: 
  174:     def check_default(self, option: optparse.Option, key: str, val: Any) -> Any:
  175:         try:
  176:             return option.check_value(key, val)
  177:         except optparse.OptionValueError as exc:
  178:             print(f"An error occurred during configuration: {exc}")
  179:             sys.exit(3)
  180: 
  181:     def _get_ordered_configuration_items(
  182:         self,
  183:     ) -> Generator[tuple[str, Any], None, None]:
  184:         # Configuration gives keys in an unordered manner. Order them.
  185:         override_order = ["global", self.name, ":env:"]
  186: 
  187:         # Pool the options into different groups
  188:         section_items: dict[str, list[tuple[str, Any]]] = {
  189:             name: [] for name in override_order
  190:         }
  191: 
  192:         for _, value in self.config.items():  # noqa: PERF102
  193:             for section_key, val in value.items():
  194:                 # ignore empty values
  195:                 if not val:
  196:                     logger.debug(
  197:                         "Ignoring configuration key '%s' as its value is empty.",
  198:                         section_key,
  199:                     )
  200:                     continue
  201: 
  202:                 section, key = section_key.split(".", 1)
  203:                 if section in override_order:
  204:                     section_items[section].append((key, val))
  205: 
  206:             # Yield each group in their override order
  207:             for section in override_order:
  208:                 yield from section_items[section]
  209: 
  210:     def _update_defaults(self, defaults: dict[str, Any]) -> dict[str, Any]:
  211:         """Updates the given defaults with values from the config files and
  212:         the environ. Does a little special handling for certain types of
  213:         options (lists)."""
  214: 
  215:         # Accumulate complex default state.
  216:         self.values = optparse.Values(self.defaults)
  217:         late_eval = set()
  218:         # Then set the options with those values
  219:         for key, val in self._get_ordered_configuration_items():
  220:             # '--' because configuration supports only long names
  221:             option = self.get_option("--" + key)
  222: 
  223:             # Ignore options not present in this parser. E.g. non-globals put
  224:             # in [global] by users that want them to apply to all applicable
  225:             # commands.
  226:             if option is None:
  227:                 continue
  228: 
  229:             assert option.dest is not None
  230: 
  231:             if option.action in ("store_true", "store_false"):
  232:                 try:
  233:                     val = strtobool(val)
  234:                 except ValueError:
  235:                     self.error(
  236:                         f"{val} is not a valid value for {key} option, "
  237:                         "please specify a boolean value like yes/no, "
  238:                         "true/false or 1/0 instead."
  239:                     )
  240:             elif option.action == "count":
  241:                 with suppress(ValueError):
  242:                     val = strtobool(val)
  243:                 with suppress(ValueError):
  244:                     val = int(val)
  245:                 if not isinstance(val, int) or val < 0:
  246:                     self.error(
  247:                         f"{val} is not a valid value for {key} option, "
  248:                         "please instead specify either a non-negative integer "
  249:                         "or a boolean value like yes/no or false/true "
  250:                         "which is equivalent to 1/0."
  251:                     )
  252:             elif option.action == "append":
  253:                 val = val.split()
  254:                 val = [self.check_default(option, key, v) for v in val]
  255:             elif option.action == "callback":
  256:                 assert option.callback is not None
  257:                 late_eval.add(option.dest)
  258:                 opt_str = option.get_opt_string()
  259:                 val = option.convert_value(opt_str, val)
  260:                 # From take_action
  261:                 args = option.callback_args or ()
  262:                 kwargs = option.callback_kwargs or {}
  263:                 option.callback(option, opt_str, val, self, *args, **kwargs)
  264:             else:
  265:                 val = self.check_default(option, key, val)
  266: 
  267:             defaults[option.dest] = val
  268: 
  269:         for key in late_eval:
  270:             defaults[key] = getattr(self.values, key)
  271:         self.values = None
  272:         return defaults
  273: 
  274:     def get_default_values(self) -> optparse.Values:
  275:         """Overriding to make updating the defaults after instantiation of
  276:         the option parser possible, _update_defaults() does the dirty work."""
  277:         if not self.process_default_values:
  278:             # Old, pre-Optik 1.5 behaviour.
  279:             return optparse.Values(self.defaults)
  280: 
  281:         # Load the configuration, or error out in case of an error
  282:         try:
  283:             self.config.load()
  284:         except ConfigurationError as err:
  285:             self.exit(UNKNOWN_ERROR, str(err))
  286: 
  287:         defaults = self._update_defaults(self.defaults.copy())  # ours
  288:         for option in self._get_all_options():
  289:             assert option.dest is not None
  290:             default = defaults.get(option.dest)
  291:             if isinstance(default, str):
  292:                 opt_str = option.get_opt_string()
  293:                 defaults[option.dest] = option.check_value(opt_str, default)
  294:         return optparse.Values(defaults)
  295: 
  296:     def error(self, msg: str) -> NoReturn:
  297:         self.print_usage(sys.stderr)
  298:         self.exit(UNKNOWN_ERROR, f"{msg}\n")
