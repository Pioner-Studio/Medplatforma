    1: """Contains the RequirementCommand base class.
    2: 
    3: This class is in a separate module so the commands that do not always
    4: need PackageFinder capability don't unnecessarily import the
    5: PackageFinder machinery and all its vendored dependencies, etc.
    6: """
    7: 
    8: from __future__ import annotations
    9: 
   10: import logging
   11: from functools import partial
   12: from optparse import Values
   13: from typing import Any
   14: 
   15: from pip._internal.build_env import SubprocessBuildEnvironmentInstaller
   16: from pip._internal.cache import WheelCache
   17: from pip._internal.cli import cmdoptions
   18: from pip._internal.cli.index_command import IndexGroupCommand
   19: from pip._internal.cli.index_command import SessionCommandMixin as SessionCommandMixin
   20: from pip._internal.exceptions import CommandError, PreviousBuildDirError
   21: from pip._internal.index.collector import LinkCollector
   22: from pip._internal.index.package_finder import PackageFinder
   23: from pip._internal.models.selection_prefs import SelectionPreferences
   24: from pip._internal.models.target_python import TargetPython
   25: from pip._internal.network.session import PipSession
   26: from pip._internal.operations.build.build_tracker import BuildTracker
   27: from pip._internal.operations.prepare import RequirementPreparer
   28: from pip._internal.req.constructors import (
   29:     install_req_from_editable,
   30:     install_req_from_line,
   31:     install_req_from_parsed_requirement,
   32:     install_req_from_req_string,
   33: )
   34: from pip._internal.req.req_dependency_group import parse_dependency_groups
   35: from pip._internal.req.req_file import parse_requirements
   36: from pip._internal.req.req_install import InstallRequirement
   37: from pip._internal.resolution.base import BaseResolver
   38: from pip._internal.utils.temp_dir import (
   39:     TempDirectory,
   40:     TempDirectoryTypeRegistry,
   41:     tempdir_kinds,
   42: )
   43: 
   44: logger = logging.getLogger(__name__)
   45: 
   46: 
   47: KEEPABLE_TEMPDIR_TYPES = [
   48:     tempdir_kinds.BUILD_ENV,
   49:     tempdir_kinds.EPHEM_WHEEL_CACHE,
   50:     tempdir_kinds.REQ_BUILD,
   51: ]
   52: 
   53: 
   54: def with_cleanup(func: Any) -> Any:
   55:     """Decorator for common logic related to managing temporary
   56:     directories.
   57:     """
   58: 
   59:     def configure_tempdir_registry(registry: TempDirectoryTypeRegistry) -> None:
   60:         for t in KEEPABLE_TEMPDIR_TYPES:
   61:             registry.set_delete(t, False)
   62: 
   63:     def wrapper(
   64:         self: RequirementCommand, options: Values, args: list[Any]
   65:     ) -> int | None:
   66:         assert self.tempdir_registry is not None
   67:         if options.no_clean:
   68:             configure_tempdir_registry(self.tempdir_registry)
   69: 
   70:         try:
   71:             return func(self, options, args)
   72:         except PreviousBuildDirError:
   73:             # This kind of conflict can occur when the user passes an explicit
   74:             # build directory with a pre-existing folder. In that case we do
   75:             # not want to accidentally remove it.
   76:             configure_tempdir_registry(self.tempdir_registry)
   77:             raise
   78: 
   79:     return wrapper
   80: 
   81: 
   82: class RequirementCommand(IndexGroupCommand):
   83:     def __init__(self, *args: Any, **kw: Any) -> None:
   84:         super().__init__(*args, **kw)
   85: 
   86:         self.cmd_opts.add_option(cmdoptions.dependency_groups())
   87:         self.cmd_opts.add_option(cmdoptions.no_clean())
   88: 
   89:     @staticmethod
   90:     def determine_resolver_variant(options: Values) -> str:
   91:         """Determines which resolver should be used, based on the given options."""
   92:         if "legacy-resolver" in options.deprecated_features_enabled:
   93:             return "legacy"
   94: 
   95:         return "resolvelib"
   96: 
   97:     @classmethod
   98:     def make_requirement_preparer(
   99:         cls,
  100:         temp_build_dir: TempDirectory,
  101:         options: Values,
  102:         build_tracker: BuildTracker,
  103:         session: PipSession,
  104:         finder: PackageFinder,
  105:         use_user_site: bool,
  106:         download_dir: str | None = None,
  107:         verbosity: int = 0,
  108:     ) -> RequirementPreparer:
  109:         """
  110:         Create a RequirementPreparer instance for the given parameters.
  111:         """
  112:         temp_build_dir_path = temp_build_dir.path
  113:         assert temp_build_dir_path is not None
  114:         legacy_resolver = False
  115: 
  116:         resolver_variant = cls.determine_resolver_variant(options)
  117:         if resolver_variant == "resolvelib":
  118:             lazy_wheel = "fast-deps" in options.features_enabled
  119:             if lazy_wheel:
  120:                 logger.warning(
  121:                     "pip is using lazily downloaded wheels using HTTP "
  122:                     "range requests to obtain dependency information. "
  123:                     "This experimental feature is enabled through "
  124:                     "--use-feature=fast-deps and it is not ready for "
  125:                     "production."
  126:                 )
  127:         else:
  128:             legacy_resolver = True
  129:             lazy_wheel = False
  130:             if "fast-deps" in options.features_enabled:
  131:                 logger.warning(
  132:                     "fast-deps has no effect when used with the legacy resolver."
  133:                 )
  134: 
  135:         return RequirementPreparer(
  136:             build_dir=temp_build_dir_path,
  137:             src_dir=options.src_dir,
  138:             download_dir=download_dir,
  139:             build_isolation=options.build_isolation,
  140:             build_isolation_installer=SubprocessBuildEnvironmentInstaller(finder),
  141:             check_build_deps=options.check_build_deps,
  142:             build_tracker=build_tracker,
  143:             session=session,
  144:             progress_bar=options.progress_bar,
  145:             finder=finder,
  146:             require_hashes=options.require_hashes,
  147:             use_user_site=use_user_site,
  148:             lazy_wheel=lazy_wheel,
  149:             verbosity=verbosity,
  150:             legacy_resolver=legacy_resolver,
  151:             resume_retries=options.resume_retries,
  152:         )
  153: 
  154:     @classmethod
  155:     def make_resolver(
  156:         cls,
  157:         preparer: RequirementPreparer,
  158:         finder: PackageFinder,
  159:         options: Values,
  160:         wheel_cache: WheelCache | None = None,
  161:         use_user_site: bool = False,
  162:         ignore_installed: bool = True,
  163:         ignore_requires_python: bool = False,
  164:         force_reinstall: bool = False,
  165:         upgrade_strategy: str = "to-satisfy-only",
  166:         use_pep517: bool | None = None,
  167:         py_version_info: tuple[int, ...] | None = None,
  168:     ) -> BaseResolver:
  169:         """
  170:         Create a Resolver instance for the given parameters.
  171:         """
  172:         make_install_req = partial(
  173:             install_req_from_req_string,
  174:             isolated=options.isolated_mode,
  175:             use_pep517=use_pep517,
  176:         )
  177:         resolver_variant = cls.determine_resolver_variant(options)
  178:         # The long import name and duplicated invocation is needed to convince
  179:         # Mypy into correctly typechecking. Otherwise it would complain the
  180:         # "Resolver" class being redefined.
  181:         if resolver_variant == "resolvelib":
  182:             import pip._internal.resolution.resolvelib.resolver
  183: 
  184:             return pip._internal.resolution.resolvelib.resolver.Resolver(
  185:                 preparer=preparer,
  186:                 finder=finder,
  187:                 wheel_cache=wheel_cache,
  188:                 make_install_req=make_install_req,
  189:                 use_user_site=use_user_site,
  190:                 ignore_dependencies=options.ignore_dependencies,
  191:                 ignore_installed=ignore_installed,
  192:                 ignore_requires_python=ignore_requires_python,
  193:                 force_reinstall=force_reinstall,
  194:                 upgrade_strategy=upgrade_strategy,
  195:                 py_version_info=py_version_info,
  196:             )
  197:         import pip._internal.resolution.legacy.resolver
  198: 
  199:         return pip._internal.resolution.legacy.resolver.Resolver(
  200:             preparer=preparer,
  201:             finder=finder,
  202:             wheel_cache=wheel_cache,
  203:             make_install_req=make_install_req,
  204:             use_user_site=use_user_site,
  205:             ignore_dependencies=options.ignore_dependencies,
  206:             ignore_installed=ignore_installed,
  207:             ignore_requires_python=ignore_requires_python,
  208:             force_reinstall=force_reinstall,
  209:             upgrade_strategy=upgrade_strategy,
  210:             py_version_info=py_version_info,
  211:         )
  212: 
  213:     def get_requirements(
  214:         self,
  215:         args: list[str],
  216:         options: Values,
  217:         finder: PackageFinder,
  218:         session: PipSession,
  219:     ) -> list[InstallRequirement]:
  220:         """
  221:         Parse command-line arguments into the corresponding requirements.
  222:         """
  223:         requirements: list[InstallRequirement] = []
  224:         for filename in options.constraints:
  225:             for parsed_req in parse_requirements(
  226:                 filename,
  227:                 constraint=True,
  228:                 finder=finder,
  229:                 options=options,
  230:                 session=session,
  231:             ):
  232:                 req_to_add = install_req_from_parsed_requirement(
  233:                     parsed_req,
  234:                     isolated=options.isolated_mode,
  235:                     user_supplied=False,
  236:                 )
  237:                 requirements.append(req_to_add)
  238: 
  239:         for req in args:
  240:             req_to_add = install_req_from_line(
  241:                 req,
  242:                 comes_from=None,
  243:                 isolated=options.isolated_mode,
  244:                 use_pep517=options.use_pep517,
  245:                 user_supplied=True,
  246:                 config_settings=getattr(options, "config_settings", None),
  247:             )
  248:             requirements.append(req_to_add)
  249: 
  250:         if options.dependency_groups:
  251:             for req in parse_dependency_groups(options.dependency_groups):
  252:                 req_to_add = install_req_from_req_string(
  253:                     req,
  254:                     isolated=options.isolated_mode,
  255:                     use_pep517=options.use_pep517,
  256:                     user_supplied=True,
  257:                 )
  258:                 requirements.append(req_to_add)
  259: 
  260:         for req in options.editables:
  261:             req_to_add = install_req_from_editable(
  262:                 req,
  263:                 user_supplied=True,
  264:                 isolated=options.isolated_mode,
  265:                 use_pep517=options.use_pep517,
  266:                 config_settings=getattr(options, "config_settings", None),
  267:             )
  268:             requirements.append(req_to_add)
  269: 
  270:         # NOTE: options.require_hashes may be set if --require-hashes is True
  271:         for filename in options.requirements:
  272:             for parsed_req in parse_requirements(
  273:                 filename, finder=finder, options=options, session=session
  274:             ):
  275:                 req_to_add = install_req_from_parsed_requirement(
  276:                     parsed_req,
  277:                     isolated=options.isolated_mode,
  278:                     use_pep517=options.use_pep517,
  279:                     user_supplied=True,
  280:                     config_settings=(
  281:                         parsed_req.options.get("config_settings")
  282:                         if parsed_req.options
  283:                         else None
  284:                     ),
  285:                 )
  286:                 requirements.append(req_to_add)
  287: 
  288:         # If any requirement has hash options, enable hash checking.
  289:         if any(req.has_hash_options for req in requirements):
  290:             options.require_hashes = True
  291: 
  292:         if not (
  293:             args
  294:             or options.editables
  295:             or options.requirements
  296:             or options.dependency_groups
  297:         ):
  298:             opts = {"name": self.name}
  299:             if options.find_links:
  300:                 raise CommandError(
  301:                     "You must give at least one requirement to {name} "
  302:                     '(maybe you meant "pip {name} {links}"?)'.format(
  303:                         **dict(opts, links=" ".join(options.find_links))
  304:                     )
  305:                 )
  306:             else:
  307:                 raise CommandError(
  308:                     "You must give at least one requirement to {name} "
  309:                     '(see "pip help {name}")'.format(**opts)
  310:                 )
  311: 
  312:         return requirements
  313: 
  314:     @staticmethod
  315:     def trace_basic_info(finder: PackageFinder) -> None:
  316:         """
  317:         Trace basic information about the provided objects.
  318:         """
  319:         # Display where finder is looking for packages
  320:         search_scope = finder.search_scope
  321:         locations = search_scope.get_formatted_locations()
  322:         if locations:
  323:             logger.info(locations)
  324: 
  325:     def _build_package_finder(
  326:         self,
  327:         options: Values,
  328:         session: PipSession,
  329:         target_python: TargetPython | None = None,
  330:         ignore_requires_python: bool | None = None,
  331:     ) -> PackageFinder:
  332:         """
  333:         Create a package finder appropriate to this requirement command.
  334: 
  335:         :param ignore_requires_python: Whether to ignore incompatible
  336:             "Requires-Python" values in links. Defaults to False.
  337:         """
  338:         link_collector = LinkCollector.create(session, options=options)
  339:         selection_prefs = SelectionPreferences(
  340:             allow_yanked=True,
  341:             format_control=options.format_control,
  342:             allow_all_prereleases=options.pre,
  343:             prefer_binary=options.prefer_binary,
  344:             ignore_requires_python=ignore_requires_python,
  345:         )
  346: 
  347:         return PackageFinder.create(
  348:             link_collector=link_collector,
  349:             selection_prefs=selection_prefs,
  350:             target_python=target_python,
  351:         )
