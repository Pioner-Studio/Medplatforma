    1: """Build Environment used for isolation during sdist building"""
    2: 
    3: from __future__ import annotations
    4: 
    5: import logging
    6: import os
    7: import pathlib
    8: import site
    9: import sys
   10: import textwrap
   11: from collections import OrderedDict
   12: from collections.abc import Iterable
   13: from types import TracebackType
   14: from typing import TYPE_CHECKING, Protocol
   15: 
   16: from pip._vendor.packaging.version import Version
   17: 
   18: from pip import __file__ as pip_location
   19: from pip._internal.cli.spinners import open_spinner
   20: from pip._internal.locations import get_platlib, get_purelib, get_scheme
   21: from pip._internal.metadata import get_default_environment, get_environment
   22: from pip._internal.utils.logging import VERBOSE
   23: from pip._internal.utils.packaging import get_requirement
   24: from pip._internal.utils.subprocess import call_subprocess
   25: from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds
   26: 
   27: if TYPE_CHECKING:
   28:     from pip._internal.index.package_finder import PackageFinder
   29:     from pip._internal.req.req_install import InstallRequirement
   30: 
   31: logger = logging.getLogger(__name__)
   32: 
   33: 
   34: def _dedup(a: str, b: str) -> tuple[str] | tuple[str, str]:
   35:     return (a, b) if a != b else (a,)
   36: 
   37: 
   38: class _Prefix:
   39:     def __init__(self, path: str) -> None:
   40:         self.path = path
   41:         self.setup = False
   42:         scheme = get_scheme("", prefix=path)
   43:         self.bin_dir = scheme.scripts
   44:         self.lib_dirs = _dedup(scheme.purelib, scheme.platlib)
   45: 
   46: 
   47: def get_runnable_pip() -> str:
   48:     """Get a file to pass to a Python executable, to run the currently-running pip.
   49: 
   50:     This is used to run a pip subprocess, for installing requirements into the build
   51:     environment.
   52:     """
   53:     source = pathlib.Path(pip_location).resolve().parent
   54: 
   55:     if not source.is_dir():
   56:         # This would happen if someone is using pip from inside a zip file. In that
   57:         # case, we can use that directly.
   58:         return str(source)
   59: 
   60:     return os.fsdecode(source / "__pip-runner__.py")
   61: 
   62: 
   63: def _get_system_sitepackages() -> set[str]:
   64:     """Get system site packages
   65: 
   66:     Usually from site.getsitepackages,
   67:     but fallback on `get_purelib()/get_platlib()` if unavailable
   68:     (e.g. in a virtualenv created by virtualenv<20)
   69: 
   70:     Returns normalized set of strings.
   71:     """
   72:     if hasattr(site, "getsitepackages"):
   73:         system_sites = site.getsitepackages()
   74:     else:
   75:         # virtualenv < 20 overwrites site.py without getsitepackages
   76:         # fallback on get_purelib/get_platlib.
   77:         # this is known to miss things, but shouldn't in the cases
   78:         # where getsitepackages() has been removed (inside a virtualenv)
   79:         system_sites = [get_purelib(), get_platlib()]
   80:     return {os.path.normcase(path) for path in system_sites}
   81: 
   82: 
   83: class BuildEnvironmentInstaller(Protocol):
   84:     """
   85:     Interface for installing build dependencies into an isolated build
   86:     environment.
   87:     """
   88: 
   89:     def install(
   90:         self,
   91:         requirements: Iterable[str],
   92:         prefix: _Prefix,
   93:         *,
   94:         kind: str,
   95:         for_req: InstallRequirement | None,
   96:     ) -> None: ...
   97: 
   98: 
   99: class SubprocessBuildEnvironmentInstaller:
  100:     """
  101:     Install build dependencies by calling pip in a subprocess.
  102:     """
  103: 
  104:     def __init__(self, finder: PackageFinder) -> None:
  105:         self.finder = finder
  106: 
  107:     def install(
  108:         self,
  109:         requirements: Iterable[str],
  110:         prefix: _Prefix,
  111:         *,
  112:         kind: str,
  113:         for_req: InstallRequirement | None,
  114:     ) -> None:
  115:         finder = self.finder
  116:         args: list[str] = [
  117:             sys.executable,
  118:             get_runnable_pip(),
  119:             "install",
  120:             "--ignore-installed",
  121:             "--no-user",
  122:             "--prefix",
  123:             prefix.path,
  124:             "--no-warn-script-location",
  125:             "--disable-pip-version-check",
  126:             # As the build environment is ephemeral, it's wasteful to
  127:             # pre-compile everything, especially as not every Python
  128:             # module will be used/compiled in most cases.
  129:             "--no-compile",
  130:             # The prefix specified two lines above, thus
  131:             # target from config file or env var should be ignored
  132:             "--target",
  133:             "",
  134:         ]
  135:         if logger.getEffectiveLevel() <= logging.DEBUG:
  136:             args.append("-vv")
  137:         elif logger.getEffectiveLevel() <= VERBOSE:
  138:             args.append("-v")
  139:         for format_control in ("no_binary", "only_binary"):
  140:             formats = getattr(finder.format_control, format_control)
  141:             args.extend(
  142:                 (
  143:                     "--" + format_control.replace("_", "-"),
  144:                     ",".join(sorted(formats or {":none:"})),
  145:                 )
  146:             )
  147: 
  148:         index_urls = finder.index_urls
  149:         if index_urls:
  150:             args.extend(["-i", index_urls[0]])
  151:             for extra_index in index_urls[1:]:
  152:                 args.extend(["--extra-index-url", extra_index])
  153:         else:
  154:             args.append("--no-index")
  155:         for link in finder.find_links:
  156:             args.extend(["--find-links", link])
  157: 
  158:         if finder.proxy:
  159:             args.extend(["--proxy", finder.proxy])
  160:         for host in finder.trusted_hosts:
  161:             args.extend(["--trusted-host", host])
  162:         if finder.custom_cert:
  163:             args.extend(["--cert", finder.custom_cert])
  164:         if finder.client_cert:
  165:             args.extend(["--client-cert", finder.client_cert])
  166:         if finder.allow_all_prereleases:
  167:             args.append("--pre")
  168:         if finder.prefer_binary:
  169:             args.append("--prefer-binary")
  170:         args.append("--")
  171:         args.extend(requirements)
  172:         with open_spinner(f"Installing {kind}") as spinner:
  173:             call_subprocess(
  174:                 args,
  175:                 command_desc=f"pip subprocess to install {kind}",
  176:                 spinner=spinner,
  177:             )
  178: 
  179: 
  180: class BuildEnvironment:
  181:     """Creates and manages an isolated environment to install build deps"""
  182: 
  183:     def __init__(self, installer: BuildEnvironmentInstaller) -> None:
  184:         self.installer = installer
  185:         temp_dir = TempDirectory(kind=tempdir_kinds.BUILD_ENV, globally_managed=True)
  186: 
  187:         self._prefixes = OrderedDict(
  188:             (name, _Prefix(os.path.join(temp_dir.path, name)))
  189:             for name in ("normal", "overlay")
  190:         )
  191: 
  192:         self._bin_dirs: list[str] = []
  193:         self._lib_dirs: list[str] = []
  194:         for prefix in reversed(list(self._prefixes.values())):
  195:             self._bin_dirs.append(prefix.bin_dir)
  196:             self._lib_dirs.extend(prefix.lib_dirs)
  197: 
  198:         # Customize site to:
  199:         # - ensure .pth files are honored
  200:         # - prevent access to system site packages
  201:         system_sites = _get_system_sitepackages()
  202: 
  203:         self._site_dir = os.path.join(temp_dir.path, "site")
  204:         if not os.path.exists(self._site_dir):
  205:             os.mkdir(self._site_dir)
  206:         with open(
  207:             os.path.join(self._site_dir, "sitecustomize.py"), "w", encoding="utf-8"
  208:         ) as fp:
  209:             fp.write(
  210:                 textwrap.dedent(
  211:                     """
  212:                 import os, site, sys
  213: 
  214:                 # First, drop system-sites related paths.
  215:                 original_sys_path = sys.path[:]
  216:                 known_paths = set()
  217:                 for path in {system_sites!r}:
  218:                     site.addsitedir(path, known_paths=known_paths)
  219:                 system_paths = set(
  220:                     os.path.normcase(path)
  221:                     for path in sys.path[len(original_sys_path):]
  222:                 )
  223:                 original_sys_path = [
  224:                     path for path in original_sys_path
  225:                     if os.path.normcase(path) not in system_paths
  226:                 ]
  227:                 sys.path = original_sys_path
  228: 
  229:                 # Second, add lib directories.
  230:                 # ensuring .pth file are processed.
  231:                 for path in {lib_dirs!r}:
  232:                     assert not path in sys.path
  233:                     site.addsitedir(path)
  234:                 """
  235:                 ).format(system_sites=system_sites, lib_dirs=self._lib_dirs)
  236:             )
  237: 
  238:     def __enter__(self) -> None:
  239:         self._save_env = {
  240:             name: os.environ.get(name, None)
  241:             for name in ("PATH", "PYTHONNOUSERSITE", "PYTHONPATH")
  242:         }
  243: 
  244:         path = self._bin_dirs[:]
  245:         old_path = self._save_env["PATH"]
  246:         if old_path:
  247:             path.extend(old_path.split(os.pathsep))
  248: 
  249:         pythonpath = [self._site_dir]
  250: 
  251:         os.environ.update(
  252:             {
  253:                 "PATH": os.pathsep.join(path),
  254:                 "PYTHONNOUSERSITE": "1",
  255:                 "PYTHONPATH": os.pathsep.join(pythonpath),
  256:             }
  257:         )
  258: 
  259:     def __exit__(
  260:         self,
  261:         exc_type: type[BaseException] | None,
  262:         exc_val: BaseException | None,
  263:         exc_tb: TracebackType | None,
  264:     ) -> None:
  265:         for varname, old_value in self._save_env.items():
  266:             if old_value is None:
  267:                 os.environ.pop(varname, None)
  268:             else:
  269:                 os.environ[varname] = old_value
  270: 
  271:     def check_requirements(
  272:         self, reqs: Iterable[str]
  273:     ) -> tuple[set[tuple[str, str]], set[str]]:
  274:         """Return 2 sets:
  275:         - conflicting requirements: set of (installed, wanted) reqs tuples
  276:         - missing requirements: set of reqs
  277:         """
  278:         missing = set()
  279:         conflicting = set()
  280:         if reqs:
  281:             env = (
  282:                 get_environment(self._lib_dirs)
  283:                 if hasattr(self, "_lib_dirs")
  284:                 else get_default_environment()
  285:             )
  286:             for req_str in reqs:
  287:                 req = get_requirement(req_str)
  288:                 # We're explicitly evaluating with an empty extra value, since build
  289:                 # environments are not provided any mechanism to select specific extras.
  290:                 if req.marker is not None and not req.marker.evaluate({"extra": ""}):
  291:                     continue
  292:                 dist = env.get_distribution(req.name)
  293:                 if not dist:
  294:                     missing.add(req_str)
  295:                     continue
  296:                 if isinstance(dist.version, Version):
  297:                     installed_req_str = f"{req.name}=={dist.version}"
  298:                 else:
  299:                     installed_req_str = f"{req.name}==={dist.version}"
  300:                 if not req.specifier.contains(dist.version, prereleases=True):
  301:                     conflicting.add((installed_req_str, req_str))
  302:                 # FIXME: Consider direct URL?
  303:         return conflicting, missing
  304: 
  305:     def install_requirements(
  306:         self,
  307:         requirements: Iterable[str],
  308:         prefix_as_string: str,
  309:         *,
  310:         kind: str,
  311:         for_req: InstallRequirement | None = None,
  312:     ) -> None:
  313:         prefix = self._prefixes[prefix_as_string]
  314:         assert not prefix.setup
  315:         prefix.setup = True
  316:         if not requirements:
  317:             return
  318:         self.installer.install(requirements, prefix, kind=kind, for_req=for_req)
  319: 
  320: 
  321: class NoOpBuildEnvironment(BuildEnvironment):
  322:     """A no-op drop-in replacement for BuildEnvironment"""
  323: 
  324:     def __init__(self) -> None:
  325:         pass
  326: 
  327:     def __enter__(self) -> None:
  328:         pass
  329: 
  330:     def __exit__(
  331:         self,
  332:         exc_type: type[BaseException] | None,
  333:         exc_val: BaseException | None,
  334:         exc_tb: TracebackType | None,
  335:     ) -> None:
  336:         pass
  337: 
  338:     def cleanup(self) -> None:
  339:         pass
  340: 
  341:     def install_requirements(
  342:         self,
  343:         requirements: Iterable[str],
  344:         prefix_as_string: str,
  345:         *,
  346:         kind: str,
  347:         for_req: InstallRequirement | None = None,
  348:     ) -> None:
  349:         raise NotImplementedError()
