    1: """Cache Management"""
    2: 
    3: from __future__ import annotations
    4: 
    5: import hashlib
    6: import json
    7: import logging
    8: import os
    9: from pathlib import Path
   10: from typing import Any
   11: 
   12: from pip._vendor.packaging.tags import Tag, interpreter_name, interpreter_version
   13: from pip._vendor.packaging.utils import canonicalize_name
   14: 
   15: from pip._internal.exceptions import InvalidWheelFilename
   16: from pip._internal.models.direct_url import DirectUrl
   17: from pip._internal.models.link import Link
   18: from pip._internal.models.wheel import Wheel
   19: from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds
   20: from pip._internal.utils.urls import path_to_url
   21: 
   22: logger = logging.getLogger(__name__)
   23: 
   24: ORIGIN_JSON_NAME = "origin.json"
   25: 
   26: 
   27: def _hash_dict(d: dict[str, str]) -> str:
   28:     """Return a stable sha224 of a dictionary."""
   29:     s = json.dumps(d, sort_keys=True, separators=(",", ":"), ensure_ascii=True)
   30:     return hashlib.sha224(s.encode("ascii")).hexdigest()
   31: 
   32: 
   33: class Cache:
   34:     """An abstract class - provides cache directories for data from links
   35: 
   36:     :param cache_dir: The root of the cache.
   37:     """
   38: 
   39:     def __init__(self, cache_dir: str) -> None:
   40:         super().__init__()
   41:         assert not cache_dir or os.path.isabs(cache_dir)
   42:         self.cache_dir = cache_dir or None
   43: 
   44:     def _get_cache_path_parts(self, link: Link) -> list[str]:
   45:         """Get parts of part that must be os.path.joined with cache_dir"""
   46: 
   47:         # We want to generate an url to use as our cache key, we don't want to
   48:         # just reuse the URL because it might have other items in the fragment
   49:         # and we don't care about those.
   50:         key_parts = {"url": link.url_without_fragment}
   51:         if link.hash_name is not None and link.hash is not None:
   52:             key_parts[link.hash_name] = link.hash
   53:         if link.subdirectory_fragment:
   54:             key_parts["subdirectory"] = link.subdirectory_fragment
   55: 
   56:         # Include interpreter name, major and minor version in cache key
   57:         # to cope with ill-behaved sdists that build a different wheel
   58:         # depending on the python version their setup.py is being run on,
   59:         # and don't encode the difference in compatibility tags.
   60:         # https://github.com/pypa/pip/issues/7296
   61:         key_parts["interpreter_name"] = interpreter_name()
   62:         key_parts["interpreter_version"] = interpreter_version()
   63: 
   64:         # Encode our key url with sha224, we'll use this because it has similar
   65:         # security properties to sha256, but with a shorter total output (and
   66:         # thus less secure). However the differences don't make a lot of
   67:         # difference for our use case here.
   68:         hashed = _hash_dict(key_parts)
   69: 
   70:         # We want to nest the directories some to prevent having a ton of top
   71:         # level directories where we might run out of sub directories on some
   72:         # FS.
   73:         parts = [hashed[:2], hashed[2:4], hashed[4:6], hashed[6:]]
   74: 
   75:         return parts
   76: 
   77:     def _get_candidates(self, link: Link, canonical_package_name: str) -> list[Any]:
   78:         can_not_cache = not self.cache_dir or not canonical_package_name or not link
   79:         if can_not_cache:
   80:             return []
   81: 
   82:         path = self.get_path_for_link(link)
   83:         if os.path.isdir(path):
   84:             return [(candidate, path) for candidate in os.listdir(path)]
   85:         return []
   86: 
   87:     def get_path_for_link(self, link: Link) -> str:
   88:         """Return a directory to store cached items in for link."""
   89:         raise NotImplementedError()
   90: 
   91:     def get(
   92:         self,
   93:         link: Link,
   94:         package_name: str | None,
   95:         supported_tags: list[Tag],
   96:     ) -> Link:
   97:         """Returns a link to a cached item if it exists, otherwise returns the
   98:         passed link.
   99:         """
  100:         raise NotImplementedError()
  101: 
  102: 
  103: class SimpleWheelCache(Cache):
  104:     """A cache of wheels for future installs."""
  105: 
  106:     def __init__(self, cache_dir: str) -> None:
  107:         super().__init__(cache_dir)
  108: 
  109:     def get_path_for_link(self, link: Link) -> str:
  110:         """Return a directory to store cached wheels for link
  111: 
  112:         Because there are M wheels for any one sdist, we provide a directory
  113:         to cache them in, and then consult that directory when looking up
  114:         cache hits.
  115: 
  116:         We only insert things into the cache if they have plausible version
  117:         numbers, so that we don't contaminate the cache with things that were
  118:         not unique. E.g. ./package might have dozens of installs done for it
  119:         and build a version of 0.0...and if we built and cached a wheel, we'd
  120:         end up using the same wheel even if the source has been edited.
  121: 
  122:         :param link: The link of the sdist for which this will cache wheels.
  123:         """
  124:         parts = self._get_cache_path_parts(link)
  125:         assert self.cache_dir
  126:         # Store wheels within the root cache_dir
  127:         return os.path.join(self.cache_dir, "wheels", *parts)
  128: 
  129:     def get(
  130:         self,
  131:         link: Link,
  132:         package_name: str | None,
  133:         supported_tags: list[Tag],
  134:     ) -> Link:
  135:         candidates = []
  136: 
  137:         if not package_name:
  138:             return link
  139: 
  140:         canonical_package_name = canonicalize_name(package_name)
  141:         for wheel_name, wheel_dir in self._get_candidates(link, canonical_package_name):
  142:             try:
  143:                 wheel = Wheel(wheel_name)
  144:             except InvalidWheelFilename:
  145:                 continue
  146:             if canonicalize_name(wheel.name) != canonical_package_name:
  147:                 logger.debug(
  148:                     "Ignoring cached wheel %s for %s as it "
  149:                     "does not match the expected distribution name %s.",
  150:                     wheel_name,
  151:                     link,
  152:                     package_name,
  153:                 )
  154:                 continue
  155:             if not wheel.supported(supported_tags):
  156:                 # Built for a different python/arch/etc
  157:                 continue
  158:             candidates.append(
  159:                 (
  160:                     wheel.support_index_min(supported_tags),
  161:                     wheel_name,
  162:                     wheel_dir,
  163:                 )
  164:             )
  165: 
  166:         if not candidates:
  167:             return link
  168: 
  169:         _, wheel_name, wheel_dir = min(candidates)
  170:         return Link(path_to_url(os.path.join(wheel_dir, wheel_name)))
  171: 
  172: 
  173: class EphemWheelCache(SimpleWheelCache):
  174:     """A SimpleWheelCache that creates it's own temporary cache directory"""
  175: 
  176:     def __init__(self) -> None:
  177:         self._temp_dir = TempDirectory(
  178:             kind=tempdir_kinds.EPHEM_WHEEL_CACHE,
  179:             globally_managed=True,
  180:         )
  181: 
  182:         super().__init__(self._temp_dir.path)
  183: 
  184: 
  185: class CacheEntry:
  186:     def __init__(
  187:         self,
  188:         link: Link,
  189:         persistent: bool,
  190:     ):
  191:         self.link = link
  192:         self.persistent = persistent
  193:         self.origin: DirectUrl | None = None
  194:         origin_direct_url_path = Path(self.link.file_path).parent / ORIGIN_JSON_NAME
  195:         if origin_direct_url_path.exists():
  196:             try:
  197:                 self.origin = DirectUrl.from_json(
  198:                     origin_direct_url_path.read_text(encoding="utf-8")
  199:                 )
  200:             except Exception as e:
  201:                 logger.warning(
  202:                     "Ignoring invalid cache entry origin file %s for %s (%s)",
  203:                     origin_direct_url_path,
  204:                     link.filename,
  205:                     e,
  206:                 )
  207: 
  208: 
  209: class WheelCache(Cache):
  210:     """Wraps EphemWheelCache and SimpleWheelCache into a single Cache
  211: 
  212:     This Cache allows for gracefully degradation, using the ephem wheel cache
  213:     when a certain link is not found in the simple wheel cache first.
  214:     """
  215: 
  216:     def __init__(self, cache_dir: str) -> None:
  217:         super().__init__(cache_dir)
  218:         self._wheel_cache = SimpleWheelCache(cache_dir)
  219:         self._ephem_cache = EphemWheelCache()
  220: 
  221:     def get_path_for_link(self, link: Link) -> str:
  222:         return self._wheel_cache.get_path_for_link(link)
  223: 
  224:     def get_ephem_path_for_link(self, link: Link) -> str:
  225:         return self._ephem_cache.get_path_for_link(link)
  226: 
  227:     def get(
  228:         self,
  229:         link: Link,
  230:         package_name: str | None,
  231:         supported_tags: list[Tag],
  232:     ) -> Link:
  233:         cache_entry = self.get_cache_entry(link, package_name, supported_tags)
  234:         if cache_entry is None:
  235:             return link
  236:         return cache_entry.link
  237: 
  238:     def get_cache_entry(
  239:         self,
  240:         link: Link,
  241:         package_name: str | None,
  242:         supported_tags: list[Tag],
  243:     ) -> CacheEntry | None:
  244:         """Returns a CacheEntry with a link to a cached item if it exists or
  245:         None. The cache entry indicates if the item was found in the persistent
  246:         or ephemeral cache.
  247:         """
  248:         retval = self._wheel_cache.get(
  249:             link=link,
  250:             package_name=package_name,
  251:             supported_tags=supported_tags,
  252:         )
  253:         if retval is not link:
  254:             return CacheEntry(retval, persistent=True)
  255: 
  256:         retval = self._ephem_cache.get(
  257:             link=link,
  258:             package_name=package_name,
  259:             supported_tags=supported_tags,
  260:         )
  261:         if retval is not link:
  262:             return CacheEntry(retval, persistent=False)
  263: 
  264:         return None
  265: 
  266:     @staticmethod
  267:     def record_download_origin(cache_dir: str, download_info: DirectUrl) -> None:
  268:         origin_path = Path(cache_dir) / ORIGIN_JSON_NAME
  269:         if origin_path.exists():
  270:             try:
  271:                 origin = DirectUrl.from_json(origin_path.read_text(encoding="utf-8"))
  272:             except Exception as e:
  273:                 logger.warning(
  274:                     "Could not read origin file %s in cache entry (%s). "
  275:                     "Will attempt to overwrite it.",
  276:                     origin_path,
  277:                     e,
  278:                 )
  279:             else:
  280:                 # TODO: use DirectUrl.equivalent when
  281:                 # https://github.com/pypa/pip/pull/10564 is merged.
  282:                 if origin.url != download_info.url:
  283:                     logger.warning(
  284:                         "Origin URL %s in cache entry %s does not match download URL "
  285:                         "%s. This is likely a pip bug or a cache corruption issue. "
  286:                         "Will overwrite it with the new value.",
  287:                         origin.url,
  288:                         cache_dir,
  289:                         download_info.url,
  290:                     )
  291:         origin_path.write_text(download_info.to_json(), encoding="utf-8")
