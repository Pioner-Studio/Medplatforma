    1: from __future__ import annotations
    2: 
    3: import logging
    4: import sys
    5: from collections.abc import Iterable
    6: from typing import TYPE_CHECKING, Any, Union, cast
    7: 
    8: from pip._vendor.packaging.requirements import InvalidRequirement
    9: from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
   10: from pip._vendor.packaging.version import Version
   11: 
   12: from pip._internal.exceptions import (
   13:     HashError,
   14:     InstallationSubprocessError,
   15:     InvalidInstalledPackage,
   16:     MetadataInconsistent,
   17:     MetadataInvalid,
   18: )
   19: from pip._internal.metadata import BaseDistribution
   20: from pip._internal.models.link import Link, links_equivalent
   21: from pip._internal.models.wheel import Wheel
   22: from pip._internal.req.constructors import (
   23:     install_req_from_editable,
   24:     install_req_from_line,
   25: )
   26: from pip._internal.req.req_install import InstallRequirement
   27: from pip._internal.utils.direct_url_helpers import direct_url_from_link
   28: from pip._internal.utils.misc import normalize_version_info
   29: 
   30: from .base import Candidate, Requirement, format_name
   31: 
   32: if TYPE_CHECKING:
   33:     from .factory import Factory
   34: 
   35: logger = logging.getLogger(__name__)
   36: 
   37: BaseCandidate = Union[
   38:     "AlreadyInstalledCandidate",
   39:     "EditableCandidate",
   40:     "LinkCandidate",
   41: ]
   42: 
   43: # Avoid conflicting with the PyPI package "Python".
   44: REQUIRES_PYTHON_IDENTIFIER = cast(NormalizedName, "<Python from Requires-Python>")
   45: 
   46: 
   47: def as_base_candidate(candidate: Candidate) -> BaseCandidate | None:
   48:     """The runtime version of BaseCandidate."""
   49:     base_candidate_classes = (
   50:         AlreadyInstalledCandidate,
   51:         EditableCandidate,
   52:         LinkCandidate,
   53:     )
   54:     if isinstance(candidate, base_candidate_classes):
   55:         return candidate
   56:     return None
   57: 
   58: 
   59: def make_install_req_from_link(
   60:     link: Link, template: InstallRequirement
   61: ) -> InstallRequirement:
   62:     assert not template.editable, "template is editable"
   63:     if template.req:
   64:         line = str(template.req)
   65:     else:
   66:         line = link.url
   67:     ireq = install_req_from_line(
   68:         line,
   69:         user_supplied=template.user_supplied,
   70:         comes_from=template.comes_from,
   71:         use_pep517=template.use_pep517,
   72:         isolated=template.isolated,
   73:         constraint=template.constraint,
   74:         global_options=template.global_options,
   75:         hash_options=template.hash_options,
   76:         config_settings=template.config_settings,
   77:     )
   78:     ireq.original_link = template.original_link
   79:     ireq.link = link
   80:     ireq.extras = template.extras
   81:     return ireq
   82: 
   83: 
   84: def make_install_req_from_editable(
   85:     link: Link, template: InstallRequirement
   86: ) -> InstallRequirement:
   87:     assert template.editable, "template not editable"
   88:     ireq = install_req_from_editable(
   89:         link.url,
   90:         user_supplied=template.user_supplied,
   91:         comes_from=template.comes_from,
   92:         use_pep517=template.use_pep517,
   93:         isolated=template.isolated,
   94:         constraint=template.constraint,
   95:         permit_editable_wheels=template.permit_editable_wheels,
   96:         global_options=template.global_options,
   97:         hash_options=template.hash_options,
   98:         config_settings=template.config_settings,
   99:     )
  100:     ireq.extras = template.extras
  101:     return ireq
  102: 
  103: 
  104: def _make_install_req_from_dist(
  105:     dist: BaseDistribution, template: InstallRequirement
  106: ) -> InstallRequirement:
  107:     if template.req:
  108:         line = str(template.req)
  109:     elif template.link:
  110:         line = f"{dist.canonical_name} @ {template.link.url}"
  111:     else:
  112:         line = f"{dist.canonical_name}=={dist.version}"
  113:     ireq = install_req_from_line(
  114:         line,
  115:         user_supplied=template.user_supplied,
  116:         comes_from=template.comes_from,
  117:         use_pep517=template.use_pep517,
  118:         isolated=template.isolated,
  119:         constraint=template.constraint,
  120:         global_options=template.global_options,
  121:         hash_options=template.hash_options,
  122:         config_settings=template.config_settings,
  123:     )
  124:     ireq.satisfied_by = dist
  125:     return ireq
  126: 
  127: 
  128: class _InstallRequirementBackedCandidate(Candidate):
  129:     """A candidate backed by an ``InstallRequirement``.
  130: 
  131:     This represents a package request with the target not being already
  132:     in the environment, and needs to be fetched and installed. The backing
  133:     ``InstallRequirement`` is responsible for most of the leg work; this
  134:     class exposes appropriate information to the resolver.
  135: 
  136:     :param link: The link passed to the ``InstallRequirement``. The backing
  137:         ``InstallRequirement`` will use this link to fetch the distribution.
  138:     :param source_link: The link this candidate "originates" from. This is
  139:         different from ``link`` when the link is found in the wheel cache.
  140:         ``link`` would point to the wheel cache, while this points to the
  141:         found remote link (e.g. from pypi.org).
  142:     """
  143: 
  144:     dist: BaseDistribution
  145:     is_installed = False
  146: 
  147:     def __init__(
  148:         self,
  149:         link: Link,
  150:         source_link: Link,
  151:         ireq: InstallRequirement,
  152:         factory: Factory,
  153:         name: NormalizedName | None = None,
  154:         version: Version | None = None,
  155:     ) -> None:
  156:         self._link = link
  157:         self._source_link = source_link
  158:         self._factory = factory
  159:         self._ireq = ireq
  160:         self._name = name
  161:         self._version = version
  162:         self.dist = self._prepare()
  163:         self._hash: int | None = None
  164: 
  165:     def __str__(self) -> str:
  166:         return f"{self.name} {self.version}"
  167: 
  168:     def __repr__(self) -> str:
  169:         return f"{self.__class__.__name__}({str(self._link)!r})"
  170: 
  171:     def __hash__(self) -> int:
  172:         if self._hash is not None:
  173:             return self._hash
  174: 
  175:         self._hash = hash((self.__class__, self._link))
  176:         return self._hash
  177: 
  178:     def __eq__(self, other: Any) -> bool:
  179:         if isinstance(other, self.__class__):
  180:             return links_equivalent(self._link, other._link)
  181:         return False
  182: 
  183:     @property
  184:     def source_link(self) -> Link | None:
  185:         return self._source_link
  186: 
  187:     @property
  188:     def project_name(self) -> NormalizedName:
  189:         """The normalised name of the project the candidate refers to"""
  190:         if self._name is None:
  191:             self._name = self.dist.canonical_name
  192:         return self._name
  193: 
  194:     @property
  195:     def name(self) -> str:
  196:         return self.project_name
  197: 
  198:     @property
  199:     def version(self) -> Version:
  200:         if self._version is None:
  201:             self._version = self.dist.version
  202:         return self._version
  203: 
  204:     def format_for_error(self) -> str:
  205:         return (
  206:             f"{self.name} {self.version} "
  207:             f"(from {self._link.file_path if self._link.is_file else self._link})"
  208:         )
  209: 
  210:     def _prepare_distribution(self) -> BaseDistribution:
  211:         raise NotImplementedError("Override in subclass")
  212: 
  213:     def _check_metadata_consistency(self, dist: BaseDistribution) -> None:
  214:         """Check for consistency of project name and version of dist."""
  215:         if self._name is not None and self._name != dist.canonical_name:
  216:             raise MetadataInconsistent(
  217:                 self._ireq,
  218:                 "name",
  219:                 self._name,
  220:                 dist.canonical_name,
  221:             )
  222:         if self._version is not None and self._version != dist.version:
  223:             raise MetadataInconsistent(
  224:                 self._ireq,
  225:                 "version",
  226:                 str(self._version),
  227:                 str(dist.version),
  228:             )
  229:         # check dependencies are valid
  230:         # TODO performance: this means we iterate the dependencies at least twice,
  231:         # we may want to cache parsed Requires-Dist
  232:         try:
  233:             list(dist.iter_dependencies(list(dist.iter_provided_extras())))
  234:         except InvalidRequirement as e:
  235:             raise MetadataInvalid(self._ireq, str(e))
  236: 
  237:     def _prepare(self) -> BaseDistribution:
  238:         try:
  239:             dist = self._prepare_distribution()
  240:         except HashError as e:
  241:             # Provide HashError the underlying ireq that caused it. This
  242:             # provides context for the resulting error message to show the
  243:             # offending line to the user.
  244:             e.req = self._ireq
  245:             raise
  246:         except InstallationSubprocessError as exc:
  247:             # The output has been presented already, so don't duplicate it.
  248:             exc.context = "See above for output."
  249:             raise
  250: 
  251:         self._check_metadata_consistency(dist)
  252:         return dist
  253: 
  254:     def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
  255:         # Emit the Requires-Python requirement first to fail fast on
  256:         # unsupported candidates and avoid pointless downloads/preparation.
  257:         yield self._factory.make_requires_python_requirement(self.dist.requires_python)
  258:         requires = self.dist.iter_dependencies() if with_requires else ()
  259:         for r in requires:
  260:             yield from self._factory.make_requirements_from_spec(str(r), self._ireq)
  261: 
  262:     def get_install_requirement(self) -> InstallRequirement | None:
  263:         return self._ireq
  264: 
  265: 
  266: class LinkCandidate(_InstallRequirementBackedCandidate):
  267:     is_editable = False
  268: 
  269:     def __init__(
  270:         self,
  271:         link: Link,
  272:         template: InstallRequirement,
  273:         factory: Factory,
  274:         name: NormalizedName | None = None,
  275:         version: Version | None = None,
  276:     ) -> None:
  277:         source_link = link
  278:         cache_entry = factory.get_wheel_cache_entry(source_link, name)
  279:         if cache_entry is not None:
  280:             logger.debug("Using cached wheel link: %s", cache_entry.link)
  281:             link = cache_entry.link
  282:         ireq = make_install_req_from_link(link, template)
  283:         assert ireq.link == link
  284:         if ireq.link.is_wheel and not ireq.link.is_file:
  285:             wheel = Wheel(ireq.link.filename)
  286:             wheel_name = canonicalize_name(wheel.name)
  287:             assert name == wheel_name, f"{name!r} != {wheel_name!r} for wheel"
  288:             # Version may not be present for PEP 508 direct URLs
  289:             if version is not None:
  290:                 wheel_version = Version(wheel.version)
  291:                 assert (
  292:                     version == wheel_version
  293:                 ), f"{version!r} != {wheel_version!r} for wheel {name}"
  294: 
  295:         if cache_entry is not None:
  296:             assert ireq.link.is_wheel
  297:             assert ireq.link.is_file
  298:             if cache_entry.persistent and template.link is template.original_link:
  299:                 ireq.cached_wheel_source_link = source_link
  300:             if cache_entry.origin is not None:
  301:                 ireq.download_info = cache_entry.origin
  302:             else:
  303:                 # Legacy cache entry that does not have origin.json.
  304:                 # download_info may miss the archive_info.hashes field.
  305:                 ireq.download_info = direct_url_from_link(
  306:                     source_link, link_is_in_wheel_cache=cache_entry.persistent
  307:                 )
  308: 
  309:         super().__init__(
  310:             link=link,
  311:             source_link=source_link,
  312:             ireq=ireq,
  313:             factory=factory,
  314:             name=name,
  315:             version=version,
  316:         )
  317: 
  318:     def _prepare_distribution(self) -> BaseDistribution:
  319:         preparer = self._factory.preparer
  320:         return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
  321: 
  322: 
  323: class EditableCandidate(_InstallRequirementBackedCandidate):
  324:     is_editable = True
  325: 
  326:     def __init__(
  327:         self,
  328:         link: Link,
  329:         template: InstallRequirement,
  330:         factory: Factory,
  331:         name: NormalizedName | None = None,
  332:         version: Version | None = None,
  333:     ) -> None:
  334:         super().__init__(
  335:             link=link,
  336:             source_link=link,
  337:             ireq=make_install_req_from_editable(link, template),
  338:             factory=factory,
  339:             name=name,
  340:             version=version,
  341:         )
  342: 
  343:     def _prepare_distribution(self) -> BaseDistribution:
  344:         return self._factory.preparer.prepare_editable_requirement(self._ireq)
  345: 
  346: 
  347: class AlreadyInstalledCandidate(Candidate):
  348:     is_installed = True
  349:     source_link = None
  350: 
  351:     def __init__(
  352:         self,
  353:         dist: BaseDistribution,
  354:         template: InstallRequirement,
  355:         factory: Factory,
  356:     ) -> None:
  357:         self.dist = dist
  358:         self._ireq = _make_install_req_from_dist(dist, template)
  359:         self._factory = factory
  360:         self._version = None
  361: 
  362:         # This is just logging some messages, so we can do it eagerly.
  363:         # The returned dist would be exactly the same as self.dist because we
  364:         # set satisfied_by in _make_install_req_from_dist.
  365:         # TODO: Supply reason based on force_reinstall and upgrade_strategy.
  366:         skip_reason = "already satisfied"
  367:         factory.preparer.prepare_installed_requirement(self._ireq, skip_reason)
  368: 
  369:     def __str__(self) -> str:
  370:         return str(self.dist)
  371: 
  372:     def __repr__(self) -> str:
  373:         return f"{self.__class__.__name__}({self.dist!r})"
  374: 
  375:     def __eq__(self, other: object) -> bool:
  376:         if not isinstance(other, AlreadyInstalledCandidate):
  377:             return NotImplemented
  378:         return self.name == other.name and self.version == other.version
  379: 
  380:     def __hash__(self) -> int:
  381:         return hash((self.name, self.version))
  382: 
  383:     @property
  384:     def project_name(self) -> NormalizedName:
  385:         return self.dist.canonical_name
  386: 
  387:     @property
  388:     def name(self) -> str:
  389:         return self.project_name
  390: 
  391:     @property
  392:     def version(self) -> Version:
  393:         if self._version is None:
  394:             self._version = self.dist.version
  395:         return self._version
  396: 
  397:     @property
  398:     def is_editable(self) -> bool:
  399:         return self.dist.editable
  400: 
  401:     def format_for_error(self) -> str:
  402:         return f"{self.name} {self.version} (Installed)"
  403: 
  404:     def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
  405:         if not with_requires:
  406:             return
  407: 
  408:         try:
  409:             for r in self.dist.iter_dependencies():
  410:                 yield from self._factory.make_requirements_from_spec(str(r), self._ireq)
  411:         except InvalidRequirement as exc:
  412:             raise InvalidInstalledPackage(dist=self.dist, invalid_exc=exc) from None
  413: 
  414:     def get_install_requirement(self) -> InstallRequirement | None:
  415:         return None
  416: 
  417: 
  418: class ExtrasCandidate(Candidate):
  419:     """A candidate that has 'extras', indicating additional dependencies.
  420: 
  421:     Requirements can be for a project with dependencies, something like
  422:     foo[extra].  The extras don't affect the project/version being installed
  423:     directly, but indicate that we need additional dependencies. We model that
  424:     by having an artificial ExtrasCandidate that wraps the "base" candidate.
  425: 
  426:     The ExtrasCandidate differs from the base in the following ways:
  427: 
  428:     1. It has a unique name, of the form foo[extra]. This causes the resolver
  429:        to treat it as a separate node in the dependency graph.
  430:     2. When we're getting the candidate's dependencies,
  431:        a) We specify that we want the extra dependencies as well.
  432:        b) We add a dependency on the base candidate.
  433:           See below for why this is needed.
  434:     3. We return None for the underlying InstallRequirement, as the base
  435:        candidate will provide it, and we don't want to end up with duplicates.
  436: 
  437:     The dependency on the base candidate is needed so that the resolver can't
  438:     decide that it should recommend foo[extra1] version 1.0 and foo[extra2]
  439:     version 2.0. Having those candidates depend on foo=1.0 and foo=2.0
  440:     respectively forces the resolver to recognise that this is a conflict.
  441:     """
  442: 
  443:     def __init__(
  444:         self,
  445:         base: BaseCandidate,
  446:         extras: frozenset[str],
  447:         *,
  448:         comes_from: InstallRequirement | None = None,
  449:     ) -> None:
  450:         """
  451:         :param comes_from: the InstallRequirement that led to this candidate if it
  452:             differs from the base's InstallRequirement. This will often be the
  453:             case in the sense that this candidate's requirement has the extras
  454:             while the base's does not. Unlike the InstallRequirement backed
  455:             candidates, this requirement is used solely for reporting purposes,
  456:             it does not do any leg work.
  457:         """
  458:         self.base = base
  459:         self.extras = frozenset(canonicalize_name(e) for e in extras)
  460:         self._comes_from = comes_from if comes_from is not None else self.base._ireq
  461: 
  462:     def __str__(self) -> str:
  463:         name, rest = str(self.base).split(" ", 1)
  464:         return "{}[{}] {}".format(name, ",".join(self.extras), rest)
  465: 
  466:     def __repr__(self) -> str:
  467:         return f"{self.__class__.__name__}(base={self.base!r}, extras={self.extras!r})"
  468: 
  469:     def __hash__(self) -> int:
  470:         return hash((self.base, self.extras))
  471: 
  472:     def __eq__(self, other: Any) -> bool:
  473:         if isinstance(other, self.__class__):
  474:             return self.base == other.base and self.extras == other.extras
  475:         return False
  476: 
  477:     @property
  478:     def project_name(self) -> NormalizedName:
  479:         return self.base.project_name
  480: 
  481:     @property
  482:     def name(self) -> str:
  483:         """The normalised name of the project the candidate refers to"""
  484:         return format_name(self.base.project_name, self.extras)
  485: 
  486:     @property
  487:     def version(self) -> Version:
  488:         return self.base.version
  489: 
  490:     def format_for_error(self) -> str:
  491:         return "{} [{}]".format(
  492:             self.base.format_for_error(), ", ".join(sorted(self.extras))
  493:         )
  494: 
  495:     @property
  496:     def is_installed(self) -> bool:
  497:         return self.base.is_installed
  498: 
  499:     @property
  500:     def is_editable(self) -> bool:
  501:         return self.base.is_editable
  502: 
  503:     @property
  504:     def source_link(self) -> Link | None:
  505:         return self.base.source_link
  506: 
  507:     def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
  508:         factory = self.base._factory
  509: 
  510:         # Add a dependency on the exact base
  511:         # (See note 2b in the class docstring)
  512:         yield factory.make_requirement_from_candidate(self.base)
  513:         if not with_requires:
  514:             return
  515: 
  516:         # The user may have specified extras that the candidate doesn't
  517:         # support. We ignore any unsupported extras here.
  518:         valid_extras = self.extras.intersection(self.base.dist.iter_provided_extras())
  519:         invalid_extras = self.extras.difference(self.base.dist.iter_provided_extras())
  520:         for extra in sorted(invalid_extras):
  521:             logger.warning(
  522:                 "%s %s does not provide the extra '%s'",
  523:                 self.base.name,
  524:                 self.version,
  525:                 extra,
  526:             )
  527: 
  528:         for r in self.base.dist.iter_dependencies(valid_extras):
  529:             yield from factory.make_requirements_from_spec(
  530:                 str(r),
  531:                 self._comes_from,
  532:                 valid_extras,
  533:             )
  534: 
  535:     def get_install_requirement(self) -> InstallRequirement | None:
  536:         # We don't return anything here, because we always
  537:         # depend on the base candidate, and we'll get the
  538:         # install requirement from that.
  539:         return None
  540: 
  541: 
  542: class RequiresPythonCandidate(Candidate):
  543:     is_installed = False
  544:     source_link = None
  545: 
  546:     def __init__(self, py_version_info: tuple[int, ...] | None) -> None:
  547:         if py_version_info is not None:
  548:             version_info = normalize_version_info(py_version_info)
  549:         else:
  550:             version_info = sys.version_info[:3]
  551:         self._version = Version(".".join(str(c) for c in version_info))
  552: 
  553:     # We don't need to implement __eq__() and __ne__() since there is always
  554:     # only one RequiresPythonCandidate in a resolution, i.e. the host Python.
  555:     # The built-in object.__eq__() and object.__ne__() do exactly what we want.
  556: 
  557:     def __str__(self) -> str:
  558:         return f"Python {self._version}"
  559: 
  560:     def __repr__(self) -> str:
  561:         return f"{self.__class__.__name__}({self._version!r})"
  562: 
  563:     @property
  564:     def project_name(self) -> NormalizedName:
  565:         return REQUIRES_PYTHON_IDENTIFIER
  566: 
  567:     @property
  568:     def name(self) -> str:
  569:         return REQUIRES_PYTHON_IDENTIFIER
  570: 
  571:     @property
  572:     def version(self) -> Version:
  573:         return self._version
  574: 
  575:     def format_for_error(self) -> str:
  576:         return f"Python {self.version}"
  577: 
  578:     def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
  579:         return ()
  580: 
  581:     def get_install_requirement(self) -> InstallRequirement | None:
  582:         return None
