    1: from __future__ import annotations
    2: 
    3: from collections.abc import Iterable
    4: from dataclasses import dataclass
    5: from typing import Optional
    6: 
    7: from pip._vendor.packaging.specifiers import SpecifierSet
    8: from pip._vendor.packaging.utils import NormalizedName
    9: from pip._vendor.packaging.version import Version
   10: 
   11: from pip._internal.models.link import Link, links_equivalent
   12: from pip._internal.req.req_install import InstallRequirement
   13: from pip._internal.utils.hashes import Hashes
   14: 
   15: CandidateLookup = tuple[Optional["Candidate"], Optional[InstallRequirement]]
   16: 
   17: 
   18: def format_name(project: NormalizedName, extras: frozenset[NormalizedName]) -> str:
   19:     if not extras:
   20:         return project
   21:     extras_expr = ",".join(sorted(extras))
   22:     return f"{project}[{extras_expr}]"
   23: 
   24: 
   25: @dataclass(frozen=True)
   26: class Constraint:
   27:     specifier: SpecifierSet
   28:     hashes: Hashes
   29:     links: frozenset[Link]
   30: 
   31:     @classmethod
   32:     def empty(cls) -> Constraint:
   33:         return Constraint(SpecifierSet(), Hashes(), frozenset())
   34: 
   35:     @classmethod
   36:     def from_ireq(cls, ireq: InstallRequirement) -> Constraint:
   37:         links = frozenset([ireq.link]) if ireq.link else frozenset()
   38:         return Constraint(ireq.specifier, ireq.hashes(trust_internet=False), links)
   39: 
   40:     def __bool__(self) -> bool:
   41:         return bool(self.specifier) or bool(self.hashes) or bool(self.links)
   42: 
   43:     def __and__(self, other: InstallRequirement) -> Constraint:
   44:         if not isinstance(other, InstallRequirement):
   45:             return NotImplemented
   46:         specifier = self.specifier & other.specifier
   47:         hashes = self.hashes & other.hashes(trust_internet=False)
   48:         links = self.links
   49:         if other.link:
   50:             links = links.union([other.link])
   51:         return Constraint(specifier, hashes, links)
   52: 
   53:     def is_satisfied_by(self, candidate: Candidate) -> bool:
   54:         # Reject if there are any mismatched URL constraints on this package.
   55:         if self.links and not all(_match_link(link, candidate) for link in self.links):
   56:             return False
   57:         # We can safely always allow prereleases here since PackageFinder
   58:         # already implements the prerelease logic, and would have filtered out
   59:         # prerelease candidates if the user does not expect them.
   60:         return self.specifier.contains(candidate.version, prereleases=True)
   61: 
   62: 
   63: class Requirement:
   64:     @property
   65:     def project_name(self) -> NormalizedName:
   66:         """The "project name" of a requirement.
   67: 
   68:         This is different from ``name`` if this requirement contains extras,
   69:         in which case ``name`` would contain the ``[...]`` part, while this
   70:         refers to the name of the project.
   71:         """
   72:         raise NotImplementedError("Subclass should override")
   73: 
   74:     @property
   75:     def name(self) -> str:
   76:         """The name identifying this requirement in the resolver.
   77: 
   78:         This is different from ``project_name`` if this requirement contains
   79:         extras, where ``project_name`` would not contain the ``[...]`` part.
   80:         """
   81:         raise NotImplementedError("Subclass should override")
   82: 
   83:     def is_satisfied_by(self, candidate: Candidate) -> bool:
   84:         return False
   85: 
   86:     def get_candidate_lookup(self) -> CandidateLookup:
   87:         raise NotImplementedError("Subclass should override")
   88: 
   89:     def format_for_error(self) -> str:
   90:         raise NotImplementedError("Subclass should override")
   91: 
   92: 
   93: def _match_link(link: Link, candidate: Candidate) -> bool:
   94:     if candidate.source_link:
   95:         return links_equivalent(link, candidate.source_link)
   96:     return False
   97: 
   98: 
   99: class Candidate:
  100:     @property
  101:     def project_name(self) -> NormalizedName:
  102:         """The "project name" of the candidate.
  103: 
  104:         This is different from ``name`` if this candidate contains extras,
  105:         in which case ``name`` would contain the ``[...]`` part, while this
  106:         refers to the name of the project.
  107:         """
  108:         raise NotImplementedError("Override in subclass")
  109: 
  110:     @property
  111:     def name(self) -> str:
  112:         """The name identifying this candidate in the resolver.
  113: 
  114:         This is different from ``project_name`` if this candidate contains
  115:         extras, where ``project_name`` would not contain the ``[...]`` part.
  116:         """
  117:         raise NotImplementedError("Override in subclass")
  118: 
  119:     @property
  120:     def version(self) -> Version:
  121:         raise NotImplementedError("Override in subclass")
  122: 
  123:     @property
  124:     def is_installed(self) -> bool:
  125:         raise NotImplementedError("Override in subclass")
  126: 
  127:     @property
  128:     def is_editable(self) -> bool:
  129:         raise NotImplementedError("Override in subclass")
  130: 
  131:     @property
  132:     def source_link(self) -> Link | None:
  133:         raise NotImplementedError("Override in subclass")
  134: 
  135:     def iter_dependencies(self, with_requires: bool) -> Iterable[Requirement | None]:
  136:         raise NotImplementedError("Override in subclass")
  137: 
  138:     def get_install_requirement(self) -> InstallRequirement | None:
  139:         raise NotImplementedError("Override in subclass")
  140: 
  141:     def format_for_error(self) -> str:
  142:         raise NotImplementedError("Subclass should override")
