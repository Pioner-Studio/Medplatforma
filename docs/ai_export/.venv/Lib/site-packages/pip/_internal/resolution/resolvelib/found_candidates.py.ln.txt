    1: """Utilities to lazily create and visit candidates found.
    2: 
    3: Creating and visiting a candidate is a *very* costly operation. It involves
    4: fetching, extracting, potentially building modules from source, and verifying
    5: distribution metadata. It is therefore crucial for performance to keep
    6: everything here lazy all the way down, so we only touch candidates that we
    7: absolutely need, and not "download the world" when we only need one version of
    8: something.
    9: """
   10: 
   11: from __future__ import annotations
   12: 
   13: import logging
   14: from collections.abc import Iterator, Sequence
   15: from typing import Any, Callable, Optional
   16: 
   17: from pip._vendor.packaging.version import _BaseVersion
   18: 
   19: from pip._internal.exceptions import MetadataInvalid
   20: 
   21: from .base import Candidate
   22: 
   23: logger = logging.getLogger(__name__)
   24: 
   25: IndexCandidateInfo = tuple[_BaseVersion, Callable[[], Optional[Candidate]]]
   26: 
   27: 
   28: def _iter_built(infos: Iterator[IndexCandidateInfo]) -> Iterator[Candidate]:
   29:     """Iterator for ``FoundCandidates``.
   30: 
   31:     This iterator is used when the package is not already installed. Candidates
   32:     from index come later in their normal ordering.
   33:     """
   34:     versions_found: set[_BaseVersion] = set()
   35:     for version, func in infos:
   36:         if version in versions_found:
   37:             continue
   38:         try:
   39:             candidate = func()
   40:         except MetadataInvalid as e:
   41:             logger.warning(
   42:                 "Ignoring version %s of %s since it has invalid metadata:\n"
   43:                 "%s\n"
   44:                 "Please use pip<24.1 if you need to use this version.",
   45:                 version,
   46:                 e.ireq.name,
   47:                 e,
   48:             )
   49:             # Mark version as found to avoid trying other candidates with the same
   50:             # version, since they most likely have invalid metadata as well.
   51:             versions_found.add(version)
   52:         else:
   53:             if candidate is None:
   54:                 continue
   55:             yield candidate
   56:             versions_found.add(version)
   57: 
   58: 
   59: def _iter_built_with_prepended(
   60:     installed: Candidate, infos: Iterator[IndexCandidateInfo]
   61: ) -> Iterator[Candidate]:
   62:     """Iterator for ``FoundCandidates``.
   63: 
   64:     This iterator is used when the resolver prefers the already-installed
   65:     candidate and NOT to upgrade. The installed candidate is therefore
   66:     always yielded first, and candidates from index come later in their
   67:     normal ordering, except skipped when the version is already installed.
   68:     """
   69:     yield installed
   70:     versions_found: set[_BaseVersion] = {installed.version}
   71:     for version, func in infos:
   72:         if version in versions_found:
   73:             continue
   74:         candidate = func()
   75:         if candidate is None:
   76:             continue
   77:         yield candidate
   78:         versions_found.add(version)
   79: 
   80: 
   81: def _iter_built_with_inserted(
   82:     installed: Candidate, infos: Iterator[IndexCandidateInfo]
   83: ) -> Iterator[Candidate]:
   84:     """Iterator for ``FoundCandidates``.
   85: 
   86:     This iterator is used when the resolver prefers to upgrade an
   87:     already-installed package. Candidates from index are returned in their
   88:     normal ordering, except replaced when the version is already installed.
   89: 
   90:     The implementation iterates through and yields other candidates, inserting
   91:     the installed candidate exactly once before we start yielding older or
   92:     equivalent candidates, or after all other candidates if they are all newer.
   93:     """
   94:     versions_found: set[_BaseVersion] = set()
   95:     for version, func in infos:
   96:         if version in versions_found:
   97:             continue
   98:         # If the installed candidate is better, yield it first.
   99:         if installed.version >= version:
  100:             yield installed
  101:             versions_found.add(installed.version)
  102:         candidate = func()
  103:         if candidate is None:
  104:             continue
  105:         yield candidate
  106:         versions_found.add(version)
  107: 
  108:     # If the installed candidate is older than all other candidates.
  109:     if installed.version not in versions_found:
  110:         yield installed
  111: 
  112: 
  113: class FoundCandidates(Sequence[Candidate]):
  114:     """A lazy sequence to provide candidates to the resolver.
  115: 
  116:     The intended usage is to return this from `find_matches()` so the resolver
  117:     can iterate through the sequence multiple times, but only access the index
  118:     page when remote packages are actually needed. This improve performances
  119:     when suitable candidates are already installed on disk.
  120:     """
  121: 
  122:     def __init__(
  123:         self,
  124:         get_infos: Callable[[], Iterator[IndexCandidateInfo]],
  125:         installed: Candidate | None,
  126:         prefers_installed: bool,
  127:         incompatible_ids: set[int],
  128:     ):
  129:         self._get_infos = get_infos
  130:         self._installed = installed
  131:         self._prefers_installed = prefers_installed
  132:         self._incompatible_ids = incompatible_ids
  133:         self._bool: bool | None = None
  134: 
  135:     def __getitem__(self, index: Any) -> Any:
  136:         # Implemented to satisfy the ABC check. This is not needed by the
  137:         # resolver, and should not be used by the provider either (for
  138:         # performance reasons).
  139:         raise NotImplementedError("don't do this")
  140: 
  141:     def __iter__(self) -> Iterator[Candidate]:
  142:         infos = self._get_infos()
  143:         if not self._installed:
  144:             iterator = _iter_built(infos)
  145:         elif self._prefers_installed:
  146:             iterator = _iter_built_with_prepended(self._installed, infos)
  147:         else:
  148:             iterator = _iter_built_with_inserted(self._installed, infos)
  149:         return (c for c in iterator if id(c) not in self._incompatible_ids)
  150: 
  151:     def __len__(self) -> int:
  152:         # Implemented to satisfy the ABC check. This is not needed by the
  153:         # resolver, and should not be used by the provider either (for
  154:         # performance reasons).
  155:         raise NotImplementedError("don't do this")
  156: 
  157:     def __bool__(self) -> bool:
  158:         if self._bool is not None:
  159:             return self._bool
  160: 
  161:         if self._prefers_installed and self._installed:
  162:             self._bool = True
  163:             return True
  164: 
  165:         self._bool = any(self)
  166:         return self._bool
