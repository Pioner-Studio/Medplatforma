    1: from __future__ import annotations
    2: 
    3: from typing import Any
    4: 
    5: from pip._vendor.packaging.specifiers import SpecifierSet
    6: from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    7: 
    8: from pip._internal.req.constructors import install_req_drop_extras
    9: from pip._internal.req.req_install import InstallRequirement
   10: 
   11: from .base import Candidate, CandidateLookup, Requirement, format_name
   12: 
   13: 
   14: class ExplicitRequirement(Requirement):
   15:     def __init__(self, candidate: Candidate) -> None:
   16:         self.candidate = candidate
   17: 
   18:     def __str__(self) -> str:
   19:         return str(self.candidate)
   20: 
   21:     def __repr__(self) -> str:
   22:         return f"{self.__class__.__name__}({self.candidate!r})"
   23: 
   24:     def __hash__(self) -> int:
   25:         return hash(self.candidate)
   26: 
   27:     def __eq__(self, other: Any) -> bool:
   28:         if not isinstance(other, ExplicitRequirement):
   29:             return False
   30:         return self.candidate == other.candidate
   31: 
   32:     @property
   33:     def project_name(self) -> NormalizedName:
   34:         # No need to canonicalize - the candidate did this
   35:         return self.candidate.project_name
   36: 
   37:     @property
   38:     def name(self) -> str:
   39:         # No need to canonicalize - the candidate did this
   40:         return self.candidate.name
   41: 
   42:     def format_for_error(self) -> str:
   43:         return self.candidate.format_for_error()
   44: 
   45:     def get_candidate_lookup(self) -> CandidateLookup:
   46:         return self.candidate, None
   47: 
   48:     def is_satisfied_by(self, candidate: Candidate) -> bool:
   49:         return candidate == self.candidate
   50: 
   51: 
   52: class SpecifierRequirement(Requirement):
   53:     def __init__(self, ireq: InstallRequirement) -> None:
   54:         assert ireq.link is None, "This is a link, not a specifier"
   55:         self._ireq = ireq
   56:         self._equal_cache: str | None = None
   57:         self._hash: int | None = None
   58:         self._extras = frozenset(canonicalize_name(e) for e in self._ireq.extras)
   59: 
   60:     @property
   61:     def _equal(self) -> str:
   62:         if self._equal_cache is not None:
   63:             return self._equal_cache
   64: 
   65:         self._equal_cache = str(self._ireq)
   66:         return self._equal_cache
   67: 
   68:     def __str__(self) -> str:
   69:         return str(self._ireq.req)
   70: 
   71:     def __repr__(self) -> str:
   72:         return f"{self.__class__.__name__}({str(self._ireq.req)!r})"
   73: 
   74:     def __eq__(self, other: object) -> bool:
   75:         if not isinstance(other, SpecifierRequirement):
   76:             return NotImplemented
   77:         return self._equal == other._equal
   78: 
   79:     def __hash__(self) -> int:
   80:         if self._hash is not None:
   81:             return self._hash
   82: 
   83:         self._hash = hash(self._equal)
   84:         return self._hash
   85: 
   86:     @property
   87:     def project_name(self) -> NormalizedName:
   88:         assert self._ireq.req, "Specifier-backed ireq is always PEP 508"
   89:         return canonicalize_name(self._ireq.req.name)
   90: 
   91:     @property
   92:     def name(self) -> str:
   93:         return format_name(self.project_name, self._extras)
   94: 
   95:     def format_for_error(self) -> str:
   96:         # Convert comma-separated specifiers into "A, B, ..., F and G"
   97:         # This makes the specifier a bit more "human readable", without
   98:         # risking a change in meaning. (Hopefully! Not all edge cases have
   99:         # been checked)
  100:         parts = [s.strip() for s in str(self).split(",")]
  101:         if len(parts) == 0:
  102:             return ""
  103:         elif len(parts) == 1:
  104:             return parts[0]
  105: 
  106:         return ", ".join(parts[:-1]) + " and " + parts[-1]
  107: 
  108:     def get_candidate_lookup(self) -> CandidateLookup:
  109:         return None, self._ireq
  110: 
  111:     def is_satisfied_by(self, candidate: Candidate) -> bool:
  112:         assert candidate.name == self.name, (
  113:             f"Internal issue: Candidate is not for this requirement "
  114:             f"{candidate.name} vs {self.name}"
  115:         )
  116:         # We can safely always allow prereleases here since PackageFinder
  117:         # already implements the prerelease logic, and would have filtered out
  118:         # prerelease candidates if the user does not expect them.
  119:         assert self._ireq.req, "Specifier-backed ireq is always PEP 508"
  120:         spec = self._ireq.req.specifier
  121:         return spec.contains(candidate.version, prereleases=True)
  122: 
  123: 
  124: class SpecifierWithoutExtrasRequirement(SpecifierRequirement):
  125:     """
  126:     Requirement backed by an install requirement on a base package.
  127:     Trims extras from its install requirement if there are any.
  128:     """
  129: 
  130:     def __init__(self, ireq: InstallRequirement) -> None:
  131:         assert ireq.link is None, "This is a link, not a specifier"
  132:         self._ireq = install_req_drop_extras(ireq)
  133:         self._equal_cache: str | None = None
  134:         self._hash: int | None = None
  135:         self._extras = frozenset(canonicalize_name(e) for e in self._ireq.extras)
  136: 
  137:     @property
  138:     def _equal(self) -> str:
  139:         if self._equal_cache is not None:
  140:             return self._equal_cache
  141: 
  142:         self._equal_cache = str(self._ireq)
  143:         return self._equal_cache
  144: 
  145:     def __eq__(self, other: object) -> bool:
  146:         if not isinstance(other, SpecifierWithoutExtrasRequirement):
  147:             return NotImplemented
  148:         return self._equal == other._equal
  149: 
  150:     def __hash__(self) -> int:
  151:         if self._hash is not None:
  152:             return self._hash
  153: 
  154:         self._hash = hash(self._equal)
  155:         return self._hash
  156: 
  157: 
  158: class RequiresPythonRequirement(Requirement):
  159:     """A requirement representing Requires-Python metadata."""
  160: 
  161:     def __init__(self, specifier: SpecifierSet, match: Candidate) -> None:
  162:         self.specifier = specifier
  163:         self._specifier_string = str(specifier)  # for faster __eq__
  164:         self._hash: int | None = None
  165:         self._candidate = match
  166: 
  167:     def __str__(self) -> str:
  168:         return f"Python {self.specifier}"
  169: 
  170:     def __repr__(self) -> str:
  171:         return f"{self.__class__.__name__}({str(self.specifier)!r})"
  172: 
  173:     def __hash__(self) -> int:
  174:         if self._hash is not None:
  175:             return self._hash
  176: 
  177:         self._hash = hash((self._specifier_string, self._candidate))
  178:         return self._hash
  179: 
  180:     def __eq__(self, other: Any) -> bool:
  181:         if not isinstance(other, RequiresPythonRequirement):
  182:             return False
  183:         return (
  184:             self._specifier_string == other._specifier_string
  185:             and self._candidate == other._candidate
  186:         )
  187: 
  188:     @property
  189:     def project_name(self) -> NormalizedName:
  190:         return self._candidate.project_name
  191: 
  192:     @property
  193:     def name(self) -> str:
  194:         return self._candidate.name
  195: 
  196:     def format_for_error(self) -> str:
  197:         return str(self)
  198: 
  199:     def get_candidate_lookup(self) -> CandidateLookup:
  200:         if self.specifier.contains(self._candidate.version, prereleases=True):
  201:             return self._candidate, None
  202:         return None, None
  203: 
  204:     def is_satisfied_by(self, candidate: Candidate) -> bool:
  205:         assert candidate.name == self._candidate.name, "Not Python candidate"
  206:         # We can safely always allow prereleases here since PackageFinder
  207:         # already implements the prerelease logic, and would have filtered out
  208:         # prerelease candidates if the user does not expect them.
  209:         return self.specifier.contains(candidate.version, prereleases=True)
  210: 
  211: 
  212: class UnsatisfiableRequirement(Requirement):
  213:     """A requirement that cannot be satisfied."""
  214: 
  215:     def __init__(self, name: NormalizedName) -> None:
  216:         self._name = name
  217: 
  218:     def __str__(self) -> str:
  219:         return f"{self._name} (unavailable)"
  220: 
  221:     def __repr__(self) -> str:
  222:         return f"{self.__class__.__name__}({str(self._name)!r})"
  223: 
  224:     def __eq__(self, other: object) -> bool:
  225:         if not isinstance(other, UnsatisfiableRequirement):
  226:             return NotImplemented
  227:         return self._name == other._name
  228: 
  229:     def __hash__(self) -> int:
  230:         return hash(self._name)
  231: 
  232:     @property
  233:     def project_name(self) -> NormalizedName:
  234:         return self._name
  235: 
  236:     @property
  237:     def name(self) -> str:
  238:         return self._name
  239: 
  240:     def format_for_error(self) -> str:
  241:         return str(self)
  242: 
  243:     def get_candidate_lookup(self) -> CandidateLookup:
  244:         return None, None
  245: 
  246:     def is_satisfied_by(self, candidate: Candidate) -> bool:
  247:         return False
