    1: from __future__ import annotations
    2: 
    3: import math
    4: from collections.abc import Iterable, Iterator, Mapping, Sequence
    5: from functools import cache
    6: from typing import (
    7:     TYPE_CHECKING,
    8:     TypeVar,
    9: )
   10: 
   11: from pip._vendor.resolvelib.providers import AbstractProvider
   12: 
   13: from pip._internal.req.req_install import InstallRequirement
   14: 
   15: from .base import Candidate, Constraint, Requirement
   16: from .candidates import REQUIRES_PYTHON_IDENTIFIER
   17: from .factory import Factory
   18: from .requirements import ExplicitRequirement
   19: 
   20: if TYPE_CHECKING:
   21:     from pip._vendor.resolvelib.providers import Preference
   22:     from pip._vendor.resolvelib.resolvers import RequirementInformation
   23: 
   24:     PreferenceInformation = RequirementInformation[Requirement, Candidate]
   25: 
   26:     _ProviderBase = AbstractProvider[Requirement, Candidate, str]
   27: else:
   28:     _ProviderBase = AbstractProvider
   29: 
   30: # Notes on the relationship between the provider, the factory, and the
   31: # candidate and requirement classes.
   32: #
   33: # The provider is a direct implementation of the resolvelib class. Its role
   34: # is to deliver the API that resolvelib expects.
   35: #
   36: # Rather than work with completely abstract "requirement" and "candidate"
   37: # concepts as resolvelib does, pip has concrete classes implementing these two
   38: # ideas. The API of Requirement and Candidate objects are defined in the base
   39: # classes, but essentially map fairly directly to the equivalent provider
   40: # methods. In particular, `find_matches` and `is_satisfied_by` are
   41: # requirement methods, and `get_dependencies` is a candidate method.
   42: #
   43: # The factory is the interface to pip's internal mechanisms. It is stateless,
   44: # and is created by the resolver and held as a property of the provider. It is
   45: # responsible for creating Requirement and Candidate objects, and provides
   46: # services to those objects (access to pip's finder and preparer).
   47: 
   48: 
   49: D = TypeVar("D")
   50: V = TypeVar("V")
   51: 
   52: 
   53: def _get_with_identifier(
   54:     mapping: Mapping[str, V],
   55:     identifier: str,
   56:     default: D,
   57: ) -> D | V:
   58:     """Get item from a package name lookup mapping with a resolver identifier.
   59: 
   60:     This extra logic is needed when the target mapping is keyed by package
   61:     name, which cannot be directly looked up with an identifier (which may
   62:     contain requested extras). Additional logic is added to also look up a value
   63:     by "cleaning up" the extras from the identifier.
   64:     """
   65:     if identifier in mapping:
   66:         return mapping[identifier]
   67:     # HACK: Theoretically we should check whether this identifier is a valid
   68:     # "NAME[EXTRAS]" format, and parse out the name part with packaging or
   69:     # some regular expression. But since pip's resolver only spits out three
   70:     # kinds of identifiers: normalized PEP 503 names, normalized names plus
   71:     # extras, and Requires-Python, we can cheat a bit here.
   72:     name, open_bracket, _ = identifier.partition("[")
   73:     if open_bracket and name in mapping:
   74:         return mapping[name]
   75:     return default
   76: 
   77: 
   78: class PipProvider(_ProviderBase):
   79:     """Pip's provider implementation for resolvelib.
   80: 
   81:     :params constraints: A mapping of constraints specified by the user. Keys
   82:         are canonicalized project names.
   83:     :params ignore_dependencies: Whether the user specified ``--no-deps``.
   84:     :params upgrade_strategy: The user-specified upgrade strategy.
   85:     :params user_requested: A set of canonicalized package names that the user
   86:         supplied for pip to install/upgrade.
   87:     """
   88: 
   89:     def __init__(
   90:         self,
   91:         factory: Factory,
   92:         constraints: dict[str, Constraint],
   93:         ignore_dependencies: bool,
   94:         upgrade_strategy: str,
   95:         user_requested: dict[str, int],
   96:     ) -> None:
   97:         self._factory = factory
   98:         self._constraints = constraints
   99:         self._ignore_dependencies = ignore_dependencies
  100:         self._upgrade_strategy = upgrade_strategy
  101:         self._user_requested = user_requested
  102: 
  103:     def identify(self, requirement_or_candidate: Requirement | Candidate) -> str:
  104:         return requirement_or_candidate.name
  105: 
  106:     def narrow_requirement_selection(
  107:         self,
  108:         identifiers: Iterable[str],
  109:         resolutions: Mapping[str, Candidate],
  110:         candidates: Mapping[str, Iterator[Candidate]],
  111:         information: Mapping[str, Iterator[PreferenceInformation]],
  112:         backtrack_causes: Sequence[PreferenceInformation],
  113:     ) -> Iterable[str]:
  114:         """Produce a subset of identifiers that should be considered before others.
  115: 
  116:         Currently pip narrows the following selection:
  117:             * Requires-Python, if present is always returned by itself
  118:             * Backtrack causes are considered next because they can be identified
  119:               in linear time here, whereas because get_preference() is called
  120:               for each identifier, it would be quadratic to check for them there.
  121:               Further, the current backtrack causes likely need to be resolved
  122:               before other requirements as a resolution can't be found while
  123:               there is a conflict.
  124:         """
  125:         backtrack_identifiers = set()
  126:         for info in backtrack_causes:
  127:             backtrack_identifiers.add(info.requirement.name)
  128:             if info.parent is not None:
  129:                 backtrack_identifiers.add(info.parent.name)
  130: 
  131:         current_backtrack_causes = []
  132:         for identifier in identifiers:
  133:             # Requires-Python has only one candidate and the check is basically
  134:             # free, so we always do it first to avoid needless work if it fails.
  135:             # This skips calling get_preference() for all other identifiers.
  136:             if identifier == REQUIRES_PYTHON_IDENTIFIER:
  137:                 return [identifier]
  138: 
  139:             # Check if this identifier is a backtrack cause
  140:             if identifier in backtrack_identifiers:
  141:                 current_backtrack_causes.append(identifier)
  142:                 continue
  143: 
  144:         if current_backtrack_causes:
  145:             return current_backtrack_causes
  146: 
  147:         return identifiers
  148: 
  149:     def get_preference(
  150:         self,
  151:         identifier: str,
  152:         resolutions: Mapping[str, Candidate],
  153:         candidates: Mapping[str, Iterator[Candidate]],
  154:         information: Mapping[str, Iterable[PreferenceInformation]],
  155:         backtrack_causes: Sequence[PreferenceInformation],
  156:     ) -> Preference:
  157:         """Produce a sort key for given requirement based on preference.
  158: 
  159:         The lower the return value is, the more preferred this group of
  160:         arguments is.
  161: 
  162:         Currently pip considers the following in order:
  163: 
  164:         * Any requirement that is "direct", e.g., points to an explicit URL.
  165:         * Any requirement that is "pinned", i.e., contains the operator ``===``
  166:           or ``==`` without a wildcard.
  167:         * Any requirement that imposes an upper version limit, i.e., contains the
  168:           operator ``<``, ``<=``, ``~=``, or ``==`` with a wildcard. Because
  169:           pip prioritizes the latest version, preferring explicit upper bounds
  170:           can rule out infeasible candidates sooner. This does not imply that
  171:           upper bounds are good practice; they can make dependency management
  172:           and resolution harder.
  173:         * Order user-specified requirements as they are specified, placing
  174:           other requirements afterward.
  175:         * Any "non-free" requirement, i.e., one that contains at least one
  176:           operator, such as ``>=`` or ``!=``.
  177:         * Alphabetical order for consistency (aids debuggability).
  178:         """
  179:         try:
  180:             next(iter(information[identifier]))
  181:         except StopIteration:
  182:             # There is no information for this identifier, so there's no known
  183:             # candidates.
  184:             has_information = False
  185:         else:
  186:             has_information = True
  187: 
  188:         if not has_information:
  189:             direct = False
  190:             ireqs: tuple[InstallRequirement | None, ...] = ()
  191:         else:
  192:             # Go through the information and for each requirement,
  193:             # check if it's explicit (e.g., a direct link) and get the
  194:             # InstallRequirement (the second element) from get_candidate_lookup()
  195:             directs, ireqs = zip(
  196:                 *(
  197:                     (isinstance(r, ExplicitRequirement), r.get_candidate_lookup()[1])
  198:                     for r, _ in information[identifier]
  199:                 )
  200:             )
  201:             direct = any(directs)
  202: 
  203:         operators: list[tuple[str, str]] = [
  204:             (specifier.operator, specifier.version)
  205:             for specifier_set in (ireq.specifier for ireq in ireqs if ireq)
  206:             for specifier in specifier_set
  207:         ]
  208: 
  209:         pinned = any(((op[:2] == "==") and ("*" not in ver)) for op, ver in operators)
  210:         upper_bounded = any(
  211:             ((op in ("<", "<=", "~=")) or (op == "==" and "*" in ver))
  212:             for op, ver in operators
  213:         )
  214:         unfree = bool(operators)
  215:         requested_order = self._user_requested.get(identifier, math.inf)
  216: 
  217:         return (
  218:             not direct,
  219:             not pinned,
  220:             not upper_bounded,
  221:             requested_order,
  222:             not unfree,
  223:             identifier,
  224:         )
  225: 
  226:     def find_matches(
  227:         self,
  228:         identifier: str,
  229:         requirements: Mapping[str, Iterator[Requirement]],
  230:         incompatibilities: Mapping[str, Iterator[Candidate]],
  231:     ) -> Iterable[Candidate]:
  232:         def _eligible_for_upgrade(identifier: str) -> bool:
  233:             """Are upgrades allowed for this project?
  234: 
  235:             This checks the upgrade strategy, and whether the project was one
  236:             that the user specified in the command line, in order to decide
  237:             whether we should upgrade if there's a newer version available.
  238: 
  239:             (Note that we don't need access to the `--upgrade` flag, because
  240:             an upgrade strategy of "to-satisfy-only" means that `--upgrade`
  241:             was not specified).
  242:             """
  243:             if self._upgrade_strategy == "eager":
  244:                 return True
  245:             elif self._upgrade_strategy == "only-if-needed":
  246:                 user_order = _get_with_identifier(
  247:                     self._user_requested,
  248:                     identifier,
  249:                     default=None,
  250:                 )
  251:                 return user_order is not None
  252:             return False
  253: 
  254:         constraint = _get_with_identifier(
  255:             self._constraints,
  256:             identifier,
  257:             default=Constraint.empty(),
  258:         )
  259:         return self._factory.find_candidates(
  260:             identifier=identifier,
  261:             requirements=requirements,
  262:             constraint=constraint,
  263:             prefers_installed=(not _eligible_for_upgrade(identifier)),
  264:             incompatibilities=incompatibilities,
  265:             is_satisfied_by=self.is_satisfied_by,
  266:         )
  267: 
  268:     @staticmethod
  269:     @cache
  270:     def is_satisfied_by(requirement: Requirement, candidate: Candidate) -> bool:
  271:         return requirement.is_satisfied_by(candidate)
  272: 
  273:     def get_dependencies(self, candidate: Candidate) -> Iterable[Requirement]:
  274:         with_requires = not self._ignore_dependencies
  275:         # iter_dependencies() can perform nontrivial work so delay until needed.
  276:         return (r for r in candidate.iter_dependencies(with_requires) if r is not None)
