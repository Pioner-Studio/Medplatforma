    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import functools
    5: import logging
    6: from collections.abc import Iterable, Iterator, Mapping, Sequence
    7: from typing import (
    8:     TYPE_CHECKING,
    9:     Callable,
   10:     NamedTuple,
   11:     Protocol,
   12:     TypeVar,
   13:     cast,
   14: )
   15: 
   16: from pip._vendor.packaging.requirements import InvalidRequirement
   17: from pip._vendor.packaging.specifiers import SpecifierSet
   18: from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
   19: from pip._vendor.packaging.version import InvalidVersion, Version
   20: from pip._vendor.resolvelib import ResolutionImpossible
   21: 
   22: from pip._internal.cache import CacheEntry, WheelCache
   23: from pip._internal.exceptions import (
   24:     DistributionNotFound,
   25:     InstallationError,
   26:     InvalidInstalledPackage,
   27:     MetadataInconsistent,
   28:     MetadataInvalid,
   29:     UnsupportedPythonVersion,
   30:     UnsupportedWheel,
   31: )
   32: from pip._internal.index.package_finder import PackageFinder
   33: from pip._internal.metadata import BaseDistribution, get_default_environment
   34: from pip._internal.models.link import Link
   35: from pip._internal.models.wheel import Wheel
   36: from pip._internal.operations.prepare import RequirementPreparer
   37: from pip._internal.req.constructors import (
   38:     install_req_drop_extras,
   39:     install_req_from_link_and_ireq,
   40: )
   41: from pip._internal.req.req_install import (
   42:     InstallRequirement,
   43:     check_invalid_constraint_type,
   44: )
   45: from pip._internal.resolution.base import InstallRequirementProvider
   46: from pip._internal.utils.compatibility_tags import get_supported
   47: from pip._internal.utils.hashes import Hashes
   48: from pip._internal.utils.packaging import get_requirement
   49: from pip._internal.utils.virtualenv import running_under_virtualenv
   50: 
   51: from .base import Candidate, Constraint, Requirement
   52: from .candidates import (
   53:     AlreadyInstalledCandidate,
   54:     BaseCandidate,
   55:     EditableCandidate,
   56:     ExtrasCandidate,
   57:     LinkCandidate,
   58:     RequiresPythonCandidate,
   59:     as_base_candidate,
   60: )
   61: from .found_candidates import FoundCandidates, IndexCandidateInfo
   62: from .requirements import (
   63:     ExplicitRequirement,
   64:     RequiresPythonRequirement,
   65:     SpecifierRequirement,
   66:     SpecifierWithoutExtrasRequirement,
   67:     UnsatisfiableRequirement,
   68: )
   69: 
   70: if TYPE_CHECKING:
   71: 
   72:     class ConflictCause(Protocol):
   73:         requirement: RequiresPythonRequirement
   74:         parent: Candidate
   75: 
   76: 
   77: logger = logging.getLogger(__name__)
   78: 
   79: C = TypeVar("C")
   80: Cache = dict[Link, C]
   81: 
   82: 
   83: class CollectedRootRequirements(NamedTuple):
   84:     requirements: list[Requirement]
   85:     constraints: dict[str, Constraint]
   86:     user_requested: dict[str, int]
   87: 
   88: 
   89: class Factory:
   90:     def __init__(
   91:         self,
   92:         finder: PackageFinder,
   93:         preparer: RequirementPreparer,
   94:         make_install_req: InstallRequirementProvider,
   95:         wheel_cache: WheelCache | None,
   96:         use_user_site: bool,
   97:         force_reinstall: bool,
   98:         ignore_installed: bool,
   99:         ignore_requires_python: bool,
  100:         py_version_info: tuple[int, ...] | None = None,
  101:     ) -> None:
  102:         self._finder = finder
  103:         self.preparer = preparer
  104:         self._wheel_cache = wheel_cache
  105:         self._python_candidate = RequiresPythonCandidate(py_version_info)
  106:         self._make_install_req_from_spec = make_install_req
  107:         self._use_user_site = use_user_site
  108:         self._force_reinstall = force_reinstall
  109:         self._ignore_requires_python = ignore_requires_python
  110: 
  111:         self._build_failures: Cache[InstallationError] = {}
  112:         self._link_candidate_cache: Cache[LinkCandidate] = {}
  113:         self._editable_candidate_cache: Cache[EditableCandidate] = {}
  114:         self._installed_candidate_cache: dict[str, AlreadyInstalledCandidate] = {}
  115:         self._extras_candidate_cache: dict[
  116:             tuple[int, frozenset[NormalizedName]], ExtrasCandidate
  117:         ] = {}
  118:         self._supported_tags_cache = get_supported()
  119: 
  120:         if not ignore_installed:
  121:             env = get_default_environment()
  122:             self._installed_dists = {
  123:                 dist.canonical_name: dist
  124:                 for dist in env.iter_installed_distributions(local_only=False)
  125:             }
  126:         else:
  127:             self._installed_dists = {}
  128: 
  129:     @property
  130:     def force_reinstall(self) -> bool:
  131:         return self._force_reinstall
  132: 
  133:     def _fail_if_link_is_unsupported_wheel(self, link: Link) -> None:
  134:         if not link.is_wheel:
  135:             return
  136:         wheel = Wheel(link.filename)
  137:         if wheel.supported(self._finder.target_python.get_unsorted_tags()):
  138:             return
  139:         msg = f"{link.filename} is not a supported wheel on this platform."
  140:         raise UnsupportedWheel(msg)
  141: 
  142:     def _make_extras_candidate(
  143:         self,
  144:         base: BaseCandidate,
  145:         extras: frozenset[str],
  146:         *,
  147:         comes_from: InstallRequirement | None = None,
  148:     ) -> ExtrasCandidate:
  149:         cache_key = (id(base), frozenset(canonicalize_name(e) for e in extras))
  150:         try:
  151:             candidate = self._extras_candidate_cache[cache_key]
  152:         except KeyError:
  153:             candidate = ExtrasCandidate(base, extras, comes_from=comes_from)
  154:             self._extras_candidate_cache[cache_key] = candidate
  155:         return candidate
  156: 
  157:     def _make_candidate_from_dist(
  158:         self,
  159:         dist: BaseDistribution,
  160:         extras: frozenset[str],
  161:         template: InstallRequirement,
  162:     ) -> Candidate:
  163:         try:
  164:             base = self._installed_candidate_cache[dist.canonical_name]
  165:         except KeyError:
  166:             base = AlreadyInstalledCandidate(dist, template, factory=self)
  167:             self._installed_candidate_cache[dist.canonical_name] = base
  168:         if not extras:
  169:             return base
  170:         return self._make_extras_candidate(base, extras, comes_from=template)
  171: 
  172:     def _make_candidate_from_link(
  173:         self,
  174:         link: Link,
  175:         extras: frozenset[str],
  176:         template: InstallRequirement,
  177:         name: NormalizedName | None,
  178:         version: Version | None,
  179:     ) -> Candidate | None:
  180:         base: BaseCandidate | None = self._make_base_candidate_from_link(
  181:             link, template, name, version
  182:         )
  183:         if not extras or base is None:
  184:             return base
  185:         return self._make_extras_candidate(base, extras, comes_from=template)
  186: 
  187:     def _make_base_candidate_from_link(
  188:         self,
  189:         link: Link,
  190:         template: InstallRequirement,
  191:         name: NormalizedName | None,
  192:         version: Version | None,
  193:     ) -> BaseCandidate | None:
  194:         # TODO: Check already installed candidate, and use it if the link and
  195:         # editable flag match.
  196: 
  197:         if link in self._build_failures:
  198:             # We already tried this candidate before, and it does not build.
  199:             # Don't bother trying again.
  200:             return None
  201: 
  202:         if template.editable:
  203:             if link not in self._editable_candidate_cache:
  204:                 try:
  205:                     self._editable_candidate_cache[link] = EditableCandidate(
  206:                         link,
  207:                         template,
  208:                         factory=self,
  209:                         name=name,
  210:                         version=version,
  211:                     )
  212:                 except (MetadataInconsistent, MetadataInvalid) as e:
  213:                     logger.info(
  214:                         "Discarding [blue underline]%s[/]: [yellow]%s[reset]",
  215:                         link,
  216:                         e,
  217:                         extra={"markup": True},
  218:                     )
  219:                     self._build_failures[link] = e
  220:                     return None
  221: 
  222:             return self._editable_candidate_cache[link]
  223:         else:
  224:             if link not in self._link_candidate_cache:
  225:                 try:
  226:                     self._link_candidate_cache[link] = LinkCandidate(
  227:                         link,
  228:                         template,
  229:                         factory=self,
  230:                         name=name,
  231:                         version=version,
  232:                     )
  233:                 except MetadataInconsistent as e:
  234:                     logger.info(
  235:                         "Discarding [blue underline]%s[/]: [yellow]%s[reset]",
  236:                         link,
  237:                         e,
  238:                         extra={"markup": True},
  239:                     )
  240:                     self._build_failures[link] = e
  241:                     return None
  242:             return self._link_candidate_cache[link]
  243: 
  244:     def _iter_found_candidates(
  245:         self,
  246:         ireqs: Sequence[InstallRequirement],
  247:         specifier: SpecifierSet,
  248:         hashes: Hashes,
  249:         prefers_installed: bool,
  250:         incompatible_ids: set[int],
  251:     ) -> Iterable[Candidate]:
  252:         if not ireqs:
  253:             return ()
  254: 
  255:         # The InstallRequirement implementation requires us to give it a
  256:         # "template". Here we just choose the first requirement to represent
  257:         # all of them.
  258:         # Hopefully the Project model can correct this mismatch in the future.
  259:         template = ireqs[0]
  260:         assert template.req, "Candidates found on index must be PEP 508"
  261:         name = canonicalize_name(template.req.name)
  262: 
  263:         extras: frozenset[str] = frozenset()
  264:         for ireq in ireqs:
  265:             assert ireq.req, "Candidates found on index must be PEP 508"
  266:             specifier &= ireq.req.specifier
  267:             hashes &= ireq.hashes(trust_internet=False)
  268:             extras |= frozenset(ireq.extras)
  269: 
  270:         def _get_installed_candidate() -> Candidate | None:
  271:             """Get the candidate for the currently-installed version."""
  272:             # If --force-reinstall is set, we want the version from the index
  273:             # instead, so we "pretend" there is nothing installed.
  274:             if self._force_reinstall:
  275:                 return None
  276:             try:
  277:                 installed_dist = self._installed_dists[name]
  278:             except KeyError:
  279:                 return None
  280: 
  281:             try:
  282:                 # Don't use the installed distribution if its version
  283:                 # does not fit the current dependency graph.
  284:                 if not specifier.contains(installed_dist.version, prereleases=True):
  285:                     return None
  286:             except InvalidVersion as e:
  287:                 raise InvalidInstalledPackage(dist=installed_dist, invalid_exc=e)
  288: 
  289:             candidate = self._make_candidate_from_dist(
  290:                 dist=installed_dist,
  291:                 extras=extras,
  292:                 template=template,
  293:             )
  294:             # The candidate is a known incompatibility. Don't use it.
  295:             if id(candidate) in incompatible_ids:
  296:                 return None
  297:             return candidate
  298: 
  299:         def iter_index_candidate_infos() -> Iterator[IndexCandidateInfo]:
  300:             result = self._finder.find_best_candidate(
  301:                 project_name=name,
  302:                 specifier=specifier,
  303:                 hashes=hashes,
  304:             )
  305:             icans = result.applicable_candidates
  306: 
  307:             # PEP 592: Yanked releases are ignored unless the specifier
  308:             # explicitly pins a version (via '==' or '===') that can be
  309:             # solely satisfied by a yanked release.
  310:             all_yanked = all(ican.link.is_yanked for ican in icans)
  311: 
  312:             def is_pinned(specifier: SpecifierSet) -> bool:
  313:                 for sp in specifier:
  314:                     if sp.operator == "===":
  315:                         return True
  316:                     if sp.operator != "==":
  317:                         continue
  318:                     if sp.version.endswith(".*"):
  319:                         continue
  320:                     return True
  321:                 return False
  322: 
  323:             pinned = is_pinned(specifier)
  324: 
  325:             # PackageFinder returns earlier versions first, so we reverse.
  326:             for ican in reversed(icans):
  327:                 if not (all_yanked and pinned) and ican.link.is_yanked:
  328:                     continue
  329:                 func = functools.partial(
  330:                     self._make_candidate_from_link,
  331:                     link=ican.link,
  332:                     extras=extras,
  333:                     template=template,
  334:                     name=name,
  335:                     version=ican.version,
  336:                 )
  337:                 yield ican.version, func
  338: 
  339:         return FoundCandidates(
  340:             iter_index_candidate_infos,
  341:             _get_installed_candidate(),
  342:             prefers_installed,
  343:             incompatible_ids,
  344:         )
  345: 
  346:     def _iter_explicit_candidates_from_base(
  347:         self,
  348:         base_requirements: Iterable[Requirement],
  349:         extras: frozenset[str],
  350:     ) -> Iterator[Candidate]:
  351:         """Produce explicit candidates from the base given an extra-ed package.
  352: 
  353:         :param base_requirements: Requirements known to the resolver. The
  354:             requirements are guaranteed to not have extras.
  355:         :param extras: The extras to inject into the explicit requirements'
  356:             candidates.
  357:         """
  358:         for req in base_requirements:
  359:             lookup_cand, _ = req.get_candidate_lookup()
  360:             if lookup_cand is None:  # Not explicit.
  361:                 continue
  362:             # We've stripped extras from the identifier, and should always
  363:             # get a BaseCandidate here, unless there's a bug elsewhere.
  364:             base_cand = as_base_candidate(lookup_cand)
  365:             assert base_cand is not None, "no extras here"
  366:             yield self._make_extras_candidate(base_cand, extras)
  367: 
  368:     def _iter_candidates_from_constraints(
  369:         self,
  370:         identifier: str,
  371:         constraint: Constraint,
  372:         template: InstallRequirement,
  373:     ) -> Iterator[Candidate]:
  374:         """Produce explicit candidates from constraints.
  375: 
  376:         This creates "fake" InstallRequirement objects that are basically clones
  377:         of what "should" be the template, but with original_link set to link.
  378:         """
  379:         for link in constraint.links:
  380:             self._fail_if_link_is_unsupported_wheel(link)
  381:             candidate = self._make_base_candidate_from_link(
  382:                 link,
  383:                 template=install_req_from_link_and_ireq(link, template),
  384:                 name=canonicalize_name(identifier),
  385:                 version=None,
  386:             )
  387:             if candidate:
  388:                 yield candidate
  389: 
  390:     def find_candidates(
  391:         self,
  392:         identifier: str,
  393:         requirements: Mapping[str, Iterable[Requirement]],
  394:         incompatibilities: Mapping[str, Iterator[Candidate]],
  395:         constraint: Constraint,
  396:         prefers_installed: bool,
  397:         is_satisfied_by: Callable[[Requirement, Candidate], bool],
  398:     ) -> Iterable[Candidate]:
  399:         # Collect basic lookup information from the requirements.
  400:         explicit_candidates: set[Candidate] = set()
  401:         ireqs: list[InstallRequirement] = []
  402:         for req in requirements[identifier]:
  403:             cand, ireq = req.get_candidate_lookup()
  404:             if cand is not None:
  405:                 explicit_candidates.add(cand)
  406:             if ireq is not None:
  407:                 ireqs.append(ireq)
  408: 
  409:         # If the current identifier contains extras, add requires and explicit
  410:         # candidates from entries from extra-less identifier.
  411:         with contextlib.suppress(InvalidRequirement):
  412:             parsed_requirement = get_requirement(identifier)
  413:             if parsed_requirement.name != identifier:
  414:                 explicit_candidates.update(
  415:                     self._iter_explicit_candidates_from_base(
  416:                         requirements.get(parsed_requirement.name, ()),
  417:                         frozenset(parsed_requirement.extras),
  418:                     ),
  419:                 )
  420:                 for req in requirements.get(parsed_requirement.name, []):
  421:                     _, ireq = req.get_candidate_lookup()
  422:                     if ireq is not None:
  423:                         ireqs.append(ireq)
  424: 
  425:         # Add explicit candidates from constraints. We only do this if there are
  426:         # known ireqs, which represent requirements not already explicit. If
  427:         # there are no ireqs, we're constraining already-explicit requirements,
  428:         # which is handled later when we return the explicit candidates.
  429:         if ireqs:
  430:             try:
  431:                 explicit_candidates.update(
  432:                     self._iter_candidates_from_constraints(
  433:                         identifier,
  434:                         constraint,
  435:                         template=ireqs[0],
  436:                     ),
  437:                 )
  438:             except UnsupportedWheel:
  439:                 # If we're constrained to install a wheel incompatible with the
  440:                 # target architecture, no candidates will ever be valid.
  441:                 return ()
  442: 
  443:         # Since we cache all the candidates, incompatibility identification
  444:         # can be made quicker by comparing only the id() values.
  445:         incompat_ids = {id(c) for c in incompatibilities.get(identifier, ())}
  446: 
  447:         # If none of the requirements want an explicit candidate, we can ask
  448:         # the finder for candidates.
  449:         if not explicit_candidates:
  450:             return self._iter_found_candidates(
  451:                 ireqs,
  452:                 constraint.specifier,
  453:                 constraint.hashes,
  454:                 prefers_installed,
  455:                 incompat_ids,
  456:             )
  457: 
  458:         return (
  459:             c
  460:             for c in explicit_candidates
  461:             if id(c) not in incompat_ids
  462:             and constraint.is_satisfied_by(c)
  463:             and all(is_satisfied_by(req, c) for req in requirements[identifier])
  464:         )
  465: 
  466:     def _make_requirements_from_install_req(
  467:         self, ireq: InstallRequirement, requested_extras: Iterable[str]
  468:     ) -> Iterator[Requirement]:
  469:         """
  470:         Returns requirement objects associated with the given InstallRequirement. In
  471:         most cases this will be a single object but the following special cases exist:
  472:             - the InstallRequirement has markers that do not apply -> result is empty
  473:             - the InstallRequirement has both a constraint (or link) and extras
  474:                 -> result is split in two requirement objects: one with the constraint
  475:                 (or link) and one with the extra. This allows centralized constraint
  476:                 handling for the base, resulting in fewer candidate rejections.
  477:         """
  478:         if not ireq.match_markers(requested_extras):
  479:             logger.info(
  480:                 "Ignoring %s: markers '%s' don't match your environment",
  481:                 ireq.name,
  482:                 ireq.markers,
  483:             )
  484:         elif not ireq.link:
  485:             if ireq.extras and ireq.req is not None and ireq.req.specifier:
  486:                 yield SpecifierWithoutExtrasRequirement(ireq)
  487:             yield SpecifierRequirement(ireq)
  488:         else:
  489:             self._fail_if_link_is_unsupported_wheel(ireq.link)
  490:             # Always make the link candidate for the base requirement to make it
  491:             # available to `find_candidates` for explicit candidate lookup for any
  492:             # set of extras.
  493:             # The extras are required separately via a second requirement.
  494:             cand = self._make_base_candidate_from_link(
  495:                 ireq.link,
  496:                 template=install_req_drop_extras(ireq) if ireq.extras else ireq,
  497:                 name=canonicalize_name(ireq.name) if ireq.name else None,
  498:                 version=None,
  499:             )
  500:             if cand is None:
  501:                 # There's no way we can satisfy a URL requirement if the underlying
  502:                 # candidate fails to build. An unnamed URL must be user-supplied, so
  503:                 # we fail eagerly. If the URL is named, an unsatisfiable requirement
  504:                 # can make the resolver do the right thing, either backtrack (and
  505:                 # maybe find some other requirement that's buildable) or raise a
  506:                 # ResolutionImpossible eventually.
  507:                 if not ireq.name:
  508:                     raise self._build_failures[ireq.link]
  509:                 yield UnsatisfiableRequirement(canonicalize_name(ireq.name))
  510:             else:
  511:                 # require the base from the link
  512:                 yield self.make_requirement_from_candidate(cand)
  513:                 if ireq.extras:
  514:                     # require the extras on top of the base candidate
  515:                     yield self.make_requirement_from_candidate(
  516:                         self._make_extras_candidate(cand, frozenset(ireq.extras))
  517:                     )
  518: 
  519:     def collect_root_requirements(
  520:         self, root_ireqs: list[InstallRequirement]
  521:     ) -> CollectedRootRequirements:
  522:         collected = CollectedRootRequirements([], {}, {})
  523:         for i, ireq in enumerate(root_ireqs):
  524:             if ireq.constraint:
  525:                 # Ensure we only accept valid constraints
  526:                 problem = check_invalid_constraint_type(ireq)
  527:                 if problem:
  528:                     raise InstallationError(problem)
  529:                 if not ireq.match_markers():
  530:                     continue
  531:                 assert ireq.name, "Constraint must be named"
  532:                 name = canonicalize_name(ireq.name)
  533:                 if name in collected.constraints:
  534:                     collected.constraints[name] &= ireq
  535:                 else:
  536:                     collected.constraints[name] = Constraint.from_ireq(ireq)
  537:             else:
  538:                 reqs = list(
  539:                     self._make_requirements_from_install_req(
  540:                         ireq,
  541:                         requested_extras=(),
  542:                     )
  543:                 )
  544:                 if not reqs:
  545:                     continue
  546:                 template = reqs[0]
  547:                 if ireq.user_supplied and template.name not in collected.user_requested:
  548:                     collected.user_requested[template.name] = i
  549:                 collected.requirements.extend(reqs)
  550:         # Put requirements with extras at the end of the root requires. This does not
  551:         # affect resolvelib's picking preference but it does affect its initial criteria
  552:         # population: by putting extras at the end we enable the candidate finder to
  553:         # present resolvelib with a smaller set of candidates to resolvelib, already
  554:         # taking into account any non-transient constraints on the associated base. This
  555:         # means resolvelib will have fewer candidates to visit and reject.
  556:         # Python's list sort is stable, meaning relative order is kept for objects with
  557:         # the same key.
  558:         collected.requirements.sort(key=lambda r: r.name != r.project_name)
  559:         return collected
  560: 
  561:     def make_requirement_from_candidate(
  562:         self, candidate: Candidate
  563:     ) -> ExplicitRequirement:
  564:         return ExplicitRequirement(candidate)
  565: 
  566:     def make_requirements_from_spec(
  567:         self,
  568:         specifier: str,
  569:         comes_from: InstallRequirement | None,
  570:         requested_extras: Iterable[str] = (),
  571:     ) -> Iterator[Requirement]:
  572:         """
  573:         Returns requirement objects associated with the given specifier. In most cases
  574:         this will be a single object but the following special cases exist:
  575:             - the specifier has markers that do not apply -> result is empty
  576:             - the specifier has both a constraint and extras -> result is split
  577:                 in two requirement objects: one with the constraint and one with the
  578:                 extra. This allows centralized constraint handling for the base,
  579:                 resulting in fewer candidate rejections.
  580:         """
  581:         ireq = self._make_install_req_from_spec(specifier, comes_from)
  582:         return self._make_requirements_from_install_req(ireq, requested_extras)
  583: 
  584:     def make_requires_python_requirement(
  585:         self,
  586:         specifier: SpecifierSet,
  587:     ) -> Requirement | None:
  588:         if self._ignore_requires_python:
  589:             return None
  590:         # Don't bother creating a dependency for an empty Requires-Python.
  591:         if not str(specifier):
  592:             return None
  593:         return RequiresPythonRequirement(specifier, self._python_candidate)
  594: 
  595:     def get_wheel_cache_entry(self, link: Link, name: str | None) -> CacheEntry | None:
  596:         """Look up the link in the wheel cache.
  597: 
  598:         If ``preparer.require_hashes`` is True, don't use the wheel cache,
  599:         because cached wheels, always built locally, have different hashes
  600:         than the files downloaded from the index server and thus throw false
  601:         hash mismatches. Furthermore, cached wheels at present have
  602:         nondeterministic contents due to file modification times.
  603:         """
  604:         if self._wheel_cache is None:
  605:             return None
  606:         return self._wheel_cache.get_cache_entry(
  607:             link=link,
  608:             package_name=name,
  609:             supported_tags=self._supported_tags_cache,
  610:         )
  611: 
  612:     def get_dist_to_uninstall(self, candidate: Candidate) -> BaseDistribution | None:
  613:         # TODO: Are there more cases this needs to return True? Editable?
  614:         dist = self._installed_dists.get(candidate.project_name)
  615:         if dist is None:  # Not installed, no uninstallation required.
  616:             return None
  617: 
  618:         # We're installing into global site. The current installation must
  619:         # be uninstalled, no matter it's in global or user site, because the
  620:         # user site installation has precedence over global.
  621:         if not self._use_user_site:
  622:             return dist
  623: 
  624:         # We're installing into user site. Remove the user site installation.
  625:         if dist.in_usersite:
  626:             return dist
  627: 
  628:         # We're installing into user site, but the installed incompatible
  629:         # package is in global site. We can't uninstall that, and would let
  630:         # the new user installation to "shadow" it. But shadowing won't work
  631:         # in virtual environments, so we error out.
  632:         if running_under_virtualenv() and dist.in_site_packages:
  633:             message = (
  634:                 f"Will not install to the user site because it will lack "
  635:                 f"sys.path precedence to {dist.raw_name} in {dist.location}"
  636:             )
  637:             raise InstallationError(message)
  638:         return None
  639: 
  640:     def _report_requires_python_error(
  641:         self, causes: Sequence[ConflictCause]
  642:     ) -> UnsupportedPythonVersion:
  643:         assert causes, "Requires-Python error reported with no cause"
  644: 
  645:         version = self._python_candidate.version
  646: 
  647:         if len(causes) == 1:
  648:             specifier = str(causes[0].requirement.specifier)
  649:             message = (
  650:                 f"Package {causes[0].parent.name!r} requires a different "
  651:                 f"Python: {version} not in {specifier!r}"
  652:             )
  653:             return UnsupportedPythonVersion(message)
  654: 
  655:         message = f"Packages require a different Python. {version} not in:"
  656:         for cause in causes:
  657:             package = cause.parent.format_for_error()
  658:             specifier = str(cause.requirement.specifier)
  659:             message += f"\n{specifier!r} (required by {package})"
  660:         return UnsupportedPythonVersion(message)
  661: 
  662:     def _report_single_requirement_conflict(
  663:         self, req: Requirement, parent: Candidate | None
  664:     ) -> DistributionNotFound:
  665:         if parent is None:
  666:             req_disp = str(req)
  667:         else:
  668:             req_disp = f"{req} (from {parent.name})"
  669: 
  670:         cands = self._finder.find_all_candidates(req.project_name)
  671:         skipped_by_requires_python = self._finder.requires_python_skipped_reasons()
  672: 
  673:         versions_set: set[Version] = set()
  674:         yanked_versions_set: set[Version] = set()
  675:         for c in cands:
  676:             is_yanked = c.link.is_yanked if c.link else False
  677:             if is_yanked:
  678:                 yanked_versions_set.add(c.version)
  679:             else:
  680:                 versions_set.add(c.version)
  681: 
  682:         versions = [str(v) for v in sorted(versions_set)]
  683:         yanked_versions = [str(v) for v in sorted(yanked_versions_set)]
  684: 
  685:         if yanked_versions:
  686:             # Saying "version X is yanked" isn't entirely accurate.
  687:             # https://github.com/pypa/pip/issues/11745#issuecomment-1402805842
  688:             logger.critical(
  689:                 "Ignored the following yanked versions: %s",
  690:                 ", ".join(yanked_versions) or "none",
  691:             )
  692:         if skipped_by_requires_python:
  693:             logger.critical(
  694:                 "Ignored the following versions that require a different python "
  695:                 "version: %s",
  696:                 "; ".join(skipped_by_requires_python) or "none",
  697:             )
  698:         logger.critical(
  699:             "Could not find a version that satisfies the requirement %s "
  700:             "(from versions: %s)",
  701:             req_disp,
  702:             ", ".join(versions) or "none",
  703:         )
  704:         if str(req) == "requirements.txt":
  705:             logger.info(
  706:                 "HINT: You are attempting to install a package literally "
  707:                 'named "requirements.txt" (which cannot exist). Consider '
  708:                 "using the '-r' flag to install the packages listed in "
  709:                 "requirements.txt"
  710:             )
  711: 
  712:         return DistributionNotFound(f"No matching distribution found for {req}")
  713: 
  714:     def get_installation_error(
  715:         self,
  716:         e: ResolutionImpossible[Requirement, Candidate],
  717:         constraints: dict[str, Constraint],
  718:     ) -> InstallationError:
  719:         assert e.causes, "Installation error reported with no cause"
  720: 
  721:         # If one of the things we can't solve is "we need Python X.Y",
  722:         # that is what we report.
  723:         requires_python_causes = [
  724:             cause
  725:             for cause in e.causes
  726:             if isinstance(cause.requirement, RequiresPythonRequirement)
  727:             and not cause.requirement.is_satisfied_by(self._python_candidate)
  728:         ]
  729:         if requires_python_causes:
  730:             # The comprehension above makes sure all Requirement instances are
  731:             # RequiresPythonRequirement, so let's cast for convenience.
  732:             return self._report_requires_python_error(
  733:                 cast("Sequence[ConflictCause]", requires_python_causes),
  734:             )
  735: 
  736:         # Otherwise, we have a set of causes which can't all be satisfied
  737:         # at once.
  738: 
  739:         # The simplest case is when we have *one* cause that can't be
  740:         # satisfied. We just report that case.
  741:         if len(e.causes) == 1:
  742:             req, parent = next(iter(e.causes))
  743:             if req.name not in constraints:
  744:                 return self._report_single_requirement_conflict(req, parent)
  745: 
  746:         # OK, we now have a list of requirements that can't all be
  747:         # satisfied at once.
  748: 
  749:         # A couple of formatting helpers
  750:         def text_join(parts: list[str]) -> str:
  751:             if len(parts) == 1:
  752:                 return parts[0]
  753: 
  754:             return ", ".join(parts[:-1]) + " and " + parts[-1]
  755: 
  756:         def describe_trigger(parent: Candidate) -> str:
  757:             ireq = parent.get_install_requirement()
  758:             if not ireq or not ireq.comes_from:
  759:                 return f"{parent.name}=={parent.version}"
  760:             if isinstance(ireq.comes_from, InstallRequirement):
  761:                 return str(ireq.comes_from.name)
  762:             return str(ireq.comes_from)
  763: 
  764:         triggers = set()
  765:         for req, parent in e.causes:
  766:             if parent is None:
  767:                 # This is a root requirement, so we can report it directly
  768:                 trigger = req.format_for_error()
  769:             else:
  770:                 trigger = describe_trigger(parent)
  771:             triggers.add(trigger)
  772: 
  773:         if triggers:
  774:             info = text_join(sorted(triggers))
  775:         else:
  776:             info = "the requested packages"
  777: 
  778:         msg = (
  779:             f"Cannot install {info} because these package versions "
  780:             "have conflicting dependencies."
  781:         )
  782:         logger.critical(msg)
  783:         msg = "\nThe conflict is caused by:"
  784: 
  785:         relevant_constraints = set()
  786:         for req, parent in e.causes:
  787:             if req.name in constraints:
  788:                 relevant_constraints.add(req.name)
  789:             msg = msg + "\n    "
  790:             if parent:
  791:                 msg = msg + f"{parent.name} {parent.version} depends on "
  792:             else:
  793:                 msg = msg + "The user requested "
  794:             msg = msg + req.format_for_error()
  795:         for key in relevant_constraints:
  796:             spec = constraints[key].specifier
  797:             msg += f"\n    The user requested (constraint) {key}{spec}"
  798: 
  799:         msg = (
  800:             msg
  801:             + "\n\n"
  802:             + "To fix this you could try to:\n"
  803:             + "1. loosen the range of package versions you've specified\n"
  804:             + "2. remove package versions to allow pip to attempt to solve "
  805:             + "the dependency conflict\n"
  806:         )
  807: 
  808:         logger.info(msg)
  809: 
  810:         return DistributionNotFound(
  811:             "ResolutionImpossible: for help visit "
  812:             "https://pip.pypa.io/en/latest/topics/dependency-resolution/"
  813:             "#dealing-with-dependency-conflicts"
  814:         )
