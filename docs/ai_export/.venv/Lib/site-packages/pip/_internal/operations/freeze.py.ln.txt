    1: from __future__ import annotations
    2: 
    3: import collections
    4: import logging
    5: import os
    6: from collections.abc import Container, Generator, Iterable
    7: from dataclasses import dataclass, field
    8: from typing import NamedTuple
    9: 
   10: from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
   11: from pip._vendor.packaging.version import InvalidVersion
   12: 
   13: from pip._internal.exceptions import BadCommand, InstallationError
   14: from pip._internal.metadata import BaseDistribution, get_environment
   15: from pip._internal.req.constructors import (
   16:     install_req_from_editable,
   17:     install_req_from_line,
   18: )
   19: from pip._internal.req.req_file import COMMENT_RE
   20: from pip._internal.utils.direct_url_helpers import direct_url_as_pep440_direct_reference
   21: 
   22: logger = logging.getLogger(__name__)
   23: 
   24: 
   25: class _EditableInfo(NamedTuple):
   26:     requirement: str
   27:     comments: list[str]
   28: 
   29: 
   30: def freeze(
   31:     requirement: list[str] | None = None,
   32:     local_only: bool = False,
   33:     user_only: bool = False,
   34:     paths: list[str] | None = None,
   35:     isolated: bool = False,
   36:     exclude_editable: bool = False,
   37:     skip: Container[str] = (),
   38: ) -> Generator[str, None, None]:
   39:     installations: dict[str, FrozenRequirement] = {}
   40: 
   41:     dists = get_environment(paths).iter_installed_distributions(
   42:         local_only=local_only,
   43:         skip=(),
   44:         user_only=user_only,
   45:     )
   46:     for dist in dists:
   47:         req = FrozenRequirement.from_dist(dist)
   48:         if exclude_editable and req.editable:
   49:             continue
   50:         installations[req.canonical_name] = req
   51: 
   52:     if requirement:
   53:         # the options that don't get turned into an InstallRequirement
   54:         # should only be emitted once, even if the same option is in multiple
   55:         # requirements files, so we need to keep track of what has been emitted
   56:         # so that we don't emit it again if it's seen again
   57:         emitted_options: set[str] = set()
   58:         # keep track of which files a requirement is in so that we can
   59:         # give an accurate warning if a requirement appears multiple times.
   60:         req_files: dict[str, list[str]] = collections.defaultdict(list)
   61:         for req_file_path in requirement:
   62:             with open(req_file_path) as req_file:
   63:                 for line in req_file:
   64:                     if (
   65:                         not line.strip()
   66:                         or line.strip().startswith("#")
   67:                         or line.startswith(
   68:                             (
   69:                                 "-r",
   70:                                 "--requirement",
   71:                                 "-f",
   72:                                 "--find-links",
   73:                                 "-i",
   74:                                 "--index-url",
   75:                                 "--pre",
   76:                                 "--trusted-host",
   77:                                 "--process-dependency-links",
   78:                                 "--extra-index-url",
   79:                                 "--use-feature",
   80:                             )
   81:                         )
   82:                     ):
   83:                         line = line.rstrip()
   84:                         if line not in emitted_options:
   85:                             emitted_options.add(line)
   86:                             yield line
   87:                         continue
   88: 
   89:                     if line.startswith(("-e", "--editable")):
   90:                         if line.startswith("-e"):
   91:                             line = line[2:].strip()
   92:                         else:
   93:                             line = line[len("--editable") :].strip().lstrip("=")
   94:                         line_req = install_req_from_editable(
   95:                             line,
   96:                             isolated=isolated,
   97:                         )
   98:                     else:
   99:                         line_req = install_req_from_line(
  100:                             COMMENT_RE.sub("", line).strip(),
  101:                             isolated=isolated,
  102:                         )
  103: 
  104:                     if not line_req.name:
  105:                         logger.info(
  106:                             "Skipping line in requirement file [%s] because "
  107:                             "it's not clear what it would install: %s",
  108:                             req_file_path,
  109:                             line.strip(),
  110:                         )
  111:                         logger.info(
  112:                             "  (add #egg=PackageName to the URL to avoid"
  113:                             " this warning)"
  114:                         )
  115:                     else:
  116:                         line_req_canonical_name = canonicalize_name(line_req.name)
  117:                         if line_req_canonical_name not in installations:
  118:                             # either it's not installed, or it is installed
  119:                             # but has been processed already
  120:                             if not req_files[line_req.name]:
  121:                                 logger.warning(
  122:                                     "Requirement file [%s] contains %s, but "
  123:                                     "package %r is not installed",
  124:                                     req_file_path,
  125:                                     COMMENT_RE.sub("", line).strip(),
  126:                                     line_req.name,
  127:                                 )
  128:                             else:
  129:                                 req_files[line_req.name].append(req_file_path)
  130:                         else:
  131:                             yield str(installations[line_req_canonical_name]).rstrip()
  132:                             del installations[line_req_canonical_name]
  133:                             req_files[line_req.name].append(req_file_path)
  134: 
  135:         # Warn about requirements that were included multiple times (in a
  136:         # single requirements file or in different requirements files).
  137:         for name, files in req_files.items():
  138:             if len(files) > 1:
  139:                 logger.warning(
  140:                     "Requirement %s included multiple times [%s]",
  141:                     name,
  142:                     ", ".join(sorted(set(files))),
  143:                 )
  144: 
  145:         yield ("## The following requirements were added by pip freeze:")
  146:     for installation in sorted(installations.values(), key=lambda x: x.name.lower()):
  147:         if installation.canonical_name not in skip:
  148:             yield str(installation).rstrip()
  149: 
  150: 
  151: def _format_as_name_version(dist: BaseDistribution) -> str:
  152:     try:
  153:         dist_version = dist.version
  154:     except InvalidVersion:
  155:         # legacy version
  156:         return f"{dist.raw_name}==={dist.raw_version}"
  157:     else:
  158:         return f"{dist.raw_name}=={dist_version}"
  159: 
  160: 
  161: def _get_editable_info(dist: BaseDistribution) -> _EditableInfo:
  162:     """
  163:     Compute and return values (req, comments) for use in
  164:     FrozenRequirement.from_dist().
  165:     """
  166:     editable_project_location = dist.editable_project_location
  167:     assert editable_project_location
  168:     location = os.path.normcase(os.path.abspath(editable_project_location))
  169: 
  170:     from pip._internal.vcs import RemoteNotFoundError, RemoteNotValidError, vcs
  171: 
  172:     vcs_backend = vcs.get_backend_for_dir(location)
  173: 
  174:     if vcs_backend is None:
  175:         display = _format_as_name_version(dist)
  176:         logger.debug(
  177:             'No VCS found for editable requirement "%s" in: %r',
  178:             display,
  179:             location,
  180:         )
  181:         return _EditableInfo(
  182:             requirement=location,
  183:             comments=[f"# Editable install with no version control ({display})"],
  184:         )
  185: 
  186:     vcs_name = type(vcs_backend).__name__
  187: 
  188:     try:
  189:         req = vcs_backend.get_src_requirement(location, dist.raw_name)
  190:     except RemoteNotFoundError:
  191:         display = _format_as_name_version(dist)
  192:         return _EditableInfo(
  193:             requirement=location,
  194:             comments=[f"# Editable {vcs_name} install with no remote ({display})"],
  195:         )
  196:     except RemoteNotValidError as ex:
  197:         display = _format_as_name_version(dist)
  198:         return _EditableInfo(
  199:             requirement=location,
  200:             comments=[
  201:                 f"# Editable {vcs_name} install ({display}) with either a deleted "
  202:                 f"local remote or invalid URI:",
  203:                 f"# '{ex.url}'",
  204:             ],
  205:         )
  206:     except BadCommand:
  207:         logger.warning(
  208:             "cannot determine version of editable source in %s "
  209:             "(%s command not found in path)",
  210:             location,
  211:             vcs_backend.name,
  212:         )
  213:         return _EditableInfo(requirement=location, comments=[])
  214:     except InstallationError as exc:
  215:         logger.warning("Error when trying to get requirement for VCS system %s", exc)
  216:     else:
  217:         return _EditableInfo(requirement=req, comments=[])
  218: 
  219:     logger.warning("Could not determine repository location of %s", location)
  220: 
  221:     return _EditableInfo(
  222:         requirement=location,
  223:         comments=["## !! Could not determine repository location"],
  224:     )
  225: 
  226: 
  227: @dataclass(frozen=True)
  228: class FrozenRequirement:
  229:     name: str
  230:     req: str
  231:     editable: bool
  232:     comments: Iterable[str] = field(default_factory=tuple)
  233: 
  234:     @property
  235:     def canonical_name(self) -> NormalizedName:
  236:         return canonicalize_name(self.name)
  237: 
  238:     @classmethod
  239:     def from_dist(cls, dist: BaseDistribution) -> FrozenRequirement:
  240:         editable = dist.editable
  241:         if editable:
  242:             req, comments = _get_editable_info(dist)
  243:         else:
  244:             comments = []
  245:             direct_url = dist.direct_url
  246:             if direct_url:
  247:                 # if PEP 610 metadata is present, use it
  248:                 req = direct_url_as_pep440_direct_reference(direct_url, dist.raw_name)
  249:             else:
  250:                 # name==version requirement
  251:                 req = _format_as_name_version(dist)
  252: 
  253:         return cls(dist.raw_name, req, editable, comments=comments)
  254: 
  255:     def __str__(self) -> str:
  256:         req = self.req
  257:         if self.editable:
  258:             req = f"-e {req}"
  259:         return "\n".join(list(self.comments) + [str(req)]) + "\n"
