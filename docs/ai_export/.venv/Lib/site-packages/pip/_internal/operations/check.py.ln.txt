    1: """Validation of dependencies of packages"""
    2: 
    3: from __future__ import annotations
    4: 
    5: import logging
    6: from collections.abc import Generator, Iterable
    7: from contextlib import suppress
    8: from email.parser import Parser
    9: from functools import reduce
   10: from typing import (
   11:     Callable,
   12:     NamedTuple,
   13: )
   14: 
   15: from pip._vendor.packaging.requirements import Requirement
   16: from pip._vendor.packaging.tags import Tag, parse_tag
   17: from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
   18: from pip._vendor.packaging.version import Version
   19: 
   20: from pip._internal.distributions import make_distribution_for_install_requirement
   21: from pip._internal.metadata import get_default_environment
   22: from pip._internal.metadata.base import BaseDistribution
   23: from pip._internal.req.req_install import InstallRequirement
   24: 
   25: logger = logging.getLogger(__name__)
   26: 
   27: 
   28: class PackageDetails(NamedTuple):
   29:     version: Version
   30:     dependencies: list[Requirement]
   31: 
   32: 
   33: # Shorthands
   34: PackageSet = dict[NormalizedName, PackageDetails]
   35: Missing = tuple[NormalizedName, Requirement]
   36: Conflicting = tuple[NormalizedName, Version, Requirement]
   37: 
   38: MissingDict = dict[NormalizedName, list[Missing]]
   39: ConflictingDict = dict[NormalizedName, list[Conflicting]]
   40: CheckResult = tuple[MissingDict, ConflictingDict]
   41: ConflictDetails = tuple[PackageSet, CheckResult]
   42: 
   43: 
   44: def create_package_set_from_installed() -> tuple[PackageSet, bool]:
   45:     """Converts a list of distributions into a PackageSet."""
   46:     package_set = {}
   47:     problems = False
   48:     env = get_default_environment()
   49:     for dist in env.iter_installed_distributions(local_only=False, skip=()):
   50:         name = dist.canonical_name
   51:         try:
   52:             dependencies = list(dist.iter_dependencies())
   53:             package_set[name] = PackageDetails(dist.version, dependencies)
   54:         except (OSError, ValueError) as e:
   55:             # Don't crash on unreadable or broken metadata.
   56:             logger.warning("Error parsing dependencies of %s: %s", name, e)
   57:             problems = True
   58:     return package_set, problems
   59: 
   60: 
   61: def check_package_set(
   62:     package_set: PackageSet, should_ignore: Callable[[str], bool] | None = None
   63: ) -> CheckResult:
   64:     """Check if a package set is consistent
   65: 
   66:     If should_ignore is passed, it should be a callable that takes a
   67:     package name and returns a boolean.
   68:     """
   69: 
   70:     missing = {}
   71:     conflicting = {}
   72: 
   73:     for package_name, package_detail in package_set.items():
   74:         # Info about dependencies of package_name
   75:         missing_deps: set[Missing] = set()
   76:         conflicting_deps: set[Conflicting] = set()
   77: 
   78:         if should_ignore and should_ignore(package_name):
   79:             continue
   80: 
   81:         for req in package_detail.dependencies:
   82:             name = canonicalize_name(req.name)
   83: 
   84:             # Check if it's missing
   85:             if name not in package_set:
   86:                 missed = True
   87:                 if req.marker is not None:
   88:                     missed = req.marker.evaluate({"extra": ""})
   89:                 if missed:
   90:                     missing_deps.add((name, req))
   91:                 continue
   92: 
   93:             # Check if there's a conflict
   94:             version = package_set[name].version
   95:             if not req.specifier.contains(version, prereleases=True):
   96:                 conflicting_deps.add((name, version, req))
   97: 
   98:         if missing_deps:
   99:             missing[package_name] = sorted(missing_deps, key=str)
  100:         if conflicting_deps:
  101:             conflicting[package_name] = sorted(conflicting_deps, key=str)
  102: 
  103:     return missing, conflicting
  104: 
  105: 
  106: def check_install_conflicts(to_install: list[InstallRequirement]) -> ConflictDetails:
  107:     """For checking if the dependency graph would be consistent after \
  108:     installing given requirements
  109:     """
  110:     # Start from the current state
  111:     package_set, _ = create_package_set_from_installed()
  112:     # Install packages
  113:     would_be_installed = _simulate_installation_of(to_install, package_set)
  114: 
  115:     # Only warn about directly-dependent packages; create a whitelist of them
  116:     whitelist = _create_whitelist(would_be_installed, package_set)
  117: 
  118:     return (
  119:         package_set,
  120:         check_package_set(
  121:             package_set, should_ignore=lambda name: name not in whitelist
  122:         ),
  123:     )
  124: 
  125: 
  126: def check_unsupported(
  127:     packages: Iterable[BaseDistribution],
  128:     supported_tags: Iterable[Tag],
  129: ) -> Generator[BaseDistribution, None, None]:
  130:     for p in packages:
  131:         with suppress(FileNotFoundError):
  132:             wheel_file = p.read_text("WHEEL")
  133:             wheel_tags: frozenset[Tag] = reduce(
  134:                 frozenset.union,
  135:                 map(parse_tag, Parser().parsestr(wheel_file).get_all("Tag", [])),
  136:                 frozenset(),
  137:             )
  138:             if wheel_tags.isdisjoint(supported_tags):
  139:                 yield p
  140: 
  141: 
  142: def _simulate_installation_of(
  143:     to_install: list[InstallRequirement], package_set: PackageSet
  144: ) -> set[NormalizedName]:
  145:     """Computes the version of packages after installing to_install."""
  146:     # Keep track of packages that were installed
  147:     installed = set()
  148: 
  149:     # Modify it as installing requirement_set would (assuming no errors)
  150:     for inst_req in to_install:
  151:         abstract_dist = make_distribution_for_install_requirement(inst_req)
  152:         dist = abstract_dist.get_metadata_distribution()
  153:         name = dist.canonical_name
  154:         package_set[name] = PackageDetails(dist.version, list(dist.iter_dependencies()))
  155: 
  156:         installed.add(name)
  157: 
  158:     return installed
  159: 
  160: 
  161: def _create_whitelist(
  162:     would_be_installed: set[NormalizedName], package_set: PackageSet
  163: ) -> set[NormalizedName]:
  164:     packages_affected = set(would_be_installed)
  165: 
  166:     for package_name in package_set:
  167:         if package_name in packages_affected:
  168:             continue
  169: 
  170:         for req in package_set[package_name].dependencies:
  171:             if canonicalize_name(req.name) in packages_affected:
  172:                 packages_affected.add(package_name)
  173:                 break
  174: 
  175:     return packages_affected
