    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import hashlib
    5: import logging
    6: import os
    7: from collections.abc import Generator
    8: from types import TracebackType
    9: 
   10: from pip._internal.req.req_install import InstallRequirement
   11: from pip._internal.utils.temp_dir import TempDirectory
   12: 
   13: logger = logging.getLogger(__name__)
   14: 
   15: 
   16: @contextlib.contextmanager
   17: def update_env_context_manager(**changes: str) -> Generator[None, None, None]:
   18:     target = os.environ
   19: 
   20:     # Save values from the target and change them.
   21:     non_existent_marker = object()
   22:     saved_values: dict[str, object | str] = {}
   23:     for name, new_value in changes.items():
   24:         try:
   25:             saved_values[name] = target[name]
   26:         except KeyError:
   27:             saved_values[name] = non_existent_marker
   28:         target[name] = new_value
   29: 
   30:     try:
   31:         yield
   32:     finally:
   33:         # Restore original values in the target.
   34:         for name, original_value in saved_values.items():
   35:             if original_value is non_existent_marker:
   36:                 del target[name]
   37:             else:
   38:                 assert isinstance(original_value, str)  # for mypy
   39:                 target[name] = original_value
   40: 
   41: 
   42: @contextlib.contextmanager
   43: def get_build_tracker() -> Generator[BuildTracker, None, None]:
   44:     root = os.environ.get("PIP_BUILD_TRACKER")
   45:     with contextlib.ExitStack() as ctx:
   46:         if root is None:
   47:             root = ctx.enter_context(TempDirectory(kind="build-tracker")).path
   48:             ctx.enter_context(update_env_context_manager(PIP_BUILD_TRACKER=root))
   49:             logger.debug("Initialized build tracking at %s", root)
   50: 
   51:         with BuildTracker(root) as tracker:
   52:             yield tracker
   53: 
   54: 
   55: class TrackerId(str):
   56:     """Uniquely identifying string provided to the build tracker."""
   57: 
   58: 
   59: class BuildTracker:
   60:     """Ensure that an sdist cannot request itself as a setup requirement.
   61: 
   62:     When an sdist is prepared, it identifies its setup requirements in the
   63:     context of ``BuildTracker.track()``. If a requirement shows up recursively, this
   64:     raises an exception.
   65: 
   66:     This stops fork bombs embedded in malicious packages."""
   67: 
   68:     def __init__(self, root: str) -> None:
   69:         self._root = root
   70:         self._entries: dict[TrackerId, InstallRequirement] = {}
   71:         logger.debug("Created build tracker: %s", self._root)
   72: 
   73:     def __enter__(self) -> BuildTracker:
   74:         logger.debug("Entered build tracker: %s", self._root)
   75:         return self
   76: 
   77:     def __exit__(
   78:         self,
   79:         exc_type: type[BaseException] | None,
   80:         exc_val: BaseException | None,
   81:         exc_tb: TracebackType | None,
   82:     ) -> None:
   83:         self.cleanup()
   84: 
   85:     def _entry_path(self, key: TrackerId) -> str:
   86:         hashed = hashlib.sha224(key.encode()).hexdigest()
   87:         return os.path.join(self._root, hashed)
   88: 
   89:     def add(self, req: InstallRequirement, key: TrackerId) -> None:
   90:         """Add an InstallRequirement to build tracking."""
   91: 
   92:         # Get the file to write information about this requirement.
   93:         entry_path = self._entry_path(key)
   94: 
   95:         # Try reading from the file. If it exists and can be read from, a build
   96:         # is already in progress, so a LookupError is raised.
   97:         try:
   98:             with open(entry_path) as fp:
   99:                 contents = fp.read()
  100:         except FileNotFoundError:
  101:             pass
  102:         else:
  103:             message = f"{req.link} is already being built: {contents}"
  104:             raise LookupError(message)
  105: 
  106:         # If we're here, req should really not be building already.
  107:         assert key not in self._entries
  108: 
  109:         # Start tracking this requirement.
  110:         with open(entry_path, "w", encoding="utf-8") as fp:
  111:             fp.write(str(req))
  112:         self._entries[key] = req
  113: 
  114:         logger.debug("Added %s to build tracker %r", req, self._root)
  115: 
  116:     def remove(self, req: InstallRequirement, key: TrackerId) -> None:
  117:         """Remove an InstallRequirement from build tracking."""
  118: 
  119:         # Delete the created file and the corresponding entry.
  120:         os.unlink(self._entry_path(key))
  121:         del self._entries[key]
  122: 
  123:         logger.debug("Removed %s from build tracker %r", req, self._root)
  124: 
  125:     def cleanup(self) -> None:
  126:         for key, req in list(self._entries.items()):
  127:             self.remove(req, key)
  128: 
  129:         logger.debug("Removed build tracker: %r", self._root)
  130: 
  131:     @contextlib.contextmanager
  132:     def track(self, req: InstallRequirement, key: str) -> Generator[None, None, None]:
  133:         """Ensure that `key` cannot install itself as a setup requirement.
  134: 
  135:         :raises LookupError: If `key` was already provided in a parent invocation of
  136:                              the context introduced by this method."""
  137:         tracker_id = TrackerId(key)
  138:         self.add(req, tracker_id)
  139:         yield
  140:         self.remove(req, tracker_id)
