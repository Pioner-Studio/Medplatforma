    1: """Handles all VCS (version control) support"""
    2: 
    3: from __future__ import annotations
    4: 
    5: import logging
    6: import os
    7: import shutil
    8: import sys
    9: import urllib.parse
   10: from collections.abc import Iterable, Iterator, Mapping
   11: from dataclasses import dataclass, field
   12: from typing import (
   13:     Any,
   14:     Literal,
   15:     Optional,
   16: )
   17: 
   18: from pip._internal.cli.spinners import SpinnerInterface
   19: from pip._internal.exceptions import BadCommand, InstallationError
   20: from pip._internal.utils.misc import (
   21:     HiddenText,
   22:     ask_path_exists,
   23:     backup_dir,
   24:     display_path,
   25:     hide_url,
   26:     hide_value,
   27:     is_installable_dir,
   28:     rmtree,
   29: )
   30: from pip._internal.utils.subprocess import (
   31:     CommandArgs,
   32:     call_subprocess,
   33:     format_command_args,
   34:     make_command,
   35: )
   36: 
   37: __all__ = ["vcs"]
   38: 
   39: 
   40: logger = logging.getLogger(__name__)
   41: 
   42: AuthInfo = tuple[Optional[str], Optional[str]]
   43: 
   44: 
   45: def is_url(name: str) -> bool:
   46:     """
   47:     Return true if the name looks like a URL.
   48:     """
   49:     scheme = urllib.parse.urlsplit(name).scheme
   50:     if not scheme:
   51:         return False
   52:     return scheme in ["http", "https", "file", "ftp"] + vcs.all_schemes
   53: 
   54: 
   55: def make_vcs_requirement_url(
   56:     repo_url: str, rev: str, project_name: str, subdir: str | None = None
   57: ) -> str:
   58:     """
   59:     Return the URL for a VCS requirement.
   60: 
   61:     Args:
   62:       repo_url: the remote VCS url, with any needed VCS prefix (e.g. "git+").
   63:       project_name: the (unescaped) project name.
   64:     """
   65:     egg_project_name = project_name.replace("-", "_")
   66:     req = f"{repo_url}@{rev}#egg={egg_project_name}"
   67:     if subdir:
   68:         req += f"&subdirectory={subdir}"
   69: 
   70:     return req
   71: 
   72: 
   73: def find_path_to_project_root_from_repo_root(
   74:     location: str, repo_root: str
   75: ) -> str | None:
   76:     """
   77:     Find the the Python project's root by searching up the filesystem from
   78:     `location`. Return the path to project root relative to `repo_root`.
   79:     Return None if the project root is `repo_root`, or cannot be found.
   80:     """
   81:     # find project root.
   82:     orig_location = location
   83:     while not is_installable_dir(location):
   84:         last_location = location
   85:         location = os.path.dirname(location)
   86:         if location == last_location:
   87:             # We've traversed up to the root of the filesystem without
   88:             # finding a Python project.
   89:             logger.warning(
   90:                 "Could not find a Python project for directory %s (tried all "
   91:                 "parent directories)",
   92:                 orig_location,
   93:             )
   94:             return None
   95: 
   96:     if os.path.samefile(repo_root, location):
   97:         return None
   98: 
   99:     return os.path.relpath(location, repo_root)
  100: 
  101: 
  102: class RemoteNotFoundError(Exception):
  103:     pass
  104: 
  105: 
  106: class RemoteNotValidError(Exception):
  107:     def __init__(self, url: str):
  108:         super().__init__(url)
  109:         self.url = url
  110: 
  111: 
  112: @dataclass(frozen=True)
  113: class RevOptions:
  114:     """
  115:     Encapsulates a VCS-specific revision to install, along with any VCS
  116:     install options.
  117: 
  118:     Args:
  119:         vc_class: a VersionControl subclass.
  120:         rev: the name of the revision to install.
  121:         extra_args: a list of extra options.
  122:     """
  123: 
  124:     vc_class: type[VersionControl]
  125:     rev: str | None = None
  126:     extra_args: CommandArgs = field(default_factory=list)
  127:     branch_name: str | None = None
  128: 
  129:     def __repr__(self) -> str:
  130:         return f"<RevOptions {self.vc_class.name}: rev={self.rev!r}>"
  131: 
  132:     @property
  133:     def arg_rev(self) -> str | None:
  134:         if self.rev is None:
  135:             return self.vc_class.default_arg_rev
  136: 
  137:         return self.rev
  138: 
  139:     def to_args(self) -> CommandArgs:
  140:         """
  141:         Return the VCS-specific command arguments.
  142:         """
  143:         args: CommandArgs = []
  144:         rev = self.arg_rev
  145:         if rev is not None:
  146:             args += self.vc_class.get_base_rev_args(rev)
  147:         args += self.extra_args
  148: 
  149:         return args
  150: 
  151:     def to_display(self) -> str:
  152:         if not self.rev:
  153:             return ""
  154: 
  155:         return f" (to revision {self.rev})"
  156: 
  157:     def make_new(self, rev: str) -> RevOptions:
  158:         """
  159:         Make a copy of the current instance, but with a new rev.
  160: 
  161:         Args:
  162:           rev: the name of the revision for the new object.
  163:         """
  164:         return self.vc_class.make_rev_options(rev, extra_args=self.extra_args)
  165: 
  166: 
  167: class VcsSupport:
  168:     _registry: dict[str, VersionControl] = {}
  169:     schemes = ["ssh", "git", "hg", "bzr", "sftp", "svn"]
  170: 
  171:     def __init__(self) -> None:
  172:         # Register more schemes with urlparse for various version control
  173:         # systems
  174:         urllib.parse.uses_netloc.extend(self.schemes)
  175:         super().__init__()
  176: 
  177:     def __iter__(self) -> Iterator[str]:
  178:         return self._registry.__iter__()
  179: 
  180:     @property
  181:     def backends(self) -> list[VersionControl]:
  182:         return list(self._registry.values())
  183: 
  184:     @property
  185:     def dirnames(self) -> list[str]:
  186:         return [backend.dirname for backend in self.backends]
  187: 
  188:     @property
  189:     def all_schemes(self) -> list[str]:
  190:         schemes: list[str] = []
  191:         for backend in self.backends:
  192:             schemes.extend(backend.schemes)
  193:         return schemes
  194: 
  195:     def register(self, cls: type[VersionControl]) -> None:
  196:         if not hasattr(cls, "name"):
  197:             logger.warning("Cannot register VCS %s", cls.__name__)
  198:             return
  199:         if cls.name not in self._registry:
  200:             self._registry[cls.name] = cls()
  201:             logger.debug("Registered VCS backend: %s", cls.name)
  202: 
  203:     def unregister(self, name: str) -> None:
  204:         if name in self._registry:
  205:             del self._registry[name]
  206: 
  207:     def get_backend_for_dir(self, location: str) -> VersionControl | None:
  208:         """
  209:         Return a VersionControl object if a repository of that type is found
  210:         at the given directory.
  211:         """
  212:         vcs_backends = {}
  213:         for vcs_backend in self._registry.values():
  214:             repo_path = vcs_backend.get_repository_root(location)
  215:             if not repo_path:
  216:                 continue
  217:             logger.debug("Determine that %s uses VCS: %s", location, vcs_backend.name)
  218:             vcs_backends[repo_path] = vcs_backend
  219: 
  220:         if not vcs_backends:
  221:             return None
  222: 
  223:         # Choose the VCS in the inner-most directory. Since all repository
  224:         # roots found here would be either `location` or one of its
  225:         # parents, the longest path should have the most path components,
  226:         # i.e. the backend representing the inner-most repository.
  227:         inner_most_repo_path = max(vcs_backends, key=len)
  228:         return vcs_backends[inner_most_repo_path]
  229: 
  230:     def get_backend_for_scheme(self, scheme: str) -> VersionControl | None:
  231:         """
  232:         Return a VersionControl object or None.
  233:         """
  234:         for vcs_backend in self._registry.values():
  235:             if scheme in vcs_backend.schemes:
  236:                 return vcs_backend
  237:         return None
  238: 
  239:     def get_backend(self, name: str) -> VersionControl | None:
  240:         """
  241:         Return a VersionControl object or None.
  242:         """
  243:         name = name.lower()
  244:         return self._registry.get(name)
  245: 
  246: 
  247: vcs = VcsSupport()
  248: 
  249: 
  250: class VersionControl:
  251:     name = ""
  252:     dirname = ""
  253:     repo_name = ""
  254:     # List of supported schemes for this Version Control
  255:     schemes: tuple[str, ...] = ()
  256:     # Iterable of environment variable names to pass to call_subprocess().
  257:     unset_environ: tuple[str, ...] = ()
  258:     default_arg_rev: str | None = None
  259: 
  260:     @classmethod
  261:     def should_add_vcs_url_prefix(cls, remote_url: str) -> bool:
  262:         """
  263:         Return whether the vcs prefix (e.g. "git+") should be added to a
  264:         repository's remote url when used in a requirement.
  265:         """
  266:         return not remote_url.lower().startswith(f"{cls.name}:")
  267: 
  268:     @classmethod
  269:     def get_subdirectory(cls, location: str) -> str | None:
  270:         """
  271:         Return the path to Python project root, relative to the repo root.
  272:         Return None if the project root is in the repo root.
  273:         """
  274:         return None
  275: 
  276:     @classmethod
  277:     def get_requirement_revision(cls, repo_dir: str) -> str:
  278:         """
  279:         Return the revision string that should be used in a requirement.
  280:         """
  281:         return cls.get_revision(repo_dir)
  282: 
  283:     @classmethod
  284:     def get_src_requirement(cls, repo_dir: str, project_name: str) -> str:
  285:         """
  286:         Return the requirement string to use to redownload the files
  287:         currently at the given repository directory.
  288: 
  289:         Args:
  290:           project_name: the (unescaped) project name.
  291: 
  292:         The return value has a form similar to the following:
  293: 
  294:             {repository_url}@{revision}#egg={project_name}
  295:         """
  296:         repo_url = cls.get_remote_url(repo_dir)
  297: 
  298:         if cls.should_add_vcs_url_prefix(repo_url):
  299:             repo_url = f"{cls.name}+{repo_url}"
  300: 
  301:         revision = cls.get_requirement_revision(repo_dir)
  302:         subdir = cls.get_subdirectory(repo_dir)
  303:         req = make_vcs_requirement_url(repo_url, revision, project_name, subdir=subdir)
  304: 
  305:         return req
  306: 
  307:     @staticmethod
  308:     def get_base_rev_args(rev: str) -> list[str]:
  309:         """
  310:         Return the base revision arguments for a vcs command.
  311: 
  312:         Args:
  313:           rev: the name of a revision to install.  Cannot be None.
  314:         """
  315:         raise NotImplementedError
  316: 
  317:     def is_immutable_rev_checkout(self, url: str, dest: str) -> bool:
  318:         """
  319:         Return true if the commit hash checked out at dest matches
  320:         the revision in url.
  321: 
  322:         Always return False, if the VCS does not support immutable commit
  323:         hashes.
  324: 
  325:         This method does not check if there are local uncommitted changes
  326:         in dest after checkout, as pip currently has no use case for that.
  327:         """
  328:         return False
  329: 
  330:     @classmethod
  331:     def make_rev_options(
  332:         cls, rev: str | None = None, extra_args: CommandArgs | None = None
  333:     ) -> RevOptions:
  334:         """
  335:         Return a RevOptions object.
  336: 
  337:         Args:
  338:           rev: the name of a revision to install.
  339:           extra_args: a list of extra options.
  340:         """
  341:         return RevOptions(cls, rev, extra_args=extra_args or [])
  342: 
  343:     @classmethod
  344:     def _is_local_repository(cls, repo: str) -> bool:
  345:         """
  346:         posix absolute paths start with os.path.sep,
  347:         win32 ones start with drive (like c:\\folder)
  348:         """
  349:         drive, tail = os.path.splitdrive(repo)
  350:         return repo.startswith(os.path.sep) or bool(drive)
  351: 
  352:     @classmethod
  353:     def get_netloc_and_auth(
  354:         cls, netloc: str, scheme: str
  355:     ) -> tuple[str, tuple[str | None, str | None]]:
  356:         """
  357:         Parse the repository URL's netloc, and return the new netloc to use
  358:         along with auth information.
  359: 
  360:         Args:
  361:           netloc: the original repository URL netloc.
  362:           scheme: the repository URL's scheme without the vcs prefix.
  363: 
  364:         This is mainly for the Subversion class to override, so that auth
  365:         information can be provided via the --username and --password options
  366:         instead of through the URL.  For other subclasses like Git without
  367:         such an option, auth information must stay in the URL.
  368: 
  369:         Returns: (netloc, (username, password)).
  370:         """
  371:         return netloc, (None, None)
  372: 
  373:     @classmethod
  374:     def get_url_rev_and_auth(cls, url: str) -> tuple[str, str | None, AuthInfo]:
  375:         """
  376:         Parse the repository URL to use, and return the URL, revision,
  377:         and auth info to use.
  378: 
  379:         Returns: (url, rev, (username, password)).
  380:         """
  381:         scheme, netloc, path, query, frag = urllib.parse.urlsplit(url)
  382:         if "+" not in scheme:
  383:             raise ValueError(
  384:                 f"Sorry, {url!r} is a malformed VCS url. "
  385:                 "The format is <vcs>+<protocol>://<url>, "
  386:                 "e.g. svn+http://myrepo/svn/MyApp#egg=MyApp"
  387:             )
  388:         # Remove the vcs prefix.
  389:         scheme = scheme.split("+", 1)[1]
  390:         netloc, user_pass = cls.get_netloc_and_auth(netloc, scheme)
  391:         rev = None
  392:         if "@" in path:
  393:             path, rev = path.rsplit("@", 1)
  394:             if not rev:
  395:                 raise InstallationError(
  396:                     f"The URL {url!r} has an empty revision (after @) "
  397:                     "which is not supported. Include a revision after @ "
  398:                     "or remove @ from the URL."
  399:                 )
  400:         url = urllib.parse.urlunsplit((scheme, netloc, path, query, ""))
  401:         return url, rev, user_pass
  402: 
  403:     @staticmethod
  404:     def make_rev_args(username: str | None, password: HiddenText | None) -> CommandArgs:
  405:         """
  406:         Return the RevOptions "extra arguments" to use in obtain().
  407:         """
  408:         return []
  409: 
  410:     def get_url_rev_options(self, url: HiddenText) -> tuple[HiddenText, RevOptions]:
  411:         """
  412:         Return the URL and RevOptions object to use in obtain(),
  413:         as a tuple (url, rev_options).
  414:         """
  415:         secret_url, rev, user_pass = self.get_url_rev_and_auth(url.secret)
  416:         username, secret_password = user_pass
  417:         password: HiddenText | None = None
  418:         if secret_password is not None:
  419:             password = hide_value(secret_password)
  420:         extra_args = self.make_rev_args(username, password)
  421:         rev_options = self.make_rev_options(rev, extra_args=extra_args)
  422: 
  423:         return hide_url(secret_url), rev_options
  424: 
  425:     @staticmethod
  426:     def normalize_url(url: str) -> str:
  427:         """
  428:         Normalize a URL for comparison by unquoting it and removing any
  429:         trailing slash.
  430:         """
  431:         return urllib.parse.unquote(url).rstrip("/")
  432: 
  433:     @classmethod
  434:     def compare_urls(cls, url1: str, url2: str) -> bool:
  435:         """
  436:         Compare two repo URLs for identity, ignoring incidental differences.
  437:         """
  438:         return cls.normalize_url(url1) == cls.normalize_url(url2)
  439: 
  440:     def fetch_new(
  441:         self, dest: str, url: HiddenText, rev_options: RevOptions, verbosity: int
  442:     ) -> None:
  443:         """
  444:         Fetch a revision from a repository, in the case that this is the
  445:         first fetch from the repository.
  446: 
  447:         Args:
  448:           dest: the directory to fetch the repository to.
  449:           rev_options: a RevOptions object.
  450:           verbosity: verbosity level.
  451:         """
  452:         raise NotImplementedError
  453: 
  454:     def switch(
  455:         self,
  456:         dest: str,
  457:         url: HiddenText,
  458:         rev_options: RevOptions,
  459:         verbosity: int = 0,
  460:     ) -> None:
  461:         """
  462:         Switch the repo at ``dest`` to point to ``URL``.
  463: 
  464:         Args:
  465:           rev_options: a RevOptions object.
  466:         """
  467:         raise NotImplementedError
  468: 
  469:     def update(
  470:         self,
  471:         dest: str,
  472:         url: HiddenText,
  473:         rev_options: RevOptions,
  474:         verbosity: int = 0,
  475:     ) -> None:
  476:         """
  477:         Update an already-existing repo to the given ``rev_options``.
  478: 
  479:         Args:
  480:           rev_options: a RevOptions object.
  481:         """
  482:         raise NotImplementedError
  483: 
  484:     @classmethod
  485:     def is_commit_id_equal(cls, dest: str, name: str | None) -> bool:
  486:         """
  487:         Return whether the id of the current commit equals the given name.
  488: 
  489:         Args:
  490:           dest: the repository directory.
  491:           name: a string name.
  492:         """
  493:         raise NotImplementedError
  494: 
  495:     def obtain(self, dest: str, url: HiddenText, verbosity: int) -> None:
  496:         """
  497:         Install or update in editable mode the package represented by this
  498:         VersionControl object.
  499: 
  500:         :param dest: the repository directory in which to install or update.
  501:         :param url: the repository URL starting with a vcs prefix.
  502:         :param verbosity: verbosity level.
  503:         """
  504:         url, rev_options = self.get_url_rev_options(url)
  505: 
  506:         if not os.path.exists(dest):
  507:             self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  508:             return
  509: 
  510:         rev_display = rev_options.to_display()
  511:         if self.is_repository_directory(dest):
  512:             existing_url = self.get_remote_url(dest)
  513:             if self.compare_urls(existing_url, url.secret):
  514:                 logger.debug(
  515:                     "%s in %s exists, and has correct URL (%s)",
  516:                     self.repo_name.title(),
  517:                     display_path(dest),
  518:                     url,
  519:                 )
  520:                 if not self.is_commit_id_equal(dest, rev_options.rev):
  521:                     logger.info(
  522:                         "Updating %s %s%s",
  523:                         display_path(dest),
  524:                         self.repo_name,
  525:                         rev_display,
  526:                     )
  527:                     self.update(dest, url, rev_options, verbosity=verbosity)
  528:                 else:
  529:                     logger.info("Skipping because already up-to-date.")
  530:                 return
  531: 
  532:             logger.warning(
  533:                 "%s %s in %s exists with URL %s",
  534:                 self.name,
  535:                 self.repo_name,
  536:                 display_path(dest),
  537:                 existing_url,
  538:             )
  539:             prompt = ("(s)witch, (i)gnore, (w)ipe, (b)ackup ", ("s", "i", "w", "b"))
  540:         else:
  541:             logger.warning(
  542:                 "Directory %s already exists, and is not a %s %s.",
  543:                 dest,
  544:                 self.name,
  545:                 self.repo_name,
  546:             )
  547:             # https://github.com/python/mypy/issues/1174
  548:             prompt = ("(i)gnore, (w)ipe, (b)ackup ", ("i", "w", "b"))  # type: ignore
  549: 
  550:         logger.warning(
  551:             "The plan is to install the %s repository %s",
  552:             self.name,
  553:             url,
  554:         )
  555:         response = ask_path_exists(f"What to do?  {prompt[0]}", prompt[1])
  556: 
  557:         if response == "a":
  558:             sys.exit(-1)
  559: 
  560:         if response == "w":
  561:             logger.warning("Deleting %s", display_path(dest))
  562:             rmtree(dest)
  563:             self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  564:             return
  565: 
  566:         if response == "b":
  567:             dest_dir = backup_dir(dest)
  568:             logger.warning("Backing up %s to %s", display_path(dest), dest_dir)
  569:             shutil.move(dest, dest_dir)
  570:             self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  571:             return
  572: 
  573:         # Do nothing if the response is "i".
  574:         if response == "s":
  575:             logger.info(
  576:                 "Switching %s %s to %s%s",
  577:                 self.repo_name,
  578:                 display_path(dest),
  579:                 url,
  580:                 rev_display,
  581:             )
  582:             self.switch(dest, url, rev_options, verbosity=verbosity)
  583: 
  584:     def unpack(self, location: str, url: HiddenText, verbosity: int) -> None:
  585:         """
  586:         Clean up current location and download the url repository
  587:         (and vcs infos) into location
  588: 
  589:         :param url: the repository URL starting with a vcs prefix.
  590:         :param verbosity: verbosity level.
  591:         """
  592:         if os.path.exists(location):
  593:             rmtree(location)
  594:         self.obtain(location, url=url, verbosity=verbosity)
  595: 
  596:     @classmethod
  597:     def get_remote_url(cls, location: str) -> str:
  598:         """
  599:         Return the url used at location
  600: 
  601:         Raises RemoteNotFoundError if the repository does not have a remote
  602:         url configured.
  603:         """
  604:         raise NotImplementedError
  605: 
  606:     @classmethod
  607:     def get_revision(cls, location: str) -> str:
  608:         """
  609:         Return the current commit id of the files at the given location.
  610:         """
  611:         raise NotImplementedError
  612: 
  613:     @classmethod
  614:     def run_command(
  615:         cls,
  616:         cmd: list[str] | CommandArgs,
  617:         show_stdout: bool = True,
  618:         cwd: str | None = None,
  619:         on_returncode: Literal["raise", "warn", "ignore"] = "raise",
  620:         extra_ok_returncodes: Iterable[int] | None = None,
  621:         command_desc: str | None = None,
  622:         extra_environ: Mapping[str, Any] | None = None,
  623:         spinner: SpinnerInterface | None = None,
  624:         log_failed_cmd: bool = True,
  625:         stdout_only: bool = False,
  626:     ) -> str:
  627:         """
  628:         Run a VCS subcommand
  629:         This is simply a wrapper around call_subprocess that adds the VCS
  630:         command name, and checks that the VCS is available
  631:         """
  632:         cmd = make_command(cls.name, *cmd)
  633:         if command_desc is None:
  634:             command_desc = format_command_args(cmd)
  635:         try:
  636:             return call_subprocess(
  637:                 cmd,
  638:                 show_stdout,
  639:                 cwd,
  640:                 on_returncode=on_returncode,
  641:                 extra_ok_returncodes=extra_ok_returncodes,
  642:                 command_desc=command_desc,
  643:                 extra_environ=extra_environ,
  644:                 unset_environ=cls.unset_environ,
  645:                 spinner=spinner,
  646:                 log_failed_cmd=log_failed_cmd,
  647:                 stdout_only=stdout_only,
  648:             )
  649:         except NotADirectoryError:
  650:             raise BadCommand(f"Cannot find command {cls.name!r} - invalid PATH")
  651:         except FileNotFoundError:
  652:             # errno.ENOENT = no such file or directory
  653:             # In other words, the VCS executable isn't available
  654:             raise BadCommand(
  655:                 f"Cannot find command {cls.name!r} - do you have "
  656:                 f"{cls.name!r} installed and in your PATH?"
  657:             )
  658:         except PermissionError:
  659:             # errno.EACCES = Permission denied
  660:             # This error occurs, for instance, when the command is installed
  661:             # only for another user. So, the current user don't have
  662:             # permission to call the other user command.
  663:             raise BadCommand(
  664:                 f"No permission to execute {cls.name!r} - install it "
  665:                 f"locally, globally (ask admin), or check your PATH. "
  666:                 f"See possible solutions at "
  667:                 f"https://pip.pypa.io/en/latest/reference/pip_freeze/"
  668:                 f"#fixing-permission-denied."
  669:             )
  670: 
  671:     @classmethod
  672:     def is_repository_directory(cls, path: str) -> bool:
  673:         """
  674:         Return whether a directory path is a repository directory.
  675:         """
  676:         logger.debug("Checking in %s for %s (%s)...", path, cls.dirname, cls.name)
  677:         return os.path.exists(os.path.join(path, cls.dirname))
  678: 
  679:     @classmethod
  680:     def get_repository_root(cls, location: str) -> str | None:
  681:         """
  682:         Return the "root" (top-level) directory controlled by the vcs,
  683:         or `None` if the directory is not in any.
  684: 
  685:         It is meant to be overridden to implement smarter detection
  686:         mechanisms for specific vcs.
  687: 
  688:         This can do more than is_repository_directory() alone. For
  689:         example, the Git override checks that Git is actually available.
  690:         """
  691:         if cls.is_repository_directory(location):
  692:             return location
  693:         return None
