    1: """Represents a wheel file and provides access to the various parts of the
    2: name that have meaning.
    3: """
    4: 
    5: from __future__ import annotations
    6: 
    7: import re
    8: from collections.abc import Iterable
    9: 
   10: from pip._vendor.packaging.tags import Tag
   11: from pip._vendor.packaging.utils import BuildTag, parse_wheel_filename
   12: from pip._vendor.packaging.utils import (
   13:     InvalidWheelFilename as _PackagingInvalidWheelFilename,
   14: )
   15: 
   16: from pip._internal.exceptions import InvalidWheelFilename
   17: from pip._internal.utils.deprecation import deprecated
   18: 
   19: 
   20: class Wheel:
   21:     """A wheel file"""
   22: 
   23:     legacy_wheel_file_re = re.compile(
   24:         r"""^(?P<namever>(?P<name>[^\s-]+?)-(?P<ver>[^\s-]*?))
   25:         ((-(?P<build>\d[^-]*?))?-(?P<pyver>[^\s-]+?)-(?P<abi>[^\s-]+?)-(?P<plat>[^\s-]+?)
   26:         \.whl|\.dist-info)$""",
   27:         re.VERBOSE,
   28:     )
   29: 
   30:     def __init__(self, filename: str) -> None:
   31:         self.filename = filename
   32: 
   33:         # To make mypy happy specify type hints that can come from either
   34:         # parse_wheel_filename or the legacy_wheel_file_re match.
   35:         self.name: str
   36:         self._build_tag: BuildTag | None = None
   37: 
   38:         try:
   39:             wheel_info = parse_wheel_filename(filename)
   40:             self.name, _version, self._build_tag, self.file_tags = wheel_info
   41:             self.version = str(_version)
   42:         except _PackagingInvalidWheelFilename as e:
   43:             # Check if the wheel filename is in the legacy format
   44:             legacy_wheel_info = self.legacy_wheel_file_re.match(filename)
   45:             if not legacy_wheel_info:
   46:                 raise InvalidWheelFilename(e.args[0]) from None
   47: 
   48:             deprecated(
   49:                 reason=(
   50:                     f"Wheel filename {filename!r} is not correctly normalised. "
   51:                     "Future versions of pip will raise the following error:\n"
   52:                     f"{e.args[0]}\n\n"
   53:                 ),
   54:                 replacement=(
   55:                     "to rename the wheel to use a correctly normalised "
   56:                     "name (this may require updating the version in "
   57:                     "the project metadata)"
   58:                 ),
   59:                 gone_in="25.3",
   60:                 issue=12938,
   61:             )
   62: 
   63:             self.name = legacy_wheel_info.group("name").replace("_", "-")
   64:             self.version = legacy_wheel_info.group("ver").replace("_", "-")
   65: 
   66:             # Generate the file tags from the legacy wheel filename
   67:             pyversions = legacy_wheel_info.group("pyver").split(".")
   68:             abis = legacy_wheel_info.group("abi").split(".")
   69:             plats = legacy_wheel_info.group("plat").split(".")
   70:             self.file_tags = frozenset(
   71:                 Tag(interpreter=py, abi=abi, platform=plat)
   72:                 for py in pyversions
   73:                 for abi in abis
   74:                 for plat in plats
   75:             )
   76: 
   77:     @property
   78:     def build_tag(self) -> BuildTag:
   79:         if self._build_tag is not None:
   80:             return self._build_tag
   81: 
   82:         # Parse the build tag from the legacy wheel filename
   83:         legacy_wheel_info = self.legacy_wheel_file_re.match(self.filename)
   84:         assert legacy_wheel_info is not None, "guaranteed by filename validation"
   85:         build_tag = legacy_wheel_info.group("build")
   86:         match = re.match(r"^(\d+)(.*)$", build_tag)
   87:         assert match is not None, "guaranteed by filename validation"
   88:         build_tag_groups = match.groups()
   89:         self._build_tag = (int(build_tag_groups[0]), build_tag_groups[1])
   90: 
   91:         return self._build_tag
   92: 
   93:     def get_formatted_file_tags(self) -> list[str]:
   94:         """Return the wheel's tags as a sorted list of strings."""
   95:         return sorted(str(tag) for tag in self.file_tags)
   96: 
   97:     def support_index_min(self, tags: list[Tag]) -> int:
   98:         """Return the lowest index that one of the wheel's file_tag combinations
   99:         achieves in the given list of supported tags.
  100: 
  101:         For example, if there are 8 supported tags and one of the file tags
  102:         is first in the list, then return 0.
  103: 
  104:         :param tags: the PEP 425 tags to check the wheel against, in order
  105:             with most preferred first.
  106: 
  107:         :raises ValueError: If none of the wheel's file tags match one of
  108:             the supported tags.
  109:         """
  110:         try:
  111:             return next(i for i, t in enumerate(tags) if t in self.file_tags)
  112:         except StopIteration:
  113:             raise ValueError()
  114: 
  115:     def find_most_preferred_tag(
  116:         self, tags: list[Tag], tag_to_priority: dict[Tag, int]
  117:     ) -> int:
  118:         """Return the priority of the most preferred tag that one of the wheel's file
  119:         tag combinations achieves in the given list of supported tags using the given
  120:         tag_to_priority mapping, where lower priorities are more-preferred.
  121: 
  122:         This is used in place of support_index_min in some cases in order to avoid
  123:         an expensive linear scan of a large list of tags.
  124: 
  125:         :param tags: the PEP 425 tags to check the wheel against.
  126:         :param tag_to_priority: a mapping from tag to priority of that tag, where
  127:             lower is more preferred.
  128: 
  129:         :raises ValueError: If none of the wheel's file tags match one of
  130:             the supported tags.
  131:         """
  132:         return min(
  133:             tag_to_priority[tag] for tag in self.file_tags if tag in tag_to_priority
  134:         )
  135: 
  136:     def supported(self, tags: Iterable[Tag]) -> bool:
  137:         """Return whether the wheel is compatible with one of the given tags.
  138: 
  139:         :param tags: the PEP 425 tags to check the wheel against.
  140:         """
  141:         return not self.file_tags.isdisjoint(tags)
