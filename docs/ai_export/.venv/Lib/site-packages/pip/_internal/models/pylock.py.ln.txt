    1: from __future__ import annotations
    2: 
    3: import dataclasses
    4: import re
    5: from collections.abc import Iterable
    6: from dataclasses import dataclass
    7: from pathlib import Path
    8: from typing import TYPE_CHECKING, Any
    9: 
   10: from pip._vendor import tomli_w
   11: 
   12: from pip._internal.models.direct_url import ArchiveInfo, DirInfo, VcsInfo
   13: from pip._internal.models.link import Link
   14: from pip._internal.req.req_install import InstallRequirement
   15: from pip._internal.utils.urls import url_to_path
   16: 
   17: if TYPE_CHECKING:
   18:     from typing_extensions import Self
   19: 
   20: PYLOCK_FILE_NAME_RE = re.compile(r"^pylock\.([^.]+)\.toml$")
   21: 
   22: 
   23: def is_valid_pylock_file_name(path: Path) -> bool:
   24:     return path.name == "pylock.toml" or bool(re.match(PYLOCK_FILE_NAME_RE, path.name))
   25: 
   26: 
   27: def _toml_dict_factory(data: list[tuple[str, Any]]) -> dict[str, Any]:
   28:     return {key.replace("_", "-"): value for key, value in data if value is not None}
   29: 
   30: 
   31: @dataclass
   32: class PackageVcs:
   33:     type: str
   34:     url: str | None
   35:     # (not supported) path: Optional[str]
   36:     requested_revision: str | None
   37:     commit_id: str
   38:     subdirectory: str | None
   39: 
   40: 
   41: @dataclass
   42: class PackageDirectory:
   43:     path: str
   44:     editable: bool | None
   45:     subdirectory: str | None
   46: 
   47: 
   48: @dataclass
   49: class PackageArchive:
   50:     url: str | None
   51:     # (not supported) path: Optional[str]
   52:     # (not supported) size: Optional[int]
   53:     # (not supported) upload_time: Optional[datetime]
   54:     hashes: dict[str, str]
   55:     subdirectory: str | None
   56: 
   57: 
   58: @dataclass
   59: class PackageSdist:
   60:     name: str
   61:     # (not supported) upload_time: Optional[datetime]
   62:     url: str | None
   63:     # (not supported) path: Optional[str]
   64:     # (not supported) size: Optional[int]
   65:     hashes: dict[str, str]
   66: 
   67: 
   68: @dataclass
   69: class PackageWheel:
   70:     name: str
   71:     # (not supported) upload_time: Optional[datetime]
   72:     url: str | None
   73:     # (not supported) path: Optional[str]
   74:     # (not supported) size: Optional[int]
   75:     hashes: dict[str, str]
   76: 
   77: 
   78: @dataclass
   79: class Package:
   80:     name: str
   81:     version: str | None = None
   82:     # (not supported) marker: Optional[str]
   83:     # (not supported) requires_python: Optional[str]
   84:     # (not supported) dependencies
   85:     vcs: PackageVcs | None = None
   86:     directory: PackageDirectory | None = None
   87:     archive: PackageArchive | None = None
   88:     # (not supported) index: Optional[str]
   89:     sdist: PackageSdist | None = None
   90:     wheels: list[PackageWheel] | None = None
   91:     # (not supported) attestation_identities: Optional[List[Dict[str, Any]]]
   92:     # (not supported) tool: Optional[Dict[str, Any]]
   93: 
   94:     @classmethod
   95:     def from_install_requirement(cls, ireq: InstallRequirement, base_dir: Path) -> Self:
   96:         base_dir = base_dir.resolve()
   97:         dist = ireq.get_dist()
   98:         download_info = ireq.download_info
   99:         assert download_info
  100:         package = cls(name=dist.canonical_name)
  101:         if ireq.is_direct:
  102:             if isinstance(download_info.info, VcsInfo):
  103:                 package.vcs = PackageVcs(
  104:                     type=download_info.info.vcs,
  105:                     url=download_info.url,
  106:                     requested_revision=download_info.info.requested_revision,
  107:                     commit_id=download_info.info.commit_id,
  108:                     subdirectory=download_info.subdirectory,
  109:                 )
  110:             elif isinstance(download_info.info, DirInfo):
  111:                 package.directory = PackageDirectory(
  112:                     path=(
  113:                         Path(url_to_path(download_info.url))
  114:                         .resolve()
  115:                         .relative_to(base_dir)
  116:                         .as_posix()
  117:                     ),
  118:                     editable=(
  119:                         download_info.info.editable
  120:                         if download_info.info.editable
  121:                         else None
  122:                     ),
  123:                     subdirectory=download_info.subdirectory,
  124:                 )
  125:             elif isinstance(download_info.info, ArchiveInfo):
  126:                 if not download_info.info.hashes:
  127:                     raise NotImplementedError()
  128:                 package.archive = PackageArchive(
  129:                     url=download_info.url,
  130:                     hashes=download_info.info.hashes,
  131:                     subdirectory=download_info.subdirectory,
  132:                 )
  133:             else:
  134:                 # should never happen
  135:                 raise NotImplementedError()
  136:         else:
  137:             package.version = str(dist.version)
  138:             if isinstance(download_info.info, ArchiveInfo):
  139:                 if not download_info.info.hashes:
  140:                     raise NotImplementedError()
  141:                 link = Link(download_info.url)
  142:                 if link.is_wheel:
  143:                     package.wheels = [
  144:                         PackageWheel(
  145:                             name=link.filename,
  146:                             url=download_info.url,
  147:                             hashes=download_info.info.hashes,
  148:                         )
  149:                     ]
  150:                 else:
  151:                     package.sdist = PackageSdist(
  152:                         name=link.filename,
  153:                         url=download_info.url,
  154:                         hashes=download_info.info.hashes,
  155:                     )
  156:             else:
  157:                 # should never happen
  158:                 raise NotImplementedError()
  159:         return package
  160: 
  161: 
  162: @dataclass
  163: class Pylock:
  164:     lock_version: str = "1.0"
  165:     # (not supported) environments: Optional[List[str]]
  166:     # (not supported) requires_python: Optional[str]
  167:     # (not supported) extras: List[str] = []
  168:     # (not supported) dependency_groups: List[str] = []
  169:     created_by: str = "pip"
  170:     packages: list[Package] = dataclasses.field(default_factory=list)
  171:     # (not supported) tool: Optional[Dict[str, Any]]
  172: 
  173:     def as_toml(self) -> str:
  174:         return tomli_w.dumps(dataclasses.asdict(self, dict_factory=_toml_dict_factory))
  175: 
  176:     @classmethod
  177:     def from_install_requirements(
  178:         cls, install_requirements: Iterable[InstallRequirement], base_dir: Path
  179:     ) -> Self:
  180:         return cls(
  181:             packages=sorted(
  182:                 (
  183:                     Package.from_install_requirement(ireq, base_dir)
  184:                     for ireq in install_requirements
  185:                 ),
  186:                 key=lambda p: p.name,
  187:             )
  188:         )
