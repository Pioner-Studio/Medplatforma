    1: import os
    2: import stat
    3: import sys
    4: import typing as t
    5: from datetime import datetime
    6: from gettext import gettext as _
    7: from gettext import ngettext
    8: 
    9: from ._compat import _get_argv_encoding
   10: from ._compat import open_stream
   11: from .exceptions import BadParameter
   12: from .utils import format_filename
   13: from .utils import LazyFile
   14: from .utils import safecall
   15: 
   16: if t.TYPE_CHECKING:
   17:     import typing_extensions as te
   18:     from .core import Context
   19:     from .core import Parameter
   20:     from .shell_completion import CompletionItem
   21: 
   22: 
   23: class ParamType:
   24:     """Represents the type of a parameter. Validates and converts values
   25:     from the command line or Python into the correct type.
   26: 
   27:     To implement a custom type, subclass and implement at least the
   28:     following:
   29: 
   30:     -   The :attr:`name` class attribute must be set.
   31:     -   Calling an instance of the type with ``None`` must return
   32:         ``None``. This is already implemented by default.
   33:     -   :meth:`convert` must convert string values to the correct type.
   34:     -   :meth:`convert` must accept values that are already the correct
   35:         type.
   36:     -   It must be able to convert a value if the ``ctx`` and ``param``
   37:         arguments are ``None``. This can occur when converting prompt
   38:         input.
   39:     """
   40: 
   41:     is_composite: t.ClassVar[bool] = False
   42:     arity: t.ClassVar[int] = 1
   43: 
   44:     #: the descriptive name of this type
   45:     name: str
   46: 
   47:     #: if a list of this type is expected and the value is pulled from a
   48:     #: string environment variable, this is what splits it up.  `None`
   49:     #: means any whitespace.  For all parameters the general rule is that
   50:     #: whitespace splits them up.  The exception are paths and files which
   51:     #: are split by ``os.path.pathsep`` by default (":" on Unix and ";" on
   52:     #: Windows).
   53:     envvar_list_splitter: t.ClassVar[t.Optional[str]] = None
   54: 
   55:     def to_info_dict(self) -> t.Dict[str, t.Any]:
   56:         """Gather information that could be useful for a tool generating
   57:         user-facing documentation.
   58: 
   59:         Use :meth:`click.Context.to_info_dict` to traverse the entire
   60:         CLI structure.
   61: 
   62:         .. versionadded:: 8.0
   63:         """
   64:         # The class name without the "ParamType" suffix.
   65:         param_type = type(self).__name__.partition("ParamType")[0]
   66:         param_type = param_type.partition("ParameterType")[0]
   67: 
   68:         # Custom subclasses might not remember to set a name.
   69:         if hasattr(self, "name"):
   70:             name = self.name
   71:         else:
   72:             name = param_type
   73: 
   74:         return {"param_type": param_type, "name": name}
   75: 
   76:     def __call__(
   77:         self,
   78:         value: t.Any,
   79:         param: t.Optional["Parameter"] = None,
   80:         ctx: t.Optional["Context"] = None,
   81:     ) -> t.Any:
   82:         if value is not None:
   83:             return self.convert(value, param, ctx)
   84: 
   85:     def get_metavar(self, param: "Parameter") -> t.Optional[str]:
   86:         """Returns the metavar default for this param if it provides one."""
   87: 
   88:     def get_missing_message(self, param: "Parameter") -> t.Optional[str]:
   89:         """Optionally might return extra information about a missing
   90:         parameter.
   91: 
   92:         .. versionadded:: 2.0
   93:         """
   94: 
   95:     def convert(
   96:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
   97:     ) -> t.Any:
   98:         """Convert the value to the correct type. This is not called if
   99:         the value is ``None`` (the missing value).
  100: 
  101:         This must accept string values from the command line, as well as
  102:         values that are already the correct type. It may also convert
  103:         other compatible types.
  104: 
  105:         The ``param`` and ``ctx`` arguments may be ``None`` in certain
  106:         situations, such as when converting prompt input.
  107: 
  108:         If the value cannot be converted, call :meth:`fail` with a
  109:         descriptive message.
  110: 
  111:         :param value: The value to convert.
  112:         :param param: The parameter that is using this type to convert
  113:             its value. May be ``None``.
  114:         :param ctx: The current context that arrived at this value. May
  115:             be ``None``.
  116:         """
  117:         return value
  118: 
  119:     def split_envvar_value(self, rv: str) -> t.Sequence[str]:
  120:         """Given a value from an environment variable this splits it up
  121:         into small chunks depending on the defined envvar list splitter.
  122: 
  123:         If the splitter is set to `None`, which means that whitespace splits,
  124:         then leading and trailing whitespace is ignored.  Otherwise, leading
  125:         and trailing splitters usually lead to empty items being included.
  126:         """
  127:         return (rv or "").split(self.envvar_list_splitter)
  128: 
  129:     def fail(
  130:         self,
  131:         message: str,
  132:         param: t.Optional["Parameter"] = None,
  133:         ctx: t.Optional["Context"] = None,
  134:     ) -> "t.NoReturn":
  135:         """Helper method to fail with an invalid value message."""
  136:         raise BadParameter(message, ctx=ctx, param=param)
  137: 
  138:     def shell_complete(
  139:         self, ctx: "Context", param: "Parameter", incomplete: str
  140:     ) -> t.List["CompletionItem"]:
  141:         """Return a list of
  142:         :class:`~click.shell_completion.CompletionItem` objects for the
  143:         incomplete value. Most types do not provide completions, but
  144:         some do, and this allows custom types to provide custom
  145:         completions as well.
  146: 
  147:         :param ctx: Invocation context for this command.
  148:         :param param: The parameter that is requesting completion.
  149:         :param incomplete: Value being completed. May be empty.
  150: 
  151:         .. versionadded:: 8.0
  152:         """
  153:         return []
  154: 
  155: 
  156: class CompositeParamType(ParamType):
  157:     is_composite = True
  158: 
  159:     @property
  160:     def arity(self) -> int:  # type: ignore
  161:         raise NotImplementedError()
  162: 
  163: 
  164: class FuncParamType(ParamType):
  165:     def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
  166:         self.name: str = func.__name__
  167:         self.func = func
  168: 
  169:     def to_info_dict(self) -> t.Dict[str, t.Any]:
  170:         info_dict = super().to_info_dict()
  171:         info_dict["func"] = self.func
  172:         return info_dict
  173: 
  174:     def convert(
  175:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
  176:     ) -> t.Any:
  177:         try:
  178:             return self.func(value)
  179:         except ValueError:
  180:             try:
  181:                 value = str(value)
  182:             except UnicodeError:
  183:                 value = value.decode("utf-8", "replace")
  184: 
  185:             self.fail(value, param, ctx)
  186: 
  187: 
  188: class UnprocessedParamType(ParamType):
  189:     name = "text"
  190: 
  191:     def convert(
  192:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
  193:     ) -> t.Any:
  194:         return value
  195: 
  196:     def __repr__(self) -> str:
  197:         return "UNPROCESSED"
  198: 
  199: 
  200: class StringParamType(ParamType):
  201:     name = "text"
  202: 
  203:     def convert(
  204:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
  205:     ) -> t.Any:
  206:         if isinstance(value, bytes):
  207:             enc = _get_argv_encoding()
  208:             try:
  209:                 value = value.decode(enc)
  210:             except UnicodeError:
  211:                 fs_enc = sys.getfilesystemencoding()
  212:                 if fs_enc != enc:
  213:                     try:
  214:                         value = value.decode(fs_enc)
  215:                     except UnicodeError:
  216:                         value = value.decode("utf-8", "replace")
  217:                 else:
  218:                     value = value.decode("utf-8", "replace")
  219:             return value
  220:         return str(value)
  221: 
  222:     def __repr__(self) -> str:
  223:         return "STRING"
  224: 
  225: 
  226: class Choice(ParamType):
  227:     """The choice type allows a value to be checked against a fixed set
  228:     of supported values. All of these values have to be strings.
  229: 
  230:     You should only pass a list or tuple of choices. Other iterables
  231:     (like generators) may lead to surprising results.
  232: 
  233:     The resulting value will always be one of the originally passed choices
  234:     regardless of ``case_sensitive`` or any ``ctx.token_normalize_func``
  235:     being specified.
  236: 
  237:     See :ref:`choice-opts` for an example.
  238: 
  239:     :param case_sensitive: Set to false to make choices case
  240:         insensitive. Defaults to true.
  241:     """
  242: 
  243:     name = "choice"
  244: 
  245:     def __init__(self, choices: t.Sequence[str], case_sensitive: bool = True) -> None:
  246:         self.choices = choices
  247:         self.case_sensitive = case_sensitive
  248: 
  249:     def to_info_dict(self) -> t.Dict[str, t.Any]:
  250:         info_dict = super().to_info_dict()
  251:         info_dict["choices"] = self.choices
  252:         info_dict["case_sensitive"] = self.case_sensitive
  253:         return info_dict
  254: 
  255:     def get_metavar(self, param: "Parameter") -> str:
  256:         choices_str = "|".join(self.choices)
  257: 
  258:         # Use curly braces to indicate a required argument.
  259:         if param.required and param.param_type_name == "argument":
  260:             return f"{{{choices_str}}}"
  261: 
  262:         # Use square braces to indicate an option or optional argument.
  263:         return f"[{choices_str}]"
  264: 
  265:     def get_missing_message(self, param: "Parameter") -> str:
  266:         return _("Choose from:\n\t{choices}").format(choices=",\n\t".join(self.choices))
  267: 
  268:     def convert(
  269:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
  270:     ) -> t.Any:
  271:         # Match through normalization and case sensitivity
  272:         # first do token_normalize_func, then lowercase
  273:         # preserve original `value` to produce an accurate message in
  274:         # `self.fail`
  275:         normed_value = value
  276:         normed_choices = {choice: choice for choice in self.choices}
  277: 
  278:         if ctx is not None and ctx.token_normalize_func is not None:
  279:             normed_value = ctx.token_normalize_func(value)
  280:             normed_choices = {
  281:                 ctx.token_normalize_func(normed_choice): original
  282:                 for normed_choice, original in normed_choices.items()
  283:             }
  284: 
  285:         if not self.case_sensitive:
  286:             normed_value = normed_value.casefold()
  287:             normed_choices = {
  288:                 normed_choice.casefold(): original
  289:                 for normed_choice, original in normed_choices.items()
  290:             }
  291: 
  292:         if normed_value in normed_choices:
  293:             return normed_choices[normed_value]
  294: 
  295:         choices_str = ", ".join(map(repr, self.choices))
  296:         self.fail(
  297:             ngettext(
  298:                 "{value!r} is not {choice}.",
  299:                 "{value!r} is not one of {choices}.",
  300:                 len(self.choices),
  301:             ).format(value=value, choice=choices_str, choices=choices_str),
  302:             param,
  303:             ctx,
  304:         )
  305: 
  306:     def __repr__(self) -> str:
  307:         return f"Choice({list(self.choices)})"
  308: 
  309:     def shell_complete(
  310:         self, ctx: "Context", param: "Parameter", incomplete: str
  311:     ) -> t.List["CompletionItem"]:
  312:         """Complete choices that start with the incomplete value.
  313: 
  314:         :param ctx: Invocation context for this command.
  315:         :param param: The parameter that is requesting completion.
  316:         :param incomplete: Value being completed. May be empty.
  317: 
  318:         .. versionadded:: 8.0
  319:         """
  320:         from click.shell_completion import CompletionItem
  321: 
  322:         str_choices = map(str, self.choices)
  323: 
  324:         if self.case_sensitive:
  325:             matched = (c for c in str_choices if c.startswith(incomplete))
  326:         else:
  327:             incomplete = incomplete.lower()
  328:             matched = (c for c in str_choices if c.lower().startswith(incomplete))
  329: 
  330:         return [CompletionItem(c) for c in matched]
  331: 
  332: 
  333: class DateTime(ParamType):
  334:     """The DateTime type converts date strings into `datetime` objects.
  335: 
  336:     The format strings which are checked are configurable, but default to some
  337:     common (non-timezone aware) ISO 8601 formats.
  338: 
  339:     When specifying *DateTime* formats, you should only pass a list or a tuple.
  340:     Other iterables, like generators, may lead to surprising results.
  341: 
  342:     The format strings are processed using ``datetime.strptime``, and this
  343:     consequently defines the format strings which are allowed.
  344: 
  345:     Parsing is tried using each format, in order, and the first format which
  346:     parses successfully is used.
  347: 
  348:     :param formats: A list or tuple of date format strings, in the order in
  349:                     which they should be tried. Defaults to
  350:                     ``'%Y-%m-%d'``, ``'%Y-%m-%dT%H:%M:%S'``,
  351:                     ``'%Y-%m-%d %H:%M:%S'``.
  352:     """
  353: 
  354:     name = "datetime"
  355: 
  356:     def __init__(self, formats: t.Optional[t.Sequence[str]] = None):
  357:         self.formats: t.Sequence[str] = formats or [
  358:             "%Y-%m-%d",
  359:             "%Y-%m-%dT%H:%M:%S",
  360:             "%Y-%m-%d %H:%M:%S",
  361:         ]
  362: 
  363:     def to_info_dict(self) -> t.Dict[str, t.Any]:
  364:         info_dict = super().to_info_dict()
  365:         info_dict["formats"] = self.formats
  366:         return info_dict
  367: 
  368:     def get_metavar(self, param: "Parameter") -> str:
  369:         return f"[{'|'.join(self.formats)}]"
  370: 
  371:     def _try_to_convert_date(self, value: t.Any, format: str) -> t.Optional[datetime]:
  372:         try:
  373:             return datetime.strptime(value, format)
  374:         except ValueError:
  375:             return None
  376: 
  377:     def convert(
  378:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
  379:     ) -> t.Any:
  380:         if isinstance(value, datetime):
  381:             return value
  382: 
  383:         for format in self.formats:
  384:             converted = self._try_to_convert_date(value, format)
  385: 
  386:             if converted is not None:
  387:                 return converted
  388: 
  389:         formats_str = ", ".join(map(repr, self.formats))
  390:         self.fail(
  391:             ngettext(
  392:                 "{value!r} does not match the format {format}.",
  393:                 "{value!r} does not match the formats {formats}.",
  394:                 len(self.formats),
  395:             ).format(value=value, format=formats_str, formats=formats_str),
  396:             param,
  397:             ctx,
  398:         )
  399: 
  400:     def __repr__(self) -> str:
  401:         return "DateTime"
  402: 
  403: 
  404: class _NumberParamTypeBase(ParamType):
  405:     _number_class: t.ClassVar[t.Type[t.Any]]
  406: 
  407:     def convert(
  408:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
  409:     ) -> t.Any:
  410:         try:
  411:             return self._number_class(value)
  412:         except ValueError:
  413:             self.fail(
  414:                 _("{value!r} is not a valid {number_type}.").format(
  415:                     value=value, number_type=self.name
  416:                 ),
  417:                 param,
  418:                 ctx,
  419:             )
  420: 
  421: 
  422: class _NumberRangeBase(_NumberParamTypeBase):
  423:     def __init__(
  424:         self,
  425:         min: t.Optional[float] = None,
  426:         max: t.Optional[float] = None,
  427:         min_open: bool = False,
  428:         max_open: bool = False,
  429:         clamp: bool = False,
  430:     ) -> None:
  431:         self.min = min
  432:         self.max = max
  433:         self.min_open = min_open
  434:         self.max_open = max_open
  435:         self.clamp = clamp
  436: 
  437:     def to_info_dict(self) -> t.Dict[str, t.Any]:
  438:         info_dict = super().to_info_dict()
  439:         info_dict.update(
  440:             min=self.min,
  441:             max=self.max,
  442:             min_open=self.min_open,
  443:             max_open=self.max_open,
  444:             clamp=self.clamp,
  445:         )
  446:         return info_dict
  447: 
  448:     def convert(
  449:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
  450:     ) -> t.Any:
  451:         import operator
  452: 
  453:         rv = super().convert(value, param, ctx)
  454:         lt_min: bool = self.min is not None and (
  455:             operator.le if self.min_open else operator.lt
  456:         )(rv, self.min)
  457:         gt_max: bool = self.max is not None and (
  458:             operator.ge if self.max_open else operator.gt
  459:         )(rv, self.max)
  460: 
  461:         if self.clamp:
  462:             if lt_min:
  463:                 return self._clamp(self.min, 1, self.min_open)  # type: ignore
  464: 
  465:             if gt_max:
  466:                 return self._clamp(self.max, -1, self.max_open)  # type: ignore
  467: 
  468:         if lt_min or gt_max:
  469:             self.fail(
  470:                 _("{value} is not in the range {range}.").format(
  471:                     value=rv, range=self._describe_range()
  472:                 ),
  473:                 param,
  474:                 ctx,
  475:             )
  476: 
  477:         return rv
  478: 
  479:     def _clamp(self, bound: float, dir: "te.Literal[1, -1]", open: bool) -> float:
  480:         """Find the valid value to clamp to bound in the given
  481:         direction.
  482: 
  483:         :param bound: The boundary value.
  484:         :param dir: 1 or -1 indicating the direction to move.
  485:         :param open: If true, the range does not include the bound.
  486:         """
  487:         raise NotImplementedError
  488: 
  489:     def _describe_range(self) -> str:
  490:         """Describe the range for use in help text."""
  491:         if self.min is None:
  492:             op = "<" if self.max_open else "<="
  493:             return f"x{op}{self.max}"
  494: 
  495:         if self.max is None:
  496:             op = ">" if self.min_open else ">="
  497:             return f"x{op}{self.min}"
  498: 
  499:         lop = "<" if self.min_open else "<="
  500:         rop = "<" if self.max_open else "<="
  501:         return f"{self.min}{lop}x{rop}{self.max}"
  502: 
  503:     def __repr__(self) -> str:
  504:         clamp = " clamped" if self.clamp else ""
  505:         return f"<{type(self).__name__} {self._describe_range()}{clamp}>"
  506: 
  507: 
  508: class IntParamType(_NumberParamTypeBase):
  509:     name = "integer"
  510:     _number_class = int
  511: 
  512:     def __repr__(self) -> str:
  513:         return "INT"
  514: 
  515: 
  516: class IntRange(_NumberRangeBase, IntParamType):
  517:     """Restrict an :data:`click.INT` value to a range of accepted
  518:     values. See :ref:`ranges`.
  519: 
  520:     If ``min`` or ``max`` are not passed, any value is accepted in that
  521:     direction. If ``min_open`` or ``max_open`` are enabled, the
  522:     corresponding boundary is not included in the range.
  523: 
  524:     If ``clamp`` is enabled, a value outside the range is clamped to the
  525:     boundary instead of failing.
  526: 
  527:     .. versionchanged:: 8.0
  528:         Added the ``min_open`` and ``max_open`` parameters.
  529:     """
  530: 
  531:     name = "integer range"
  532: 
  533:     def _clamp(  # type: ignore
  534:         self, bound: int, dir: "te.Literal[1, -1]", open: bool
  535:     ) -> int:
  536:         if not open:
  537:             return bound
  538: 
  539:         return bound + dir
  540: 
  541: 
  542: class FloatParamType(_NumberParamTypeBase):
  543:     name = "float"
  544:     _number_class = float
  545: 
  546:     def __repr__(self) -> str:
  547:         return "FLOAT"
  548: 
  549: 
  550: class FloatRange(_NumberRangeBase, FloatParamType):
  551:     """Restrict a :data:`click.FLOAT` value to a range of accepted
  552:     values. See :ref:`ranges`.
  553: 
  554:     If ``min`` or ``max`` are not passed, any value is accepted in that
  555:     direction. If ``min_open`` or ``max_open`` are enabled, the
  556:     corresponding boundary is not included in the range.
  557: 
  558:     If ``clamp`` is enabled, a value outside the range is clamped to the
  559:     boundary instead of failing. This is not supported if either
  560:     boundary is marked ``open``.
  561: 
  562:     .. versionchanged:: 8.0
  563:         Added the ``min_open`` and ``max_open`` parameters.
  564:     """
  565: 
  566:     name = "float range"
  567: 
  568:     def __init__(
  569:         self,
  570:         min: t.Optional[float] = None,
  571:         max: t.Optional[float] = None,
  572:         min_open: bool = False,
  573:         max_open: bool = False,
  574:         clamp: bool = False,
  575:     ) -> None:
  576:         super().__init__(
  577:             min=min, max=max, min_open=min_open, max_open=max_open, clamp=clamp
  578:         )
  579: 
  580:         if (min_open or max_open) and clamp:
  581:             raise TypeError("Clamping is not supported for open bounds.")
  582: 
  583:     def _clamp(self, bound: float, dir: "te.Literal[1, -1]", open: bool) -> float:
  584:         if not open:
  585:             return bound
  586: 
  587:         # Could use Python 3.9's math.nextafter here, but clamping an
  588:         # open float range doesn't seem to be particularly useful. It's
  589:         # left up to the user to write a callback to do it if needed.
  590:         raise RuntimeError("Clamping is not supported for open bounds.")
  591: 
  592: 
  593: class BoolParamType(ParamType):
  594:     name = "boolean"
  595: 
  596:     def convert(
  597:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
  598:     ) -> t.Any:
  599:         if value in {False, True}:
  600:             return bool(value)
  601: 
  602:         norm = value.strip().lower()
  603: 
  604:         if norm in {"1", "true", "t", "yes", "y", "on"}:
  605:             return True
  606: 
  607:         if norm in {"0", "false", "f", "no", "n", "off"}:
  608:             return False
  609: 
  610:         self.fail(
  611:             _("{value!r} is not a valid boolean.").format(value=value), param, ctx
  612:         )
  613: 
  614:     def __repr__(self) -> str:
  615:         return "BOOL"
  616: 
  617: 
  618: class UUIDParameterType(ParamType):
  619:     name = "uuid"
  620: 
  621:     def convert(
  622:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
  623:     ) -> t.Any:
  624:         import uuid
  625: 
  626:         if isinstance(value, uuid.UUID):
  627:             return value
  628: 
  629:         value = value.strip()
  630: 
  631:         try:
  632:             return uuid.UUID(value)
  633:         except ValueError:
  634:             self.fail(
  635:                 _("{value!r} is not a valid UUID.").format(value=value), param, ctx
  636:             )
  637: 
  638:     def __repr__(self) -> str:
  639:         return "UUID"
  640: 
  641: 
  642: class File(ParamType):
  643:     """Declares a parameter to be a file for reading or writing.  The file
  644:     is automatically closed once the context tears down (after the command
  645:     finished working).
  646: 
  647:     Files can be opened for reading or writing.  The special value ``-``
  648:     indicates stdin or stdout depending on the mode.
  649: 
  650:     By default, the file is opened for reading text data, but it can also be
  651:     opened in binary mode or for writing.  The encoding parameter can be used
  652:     to force a specific encoding.
  653: 
  654:     The `lazy` flag controls if the file should be opened immediately or upon
  655:     first IO. The default is to be non-lazy for standard input and output
  656:     streams as well as files opened for reading, `lazy` otherwise. When opening a
  657:     file lazily for reading, it is still opened temporarily for validation, but
  658:     will not be held open until first IO. lazy is mainly useful when opening
  659:     for writing to avoid creating the file until it is needed.
  660: 
  661:     Starting with Click 2.0, files can also be opened atomically in which
  662:     case all writes go into a separate file in the same folder and upon
  663:     completion the file will be moved over to the original location.  This
  664:     is useful if a file regularly read by other users is modified.
  665: 
  666:     See :ref:`file-args` for more information.
  667:     """
  668: 
  669:     name = "filename"
  670:     envvar_list_splitter: t.ClassVar[str] = os.path.pathsep
  671: 
  672:     def __init__(
  673:         self,
  674:         mode: str = "r",
  675:         encoding: t.Optional[str] = None,
  676:         errors: t.Optional[str] = "strict",
  677:         lazy: t.Optional[bool] = None,
  678:         atomic: bool = False,
  679:     ) -> None:
  680:         self.mode = mode
  681:         self.encoding = encoding
  682:         self.errors = errors
  683:         self.lazy = lazy
  684:         self.atomic = atomic
  685: 
  686:     def to_info_dict(self) -> t.Dict[str, t.Any]:
  687:         info_dict = super().to_info_dict()
  688:         info_dict.update(mode=self.mode, encoding=self.encoding)
  689:         return info_dict
  690: 
  691:     def resolve_lazy_flag(self, value: "t.Union[str, os.PathLike[str]]") -> bool:
  692:         if self.lazy is not None:
  693:             return self.lazy
  694:         if os.fspath(value) == "-":
  695:             return False
  696:         elif "w" in self.mode:
  697:             return True
  698:         return False
  699: 
  700:     def convert(
  701:         self,
  702:         value: t.Union[str, "os.PathLike[str]", t.IO[t.Any]],
  703:         param: t.Optional["Parameter"],
  704:         ctx: t.Optional["Context"],
  705:     ) -> t.IO[t.Any]:
  706:         if _is_file_like(value):
  707:             return value
  708: 
  709:         value = t.cast("t.Union[str, os.PathLike[str]]", value)
  710: 
  711:         try:
  712:             lazy = self.resolve_lazy_flag(value)
  713: 
  714:             if lazy:
  715:                 lf = LazyFile(
  716:                     value, self.mode, self.encoding, self.errors, atomic=self.atomic
  717:                 )
  718: 
  719:                 if ctx is not None:
  720:                     ctx.call_on_close(lf.close_intelligently)
  721: 
  722:                 return t.cast(t.IO[t.Any], lf)
  723: 
  724:             f, should_close = open_stream(
  725:                 value, self.mode, self.encoding, self.errors, atomic=self.atomic
  726:             )
  727: 
  728:             # If a context is provided, we automatically close the file
  729:             # at the end of the context execution (or flush out).  If a
  730:             # context does not exist, it's the caller's responsibility to
  731:             # properly close the file.  This for instance happens when the
  732:             # type is used with prompts.
  733:             if ctx is not None:
  734:                 if should_close:
  735:                     ctx.call_on_close(safecall(f.close))
  736:                 else:
  737:                     ctx.call_on_close(safecall(f.flush))
  738: 
  739:             return f
  740:         except OSError as e:  # noqa: B014
  741:             self.fail(f"'{format_filename(value)}': {e.strerror}", param, ctx)
  742: 
  743:     def shell_complete(
  744:         self, ctx: "Context", param: "Parameter", incomplete: str
  745:     ) -> t.List["CompletionItem"]:
  746:         """Return a special completion marker that tells the completion
  747:         system to use the shell to provide file path completions.
  748: 
  749:         :param ctx: Invocation context for this command.
  750:         :param param: The parameter that is requesting completion.
  751:         :param incomplete: Value being completed. May be empty.
  752: 
  753:         .. versionadded:: 8.0
  754:         """
  755:         from click.shell_completion import CompletionItem
  756: 
  757:         return [CompletionItem(incomplete, type="file")]
  758: 
  759: 
  760: def _is_file_like(value: t.Any) -> "te.TypeGuard[t.IO[t.Any]]":
  761:     return hasattr(value, "read") or hasattr(value, "write")
  762: 
  763: 
  764: class Path(ParamType):
  765:     """The ``Path`` type is similar to the :class:`File` type, but
  766:     returns the filename instead of an open file. Various checks can be
  767:     enabled to validate the type of file and permissions.
  768: 
  769:     :param exists: The file or directory needs to exist for the value to
  770:         be valid. If this is not set to ``True``, and the file does not
  771:         exist, then all further checks are silently skipped.
  772:     :param file_okay: Allow a file as a value.
  773:     :param dir_okay: Allow a directory as a value.
  774:     :param readable: if true, a readable check is performed.
  775:     :param writable: if true, a writable check is performed.
  776:     :param executable: if true, an executable check is performed.
  777:     :param resolve_path: Make the value absolute and resolve any
  778:         symlinks. A ``~`` is not expanded, as this is supposed to be
  779:         done by the shell only.
  780:     :param allow_dash: Allow a single dash as a value, which indicates
  781:         a standard stream (but does not open it). Use
  782:         :func:`~click.open_file` to handle opening this value.
  783:     :param path_type: Convert the incoming path value to this type. If
  784:         ``None``, keep Python's default, which is ``str``. Useful to
  785:         convert to :class:`pathlib.Path`.
  786: 
  787:     .. versionchanged:: 8.1
  788:         Added the ``executable`` parameter.
  789: 
  790:     .. versionchanged:: 8.0
  791:         Allow passing ``path_type=pathlib.Path``.
  792: 
  793:     .. versionchanged:: 6.0
  794:         Added the ``allow_dash`` parameter.
  795:     """
  796: 
  797:     envvar_list_splitter: t.ClassVar[str] = os.path.pathsep
  798: 
  799:     def __init__(
  800:         self,
  801:         exists: bool = False,
  802:         file_okay: bool = True,
  803:         dir_okay: bool = True,
  804:         writable: bool = False,
  805:         readable: bool = True,
  806:         resolve_path: bool = False,
  807:         allow_dash: bool = False,
  808:         path_type: t.Optional[t.Type[t.Any]] = None,
  809:         executable: bool = False,
  810:     ):
  811:         self.exists = exists
  812:         self.file_okay = file_okay
  813:         self.dir_okay = dir_okay
  814:         self.readable = readable
  815:         self.writable = writable
  816:         self.executable = executable
  817:         self.resolve_path = resolve_path
  818:         self.allow_dash = allow_dash
  819:         self.type = path_type
  820: 
  821:         if self.file_okay and not self.dir_okay:
  822:             self.name: str = _("file")
  823:         elif self.dir_okay and not self.file_okay:
  824:             self.name = _("directory")
  825:         else:
  826:             self.name = _("path")
  827: 
  828:     def to_info_dict(self) -> t.Dict[str, t.Any]:
  829:         info_dict = super().to_info_dict()
  830:         info_dict.update(
  831:             exists=self.exists,
  832:             file_okay=self.file_okay,
  833:             dir_okay=self.dir_okay,
  834:             writable=self.writable,
  835:             readable=self.readable,
  836:             allow_dash=self.allow_dash,
  837:         )
  838:         return info_dict
  839: 
  840:     def coerce_path_result(
  841:         self, value: "t.Union[str, os.PathLike[str]]"
  842:     ) -> "t.Union[str, bytes, os.PathLike[str]]":
  843:         if self.type is not None and not isinstance(value, self.type):
  844:             if self.type is str:
  845:                 return os.fsdecode(value)
  846:             elif self.type is bytes:
  847:                 return os.fsencode(value)
  848:             else:
  849:                 return t.cast("os.PathLike[str]", self.type(value))
  850: 
  851:         return value
  852: 
  853:     def convert(
  854:         self,
  855:         value: "t.Union[str, os.PathLike[str]]",
  856:         param: t.Optional["Parameter"],
  857:         ctx: t.Optional["Context"],
  858:     ) -> "t.Union[str, bytes, os.PathLike[str]]":
  859:         rv = value
  860: 
  861:         is_dash = self.file_okay and self.allow_dash and rv in (b"-", "-")
  862: 
  863:         if not is_dash:
  864:             if self.resolve_path:
  865:                 # os.path.realpath doesn't resolve symlinks on Windows
  866:                 # until Python 3.8. Use pathlib for now.
  867:                 import pathlib
  868: 
  869:                 rv = os.fsdecode(pathlib.Path(rv).resolve())
  870: 
  871:             try:
  872:                 st = os.stat(rv)
  873:             except OSError:
  874:                 if not self.exists:
  875:                     return self.coerce_path_result(rv)
  876:                 self.fail(
  877:                     _("{name} {filename!r} does not exist.").format(
  878:                         name=self.name.title(), filename=format_filename(value)
  879:                     ),
  880:                     param,
  881:                     ctx,
  882:                 )
  883: 
  884:             if not self.file_okay and stat.S_ISREG(st.st_mode):
  885:                 self.fail(
  886:                     _("{name} {filename!r} is a file.").format(
  887:                         name=self.name.title(), filename=format_filename(value)
  888:                     ),
  889:                     param,
  890:                     ctx,
  891:                 )
  892:             if not self.dir_okay and stat.S_ISDIR(st.st_mode):
  893:                 self.fail(
  894:                     _("{name} '{filename}' is a directory.").format(
  895:                         name=self.name.title(), filename=format_filename(value)
  896:                     ),
  897:                     param,
  898:                     ctx,
  899:                 )
  900: 
  901:             if self.readable and not os.access(rv, os.R_OK):
  902:                 self.fail(
  903:                     _("{name} {filename!r} is not readable.").format(
  904:                         name=self.name.title(), filename=format_filename(value)
  905:                     ),
  906:                     param,
  907:                     ctx,
  908:                 )
  909: 
  910:             if self.writable and not os.access(rv, os.W_OK):
  911:                 self.fail(
  912:                     _("{name} {filename!r} is not writable.").format(
  913:                         name=self.name.title(), filename=format_filename(value)
  914:                     ),
  915:                     param,
  916:                     ctx,
  917:                 )
  918: 
  919:             if self.executable and not os.access(value, os.X_OK):
  920:                 self.fail(
  921:                     _("{name} {filename!r} is not executable.").format(
  922:                         name=self.name.title(), filename=format_filename(value)
  923:                     ),
  924:                     param,
  925:                     ctx,
  926:                 )
  927: 
  928:         return self.coerce_path_result(rv)
  929: 
  930:     def shell_complete(
  931:         self, ctx: "Context", param: "Parameter", incomplete: str
  932:     ) -> t.List["CompletionItem"]:
  933:         """Return a special completion marker that tells the completion
  934:         system to use the shell to provide path completions for only
  935:         directories or any paths.
  936: 
  937:         :param ctx: Invocation context for this command.
  938:         :param param: The parameter that is requesting completion.
  939:         :param incomplete: Value being completed. May be empty.
  940: 
  941:         .. versionadded:: 8.0
  942:         """
  943:         from click.shell_completion import CompletionItem
  944: 
  945:         type = "dir" if self.dir_okay and not self.file_okay else "file"
  946:         return [CompletionItem(incomplete, type=type)]
  947: 
  948: 
  949: class Tuple(CompositeParamType):
  950:     """The default behavior of Click is to apply a type on a value directly.
  951:     This works well in most cases, except for when `nargs` is set to a fixed
  952:     count and different types should be used for different items.  In this
  953:     case the :class:`Tuple` type can be used.  This type can only be used
  954:     if `nargs` is set to a fixed number.
  955: 
  956:     For more information see :ref:`tuple-type`.
  957: 
  958:     This can be selected by using a Python tuple literal as a type.
  959: 
  960:     :param types: a list of types that should be used for the tuple items.
  961:     """
  962: 
  963:     def __init__(self, types: t.Sequence[t.Union[t.Type[t.Any], ParamType]]) -> None:
  964:         self.types: t.Sequence[ParamType] = [convert_type(ty) for ty in types]
  965: 
  966:     def to_info_dict(self) -> t.Dict[str, t.Any]:
  967:         info_dict = super().to_info_dict()
  968:         info_dict["types"] = [t.to_info_dict() for t in self.types]
  969:         return info_dict
  970: 
  971:     @property
  972:     def name(self) -> str:  # type: ignore
  973:         return f"<{' '.join(ty.name for ty in self.types)}>"
  974: 
  975:     @property
  976:     def arity(self) -> int:  # type: ignore
  977:         return len(self.types)
  978: 
  979:     def convert(
  980:         self, value: t.Any, param: t.Optional["Parameter"], ctx: t.Optional["Context"]
  981:     ) -> t.Any:
  982:         len_type = len(self.types)
  983:         len_value = len(value)
  984: 
  985:         if len_value != len_type:
  986:             self.fail(
  987:                 ngettext(
  988:                     "{len_type} values are required, but {len_value} was given.",
  989:                     "{len_type} values are required, but {len_value} were given.",
  990:                     len_value,
  991:                 ).format(len_type=len_type, len_value=len_value),
  992:                 param=param,
  993:                 ctx=ctx,
  994:             )
  995: 
  996:         return tuple(ty(x, param, ctx) for ty, x in zip(self.types, value))
  997: 
  998: 
  999: def convert_type(ty: t.Optional[t.Any], default: t.Optional[t.Any] = None) -> ParamType:
 1000:     """Find the most appropriate :class:`ParamType` for the given Python
 1001:     type. If the type isn't provided, it can be inferred from a default
 1002:     value.
 1003:     """
 1004:     guessed_type = False
 1005: 
 1006:     if ty is None and default is not None:
 1007:         if isinstance(default, (tuple, list)):
 1008:             # If the default is empty, ty will remain None and will
 1009:             # return STRING.
 1010:             if default:
 1011:                 item = default[0]
 1012: 
 1013:                 # A tuple of tuples needs to detect the inner types.
 1014:                 # Can't call convert recursively because that would
 1015:                 # incorrectly unwind the tuple to a single type.
 1016:                 if isinstance(item, (tuple, list)):
 1017:                     ty = tuple(map(type, item))
 1018:                 else:
 1019:                     ty = type(item)
 1020:         else:
 1021:             ty = type(default)
 1022: 
 1023:         guessed_type = True
 1024: 
 1025:     if isinstance(ty, tuple):
 1026:         return Tuple(ty)
 1027: 
 1028:     if isinstance(ty, ParamType):
 1029:         return ty
 1030: 
 1031:     if ty is str or ty is None:
 1032:         return STRING
 1033: 
 1034:     if ty is int:
 1035:         return INT
 1036: 
 1037:     if ty is float:
 1038:         return FLOAT
 1039: 
 1040:     if ty is bool:
 1041:         return BOOL
 1042: 
 1043:     if guessed_type:
 1044:         return STRING
 1045: 
 1046:     if __debug__:
 1047:         try:
 1048:             if issubclass(ty, ParamType):
 1049:                 raise AssertionError(
 1050:                     f"Attempted to use an uninstantiated parameter type ({ty})."
 1051:                 )
 1052:         except TypeError:
 1053:             # ty is an instance (correct), so issubclass fails.
 1054:             pass
 1055: 
 1056:     return FuncParamType(ty)
 1057: 
 1058: 
 1059: #: A dummy parameter type that just does nothing.  From a user's
 1060: #: perspective this appears to just be the same as `STRING` but
 1061: #: internally no string conversion takes place if the input was bytes.
 1062: #: This is usually useful when working with file paths as they can
 1063: #: appear in bytes and unicode.
 1064: #:
 1065: #: For path related uses the :class:`Path` type is a better choice but
 1066: #: there are situations where an unprocessed type is useful which is why
 1067: #: it is is provided.
 1068: #:
 1069: #: .. versionadded:: 4.0
 1070: UNPROCESSED = UnprocessedParamType()
 1071: 
 1072: #: A unicode string parameter type which is the implicit default.  This
 1073: #: can also be selected by using ``str`` as type.
 1074: STRING = StringParamType()
 1075: 
 1076: #: An integer parameter.  This can also be selected by using ``int`` as
 1077: #: type.
 1078: INT = IntParamType()
 1079: 
 1080: #: A floating point value parameter.  This can also be selected by using
 1081: #: ``float`` as type.
 1082: FLOAT = FloatParamType()
 1083: 
 1084: #: A boolean parameter.  This is the default for boolean flags.  This can
 1085: #: also be selected by using ``bool`` as a type.
 1086: BOOL = BoolParamType()
 1087: 
 1088: #: A UUID parameter.
 1089: UUID = UUIDParameterType()
