    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2017 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: """DNS stub resolver."""
   19: 
   20: import contextlib
   21: import random
   22: import socket
   23: import sys
   24: import threading
   25: import time
   26: import warnings
   27: from typing import Any, Dict, Iterator, List, Optional, Sequence, Tuple, Union
   28: from urllib.parse import urlparse
   29: 
   30: import dns._ddr
   31: import dns.edns
   32: import dns.exception
   33: import dns.flags
   34: import dns.inet
   35: import dns.ipv4
   36: import dns.ipv6
   37: import dns.message
   38: import dns.name
   39: import dns.nameserver
   40: import dns.query
   41: import dns.rcode
   42: import dns.rdataclass
   43: import dns.rdatatype
   44: import dns.rdtypes.svcbbase
   45: import dns.reversename
   46: import dns.tsig
   47: 
   48: if sys.platform == "win32":
   49:     import dns.win32util
   50: 
   51: 
   52: class NXDOMAIN(dns.exception.DNSException):
   53:     """The DNS query name does not exist."""
   54: 
   55:     supp_kwargs = {"qnames", "responses"}
   56:     fmt = None  # we have our own __str__ implementation
   57: 
   58:     # pylint: disable=arguments-differ
   59: 
   60:     # We do this as otherwise mypy complains about unexpected keyword argument
   61:     # idna_exception
   62:     def __init__(self, *args, **kwargs):
   63:         super().__init__(*args, **kwargs)
   64: 
   65:     def _check_kwargs(self, qnames, responses=None):
   66:         if not isinstance(qnames, (list, tuple, set)):
   67:             raise AttributeError("qnames must be a list, tuple or set")
   68:         if len(qnames) == 0:
   69:             raise AttributeError("qnames must contain at least one element")
   70:         if responses is None:
   71:             responses = {}
   72:         elif not isinstance(responses, dict):
   73:             raise AttributeError("responses must be a dict(qname=response)")
   74:         kwargs = dict(qnames=qnames, responses=responses)
   75:         return kwargs
   76: 
   77:     def __str__(self) -> str:
   78:         if "qnames" not in self.kwargs:
   79:             return super().__str__()
   80:         qnames = self.kwargs["qnames"]
   81:         if len(qnames) > 1:
   82:             msg = "None of DNS query names exist"
   83:         else:
   84:             msg = "The DNS query name does not exist"
   85:         qnames = ", ".join(map(str, qnames))
   86:         return "{}: {}".format(msg, qnames)
   87: 
   88:     @property
   89:     def canonical_name(self):
   90:         """Return the unresolved canonical name."""
   91:         if "qnames" not in self.kwargs:
   92:             raise TypeError("parametrized exception required")
   93:         for qname in self.kwargs["qnames"]:
   94:             response = self.kwargs["responses"][qname]
   95:             try:
   96:                 cname = response.canonical_name()
   97:                 if cname != qname:
   98:                     return cname
   99:             except Exception:
  100:                 # We can just eat this exception as it means there was
  101:                 # something wrong with the response.
  102:                 pass
  103:         return self.kwargs["qnames"][0]
  104: 
  105:     def __add__(self, e_nx):
  106:         """Augment by results from another NXDOMAIN exception."""
  107:         qnames0 = list(self.kwargs.get("qnames", []))
  108:         responses0 = dict(self.kwargs.get("responses", {}))
  109:         responses1 = e_nx.kwargs.get("responses", {})
  110:         for qname1 in e_nx.kwargs.get("qnames", []):
  111:             if qname1 not in qnames0:
  112:                 qnames0.append(qname1)
  113:             if qname1 in responses1:
  114:                 responses0[qname1] = responses1[qname1]
  115:         return NXDOMAIN(qnames=qnames0, responses=responses0)
  116: 
  117:     def qnames(self):
  118:         """All of the names that were tried.
  119: 
  120:         Returns a list of ``dns.name.Name``.
  121:         """
  122:         return self.kwargs["qnames"]
  123: 
  124:     def responses(self):
  125:         """A map from queried names to their NXDOMAIN responses.
  126: 
  127:         Returns a dict mapping a ``dns.name.Name`` to a
  128:         ``dns.message.Message``.
  129:         """
  130:         return self.kwargs["responses"]
  131: 
  132:     def response(self, qname):
  133:         """The response for query *qname*.
  134: 
  135:         Returns a ``dns.message.Message``.
  136:         """
  137:         return self.kwargs["responses"][qname]
  138: 
  139: 
  140: class YXDOMAIN(dns.exception.DNSException):
  141:     """The DNS query name is too long after DNAME substitution."""
  142: 
  143: 
  144: ErrorTuple = Tuple[
  145:     Optional[str],
  146:     bool,
  147:     int,
  148:     Union[Exception, str],
  149:     Optional[dns.message.Message],
  150: ]
  151: 
  152: 
  153: def _errors_to_text(errors: List[ErrorTuple]) -> List[str]:
  154:     """Turn a resolution errors trace into a list of text."""
  155:     texts = []
  156:     for err in errors:
  157:         texts.append("Server {} answered {}".format(err[0], err[3]))
  158:     return texts
  159: 
  160: 
  161: class LifetimeTimeout(dns.exception.Timeout):
  162:     """The resolution lifetime expired."""
  163: 
  164:     msg = "The resolution lifetime expired."
  165:     fmt = "%s after {timeout:.3f} seconds: {errors}" % msg[:-1]
  166:     supp_kwargs = {"timeout", "errors"}
  167: 
  168:     # We do this as otherwise mypy complains about unexpected keyword argument
  169:     # idna_exception
  170:     def __init__(self, *args, **kwargs):
  171:         super().__init__(*args, **kwargs)
  172: 
  173:     def _fmt_kwargs(self, **kwargs):
  174:         srv_msgs = _errors_to_text(kwargs["errors"])
  175:         return super()._fmt_kwargs(
  176:             timeout=kwargs["timeout"], errors="; ".join(srv_msgs)
  177:         )
  178: 
  179: 
  180: # We added more detail to resolution timeouts, but they are still
  181: # subclasses of dns.exception.Timeout for backwards compatibility.  We also
  182: # keep dns.resolver.Timeout defined for backwards compatibility.
  183: Timeout = LifetimeTimeout
  184: 
  185: 
  186: class NoAnswer(dns.exception.DNSException):
  187:     """The DNS response does not contain an answer to the question."""
  188: 
  189:     fmt = "The DNS response does not contain an answer to the question: {query}"
  190:     supp_kwargs = {"response"}
  191: 
  192:     # We do this as otherwise mypy complains about unexpected keyword argument
  193:     # idna_exception
  194:     def __init__(self, *args, **kwargs):
  195:         super().__init__(*args, **kwargs)
  196: 
  197:     def _fmt_kwargs(self, **kwargs):
  198:         return super()._fmt_kwargs(query=kwargs["response"].question)
  199: 
  200:     def response(self):
  201:         return self.kwargs["response"]
  202: 
  203: 
  204: class NoNameservers(dns.exception.DNSException):
  205:     """All nameservers failed to answer the query.
  206: 
  207:     errors: list of servers and respective errors
  208:     The type of errors is
  209:     [(server IP address, any object convertible to string)].
  210:     Non-empty errors list will add explanatory message ()
  211:     """
  212: 
  213:     msg = "All nameservers failed to answer the query."
  214:     fmt = "%s {query}: {errors}" % msg[:-1]
  215:     supp_kwargs = {"request", "errors"}
  216: 
  217:     # We do this as otherwise mypy complains about unexpected keyword argument
  218:     # idna_exception
  219:     def __init__(self, *args, **kwargs):
  220:         super().__init__(*args, **kwargs)
  221: 
  222:     def _fmt_kwargs(self, **kwargs):
  223:         srv_msgs = _errors_to_text(kwargs["errors"])
  224:         return super()._fmt_kwargs(
  225:             query=kwargs["request"].question, errors="; ".join(srv_msgs)
  226:         )
  227: 
  228: 
  229: class NotAbsolute(dns.exception.DNSException):
  230:     """An absolute domain name is required but a relative name was provided."""
  231: 
  232: 
  233: class NoRootSOA(dns.exception.DNSException):
  234:     """There is no SOA RR at the DNS root name. This should never happen!"""
  235: 
  236: 
  237: class NoMetaqueries(dns.exception.DNSException):
  238:     """DNS metaqueries are not allowed."""
  239: 
  240: 
  241: class NoResolverConfiguration(dns.exception.DNSException):
  242:     """Resolver configuration could not be read or specified no nameservers."""
  243: 
  244: 
  245: class Answer:
  246:     """DNS stub resolver answer.
  247: 
  248:     Instances of this class bundle up the result of a successful DNS
  249:     resolution.
  250: 
  251:     For convenience, the answer object implements much of the sequence
  252:     protocol, forwarding to its ``rrset`` attribute.  E.g.
  253:     ``for a in answer`` is equivalent to ``for a in answer.rrset``.
  254:     ``answer[i]`` is equivalent to ``answer.rrset[i]``, and
  255:     ``answer[i:j]`` is equivalent to ``answer.rrset[i:j]``.
  256: 
  257:     Note that CNAMEs or DNAMEs in the response may mean that answer
  258:     RRset's name might not be the query name.
  259:     """
  260: 
  261:     def __init__(
  262:         self,
  263:         qname: dns.name.Name,
  264:         rdtype: dns.rdatatype.RdataType,
  265:         rdclass: dns.rdataclass.RdataClass,
  266:         response: dns.message.QueryMessage,
  267:         nameserver: Optional[str] = None,
  268:         port: Optional[int] = None,
  269:     ) -> None:
  270:         self.qname = qname
  271:         self.rdtype = rdtype
  272:         self.rdclass = rdclass
  273:         self.response = response
  274:         self.nameserver = nameserver
  275:         self.port = port
  276:         self.chaining_result = response.resolve_chaining()
  277:         # Copy some attributes out of chaining_result for backwards
  278:         # compatibility and convenience.
  279:         self.canonical_name = self.chaining_result.canonical_name
  280:         self.rrset = self.chaining_result.answer
  281:         self.expiration = time.time() + self.chaining_result.minimum_ttl
  282: 
  283:     def __getattr__(self, attr):  # pragma: no cover
  284:         if attr == "name":
  285:             return self.rrset.name
  286:         elif attr == "ttl":
  287:             return self.rrset.ttl
  288:         elif attr == "covers":
  289:             return self.rrset.covers
  290:         elif attr == "rdclass":
  291:             return self.rrset.rdclass
  292:         elif attr == "rdtype":
  293:             return self.rrset.rdtype
  294:         else:
  295:             raise AttributeError(attr)
  296: 
  297:     def __len__(self) -> int:
  298:         return self.rrset and len(self.rrset) or 0
  299: 
  300:     def __iter__(self):
  301:         return self.rrset and iter(self.rrset) or iter(tuple())
  302: 
  303:     def __getitem__(self, i):
  304:         if self.rrset is None:
  305:             raise IndexError
  306:         return self.rrset[i]
  307: 
  308:     def __delitem__(self, i):
  309:         if self.rrset is None:
  310:             raise IndexError
  311:         del self.rrset[i]
  312: 
  313: 
  314: class Answers(dict):
  315:     """A dict of DNS stub resolver answers, indexed by type."""
  316: 
  317: 
  318: class HostAnswers(Answers):
  319:     """A dict of DNS stub resolver answers to a host name lookup, indexed by
  320:     type.
  321:     """
  322: 
  323:     @classmethod
  324:     def make(
  325:         cls,
  326:         v6: Optional[Answer] = None,
  327:         v4: Optional[Answer] = None,
  328:         add_empty: bool = True,
  329:     ) -> "HostAnswers":
  330:         answers = HostAnswers()
  331:         if v6 is not None and (add_empty or v6.rrset):
  332:             answers[dns.rdatatype.AAAA] = v6
  333:         if v4 is not None and (add_empty or v4.rrset):
  334:             answers[dns.rdatatype.A] = v4
  335:         return answers
  336: 
  337:     # Returns pairs of (address, family) from this result, potentiallys
  338:     # filtering by address family.
  339:     def addresses_and_families(
  340:         self, family: int = socket.AF_UNSPEC
  341:     ) -> Iterator[Tuple[str, int]]:
  342:         if family == socket.AF_UNSPEC:
  343:             yield from self.addresses_and_families(socket.AF_INET6)
  344:             yield from self.addresses_and_families(socket.AF_INET)
  345:             return
  346:         elif family == socket.AF_INET6:
  347:             answer = self.get(dns.rdatatype.AAAA)
  348:         elif family == socket.AF_INET:
  349:             answer = self.get(dns.rdatatype.A)
  350:         else:
  351:             raise NotImplementedError(f"unknown address family {family}")
  352:         if answer:
  353:             for rdata in answer:
  354:                 yield (rdata.address, family)
  355: 
  356:     # Returns addresses from this result, potentially filtering by
  357:     # address family.
  358:     def addresses(self, family: int = socket.AF_UNSPEC) -> Iterator[str]:
  359:         return (pair[0] for pair in self.addresses_and_families(family))
  360: 
  361:     # Returns the canonical name from this result.
  362:     def canonical_name(self) -> dns.name.Name:
  363:         answer = self.get(dns.rdatatype.AAAA, self.get(dns.rdatatype.A))
  364:         return answer.canonical_name
  365: 
  366: 
  367: class CacheStatistics:
  368:     """Cache Statistics"""
  369: 
  370:     def __init__(self, hits: int = 0, misses: int = 0) -> None:
  371:         self.hits = hits
  372:         self.misses = misses
  373: 
  374:     def reset(self) -> None:
  375:         self.hits = 0
  376:         self.misses = 0
  377: 
  378:     def clone(self) -> "CacheStatistics":
  379:         return CacheStatistics(self.hits, self.misses)
  380: 
  381: 
  382: class CacheBase:
  383:     def __init__(self) -> None:
  384:         self.lock = threading.Lock()
  385:         self.statistics = CacheStatistics()
  386: 
  387:     def reset_statistics(self) -> None:
  388:         """Reset all statistics to zero."""
  389:         with self.lock:
  390:             self.statistics.reset()
  391: 
  392:     def hits(self) -> int:
  393:         """How many hits has the cache had?"""
  394:         with self.lock:
  395:             return self.statistics.hits
  396: 
  397:     def misses(self) -> int:
  398:         """How many misses has the cache had?"""
  399:         with self.lock:
  400:             return self.statistics.misses
  401: 
  402:     def get_statistics_snapshot(self) -> CacheStatistics:
  403:         """Return a consistent snapshot of all the statistics.
  404: 
  405:         If running with multiple threads, it's better to take a
  406:         snapshot than to call statistics methods such as hits() and
  407:         misses() individually.
  408:         """
  409:         with self.lock:
  410:             return self.statistics.clone()
  411: 
  412: 
  413: CacheKey = Tuple[dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass]
  414: 
  415: 
  416: class Cache(CacheBase):
  417:     """Simple thread-safe DNS answer cache."""
  418: 
  419:     def __init__(self, cleaning_interval: float = 300.0) -> None:
  420:         """*cleaning_interval*, a ``float`` is the number of seconds between
  421:         periodic cleanings.
  422:         """
  423: 
  424:         super().__init__()
  425:         self.data: Dict[CacheKey, Answer] = {}
  426:         self.cleaning_interval = cleaning_interval
  427:         self.next_cleaning: float = time.time() + self.cleaning_interval
  428: 
  429:     def _maybe_clean(self) -> None:
  430:         """Clean the cache if it's time to do so."""
  431: 
  432:         now = time.time()
  433:         if self.next_cleaning <= now:
  434:             keys_to_delete = []
  435:             for k, v in self.data.items():
  436:                 if v.expiration <= now:
  437:                     keys_to_delete.append(k)
  438:             for k in keys_to_delete:
  439:                 del self.data[k]
  440:             now = time.time()
  441:             self.next_cleaning = now + self.cleaning_interval
  442: 
  443:     def get(self, key: CacheKey) -> Optional[Answer]:
  444:         """Get the answer associated with *key*.
  445: 
  446:         Returns None if no answer is cached for the key.
  447: 
  448:         *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
  449:         tuple whose values are the query name, rdtype, and rdclass respectively.
  450: 
  451:         Returns a ``dns.resolver.Answer`` or ``None``.
  452:         """
  453: 
  454:         with self.lock:
  455:             self._maybe_clean()
  456:             v = self.data.get(key)
  457:             if v is None or v.expiration <= time.time():
  458:                 self.statistics.misses += 1
  459:                 return None
  460:             self.statistics.hits += 1
  461:             return v
  462: 
  463:     def put(self, key: CacheKey, value: Answer) -> None:
  464:         """Associate key and value in the cache.
  465: 
  466:         *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
  467:         tuple whose values are the query name, rdtype, and rdclass respectively.
  468: 
  469:         *value*, a ``dns.resolver.Answer``, the answer.
  470:         """
  471: 
  472:         with self.lock:
  473:             self._maybe_clean()
  474:             self.data[key] = value
  475: 
  476:     def flush(self, key: Optional[CacheKey] = None) -> None:
  477:         """Flush the cache.
  478: 
  479:         If *key* is not ``None``, only that item is flushed.  Otherwise the entire cache
  480:         is flushed.
  481: 
  482:         *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
  483:         tuple whose values are the query name, rdtype, and rdclass respectively.
  484:         """
  485: 
  486:         with self.lock:
  487:             if key is not None:
  488:                 if key in self.data:
  489:                     del self.data[key]
  490:             else:
  491:                 self.data = {}
  492:                 self.next_cleaning = time.time() + self.cleaning_interval
  493: 
  494: 
  495: class LRUCacheNode:
  496:     """LRUCache node."""
  497: 
  498:     def __init__(self, key, value):
  499:         self.key = key
  500:         self.value = value
  501:         self.hits = 0
  502:         self.prev = self
  503:         self.next = self
  504: 
  505:     def link_after(self, node: "LRUCacheNode") -> None:
  506:         self.prev = node
  507:         self.next = node.next
  508:         node.next.prev = self
  509:         node.next = self
  510: 
  511:     def unlink(self) -> None:
  512:         self.next.prev = self.prev
  513:         self.prev.next = self.next
  514: 
  515: 
  516: class LRUCache(CacheBase):
  517:     """Thread-safe, bounded, least-recently-used DNS answer cache.
  518: 
  519:     This cache is better than the simple cache (above) if you're
  520:     running a web crawler or other process that does a lot of
  521:     resolutions.  The LRUCache has a maximum number of nodes, and when
  522:     it is full, the least-recently used node is removed to make space
  523:     for a new one.
  524:     """
  525: 
  526:     def __init__(self, max_size: int = 100000) -> None:
  527:         """*max_size*, an ``int``, is the maximum number of nodes to cache;
  528:         it must be greater than 0.
  529:         """
  530: 
  531:         super().__init__()
  532:         self.data: Dict[CacheKey, LRUCacheNode] = {}
  533:         self.set_max_size(max_size)
  534:         self.sentinel: LRUCacheNode = LRUCacheNode(None, None)
  535:         self.sentinel.prev = self.sentinel
  536:         self.sentinel.next = self.sentinel
  537: 
  538:     def set_max_size(self, max_size: int) -> None:
  539:         if max_size < 1:
  540:             max_size = 1
  541:         self.max_size = max_size
  542: 
  543:     def get(self, key: CacheKey) -> Optional[Answer]:
  544:         """Get the answer associated with *key*.
  545: 
  546:         Returns None if no answer is cached for the key.
  547: 
  548:         *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
  549:         tuple whose values are the query name, rdtype, and rdclass respectively.
  550: 
  551:         Returns a ``dns.resolver.Answer`` or ``None``.
  552:         """
  553: 
  554:         with self.lock:
  555:             node = self.data.get(key)
  556:             if node is None:
  557:                 self.statistics.misses += 1
  558:                 return None
  559:             # Unlink because we're either going to move the node to the front
  560:             # of the LRU list or we're going to free it.
  561:             node.unlink()
  562:             if node.value.expiration <= time.time():
  563:                 del self.data[node.key]
  564:                 self.statistics.misses += 1
  565:                 return None
  566:             node.link_after(self.sentinel)
  567:             self.statistics.hits += 1
  568:             node.hits += 1
  569:             return node.value
  570: 
  571:     def get_hits_for_key(self, key: CacheKey) -> int:
  572:         """Return the number of cache hits associated with the specified key."""
  573:         with self.lock:
  574:             node = self.data.get(key)
  575:             if node is None or node.value.expiration <= time.time():
  576:                 return 0
  577:             else:
  578:                 return node.hits
  579: 
  580:     def put(self, key: CacheKey, value: Answer) -> None:
  581:         """Associate key and value in the cache.
  582: 
  583:         *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
  584:         tuple whose values are the query name, rdtype, and rdclass respectively.
  585: 
  586:         *value*, a ``dns.resolver.Answer``, the answer.
  587:         """
  588: 
  589:         with self.lock:
  590:             node = self.data.get(key)
  591:             if node is not None:
  592:                 node.unlink()
  593:                 del self.data[node.key]
  594:             while len(self.data) >= self.max_size:
  595:                 gnode = self.sentinel.prev
  596:                 gnode.unlink()
  597:                 del self.data[gnode.key]
  598:             node = LRUCacheNode(key, value)
  599:             node.link_after(self.sentinel)
  600:             self.data[key] = node
  601: 
  602:     def flush(self, key: Optional[CacheKey] = None) -> None:
  603:         """Flush the cache.
  604: 
  605:         If *key* is not ``None``, only that item is flushed.  Otherwise the entire cache
  606:         is flushed.
  607: 
  608:         *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
  609:         tuple whose values are the query name, rdtype, and rdclass respectively.
  610:         """
  611: 
  612:         with self.lock:
  613:             if key is not None:
  614:                 node = self.data.get(key)
  615:                 if node is not None:
  616:                     node.unlink()
  617:                     del self.data[node.key]
  618:             else:
  619:                 gnode = self.sentinel.next
  620:                 while gnode != self.sentinel:
  621:                     next = gnode.next
  622:                     gnode.unlink()
  623:                     gnode = next
  624:                 self.data = {}
  625: 
  626: 
  627: class _Resolution:
  628:     """Helper class for dns.resolver.Resolver.resolve().
  629: 
  630:     All of the "business logic" of resolution is encapsulated in this
  631:     class, allowing us to have multiple resolve() implementations
  632:     using different I/O schemes without copying all of the
  633:     complicated logic.
  634: 
  635:     This class is a "friend" to dns.resolver.Resolver and manipulates
  636:     resolver data structures directly.
  637:     """
  638: 
  639:     def __init__(
  640:         self,
  641:         resolver: "BaseResolver",
  642:         qname: Union[dns.name.Name, str],
  643:         rdtype: Union[dns.rdatatype.RdataType, str],
  644:         rdclass: Union[dns.rdataclass.RdataClass, str],
  645:         tcp: bool,
  646:         raise_on_no_answer: bool,
  647:         search: Optional[bool],
  648:     ) -> None:
  649:         if isinstance(qname, str):
  650:             qname = dns.name.from_text(qname, None)
  651:         rdtype = dns.rdatatype.RdataType.make(rdtype)
  652:         if dns.rdatatype.is_metatype(rdtype):
  653:             raise NoMetaqueries
  654:         rdclass = dns.rdataclass.RdataClass.make(rdclass)
  655:         if dns.rdataclass.is_metaclass(rdclass):
  656:             raise NoMetaqueries
  657:         self.resolver = resolver
  658:         self.qnames_to_try = resolver._get_qnames_to_try(qname, search)
  659:         self.qnames = self.qnames_to_try[:]
  660:         self.rdtype = rdtype
  661:         self.rdclass = rdclass
  662:         self.tcp = tcp
  663:         self.raise_on_no_answer = raise_on_no_answer
  664:         self.nxdomain_responses: Dict[dns.name.Name, dns.message.QueryMessage] = {}
  665:         # Initialize other things to help analysis tools
  666:         self.qname = dns.name.empty
  667:         self.nameservers: List[dns.nameserver.Nameserver] = []
  668:         self.current_nameservers: List[dns.nameserver.Nameserver] = []
  669:         self.errors: List[ErrorTuple] = []
  670:         self.nameserver: Optional[dns.nameserver.Nameserver] = None
  671:         self.tcp_attempt = False
  672:         self.retry_with_tcp = False
  673:         self.request: Optional[dns.message.QueryMessage] = None
  674:         self.backoff = 0.0
  675: 
  676:     def next_request(
  677:         self,
  678:     ) -> Tuple[Optional[dns.message.QueryMessage], Optional[Answer]]:
  679:         """Get the next request to send, and check the cache.
  680: 
  681:         Returns a (request, answer) tuple.  At most one of request or
  682:         answer will not be None.
  683:         """
  684: 
  685:         # We return a tuple instead of Union[Message,Answer] as it lets
  686:         # the caller avoid isinstance().
  687: 
  688:         while len(self.qnames) > 0:
  689:             self.qname = self.qnames.pop(0)
  690: 
  691:             # Do we know the answer?
  692:             if self.resolver.cache:
  693:                 answer = self.resolver.cache.get(
  694:                     (self.qname, self.rdtype, self.rdclass)
  695:                 )
  696:                 if answer is not None:
  697:                     if answer.rrset is None and self.raise_on_no_answer:
  698:                         raise NoAnswer(response=answer.response)
  699:                     else:
  700:                         return (None, answer)
  701:                 answer = self.resolver.cache.get(
  702:                     (self.qname, dns.rdatatype.ANY, self.rdclass)
  703:                 )
  704:                 if answer is not None and answer.response.rcode() == dns.rcode.NXDOMAIN:
  705:                     # cached NXDOMAIN; record it and continue to next
  706:                     # name.
  707:                     self.nxdomain_responses[self.qname] = answer.response
  708:                     continue
  709: 
  710:             # Build the request
  711:             request = dns.message.make_query(self.qname, self.rdtype, self.rdclass)
  712:             if self.resolver.keyname is not None:
  713:                 request.use_tsig(
  714:                     self.resolver.keyring,
  715:                     self.resolver.keyname,
  716:                     algorithm=self.resolver.keyalgorithm,
  717:                 )
  718:             request.use_edns(
  719:                 self.resolver.edns,
  720:                 self.resolver.ednsflags,
  721:                 self.resolver.payload,
  722:                 options=self.resolver.ednsoptions,
  723:             )
  724:             if self.resolver.flags is not None:
  725:                 request.flags = self.resolver.flags
  726: 
  727:             self.nameservers = self.resolver._enrich_nameservers(
  728:                 self.resolver._nameservers,
  729:                 self.resolver.nameserver_ports,
  730:                 self.resolver.port,
  731:             )
  732:             if self.resolver.rotate:
  733:                 random.shuffle(self.nameservers)
  734:             self.current_nameservers = self.nameservers[:]
  735:             self.errors = []
  736:             self.nameserver = None
  737:             self.tcp_attempt = False
  738:             self.retry_with_tcp = False
  739:             self.request = request
  740:             self.backoff = 0.10
  741: 
  742:             return (request, None)
  743: 
  744:         #
  745:         # We've tried everything and only gotten NXDOMAINs.  (We know
  746:         # it's only NXDOMAINs as anything else would have returned
  747:         # before now.)
  748:         #
  749:         raise NXDOMAIN(qnames=self.qnames_to_try, responses=self.nxdomain_responses)
  750: 
  751:     def next_nameserver(self) -> Tuple[dns.nameserver.Nameserver, bool, float]:
  752:         if self.retry_with_tcp:
  753:             assert self.nameserver is not None
  754:             assert not self.nameserver.is_always_max_size()
  755:             self.tcp_attempt = True
  756:             self.retry_with_tcp = False
  757:             return (self.nameserver, True, 0)
  758: 
  759:         backoff = 0.0
  760:         if not self.current_nameservers:
  761:             if len(self.nameservers) == 0:
  762:                 # Out of things to try!
  763:                 raise NoNameservers(request=self.request, errors=self.errors)
  764:             self.current_nameservers = self.nameservers[:]
  765:             backoff = self.backoff
  766:             self.backoff = min(self.backoff * 2, 2)
  767: 
  768:         self.nameserver = self.current_nameservers.pop(0)
  769:         self.tcp_attempt = self.tcp or self.nameserver.is_always_max_size()
  770:         return (self.nameserver, self.tcp_attempt, backoff)
  771: 
  772:     def query_result(
  773:         self, response: Optional[dns.message.Message], ex: Optional[Exception]
  774:     ) -> Tuple[Optional[Answer], bool]:
  775:         #
  776:         # returns an (answer: Answer, end_loop: bool) tuple.
  777:         #
  778:         assert self.nameserver is not None
  779:         if ex:
  780:             # Exception during I/O or from_wire()
  781:             assert response is None
  782:             self.errors.append(
  783:                 (
  784:                     str(self.nameserver),
  785:                     self.tcp_attempt,
  786:                     self.nameserver.answer_port(),
  787:                     ex,
  788:                     response,
  789:                 )
  790:             )
  791:             if (
  792:                 isinstance(ex, dns.exception.FormError)
  793:                 or isinstance(ex, EOFError)
  794:                 or isinstance(ex, OSError)
  795:                 or isinstance(ex, NotImplementedError)
  796:             ):
  797:                 # This nameserver is no good, take it out of the mix.
  798:                 self.nameservers.remove(self.nameserver)
  799:             elif isinstance(ex, dns.message.Truncated):
  800:                 if self.tcp_attempt:
  801:                     # Truncation with TCP is no good!
  802:                     self.nameservers.remove(self.nameserver)
  803:                 else:
  804:                     self.retry_with_tcp = True
  805:             return (None, False)
  806:         # We got an answer!
  807:         assert response is not None
  808:         assert isinstance(response, dns.message.QueryMessage)
  809:         rcode = response.rcode()
  810:         if rcode == dns.rcode.NOERROR:
  811:             try:
  812:                 answer = Answer(
  813:                     self.qname,
  814:                     self.rdtype,
  815:                     self.rdclass,
  816:                     response,
  817:                     self.nameserver.answer_nameserver(),
  818:                     self.nameserver.answer_port(),
  819:                 )
  820:             except Exception as e:
  821:                 self.errors.append(
  822:                     (
  823:                         str(self.nameserver),
  824:                         self.tcp_attempt,
  825:                         self.nameserver.answer_port(),
  826:                         e,
  827:                         response,
  828:                     )
  829:                 )
  830:                 # The nameserver is no good, take it out of the mix.
  831:                 self.nameservers.remove(self.nameserver)
  832:                 return (None, False)
  833:             if self.resolver.cache:
  834:                 self.resolver.cache.put((self.qname, self.rdtype, self.rdclass), answer)
  835:             if answer.rrset is None and self.raise_on_no_answer:
  836:                 raise NoAnswer(response=answer.response)
  837:             return (answer, True)
  838:         elif rcode == dns.rcode.NXDOMAIN:
  839:             # Further validate the response by making an Answer, even
  840:             # if we aren't going to cache it.
  841:             try:
  842:                 answer = Answer(
  843:                     self.qname, dns.rdatatype.ANY, dns.rdataclass.IN, response
  844:                 )
  845:             except Exception as e:
  846:                 self.errors.append(
  847:                     (
  848:                         str(self.nameserver),
  849:                         self.tcp_attempt,
  850:                         self.nameserver.answer_port(),
  851:                         e,
  852:                         response,
  853:                     )
  854:                 )
  855:                 # The nameserver is no good, take it out of the mix.
  856:                 self.nameservers.remove(self.nameserver)
  857:                 return (None, False)
  858:             self.nxdomain_responses[self.qname] = response
  859:             if self.resolver.cache:
  860:                 self.resolver.cache.put(
  861:                     (self.qname, dns.rdatatype.ANY, self.rdclass), answer
  862:                 )
  863:             # Make next_nameserver() return None, so caller breaks its
  864:             # inner loop and calls next_request().
  865:             return (None, True)
  866:         elif rcode == dns.rcode.YXDOMAIN:
  867:             yex = YXDOMAIN()
  868:             self.errors.append(
  869:                 (
  870:                     str(self.nameserver),
  871:                     self.tcp_attempt,
  872:                     self.nameserver.answer_port(),
  873:                     yex,
  874:                     response,
  875:                 )
  876:             )
  877:             raise yex
  878:         else:
  879:             #
  880:             # We got a response, but we're not happy with the
  881:             # rcode in it.
  882:             #
  883:             if rcode != dns.rcode.SERVFAIL or not self.resolver.retry_servfail:
  884:                 self.nameservers.remove(self.nameserver)
  885:             self.errors.append(
  886:                 (
  887:                     str(self.nameserver),
  888:                     self.tcp_attempt,
  889:                     self.nameserver.answer_port(),
  890:                     dns.rcode.to_text(rcode),
  891:                     response,
  892:                 )
  893:             )
  894:             return (None, False)
  895: 
  896: 
  897: class BaseResolver:
  898:     """DNS stub resolver."""
  899: 
  900:     # We initialize in reset()
  901:     #
  902:     # pylint: disable=attribute-defined-outside-init
  903: 
  904:     domain: dns.name.Name
  905:     nameserver_ports: Dict[str, int]
  906:     port: int
  907:     search: List[dns.name.Name]
  908:     use_search_by_default: bool
  909:     timeout: float
  910:     lifetime: float
  911:     keyring: Optional[Any]
  912:     keyname: Optional[Union[dns.name.Name, str]]
  913:     keyalgorithm: Union[dns.name.Name, str]
  914:     edns: int
  915:     ednsflags: int
  916:     ednsoptions: Optional[List[dns.edns.Option]]
  917:     payload: int
  918:     cache: Any
  919:     flags: Optional[int]
  920:     retry_servfail: bool
  921:     rotate: bool
  922:     ndots: Optional[int]
  923:     _nameservers: Sequence[Union[str, dns.nameserver.Nameserver]]
  924: 
  925:     def __init__(
  926:         self, filename: str = "/etc/resolv.conf", configure: bool = True
  927:     ) -> None:
  928:         """*filename*, a ``str`` or file object, specifying a file
  929:         in standard /etc/resolv.conf format.  This parameter is meaningful
  930:         only when *configure* is true and the platform is POSIX.
  931: 
  932:         *configure*, a ``bool``.  If True (the default), the resolver
  933:         instance is configured in the normal fashion for the operating
  934:         system the resolver is running on.  (I.e. by reading a
  935:         /etc/resolv.conf file on POSIX systems and from the registry
  936:         on Windows systems.)
  937:         """
  938: 
  939:         self.reset()
  940:         if configure:
  941:             if sys.platform == "win32":
  942:                 self.read_registry()
  943:             elif filename:
  944:                 self.read_resolv_conf(filename)
  945: 
  946:     def reset(self) -> None:
  947:         """Reset all resolver configuration to the defaults."""
  948: 
  949:         self.domain = dns.name.Name(dns.name.from_text(socket.gethostname())[1:])
  950:         if len(self.domain) == 0:
  951:             self.domain = dns.name.root
  952:         self._nameservers = []
  953:         self.nameserver_ports = {}
  954:         self.port = 53
  955:         self.search = []
  956:         self.use_search_by_default = False
  957:         self.timeout = 2.0
  958:         self.lifetime = 5.0
  959:         self.keyring = None
  960:         self.keyname = None
  961:         self.keyalgorithm = dns.tsig.default_algorithm
  962:         self.edns = -1
  963:         self.ednsflags = 0
  964:         self.ednsoptions = None
  965:         self.payload = 0
  966:         self.cache = None
  967:         self.flags = None
  968:         self.retry_servfail = False
  969:         self.rotate = False
  970:         self.ndots = None
  971: 
  972:     def read_resolv_conf(self, f: Any) -> None:
  973:         """Process *f* as a file in the /etc/resolv.conf format.  If f is
  974:         a ``str``, it is used as the name of the file to open; otherwise it
  975:         is treated as the file itself.
  976: 
  977:         Interprets the following items:
  978: 
  979:         - nameserver - name server IP address
  980: 
  981:         - domain - local domain name
  982: 
  983:         - search - search list for host-name lookup
  984: 
  985:         - options - supported options are rotate, timeout, edns0, and ndots
  986: 
  987:         """
  988: 
  989:         nameservers = []
  990:         if isinstance(f, str):
  991:             try:
  992:                 cm: contextlib.AbstractContextManager = open(f)
  993:             except OSError:
  994:                 # /etc/resolv.conf doesn't exist, can't be read, etc.
  995:                 raise NoResolverConfiguration(f"cannot open {f}")
  996:         else:
  997:             cm = contextlib.nullcontext(f)
  998:         with cm as f:
  999:             for l in f:
 1000:                 if len(l) == 0 or l[0] == "#" or l[0] == ";":
 1001:                     continue
 1002:                 tokens = l.split()
 1003: 
 1004:                 # Any line containing less than 2 tokens is malformed
 1005:                 if len(tokens) < 2:
 1006:                     continue
 1007: 
 1008:                 if tokens[0] == "nameserver":
 1009:                     nameservers.append(tokens[1])
 1010:                 elif tokens[0] == "domain":
 1011:                     self.domain = dns.name.from_text(tokens[1])
 1012:                     # domain and search are exclusive
 1013:                     self.search = []
 1014:                 elif tokens[0] == "search":
 1015:                     # the last search wins
 1016:                     self.search = []
 1017:                     for suffix in tokens[1:]:
 1018:                         self.search.append(dns.name.from_text(suffix))
 1019:                     # We don't set domain as it is not used if
 1020:                     # len(self.search) > 0
 1021:                 elif tokens[0] == "options":
 1022:                     for opt in tokens[1:]:
 1023:                         if opt == "rotate":
 1024:                             self.rotate = True
 1025:                         elif opt == "edns0":
 1026:                             self.use_edns()
 1027:                         elif "timeout" in opt:
 1028:                             try:
 1029:                                 self.timeout = int(opt.split(":")[1])
 1030:                             except (ValueError, IndexError):
 1031:                                 pass
 1032:                         elif "ndots" in opt:
 1033:                             try:
 1034:                                 self.ndots = int(opt.split(":")[1])
 1035:                             except (ValueError, IndexError):
 1036:                                 pass
 1037:         if len(nameservers) == 0:
 1038:             raise NoResolverConfiguration("no nameservers")
 1039:         # Assigning directly instead of appending means we invoke the
 1040:         # setter logic, with additonal checking and enrichment.
 1041:         self.nameservers = nameservers
 1042: 
 1043:     def read_registry(self) -> None:
 1044:         """Extract resolver configuration from the Windows registry."""
 1045:         try:
 1046:             info = dns.win32util.get_dns_info()  # type: ignore
 1047:             if info.domain is not None:
 1048:                 self.domain = info.domain
 1049:             self.nameservers = info.nameservers
 1050:             self.search = info.search
 1051:         except AttributeError:
 1052:             raise NotImplementedError
 1053: 
 1054:     def _compute_timeout(
 1055:         self,
 1056:         start: float,
 1057:         lifetime: Optional[float] = None,
 1058:         errors: Optional[List[ErrorTuple]] = None,
 1059:     ) -> float:
 1060:         lifetime = self.lifetime if lifetime is None else lifetime
 1061:         now = time.time()
 1062:         duration = now - start
 1063:         if errors is None:
 1064:             errors = []
 1065:         if duration < 0:
 1066:             if duration < -1:
 1067:                 # Time going backwards is bad.  Just give up.
 1068:                 raise LifetimeTimeout(timeout=duration, errors=errors)
 1069:             else:
 1070:                 # Time went backwards, but only a little.  This can
 1071:                 # happen, e.g. under vmware with older linux kernels.
 1072:                 # Pretend it didn't happen.
 1073:                 duration = 0
 1074:         if duration >= lifetime:
 1075:             raise LifetimeTimeout(timeout=duration, errors=errors)
 1076:         return min(lifetime - duration, self.timeout)
 1077: 
 1078:     def _get_qnames_to_try(
 1079:         self, qname: dns.name.Name, search: Optional[bool]
 1080:     ) -> List[dns.name.Name]:
 1081:         # This is a separate method so we can unit test the search
 1082:         # rules without requiring the Internet.
 1083:         if search is None:
 1084:             search = self.use_search_by_default
 1085:         qnames_to_try = []
 1086:         if qname.is_absolute():
 1087:             qnames_to_try.append(qname)
 1088:         else:
 1089:             abs_qname = qname.concatenate(dns.name.root)
 1090:             if search:
 1091:                 if len(self.search) > 0:
 1092:                     # There is a search list, so use it exclusively
 1093:                     search_list = self.search[:]
 1094:                 elif self.domain != dns.name.root and self.domain is not None:
 1095:                     # We have some notion of a domain that isn't the root, so
 1096:                     # use it as the search list.
 1097:                     search_list = [self.domain]
 1098:                 else:
 1099:                     search_list = []
 1100:                 # Figure out the effective ndots (default is 1)
 1101:                 if self.ndots is None:
 1102:                     ndots = 1
 1103:                 else:
 1104:                     ndots = self.ndots
 1105:                 for suffix in search_list:
 1106:                     qnames_to_try.append(qname + suffix)
 1107:                 if len(qname) > ndots:
 1108:                     # The name has at least ndots dots, so we should try an
 1109:                     # absolute query first.
 1110:                     qnames_to_try.insert(0, abs_qname)
 1111:                 else:
 1112:                     # The name has less than ndots dots, so we should search
 1113:                     # first, then try the absolute name.
 1114:                     qnames_to_try.append(abs_qname)
 1115:             else:
 1116:                 qnames_to_try.append(abs_qname)
 1117:         return qnames_to_try
 1118: 
 1119:     def use_tsig(
 1120:         self,
 1121:         keyring: Any,
 1122:         keyname: Optional[Union[dns.name.Name, str]] = None,
 1123:         algorithm: Union[dns.name.Name, str] = dns.tsig.default_algorithm,
 1124:     ) -> None:
 1125:         """Add a TSIG signature to each query.
 1126: 
 1127:         The parameters are passed to ``dns.message.Message.use_tsig()``;
 1128:         see its documentation for details.
 1129:         """
 1130: 
 1131:         self.keyring = keyring
 1132:         self.keyname = keyname
 1133:         self.keyalgorithm = algorithm
 1134: 
 1135:     def use_edns(
 1136:         self,
 1137:         edns: Optional[Union[int, bool]] = 0,
 1138:         ednsflags: int = 0,
 1139:         payload: int = dns.message.DEFAULT_EDNS_PAYLOAD,
 1140:         options: Optional[List[dns.edns.Option]] = None,
 1141:     ) -> None:
 1142:         """Configure EDNS behavior.
 1143: 
 1144:         *edns*, an ``int``, is the EDNS level to use.  Specifying
 1145:         ``None``, ``False``, or ``-1`` means "do not use EDNS", and in this case
 1146:         the other parameters are ignored.  Specifying ``True`` is
 1147:         equivalent to specifying 0, i.e. "use EDNS0".
 1148: 
 1149:         *ednsflags*, an ``int``, the EDNS flag values.
 1150: 
 1151:         *payload*, an ``int``, is the EDNS sender's payload field, which is the
 1152:         maximum size of UDP datagram the sender can handle.  I.e. how big
 1153:         a response to this message can be.
 1154: 
 1155:         *options*, a list of ``dns.edns.Option`` objects or ``None``, the EDNS
 1156:         options.
 1157:         """
 1158: 
 1159:         if edns is None or edns is False:
 1160:             edns = -1
 1161:         elif edns is True:
 1162:             edns = 0
 1163:         self.edns = edns
 1164:         self.ednsflags = ednsflags
 1165:         self.payload = payload
 1166:         self.ednsoptions = options
 1167: 
 1168:     def set_flags(self, flags: int) -> None:
 1169:         """Overrides the default flags with your own.
 1170: 
 1171:         *flags*, an ``int``, the message flags to use.
 1172:         """
 1173: 
 1174:         self.flags = flags
 1175: 
 1176:     @classmethod
 1177:     def _enrich_nameservers(
 1178:         cls,
 1179:         nameservers: Sequence[Union[str, dns.nameserver.Nameserver]],
 1180:         nameserver_ports: Dict[str, int],
 1181:         default_port: int,
 1182:     ) -> List[dns.nameserver.Nameserver]:
 1183:         enriched_nameservers = []
 1184:         if isinstance(nameservers, list):
 1185:             for nameserver in nameservers:
 1186:                 enriched_nameserver: dns.nameserver.Nameserver
 1187:                 if isinstance(nameserver, dns.nameserver.Nameserver):
 1188:                     enriched_nameserver = nameserver
 1189:                 elif dns.inet.is_address(nameserver):
 1190:                     port = nameserver_ports.get(nameserver, default_port)
 1191:                     enriched_nameserver = dns.nameserver.Do53Nameserver(
 1192:                         nameserver, port
 1193:                     )
 1194:                 else:
 1195:                     try:
 1196:                         if urlparse(nameserver).scheme != "https":
 1197:                             raise NotImplementedError
 1198:                     except Exception:
 1199:                         raise ValueError(
 1200:                             f"nameserver {nameserver} is not a "
 1201:                             "dns.nameserver.Nameserver instance or text form, "
 1202:                             "IP address, nor a valid https URL"
 1203:                         )
 1204:                     enriched_nameserver = dns.nameserver.DoHNameserver(nameserver)
 1205:                 enriched_nameservers.append(enriched_nameserver)
 1206:         else:
 1207:             raise ValueError(
 1208:                 "nameservers must be a list or tuple (not a {})".format(
 1209:                     type(nameservers)
 1210:                 )
 1211:             )
 1212:         return enriched_nameservers
 1213: 
 1214:     @property
 1215:     def nameservers(
 1216:         self,
 1217:     ) -> Sequence[Union[str, dns.nameserver.Nameserver]]:
 1218:         return self._nameservers
 1219: 
 1220:     @nameservers.setter
 1221:     def nameservers(
 1222:         self, nameservers: Sequence[Union[str, dns.nameserver.Nameserver]]
 1223:     ) -> None:
 1224:         """
 1225:         *nameservers*, a ``list`` of nameservers, where a nameserver is either
 1226:         a string interpretable as a nameserver, or a ``dns.nameserver.Nameserver``
 1227:         instance.
 1228: 
 1229:         Raises ``ValueError`` if *nameservers* is not a list of nameservers.
 1230:         """
 1231:         # We just call _enrich_nameservers() for checking
 1232:         self._enrich_nameservers(nameservers, self.nameserver_ports, self.port)
 1233:         self._nameservers = nameservers
 1234: 
 1235: 
 1236: class Resolver(BaseResolver):
 1237:     """DNS stub resolver."""
 1238: 
 1239:     def resolve(
 1240:         self,
 1241:         qname: Union[dns.name.Name, str],
 1242:         rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,
 1243:         rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,
 1244:         tcp: bool = False,
 1245:         source: Optional[str] = None,
 1246:         raise_on_no_answer: bool = True,
 1247:         source_port: int = 0,
 1248:         lifetime: Optional[float] = None,
 1249:         search: Optional[bool] = None,
 1250:     ) -> Answer:  # pylint: disable=arguments-differ
 1251:         """Query nameservers to find the answer to the question.
 1252: 
 1253:         The *qname*, *rdtype*, and *rdclass* parameters may be objects
 1254:         of the appropriate type, or strings that can be converted into objects
 1255:         of the appropriate type.
 1256: 
 1257:         *qname*, a ``dns.name.Name`` or ``str``, the query name.
 1258: 
 1259:         *rdtype*, an ``int`` or ``str``,  the query type.
 1260: 
 1261:         *rdclass*, an ``int`` or ``str``,  the query class.
 1262: 
 1263:         *tcp*, a ``bool``.  If ``True``, use TCP to make the query.
 1264: 
 1265:         *source*, a ``str`` or ``None``.  If not ``None``, bind to this IP
 1266:         address when making queries.
 1267: 
 1268:         *raise_on_no_answer*, a ``bool``.  If ``True``, raise
 1269:         ``dns.resolver.NoAnswer`` if there's no answer to the question.
 1270: 
 1271:         *source_port*, an ``int``, the port from which to send the message.
 1272: 
 1273:         *lifetime*, a ``float``, how many seconds a query should run
 1274:         before timing out.
 1275: 
 1276:         *search*, a ``bool`` or ``None``, determines whether the
 1277:         search list configured in the system's resolver configuration
 1278:         are used for relative names, and whether the resolver's domain
 1279:         may be added to relative names.  The default is ``None``,
 1280:         which causes the value of the resolver's
 1281:         ``use_search_by_default`` attribute to be used.
 1282: 
 1283:         Raises ``dns.resolver.LifetimeTimeout`` if no answers could be found
 1284:         in the specified lifetime.
 1285: 
 1286:         Raises ``dns.resolver.NXDOMAIN`` if the query name does not exist.
 1287: 
 1288:         Raises ``dns.resolver.YXDOMAIN`` if the query name is too long after
 1289:         DNAME substitution.
 1290: 
 1291:         Raises ``dns.resolver.NoAnswer`` if *raise_on_no_answer* is
 1292:         ``True`` and the query name exists but has no RRset of the
 1293:         desired type and class.
 1294: 
 1295:         Raises ``dns.resolver.NoNameservers`` if no non-broken
 1296:         nameservers are available to answer the question.
 1297: 
 1298:         Returns a ``dns.resolver.Answer`` instance.
 1299: 
 1300:         """
 1301: 
 1302:         resolution = _Resolution(
 1303:             self, qname, rdtype, rdclass, tcp, raise_on_no_answer, search
 1304:         )
 1305:         start = time.time()
 1306:         while True:
 1307:             (request, answer) = resolution.next_request()
 1308:             # Note we need to say "if answer is not None" and not just
 1309:             # "if answer" because answer implements __len__, and python
 1310:             # will call that.  We want to return if we have an answer
 1311:             # object, including in cases where its length is 0.
 1312:             if answer is not None:
 1313:                 # cache hit!
 1314:                 return answer
 1315:             assert request is not None  # needed for type checking
 1316:             done = False
 1317:             while not done:
 1318:                 (nameserver, tcp, backoff) = resolution.next_nameserver()
 1319:                 if backoff:
 1320:                     time.sleep(backoff)
 1321:                 timeout = self._compute_timeout(start, lifetime, resolution.errors)
 1322:                 try:
 1323:                     response = nameserver.query(
 1324:                         request,
 1325:                         timeout=timeout,
 1326:                         source=source,
 1327:                         source_port=source_port,
 1328:                         max_size=tcp,
 1329:                     )
 1330:                 except Exception as ex:
 1331:                     (_, done) = resolution.query_result(None, ex)
 1332:                     continue
 1333:                 (answer, done) = resolution.query_result(response, None)
 1334:                 # Note we need to say "if answer is not None" and not just
 1335:                 # "if answer" because answer implements __len__, and python
 1336:                 # will call that.  We want to return if we have an answer
 1337:                 # object, including in cases where its length is 0.
 1338:                 if answer is not None:
 1339:                     return answer
 1340: 
 1341:     def query(
 1342:         self,
 1343:         qname: Union[dns.name.Name, str],
 1344:         rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,
 1345:         rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,
 1346:         tcp: bool = False,
 1347:         source: Optional[str] = None,
 1348:         raise_on_no_answer: bool = True,
 1349:         source_port: int = 0,
 1350:         lifetime: Optional[float] = None,
 1351:     ) -> Answer:  # pragma: no cover
 1352:         """Query nameservers to find the answer to the question.
 1353: 
 1354:         This method calls resolve() with ``search=True``, and is
 1355:         provided for backwards compatibility with prior versions of
 1356:         dnspython.  See the documentation for the resolve() method for
 1357:         further details.
 1358:         """
 1359:         warnings.warn(
 1360:             "please use dns.resolver.Resolver.resolve() instead",
 1361:             DeprecationWarning,
 1362:             stacklevel=2,
 1363:         )
 1364:         return self.resolve(
 1365:             qname,
 1366:             rdtype,
 1367:             rdclass,
 1368:             tcp,
 1369:             source,
 1370:             raise_on_no_answer,
 1371:             source_port,
 1372:             lifetime,
 1373:             True,
 1374:         )
 1375: 
 1376:     def resolve_address(self, ipaddr: str, *args: Any, **kwargs: Any) -> Answer:
 1377:         """Use a resolver to run a reverse query for PTR records.
 1378: 
 1379:         This utilizes the resolve() method to perform a PTR lookup on the
 1380:         specified IP address.
 1381: 
 1382:         *ipaddr*, a ``str``, the IPv4 or IPv6 address you want to get
 1383:         the PTR record for.
 1384: 
 1385:         All other arguments that can be passed to the resolve() function
 1386:         except for rdtype and rdclass are also supported by this
 1387:         function.
 1388:         """
 1389:         # We make a modified kwargs for type checking happiness, as otherwise
 1390:         # we get a legit warning about possibly having rdtype and rdclass
 1391:         # in the kwargs more than once.
 1392:         modified_kwargs: Dict[str, Any] = {}
 1393:         modified_kwargs.update(kwargs)
 1394:         modified_kwargs["rdtype"] = dns.rdatatype.PTR
 1395:         modified_kwargs["rdclass"] = dns.rdataclass.IN
 1396:         return self.resolve(
 1397:             dns.reversename.from_address(ipaddr), *args, **modified_kwargs
 1398:         )
 1399: 
 1400:     def resolve_name(
 1401:         self,
 1402:         name: Union[dns.name.Name, str],
 1403:         family: int = socket.AF_UNSPEC,
 1404:         **kwargs: Any,
 1405:     ) -> HostAnswers:
 1406:         """Use a resolver to query for address records.
 1407: 
 1408:         This utilizes the resolve() method to perform A and/or AAAA lookups on
 1409:         the specified name.
 1410: 
 1411:         *qname*, a ``dns.name.Name`` or ``str``, the name to resolve.
 1412: 
 1413:         *family*, an ``int``, the address family.  If socket.AF_UNSPEC
 1414:         (the default), both A and AAAA records will be retrieved.
 1415: 
 1416:         All other arguments that can be passed to the resolve() function
 1417:         except for rdtype and rdclass are also supported by this
 1418:         function.
 1419:         """
 1420:         # We make a modified kwargs for type checking happiness, as otherwise
 1421:         # we get a legit warning about possibly having rdtype and rdclass
 1422:         # in the kwargs more than once.
 1423:         modified_kwargs: Dict[str, Any] = {}
 1424:         modified_kwargs.update(kwargs)
 1425:         modified_kwargs.pop("rdtype", None)
 1426:         modified_kwargs["rdclass"] = dns.rdataclass.IN
 1427: 
 1428:         if family == socket.AF_INET:
 1429:             v4 = self.resolve(name, dns.rdatatype.A, **modified_kwargs)
 1430:             return HostAnswers.make(v4=v4)
 1431:         elif family == socket.AF_INET6:
 1432:             v6 = self.resolve(name, dns.rdatatype.AAAA, **modified_kwargs)
 1433:             return HostAnswers.make(v6=v6)
 1434:         elif family != socket.AF_UNSPEC:
 1435:             raise NotImplementedError(f"unknown address family {family}")
 1436: 
 1437:         raise_on_no_answer = modified_kwargs.pop("raise_on_no_answer", True)
 1438:         lifetime = modified_kwargs.pop("lifetime", None)
 1439:         start = time.time()
 1440:         v6 = self.resolve(
 1441:             name,
 1442:             dns.rdatatype.AAAA,
 1443:             raise_on_no_answer=False,
 1444:             lifetime=self._compute_timeout(start, lifetime),
 1445:             **modified_kwargs,
 1446:         )
 1447:         # Note that setting name ensures we query the same name
 1448:         # for A as we did for AAAA.  (This is just in case search lists
 1449:         # are active by default in the resolver configuration and
 1450:         # we might be talking to a server that says NXDOMAIN when it
 1451:         # wants to say NOERROR no data.
 1452:         name = v6.qname
 1453:         v4 = self.resolve(
 1454:             name,
 1455:             dns.rdatatype.A,
 1456:             raise_on_no_answer=False,
 1457:             lifetime=self._compute_timeout(start, lifetime),
 1458:             **modified_kwargs,
 1459:         )
 1460:         answers = HostAnswers.make(v6=v6, v4=v4, add_empty=not raise_on_no_answer)
 1461:         if not answers:
 1462:             raise NoAnswer(response=v6.response)
 1463:         return answers
 1464: 
 1465:     # pylint: disable=redefined-outer-name
 1466: 
 1467:     def canonical_name(self, name: Union[dns.name.Name, str]) -> dns.name.Name:
 1468:         """Determine the canonical name of *name*.
 1469: 
 1470:         The canonical name is the name the resolver uses for queries
 1471:         after all CNAME and DNAME renamings have been applied.
 1472: 
 1473:         *name*, a ``dns.name.Name`` or ``str``, the query name.
 1474: 
 1475:         This method can raise any exception that ``resolve()`` can
 1476:         raise, other than ``dns.resolver.NoAnswer`` and
 1477:         ``dns.resolver.NXDOMAIN``.
 1478: 
 1479:         Returns a ``dns.name.Name``.
 1480:         """
 1481:         try:
 1482:             answer = self.resolve(name, raise_on_no_answer=False)
 1483:             canonical_name = answer.canonical_name
 1484:         except dns.resolver.NXDOMAIN as e:
 1485:             canonical_name = e.canonical_name
 1486:         return canonical_name
 1487: 
 1488:     # pylint: enable=redefined-outer-name
 1489: 
 1490:     def try_ddr(self, lifetime: float = 5.0) -> None:
 1491:         """Try to update the resolver's nameservers using Discovery of Designated
 1492:         Resolvers (DDR).  If successful, the resolver will subsequently use
 1493:         DNS-over-HTTPS or DNS-over-TLS for future queries.
 1494: 
 1495:         *lifetime*, a float, is the maximum time to spend attempting DDR.  The default
 1496:         is 5 seconds.
 1497: 
 1498:         If the SVCB query is successful and results in a non-empty list of nameservers,
 1499:         then the resolver's nameservers are set to the returned servers in priority
 1500:         order.
 1501: 
 1502:         The current implementation does not use any address hints from the SVCB record,
 1503:         nor does it resolve addresses for the SCVB target name, rather it assumes that
 1504:         the bootstrap nameserver will always be one of the addresses and uses it.
 1505:         A future revision to the code may offer fuller support.  The code verifies that
 1506:         the bootstrap nameserver is in the Subject Alternative Name field of the
 1507:         TLS certficate.
 1508:         """
 1509:         try:
 1510:             expiration = time.time() + lifetime
 1511:             answer = self.resolve(
 1512:                 dns._ddr._local_resolver_name, "SVCB", lifetime=lifetime
 1513:             )
 1514:             timeout = dns.query._remaining(expiration)
 1515:             nameservers = dns._ddr._get_nameservers_sync(answer, timeout)
 1516:             if len(nameservers) > 0:
 1517:                 self.nameservers = nameservers
 1518:         except Exception:
 1519:             pass
 1520: 
 1521: 
 1522: #: The default resolver.
 1523: default_resolver: Optional[Resolver] = None
 1524: 
 1525: 
 1526: def get_default_resolver() -> Resolver:
 1527:     """Get the default resolver, initializing it if necessary."""
 1528:     if default_resolver is None:
 1529:         reset_default_resolver()
 1530:     assert default_resolver is not None
 1531:     return default_resolver
 1532: 
 1533: 
 1534: def reset_default_resolver() -> None:
 1535:     """Re-initialize default resolver.
 1536: 
 1537:     Note that the resolver configuration (i.e. /etc/resolv.conf on UNIX
 1538:     systems) will be re-read immediately.
 1539:     """
 1540: 
 1541:     global default_resolver
 1542:     default_resolver = Resolver()
 1543: 
 1544: 
 1545: def resolve(
 1546:     qname: Union[dns.name.Name, str],
 1547:     rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,
 1548:     rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,
 1549:     tcp: bool = False,
 1550:     source: Optional[str] = None,
 1551:     raise_on_no_answer: bool = True,
 1552:     source_port: int = 0,
 1553:     lifetime: Optional[float] = None,
 1554:     search: Optional[bool] = None,
 1555: ) -> Answer:  # pragma: no cover
 1556:     """Query nameservers to find the answer to the question.
 1557: 
 1558:     This is a convenience function that uses the default resolver
 1559:     object to make the query.
 1560: 
 1561:     See ``dns.resolver.Resolver.resolve`` for more information on the
 1562:     parameters.
 1563:     """
 1564: 
 1565:     return get_default_resolver().resolve(
 1566:         qname,
 1567:         rdtype,
 1568:         rdclass,
 1569:         tcp,
 1570:         source,
 1571:         raise_on_no_answer,
 1572:         source_port,
 1573:         lifetime,
 1574:         search,
 1575:     )
 1576: 
 1577: 
 1578: def query(
 1579:     qname: Union[dns.name.Name, str],
 1580:     rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,
 1581:     rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,
 1582:     tcp: bool = False,
 1583:     source: Optional[str] = None,
 1584:     raise_on_no_answer: bool = True,
 1585:     source_port: int = 0,
 1586:     lifetime: Optional[float] = None,
 1587: ) -> Answer:  # pragma: no cover
 1588:     """Query nameservers to find the answer to the question.
 1589: 
 1590:     This method calls resolve() with ``search=True``, and is
 1591:     provided for backwards compatibility with prior versions of
 1592:     dnspython.  See the documentation for the resolve() method for
 1593:     further details.
 1594:     """
 1595:     warnings.warn(
 1596:         "please use dns.resolver.resolve() instead", DeprecationWarning, stacklevel=2
 1597:     )
 1598:     return resolve(
 1599:         qname,
 1600:         rdtype,
 1601:         rdclass,
 1602:         tcp,
 1603:         source,
 1604:         raise_on_no_answer,
 1605:         source_port,
 1606:         lifetime,
 1607:         True,
 1608:     )
 1609: 
 1610: 
 1611: def resolve_address(ipaddr: str, *args: Any, **kwargs: Any) -> Answer:
 1612:     """Use a resolver to run a reverse query for PTR records.
 1613: 
 1614:     See ``dns.resolver.Resolver.resolve_address`` for more information on the
 1615:     parameters.
 1616:     """
 1617: 
 1618:     return get_default_resolver().resolve_address(ipaddr, *args, **kwargs)
 1619: 
 1620: 
 1621: def resolve_name(
 1622:     name: Union[dns.name.Name, str], family: int = socket.AF_UNSPEC, **kwargs: Any
 1623: ) -> HostAnswers:
 1624:     """Use a resolver to query for address records.
 1625: 
 1626:     See ``dns.resolver.Resolver.resolve_name`` for more information on the
 1627:     parameters.
 1628:     """
 1629: 
 1630:     return get_default_resolver().resolve_name(name, family, **kwargs)
 1631: 
 1632: 
 1633: def canonical_name(name: Union[dns.name.Name, str]) -> dns.name.Name:
 1634:     """Determine the canonical name of *name*.
 1635: 
 1636:     See ``dns.resolver.Resolver.canonical_name`` for more information on the
 1637:     parameters and possible exceptions.
 1638:     """
 1639: 
 1640:     return get_default_resolver().canonical_name(name)
 1641: 
 1642: 
 1643: def try_ddr(lifetime: float = 5.0) -> None:
 1644:     """Try to update the default resolver's nameservers using Discovery of Designated
 1645:     Resolvers (DDR).  If successful, the resolver will subsequently use
 1646:     DNS-over-HTTPS or DNS-over-TLS for future queries.
 1647: 
 1648:     See :py:func:`dns.resolver.Resolver.try_ddr` for more information.
 1649:     """
 1650:     return get_default_resolver().try_ddr(lifetime)
 1651: 
 1652: 
 1653: def zone_for_name(
 1654:     name: Union[dns.name.Name, str],
 1655:     rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,
 1656:     tcp: bool = False,
 1657:     resolver: Optional[Resolver] = None,
 1658:     lifetime: Optional[float] = None,
 1659: ) -> dns.name.Name:
 1660:     """Find the name of the zone which contains the specified name.
 1661: 
 1662:     *name*, an absolute ``dns.name.Name`` or ``str``, the query name.
 1663: 
 1664:     *rdclass*, an ``int``, the query class.
 1665: 
 1666:     *tcp*, a ``bool``.  If ``True``, use TCP to make the query.
 1667: 
 1668:     *resolver*, a ``dns.resolver.Resolver`` or ``None``, the resolver to use.
 1669:     If ``None``, the default, then the default resolver is used.
 1670: 
 1671:     *lifetime*, a ``float``, the total time to allow for the queries needed
 1672:     to determine the zone.  If ``None``, the default, then only the individual
 1673:     query limits of the resolver apply.
 1674: 
 1675:     Raises ``dns.resolver.NoRootSOA`` if there is no SOA RR at the DNS
 1676:     root.  (This is only likely to happen if you're using non-default
 1677:     root servers in your network and they are misconfigured.)
 1678: 
 1679:     Raises ``dns.resolver.LifetimeTimeout`` if the answer could not be
 1680:     found in the allotted lifetime.
 1681: 
 1682:     Returns a ``dns.name.Name``.
 1683:     """
 1684: 
 1685:     if isinstance(name, str):
 1686:         name = dns.name.from_text(name, dns.name.root)
 1687:     if resolver is None:
 1688:         resolver = get_default_resolver()
 1689:     if not name.is_absolute():
 1690:         raise NotAbsolute(name)
 1691:     start = time.time()
 1692:     expiration: Optional[float]
 1693:     if lifetime is not None:
 1694:         expiration = start + lifetime
 1695:     else:
 1696:         expiration = None
 1697:     while 1:
 1698:         try:
 1699:             rlifetime: Optional[float]
 1700:             if expiration is not None:
 1701:                 rlifetime = expiration - time.time()
 1702:                 if rlifetime <= 0:
 1703:                     rlifetime = 0
 1704:             else:
 1705:                 rlifetime = None
 1706:             answer = resolver.resolve(
 1707:                 name, dns.rdatatype.SOA, rdclass, tcp, lifetime=rlifetime
 1708:             )
 1709:             assert answer.rrset is not None
 1710:             if answer.rrset.name == name:
 1711:                 return name
 1712:             # otherwise we were CNAMEd or DNAMEd and need to look higher
 1713:         except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer) as e:
 1714:             if isinstance(e, dns.resolver.NXDOMAIN):
 1715:                 response = e.responses().get(name)
 1716:             else:
 1717:                 response = e.response()  # pylint: disable=no-value-for-parameter
 1718:             if response:
 1719:                 for rrs in response.authority:
 1720:                     if rrs.rdtype == dns.rdatatype.SOA and rrs.rdclass == rdclass:
 1721:                         (nr, _, _) = rrs.name.fullcompare(name)
 1722:                         if nr == dns.name.NAMERELN_SUPERDOMAIN:
 1723:                             # We're doing a proper superdomain check as
 1724:                             # if the name were equal we ought to have gotten
 1725:                             # it in the answer section!  We are ignoring the
 1726:                             # possibility that the authority is insane and
 1727:                             # is including multiple SOA RRs for different
 1728:                             # authorities.
 1729:                             return rrs.name
 1730:             # we couldn't extract anything useful from the response (e.g. it's
 1731:             # a type 3 NXDOMAIN)
 1732:         try:
 1733:             name = name.parent()
 1734:         except dns.name.NoParent:
 1735:             raise NoRootSOA
 1736: 
 1737: 
 1738: def make_resolver_at(
 1739:     where: Union[dns.name.Name, str],
 1740:     port: int = 53,
 1741:     family: int = socket.AF_UNSPEC,
 1742:     resolver: Optional[Resolver] = None,
 1743: ) -> Resolver:
 1744:     """Make a stub resolver using the specified destination as the full resolver.
 1745: 
 1746:     *where*, a ``dns.name.Name`` or ``str`` the domain name or IP address of the
 1747:     full resolver.
 1748: 
 1749:     *port*, an ``int``, the port to use.  If not specified, the default is 53.
 1750: 
 1751:     *family*, an ``int``, the address family to use.  This parameter is used if
 1752:     *where* is not an address.  The default is ``socket.AF_UNSPEC`` in which case
 1753:     the first address returned by ``resolve_name()`` will be used, otherwise the
 1754:     first address of the specified family will be used.
 1755: 
 1756:     *resolver*, a ``dns.resolver.Resolver`` or ``None``, the resolver to use for
 1757:     resolution of hostnames.  If not specified, the default resolver will be used.
 1758: 
 1759:     Returns a ``dns.resolver.Resolver`` or raises an exception.
 1760:     """
 1761:     if resolver is None:
 1762:         resolver = get_default_resolver()
 1763:     nameservers: List[Union[str, dns.nameserver.Nameserver]] = []
 1764:     if isinstance(where, str) and dns.inet.is_address(where):
 1765:         nameservers.append(dns.nameserver.Do53Nameserver(where, port))
 1766:     else:
 1767:         for address in resolver.resolve_name(where, family).addresses():
 1768:             nameservers.append(dns.nameserver.Do53Nameserver(address, port))
 1769:     res = dns.resolver.Resolver(configure=False)
 1770:     res.nameservers = nameservers
 1771:     return res
 1772: 
 1773: 
 1774: def resolve_at(
 1775:     where: Union[dns.name.Name, str],
 1776:     qname: Union[dns.name.Name, str],
 1777:     rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,
 1778:     rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,
 1779:     tcp: bool = False,
 1780:     source: Optional[str] = None,
 1781:     raise_on_no_answer: bool = True,
 1782:     source_port: int = 0,
 1783:     lifetime: Optional[float] = None,
 1784:     search: Optional[bool] = None,
 1785:     port: int = 53,
 1786:     family: int = socket.AF_UNSPEC,
 1787:     resolver: Optional[Resolver] = None,
 1788: ) -> Answer:
 1789:     """Query nameservers to find the answer to the question.
 1790: 
 1791:     This is a convenience function that calls ``dns.resolver.make_resolver_at()`` to
 1792:     make a resolver, and then uses it to resolve the query.
 1793: 
 1794:     See ``dns.resolver.Resolver.resolve`` for more information on the resolution
 1795:     parameters, and ``dns.resolver.make_resolver_at`` for information about the resolver
 1796:     parameters *where*, *port*, *family*, and *resolver*.
 1797: 
 1798:     If making more than one query, it is more efficient to call
 1799:     ``dns.resolver.make_resolver_at()`` and then use that resolver for the queries
 1800:     instead of calling ``resolve_at()`` multiple times.
 1801:     """
 1802:     return make_resolver_at(where, port, family, resolver).resolve(
 1803:         qname,
 1804:         rdtype,
 1805:         rdclass,
 1806:         tcp,
 1807:         source,
 1808:         raise_on_no_answer,
 1809:         source_port,
 1810:         lifetime,
 1811:         search,
 1812:     )
 1813: 
 1814: 
 1815: #
 1816: # Support for overriding the system resolver for all python code in the
 1817: # running process.
 1818: #
 1819: 
 1820: _protocols_for_socktype = {
 1821:     socket.SOCK_DGRAM: [socket.SOL_UDP],
 1822:     socket.SOCK_STREAM: [socket.SOL_TCP],
 1823: }
 1824: 
 1825: _resolver = None
 1826: _original_getaddrinfo = socket.getaddrinfo
 1827: _original_getnameinfo = socket.getnameinfo
 1828: _original_getfqdn = socket.getfqdn
 1829: _original_gethostbyname = socket.gethostbyname
 1830: _original_gethostbyname_ex = socket.gethostbyname_ex
 1831: _original_gethostbyaddr = socket.gethostbyaddr
 1832: 
 1833: 
 1834: def _getaddrinfo(
 1835:     host=None, service=None, family=socket.AF_UNSPEC, socktype=0, proto=0, flags=0
 1836: ):
 1837:     if flags & socket.AI_NUMERICHOST != 0:
 1838:         # Short circuit directly into the system's getaddrinfo().  We're
 1839:         # not adding any value in this case, and this avoids infinite loops
 1840:         # because dns.query.* needs to call getaddrinfo() for IPv6 scoping
 1841:         # reasons.  We will also do this short circuit below if we
 1842:         # discover that the host is an address literal.
 1843:         return _original_getaddrinfo(host, service, family, socktype, proto, flags)
 1844:     if flags & (socket.AI_ADDRCONFIG | socket.AI_V4MAPPED) != 0:
 1845:         # Not implemented.  We raise a gaierror as opposed to a
 1846:         # NotImplementedError as it helps callers handle errors more
 1847:         # appropriately.  [Issue #316]
 1848:         #
 1849:         # We raise EAI_FAIL as opposed to EAI_SYSTEM because there is
 1850:         # no EAI_SYSTEM on Windows [Issue #416].  We didn't go for
 1851:         # EAI_BADFLAGS as the flags aren't bad, we just don't
 1852:         # implement them.
 1853:         raise socket.gaierror(
 1854:             socket.EAI_FAIL, "Non-recoverable failure in name resolution"
 1855:         )
 1856:     if host is None and service is None:
 1857:         raise socket.gaierror(socket.EAI_NONAME, "Name or service not known")
 1858:     addrs = []
 1859:     canonical_name = None  # pylint: disable=redefined-outer-name
 1860:     # Is host None or an address literal?  If so, use the system's
 1861:     # getaddrinfo().
 1862:     if host is None:
 1863:         return _original_getaddrinfo(host, service, family, socktype, proto, flags)
 1864:     try:
 1865:         # We don't care about the result of af_for_address(), we're just
 1866:         # calling it so it raises an exception if host is not an IPv4 or
 1867:         # IPv6 address.
 1868:         dns.inet.af_for_address(host)
 1869:         return _original_getaddrinfo(host, service, family, socktype, proto, flags)
 1870:     except Exception:
 1871:         pass
 1872:     # Something needs resolution!
 1873:     try:
 1874:         answers = _resolver.resolve_name(host, family)
 1875:         addrs = answers.addresses_and_families()
 1876:         canonical_name = answers.canonical_name().to_text(True)
 1877:     except dns.resolver.NXDOMAIN:
 1878:         raise socket.gaierror(socket.EAI_NONAME, "Name or service not known")
 1879:     except Exception:
 1880:         # We raise EAI_AGAIN here as the failure may be temporary
 1881:         # (e.g. a timeout) and EAI_SYSTEM isn't defined on Windows.
 1882:         # [Issue #416]
 1883:         raise socket.gaierror(socket.EAI_AGAIN, "Temporary failure in name resolution")
 1884:     port = None
 1885:     try:
 1886:         # Is it a port literal?
 1887:         if service is None:
 1888:             port = 0
 1889:         else:
 1890:             port = int(service)
 1891:     except Exception:
 1892:         if flags & socket.AI_NUMERICSERV == 0:
 1893:             try:
 1894:                 port = socket.getservbyname(service)
 1895:             except Exception:
 1896:                 pass
 1897:     if port is None:
 1898:         raise socket.gaierror(socket.EAI_NONAME, "Name or service not known")
 1899:     tuples = []
 1900:     if socktype == 0:
 1901:         socktypes = [socket.SOCK_DGRAM, socket.SOCK_STREAM]
 1902:     else:
 1903:         socktypes = [socktype]
 1904:     if flags & socket.AI_CANONNAME != 0:
 1905:         cname = canonical_name
 1906:     else:
 1907:         cname = ""
 1908:     for addr, af in addrs:
 1909:         for socktype in socktypes:
 1910:             for proto in _protocols_for_socktype[socktype]:
 1911:                 addr_tuple = dns.inet.low_level_address_tuple((addr, port), af)
 1912:                 tuples.append((af, socktype, proto, cname, addr_tuple))
 1913:     if len(tuples) == 0:
 1914:         raise socket.gaierror(socket.EAI_NONAME, "Name or service not known")
 1915:     return tuples
 1916: 
 1917: 
 1918: def _getnameinfo(sockaddr, flags=0):
 1919:     host = sockaddr[0]
 1920:     port = sockaddr[1]
 1921:     if len(sockaddr) == 4:
 1922:         scope = sockaddr[3]
 1923:         family = socket.AF_INET6
 1924:     else:
 1925:         scope = None
 1926:         family = socket.AF_INET
 1927:     tuples = _getaddrinfo(host, port, family, socket.SOCK_STREAM, socket.SOL_TCP, 0)
 1928:     if len(tuples) > 1:
 1929:         raise socket.error("sockaddr resolved to multiple addresses")
 1930:     addr = tuples[0][4][0]
 1931:     if flags & socket.NI_DGRAM:
 1932:         pname = "udp"
 1933:     else:
 1934:         pname = "tcp"
 1935:     qname = dns.reversename.from_address(addr)
 1936:     if flags & socket.NI_NUMERICHOST == 0:
 1937:         try:
 1938:             answer = _resolver.resolve(qname, "PTR")
 1939:             hostname = answer.rrset[0].target.to_text(True)
 1940:         except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):
 1941:             if flags & socket.NI_NAMEREQD:
 1942:                 raise socket.gaierror(socket.EAI_NONAME, "Name or service not known")
 1943:             hostname = addr
 1944:             if scope is not None:
 1945:                 hostname += "%" + str(scope)
 1946:     else:
 1947:         hostname = addr
 1948:         if scope is not None:
 1949:             hostname += "%" + str(scope)
 1950:     if flags & socket.NI_NUMERICSERV:
 1951:         service = str(port)
 1952:     else:
 1953:         service = socket.getservbyport(port, pname)
 1954:     return (hostname, service)
 1955: 
 1956: 
 1957: def _getfqdn(name=None):
 1958:     if name is None:
 1959:         name = socket.gethostname()
 1960:     try:
 1961:         (name, _, _) = _gethostbyaddr(name)
 1962:         # Python's version checks aliases too, but our gethostbyname
 1963:         # ignores them, so we do so here as well.
 1964:     except Exception:
 1965:         pass
 1966:     return name
 1967: 
 1968: 
 1969: def _gethostbyname(name):
 1970:     return _gethostbyname_ex(name)[2][0]
 1971: 
 1972: 
 1973: def _gethostbyname_ex(name):
 1974:     aliases = []
 1975:     addresses = []
 1976:     tuples = _getaddrinfo(
 1977:         name, 0, socket.AF_INET, socket.SOCK_STREAM, socket.SOL_TCP, socket.AI_CANONNAME
 1978:     )
 1979:     canonical = tuples[0][3]
 1980:     for item in tuples:
 1981:         addresses.append(item[4][0])
 1982:     # XXX we just ignore aliases
 1983:     return (canonical, aliases, addresses)
 1984: 
 1985: 
 1986: def _gethostbyaddr(ip):
 1987:     try:
 1988:         dns.ipv6.inet_aton(ip)
 1989:         sockaddr = (ip, 80, 0, 0)
 1990:         family = socket.AF_INET6
 1991:     except Exception:
 1992:         try:
 1993:             dns.ipv4.inet_aton(ip)
 1994:         except Exception:
 1995:             raise socket.gaierror(socket.EAI_NONAME, "Name or service not known")
 1996:         sockaddr = (ip, 80)
 1997:         family = socket.AF_INET
 1998:     (name, _) = _getnameinfo(sockaddr, socket.NI_NAMEREQD)
 1999:     aliases = []
 2000:     addresses = []
 2001:     tuples = _getaddrinfo(
 2002:         name, 0, family, socket.SOCK_STREAM, socket.SOL_TCP, socket.AI_CANONNAME
 2003:     )
 2004:     canonical = tuples[0][3]
 2005:     # We only want to include an address from the tuples if it's the
 2006:     # same as the one we asked about.  We do this comparison in binary
 2007:     # to avoid any differences in text representations.
 2008:     bin_ip = dns.inet.inet_pton(family, ip)
 2009:     for item in tuples:
 2010:         addr = item[4][0]
 2011:         bin_addr = dns.inet.inet_pton(family, addr)
 2012:         if bin_ip == bin_addr:
 2013:             addresses.append(addr)
 2014:     # XXX we just ignore aliases
 2015:     return (canonical, aliases, addresses)
 2016: 
 2017: 
 2018: def override_system_resolver(resolver: Optional[Resolver] = None) -> None:
 2019:     """Override the system resolver routines in the socket module with
 2020:     versions which use dnspython's resolver.
 2021: 
 2022:     This can be useful in testing situations where you want to control
 2023:     the resolution behavior of python code without having to change
 2024:     the system's resolver settings (e.g. /etc/resolv.conf).
 2025: 
 2026:     The resolver to use may be specified; if it's not, the default
 2027:     resolver will be used.
 2028: 
 2029:     resolver, a ``dns.resolver.Resolver`` or ``None``, the resolver to use.
 2030:     """
 2031: 
 2032:     if resolver is None:
 2033:         resolver = get_default_resolver()
 2034:     global _resolver
 2035:     _resolver = resolver
 2036:     socket.getaddrinfo = _getaddrinfo
 2037:     socket.getnameinfo = _getnameinfo
 2038:     socket.getfqdn = _getfqdn
 2039:     socket.gethostbyname = _gethostbyname
 2040:     socket.gethostbyname_ex = _gethostbyname_ex
 2041:     socket.gethostbyaddr = _gethostbyaddr
 2042: 
 2043: 
 2044: def restore_system_resolver() -> None:
 2045:     """Undo the effects of prior override_system_resolver()."""
 2046: 
 2047:     global _resolver
 2048:     _resolver = None
 2049:     socket.getaddrinfo = _original_getaddrinfo
 2050:     socket.getnameinfo = _original_getnameinfo
 2051:     socket.getfqdn = _original_getfqdn
 2052:     socket.gethostbyname = _original_gethostbyname
 2053:     socket.gethostbyname_ex = _original_gethostbyname_ex
 2054:     socket.gethostbyaddr = _original_gethostbyaddr
