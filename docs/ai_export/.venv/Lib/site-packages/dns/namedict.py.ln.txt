    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2017 Nominum, Inc.
    4: # Copyright (C) 2016 Coresec Systems AB
    5: #
    6: # Permission to use, copy, modify, and distribute this software and its
    7: # documentation for any purpose with or without fee is hereby granted,
    8: # provided that the above copyright notice and this permission notice
    9: # appear in all copies.
   10: #
   11: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   12: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   13: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   14: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   15: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   16: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   17: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   18: #
   19: # THE SOFTWARE IS PROVIDED "AS IS" AND CORESEC SYSTEMS AB DISCLAIMS ALL
   20: # WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
   21: # WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL CORESEC
   22: # SYSTEMS AB BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
   23: # CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
   24: # OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
   25: # NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
   26: # WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   27: 
   28: """DNS name dictionary"""
   29: 
   30: # pylint seems to be confused about this one!
   31: from collections.abc import MutableMapping  # pylint: disable=no-name-in-module
   32: 
   33: import dns.name
   34: 
   35: 
   36: class NameDict(MutableMapping):
   37:     """A dictionary whose keys are dns.name.Name objects.
   38: 
   39:     In addition to being like a regular Python dictionary, this
   40:     dictionary can also get the deepest match for a given key.
   41:     """
   42: 
   43:     __slots__ = ["max_depth", "max_depth_items", "__store"]
   44: 
   45:     def __init__(self, *args, **kwargs):
   46:         super().__init__()
   47:         self.__store = dict()
   48:         #: the maximum depth of the keys that have ever been added
   49:         self.max_depth = 0
   50:         #: the number of items of maximum depth
   51:         self.max_depth_items = 0
   52:         self.update(dict(*args, **kwargs))
   53: 
   54:     def __update_max_depth(self, key):
   55:         if len(key) == self.max_depth:
   56:             self.max_depth_items = self.max_depth_items + 1
   57:         elif len(key) > self.max_depth:
   58:             self.max_depth = len(key)
   59:             self.max_depth_items = 1
   60: 
   61:     def __getitem__(self, key):
   62:         return self.__store[key]
   63: 
   64:     def __setitem__(self, key, value):
   65:         if not isinstance(key, dns.name.Name):
   66:             raise ValueError("NameDict key must be a name")
   67:         self.__store[key] = value
   68:         self.__update_max_depth(key)
   69: 
   70:     def __delitem__(self, key):
   71:         self.__store.pop(key)
   72:         if len(key) == self.max_depth:
   73:             self.max_depth_items = self.max_depth_items - 1
   74:         if self.max_depth_items == 0:
   75:             self.max_depth = 0
   76:             for k in self.__store:
   77:                 self.__update_max_depth(k)
   78: 
   79:     def __iter__(self):
   80:         return iter(self.__store)
   81: 
   82:     def __len__(self):
   83:         return len(self.__store)
   84: 
   85:     def has_key(self, key):
   86:         return key in self.__store
   87: 
   88:     def get_deepest_match(self, name):
   89:         """Find the deepest match to *name* in the dictionary.
   90: 
   91:         The deepest match is the longest name in the dictionary which is
   92:         a superdomain of *name*.  Note that *superdomain* includes matching
   93:         *name* itself.
   94: 
   95:         *name*, a ``dns.name.Name``, the name to find.
   96: 
   97:         Returns a ``(key, value)`` where *key* is the deepest
   98:         ``dns.name.Name``, and *value* is the value associated with *key*.
   99:         """
  100: 
  101:         depth = len(name)
  102:         if depth > self.max_depth:
  103:             depth = self.max_depth
  104:         for i in range(-depth, 0):
  105:             n = dns.name.Name(name[i:])
  106:             if n in self:
  107:                 return (n, self[n])
  108:         v = self[dns.name.empty]
  109:         return (dns.name.empty, v)
