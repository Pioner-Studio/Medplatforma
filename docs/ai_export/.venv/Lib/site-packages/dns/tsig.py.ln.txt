    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: """DNS TSIG support."""
   19: 
   20: import base64
   21: import hashlib
   22: import hmac
   23: import struct
   24: 
   25: import dns.exception
   26: import dns.name
   27: import dns.rcode
   28: import dns.rdataclass
   29: 
   30: 
   31: class BadTime(dns.exception.DNSException):
   32:     """The current time is not within the TSIG's validity time."""
   33: 
   34: 
   35: class BadSignature(dns.exception.DNSException):
   36:     """The TSIG signature fails to verify."""
   37: 
   38: 
   39: class BadKey(dns.exception.DNSException):
   40:     """The TSIG record owner name does not match the key."""
   41: 
   42: 
   43: class BadAlgorithm(dns.exception.DNSException):
   44:     """The TSIG algorithm does not match the key."""
   45: 
   46: 
   47: class PeerError(dns.exception.DNSException):
   48:     """Base class for all TSIG errors generated by the remote peer"""
   49: 
   50: 
   51: class PeerBadKey(PeerError):
   52:     """The peer didn't know the key we used"""
   53: 
   54: 
   55: class PeerBadSignature(PeerError):
   56:     """The peer didn't like the signature we sent"""
   57: 
   58: 
   59: class PeerBadTime(PeerError):
   60:     """The peer didn't like the time we sent"""
   61: 
   62: 
   63: class PeerBadTruncation(PeerError):
   64:     """The peer didn't like amount of truncation in the TSIG we sent"""
   65: 
   66: 
   67: # TSIG Algorithms
   68: 
   69: HMAC_MD5 = dns.name.from_text("HMAC-MD5.SIG-ALG.REG.INT")
   70: HMAC_SHA1 = dns.name.from_text("hmac-sha1")
   71: HMAC_SHA224 = dns.name.from_text("hmac-sha224")
   72: HMAC_SHA256 = dns.name.from_text("hmac-sha256")
   73: HMAC_SHA256_128 = dns.name.from_text("hmac-sha256-128")
   74: HMAC_SHA384 = dns.name.from_text("hmac-sha384")
   75: HMAC_SHA384_192 = dns.name.from_text("hmac-sha384-192")
   76: HMAC_SHA512 = dns.name.from_text("hmac-sha512")
   77: HMAC_SHA512_256 = dns.name.from_text("hmac-sha512-256")
   78: GSS_TSIG = dns.name.from_text("gss-tsig")
   79: 
   80: default_algorithm = HMAC_SHA256
   81: 
   82: mac_sizes = {
   83:     HMAC_SHA1: 20,
   84:     HMAC_SHA224: 28,
   85:     HMAC_SHA256: 32,
   86:     HMAC_SHA256_128: 16,
   87:     HMAC_SHA384: 48,
   88:     HMAC_SHA384_192: 24,
   89:     HMAC_SHA512: 64,
   90:     HMAC_SHA512_256: 32,
   91:     HMAC_MD5: 16,
   92:     GSS_TSIG: 128,  # This is what we assume to be the worst case!
   93: }
   94: 
   95: 
   96: class GSSTSig:
   97:     """
   98:     GSS-TSIG TSIG implementation.  This uses the GSS-API context established
   99:     in the TKEY message handshake to sign messages using GSS-API message
  100:     integrity codes, per the RFC.
  101: 
  102:     In order to avoid a direct GSSAPI dependency, the keyring holds a ref
  103:     to the GSSAPI object required, rather than the key itself.
  104:     """
  105: 
  106:     def __init__(self, gssapi_context):
  107:         self.gssapi_context = gssapi_context
  108:         self.data = b""
  109:         self.name = "gss-tsig"
  110: 
  111:     def update(self, data):
  112:         self.data += data
  113: 
  114:     def sign(self):
  115:         # defer to the GSSAPI function to sign
  116:         return self.gssapi_context.get_signature(self.data)
  117: 
  118:     def verify(self, expected):
  119:         try:
  120:             # defer to the GSSAPI function to verify
  121:             return self.gssapi_context.verify_signature(self.data, expected)
  122:         except Exception:
  123:             # note the usage of a bare exception
  124:             raise BadSignature
  125: 
  126: 
  127: class GSSTSigAdapter:
  128:     def __init__(self, keyring):
  129:         self.keyring = keyring
  130: 
  131:     def __call__(self, message, keyname):
  132:         if keyname in self.keyring:
  133:             key = self.keyring[keyname]
  134:             if isinstance(key, Key) and key.algorithm == GSS_TSIG:
  135:                 if message:
  136:                     GSSTSigAdapter.parse_tkey_and_step(key, message, keyname)
  137:             return key
  138:         else:
  139:             return None
  140: 
  141:     @classmethod
  142:     def parse_tkey_and_step(cls, key, message, keyname):
  143:         # if the message is a TKEY type, absorb the key material
  144:         # into the context using step(); this is used to allow the
  145:         # client to complete the GSSAPI negotiation before attempting
  146:         # to verify the signed response to a TKEY message exchange
  147:         try:
  148:             rrset = message.find_rrset(
  149:                 message.answer, keyname, dns.rdataclass.ANY, dns.rdatatype.TKEY
  150:             )
  151:             if rrset:
  152:                 token = rrset[0].key
  153:                 gssapi_context = key.secret
  154:                 return gssapi_context.step(token)
  155:         except KeyError:
  156:             pass
  157: 
  158: 
  159: class HMACTSig:
  160:     """
  161:     HMAC TSIG implementation.  This uses the HMAC python module to handle the
  162:     sign/verify operations.
  163:     """
  164: 
  165:     _hashes = {
  166:         HMAC_SHA1: hashlib.sha1,
  167:         HMAC_SHA224: hashlib.sha224,
  168:         HMAC_SHA256: hashlib.sha256,
  169:         HMAC_SHA256_128: (hashlib.sha256, 128),
  170:         HMAC_SHA384: hashlib.sha384,
  171:         HMAC_SHA384_192: (hashlib.sha384, 192),
  172:         HMAC_SHA512: hashlib.sha512,
  173:         HMAC_SHA512_256: (hashlib.sha512, 256),
  174:         HMAC_MD5: hashlib.md5,
  175:     }
  176: 
  177:     def __init__(self, key, algorithm):
  178:         try:
  179:             hashinfo = self._hashes[algorithm]
  180:         except KeyError:
  181:             raise NotImplementedError(f"TSIG algorithm {algorithm} is not supported")
  182: 
  183:         # create the HMAC context
  184:         if isinstance(hashinfo, tuple):
  185:             self.hmac_context = hmac.new(key, digestmod=hashinfo[0])
  186:             self.size = hashinfo[1]
  187:         else:
  188:             self.hmac_context = hmac.new(key, digestmod=hashinfo)
  189:             self.size = None
  190:         self.name = self.hmac_context.name
  191:         if self.size:
  192:             self.name += f"-{self.size}"
  193: 
  194:     def update(self, data):
  195:         return self.hmac_context.update(data)
  196: 
  197:     def sign(self):
  198:         # defer to the HMAC digest() function for that digestmod
  199:         digest = self.hmac_context.digest()
  200:         if self.size:
  201:             digest = digest[: (self.size // 8)]
  202:         return digest
  203: 
  204:     def verify(self, expected):
  205:         # re-digest and compare the results
  206:         mac = self.sign()
  207:         if not hmac.compare_digest(mac, expected):
  208:             raise BadSignature
  209: 
  210: 
  211: def _digest(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=None):
  212:     """Return a context containing the TSIG rdata for the input parameters
  213:     @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object
  214:     @raises ValueError: I{other_data} is too long
  215:     @raises NotImplementedError: I{algorithm} is not supported
  216:     """
  217: 
  218:     first = not (ctx and multi)
  219:     if first:
  220:         ctx = get_context(key)
  221:         if request_mac:
  222:             ctx.update(struct.pack("!H", len(request_mac)))
  223:             ctx.update(request_mac)
  224:     ctx.update(struct.pack("!H", rdata.original_id))
  225:     ctx.update(wire[2:])
  226:     if first:
  227:         ctx.update(key.name.to_digestable())
  228:         ctx.update(struct.pack("!H", dns.rdataclass.ANY))
  229:         ctx.update(struct.pack("!I", 0))
  230:     if time is None:
  231:         time = rdata.time_signed
  232:     upper_time = (time >> 32) & 0xFFFF
  233:     lower_time = time & 0xFFFFFFFF
  234:     time_encoded = struct.pack("!HIH", upper_time, lower_time, rdata.fudge)
  235:     other_len = len(rdata.other)
  236:     if other_len > 65535:
  237:         raise ValueError("TSIG Other Data is > 65535 bytes")
  238:     if first:
  239:         ctx.update(key.algorithm.to_digestable() + time_encoded)
  240:         ctx.update(struct.pack("!HH", rdata.error, other_len) + rdata.other)
  241:     else:
  242:         ctx.update(time_encoded)
  243:     return ctx
  244: 
  245: 
  246: def _maybe_start_digest(key, mac, multi):
  247:     """If this is the first message in a multi-message sequence,
  248:     start a new context.
  249:     @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object
  250:     """
  251:     if multi:
  252:         ctx = get_context(key)
  253:         ctx.update(struct.pack("!H", len(mac)))
  254:         ctx.update(mac)
  255:         return ctx
  256:     else:
  257:         return None
  258: 
  259: 
  260: def sign(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=False):
  261:     """Return a (tsig_rdata, mac, ctx) tuple containing the HMAC TSIG rdata
  262:     for the input parameters, the HMAC MAC calculated by applying the
  263:     TSIG signature algorithm, and the TSIG digest context.
  264:     @rtype: (string, dns.tsig.HMACTSig or dns.tsig.GSSTSig object)
  265:     @raises ValueError: I{other_data} is too long
  266:     @raises NotImplementedError: I{algorithm} is not supported
  267:     """
  268: 
  269:     ctx = _digest(wire, key, rdata, time, request_mac, ctx, multi)
  270:     mac = ctx.sign()
  271:     tsig = rdata.replace(time_signed=time, mac=mac)
  272: 
  273:     return (tsig, _maybe_start_digest(key, mac, multi))
  274: 
  275: 
  276: def validate(
  277:     wire, key, owner, rdata, now, request_mac, tsig_start, ctx=None, multi=False
  278: ):
  279:     """Validate the specified TSIG rdata against the other input parameters.
  280: 
  281:     @raises FormError: The TSIG is badly formed.
  282:     @raises BadTime: There is too much time skew between the client and the
  283:     server.
  284:     @raises BadSignature: The TSIG signature did not validate
  285:     @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object"""
  286: 
  287:     (adcount,) = struct.unpack("!H", wire[10:12])
  288:     if adcount == 0:
  289:         raise dns.exception.FormError
  290:     adcount -= 1
  291:     new_wire = wire[0:10] + struct.pack("!H", adcount) + wire[12:tsig_start]
  292:     if rdata.error != 0:
  293:         if rdata.error == dns.rcode.BADSIG:
  294:             raise PeerBadSignature
  295:         elif rdata.error == dns.rcode.BADKEY:
  296:             raise PeerBadKey
  297:         elif rdata.error == dns.rcode.BADTIME:
  298:             raise PeerBadTime
  299:         elif rdata.error == dns.rcode.BADTRUNC:
  300:             raise PeerBadTruncation
  301:         else:
  302:             raise PeerError("unknown TSIG error code %d" % rdata.error)
  303:     if abs(rdata.time_signed - now) > rdata.fudge:
  304:         raise BadTime
  305:     if key.name != owner:
  306:         raise BadKey
  307:     if key.algorithm != rdata.algorithm:
  308:         raise BadAlgorithm
  309:     ctx = _digest(new_wire, key, rdata, None, request_mac, ctx, multi)
  310:     ctx.verify(rdata.mac)
  311:     return _maybe_start_digest(key, rdata.mac, multi)
  312: 
  313: 
  314: def get_context(key):
  315:     """Returns an HMAC context for the specified key.
  316: 
  317:     @rtype: HMAC context
  318:     @raises NotImplementedError: I{algorithm} is not supported
  319:     """
  320: 
  321:     if key.algorithm == GSS_TSIG:
  322:         return GSSTSig(key.secret)
  323:     else:
  324:         return HMACTSig(key.secret, key.algorithm)
  325: 
  326: 
  327: class Key:
  328:     def __init__(self, name, secret, algorithm=default_algorithm):
  329:         if isinstance(name, str):
  330:             name = dns.name.from_text(name)
  331:         self.name = name
  332:         if isinstance(secret, str):
  333:             secret = base64.decodebytes(secret.encode())
  334:         self.secret = secret
  335:         if isinstance(algorithm, str):
  336:             algorithm = dns.name.from_text(algorithm)
  337:         self.algorithm = algorithm
  338: 
  339:     def __eq__(self, other):
  340:         return (
  341:             isinstance(other, Key)
  342:             and self.name == other.name
  343:             and self.secret == other.secret
  344:             and self.algorithm == other.algorithm
  345:         )
  346: 
  347:     def __repr__(self):
  348:         r = f"<DNS key name='{self.name}', " + f"algorithm='{self.algorithm}'"
  349:         if self.algorithm != GSS_TSIG:
  350:             r += f", secret='{base64.b64encode(self.secret).decode()}'"
  351:         r += ">"
  352:         return r
