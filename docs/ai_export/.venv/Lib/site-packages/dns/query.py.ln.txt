    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2017 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: """Talk to a DNS server."""
   19: 
   20: import base64
   21: import contextlib
   22: import enum
   23: import errno
   24: import os
   25: import os.path
   26: import selectors
   27: import socket
   28: import struct
   29: import time
   30: from typing import Any, Dict, Optional, Tuple, Union
   31: 
   32: import dns._features
   33: import dns.exception
   34: import dns.inet
   35: import dns.message
   36: import dns.name
   37: import dns.quic
   38: import dns.rcode
   39: import dns.rdataclass
   40: import dns.rdatatype
   41: import dns.serial
   42: import dns.transaction
   43: import dns.tsig
   44: import dns.xfr
   45: 
   46: 
   47: def _remaining(expiration):
   48:     if expiration is None:
   49:         return None
   50:     timeout = expiration - time.time()
   51:     if timeout <= 0.0:
   52:         raise dns.exception.Timeout
   53:     return timeout
   54: 
   55: 
   56: def _expiration_for_this_attempt(timeout, expiration):
   57:     if expiration is None:
   58:         return None
   59:     return min(time.time() + timeout, expiration)
   60: 
   61: 
   62: _have_httpx = dns._features.have("doh")
   63: if _have_httpx:
   64:     import httpcore._backends.sync
   65:     import httpx
   66: 
   67:     _CoreNetworkBackend = httpcore.NetworkBackend
   68:     _CoreSyncStream = httpcore._backends.sync.SyncStream
   69: 
   70:     class _NetworkBackend(_CoreNetworkBackend):
   71:         def __init__(self, resolver, local_port, bootstrap_address, family):
   72:             super().__init__()
   73:             self._local_port = local_port
   74:             self._resolver = resolver
   75:             self._bootstrap_address = bootstrap_address
   76:             self._family = family
   77: 
   78:         def connect_tcp(
   79:             self, host, port, timeout, local_address, socket_options=None
   80:         ):  # pylint: disable=signature-differs
   81:             addresses = []
   82:             _, expiration = _compute_times(timeout)
   83:             if dns.inet.is_address(host):
   84:                 addresses.append(host)
   85:             elif self._bootstrap_address is not None:
   86:                 addresses.append(self._bootstrap_address)
   87:             else:
   88:                 timeout = _remaining(expiration)
   89:                 family = self._family
   90:                 if local_address:
   91:                     family = dns.inet.af_for_address(local_address)
   92:                 answers = self._resolver.resolve_name(
   93:                     host, family=family, lifetime=timeout
   94:                 )
   95:                 addresses = answers.addresses()
   96:             for address in addresses:
   97:                 af = dns.inet.af_for_address(address)
   98:                 if local_address is not None or self._local_port != 0:
   99:                     source = dns.inet.low_level_address_tuple(
  100:                         (local_address, self._local_port), af
  101:                     )
  102:                 else:
  103:                     source = None
  104:                 sock = _make_socket(af, socket.SOCK_STREAM, source)
  105:                 attempt_expiration = _expiration_for_this_attempt(2.0, expiration)
  106:                 try:
  107:                     _connect(
  108:                         sock,
  109:                         dns.inet.low_level_address_tuple((address, port), af),
  110:                         attempt_expiration,
  111:                     )
  112:                     return _CoreSyncStream(sock)
  113:                 except Exception:
  114:                     pass
  115:             raise httpcore.ConnectError
  116: 
  117:         def connect_unix_socket(
  118:             self, path, timeout, socket_options=None
  119:         ):  # pylint: disable=signature-differs
  120:             raise NotImplementedError
  121: 
  122:     class _HTTPTransport(httpx.HTTPTransport):
  123:         def __init__(
  124:             self,
  125:             *args,
  126:             local_port=0,
  127:             bootstrap_address=None,
  128:             resolver=None,
  129:             family=socket.AF_UNSPEC,
  130:             **kwargs,
  131:         ):
  132:             if resolver is None:
  133:                 # pylint: disable=import-outside-toplevel,redefined-outer-name
  134:                 import dns.resolver
  135: 
  136:                 resolver = dns.resolver.Resolver()
  137:             super().__init__(*args, **kwargs)
  138:             self._pool._network_backend = _NetworkBackend(
  139:                 resolver, local_port, bootstrap_address, family
  140:             )
  141: 
  142: else:
  143: 
  144:     class _HTTPTransport:  # type: ignore
  145:         def connect_tcp(self, host, port, timeout, local_address):
  146:             raise NotImplementedError
  147: 
  148: 
  149: have_doh = _have_httpx
  150: 
  151: try:
  152:     import ssl
  153: except ImportError:  # pragma: no cover
  154: 
  155:     class ssl:  # type: ignore
  156:         CERT_NONE = 0
  157: 
  158:         class WantReadException(Exception):
  159:             pass
  160: 
  161:         class WantWriteException(Exception):
  162:             pass
  163: 
  164:         class SSLContext:
  165:             pass
  166: 
  167:         class SSLSocket:
  168:             pass
  169: 
  170:         @classmethod
  171:         def create_default_context(cls, *args, **kwargs):
  172:             raise Exception("no ssl support")  # pylint: disable=broad-exception-raised
  173: 
  174: 
  175: # Function used to create a socket.  Can be overridden if needed in special
  176: # situations.
  177: socket_factory = socket.socket
  178: 
  179: 
  180: class UnexpectedSource(dns.exception.DNSException):
  181:     """A DNS query response came from an unexpected address or port."""
  182: 
  183: 
  184: class BadResponse(dns.exception.FormError):
  185:     """A DNS query response does not respond to the question asked."""
  186: 
  187: 
  188: class NoDOH(dns.exception.DNSException):
  189:     """DNS over HTTPS (DOH) was requested but the httpx module is not
  190:     available."""
  191: 
  192: 
  193: class NoDOQ(dns.exception.DNSException):
  194:     """DNS over QUIC (DOQ) was requested but the aioquic module is not
  195:     available."""
  196: 
  197: 
  198: # for backwards compatibility
  199: TransferError = dns.xfr.TransferError
  200: 
  201: 
  202: def _compute_times(timeout):
  203:     now = time.time()
  204:     if timeout is None:
  205:         return (now, None)
  206:     else:
  207:         return (now, now + timeout)
  208: 
  209: 
  210: def _wait_for(fd, readable, writable, _, expiration):
  211:     # Use the selected selector class to wait for any of the specified
  212:     # events.  An "expiration" absolute time is converted into a relative
  213:     # timeout.
  214:     #
  215:     # The unused parameter is 'error', which is always set when
  216:     # selecting for read or write, and we have no error-only selects.
  217: 
  218:     if readable and isinstance(fd, ssl.SSLSocket) and fd.pending() > 0:
  219:         return True
  220:     sel = _selector_class()
  221:     events = 0
  222:     if readable:
  223:         events |= selectors.EVENT_READ
  224:     if writable:
  225:         events |= selectors.EVENT_WRITE
  226:     if events:
  227:         sel.register(fd, events)
  228:     if expiration is None:
  229:         timeout = None
  230:     else:
  231:         timeout = expiration - time.time()
  232:         if timeout <= 0.0:
  233:             raise dns.exception.Timeout
  234:     if not sel.select(timeout):
  235:         raise dns.exception.Timeout
  236: 
  237: 
  238: def _set_selector_class(selector_class):
  239:     # Internal API. Do not use.
  240: 
  241:     global _selector_class
  242: 
  243:     _selector_class = selector_class
  244: 
  245: 
  246: if hasattr(selectors, "PollSelector"):
  247:     # Prefer poll() on platforms that support it because it has no
  248:     # limits on the maximum value of a file descriptor (plus it will
  249:     # be more efficient for high values).
  250:     #
  251:     # We ignore typing here as we can't say _selector_class is Any
  252:     # on python < 3.8 due to a bug.
  253:     _selector_class = selectors.PollSelector  # type: ignore
  254: else:
  255:     _selector_class = selectors.SelectSelector  # type: ignore
  256: 
  257: 
  258: def _wait_for_readable(s, expiration):
  259:     _wait_for(s, True, False, True, expiration)
  260: 
  261: 
  262: def _wait_for_writable(s, expiration):
  263:     _wait_for(s, False, True, True, expiration)
  264: 
  265: 
  266: def _addresses_equal(af, a1, a2):
  267:     # Convert the first value of the tuple, which is a textual format
  268:     # address into binary form, so that we are not confused by different
  269:     # textual representations of the same address
  270:     try:
  271:         n1 = dns.inet.inet_pton(af, a1[0])
  272:         n2 = dns.inet.inet_pton(af, a2[0])
  273:     except dns.exception.SyntaxError:
  274:         return False
  275:     return n1 == n2 and a1[1:] == a2[1:]
  276: 
  277: 
  278: def _matches_destination(af, from_address, destination, ignore_unexpected):
  279:     # Check that from_address is appropriate for a response to a query
  280:     # sent to destination.
  281:     if not destination:
  282:         return True
  283:     if _addresses_equal(af, from_address, destination) or (
  284:         dns.inet.is_multicast(destination[0]) and from_address[1:] == destination[1:]
  285:     ):
  286:         return True
  287:     elif ignore_unexpected:
  288:         return False
  289:     raise UnexpectedSource(
  290:         f"got a response from {from_address} instead of " f"{destination}"
  291:     )
  292: 
  293: 
  294: def _destination_and_source(
  295:     where, port, source, source_port, where_must_be_address=True
  296: ):
  297:     # Apply defaults and compute destination and source tuples
  298:     # suitable for use in connect(), sendto(), or bind().
  299:     af = None
  300:     destination = None
  301:     try:
  302:         af = dns.inet.af_for_address(where)
  303:         destination = where
  304:     except Exception:
  305:         if where_must_be_address:
  306:             raise
  307:         # URLs are ok so eat the exception
  308:     if source:
  309:         saf = dns.inet.af_for_address(source)
  310:         if af:
  311:             # We know the destination af, so source had better agree!
  312:             if saf != af:
  313:                 raise ValueError(
  314:                     "different address families for source and destination"
  315:                 )
  316:         else:
  317:             # We didn't know the destination af, but we know the source,
  318:             # so that's our af.
  319:             af = saf
  320:     if source_port and not source:
  321:         # Caller has specified a source_port but not an address, so we
  322:         # need to return a source, and we need to use the appropriate
  323:         # wildcard address as the address.
  324:         try:
  325:             source = dns.inet.any_for_af(af)
  326:         except Exception:
  327:             # we catch this and raise ValueError for backwards compatibility
  328:             raise ValueError("source_port specified but address family is unknown")
  329:     # Convert high-level (address, port) tuples into low-level address
  330:     # tuples.
  331:     if destination:
  332:         destination = dns.inet.low_level_address_tuple((destination, port), af)
  333:     if source:
  334:         source = dns.inet.low_level_address_tuple((source, source_port), af)
  335:     return (af, destination, source)
  336: 
  337: 
  338: def _make_socket(af, type, source, ssl_context=None, server_hostname=None):
  339:     s = socket_factory(af, type)
  340:     try:
  341:         s.setblocking(False)
  342:         if source is not None:
  343:             s.bind(source)
  344:         if ssl_context:
  345:             # LGTM gets a false positive here, as our default context is OK
  346:             return ssl_context.wrap_socket(
  347:                 s,
  348:                 do_handshake_on_connect=False,  # lgtm[py/insecure-protocol]
  349:                 server_hostname=server_hostname,
  350:             )
  351:         else:
  352:             return s
  353:     except Exception:
  354:         s.close()
  355:         raise
  356: 
  357: 
  358: def https(
  359:     q: dns.message.Message,
  360:     where: str,
  361:     timeout: Optional[float] = None,
  362:     port: int = 443,
  363:     source: Optional[str] = None,
  364:     source_port: int = 0,
  365:     one_rr_per_rrset: bool = False,
  366:     ignore_trailing: bool = False,
  367:     session: Optional[Any] = None,
  368:     path: str = "/dns-query",
  369:     post: bool = True,
  370:     bootstrap_address: Optional[str] = None,
  371:     verify: Union[bool, str] = True,
  372:     resolver: Optional["dns.resolver.Resolver"] = None,
  373:     family: Optional[int] = socket.AF_UNSPEC,
  374: ) -> dns.message.Message:
  375:     """Return the response obtained after sending a query via DNS-over-HTTPS.
  376: 
  377:     *q*, a ``dns.message.Message``, the query to send.
  378: 
  379:     *where*, a ``str``, the nameserver IP address or the full URL. If an IP address is
  380:     given, the URL will be constructed using the following schema:
  381:     https://<IP-address>:<port>/<path>.
  382: 
  383:     *timeout*, a ``float`` or ``None``, the number of seconds to wait before the query
  384:     times out. If ``None``, the default, wait forever.
  385: 
  386:     *port*, a ``int``, the port to send the query to. The default is 443.
  387: 
  388:     *source*, a ``str`` containing an IPv4 or IPv6 address, specifying the source
  389:     address.  The default is the wildcard address.
  390: 
  391:     *source_port*, an ``int``, the port from which to send the message. The default is
  392:     0.
  393: 
  394:     *one_rr_per_rrset*, a ``bool``. If ``True``, put each RR into its own RRset.
  395: 
  396:     *ignore_trailing*, a ``bool``. If ``True``, ignore trailing junk at end of the
  397:     received message.
  398: 
  399:     *session*, an ``httpx.Client``.  If provided, the client session to use to send the
  400:     queries.
  401: 
  402:     *path*, a ``str``. If *where* is an IP address, then *path* will be used to
  403:     construct the URL to send the DNS query to.
  404: 
  405:     *post*, a ``bool``. If ``True``, the default, POST method will be used.
  406: 
  407:     *bootstrap_address*, a ``str``, the IP address to use to bypass resolution.
  408: 
  409:     *verify*, a ``bool`` or ``str``.  If a ``True``, then TLS certificate verification
  410:     of the server is done using the default CA bundle; if ``False``, then no
  411:     verification is done; if a `str` then it specifies the path to a certificate file or
  412:     directory which will be used for verification.
  413: 
  414:     *resolver*, a ``dns.resolver.Resolver`` or ``None``, the resolver to use for
  415:     resolution of hostnames in URLs.  If not specified, a new resolver with a default
  416:     configuration will be used; note this is *not* the default resolver as that resolver
  417:     might have been configured to use DoH causing a chicken-and-egg problem.  This
  418:     parameter only has an effect if the HTTP library is httpx.
  419: 
  420:     *family*, an ``int``, the address family.  If socket.AF_UNSPEC (the default), both A
  421:     and AAAA records will be retrieved.
  422: 
  423:     Returns a ``dns.message.Message``.
  424:     """
  425: 
  426:     if not have_doh:
  427:         raise NoDOH  # pragma: no cover
  428:     if session and not isinstance(session, httpx.Client):
  429:         raise ValueError("session parameter must be an httpx.Client")
  430: 
  431:     wire = q.to_wire()
  432:     (af, _, the_source) = _destination_and_source(
  433:         where, port, source, source_port, False
  434:     )
  435:     transport = None
  436:     headers = {"accept": "application/dns-message"}
  437:     if af is not None and dns.inet.is_address(where):
  438:         if af == socket.AF_INET:
  439:             url = "https://{}:{}{}".format(where, port, path)
  440:         elif af == socket.AF_INET6:
  441:             url = "https://[{}]:{}{}".format(where, port, path)
  442:     else:
  443:         url = where
  444: 
  445:     # set source port and source address
  446: 
  447:     if the_source is None:
  448:         local_address = None
  449:         local_port = 0
  450:     else:
  451:         local_address = the_source[0]
  452:         local_port = the_source[1]
  453:     transport = _HTTPTransport(
  454:         local_address=local_address,
  455:         http1=True,
  456:         http2=True,
  457:         verify=verify,
  458:         local_port=local_port,
  459:         bootstrap_address=bootstrap_address,
  460:         resolver=resolver,
  461:         family=family,
  462:     )
  463: 
  464:     if session:
  465:         cm: contextlib.AbstractContextManager = contextlib.nullcontext(session)
  466:     else:
  467:         cm = httpx.Client(http1=True, http2=True, verify=verify, transport=transport)
  468:     with cm as session:
  469:         # see https://tools.ietf.org/html/rfc8484#section-4.1.1 for DoH
  470:         # GET and POST examples
  471:         if post:
  472:             headers.update(
  473:                 {
  474:                     "content-type": "application/dns-message",
  475:                     "content-length": str(len(wire)),
  476:                 }
  477:             )
  478:             response = session.post(url, headers=headers, content=wire, timeout=timeout)
  479:         else:
  480:             wire = base64.urlsafe_b64encode(wire).rstrip(b"=")
  481:             twire = wire.decode()  # httpx does a repr() if we give it bytes
  482:             response = session.get(
  483:                 url, headers=headers, timeout=timeout, params={"dns": twire}
  484:             )
  485: 
  486:     # see https://tools.ietf.org/html/rfc8484#section-4.2.1 for info about DoH
  487:     # status codes
  488:     if response.status_code < 200 or response.status_code > 299:
  489:         raise ValueError(
  490:             "{} responded with status code {}"
  491:             "\nResponse body: {}".format(where, response.status_code, response.content)
  492:         )
  493:     r = dns.message.from_wire(
  494:         response.content,
  495:         keyring=q.keyring,
  496:         request_mac=q.request_mac,
  497:         one_rr_per_rrset=one_rr_per_rrset,
  498:         ignore_trailing=ignore_trailing,
  499:     )
  500:     r.time = response.elapsed.total_seconds()
  501:     if not q.is_response(r):
  502:         raise BadResponse
  503:     return r
  504: 
  505: 
  506: def _udp_recv(sock, max_size, expiration):
  507:     """Reads a datagram from the socket.
  508:     A Timeout exception will be raised if the operation is not completed
  509:     by the expiration time.
  510:     """
  511:     while True:
  512:         try:
  513:             return sock.recvfrom(max_size)
  514:         except BlockingIOError:
  515:             _wait_for_readable(sock, expiration)
  516: 
  517: 
  518: def _udp_send(sock, data, destination, expiration):
  519:     """Sends the specified datagram to destination over the socket.
  520:     A Timeout exception will be raised if the operation is not completed
  521:     by the expiration time.
  522:     """
  523:     while True:
  524:         try:
  525:             if destination:
  526:                 return sock.sendto(data, destination)
  527:             else:
  528:                 return sock.send(data)
  529:         except BlockingIOError:  # pragma: no cover
  530:             _wait_for_writable(sock, expiration)
  531: 
  532: 
  533: def send_udp(
  534:     sock: Any,
  535:     what: Union[dns.message.Message, bytes],
  536:     destination: Any,
  537:     expiration: Optional[float] = None,
  538: ) -> Tuple[int, float]:
  539:     """Send a DNS message to the specified UDP socket.
  540: 
  541:     *sock*, a ``socket``.
  542: 
  543:     *what*, a ``bytes`` or ``dns.message.Message``, the message to send.
  544: 
  545:     *destination*, a destination tuple appropriate for the address family
  546:     of the socket, specifying where to send the query.
  547: 
  548:     *expiration*, a ``float`` or ``None``, the absolute time at which
  549:     a timeout exception should be raised.  If ``None``, no timeout will
  550:     occur.
  551: 
  552:     Returns an ``(int, float)`` tuple of bytes sent and the sent time.
  553:     """
  554: 
  555:     if isinstance(what, dns.message.Message):
  556:         what = what.to_wire()
  557:     sent_time = time.time()
  558:     n = _udp_send(sock, what, destination, expiration)
  559:     return (n, sent_time)
  560: 
  561: 
  562: def receive_udp(
  563:     sock: Any,
  564:     destination: Optional[Any] = None,
  565:     expiration: Optional[float] = None,
  566:     ignore_unexpected: bool = False,
  567:     one_rr_per_rrset: bool = False,
  568:     keyring: Optional[Dict[dns.name.Name, dns.tsig.Key]] = None,
  569:     request_mac: Optional[bytes] = b"",
  570:     ignore_trailing: bool = False,
  571:     raise_on_truncation: bool = False,
  572:     ignore_errors: bool = False,
  573:     query: Optional[dns.message.Message] = None,
  574: ) -> Any:
  575:     """Read a DNS message from a UDP socket.
  576: 
  577:     *sock*, a ``socket``.
  578: 
  579:     *destination*, a destination tuple appropriate for the address family
  580:     of the socket, specifying where the message is expected to arrive from.
  581:     When receiving a response, this would be where the associated query was
  582:     sent.
  583: 
  584:     *expiration*, a ``float`` or ``None``, the absolute time at which
  585:     a timeout exception should be raised.  If ``None``, no timeout will
  586:     occur.
  587: 
  588:     *ignore_unexpected*, a ``bool``.  If ``True``, ignore responses from
  589:     unexpected sources.
  590: 
  591:     *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its own
  592:     RRset.
  593: 
  594:     *keyring*, a ``dict``, the keyring to use for TSIG.
  595: 
  596:     *request_mac*, a ``bytes`` or ``None``, the MAC of the request (for TSIG).
  597: 
  598:     *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing
  599:     junk at end of the received message.
  600: 
  601:     *raise_on_truncation*, a ``bool``.  If ``True``, raise an exception if
  602:     the TC bit is set.
  603: 
  604:     Raises if the message is malformed, if network errors occur, of if
  605:     there is a timeout.
  606: 
  607:     If *destination* is not ``None``, returns a ``(dns.message.Message, float)``
  608:     tuple of the received message and the received time.
  609: 
  610:     If *destination* is ``None``, returns a
  611:     ``(dns.message.Message, float, tuple)``
  612:     tuple of the received message, the received time, and the address where
  613:     the message arrived from.
  614: 
  615:     *ignore_errors*, a ``bool``.  If various format errors or response
  616:     mismatches occur, ignore them and keep listening for a valid response.
  617:     The default is ``False``.
  618: 
  619:     *query*, a ``dns.message.Message`` or ``None``.  If not ``None`` and
  620:     *ignore_errors* is ``True``, check that the received message is a response
  621:     to this query, and if not keep listening for a valid response.
  622:     """
  623: 
  624:     wire = b""
  625:     while True:
  626:         (wire, from_address) = _udp_recv(sock, 65535, expiration)
  627:         if not _matches_destination(
  628:             sock.family, from_address, destination, ignore_unexpected
  629:         ):
  630:             continue
  631:         received_time = time.time()
  632:         try:
  633:             r = dns.message.from_wire(
  634:                 wire,
  635:                 keyring=keyring,
  636:                 request_mac=request_mac,
  637:                 one_rr_per_rrset=one_rr_per_rrset,
  638:                 ignore_trailing=ignore_trailing,
  639:                 raise_on_truncation=raise_on_truncation,
  640:             )
  641:         except dns.message.Truncated as e:
  642:             # If we got Truncated and not FORMERR, we at least got the header with TC
  643:             # set, and very likely the question section, so we'll re-raise if the
  644:             # message seems to be a response as we need to know when truncation happens.
  645:             # We need to check that it seems to be a response as we don't want a random
  646:             # injected message with TC set to cause us to bail out.
  647:             if (
  648:                 ignore_errors
  649:                 and query is not None
  650:                 and not query.is_response(e.message())
  651:             ):
  652:                 continue
  653:             else:
  654:                 raise
  655:         except Exception:
  656:             if ignore_errors:
  657:                 continue
  658:             else:
  659:                 raise
  660:         if ignore_errors and query is not None and not query.is_response(r):
  661:             continue
  662:         if destination:
  663:             return (r, received_time)
  664:         else:
  665:             return (r, received_time, from_address)
  666: 
  667: 
  668: def udp(
  669:     q: dns.message.Message,
  670:     where: str,
  671:     timeout: Optional[float] = None,
  672:     port: int = 53,
  673:     source: Optional[str] = None,
  674:     source_port: int = 0,
  675:     ignore_unexpected: bool = False,
  676:     one_rr_per_rrset: bool = False,
  677:     ignore_trailing: bool = False,
  678:     raise_on_truncation: bool = False,
  679:     sock: Optional[Any] = None,
  680:     ignore_errors: bool = False,
  681: ) -> dns.message.Message:
  682:     """Return the response obtained after sending a query via UDP.
  683: 
  684:     *q*, a ``dns.message.Message``, the query to send
  685: 
  686:     *where*, a ``str`` containing an IPv4 or IPv6 address,  where
  687:     to send the message.
  688: 
  689:     *timeout*, a ``float`` or ``None``, the number of seconds to wait before the
  690:     query times out.  If ``None``, the default, wait forever.
  691: 
  692:     *port*, an ``int``, the port send the message to.  The default is 53.
  693: 
  694:     *source*, a ``str`` containing an IPv4 or IPv6 address, specifying
  695:     the source address.  The default is the wildcard address.
  696: 
  697:     *source_port*, an ``int``, the port from which to send the message.
  698:     The default is 0.
  699: 
  700:     *ignore_unexpected*, a ``bool``.  If ``True``, ignore responses from
  701:     unexpected sources.
  702: 
  703:     *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its own
  704:     RRset.
  705: 
  706:     *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing
  707:     junk at end of the received message.
  708: 
  709:     *raise_on_truncation*, a ``bool``.  If ``True``, raise an exception if
  710:     the TC bit is set.
  711: 
  712:     *sock*, a ``socket.socket``, or ``None``, the socket to use for the
  713:     query.  If ``None``, the default, a socket is created.  Note that
  714:     if a socket is provided, it must be a nonblocking datagram socket,
  715:     and the *source* and *source_port* are ignored.
  716: 
  717:     *ignore_errors*, a ``bool``.  If various format errors or response
  718:     mismatches occur, ignore them and keep listening for a valid response.
  719:     The default is ``False``.
  720: 
  721:     Returns a ``dns.message.Message``.
  722:     """
  723: 
  724:     wire = q.to_wire()
  725:     (af, destination, source) = _destination_and_source(
  726:         where, port, source, source_port
  727:     )
  728:     (begin_time, expiration) = _compute_times(timeout)
  729:     if sock:
  730:         cm: contextlib.AbstractContextManager = contextlib.nullcontext(sock)
  731:     else:
  732:         cm = _make_socket(af, socket.SOCK_DGRAM, source)
  733:     with cm as s:
  734:         send_udp(s, wire, destination, expiration)
  735:         (r, received_time) = receive_udp(
  736:             s,
  737:             destination,
  738:             expiration,
  739:             ignore_unexpected,
  740:             one_rr_per_rrset,
  741:             q.keyring,
  742:             q.mac,
  743:             ignore_trailing,
  744:             raise_on_truncation,
  745:             ignore_errors,
  746:             q,
  747:         )
  748:         r.time = received_time - begin_time
  749:         # We don't need to check q.is_response() if we are in ignore_errors mode
  750:         # as receive_udp() will have checked it.
  751:         if not (ignore_errors or q.is_response(r)):
  752:             raise BadResponse
  753:         return r
  754:     assert (
  755:         False  # help mypy figure out we can't get here  lgtm[py/unreachable-statement]
  756:     )
  757: 
  758: 
  759: def udp_with_fallback(
  760:     q: dns.message.Message,
  761:     where: str,
  762:     timeout: Optional[float] = None,
  763:     port: int = 53,
  764:     source: Optional[str] = None,
  765:     source_port: int = 0,
  766:     ignore_unexpected: bool = False,
  767:     one_rr_per_rrset: bool = False,
  768:     ignore_trailing: bool = False,
  769:     udp_sock: Optional[Any] = None,
  770:     tcp_sock: Optional[Any] = None,
  771:     ignore_errors: bool = False,
  772: ) -> Tuple[dns.message.Message, bool]:
  773:     """Return the response to the query, trying UDP first and falling back
  774:     to TCP if UDP results in a truncated response.
  775: 
  776:     *q*, a ``dns.message.Message``, the query to send
  777: 
  778:     *where*, a ``str`` containing an IPv4 or IPv6 address,  where to send the message.
  779: 
  780:     *timeout*, a ``float`` or ``None``, the number of seconds to wait before the query
  781:     times out.  If ``None``, the default, wait forever.
  782: 
  783:     *port*, an ``int``, the port send the message to.  The default is 53.
  784: 
  785:     *source*, a ``str`` containing an IPv4 or IPv6 address, specifying the source
  786:     address.  The default is the wildcard address.
  787: 
  788:     *source_port*, an ``int``, the port from which to send the message. The default is
  789:     0.
  790: 
  791:     *ignore_unexpected*, a ``bool``.  If ``True``, ignore responses from unexpected
  792:     sources.
  793: 
  794:     *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its own RRset.
  795: 
  796:     *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing junk at end of the
  797:     received message.
  798: 
  799:     *udp_sock*, a ``socket.socket``, or ``None``, the socket to use for the UDP query.
  800:     If ``None``, the default, a socket is created.  Note that if a socket is provided,
  801:     it must be a nonblocking datagram socket, and the *source* and *source_port* are
  802:     ignored for the UDP query.
  803: 
  804:     *tcp_sock*, a ``socket.socket``, or ``None``, the connected socket to use for the
  805:     TCP query.  If ``None``, the default, a socket is created.  Note that if a socket is
  806:     provided, it must be a nonblocking connected stream socket, and *where*, *source*
  807:     and *source_port* are ignored for the TCP query.
  808: 
  809:     *ignore_errors*, a ``bool``.  If various format errors or response mismatches occur
  810:     while listening for UDP, ignore them and keep listening for a valid response. The
  811:     default is ``False``.
  812: 
  813:     Returns a (``dns.message.Message``, tcp) tuple where tcp is ``True`` if and only if
  814:     TCP was used.
  815:     """
  816:     try:
  817:         response = udp(
  818:             q,
  819:             where,
  820:             timeout,
  821:             port,
  822:             source,
  823:             source_port,
  824:             ignore_unexpected,
  825:             one_rr_per_rrset,
  826:             ignore_trailing,
  827:             True,
  828:             udp_sock,
  829:             ignore_errors,
  830:         )
  831:         return (response, False)
  832:     except dns.message.Truncated:
  833:         response = tcp(
  834:             q,
  835:             where,
  836:             timeout,
  837:             port,
  838:             source,
  839:             source_port,
  840:             one_rr_per_rrset,
  841:             ignore_trailing,
  842:             tcp_sock,
  843:         )
  844:         return (response, True)
  845: 
  846: 
  847: def _net_read(sock, count, expiration):
  848:     """Read the specified number of bytes from sock.  Keep trying until we
  849:     either get the desired amount, or we hit EOF.
  850:     A Timeout exception will be raised if the operation is not completed
  851:     by the expiration time.
  852:     """
  853:     s = b""
  854:     while count > 0:
  855:         try:
  856:             n = sock.recv(count)
  857:             if n == b"":
  858:                 raise EOFError
  859:             count -= len(n)
  860:             s += n
  861:         except (BlockingIOError, ssl.SSLWantReadError):
  862:             _wait_for_readable(sock, expiration)
  863:         except ssl.SSLWantWriteError:  # pragma: no cover
  864:             _wait_for_writable(sock, expiration)
  865:     return s
  866: 
  867: 
  868: def _net_write(sock, data, expiration):
  869:     """Write the specified data to the socket.
  870:     A Timeout exception will be raised if the operation is not completed
  871:     by the expiration time.
  872:     """
  873:     current = 0
  874:     l = len(data)
  875:     while current < l:
  876:         try:
  877:             current += sock.send(data[current:])
  878:         except (BlockingIOError, ssl.SSLWantWriteError):
  879:             _wait_for_writable(sock, expiration)
  880:         except ssl.SSLWantReadError:  # pragma: no cover
  881:             _wait_for_readable(sock, expiration)
  882: 
  883: 
  884: def send_tcp(
  885:     sock: Any,
  886:     what: Union[dns.message.Message, bytes],
  887:     expiration: Optional[float] = None,
  888: ) -> Tuple[int, float]:
  889:     """Send a DNS message to the specified TCP socket.
  890: 
  891:     *sock*, a ``socket``.
  892: 
  893:     *what*, a ``bytes`` or ``dns.message.Message``, the message to send.
  894: 
  895:     *expiration*, a ``float`` or ``None``, the absolute time at which
  896:     a timeout exception should be raised.  If ``None``, no timeout will
  897:     occur.
  898: 
  899:     Returns an ``(int, float)`` tuple of bytes sent and the sent time.
  900:     """
  901: 
  902:     if isinstance(what, dns.message.Message):
  903:         tcpmsg = what.to_wire(prepend_length=True)
  904:     else:
  905:         # copying the wire into tcpmsg is inefficient, but lets us
  906:         # avoid writev() or doing a short write that would get pushed
  907:         # onto the net
  908:         tcpmsg = len(what).to_bytes(2, "big") + what
  909:     sent_time = time.time()
  910:     _net_write(sock, tcpmsg, expiration)
  911:     return (len(tcpmsg), sent_time)
  912: 
  913: 
  914: def receive_tcp(
  915:     sock: Any,
  916:     expiration: Optional[float] = None,
  917:     one_rr_per_rrset: bool = False,
  918:     keyring: Optional[Dict[dns.name.Name, dns.tsig.Key]] = None,
  919:     request_mac: Optional[bytes] = b"",
  920:     ignore_trailing: bool = False,
  921: ) -> Tuple[dns.message.Message, float]:
  922:     """Read a DNS message from a TCP socket.
  923: 
  924:     *sock*, a ``socket``.
  925: 
  926:     *expiration*, a ``float`` or ``None``, the absolute time at which
  927:     a timeout exception should be raised.  If ``None``, no timeout will
  928:     occur.
  929: 
  930:     *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its own
  931:     RRset.
  932: 
  933:     *keyring*, a ``dict``, the keyring to use for TSIG.
  934: 
  935:     *request_mac*, a ``bytes`` or ``None``, the MAC of the request (for TSIG).
  936: 
  937:     *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing
  938:     junk at end of the received message.
  939: 
  940:     Raises if the message is malformed, if network errors occur, of if
  941:     there is a timeout.
  942: 
  943:     Returns a ``(dns.message.Message, float)`` tuple of the received message
  944:     and the received time.
  945:     """
  946: 
  947:     ldata = _net_read(sock, 2, expiration)
  948:     (l,) = struct.unpack("!H", ldata)
  949:     wire = _net_read(sock, l, expiration)
  950:     received_time = time.time()
  951:     r = dns.message.from_wire(
  952:         wire,
  953:         keyring=keyring,
  954:         request_mac=request_mac,
  955:         one_rr_per_rrset=one_rr_per_rrset,
  956:         ignore_trailing=ignore_trailing,
  957:     )
  958:     return (r, received_time)
  959: 
  960: 
  961: def _connect(s, address, expiration):
  962:     err = s.connect_ex(address)
  963:     if err == 0:
  964:         return
  965:     if err in (errno.EINPROGRESS, errno.EWOULDBLOCK, errno.EALREADY):
  966:         _wait_for_writable(s, expiration)
  967:         err = s.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
  968:     if err != 0:
  969:         raise OSError(err, os.strerror(err))
  970: 
  971: 
  972: def tcp(
  973:     q: dns.message.Message,
  974:     where: str,
  975:     timeout: Optional[float] = None,
  976:     port: int = 53,
  977:     source: Optional[str] = None,
  978:     source_port: int = 0,
  979:     one_rr_per_rrset: bool = False,
  980:     ignore_trailing: bool = False,
  981:     sock: Optional[Any] = None,
  982: ) -> dns.message.Message:
  983:     """Return the response obtained after sending a query via TCP.
  984: 
  985:     *q*, a ``dns.message.Message``, the query to send
  986: 
  987:     *where*, a ``str`` containing an IPv4 or IPv6 address, where
  988:     to send the message.
  989: 
  990:     *timeout*, a ``float`` or ``None``, the number of seconds to wait before the
  991:     query times out.  If ``None``, the default, wait forever.
  992: 
  993:     *port*, an ``int``, the port send the message to.  The default is 53.
  994: 
  995:     *source*, a ``str`` containing an IPv4 or IPv6 address, specifying
  996:     the source address.  The default is the wildcard address.
  997: 
  998:     *source_port*, an ``int``, the port from which to send the message.
  999:     The default is 0.
 1000: 
 1001:     *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its own
 1002:     RRset.
 1003: 
 1004:     *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing
 1005:     junk at end of the received message.
 1006: 
 1007:     *sock*, a ``socket.socket``, or ``None``, the connected socket to use for the
 1008:     query.  If ``None``, the default, a socket is created.  Note that
 1009:     if a socket is provided, it must be a nonblocking connected stream
 1010:     socket, and *where*, *port*, *source* and *source_port* are ignored.
 1011: 
 1012:     Returns a ``dns.message.Message``.
 1013:     """
 1014: 
 1015:     wire = q.to_wire()
 1016:     (begin_time, expiration) = _compute_times(timeout)
 1017:     if sock:
 1018:         cm: contextlib.AbstractContextManager = contextlib.nullcontext(sock)
 1019:     else:
 1020:         (af, destination, source) = _destination_and_source(
 1021:             where, port, source, source_port
 1022:         )
 1023:         cm = _make_socket(af, socket.SOCK_STREAM, source)
 1024:     with cm as s:
 1025:         if not sock:
 1026:             _connect(s, destination, expiration)
 1027:         send_tcp(s, wire, expiration)
 1028:         (r, received_time) = receive_tcp(
 1029:             s, expiration, one_rr_per_rrset, q.keyring, q.mac, ignore_trailing
 1030:         )
 1031:         r.time = received_time - begin_time
 1032:         if not q.is_response(r):
 1033:             raise BadResponse
 1034:         return r
 1035:     assert (
 1036:         False  # help mypy figure out we can't get here  lgtm[py/unreachable-statement]
 1037:     )
 1038: 
 1039: 
 1040: def _tls_handshake(s, expiration):
 1041:     while True:
 1042:         try:
 1043:             s.do_handshake()
 1044:             return
 1045:         except ssl.SSLWantReadError:
 1046:             _wait_for_readable(s, expiration)
 1047:         except ssl.SSLWantWriteError:  # pragma: no cover
 1048:             _wait_for_writable(s, expiration)
 1049: 
 1050: 
 1051: def _make_dot_ssl_context(
 1052:     server_hostname: Optional[str], verify: Union[bool, str]
 1053: ) -> ssl.SSLContext:
 1054:     cafile: Optional[str] = None
 1055:     capath: Optional[str] = None
 1056:     if isinstance(verify, str):
 1057:         if os.path.isfile(verify):
 1058:             cafile = verify
 1059:         elif os.path.isdir(verify):
 1060:             capath = verify
 1061:         else:
 1062:             raise ValueError("invalid verify string")
 1063:     ssl_context = ssl.create_default_context(cafile=cafile, capath=capath)
 1064:     ssl_context.minimum_version = ssl.TLSVersion.TLSv1_2
 1065:     if server_hostname is None:
 1066:         ssl_context.check_hostname = False
 1067:     ssl_context.set_alpn_protocols(["dot"])
 1068:     if verify is False:
 1069:         ssl_context.verify_mode = ssl.CERT_NONE
 1070:     return ssl_context
 1071: 
 1072: 
 1073: def tls(
 1074:     q: dns.message.Message,
 1075:     where: str,
 1076:     timeout: Optional[float] = None,
 1077:     port: int = 853,
 1078:     source: Optional[str] = None,
 1079:     source_port: int = 0,
 1080:     one_rr_per_rrset: bool = False,
 1081:     ignore_trailing: bool = False,
 1082:     sock: Optional[ssl.SSLSocket] = None,
 1083:     ssl_context: Optional[ssl.SSLContext] = None,
 1084:     server_hostname: Optional[str] = None,
 1085:     verify: Union[bool, str] = True,
 1086: ) -> dns.message.Message:
 1087:     """Return the response obtained after sending a query via TLS.
 1088: 
 1089:     *q*, a ``dns.message.Message``, the query to send
 1090: 
 1091:     *where*, a ``str`` containing an IPv4 or IPv6 address,  where
 1092:     to send the message.
 1093: 
 1094:     *timeout*, a ``float`` or ``None``, the number of seconds to wait before the
 1095:     query times out.  If ``None``, the default, wait forever.
 1096: 
 1097:     *port*, an ``int``, the port send the message to.  The default is 853.
 1098: 
 1099:     *source*, a ``str`` containing an IPv4 or IPv6 address, specifying
 1100:     the source address.  The default is the wildcard address.
 1101: 
 1102:     *source_port*, an ``int``, the port from which to send the message.
 1103:     The default is 0.
 1104: 
 1105:     *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its own
 1106:     RRset.
 1107: 
 1108:     *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing
 1109:     junk at end of the received message.
 1110: 
 1111:     *sock*, an ``ssl.SSLSocket``, or ``None``, the socket to use for
 1112:     the query.  If ``None``, the default, a socket is created.  Note
 1113:     that if a socket is provided, it must be a nonblocking connected
 1114:     SSL stream socket, and *where*, *port*, *source*, *source_port*,
 1115:     and *ssl_context* are ignored.
 1116: 
 1117:     *ssl_context*, an ``ssl.SSLContext``, the context to use when establishing
 1118:     a TLS connection. If ``None``, the default, creates one with the default
 1119:     configuration.
 1120: 
 1121:     *server_hostname*, a ``str`` containing the server's hostname.  The
 1122:     default is ``None``, which means that no hostname is known, and if an
 1123:     SSL context is created, hostname checking will be disabled.
 1124: 
 1125:     *verify*, a ``bool`` or ``str``.  If a ``True``, then TLS certificate verification
 1126:     of the server is done using the default CA bundle; if ``False``, then no
 1127:     verification is done; if a `str` then it specifies the path to a certificate file or
 1128:     directory which will be used for verification.
 1129: 
 1130:     Returns a ``dns.message.Message``.
 1131: 
 1132:     """
 1133: 
 1134:     if sock:
 1135:         #
 1136:         # If a socket was provided, there's no special TLS handling needed.
 1137:         #
 1138:         return tcp(
 1139:             q,
 1140:             where,
 1141:             timeout,
 1142:             port,
 1143:             source,
 1144:             source_port,
 1145:             one_rr_per_rrset,
 1146:             ignore_trailing,
 1147:             sock,
 1148:         )
 1149: 
 1150:     wire = q.to_wire()
 1151:     (begin_time, expiration) = _compute_times(timeout)
 1152:     (af, destination, source) = _destination_and_source(
 1153:         where, port, source, source_port
 1154:     )
 1155:     if ssl_context is None and not sock:
 1156:         ssl_context = _make_dot_ssl_context(server_hostname, verify)
 1157: 
 1158:     with _make_socket(
 1159:         af,
 1160:         socket.SOCK_STREAM,
 1161:         source,
 1162:         ssl_context=ssl_context,
 1163:         server_hostname=server_hostname,
 1164:     ) as s:
 1165:         _connect(s, destination, expiration)
 1166:         _tls_handshake(s, expiration)
 1167:         send_tcp(s, wire, expiration)
 1168:         (r, received_time) = receive_tcp(
 1169:             s, expiration, one_rr_per_rrset, q.keyring, q.mac, ignore_trailing
 1170:         )
 1171:         r.time = received_time - begin_time
 1172:         if not q.is_response(r):
 1173:             raise BadResponse
 1174:         return r
 1175:     assert (
 1176:         False  # help mypy figure out we can't get here  lgtm[py/unreachable-statement]
 1177:     )
 1178: 
 1179: 
 1180: def quic(
 1181:     q: dns.message.Message,
 1182:     where: str,
 1183:     timeout: Optional[float] = None,
 1184:     port: int = 853,
 1185:     source: Optional[str] = None,
 1186:     source_port: int = 0,
 1187:     one_rr_per_rrset: bool = False,
 1188:     ignore_trailing: bool = False,
 1189:     connection: Optional[dns.quic.SyncQuicConnection] = None,
 1190:     verify: Union[bool, str] = True,
 1191:     server_hostname: Optional[str] = None,
 1192: ) -> dns.message.Message:
 1193:     """Return the response obtained after sending a query via DNS-over-QUIC.
 1194: 
 1195:     *q*, a ``dns.message.Message``, the query to send.
 1196: 
 1197:     *where*, a ``str``, the nameserver IP address.
 1198: 
 1199:     *timeout*, a ``float`` or ``None``, the number of seconds to wait before the query
 1200:     times out. If ``None``, the default, wait forever.
 1201: 
 1202:     *port*, a ``int``, the port to send the query to. The default is 853.
 1203: 
 1204:     *source*, a ``str`` containing an IPv4 or IPv6 address, specifying the source
 1205:     address.  The default is the wildcard address.
 1206: 
 1207:     *source_port*, an ``int``, the port from which to send the message. The default is
 1208:     0.
 1209: 
 1210:     *one_rr_per_rrset*, a ``bool``. If ``True``, put each RR into its own RRset.
 1211: 
 1212:     *ignore_trailing*, a ``bool``. If ``True``, ignore trailing junk at end of the
 1213:     received message.
 1214: 
 1215:     *connection*, a ``dns.quic.SyncQuicConnection``.  If provided, the
 1216:     connection to use to send the query.
 1217: 
 1218:     *verify*, a ``bool`` or ``str``.  If a ``True``, then TLS certificate verification
 1219:     of the server is done using the default CA bundle; if ``False``, then no
 1220:     verification is done; if a `str` then it specifies the path to a certificate file or
 1221:     directory which will be used for verification.
 1222: 
 1223:     *server_hostname*, a ``str`` containing the server's hostname.  The
 1224:     default is ``None``, which means that no hostname is known, and if an
 1225:     SSL context is created, hostname checking will be disabled.
 1226: 
 1227:     Returns a ``dns.message.Message``.
 1228:     """
 1229: 
 1230:     if not dns.quic.have_quic:
 1231:         raise NoDOQ("DNS-over-QUIC is not available.")  # pragma: no cover
 1232: 
 1233:     q.id = 0
 1234:     wire = q.to_wire()
 1235:     the_connection: dns.quic.SyncQuicConnection
 1236:     the_manager: dns.quic.SyncQuicManager
 1237:     if connection:
 1238:         manager: contextlib.AbstractContextManager = contextlib.nullcontext(None)
 1239:         the_connection = connection
 1240:     else:
 1241:         manager = dns.quic.SyncQuicManager(
 1242:             verify_mode=verify, server_name=server_hostname
 1243:         )
 1244:         the_manager = manager  # for type checking happiness
 1245: 
 1246:     with manager:
 1247:         if not connection:
 1248:             the_connection = the_manager.connect(where, port, source, source_port)
 1249:         (start, expiration) = _compute_times(timeout)
 1250:         with the_connection.make_stream(timeout) as stream:
 1251:             stream.send(wire, True)
 1252:             wire = stream.receive(_remaining(expiration))
 1253:         finish = time.time()
 1254:     r = dns.message.from_wire(
 1255:         wire,
 1256:         keyring=q.keyring,
 1257:         request_mac=q.request_mac,
 1258:         one_rr_per_rrset=one_rr_per_rrset,
 1259:         ignore_trailing=ignore_trailing,
 1260:     )
 1261:     r.time = max(finish - start, 0.0)
 1262:     if not q.is_response(r):
 1263:         raise BadResponse
 1264:     return r
 1265: 
 1266: 
 1267: def xfr(
 1268:     where: str,
 1269:     zone: Union[dns.name.Name, str],
 1270:     rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.AXFR,
 1271:     rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,
 1272:     timeout: Optional[float] = None,
 1273:     port: int = 53,
 1274:     keyring: Optional[Dict[dns.name.Name, dns.tsig.Key]] = None,
 1275:     keyname: Optional[Union[dns.name.Name, str]] = None,
 1276:     relativize: bool = True,
 1277:     lifetime: Optional[float] = None,
 1278:     source: Optional[str] = None,
 1279:     source_port: int = 0,
 1280:     serial: int = 0,
 1281:     use_udp: bool = False,
 1282:     keyalgorithm: Union[dns.name.Name, str] = dns.tsig.default_algorithm,
 1283: ) -> Any:
 1284:     """Return a generator for the responses to a zone transfer.
 1285: 
 1286:     *where*, a ``str`` containing an IPv4 or IPv6 address,  where
 1287:     to send the message.
 1288: 
 1289:     *zone*, a ``dns.name.Name`` or ``str``, the name of the zone to transfer.
 1290: 
 1291:     *rdtype*, an ``int`` or ``str``, the type of zone transfer.  The
 1292:     default is ``dns.rdatatype.AXFR``.  ``dns.rdatatype.IXFR`` can be
 1293:     used to do an incremental transfer instead.
 1294: 
 1295:     *rdclass*, an ``int`` or ``str``, the class of the zone transfer.
 1296:     The default is ``dns.rdataclass.IN``.
 1297: 
 1298:     *timeout*, a ``float``, the number of seconds to wait for each
 1299:     response message.  If None, the default, wait forever.
 1300: 
 1301:     *port*, an ``int``, the port send the message to.  The default is 53.
 1302: 
 1303:     *keyring*, a ``dict``, the keyring to use for TSIG.
 1304: 
 1305:     *keyname*, a ``dns.name.Name`` or ``str``, the name of the TSIG
 1306:     key to use.
 1307: 
 1308:     *relativize*, a ``bool``.  If ``True``, all names in the zone will be
 1309:     relativized to the zone origin.  It is essential that the
 1310:     relativize setting matches the one specified to
 1311:     ``dns.zone.from_xfr()`` if using this generator to make a zone.
 1312: 
 1313:     *lifetime*, a ``float``, the total number of seconds to spend
 1314:     doing the transfer.  If ``None``, the default, then there is no
 1315:     limit on the time the transfer may take.
 1316: 
 1317:     *source*, a ``str`` containing an IPv4 or IPv6 address, specifying
 1318:     the source address.  The default is the wildcard address.
 1319: 
 1320:     *source_port*, an ``int``, the port from which to send the message.
 1321:     The default is 0.
 1322: 
 1323:     *serial*, an ``int``, the SOA serial number to use as the base for
 1324:     an IXFR diff sequence (only meaningful if *rdtype* is
 1325:     ``dns.rdatatype.IXFR``).
 1326: 
 1327:     *use_udp*, a ``bool``.  If ``True``, use UDP (only meaningful for IXFR).
 1328: 
 1329:     *keyalgorithm*, a ``dns.name.Name`` or ``str``, the TSIG algorithm to use.
 1330: 
 1331:     Raises on errors, and so does the generator.
 1332: 
 1333:     Returns a generator of ``dns.message.Message`` objects.
 1334:     """
 1335: 
 1336:     if isinstance(zone, str):
 1337:         zone = dns.name.from_text(zone)
 1338:     rdtype = dns.rdatatype.RdataType.make(rdtype)
 1339:     q = dns.message.make_query(zone, rdtype, rdclass)
 1340:     if rdtype == dns.rdatatype.IXFR:
 1341:         rrset = dns.rrset.from_text(zone, 0, "IN", "SOA", ". . %u 0 0 0 0" % serial)
 1342:         q.authority.append(rrset)
 1343:     if keyring is not None:
 1344:         q.use_tsig(keyring, keyname, algorithm=keyalgorithm)
 1345:     wire = q.to_wire()
 1346:     (af, destination, source) = _destination_and_source(
 1347:         where, port, source, source_port
 1348:     )
 1349:     if use_udp and rdtype != dns.rdatatype.IXFR:
 1350:         raise ValueError("cannot do a UDP AXFR")
 1351:     sock_type = socket.SOCK_DGRAM if use_udp else socket.SOCK_STREAM
 1352:     with _make_socket(af, sock_type, source) as s:
 1353:         (_, expiration) = _compute_times(lifetime)
 1354:         _connect(s, destination, expiration)
 1355:         l = len(wire)
 1356:         if use_udp:
 1357:             _udp_send(s, wire, None, expiration)
 1358:         else:
 1359:             tcpmsg = struct.pack("!H", l) + wire
 1360:             _net_write(s, tcpmsg, expiration)
 1361:         done = False
 1362:         delete_mode = True
 1363:         expecting_SOA = False
 1364:         soa_rrset = None
 1365:         if relativize:
 1366:             origin = zone
 1367:             oname = dns.name.empty
 1368:         else:
 1369:             origin = None
 1370:             oname = zone
 1371:         tsig_ctx = None
 1372:         while not done:
 1373:             (_, mexpiration) = _compute_times(timeout)
 1374:             if mexpiration is None or (
 1375:                 expiration is not None and mexpiration > expiration
 1376:             ):
 1377:                 mexpiration = expiration
 1378:             if use_udp:
 1379:                 (wire, _) = _udp_recv(s, 65535, mexpiration)
 1380:             else:
 1381:                 ldata = _net_read(s, 2, mexpiration)
 1382:                 (l,) = struct.unpack("!H", ldata)
 1383:                 wire = _net_read(s, l, mexpiration)
 1384:             is_ixfr = rdtype == dns.rdatatype.IXFR
 1385:             r = dns.message.from_wire(
 1386:                 wire,
 1387:                 keyring=q.keyring,
 1388:                 request_mac=q.mac,
 1389:                 xfr=True,
 1390:                 origin=origin,
 1391:                 tsig_ctx=tsig_ctx,
 1392:                 multi=True,
 1393:                 one_rr_per_rrset=is_ixfr,
 1394:             )
 1395:             rcode = r.rcode()
 1396:             if rcode != dns.rcode.NOERROR:
 1397:                 raise TransferError(rcode)
 1398:             tsig_ctx = r.tsig_ctx
 1399:             answer_index = 0
 1400:             if soa_rrset is None:
 1401:                 if not r.answer or r.answer[0].name != oname:
 1402:                     raise dns.exception.FormError("No answer or RRset not for qname")
 1403:                 rrset = r.answer[0]
 1404:                 if rrset.rdtype != dns.rdatatype.SOA:
 1405:                     raise dns.exception.FormError("first RRset is not an SOA")
 1406:                 answer_index = 1
 1407:                 soa_rrset = rrset.copy()
 1408:                 if rdtype == dns.rdatatype.IXFR:
 1409:                     if dns.serial.Serial(soa_rrset[0].serial) <= serial:
 1410:                         #
 1411:                         # We're already up-to-date.
 1412:                         #
 1413:                         done = True
 1414:                     else:
 1415:                         expecting_SOA = True
 1416:             #
 1417:             # Process SOAs in the answer section (other than the initial
 1418:             # SOA in the first message).
 1419:             #
 1420:             for rrset in r.answer[answer_index:]:
 1421:                 if done:
 1422:                     raise dns.exception.FormError("answers after final SOA")
 1423:                 if rrset.rdtype == dns.rdatatype.SOA and rrset.name == oname:
 1424:                     if expecting_SOA:
 1425:                         if rrset[0].serial != serial:
 1426:                             raise dns.exception.FormError("IXFR base serial mismatch")
 1427:                         expecting_SOA = False
 1428:                     elif rdtype == dns.rdatatype.IXFR:
 1429:                         delete_mode = not delete_mode
 1430:                     #
 1431:                     # If this SOA RRset is equal to the first we saw then we're
 1432:                     # finished. If this is an IXFR we also check that we're
 1433:                     # seeing the record in the expected part of the response.
 1434:                     #
 1435:                     if rrset == soa_rrset and (
 1436:                         rdtype == dns.rdatatype.AXFR
 1437:                         or (rdtype == dns.rdatatype.IXFR and delete_mode)
 1438:                     ):
 1439:                         done = True
 1440:                 elif expecting_SOA:
 1441:                     #
 1442:                     # We made an IXFR request and are expecting another
 1443:                     # SOA RR, but saw something else, so this must be an
 1444:                     # AXFR response.
 1445:                     #
 1446:                     rdtype = dns.rdatatype.AXFR
 1447:                     expecting_SOA = False
 1448:             if done and q.keyring and not r.had_tsig:
 1449:                 raise dns.exception.FormError("missing TSIG")
 1450:             yield r
 1451: 
 1452: 
 1453: class UDPMode(enum.IntEnum):
 1454:     """How should UDP be used in an IXFR from :py:func:`inbound_xfr()`?
 1455: 
 1456:     NEVER means "never use UDP; always use TCP"
 1457:     TRY_FIRST means "try to use UDP but fall back to TCP if needed"
 1458:     ONLY means "raise ``dns.xfr.UseTCP`` if trying UDP does not succeed"
 1459:     """
 1460: 
 1461:     NEVER = 0
 1462:     TRY_FIRST = 1
 1463:     ONLY = 2
 1464: 
 1465: 
 1466: def inbound_xfr(
 1467:     where: str,
 1468:     txn_manager: dns.transaction.TransactionManager,
 1469:     query: Optional[dns.message.Message] = None,
 1470:     port: int = 53,
 1471:     timeout: Optional[float] = None,
 1472:     lifetime: Optional[float] = None,
 1473:     source: Optional[str] = None,
 1474:     source_port: int = 0,
 1475:     udp_mode: UDPMode = UDPMode.NEVER,
 1476: ) -> None:
 1477:     """Conduct an inbound transfer and apply it via a transaction from the
 1478:     txn_manager.
 1479: 
 1480:     *where*, a ``str`` containing an IPv4 or IPv6 address,  where
 1481:     to send the message.
 1482: 
 1483:     *txn_manager*, a ``dns.transaction.TransactionManager``, the txn_manager
 1484:     for this transfer (typically a ``dns.zone.Zone``).
 1485: 
 1486:     *query*, the query to send.  If not supplied, a default query is
 1487:     constructed using information from the *txn_manager*.
 1488: 
 1489:     *port*, an ``int``, the port send the message to.  The default is 53.
 1490: 
 1491:     *timeout*, a ``float``, the number of seconds to wait for each
 1492:     response message.  If None, the default, wait forever.
 1493: 
 1494:     *lifetime*, a ``float``, the total number of seconds to spend
 1495:     doing the transfer.  If ``None``, the default, then there is no
 1496:     limit on the time the transfer may take.
 1497: 
 1498:     *source*, a ``str`` containing an IPv4 or IPv6 address, specifying
 1499:     the source address.  The default is the wildcard address.
 1500: 
 1501:     *source_port*, an ``int``, the port from which to send the message.
 1502:     The default is 0.
 1503: 
 1504:     *udp_mode*, a ``dns.query.UDPMode``, determines how UDP is used
 1505:     for IXFRs.  The default is ``dns.UDPMode.NEVER``, i.e. only use
 1506:     TCP.  Other possibilities are ``dns.UDPMode.TRY_FIRST``, which
 1507:     means "try UDP but fallback to TCP if needed", and
 1508:     ``dns.UDPMode.ONLY``, which means "try UDP and raise
 1509:     ``dns.xfr.UseTCP`` if it does not succeed.
 1510: 
 1511:     Raises on errors.
 1512:     """
 1513:     if query is None:
 1514:         (query, serial) = dns.xfr.make_query(txn_manager)
 1515:     else:
 1516:         serial = dns.xfr.extract_serial_from_query(query)
 1517:     rdtype = query.question[0].rdtype
 1518:     is_ixfr = rdtype == dns.rdatatype.IXFR
 1519:     origin = txn_manager.from_wire_origin()
 1520:     wire = query.to_wire()
 1521:     (af, destination, source) = _destination_and_source(
 1522:         where, port, source, source_port
 1523:     )
 1524:     (_, expiration) = _compute_times(lifetime)
 1525:     retry = True
 1526:     while retry:
 1527:         retry = False
 1528:         if is_ixfr and udp_mode != UDPMode.NEVER:
 1529:             sock_type = socket.SOCK_DGRAM
 1530:             is_udp = True
 1531:         else:
 1532:             sock_type = socket.SOCK_STREAM
 1533:             is_udp = False
 1534:         with _make_socket(af, sock_type, source) as s:
 1535:             _connect(s, destination, expiration)
 1536:             if is_udp:
 1537:                 _udp_send(s, wire, None, expiration)
 1538:             else:
 1539:                 tcpmsg = struct.pack("!H", len(wire)) + wire
 1540:                 _net_write(s, tcpmsg, expiration)
 1541:             with dns.xfr.Inbound(txn_manager, rdtype, serial, is_udp) as inbound:
 1542:                 done = False
 1543:                 tsig_ctx = None
 1544:                 while not done:
 1545:                     (_, mexpiration) = _compute_times(timeout)
 1546:                     if mexpiration is None or (
 1547:                         expiration is not None and mexpiration > expiration
 1548:                     ):
 1549:                         mexpiration = expiration
 1550:                     if is_udp:
 1551:                         (rwire, _) = _udp_recv(s, 65535, mexpiration)
 1552:                     else:
 1553:                         ldata = _net_read(s, 2, mexpiration)
 1554:                         (l,) = struct.unpack("!H", ldata)
 1555:                         rwire = _net_read(s, l, mexpiration)
 1556:                     r = dns.message.from_wire(
 1557:                         rwire,
 1558:                         keyring=query.keyring,
 1559:                         request_mac=query.mac,
 1560:                         xfr=True,
 1561:                         origin=origin,
 1562:                         tsig_ctx=tsig_ctx,
 1563:                         multi=(not is_udp),
 1564:                         one_rr_per_rrset=is_ixfr,
 1565:                     )
 1566:                     try:
 1567:                         done = inbound.process_message(r)
 1568:                     except dns.xfr.UseTCP:
 1569:                         assert is_udp  # should not happen if we used TCP!
 1570:                         if udp_mode == UDPMode.ONLY:
 1571:                             raise
 1572:                         done = True
 1573:                         retry = True
 1574:                         udp_mode = UDPMode.NEVER
 1575:                         continue
 1576:                     tsig_ctx = r.tsig_ctx
 1577:                 if not retry and query.keyring and not r.had_tsig:
 1578:                     raise dns.exception.FormError("missing TSIG")
