    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: import importlib.metadata
    4: import itertools
    5: import string
    6: from typing import Dict, List, Tuple
    7: 
    8: 
    9: def _tuple_from_text(version: str) -> Tuple:
   10:     text_parts = version.split(".")
   11:     int_parts = []
   12:     for text_part in text_parts:
   13:         digit_prefix = "".join(
   14:             itertools.takewhile(lambda x: x in string.digits, text_part)
   15:         )
   16:         try:
   17:             int_parts.append(int(digit_prefix))
   18:         except Exception:
   19:             break
   20:     return tuple(int_parts)
   21: 
   22: 
   23: def _version_check(
   24:     requirement: str,
   25: ) -> bool:
   26:     """Is the requirement fulfilled?
   27: 
   28:     The requirement must be of the form
   29: 
   30:         package>=version
   31:     """
   32:     package, minimum = requirement.split(">=")
   33:     try:
   34:         version = importlib.metadata.version(package)
   35:     except Exception:
   36:         return False
   37:     t_version = _tuple_from_text(version)
   38:     t_minimum = _tuple_from_text(minimum)
   39:     if t_version < t_minimum:
   40:         return False
   41:     return True
   42: 
   43: 
   44: _cache: Dict[str, bool] = {}
   45: 
   46: 
   47: def have(feature: str) -> bool:
   48:     """Is *feature* available?
   49: 
   50:     This tests if all optional packages needed for the
   51:     feature are available and recent enough.
   52: 
   53:     Returns ``True`` if the feature is available,
   54:     and ``False`` if it is not or if metadata is
   55:     missing.
   56:     """
   57:     value = _cache.get(feature)
   58:     if value is not None:
   59:         return value
   60:     requirements = _requirements.get(feature)
   61:     if requirements is None:
   62:         # we make a cache entry here for consistency not performance
   63:         _cache[feature] = False
   64:         return False
   65:     ok = True
   66:     for requirement in requirements:
   67:         if not _version_check(requirement):
   68:             ok = False
   69:             break
   70:     _cache[feature] = ok
   71:     return ok
   72: 
   73: 
   74: def force(feature: str, enabled: bool) -> None:
   75:     """Force the status of *feature* to be *enabled*.
   76: 
   77:     This method is provided as a workaround for any cases
   78:     where importlib.metadata is ineffective, or for testing.
   79:     """
   80:     _cache[feature] = enabled
   81: 
   82: 
   83: _requirements: Dict[str, List[str]] = {
   84:     ### BEGIN generated requirements
   85:     "dnssec": ["cryptography>=41"],
   86:     "doh": ["httpcore>=1.0.0", "httpx>=0.26.0", "h2>=4.1.0"],
   87:     "doq": ["aioquic>=0.9.25"],
   88:     "idna": ["idna>=3.6"],
   89:     "trio": ["trio>=0.23"],
   90:     "wmi": ["wmi>=1.5.1"],
   91:     ### END generated requirements
   92: }
