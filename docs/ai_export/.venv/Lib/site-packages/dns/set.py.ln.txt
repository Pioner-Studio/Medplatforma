    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2017 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import itertools
   19: 
   20: 
   21: class Set:
   22:     """A simple set class.
   23: 
   24:     This class was originally used to deal with sets being missing in
   25:     ancient versions of python, but dnspython will continue to use it
   26:     as these sets are based on lists and are thus indexable, and this
   27:     ability is widely used in dnspython applications.
   28:     """
   29: 
   30:     __slots__ = ["items"]
   31: 
   32:     def __init__(self, items=None):
   33:         """Initialize the set.
   34: 
   35:         *items*, an iterable or ``None``, the initial set of items.
   36:         """
   37: 
   38:         self.items = dict()
   39:         if items is not None:
   40:             for item in items:
   41:                 # This is safe for how we use set, but if other code
   42:                 # subclasses it could be a legitimate issue.
   43:                 self.add(item)  # lgtm[py/init-calls-subclass]
   44: 
   45:     def __repr__(self):
   46:         return "dns.set.Set(%s)" % repr(list(self.items.keys()))
   47: 
   48:     def add(self, item):
   49:         """Add an item to the set."""
   50: 
   51:         if item not in self.items:
   52:             self.items[item] = None
   53: 
   54:     def remove(self, item):
   55:         """Remove an item from the set."""
   56: 
   57:         try:
   58:             del self.items[item]
   59:         except KeyError:
   60:             raise ValueError
   61: 
   62:     def discard(self, item):
   63:         """Remove an item from the set if present."""
   64: 
   65:         self.items.pop(item, None)
   66: 
   67:     def pop(self):
   68:         """Remove an arbitrary item from the set."""
   69:         (k, _) = self.items.popitem()
   70:         return k
   71: 
   72:     def _clone(self) -> "Set":
   73:         """Make a (shallow) copy of the set.
   74: 
   75:         There is a 'clone protocol' that subclasses of this class
   76:         should use.  To make a copy, first call your super's _clone()
   77:         method, and use the object returned as the new instance.  Then
   78:         make shallow copies of the attributes defined in the subclass.
   79: 
   80:         This protocol allows us to write the set algorithms that
   81:         return new instances (e.g. union) once, and keep using them in
   82:         subclasses.
   83:         """
   84: 
   85:         if hasattr(self, "_clone_class"):
   86:             cls = self._clone_class  # type: ignore
   87:         else:
   88:             cls = self.__class__
   89:         obj = cls.__new__(cls)
   90:         obj.items = dict()
   91:         obj.items.update(self.items)
   92:         return obj
   93: 
   94:     def __copy__(self):
   95:         """Make a (shallow) copy of the set."""
   96: 
   97:         return self._clone()
   98: 
   99:     def copy(self):
  100:         """Make a (shallow) copy of the set."""
  101: 
  102:         return self._clone()
  103: 
  104:     def union_update(self, other):
  105:         """Update the set, adding any elements from other which are not
  106:         already in the set.
  107:         """
  108: 
  109:         if not isinstance(other, Set):
  110:             raise ValueError("other must be a Set instance")
  111:         if self is other:  # lgtm[py/comparison-using-is]
  112:             return
  113:         for item in other.items:
  114:             self.add(item)
  115: 
  116:     def intersection_update(self, other):
  117:         """Update the set, removing any elements from other which are not
  118:         in both sets.
  119:         """
  120: 
  121:         if not isinstance(other, Set):
  122:             raise ValueError("other must be a Set instance")
  123:         if self is other:  # lgtm[py/comparison-using-is]
  124:             return
  125:         # we make a copy of the list so that we can remove items from
  126:         # the list without breaking the iterator.
  127:         for item in list(self.items):
  128:             if item not in other.items:
  129:                 del self.items[item]
  130: 
  131:     def difference_update(self, other):
  132:         """Update the set, removing any elements from other which are in
  133:         the set.
  134:         """
  135: 
  136:         if not isinstance(other, Set):
  137:             raise ValueError("other must be a Set instance")
  138:         if self is other:  # lgtm[py/comparison-using-is]
  139:             self.items.clear()
  140:         else:
  141:             for item in other.items:
  142:                 self.discard(item)
  143: 
  144:     def symmetric_difference_update(self, other):
  145:         """Update the set, retaining only elements unique to both sets."""
  146: 
  147:         if not isinstance(other, Set):
  148:             raise ValueError("other must be a Set instance")
  149:         if self is other:  # lgtm[py/comparison-using-is]
  150:             self.items.clear()
  151:         else:
  152:             overlap = self.intersection(other)
  153:             self.union_update(other)
  154:             self.difference_update(overlap)
  155: 
  156:     def union(self, other):
  157:         """Return a new set which is the union of ``self`` and ``other``.
  158: 
  159:         Returns the same Set type as this set.
  160:         """
  161: 
  162:         obj = self._clone()
  163:         obj.union_update(other)
  164:         return obj
  165: 
  166:     def intersection(self, other):
  167:         """Return a new set which is the intersection of ``self`` and
  168:         ``other``.
  169: 
  170:         Returns the same Set type as this set.
  171:         """
  172: 
  173:         obj = self._clone()
  174:         obj.intersection_update(other)
  175:         return obj
  176: 
  177:     def difference(self, other):
  178:         """Return a new set which ``self`` - ``other``, i.e. the items
  179:         in ``self`` which are not also in ``other``.
  180: 
  181:         Returns the same Set type as this set.
  182:         """
  183: 
  184:         obj = self._clone()
  185:         obj.difference_update(other)
  186:         return obj
  187: 
  188:     def symmetric_difference(self, other):
  189:         """Return a new set which (``self`` - ``other``) | (``other``
  190:         - ``self), ie: the items in either ``self`` or ``other`` which
  191:         are not contained in their intersection.
  192: 
  193:         Returns the same Set type as this set.
  194:         """
  195: 
  196:         obj = self._clone()
  197:         obj.symmetric_difference_update(other)
  198:         return obj
  199: 
  200:     def __or__(self, other):
  201:         return self.union(other)
  202: 
  203:     def __and__(self, other):
  204:         return self.intersection(other)
  205: 
  206:     def __add__(self, other):
  207:         return self.union(other)
  208: 
  209:     def __sub__(self, other):
  210:         return self.difference(other)
  211: 
  212:     def __xor__(self, other):
  213:         return self.symmetric_difference(other)
  214: 
  215:     def __ior__(self, other):
  216:         self.union_update(other)
  217:         return self
  218: 
  219:     def __iand__(self, other):
  220:         self.intersection_update(other)
  221:         return self
  222: 
  223:     def __iadd__(self, other):
  224:         self.union_update(other)
  225:         return self
  226: 
  227:     def __isub__(self, other):
  228:         self.difference_update(other)
  229:         return self
  230: 
  231:     def __ixor__(self, other):
  232:         self.symmetric_difference_update(other)
  233:         return self
  234: 
  235:     def update(self, other):
  236:         """Update the set, adding any elements from other which are not
  237:         already in the set.
  238: 
  239:         *other*, the collection of items with which to update the set, which
  240:         may be any iterable type.
  241:         """
  242: 
  243:         for item in other:
  244:             self.add(item)
  245: 
  246:     def clear(self):
  247:         """Make the set empty."""
  248:         self.items.clear()
  249: 
  250:     def __eq__(self, other):
  251:         return self.items == other.items
  252: 
  253:     def __ne__(self, other):
  254:         return not self.__eq__(other)
  255: 
  256:     def __len__(self):
  257:         return len(self.items)
  258: 
  259:     def __iter__(self):
  260:         return iter(self.items)
  261: 
  262:     def __getitem__(self, i):
  263:         if isinstance(i, slice):
  264:             return list(itertools.islice(self.items, i.start, i.stop, i.step))
  265:         else:
  266:             return next(itertools.islice(self.items, i, i + 1))
  267: 
  268:     def __delitem__(self, i):
  269:         if isinstance(i, slice):
  270:             for elt in list(self[i]):
  271:                 del self.items[elt]
  272:         else:
  273:             del self.items[self[i]]
  274: 
  275:     def issubset(self, other):
  276:         """Is this set a subset of *other*?
  277: 
  278:         Returns a ``bool``.
  279:         """
  280: 
  281:         if not isinstance(other, Set):
  282:             raise ValueError("other must be a Set instance")
  283:         for item in self.items:
  284:             if item not in other.items:
  285:                 return False
  286:         return True
  287: 
  288:     def issuperset(self, other):
  289:         """Is this set a superset of *other*?
  290: 
  291:         Returns a ``bool``.
  292:         """
  293: 
  294:         if not isinstance(other, Set):
  295:             raise ValueError("other must be a Set instance")
  296:         for item in other.items:
  297:             if item not in self.items:
  298:                 return False
  299:         return True
  300: 
  301:     def isdisjoint(self, other):
  302:         if not isinstance(other, Set):
  303:             raise ValueError("other must be a Set instance")
  304:         for item in other.items:
  305:             if item in self.items:
  306:                 return False
  307:         return True
