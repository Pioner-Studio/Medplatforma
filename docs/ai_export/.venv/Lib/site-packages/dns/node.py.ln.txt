    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2001-2017 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: """DNS nodes.  A node is a set of rdatasets."""
   19: 
   20: import enum
   21: import io
   22: from typing import Any, Dict, Optional
   23: 
   24: import dns.immutable
   25: import dns.name
   26: import dns.rdataclass
   27: import dns.rdataset
   28: import dns.rdatatype
   29: import dns.renderer
   30: import dns.rrset
   31: 
   32: _cname_types = {
   33:     dns.rdatatype.CNAME,
   34: }
   35: 
   36: # "neutral" types can coexist with a CNAME and thus are not "other data"
   37: _neutral_types = {
   38:     dns.rdatatype.NSEC,  # RFC 4035 section 2.5
   39:     dns.rdatatype.NSEC3,  # This is not likely to happen, but not impossible!
   40:     dns.rdatatype.KEY,  # RFC 4035 section 2.5, RFC 3007
   41: }
   42: 
   43: 
   44: def _matches_type_or_its_signature(rdtypes, rdtype, covers):
   45:     return rdtype in rdtypes or (rdtype == dns.rdatatype.RRSIG and covers in rdtypes)
   46: 
   47: 
   48: @enum.unique
   49: class NodeKind(enum.Enum):
   50:     """Rdatasets in nodes"""
   51: 
   52:     REGULAR = 0  # a.k.a "other data"
   53:     NEUTRAL = 1
   54:     CNAME = 2
   55: 
   56:     @classmethod
   57:     def classify(
   58:         cls, rdtype: dns.rdatatype.RdataType, covers: dns.rdatatype.RdataType
   59:     ) -> "NodeKind":
   60:         if _matches_type_or_its_signature(_cname_types, rdtype, covers):
   61:             return NodeKind.CNAME
   62:         elif _matches_type_or_its_signature(_neutral_types, rdtype, covers):
   63:             return NodeKind.NEUTRAL
   64:         else:
   65:             return NodeKind.REGULAR
   66: 
   67:     @classmethod
   68:     def classify_rdataset(cls, rdataset: dns.rdataset.Rdataset) -> "NodeKind":
   69:         return cls.classify(rdataset.rdtype, rdataset.covers)
   70: 
   71: 
   72: class Node:
   73:     """A Node is a set of rdatasets.
   74: 
   75:     A node is either a CNAME node or an "other data" node.  A CNAME
   76:     node contains only CNAME, KEY, NSEC, and NSEC3 rdatasets along with their
   77:     covering RRSIG rdatasets.  An "other data" node contains any
   78:     rdataset other than a CNAME or RRSIG(CNAME) rdataset.  When
   79:     changes are made to a node, the CNAME or "other data" state is
   80:     always consistent with the update, i.e. the most recent change
   81:     wins.  For example, if you have a node which contains a CNAME
   82:     rdataset, and then add an MX rdataset to it, then the CNAME
   83:     rdataset will be deleted.  Likewise if you have a node containing
   84:     an MX rdataset and add a CNAME rdataset, the MX rdataset will be
   85:     deleted.
   86:     """
   87: 
   88:     __slots__ = ["rdatasets"]
   89: 
   90:     def __init__(self):
   91:         # the set of rdatasets, represented as a list.
   92:         self.rdatasets = []
   93: 
   94:     def to_text(self, name: dns.name.Name, **kw: Dict[str, Any]) -> str:
   95:         """Convert a node to text format.
   96: 
   97:         Each rdataset at the node is printed.  Any keyword arguments
   98:         to this method are passed on to the rdataset's to_text() method.
   99: 
  100:         *name*, a ``dns.name.Name``, the owner name of the
  101:         rdatasets.
  102: 
  103:         Returns a ``str``.
  104: 
  105:         """
  106: 
  107:         s = io.StringIO()
  108:         for rds in self.rdatasets:
  109:             if len(rds) > 0:
  110:                 s.write(rds.to_text(name, **kw))  # type: ignore[arg-type]
  111:                 s.write("\n")
  112:         return s.getvalue()[:-1]
  113: 
  114:     def __repr__(self):
  115:         return "<DNS node " + str(id(self)) + ">"
  116: 
  117:     def __eq__(self, other):
  118:         #
  119:         # This is inefficient.  Good thing we don't need to do it much.
  120:         #
  121:         for rd in self.rdatasets:
  122:             if rd not in other.rdatasets:
  123:                 return False
  124:         for rd in other.rdatasets:
  125:             if rd not in self.rdatasets:
  126:                 return False
  127:         return True
  128: 
  129:     def __ne__(self, other):
  130:         return not self.__eq__(other)
  131: 
  132:     def __len__(self):
  133:         return len(self.rdatasets)
  134: 
  135:     def __iter__(self):
  136:         return iter(self.rdatasets)
  137: 
  138:     def _append_rdataset(self, rdataset):
  139:         """Append rdataset to the node with special handling for CNAME and
  140:         other data conditions.
  141: 
  142:         Specifically, if the rdataset being appended has ``NodeKind.CNAME``,
  143:         then all rdatasets other than KEY, NSEC, NSEC3, and their covering
  144:         RRSIGs are deleted.  If the rdataset being appended has
  145:         ``NodeKind.REGULAR`` then CNAME and RRSIG(CNAME) are deleted.
  146:         """
  147:         # Make having just one rdataset at the node fast.
  148:         if len(self.rdatasets) > 0:
  149:             kind = NodeKind.classify_rdataset(rdataset)
  150:             if kind == NodeKind.CNAME:
  151:                 self.rdatasets = [
  152:                     rds
  153:                     for rds in self.rdatasets
  154:                     if NodeKind.classify_rdataset(rds) != NodeKind.REGULAR
  155:                 ]
  156:             elif kind == NodeKind.REGULAR:
  157:                 self.rdatasets = [
  158:                     rds
  159:                     for rds in self.rdatasets
  160:                     if NodeKind.classify_rdataset(rds) != NodeKind.CNAME
  161:                 ]
  162:             # Otherwise the rdataset is NodeKind.NEUTRAL and we do not need to
  163:             # edit self.rdatasets.
  164:         self.rdatasets.append(rdataset)
  165: 
  166:     def find_rdataset(
  167:         self,
  168:         rdclass: dns.rdataclass.RdataClass,
  169:         rdtype: dns.rdatatype.RdataType,
  170:         covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,
  171:         create: bool = False,
  172:     ) -> dns.rdataset.Rdataset:
  173:         """Find an rdataset matching the specified properties in the
  174:         current node.
  175: 
  176:         *rdclass*, a ``dns.rdataclass.RdataClass``, the class of the rdataset.
  177: 
  178:         *rdtype*, a ``dns.rdatatype.RdataType``, the type of the rdataset.
  179: 
  180:         *covers*, a ``dns.rdatatype.RdataType``, the covered type.
  181:         Usually this value is ``dns.rdatatype.NONE``, but if the
  182:         rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``,
  183:         then the covers value will be the rdata type the SIG/RRSIG
  184:         covers.  The library treats the SIG and RRSIG types as if they
  185:         were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).
  186:         This makes RRSIGs much easier to work with than if RRSIGs
  187:         covering different rdata types were aggregated into a single
  188:         RRSIG rdataset.
  189: 
  190:         *create*, a ``bool``.  If True, create the rdataset if it is not found.
  191: 
  192:         Raises ``KeyError`` if an rdataset of the desired type and class does
  193:         not exist and *create* is not ``True``.
  194: 
  195:         Returns a ``dns.rdataset.Rdataset``.
  196:         """
  197: 
  198:         for rds in self.rdatasets:
  199:             if rds.match(rdclass, rdtype, covers):
  200:                 return rds
  201:         if not create:
  202:             raise KeyError
  203:         rds = dns.rdataset.Rdataset(rdclass, rdtype, covers)
  204:         self._append_rdataset(rds)
  205:         return rds
  206: 
  207:     def get_rdataset(
  208:         self,
  209:         rdclass: dns.rdataclass.RdataClass,
  210:         rdtype: dns.rdatatype.RdataType,
  211:         covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,
  212:         create: bool = False,
  213:     ) -> Optional[dns.rdataset.Rdataset]:
  214:         """Get an rdataset matching the specified properties in the
  215:         current node.
  216: 
  217:         None is returned if an rdataset of the specified type and
  218:         class does not exist and *create* is not ``True``.
  219: 
  220:         *rdclass*, an ``int``, the class of the rdataset.
  221: 
  222:         *rdtype*, an ``int``, the type of the rdataset.
  223: 
  224:         *covers*, an ``int``, the covered type.  Usually this value is
  225:         dns.rdatatype.NONE, but if the rdtype is dns.rdatatype.SIG or
  226:         dns.rdatatype.RRSIG, then the covers value will be the rdata
  227:         type the SIG/RRSIG covers.  The library treats the SIG and RRSIG
  228:         types as if they were a family of
  229:         types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).  This makes RRSIGs much
  230:         easier to work with than if RRSIGs covering different rdata
  231:         types were aggregated into a single RRSIG rdataset.
  232: 
  233:         *create*, a ``bool``.  If True, create the rdataset if it is not found.
  234: 
  235:         Returns a ``dns.rdataset.Rdataset`` or ``None``.
  236:         """
  237: 
  238:         try:
  239:             rds = self.find_rdataset(rdclass, rdtype, covers, create)
  240:         except KeyError:
  241:             rds = None
  242:         return rds
  243: 
  244:     def delete_rdataset(
  245:         self,
  246:         rdclass: dns.rdataclass.RdataClass,
  247:         rdtype: dns.rdatatype.RdataType,
  248:         covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,
  249:     ) -> None:
  250:         """Delete the rdataset matching the specified properties in the
  251:         current node.
  252: 
  253:         If a matching rdataset does not exist, it is not an error.
  254: 
  255:         *rdclass*, an ``int``, the class of the rdataset.
  256: 
  257:         *rdtype*, an ``int``, the type of the rdataset.
  258: 
  259:         *covers*, an ``int``, the covered type.
  260:         """
  261: 
  262:         rds = self.get_rdataset(rdclass, rdtype, covers)
  263:         if rds is not None:
  264:             self.rdatasets.remove(rds)
  265: 
  266:     def replace_rdataset(self, replacement: dns.rdataset.Rdataset) -> None:
  267:         """Replace an rdataset.
  268: 
  269:         It is not an error if there is no rdataset matching *replacement*.
  270: 
  271:         Ownership of the *replacement* object is transferred to the node;
  272:         in other words, this method does not store a copy of *replacement*
  273:         at the node, it stores *replacement* itself.
  274: 
  275:         *replacement*, a ``dns.rdataset.Rdataset``.
  276: 
  277:         Raises ``ValueError`` if *replacement* is not a
  278:         ``dns.rdataset.Rdataset``.
  279:         """
  280: 
  281:         if not isinstance(replacement, dns.rdataset.Rdataset):
  282:             raise ValueError("replacement is not an rdataset")
  283:         if isinstance(replacement, dns.rrset.RRset):
  284:             # RRsets are not good replacements as the match() method
  285:             # is not compatible.
  286:             replacement = replacement.to_rdataset()
  287:         self.delete_rdataset(
  288:             replacement.rdclass, replacement.rdtype, replacement.covers
  289:         )
  290:         self._append_rdataset(replacement)
  291: 
  292:     def classify(self) -> NodeKind:
  293:         """Classify a node.
  294: 
  295:         A node which contains a CNAME or RRSIG(CNAME) is a
  296:         ``NodeKind.CNAME`` node.
  297: 
  298:         A node which contains only "neutral" types, i.e. types allowed to
  299:         co-exist with a CNAME, is a ``NodeKind.NEUTRAL`` node.  The neutral
  300:         types are NSEC, NSEC3, KEY, and their associated RRSIGS.  An empty node
  301:         is also considered neutral.
  302: 
  303:         A node which contains some rdataset which is not a CNAME, RRSIG(CNAME),
  304:         or a neutral type is a a ``NodeKind.REGULAR`` node.  Regular nodes are
  305:         also commonly referred to as "other data".
  306:         """
  307:         for rdataset in self.rdatasets:
  308:             kind = NodeKind.classify(rdataset.rdtype, rdataset.covers)
  309:             if kind != NodeKind.NEUTRAL:
  310:                 return kind
  311:         return NodeKind.NEUTRAL
  312: 
  313:     def is_immutable(self) -> bool:
  314:         return False
  315: 
  316: 
  317: @dns.immutable.immutable
  318: class ImmutableNode(Node):
  319:     def __init__(self, node):
  320:         super().__init__()
  321:         self.rdatasets = tuple(
  322:             [dns.rdataset.ImmutableRdataset(rds) for rds in node.rdatasets]
  323:         )
  324: 
  325:     def find_rdataset(
  326:         self,
  327:         rdclass: dns.rdataclass.RdataClass,
  328:         rdtype: dns.rdatatype.RdataType,
  329:         covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,
  330:         create: bool = False,
  331:     ) -> dns.rdataset.Rdataset:
  332:         if create:
  333:             raise TypeError("immutable")
  334:         return super().find_rdataset(rdclass, rdtype, covers, False)
  335: 
  336:     def get_rdataset(
  337:         self,
  338:         rdclass: dns.rdataclass.RdataClass,
  339:         rdtype: dns.rdatatype.RdataType,
  340:         covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,
  341:         create: bool = False,
  342:     ) -> Optional[dns.rdataset.Rdataset]:
  343:         if create:
  344:             raise TypeError("immutable")
  345:         return super().get_rdataset(rdclass, rdtype, covers, False)
  346: 
  347:     def delete_rdataset(
  348:         self,
  349:         rdclass: dns.rdataclass.RdataClass,
  350:         rdtype: dns.rdatatype.RdataType,
  351:         covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,
  352:     ) -> None:
  353:         raise TypeError("immutable")
  354: 
  355:     def replace_rdataset(self, replacement: dns.rdataset.Rdataset) -> None:
  356:         raise TypeError("immutable")
  357: 
  358:     def is_immutable(self) -> bool:
  359:         return True
