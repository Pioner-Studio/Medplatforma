    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: """trio async I/O library query support"""
    4: 
    5: import socket
    6: 
    7: import trio
    8: import trio.socket  # type: ignore
    9: 
   10: import dns._asyncbackend
   11: import dns._features
   12: import dns.exception
   13: import dns.inet
   14: 
   15: if not dns._features.have("trio"):
   16:     raise ImportError("trio not found or too old")
   17: 
   18: 
   19: def _maybe_timeout(timeout):
   20:     if timeout is not None:
   21:         return trio.move_on_after(timeout)
   22:     else:
   23:         return dns._asyncbackend.NullContext()
   24: 
   25: 
   26: # for brevity
   27: _lltuple = dns.inet.low_level_address_tuple
   28: 
   29: # pylint: disable=redefined-outer-name
   30: 
   31: 
   32: class DatagramSocket(dns._asyncbackend.DatagramSocket):
   33:     def __init__(self, socket):
   34:         super().__init__(socket.family)
   35:         self.socket = socket
   36: 
   37:     async def sendto(self, what, destination, timeout):
   38:         with _maybe_timeout(timeout):
   39:             return await self.socket.sendto(what, destination)
   40:         raise dns.exception.Timeout(
   41:             timeout=timeout
   42:         )  # pragma: no cover  lgtm[py/unreachable-statement]
   43: 
   44:     async def recvfrom(self, size, timeout):
   45:         with _maybe_timeout(timeout):
   46:             return await self.socket.recvfrom(size)
   47:         raise dns.exception.Timeout(timeout=timeout)  # lgtm[py/unreachable-statement]
   48: 
   49:     async def close(self):
   50:         self.socket.close()
   51: 
   52:     async def getpeername(self):
   53:         return self.socket.getpeername()
   54: 
   55:     async def getsockname(self):
   56:         return self.socket.getsockname()
   57: 
   58:     async def getpeercert(self, timeout):
   59:         raise NotImplementedError
   60: 
   61: 
   62: class StreamSocket(dns._asyncbackend.StreamSocket):
   63:     def __init__(self, family, stream, tls=False):
   64:         self.family = family
   65:         self.stream = stream
   66:         self.tls = tls
   67: 
   68:     async def sendall(self, what, timeout):
   69:         with _maybe_timeout(timeout):
   70:             return await self.stream.send_all(what)
   71:         raise dns.exception.Timeout(timeout=timeout)  # lgtm[py/unreachable-statement]
   72: 
   73:     async def recv(self, size, timeout):
   74:         with _maybe_timeout(timeout):
   75:             return await self.stream.receive_some(size)
   76:         raise dns.exception.Timeout(timeout=timeout)  # lgtm[py/unreachable-statement]
   77: 
   78:     async def close(self):
   79:         await self.stream.aclose()
   80: 
   81:     async def getpeername(self):
   82:         if self.tls:
   83:             return self.stream.transport_stream.socket.getpeername()
   84:         else:
   85:             return self.stream.socket.getpeername()
   86: 
   87:     async def getsockname(self):
   88:         if self.tls:
   89:             return self.stream.transport_stream.socket.getsockname()
   90:         else:
   91:             return self.stream.socket.getsockname()
   92: 
   93:     async def getpeercert(self, timeout):
   94:         if self.tls:
   95:             with _maybe_timeout(timeout):
   96:                 await self.stream.do_handshake()
   97:             return self.stream.getpeercert()
   98:         else:
   99:             raise NotImplementedError
  100: 
  101: 
  102: if dns._features.have("doh"):
  103:     import httpcore
  104:     import httpcore._backends.trio
  105:     import httpx
  106: 
  107:     _CoreAsyncNetworkBackend = httpcore.AsyncNetworkBackend
  108:     _CoreTrioStream = httpcore._backends.trio.TrioStream
  109: 
  110:     from dns.query import _compute_times, _expiration_for_this_attempt, _remaining
  111: 
  112:     class _NetworkBackend(_CoreAsyncNetworkBackend):
  113:         def __init__(self, resolver, local_port, bootstrap_address, family):
  114:             super().__init__()
  115:             self._local_port = local_port
  116:             self._resolver = resolver
  117:             self._bootstrap_address = bootstrap_address
  118:             self._family = family
  119: 
  120:         async def connect_tcp(
  121:             self, host, port, timeout, local_address, socket_options=None
  122:         ):  # pylint: disable=signature-differs
  123:             addresses = []
  124:             _, expiration = _compute_times(timeout)
  125:             if dns.inet.is_address(host):
  126:                 addresses.append(host)
  127:             elif self._bootstrap_address is not None:
  128:                 addresses.append(self._bootstrap_address)
  129:             else:
  130:                 timeout = _remaining(expiration)
  131:                 family = self._family
  132:                 if local_address:
  133:                     family = dns.inet.af_for_address(local_address)
  134:                 answers = await self._resolver.resolve_name(
  135:                     host, family=family, lifetime=timeout
  136:                 )
  137:                 addresses = answers.addresses()
  138:             for address in addresses:
  139:                 try:
  140:                     af = dns.inet.af_for_address(address)
  141:                     if local_address is not None or self._local_port != 0:
  142:                         source = (local_address, self._local_port)
  143:                     else:
  144:                         source = None
  145:                     destination = (address, port)
  146:                     attempt_expiration = _expiration_for_this_attempt(2.0, expiration)
  147:                     timeout = _remaining(attempt_expiration)
  148:                     sock = await Backend().make_socket(
  149:                         af, socket.SOCK_STREAM, 0, source, destination, timeout
  150:                     )
  151:                     return _CoreTrioStream(sock.stream)
  152:                 except Exception:
  153:                     continue
  154:             raise httpcore.ConnectError
  155: 
  156:         async def connect_unix_socket(
  157:             self, path, timeout, socket_options=None
  158:         ):  # pylint: disable=signature-differs
  159:             raise NotImplementedError
  160: 
  161:         async def sleep(self, seconds):  # pylint: disable=signature-differs
  162:             await trio.sleep(seconds)
  163: 
  164:     class _HTTPTransport(httpx.AsyncHTTPTransport):
  165:         def __init__(
  166:             self,
  167:             *args,
  168:             local_port=0,
  169:             bootstrap_address=None,
  170:             resolver=None,
  171:             family=socket.AF_UNSPEC,
  172:             **kwargs,
  173:         ):
  174:             if resolver is None:
  175:                 # pylint: disable=import-outside-toplevel,redefined-outer-name
  176:                 import dns.asyncresolver
  177: 
  178:                 resolver = dns.asyncresolver.Resolver()
  179:             super().__init__(*args, **kwargs)
  180:             self._pool._network_backend = _NetworkBackend(
  181:                 resolver, local_port, bootstrap_address, family
  182:             )
  183: 
  184: else:
  185:     _HTTPTransport = dns._asyncbackend.NullTransport  # type: ignore
  186: 
  187: 
  188: class Backend(dns._asyncbackend.Backend):
  189:     def name(self):
  190:         return "trio"
  191: 
  192:     async def make_socket(
  193:         self,
  194:         af,
  195:         socktype,
  196:         proto=0,
  197:         source=None,
  198:         destination=None,
  199:         timeout=None,
  200:         ssl_context=None,
  201:         server_hostname=None,
  202:     ):
  203:         s = trio.socket.socket(af, socktype, proto)
  204:         stream = None
  205:         try:
  206:             if source:
  207:                 await s.bind(_lltuple(source, af))
  208:             if socktype == socket.SOCK_STREAM:
  209:                 connected = False
  210:                 with _maybe_timeout(timeout):
  211:                     await s.connect(_lltuple(destination, af))
  212:                     connected = True
  213:                 if not connected:
  214:                     raise dns.exception.Timeout(
  215:                         timeout=timeout
  216:                     )  # lgtm[py/unreachable-statement]
  217:         except Exception:  # pragma: no cover
  218:             s.close()
  219:             raise
  220:         if socktype == socket.SOCK_DGRAM:
  221:             return DatagramSocket(s)
  222:         elif socktype == socket.SOCK_STREAM:
  223:             stream = trio.SocketStream(s)
  224:             tls = False
  225:             if ssl_context:
  226:                 tls = True
  227:                 try:
  228:                     stream = trio.SSLStream(
  229:                         stream, ssl_context, server_hostname=server_hostname
  230:                     )
  231:                 except Exception:  # pragma: no cover
  232:                     await stream.aclose()
  233:                     raise
  234:             return StreamSocket(af, stream, tls)
  235:         raise NotImplementedError(
  236:             "unsupported socket " + f"type {socktype}"
  237:         )  # pragma: no cover
  238: 
  239:     async def sleep(self, interval):
  240:         await trio.sleep(interval)
  241: 
  242:     def get_transport_class(self):
  243:         return _HTTPTransport
  244: 
  245:     async def wait_for(self, awaitable, timeout):
  246:         with _maybe_timeout(timeout):
  247:             return await awaitable
  248:         raise dns.exception.Timeout(
  249:             timeout=timeout
  250:         )  # pragma: no cover  lgtm[py/unreachable-statement]
