    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: """DNS Versioned Zones."""
    4: 
    5: import collections
    6: import threading
    7: from typing import Callable, Deque, Optional, Set, Union
    8: 
    9: import dns.exception
   10: import dns.immutable
   11: import dns.name
   12: import dns.node
   13: import dns.rdataclass
   14: import dns.rdataset
   15: import dns.rdatatype
   16: import dns.rdtypes.ANY.SOA
   17: import dns.zone
   18: 
   19: 
   20: class UseTransaction(dns.exception.DNSException):
   21:     """To alter a versioned zone, use a transaction."""
   22: 
   23: 
   24: # Backwards compatibility
   25: Node = dns.zone.VersionedNode
   26: ImmutableNode = dns.zone.ImmutableVersionedNode
   27: Version = dns.zone.Version
   28: WritableVersion = dns.zone.WritableVersion
   29: ImmutableVersion = dns.zone.ImmutableVersion
   30: Transaction = dns.zone.Transaction
   31: 
   32: 
   33: class Zone(dns.zone.Zone):  # lgtm[py/missing-equals]
   34:     __slots__ = [
   35:         "_versions",
   36:         "_versions_lock",
   37:         "_write_txn",
   38:         "_write_waiters",
   39:         "_write_event",
   40:         "_pruning_policy",
   41:         "_readers",
   42:     ]
   43: 
   44:     node_factory = Node
   45: 
   46:     def __init__(
   47:         self,
   48:         origin: Optional[Union[dns.name.Name, str]],
   49:         rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,
   50:         relativize: bool = True,
   51:         pruning_policy: Optional[Callable[["Zone", Version], Optional[bool]]] = None,
   52:     ):
   53:         """Initialize a versioned zone object.
   54: 
   55:         *origin* is the origin of the zone.  It may be a ``dns.name.Name``,
   56:         a ``str``, or ``None``.  If ``None``, then the zone's origin will
   57:         be set by the first ``$ORIGIN`` line in a zone file.
   58: 
   59:         *rdclass*, an ``int``, the zone's rdata class; the default is class IN.
   60: 
   61:         *relativize*, a ``bool``, determine's whether domain names are
   62:         relativized to the zone's origin.  The default is ``True``.
   63: 
   64:         *pruning policy*, a function taking a ``Zone`` and a ``Version`` and returning
   65:         a ``bool``, or ``None``.  Should the version be pruned?  If ``None``,
   66:         the default policy, which retains one version is used.
   67:         """
   68:         super().__init__(origin, rdclass, relativize)
   69:         self._versions: Deque[Version] = collections.deque()
   70:         self._version_lock = threading.Lock()
   71:         if pruning_policy is None:
   72:             self._pruning_policy = self._default_pruning_policy
   73:         else:
   74:             self._pruning_policy = pruning_policy
   75:         self._write_txn: Optional[Transaction] = None
   76:         self._write_event: Optional[threading.Event] = None
   77:         self._write_waiters: Deque[threading.Event] = collections.deque()
   78:         self._readers: Set[Transaction] = set()
   79:         self._commit_version_unlocked(
   80:             None, WritableVersion(self, replacement=True), origin
   81:         )
   82: 
   83:     def reader(
   84:         self, id: Optional[int] = None, serial: Optional[int] = None
   85:     ) -> Transaction:  # pylint: disable=arguments-differ
   86:         if id is not None and serial is not None:
   87:             raise ValueError("cannot specify both id and serial")
   88:         with self._version_lock:
   89:             if id is not None:
   90:                 version = None
   91:                 for v in reversed(self._versions):
   92:                     if v.id == id:
   93:                         version = v
   94:                         break
   95:                 if version is None:
   96:                     raise KeyError("version not found")
   97:             elif serial is not None:
   98:                 if self.relativize:
   99:                     oname = dns.name.empty
  100:                 else:
  101:                     assert self.origin is not None
  102:                     oname = self.origin
  103:                 version = None
  104:                 for v in reversed(self._versions):
  105:                     n = v.nodes.get(oname)
  106:                     if n:
  107:                         rds = n.get_rdataset(self.rdclass, dns.rdatatype.SOA)
  108:                         if rds and rds[0].serial == serial:
  109:                             version = v
  110:                             break
  111:                 if version is None:
  112:                     raise KeyError("serial not found")
  113:             else:
  114:                 version = self._versions[-1]
  115:             txn = Transaction(self, False, version)
  116:             self._readers.add(txn)
  117:             return txn
  118: 
  119:     def writer(self, replacement: bool = False) -> Transaction:
  120:         event = None
  121:         while True:
  122:             with self._version_lock:
  123:                 # Checking event == self._write_event ensures that either
  124:                 # no one was waiting before we got lucky and found no write
  125:                 # txn, or we were the one who was waiting and got woken up.
  126:                 # This prevents "taking cuts" when creating a write txn.
  127:                 if self._write_txn is None and event == self._write_event:
  128:                     # Creating the transaction defers version setup
  129:                     # (i.e.  copying the nodes dictionary) until we
  130:                     # give up the lock, so that we hold the lock as
  131:                     # short a time as possible.  This is why we call
  132:                     # _setup_version() below.
  133:                     self._write_txn = Transaction(
  134:                         self, replacement, make_immutable=True
  135:                     )
  136:                     # give up our exclusive right to make a Transaction
  137:                     self._write_event = None
  138:                     break
  139:                 # Someone else is writing already, so we will have to
  140:                 # wait, but we want to do the actual wait outside the
  141:                 # lock.
  142:                 event = threading.Event()
  143:                 self._write_waiters.append(event)
  144:             # wait (note we gave up the lock!)
  145:             #
  146:             # We only wake one sleeper at a time, so it's important
  147:             # that no event waiter can exit this method (e.g. via
  148:             # cancellation) without returning a transaction or waking
  149:             # someone else up.
  150:             #
  151:             # This is not a problem with Threading module threads as
  152:             # they cannot be canceled, but could be an issue with trio
  153:             # tasks when we do the async version of writer().
  154:             # I.e. we'd need to do something like:
  155:             #
  156:             # try:
  157:             #     event.wait()
  158:             # except trio.Cancelled:
  159:             #     with self._version_lock:
  160:             #         self._maybe_wakeup_one_waiter_unlocked()
  161:             #     raise
  162:             #
  163:             event.wait()
  164:         # Do the deferred version setup.
  165:         self._write_txn._setup_version()
  166:         return self._write_txn
  167: 
  168:     def _maybe_wakeup_one_waiter_unlocked(self):
  169:         if len(self._write_waiters) > 0:
  170:             self._write_event = self._write_waiters.popleft()
  171:             self._write_event.set()
  172: 
  173:     # pylint: disable=unused-argument
  174:     def _default_pruning_policy(self, zone, version):
  175:         return True
  176: 
  177:     # pylint: enable=unused-argument
  178: 
  179:     def _prune_versions_unlocked(self):
  180:         assert len(self._versions) > 0
  181:         # Don't ever prune a version greater than or equal to one that
  182:         # a reader has open.  This pins versions in memory while the
  183:         # reader is open, and importantly lets the reader open a txn on
  184:         # a successor version (e.g. if generating an IXFR).
  185:         #
  186:         # Note our definition of least_kept also ensures we do not try to
  187:         # delete the greatest version.
  188:         if len(self._readers) > 0:
  189:             least_kept = min(txn.version.id for txn in self._readers)
  190:         else:
  191:             least_kept = self._versions[-1].id
  192:         while self._versions[0].id < least_kept and self._pruning_policy(
  193:             self, self._versions[0]
  194:         ):
  195:             self._versions.popleft()
  196: 
  197:     def set_max_versions(self, max_versions: Optional[int]) -> None:
  198:         """Set a pruning policy that retains up to the specified number
  199:         of versions
  200:         """
  201:         if max_versions is not None and max_versions < 1:
  202:             raise ValueError("max versions must be at least 1")
  203:         if max_versions is None:
  204: 
  205:             def policy(zone, _):  # pylint: disable=unused-argument
  206:                 return False
  207: 
  208:         else:
  209: 
  210:             def policy(zone, _):
  211:                 return len(zone._versions) > max_versions
  212: 
  213:         self.set_pruning_policy(policy)
  214: 
  215:     def set_pruning_policy(
  216:         self, policy: Optional[Callable[["Zone", Version], Optional[bool]]]
  217:     ) -> None:
  218:         """Set the pruning policy for the zone.
  219: 
  220:         The *policy* function takes a `Version` and returns `True` if
  221:         the version should be pruned, and `False` otherwise.  `None`
  222:         may also be specified for policy, in which case the default policy
  223:         is used.
  224: 
  225:         Pruning checking proceeds from the least version and the first
  226:         time the function returns `False`, the checking stops.  I.e. the
  227:         retained versions are always a consecutive sequence.
  228:         """
  229:         if policy is None:
  230:             policy = self._default_pruning_policy
  231:         with self._version_lock:
  232:             self._pruning_policy = policy
  233:             self._prune_versions_unlocked()
  234: 
  235:     def _end_read(self, txn):
  236:         with self._version_lock:
  237:             self._readers.remove(txn)
  238:             self._prune_versions_unlocked()
  239: 
  240:     def _end_write_unlocked(self, txn):
  241:         assert self._write_txn == txn
  242:         self._write_txn = None
  243:         self._maybe_wakeup_one_waiter_unlocked()
  244: 
  245:     def _end_write(self, txn):
  246:         with self._version_lock:
  247:             self._end_write_unlocked(txn)
  248: 
  249:     def _commit_version_unlocked(self, txn, version, origin):
  250:         self._versions.append(version)
  251:         self._prune_versions_unlocked()
  252:         self.nodes = version.nodes
  253:         if self.origin is None:
  254:             self.origin = origin
  255:         # txn can be None in __init__ when we make the empty version.
  256:         if txn is not None:
  257:             self._end_write_unlocked(txn)
  258: 
  259:     def _commit_version(self, txn, version, origin):
  260:         with self._version_lock:
  261:             self._commit_version_unlocked(txn, version, origin)
  262: 
  263:     def _get_next_version_id(self):
  264:         if len(self._versions) > 0:
  265:             id = self._versions[-1].id + 1
  266:         else:
  267:             id = 1
  268:         return id
  269: 
  270:     def find_node(
  271:         self, name: Union[dns.name.Name, str], create: bool = False
  272:     ) -> dns.node.Node:
  273:         if create:
  274:             raise UseTransaction
  275:         return super().find_node(name)
  276: 
  277:     def delete_node(self, name: Union[dns.name.Name, str]) -> None:
  278:         raise UseTransaction
  279: 
  280:     def find_rdataset(
  281:         self,
  282:         name: Union[dns.name.Name, str],
  283:         rdtype: Union[dns.rdatatype.RdataType, str],
  284:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  285:         create: bool = False,
  286:     ) -> dns.rdataset.Rdataset:
  287:         if create:
  288:             raise UseTransaction
  289:         rdataset = super().find_rdataset(name, rdtype, covers)
  290:         return dns.rdataset.ImmutableRdataset(rdataset)
  291: 
  292:     def get_rdataset(
  293:         self,
  294:         name: Union[dns.name.Name, str],
  295:         rdtype: Union[dns.rdatatype.RdataType, str],
  296:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  297:         create: bool = False,
  298:     ) -> Optional[dns.rdataset.Rdataset]:
  299:         if create:
  300:             raise UseTransaction
  301:         rdataset = super().get_rdataset(name, rdtype, covers)
  302:         if rdataset is not None:
  303:             return dns.rdataset.ImmutableRdataset(rdataset)
  304:         else:
  305:             return None
  306: 
  307:     def delete_rdataset(
  308:         self,
  309:         name: Union[dns.name.Name, str],
  310:         rdtype: Union[dns.rdatatype.RdataType, str],
  311:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  312:     ) -> None:
  313:         raise UseTransaction
  314: 
  315:     def replace_rdataset(
  316:         self, name: Union[dns.name.Name, str], replacement: dns.rdataset.Rdataset
  317:     ) -> None:
  318:         raise UseTransaction
