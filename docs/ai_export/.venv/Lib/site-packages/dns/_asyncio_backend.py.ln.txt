    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: """asyncio library query support"""
    4: 
    5: import asyncio
    6: import socket
    7: import sys
    8: 
    9: import dns._asyncbackend
   10: import dns._features
   11: import dns.exception
   12: import dns.inet
   13: 
   14: _is_win32 = sys.platform == "win32"
   15: 
   16: 
   17: def _get_running_loop():
   18:     try:
   19:         return asyncio.get_running_loop()
   20:     except AttributeError:  # pragma: no cover
   21:         return asyncio.get_event_loop()
   22: 
   23: 
   24: class _DatagramProtocol:
   25:     def __init__(self):
   26:         self.transport = None
   27:         self.recvfrom = None
   28: 
   29:     def connection_made(self, transport):
   30:         self.transport = transport
   31: 
   32:     def datagram_received(self, data, addr):
   33:         if self.recvfrom and not self.recvfrom.done():
   34:             self.recvfrom.set_result((data, addr))
   35: 
   36:     def error_received(self, exc):  # pragma: no cover
   37:         if self.recvfrom and not self.recvfrom.done():
   38:             self.recvfrom.set_exception(exc)
   39: 
   40:     def connection_lost(self, exc):
   41:         if self.recvfrom and not self.recvfrom.done():
   42:             if exc is None:
   43:                 # EOF we triggered.  Is there a better way to do this?
   44:                 try:
   45:                     raise EOFError
   46:                 except EOFError as e:
   47:                     self.recvfrom.set_exception(e)
   48:             else:
   49:                 self.recvfrom.set_exception(exc)
   50: 
   51:     def close(self):
   52:         self.transport.close()
   53: 
   54: 
   55: async def _maybe_wait_for(awaitable, timeout):
   56:     if timeout is not None:
   57:         try:
   58:             return await asyncio.wait_for(awaitable, timeout)
   59:         except asyncio.TimeoutError:
   60:             raise dns.exception.Timeout(timeout=timeout)
   61:     else:
   62:         return await awaitable
   63: 
   64: 
   65: class DatagramSocket(dns._asyncbackend.DatagramSocket):
   66:     def __init__(self, family, transport, protocol):
   67:         super().__init__(family)
   68:         self.transport = transport
   69:         self.protocol = protocol
   70: 
   71:     async def sendto(self, what, destination, timeout):  # pragma: no cover
   72:         # no timeout for asyncio sendto
   73:         self.transport.sendto(what, destination)
   74:         return len(what)
   75: 
   76:     async def recvfrom(self, size, timeout):
   77:         # ignore size as there's no way I know to tell protocol about it
   78:         done = _get_running_loop().create_future()
   79:         try:
   80:             assert self.protocol.recvfrom is None
   81:             self.protocol.recvfrom = done
   82:             await _maybe_wait_for(done, timeout)
   83:             return done.result()
   84:         finally:
   85:             self.protocol.recvfrom = None
   86: 
   87:     async def close(self):
   88:         self.protocol.close()
   89: 
   90:     async def getpeername(self):
   91:         return self.transport.get_extra_info("peername")
   92: 
   93:     async def getsockname(self):
   94:         return self.transport.get_extra_info("sockname")
   95: 
   96:     async def getpeercert(self, timeout):
   97:         raise NotImplementedError
   98: 
   99: 
  100: class StreamSocket(dns._asyncbackend.StreamSocket):
  101:     def __init__(self, af, reader, writer):
  102:         self.family = af
  103:         self.reader = reader
  104:         self.writer = writer
  105: 
  106:     async def sendall(self, what, timeout):
  107:         self.writer.write(what)
  108:         return await _maybe_wait_for(self.writer.drain(), timeout)
  109: 
  110:     async def recv(self, size, timeout):
  111:         return await _maybe_wait_for(self.reader.read(size), timeout)
  112: 
  113:     async def close(self):
  114:         self.writer.close()
  115: 
  116:     async def getpeername(self):
  117:         return self.writer.get_extra_info("peername")
  118: 
  119:     async def getsockname(self):
  120:         return self.writer.get_extra_info("sockname")
  121: 
  122:     async def getpeercert(self, timeout):
  123:         return self.writer.get_extra_info("peercert")
  124: 
  125: 
  126: if dns._features.have("doh"):
  127:     import anyio
  128:     import httpcore
  129:     import httpcore._backends.anyio
  130:     import httpx
  131: 
  132:     _CoreAsyncNetworkBackend = httpcore.AsyncNetworkBackend
  133:     _CoreAnyIOStream = httpcore._backends.anyio.AnyIOStream
  134: 
  135:     from dns.query import _compute_times, _expiration_for_this_attempt, _remaining
  136: 
  137:     class _NetworkBackend(_CoreAsyncNetworkBackend):
  138:         def __init__(self, resolver, local_port, bootstrap_address, family):
  139:             super().__init__()
  140:             self._local_port = local_port
  141:             self._resolver = resolver
  142:             self._bootstrap_address = bootstrap_address
  143:             self._family = family
  144:             if local_port != 0:
  145:                 raise NotImplementedError(
  146:                     "the asyncio transport for HTTPX cannot set the local port"
  147:                 )
  148: 
  149:         async def connect_tcp(
  150:             self, host, port, timeout, local_address, socket_options=None
  151:         ):  # pylint: disable=signature-differs
  152:             addresses = []
  153:             _, expiration = _compute_times(timeout)
  154:             if dns.inet.is_address(host):
  155:                 addresses.append(host)
  156:             elif self._bootstrap_address is not None:
  157:                 addresses.append(self._bootstrap_address)
  158:             else:
  159:                 timeout = _remaining(expiration)
  160:                 family = self._family
  161:                 if local_address:
  162:                     family = dns.inet.af_for_address(local_address)
  163:                 answers = await self._resolver.resolve_name(
  164:                     host, family=family, lifetime=timeout
  165:                 )
  166:                 addresses = answers.addresses()
  167:             for address in addresses:
  168:                 try:
  169:                     attempt_expiration = _expiration_for_this_attempt(2.0, expiration)
  170:                     timeout = _remaining(attempt_expiration)
  171:                     with anyio.fail_after(timeout):
  172:                         stream = await anyio.connect_tcp(
  173:                             remote_host=address,
  174:                             remote_port=port,
  175:                             local_host=local_address,
  176:                         )
  177:                     return _CoreAnyIOStream(stream)
  178:                 except Exception:
  179:                     pass
  180:             raise httpcore.ConnectError
  181: 
  182:         async def connect_unix_socket(
  183:             self, path, timeout, socket_options=None
  184:         ):  # pylint: disable=signature-differs
  185:             raise NotImplementedError
  186: 
  187:         async def sleep(self, seconds):  # pylint: disable=signature-differs
  188:             await anyio.sleep(seconds)
  189: 
  190:     class _HTTPTransport(httpx.AsyncHTTPTransport):
  191:         def __init__(
  192:             self,
  193:             *args,
  194:             local_port=0,
  195:             bootstrap_address=None,
  196:             resolver=None,
  197:             family=socket.AF_UNSPEC,
  198:             **kwargs,
  199:         ):
  200:             if resolver is None:
  201:                 # pylint: disable=import-outside-toplevel,redefined-outer-name
  202:                 import dns.asyncresolver
  203: 
  204:                 resolver = dns.asyncresolver.Resolver()
  205:             super().__init__(*args, **kwargs)
  206:             self._pool._network_backend = _NetworkBackend(
  207:                 resolver, local_port, bootstrap_address, family
  208:             )
  209: 
  210: else:
  211:     _HTTPTransport = dns._asyncbackend.NullTransport  # type: ignore
  212: 
  213: 
  214: class Backend(dns._asyncbackend.Backend):
  215:     def name(self):
  216:         return "asyncio"
  217: 
  218:     async def make_socket(
  219:         self,
  220:         af,
  221:         socktype,
  222:         proto=0,
  223:         source=None,
  224:         destination=None,
  225:         timeout=None,
  226:         ssl_context=None,
  227:         server_hostname=None,
  228:     ):
  229:         loop = _get_running_loop()
  230:         if socktype == socket.SOCK_DGRAM:
  231:             if _is_win32 and source is None:
  232:                 # Win32 wants explicit binding before recvfrom().  This is the
  233:                 # proper fix for [#637].
  234:                 source = (dns.inet.any_for_af(af), 0)
  235:             transport, protocol = await loop.create_datagram_endpoint(
  236:                 _DatagramProtocol,
  237:                 source,
  238:                 family=af,
  239:                 proto=proto,
  240:                 remote_addr=destination,
  241:             )
  242:             return DatagramSocket(af, transport, protocol)
  243:         elif socktype == socket.SOCK_STREAM:
  244:             if destination is None:
  245:                 # This shouldn't happen, but we check to make code analysis software
  246:                 # happier.
  247:                 raise ValueError("destination required for stream sockets")
  248:             (r, w) = await _maybe_wait_for(
  249:                 asyncio.open_connection(
  250:                     destination[0],
  251:                     destination[1],
  252:                     ssl=ssl_context,
  253:                     family=af,
  254:                     proto=proto,
  255:                     local_addr=source,
  256:                     server_hostname=server_hostname,
  257:                 ),
  258:                 timeout,
  259:             )
  260:             return StreamSocket(af, r, w)
  261:         raise NotImplementedError(
  262:             "unsupported socket " + f"type {socktype}"
  263:         )  # pragma: no cover
  264: 
  265:     async def sleep(self, interval):
  266:         await asyncio.sleep(interval)
  267: 
  268:     def datagram_connection_required(self):
  269:         return False
  270: 
  271:     def get_transport_class(self):
  272:         return _HTTPTransport
  273: 
  274:     async def wait_for(self, awaitable, timeout):
  275:         return await _maybe_wait_for(awaitable, timeout)
