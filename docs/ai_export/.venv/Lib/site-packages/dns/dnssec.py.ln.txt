    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2017 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: """Common DNSSEC-related functions and constants."""
   19: 
   20: 
   21: import base64
   22: import contextlib
   23: import functools
   24: import hashlib
   25: import struct
   26: import time
   27: from datetime import datetime
   28: from typing import Callable, Dict, List, Optional, Set, Tuple, Union, cast
   29: 
   30: import dns._features
   31: import dns.exception
   32: import dns.name
   33: import dns.node
   34: import dns.rdata
   35: import dns.rdataclass
   36: import dns.rdataset
   37: import dns.rdatatype
   38: import dns.rrset
   39: import dns.transaction
   40: import dns.zone
   41: from dns.dnssectypes import Algorithm, DSDigest, NSEC3Hash
   42: from dns.exception import (  # pylint: disable=W0611
   43:     AlgorithmKeyMismatch,
   44:     DeniedByPolicy,
   45:     UnsupportedAlgorithm,
   46:     ValidationFailure,
   47: )
   48: from dns.rdtypes.ANY.CDNSKEY import CDNSKEY
   49: from dns.rdtypes.ANY.CDS import CDS
   50: from dns.rdtypes.ANY.DNSKEY import DNSKEY
   51: from dns.rdtypes.ANY.DS import DS
   52: from dns.rdtypes.ANY.NSEC import NSEC, Bitmap
   53: from dns.rdtypes.ANY.NSEC3PARAM import NSEC3PARAM
   54: from dns.rdtypes.ANY.RRSIG import RRSIG, sigtime_to_posixtime
   55: from dns.rdtypes.dnskeybase import Flag
   56: 
   57: PublicKey = Union[
   58:     "GenericPublicKey",
   59:     "rsa.RSAPublicKey",
   60:     "ec.EllipticCurvePublicKey",
   61:     "ed25519.Ed25519PublicKey",
   62:     "ed448.Ed448PublicKey",
   63: ]
   64: 
   65: PrivateKey = Union[
   66:     "GenericPrivateKey",
   67:     "rsa.RSAPrivateKey",
   68:     "ec.EllipticCurvePrivateKey",
   69:     "ed25519.Ed25519PrivateKey",
   70:     "ed448.Ed448PrivateKey",
   71: ]
   72: 
   73: RRsetSigner = Callable[[dns.transaction.Transaction, dns.rrset.RRset], None]
   74: 
   75: 
   76: def algorithm_from_text(text: str) -> Algorithm:
   77:     """Convert text into a DNSSEC algorithm value.
   78: 
   79:     *text*, a ``str``, the text to convert to into an algorithm value.
   80: 
   81:     Returns an ``int``.
   82:     """
   83: 
   84:     return Algorithm.from_text(text)
   85: 
   86: 
   87: def algorithm_to_text(value: Union[Algorithm, int]) -> str:
   88:     """Convert a DNSSEC algorithm value to text
   89: 
   90:     *value*, a ``dns.dnssec.Algorithm``.
   91: 
   92:     Returns a ``str``, the name of a DNSSEC algorithm.
   93:     """
   94: 
   95:     return Algorithm.to_text(value)
   96: 
   97: 
   98: def to_timestamp(value: Union[datetime, str, float, int]) -> int:
   99:     """Convert various format to a timestamp"""
  100:     if isinstance(value, datetime):
  101:         return int(value.timestamp())
  102:     elif isinstance(value, str):
  103:         return sigtime_to_posixtime(value)
  104:     elif isinstance(value, float):
  105:         return int(value)
  106:     elif isinstance(value, int):
  107:         return value
  108:     else:
  109:         raise TypeError("Unsupported timestamp type")
  110: 
  111: 
  112: def key_id(key: Union[DNSKEY, CDNSKEY]) -> int:
  113:     """Return the key id (a 16-bit number) for the specified key.
  114: 
  115:     *key*, a ``dns.rdtypes.ANY.DNSKEY.DNSKEY``
  116: 
  117:     Returns an ``int`` between 0 and 65535
  118:     """
  119: 
  120:     rdata = key.to_wire()
  121:     if key.algorithm == Algorithm.RSAMD5:
  122:         return (rdata[-3] << 8) + rdata[-2]
  123:     else:
  124:         total = 0
  125:         for i in range(len(rdata) // 2):
  126:             total += (rdata[2 * i] << 8) + rdata[2 * i + 1]
  127:         if len(rdata) % 2 != 0:
  128:             total += rdata[len(rdata) - 1] << 8
  129:         total += (total >> 16) & 0xFFFF
  130:         return total & 0xFFFF
  131: 
  132: 
  133: class Policy:
  134:     def __init__(self):
  135:         pass
  136: 
  137:     def ok_to_sign(self, _: DNSKEY) -> bool:  # pragma: no cover
  138:         return False
  139: 
  140:     def ok_to_validate(self, _: DNSKEY) -> bool:  # pragma: no cover
  141:         return False
  142: 
  143:     def ok_to_create_ds(self, _: DSDigest) -> bool:  # pragma: no cover
  144:         return False
  145: 
  146:     def ok_to_validate_ds(self, _: DSDigest) -> bool:  # pragma: no cover
  147:         return False
  148: 
  149: 
  150: class SimpleDeny(Policy):
  151:     def __init__(self, deny_sign, deny_validate, deny_create_ds, deny_validate_ds):
  152:         super().__init__()
  153:         self._deny_sign = deny_sign
  154:         self._deny_validate = deny_validate
  155:         self._deny_create_ds = deny_create_ds
  156:         self._deny_validate_ds = deny_validate_ds
  157: 
  158:     def ok_to_sign(self, key: DNSKEY) -> bool:
  159:         return key.algorithm not in self._deny_sign
  160: 
  161:     def ok_to_validate(self, key: DNSKEY) -> bool:
  162:         return key.algorithm not in self._deny_validate
  163: 
  164:     def ok_to_create_ds(self, algorithm: DSDigest) -> bool:
  165:         return algorithm not in self._deny_create_ds
  166: 
  167:     def ok_to_validate_ds(self, algorithm: DSDigest) -> bool:
  168:         return algorithm not in self._deny_validate_ds
  169: 
  170: 
  171: rfc_8624_policy = SimpleDeny(
  172:     {Algorithm.RSAMD5, Algorithm.DSA, Algorithm.DSANSEC3SHA1, Algorithm.ECCGOST},
  173:     {Algorithm.RSAMD5, Algorithm.DSA, Algorithm.DSANSEC3SHA1},
  174:     {DSDigest.NULL, DSDigest.SHA1, DSDigest.GOST},
  175:     {DSDigest.NULL},
  176: )
  177: 
  178: allow_all_policy = SimpleDeny(set(), set(), set(), set())
  179: 
  180: 
  181: default_policy = rfc_8624_policy
  182: 
  183: 
  184: def make_ds(
  185:     name: Union[dns.name.Name, str],
  186:     key: dns.rdata.Rdata,
  187:     algorithm: Union[DSDigest, str],
  188:     origin: Optional[dns.name.Name] = None,
  189:     policy: Optional[Policy] = None,
  190:     validating: bool = False,
  191: ) -> DS:
  192:     """Create a DS record for a DNSSEC key.
  193: 
  194:     *name*, a ``dns.name.Name`` or ``str``, the owner name of the DS record.
  195: 
  196:     *key*, a ``dns.rdtypes.ANY.DNSKEY.DNSKEY`` or ``dns.rdtypes.ANY.DNSKEY.CDNSKEY``,
  197:     the key the DS is about.
  198: 
  199:     *algorithm*, a ``str`` or ``int`` specifying the hash algorithm.
  200:     The currently supported hashes are "SHA1", "SHA256", and "SHA384". Case
  201:     does not matter for these strings.
  202: 
  203:     *origin*, a ``dns.name.Name`` or ``None``.  If *key* is a relative name,
  204:     then it will be made absolute using the specified origin.
  205: 
  206:     *policy*, a ``dns.dnssec.Policy`` or ``None``.  If ``None``, the default policy,
  207:     ``dns.dnssec.default_policy`` is used; this policy defaults to that of RFC 8624.
  208: 
  209:     *validating*, a ``bool``.  If ``True``, then policy is checked in
  210:     validating mode, i.e. "Is it ok to validate using this digest algorithm?".
  211:     Otherwise the policy is checked in creating mode, i.e. "Is it ok to create a DS with
  212:     this digest algorithm?".
  213: 
  214:     Raises ``UnsupportedAlgorithm`` if the algorithm is unknown.
  215: 
  216:     Raises ``DeniedByPolicy`` if the algorithm is denied by policy.
  217: 
  218:     Returns a ``dns.rdtypes.ANY.DS.DS``
  219:     """
  220: 
  221:     if policy is None:
  222:         policy = default_policy
  223:     try:
  224:         if isinstance(algorithm, str):
  225:             algorithm = DSDigest[algorithm.upper()]
  226:     except Exception:
  227:         raise UnsupportedAlgorithm('unsupported algorithm "%s"' % algorithm)
  228:     if validating:
  229:         check = policy.ok_to_validate_ds
  230:     else:
  231:         check = policy.ok_to_create_ds
  232:     if not check(algorithm):
  233:         raise DeniedByPolicy
  234:     if not isinstance(key, (DNSKEY, CDNSKEY)):
  235:         raise ValueError("key is not a DNSKEY/CDNSKEY")
  236:     if algorithm == DSDigest.SHA1:
  237:         dshash = hashlib.sha1()
  238:     elif algorithm == DSDigest.SHA256:
  239:         dshash = hashlib.sha256()
  240:     elif algorithm == DSDigest.SHA384:
  241:         dshash = hashlib.sha384()
  242:     else:
  243:         raise UnsupportedAlgorithm('unsupported algorithm "%s"' % algorithm)
  244: 
  245:     if isinstance(name, str):
  246:         name = dns.name.from_text(name, origin)
  247:     wire = name.canonicalize().to_wire()
  248:     assert wire is not None
  249:     dshash.update(wire)
  250:     dshash.update(key.to_wire(origin=origin))
  251:     digest = dshash.digest()
  252: 
  253:     dsrdata = struct.pack("!HBB", key_id(key), key.algorithm, algorithm) + digest
  254:     ds = dns.rdata.from_wire(
  255:         dns.rdataclass.IN, dns.rdatatype.DS, dsrdata, 0, len(dsrdata)
  256:     )
  257:     return cast(DS, ds)
  258: 
  259: 
  260: def make_cds(
  261:     name: Union[dns.name.Name, str],
  262:     key: dns.rdata.Rdata,
  263:     algorithm: Union[DSDigest, str],
  264:     origin: Optional[dns.name.Name] = None,
  265: ) -> CDS:
  266:     """Create a CDS record for a DNSSEC key.
  267: 
  268:     *name*, a ``dns.name.Name`` or ``str``, the owner name of the DS record.
  269: 
  270:     *key*, a ``dns.rdtypes.ANY.DNSKEY.DNSKEY`` or ``dns.rdtypes.ANY.DNSKEY.CDNSKEY``,
  271:     the key the DS is about.
  272: 
  273:     *algorithm*, a ``str`` or ``int`` specifying the hash algorithm.
  274:     The currently supported hashes are "SHA1", "SHA256", and "SHA384". Case
  275:     does not matter for these strings.
  276: 
  277:     *origin*, a ``dns.name.Name`` or ``None``.  If *key* is a relative name,
  278:     then it will be made absolute using the specified origin.
  279: 
  280:     Raises ``UnsupportedAlgorithm`` if the algorithm is unknown.
  281: 
  282:     Returns a ``dns.rdtypes.ANY.DS.CDS``
  283:     """
  284: 
  285:     ds = make_ds(name, key, algorithm, origin)
  286:     return CDS(
  287:         rdclass=ds.rdclass,
  288:         rdtype=dns.rdatatype.CDS,
  289:         key_tag=ds.key_tag,
  290:         algorithm=ds.algorithm,
  291:         digest_type=ds.digest_type,
  292:         digest=ds.digest,
  293:     )
  294: 
  295: 
  296: def _find_candidate_keys(
  297:     keys: Dict[dns.name.Name, Union[dns.rdataset.Rdataset, dns.node.Node]], rrsig: RRSIG
  298: ) -> Optional[List[DNSKEY]]:
  299:     value = keys.get(rrsig.signer)
  300:     if isinstance(value, dns.node.Node):
  301:         rdataset = value.get_rdataset(dns.rdataclass.IN, dns.rdatatype.DNSKEY)
  302:     else:
  303:         rdataset = value
  304:     if rdataset is None:
  305:         return None
  306:     return [
  307:         cast(DNSKEY, rd)
  308:         for rd in rdataset
  309:         if rd.algorithm == rrsig.algorithm
  310:         and key_id(rd) == rrsig.key_tag
  311:         and (rd.flags & Flag.ZONE) == Flag.ZONE  # RFC 4034 2.1.1
  312:         and rd.protocol == 3  # RFC 4034 2.1.2
  313:     ]
  314: 
  315: 
  316: def _get_rrname_rdataset(
  317:     rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],
  318: ) -> Tuple[dns.name.Name, dns.rdataset.Rdataset]:
  319:     if isinstance(rrset, tuple):
  320:         return rrset[0], rrset[1]
  321:     else:
  322:         return rrset.name, rrset
  323: 
  324: 
  325: def _validate_signature(sig: bytes, data: bytes, key: DNSKEY) -> None:
  326:     public_cls = get_algorithm_cls_from_dnskey(key).public_cls
  327:     try:
  328:         public_key = public_cls.from_dnskey(key)
  329:     except ValueError:
  330:         raise ValidationFailure("invalid public key")
  331:     public_key.verify(sig, data)
  332: 
  333: 
  334: def _validate_rrsig(
  335:     rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],
  336:     rrsig: RRSIG,
  337:     keys: Dict[dns.name.Name, Union[dns.node.Node, dns.rdataset.Rdataset]],
  338:     origin: Optional[dns.name.Name] = None,
  339:     now: Optional[float] = None,
  340:     policy: Optional[Policy] = None,
  341: ) -> None:
  342:     """Validate an RRset against a single signature rdata, throwing an
  343:     exception if validation is not successful.
  344: 
  345:     *rrset*, the RRset to validate.  This can be a
  346:     ``dns.rrset.RRset`` or a (``dns.name.Name``, ``dns.rdataset.Rdataset``)
  347:     tuple.
  348: 
  349:     *rrsig*, a ``dns.rdata.Rdata``, the signature to validate.
  350: 
  351:     *keys*, the key dictionary, used to find the DNSKEY associated
  352:     with a given name.  The dictionary is keyed by a
  353:     ``dns.name.Name``, and has ``dns.node.Node`` or
  354:     ``dns.rdataset.Rdataset`` values.
  355: 
  356:     *origin*, a ``dns.name.Name`` or ``None``, the origin to use for relative
  357:     names.
  358: 
  359:     *now*, a ``float`` or ``None``, the time, in seconds since the epoch, to
  360:     use as the current time when validating.  If ``None``, the actual current
  361:     time is used.
  362: 
  363:     *policy*, a ``dns.dnssec.Policy`` or ``None``.  If ``None``, the default policy,
  364:     ``dns.dnssec.default_policy`` is used; this policy defaults to that of RFC 8624.
  365: 
  366:     Raises ``ValidationFailure`` if the signature is expired, not yet valid,
  367:     the public key is invalid, the algorithm is unknown, the verification
  368:     fails, etc.
  369: 
  370:     Raises ``UnsupportedAlgorithm`` if the algorithm is recognized by
  371:     dnspython but not implemented.
  372:     """
  373: 
  374:     if policy is None:
  375:         policy = default_policy
  376: 
  377:     candidate_keys = _find_candidate_keys(keys, rrsig)
  378:     if candidate_keys is None:
  379:         raise ValidationFailure("unknown key")
  380: 
  381:     if now is None:
  382:         now = time.time()
  383:     if rrsig.expiration < now:
  384:         raise ValidationFailure("expired")
  385:     if rrsig.inception > now:
  386:         raise ValidationFailure("not yet valid")
  387: 
  388:     data = _make_rrsig_signature_data(rrset, rrsig, origin)
  389: 
  390:     for candidate_key in candidate_keys:
  391:         if not policy.ok_to_validate(candidate_key):
  392:             continue
  393:         try:
  394:             _validate_signature(rrsig.signature, data, candidate_key)
  395:             return
  396:         except (InvalidSignature, ValidationFailure):
  397:             # this happens on an individual validation failure
  398:             continue
  399:     # nothing verified -- raise failure:
  400:     raise ValidationFailure("verify failure")
  401: 
  402: 
  403: def _validate(
  404:     rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],
  405:     rrsigset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],
  406:     keys: Dict[dns.name.Name, Union[dns.node.Node, dns.rdataset.Rdataset]],
  407:     origin: Optional[dns.name.Name] = None,
  408:     now: Optional[float] = None,
  409:     policy: Optional[Policy] = None,
  410: ) -> None:
  411:     """Validate an RRset against a signature RRset, throwing an exception
  412:     if none of the signatures validate.
  413: 
  414:     *rrset*, the RRset to validate.  This can be a
  415:     ``dns.rrset.RRset`` or a (``dns.name.Name``, ``dns.rdataset.Rdataset``)
  416:     tuple.
  417: 
  418:     *rrsigset*, the signature RRset.  This can be a
  419:     ``dns.rrset.RRset`` or a (``dns.name.Name``, ``dns.rdataset.Rdataset``)
  420:     tuple.
  421: 
  422:     *keys*, the key dictionary, used to find the DNSKEY associated
  423:     with a given name.  The dictionary is keyed by a
  424:     ``dns.name.Name``, and has ``dns.node.Node`` or
  425:     ``dns.rdataset.Rdataset`` values.
  426: 
  427:     *origin*, a ``dns.name.Name``, the origin to use for relative names;
  428:     defaults to None.
  429: 
  430:     *now*, an ``int`` or ``None``, the time, in seconds since the epoch, to
  431:     use as the current time when validating.  If ``None``, the actual current
  432:     time is used.
  433: 
  434:     *policy*, a ``dns.dnssec.Policy`` or ``None``.  If ``None``, the default policy,
  435:     ``dns.dnssec.default_policy`` is used; this policy defaults to that of RFC 8624.
  436: 
  437:     Raises ``ValidationFailure`` if the signature is expired, not yet valid,
  438:     the public key is invalid, the algorithm is unknown, the verification
  439:     fails, etc.
  440:     """
  441: 
  442:     if policy is None:
  443:         policy = default_policy
  444: 
  445:     if isinstance(origin, str):
  446:         origin = dns.name.from_text(origin, dns.name.root)
  447: 
  448:     if isinstance(rrset, tuple):
  449:         rrname = rrset[0]
  450:     else:
  451:         rrname = rrset.name
  452: 
  453:     if isinstance(rrsigset, tuple):
  454:         rrsigname = rrsigset[0]
  455:         rrsigrdataset = rrsigset[1]
  456:     else:
  457:         rrsigname = rrsigset.name
  458:         rrsigrdataset = rrsigset
  459: 
  460:     rrname = rrname.choose_relativity(origin)
  461:     rrsigname = rrsigname.choose_relativity(origin)
  462:     if rrname != rrsigname:
  463:         raise ValidationFailure("owner names do not match")
  464: 
  465:     for rrsig in rrsigrdataset:
  466:         if not isinstance(rrsig, RRSIG):
  467:             raise ValidationFailure("expected an RRSIG")
  468:         try:
  469:             _validate_rrsig(rrset, rrsig, keys, origin, now, policy)
  470:             return
  471:         except (ValidationFailure, UnsupportedAlgorithm):
  472:             pass
  473:     raise ValidationFailure("no RRSIGs validated")
  474: 
  475: 
  476: def _sign(
  477:     rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],
  478:     private_key: PrivateKey,
  479:     signer: dns.name.Name,
  480:     dnskey: DNSKEY,
  481:     inception: Optional[Union[datetime, str, int, float]] = None,
  482:     expiration: Optional[Union[datetime, str, int, float]] = None,
  483:     lifetime: Optional[int] = None,
  484:     verify: bool = False,
  485:     policy: Optional[Policy] = None,
  486:     origin: Optional[dns.name.Name] = None,
  487: ) -> RRSIG:
  488:     """Sign RRset using private key.
  489: 
  490:     *rrset*, the RRset to validate.  This can be a
  491:     ``dns.rrset.RRset`` or a (``dns.name.Name``, ``dns.rdataset.Rdataset``)
  492:     tuple.
  493: 
  494:     *private_key*, the private key to use for signing, a
  495:     ``cryptography.hazmat.primitives.asymmetric`` private key class applicable
  496:     for DNSSEC.
  497: 
  498:     *signer*, a ``dns.name.Name``, the Signer's name.
  499: 
  500:     *dnskey*, a ``DNSKEY`` matching ``private_key``.
  501: 
  502:     *inception*, a ``datetime``, ``str``, ``int``, ``float`` or ``None``, the
  503:     signature inception time.  If ``None``, the current time is used.  If a ``str``, the
  504:     format is "YYYYMMDDHHMMSS" or alternatively the number of seconds since the UNIX
  505:     epoch in text form; this is the same the RRSIG rdata's text form.
  506:     Values of type `int` or `float` are interpreted as seconds since the UNIX epoch.
  507: 
  508:     *expiration*, a ``datetime``, ``str``, ``int``, ``float`` or ``None``, the signature
  509:     expiration time.  If ``None``, the expiration time will be the inception time plus
  510:     the value of the *lifetime* parameter.  See the description of *inception* above
  511:     for how the various parameter types are interpreted.
  512: 
  513:     *lifetime*, an ``int`` or ``None``, the signature lifetime in seconds.  This
  514:     parameter is only meaningful if *expiration* is ``None``.
  515: 
  516:     *verify*, a ``bool``.  If set to ``True``, the signer will verify signatures
  517:     after they are created; the default is ``False``.
  518: 
  519:     *policy*, a ``dns.dnssec.Policy`` or ``None``.  If ``None``, the default policy,
  520:     ``dns.dnssec.default_policy`` is used; this policy defaults to that of RFC 8624.
  521: 
  522:     *origin*, a ``dns.name.Name`` or ``None``.  If ``None``, the default, then all
  523:     names in the rrset (including its owner name) must be absolute; otherwise the
  524:     specified origin will be used to make names absolute when signing.
  525: 
  526:     Raises ``DeniedByPolicy`` if the signature is denied by policy.
  527:     """
  528: 
  529:     if policy is None:
  530:         policy = default_policy
  531:     if not policy.ok_to_sign(dnskey):
  532:         raise DeniedByPolicy
  533: 
  534:     if isinstance(rrset, tuple):
  535:         rdclass = rrset[1].rdclass
  536:         rdtype = rrset[1].rdtype
  537:         rrname = rrset[0]
  538:         original_ttl = rrset[1].ttl
  539:     else:
  540:         rdclass = rrset.rdclass
  541:         rdtype = rrset.rdtype
  542:         rrname = rrset.name
  543:         original_ttl = rrset.ttl
  544: 
  545:     if inception is not None:
  546:         rrsig_inception = to_timestamp(inception)
  547:     else:
  548:         rrsig_inception = int(time.time())
  549: 
  550:     if expiration is not None:
  551:         rrsig_expiration = to_timestamp(expiration)
  552:     elif lifetime is not None:
  553:         rrsig_expiration = rrsig_inception + lifetime
  554:     else:
  555:         raise ValueError("expiration or lifetime must be specified")
  556: 
  557:     # Derelativize now because we need a correct labels length for the
  558:     # rrsig_template.
  559:     if origin is not None:
  560:         rrname = rrname.derelativize(origin)
  561:     labels = len(rrname) - 1
  562: 
  563:     # Adjust labels appropriately for wildcards.
  564:     if rrname.is_wild():
  565:         labels -= 1
  566: 
  567:     rrsig_template = RRSIG(
  568:         rdclass=rdclass,
  569:         rdtype=dns.rdatatype.RRSIG,
  570:         type_covered=rdtype,
  571:         algorithm=dnskey.algorithm,
  572:         labels=labels,
  573:         original_ttl=original_ttl,
  574:         expiration=rrsig_expiration,
  575:         inception=rrsig_inception,
  576:         key_tag=key_id(dnskey),
  577:         signer=signer,
  578:         signature=b"",
  579:     )
  580: 
  581:     data = dns.dnssec._make_rrsig_signature_data(rrset, rrsig_template, origin)
  582: 
  583:     if isinstance(private_key, GenericPrivateKey):
  584:         signing_key = private_key
  585:     else:
  586:         try:
  587:             private_cls = get_algorithm_cls_from_dnskey(dnskey)
  588:             signing_key = private_cls(key=private_key)
  589:         except UnsupportedAlgorithm:
  590:             raise TypeError("Unsupported key algorithm")
  591: 
  592:     signature = signing_key.sign(data, verify)
  593: 
  594:     return cast(RRSIG, rrsig_template.replace(signature=signature))
  595: 
  596: 
  597: def _make_rrsig_signature_data(
  598:     rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],
  599:     rrsig: RRSIG,
  600:     origin: Optional[dns.name.Name] = None,
  601: ) -> bytes:
  602:     """Create signature rdata.
  603: 
  604:     *rrset*, the RRset to sign/validate.  This can be a
  605:     ``dns.rrset.RRset`` or a (``dns.name.Name``, ``dns.rdataset.Rdataset``)
  606:     tuple.
  607: 
  608:     *rrsig*, a ``dns.rdata.Rdata``, the signature to validate, or the
  609:     signature template used when signing.
  610: 
  611:     *origin*, a ``dns.name.Name`` or ``None``, the origin to use for relative
  612:     names.
  613: 
  614:     Raises ``UnsupportedAlgorithm`` if the algorithm is recognized by
  615:     dnspython but not implemented.
  616:     """
  617: 
  618:     if isinstance(origin, str):
  619:         origin = dns.name.from_text(origin, dns.name.root)
  620: 
  621:     signer = rrsig.signer
  622:     if not signer.is_absolute():
  623:         if origin is None:
  624:             raise ValidationFailure("relative RR name without an origin specified")
  625:         signer = signer.derelativize(origin)
  626: 
  627:     # For convenience, allow the rrset to be specified as a (name,
  628:     # rdataset) tuple as well as a proper rrset
  629:     rrname, rdataset = _get_rrname_rdataset(rrset)
  630: 
  631:     data = b""
  632:     data += rrsig.to_wire(origin=signer)[:18]
  633:     data += rrsig.signer.to_digestable(signer)
  634: 
  635:     # Derelativize the name before considering labels.
  636:     if not rrname.is_absolute():
  637:         if origin is None:
  638:             raise ValidationFailure("relative RR name without an origin specified")
  639:         rrname = rrname.derelativize(origin)
  640: 
  641:     name_len = len(rrname)
  642:     if rrname.is_wild() and rrsig.labels != name_len - 2:
  643:         raise ValidationFailure("wild owner name has wrong label length")
  644:     if name_len - 1 < rrsig.labels:
  645:         raise ValidationFailure("owner name longer than RRSIG labels")
  646:     elif rrsig.labels < name_len - 1:
  647:         suffix = rrname.split(rrsig.labels + 1)[1]
  648:         rrname = dns.name.from_text("*", suffix)
  649:     rrnamebuf = rrname.to_digestable()
  650:     rrfixed = struct.pack("!HHI", rdataset.rdtype, rdataset.rdclass, rrsig.original_ttl)
  651:     rdatas = [rdata.to_digestable(origin) for rdata in rdataset]
  652:     for rdata in sorted(rdatas):
  653:         data += rrnamebuf
  654:         data += rrfixed
  655:         rrlen = struct.pack("!H", len(rdata))
  656:         data += rrlen
  657:         data += rdata
  658: 
  659:     return data
  660: 
  661: 
  662: def _make_dnskey(
  663:     public_key: PublicKey,
  664:     algorithm: Union[int, str],
  665:     flags: int = Flag.ZONE,
  666:     protocol: int = 3,
  667: ) -> DNSKEY:
  668:     """Convert a public key to DNSKEY Rdata
  669: 
  670:     *public_key*, a ``PublicKey`` (``GenericPublicKey`` or
  671:     ``cryptography.hazmat.primitives.asymmetric``) to convert.
  672: 
  673:     *algorithm*, a ``str`` or ``int`` specifying the DNSKEY algorithm.
  674: 
  675:     *flags*: DNSKEY flags field as an integer.
  676: 
  677:     *protocol*: DNSKEY protocol field as an integer.
  678: 
  679:     Raises ``ValueError`` if the specified key algorithm parameters are not
  680:     unsupported, ``TypeError`` if the key type is unsupported,
  681:     `UnsupportedAlgorithm` if the algorithm is unknown and
  682:     `AlgorithmKeyMismatch` if the algorithm does not match the key type.
  683: 
  684:     Return DNSKEY ``Rdata``.
  685:     """
  686: 
  687:     algorithm = Algorithm.make(algorithm)
  688: 
  689:     if isinstance(public_key, GenericPublicKey):
  690:         return public_key.to_dnskey(flags=flags, protocol=protocol)
  691:     else:
  692:         public_cls = get_algorithm_cls(algorithm).public_cls
  693:         return public_cls(key=public_key).to_dnskey(flags=flags, protocol=protocol)
  694: 
  695: 
  696: def _make_cdnskey(
  697:     public_key: PublicKey,
  698:     algorithm: Union[int, str],
  699:     flags: int = Flag.ZONE,
  700:     protocol: int = 3,
  701: ) -> CDNSKEY:
  702:     """Convert a public key to CDNSKEY Rdata
  703: 
  704:     *public_key*, the public key to convert, a
  705:     ``cryptography.hazmat.primitives.asymmetric`` public key class applicable
  706:     for DNSSEC.
  707: 
  708:     *algorithm*, a ``str`` or ``int`` specifying the DNSKEY algorithm.
  709: 
  710:     *flags*: DNSKEY flags field as an integer.
  711: 
  712:     *protocol*: DNSKEY protocol field as an integer.
  713: 
  714:     Raises ``ValueError`` if the specified key algorithm parameters are not
  715:     unsupported, ``TypeError`` if the key type is unsupported,
  716:     `UnsupportedAlgorithm` if the algorithm is unknown and
  717:     `AlgorithmKeyMismatch` if the algorithm does not match the key type.
  718: 
  719:     Return CDNSKEY ``Rdata``.
  720:     """
  721: 
  722:     dnskey = _make_dnskey(public_key, algorithm, flags, protocol)
  723: 
  724:     return CDNSKEY(
  725:         rdclass=dnskey.rdclass,
  726:         rdtype=dns.rdatatype.CDNSKEY,
  727:         flags=dnskey.flags,
  728:         protocol=dnskey.protocol,
  729:         algorithm=dnskey.algorithm,
  730:         key=dnskey.key,
  731:     )
  732: 
  733: 
  734: def nsec3_hash(
  735:     domain: Union[dns.name.Name, str],
  736:     salt: Optional[Union[str, bytes]],
  737:     iterations: int,
  738:     algorithm: Union[int, str],
  739: ) -> str:
  740:     """
  741:     Calculate the NSEC3 hash, according to
  742:     https://tools.ietf.org/html/rfc5155#section-5
  743: 
  744:     *domain*, a ``dns.name.Name`` or ``str``, the name to hash.
  745: 
  746:     *salt*, a ``str``, ``bytes``, or ``None``, the hash salt.  If a
  747:     string, it is decoded as a hex string.
  748: 
  749:     *iterations*, an ``int``, the number of iterations.
  750: 
  751:     *algorithm*, a ``str`` or ``int``, the hash algorithm.
  752:     The only defined algorithm is SHA1.
  753: 
  754:     Returns a ``str``, the encoded NSEC3 hash.
  755:     """
  756: 
  757:     b32_conversion = str.maketrans(
  758:         "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", "0123456789ABCDEFGHIJKLMNOPQRSTUV"
  759:     )
  760: 
  761:     try:
  762:         if isinstance(algorithm, str):
  763:             algorithm = NSEC3Hash[algorithm.upper()]
  764:     except Exception:
  765:         raise ValueError("Wrong hash algorithm (only SHA1 is supported)")
  766: 
  767:     if algorithm != NSEC3Hash.SHA1:
  768:         raise ValueError("Wrong hash algorithm (only SHA1 is supported)")
  769: 
  770:     if salt is None:
  771:         salt_encoded = b""
  772:     elif isinstance(salt, str):
  773:         if len(salt) % 2 == 0:
  774:             salt_encoded = bytes.fromhex(salt)
  775:         else:
  776:             raise ValueError("Invalid salt length")
  777:     else:
  778:         salt_encoded = salt
  779: 
  780:     if not isinstance(domain, dns.name.Name):
  781:         domain = dns.name.from_text(domain)
  782:     domain_encoded = domain.canonicalize().to_wire()
  783:     assert domain_encoded is not None
  784: 
  785:     digest = hashlib.sha1(domain_encoded + salt_encoded).digest()
  786:     for _ in range(iterations):
  787:         digest = hashlib.sha1(digest + salt_encoded).digest()
  788: 
  789:     output = base64.b32encode(digest).decode("utf-8")
  790:     output = output.translate(b32_conversion)
  791: 
  792:     return output
  793: 
  794: 
  795: def make_ds_rdataset(
  796:     rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.rdataset.Rdataset]],
  797:     algorithms: Set[Union[DSDigest, str]],
  798:     origin: Optional[dns.name.Name] = None,
  799: ) -> dns.rdataset.Rdataset:
  800:     """Create a DS record from DNSKEY/CDNSKEY/CDS.
  801: 
  802:     *rrset*, the RRset to create DS Rdataset for.  This can be a
  803:     ``dns.rrset.RRset`` or a (``dns.name.Name``, ``dns.rdataset.Rdataset``)
  804:     tuple.
  805: 
  806:     *algorithms*, a set of ``str`` or ``int`` specifying the hash algorithms.
  807:     The currently supported hashes are "SHA1", "SHA256", and "SHA384". Case
  808:     does not matter for these strings. If the RRset is a CDS, only digest
  809:     algorithms matching algorithms are accepted.
  810: 
  811:     *origin*, a ``dns.name.Name`` or ``None``.  If `key` is a relative name,
  812:     then it will be made absolute using the specified origin.
  813: 
  814:     Raises ``UnsupportedAlgorithm`` if any of the algorithms are unknown and
  815:     ``ValueError`` if the given RRset is not usable.
  816: 
  817:     Returns a ``dns.rdataset.Rdataset``
  818:     """
  819: 
  820:     rrname, rdataset = _get_rrname_rdataset(rrset)
  821: 
  822:     if rdataset.rdtype not in (
  823:         dns.rdatatype.DNSKEY,
  824:         dns.rdatatype.CDNSKEY,
  825:         dns.rdatatype.CDS,
  826:     ):
  827:         raise ValueError("rrset not a DNSKEY/CDNSKEY/CDS")
  828: 
  829:     _algorithms = set()
  830:     for algorithm in algorithms:
  831:         try:
  832:             if isinstance(algorithm, str):
  833:                 algorithm = DSDigest[algorithm.upper()]
  834:         except Exception:
  835:             raise UnsupportedAlgorithm('unsupported algorithm "%s"' % algorithm)
  836:         _algorithms.add(algorithm)
  837: 
  838:     if rdataset.rdtype == dns.rdatatype.CDS:
  839:         res = []
  840:         for rdata in cds_rdataset_to_ds_rdataset(rdataset):
  841:             if rdata.digest_type in _algorithms:
  842:                 res.append(rdata)
  843:         if len(res) == 0:
  844:             raise ValueError("no acceptable CDS rdata found")
  845:         return dns.rdataset.from_rdata_list(rdataset.ttl, res)
  846: 
  847:     res = []
  848:     for algorithm in _algorithms:
  849:         res.extend(dnskey_rdataset_to_cds_rdataset(rrname, rdataset, algorithm, origin))
  850:     return dns.rdataset.from_rdata_list(rdataset.ttl, res)
  851: 
  852: 
  853: def cds_rdataset_to_ds_rdataset(
  854:     rdataset: dns.rdataset.Rdataset,
  855: ) -> dns.rdataset.Rdataset:
  856:     """Create a CDS record from DS.
  857: 
  858:     *rdataset*, a ``dns.rdataset.Rdataset``, to create DS Rdataset for.
  859: 
  860:     Raises ``ValueError`` if the rdataset is not CDS.
  861: 
  862:     Returns a ``dns.rdataset.Rdataset``
  863:     """
  864: 
  865:     if rdataset.rdtype != dns.rdatatype.CDS:
  866:         raise ValueError("rdataset not a CDS")
  867:     res = []
  868:     for rdata in rdataset:
  869:         res.append(
  870:             CDS(
  871:                 rdclass=rdata.rdclass,
  872:                 rdtype=dns.rdatatype.DS,
  873:                 key_tag=rdata.key_tag,
  874:                 algorithm=rdata.algorithm,
  875:                 digest_type=rdata.digest_type,
  876:                 digest=rdata.digest,
  877:             )
  878:         )
  879:     return dns.rdataset.from_rdata_list(rdataset.ttl, res)
  880: 
  881: 
  882: def dnskey_rdataset_to_cds_rdataset(
  883:     name: Union[dns.name.Name, str],
  884:     rdataset: dns.rdataset.Rdataset,
  885:     algorithm: Union[DSDigest, str],
  886:     origin: Optional[dns.name.Name] = None,
  887: ) -> dns.rdataset.Rdataset:
  888:     """Create a CDS record from DNSKEY/CDNSKEY.
  889: 
  890:     *name*, a ``dns.name.Name`` or ``str``, the owner name of the CDS record.
  891: 
  892:     *rdataset*, a ``dns.rdataset.Rdataset``, to create DS Rdataset for.
  893: 
  894:     *algorithm*, a ``str`` or ``int`` specifying the hash algorithm.
  895:     The currently supported hashes are "SHA1", "SHA256", and "SHA384". Case
  896:     does not matter for these strings.
  897: 
  898:     *origin*, a ``dns.name.Name`` or ``None``.  If `key` is a relative name,
  899:     then it will be made absolute using the specified origin.
  900: 
  901:     Raises ``UnsupportedAlgorithm`` if the algorithm is unknown or
  902:     ``ValueError`` if the rdataset is not DNSKEY/CDNSKEY.
  903: 
  904:     Returns a ``dns.rdataset.Rdataset``
  905:     """
  906: 
  907:     if rdataset.rdtype not in (dns.rdatatype.DNSKEY, dns.rdatatype.CDNSKEY):
  908:         raise ValueError("rdataset not a DNSKEY/CDNSKEY")
  909:     res = []
  910:     for rdata in rdataset:
  911:         res.append(make_cds(name, rdata, algorithm, origin))
  912:     return dns.rdataset.from_rdata_list(rdataset.ttl, res)
  913: 
  914: 
  915: def dnskey_rdataset_to_cdnskey_rdataset(
  916:     rdataset: dns.rdataset.Rdataset,
  917: ) -> dns.rdataset.Rdataset:
  918:     """Create a CDNSKEY record from DNSKEY.
  919: 
  920:     *rdataset*, a ``dns.rdataset.Rdataset``, to create CDNSKEY Rdataset for.
  921: 
  922:     Returns a ``dns.rdataset.Rdataset``
  923:     """
  924: 
  925:     if rdataset.rdtype != dns.rdatatype.DNSKEY:
  926:         raise ValueError("rdataset not a DNSKEY")
  927:     res = []
  928:     for rdata in rdataset:
  929:         res.append(
  930:             CDNSKEY(
  931:                 rdclass=rdataset.rdclass,
  932:                 rdtype=rdataset.rdtype,
  933:                 flags=rdata.flags,
  934:                 protocol=rdata.protocol,
  935:                 algorithm=rdata.algorithm,
  936:                 key=rdata.key,
  937:             )
  938:         )
  939:     return dns.rdataset.from_rdata_list(rdataset.ttl, res)
  940: 
  941: 
  942: def default_rrset_signer(
  943:     txn: dns.transaction.Transaction,
  944:     rrset: dns.rrset.RRset,
  945:     signer: dns.name.Name,
  946:     ksks: List[Tuple[PrivateKey, DNSKEY]],
  947:     zsks: List[Tuple[PrivateKey, DNSKEY]],
  948:     inception: Optional[Union[datetime, str, int, float]] = None,
  949:     expiration: Optional[Union[datetime, str, int, float]] = None,
  950:     lifetime: Optional[int] = None,
  951:     policy: Optional[Policy] = None,
  952:     origin: Optional[dns.name.Name] = None,
  953: ) -> None:
  954:     """Default RRset signer"""
  955: 
  956:     if rrset.rdtype in set(
  957:         [
  958:             dns.rdatatype.RdataType.DNSKEY,
  959:             dns.rdatatype.RdataType.CDS,
  960:             dns.rdatatype.RdataType.CDNSKEY,
  961:         ]
  962:     ):
  963:         keys = ksks
  964:     else:
  965:         keys = zsks
  966: 
  967:     for private_key, dnskey in keys:
  968:         rrsig = dns.dnssec.sign(
  969:             rrset=rrset,
  970:             private_key=private_key,
  971:             dnskey=dnskey,
  972:             inception=inception,
  973:             expiration=expiration,
  974:             lifetime=lifetime,
  975:             signer=signer,
  976:             policy=policy,
  977:             origin=origin,
  978:         )
  979:         txn.add(rrset.name, rrset.ttl, rrsig)
  980: 
  981: 
  982: def sign_zone(
  983:     zone: dns.zone.Zone,
  984:     txn: Optional[dns.transaction.Transaction] = None,
  985:     keys: Optional[List[Tuple[PrivateKey, DNSKEY]]] = None,
  986:     add_dnskey: bool = True,
  987:     dnskey_ttl: Optional[int] = None,
  988:     inception: Optional[Union[datetime, str, int, float]] = None,
  989:     expiration: Optional[Union[datetime, str, int, float]] = None,
  990:     lifetime: Optional[int] = None,
  991:     nsec3: Optional[NSEC3PARAM] = None,
  992:     rrset_signer: Optional[RRsetSigner] = None,
  993:     policy: Optional[Policy] = None,
  994: ) -> None:
  995:     """Sign zone.
  996: 
  997:     *zone*, a ``dns.zone.Zone``, the zone to sign.
  998: 
  999:     *txn*, a ``dns.transaction.Transaction``, an optional transaction to use for
 1000:     signing.
 1001: 
 1002:     *keys*, a list of (``PrivateKey``, ``DNSKEY``) tuples, to use for signing. KSK/ZSK
 1003:     roles are assigned automatically if the SEP flag is used, otherwise all RRsets are
 1004:     signed by all keys.
 1005: 
 1006:     *add_dnskey*, a ``bool``.  If ``True``, the default, all specified DNSKEYs are
 1007:     automatically added to the zone on signing.
 1008: 
 1009:     *dnskey_ttl*, a``int``, specifies the TTL for DNSKEY RRs. If not specified the TTL
 1010:     of the existing DNSKEY RRset used or the TTL of the SOA RRset.
 1011: 
 1012:     *inception*, a ``datetime``, ``str``, ``int``, ``float`` or ``None``, the signature
 1013:     inception time.  If ``None``, the current time is used.  If a ``str``, the format is
 1014:     "YYYYMMDDHHMMSS" or alternatively the number of seconds since the UNIX epoch in text
 1015:     form; this is the same the RRSIG rdata's text form. Values of type `int` or `float`
 1016:     are interpreted as seconds since the UNIX epoch.
 1017: 
 1018:     *expiration*, a ``datetime``, ``str``, ``int``, ``float`` or ``None``, the signature
 1019:     expiration time.  If ``None``, the expiration time will be the inception time plus
 1020:     the value of the *lifetime* parameter.  See the description of *inception* above for
 1021:     how the various parameter types are interpreted.
 1022: 
 1023:     *lifetime*, an ``int`` or ``None``, the signature lifetime in seconds.  This
 1024:     parameter is only meaningful if *expiration* is ``None``.
 1025: 
 1026:     *nsec3*, a ``NSEC3PARAM`` Rdata, configures signing using NSEC3. Not yet
 1027:     implemented.
 1028: 
 1029:     *rrset_signer*, a ``Callable``, an optional function for signing RRsets. The
 1030:     function requires two arguments: transaction and RRset. If the not specified,
 1031:     ``dns.dnssec.default_rrset_signer`` will be used.
 1032: 
 1033:     Returns ``None``.
 1034:     """
 1035: 
 1036:     ksks = []
 1037:     zsks = []
 1038: 
 1039:     # if we have both KSKs and ZSKs, split by SEP flag. if not, sign all
 1040:     # records with all keys
 1041:     if keys:
 1042:         for key in keys:
 1043:             if key[1].flags & Flag.SEP:
 1044:                 ksks.append(key)
 1045:             else:
 1046:                 zsks.append(key)
 1047:         if not ksks:
 1048:             ksks = keys
 1049:         if not zsks:
 1050:             zsks = keys
 1051:     else:
 1052:         keys = []
 1053: 
 1054:     if txn:
 1055:         cm: contextlib.AbstractContextManager = contextlib.nullcontext(txn)
 1056:     else:
 1057:         cm = zone.writer()
 1058: 
 1059:     with cm as _txn:
 1060:         if add_dnskey:
 1061:             if dnskey_ttl is None:
 1062:                 dnskey = _txn.get(zone.origin, dns.rdatatype.DNSKEY)
 1063:                 if dnskey:
 1064:                     dnskey_ttl = dnskey.ttl
 1065:                 else:
 1066:                     soa = _txn.get(zone.origin, dns.rdatatype.SOA)
 1067:                     dnskey_ttl = soa.ttl
 1068:             for _, dnskey in keys:
 1069:                 _txn.add(zone.origin, dnskey_ttl, dnskey)
 1070: 
 1071:         if nsec3:
 1072:             raise NotImplementedError("Signing with NSEC3 not yet implemented")
 1073:         else:
 1074:             _rrset_signer = rrset_signer or functools.partial(
 1075:                 default_rrset_signer,
 1076:                 signer=zone.origin,
 1077:                 ksks=ksks,
 1078:                 zsks=zsks,
 1079:                 inception=inception,
 1080:                 expiration=expiration,
 1081:                 lifetime=lifetime,
 1082:                 policy=policy,
 1083:                 origin=zone.origin,
 1084:             )
 1085:             return _sign_zone_nsec(zone, _txn, _rrset_signer)
 1086: 
 1087: 
 1088: def _sign_zone_nsec(
 1089:     zone: dns.zone.Zone,
 1090:     txn: dns.transaction.Transaction,
 1091:     rrset_signer: Optional[RRsetSigner] = None,
 1092: ) -> None:
 1093:     """NSEC zone signer"""
 1094: 
 1095:     def _txn_add_nsec(
 1096:         txn: dns.transaction.Transaction,
 1097:         name: dns.name.Name,
 1098:         next_secure: Optional[dns.name.Name],
 1099:         rdclass: dns.rdataclass.RdataClass,
 1100:         ttl: int,
 1101:         rrset_signer: Optional[RRsetSigner] = None,
 1102:     ) -> None:
 1103:         """NSEC zone signer helper"""
 1104:         mandatory_types = set(
 1105:             [dns.rdatatype.RdataType.RRSIG, dns.rdatatype.RdataType.NSEC]
 1106:         )
 1107:         node = txn.get_node(name)
 1108:         if node and next_secure:
 1109:             types = (
 1110:                 set([rdataset.rdtype for rdataset in node.rdatasets]) | mandatory_types
 1111:             )
 1112:             windows = Bitmap.from_rdtypes(list(types))
 1113:             rrset = dns.rrset.from_rdata(
 1114:                 name,
 1115:                 ttl,
 1116:                 NSEC(
 1117:                     rdclass=rdclass,
 1118:                     rdtype=dns.rdatatype.RdataType.NSEC,
 1119:                     next=next_secure,
 1120:                     windows=windows,
 1121:                 ),
 1122:             )
 1123:             txn.add(rrset)
 1124:             if rrset_signer:
 1125:                 rrset_signer(txn, rrset)
 1126: 
 1127:     rrsig_ttl = zone.get_soa().minimum
 1128:     delegation = None
 1129:     last_secure = None
 1130: 
 1131:     for name in sorted(txn.iterate_names()):
 1132:         if delegation and name.is_subdomain(delegation):
 1133:             # names below delegations are not secure
 1134:             continue
 1135:         elif txn.get(name, dns.rdatatype.NS) and name != zone.origin:
 1136:             # inside delegation
 1137:             delegation = name
 1138:         else:
 1139:             # outside delegation
 1140:             delegation = None
 1141: 
 1142:         if rrset_signer:
 1143:             node = txn.get_node(name)
 1144:             if node:
 1145:                 for rdataset in node.rdatasets:
 1146:                     if rdataset.rdtype == dns.rdatatype.RRSIG:
 1147:                         # do not sign RRSIGs
 1148:                         continue
 1149:                     elif delegation and rdataset.rdtype != dns.rdatatype.DS:
 1150:                         # do not sign delegations except DS records
 1151:                         continue
 1152:                     else:
 1153:                         rrset = dns.rrset.from_rdata(name, rdataset.ttl, *rdataset)
 1154:                         rrset_signer(txn, rrset)
 1155: 
 1156:         # We need "is not None" as the empty name is False because its length is 0.
 1157:         if last_secure is not None:
 1158:             _txn_add_nsec(txn, last_secure, name, zone.rdclass, rrsig_ttl, rrset_signer)
 1159:         last_secure = name
 1160: 
 1161:     if last_secure:
 1162:         _txn_add_nsec(
 1163:             txn, last_secure, zone.origin, zone.rdclass, rrsig_ttl, rrset_signer
 1164:         )
 1165: 
 1166: 
 1167: def _need_pyca(*args, **kwargs):
 1168:     raise ImportError(
 1169:         "DNSSEC validation requires python cryptography"
 1170:     )  # pragma: no cover
 1171: 
 1172: 
 1173: if dns._features.have("dnssec"):
 1174:     from cryptography.exceptions import InvalidSignature
 1175:     from cryptography.hazmat.primitives.asymmetric import dsa  # pylint: disable=W0611
 1176:     from cryptography.hazmat.primitives.asymmetric import ec  # pylint: disable=W0611
 1177:     from cryptography.hazmat.primitives.asymmetric import ed448  # pylint: disable=W0611
 1178:     from cryptography.hazmat.primitives.asymmetric import rsa  # pylint: disable=W0611
 1179:     from cryptography.hazmat.primitives.asymmetric import (  # pylint: disable=W0611
 1180:         ed25519,
 1181:     )
 1182: 
 1183:     from dns.dnssecalgs import (  # pylint: disable=C0412
 1184:         get_algorithm_cls,
 1185:         get_algorithm_cls_from_dnskey,
 1186:     )
 1187:     from dns.dnssecalgs.base import GenericPrivateKey, GenericPublicKey
 1188: 
 1189:     validate = _validate  # type: ignore
 1190:     validate_rrsig = _validate_rrsig  # type: ignore
 1191:     sign = _sign
 1192:     make_dnskey = _make_dnskey
 1193:     make_cdnskey = _make_cdnskey
 1194:     _have_pyca = True
 1195: else:  # pragma: no cover
 1196:     validate = _need_pyca
 1197:     validate_rrsig = _need_pyca
 1198:     sign = _need_pyca
 1199:     make_dnskey = _need_pyca
 1200:     make_cdnskey = _need_pyca
 1201:     _have_pyca = False
 1202: 
 1203: ### BEGIN generated Algorithm constants
 1204: 
 1205: RSAMD5 = Algorithm.RSAMD5
 1206: DH = Algorithm.DH
 1207: DSA = Algorithm.DSA
 1208: ECC = Algorithm.ECC
 1209: RSASHA1 = Algorithm.RSASHA1
 1210: DSANSEC3SHA1 = Algorithm.DSANSEC3SHA1
 1211: RSASHA1NSEC3SHA1 = Algorithm.RSASHA1NSEC3SHA1
 1212: RSASHA256 = Algorithm.RSASHA256
 1213: RSASHA512 = Algorithm.RSASHA512
 1214: ECCGOST = Algorithm.ECCGOST
 1215: ECDSAP256SHA256 = Algorithm.ECDSAP256SHA256
 1216: ECDSAP384SHA384 = Algorithm.ECDSAP384SHA384
 1217: ED25519 = Algorithm.ED25519
 1218: ED448 = Algorithm.ED448
 1219: INDIRECT = Algorithm.INDIRECT
 1220: PRIVATEDNS = Algorithm.PRIVATEDNS
 1221: PRIVATEOID = Algorithm.PRIVATEOID
 1222: 
 1223: ### END generated Algorithm constants
