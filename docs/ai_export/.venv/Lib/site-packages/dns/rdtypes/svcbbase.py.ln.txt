    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: import base64
    4: import enum
    5: import struct
    6: 
    7: import dns.enum
    8: import dns.exception
    9: import dns.immutable
   10: import dns.ipv4
   11: import dns.ipv6
   12: import dns.name
   13: import dns.rdata
   14: import dns.rdtypes.util
   15: import dns.renderer
   16: import dns.tokenizer
   17: import dns.wire
   18: 
   19: # Until there is an RFC, this module is experimental and may be changed in
   20: # incompatible ways.
   21: 
   22: 
   23: class UnknownParamKey(dns.exception.DNSException):
   24:     """Unknown SVCB ParamKey"""
   25: 
   26: 
   27: class ParamKey(dns.enum.IntEnum):
   28:     """SVCB ParamKey"""
   29: 
   30:     MANDATORY = 0
   31:     ALPN = 1
   32:     NO_DEFAULT_ALPN = 2
   33:     PORT = 3
   34:     IPV4HINT = 4
   35:     ECH = 5
   36:     IPV6HINT = 6
   37:     DOHPATH = 7
   38: 
   39:     @classmethod
   40:     def _maximum(cls):
   41:         return 65535
   42: 
   43:     @classmethod
   44:     def _short_name(cls):
   45:         return "SVCBParamKey"
   46: 
   47:     @classmethod
   48:     def _prefix(cls):
   49:         return "KEY"
   50: 
   51:     @classmethod
   52:     def _unknown_exception_class(cls):
   53:         return UnknownParamKey
   54: 
   55: 
   56: class Emptiness(enum.IntEnum):
   57:     NEVER = 0
   58:     ALWAYS = 1
   59:     ALLOWED = 2
   60: 
   61: 
   62: def _validate_key(key):
   63:     force_generic = False
   64:     if isinstance(key, bytes):
   65:         # We decode to latin-1 so we get 0-255 as valid and do NOT interpret
   66:         # UTF-8 sequences
   67:         key = key.decode("latin-1")
   68:     if isinstance(key, str):
   69:         if key.lower().startswith("key"):
   70:             force_generic = True
   71:             if key[3:].startswith("0") and len(key) != 4:
   72:                 # key has leading zeros
   73:                 raise ValueError("leading zeros in key")
   74:         key = key.replace("-", "_")
   75:     return (ParamKey.make(key), force_generic)
   76: 
   77: 
   78: def key_to_text(key):
   79:     return ParamKey.to_text(key).replace("_", "-").lower()
   80: 
   81: 
   82: # Like rdata escapify, but escapes ',' too.
   83: 
   84: _escaped = b'",\\'
   85: 
   86: 
   87: def _escapify(qstring):
   88:     text = ""
   89:     for c in qstring:
   90:         if c in _escaped:
   91:             text += "\\" + chr(c)
   92:         elif c >= 0x20 and c < 0x7F:
   93:             text += chr(c)
   94:         else:
   95:             text += "\\%03d" % c
   96:     return text
   97: 
   98: 
   99: def _unescape(value):
  100:     if value == "":
  101:         return value
  102:     unescaped = b""
  103:     l = len(value)
  104:     i = 0
  105:     while i < l:
  106:         c = value[i]
  107:         i += 1
  108:         if c == "\\":
  109:             if i >= l:  # pragma: no cover   (can't happen via tokenizer get())
  110:                 raise dns.exception.UnexpectedEnd
  111:             c = value[i]
  112:             i += 1
  113:             if c.isdigit():
  114:                 if i >= l:
  115:                     raise dns.exception.UnexpectedEnd
  116:                 c2 = value[i]
  117:                 i += 1
  118:                 if i >= l:
  119:                     raise dns.exception.UnexpectedEnd
  120:                 c3 = value[i]
  121:                 i += 1
  122:                 if not (c2.isdigit() and c3.isdigit()):
  123:                     raise dns.exception.SyntaxError
  124:                 codepoint = int(c) * 100 + int(c2) * 10 + int(c3)
  125:                 if codepoint > 255:
  126:                     raise dns.exception.SyntaxError
  127:                 unescaped += b"%c" % (codepoint)
  128:                 continue
  129:         unescaped += c.encode()
  130:     return unescaped
  131: 
  132: 
  133: def _split(value):
  134:     l = len(value)
  135:     i = 0
  136:     items = []
  137:     unescaped = b""
  138:     while i < l:
  139:         c = value[i]
  140:         i += 1
  141:         if c == ord("\\"):
  142:             if i >= l:  # pragma: no cover   (can't happen via tokenizer get())
  143:                 raise dns.exception.UnexpectedEnd
  144:             c = value[i]
  145:             i += 1
  146:             unescaped += b"%c" % (c)
  147:         elif c == ord(","):
  148:             items.append(unescaped)
  149:             unescaped = b""
  150:         else:
  151:             unescaped += b"%c" % (c)
  152:     items.append(unescaped)
  153:     return items
  154: 
  155: 
  156: @dns.immutable.immutable
  157: class Param:
  158:     """Abstract base class for SVCB parameters"""
  159: 
  160:     @classmethod
  161:     def emptiness(cls):
  162:         return Emptiness.NEVER
  163: 
  164: 
  165: @dns.immutable.immutable
  166: class GenericParam(Param):
  167:     """Generic SVCB parameter"""
  168: 
  169:     def __init__(self, value):
  170:         self.value = dns.rdata.Rdata._as_bytes(value, True)
  171: 
  172:     @classmethod
  173:     def emptiness(cls):
  174:         return Emptiness.ALLOWED
  175: 
  176:     @classmethod
  177:     def from_value(cls, value):
  178:         if value is None or len(value) == 0:
  179:             return None
  180:         else:
  181:             return cls(_unescape(value))
  182: 
  183:     def to_text(self):
  184:         return '"' + dns.rdata._escapify(self.value) + '"'
  185: 
  186:     @classmethod
  187:     def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613
  188:         value = parser.get_bytes(parser.remaining())
  189:         if len(value) == 0:
  190:             return None
  191:         else:
  192:             return cls(value)
  193: 
  194:     def to_wire(self, file, origin=None):  # pylint: disable=W0613
  195:         file.write(self.value)
  196: 
  197: 
  198: @dns.immutable.immutable
  199: class MandatoryParam(Param):
  200:     def __init__(self, keys):
  201:         # check for duplicates
  202:         keys = sorted([_validate_key(key)[0] for key in keys])
  203:         prior_k = None
  204:         for k in keys:
  205:             if k == prior_k:
  206:                 raise ValueError(f"duplicate key {k:d}")
  207:             prior_k = k
  208:             if k == ParamKey.MANDATORY:
  209:                 raise ValueError("listed the mandatory key as mandatory")
  210:         self.keys = tuple(keys)
  211: 
  212:     @classmethod
  213:     def from_value(cls, value):
  214:         keys = [k.encode() for k in value.split(",")]
  215:         return cls(keys)
  216: 
  217:     def to_text(self):
  218:         return '"' + ",".join([key_to_text(key) for key in self.keys]) + '"'
  219: 
  220:     @classmethod
  221:     def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613
  222:         keys = []
  223:         last_key = -1
  224:         while parser.remaining() > 0:
  225:             key = parser.get_uint16()
  226:             if key < last_key:
  227:                 raise dns.exception.FormError("manadatory keys not ascending")
  228:             last_key = key
  229:             keys.append(key)
  230:         return cls(keys)
  231: 
  232:     def to_wire(self, file, origin=None):  # pylint: disable=W0613
  233:         for key in self.keys:
  234:             file.write(struct.pack("!H", key))
  235: 
  236: 
  237: @dns.immutable.immutable
  238: class ALPNParam(Param):
  239:     def __init__(self, ids):
  240:         self.ids = dns.rdata.Rdata._as_tuple(
  241:             ids, lambda x: dns.rdata.Rdata._as_bytes(x, True, 255, False)
  242:         )
  243: 
  244:     @classmethod
  245:     def from_value(cls, value):
  246:         return cls(_split(_unescape(value)))
  247: 
  248:     def to_text(self):
  249:         value = ",".join([_escapify(id) for id in self.ids])
  250:         return '"' + dns.rdata._escapify(value.encode()) + '"'
  251: 
  252:     @classmethod
  253:     def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613
  254:         ids = []
  255:         while parser.remaining() > 0:
  256:             id = parser.get_counted_bytes()
  257:             ids.append(id)
  258:         return cls(ids)
  259: 
  260:     def to_wire(self, file, origin=None):  # pylint: disable=W0613
  261:         for id in self.ids:
  262:             file.write(struct.pack("!B", len(id)))
  263:             file.write(id)
  264: 
  265: 
  266: @dns.immutable.immutable
  267: class NoDefaultALPNParam(Param):
  268:     # We don't ever expect to instantiate this class, but we need
  269:     # a from_value() and a from_wire_parser(), so we just return None
  270:     # from the class methods when things are OK.
  271: 
  272:     @classmethod
  273:     def emptiness(cls):
  274:         return Emptiness.ALWAYS
  275: 
  276:     @classmethod
  277:     def from_value(cls, value):
  278:         if value is None or value == "":
  279:             return None
  280:         else:
  281:             raise ValueError("no-default-alpn with non-empty value")
  282: 
  283:     def to_text(self):
  284:         raise NotImplementedError  # pragma: no cover
  285: 
  286:     @classmethod
  287:     def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613
  288:         if parser.remaining() != 0:
  289:             raise dns.exception.FormError
  290:         return None
  291: 
  292:     def to_wire(self, file, origin=None):  # pylint: disable=W0613
  293:         raise NotImplementedError  # pragma: no cover
  294: 
  295: 
  296: @dns.immutable.immutable
  297: class PortParam(Param):
  298:     def __init__(self, port):
  299:         self.port = dns.rdata.Rdata._as_uint16(port)
  300: 
  301:     @classmethod
  302:     def from_value(cls, value):
  303:         value = int(value)
  304:         return cls(value)
  305: 
  306:     def to_text(self):
  307:         return f'"{self.port}"'
  308: 
  309:     @classmethod
  310:     def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613
  311:         port = parser.get_uint16()
  312:         return cls(port)
  313: 
  314:     def to_wire(self, file, origin=None):  # pylint: disable=W0613
  315:         file.write(struct.pack("!H", self.port))
  316: 
  317: 
  318: @dns.immutable.immutable
  319: class IPv4HintParam(Param):
  320:     def __init__(self, addresses):
  321:         self.addresses = dns.rdata.Rdata._as_tuple(
  322:             addresses, dns.rdata.Rdata._as_ipv4_address
  323:         )
  324: 
  325:     @classmethod
  326:     def from_value(cls, value):
  327:         addresses = value.split(",")
  328:         return cls(addresses)
  329: 
  330:     def to_text(self):
  331:         return '"' + ",".join(self.addresses) + '"'
  332: 
  333:     @classmethod
  334:     def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613
  335:         addresses = []
  336:         while parser.remaining() > 0:
  337:             ip = parser.get_bytes(4)
  338:             addresses.append(dns.ipv4.inet_ntoa(ip))
  339:         return cls(addresses)
  340: 
  341:     def to_wire(self, file, origin=None):  # pylint: disable=W0613
  342:         for address in self.addresses:
  343:             file.write(dns.ipv4.inet_aton(address))
  344: 
  345: 
  346: @dns.immutable.immutable
  347: class IPv6HintParam(Param):
  348:     def __init__(self, addresses):
  349:         self.addresses = dns.rdata.Rdata._as_tuple(
  350:             addresses, dns.rdata.Rdata._as_ipv6_address
  351:         )
  352: 
  353:     @classmethod
  354:     def from_value(cls, value):
  355:         addresses = value.split(",")
  356:         return cls(addresses)
  357: 
  358:     def to_text(self):
  359:         return '"' + ",".join(self.addresses) + '"'
  360: 
  361:     @classmethod
  362:     def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613
  363:         addresses = []
  364:         while parser.remaining() > 0:
  365:             ip = parser.get_bytes(16)
  366:             addresses.append(dns.ipv6.inet_ntoa(ip))
  367:         return cls(addresses)
  368: 
  369:     def to_wire(self, file, origin=None):  # pylint: disable=W0613
  370:         for address in self.addresses:
  371:             file.write(dns.ipv6.inet_aton(address))
  372: 
  373: 
  374: @dns.immutable.immutable
  375: class ECHParam(Param):
  376:     def __init__(self, ech):
  377:         self.ech = dns.rdata.Rdata._as_bytes(ech, True)
  378: 
  379:     @classmethod
  380:     def from_value(cls, value):
  381:         if "\\" in value:
  382:             raise ValueError("escape in ECH value")
  383:         value = base64.b64decode(value.encode())
  384:         return cls(value)
  385: 
  386:     def to_text(self):
  387:         b64 = base64.b64encode(self.ech).decode("ascii")
  388:         return f'"{b64}"'
  389: 
  390:     @classmethod
  391:     def from_wire_parser(cls, parser, origin=None):  # pylint: disable=W0613
  392:         value = parser.get_bytes(parser.remaining())
  393:         return cls(value)
  394: 
  395:     def to_wire(self, file, origin=None):  # pylint: disable=W0613
  396:         file.write(self.ech)
  397: 
  398: 
  399: _class_for_key = {
  400:     ParamKey.MANDATORY: MandatoryParam,
  401:     ParamKey.ALPN: ALPNParam,
  402:     ParamKey.NO_DEFAULT_ALPN: NoDefaultALPNParam,
  403:     ParamKey.PORT: PortParam,
  404:     ParamKey.IPV4HINT: IPv4HintParam,
  405:     ParamKey.ECH: ECHParam,
  406:     ParamKey.IPV6HINT: IPv6HintParam,
  407: }
  408: 
  409: 
  410: def _validate_and_define(params, key, value):
  411:     (key, force_generic) = _validate_key(_unescape(key))
  412:     if key in params:
  413:         raise SyntaxError(f'duplicate key "{key:d}"')
  414:     cls = _class_for_key.get(key, GenericParam)
  415:     emptiness = cls.emptiness()
  416:     if value is None:
  417:         if emptiness == Emptiness.NEVER:
  418:             raise SyntaxError("value cannot be empty")
  419:         value = cls.from_value(value)
  420:     else:
  421:         if force_generic:
  422:             value = cls.from_wire_parser(dns.wire.Parser(_unescape(value)))
  423:         else:
  424:             value = cls.from_value(value)
  425:     params[key] = value
  426: 
  427: 
  428: @dns.immutable.immutable
  429: class SVCBBase(dns.rdata.Rdata):
  430:     """Base class for SVCB-like records"""
  431: 
  432:     # see: draft-ietf-dnsop-svcb-https-11
  433: 
  434:     __slots__ = ["priority", "target", "params"]
  435: 
  436:     def __init__(self, rdclass, rdtype, priority, target, params):
  437:         super().__init__(rdclass, rdtype)
  438:         self.priority = self._as_uint16(priority)
  439:         self.target = self._as_name(target)
  440:         for k, v in params.items():
  441:             k = ParamKey.make(k)
  442:             if not isinstance(v, Param) and v is not None:
  443:                 raise ValueError(f"{k:d} not a Param")
  444:         self.params = dns.immutable.Dict(params)
  445:         # Make sure any parameter listed as mandatory is present in the
  446:         # record.
  447:         mandatory = params.get(ParamKey.MANDATORY)
  448:         if mandatory:
  449:             for key in mandatory.keys:
  450:                 # Note we have to say "not in" as we have None as a value
  451:                 # so a get() and a not None test would be wrong.
  452:                 if key not in params:
  453:                     raise ValueError(f"key {key:d} declared mandatory but not present")
  454:         # The no-default-alpn parameter requires the alpn parameter.
  455:         if ParamKey.NO_DEFAULT_ALPN in params:
  456:             if ParamKey.ALPN not in params:
  457:                 raise ValueError("no-default-alpn present, but alpn missing")
  458: 
  459:     def to_text(self, origin=None, relativize=True, **kw):
  460:         target = self.target.choose_relativity(origin, relativize)
  461:         params = []
  462:         for key in sorted(self.params.keys()):
  463:             value = self.params[key]
  464:             if value is None:
  465:                 params.append(key_to_text(key))
  466:             else:
  467:                 kv = key_to_text(key) + "=" + value.to_text()
  468:                 params.append(kv)
  469:         if len(params) > 0:
  470:             space = " "
  471:         else:
  472:             space = ""
  473:         return "%d %s%s%s" % (self.priority, target, space, " ".join(params))
  474: 
  475:     @classmethod
  476:     def from_text(
  477:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
  478:     ):
  479:         priority = tok.get_uint16()
  480:         target = tok.get_name(origin, relativize, relativize_to)
  481:         if priority == 0:
  482:             token = tok.get()
  483:             if not token.is_eol_or_eof():
  484:                 raise SyntaxError("parameters in AliasMode")
  485:             tok.unget(token)
  486:         params = {}
  487:         while True:
  488:             token = tok.get()
  489:             if token.is_eol_or_eof():
  490:                 tok.unget(token)
  491:                 break
  492:             if token.ttype != dns.tokenizer.IDENTIFIER:
  493:                 raise SyntaxError("parameter is not an identifier")
  494:             equals = token.value.find("=")
  495:             if equals == len(token.value) - 1:
  496:                 # 'key=', so next token should be a quoted string without
  497:                 # any intervening whitespace.
  498:                 key = token.value[:-1]
  499:                 token = tok.get(want_leading=True)
  500:                 if token.ttype != dns.tokenizer.QUOTED_STRING:
  501:                     raise SyntaxError("whitespace after =")
  502:                 value = token.value
  503:             elif equals > 0:
  504:                 # key=value
  505:                 key = token.value[:equals]
  506:                 value = token.value[equals + 1 :]
  507:             elif equals == 0:
  508:                 # =key
  509:                 raise SyntaxError('parameter cannot start with "="')
  510:             else:
  511:                 # key
  512:                 key = token.value
  513:                 value = None
  514:             _validate_and_define(params, key, value)
  515:         return cls(rdclass, rdtype, priority, target, params)
  516: 
  517:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
  518:         file.write(struct.pack("!H", self.priority))
  519:         self.target.to_wire(file, None, origin, False)
  520:         for key in sorted(self.params):
  521:             file.write(struct.pack("!H", key))
  522:             value = self.params[key]
  523:             with dns.renderer.prefixed_length(file, 2):
  524:                 # Note that we're still writing a length of zero if the value is None
  525:                 if value is not None:
  526:                     value.to_wire(file, origin)
  527: 
  528:     @classmethod
  529:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
  530:         priority = parser.get_uint16()
  531:         target = parser.get_name(origin)
  532:         if priority == 0 and parser.remaining() != 0:
  533:             raise dns.exception.FormError("parameters in AliasMode")
  534:         params = {}
  535:         prior_key = -1
  536:         while parser.remaining() > 0:
  537:             key = parser.get_uint16()
  538:             if key < prior_key:
  539:                 raise dns.exception.FormError("keys not in order")
  540:             prior_key = key
  541:             vlen = parser.get_uint16()
  542:             pcls = _class_for_key.get(key, GenericParam)
  543:             with parser.restrict_to(vlen):
  544:                 value = pcls.from_wire_parser(parser, origin)
  545:             params[key] = value
  546:         return cls(rdclass, rdtype, priority, target, params)
  547: 
  548:     def _processing_priority(self):
  549:         return self.priority
  550: 
  551:     @classmethod
  552:     def _processing_order(cls, iterable):
  553:         return dns.rdtypes.util.priority_processing_order(iterable)
