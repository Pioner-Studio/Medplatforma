    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2010, 2011 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import binascii
   19: import struct
   20: 
   21: import dns.dnssectypes
   22: import dns.immutable
   23: import dns.rdata
   24: import dns.rdatatype
   25: 
   26: 
   27: @dns.immutable.immutable
   28: class DSBase(dns.rdata.Rdata):
   29:     """Base class for rdata that is like a DS record"""
   30: 
   31:     __slots__ = ["key_tag", "algorithm", "digest_type", "digest"]
   32: 
   33:     # Digest types registry:
   34:     # https://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml
   35:     _digest_length_by_type = {
   36:         1: 20,  # SHA-1, RFC 3658 Sec. 2.4
   37:         2: 32,  # SHA-256, RFC 4509 Sec. 2.2
   38:         3: 32,  # GOST R 34.11-94, RFC 5933 Sec. 4 in conjunction with RFC 4490 Sec. 2.1
   39:         4: 48,  # SHA-384, RFC 6605 Sec. 2
   40:     }
   41: 
   42:     def __init__(self, rdclass, rdtype, key_tag, algorithm, digest_type, digest):
   43:         super().__init__(rdclass, rdtype)
   44:         self.key_tag = self._as_uint16(key_tag)
   45:         self.algorithm = dns.dnssectypes.Algorithm.make(algorithm)
   46:         self.digest_type = dns.dnssectypes.DSDigest.make(self._as_uint8(digest_type))
   47:         self.digest = self._as_bytes(digest)
   48:         try:
   49:             if len(self.digest) != self._digest_length_by_type[self.digest_type]:
   50:                 raise ValueError("digest length inconsistent with digest type")
   51:         except KeyError:
   52:             if self.digest_type == 0:  # reserved, RFC 3658 Sec. 2.4
   53:                 raise ValueError("digest type 0 is reserved")
   54: 
   55:     def to_text(self, origin=None, relativize=True, **kw):
   56:         kw = kw.copy()
   57:         chunksize = kw.pop("chunksize", 128)
   58:         return "%d %d %d %s" % (
   59:             self.key_tag,
   60:             self.algorithm,
   61:             self.digest_type,
   62:             dns.rdata._hexify(self.digest, chunksize=chunksize, **kw),
   63:         )
   64: 
   65:     @classmethod
   66:     def from_text(
   67:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
   68:     ):
   69:         key_tag = tok.get_uint16()
   70:         algorithm = tok.get_string()
   71:         digest_type = tok.get_uint8()
   72:         digest = tok.concatenate_remaining_identifiers().encode()
   73:         digest = binascii.unhexlify(digest)
   74:         return cls(rdclass, rdtype, key_tag, algorithm, digest_type, digest)
   75: 
   76:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
   77:         header = struct.pack("!HBB", self.key_tag, self.algorithm, self.digest_type)
   78:         file.write(header)
   79:         file.write(self.digest)
   80: 
   81:     @classmethod
   82:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
   83:         header = parser.get_struct("!HBB")
   84:         digest = parser.get_remaining()
   85:         return cls(rdclass, rdtype, header[0], header[1], header[2], digest)
