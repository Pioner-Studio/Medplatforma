    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
    4: # Copyright (C) 2015 Red Hat, Inc.
    5: #
    6: # Permission to use, copy, modify, and distribute this software and its
    7: # documentation for any purpose with or without fee is hereby granted,
    8: # provided that the above copyright notice and this permission notice
    9: # appear in all copies.
   10: #
   11: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   12: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   13: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   14: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   15: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   16: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   17: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   18: 
   19: import struct
   20: 
   21: import dns.exception
   22: import dns.immutable
   23: import dns.name
   24: import dns.rdata
   25: import dns.rdtypes.util
   26: 
   27: 
   28: @dns.immutable.immutable
   29: class URI(dns.rdata.Rdata):
   30:     """URI record"""
   31: 
   32:     # see RFC 7553
   33: 
   34:     __slots__ = ["priority", "weight", "target"]
   35: 
   36:     def __init__(self, rdclass, rdtype, priority, weight, target):
   37:         super().__init__(rdclass, rdtype)
   38:         self.priority = self._as_uint16(priority)
   39:         self.weight = self._as_uint16(weight)
   40:         self.target = self._as_bytes(target, True)
   41:         if len(self.target) == 0:
   42:             raise dns.exception.SyntaxError("URI target cannot be empty")
   43: 
   44:     def to_text(self, origin=None, relativize=True, **kw):
   45:         return '%d %d "%s"' % (self.priority, self.weight, self.target.decode())
   46: 
   47:     @classmethod
   48:     def from_text(
   49:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
   50:     ):
   51:         priority = tok.get_uint16()
   52:         weight = tok.get_uint16()
   53:         target = tok.get().unescape()
   54:         if not (target.is_quoted_string() or target.is_identifier()):
   55:             raise dns.exception.SyntaxError("URI target must be a string")
   56:         return cls(rdclass, rdtype, priority, weight, target.value)
   57: 
   58:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
   59:         two_ints = struct.pack("!HH", self.priority, self.weight)
   60:         file.write(two_ints)
   61:         file.write(self.target)
   62: 
   63:     @classmethod
   64:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
   65:         (priority, weight) = parser.get_struct("!HH")
   66:         target = parser.get_remaining()
   67:         if len(target) == 0:
   68:             raise dns.exception.FormError("URI target may not be empty")
   69:         return cls(rdclass, rdtype, priority, weight, target)
   70: 
   71:     def _processing_priority(self):
   72:         return self.priority
   73: 
   74:     def _processing_weight(self):
   75:         return self.weight
   76: 
   77:     @classmethod
   78:     def _processing_order(cls, iterable):
   79:         return dns.rdtypes.util.weighted_processing_order(iterable)
