    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: import struct
    4: 
    5: import dns.immutable
    6: import dns.rdata
    7: 
    8: 
    9: @dns.immutable.immutable
   10: class LP(dns.rdata.Rdata):
   11:     """LP record"""
   12: 
   13:     # see: rfc6742.txt
   14: 
   15:     __slots__ = ["preference", "fqdn"]
   16: 
   17:     def __init__(self, rdclass, rdtype, preference, fqdn):
   18:         super().__init__(rdclass, rdtype)
   19:         self.preference = self._as_uint16(preference)
   20:         self.fqdn = self._as_name(fqdn)
   21: 
   22:     def to_text(self, origin=None, relativize=True, **kw):
   23:         fqdn = self.fqdn.choose_relativity(origin, relativize)
   24:         return "%d %s" % (self.preference, fqdn)
   25: 
   26:     @classmethod
   27:     def from_text(
   28:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
   29:     ):
   30:         preference = tok.get_uint16()
   31:         fqdn = tok.get_name(origin, relativize, relativize_to)
   32:         return cls(rdclass, rdtype, preference, fqdn)
   33: 
   34:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
   35:         file.write(struct.pack("!H", self.preference))
   36:         self.fqdn.to_wire(file, compress, origin, canonicalize)
   37: 
   38:     @classmethod
   39:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
   40:         preference = parser.get_uint16()
   41:         fqdn = parser.get_name(origin)
   42:         return cls(rdclass, rdtype, preference, fqdn)
