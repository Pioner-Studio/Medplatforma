    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import struct
   19: 
   20: import dns.exception
   21: import dns.immutable
   22: import dns.rdata
   23: 
   24: _pows = tuple(10**i for i in range(0, 11))
   25: 
   26: # default values are in centimeters
   27: _default_size = 100.0
   28: _default_hprec = 1000000.0
   29: _default_vprec = 1000.0
   30: 
   31: # for use by from_wire()
   32: _MAX_LATITUDE = 0x80000000 + 90 * 3600000
   33: _MIN_LATITUDE = 0x80000000 - 90 * 3600000
   34: _MAX_LONGITUDE = 0x80000000 + 180 * 3600000
   35: _MIN_LONGITUDE = 0x80000000 - 180 * 3600000
   36: 
   37: 
   38: def _exponent_of(what, desc):
   39:     if what == 0:
   40:         return 0
   41:     exp = None
   42:     for i, pow in enumerate(_pows):
   43:         if what < pow:
   44:             exp = i - 1
   45:             break
   46:     if exp is None or exp < 0:
   47:         raise dns.exception.SyntaxError("%s value out of bounds" % desc)
   48:     return exp
   49: 
   50: 
   51: def _float_to_tuple(what):
   52:     if what < 0:
   53:         sign = -1
   54:         what *= -1
   55:     else:
   56:         sign = 1
   57:     what = round(what * 3600000)
   58:     degrees = int(what // 3600000)
   59:     what -= degrees * 3600000
   60:     minutes = int(what // 60000)
   61:     what -= minutes * 60000
   62:     seconds = int(what // 1000)
   63:     what -= int(seconds * 1000)
   64:     what = int(what)
   65:     return (degrees, minutes, seconds, what, sign)
   66: 
   67: 
   68: def _tuple_to_float(what):
   69:     value = float(what[0])
   70:     value += float(what[1]) / 60.0
   71:     value += float(what[2]) / 3600.0
   72:     value += float(what[3]) / 3600000.0
   73:     return float(what[4]) * value
   74: 
   75: 
   76: def _encode_size(what, desc):
   77:     what = int(what)
   78:     exponent = _exponent_of(what, desc) & 0xF
   79:     base = what // pow(10, exponent) & 0xF
   80:     return base * 16 + exponent
   81: 
   82: 
   83: def _decode_size(what, desc):
   84:     exponent = what & 0x0F
   85:     if exponent > 9:
   86:         raise dns.exception.FormError("bad %s exponent" % desc)
   87:     base = (what & 0xF0) >> 4
   88:     if base > 9:
   89:         raise dns.exception.FormError("bad %s base" % desc)
   90:     return base * pow(10, exponent)
   91: 
   92: 
   93: def _check_coordinate_list(value, low, high):
   94:     if value[0] < low or value[0] > high:
   95:         raise ValueError(f"not in range [{low}, {high}]")
   96:     if value[1] < 0 or value[1] > 59:
   97:         raise ValueError("bad minutes value")
   98:     if value[2] < 0 or value[2] > 59:
   99:         raise ValueError("bad seconds value")
  100:     if value[3] < 0 or value[3] > 999:
  101:         raise ValueError("bad milliseconds value")
  102:     if value[4] != 1 and value[4] != -1:
  103:         raise ValueError("bad hemisphere value")
  104: 
  105: 
  106: @dns.immutable.immutable
  107: class LOC(dns.rdata.Rdata):
  108:     """LOC record"""
  109: 
  110:     # see: RFC 1876
  111: 
  112:     __slots__ = [
  113:         "latitude",
  114:         "longitude",
  115:         "altitude",
  116:         "size",
  117:         "horizontal_precision",
  118:         "vertical_precision",
  119:     ]
  120: 
  121:     def __init__(
  122:         self,
  123:         rdclass,
  124:         rdtype,
  125:         latitude,
  126:         longitude,
  127:         altitude,
  128:         size=_default_size,
  129:         hprec=_default_hprec,
  130:         vprec=_default_vprec,
  131:     ):
  132:         """Initialize a LOC record instance.
  133: 
  134:         The parameters I{latitude} and I{longitude} may be either a 4-tuple
  135:         of integers specifying (degrees, minutes, seconds, milliseconds),
  136:         or they may be floating point values specifying the number of
  137:         degrees. The other parameters are floats. Size, horizontal precision,
  138:         and vertical precision are specified in centimeters."""
  139: 
  140:         super().__init__(rdclass, rdtype)
  141:         if isinstance(latitude, int):
  142:             latitude = float(latitude)
  143:         if isinstance(latitude, float):
  144:             latitude = _float_to_tuple(latitude)
  145:         _check_coordinate_list(latitude, -90, 90)
  146:         self.latitude = tuple(latitude)
  147:         if isinstance(longitude, int):
  148:             longitude = float(longitude)
  149:         if isinstance(longitude, float):
  150:             longitude = _float_to_tuple(longitude)
  151:         _check_coordinate_list(longitude, -180, 180)
  152:         self.longitude = tuple(longitude)
  153:         self.altitude = float(altitude)
  154:         self.size = float(size)
  155:         self.horizontal_precision = float(hprec)
  156:         self.vertical_precision = float(vprec)
  157: 
  158:     def to_text(self, origin=None, relativize=True, **kw):
  159:         if self.latitude[4] > 0:
  160:             lat_hemisphere = "N"
  161:         else:
  162:             lat_hemisphere = "S"
  163:         if self.longitude[4] > 0:
  164:             long_hemisphere = "E"
  165:         else:
  166:             long_hemisphere = "W"
  167:         text = "%d %d %d.%03d %s %d %d %d.%03d %s %0.2fm" % (
  168:             self.latitude[0],
  169:             self.latitude[1],
  170:             self.latitude[2],
  171:             self.latitude[3],
  172:             lat_hemisphere,
  173:             self.longitude[0],
  174:             self.longitude[1],
  175:             self.longitude[2],
  176:             self.longitude[3],
  177:             long_hemisphere,
  178:             self.altitude / 100.0,
  179:         )
  180: 
  181:         # do not print default values
  182:         if (
  183:             self.size != _default_size
  184:             or self.horizontal_precision != _default_hprec
  185:             or self.vertical_precision != _default_vprec
  186:         ):
  187:             text += " {:0.2f}m {:0.2f}m {:0.2f}m".format(
  188:                 self.size / 100.0,
  189:                 self.horizontal_precision / 100.0,
  190:                 self.vertical_precision / 100.0,
  191:             )
  192:         return text
  193: 
  194:     @classmethod
  195:     def from_text(
  196:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
  197:     ):
  198:         latitude = [0, 0, 0, 0, 1]
  199:         longitude = [0, 0, 0, 0, 1]
  200:         size = _default_size
  201:         hprec = _default_hprec
  202:         vprec = _default_vprec
  203: 
  204:         latitude[0] = tok.get_int()
  205:         t = tok.get_string()
  206:         if t.isdigit():
  207:             latitude[1] = int(t)
  208:             t = tok.get_string()
  209:             if "." in t:
  210:                 (seconds, milliseconds) = t.split(".")
  211:                 if not seconds.isdigit():
  212:                     raise dns.exception.SyntaxError("bad latitude seconds value")
  213:                 latitude[2] = int(seconds)
  214:                 l = len(milliseconds)
  215:                 if l == 0 or l > 3 or not milliseconds.isdigit():
  216:                     raise dns.exception.SyntaxError("bad latitude milliseconds value")
  217:                 if l == 1:
  218:                     m = 100
  219:                 elif l == 2:
  220:                     m = 10
  221:                 else:
  222:                     m = 1
  223:                 latitude[3] = m * int(milliseconds)
  224:                 t = tok.get_string()
  225:             elif t.isdigit():
  226:                 latitude[2] = int(t)
  227:                 t = tok.get_string()
  228:         if t == "S":
  229:             latitude[4] = -1
  230:         elif t != "N":
  231:             raise dns.exception.SyntaxError("bad latitude hemisphere value")
  232: 
  233:         longitude[0] = tok.get_int()
  234:         t = tok.get_string()
  235:         if t.isdigit():
  236:             longitude[1] = int(t)
  237:             t = tok.get_string()
  238:             if "." in t:
  239:                 (seconds, milliseconds) = t.split(".")
  240:                 if not seconds.isdigit():
  241:                     raise dns.exception.SyntaxError("bad longitude seconds value")
  242:                 longitude[2] = int(seconds)
  243:                 l = len(milliseconds)
  244:                 if l == 0 or l > 3 or not milliseconds.isdigit():
  245:                     raise dns.exception.SyntaxError("bad longitude milliseconds value")
  246:                 if l == 1:
  247:                     m = 100
  248:                 elif l == 2:
  249:                     m = 10
  250:                 else:
  251:                     m = 1
  252:                 longitude[3] = m * int(milliseconds)
  253:                 t = tok.get_string()
  254:             elif t.isdigit():
  255:                 longitude[2] = int(t)
  256:                 t = tok.get_string()
  257:         if t == "W":
  258:             longitude[4] = -1
  259:         elif t != "E":
  260:             raise dns.exception.SyntaxError("bad longitude hemisphere value")
  261: 
  262:         t = tok.get_string()
  263:         if t[-1] == "m":
  264:             t = t[0:-1]
  265:         altitude = float(t) * 100.0  # m -> cm
  266: 
  267:         tokens = tok.get_remaining(max_tokens=3)
  268:         if len(tokens) >= 1:
  269:             value = tokens[0].unescape().value
  270:             if value[-1] == "m":
  271:                 value = value[0:-1]
  272:             size = float(value) * 100.0  # m -> cm
  273:             if len(tokens) >= 2:
  274:                 value = tokens[1].unescape().value
  275:                 if value[-1] == "m":
  276:                     value = value[0:-1]
  277:                 hprec = float(value) * 100.0  # m -> cm
  278:                 if len(tokens) >= 3:
  279:                     value = tokens[2].unescape().value
  280:                     if value[-1] == "m":
  281:                         value = value[0:-1]
  282:                     vprec = float(value) * 100.0  # m -> cm
  283: 
  284:         # Try encoding these now so we raise if they are bad
  285:         _encode_size(size, "size")
  286:         _encode_size(hprec, "horizontal precision")
  287:         _encode_size(vprec, "vertical precision")
  288: 
  289:         return cls(rdclass, rdtype, latitude, longitude, altitude, size, hprec, vprec)
  290: 
  291:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
  292:         milliseconds = (
  293:             self.latitude[0] * 3600000
  294:             + self.latitude[1] * 60000
  295:             + self.latitude[2] * 1000
  296:             + self.latitude[3]
  297:         ) * self.latitude[4]
  298:         latitude = 0x80000000 + milliseconds
  299:         milliseconds = (
  300:             self.longitude[0] * 3600000
  301:             + self.longitude[1] * 60000
  302:             + self.longitude[2] * 1000
  303:             + self.longitude[3]
  304:         ) * self.longitude[4]
  305:         longitude = 0x80000000 + milliseconds
  306:         altitude = int(self.altitude) + 10000000
  307:         size = _encode_size(self.size, "size")
  308:         hprec = _encode_size(self.horizontal_precision, "horizontal precision")
  309:         vprec = _encode_size(self.vertical_precision, "vertical precision")
  310:         wire = struct.pack(
  311:             "!BBBBIII", 0, size, hprec, vprec, latitude, longitude, altitude
  312:         )
  313:         file.write(wire)
  314: 
  315:     @classmethod
  316:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
  317:         (
  318:             version,
  319:             size,
  320:             hprec,
  321:             vprec,
  322:             latitude,
  323:             longitude,
  324:             altitude,
  325:         ) = parser.get_struct("!BBBBIII")
  326:         if version != 0:
  327:             raise dns.exception.FormError("LOC version not zero")
  328:         if latitude < _MIN_LATITUDE or latitude > _MAX_LATITUDE:
  329:             raise dns.exception.FormError("bad latitude")
  330:         if latitude > 0x80000000:
  331:             latitude = (latitude - 0x80000000) / 3600000
  332:         else:
  333:             latitude = -1 * (0x80000000 - latitude) / 3600000
  334:         if longitude < _MIN_LONGITUDE or longitude > _MAX_LONGITUDE:
  335:             raise dns.exception.FormError("bad longitude")
  336:         if longitude > 0x80000000:
  337:             longitude = (longitude - 0x80000000) / 3600000
  338:         else:
  339:             longitude = -1 * (0x80000000 - longitude) / 3600000
  340:         altitude = float(altitude) - 10000000.0
  341:         size = _decode_size(size, "size")
  342:         hprec = _decode_size(hprec, "horizontal precision")
  343:         vprec = _decode_size(vprec, "vertical precision")
  344:         return cls(rdclass, rdtype, latitude, longitude, altitude, size, hprec, vprec)
  345: 
  346:     @property
  347:     def float_latitude(self):
  348:         "latitude as a floating point value"
  349:         return _tuple_to_float(self.latitude)
  350: 
  351:     @property
  352:     def float_longitude(self):
  353:         "longitude as a floating point value"
  354:         return _tuple_to_float(self.longitude)
