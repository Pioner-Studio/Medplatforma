    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import base64
   19: import calendar
   20: import struct
   21: import time
   22: 
   23: import dns.dnssectypes
   24: import dns.exception
   25: import dns.immutable
   26: import dns.rdata
   27: import dns.rdatatype
   28: 
   29: 
   30: class BadSigTime(dns.exception.DNSException):
   31:     """Time in DNS SIG or RRSIG resource record cannot be parsed."""
   32: 
   33: 
   34: def sigtime_to_posixtime(what):
   35:     if len(what) <= 10 and what.isdigit():
   36:         return int(what)
   37:     if len(what) != 14:
   38:         raise BadSigTime
   39:     year = int(what[0:4])
   40:     month = int(what[4:6])
   41:     day = int(what[6:8])
   42:     hour = int(what[8:10])
   43:     minute = int(what[10:12])
   44:     second = int(what[12:14])
   45:     return calendar.timegm((year, month, day, hour, minute, second, 0, 0, 0))
   46: 
   47: 
   48: def posixtime_to_sigtime(what):
   49:     return time.strftime("%Y%m%d%H%M%S", time.gmtime(what))
   50: 
   51: 
   52: @dns.immutable.immutable
   53: class RRSIG(dns.rdata.Rdata):
   54:     """RRSIG record"""
   55: 
   56:     __slots__ = [
   57:         "type_covered",
   58:         "algorithm",
   59:         "labels",
   60:         "original_ttl",
   61:         "expiration",
   62:         "inception",
   63:         "key_tag",
   64:         "signer",
   65:         "signature",
   66:     ]
   67: 
   68:     def __init__(
   69:         self,
   70:         rdclass,
   71:         rdtype,
   72:         type_covered,
   73:         algorithm,
   74:         labels,
   75:         original_ttl,
   76:         expiration,
   77:         inception,
   78:         key_tag,
   79:         signer,
   80:         signature,
   81:     ):
   82:         super().__init__(rdclass, rdtype)
   83:         self.type_covered = self._as_rdatatype(type_covered)
   84:         self.algorithm = dns.dnssectypes.Algorithm.make(algorithm)
   85:         self.labels = self._as_uint8(labels)
   86:         self.original_ttl = self._as_ttl(original_ttl)
   87:         self.expiration = self._as_uint32(expiration)
   88:         self.inception = self._as_uint32(inception)
   89:         self.key_tag = self._as_uint16(key_tag)
   90:         self.signer = self._as_name(signer)
   91:         self.signature = self._as_bytes(signature)
   92: 
   93:     def covers(self):
   94:         return self.type_covered
   95: 
   96:     def to_text(self, origin=None, relativize=True, **kw):
   97:         return "%s %d %d %d %s %s %d %s %s" % (
   98:             dns.rdatatype.to_text(self.type_covered),
   99:             self.algorithm,
  100:             self.labels,
  101:             self.original_ttl,
  102:             posixtime_to_sigtime(self.expiration),
  103:             posixtime_to_sigtime(self.inception),
  104:             self.key_tag,
  105:             self.signer.choose_relativity(origin, relativize),
  106:             dns.rdata._base64ify(self.signature, **kw),
  107:         )
  108: 
  109:     @classmethod
  110:     def from_text(
  111:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
  112:     ):
  113:         type_covered = dns.rdatatype.from_text(tok.get_string())
  114:         algorithm = dns.dnssectypes.Algorithm.from_text(tok.get_string())
  115:         labels = tok.get_int()
  116:         original_ttl = tok.get_ttl()
  117:         expiration = sigtime_to_posixtime(tok.get_string())
  118:         inception = sigtime_to_posixtime(tok.get_string())
  119:         key_tag = tok.get_int()
  120:         signer = tok.get_name(origin, relativize, relativize_to)
  121:         b64 = tok.concatenate_remaining_identifiers().encode()
  122:         signature = base64.b64decode(b64)
  123:         return cls(
  124:             rdclass,
  125:             rdtype,
  126:             type_covered,
  127:             algorithm,
  128:             labels,
  129:             original_ttl,
  130:             expiration,
  131:             inception,
  132:             key_tag,
  133:             signer,
  134:             signature,
  135:         )
  136: 
  137:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
  138:         header = struct.pack(
  139:             "!HBBIIIH",
  140:             self.type_covered,
  141:             self.algorithm,
  142:             self.labels,
  143:             self.original_ttl,
  144:             self.expiration,
  145:             self.inception,
  146:             self.key_tag,
  147:         )
  148:         file.write(header)
  149:         self.signer.to_wire(file, None, origin, canonicalize)
  150:         file.write(self.signature)
  151: 
  152:     @classmethod
  153:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
  154:         header = parser.get_struct("!HBBIIIH")
  155:         signer = parser.get_name(origin)
  156:         signature = parser.get_remaining()
  157:         return cls(rdclass, rdtype, *header, signer, signature)
