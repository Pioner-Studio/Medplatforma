    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2004-2007, 2009-2011 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import base64
   19: import struct
   20: 
   21: import dns.exception
   22: import dns.immutable
   23: import dns.rdata
   24: 
   25: 
   26: @dns.immutable.immutable
   27: class TKEY(dns.rdata.Rdata):
   28:     """TKEY Record"""
   29: 
   30:     __slots__ = [
   31:         "algorithm",
   32:         "inception",
   33:         "expiration",
   34:         "mode",
   35:         "error",
   36:         "key",
   37:         "other",
   38:     ]
   39: 
   40:     def __init__(
   41:         self,
   42:         rdclass,
   43:         rdtype,
   44:         algorithm,
   45:         inception,
   46:         expiration,
   47:         mode,
   48:         error,
   49:         key,
   50:         other=b"",
   51:     ):
   52:         super().__init__(rdclass, rdtype)
   53:         self.algorithm = self._as_name(algorithm)
   54:         self.inception = self._as_uint32(inception)
   55:         self.expiration = self._as_uint32(expiration)
   56:         self.mode = self._as_uint16(mode)
   57:         self.error = self._as_uint16(error)
   58:         self.key = self._as_bytes(key)
   59:         self.other = self._as_bytes(other)
   60: 
   61:     def to_text(self, origin=None, relativize=True, **kw):
   62:         _algorithm = self.algorithm.choose_relativity(origin, relativize)
   63:         text = "%s %u %u %u %u %s" % (
   64:             str(_algorithm),
   65:             self.inception,
   66:             self.expiration,
   67:             self.mode,
   68:             self.error,
   69:             dns.rdata._base64ify(self.key, 0),
   70:         )
   71:         if len(self.other) > 0:
   72:             text += " %s" % (dns.rdata._base64ify(self.other, 0))
   73: 
   74:         return text
   75: 
   76:     @classmethod
   77:     def from_text(
   78:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
   79:     ):
   80:         algorithm = tok.get_name(relativize=False)
   81:         inception = tok.get_uint32()
   82:         expiration = tok.get_uint32()
   83:         mode = tok.get_uint16()
   84:         error = tok.get_uint16()
   85:         key_b64 = tok.get_string().encode()
   86:         key = base64.b64decode(key_b64)
   87:         other_b64 = tok.concatenate_remaining_identifiers(True).encode()
   88:         other = base64.b64decode(other_b64)
   89: 
   90:         return cls(
   91:             rdclass, rdtype, algorithm, inception, expiration, mode, error, key, other
   92:         )
   93: 
   94:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
   95:         self.algorithm.to_wire(file, compress, origin)
   96:         file.write(
   97:             struct.pack("!IIHH", self.inception, self.expiration, self.mode, self.error)
   98:         )
   99:         file.write(struct.pack("!H", len(self.key)))
  100:         file.write(self.key)
  101:         file.write(struct.pack("!H", len(self.other)))
  102:         if len(self.other) > 0:
  103:             file.write(self.other)
  104: 
  105:     @classmethod
  106:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
  107:         algorithm = parser.get_name(origin)
  108:         inception, expiration, mode, error = parser.get_struct("!IIHH")
  109:         key = parser.get_counted_bytes(2)
  110:         other = parser.get_counted_bytes(2)
  111: 
  112:         return cls(
  113:             rdclass, rdtype, algorithm, inception, expiration, mode, error, key, other
  114:         )
  115: 
  116:     # Constants for the mode field - from RFC 2930:
  117:     # 2.5 The Mode Field
  118:     #
  119:     #    The mode field specifies the general scheme for key agreement or
  120:     #    the purpose of the TKEY DNS message.  Servers and resolvers
  121:     #    supporting this specification MUST implement the Diffie-Hellman key
  122:     #    agreement mode and the key deletion mode for queries.  All other
  123:     #    modes are OPTIONAL.  A server supporting TKEY that receives a TKEY
  124:     #    request with a mode it does not support returns the BADMODE error.
  125:     #    The following values of the Mode octet are defined, available, or
  126:     #    reserved:
  127:     #
  128:     #          Value    Description
  129:     #          -----    -----------
  130:     #           0        - reserved, see section 7
  131:     #           1       server assignment
  132:     #           2       Diffie-Hellman exchange
  133:     #           3       GSS-API negotiation
  134:     #           4       resolver assignment
  135:     #           5       key deletion
  136:     #          6-65534   - available, see section 7
  137:     #          65535     - reserved, see section 7
  138:     SERVER_ASSIGNMENT = 1
  139:     DIFFIE_HELLMAN_EXCHANGE = 2
  140:     GSSAPI_NEGOTIATION = 3
  141:     RESOLVER_ASSIGNMENT = 4
  142:     KEY_DELETION = 5
