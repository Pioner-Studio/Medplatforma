    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import base64
   19: import struct
   20: 
   21: import dns.dnssectypes
   22: import dns.exception
   23: import dns.immutable
   24: import dns.rdata
   25: import dns.tokenizer
   26: 
   27: _ctype_by_value = {
   28:     1: "PKIX",
   29:     2: "SPKI",
   30:     3: "PGP",
   31:     4: "IPKIX",
   32:     5: "ISPKI",
   33:     6: "IPGP",
   34:     7: "ACPKIX",
   35:     8: "IACPKIX",
   36:     253: "URI",
   37:     254: "OID",
   38: }
   39: 
   40: _ctype_by_name = {
   41:     "PKIX": 1,
   42:     "SPKI": 2,
   43:     "PGP": 3,
   44:     "IPKIX": 4,
   45:     "ISPKI": 5,
   46:     "IPGP": 6,
   47:     "ACPKIX": 7,
   48:     "IACPKIX": 8,
   49:     "URI": 253,
   50:     "OID": 254,
   51: }
   52: 
   53: 
   54: def _ctype_from_text(what):
   55:     v = _ctype_by_name.get(what)
   56:     if v is not None:
   57:         return v
   58:     return int(what)
   59: 
   60: 
   61: def _ctype_to_text(what):
   62:     v = _ctype_by_value.get(what)
   63:     if v is not None:
   64:         return v
   65:     return str(what)
   66: 
   67: 
   68: @dns.immutable.immutable
   69: class CERT(dns.rdata.Rdata):
   70:     """CERT record"""
   71: 
   72:     # see RFC 4398
   73: 
   74:     __slots__ = ["certificate_type", "key_tag", "algorithm", "certificate"]
   75: 
   76:     def __init__(
   77:         self, rdclass, rdtype, certificate_type, key_tag, algorithm, certificate
   78:     ):
   79:         super().__init__(rdclass, rdtype)
   80:         self.certificate_type = self._as_uint16(certificate_type)
   81:         self.key_tag = self._as_uint16(key_tag)
   82:         self.algorithm = self._as_uint8(algorithm)
   83:         self.certificate = self._as_bytes(certificate)
   84: 
   85:     def to_text(self, origin=None, relativize=True, **kw):
   86:         certificate_type = _ctype_to_text(self.certificate_type)
   87:         return "%s %d %s %s" % (
   88:             certificate_type,
   89:             self.key_tag,
   90:             dns.dnssectypes.Algorithm.to_text(self.algorithm),
   91:             dns.rdata._base64ify(self.certificate, **kw),
   92:         )
   93: 
   94:     @classmethod
   95:     def from_text(
   96:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
   97:     ):
   98:         certificate_type = _ctype_from_text(tok.get_string())
   99:         key_tag = tok.get_uint16()
  100:         algorithm = dns.dnssectypes.Algorithm.from_text(tok.get_string())
  101:         b64 = tok.concatenate_remaining_identifiers().encode()
  102:         certificate = base64.b64decode(b64)
  103:         return cls(rdclass, rdtype, certificate_type, key_tag, algorithm, certificate)
  104: 
  105:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
  106:         prefix = struct.pack(
  107:             "!HHB", self.certificate_type, self.key_tag, self.algorithm
  108:         )
  109:         file.write(prefix)
  110:         file.write(self.certificate)
  111: 
  112:     @classmethod
  113:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
  114:         (certificate_type, key_tag, algorithm) = parser.get_struct("!HHB")
  115:         certificate = parser.get_remaining()
  116:         return cls(rdclass, rdtype, certificate_type, key_tag, algorithm, certificate)
