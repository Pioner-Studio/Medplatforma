    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2004-2017 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import base64
   19: import binascii
   20: import struct
   21: 
   22: import dns.exception
   23: import dns.immutable
   24: import dns.rdata
   25: import dns.rdatatype
   26: import dns.rdtypes.util
   27: 
   28: b32_hex_to_normal = bytes.maketrans(
   29:     b"0123456789ABCDEFGHIJKLMNOPQRSTUV", b"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
   30: )
   31: b32_normal_to_hex = bytes.maketrans(
   32:     b"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", b"0123456789ABCDEFGHIJKLMNOPQRSTUV"
   33: )
   34: 
   35: # hash algorithm constants
   36: SHA1 = 1
   37: 
   38: # flag constants
   39: OPTOUT = 1
   40: 
   41: 
   42: @dns.immutable.immutable
   43: class Bitmap(dns.rdtypes.util.Bitmap):
   44:     type_name = "NSEC3"
   45: 
   46: 
   47: @dns.immutable.immutable
   48: class NSEC3(dns.rdata.Rdata):
   49:     """NSEC3 record"""
   50: 
   51:     __slots__ = ["algorithm", "flags", "iterations", "salt", "next", "windows"]
   52: 
   53:     def __init__(
   54:         self, rdclass, rdtype, algorithm, flags, iterations, salt, next, windows
   55:     ):
   56:         super().__init__(rdclass, rdtype)
   57:         self.algorithm = self._as_uint8(algorithm)
   58:         self.flags = self._as_uint8(flags)
   59:         self.iterations = self._as_uint16(iterations)
   60:         self.salt = self._as_bytes(salt, True, 255)
   61:         self.next = self._as_bytes(next, True, 255)
   62:         if not isinstance(windows, Bitmap):
   63:             windows = Bitmap(windows)
   64:         self.windows = tuple(windows.windows)
   65: 
   66:     def _next_text(self):
   67:         next = base64.b32encode(self.next).translate(b32_normal_to_hex).lower().decode()
   68:         next = next.rstrip("=")
   69:         return next
   70: 
   71:     def to_text(self, origin=None, relativize=True, **kw):
   72:         next = self._next_text()
   73:         if self.salt == b"":
   74:             salt = "-"
   75:         else:
   76:             salt = binascii.hexlify(self.salt).decode()
   77:         text = Bitmap(self.windows).to_text()
   78:         return "%u %u %u %s %s%s" % (
   79:             self.algorithm,
   80:             self.flags,
   81:             self.iterations,
   82:             salt,
   83:             next,
   84:             text,
   85:         )
   86: 
   87:     @classmethod
   88:     def from_text(
   89:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
   90:     ):
   91:         algorithm = tok.get_uint8()
   92:         flags = tok.get_uint8()
   93:         iterations = tok.get_uint16()
   94:         salt = tok.get_string()
   95:         if salt == "-":
   96:             salt = b""
   97:         else:
   98:             salt = binascii.unhexlify(salt.encode("ascii"))
   99:         next = tok.get_string().encode("ascii").upper().translate(b32_hex_to_normal)
  100:         if next.endswith(b"="):
  101:             raise binascii.Error("Incorrect padding")
  102:         if len(next) % 8 != 0:
  103:             next += b"=" * (8 - len(next) % 8)
  104:         next = base64.b32decode(next)
  105:         bitmap = Bitmap.from_text(tok)
  106:         return cls(rdclass, rdtype, algorithm, flags, iterations, salt, next, bitmap)
  107: 
  108:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
  109:         l = len(self.salt)
  110:         file.write(struct.pack("!BBHB", self.algorithm, self.flags, self.iterations, l))
  111:         file.write(self.salt)
  112:         l = len(self.next)
  113:         file.write(struct.pack("!B", l))
  114:         file.write(self.next)
  115:         Bitmap(self.windows).to_wire(file)
  116: 
  117:     @classmethod
  118:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
  119:         (algorithm, flags, iterations) = parser.get_struct("!BBH")
  120:         salt = parser.get_counted_bytes()
  121:         next = parser.get_counted_bytes()
  122:         bitmap = Bitmap.from_wire_parser(parser)
  123:         return cls(rdclass, rdtype, algorithm, flags, iterations, salt, next, bitmap)
  124: 
  125:     def next_name(self, origin=None):
  126:         return dns.name.from_text(self._next_text(), origin)
