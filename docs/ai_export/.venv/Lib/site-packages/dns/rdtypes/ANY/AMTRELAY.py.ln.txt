    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2006, 2007, 2009-2011 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import struct
   19: 
   20: import dns.exception
   21: import dns.immutable
   22: import dns.rdtypes.util
   23: 
   24: 
   25: class Relay(dns.rdtypes.util.Gateway):
   26:     name = "AMTRELAY relay"
   27: 
   28:     @property
   29:     def relay(self):
   30:         return self.gateway
   31: 
   32: 
   33: @dns.immutable.immutable
   34: class AMTRELAY(dns.rdata.Rdata):
   35:     """AMTRELAY record"""
   36: 
   37:     # see: RFC 8777
   38: 
   39:     __slots__ = ["precedence", "discovery_optional", "relay_type", "relay"]
   40: 
   41:     def __init__(
   42:         self, rdclass, rdtype, precedence, discovery_optional, relay_type, relay
   43:     ):
   44:         super().__init__(rdclass, rdtype)
   45:         relay = Relay(relay_type, relay)
   46:         self.precedence = self._as_uint8(precedence)
   47:         self.discovery_optional = self._as_bool(discovery_optional)
   48:         self.relay_type = relay.type
   49:         self.relay = relay.relay
   50: 
   51:     def to_text(self, origin=None, relativize=True, **kw):
   52:         relay = Relay(self.relay_type, self.relay).to_text(origin, relativize)
   53:         return "%d %d %d %s" % (
   54:             self.precedence,
   55:             self.discovery_optional,
   56:             self.relay_type,
   57:             relay,
   58:         )
   59: 
   60:     @classmethod
   61:     def from_text(
   62:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
   63:     ):
   64:         precedence = tok.get_uint8()
   65:         discovery_optional = tok.get_uint8()
   66:         if discovery_optional > 1:
   67:             raise dns.exception.SyntaxError("expecting 0 or 1")
   68:         discovery_optional = bool(discovery_optional)
   69:         relay_type = tok.get_uint8()
   70:         if relay_type > 0x7F:
   71:             raise dns.exception.SyntaxError("expecting an integer <= 127")
   72:         relay = Relay.from_text(relay_type, tok, origin, relativize, relativize_to)
   73:         return cls(
   74:             rdclass, rdtype, precedence, discovery_optional, relay_type, relay.relay
   75:         )
   76: 
   77:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
   78:         relay_type = self.relay_type | (self.discovery_optional << 7)
   79:         header = struct.pack("!BB", self.precedence, relay_type)
   80:         file.write(header)
   81:         Relay(self.relay_type, self.relay).to_wire(file, compress, origin, canonicalize)
   82: 
   83:     @classmethod
   84:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
   85:         (precedence, relay_type) = parser.get_struct("!BB")
   86:         discovery_optional = bool(relay_type >> 7)
   87:         relay_type &= 0x7F
   88:         relay = Relay.from_wire_parser(relay_type, parser, origin)
   89:         return cls(
   90:             rdclass, rdtype, precedence, discovery_optional, relay_type, relay.relay
   91:         )
