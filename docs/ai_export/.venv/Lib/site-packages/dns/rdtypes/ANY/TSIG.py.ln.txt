    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2001-2017 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import base64
   19: import struct
   20: 
   21: import dns.exception
   22: import dns.immutable
   23: import dns.rcode
   24: import dns.rdata
   25: 
   26: 
   27: @dns.immutable.immutable
   28: class TSIG(dns.rdata.Rdata):
   29:     """TSIG record"""
   30: 
   31:     __slots__ = [
   32:         "algorithm",
   33:         "time_signed",
   34:         "fudge",
   35:         "mac",
   36:         "original_id",
   37:         "error",
   38:         "other",
   39:     ]
   40: 
   41:     def __init__(
   42:         self,
   43:         rdclass,
   44:         rdtype,
   45:         algorithm,
   46:         time_signed,
   47:         fudge,
   48:         mac,
   49:         original_id,
   50:         error,
   51:         other,
   52:     ):
   53:         """Initialize a TSIG rdata.
   54: 
   55:         *rdclass*, an ``int`` is the rdataclass of the Rdata.
   56: 
   57:         *rdtype*, an ``int`` is the rdatatype of the Rdata.
   58: 
   59:         *algorithm*, a ``dns.name.Name``.
   60: 
   61:         *time_signed*, an ``int``.
   62: 
   63:         *fudge*, an ``int`.
   64: 
   65:         *mac*, a ``bytes``
   66: 
   67:         *original_id*, an ``int``
   68: 
   69:         *error*, an ``int``
   70: 
   71:         *other*, a ``bytes``
   72:         """
   73: 
   74:         super().__init__(rdclass, rdtype)
   75:         self.algorithm = self._as_name(algorithm)
   76:         self.time_signed = self._as_uint48(time_signed)
   77:         self.fudge = self._as_uint16(fudge)
   78:         self.mac = self._as_bytes(mac)
   79:         self.original_id = self._as_uint16(original_id)
   80:         self.error = dns.rcode.Rcode.make(error)
   81:         self.other = self._as_bytes(other)
   82: 
   83:     def to_text(self, origin=None, relativize=True, **kw):
   84:         algorithm = self.algorithm.choose_relativity(origin, relativize)
   85:         error = dns.rcode.to_text(self.error, True)
   86:         text = (
   87:             f"{algorithm} {self.time_signed} {self.fudge} "
   88:             + f"{len(self.mac)} {dns.rdata._base64ify(self.mac, 0)} "
   89:             + f"{self.original_id} {error} {len(self.other)}"
   90:         )
   91:         if self.other:
   92:             text += f" {dns.rdata._base64ify(self.other, 0)}"
   93:         return text
   94: 
   95:     @classmethod
   96:     def from_text(
   97:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
   98:     ):
   99:         algorithm = tok.get_name(relativize=False)
  100:         time_signed = tok.get_uint48()
  101:         fudge = tok.get_uint16()
  102:         mac_len = tok.get_uint16()
  103:         mac = base64.b64decode(tok.get_string())
  104:         if len(mac) != mac_len:
  105:             raise SyntaxError("invalid MAC")
  106:         original_id = tok.get_uint16()
  107:         error = dns.rcode.from_text(tok.get_string())
  108:         other_len = tok.get_uint16()
  109:         if other_len > 0:
  110:             other = base64.b64decode(tok.get_string())
  111:             if len(other) != other_len:
  112:                 raise SyntaxError("invalid other data")
  113:         else:
  114:             other = b""
  115:         return cls(
  116:             rdclass,
  117:             rdtype,
  118:             algorithm,
  119:             time_signed,
  120:             fudge,
  121:             mac,
  122:             original_id,
  123:             error,
  124:             other,
  125:         )
  126: 
  127:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
  128:         self.algorithm.to_wire(file, None, origin, False)
  129:         file.write(
  130:             struct.pack(
  131:                 "!HIHH",
  132:                 (self.time_signed >> 32) & 0xFFFF,
  133:                 self.time_signed & 0xFFFFFFFF,
  134:                 self.fudge,
  135:                 len(self.mac),
  136:             )
  137:         )
  138:         file.write(self.mac)
  139:         file.write(struct.pack("!HHH", self.original_id, self.error, len(self.other)))
  140:         file.write(self.other)
  141: 
  142:     @classmethod
  143:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
  144:         algorithm = parser.get_name()
  145:         time_signed = parser.get_uint48()
  146:         fudge = parser.get_uint16()
  147:         mac = parser.get_counted_bytes(2)
  148:         (original_id, error) = parser.get_struct("!HH")
  149:         other = parser.get_counted_bytes(2)
  150:         return cls(
  151:             rdclass,
  152:             rdtype,
  153:             algorithm,
  154:             time_signed,
  155:             fudge,
  156:             mac,
  157:             original_id,
  158:             error,
  159:             other,
  160:         )
