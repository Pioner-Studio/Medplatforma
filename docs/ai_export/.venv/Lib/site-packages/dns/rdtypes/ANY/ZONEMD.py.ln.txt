    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: import binascii
    4: import struct
    5: 
    6: import dns.immutable
    7: import dns.rdata
    8: import dns.rdatatype
    9: import dns.zonetypes
   10: 
   11: 
   12: @dns.immutable.immutable
   13: class ZONEMD(dns.rdata.Rdata):
   14:     """ZONEMD record"""
   15: 
   16:     # See RFC 8976
   17: 
   18:     __slots__ = ["serial", "scheme", "hash_algorithm", "digest"]
   19: 
   20:     def __init__(self, rdclass, rdtype, serial, scheme, hash_algorithm, digest):
   21:         super().__init__(rdclass, rdtype)
   22:         self.serial = self._as_uint32(serial)
   23:         self.scheme = dns.zonetypes.DigestScheme.make(scheme)
   24:         self.hash_algorithm = dns.zonetypes.DigestHashAlgorithm.make(hash_algorithm)
   25:         self.digest = self._as_bytes(digest)
   26: 
   27:         if self.scheme == 0:  # reserved, RFC 8976 Sec. 5.2
   28:             raise ValueError("scheme 0 is reserved")
   29:         if self.hash_algorithm == 0:  # reserved, RFC 8976 Sec. 5.3
   30:             raise ValueError("hash_algorithm 0 is reserved")
   31: 
   32:         hasher = dns.zonetypes._digest_hashers.get(self.hash_algorithm)
   33:         if hasher and hasher().digest_size != len(self.digest):
   34:             raise ValueError("digest length inconsistent with hash algorithm")
   35: 
   36:     def to_text(self, origin=None, relativize=True, **kw):
   37:         kw = kw.copy()
   38:         chunksize = kw.pop("chunksize", 128)
   39:         return "%d %d %d %s" % (
   40:             self.serial,
   41:             self.scheme,
   42:             self.hash_algorithm,
   43:             dns.rdata._hexify(self.digest, chunksize=chunksize, **kw),
   44:         )
   45: 
   46:     @classmethod
   47:     def from_text(
   48:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
   49:     ):
   50:         serial = tok.get_uint32()
   51:         scheme = tok.get_uint8()
   52:         hash_algorithm = tok.get_uint8()
   53:         digest = tok.concatenate_remaining_identifiers().encode()
   54:         digest = binascii.unhexlify(digest)
   55:         return cls(rdclass, rdtype, serial, scheme, hash_algorithm, digest)
   56: 
   57:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
   58:         header = struct.pack("!IBB", self.serial, self.scheme, self.hash_algorithm)
   59:         file.write(header)
   60:         file.write(self.digest)
   61: 
   62:     @classmethod
   63:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
   64:         header = parser.get_struct("!IBB")
   65:         digest = parser.get_remaining()
   66:         return cls(rdclass, rdtype, header[0], header[1], header[2], digest)
