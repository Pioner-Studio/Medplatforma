    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2017 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import binascii
   19: import codecs
   20: import struct
   21: 
   22: import dns.exception
   23: import dns.immutable
   24: import dns.ipv4
   25: import dns.ipv6
   26: import dns.rdata
   27: import dns.tokenizer
   28: 
   29: 
   30: @dns.immutable.immutable
   31: class APLItem:
   32:     """An APL list item."""
   33: 
   34:     __slots__ = ["family", "negation", "address", "prefix"]
   35: 
   36:     def __init__(self, family, negation, address, prefix):
   37:         self.family = dns.rdata.Rdata._as_uint16(family)
   38:         self.negation = dns.rdata.Rdata._as_bool(negation)
   39:         if self.family == 1:
   40:             self.address = dns.rdata.Rdata._as_ipv4_address(address)
   41:             self.prefix = dns.rdata.Rdata._as_int(prefix, 0, 32)
   42:         elif self.family == 2:
   43:             self.address = dns.rdata.Rdata._as_ipv6_address(address)
   44:             self.prefix = dns.rdata.Rdata._as_int(prefix, 0, 128)
   45:         else:
   46:             self.address = dns.rdata.Rdata._as_bytes(address, max_length=127)
   47:             self.prefix = dns.rdata.Rdata._as_uint8(prefix)
   48: 
   49:     def __str__(self):
   50:         if self.negation:
   51:             return "!%d:%s/%s" % (self.family, self.address, self.prefix)
   52:         else:
   53:             return "%d:%s/%s" % (self.family, self.address, self.prefix)
   54: 
   55:     def to_wire(self, file):
   56:         if self.family == 1:
   57:             address = dns.ipv4.inet_aton(self.address)
   58:         elif self.family == 2:
   59:             address = dns.ipv6.inet_aton(self.address)
   60:         else:
   61:             address = binascii.unhexlify(self.address)
   62:         #
   63:         # Truncate least significant zero bytes.
   64:         #
   65:         last = 0
   66:         for i in range(len(address) - 1, -1, -1):
   67:             if address[i] != 0:
   68:                 last = i + 1
   69:                 break
   70:         address = address[0:last]
   71:         l = len(address)
   72:         assert l < 128
   73:         if self.negation:
   74:             l |= 0x80
   75:         header = struct.pack("!HBB", self.family, self.prefix, l)
   76:         file.write(header)
   77:         file.write(address)
   78: 
   79: 
   80: @dns.immutable.immutable
   81: class APL(dns.rdata.Rdata):
   82:     """APL record."""
   83: 
   84:     # see: RFC 3123
   85: 
   86:     __slots__ = ["items"]
   87: 
   88:     def __init__(self, rdclass, rdtype, items):
   89:         super().__init__(rdclass, rdtype)
   90:         for item in items:
   91:             if not isinstance(item, APLItem):
   92:                 raise ValueError("item not an APLItem")
   93:         self.items = tuple(items)
   94: 
   95:     def to_text(self, origin=None, relativize=True, **kw):
   96:         return " ".join(map(str, self.items))
   97: 
   98:     @classmethod
   99:     def from_text(
  100:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
  101:     ):
  102:         items = []
  103:         for token in tok.get_remaining():
  104:             item = token.unescape().value
  105:             if item[0] == "!":
  106:                 negation = True
  107:                 item = item[1:]
  108:             else:
  109:                 negation = False
  110:             (family, rest) = item.split(":", 1)
  111:             family = int(family)
  112:             (address, prefix) = rest.split("/", 1)
  113:             prefix = int(prefix)
  114:             item = APLItem(family, negation, address, prefix)
  115:             items.append(item)
  116: 
  117:         return cls(rdclass, rdtype, items)
  118: 
  119:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
  120:         for item in self.items:
  121:             item.to_wire(file)
  122: 
  123:     @classmethod
  124:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
  125:         items = []
  126:         while parser.remaining() > 0:
  127:             header = parser.get_struct("!HBB")
  128:             afdlen = header[2]
  129:             if afdlen > 127:
  130:                 negation = True
  131:                 afdlen -= 128
  132:             else:
  133:                 negation = False
  134:             address = parser.get_bytes(afdlen)
  135:             l = len(address)
  136:             if header[0] == 1:
  137:                 if l < 4:
  138:                     address += b"\x00" * (4 - l)
  139:             elif header[0] == 2:
  140:                 if l < 16:
  141:                     address += b"\x00" * (16 - l)
  142:             else:
  143:                 #
  144:                 # This isn't really right according to the RFC, but it
  145:                 # seems better than throwing an exception
  146:                 #
  147:                 address = codecs.encode(address, "hex_codec")
  148:             item = APLItem(header[0], negation, address, header[1])
  149:             items.append(item)
  150:         return cls(rdclass, rdtype, items)
