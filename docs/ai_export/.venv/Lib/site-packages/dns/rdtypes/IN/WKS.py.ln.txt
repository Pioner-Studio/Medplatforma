    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: import socket
   19: import struct
   20: 
   21: import dns.immutable
   22: import dns.ipv4
   23: import dns.rdata
   24: 
   25: try:
   26:     _proto_tcp = socket.getprotobyname("tcp")
   27:     _proto_udp = socket.getprotobyname("udp")
   28: except OSError:
   29:     # Fall back to defaults in case /etc/protocols is unavailable.
   30:     _proto_tcp = 6
   31:     _proto_udp = 17
   32: 
   33: 
   34: @dns.immutable.immutable
   35: class WKS(dns.rdata.Rdata):
   36:     """WKS record"""
   37: 
   38:     # see: RFC 1035
   39: 
   40:     __slots__ = ["address", "protocol", "bitmap"]
   41: 
   42:     def __init__(self, rdclass, rdtype, address, protocol, bitmap):
   43:         super().__init__(rdclass, rdtype)
   44:         self.address = self._as_ipv4_address(address)
   45:         self.protocol = self._as_uint8(protocol)
   46:         self.bitmap = self._as_bytes(bitmap)
   47: 
   48:     def to_text(self, origin=None, relativize=True, **kw):
   49:         bits = []
   50:         for i, byte in enumerate(self.bitmap):
   51:             for j in range(0, 8):
   52:                 if byte & (0x80 >> j):
   53:                     bits.append(str(i * 8 + j))
   54:         text = " ".join(bits)
   55:         return "%s %d %s" % (self.address, self.protocol, text)
   56: 
   57:     @classmethod
   58:     def from_text(
   59:         cls, rdclass, rdtype, tok, origin=None, relativize=True, relativize_to=None
   60:     ):
   61:         address = tok.get_string()
   62:         protocol = tok.get_string()
   63:         if protocol.isdigit():
   64:             protocol = int(protocol)
   65:         else:
   66:             protocol = socket.getprotobyname(protocol)
   67:         bitmap = bytearray()
   68:         for token in tok.get_remaining():
   69:             value = token.unescape().value
   70:             if value.isdigit():
   71:                 serv = int(value)
   72:             else:
   73:                 if protocol != _proto_udp and protocol != _proto_tcp:
   74:                     raise NotImplementedError("protocol must be TCP or UDP")
   75:                 if protocol == _proto_udp:
   76:                     protocol_text = "udp"
   77:                 else:
   78:                     protocol_text = "tcp"
   79:                 serv = socket.getservbyname(value, protocol_text)
   80:             i = serv // 8
   81:             l = len(bitmap)
   82:             if l < i + 1:
   83:                 for _ in range(l, i + 1):
   84:                     bitmap.append(0)
   85:             bitmap[i] = bitmap[i] | (0x80 >> (serv % 8))
   86:         bitmap = dns.rdata._truncate_bitmap(bitmap)
   87:         return cls(rdclass, rdtype, address, protocol, bitmap)
   88: 
   89:     def _to_wire(self, file, compress=None, origin=None, canonicalize=False):
   90:         file.write(dns.ipv4.inet_aton(self.address))
   91:         protocol = struct.pack("!B", self.protocol)
   92:         file.write(protocol)
   93:         file.write(self.bitmap)
   94: 
   95:     @classmethod
   96:     def from_wire_parser(cls, rdclass, rdtype, parser, origin=None):
   97:         address = parser.get_bytes(4)
   98:         protocol = parser.get_uint8()
   99:         bitmap = parser.get_remaining()
  100:         return cls(rdclass, rdtype, address, protocol, bitmap)
