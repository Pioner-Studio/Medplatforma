    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: """DNS Zones."""
   19: 
   20: import contextlib
   21: import io
   22: import os
   23: import struct
   24: from typing import (
   25:     Any,
   26:     Callable,
   27:     Iterable,
   28:     Iterator,
   29:     List,
   30:     MutableMapping,
   31:     Optional,
   32:     Set,
   33:     Tuple,
   34:     Union,
   35: )
   36: 
   37: import dns.exception
   38: import dns.grange
   39: import dns.immutable
   40: import dns.name
   41: import dns.node
   42: import dns.rdata
   43: import dns.rdataclass
   44: import dns.rdataset
   45: import dns.rdatatype
   46: import dns.rdtypes.ANY.SOA
   47: import dns.rdtypes.ANY.ZONEMD
   48: import dns.rrset
   49: import dns.tokenizer
   50: import dns.transaction
   51: import dns.ttl
   52: import dns.zonefile
   53: from dns.zonetypes import DigestHashAlgorithm, DigestScheme, _digest_hashers
   54: 
   55: 
   56: class BadZone(dns.exception.DNSException):
   57:     """The DNS zone is malformed."""
   58: 
   59: 
   60: class NoSOA(BadZone):
   61:     """The DNS zone has no SOA RR at its origin."""
   62: 
   63: 
   64: class NoNS(BadZone):
   65:     """The DNS zone has no NS RRset at its origin."""
   66: 
   67: 
   68: class UnknownOrigin(BadZone):
   69:     """The DNS zone's origin is unknown."""
   70: 
   71: 
   72: class UnsupportedDigestScheme(dns.exception.DNSException):
   73:     """The zone digest's scheme is unsupported."""
   74: 
   75: 
   76: class UnsupportedDigestHashAlgorithm(dns.exception.DNSException):
   77:     """The zone digest's origin is unsupported."""
   78: 
   79: 
   80: class NoDigest(dns.exception.DNSException):
   81:     """The DNS zone has no ZONEMD RRset at its origin."""
   82: 
   83: 
   84: class DigestVerificationFailure(dns.exception.DNSException):
   85:     """The ZONEMD digest failed to verify."""
   86: 
   87: 
   88: def _validate_name(
   89:     name: dns.name.Name,
   90:     origin: Optional[dns.name.Name],
   91:     relativize: bool,
   92: ) -> dns.name.Name:
   93:     # This name validation code is shared by Zone and Version
   94:     if origin is None:
   95:         # This should probably never happen as other code (e.g.
   96:         # _rr_line) will notice the lack of an origin before us, but
   97:         # we check just in case!
   98:         raise KeyError("no zone origin is defined")
   99:     if name.is_absolute():
  100:         if not name.is_subdomain(origin):
  101:             raise KeyError("name parameter must be a subdomain of the zone origin")
  102:         if relativize:
  103:             name = name.relativize(origin)
  104:     else:
  105:         # We have a relative name.  Make sure that the derelativized name is
  106:         # not too long.
  107:         try:
  108:             abs_name = name.derelativize(origin)
  109:         except dns.name.NameTooLong:
  110:             # We map dns.name.NameTooLong to KeyError to be consistent with
  111:             # the other exceptions above.
  112:             raise KeyError("relative name too long for zone")
  113:         if not relativize:
  114:             # We have a relative name in a non-relative zone, so use the
  115:             # derelativized name.
  116:             name = abs_name
  117:     return name
  118: 
  119: 
  120: class Zone(dns.transaction.TransactionManager):
  121:     """A DNS zone.
  122: 
  123:     A ``Zone`` is a mapping from names to nodes.  The zone object may be
  124:     treated like a Python dictionary, e.g. ``zone[name]`` will retrieve
  125:     the node associated with that name.  The *name* may be a
  126:     ``dns.name.Name object``, or it may be a string.  In either case,
  127:     if the name is relative it is treated as relative to the origin of
  128:     the zone.
  129:     """
  130: 
  131:     node_factory: Callable[[], dns.node.Node] = dns.node.Node
  132:     map_factory: Callable[[], MutableMapping[dns.name.Name, dns.node.Node]] = dict
  133:     writable_version_factory: Optional[Callable[[], "WritableVersion"]] = None
  134:     immutable_version_factory: Optional[Callable[[], "ImmutableVersion"]] = None
  135: 
  136:     __slots__ = ["rdclass", "origin", "nodes", "relativize"]
  137: 
  138:     def __init__(
  139:         self,
  140:         origin: Optional[Union[dns.name.Name, str]],
  141:         rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,
  142:         relativize: bool = True,
  143:     ):
  144:         """Initialize a zone object.
  145: 
  146:         *origin* is the origin of the zone.  It may be a ``dns.name.Name``,
  147:         a ``str``, or ``None``.  If ``None``, then the zone's origin will
  148:         be set by the first ``$ORIGIN`` line in a zone file.
  149: 
  150:         *rdclass*, an ``int``, the zone's rdata class; the default is class IN.
  151: 
  152:         *relativize*, a ``bool``, determine's whether domain names are
  153:         relativized to the zone's origin.  The default is ``True``.
  154:         """
  155: 
  156:         if origin is not None:
  157:             if isinstance(origin, str):
  158:                 origin = dns.name.from_text(origin)
  159:             elif not isinstance(origin, dns.name.Name):
  160:                 raise ValueError("origin parameter must be convertible to a DNS name")
  161:             if not origin.is_absolute():
  162:                 raise ValueError("origin parameter must be an absolute name")
  163:         self.origin = origin
  164:         self.rdclass = rdclass
  165:         self.nodes: MutableMapping[dns.name.Name, dns.node.Node] = self.map_factory()
  166:         self.relativize = relativize
  167: 
  168:     def __eq__(self, other):
  169:         """Two zones are equal if they have the same origin, class, and
  170:         nodes.
  171: 
  172:         Returns a ``bool``.
  173:         """
  174: 
  175:         if not isinstance(other, Zone):
  176:             return False
  177:         if (
  178:             self.rdclass != other.rdclass
  179:             or self.origin != other.origin
  180:             or self.nodes != other.nodes
  181:         ):
  182:             return False
  183:         return True
  184: 
  185:     def __ne__(self, other):
  186:         """Are two zones not equal?
  187: 
  188:         Returns a ``bool``.
  189:         """
  190: 
  191:         return not self.__eq__(other)
  192: 
  193:     def _validate_name(self, name: Union[dns.name.Name, str]) -> dns.name.Name:
  194:         # Note that any changes in this method should have corresponding changes
  195:         # made in the Version _validate_name() method.
  196:         if isinstance(name, str):
  197:             name = dns.name.from_text(name, None)
  198:         elif not isinstance(name, dns.name.Name):
  199:             raise KeyError("name parameter must be convertible to a DNS name")
  200:         return _validate_name(name, self.origin, self.relativize)
  201: 
  202:     def __getitem__(self, key):
  203:         key = self._validate_name(key)
  204:         return self.nodes[key]
  205: 
  206:     def __setitem__(self, key, value):
  207:         key = self._validate_name(key)
  208:         self.nodes[key] = value
  209: 
  210:     def __delitem__(self, key):
  211:         key = self._validate_name(key)
  212:         del self.nodes[key]
  213: 
  214:     def __iter__(self):
  215:         return self.nodes.__iter__()
  216: 
  217:     def keys(self):
  218:         return self.nodes.keys()
  219: 
  220:     def values(self):
  221:         return self.nodes.values()
  222: 
  223:     def items(self):
  224:         return self.nodes.items()
  225: 
  226:     def get(self, key):
  227:         key = self._validate_name(key)
  228:         return self.nodes.get(key)
  229: 
  230:     def __contains__(self, key):
  231:         key = self._validate_name(key)
  232:         return key in self.nodes
  233: 
  234:     def find_node(
  235:         self, name: Union[dns.name.Name, str], create: bool = False
  236:     ) -> dns.node.Node:
  237:         """Find a node in the zone, possibly creating it.
  238: 
  239:         *name*: the name of the node to find.
  240:         The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the
  241:         name must be a subdomain of the zone's origin.  If ``zone.relativize``
  242:         is ``True``, then the name will be relativized.
  243: 
  244:         *create*, a ``bool``.  If true, the node will be created if it does
  245:         not exist.
  246: 
  247:         Raises ``KeyError`` if the name is not known and create was
  248:         not specified, or if the name was not a subdomain of the origin.
  249: 
  250:         Returns a ``dns.node.Node``.
  251:         """
  252: 
  253:         name = self._validate_name(name)
  254:         node = self.nodes.get(name)
  255:         if node is None:
  256:             if not create:
  257:                 raise KeyError
  258:             node = self.node_factory()
  259:             self.nodes[name] = node
  260:         return node
  261: 
  262:     def get_node(
  263:         self, name: Union[dns.name.Name, str], create: bool = False
  264:     ) -> Optional[dns.node.Node]:
  265:         """Get a node in the zone, possibly creating it.
  266: 
  267:         This method is like ``find_node()``, except it returns None instead
  268:         of raising an exception if the node does not exist and creation
  269:         has not been requested.
  270: 
  271:         *name*: the name of the node to find.
  272:         The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the
  273:         name must be a subdomain of the zone's origin.  If ``zone.relativize``
  274:         is ``True``, then the name will be relativized.
  275: 
  276:         *create*, a ``bool``.  If true, the node will be created if it does
  277:         not exist.
  278: 
  279:         Returns a ``dns.node.Node`` or ``None``.
  280:         """
  281: 
  282:         try:
  283:             node = self.find_node(name, create)
  284:         except KeyError:
  285:             node = None
  286:         return node
  287: 
  288:     def delete_node(self, name: Union[dns.name.Name, str]) -> None:
  289:         """Delete the specified node if it exists.
  290: 
  291:         *name*: the name of the node to find.
  292:         The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the
  293:         name must be a subdomain of the zone's origin.  If ``zone.relativize``
  294:         is ``True``, then the name will be relativized.
  295: 
  296:         It is not an error if the node does not exist.
  297:         """
  298: 
  299:         name = self._validate_name(name)
  300:         if name in self.nodes:
  301:             del self.nodes[name]
  302: 
  303:     def find_rdataset(
  304:         self,
  305:         name: Union[dns.name.Name, str],
  306:         rdtype: Union[dns.rdatatype.RdataType, str],
  307:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  308:         create: bool = False,
  309:     ) -> dns.rdataset.Rdataset:
  310:         """Look for an rdataset with the specified name and type in the zone,
  311:         and return an rdataset encapsulating it.
  312: 
  313:         The rdataset returned is not a copy; changes to it will change
  314:         the zone.
  315: 
  316:         KeyError is raised if the name or type are not found.
  317: 
  318:         *name*: the name of the node to find.
  319:         The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the
  320:         name must be a subdomain of the zone's origin.  If ``zone.relativize``
  321:         is ``True``, then the name will be relativized.
  322: 
  323:         *rdtype*, a ``dns.rdatatype.RdataType`` or ``str``, the rdata type desired.
  324: 
  325:         *covers*, a ``dns.rdatatype.RdataType`` or ``str`` the covered type.
  326:         Usually this value is ``dns.rdatatype.NONE``, but if the
  327:         rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``,
  328:         then the covers value will be the rdata type the SIG/RRSIG
  329:         covers.  The library treats the SIG and RRSIG types as if they
  330:         were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).
  331:         This makes RRSIGs much easier to work with than if RRSIGs
  332:         covering different rdata types were aggregated into a single
  333:         RRSIG rdataset.
  334: 
  335:         *create*, a ``bool``.  If true, the node will be created if it does
  336:         not exist.
  337: 
  338:         Raises ``KeyError`` if the name is not known and create was
  339:         not specified, or if the name was not a subdomain of the origin.
  340: 
  341:         Returns a ``dns.rdataset.Rdataset``.
  342:         """
  343: 
  344:         name = self._validate_name(name)
  345:         rdtype = dns.rdatatype.RdataType.make(rdtype)
  346:         covers = dns.rdatatype.RdataType.make(covers)
  347:         node = self.find_node(name, create)
  348:         return node.find_rdataset(self.rdclass, rdtype, covers, create)
  349: 
  350:     def get_rdataset(
  351:         self,
  352:         name: Union[dns.name.Name, str],
  353:         rdtype: Union[dns.rdatatype.RdataType, str],
  354:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  355:         create: bool = False,
  356:     ) -> Optional[dns.rdataset.Rdataset]:
  357:         """Look for an rdataset with the specified name and type in the zone.
  358: 
  359:         This method is like ``find_rdataset()``, except it returns None instead
  360:         of raising an exception if the rdataset does not exist and creation
  361:         has not been requested.
  362: 
  363:         The rdataset returned is not a copy; changes to it will change
  364:         the zone.
  365: 
  366:         *name*: the name of the node to find.
  367:         The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the
  368:         name must be a subdomain of the zone's origin.  If ``zone.relativize``
  369:         is ``True``, then the name will be relativized.
  370: 
  371:         *rdtype*, a ``dns.rdatatype.RdataType`` or ``str``, the rdata type desired.
  372: 
  373:         *covers*, a ``dns.rdatatype.RdataType`` or ``str``, the covered type.
  374:         Usually this value is ``dns.rdatatype.NONE``, but if the
  375:         rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``,
  376:         then the covers value will be the rdata type the SIG/RRSIG
  377:         covers.  The library treats the SIG and RRSIG types as if they
  378:         were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).
  379:         This makes RRSIGs much easier to work with than if RRSIGs
  380:         covering different rdata types were aggregated into a single
  381:         RRSIG rdataset.
  382: 
  383:         *create*, a ``bool``.  If true, the node will be created if it does
  384:         not exist.
  385: 
  386:         Raises ``KeyError`` if the name is not known and create was
  387:         not specified, or if the name was not a subdomain of the origin.
  388: 
  389:         Returns a ``dns.rdataset.Rdataset`` or ``None``.
  390:         """
  391: 
  392:         try:
  393:             rdataset = self.find_rdataset(name, rdtype, covers, create)
  394:         except KeyError:
  395:             rdataset = None
  396:         return rdataset
  397: 
  398:     def delete_rdataset(
  399:         self,
  400:         name: Union[dns.name.Name, str],
  401:         rdtype: Union[dns.rdatatype.RdataType, str],
  402:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  403:     ) -> None:
  404:         """Delete the rdataset matching *rdtype* and *covers*, if it
  405:         exists at the node specified by *name*.
  406: 
  407:         It is not an error if the node does not exist, or if there is no matching
  408:         rdataset at the node.
  409: 
  410:         If the node has no rdatasets after the deletion, it will itself be deleted.
  411: 
  412:         *name*: the name of the node to find. The value may be a ``dns.name.Name`` or a
  413:         ``str``.  If absolute, the name must be a subdomain of the zone's origin.  If
  414:         ``zone.relativize`` is ``True``, then the name will be relativized.
  415: 
  416:         *rdtype*, a ``dns.rdatatype.RdataType`` or ``str``, the rdata type desired.
  417: 
  418:         *covers*, a ``dns.rdatatype.RdataType`` or ``str`` or ``None``, the covered
  419:         type. Usually this value is ``dns.rdatatype.NONE``, but if the rdtype is
  420:         ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``, then the covers value will be
  421:         the rdata type the SIG/RRSIG covers.  The library treats the SIG and RRSIG types
  422:         as if they were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA). This
  423:         makes RRSIGs much easier to work with than if RRSIGs covering different rdata
  424:         types were aggregated into a single RRSIG rdataset.
  425:         """
  426: 
  427:         name = self._validate_name(name)
  428:         rdtype = dns.rdatatype.RdataType.make(rdtype)
  429:         covers = dns.rdatatype.RdataType.make(covers)
  430:         node = self.get_node(name)
  431:         if node is not None:
  432:             node.delete_rdataset(self.rdclass, rdtype, covers)
  433:             if len(node) == 0:
  434:                 self.delete_node(name)
  435: 
  436:     def replace_rdataset(
  437:         self, name: Union[dns.name.Name, str], replacement: dns.rdataset.Rdataset
  438:     ) -> None:
  439:         """Replace an rdataset at name.
  440: 
  441:         It is not an error if there is no rdataset matching I{replacement}.
  442: 
  443:         Ownership of the *replacement* object is transferred to the zone;
  444:         in other words, this method does not store a copy of *replacement*
  445:         at the node, it stores *replacement* itself.
  446: 
  447:         If the node does not exist, it is created.
  448: 
  449:         *name*: the name of the node to find.
  450:         The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the
  451:         name must be a subdomain of the zone's origin.  If ``zone.relativize``
  452:         is ``True``, then the name will be relativized.
  453: 
  454:         *replacement*, a ``dns.rdataset.Rdataset``, the replacement rdataset.
  455:         """
  456: 
  457:         if replacement.rdclass != self.rdclass:
  458:             raise ValueError("replacement.rdclass != zone.rdclass")
  459:         node = self.find_node(name, True)
  460:         node.replace_rdataset(replacement)
  461: 
  462:     def find_rrset(
  463:         self,
  464:         name: Union[dns.name.Name, str],
  465:         rdtype: Union[dns.rdatatype.RdataType, str],
  466:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  467:     ) -> dns.rrset.RRset:
  468:         """Look for an rdataset with the specified name and type in the zone,
  469:         and return an RRset encapsulating it.
  470: 
  471:         This method is less efficient than the similar
  472:         ``find_rdataset()`` because it creates an RRset instead of
  473:         returning the matching rdataset.  It may be more convenient
  474:         for some uses since it returns an object which binds the owner
  475:         name to the rdataset.
  476: 
  477:         This method may not be used to create new nodes or rdatasets;
  478:         use ``find_rdataset`` instead.
  479: 
  480:         *name*: the name of the node to find.
  481:         The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the
  482:         name must be a subdomain of the zone's origin.  If ``zone.relativize``
  483:         is ``True``, then the name will be relativized.
  484: 
  485:         *rdtype*, a ``dns.rdatatype.RdataType`` or ``str``, the rdata type desired.
  486: 
  487:         *covers*, a ``dns.rdatatype.RdataType`` or ``str``, the covered type.
  488:         Usually this value is ``dns.rdatatype.NONE``, but if the
  489:         rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``,
  490:         then the covers value will be the rdata type the SIG/RRSIG
  491:         covers.  The library treats the SIG and RRSIG types as if they
  492:         were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).
  493:         This makes RRSIGs much easier to work with than if RRSIGs
  494:         covering different rdata types were aggregated into a single
  495:         RRSIG rdataset.
  496: 
  497:         *create*, a ``bool``.  If true, the node will be created if it does
  498:         not exist.
  499: 
  500:         Raises ``KeyError`` if the name is not known and create was
  501:         not specified, or if the name was not a subdomain of the origin.
  502: 
  503:         Returns a ``dns.rrset.RRset`` or ``None``.
  504:         """
  505: 
  506:         vname = self._validate_name(name)
  507:         rdtype = dns.rdatatype.RdataType.make(rdtype)
  508:         covers = dns.rdatatype.RdataType.make(covers)
  509:         rdataset = self.nodes[vname].find_rdataset(self.rdclass, rdtype, covers)
  510:         rrset = dns.rrset.RRset(vname, self.rdclass, rdtype, covers)
  511:         rrset.update(rdataset)
  512:         return rrset
  513: 
  514:     def get_rrset(
  515:         self,
  516:         name: Union[dns.name.Name, str],
  517:         rdtype: Union[dns.rdatatype.RdataType, str],
  518:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  519:     ) -> Optional[dns.rrset.RRset]:
  520:         """Look for an rdataset with the specified name and type in the zone,
  521:         and return an RRset encapsulating it.
  522: 
  523:         This method is less efficient than the similar ``get_rdataset()``
  524:         because it creates an RRset instead of returning the matching
  525:         rdataset.  It may be more convenient for some uses since it
  526:         returns an object which binds the owner name to the rdataset.
  527: 
  528:         This method may not be used to create new nodes or rdatasets;
  529:         use ``get_rdataset()`` instead.
  530: 
  531:         *name*: the name of the node to find.
  532:         The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the
  533:         name must be a subdomain of the zone's origin.  If ``zone.relativize``
  534:         is ``True``, then the name will be relativized.
  535: 
  536:         *rdtype*, a ``dns.rdataset.Rdataset`` or ``str``, the rdata type desired.
  537: 
  538:         *covers*, a ``dns.rdataset.Rdataset`` or ``str``, the covered type.
  539:         Usually this value is ``dns.rdatatype.NONE``, but if the
  540:         rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``,
  541:         then the covers value will be the rdata type the SIG/RRSIG
  542:         covers.  The library treats the SIG and RRSIG types as if they
  543:         were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).
  544:         This makes RRSIGs much easier to work with than if RRSIGs
  545:         covering different rdata types were aggregated into a single
  546:         RRSIG rdataset.
  547: 
  548:         *create*, a ``bool``.  If true, the node will be created if it does
  549:         not exist.
  550: 
  551:         Returns a ``dns.rrset.RRset`` or ``None``.
  552:         """
  553: 
  554:         try:
  555:             rrset = self.find_rrset(name, rdtype, covers)
  556:         except KeyError:
  557:             rrset = None
  558:         return rrset
  559: 
  560:     def iterate_rdatasets(
  561:         self,
  562:         rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.ANY,
  563:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  564:     ) -> Iterator[Tuple[dns.name.Name, dns.rdataset.Rdataset]]:
  565:         """Return a generator which yields (name, rdataset) tuples for
  566:         all rdatasets in the zone which have the specified *rdtype*
  567:         and *covers*.  If *rdtype* is ``dns.rdatatype.ANY``, the default,
  568:         then all rdatasets will be matched.
  569: 
  570:         *rdtype*, a ``dns.rdataset.Rdataset`` or ``str``, the rdata type desired.
  571: 
  572:         *covers*, a ``dns.rdataset.Rdataset`` or ``str``, the covered type.
  573:         Usually this value is ``dns.rdatatype.NONE``, but if the
  574:         rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``,
  575:         then the covers value will be the rdata type the SIG/RRSIG
  576:         covers.  The library treats the SIG and RRSIG types as if they
  577:         were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).
  578:         This makes RRSIGs much easier to work with than if RRSIGs
  579:         covering different rdata types were aggregated into a single
  580:         RRSIG rdataset.
  581:         """
  582: 
  583:         rdtype = dns.rdatatype.RdataType.make(rdtype)
  584:         covers = dns.rdatatype.RdataType.make(covers)
  585:         for name, node in self.items():
  586:             for rds in node:
  587:                 if rdtype == dns.rdatatype.ANY or (
  588:                     rds.rdtype == rdtype and rds.covers == covers
  589:                 ):
  590:                     yield (name, rds)
  591: 
  592:     def iterate_rdatas(
  593:         self,
  594:         rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.ANY,
  595:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  596:     ) -> Iterator[Tuple[dns.name.Name, int, dns.rdata.Rdata]]:
  597:         """Return a generator which yields (name, ttl, rdata) tuples for
  598:         all rdatas in the zone which have the specified *rdtype*
  599:         and *covers*.  If *rdtype* is ``dns.rdatatype.ANY``, the default,
  600:         then all rdatas will be matched.
  601: 
  602:         *rdtype*, a ``dns.rdataset.Rdataset`` or ``str``, the rdata type desired.
  603: 
  604:         *covers*, a ``dns.rdataset.Rdataset`` or ``str``, the covered type.
  605:         Usually this value is ``dns.rdatatype.NONE``, but if the
  606:         rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``,
  607:         then the covers value will be the rdata type the SIG/RRSIG
  608:         covers.  The library treats the SIG and RRSIG types as if they
  609:         were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA).
  610:         This makes RRSIGs much easier to work with than if RRSIGs
  611:         covering different rdata types were aggregated into a single
  612:         RRSIG rdataset.
  613:         """
  614: 
  615:         rdtype = dns.rdatatype.RdataType.make(rdtype)
  616:         covers = dns.rdatatype.RdataType.make(covers)
  617:         for name, node in self.items():
  618:             for rds in node:
  619:                 if rdtype == dns.rdatatype.ANY or (
  620:                     rds.rdtype == rdtype and rds.covers == covers
  621:                 ):
  622:                     for rdata in rds:
  623:                         yield (name, rds.ttl, rdata)
  624: 
  625:     def to_file(
  626:         self,
  627:         f: Any,
  628:         sorted: bool = True,
  629:         relativize: bool = True,
  630:         nl: Optional[str] = None,
  631:         want_comments: bool = False,
  632:         want_origin: bool = False,
  633:     ) -> None:
  634:         """Write a zone to a file.
  635: 
  636:         *f*, a file or `str`.  If *f* is a string, it is treated
  637:         as the name of a file to open.
  638: 
  639:         *sorted*, a ``bool``.  If True, the default, then the file
  640:         will be written with the names sorted in DNSSEC order from
  641:         least to greatest.  Otherwise the names will be written in
  642:         whatever order they happen to have in the zone's dictionary.
  643: 
  644:         *relativize*, a ``bool``.  If True, the default, then domain
  645:         names in the output will be relativized to the zone's origin
  646:         if possible.
  647: 
  648:         *nl*, a ``str`` or None.  The end of line string.  If not
  649:         ``None``, the output will use the platform's native
  650:         end-of-line marker (i.e. LF on POSIX, CRLF on Windows).
  651: 
  652:         *want_comments*, a ``bool``.  If ``True``, emit end-of-line comments
  653:         as part of writing the file.  If ``False``, the default, do not
  654:         emit them.
  655: 
  656:         *want_origin*, a ``bool``.  If ``True``, emit a $ORIGIN line at
  657:         the start of the file.  If ``False``, the default, do not emit
  658:         one.
  659:         """
  660: 
  661:         if isinstance(f, str):
  662:             cm: contextlib.AbstractContextManager = open(f, "wb")
  663:         else:
  664:             cm = contextlib.nullcontext(f)
  665:         with cm as f:
  666:             # must be in this way, f.encoding may contain None, or even
  667:             # attribute may not be there
  668:             file_enc = getattr(f, "encoding", None)
  669:             if file_enc is None:
  670:                 file_enc = "utf-8"
  671: 
  672:             if nl is None:
  673:                 # binary mode, '\n' is not enough
  674:                 nl_b = os.linesep.encode(file_enc)
  675:                 nl = "\n"
  676:             elif isinstance(nl, str):
  677:                 nl_b = nl.encode(file_enc)
  678:             else:
  679:                 nl_b = nl
  680:                 nl = nl.decode()
  681: 
  682:             if want_origin:
  683:                 assert self.origin is not None
  684:                 l = "$ORIGIN " + self.origin.to_text()
  685:                 l_b = l.encode(file_enc)
  686:                 try:
  687:                     f.write(l_b)
  688:                     f.write(nl_b)
  689:                 except TypeError:  # textual mode
  690:                     f.write(l)
  691:                     f.write(nl)
  692: 
  693:             if sorted:
  694:                 names = list(self.keys())
  695:                 names.sort()
  696:             else:
  697:                 names = self.keys()
  698:             for n in names:
  699:                 l = self[n].to_text(
  700:                     n,
  701:                     origin=self.origin,
  702:                     relativize=relativize,
  703:                     want_comments=want_comments,
  704:                 )
  705:                 l_b = l.encode(file_enc)
  706: 
  707:                 try:
  708:                     f.write(l_b)
  709:                     f.write(nl_b)
  710:                 except TypeError:  # textual mode
  711:                     f.write(l)
  712:                     f.write(nl)
  713: 
  714:     def to_text(
  715:         self,
  716:         sorted: bool = True,
  717:         relativize: bool = True,
  718:         nl: Optional[str] = None,
  719:         want_comments: bool = False,
  720:         want_origin: bool = False,
  721:     ) -> str:
  722:         """Return a zone's text as though it were written to a file.
  723: 
  724:         *sorted*, a ``bool``.  If True, the default, then the file
  725:         will be written with the names sorted in DNSSEC order from
  726:         least to greatest.  Otherwise the names will be written in
  727:         whatever order they happen to have in the zone's dictionary.
  728: 
  729:         *relativize*, a ``bool``.  If True, the default, then domain
  730:         names in the output will be relativized to the zone's origin
  731:         if possible.
  732: 
  733:         *nl*, a ``str`` or None.  The end of line string.  If not
  734:         ``None``, the output will use the platform's native
  735:         end-of-line marker (i.e. LF on POSIX, CRLF on Windows).
  736: 
  737:         *want_comments*, a ``bool``.  If ``True``, emit end-of-line comments
  738:         as part of writing the file.  If ``False``, the default, do not
  739:         emit them.
  740: 
  741:         *want_origin*, a ``bool``.  If ``True``, emit a $ORIGIN line at
  742:         the start of the output.  If ``False``, the default, do not emit
  743:         one.
  744: 
  745:         Returns a ``str``.
  746:         """
  747:         temp_buffer = io.StringIO()
  748:         self.to_file(temp_buffer, sorted, relativize, nl, want_comments, want_origin)
  749:         return_value = temp_buffer.getvalue()
  750:         temp_buffer.close()
  751:         return return_value
  752: 
  753:     def check_origin(self) -> None:
  754:         """Do some simple checking of the zone's origin.
  755: 
  756:         Raises ``dns.zone.NoSOA`` if there is no SOA RRset.
  757: 
  758:         Raises ``dns.zone.NoNS`` if there is no NS RRset.
  759: 
  760:         Raises ``KeyError`` if there is no origin node.
  761:         """
  762:         if self.relativize:
  763:             name = dns.name.empty
  764:         else:
  765:             assert self.origin is not None
  766:             name = self.origin
  767:         if self.get_rdataset(name, dns.rdatatype.SOA) is None:
  768:             raise NoSOA
  769:         if self.get_rdataset(name, dns.rdatatype.NS) is None:
  770:             raise NoNS
  771: 
  772:     def get_soa(
  773:         self, txn: Optional[dns.transaction.Transaction] = None
  774:     ) -> dns.rdtypes.ANY.SOA.SOA:
  775:         """Get the zone SOA rdata.
  776: 
  777:         Raises ``dns.zone.NoSOA`` if there is no SOA RRset.
  778: 
  779:         Returns a ``dns.rdtypes.ANY.SOA.SOA`` Rdata.
  780:         """
  781:         if self.relativize:
  782:             origin_name = dns.name.empty
  783:         else:
  784:             if self.origin is None:
  785:                 # get_soa() has been called very early, and there must not be
  786:                 # an SOA if there is no origin.
  787:                 raise NoSOA
  788:             origin_name = self.origin
  789:         soa: Optional[dns.rdataset.Rdataset]
  790:         if txn:
  791:             soa = txn.get(origin_name, dns.rdatatype.SOA)
  792:         else:
  793:             soa = self.get_rdataset(origin_name, dns.rdatatype.SOA)
  794:         if soa is None:
  795:             raise NoSOA
  796:         return soa[0]
  797: 
  798:     def _compute_digest(
  799:         self,
  800:         hash_algorithm: DigestHashAlgorithm,
  801:         scheme: DigestScheme = DigestScheme.SIMPLE,
  802:     ) -> bytes:
  803:         hashinfo = _digest_hashers.get(hash_algorithm)
  804:         if not hashinfo:
  805:             raise UnsupportedDigestHashAlgorithm
  806:         if scheme != DigestScheme.SIMPLE:
  807:             raise UnsupportedDigestScheme
  808: 
  809:         if self.relativize:
  810:             origin_name = dns.name.empty
  811:         else:
  812:             assert self.origin is not None
  813:             origin_name = self.origin
  814:         hasher = hashinfo()
  815:         for name, node in sorted(self.items()):
  816:             rrnamebuf = name.to_digestable(self.origin)
  817:             for rdataset in sorted(node, key=lambda rds: (rds.rdtype, rds.covers)):
  818:                 if name == origin_name and dns.rdatatype.ZONEMD in (
  819:                     rdataset.rdtype,
  820:                     rdataset.covers,
  821:                 ):
  822:                     continue
  823:                 rrfixed = struct.pack(
  824:                     "!HHI", rdataset.rdtype, rdataset.rdclass, rdataset.ttl
  825:                 )
  826:                 rdatas = [rdata.to_digestable(self.origin) for rdata in rdataset]
  827:                 for rdata in sorted(rdatas):
  828:                     rrlen = struct.pack("!H", len(rdata))
  829:                     hasher.update(rrnamebuf + rrfixed + rrlen + rdata)
  830:         return hasher.digest()
  831: 
  832:     def compute_digest(
  833:         self,
  834:         hash_algorithm: DigestHashAlgorithm,
  835:         scheme: DigestScheme = DigestScheme.SIMPLE,
  836:     ) -> dns.rdtypes.ANY.ZONEMD.ZONEMD:
  837:         serial = self.get_soa().serial
  838:         digest = self._compute_digest(hash_algorithm, scheme)
  839:         return dns.rdtypes.ANY.ZONEMD.ZONEMD(
  840:             self.rdclass, dns.rdatatype.ZONEMD, serial, scheme, hash_algorithm, digest
  841:         )
  842: 
  843:     def verify_digest(
  844:         self, zonemd: Optional[dns.rdtypes.ANY.ZONEMD.ZONEMD] = None
  845:     ) -> None:
  846:         digests: Union[dns.rdataset.Rdataset, List[dns.rdtypes.ANY.ZONEMD.ZONEMD]]
  847:         if zonemd:
  848:             digests = [zonemd]
  849:         else:
  850:             assert self.origin is not None
  851:             rds = self.get_rdataset(self.origin, dns.rdatatype.ZONEMD)
  852:             if rds is None:
  853:                 raise NoDigest
  854:             digests = rds
  855:         for digest in digests:
  856:             try:
  857:                 computed = self._compute_digest(digest.hash_algorithm, digest.scheme)
  858:                 if computed == digest.digest:
  859:                     return
  860:             except Exception:
  861:                 pass
  862:         raise DigestVerificationFailure
  863: 
  864:     # TransactionManager methods
  865: 
  866:     def reader(self) -> "Transaction":
  867:         return Transaction(self, False, Version(self, 1, self.nodes, self.origin))
  868: 
  869:     def writer(self, replacement: bool = False) -> "Transaction":
  870:         txn = Transaction(self, replacement)
  871:         txn._setup_version()
  872:         return txn
  873: 
  874:     def origin_information(
  875:         self,
  876:     ) -> Tuple[Optional[dns.name.Name], bool, Optional[dns.name.Name]]:
  877:         effective: Optional[dns.name.Name]
  878:         if self.relativize:
  879:             effective = dns.name.empty
  880:         else:
  881:             effective = self.origin
  882:         return (self.origin, self.relativize, effective)
  883: 
  884:     def get_class(self):
  885:         return self.rdclass
  886: 
  887:     # Transaction methods
  888: 
  889:     def _end_read(self, txn):
  890:         pass
  891: 
  892:     def _end_write(self, txn):
  893:         pass
  894: 
  895:     def _commit_version(self, _, version, origin):
  896:         self.nodes = version.nodes
  897:         if self.origin is None:
  898:             self.origin = origin
  899: 
  900:     def _get_next_version_id(self):
  901:         # Versions are ephemeral and all have id 1
  902:         return 1
  903: 
  904: 
  905: # These classes used to be in dns.versioned, but have moved here so we can use
  906: # the copy-on-write transaction mechanism for both kinds of zones.  In a
  907: # regular zone, the version only exists during the transaction, and the nodes
  908: # are regular dns.node.Nodes.
  909: 
  910: # A node with a version id.
  911: 
  912: 
  913: class VersionedNode(dns.node.Node):  # lgtm[py/missing-equals]
  914:     __slots__ = ["id"]
  915: 
  916:     def __init__(self):
  917:         super().__init__()
  918:         # A proper id will get set by the Version
  919:         self.id = 0
  920: 
  921: 
  922: @dns.immutable.immutable
  923: class ImmutableVersionedNode(VersionedNode):
  924:     def __init__(self, node):
  925:         super().__init__()
  926:         self.id = node.id
  927:         self.rdatasets = tuple(
  928:             [dns.rdataset.ImmutableRdataset(rds) for rds in node.rdatasets]
  929:         )
  930: 
  931:     def find_rdataset(
  932:         self,
  933:         rdclass: dns.rdataclass.RdataClass,
  934:         rdtype: dns.rdatatype.RdataType,
  935:         covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,
  936:         create: bool = False,
  937:     ) -> dns.rdataset.Rdataset:
  938:         if create:
  939:             raise TypeError("immutable")
  940:         return super().find_rdataset(rdclass, rdtype, covers, False)
  941: 
  942:     def get_rdataset(
  943:         self,
  944:         rdclass: dns.rdataclass.RdataClass,
  945:         rdtype: dns.rdatatype.RdataType,
  946:         covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,
  947:         create: bool = False,
  948:     ) -> Optional[dns.rdataset.Rdataset]:
  949:         if create:
  950:             raise TypeError("immutable")
  951:         return super().get_rdataset(rdclass, rdtype, covers, False)
  952: 
  953:     def delete_rdataset(
  954:         self,
  955:         rdclass: dns.rdataclass.RdataClass,
  956:         rdtype: dns.rdatatype.RdataType,
  957:         covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,
  958:     ) -> None:
  959:         raise TypeError("immutable")
  960: 
  961:     def replace_rdataset(self, replacement: dns.rdataset.Rdataset) -> None:
  962:         raise TypeError("immutable")
  963: 
  964:     def is_immutable(self) -> bool:
  965:         return True
  966: 
  967: 
  968: class Version:
  969:     def __init__(
  970:         self,
  971:         zone: Zone,
  972:         id: int,
  973:         nodes: Optional[MutableMapping[dns.name.Name, dns.node.Node]] = None,
  974:         origin: Optional[dns.name.Name] = None,
  975:     ):
  976:         self.zone = zone
  977:         self.id = id
  978:         if nodes is not None:
  979:             self.nodes = nodes
  980:         else:
  981:             self.nodes = zone.map_factory()
  982:         self.origin = origin
  983: 
  984:     def _validate_name(self, name: dns.name.Name) -> dns.name.Name:
  985:         return _validate_name(name, self.origin, self.zone.relativize)
  986: 
  987:     def get_node(self, name: dns.name.Name) -> Optional[dns.node.Node]:
  988:         name = self._validate_name(name)
  989:         return self.nodes.get(name)
  990: 
  991:     def get_rdataset(
  992:         self,
  993:         name: dns.name.Name,
  994:         rdtype: dns.rdatatype.RdataType,
  995:         covers: dns.rdatatype.RdataType,
  996:     ) -> Optional[dns.rdataset.Rdataset]:
  997:         node = self.get_node(name)
  998:         if node is None:
  999:             return None
 1000:         return node.get_rdataset(self.zone.rdclass, rdtype, covers)
 1001: 
 1002:     def keys(self):
 1003:         return self.nodes.keys()
 1004: 
 1005:     def items(self):
 1006:         return self.nodes.items()
 1007: 
 1008: 
 1009: class WritableVersion(Version):
 1010:     def __init__(self, zone: Zone, replacement: bool = False):
 1011:         # The zone._versions_lock must be held by our caller in a versioned
 1012:         # zone.
 1013:         id = zone._get_next_version_id()
 1014:         super().__init__(zone, id)
 1015:         if not replacement:
 1016:             # We copy the map, because that gives us a simple and thread-safe
 1017:             # way of doing versions, and we have a garbage collector to help
 1018:             # us.  We only make new node objects if we actually change the
 1019:             # node.
 1020:             self.nodes.update(zone.nodes)
 1021:         # We have to copy the zone origin as it may be None in the first
 1022:         # version, and we don't want to mutate the zone until we commit.
 1023:         self.origin = zone.origin
 1024:         self.changed: Set[dns.name.Name] = set()
 1025: 
 1026:     def _maybe_cow(self, name: dns.name.Name) -> dns.node.Node:
 1027:         name = self._validate_name(name)
 1028:         node = self.nodes.get(name)
 1029:         if node is None or name not in self.changed:
 1030:             new_node = self.zone.node_factory()
 1031:             if hasattr(new_node, "id"):
 1032:                 # We keep doing this for backwards compatibility, as earlier
 1033:                 # code used new_node.id != self.id for the "do we need to CoW?"
 1034:                 # test.  Now we use the changed set as this works with both
 1035:                 # regular zones and versioned zones.
 1036:                 #
 1037:                 # We ignore the mypy error as this is safe but it doesn't see it.
 1038:                 new_node.id = self.id  # type: ignore
 1039:             if node is not None:
 1040:                 # moo!  copy on write!
 1041:                 new_node.rdatasets.extend(node.rdatasets)
 1042:             self.nodes[name] = new_node
 1043:             self.changed.add(name)
 1044:             return new_node
 1045:         else:
 1046:             return node
 1047: 
 1048:     def delete_node(self, name: dns.name.Name) -> None:
 1049:         name = self._validate_name(name)
 1050:         if name in self.nodes:
 1051:             del self.nodes[name]
 1052:             self.changed.add(name)
 1053: 
 1054:     def put_rdataset(
 1055:         self, name: dns.name.Name, rdataset: dns.rdataset.Rdataset
 1056:     ) -> None:
 1057:         node = self._maybe_cow(name)
 1058:         node.replace_rdataset(rdataset)
 1059: 
 1060:     def delete_rdataset(
 1061:         self,
 1062:         name: dns.name.Name,
 1063:         rdtype: dns.rdatatype.RdataType,
 1064:         covers: dns.rdatatype.RdataType,
 1065:     ) -> None:
 1066:         node = self._maybe_cow(name)
 1067:         node.delete_rdataset(self.zone.rdclass, rdtype, covers)
 1068:         if len(node) == 0:
 1069:             del self.nodes[name]
 1070: 
 1071: 
 1072: @dns.immutable.immutable
 1073: class ImmutableVersion(Version):
 1074:     def __init__(self, version: WritableVersion):
 1075:         # We tell super() that it's a replacement as we don't want it
 1076:         # to copy the nodes, as we're about to do that with an
 1077:         # immutable Dict.
 1078:         super().__init__(version.zone, True)
 1079:         # set the right id!
 1080:         self.id = version.id
 1081:         # keep the origin
 1082:         self.origin = version.origin
 1083:         # Make changed nodes immutable
 1084:         for name in version.changed:
 1085:             node = version.nodes.get(name)
 1086:             # it might not exist if we deleted it in the version
 1087:             if node:
 1088:                 version.nodes[name] = ImmutableVersionedNode(node)
 1089:         # We're changing the type of the nodes dictionary here on purpose, so
 1090:         # we ignore the mypy error.
 1091:         self.nodes = dns.immutable.Dict(
 1092:             version.nodes, True, self.zone.map_factory
 1093:         )  # type: ignore
 1094: 
 1095: 
 1096: class Transaction(dns.transaction.Transaction):
 1097:     def __init__(self, zone, replacement, version=None, make_immutable=False):
 1098:         read_only = version is not None
 1099:         super().__init__(zone, replacement, read_only)
 1100:         self.version = version
 1101:         self.make_immutable = make_immutable
 1102: 
 1103:     @property
 1104:     def zone(self):
 1105:         return self.manager
 1106: 
 1107:     def _setup_version(self):
 1108:         assert self.version is None
 1109:         factory = self.manager.writable_version_factory
 1110:         if factory is None:
 1111:             factory = WritableVersion
 1112:         self.version = factory(self.zone, self.replacement)
 1113: 
 1114:     def _get_rdataset(self, name, rdtype, covers):
 1115:         return self.version.get_rdataset(name, rdtype, covers)
 1116: 
 1117:     def _put_rdataset(self, name, rdataset):
 1118:         assert not self.read_only
 1119:         self.version.put_rdataset(name, rdataset)
 1120: 
 1121:     def _delete_name(self, name):
 1122:         assert not self.read_only
 1123:         self.version.delete_node(name)
 1124: 
 1125:     def _delete_rdataset(self, name, rdtype, covers):
 1126:         assert not self.read_only
 1127:         self.version.delete_rdataset(name, rdtype, covers)
 1128: 
 1129:     def _name_exists(self, name):
 1130:         return self.version.get_node(name) is not None
 1131: 
 1132:     def _changed(self):
 1133:         if self.read_only:
 1134:             return False
 1135:         else:
 1136:             return len(self.version.changed) > 0
 1137: 
 1138:     def _end_transaction(self, commit):
 1139:         if self.read_only:
 1140:             self.zone._end_read(self)
 1141:         elif commit and len(self.version.changed) > 0:
 1142:             if self.make_immutable:
 1143:                 factory = self.manager.immutable_version_factory
 1144:                 if factory is None:
 1145:                     factory = ImmutableVersion
 1146:                 version = factory(self.version)
 1147:             else:
 1148:                 version = self.version
 1149:             self.zone._commit_version(self, version, self.version.origin)
 1150:         else:
 1151:             # rollback
 1152:             self.zone._end_write(self)
 1153: 
 1154:     def _set_origin(self, origin):
 1155:         if self.version.origin is None:
 1156:             self.version.origin = origin
 1157: 
 1158:     def _iterate_rdatasets(self):
 1159:         for name, node in self.version.items():
 1160:             for rdataset in node:
 1161:                 yield (name, rdataset)
 1162: 
 1163:     def _iterate_names(self):
 1164:         return self.version.keys()
 1165: 
 1166:     def _get_node(self, name):
 1167:         return self.version.get_node(name)
 1168: 
 1169:     def _origin_information(self):
 1170:         (absolute, relativize, effective) = self.manager.origin_information()
 1171:         if absolute is None and self.version.origin is not None:
 1172:             # No origin has been committed yet, but we've learned one as part of
 1173:             # this txn.  Use it.
 1174:             absolute = self.version.origin
 1175:             if relativize:
 1176:                 effective = dns.name.empty
 1177:             else:
 1178:                 effective = absolute
 1179:         return (absolute, relativize, effective)
 1180: 
 1181: 
 1182: def _from_text(
 1183:     text: Any,
 1184:     origin: Optional[Union[dns.name.Name, str]] = None,
 1185:     rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,
 1186:     relativize: bool = True,
 1187:     zone_factory: Any = Zone,
 1188:     filename: Optional[str] = None,
 1189:     allow_include: bool = False,
 1190:     check_origin: bool = True,
 1191:     idna_codec: Optional[dns.name.IDNACodec] = None,
 1192:     allow_directives: Union[bool, Iterable[str]] = True,
 1193: ) -> Zone:
 1194:     # See the comments for the public APIs from_text() and from_file() for
 1195:     # details.
 1196: 
 1197:     # 'text' can also be a file, but we don't publish that fact
 1198:     # since it's an implementation detail.  The official file
 1199:     # interface is from_file().
 1200: 
 1201:     if filename is None:
 1202:         filename = "<string>"
 1203:     zone = zone_factory(origin, rdclass, relativize=relativize)
 1204:     with zone.writer(True) as txn:
 1205:         tok = dns.tokenizer.Tokenizer(text, filename, idna_codec=idna_codec)
 1206:         reader = dns.zonefile.Reader(
 1207:             tok,
 1208:             rdclass,
 1209:             txn,
 1210:             allow_include=allow_include,
 1211:             allow_directives=allow_directives,
 1212:         )
 1213:         try:
 1214:             reader.read()
 1215:         except dns.zonefile.UnknownOrigin:
 1216:             # for backwards compatibility
 1217:             raise dns.zone.UnknownOrigin
 1218:     # Now that we're done reading, do some basic checking of the zone.
 1219:     if check_origin:
 1220:         zone.check_origin()
 1221:     return zone
 1222: 
 1223: 
 1224: def from_text(
 1225:     text: str,
 1226:     origin: Optional[Union[dns.name.Name, str]] = None,
 1227:     rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,
 1228:     relativize: bool = True,
 1229:     zone_factory: Any = Zone,
 1230:     filename: Optional[str] = None,
 1231:     allow_include: bool = False,
 1232:     check_origin: bool = True,
 1233:     idna_codec: Optional[dns.name.IDNACodec] = None,
 1234:     allow_directives: Union[bool, Iterable[str]] = True,
 1235: ) -> Zone:
 1236:     """Build a zone object from a zone file format string.
 1237: 
 1238:     *text*, a ``str``, the zone file format input.
 1239: 
 1240:     *origin*, a ``dns.name.Name``, a ``str``, or ``None``.  The origin
 1241:     of the zone; if not specified, the first ``$ORIGIN`` statement in the
 1242:     zone file will determine the origin of the zone.
 1243: 
 1244:     *rdclass*, a ``dns.rdataclass.RdataClass``, the zone's rdata class; the default is
 1245:     class IN.
 1246: 
 1247:     *relativize*, a ``bool``, determine's whether domain names are
 1248:     relativized to the zone's origin.  The default is ``True``.
 1249: 
 1250:     *zone_factory*, the zone factory to use or ``None``.  If ``None``, then
 1251:     ``dns.zone.Zone`` will be used.  The value may be any class or callable
 1252:     that returns a subclass of ``dns.zone.Zone``.
 1253: 
 1254:     *filename*, a ``str`` or ``None``, the filename to emit when
 1255:     describing where an error occurred; the default is ``'<string>'``.
 1256: 
 1257:     *allow_include*, a ``bool``.  If ``True``, the default, then ``$INCLUDE``
 1258:     directives are permitted.  If ``False``, then encoutering a ``$INCLUDE``
 1259:     will raise a ``SyntaxError`` exception.
 1260: 
 1261:     *check_origin*, a ``bool``.  If ``True``, the default, then sanity
 1262:     checks of the origin node will be made by calling the zone's
 1263:     ``check_origin()`` method.
 1264: 
 1265:     *idna_codec*, a ``dns.name.IDNACodec``, specifies the IDNA
 1266:     encoder/decoder.  If ``None``, the default IDNA 2003 encoder/decoder
 1267:     is used.
 1268: 
 1269:     *allow_directives*, a ``bool`` or an iterable of `str`.  If ``True``, the default,
 1270:     then directives are permitted, and the *allow_include* parameter controls whether
 1271:     ``$INCLUDE`` is permitted.  If ``False`` or an empty iterable, then no directive
 1272:     processing is done and any directive-like text will be treated as a regular owner
 1273:     name.  If a non-empty iterable, then only the listed directives (including the
 1274:     ``$``) are allowed.
 1275: 
 1276:     Raises ``dns.zone.NoSOA`` if there is no SOA RRset.
 1277: 
 1278:     Raises ``dns.zone.NoNS`` if there is no NS RRset.
 1279: 
 1280:     Raises ``KeyError`` if there is no origin node.
 1281: 
 1282:     Returns a subclass of ``dns.zone.Zone``.
 1283:     """
 1284:     return _from_text(
 1285:         text,
 1286:         origin,
 1287:         rdclass,
 1288:         relativize,
 1289:         zone_factory,
 1290:         filename,
 1291:         allow_include,
 1292:         check_origin,
 1293:         idna_codec,
 1294:         allow_directives,
 1295:     )
 1296: 
 1297: 
 1298: def from_file(
 1299:     f: Any,
 1300:     origin: Optional[Union[dns.name.Name, str]] = None,
 1301:     rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,
 1302:     relativize: bool = True,
 1303:     zone_factory: Any = Zone,
 1304:     filename: Optional[str] = None,
 1305:     allow_include: bool = True,
 1306:     check_origin: bool = True,
 1307:     idna_codec: Optional[dns.name.IDNACodec] = None,
 1308:     allow_directives: Union[bool, Iterable[str]] = True,
 1309: ) -> Zone:
 1310:     """Read a zone file and build a zone object.
 1311: 
 1312:     *f*, a file or ``str``.  If *f* is a string, it is treated
 1313:     as the name of a file to open.
 1314: 
 1315:     *origin*, a ``dns.name.Name``, a ``str``, or ``None``.  The origin
 1316:     of the zone; if not specified, the first ``$ORIGIN`` statement in the
 1317:     zone file will determine the origin of the zone.
 1318: 
 1319:     *rdclass*, an ``int``, the zone's rdata class; the default is class IN.
 1320: 
 1321:     *relativize*, a ``bool``, determine's whether domain names are
 1322:     relativized to the zone's origin.  The default is ``True``.
 1323: 
 1324:     *zone_factory*, the zone factory to use or ``None``.  If ``None``, then
 1325:     ``dns.zone.Zone`` will be used.  The value may be any class or callable
 1326:     that returns a subclass of ``dns.zone.Zone``.
 1327: 
 1328:     *filename*, a ``str`` or ``None``, the filename to emit when
 1329:     describing where an error occurred; the default is ``'<string>'``.
 1330: 
 1331:     *allow_include*, a ``bool``.  If ``True``, the default, then ``$INCLUDE``
 1332:     directives are permitted.  If ``False``, then encoutering a ``$INCLUDE``
 1333:     will raise a ``SyntaxError`` exception.
 1334: 
 1335:     *check_origin*, a ``bool``.  If ``True``, the default, then sanity
 1336:     checks of the origin node will be made by calling the zone's
 1337:     ``check_origin()`` method.
 1338: 
 1339:     *idna_codec*, a ``dns.name.IDNACodec``, specifies the IDNA
 1340:     encoder/decoder.  If ``None``, the default IDNA 2003 encoder/decoder
 1341:     is used.
 1342: 
 1343:     *allow_directives*, a ``bool`` or an iterable of `str`.  If ``True``, the default,
 1344:     then directives are permitted, and the *allow_include* parameter controls whether
 1345:     ``$INCLUDE`` is permitted.  If ``False`` or an empty iterable, then no directive
 1346:     processing is done and any directive-like text will be treated as a regular owner
 1347:     name.  If a non-empty iterable, then only the listed directives (including the
 1348:     ``$``) are allowed.
 1349: 
 1350:     Raises ``dns.zone.NoSOA`` if there is no SOA RRset.
 1351: 
 1352:     Raises ``dns.zone.NoNS`` if there is no NS RRset.
 1353: 
 1354:     Raises ``KeyError`` if there is no origin node.
 1355: 
 1356:     Returns a subclass of ``dns.zone.Zone``.
 1357:     """
 1358: 
 1359:     if isinstance(f, str):
 1360:         if filename is None:
 1361:             filename = f
 1362:         cm: contextlib.AbstractContextManager = open(f)
 1363:     else:
 1364:         cm = contextlib.nullcontext(f)
 1365:     with cm as f:
 1366:         return _from_text(
 1367:             f,
 1368:             origin,
 1369:             rdclass,
 1370:             relativize,
 1371:             zone_factory,
 1372:             filename,
 1373:             allow_include,
 1374:             check_origin,
 1375:             idna_codec,
 1376:             allow_directives,
 1377:         )
 1378:     assert False  # make mypy happy  lgtm[py/unreachable-statement]
 1379: 
 1380: 
 1381: def from_xfr(
 1382:     xfr: Any,
 1383:     zone_factory: Any = Zone,
 1384:     relativize: bool = True,
 1385:     check_origin: bool = True,
 1386: ) -> Zone:
 1387:     """Convert the output of a zone transfer generator into a zone object.
 1388: 
 1389:     *xfr*, a generator of ``dns.message.Message`` objects, typically
 1390:     ``dns.query.xfr()``.
 1391: 
 1392:     *relativize*, a ``bool``, determine's whether domain names are
 1393:     relativized to the zone's origin.  The default is ``True``.
 1394:     It is essential that the relativize setting matches the one specified
 1395:     to the generator.
 1396: 
 1397:     *check_origin*, a ``bool``.  If ``True``, the default, then sanity
 1398:     checks of the origin node will be made by calling the zone's
 1399:     ``check_origin()`` method.
 1400: 
 1401:     Raises ``dns.zone.NoSOA`` if there is no SOA RRset.
 1402: 
 1403:     Raises ``dns.zone.NoNS`` if there is no NS RRset.
 1404: 
 1405:     Raises ``KeyError`` if there is no origin node.
 1406: 
 1407:     Raises ``ValueError`` if no messages are yielded by the generator.
 1408: 
 1409:     Returns a subclass of ``dns.zone.Zone``.
 1410:     """
 1411: 
 1412:     z = None
 1413:     for r in xfr:
 1414:         if z is None:
 1415:             if relativize:
 1416:                 origin = r.origin
 1417:             else:
 1418:                 origin = r.answer[0].name
 1419:             rdclass = r.answer[0].rdclass
 1420:             z = zone_factory(origin, rdclass, relativize=relativize)
 1421:         for rrset in r.answer:
 1422:             znode = z.nodes.get(rrset.name)
 1423:             if not znode:
 1424:                 znode = z.node_factory()
 1425:                 z.nodes[rrset.name] = znode
 1426:             zrds = znode.find_rdataset(rrset.rdclass, rrset.rdtype, rrset.covers, True)
 1427:             zrds.update_ttl(rrset.ttl)
 1428:             for rd in rrset:
 1429:                 zrds.add(rd)
 1430:     if z is None:
 1431:         raise ValueError("empty transfer")
 1432:     if check_origin:
 1433:         z.check_origin()
 1434:     return z
