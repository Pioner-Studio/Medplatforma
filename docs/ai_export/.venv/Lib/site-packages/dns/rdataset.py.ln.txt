    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2001-2017 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: """DNS rdatasets (an rdataset is a set of rdatas of a given type and class)"""
   19: 
   20: import io
   21: import random
   22: import struct
   23: from typing import Any, Collection, Dict, List, Optional, Union, cast
   24: 
   25: import dns.exception
   26: import dns.immutable
   27: import dns.name
   28: import dns.rdata
   29: import dns.rdataclass
   30: import dns.rdatatype
   31: import dns.renderer
   32: import dns.set
   33: import dns.ttl
   34: 
   35: # define SimpleSet here for backwards compatibility
   36: SimpleSet = dns.set.Set
   37: 
   38: 
   39: class DifferingCovers(dns.exception.DNSException):
   40:     """An attempt was made to add a DNS SIG/RRSIG whose covered type
   41:     is not the same as that of the other rdatas in the rdataset."""
   42: 
   43: 
   44: class IncompatibleTypes(dns.exception.DNSException):
   45:     """An attempt was made to add DNS RR data of an incompatible type."""
   46: 
   47: 
   48: class Rdataset(dns.set.Set):
   49:     """A DNS rdataset."""
   50: 
   51:     __slots__ = ["rdclass", "rdtype", "covers", "ttl"]
   52: 
   53:     def __init__(
   54:         self,
   55:         rdclass: dns.rdataclass.RdataClass,
   56:         rdtype: dns.rdatatype.RdataType,
   57:         covers: dns.rdatatype.RdataType = dns.rdatatype.NONE,
   58:         ttl: int = 0,
   59:     ):
   60:         """Create a new rdataset of the specified class and type.
   61: 
   62:         *rdclass*, a ``dns.rdataclass.RdataClass``, the rdataclass.
   63: 
   64:         *rdtype*, an ``dns.rdatatype.RdataType``, the rdatatype.
   65: 
   66:         *covers*, an ``dns.rdatatype.RdataType``, the covered rdatatype.
   67: 
   68:         *ttl*, an ``int``, the TTL.
   69:         """
   70: 
   71:         super().__init__()
   72:         self.rdclass = rdclass
   73:         self.rdtype: dns.rdatatype.RdataType = rdtype
   74:         self.covers: dns.rdatatype.RdataType = covers
   75:         self.ttl = ttl
   76: 
   77:     def _clone(self):
   78:         obj = super()._clone()
   79:         obj.rdclass = self.rdclass
   80:         obj.rdtype = self.rdtype
   81:         obj.covers = self.covers
   82:         obj.ttl = self.ttl
   83:         return obj
   84: 
   85:     def update_ttl(self, ttl: int) -> None:
   86:         """Perform TTL minimization.
   87: 
   88:         Set the TTL of the rdataset to be the lesser of the set's current
   89:         TTL or the specified TTL.  If the set contains no rdatas, set the TTL
   90:         to the specified TTL.
   91: 
   92:         *ttl*, an ``int`` or ``str``.
   93:         """
   94:         ttl = dns.ttl.make(ttl)
   95:         if len(self) == 0:
   96:             self.ttl = ttl
   97:         elif ttl < self.ttl:
   98:             self.ttl = ttl
   99: 
  100:     def add(  # pylint: disable=arguments-differ,arguments-renamed
  101:         self, rd: dns.rdata.Rdata, ttl: Optional[int] = None
  102:     ) -> None:
  103:         """Add the specified rdata to the rdataset.
  104: 
  105:         If the optional *ttl* parameter is supplied, then
  106:         ``self.update_ttl(ttl)`` will be called prior to adding the rdata.
  107: 
  108:         *rd*, a ``dns.rdata.Rdata``, the rdata
  109: 
  110:         *ttl*, an ``int``, the TTL.
  111: 
  112:         Raises ``dns.rdataset.IncompatibleTypes`` if the type and class
  113:         do not match the type and class of the rdataset.
  114: 
  115:         Raises ``dns.rdataset.DifferingCovers`` if the type is a signature
  116:         type and the covered type does not match that of the rdataset.
  117:         """
  118: 
  119:         #
  120:         # If we're adding a signature, do some special handling to
  121:         # check that the signature covers the same type as the
  122:         # other rdatas in this rdataset.  If this is the first rdata
  123:         # in the set, initialize the covers field.
  124:         #
  125:         if self.rdclass != rd.rdclass or self.rdtype != rd.rdtype:
  126:             raise IncompatibleTypes
  127:         if ttl is not None:
  128:             self.update_ttl(ttl)
  129:         if self.rdtype == dns.rdatatype.RRSIG or self.rdtype == dns.rdatatype.SIG:
  130:             covers = rd.covers()
  131:             if len(self) == 0 and self.covers == dns.rdatatype.NONE:
  132:                 self.covers = covers
  133:             elif self.covers != covers:
  134:                 raise DifferingCovers
  135:         if dns.rdatatype.is_singleton(rd.rdtype) and len(self) > 0:
  136:             self.clear()
  137:         super().add(rd)
  138: 
  139:     def union_update(self, other):
  140:         self.update_ttl(other.ttl)
  141:         super().union_update(other)
  142: 
  143:     def intersection_update(self, other):
  144:         self.update_ttl(other.ttl)
  145:         super().intersection_update(other)
  146: 
  147:     def update(self, other):
  148:         """Add all rdatas in other to self.
  149: 
  150:         *other*, a ``dns.rdataset.Rdataset``, the rdataset from which
  151:         to update.
  152:         """
  153: 
  154:         self.update_ttl(other.ttl)
  155:         super().update(other)
  156: 
  157:     def _rdata_repr(self):
  158:         def maybe_truncate(s):
  159:             if len(s) > 100:
  160:                 return s[:100] + "..."
  161:             return s
  162: 
  163:         return "[%s]" % ", ".join("<%s>" % maybe_truncate(str(rr)) for rr in self)
  164: 
  165:     def __repr__(self):
  166:         if self.covers == 0:
  167:             ctext = ""
  168:         else:
  169:             ctext = "(" + dns.rdatatype.to_text(self.covers) + ")"
  170:         return (
  171:             "<DNS "
  172:             + dns.rdataclass.to_text(self.rdclass)
  173:             + " "
  174:             + dns.rdatatype.to_text(self.rdtype)
  175:             + ctext
  176:             + " rdataset: "
  177:             + self._rdata_repr()
  178:             + ">"
  179:         )
  180: 
  181:     def __str__(self):
  182:         return self.to_text()
  183: 
  184:     def __eq__(self, other):
  185:         if not isinstance(other, Rdataset):
  186:             return False
  187:         if (
  188:             self.rdclass != other.rdclass
  189:             or self.rdtype != other.rdtype
  190:             or self.covers != other.covers
  191:         ):
  192:             return False
  193:         return super().__eq__(other)
  194: 
  195:     def __ne__(self, other):
  196:         return not self.__eq__(other)
  197: 
  198:     def to_text(
  199:         self,
  200:         name: Optional[dns.name.Name] = None,
  201:         origin: Optional[dns.name.Name] = None,
  202:         relativize: bool = True,
  203:         override_rdclass: Optional[dns.rdataclass.RdataClass] = None,
  204:         want_comments: bool = False,
  205:         **kw: Dict[str, Any],
  206:     ) -> str:
  207:         """Convert the rdataset into DNS zone file format.
  208: 
  209:         See ``dns.name.Name.choose_relativity`` for more information
  210:         on how *origin* and *relativize* determine the way names
  211:         are emitted.
  212: 
  213:         Any additional keyword arguments are passed on to the rdata
  214:         ``to_text()`` method.
  215: 
  216:         *name*, a ``dns.name.Name``.  If name is not ``None``, emit RRs with
  217:         *name* as the owner name.
  218: 
  219:         *origin*, a ``dns.name.Name`` or ``None``, the origin for relative
  220:         names.
  221: 
  222:         *relativize*, a ``bool``.  If ``True``, names will be relativized
  223:         to *origin*.
  224: 
  225:         *override_rdclass*, a ``dns.rdataclass.RdataClass`` or ``None``.
  226:         If not ``None``, use this class instead of the Rdataset's class.
  227: 
  228:         *want_comments*, a ``bool``.  If ``True``, emit comments for rdata
  229:         which have them.  The default is ``False``.
  230:         """
  231: 
  232:         if name is not None:
  233:             name = name.choose_relativity(origin, relativize)
  234:             ntext = str(name)
  235:             pad = " "
  236:         else:
  237:             ntext = ""
  238:             pad = ""
  239:         s = io.StringIO()
  240:         if override_rdclass is not None:
  241:             rdclass = override_rdclass
  242:         else:
  243:             rdclass = self.rdclass
  244:         if len(self) == 0:
  245:             #
  246:             # Empty rdatasets are used for the question section, and in
  247:             # some dynamic updates, so we don't need to print out the TTL
  248:             # (which is meaningless anyway).
  249:             #
  250:             s.write(
  251:                 "{}{}{} {}\n".format(
  252:                     ntext,
  253:                     pad,
  254:                     dns.rdataclass.to_text(rdclass),
  255:                     dns.rdatatype.to_text(self.rdtype),
  256:                 )
  257:             )
  258:         else:
  259:             for rd in self:
  260:                 extra = ""
  261:                 if want_comments:
  262:                     if rd.rdcomment:
  263:                         extra = f" ;{rd.rdcomment}"
  264:                 s.write(
  265:                     "%s%s%d %s %s %s%s\n"
  266:                     % (
  267:                         ntext,
  268:                         pad,
  269:                         self.ttl,
  270:                         dns.rdataclass.to_text(rdclass),
  271:                         dns.rdatatype.to_text(self.rdtype),
  272:                         rd.to_text(origin=origin, relativize=relativize, **kw),
  273:                         extra,
  274:                     )
  275:                 )
  276:         #
  277:         # We strip off the final \n for the caller's convenience in printing
  278:         #
  279:         return s.getvalue()[:-1]
  280: 
  281:     def to_wire(
  282:         self,
  283:         name: dns.name.Name,
  284:         file: Any,
  285:         compress: Optional[dns.name.CompressType] = None,
  286:         origin: Optional[dns.name.Name] = None,
  287:         override_rdclass: Optional[dns.rdataclass.RdataClass] = None,
  288:         want_shuffle: bool = True,
  289:     ) -> int:
  290:         """Convert the rdataset to wire format.
  291: 
  292:         *name*, a ``dns.name.Name`` is the owner name to use.
  293: 
  294:         *file* is the file where the name is emitted (typically a
  295:         BytesIO file).
  296: 
  297:         *compress*, a ``dict``, is the compression table to use.  If
  298:         ``None`` (the default), names will not be compressed.
  299: 
  300:         *origin* is a ``dns.name.Name`` or ``None``.  If the name is
  301:         relative and origin is not ``None``, then *origin* will be appended
  302:         to it.
  303: 
  304:         *override_rdclass*, an ``int``, is used as the class instead of the
  305:         class of the rdataset.  This is useful when rendering rdatasets
  306:         associated with dynamic updates.
  307: 
  308:         *want_shuffle*, a ``bool``.  If ``True``, then the order of the
  309:         Rdatas within the Rdataset will be shuffled before rendering.
  310: 
  311:         Returns an ``int``, the number of records emitted.
  312:         """
  313: 
  314:         if override_rdclass is not None:
  315:             rdclass = override_rdclass
  316:             want_shuffle = False
  317:         else:
  318:             rdclass = self.rdclass
  319:         if len(self) == 0:
  320:             name.to_wire(file, compress, origin)
  321:             file.write(struct.pack("!HHIH", self.rdtype, rdclass, 0, 0))
  322:             return 1
  323:         else:
  324:             l: Union[Rdataset, List[dns.rdata.Rdata]]
  325:             if want_shuffle:
  326:                 l = list(self)
  327:                 random.shuffle(l)
  328:             else:
  329:                 l = self
  330:             for rd in l:
  331:                 name.to_wire(file, compress, origin)
  332:                 file.write(struct.pack("!HHI", self.rdtype, rdclass, self.ttl))
  333:                 with dns.renderer.prefixed_length(file, 2):
  334:                     rd.to_wire(file, compress, origin)
  335:             return len(self)
  336: 
  337:     def match(
  338:         self,
  339:         rdclass: dns.rdataclass.RdataClass,
  340:         rdtype: dns.rdatatype.RdataType,
  341:         covers: dns.rdatatype.RdataType,
  342:     ) -> bool:
  343:         """Returns ``True`` if this rdataset matches the specified class,
  344:         type, and covers.
  345:         """
  346:         if self.rdclass == rdclass and self.rdtype == rdtype and self.covers == covers:
  347:             return True
  348:         return False
  349: 
  350:     def processing_order(self) -> List[dns.rdata.Rdata]:
  351:         """Return rdatas in a valid processing order according to the type's
  352:         specification.  For example, MX records are in preference order from
  353:         lowest to highest preferences, with items of the same preference
  354:         shuffled.
  355: 
  356:         For types that do not define a processing order, the rdatas are
  357:         simply shuffled.
  358:         """
  359:         if len(self) == 0:
  360:             return []
  361:         else:
  362:             return self[0]._processing_order(iter(self))
  363: 
  364: 
  365: @dns.immutable.immutable
  366: class ImmutableRdataset(Rdataset):  # lgtm[py/missing-equals]
  367:     """An immutable DNS rdataset."""
  368: 
  369:     _clone_class = Rdataset
  370: 
  371:     def __init__(self, rdataset: Rdataset):
  372:         """Create an immutable rdataset from the specified rdataset."""
  373: 
  374:         super().__init__(
  375:             rdataset.rdclass, rdataset.rdtype, rdataset.covers, rdataset.ttl
  376:         )
  377:         self.items = dns.immutable.Dict(rdataset.items)
  378: 
  379:     def update_ttl(self, ttl):
  380:         raise TypeError("immutable")
  381: 
  382:     def add(self, rd, ttl=None):
  383:         raise TypeError("immutable")
  384: 
  385:     def union_update(self, other):
  386:         raise TypeError("immutable")
  387: 
  388:     def intersection_update(self, other):
  389:         raise TypeError("immutable")
  390: 
  391:     def update(self, other):
  392:         raise TypeError("immutable")
  393: 
  394:     def __delitem__(self, i):
  395:         raise TypeError("immutable")
  396: 
  397:     # lgtm complains about these not raising ArithmeticError, but there is
  398:     # precedent for overrides of these methods in other classes to raise
  399:     # TypeError, and it seems like the better exception.
  400: 
  401:     def __ior__(self, other):  # lgtm[py/unexpected-raise-in-special-method]
  402:         raise TypeError("immutable")
  403: 
  404:     def __iand__(self, other):  # lgtm[py/unexpected-raise-in-special-method]
  405:         raise TypeError("immutable")
  406: 
  407:     def __iadd__(self, other):  # lgtm[py/unexpected-raise-in-special-method]
  408:         raise TypeError("immutable")
  409: 
  410:     def __isub__(self, other):  # lgtm[py/unexpected-raise-in-special-method]
  411:         raise TypeError("immutable")
  412: 
  413:     def clear(self):
  414:         raise TypeError("immutable")
  415: 
  416:     def __copy__(self):
  417:         return ImmutableRdataset(super().copy())
  418: 
  419:     def copy(self):
  420:         return ImmutableRdataset(super().copy())
  421: 
  422:     def union(self, other):
  423:         return ImmutableRdataset(super().union(other))
  424: 
  425:     def intersection(self, other):
  426:         return ImmutableRdataset(super().intersection(other))
  427: 
  428:     def difference(self, other):
  429:         return ImmutableRdataset(super().difference(other))
  430: 
  431:     def symmetric_difference(self, other):
  432:         return ImmutableRdataset(super().symmetric_difference(other))
  433: 
  434: 
  435: def from_text_list(
  436:     rdclass: Union[dns.rdataclass.RdataClass, str],
  437:     rdtype: Union[dns.rdatatype.RdataType, str],
  438:     ttl: int,
  439:     text_rdatas: Collection[str],
  440:     idna_codec: Optional[dns.name.IDNACodec] = None,
  441:     origin: Optional[dns.name.Name] = None,
  442:     relativize: bool = True,
  443:     relativize_to: Optional[dns.name.Name] = None,
  444: ) -> Rdataset:
  445:     """Create an rdataset with the specified class, type, and TTL, and with
  446:     the specified list of rdatas in text format.
  447: 
  448:     *idna_codec*, a ``dns.name.IDNACodec``, specifies the IDNA
  449:     encoder/decoder to use; if ``None``, the default IDNA 2003
  450:     encoder/decoder is used.
  451: 
  452:     *origin*, a ``dns.name.Name`` (or ``None``), the
  453:     origin to use for relative names.
  454: 
  455:     *relativize*, a ``bool``.  If true, name will be relativized.
  456: 
  457:     *relativize_to*, a ``dns.name.Name`` (or ``None``), the origin to use
  458:     when relativizing names.  If not set, the *origin* value will be used.
  459: 
  460:     Returns a ``dns.rdataset.Rdataset`` object.
  461:     """
  462: 
  463:     rdclass = dns.rdataclass.RdataClass.make(rdclass)
  464:     rdtype = dns.rdatatype.RdataType.make(rdtype)
  465:     r = Rdataset(rdclass, rdtype)
  466:     r.update_ttl(ttl)
  467:     for t in text_rdatas:
  468:         rd = dns.rdata.from_text(
  469:             r.rdclass, r.rdtype, t, origin, relativize, relativize_to, idna_codec
  470:         )
  471:         r.add(rd)
  472:     return r
  473: 
  474: 
  475: def from_text(
  476:     rdclass: Union[dns.rdataclass.RdataClass, str],
  477:     rdtype: Union[dns.rdatatype.RdataType, str],
  478:     ttl: int,
  479:     *text_rdatas: Any,
  480: ) -> Rdataset:
  481:     """Create an rdataset with the specified class, type, and TTL, and with
  482:     the specified rdatas in text format.
  483: 
  484:     Returns a ``dns.rdataset.Rdataset`` object.
  485:     """
  486: 
  487:     return from_text_list(rdclass, rdtype, ttl, cast(Collection[str], text_rdatas))
  488: 
  489: 
  490: def from_rdata_list(ttl: int, rdatas: Collection[dns.rdata.Rdata]) -> Rdataset:
  491:     """Create an rdataset with the specified TTL, and with
  492:     the specified list of rdata objects.
  493: 
  494:     Returns a ``dns.rdataset.Rdataset`` object.
  495:     """
  496: 
  497:     if len(rdatas) == 0:
  498:         raise ValueError("rdata list must not be empty")
  499:     r = None
  500:     for rd in rdatas:
  501:         if r is None:
  502:             r = Rdataset(rd.rdclass, rd.rdtype)
  503:             r.update_ttl(ttl)
  504:         r.add(rd)
  505:     assert r is not None
  506:     return r
  507: 
  508: 
  509: def from_rdata(ttl: int, *rdatas: Any) -> Rdataset:
  510:     """Create an rdataset with the specified TTL, and with
  511:     the specified rdata objects.
  512: 
  513:     Returns a ``dns.rdataset.Rdataset`` object.
  514:     """
  515: 
  516:     return from_rdata_list(ttl, cast(Collection[dns.rdata.Rdata], rdatas))
