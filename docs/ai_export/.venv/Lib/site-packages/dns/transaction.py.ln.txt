    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: import collections
    4: from typing import Any, Callable, Iterator, List, Optional, Tuple, Union
    5: 
    6: import dns.exception
    7: import dns.name
    8: import dns.node
    9: import dns.rdataclass
   10: import dns.rdataset
   11: import dns.rdatatype
   12: import dns.rrset
   13: import dns.serial
   14: import dns.ttl
   15: 
   16: 
   17: class TransactionManager:
   18:     def reader(self) -> "Transaction":
   19:         """Begin a read-only transaction."""
   20:         raise NotImplementedError  # pragma: no cover
   21: 
   22:     def writer(self, replacement: bool = False) -> "Transaction":
   23:         """Begin a writable transaction.
   24: 
   25:         *replacement*, a ``bool``.  If `True`, the content of the
   26:         transaction completely replaces any prior content.  If False,
   27:         the default, then the content of the transaction updates the
   28:         existing content.
   29:         """
   30:         raise NotImplementedError  # pragma: no cover
   31: 
   32:     def origin_information(
   33:         self,
   34:     ) -> Tuple[Optional[dns.name.Name], bool, Optional[dns.name.Name]]:
   35:         """Returns a tuple
   36: 
   37:             (absolute_origin, relativize, effective_origin)
   38: 
   39:         giving the absolute name of the default origin for any
   40:         relative domain names, the "effective origin", and whether
   41:         names should be relativized.  The "effective origin" is the
   42:         absolute origin if relativize is False, and the empty name if
   43:         relativize is true.  (The effective origin is provided even
   44:         though it can be computed from the absolute_origin and
   45:         relativize setting because it avoids a lot of code
   46:         duplication.)
   47: 
   48:         If the returned names are `None`, then no origin information is
   49:         available.
   50: 
   51:         This information is used by code working with transactions to
   52:         allow it to coordinate relativization.  The transaction code
   53:         itself takes what it gets (i.e. does not change name
   54:         relativity).
   55: 
   56:         """
   57:         raise NotImplementedError  # pragma: no cover
   58: 
   59:     def get_class(self) -> dns.rdataclass.RdataClass:
   60:         """The class of the transaction manager."""
   61:         raise NotImplementedError  # pragma: no cover
   62: 
   63:     def from_wire_origin(self) -> Optional[dns.name.Name]:
   64:         """Origin to use in from_wire() calls."""
   65:         (absolute_origin, relativize, _) = self.origin_information()
   66:         if relativize:
   67:             return absolute_origin
   68:         else:
   69:             return None
   70: 
   71: 
   72: class DeleteNotExact(dns.exception.DNSException):
   73:     """Existing data did not match data specified by an exact delete."""
   74: 
   75: 
   76: class ReadOnly(dns.exception.DNSException):
   77:     """Tried to write to a read-only transaction."""
   78: 
   79: 
   80: class AlreadyEnded(dns.exception.DNSException):
   81:     """Tried to use an already-ended transaction."""
   82: 
   83: 
   84: def _ensure_immutable_rdataset(rdataset):
   85:     if rdataset is None or isinstance(rdataset, dns.rdataset.ImmutableRdataset):
   86:         return rdataset
   87:     return dns.rdataset.ImmutableRdataset(rdataset)
   88: 
   89: 
   90: def _ensure_immutable_node(node):
   91:     if node is None or node.is_immutable():
   92:         return node
   93:     return dns.node.ImmutableNode(node)
   94: 
   95: 
   96: CheckPutRdatasetType = Callable[
   97:     ["Transaction", dns.name.Name, dns.rdataset.Rdataset], None
   98: ]
   99: CheckDeleteRdatasetType = Callable[
  100:     ["Transaction", dns.name.Name, dns.rdatatype.RdataType, dns.rdatatype.RdataType],
  101:     None,
  102: ]
  103: CheckDeleteNameType = Callable[["Transaction", dns.name.Name], None]
  104: 
  105: 
  106: class Transaction:
  107:     def __init__(
  108:         self,
  109:         manager: TransactionManager,
  110:         replacement: bool = False,
  111:         read_only: bool = False,
  112:     ):
  113:         self.manager = manager
  114:         self.replacement = replacement
  115:         self.read_only = read_only
  116:         self._ended = False
  117:         self._check_put_rdataset: List[CheckPutRdatasetType] = []
  118:         self._check_delete_rdataset: List[CheckDeleteRdatasetType] = []
  119:         self._check_delete_name: List[CheckDeleteNameType] = []
  120: 
  121:     #
  122:     # This is the high level API
  123:     #
  124:     # Note that we currently use non-immutable types in the return type signature to
  125:     # avoid covariance problems, e.g. if the caller has a List[Rdataset], mypy will be
  126:     # unhappy if we return an ImmutableRdataset.
  127: 
  128:     def get(
  129:         self,
  130:         name: Optional[Union[dns.name.Name, str]],
  131:         rdtype: Union[dns.rdatatype.RdataType, str],
  132:         covers: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.NONE,
  133:     ) -> dns.rdataset.Rdataset:
  134:         """Return the rdataset associated with *name*, *rdtype*, and *covers*,
  135:         or `None` if not found.
  136: 
  137:         Note that the returned rdataset is immutable.
  138:         """
  139:         self._check_ended()
  140:         if isinstance(name, str):
  141:             name = dns.name.from_text(name, None)
  142:         rdtype = dns.rdatatype.RdataType.make(rdtype)
  143:         covers = dns.rdatatype.RdataType.make(covers)
  144:         rdataset = self._get_rdataset(name, rdtype, covers)
  145:         return _ensure_immutable_rdataset(rdataset)
  146: 
  147:     def get_node(self, name: dns.name.Name) -> Optional[dns.node.Node]:
  148:         """Return the node at *name*, if any.
  149: 
  150:         Returns an immutable node or ``None``.
  151:         """
  152:         return _ensure_immutable_node(self._get_node(name))
  153: 
  154:     def _check_read_only(self) -> None:
  155:         if self.read_only:
  156:             raise ReadOnly
  157: 
  158:     def add(self, *args: Any) -> None:
  159:         """Add records.
  160: 
  161:         The arguments may be:
  162: 
  163:             - rrset
  164: 
  165:             - name, rdataset...
  166: 
  167:             - name, ttl, rdata...
  168:         """
  169:         self._check_ended()
  170:         self._check_read_only()
  171:         self._add(False, args)
  172: 
  173:     def replace(self, *args: Any) -> None:
  174:         """Replace the existing rdataset at the name with the specified
  175:         rdataset, or add the specified rdataset if there was no existing
  176:         rdataset.
  177: 
  178:         The arguments may be:
  179: 
  180:             - rrset
  181: 
  182:             - name, rdataset...
  183: 
  184:             - name, ttl, rdata...
  185: 
  186:         Note that if you want to replace the entire node, you should do
  187:         a delete of the name followed by one or more calls to add() or
  188:         replace().
  189:         """
  190:         self._check_ended()
  191:         self._check_read_only()
  192:         self._add(True, args)
  193: 
  194:     def delete(self, *args: Any) -> None:
  195:         """Delete records.
  196: 
  197:         It is not an error if some of the records are not in the existing
  198:         set.
  199: 
  200:         The arguments may be:
  201: 
  202:             - rrset
  203: 
  204:             - name
  205: 
  206:             - name, rdatatype, [covers]
  207: 
  208:             - name, rdataset...
  209: 
  210:             - name, rdata...
  211:         """
  212:         self._check_ended()
  213:         self._check_read_only()
  214:         self._delete(False, args)
  215: 
  216:     def delete_exact(self, *args: Any) -> None:
  217:         """Delete records.
  218: 
  219:         The arguments may be:
  220: 
  221:             - rrset
  222: 
  223:             - name
  224: 
  225:             - name, rdatatype, [covers]
  226: 
  227:             - name, rdataset...
  228: 
  229:             - name, rdata...
  230: 
  231:         Raises dns.transaction.DeleteNotExact if some of the records
  232:         are not in the existing set.
  233: 
  234:         """
  235:         self._check_ended()
  236:         self._check_read_only()
  237:         self._delete(True, args)
  238: 
  239:     def name_exists(self, name: Union[dns.name.Name, str]) -> bool:
  240:         """Does the specified name exist?"""
  241:         self._check_ended()
  242:         if isinstance(name, str):
  243:             name = dns.name.from_text(name, None)
  244:         return self._name_exists(name)
  245: 
  246:     def update_serial(
  247:         self,
  248:         value: int = 1,
  249:         relative: bool = True,
  250:         name: dns.name.Name = dns.name.empty,
  251:     ) -> None:
  252:         """Update the serial number.
  253: 
  254:         *value*, an `int`, is an increment if *relative* is `True`, or the
  255:         actual value to set if *relative* is `False`.
  256: 
  257:         Raises `KeyError` if there is no SOA rdataset at *name*.
  258: 
  259:         Raises `ValueError` if *value* is negative or if the increment is
  260:         so large that it would cause the new serial to be less than the
  261:         prior value.
  262:         """
  263:         self._check_ended()
  264:         if value < 0:
  265:             raise ValueError("negative update_serial() value")
  266:         if isinstance(name, str):
  267:             name = dns.name.from_text(name, None)
  268:         rdataset = self._get_rdataset(name, dns.rdatatype.SOA, dns.rdatatype.NONE)
  269:         if rdataset is None or len(rdataset) == 0:
  270:             raise KeyError
  271:         if relative:
  272:             serial = dns.serial.Serial(rdataset[0].serial) + value
  273:         else:
  274:             serial = dns.serial.Serial(value)
  275:         serial = serial.value  # convert back to int
  276:         if serial == 0:
  277:             serial = 1
  278:         rdata = rdataset[0].replace(serial=serial)
  279:         new_rdataset = dns.rdataset.from_rdata(rdataset.ttl, rdata)
  280:         self.replace(name, new_rdataset)
  281: 
  282:     def __iter__(self):
  283:         self._check_ended()
  284:         return self._iterate_rdatasets()
  285: 
  286:     def changed(self) -> bool:
  287:         """Has this transaction changed anything?
  288: 
  289:         For read-only transactions, the result is always `False`.
  290: 
  291:         For writable transactions, the result is `True` if at some time
  292:         during the life of the transaction, the content was changed.
  293:         """
  294:         self._check_ended()
  295:         return self._changed()
  296: 
  297:     def commit(self) -> None:
  298:         """Commit the transaction.
  299: 
  300:         Normally transactions are used as context managers and commit
  301:         or rollback automatically, but it may be done explicitly if needed.
  302:         A ``dns.transaction.Ended`` exception will be raised if you try
  303:         to use a transaction after it has been committed or rolled back.
  304: 
  305:         Raises an exception if the commit fails (in which case the transaction
  306:         is also rolled back.
  307:         """
  308:         self._end(True)
  309: 
  310:     def rollback(self) -> None:
  311:         """Rollback the transaction.
  312: 
  313:         Normally transactions are used as context managers and commit
  314:         or rollback automatically, but it may be done explicitly if needed.
  315:         A ``dns.transaction.AlreadyEnded`` exception will be raised if you try
  316:         to use a transaction after it has been committed or rolled back.
  317: 
  318:         Rollback cannot otherwise fail.
  319:         """
  320:         self._end(False)
  321: 
  322:     def check_put_rdataset(self, check: CheckPutRdatasetType) -> None:
  323:         """Call *check* before putting (storing) an rdataset.
  324: 
  325:         The function is called with the transaction, the name, and the rdataset.
  326: 
  327:         The check function may safely make non-mutating transaction method
  328:         calls, but behavior is undefined if mutating transaction methods are
  329:         called.  The check function should raise an exception if it objects to
  330:         the put, and otherwise should return ``None``.
  331:         """
  332:         self._check_put_rdataset.append(check)
  333: 
  334:     def check_delete_rdataset(self, check: CheckDeleteRdatasetType) -> None:
  335:         """Call *check* before deleting an rdataset.
  336: 
  337:         The function is called with the transaction, the name, the rdatatype,
  338:         and the covered rdatatype.
  339: 
  340:         The check function may safely make non-mutating transaction method
  341:         calls, but behavior is undefined if mutating transaction methods are
  342:         called.  The check function should raise an exception if it objects to
  343:         the put, and otherwise should return ``None``.
  344:         """
  345:         self._check_delete_rdataset.append(check)
  346: 
  347:     def check_delete_name(self, check: CheckDeleteNameType) -> None:
  348:         """Call *check* before putting (storing) an rdataset.
  349: 
  350:         The function is called with the transaction and the name.
  351: 
  352:         The check function may safely make non-mutating transaction method
  353:         calls, but behavior is undefined if mutating transaction methods are
  354:         called.  The check function should raise an exception if it objects to
  355:         the put, and otherwise should return ``None``.
  356:         """
  357:         self._check_delete_name.append(check)
  358: 
  359:     def iterate_rdatasets(
  360:         self,
  361:     ) -> Iterator[Tuple[dns.name.Name, dns.rdataset.Rdataset]]:
  362:         """Iterate all the rdatasets in the transaction, returning
  363:         (`dns.name.Name`, `dns.rdataset.Rdataset`) tuples.
  364: 
  365:         Note that as is usual with python iterators, adding or removing items
  366:         while iterating will invalidate the iterator and may raise `RuntimeError`
  367:         or fail to iterate over all entries."""
  368:         self._check_ended()
  369:         return self._iterate_rdatasets()
  370: 
  371:     def iterate_names(self) -> Iterator[dns.name.Name]:
  372:         """Iterate all the names in the transaction.
  373: 
  374:         Note that as is usual with python iterators, adding or removing names
  375:         while iterating will invalidate the iterator and may raise `RuntimeError`
  376:         or fail to iterate over all entries."""
  377:         self._check_ended()
  378:         return self._iterate_names()
  379: 
  380:     #
  381:     # Helper methods
  382:     #
  383: 
  384:     def _raise_if_not_empty(self, method, args):
  385:         if len(args) != 0:
  386:             raise TypeError(f"extra parameters to {method}")
  387: 
  388:     def _rdataset_from_args(self, method, deleting, args):
  389:         try:
  390:             arg = args.popleft()
  391:             if isinstance(arg, dns.rrset.RRset):
  392:                 rdataset = arg.to_rdataset()
  393:             elif isinstance(arg, dns.rdataset.Rdataset):
  394:                 rdataset = arg
  395:             else:
  396:                 if deleting:
  397:                     ttl = 0
  398:                 else:
  399:                     if isinstance(arg, int):
  400:                         ttl = arg
  401:                         if ttl > dns.ttl.MAX_TTL:
  402:                             raise ValueError(f"{method}: TTL value too big")
  403:                     else:
  404:                         raise TypeError(f"{method}: expected a TTL")
  405:                     arg = args.popleft()
  406:                 if isinstance(arg, dns.rdata.Rdata):
  407:                     rdataset = dns.rdataset.from_rdata(ttl, arg)
  408:                 else:
  409:                     raise TypeError(f"{method}: expected an Rdata")
  410:             return rdataset
  411:         except IndexError:
  412:             if deleting:
  413:                 return None
  414:             else:
  415:                 # reraise
  416:                 raise TypeError(f"{method}: expected more arguments")
  417: 
  418:     def _add(self, replace, args):
  419:         try:
  420:             args = collections.deque(args)
  421:             if replace:
  422:                 method = "replace()"
  423:             else:
  424:                 method = "add()"
  425:             arg = args.popleft()
  426:             if isinstance(arg, str):
  427:                 arg = dns.name.from_text(arg, None)
  428:             if isinstance(arg, dns.name.Name):
  429:                 name = arg
  430:                 rdataset = self._rdataset_from_args(method, False, args)
  431:             elif isinstance(arg, dns.rrset.RRset):
  432:                 rrset = arg
  433:                 name = rrset.name
  434:                 # rrsets are also rdatasets, but they don't print the
  435:                 # same and can't be stored in nodes, so convert.
  436:                 rdataset = rrset.to_rdataset()
  437:             else:
  438:                 raise TypeError(
  439:                     f"{method} requires a name or RRset as the first argument"
  440:                 )
  441:             if rdataset.rdclass != self.manager.get_class():
  442:                 raise ValueError(f"{method} has objects of wrong RdataClass")
  443:             if rdataset.rdtype == dns.rdatatype.SOA:
  444:                 (_, _, origin) = self._origin_information()
  445:                 if name != origin:
  446:                     raise ValueError(f"{method} has non-origin SOA")
  447:             self._raise_if_not_empty(method, args)
  448:             if not replace:
  449:                 existing = self._get_rdataset(name, rdataset.rdtype, rdataset.covers)
  450:                 if existing is not None:
  451:                     if isinstance(existing, dns.rdataset.ImmutableRdataset):
  452:                         trds = dns.rdataset.Rdataset(
  453:                             existing.rdclass, existing.rdtype, existing.covers
  454:                         )
  455:                         trds.update(existing)
  456:                         existing = trds
  457:                     rdataset = existing.union(rdataset)
  458:             self._checked_put_rdataset(name, rdataset)
  459:         except IndexError:
  460:             raise TypeError(f"not enough parameters to {method}")
  461: 
  462:     def _delete(self, exact, args):
  463:         try:
  464:             args = collections.deque(args)
  465:             if exact:
  466:                 method = "delete_exact()"
  467:             else:
  468:                 method = "delete()"
  469:             arg = args.popleft()
  470:             if isinstance(arg, str):
  471:                 arg = dns.name.from_text(arg, None)
  472:             if isinstance(arg, dns.name.Name):
  473:                 name = arg
  474:                 if len(args) > 0 and (
  475:                     isinstance(args[0], int) or isinstance(args[0], str)
  476:                 ):
  477:                     # deleting by type and (optionally) covers
  478:                     rdtype = dns.rdatatype.RdataType.make(args.popleft())
  479:                     if len(args) > 0:
  480:                         covers = dns.rdatatype.RdataType.make(args.popleft())
  481:                     else:
  482:                         covers = dns.rdatatype.NONE
  483:                     self._raise_if_not_empty(method, args)
  484:                     existing = self._get_rdataset(name, rdtype, covers)
  485:                     if existing is None:
  486:                         if exact:
  487:                             raise DeleteNotExact(f"{method}: missing rdataset")
  488:                     else:
  489:                         self._delete_rdataset(name, rdtype, covers)
  490:                     return
  491:                 else:
  492:                     rdataset = self._rdataset_from_args(method, True, args)
  493:             elif isinstance(arg, dns.rrset.RRset):
  494:                 rdataset = arg  # rrsets are also rdatasets
  495:                 name = rdataset.name
  496:             else:
  497:                 raise TypeError(
  498:                     f"{method} requires a name or RRset as the first argument"
  499:                 )
  500:             self._raise_if_not_empty(method, args)
  501:             if rdataset:
  502:                 if rdataset.rdclass != self.manager.get_class():
  503:                     raise ValueError(f"{method} has objects of wrong RdataClass")
  504:                 existing = self._get_rdataset(name, rdataset.rdtype, rdataset.covers)
  505:                 if existing is not None:
  506:                     if exact:
  507:                         intersection = existing.intersection(rdataset)
  508:                         if intersection != rdataset:
  509:                             raise DeleteNotExact(f"{method}: missing rdatas")
  510:                     rdataset = existing.difference(rdataset)
  511:                     if len(rdataset) == 0:
  512:                         self._checked_delete_rdataset(
  513:                             name, rdataset.rdtype, rdataset.covers
  514:                         )
  515:                     else:
  516:                         self._checked_put_rdataset(name, rdataset)
  517:                 elif exact:
  518:                     raise DeleteNotExact(f"{method}: missing rdataset")
  519:             else:
  520:                 if exact and not self._name_exists(name):
  521:                     raise DeleteNotExact(f"{method}: name not known")
  522:                 self._checked_delete_name(name)
  523:         except IndexError:
  524:             raise TypeError(f"not enough parameters to {method}")
  525: 
  526:     def _check_ended(self):
  527:         if self._ended:
  528:             raise AlreadyEnded
  529: 
  530:     def _end(self, commit):
  531:         self._check_ended()
  532:         if self._ended:
  533:             raise AlreadyEnded
  534:         try:
  535:             self._end_transaction(commit)
  536:         finally:
  537:             self._ended = True
  538: 
  539:     def _checked_put_rdataset(self, name, rdataset):
  540:         for check in self._check_put_rdataset:
  541:             check(self, name, rdataset)
  542:         self._put_rdataset(name, rdataset)
  543: 
  544:     def _checked_delete_rdataset(self, name, rdtype, covers):
  545:         for check in self._check_delete_rdataset:
  546:             check(self, name, rdtype, covers)
  547:         self._delete_rdataset(name, rdtype, covers)
  548: 
  549:     def _checked_delete_name(self, name):
  550:         for check in self._check_delete_name:
  551:             check(self, name)
  552:         self._delete_name(name)
  553: 
  554:     #
  555:     # Transactions are context managers.
  556:     #
  557: 
  558:     def __enter__(self):
  559:         return self
  560: 
  561:     def __exit__(self, exc_type, exc_val, exc_tb):
  562:         if not self._ended:
  563:             if exc_type is None:
  564:                 self.commit()
  565:             else:
  566:                 self.rollback()
  567:         return False
  568: 
  569:     #
  570:     # This is the low level API, which must be implemented by subclasses
  571:     # of Transaction.
  572:     #
  573: 
  574:     def _get_rdataset(self, name, rdtype, covers):
  575:         """Return the rdataset associated with *name*, *rdtype*, and *covers*,
  576:         or `None` if not found.
  577:         """
  578:         raise NotImplementedError  # pragma: no cover
  579: 
  580:     def _put_rdataset(self, name, rdataset):
  581:         """Store the rdataset."""
  582:         raise NotImplementedError  # pragma: no cover
  583: 
  584:     def _delete_name(self, name):
  585:         """Delete all data associated with *name*.
  586: 
  587:         It is not an error if the name does not exist.
  588:         """
  589:         raise NotImplementedError  # pragma: no cover
  590: 
  591:     def _delete_rdataset(self, name, rdtype, covers):
  592:         """Delete all data associated with *name*, *rdtype*, and *covers*.
  593: 
  594:         It is not an error if the rdataset does not exist.
  595:         """
  596:         raise NotImplementedError  # pragma: no cover
  597: 
  598:     def _name_exists(self, name):
  599:         """Does name exist?
  600: 
  601:         Returns a bool.
  602:         """
  603:         raise NotImplementedError  # pragma: no cover
  604: 
  605:     def _changed(self):
  606:         """Has this transaction changed anything?"""
  607:         raise NotImplementedError  # pragma: no cover
  608: 
  609:     def _end_transaction(self, commit):
  610:         """End the transaction.
  611: 
  612:         *commit*, a bool.  If ``True``, commit the transaction, otherwise
  613:         roll it back.
  614: 
  615:         If committing and the commit fails, then roll back and raise an
  616:         exception.
  617:         """
  618:         raise NotImplementedError  # pragma: no cover
  619: 
  620:     def _set_origin(self, origin):
  621:         """Set the origin.
  622: 
  623:         This method is called when reading a possibly relativized
  624:         source, and an origin setting operation occurs (e.g. $ORIGIN
  625:         in a zone file).
  626:         """
  627:         raise NotImplementedError  # pragma: no cover
  628: 
  629:     def _iterate_rdatasets(self):
  630:         """Return an iterator that yields (name, rdataset) tuples."""
  631:         raise NotImplementedError  # pragma: no cover
  632: 
  633:     def _iterate_names(self):
  634:         """Return an iterator that yields a name."""
  635:         raise NotImplementedError  # pragma: no cover
  636: 
  637:     def _get_node(self, name):
  638:         """Return the node at *name*, if any.
  639: 
  640:         Returns a node or ``None``.
  641:         """
  642:         raise NotImplementedError  # pragma: no cover
  643: 
  644:     #
  645:     # Low-level API with a default implementation, in case a subclass needs
  646:     # to override.
  647:     #
  648: 
  649:     def _origin_information(self):
  650:         # This is only used by _add()
  651:         return self.manager.origin_information()
