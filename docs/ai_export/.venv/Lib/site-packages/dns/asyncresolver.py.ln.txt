    1: # Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license
    2: 
    3: # Copyright (C) 2003-2017 Nominum, Inc.
    4: #
    5: # Permission to use, copy, modify, and distribute this software and its
    6: # documentation for any purpose with or without fee is hereby granted,
    7: # provided that the above copyright notice and this permission notice
    8: # appear in all copies.
    9: #
   10: # THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
   11: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   12: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
   13: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   14: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   15: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
   16: # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   17: 
   18: """Asynchronous DNS stub resolver."""
   19: 
   20: import socket
   21: import time
   22: from typing import Any, Dict, List, Optional, Union
   23: 
   24: import dns._ddr
   25: import dns.asyncbackend
   26: import dns.asyncquery
   27: import dns.exception
   28: import dns.name
   29: import dns.query
   30: import dns.rdataclass
   31: import dns.rdatatype
   32: import dns.resolver  # lgtm[py/import-and-import-from]
   33: 
   34: # import some resolver symbols for brevity
   35: from dns.resolver import NXDOMAIN, NoAnswer, NoRootSOA, NotAbsolute
   36: 
   37: # for indentation purposes below
   38: _udp = dns.asyncquery.udp
   39: _tcp = dns.asyncquery.tcp
   40: 
   41: 
   42: class Resolver(dns.resolver.BaseResolver):
   43:     """Asynchronous DNS stub resolver."""
   44: 
   45:     async def resolve(
   46:         self,
   47:         qname: Union[dns.name.Name, str],
   48:         rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,
   49:         rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,
   50:         tcp: bool = False,
   51:         source: Optional[str] = None,
   52:         raise_on_no_answer: bool = True,
   53:         source_port: int = 0,
   54:         lifetime: Optional[float] = None,
   55:         search: Optional[bool] = None,
   56:         backend: Optional[dns.asyncbackend.Backend] = None,
   57:     ) -> dns.resolver.Answer:
   58:         """Query nameservers asynchronously to find the answer to the question.
   59: 
   60:         *backend*, a ``dns.asyncbackend.Backend``, or ``None``.  If ``None``,
   61:         the default, then dnspython will use the default backend.
   62: 
   63:         See :py:func:`dns.resolver.Resolver.resolve()` for the
   64:         documentation of the other parameters, exceptions, and return
   65:         type of this method.
   66:         """
   67: 
   68:         resolution = dns.resolver._Resolution(
   69:             self, qname, rdtype, rdclass, tcp, raise_on_no_answer, search
   70:         )
   71:         if not backend:
   72:             backend = dns.asyncbackend.get_default_backend()
   73:         start = time.time()
   74:         while True:
   75:             (request, answer) = resolution.next_request()
   76:             # Note we need to say "if answer is not None" and not just
   77:             # "if answer" because answer implements __len__, and python
   78:             # will call that.  We want to return if we have an answer
   79:             # object, including in cases where its length is 0.
   80:             if answer is not None:
   81:                 # cache hit!
   82:                 return answer
   83:             assert request is not None  # needed for type checking
   84:             done = False
   85:             while not done:
   86:                 (nameserver, tcp, backoff) = resolution.next_nameserver()
   87:                 if backoff:
   88:                     await backend.sleep(backoff)
   89:                 timeout = self._compute_timeout(start, lifetime, resolution.errors)
   90:                 try:
   91:                     response = await nameserver.async_query(
   92:                         request,
   93:                         timeout=timeout,
   94:                         source=source,
   95:                         source_port=source_port,
   96:                         max_size=tcp,
   97:                         backend=backend,
   98:                     )
   99:                 except Exception as ex:
  100:                     (_, done) = resolution.query_result(None, ex)
  101:                     continue
  102:                 (answer, done) = resolution.query_result(response, None)
  103:                 # Note we need to say "if answer is not None" and not just
  104:                 # "if answer" because answer implements __len__, and python
  105:                 # will call that.  We want to return if we have an answer
  106:                 # object, including in cases where its length is 0.
  107:                 if answer is not None:
  108:                     return answer
  109: 
  110:     async def resolve_address(
  111:         self, ipaddr: str, *args: Any, **kwargs: Any
  112:     ) -> dns.resolver.Answer:
  113:         """Use an asynchronous resolver to run a reverse query for PTR
  114:         records.
  115: 
  116:         This utilizes the resolve() method to perform a PTR lookup on the
  117:         specified IP address.
  118: 
  119:         *ipaddr*, a ``str``, the IPv4 or IPv6 address you want to get
  120:         the PTR record for.
  121: 
  122:         All other arguments that can be passed to the resolve() function
  123:         except for rdtype and rdclass are also supported by this
  124:         function.
  125: 
  126:         """
  127:         # We make a modified kwargs for type checking happiness, as otherwise
  128:         # we get a legit warning about possibly having rdtype and rdclass
  129:         # in the kwargs more than once.
  130:         modified_kwargs: Dict[str, Any] = {}
  131:         modified_kwargs.update(kwargs)
  132:         modified_kwargs["rdtype"] = dns.rdatatype.PTR
  133:         modified_kwargs["rdclass"] = dns.rdataclass.IN
  134:         return await self.resolve(
  135:             dns.reversename.from_address(ipaddr), *args, **modified_kwargs
  136:         )
  137: 
  138:     async def resolve_name(
  139:         self,
  140:         name: Union[dns.name.Name, str],
  141:         family: int = socket.AF_UNSPEC,
  142:         **kwargs: Any,
  143:     ) -> dns.resolver.HostAnswers:
  144:         """Use an asynchronous resolver to query for address records.
  145: 
  146:         This utilizes the resolve() method to perform A and/or AAAA lookups on
  147:         the specified name.
  148: 
  149:         *qname*, a ``dns.name.Name`` or ``str``, the name to resolve.
  150: 
  151:         *family*, an ``int``, the address family.  If socket.AF_UNSPEC
  152:         (the default), both A and AAAA records will be retrieved.
  153: 
  154:         All other arguments that can be passed to the resolve() function
  155:         except for rdtype and rdclass are also supported by this
  156:         function.
  157:         """
  158:         # We make a modified kwargs for type checking happiness, as otherwise
  159:         # we get a legit warning about possibly having rdtype and rdclass
  160:         # in the kwargs more than once.
  161:         modified_kwargs: Dict[str, Any] = {}
  162:         modified_kwargs.update(kwargs)
  163:         modified_kwargs.pop("rdtype", None)
  164:         modified_kwargs["rdclass"] = dns.rdataclass.IN
  165: 
  166:         if family == socket.AF_INET:
  167:             v4 = await self.resolve(name, dns.rdatatype.A, **modified_kwargs)
  168:             return dns.resolver.HostAnswers.make(v4=v4)
  169:         elif family == socket.AF_INET6:
  170:             v6 = await self.resolve(name, dns.rdatatype.AAAA, **modified_kwargs)
  171:             return dns.resolver.HostAnswers.make(v6=v6)
  172:         elif family != socket.AF_UNSPEC:
  173:             raise NotImplementedError(f"unknown address family {family}")
  174: 
  175:         raise_on_no_answer = modified_kwargs.pop("raise_on_no_answer", True)
  176:         lifetime = modified_kwargs.pop("lifetime", None)
  177:         start = time.time()
  178:         v6 = await self.resolve(
  179:             name,
  180:             dns.rdatatype.AAAA,
  181:             raise_on_no_answer=False,
  182:             lifetime=self._compute_timeout(start, lifetime),
  183:             **modified_kwargs,
  184:         )
  185:         # Note that setting name ensures we query the same name
  186:         # for A as we did for AAAA.  (This is just in case search lists
  187:         # are active by default in the resolver configuration and
  188:         # we might be talking to a server that says NXDOMAIN when it
  189:         # wants to say NOERROR no data.
  190:         name = v6.qname
  191:         v4 = await self.resolve(
  192:             name,
  193:             dns.rdatatype.A,
  194:             raise_on_no_answer=False,
  195:             lifetime=self._compute_timeout(start, lifetime),
  196:             **modified_kwargs,
  197:         )
  198:         answers = dns.resolver.HostAnswers.make(
  199:             v6=v6, v4=v4, add_empty=not raise_on_no_answer
  200:         )
  201:         if not answers:
  202:             raise NoAnswer(response=v6.response)
  203:         return answers
  204: 
  205:     # pylint: disable=redefined-outer-name
  206: 
  207:     async def canonical_name(self, name: Union[dns.name.Name, str]) -> dns.name.Name:
  208:         """Determine the canonical name of *name*.
  209: 
  210:         The canonical name is the name the resolver uses for queries
  211:         after all CNAME and DNAME renamings have been applied.
  212: 
  213:         *name*, a ``dns.name.Name`` or ``str``, the query name.
  214: 
  215:         This method can raise any exception that ``resolve()`` can
  216:         raise, other than ``dns.resolver.NoAnswer`` and
  217:         ``dns.resolver.NXDOMAIN``.
  218: 
  219:         Returns a ``dns.name.Name``.
  220:         """
  221:         try:
  222:             answer = await self.resolve(name, raise_on_no_answer=False)
  223:             canonical_name = answer.canonical_name
  224:         except dns.resolver.NXDOMAIN as e:
  225:             canonical_name = e.canonical_name
  226:         return canonical_name
  227: 
  228:     async def try_ddr(self, lifetime: float = 5.0) -> None:
  229:         """Try to update the resolver's nameservers using Discovery of Designated
  230:         Resolvers (DDR).  If successful, the resolver will subsequently use
  231:         DNS-over-HTTPS or DNS-over-TLS for future queries.
  232: 
  233:         *lifetime*, a float, is the maximum time to spend attempting DDR.  The default
  234:         is 5 seconds.
  235: 
  236:         If the SVCB query is successful and results in a non-empty list of nameservers,
  237:         then the resolver's nameservers are set to the returned servers in priority
  238:         order.
  239: 
  240:         The current implementation does not use any address hints from the SVCB record,
  241:         nor does it resolve addresses for the SCVB target name, rather it assumes that
  242:         the bootstrap nameserver will always be one of the addresses and uses it.
  243:         A future revision to the code may offer fuller support.  The code verifies that
  244:         the bootstrap nameserver is in the Subject Alternative Name field of the
  245:         TLS certficate.
  246:         """
  247:         try:
  248:             expiration = time.time() + lifetime
  249:             answer = await self.resolve(
  250:                 dns._ddr._local_resolver_name, "svcb", lifetime=lifetime
  251:             )
  252:             timeout = dns.query._remaining(expiration)
  253:             nameservers = await dns._ddr._get_nameservers_async(answer, timeout)
  254:             if len(nameservers) > 0:
  255:                 self.nameservers = nameservers
  256:         except Exception:
  257:             pass
  258: 
  259: 
  260: default_resolver = None
  261: 
  262: 
  263: def get_default_resolver() -> Resolver:
  264:     """Get the default asynchronous resolver, initializing it if necessary."""
  265:     if default_resolver is None:
  266:         reset_default_resolver()
  267:     assert default_resolver is not None
  268:     return default_resolver
  269: 
  270: 
  271: def reset_default_resolver() -> None:
  272:     """Re-initialize default asynchronous resolver.
  273: 
  274:     Note that the resolver configuration (i.e. /etc/resolv.conf on UNIX
  275:     systems) will be re-read immediately.
  276:     """
  277: 
  278:     global default_resolver
  279:     default_resolver = Resolver()
  280: 
  281: 
  282: async def resolve(
  283:     qname: Union[dns.name.Name, str],
  284:     rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,
  285:     rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,
  286:     tcp: bool = False,
  287:     source: Optional[str] = None,
  288:     raise_on_no_answer: bool = True,
  289:     source_port: int = 0,
  290:     lifetime: Optional[float] = None,
  291:     search: Optional[bool] = None,
  292:     backend: Optional[dns.asyncbackend.Backend] = None,
  293: ) -> dns.resolver.Answer:
  294:     """Query nameservers asynchronously to find the answer to the question.
  295: 
  296:     This is a convenience function that uses the default resolver
  297:     object to make the query.
  298: 
  299:     See :py:func:`dns.asyncresolver.Resolver.resolve` for more
  300:     information on the parameters.
  301:     """
  302: 
  303:     return await get_default_resolver().resolve(
  304:         qname,
  305:         rdtype,
  306:         rdclass,
  307:         tcp,
  308:         source,
  309:         raise_on_no_answer,
  310:         source_port,
  311:         lifetime,
  312:         search,
  313:         backend,
  314:     )
  315: 
  316: 
  317: async def resolve_address(
  318:     ipaddr: str, *args: Any, **kwargs: Any
  319: ) -> dns.resolver.Answer:
  320:     """Use a resolver to run a reverse query for PTR records.
  321: 
  322:     See :py:func:`dns.asyncresolver.Resolver.resolve_address` for more
  323:     information on the parameters.
  324:     """
  325: 
  326:     return await get_default_resolver().resolve_address(ipaddr, *args, **kwargs)
  327: 
  328: 
  329: async def resolve_name(
  330:     name: Union[dns.name.Name, str], family: int = socket.AF_UNSPEC, **kwargs: Any
  331: ) -> dns.resolver.HostAnswers:
  332:     """Use a resolver to asynchronously query for address records.
  333: 
  334:     See :py:func:`dns.asyncresolver.Resolver.resolve_name` for more
  335:     information on the parameters.
  336:     """
  337: 
  338:     return await get_default_resolver().resolve_name(name, family, **kwargs)
  339: 
  340: 
  341: async def canonical_name(name: Union[dns.name.Name, str]) -> dns.name.Name:
  342:     """Determine the canonical name of *name*.
  343: 
  344:     See :py:func:`dns.resolver.Resolver.canonical_name` for more
  345:     information on the parameters and possible exceptions.
  346:     """
  347: 
  348:     return await get_default_resolver().canonical_name(name)
  349: 
  350: 
  351: async def try_ddr(timeout: float = 5.0) -> None:
  352:     """Try to update the default resolver's nameservers using Discovery of Designated
  353:     Resolvers (DDR).  If successful, the resolver will subsequently use
  354:     DNS-over-HTTPS or DNS-over-TLS for future queries.
  355: 
  356:     See :py:func:`dns.resolver.Resolver.try_ddr` for more information.
  357:     """
  358:     return await get_default_resolver().try_ddr(timeout)
  359: 
  360: 
  361: async def zone_for_name(
  362:     name: Union[dns.name.Name, str],
  363:     rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN,
  364:     tcp: bool = False,
  365:     resolver: Optional[Resolver] = None,
  366:     backend: Optional[dns.asyncbackend.Backend] = None,
  367: ) -> dns.name.Name:
  368:     """Find the name of the zone which contains the specified name.
  369: 
  370:     See :py:func:`dns.resolver.Resolver.zone_for_name` for more
  371:     information on the parameters and possible exceptions.
  372:     """
  373: 
  374:     if isinstance(name, str):
  375:         name = dns.name.from_text(name, dns.name.root)
  376:     if resolver is None:
  377:         resolver = get_default_resolver()
  378:     if not name.is_absolute():
  379:         raise NotAbsolute(name)
  380:     while True:
  381:         try:
  382:             answer = await resolver.resolve(
  383:                 name, dns.rdatatype.SOA, rdclass, tcp, backend=backend
  384:             )
  385:             assert answer.rrset is not None
  386:             if answer.rrset.name == name:
  387:                 return name
  388:             # otherwise we were CNAMEd or DNAMEd and need to look higher
  389:         except (NXDOMAIN, NoAnswer):
  390:             pass
  391:         try:
  392:             name = name.parent()
  393:         except dns.name.NoParent:  # pragma: no cover
  394:             raise NoRootSOA
  395: 
  396: 
  397: async def make_resolver_at(
  398:     where: Union[dns.name.Name, str],
  399:     port: int = 53,
  400:     family: int = socket.AF_UNSPEC,
  401:     resolver: Optional[Resolver] = None,
  402: ) -> Resolver:
  403:     """Make a stub resolver using the specified destination as the full resolver.
  404: 
  405:     *where*, a ``dns.name.Name`` or ``str`` the domain name or IP address of the
  406:     full resolver.
  407: 
  408:     *port*, an ``int``, the port to use.  If not specified, the default is 53.
  409: 
  410:     *family*, an ``int``, the address family to use.  This parameter is used if
  411:     *where* is not an address.  The default is ``socket.AF_UNSPEC`` in which case
  412:     the first address returned by ``resolve_name()`` will be used, otherwise the
  413:     first address of the specified family will be used.
  414: 
  415:     *resolver*, a ``dns.asyncresolver.Resolver`` or ``None``, the resolver to use for
  416:     resolution of hostnames.  If not specified, the default resolver will be used.
  417: 
  418:     Returns a ``dns.resolver.Resolver`` or raises an exception.
  419:     """
  420:     if resolver is None:
  421:         resolver = get_default_resolver()
  422:     nameservers: List[Union[str, dns.nameserver.Nameserver]] = []
  423:     if isinstance(where, str) and dns.inet.is_address(where):
  424:         nameservers.append(dns.nameserver.Do53Nameserver(where, port))
  425:     else:
  426:         answers = await resolver.resolve_name(where, family)
  427:         for address in answers.addresses():
  428:             nameservers.append(dns.nameserver.Do53Nameserver(address, port))
  429:     res = dns.asyncresolver.Resolver(configure=False)
  430:     res.nameservers = nameservers
  431:     return res
  432: 
  433: 
  434: async def resolve_at(
  435:     where: Union[dns.name.Name, str],
  436:     qname: Union[dns.name.Name, str],
  437:     rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,
  438:     rdclass: Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,
  439:     tcp: bool = False,
  440:     source: Optional[str] = None,
  441:     raise_on_no_answer: bool = True,
  442:     source_port: int = 0,
  443:     lifetime: Optional[float] = None,
  444:     search: Optional[bool] = None,
  445:     backend: Optional[dns.asyncbackend.Backend] = None,
  446:     port: int = 53,
  447:     family: int = socket.AF_UNSPEC,
  448:     resolver: Optional[Resolver] = None,
  449: ) -> dns.resolver.Answer:
  450:     """Query nameservers to find the answer to the question.
  451: 
  452:     This is a convenience function that calls ``dns.asyncresolver.make_resolver_at()``
  453:     to make a resolver, and then uses it to resolve the query.
  454: 
  455:     See ``dns.asyncresolver.Resolver.resolve`` for more information on the resolution
  456:     parameters, and ``dns.asyncresolver.make_resolver_at`` for information about the
  457:     resolver parameters *where*, *port*, *family*, and *resolver*.
  458: 
  459:     If making more than one query, it is more efficient to call
  460:     ``dns.asyncresolver.make_resolver_at()`` and then use that resolver for the queries
  461:     instead of calling ``resolve_at()`` multiple times.
  462:     """
  463:     res = await make_resolver_at(where, port, family, resolver)
  464:     return await res.resolve(
  465:         qname,
  466:         rdtype,
  467:         rdclass,
  468:         tcp,
  469:         source,
  470:         raise_on_no_answer,
  471:         source_port,
  472:         lifetime,
  473:         search,
  474:         backend,
  475:     )
