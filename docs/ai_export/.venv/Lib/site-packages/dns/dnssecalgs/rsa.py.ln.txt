    1: import math
    2: import struct
    3: 
    4: from cryptography.hazmat.backends import default_backend
    5: from cryptography.hazmat.primitives import hashes
    6: from cryptography.hazmat.primitives.asymmetric import padding, rsa
    7: 
    8: from dns.dnssecalgs.cryptography import CryptographyPrivateKey, CryptographyPublicKey
    9: from dns.dnssectypes import Algorithm
   10: from dns.rdtypes.ANY.DNSKEY import DNSKEY
   11: 
   12: 
   13: class PublicRSA(CryptographyPublicKey):
   14:     key: rsa.RSAPublicKey
   15:     key_cls = rsa.RSAPublicKey
   16:     algorithm: Algorithm
   17:     chosen_hash: hashes.HashAlgorithm
   18: 
   19:     def verify(self, signature: bytes, data: bytes) -> None:
   20:         self.key.verify(signature, data, padding.PKCS1v15(), self.chosen_hash)
   21: 
   22:     def encode_key_bytes(self) -> bytes:
   23:         """Encode a public key per RFC 3110, section 2."""
   24:         pn = self.key.public_numbers()
   25:         _exp_len = math.ceil(int.bit_length(pn.e) / 8)
   26:         exp = int.to_bytes(pn.e, length=_exp_len, byteorder="big")
   27:         if _exp_len > 255:
   28:             exp_header = b"\0" + struct.pack("!H", _exp_len)
   29:         else:
   30:             exp_header = struct.pack("!B", _exp_len)
   31:         if pn.n.bit_length() < 512 or pn.n.bit_length() > 4096:
   32:             raise ValueError("unsupported RSA key length")
   33:         return exp_header + exp + pn.n.to_bytes((pn.n.bit_length() + 7) // 8, "big")
   34: 
   35:     @classmethod
   36:     def from_dnskey(cls, key: DNSKEY) -> "PublicRSA":
   37:         cls._ensure_algorithm_key_combination(key)
   38:         keyptr = key.key
   39:         (bytes_,) = struct.unpack("!B", keyptr[0:1])
   40:         keyptr = keyptr[1:]
   41:         if bytes_ == 0:
   42:             (bytes_,) = struct.unpack("!H", keyptr[0:2])
   43:             keyptr = keyptr[2:]
   44:         rsa_e = keyptr[0:bytes_]
   45:         rsa_n = keyptr[bytes_:]
   46:         return cls(
   47:             key=rsa.RSAPublicNumbers(
   48:                 int.from_bytes(rsa_e, "big"), int.from_bytes(rsa_n, "big")
   49:             ).public_key(default_backend())
   50:         )
   51: 
   52: 
   53: class PrivateRSA(CryptographyPrivateKey):
   54:     key: rsa.RSAPrivateKey
   55:     key_cls = rsa.RSAPrivateKey
   56:     public_cls = PublicRSA
   57:     default_public_exponent = 65537
   58: 
   59:     def sign(self, data: bytes, verify: bool = False) -> bytes:
   60:         """Sign using a private key per RFC 3110, section 3."""
   61:         signature = self.key.sign(data, padding.PKCS1v15(), self.public_cls.chosen_hash)
   62:         if verify:
   63:             self.public_key().verify(signature, data)
   64:         return signature
   65: 
   66:     @classmethod
   67:     def generate(cls, key_size: int) -> "PrivateRSA":
   68:         return cls(
   69:             key=rsa.generate_private_key(
   70:                 public_exponent=cls.default_public_exponent,
   71:                 key_size=key_size,
   72:                 backend=default_backend(),
   73:             )
   74:         )
   75: 
   76: 
   77: class PublicRSAMD5(PublicRSA):
   78:     algorithm = Algorithm.RSAMD5
   79:     chosen_hash = hashes.MD5()
   80: 
   81: 
   82: class PrivateRSAMD5(PrivateRSA):
   83:     public_cls = PublicRSAMD5
   84: 
   85: 
   86: class PublicRSASHA1(PublicRSA):
   87:     algorithm = Algorithm.RSASHA1
   88:     chosen_hash = hashes.SHA1()
   89: 
   90: 
   91: class PrivateRSASHA1(PrivateRSA):
   92:     public_cls = PublicRSASHA1
   93: 
   94: 
   95: class PublicRSASHA1NSEC3SHA1(PublicRSA):
   96:     algorithm = Algorithm.RSASHA1NSEC3SHA1
   97:     chosen_hash = hashes.SHA1()
   98: 
   99: 
  100: class PrivateRSASHA1NSEC3SHA1(PrivateRSA):
  101:     public_cls = PublicRSASHA1NSEC3SHA1
  102: 
  103: 
  104: class PublicRSASHA256(PublicRSA):
  105:     algorithm = Algorithm.RSASHA256
  106:     chosen_hash = hashes.SHA256()
  107: 
  108: 
  109: class PrivateRSASHA256(PrivateRSA):
  110:     public_cls = PublicRSASHA256
  111: 
  112: 
  113: class PublicRSASHA512(PublicRSA):
  114:     algorithm = Algorithm.RSASHA512
  115:     chosen_hash = hashes.SHA512()
  116: 
  117: 
  118: class PrivateRSASHA512(PrivateRSA):
  119:     public_cls = PublicRSASHA512
