    1: from cryptography.hazmat.backends import default_backend
    2: from cryptography.hazmat.primitives import hashes
    3: from cryptography.hazmat.primitives.asymmetric import ec, utils
    4: 
    5: from dns.dnssecalgs.cryptography import CryptographyPrivateKey, CryptographyPublicKey
    6: from dns.dnssectypes import Algorithm
    7: from dns.rdtypes.ANY.DNSKEY import DNSKEY
    8: 
    9: 
   10: class PublicECDSA(CryptographyPublicKey):
   11:     key: ec.EllipticCurvePublicKey
   12:     key_cls = ec.EllipticCurvePublicKey
   13:     algorithm: Algorithm
   14:     chosen_hash: hashes.HashAlgorithm
   15:     curve: ec.EllipticCurve
   16:     octets: int
   17: 
   18:     def verify(self, signature: bytes, data: bytes) -> None:
   19:         sig_r = signature[0 : self.octets]
   20:         sig_s = signature[self.octets :]
   21:         sig = utils.encode_dss_signature(
   22:             int.from_bytes(sig_r, "big"), int.from_bytes(sig_s, "big")
   23:         )
   24:         self.key.verify(sig, data, ec.ECDSA(self.chosen_hash))
   25: 
   26:     def encode_key_bytes(self) -> bytes:
   27:         """Encode a public key per RFC 6605, section 4."""
   28:         pn = self.key.public_numbers()
   29:         return pn.x.to_bytes(self.octets, "big") + pn.y.to_bytes(self.octets, "big")
   30: 
   31:     @classmethod
   32:     def from_dnskey(cls, key: DNSKEY) -> "PublicECDSA":
   33:         cls._ensure_algorithm_key_combination(key)
   34:         ecdsa_x = key.key[0 : cls.octets]
   35:         ecdsa_y = key.key[cls.octets : cls.octets * 2]
   36:         return cls(
   37:             key=ec.EllipticCurvePublicNumbers(
   38:                 curve=cls.curve,
   39:                 x=int.from_bytes(ecdsa_x, "big"),
   40:                 y=int.from_bytes(ecdsa_y, "big"),
   41:             ).public_key(default_backend()),
   42:         )
   43: 
   44: 
   45: class PrivateECDSA(CryptographyPrivateKey):
   46:     key: ec.EllipticCurvePrivateKey
   47:     key_cls = ec.EllipticCurvePrivateKey
   48:     public_cls = PublicECDSA
   49: 
   50:     def sign(self, data: bytes, verify: bool = False) -> bytes:
   51:         """Sign using a private key per RFC 6605, section 4."""
   52:         der_signature = self.key.sign(data, ec.ECDSA(self.public_cls.chosen_hash))
   53:         dsa_r, dsa_s = utils.decode_dss_signature(der_signature)
   54:         signature = int.to_bytes(
   55:             dsa_r, length=self.public_cls.octets, byteorder="big"
   56:         ) + int.to_bytes(dsa_s, length=self.public_cls.octets, byteorder="big")
   57:         if verify:
   58:             self.public_key().verify(signature, data)
   59:         return signature
   60: 
   61:     @classmethod
   62:     def generate(cls) -> "PrivateECDSA":
   63:         return cls(
   64:             key=ec.generate_private_key(
   65:                 curve=cls.public_cls.curve, backend=default_backend()
   66:             ),
   67:         )
   68: 
   69: 
   70: class PublicECDSAP256SHA256(PublicECDSA):
   71:     algorithm = Algorithm.ECDSAP256SHA256
   72:     chosen_hash = hashes.SHA256()
   73:     curve = ec.SECP256R1()
   74:     octets = 32
   75: 
   76: 
   77: class PrivateECDSAP256SHA256(PrivateECDSA):
   78:     public_cls = PublicECDSAP256SHA256
   79: 
   80: 
   81: class PublicECDSAP384SHA384(PublicECDSA):
   82:     algorithm = Algorithm.ECDSAP384SHA384
   83:     chosen_hash = hashes.SHA384()
   84:     curve = ec.SECP384R1()
   85:     octets = 48
   86: 
   87: 
   88: class PrivateECDSAP384SHA384(PrivateECDSA):
   89:     public_cls = PublicECDSAP384SHA384
