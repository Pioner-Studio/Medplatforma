    1: import struct
    2: 
    3: from cryptography.hazmat.backends import default_backend
    4: from cryptography.hazmat.primitives import hashes
    5: from cryptography.hazmat.primitives.asymmetric import dsa, utils
    6: 
    7: from dns.dnssecalgs.cryptography import CryptographyPrivateKey, CryptographyPublicKey
    8: from dns.dnssectypes import Algorithm
    9: from dns.rdtypes.ANY.DNSKEY import DNSKEY
   10: 
   11: 
   12: class PublicDSA(CryptographyPublicKey):
   13:     key: dsa.DSAPublicKey
   14:     key_cls = dsa.DSAPublicKey
   15:     algorithm = Algorithm.DSA
   16:     chosen_hash = hashes.SHA1()
   17: 
   18:     def verify(self, signature: bytes, data: bytes) -> None:
   19:         sig_r = signature[1:21]
   20:         sig_s = signature[21:]
   21:         sig = utils.encode_dss_signature(
   22:             int.from_bytes(sig_r, "big"), int.from_bytes(sig_s, "big")
   23:         )
   24:         self.key.verify(sig, data, self.chosen_hash)
   25: 
   26:     def encode_key_bytes(self) -> bytes:
   27:         """Encode a public key per RFC 2536, section 2."""
   28:         pn = self.key.public_numbers()
   29:         dsa_t = (self.key.key_size // 8 - 64) // 8
   30:         if dsa_t > 8:
   31:             raise ValueError("unsupported DSA key size")
   32:         octets = 64 + dsa_t * 8
   33:         res = struct.pack("!B", dsa_t)
   34:         res += pn.parameter_numbers.q.to_bytes(20, "big")
   35:         res += pn.parameter_numbers.p.to_bytes(octets, "big")
   36:         res += pn.parameter_numbers.g.to_bytes(octets, "big")
   37:         res += pn.y.to_bytes(octets, "big")
   38:         return res
   39: 
   40:     @classmethod
   41:     def from_dnskey(cls, key: DNSKEY) -> "PublicDSA":
   42:         cls._ensure_algorithm_key_combination(key)
   43:         keyptr = key.key
   44:         (t,) = struct.unpack("!B", keyptr[0:1])
   45:         keyptr = keyptr[1:]
   46:         octets = 64 + t * 8
   47:         dsa_q = keyptr[0:20]
   48:         keyptr = keyptr[20:]
   49:         dsa_p = keyptr[0:octets]
   50:         keyptr = keyptr[octets:]
   51:         dsa_g = keyptr[0:octets]
   52:         keyptr = keyptr[octets:]
   53:         dsa_y = keyptr[0:octets]
   54:         return cls(
   55:             key=dsa.DSAPublicNumbers(  # type: ignore
   56:                 int.from_bytes(dsa_y, "big"),
   57:                 dsa.DSAParameterNumbers(
   58:                     int.from_bytes(dsa_p, "big"),
   59:                     int.from_bytes(dsa_q, "big"),
   60:                     int.from_bytes(dsa_g, "big"),
   61:                 ),
   62:             ).public_key(default_backend()),
   63:         )
   64: 
   65: 
   66: class PrivateDSA(CryptographyPrivateKey):
   67:     key: dsa.DSAPrivateKey
   68:     key_cls = dsa.DSAPrivateKey
   69:     public_cls = PublicDSA
   70: 
   71:     def sign(self, data: bytes, verify: bool = False) -> bytes:
   72:         """Sign using a private key per RFC 2536, section 3."""
   73:         public_dsa_key = self.key.public_key()
   74:         if public_dsa_key.key_size > 1024:
   75:             raise ValueError("DSA key size overflow")
   76:         der_signature = self.key.sign(data, self.public_cls.chosen_hash)
   77:         dsa_r, dsa_s = utils.decode_dss_signature(der_signature)
   78:         dsa_t = (public_dsa_key.key_size // 8 - 64) // 8
   79:         octets = 20
   80:         signature = (
   81:             struct.pack("!B", dsa_t)
   82:             + int.to_bytes(dsa_r, length=octets, byteorder="big")
   83:             + int.to_bytes(dsa_s, length=octets, byteorder="big")
   84:         )
   85:         if verify:
   86:             self.public_key().verify(signature, data)
   87:         return signature
   88: 
   89:     @classmethod
   90:     def generate(cls, key_size: int) -> "PrivateDSA":
   91:         return cls(
   92:             key=dsa.generate_private_key(key_size=key_size),
   93:         )
   94: 
   95: 
   96: class PublicDSANSEC3SHA1(PublicDSA):
   97:     algorithm = Algorithm.DSANSEC3SHA1
   98: 
   99: 
  100: class PrivateDSANSEC3SHA1(PrivateDSA):
  101:     public_cls = PublicDSANSEC3SHA1
