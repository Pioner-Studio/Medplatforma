    1: from typing import Dict, Optional, Tuple, Type, Union
    2: 
    3: import dns.name
    4: from dns.dnssecalgs.base import GenericPrivateKey
    5: from dns.dnssectypes import Algorithm
    6: from dns.exception import UnsupportedAlgorithm
    7: from dns.rdtypes.ANY.DNSKEY import DNSKEY
    8: 
    9: if dns._features.have("dnssec"):
   10:     from dns.dnssecalgs.dsa import PrivateDSA, PrivateDSANSEC3SHA1
   11:     from dns.dnssecalgs.ecdsa import PrivateECDSAP256SHA256, PrivateECDSAP384SHA384
   12:     from dns.dnssecalgs.eddsa import PrivateED448, PrivateED25519
   13:     from dns.dnssecalgs.rsa import (
   14:         PrivateRSAMD5,
   15:         PrivateRSASHA1,
   16:         PrivateRSASHA1NSEC3SHA1,
   17:         PrivateRSASHA256,
   18:         PrivateRSASHA512,
   19:     )
   20: 
   21:     _have_cryptography = True
   22: else:
   23:     _have_cryptography = False
   24: 
   25: AlgorithmPrefix = Optional[Union[bytes, dns.name.Name]]
   26: 
   27: algorithms: Dict[Tuple[Algorithm, AlgorithmPrefix], Type[GenericPrivateKey]] = {}
   28: if _have_cryptography:
   29:     algorithms.update(
   30:         {
   31:             (Algorithm.RSAMD5, None): PrivateRSAMD5,
   32:             (Algorithm.DSA, None): PrivateDSA,
   33:             (Algorithm.RSASHA1, None): PrivateRSASHA1,
   34:             (Algorithm.DSANSEC3SHA1, None): PrivateDSANSEC3SHA1,
   35:             (Algorithm.RSASHA1NSEC3SHA1, None): PrivateRSASHA1NSEC3SHA1,
   36:             (Algorithm.RSASHA256, None): PrivateRSASHA256,
   37:             (Algorithm.RSASHA512, None): PrivateRSASHA512,
   38:             (Algorithm.ECDSAP256SHA256, None): PrivateECDSAP256SHA256,
   39:             (Algorithm.ECDSAP384SHA384, None): PrivateECDSAP384SHA384,
   40:             (Algorithm.ED25519, None): PrivateED25519,
   41:             (Algorithm.ED448, None): PrivateED448,
   42:         }
   43:     )
   44: 
   45: 
   46: def get_algorithm_cls(
   47:     algorithm: Union[int, str], prefix: AlgorithmPrefix = None
   48: ) -> Type[GenericPrivateKey]:
   49:     """Get Private Key class from Algorithm.
   50: 
   51:     *algorithm*, a ``str`` or ``int`` specifying the DNSKEY algorithm.
   52: 
   53:     Raises ``UnsupportedAlgorithm`` if the algorithm is unknown.
   54: 
   55:     Returns a ``dns.dnssecalgs.GenericPrivateKey``
   56:     """
   57:     algorithm = Algorithm.make(algorithm)
   58:     cls = algorithms.get((algorithm, prefix))
   59:     if cls:
   60:         return cls
   61:     raise UnsupportedAlgorithm(
   62:         'algorithm "%s" not supported by dnspython' % Algorithm.to_text(algorithm)
   63:     )
   64: 
   65: 
   66: def get_algorithm_cls_from_dnskey(dnskey: DNSKEY) -> Type[GenericPrivateKey]:
   67:     """Get Private Key class from DNSKEY.
   68: 
   69:     *dnskey*, a ``DNSKEY`` to get Algorithm class for.
   70: 
   71:     Raises ``UnsupportedAlgorithm`` if the algorithm is unknown.
   72: 
   73:     Returns a ``dns.dnssecalgs.GenericPrivateKey``
   74:     """
   75:     prefix: AlgorithmPrefix = None
   76:     if dnskey.algorithm == Algorithm.PRIVATEDNS:
   77:         prefix, _ = dns.name.from_wire(dnskey.key, 0)
   78:     elif dnskey.algorithm == Algorithm.PRIVATEOID:
   79:         length = int(dnskey.key[0])
   80:         prefix = dnskey.key[0 : length + 1]
   81:     return get_algorithm_cls(dnskey.algorithm, prefix)
   82: 
   83: 
   84: def register_algorithm_cls(
   85:     algorithm: Union[int, str],
   86:     algorithm_cls: Type[GenericPrivateKey],
   87:     name: Optional[Union[dns.name.Name, str]] = None,
   88:     oid: Optional[bytes] = None,
   89: ) -> None:
   90:     """Register Algorithm Private Key class.
   91: 
   92:     *algorithm*, a ``str`` or ``int`` specifying the DNSKEY algorithm.
   93: 
   94:     *algorithm_cls*: A `GenericPrivateKey` class.
   95: 
   96:     *name*, an optional ``dns.name.Name`` or ``str``, for for PRIVATEDNS algorithms.
   97: 
   98:     *oid*: an optional BER-encoded `bytes` for PRIVATEOID algorithms.
   99: 
  100:     Raises ``ValueError`` if a name or oid is specified incorrectly.
  101:     """
  102:     if not issubclass(algorithm_cls, GenericPrivateKey):
  103:         raise TypeError("Invalid algorithm class")
  104:     algorithm = Algorithm.make(algorithm)
  105:     prefix: AlgorithmPrefix = None
  106:     if algorithm == Algorithm.PRIVATEDNS:
  107:         if name is None:
  108:             raise ValueError("Name required for PRIVATEDNS algorithms")
  109:         if isinstance(name, str):
  110:             name = dns.name.from_text(name)
  111:         prefix = name
  112:     elif algorithm == Algorithm.PRIVATEOID:
  113:         if oid is None:
  114:             raise ValueError("OID required for PRIVATEOID algorithms")
  115:         prefix = bytes([len(oid)]) + oid
  116:     elif name:
  117:         raise ValueError("Name only supported for PRIVATEDNS algorithm")
  118:     elif oid:
  119:         raise ValueError("OID only supported for PRIVATEOID algorithm")
  120:     algorithms[(algorithm, prefix)] = algorithm_cls
