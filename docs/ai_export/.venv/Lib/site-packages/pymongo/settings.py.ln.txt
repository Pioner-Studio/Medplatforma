    1: # Copyright 2014-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Represent MongoClient's configuration."""
   16: from __future__ import annotations
   17: 
   18: import threading
   19: import traceback
   20: from typing import Any, Collection, Optional, Type, Union
   21: 
   22: from bson.objectid import ObjectId
   23: from pymongo import common, monitor, pool
   24: from pymongo.common import LOCAL_THRESHOLD_MS, SERVER_SELECTION_TIMEOUT
   25: from pymongo.errors import ConfigurationError
   26: from pymongo.pool import Pool, PoolOptions
   27: from pymongo.server_description import ServerDescription
   28: from pymongo.topology_description import TOPOLOGY_TYPE, _ServerSelector
   29: 
   30: 
   31: class TopologySettings:
   32:     def __init__(
   33:         self,
   34:         seeds: Optional[Collection[tuple[str, int]]] = None,
   35:         replica_set_name: Optional[str] = None,
   36:         pool_class: Optional[Type[Pool]] = None,
   37:         pool_options: Optional[PoolOptions] = None,
   38:         monitor_class: Optional[Type[monitor.Monitor]] = None,
   39:         condition_class: Optional[Type[threading.Condition]] = None,
   40:         local_threshold_ms: int = LOCAL_THRESHOLD_MS,
   41:         server_selection_timeout: int = SERVER_SELECTION_TIMEOUT,
   42:         heartbeat_frequency: int = common.HEARTBEAT_FREQUENCY,
   43:         server_selector: Optional[_ServerSelector] = None,
   44:         fqdn: Optional[str] = None,
   45:         direct_connection: Optional[bool] = False,
   46:         load_balanced: Optional[bool] = None,
   47:         srv_service_name: str = common.SRV_SERVICE_NAME,
   48:         srv_max_hosts: int = 0,
   49:         server_monitoring_mode: str = common.SERVER_MONITORING_MODE,
   50:     ):
   51:         """Represent MongoClient's configuration.
   52: 
   53:         Take a list of (host, port) pairs and optional replica set name.
   54:         """
   55:         if heartbeat_frequency < common.MIN_HEARTBEAT_INTERVAL:
   56:             raise ConfigurationError(
   57:                 "heartbeatFrequencyMS cannot be less than %d"
   58:                 % (common.MIN_HEARTBEAT_INTERVAL * 1000,)
   59:             )
   60: 
   61:         self._seeds: Collection[tuple[str, int]] = seeds or [("localhost", 27017)]
   62:         self._replica_set_name = replica_set_name
   63:         self._pool_class: Type[Pool] = pool_class or pool.Pool
   64:         self._pool_options: PoolOptions = pool_options or PoolOptions()
   65:         self._monitor_class: Type[monitor.Monitor] = monitor_class or monitor.Monitor
   66:         self._condition_class: Type[threading.Condition] = condition_class or threading.Condition
   67:         self._local_threshold_ms = local_threshold_ms
   68:         self._server_selection_timeout = server_selection_timeout
   69:         self._server_selector = server_selector
   70:         self._fqdn = fqdn
   71:         self._heartbeat_frequency = heartbeat_frequency
   72:         self._direct = direct_connection
   73:         self._load_balanced = load_balanced
   74:         self._srv_service_name = srv_service_name
   75:         self._srv_max_hosts = srv_max_hosts or 0
   76:         self._server_monitoring_mode = server_monitoring_mode
   77: 
   78:         self._topology_id = ObjectId()
   79:         # Store the allocation traceback to catch unclosed clients in the
   80:         # test suite.
   81:         self._stack = "".join(traceback.format_stack())
   82: 
   83:     @property
   84:     def seeds(self) -> Collection[tuple[str, int]]:
   85:         """List of server addresses."""
   86:         return self._seeds
   87: 
   88:     @property
   89:     def replica_set_name(self) -> Optional[str]:
   90:         return self._replica_set_name
   91: 
   92:     @property
   93:     def pool_class(self) -> Type[Pool]:
   94:         return self._pool_class
   95: 
   96:     @property
   97:     def pool_options(self) -> PoolOptions:
   98:         return self._pool_options
   99: 
  100:     @property
  101:     def monitor_class(self) -> Type[monitor.Monitor]:
  102:         return self._monitor_class
  103: 
  104:     @property
  105:     def condition_class(self) -> Type[threading.Condition]:
  106:         return self._condition_class
  107: 
  108:     @property
  109:     def local_threshold_ms(self) -> int:
  110:         return self._local_threshold_ms
  111: 
  112:     @property
  113:     def server_selection_timeout(self) -> int:
  114:         return self._server_selection_timeout
  115: 
  116:     @property
  117:     def server_selector(self) -> Optional[_ServerSelector]:
  118:         return self._server_selector
  119: 
  120:     @property
  121:     def heartbeat_frequency(self) -> int:
  122:         return self._heartbeat_frequency
  123: 
  124:     @property
  125:     def fqdn(self) -> Optional[str]:
  126:         return self._fqdn
  127: 
  128:     @property
  129:     def direct(self) -> Optional[bool]:
  130:         """Connect directly to a single server, or use a set of servers?
  131: 
  132:         True if there is one seed and no replica_set_name.
  133:         """
  134:         return self._direct
  135: 
  136:     @property
  137:     def load_balanced(self) -> Optional[bool]:
  138:         """True if the client was configured to connect to a load balancer."""
  139:         return self._load_balanced
  140: 
  141:     @property
  142:     def srv_service_name(self) -> str:
  143:         """The srvServiceName."""
  144:         return self._srv_service_name
  145: 
  146:     @property
  147:     def srv_max_hosts(self) -> int:
  148:         """The srvMaxHosts."""
  149:         return self._srv_max_hosts
  150: 
  151:     @property
  152:     def server_monitoring_mode(self) -> str:
  153:         """The serverMonitoringMode."""
  154:         return self._server_monitoring_mode
  155: 
  156:     def get_topology_type(self) -> int:
  157:         if self.load_balanced:
  158:             return TOPOLOGY_TYPE.LoadBalanced
  159:         elif self.direct:
  160:             return TOPOLOGY_TYPE.Single
  161:         elif self.replica_set_name is not None:
  162:             return TOPOLOGY_TYPE.ReplicaSetNoPrimary
  163:         else:
  164:             return TOPOLOGY_TYPE.Unknown
  165: 
  166:     def get_server_descriptions(self) -> dict[Union[tuple[str, int], Any], ServerDescription]:
  167:         """Initial dict of (address, ServerDescription) for all seeds."""
  168:         return {address: ServerDescription(address) for address in self.seeds}
