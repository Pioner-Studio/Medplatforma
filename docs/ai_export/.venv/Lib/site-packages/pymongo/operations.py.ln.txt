    1: # Copyright 2015-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Operation class definitions."""
   16: from __future__ import annotations
   17: 
   18: import enum
   19: from typing import (
   20:     TYPE_CHECKING,
   21:     Any,
   22:     Generic,
   23:     Mapping,
   24:     Optional,
   25:     Sequence,
   26:     Tuple,
   27:     Union,
   28: )
   29: 
   30: from bson.raw_bson import RawBSONDocument
   31: from pymongo import helpers
   32: from pymongo.collation import validate_collation_or_none
   33: from pymongo.common import validate_is_mapping, validate_list
   34: from pymongo.helpers import _gen_index_name, _index_document, _index_list
   35: from pymongo.typings import _CollationIn, _DocumentType, _Pipeline
   36: from pymongo.write_concern import validate_boolean
   37: 
   38: if TYPE_CHECKING:
   39:     from pymongo.bulk import _Bulk
   40: 
   41: # Hint supports index name, "myIndex", a list of either strings or index pairs: [('x', 1), ('y', -1), 'z''], or a dictionary
   42: _IndexList = Union[
   43:     Sequence[Union[str, Tuple[str, Union[int, str, Mapping[str, Any]]]]], Mapping[str, Any]
   44: ]
   45: _IndexKeyHint = Union[str, _IndexList]
   46: 
   47: 
   48: class _Op(str, enum.Enum):
   49:     ABORT = "abortTransaction"
   50:     AGGREGATE = "aggregate"
   51:     COMMIT = "commitTransaction"
   52:     COUNT = "count"
   53:     CREATE = "create"
   54:     CREATE_INDEXES = "createIndexes"
   55:     CREATE_SEARCH_INDEXES = "createSearchIndexes"
   56:     DELETE = "delete"
   57:     DISTINCT = "distinct"
   58:     DROP = "drop"
   59:     DROP_DATABASE = "dropDatabase"
   60:     DROP_INDEXES = "dropIndexes"
   61:     DROP_SEARCH_INDEXES = "dropSearchIndexes"
   62:     END_SESSIONS = "endSessions"
   63:     FIND_AND_MODIFY = "findAndModify"
   64:     FIND = "find"
   65:     INSERT = "insert"
   66:     LIST_COLLECTIONS = "listCollections"
   67:     LIST_INDEXES = "listIndexes"
   68:     LIST_SEARCH_INDEX = "listSearchIndexes"
   69:     LIST_DATABASES = "listDatabases"
   70:     UPDATE = "update"
   71:     UPDATE_INDEX = "updateIndex"
   72:     UPDATE_SEARCH_INDEX = "updateSearchIndex"
   73:     RENAME = "rename"
   74:     GETMORE = "getMore"
   75:     KILL_CURSORS = "killCursors"
   76:     TEST = "testOperation"
   77: 
   78: 
   79: class InsertOne(Generic[_DocumentType]):
   80:     """Represents an insert_one operation."""
   81: 
   82:     __slots__ = ("_doc",)
   83: 
   84:     def __init__(self, document: _DocumentType) -> None:
   85:         """Create an InsertOne instance.
   86: 
   87:         For use with :meth:`~pymongo.collection.Collection.bulk_write`.
   88: 
   89:         :param document: The document to insert. If the document is missing an
   90:             _id field one will be added.
   91:         """
   92:         self._doc = document
   93: 
   94:     def _add_to_bulk(self, bulkobj: _Bulk) -> None:
   95:         """Add this operation to the _Bulk instance `bulkobj`."""
   96:         bulkobj.add_insert(self._doc)  # type: ignore[arg-type]
   97: 
   98:     def __repr__(self) -> str:
   99:         return f"InsertOne({self._doc!r})"
  100: 
  101:     def __eq__(self, other: Any) -> bool:
  102:         if type(other) == type(self):
  103:             return other._doc == self._doc
  104:         return NotImplemented
  105: 
  106:     def __ne__(self, other: Any) -> bool:
  107:         return not self == other
  108: 
  109: 
  110: class DeleteOne:
  111:     """Represents a delete_one operation."""
  112: 
  113:     __slots__ = ("_filter", "_collation", "_hint")
  114: 
  115:     def __init__(
  116:         self,
  117:         filter: Mapping[str, Any],
  118:         collation: Optional[_CollationIn] = None,
  119:         hint: Optional[_IndexKeyHint] = None,
  120:     ) -> None:
  121:         """Create a DeleteOne instance.
  122: 
  123:         For use with :meth:`~pymongo.collection.Collection.bulk_write`.
  124: 
  125:         :param filter: A query that matches the document to delete.
  126:         :param collation: An instance of
  127:             :class:`~pymongo.collation.Collation`.
  128:         :param hint: An index to use to support the query
  129:             predicate specified either by its string name, or in the same
  130:             format as passed to
  131:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
  132:             ``[('field', ASCENDING)]``). This option is only supported on
  133:             MongoDB 4.4 and above.
  134: 
  135:         .. versionchanged:: 3.11
  136:            Added the ``hint`` option.
  137:         .. versionchanged:: 3.5
  138:            Added the `collation` option.
  139:         """
  140:         if filter is not None:
  141:             validate_is_mapping("filter", filter)
  142:         if hint is not None and not isinstance(hint, str):
  143:             self._hint: Union[str, dict[str, Any], None] = helpers._index_document(hint)
  144:         else:
  145:             self._hint = hint
  146:         self._filter = filter
  147:         self._collation = collation
  148: 
  149:     def _add_to_bulk(self, bulkobj: _Bulk) -> None:
  150:         """Add this operation to the _Bulk instance `bulkobj`."""
  151:         bulkobj.add_delete(
  152:             self._filter,
  153:             1,
  154:             collation=validate_collation_or_none(self._collation),
  155:             hint=self._hint,
  156:         )
  157: 
  158:     def __repr__(self) -> str:
  159:         return f"DeleteOne({self._filter!r}, {self._collation!r}, {self._hint!r})"
  160: 
  161:     def __eq__(self, other: Any) -> bool:
  162:         if type(other) == type(self):
  163:             return (other._filter, other._collation, other._hint) == (
  164:                 self._filter,
  165:                 self._collation,
  166:                 self._hint,
  167:             )
  168:         return NotImplemented
  169: 
  170:     def __ne__(self, other: Any) -> bool:
  171:         return not self == other
  172: 
  173: 
  174: class DeleteMany:
  175:     """Represents a delete_many operation."""
  176: 
  177:     __slots__ = ("_filter", "_collation", "_hint")
  178: 
  179:     def __init__(
  180:         self,
  181:         filter: Mapping[str, Any],
  182:         collation: Optional[_CollationIn] = None,
  183:         hint: Optional[_IndexKeyHint] = None,
  184:     ) -> None:
  185:         """Create a DeleteMany instance.
  186: 
  187:         For use with :meth:`~pymongo.collection.Collection.bulk_write`.
  188: 
  189:         :param filter: A query that matches the documents to delete.
  190:         :param collation: An instance of
  191:             :class:`~pymongo.collation.Collation`.
  192:         :param hint: An index to use to support the query
  193:             predicate specified either by its string name, or in the same
  194:             format as passed to
  195:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
  196:             ``[('field', ASCENDING)]``). This option is only supported on
  197:             MongoDB 4.4 and above.
  198: 
  199:         .. versionchanged:: 3.11
  200:            Added the ``hint`` option.
  201:         .. versionchanged:: 3.5
  202:            Added the `collation` option.
  203:         """
  204:         if filter is not None:
  205:             validate_is_mapping("filter", filter)
  206:         if hint is not None and not isinstance(hint, str):
  207:             self._hint: Union[str, dict[str, Any], None] = helpers._index_document(hint)
  208:         else:
  209:             self._hint = hint
  210:         self._filter = filter
  211:         self._collation = collation
  212: 
  213:     def _add_to_bulk(self, bulkobj: _Bulk) -> None:
  214:         """Add this operation to the _Bulk instance `bulkobj`."""
  215:         bulkobj.add_delete(
  216:             self._filter,
  217:             0,
  218:             collation=validate_collation_or_none(self._collation),
  219:             hint=self._hint,
  220:         )
  221: 
  222:     def __repr__(self) -> str:
  223:         return f"DeleteMany({self._filter!r}, {self._collation!r}, {self._hint!r})"
  224: 
  225:     def __eq__(self, other: Any) -> bool:
  226:         if type(other) == type(self):
  227:             return (other._filter, other._collation, other._hint) == (
  228:                 self._filter,
  229:                 self._collation,
  230:                 self._hint,
  231:             )
  232:         return NotImplemented
  233: 
  234:     def __ne__(self, other: Any) -> bool:
  235:         return not self == other
  236: 
  237: 
  238: class ReplaceOne(Generic[_DocumentType]):
  239:     """Represents a replace_one operation."""
  240: 
  241:     __slots__ = ("_filter", "_doc", "_upsert", "_collation", "_hint")
  242: 
  243:     def __init__(
  244:         self,
  245:         filter: Mapping[str, Any],
  246:         replacement: Union[_DocumentType, RawBSONDocument],
  247:         upsert: bool = False,
  248:         collation: Optional[_CollationIn] = None,
  249:         hint: Optional[_IndexKeyHint] = None,
  250:     ) -> None:
  251:         """Create a ReplaceOne instance.
  252: 
  253:         For use with :meth:`~pymongo.collection.Collection.bulk_write`.
  254: 
  255:         :param filter: A query that matches the document to replace.
  256:         :param replacement: The new document.
  257:         :param upsert: If ``True``, perform an insert if no documents
  258:             match the filter.
  259:         :param collation: An instance of
  260:             :class:`~pymongo.collation.Collation`.
  261:         :param hint: An index to use to support the query
  262:             predicate specified either by its string name, or in the same
  263:             format as passed to
  264:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
  265:             ``[('field', ASCENDING)]``). This option is only supported on
  266:             MongoDB 4.2 and above.
  267: 
  268:         .. versionchanged:: 3.11
  269:            Added the ``hint`` option.
  270:         .. versionchanged:: 3.5
  271:            Added the ``collation`` option.
  272:         """
  273:         if filter is not None:
  274:             validate_is_mapping("filter", filter)
  275:         if upsert is not None:
  276:             validate_boolean("upsert", upsert)
  277:         if hint is not None and not isinstance(hint, str):
  278:             self._hint: Union[str, dict[str, Any], None] = helpers._index_document(hint)
  279:         else:
  280:             self._hint = hint
  281:         self._filter = filter
  282:         self._doc = replacement
  283:         self._upsert = upsert
  284:         self._collation = collation
  285: 
  286:     def _add_to_bulk(self, bulkobj: _Bulk) -> None:
  287:         """Add this operation to the _Bulk instance `bulkobj`."""
  288:         bulkobj.add_replace(
  289:             self._filter,
  290:             self._doc,
  291:             self._upsert,
  292:             collation=validate_collation_or_none(self._collation),
  293:             hint=self._hint,
  294:         )
  295: 
  296:     def __eq__(self, other: Any) -> bool:
  297:         if type(other) == type(self):
  298:             return (
  299:                 other._filter,
  300:                 other._doc,
  301:                 other._upsert,
  302:                 other._collation,
  303:                 other._hint,
  304:             ) == (
  305:                 self._filter,
  306:                 self._doc,
  307:                 self._upsert,
  308:                 self._collation,
  309:                 other._hint,
  310:             )
  311:         return NotImplemented
  312: 
  313:     def __ne__(self, other: Any) -> bool:
  314:         return not self == other
  315: 
  316:     def __repr__(self) -> str:
  317:         return "{}({!r}, {!r}, {!r}, {!r}, {!r})".format(
  318:             self.__class__.__name__,
  319:             self._filter,
  320:             self._doc,
  321:             self._upsert,
  322:             self._collation,
  323:             self._hint,
  324:         )
  325: 
  326: 
  327: class _UpdateOp:
  328:     """Private base class for update operations."""
  329: 
  330:     __slots__ = ("_filter", "_doc", "_upsert", "_collation", "_array_filters", "_hint")
  331: 
  332:     def __init__(
  333:         self,
  334:         filter: Mapping[str, Any],
  335:         doc: Union[Mapping[str, Any], _Pipeline],
  336:         upsert: bool,
  337:         collation: Optional[_CollationIn],
  338:         array_filters: Optional[list[Mapping[str, Any]]],
  339:         hint: Optional[_IndexKeyHint],
  340:     ):
  341:         if filter is not None:
  342:             validate_is_mapping("filter", filter)
  343:         if upsert is not None:
  344:             validate_boolean("upsert", upsert)
  345:         if array_filters is not None:
  346:             validate_list("array_filters", array_filters)
  347:         if hint is not None and not isinstance(hint, str):
  348:             self._hint: Union[str, dict[str, Any], None] = helpers._index_document(hint)
  349:         else:
  350:             self._hint = hint
  351: 
  352:         self._filter = filter
  353:         self._doc = doc
  354:         self._upsert = upsert
  355:         self._collation = collation
  356:         self._array_filters = array_filters
  357: 
  358:     def __eq__(self, other: object) -> bool:
  359:         if isinstance(other, type(self)):
  360:             return (
  361:                 other._filter,
  362:                 other._doc,
  363:                 other._upsert,
  364:                 other._collation,
  365:                 other._array_filters,
  366:                 other._hint,
  367:             ) == (
  368:                 self._filter,
  369:                 self._doc,
  370:                 self._upsert,
  371:                 self._collation,
  372:                 self._array_filters,
  373:                 self._hint,
  374:             )
  375:         return NotImplemented
  376: 
  377:     def __repr__(self) -> str:
  378:         return "{}({!r}, {!r}, {!r}, {!r}, {!r}, {!r})".format(
  379:             self.__class__.__name__,
  380:             self._filter,
  381:             self._doc,
  382:             self._upsert,
  383:             self._collation,
  384:             self._array_filters,
  385:             self._hint,
  386:         )
  387: 
  388: 
  389: class UpdateOne(_UpdateOp):
  390:     """Represents an update_one operation."""
  391: 
  392:     __slots__ = ()
  393: 
  394:     def __init__(
  395:         self,
  396:         filter: Mapping[str, Any],
  397:         update: Union[Mapping[str, Any], _Pipeline],
  398:         upsert: bool = False,
  399:         collation: Optional[_CollationIn] = None,
  400:         array_filters: Optional[list[Mapping[str, Any]]] = None,
  401:         hint: Optional[_IndexKeyHint] = None,
  402:     ) -> None:
  403:         """Represents an update_one operation.
  404: 
  405:         For use with :meth:`~pymongo.collection.Collection.bulk_write`.
  406: 
  407:         :param filter: A query that matches the document to update.
  408:         :param update: The modifications to apply.
  409:         :param upsert: If ``True``, perform an insert if no documents
  410:             match the filter.
  411:         :param collation: An instance of
  412:             :class:`~pymongo.collation.Collation`.
  413:         :param array_filters: A list of filters specifying which
  414:             array elements an update should apply.
  415:         :param hint: An index to use to support the query
  416:             predicate specified either by its string name, or in the same
  417:             format as passed to
  418:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
  419:             ``[('field', ASCENDING)]``). This option is only supported on
  420:             MongoDB 4.2 and above.
  421: 
  422:         .. versionchanged:: 3.11
  423:            Added the `hint` option.
  424:         .. versionchanged:: 3.9
  425:            Added the ability to accept a pipeline as the `update`.
  426:         .. versionchanged:: 3.6
  427:            Added the `array_filters` option.
  428:         .. versionchanged:: 3.5
  429:            Added the `collation` option.
  430:         """
  431:         super().__init__(filter, update, upsert, collation, array_filters, hint)
  432: 
  433:     def _add_to_bulk(self, bulkobj: _Bulk) -> None:
  434:         """Add this operation to the _Bulk instance `bulkobj`."""
  435:         bulkobj.add_update(
  436:             self._filter,
  437:             self._doc,
  438:             False,
  439:             self._upsert,
  440:             collation=validate_collation_or_none(self._collation),
  441:             array_filters=self._array_filters,
  442:             hint=self._hint,
  443:         )
  444: 
  445: 
  446: class UpdateMany(_UpdateOp):
  447:     """Represents an update_many operation."""
  448: 
  449:     __slots__ = ()
  450: 
  451:     def __init__(
  452:         self,
  453:         filter: Mapping[str, Any],
  454:         update: Union[Mapping[str, Any], _Pipeline],
  455:         upsert: bool = False,
  456:         collation: Optional[_CollationIn] = None,
  457:         array_filters: Optional[list[Mapping[str, Any]]] = None,
  458:         hint: Optional[_IndexKeyHint] = None,
  459:     ) -> None:
  460:         """Create an UpdateMany instance.
  461: 
  462:         For use with :meth:`~pymongo.collection.Collection.bulk_write`.
  463: 
  464:         :param filter: A query that matches the documents to update.
  465:         :param update: The modifications to apply.
  466:         :param upsert: If ``True``, perform an insert if no documents
  467:             match the filter.
  468:         :param collation: An instance of
  469:             :class:`~pymongo.collation.Collation`.
  470:         :param array_filters: A list of filters specifying which
  471:             array elements an update should apply.
  472:         :param hint: An index to use to support the query
  473:             predicate specified either by its string name, or in the same
  474:             format as passed to
  475:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
  476:             ``[('field', ASCENDING)]``). This option is only supported on
  477:             MongoDB 4.2 and above.
  478: 
  479:         .. versionchanged:: 3.11
  480:            Added the `hint` option.
  481:         .. versionchanged:: 3.9
  482:            Added the ability to accept a pipeline as the `update`.
  483:         .. versionchanged:: 3.6
  484:            Added the `array_filters` option.
  485:         .. versionchanged:: 3.5
  486:            Added the `collation` option.
  487:         """
  488:         super().__init__(filter, update, upsert, collation, array_filters, hint)
  489: 
  490:     def _add_to_bulk(self, bulkobj: _Bulk) -> None:
  491:         """Add this operation to the _Bulk instance `bulkobj`."""
  492:         bulkobj.add_update(
  493:             self._filter,
  494:             self._doc,
  495:             True,
  496:             self._upsert,
  497:             collation=validate_collation_or_none(self._collation),
  498:             array_filters=self._array_filters,
  499:             hint=self._hint,
  500:         )
  501: 
  502: 
  503: class IndexModel:
  504:     """Represents an index to create."""
  505: 
  506:     __slots__ = ("__document",)
  507: 
  508:     def __init__(self, keys: _IndexKeyHint, **kwargs: Any) -> None:
  509:         """Create an Index instance.
  510: 
  511:         For use with :meth:`~pymongo.collection.Collection.create_indexes`.
  512: 
  513:         Takes either a single key or a list containing (key, direction) pairs
  514:         or keys.  If no direction is given, :data:`~pymongo.ASCENDING` will
  515:         be assumed.
  516:         The key(s) must be an instance of :class:`str`, and the direction(s) must
  517:         be one of (:data:`~pymongo.ASCENDING`, :data:`~pymongo.DESCENDING`,
  518:         :data:`~pymongo.GEO2D`, :data:`~pymongo.GEOSPHERE`,
  519:         :data:`~pymongo.HASHED`, :data:`~pymongo.TEXT`).
  520: 
  521:         Valid options include, but are not limited to:
  522: 
  523:           - `name`: custom name to use for this index - if none is
  524:             given, a name will be generated.
  525:           - `unique`: if ``True``, creates a uniqueness constraint on the index.
  526:           - `background`: if ``True``, this index should be created in the
  527:             background.
  528:           - `sparse`: if ``True``, omit from the index any documents that lack
  529:             the indexed field.
  530:           - `bucketSize`: for use with geoHaystack indexes.
  531:             Number of documents to group together within a certain proximity
  532:             to a given longitude and latitude.
  533:           - `min`: minimum value for keys in a :data:`~pymongo.GEO2D`
  534:             index.
  535:           - `max`: maximum value for keys in a :data:`~pymongo.GEO2D`
  536:             index.
  537:           - `expireAfterSeconds`: <int> Used to create an expiring (TTL)
  538:             collection. MongoDB will automatically delete documents from
  539:             this collection after <int> seconds. The indexed field must
  540:             be a UTC datetime or the data will not expire.
  541:           - `partialFilterExpression`: A document that specifies a filter for
  542:             a partial index.
  543:           - `collation`: An instance of :class:`~pymongo.collation.Collation`
  544:             that specifies the collation to use.
  545:           - `wildcardProjection`: Allows users to include or exclude specific
  546:             field paths from a `wildcard index`_ using the { "$**" : 1} key
  547:             pattern. Requires MongoDB >= 4.2.
  548:           - `hidden`: if ``True``, this index will be hidden from the query
  549:             planner and will not be evaluated as part of query plan
  550:             selection. Requires MongoDB >= 4.4.
  551: 
  552:         See the MongoDB documentation for a full list of supported options by
  553:         server version.
  554: 
  555:         :param keys: a single key or a list containing (key, direction) pairs
  556:              or keys specifying the index to create.
  557:         :param kwargs: any additional index creation
  558:             options (see the above list) should be passed as keyword
  559:             arguments.
  560: 
  561:         .. versionchanged:: 3.11
  562:            Added the ``hidden`` option.
  563:         .. versionchanged:: 3.2
  564:            Added the ``partialFilterExpression`` option to support partial
  565:            indexes.
  566: 
  567:         .. _wildcard index: https://mongodb.com/docs/master/core/index-wildcard/
  568:         """
  569:         keys = _index_list(keys)
  570:         if kwargs.get("name") is None:
  571:             kwargs["name"] = _gen_index_name(keys)
  572:         kwargs["key"] = _index_document(keys)
  573:         collation = validate_collation_or_none(kwargs.pop("collation", None))
  574:         self.__document = kwargs
  575:         if collation is not None:
  576:             self.__document["collation"] = collation
  577: 
  578:     @property
  579:     def document(self) -> dict[str, Any]:
  580:         """An index document suitable for passing to the createIndexes
  581:         command.
  582:         """
  583:         return self.__document
  584: 
  585: 
  586: class SearchIndexModel:
  587:     """Represents a search index to create."""
  588: 
  589:     __slots__ = ("__document",)
  590: 
  591:     def __init__(
  592:         self,
  593:         definition: Mapping[str, Any],
  594:         name: Optional[str] = None,
  595:         type: Optional[str] = None,
  596:         **kwargs: Any,
  597:     ) -> None:
  598:         """Create a Search Index instance.
  599: 
  600:         For use with :meth:`~pymongo.collection.Collection.create_search_index` and :meth:`~pymongo.collection.Collection.create_search_indexes`.
  601: 
  602:         :param definition: The definition for this index.
  603:         :param name: The name for this index, if present.
  604:         :param type: The type for this index which defaults to "search". Alternative values include "vectorSearch".
  605:         :param kwargs: Keyword arguments supplying any additional options.
  606: 
  607:         .. note:: Search indexes require a MongoDB server version 7.0+ Atlas cluster.
  608:         .. versionadded:: 4.5
  609:         .. versionchanged:: 4.7
  610:            Added the type and kwargs arguments.
  611:         """
  612:         self.__document: dict[str, Any] = {}
  613:         if name is not None:
  614:             self.__document["name"] = name
  615:         self.__document["definition"] = definition
  616:         if type is not None:
  617:             self.__document["type"] = type
  618:         self.__document.update(kwargs)
  619: 
  620:     @property
  621:     def document(self) -> Mapping[str, Any]:
  622:         """The document for this index."""
  623:         return self.__document
