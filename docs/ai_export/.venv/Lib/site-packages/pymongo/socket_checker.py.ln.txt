    1: # Copyright 2020-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Select / poll helper"""
   16: from __future__ import annotations
   17: 
   18: import errno
   19: import select
   20: import sys
   21: from typing import Any, Optional, cast
   22: 
   23: # PYTHON-2320: Jython does not fully support poll on SSL sockets,
   24: # https://bugs.jython.org/issue2900
   25: _HAVE_POLL = hasattr(select, "poll") and not sys.platform.startswith("java")
   26: _SelectError = getattr(select, "error", OSError)
   27: 
   28: 
   29: def _errno_from_exception(exc: BaseException) -> Optional[int]:
   30:     if hasattr(exc, "errno"):
   31:         return cast(int, exc.errno)
   32:     if exc.args:
   33:         return cast(int, exc.args[0])
   34:     return None
   35: 
   36: 
   37: class SocketChecker:
   38:     def __init__(self) -> None:
   39:         self._poller: Optional[select.poll]
   40:         if _HAVE_POLL:
   41:             self._poller = select.poll()
   42:         else:
   43:             self._poller = None
   44: 
   45:     def select(
   46:         self, sock: Any, read: bool = False, write: bool = False, timeout: Optional[float] = 0
   47:     ) -> bool:
   48:         """Select for reads or writes with a timeout in seconds (or None).
   49: 
   50:         Returns True if the socket is readable/writable, False on timeout.
   51:         """
   52:         res: Any
   53:         while True:
   54:             try:
   55:                 if self._poller:
   56:                     mask = select.POLLERR | select.POLLHUP
   57:                     if read:
   58:                         mask = mask | select.POLLIN | select.POLLPRI
   59:                     if write:
   60:                         mask = mask | select.POLLOUT
   61:                     self._poller.register(sock, mask)
   62:                     try:
   63:                         # poll() timeout is in milliseconds. select()
   64:                         # timeout is in seconds.
   65:                         timeout_ = None if timeout is None else timeout * 1000
   66:                         res = self._poller.poll(timeout_)
   67:                         # poll returns a possibly-empty list containing
   68:                         # (fd, event) 2-tuples for the descriptors that have
   69:                         # events or errors to report. Return True if the list
   70:                         # is not empty.
   71:                         return bool(res)
   72:                     finally:
   73:                         self._poller.unregister(sock)
   74:                 else:
   75:                     rlist = [sock] if read else []
   76:                     wlist = [sock] if write else []
   77:                     res = select.select(rlist, wlist, [sock], timeout)
   78:                     # select returns a 3-tuple of lists of objects that are
   79:                     # ready: subsets of the first three arguments. Return
   80:                     # True if any of the lists are not empty.
   81:                     return any(res)
   82:             except (_SelectError, OSError) as exc:  # type: ignore
   83:                 if _errno_from_exception(exc) in (errno.EINTR, errno.EAGAIN):
   84:                     continue
   85:                 raise
   86: 
   87:     def socket_closed(self, sock: Any) -> bool:
   88:         """Return True if we know socket has been closed, False otherwise."""
   89:         try:
   90:             return self.select(sock, read=True)
   91:         except (RuntimeError, KeyError):
   92:             # RuntimeError is raised during a concurrent poll. KeyError
   93:             # is raised by unregister if the socket is not in the poller.
   94:             # These errors should not be possible since we protect the
   95:             # poller with a mutex.
   96:             raise
   97:         except ValueError:
   98:             # ValueError is raised by register/unregister/select if the
   99:             # socket file descriptor is negative or outside the range for
  100:             # select (> 1023).
  101:             return True
  102:         except Exception:
  103:             # Any other exceptions should be attributed to a closed
  104:             # or invalid socket.
  105:             return True
