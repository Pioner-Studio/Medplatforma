    1: # Copyright 2009-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Bits and pieces used by the driver that don't really fit elsewhere."""
   16: from __future__ import annotations
   17: 
   18: import sys
   19: import traceback
   20: from collections import abc
   21: from typing import (
   22:     TYPE_CHECKING,
   23:     Any,
   24:     Callable,
   25:     Container,
   26:     Iterable,
   27:     Mapping,
   28:     NoReturn,
   29:     Optional,
   30:     Sequence,
   31:     TypeVar,
   32:     Union,
   33:     cast,
   34: )
   35: 
   36: from pymongo import ASCENDING
   37: from pymongo.errors import (
   38:     CursorNotFound,
   39:     DuplicateKeyError,
   40:     ExecutionTimeout,
   41:     NotPrimaryError,
   42:     OperationFailure,
   43:     WriteConcernError,
   44:     WriteError,
   45:     WTimeoutError,
   46:     _wtimeout_error,
   47: )
   48: from pymongo.hello import HelloCompat
   49: 
   50: if TYPE_CHECKING:
   51:     from pymongo.cursor import _Hint
   52:     from pymongo.operations import _IndexList
   53:     from pymongo.typings import _DocumentOut
   54: 
   55: # From the SDAM spec, the "node is shutting down" codes.
   56: _SHUTDOWN_CODES: frozenset = frozenset(
   57:     [
   58:         11600,  # InterruptedAtShutdown
   59:         91,  # ShutdownInProgress
   60:     ]
   61: )
   62: # From the SDAM spec, the "not primary" error codes are combined with the
   63: # "node is recovering" error codes (of which the "node is shutting down"
   64: # errors are a subset).
   65: _NOT_PRIMARY_CODES: frozenset = (
   66:     frozenset(
   67:         [
   68:             10058,  # LegacyNotPrimary <=3.2 "not primary" error code
   69:             10107,  # NotWritablePrimary
   70:             13435,  # NotPrimaryNoSecondaryOk
   71:             11602,  # InterruptedDueToReplStateChange
   72:             13436,  # NotPrimaryOrSecondary
   73:             189,  # PrimarySteppedDown
   74:         ]
   75:     )
   76:     | _SHUTDOWN_CODES
   77: )
   78: # From the retryable writes spec.
   79: _RETRYABLE_ERROR_CODES: frozenset = _NOT_PRIMARY_CODES | frozenset(
   80:     [
   81:         7,  # HostNotFound
   82:         6,  # HostUnreachable
   83:         89,  # NetworkTimeout
   84:         9001,  # SocketException
   85:         262,  # ExceededTimeLimit
   86:         134,  # ReadConcernMajorityNotAvailableYet
   87:     ]
   88: )
   89: 
   90: # Server code raised when re-authentication is required
   91: _REAUTHENTICATION_REQUIRED_CODE: int = 391
   92: 
   93: # Server code raised when authentication fails.
   94: _AUTHENTICATION_FAILURE_CODE: int = 18
   95: 
   96: # Note - to avoid bugs from forgetting which if these is all lowercase and
   97: # which are camelCase, and at the same time avoid having to add a test for
   98: # every command, use all lowercase here and test against command_name.lower().
   99: _SENSITIVE_COMMANDS: set = {
  100:     "authenticate",
  101:     "saslstart",
  102:     "saslcontinue",
  103:     "getnonce",
  104:     "createuser",
  105:     "updateuser",
  106:     "copydbgetnonce",
  107:     "copydbsaslstart",
  108:     "copydb",
  109: }
  110: 
  111: 
  112: def _gen_index_name(keys: _IndexList) -> str:
  113:     """Generate an index name from the set of fields it is over."""
  114:     return "_".join(["{}_{}".format(*item) for item in keys])
  115: 
  116: 
  117: def _index_list(
  118:     key_or_list: _Hint, direction: Optional[Union[int, str]] = None
  119: ) -> Sequence[tuple[str, Union[int, str, Mapping[str, Any]]]]:
  120:     """Helper to generate a list of (key, direction) pairs.
  121: 
  122:     Takes such a list, or a single key, or a single key and direction.
  123:     """
  124:     if direction is not None:
  125:         if not isinstance(key_or_list, str):
  126:             raise TypeError("Expected a string and a direction")
  127:         return [(key_or_list, direction)]
  128:     else:
  129:         if isinstance(key_or_list, str):
  130:             return [(key_or_list, ASCENDING)]
  131:         elif isinstance(key_or_list, abc.ItemsView):
  132:             return list(key_or_list)  # type: ignore[arg-type]
  133:         elif isinstance(key_or_list, abc.Mapping):
  134:             return list(key_or_list.items())
  135:         elif not isinstance(key_or_list, (list, tuple)):
  136:             raise TypeError("if no direction is specified, key_or_list must be an instance of list")
  137:         values: list[tuple[str, int]] = []
  138:         for item in key_or_list:
  139:             if isinstance(item, str):
  140:                 item = (item, ASCENDING)  # noqa: PLW2901
  141:             values.append(item)
  142:         return values
  143: 
  144: 
  145: def _index_document(index_list: _IndexList) -> dict[str, Any]:
  146:     """Helper to generate an index specifying document.
  147: 
  148:     Takes a list of (key, direction) pairs.
  149:     """
  150:     if not isinstance(index_list, (list, tuple, abc.Mapping)):
  151:         raise TypeError(
  152:             "must use a dictionary or a list of (key, direction) pairs, not: " + repr(index_list)
  153:         )
  154:     if not len(index_list):
  155:         raise ValueError("key_or_list must not be empty")
  156: 
  157:     index: dict[str, Any] = {}
  158: 
  159:     if isinstance(index_list, abc.Mapping):
  160:         for key in index_list:
  161:             value = index_list[key]
  162:             _validate_index_key_pair(key, value)
  163:             index[key] = value
  164:     else:
  165:         for item in index_list:
  166:             if isinstance(item, str):
  167:                 item = (item, ASCENDING)  # noqa: PLW2901
  168:             key, value = item
  169:             _validate_index_key_pair(key, value)
  170:             index[key] = value
  171:     return index
  172: 
  173: 
  174: def _validate_index_key_pair(key: Any, value: Any) -> None:
  175:     if not isinstance(key, str):
  176:         raise TypeError("first item in each key pair must be an instance of str")
  177:     if not isinstance(value, (str, int, abc.Mapping)):
  178:         raise TypeError(
  179:             "second item in each key pair must be 1, -1, "
  180:             "'2d', or another valid MongoDB index specifier."
  181:         )
  182: 
  183: 
  184: def _check_command_response(
  185:     response: _DocumentOut,
  186:     max_wire_version: Optional[int],
  187:     allowable_errors: Optional[Container[Union[int, str]]] = None,
  188:     parse_write_concern_error: bool = False,
  189: ) -> None:
  190:     """Check the response to a command for errors."""
  191:     if "ok" not in response:
  192:         # Server didn't recognize our message as a command.
  193:         raise OperationFailure(
  194:             response.get("$err"),  # type: ignore[arg-type]
  195:             response.get("code"),
  196:             response,
  197:             max_wire_version,
  198:         )
  199: 
  200:     if parse_write_concern_error and "writeConcernError" in response:
  201:         _error = response["writeConcernError"]
  202:         _labels = response.get("errorLabels")
  203:         if _labels:
  204:             _error.update({"errorLabels": _labels})
  205:         _raise_write_concern_error(_error)
  206: 
  207:     if response["ok"]:
  208:         return
  209: 
  210:     details = response
  211:     # Mongos returns the error details in a 'raw' object
  212:     # for some errors.
  213:     if "raw" in response:
  214:         for shard in response["raw"].values():
  215:             # Grab the first non-empty raw error from a shard.
  216:             if shard.get("errmsg") and not shard.get("ok"):
  217:                 details = shard
  218:                 break
  219: 
  220:     errmsg = details["errmsg"]
  221:     code = details.get("code")
  222: 
  223:     # For allowable errors, only check for error messages when the code is not
  224:     # included.
  225:     if allowable_errors:
  226:         if code is not None:
  227:             if code in allowable_errors:
  228:                 return
  229:         elif errmsg in allowable_errors:
  230:             return
  231: 
  232:     # Server is "not primary" or "recovering"
  233:     if code is not None:
  234:         if code in _NOT_PRIMARY_CODES:
  235:             raise NotPrimaryError(errmsg, response)
  236:     elif HelloCompat.LEGACY_ERROR in errmsg or "node is recovering" in errmsg:
  237:         raise NotPrimaryError(errmsg, response)
  238: 
  239:     # Other errors
  240:     # findAndModify with upsert can raise duplicate key error
  241:     if code in (11000, 11001, 12582):
  242:         raise DuplicateKeyError(errmsg, code, response, max_wire_version)
  243:     elif code == 50:
  244:         raise ExecutionTimeout(errmsg, code, response, max_wire_version)
  245:     elif code == 43:
  246:         raise CursorNotFound(errmsg, code, response, max_wire_version)
  247: 
  248:     raise OperationFailure(errmsg, code, response, max_wire_version)
  249: 
  250: 
  251: def _raise_last_write_error(write_errors: list[Any]) -> NoReturn:
  252:     # If the last batch had multiple errors only report
  253:     # the last error to emulate continue_on_error.
  254:     error = write_errors[-1]
  255:     if error.get("code") == 11000:
  256:         raise DuplicateKeyError(error.get("errmsg"), 11000, error)
  257:     raise WriteError(error.get("errmsg"), error.get("code"), error)
  258: 
  259: 
  260: def _raise_write_concern_error(error: Any) -> NoReturn:
  261:     if _wtimeout_error(error):
  262:         # Make sure we raise WTimeoutError
  263:         raise WTimeoutError(error.get("errmsg"), error.get("code"), error)
  264:     raise WriteConcernError(error.get("errmsg"), error.get("code"), error)
  265: 
  266: 
  267: def _get_wce_doc(result: Mapping[str, Any]) -> Optional[Mapping[str, Any]]:
  268:     """Return the writeConcernError or None."""
  269:     wce = result.get("writeConcernError")
  270:     if wce:
  271:         # The server reports errorLabels at the top level but it's more
  272:         # convenient to attach it to the writeConcernError doc itself.
  273:         error_labels = result.get("errorLabels")
  274:         if error_labels:
  275:             # Copy to avoid changing the original document.
  276:             wce = wce.copy()
  277:             wce["errorLabels"] = error_labels
  278:     return wce
  279: 
  280: 
  281: def _check_write_command_response(result: Mapping[str, Any]) -> None:
  282:     """Backward compatibility helper for write command error handling."""
  283:     # Prefer write errors over write concern errors
  284:     write_errors = result.get("writeErrors")
  285:     if write_errors:
  286:         _raise_last_write_error(write_errors)
  287: 
  288:     wce = _get_wce_doc(result)
  289:     if wce:
  290:         _raise_write_concern_error(wce)
  291: 
  292: 
  293: def _fields_list_to_dict(
  294:     fields: Union[Mapping[str, Any], Iterable[str]], option_name: str
  295: ) -> Mapping[str, Any]:
  296:     """Takes a sequence of field names and returns a matching dictionary.
  297: 
  298:     ["a", "b"] becomes {"a": 1, "b": 1}
  299: 
  300:     and
  301: 
  302:     ["a.b.c", "d", "a.c"] becomes {"a.b.c": 1, "d": 1, "a.c": 1}
  303:     """
  304:     if isinstance(fields, abc.Mapping):
  305:         return fields
  306: 
  307:     if isinstance(fields, (abc.Sequence, abc.Set)):
  308:         if not all(isinstance(field, str) for field in fields):
  309:             raise TypeError(f"{option_name} must be a list of key names, each an instance of str")
  310:         return dict.fromkeys(fields, 1)
  311: 
  312:     raise TypeError(f"{option_name} must be a mapping or list of key names")
  313: 
  314: 
  315: def _handle_exception() -> None:
  316:     """Print exceptions raised by subscribers to stderr."""
  317:     # Heavily influenced by logging.Handler.handleError.
  318: 
  319:     # See note here:
  320:     # https://docs.python.org/3.4/library/sys.html#sys.__stderr__
  321:     if sys.stderr:
  322:         einfo = sys.exc_info()
  323:         try:
  324:             traceback.print_exception(einfo[0], einfo[1], einfo[2], None, sys.stderr)
  325:         except OSError:
  326:             pass
  327:         finally:
  328:             del einfo
  329: 
  330: 
  331: # See https://mypy.readthedocs.io/en/stable/generics.html?#decorator-factories
  332: F = TypeVar("F", bound=Callable[..., Any])
  333: 
  334: 
  335: def _handle_reauth(func: F) -> F:
  336:     def inner(*args: Any, **kwargs: Any) -> Any:
  337:         no_reauth = kwargs.pop("no_reauth", False)
  338:         from pymongo.message import _BulkWriteContext
  339:         from pymongo.pool import Connection
  340: 
  341:         try:
  342:             return func(*args, **kwargs)
  343:         except OperationFailure as exc:
  344:             if no_reauth:
  345:                 raise
  346:             if exc.code == _REAUTHENTICATION_REQUIRED_CODE:
  347:                 # Look for an argument that either is a Connection
  348:                 # or has a connection attribute, so we can trigger
  349:                 # a reauth.
  350:                 conn = None
  351:                 for arg in args:
  352:                     if isinstance(arg, Connection):
  353:                         conn = arg
  354:                         break
  355:                     if isinstance(arg, _BulkWriteContext):
  356:                         conn = arg.conn
  357:                         break
  358:                 if conn:
  359:                     conn.authenticate(reauthenticate=True)
  360:                 else:
  361:                     raise
  362:                 return func(*args, **kwargs)
  363:             raise
  364: 
  365:     return cast(F, inner)
