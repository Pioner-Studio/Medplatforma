    1: # Copyright 2019-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """A CPython compatible SSLContext implementation wrapping PyOpenSSL's
   16: context.
   17: """
   18: from __future__ import annotations
   19: 
   20: import socket as _socket
   21: import ssl as _stdlibssl
   22: import sys as _sys
   23: import time as _time
   24: from errno import EINTR as _EINTR
   25: from ipaddress import ip_address as _ip_address
   26: from typing import TYPE_CHECKING, Any, Callable, Optional, TypeVar, Union
   27: 
   28: import cryptography.x509 as x509
   29: import service_identity
   30: from OpenSSL import SSL as _SSL
   31: from OpenSSL import crypto as _crypto
   32: 
   33: from pymongo.errors import ConfigurationError as _ConfigurationError
   34: from pymongo.errors import _CertificateError  # type:ignore[attr-defined]
   35: from pymongo.ocsp_cache import _OCSPCache
   36: from pymongo.ocsp_support import _load_trusted_ca_certs, _ocsp_callback
   37: from pymongo.socket_checker import SocketChecker as _SocketChecker
   38: from pymongo.socket_checker import _errno_from_exception
   39: from pymongo.write_concern import validate_boolean
   40: 
   41: if TYPE_CHECKING:
   42:     from ssl import VerifyMode
   43: 
   44: 
   45: _T = TypeVar("_T")
   46: 
   47: try:
   48:     import certifi
   49: 
   50:     _HAVE_CERTIFI = True
   51: except ImportError:
   52:     _HAVE_CERTIFI = False
   53: 
   54: PROTOCOL_SSLv23 = _SSL.SSLv23_METHOD
   55: # Always available
   56: OP_NO_SSLv2 = _SSL.OP_NO_SSLv2
   57: OP_NO_SSLv3 = _SSL.OP_NO_SSLv3
   58: OP_NO_COMPRESSION = _SSL.OP_NO_COMPRESSION
   59: # This isn't currently documented for PyOpenSSL
   60: OP_NO_RENEGOTIATION = getattr(_SSL, "OP_NO_RENEGOTIATION", 0)
   61: 
   62: # Always available
   63: HAS_SNI = True
   64: IS_PYOPENSSL = True
   65: 
   66: # Base Exception class
   67: SSLError = _SSL.Error
   68: 
   69: # https://github.com/python/cpython/blob/v3.8.0/Modules/_ssl.c#L2995-L3002
   70: _VERIFY_MAP = {
   71:     _stdlibssl.CERT_NONE: _SSL.VERIFY_NONE,
   72:     _stdlibssl.CERT_OPTIONAL: _SSL.VERIFY_PEER,
   73:     _stdlibssl.CERT_REQUIRED: _SSL.VERIFY_PEER | _SSL.VERIFY_FAIL_IF_NO_PEER_CERT,
   74: }
   75: 
   76: _REVERSE_VERIFY_MAP = {value: key for key, value in _VERIFY_MAP.items()}
   77: 
   78: 
   79: # For SNI support. According to RFC6066, section 3, IPv4 and IPv6 literals are
   80: # not permitted for SNI hostname.
   81: def _is_ip_address(address: Any) -> bool:
   82:     try:
   83:         _ip_address(address)
   84:         return True
   85:     except (ValueError, UnicodeError):
   86:         return False
   87: 
   88: 
   89: # According to the docs for socket.send it can raise
   90: # WantX509LookupError and should be retried.
   91: BLOCKING_IO_ERRORS = (_SSL.WantReadError, _SSL.WantWriteError, _SSL.WantX509LookupError)
   92: 
   93: 
   94: def _ragged_eof(exc: BaseException) -> bool:
   95:     """Return True if the OpenSSL.SSL.SysCallError is a ragged EOF."""
   96:     return exc.args == (-1, "Unexpected EOF")
   97: 
   98: 
   99: # https://github.com/pyca/pyopenssl/issues/168
  100: # https://github.com/pyca/pyopenssl/issues/176
  101: # https://docs.python.org/3/library/ssl.html#notes-on-non-blocking-sockets
  102: class _sslConn(_SSL.Connection):
  103:     def __init__(
  104:         self, ctx: _SSL.Context, sock: Optional[_socket.socket], suppress_ragged_eofs: bool
  105:     ):
  106:         self.socket_checker = _SocketChecker()
  107:         self.suppress_ragged_eofs = suppress_ragged_eofs
  108:         super().__init__(ctx, sock)
  109: 
  110:     def _call(self, call: Callable[..., _T], *args: Any, **kwargs: Any) -> _T:
  111:         timeout = self.gettimeout()
  112:         if timeout:
  113:             start = _time.monotonic()
  114:         while True:
  115:             try:
  116:                 return call(*args, **kwargs)
  117:             except BLOCKING_IO_ERRORS as exc:
  118:                 # Check for closed socket.
  119:                 if self.fileno() == -1:
  120:                     if timeout and _time.monotonic() - start > timeout:
  121:                         raise _socket.timeout("timed out") from None
  122:                     raise SSLError("Underlying socket has been closed") from None
  123:                 if isinstance(exc, _SSL.WantReadError):
  124:                     want_read = True
  125:                     want_write = False
  126:                 elif isinstance(exc, _SSL.WantWriteError):
  127:                     want_read = False
  128:                     want_write = True
  129:                 else:
  130:                     want_read = True
  131:                     want_write = True
  132:                 self.socket_checker.select(self, want_read, want_write, timeout)
  133:                 if timeout and _time.monotonic() - start > timeout:
  134:                     raise _socket.timeout("timed out") from None
  135:                 continue
  136: 
  137:     def do_handshake(self, *args: Any, **kwargs: Any) -> None:
  138:         return self._call(super().do_handshake, *args, **kwargs)
  139: 
  140:     def recv(self, *args: Any, **kwargs: Any) -> bytes:
  141:         try:
  142:             return self._call(super().recv, *args, **kwargs)
  143:         except _SSL.SysCallError as exc:
  144:             # Suppress ragged EOFs to match the stdlib.
  145:             if self.suppress_ragged_eofs and _ragged_eof(exc):
  146:                 return b""
  147:             raise
  148: 
  149:     def recv_into(self, *args: Any, **kwargs: Any) -> int:
  150:         try:
  151:             return self._call(super().recv_into, *args, **kwargs)
  152:         except _SSL.SysCallError as exc:
  153:             # Suppress ragged EOFs to match the stdlib.
  154:             if self.suppress_ragged_eofs and _ragged_eof(exc):
  155:                 return 0
  156:             raise
  157: 
  158:     def sendall(self, buf: bytes, flags: int = 0) -> None:  # type: ignore[override]
  159:         view = memoryview(buf)
  160:         total_length = len(buf)
  161:         total_sent = 0
  162:         while total_sent < total_length:
  163:             try:
  164:                 sent = self._call(super().send, view[total_sent:], flags)
  165:             # XXX: It's not clear if this can actually happen. PyOpenSSL
  166:             # doesn't appear to have any interrupt handling, nor any interrupt
  167:             # errors for OpenSSL connections.
  168:             except OSError as exc:
  169:                 if _errno_from_exception(exc) == _EINTR:
  170:                     continue
  171:                 raise
  172:             # https://github.com/pyca/pyopenssl/blob/19.1.0/src/OpenSSL/SSL.py#L1756
  173:             # https://www.openssl.org/docs/man1.0.2/man3/SSL_write.html
  174:             if sent <= 0:
  175:                 raise OSError("connection closed")
  176:             total_sent += sent
  177: 
  178: 
  179: class _CallbackData:
  180:     """Data class which is passed to the OCSP callback."""
  181: 
  182:     def __init__(self) -> None:
  183:         self.trusted_ca_certs: Optional[list[x509.Certificate]] = None
  184:         self.check_ocsp_endpoint: Optional[bool] = None
  185:         self.ocsp_response_cache = _OCSPCache()
  186: 
  187: 
  188: class SSLContext:
  189:     """A CPython compatible SSLContext implementation wrapping PyOpenSSL's
  190:     context.
  191:     """
  192: 
  193:     __slots__ = ("_protocol", "_ctx", "_callback_data", "_check_hostname")
  194: 
  195:     def __init__(self, protocol: int):
  196:         self._protocol = protocol
  197:         self._ctx = _SSL.Context(self._protocol)
  198:         self._callback_data = _CallbackData()
  199:         self._check_hostname = True
  200:         # OCSP
  201:         # XXX: Find a better place to do this someday, since this is client
  202:         # side configuration and wrap_socket tries to support both client and
  203:         # server side sockets.
  204:         self._callback_data.check_ocsp_endpoint = True
  205:         self._ctx.set_ocsp_client_callback(callback=_ocsp_callback, data=self._callback_data)
  206: 
  207:     @property
  208:     def protocol(self) -> int:
  209:         """The protocol version chosen when constructing the context.
  210:         This attribute is read-only.
  211:         """
  212:         return self._protocol
  213: 
  214:     def __get_verify_mode(self) -> VerifyMode:
  215:         """Whether to try to verify other peers' certificates and how to
  216:         behave if verification fails. This attribute must be one of
  217:         ssl.CERT_NONE, ssl.CERT_OPTIONAL or ssl.CERT_REQUIRED.
  218:         """
  219:         return _REVERSE_VERIFY_MAP[self._ctx.get_verify_mode()]
  220: 
  221:     def __set_verify_mode(self, value: VerifyMode) -> None:
  222:         """Setter for verify_mode."""
  223: 
  224:         def _cb(
  225:             _connobj: _SSL.Connection,
  226:             _x509obj: _crypto.X509,
  227:             _errnum: int,
  228:             _errdepth: int,
  229:             retcode: int,
  230:         ) -> bool:
  231:             # It seems we don't need to do anything here. Twisted doesn't,
  232:             # and OpenSSL's SSL_CTX_set_verify let's you pass NULL
  233:             # for the callback option. It's weird that PyOpenSSL requires
  234:             # this.
  235:             # This is optional in pyopenssl >= 20 and can be removed once minimum
  236:             # supported version is bumped
  237:             # See: pyopenssl.org/en/latest/changelog.html#id47
  238:             return bool(retcode)
  239: 
  240:         self._ctx.set_verify(_VERIFY_MAP[value], _cb)
  241: 
  242:     verify_mode = property(__get_verify_mode, __set_verify_mode)
  243: 
  244:     def __get_check_hostname(self) -> bool:
  245:         return self._check_hostname
  246: 
  247:     def __set_check_hostname(self, value: Any) -> None:
  248:         validate_boolean("check_hostname", value)
  249:         self._check_hostname = value
  250: 
  251:     check_hostname = property(__get_check_hostname, __set_check_hostname)
  252: 
  253:     def __get_check_ocsp_endpoint(self) -> Optional[bool]:
  254:         return self._callback_data.check_ocsp_endpoint
  255: 
  256:     def __set_check_ocsp_endpoint(self, value: bool) -> None:
  257:         validate_boolean("check_ocsp", value)
  258:         self._callback_data.check_ocsp_endpoint = value
  259: 
  260:     check_ocsp_endpoint = property(__get_check_ocsp_endpoint, __set_check_ocsp_endpoint)
  261: 
  262:     def __get_options(self) -> None:
  263:         # Calling set_options adds the option to the existing bitmask and
  264:         # returns the new bitmask.
  265:         # https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context.set_options
  266:         return self._ctx.set_options(0)
  267: 
  268:     def __set_options(self, value: int) -> None:
  269:         # Explicitly convert to int, since newer CPython versions
  270:         # use enum.IntFlag for options. The values are the same
  271:         # regardless of implementation.
  272:         self._ctx.set_options(int(value))
  273: 
  274:     options = property(__get_options, __set_options)
  275: 
  276:     def load_cert_chain(
  277:         self,
  278:         certfile: Union[str, bytes],
  279:         keyfile: Union[str, bytes, None] = None,
  280:         password: Optional[str] = None,
  281:     ) -> None:
  282:         """Load a private key and the corresponding certificate. The certfile
  283:         string must be the path to a single file in PEM format containing the
  284:         certificate as well as any number of CA certificates needed to
  285:         establish the certificate's authenticity. The keyfile string, if
  286:         present, must point to a file containing the private key. Otherwise
  287:         the private key will be taken from certfile as well.
  288:         """
  289:         # Match CPython behavior
  290:         # https://github.com/python/cpython/blob/v3.8.0/Modules/_ssl.c#L3930-L3971
  291:         # Password callback MUST be set first or it will be ignored.
  292:         if password:
  293: 
  294:             def _pwcb(_max_length: int, _prompt_twice: bool, _user_data: bytes) -> bytes:
  295:                 # XXX:We could check the password length against what OpenSSL
  296:                 # tells us is the max, but we can't raise an exception, so...
  297:                 # warn?
  298:                 assert password is not None
  299:                 return password.encode("utf-8")
  300: 
  301:             self._ctx.set_passwd_cb(_pwcb)
  302:         self._ctx.use_certificate_chain_file(certfile)
  303:         self._ctx.use_privatekey_file(keyfile or certfile)
  304:         self._ctx.check_privatekey()
  305: 
  306:     def load_verify_locations(
  307:         self, cafile: Optional[str] = None, capath: Optional[str] = None
  308:     ) -> None:
  309:         """Load a set of "certification authority"(CA) certificates used to
  310:         validate other peers' certificates when `~verify_mode` is other than
  311:         ssl.CERT_NONE.
  312:         """
  313:         self._ctx.load_verify_locations(cafile, capath)
  314:         # Manually load the CA certs when get_verified_chain is not available (pyopenssl<20).
  315:         if not hasattr(_SSL.Connection, "get_verified_chain"):
  316:             assert cafile is not None
  317:             self._callback_data.trusted_ca_certs = _load_trusted_ca_certs(cafile)
  318: 
  319:     def _load_certifi(self) -> None:
  320:         """Attempt to load CA certs from certifi."""
  321:         if _HAVE_CERTIFI:
  322:             self.load_verify_locations(certifi.where())
  323:         else:
  324:             raise _ConfigurationError(
  325:                 "tlsAllowInvalidCertificates is False but no system "
  326:                 "CA certificates could be loaded. Please install the "
  327:                 "certifi package, or provide a path to a CA file using "
  328:                 "the tlsCAFile option"
  329:             )
  330: 
  331:     def _load_wincerts(self, store: str) -> None:
  332:         """Attempt to load CA certs from Windows trust store."""
  333:         cert_store = self._ctx.get_cert_store()
  334:         oid = _stdlibssl.Purpose.SERVER_AUTH.oid
  335: 
  336:         for cert, encoding, trust in _stdlibssl.enum_certificates(store):  # type: ignore
  337:             if encoding == "x509_asn":
  338:                 if trust is True or oid in trust:
  339:                     cert_store.add_cert(
  340:                         _crypto.X509.from_cryptography(x509.load_der_x509_certificate(cert))
  341:                     )
  342: 
  343:     def load_default_certs(self) -> None:
  344:         """A PyOpenSSL version of load_default_certs from CPython."""
  345:         # PyOpenSSL is incapable of loading CA certs from Windows, and mostly
  346:         # incapable on macOS.
  347:         # https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context.set_default_verify_paths
  348:         if _sys.platform == "win32":
  349:             try:
  350:                 for storename in ("CA", "ROOT"):
  351:                     self._load_wincerts(storename)
  352:             except PermissionError:
  353:                 # Fall back to certifi
  354:                 self._load_certifi()
  355:         elif _sys.platform == "darwin":
  356:             self._load_certifi()
  357:         self._ctx.set_default_verify_paths()
  358: 
  359:     def set_default_verify_paths(self) -> None:
  360:         """Specify that the platform provided CA certificates are to be used
  361:         for verification purposes.
  362:         """
  363:         # Note: See PyOpenSSL's docs for limitations, which are similar
  364:         # but not that same as CPython's.
  365:         self._ctx.set_default_verify_paths()
  366: 
  367:     def wrap_socket(
  368:         self,
  369:         sock: _socket.socket,
  370:         server_side: bool = False,
  371:         do_handshake_on_connect: bool = True,
  372:         suppress_ragged_eofs: bool = True,
  373:         server_hostname: Optional[str] = None,
  374:         session: Optional[_SSL.Session] = None,
  375:     ) -> _sslConn:
  376:         """Wrap an existing Python socket connection and return a TLS socket
  377:         object.
  378:         """
  379:         ssl_conn = _sslConn(self._ctx, sock, suppress_ragged_eofs)
  380:         if session:
  381:             ssl_conn.set_session(session)
  382:         if server_side is True:
  383:             ssl_conn.set_accept_state()
  384:         else:
  385:             # SNI
  386:             if server_hostname and not _is_ip_address(server_hostname):
  387:                 # XXX: Do this in a callback registered with
  388:                 # SSLContext.set_info_callback? See Twisted for an example.
  389:                 ssl_conn.set_tlsext_host_name(server_hostname.encode("idna"))
  390:             if self.verify_mode != _stdlibssl.CERT_NONE:
  391:                 # Request a stapled OCSP response.
  392:                 ssl_conn.request_ocsp()
  393:             ssl_conn.set_connect_state()
  394:         # If this wasn't true the caller of wrap_socket would call
  395:         # do_handshake()
  396:         if do_handshake_on_connect:
  397:             # XXX: If we do hostname checking in a callback we can get rid
  398:             # of this call to do_handshake() since the handshake
  399:             # will happen automatically later.
  400:             ssl_conn.do_handshake()
  401:             # XXX: Do this in a callback registered with
  402:             # SSLContext.set_info_callback? See Twisted for an example.
  403:             if self.check_hostname and server_hostname is not None:
  404:                 from service_identity import pyopenssl
  405: 
  406:                 try:
  407:                     if _is_ip_address(server_hostname):
  408:                         pyopenssl.verify_ip_address(ssl_conn, server_hostname)
  409:                     else:
  410:                         pyopenssl.verify_hostname(ssl_conn, server_hostname)
  411:                 except (  # type:ignore[misc]
  412:                     service_identity.SICertificateError,
  413:                     service_identity.SIVerificationError,
  414:                 ) as exc:
  415:                     raise _CertificateError(str(exc)) from None
  416:         return ssl_conn
