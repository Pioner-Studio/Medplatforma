    1: # Copyright 2016-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """An implementation of RFC4013 SASLprep."""
   16: from __future__ import annotations
   17: 
   18: from typing import Any, Optional
   19: 
   20: try:
   21:     import stringprep
   22: except ImportError:
   23:     HAVE_STRINGPREP = False
   24: 
   25:     def saslprep(
   26:         data: Any,
   27:         prohibit_unassigned_code_points: Optional[bool] = True,  # noqa: ARG001
   28:     ) -> Any:
   29:         """SASLprep dummy"""
   30:         if isinstance(data, str):
   31:             raise TypeError(
   32:                 "The stringprep module is not available. Usernames and "
   33:                 "passwords must be instances of bytes."
   34:             )
   35:         return data
   36: 
   37: else:
   38:     HAVE_STRINGPREP = True
   39:     import unicodedata
   40: 
   41:     # RFC4013 section 2.3 prohibited output.
   42:     _PROHIBITED = (
   43:         # A strict reading of RFC 4013 requires table c12 here, but
   44:         # characters from it are mapped to SPACE in the Map step. Can
   45:         # normalization reintroduce them somehow?
   46:         stringprep.in_table_c12,
   47:         stringprep.in_table_c21_c22,
   48:         stringprep.in_table_c3,
   49:         stringprep.in_table_c4,
   50:         stringprep.in_table_c5,
   51:         stringprep.in_table_c6,
   52:         stringprep.in_table_c7,
   53:         stringprep.in_table_c8,
   54:         stringprep.in_table_c9,
   55:     )
   56: 
   57:     def saslprep(data: Any, prohibit_unassigned_code_points: Optional[bool] = True) -> Any:
   58:         """An implementation of RFC4013 SASLprep.
   59: 
   60:         :param data: The string to SASLprep. Unicode strings
   61:             (:class:`str`) are supported. Byte strings
   62:             (:class:`bytes`) are ignored.
   63:         :param prohibit_unassigned_code_points: True / False. RFC 3454
   64:             and RFCs for various SASL mechanisms distinguish between
   65:             `queries` (unassigned code points allowed) and
   66:             `stored strings` (unassigned code points prohibited). Defaults
   67:             to ``True`` (unassigned code points are prohibited).
   68: 
   69:         :return: The SASLprep'ed version of `data`.
   70:         """
   71:         prohibited: Any
   72: 
   73:         if not isinstance(data, str):
   74:             return data
   75: 
   76:         if prohibit_unassigned_code_points:
   77:             prohibited = (*_PROHIBITED, stringprep.in_table_a1)
   78:         else:
   79:             prohibited = _PROHIBITED
   80: 
   81:         # RFC3454 section 2, step 1 - Map
   82:         # RFC4013 section 2.1 mappings
   83:         # Map Non-ASCII space characters to SPACE (U+0020). Map
   84:         # commonly mapped to nothing characters to, well, nothing.
   85:         in_table_c12 = stringprep.in_table_c12
   86:         in_table_b1 = stringprep.in_table_b1
   87:         data = "".join(
   88:             ["\u0020" if in_table_c12(elt) else elt for elt in data if not in_table_b1(elt)]
   89:         )
   90: 
   91:         # RFC3454 section 2, step 2 - Normalize
   92:         # RFC4013 section 2.2 normalization
   93:         data = unicodedata.ucd_3_2_0.normalize("NFKC", data)
   94: 
   95:         in_table_d1 = stringprep.in_table_d1
   96:         if in_table_d1(data[0]):
   97:             if not in_table_d1(data[-1]):
   98:                 # RFC3454, Section 6, #3. If a string contains any
   99:                 # RandALCat character, the first and last characters
  100:                 # MUST be RandALCat characters.
  101:                 raise ValueError("SASLprep: failed bidirectional check")
  102:             # RFC3454, Section 6, #2. If a string contains any RandALCat
  103:             # character, it MUST NOT contain any LCat character.
  104:             prohibited = (*prohibited, stringprep.in_table_d2)
  105:         else:
  106:             # RFC3454, Section 6, #3. Following the logic of #3, if
  107:             # the first character is not a RandALCat, no other character
  108:             # can be either.
  109:             prohibited = (*prohibited, in_table_d1)
  110: 
  111:         # RFC3454 section 2, step 3 and 4 - Prohibit and check bidi
  112:         for char in data:
  113:             if any(in_table(char) for in_table in prohibited):
  114:                 raise ValueError("SASLprep: failed prohibited character check")
  115: 
  116:         return data
