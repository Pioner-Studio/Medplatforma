    1: # Copyright 2017 MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Logical sessions for ordering sequential operations.
   16: 
   17: .. versionadded:: 3.6
   18: 
   19: Causally Consistent Reads
   20: =========================
   21: 
   22: .. code-block:: python
   23: 
   24:   with client.start_session(causal_consistency=True) as session:
   25:       collection = client.db.collection
   26:       collection.update_one({"_id": 1}, {"$set": {"x": 10}}, session=session)
   27:       secondary_c = collection.with_options(read_preference=ReadPreference.SECONDARY)
   28: 
   29:       # A secondary read waits for replication of the write.
   30:       secondary_c.find_one({"_id": 1}, session=session)
   31: 
   32: If `causal_consistency` is True (the default), read operations that use
   33: the session are causally after previous read and write operations. Using a
   34: causally consistent session, an application can read its own writes and is
   35: guaranteed monotonic reads, even when reading from replica set secondaries.
   36: 
   37: .. seealso:: The MongoDB documentation on `causal-consistency <https://dochub.mongodb.org/core/causal-consistency>`_.
   38: 
   39: .. _transactions-ref:
   40: 
   41: Transactions
   42: ============
   43: 
   44: .. versionadded:: 3.7
   45: 
   46: MongoDB 4.0 adds support for transactions on replica set primaries. A
   47: transaction is associated with a :class:`ClientSession`. To start a transaction
   48: on a session, use :meth:`ClientSession.start_transaction` in a with-statement.
   49: Then, execute an operation within the transaction by passing the session to the
   50: operation:
   51: 
   52: .. code-block:: python
   53: 
   54:   orders = client.db.orders
   55:   inventory = client.db.inventory
   56:   with client.start_session() as session:
   57:       with session.start_transaction():
   58:           orders.insert_one({"sku": "abc123", "qty": 100}, session=session)
   59:           inventory.update_one(
   60:               {"sku": "abc123", "qty": {"$gte": 100}},
   61:               {"$inc": {"qty": -100}},
   62:               session=session,
   63:           )
   64: 
   65: Upon normal completion of ``with session.start_transaction()`` block, the
   66: transaction automatically calls :meth:`ClientSession.commit_transaction`.
   67: If the block exits with an exception, the transaction automatically calls
   68: :meth:`ClientSession.abort_transaction`.
   69: 
   70: In general, multi-document transactions only support read/write (CRUD)
   71: operations on existing collections. However, MongoDB 4.4 adds support for
   72: creating collections and indexes with some limitations, including an
   73: insert operation that would result in the creation of a new collection.
   74: For a complete description of all the supported and unsupported operations
   75: see the `MongoDB server's documentation for transactions
   76: <http://dochub.mongodb.org/core/transactions>`_.
   77: 
   78: A session may only have a single active transaction at a time, multiple
   79: transactions on the same session can be executed in sequence.
   80: 
   81: Sharded Transactions
   82: ^^^^^^^^^^^^^^^^^^^^
   83: 
   84: .. versionadded:: 3.9
   85: 
   86: PyMongo 3.9 adds support for transactions on sharded clusters running MongoDB
   87: >=4.2. Sharded transactions have the same API as replica set transactions.
   88: When running a transaction against a sharded cluster, the session is
   89: pinned to the mongos server selected for the first operation in the
   90: transaction. All subsequent operations that are part of the same transaction
   91: are routed to the same mongos server. When the transaction is completed, by
   92: running either commitTransaction or abortTransaction, the session is unpinned.
   93: 
   94: .. seealso:: The MongoDB documentation on `transactions <https://dochub.mongodb.org/core/transactions>`_.
   95: 
   96: .. _snapshot-reads-ref:
   97: 
   98: Snapshot Reads
   99: ==============
  100: 
  101: .. versionadded:: 3.12
  102: 
  103: MongoDB 5.0 adds support for snapshot reads. Snapshot reads are requested by
  104: passing the ``snapshot`` option to
  105: :meth:`~pymongo.mongo_client.MongoClient.start_session`.
  106: If ``snapshot`` is True, all read operations that use this session read data
  107: from the same snapshot timestamp. The server chooses the latest
  108: majority-committed snapshot timestamp when executing the first read operation
  109: using the session. Subsequent reads on this session read from the same
  110: snapshot timestamp. Snapshot reads are also supported when reading from
  111: replica set secondaries.
  112: 
  113: .. code-block:: python
  114: 
  115:   # Each read using this session reads data from the same point in time.
  116:   with client.start_session(snapshot=True) as session:
  117:       order = orders.find_one({"sku": "abc123"}, session=session)
  118:       inventory = inventory.find_one({"sku": "abc123"}, session=session)
  119: 
  120: Snapshot Reads Limitations
  121: ^^^^^^^^^^^^^^^^^^^^^^^^^^
  122: 
  123: Snapshot reads sessions are incompatible with ``causal_consistency=True``.
  124: Only the following read operations are supported in a snapshot reads session:
  125: 
  126: - :meth:`~pymongo.collection.Collection.find`
  127: - :meth:`~pymongo.collection.Collection.find_one`
  128: - :meth:`~pymongo.collection.Collection.aggregate`
  129: - :meth:`~pymongo.collection.Collection.count_documents`
  130: - :meth:`~pymongo.collection.Collection.distinct` (on unsharded collections)
  131: 
  132: Classes
  133: =======
  134: """
  135: 
  136: from __future__ import annotations
  137: 
  138: import collections
  139: import time
  140: import uuid
  141: from collections.abc import Mapping as _Mapping
  142: from typing import (
  143:     TYPE_CHECKING,
  144:     Any,
  145:     Callable,
  146:     ContextManager,
  147:     Mapping,
  148:     MutableMapping,
  149:     NoReturn,
  150:     Optional,
  151:     Type,
  152:     TypeVar,
  153: )
  154: 
  155: from bson.binary import Binary
  156: from bson.int64 import Int64
  157: from bson.timestamp import Timestamp
  158: from pymongo import _csot
  159: from pymongo.cursor import _ConnectionManager
  160: from pymongo.errors import (
  161:     ConfigurationError,
  162:     ConnectionFailure,
  163:     InvalidOperation,
  164:     OperationFailure,
  165:     PyMongoError,
  166:     WTimeoutError,
  167: )
  168: from pymongo.helpers import _RETRYABLE_ERROR_CODES
  169: from pymongo.operations import _Op
  170: from pymongo.read_concern import ReadConcern
  171: from pymongo.read_preferences import ReadPreference, _ServerMode
  172: from pymongo.server_type import SERVER_TYPE
  173: from pymongo.write_concern import WriteConcern
  174: 
  175: if TYPE_CHECKING:
  176:     from types import TracebackType
  177: 
  178:     from pymongo.pool import Connection
  179:     from pymongo.server import Server
  180:     from pymongo.typings import ClusterTime, _Address
  181: 
  182: 
  183: class SessionOptions:
  184:     """Options for a new :class:`ClientSession`.
  185: 
  186:     :param causal_consistency: If True, read operations are causally
  187:         ordered within the session. Defaults to True when the ``snapshot``
  188:         option is ``False``.
  189:     :param default_transaction_options: The default
  190:         TransactionOptions to use for transactions started on this session.
  191:     :param snapshot: If True, then all reads performed using this
  192:         session will read from the same snapshot. This option is incompatible
  193:         with ``causal_consistency=True``. Defaults to ``False``.
  194: 
  195:     .. versionchanged:: 3.12
  196:        Added the ``snapshot`` parameter.
  197:     """
  198: 
  199:     def __init__(
  200:         self,
  201:         causal_consistency: Optional[bool] = None,
  202:         default_transaction_options: Optional[TransactionOptions] = None,
  203:         snapshot: Optional[bool] = False,
  204:     ) -> None:
  205:         if snapshot:
  206:             if causal_consistency:
  207:                 raise ConfigurationError("snapshot reads do not support causal_consistency=True")
  208:             causal_consistency = False
  209:         elif causal_consistency is None:
  210:             causal_consistency = True
  211:         self._causal_consistency = causal_consistency
  212:         if default_transaction_options is not None:
  213:             if not isinstance(default_transaction_options, TransactionOptions):
  214:                 raise TypeError(
  215:                     "default_transaction_options must be an instance of "
  216:                     "pymongo.client_session.TransactionOptions, not: {!r}".format(
  217:                         default_transaction_options
  218:                     )
  219:                 )
  220:         self._default_transaction_options = default_transaction_options
  221:         self._snapshot = snapshot
  222: 
  223:     @property
  224:     def causal_consistency(self) -> bool:
  225:         """Whether causal consistency is configured."""
  226:         return self._causal_consistency
  227: 
  228:     @property
  229:     def default_transaction_options(self) -> Optional[TransactionOptions]:
  230:         """The default TransactionOptions to use for transactions started on
  231:         this session.
  232: 
  233:         .. versionadded:: 3.7
  234:         """
  235:         return self._default_transaction_options
  236: 
  237:     @property
  238:     def snapshot(self) -> Optional[bool]:
  239:         """Whether snapshot reads are configured.
  240: 
  241:         .. versionadded:: 3.12
  242:         """
  243:         return self._snapshot
  244: 
  245: 
  246: class TransactionOptions:
  247:     """Options for :meth:`ClientSession.start_transaction`.
  248: 
  249:     :param read_concern: The
  250:         :class:`~pymongo.read_concern.ReadConcern` to use for this transaction.
  251:         If ``None`` (the default) the :attr:`read_preference` of
  252:         the :class:`MongoClient` is used.
  253:     :param write_concern: The
  254:         :class:`~pymongo.write_concern.WriteConcern` to use for this
  255:         transaction. If ``None`` (the default) the :attr:`read_preference` of
  256:         the :class:`MongoClient` is used.
  257:     :param read_preference: The read preference to use. If
  258:         ``None`` (the default) the :attr:`read_preference` of this
  259:         :class:`MongoClient` is used. See :mod:`~pymongo.read_preferences`
  260:         for options. Transactions which read must use
  261:         :attr:`~pymongo.read_preferences.ReadPreference.PRIMARY`.
  262:     :param max_commit_time_ms: The maximum amount of time to allow a
  263:         single commitTransaction command to run. This option is an alias for
  264:         maxTimeMS option on the commitTransaction command. If ``None`` (the
  265:         default) maxTimeMS is not used.
  266: 
  267:     .. versionchanged:: 3.9
  268:        Added the ``max_commit_time_ms`` option.
  269: 
  270:     .. versionadded:: 3.7
  271:     """
  272: 
  273:     def __init__(
  274:         self,
  275:         read_concern: Optional[ReadConcern] = None,
  276:         write_concern: Optional[WriteConcern] = None,
  277:         read_preference: Optional[_ServerMode] = None,
  278:         max_commit_time_ms: Optional[int] = None,
  279:     ) -> None:
  280:         self._read_concern = read_concern
  281:         self._write_concern = write_concern
  282:         self._read_preference = read_preference
  283:         self._max_commit_time_ms = max_commit_time_ms
  284:         if read_concern is not None:
  285:             if not isinstance(read_concern, ReadConcern):
  286:                 raise TypeError(
  287:                     "read_concern must be an instance of "
  288:                     f"pymongo.read_concern.ReadConcern, not: {read_concern!r}"
  289:                 )
  290:         if write_concern is not None:
  291:             if not isinstance(write_concern, WriteConcern):
  292:                 raise TypeError(
  293:                     "write_concern must be an instance of "
  294:                     f"pymongo.write_concern.WriteConcern, not: {write_concern!r}"
  295:                 )
  296:             if not write_concern.acknowledged:
  297:                 raise ConfigurationError(
  298:                     "transactions do not support unacknowledged write concern"
  299:                     f": {write_concern!r}"
  300:                 )
  301:         if read_preference is not None:
  302:             if not isinstance(read_preference, _ServerMode):
  303:                 raise TypeError(
  304:                     f"{read_preference!r} is not valid for read_preference. See "
  305:                     "pymongo.read_preferences for valid "
  306:                     "options."
  307:                 )
  308:         if max_commit_time_ms is not None:
  309:             if not isinstance(max_commit_time_ms, int):
  310:                 raise TypeError("max_commit_time_ms must be an integer or None")
  311: 
  312:     @property
  313:     def read_concern(self) -> Optional[ReadConcern]:
  314:         """This transaction's :class:`~pymongo.read_concern.ReadConcern`."""
  315:         return self._read_concern
  316: 
  317:     @property
  318:     def write_concern(self) -> Optional[WriteConcern]:
  319:         """This transaction's :class:`~pymongo.write_concern.WriteConcern`."""
  320:         return self._write_concern
  321: 
  322:     @property
  323:     def read_preference(self) -> Optional[_ServerMode]:
  324:         """This transaction's :class:`~pymongo.read_preferences.ReadPreference`."""
  325:         return self._read_preference
  326: 
  327:     @property
  328:     def max_commit_time_ms(self) -> Optional[int]:
  329:         """The maxTimeMS to use when running a commitTransaction command.
  330: 
  331:         .. versionadded:: 3.9
  332:         """
  333:         return self._max_commit_time_ms
  334: 
  335: 
  336: def _validate_session_write_concern(
  337:     session: Optional[ClientSession], write_concern: Optional[WriteConcern]
  338: ) -> Optional[ClientSession]:
  339:     """Validate that an explicit session is not used with an unack'ed write.
  340: 
  341:     Returns the session to use for the next operation.
  342:     """
  343:     if session:
  344:         if write_concern is not None and not write_concern.acknowledged:
  345:             # For unacknowledged writes without an explicit session,
  346:             # drivers SHOULD NOT use an implicit session. If a driver
  347:             # creates an implicit session for unacknowledged writes
  348:             # without an explicit session, the driver MUST NOT send the
  349:             # session ID.
  350:             if session._implicit:
  351:                 return None
  352:             else:
  353:                 raise ConfigurationError(
  354:                     "Explicit sessions are incompatible with "
  355:                     f"unacknowledged write concern: {write_concern!r}"
  356:                 )
  357:     return session
  358: 
  359: 
  360: class _TransactionContext:
  361:     """Internal transaction context manager for start_transaction."""
  362: 
  363:     def __init__(self, session: ClientSession):
  364:         self.__session = session
  365: 
  366:     def __enter__(self) -> _TransactionContext:
  367:         return self
  368: 
  369:     def __exit__(
  370:         self,
  371:         exc_type: Optional[Type[BaseException]],
  372:         exc_val: Optional[BaseException],
  373:         exc_tb: Optional[TracebackType],
  374:     ) -> None:
  375:         if self.__session.in_transaction:
  376:             if exc_val is None:
  377:                 self.__session.commit_transaction()
  378:             else:
  379:                 self.__session.abort_transaction()
  380: 
  381: 
  382: class _TxnState:
  383:     NONE = 1
  384:     STARTING = 2
  385:     IN_PROGRESS = 3
  386:     COMMITTED = 4
  387:     COMMITTED_EMPTY = 5
  388:     ABORTED = 6
  389: 
  390: 
  391: class _Transaction:
  392:     """Internal class to hold transaction information in a ClientSession."""
  393: 
  394:     def __init__(self, opts: Optional[TransactionOptions], client: MongoClient):
  395:         self.opts = opts
  396:         self.state = _TxnState.NONE
  397:         self.sharded = False
  398:         self.pinned_address: Optional[_Address] = None
  399:         self.conn_mgr: Optional[_ConnectionManager] = None
  400:         self.recovery_token = None
  401:         self.attempt = 0
  402:         self.client = client
  403: 
  404:     def active(self) -> bool:
  405:         return self.state in (_TxnState.STARTING, _TxnState.IN_PROGRESS)
  406: 
  407:     def starting(self) -> bool:
  408:         return self.state == _TxnState.STARTING
  409: 
  410:     @property
  411:     def pinned_conn(self) -> Optional[Connection]:
  412:         if self.active() and self.conn_mgr:
  413:             return self.conn_mgr.conn
  414:         return None
  415: 
  416:     def pin(self, server: Server, conn: Connection) -> None:
  417:         self.sharded = True
  418:         self.pinned_address = server.description.address
  419:         if server.description.server_type == SERVER_TYPE.LoadBalancer:
  420:             conn.pin_txn()
  421:             self.conn_mgr = _ConnectionManager(conn, False)
  422: 
  423:     def unpin(self) -> None:
  424:         self.pinned_address = None
  425:         if self.conn_mgr:
  426:             self.conn_mgr.close()
  427:         self.conn_mgr = None
  428: 
  429:     def reset(self) -> None:
  430:         self.unpin()
  431:         self.state = _TxnState.NONE
  432:         self.sharded = False
  433:         self.recovery_token = None
  434:         self.attempt = 0
  435: 
  436:     def __del__(self) -> None:
  437:         if self.conn_mgr:
  438:             # Reuse the cursor closing machinery to return the socket to the
  439:             # pool soon.
  440:             self.client._close_cursor_soon(0, None, self.conn_mgr)
  441:             self.conn_mgr = None
  442: 
  443: 
  444: def _reraise_with_unknown_commit(exc: Any) -> NoReturn:
  445:     """Re-raise an exception with the UnknownTransactionCommitResult label."""
  446:     exc._add_error_label("UnknownTransactionCommitResult")
  447:     raise
  448: 
  449: 
  450: def _max_time_expired_error(exc: PyMongoError) -> bool:
  451:     """Return true if exc is a MaxTimeMSExpired error."""
  452:     return isinstance(exc, OperationFailure) and exc.code == 50
  453: 
  454: 
  455: # From the transactions spec, all the retryable writes errors plus
  456: # WriteConcernFailed.
  457: _UNKNOWN_COMMIT_ERROR_CODES: frozenset = _RETRYABLE_ERROR_CODES | frozenset(
  458:     [
  459:         64,  # WriteConcernFailed
  460:         50,  # MaxTimeMSExpired
  461:     ]
  462: )
  463: 
  464: # From the Convenient API for Transactions spec, with_transaction must
  465: # halt retries after 120 seconds.
  466: # This limit is non-configurable and was chosen to be twice the 60 second
  467: # default value of MongoDB's `transactionLifetimeLimitSeconds` parameter.
  468: _WITH_TRANSACTION_RETRY_TIME_LIMIT = 120
  469: 
  470: 
  471: def _within_time_limit(start_time: float) -> bool:
  472:     """Are we within the with_transaction retry limit?"""
  473:     return time.monotonic() - start_time < _WITH_TRANSACTION_RETRY_TIME_LIMIT
  474: 
  475: 
  476: _T = TypeVar("_T")
  477: 
  478: if TYPE_CHECKING:
  479:     from pymongo.mongo_client import MongoClient
  480: 
  481: 
  482: class ClientSession:
  483:     """A session for ordering sequential operations.
  484: 
  485:     :class:`ClientSession` instances are **not thread-safe or fork-safe**.
  486:     They can only be used by one thread or process at a time. A single
  487:     :class:`ClientSession` cannot be used to run multiple operations
  488:     concurrently.
  489: 
  490:     Should not be initialized directly by application developers - to create a
  491:     :class:`ClientSession`, call
  492:     :meth:`~pymongo.mongo_client.MongoClient.start_session`.
  493:     """
  494: 
  495:     def __init__(
  496:         self,
  497:         client: MongoClient,
  498:         server_session: Any,
  499:         options: SessionOptions,
  500:         implicit: bool,
  501:     ) -> None:
  502:         # A MongoClient, a _ServerSession, a SessionOptions, and a set.
  503:         self._client: MongoClient = client
  504:         self._server_session = server_session
  505:         self._options = options
  506:         self._cluster_time: Optional[Mapping[str, Any]] = None
  507:         self._operation_time: Optional[Timestamp] = None
  508:         self._snapshot_time = None
  509:         # Is this an implicitly created session?
  510:         self._implicit = implicit
  511:         self._transaction = _Transaction(None, client)
  512: 
  513:     def end_session(self) -> None:
  514:         """Finish this session. If a transaction has started, abort it.
  515: 
  516:         It is an error to use the session after the session has ended.
  517:         """
  518:         if self._server_session is not None:
  519:             try:
  520:                 if self.in_transaction:
  521:                     self.abort_transaction()
  522:                 # It's possible we're still pinned here when the transaction
  523:                 # is in the committed state when the session is discarded.
  524:                 self._unpin()
  525:             finally:
  526:                 self._client._return_server_session(self._server_session)
  527:                 self._server_session = None
  528: 
  529:     def _check_ended(self) -> None:
  530:         if self._server_session is None:
  531:             raise InvalidOperation("Cannot use ended session")
  532: 
  533:     def __enter__(self) -> ClientSession:
  534:         return self
  535: 
  536:     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
  537:         self.end_session()
  538: 
  539:     @property
  540:     def client(self) -> MongoClient:
  541:         """The :class:`~pymongo.mongo_client.MongoClient` this session was
  542:         created from.
  543:         """
  544:         return self._client
  545: 
  546:     @property
  547:     def options(self) -> SessionOptions:
  548:         """The :class:`SessionOptions` this session was created with."""
  549:         return self._options
  550: 
  551:     @property
  552:     def session_id(self) -> Mapping[str, Any]:
  553:         """A BSON document, the opaque server session identifier."""
  554:         self._check_ended()
  555:         self._materialize(self._client.topology_description.logical_session_timeout_minutes)
  556:         return self._server_session.session_id
  557: 
  558:     @property
  559:     def _transaction_id(self) -> Int64:
  560:         """The current transaction id for the underlying server session."""
  561:         self._materialize(self._client.topology_description.logical_session_timeout_minutes)
  562:         return self._server_session.transaction_id
  563: 
  564:     @property
  565:     def cluster_time(self) -> Optional[ClusterTime]:
  566:         """The cluster time returned by the last operation executed
  567:         in this session.
  568:         """
  569:         return self._cluster_time
  570: 
  571:     @property
  572:     def operation_time(self) -> Optional[Timestamp]:
  573:         """The operation time returned by the last operation executed
  574:         in this session.
  575:         """
  576:         return self._operation_time
  577: 
  578:     def _inherit_option(self, name: str, val: _T) -> _T:
  579:         """Return the inherited TransactionOption value."""
  580:         if val:
  581:             return val
  582:         txn_opts = self.options.default_transaction_options
  583:         parent_val = txn_opts and getattr(txn_opts, name)
  584:         if parent_val:
  585:             return parent_val
  586:         return getattr(self.client, name)
  587: 
  588:     def with_transaction(
  589:         self,
  590:         callback: Callable[[ClientSession], _T],
  591:         read_concern: Optional[ReadConcern] = None,
  592:         write_concern: Optional[WriteConcern] = None,
  593:         read_preference: Optional[_ServerMode] = None,
  594:         max_commit_time_ms: Optional[int] = None,
  595:     ) -> _T:
  596:         """Execute a callback in a transaction.
  597: 
  598:         This method starts a transaction on this session, executes ``callback``
  599:         once, and then commits the transaction. For example::
  600: 
  601:           def callback(session):
  602:               orders = session.client.db.orders
  603:               inventory = session.client.db.inventory
  604:               orders.insert_one({"sku": "abc123", "qty": 100}, session=session)
  605:               inventory.update_one({"sku": "abc123", "qty": {"$gte": 100}},
  606:                                    {"$inc": {"qty": -100}}, session=session)
  607: 
  608:           with client.start_session() as session:
  609:               session.with_transaction(callback)
  610: 
  611:         To pass arbitrary arguments to the ``callback``, wrap your callable
  612:         with a ``lambda`` like this::
  613: 
  614:           def callback(session, custom_arg, custom_kwarg=None):
  615:               # Transaction operations...
  616: 
  617:           with client.start_session() as session:
  618:               session.with_transaction(
  619:                   lambda s: callback(s, "custom_arg", custom_kwarg=1))
  620: 
  621:         In the event of an exception, ``with_transaction`` may retry the commit
  622:         or the entire transaction, therefore ``callback`` may be invoked
  623:         multiple times by a single call to ``with_transaction``. Developers
  624:         should be mindful of this possibility when writing a ``callback`` that
  625:         modifies application state or has any other side-effects.
  626:         Note that even when the ``callback`` is invoked multiple times,
  627:         ``with_transaction`` ensures that the transaction will be committed
  628:         at-most-once on the server.
  629: 
  630:         The ``callback`` should not attempt to start new transactions, but
  631:         should simply run operations meant to be contained within a
  632:         transaction. The ``callback`` should also not commit the transaction;
  633:         this is handled automatically by ``with_transaction``. If the
  634:         ``callback`` does commit or abort the transaction without error,
  635:         however, ``with_transaction`` will return without taking further
  636:         action.
  637: 
  638:         :class:`ClientSession` instances are **not thread-safe or fork-safe**.
  639:         Consequently, the ``callback`` must not attempt to execute multiple
  640:         operations concurrently.
  641: 
  642:         When ``callback`` raises an exception, ``with_transaction``
  643:         automatically aborts the current transaction. When ``callback`` or
  644:         :meth:`~ClientSession.commit_transaction` raises an exception that
  645:         includes the ``"TransientTransactionError"`` error label,
  646:         ``with_transaction`` starts a new transaction and re-executes
  647:         the ``callback``.
  648: 
  649:         When :meth:`~ClientSession.commit_transaction` raises an exception with
  650:         the ``"UnknownTransactionCommitResult"`` error label,
  651:         ``with_transaction`` retries the commit until the result of the
  652:         transaction is known.
  653: 
  654:         This method will cease retrying after 120 seconds has elapsed. This
  655:         timeout is not configurable and any exception raised by the
  656:         ``callback`` or by :meth:`ClientSession.commit_transaction` after the
  657:         timeout is reached will be re-raised. Applications that desire a
  658:         different timeout duration should not use this method.
  659: 
  660:         :param callback: The callable ``callback`` to run inside a transaction.
  661:             The callable must accept a single argument, this session. Note,
  662:             under certain error conditions the callback may be run multiple
  663:             times.
  664:         :param read_concern: The
  665:             :class:`~pymongo.read_concern.ReadConcern` to use for this
  666:             transaction.
  667:         :param write_concern: The
  668:             :class:`~pymongo.write_concern.WriteConcern` to use for this
  669:             transaction.
  670:         :param read_preference: The read preference to use for this
  671:             transaction. If ``None`` (the default) the :attr:`read_preference`
  672:             of this :class:`Database` is used. See
  673:             :mod:`~pymongo.read_preferences` for options.
  674: 
  675:         :return: The return value of the ``callback``.
  676: 
  677:         .. versionadded:: 3.9
  678:         """
  679:         start_time = time.monotonic()
  680:         while True:
  681:             self.start_transaction(read_concern, write_concern, read_preference, max_commit_time_ms)
  682:             try:
  683:                 ret = callback(self)
  684:             except Exception as exc:
  685:                 if self.in_transaction:
  686:                     self.abort_transaction()
  687:                 if (
  688:                     isinstance(exc, PyMongoError)
  689:                     and exc.has_error_label("TransientTransactionError")
  690:                     and _within_time_limit(start_time)
  691:                 ):
  692:                     # Retry the entire transaction.
  693:                     continue
  694:                 raise
  695: 
  696:             if not self.in_transaction:
  697:                 # Assume callback intentionally ended the transaction.
  698:                 return ret
  699: 
  700:             while True:
  701:                 try:
  702:                     self.commit_transaction()
  703:                 except PyMongoError as exc:
  704:                     if (
  705:                         exc.has_error_label("UnknownTransactionCommitResult")
  706:                         and _within_time_limit(start_time)
  707:                         and not _max_time_expired_error(exc)
  708:                     ):
  709:                         # Retry the commit.
  710:                         continue
  711: 
  712:                     if exc.has_error_label("TransientTransactionError") and _within_time_limit(
  713:                         start_time
  714:                     ):
  715:                         # Retry the entire transaction.
  716:                         break
  717:                     raise
  718: 
  719:                 # Commit succeeded.
  720:                 return ret
  721: 
  722:     def start_transaction(
  723:         self,
  724:         read_concern: Optional[ReadConcern] = None,
  725:         write_concern: Optional[WriteConcern] = None,
  726:         read_preference: Optional[_ServerMode] = None,
  727:         max_commit_time_ms: Optional[int] = None,
  728:     ) -> ContextManager:
  729:         """Start a multi-statement transaction.
  730: 
  731:         Takes the same arguments as :class:`TransactionOptions`.
  732: 
  733:         .. versionchanged:: 3.9
  734:            Added the ``max_commit_time_ms`` option.
  735: 
  736:         .. versionadded:: 3.7
  737:         """
  738:         self._check_ended()
  739: 
  740:         if self.options.snapshot:
  741:             raise InvalidOperation("Transactions are not supported in snapshot sessions")
  742: 
  743:         if self.in_transaction:
  744:             raise InvalidOperation("Transaction already in progress")
  745: 
  746:         read_concern = self._inherit_option("read_concern", read_concern)
  747:         write_concern = self._inherit_option("write_concern", write_concern)
  748:         read_preference = self._inherit_option("read_preference", read_preference)
  749:         if max_commit_time_ms is None:
  750:             opts = self.options.default_transaction_options
  751:             if opts:
  752:                 max_commit_time_ms = opts.max_commit_time_ms
  753: 
  754:         self._transaction.opts = TransactionOptions(
  755:             read_concern, write_concern, read_preference, max_commit_time_ms
  756:         )
  757:         self._transaction.reset()
  758:         self._transaction.state = _TxnState.STARTING
  759:         self._start_retryable_write()
  760:         return _TransactionContext(self)
  761: 
  762:     def commit_transaction(self) -> None:
  763:         """Commit a multi-statement transaction.
  764: 
  765:         .. versionadded:: 3.7
  766:         """
  767:         self._check_ended()
  768:         state = self._transaction.state
  769:         if state is _TxnState.NONE:
  770:             raise InvalidOperation("No transaction started")
  771:         elif state in (_TxnState.STARTING, _TxnState.COMMITTED_EMPTY):
  772:             # Server transaction was never started, no need to send a command.
  773:             self._transaction.state = _TxnState.COMMITTED_EMPTY
  774:             return
  775:         elif state is _TxnState.ABORTED:
  776:             raise InvalidOperation("Cannot call commitTransaction after calling abortTransaction")
  777:         elif state is _TxnState.COMMITTED:
  778:             # We're explicitly retrying the commit, move the state back to
  779:             # "in progress" so that in_transaction returns true.
  780:             self._transaction.state = _TxnState.IN_PROGRESS
  781: 
  782:         try:
  783:             self._finish_transaction_with_retry("commitTransaction")
  784:         except ConnectionFailure as exc:
  785:             # We do not know if the commit was successfully applied on the
  786:             # server or if it satisfied the provided write concern, set the
  787:             # unknown commit error label.
  788:             exc._remove_error_label("TransientTransactionError")
  789:             _reraise_with_unknown_commit(exc)
  790:         except WTimeoutError as exc:
  791:             # We do not know if the commit has satisfied the provided write
  792:             # concern, add the unknown commit error label.
  793:             _reraise_with_unknown_commit(exc)
  794:         except OperationFailure as exc:
  795:             if exc.code not in _UNKNOWN_COMMIT_ERROR_CODES:
  796:                 # The server reports errorLabels in the case.
  797:                 raise
  798:             # We do not know if the commit was successfully applied on the
  799:             # server or if it satisfied the provided write concern, set the
  800:             # unknown commit error label.
  801:             _reraise_with_unknown_commit(exc)
  802:         finally:
  803:             self._transaction.state = _TxnState.COMMITTED
  804: 
  805:     def abort_transaction(self) -> None:
  806:         """Abort a multi-statement transaction.
  807: 
  808:         .. versionadded:: 3.7
  809:         """
  810:         self._check_ended()
  811: 
  812:         state = self._transaction.state
  813:         if state is _TxnState.NONE:
  814:             raise InvalidOperation("No transaction started")
  815:         elif state is _TxnState.STARTING:
  816:             # Server transaction was never started, no need to send a command.
  817:             self._transaction.state = _TxnState.ABORTED
  818:             return
  819:         elif state is _TxnState.ABORTED:
  820:             raise InvalidOperation("Cannot call abortTransaction twice")
  821:         elif state in (_TxnState.COMMITTED, _TxnState.COMMITTED_EMPTY):
  822:             raise InvalidOperation("Cannot call abortTransaction after calling commitTransaction")
  823: 
  824:         try:
  825:             self._finish_transaction_with_retry("abortTransaction")
  826:         except (OperationFailure, ConnectionFailure):
  827:             # The transactions spec says to ignore abortTransaction errors.
  828:             pass
  829:         finally:
  830:             self._transaction.state = _TxnState.ABORTED
  831:             self._unpin()
  832: 
  833:     def _finish_transaction_with_retry(self, command_name: str) -> dict[str, Any]:
  834:         """Run commit or abort with one retry after any retryable error.
  835: 
  836:         :param command_name: Either "commitTransaction" or "abortTransaction".
  837:         """
  838: 
  839:         def func(
  840:             _session: Optional[ClientSession], conn: Connection, _retryable: bool
  841:         ) -> dict[str, Any]:
  842:             return self._finish_transaction(conn, command_name)
  843: 
  844:         return self._client._retry_internal(func, self, None, retryable=True, operation=_Op.ABORT)
  845: 
  846:     def _finish_transaction(self, conn: Connection, command_name: str) -> dict[str, Any]:
  847:         self._transaction.attempt += 1
  848:         opts = self._transaction.opts
  849:         assert opts
  850:         wc = opts.write_concern
  851:         cmd = {command_name: 1}
  852:         if command_name == "commitTransaction":
  853:             if opts.max_commit_time_ms and _csot.get_timeout() is None:
  854:                 cmd["maxTimeMS"] = opts.max_commit_time_ms
  855: 
  856:             # Transaction spec says that after the initial commit attempt,
  857:             # subsequent commitTransaction commands should be upgraded to use
  858:             # w:"majority" and set a default value of 10 seconds for wtimeout.
  859:             if self._transaction.attempt > 1:
  860:                 assert wc
  861:                 wc_doc = wc.document
  862:                 wc_doc["w"] = "majority"
  863:                 wc_doc.setdefault("wtimeout", 10000)
  864:                 wc = WriteConcern(**wc_doc)
  865: 
  866:         if self._transaction.recovery_token:
  867:             cmd["recoveryToken"] = self._transaction.recovery_token
  868: 
  869:         return self._client.admin._command(
  870:             conn, cmd, session=self, write_concern=wc, parse_write_concern_error=True
  871:         )
  872: 
  873:     def _advance_cluster_time(self, cluster_time: Optional[Mapping[str, Any]]) -> None:
  874:         """Internal cluster time helper."""
  875:         if self._cluster_time is None:
  876:             self._cluster_time = cluster_time
  877:         elif cluster_time is not None:
  878:             if cluster_time["clusterTime"] > self._cluster_time["clusterTime"]:
  879:                 self._cluster_time = cluster_time
  880: 
  881:     def advance_cluster_time(self, cluster_time: Mapping[str, Any]) -> None:
  882:         """Update the cluster time for this session.
  883: 
  884:         :param cluster_time: The
  885:             :data:`~pymongo.client_session.ClientSession.cluster_time` from
  886:             another `ClientSession` instance.
  887:         """
  888:         if not isinstance(cluster_time, _Mapping):
  889:             raise TypeError("cluster_time must be a subclass of collections.Mapping")
  890:         if not isinstance(cluster_time.get("clusterTime"), Timestamp):
  891:             raise ValueError("Invalid cluster_time")
  892:         self._advance_cluster_time(cluster_time)
  893: 
  894:     def _advance_operation_time(self, operation_time: Optional[Timestamp]) -> None:
  895:         """Internal operation time helper."""
  896:         if self._operation_time is None:
  897:             self._operation_time = operation_time
  898:         elif operation_time is not None:
  899:             if operation_time > self._operation_time:
  900:                 self._operation_time = operation_time
  901: 
  902:     def advance_operation_time(self, operation_time: Timestamp) -> None:
  903:         """Update the operation time for this session.
  904: 
  905:         :param operation_time: The
  906:             :data:`~pymongo.client_session.ClientSession.operation_time` from
  907:             another `ClientSession` instance.
  908:         """
  909:         if not isinstance(operation_time, Timestamp):
  910:             raise TypeError("operation_time must be an instance of bson.timestamp.Timestamp")
  911:         self._advance_operation_time(operation_time)
  912: 
  913:     def _process_response(self, reply: Mapping[str, Any]) -> None:
  914:         """Process a response to a command that was run with this session."""
  915:         self._advance_cluster_time(reply.get("$clusterTime"))
  916:         self._advance_operation_time(reply.get("operationTime"))
  917:         if self._options.snapshot and self._snapshot_time is None:
  918:             if "cursor" in reply:
  919:                 ct = reply["cursor"].get("atClusterTime")
  920:             else:
  921:                 ct = reply.get("atClusterTime")
  922:             self._snapshot_time = ct
  923:         if self.in_transaction and self._transaction.sharded:
  924:             recovery_token = reply.get("recoveryToken")
  925:             if recovery_token:
  926:                 self._transaction.recovery_token = recovery_token
  927: 
  928:     @property
  929:     def has_ended(self) -> bool:
  930:         """True if this session is finished."""
  931:         return self._server_session is None
  932: 
  933:     @property
  934:     def in_transaction(self) -> bool:
  935:         """True if this session has an active multi-statement transaction.
  936: 
  937:         .. versionadded:: 3.10
  938:         """
  939:         return self._transaction.active()
  940: 
  941:     @property
  942:     def _starting_transaction(self) -> bool:
  943:         """True if this session is starting a multi-statement transaction."""
  944:         return self._transaction.starting()
  945: 
  946:     @property
  947:     def _pinned_address(self) -> Optional[_Address]:
  948:         """The mongos address this transaction was created on."""
  949:         if self._transaction.active():
  950:             return self._transaction.pinned_address
  951:         return None
  952: 
  953:     @property
  954:     def _pinned_connection(self) -> Optional[Connection]:
  955:         """The connection this transaction was started on."""
  956:         return self._transaction.pinned_conn
  957: 
  958:     def _pin(self, server: Server, conn: Connection) -> None:
  959:         """Pin this session to the given Server or to the given connection."""
  960:         self._transaction.pin(server, conn)
  961: 
  962:     def _unpin(self) -> None:
  963:         """Unpin this session from any pinned Server."""
  964:         self._transaction.unpin()
  965: 
  966:     def _txn_read_preference(self) -> Optional[_ServerMode]:
  967:         """Return read preference of this transaction or None."""
  968:         if self.in_transaction:
  969:             assert self._transaction.opts
  970:             return self._transaction.opts.read_preference
  971:         return None
  972: 
  973:     def _materialize(self, logical_session_timeout_minutes: Optional[int] = None) -> None:
  974:         if isinstance(self._server_session, _EmptyServerSession):
  975:             old = self._server_session
  976:             self._server_session = self._client._topology.get_server_session(
  977:                 logical_session_timeout_minutes
  978:             )
  979:             if old.started_retryable_write:
  980:                 self._server_session.inc_transaction_id()
  981: 
  982:     def _apply_to(
  983:         self,
  984:         command: MutableMapping[str, Any],
  985:         is_retryable: bool,
  986:         read_preference: _ServerMode,
  987:         conn: Connection,
  988:     ) -> None:
  989:         if not conn.supports_sessions:
  990:             if not self._implicit:
  991:                 raise ConfigurationError("Sessions are not supported by this MongoDB deployment")
  992:             return
  993:         self._check_ended()
  994:         self._materialize(conn.logical_session_timeout_minutes)
  995:         if self.options.snapshot:
  996:             self._update_read_concern(command, conn)
  997: 
  998:         self._server_session.last_use = time.monotonic()
  999:         command["lsid"] = self._server_session.session_id
 1000: 
 1001:         if is_retryable:
 1002:             command["txnNumber"] = self._server_session.transaction_id
 1003:             return
 1004: 
 1005:         if self.in_transaction:
 1006:             if read_preference != ReadPreference.PRIMARY:
 1007:                 raise InvalidOperation(
 1008:                     f"read preference in a transaction must be primary, not: {read_preference!r}"
 1009:                 )
 1010: 
 1011:             if self._transaction.state == _TxnState.STARTING:
 1012:                 # First command begins a new transaction.
 1013:                 self._transaction.state = _TxnState.IN_PROGRESS
 1014:                 command["startTransaction"] = True
 1015: 
 1016:                 assert self._transaction.opts
 1017:                 if self._transaction.opts.read_concern:
 1018:                     rc = self._transaction.opts.read_concern.document
 1019:                     if rc:
 1020:                         command["readConcern"] = rc
 1021:                 self._update_read_concern(command, conn)
 1022: 
 1023:             command["txnNumber"] = self._server_session.transaction_id
 1024:             command["autocommit"] = False
 1025: 
 1026:     def _start_retryable_write(self) -> None:
 1027:         self._check_ended()
 1028:         self._server_session.inc_transaction_id()
 1029: 
 1030:     def _update_read_concern(self, cmd: MutableMapping[str, Any], conn: Connection) -> None:
 1031:         if self.options.causal_consistency and self.operation_time is not None:
 1032:             cmd.setdefault("readConcern", {})["afterClusterTime"] = self.operation_time
 1033:         if self.options.snapshot:
 1034:             if conn.max_wire_version < 13:
 1035:                 raise ConfigurationError("Snapshot reads require MongoDB 5.0 or later")
 1036:             rc = cmd.setdefault("readConcern", {})
 1037:             rc["level"] = "snapshot"
 1038:             if self._snapshot_time is not None:
 1039:                 rc["atClusterTime"] = self._snapshot_time
 1040: 
 1041:     def __copy__(self) -> NoReturn:
 1042:         raise TypeError("A ClientSession cannot be copied, create a new session instead")
 1043: 
 1044: 
 1045: class _EmptyServerSession:
 1046:     __slots__ = "dirty", "started_retryable_write"
 1047: 
 1048:     def __init__(self) -> None:
 1049:         self.dirty = False
 1050:         self.started_retryable_write = False
 1051: 
 1052:     def mark_dirty(self) -> None:
 1053:         self.dirty = True
 1054: 
 1055:     def inc_transaction_id(self) -> None:
 1056:         self.started_retryable_write = True
 1057: 
 1058: 
 1059: class _ServerSession:
 1060:     def __init__(self, generation: int):
 1061:         # Ensure id is type 4, regardless of CodecOptions.uuid_representation.
 1062:         self.session_id = {"id": Binary(uuid.uuid4().bytes, 4)}
 1063:         self.last_use = time.monotonic()
 1064:         self._transaction_id = 0
 1065:         self.dirty = False
 1066:         self.generation = generation
 1067: 
 1068:     def mark_dirty(self) -> None:
 1069:         """Mark this session as dirty.
 1070: 
 1071:         A server session is marked dirty when a command fails with a network
 1072:         error. Dirty sessions are later discarded from the server session pool.
 1073:         """
 1074:         self.dirty = True
 1075: 
 1076:     def timed_out(self, session_timeout_minutes: Optional[int]) -> bool:
 1077:         if session_timeout_minutes is None:
 1078:             return False
 1079: 
 1080:         idle_seconds = time.monotonic() - self.last_use
 1081: 
 1082:         # Timed out if we have less than a minute to live.
 1083:         return idle_seconds > (session_timeout_minutes - 1) * 60
 1084: 
 1085:     @property
 1086:     def transaction_id(self) -> Int64:
 1087:         """Positive 64-bit integer."""
 1088:         return Int64(self._transaction_id)
 1089: 
 1090:     def inc_transaction_id(self) -> None:
 1091:         self._transaction_id += 1
 1092: 
 1093: 
 1094: class _ServerSessionPool(collections.deque):
 1095:     """Pool of _ServerSession objects.
 1096: 
 1097:     This class is thread-safe.
 1098:     """
 1099: 
 1100:     def __init__(self, *args: Any, **kwargs: Any):
 1101:         super().__init__(*args, **kwargs)
 1102:         self.generation = 0
 1103: 
 1104:     def reset(self) -> None:
 1105:         self.generation += 1
 1106:         self.clear()
 1107: 
 1108:     def pop_all(self) -> list[_ServerSession]:
 1109:         ids = []
 1110:         while True:
 1111:             try:
 1112:                 ids.append(self.pop().session_id)
 1113:             except IndexError:
 1114:                 break
 1115:         return ids
 1116: 
 1117:     def get_server_session(self, session_timeout_minutes: Optional[int]) -> _ServerSession:
 1118:         # Although the Driver Sessions Spec says we only clear stale sessions
 1119:         # in return_server_session, PyMongo can't take a lock when returning
 1120:         # sessions from a __del__ method (like in Cursor.__die), so it can't
 1121:         # clear stale sessions there. In case many sessions were returned via
 1122:         # __del__, check for stale sessions here too.
 1123:         self._clear_stale(session_timeout_minutes)
 1124: 
 1125:         # The most recently used sessions are on the left.
 1126:         while True:
 1127:             try:
 1128:                 s = self.popleft()
 1129:             except IndexError:
 1130:                 break
 1131:             if not s.timed_out(session_timeout_minutes):
 1132:                 return s
 1133: 
 1134:         return _ServerSession(self.generation)
 1135: 
 1136:     def return_server_session(self, server_session: _ServerSession) -> None:
 1137:         # Discard sessions from an old pool to avoid duplicate sessions in the
 1138:         # child process after a fork.
 1139:         if server_session.generation == self.generation and not server_session.dirty:
 1140:             self.appendleft(server_session)
 1141: 
 1142:     def _clear_stale(self, session_timeout_minutes: Optional[int]) -> None:
 1143:         # Clear stale sessions. The least recently used are on the right.
 1144:         while True:
 1145:             try:
 1146:                 s = self.pop()
 1147:             except IndexError:
 1148:                 break
 1149:             if not s.timed_out(session_timeout_minutes):
 1150:                 self.append(s)
 1151:                 # The remaining sessions also haven't timed out.
 1152:                 break
