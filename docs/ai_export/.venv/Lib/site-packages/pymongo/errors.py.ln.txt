    1: # Copyright 2009-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Exceptions raised by PyMongo."""
   16: from __future__ import annotations
   17: 
   18: from ssl import SSLCertVerificationError as _CertificateError  # noqa: F401
   19: from typing import TYPE_CHECKING, Any, Iterable, Mapping, Optional, Sequence, Union
   20: 
   21: from bson.errors import InvalidDocument
   22: 
   23: if TYPE_CHECKING:
   24:     from pymongo.typings import _DocumentOut
   25: 
   26: 
   27: class PyMongoError(Exception):
   28:     """Base class for all PyMongo exceptions."""
   29: 
   30:     def __init__(self, message: str = "", error_labels: Optional[Iterable[str]] = None) -> None:
   31:         super().__init__(message)
   32:         self._message = message
   33:         self._error_labels = set(error_labels or [])
   34: 
   35:     def has_error_label(self, label: str) -> bool:
   36:         """Return True if this error contains the given label.
   37: 
   38:         .. versionadded:: 3.7
   39:         """
   40:         return label in self._error_labels
   41: 
   42:     def _add_error_label(self, label: str) -> None:
   43:         """Add the given label to this error."""
   44:         self._error_labels.add(label)
   45: 
   46:     def _remove_error_label(self, label: str) -> None:
   47:         """Remove the given label from this error."""
   48:         self._error_labels.discard(label)
   49: 
   50:     @property
   51:     def timeout(self) -> bool:
   52:         """True if this error was caused by a timeout.
   53: 
   54:         .. versionadded:: 4.2
   55:         """
   56:         return False
   57: 
   58: 
   59: class ProtocolError(PyMongoError):
   60:     """Raised for failures related to the wire protocol."""
   61: 
   62: 
   63: class ConnectionFailure(PyMongoError):
   64:     """Raised when a connection to the database cannot be made or is lost."""
   65: 
   66: 
   67: class WaitQueueTimeoutError(ConnectionFailure):
   68:     """Raised when an operation times out waiting to checkout a connection from the pool.
   69: 
   70:     Subclass of :exc:`~pymongo.errors.ConnectionFailure`.
   71: 
   72:     .. versionadded:: 4.2
   73:     """
   74: 
   75:     @property
   76:     def timeout(self) -> bool:
   77:         return True
   78: 
   79: 
   80: class AutoReconnect(ConnectionFailure):
   81:     """Raised when a connection to the database is lost and an attempt to
   82:     auto-reconnect will be made.
   83: 
   84:     In order to auto-reconnect you must handle this exception, recognizing that
   85:     the operation which caused it has not necessarily succeeded. Future
   86:     operations will attempt to open a new connection to the database (and
   87:     will continue to raise this exception until the first successful
   88:     connection is made).
   89: 
   90:     Subclass of :exc:`~pymongo.errors.ConnectionFailure`.
   91:     """
   92: 
   93:     errors: Union[Mapping[str, Any], Sequence[Any]]
   94:     details: Union[Mapping[str, Any], Sequence[Any]]
   95: 
   96:     def __init__(
   97:         self, message: str = "", errors: Optional[Union[Mapping[str, Any], Sequence[Any]]] = None
   98:     ) -> None:
   99:         error_labels = None
  100:         if errors is not None:
  101:             if isinstance(errors, dict):
  102:                 error_labels = errors.get("errorLabels")
  103:         super().__init__(message, error_labels)
  104:         self.errors = self.details = errors or []
  105: 
  106: 
  107: class NetworkTimeout(AutoReconnect):
  108:     """An operation on an open connection exceeded socketTimeoutMS.
  109: 
  110:     The remaining connections in the pool stay open. In the case of a write
  111:     operation, you cannot know whether it succeeded or failed.
  112: 
  113:     Subclass of :exc:`~pymongo.errors.AutoReconnect`.
  114:     """
  115: 
  116:     @property
  117:     def timeout(self) -> bool:
  118:         return True
  119: 
  120: 
  121: def _format_detailed_error(
  122:     message: str, details: Optional[Union[Mapping[str, Any], list[Any]]]
  123: ) -> str:
  124:     if details is not None:
  125:         message = f"{message}, full error: {details}"
  126:     return message
  127: 
  128: 
  129: class NotPrimaryError(AutoReconnect):
  130:     """The server responded "not primary" or "node is recovering".
  131: 
  132:     These errors result from a query, write, or command. The operation failed
  133:     because the client thought it was using the primary but the primary has
  134:     stepped down, or the client thought it was using a healthy secondary but
  135:     the secondary is stale and trying to recover.
  136: 
  137:     The client launches a refresh operation on a background thread, to update
  138:     its view of the server as soon as possible after throwing this exception.
  139: 
  140:     Subclass of :exc:`~pymongo.errors.AutoReconnect`.
  141: 
  142:     .. versionadded:: 3.12
  143:     """
  144: 
  145:     def __init__(
  146:         self, message: str = "", errors: Optional[Union[Mapping[str, Any], list[Any]]] = None
  147:     ) -> None:
  148:         super().__init__(_format_detailed_error(message, errors), errors=errors)
  149: 
  150: 
  151: class ServerSelectionTimeoutError(AutoReconnect):
  152:     """Thrown when no MongoDB server is available for an operation
  153: 
  154:     If there is no suitable server for an operation PyMongo tries for
  155:     ``serverSelectionTimeoutMS`` (default 30 seconds) to find one, then
  156:     throws this exception. For example, it is thrown after attempting an
  157:     operation when PyMongo cannot connect to any server, or if you attempt
  158:     an insert into a replica set that has no primary and does not elect one
  159:     within the timeout window, or if you attempt to query with a Read
  160:     Preference that the replica set cannot satisfy.
  161:     """
  162: 
  163:     @property
  164:     def timeout(self) -> bool:
  165:         return True
  166: 
  167: 
  168: class ConfigurationError(PyMongoError):
  169:     """Raised when something is incorrectly configured."""
  170: 
  171: 
  172: class OperationFailure(PyMongoError):
  173:     """Raised when a database operation fails.
  174: 
  175:     .. versionadded:: 2.7
  176:        The :attr:`details` attribute.
  177:     """
  178: 
  179:     def __init__(
  180:         self,
  181:         error: str,
  182:         code: Optional[int] = None,
  183:         details: Optional[Mapping[str, Any]] = None,
  184:         max_wire_version: Optional[int] = None,
  185:     ) -> None:
  186:         error_labels = None
  187:         if details is not None:
  188:             error_labels = details.get("errorLabels")
  189:         super().__init__(_format_detailed_error(error, details), error_labels=error_labels)
  190:         self.__code = code
  191:         self.__details = details
  192:         self.__max_wire_version = max_wire_version
  193: 
  194:     @property
  195:     def _max_wire_version(self) -> Optional[int]:
  196:         return self.__max_wire_version
  197: 
  198:     @property
  199:     def code(self) -> Optional[int]:
  200:         """The error code returned by the server, if any."""
  201:         return self.__code
  202: 
  203:     @property
  204:     def details(self) -> Optional[Mapping[str, Any]]:
  205:         """The complete error document returned by the server.
  206: 
  207:         Depending on the error that occurred, the error document
  208:         may include useful information beyond just the error
  209:         message. When connected to a mongos the error document
  210:         may contain one or more subdocuments if errors occurred
  211:         on multiple shards.
  212:         """
  213:         return self.__details
  214: 
  215:     @property
  216:     def timeout(self) -> bool:
  217:         return self.__code in (50,)
  218: 
  219: 
  220: class CursorNotFound(OperationFailure):
  221:     """Raised while iterating query results if the cursor is
  222:     invalidated on the server.
  223: 
  224:     .. versionadded:: 2.7
  225:     """
  226: 
  227: 
  228: class ExecutionTimeout(OperationFailure):
  229:     """Raised when a database operation times out, exceeding the $maxTimeMS
  230:     set in the query or command option.
  231: 
  232:     .. note:: Requires server version **>= 2.6.0**
  233: 
  234:     .. versionadded:: 2.7
  235:     """
  236: 
  237:     @property
  238:     def timeout(self) -> bool:
  239:         return True
  240: 
  241: 
  242: class WriteConcernError(OperationFailure):
  243:     """Base exception type for errors raised due to write concern.
  244: 
  245:     .. versionadded:: 3.0
  246:     """
  247: 
  248: 
  249: class WriteError(OperationFailure):
  250:     """Base exception type for errors raised during write operations.
  251: 
  252:     .. versionadded:: 3.0
  253:     """
  254: 
  255: 
  256: class WTimeoutError(WriteConcernError):
  257:     """Raised when a database operation times out (i.e. wtimeout expires)
  258:     before replication completes.
  259: 
  260:     With newer versions of MongoDB the `details` attribute may include
  261:     write concern fields like 'n', 'updatedExisting', or 'writtenTo'.
  262: 
  263:     .. versionadded:: 2.7
  264:     """
  265: 
  266:     @property
  267:     def timeout(self) -> bool:
  268:         return True
  269: 
  270: 
  271: class DuplicateKeyError(WriteError):
  272:     """Raised when an insert or update fails due to a duplicate key error."""
  273: 
  274: 
  275: def _wtimeout_error(error: Any) -> bool:
  276:     """Return True if this writeConcernError doc is a caused by a timeout."""
  277:     return error.get("code") == 50 or ("errInfo" in error and error["errInfo"].get("wtimeout"))
  278: 
  279: 
  280: class BulkWriteError(OperationFailure):
  281:     """Exception class for bulk write errors.
  282: 
  283:     .. versionadded:: 2.7
  284:     """
  285: 
  286:     details: _DocumentOut
  287: 
  288:     def __init__(self, results: _DocumentOut) -> None:
  289:         super().__init__("batch op errors occurred", 65, results)
  290: 
  291:     def __reduce__(self) -> tuple[Any, Any]:
  292:         return self.__class__, (self.details,)
  293: 
  294:     @property
  295:     def timeout(self) -> bool:
  296:         # Check the last writeConcernError and last writeError to determine if this
  297:         # BulkWriteError was caused by a timeout.
  298:         wces = self.details.get("writeConcernErrors", [])
  299:         if wces and _wtimeout_error(wces[-1]):
  300:             return True
  301: 
  302:         werrs = self.details.get("writeErrors", [])
  303:         if werrs and werrs[-1].get("code") == 50:
  304:             return True
  305:         return False
  306: 
  307: 
  308: class InvalidOperation(PyMongoError):
  309:     """Raised when a client attempts to perform an invalid operation."""
  310: 
  311: 
  312: class InvalidName(PyMongoError):
  313:     """Raised when an invalid name is used."""
  314: 
  315: 
  316: class CollectionInvalid(PyMongoError):
  317:     """Raised when collection validation fails."""
  318: 
  319: 
  320: class InvalidURI(ConfigurationError):
  321:     """Raised when trying to parse an invalid mongodb URI."""
  322: 
  323: 
  324: class DocumentTooLarge(InvalidDocument):
  325:     """Raised when an encoded document is too large for the connected server."""
  326: 
  327: 
  328: class EncryptionError(PyMongoError):
  329:     """Raised when encryption or decryption fails.
  330: 
  331:     This error always wraps another exception which can be retrieved via the
  332:     :attr:`cause` property.
  333: 
  334:     .. versionadded:: 3.9
  335:     """
  336: 
  337:     def __init__(self, cause: Exception) -> None:
  338:         super().__init__(str(cause))
  339:         self.__cause = cause
  340: 
  341:     @property
  342:     def cause(self) -> Exception:
  343:         """The exception that caused this encryption or decryption error."""
  344:         return self.__cause
  345: 
  346:     @property
  347:     def timeout(self) -> bool:
  348:         if isinstance(self.__cause, PyMongoError):
  349:             return self.__cause.timeout
  350:         return False
  351: 
  352: 
  353: class EncryptedCollectionError(EncryptionError):
  354:     """Raised when creating a collection with encrypted_fields fails.
  355: 
  356:     .. versionadded:: 4.4
  357:     """
  358: 
  359:     def __init__(self, cause: Exception, encrypted_fields: Mapping[str, Any]) -> None:
  360:         super().__init__(cause)
  361:         self.__encrypted_fields = encrypted_fields
  362: 
  363:     @property
  364:     def encrypted_fields(self) -> Mapping[str, Any]:
  365:         """The encrypted_fields document that allows inferring which data keys are *known* to be created.
  366: 
  367:         Note that the returned document is not guaranteed to contain information about *all* of the data keys that
  368:         were created, for example in the case of an indefinite error like a timeout. Use the `cause` property to
  369:         determine whether a definite or indefinite error caused this error, and only rely on the accuracy of the
  370:         encrypted_fields if the error is definite.
  371:         """
  372:         return self.__encrypted_fields
  373: 
  374: 
  375: class _OperationCancelled(AutoReconnect):
  376:     """Internal error raised when a socket operation is cancelled."""
