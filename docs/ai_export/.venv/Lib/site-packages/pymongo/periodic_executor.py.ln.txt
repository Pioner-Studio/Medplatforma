    1: # Copyright 2014-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Run a target function on a background thread."""
   16: 
   17: from __future__ import annotations
   18: 
   19: import sys
   20: import threading
   21: import time
   22: import weakref
   23: from typing import Any, Callable, Optional
   24: 
   25: from pymongo.lock import _create_lock
   26: 
   27: 
   28: class PeriodicExecutor:
   29:     def __init__(
   30:         self,
   31:         interval: float,
   32:         min_interval: float,
   33:         target: Callable[[], bool],
   34:         name: Optional[str] = None,
   35:     ):
   36:         """ "Run a target function periodically on a background thread.
   37: 
   38:         If the target's return value is false, the executor stops.
   39: 
   40:         :param interval: Seconds between calls to `target`.
   41:         :param min_interval: Minimum seconds between calls if `wake` is
   42:             called very often.
   43:         :param target: A function.
   44:         :param name: A name to give the underlying thread.
   45:         """
   46:         # threading.Event and its internal condition variable are expensive
   47:         # in Python 2, see PYTHON-983. Use a boolean to know when to wake.
   48:         # The executor's design is constrained by several Python issues, see
   49:         # "periodic_executor.rst" in this repository.
   50:         self._event = False
   51:         self._interval = interval
   52:         self._min_interval = min_interval
   53:         self._target = target
   54:         self._stopped = False
   55:         self._thread: Optional[threading.Thread] = None
   56:         self._name = name
   57:         self._skip_sleep = False
   58:         self._thread_will_exit = False
   59:         self._lock = _create_lock()
   60: 
   61:     def __repr__(self) -> str:
   62:         return f"<{self.__class__.__name__}(name={self._name}) object at 0x{id(self):x}>"
   63: 
   64:     def open(self) -> None:
   65:         """Start. Multiple calls have no effect.
   66: 
   67:         Not safe to call from multiple threads at once.
   68:         """
   69:         with self._lock:
   70:             if self._thread_will_exit:
   71:                 # If the background thread has read self._stopped as True
   72:                 # there is a chance that it has not yet exited. The call to
   73:                 # join should not block indefinitely because there is no
   74:                 # other work done outside the while loop in self._run.
   75:                 try:
   76:                     assert self._thread is not None
   77:                     self._thread.join()
   78:                 except ReferenceError:
   79:                     # Thread terminated.
   80:                     pass
   81:             self._thread_will_exit = False
   82:             self._stopped = False
   83:         started: Any = False
   84:         try:
   85:             started = self._thread and self._thread.is_alive()
   86:         except ReferenceError:
   87:             # Thread terminated.
   88:             pass
   89: 
   90:         if not started:
   91:             thread = threading.Thread(target=self._run, name=self._name)
   92:             thread.daemon = True
   93:             self._thread = weakref.proxy(thread)
   94:             _register_executor(self)
   95:             # Mitigation to RuntimeError firing when thread starts on shutdown
   96:             # https://github.com/python/cpython/issues/114570
   97:             try:
   98:                 thread.start()
   99:             except RuntimeError as e:
  100:                 if "interpreter shutdown" in str(e) or sys.is_finalizing():
  101:                     self._thread = None
  102:                     return
  103:                 raise
  104: 
  105:     def close(self, dummy: Any = None) -> None:
  106:         """Stop. To restart, call open().
  107: 
  108:         The dummy parameter allows an executor's close method to be a weakref
  109:         callback; see monitor.py.
  110:         """
  111:         self._stopped = True
  112: 
  113:     def join(self, timeout: Optional[int] = None) -> None:
  114:         if self._thread is not None:
  115:             try:
  116:                 self._thread.join(timeout)
  117:             except (ReferenceError, RuntimeError):
  118:                 # Thread already terminated, or not yet started.
  119:                 pass
  120: 
  121:     def wake(self) -> None:
  122:         """Execute the target function soon."""
  123:         self._event = True
  124: 
  125:     def update_interval(self, new_interval: int) -> None:
  126:         self._interval = new_interval
  127: 
  128:     def skip_sleep(self) -> None:
  129:         self._skip_sleep = True
  130: 
  131:     def __should_stop(self) -> bool:
  132:         with self._lock:
  133:             if self._stopped:
  134:                 self._thread_will_exit = True
  135:                 return True
  136:             return False
  137: 
  138:     def _run(self) -> None:
  139:         while not self.__should_stop():
  140:             try:
  141:                 if not self._target():
  142:                     self._stopped = True
  143:                     break
  144:             except BaseException:
  145:                 with self._lock:
  146:                     self._stopped = True
  147:                     self._thread_will_exit = True
  148: 
  149:                 raise
  150: 
  151:             if self._skip_sleep:
  152:                 self._skip_sleep = False
  153:             else:
  154:                 deadline = time.monotonic() + self._interval
  155:                 while not self._stopped and time.monotonic() < deadline:
  156:                     time.sleep(self._min_interval)
  157:                     if self._event:
  158:                         break  # Early wake.
  159: 
  160:             self._event = False
  161: 
  162: 
  163: # _EXECUTORS has a weakref to each running PeriodicExecutor. Once started,
  164: # an executor is kept alive by a strong reference from its thread and perhaps
  165: # from other objects. When the thread dies and all other referrers are freed,
  166: # the executor is freed and removed from _EXECUTORS. If any threads are
  167: # running when the interpreter begins to shut down, we try to halt and join
  168: # them to avoid spurious errors.
  169: _EXECUTORS = set()
  170: 
  171: 
  172: def _register_executor(executor: PeriodicExecutor) -> None:
  173:     ref = weakref.ref(executor, _on_executor_deleted)
  174:     _EXECUTORS.add(ref)
  175: 
  176: 
  177: def _on_executor_deleted(ref: weakref.ReferenceType[PeriodicExecutor]) -> None:
  178:     _EXECUTORS.remove(ref)
  179: 
  180: 
  181: def _shutdown_executors() -> None:
  182:     if _EXECUTORS is None:
  183:         return
  184: 
  185:     # Copy the set. Stopping threads has the side effect of removing executors.
  186:     executors = list(_EXECUTORS)
  187: 
  188:     # First signal all executors to close...
  189:     for ref in executors:
  190:         executor = ref()
  191:         if executor:
  192:             executor.close()
  193: 
  194:     # ...then try to join them.
  195:     for ref in executors:
  196:         executor = ref()
  197:         if executor:
  198:             executor.join(1)
  199: 
  200:     executor = None
