    1: # Copyright 2022-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Internal helpers for CSOT."""
   16: 
   17: from __future__ import annotations
   18: 
   19: import functools
   20: import time
   21: from collections import deque
   22: from contextlib import AbstractContextManager
   23: from contextvars import ContextVar, Token
   24: from typing import TYPE_CHECKING, Any, Callable, Deque, MutableMapping, Optional, TypeVar, cast
   25: 
   26: if TYPE_CHECKING:
   27:     from pymongo.write_concern import WriteConcern
   28: 
   29: TIMEOUT: ContextVar[Optional[float]] = ContextVar("TIMEOUT", default=None)
   30: RTT: ContextVar[float] = ContextVar("RTT", default=0.0)
   31: DEADLINE: ContextVar[float] = ContextVar("DEADLINE", default=float("inf"))
   32: 
   33: 
   34: def get_timeout() -> Optional[float]:
   35:     return TIMEOUT.get(None)
   36: 
   37: 
   38: def get_rtt() -> float:
   39:     return RTT.get()
   40: 
   41: 
   42: def get_deadline() -> float:
   43:     return DEADLINE.get()
   44: 
   45: 
   46: def set_rtt(rtt: float) -> None:
   47:     RTT.set(rtt)
   48: 
   49: 
   50: def remaining() -> Optional[float]:
   51:     if not get_timeout():
   52:         return None
   53:     return DEADLINE.get() - time.monotonic()
   54: 
   55: 
   56: def clamp_remaining(max_timeout: float) -> float:
   57:     """Return the remaining timeout clamped to a max value."""
   58:     timeout = remaining()
   59:     if timeout is None:
   60:         return max_timeout
   61:     return min(timeout, max_timeout)
   62: 
   63: 
   64: class _TimeoutContext(AbstractContextManager):
   65:     """Internal timeout context manager.
   66: 
   67:     Use :func:`pymongo.timeout` instead::
   68: 
   69:       with pymongo.timeout(0.5):
   70:           client.test.test.insert_one({})
   71:     """
   72: 
   73:     def __init__(self, timeout: Optional[float]):
   74:         self._timeout = timeout
   75:         self._tokens: Optional[tuple[Token[Optional[float]], Token[float], Token[float]]] = None
   76: 
   77:     def __enter__(self) -> _TimeoutContext:
   78:         timeout_token = TIMEOUT.set(self._timeout)
   79:         prev_deadline = DEADLINE.get()
   80:         next_deadline = time.monotonic() + self._timeout if self._timeout else float("inf")
   81:         deadline_token = DEADLINE.set(min(prev_deadline, next_deadline))
   82:         rtt_token = RTT.set(0.0)
   83:         self._tokens = (timeout_token, deadline_token, rtt_token)
   84:         return self
   85: 
   86:     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
   87:         if self._tokens:
   88:             timeout_token, deadline_token, rtt_token = self._tokens
   89:             TIMEOUT.reset(timeout_token)
   90:             DEADLINE.reset(deadline_token)
   91:             RTT.reset(rtt_token)
   92: 
   93: 
   94: # See https://mypy.readthedocs.io/en/stable/generics.html?#decorator-factories
   95: F = TypeVar("F", bound=Callable[..., Any])
   96: 
   97: 
   98: def apply(func: F) -> F:
   99:     """Apply the client's timeoutMS to this operation."""
  100: 
  101:     @functools.wraps(func)
  102:     def csot_wrapper(self: Any, *args: Any, **kwargs: Any) -> Any:
  103:         if get_timeout() is None:
  104:             timeout = self._timeout
  105:             if timeout is not None:
  106:                 with _TimeoutContext(timeout):
  107:                     return func(self, *args, **kwargs)
  108:         return func(self, *args, **kwargs)
  109: 
  110:     return cast(F, csot_wrapper)
  111: 
  112: 
  113: def apply_write_concern(
  114:     cmd: MutableMapping[str, Any], write_concern: Optional[WriteConcern]
  115: ) -> None:
  116:     """Apply the given write concern to a command."""
  117:     if not write_concern or write_concern.is_server_default:
  118:         return
  119:     wc = write_concern.document
  120:     if get_timeout() is not None:
  121:         wc.pop("wtimeout", None)
  122:     if wc:
  123:         cmd["writeConcern"] = wc
  124: 
  125: 
  126: _MAX_RTT_SAMPLES: int = 10
  127: _MIN_RTT_SAMPLES: int = 2
  128: 
  129: 
  130: class MovingMinimum:
  131:     """Tracks a minimum RTT within the last 10 RTT samples."""
  132: 
  133:     samples: Deque[float]
  134: 
  135:     def __init__(self) -> None:
  136:         self.samples = deque(maxlen=_MAX_RTT_SAMPLES)
  137: 
  138:     def add_sample(self, sample: float) -> None:
  139:         if sample < 0:
  140:             # Likely system time change while waiting for hello response
  141:             # and not using time.monotonic. Ignore it, the next one will
  142:             # probably be valid.
  143:             return
  144:         self.samples.append(sample)
  145: 
  146:     def get(self) -> float:
  147:         """Get the min, or 0.0 if there aren't enough samples yet."""
  148:         if len(self.samples) >= _MIN_RTT_SAMPLES:
  149:             return min(self.samples)
  150:         return 0.0
  151: 
  152:     def reset(self) -> None:
  153:         self.samples.clear()
