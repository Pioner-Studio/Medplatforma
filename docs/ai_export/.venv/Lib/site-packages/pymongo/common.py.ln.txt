    1: # Copyright 2011-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: 
   16: """Functions and classes common to multiple pymongo modules."""
   17: from __future__ import annotations
   18: 
   19: import datetime
   20: import warnings
   21: from collections import OrderedDict, abc
   22: from difflib import get_close_matches
   23: from typing import (
   24:     TYPE_CHECKING,
   25:     Any,
   26:     Callable,
   27:     Iterator,
   28:     Mapping,
   29:     MutableMapping,
   30:     NoReturn,
   31:     Optional,
   32:     Sequence,
   33:     Type,
   34:     Union,
   35:     overload,
   36: )
   37: from urllib.parse import unquote_plus
   38: 
   39: from bson import SON
   40: from bson.binary import UuidRepresentation
   41: from bson.codec_options import CodecOptions, DatetimeConversion, TypeRegistry
   42: from bson.raw_bson import RawBSONDocument
   43: from pymongo.compression_support import (
   44:     validate_compressors,
   45:     validate_zlib_compression_level,
   46: )
   47: from pymongo.driver_info import DriverInfo
   48: from pymongo.errors import ConfigurationError
   49: from pymongo.monitoring import _validate_event_listeners
   50: from pymongo.read_concern import ReadConcern
   51: from pymongo.read_preferences import _MONGOS_MODES, _ServerMode
   52: from pymongo.server_api import ServerApi
   53: from pymongo.write_concern import DEFAULT_WRITE_CONCERN, WriteConcern, validate_boolean
   54: 
   55: if TYPE_CHECKING:
   56:     from pymongo.client_session import ClientSession
   57: 
   58: ORDERED_TYPES: Sequence[Type] = (SON, OrderedDict)
   59: 
   60: # Defaults until we connect to a server and get updated limits.
   61: MAX_BSON_SIZE = 16 * (1024**2)
   62: MAX_MESSAGE_SIZE: int = 2 * MAX_BSON_SIZE
   63: MIN_WIRE_VERSION = 0
   64: MAX_WIRE_VERSION = 0
   65: MAX_WRITE_BATCH_SIZE = 1000
   66: 
   67: # What this version of PyMongo supports.
   68: MIN_SUPPORTED_SERVER_VERSION = "3.6"
   69: MIN_SUPPORTED_WIRE_VERSION = 6
   70: MAX_SUPPORTED_WIRE_VERSION = 21
   71: 
   72: # Frequency to call hello on servers, in seconds.
   73: HEARTBEAT_FREQUENCY = 10
   74: 
   75: # Frequency to clean up unclosed cursors, in seconds.
   76: # See MongoClient._process_kill_cursors.
   77: KILL_CURSOR_FREQUENCY = 1
   78: 
   79: # Frequency to process events queue, in seconds.
   80: EVENTS_QUEUE_FREQUENCY = 1
   81: 
   82: # How long to wait, in seconds, for a suitable server to be found before
   83: # aborting an operation. For example, if the client attempts an insert
   84: # during a replica set election, SERVER_SELECTION_TIMEOUT governs the
   85: # longest it is willing to wait for a new primary to be found.
   86: SERVER_SELECTION_TIMEOUT = 30
   87: 
   88: # Spec requires at least 500ms between hello calls.
   89: MIN_HEARTBEAT_INTERVAL = 0.5
   90: 
   91: # Spec requires at least 60s between SRV rescans.
   92: MIN_SRV_RESCAN_INTERVAL = 60
   93: 
   94: # Default connectTimeout in seconds.
   95: CONNECT_TIMEOUT = 20.0
   96: 
   97: # Default value for maxPoolSize.
   98: MAX_POOL_SIZE = 100
   99: 
  100: # Default value for minPoolSize.
  101: MIN_POOL_SIZE = 0
  102: 
  103: # The maximum number of concurrent connection creation attempts per pool.
  104: MAX_CONNECTING = 2
  105: 
  106: # Default value for maxIdleTimeMS.
  107: MAX_IDLE_TIME_MS: Optional[int] = None
  108: 
  109: # Default value for maxIdleTimeMS in seconds.
  110: MAX_IDLE_TIME_SEC: Optional[int] = None
  111: 
  112: # Default value for waitQueueTimeoutMS in seconds.
  113: WAIT_QUEUE_TIMEOUT: Optional[int] = None
  114: 
  115: # Default value for localThresholdMS.
  116: LOCAL_THRESHOLD_MS = 15
  117: 
  118: # Default value for retryWrites.
  119: RETRY_WRITES = True
  120: 
  121: # Default value for retryReads.
  122: RETRY_READS = True
  123: 
  124: # The error code returned when a command doesn't exist.
  125: COMMAND_NOT_FOUND_CODES: Sequence[int] = (59,)
  126: 
  127: # Error codes to ignore if GridFS calls createIndex on a secondary
  128: UNAUTHORIZED_CODES: Sequence[int] = (13, 16547, 16548)
  129: 
  130: # Maximum number of sessions to send in a single endSessions command.
  131: # From the driver sessions spec.
  132: _MAX_END_SESSIONS = 10000
  133: 
  134: # Default value for srvServiceName
  135: SRV_SERVICE_NAME = "mongodb"
  136: 
  137: # Default value for serverMonitoringMode
  138: SERVER_MONITORING_MODE = "auto"  # poll/stream/auto
  139: 
  140: 
  141: def partition_node(node: str) -> tuple[str, int]:
  142:     """Split a host:port string into (host, int(port)) pair."""
  143:     host = node
  144:     port = 27017
  145:     idx = node.rfind(":")
  146:     if idx != -1:
  147:         host, port = node[:idx], int(node[idx + 1 :])
  148:     if host.startswith("["):
  149:         host = host[1:-1]
  150:     return host, port
  151: 
  152: 
  153: def clean_node(node: str) -> tuple[str, int]:
  154:     """Split and normalize a node name from a hello response."""
  155:     host, port = partition_node(node)
  156: 
  157:     # Normalize hostname to lowercase, since DNS is case-insensitive:
  158:     # http://tools.ietf.org/html/rfc4343
  159:     # This prevents useless rediscovery if "foo.com" is in the seed list but
  160:     # "FOO.com" is in the hello response.
  161:     return host.lower(), port
  162: 
  163: 
  164: def raise_config_error(key: str, suggestions: Optional[list] = None) -> NoReturn:
  165:     """Raise ConfigurationError with the given key name."""
  166:     msg = f"Unknown option: {key}."
  167:     if suggestions:
  168:         msg += f" Did you mean one of ({', '.join(suggestions)}) or maybe a camelCase version of one? Refer to docstring."
  169:     raise ConfigurationError(msg)
  170: 
  171: 
  172: # Mapping of URI uuid representation options to valid subtypes.
  173: _UUID_REPRESENTATIONS = {
  174:     "unspecified": UuidRepresentation.UNSPECIFIED,
  175:     "standard": UuidRepresentation.STANDARD,
  176:     "pythonLegacy": UuidRepresentation.PYTHON_LEGACY,
  177:     "javaLegacy": UuidRepresentation.JAVA_LEGACY,
  178:     "csharpLegacy": UuidRepresentation.CSHARP_LEGACY,
  179: }
  180: 
  181: 
  182: def validate_boolean_or_string(option: str, value: Any) -> bool:
  183:     """Validates that value is True, False, 'true', or 'false'."""
  184:     if isinstance(value, str):
  185:         if value not in ("true", "false"):
  186:             raise ValueError(f"The value of {option} must be 'true' or 'false'")
  187:         return value == "true"
  188:     return validate_boolean(option, value)
  189: 
  190: 
  191: def validate_integer(option: str, value: Any) -> int:
  192:     """Validates that 'value' is an integer (or basestring representation)."""
  193:     if isinstance(value, int):
  194:         return value
  195:     elif isinstance(value, str):
  196:         try:
  197:             return int(value)
  198:         except ValueError:
  199:             raise ValueError(f"The value of {option} must be an integer") from None
  200:     raise TypeError(f"Wrong type for {option}, value must be an integer")
  201: 
  202: 
  203: def validate_positive_integer(option: str, value: Any) -> int:
  204:     """Validate that 'value' is a positive integer, which does not include 0."""
  205:     val = validate_integer(option, value)
  206:     if val <= 0:
  207:         raise ValueError(f"The value of {option} must be a positive integer")
  208:     return val
  209: 
  210: 
  211: def validate_non_negative_integer(option: str, value: Any) -> int:
  212:     """Validate that 'value' is a positive integer or 0."""
  213:     val = validate_integer(option, value)
  214:     if val < 0:
  215:         raise ValueError(f"The value of {option} must be a non negative integer")
  216:     return val
  217: 
  218: 
  219: def validate_readable(option: str, value: Any) -> Optional[str]:
  220:     """Validates that 'value' is file-like and readable."""
  221:     if value is None:
  222:         return value
  223:     # First make sure its a string py3.3 open(True, 'r') succeeds
  224:     # Used in ssl cert checking due to poor ssl module error reporting
  225:     value = validate_string(option, value)
  226:     open(value).close()
  227:     return value
  228: 
  229: 
  230: def validate_positive_integer_or_none(option: str, value: Any) -> Optional[int]:
  231:     """Validate that 'value' is a positive integer or None."""
  232:     if value is None:
  233:         return value
  234:     return validate_positive_integer(option, value)
  235: 
  236: 
  237: def validate_non_negative_integer_or_none(option: str, value: Any) -> Optional[int]:
  238:     """Validate that 'value' is a positive integer or 0 or None."""
  239:     if value is None:
  240:         return value
  241:     return validate_non_negative_integer(option, value)
  242: 
  243: 
  244: def validate_string(option: str, value: Any) -> str:
  245:     """Validates that 'value' is an instance of `str`."""
  246:     if isinstance(value, str):
  247:         return value
  248:     raise TypeError(f"Wrong type for {option}, value must be an instance of str")
  249: 
  250: 
  251: def validate_string_or_none(option: str, value: Any) -> Optional[str]:
  252:     """Validates that 'value' is an instance of `basestring` or `None`."""
  253:     if value is None:
  254:         return value
  255:     return validate_string(option, value)
  256: 
  257: 
  258: def validate_int_or_basestring(option: str, value: Any) -> Union[int, str]:
  259:     """Validates that 'value' is an integer or string."""
  260:     if isinstance(value, int):
  261:         return value
  262:     elif isinstance(value, str):
  263:         try:
  264:             return int(value)
  265:         except ValueError:
  266:             return value
  267:     raise TypeError(f"Wrong type for {option}, value must be an integer or a string")
  268: 
  269: 
  270: def validate_non_negative_int_or_basestring(option: Any, value: Any) -> Union[int, str]:
  271:     """Validates that 'value' is an integer or string."""
  272:     if isinstance(value, int):
  273:         return value
  274:     elif isinstance(value, str):
  275:         try:
  276:             val = int(value)
  277:         except ValueError:
  278:             return value
  279:         return validate_non_negative_integer(option, val)
  280:     raise TypeError(f"Wrong type for {option}, value must be an non negative integer or a string")
  281: 
  282: 
  283: def validate_positive_float(option: str, value: Any) -> float:
  284:     """Validates that 'value' is a float, or can be converted to one, and is
  285:     positive.
  286:     """
  287:     errmsg = f"{option} must be an integer or float"
  288:     try:
  289:         value = float(value)
  290:     except ValueError:
  291:         raise ValueError(errmsg) from None
  292:     except TypeError:
  293:         raise TypeError(errmsg) from None
  294: 
  295:     # float('inf') doesn't work in 2.4 or 2.5 on Windows, so just cap floats at
  296:     # one billion - this is a reasonable approximation for infinity
  297:     if not 0 < value < 1e9:
  298:         raise ValueError(f"{option} must be greater than 0 and less than one billion")
  299:     return value
  300: 
  301: 
  302: def validate_positive_float_or_zero(option: str, value: Any) -> float:
  303:     """Validates that 'value' is 0 or a positive float, or can be converted to
  304:     0 or a positive float.
  305:     """
  306:     if value == 0 or value == "0":
  307:         return 0
  308:     return validate_positive_float(option, value)
  309: 
  310: 
  311: def validate_timeout_or_none(option: str, value: Any) -> Optional[float]:
  312:     """Validates a timeout specified in milliseconds returning
  313:     a value in floating point seconds.
  314:     """
  315:     if value is None:
  316:         return value
  317:     return validate_positive_float(option, value) / 1000.0
  318: 
  319: 
  320: def validate_timeout_or_zero(option: str, value: Any) -> float:
  321:     """Validates a timeout specified in milliseconds returning
  322:     a value in floating point seconds for the case where None is an error
  323:     and 0 is valid. Setting the timeout to nothing in the URI string is a
  324:     config error.
  325:     """
  326:     if value is None:
  327:         raise ConfigurationError(f"{option} cannot be None")
  328:     if value == 0 or value == "0":
  329:         return 0
  330:     return validate_positive_float(option, value) / 1000.0
  331: 
  332: 
  333: def validate_timeout_or_none_or_zero(option: Any, value: Any) -> Optional[float]:
  334:     """Validates a timeout specified in milliseconds returning
  335:     a value in floating point seconds. value=0 and value="0" are treated the
  336:     same as value=None which means unlimited timeout.
  337:     """
  338:     if value is None or value == 0 or value == "0":
  339:         return None
  340:     return validate_positive_float(option, value) / 1000.0
  341: 
  342: 
  343: def validate_timeoutms(option: Any, value: Any) -> Optional[float]:
  344:     """Validates a timeout specified in milliseconds returning
  345:     a value in floating point seconds.
  346:     """
  347:     if value is None:
  348:         return None
  349:     return validate_positive_float_or_zero(option, value) / 1000.0
  350: 
  351: 
  352: def validate_max_staleness(option: str, value: Any) -> int:
  353:     """Validates maxStalenessSeconds according to the Max Staleness Spec."""
  354:     if value == -1 or value == "-1":
  355:         # Default: No maximum staleness.
  356:         return -1
  357:     return validate_positive_integer(option, value)
  358: 
  359: 
  360: def validate_read_preference(dummy: Any, value: Any) -> _ServerMode:
  361:     """Validate a read preference."""
  362:     if not isinstance(value, _ServerMode):
  363:         raise TypeError(f"{value!r} is not a read preference.")
  364:     return value
  365: 
  366: 
  367: def validate_read_preference_mode(dummy: Any, value: Any) -> _ServerMode:
  368:     """Validate read preference mode for a MongoClient.
  369: 
  370:     .. versionchanged:: 3.5
  371:        Returns the original ``value`` instead of the validated read preference
  372:        mode.
  373:     """
  374:     if value not in _MONGOS_MODES:
  375:         raise ValueError(f"{value} is not a valid read preference")
  376:     return value
  377: 
  378: 
  379: def validate_auth_mechanism(option: str, value: Any) -> str:
  380:     """Validate the authMechanism URI option."""
  381:     from pymongo.auth import MECHANISMS
  382: 
  383:     if value not in MECHANISMS:
  384:         raise ValueError(f"{option} must be in {tuple(MECHANISMS)}")
  385:     return value
  386: 
  387: 
  388: def validate_uuid_representation(dummy: Any, value: Any) -> int:
  389:     """Validate the uuid representation option selected in the URI."""
  390:     try:
  391:         return _UUID_REPRESENTATIONS[value]
  392:     except KeyError:
  393:         raise ValueError(
  394:             f"{value} is an invalid UUID representation. "
  395:             "Must be one of "
  396:             f"{tuple(_UUID_REPRESENTATIONS)}"
  397:         ) from None
  398: 
  399: 
  400: def validate_read_preference_tags(name: str, value: Any) -> list[dict[str, str]]:
  401:     """Parse readPreferenceTags if passed as a client kwarg."""
  402:     if not isinstance(value, list):
  403:         value = [value]
  404: 
  405:     tag_sets: list = []
  406:     for tag_set in value:
  407:         if tag_set == "":
  408:             tag_sets.append({})
  409:             continue
  410:         try:
  411:             tags = {}
  412:             for tag in tag_set.split(","):
  413:                 key, val = tag.split(":")
  414:                 tags[unquote_plus(key)] = unquote_plus(val)
  415:             tag_sets.append(tags)
  416:         except Exception:
  417:             raise ValueError(f"{tag_set!r} not a valid value for {name}") from None
  418:     return tag_sets
  419: 
  420: 
  421: _MECHANISM_PROPS = frozenset(
  422:     [
  423:         "SERVICE_NAME",
  424:         "CANONICALIZE_HOST_NAME",
  425:         "SERVICE_REALM",
  426:         "AWS_SESSION_TOKEN",
  427:         "ENVIRONMENT",
  428:         "TOKEN_RESOURCE",
  429:     ]
  430: )
  431: 
  432: 
  433: def validate_auth_mechanism_properties(option: str, value: Any) -> dict[str, Union[bool, str]]:
  434:     """Validate authMechanismProperties."""
  435:     props: dict[str, Any] = {}
  436:     if not isinstance(value, str):
  437:         if not isinstance(value, dict):
  438:             raise ValueError("Auth mechanism properties must be given as a string or a dictionary")
  439:         for key, value in value.items():  # noqa: B020
  440:             if isinstance(value, str):
  441:                 props[key] = value
  442:             elif isinstance(value, bool):
  443:                 props[key] = str(value).lower()
  444:             elif key in ["ALLOWED_HOSTS"] and isinstance(value, list):
  445:                 props[key] = value
  446:             elif key in ["OIDC_CALLBACK", "OIDC_HUMAN_CALLBACK"]:
  447:                 from pymongo.auth_oidc import OIDCCallback
  448: 
  449:                 if not isinstance(value, OIDCCallback):
  450:                     raise ValueError("callback must be an OIDCCallback object")
  451:                 props[key] = value
  452:             else:
  453:                 raise ValueError(f"Invalid type for auth mechanism property {key}, {type(value)}")
  454:         return props
  455: 
  456:     value = validate_string(option, value)
  457:     value = unquote_plus(value)
  458:     for opt in value.split(","):
  459:         key, _, val = opt.partition(":")
  460:         if not val:
  461:             raise ValueError("Malformed auth mechanism properties")
  462:         if key not in _MECHANISM_PROPS:
  463:             # Try not to leak the token.
  464:             if "AWS_SESSION_TOKEN" in key:
  465:                 raise ValueError(
  466:                     "auth mechanism properties must be "
  467:                     "key:value pairs like AWS_SESSION_TOKEN:<token>"
  468:                 )
  469: 
  470:             raise ValueError(
  471:                 f"{key} is not a supported auth "
  472:                 "mechanism property. Must be one of "
  473:                 f"{tuple(_MECHANISM_PROPS)}."
  474:             )
  475: 
  476:         if key == "CANONICALIZE_HOST_NAME":
  477:             props[key] = validate_boolean_or_string(key, val)
  478:         else:
  479:             props[key] = val
  480: 
  481:     return props
  482: 
  483: 
  484: def validate_document_class(
  485:     option: str, value: Any
  486: ) -> Union[Type[MutableMapping], Type[RawBSONDocument]]:
  487:     """Validate the document_class option."""
  488:     # issubclass can raise TypeError for generic aliases like SON[str, Any].
  489:     # In that case we can use the base class for the comparison.
  490:     is_mapping = False
  491:     try:
  492:         is_mapping = issubclass(value, abc.MutableMapping)
  493:     except TypeError:
  494:         if hasattr(value, "__origin__"):
  495:             is_mapping = issubclass(value.__origin__, abc.MutableMapping)
  496:     if not is_mapping and not issubclass(value, RawBSONDocument):
  497:         raise TypeError(
  498:             f"{option} must be dict, bson.son.SON, "
  499:             "bson.raw_bson.RawBSONDocument, or a "
  500:             "subclass of collections.MutableMapping"
  501:         )
  502:     return value
  503: 
  504: 
  505: def validate_type_registry(option: Any, value: Any) -> Optional[TypeRegistry]:
  506:     """Validate the type_registry option."""
  507:     if value is not None and not isinstance(value, TypeRegistry):
  508:         raise TypeError(f"{option} must be an instance of {TypeRegistry}")
  509:     return value
  510: 
  511: 
  512: def validate_list(option: str, value: Any) -> list:
  513:     """Validates that 'value' is a list."""
  514:     if not isinstance(value, list):
  515:         raise TypeError(f"{option} must be a list")
  516:     return value
  517: 
  518: 
  519: def validate_list_or_none(option: Any, value: Any) -> Optional[list]:
  520:     """Validates that 'value' is a list or None."""
  521:     if value is None:
  522:         return value
  523:     return validate_list(option, value)
  524: 
  525: 
  526: def validate_list_or_mapping(option: Any, value: Any) -> None:
  527:     """Validates that 'value' is a list or a document."""
  528:     if not isinstance(value, (abc.Mapping, list)):
  529:         raise TypeError(
  530:             f"{option} must either be a list or an instance of dict, "
  531:             "bson.son.SON, or any other type that inherits from "
  532:             "collections.Mapping"
  533:         )
  534: 
  535: 
  536: def validate_is_mapping(option: str, value: Any) -> None:
  537:     """Validate the type of method arguments that expect a document."""
  538:     if not isinstance(value, abc.Mapping):
  539:         raise TypeError(
  540:             f"{option} must be an instance of dict, bson.son.SON, or "
  541:             "any other type that inherits from "
  542:             "collections.Mapping"
  543:         )
  544: 
  545: 
  546: def validate_is_document_type(option: str, value: Any) -> None:
  547:     """Validate the type of method arguments that expect a MongoDB document."""
  548:     if not isinstance(value, (abc.MutableMapping, RawBSONDocument)):
  549:         raise TypeError(
  550:             f"{option} must be an instance of dict, bson.son.SON, "
  551:             "bson.raw_bson.RawBSONDocument, or "
  552:             "a type that inherits from "
  553:             "collections.MutableMapping"
  554:         )
  555: 
  556: 
  557: def validate_appname_or_none(option: str, value: Any) -> Optional[str]:
  558:     """Validate the appname option."""
  559:     if value is None:
  560:         return value
  561:     validate_string(option, value)
  562:     # We need length in bytes, so encode utf8 first.
  563:     if len(value.encode("utf-8")) > 128:
  564:         raise ValueError(f"{option} must be <= 128 bytes")
  565:     return value
  566: 
  567: 
  568: def validate_driver_or_none(option: Any, value: Any) -> Optional[DriverInfo]:
  569:     """Validate the driver keyword arg."""
  570:     if value is None:
  571:         return value
  572:     if not isinstance(value, DriverInfo):
  573:         raise TypeError(f"{option} must be an instance of DriverInfo")
  574:     return value
  575: 
  576: 
  577: def validate_server_api_or_none(option: Any, value: Any) -> Optional[ServerApi]:
  578:     """Validate the server_api keyword arg."""
  579:     if value is None:
  580:         return value
  581:     if not isinstance(value, ServerApi):
  582:         raise TypeError(f"{option} must be an instance of ServerApi")
  583:     return value
  584: 
  585: 
  586: def validate_is_callable_or_none(option: Any, value: Any) -> Optional[Callable]:
  587:     """Validates that 'value' is a callable."""
  588:     if value is None:
  589:         return value
  590:     if not callable(value):
  591:         raise ValueError(f"{option} must be a callable")
  592:     return value
  593: 
  594: 
  595: def validate_ok_for_replace(replacement: Mapping[str, Any]) -> None:
  596:     """Validate a replacement document."""
  597:     validate_is_mapping("replacement", replacement)
  598:     # Replacement can be {}
  599:     if replacement and not isinstance(replacement, RawBSONDocument):
  600:         first = next(iter(replacement))
  601:         if first.startswith("$"):
  602:             raise ValueError("replacement can not include $ operators")
  603: 
  604: 
  605: def validate_ok_for_update(update: Any) -> None:
  606:     """Validate an update document."""
  607:     validate_list_or_mapping("update", update)
  608:     # Update cannot be {}.
  609:     if not update:
  610:         raise ValueError("update cannot be empty")
  611: 
  612:     is_document = not isinstance(update, list)
  613:     first = next(iter(update))
  614:     if is_document and not first.startswith("$"):
  615:         raise ValueError("update only works with $ operators")
  616: 
  617: 
  618: _UNICODE_DECODE_ERROR_HANDLERS = frozenset(["strict", "replace", "ignore"])
  619: 
  620: 
  621: def validate_unicode_decode_error_handler(dummy: Any, value: str) -> str:
  622:     """Validate the Unicode decode error handler option of CodecOptions."""
  623:     if value not in _UNICODE_DECODE_ERROR_HANDLERS:
  624:         raise ValueError(
  625:             f"{value} is an invalid Unicode decode error handler. "
  626:             "Must be one of "
  627:             f"{tuple(_UNICODE_DECODE_ERROR_HANDLERS)}"
  628:         )
  629:     return value
  630: 
  631: 
  632: def validate_tzinfo(dummy: Any, value: Any) -> Optional[datetime.tzinfo]:
  633:     """Validate the tzinfo option"""
  634:     if value is not None and not isinstance(value, datetime.tzinfo):
  635:         raise TypeError("%s must be an instance of datetime.tzinfo" % value)
  636:     return value
  637: 
  638: 
  639: def validate_auto_encryption_opts_or_none(option: Any, value: Any) -> Optional[Any]:
  640:     """Validate the driver keyword arg."""
  641:     if value is None:
  642:         return value
  643:     from pymongo.encryption_options import AutoEncryptionOpts
  644: 
  645:     if not isinstance(value, AutoEncryptionOpts):
  646:         raise TypeError(f"{option} must be an instance of AutoEncryptionOpts")
  647: 
  648:     return value
  649: 
  650: 
  651: def validate_datetime_conversion(option: Any, value: Any) -> Optional[DatetimeConversion]:
  652:     """Validate a DatetimeConversion string."""
  653:     if value is None:
  654:         return DatetimeConversion.DATETIME
  655: 
  656:     if isinstance(value, str):
  657:         if value.isdigit():
  658:             return DatetimeConversion(int(value))
  659:         return DatetimeConversion[value]
  660:     elif isinstance(value, int):
  661:         return DatetimeConversion(value)
  662: 
  663:     raise TypeError(f"{option} must be a str or int representing DatetimeConversion")
  664: 
  665: 
  666: def validate_server_monitoring_mode(option: str, value: str) -> str:
  667:     """Validate the serverMonitoringMode option."""
  668:     if value not in {"auto", "stream", "poll"}:
  669:         raise ValueError(
  670:             f'{option}={value!r} is invalid. Must be one of "auto", "stream", or "poll"'
  671:         )
  672:     return value
  673: 
  674: 
  675: # Dictionary where keys are the names of public URI options, and values
  676: # are lists of aliases for that option.
  677: URI_OPTIONS_ALIAS_MAP: dict[str, list[str]] = {
  678:     "tls": ["ssl"],
  679: }
  680: 
  681: # Dictionary where keys are the names of URI options, and values
  682: # are functions that validate user-input values for that option. If an option
  683: # alias uses a different validator than its public counterpart, it should be
  684: # included here as a key, value pair.
  685: URI_OPTIONS_VALIDATOR_MAP: dict[str, Callable[[Any, Any], Any]] = {
  686:     "appname": validate_appname_or_none,
  687:     "authmechanism": validate_auth_mechanism,
  688:     "authmechanismproperties": validate_auth_mechanism_properties,
  689:     "authsource": validate_string,
  690:     "compressors": validate_compressors,
  691:     "connecttimeoutms": validate_timeout_or_none_or_zero,
  692:     "directconnection": validate_boolean_or_string,
  693:     "heartbeatfrequencyms": validate_timeout_or_none,
  694:     "journal": validate_boolean_or_string,
  695:     "localthresholdms": validate_positive_float_or_zero,
  696:     "maxidletimems": validate_timeout_or_none,
  697:     "maxconnecting": validate_positive_integer,
  698:     "maxpoolsize": validate_non_negative_integer_or_none,
  699:     "maxstalenessseconds": validate_max_staleness,
  700:     "readconcernlevel": validate_string_or_none,
  701:     "readpreference": validate_read_preference_mode,
  702:     "readpreferencetags": validate_read_preference_tags,
  703:     "replicaset": validate_string_or_none,
  704:     "retryreads": validate_boolean_or_string,
  705:     "retrywrites": validate_boolean_or_string,
  706:     "loadbalanced": validate_boolean_or_string,
  707:     "serverselectiontimeoutms": validate_timeout_or_zero,
  708:     "sockettimeoutms": validate_timeout_or_none_or_zero,
  709:     "tls": validate_boolean_or_string,
  710:     "tlsallowinvalidcertificates": validate_boolean_or_string,
  711:     "tlsallowinvalidhostnames": validate_boolean_or_string,
  712:     "tlscafile": validate_readable,
  713:     "tlscertificatekeyfile": validate_readable,
  714:     "tlscertificatekeyfilepassword": validate_string_or_none,
  715:     "tlsdisableocspendpointcheck": validate_boolean_or_string,
  716:     "tlsinsecure": validate_boolean_or_string,
  717:     "w": validate_non_negative_int_or_basestring,
  718:     "wtimeoutms": validate_non_negative_integer,
  719:     "zlibcompressionlevel": validate_zlib_compression_level,
  720:     "srvservicename": validate_string,
  721:     "srvmaxhosts": validate_non_negative_integer,
  722:     "timeoutms": validate_timeoutms,
  723:     "servermonitoringmode": validate_server_monitoring_mode,
  724: }
  725: 
  726: # Dictionary where keys are the names of URI options specific to pymongo,
  727: # and values are functions that validate user-input values for those options.
  728: NONSPEC_OPTIONS_VALIDATOR_MAP: dict[str, Callable[[Any, Any], Any]] = {
  729:     "connect": validate_boolean_or_string,
  730:     "driver": validate_driver_or_none,
  731:     "server_api": validate_server_api_or_none,
  732:     "fsync": validate_boolean_or_string,
  733:     "minpoolsize": validate_non_negative_integer,
  734:     "tlscrlfile": validate_readable,
  735:     "tz_aware": validate_boolean_or_string,
  736:     "unicode_decode_error_handler": validate_unicode_decode_error_handler,
  737:     "uuidrepresentation": validate_uuid_representation,
  738:     "waitqueuemultiple": validate_non_negative_integer_or_none,
  739:     "waitqueuetimeoutms": validate_timeout_or_none,
  740:     "datetime_conversion": validate_datetime_conversion,
  741: }
  742: 
  743: # Dictionary where keys are the names of keyword-only options for the
  744: # MongoClient constructor, and values are functions that validate user-input
  745: # values for those options.
  746: KW_VALIDATORS: dict[str, Callable[[Any, Any], Any]] = {
  747:     "document_class": validate_document_class,
  748:     "type_registry": validate_type_registry,
  749:     "read_preference": validate_read_preference,
  750:     "event_listeners": _validate_event_listeners,
  751:     "tzinfo": validate_tzinfo,
  752:     "username": validate_string_or_none,
  753:     "password": validate_string_or_none,
  754:     "server_selector": validate_is_callable_or_none,
  755:     "auto_encryption_opts": validate_auto_encryption_opts_or_none,
  756:     "authoidcallowedhosts": validate_list,
  757: }
  758: 
  759: # Dictionary where keys are any URI option name, and values are the
  760: # internally-used names of that URI option. Options with only one name
  761: # variant need not be included here. Options whose public and internal
  762: # names are the same need not be included here.
  763: INTERNAL_URI_OPTION_NAME_MAP: dict[str, str] = {
  764:     "ssl": "tls",
  765: }
  766: 
  767: # Map from deprecated URI option names to a tuple indicating the method of
  768: # their deprecation and any additional information that may be needed to
  769: # construct the warning message.
  770: URI_OPTIONS_DEPRECATION_MAP: dict[str, tuple[str, str]] = {
  771:     # format: <deprecated option name>: (<mode>, <message>),
  772:     # Supported <mode> values:
  773:     # - 'renamed': <message> should be the new option name. Note that case is
  774:     #   preserved for renamed options as they are part of user warnings.
  775:     # - 'removed': <message> may suggest the rationale for deprecating the
  776:     #   option and/or recommend remedial action.
  777:     # For example:
  778:     # 'wtimeout': ('renamed', 'wTimeoutMS'),
  779: }
  780: 
  781: # Augment the option validator map with pymongo-specific option information.
  782: URI_OPTIONS_VALIDATOR_MAP.update(NONSPEC_OPTIONS_VALIDATOR_MAP)
  783: for optname, aliases in URI_OPTIONS_ALIAS_MAP.items():
  784:     for alias in aliases:
  785:         if alias not in URI_OPTIONS_VALIDATOR_MAP:
  786:             URI_OPTIONS_VALIDATOR_MAP[alias] = URI_OPTIONS_VALIDATOR_MAP[optname]
  787: 
  788: # Map containing all URI option and keyword argument validators.
  789: VALIDATORS: dict[str, Callable[[Any, Any], Any]] = URI_OPTIONS_VALIDATOR_MAP.copy()
  790: VALIDATORS.update(KW_VALIDATORS)
  791: 
  792: # List of timeout-related options.
  793: TIMEOUT_OPTIONS: list[str] = [
  794:     "connecttimeoutms",
  795:     "heartbeatfrequencyms",
  796:     "maxidletimems",
  797:     "maxstalenessseconds",
  798:     "serverselectiontimeoutms",
  799:     "sockettimeoutms",
  800:     "waitqueuetimeoutms",
  801: ]
  802: 
  803: _AUTH_OPTIONS = frozenset(["authmechanismproperties"])
  804: 
  805: 
  806: def validate_auth_option(option: str, value: Any) -> tuple[str, Any]:
  807:     """Validate optional authentication parameters."""
  808:     lower, value = validate(option, value)
  809:     if lower not in _AUTH_OPTIONS:
  810:         raise ConfigurationError(f"Unknown option: {option}. Must be in {_AUTH_OPTIONS}")
  811:     return option, value
  812: 
  813: 
  814: def _get_validator(
  815:     key: str, validators: dict[str, Callable[[Any, Any], Any]], normed_key: Optional[str] = None
  816: ) -> Callable:
  817:     normed_key = normed_key or key
  818:     try:
  819:         return validators[normed_key]
  820:     except KeyError:
  821:         suggestions = get_close_matches(normed_key, validators, cutoff=0.2)
  822:         raise_config_error(key, suggestions)
  823: 
  824: 
  825: def validate(option: str, value: Any) -> tuple[str, Any]:
  826:     """Generic validation function."""
  827:     validator = _get_validator(option, VALIDATORS, normed_key=option.lower())
  828:     value = validator(option, value)
  829:     return option, value
  830: 
  831: 
  832: def get_validated_options(
  833:     options: Mapping[str, Any], warn: bool = True
  834: ) -> MutableMapping[str, Any]:
  835:     """Validate each entry in options and raise a warning if it is not valid.
  836:     Returns a copy of options with invalid entries removed.
  837: 
  838:     :param opts: A dict containing MongoDB URI options.
  839:     :param warn: If ``True`` then warnings will be logged and
  840:           invalid options will be ignored. Otherwise, invalid options will
  841:           cause errors.
  842:     """
  843:     validated_options: MutableMapping[str, Any]
  844:     if isinstance(options, _CaseInsensitiveDictionary):
  845:         validated_options = _CaseInsensitiveDictionary()
  846: 
  847:         def get_normed_key(x: str) -> str:
  848:             return x
  849: 
  850:         def get_setter_key(x: str) -> str:
  851:             return options.cased_key(x)  # type: ignore[attr-defined]
  852: 
  853:     else:
  854:         validated_options = {}
  855: 
  856:         def get_normed_key(x: str) -> str:
  857:             return x.lower()
  858: 
  859:         def get_setter_key(x: str) -> str:
  860:             return x
  861: 
  862:     for opt, value in options.items():
  863:         normed_key = get_normed_key(opt)
  864:         try:
  865:             validator = _get_validator(opt, URI_OPTIONS_VALIDATOR_MAP, normed_key=normed_key)
  866:             validated = validator(opt, value)
  867:         except (ValueError, TypeError, ConfigurationError) as exc:
  868:             if warn:
  869:                 warnings.warn(str(exc), stacklevel=2)
  870:             else:
  871:                 raise
  872:         else:
  873:             validated_options[get_setter_key(normed_key)] = validated
  874:     return validated_options
  875: 
  876: 
  877: def _esc_coll_name(encrypted_fields: Mapping[str, Any], name: str) -> Any:
  878:     return encrypted_fields.get("escCollection", f"enxcol_.{name}.esc")
  879: 
  880: 
  881: def _ecoc_coll_name(encrypted_fields: Mapping[str, Any], name: str) -> Any:
  882:     return encrypted_fields.get("ecocCollection", f"enxcol_.{name}.ecoc")
  883: 
  884: 
  885: # List of write-concern-related options.
  886: WRITE_CONCERN_OPTIONS = frozenset(["w", "wtimeout", "wtimeoutms", "fsync", "j", "journal"])
  887: 
  888: 
  889: class BaseObject:
  890:     """A base class that provides attributes and methods common
  891:     to multiple pymongo classes.
  892: 
  893:     SHOULD NOT BE USED BY DEVELOPERS EXTERNAL TO MONGODB.
  894:     """
  895: 
  896:     def __init__(
  897:         self,
  898:         codec_options: CodecOptions,
  899:         read_preference: _ServerMode,
  900:         write_concern: WriteConcern,
  901:         read_concern: ReadConcern,
  902:     ) -> None:
  903:         if not isinstance(codec_options, CodecOptions):
  904:             raise TypeError("codec_options must be an instance of bson.codec_options.CodecOptions")
  905:         self.__codec_options = codec_options
  906: 
  907:         if not isinstance(read_preference, _ServerMode):
  908:             raise TypeError(
  909:                 f"{read_preference!r} is not valid for read_preference. See "
  910:                 "pymongo.read_preferences for valid "
  911:                 "options."
  912:             )
  913:         self.__read_preference = read_preference
  914: 
  915:         if not isinstance(write_concern, WriteConcern):
  916:             raise TypeError(
  917:                 "write_concern must be an instance of pymongo.write_concern.WriteConcern"
  918:             )
  919:         self.__write_concern = write_concern
  920: 
  921:         if not isinstance(read_concern, ReadConcern):
  922:             raise TypeError("read_concern must be an instance of pymongo.read_concern.ReadConcern")
  923:         self.__read_concern = read_concern
  924: 
  925:     @property
  926:     def codec_options(self) -> CodecOptions:
  927:         """Read only access to the :class:`~bson.codec_options.CodecOptions`
  928:         of this instance.
  929:         """
  930:         return self.__codec_options
  931: 
  932:     @property
  933:     def write_concern(self) -> WriteConcern:
  934:         """Read only access to the :class:`~pymongo.write_concern.WriteConcern`
  935:         of this instance.
  936: 
  937:         .. versionchanged:: 3.0
  938:           The :attr:`write_concern` attribute is now read only.
  939:         """
  940:         return self.__write_concern
  941: 
  942:     def _write_concern_for(self, session: Optional[ClientSession]) -> WriteConcern:
  943:         """Read only access to the write concern of this instance or session."""
  944:         # Override this operation's write concern with the transaction's.
  945:         if session and session.in_transaction:
  946:             return DEFAULT_WRITE_CONCERN
  947:         return self.write_concern
  948: 
  949:     @property
  950:     def read_preference(self) -> _ServerMode:
  951:         """Read only access to the read preference of this instance.
  952: 
  953:         .. versionchanged:: 3.0
  954:           The :attr:`read_preference` attribute is now read only.
  955:         """
  956:         return self.__read_preference
  957: 
  958:     def _read_preference_for(self, session: Optional[ClientSession]) -> _ServerMode:
  959:         """Read only access to the read preference of this instance or session."""
  960:         # Override this operation's read preference with the transaction's.
  961:         if session:
  962:             return session._txn_read_preference() or self.__read_preference
  963:         return self.__read_preference
  964: 
  965:     @property
  966:     def read_concern(self) -> ReadConcern:
  967:         """Read only access to the :class:`~pymongo.read_concern.ReadConcern`
  968:         of this instance.
  969: 
  970:         .. versionadded:: 3.2
  971:         """
  972:         return self.__read_concern
  973: 
  974: 
  975: class _CaseInsensitiveDictionary(MutableMapping[str, Any]):
  976:     def __init__(self, *args: Any, **kwargs: Any):
  977:         self.__casedkeys: dict[str, Any] = {}
  978:         self.__data: dict[str, Any] = {}
  979:         self.update(dict(*args, **kwargs))
  980: 
  981:     def __contains__(self, key: str) -> bool:  # type: ignore[override]
  982:         return key.lower() in self.__data
  983: 
  984:     def __len__(self) -> int:
  985:         return len(self.__data)
  986: 
  987:     def __iter__(self) -> Iterator[str]:
  988:         return (key for key in self.__casedkeys)
  989: 
  990:     def __repr__(self) -> str:
  991:         return str({self.__casedkeys[k]: self.__data[k] for k in self})
  992: 
  993:     def __setitem__(self, key: str, value: Any) -> None:
  994:         lc_key = key.lower()
  995:         self.__casedkeys[lc_key] = key
  996:         self.__data[lc_key] = value
  997: 
  998:     def __getitem__(self, key: str) -> Any:
  999:         return self.__data[key.lower()]
 1000: 
 1001:     def __delitem__(self, key: str) -> None:
 1002:         lc_key = key.lower()
 1003:         del self.__casedkeys[lc_key]
 1004:         del self.__data[lc_key]
 1005: 
 1006:     def __eq__(self, other: Any) -> bool:
 1007:         if not isinstance(other, abc.Mapping):
 1008:             return NotImplemented
 1009:         if len(self) != len(other):
 1010:             return False
 1011:         for key in other:  # noqa: SIM110
 1012:             if self[key] != other[key]:
 1013:                 return False
 1014: 
 1015:         return True
 1016: 
 1017:     def get(self, key: str, default: Optional[Any] = None) -> Any:
 1018:         return self.__data.get(key.lower(), default)
 1019: 
 1020:     def pop(self, key: str, *args: Any, **kwargs: Any) -> Any:
 1021:         lc_key = key.lower()
 1022:         self.__casedkeys.pop(lc_key, None)
 1023:         return self.__data.pop(lc_key, *args, **kwargs)
 1024: 
 1025:     def popitem(self) -> tuple[str, Any]:
 1026:         lc_key, cased_key = self.__casedkeys.popitem()
 1027:         value = self.__data.pop(lc_key)
 1028:         return cased_key, value
 1029: 
 1030:     def clear(self) -> None:
 1031:         self.__casedkeys.clear()
 1032:         self.__data.clear()
 1033: 
 1034:     @overload
 1035:     def setdefault(self, key: str, default: None = None) -> Optional[Any]:
 1036:         ...
 1037: 
 1038:     @overload
 1039:     def setdefault(self, key: str, default: Any) -> Any:
 1040:         ...
 1041: 
 1042:     def setdefault(self, key: str, default: Optional[Any] = None) -> Optional[Any]:
 1043:         lc_key = key.lower()
 1044:         if key in self:
 1045:             return self.__data[lc_key]
 1046:         else:
 1047:             self.__casedkeys[lc_key] = key
 1048:             self.__data[lc_key] = default
 1049:             return default
 1050: 
 1051:     def update(self, other: Mapping[str, Any]) -> None:  # type: ignore[override]
 1052:         if isinstance(other, _CaseInsensitiveDictionary):
 1053:             for key in other:
 1054:                 self[other.cased_key(key)] = other[key]
 1055:         else:
 1056:             for key in other:
 1057:                 self[key] = other[key]
 1058: 
 1059:     def cased_key(self, key: str) -> Any:
 1060:         return self.__casedkeys[key.lower()]
