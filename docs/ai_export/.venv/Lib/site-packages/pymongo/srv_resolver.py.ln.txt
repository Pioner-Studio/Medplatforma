    1: # Copyright 2019-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Support for resolving hosts and options from mongodb+srv:// URIs."""
   16: from __future__ import annotations
   17: 
   18: import ipaddress
   19: import random
   20: from typing import TYPE_CHECKING, Any, Optional, Union
   21: 
   22: from pymongo.common import CONNECT_TIMEOUT
   23: from pymongo.errors import ConfigurationError
   24: 
   25: if TYPE_CHECKING:
   26:     from dns import resolver
   27: 
   28: 
   29: def _have_dnspython() -> bool:
   30:     try:
   31:         import dns  # noqa: F401
   32: 
   33:         return True
   34:     except ImportError:
   35:         return False
   36: 
   37: 
   38: # dnspython can return bytes or str from various parts
   39: # of its API depending on version. We always want str.
   40: def maybe_decode(text: Union[str, bytes]) -> str:
   41:     if isinstance(text, bytes):
   42:         return text.decode()
   43:     return text
   44: 
   45: 
   46: # PYTHON-2667 Lazily call dns.resolver methods for compatibility with eventlet.
   47: def _resolve(*args: Any, **kwargs: Any) -> resolver.Answer:
   48:     from dns import resolver
   49: 
   50:     if hasattr(resolver, "resolve"):
   51:         # dnspython >= 2
   52:         return resolver.resolve(*args, **kwargs)
   53:     # dnspython 1.X
   54:     return resolver.query(*args, **kwargs)
   55: 
   56: 
   57: _INVALID_HOST_MSG = (
   58:     "Invalid URI host: %s is not a valid hostname for 'mongodb+srv://'. "
   59:     "Did you mean to use 'mongodb://'?"
   60: )
   61: 
   62: 
   63: class _SrvResolver:
   64:     def __init__(
   65:         self,
   66:         fqdn: str,
   67:         connect_timeout: Optional[float],
   68:         srv_service_name: str,
   69:         srv_max_hosts: int = 0,
   70:     ):
   71:         self.__fqdn = fqdn
   72:         self.__srv = srv_service_name
   73:         self.__connect_timeout = connect_timeout or CONNECT_TIMEOUT
   74:         self.__srv_max_hosts = srv_max_hosts or 0
   75:         # Validate the fully qualified domain name.
   76:         try:
   77:             ipaddress.ip_address(fqdn)
   78:             raise ConfigurationError(_INVALID_HOST_MSG % ("an IP address",))
   79:         except ValueError:
   80:             pass
   81: 
   82:         try:
   83:             self.__plist = self.__fqdn.split(".")[1:]
   84:         except Exception:
   85:             raise ConfigurationError(_INVALID_HOST_MSG % (fqdn,)) from None
   86:         self.__slen = len(self.__plist)
   87:         if self.__slen < 2:
   88:             raise ConfigurationError(_INVALID_HOST_MSG % (fqdn,))
   89: 
   90:     def get_options(self) -> Optional[str]:
   91:         from dns import resolver
   92: 
   93:         try:
   94:             results = _resolve(self.__fqdn, "TXT", lifetime=self.__connect_timeout)
   95:         except (resolver.NoAnswer, resolver.NXDOMAIN):
   96:             # No TXT records
   97:             return None
   98:         except Exception as exc:
   99:             raise ConfigurationError(str(exc)) from None
  100:         if len(results) > 1:
  101:             raise ConfigurationError("Only one TXT record is supported")
  102:         return (b"&".join([b"".join(res.strings) for res in results])).decode("utf-8")
  103: 
  104:     def _resolve_uri(self, encapsulate_errors: bool) -> resolver.Answer:
  105:         try:
  106:             results = _resolve(
  107:                 "_" + self.__srv + "._tcp." + self.__fqdn, "SRV", lifetime=self.__connect_timeout
  108:             )
  109:         except Exception as exc:
  110:             if not encapsulate_errors:
  111:                 # Raise the original error.
  112:                 raise
  113:             # Else, raise all errors as ConfigurationError.
  114:             raise ConfigurationError(str(exc)) from None
  115:         return results
  116: 
  117:     def _get_srv_response_and_hosts(
  118:         self, encapsulate_errors: bool
  119:     ) -> tuple[resolver.Answer, list[tuple[str, Any]]]:
  120:         results = self._resolve_uri(encapsulate_errors)
  121: 
  122:         # Construct address tuples
  123:         nodes = [
  124:             (maybe_decode(res.target.to_text(omit_final_dot=True)), res.port) for res in results
  125:         ]
  126: 
  127:         # Validate hosts
  128:         for node in nodes:
  129:             try:
  130:                 nlist = node[0].lower().split(".")[1:][-self.__slen :]
  131:             except Exception:
  132:                 raise ConfigurationError(f"Invalid SRV host: {node[0]}") from None
  133:             if self.__plist != nlist:
  134:                 raise ConfigurationError(f"Invalid SRV host: {node[0]}")
  135:         if self.__srv_max_hosts:
  136:             nodes = random.sample(nodes, min(self.__srv_max_hosts, len(nodes)))
  137:         return results, nodes
  138: 
  139:     def get_hosts(self) -> list[tuple[str, Any]]:
  140:         _, nodes = self._get_srv_response_and_hosts(True)
  141:         return nodes
  142: 
  143:     def get_hosts_and_min_ttl(self) -> tuple[list[tuple[str, Any]], int]:
  144:         results, nodes = self._get_srv_response_and_hosts(False)
  145:         rrset = results.rrset
  146:         ttl = rrset.ttl if rrset else 0
  147:         return nodes, ttl
