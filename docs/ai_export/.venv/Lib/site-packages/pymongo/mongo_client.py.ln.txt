    1: # Copyright 2009-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Tools for connecting to MongoDB.
   16: 
   17: .. seealso:: :doc:`/examples/high_availability` for examples of connecting
   18:    to replica sets or sets of mongos servers.
   19: 
   20: To get a :class:`~pymongo.database.Database` instance from a
   21: :class:`MongoClient` use either dictionary-style or attribute-style
   22: access:
   23: 
   24: .. doctest::
   25: 
   26:   >>> from pymongo import MongoClient
   27:   >>> c = MongoClient()
   28:   >>> c.test_database
   29:   Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'test_database')
   30:   >>> c["test-database"]
   31:   Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'test-database')
   32: """
   33: from __future__ import annotations
   34: 
   35: import contextlib
   36: import os
   37: import weakref
   38: from collections import defaultdict
   39: from typing import (
   40:     TYPE_CHECKING,
   41:     Any,
   42:     Callable,
   43:     ContextManager,
   44:     FrozenSet,
   45:     Generic,
   46:     Iterator,
   47:     Mapping,
   48:     MutableMapping,
   49:     NoReturn,
   50:     Optional,
   51:     Sequence,
   52:     Type,
   53:     TypeVar,
   54:     Union,
   55:     cast,
   56: )
   57: 
   58: from bson.codec_options import DEFAULT_CODEC_OPTIONS, CodecOptions, TypeRegistry
   59: from bson.timestamp import Timestamp
   60: from pymongo import (
   61:     _csot,
   62:     client_session,
   63:     common,
   64:     database,
   65:     helpers,
   66:     message,
   67:     periodic_executor,
   68:     uri_parser,
   69: )
   70: from pymongo.change_stream import ChangeStream, ClusterChangeStream
   71: from pymongo.client_options import ClientOptions
   72: from pymongo.client_session import _EmptyServerSession
   73: from pymongo.command_cursor import CommandCursor
   74: from pymongo.errors import (
   75:     AutoReconnect,
   76:     BulkWriteError,
   77:     ConfigurationError,
   78:     ConnectionFailure,
   79:     InvalidOperation,
   80:     NotPrimaryError,
   81:     OperationFailure,
   82:     PyMongoError,
   83:     ServerSelectionTimeoutError,
   84:     WaitQueueTimeoutError,
   85:     WriteConcernError,
   86: )
   87: from pymongo.lock import _HAS_REGISTER_AT_FORK, _create_lock, _release_locks
   88: from pymongo.logger import _CLIENT_LOGGER, _log_or_warn
   89: from pymongo.monitoring import ConnectionClosedReason
   90: from pymongo.operations import _Op
   91: from pymongo.read_preferences import ReadPreference, _ServerMode
   92: from pymongo.server_selectors import writable_server_selector
   93: from pymongo.server_type import SERVER_TYPE
   94: from pymongo.settings import TopologySettings
   95: from pymongo.topology import Topology, _ErrorContext
   96: from pymongo.topology_description import TOPOLOGY_TYPE, TopologyDescription
   97: from pymongo.typings import (
   98:     ClusterTime,
   99:     _Address,
  100:     _CollationIn,
  101:     _DocumentType,
  102:     _DocumentTypeArg,
  103:     _Pipeline,
  104: )
  105: from pymongo.uri_parser import (
  106:     _check_options,
  107:     _handle_option_deprecations,
  108:     _handle_security_options,
  109:     _normalize_options,
  110: )
  111: from pymongo.write_concern import DEFAULT_WRITE_CONCERN, WriteConcern
  112: 
  113: if TYPE_CHECKING:
  114:     import sys
  115:     from types import TracebackType
  116: 
  117:     from bson.objectid import ObjectId
  118:     from pymongo.bulk import _Bulk
  119:     from pymongo.client_session import ClientSession, _ServerSession
  120:     from pymongo.cursor import _ConnectionManager
  121:     from pymongo.database import Database
  122:     from pymongo.message import _CursorAddress, _GetMore, _Query
  123:     from pymongo.pool import Connection
  124:     from pymongo.read_concern import ReadConcern
  125:     from pymongo.response import Response
  126:     from pymongo.server import Server
  127:     from pymongo.server_selectors import Selection
  128: 
  129:     if sys.version_info[:2] >= (3, 9):
  130:         from collections.abc import Generator
  131:     else:
  132:         # Deprecated since version 3.9: collections.abc.Generator now supports [].
  133:         from typing import Generator
  134: 
  135: T = TypeVar("T")
  136: 
  137: _WriteCall = Callable[[Optional["ClientSession"], "Connection", bool], T]
  138: _ReadCall = Callable[[Optional["ClientSession"], "Server", "Connection", _ServerMode], T]
  139: 
  140: 
  141: class MongoClient(common.BaseObject, Generic[_DocumentType]):
  142:     """
  143:     A client-side representation of a MongoDB cluster.
  144: 
  145:     Instances can represent either a standalone MongoDB server, a replica
  146:     set, or a sharded cluster. Instances of this class are responsible for
  147:     maintaining up-to-date state of the cluster, and possibly cache
  148:     resources related to this, including background threads for monitoring,
  149:     and connection pools.
  150:     """
  151: 
  152:     HOST = "localhost"
  153:     PORT = 27017
  154:     # Define order to retrieve options from ClientOptions for __repr__.
  155:     # No host/port; these are retrieved from TopologySettings.
  156:     _constructor_args = ("document_class", "tz_aware", "connect")
  157:     _clients: weakref.WeakValueDictionary = weakref.WeakValueDictionary()
  158: 
  159:     def __init__(
  160:         self,
  161:         host: Optional[Union[str, Sequence[str]]] = None,
  162:         port: Optional[int] = None,
  163:         document_class: Optional[Type[_DocumentType]] = None,
  164:         tz_aware: Optional[bool] = None,
  165:         connect: Optional[bool] = None,
  166:         type_registry: Optional[TypeRegistry] = None,
  167:         **kwargs: Any,
  168:     ) -> None:
  169:         """Client for a MongoDB instance, a replica set, or a set of mongoses.
  170: 
  171:         .. warning:: Starting in PyMongo 4.0, ``directConnection`` now has a default value of
  172:           False instead of None.
  173:           For more details, see the relevant section of the PyMongo 4.x migration guide:
  174:           :ref:`pymongo4-migration-direct-connection`.
  175: 
  176:         The client object is thread-safe and has connection-pooling built in.
  177:         If an operation fails because of a network error,
  178:         :class:`~pymongo.errors.ConnectionFailure` is raised and the client
  179:         reconnects in the background. Application code should handle this
  180:         exception (recognizing that the operation failed) and then continue to
  181:         execute.
  182: 
  183:         The `host` parameter can be a full `mongodb URI
  184:         <http://dochub.mongodb.org/core/connections>`_, in addition to
  185:         a simple hostname. It can also be a list of hostnames but no more
  186:         than one URI. Any port specified in the host string(s) will override
  187:         the `port` parameter. For username and
  188:         passwords reserved characters like ':', '/', '+' and '@' must be
  189:         percent encoded following RFC 2396::
  190: 
  191:             from urllib.parse import quote_plus
  192: 
  193:             uri = "mongodb://%s:%s@%s" % (
  194:                 quote_plus(user), quote_plus(password), host)
  195:             client = MongoClient(uri)
  196: 
  197:         Unix domain sockets are also supported. The socket path must be percent
  198:         encoded in the URI::
  199: 
  200:             uri = "mongodb://%s:%s@%s" % (
  201:                 quote_plus(user), quote_plus(password), quote_plus(socket_path))
  202:             client = MongoClient(uri)
  203: 
  204:         But not when passed as a simple hostname::
  205: 
  206:             client = MongoClient('/tmp/mongodb-27017.sock')
  207: 
  208:         Starting with version 3.6, PyMongo supports mongodb+srv:// URIs. The
  209:         URI must include one, and only one, hostname. The hostname will be
  210:         resolved to one or more DNS `SRV records
  211:         <https://en.wikipedia.org/wiki/SRV_record>`_ which will be used
  212:         as the seed list for connecting to the MongoDB deployment. When using
  213:         SRV URIs, the `authSource` and `replicaSet` configuration options can
  214:         be specified using `TXT records
  215:         <https://en.wikipedia.org/wiki/TXT_record>`_. See the
  216:         `Initial DNS Seedlist Discovery spec
  217:         <https://github.com/mongodb/specifications/blob/master/source/
  218:         initial-dns-seedlist-discovery/initial-dns-seedlist-discovery.rst>`_
  219:         for more details. Note that the use of SRV URIs implicitly enables
  220:         TLS support. Pass tls=false in the URI to override.
  221: 
  222:         .. note:: MongoClient creation will block waiting for answers from
  223:           DNS when mongodb+srv:// URIs are used.
  224: 
  225:         .. note:: Starting with version 3.0 the :class:`MongoClient`
  226:           constructor no longer blocks while connecting to the server or
  227:           servers, and it no longer raises
  228:           :class:`~pymongo.errors.ConnectionFailure` if they are
  229:           unavailable, nor :class:`~pymongo.errors.ConfigurationError`
  230:           if the user's credentials are wrong. Instead, the constructor
  231:           returns immediately and launches the connection process on
  232:           background threads. You can check if the server is available
  233:           like this::
  234: 
  235:             from pymongo.errors import ConnectionFailure
  236:             client = MongoClient()
  237:             try:
  238:                 # The ping command is cheap and does not require auth.
  239:                 client.admin.command('ping')
  240:             except ConnectionFailure:
  241:                 print("Server not available")
  242: 
  243:         .. warning:: When using PyMongo in a multiprocessing context, please
  244:           read :ref:`multiprocessing` first.
  245: 
  246:         .. note:: Many of the following options can be passed using a MongoDB
  247:           URI or keyword parameters. If the same option is passed in a URI and
  248:           as a keyword parameter the keyword parameter takes precedence.
  249: 
  250:         :param host: hostname or IP address or Unix domain socket
  251:             path of a single mongod or mongos instance to connect to, or a
  252:             mongodb URI, or a list of hostnames (but no more than one mongodb
  253:             URI). If `host` is an IPv6 literal it must be enclosed in '['
  254:             and ']' characters
  255:             following the RFC2732 URL syntax (e.g. '[::1]' for localhost).
  256:             Multihomed and round robin DNS addresses are **not** supported.
  257:         :param port: port number on which to connect
  258:         :param document_class: default class to use for
  259:             documents returned from queries on this client
  260:         :param tz_aware: if ``True``,
  261:             :class:`~datetime.datetime` instances returned as values
  262:             in a document by this :class:`MongoClient` will be timezone
  263:             aware (otherwise they will be naive)
  264:         :param connect: if ``True`` (the default), immediately
  265:             begin connecting to MongoDB in the background. Otherwise connect
  266:             on the first operation.
  267:         :param type_registry: instance of
  268:             :class:`~bson.codec_options.TypeRegistry` to enable encoding
  269:             and decoding of custom types.
  270:         :param datetime_conversion: Specifies how UTC datetimes should be decoded
  271:             within BSON. Valid options include 'datetime_ms' to return as a
  272:             DatetimeMS, 'datetime' to return as a datetime.datetime and
  273:             raising a ValueError for out-of-range values, 'datetime_auto' to
  274:             return DatetimeMS objects when the underlying datetime is
  275:             out-of-range and 'datetime_clamp' to clamp to the minimum and
  276:             maximum possible datetimes. Defaults to 'datetime'. See
  277:             :ref:`handling-out-of-range-datetimes` for details.
  278: 
  279:           | **Other optional parameters can be passed as keyword arguments:**
  280: 
  281:           - `directConnection` (optional): if ``True``, forces this client to
  282:              connect directly to the specified MongoDB host as a standalone.
  283:              If ``false``, the client connects to the entire replica set of
  284:              which the given MongoDB host(s) is a part. If this is ``True``
  285:              and a mongodb+srv:// URI or a URI containing multiple seeds is
  286:              provided, an exception will be raised.
  287:           - `maxPoolSize` (optional): The maximum allowable number of
  288:             concurrent connections to each connected server. Requests to a
  289:             server will block if there are `maxPoolSize` outstanding
  290:             connections to the requested server. Defaults to 100. Can be
  291:             either 0 or None, in which case there is no limit on the number
  292:             of concurrent connections.
  293:           - `minPoolSize` (optional): The minimum required number of concurrent
  294:             connections that the pool will maintain to each connected server.
  295:             Default is 0.
  296:           - `maxIdleTimeMS` (optional): The maximum number of milliseconds that
  297:             a connection can remain idle in the pool before being removed and
  298:             replaced. Defaults to `None` (no limit).
  299:           - `maxConnecting` (optional): The maximum number of connections that
  300:             each pool can establish concurrently. Defaults to `2`.
  301:           - `timeoutMS`: (integer or None) Controls how long (in
  302:             milliseconds) the driver will wait when executing an operation
  303:             (including retry attempts) before raising a timeout error.
  304:             ``0`` or ``None`` means no timeout.
  305:           - `socketTimeoutMS`: (integer or None) Controls how long (in
  306:             milliseconds) the driver will wait for a response after sending an
  307:             ordinary (non-monitoring) database operation before concluding that
  308:             a network error has occurred. ``0`` or ``None`` means no timeout.
  309:             Defaults to ``None`` (no timeout).
  310:           - `connectTimeoutMS`: (integer or None) Controls how long (in
  311:             milliseconds) the driver will wait during server monitoring when
  312:             connecting a new socket to a server before concluding the server
  313:             is unavailable. ``0`` or ``None`` means no timeout.
  314:             Defaults to ``20000`` (20 seconds).
  315:           - `server_selector`: (callable or None) Optional, user-provided
  316:             function that augments server selection rules. The function should
  317:             accept as an argument a list of
  318:             :class:`~pymongo.server_description.ServerDescription` objects and
  319:             return a list of server descriptions that should be considered
  320:             suitable for the desired operation.
  321:           - `serverSelectionTimeoutMS`: (integer) Controls how long (in
  322:             milliseconds) the driver will wait to find an available,
  323:             appropriate server to carry out a database operation; while it is
  324:             waiting, multiple server monitoring operations may be carried out,
  325:             each controlled by `connectTimeoutMS`. Defaults to ``30000`` (30
  326:             seconds).
  327:           - `waitQueueTimeoutMS`: (integer or None) How long (in milliseconds)
  328:             a thread will wait for a socket from the pool if the pool has no
  329:             free sockets. Defaults to ``None`` (no timeout).
  330:           - `heartbeatFrequencyMS`: (optional) The number of milliseconds
  331:             between periodic server checks, or None to accept the default
  332:             frequency of 10 seconds.
  333:           - `serverMonitoringMode`: (optional) The server monitoring mode to use.
  334:             Valid values are the strings: "auto", "stream", "poll". Defaults to "auto".
  335:           - `appname`: (string or None) The name of the application that
  336:             created this MongoClient instance. The server will log this value
  337:             upon establishing each connection. It is also recorded in the slow
  338:             query log and profile collections.
  339:           - `driver`: (pair or None) A driver implemented on top of PyMongo can
  340:             pass a :class:`~pymongo.driver_info.DriverInfo` to add its name,
  341:             version, and platform to the message printed in the server log when
  342:             establishing a connection.
  343:           - `event_listeners`: a list or tuple of event listeners. See
  344:             :mod:`~pymongo.monitoring` for details.
  345:           - `retryWrites`: (boolean) Whether supported write operations
  346:             executed within this MongoClient will be retried once after a
  347:             network error. Defaults to ``True``.
  348:             The supported write operations are:
  349: 
  350:               - :meth:`~pymongo.collection.Collection.bulk_write`, as long as
  351:                 :class:`~pymongo.operations.UpdateMany` or
  352:                 :class:`~pymongo.operations.DeleteMany` are not included.
  353:               - :meth:`~pymongo.collection.Collection.delete_one`
  354:               - :meth:`~pymongo.collection.Collection.insert_one`
  355:               - :meth:`~pymongo.collection.Collection.insert_many`
  356:               - :meth:`~pymongo.collection.Collection.replace_one`
  357:               - :meth:`~pymongo.collection.Collection.update_one`
  358:               - :meth:`~pymongo.collection.Collection.find_one_and_delete`
  359:               - :meth:`~pymongo.collection.Collection.find_one_and_replace`
  360:               - :meth:`~pymongo.collection.Collection.find_one_and_update`
  361: 
  362:             Unsupported write operations include, but are not limited to,
  363:             :meth:`~pymongo.collection.Collection.aggregate` using the ``$out``
  364:             pipeline operator and any operation with an unacknowledged write
  365:             concern (e.g. {w: 0})). See
  366:             https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.rst
  367:           - `retryReads`: (boolean) Whether supported read operations
  368:             executed within this MongoClient will be retried once after a
  369:             network error. Defaults to ``True``.
  370:             The supported read operations are:
  371:             :meth:`~pymongo.collection.Collection.find`,
  372:             :meth:`~pymongo.collection.Collection.find_one`,
  373:             :meth:`~pymongo.collection.Collection.aggregate` without ``$out``,
  374:             :meth:`~pymongo.collection.Collection.distinct`,
  375:             :meth:`~pymongo.collection.Collection.count`,
  376:             :meth:`~pymongo.collection.Collection.estimated_document_count`,
  377:             :meth:`~pymongo.collection.Collection.count_documents`,
  378:             :meth:`pymongo.collection.Collection.watch`,
  379:             :meth:`~pymongo.collection.Collection.list_indexes`,
  380:             :meth:`pymongo.database.Database.watch`,
  381:             :meth:`~pymongo.database.Database.list_collections`,
  382:             :meth:`pymongo.mongo_client.MongoClient.watch`,
  383:             and :meth:`~pymongo.mongo_client.MongoClient.list_databases`.
  384: 
  385:             Unsupported read operations include, but are not limited to
  386:             :meth:`~pymongo.database.Database.command` and any getMore
  387:             operation on a cursor.
  388: 
  389:             Enabling retryable reads makes applications more resilient to
  390:             transient errors such as network failures, database upgrades, and
  391:             replica set failovers. For an exact definition of which errors
  392:             trigger a retry, see the `retryable reads specification
  393:             <https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.rst>`_.
  394: 
  395:           - `compressors`: Comma separated list of compressors for wire
  396:             protocol compression. The list is used to negotiate a compressor
  397:             with the server. Currently supported options are "snappy", "zlib"
  398:             and "zstd". Support for snappy requires the
  399:             `python-snappy <https://pypi.org/project/python-snappy/>`_ package.
  400:             zlib support requires the Python standard library zlib module. zstd
  401:             requires the `zstandard <https://pypi.org/project/zstandard/>`_
  402:             package. By default no compression is used. Compression support
  403:             must also be enabled on the server. MongoDB 3.6+ supports snappy
  404:             and zlib compression. MongoDB 4.2+ adds support for zstd.
  405:             See :ref:`network-compression-example` for details.
  406:           - `zlibCompressionLevel`: (int) The zlib compression level to use
  407:             when zlib is used as the wire protocol compressor. Supported values
  408:             are -1 through 9. -1 tells the zlib library to use its default
  409:             compression level (usually 6). 0 means no compression. 1 is best
  410:             speed. 9 is best compression. Defaults to -1.
  411:           - `uuidRepresentation`: The BSON representation to use when encoding
  412:             from and decoding to instances of :class:`~uuid.UUID`. Valid
  413:             values are the strings: "standard", "pythonLegacy", "javaLegacy",
  414:             "csharpLegacy", and "unspecified" (the default). New applications
  415:             should consider setting this to "standard" for cross language
  416:             compatibility. See :ref:`handling-uuid-data-example` for details.
  417:           - `unicode_decode_error_handler`: The error handler to apply when
  418:             a Unicode-related error occurs during BSON decoding that would
  419:             otherwise raise :exc:`UnicodeDecodeError`. Valid options include
  420:             'strict', 'replace', 'backslashreplace', 'surrogateescape', and
  421:             'ignore'. Defaults to 'strict'.
  422:           - `srvServiceName`: (string) The SRV service name to use for
  423:             "mongodb+srv://" URIs. Defaults to "mongodb". Use it like so::
  424: 
  425:                 MongoClient("mongodb+srv://example.com/?srvServiceName=customname")
  426:           - `srvMaxHosts`: (int) limits the number of mongos-like hosts a client will
  427:             connect to. More specifically, when a "mongodb+srv://" connection string
  428:             resolves to more than srvMaxHosts number of hosts, the client will randomly
  429:             choose an srvMaxHosts sized subset of hosts.
  430: 
  431: 
  432:           | **Write Concern options:**
  433:           | (Only set if passed. No default values.)
  434: 
  435:           - `w`: (integer or string) If this is a replica set, write operations
  436:             will block until they have been replicated to the specified number
  437:             or tagged set of servers. `w=<int>` always includes the replica set
  438:             primary (e.g. w=3 means write to the primary and wait until
  439:             replicated to **two** secondaries). Passing w=0 **disables write
  440:             acknowledgement** and all other write concern options.
  441:           - `wTimeoutMS`: **DEPRECATED** (integer) Used in conjunction with `w`.
  442:             Specify a value in milliseconds to control how long to wait for write propagation
  443:             to complete. If replication does not complete in the given
  444:             timeframe, a timeout exception is raised. Passing wTimeoutMS=0
  445:             will cause **write operations to wait indefinitely**.
  446:           - `journal`: If ``True`` block until write operations have been
  447:             committed to the journal. Cannot be used in combination with
  448:             `fsync`. Write operations will fail with an exception if this
  449:             option is used when the server is running without journaling.
  450:           - `fsync`: If ``True`` and the server is running without journaling,
  451:             blocks until the server has synced all data files to disk. If the
  452:             server is running with journaling, this acts the same as the `j`
  453:             option, blocking until write operations have been committed to the
  454:             journal. Cannot be used in combination with `j`.
  455: 
  456:           | **Replica set keyword arguments for connecting with a replica set
  457:             - either directly or via a mongos:**
  458: 
  459:           - `replicaSet`: (string or None) The name of the replica set to
  460:             connect to. The driver will verify that all servers it connects to
  461:             match this name. Implies that the hosts specified are a seed list
  462:             and the driver should attempt to find all members of the set.
  463:             Defaults to ``None``.
  464: 
  465:           | **Read Preference:**
  466: 
  467:           - `readPreference`: The replica set read preference for this client.
  468:             One of ``primary``, ``primaryPreferred``, ``secondary``,
  469:             ``secondaryPreferred``, or ``nearest``. Defaults to ``primary``.
  470:           - `readPreferenceTags`: Specifies a tag set as a comma-separated list
  471:             of colon-separated key-value pairs. For example ``dc:ny,rack:1``.
  472:             Defaults to ``None``.
  473:           - `maxStalenessSeconds`: (integer) The maximum estimated
  474:             length of time a replica set secondary can fall behind the primary
  475:             in replication before it will no longer be selected for operations.
  476:             Defaults to ``-1``, meaning no maximum. If maxStalenessSeconds
  477:             is set, it must be a positive integer greater than or equal to
  478:             90 seconds.
  479: 
  480:           .. seealso:: :doc:`/examples/server_selection`
  481: 
  482:           | **Authentication:**
  483: 
  484:           - `username`: A string.
  485:           - `password`: A string.
  486: 
  487:             Although username and password must be percent-escaped in a MongoDB
  488:             URI, they must not be percent-escaped when passed as parameters. In
  489:             this example, both the space and slash special characters are passed
  490:             as-is::
  491: 
  492:               MongoClient(username="user name", password="pass/word")
  493: 
  494:           - `authSource`: The database to authenticate on. Defaults to the
  495:             database specified in the URI, if provided, or to "admin".
  496:           - `authMechanism`: See :data:`~pymongo.auth.MECHANISMS` for options.
  497:             If no mechanism is specified, PyMongo automatically SCRAM-SHA-1
  498:             when connected to MongoDB 3.6 and negotiates the mechanism to use
  499:             (SCRAM-SHA-1 or SCRAM-SHA-256) when connected to MongoDB 4.0+.
  500:           - `authMechanismProperties`: Used to specify authentication mechanism
  501:             specific options. To specify the service name for GSSAPI
  502:             authentication pass authMechanismProperties='SERVICE_NAME:<service
  503:             name>'.
  504:             To specify the session token for MONGODB-AWS authentication pass
  505:             ``authMechanismProperties='AWS_SESSION_TOKEN:<session token>'``.
  506: 
  507:           .. seealso:: :doc:`/examples/authentication`
  508: 
  509:           | **TLS/SSL configuration:**
  510: 
  511:           - `tls`: (boolean) If ``True``, create the connection to the server
  512:             using transport layer security. Defaults to ``False``.
  513:           - `tlsInsecure`: (boolean) Specify whether TLS constraints should be
  514:             relaxed as much as possible. Setting ``tlsInsecure=True`` implies
  515:             ``tlsAllowInvalidCertificates=True`` and
  516:             ``tlsAllowInvalidHostnames=True``. Defaults to ``False``. Think
  517:             very carefully before setting this to ``True`` as it dramatically
  518:             reduces the security of TLS.
  519:           - `tlsAllowInvalidCertificates`: (boolean) If ``True``, continues
  520:             the TLS handshake regardless of the outcome of the certificate
  521:             verification process. If this is ``False``, and a value is not
  522:             provided for ``tlsCAFile``, PyMongo will attempt to load system
  523:             provided CA certificates. If the python version in use does not
  524:             support loading system CA certificates then the ``tlsCAFile``
  525:             parameter must point to a file of CA certificates.
  526:             ``tlsAllowInvalidCertificates=False`` implies ``tls=True``.
  527:             Defaults to ``False``. Think very carefully before setting this
  528:             to ``True`` as that could make your application vulnerable to
  529:             on-path attackers.
  530:           - `tlsAllowInvalidHostnames`: (boolean) If ``True``, disables TLS
  531:             hostname verification. ``tlsAllowInvalidHostnames=False`` implies
  532:             ``tls=True``. Defaults to ``False``. Think very carefully before
  533:             setting this to ``True`` as that could make your application
  534:             vulnerable to on-path attackers.
  535:           - `tlsCAFile`: A file containing a single or a bundle of
  536:             "certification authority" certificates, which are used to validate
  537:             certificates passed from the other end of the connection.
  538:             Implies ``tls=True``. Defaults to ``None``.
  539:           - `tlsCertificateKeyFile`: A file containing the client certificate
  540:             and private key. Implies ``tls=True``. Defaults to ``None``.
  541:           - `tlsCRLFile`: A file containing a PEM or DER formatted
  542:             certificate revocation list. Implies ``tls=True``. Defaults to
  543:             ``None``.
  544:           - `tlsCertificateKeyFilePassword`: The password or passphrase for
  545:             decrypting the private key in ``tlsCertificateKeyFile``. Only
  546:             necessary if the private key is encrypted. Defaults to ``None``.
  547:           - `tlsDisableOCSPEndpointCheck`: (boolean) If ``True``, disables
  548:             certificate revocation status checking via the OCSP responder
  549:             specified on the server certificate.
  550:             ``tlsDisableOCSPEndpointCheck=False`` implies ``tls=True``.
  551:             Defaults to ``False``.
  552:           - `ssl`: (boolean) Alias for ``tls``.
  553: 
  554:           | **Read Concern options:**
  555:           | (If not set explicitly, this will use the server default)
  556: 
  557:           - `readConcernLevel`: (string) The read concern level specifies the
  558:             level of isolation for read operations.  For example, a read
  559:             operation using a read concern level of ``majority`` will only
  560:             return data that has been written to a majority of nodes. If the
  561:             level is left unspecified, the server default will be used.
  562: 
  563:           | **Client side encryption options:**
  564:           | (If not set explicitly, client side encryption will not be enabled.)
  565: 
  566:           - `auto_encryption_opts`: A
  567:             :class:`~pymongo.encryption_options.AutoEncryptionOpts` which
  568:             configures this client to automatically encrypt collection commands
  569:             and automatically decrypt results. See
  570:             :ref:`automatic-client-side-encryption` for an example.
  571:             If a :class:`MongoClient` is configured with
  572:             ``auto_encryption_opts`` and a non-None ``maxPoolSize``, a
  573:             separate internal ``MongoClient`` is created if any of the
  574:             following are true:
  575: 
  576:               - A ``key_vault_client`` is not passed to
  577:                 :class:`~pymongo.encryption_options.AutoEncryptionOpts`
  578:               - ``bypass_auto_encrpytion=False`` is passed to
  579:                 :class:`~pymongo.encryption_options.AutoEncryptionOpts`
  580: 
  581:           | **Stable API options:**
  582:           | (If not set explicitly, Stable API will not be enabled.)
  583: 
  584:           - `server_api`: A
  585:             :class:`~pymongo.server_api.ServerApi` which configures this
  586:             client to use Stable API. See :ref:`versioned-api-ref` for
  587:             details.
  588: 
  589:         .. seealso:: The MongoDB documentation on `connections <https://dochub.mongodb.org/core/connections>`_.
  590: 
  591:         .. versionchanged:: 4.5
  592:            Added the ``serverMonitoringMode`` keyword argument.
  593: 
  594:         .. versionchanged:: 4.2
  595:            Added the ``timeoutMS`` keyword argument.
  596: 
  597:         .. versionchanged:: 4.0
  598: 
  599:              - Removed the fsync, unlock, is_locked, database_names, and
  600:                close_cursor methods.
  601:                See the :ref:`pymongo4-migration-guide`.
  602:              - Removed the ``waitQueueMultiple`` and ``socketKeepAlive``
  603:                keyword arguments.
  604:              - The default for `uuidRepresentation` was changed from
  605:                ``pythonLegacy`` to ``unspecified``.
  606:              - Added the ``srvServiceName``, ``maxConnecting``, and ``srvMaxHosts`` URI and
  607:                keyword arguments.
  608: 
  609:         .. versionchanged:: 3.12
  610:            Added the ``server_api`` keyword argument.
  611:            The following keyword arguments were deprecated:
  612: 
  613:              - ``ssl_certfile`` and ``ssl_keyfile`` were deprecated in favor
  614:                of ``tlsCertificateKeyFile``.
  615: 
  616:         .. versionchanged:: 3.11
  617:            Added the following keyword arguments and URI options:
  618: 
  619:              - ``tlsDisableOCSPEndpointCheck``
  620:              - ``directConnection``
  621: 
  622:         .. versionchanged:: 3.9
  623:            Added the ``retryReads`` keyword argument and URI option.
  624:            Added the ``tlsInsecure`` keyword argument and URI option.
  625:            The following keyword arguments and URI options were deprecated:
  626: 
  627:              - ``wTimeout`` was deprecated in favor of ``wTimeoutMS``.
  628:              - ``j`` was deprecated in favor of ``journal``.
  629:              - ``ssl_cert_reqs`` was deprecated in favor of
  630:                ``tlsAllowInvalidCertificates``.
  631:              - ``ssl_match_hostname`` was deprecated in favor of
  632:                ``tlsAllowInvalidHostnames``.
  633:              - ``ssl_ca_certs`` was deprecated in favor of ``tlsCAFile``.
  634:              - ``ssl_certfile`` was deprecated in favor of
  635:                ``tlsCertificateKeyFile``.
  636:              - ``ssl_crlfile`` was deprecated in favor of ``tlsCRLFile``.
  637:              - ``ssl_pem_passphrase`` was deprecated in favor of
  638:                ``tlsCertificateKeyFilePassword``.
  639: 
  640:         .. versionchanged:: 3.9
  641:            ``retryWrites`` now defaults to ``True``.
  642: 
  643:         .. versionchanged:: 3.8
  644:            Added the ``server_selector`` keyword argument.
  645:            Added the ``type_registry`` keyword argument.
  646: 
  647:         .. versionchanged:: 3.7
  648:            Added the ``driver`` keyword argument.
  649: 
  650:         .. versionchanged:: 3.6
  651:            Added support for mongodb+srv:// URIs.
  652:            Added the ``retryWrites`` keyword argument and URI option.
  653: 
  654:         .. versionchanged:: 3.5
  655:            Add ``username`` and ``password`` options. Document the
  656:            ``authSource``, ``authMechanism``, and ``authMechanismProperties``
  657:            options.
  658:            Deprecated the ``socketKeepAlive`` keyword argument and URI option.
  659:            ``socketKeepAlive`` now defaults to ``True``.
  660: 
  661:         .. versionchanged:: 3.0
  662:            :class:`~pymongo.mongo_client.MongoClient` is now the one and only
  663:            client class for a standalone server, mongos, or replica set.
  664:            It includes the functionality that had been split into
  665:            :class:`~pymongo.mongo_client.MongoReplicaSetClient`: it can connect
  666:            to a replica set, discover all its members, and monitor the set for
  667:            stepdowns, elections, and reconfigs.
  668: 
  669:            The :class:`~pymongo.mongo_client.MongoClient` constructor no
  670:            longer blocks while connecting to the server or servers, and it no
  671:            longer raises :class:`~pymongo.errors.ConnectionFailure` if they
  672:            are unavailable, nor :class:`~pymongo.errors.ConfigurationError`
  673:            if the user's credentials are wrong. Instead, the constructor
  674:            returns immediately and launches the connection process on
  675:            background threads.
  676: 
  677:            Therefore the ``alive`` method is removed since it no longer
  678:            provides meaningful information; even if the client is disconnected,
  679:            it may discover a server in time to fulfill the next operation.
  680: 
  681:            In PyMongo 2.x, :class:`~pymongo.MongoClient` accepted a list of
  682:            standalone MongoDB servers and used the first it could connect to::
  683: 
  684:                MongoClient(['host1.com:27017', 'host2.com:27017'])
  685: 
  686:            A list of multiple standalones is no longer supported; if multiple
  687:            servers are listed they must be members of the same replica set, or
  688:            mongoses in the same sharded cluster.
  689: 
  690:            The behavior for a list of mongoses is changed from "high
  691:            availability" to "load balancing". Before, the client connected to
  692:            the lowest-latency mongos in the list, and used it until a network
  693:            error prompted it to re-evaluate all mongoses' latencies and
  694:            reconnect to one of them. In PyMongo 3, the client monitors its
  695:            network latency to all the mongoses continuously, and distributes
  696:            operations evenly among those with the lowest latency. See
  697:            :ref:`mongos-load-balancing` for more information.
  698: 
  699:            The ``connect`` option is added.
  700: 
  701:            The ``start_request``, ``in_request``, and ``end_request`` methods
  702:            are removed, as well as the ``auto_start_request`` option.
  703: 
  704:            The ``copy_database`` method is removed, see the
  705:            :doc:`copy_database examples </examples/copydb>` for alternatives.
  706: 
  707:            The :meth:`MongoClient.disconnect` method is removed; it was a
  708:            synonym for :meth:`~pymongo.MongoClient.close`.
  709: 
  710:            :class:`~pymongo.mongo_client.MongoClient` no longer returns an
  711:            instance of :class:`~pymongo.database.Database` for attribute names
  712:            with leading underscores. You must use dict-style lookups instead::
  713: 
  714:                client['__my_database__']
  715: 
  716:            Not::
  717: 
  718:                client.__my_database__
  719: 
  720:         .. versionchanged:: 4.7
  721:             Deprecated parameter ``wTimeoutMS``, use :meth:`~pymongo.timeout`.
  722:         """
  723:         doc_class = document_class or dict
  724:         self.__init_kwargs: dict[str, Any] = {
  725:             "host": host,
  726:             "port": port,
  727:             "document_class": doc_class,
  728:             "tz_aware": tz_aware,
  729:             "connect": connect,
  730:             "type_registry": type_registry,
  731:             **kwargs,
  732:         }
  733: 
  734:         if host is None:
  735:             host = self.HOST
  736:         if isinstance(host, str):
  737:             host = [host]
  738:         if port is None:
  739:             port = self.PORT
  740:         if not isinstance(port, int):
  741:             raise TypeError("port must be an instance of int")
  742: 
  743:         # _pool_class, _monitor_class, and _condition_class are for deep
  744:         # customization of PyMongo, e.g. Motor.
  745:         pool_class = kwargs.pop("_pool_class", None)
  746:         monitor_class = kwargs.pop("_monitor_class", None)
  747:         condition_class = kwargs.pop("_condition_class", None)
  748: 
  749:         # Parse options passed as kwargs.
  750:         keyword_opts = common._CaseInsensitiveDictionary(kwargs)
  751:         keyword_opts["document_class"] = doc_class
  752: 
  753:         seeds = set()
  754:         username = None
  755:         password = None
  756:         dbase = None
  757:         opts = common._CaseInsensitiveDictionary()
  758:         fqdn = None
  759:         srv_service_name = keyword_opts.get("srvservicename")
  760:         srv_max_hosts = keyword_opts.get("srvmaxhosts")
  761:         if len([h for h in host if "/" in h]) > 1:
  762:             raise ConfigurationError("host must not contain multiple MongoDB URIs")
  763:         for entity in host:
  764:             # A hostname can only include a-z, 0-9, '-' and '.'. If we find a '/'
  765:             # it must be a URI,
  766:             # https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
  767:             if "/" in entity:
  768:                 # Determine connection timeout from kwargs.
  769:                 timeout = keyword_opts.get("connecttimeoutms")
  770:                 if timeout is not None:
  771:                     timeout = common.validate_timeout_or_none_or_zero(
  772:                         keyword_opts.cased_key("connecttimeoutms"), timeout
  773:                     )
  774:                 res = uri_parser.parse_uri(
  775:                     entity,
  776:                     port,
  777:                     validate=True,
  778:                     warn=True,
  779:                     normalize=False,
  780:                     connect_timeout=timeout,
  781:                     srv_service_name=srv_service_name,
  782:                     srv_max_hosts=srv_max_hosts,
  783:                 )
  784:                 seeds.update(res["nodelist"])
  785:                 username = res["username"] or username
  786:                 password = res["password"] or password
  787:                 dbase = res["database"] or dbase
  788:                 opts = res["options"]
  789:                 fqdn = res["fqdn"]
  790:             else:
  791:                 seeds.update(uri_parser.split_hosts(entity, port))
  792:         if not seeds:
  793:             raise ConfigurationError("need to specify at least one host")
  794: 
  795:         for hostname in [node[0] for node in seeds]:
  796:             if _detect_external_db(hostname):
  797:                 break
  798: 
  799:         # Add options with named keyword arguments to the parsed kwarg options.
  800:         if type_registry is not None:
  801:             keyword_opts["type_registry"] = type_registry
  802:         if tz_aware is None:
  803:             tz_aware = opts.get("tz_aware", False)
  804:         if connect is None:
  805:             connect = opts.get("connect", True)
  806:         keyword_opts["tz_aware"] = tz_aware
  807:         keyword_opts["connect"] = connect
  808: 
  809:         # Handle deprecated options in kwarg options.
  810:         keyword_opts = _handle_option_deprecations(keyword_opts)
  811:         # Validate kwarg options.
  812:         keyword_opts = common._CaseInsensitiveDictionary(
  813:             dict(common.validate(keyword_opts.cased_key(k), v) for k, v in keyword_opts.items())
  814:         )
  815: 
  816:         # Override connection string options with kwarg options.
  817:         opts.update(keyword_opts)
  818: 
  819:         if srv_service_name is None:
  820:             srv_service_name = opts.get("srvServiceName", common.SRV_SERVICE_NAME)
  821: 
  822:         srv_max_hosts = srv_max_hosts or opts.get("srvmaxhosts")
  823:         # Handle security-option conflicts in combined options.
  824:         opts = _handle_security_options(opts)
  825:         # Normalize combined options.
  826:         opts = _normalize_options(opts)
  827:         _check_options(seeds, opts)
  828: 
  829:         # Username and password passed as kwargs override user info in URI.
  830:         username = opts.get("username", username)
  831:         password = opts.get("password", password)
  832:         self.__options = options = ClientOptions(username, password, dbase, opts)
  833: 
  834:         self.__default_database_name = dbase
  835:         self.__lock = _create_lock()
  836:         self.__kill_cursors_queue: list = []
  837: 
  838:         self._event_listeners = options.pool_options._event_listeners
  839:         super().__init__(
  840:             options.codec_options,
  841:             options.read_preference,
  842:             options.write_concern,
  843:             options.read_concern,
  844:         )
  845: 
  846:         self._topology_settings = TopologySettings(
  847:             seeds=seeds,
  848:             replica_set_name=options.replica_set_name,
  849:             pool_class=pool_class,
  850:             pool_options=options.pool_options,
  851:             monitor_class=monitor_class,
  852:             condition_class=condition_class,
  853:             local_threshold_ms=options.local_threshold_ms,
  854:             server_selection_timeout=options.server_selection_timeout,
  855:             server_selector=options.server_selector,
  856:             heartbeat_frequency=options.heartbeat_frequency,
  857:             fqdn=fqdn,
  858:             direct_connection=options.direct_connection,
  859:             load_balanced=options.load_balanced,
  860:             srv_service_name=srv_service_name,
  861:             srv_max_hosts=srv_max_hosts,
  862:             server_monitoring_mode=options.server_monitoring_mode,
  863:         )
  864: 
  865:         self._opened = False
  866:         self._init_background()
  867: 
  868:         if connect:
  869:             self._get_topology()
  870: 
  871:         self._encrypter = None
  872:         if self.__options.auto_encryption_opts:
  873:             from pymongo.encryption import _Encrypter
  874: 
  875:             self._encrypter = _Encrypter(self, self.__options.auto_encryption_opts)
  876:         self._timeout = self.__options.timeout
  877: 
  878:         if _HAS_REGISTER_AT_FORK:
  879:             # Add this client to the list of weakly referenced items.
  880:             # This will be used later if we fork.
  881:             MongoClient._clients[self._topology._topology_id] = self
  882: 
  883:     def _init_background(self, old_pid: Optional[int] = None) -> None:
  884:         self._topology = Topology(self._topology_settings)
  885:         # Seed the topology with the old one's pid so we can detect clients
  886:         # that are opened before a fork and used after.
  887:         self._topology._pid = old_pid
  888: 
  889:         def target() -> bool:
  890:             client = self_ref()
  891:             if client is None:
  892:                 return False  # Stop the executor.
  893:             MongoClient._process_periodic_tasks(client)
  894:             return True
  895: 
  896:         executor = periodic_executor.PeriodicExecutor(
  897:             interval=common.KILL_CURSOR_FREQUENCY,
  898:             min_interval=common.MIN_HEARTBEAT_INTERVAL,
  899:             target=target,
  900:             name="pymongo_kill_cursors_thread",
  901:         )
  902: 
  903:         # We strongly reference the executor and it weakly references us via
  904:         # this closure. When the client is freed, stop the executor soon.
  905:         self_ref: Any = weakref.ref(self, executor.close)
  906:         self._kill_cursors_executor = executor
  907:         self._opened = False
  908: 
  909:     def _after_fork(self) -> None:
  910:         """Resets topology in a child after successfully forking."""
  911:         self._init_background(self._topology._pid)
  912:         # Reset the session pool to avoid duplicate sessions in the child process.
  913:         self._topology._session_pool.reset()
  914: 
  915:     def _duplicate(self, **kwargs: Any) -> MongoClient:
  916:         args = self.__init_kwargs.copy()
  917:         args.update(kwargs)
  918:         return MongoClient(**args)
  919: 
  920:     def _server_property(self, attr_name: str) -> Any:
  921:         """An attribute of the current server's description.
  922: 
  923:         If the client is not connected, this will block until a connection is
  924:         established or raise ServerSelectionTimeoutError if no server is
  925:         available.
  926: 
  927:         Not threadsafe if used multiple times in a single method, since
  928:         the server may change. In such cases, store a local reference to a
  929:         ServerDescription first, then use its properties.
  930:         """
  931:         server = self._get_topology().select_server(writable_server_selector, _Op.TEST)
  932: 
  933:         return getattr(server.description, attr_name)
  934: 
  935:     def watch(
  936:         self,
  937:         pipeline: Optional[_Pipeline] = None,
  938:         full_document: Optional[str] = None,
  939:         resume_after: Optional[Mapping[str, Any]] = None,
  940:         max_await_time_ms: Optional[int] = None,
  941:         batch_size: Optional[int] = None,
  942:         collation: Optional[_CollationIn] = None,
  943:         start_at_operation_time: Optional[Timestamp] = None,
  944:         session: Optional[client_session.ClientSession] = None,
  945:         start_after: Optional[Mapping[str, Any]] = None,
  946:         comment: Optional[Any] = None,
  947:         full_document_before_change: Optional[str] = None,
  948:         show_expanded_events: Optional[bool] = None,
  949:     ) -> ChangeStream[_DocumentType]:
  950:         """Watch changes on this cluster.
  951: 
  952:         Performs an aggregation with an implicit initial ``$changeStream``
  953:         stage and returns a
  954:         :class:`~pymongo.change_stream.ClusterChangeStream` cursor which
  955:         iterates over changes on all databases on this cluster.
  956: 
  957:         Introduced in MongoDB 4.0.
  958: 
  959:         .. code-block:: python
  960: 
  961:            with client.watch() as stream:
  962:                for change in stream:
  963:                    print(change)
  964: 
  965:         The :class:`~pymongo.change_stream.ClusterChangeStream` iterable
  966:         blocks until the next change document is returned or an error is
  967:         raised. If the
  968:         :meth:`~pymongo.change_stream.ClusterChangeStream.next` method
  969:         encounters a network error when retrieving a batch from the server,
  970:         it will automatically attempt to recreate the cursor such that no
  971:         change events are missed. Any error encountered during the resume
  972:         attempt indicates there may be an outage and will be raised.
  973: 
  974:         .. code-block:: python
  975: 
  976:             try:
  977:                 with client.watch([{"$match": {"operationType": "insert"}}]) as stream:
  978:                     for insert_change in stream:
  979:                         print(insert_change)
  980:             except pymongo.errors.PyMongoError:
  981:                 # The ChangeStream encountered an unrecoverable error or the
  982:                 # resume attempt failed to recreate the cursor.
  983:                 logging.error("...")
  984: 
  985:         For a precise description of the resume process see the
  986:         `change streams specification`_.
  987: 
  988:         :param pipeline: A list of aggregation pipeline stages to
  989:             append to an initial ``$changeStream`` stage. Not all
  990:             pipeline stages are valid after a ``$changeStream`` stage, see the
  991:             MongoDB documentation on change streams for the supported stages.
  992:         :param full_document: The fullDocument to pass as an option
  993:             to the ``$changeStream`` stage. Allowed values: 'updateLookup',
  994:             'whenAvailable', 'required'. When set to 'updateLookup', the
  995:             change notification for partial updates will include both a delta
  996:             describing the changes to the document, as well as a copy of the
  997:             entire document that was changed from some time after the change
  998:             occurred.
  999:         :param full_document_before_change: Allowed values: 'whenAvailable'
 1000:             and 'required'. Change events may now result in a
 1001:             'fullDocumentBeforeChange' response field.
 1002:         :param resume_after: A resume token. If provided, the
 1003:             change stream will start returning changes that occur directly
 1004:             after the operation specified in the resume token. A resume token
 1005:             is the _id value of a change document.
 1006:         :param max_await_time_ms: The maximum time in milliseconds
 1007:             for the server to wait for changes before responding to a getMore
 1008:             operation.
 1009:         :param batch_size: The maximum number of documents to return
 1010:             per batch.
 1011:         :param collation: The :class:`~pymongo.collation.Collation`
 1012:             to use for the aggregation.
 1013:         :param start_at_operation_time: If provided, the resulting
 1014:             change stream will only return changes that occurred at or after
 1015:             the specified :class:`~bson.timestamp.Timestamp`. Requires
 1016:             MongoDB >= 4.0.
 1017:         :param session: a
 1018:             :class:`~pymongo.client_session.ClientSession`.
 1019:         :param start_after: The same as `resume_after` except that
 1020:             `start_after` can resume notifications after an invalidate event.
 1021:             This option and `resume_after` are mutually exclusive.
 1022:         :param comment: A user-provided comment to attach to this
 1023:             command.
 1024:         :param show_expanded_events: Include expanded events such as DDL events like `dropIndexes`.
 1025: 
 1026:         :return: A :class:`~pymongo.change_stream.ClusterChangeStream` cursor.
 1027: 
 1028:         .. versionchanged:: 4.3
 1029:            Added `show_expanded_events` parameter.
 1030: 
 1031:         .. versionchanged:: 4.2
 1032:             Added ``full_document_before_change`` parameter.
 1033: 
 1034:         .. versionchanged:: 4.1
 1035:            Added ``comment`` parameter.
 1036: 
 1037:         .. versionchanged:: 3.9
 1038:            Added the ``start_after`` parameter.
 1039: 
 1040:         .. versionadded:: 3.7
 1041: 
 1042:         .. seealso:: The MongoDB documentation on `changeStreams <https://mongodb.com/docs/manual/changeStreams/>`_.
 1043: 
 1044:         .. _change streams specification:
 1045:             https://github.com/mongodb/specifications/blob/master/source/change-streams/change-streams.md
 1046:         """
 1047:         return ClusterChangeStream(
 1048:             self.admin,
 1049:             pipeline,
 1050:             full_document,
 1051:             resume_after,
 1052:             max_await_time_ms,
 1053:             batch_size,
 1054:             collation,
 1055:             start_at_operation_time,
 1056:             session,
 1057:             start_after,
 1058:             comment,
 1059:             full_document_before_change,
 1060:             show_expanded_events=show_expanded_events,
 1061:         )
 1062: 
 1063:     @property
 1064:     def topology_description(self) -> TopologyDescription:
 1065:         """The description of the connected MongoDB deployment.
 1066: 
 1067:         >>> client.topology_description
 1068:         <TopologyDescription id: 605a7b04e76489833a7c6113, topology_type: ReplicaSetWithPrimary, servers: [<ServerDescription ('localhost', 27017) server_type: RSPrimary, rtt: 0.0007973677999995488>, <ServerDescription ('localhost', 27018) server_type: RSSecondary, rtt: 0.0005540556000003249>, <ServerDescription ('localhost', 27019) server_type: RSSecondary, rtt: 0.0010367483999999649>]>
 1069:         >>> client.topology_description.topology_type_name
 1070:         'ReplicaSetWithPrimary'
 1071: 
 1072:         Note that the description is periodically updated in the background
 1073:         but the returned object itself is immutable. Access this property again
 1074:         to get a more recent
 1075:         :class:`~pymongo.topology_description.TopologyDescription`.
 1076: 
 1077:         :return: An instance of
 1078:           :class:`~pymongo.topology_description.TopologyDescription`.
 1079: 
 1080:         .. versionadded:: 4.0
 1081:         """
 1082:         return self._topology.description
 1083: 
 1084:     @property
 1085:     def address(self) -> Optional[tuple[str, int]]:
 1086:         """(host, port) of the current standalone, primary, or mongos, or None.
 1087: 
 1088:         Accessing :attr:`address` raises :exc:`~.errors.InvalidOperation` if
 1089:         the client is load-balancing among mongoses, since there is no single
 1090:         address. Use :attr:`nodes` instead.
 1091: 
 1092:         If the client is not connected, this will block until a connection is
 1093:         established or raise ServerSelectionTimeoutError if no server is
 1094:         available.
 1095: 
 1096:         .. versionadded:: 3.0
 1097:         """
 1098:         topology_type = self._topology._description.topology_type
 1099:         if (
 1100:             topology_type == TOPOLOGY_TYPE.Sharded
 1101:             and len(self.topology_description.server_descriptions()) > 1
 1102:         ):
 1103:             raise InvalidOperation(
 1104:                 'Cannot use "address" property when load balancing among'
 1105:                 ' mongoses, use "nodes" instead.'
 1106:             )
 1107:         if topology_type not in (
 1108:             TOPOLOGY_TYPE.ReplicaSetWithPrimary,
 1109:             TOPOLOGY_TYPE.Single,
 1110:             TOPOLOGY_TYPE.LoadBalanced,
 1111:             TOPOLOGY_TYPE.Sharded,
 1112:         ):
 1113:             return None
 1114:         return self._server_property("address")
 1115: 
 1116:     @property
 1117:     def primary(self) -> Optional[tuple[str, int]]:
 1118:         """The (host, port) of the current primary of the replica set.
 1119: 
 1120:         Returns ``None`` if this client is not connected to a replica set,
 1121:         there is no primary, or this client was created without the
 1122:         `replicaSet` option.
 1123: 
 1124:         .. versionadded:: 3.0
 1125:            MongoClient gained this property in version 3.0.
 1126:         """
 1127:         return self._topology.get_primary()  # type: ignore[return-value]
 1128: 
 1129:     @property
 1130:     def secondaries(self) -> set[_Address]:
 1131:         """The secondary members known to this client.
 1132: 
 1133:         A sequence of (host, port) pairs. Empty if this client is not
 1134:         connected to a replica set, there are no visible secondaries, or this
 1135:         client was created without the `replicaSet` option.
 1136: 
 1137:         .. versionadded:: 3.0
 1138:            MongoClient gained this property in version 3.0.
 1139:         """
 1140:         return self._topology.get_secondaries()
 1141: 
 1142:     @property
 1143:     def arbiters(self) -> set[_Address]:
 1144:         """Arbiters in the replica set.
 1145: 
 1146:         A sequence of (host, port) pairs. Empty if this client is not
 1147:         connected to a replica set, there are no arbiters, or this client was
 1148:         created without the `replicaSet` option.
 1149:         """
 1150:         return self._topology.get_arbiters()
 1151: 
 1152:     @property
 1153:     def is_primary(self) -> bool:
 1154:         """If this client is connected to a server that can accept writes.
 1155: 
 1156:         True if the current server is a standalone, mongos, or the primary of
 1157:         a replica set. If the client is not connected, this will block until a
 1158:         connection is established or raise ServerSelectionTimeoutError if no
 1159:         server is available.
 1160:         """
 1161:         return self._server_property("is_writable")
 1162: 
 1163:     @property
 1164:     def is_mongos(self) -> bool:
 1165:         """If this client is connected to mongos. If the client is not
 1166:         connected, this will block until a connection is established or raise
 1167:         ServerSelectionTimeoutError if no server is available.
 1168:         """
 1169:         return self._server_property("server_type") == SERVER_TYPE.Mongos
 1170: 
 1171:     @property
 1172:     def nodes(self) -> FrozenSet[_Address]:
 1173:         """Set of all currently connected servers.
 1174: 
 1175:         .. warning:: When connected to a replica set the value of :attr:`nodes`
 1176:           can change over time as :class:`MongoClient`'s view of the replica
 1177:           set changes. :attr:`nodes` can also be an empty set when
 1178:           :class:`MongoClient` is first instantiated and hasn't yet connected
 1179:           to any servers, or a network partition causes it to lose connection
 1180:           to all servers.
 1181:         """
 1182:         description = self._topology.description
 1183:         return frozenset(s.address for s in description.known_servers)
 1184: 
 1185:     @property
 1186:     def options(self) -> ClientOptions:
 1187:         """The configuration options for this client.
 1188: 
 1189:         :return: An instance of :class:`~pymongo.client_options.ClientOptions`.
 1190: 
 1191:         .. versionadded:: 4.0
 1192:         """
 1193:         return self.__options
 1194: 
 1195:     def _end_sessions(self, session_ids: list[_ServerSession]) -> None:
 1196:         """Send endSessions command(s) with the given session ids."""
 1197:         try:
 1198:             # Use Connection.command directly to avoid implicitly creating
 1199:             # another session.
 1200:             with self._conn_for_reads(
 1201:                 ReadPreference.PRIMARY_PREFERRED, None, operation=_Op.END_SESSIONS
 1202:             ) as (
 1203:                 conn,
 1204:                 read_pref,
 1205:             ):
 1206:                 if not conn.supports_sessions:
 1207:                     return
 1208: 
 1209:                 for i in range(0, len(session_ids), common._MAX_END_SESSIONS):
 1210:                     spec = {"endSessions": session_ids[i : i + common._MAX_END_SESSIONS]}
 1211:                     conn.command("admin", spec, read_preference=read_pref, client=self)
 1212:         except PyMongoError:
 1213:             # Drivers MUST ignore any errors returned by the endSessions
 1214:             # command.
 1215:             pass
 1216: 
 1217:     def close(self) -> None:
 1218:         """Cleanup client resources and disconnect from MongoDB.
 1219: 
 1220:         End all server sessions created by this client by sending one or more
 1221:         endSessions commands.
 1222: 
 1223:         Close all sockets in the connection pools and stop the monitor threads.
 1224: 
 1225:         .. versionchanged:: 4.0
 1226:            Once closed, the client cannot be used again and any attempt will
 1227:            raise :exc:`~pymongo.errors.InvalidOperation`.
 1228: 
 1229:         .. versionchanged:: 3.6
 1230:            End all server sessions created by this client.
 1231:         """
 1232:         session_ids = self._topology.pop_all_sessions()
 1233:         if session_ids:
 1234:             self._end_sessions(session_ids)
 1235:         # Stop the periodic task thread and then send pending killCursor
 1236:         # requests before closing the topology.
 1237:         self._kill_cursors_executor.close()
 1238:         self._process_kill_cursors()
 1239:         self._topology.close()
 1240:         if self._encrypter:
 1241:             # TODO: PYTHON-1921 Encrypted MongoClients cannot be re-opened.
 1242:             self._encrypter.close()
 1243: 
 1244:     def _get_topology(self) -> Topology:
 1245:         """Get the internal :class:`~pymongo.topology.Topology` object.
 1246: 
 1247:         If this client was created with "connect=False", calling _get_topology
 1248:         launches the connection process in the background.
 1249:         """
 1250:         if not self._opened:
 1251:             self._topology.open()
 1252:             with self.__lock:
 1253:                 self._kill_cursors_executor.open()
 1254:             self._opened = True
 1255:         return self._topology
 1256: 
 1257:     @contextlib.contextmanager
 1258:     def _checkout(self, server: Server, session: Optional[ClientSession]) -> Iterator[Connection]:
 1259:         in_txn = session and session.in_transaction
 1260:         with _MongoClientErrorHandler(self, server, session) as err_handler:
 1261:             # Reuse the pinned connection, if it exists.
 1262:             if in_txn and session and session._pinned_connection:
 1263:                 err_handler.contribute_socket(session._pinned_connection)
 1264:                 yield session._pinned_connection
 1265:                 return
 1266:             with server.checkout(handler=err_handler) as conn:
 1267:                 # Pin this session to the selected server or connection.
 1268:                 if (
 1269:                     in_txn
 1270:                     and session
 1271:                     and server.description.server_type
 1272:                     in (
 1273:                         SERVER_TYPE.Mongos,
 1274:                         SERVER_TYPE.LoadBalancer,
 1275:                     )
 1276:                 ):
 1277:                     session._pin(server, conn)
 1278:                 err_handler.contribute_socket(conn)
 1279:                 if (
 1280:                     self._encrypter
 1281:                     and not self._encrypter._bypass_auto_encryption
 1282:                     and conn.max_wire_version < 8
 1283:                 ):
 1284:                     raise ConfigurationError(
 1285:                         "Auto-encryption requires a minimum MongoDB version of 4.2"
 1286:                     )
 1287:                 yield conn
 1288: 
 1289:     def _select_server(
 1290:         self,
 1291:         server_selector: Callable[[Selection], Selection],
 1292:         session: Optional[ClientSession],
 1293:         operation: str,
 1294:         address: Optional[_Address] = None,
 1295:         deprioritized_servers: Optional[list[Server]] = None,
 1296:         operation_id: Optional[int] = None,
 1297:     ) -> Server:
 1298:         """Select a server to run an operation on this client.
 1299: 
 1300:         :param server_selector: The server selector to use if the session is
 1301:             not pinned and no address is given.
 1302:         :param session: The ClientSession for the next operation, or None. May
 1303:             be pinned to a mongos server address.
 1304:         :param operation: The name of the operation that the server is being selected for.
 1305:         :param address: Address when sending a message
 1306:             to a specific server, used for getMore.
 1307:         """
 1308:         try:
 1309:             topology = self._get_topology()
 1310:             if session and not session.in_transaction:
 1311:                 session._transaction.reset()
 1312:             if not address and session:
 1313:                 address = session._pinned_address
 1314:             if address:
 1315:                 # We're running a getMore or this session is pinned to a mongos.
 1316:                 server = topology.select_server_by_address(
 1317:                     address, operation, operation_id=operation_id
 1318:                 )
 1319:                 if not server:
 1320:                     raise AutoReconnect("server %s:%s no longer available" % address)  # noqa: UP031
 1321:             else:
 1322:                 server = topology.select_server(
 1323:                     server_selector,
 1324:                     operation,
 1325:                     deprioritized_servers=deprioritized_servers,
 1326:                     operation_id=operation_id,
 1327:                 )
 1328:             return server
 1329:         except PyMongoError as exc:
 1330:             # Server selection errors in a transaction are transient.
 1331:             if session and session.in_transaction:
 1332:                 exc._add_error_label("TransientTransactionError")
 1333:                 session._unpin()
 1334:             raise
 1335: 
 1336:     def _conn_for_writes(
 1337:         self, session: Optional[ClientSession], operation: str
 1338:     ) -> ContextManager[Connection]:
 1339:         server = self._select_server(writable_server_selector, session, operation)
 1340:         return self._checkout(server, session)
 1341: 
 1342:     @contextlib.contextmanager
 1343:     def _conn_from_server(
 1344:         self, read_preference: _ServerMode, server: Server, session: Optional[ClientSession]
 1345:     ) -> Iterator[tuple[Connection, _ServerMode]]:
 1346:         assert read_preference is not None, "read_preference must not be None"
 1347:         # Get a connection for a server matching the read preference, and yield
 1348:         # conn with the effective read preference. The Server Selection
 1349:         # Spec says not to send any $readPreference to standalones and to
 1350:         # always send primaryPreferred when directly connected to a repl set
 1351:         # member.
 1352:         # Thread safe: if the type is single it cannot change.
 1353:         # NOTE: We already opened the Topology when selecting a server so there's no need
 1354:         # to call _get_topology() again.
 1355:         single = self._topology.description.topology_type == TOPOLOGY_TYPE.Single
 1356: 
 1357:         with self._checkout(server, session) as conn:
 1358:             if single:
 1359:                 if conn.is_repl and not (session and session.in_transaction):
 1360:                     # Use primary preferred to ensure any repl set member
 1361:                     # can handle the request.
 1362:                     read_preference = ReadPreference.PRIMARY_PREFERRED
 1363:                 elif conn.is_standalone:
 1364:                     # Don't send read preference to standalones.
 1365:                     read_preference = ReadPreference.PRIMARY
 1366:             yield conn, read_preference
 1367: 
 1368:     def _conn_for_reads(
 1369:         self,
 1370:         read_preference: _ServerMode,
 1371:         session: Optional[ClientSession],
 1372:         operation: str,
 1373:     ) -> ContextManager[tuple[Connection, _ServerMode]]:
 1374:         assert read_preference is not None, "read_preference must not be None"
 1375:         server = self._select_server(read_preference, session, operation)
 1376:         return self._conn_from_server(read_preference, server, session)
 1377: 
 1378:     def _should_pin_cursor(self, session: Optional[ClientSession]) -> Optional[bool]:
 1379:         return self.__options.load_balanced and not (session and session.in_transaction)
 1380: 
 1381:     @_csot.apply
 1382:     def _run_operation(
 1383:         self,
 1384:         operation: Union[_Query, _GetMore],
 1385:         unpack_res: Callable,
 1386:         address: Optional[_Address] = None,
 1387:     ) -> Response:
 1388:         """Run a _Query/_GetMore operation and return a Response.
 1389: 
 1390:         :param operation: a _Query or _GetMore object.
 1391:         :param unpack_res: A callable that decodes the wire protocol response.
 1392:         :param address: Optional address when sending a message
 1393:             to a specific server, used for getMore.
 1394:         """
 1395:         if operation.conn_mgr:
 1396:             server = self._select_server(
 1397:                 operation.read_preference,
 1398:                 operation.session,
 1399:                 operation.name,
 1400:                 address=address,
 1401:             )
 1402: 
 1403:             with operation.conn_mgr.lock:
 1404:                 with _MongoClientErrorHandler(self, server, operation.session) as err_handler:
 1405:                     err_handler.contribute_socket(operation.conn_mgr.conn)
 1406:                     return server.run_operation(
 1407:                         operation.conn_mgr.conn,
 1408:                         operation,
 1409:                         operation.read_preference,
 1410:                         self._event_listeners,
 1411:                         unpack_res,
 1412:                         self,
 1413:                     )
 1414: 
 1415:         def _cmd(
 1416:             _session: Optional[ClientSession],
 1417:             server: Server,
 1418:             conn: Connection,
 1419:             read_preference: _ServerMode,
 1420:         ) -> Response:
 1421:             operation.reset()  # Reset op in case of retry.
 1422:             return server.run_operation(
 1423:                 conn,
 1424:                 operation,
 1425:                 read_preference,
 1426:                 self._event_listeners,
 1427:                 unpack_res,
 1428:                 self,
 1429:             )
 1430: 
 1431:         return self._retryable_read(
 1432:             _cmd,
 1433:             operation.read_preference,
 1434:             operation.session,
 1435:             address=address,
 1436:             retryable=isinstance(operation, message._Query),
 1437:             operation=operation.name,
 1438:         )
 1439: 
 1440:     def _retry_with_session(
 1441:         self,
 1442:         retryable: bool,
 1443:         func: _WriteCall[T],
 1444:         session: Optional[ClientSession],
 1445:         bulk: Optional[_Bulk],
 1446:         operation: str,
 1447:         operation_id: Optional[int] = None,
 1448:     ) -> T:
 1449:         """Execute an operation with at most one consecutive retries
 1450: 
 1451:         Returns func()'s return value on success. On error retries the same
 1452:         command.
 1453: 
 1454:         Re-raises any exception thrown by func().
 1455:         """
 1456:         # Ensure that the options supports retry_writes and there is a valid session not in
 1457:         # transaction, otherwise, we will not support retry behavior for this txn.
 1458:         retryable = bool(
 1459:             retryable and self.options.retry_writes and session and not session.in_transaction
 1460:         )
 1461:         return self._retry_internal(
 1462:             func=func,
 1463:             session=session,
 1464:             bulk=bulk,
 1465:             operation=operation,
 1466:             retryable=retryable,
 1467:             operation_id=operation_id,
 1468:         )
 1469: 
 1470:     @_csot.apply
 1471:     def _retry_internal(
 1472:         self,
 1473:         func: _WriteCall[T] | _ReadCall[T],
 1474:         session: Optional[ClientSession],
 1475:         bulk: Optional[_Bulk],
 1476:         operation: str,
 1477:         is_read: bool = False,
 1478:         address: Optional[_Address] = None,
 1479:         read_pref: Optional[_ServerMode] = None,
 1480:         retryable: bool = False,
 1481:         operation_id: Optional[int] = None,
 1482:     ) -> T:
 1483:         """Internal retryable helper for all client transactions.
 1484: 
 1485:         :param func: Callback function we want to retry
 1486:         :param session: Client Session on which the transaction should occur
 1487:         :param bulk: Abstraction to handle bulk write operations
 1488:         :param operation: The name of the operation that the server is being selected for
 1489:         :param is_read: If this is an exclusive read transaction, defaults to False
 1490:         :param address: Server Address, defaults to None
 1491:         :param read_pref: Topology of read operation, defaults to None
 1492:         :param retryable: If the operation should be retried once, defaults to None
 1493: 
 1494:         :return: Output of the calling func()
 1495:         """
 1496:         return _ClientConnectionRetryable(
 1497:             mongo_client=self,
 1498:             func=func,
 1499:             bulk=bulk,
 1500:             operation=operation,
 1501:             is_read=is_read,
 1502:             session=session,
 1503:             read_pref=read_pref,
 1504:             address=address,
 1505:             retryable=retryable,
 1506:             operation_id=operation_id,
 1507:         ).run()
 1508: 
 1509:     def _retryable_read(
 1510:         self,
 1511:         func: _ReadCall[T],
 1512:         read_pref: _ServerMode,
 1513:         session: Optional[ClientSession],
 1514:         operation: str,
 1515:         address: Optional[_Address] = None,
 1516:         retryable: bool = True,
 1517:         operation_id: Optional[int] = None,
 1518:     ) -> T:
 1519:         """Execute an operation with consecutive retries if possible
 1520: 
 1521:         Returns func()'s return value on success. On error retries the same
 1522:         command.
 1523: 
 1524:         Re-raises any exception thrown by func().
 1525: 
 1526:         :param func: Read call we want to execute
 1527:         :param read_pref: Desired topology of read operation
 1528:         :param session: Client session we should use to execute operation
 1529:         :param operation: The name of the operation that the server is being selected for
 1530:         :param address: Optional address when sending a message, defaults to None
 1531:         :param retryable: if we should attempt retries
 1532:             (may not always be supported even if supplied), defaults to False
 1533:         """
 1534: 
 1535:         # Ensure that the client supports retrying on reads and there is no session in
 1536:         # transaction, otherwise, we will not support retry behavior for this call.
 1537:         retryable = bool(
 1538:             retryable and self.options.retry_reads and not (session and session.in_transaction)
 1539:         )
 1540:         return self._retry_internal(
 1541:             func,
 1542:             session,
 1543:             None,
 1544:             operation,
 1545:             is_read=True,
 1546:             address=address,
 1547:             read_pref=read_pref,
 1548:             retryable=retryable,
 1549:             operation_id=operation_id,
 1550:         )
 1551: 
 1552:     def _retryable_write(
 1553:         self,
 1554:         retryable: bool,
 1555:         func: _WriteCall[T],
 1556:         session: Optional[ClientSession],
 1557:         operation: str,
 1558:         bulk: Optional[_Bulk] = None,
 1559:         operation_id: Optional[int] = None,
 1560:     ) -> T:
 1561:         """Execute an operation with consecutive retries if possible
 1562: 
 1563:         Returns func()'s return value on success. On error retries the same
 1564:         command.
 1565: 
 1566:         Re-raises any exception thrown by func().
 1567: 
 1568:         :param retryable: if we should attempt retries (may not always be supported)
 1569:         :param func: write call we want to execute during a session
 1570:         :param session: Client session we will use to execute write operation
 1571:         :param operation: The name of the operation that the server is being selected for
 1572:         :param bulk: bulk abstraction to execute operations in bulk, defaults to None
 1573:         """
 1574:         with self._tmp_session(session) as s:
 1575:             return self._retry_with_session(retryable, func, s, bulk, operation, operation_id)
 1576: 
 1577:     def __eq__(self, other: Any) -> bool:
 1578:         if isinstance(other, self.__class__):
 1579:             return self._topology == other._topology
 1580:         return NotImplemented
 1581: 
 1582:     def __ne__(self, other: Any) -> bool:
 1583:         return not self == other
 1584: 
 1585:     def __hash__(self) -> int:
 1586:         return hash(self._topology)
 1587: 
 1588:     def _repr_helper(self) -> str:
 1589:         def option_repr(option: str, value: Any) -> str:
 1590:             """Fix options whose __repr__ isn't usable in a constructor."""
 1591:             if option == "document_class":
 1592:                 if value is dict:
 1593:                     return "document_class=dict"
 1594:                 else:
 1595:                     return f"document_class={value.__module__}.{value.__name__}"
 1596:             if option in common.TIMEOUT_OPTIONS and value is not None:
 1597:                 return f"{option}={int(value * 1000)}"
 1598: 
 1599:             return f"{option}={value!r}"
 1600: 
 1601:         # Host first...
 1602:         options = [
 1603:             "host=%r"
 1604:             % [
 1605:                 "%s:%d" % (host, port) if port is not None else host
 1606:                 for host, port in self._topology_settings.seeds
 1607:             ]
 1608:         ]
 1609:         # ... then everything in self._constructor_args...
 1610:         options.extend(
 1611:             option_repr(key, self.__options._options[key]) for key in self._constructor_args
 1612:         )
 1613:         # ... then everything else.
 1614:         options.extend(
 1615:             option_repr(key, self.__options._options[key])
 1616:             for key in self.__options._options
 1617:             if key not in set(self._constructor_args) and key != "username" and key != "password"
 1618:         )
 1619:         return ", ".join(options)
 1620: 
 1621:     def __repr__(self) -> str:
 1622:         return f"MongoClient({self._repr_helper()})"
 1623: 
 1624:     def __getattr__(self, name: str) -> database.Database[_DocumentType]:
 1625:         """Get a database by name.
 1626: 
 1627:         Raises :class:`~pymongo.errors.InvalidName` if an invalid
 1628:         database name is used.
 1629: 
 1630:         :param name: the name of the database to get
 1631:         """
 1632:         if name.startswith("_"):
 1633:             raise AttributeError(
 1634:                 f"MongoClient has no attribute {name!r}. To access the {name}"
 1635:                 f" database, use client[{name!r}]."
 1636:             )
 1637:         return self.__getitem__(name)
 1638: 
 1639:     def __getitem__(self, name: str) -> database.Database[_DocumentType]:
 1640:         """Get a database by name.
 1641: 
 1642:         Raises :class:`~pymongo.errors.InvalidName` if an invalid
 1643:         database name is used.
 1644: 
 1645:         :param name: the name of the database to get
 1646:         """
 1647:         return database.Database(self, name)
 1648: 
 1649:     def _cleanup_cursor(
 1650:         self,
 1651:         locks_allowed: bool,
 1652:         cursor_id: int,
 1653:         address: Optional[_CursorAddress],
 1654:         conn_mgr: _ConnectionManager,
 1655:         session: Optional[ClientSession],
 1656:         explicit_session: bool,
 1657:     ) -> None:
 1658:         """Cleanup a cursor from cursor.close() or __del__.
 1659: 
 1660:         This method handles cleanup for Cursors/CommandCursors including any
 1661:         pinned connection or implicit session attached at the time the cursor
 1662:         was closed or garbage collected.
 1663: 
 1664:         :param locks_allowed: True if we are allowed to acquire locks.
 1665:         :param cursor_id: The cursor id which may be 0.
 1666:         :param address: The _CursorAddress.
 1667:         :param conn_mgr: The _ConnectionManager for the pinned connection or None.
 1668:         :param session: The cursor's session.
 1669:         :param explicit_session: True if the session was passed explicitly.
 1670:         """
 1671:         if locks_allowed:
 1672:             if cursor_id:
 1673:                 if conn_mgr and conn_mgr.more_to_come:
 1674:                     # If this is an exhaust cursor and we haven't completely
 1675:                     # exhausted the result set we *must* close the socket
 1676:                     # to stop the server from sending more data.
 1677:                     assert conn_mgr.conn is not None
 1678:                     conn_mgr.conn.close_conn(ConnectionClosedReason.ERROR)
 1679:                 else:
 1680:                     self._close_cursor_now(cursor_id, address, session=session, conn_mgr=conn_mgr)
 1681:             if conn_mgr:
 1682:                 conn_mgr.close()
 1683:         else:
 1684:             # The cursor will be closed later in a different session.
 1685:             if cursor_id or conn_mgr:
 1686:                 self._close_cursor_soon(cursor_id, address, conn_mgr)
 1687:         if session and not explicit_session:
 1688:             session.end_session()
 1689: 
 1690:     def _close_cursor_soon(
 1691:         self,
 1692:         cursor_id: int,
 1693:         address: Optional[_CursorAddress],
 1694:         conn_mgr: Optional[_ConnectionManager] = None,
 1695:     ) -> None:
 1696:         """Request that a cursor and/or connection be cleaned up soon."""
 1697:         self.__kill_cursors_queue.append((address, cursor_id, conn_mgr))
 1698: 
 1699:     def _close_cursor_now(
 1700:         self,
 1701:         cursor_id: int,
 1702:         address: Optional[_CursorAddress],
 1703:         session: Optional[ClientSession] = None,
 1704:         conn_mgr: Optional[_ConnectionManager] = None,
 1705:     ) -> None:
 1706:         """Send a kill cursors message with the given id.
 1707: 
 1708:         The cursor is closed synchronously on the current thread.
 1709:         """
 1710:         if not isinstance(cursor_id, int):
 1711:             raise TypeError("cursor_id must be an instance of int")
 1712: 
 1713:         try:
 1714:             if conn_mgr:
 1715:                 with conn_mgr.lock:
 1716:                     # Cursor is pinned to LB outside of a transaction.
 1717:                     assert address is not None
 1718:                     assert conn_mgr.conn is not None
 1719:                     self._kill_cursor_impl([cursor_id], address, session, conn_mgr.conn)
 1720:             else:
 1721:                 self._kill_cursors([cursor_id], address, self._get_topology(), session)
 1722:         except PyMongoError:
 1723:             # Make another attempt to kill the cursor later.
 1724:             self._close_cursor_soon(cursor_id, address)
 1725: 
 1726:     def _kill_cursors(
 1727:         self,
 1728:         cursor_ids: Sequence[int],
 1729:         address: Optional[_CursorAddress],
 1730:         topology: Topology,
 1731:         session: Optional[ClientSession],
 1732:     ) -> None:
 1733:         """Send a kill cursors message with the given ids."""
 1734:         if address:
 1735:             # address could be a tuple or _CursorAddress, but
 1736:             # select_server_by_address needs (host, port).
 1737:             server = topology.select_server_by_address(tuple(address), _Op.KILL_CURSORS)  # type: ignore[arg-type]
 1738:         else:
 1739:             # Application called close_cursor() with no address.
 1740:             server = topology.select_server(writable_server_selector, _Op.KILL_CURSORS)
 1741: 
 1742:         with self._checkout(server, session) as conn:
 1743:             assert address is not None
 1744:             self._kill_cursor_impl(cursor_ids, address, session, conn)
 1745: 
 1746:     def _kill_cursor_impl(
 1747:         self,
 1748:         cursor_ids: Sequence[int],
 1749:         address: _CursorAddress,
 1750:         session: Optional[ClientSession],
 1751:         conn: Connection,
 1752:     ) -> None:
 1753:         namespace = address.namespace
 1754:         db, coll = namespace.split(".", 1)
 1755:         spec = {"killCursors": coll, "cursors": cursor_ids}
 1756:         conn.command(db, spec, session=session, client=self)
 1757: 
 1758:     def _process_kill_cursors(self) -> None:
 1759:         """Process any pending kill cursors requests."""
 1760:         address_to_cursor_ids = defaultdict(list)
 1761:         pinned_cursors = []
 1762: 
 1763:         # Other threads or the GC may append to the queue concurrently.
 1764:         while True:
 1765:             try:
 1766:                 address, cursor_id, conn_mgr = self.__kill_cursors_queue.pop()
 1767:             except IndexError:
 1768:                 break
 1769: 
 1770:             if conn_mgr:
 1771:                 pinned_cursors.append((address, cursor_id, conn_mgr))
 1772:             else:
 1773:                 address_to_cursor_ids[address].append(cursor_id)
 1774: 
 1775:         for address, cursor_id, conn_mgr in pinned_cursors:
 1776:             try:
 1777:                 self._cleanup_cursor(True, cursor_id, address, conn_mgr, None, False)
 1778:             except Exception as exc:
 1779:                 if isinstance(exc, InvalidOperation) and self._topology._closed:
 1780:                     # Raise the exception when client is closed so that it
 1781:                     # can be caught in _process_periodic_tasks
 1782:                     raise
 1783:                 else:
 1784:                     helpers._handle_exception()
 1785: 
 1786:         # Don't re-open topology if it's closed and there's no pending cursors.
 1787:         if address_to_cursor_ids:
 1788:             topology = self._get_topology()
 1789:             for address, cursor_ids in address_to_cursor_ids.items():
 1790:                 try:
 1791:                     self._kill_cursors(cursor_ids, address, topology, session=None)
 1792:                 except Exception as exc:
 1793:                     if isinstance(exc, InvalidOperation) and self._topology._closed:
 1794:                         raise
 1795:                     else:
 1796:                         helpers._handle_exception()
 1797: 
 1798:     # This method is run periodically by a background thread.
 1799:     def _process_periodic_tasks(self) -> None:
 1800:         """Process any pending kill cursors requests and
 1801:         maintain connection pool parameters.
 1802:         """
 1803:         try:
 1804:             self._process_kill_cursors()
 1805:             self._topology.update_pool()
 1806:         except Exception as exc:
 1807:             if isinstance(exc, InvalidOperation) and self._topology._closed:
 1808:                 return
 1809:             else:
 1810:                 helpers._handle_exception()
 1811: 
 1812:     def __start_session(self, implicit: bool, **kwargs: Any) -> ClientSession:
 1813:         server_session = _EmptyServerSession()
 1814:         opts = client_session.SessionOptions(**kwargs)
 1815:         return client_session.ClientSession(self, server_session, opts, implicit)
 1816: 
 1817:     def start_session(
 1818:         self,
 1819:         causal_consistency: Optional[bool] = None,
 1820:         default_transaction_options: Optional[client_session.TransactionOptions] = None,
 1821:         snapshot: Optional[bool] = False,
 1822:     ) -> client_session.ClientSession:
 1823:         """Start a logical session.
 1824: 
 1825:         This method takes the same parameters as
 1826:         :class:`~pymongo.client_session.SessionOptions`. See the
 1827:         :mod:`~pymongo.client_session` module for details and examples.
 1828: 
 1829:         A :class:`~pymongo.client_session.ClientSession` may only be used with
 1830:         the MongoClient that started it. :class:`ClientSession` instances are
 1831:         **not thread-safe or fork-safe**. They can only be used by one thread
 1832:         or process at a time. A single :class:`ClientSession` cannot be used
 1833:         to run multiple operations concurrently.
 1834: 
 1835:         :return: An instance of :class:`~pymongo.client_session.ClientSession`.
 1836: 
 1837:         .. versionadded:: 3.6
 1838:         """
 1839:         return self.__start_session(
 1840:             False,
 1841:             causal_consistency=causal_consistency,
 1842:             default_transaction_options=default_transaction_options,
 1843:             snapshot=snapshot,
 1844:         )
 1845: 
 1846:     def _return_server_session(
 1847:         self, server_session: Union[_ServerSession, _EmptyServerSession]
 1848:     ) -> None:
 1849:         """Internal: return a _ServerSession to the pool."""
 1850:         if isinstance(server_session, _EmptyServerSession):
 1851:             return None
 1852:         return self._topology.return_server_session(server_session)
 1853: 
 1854:     def _ensure_session(self, session: Optional[ClientSession] = None) -> Optional[ClientSession]:
 1855:         """If provided session is None, lend a temporary session."""
 1856:         if session:
 1857:             return session
 1858: 
 1859:         try:
 1860:             # Don't make implicit sessions causally consistent. Applications
 1861:             # should always opt-in.
 1862:             return self.__start_session(True, causal_consistency=False)
 1863:         except (ConfigurationError, InvalidOperation):
 1864:             # Sessions not supported.
 1865:             return None
 1866: 
 1867:     @contextlib.contextmanager
 1868:     def _tmp_session(
 1869:         self, session: Optional[client_session.ClientSession], close: bool = True
 1870:     ) -> Generator[Optional[client_session.ClientSession], None, None]:
 1871:         """If provided session is None, lend a temporary session."""
 1872:         if session is not None:
 1873:             if not isinstance(session, client_session.ClientSession):
 1874:                 raise ValueError("'session' argument must be a ClientSession or None.")
 1875:             # Don't call end_session.
 1876:             yield session
 1877:             return
 1878: 
 1879:         s = self._ensure_session(session)
 1880:         if s:
 1881:             try:
 1882:                 yield s
 1883:             except Exception as exc:
 1884:                 if isinstance(exc, ConnectionFailure):
 1885:                     s._server_session.mark_dirty()
 1886: 
 1887:                 # Always call end_session on error.
 1888:                 s.end_session()
 1889:                 raise
 1890:             finally:
 1891:                 # Call end_session when we exit this scope.
 1892:                 if close:
 1893:                     s.end_session()
 1894:         else:
 1895:             yield None
 1896: 
 1897:     def _send_cluster_time(
 1898:         self, command: MutableMapping[str, Any], session: Optional[ClientSession]
 1899:     ) -> None:
 1900:         topology_time = self._topology.max_cluster_time()
 1901:         session_time = session.cluster_time if session else None
 1902:         if topology_time and session_time:
 1903:             if topology_time["clusterTime"] > session_time["clusterTime"]:
 1904:                 cluster_time: Optional[ClusterTime] = topology_time
 1905:             else:
 1906:                 cluster_time = session_time
 1907:         else:
 1908:             cluster_time = topology_time or session_time
 1909:         if cluster_time:
 1910:             command["$clusterTime"] = cluster_time
 1911: 
 1912:     def _process_response(self, reply: Mapping[str, Any], session: Optional[ClientSession]) -> None:
 1913:         self._topology.receive_cluster_time(reply.get("$clusterTime"))
 1914:         if session is not None:
 1915:             session._process_response(reply)
 1916: 
 1917:     def server_info(self, session: Optional[client_session.ClientSession] = None) -> dict[str, Any]:
 1918:         """Get information about the MongoDB server we're connected to.
 1919: 
 1920:         :param session: a
 1921:             :class:`~pymongo.client_session.ClientSession`.
 1922: 
 1923:         .. versionchanged:: 3.6
 1924:            Added ``session`` parameter.
 1925:         """
 1926:         return cast(
 1927:             dict,
 1928:             self.admin.command(
 1929:                 "buildinfo", read_preference=ReadPreference.PRIMARY, session=session
 1930:             ),
 1931:         )
 1932: 
 1933:     def list_databases(
 1934:         self,
 1935:         session: Optional[client_session.ClientSession] = None,
 1936:         comment: Optional[Any] = None,
 1937:         **kwargs: Any,
 1938:     ) -> CommandCursor[dict[str, Any]]:
 1939:         """Get a cursor over the databases of the connected server.
 1940: 
 1941:         :param session: a
 1942:             :class:`~pymongo.client_session.ClientSession`.
 1943:         :param comment: A user-provided comment to attach to this
 1944:             command.
 1945:         :param kwargs: Optional parameters of the
 1946:             `listDatabases command
 1947:             <https://mongodb.com/docs/manual/reference/command/listDatabases/>`_
 1948:             can be passed as keyword arguments to this method. The supported
 1949:             options differ by server version.
 1950: 
 1951: 
 1952:         :return: An instance of :class:`~pymongo.command_cursor.CommandCursor`.
 1953: 
 1954:         .. versionadded:: 3.6
 1955:         """
 1956:         cmd = {"listDatabases": 1}
 1957:         cmd.update(kwargs)
 1958:         if comment is not None:
 1959:             cmd["comment"] = comment
 1960:         admin = self._database_default_options("admin")
 1961:         res = admin._retryable_read_command(cmd, session=session, operation=_Op.LIST_DATABASES)
 1962:         # listDatabases doesn't return a cursor (yet). Fake one.
 1963:         cursor = {
 1964:             "id": 0,
 1965:             "firstBatch": res["databases"],
 1966:             "ns": "admin.$cmd",
 1967:         }
 1968:         return CommandCursor(admin["$cmd"], cursor, None, comment=comment)
 1969: 
 1970:     def list_database_names(
 1971:         self,
 1972:         session: Optional[client_session.ClientSession] = None,
 1973:         comment: Optional[Any] = None,
 1974:     ) -> list[str]:
 1975:         """Get a list of the names of all databases on the connected server.
 1976: 
 1977:         :param session: a
 1978:             :class:`~pymongo.client_session.ClientSession`.
 1979:         :param comment: A user-provided comment to attach to this
 1980:             command.
 1981: 
 1982:         .. versionchanged:: 4.1
 1983:            Added ``comment`` parameter.
 1984: 
 1985:         .. versionadded:: 3.6
 1986:         """
 1987:         return [doc["name"] for doc in self.list_databases(session, nameOnly=True, comment=comment)]
 1988: 
 1989:     @_csot.apply
 1990:     def drop_database(
 1991:         self,
 1992:         name_or_database: Union[str, database.Database[_DocumentTypeArg]],
 1993:         session: Optional[client_session.ClientSession] = None,
 1994:         comment: Optional[Any] = None,
 1995:     ) -> None:
 1996:         """Drop a database.
 1997: 
 1998:         Raises :class:`TypeError` if `name_or_database` is not an instance of
 1999:         :class:`str` or :class:`~pymongo.database.Database`.
 2000: 
 2001:         :param name_or_database: the name of a database to drop, or a
 2002:             :class:`~pymongo.database.Database` instance representing the
 2003:             database to drop
 2004:         :param session: a
 2005:             :class:`~pymongo.client_session.ClientSession`.
 2006:         :param comment: A user-provided comment to attach to this
 2007:             command.
 2008: 
 2009:         .. versionchanged:: 4.1
 2010:            Added ``comment`` parameter.
 2011: 
 2012:         .. versionchanged:: 3.6
 2013:            Added ``session`` parameter.
 2014: 
 2015:         .. note:: The :attr:`~pymongo.mongo_client.MongoClient.write_concern` of
 2016:            this client is automatically applied to this operation.
 2017: 
 2018:         .. versionchanged:: 3.4
 2019:            Apply this client's write concern automatically to this operation
 2020:            when connected to MongoDB >= 3.4.
 2021: 
 2022:         """
 2023:         name = name_or_database
 2024:         if isinstance(name, database.Database):
 2025:             name = name.name
 2026: 
 2027:         if not isinstance(name, str):
 2028:             raise TypeError("name_or_database must be an instance of str or a Database")
 2029: 
 2030:         with self._conn_for_writes(session, operation=_Op.DROP_DATABASE) as conn:
 2031:             self[name]._command(
 2032:                 conn,
 2033:                 {"dropDatabase": 1, "comment": comment},
 2034:                 read_preference=ReadPreference.PRIMARY,
 2035:                 write_concern=self._write_concern_for(session),
 2036:                 parse_write_concern_error=True,
 2037:                 session=session,
 2038:             )
 2039: 
 2040:     def get_default_database(
 2041:         self,
 2042:         default: Optional[str] = None,
 2043:         codec_options: Optional[CodecOptions[_DocumentTypeArg]] = None,
 2044:         read_preference: Optional[_ServerMode] = None,
 2045:         write_concern: Optional[WriteConcern] = None,
 2046:         read_concern: Optional[ReadConcern] = None,
 2047:     ) -> database.Database[_DocumentType]:
 2048:         """Get the database named in the MongoDB connection URI.
 2049: 
 2050:         >>> uri = 'mongodb://host/my_database'
 2051:         >>> client = MongoClient(uri)
 2052:         >>> db = client.get_default_database()
 2053:         >>> assert db.name == 'my_database'
 2054:         >>> db = client.get_database()
 2055:         >>> assert db.name == 'my_database'
 2056: 
 2057:         Useful in scripts where you want to choose which database to use
 2058:         based only on the URI in a configuration file.
 2059: 
 2060:         :param default: the database name to use if no database name
 2061:             was provided in the URI.
 2062:         :param codec_options: An instance of
 2063:             :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
 2064:             default) the :attr:`codec_options` of this :class:`MongoClient` is
 2065:             used.
 2066:         :param read_preference: The read preference to use. If
 2067:             ``None`` (the default) the :attr:`read_preference` of this
 2068:             :class:`MongoClient` is used. See :mod:`~pymongo.read_preferences`
 2069:             for options.
 2070:         :param write_concern: An instance of
 2071:             :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
 2072:             default) the :attr:`write_concern` of this :class:`MongoClient` is
 2073:             used.
 2074:         :param read_concern: An instance of
 2075:             :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
 2076:             default) the :attr:`read_concern` of this :class:`MongoClient` is
 2077:             used.
 2078:         :param comment: A user-provided comment to attach to this
 2079:             command.
 2080: 
 2081:         .. versionchanged:: 4.1
 2082:            Added ``comment`` parameter.
 2083: 
 2084:         .. versionchanged:: 3.8
 2085:            Undeprecated. Added the ``default``, ``codec_options``,
 2086:            ``read_preference``, ``write_concern`` and ``read_concern``
 2087:            parameters.
 2088: 
 2089:         .. versionchanged:: 3.5
 2090:            Deprecated, use :meth:`get_database` instead.
 2091:         """
 2092:         if self.__default_database_name is None and default is None:
 2093:             raise ConfigurationError("No default database name defined or provided.")
 2094: 
 2095:         name = cast(str, self.__default_database_name or default)
 2096:         return database.Database(
 2097:             self, name, codec_options, read_preference, write_concern, read_concern
 2098:         )
 2099: 
 2100:     def get_database(
 2101:         self,
 2102:         name: Optional[str] = None,
 2103:         codec_options: Optional[CodecOptions[_DocumentTypeArg]] = None,
 2104:         read_preference: Optional[_ServerMode] = None,
 2105:         write_concern: Optional[WriteConcern] = None,
 2106:         read_concern: Optional[ReadConcern] = None,
 2107:     ) -> database.Database[_DocumentType]:
 2108:         """Get a :class:`~pymongo.database.Database` with the given name and
 2109:         options.
 2110: 
 2111:         Useful for creating a :class:`~pymongo.database.Database` with
 2112:         different codec options, read preference, and/or write concern from
 2113:         this :class:`MongoClient`.
 2114: 
 2115:           >>> client.read_preference
 2116:           Primary()
 2117:           >>> db1 = client.test
 2118:           >>> db1.read_preference
 2119:           Primary()
 2120:           >>> from pymongo import ReadPreference
 2121:           >>> db2 = client.get_database(
 2122:           ...     'test', read_preference=ReadPreference.SECONDARY)
 2123:           >>> db2.read_preference
 2124:           Secondary(tag_sets=None)
 2125: 
 2126:         :param name: The name of the database - a string. If ``None``
 2127:             (the default) the database named in the MongoDB connection URI is
 2128:             returned.
 2129:         :param codec_options: An instance of
 2130:             :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
 2131:             default) the :attr:`codec_options` of this :class:`MongoClient` is
 2132:             used.
 2133:         :param read_preference: The read preference to use. If
 2134:             ``None`` (the default) the :attr:`read_preference` of this
 2135:             :class:`MongoClient` is used. See :mod:`~pymongo.read_preferences`
 2136:             for options.
 2137:         :param write_concern: An instance of
 2138:             :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
 2139:             default) the :attr:`write_concern` of this :class:`MongoClient` is
 2140:             used.
 2141:         :param read_concern: An instance of
 2142:             :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
 2143:             default) the :attr:`read_concern` of this :class:`MongoClient` is
 2144:             used.
 2145: 
 2146:         .. versionchanged:: 3.5
 2147:            The `name` parameter is now optional, defaulting to the database
 2148:            named in the MongoDB connection URI.
 2149:         """
 2150:         if name is None:
 2151:             if self.__default_database_name is None:
 2152:                 raise ConfigurationError("No default database defined")
 2153:             name = self.__default_database_name
 2154: 
 2155:         return database.Database(
 2156:             self, name, codec_options, read_preference, write_concern, read_concern
 2157:         )
 2158: 
 2159:     def _database_default_options(self, name: str) -> Database:
 2160:         """Get a Database instance with the default settings."""
 2161:         return self.get_database(
 2162:             name,
 2163:             codec_options=DEFAULT_CODEC_OPTIONS,
 2164:             read_preference=ReadPreference.PRIMARY,
 2165:             write_concern=DEFAULT_WRITE_CONCERN,
 2166:         )
 2167: 
 2168:     def __enter__(self) -> MongoClient[_DocumentType]:
 2169:         return self
 2170: 
 2171:     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
 2172:         self.close()
 2173: 
 2174:     # See PYTHON-3084.
 2175:     __iter__ = None
 2176: 
 2177:     def __next__(self) -> NoReturn:
 2178:         raise TypeError("'MongoClient' object is not iterable")
 2179: 
 2180:     next = __next__
 2181: 
 2182: 
 2183: def _retryable_error_doc(exc: PyMongoError) -> Optional[Mapping[str, Any]]:
 2184:     """Return the server response from PyMongo exception or None."""
 2185:     if isinstance(exc, BulkWriteError):
 2186:         # Check the last writeConcernError to determine if this
 2187:         # BulkWriteError is retryable.
 2188:         wces = exc.details["writeConcernErrors"]
 2189:         return wces[-1] if wces else None
 2190:     if isinstance(exc, (NotPrimaryError, OperationFailure)):
 2191:         return cast(Mapping[str, Any], exc.details)
 2192:     return None
 2193: 
 2194: 
 2195: def _add_retryable_write_error(exc: PyMongoError, max_wire_version: int, is_mongos: bool) -> None:
 2196:     doc = _retryable_error_doc(exc)
 2197:     if doc:
 2198:         code = doc.get("code", 0)
 2199:         # retryWrites on MMAPv1 should raise an actionable error.
 2200:         if code == 20 and str(exc).startswith("Transaction numbers"):
 2201:             errmsg = (
 2202:                 "This MongoDB deployment does not support "
 2203:                 "retryable writes. Please add retryWrites=false "
 2204:                 "to your connection string."
 2205:             )
 2206:             raise OperationFailure(errmsg, code, exc.details)  # type: ignore[attr-defined]
 2207:         if max_wire_version >= 9:
 2208:             # In MongoDB 4.4+, the server reports the error labels.
 2209:             for label in doc.get("errorLabels", []):
 2210:                 exc._add_error_label(label)
 2211:         else:
 2212:             # Do not consult writeConcernError for pre-4.4 mongos.
 2213:             if isinstance(exc, WriteConcernError) and is_mongos:
 2214:                 pass
 2215:             elif code in helpers._RETRYABLE_ERROR_CODES:
 2216:                 exc._add_error_label("RetryableWriteError")
 2217: 
 2218:     # Connection errors are always retryable except NotPrimaryError and WaitQueueTimeoutError which is
 2219:     # handled above.
 2220:     if isinstance(exc, ConnectionFailure) and not isinstance(
 2221:         exc, (NotPrimaryError, WaitQueueTimeoutError)
 2222:     ):
 2223:         exc._add_error_label("RetryableWriteError")
 2224: 
 2225: 
 2226: class _MongoClientErrorHandler:
 2227:     """Handle errors raised when executing an operation."""
 2228: 
 2229:     __slots__ = (
 2230:         "client",
 2231:         "server_address",
 2232:         "session",
 2233:         "max_wire_version",
 2234:         "sock_generation",
 2235:         "completed_handshake",
 2236:         "service_id",
 2237:         "handled",
 2238:     )
 2239: 
 2240:     def __init__(self, client: MongoClient, server: Server, session: Optional[ClientSession]):
 2241:         self.client = client
 2242:         self.server_address = server.description.address
 2243:         self.session = session
 2244:         self.max_wire_version = common.MIN_WIRE_VERSION
 2245:         # XXX: When get_socket fails, this generation could be out of date:
 2246:         # "Note that when a network error occurs before the handshake
 2247:         # completes then the error's generation number is the generation
 2248:         # of the pool at the time the connection attempt was started."
 2249:         self.sock_generation = server.pool.gen.get_overall()
 2250:         self.completed_handshake = False
 2251:         self.service_id: Optional[ObjectId] = None
 2252:         self.handled = False
 2253: 
 2254:     def contribute_socket(self, conn: Connection, completed_handshake: bool = True) -> None:
 2255:         """Provide socket information to the error handler."""
 2256:         self.max_wire_version = conn.max_wire_version
 2257:         self.sock_generation = conn.generation
 2258:         self.service_id = conn.service_id
 2259:         self.completed_handshake = completed_handshake
 2260: 
 2261:     def handle(
 2262:         self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException]
 2263:     ) -> None:
 2264:         if self.handled or exc_val is None:
 2265:             return
 2266:         self.handled = True
 2267:         if self.session:
 2268:             if isinstance(exc_val, ConnectionFailure):
 2269:                 if self.session.in_transaction:
 2270:                     exc_val._add_error_label("TransientTransactionError")
 2271:                 self.session._server_session.mark_dirty()
 2272: 
 2273:             if isinstance(exc_val, PyMongoError):
 2274:                 if exc_val.has_error_label("TransientTransactionError") or exc_val.has_error_label(
 2275:                     "RetryableWriteError"
 2276:                 ):
 2277:                     self.session._unpin()
 2278:         err_ctx = _ErrorContext(
 2279:             exc_val,
 2280:             self.max_wire_version,
 2281:             self.sock_generation,
 2282:             self.completed_handshake,
 2283:             self.service_id,
 2284:         )
 2285:         self.client._topology.handle_error(self.server_address, err_ctx)
 2286: 
 2287:     def __enter__(self) -> _MongoClientErrorHandler:
 2288:         return self
 2289: 
 2290:     def __exit__(
 2291:         self,
 2292:         exc_type: Optional[Type[Exception]],
 2293:         exc_val: Optional[Exception],
 2294:         exc_tb: Optional[TracebackType],
 2295:     ) -> None:
 2296:         return self.handle(exc_type, exc_val)
 2297: 
 2298: 
 2299: class _ClientConnectionRetryable(Generic[T]):
 2300:     """Responsible for executing retryable connections on read or write operations"""
 2301: 
 2302:     def __init__(
 2303:         self,
 2304:         mongo_client: MongoClient,
 2305:         func: _WriteCall[T] | _ReadCall[T],
 2306:         bulk: Optional[_Bulk],
 2307:         operation: str,
 2308:         is_read: bool = False,
 2309:         session: Optional[ClientSession] = None,
 2310:         read_pref: Optional[_ServerMode] = None,
 2311:         address: Optional[_Address] = None,
 2312:         retryable: bool = False,
 2313:         operation_id: Optional[int] = None,
 2314:     ):
 2315:         self._last_error: Optional[Exception] = None
 2316:         self._retrying = False
 2317:         self._multiple_retries = _csot.get_timeout() is not None
 2318:         self._client = mongo_client
 2319: 
 2320:         self._func = func
 2321:         self._bulk = bulk
 2322:         self._session = session
 2323:         self._is_read = is_read
 2324:         self._retryable = retryable
 2325:         self._read_pref = read_pref
 2326:         self._server_selector: Callable[[Selection], Selection] = (
 2327:             read_pref if is_read else writable_server_selector  # type: ignore
 2328:         )
 2329:         self._address = address
 2330:         self._server: Server = None  # type: ignore
 2331:         self._deprioritized_servers: list[Server] = []
 2332:         self._operation = operation
 2333:         self._operation_id = operation_id
 2334: 
 2335:     def run(self) -> T:
 2336:         """Runs the supplied func() and attempts a retry
 2337: 
 2338:         :raises: self._last_error: Last exception raised
 2339: 
 2340:         :return: Result of the func() call
 2341:         """
 2342:         # Increment the transaction id up front to ensure any retry attempt
 2343:         # will use the proper txnNumber, even if server or socket selection
 2344:         # fails before the command can be sent.
 2345:         if self._is_session_state_retryable() and self._retryable and not self._is_read:
 2346:             self._session._start_retryable_write()  # type: ignore
 2347:             if self._bulk:
 2348:                 self._bulk.started_retryable_write = True
 2349: 
 2350:         while True:
 2351:             self._check_last_error(check_csot=True)
 2352:             try:
 2353:                 return self._read() if self._is_read else self._write()
 2354:             except ServerSelectionTimeoutError:
 2355:                 # The application may think the write was never attempted
 2356:                 # if we raise ServerSelectionTimeoutError on the retry
 2357:                 # attempt. Raise the original exception instead.
 2358:                 self._check_last_error()
 2359:                 # A ServerSelectionTimeoutError error indicates that there may
 2360:                 # be a persistent outage. Attempting to retry in this case will
 2361:                 # most likely be a waste of time.
 2362:                 raise
 2363:             except PyMongoError as exc:
 2364:                 # Execute specialized catch on read
 2365:                 if self._is_read:
 2366:                     if isinstance(exc, (ConnectionFailure, OperationFailure)):
 2367:                         # ConnectionFailures do not supply a code property
 2368:                         exc_code = getattr(exc, "code", None)
 2369:                         if self._is_not_eligible_for_retry() or (
 2370:                             isinstance(exc, OperationFailure)
 2371:                             and exc_code not in helpers._RETRYABLE_ERROR_CODES
 2372:                         ):
 2373:                             raise
 2374:                         self._retrying = True
 2375:                         self._last_error = exc
 2376:                     else:
 2377:                         raise
 2378: 
 2379:                 # Specialized catch on write operation
 2380:                 if not self._is_read:
 2381:                     if not self._retryable:
 2382:                         raise
 2383:                     retryable_write_error_exc = exc.has_error_label("RetryableWriteError")
 2384:                     if retryable_write_error_exc:
 2385:                         assert self._session
 2386:                         self._session._unpin()
 2387:                     if not retryable_write_error_exc or self._is_not_eligible_for_retry():
 2388:                         if exc.has_error_label("NoWritesPerformed") and self._last_error:
 2389:                             raise self._last_error from exc
 2390:                         else:
 2391:                             raise
 2392:                     if self._bulk:
 2393:                         self._bulk.retrying = True
 2394:                     else:
 2395:                         self._retrying = True
 2396:                     if not exc.has_error_label("NoWritesPerformed"):
 2397:                         self._last_error = exc
 2398:                     if self._last_error is None:
 2399:                         self._last_error = exc
 2400: 
 2401:                 if self._client.topology_description.topology_type == TOPOLOGY_TYPE.Sharded:
 2402:                     self._deprioritized_servers.append(self._server)
 2403: 
 2404:     def _is_not_eligible_for_retry(self) -> bool:
 2405:         """Checks if the exchange is not eligible for retry"""
 2406:         return not self._retryable or (self._is_retrying() and not self._multiple_retries)
 2407: 
 2408:     def _is_retrying(self) -> bool:
 2409:         """Checks if the exchange is currently undergoing a retry"""
 2410:         return self._bulk.retrying if self._bulk else self._retrying
 2411: 
 2412:     def _is_session_state_retryable(self) -> bool:
 2413:         """Checks if provided session is eligible for retry
 2414: 
 2415:         reads: Make sure there is no ongoing transaction (if provided a session)
 2416:         writes: Make sure there is a session without an active transaction
 2417:         """
 2418:         if self._is_read:
 2419:             return not (self._session and self._session.in_transaction)
 2420:         return bool(self._session and not self._session.in_transaction)
 2421: 
 2422:     def _check_last_error(self, check_csot: bool = False) -> None:
 2423:         """Checks if the ongoing client exchange experienced a exception previously.
 2424:         If so, raise last error
 2425: 
 2426:         :param check_csot: Checks CSOT to ensure we are retrying with time remaining defaults to False
 2427:         """
 2428:         if self._is_retrying():
 2429:             remaining = _csot.remaining()
 2430:             if not check_csot or (remaining is not None and remaining <= 0):
 2431:                 assert self._last_error is not None
 2432:                 raise self._last_error
 2433: 
 2434:     def _get_server(self) -> Server:
 2435:         """Retrieves a server object based on provided object context
 2436: 
 2437:         :return: Abstraction to connect to server
 2438:         """
 2439:         return self._client._select_server(
 2440:             self._server_selector,
 2441:             self._session,
 2442:             self._operation,
 2443:             address=self._address,
 2444:             deprioritized_servers=self._deprioritized_servers,
 2445:             operation_id=self._operation_id,
 2446:         )
 2447: 
 2448:     def _write(self) -> T:
 2449:         """Wrapper method for write-type retryable client executions
 2450: 
 2451:         :return: Output for func()'s call
 2452:         """
 2453:         try:
 2454:             max_wire_version = 0
 2455:             is_mongos = False
 2456:             self._server = self._get_server()
 2457:             with self._client._checkout(self._server, self._session) as conn:
 2458:                 max_wire_version = conn.max_wire_version
 2459:                 sessions_supported = (
 2460:                     self._session
 2461:                     and self._server.description.retryable_writes_supported
 2462:                     and conn.supports_sessions
 2463:                 )
 2464:                 is_mongos = conn.is_mongos
 2465:                 if not sessions_supported:
 2466:                     # A retry is not possible because this server does
 2467:                     # not support sessions raise the last error.
 2468:                     self._check_last_error()
 2469:                     self._retryable = False
 2470:                 return self._func(self._session, conn, self._retryable)  # type: ignore
 2471:         except PyMongoError as exc:
 2472:             if not self._retryable:
 2473:                 raise
 2474:             # Add the RetryableWriteError label, if applicable.
 2475:             _add_retryable_write_error(exc, max_wire_version, is_mongos)
 2476:             raise
 2477: 
 2478:     def _read(self) -> T:
 2479:         """Wrapper method for read-type retryable client executions
 2480: 
 2481:         :return: Output for func()'s call
 2482:         """
 2483:         self._server = self._get_server()
 2484:         assert self._read_pref is not None, "Read Preference required on read calls"
 2485:         with self._client._conn_from_server(self._read_pref, self._server, self._session) as (
 2486:             conn,
 2487:             read_pref,
 2488:         ):
 2489:             if self._retrying and not self._retryable:
 2490:                 self._check_last_error()
 2491:             return self._func(self._session, self._server, conn, read_pref)  # type: ignore
 2492: 
 2493: 
 2494: def _after_fork_child() -> None:
 2495:     """Releases the locks in child process and resets the
 2496:     topologies in all MongoClients.
 2497:     """
 2498:     # Reinitialize locks
 2499:     _release_locks()
 2500: 
 2501:     # Perform cleanup in clients (i.e. get rid of topology)
 2502:     for _, client in MongoClient._clients.items():
 2503:         client._after_fork()
 2504: 
 2505: 
 2506: def _detect_external_db(entity: str) -> bool:
 2507:     """Detects external database hosts and logs an informational message at the INFO level."""
 2508:     entity = entity.lower()
 2509:     cosmos_db_hosts = [".cosmos.azure.com"]
 2510:     document_db_hosts = [".docdb.amazonaws.com", ".docdb-elastic.amazonaws.com"]
 2511: 
 2512:     for host in cosmos_db_hosts:
 2513:         if entity.endswith(host):
 2514:             _log_or_warn(
 2515:                 _CLIENT_LOGGER,
 2516:                 "You appear to be connected to a CosmosDB cluster. For more information regarding feature "
 2517:                 "compatibility and support please visit https://www.mongodb.com/supportability/cosmosdb",
 2518:             )
 2519:             return True
 2520:     for host in document_db_hosts:
 2521:         if entity.endswith(host):
 2522:             _log_or_warn(
 2523:                 _CLIENT_LOGGER,
 2524:                 "You appear to be connected to a DocumentDB cluster. For more information regarding feature "
 2525:                 "compatibility and support please visit https://www.mongodb.com/supportability/documentdb",
 2526:             )
 2527:             return True
 2528:     return False
 2529: 
 2530: 
 2531: if _HAS_REGISTER_AT_FORK:
 2532:     # This will run in the same thread as the fork was called.
 2533:     # If we fork in a critical region on the same thread, it should break.
 2534:     # This is fine since we would never call fork directly from a critical region.
 2535:     os.register_at_fork(after_in_child=_after_fork_child)
