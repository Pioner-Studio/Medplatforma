    1: # Copyright 2014-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Communicate with one MongoDB server in a topology."""
   16: from __future__ import annotations
   17: 
   18: import logging
   19: from datetime import datetime
   20: from typing import TYPE_CHECKING, Any, Callable, ContextManager, Optional, Union
   21: 
   22: from bson import _decode_all_selective
   23: from pymongo.errors import NotPrimaryError, OperationFailure
   24: from pymongo.helpers import _check_command_response, _handle_reauth
   25: from pymongo.logger import _COMMAND_LOGGER, _CommandStatusMessage, _debug_log
   26: from pymongo.message import _convert_exception, _GetMore, _OpMsg, _Query
   27: from pymongo.response import PinnedResponse, Response
   28: 
   29: if TYPE_CHECKING:
   30:     from queue import Queue
   31:     from weakref import ReferenceType
   32: 
   33:     from bson.objectid import ObjectId
   34:     from pymongo.mongo_client import MongoClient, _MongoClientErrorHandler
   35:     from pymongo.monitor import Monitor
   36:     from pymongo.monitoring import _EventListeners
   37:     from pymongo.pool import Connection, Pool
   38:     from pymongo.read_preferences import _ServerMode
   39:     from pymongo.server_description import ServerDescription
   40:     from pymongo.typings import _DocumentOut
   41: 
   42: _CURSOR_DOC_FIELDS = {"cursor": {"firstBatch": 1, "nextBatch": 1}}
   43: 
   44: 
   45: class Server:
   46:     def __init__(
   47:         self,
   48:         server_description: ServerDescription,
   49:         pool: Pool,
   50:         monitor: Monitor,
   51:         topology_id: Optional[ObjectId] = None,
   52:         listeners: Optional[_EventListeners] = None,
   53:         events: Optional[ReferenceType[Queue]] = None,
   54:     ) -> None:
   55:         """Represent one MongoDB server."""
   56:         self._description = server_description
   57:         self._pool = pool
   58:         self._monitor = monitor
   59:         self._topology_id = topology_id
   60:         self._publish = listeners is not None and listeners.enabled_for_server
   61:         self._listener = listeners
   62:         self._events = None
   63:         if self._publish:
   64:             self._events = events()  # type: ignore[misc]
   65: 
   66:     def open(self) -> None:
   67:         """Start monitoring, or restart after a fork.
   68: 
   69:         Multiple calls have no effect.
   70:         """
   71:         if not self._pool.opts.load_balanced:
   72:             self._monitor.open()
   73: 
   74:     def reset(self, service_id: Optional[ObjectId] = None) -> None:
   75:         """Clear the connection pool."""
   76:         self.pool.reset(service_id)
   77: 
   78:     def close(self) -> None:
   79:         """Clear the connection pool and stop the monitor.
   80: 
   81:         Reconnect with open().
   82:         """
   83:         if self._publish:
   84:             assert self._listener is not None
   85:             assert self._events is not None
   86:             self._events.put(
   87:                 (
   88:                     self._listener.publish_server_closed,
   89:                     (self._description.address, self._topology_id),
   90:                 )
   91:             )
   92:         self._monitor.close()
   93:         self._pool.close()
   94: 
   95:     def request_check(self) -> None:
   96:         """Check the server's state soon."""
   97:         self._monitor.request_check()
   98: 
   99:     @_handle_reauth
  100:     def run_operation(
  101:         self,
  102:         conn: Connection,
  103:         operation: Union[_Query, _GetMore],
  104:         read_preference: _ServerMode,
  105:         listeners: Optional[_EventListeners],
  106:         unpack_res: Callable[..., list[_DocumentOut]],
  107:         client: MongoClient,
  108:     ) -> Response:
  109:         """Run a _Query or _GetMore operation and return a Response object.
  110: 
  111:         This method is used only to run _Query/_GetMore operations from
  112:         cursors.
  113:         Can raise ConnectionFailure, OperationFailure, etc.
  114: 
  115:         :param conn: A Connection instance.
  116:         :param operation: A _Query or _GetMore object.
  117:         :param read_preference: The read preference to use.
  118:         :param listeners: Instance of _EventListeners or None.
  119:         :param unpack_res: A callable that decodes the wire protocol response.
  120:         """
  121:         duration = None
  122:         assert listeners is not None
  123:         publish = listeners.enabled_for_commands
  124:         start = datetime.now()
  125: 
  126:         use_cmd = operation.use_command(conn)
  127:         more_to_come = operation.conn_mgr and operation.conn_mgr.more_to_come
  128:         if more_to_come:
  129:             request_id = 0
  130:         else:
  131:             message = operation.get_message(read_preference, conn, use_cmd)
  132:             request_id, data, max_doc_size = self._split_message(message)
  133: 
  134:         cmd, dbn = operation.as_command(conn)
  135:         if _COMMAND_LOGGER.isEnabledFor(logging.DEBUG):
  136:             _debug_log(
  137:                 _COMMAND_LOGGER,
  138:                 clientId=client._topology_settings._topology_id,
  139:                 message=_CommandStatusMessage.STARTED,
  140:                 command=cmd,
  141:                 commandName=next(iter(cmd)),
  142:                 databaseName=dbn,
  143:                 requestId=request_id,
  144:                 operationId=request_id,
  145:                 driverConnectionId=conn.id,
  146:                 serverConnectionId=conn.server_connection_id,
  147:                 serverHost=conn.address[0],
  148:                 serverPort=conn.address[1],
  149:                 serviceId=conn.service_id,
  150:             )
  151: 
  152:         if publish:
  153:             cmd, dbn = operation.as_command(conn)
  154:             if "$db" not in cmd:
  155:                 cmd["$db"] = dbn
  156:             assert listeners is not None
  157:             listeners.publish_command_start(
  158:                 cmd,
  159:                 dbn,
  160:                 request_id,
  161:                 conn.address,
  162:                 conn.server_connection_id,
  163:                 service_id=conn.service_id,
  164:             )
  165: 
  166:         try:
  167:             if more_to_come:
  168:                 reply = conn.receive_message(None)
  169:             else:
  170:                 conn.send_message(data, max_doc_size)
  171:                 reply = conn.receive_message(request_id)
  172: 
  173:             # Unpack and check for command errors.
  174:             if use_cmd:
  175:                 user_fields = _CURSOR_DOC_FIELDS
  176:                 legacy_response = False
  177:             else:
  178:                 user_fields = None
  179:                 legacy_response = True
  180:             docs = unpack_res(
  181:                 reply,
  182:                 operation.cursor_id,
  183:                 operation.codec_options,
  184:                 legacy_response=legacy_response,
  185:                 user_fields=user_fields,
  186:             )
  187:             if use_cmd:
  188:                 first = docs[0]
  189:                 operation.client._process_response(first, operation.session)
  190:                 _check_command_response(first, conn.max_wire_version)
  191:         except Exception as exc:
  192:             duration = datetime.now() - start
  193:             if isinstance(exc, (NotPrimaryError, OperationFailure)):
  194:                 failure: _DocumentOut = exc.details  # type: ignore[assignment]
  195:             else:
  196:                 failure = _convert_exception(exc)
  197:             if _COMMAND_LOGGER.isEnabledFor(logging.DEBUG):
  198:                 _debug_log(
  199:                     _COMMAND_LOGGER,
  200:                     clientId=client._topology_settings._topology_id,
  201:                     message=_CommandStatusMessage.FAILED,
  202:                     durationMS=duration,
  203:                     failure=failure,
  204:                     commandName=next(iter(cmd)),
  205:                     databaseName=dbn,
  206:                     requestId=request_id,
  207:                     operationId=request_id,
  208:                     driverConnectionId=conn.id,
  209:                     serverConnectionId=conn.server_connection_id,
  210:                     serverHost=conn.address[0],
  211:                     serverPort=conn.address[1],
  212:                     serviceId=conn.service_id,
  213:                     isServerSideError=isinstance(exc, OperationFailure),
  214:                 )
  215:             if publish:
  216:                 assert listeners is not None
  217:                 listeners.publish_command_failure(
  218:                     duration,
  219:                     failure,
  220:                     operation.name,
  221:                     request_id,
  222:                     conn.address,
  223:                     conn.server_connection_id,
  224:                     service_id=conn.service_id,
  225:                     database_name=dbn,
  226:                 )
  227:             raise
  228:         duration = datetime.now() - start
  229:         # Must publish in find / getMore / explain command response
  230:         # format.
  231:         if use_cmd:
  232:             res = docs[0]
  233:         elif operation.name == "explain":
  234:             res = docs[0] if docs else {}
  235:         else:
  236:             res = {"cursor": {"id": reply.cursor_id, "ns": operation.namespace()}, "ok": 1}  # type: ignore[union-attr]
  237:             if operation.name == "find":
  238:                 res["cursor"]["firstBatch"] = docs
  239:             else:
  240:                 res["cursor"]["nextBatch"] = docs
  241:         if _COMMAND_LOGGER.isEnabledFor(logging.DEBUG):
  242:             _debug_log(
  243:                 _COMMAND_LOGGER,
  244:                 clientId=client._topology_settings._topology_id,
  245:                 message=_CommandStatusMessage.SUCCEEDED,
  246:                 durationMS=duration,
  247:                 reply=res,
  248:                 commandName=next(iter(cmd)),
  249:                 databaseName=dbn,
  250:                 requestId=request_id,
  251:                 operationId=request_id,
  252:                 driverConnectionId=conn.id,
  253:                 serverConnectionId=conn.server_connection_id,
  254:                 serverHost=conn.address[0],
  255:                 serverPort=conn.address[1],
  256:                 serviceId=conn.service_id,
  257:             )
  258:         if publish:
  259:             assert listeners is not None
  260:             listeners.publish_command_success(
  261:                 duration,
  262:                 res,
  263:                 operation.name,
  264:                 request_id,
  265:                 conn.address,
  266:                 conn.server_connection_id,
  267:                 service_id=conn.service_id,
  268:                 database_name=dbn,
  269:             )
  270: 
  271:         # Decrypt response.
  272:         client = operation.client
  273:         if client and client._encrypter:
  274:             if use_cmd:
  275:                 decrypted = client._encrypter.decrypt(reply.raw_command_response())
  276:                 docs = _decode_all_selective(decrypted, operation.codec_options, user_fields)
  277: 
  278:         response: Response
  279: 
  280:         if client._should_pin_cursor(operation.session) or operation.exhaust:
  281:             conn.pin_cursor()
  282:             if isinstance(reply, _OpMsg):
  283:                 # In OP_MSG, the server keeps sending only if the
  284:                 # more_to_come flag is set.
  285:                 more_to_come = reply.more_to_come
  286:             else:
  287:                 # In OP_REPLY, the server keeps sending until cursor_id is 0.
  288:                 more_to_come = bool(operation.exhaust and reply.cursor_id)
  289:             if operation.conn_mgr:
  290:                 operation.conn_mgr.update_exhaust(more_to_come)
  291:             response = PinnedResponse(
  292:                 data=reply,
  293:                 address=self._description.address,
  294:                 conn=conn,
  295:                 duration=duration,
  296:                 request_id=request_id,
  297:                 from_command=use_cmd,
  298:                 docs=docs,
  299:                 more_to_come=more_to_come,
  300:             )
  301:         else:
  302:             response = Response(
  303:                 data=reply,
  304:                 address=self._description.address,
  305:                 duration=duration,
  306:                 request_id=request_id,
  307:                 from_command=use_cmd,
  308:                 docs=docs,
  309:             )
  310: 
  311:         return response
  312: 
  313:     def checkout(
  314:         self, handler: Optional[_MongoClientErrorHandler] = None
  315:     ) -> ContextManager[Connection]:
  316:         return self.pool.checkout(handler)
  317: 
  318:     @property
  319:     def description(self) -> ServerDescription:
  320:         return self._description
  321: 
  322:     @description.setter
  323:     def description(self, server_description: ServerDescription) -> None:
  324:         assert server_description.address == self._description.address
  325:         self._description = server_description
  326: 
  327:     @property
  328:     def pool(self) -> Pool:
  329:         return self._pool
  330: 
  331:     def _split_message(
  332:         self, message: Union[tuple[int, Any], tuple[int, Any, int]]
  333:     ) -> tuple[int, Any, int]:
  334:         """Return request_id, data, max_doc_size.
  335: 
  336:         :param message: (request_id, data, max_doc_size) or (request_id, data)
  337:         """
  338:         if len(message) == 3:
  339:             return message  # type: ignore[return-value]
  340:         else:
  341:             # get_more and kill_cursors messages don't include BSON documents.
  342:             request_id, data = message  # type: ignore[misc]
  343:             return request_id, data, 0
  344: 
  345:     def __repr__(self) -> str:
  346:         return f"<{self.__class__.__name__} {self._description!r}>"
