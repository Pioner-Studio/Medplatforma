    1: # Copyright 2014-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Represent a deployment of MongoDB servers."""
   16: from __future__ import annotations
   17: 
   18: from random import sample
   19: from typing import (
   20:     Any,
   21:     Callable,
   22:     List,
   23:     Mapping,
   24:     MutableMapping,
   25:     NamedTuple,
   26:     Optional,
   27:     cast,
   28: )
   29: 
   30: from bson.min_key import MinKey
   31: from bson.objectid import ObjectId
   32: from pymongo import common
   33: from pymongo.errors import ConfigurationError
   34: from pymongo.read_preferences import ReadPreference, _AggWritePref, _ServerMode
   35: from pymongo.server_description import ServerDescription
   36: from pymongo.server_selectors import Selection
   37: from pymongo.server_type import SERVER_TYPE
   38: from pymongo.typings import _Address
   39: 
   40: 
   41: # Enumeration for various kinds of MongoDB cluster topologies.
   42: class _TopologyType(NamedTuple):
   43:     Single: int
   44:     ReplicaSetNoPrimary: int
   45:     ReplicaSetWithPrimary: int
   46:     Sharded: int
   47:     Unknown: int
   48:     LoadBalanced: int
   49: 
   50: 
   51: TOPOLOGY_TYPE = _TopologyType(*range(6))
   52: 
   53: # Topologies compatible with SRV record polling.
   54: SRV_POLLING_TOPOLOGIES: tuple[int, int] = (TOPOLOGY_TYPE.Unknown, TOPOLOGY_TYPE.Sharded)
   55: 
   56: 
   57: _ServerSelector = Callable[[List[ServerDescription]], List[ServerDescription]]
   58: 
   59: 
   60: class TopologyDescription:
   61:     def __init__(
   62:         self,
   63:         topology_type: int,
   64:         server_descriptions: dict[_Address, ServerDescription],
   65:         replica_set_name: Optional[str],
   66:         max_set_version: Optional[int],
   67:         max_election_id: Optional[ObjectId],
   68:         topology_settings: Any,
   69:     ) -> None:
   70:         """Representation of a deployment of MongoDB servers.
   71: 
   72:         :param topology_type: initial type
   73:         :param server_descriptions: dict of (address, ServerDescription) for
   74:             all seeds
   75:         :param replica_set_name: replica set name or None
   76:         :param max_set_version: greatest setVersion seen from a primary, or None
   77:         :param max_election_id: greatest electionId seen from a primary, or None
   78:         :param topology_settings: a TopologySettings
   79:         """
   80:         self._topology_type = topology_type
   81:         self._replica_set_name = replica_set_name
   82:         self._server_descriptions = server_descriptions
   83:         self._max_set_version = max_set_version
   84:         self._max_election_id = max_election_id
   85: 
   86:         # The heartbeat_frequency is used in staleness estimates.
   87:         self._topology_settings = topology_settings
   88: 
   89:         # Is PyMongo compatible with all servers' wire protocols?
   90:         self._incompatible_err = None
   91:         if self._topology_type != TOPOLOGY_TYPE.LoadBalanced:
   92:             self._init_incompatible_err()
   93: 
   94:         # Server Discovery And Monitoring Spec: Whenever a client updates the
   95:         # TopologyDescription from an hello response, it MUST set
   96:         # TopologyDescription.logicalSessionTimeoutMinutes to the smallest
   97:         # logicalSessionTimeoutMinutes value among ServerDescriptions of all
   98:         # data-bearing server types. If any have a null
   99:         # logicalSessionTimeoutMinutes, then
  100:         # TopologyDescription.logicalSessionTimeoutMinutes MUST be set to null.
  101:         readable_servers = self.readable_servers
  102:         if not readable_servers:
  103:             self._ls_timeout_minutes = None
  104:         elif any(s.logical_session_timeout_minutes is None for s in readable_servers):
  105:             self._ls_timeout_minutes = None
  106:         else:
  107:             self._ls_timeout_minutes = min(  # type: ignore[type-var]
  108:                 s.logical_session_timeout_minutes for s in readable_servers
  109:             )
  110: 
  111:     def _init_incompatible_err(self) -> None:
  112:         """Internal compatibility check for non-load balanced topologies."""
  113:         for s in self._server_descriptions.values():
  114:             if not s.is_server_type_known:
  115:                 continue
  116: 
  117:             # s.min/max_wire_version is the server's wire protocol.
  118:             # MIN/MAX_SUPPORTED_WIRE_VERSION is what PyMongo supports.
  119:             server_too_new = (
  120:                 # Server too new.
  121:                 s.min_wire_version is not None
  122:                 and s.min_wire_version > common.MAX_SUPPORTED_WIRE_VERSION
  123:             )
  124: 
  125:             server_too_old = (
  126:                 # Server too old.
  127:                 s.max_wire_version is not None
  128:                 and s.max_wire_version < common.MIN_SUPPORTED_WIRE_VERSION
  129:             )
  130: 
  131:             if server_too_new:
  132:                 self._incompatible_err = (
  133:                     "Server at %s:%d requires wire version %d, but this "  # type: ignore
  134:                     "version of PyMongo only supports up to %d."
  135:                     % (
  136:                         s.address[0],
  137:                         s.address[1] or 0,
  138:                         s.min_wire_version,
  139:                         common.MAX_SUPPORTED_WIRE_VERSION,
  140:                     )
  141:                 )
  142: 
  143:             elif server_too_old:
  144:                 self._incompatible_err = (
  145:                     "Server at %s:%d reports wire version %d, but this "  # type: ignore
  146:                     "version of PyMongo requires at least %d (MongoDB %s)."
  147:                     % (
  148:                         s.address[0],
  149:                         s.address[1] or 0,
  150:                         s.max_wire_version,
  151:                         common.MIN_SUPPORTED_WIRE_VERSION,
  152:                         common.MIN_SUPPORTED_SERVER_VERSION,
  153:                     )
  154:                 )
  155: 
  156:                 break
  157: 
  158:     def check_compatible(self) -> None:
  159:         """Raise ConfigurationError if any server is incompatible.
  160: 
  161:         A server is incompatible if its wire protocol version range does not
  162:         overlap with PyMongo's.
  163:         """
  164:         if self._incompatible_err:
  165:             raise ConfigurationError(self._incompatible_err)
  166: 
  167:     def has_server(self, address: _Address) -> bool:
  168:         return address in self._server_descriptions
  169: 
  170:     def reset_server(self, address: _Address) -> TopologyDescription:
  171:         """A copy of this description, with one server marked Unknown."""
  172:         unknown_sd = self._server_descriptions[address].to_unknown()
  173:         return updated_topology_description(self, unknown_sd)
  174: 
  175:     def reset(self) -> TopologyDescription:
  176:         """A copy of this description, with all servers marked Unknown."""
  177:         if self._topology_type == TOPOLOGY_TYPE.ReplicaSetWithPrimary:
  178:             topology_type = TOPOLOGY_TYPE.ReplicaSetNoPrimary
  179:         else:
  180:             topology_type = self._topology_type
  181: 
  182:         # The default ServerDescription's type is Unknown.
  183:         sds = {address: ServerDescription(address) for address in self._server_descriptions}
  184: 
  185:         return TopologyDescription(
  186:             topology_type,
  187:             sds,
  188:             self._replica_set_name,
  189:             self._max_set_version,
  190:             self._max_election_id,
  191:             self._topology_settings,
  192:         )
  193: 
  194:     def server_descriptions(self) -> dict[_Address, ServerDescription]:
  195:         """dict of (address,
  196:         :class:`~pymongo.server_description.ServerDescription`).
  197:         """
  198:         return self._server_descriptions.copy()
  199: 
  200:     @property
  201:     def topology_type(self) -> int:
  202:         """The type of this topology."""
  203:         return self._topology_type
  204: 
  205:     @property
  206:     def topology_type_name(self) -> str:
  207:         """The topology type as a human readable string.
  208: 
  209:         .. versionadded:: 3.4
  210:         """
  211:         return TOPOLOGY_TYPE._fields[self._topology_type]
  212: 
  213:     @property
  214:     def replica_set_name(self) -> Optional[str]:
  215:         """The replica set name."""
  216:         return self._replica_set_name
  217: 
  218:     @property
  219:     def max_set_version(self) -> Optional[int]:
  220:         """Greatest setVersion seen from a primary, or None."""
  221:         return self._max_set_version
  222: 
  223:     @property
  224:     def max_election_id(self) -> Optional[ObjectId]:
  225:         """Greatest electionId seen from a primary, or None."""
  226:         return self._max_election_id
  227: 
  228:     @property
  229:     def logical_session_timeout_minutes(self) -> Optional[int]:
  230:         """Minimum logical session timeout, or None."""
  231:         return self._ls_timeout_minutes
  232: 
  233:     @property
  234:     def known_servers(self) -> list[ServerDescription]:
  235:         """List of Servers of types besides Unknown."""
  236:         return [s for s in self._server_descriptions.values() if s.is_server_type_known]
  237: 
  238:     @property
  239:     def has_known_servers(self) -> bool:
  240:         """Whether there are any Servers of types besides Unknown."""
  241:         return any(s for s in self._server_descriptions.values() if s.is_server_type_known)
  242: 
  243:     @property
  244:     def readable_servers(self) -> list[ServerDescription]:
  245:         """List of readable Servers."""
  246:         return [s for s in self._server_descriptions.values() if s.is_readable]
  247: 
  248:     @property
  249:     def common_wire_version(self) -> Optional[int]:
  250:         """Minimum of all servers' max wire versions, or None."""
  251:         servers = self.known_servers
  252:         if servers:
  253:             return min(s.max_wire_version for s in self.known_servers)
  254: 
  255:         return None
  256: 
  257:     @property
  258:     def heartbeat_frequency(self) -> int:
  259:         return self._topology_settings.heartbeat_frequency
  260: 
  261:     @property
  262:     def srv_max_hosts(self) -> int:
  263:         return self._topology_settings._srv_max_hosts
  264: 
  265:     def _apply_local_threshold(self, selection: Optional[Selection]) -> list[ServerDescription]:
  266:         if not selection:
  267:             return []
  268:         round_trip_times: list[float] = []
  269:         for server in selection.server_descriptions:
  270:             if server.round_trip_time is None:
  271:                 config_err_msg = f"round_trip_time for server {server.address} is unexpectedly None: {self}, servers: {selection.server_descriptions}"
  272:                 raise ConfigurationError(config_err_msg)
  273:             round_trip_times.append(server.round_trip_time)
  274:         # Round trip time in seconds.
  275:         fastest = min(round_trip_times)
  276:         threshold = self._topology_settings.local_threshold_ms / 1000.0
  277:         return [
  278:             s
  279:             for s in selection.server_descriptions
  280:             if (cast(float, s.round_trip_time) - fastest) <= threshold
  281:         ]
  282: 
  283:     def apply_selector(
  284:         self,
  285:         selector: Any,
  286:         address: Optional[_Address] = None,
  287:         custom_selector: Optional[_ServerSelector] = None,
  288:     ) -> list[ServerDescription]:
  289:         """List of servers matching the provided selector(s).
  290: 
  291:         :param selector: a callable that takes a Selection as input and returns
  292:             a Selection as output. For example, an instance of a read
  293:             preference from :mod:`~pymongo.read_preferences`.
  294:         :param address: A server address to select.
  295:         :param custom_selector: A callable that augments server
  296:             selection rules. Accepts a list of
  297:             :class:`~pymongo.server_description.ServerDescription` objects and
  298:             return a list of server descriptions that should be considered
  299:             suitable for the desired operation.
  300: 
  301:         .. versionadded:: 3.4
  302:         """
  303:         if getattr(selector, "min_wire_version", 0):
  304:             common_wv = self.common_wire_version
  305:             if common_wv and common_wv < selector.min_wire_version:
  306:                 raise ConfigurationError(
  307:                     "%s requires min wire version %d, but topology's min"
  308:                     " wire version is %d" % (selector, selector.min_wire_version, common_wv)
  309:                 )
  310: 
  311:         if isinstance(selector, _AggWritePref):
  312:             selector.selection_hook(self)
  313: 
  314:         if self.topology_type == TOPOLOGY_TYPE.Unknown:
  315:             return []
  316:         elif self.topology_type in (TOPOLOGY_TYPE.Single, TOPOLOGY_TYPE.LoadBalanced):
  317:             # Ignore selectors for standalone and load balancer mode.
  318:             return self.known_servers
  319:         if address:
  320:             # Ignore selectors when explicit address is requested.
  321:             description = self.server_descriptions().get(address)
  322:             return [description] if description else []
  323: 
  324:         selection = Selection.from_topology_description(self)
  325:         # Ignore read preference for sharded clusters.
  326:         if self.topology_type != TOPOLOGY_TYPE.Sharded:
  327:             selection = selector(selection)
  328: 
  329:         # Apply custom selector followed by localThresholdMS.
  330:         if custom_selector is not None and selection:
  331:             selection = selection.with_server_descriptions(
  332:                 custom_selector(selection.server_descriptions)
  333:             )
  334:         return self._apply_local_threshold(selection)
  335: 
  336:     def has_readable_server(self, read_preference: _ServerMode = ReadPreference.PRIMARY) -> bool:
  337:         """Does this topology have any readable servers available matching the
  338:         given read preference?
  339: 
  340:         :param read_preference: an instance of a read preference from
  341:             :mod:`~pymongo.read_preferences`. Defaults to
  342:             :attr:`~pymongo.read_preferences.ReadPreference.PRIMARY`.
  343: 
  344:         .. note:: When connected directly to a single server this method
  345:           always returns ``True``.
  346: 
  347:         .. versionadded:: 3.4
  348:         """
  349:         common.validate_read_preference("read_preference", read_preference)
  350:         return any(self.apply_selector(read_preference))
  351: 
  352:     def has_writable_server(self) -> bool:
  353:         """Does this topology have a writable server available?
  354: 
  355:         .. note:: When connected directly to a single server this method
  356:           always returns ``True``.
  357: 
  358:         .. versionadded:: 3.4
  359:         """
  360:         return self.has_readable_server(ReadPreference.PRIMARY)
  361: 
  362:     def __repr__(self) -> str:
  363:         # Sort the servers by address.
  364:         servers = sorted(self._server_descriptions.values(), key=lambda sd: sd.address)
  365:         return "<{} id: {}, topology_type: {}, servers: {!r}>".format(
  366:             self.__class__.__name__,
  367:             self._topology_settings._topology_id,
  368:             self.topology_type_name,
  369:             servers,
  370:         )
  371: 
  372: 
  373: # If topology type is Unknown and we receive a hello response, what should
  374: # the new topology type be?
  375: _SERVER_TYPE_TO_TOPOLOGY_TYPE = {
  376:     SERVER_TYPE.Mongos: TOPOLOGY_TYPE.Sharded,
  377:     SERVER_TYPE.RSPrimary: TOPOLOGY_TYPE.ReplicaSetWithPrimary,
  378:     SERVER_TYPE.RSSecondary: TOPOLOGY_TYPE.ReplicaSetNoPrimary,
  379:     SERVER_TYPE.RSArbiter: TOPOLOGY_TYPE.ReplicaSetNoPrimary,
  380:     SERVER_TYPE.RSOther: TOPOLOGY_TYPE.ReplicaSetNoPrimary,
  381:     # Note: SERVER_TYPE.LoadBalancer and Unknown are intentionally left out.
  382: }
  383: 
  384: 
  385: def updated_topology_description(
  386:     topology_description: TopologyDescription, server_description: ServerDescription
  387: ) -> TopologyDescription:
  388:     """Return an updated copy of a TopologyDescription.
  389: 
  390:     :param topology_description: the current TopologyDescription
  391:     :param server_description: a new ServerDescription that resulted from
  392:         a hello call
  393: 
  394:     Called after attempting (successfully or not) to call hello on the
  395:     server at server_description.address. Does not modify topology_description.
  396:     """
  397:     address = server_description.address
  398: 
  399:     # These values will be updated, if necessary, to form the new
  400:     # TopologyDescription.
  401:     topology_type = topology_description.topology_type
  402:     set_name = topology_description.replica_set_name
  403:     max_set_version = topology_description.max_set_version
  404:     max_election_id = topology_description.max_election_id
  405:     server_type = server_description.server_type
  406: 
  407:     # Don't mutate the original dict of server descriptions; copy it.
  408:     sds = topology_description.server_descriptions()
  409: 
  410:     # Replace this server's description with the new one.
  411:     sds[address] = server_description
  412: 
  413:     if topology_type == TOPOLOGY_TYPE.Single:
  414:         # Set server type to Unknown if replica set name does not match.
  415:         if set_name is not None and set_name != server_description.replica_set_name:
  416:             error = ConfigurationError(
  417:                 "client is configured to connect to a replica set named "
  418:                 "'{}' but this node belongs to a set named '{}'".format(
  419:                     set_name, server_description.replica_set_name
  420:                 )
  421:             )
  422:             sds[address] = server_description.to_unknown(error=error)
  423:         # Single type never changes.
  424:         return TopologyDescription(
  425:             TOPOLOGY_TYPE.Single,
  426:             sds,
  427:             set_name,
  428:             max_set_version,
  429:             max_election_id,
  430:             topology_description._topology_settings,
  431:         )
  432: 
  433:     if topology_type == TOPOLOGY_TYPE.Unknown:
  434:         if server_type in (SERVER_TYPE.Standalone, SERVER_TYPE.LoadBalancer):
  435:             if len(topology_description._topology_settings.seeds) == 1:
  436:                 topology_type = TOPOLOGY_TYPE.Single
  437:             else:
  438:                 # Remove standalone from Topology when given multiple seeds.
  439:                 sds.pop(address)
  440:         elif server_type not in (SERVER_TYPE.Unknown, SERVER_TYPE.RSGhost):
  441:             topology_type = _SERVER_TYPE_TO_TOPOLOGY_TYPE[server_type]
  442: 
  443:     if topology_type == TOPOLOGY_TYPE.Sharded:
  444:         if server_type not in (SERVER_TYPE.Mongos, SERVER_TYPE.Unknown):
  445:             sds.pop(address)
  446: 
  447:     elif topology_type == TOPOLOGY_TYPE.ReplicaSetNoPrimary:
  448:         if server_type in (SERVER_TYPE.Standalone, SERVER_TYPE.Mongos):
  449:             sds.pop(address)
  450: 
  451:         elif server_type == SERVER_TYPE.RSPrimary:
  452:             (topology_type, set_name, max_set_version, max_election_id) = _update_rs_from_primary(
  453:                 sds, set_name, server_description, max_set_version, max_election_id
  454:             )
  455: 
  456:         elif server_type in (SERVER_TYPE.RSSecondary, SERVER_TYPE.RSArbiter, SERVER_TYPE.RSOther):
  457:             topology_type, set_name = _update_rs_no_primary_from_member(
  458:                 sds, set_name, server_description
  459:             )
  460: 
  461:     elif topology_type == TOPOLOGY_TYPE.ReplicaSetWithPrimary:
  462:         if server_type in (SERVER_TYPE.Standalone, SERVER_TYPE.Mongos):
  463:             sds.pop(address)
  464:             topology_type = _check_has_primary(sds)
  465: 
  466:         elif server_type == SERVER_TYPE.RSPrimary:
  467:             (topology_type, set_name, max_set_version, max_election_id) = _update_rs_from_primary(
  468:                 sds, set_name, server_description, max_set_version, max_election_id
  469:             )
  470: 
  471:         elif server_type in (SERVER_TYPE.RSSecondary, SERVER_TYPE.RSArbiter, SERVER_TYPE.RSOther):
  472:             topology_type = _update_rs_with_primary_from_member(sds, set_name, server_description)
  473: 
  474:         else:
  475:             # Server type is Unknown or RSGhost: did we just lose the primary?
  476:             topology_type = _check_has_primary(sds)
  477: 
  478:     # Return updated copy.
  479:     return TopologyDescription(
  480:         topology_type,
  481:         sds,
  482:         set_name,
  483:         max_set_version,
  484:         max_election_id,
  485:         topology_description._topology_settings,
  486:     )
  487: 
  488: 
  489: def _updated_topology_description_srv_polling(
  490:     topology_description: TopologyDescription, seedlist: list[tuple[str, Any]]
  491: ) -> TopologyDescription:
  492:     """Return an updated copy of a TopologyDescription.
  493: 
  494:     :param topology_description: the current TopologyDescription
  495:     :param seedlist: a list of new seeds new ServerDescription that resulted from
  496:         a hello call
  497:     """
  498:     assert topology_description.topology_type in SRV_POLLING_TOPOLOGIES
  499:     # Create a copy of the server descriptions.
  500:     sds = topology_description.server_descriptions()
  501: 
  502:     # If seeds haven't changed, don't do anything.
  503:     if set(sds.keys()) == set(seedlist):
  504:         return topology_description
  505: 
  506:     # Remove SDs corresponding to servers no longer part of the SRV record.
  507:     for address in list(sds.keys()):
  508:         if address not in seedlist:
  509:             sds.pop(address)
  510: 
  511:     if topology_description.srv_max_hosts != 0:
  512:         new_hosts = set(seedlist) - set(sds.keys())
  513:         n_to_add = topology_description.srv_max_hosts - len(sds)
  514:         if n_to_add > 0:
  515:             seedlist = sample(sorted(new_hosts), min(n_to_add, len(new_hosts)))
  516:         else:
  517:             seedlist = []
  518:     # Add SDs corresponding to servers recently added to the SRV record.
  519:     for address in seedlist:
  520:         if address not in sds:
  521:             sds[address] = ServerDescription(address)
  522:     return TopologyDescription(
  523:         topology_description.topology_type,
  524:         sds,
  525:         topology_description.replica_set_name,
  526:         topology_description.max_set_version,
  527:         topology_description.max_election_id,
  528:         topology_description._topology_settings,
  529:     )
  530: 
  531: 
  532: def _update_rs_from_primary(
  533:     sds: MutableMapping[_Address, ServerDescription],
  534:     replica_set_name: Optional[str],
  535:     server_description: ServerDescription,
  536:     max_set_version: Optional[int],
  537:     max_election_id: Optional[ObjectId],
  538: ) -> tuple[int, Optional[str], Optional[int], Optional[ObjectId]]:
  539:     """Update topology description from a primary's hello response.
  540: 
  541:     Pass in a dict of ServerDescriptions, current replica set name, the
  542:     ServerDescription we are processing, and the TopologyDescription's
  543:     max_set_version and max_election_id if any.
  544: 
  545:     Returns (new topology type, new replica_set_name, new max_set_version,
  546:     new max_election_id).
  547:     """
  548:     if replica_set_name is None:
  549:         replica_set_name = server_description.replica_set_name
  550: 
  551:     elif replica_set_name != server_description.replica_set_name:
  552:         # We found a primary but it doesn't have the replica_set_name
  553:         # provided by the user.
  554:         sds.pop(server_description.address)
  555:         return _check_has_primary(sds), replica_set_name, max_set_version, max_election_id
  556: 
  557:     if server_description.max_wire_version is None or server_description.max_wire_version < 17:
  558:         new_election_tuple: tuple = (server_description.set_version, server_description.election_id)
  559:         max_election_tuple: tuple = (max_set_version, max_election_id)
  560:         if None not in new_election_tuple:
  561:             if None not in max_election_tuple and new_election_tuple < max_election_tuple:
  562:                 # Stale primary, set to type Unknown.
  563:                 sds[server_description.address] = server_description.to_unknown()
  564:                 return _check_has_primary(sds), replica_set_name, max_set_version, max_election_id
  565:             max_election_id = server_description.election_id
  566: 
  567:         if server_description.set_version is not None and (
  568:             max_set_version is None or server_description.set_version > max_set_version
  569:         ):
  570:             max_set_version = server_description.set_version
  571:     else:
  572:         new_election_tuple = server_description.election_id, server_description.set_version
  573:         max_election_tuple = max_election_id, max_set_version
  574:         new_election_safe = tuple(MinKey() if i is None else i for i in new_election_tuple)
  575:         max_election_safe = tuple(MinKey() if i is None else i for i in max_election_tuple)
  576:         if new_election_safe < max_election_safe:
  577:             # Stale primary, set to type Unknown.
  578:             sds[server_description.address] = server_description.to_unknown()
  579:             return _check_has_primary(sds), replica_set_name, max_set_version, max_election_id
  580:         else:
  581:             max_election_id = server_description.election_id
  582:             max_set_version = server_description.set_version
  583: 
  584:     # We've heard from the primary. Is it the same primary as before?
  585:     for server in sds.values():
  586:         if (
  587:             server.server_type is SERVER_TYPE.RSPrimary
  588:             and server.address != server_description.address
  589:         ):
  590:             # Reset old primary's type to Unknown.
  591:             sds[server.address] = server.to_unknown()
  592: 
  593:             # There can be only one prior primary.
  594:             break
  595: 
  596:     # Discover new hosts from this primary's response.
  597:     for new_address in server_description.all_hosts:
  598:         if new_address not in sds:
  599:             sds[new_address] = ServerDescription(new_address)
  600: 
  601:     # Remove hosts not in the response.
  602:     for addr in set(sds) - server_description.all_hosts:
  603:         sds.pop(addr)
  604: 
  605:     # If the host list differs from the seed list, we may not have a primary
  606:     # after all.
  607:     return (_check_has_primary(sds), replica_set_name, max_set_version, max_election_id)
  608: 
  609: 
  610: def _update_rs_with_primary_from_member(
  611:     sds: MutableMapping[_Address, ServerDescription],
  612:     replica_set_name: Optional[str],
  613:     server_description: ServerDescription,
  614: ) -> int:
  615:     """RS with known primary. Process a response from a non-primary.
  616: 
  617:     Pass in a dict of ServerDescriptions, current replica set name, and the
  618:     ServerDescription we are processing.
  619: 
  620:     Returns new topology type.
  621:     """
  622:     assert replica_set_name is not None
  623: 
  624:     if replica_set_name != server_description.replica_set_name:
  625:         sds.pop(server_description.address)
  626:     elif server_description.me and server_description.address != server_description.me:
  627:         sds.pop(server_description.address)
  628: 
  629:     # Had this member been the primary?
  630:     return _check_has_primary(sds)
  631: 
  632: 
  633: def _update_rs_no_primary_from_member(
  634:     sds: MutableMapping[_Address, ServerDescription],
  635:     replica_set_name: Optional[str],
  636:     server_description: ServerDescription,
  637: ) -> tuple[int, Optional[str]]:
  638:     """RS without known primary. Update from a non-primary's response.
  639: 
  640:     Pass in a dict of ServerDescriptions, current replica set name, and the
  641:     ServerDescription we are processing.
  642: 
  643:     Returns (new topology type, new replica_set_name).
  644:     """
  645:     topology_type = TOPOLOGY_TYPE.ReplicaSetNoPrimary
  646:     if replica_set_name is None:
  647:         replica_set_name = server_description.replica_set_name
  648: 
  649:     elif replica_set_name != server_description.replica_set_name:
  650:         sds.pop(server_description.address)
  651:         return topology_type, replica_set_name
  652: 
  653:     # This isn't the primary's response, so don't remove any servers
  654:     # it doesn't report. Only add new servers.
  655:     for address in server_description.all_hosts:
  656:         if address not in sds:
  657:             sds[address] = ServerDescription(address)
  658: 
  659:     if server_description.me and server_description.address != server_description.me:
  660:         sds.pop(server_description.address)
  661: 
  662:     return topology_type, replica_set_name
  663: 
  664: 
  665: def _check_has_primary(sds: Mapping[_Address, ServerDescription]) -> int:
  666:     """Current topology type is ReplicaSetWithPrimary. Is primary still known?
  667: 
  668:     Pass in a dict of ServerDescriptions.
  669: 
  670:     Returns new topology type.
  671:     """
  672:     for s in sds.values():
  673:         if s.server_type == SERVER_TYPE.RSPrimary:
  674:             return TOPOLOGY_TYPE.ReplicaSetWithPrimary
  675:     else:  # noqa: PLW0120
  676:         return TOPOLOGY_TYPE.ReplicaSetNoPrimary
