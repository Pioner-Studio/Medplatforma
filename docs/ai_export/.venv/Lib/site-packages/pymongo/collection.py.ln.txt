    1: # Copyright 2009-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Collection level utilities for Mongo."""
   16: from __future__ import annotations
   17: 
   18: from collections import abc
   19: from typing import (
   20:     TYPE_CHECKING,
   21:     Any,
   22:     Callable,
   23:     ContextManager,
   24:     Generic,
   25:     Iterable,
   26:     Iterator,
   27:     Mapping,
   28:     MutableMapping,
   29:     NoReturn,
   30:     Optional,
   31:     Sequence,
   32:     Type,
   33:     TypeVar,
   34:     Union,
   35:     cast,
   36: )
   37: 
   38: from bson.codec_options import DEFAULT_CODEC_OPTIONS, CodecOptions
   39: from bson.objectid import ObjectId
   40: from bson.raw_bson import RawBSONDocument
   41: from bson.son import SON
   42: from bson.timestamp import Timestamp
   43: from pymongo import ASCENDING, _csot, common, helpers, message
   44: from pymongo.aggregation import (
   45:     _CollectionAggregationCommand,
   46:     _CollectionRawAggregationCommand,
   47: )
   48: from pymongo.bulk import _Bulk
   49: from pymongo.change_stream import CollectionChangeStream
   50: from pymongo.collation import validate_collation_or_none
   51: from pymongo.command_cursor import CommandCursor, RawBatchCommandCursor
   52: from pymongo.common import _ecoc_coll_name, _esc_coll_name
   53: from pymongo.cursor import Cursor, RawBatchCursor
   54: from pymongo.errors import (
   55:     ConfigurationError,
   56:     InvalidName,
   57:     InvalidOperation,
   58:     OperationFailure,
   59: )
   60: from pymongo.helpers import _check_write_command_response
   61: from pymongo.message import _UNICODE_REPLACE_CODEC_OPTIONS
   62: from pymongo.operations import (
   63:     DeleteMany,
   64:     DeleteOne,
   65:     IndexModel,
   66:     InsertOne,
   67:     ReplaceOne,
   68:     SearchIndexModel,
   69:     UpdateMany,
   70:     UpdateOne,
   71:     _IndexKeyHint,
   72:     _IndexList,
   73:     _Op,
   74: )
   75: from pymongo.read_concern import DEFAULT_READ_CONCERN, ReadConcern
   76: from pymongo.read_preferences import ReadPreference, _ServerMode
   77: from pymongo.results import (
   78:     BulkWriteResult,
   79:     DeleteResult,
   80:     InsertManyResult,
   81:     InsertOneResult,
   82:     UpdateResult,
   83: )
   84: from pymongo.typings import _CollationIn, _DocumentType, _DocumentTypeArg, _Pipeline
   85: from pymongo.write_concern import DEFAULT_WRITE_CONCERN, WriteConcern, validate_boolean
   86: 
   87: T = TypeVar("T")
   88: 
   89: _FIND_AND_MODIFY_DOC_FIELDS = {"value": 1}
   90: 
   91: 
   92: _WriteOp = Union[
   93:     InsertOne[_DocumentType],
   94:     DeleteOne,
   95:     DeleteMany,
   96:     ReplaceOne[_DocumentType],
   97:     UpdateOne,
   98:     UpdateMany,
   99: ]
  100: 
  101: 
  102: class ReturnDocument:
  103:     """An enum used with
  104:     :meth:`~pymongo.collection.Collection.find_one_and_replace` and
  105:     :meth:`~pymongo.collection.Collection.find_one_and_update`.
  106:     """
  107: 
  108:     BEFORE = False
  109:     """Return the original document before it was updated/replaced, or
  110:     ``None`` if no document matches the query.
  111:     """
  112:     AFTER = True
  113:     """Return the updated/replaced or inserted document."""
  114: 
  115: 
  116: if TYPE_CHECKING:
  117:     from pymongo.aggregation import _AggregationCommand
  118:     from pymongo.client_session import ClientSession
  119:     from pymongo.collation import Collation
  120:     from pymongo.database import Database
  121:     from pymongo.pool import Connection
  122:     from pymongo.server import Server
  123: 
  124: 
  125: class Collection(common.BaseObject, Generic[_DocumentType]):
  126:     """A Mongo collection."""
  127: 
  128:     def __init__(
  129:         self,
  130:         database: Database[_DocumentType],
  131:         name: str,
  132:         create: Optional[bool] = False,
  133:         codec_options: Optional[CodecOptions[_DocumentTypeArg]] = None,
  134:         read_preference: Optional[_ServerMode] = None,
  135:         write_concern: Optional[WriteConcern] = None,
  136:         read_concern: Optional[ReadConcern] = None,
  137:         session: Optional[ClientSession] = None,
  138:         **kwargs: Any,
  139:     ) -> None:
  140:         """Get / create a Mongo collection.
  141: 
  142:         Raises :class:`TypeError` if `name` is not an instance of
  143:         :class:`str`. Raises :class:`~pymongo.errors.InvalidName` if `name` is
  144:         not a valid collection name. Any additional keyword arguments will be used
  145:         as options passed to the create command. See
  146:         :meth:`~pymongo.database.Database.create_collection` for valid
  147:         options.
  148: 
  149:         If `create` is ``True``, `collation` is specified, or any additional
  150:         keyword arguments are present, a ``create`` command will be
  151:         sent, using ``session`` if specified. Otherwise, a ``create`` command
  152:         will not be sent and the collection will be created implicitly on first
  153:         use. The optional ``session`` argument is *only* used for the ``create``
  154:         command, it is not associated with the collection afterward.
  155: 
  156:         :param database: the database to get a collection from
  157:         :param name: the name of the collection to get
  158:         :param create: if ``True``, force collection
  159:             creation even without options being set
  160:         :param codec_options: An instance of
  161:             :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
  162:             default) database.codec_options is used.
  163:         :param read_preference: The read preference to use. If
  164:             ``None`` (the default) database.read_preference is used.
  165:         :param write_concern: An instance of
  166:             :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
  167:             default) database.write_concern is used.
  168:         :param read_concern: An instance of
  169:             :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
  170:             default) database.read_concern is used.
  171:         :param collation: An instance of
  172:             :class:`~pymongo.collation.Collation`. If a collation is provided,
  173:             it will be passed to the create collection command.
  174:         :param session: a
  175:             :class:`~pymongo.client_session.ClientSession` that is used with
  176:             the create collection command
  177:         :param kwargs: additional keyword arguments will
  178:             be passed as options for the create collection command
  179: 
  180:         .. versionchanged:: 4.2
  181:            Added the ``clusteredIndex`` and ``encryptedFields`` parameters.
  182: 
  183:         .. versionchanged:: 4.0
  184:            Removed the reindex, map_reduce, inline_map_reduce,
  185:            parallel_scan, initialize_unordered_bulk_op,
  186:            initialize_ordered_bulk_op, group, count, insert, save,
  187:            update, remove, find_and_modify, and ensure_index methods. See the
  188:            :ref:`pymongo4-migration-guide`.
  189: 
  190:         .. versionchanged:: 3.6
  191:            Added ``session`` parameter.
  192: 
  193:         .. versionchanged:: 3.4
  194:            Support the `collation` option.
  195: 
  196:         .. versionchanged:: 3.2
  197:            Added the read_concern option.
  198: 
  199:         .. versionchanged:: 3.0
  200:            Added the codec_options, read_preference, and write_concern options.
  201:            Removed the uuid_subtype attribute.
  202:            :class:`~pymongo.collection.Collection` no longer returns an
  203:            instance of :class:`~pymongo.collection.Collection` for attribute
  204:            names with leading underscores. You must use dict-style lookups
  205:            instead::
  206: 
  207:                collection['__my_collection__']
  208: 
  209:            Not:
  210: 
  211:                collection.__my_collection__
  212: 
  213:         .. seealso:: The MongoDB documentation on `collections <https://dochub.mongodb.org/core/collections>`_.
  214:         """
  215:         super().__init__(
  216:             codec_options or database.codec_options,
  217:             read_preference or database.read_preference,
  218:             write_concern or database.write_concern,
  219:             read_concern or database.read_concern,
  220:         )
  221:         if not isinstance(name, str):
  222:             raise TypeError("name must be an instance of str")
  223: 
  224:         if not name or ".." in name:
  225:             raise InvalidName("collection names cannot be empty")
  226:         if "$" in name and not (name.startswith(("oplog.$main", "$cmd"))):
  227:             raise InvalidName("collection names must not contain '$': %r" % name)
  228:         if name[0] == "." or name[-1] == ".":
  229:             raise InvalidName("collection names must not start or end with '.': %r" % name)
  230:         if "\x00" in name:
  231:             raise InvalidName("collection names must not contain the null character")
  232:         collation = validate_collation_or_none(kwargs.pop("collation", None))
  233: 
  234:         self.__database: Database[_DocumentType] = database
  235:         self.__name = name
  236:         self.__full_name = f"{self.__database.name}.{self.__name}"
  237:         self.__write_response_codec_options = self.codec_options._replace(
  238:             unicode_decode_error_handler="replace", document_class=dict
  239:         )
  240:         self._timeout = database.client.options.timeout
  241:         encrypted_fields = kwargs.pop("encryptedFields", None)
  242:         if create or kwargs or collation:
  243:             if encrypted_fields:
  244:                 common.validate_is_mapping("encrypted_fields", encrypted_fields)
  245:                 opts = {"clusteredIndex": {"key": {"_id": 1}, "unique": True}}
  246:                 self.__create(
  247:                     _esc_coll_name(encrypted_fields, name), opts, None, session, qev2_required=True
  248:                 )
  249:                 self.__create(_ecoc_coll_name(encrypted_fields, name), opts, None, session)
  250:                 self.__create(name, kwargs, collation, session, encrypted_fields=encrypted_fields)
  251:                 self.create_index([("__safeContent__", ASCENDING)], session)
  252:             else:
  253:                 self.__create(name, kwargs, collation, session)
  254: 
  255:     def _conn_for_writes(
  256:         self, session: Optional[ClientSession], operation: str
  257:     ) -> ContextManager[Connection]:
  258:         return self.__database.client._conn_for_writes(session, operation)
  259: 
  260:     def _command(
  261:         self,
  262:         conn: Connection,
  263:         command: MutableMapping[str, Any],
  264:         read_preference: Optional[_ServerMode] = None,
  265:         codec_options: Optional[CodecOptions] = None,
  266:         check: bool = True,
  267:         allowable_errors: Optional[Sequence[Union[str, int]]] = None,
  268:         read_concern: Optional[ReadConcern] = None,
  269:         write_concern: Optional[WriteConcern] = None,
  270:         collation: Optional[_CollationIn] = None,
  271:         session: Optional[ClientSession] = None,
  272:         retryable_write: bool = False,
  273:         user_fields: Optional[Any] = None,
  274:     ) -> Mapping[str, Any]:
  275:         """Internal command helper.
  276: 
  277:         :param conn` - A Connection instance.
  278:         :param command` - The command itself, as a :class:`~bson.son.SON` instance.
  279:         :param read_preference` (optional) - The read preference to use.
  280:         :param codec_options` (optional) - An instance of
  281:             :class:`~bson.codec_options.CodecOptions`.
  282:         :param check: raise OperationFailure if there are errors
  283:         :param allowable_errors: errors to ignore if `check` is True
  284:         :param read_concern` (optional) - An instance of
  285:             :class:`~pymongo.read_concern.ReadConcern`.
  286:         :param write_concern: An instance of
  287:             :class:`~pymongo.write_concern.WriteConcern`.
  288:         :param collation` (optional) - An instance of
  289:             :class:`~pymongo.collation.Collation`.
  290:         :param session: a
  291:             :class:`~pymongo.client_session.ClientSession`.
  292:         :param retryable_write: True if this command is a retryable
  293:             write.
  294:         :param user_fields: Response fields that should be decoded
  295:             using the TypeDecoders from codec_options, passed to
  296:             bson._decode_all_selective.
  297: 
  298:         :return: The result document.
  299:         """
  300:         with self.__database.client._tmp_session(session) as s:
  301:             return conn.command(
  302:                 self.__database.name,
  303:                 command,
  304:                 read_preference or self._read_preference_for(session),
  305:                 codec_options or self.codec_options,
  306:                 check,
  307:                 allowable_errors,
  308:                 read_concern=read_concern,
  309:                 write_concern=write_concern,
  310:                 parse_write_concern_error=True,
  311:                 collation=collation,
  312:                 session=s,
  313:                 client=self.__database.client,
  314:                 retryable_write=retryable_write,
  315:                 user_fields=user_fields,
  316:             )
  317: 
  318:     def __create(
  319:         self,
  320:         name: str,
  321:         options: MutableMapping[str, Any],
  322:         collation: Optional[_CollationIn],
  323:         session: Optional[ClientSession],
  324:         encrypted_fields: Optional[Mapping[str, Any]] = None,
  325:         qev2_required: bool = False,
  326:     ) -> None:
  327:         """Sends a create command with the given options."""
  328:         cmd: dict[str, Any] = {"create": name}
  329:         if encrypted_fields:
  330:             cmd["encryptedFields"] = encrypted_fields
  331: 
  332:         if options:
  333:             if "size" in options:
  334:                 options["size"] = float(options["size"])
  335:             cmd.update(options)
  336:         with self._conn_for_writes(session, operation=_Op.CREATE) as conn:
  337:             if qev2_required and conn.max_wire_version < 21:
  338:                 raise ConfigurationError(
  339:                     "Driver support of Queryable Encryption is incompatible with server. "
  340:                     "Upgrade server to use Queryable Encryption. "
  341:                     f"Got maxWireVersion {conn.max_wire_version} but need maxWireVersion >= 21 (MongoDB >=7.0)"
  342:                 )
  343: 
  344:             self._command(
  345:                 conn,
  346:                 cmd,
  347:                 read_preference=ReadPreference.PRIMARY,
  348:                 write_concern=self._write_concern_for(session),
  349:                 collation=collation,
  350:                 session=session,
  351:             )
  352: 
  353:     def __getattr__(self, name: str) -> Collection[_DocumentType]:
  354:         """Get a sub-collection of this collection by name.
  355: 
  356:         Raises InvalidName if an invalid collection name is used.
  357: 
  358:         :param name: the name of the collection to get
  359:         """
  360:         if name.startswith("_"):
  361:             full_name = f"{self.__name}.{name}"
  362:             raise AttributeError(
  363:                 f"Collection has no attribute {name!r}. To access the {full_name}"
  364:                 f" collection, use database['{full_name}']."
  365:             )
  366:         return self.__getitem__(name)
  367: 
  368:     def __getitem__(self, name: str) -> Collection[_DocumentType]:
  369:         return Collection(
  370:             self.__database,
  371:             f"{self.__name}.{name}",
  372:             False,
  373:             self.codec_options,
  374:             self.read_preference,
  375:             self.write_concern,
  376:             self.read_concern,
  377:         )
  378: 
  379:     def __repr__(self) -> str:
  380:         return f"Collection({self.__database!r}, {self.__name!r})"
  381: 
  382:     def __eq__(self, other: Any) -> bool:
  383:         if isinstance(other, Collection):
  384:             return self.__database == other.database and self.__name == other.name
  385:         return NotImplemented
  386: 
  387:     def __ne__(self, other: Any) -> bool:
  388:         return not self == other
  389: 
  390:     def __hash__(self) -> int:
  391:         return hash((self.__database, self.__name))
  392: 
  393:     def __bool__(self) -> NoReturn:
  394:         raise NotImplementedError(
  395:             "Collection objects do not implement truth "
  396:             "value testing or bool(). Please compare "
  397:             "with None instead: collection is not None"
  398:         )
  399: 
  400:     @property
  401:     def full_name(self) -> str:
  402:         """The full name of this :class:`Collection`.
  403: 
  404:         The full name is of the form `database_name.collection_name`.
  405:         """
  406:         return self.__full_name
  407: 
  408:     @property
  409:     def name(self) -> str:
  410:         """The name of this :class:`Collection`."""
  411:         return self.__name
  412: 
  413:     @property
  414:     def database(self) -> Database[_DocumentType]:
  415:         """The :class:`~pymongo.database.Database` that this
  416:         :class:`Collection` is a part of.
  417:         """
  418:         return self.__database
  419: 
  420:     def with_options(
  421:         self,
  422:         codec_options: Optional[CodecOptions[_DocumentTypeArg]] = None,
  423:         read_preference: Optional[_ServerMode] = None,
  424:         write_concern: Optional[WriteConcern] = None,
  425:         read_concern: Optional[ReadConcern] = None,
  426:     ) -> Collection[_DocumentType]:
  427:         """Get a clone of this collection changing the specified settings.
  428: 
  429:           >>> coll1.read_preference
  430:           Primary()
  431:           >>> from pymongo import ReadPreference
  432:           >>> coll2 = coll1.with_options(read_preference=ReadPreference.SECONDARY)
  433:           >>> coll1.read_preference
  434:           Primary()
  435:           >>> coll2.read_preference
  436:           Secondary(tag_sets=None)
  437: 
  438:         :param codec_options: An instance of
  439:             :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
  440:             default) the :attr:`codec_options` of this :class:`Collection`
  441:             is used.
  442:         :param read_preference: The read preference to use. If
  443:             ``None`` (the default) the :attr:`read_preference` of this
  444:             :class:`Collection` is used. See :mod:`~pymongo.read_preferences`
  445:             for options.
  446:         :param write_concern: An instance of
  447:             :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
  448:             default) the :attr:`write_concern` of this :class:`Collection`
  449:             is used.
  450:         :param read_concern: An instance of
  451:             :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
  452:             default) the :attr:`read_concern` of this :class:`Collection`
  453:             is used.
  454:         """
  455:         return Collection(
  456:             self.__database,
  457:             self.__name,
  458:             False,
  459:             codec_options or self.codec_options,
  460:             read_preference or self.read_preference,
  461:             write_concern or self.write_concern,
  462:             read_concern or self.read_concern,
  463:         )
  464: 
  465:     @_csot.apply
  466:     def bulk_write(
  467:         self,
  468:         requests: Sequence[_WriteOp[_DocumentType]],
  469:         ordered: bool = True,
  470:         bypass_document_validation: bool = False,
  471:         session: Optional[ClientSession] = None,
  472:         comment: Optional[Any] = None,
  473:         let: Optional[Mapping] = None,
  474:     ) -> BulkWriteResult:
  475:         """Send a batch of write operations to the server.
  476: 
  477:         Requests are passed as a list of write operation instances (
  478:         :class:`~pymongo.operations.InsertOne`,
  479:         :class:`~pymongo.operations.UpdateOne`,
  480:         :class:`~pymongo.operations.UpdateMany`,
  481:         :class:`~pymongo.operations.ReplaceOne`,
  482:         :class:`~pymongo.operations.DeleteOne`, or
  483:         :class:`~pymongo.operations.DeleteMany`).
  484: 
  485:           >>> for doc in db.test.find({}):
  486:           ...     print(doc)
  487:           ...
  488:           {'x': 1, '_id': ObjectId('54f62e60fba5226811f634ef')}
  489:           {'x': 1, '_id': ObjectId('54f62e60fba5226811f634f0')}
  490:           >>> # DeleteMany, UpdateOne, and UpdateMany are also available.
  491:           ...
  492:           >>> from pymongo import InsertOne, DeleteOne, ReplaceOne
  493:           >>> requests = [InsertOne({'y': 1}), DeleteOne({'x': 1}),
  494:           ...             ReplaceOne({'w': 1}, {'z': 1}, upsert=True)]
  495:           >>> result = db.test.bulk_write(requests)
  496:           >>> result.inserted_count
  497:           1
  498:           >>> result.deleted_count
  499:           1
  500:           >>> result.modified_count
  501:           0
  502:           >>> result.upserted_ids
  503:           {2: ObjectId('54f62ee28891e756a6e1abd5')}
  504:           >>> for doc in db.test.find({}):
  505:           ...     print(doc)
  506:           ...
  507:           {'x': 1, '_id': ObjectId('54f62e60fba5226811f634f0')}
  508:           {'y': 1, '_id': ObjectId('54f62ee2fba5226811f634f1')}
  509:           {'z': 1, '_id': ObjectId('54f62ee28891e756a6e1abd5')}
  510: 
  511:         :param requests: A list of write operations (see examples above).
  512:         :param ordered: If ``True`` (the default) requests will be
  513:             performed on the server serially, in the order provided. If an error
  514:             occurs all remaining operations are aborted. If ``False`` requests
  515:             will be performed on the server in arbitrary order, possibly in
  516:             parallel, and all operations will be attempted.
  517:         :param bypass_document_validation: (optional) If ``True``, allows the
  518:             write to opt-out of document level validation. Default is
  519:             ``False``.
  520:         :param session: a
  521:             :class:`~pymongo.client_session.ClientSession`.
  522:         :param comment: A user-provided comment to attach to this
  523:             command.
  524:         :param let: Map of parameter names and values. Values must be
  525:             constant or closed expressions that do not reference document
  526:             fields. Parameters can then be accessed as variables in an
  527:             aggregate expression context (e.g. "$$var").
  528: 
  529:         :return: An instance of :class:`~pymongo.results.BulkWriteResult`.
  530: 
  531:         .. seealso:: :ref:`writes-and-ids`
  532: 
  533:         .. note:: `bypass_document_validation` requires server version
  534:           **>= 3.2**
  535: 
  536:         .. versionchanged:: 4.1
  537:            Added ``comment`` parameter.
  538:            Added ``let`` parameter.
  539: 
  540:         .. versionchanged:: 3.6
  541:            Added ``session`` parameter.
  542: 
  543:         .. versionchanged:: 3.2
  544:           Added bypass_document_validation support
  545: 
  546:         .. versionadded:: 3.0
  547:         """
  548:         common.validate_list("requests", requests)
  549: 
  550:         blk = _Bulk(self, ordered, bypass_document_validation, comment=comment, let=let)
  551:         for request in requests:
  552:             try:
  553:                 request._add_to_bulk(blk)
  554:             except AttributeError:
  555:                 raise TypeError(f"{request!r} is not a valid request") from None
  556: 
  557:         write_concern = self._write_concern_for(session)
  558:         bulk_api_result = blk.execute(write_concern, session, _Op.INSERT)
  559:         if bulk_api_result is not None:
  560:             return BulkWriteResult(bulk_api_result, True)
  561:         return BulkWriteResult({}, False)
  562: 
  563:     def _insert_one(
  564:         self,
  565:         doc: Mapping[str, Any],
  566:         ordered: bool,
  567:         write_concern: WriteConcern,
  568:         op_id: Optional[int],
  569:         bypass_doc_val: bool,
  570:         session: Optional[ClientSession],
  571:         comment: Optional[Any] = None,
  572:     ) -> Any:
  573:         """Internal helper for inserting a single document."""
  574:         write_concern = write_concern or self.write_concern
  575:         acknowledged = write_concern.acknowledged
  576:         command = {"insert": self.name, "ordered": ordered, "documents": [doc]}
  577:         if comment is not None:
  578:             command["comment"] = comment
  579: 
  580:         def _insert_command(
  581:             session: Optional[ClientSession], conn: Connection, retryable_write: bool
  582:         ) -> None:
  583:             if bypass_doc_val:
  584:                 command["bypassDocumentValidation"] = True
  585: 
  586:             result = conn.command(
  587:                 self.__database.name,
  588:                 command,
  589:                 write_concern=write_concern,
  590:                 codec_options=self.__write_response_codec_options,
  591:                 session=session,
  592:                 client=self.__database.client,
  593:                 retryable_write=retryable_write,
  594:             )
  595: 
  596:             _check_write_command_response(result)
  597: 
  598:         self.__database.client._retryable_write(
  599:             acknowledged, _insert_command, session, operation=_Op.INSERT
  600:         )
  601: 
  602:         if not isinstance(doc, RawBSONDocument):
  603:             return doc.get("_id")
  604:         return None
  605: 
  606:     def insert_one(
  607:         self,
  608:         document: Union[_DocumentType, RawBSONDocument],
  609:         bypass_document_validation: bool = False,
  610:         session: Optional[ClientSession] = None,
  611:         comment: Optional[Any] = None,
  612:     ) -> InsertOneResult:
  613:         """Insert a single document.
  614: 
  615:           >>> db.test.count_documents({'x': 1})
  616:           0
  617:           >>> result = db.test.insert_one({'x': 1})
  618:           >>> result.inserted_id
  619:           ObjectId('54f112defba522406c9cc208')
  620:           >>> db.test.find_one({'x': 1})
  621:           {'x': 1, '_id': ObjectId('54f112defba522406c9cc208')}
  622: 
  623:         :param document: The document to insert. Must be a mutable mapping
  624:             type. If the document does not have an _id field one will be
  625:             added automatically.
  626:         :param bypass_document_validation: (optional) If ``True``, allows the
  627:             write to opt-out of document level validation. Default is
  628:             ``False``.
  629:         :param session: a
  630:             :class:`~pymongo.client_session.ClientSession`.
  631:         :param comment: A user-provided comment to attach to this
  632:             command.
  633: 
  634:         :return: - An instance of :class:`~pymongo.results.InsertOneResult`.
  635: 
  636:         .. seealso:: :ref:`writes-and-ids`
  637: 
  638:         .. note:: `bypass_document_validation` requires server version
  639:           **>= 3.2**
  640: 
  641:         .. versionchanged:: 4.1
  642:            Added ``comment`` parameter.
  643: 
  644:         .. versionchanged:: 3.6
  645:            Added ``session`` parameter.
  646: 
  647:         .. versionchanged:: 3.2
  648:           Added bypass_document_validation support
  649: 
  650:         .. versionadded:: 3.0
  651:         """
  652:         common.validate_is_document_type("document", document)
  653:         if not (isinstance(document, RawBSONDocument) or "_id" in document):
  654:             document["_id"] = ObjectId()  # type: ignore[index]
  655: 
  656:         write_concern = self._write_concern_for(session)
  657:         return InsertOneResult(
  658:             self._insert_one(
  659:                 document,
  660:                 ordered=True,
  661:                 write_concern=write_concern,
  662:                 op_id=None,
  663:                 bypass_doc_val=bypass_document_validation,
  664:                 session=session,
  665:                 comment=comment,
  666:             ),
  667:             write_concern.acknowledged,
  668:         )
  669: 
  670:     @_csot.apply
  671:     def insert_many(
  672:         self,
  673:         documents: Iterable[Union[_DocumentType, RawBSONDocument]],
  674:         ordered: bool = True,
  675:         bypass_document_validation: bool = False,
  676:         session: Optional[ClientSession] = None,
  677:         comment: Optional[Any] = None,
  678:     ) -> InsertManyResult:
  679:         """Insert an iterable of documents.
  680: 
  681:           >>> db.test.count_documents({})
  682:           0
  683:           >>> result = db.test.insert_many([{'x': i} for i in range(2)])
  684:           >>> result.inserted_ids
  685:           [ObjectId('54f113fffba522406c9cc20e'), ObjectId('54f113fffba522406c9cc20f')]
  686:           >>> db.test.count_documents({})
  687:           2
  688: 
  689:         :param documents: A iterable of documents to insert.
  690:         :param ordered: If ``True`` (the default) documents will be
  691:             inserted on the server serially, in the order provided. If an error
  692:             occurs all remaining inserts are aborted. If ``False``, documents
  693:             will be inserted on the server in arbitrary order, possibly in
  694:             parallel, and all document inserts will be attempted.
  695:         :param bypass_document_validation: (optional) If ``True``, allows the
  696:             write to opt-out of document level validation. Default is
  697:             ``False``.
  698:         :param session: a
  699:             :class:`~pymongo.client_session.ClientSession`.
  700:         :param comment: A user-provided comment to attach to this
  701:             command.
  702: 
  703:         :return: An instance of :class:`~pymongo.results.InsertManyResult`.
  704: 
  705:         .. seealso:: :ref:`writes-and-ids`
  706: 
  707:         .. note:: `bypass_document_validation` requires server version
  708:           **>= 3.2**
  709: 
  710:         .. versionchanged:: 4.1
  711:            Added ``comment`` parameter.
  712: 
  713:         .. versionchanged:: 3.6
  714:            Added ``session`` parameter.
  715: 
  716:         .. versionchanged:: 3.2
  717:           Added bypass_document_validation support
  718: 
  719:         .. versionadded:: 3.0
  720:         """
  721:         if (
  722:             not isinstance(documents, abc.Iterable)
  723:             or isinstance(documents, abc.Mapping)
  724:             or not documents
  725:         ):
  726:             raise TypeError("documents must be a non-empty list")
  727:         inserted_ids: list[ObjectId] = []
  728: 
  729:         def gen() -> Iterator[tuple[int, Mapping[str, Any]]]:
  730:             """A generator that validates documents and handles _ids."""
  731:             for document in documents:
  732:                 common.validate_is_document_type("document", document)
  733:                 if not isinstance(document, RawBSONDocument):
  734:                     if "_id" not in document:
  735:                         document["_id"] = ObjectId()  # type: ignore[index]
  736:                     inserted_ids.append(document["_id"])
  737:                 yield (message._INSERT, document)
  738: 
  739:         write_concern = self._write_concern_for(session)
  740:         blk = _Bulk(self, ordered, bypass_document_validation, comment=comment)
  741:         blk.ops = list(gen())
  742:         blk.execute(write_concern, session, _Op.INSERT)
  743:         return InsertManyResult(inserted_ids, write_concern.acknowledged)
  744: 
  745:     def _update(
  746:         self,
  747:         conn: Connection,
  748:         criteria: Mapping[str, Any],
  749:         document: Union[Mapping[str, Any], _Pipeline],
  750:         upsert: bool = False,
  751:         multi: bool = False,
  752:         write_concern: Optional[WriteConcern] = None,
  753:         op_id: Optional[int] = None,
  754:         ordered: bool = True,
  755:         bypass_doc_val: Optional[bool] = False,
  756:         collation: Optional[_CollationIn] = None,
  757:         array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
  758:         hint: Optional[_IndexKeyHint] = None,
  759:         session: Optional[ClientSession] = None,
  760:         retryable_write: bool = False,
  761:         let: Optional[Mapping[str, Any]] = None,
  762:         comment: Optional[Any] = None,
  763:     ) -> Optional[Mapping[str, Any]]:
  764:         """Internal update / replace helper."""
  765:         validate_boolean("upsert", upsert)
  766:         collation = validate_collation_or_none(collation)
  767:         write_concern = write_concern or self.write_concern
  768:         acknowledged = write_concern.acknowledged
  769:         update_doc: dict[str, Any] = {
  770:             "q": criteria,
  771:             "u": document,
  772:             "multi": multi,
  773:             "upsert": upsert,
  774:         }
  775:         if collation is not None:
  776:             if not acknowledged:
  777:                 raise ConfigurationError("Collation is unsupported for unacknowledged writes.")
  778:             else:
  779:                 update_doc["collation"] = collation
  780:         if array_filters is not None:
  781:             if not acknowledged:
  782:                 raise ConfigurationError("arrayFilters is unsupported for unacknowledged writes.")
  783:             else:
  784:                 update_doc["arrayFilters"] = array_filters
  785:         if hint is not None:
  786:             if not acknowledged and conn.max_wire_version < 8:
  787:                 raise ConfigurationError(
  788:                     "Must be connected to MongoDB 4.2+ to use hint on unacknowledged update commands."
  789:                 )
  790:             if not isinstance(hint, str):
  791:                 hint = helpers._index_document(hint)
  792:             update_doc["hint"] = hint
  793:         command = {"update": self.name, "ordered": ordered, "updates": [update_doc]}
  794:         if let is not None:
  795:             common.validate_is_mapping("let", let)
  796:             command["let"] = let
  797: 
  798:         if comment is not None:
  799:             command["comment"] = comment
  800:         # Update command.
  801:         if bypass_doc_val:
  802:             command["bypassDocumentValidation"] = True
  803: 
  804:         # The command result has to be published for APM unmodified
  805:         # so we make a shallow copy here before adding updatedExisting.
  806:         result = conn.command(
  807:             self.__database.name,
  808:             command,
  809:             write_concern=write_concern,
  810:             codec_options=self.__write_response_codec_options,
  811:             session=session,
  812:             client=self.__database.client,
  813:             retryable_write=retryable_write,
  814:         ).copy()
  815:         _check_write_command_response(result)
  816:         # Add the updatedExisting field for compatibility.
  817:         if result.get("n") and "upserted" not in result:
  818:             result["updatedExisting"] = True
  819:         else:
  820:             result["updatedExisting"] = False
  821:             # MongoDB >= 2.6.0 returns the upsert _id in an array
  822:             # element. Break it out for backward compatibility.
  823:             if "upserted" in result:
  824:                 result["upserted"] = result["upserted"][0]["_id"]
  825: 
  826:         if not acknowledged:
  827:             return None
  828:         return result
  829: 
  830:     def _update_retryable(
  831:         self,
  832:         criteria: Mapping[str, Any],
  833:         document: Union[Mapping[str, Any], _Pipeline],
  834:         operation: str,
  835:         upsert: bool = False,
  836:         multi: bool = False,
  837:         write_concern: Optional[WriteConcern] = None,
  838:         op_id: Optional[int] = None,
  839:         ordered: bool = True,
  840:         bypass_doc_val: Optional[bool] = False,
  841:         collation: Optional[_CollationIn] = None,
  842:         array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
  843:         hint: Optional[_IndexKeyHint] = None,
  844:         session: Optional[ClientSession] = None,
  845:         let: Optional[Mapping[str, Any]] = None,
  846:         comment: Optional[Any] = None,
  847:     ) -> Optional[Mapping[str, Any]]:
  848:         """Internal update / replace helper."""
  849: 
  850:         def _update(
  851:             session: Optional[ClientSession], conn: Connection, retryable_write: bool
  852:         ) -> Optional[Mapping[str, Any]]:
  853:             return self._update(
  854:                 conn,
  855:                 criteria,
  856:                 document,
  857:                 upsert=upsert,
  858:                 multi=multi,
  859:                 write_concern=write_concern,
  860:                 op_id=op_id,
  861:                 ordered=ordered,
  862:                 bypass_doc_val=bypass_doc_val,
  863:                 collation=collation,
  864:                 array_filters=array_filters,
  865:                 hint=hint,
  866:                 session=session,
  867:                 retryable_write=retryable_write,
  868:                 let=let,
  869:                 comment=comment,
  870:             )
  871: 
  872:         return self.__database.client._retryable_write(
  873:             (write_concern or self.write_concern).acknowledged and not multi,
  874:             _update,
  875:             session,
  876:             operation,
  877:         )
  878: 
  879:     def replace_one(
  880:         self,
  881:         filter: Mapping[str, Any],
  882:         replacement: Mapping[str, Any],
  883:         upsert: bool = False,
  884:         bypass_document_validation: bool = False,
  885:         collation: Optional[_CollationIn] = None,
  886:         hint: Optional[_IndexKeyHint] = None,
  887:         session: Optional[ClientSession] = None,
  888:         let: Optional[Mapping[str, Any]] = None,
  889:         comment: Optional[Any] = None,
  890:     ) -> UpdateResult:
  891:         """Replace a single document matching the filter.
  892: 
  893:           >>> for doc in db.test.find({}):
  894:           ...     print(doc)
  895:           ...
  896:           {'x': 1, '_id': ObjectId('54f4c5befba5220aa4d6dee7')}
  897:           >>> result = db.test.replace_one({'x': 1}, {'y': 1})
  898:           >>> result.matched_count
  899:           1
  900:           >>> result.modified_count
  901:           1
  902:           >>> for doc in db.test.find({}):
  903:           ...     print(doc)
  904:           ...
  905:           {'y': 1, '_id': ObjectId('54f4c5befba5220aa4d6dee7')}
  906: 
  907:         The *upsert* option can be used to insert a new document if a matching
  908:         document does not exist.
  909: 
  910:           >>> result = db.test.replace_one({'x': 1}, {'x': 1}, True)
  911:           >>> result.matched_count
  912:           0
  913:           >>> result.modified_count
  914:           0
  915:           >>> result.upserted_id
  916:           ObjectId('54f11e5c8891e756a6e1abd4')
  917:           >>> db.test.find_one({'x': 1})
  918:           {'x': 1, '_id': ObjectId('54f11e5c8891e756a6e1abd4')}
  919: 
  920:         :param filter: A query that matches the document to replace.
  921:         :param replacement: The new document.
  922:         :param upsert: If ``True``, perform an insert if no documents
  923:             match the filter.
  924:         :param bypass_document_validation: (optional) If ``True``, allows the
  925:             write to opt-out of document level validation. Default is
  926:             ``False``.
  927:         :param collation: An instance of
  928:             :class:`~pymongo.collation.Collation`.
  929:         :param hint: An index to use to support the query
  930:             predicate specified either by its string name, or in the same
  931:             format as passed to
  932:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
  933:             ``[('field', ASCENDING)]``). This option is only supported on
  934:             MongoDB 4.2 and above.
  935:         :param session: a
  936:             :class:`~pymongo.client_session.ClientSession`.
  937:         :param let: Map of parameter names and values. Values must be
  938:             constant or closed expressions that do not reference document
  939:             fields. Parameters can then be accessed as variables in an
  940:             aggregate expression context (e.g. "$$var").
  941:         :param comment: A user-provided comment to attach to this
  942:             command.
  943:         :return: - An instance of :class:`~pymongo.results.UpdateResult`.
  944: 
  945:         .. versionchanged:: 4.1
  946:            Added ``let`` parameter.
  947:            Added ``comment`` parameter.
  948:         .. versionchanged:: 3.11
  949:            Added ``hint`` parameter.
  950:         .. versionchanged:: 3.6
  951:            Added ``session`` parameter.
  952:         .. versionchanged:: 3.4
  953:           Added the `collation` option.
  954:         .. versionchanged:: 3.2
  955:           Added bypass_document_validation support.
  956: 
  957:         .. versionadded:: 3.0
  958:         """
  959:         common.validate_is_mapping("filter", filter)
  960:         common.validate_ok_for_replace(replacement)
  961:         if let is not None:
  962:             common.validate_is_mapping("let", let)
  963:         write_concern = self._write_concern_for(session)
  964:         return UpdateResult(
  965:             self._update_retryable(
  966:                 filter,
  967:                 replacement,
  968:                 _Op.UPDATE,
  969:                 upsert,
  970:                 write_concern=write_concern,
  971:                 bypass_doc_val=bypass_document_validation,
  972:                 collation=collation,
  973:                 hint=hint,
  974:                 session=session,
  975:                 let=let,
  976:                 comment=comment,
  977:             ),
  978:             write_concern.acknowledged,
  979:         )
  980: 
  981:     def update_one(
  982:         self,
  983:         filter: Mapping[str, Any],
  984:         update: Union[Mapping[str, Any], _Pipeline],
  985:         upsert: bool = False,
  986:         bypass_document_validation: bool = False,
  987:         collation: Optional[_CollationIn] = None,
  988:         array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
  989:         hint: Optional[_IndexKeyHint] = None,
  990:         session: Optional[ClientSession] = None,
  991:         let: Optional[Mapping[str, Any]] = None,
  992:         comment: Optional[Any] = None,
  993:     ) -> UpdateResult:
  994:         """Update a single document matching the filter.
  995: 
  996:           >>> for doc in db.test.find():
  997:           ...     print(doc)
  998:           ...
  999:           {'x': 1, '_id': 0}
 1000:           {'x': 1, '_id': 1}
 1001:           {'x': 1, '_id': 2}
 1002:           >>> result = db.test.update_one({'x': 1}, {'$inc': {'x': 3}})
 1003:           >>> result.matched_count
 1004:           1
 1005:           >>> result.modified_count
 1006:           1
 1007:           >>> for doc in db.test.find():
 1008:           ...     print(doc)
 1009:           ...
 1010:           {'x': 4, '_id': 0}
 1011:           {'x': 1, '_id': 1}
 1012:           {'x': 1, '_id': 2}
 1013: 
 1014:         If ``upsert=True`` and no documents match the filter, create a
 1015:         new document based on the filter criteria and update modifications.
 1016: 
 1017:           >>> result = db.test.update_one({'x': -10}, {'$inc': {'x': 3}}, upsert=True)
 1018:           >>> result.matched_count
 1019:           0
 1020:           >>> result.modified_count
 1021:           0
 1022:           >>> result.upserted_id
 1023:           ObjectId('626a678eeaa80587d4bb3fb7')
 1024:           >>> db.test.find_one(result.upserted_id)
 1025:           {'_id': ObjectId('626a678eeaa80587d4bb3fb7'), 'x': -7}
 1026: 
 1027:         :param filter: A query that matches the document to update.
 1028:         :param update: The modifications to apply.
 1029:         :param upsert: If ``True``, perform an insert if no documents
 1030:             match the filter.
 1031:         :param bypass_document_validation: (optional) If ``True``, allows the
 1032:             write to opt-out of document level validation. Default is
 1033:             ``False``.
 1034:         :param collation: An instance of
 1035:             :class:`~pymongo.collation.Collation`.
 1036:         :param array_filters: A list of filters specifying which
 1037:             array elements an update should apply.
 1038:         :param hint: An index to use to support the query
 1039:             predicate specified either by its string name, or in the same
 1040:             format as passed to
 1041:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
 1042:             ``[('field', ASCENDING)]``). This option is only supported on
 1043:             MongoDB 4.2 and above.
 1044:         :param session: a
 1045:             :class:`~pymongo.client_session.ClientSession`.
 1046:         :param let: Map of parameter names and values. Values must be
 1047:             constant or closed expressions that do not reference document
 1048:             fields. Parameters can then be accessed as variables in an
 1049:             aggregate expression context (e.g. "$$var").
 1050:         :param comment: A user-provided comment to attach to this
 1051:             command.
 1052: 
 1053:         :return: - An instance of :class:`~pymongo.results.UpdateResult`.
 1054: 
 1055:         .. versionchanged:: 4.1
 1056:            Added ``let`` parameter.
 1057:            Added ``comment`` parameter.
 1058:         .. versionchanged:: 3.11
 1059:            Added ``hint`` parameter.
 1060:         .. versionchanged:: 3.9
 1061:            Added the ability to accept a pipeline as the ``update``.
 1062:         .. versionchanged:: 3.6
 1063:            Added the ``array_filters`` and ``session`` parameters.
 1064:         .. versionchanged:: 3.4
 1065:           Added the ``collation`` option.
 1066:         .. versionchanged:: 3.2
 1067:           Added ``bypass_document_validation`` support.
 1068: 
 1069:         .. versionadded:: 3.0
 1070:         """
 1071:         common.validate_is_mapping("filter", filter)
 1072:         common.validate_ok_for_update(update)
 1073:         common.validate_list_or_none("array_filters", array_filters)
 1074: 
 1075:         write_concern = self._write_concern_for(session)
 1076:         return UpdateResult(
 1077:             self._update_retryable(
 1078:                 filter,
 1079:                 update,
 1080:                 _Op.UPDATE,
 1081:                 upsert,
 1082:                 write_concern=write_concern,
 1083:                 bypass_doc_val=bypass_document_validation,
 1084:                 collation=collation,
 1085:                 array_filters=array_filters,
 1086:                 hint=hint,
 1087:                 session=session,
 1088:                 let=let,
 1089:                 comment=comment,
 1090:             ),
 1091:             write_concern.acknowledged,
 1092:         )
 1093: 
 1094:     def update_many(
 1095:         self,
 1096:         filter: Mapping[str, Any],
 1097:         update: Union[Mapping[str, Any], _Pipeline],
 1098:         upsert: bool = False,
 1099:         array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
 1100:         bypass_document_validation: Optional[bool] = None,
 1101:         collation: Optional[_CollationIn] = None,
 1102:         hint: Optional[_IndexKeyHint] = None,
 1103:         session: Optional[ClientSession] = None,
 1104:         let: Optional[Mapping[str, Any]] = None,
 1105:         comment: Optional[Any] = None,
 1106:     ) -> UpdateResult:
 1107:         """Update one or more documents that match the filter.
 1108: 
 1109:           >>> for doc in db.test.find():
 1110:           ...     print(doc)
 1111:           ...
 1112:           {'x': 1, '_id': 0}
 1113:           {'x': 1, '_id': 1}
 1114:           {'x': 1, '_id': 2}
 1115:           >>> result = db.test.update_many({'x': 1}, {'$inc': {'x': 3}})
 1116:           >>> result.matched_count
 1117:           3
 1118:           >>> result.modified_count
 1119:           3
 1120:           >>> for doc in db.test.find():
 1121:           ...     print(doc)
 1122:           ...
 1123:           {'x': 4, '_id': 0}
 1124:           {'x': 4, '_id': 1}
 1125:           {'x': 4, '_id': 2}
 1126: 
 1127:         :param filter: A query that matches the documents to update.
 1128:         :param update: The modifications to apply.
 1129:         :param upsert: If ``True``, perform an insert if no documents
 1130:             match the filter.
 1131:         :param bypass_document_validation: If ``True``, allows the
 1132:             write to opt-out of document level validation. Default is
 1133:             ``False``.
 1134:         :param collation: An instance of
 1135:             :class:`~pymongo.collation.Collation`.
 1136:         :param array_filters: A list of filters specifying which
 1137:             array elements an update should apply.
 1138:         :param hint: An index to use to support the query
 1139:             predicate specified either by its string name, or in the same
 1140:             format as passed to
 1141:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
 1142:             ``[('field', ASCENDING)]``). This option is only supported on
 1143:             MongoDB 4.2 and above.
 1144:         :param session: a
 1145:             :class:`~pymongo.client_session.ClientSession`.
 1146:         :param let: Map of parameter names and values. Values must be
 1147:             constant or closed expressions that do not reference document
 1148:             fields. Parameters can then be accessed as variables in an
 1149:             aggregate expression context (e.g. "$$var").
 1150:         :param comment: A user-provided comment to attach to this
 1151:             command.
 1152: 
 1153:         :return: - An instance of :class:`~pymongo.results.UpdateResult`.
 1154: 
 1155:         .. versionchanged:: 4.1
 1156:            Added ``let`` parameter.
 1157:            Added ``comment`` parameter.
 1158:         .. versionchanged:: 3.11
 1159:            Added ``hint`` parameter.
 1160:         .. versionchanged:: 3.9
 1161:            Added the ability to accept a pipeline as the `update`.
 1162:         .. versionchanged:: 3.6
 1163:            Added ``array_filters`` and ``session`` parameters.
 1164:         .. versionchanged:: 3.4
 1165:           Added the `collation` option.
 1166:         .. versionchanged:: 3.2
 1167:           Added bypass_document_validation support.
 1168: 
 1169:         .. versionadded:: 3.0
 1170:         """
 1171:         common.validate_is_mapping("filter", filter)
 1172:         common.validate_ok_for_update(update)
 1173:         common.validate_list_or_none("array_filters", array_filters)
 1174: 
 1175:         write_concern = self._write_concern_for(session)
 1176:         return UpdateResult(
 1177:             self._update_retryable(
 1178:                 filter,
 1179:                 update,
 1180:                 _Op.UPDATE,
 1181:                 upsert,
 1182:                 multi=True,
 1183:                 write_concern=write_concern,
 1184:                 bypass_doc_val=bypass_document_validation,
 1185:                 collation=collation,
 1186:                 array_filters=array_filters,
 1187:                 hint=hint,
 1188:                 session=session,
 1189:                 let=let,
 1190:                 comment=comment,
 1191:             ),
 1192:             write_concern.acknowledged,
 1193:         )
 1194: 
 1195:     def drop(
 1196:         self,
 1197:         session: Optional[ClientSession] = None,
 1198:         comment: Optional[Any] = None,
 1199:         encrypted_fields: Optional[Mapping[str, Any]] = None,
 1200:     ) -> None:
 1201:         """Alias for :meth:`~pymongo.database.Database.drop_collection`.
 1202: 
 1203:         :param session: a
 1204:             :class:`~pymongo.client_session.ClientSession`.
 1205:         :param comment: A user-provided comment to attach to this
 1206:             command.
 1207:         :param encrypted_fields: **(BETA)** Document that describes the encrypted fields for
 1208:             Queryable Encryption.
 1209: 
 1210:         The following two calls are equivalent:
 1211: 
 1212:           >>> db.foo.drop()
 1213:           >>> db.drop_collection("foo")
 1214: 
 1215:         .. versionchanged:: 4.2
 1216:            Added ``encrypted_fields`` parameter.
 1217: 
 1218:         .. versionchanged:: 4.1
 1219:            Added ``comment`` parameter.
 1220: 
 1221:         .. versionchanged:: 3.7
 1222:            :meth:`drop` now respects this :class:`Collection`'s :attr:`write_concern`.
 1223: 
 1224:         .. versionchanged:: 3.6
 1225:            Added ``session`` parameter.
 1226:         """
 1227:         dbo = self.__database.client.get_database(
 1228:             self.__database.name,
 1229:             self.codec_options,
 1230:             self.read_preference,
 1231:             self.write_concern,
 1232:             self.read_concern,
 1233:         )
 1234:         dbo.drop_collection(
 1235:             self.__name, session=session, comment=comment, encrypted_fields=encrypted_fields
 1236:         )
 1237: 
 1238:     def _delete(
 1239:         self,
 1240:         conn: Connection,
 1241:         criteria: Mapping[str, Any],
 1242:         multi: bool,
 1243:         write_concern: Optional[WriteConcern] = None,
 1244:         op_id: Optional[int] = None,
 1245:         ordered: bool = True,
 1246:         collation: Optional[_CollationIn] = None,
 1247:         hint: Optional[_IndexKeyHint] = None,
 1248:         session: Optional[ClientSession] = None,
 1249:         retryable_write: bool = False,
 1250:         let: Optional[Mapping[str, Any]] = None,
 1251:         comment: Optional[Any] = None,
 1252:     ) -> Mapping[str, Any]:
 1253:         """Internal delete helper."""
 1254:         common.validate_is_mapping("filter", criteria)
 1255:         write_concern = write_concern or self.write_concern
 1256:         acknowledged = write_concern.acknowledged
 1257:         delete_doc = {"q": criteria, "limit": int(not multi)}
 1258:         collation = validate_collation_or_none(collation)
 1259:         if collation is not None:
 1260:             if not acknowledged:
 1261:                 raise ConfigurationError("Collation is unsupported for unacknowledged writes.")
 1262:             else:
 1263:                 delete_doc["collation"] = collation
 1264:         if hint is not None:
 1265:             if not acknowledged and conn.max_wire_version < 9:
 1266:                 raise ConfigurationError(
 1267:                     "Must be connected to MongoDB 4.4+ to use hint on unacknowledged delete commands."
 1268:                 )
 1269:             if not isinstance(hint, str):
 1270:                 hint = helpers._index_document(hint)
 1271:             delete_doc["hint"] = hint
 1272:         command = {"delete": self.name, "ordered": ordered, "deletes": [delete_doc]}
 1273: 
 1274:         if let is not None:
 1275:             common.validate_is_document_type("let", let)
 1276:             command["let"] = let
 1277: 
 1278:         if comment is not None:
 1279:             command["comment"] = comment
 1280: 
 1281:         # Delete command.
 1282:         result = conn.command(
 1283:             self.__database.name,
 1284:             command,
 1285:             write_concern=write_concern,
 1286:             codec_options=self.__write_response_codec_options,
 1287:             session=session,
 1288:             client=self.__database.client,
 1289:             retryable_write=retryable_write,
 1290:         )
 1291:         _check_write_command_response(result)
 1292:         return result
 1293: 
 1294:     def _delete_retryable(
 1295:         self,
 1296:         criteria: Mapping[str, Any],
 1297:         multi: bool,
 1298:         write_concern: Optional[WriteConcern] = None,
 1299:         op_id: Optional[int] = None,
 1300:         ordered: bool = True,
 1301:         collation: Optional[_CollationIn] = None,
 1302:         hint: Optional[_IndexKeyHint] = None,
 1303:         session: Optional[ClientSession] = None,
 1304:         let: Optional[Mapping[str, Any]] = None,
 1305:         comment: Optional[Any] = None,
 1306:     ) -> Mapping[str, Any]:
 1307:         """Internal delete helper."""
 1308: 
 1309:         def _delete(
 1310:             session: Optional[ClientSession], conn: Connection, retryable_write: bool
 1311:         ) -> Mapping[str, Any]:
 1312:             return self._delete(
 1313:                 conn,
 1314:                 criteria,
 1315:                 multi,
 1316:                 write_concern=write_concern,
 1317:                 op_id=op_id,
 1318:                 ordered=ordered,
 1319:                 collation=collation,
 1320:                 hint=hint,
 1321:                 session=session,
 1322:                 retryable_write=retryable_write,
 1323:                 let=let,
 1324:                 comment=comment,
 1325:             )
 1326: 
 1327:         return self.__database.client._retryable_write(
 1328:             (write_concern or self.write_concern).acknowledged and not multi,
 1329:             _delete,
 1330:             session,
 1331:             operation=_Op.DELETE,
 1332:         )
 1333: 
 1334:     def delete_one(
 1335:         self,
 1336:         filter: Mapping[str, Any],
 1337:         collation: Optional[_CollationIn] = None,
 1338:         hint: Optional[_IndexKeyHint] = None,
 1339:         session: Optional[ClientSession] = None,
 1340:         let: Optional[Mapping[str, Any]] = None,
 1341:         comment: Optional[Any] = None,
 1342:     ) -> DeleteResult:
 1343:         """Delete a single document matching the filter.
 1344: 
 1345:           >>> db.test.count_documents({'x': 1})
 1346:           3
 1347:           >>> result = db.test.delete_one({'x': 1})
 1348:           >>> result.deleted_count
 1349:           1
 1350:           >>> db.test.count_documents({'x': 1})
 1351:           2
 1352: 
 1353:         :param filter: A query that matches the document to delete.
 1354:         :param collation: An instance of
 1355:             :class:`~pymongo.collation.Collation`.
 1356:         :param hint: An index to use to support the query
 1357:             predicate specified either by its string name, or in the same
 1358:             format as passed to
 1359:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
 1360:             ``[('field', ASCENDING)]``). This option is only supported on
 1361:             MongoDB 4.4 and above.
 1362:         :param session: a
 1363:             :class:`~pymongo.client_session.ClientSession`.
 1364:         :param let: Map of parameter names and values. Values must be
 1365:             constant or closed expressions that do not reference document
 1366:             fields. Parameters can then be accessed as variables in an
 1367:             aggregate expression context (e.g. "$$var").
 1368:         :param comment: A user-provided comment to attach to this
 1369:             command.
 1370: 
 1371:         :return: - An instance of :class:`~pymongo.results.DeleteResult`.
 1372: 
 1373:         .. versionchanged:: 4.1
 1374:            Added ``let`` parameter.
 1375:            Added ``comment`` parameter.
 1376:         .. versionchanged:: 3.11
 1377:            Added ``hint`` parameter.
 1378:         .. versionchanged:: 3.6
 1379:            Added ``session`` parameter.
 1380:         .. versionchanged:: 3.4
 1381:           Added the `collation` option.
 1382:         .. versionadded:: 3.0
 1383:         """
 1384:         write_concern = self._write_concern_for(session)
 1385:         return DeleteResult(
 1386:             self._delete_retryable(
 1387:                 filter,
 1388:                 False,
 1389:                 write_concern=write_concern,
 1390:                 collation=collation,
 1391:                 hint=hint,
 1392:                 session=session,
 1393:                 let=let,
 1394:                 comment=comment,
 1395:             ),
 1396:             write_concern.acknowledged,
 1397:         )
 1398: 
 1399:     def delete_many(
 1400:         self,
 1401:         filter: Mapping[str, Any],
 1402:         collation: Optional[_CollationIn] = None,
 1403:         hint: Optional[_IndexKeyHint] = None,
 1404:         session: Optional[ClientSession] = None,
 1405:         let: Optional[Mapping[str, Any]] = None,
 1406:         comment: Optional[Any] = None,
 1407:     ) -> DeleteResult:
 1408:         """Delete one or more documents matching the filter.
 1409: 
 1410:           >>> db.test.count_documents({'x': 1})
 1411:           3
 1412:           >>> result = db.test.delete_many({'x': 1})
 1413:           >>> result.deleted_count
 1414:           3
 1415:           >>> db.test.count_documents({'x': 1})
 1416:           0
 1417: 
 1418:         :param filter: A query that matches the documents to delete.
 1419:         :param collation: An instance of
 1420:             :class:`~pymongo.collation.Collation`.
 1421:         :param hint: An index to use to support the query
 1422:             predicate specified either by its string name, or in the same
 1423:             format as passed to
 1424:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
 1425:             ``[('field', ASCENDING)]``). This option is only supported on
 1426:             MongoDB 4.4 and above.
 1427:         :param session: a
 1428:             :class:`~pymongo.client_session.ClientSession`.
 1429:         :param let: Map of parameter names and values. Values must be
 1430:             constant or closed expressions that do not reference document
 1431:             fields. Parameters can then be accessed as variables in an
 1432:             aggregate expression context (e.g. "$$var").
 1433:         :param comment: A user-provided comment to attach to this
 1434:             command.
 1435: 
 1436:         :return: - An instance of :class:`~pymongo.results.DeleteResult`.
 1437: 
 1438:         .. versionchanged:: 4.1
 1439:            Added ``let`` parameter.
 1440:            Added ``comment`` parameter.
 1441:         .. versionchanged:: 3.11
 1442:            Added ``hint`` parameter.
 1443:         .. versionchanged:: 3.6
 1444:            Added ``session`` parameter.
 1445:         .. versionchanged:: 3.4
 1446:           Added the `collation` option.
 1447:         .. versionadded:: 3.0
 1448:         """
 1449:         write_concern = self._write_concern_for(session)
 1450:         return DeleteResult(
 1451:             self._delete_retryable(
 1452:                 filter,
 1453:                 True,
 1454:                 write_concern=write_concern,
 1455:                 collation=collation,
 1456:                 hint=hint,
 1457:                 session=session,
 1458:                 let=let,
 1459:                 comment=comment,
 1460:             ),
 1461:             write_concern.acknowledged,
 1462:         )
 1463: 
 1464:     def find_one(
 1465:         self, filter: Optional[Any] = None, *args: Any, **kwargs: Any
 1466:     ) -> Optional[_DocumentType]:
 1467:         """Get a single document from the database.
 1468: 
 1469:         All arguments to :meth:`find` are also valid arguments for
 1470:         :meth:`find_one`, although any `limit` argument will be
 1471:         ignored. Returns a single document, or ``None`` if no matching
 1472:         document is found.
 1473: 
 1474:         The :meth:`find_one` method obeys the :attr:`read_preference` of
 1475:         this :class:`Collection`.
 1476: 
 1477:         :param filter: a dictionary specifying
 1478:             the query to be performed OR any other type to be used as
 1479:             the value for a query for ``"_id"``.
 1480: 
 1481:         :param args: any additional positional arguments
 1482:             are the same as the arguments to :meth:`find`.
 1483: 
 1484:         :param kwargs: any additional keyword arguments
 1485:             are the same as the arguments to :meth:`find`.
 1486: 
 1487:             :: code-block: python
 1488: 
 1489:               >>> collection.find_one(max_time_ms=100)
 1490: 
 1491:         """
 1492:         if filter is not None and not isinstance(filter, abc.Mapping):
 1493:             filter = {"_id": filter}
 1494:         cursor = self.find(filter, *args, **kwargs)
 1495:         for result in cursor.limit(-1):
 1496:             return result
 1497:         return None
 1498: 
 1499:     def find(self, *args: Any, **kwargs: Any) -> Cursor[_DocumentType]:
 1500:         """Query the database.
 1501: 
 1502:         The `filter` argument is a query document that all results
 1503:         must match. For example:
 1504: 
 1505:         >>> db.test.find({"hello": "world"})
 1506: 
 1507:         only matches documents that have a key "hello" with value
 1508:         "world".  Matches can have other keys *in addition* to
 1509:         "hello". The `projection` argument is used to specify a subset
 1510:         of fields that should be included in the result documents. By
 1511:         limiting results to a certain subset of fields you can cut
 1512:         down on network traffic and decoding time.
 1513: 
 1514:         Raises :class:`TypeError` if any of the arguments are of
 1515:         improper type. Returns an instance of
 1516:         :class:`~pymongo.cursor.Cursor` corresponding to this query.
 1517: 
 1518:         The :meth:`find` method obeys the :attr:`read_preference` of
 1519:         this :class:`Collection`.
 1520: 
 1521:         :param filter: A query document that selects which documents
 1522:             to include in the result set. Can be an empty document to include
 1523:             all documents.
 1524:         :param projection: a list of field names that should be
 1525:             returned in the result set or a dict specifying the fields
 1526:             to include or exclude. If `projection` is a list "_id" will
 1527:             always be returned. Use a dict to exclude fields from
 1528:             the result (e.g. projection={'_id': False}).
 1529:         :param session: a
 1530:             :class:`~pymongo.client_session.ClientSession`.
 1531:         :param skip: the number of documents to omit (from
 1532:             the start of the result set) when returning the results
 1533:         :param limit: the maximum number of results to
 1534:             return. A limit of 0 (the default) is equivalent to setting no
 1535:             limit.
 1536:         :param no_cursor_timeout: if False (the default), any
 1537:             returned cursor is closed by the server after 10 minutes of
 1538:             inactivity. If set to True, the returned cursor will never
 1539:             time out on the server. Care should be taken to ensure that
 1540:             cursors with no_cursor_timeout turned on are properly closed.
 1541:         :param cursor_type: the type of cursor to return. The valid
 1542:             options are defined by :class:`~pymongo.cursor.CursorType`:
 1543: 
 1544:             - :attr:`~pymongo.cursor.CursorType.NON_TAILABLE` - the result of
 1545:               this find call will return a standard cursor over the result set.
 1546:             - :attr:`~pymongo.cursor.CursorType.TAILABLE` - the result of this
 1547:               find call will be a tailable cursor - tailable cursors are only
 1548:               for use with capped collections. They are not closed when the
 1549:               last data is retrieved but are kept open and the cursor location
 1550:               marks the final document position. If more data is received
 1551:               iteration of the cursor will continue from the last document
 1552:               received. For details, see the `tailable cursor documentation
 1553:               <https://www.mongodb.com/docs/manual/core/tailable-cursors/>`_.
 1554:             - :attr:`~pymongo.cursor.CursorType.TAILABLE_AWAIT` - the result
 1555:               of this find call will be a tailable cursor with the await flag
 1556:               set. The server will wait for a few seconds after returning the
 1557:               full result set so that it can capture and return additional data
 1558:               added during the query.
 1559:             - :attr:`~pymongo.cursor.CursorType.EXHAUST` - the result of this
 1560:               find call will be an exhaust cursor. MongoDB will stream batched
 1561:               results to the client without waiting for the client to request
 1562:               each batch, reducing latency. See notes on compatibility below.
 1563: 
 1564:         :param sort: a list of (key, direction) pairs
 1565:             specifying the sort order for this query. See
 1566:             :meth:`~pymongo.cursor.Cursor.sort` for details.
 1567:         :param allow_partial_results: if True, mongos will return
 1568:             partial results if some shards are down instead of returning an
 1569:             error.
 1570:         :param oplog_replay: **DEPRECATED** - if True, set the
 1571:             oplogReplay query flag. Default: False.
 1572:         :param batch_size: Limits the number of documents returned in
 1573:             a single batch.
 1574:         :param collation: An instance of
 1575:             :class:`~pymongo.collation.Collation`.
 1576:         :param return_key: If True, return only the index keys in
 1577:             each document.
 1578:         :param show_record_id: If True, adds a field ``$recordId`` in
 1579:             each document with the storage engine's internal record identifier.
 1580:         :param snapshot: **DEPRECATED** - If True, prevents the
 1581:             cursor from returning a document more than once because of an
 1582:             intervening write operation.
 1583:         :param hint: An index, in the same format as passed to
 1584:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
 1585:             ``[('field', ASCENDING)]``). Pass this as an alternative to calling
 1586:             :meth:`~pymongo.cursor.Cursor.hint` on the cursor to tell Mongo the
 1587:             proper index to use for the query.
 1588:         :param max_time_ms: Specifies a time limit for a query
 1589:             operation. If the specified time is exceeded, the operation will be
 1590:             aborted and :exc:`~pymongo.errors.ExecutionTimeout` is raised. Pass
 1591:             this as an alternative to calling
 1592:             :meth:`~pymongo.cursor.Cursor.max_time_ms` on the cursor.
 1593:         :param max_scan: **DEPRECATED** - The maximum number of
 1594:             documents to scan. Pass this as an alternative to calling
 1595:             :meth:`~pymongo.cursor.Cursor.max_scan` on the cursor.
 1596:         :param min: A list of field, limit pairs specifying the
 1597:             inclusive lower bound for all keys of a specific index in order.
 1598:             Pass this as an alternative to calling
 1599:             :meth:`~pymongo.cursor.Cursor.min` on the cursor. ``hint`` must
 1600:             also be passed to ensure the query utilizes the correct index.
 1601:         :param max: A list of field, limit pairs specifying the
 1602:             exclusive upper bound for all keys of a specific index in order.
 1603:             Pass this as an alternative to calling
 1604:             :meth:`~pymongo.cursor.Cursor.max` on the cursor. ``hint`` must
 1605:             also be passed to ensure the query utilizes the correct index.
 1606:         :param comment: A string to attach to the query to help
 1607:             interpret and trace the operation in the server logs and in profile
 1608:             data. Pass this as an alternative to calling
 1609:             :meth:`~pymongo.cursor.Cursor.comment` on the cursor.
 1610:         :param allow_disk_use: if True, MongoDB may use temporary
 1611:             disk files to store data exceeding the system memory limit while
 1612:             processing a blocking sort operation. The option has no effect if
 1613:             MongoDB can satisfy the specified sort using an index, or if the
 1614:             blocking sort requires less memory than the 100 MiB limit. This
 1615:             option is only supported on MongoDB 4.4 and above.
 1616: 
 1617:         .. note:: There are a number of caveats to using
 1618:           :attr:`~pymongo.cursor.CursorType.EXHAUST` as cursor_type:
 1619: 
 1620:           - The `limit` option can not be used with an exhaust cursor.
 1621: 
 1622:           - Exhaust cursors are not supported by mongos and can not be
 1623:             used with a sharded cluster.
 1624: 
 1625:           - A :class:`~pymongo.cursor.Cursor` instance created with the
 1626:             :attr:`~pymongo.cursor.CursorType.EXHAUST` cursor_type requires an
 1627:             exclusive :class:`~socket.socket` connection to MongoDB. If the
 1628:             :class:`~pymongo.cursor.Cursor` is discarded without being
 1629:             completely iterated the underlying :class:`~socket.socket`
 1630:             connection will be closed and discarded without being returned to
 1631:             the connection pool.
 1632: 
 1633:         .. versionchanged:: 4.0
 1634:            Removed the ``modifiers`` option.
 1635:            Empty projections (eg {} or []) are passed to the server as-is,
 1636:            rather than the previous behavior which substituted in a
 1637:            projection of ``{"_id": 1}``. This means that an empty projection
 1638:            will now return the entire document, not just the ``"_id"`` field.
 1639: 
 1640:         .. versionchanged:: 3.11
 1641:            Added the ``allow_disk_use`` option.
 1642:            Deprecated the ``oplog_replay`` option. Support for this option is
 1643:            deprecated in MongoDB 4.4. The query engine now automatically
 1644:            optimizes queries against the oplog without requiring this
 1645:            option to be set.
 1646: 
 1647:         .. versionchanged:: 3.7
 1648:            Deprecated the ``snapshot`` option, which is deprecated in MongoDB
 1649:            3.6 and removed in MongoDB 4.0.
 1650:            Deprecated the ``max_scan`` option. Support for this option is
 1651:            deprecated in MongoDB 4.0. Use ``max_time_ms`` instead to limit
 1652:            server-side execution time.
 1653: 
 1654:         .. versionchanged:: 3.6
 1655:            Added ``session`` parameter.
 1656: 
 1657:         .. versionchanged:: 3.5
 1658:            Added the options ``return_key``, ``show_record_id``, ``snapshot``,
 1659:            ``hint``, ``max_time_ms``, ``max_scan``, ``min``, ``max``, and
 1660:            ``comment``.
 1661:            Deprecated the ``modifiers`` option.
 1662: 
 1663:         .. versionchanged:: 3.4
 1664:            Added support for the ``collation`` option.
 1665: 
 1666:         .. versionchanged:: 3.0
 1667:            Changed the parameter names ``spec``, ``fields``, ``timeout``, and
 1668:            ``partial`` to ``filter``, ``projection``, ``no_cursor_timeout``,
 1669:            and ``allow_partial_results`` respectively.
 1670:            Added the ``cursor_type``, ``oplog_replay``, and ``modifiers``
 1671:            options.
 1672:            Removed the ``network_timeout``, ``read_preference``, ``tag_sets``,
 1673:            ``secondary_acceptable_latency_ms``, ``max_scan``, ``snapshot``,
 1674:            ``tailable``, ``await_data``, ``exhaust``, ``as_class``, and
 1675:            slave_okay parameters.
 1676:            Removed ``compile_re`` option: PyMongo now always
 1677:            represents BSON regular expressions as :class:`~bson.regex.Regex`
 1678:            objects. Use :meth:`~bson.regex.Regex.try_compile` to attempt to
 1679:            convert from a BSON regular expression to a Python regular
 1680:            expression object.
 1681:            Soft deprecated the ``manipulate`` option.
 1682: 
 1683:         .. seealso:: The MongoDB documentation on `find <https://dochub.mongodb.org/core/find>`_.
 1684:         """
 1685:         return Cursor(self, *args, **kwargs)
 1686: 
 1687:     def find_raw_batches(self, *args: Any, **kwargs: Any) -> RawBatchCursor[_DocumentType]:
 1688:         """Query the database and retrieve batches of raw BSON.
 1689: 
 1690:         Similar to the :meth:`find` method but returns a
 1691:         :class:`~pymongo.cursor.RawBatchCursor`.
 1692: 
 1693:         This example demonstrates how to work with raw batches, but in practice
 1694:         raw batches should be passed to an external library that can decode
 1695:         BSON into another data type, rather than used with PyMongo's
 1696:         :mod:`bson` module.
 1697: 
 1698:           >>> import bson
 1699:           >>> cursor = db.test.find_raw_batches()
 1700:           >>> for batch in cursor:
 1701:           ...     print(bson.decode_all(batch))
 1702: 
 1703:         .. note:: find_raw_batches does not support auto encryption.
 1704: 
 1705:         .. versionchanged:: 3.12
 1706:            Instead of ignoring the user-specified read concern, this method
 1707:            now sends it to the server when connected to MongoDB 3.6+.
 1708: 
 1709:            Added session support.
 1710: 
 1711:         .. versionadded:: 3.6
 1712:         """
 1713:         # OP_MSG is required to support encryption.
 1714:         if self.__database.client._encrypter:
 1715:             raise InvalidOperation("find_raw_batches does not support auto encryption")
 1716:         return RawBatchCursor(self, *args, **kwargs)
 1717: 
 1718:     def _count_cmd(
 1719:         self,
 1720:         session: Optional[ClientSession],
 1721:         conn: Connection,
 1722:         read_preference: Optional[_ServerMode],
 1723:         cmd: dict[str, Any],
 1724:         collation: Optional[Collation],
 1725:     ) -> int:
 1726:         """Internal count command helper."""
 1727:         # XXX: "ns missing" checks can be removed when we drop support for
 1728:         # MongoDB 3.0, see SERVER-17051.
 1729:         res = self._command(
 1730:             conn,
 1731:             cmd,
 1732:             read_preference=read_preference,
 1733:             allowable_errors=["ns missing"],
 1734:             codec_options=self.__write_response_codec_options,
 1735:             read_concern=self.read_concern,
 1736:             collation=collation,
 1737:             session=session,
 1738:         )
 1739:         if res.get("errmsg", "") == "ns missing":
 1740:             return 0
 1741:         return int(res["n"])
 1742: 
 1743:     def _aggregate_one_result(
 1744:         self,
 1745:         conn: Connection,
 1746:         read_preference: Optional[_ServerMode],
 1747:         cmd: dict[str, Any],
 1748:         collation: Optional[_CollationIn],
 1749:         session: Optional[ClientSession],
 1750:     ) -> Optional[Mapping[str, Any]]:
 1751:         """Internal helper to run an aggregate that returns a single result."""
 1752:         result = self._command(
 1753:             conn,
 1754:             cmd,
 1755:             read_preference,
 1756:             allowable_errors=[26],  # Ignore NamespaceNotFound.
 1757:             codec_options=self.__write_response_codec_options,
 1758:             read_concern=self.read_concern,
 1759:             collation=collation,
 1760:             session=session,
 1761:         )
 1762:         # cursor will not be present for NamespaceNotFound errors.
 1763:         if "cursor" not in result:
 1764:             return None
 1765:         batch = result["cursor"]["firstBatch"]
 1766:         return batch[0] if batch else None
 1767: 
 1768:     def estimated_document_count(self, comment: Optional[Any] = None, **kwargs: Any) -> int:
 1769:         """Get an estimate of the number of documents in this collection using
 1770:         collection metadata.
 1771: 
 1772:         The :meth:`estimated_document_count` method is **not** supported in a
 1773:         transaction.
 1774: 
 1775:         All optional parameters should be passed as keyword arguments
 1776:         to this method. Valid options include:
 1777: 
 1778:           - `maxTimeMS` (int): The maximum amount of time to allow this
 1779:             operation to run, in milliseconds.
 1780: 
 1781:         :param comment: A user-provided comment to attach to this
 1782:             command.
 1783:         :param kwargs: See list of options above.
 1784: 
 1785:         .. versionchanged:: 4.2
 1786:            This method now always uses the `count`_ command. Due to an oversight in versions
 1787:            5.0.0-5.0.8 of MongoDB, the count command was not included in V1 of the
 1788:            :ref:`versioned-api-ref`. Users of the Stable API with estimated_document_count are
 1789:            recommended to upgrade their server version to 5.0.9+ or set
 1790:            :attr:`pymongo.server_api.ServerApi.strict` to ``False`` to avoid encountering errors.
 1791: 
 1792:         .. versionadded:: 3.7
 1793:         .. _count: https://mongodb.com/docs/manual/reference/command/count/
 1794:         """
 1795:         if "session" in kwargs:
 1796:             raise ConfigurationError("estimated_document_count does not support sessions")
 1797:         if comment is not None:
 1798:             kwargs["comment"] = comment
 1799: 
 1800:         def _cmd(
 1801:             session: Optional[ClientSession],
 1802:             _server: Server,
 1803:             conn: Connection,
 1804:             read_preference: Optional[_ServerMode],
 1805:         ) -> int:
 1806:             cmd: dict[str, Any] = {"count": self.__name}
 1807:             cmd.update(kwargs)
 1808:             return self._count_cmd(session, conn, read_preference, cmd, collation=None)
 1809: 
 1810:         return self._retryable_non_cursor_read(_cmd, None, operation=_Op.COUNT)
 1811: 
 1812:     def count_documents(
 1813:         self,
 1814:         filter: Mapping[str, Any],
 1815:         session: Optional[ClientSession] = None,
 1816:         comment: Optional[Any] = None,
 1817:         **kwargs: Any,
 1818:     ) -> int:
 1819:         """Count the number of documents in this collection.
 1820: 
 1821:         .. note:: For a fast count of the total documents in a collection see
 1822:            :meth:`estimated_document_count`.
 1823: 
 1824:         The :meth:`count_documents` method is supported in a transaction.
 1825: 
 1826:         All optional parameters should be passed as keyword arguments
 1827:         to this method. Valid options include:
 1828: 
 1829:           - `skip` (int): The number of matching documents to skip before
 1830:             returning results.
 1831:           - `limit` (int): The maximum number of documents to count. Must be
 1832:             a positive integer. If not provided, no limit is imposed.
 1833:           - `maxTimeMS` (int): The maximum amount of time to allow this
 1834:             operation to run, in milliseconds.
 1835:           - `collation` (optional): An instance of
 1836:             :class:`~pymongo.collation.Collation`.
 1837:           - `hint` (string or list of tuples): The index to use. Specify either
 1838:             the index name as a string or the index specification as a list of
 1839:             tuples (e.g. [('a', pymongo.ASCENDING), ('b', pymongo.ASCENDING)]).
 1840: 
 1841:         The :meth:`count_documents` method obeys the :attr:`read_preference` of
 1842:         this :class:`Collection`.
 1843: 
 1844:         .. note:: When migrating from :meth:`count` to :meth:`count_documents`
 1845:            the following query operators must be replaced:
 1846: 
 1847:            +-------------+-------------------------------------+
 1848:            | Operator    | Replacement                         |
 1849:            +=============+=====================================+
 1850:            | $where      | `$expr`_                            |
 1851:            +-------------+-------------------------------------+
 1852:            | $near       | `$geoWithin`_ with `$center`_       |
 1853:            +-------------+-------------------------------------+
 1854:            | $nearSphere | `$geoWithin`_ with `$centerSphere`_ |
 1855:            +-------------+-------------------------------------+
 1856: 
 1857:         :param filter: A query document that selects which documents
 1858:             to count in the collection. Can be an empty document to count all
 1859:             documents.
 1860:         :param session: a
 1861:             :class:`~pymongo.client_session.ClientSession`.
 1862:         :param comment: A user-provided comment to attach to this
 1863:             command.
 1864:         :param kwargs: See list of options above.
 1865: 
 1866: 
 1867:         .. versionadded:: 3.7
 1868: 
 1869:         .. _$expr: https://mongodb.com/docs/manual/reference/operator/query/expr/
 1870:         .. _$geoWithin: https://mongodb.com/docs/manual/reference/operator/query/geoWithin/
 1871:         .. _$center: https://mongodb.com/docs/manual/reference/operator/query/center/
 1872:         .. _$centerSphere: https://mongodb.com/docs/manual/reference/operator/query/centerSphere/
 1873:         """
 1874:         pipeline = [{"$match": filter}]
 1875:         if "skip" in kwargs:
 1876:             pipeline.append({"$skip": kwargs.pop("skip")})
 1877:         if "limit" in kwargs:
 1878:             pipeline.append({"$limit": kwargs.pop("limit")})
 1879:         if comment is not None:
 1880:             kwargs["comment"] = comment
 1881:         pipeline.append({"$group": {"_id": 1, "n": {"$sum": 1}}})
 1882:         cmd = {"aggregate": self.__name, "pipeline": pipeline, "cursor": {}}
 1883:         if "hint" in kwargs and not isinstance(kwargs["hint"], str):
 1884:             kwargs["hint"] = helpers._index_document(kwargs["hint"])
 1885:         collation = validate_collation_or_none(kwargs.pop("collation", None))
 1886:         cmd.update(kwargs)
 1887: 
 1888:         def _cmd(
 1889:             session: Optional[ClientSession],
 1890:             _server: Server,
 1891:             conn: Connection,
 1892:             read_preference: Optional[_ServerMode],
 1893:         ) -> int:
 1894:             result = self._aggregate_one_result(conn, read_preference, cmd, collation, session)
 1895:             if not result:
 1896:                 return 0
 1897:             return result["n"]
 1898: 
 1899:         return self._retryable_non_cursor_read(_cmd, session, _Op.COUNT)
 1900: 
 1901:     def _retryable_non_cursor_read(
 1902:         self,
 1903:         func: Callable[[Optional[ClientSession], Server, Connection, Optional[_ServerMode]], T],
 1904:         session: Optional[ClientSession],
 1905:         operation: str,
 1906:     ) -> T:
 1907:         """Non-cursor read helper to handle implicit session creation."""
 1908:         client = self.__database.client
 1909:         with client._tmp_session(session) as s:
 1910:             return client._retryable_read(func, self._read_preference_for(s), s, operation)
 1911: 
 1912:     def create_indexes(
 1913:         self,
 1914:         indexes: Sequence[IndexModel],
 1915:         session: Optional[ClientSession] = None,
 1916:         comment: Optional[Any] = None,
 1917:         **kwargs: Any,
 1918:     ) -> list[str]:
 1919:         """Create one or more indexes on this collection.
 1920: 
 1921:           >>> from pymongo import IndexModel, ASCENDING, DESCENDING
 1922:           >>> index1 = IndexModel([("hello", DESCENDING),
 1923:           ...                      ("world", ASCENDING)], name="hello_world")
 1924:           >>> index2 = IndexModel([("goodbye", DESCENDING)])
 1925:           >>> db.test.create_indexes([index1, index2])
 1926:           ["hello_world", "goodbye_-1"]
 1927: 
 1928:         :param indexes: A list of :class:`~pymongo.operations.IndexModel`
 1929:             instances.
 1930:         :param session: a
 1931:             :class:`~pymongo.client_session.ClientSession`.
 1932:         :param comment: A user-provided comment to attach to this
 1933:             command.
 1934:         :param kwargs: optional arguments to the createIndexes
 1935:             command (like maxTimeMS) can be passed as keyword arguments.
 1936: 
 1937: 
 1938: 
 1939: 
 1940:         .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
 1941:            this collection is automatically applied to this operation.
 1942: 
 1943:         .. versionchanged:: 3.6
 1944:            Added ``session`` parameter. Added support for arbitrary keyword
 1945:            arguments.
 1946: 
 1947:         .. versionchanged:: 3.4
 1948:            Apply this collection's write concern automatically to this operation
 1949:            when connected to MongoDB >= 3.4.
 1950:         .. versionadded:: 3.0
 1951: 
 1952:         .. _createIndexes: https://mongodb.com/docs/manual/reference/command/createIndexes/
 1953:         """
 1954:         common.validate_list("indexes", indexes)
 1955:         if comment is not None:
 1956:             kwargs["comment"] = comment
 1957:         return self.__create_indexes(indexes, session, **kwargs)
 1958: 
 1959:     @_csot.apply
 1960:     def __create_indexes(
 1961:         self, indexes: Sequence[IndexModel], session: Optional[ClientSession], **kwargs: Any
 1962:     ) -> list[str]:
 1963:         """Internal createIndexes helper.
 1964: 
 1965:         :param indexes: A list of :class:`~pymongo.operations.IndexModel`
 1966:             instances.
 1967:         :param session: a
 1968:             :class:`~pymongo.client_session.ClientSession`.
 1969:         :param kwargs: optional arguments to the createIndexes
 1970:             command (like maxTimeMS) can be passed as keyword arguments.
 1971:         """
 1972:         names = []
 1973:         with self._conn_for_writes(session, operation=_Op.CREATE_INDEXES) as conn:
 1974:             supports_quorum = conn.max_wire_version >= 9
 1975: 
 1976:             def gen_indexes() -> Iterator[Mapping[str, Any]]:
 1977:                 for index in indexes:
 1978:                     if not isinstance(index, IndexModel):
 1979:                         raise TypeError(
 1980:                             f"{index!r} is not an instance of pymongo.operations.IndexModel"
 1981:                         )
 1982:                     document = index.document
 1983:                     names.append(document["name"])
 1984:                     yield document
 1985: 
 1986:             cmd = {"createIndexes": self.name, "indexes": list(gen_indexes())}
 1987:             cmd.update(kwargs)
 1988:             if "commitQuorum" in kwargs and not supports_quorum:
 1989:                 raise ConfigurationError(
 1990:                     "Must be connected to MongoDB 4.4+ to use the "
 1991:                     "commitQuorum option for createIndexes"
 1992:                 )
 1993: 
 1994:             self._command(
 1995:                 conn,
 1996:                 cmd,
 1997:                 read_preference=ReadPreference.PRIMARY,
 1998:                 codec_options=_UNICODE_REPLACE_CODEC_OPTIONS,
 1999:                 write_concern=self._write_concern_for(session),
 2000:                 session=session,
 2001:             )
 2002:         return names
 2003: 
 2004:     def create_index(
 2005:         self,
 2006:         keys: _IndexKeyHint,
 2007:         session: Optional[ClientSession] = None,
 2008:         comment: Optional[Any] = None,
 2009:         **kwargs: Any,
 2010:     ) -> str:
 2011:         """Creates an index on this collection.
 2012: 
 2013:         Takes either a single key or a list containing (key, direction) pairs
 2014:         or keys.  If no direction is given, :data:`~pymongo.ASCENDING` will
 2015:         be assumed.
 2016:         The key(s) must be an instance of :class:`str` and the direction(s) must
 2017:         be one of (:data:`~pymongo.ASCENDING`, :data:`~pymongo.DESCENDING`,
 2018:         :data:`~pymongo.GEO2D`, :data:`~pymongo.GEOSPHERE`,
 2019:         :data:`~pymongo.HASHED`, :data:`~pymongo.TEXT`).
 2020: 
 2021:         To create a single key ascending index on the key ``'mike'`` we just
 2022:         use a string argument::
 2023: 
 2024:           >>> my_collection.create_index("mike")
 2025: 
 2026:         For a compound index on ``'mike'`` descending and ``'eliot'``
 2027:         ascending we need to use a list of tuples::
 2028: 
 2029:           >>> my_collection.create_index([("mike", pymongo.DESCENDING),
 2030:           ...                             "eliot"])
 2031: 
 2032:         All optional index creation parameters should be passed as
 2033:         keyword arguments to this method. For example::
 2034: 
 2035:           >>> my_collection.create_index([("mike", pymongo.DESCENDING)],
 2036:           ...                            background=True)
 2037: 
 2038:         Valid options include, but are not limited to:
 2039: 
 2040:           - `name`: custom name to use for this index - if none is
 2041:             given, a name will be generated.
 2042:           - `unique`: if ``True``, creates a uniqueness constraint on the
 2043:             index.
 2044:           - `background`: if ``True``, this index should be created in the
 2045:             background.
 2046:           - `sparse`: if ``True``, omit from the index any documents that lack
 2047:             the indexed field.
 2048:           - `bucketSize`: for use with geoHaystack indexes.
 2049:             Number of documents to group together within a certain proximity
 2050:             to a given longitude and latitude.
 2051:           - `min`: minimum value for keys in a :data:`~pymongo.GEO2D`
 2052:             index.
 2053:           - `max`: maximum value for keys in a :data:`~pymongo.GEO2D`
 2054:             index.
 2055:           - `expireAfterSeconds`: <int> Used to create an expiring (TTL)
 2056:             collection. MongoDB will automatically delete documents from
 2057:             this collection after <int> seconds. The indexed field must
 2058:             be a UTC datetime or the data will not expire.
 2059:           - `partialFilterExpression`: A document that specifies a filter for
 2060:             a partial index.
 2061:           - `collation` (optional): An instance of
 2062:             :class:`~pymongo.collation.Collation`.
 2063:           - `wildcardProjection`: Allows users to include or exclude specific
 2064:             field paths from a `wildcard index`_ using the {"$**" : 1} key
 2065:             pattern. Requires MongoDB >= 4.2.
 2066:           - `hidden`: if ``True``, this index will be hidden from the query
 2067:             planner and will not be evaluated as part of query plan
 2068:             selection. Requires MongoDB >= 4.4.
 2069: 
 2070:         See the MongoDB documentation for a full list of supported options by
 2071:         server version.
 2072: 
 2073:         .. warning:: `dropDups` is not supported by MongoDB 3.0 or newer. The
 2074:           option is silently ignored by the server and unique index builds
 2075:           using the option will fail if a duplicate value is detected.
 2076: 
 2077:         .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
 2078:            this collection is automatically applied to this operation.
 2079: 
 2080:         :param keys: a single key or a list of (key, direction)
 2081:             pairs specifying the index to create
 2082:         :param session: a
 2083:             :class:`~pymongo.client_session.ClientSession`.
 2084:         :param comment: A user-provided comment to attach to this
 2085:             command.
 2086:         :param kwargs: any additional index creation
 2087:             options (see the above list) should be passed as keyword
 2088:             arguments.
 2089: 
 2090:         .. versionchanged:: 4.4
 2091:            Allow passing a list containing (key, direction) pairs
 2092:            or keys for the ``keys`` parameter.
 2093:         .. versionchanged:: 4.1
 2094:            Added ``comment`` parameter.
 2095:         .. versionchanged:: 3.11
 2096:            Added the ``hidden`` option.
 2097:         .. versionchanged:: 3.6
 2098:            Added ``session`` parameter. Added support for passing maxTimeMS
 2099:            in kwargs.
 2100:         .. versionchanged:: 3.4
 2101:            Apply this collection's write concern automatically to this operation
 2102:            when connected to MongoDB >= 3.4. Support the `collation` option.
 2103:         .. versionchanged:: 3.2
 2104:            Added partialFilterExpression to support partial indexes.
 2105:         .. versionchanged:: 3.0
 2106:            Renamed `key_or_list` to `keys`. Removed the `cache_for` option.
 2107:            :meth:`create_index` no longer caches index names. Removed support
 2108:            for the drop_dups and bucket_size aliases.
 2109: 
 2110:         .. seealso:: The MongoDB documentation on `indexes <https://dochub.mongodb.org/core/indexes>`_.
 2111: 
 2112:         .. _wildcard index: https://dochub.mongodb.org/core/index-wildcard/
 2113:         """
 2114:         cmd_options = {}
 2115:         if "maxTimeMS" in kwargs:
 2116:             cmd_options["maxTimeMS"] = kwargs.pop("maxTimeMS")
 2117:         if comment is not None:
 2118:             cmd_options["comment"] = comment
 2119:         index = IndexModel(keys, **kwargs)
 2120:         return self.__create_indexes([index], session, **cmd_options)[0]
 2121: 
 2122:     def drop_indexes(
 2123:         self,
 2124:         session: Optional[ClientSession] = None,
 2125:         comment: Optional[Any] = None,
 2126:         **kwargs: Any,
 2127:     ) -> None:
 2128:         """Drops all indexes on this collection.
 2129: 
 2130:         Can be used on non-existent collections or collections with no indexes.
 2131:         Raises OperationFailure on an error.
 2132: 
 2133:         :param session: a
 2134:             :class:`~pymongo.client_session.ClientSession`.
 2135:         :param comment: A user-provided comment to attach to this
 2136:             command.
 2137:         :param kwargs: optional arguments to the createIndexes
 2138:             command (like maxTimeMS) can be passed as keyword arguments.
 2139: 
 2140:         .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
 2141:            this collection is automatically applied to this operation.
 2142: 
 2143:         .. versionchanged:: 3.6
 2144:            Added ``session`` parameter. Added support for arbitrary keyword
 2145:            arguments.
 2146: 
 2147:         .. versionchanged:: 3.4
 2148:            Apply this collection's write concern automatically to this operation
 2149:            when connected to MongoDB >= 3.4.
 2150:         """
 2151:         if comment is not None:
 2152:             kwargs["comment"] = comment
 2153:         self.drop_index("*", session=session, **kwargs)
 2154: 
 2155:     @_csot.apply
 2156:     def drop_index(
 2157:         self,
 2158:         index_or_name: _IndexKeyHint,
 2159:         session: Optional[ClientSession] = None,
 2160:         comment: Optional[Any] = None,
 2161:         **kwargs: Any,
 2162:     ) -> None:
 2163:         """Drops the specified index on this collection.
 2164: 
 2165:         Can be used on non-existent collections or collections with no
 2166:         indexes.  Raises OperationFailure on an error (e.g. trying to
 2167:         drop an index that does not exist). `index_or_name`
 2168:         can be either an index name (as returned by `create_index`),
 2169:         or an index specifier (as passed to `create_index`). An index
 2170:         specifier should be a list of (key, direction) pairs. Raises
 2171:         TypeError if index is not an instance of (str, unicode, list).
 2172: 
 2173:         .. warning::
 2174: 
 2175:           if a custom name was used on index creation (by
 2176:           passing the `name` parameter to :meth:`create_index`) the index
 2177:           **must** be dropped by name.
 2178: 
 2179:         :param index_or_name: index (or name of index) to drop
 2180:         :param session: a
 2181:             :class:`~pymongo.client_session.ClientSession`.
 2182:         :param comment: A user-provided comment to attach to this
 2183:             command.
 2184:         :param kwargs: optional arguments to the createIndexes
 2185:             command (like maxTimeMS) can be passed as keyword arguments.
 2186: 
 2187: 
 2188: 
 2189:         .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
 2190:            this collection is automatically applied to this operation.
 2191: 
 2192: 
 2193:         .. versionchanged:: 3.6
 2194:            Added ``session`` parameter. Added support for arbitrary keyword
 2195:            arguments.
 2196: 
 2197:         .. versionchanged:: 3.4
 2198:            Apply this collection's write concern automatically to this operation
 2199:            when connected to MongoDB >= 3.4.
 2200: 
 2201:         """
 2202:         name = index_or_name
 2203:         if isinstance(index_or_name, list):
 2204:             name = helpers._gen_index_name(index_or_name)
 2205: 
 2206:         if not isinstance(name, str):
 2207:             raise TypeError("index_or_name must be an instance of str or list")
 2208: 
 2209:         cmd = {"dropIndexes": self.__name, "index": name}
 2210:         cmd.update(kwargs)
 2211:         if comment is not None:
 2212:             cmd["comment"] = comment
 2213:         with self._conn_for_writes(session, operation=_Op.DROP_INDEXES) as conn:
 2214:             self._command(
 2215:                 conn,
 2216:                 cmd,
 2217:                 read_preference=ReadPreference.PRIMARY,
 2218:                 allowable_errors=["ns not found", 26],
 2219:                 write_concern=self._write_concern_for(session),
 2220:                 session=session,
 2221:             )
 2222: 
 2223:     def list_indexes(
 2224:         self,
 2225:         session: Optional[ClientSession] = None,
 2226:         comment: Optional[Any] = None,
 2227:     ) -> CommandCursor[MutableMapping[str, Any]]:
 2228:         """Get a cursor over the index documents for this collection.
 2229: 
 2230:           >>> for index in db.test.list_indexes():
 2231:           ...     print(index)
 2232:           ...
 2233:           SON([('v', 2), ('key', SON([('_id', 1)])), ('name', '_id_')])
 2234: 
 2235:         :param session: a
 2236:             :class:`~pymongo.client_session.ClientSession`.
 2237:         :param comment: A user-provided comment to attach to this
 2238:             command.
 2239: 
 2240:         :return: An instance of :class:`~pymongo.command_cursor.CommandCursor`.
 2241: 
 2242:         .. versionchanged:: 4.1
 2243:            Added ``comment`` parameter.
 2244: 
 2245:         .. versionchanged:: 3.6
 2246:            Added ``session`` parameter.
 2247: 
 2248:         .. versionadded:: 3.0
 2249:         """
 2250:         codec_options: CodecOptions = CodecOptions(SON)
 2251:         coll = cast(
 2252:             Collection[MutableMapping[str, Any]],
 2253:             self.with_options(codec_options=codec_options, read_preference=ReadPreference.PRIMARY),
 2254:         )
 2255:         read_pref = (session and session._txn_read_preference()) or ReadPreference.PRIMARY
 2256:         explicit_session = session is not None
 2257: 
 2258:         def _cmd(
 2259:             session: Optional[ClientSession],
 2260:             _server: Server,
 2261:             conn: Connection,
 2262:             read_preference: _ServerMode,
 2263:         ) -> CommandCursor[MutableMapping[str, Any]]:
 2264:             cmd = {"listIndexes": self.__name, "cursor": {}}
 2265:             if comment is not None:
 2266:                 cmd["comment"] = comment
 2267: 
 2268:             try:
 2269:                 cursor = self._command(conn, cmd, read_preference, codec_options, session=session)[
 2270:                     "cursor"
 2271:                 ]
 2272:             except OperationFailure as exc:
 2273:                 # Ignore NamespaceNotFound errors to match the behavior
 2274:                 # of reading from *.system.indexes.
 2275:                 if exc.code != 26:
 2276:                     raise
 2277:                 cursor = {"id": 0, "firstBatch": []}
 2278:             cmd_cursor = CommandCursor(
 2279:                 coll,
 2280:                 cursor,
 2281:                 conn.address,
 2282:                 session=session,
 2283:                 explicit_session=explicit_session,
 2284:                 comment=cmd.get("comment"),
 2285:             )
 2286:             cmd_cursor._maybe_pin_connection(conn)
 2287:             return cmd_cursor
 2288: 
 2289:         with self.__database.client._tmp_session(session, False) as s:
 2290:             return self.__database.client._retryable_read(
 2291:                 _cmd, read_pref, s, operation=_Op.LIST_INDEXES
 2292:             )
 2293: 
 2294:     def index_information(
 2295:         self,
 2296:         session: Optional[ClientSession] = None,
 2297:         comment: Optional[Any] = None,
 2298:     ) -> MutableMapping[str, Any]:
 2299:         """Get information on this collection's indexes.
 2300: 
 2301:         Returns a dictionary where the keys are index names (as
 2302:         returned by create_index()) and the values are dictionaries
 2303:         containing information about each index. The dictionary is
 2304:         guaranteed to contain at least a single key, ``"key"`` which
 2305:         is a list of (key, direction) pairs specifying the index (as
 2306:         passed to create_index()). It will also contain any other
 2307:         metadata about the indexes, except for the ``"ns"`` and
 2308:         ``"name"`` keys, which are cleaned. Example output might look
 2309:         like this:
 2310: 
 2311:         >>> db.test.create_index("x", unique=True)
 2312:         'x_1'
 2313:         >>> db.test.index_information()
 2314:         {'_id_': {'key': [('_id', 1)]},
 2315:          'x_1': {'unique': True, 'key': [('x', 1)]}}
 2316: 
 2317:         :param session: a
 2318:             :class:`~pymongo.client_session.ClientSession`.
 2319:         :param comment: A user-provided comment to attach to this
 2320:             command.
 2321: 
 2322:         .. versionchanged:: 4.1
 2323:            Added ``comment`` parameter.
 2324: 
 2325:         .. versionchanged:: 3.6
 2326:            Added ``session`` parameter.
 2327:         """
 2328:         cursor = self.list_indexes(session=session, comment=comment)
 2329:         info = {}
 2330:         for index in cursor:
 2331:             index["key"] = list(index["key"].items())
 2332:             index = dict(index)  # noqa: PLW2901
 2333:             info[index.pop("name")] = index
 2334:         return info
 2335: 
 2336:     def list_search_indexes(
 2337:         self,
 2338:         name: Optional[str] = None,
 2339:         session: Optional[ClientSession] = None,
 2340:         comment: Optional[Any] = None,
 2341:         **kwargs: Any,
 2342:     ) -> CommandCursor[Mapping[str, Any]]:
 2343:         """Return a cursor over search indexes for the current collection.
 2344: 
 2345:         :param name: If given, the name of the index to search
 2346:             for.  Only indexes with matching index names will be returned.
 2347:             If not given, all search indexes for the current collection
 2348:             will be returned.
 2349:         :param session: a :class:`~pymongo.client_session.ClientSession`.
 2350:         :param comment: A user-provided comment to attach to this
 2351:             command.
 2352: 
 2353:         :return: A :class:`~pymongo.command_cursor.CommandCursor` over the result
 2354:           set.
 2355: 
 2356:         .. note:: requires a MongoDB server version 7.0+ Atlas cluster.
 2357: 
 2358:         .. versionadded:: 4.5
 2359:         """
 2360:         if name is None:
 2361:             pipeline: _Pipeline = [{"$listSearchIndexes": {}}]
 2362:         else:
 2363:             pipeline = [{"$listSearchIndexes": {"name": name}}]
 2364: 
 2365:         coll = self.with_options(
 2366:             codec_options=DEFAULT_CODEC_OPTIONS,
 2367:             read_preference=ReadPreference.PRIMARY,
 2368:             write_concern=DEFAULT_WRITE_CONCERN,
 2369:             read_concern=DEFAULT_READ_CONCERN,
 2370:         )
 2371:         cmd = _CollectionAggregationCommand(
 2372:             coll,
 2373:             CommandCursor,
 2374:             pipeline,
 2375:             kwargs,
 2376:             explicit_session=session is not None,
 2377:             comment=comment,
 2378:             user_fields={"cursor": {"firstBatch": 1}},
 2379:         )
 2380: 
 2381:         return self.__database.client._retryable_read(
 2382:             cmd.get_cursor,
 2383:             cmd.get_read_preference(session),  # type: ignore[arg-type]
 2384:             session,
 2385:             retryable=not cmd._performs_write,
 2386:             operation=_Op.LIST_SEARCH_INDEX,
 2387:         )
 2388: 
 2389:     def create_search_index(
 2390:         self,
 2391:         model: Union[Mapping[str, Any], SearchIndexModel],
 2392:         session: Optional[ClientSession] = None,
 2393:         comment: Any = None,
 2394:         **kwargs: Any,
 2395:     ) -> str:
 2396:         """Create a single search index for the current collection.
 2397: 
 2398:         :param model: The model for the new search index.
 2399:             It can be given as a :class:`~pymongo.operations.SearchIndexModel`
 2400:             instance or a dictionary with a model "definition"  and optional
 2401:             "name".
 2402:         :param session: a
 2403:             :class:`~pymongo.client_session.ClientSession`.
 2404:         :param comment: A user-provided comment to attach to this
 2405:             command.
 2406:         :param kwargs: optional arguments to the createSearchIndexes
 2407:             command (like maxTimeMS) can be passed as keyword arguments.
 2408: 
 2409:         :return: The name of the new search index.
 2410: 
 2411:         .. note:: requires a MongoDB server version 7.0+ Atlas cluster.
 2412: 
 2413:         .. versionadded:: 4.5
 2414:         """
 2415:         if not isinstance(model, SearchIndexModel):
 2416:             model = SearchIndexModel(**model)
 2417:         return self.create_search_indexes([model], session, comment, **kwargs)[0]
 2418: 
 2419:     def create_search_indexes(
 2420:         self,
 2421:         models: list[SearchIndexModel],
 2422:         session: Optional[ClientSession] = None,
 2423:         comment: Optional[Any] = None,
 2424:         **kwargs: Any,
 2425:     ) -> list[str]:
 2426:         """Create multiple search indexes for the current collection.
 2427: 
 2428:         :param models: A list of :class:`~pymongo.operations.SearchIndexModel` instances.
 2429:         :param session: a :class:`~pymongo.client_session.ClientSession`.
 2430:         :param comment: A user-provided comment to attach to this
 2431:             command.
 2432:         :param kwargs: optional arguments to the createSearchIndexes
 2433:             command (like maxTimeMS) can be passed as keyword arguments.
 2434: 
 2435:         :return: A list of the newly created search index names.
 2436: 
 2437:         .. note:: requires a MongoDB server version 7.0+ Atlas cluster.
 2438: 
 2439:         .. versionadded:: 4.5
 2440:         """
 2441:         if comment is not None:
 2442:             kwargs["comment"] = comment
 2443: 
 2444:         def gen_indexes() -> Iterator[Mapping[str, Any]]:
 2445:             for index in models:
 2446:                 if not isinstance(index, SearchIndexModel):
 2447:                     raise TypeError(
 2448:                         f"{index!r} is not an instance of pymongo.operations.SearchIndexModel"
 2449:                     )
 2450:                 yield index.document
 2451: 
 2452:         cmd = {"createSearchIndexes": self.name, "indexes": list(gen_indexes())}
 2453:         cmd.update(kwargs)
 2454: 
 2455:         with self._conn_for_writes(session, operation=_Op.CREATE_SEARCH_INDEXES) as conn:
 2456:             resp = self._command(
 2457:                 conn,
 2458:                 cmd,
 2459:                 read_preference=ReadPreference.PRIMARY,
 2460:                 codec_options=_UNICODE_REPLACE_CODEC_OPTIONS,
 2461:             )
 2462:             return [index["name"] for index in resp["indexesCreated"]]
 2463: 
 2464:     def drop_search_index(
 2465:         self,
 2466:         name: str,
 2467:         session: Optional[ClientSession] = None,
 2468:         comment: Optional[Any] = None,
 2469:         **kwargs: Any,
 2470:     ) -> None:
 2471:         """Delete a search index by index name.
 2472: 
 2473:         :param name: The name of the search index to be deleted.
 2474:         :param session: a
 2475:             :class:`~pymongo.client_session.ClientSession`.
 2476:         :param comment: A user-provided comment to attach to this
 2477:             command.
 2478:         :param kwargs: optional arguments to the dropSearchIndexes
 2479:             command (like maxTimeMS) can be passed as keyword arguments.
 2480: 
 2481:         .. note:: requires a MongoDB server version 7.0+ Atlas cluster.
 2482: 
 2483:         .. versionadded:: 4.5
 2484:         """
 2485:         cmd = {"dropSearchIndex": self.__name, "name": name}
 2486:         cmd.update(kwargs)
 2487:         if comment is not None:
 2488:             cmd["comment"] = comment
 2489:         with self._conn_for_writes(session, operation=_Op.DROP_SEARCH_INDEXES) as conn:
 2490:             self._command(
 2491:                 conn,
 2492:                 cmd,
 2493:                 read_preference=ReadPreference.PRIMARY,
 2494:                 allowable_errors=["ns not found", 26],
 2495:                 codec_options=_UNICODE_REPLACE_CODEC_OPTIONS,
 2496:             )
 2497: 
 2498:     def update_search_index(
 2499:         self,
 2500:         name: str,
 2501:         definition: Mapping[str, Any],
 2502:         session: Optional[ClientSession] = None,
 2503:         comment: Optional[Any] = None,
 2504:         **kwargs: Any,
 2505:     ) -> None:
 2506:         """Update a search index by replacing the existing index definition with the provided definition.
 2507: 
 2508:         :param name: The name of the search index to be updated.
 2509:         :param definition: The new search index definition.
 2510:         :param session: a
 2511:             :class:`~pymongo.client_session.ClientSession`.
 2512:         :param comment: A user-provided comment to attach to this
 2513:             command.
 2514:         :param kwargs: optional arguments to the updateSearchIndexes
 2515:             command (like maxTimeMS) can be passed as keyword arguments.
 2516: 
 2517:         .. note:: requires a MongoDB server version 7.0+ Atlas cluster.
 2518: 
 2519:         .. versionadded:: 4.5
 2520:         """
 2521:         cmd = {"updateSearchIndex": self.__name, "name": name, "definition": definition}
 2522:         cmd.update(kwargs)
 2523:         if comment is not None:
 2524:             cmd["comment"] = comment
 2525:         with self._conn_for_writes(session, operation=_Op.UPDATE_SEARCH_INDEX) as conn:
 2526:             self._command(
 2527:                 conn,
 2528:                 cmd,
 2529:                 read_preference=ReadPreference.PRIMARY,
 2530:                 allowable_errors=["ns not found", 26],
 2531:                 codec_options=_UNICODE_REPLACE_CODEC_OPTIONS,
 2532:             )
 2533: 
 2534:     def options(
 2535:         self,
 2536:         session: Optional[ClientSession] = None,
 2537:         comment: Optional[Any] = None,
 2538:     ) -> MutableMapping[str, Any]:
 2539:         """Get the options set on this collection.
 2540: 
 2541:         Returns a dictionary of options and their values - see
 2542:         :meth:`~pymongo.database.Database.create_collection` for more
 2543:         information on the possible options. Returns an empty
 2544:         dictionary if the collection has not been created yet.
 2545: 
 2546:         :param session: a
 2547:             :class:`~pymongo.client_session.ClientSession`.
 2548:         :param comment: A user-provided comment to attach to this
 2549:             command.
 2550: 
 2551:         .. versionchanged:: 3.6
 2552:            Added ``session`` parameter.
 2553:         """
 2554:         dbo = self.__database.client.get_database(
 2555:             self.__database.name,
 2556:             self.codec_options,
 2557:             self.read_preference,
 2558:             self.write_concern,
 2559:             self.read_concern,
 2560:         )
 2561:         cursor = dbo.list_collections(
 2562:             session=session, filter={"name": self.__name}, comment=comment
 2563:         )
 2564: 
 2565:         result = None
 2566:         for doc in cursor:
 2567:             result = doc
 2568:             break
 2569: 
 2570:         if not result:
 2571:             return {}
 2572: 
 2573:         options = result.get("options", {})
 2574:         assert options is not None
 2575:         if "create" in options:
 2576:             del options["create"]
 2577: 
 2578:         return options
 2579: 
 2580:     @_csot.apply
 2581:     def _aggregate(
 2582:         self,
 2583:         aggregation_command: Type[_AggregationCommand],
 2584:         pipeline: _Pipeline,
 2585:         cursor_class: Type[CommandCursor],
 2586:         session: Optional[ClientSession],
 2587:         explicit_session: bool,
 2588:         let: Optional[Mapping[str, Any]] = None,
 2589:         comment: Optional[Any] = None,
 2590:         **kwargs: Any,
 2591:     ) -> CommandCursor[_DocumentType]:
 2592:         if comment is not None:
 2593:             kwargs["comment"] = comment
 2594:         cmd = aggregation_command(
 2595:             self,
 2596:             cursor_class,
 2597:             pipeline,
 2598:             kwargs,
 2599:             explicit_session,
 2600:             let,
 2601:             user_fields={"cursor": {"firstBatch": 1}},
 2602:         )
 2603: 
 2604:         return self.__database.client._retryable_read(
 2605:             cmd.get_cursor,
 2606:             cmd.get_read_preference(session),  # type: ignore[arg-type]
 2607:             session,
 2608:             retryable=not cmd._performs_write,
 2609:             operation=_Op.AGGREGATE,
 2610:         )
 2611: 
 2612:     def aggregate(
 2613:         self,
 2614:         pipeline: _Pipeline,
 2615:         session: Optional[ClientSession] = None,
 2616:         let: Optional[Mapping[str, Any]] = None,
 2617:         comment: Optional[Any] = None,
 2618:         **kwargs: Any,
 2619:     ) -> CommandCursor[_DocumentType]:
 2620:         """Perform an aggregation using the aggregation framework on this
 2621:         collection.
 2622: 
 2623:         The :meth:`aggregate` method obeys the :attr:`read_preference` of this
 2624:         :class:`Collection`, except when ``$out`` or ``$merge`` are used on
 2625:         MongoDB <5.0, in which case
 2626:         :attr:`~pymongo.read_preferences.ReadPreference.PRIMARY` is used.
 2627: 
 2628:         .. note:: This method does not support the 'explain' option. Please
 2629:            use `PyMongoExplain <https://pypi.org/project/pymongoexplain/>`_
 2630:            instead. An example is included in the :ref:`aggregate-examples`
 2631:            documentation.
 2632: 
 2633:         .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
 2634:            this collection is automatically applied to this operation.
 2635: 
 2636:         :param pipeline: a list of aggregation pipeline stages
 2637:         :param session: a
 2638:             :class:`~pymongo.client_session.ClientSession`.
 2639:         :param let: A dict of parameter names and values. Values must be
 2640:             constant or closed expressions that do not reference document
 2641:             fields. Parameters can then be accessed as variables in an
 2642:             aggregate expression context (e.g. ``"$$var"``). This option is
 2643:             only supported on MongoDB >= 5.0.
 2644:         :param comment: A user-provided comment to attach to this
 2645:             command.
 2646:         :param kwargs: extra `aggregate command`_ parameters.
 2647: 
 2648:         All optional `aggregate command`_ parameters should be passed as
 2649:         keyword arguments to this method. Valid options include, but are not
 2650:         limited to:
 2651: 
 2652:           - `allowDiskUse` (bool): Enables writing to temporary files. When set
 2653:             to True, aggregation stages can write data to the _tmp subdirectory
 2654:             of the --dbpath directory. The default is False.
 2655:           - `maxTimeMS` (int): The maximum amount of time to allow the operation
 2656:             to run in milliseconds.
 2657:           - `batchSize` (int): The maximum number of documents to return per
 2658:             batch. Ignored if the connected mongod or mongos does not support
 2659:             returning aggregate results using a cursor.
 2660:           - `collation` (optional): An instance of
 2661:             :class:`~pymongo.collation.Collation`.
 2662: 
 2663: 
 2664:         :return: A :class:`~pymongo.command_cursor.CommandCursor` over the result
 2665:           set.
 2666: 
 2667:         .. versionchanged:: 4.1
 2668:            Added ``comment`` parameter.
 2669:            Added ``let`` parameter.
 2670:            Support $merge and $out executing on secondaries according to the
 2671:            collection's :attr:`read_preference`.
 2672:         .. versionchanged:: 4.0
 2673:            Removed the ``useCursor`` option.
 2674:         .. versionchanged:: 3.9
 2675:            Apply this collection's read concern to pipelines containing the
 2676:            `$out` stage when connected to MongoDB >= 4.2.
 2677:            Added support for the ``$merge`` pipeline stage.
 2678:            Aggregations that write always use read preference
 2679:            :attr:`~pymongo.read_preferences.ReadPreference.PRIMARY`.
 2680:         .. versionchanged:: 3.6
 2681:            Added the `session` parameter. Added the `maxAwaitTimeMS` option.
 2682:            Deprecated the `useCursor` option.
 2683:         .. versionchanged:: 3.4
 2684:            Apply this collection's write concern automatically to this operation
 2685:            when connected to MongoDB >= 3.4. Support the `collation` option.
 2686:         .. versionchanged:: 3.0
 2687:            The :meth:`aggregate` method always returns a CommandCursor. The
 2688:            pipeline argument must be a list.
 2689: 
 2690:         .. seealso:: :doc:`/examples/aggregation`
 2691: 
 2692:         .. _aggregate command:
 2693:             https://mongodb.com/docs/manual/reference/command/aggregate
 2694:         """
 2695:         with self.__database.client._tmp_session(session, close=False) as s:
 2696:             return self._aggregate(
 2697:                 _CollectionAggregationCommand,
 2698:                 pipeline,
 2699:                 CommandCursor,
 2700:                 session=s,
 2701:                 explicit_session=session is not None,
 2702:                 let=let,
 2703:                 comment=comment,
 2704:                 **kwargs,
 2705:             )
 2706: 
 2707:     def aggregate_raw_batches(
 2708:         self,
 2709:         pipeline: _Pipeline,
 2710:         session: Optional[ClientSession] = None,
 2711:         comment: Optional[Any] = None,
 2712:         **kwargs: Any,
 2713:     ) -> RawBatchCursor[_DocumentType]:
 2714:         """Perform an aggregation and retrieve batches of raw BSON.
 2715: 
 2716:         Similar to the :meth:`aggregate` method but returns a
 2717:         :class:`~pymongo.cursor.RawBatchCursor`.
 2718: 
 2719:         This example demonstrates how to work with raw batches, but in practice
 2720:         raw batches should be passed to an external library that can decode
 2721:         BSON into another data type, rather than used with PyMongo's
 2722:         :mod:`bson` module.
 2723: 
 2724:           >>> import bson
 2725:           >>> cursor = db.test.aggregate_raw_batches([
 2726:           ...     {'$project': {'x': {'$multiply': [2, '$x']}}}])
 2727:           >>> for batch in cursor:
 2728:           ...     print(bson.decode_all(batch))
 2729: 
 2730:         .. note:: aggregate_raw_batches does not support auto encryption.
 2731: 
 2732:         .. versionchanged:: 3.12
 2733:            Added session support.
 2734: 
 2735:         .. versionadded:: 3.6
 2736:         """
 2737:         # OP_MSG is required to support encryption.
 2738:         if self.__database.client._encrypter:
 2739:             raise InvalidOperation("aggregate_raw_batches does not support auto encryption")
 2740:         if comment is not None:
 2741:             kwargs["comment"] = comment
 2742:         with self.__database.client._tmp_session(session, close=False) as s:
 2743:             return cast(
 2744:                 RawBatchCursor[_DocumentType],
 2745:                 self._aggregate(
 2746:                     _CollectionRawAggregationCommand,
 2747:                     pipeline,
 2748:                     RawBatchCommandCursor,
 2749:                     session=s,
 2750:                     explicit_session=session is not None,
 2751:                     **kwargs,
 2752:                 ),
 2753:             )
 2754: 
 2755:     def watch(
 2756:         self,
 2757:         pipeline: Optional[_Pipeline] = None,
 2758:         full_document: Optional[str] = None,
 2759:         resume_after: Optional[Mapping[str, Any]] = None,
 2760:         max_await_time_ms: Optional[int] = None,
 2761:         batch_size: Optional[int] = None,
 2762:         collation: Optional[_CollationIn] = None,
 2763:         start_at_operation_time: Optional[Timestamp] = None,
 2764:         session: Optional[ClientSession] = None,
 2765:         start_after: Optional[Mapping[str, Any]] = None,
 2766:         comment: Optional[Any] = None,
 2767:         full_document_before_change: Optional[str] = None,
 2768:         show_expanded_events: Optional[bool] = None,
 2769:     ) -> CollectionChangeStream[_DocumentType]:
 2770:         """Watch changes on this collection.
 2771: 
 2772:         Performs an aggregation with an implicit initial ``$changeStream``
 2773:         stage and returns a
 2774:         :class:`~pymongo.change_stream.CollectionChangeStream` cursor which
 2775:         iterates over changes on this collection.
 2776: 
 2777:         .. code-block:: python
 2778: 
 2779:            with db.collection.watch() as stream:
 2780:                for change in stream:
 2781:                    print(change)
 2782: 
 2783:         The :class:`~pymongo.change_stream.CollectionChangeStream` iterable
 2784:         blocks until the next change document is returned or an error is
 2785:         raised. If the
 2786:         :meth:`~pymongo.change_stream.CollectionChangeStream.next` method
 2787:         encounters a network error when retrieving a batch from the server,
 2788:         it will automatically attempt to recreate the cursor such that no
 2789:         change events are missed. Any error encountered during the resume
 2790:         attempt indicates there may be an outage and will be raised.
 2791: 
 2792:         .. code-block:: python
 2793: 
 2794:             try:
 2795:                 with db.collection.watch([{"$match": {"operationType": "insert"}}]) as stream:
 2796:                     for insert_change in stream:
 2797:                         print(insert_change)
 2798:             except pymongo.errors.PyMongoError:
 2799:                 # The ChangeStream encountered an unrecoverable error or the
 2800:                 # resume attempt failed to recreate the cursor.
 2801:                 logging.error("...")
 2802: 
 2803:         For a precise description of the resume process see the
 2804:         `change streams specification`_.
 2805: 
 2806:         .. note:: Using this helper method is preferred to directly calling
 2807:             :meth:`~pymongo.collection.Collection.aggregate` with a
 2808:             ``$changeStream`` stage, for the purpose of supporting
 2809:             resumability.
 2810: 
 2811:         .. warning:: This Collection's :attr:`read_concern` must be
 2812:             ``ReadConcern("majority")`` in order to use the ``$changeStream``
 2813:             stage.
 2814: 
 2815:         :param pipeline: A list of aggregation pipeline stages to
 2816:             append to an initial ``$changeStream`` stage. Not all
 2817:             pipeline stages are valid after a ``$changeStream`` stage, see the
 2818:             MongoDB documentation on change streams for the supported stages.
 2819:         :param full_document: The fullDocument to pass as an option
 2820:             to the ``$changeStream`` stage. Allowed values: 'updateLookup',
 2821:             'whenAvailable', 'required'. When set to 'updateLookup', the
 2822:             change notification for partial updates will include both a delta
 2823:             describing the changes to the document, as well as a copy of the
 2824:             entire document that was changed from some time after the change
 2825:             occurred.
 2826:         :param full_document_before_change: Allowed values: 'whenAvailable'
 2827:             and 'required'. Change events may now result in a
 2828:             'fullDocumentBeforeChange' response field.
 2829:         :param resume_after: A resume token. If provided, the
 2830:             change stream will start returning changes that occur directly
 2831:             after the operation specified in the resume token. A resume token
 2832:             is the _id value of a change document.
 2833:         :param max_await_time_ms: The maximum time in milliseconds
 2834:             for the server to wait for changes before responding to a getMore
 2835:             operation.
 2836:         :param batch_size: The maximum number of documents to return
 2837:             per batch.
 2838:         :param collation: The :class:`~pymongo.collation.Collation`
 2839:             to use for the aggregation.
 2840:         :param start_at_operation_time: If provided, the resulting
 2841:             change stream will only return changes that occurred at or after
 2842:             the specified :class:`~bson.timestamp.Timestamp`. Requires
 2843:             MongoDB >= 4.0.
 2844:         :param session: a
 2845:             :class:`~pymongo.client_session.ClientSession`.
 2846:         :param start_after: The same as `resume_after` except that
 2847:             `start_after` can resume notifications after an invalidate event.
 2848:             This option and `resume_after` are mutually exclusive.
 2849:         :param comment: A user-provided comment to attach to this
 2850:             command.
 2851:         :param show_expanded_events: Include expanded events such as DDL events like `dropIndexes`.
 2852: 
 2853:         :return: A :class:`~pymongo.change_stream.CollectionChangeStream` cursor.
 2854: 
 2855:         .. versionchanged:: 4.3
 2856:            Added `show_expanded_events` parameter.
 2857: 
 2858:         .. versionchanged:: 4.2
 2859:            Added ``full_document_before_change`` parameter.
 2860: 
 2861:         .. versionchanged:: 4.1
 2862:            Added ``comment`` parameter.
 2863: 
 2864:         .. versionchanged:: 3.9
 2865:            Added the ``start_after`` parameter.
 2866: 
 2867:         .. versionchanged:: 3.7
 2868:            Added the ``start_at_operation_time`` parameter.
 2869: 
 2870:         .. versionadded:: 3.6
 2871: 
 2872:         .. seealso:: The MongoDB documentation on `changeStreams <https://mongodb.com/docs/manual/changeStreams/>`_.
 2873: 
 2874:         .. _change streams specification:
 2875:             https://github.com/mongodb/specifications/blob/master/source/change-streams/change-streams.md
 2876:         """
 2877:         return CollectionChangeStream(
 2878:             self,
 2879:             pipeline,
 2880:             full_document,
 2881:             resume_after,
 2882:             max_await_time_ms,
 2883:             batch_size,
 2884:             collation,
 2885:             start_at_operation_time,
 2886:             session,
 2887:             start_after,
 2888:             comment,
 2889:             full_document_before_change,
 2890:             show_expanded_events,
 2891:         )
 2892: 
 2893:     @_csot.apply
 2894:     def rename(
 2895:         self,
 2896:         new_name: str,
 2897:         session: Optional[ClientSession] = None,
 2898:         comment: Optional[Any] = None,
 2899:         **kwargs: Any,
 2900:     ) -> MutableMapping[str, Any]:
 2901:         """Rename this collection.
 2902: 
 2903:         If operating in auth mode, client must be authorized as an
 2904:         admin to perform this operation. Raises :class:`TypeError` if
 2905:         `new_name` is not an instance of :class:`str`.
 2906:         Raises :class:`~pymongo.errors.InvalidName`
 2907:         if `new_name` is not a valid collection name.
 2908: 
 2909:         :param new_name: new name for this collection
 2910:         :param session: a
 2911:             :class:`~pymongo.client_session.ClientSession`.
 2912:         :param comment: A user-provided comment to attach to this
 2913:             command.
 2914:         :param kwargs: additional arguments to the rename command
 2915:             may be passed as keyword arguments to this helper method
 2916:             (i.e. ``dropTarget=True``)
 2917: 
 2918:         .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
 2919:            this collection is automatically applied to this operation.
 2920: 
 2921:         .. versionchanged:: 3.6
 2922:            Added ``session`` parameter.
 2923: 
 2924:         .. versionchanged:: 3.4
 2925:            Apply this collection's write concern automatically to this operation
 2926:            when connected to MongoDB >= 3.4.
 2927: 
 2928:         """
 2929:         if not isinstance(new_name, str):
 2930:             raise TypeError("new_name must be an instance of str")
 2931: 
 2932:         if not new_name or ".." in new_name:
 2933:             raise InvalidName("collection names cannot be empty")
 2934:         if new_name[0] == "." or new_name[-1] == ".":
 2935:             raise InvalidName("collection names must not start or end with '.'")
 2936:         if "$" in new_name and not new_name.startswith("oplog.$main"):
 2937:             raise InvalidName("collection names must not contain '$'")
 2938: 
 2939:         new_name = f"{self.__database.name}.{new_name}"
 2940:         cmd = {"renameCollection": self.__full_name, "to": new_name}
 2941:         cmd.update(kwargs)
 2942:         if comment is not None:
 2943:             cmd["comment"] = comment
 2944:         write_concern = self._write_concern_for_cmd(cmd, session)
 2945: 
 2946:         with self._conn_for_writes(session, operation=_Op.RENAME) as conn:
 2947:             with self.__database.client._tmp_session(session) as s:
 2948:                 return conn.command(
 2949:                     "admin",
 2950:                     cmd,
 2951:                     write_concern=write_concern,
 2952:                     parse_write_concern_error=True,
 2953:                     session=s,
 2954:                     client=self.__database.client,
 2955:                 )
 2956: 
 2957:     def distinct(
 2958:         self,
 2959:         key: str,
 2960:         filter: Optional[Mapping[str, Any]] = None,
 2961:         session: Optional[ClientSession] = None,
 2962:         comment: Optional[Any] = None,
 2963:         **kwargs: Any,
 2964:     ) -> list:
 2965:         """Get a list of distinct values for `key` among all documents
 2966:         in this collection.
 2967: 
 2968:         Raises :class:`TypeError` if `key` is not an instance of
 2969:         :class:`str`.
 2970: 
 2971:         All optional distinct parameters should be passed as keyword arguments
 2972:         to this method. Valid options include:
 2973: 
 2974:           - `maxTimeMS` (int): The maximum amount of time to allow the count
 2975:             command to run, in milliseconds.
 2976:           - `collation` (optional): An instance of
 2977:             :class:`~pymongo.collation.Collation`.
 2978: 
 2979:         The :meth:`distinct` method obeys the :attr:`read_preference` of
 2980:         this :class:`Collection`.
 2981: 
 2982:         :param key: name of the field for which we want to get the distinct
 2983:             values
 2984:         :param filter: A query document that specifies the documents
 2985:             from which to retrieve the distinct values.
 2986:         :param session: a
 2987:             :class:`~pymongo.client_session.ClientSession`.
 2988:         :param comment: A user-provided comment to attach to this
 2989:             command.
 2990:         :param kwargs: See list of options above.
 2991: 
 2992:         .. versionchanged:: 3.6
 2993:            Added ``session`` parameter.
 2994: 
 2995:         .. versionchanged:: 3.4
 2996:            Support the `collation` option.
 2997: 
 2998:         """
 2999:         if not isinstance(key, str):
 3000:             raise TypeError("key must be an instance of str")
 3001:         cmd = {"distinct": self.__name, "key": key}
 3002:         if filter is not None:
 3003:             if "query" in kwargs:
 3004:                 raise ConfigurationError("can't pass both filter and query")
 3005:             kwargs["query"] = filter
 3006:         collation = validate_collation_or_none(kwargs.pop("collation", None))
 3007:         cmd.update(kwargs)
 3008:         if comment is not None:
 3009:             cmd["comment"] = comment
 3010: 
 3011:         def _cmd(
 3012:             session: Optional[ClientSession],
 3013:             _server: Server,
 3014:             conn: Connection,
 3015:             read_preference: Optional[_ServerMode],
 3016:         ) -> list:
 3017:             return self._command(
 3018:                 conn,
 3019:                 cmd,
 3020:                 read_preference=read_preference,
 3021:                 read_concern=self.read_concern,
 3022:                 collation=collation,
 3023:                 session=session,
 3024:                 user_fields={"values": 1},
 3025:             )["values"]
 3026: 
 3027:         return self._retryable_non_cursor_read(_cmd, session, operation=_Op.DISTINCT)
 3028: 
 3029:     def _write_concern_for_cmd(
 3030:         self, cmd: Mapping[str, Any], session: Optional[ClientSession]
 3031:     ) -> WriteConcern:
 3032:         raw_wc = cmd.get("writeConcern")
 3033:         if raw_wc is not None:
 3034:             return WriteConcern(**raw_wc)
 3035:         else:
 3036:             return self._write_concern_for(session)
 3037: 
 3038:     def __find_and_modify(
 3039:         self,
 3040:         filter: Mapping[str, Any],
 3041:         projection: Optional[Union[Mapping[str, Any], Iterable[str]]],
 3042:         sort: Optional[_IndexList],
 3043:         upsert: Optional[bool] = None,
 3044:         return_document: bool = ReturnDocument.BEFORE,
 3045:         array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
 3046:         hint: Optional[_IndexKeyHint] = None,
 3047:         session: Optional[ClientSession] = None,
 3048:         let: Optional[Mapping] = None,
 3049:         **kwargs: Any,
 3050:     ) -> Any:
 3051:         """Internal findAndModify helper."""
 3052:         common.validate_is_mapping("filter", filter)
 3053:         if not isinstance(return_document, bool):
 3054:             raise ValueError(
 3055:                 "return_document must be ReturnDocument.BEFORE or ReturnDocument.AFTER"
 3056:             )
 3057:         collation = validate_collation_or_none(kwargs.pop("collation", None))
 3058:         cmd = {"findAndModify": self.__name, "query": filter, "new": return_document}
 3059:         if let is not None:
 3060:             common.validate_is_mapping("let", let)
 3061:             cmd["let"] = let
 3062:         cmd.update(kwargs)
 3063:         if projection is not None:
 3064:             cmd["fields"] = helpers._fields_list_to_dict(projection, "projection")
 3065:         if sort is not None:
 3066:             cmd["sort"] = helpers._index_document(sort)
 3067:         if upsert is not None:
 3068:             validate_boolean("upsert", upsert)
 3069:             cmd["upsert"] = upsert
 3070:         if hint is not None:
 3071:             if not isinstance(hint, str):
 3072:                 hint = helpers._index_document(hint)
 3073: 
 3074:         write_concern = self._write_concern_for_cmd(cmd, session)
 3075: 
 3076:         def _find_and_modify(
 3077:             session: Optional[ClientSession], conn: Connection, retryable_write: bool
 3078:         ) -> Any:
 3079:             acknowledged = write_concern.acknowledged
 3080:             if array_filters is not None:
 3081:                 if not acknowledged:
 3082:                     raise ConfigurationError(
 3083:                         "arrayFilters is unsupported for unacknowledged writes."
 3084:                     )
 3085:                 cmd["arrayFilters"] = list(array_filters)
 3086:             if hint is not None:
 3087:                 if conn.max_wire_version < 8:
 3088:                     raise ConfigurationError(
 3089:                         "Must be connected to MongoDB 4.2+ to use hint on find and modify commands."
 3090:                     )
 3091:                 elif not acknowledged and conn.max_wire_version < 9:
 3092:                     raise ConfigurationError(
 3093:                         "Must be connected to MongoDB 4.4+ to use hint on unacknowledged find and modify commands."
 3094:                     )
 3095:                 cmd["hint"] = hint
 3096:             out = self._command(
 3097:                 conn,
 3098:                 cmd,
 3099:                 read_preference=ReadPreference.PRIMARY,
 3100:                 write_concern=write_concern,
 3101:                 collation=collation,
 3102:                 session=session,
 3103:                 retryable_write=retryable_write,
 3104:                 user_fields=_FIND_AND_MODIFY_DOC_FIELDS,
 3105:             )
 3106:             _check_write_command_response(out)
 3107: 
 3108:             return out.get("value")
 3109: 
 3110:         return self.__database.client._retryable_write(
 3111:             write_concern.acknowledged,
 3112:             _find_and_modify,
 3113:             session,
 3114:             operation=_Op.FIND_AND_MODIFY,
 3115:         )
 3116: 
 3117:     def find_one_and_delete(
 3118:         self,
 3119:         filter: Mapping[str, Any],
 3120:         projection: Optional[Union[Mapping[str, Any], Iterable[str]]] = None,
 3121:         sort: Optional[_IndexList] = None,
 3122:         hint: Optional[_IndexKeyHint] = None,
 3123:         session: Optional[ClientSession] = None,
 3124:         let: Optional[Mapping[str, Any]] = None,
 3125:         comment: Optional[Any] = None,
 3126:         **kwargs: Any,
 3127:     ) -> _DocumentType:
 3128:         """Finds a single document and deletes it, returning the document.
 3129: 
 3130:           >>> db.test.count_documents({'x': 1})
 3131:           2
 3132:           >>> db.test.find_one_and_delete({'x': 1})
 3133:           {'x': 1, '_id': ObjectId('54f4e12bfba5220aa4d6dee8')}
 3134:           >>> db.test.count_documents({'x': 1})
 3135:           1
 3136: 
 3137:         If multiple documents match *filter*, a *sort* can be applied.
 3138: 
 3139:           >>> for doc in db.test.find({'x': 1}):
 3140:           ...     print(doc)
 3141:           ...
 3142:           {'x': 1, '_id': 0}
 3143:           {'x': 1, '_id': 1}
 3144:           {'x': 1, '_id': 2}
 3145:           >>> db.test.find_one_and_delete(
 3146:           ...     {'x': 1}, sort=[('_id', pymongo.DESCENDING)])
 3147:           {'x': 1, '_id': 2}
 3148: 
 3149:         The *projection* option can be used to limit the fields returned.
 3150: 
 3151:           >>> db.test.find_one_and_delete({'x': 1}, projection={'_id': False})
 3152:           {'x': 1}
 3153: 
 3154:         :param filter: A query that matches the document to delete.
 3155:         :param projection: a list of field names that should be
 3156:             returned in the result document or a mapping specifying the fields
 3157:             to include or exclude. If `projection` is a list "_id" will
 3158:             always be returned. Use a mapping to exclude fields from
 3159:             the result (e.g. projection={'_id': False}).
 3160:         :param sort: a list of (key, direction) pairs
 3161:             specifying the sort order for the query. If multiple documents
 3162:             match the query, they are sorted and the first is deleted.
 3163:         :param hint: An index to use to support the query predicate
 3164:             specified either by its string name, or in the same format as
 3165:             passed to :meth:`~pymongo.collection.Collection.create_index`
 3166:             (e.g. ``[('field', ASCENDING)]``). This option is only supported
 3167:             on MongoDB 4.4 and above.
 3168:         :param session: a
 3169:             :class:`~pymongo.client_session.ClientSession`.
 3170:         :param let: Map of parameter names and values. Values must be
 3171:             constant or closed expressions that do not reference document
 3172:             fields. Parameters can then be accessed as variables in an
 3173:             aggregate expression context (e.g. "$$var").
 3174:         :param comment: A user-provided comment to attach to this
 3175:             command.
 3176:         :param kwargs: additional command arguments can be passed
 3177:             as keyword arguments (for example maxTimeMS can be used with
 3178:             recent server versions).
 3179: 
 3180:         .. versionchanged:: 4.1
 3181:            Added ``let`` parameter.
 3182:         .. versionchanged:: 3.11
 3183:            Added ``hint`` parameter.
 3184:         .. versionchanged:: 3.6
 3185:            Added ``session`` parameter.
 3186:         .. versionchanged:: 3.2
 3187:            Respects write concern.
 3188: 
 3189:         .. warning:: Starting in PyMongo 3.2, this command uses the
 3190:            :class:`~pymongo.write_concern.WriteConcern` of this
 3191:            :class:`~pymongo.collection.Collection` when connected to MongoDB >=
 3192:            3.2. Note that using an elevated write concern with this command may
 3193:            be slower compared to using the default write concern.
 3194: 
 3195:         .. versionchanged:: 3.4
 3196:            Added the `collation` option.
 3197:         .. versionadded:: 3.0
 3198:         """
 3199:         kwargs["remove"] = True
 3200:         if comment is not None:
 3201:             kwargs["comment"] = comment
 3202:         return self.__find_and_modify(
 3203:             filter, projection, sort, let=let, hint=hint, session=session, **kwargs
 3204:         )
 3205: 
 3206:     def find_one_and_replace(
 3207:         self,
 3208:         filter: Mapping[str, Any],
 3209:         replacement: Mapping[str, Any],
 3210:         projection: Optional[Union[Mapping[str, Any], Iterable[str]]] = None,
 3211:         sort: Optional[_IndexList] = None,
 3212:         upsert: bool = False,
 3213:         return_document: bool = ReturnDocument.BEFORE,
 3214:         hint: Optional[_IndexKeyHint] = None,
 3215:         session: Optional[ClientSession] = None,
 3216:         let: Optional[Mapping[str, Any]] = None,
 3217:         comment: Optional[Any] = None,
 3218:         **kwargs: Any,
 3219:     ) -> _DocumentType:
 3220:         """Finds a single document and replaces it, returning either the
 3221:         original or the replaced document.
 3222: 
 3223:         The :meth:`find_one_and_replace` method differs from
 3224:         :meth:`find_one_and_update` by replacing the document matched by
 3225:         *filter*, rather than modifying the existing document.
 3226: 
 3227:           >>> for doc in db.test.find({}):
 3228:           ...     print(doc)
 3229:           ...
 3230:           {'x': 1, '_id': 0}
 3231:           {'x': 1, '_id': 1}
 3232:           {'x': 1, '_id': 2}
 3233:           >>> db.test.find_one_and_replace({'x': 1}, {'y': 1})
 3234:           {'x': 1, '_id': 0}
 3235:           >>> for doc in db.test.find({}):
 3236:           ...     print(doc)
 3237:           ...
 3238:           {'y': 1, '_id': 0}
 3239:           {'x': 1, '_id': 1}
 3240:           {'x': 1, '_id': 2}
 3241: 
 3242:         :param filter: A query that matches the document to replace.
 3243:         :param replacement: The replacement document.
 3244:         :param projection: A list of field names that should be
 3245:             returned in the result document or a mapping specifying the fields
 3246:             to include or exclude. If `projection` is a list "_id" will
 3247:             always be returned. Use a mapping to exclude fields from
 3248:             the result (e.g. projection={'_id': False}).
 3249:         :param sort: a list of (key, direction) pairs
 3250:             specifying the sort order for the query. If multiple documents
 3251:             match the query, they are sorted and the first is replaced.
 3252:         :param upsert: When ``True``, inserts a new document if no
 3253:             document matches the query. Defaults to ``False``.
 3254:         :param return_document: If
 3255:             :attr:`ReturnDocument.BEFORE` (the default),
 3256:             returns the original document before it was replaced, or ``None``
 3257:             if no document matches. If
 3258:             :attr:`ReturnDocument.AFTER`, returns the replaced
 3259:             or inserted document.
 3260:         :param hint: An index to use to support the query
 3261:             predicate specified either by its string name, or in the same
 3262:             format as passed to
 3263:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
 3264:             ``[('field', ASCENDING)]``). This option is only supported on
 3265:             MongoDB 4.4 and above.
 3266:         :param session: a
 3267:             :class:`~pymongo.client_session.ClientSession`.
 3268:         :param let: Map of parameter names and values. Values must be
 3269:             constant or closed expressions that do not reference document
 3270:             fields. Parameters can then be accessed as variables in an
 3271:             aggregate expression context (e.g. "$$var").
 3272:         :param comment: A user-provided comment to attach to this
 3273:             command.
 3274:         :param kwargs: additional command arguments can be passed
 3275:             as keyword arguments (for example maxTimeMS can be used with
 3276:             recent server versions).
 3277: 
 3278:         .. versionchanged:: 4.1
 3279:            Added ``let`` parameter.
 3280:         .. versionchanged:: 3.11
 3281:            Added the ``hint`` option.
 3282:         .. versionchanged:: 3.6
 3283:            Added ``session`` parameter.
 3284:         .. versionchanged:: 3.4
 3285:            Added the ``collation`` option.
 3286:         .. versionchanged:: 3.2
 3287:            Respects write concern.
 3288: 
 3289:         .. warning:: Starting in PyMongo 3.2, this command uses the
 3290:            :class:`~pymongo.write_concern.WriteConcern` of this
 3291:            :class:`~pymongo.collection.Collection` when connected to MongoDB >=
 3292:            3.2. Note that using an elevated write concern with this command may
 3293:            be slower compared to using the default write concern.
 3294: 
 3295:         .. versionadded:: 3.0
 3296:         """
 3297:         common.validate_ok_for_replace(replacement)
 3298:         kwargs["update"] = replacement
 3299:         if comment is not None:
 3300:             kwargs["comment"] = comment
 3301:         return self.__find_and_modify(
 3302:             filter,
 3303:             projection,
 3304:             sort,
 3305:             upsert,
 3306:             return_document,
 3307:             let=let,
 3308:             hint=hint,
 3309:             session=session,
 3310:             **kwargs,
 3311:         )
 3312: 
 3313:     def find_one_and_update(
 3314:         self,
 3315:         filter: Mapping[str, Any],
 3316:         update: Union[Mapping[str, Any], _Pipeline],
 3317:         projection: Optional[Union[Mapping[str, Any], Iterable[str]]] = None,
 3318:         sort: Optional[_IndexList] = None,
 3319:         upsert: bool = False,
 3320:         return_document: bool = ReturnDocument.BEFORE,
 3321:         array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
 3322:         hint: Optional[_IndexKeyHint] = None,
 3323:         session: Optional[ClientSession] = None,
 3324:         let: Optional[Mapping[str, Any]] = None,
 3325:         comment: Optional[Any] = None,
 3326:         **kwargs: Any,
 3327:     ) -> _DocumentType:
 3328:         """Finds a single document and updates it, returning either the
 3329:         original or the updated document.
 3330: 
 3331:           >>> db.test.find_one_and_update(
 3332:           ...    {'_id': 665}, {'$inc': {'count': 1}, '$set': {'done': True}})
 3333:           {'_id': 665, 'done': False, 'count': 25}}
 3334: 
 3335:         Returns ``None`` if no document matches the filter.
 3336: 
 3337:           >>> db.test.find_one_and_update(
 3338:           ...    {'_exists': False}, {'$inc': {'count': 1}})
 3339: 
 3340:         When the filter matches, by default :meth:`find_one_and_update`
 3341:         returns the original version of the document before the update was
 3342:         applied. To return the updated (or inserted in the case of
 3343:         *upsert*) version of the document instead, use the *return_document*
 3344:         option.
 3345: 
 3346:           >>> from pymongo import ReturnDocument
 3347:           >>> db.example.find_one_and_update(
 3348:           ...     {'_id': 'userid'},
 3349:           ...     {'$inc': {'seq': 1}},
 3350:           ...     return_document=ReturnDocument.AFTER)
 3351:           {'_id': 'userid', 'seq': 1}
 3352: 
 3353:         You can limit the fields returned with the *projection* option.
 3354: 
 3355:           >>> db.example.find_one_and_update(
 3356:           ...     {'_id': 'userid'},
 3357:           ...     {'$inc': {'seq': 1}},
 3358:           ...     projection={'seq': True, '_id': False},
 3359:           ...     return_document=ReturnDocument.AFTER)
 3360:           {'seq': 2}
 3361: 
 3362:         The *upsert* option can be used to create the document if it doesn't
 3363:         already exist.
 3364: 
 3365:           >>> db.example.delete_many({}).deleted_count
 3366:           1
 3367:           >>> db.example.find_one_and_update(
 3368:           ...     {'_id': 'userid'},
 3369:           ...     {'$inc': {'seq': 1}},
 3370:           ...     projection={'seq': True, '_id': False},
 3371:           ...     upsert=True,
 3372:           ...     return_document=ReturnDocument.AFTER)
 3373:           {'seq': 1}
 3374: 
 3375:         If multiple documents match *filter*, a *sort* can be applied.
 3376: 
 3377:           >>> for doc in db.test.find({'done': True}):
 3378:           ...     print(doc)
 3379:           ...
 3380:           {'_id': 665, 'done': True, 'result': {'count': 26}}
 3381:           {'_id': 701, 'done': True, 'result': {'count': 17}}
 3382:           >>> db.test.find_one_and_update(
 3383:           ...     {'done': True},
 3384:           ...     {'$set': {'final': True}},
 3385:           ...     sort=[('_id', pymongo.DESCENDING)])
 3386:           {'_id': 701, 'done': True, 'result': {'count': 17}}
 3387: 
 3388:         :param filter: A query that matches the document to update.
 3389:         :param update: The update operations to apply.
 3390:         :param projection: A list of field names that should be
 3391:             returned in the result document or a mapping specifying the fields
 3392:             to include or exclude. If `projection` is a list "_id" will
 3393:             always be returned. Use a dict to exclude fields from
 3394:             the result (e.g. projection={'_id': False}).
 3395:         :param sort: a list of (key, direction) pairs
 3396:             specifying the sort order for the query. If multiple documents
 3397:             match the query, they are sorted and the first is updated.
 3398:         :param upsert: When ``True``, inserts a new document if no
 3399:             document matches the query. Defaults to ``False``.
 3400:         :param return_document: If
 3401:             :attr:`ReturnDocument.BEFORE` (the default),
 3402:             returns the original document before it was updated. If
 3403:             :attr:`ReturnDocument.AFTER`, returns the updated
 3404:             or inserted document.
 3405:         :param array_filters: A list of filters specifying which
 3406:             array elements an update should apply.
 3407:         :param hint: An index to use to support the query
 3408:             predicate specified either by its string name, or in the same
 3409:             format as passed to
 3410:             :meth:`~pymongo.collection.Collection.create_index` (e.g.
 3411:             ``[('field', ASCENDING)]``). This option is only supported on
 3412:             MongoDB 4.4 and above.
 3413:         :param session: a
 3414:             :class:`~pymongo.client_session.ClientSession`.
 3415:         :param let: Map of parameter names and values. Values must be
 3416:             constant or closed expressions that do not reference document
 3417:             fields. Parameters can then be accessed as variables in an
 3418:             aggregate expression context (e.g. "$$var").
 3419:         :param comment: A user-provided comment to attach to this
 3420:             command.
 3421:         :param kwargs: additional command arguments can be passed
 3422:             as keyword arguments (for example maxTimeMS can be used with
 3423:             recent server versions).
 3424: 
 3425:         .. versionchanged:: 3.11
 3426:            Added the ``hint`` option.
 3427:         .. versionchanged:: 3.9
 3428:            Added the ability to accept a pipeline as the ``update``.
 3429:         .. versionchanged:: 3.6
 3430:            Added the ``array_filters`` and ``session`` options.
 3431:         .. versionchanged:: 3.4
 3432:            Added the ``collation`` option.
 3433:         .. versionchanged:: 3.2
 3434:            Respects write concern.
 3435: 
 3436:         .. warning:: Starting in PyMongo 3.2, this command uses the
 3437:            :class:`~pymongo.write_concern.WriteConcern` of this
 3438:            :class:`~pymongo.collection.Collection` when connected to MongoDB >=
 3439:            3.2. Note that using an elevated write concern with this command may
 3440:            be slower compared to using the default write concern.
 3441: 
 3442:         .. versionadded:: 3.0
 3443:         """
 3444:         common.validate_ok_for_update(update)
 3445:         common.validate_list_or_none("array_filters", array_filters)
 3446:         kwargs["update"] = update
 3447:         if comment is not None:
 3448:             kwargs["comment"] = comment
 3449:         return self.__find_and_modify(
 3450:             filter,
 3451:             projection,
 3452:             sort,
 3453:             upsert,
 3454:             return_document,
 3455:             array_filters,
 3456:             hint=hint,
 3457:             let=let,
 3458:             session=session,
 3459:             **kwargs,
 3460:         )
 3461: 
 3462:     # See PYTHON-3084.
 3463:     __iter__ = None
 3464: 
 3465:     def __next__(self) -> NoReturn:
 3466:         raise TypeError("'Collection' object is not iterable")
 3467: 
 3468:     next = __next__
 3469: 
 3470:     def __call__(self, *args: Any, **kwargs: Any) -> NoReturn:
 3471:         """This is only here so that some API misusages are easier to debug."""
 3472:         if "." not in self.__name:
 3473:             raise TypeError(
 3474:                 "'Collection' object is not callable. If you "
 3475:                 "meant to call the '%s' method on a 'Database' "
 3476:                 "object it is failing because no such method "
 3477:                 "exists." % self.__name
 3478:             )
 3479:         raise TypeError(
 3480:             "'Collection' object is not callable. If you meant to "
 3481:             "call the '%s' method on a 'Collection' object it is "
 3482:             "failing because no such method exists." % self.__name.split(".")[-1]
 3483:         )
