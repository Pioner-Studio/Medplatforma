    1: # Copyright 2014-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Represent one server the driver is connected to."""
   16: from __future__ import annotations
   17: 
   18: import time
   19: import warnings
   20: from typing import Any, Mapping, Optional
   21: 
   22: from bson import EPOCH_NAIVE
   23: from bson.objectid import ObjectId
   24: from pymongo.hello import Hello
   25: from pymongo.server_type import SERVER_TYPE
   26: from pymongo.typings import ClusterTime, _Address
   27: 
   28: 
   29: class ServerDescription:
   30:     """Immutable representation of one server.
   31: 
   32:     :param address: A (host, port) pair
   33:     :param hello: Optional Hello instance
   34:     :param round_trip_time: Optional float
   35:     :param error: Optional, the last error attempting to connect to the server
   36:     :param round_trip_time: Optional float, the min latency from the most recent samples
   37:     """
   38: 
   39:     __slots__ = (
   40:         "_address",
   41:         "_server_type",
   42:         "_all_hosts",
   43:         "_tags",
   44:         "_replica_set_name",
   45:         "_primary",
   46:         "_max_bson_size",
   47:         "_max_message_size",
   48:         "_max_write_batch_size",
   49:         "_min_wire_version",
   50:         "_max_wire_version",
   51:         "_round_trip_time",
   52:         "_min_round_trip_time",
   53:         "_me",
   54:         "_is_writable",
   55:         "_is_readable",
   56:         "_ls_timeout_minutes",
   57:         "_error",
   58:         "_set_version",
   59:         "_election_id",
   60:         "_cluster_time",
   61:         "_last_write_date",
   62:         "_last_update_time",
   63:         "_topology_version",
   64:     )
   65: 
   66:     def __init__(
   67:         self,
   68:         address: _Address,
   69:         hello: Optional[Hello] = None,
   70:         round_trip_time: Optional[float] = None,
   71:         error: Optional[Exception] = None,
   72:         min_round_trip_time: float = 0.0,
   73:     ) -> None:
   74:         self._address = address
   75:         if not hello:
   76:             hello = Hello({})
   77: 
   78:         self._server_type = hello.server_type
   79:         self._all_hosts = hello.all_hosts
   80:         self._tags = hello.tags
   81:         self._replica_set_name = hello.replica_set_name
   82:         self._primary = hello.primary
   83:         self._max_bson_size = hello.max_bson_size
   84:         self._max_message_size = hello.max_message_size
   85:         self._max_write_batch_size = hello.max_write_batch_size
   86:         self._min_wire_version = hello.min_wire_version
   87:         self._max_wire_version = hello.max_wire_version
   88:         self._set_version = hello.set_version
   89:         self._election_id = hello.election_id
   90:         self._cluster_time = hello.cluster_time
   91:         self._is_writable = hello.is_writable
   92:         self._is_readable = hello.is_readable
   93:         self._ls_timeout_minutes = hello.logical_session_timeout_minutes
   94:         self._round_trip_time = round_trip_time
   95:         self._min_round_trip_time = min_round_trip_time
   96:         self._me = hello.me
   97:         self._last_update_time = time.monotonic()
   98:         self._error = error
   99:         self._topology_version = hello.topology_version
  100:         if error:
  101:             details = getattr(error, "details", None)
  102:             if isinstance(details, dict):
  103:                 self._topology_version = details.get("topologyVersion")
  104: 
  105:         self._last_write_date: Optional[float]
  106:         if hello.last_write_date:
  107:             # Convert from datetime to seconds.
  108:             delta = hello.last_write_date - EPOCH_NAIVE
  109:             self._last_write_date = delta.total_seconds()
  110:         else:
  111:             self._last_write_date = None
  112: 
  113:     @property
  114:     def address(self) -> _Address:
  115:         """The address (host, port) of this server."""
  116:         return self._address
  117: 
  118:     @property
  119:     def server_type(self) -> int:
  120:         """The type of this server."""
  121:         return self._server_type
  122: 
  123:     @property
  124:     def server_type_name(self) -> str:
  125:         """The server type as a human readable string.
  126: 
  127:         .. versionadded:: 3.4
  128:         """
  129:         return SERVER_TYPE._fields[self._server_type]
  130: 
  131:     @property
  132:     def all_hosts(self) -> set[tuple[str, int]]:
  133:         """List of hosts, passives, and arbiters known to this server."""
  134:         return self._all_hosts
  135: 
  136:     @property
  137:     def tags(self) -> Mapping[str, Any]:
  138:         return self._tags
  139: 
  140:     @property
  141:     def replica_set_name(self) -> Optional[str]:
  142:         """Replica set name or None."""
  143:         return self._replica_set_name
  144: 
  145:     @property
  146:     def primary(self) -> Optional[tuple[str, int]]:
  147:         """This server's opinion about who the primary is, or None."""
  148:         return self._primary
  149: 
  150:     @property
  151:     def max_bson_size(self) -> int:
  152:         return self._max_bson_size
  153: 
  154:     @property
  155:     def max_message_size(self) -> int:
  156:         return self._max_message_size
  157: 
  158:     @property
  159:     def max_write_batch_size(self) -> int:
  160:         return self._max_write_batch_size
  161: 
  162:     @property
  163:     def min_wire_version(self) -> int:
  164:         return self._min_wire_version
  165: 
  166:     @property
  167:     def max_wire_version(self) -> int:
  168:         return self._max_wire_version
  169: 
  170:     @property
  171:     def set_version(self) -> Optional[int]:
  172:         return self._set_version
  173: 
  174:     @property
  175:     def election_id(self) -> Optional[ObjectId]:
  176:         return self._election_id
  177: 
  178:     @property
  179:     def cluster_time(self) -> Optional[ClusterTime]:
  180:         return self._cluster_time
  181: 
  182:     @property
  183:     def election_tuple(self) -> tuple[Optional[int], Optional[ObjectId]]:
  184:         warnings.warn(
  185:             "'election_tuple' is deprecated, use  'set_version' and 'election_id' instead",
  186:             DeprecationWarning,
  187:             stacklevel=2,
  188:         )
  189:         return self._set_version, self._election_id
  190: 
  191:     @property
  192:     def me(self) -> Optional[tuple[str, int]]:
  193:         return self._me
  194: 
  195:     @property
  196:     def logical_session_timeout_minutes(self) -> Optional[int]:
  197:         return self._ls_timeout_minutes
  198: 
  199:     @property
  200:     def last_write_date(self) -> Optional[float]:
  201:         return self._last_write_date
  202: 
  203:     @property
  204:     def last_update_time(self) -> float:
  205:         return self._last_update_time
  206: 
  207:     @property
  208:     def round_trip_time(self) -> Optional[float]:
  209:         """The current average latency or None."""
  210:         # This override is for unittesting only!
  211:         if self._address in self._host_to_round_trip_time:
  212:             return self._host_to_round_trip_time[self._address]
  213: 
  214:         return self._round_trip_time
  215: 
  216:     @property
  217:     def min_round_trip_time(self) -> float:
  218:         """The min latency from the most recent samples."""
  219:         return self._min_round_trip_time
  220: 
  221:     @property
  222:     def error(self) -> Optional[Exception]:
  223:         """The last error attempting to connect to the server, or None."""
  224:         return self._error
  225: 
  226:     @property
  227:     def is_writable(self) -> bool:
  228:         return self._is_writable
  229: 
  230:     @property
  231:     def is_readable(self) -> bool:
  232:         return self._is_readable
  233: 
  234:     @property
  235:     def mongos(self) -> bool:
  236:         return self._server_type == SERVER_TYPE.Mongos
  237: 
  238:     @property
  239:     def is_server_type_known(self) -> bool:
  240:         return self.server_type != SERVER_TYPE.Unknown
  241: 
  242:     @property
  243:     def retryable_writes_supported(self) -> bool:
  244:         """Checks if this server supports retryable writes."""
  245:         return (
  246:             self._server_type in (SERVER_TYPE.Mongos, SERVER_TYPE.RSPrimary)
  247:         ) or self._server_type == SERVER_TYPE.LoadBalancer
  248: 
  249:     @property
  250:     def retryable_reads_supported(self) -> bool:
  251:         """Checks if this server supports retryable writes."""
  252:         return self._max_wire_version >= 6
  253: 
  254:     @property
  255:     def topology_version(self) -> Optional[Mapping[str, Any]]:
  256:         return self._topology_version
  257: 
  258:     def to_unknown(self, error: Optional[Exception] = None) -> ServerDescription:
  259:         unknown = ServerDescription(self.address, error=error)
  260:         unknown._topology_version = self.topology_version
  261:         return unknown
  262: 
  263:     def __eq__(self, other: Any) -> bool:
  264:         if isinstance(other, ServerDescription):
  265:             return (
  266:                 (self._address == other.address)
  267:                 and (self._server_type == other.server_type)
  268:                 and (self._min_wire_version == other.min_wire_version)
  269:                 and (self._max_wire_version == other.max_wire_version)
  270:                 and (self._me == other.me)
  271:                 and (self._all_hosts == other.all_hosts)
  272:                 and (self._tags == other.tags)
  273:                 and (self._replica_set_name == other.replica_set_name)
  274:                 and (self._set_version == other.set_version)
  275:                 and (self._election_id == other.election_id)
  276:                 and (self._primary == other.primary)
  277:                 and (self._ls_timeout_minutes == other.logical_session_timeout_minutes)
  278:                 and (self._error == other.error)
  279:             )
  280: 
  281:         return NotImplemented
  282: 
  283:     def __ne__(self, other: Any) -> bool:
  284:         return not self == other
  285: 
  286:     def __repr__(self) -> str:
  287:         errmsg = ""
  288:         if self.error:
  289:             errmsg = f", error={self.error!r}"
  290:         return "<{} {} server_type: {}, rtt: {}{}>".format(
  291:             self.__class__.__name__,
  292:             self.address,
  293:             self.server_type_name,
  294:             self.round_trip_time,
  295:             errmsg,
  296:         )
  297: 
  298:     # For unittesting only. Use under no circumstances!
  299:     _host_to_round_trip_time: dict = {}
