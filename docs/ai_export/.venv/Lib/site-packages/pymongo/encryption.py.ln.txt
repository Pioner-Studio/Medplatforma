    1: # Copyright 2019-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Support for explicit client-side field level encryption."""
   16: from __future__ import annotations
   17: 
   18: import contextlib
   19: import enum
   20: import socket
   21: import uuid
   22: import weakref
   23: from copy import deepcopy
   24: from typing import (
   25:     TYPE_CHECKING,
   26:     Any,
   27:     Dict,
   28:     Generic,
   29:     Iterator,
   30:     Mapping,
   31:     MutableMapping,
   32:     Optional,
   33:     Sequence,
   34:     Union,
   35:     cast,
   36: )
   37: 
   38: try:
   39:     from pymongocrypt.auto_encrypter import AutoEncrypter  # type:ignore[import]
   40:     from pymongocrypt.errors import MongoCryptError  # type:ignore[import]
   41:     from pymongocrypt.explicit_encrypter import ExplicitEncrypter  # type:ignore[import]
   42:     from pymongocrypt.mongocrypt import MongoCryptOptions  # type:ignore[import]
   43:     from pymongocrypt.state_machine import MongoCryptCallback  # type:ignore[import]
   44: 
   45:     _HAVE_PYMONGOCRYPT = True
   46: except ImportError:
   47:     _HAVE_PYMONGOCRYPT = False
   48:     MongoCryptCallback = object
   49: 
   50: from bson import _dict_to_bson, decode, encode
   51: from bson.binary import STANDARD, UUID_SUBTYPE, Binary
   52: from bson.codec_options import CodecOptions
   53: from bson.errors import BSONError
   54: from bson.raw_bson import DEFAULT_RAW_BSON_OPTIONS, RawBSONDocument, _inflate_bson
   55: from pymongo import _csot
   56: from pymongo.collection import Collection
   57: from pymongo.common import CONNECT_TIMEOUT
   58: from pymongo.cursor import Cursor
   59: from pymongo.daemon import _spawn_daemon
   60: from pymongo.database import Database
   61: from pymongo.encryption_options import AutoEncryptionOpts, RangeOpts
   62: from pymongo.errors import (
   63:     ConfigurationError,
   64:     EncryptedCollectionError,
   65:     EncryptionError,
   66:     InvalidOperation,
   67:     PyMongoError,
   68:     ServerSelectionTimeoutError,
   69: )
   70: from pymongo.mongo_client import MongoClient
   71: from pymongo.network import BLOCKING_IO_ERRORS
   72: from pymongo.operations import UpdateOne
   73: from pymongo.pool import PoolOptions, _configured_socket, _raise_connection_failure
   74: from pymongo.read_concern import ReadConcern
   75: from pymongo.results import BulkWriteResult, DeleteResult
   76: from pymongo.ssl_support import get_ssl_context
   77: from pymongo.typings import _DocumentType, _DocumentTypeArg
   78: from pymongo.uri_parser import parse_host
   79: from pymongo.write_concern import WriteConcern
   80: 
   81: if TYPE_CHECKING:
   82:     from pymongocrypt.mongocrypt import MongoCryptKmsContext
   83: 
   84: _HTTPS_PORT = 443
   85: _KMS_CONNECT_TIMEOUT = CONNECT_TIMEOUT  # CDRIVER-3262 redefined this value to CONNECT_TIMEOUT
   86: _MONGOCRYPTD_TIMEOUT_MS = 10000
   87: 
   88: _DATA_KEY_OPTS: CodecOptions[dict[str, Any]] = CodecOptions(
   89:     document_class=Dict[str, Any], uuid_representation=STANDARD
   90: )
   91: # Use RawBSONDocument codec options to avoid needlessly decoding
   92: # documents from the key vault.
   93: _KEY_VAULT_OPTS = CodecOptions(document_class=RawBSONDocument)
   94: 
   95: 
   96: @contextlib.contextmanager
   97: def _wrap_encryption_errors() -> Iterator[None]:
   98:     """Context manager to wrap encryption related errors."""
   99:     try:
  100:         yield
  101:     except BSONError:
  102:         # BSON encoding/decoding errors are unrelated to encryption so
  103:         # we should propagate them unchanged.
  104:         raise
  105:     except Exception as exc:
  106:         raise EncryptionError(exc) from exc
  107: 
  108: 
  109: class _EncryptionIO(MongoCryptCallback):  # type: ignore[misc]
  110:     def __init__(
  111:         self,
  112:         client: Optional[MongoClient[_DocumentTypeArg]],
  113:         key_vault_coll: Collection[_DocumentTypeArg],
  114:         mongocryptd_client: Optional[MongoClient[_DocumentTypeArg]],
  115:         opts: AutoEncryptionOpts,
  116:     ):
  117:         """Internal class to perform I/O on behalf of pymongocrypt."""
  118:         self.client_ref: Any
  119:         # Use a weak ref to break reference cycle.
  120:         if client is not None:
  121:             self.client_ref = weakref.ref(client)
  122:         else:
  123:             self.client_ref = None
  124:         self.key_vault_coll: Optional[Collection[RawBSONDocument]] = cast(
  125:             Collection[RawBSONDocument],
  126:             key_vault_coll.with_options(
  127:                 codec_options=_KEY_VAULT_OPTS,
  128:                 read_concern=ReadConcern(level="majority"),
  129:                 write_concern=WriteConcern(w="majority"),
  130:             ),
  131:         )
  132:         self.mongocryptd_client = mongocryptd_client
  133:         self.opts = opts
  134:         self._spawned = False
  135: 
  136:     def kms_request(self, kms_context: MongoCryptKmsContext) -> None:
  137:         """Complete a KMS request.
  138: 
  139:         :param kms_context: A :class:`MongoCryptKmsContext`.
  140: 
  141:         :return: None
  142:         """
  143:         endpoint = kms_context.endpoint
  144:         message = kms_context.message
  145:         provider = kms_context.kms_provider
  146:         ctx = self.opts._kms_ssl_contexts.get(provider)
  147:         if ctx is None:
  148:             # Enable strict certificate verification, OCSP, match hostname, and
  149:             # SNI using the system default CA certificates.
  150:             ctx = get_ssl_context(
  151:                 None,  # certfile
  152:                 None,  # passphrase
  153:                 None,  # ca_certs
  154:                 None,  # crlfile
  155:                 False,  # allow_invalid_certificates
  156:                 False,  # allow_invalid_hostnames
  157:                 False,
  158:             )  # disable_ocsp_endpoint_check
  159:         # CSOT: set timeout for socket creation.
  160:         connect_timeout = max(_csot.clamp_remaining(_KMS_CONNECT_TIMEOUT), 0.001)
  161:         opts = PoolOptions(
  162:             connect_timeout=connect_timeout,
  163:             socket_timeout=connect_timeout,
  164:             ssl_context=ctx,
  165:         )
  166:         host, port = parse_host(endpoint, _HTTPS_PORT)
  167:         try:
  168:             conn = _configured_socket((host, port), opts)
  169:             try:
  170:                 conn.sendall(message)
  171:                 while kms_context.bytes_needed > 0:
  172:                     # CSOT: update timeout.
  173:                     conn.settimeout(max(_csot.clamp_remaining(_KMS_CONNECT_TIMEOUT), 0))
  174:                     data = conn.recv(kms_context.bytes_needed)
  175:                     if not data:
  176:                         raise OSError("KMS connection closed")
  177:                     kms_context.feed(data)
  178:             except BLOCKING_IO_ERRORS:
  179:                 raise socket.timeout("timed out") from None
  180:             finally:
  181:                 conn.close()
  182:         except (PyMongoError, MongoCryptError):
  183:             raise  # Propagate pymongo errors directly.
  184:         except Exception as error:
  185:             # Wrap I/O errors in PyMongo exceptions.
  186:             _raise_connection_failure((host, port), error)
  187: 
  188:     def collection_info(
  189:         self, database: Database[Mapping[str, Any]], filter: bytes
  190:     ) -> Optional[bytes]:
  191:         """Get the collection info for a namespace.
  192: 
  193:         The returned collection info is passed to libmongocrypt which reads
  194:         the JSON schema.
  195: 
  196:         :param database: The database on which to run listCollections.
  197:         :param filter: The filter to pass to listCollections.
  198: 
  199:         :return: The first document from the listCollections command response as BSON.
  200:         """
  201:         with self.client_ref()[database].list_collections(filter=RawBSONDocument(filter)) as cursor:
  202:             for doc in cursor:
  203:                 return _dict_to_bson(doc, False, _DATA_KEY_OPTS)
  204:             return None
  205: 
  206:     def spawn(self) -> None:
  207:         """Spawn mongocryptd.
  208: 
  209:         Note this method is thread safe; at most one mongocryptd will start
  210:         successfully.
  211:         """
  212:         self._spawned = True
  213:         args = [self.opts._mongocryptd_spawn_path or "mongocryptd"]
  214:         args.extend(self.opts._mongocryptd_spawn_args)
  215:         _spawn_daemon(args)
  216: 
  217:     def mark_command(self, database: str, cmd: bytes) -> bytes:
  218:         """Mark a command for encryption.
  219: 
  220:         :param database: The database on which to run this command.
  221:         :param cmd: The BSON command to run.
  222: 
  223:         :return: The marked command response from mongocryptd.
  224:         """
  225:         if not self._spawned and not self.opts._mongocryptd_bypass_spawn:
  226:             self.spawn()
  227:         # Database.command only supports mutable mappings so we need to decode
  228:         # the raw BSON command first.
  229:         inflated_cmd = _inflate_bson(cmd, DEFAULT_RAW_BSON_OPTIONS)
  230:         assert self.mongocryptd_client is not None
  231:         try:
  232:             res = self.mongocryptd_client[database].command(
  233:                 inflated_cmd, codec_options=DEFAULT_RAW_BSON_OPTIONS
  234:             )
  235:         except ServerSelectionTimeoutError:
  236:             if self.opts._mongocryptd_bypass_spawn:
  237:                 raise
  238:             self.spawn()
  239:             res = self.mongocryptd_client[database].command(
  240:                 inflated_cmd, codec_options=DEFAULT_RAW_BSON_OPTIONS
  241:             )
  242:         return res.raw
  243: 
  244:     def fetch_keys(self, filter: bytes) -> Iterator[bytes]:
  245:         """Yields one or more keys from the key vault.
  246: 
  247:         :param filter: The filter to pass to find.
  248: 
  249:         :return: A generator which yields the requested keys from the key vault.
  250:         """
  251:         assert self.key_vault_coll is not None
  252:         with self.key_vault_coll.find(RawBSONDocument(filter)) as cursor:
  253:             for key in cursor:
  254:                 yield key.raw
  255: 
  256:     def insert_data_key(self, data_key: bytes) -> Binary:
  257:         """Insert a data key into the key vault.
  258: 
  259:         :param data_key: The data key document to insert.
  260: 
  261:         :return: The _id of the inserted data key document.
  262:         """
  263:         raw_doc = RawBSONDocument(data_key, _KEY_VAULT_OPTS)
  264:         data_key_id = raw_doc.get("_id")
  265:         if not isinstance(data_key_id, Binary) or data_key_id.subtype != UUID_SUBTYPE:
  266:             raise TypeError("data_key _id must be Binary with a UUID subtype")
  267: 
  268:         assert self.key_vault_coll is not None
  269:         self.key_vault_coll.insert_one(raw_doc)
  270:         return data_key_id
  271: 
  272:     def bson_encode(self, doc: MutableMapping[str, Any]) -> bytes:
  273:         """Encode a document to BSON.
  274: 
  275:         A document can be any mapping type (like :class:`dict`).
  276: 
  277:         :param doc: mapping type representing a document
  278: 
  279:         :return: The encoded BSON bytes.
  280:         """
  281:         return encode(doc)
  282: 
  283:     def close(self) -> None:
  284:         """Release resources.
  285: 
  286:         Note it is not safe to call this method from __del__ or any GC hooks.
  287:         """
  288:         self.client_ref = None
  289:         self.key_vault_coll = None
  290:         if self.mongocryptd_client:
  291:             self.mongocryptd_client.close()
  292:             self.mongocryptd_client = None
  293: 
  294: 
  295: class RewrapManyDataKeyResult:
  296:     """Result object returned by a :meth:`~ClientEncryption.rewrap_many_data_key` operation.
  297: 
  298:     .. versionadded:: 4.2
  299:     """
  300: 
  301:     def __init__(self, bulk_write_result: Optional[BulkWriteResult] = None) -> None:
  302:         self._bulk_write_result = bulk_write_result
  303: 
  304:     @property
  305:     def bulk_write_result(self) -> Optional[BulkWriteResult]:
  306:         """The result of the bulk write operation used to update the key vault
  307:         collection with one or more rewrapped data keys. If
  308:         :meth:`~ClientEncryption.rewrap_many_data_key` does not find any matching keys to rewrap,
  309:         no bulk write operation will be executed and this field will be
  310:         ``None``.
  311:         """
  312:         return self._bulk_write_result
  313: 
  314:     def __repr__(self) -> str:
  315:         return f"{self.__class__.__name__}({self._bulk_write_result!r})"
  316: 
  317: 
  318: class _Encrypter:
  319:     """Encrypts and decrypts MongoDB commands.
  320: 
  321:     This class is used to support automatic encryption and decryption of
  322:     MongoDB commands.
  323:     """
  324: 
  325:     def __init__(self, client: MongoClient[_DocumentTypeArg], opts: AutoEncryptionOpts):
  326:         """Create a _Encrypter for a client.
  327: 
  328:         :param client: The encrypted MongoClient.
  329:         :param opts: The encrypted client's :class:`AutoEncryptionOpts`.
  330:         """
  331:         if opts._schema_map is None:
  332:             schema_map = None
  333:         else:
  334:             schema_map = _dict_to_bson(opts._schema_map, False, _DATA_KEY_OPTS)
  335: 
  336:         if opts._encrypted_fields_map is None:
  337:             encrypted_fields_map = None
  338:         else:
  339:             encrypted_fields_map = _dict_to_bson(opts._encrypted_fields_map, False, _DATA_KEY_OPTS)
  340:         self._bypass_auto_encryption = opts._bypass_auto_encryption
  341:         self._internal_client = None
  342: 
  343:         def _get_internal_client(
  344:             encrypter: _Encrypter, mongo_client: MongoClient[_DocumentTypeArg]
  345:         ) -> MongoClient[_DocumentTypeArg]:
  346:             if mongo_client.options.pool_options.max_pool_size is None:
  347:                 # Unlimited pool size, use the same client.
  348:                 return mongo_client
  349:             # Else - limited pool size, use an internal client.
  350:             if encrypter._internal_client is not None:
  351:                 return encrypter._internal_client
  352:             internal_client = mongo_client._duplicate(minPoolSize=0, auto_encryption_opts=None)
  353:             encrypter._internal_client = internal_client
  354:             return internal_client
  355: 
  356:         if opts._key_vault_client is not None:
  357:             key_vault_client = opts._key_vault_client
  358:         else:
  359:             key_vault_client = _get_internal_client(self, client)
  360: 
  361:         if opts._bypass_auto_encryption:
  362:             metadata_client = None
  363:         else:
  364:             metadata_client = _get_internal_client(self, client)
  365: 
  366:         db, coll = opts._key_vault_namespace.split(".", 1)
  367:         key_vault_coll = key_vault_client[db][coll]
  368: 
  369:         mongocryptd_client: MongoClient[Mapping[str, Any]] = MongoClient(
  370:             opts._mongocryptd_uri, connect=False, serverSelectionTimeoutMS=_MONGOCRYPTD_TIMEOUT_MS
  371:         )
  372: 
  373:         io_callbacks = _EncryptionIO(  # type:ignore[misc]
  374:             metadata_client, key_vault_coll, mongocryptd_client, opts
  375:         )
  376:         self._auto_encrypter = AutoEncrypter(
  377:             io_callbacks,
  378:             MongoCryptOptions(
  379:                 opts._kms_providers,
  380:                 schema_map,
  381:                 crypt_shared_lib_path=opts._crypt_shared_lib_path,
  382:                 crypt_shared_lib_required=opts._crypt_shared_lib_required,
  383:                 bypass_encryption=opts._bypass_auto_encryption,
  384:                 encrypted_fields_map=encrypted_fields_map,
  385:                 bypass_query_analysis=opts._bypass_query_analysis,
  386:             ),
  387:         )
  388:         self._closed = False
  389: 
  390:     def encrypt(
  391:         self, database: str, cmd: Mapping[str, Any], codec_options: CodecOptions[_DocumentTypeArg]
  392:     ) -> dict[str, Any]:
  393:         """Encrypt a MongoDB command.
  394: 
  395:         :param database: The database for this command.
  396:         :param cmd: A command document.
  397:         :param codec_options: The CodecOptions to use while encoding `cmd`.
  398: 
  399:         :return: The encrypted command to execute.
  400:         """
  401:         self._check_closed()
  402:         encoded_cmd = _dict_to_bson(cmd, False, codec_options)
  403:         with _wrap_encryption_errors():
  404:             encrypted_cmd = self._auto_encrypter.encrypt(database, encoded_cmd)
  405:             # TODO: PYTHON-1922 avoid decoding the encrypted_cmd.
  406:             return _inflate_bson(encrypted_cmd, DEFAULT_RAW_BSON_OPTIONS)
  407: 
  408:     def decrypt(self, response: bytes) -> Optional[bytes]:
  409:         """Decrypt a MongoDB command response.
  410: 
  411:         :param response: A MongoDB command response as BSON.
  412: 
  413:         :return: The decrypted command response.
  414:         """
  415:         self._check_closed()
  416:         with _wrap_encryption_errors():
  417:             return cast(bytes, self._auto_encrypter.decrypt(response))
  418: 
  419:     def _check_closed(self) -> None:
  420:         if self._closed:
  421:             raise InvalidOperation("Cannot use MongoClient after close")
  422: 
  423:     def close(self) -> None:
  424:         """Cleanup resources."""
  425:         self._closed = True
  426:         self._auto_encrypter.close()
  427:         if self._internal_client:
  428:             self._internal_client.close()
  429:             self._internal_client = None
  430: 
  431: 
  432: class Algorithm(str, enum.Enum):
  433:     """An enum that defines the supported encryption algorithms."""
  434: 
  435:     AEAD_AES_256_CBC_HMAC_SHA_512_Deterministic = "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic"
  436:     """AEAD_AES_256_CBC_HMAC_SHA_512_Deterministic."""
  437:     AEAD_AES_256_CBC_HMAC_SHA_512_Random = "AEAD_AES_256_CBC_HMAC_SHA_512-Random"
  438:     """AEAD_AES_256_CBC_HMAC_SHA_512_Random."""
  439:     INDEXED = "Indexed"
  440:     """Indexed.
  441: 
  442:     .. versionadded:: 4.2
  443:     """
  444:     UNINDEXED = "Unindexed"
  445:     """Unindexed.
  446: 
  447:     .. versionadded:: 4.2
  448:     """
  449:     RANGEPREVIEW = "RangePreview"
  450:     """RangePreview.
  451: 
  452:     .. note:: Support for Range queries is in beta.
  453:        Backwards-breaking changes may be made before the final release.
  454: 
  455:     .. versionadded:: 4.4
  456:     """
  457: 
  458: 
  459: class QueryType(str, enum.Enum):
  460:     """An enum that defines the supported values for explicit encryption query_type.
  461: 
  462:     .. versionadded:: 4.2
  463:     """
  464: 
  465:     EQUALITY = "equality"
  466:     """Used to encrypt a value for an equality query."""
  467: 
  468:     RANGEPREVIEW = "rangePreview"
  469:     """Used to encrypt a value for a range query.
  470: 
  471:     .. note:: Support for Range queries is in beta.
  472:        Backwards-breaking changes may be made before the final release.
  473: """
  474: 
  475: 
  476: class ClientEncryption(Generic[_DocumentType]):
  477:     """Explicit client-side field level encryption."""
  478: 
  479:     def __init__(
  480:         self,
  481:         kms_providers: Mapping[str, Any],
  482:         key_vault_namespace: str,
  483:         key_vault_client: MongoClient[_DocumentTypeArg],
  484:         codec_options: CodecOptions[_DocumentTypeArg],
  485:         kms_tls_options: Optional[Mapping[str, Any]] = None,
  486:     ) -> None:
  487:         """Explicit client-side field level encryption.
  488: 
  489:         The ClientEncryption class encapsulates explicit operations on a key
  490:         vault collection that cannot be done directly on a MongoClient. Similar
  491:         to configuring auto encryption on a MongoClient, it is constructed with
  492:         a MongoClient (to a MongoDB cluster containing the key vault
  493:         collection), KMS provider configuration, and keyVaultNamespace. It
  494:         provides an API for explicitly encrypting and decrypting values, and
  495:         creating data keys. It does not provide an API to query keys from the
  496:         key vault collection, as this can be done directly on the MongoClient.
  497: 
  498:         See :ref:`explicit-client-side-encryption` for an example.
  499: 
  500:         :param kms_providers: Map of KMS provider options. The `kms_providers`
  501:             map values differ by provider:
  502: 
  503:               - `aws`: Map with "accessKeyId" and "secretAccessKey" as strings.
  504:                 These are the AWS access key ID and AWS secret access key used
  505:                 to generate KMS messages. An optional "sessionToken" may be
  506:                 included to support temporary AWS credentials.
  507:               - `azure`: Map with "tenantId", "clientId", and "clientSecret" as
  508:                 strings. Additionally, "identityPlatformEndpoint" may also be
  509:                 specified as a string (defaults to 'login.microsoftonline.com').
  510:                 These are the Azure Active Directory credentials used to
  511:                 generate Azure Key Vault messages.
  512:               - `gcp`: Map with "email" as a string and "privateKey"
  513:                 as `bytes` or a base64 encoded string.
  514:                 Additionally, "endpoint" may also be specified as a string
  515:                 (defaults to 'oauth2.googleapis.com'). These are the
  516:                 credentials used to generate Google Cloud KMS messages.
  517:               - `kmip`: Map with "endpoint" as a host with required port.
  518:                 For example: ``{"endpoint": "example.com:443"}``.
  519:               - `local`: Map with "key" as `bytes` (96 bytes in length) or
  520:                 a base64 encoded string which decodes
  521:                 to 96 bytes. "key" is the master key used to encrypt/decrypt
  522:                 data keys. This key should be generated and stored as securely
  523:                 as possible.
  524: 
  525:             KMS providers may be specified with an optional name suffix
  526:             separated by a colon, for example "kmip:name" or "aws:name".
  527:             Named KMS providers do not support :ref:`CSFLE on-demand credentials`.
  528:         :param key_vault_namespace: The namespace for the key vault collection.
  529:             The key vault collection contains all data keys used for encryption
  530:             and decryption. Data keys are stored as documents in this MongoDB
  531:             collection. Data keys are protected with encryption by a KMS
  532:             provider.
  533:         :param key_vault_client: A MongoClient connected to a MongoDB cluster
  534:             containing the `key_vault_namespace` collection.
  535:         :param codec_options: An instance of
  536:             :class:`~bson.codec_options.CodecOptions` to use when encoding a
  537:             value for encryption and decoding the decrypted BSON value. This
  538:             should be the same CodecOptions instance configured on the
  539:             MongoClient, Database, or Collection used to access application
  540:             data.
  541:         :param kms_tls_options: A map of KMS provider names to TLS
  542:             options to use when creating secure connections to KMS providers.
  543:             Accepts the same TLS options as
  544:             :class:`pymongo.mongo_client.MongoClient`. For example, to
  545:             override the system default CA file::
  546: 
  547:               kms_tls_options={'kmip': {'tlsCAFile': certifi.where()}}
  548: 
  549:             Or to supply a client certificate::
  550: 
  551:               kms_tls_options={'kmip': {'tlsCertificateKeyFile': 'client.pem'}}
  552: 
  553:         .. versionchanged:: 4.0
  554:            Added the `kms_tls_options` parameter and the "kmip" KMS provider.
  555: 
  556:         .. versionadded:: 3.9
  557:         """
  558:         if not _HAVE_PYMONGOCRYPT:
  559:             raise ConfigurationError(
  560:                 "client-side field level encryption requires the pymongocrypt "
  561:                 "library: install a compatible version with: "
  562:                 "python -m pip install 'pymongo[encryption]'"
  563:             )
  564: 
  565:         if not isinstance(codec_options, CodecOptions):
  566:             raise TypeError("codec_options must be an instance of bson.codec_options.CodecOptions")
  567: 
  568:         self._kms_providers = kms_providers
  569:         self._key_vault_namespace = key_vault_namespace
  570:         self._key_vault_client = key_vault_client
  571:         self._codec_options = codec_options
  572: 
  573:         db, coll = key_vault_namespace.split(".", 1)
  574:         key_vault_coll = key_vault_client[db][coll]
  575: 
  576:         opts = AutoEncryptionOpts(
  577:             kms_providers, key_vault_namespace, kms_tls_options=kms_tls_options
  578:         )
  579:         self._io_callbacks: Optional[_EncryptionIO] = _EncryptionIO(
  580:             None, key_vault_coll, None, opts
  581:         )
  582:         self._encryption = ExplicitEncrypter(
  583:             self._io_callbacks, MongoCryptOptions(kms_providers, None)
  584:         )
  585:         # Use the same key vault collection as the callback.
  586:         assert self._io_callbacks.key_vault_coll is not None
  587:         self._key_vault_coll = self._io_callbacks.key_vault_coll
  588: 
  589:     def create_encrypted_collection(
  590:         self,
  591:         database: Database[_DocumentTypeArg],
  592:         name: str,
  593:         encrypted_fields: Mapping[str, Any],
  594:         kms_provider: Optional[str] = None,
  595:         master_key: Optional[Mapping[str, Any]] = None,
  596:         **kwargs: Any,
  597:     ) -> tuple[Collection[_DocumentTypeArg], Mapping[str, Any]]:
  598:         """Create a collection with encryptedFields.
  599: 
  600:         .. warning::
  601:             This function does not update the encryptedFieldsMap in the client's
  602:             AutoEncryptionOpts, thus the user must create a new client after calling this function with
  603:             the encryptedFields returned.
  604: 
  605:         Normally collection creation is automatic. This method should
  606:         only be used to specify options on
  607:         creation. :class:`~pymongo.errors.EncryptionError` will be
  608:         raised if the collection already exists.
  609: 
  610:         :param name: the name of the collection to create
  611:         :param encrypted_fields: Document that describes the encrypted fields for
  612:             Queryable Encryption. The "keyId" may be set to ``None`` to auto-generate the data keys.  For example:
  613: 
  614:             .. code-block: python
  615: 
  616:               {
  617:                 "escCollection": "enxcol_.encryptedCollection.esc",
  618:                 "ecocCollection": "enxcol_.encryptedCollection.ecoc",
  619:                 "fields": [
  620:                     {
  621:                         "path": "firstName",
  622:                         "keyId": Binary.from_uuid(UUID('00000000-0000-0000-0000-000000000000')),
  623:                         "bsonType": "string",
  624:                         "queries": {"queryType": "equality"}
  625:                     },
  626:                     {
  627:                         "path": "ssn",
  628:                         "keyId": Binary.from_uuid(UUID('04104104-1041-0410-4104-104104104104')),
  629:                         "bsonType": "string"
  630:                     }
  631:                   ]
  632:               }
  633: 
  634:           :param kms_provider: the KMS provider to be used
  635:           :param master_key: Identifies a KMS-specific key used to encrypt the
  636:             new data key. If the kmsProvider is "local" the `master_key` is
  637:             not applicable and may be omitted.
  638:           :param kwargs: additional keyword arguments are the same as "create_collection".
  639: 
  640:         All optional `create collection command`_ parameters should be passed
  641:         as keyword arguments to this method.
  642:         See the documentation for :meth:`~pymongo.database.Database.create_collection` for all valid options.
  643: 
  644:         :raises: - :class:`~pymongo.errors.EncryptedCollectionError`: When either data-key creation or creating the collection fails.
  645: 
  646:         .. versionadded:: 4.4
  647: 
  648:         .. _create collection command:
  649:             https://mongodb.com/docs/manual/reference/command/create
  650: 
  651:         """
  652:         encrypted_fields = deepcopy(encrypted_fields)
  653:         for i, field in enumerate(encrypted_fields["fields"]):
  654:             if isinstance(field, dict) and field.get("keyId") is None:
  655:                 try:
  656:                     encrypted_fields["fields"][i]["keyId"] = self.create_data_key(
  657:                         kms_provider=kms_provider,  # type:ignore[arg-type]
  658:                         master_key=master_key,
  659:                     )
  660:                 except EncryptionError as exc:
  661:                     raise EncryptedCollectionError(exc, encrypted_fields) from exc
  662:         kwargs["encryptedFields"] = encrypted_fields
  663:         kwargs["check_exists"] = False
  664:         try:
  665:             return (
  666:                 database.create_collection(name=name, **kwargs),
  667:                 encrypted_fields,
  668:             )
  669:         except Exception as exc:
  670:             raise EncryptedCollectionError(exc, encrypted_fields) from exc
  671: 
  672:     def create_data_key(
  673:         self,
  674:         kms_provider: str,
  675:         master_key: Optional[Mapping[str, Any]] = None,
  676:         key_alt_names: Optional[Sequence[str]] = None,
  677:         key_material: Optional[bytes] = None,
  678:     ) -> Binary:
  679:         """Create and insert a new data key into the key vault collection.
  680: 
  681:         :param kms_provider: The KMS provider to use. Supported values are
  682:             "aws", "azure", "gcp", "kmip", "local", or a named provider like
  683:             "kmip:name".
  684:         :param master_key: Identifies a KMS-specific key used to encrypt the
  685:             new data key. If the kmsProvider is "local" the `master_key` is
  686:             not applicable and may be omitted.
  687: 
  688:             If the `kms_provider` type is "aws" it is required and has the
  689:             following fields::
  690: 
  691:               - `region` (string): Required. The AWS region, e.g. "us-east-1".
  692:               - `key` (string): Required. The Amazon Resource Name (ARN) to
  693:                  the AWS customer.
  694:               - `endpoint` (string): Optional. An alternate host to send KMS
  695:                 requests to. May include port number, e.g.
  696:                 "kms.us-east-1.amazonaws.com:443".
  697: 
  698:             If the `kms_provider` type is "azure" it is required and has the
  699:             following fields::
  700: 
  701:               - `keyVaultEndpoint` (string): Required. Host with optional
  702:                  port, e.g. "example.vault.azure.net".
  703:               - `keyName` (string): Required. Key name in the key vault.
  704:               - `keyVersion` (string): Optional. Version of the key to use.
  705: 
  706:             If the `kms_provider` type is "gcp" it is required and has the
  707:             following fields::
  708: 
  709:               - `projectId` (string): Required. The Google cloud project ID.
  710:               - `location` (string): Required. The GCP location, e.g. "us-east1".
  711:               - `keyRing` (string): Required. Name of the key ring that contains
  712:                 the key to use.
  713:               - `keyName` (string): Required. Name of the key to use.
  714:               - `keyVersion` (string): Optional. Version of the key to use.
  715:               - `endpoint` (string): Optional. Host with optional port.
  716:                 Defaults to "cloudkms.googleapis.com".
  717: 
  718:             If the `kms_provider` type is "kmip" it is optional and has the
  719:             following fields::
  720: 
  721:               - `keyId` (string): Optional. `keyId` is the KMIP Unique
  722:                 Identifier to a 96 byte KMIP Secret Data managed object. If
  723:                 keyId is omitted, the driver creates a random 96 byte KMIP
  724:                 Secret Data managed object.
  725:               - `endpoint` (string): Optional. Host with optional
  726:                  port, e.g. "example.vault.azure.net:".
  727: 
  728:         :param key_alt_names: An optional list of string alternate
  729:             names used to reference a key. If a key is created with alternate
  730:             names, then encryption may refer to the key by the unique alternate
  731:             name instead of by ``key_id``. The following example shows creating
  732:             and referring to a data key by alternate name::
  733: 
  734:               client_encryption.create_data_key("local", key_alt_names=["name1"])
  735:               # reference the key with the alternate name
  736:               client_encryption.encrypt("457-55-5462", key_alt_name="name1",
  737:                                         algorithm=Algorithm.AEAD_AES_256_CBC_HMAC_SHA_512_Random)
  738:         :param key_material: Sets the custom key material to be used
  739:             by the data key for encryption and decryption.
  740: 
  741:         :return: The ``_id`` of the created data key document as a
  742:           :class:`~bson.binary.Binary` with subtype
  743:           :data:`~bson.binary.UUID_SUBTYPE`.
  744: 
  745:         .. versionchanged:: 4.2
  746:            Added the `key_material` parameter.
  747:         """
  748:         self._check_closed()
  749:         with _wrap_encryption_errors():
  750:             return cast(
  751:                 Binary,
  752:                 self._encryption.create_data_key(
  753:                     kms_provider,
  754:                     master_key=master_key,
  755:                     key_alt_names=key_alt_names,
  756:                     key_material=key_material,
  757:                 ),
  758:             )
  759: 
  760:     def _encrypt_helper(
  761:         self,
  762:         value: Any,
  763:         algorithm: str,
  764:         key_id: Optional[Union[Binary, uuid.UUID]] = None,
  765:         key_alt_name: Optional[str] = None,
  766:         query_type: Optional[str] = None,
  767:         contention_factor: Optional[int] = None,
  768:         range_opts: Optional[RangeOpts] = None,
  769:         is_expression: bool = False,
  770:     ) -> Any:
  771:         self._check_closed()
  772:         if isinstance(key_id, uuid.UUID):
  773:             key_id = Binary.from_uuid(key_id)
  774:         if key_id is not None and not (
  775:             isinstance(key_id, Binary) and key_id.subtype == UUID_SUBTYPE
  776:         ):
  777:             raise TypeError("key_id must be a bson.binary.Binary with subtype 4")
  778: 
  779:         doc = encode(
  780:             {"v": value},
  781:             codec_options=self._codec_options,
  782:         )
  783:         range_opts_bytes = None
  784:         if range_opts:
  785:             range_opts_bytes = encode(
  786:                 range_opts.document,
  787:                 codec_options=self._codec_options,
  788:             )
  789:         with _wrap_encryption_errors():
  790:             encrypted_doc = self._encryption.encrypt(
  791:                 value=doc,
  792:                 algorithm=algorithm,
  793:                 key_id=key_id,
  794:                 key_alt_name=key_alt_name,
  795:                 query_type=query_type,
  796:                 contention_factor=contention_factor,
  797:                 range_opts=range_opts_bytes,
  798:                 is_expression=is_expression,
  799:             )
  800:             return decode(encrypted_doc)["v"]
  801: 
  802:     def encrypt(
  803:         self,
  804:         value: Any,
  805:         algorithm: str,
  806:         key_id: Optional[Union[Binary, uuid.UUID]] = None,
  807:         key_alt_name: Optional[str] = None,
  808:         query_type: Optional[str] = None,
  809:         contention_factor: Optional[int] = None,
  810:         range_opts: Optional[RangeOpts] = None,
  811:     ) -> Binary:
  812:         """Encrypt a BSON value with a given key and algorithm.
  813: 
  814:         Note that exactly one of ``key_id`` or  ``key_alt_name`` must be
  815:         provided.
  816: 
  817:         :param value: The BSON value to encrypt.
  818:         :param algorithm` (string): The encryption algorithm to use. See
  819:             :class:`Algorithm` for some valid options.
  820:         :param key_id: Identifies a data key by ``_id`` which must be a
  821:             :class:`~bson.binary.Binary` with subtype 4 (
  822:             :attr:`~bson.binary.UUID_SUBTYPE`).
  823:         :param key_alt_name: Identifies a key vault document by 'keyAltName'.
  824:         :param query_type` (str): The query type to execute. See :class:`QueryType` for valid options.
  825:         :param contention_factor` (int): The contention factor to use
  826:             when the algorithm is :attr:`Algorithm.INDEXED`.  An integer value
  827:             *must* be given when the :attr:`Algorithm.INDEXED` algorithm is
  828:             used.
  829:         :param range_opts: Experimental only, not intended for public use.
  830: 
  831:         :return: The encrypted value, a :class:`~bson.binary.Binary` with subtype 6.
  832: 
  833:         .. versionchanged:: 4.7
  834:            ``key_id`` can now be passed in as a :class:`uuid.UUID`.
  835: 
  836:         .. versionchanged:: 4.2
  837:            Added the `query_type` and `contention_factor` parameters.
  838:         """
  839:         return cast(
  840:             Binary,
  841:             self._encrypt_helper(
  842:                 value=value,
  843:                 algorithm=algorithm,
  844:                 key_id=key_id,
  845:                 key_alt_name=key_alt_name,
  846:                 query_type=query_type,
  847:                 contention_factor=contention_factor,
  848:                 range_opts=range_opts,
  849:                 is_expression=False,
  850:             ),
  851:         )
  852: 
  853:     def encrypt_expression(
  854:         self,
  855:         expression: Mapping[str, Any],
  856:         algorithm: str,
  857:         key_id: Optional[Union[Binary, uuid.UUID]] = None,
  858:         key_alt_name: Optional[str] = None,
  859:         query_type: Optional[str] = None,
  860:         contention_factor: Optional[int] = None,
  861:         range_opts: Optional[RangeOpts] = None,
  862:     ) -> RawBSONDocument:
  863:         """Encrypt a BSON expression with a given key and algorithm.
  864: 
  865:         Note that exactly one of ``key_id`` or  ``key_alt_name`` must be
  866:         provided.
  867: 
  868:         :param expression: The BSON aggregate or match expression to encrypt.
  869:         :param algorithm` (string): The encryption algorithm to use. See
  870:             :class:`Algorithm` for some valid options.
  871:         :param key_id: Identifies a data key by ``_id`` which must be a
  872:             :class:`~bson.binary.Binary` with subtype 4 (
  873:             :attr:`~bson.binary.UUID_SUBTYPE`).
  874:         :param key_alt_name: Identifies a key vault document by 'keyAltName'.
  875:         :param query_type` (str): The query type to execute. See
  876:             :class:`QueryType` for valid options.
  877:         :param contention_factor` (int): The contention factor to use
  878:             when the algorithm is :attr:`Algorithm.INDEXED`.  An integer value
  879:             *must* be given when the :attr:`Algorithm.INDEXED` algorithm is
  880:             used.
  881:         :param range_opts: Experimental only, not intended for public use.
  882: 
  883:         :return: The encrypted expression, a :class:`~bson.RawBSONDocument`.
  884: 
  885:         .. versionchanged:: 4.7
  886:            ``key_id`` can now be passed in as a :class:`uuid.UUID`.
  887: 
  888:         .. versionadded:: 4.4
  889:         """
  890:         return cast(
  891:             RawBSONDocument,
  892:             self._encrypt_helper(
  893:                 value=expression,
  894:                 algorithm=algorithm,
  895:                 key_id=key_id,
  896:                 key_alt_name=key_alt_name,
  897:                 query_type=query_type,
  898:                 contention_factor=contention_factor,
  899:                 range_opts=range_opts,
  900:                 is_expression=True,
  901:             ),
  902:         )
  903: 
  904:     def decrypt(self, value: Binary) -> Any:
  905:         """Decrypt an encrypted value.
  906: 
  907:         :param value` (Binary): The encrypted value, a
  908:             :class:`~bson.binary.Binary` with subtype 6.
  909: 
  910:         :return: The decrypted BSON value.
  911:         """
  912:         self._check_closed()
  913:         if not (isinstance(value, Binary) and value.subtype == 6):
  914:             raise TypeError("value to decrypt must be a bson.binary.Binary with subtype 6")
  915: 
  916:         with _wrap_encryption_errors():
  917:             doc = encode({"v": value})
  918:             decrypted_doc = self._encryption.decrypt(doc)
  919:             return decode(decrypted_doc, codec_options=self._codec_options)["v"]
  920: 
  921:     def get_key(self, id: Binary) -> Optional[RawBSONDocument]:
  922:         """Get a data key by id.
  923: 
  924:         :param id` (Binary): The UUID of a key a which must be a
  925:             :class:`~bson.binary.Binary` with subtype 4 (
  926:             :attr:`~bson.binary.UUID_SUBTYPE`).
  927: 
  928:         :return: The key document.
  929: 
  930:         .. versionadded:: 4.2
  931:         """
  932:         self._check_closed()
  933:         assert self._key_vault_coll is not None
  934:         return self._key_vault_coll.find_one({"_id": id})
  935: 
  936:     def get_keys(self) -> Cursor[RawBSONDocument]:
  937:         """Get all of the data keys.
  938: 
  939:         :return: An instance of :class:`~pymongo.cursor.Cursor` over the data key
  940:           documents.
  941: 
  942:         .. versionadded:: 4.2
  943:         """
  944:         self._check_closed()
  945:         assert self._key_vault_coll is not None
  946:         return self._key_vault_coll.find({})
  947: 
  948:     def delete_key(self, id: Binary) -> DeleteResult:
  949:         """Delete a key document in the key vault collection that has the given ``key_id``.
  950: 
  951:         :param id` (Binary): The UUID of a key a which must be a
  952:             :class:`~bson.binary.Binary` with subtype 4 (
  953:             :attr:`~bson.binary.UUID_SUBTYPE`).
  954: 
  955:         :return: The delete result.
  956: 
  957:         .. versionadded:: 4.2
  958:         """
  959:         self._check_closed()
  960:         assert self._key_vault_coll is not None
  961:         return self._key_vault_coll.delete_one({"_id": id})
  962: 
  963:     def add_key_alt_name(self, id: Binary, key_alt_name: str) -> Any:
  964:         """Add ``key_alt_name`` to the set of alternate names in the key document with UUID ``key_id``.
  965: 
  966:         :param `id`: The UUID of a key a which must be a
  967:             :class:`~bson.binary.Binary` with subtype 4 (
  968:             :attr:`~bson.binary.UUID_SUBTYPE`).
  969:         :param `key_alt_name`: The key alternate name to add.
  970: 
  971:         :return: The previous version of the key document.
  972: 
  973:         .. versionadded:: 4.2
  974:         """
  975:         self._check_closed()
  976:         update = {"$addToSet": {"keyAltNames": key_alt_name}}
  977:         assert self._key_vault_coll is not None
  978:         return self._key_vault_coll.find_one_and_update({"_id": id}, update)
  979: 
  980:     def get_key_by_alt_name(self, key_alt_name: str) -> Optional[RawBSONDocument]:
  981:         """Get a key document in the key vault collection that has the given ``key_alt_name``.
  982: 
  983:         :param key_alt_name: (str): The key alternate name of the key to get.
  984: 
  985:         :return: The key document.
  986: 
  987:         .. versionadded:: 4.2
  988:         """
  989:         self._check_closed()
  990:         assert self._key_vault_coll is not None
  991:         return self._key_vault_coll.find_one({"keyAltNames": key_alt_name})
  992: 
  993:     def remove_key_alt_name(self, id: Binary, key_alt_name: str) -> Optional[RawBSONDocument]:
  994:         """Remove ``key_alt_name`` from the set of keyAltNames in the key document with UUID ``id``.
  995: 
  996:         Also removes the ``keyAltNames`` field from the key document if it would otherwise be empty.
  997: 
  998:         :param `id`: The UUID of a key a which must be a
  999:             :class:`~bson.binary.Binary` with subtype 4 (
 1000:             :attr:`~bson.binary.UUID_SUBTYPE`).
 1001:         :param `key_alt_name`: The key alternate name to remove.
 1002: 
 1003:         :return: Returns the previous version of the key document.
 1004: 
 1005:         .. versionadded:: 4.2
 1006:         """
 1007:         self._check_closed()
 1008:         pipeline = [
 1009:             {
 1010:                 "$set": {
 1011:                     "keyAltNames": {
 1012:                         "$cond": [
 1013:                             {"$eq": ["$keyAltNames", [key_alt_name]]},
 1014:                             "$$REMOVE",
 1015:                             {
 1016:                                 "$filter": {
 1017:                                     "input": "$keyAltNames",
 1018:                                     "cond": {"$ne": ["$$this", key_alt_name]},
 1019:                                 }
 1020:                             },
 1021:                         ]
 1022:                     }
 1023:                 }
 1024:             }
 1025:         ]
 1026:         assert self._key_vault_coll is not None
 1027:         return self._key_vault_coll.find_one_and_update({"_id": id}, pipeline)
 1028: 
 1029:     def rewrap_many_data_key(
 1030:         self,
 1031:         filter: Mapping[str, Any],
 1032:         provider: Optional[str] = None,
 1033:         master_key: Optional[Mapping[str, Any]] = None,
 1034:     ) -> RewrapManyDataKeyResult:
 1035:         """Decrypts and encrypts all matching data keys in the key vault with a possibly new `master_key` value.
 1036: 
 1037:         :param filter: A document used to filter the data keys.
 1038:         :param provider: The new KMS provider to use to encrypt the data keys,
 1039:             or ``None`` to use the current KMS provider(s).
 1040:         :param `master_key`: The master key fields corresponding to the new KMS
 1041:             provider when ``provider`` is not ``None``.
 1042: 
 1043:         :return: A :class:`RewrapManyDataKeyResult`.
 1044: 
 1045:         This method allows you to re-encrypt all of your data-keys with a new CMK, or master key.
 1046:         Note that this does *not* require re-encrypting any of the data in your encrypted collections,
 1047:         but rather refreshes the key that protects the keys that encrypt the data:
 1048: 
 1049:         .. code-block:: python
 1050: 
 1051:            client_encryption.rewrap_many_data_key(
 1052:                filter={"keyAltNames": "optional filter for which keys you want to update"},
 1053:                master_key={
 1054:                    "provider": "azure",  # replace with your cloud provider
 1055:                    "master_key": {
 1056:                        # put the rest of your master_key options here
 1057:                        "key": "<your new key>"
 1058:                    },
 1059:                },
 1060:            )
 1061: 
 1062:         .. versionadded:: 4.2
 1063:         """
 1064:         if master_key is not None and provider is None:
 1065:             raise ConfigurationError("A provider must be given if a master_key is given")
 1066:         self._check_closed()
 1067:         with _wrap_encryption_errors():
 1068:             raw_result = self._encryption.rewrap_many_data_key(filter, provider, master_key)
 1069:             if raw_result is None:
 1070:                 return RewrapManyDataKeyResult()
 1071: 
 1072:         raw_doc = RawBSONDocument(raw_result, DEFAULT_RAW_BSON_OPTIONS)
 1073:         replacements = []
 1074:         for key in raw_doc["v"]:
 1075:             update_model = {
 1076:                 "$set": {"keyMaterial": key["keyMaterial"], "masterKey": key["masterKey"]},
 1077:                 "$currentDate": {"updateDate": True},
 1078:             }
 1079:             op = UpdateOne({"_id": key["_id"]}, update_model)
 1080:             replacements.append(op)
 1081:         if not replacements:
 1082:             return RewrapManyDataKeyResult()
 1083:         assert self._key_vault_coll is not None
 1084:         result = self._key_vault_coll.bulk_write(replacements)
 1085:         return RewrapManyDataKeyResult(result)
 1086: 
 1087:     def __enter__(self) -> ClientEncryption[_DocumentType]:
 1088:         return self
 1089: 
 1090:     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
 1091:         self.close()
 1092: 
 1093:     def _check_closed(self) -> None:
 1094:         if self._encryption is None:
 1095:             raise InvalidOperation("Cannot use closed ClientEncryption")
 1096: 
 1097:     def close(self) -> None:
 1098:         """Release resources.
 1099: 
 1100:         Note that using this class in a with-statement will automatically call
 1101:         :meth:`close`::
 1102: 
 1103:             with ClientEncryption(...) as client_encryption:
 1104:                 encrypted = client_encryption.encrypt(value, ...)
 1105:                 decrypted = client_encryption.decrypt(encrypted)
 1106: 
 1107:         """
 1108:         if self._io_callbacks:
 1109:             self._io_callbacks.close()
 1110:             self._encryption.close()
 1111:             self._io_callbacks = None
 1112:             self._encryption = None
