    1: # Copyright 2019-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Support for spawning a daemon process.
   16: 
   17: PyMongo only attempts to spawn the mongocryptd daemon process when automatic
   18: client-side field level encryption is enabled. See
   19: :ref:`automatic-client-side-encryption` for more info.
   20: """
   21: from __future__ import annotations
   22: 
   23: import os
   24: import subprocess
   25: import sys
   26: import warnings
   27: from typing import Any, Optional, Sequence
   28: 
   29: # The maximum amount of time to wait for the intermediate subprocess.
   30: _WAIT_TIMEOUT = 10
   31: _THIS_FILE = os.path.realpath(__file__)
   32: 
   33: 
   34: def _popen_wait(popen: subprocess.Popen[Any], timeout: Optional[float]) -> Optional[int]:
   35:     """Implement wait timeout support for Python 3."""
   36:     try:
   37:         return popen.wait(timeout=timeout)
   38:     except subprocess.TimeoutExpired:
   39:         # Silence TimeoutExpired errors.
   40:         return None
   41: 
   42: 
   43: def _silence_resource_warning(popen: Optional[subprocess.Popen[Any]]) -> None:
   44:     """Silence Popen's ResourceWarning.
   45: 
   46:     Note this should only be used if the process was created as a daemon.
   47:     """
   48:     # Set the returncode to avoid this warning when popen is garbage collected:
   49:     # "ResourceWarning: subprocess XXX is still running".
   50:     # See https://bugs.python.org/issue38890 and
   51:     # https://bugs.python.org/issue26741.
   52:     # popen is None when mongocryptd spawning fails
   53:     if popen is not None:
   54:         popen.returncode = 0
   55: 
   56: 
   57: if sys.platform == "win32":
   58:     # On Windows we spawn the daemon process simply by using DETACHED_PROCESS.
   59:     _DETACHED_PROCESS = getattr(subprocess, "DETACHED_PROCESS", 0x00000008)
   60: 
   61:     def _spawn_daemon(args: Sequence[str]) -> None:
   62:         """Spawn a daemon process (Windows)."""
   63:         try:
   64:             with open(os.devnull, "r+b") as devnull:
   65:                 popen = subprocess.Popen(
   66:                     args,  # noqa: S603
   67:                     creationflags=_DETACHED_PROCESS,
   68:                     stdin=devnull,
   69:                     stderr=devnull,
   70:                     stdout=devnull,
   71:                 )
   72:                 _silence_resource_warning(popen)
   73:         except FileNotFoundError as exc:
   74:             warnings.warn(
   75:                 f"Failed to start {args[0]}: is it on your $PATH?\nOriginal exception: {exc}",
   76:                 RuntimeWarning,
   77:                 stacklevel=2,
   78:             )
   79: 
   80: else:
   81:     # On Unix we spawn the daemon process with a double Popen.
   82:     # 1) The first Popen runs this file as a Python script using the current
   83:     #    interpreter.
   84:     # 2) The script then decouples itself and performs the second Popen to
   85:     #    spawn the daemon process.
   86:     # 3) The original process waits up to 10 seconds for the script to exit.
   87:     #
   88:     # Note that we do not call fork() directly because we want this procedure
   89:     # to be safe to call from any thread. Using Popen instead of fork also
   90:     # avoids triggering the application's os.register_at_fork() callbacks when
   91:     # we spawn the mongocryptd daemon process.
   92:     def _spawn(args: Sequence[str]) -> Optional[subprocess.Popen[Any]]:
   93:         """Spawn the process and silence stdout/stderr."""
   94:         try:
   95:             with open(os.devnull, "r+b") as devnull:
   96:                 return subprocess.Popen(
   97:                     args,  # noqa: S603
   98:                     close_fds=True,
   99:                     stdin=devnull,
  100:                     stderr=devnull,
  101:                     stdout=devnull,
  102:                 )
  103:         except FileNotFoundError as exc:
  104:             warnings.warn(
  105:                 f"Failed to start {args[0]}: is it on your $PATH?\nOriginal exception: {exc}",
  106:                 RuntimeWarning,
  107:                 stacklevel=2,
  108:             )
  109:         return None
  110: 
  111:     def _spawn_daemon_double_popen(args: Sequence[str]) -> None:
  112:         """Spawn a daemon process using a double subprocess.Popen."""
  113:         spawner_args = [sys.executable, _THIS_FILE]
  114:         spawner_args.extend(args)
  115:         temp_proc = subprocess.Popen(spawner_args, close_fds=True)  # noqa: S603
  116:         # Reap the intermediate child process to avoid creating zombie
  117:         # processes.
  118:         _popen_wait(temp_proc, _WAIT_TIMEOUT)
  119: 
  120:     def _spawn_daemon(args: Sequence[str]) -> None:
  121:         """Spawn a daemon process (Unix)."""
  122:         # "If Python is unable to retrieve the real path to its executable,
  123:         # sys.executable will be an empty string or None".
  124:         if sys.executable:
  125:             _spawn_daemon_double_popen(args)
  126:         else:
  127:             # Fallback to spawn a non-daemon process without silencing the
  128:             # resource warning. We do not use fork here because it is not
  129:             # safe to call from a thread on all systems.
  130:             # Unfortunately, this means that:
  131:             # 1) If the parent application is killed via Ctrl-C, the
  132:             #    non-daemon process will also be killed.
  133:             # 2) Each non-daemon process will hang around as a zombie process
  134:             #    until the main application exits.
  135:             _spawn(args)
  136: 
  137:     if __name__ == "__main__":
  138:         # Attempt to start a new session to decouple from the parent.
  139:         if hasattr(os, "setsid"):
  140:             try:
  141:                 os.setsid()
  142:             except OSError:
  143:                 pass
  144: 
  145:         # We are performing a double fork (Popen) to spawn the process as a
  146:         # daemon so it is safe to ignore the resource warning.
  147:         _silence_resource_warning(_spawn(sys.argv[1:]))
  148:         os._exit(0)
