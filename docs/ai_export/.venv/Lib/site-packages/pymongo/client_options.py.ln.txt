    1: # Copyright 2014-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Tools to parse mongo client options."""
   16: from __future__ import annotations
   17: 
   18: from typing import TYPE_CHECKING, Any, Mapping, Optional, Sequence, cast
   19: 
   20: from bson.codec_options import _parse_codec_options
   21: from pymongo import common
   22: from pymongo.compression_support import CompressionSettings
   23: from pymongo.errors import ConfigurationError
   24: from pymongo.monitoring import _EventListener, _EventListeners
   25: from pymongo.pool import PoolOptions
   26: from pymongo.read_concern import ReadConcern
   27: from pymongo.read_preferences import (
   28:     _ServerMode,
   29:     make_read_preference,
   30:     read_pref_mode_from_name,
   31: )
   32: from pymongo.server_selectors import any_server_selector
   33: from pymongo.ssl_support import get_ssl_context
   34: from pymongo.write_concern import WriteConcern, validate_boolean
   35: 
   36: if TYPE_CHECKING:
   37:     from bson.codec_options import CodecOptions
   38:     from pymongo.auth import MongoCredential
   39:     from pymongo.encryption_options import AutoEncryptionOpts
   40:     from pymongo.pyopenssl_context import SSLContext
   41:     from pymongo.topology_description import _ServerSelector
   42: 
   43: 
   44: def _parse_credentials(
   45:     username: str, password: str, database: Optional[str], options: Mapping[str, Any]
   46: ) -> Optional[MongoCredential]:
   47:     """Parse authentication credentials."""
   48:     mechanism = options.get("authmechanism", "DEFAULT" if username else None)
   49:     source = options.get("authsource")
   50:     if username or mechanism:
   51:         from pymongo.auth import _build_credentials_tuple
   52: 
   53:         return _build_credentials_tuple(mechanism, source, username, password, options, database)
   54:     return None
   55: 
   56: 
   57: def _parse_read_preference(options: Mapping[str, Any]) -> _ServerMode:
   58:     """Parse read preference options."""
   59:     if "read_preference" in options:
   60:         return options["read_preference"]
   61: 
   62:     name = options.get("readpreference", "primary")
   63:     mode = read_pref_mode_from_name(name)
   64:     tags = options.get("readpreferencetags")
   65:     max_staleness = options.get("maxstalenessseconds", -1)
   66:     return make_read_preference(mode, tags, max_staleness)
   67: 
   68: 
   69: def _parse_write_concern(options: Mapping[str, Any]) -> WriteConcern:
   70:     """Parse write concern options."""
   71:     concern = options.get("w")
   72:     wtimeout = options.get("wtimeoutms")
   73:     j = options.get("journal")
   74:     fsync = options.get("fsync")
   75:     return WriteConcern(concern, wtimeout, j, fsync)
   76: 
   77: 
   78: def _parse_read_concern(options: Mapping[str, Any]) -> ReadConcern:
   79:     """Parse read concern options."""
   80:     concern = options.get("readconcernlevel")
   81:     return ReadConcern(concern)
   82: 
   83: 
   84: def _parse_ssl_options(options: Mapping[str, Any]) -> tuple[Optional[SSLContext], bool]:
   85:     """Parse ssl options."""
   86:     use_tls = options.get("tls")
   87:     if use_tls is not None:
   88:         validate_boolean("tls", use_tls)
   89: 
   90:     certfile = options.get("tlscertificatekeyfile")
   91:     passphrase = options.get("tlscertificatekeyfilepassword")
   92:     ca_certs = options.get("tlscafile")
   93:     crlfile = options.get("tlscrlfile")
   94:     allow_invalid_certificates = options.get("tlsallowinvalidcertificates", False)
   95:     allow_invalid_hostnames = options.get("tlsallowinvalidhostnames", False)
   96:     disable_ocsp_endpoint_check = options.get("tlsdisableocspendpointcheck", False)
   97: 
   98:     enabled_tls_opts = []
   99:     for opt in (
  100:         "tlscertificatekeyfile",
  101:         "tlscertificatekeyfilepassword",
  102:         "tlscafile",
  103:         "tlscrlfile",
  104:     ):
  105:         # Any non-null value of these options implies tls=True.
  106:         if opt in options and options[opt]:
  107:             enabled_tls_opts.append(opt)
  108:     for opt in (
  109:         "tlsallowinvalidcertificates",
  110:         "tlsallowinvalidhostnames",
  111:         "tlsdisableocspendpointcheck",
  112:     ):
  113:         # A value of False for these options implies tls=True.
  114:         if opt in options and not options[opt]:
  115:             enabled_tls_opts.append(opt)
  116: 
  117:     if enabled_tls_opts:
  118:         if use_tls is None:
  119:             # Implicitly enable TLS when one of the tls* options is set.
  120:             use_tls = True
  121:         elif not use_tls:
  122:             # Error since tls is explicitly disabled but a tls option is set.
  123:             raise ConfigurationError(
  124:                 "TLS has not been enabled but the "
  125:                 "following tls parameters have been set: "
  126:                 "%s. Please set `tls=True` or remove." % ", ".join(enabled_tls_opts)
  127:             )
  128: 
  129:     if use_tls:
  130:         ctx = get_ssl_context(
  131:             certfile,
  132:             passphrase,
  133:             ca_certs,
  134:             crlfile,
  135:             allow_invalid_certificates,
  136:             allow_invalid_hostnames,
  137:             disable_ocsp_endpoint_check,
  138:         )
  139:         return ctx, allow_invalid_hostnames
  140:     return None, allow_invalid_hostnames
  141: 
  142: 
  143: def _parse_pool_options(
  144:     username: str, password: str, database: Optional[str], options: Mapping[str, Any]
  145: ) -> PoolOptions:
  146:     """Parse connection pool options."""
  147:     credentials = _parse_credentials(username, password, database, options)
  148:     max_pool_size = options.get("maxpoolsize", common.MAX_POOL_SIZE)
  149:     min_pool_size = options.get("minpoolsize", common.MIN_POOL_SIZE)
  150:     max_idle_time_seconds = options.get("maxidletimems", common.MAX_IDLE_TIME_SEC)
  151:     if max_pool_size is not None and min_pool_size > max_pool_size:
  152:         raise ValueError("minPoolSize must be smaller or equal to maxPoolSize")
  153:     connect_timeout = options.get("connecttimeoutms", common.CONNECT_TIMEOUT)
  154:     socket_timeout = options.get("sockettimeoutms")
  155:     wait_queue_timeout = options.get("waitqueuetimeoutms", common.WAIT_QUEUE_TIMEOUT)
  156:     event_listeners = cast(Optional[Sequence[_EventListener]], options.get("event_listeners"))
  157:     appname = options.get("appname")
  158:     driver = options.get("driver")
  159:     server_api = options.get("server_api")
  160:     compression_settings = CompressionSettings(
  161:         options.get("compressors", []), options.get("zlibcompressionlevel", -1)
  162:     )
  163:     ssl_context, tls_allow_invalid_hostnames = _parse_ssl_options(options)
  164:     load_balanced = options.get("loadbalanced")
  165:     max_connecting = options.get("maxconnecting", common.MAX_CONNECTING)
  166:     return PoolOptions(
  167:         max_pool_size,
  168:         min_pool_size,
  169:         max_idle_time_seconds,
  170:         connect_timeout,
  171:         socket_timeout,
  172:         wait_queue_timeout,
  173:         ssl_context,
  174:         tls_allow_invalid_hostnames,
  175:         _EventListeners(event_listeners),
  176:         appname,
  177:         driver,
  178:         compression_settings,
  179:         max_connecting=max_connecting,
  180:         server_api=server_api,
  181:         load_balanced=load_balanced,
  182:         credentials=credentials,
  183:     )
  184: 
  185: 
  186: class ClientOptions:
  187:     """Read only configuration options for a MongoClient.
  188: 
  189:     Should not be instantiated directly by application developers. Access
  190:     a client's options via :attr:`pymongo.mongo_client.MongoClient.options`
  191:     instead.
  192:     """
  193: 
  194:     def __init__(
  195:         self, username: str, password: str, database: Optional[str], options: Mapping[str, Any]
  196:     ):
  197:         self.__options = options
  198:         self.__codec_options = _parse_codec_options(options)
  199:         self.__direct_connection = options.get("directconnection")
  200:         self.__local_threshold_ms = options.get("localthresholdms", common.LOCAL_THRESHOLD_MS)
  201:         # self.__server_selection_timeout is in seconds. Must use full name for
  202:         # common.SERVER_SELECTION_TIMEOUT because it is set directly by tests.
  203:         self.__server_selection_timeout = options.get(
  204:             "serverselectiontimeoutms", common.SERVER_SELECTION_TIMEOUT
  205:         )
  206:         self.__pool_options = _parse_pool_options(username, password, database, options)
  207:         self.__read_preference = _parse_read_preference(options)
  208:         self.__replica_set_name = options.get("replicaset")
  209:         self.__write_concern = _parse_write_concern(options)
  210:         self.__read_concern = _parse_read_concern(options)
  211:         self.__connect = options.get("connect")
  212:         self.__heartbeat_frequency = options.get("heartbeatfrequencyms", common.HEARTBEAT_FREQUENCY)
  213:         self.__retry_writes = options.get("retrywrites", common.RETRY_WRITES)
  214:         self.__retry_reads = options.get("retryreads", common.RETRY_READS)
  215:         self.__server_selector = options.get("server_selector", any_server_selector)
  216:         self.__auto_encryption_opts = options.get("auto_encryption_opts")
  217:         self.__load_balanced = options.get("loadbalanced")
  218:         self.__timeout = options.get("timeoutms")
  219:         self.__server_monitoring_mode = options.get(
  220:             "servermonitoringmode", common.SERVER_MONITORING_MODE
  221:         )
  222: 
  223:     @property
  224:     def _options(self) -> Mapping[str, Any]:
  225:         """The original options used to create this ClientOptions."""
  226:         return self.__options
  227: 
  228:     @property
  229:     def connect(self) -> Optional[bool]:
  230:         """Whether to begin discovering a MongoDB topology automatically."""
  231:         return self.__connect
  232: 
  233:     @property
  234:     def codec_options(self) -> CodecOptions:
  235:         """A :class:`~bson.codec_options.CodecOptions` instance."""
  236:         return self.__codec_options
  237: 
  238:     @property
  239:     def direct_connection(self) -> Optional[bool]:
  240:         """Whether to connect to the deployment in 'Single' topology."""
  241:         return self.__direct_connection
  242: 
  243:     @property
  244:     def local_threshold_ms(self) -> int:
  245:         """The local threshold for this instance."""
  246:         return self.__local_threshold_ms
  247: 
  248:     @property
  249:     def server_selection_timeout(self) -> int:
  250:         """The server selection timeout for this instance in seconds."""
  251:         return self.__server_selection_timeout
  252: 
  253:     @property
  254:     def server_selector(self) -> _ServerSelector:
  255:         return self.__server_selector
  256: 
  257:     @property
  258:     def heartbeat_frequency(self) -> int:
  259:         """The monitoring frequency in seconds."""
  260:         return self.__heartbeat_frequency
  261: 
  262:     @property
  263:     def pool_options(self) -> PoolOptions:
  264:         """A :class:`~pymongo.pool.PoolOptions` instance."""
  265:         return self.__pool_options
  266: 
  267:     @property
  268:     def read_preference(self) -> _ServerMode:
  269:         """A read preference instance."""
  270:         return self.__read_preference
  271: 
  272:     @property
  273:     def replica_set_name(self) -> Optional[str]:
  274:         """Replica set name or None."""
  275:         return self.__replica_set_name
  276: 
  277:     @property
  278:     def write_concern(self) -> WriteConcern:
  279:         """A :class:`~pymongo.write_concern.WriteConcern` instance."""
  280:         return self.__write_concern
  281: 
  282:     @property
  283:     def read_concern(self) -> ReadConcern:
  284:         """A :class:`~pymongo.read_concern.ReadConcern` instance."""
  285:         return self.__read_concern
  286: 
  287:     @property
  288:     def timeout(self) -> Optional[float]:
  289:         """The configured timeoutMS converted to seconds, or None.
  290: 
  291:         .. versionadded:: 4.2
  292:         """
  293:         return self.__timeout
  294: 
  295:     @property
  296:     def retry_writes(self) -> bool:
  297:         """If this instance should retry supported write operations."""
  298:         return self.__retry_writes
  299: 
  300:     @property
  301:     def retry_reads(self) -> bool:
  302:         """If this instance should retry supported read operations."""
  303:         return self.__retry_reads
  304: 
  305:     @property
  306:     def auto_encryption_opts(self) -> Optional[AutoEncryptionOpts]:
  307:         """A :class:`~pymongo.encryption.AutoEncryptionOpts` or None."""
  308:         return self.__auto_encryption_opts
  309: 
  310:     @property
  311:     def load_balanced(self) -> Optional[bool]:
  312:         """True if the client was configured to connect to a load balancer."""
  313:         return self.__load_balanced
  314: 
  315:     @property
  316:     def event_listeners(self) -> list[_EventListeners]:
  317:         """The event listeners registered for this client.
  318: 
  319:         See :mod:`~pymongo.monitoring` for details.
  320: 
  321:         .. versionadded:: 4.0
  322:         """
  323:         assert self.__pool_options._event_listeners is not None
  324:         return self.__pool_options._event_listeners.event_listeners()
  325: 
  326:     @property
  327:     def server_monitoring_mode(self) -> str:
  328:         """The configured serverMonitoringMode option.
  329: 
  330:         .. versionadded:: 4.5
  331:         """
  332:         return self.__server_monitoring_mode
