    1: # Copyright 2011-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: 
   16: """Tools to parse and validate a MongoDB URI."""
   17: from __future__ import annotations
   18: 
   19: import re
   20: import sys
   21: import warnings
   22: from typing import (
   23:     TYPE_CHECKING,
   24:     Any,
   25:     Mapping,
   26:     MutableMapping,
   27:     Optional,
   28:     Sized,
   29:     Union,
   30:     cast,
   31: )
   32: from urllib.parse import unquote_plus
   33: 
   34: from pymongo.client_options import _parse_ssl_options
   35: from pymongo.common import (
   36:     INTERNAL_URI_OPTION_NAME_MAP,
   37:     SRV_SERVICE_NAME,
   38:     URI_OPTIONS_DEPRECATION_MAP,
   39:     _CaseInsensitiveDictionary,
   40:     get_validated_options,
   41: )
   42: from pymongo.errors import ConfigurationError, InvalidURI
   43: from pymongo.srv_resolver import _have_dnspython, _SrvResolver
   44: from pymongo.typings import _Address
   45: 
   46: if TYPE_CHECKING:
   47:     from pymongo.pyopenssl_context import SSLContext
   48: 
   49: SCHEME = "mongodb://"
   50: SCHEME_LEN = len(SCHEME)
   51: SRV_SCHEME = "mongodb+srv://"
   52: SRV_SCHEME_LEN = len(SRV_SCHEME)
   53: DEFAULT_PORT = 27017
   54: 
   55: 
   56: def _unquoted_percent(s: str) -> bool:
   57:     """Check for unescaped percent signs.
   58: 
   59:     :param s: A string. `s` can have things like '%25', '%2525',
   60:            and '%E2%85%A8' but cannot have unquoted percent like '%foo'.
   61:     """
   62:     for i in range(len(s)):
   63:         if s[i] == "%":
   64:             sub = s[i : i + 3]
   65:             # If unquoting yields the same string this means there was an
   66:             # unquoted %.
   67:             if unquote_plus(sub) == sub:
   68:                 return True
   69:     return False
   70: 
   71: 
   72: def parse_userinfo(userinfo: str) -> tuple[str, str]:
   73:     """Validates the format of user information in a MongoDB URI.
   74:     Reserved characters that are gen-delimiters (":", "/", "?", "#", "[",
   75:     "]", "@") as per RFC 3986 must be escaped.
   76: 
   77:     Returns a 2-tuple containing the unescaped username followed
   78:     by the unescaped password.
   79: 
   80:     :param userinfo: A string of the form <username>:<password>
   81:     """
   82:     if "@" in userinfo or userinfo.count(":") > 1 or _unquoted_percent(userinfo):
   83:         raise InvalidURI(
   84:             "Username and password must be escaped according to "
   85:             "RFC 3986, use urllib.parse.quote_plus"
   86:         )
   87: 
   88:     user, _, passwd = userinfo.partition(":")
   89:     # No password is expected with GSSAPI authentication.
   90:     if not user:
   91:         raise InvalidURI("The empty string is not valid username.")
   92: 
   93:     return unquote_plus(user), unquote_plus(passwd)
   94: 
   95: 
   96: def parse_ipv6_literal_host(
   97:     entity: str, default_port: Optional[int]
   98: ) -> tuple[str, Optional[Union[str, int]]]:
   99:     """Validates an IPv6 literal host:port string.
  100: 
  101:     Returns a 2-tuple of IPv6 literal followed by port where
  102:     port is default_port if it wasn't specified in entity.
  103: 
  104:     :param entity: A string that represents an IPv6 literal enclosed
  105:                     in braces (e.g. '[::1]' or '[::1]:27017').
  106:     :param default_port: The port number to use when one wasn't
  107:                           specified in entity.
  108:     """
  109:     if entity.find("]") == -1:
  110:         raise ValueError(
  111:             "an IPv6 address literal must be enclosed in '[' and ']' according to RFC 2732."
  112:         )
  113:     i = entity.find("]:")
  114:     if i == -1:
  115:         return entity[1:-1], default_port
  116:     return entity[1:i], entity[i + 2 :]
  117: 
  118: 
  119: def parse_host(entity: str, default_port: Optional[int] = DEFAULT_PORT) -> _Address:
  120:     """Validates a host string
  121: 
  122:     Returns a 2-tuple of host followed by port where port is default_port
  123:     if it wasn't specified in the string.
  124: 
  125:     :param entity: A host or host:port string where host could be a
  126:                     hostname or IP address.
  127:     :param default_port: The port number to use when one wasn't
  128:                           specified in entity.
  129:     """
  130:     host = entity
  131:     port: Optional[Union[str, int]] = default_port
  132:     if entity[0] == "[":
  133:         host, port = parse_ipv6_literal_host(entity, default_port)
  134:     elif entity.endswith(".sock"):
  135:         return entity, default_port
  136:     elif entity.find(":") != -1:
  137:         if entity.count(":") > 1:
  138:             raise ValueError(
  139:                 "Reserved characters such as ':' must be "
  140:                 "escaped according RFC 2396. An IPv6 "
  141:                 "address literal must be enclosed in '[' "
  142:                 "and ']' according to RFC 2732."
  143:             )
  144:         host, port = host.split(":", 1)
  145:     if isinstance(port, str):
  146:         if not port.isdigit() or int(port) > 65535 or int(port) <= 0:
  147:             raise ValueError(f"Port must be an integer between 0 and 65535: {port!r}")
  148:         port = int(port)
  149: 
  150:     # Normalize hostname to lowercase, since DNS is case-insensitive:
  151:     # http://tools.ietf.org/html/rfc4343
  152:     # This prevents useless rediscovery if "foo.com" is in the seed list but
  153:     # "FOO.com" is in the hello response.
  154:     return host.lower(), port
  155: 
  156: 
  157: # Options whose values are implicitly determined by tlsInsecure.
  158: _IMPLICIT_TLSINSECURE_OPTS = {
  159:     "tlsallowinvalidcertificates",
  160:     "tlsallowinvalidhostnames",
  161:     "tlsdisableocspendpointcheck",
  162: }
  163: 
  164: 
  165: def _parse_options(opts: str, delim: Optional[str]) -> _CaseInsensitiveDictionary:
  166:     """Helper method for split_options which creates the options dict.
  167:     Also handles the creation of a list for the URI tag_sets/
  168:     readpreferencetags portion, and the use of a unicode options string.
  169:     """
  170:     options = _CaseInsensitiveDictionary()
  171:     for uriopt in opts.split(delim):
  172:         key, value = uriopt.split("=")
  173:         if key.lower() == "readpreferencetags":
  174:             options.setdefault(key, []).append(value)
  175:         else:
  176:             if key in options:
  177:                 warnings.warn(f"Duplicate URI option '{key}'.", stacklevel=2)
  178:             if key.lower() == "authmechanismproperties":
  179:                 val = value
  180:             else:
  181:                 val = unquote_plus(value)
  182:             options[key] = val
  183: 
  184:     return options
  185: 
  186: 
  187: def _handle_security_options(options: _CaseInsensitiveDictionary) -> _CaseInsensitiveDictionary:
  188:     """Raise appropriate errors when conflicting TLS options are present in
  189:     the options dictionary.
  190: 
  191:     :param options: Instance of _CaseInsensitiveDictionary containing
  192:           MongoDB URI options.
  193:     """
  194:     # Implicitly defined options must not be explicitly specified.
  195:     tlsinsecure = options.get("tlsinsecure")
  196:     if tlsinsecure is not None:
  197:         for opt in _IMPLICIT_TLSINSECURE_OPTS:
  198:             if opt in options:
  199:                 err_msg = "URI options %s and %s cannot be specified simultaneously."
  200:                 raise InvalidURI(
  201:                     err_msg % (options.cased_key("tlsinsecure"), options.cased_key(opt))
  202:                 )
  203: 
  204:     # Handle co-occurence of OCSP & tlsAllowInvalidCertificates options.
  205:     tlsallowinvalidcerts = options.get("tlsallowinvalidcertificates")
  206:     if tlsallowinvalidcerts is not None:
  207:         if "tlsdisableocspendpointcheck" in options:
  208:             err_msg = "URI options %s and %s cannot be specified simultaneously."
  209:             raise InvalidURI(
  210:                 err_msg
  211:                 % ("tlsallowinvalidcertificates", options.cased_key("tlsdisableocspendpointcheck"))
  212:             )
  213:         if tlsallowinvalidcerts is True:
  214:             options["tlsdisableocspendpointcheck"] = True
  215: 
  216:     # Handle co-occurence of CRL and OCSP-related options.
  217:     tlscrlfile = options.get("tlscrlfile")
  218:     if tlscrlfile is not None:
  219:         for opt in ("tlsinsecure", "tlsallowinvalidcertificates", "tlsdisableocspendpointcheck"):
  220:             if options.get(opt) is True:
  221:                 err_msg = "URI option %s=True cannot be specified when CRL checking is enabled."
  222:                 raise InvalidURI(err_msg % (opt,))
  223: 
  224:     if "ssl" in options and "tls" in options:
  225: 
  226:         def truth_value(val: Any) -> Any:
  227:             if val in ("true", "false"):
  228:                 return val == "true"
  229:             if isinstance(val, bool):
  230:                 return val
  231:             return val
  232: 
  233:         if truth_value(options.get("ssl")) != truth_value(options.get("tls")):
  234:             err_msg = "Can not specify conflicting values for URI options %s and %s."
  235:             raise InvalidURI(err_msg % (options.cased_key("ssl"), options.cased_key("tls")))
  236: 
  237:     return options
  238: 
  239: 
  240: def _handle_option_deprecations(options: _CaseInsensitiveDictionary) -> _CaseInsensitiveDictionary:
  241:     """Issue appropriate warnings when deprecated options are present in the
  242:     options dictionary. Removes deprecated option key, value pairs if the
  243:     options dictionary is found to also have the renamed option.
  244: 
  245:     :param options: Instance of _CaseInsensitiveDictionary containing
  246:           MongoDB URI options.
  247:     """
  248:     for optname in list(options):
  249:         if optname in URI_OPTIONS_DEPRECATION_MAP:
  250:             mode, message = URI_OPTIONS_DEPRECATION_MAP[optname]
  251:             if mode == "renamed":
  252:                 newoptname = message
  253:                 if newoptname in options:
  254:                     warn_msg = "Deprecated option '%s' ignored in favor of '%s'."
  255:                     warnings.warn(
  256:                         warn_msg % (options.cased_key(optname), options.cased_key(newoptname)),
  257:                         DeprecationWarning,
  258:                         stacklevel=2,
  259:                     )
  260:                     options.pop(optname)
  261:                     continue
  262:                 warn_msg = "Option '%s' is deprecated, use '%s' instead."
  263:                 warnings.warn(
  264:                     warn_msg % (options.cased_key(optname), newoptname),
  265:                     DeprecationWarning,
  266:                     stacklevel=2,
  267:                 )
  268:             elif mode == "removed":
  269:                 warn_msg = "Option '%s' is deprecated. %s."
  270:                 warnings.warn(
  271:                     warn_msg % (options.cased_key(optname), message),
  272:                     DeprecationWarning,
  273:                     stacklevel=2,
  274:                 )
  275: 
  276:     return options
  277: 
  278: 
  279: def _normalize_options(options: _CaseInsensitiveDictionary) -> _CaseInsensitiveDictionary:
  280:     """Normalizes option names in the options dictionary by converting them to
  281:     their internally-used names.
  282: 
  283:     :param options: Instance of _CaseInsensitiveDictionary containing
  284:           MongoDB URI options.
  285:     """
  286:     # Expand the tlsInsecure option.
  287:     tlsinsecure = options.get("tlsinsecure")
  288:     if tlsinsecure is not None:
  289:         for opt in _IMPLICIT_TLSINSECURE_OPTS:
  290:             # Implicit options are logically the same as tlsInsecure.
  291:             options[opt] = tlsinsecure
  292: 
  293:     for optname in list(options):
  294:         intname = INTERNAL_URI_OPTION_NAME_MAP.get(optname, None)
  295:         if intname is not None:
  296:             options[intname] = options.pop(optname)
  297: 
  298:     return options
  299: 
  300: 
  301: def validate_options(opts: Mapping[str, Any], warn: bool = False) -> MutableMapping[str, Any]:
  302:     """Validates and normalizes options passed in a MongoDB URI.
  303: 
  304:     Returns a new dictionary of validated and normalized options. If warn is
  305:     False then errors will be thrown for invalid options, otherwise they will
  306:     be ignored and a warning will be issued.
  307: 
  308:     :param opts: A dict of MongoDB URI options.
  309:     :param warn: If ``True`` then warnings will be logged and
  310:           invalid options will be ignored. Otherwise invalid options will
  311:           cause errors.
  312:     """
  313:     return get_validated_options(opts, warn)
  314: 
  315: 
  316: def split_options(
  317:     opts: str, validate: bool = True, warn: bool = False, normalize: bool = True
  318: ) -> MutableMapping[str, Any]:
  319:     """Takes the options portion of a MongoDB URI, validates each option
  320:     and returns the options in a dictionary.
  321: 
  322:     :param opt: A string representing MongoDB URI options.
  323:     :param validate: If ``True`` (the default), validate and normalize all
  324:           options.
  325:     :param warn: If ``False`` (the default), suppress all warnings raised
  326:           during validation of options.
  327:     :param normalize: If ``True`` (the default), renames all options to their
  328:           internally-used names.
  329:     """
  330:     and_idx = opts.find("&")
  331:     semi_idx = opts.find(";")
  332:     try:
  333:         if and_idx >= 0 and semi_idx >= 0:
  334:             raise InvalidURI("Can not mix '&' and ';' for option separators.")
  335:         elif and_idx >= 0:
  336:             options = _parse_options(opts, "&")
  337:         elif semi_idx >= 0:
  338:             options = _parse_options(opts, ";")
  339:         elif opts.find("=") != -1:
  340:             options = _parse_options(opts, None)
  341:         else:
  342:             raise ValueError
  343:     except ValueError:
  344:         raise InvalidURI("MongoDB URI options are key=value pairs.") from None
  345: 
  346:     options = _handle_security_options(options)
  347: 
  348:     options = _handle_option_deprecations(options)
  349: 
  350:     if normalize:
  351:         options = _normalize_options(options)
  352: 
  353:     if validate:
  354:         options = cast(_CaseInsensitiveDictionary, validate_options(options, warn))
  355:         if options.get("authsource") == "":
  356:             raise InvalidURI("the authSource database cannot be an empty string")
  357: 
  358:     return options
  359: 
  360: 
  361: def split_hosts(hosts: str, default_port: Optional[int] = DEFAULT_PORT) -> list[_Address]:
  362:     """Takes a string of the form host1[:port],host2[:port]... and
  363:     splits it into (host, port) tuples. If [:port] isn't present the
  364:     default_port is used.
  365: 
  366:     Returns a set of 2-tuples containing the host name (or IP) followed by
  367:     port number.
  368: 
  369:     :param hosts: A string of the form host1[:port],host2[:port],...
  370:     :param default_port: The port number to use when one wasn't specified
  371:           for a host.
  372:     """
  373:     nodes = []
  374:     for entity in hosts.split(","):
  375:         if not entity:
  376:             raise ConfigurationError("Empty host (or extra comma in host list).")
  377:         port = default_port
  378:         # Unix socket entities don't have ports
  379:         if entity.endswith(".sock"):
  380:             port = None
  381:         nodes.append(parse_host(entity, port))
  382:     return nodes
  383: 
  384: 
  385: # Prohibited characters in database name. DB names also can't have ".", but for
  386: # backward-compat we allow "db.collection" in URI.
  387: _BAD_DB_CHARS = re.compile("[" + re.escape(r'/ "$') + "]")
  388: 
  389: _ALLOWED_TXT_OPTS = frozenset(
  390:     ["authsource", "authSource", "replicaset", "replicaSet", "loadbalanced", "loadBalanced"]
  391: )
  392: 
  393: 
  394: def _check_options(nodes: Sized, options: Mapping[str, Any]) -> None:
  395:     # Ensure directConnection was not True if there are multiple seeds.
  396:     if len(nodes) > 1 and options.get("directconnection"):
  397:         raise ConfigurationError("Cannot specify multiple hosts with directConnection=true")
  398: 
  399:     if options.get("loadbalanced"):
  400:         if len(nodes) > 1:
  401:             raise ConfigurationError("Cannot specify multiple hosts with loadBalanced=true")
  402:         if options.get("directconnection"):
  403:             raise ConfigurationError("Cannot specify directConnection=true with loadBalanced=true")
  404:         if options.get("replicaset"):
  405:             raise ConfigurationError("Cannot specify replicaSet with loadBalanced=true")
  406: 
  407: 
  408: def parse_uri(
  409:     uri: str,
  410:     default_port: Optional[int] = DEFAULT_PORT,
  411:     validate: bool = True,
  412:     warn: bool = False,
  413:     normalize: bool = True,
  414:     connect_timeout: Optional[float] = None,
  415:     srv_service_name: Optional[str] = None,
  416:     srv_max_hosts: Optional[int] = None,
  417: ) -> dict[str, Any]:
  418:     """Parse and validate a MongoDB URI.
  419: 
  420:     Returns a dict of the form::
  421: 
  422:         {
  423:             'nodelist': <list of (host, port) tuples>,
  424:             'username': <username> or None,
  425:             'password': <password> or None,
  426:             'database': <database name> or None,
  427:             'collection': <collection name> or None,
  428:             'options': <dict of MongoDB URI options>,
  429:             'fqdn': <fqdn of the MongoDB+SRV URI> or None
  430:         }
  431: 
  432:     If the URI scheme is "mongodb+srv://" DNS SRV and TXT lookups will be done
  433:     to build nodelist and options.
  434: 
  435:     :param uri: The MongoDB URI to parse.
  436:     :param default_port: The port number to use when one wasn't specified
  437:           for a host in the URI.
  438:     :param validate: If ``True`` (the default), validate and
  439:           normalize all options. Default: ``True``.
  440:     :param warn: When validating, if ``True`` then will warn
  441:           the user then ignore any invalid options or values. If ``False``,
  442:           validation will error when options are unsupported or values are
  443:           invalid. Default: ``False``.
  444:     :param normalize: If ``True``, convert names of URI options
  445:           to their internally-used names. Default: ``True``.
  446:     :param connect_timeout: The maximum time in milliseconds to
  447:           wait for a response from the DNS server.
  448:     :param srv_service_name: A custom SRV service name
  449: 
  450:     .. versionchanged:: 4.6
  451:        The delimiting slash (``/``) between hosts and connection options is now optional.
  452:        For example, "mongodb://example.com?tls=true" is now a valid URI.
  453: 
  454:     .. versionchanged:: 4.0
  455:        To better follow RFC 3986, unquoted percent signs ("%") are no longer
  456:        supported.
  457: 
  458:     .. versionchanged:: 3.9
  459:         Added the ``normalize`` parameter.
  460: 
  461:     .. versionchanged:: 3.6
  462:         Added support for mongodb+srv:// URIs.
  463: 
  464:     .. versionchanged:: 3.5
  465:         Return the original value of the ``readPreference`` MongoDB URI option
  466:         instead of the validated read preference mode.
  467: 
  468:     .. versionchanged:: 3.1
  469:         ``warn`` added so invalid options can be ignored.
  470:     """
  471:     if uri.startswith(SCHEME):
  472:         is_srv = False
  473:         scheme_free = uri[SCHEME_LEN:]
  474:     elif uri.startswith(SRV_SCHEME):
  475:         if not _have_dnspython():
  476:             python_path = sys.executable or "python"
  477:             raise ConfigurationError(
  478:                 'The "dnspython" module must be '
  479:                 "installed to use mongodb+srv:// URIs. "
  480:                 "To fix this error install pymongo again:\n "
  481:                 "%s -m pip install pymongo>=4.3" % (python_path)
  482:             )
  483:         is_srv = True
  484:         scheme_free = uri[SRV_SCHEME_LEN:]
  485:     else:
  486:         raise InvalidURI(f"Invalid URI scheme: URI must begin with '{SCHEME}' or '{SRV_SCHEME}'")
  487: 
  488:     if not scheme_free:
  489:         raise InvalidURI("Must provide at least one hostname or IP.")
  490: 
  491:     user = None
  492:     passwd = None
  493:     dbase = None
  494:     collection = None
  495:     options = _CaseInsensitiveDictionary()
  496: 
  497:     host_plus_db_part, _, opts = scheme_free.partition("?")
  498:     if "/" in host_plus_db_part:
  499:         host_part, _, dbase = host_plus_db_part.partition("/")
  500:     else:
  501:         host_part = host_plus_db_part
  502: 
  503:     if dbase:
  504:         dbase = unquote_plus(dbase)
  505:         if "." in dbase:
  506:             dbase, collection = dbase.split(".", 1)
  507:         if _BAD_DB_CHARS.search(dbase):
  508:             raise InvalidURI('Bad database name "%s"' % dbase)
  509:     else:
  510:         dbase = None
  511: 
  512:     if opts:
  513:         options.update(split_options(opts, validate, warn, normalize))
  514:     if srv_service_name is None:
  515:         srv_service_name = options.get("srvServiceName", SRV_SERVICE_NAME)
  516:     if "@" in host_part:
  517:         userinfo, _, hosts = host_part.rpartition("@")
  518:         user, passwd = parse_userinfo(userinfo)
  519:     else:
  520:         hosts = host_part
  521: 
  522:     if "/" in hosts:
  523:         raise InvalidURI("Any '/' in a unix domain socket must be percent-encoded: %s" % host_part)
  524: 
  525:     hosts = unquote_plus(hosts)
  526:     fqdn = None
  527:     srv_max_hosts = srv_max_hosts or options.get("srvMaxHosts")
  528:     if is_srv:
  529:         if options.get("directConnection"):
  530:             raise ConfigurationError(f"Cannot specify directConnection=true with {SRV_SCHEME} URIs")
  531:         nodes = split_hosts(hosts, default_port=None)
  532:         if len(nodes) != 1:
  533:             raise InvalidURI(f"{SRV_SCHEME} URIs must include one, and only one, hostname")
  534:         fqdn, port = nodes[0]
  535:         if port is not None:
  536:             raise InvalidURI(f"{SRV_SCHEME} URIs must not include a port number")
  537: 
  538:         # Use the connection timeout. connectTimeoutMS passed as a keyword
  539:         # argument overrides the same option passed in the connection string.
  540:         connect_timeout = connect_timeout or options.get("connectTimeoutMS")
  541:         dns_resolver = _SrvResolver(fqdn, connect_timeout, srv_service_name, srv_max_hosts)
  542:         nodes = dns_resolver.get_hosts()
  543:         dns_options = dns_resolver.get_options()
  544:         if dns_options:
  545:             parsed_dns_options = split_options(dns_options, validate, warn, normalize)
  546:             if set(parsed_dns_options) - _ALLOWED_TXT_OPTS:
  547:                 raise ConfigurationError(
  548:                     "Only authSource, replicaSet, and loadBalanced are supported from DNS"
  549:                 )
  550:             for opt, val in parsed_dns_options.items():
  551:                 if opt not in options:
  552:                     options[opt] = val
  553:         if options.get("loadBalanced") and srv_max_hosts:
  554:             raise InvalidURI("You cannot specify loadBalanced with srvMaxHosts")
  555:         if options.get("replicaSet") and srv_max_hosts:
  556:             raise InvalidURI("You cannot specify replicaSet with srvMaxHosts")
  557:         if "tls" not in options and "ssl" not in options:
  558:             options["tls"] = True if validate else "true"
  559:     elif not is_srv and options.get("srvServiceName") is not None:
  560:         raise ConfigurationError(
  561:             "The srvServiceName option is only allowed with 'mongodb+srv://' URIs"
  562:         )
  563:     elif not is_srv and srv_max_hosts:
  564:         raise ConfigurationError(
  565:             "The srvMaxHosts option is only allowed with 'mongodb+srv://' URIs"
  566:         )
  567:     else:
  568:         nodes = split_hosts(hosts, default_port=default_port)
  569: 
  570:     _check_options(nodes, options)
  571: 
  572:     return {
  573:         "nodelist": nodes,
  574:         "username": user,
  575:         "password": passwd,
  576:         "database": dbase,
  577:         "collection": collection,
  578:         "options": options,
  579:         "fqdn": fqdn,
  580:     }
  581: 
  582: 
  583: def _parse_kms_tls_options(kms_tls_options: Optional[Mapping[str, Any]]) -> dict[str, SSLContext]:
  584:     """Parse KMS TLS connection options."""
  585:     if not kms_tls_options:
  586:         return {}
  587:     if not isinstance(kms_tls_options, dict):
  588:         raise TypeError("kms_tls_options must be a dict")
  589:     contexts = {}
  590:     for provider, options in kms_tls_options.items():
  591:         if not isinstance(options, dict):
  592:             raise TypeError(f'kms_tls_options["{provider}"] must be a dict')
  593:         options.setdefault("tls", True)
  594:         opts = _CaseInsensitiveDictionary(options)
  595:         opts = _handle_security_options(opts)
  596:         opts = _normalize_options(opts)
  597:         opts = cast(_CaseInsensitiveDictionary, validate_options(opts))
  598:         ssl_context, allow_invalid_hostnames = _parse_ssl_options(opts)
  599:         if ssl_context is None:
  600:             raise ConfigurationError("TLS is required for KMS providers")
  601:         if allow_invalid_hostnames:
  602:             raise ConfigurationError("Insecure TLS options prohibited")
  603: 
  604:         for n in [
  605:             "tlsInsecure",
  606:             "tlsAllowInvalidCertificates",
  607:             "tlsAllowInvalidHostnames",
  608:             "tlsDisableCertificateRevocationCheck",
  609:         ]:
  610:             if n in opts:
  611:                 raise ConfigurationError(f"Insecure TLS options prohibited: {n}")
  612:             contexts[provider] = ssl_context
  613:     return contexts
  614: 
  615: 
  616: if __name__ == "__main__":
  617:     import pprint
  618: 
  619:     try:
  620:         pprint.pprint(parse_uri(sys.argv[1]))  # noqa: T203
  621:     except InvalidURI as exc:
  622:         print(exc)  # noqa: T201
  623:     sys.exit(0)
