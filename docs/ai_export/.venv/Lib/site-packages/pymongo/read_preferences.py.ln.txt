    1: # Copyright 2012-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License",
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Utilities for choosing which member of a replica set to read from."""
   16: 
   17: from __future__ import annotations
   18: 
   19: from collections import abc
   20: from typing import TYPE_CHECKING, Any, Mapping, Optional, Sequence
   21: 
   22: from pymongo import max_staleness_selectors
   23: from pymongo.errors import ConfigurationError
   24: from pymongo.server_selectors import (
   25:     member_with_tags_server_selector,
   26:     secondary_with_tags_server_selector,
   27: )
   28: 
   29: if TYPE_CHECKING:
   30:     from pymongo.server_selectors import Selection
   31:     from pymongo.topology_description import TopologyDescription
   32: 
   33: _PRIMARY = 0
   34: _PRIMARY_PREFERRED = 1
   35: _SECONDARY = 2
   36: _SECONDARY_PREFERRED = 3
   37: _NEAREST = 4
   38: 
   39: 
   40: _MONGOS_MODES = (
   41:     "primary",
   42:     "primaryPreferred",
   43:     "secondary",
   44:     "secondaryPreferred",
   45:     "nearest",
   46: )
   47: 
   48: _Hedge = Mapping[str, Any]
   49: _TagSets = Sequence[Mapping[str, Any]]
   50: 
   51: 
   52: def _validate_tag_sets(tag_sets: Optional[_TagSets]) -> Optional[_TagSets]:
   53:     """Validate tag sets for a MongoClient."""
   54:     if tag_sets is None:
   55:         return tag_sets
   56: 
   57:     if not isinstance(tag_sets, (list, tuple)):
   58:         raise TypeError(f"Tag sets {tag_sets!r} invalid, must be a sequence")
   59:     if len(tag_sets) == 0:
   60:         raise ValueError(
   61:             f"Tag sets {tag_sets!r} invalid, must be None or contain at least one set of tags"
   62:         )
   63: 
   64:     for tags in tag_sets:
   65:         if not isinstance(tags, abc.Mapping):
   66:             raise TypeError(
   67:                 f"Tag set {tags!r} invalid, must be an instance of dict, "
   68:                 "bson.son.SON or other type that inherits from "
   69:                 "collection.Mapping"
   70:             )
   71: 
   72:     return list(tag_sets)
   73: 
   74: 
   75: def _invalid_max_staleness_msg(max_staleness: Any) -> str:
   76:     return "maxStalenessSeconds must be a positive integer, not %s" % max_staleness
   77: 
   78: 
   79: # Some duplication with common.py to avoid import cycle.
   80: def _validate_max_staleness(max_staleness: Any) -> int:
   81:     """Validate max_staleness."""
   82:     if max_staleness == -1:
   83:         return -1
   84: 
   85:     if not isinstance(max_staleness, int):
   86:         raise TypeError(_invalid_max_staleness_msg(max_staleness))
   87: 
   88:     if max_staleness <= 0:
   89:         raise ValueError(_invalid_max_staleness_msg(max_staleness))
   90: 
   91:     return max_staleness
   92: 
   93: 
   94: def _validate_hedge(hedge: Optional[_Hedge]) -> Optional[_Hedge]:
   95:     """Validate hedge."""
   96:     if hedge is None:
   97:         return None
   98: 
   99:     if not isinstance(hedge, dict):
  100:         raise TypeError(f"hedge must be a dictionary, not {hedge!r}")
  101: 
  102:     return hedge
  103: 
  104: 
  105: class _ServerMode:
  106:     """Base class for all read preferences."""
  107: 
  108:     __slots__ = ("__mongos_mode", "__mode", "__tag_sets", "__max_staleness", "__hedge")
  109: 
  110:     def __init__(
  111:         self,
  112:         mode: int,
  113:         tag_sets: Optional[_TagSets] = None,
  114:         max_staleness: int = -1,
  115:         hedge: Optional[_Hedge] = None,
  116:     ) -> None:
  117:         self.__mongos_mode = _MONGOS_MODES[mode]
  118:         self.__mode = mode
  119:         self.__tag_sets = _validate_tag_sets(tag_sets)
  120:         self.__max_staleness = _validate_max_staleness(max_staleness)
  121:         self.__hedge = _validate_hedge(hedge)
  122: 
  123:     @property
  124:     def name(self) -> str:
  125:         """The name of this read preference."""
  126:         return self.__class__.__name__
  127: 
  128:     @property
  129:     def mongos_mode(self) -> str:
  130:         """The mongos mode of this read preference."""
  131:         return self.__mongos_mode
  132: 
  133:     @property
  134:     def document(self) -> dict[str, Any]:
  135:         """Read preference as a document."""
  136:         doc: dict[str, Any] = {"mode": self.__mongos_mode}
  137:         if self.__tag_sets not in (None, [{}]):
  138:             doc["tags"] = self.__tag_sets
  139:         if self.__max_staleness != -1:
  140:             doc["maxStalenessSeconds"] = self.__max_staleness
  141:         if self.__hedge not in (None, {}):
  142:             doc["hedge"] = self.__hedge
  143:         return doc
  144: 
  145:     @property
  146:     def mode(self) -> int:
  147:         """The mode of this read preference instance."""
  148:         return self.__mode
  149: 
  150:     @property
  151:     def tag_sets(self) -> _TagSets:
  152:         """Set ``tag_sets`` to a list of dictionaries like [{'dc': 'ny'}] to
  153:         read only from members whose ``dc`` tag has the value ``"ny"``.
  154:         To specify a priority-order for tag sets, provide a list of
  155:         tag sets: ``[{'dc': 'ny'}, {'dc': 'la'}, {}]``. A final, empty tag
  156:         set, ``{}``, means "read from any member that matches the mode,
  157:         ignoring tags." MongoClient tries each set of tags in turn
  158:         until it finds a set of tags with at least one matching member.
  159:         For example, to only send a query to an analytic node::
  160: 
  161:            Nearest(tag_sets=[{"node":"analytics"}])
  162: 
  163:         Or using :class:`SecondaryPreferred`::
  164: 
  165:            SecondaryPreferred(tag_sets=[{"node":"analytics"}])
  166: 
  167:            .. seealso:: `Data-Center Awareness
  168:                <https://www.mongodb.com/docs/manual/data-center-awareness/>`_
  169:         """
  170:         return list(self.__tag_sets) if self.__tag_sets else [{}]
  171: 
  172:     @property
  173:     def max_staleness(self) -> int:
  174:         """The maximum estimated length of time (in seconds) a replica set
  175:         secondary can fall behind the primary in replication before it will
  176:         no longer be selected for operations, or -1 for no maximum.
  177:         """
  178:         return self.__max_staleness
  179: 
  180:     @property
  181:     def hedge(self) -> Optional[_Hedge]:
  182:         """The read preference ``hedge`` parameter.
  183: 
  184:         A dictionary that configures how the server will perform hedged reads.
  185:         It consists of the following keys:
  186: 
  187:         - ``enabled``: Enables or disables hedged reads in sharded clusters.
  188: 
  189:         Hedged reads are automatically enabled in MongoDB 4.4+ when using a
  190:         ``nearest`` read preference. To explicitly enable hedged reads, set
  191:         the ``enabled`` key  to ``true``::
  192: 
  193:             >>> Nearest(hedge={'enabled': True})
  194: 
  195:         To explicitly disable hedged reads, set the ``enabled`` key  to
  196:         ``False``::
  197: 
  198:             >>> Nearest(hedge={'enabled': False})
  199: 
  200:         .. versionadded:: 3.11
  201:         """
  202:         return self.__hedge
  203: 
  204:     @property
  205:     def min_wire_version(self) -> int:
  206:         """The wire protocol version the server must support.
  207: 
  208:         Some read preferences impose version requirements on all servers (e.g.
  209:         maxStalenessSeconds requires MongoDB 3.4 / maxWireVersion 5).
  210: 
  211:         All servers' maxWireVersion must be at least this read preference's
  212:         `min_wire_version`, or the driver raises
  213:         :exc:`~pymongo.errors.ConfigurationError`.
  214:         """
  215:         return 0 if self.__max_staleness == -1 else 5
  216: 
  217:     def __repr__(self) -> str:
  218:         return "{}(tag_sets={!r}, max_staleness={!r}, hedge={!r})".format(
  219:             self.name,
  220:             self.__tag_sets,
  221:             self.__max_staleness,
  222:             self.__hedge,
  223:         )
  224: 
  225:     def __eq__(self, other: Any) -> bool:
  226:         if isinstance(other, _ServerMode):
  227:             return (
  228:                 self.mode == other.mode
  229:                 and self.tag_sets == other.tag_sets
  230:                 and self.max_staleness == other.max_staleness
  231:                 and self.hedge == other.hedge
  232:             )
  233:         return NotImplemented
  234: 
  235:     def __ne__(self, other: Any) -> bool:
  236:         return not self == other
  237: 
  238:     def __getstate__(self) -> dict[str, Any]:
  239:         """Return value of object for pickling.
  240: 
  241:         Needed explicitly because __slots__() defined.
  242:         """
  243:         return {
  244:             "mode": self.__mode,
  245:             "tag_sets": self.__tag_sets,
  246:             "max_staleness": self.__max_staleness,
  247:             "hedge": self.__hedge,
  248:         }
  249: 
  250:     def __setstate__(self, value: Mapping[str, Any]) -> None:
  251:         """Restore from pickling."""
  252:         self.__mode = value["mode"]
  253:         self.__mongos_mode = _MONGOS_MODES[self.__mode]
  254:         self.__tag_sets = _validate_tag_sets(value["tag_sets"])
  255:         self.__max_staleness = _validate_max_staleness(value["max_staleness"])
  256:         self.__hedge = _validate_hedge(value["hedge"])
  257: 
  258:     def __call__(self, selection: Selection) -> Selection:
  259:         return selection
  260: 
  261: 
  262: class Primary(_ServerMode):
  263:     """Primary read preference.
  264: 
  265:     * When directly connected to one mongod queries are allowed if the server
  266:       is standalone or a replica set primary.
  267:     * When connected to a mongos queries are sent to the primary of a shard.
  268:     * When connected to a replica set queries are sent to the primary of
  269:       the replica set.
  270:     """
  271: 
  272:     __slots__ = ()
  273: 
  274:     def __init__(self) -> None:
  275:         super().__init__(_PRIMARY)
  276: 
  277:     def __call__(self, selection: Selection) -> Selection:
  278:         """Apply this read preference to a Selection."""
  279:         return selection.primary_selection
  280: 
  281:     def __repr__(self) -> str:
  282:         return "Primary()"
  283: 
  284:     def __eq__(self, other: Any) -> bool:
  285:         if isinstance(other, _ServerMode):
  286:             return other.mode == _PRIMARY
  287:         return NotImplemented
  288: 
  289: 
  290: class PrimaryPreferred(_ServerMode):
  291:     """PrimaryPreferred read preference.
  292: 
  293:     * When directly connected to one mongod queries are allowed to standalone
  294:       servers, to a replica set primary, or to replica set secondaries.
  295:     * When connected to a mongos queries are sent to the primary of a shard if
  296:       available, otherwise a shard secondary.
  297:     * When connected to a replica set queries are sent to the primary if
  298:       available, otherwise a secondary.
  299: 
  300:     .. note:: When a :class:`~pymongo.mongo_client.MongoClient` is first
  301:       created reads will be routed to an available secondary until the
  302:       primary of the replica set is discovered.
  303: 
  304:     :param tag_sets: The :attr:`~tag_sets` to use if the primary is not
  305:         available.
  306:     :param max_staleness: (integer, in seconds) The maximum estimated
  307:         length of time a replica set secondary can fall behind the primary in
  308:         replication before it will no longer be selected for operations.
  309:         Default -1, meaning no maximum. If it is set, it must be at least
  310:         90 seconds.
  311:     :param hedge: The :attr:`~hedge` to use if the primary is not available.
  312: 
  313:     .. versionchanged:: 3.11
  314:        Added ``hedge`` parameter.
  315:     """
  316: 
  317:     __slots__ = ()
  318: 
  319:     def __init__(
  320:         self,
  321:         tag_sets: Optional[_TagSets] = None,
  322:         max_staleness: int = -1,
  323:         hedge: Optional[_Hedge] = None,
  324:     ) -> None:
  325:         super().__init__(_PRIMARY_PREFERRED, tag_sets, max_staleness, hedge)
  326: 
  327:     def __call__(self, selection: Selection) -> Selection:
  328:         """Apply this read preference to Selection."""
  329:         if selection.primary:
  330:             return selection.primary_selection
  331:         else:
  332:             return secondary_with_tags_server_selector(
  333:                 self.tag_sets, max_staleness_selectors.select(self.max_staleness, selection)
  334:             )
  335: 
  336: 
  337: class Secondary(_ServerMode):
  338:     """Secondary read preference.
  339: 
  340:     * When directly connected to one mongod queries are allowed to standalone
  341:       servers, to a replica set primary, or to replica set secondaries.
  342:     * When connected to a mongos queries are distributed among shard
  343:       secondaries. An error is raised if no secondaries are available.
  344:     * When connected to a replica set queries are distributed among
  345:       secondaries. An error is raised if no secondaries are available.
  346: 
  347:     :param tag_sets: The :attr:`~tag_sets` for this read preference.
  348:     :param max_staleness: (integer, in seconds) The maximum estimated
  349:         length of time a replica set secondary can fall behind the primary in
  350:         replication before it will no longer be selected for operations.
  351:         Default -1, meaning no maximum. If it is set, it must be at least
  352:         90 seconds.
  353:     :param hedge: The :attr:`~hedge` for this read preference.
  354: 
  355:     .. versionchanged:: 3.11
  356:        Added ``hedge`` parameter.
  357:     """
  358: 
  359:     __slots__ = ()
  360: 
  361:     def __init__(
  362:         self,
  363:         tag_sets: Optional[_TagSets] = None,
  364:         max_staleness: int = -1,
  365:         hedge: Optional[_Hedge] = None,
  366:     ) -> None:
  367:         super().__init__(_SECONDARY, tag_sets, max_staleness, hedge)
  368: 
  369:     def __call__(self, selection: Selection) -> Selection:
  370:         """Apply this read preference to Selection."""
  371:         return secondary_with_tags_server_selector(
  372:             self.tag_sets, max_staleness_selectors.select(self.max_staleness, selection)
  373:         )
  374: 
  375: 
  376: class SecondaryPreferred(_ServerMode):
  377:     """SecondaryPreferred read preference.
  378: 
  379:     * When directly connected to one mongod queries are allowed to standalone
  380:       servers, to a replica set primary, or to replica set secondaries.
  381:     * When connected to a mongos queries are distributed among shard
  382:       secondaries, or the shard primary if no secondary is available.
  383:     * When connected to a replica set queries are distributed among
  384:       secondaries, or the primary if no secondary is available.
  385: 
  386:     .. note:: When a :class:`~pymongo.mongo_client.MongoClient` is first
  387:       created reads will be routed to the primary of the replica set until
  388:       an available secondary is discovered.
  389: 
  390:     :param tag_sets: The :attr:`~tag_sets` for this read preference.
  391:     :param max_staleness: (integer, in seconds) The maximum estimated
  392:         length of time a replica set secondary can fall behind the primary in
  393:         replication before it will no longer be selected for operations.
  394:         Default -1, meaning no maximum. If it is set, it must be at least
  395:         90 seconds.
  396:     :param hedge: The :attr:`~hedge` for this read preference.
  397: 
  398:     .. versionchanged:: 3.11
  399:        Added ``hedge`` parameter.
  400:     """
  401: 
  402:     __slots__ = ()
  403: 
  404:     def __init__(
  405:         self,
  406:         tag_sets: Optional[_TagSets] = None,
  407:         max_staleness: int = -1,
  408:         hedge: Optional[_Hedge] = None,
  409:     ) -> None:
  410:         super().__init__(_SECONDARY_PREFERRED, tag_sets, max_staleness, hedge)
  411: 
  412:     def __call__(self, selection: Selection) -> Selection:
  413:         """Apply this read preference to Selection."""
  414:         secondaries = secondary_with_tags_server_selector(
  415:             self.tag_sets, max_staleness_selectors.select(self.max_staleness, selection)
  416:         )
  417: 
  418:         if secondaries:
  419:             return secondaries
  420:         else:
  421:             return selection.primary_selection
  422: 
  423: 
  424: class Nearest(_ServerMode):
  425:     """Nearest read preference.
  426: 
  427:     * When directly connected to one mongod queries are allowed to standalone
  428:       servers, to a replica set primary, or to replica set secondaries.
  429:     * When connected to a mongos queries are distributed among all members of
  430:       a shard.
  431:     * When connected to a replica set queries are distributed among all
  432:       members.
  433: 
  434:     :param tag_sets: The :attr:`~tag_sets` for this read preference.
  435:     :param max_staleness: (integer, in seconds) The maximum estimated
  436:         length of time a replica set secondary can fall behind the primary in
  437:         replication before it will no longer be selected for operations.
  438:         Default -1, meaning no maximum. If it is set, it must be at least
  439:         90 seconds.
  440:     :param hedge: The :attr:`~hedge` for this read preference.
  441: 
  442:     .. versionchanged:: 3.11
  443:        Added ``hedge`` parameter.
  444:     """
  445: 
  446:     __slots__ = ()
  447: 
  448:     def __init__(
  449:         self,
  450:         tag_sets: Optional[_TagSets] = None,
  451:         max_staleness: int = -1,
  452:         hedge: Optional[_Hedge] = None,
  453:     ) -> None:
  454:         super().__init__(_NEAREST, tag_sets, max_staleness, hedge)
  455: 
  456:     def __call__(self, selection: Selection) -> Selection:
  457:         """Apply this read preference to Selection."""
  458:         return member_with_tags_server_selector(
  459:             self.tag_sets, max_staleness_selectors.select(self.max_staleness, selection)
  460:         )
  461: 
  462: 
  463: class _AggWritePref:
  464:     """Agg $out/$merge write preference.
  465: 
  466:     * If there are readable servers and there is any pre-5.0 server, use
  467:       primary read preference.
  468:     * Otherwise use `pref` read preference.
  469: 
  470:     :param pref: The read preference to use on MongoDB 5.0+.
  471:     """
  472: 
  473:     __slots__ = ("pref", "effective_pref")
  474: 
  475:     def __init__(self, pref: _ServerMode):
  476:         self.pref = pref
  477:         self.effective_pref: _ServerMode = ReadPreference.PRIMARY
  478: 
  479:     def selection_hook(self, topology_description: TopologyDescription) -> None:
  480:         common_wv = topology_description.common_wire_version
  481:         if (
  482:             topology_description.has_readable_server(ReadPreference.PRIMARY_PREFERRED)
  483:             and common_wv
  484:             and common_wv < 13
  485:         ):
  486:             self.effective_pref = ReadPreference.PRIMARY
  487:         else:
  488:             self.effective_pref = self.pref
  489: 
  490:     def __call__(self, selection: Selection) -> Selection:
  491:         """Apply this read preference to a Selection."""
  492:         return self.effective_pref(selection)
  493: 
  494:     def __repr__(self) -> str:
  495:         return f"_AggWritePref(pref={self.pref!r})"
  496: 
  497:     # Proxy other calls to the effective_pref so that _AggWritePref can be
  498:     # used in place of an actual read preference.
  499:     def __getattr__(self, name: str) -> Any:
  500:         return getattr(self.effective_pref, name)
  501: 
  502: 
  503: _ALL_READ_PREFERENCES = (Primary, PrimaryPreferred, Secondary, SecondaryPreferred, Nearest)
  504: 
  505: 
  506: def make_read_preference(
  507:     mode: int, tag_sets: Optional[_TagSets], max_staleness: int = -1
  508: ) -> _ServerMode:
  509:     if mode == _PRIMARY:
  510:         if tag_sets not in (None, [{}]):
  511:             raise ConfigurationError("Read preference primary cannot be combined with tags")
  512:         if max_staleness != -1:
  513:             raise ConfigurationError(
  514:                 "Read preference primary cannot be combined with maxStalenessSeconds"
  515:             )
  516:         return Primary()
  517:     return _ALL_READ_PREFERENCES[mode](tag_sets, max_staleness)  # type: ignore
  518: 
  519: 
  520: _MODES = (
  521:     "PRIMARY",
  522:     "PRIMARY_PREFERRED",
  523:     "SECONDARY",
  524:     "SECONDARY_PREFERRED",
  525:     "NEAREST",
  526: )
  527: 
  528: 
  529: class ReadPreference:
  530:     """An enum that defines some commonly used read preference modes.
  531: 
  532:     Apps can also create a custom read preference, for example::
  533: 
  534:        Nearest(tag_sets=[{"node":"analytics"}])
  535: 
  536:     See :doc:`/examples/high_availability` for code examples.
  537: 
  538:     A read preference is used in three cases:
  539: 
  540:     :class:`~pymongo.mongo_client.MongoClient` connected to a single mongod:
  541: 
  542:     - ``PRIMARY``: Queries are allowed if the server is standalone or a replica
  543:       set primary.
  544:     - All other modes allow queries to standalone servers, to a replica set
  545:       primary, or to replica set secondaries.
  546: 
  547:     :class:`~pymongo.mongo_client.MongoClient` initialized with the
  548:     ``replicaSet`` option:
  549: 
  550:     - ``PRIMARY``: Read from the primary. This is the default, and provides the
  551:       strongest consistency. If no primary is available, raise
  552:       :class:`~pymongo.errors.AutoReconnect`.
  553: 
  554:     - ``PRIMARY_PREFERRED``: Read from the primary if available, or if there is
  555:       none, read from a secondary.
  556: 
  557:     - ``SECONDARY``: Read from a secondary. If no secondary is available,
  558:       raise :class:`~pymongo.errors.AutoReconnect`.
  559: 
  560:     - ``SECONDARY_PREFERRED``: Read from a secondary if available, otherwise
  561:       from the primary.
  562: 
  563:     - ``NEAREST``: Read from any member.
  564: 
  565:     :class:`~pymongo.mongo_client.MongoClient` connected to a mongos, with a
  566:     sharded cluster of replica sets:
  567: 
  568:     - ``PRIMARY``: Read from the primary of the shard, or raise
  569:       :class:`~pymongo.errors.OperationFailure` if there is none.
  570:       This is the default.
  571: 
  572:     - ``PRIMARY_PREFERRED``: Read from the primary of the shard, or if there is
  573:       none, read from a secondary of the shard.
  574: 
  575:     - ``SECONDARY``: Read from a secondary of the shard, or raise
  576:       :class:`~pymongo.errors.OperationFailure` if there is none.
  577: 
  578:     - ``SECONDARY_PREFERRED``: Read from a secondary of the shard if available,
  579:       otherwise from the shard primary.
  580: 
  581:     - ``NEAREST``: Read from any shard member.
  582:     """
  583: 
  584:     PRIMARY = Primary()
  585:     PRIMARY_PREFERRED = PrimaryPreferred()
  586:     SECONDARY = Secondary()
  587:     SECONDARY_PREFERRED = SecondaryPreferred()
  588:     NEAREST = Nearest()
  589: 
  590: 
  591: def read_pref_mode_from_name(name: str) -> int:
  592:     """Get the read preference mode from mongos/uri name."""
  593:     return _MONGOS_MODES.index(name)
  594: 
  595: 
  596: class MovingAverage:
  597:     """Tracks an exponentially-weighted moving average."""
  598: 
  599:     average: Optional[float]
  600: 
  601:     def __init__(self) -> None:
  602:         self.average = None
  603: 
  604:     def add_sample(self, sample: float) -> None:
  605:         if sample < 0:
  606:             # Likely system time change while waiting for hello response
  607:             # and not using time.monotonic. Ignore it, the next one will
  608:             # probably be valid.
  609:             return
  610:         if self.average is None:
  611:             self.average = sample
  612:         else:
  613:             # The Server Selection Spec requires an exponentially weighted
  614:             # average with alpha = 0.2.
  615:             self.average = 0.8 * self.average + 0.2 * sample
  616: 
  617:     def get(self) -> Optional[float]:
  618:         """Get the calculated average, or None if no samples yet."""
  619:         return self.average
  620: 
  621:     def reset(self) -> None:
  622:         self.average = None
