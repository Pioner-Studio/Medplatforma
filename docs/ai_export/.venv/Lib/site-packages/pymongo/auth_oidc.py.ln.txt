    1: # Copyright 2023-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """MONGODB-OIDC Authentication helpers."""
   16: from __future__ import annotations
   17: 
   18: import abc
   19: import os
   20: import threading
   21: import time
   22: from dataclasses import dataclass, field
   23: from typing import TYPE_CHECKING, Any, Mapping, MutableMapping, Optional, Union
   24: from urllib.parse import quote
   25: 
   26: import bson
   27: from bson.binary import Binary
   28: from pymongo._azure_helpers import _get_azure_response
   29: from pymongo._csot import remaining
   30: from pymongo._gcp_helpers import _get_gcp_response
   31: from pymongo.errors import ConfigurationError, OperationFailure
   32: from pymongo.helpers import _AUTHENTICATION_FAILURE_CODE
   33: 
   34: if TYPE_CHECKING:
   35:     from pymongo.auth import MongoCredential
   36:     from pymongo.pool import Connection
   37: 
   38: 
   39: @dataclass
   40: class OIDCIdPInfo:
   41:     issuer: str
   42:     clientId: Optional[str] = field(default=None)
   43:     requestScopes: Optional[list[str]] = field(default=None)
   44: 
   45: 
   46: @dataclass
   47: class OIDCCallbackContext:
   48:     timeout_seconds: float
   49:     username: str
   50:     version: int
   51:     refresh_token: Optional[str] = field(default=None)
   52:     idp_info: Optional[OIDCIdPInfo] = field(default=None)
   53: 
   54: 
   55: @dataclass
   56: class OIDCCallbackResult:
   57:     access_token: str
   58:     expires_in_seconds: Optional[float] = field(default=None)
   59:     refresh_token: Optional[str] = field(default=None)
   60: 
   61: 
   62: class OIDCCallback(abc.ABC):
   63:     """A base class for defining OIDC callbacks."""
   64: 
   65:     @abc.abstractmethod
   66:     def fetch(self, context: OIDCCallbackContext) -> OIDCCallbackResult:
   67:         """Convert the given BSON value into our own type."""
   68: 
   69: 
   70: @dataclass
   71: class _OIDCProperties:
   72:     callback: Optional[OIDCCallback] = field(default=None)
   73:     human_callback: Optional[OIDCCallback] = field(default=None)
   74:     environment: Optional[str] = field(default=None)
   75:     allowed_hosts: list[str] = field(default_factory=list)
   76:     token_resource: Optional[str] = field(default=None)
   77:     username: str = ""
   78: 
   79: 
   80: """Mechanism properties for MONGODB-OIDC authentication."""
   81: 
   82: TOKEN_BUFFER_MINUTES = 5
   83: HUMAN_CALLBACK_TIMEOUT_SECONDS = 5 * 60
   84: CALLBACK_VERSION = 1
   85: MACHINE_CALLBACK_TIMEOUT_SECONDS = 60
   86: TIME_BETWEEN_CALLS_SECONDS = 0.1
   87: 
   88: 
   89: def _get_authenticator(
   90:     credentials: MongoCredential, address: tuple[str, int]
   91: ) -> _OIDCAuthenticator:
   92:     if credentials.cache.data:
   93:         return credentials.cache.data
   94: 
   95:     # Extract values.
   96:     principal_name = credentials.username
   97:     properties = credentials.mechanism_properties
   98: 
   99:     # Validate that the address is allowed.
  100:     if not properties.environment:
  101:         found = False
  102:         allowed_hosts = properties.allowed_hosts
  103:         for patt in allowed_hosts:
  104:             if patt == address[0]:
  105:                 found = True
  106:             elif patt.startswith("*.") and address[0].endswith(patt[1:]):
  107:                 found = True
  108:         if not found:
  109:             raise ConfigurationError(
  110:                 f"Refusing to connect to {address[0]}, which is not in authOIDCAllowedHosts: {allowed_hosts}"
  111:             )
  112: 
  113:     # Get or create the cache data.
  114:     credentials.cache.data = _OIDCAuthenticator(username=principal_name, properties=properties)
  115:     return credentials.cache.data
  116: 
  117: 
  118: class _OIDCTestCallback(OIDCCallback):
  119:     def fetch(self, context: OIDCCallbackContext) -> OIDCCallbackResult:
  120:         token_file = os.environ.get("OIDC_TOKEN_FILE")
  121:         if not token_file:
  122:             raise RuntimeError(
  123:                 'MONGODB-OIDC with an "test" provider requires "OIDC_TOKEN_FILE" to be set'
  124:             )
  125:         with open(token_file) as fid:
  126:             return OIDCCallbackResult(access_token=fid.read().strip())
  127: 
  128: 
  129: class _OIDCAzureCallback(OIDCCallback):
  130:     def __init__(self, token_resource: str) -> None:
  131:         self.token_resource = quote(token_resource)
  132: 
  133:     def fetch(self, context: OIDCCallbackContext) -> OIDCCallbackResult:
  134:         resp = _get_azure_response(self.token_resource, context.username, context.timeout_seconds)
  135:         return OIDCCallbackResult(
  136:             access_token=resp["access_token"], expires_in_seconds=resp["expires_in"]
  137:         )
  138: 
  139: 
  140: class _OIDCGCPCallback(OIDCCallback):
  141:     def __init__(self, token_resource: str) -> None:
  142:         self.token_resource = quote(token_resource)
  143: 
  144:     def fetch(self, context: OIDCCallbackContext) -> OIDCCallbackResult:
  145:         resp = _get_gcp_response(self.token_resource, context.timeout_seconds)
  146:         return OIDCCallbackResult(access_token=resp["access_token"])
  147: 
  148: 
  149: @dataclass
  150: class _OIDCAuthenticator:
  151:     username: str
  152:     properties: _OIDCProperties
  153:     refresh_token: Optional[str] = field(default=None)
  154:     access_token: Optional[str] = field(default=None)
  155:     idp_info: Optional[OIDCIdPInfo] = field(default=None)
  156:     token_gen_id: int = field(default=0)
  157:     lock: threading.Lock = field(default_factory=threading.Lock)
  158:     last_call_time: float = field(default=0)
  159: 
  160:     def reauthenticate(self, conn: Connection) -> Optional[Mapping[str, Any]]:
  161:         """Handle a reauthenticate from the server."""
  162:         # Invalidate the token for the connection.
  163:         self._invalidate(conn)
  164:         # Call the appropriate auth logic for the callback type.
  165:         if self.properties.callback:
  166:             return self._authenticate_machine(conn)
  167:         return self._authenticate_human(conn)
  168: 
  169:     def authenticate(self, conn: Connection) -> Optional[Mapping[str, Any]]:
  170:         """Handle an initial authenticate request."""
  171:         # First handle speculative auth.
  172:         # If it succeeded, we are done.
  173:         ctx = conn.auth_ctx
  174:         if ctx and ctx.speculate_succeeded():
  175:             resp = ctx.speculative_authenticate
  176:             if resp and resp["done"]:
  177:                 conn.oidc_token_gen_id = self.token_gen_id
  178:                 return resp
  179: 
  180:         # If spec auth failed, call the appropriate auth logic for the callback type.
  181:         # We cannot assume that the token is invalid, because a proxy may have been
  182:         # involved that stripped the speculative auth information.
  183:         if self.properties.callback:
  184:             return self._authenticate_machine(conn)
  185:         return self._authenticate_human(conn)
  186: 
  187:     def get_spec_auth_cmd(self) -> Optional[MutableMapping[str, Any]]:
  188:         """Get the appropriate speculative auth command."""
  189:         if not self.access_token:
  190:             return None
  191:         return self._get_start_command({"jwt": self.access_token})
  192: 
  193:     def _authenticate_machine(self, conn: Connection) -> Mapping[str, Any]:
  194:         # If there is a cached access token, try to authenticate with it. If
  195:         # authentication fails with error code 18, invalidate the access token,
  196:         # fetch a new access token, and try to authenticate again. If authentication
  197:         # fails for any other reason, raise the error to the user.
  198:         if self.access_token:
  199:             try:
  200:                 return self._sasl_start_jwt(conn)
  201:             except OperationFailure as e:
  202:                 if self._is_auth_error(e):
  203:                     return self._authenticate_machine(conn)
  204:                 raise
  205:         return self._sasl_start_jwt(conn)
  206: 
  207:     def _authenticate_human(self, conn: Connection) -> Optional[Mapping[str, Any]]:
  208:         # If we have a cached access token, try a JwtStepRequest.
  209:         # authentication fails with error code 18, invalidate the access token,
  210:         # and try to authenticate again.  If authentication fails for any other
  211:         # reason, raise the error to the user.
  212:         if self.access_token:
  213:             try:
  214:                 return self._sasl_start_jwt(conn)
  215:             except OperationFailure as e:
  216:                 if self._is_auth_error(e):
  217:                     return self._authenticate_human(conn)
  218:                 raise
  219: 
  220:         # If we have a cached refresh token, try a JwtStepRequest with that.
  221:         # If authentication fails with error code 18, invalidate the access and
  222:         # refresh tokens, and try to authenticate again. If authentication fails for
  223:         # any other reason, raise the error to the user.
  224:         if self.refresh_token:
  225:             try:
  226:                 return self._sasl_start_jwt(conn)
  227:             except OperationFailure as e:
  228:                 if self._is_auth_error(e):
  229:                     self.refresh_token = None
  230:                     return self._authenticate_human(conn)
  231:                 raise
  232: 
  233:         # Start a new Two-Step SASL conversation.
  234:         # Run a PrincipalStepRequest to get the IdpInfo.
  235:         cmd = self._get_start_command(None)
  236:         start_resp = self._run_command(conn, cmd)
  237:         # Attempt to authenticate with a JwtStepRequest.
  238:         return self._sasl_continue_jwt(conn, start_resp)
  239: 
  240:     def _get_access_token(self) -> Optional[str]:
  241:         properties = self.properties
  242:         cb: Union[None, OIDCCallback]
  243:         resp: OIDCCallbackResult
  244: 
  245:         is_human = properties.human_callback is not None
  246:         if is_human and self.idp_info is None:
  247:             return None
  248: 
  249:         if properties.callback:
  250:             cb = properties.callback
  251:         if properties.human_callback:
  252:             cb = properties.human_callback
  253: 
  254:         prev_token = self.access_token
  255:         if prev_token:
  256:             return prev_token
  257: 
  258:         if cb is None and not prev_token:
  259:             return None
  260: 
  261:         if not prev_token and cb is not None:
  262:             with self.lock:
  263:                 # See if the token was changed while we were waiting for the
  264:                 # lock.
  265:                 new_token = self.access_token
  266:                 if new_token != prev_token:
  267:                     return new_token
  268: 
  269:                 # Ensure that we are waiting a min time between callback invocations.
  270:                 delta = time.time() - self.last_call_time
  271:                 if delta < TIME_BETWEEN_CALLS_SECONDS:
  272:                     time.sleep(TIME_BETWEEN_CALLS_SECONDS - delta)
  273:                 self.last_call_time = time.time()
  274: 
  275:                 if is_human:
  276:                     timeout = HUMAN_CALLBACK_TIMEOUT_SECONDS
  277:                     assert self.idp_info is not None
  278:                 else:
  279:                     timeout = int(remaining() or MACHINE_CALLBACK_TIMEOUT_SECONDS)
  280:                 context = OIDCCallbackContext(
  281:                     timeout_seconds=timeout,
  282:                     version=CALLBACK_VERSION,
  283:                     refresh_token=self.refresh_token,
  284:                     idp_info=self.idp_info,
  285:                     username=self.properties.username,
  286:                 )
  287:                 resp = cb.fetch(context)
  288:                 if not isinstance(resp, OIDCCallbackResult):
  289:                     raise ValueError("Callback result must be of type OIDCCallbackResult")
  290:                 self.refresh_token = resp.refresh_token
  291:                 self.access_token = resp.access_token
  292:                 self.token_gen_id += 1
  293: 
  294:         return self.access_token
  295: 
  296:     def _run_command(self, conn: Connection, cmd: MutableMapping[str, Any]) -> Mapping[str, Any]:
  297:         try:
  298:             return conn.command("$external", cmd, no_reauth=True)  # type: ignore[call-arg]
  299:         except OperationFailure as e:
  300:             if self._is_auth_error(e):
  301:                 self._invalidate(conn)
  302:             raise
  303: 
  304:     def _is_auth_error(self, err: Exception) -> bool:
  305:         if not isinstance(err, OperationFailure):
  306:             return False
  307:         return err.code == _AUTHENTICATION_FAILURE_CODE
  308: 
  309:     def _invalidate(self, conn: Connection) -> None:
  310:         # Ignore the invalidation if a token gen id is given and is less than our
  311:         # current token gen id.
  312:         token_gen_id = conn.oidc_token_gen_id or 0
  313:         if token_gen_id is not None and token_gen_id < self.token_gen_id:
  314:             return
  315:         self.access_token = None
  316: 
  317:     def _sasl_continue_jwt(
  318:         self, conn: Connection, start_resp: Mapping[str, Any]
  319:     ) -> Mapping[str, Any]:
  320:         self.access_token = None
  321:         self.refresh_token = None
  322:         start_payload: dict = bson.decode(start_resp["payload"])
  323:         if "issuer" in start_payload:
  324:             self.idp_info = OIDCIdPInfo(**start_payload)
  325:         access_token = self._get_access_token()
  326:         conn.oidc_token_gen_id = self.token_gen_id
  327:         cmd = self._get_continue_command({"jwt": access_token}, start_resp)
  328:         return self._run_command(conn, cmd)
  329: 
  330:     def _sasl_start_jwt(self, conn: Connection) -> Mapping[str, Any]:
  331:         access_token = self._get_access_token()
  332:         conn.oidc_token_gen_id = self.token_gen_id
  333:         cmd = self._get_start_command({"jwt": access_token})
  334:         return self._run_command(conn, cmd)
  335: 
  336:     def _get_start_command(self, payload: Optional[Mapping[str, Any]]) -> MutableMapping[str, Any]:
  337:         if payload is None:
  338:             principal_name = self.username
  339:             if principal_name:
  340:                 payload = {"n": principal_name}
  341:             else:
  342:                 payload = {}
  343:         bin_payload = Binary(bson.encode(payload))
  344:         return {"saslStart": 1, "mechanism": "MONGODB-OIDC", "payload": bin_payload}
  345: 
  346:     def _get_continue_command(
  347:         self, payload: Mapping[str, Any], start_resp: Mapping[str, Any]
  348:     ) -> MutableMapping[str, Any]:
  349:         bin_payload = Binary(bson.encode(payload))
  350:         return {
  351:             "saslContinue": 1,
  352:             "payload": bin_payload,
  353:             "conversationId": start_resp["conversationId"],
  354:         }
  355: 
  356: 
  357: def _authenticate_oidc(
  358:     credentials: MongoCredential, conn: Connection, reauthenticate: bool
  359: ) -> Optional[Mapping[str, Any]]:
  360:     """Authenticate using MONGODB-OIDC."""
  361:     authenticator = _get_authenticator(credentials, conn.address)
  362:     if reauthenticate:
  363:         return authenticator.reauthenticate(conn)
  364:     else:
  365:         return authenticator.authenticate(conn)
