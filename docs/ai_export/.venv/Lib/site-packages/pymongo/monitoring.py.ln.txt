    1: # Copyright 2015-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Tools to monitor driver events.
   16: 
   17: .. versionadded:: 3.1
   18: 
   19: .. attention:: Starting in PyMongo 3.11, the monitoring classes outlined below
   20:     are included in the PyMongo distribution under the
   21:     :mod:`~pymongo.event_loggers` submodule.
   22: 
   23: Use :func:`register` to register global listeners for specific events.
   24: Listeners must inherit from one of the abstract classes below and implement
   25: the correct functions for that class.
   26: 
   27: For example, a simple command logger might be implemented like this::
   28: 
   29:     import logging
   30: 
   31:     from pymongo import monitoring
   32: 
   33:     class CommandLogger(monitoring.CommandListener):
   34: 
   35:         def started(self, event):
   36:             logging.info("Command {0.command_name} with request id "
   37:                          "{0.request_id} started on server "
   38:                          "{0.connection_id}".format(event))
   39: 
   40:         def succeeded(self, event):
   41:             logging.info("Command {0.command_name} with request id "
   42:                          "{0.request_id} on server {0.connection_id} "
   43:                          "succeeded in {0.duration_micros} "
   44:                          "microseconds".format(event))
   45: 
   46:         def failed(self, event):
   47:             logging.info("Command {0.command_name} with request id "
   48:                          "{0.request_id} on server {0.connection_id} "
   49:                          "failed in {0.duration_micros} "
   50:                          "microseconds".format(event))
   51: 
   52:     monitoring.register(CommandLogger())
   53: 
   54: Server discovery and monitoring events are also available. For example::
   55: 
   56:     class ServerLogger(monitoring.ServerListener):
   57: 
   58:         def opened(self, event):
   59:             logging.info("Server {0.server_address} added to topology "
   60:                          "{0.topology_id}".format(event))
   61: 
   62:         def description_changed(self, event):
   63:             previous_server_type = event.previous_description.server_type
   64:             new_server_type = event.new_description.server_type
   65:             if new_server_type != previous_server_type:
   66:                 # server_type_name was added in PyMongo 3.4
   67:                 logging.info(
   68:                     "Server {0.server_address} changed type from "
   69:                     "{0.previous_description.server_type_name} to "
   70:                     "{0.new_description.server_type_name}".format(event))
   71: 
   72:         def closed(self, event):
   73:             logging.warning("Server {0.server_address} removed from topology "
   74:                             "{0.topology_id}".format(event))
   75: 
   76: 
   77:     class HeartbeatLogger(monitoring.ServerHeartbeatListener):
   78: 
   79:         def started(self, event):
   80:             logging.info("Heartbeat sent to server "
   81:                          "{0.connection_id}".format(event))
   82: 
   83:         def succeeded(self, event):
   84:             # The reply.document attribute was added in PyMongo 3.4.
   85:             logging.info("Heartbeat to server {0.connection_id} "
   86:                          "succeeded with reply "
   87:                          "{0.reply.document}".format(event))
   88: 
   89:         def failed(self, event):
   90:             logging.warning("Heartbeat to server {0.connection_id} "
   91:                             "failed with error {0.reply}".format(event))
   92: 
   93:     class TopologyLogger(monitoring.TopologyListener):
   94: 
   95:         def opened(self, event):
   96:             logging.info("Topology with id {0.topology_id} "
   97:                          "opened".format(event))
   98: 
   99:         def description_changed(self, event):
  100:             logging.info("Topology description updated for "
  101:                          "topology id {0.topology_id}".format(event))
  102:             previous_topology_type = event.previous_description.topology_type
  103:             new_topology_type = event.new_description.topology_type
  104:             if new_topology_type != previous_topology_type:
  105:                 # topology_type_name was added in PyMongo 3.4
  106:                 logging.info(
  107:                     "Topology {0.topology_id} changed type from "
  108:                     "{0.previous_description.topology_type_name} to "
  109:                     "{0.new_description.topology_type_name}".format(event))
  110:             # The has_writable_server and has_readable_server methods
  111:             # were added in PyMongo 3.4.
  112:             if not event.new_description.has_writable_server():
  113:                 logging.warning("No writable servers available.")
  114:             if not event.new_description.has_readable_server():
  115:                 logging.warning("No readable servers available.")
  116: 
  117:         def closed(self, event):
  118:             logging.info("Topology with id {0.topology_id} "
  119:                          "closed".format(event))
  120: 
  121: Connection monitoring and pooling events are also available. For example::
  122: 
  123:     class ConnectionPoolLogger(ConnectionPoolListener):
  124: 
  125:         def pool_created(self, event):
  126:             logging.info("[pool {0.address}] pool created".format(event))
  127: 
  128:         def pool_ready(self, event):
  129:             logging.info("[pool {0.address}] pool is ready".format(event))
  130: 
  131:         def pool_cleared(self, event):
  132:             logging.info("[pool {0.address}] pool cleared".format(event))
  133: 
  134:         def pool_closed(self, event):
  135:             logging.info("[pool {0.address}] pool closed".format(event))
  136: 
  137:         def connection_created(self, event):
  138:             logging.info("[pool {0.address}][connection #{0.connection_id}] "
  139:                          "connection created".format(event))
  140: 
  141:         def connection_ready(self, event):
  142:             logging.info("[pool {0.address}][connection #{0.connection_id}] "
  143:                          "connection setup succeeded".format(event))
  144: 
  145:         def connection_closed(self, event):
  146:             logging.info("[pool {0.address}][connection #{0.connection_id}] "
  147:                          "connection closed, reason: "
  148:                          "{0.reason}".format(event))
  149: 
  150:         def connection_check_out_started(self, event):
  151:             logging.info("[pool {0.address}] connection check out "
  152:                          "started".format(event))
  153: 
  154:         def connection_check_out_failed(self, event):
  155:             logging.info("[pool {0.address}] connection check out "
  156:                          "failed, reason: {0.reason}".format(event))
  157: 
  158:         def connection_checked_out(self, event):
  159:             logging.info("[pool {0.address}][connection #{0.connection_id}] "
  160:                          "connection checked out of pool".format(event))
  161: 
  162:         def connection_checked_in(self, event):
  163:             logging.info("[pool {0.address}][connection #{0.connection_id}] "
  164:                          "connection checked into pool".format(event))
  165: 
  166: 
  167: Event listeners can also be registered per instance of
  168: :class:`~pymongo.mongo_client.MongoClient`::
  169: 
  170:     client = MongoClient(event_listeners=[CommandLogger()])
  171: 
  172: Note that previously registered global listeners are automatically included
  173: when configuring per client event listeners. Registering a new global listener
  174: will not add that listener to existing client instances.
  175: 
  176: .. note:: Events are delivered **synchronously**. Application threads block
  177:   waiting for event handlers (e.g. :meth:`~CommandListener.started`) to
  178:   return. Care must be taken to ensure that your event handlers are efficient
  179:   enough to not adversely affect overall application performance.
  180: 
  181: .. warning:: The command documents published through this API are *not* copies.
  182:   If you intend to modify them in any way you must copy them in your event
  183:   handler first.
  184: """
  185: 
  186: from __future__ import annotations
  187: 
  188: import datetime
  189: from collections import abc, namedtuple
  190: from typing import TYPE_CHECKING, Any, Mapping, Optional, Sequence
  191: 
  192: from bson.objectid import ObjectId
  193: from pymongo.hello import Hello, HelloCompat
  194: from pymongo.helpers import _SENSITIVE_COMMANDS, _handle_exception
  195: from pymongo.typings import _Address, _DocumentOut
  196: 
  197: if TYPE_CHECKING:
  198:     from datetime import timedelta
  199: 
  200:     from pymongo.server_description import ServerDescription
  201:     from pymongo.topology_description import TopologyDescription
  202: 
  203: 
  204: _Listeners = namedtuple(
  205:     "_Listeners",
  206:     (
  207:         "command_listeners",
  208:         "server_listeners",
  209:         "server_heartbeat_listeners",
  210:         "topology_listeners",
  211:         "cmap_listeners",
  212:     ),
  213: )
  214: 
  215: _LISTENERS = _Listeners([], [], [], [], [])
  216: 
  217: 
  218: class _EventListener:
  219:     """Abstract base class for all event listeners."""
  220: 
  221: 
  222: class CommandListener(_EventListener):
  223:     """Abstract base class for command listeners.
  224: 
  225:     Handles `CommandStartedEvent`, `CommandSucceededEvent`,
  226:     and `CommandFailedEvent`.
  227:     """
  228: 
  229:     def started(self, event: CommandStartedEvent) -> None:
  230:         """Abstract method to handle a `CommandStartedEvent`.
  231: 
  232:         :param event: An instance of :class:`CommandStartedEvent`.
  233:         """
  234:         raise NotImplementedError
  235: 
  236:     def succeeded(self, event: CommandSucceededEvent) -> None:
  237:         """Abstract method to handle a `CommandSucceededEvent`.
  238: 
  239:         :param event: An instance of :class:`CommandSucceededEvent`.
  240:         """
  241:         raise NotImplementedError
  242: 
  243:     def failed(self, event: CommandFailedEvent) -> None:
  244:         """Abstract method to handle a `CommandFailedEvent`.
  245: 
  246:         :param event: An instance of :class:`CommandFailedEvent`.
  247:         """
  248:         raise NotImplementedError
  249: 
  250: 
  251: class ConnectionPoolListener(_EventListener):
  252:     """Abstract base class for connection pool listeners.
  253: 
  254:     Handles all of the connection pool events defined in the Connection
  255:     Monitoring and Pooling Specification:
  256:     :class:`PoolCreatedEvent`, :class:`PoolClearedEvent`,
  257:     :class:`PoolClosedEvent`, :class:`ConnectionCreatedEvent`,
  258:     :class:`ConnectionReadyEvent`, :class:`ConnectionClosedEvent`,
  259:     :class:`ConnectionCheckOutStartedEvent`,
  260:     :class:`ConnectionCheckOutFailedEvent`,
  261:     :class:`ConnectionCheckedOutEvent`,
  262:     and :class:`ConnectionCheckedInEvent`.
  263: 
  264:     .. versionadded:: 3.9
  265:     """
  266: 
  267:     def pool_created(self, event: PoolCreatedEvent) -> None:
  268:         """Abstract method to handle a :class:`PoolCreatedEvent`.
  269: 
  270:         Emitted when a connection Pool is created.
  271: 
  272:         :param event: An instance of :class:`PoolCreatedEvent`.
  273:         """
  274:         raise NotImplementedError
  275: 
  276:     def pool_ready(self, event: PoolReadyEvent) -> None:
  277:         """Abstract method to handle a :class:`PoolReadyEvent`.
  278: 
  279:         Emitted when a connection Pool is marked ready.
  280: 
  281:         :param event: An instance of :class:`PoolReadyEvent`.
  282: 
  283:         .. versionadded:: 4.0
  284:         """
  285:         raise NotImplementedError
  286: 
  287:     def pool_cleared(self, event: PoolClearedEvent) -> None:
  288:         """Abstract method to handle a `PoolClearedEvent`.
  289: 
  290:         Emitted when a connection Pool is cleared.
  291: 
  292:         :param event: An instance of :class:`PoolClearedEvent`.
  293:         """
  294:         raise NotImplementedError
  295: 
  296:     def pool_closed(self, event: PoolClosedEvent) -> None:
  297:         """Abstract method to handle a `PoolClosedEvent`.
  298: 
  299:         Emitted when a connection Pool is closed.
  300: 
  301:         :param event: An instance of :class:`PoolClosedEvent`.
  302:         """
  303:         raise NotImplementedError
  304: 
  305:     def connection_created(self, event: ConnectionCreatedEvent) -> None:
  306:         """Abstract method to handle a :class:`ConnectionCreatedEvent`.
  307: 
  308:         Emitted when a connection Pool creates a Connection object.
  309: 
  310:         :param event: An instance of :class:`ConnectionCreatedEvent`.
  311:         """
  312:         raise NotImplementedError
  313: 
  314:     def connection_ready(self, event: ConnectionReadyEvent) -> None:
  315:         """Abstract method to handle a :class:`ConnectionReadyEvent`.
  316: 
  317:         Emitted when a connection has finished its setup, and is now ready to
  318:         use.
  319: 
  320:         :param event: An instance of :class:`ConnectionReadyEvent`.
  321:         """
  322:         raise NotImplementedError
  323: 
  324:     def connection_closed(self, event: ConnectionClosedEvent) -> None:
  325:         """Abstract method to handle a :class:`ConnectionClosedEvent`.
  326: 
  327:         Emitted when a connection Pool closes a connection.
  328: 
  329:         :param event: An instance of :class:`ConnectionClosedEvent`.
  330:         """
  331:         raise NotImplementedError
  332: 
  333:     def connection_check_out_started(self, event: ConnectionCheckOutStartedEvent) -> None:
  334:         """Abstract method to handle a :class:`ConnectionCheckOutStartedEvent`.
  335: 
  336:         Emitted when the driver starts attempting to check out a connection.
  337: 
  338:         :param event: An instance of :class:`ConnectionCheckOutStartedEvent`.
  339:         """
  340:         raise NotImplementedError
  341: 
  342:     def connection_check_out_failed(self, event: ConnectionCheckOutFailedEvent) -> None:
  343:         """Abstract method to handle a :class:`ConnectionCheckOutFailedEvent`.
  344: 
  345:         Emitted when the driver's attempt to check out a connection fails.
  346: 
  347:         :param event: An instance of :class:`ConnectionCheckOutFailedEvent`.
  348:         """
  349:         raise NotImplementedError
  350: 
  351:     def connection_checked_out(self, event: ConnectionCheckedOutEvent) -> None:
  352:         """Abstract method to handle a :class:`ConnectionCheckedOutEvent`.
  353: 
  354:         Emitted when the driver successfully checks out a connection.
  355: 
  356:         :param event: An instance of :class:`ConnectionCheckedOutEvent`.
  357:         """
  358:         raise NotImplementedError
  359: 
  360:     def connection_checked_in(self, event: ConnectionCheckedInEvent) -> None:
  361:         """Abstract method to handle a :class:`ConnectionCheckedInEvent`.
  362: 
  363:         Emitted when the driver checks in a connection back to the connection
  364:         Pool.
  365: 
  366:         :param event: An instance of :class:`ConnectionCheckedInEvent`.
  367:         """
  368:         raise NotImplementedError
  369: 
  370: 
  371: class ServerHeartbeatListener(_EventListener):
  372:     """Abstract base class for server heartbeat listeners.
  373: 
  374:     Handles `ServerHeartbeatStartedEvent`, `ServerHeartbeatSucceededEvent`,
  375:     and `ServerHeartbeatFailedEvent`.
  376: 
  377:     .. versionadded:: 3.3
  378:     """
  379: 
  380:     def started(self, event: ServerHeartbeatStartedEvent) -> None:
  381:         """Abstract method to handle a `ServerHeartbeatStartedEvent`.
  382: 
  383:         :param event: An instance of :class:`ServerHeartbeatStartedEvent`.
  384:         """
  385:         raise NotImplementedError
  386: 
  387:     def succeeded(self, event: ServerHeartbeatSucceededEvent) -> None:
  388:         """Abstract method to handle a `ServerHeartbeatSucceededEvent`.
  389: 
  390:         :param event: An instance of :class:`ServerHeartbeatSucceededEvent`.
  391:         """
  392:         raise NotImplementedError
  393: 
  394:     def failed(self, event: ServerHeartbeatFailedEvent) -> None:
  395:         """Abstract method to handle a `ServerHeartbeatFailedEvent`.
  396: 
  397:         :param event: An instance of :class:`ServerHeartbeatFailedEvent`.
  398:         """
  399:         raise NotImplementedError
  400: 
  401: 
  402: class TopologyListener(_EventListener):
  403:     """Abstract base class for topology monitoring listeners.
  404:     Handles `TopologyOpenedEvent`, `TopologyDescriptionChangedEvent`, and
  405:     `TopologyClosedEvent`.
  406: 
  407:     .. versionadded:: 3.3
  408:     """
  409: 
  410:     def opened(self, event: TopologyOpenedEvent) -> None:
  411:         """Abstract method to handle a `TopologyOpenedEvent`.
  412: 
  413:         :param event: An instance of :class:`TopologyOpenedEvent`.
  414:         """
  415:         raise NotImplementedError
  416: 
  417:     def description_changed(self, event: TopologyDescriptionChangedEvent) -> None:
  418:         """Abstract method to handle a `TopologyDescriptionChangedEvent`.
  419: 
  420:         :param event: An instance of :class:`TopologyDescriptionChangedEvent`.
  421:         """
  422:         raise NotImplementedError
  423: 
  424:     def closed(self, event: TopologyClosedEvent) -> None:
  425:         """Abstract method to handle a `TopologyClosedEvent`.
  426: 
  427:         :param event: An instance of :class:`TopologyClosedEvent`.
  428:         """
  429:         raise NotImplementedError
  430: 
  431: 
  432: class ServerListener(_EventListener):
  433:     """Abstract base class for server listeners.
  434:     Handles `ServerOpeningEvent`, `ServerDescriptionChangedEvent`, and
  435:     `ServerClosedEvent`.
  436: 
  437:     .. versionadded:: 3.3
  438:     """
  439: 
  440:     def opened(self, event: ServerOpeningEvent) -> None:
  441:         """Abstract method to handle a `ServerOpeningEvent`.
  442: 
  443:         :param event: An instance of :class:`ServerOpeningEvent`.
  444:         """
  445:         raise NotImplementedError
  446: 
  447:     def description_changed(self, event: ServerDescriptionChangedEvent) -> None:
  448:         """Abstract method to handle a `ServerDescriptionChangedEvent`.
  449: 
  450:         :param event: An instance of :class:`ServerDescriptionChangedEvent`.
  451:         """
  452:         raise NotImplementedError
  453: 
  454:     def closed(self, event: ServerClosedEvent) -> None:
  455:         """Abstract method to handle a `ServerClosedEvent`.
  456: 
  457:         :param event: An instance of :class:`ServerClosedEvent`.
  458:         """
  459:         raise NotImplementedError
  460: 
  461: 
  462: def _to_micros(dur: timedelta) -> int:
  463:     """Convert duration 'dur' to microseconds."""
  464:     return int(dur.total_seconds() * 10e5)
  465: 
  466: 
  467: def _validate_event_listeners(
  468:     option: str, listeners: Sequence[_EventListeners]
  469: ) -> Sequence[_EventListeners]:
  470:     """Validate event listeners"""
  471:     if not isinstance(listeners, abc.Sequence):
  472:         raise TypeError(f"{option} must be a list or tuple")
  473:     for listener in listeners:
  474:         if not isinstance(listener, _EventListener):
  475:             raise TypeError(
  476:                 f"Listeners for {option} must be either a "
  477:                 "CommandListener, ServerHeartbeatListener, "
  478:                 "ServerListener, TopologyListener, or "
  479:                 "ConnectionPoolListener."
  480:             )
  481:     return listeners
  482: 
  483: 
  484: def register(listener: _EventListener) -> None:
  485:     """Register a global event listener.
  486: 
  487:     :param listener: A subclasses of :class:`CommandListener`,
  488:         :class:`ServerHeartbeatListener`, :class:`ServerListener`,
  489:         :class:`TopologyListener`, or :class:`ConnectionPoolListener`.
  490:     """
  491:     if not isinstance(listener, _EventListener):
  492:         raise TypeError(
  493:             f"Listeners for {listener} must be either a "
  494:             "CommandListener, ServerHeartbeatListener, "
  495:             "ServerListener, TopologyListener, or "
  496:             "ConnectionPoolListener."
  497:         )
  498:     if isinstance(listener, CommandListener):
  499:         _LISTENERS.command_listeners.append(listener)
  500:     if isinstance(listener, ServerHeartbeatListener):
  501:         _LISTENERS.server_heartbeat_listeners.append(listener)
  502:     if isinstance(listener, ServerListener):
  503:         _LISTENERS.server_listeners.append(listener)
  504:     if isinstance(listener, TopologyListener):
  505:         _LISTENERS.topology_listeners.append(listener)
  506:     if isinstance(listener, ConnectionPoolListener):
  507:         _LISTENERS.cmap_listeners.append(listener)
  508: 
  509: 
  510: # The "hello" command is also deemed sensitive when attempting speculative
  511: # authentication.
  512: def _is_speculative_authenticate(command_name: str, doc: Mapping[str, Any]) -> bool:
  513:     if (
  514:         command_name.lower() in ("hello", HelloCompat.LEGACY_CMD)
  515:         and "speculativeAuthenticate" in doc
  516:     ):
  517:         return True
  518:     return False
  519: 
  520: 
  521: class _CommandEvent:
  522:     """Base class for command events."""
  523: 
  524:     __slots__ = (
  525:         "__cmd_name",
  526:         "__rqst_id",
  527:         "__conn_id",
  528:         "__op_id",
  529:         "__service_id",
  530:         "__db",
  531:         "__server_conn_id",
  532:     )
  533: 
  534:     def __init__(
  535:         self,
  536:         command_name: str,
  537:         request_id: int,
  538:         connection_id: _Address,
  539:         operation_id: Optional[int],
  540:         service_id: Optional[ObjectId] = None,
  541:         database_name: str = "",
  542:         server_connection_id: Optional[int] = None,
  543:     ) -> None:
  544:         self.__cmd_name = command_name
  545:         self.__rqst_id = request_id
  546:         self.__conn_id = connection_id
  547:         self.__op_id = operation_id
  548:         self.__service_id = service_id
  549:         self.__db = database_name
  550:         self.__server_conn_id = server_connection_id
  551: 
  552:     @property
  553:     def command_name(self) -> str:
  554:         """The command name."""
  555:         return self.__cmd_name
  556: 
  557:     @property
  558:     def request_id(self) -> int:
  559:         """The request id for this operation."""
  560:         return self.__rqst_id
  561: 
  562:     @property
  563:     def connection_id(self) -> _Address:
  564:         """The address (host, port) of the server this command was sent to."""
  565:         return self.__conn_id
  566: 
  567:     @property
  568:     def service_id(self) -> Optional[ObjectId]:
  569:         """The service_id this command was sent to, or ``None``.
  570: 
  571:         .. versionadded:: 3.12
  572:         """
  573:         return self.__service_id
  574: 
  575:     @property
  576:     def operation_id(self) -> Optional[int]:
  577:         """An id for this series of events or None."""
  578:         return self.__op_id
  579: 
  580:     @property
  581:     def database_name(self) -> str:
  582:         """The database_name this command was sent to, or ``""``.
  583: 
  584:         .. versionadded:: 4.6
  585:         """
  586:         return self.__db
  587: 
  588:     @property
  589:     def server_connection_id(self) -> Optional[int]:
  590:         """The server-side connection id for the connection this command was sent on, or ``None``.
  591: 
  592:         .. versionadded:: 4.7
  593:         """
  594:         return self.__server_conn_id
  595: 
  596: 
  597: class CommandStartedEvent(_CommandEvent):
  598:     """Event published when a command starts.
  599: 
  600:     :param command: The command document.
  601:     :param database_name: The name of the database this command was run against.
  602:     :param request_id: The request id for this operation.
  603:     :param connection_id: The address (host, port) of the server this command
  604:         was sent to.
  605:     :param operation_id: An optional identifier for a series of related events.
  606:     :param service_id: The service_id this command was sent to, or ``None``.
  607:     """
  608: 
  609:     __slots__ = ("__cmd",)
  610: 
  611:     def __init__(
  612:         self,
  613:         command: _DocumentOut,
  614:         database_name: str,
  615:         request_id: int,
  616:         connection_id: _Address,
  617:         operation_id: Optional[int],
  618:         service_id: Optional[ObjectId] = None,
  619:         server_connection_id: Optional[int] = None,
  620:     ) -> None:
  621:         if not command:
  622:             raise ValueError(f"{command!r} is not a valid command")
  623:         # Command name must be first key.
  624:         command_name = next(iter(command))
  625:         super().__init__(
  626:             command_name,
  627:             request_id,
  628:             connection_id,
  629:             operation_id,
  630:             service_id=service_id,
  631:             database_name=database_name,
  632:             server_connection_id=server_connection_id,
  633:         )
  634:         cmd_name = command_name.lower()
  635:         if cmd_name in _SENSITIVE_COMMANDS or _is_speculative_authenticate(cmd_name, command):
  636:             self.__cmd: _DocumentOut = {}
  637:         else:
  638:             self.__cmd = command
  639: 
  640:     @property
  641:     def command(self) -> _DocumentOut:
  642:         """The command document."""
  643:         return self.__cmd
  644: 
  645:     @property
  646:     def database_name(self) -> str:
  647:         """The name of the database this command was run against."""
  648:         return super().database_name
  649: 
  650:     def __repr__(self) -> str:
  651:         return (
  652:             "<{} {} db: {!r}, command: {!r}, operation_id: {}, service_id: {}, server_connection_id: {}>"
  653:         ).format(
  654:             self.__class__.__name__,
  655:             self.connection_id,
  656:             self.database_name,
  657:             self.command_name,
  658:             self.operation_id,
  659:             self.service_id,
  660:             self.server_connection_id,
  661:         )
  662: 
  663: 
  664: class CommandSucceededEvent(_CommandEvent):
  665:     """Event published when a command succeeds.
  666: 
  667:     :param duration: The command duration as a datetime.timedelta.
  668:     :param reply: The server reply document.
  669:     :param command_name: The command name.
  670:     :param request_id: The request id for this operation.
  671:     :param connection_id: The address (host, port) of the server this command
  672:         was sent to.
  673:     :param operation_id: An optional identifier for a series of related events.
  674:     :param service_id: The service_id this command was sent to, or ``None``.
  675:     :param database_name: The database this command was sent to, or ``""``.
  676:     """
  677: 
  678:     __slots__ = ("__duration_micros", "__reply")
  679: 
  680:     def __init__(
  681:         self,
  682:         duration: datetime.timedelta,
  683:         reply: _DocumentOut,
  684:         command_name: str,
  685:         request_id: int,
  686:         connection_id: _Address,
  687:         operation_id: Optional[int],
  688:         service_id: Optional[ObjectId] = None,
  689:         database_name: str = "",
  690:         server_connection_id: Optional[int] = None,
  691:     ) -> None:
  692:         super().__init__(
  693:             command_name,
  694:             request_id,
  695:             connection_id,
  696:             operation_id,
  697:             service_id=service_id,
  698:             database_name=database_name,
  699:             server_connection_id=server_connection_id,
  700:         )
  701:         self.__duration_micros = _to_micros(duration)
  702:         cmd_name = command_name.lower()
  703:         if cmd_name in _SENSITIVE_COMMANDS or _is_speculative_authenticate(cmd_name, reply):
  704:             self.__reply: _DocumentOut = {}
  705:         else:
  706:             self.__reply = reply
  707: 
  708:     @property
  709:     def duration_micros(self) -> int:
  710:         """The duration of this operation in microseconds."""
  711:         return self.__duration_micros
  712: 
  713:     @property
  714:     def reply(self) -> _DocumentOut:
  715:         """The server failure document for this operation."""
  716:         return self.__reply
  717: 
  718:     def __repr__(self) -> str:
  719:         return (
  720:             "<{} {} db: {!r}, command: {!r}, operation_id: {}, duration_micros: {}, service_id: {}, server_connection_id: {}>"
  721:         ).format(
  722:             self.__class__.__name__,
  723:             self.connection_id,
  724:             self.database_name,
  725:             self.command_name,
  726:             self.operation_id,
  727:             self.duration_micros,
  728:             self.service_id,
  729:             self.server_connection_id,
  730:         )
  731: 
  732: 
  733: class CommandFailedEvent(_CommandEvent):
  734:     """Event published when a command fails.
  735: 
  736:     :param duration: The command duration as a datetime.timedelta.
  737:     :param failure: The server reply document.
  738:     :param command_name: The command name.
  739:     :param request_id: The request id for this operation.
  740:     :param connection_id: The address (host, port) of the server this command
  741:         was sent to.
  742:     :param operation_id: An optional identifier for a series of related events.
  743:     :param service_id: The service_id this command was sent to, or ``None``.
  744:     :param database_name: The database this command was sent to, or ``""``.
  745:     """
  746: 
  747:     __slots__ = ("__duration_micros", "__failure")
  748: 
  749:     def __init__(
  750:         self,
  751:         duration: datetime.timedelta,
  752:         failure: _DocumentOut,
  753:         command_name: str,
  754:         request_id: int,
  755:         connection_id: _Address,
  756:         operation_id: Optional[int],
  757:         service_id: Optional[ObjectId] = None,
  758:         database_name: str = "",
  759:         server_connection_id: Optional[int] = None,
  760:     ) -> None:
  761:         super().__init__(
  762:             command_name,
  763:             request_id,
  764:             connection_id,
  765:             operation_id,
  766:             service_id=service_id,
  767:             database_name=database_name,
  768:             server_connection_id=server_connection_id,
  769:         )
  770:         self.__duration_micros = _to_micros(duration)
  771:         self.__failure = failure
  772: 
  773:     @property
  774:     def duration_micros(self) -> int:
  775:         """The duration of this operation in microseconds."""
  776:         return self.__duration_micros
  777: 
  778:     @property
  779:     def failure(self) -> _DocumentOut:
  780:         """The server failure document for this operation."""
  781:         return self.__failure
  782: 
  783:     def __repr__(self) -> str:
  784:         return (
  785:             "<{} {} db: {!r}, command: {!r}, operation_id: {}, duration_micros: {}, "
  786:             "failure: {!r}, service_id: {}, server_connection_id: {}>"
  787:         ).format(
  788:             self.__class__.__name__,
  789:             self.connection_id,
  790:             self.database_name,
  791:             self.command_name,
  792:             self.operation_id,
  793:             self.duration_micros,
  794:             self.failure,
  795:             self.service_id,
  796:             self.server_connection_id,
  797:         )
  798: 
  799: 
  800: class _PoolEvent:
  801:     """Base class for pool events."""
  802: 
  803:     __slots__ = ("__address",)
  804: 
  805:     def __init__(self, address: _Address) -> None:
  806:         self.__address = address
  807: 
  808:     @property
  809:     def address(self) -> _Address:
  810:         """The address (host, port) pair of the server the pool is attempting
  811:         to connect to.
  812:         """
  813:         return self.__address
  814: 
  815:     def __repr__(self) -> str:
  816:         return f"{self.__class__.__name__}({self.__address!r})"
  817: 
  818: 
  819: class PoolCreatedEvent(_PoolEvent):
  820:     """Published when a Connection Pool is created.
  821: 
  822:     :param address: The address (host, port) pair of the server this Pool is
  823:        attempting to connect to.
  824: 
  825:     .. versionadded:: 3.9
  826:     """
  827: 
  828:     __slots__ = ("__options",)
  829: 
  830:     def __init__(self, address: _Address, options: dict[str, Any]) -> None:
  831:         super().__init__(address)
  832:         self.__options = options
  833: 
  834:     @property
  835:     def options(self) -> dict[str, Any]:
  836:         """Any non-default pool options that were set on this Connection Pool."""
  837:         return self.__options
  838: 
  839:     def __repr__(self) -> str:
  840:         return f"{self.__class__.__name__}({self.address!r}, {self.__options!r})"
  841: 
  842: 
  843: class PoolReadyEvent(_PoolEvent):
  844:     """Published when a Connection Pool is marked ready.
  845: 
  846:     :param address: The address (host, port) pair of the server this Pool is
  847:        attempting to connect to.
  848: 
  849:     .. versionadded:: 4.0
  850:     """
  851: 
  852:     __slots__ = ()
  853: 
  854: 
  855: class PoolClearedEvent(_PoolEvent):
  856:     """Published when a Connection Pool is cleared.
  857: 
  858:     :param address: The address (host, port) pair of the server this Pool is
  859:        attempting to connect to.
  860:     :param service_id: The service_id this command was sent to, or ``None``.
  861:     :param interrupt_connections: True if all active connections were interrupted by the Pool during clearing.
  862: 
  863:     .. versionadded:: 3.9
  864:     """
  865: 
  866:     __slots__ = ("__service_id", "__interrupt_connections")
  867: 
  868:     def __init__(
  869:         self,
  870:         address: _Address,
  871:         service_id: Optional[ObjectId] = None,
  872:         interrupt_connections: bool = False,
  873:     ) -> None:
  874:         super().__init__(address)
  875:         self.__service_id = service_id
  876:         self.__interrupt_connections = interrupt_connections
  877: 
  878:     @property
  879:     def service_id(self) -> Optional[ObjectId]:
  880:         """Connections with this service_id are cleared.
  881: 
  882:         When service_id is ``None``, all connections in the pool are cleared.
  883: 
  884:         .. versionadded:: 3.12
  885:         """
  886:         return self.__service_id
  887: 
  888:     @property
  889:     def interrupt_connections(self) -> bool:
  890:         """If True, active connections are interrupted during clearing.
  891: 
  892:         .. versionadded:: 4.7
  893:         """
  894:         return self.__interrupt_connections
  895: 
  896:     def __repr__(self) -> str:
  897:         return f"{self.__class__.__name__}({self.address!r}, {self.__service_id!r}, {self.__interrupt_connections!r})"
  898: 
  899: 
  900: class PoolClosedEvent(_PoolEvent):
  901:     """Published when a Connection Pool is closed.
  902: 
  903:     :param address: The address (host, port) pair of the server this Pool is
  904:        attempting to connect to.
  905: 
  906:     .. versionadded:: 3.9
  907:     """
  908: 
  909:     __slots__ = ()
  910: 
  911: 
  912: class ConnectionClosedReason:
  913:     """An enum that defines values for `reason` on a
  914:     :class:`ConnectionClosedEvent`.
  915: 
  916:     .. versionadded:: 3.9
  917:     """
  918: 
  919:     STALE = "stale"
  920:     """The pool was cleared, making the connection no longer valid."""
  921: 
  922:     IDLE = "idle"
  923:     """The connection became stale by being idle for too long (maxIdleTimeMS).
  924:     """
  925: 
  926:     ERROR = "error"
  927:     """The connection experienced an error, making it no longer valid."""
  928: 
  929:     POOL_CLOSED = "poolClosed"
  930:     """The pool was closed, making the connection no longer valid."""
  931: 
  932: 
  933: class ConnectionCheckOutFailedReason:
  934:     """An enum that defines values for `reason` on a
  935:     :class:`ConnectionCheckOutFailedEvent`.
  936: 
  937:     .. versionadded:: 3.9
  938:     """
  939: 
  940:     TIMEOUT = "timeout"
  941:     """The connection check out attempt exceeded the specified timeout."""
  942: 
  943:     POOL_CLOSED = "poolClosed"
  944:     """The pool was previously closed, and cannot provide new connections."""
  945: 
  946:     CONN_ERROR = "connectionError"
  947:     """The connection check out attempt experienced an error while setting up
  948:     a new connection.
  949:     """
  950: 
  951: 
  952: class _ConnectionEvent:
  953:     """Private base class for connection events."""
  954: 
  955:     __slots__ = ("__address",)
  956: 
  957:     def __init__(self, address: _Address) -> None:
  958:         self.__address = address
  959: 
  960:     @property
  961:     def address(self) -> _Address:
  962:         """The address (host, port) pair of the server this connection is
  963:         attempting to connect to.
  964:         """
  965:         return self.__address
  966: 
  967:     def __repr__(self) -> str:
  968:         return f"{self.__class__.__name__}({self.__address!r})"
  969: 
  970: 
  971: class _ConnectionIdEvent(_ConnectionEvent):
  972:     """Private base class for connection events with an id."""
  973: 
  974:     __slots__ = ("__connection_id",)
  975: 
  976:     def __init__(self, address: _Address, connection_id: int) -> None:
  977:         super().__init__(address)
  978:         self.__connection_id = connection_id
  979: 
  980:     @property
  981:     def connection_id(self) -> int:
  982:         """The ID of the connection."""
  983:         return self.__connection_id
  984: 
  985:     def __repr__(self) -> str:
  986:         return f"{self.__class__.__name__}({self.address!r}, {self.__connection_id!r})"
  987: 
  988: 
  989: class _ConnectionDurationEvent(_ConnectionIdEvent):
  990:     """Private base class for connection events with a duration."""
  991: 
  992:     __slots__ = ("__duration",)
  993: 
  994:     def __init__(self, address: _Address, connection_id: int, duration: Optional[float]) -> None:
  995:         super().__init__(address, connection_id)
  996:         self.__duration = duration
  997: 
  998:     @property
  999:     def duration(self) -> Optional[float]:
 1000:         """The duration of the connection event.
 1001: 
 1002:         .. versionadded:: 4.7
 1003:         """
 1004:         return self.__duration
 1005: 
 1006:     def __repr__(self) -> str:
 1007:         return f"{self.__class__.__name__}({self.address!r}, {self.connection_id!r}, {self.__duration!r})"
 1008: 
 1009: 
 1010: class ConnectionCreatedEvent(_ConnectionIdEvent):
 1011:     """Published when a Connection Pool creates a Connection object.
 1012: 
 1013:     NOTE: This connection is not ready for use until the
 1014:     :class:`ConnectionReadyEvent` is published.
 1015: 
 1016:     :param address: The address (host, port) pair of the server this
 1017:        Connection is attempting to connect to.
 1018:     :param connection_id: The integer ID of the Connection in this Pool.
 1019: 
 1020:     .. versionadded:: 3.9
 1021:     """
 1022: 
 1023:     __slots__ = ()
 1024: 
 1025: 
 1026: class ConnectionReadyEvent(_ConnectionDurationEvent):
 1027:     """Published when a Connection has finished its setup, and is ready to use.
 1028: 
 1029:     :param address: The address (host, port) pair of the server this
 1030:        Connection is attempting to connect to.
 1031:     :param connection_id: The integer ID of the Connection in this Pool.
 1032: 
 1033:     .. versionadded:: 3.9
 1034:     """
 1035: 
 1036:     __slots__ = ()
 1037: 
 1038: 
 1039: class ConnectionClosedEvent(_ConnectionIdEvent):
 1040:     """Published when a Connection is closed.
 1041: 
 1042:     :param address: The address (host, port) pair of the server this
 1043:        Connection is attempting to connect to.
 1044:     :param connection_id: The integer ID of the Connection in this Pool.
 1045:     :param reason: A reason explaining why this connection was closed.
 1046: 
 1047:     .. versionadded:: 3.9
 1048:     """
 1049: 
 1050:     __slots__ = ("__reason",)
 1051: 
 1052:     def __init__(self, address: _Address, connection_id: int, reason: str):
 1053:         super().__init__(address, connection_id)
 1054:         self.__reason = reason
 1055: 
 1056:     @property
 1057:     def reason(self) -> str:
 1058:         """A reason explaining why this connection was closed.
 1059: 
 1060:         The reason must be one of the strings from the
 1061:         :class:`ConnectionClosedReason` enum.
 1062:         """
 1063:         return self.__reason
 1064: 
 1065:     def __repr__(self) -> str:
 1066:         return "{}({!r}, {!r}, {!r})".format(
 1067:             self.__class__.__name__,
 1068:             self.address,
 1069:             self.connection_id,
 1070:             self.__reason,
 1071:         )
 1072: 
 1073: 
 1074: class ConnectionCheckOutStartedEvent(_ConnectionEvent):
 1075:     """Published when the driver starts attempting to check out a connection.
 1076: 
 1077:     :param address: The address (host, port) pair of the server this
 1078:        Connection is attempting to connect to.
 1079: 
 1080:     .. versionadded:: 3.9
 1081:     """
 1082: 
 1083:     __slots__ = ()
 1084: 
 1085: 
 1086: class ConnectionCheckOutFailedEvent(_ConnectionDurationEvent):
 1087:     """Published when the driver's attempt to check out a connection fails.
 1088: 
 1089:     :param address: The address (host, port) pair of the server this
 1090:        Connection is attempting to connect to.
 1091:     :param reason: A reason explaining why connection check out failed.
 1092: 
 1093:     .. versionadded:: 3.9
 1094:     """
 1095: 
 1096:     __slots__ = ("__reason",)
 1097: 
 1098:     def __init__(self, address: _Address, reason: str, duration: Optional[float]) -> None:
 1099:         super().__init__(address=address, connection_id=0, duration=duration)
 1100:         self.__reason = reason
 1101: 
 1102:     @property
 1103:     def reason(self) -> str:
 1104:         """A reason explaining why connection check out failed.
 1105: 
 1106:         The reason must be one of the strings from the
 1107:         :class:`ConnectionCheckOutFailedReason` enum.
 1108:         """
 1109:         return self.__reason
 1110: 
 1111:     def __repr__(self) -> str:
 1112:         return f"{self.__class__.__name__}({self.address!r}, {self.__reason!r}, {self.duration!r})"
 1113: 
 1114: 
 1115: class ConnectionCheckedOutEvent(_ConnectionDurationEvent):
 1116:     """Published when the driver successfully checks out a connection.
 1117: 
 1118:     :param address: The address (host, port) pair of the server this
 1119:        Connection is attempting to connect to.
 1120:     :param connection_id: The integer ID of the Connection in this Pool.
 1121: 
 1122:     .. versionadded:: 3.9
 1123:     """
 1124: 
 1125:     __slots__ = ()
 1126: 
 1127: 
 1128: class ConnectionCheckedInEvent(_ConnectionIdEvent):
 1129:     """Published when the driver checks in a Connection into the Pool.
 1130: 
 1131:     :param address: The address (host, port) pair of the server this
 1132:        Connection is attempting to connect to.
 1133:     :param connection_id: The integer ID of the Connection in this Pool.
 1134: 
 1135:     .. versionadded:: 3.9
 1136:     """
 1137: 
 1138:     __slots__ = ()
 1139: 
 1140: 
 1141: class _ServerEvent:
 1142:     """Base class for server events."""
 1143: 
 1144:     __slots__ = ("__server_address", "__topology_id")
 1145: 
 1146:     def __init__(self, server_address: _Address, topology_id: ObjectId) -> None:
 1147:         self.__server_address = server_address
 1148:         self.__topology_id = topology_id
 1149: 
 1150:     @property
 1151:     def server_address(self) -> _Address:
 1152:         """The address (host, port) pair of the server"""
 1153:         return self.__server_address
 1154: 
 1155:     @property
 1156:     def topology_id(self) -> ObjectId:
 1157:         """A unique identifier for the topology this server is a part of."""
 1158:         return self.__topology_id
 1159: 
 1160:     def __repr__(self) -> str:
 1161:         return f"<{self.__class__.__name__} {self.server_address} topology_id: {self.topology_id}>"
 1162: 
 1163: 
 1164: class ServerDescriptionChangedEvent(_ServerEvent):
 1165:     """Published when server description changes.
 1166: 
 1167:     .. versionadded:: 3.3
 1168:     """
 1169: 
 1170:     __slots__ = ("__previous_description", "__new_description")
 1171: 
 1172:     def __init__(
 1173:         self,
 1174:         previous_description: ServerDescription,
 1175:         new_description: ServerDescription,
 1176:         *args: Any,
 1177:     ) -> None:
 1178:         super().__init__(*args)
 1179:         self.__previous_description = previous_description
 1180:         self.__new_description = new_description
 1181: 
 1182:     @property
 1183:     def previous_description(self) -> ServerDescription:
 1184:         """The previous
 1185:         :class:`~pymongo.server_description.ServerDescription`.
 1186:         """
 1187:         return self.__previous_description
 1188: 
 1189:     @property
 1190:     def new_description(self) -> ServerDescription:
 1191:         """The new
 1192:         :class:`~pymongo.server_description.ServerDescription`.
 1193:         """
 1194:         return self.__new_description
 1195: 
 1196:     def __repr__(self) -> str:
 1197:         return "<{} {} changed from: {}, to: {}>".format(
 1198:             self.__class__.__name__,
 1199:             self.server_address,
 1200:             self.previous_description,
 1201:             self.new_description,
 1202:         )
 1203: 
 1204: 
 1205: class ServerOpeningEvent(_ServerEvent):
 1206:     """Published when server is initialized.
 1207: 
 1208:     .. versionadded:: 3.3
 1209:     """
 1210: 
 1211:     __slots__ = ()
 1212: 
 1213: 
 1214: class ServerClosedEvent(_ServerEvent):
 1215:     """Published when server is closed.
 1216: 
 1217:     .. versionadded:: 3.3
 1218:     """
 1219: 
 1220:     __slots__ = ()
 1221: 
 1222: 
 1223: class TopologyEvent:
 1224:     """Base class for topology description events."""
 1225: 
 1226:     __slots__ = ("__topology_id",)
 1227: 
 1228:     def __init__(self, topology_id: ObjectId) -> None:
 1229:         self.__topology_id = topology_id
 1230: 
 1231:     @property
 1232:     def topology_id(self) -> ObjectId:
 1233:         """A unique identifier for the topology this server is a part of."""
 1234:         return self.__topology_id
 1235: 
 1236:     def __repr__(self) -> str:
 1237:         return f"<{self.__class__.__name__} topology_id: {self.topology_id}>"
 1238: 
 1239: 
 1240: class TopologyDescriptionChangedEvent(TopologyEvent):
 1241:     """Published when the topology description changes.
 1242: 
 1243:     .. versionadded:: 3.3
 1244:     """
 1245: 
 1246:     __slots__ = ("__previous_description", "__new_description")
 1247: 
 1248:     def __init__(
 1249:         self,
 1250:         previous_description: TopologyDescription,
 1251:         new_description: TopologyDescription,
 1252:         *args: Any,
 1253:     ) -> None:
 1254:         super().__init__(*args)
 1255:         self.__previous_description = previous_description
 1256:         self.__new_description = new_description
 1257: 
 1258:     @property
 1259:     def previous_description(self) -> TopologyDescription:
 1260:         """The previous
 1261:         :class:`~pymongo.topology_description.TopologyDescription`.
 1262:         """
 1263:         return self.__previous_description
 1264: 
 1265:     @property
 1266:     def new_description(self) -> TopologyDescription:
 1267:         """The new
 1268:         :class:`~pymongo.topology_description.TopologyDescription`.
 1269:         """
 1270:         return self.__new_description
 1271: 
 1272:     def __repr__(self) -> str:
 1273:         return "<{} topology_id: {} changed from: {}, to: {}>".format(
 1274:             self.__class__.__name__,
 1275:             self.topology_id,
 1276:             self.previous_description,
 1277:             self.new_description,
 1278:         )
 1279: 
 1280: 
 1281: class TopologyOpenedEvent(TopologyEvent):
 1282:     """Published when the topology is initialized.
 1283: 
 1284:     .. versionadded:: 3.3
 1285:     """
 1286: 
 1287:     __slots__ = ()
 1288: 
 1289: 
 1290: class TopologyClosedEvent(TopologyEvent):
 1291:     """Published when the topology is closed.
 1292: 
 1293:     .. versionadded:: 3.3
 1294:     """
 1295: 
 1296:     __slots__ = ()
 1297: 
 1298: 
 1299: class _ServerHeartbeatEvent:
 1300:     """Base class for server heartbeat events."""
 1301: 
 1302:     __slots__ = ("__connection_id", "__awaited")
 1303: 
 1304:     def __init__(self, connection_id: _Address, awaited: bool = False) -> None:
 1305:         self.__connection_id = connection_id
 1306:         self.__awaited = awaited
 1307: 
 1308:     @property
 1309:     def connection_id(self) -> _Address:
 1310:         """The address (host, port) of the server this heartbeat was sent
 1311:         to.
 1312:         """
 1313:         return self.__connection_id
 1314: 
 1315:     @property
 1316:     def awaited(self) -> bool:
 1317:         """Whether the heartbeat was issued as an awaitable hello command.
 1318: 
 1319:         .. versionadded:: 4.6
 1320:         """
 1321:         return self.__awaited
 1322: 
 1323:     def __repr__(self) -> str:
 1324:         return f"<{self.__class__.__name__} {self.connection_id} awaited: {self.awaited}>"
 1325: 
 1326: 
 1327: class ServerHeartbeatStartedEvent(_ServerHeartbeatEvent):
 1328:     """Published when a heartbeat is started.
 1329: 
 1330:     .. versionadded:: 3.3
 1331:     """
 1332: 
 1333:     __slots__ = ()
 1334: 
 1335: 
 1336: class ServerHeartbeatSucceededEvent(_ServerHeartbeatEvent):
 1337:     """Fired when the server heartbeat succeeds.
 1338: 
 1339:     .. versionadded:: 3.3
 1340:     """
 1341: 
 1342:     __slots__ = ("__duration", "__reply")
 1343: 
 1344:     def __init__(
 1345:         self, duration: float, reply: Hello, connection_id: _Address, awaited: bool = False
 1346:     ) -> None:
 1347:         super().__init__(connection_id, awaited)
 1348:         self.__duration = duration
 1349:         self.__reply = reply
 1350: 
 1351:     @property
 1352:     def duration(self) -> float:
 1353:         """The duration of this heartbeat in microseconds."""
 1354:         return self.__duration
 1355: 
 1356:     @property
 1357:     def reply(self) -> Hello:
 1358:         """An instance of :class:`~pymongo.hello.Hello`."""
 1359:         return self.__reply
 1360: 
 1361:     @property
 1362:     def awaited(self) -> bool:
 1363:         """Whether the heartbeat was awaited.
 1364: 
 1365:         If true, then :meth:`duration` reflects the sum of the round trip time
 1366:         to the server and the time that the server waited before sending a
 1367:         response.
 1368: 
 1369:         .. versionadded:: 3.11
 1370:         """
 1371:         return super().awaited
 1372: 
 1373:     def __repr__(self) -> str:
 1374:         return "<{} {} duration: {}, awaited: {}, reply: {}>".format(
 1375:             self.__class__.__name__,
 1376:             self.connection_id,
 1377:             self.duration,
 1378:             self.awaited,
 1379:             self.reply,
 1380:         )
 1381: 
 1382: 
 1383: class ServerHeartbeatFailedEvent(_ServerHeartbeatEvent):
 1384:     """Fired when the server heartbeat fails, either with an "ok: 0"
 1385:     or a socket exception.
 1386: 
 1387:     .. versionadded:: 3.3
 1388:     """
 1389: 
 1390:     __slots__ = ("__duration", "__reply")
 1391: 
 1392:     def __init__(
 1393:         self, duration: float, reply: Exception, connection_id: _Address, awaited: bool = False
 1394:     ) -> None:
 1395:         super().__init__(connection_id, awaited)
 1396:         self.__duration = duration
 1397:         self.__reply = reply
 1398: 
 1399:     @property
 1400:     def duration(self) -> float:
 1401:         """The duration of this heartbeat in microseconds."""
 1402:         return self.__duration
 1403: 
 1404:     @property
 1405:     def reply(self) -> Exception:
 1406:         """A subclass of :exc:`Exception`."""
 1407:         return self.__reply
 1408: 
 1409:     @property
 1410:     def awaited(self) -> bool:
 1411:         """Whether the heartbeat was awaited.
 1412: 
 1413:         If true, then :meth:`duration` reflects the sum of the round trip time
 1414:         to the server and the time that the server waited before sending a
 1415:         response.
 1416: 
 1417:         .. versionadded:: 3.11
 1418:         """
 1419:         return super().awaited
 1420: 
 1421:     def __repr__(self) -> str:
 1422:         return "<{} {} duration: {}, awaited: {}, reply: {!r}>".format(
 1423:             self.__class__.__name__,
 1424:             self.connection_id,
 1425:             self.duration,
 1426:             self.awaited,
 1427:             self.reply,
 1428:         )
 1429: 
 1430: 
 1431: class _EventListeners:
 1432:     """Configure event listeners for a client instance.
 1433: 
 1434:     Any event listeners registered globally are included by default.
 1435: 
 1436:     :param listeners: A list of event listeners.
 1437:     """
 1438: 
 1439:     def __init__(self, listeners: Optional[Sequence[_EventListener]]):
 1440:         self.__command_listeners = _LISTENERS.command_listeners[:]
 1441:         self.__server_listeners = _LISTENERS.server_listeners[:]
 1442:         lst = _LISTENERS.server_heartbeat_listeners
 1443:         self.__server_heartbeat_listeners = lst[:]
 1444:         self.__topology_listeners = _LISTENERS.topology_listeners[:]
 1445:         self.__cmap_listeners = _LISTENERS.cmap_listeners[:]
 1446:         if listeners is not None:
 1447:             for lst in listeners:
 1448:                 if isinstance(lst, CommandListener):
 1449:                     self.__command_listeners.append(lst)
 1450:                 if isinstance(lst, ServerListener):
 1451:                     self.__server_listeners.append(lst)
 1452:                 if isinstance(lst, ServerHeartbeatListener):
 1453:                     self.__server_heartbeat_listeners.append(lst)
 1454:                 if isinstance(lst, TopologyListener):
 1455:                     self.__topology_listeners.append(lst)
 1456:                 if isinstance(lst, ConnectionPoolListener):
 1457:                     self.__cmap_listeners.append(lst)
 1458:         self.__enabled_for_commands = bool(self.__command_listeners)
 1459:         self.__enabled_for_server = bool(self.__server_listeners)
 1460:         self.__enabled_for_server_heartbeat = bool(self.__server_heartbeat_listeners)
 1461:         self.__enabled_for_topology = bool(self.__topology_listeners)
 1462:         self.__enabled_for_cmap = bool(self.__cmap_listeners)
 1463: 
 1464:     @property
 1465:     def enabled_for_commands(self) -> bool:
 1466:         """Are any CommandListener instances registered?"""
 1467:         return self.__enabled_for_commands
 1468: 
 1469:     @property
 1470:     def enabled_for_server(self) -> bool:
 1471:         """Are any ServerListener instances registered?"""
 1472:         return self.__enabled_for_server
 1473: 
 1474:     @property
 1475:     def enabled_for_server_heartbeat(self) -> bool:
 1476:         """Are any ServerHeartbeatListener instances registered?"""
 1477:         return self.__enabled_for_server_heartbeat
 1478: 
 1479:     @property
 1480:     def enabled_for_topology(self) -> bool:
 1481:         """Are any TopologyListener instances registered?"""
 1482:         return self.__enabled_for_topology
 1483: 
 1484:     @property
 1485:     def enabled_for_cmap(self) -> bool:
 1486:         """Are any ConnectionPoolListener instances registered?"""
 1487:         return self.__enabled_for_cmap
 1488: 
 1489:     def event_listeners(self) -> list[_EventListeners]:
 1490:         """List of registered event listeners."""
 1491:         return (
 1492:             self.__command_listeners
 1493:             + self.__server_heartbeat_listeners
 1494:             + self.__server_listeners
 1495:             + self.__topology_listeners
 1496:             + self.__cmap_listeners
 1497:         )
 1498: 
 1499:     def publish_command_start(
 1500:         self,
 1501:         command: _DocumentOut,
 1502:         database_name: str,
 1503:         request_id: int,
 1504:         connection_id: _Address,
 1505:         server_connection_id: Optional[int],
 1506:         op_id: Optional[int] = None,
 1507:         service_id: Optional[ObjectId] = None,
 1508:     ) -> None:
 1509:         """Publish a CommandStartedEvent to all command listeners.
 1510: 
 1511:         :param command: The command document.
 1512:         :param database_name: The name of the database this command was run
 1513:             against.
 1514:         :param request_id: The request id for this operation.
 1515:         :param connection_id: The address (host, port) of the server this
 1516:             command was sent to.
 1517:         :param op_id: The (optional) operation id for this operation.
 1518:         :param service_id: The service_id this command was sent to, or ``None``.
 1519:         """
 1520:         if op_id is None:
 1521:             op_id = request_id
 1522:         event = CommandStartedEvent(
 1523:             command,
 1524:             database_name,
 1525:             request_id,
 1526:             connection_id,
 1527:             op_id,
 1528:             service_id=service_id,
 1529:             server_connection_id=server_connection_id,
 1530:         )
 1531:         for subscriber in self.__command_listeners:
 1532:             try:
 1533:                 subscriber.started(event)
 1534:             except Exception:
 1535:                 _handle_exception()
 1536: 
 1537:     def publish_command_success(
 1538:         self,
 1539:         duration: timedelta,
 1540:         reply: _DocumentOut,
 1541:         command_name: str,
 1542:         request_id: int,
 1543:         connection_id: _Address,
 1544:         server_connection_id: Optional[int],
 1545:         op_id: Optional[int] = None,
 1546:         service_id: Optional[ObjectId] = None,
 1547:         speculative_hello: bool = False,
 1548:         database_name: str = "",
 1549:     ) -> None:
 1550:         """Publish a CommandSucceededEvent to all command listeners.
 1551: 
 1552:         :param duration: The command duration as a datetime.timedelta.
 1553:         :param reply: The server reply document.
 1554:         :param command_name: The command name.
 1555:         :param request_id: The request id for this operation.
 1556:         :param connection_id: The address (host, port) of the server this
 1557:             command was sent to.
 1558:         :param op_id: The (optional) operation id for this operation.
 1559:         :param service_id: The service_id this command was sent to, or ``None``.
 1560:         :param speculative_hello: Was the command sent with speculative auth?
 1561:         :param database_name: The database this command was sent to, or ``""``.
 1562:         """
 1563:         if op_id is None:
 1564:             op_id = request_id
 1565:         if speculative_hello:
 1566:             # Redact entire response when the command started contained
 1567:             # speculativeAuthenticate.
 1568:             reply = {}
 1569:         event = CommandSucceededEvent(
 1570:             duration,
 1571:             reply,
 1572:             command_name,
 1573:             request_id,
 1574:             connection_id,
 1575:             op_id,
 1576:             service_id,
 1577:             database_name=database_name,
 1578:             server_connection_id=server_connection_id,
 1579:         )
 1580:         for subscriber in self.__command_listeners:
 1581:             try:
 1582:                 subscriber.succeeded(event)
 1583:             except Exception:
 1584:                 _handle_exception()
 1585: 
 1586:     def publish_command_failure(
 1587:         self,
 1588:         duration: timedelta,
 1589:         failure: _DocumentOut,
 1590:         command_name: str,
 1591:         request_id: int,
 1592:         connection_id: _Address,
 1593:         server_connection_id: Optional[int],
 1594:         op_id: Optional[int] = None,
 1595:         service_id: Optional[ObjectId] = None,
 1596:         database_name: str = "",
 1597:     ) -> None:
 1598:         """Publish a CommandFailedEvent to all command listeners.
 1599: 
 1600:         :param duration: The command duration as a datetime.timedelta.
 1601:         :param failure: The server reply document or failure description
 1602:             document.
 1603:         :param command_name: The command name.
 1604:         :param request_id: The request id for this operation.
 1605:         :param connection_id: The address (host, port) of the server this
 1606:             command was sent to.
 1607:         :param op_id: The (optional) operation id for this operation.
 1608:         :param service_id: The service_id this command was sent to, or ``None``.
 1609:         :param database_name: The database this command was sent to, or ``""``.
 1610:         """
 1611:         if op_id is None:
 1612:             op_id = request_id
 1613:         event = CommandFailedEvent(
 1614:             duration,
 1615:             failure,
 1616:             command_name,
 1617:             request_id,
 1618:             connection_id,
 1619:             op_id,
 1620:             service_id=service_id,
 1621:             database_name=database_name,
 1622:             server_connection_id=server_connection_id,
 1623:         )
 1624:         for subscriber in self.__command_listeners:
 1625:             try:
 1626:                 subscriber.failed(event)
 1627:             except Exception:
 1628:                 _handle_exception()
 1629: 
 1630:     def publish_server_heartbeat_started(self, connection_id: _Address, awaited: bool) -> None:
 1631:         """Publish a ServerHeartbeatStartedEvent to all server heartbeat
 1632:         listeners.
 1633: 
 1634:         :param connection_id: The address (host, port) pair of the connection.
 1635:         :param awaited: True if this heartbeat is part of an awaitable hello command.
 1636:         """
 1637:         event = ServerHeartbeatStartedEvent(connection_id, awaited)
 1638:         for subscriber in self.__server_heartbeat_listeners:
 1639:             try:
 1640:                 subscriber.started(event)
 1641:             except Exception:
 1642:                 _handle_exception()
 1643: 
 1644:     def publish_server_heartbeat_succeeded(
 1645:         self, connection_id: _Address, duration: float, reply: Hello, awaited: bool
 1646:     ) -> None:
 1647:         """Publish a ServerHeartbeatSucceededEvent to all server heartbeat
 1648:         listeners.
 1649: 
 1650:         :param connection_id: The address (host, port) pair of the connection.
 1651:         :param duration: The execution time of the event in the highest possible
 1652:             resolution for the platform.
 1653:         :param reply: The command reply.
 1654:         :param awaited: True if the response was awaited.
 1655:         """
 1656:         event = ServerHeartbeatSucceededEvent(duration, reply, connection_id, awaited)
 1657:         for subscriber in self.__server_heartbeat_listeners:
 1658:             try:
 1659:                 subscriber.succeeded(event)
 1660:             except Exception:
 1661:                 _handle_exception()
 1662: 
 1663:     def publish_server_heartbeat_failed(
 1664:         self, connection_id: _Address, duration: float, reply: Exception, awaited: bool
 1665:     ) -> None:
 1666:         """Publish a ServerHeartbeatFailedEvent to all server heartbeat
 1667:         listeners.
 1668: 
 1669:         :param connection_id: The address (host, port) pair of the connection.
 1670:         :param duration: The execution time of the event in the highest possible
 1671:             resolution for the platform.
 1672:         :param reply: The command reply.
 1673:         :param awaited: True if the response was awaited.
 1674:         """
 1675:         event = ServerHeartbeatFailedEvent(duration, reply, connection_id, awaited)
 1676:         for subscriber in self.__server_heartbeat_listeners:
 1677:             try:
 1678:                 subscriber.failed(event)
 1679:             except Exception:
 1680:                 _handle_exception()
 1681: 
 1682:     def publish_server_opened(self, server_address: _Address, topology_id: ObjectId) -> None:
 1683:         """Publish a ServerOpeningEvent to all server listeners.
 1684: 
 1685:         :param server_address: The address (host, port) pair of the server.
 1686:         :param topology_id: A unique identifier for the topology this server
 1687:            is a part of.
 1688:         """
 1689:         event = ServerOpeningEvent(server_address, topology_id)
 1690:         for subscriber in self.__server_listeners:
 1691:             try:
 1692:                 subscriber.opened(event)
 1693:             except Exception:
 1694:                 _handle_exception()
 1695: 
 1696:     def publish_server_closed(self, server_address: _Address, topology_id: ObjectId) -> None:
 1697:         """Publish a ServerClosedEvent to all server listeners.
 1698: 
 1699:         :param server_address: The address (host, port) pair of the server.
 1700:         :param topology_id: A unique identifier for the topology this server
 1701:            is a part of.
 1702:         """
 1703:         event = ServerClosedEvent(server_address, topology_id)
 1704:         for subscriber in self.__server_listeners:
 1705:             try:
 1706:                 subscriber.closed(event)
 1707:             except Exception:
 1708:                 _handle_exception()
 1709: 
 1710:     def publish_server_description_changed(
 1711:         self,
 1712:         previous_description: ServerDescription,
 1713:         new_description: ServerDescription,
 1714:         server_address: _Address,
 1715:         topology_id: ObjectId,
 1716:     ) -> None:
 1717:         """Publish a ServerDescriptionChangedEvent to all server listeners.
 1718: 
 1719:         :param previous_description: The previous server description.
 1720:         :param server_address: The address (host, port) pair of the server.
 1721:         :param new_description: The new server description.
 1722:         :param topology_id: A unique identifier for the topology this server
 1723:            is a part of.
 1724:         """
 1725:         event = ServerDescriptionChangedEvent(
 1726:             previous_description, new_description, server_address, topology_id
 1727:         )
 1728:         for subscriber in self.__server_listeners:
 1729:             try:
 1730:                 subscriber.description_changed(event)
 1731:             except Exception:
 1732:                 _handle_exception()
 1733: 
 1734:     def publish_topology_opened(self, topology_id: ObjectId) -> None:
 1735:         """Publish a TopologyOpenedEvent to all topology listeners.
 1736: 
 1737:         :param topology_id: A unique identifier for the topology this server
 1738:            is a part of.
 1739:         """
 1740:         event = TopologyOpenedEvent(topology_id)
 1741:         for subscriber in self.__topology_listeners:
 1742:             try:
 1743:                 subscriber.opened(event)
 1744:             except Exception:
 1745:                 _handle_exception()
 1746: 
 1747:     def publish_topology_closed(self, topology_id: ObjectId) -> None:
 1748:         """Publish a TopologyClosedEvent to all topology listeners.
 1749: 
 1750:         :param topology_id: A unique identifier for the topology this server
 1751:            is a part of.
 1752:         """
 1753:         event = TopologyClosedEvent(topology_id)
 1754:         for subscriber in self.__topology_listeners:
 1755:             try:
 1756:                 subscriber.closed(event)
 1757:             except Exception:
 1758:                 _handle_exception()
 1759: 
 1760:     def publish_topology_description_changed(
 1761:         self,
 1762:         previous_description: TopologyDescription,
 1763:         new_description: TopologyDescription,
 1764:         topology_id: ObjectId,
 1765:     ) -> None:
 1766:         """Publish a TopologyDescriptionChangedEvent to all topology listeners.
 1767: 
 1768:         :param previous_description: The previous topology description.
 1769:         :param new_description: The new topology description.
 1770:         :param topology_id: A unique identifier for the topology this server
 1771:            is a part of.
 1772:         """
 1773:         event = TopologyDescriptionChangedEvent(previous_description, new_description, topology_id)
 1774:         for subscriber in self.__topology_listeners:
 1775:             try:
 1776:                 subscriber.description_changed(event)
 1777:             except Exception:
 1778:                 _handle_exception()
 1779: 
 1780:     def publish_pool_created(self, address: _Address, options: dict[str, Any]) -> None:
 1781:         """Publish a :class:`PoolCreatedEvent` to all pool listeners."""
 1782:         event = PoolCreatedEvent(address, options)
 1783:         for subscriber in self.__cmap_listeners:
 1784:             try:
 1785:                 subscriber.pool_created(event)
 1786:             except Exception:
 1787:                 _handle_exception()
 1788: 
 1789:     def publish_pool_ready(self, address: _Address) -> None:
 1790:         """Publish a :class:`PoolReadyEvent` to all pool listeners."""
 1791:         event = PoolReadyEvent(address)
 1792:         for subscriber in self.__cmap_listeners:
 1793:             try:
 1794:                 subscriber.pool_ready(event)
 1795:             except Exception:
 1796:                 _handle_exception()
 1797: 
 1798:     def publish_pool_cleared(
 1799:         self,
 1800:         address: _Address,
 1801:         service_id: Optional[ObjectId],
 1802:         interrupt_connections: bool = False,
 1803:     ) -> None:
 1804:         """Publish a :class:`PoolClearedEvent` to all pool listeners."""
 1805:         event = PoolClearedEvent(address, service_id, interrupt_connections)
 1806:         for subscriber in self.__cmap_listeners:
 1807:             try:
 1808:                 subscriber.pool_cleared(event)
 1809:             except Exception:
 1810:                 _handle_exception()
 1811: 
 1812:     def publish_pool_closed(self, address: _Address) -> None:
 1813:         """Publish a :class:`PoolClosedEvent` to all pool listeners."""
 1814:         event = PoolClosedEvent(address)
 1815:         for subscriber in self.__cmap_listeners:
 1816:             try:
 1817:                 subscriber.pool_closed(event)
 1818:             except Exception:
 1819:                 _handle_exception()
 1820: 
 1821:     def publish_connection_created(self, address: _Address, connection_id: int) -> None:
 1822:         """Publish a :class:`ConnectionCreatedEvent` to all connection
 1823:         listeners.
 1824:         """
 1825:         event = ConnectionCreatedEvent(address, connection_id)
 1826:         for subscriber in self.__cmap_listeners:
 1827:             try:
 1828:                 subscriber.connection_created(event)
 1829:             except Exception:
 1830:                 _handle_exception()
 1831: 
 1832:     def publish_connection_ready(
 1833:         self, address: _Address, connection_id: int, duration: float
 1834:     ) -> None:
 1835:         """Publish a :class:`ConnectionReadyEvent` to all connection listeners."""
 1836:         event = ConnectionReadyEvent(address, connection_id, duration)
 1837:         for subscriber in self.__cmap_listeners:
 1838:             try:
 1839:                 subscriber.connection_ready(event)
 1840:             except Exception:
 1841:                 _handle_exception()
 1842: 
 1843:     def publish_connection_closed(self, address: _Address, connection_id: int, reason: str) -> None:
 1844:         """Publish a :class:`ConnectionClosedEvent` to all connection
 1845:         listeners.
 1846:         """
 1847:         event = ConnectionClosedEvent(address, connection_id, reason)
 1848:         for subscriber in self.__cmap_listeners:
 1849:             try:
 1850:                 subscriber.connection_closed(event)
 1851:             except Exception:
 1852:                 _handle_exception()
 1853: 
 1854:     def publish_connection_check_out_started(self, address: _Address) -> None:
 1855:         """Publish a :class:`ConnectionCheckOutStartedEvent` to all connection
 1856:         listeners.
 1857:         """
 1858:         event = ConnectionCheckOutStartedEvent(address)
 1859:         for subscriber in self.__cmap_listeners:
 1860:             try:
 1861:                 subscriber.connection_check_out_started(event)
 1862:             except Exception:
 1863:                 _handle_exception()
 1864: 
 1865:     def publish_connection_check_out_failed(
 1866:         self, address: _Address, reason: str, duration: float
 1867:     ) -> None:
 1868:         """Publish a :class:`ConnectionCheckOutFailedEvent` to all connection
 1869:         listeners.
 1870:         """
 1871:         event = ConnectionCheckOutFailedEvent(address, reason, duration)
 1872:         for subscriber in self.__cmap_listeners:
 1873:             try:
 1874:                 subscriber.connection_check_out_failed(event)
 1875:             except Exception:
 1876:                 _handle_exception()
 1877: 
 1878:     def publish_connection_checked_out(
 1879:         self, address: _Address, connection_id: int, duration: float
 1880:     ) -> None:
 1881:         """Publish a :class:`ConnectionCheckedOutEvent` to all connection
 1882:         listeners.
 1883:         """
 1884:         event = ConnectionCheckedOutEvent(address, connection_id, duration)
 1885:         for subscriber in self.__cmap_listeners:
 1886:             try:
 1887:                 subscriber.connection_checked_out(event)
 1888:             except Exception:
 1889:                 _handle_exception()
 1890: 
 1891:     def publish_connection_checked_in(self, address: _Address, connection_id: int) -> None:
 1892:         """Publish a :class:`ConnectionCheckedInEvent` to all connection
 1893:         listeners.
 1894:         """
 1895:         event = ConnectionCheckedInEvent(address, connection_id)
 1896:         for subscriber in self.__cmap_listeners:
 1897:             try:
 1898:                 subscriber.connection_checked_in(event)
 1899:             except Exception:
 1900:                 _handle_exception()
