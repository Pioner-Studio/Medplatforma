    1: # Copyright 2013-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Authentication helpers."""
   16: from __future__ import annotations
   17: 
   18: import functools
   19: import hashlib
   20: import hmac
   21: import os
   22: import socket
   23: import typing
   24: from base64 import standard_b64decode, standard_b64encode
   25: from collections import namedtuple
   26: from typing import (
   27:     TYPE_CHECKING,
   28:     Any,
   29:     Callable,
   30:     Dict,
   31:     Mapping,
   32:     MutableMapping,
   33:     Optional,
   34:     cast,
   35: )
   36: from urllib.parse import quote
   37: 
   38: from bson.binary import Binary
   39: from pymongo.auth_aws import _authenticate_aws
   40: from pymongo.auth_oidc import (
   41:     _authenticate_oidc,
   42:     _get_authenticator,
   43:     _OIDCAzureCallback,
   44:     _OIDCGCPCallback,
   45:     _OIDCProperties,
   46:     _OIDCTestCallback,
   47: )
   48: from pymongo.errors import ConfigurationError, OperationFailure
   49: from pymongo.saslprep import saslprep
   50: 
   51: if TYPE_CHECKING:
   52:     from pymongo.hello import Hello
   53:     from pymongo.pool import Connection
   54: 
   55: HAVE_KERBEROS = True
   56: _USE_PRINCIPAL = False
   57: try:
   58:     import winkerberos as kerberos  # type:ignore[import]
   59: 
   60:     if tuple(map(int, kerberos.__version__.split(".")[:2])) >= (0, 5):
   61:         _USE_PRINCIPAL = True
   62: except ImportError:
   63:     try:
   64:         import kerberos  # type:ignore[import]
   65:     except ImportError:
   66:         HAVE_KERBEROS = False
   67: 
   68: 
   69: MECHANISMS = frozenset(
   70:     [
   71:         "GSSAPI",
   72:         "MONGODB-CR",
   73:         "MONGODB-OIDC",
   74:         "MONGODB-X509",
   75:         "MONGODB-AWS",
   76:         "PLAIN",
   77:         "SCRAM-SHA-1",
   78:         "SCRAM-SHA-256",
   79:         "DEFAULT",
   80:     ]
   81: )
   82: """The authentication mechanisms supported by PyMongo."""
   83: 
   84: 
   85: class _Cache:
   86:     __slots__ = ("data",)
   87: 
   88:     _hash_val = hash("_Cache")
   89: 
   90:     def __init__(self) -> None:
   91:         self.data = None
   92: 
   93:     def __eq__(self, other: object) -> bool:
   94:         # Two instances must always compare equal.
   95:         if isinstance(other, _Cache):
   96:             return True
   97:         return NotImplemented
   98: 
   99:     def __ne__(self, other: object) -> bool:
  100:         if isinstance(other, _Cache):
  101:             return False
  102:         return NotImplemented
  103: 
  104:     def __hash__(self) -> int:
  105:         return self._hash_val
  106: 
  107: 
  108: MongoCredential = namedtuple(
  109:     "MongoCredential",
  110:     ["mechanism", "source", "username", "password", "mechanism_properties", "cache"],
  111: )
  112: """A hashable namedtuple of values used for authentication."""
  113: 
  114: 
  115: GSSAPIProperties = namedtuple(
  116:     "GSSAPIProperties", ["service_name", "canonicalize_host_name", "service_realm"]
  117: )
  118: """Mechanism properties for GSSAPI authentication."""
  119: 
  120: 
  121: _AWSProperties = namedtuple("_AWSProperties", ["aws_session_token"])
  122: """Mechanism properties for MONGODB-AWS authentication."""
  123: 
  124: 
  125: def _build_credentials_tuple(
  126:     mech: str,
  127:     source: Optional[str],
  128:     user: str,
  129:     passwd: str,
  130:     extra: Mapping[str, Any],
  131:     database: Optional[str],
  132: ) -> MongoCredential:
  133:     """Build and return a mechanism specific credentials tuple."""
  134:     if mech not in ("MONGODB-X509", "MONGODB-AWS", "MONGODB-OIDC") and user is None:
  135:         raise ConfigurationError(f"{mech} requires a username.")
  136:     if mech == "GSSAPI":
  137:         if source is not None and source != "$external":
  138:             raise ValueError("authentication source must be $external or None for GSSAPI")
  139:         properties = extra.get("authmechanismproperties", {})
  140:         service_name = properties.get("SERVICE_NAME", "mongodb")
  141:         canonicalize = bool(properties.get("CANONICALIZE_HOST_NAME", False))
  142:         service_realm = properties.get("SERVICE_REALM")
  143:         props = GSSAPIProperties(
  144:             service_name=service_name,
  145:             canonicalize_host_name=canonicalize,
  146:             service_realm=service_realm,
  147:         )
  148:         # Source is always $external.
  149:         return MongoCredential(mech, "$external", user, passwd, props, None)
  150:     elif mech == "MONGODB-X509":
  151:         if passwd is not None:
  152:             raise ConfigurationError("Passwords are not supported by MONGODB-X509")
  153:         if source is not None and source != "$external":
  154:             raise ValueError("authentication source must be $external or None for MONGODB-X509")
  155:         # Source is always $external, user can be None.
  156:         return MongoCredential(mech, "$external", user, None, None, None)
  157:     elif mech == "MONGODB-AWS":
  158:         if user is not None and passwd is None:
  159:             raise ConfigurationError("username without a password is not supported by MONGODB-AWS")
  160:         if source is not None and source != "$external":
  161:             raise ConfigurationError(
  162:                 "authentication source must be $external or None for MONGODB-AWS"
  163:             )
  164: 
  165:         properties = extra.get("authmechanismproperties", {})
  166:         aws_session_token = properties.get("AWS_SESSION_TOKEN")
  167:         aws_props = _AWSProperties(aws_session_token=aws_session_token)
  168:         # user can be None for temporary link-local EC2 credentials.
  169:         return MongoCredential(mech, "$external", user, passwd, aws_props, None)
  170:     elif mech == "MONGODB-OIDC":
  171:         properties = extra.get("authmechanismproperties", {})
  172:         callback = properties.get("OIDC_CALLBACK")
  173:         human_callback = properties.get("OIDC_HUMAN_CALLBACK")
  174:         environ = properties.get("ENVIRONMENT")
  175:         token_resource = properties.get("TOKEN_RESOURCE", "")
  176:         default_allowed = [
  177:             "*.mongodb.net",
  178:             "*.mongodb-dev.net",
  179:             "*.mongodb-qa.net",
  180:             "*.mongodbgov.net",
  181:             "localhost",
  182:             "127.0.0.1",
  183:             "::1",
  184:         ]
  185:         allowed_hosts = properties.get("ALLOWED_HOSTS", default_allowed)
  186:         msg = (
  187:             "authentication with MONGODB-OIDC requires providing either a callback or a environment"
  188:         )
  189:         if passwd is not None:
  190:             msg = "password is not supported by MONGODB-OIDC"
  191:             raise ConfigurationError(msg)
  192:         if callback or human_callback:
  193:             if environ is not None:
  194:                 raise ConfigurationError(msg)
  195:             if callback and human_callback:
  196:                 msg = "cannot set both OIDC_CALLBACK and OIDC_HUMAN_CALLBACK"
  197:                 raise ConfigurationError(msg)
  198:         elif environ is not None:
  199:             if environ == "test":
  200:                 if user is not None:
  201:                     msg = "test environment for MONGODB-OIDC does not support username"
  202:                     raise ConfigurationError(msg)
  203:                 callback = _OIDCTestCallback()
  204:             elif environ == "azure":
  205:                 passwd = None
  206:                 if not token_resource:
  207:                     raise ConfigurationError(
  208:                         "Azure environment for MONGODB-OIDC requires a TOKEN_RESOURCE auth mechanism property"
  209:                     )
  210:                 callback = _OIDCAzureCallback(token_resource)
  211:             elif environ == "gcp":
  212:                 passwd = None
  213:                 if not token_resource:
  214:                     raise ConfigurationError(
  215:                         "GCP provider for MONGODB-OIDC requires a TOKEN_RESOURCE auth mechanism property"
  216:                     )
  217:                 callback = _OIDCGCPCallback(token_resource)
  218:             else:
  219:                 raise ConfigurationError(f"unrecognized ENVIRONMENT for MONGODB-OIDC: {environ}")
  220:         else:
  221:             raise ConfigurationError(msg)
  222: 
  223:         oidc_props = _OIDCProperties(
  224:             callback=callback,
  225:             human_callback=human_callback,
  226:             environment=environ,
  227:             allowed_hosts=allowed_hosts,
  228:             token_resource=token_resource,
  229:             username=user,
  230:         )
  231:         return MongoCredential(mech, "$external", user, passwd, oidc_props, _Cache())
  232: 
  233:     elif mech == "PLAIN":
  234:         source_database = source or database or "$external"
  235:         return MongoCredential(mech, source_database, user, passwd, None, None)
  236:     else:
  237:         source_database = source or database or "admin"
  238:         if passwd is None:
  239:             raise ConfigurationError("A password is required.")
  240:         return MongoCredential(mech, source_database, user, passwd, None, _Cache())
  241: 
  242: 
  243: def _xor(fir: bytes, sec: bytes) -> bytes:
  244:     """XOR two byte strings together."""
  245:     return b"".join([bytes([x ^ y]) for x, y in zip(fir, sec)])
  246: 
  247: 
  248: def _parse_scram_response(response: bytes) -> Dict[bytes, bytes]:
  249:     """Split a scram response into key, value pairs."""
  250:     return dict(
  251:         typing.cast(typing.Tuple[bytes, bytes], item.split(b"=", 1))
  252:         for item in response.split(b",")
  253:     )
  254: 
  255: 
  256: def _authenticate_scram_start(
  257:     credentials: MongoCredential, mechanism: str
  258: ) -> tuple[bytes, bytes, MutableMapping[str, Any]]:
  259:     username = credentials.username
  260:     user = username.encode("utf-8").replace(b"=", b"=3D").replace(b",", b"=2C")
  261:     nonce = standard_b64encode(os.urandom(32))
  262:     first_bare = b"n=" + user + b",r=" + nonce
  263: 
  264:     cmd = {
  265:         "saslStart": 1,
  266:         "mechanism": mechanism,
  267:         "payload": Binary(b"n,," + first_bare),
  268:         "autoAuthorize": 1,
  269:         "options": {"skipEmptyExchange": True},
  270:     }
  271:     return nonce, first_bare, cmd
  272: 
  273: 
  274: def _authenticate_scram(credentials: MongoCredential, conn: Connection, mechanism: str) -> None:
  275:     """Authenticate using SCRAM."""
  276:     username = credentials.username
  277:     if mechanism == "SCRAM-SHA-256":
  278:         digest = "sha256"
  279:         digestmod = hashlib.sha256
  280:         data = saslprep(credentials.password).encode("utf-8")
  281:     else:
  282:         digest = "sha1"
  283:         digestmod = hashlib.sha1
  284:         data = _password_digest(username, credentials.password).encode("utf-8")
  285:     source = credentials.source
  286:     cache = credentials.cache
  287: 
  288:     # Make local
  289:     _hmac = hmac.HMAC
  290: 
  291:     ctx = conn.auth_ctx
  292:     if ctx and ctx.speculate_succeeded():
  293:         assert isinstance(ctx, _ScramContext)
  294:         assert ctx.scram_data is not None
  295:         nonce, first_bare = ctx.scram_data
  296:         res = ctx.speculative_authenticate
  297:     else:
  298:         nonce, first_bare, cmd = _authenticate_scram_start(credentials, mechanism)
  299:         res = conn.command(source, cmd)
  300: 
  301:     assert res is not None
  302:     server_first = res["payload"]
  303:     parsed = _parse_scram_response(server_first)
  304:     iterations = int(parsed[b"i"])
  305:     if iterations < 4096:
  306:         raise OperationFailure("Server returned an invalid iteration count.")
  307:     salt = parsed[b"s"]
  308:     rnonce = parsed[b"r"]
  309:     if not rnonce.startswith(nonce):
  310:         raise OperationFailure("Server returned an invalid nonce.")
  311: 
  312:     without_proof = b"c=biws,r=" + rnonce
  313:     if cache.data:
  314:         client_key, server_key, csalt, citerations = cache.data
  315:     else:
  316:         client_key, server_key, csalt, citerations = None, None, None, None
  317: 
  318:     # Salt and / or iterations could change for a number of different
  319:     # reasons. Either changing invalidates the cache.
  320:     if not client_key or salt != csalt or iterations != citerations:
  321:         salted_pass = hashlib.pbkdf2_hmac(digest, data, standard_b64decode(salt), iterations)
  322:         client_key = _hmac(salted_pass, b"Client Key", digestmod).digest()
  323:         server_key = _hmac(salted_pass, b"Server Key", digestmod).digest()
  324:         cache.data = (client_key, server_key, salt, iterations)
  325:     stored_key = digestmod(client_key).digest()
  326:     auth_msg = b",".join((first_bare, server_first, without_proof))
  327:     client_sig = _hmac(stored_key, auth_msg, digestmod).digest()
  328:     client_proof = b"p=" + standard_b64encode(_xor(client_key, client_sig))
  329:     client_final = b",".join((without_proof, client_proof))
  330: 
  331:     server_sig = standard_b64encode(_hmac(server_key, auth_msg, digestmod).digest())
  332: 
  333:     cmd = {
  334:         "saslContinue": 1,
  335:         "conversationId": res["conversationId"],
  336:         "payload": Binary(client_final),
  337:     }
  338:     res = conn.command(source, cmd)
  339: 
  340:     parsed = _parse_scram_response(res["payload"])
  341:     if not hmac.compare_digest(parsed[b"v"], server_sig):
  342:         raise OperationFailure("Server returned an invalid signature.")
  343: 
  344:     # A third empty challenge may be required if the server does not support
  345:     # skipEmptyExchange: SERVER-44857.
  346:     if not res["done"]:
  347:         cmd = {
  348:             "saslContinue": 1,
  349:             "conversationId": res["conversationId"],
  350:             "payload": Binary(b""),
  351:         }
  352:         res = conn.command(source, cmd)
  353:         if not res["done"]:
  354:             raise OperationFailure("SASL conversation failed to complete.")
  355: 
  356: 
  357: def _password_digest(username: str, password: str) -> str:
  358:     """Get a password digest to use for authentication."""
  359:     if not isinstance(password, str):
  360:         raise TypeError("password must be an instance of str")
  361:     if len(password) == 0:
  362:         raise ValueError("password can't be empty")
  363:     if not isinstance(username, str):
  364:         raise TypeError("username must be an instance of str")
  365: 
  366:     md5hash = hashlib.md5()  # noqa: S324
  367:     data = f"{username}:mongo:{password}"
  368:     md5hash.update(data.encode("utf-8"))
  369:     return md5hash.hexdigest()
  370: 
  371: 
  372: def _auth_key(nonce: str, username: str, password: str) -> str:
  373:     """Get an auth key to use for authentication."""
  374:     digest = _password_digest(username, password)
  375:     md5hash = hashlib.md5()  # noqa: S324
  376:     data = f"{nonce}{username}{digest}"
  377:     md5hash.update(data.encode("utf-8"))
  378:     return md5hash.hexdigest()
  379: 
  380: 
  381: def _canonicalize_hostname(hostname: str) -> str:
  382:     """Canonicalize hostname following MIT-krb5 behavior."""
  383:     # https://github.com/krb5/krb5/blob/d406afa363554097ac48646a29249c04f498c88e/src/util/k5test.py#L505-L520
  384:     af, socktype, proto, canonname, sockaddr = socket.getaddrinfo(
  385:         hostname, None, 0, 0, socket.IPPROTO_TCP, socket.AI_CANONNAME
  386:     )[0]
  387: 
  388:     try:
  389:         name = socket.getnameinfo(sockaddr, socket.NI_NAMEREQD)
  390:     except socket.gaierror:
  391:         return canonname.lower()
  392: 
  393:     return name[0].lower()
  394: 
  395: 
  396: def _authenticate_gssapi(credentials: MongoCredential, conn: Connection) -> None:
  397:     """Authenticate using GSSAPI."""
  398:     if not HAVE_KERBEROS:
  399:         raise ConfigurationError(
  400:             'The "kerberos" module must be installed to use GSSAPI authentication.'
  401:         )
  402: 
  403:     try:
  404:         username = credentials.username
  405:         password = credentials.password
  406:         props = credentials.mechanism_properties
  407:         # Starting here and continuing through the while loop below - establish
  408:         # the security context. See RFC 4752, Section 3.1, first paragraph.
  409:         host = conn.address[0]
  410:         if props.canonicalize_host_name:
  411:             host = _canonicalize_hostname(host)
  412:         service = props.service_name + "@" + host
  413:         if props.service_realm is not None:
  414:             service = service + "@" + props.service_realm
  415: 
  416:         if password is not None:
  417:             if _USE_PRINCIPAL:
  418:                 # Note that, though we use unquote_plus for unquoting URI
  419:                 # options, we use quote here. Microsoft's UrlUnescape (used
  420:                 # by WinKerberos) doesn't support +.
  421:                 principal = ":".join((quote(username), quote(password)))
  422:                 result, ctx = kerberos.authGSSClientInit(
  423:                     service, principal, gssflags=kerberos.GSS_C_MUTUAL_FLAG
  424:                 )
  425:             else:
  426:                 if "@" in username:
  427:                     user, domain = username.split("@", 1)
  428:                 else:
  429:                     user, domain = username, None
  430:                 result, ctx = kerberos.authGSSClientInit(
  431:                     service,
  432:                     gssflags=kerberos.GSS_C_MUTUAL_FLAG,
  433:                     user=user,
  434:                     domain=domain,
  435:                     password=password,
  436:                 )
  437:         else:
  438:             result, ctx = kerberos.authGSSClientInit(service, gssflags=kerberos.GSS_C_MUTUAL_FLAG)
  439: 
  440:         if result != kerberos.AUTH_GSS_COMPLETE:
  441:             raise OperationFailure("Kerberos context failed to initialize.")
  442: 
  443:         try:
  444:             # pykerberos uses a weird mix of exceptions and return values
  445:             # to indicate errors.
  446:             # 0 == continue, 1 == complete, -1 == error
  447:             # Only authGSSClientStep can return 0.
  448:             if kerberos.authGSSClientStep(ctx, "") != 0:
  449:                 raise OperationFailure("Unknown kerberos failure in step function.")
  450: 
  451:             # Start a SASL conversation with mongod/s
  452:             # Note: pykerberos deals with base64 encoded byte strings.
  453:             # Since mongo accepts base64 strings as the payload we don't
  454:             # have to use bson.binary.Binary.
  455:             payload = kerberos.authGSSClientResponse(ctx)
  456:             cmd = {
  457:                 "saslStart": 1,
  458:                 "mechanism": "GSSAPI",
  459:                 "payload": payload,
  460:                 "autoAuthorize": 1,
  461:             }
  462:             response = conn.command("$external", cmd)
  463: 
  464:             # Limit how many times we loop to catch protocol / library issues
  465:             for _ in range(10):
  466:                 result = kerberos.authGSSClientStep(ctx, str(response["payload"]))
  467:                 if result == -1:
  468:                     raise OperationFailure("Unknown kerberos failure in step function.")
  469: 
  470:                 payload = kerberos.authGSSClientResponse(ctx) or ""
  471: 
  472:                 cmd = {
  473:                     "saslContinue": 1,
  474:                     "conversationId": response["conversationId"],
  475:                     "payload": payload,
  476:                 }
  477:                 response = conn.command("$external", cmd)
  478: 
  479:                 if result == kerberos.AUTH_GSS_COMPLETE:
  480:                     break
  481:             else:
  482:                 raise OperationFailure("Kerberos authentication failed to complete.")
  483: 
  484:             # Once the security context is established actually authenticate.
  485:             # See RFC 4752, Section 3.1, last two paragraphs.
  486:             if kerberos.authGSSClientUnwrap(ctx, str(response["payload"])) != 1:
  487:                 raise OperationFailure("Unknown kerberos failure during GSS_Unwrap step.")
  488: 
  489:             if kerberos.authGSSClientWrap(ctx, kerberos.authGSSClientResponse(ctx), username) != 1:
  490:                 raise OperationFailure("Unknown kerberos failure during GSS_Wrap step.")
  491: 
  492:             payload = kerberos.authGSSClientResponse(ctx)
  493:             cmd = {
  494:                 "saslContinue": 1,
  495:                 "conversationId": response["conversationId"],
  496:                 "payload": payload,
  497:             }
  498:             conn.command("$external", cmd)
  499: 
  500:         finally:
  501:             kerberos.authGSSClientClean(ctx)
  502: 
  503:     except kerberos.KrbError as exc:
  504:         raise OperationFailure(str(exc)) from None
  505: 
  506: 
  507: def _authenticate_plain(credentials: MongoCredential, conn: Connection) -> None:
  508:     """Authenticate using SASL PLAIN (RFC 4616)"""
  509:     source = credentials.source
  510:     username = credentials.username
  511:     password = credentials.password
  512:     payload = (f"\x00{username}\x00{password}").encode()
  513:     cmd = {
  514:         "saslStart": 1,
  515:         "mechanism": "PLAIN",
  516:         "payload": Binary(payload),
  517:         "autoAuthorize": 1,
  518:     }
  519:     conn.command(source, cmd)
  520: 
  521: 
  522: def _authenticate_x509(credentials: MongoCredential, conn: Connection) -> None:
  523:     """Authenticate using MONGODB-X509."""
  524:     ctx = conn.auth_ctx
  525:     if ctx and ctx.speculate_succeeded():
  526:         # MONGODB-X509 is done after the speculative auth step.
  527:         return
  528: 
  529:     cmd = _X509Context(credentials, conn.address).speculate_command()
  530:     conn.command("$external", cmd)
  531: 
  532: 
  533: def _authenticate_mongo_cr(credentials: MongoCredential, conn: Connection) -> None:
  534:     """Authenticate using MONGODB-CR."""
  535:     source = credentials.source
  536:     username = credentials.username
  537:     password = credentials.password
  538:     # Get a nonce
  539:     response = conn.command(source, {"getnonce": 1})
  540:     nonce = response["nonce"]
  541:     key = _auth_key(nonce, username, password)
  542: 
  543:     # Actually authenticate
  544:     query = {"authenticate": 1, "user": username, "nonce": nonce, "key": key}
  545:     conn.command(source, query)
  546: 
  547: 
  548: def _authenticate_default(credentials: MongoCredential, conn: Connection) -> None:
  549:     if conn.max_wire_version >= 7:
  550:         if conn.negotiated_mechs:
  551:             mechs = conn.negotiated_mechs
  552:         else:
  553:             source = credentials.source
  554:             cmd = conn.hello_cmd()
  555:             cmd["saslSupportedMechs"] = source + "." + credentials.username
  556:             mechs = conn.command(source, cmd, publish_events=False).get("saslSupportedMechs", [])
  557:         if "SCRAM-SHA-256" in mechs:
  558:             return _authenticate_scram(credentials, conn, "SCRAM-SHA-256")
  559:         else:
  560:             return _authenticate_scram(credentials, conn, "SCRAM-SHA-1")
  561:     else:
  562:         return _authenticate_scram(credentials, conn, "SCRAM-SHA-1")
  563: 
  564: 
  565: _AUTH_MAP: Mapping[str, Callable[..., None]] = {
  566:     "GSSAPI": _authenticate_gssapi,
  567:     "MONGODB-CR": _authenticate_mongo_cr,
  568:     "MONGODB-X509": _authenticate_x509,
  569:     "MONGODB-AWS": _authenticate_aws,
  570:     "MONGODB-OIDC": _authenticate_oidc,  # type:ignore[dict-item]
  571:     "PLAIN": _authenticate_plain,
  572:     "SCRAM-SHA-1": functools.partial(_authenticate_scram, mechanism="SCRAM-SHA-1"),
  573:     "SCRAM-SHA-256": functools.partial(_authenticate_scram, mechanism="SCRAM-SHA-256"),
  574:     "DEFAULT": _authenticate_default,
  575: }
  576: 
  577: 
  578: class _AuthContext:
  579:     def __init__(self, credentials: MongoCredential, address: tuple[str, int]) -> None:
  580:         self.credentials = credentials
  581:         self.speculative_authenticate: Optional[Mapping[str, Any]] = None
  582:         self.address = address
  583: 
  584:     @staticmethod
  585:     def from_credentials(
  586:         creds: MongoCredential, address: tuple[str, int]
  587:     ) -> Optional[_AuthContext]:
  588:         spec_cls = _SPECULATIVE_AUTH_MAP.get(creds.mechanism)
  589:         if spec_cls:
  590:             return cast(_AuthContext, spec_cls(creds, address))
  591:         return None
  592: 
  593:     def speculate_command(self) -> Optional[MutableMapping[str, Any]]:
  594:         raise NotImplementedError
  595: 
  596:     def parse_response(self, hello: Hello[Mapping[str, Any]]) -> None:
  597:         self.speculative_authenticate = hello.speculative_authenticate
  598: 
  599:     def speculate_succeeded(self) -> bool:
  600:         return bool(self.speculative_authenticate)
  601: 
  602: 
  603: class _ScramContext(_AuthContext):
  604:     def __init__(
  605:         self, credentials: MongoCredential, address: tuple[str, int], mechanism: str
  606:     ) -> None:
  607:         super().__init__(credentials, address)
  608:         self.scram_data: Optional[tuple[bytes, bytes]] = None
  609:         self.mechanism = mechanism
  610: 
  611:     def speculate_command(self) -> Optional[MutableMapping[str, Any]]:
  612:         nonce, first_bare, cmd = _authenticate_scram_start(self.credentials, self.mechanism)
  613:         # The 'db' field is included only on the speculative command.
  614:         cmd["db"] = self.credentials.source
  615:         # Save for later use.
  616:         self.scram_data = (nonce, first_bare)
  617:         return cmd
  618: 
  619: 
  620: class _X509Context(_AuthContext):
  621:     def speculate_command(self) -> MutableMapping[str, Any]:
  622:         cmd = {"authenticate": 1, "mechanism": "MONGODB-X509"}
  623:         if self.credentials.username is not None:
  624:             cmd["user"] = self.credentials.username
  625:         return cmd
  626: 
  627: 
  628: class _OIDCContext(_AuthContext):
  629:     def speculate_command(self) -> Optional[MutableMapping[str, Any]]:
  630:         authenticator = _get_authenticator(self.credentials, self.address)
  631:         cmd = authenticator.get_spec_auth_cmd()
  632:         if cmd is None:
  633:             return None
  634:         cmd["db"] = self.credentials.source
  635:         return cmd
  636: 
  637: 
  638: _SPECULATIVE_AUTH_MAP: Mapping[str, Any] = {
  639:     "MONGODB-X509": _X509Context,
  640:     "SCRAM-SHA-1": functools.partial(_ScramContext, mechanism="SCRAM-SHA-1"),
  641:     "SCRAM-SHA-256": functools.partial(_ScramContext, mechanism="SCRAM-SHA-256"),
  642:     "MONGODB-OIDC": _OIDCContext,
  643:     "DEFAULT": functools.partial(_ScramContext, mechanism="SCRAM-SHA-256"),
  644: }
  645: 
  646: 
  647: def authenticate(
  648:     credentials: MongoCredential, conn: Connection, reauthenticate: bool = False
  649: ) -> None:
  650:     """Authenticate connection."""
  651:     mechanism = credentials.mechanism
  652:     auth_func = _AUTH_MAP[mechanism]
  653:     if mechanism == "MONGODB-OIDC":
  654:         _authenticate_oidc(credentials, conn, reauthenticate)
  655:     else:
  656:         auth_func(credentials, conn)
