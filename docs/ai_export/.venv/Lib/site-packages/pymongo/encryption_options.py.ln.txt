    1: # Copyright 2019-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Support for automatic client-side field level encryption."""
   16: from __future__ import annotations
   17: 
   18: from typing import TYPE_CHECKING, Any, Mapping, Optional
   19: 
   20: try:
   21:     import pymongocrypt  # type:ignore[import] # noqa: F401
   22: 
   23:     _HAVE_PYMONGOCRYPT = True
   24: except ImportError:
   25:     _HAVE_PYMONGOCRYPT = False
   26: from bson import int64
   27: from pymongo.common import validate_is_mapping
   28: from pymongo.errors import ConfigurationError
   29: from pymongo.uri_parser import _parse_kms_tls_options
   30: 
   31: if TYPE_CHECKING:
   32:     from pymongo.mongo_client import MongoClient
   33:     from pymongo.typings import _DocumentTypeArg
   34: 
   35: 
   36: class AutoEncryptionOpts:
   37:     """Options to configure automatic client-side field level encryption."""
   38: 
   39:     def __init__(
   40:         self,
   41:         kms_providers: Mapping[str, Any],
   42:         key_vault_namespace: str,
   43:         key_vault_client: Optional[MongoClient[_DocumentTypeArg]] = None,
   44:         schema_map: Optional[Mapping[str, Any]] = None,
   45:         bypass_auto_encryption: bool = False,
   46:         mongocryptd_uri: str = "mongodb://localhost:27020",
   47:         mongocryptd_bypass_spawn: bool = False,
   48:         mongocryptd_spawn_path: str = "mongocryptd",
   49:         mongocryptd_spawn_args: Optional[list[str]] = None,
   50:         kms_tls_options: Optional[Mapping[str, Any]] = None,
   51:         crypt_shared_lib_path: Optional[str] = None,
   52:         crypt_shared_lib_required: bool = False,
   53:         bypass_query_analysis: bool = False,
   54:         encrypted_fields_map: Optional[Mapping[str, Any]] = None,
   55:     ) -> None:
   56:         """Options to configure automatic client-side field level encryption.
   57: 
   58:         Automatic client-side field level encryption requires MongoDB >=4.2
   59:         enterprise or a MongoDB >=4.2 Atlas cluster. Automatic encryption is not
   60:         supported for operations on a database or view and will result in
   61:         error.
   62: 
   63:         Although automatic encryption requires MongoDB >=4.2 enterprise or a
   64:         MongoDB >=4.2 Atlas cluster, automatic *decryption* is supported for all
   65:         users. To configure automatic *decryption* without automatic
   66:         *encryption* set ``bypass_auto_encryption=True``. Explicit
   67:         encryption and explicit decryption is also supported for all users
   68:         with the :class:`~pymongo.encryption.ClientEncryption` class.
   69: 
   70:         See :ref:`automatic-client-side-encryption` for an example.
   71: 
   72:         :param kms_providers: Map of KMS provider options. The `kms_providers`
   73:             map values differ by provider:
   74: 
   75:               - `aws`: Map with "accessKeyId" and "secretAccessKey" as strings.
   76:                 These are the AWS access key ID and AWS secret access key used
   77:                 to generate KMS messages. An optional "sessionToken" may be
   78:                 included to support temporary AWS credentials.
   79:               - `azure`: Map with "tenantId", "clientId", and "clientSecret" as
   80:                 strings. Additionally, "identityPlatformEndpoint" may also be
   81:                 specified as a string (defaults to 'login.microsoftonline.com').
   82:                 These are the Azure Active Directory credentials used to
   83:                 generate Azure Key Vault messages.
   84:               - `gcp`: Map with "email" as a string and "privateKey"
   85:                 as `bytes` or a base64 encoded string.
   86:                 Additionally, "endpoint" may also be specified as a string
   87:                 (defaults to 'oauth2.googleapis.com'). These are the
   88:                 credentials used to generate Google Cloud KMS messages.
   89:               - `kmip`: Map with "endpoint" as a host with required port.
   90:                 For example: ``{"endpoint": "example.com:443"}``.
   91:               - `local`: Map with "key" as `bytes` (96 bytes in length) or
   92:                 a base64 encoded string which decodes
   93:                 to 96 bytes. "key" is the master key used to encrypt/decrypt
   94:                 data keys. This key should be generated and stored as securely
   95:                 as possible.
   96: 
   97:             KMS providers may be specified with an optional name suffix
   98:             separated by a colon, for example "kmip:name" or "aws:name".
   99:             Named KMS providers do not support :ref:`CSFLE on-demand credentials`.
  100:             Named KMS providers enables more than one of each KMS provider type to be configured.
  101:             For example, to configure multiple local KMS providers::
  102: 
  103:               kms_providers = {
  104:                   "local": {"key": local_kek1},        # Unnamed KMS provider.
  105:                   "local:myname": {"key": local_kek2}, # Named KMS provider with name "myname".
  106:               }
  107: 
  108:         :param key_vault_namespace: The namespace for the key vault collection.
  109:             The key vault collection contains all data keys used for encryption
  110:             and decryption. Data keys are stored as documents in this MongoDB
  111:             collection. Data keys are protected with encryption by a KMS
  112:             provider.
  113:         :param key_vault_client: By default, the key vault collection
  114:             is assumed to reside in the same MongoDB cluster as the encrypted
  115:             MongoClient. Use this option to route data key queries to a
  116:             separate MongoDB cluster.
  117:         :param schema_map: Map of collection namespace ("db.coll") to
  118:             JSON Schema.  By default, a collection's JSONSchema is periodically
  119:             polled with the listCollections command. But a JSONSchema may be
  120:             specified locally with the schemaMap option.
  121: 
  122:             **Supplying a `schema_map` provides more security than relying on
  123:             JSON Schemas obtained from the server. It protects against a
  124:             malicious server advertising a false JSON Schema, which could trick
  125:             the client into sending unencrypted data that should be
  126:             encrypted.**
  127: 
  128:             Schemas supplied in the schemaMap only apply to configuring
  129:             automatic encryption for client side encryption. Other validation
  130:             rules in the JSON schema will not be enforced by the driver and
  131:             will result in an error.
  132:         :param bypass_auto_encryption: If ``True``, automatic
  133:             encryption will be disabled but automatic decryption will still be
  134:             enabled. Defaults to ``False``.
  135:         :param mongocryptd_uri: The MongoDB URI used to connect
  136:             to the *local* mongocryptd process. Defaults to
  137:             ``'mongodb://localhost:27020'``.
  138:         :param mongocryptd_bypass_spawn: If ``True``, the encrypted
  139:             MongoClient will not attempt to spawn the mongocryptd process.
  140:             Defaults to ``False``.
  141:         :param mongocryptd_spawn_path: Used for spawning the
  142:             mongocryptd process. Defaults to ``'mongocryptd'`` and spawns
  143:             mongocryptd from the system path.
  144:         :param mongocryptd_spawn_args: A list of string arguments to
  145:             use when spawning the mongocryptd process. Defaults to
  146:             ``['--idleShutdownTimeoutSecs=60']``. If the list does not include
  147:             the ``idleShutdownTimeoutSecs`` option then
  148:             ``'--idleShutdownTimeoutSecs=60'`` will be added.
  149:         :param kms_tls_options:  A map of KMS provider names to TLS
  150:             options to use when creating secure connections to KMS providers.
  151:             Accepts the same TLS options as
  152:             :class:`pymongo.mongo_client.MongoClient`. For example, to
  153:             override the system default CA file::
  154: 
  155:               kms_tls_options={'kmip': {'tlsCAFile': certifi.where()}}
  156: 
  157:             Or to supply a client certificate::
  158: 
  159:               kms_tls_options={'kmip': {'tlsCertificateKeyFile': 'client.pem'}}
  160:         :param crypt_shared_lib_path: Override the path to load the crypt_shared library.
  161:         :param crypt_shared_lib_required: If True, raise an error if libmongocrypt is
  162:             unable to load the crypt_shared library.
  163:         :param bypass_query_analysis: If ``True``, disable automatic analysis
  164:             of outgoing commands. Set `bypass_query_analysis` to use explicit
  165:             encryption on indexed fields without the MongoDB Enterprise Advanced
  166:             licensed crypt_shared library.
  167:         :param encrypted_fields_map: Map of collection namespace ("db.coll") to documents
  168:             that described the encrypted fields for Queryable Encryption. For example::
  169: 
  170:                 {
  171:                   "db.encryptedCollection": {
  172:                       "escCollection": "enxcol_.encryptedCollection.esc",
  173:                       "ecocCollection": "enxcol_.encryptedCollection.ecoc",
  174:                       "fields": [
  175:                           {
  176:                               "path": "firstName",
  177:                               "keyId": Binary.from_uuid(UUID('00000000-0000-0000-0000-000000000000')),
  178:                               "bsonType": "string",
  179:                               "queries": {"queryType": "equality"}
  180:                           },
  181:                           {
  182:                               "path": "ssn",
  183:                               "keyId": Binary.from_uuid(UUID('04104104-1041-0410-4104-104104104104')),
  184:                               "bsonType": "string"
  185:                           }
  186:                       ]
  187:                   }
  188:                 }
  189: 
  190:         .. versionchanged:: 4.2
  191:            Added `encrypted_fields_map` `crypt_shared_lib_path`, `crypt_shared_lib_required`,
  192:            and `bypass_query_analysis` parameters.
  193: 
  194:         .. versionchanged:: 4.0
  195:            Added the `kms_tls_options` parameter and the "kmip" KMS provider.
  196: 
  197:         .. versionadded:: 3.9
  198:         """
  199:         if not _HAVE_PYMONGOCRYPT:
  200:             raise ConfigurationError(
  201:                 "client side encryption requires the pymongocrypt library: "
  202:                 "install a compatible version with: "
  203:                 "python -m pip install 'pymongo[encryption]'"
  204:             )
  205:         if encrypted_fields_map:
  206:             validate_is_mapping("encrypted_fields_map", encrypted_fields_map)
  207:         self._encrypted_fields_map = encrypted_fields_map
  208:         self._bypass_query_analysis = bypass_query_analysis
  209:         self._crypt_shared_lib_path = crypt_shared_lib_path
  210:         self._crypt_shared_lib_required = crypt_shared_lib_required
  211:         self._kms_providers = kms_providers
  212:         self._key_vault_namespace = key_vault_namespace
  213:         self._key_vault_client = key_vault_client
  214:         self._schema_map = schema_map
  215:         self._bypass_auto_encryption = bypass_auto_encryption
  216:         self._mongocryptd_uri = mongocryptd_uri
  217:         self._mongocryptd_bypass_spawn = mongocryptd_bypass_spawn
  218:         self._mongocryptd_spawn_path = mongocryptd_spawn_path
  219:         if mongocryptd_spawn_args is None:
  220:             mongocryptd_spawn_args = ["--idleShutdownTimeoutSecs=60"]
  221:         self._mongocryptd_spawn_args = mongocryptd_spawn_args
  222:         if not isinstance(self._mongocryptd_spawn_args, list):
  223:             raise TypeError("mongocryptd_spawn_args must be a list")
  224:         if not any("idleShutdownTimeoutSecs" in s for s in self._mongocryptd_spawn_args):
  225:             self._mongocryptd_spawn_args.append("--idleShutdownTimeoutSecs=60")
  226:         # Maps KMS provider name to a SSLContext.
  227:         self._kms_ssl_contexts = _parse_kms_tls_options(kms_tls_options)
  228:         self._bypass_query_analysis = bypass_query_analysis
  229: 
  230: 
  231: class RangeOpts:
  232:     """Options to configure encrypted queries using the rangePreview algorithm."""
  233: 
  234:     def __init__(
  235:         self,
  236:         sparsity: int,
  237:         min: Optional[Any] = None,
  238:         max: Optional[Any] = None,
  239:         precision: Optional[int] = None,
  240:     ) -> None:
  241:         """Options to configure encrypted queries using the rangePreview algorithm.
  242: 
  243:         .. note:: This feature is experimental only, and not intended for public use.
  244: 
  245:         :param sparsity: An integer.
  246:         :param min: A BSON scalar value corresponding to the type being queried.
  247:         :param max: A BSON scalar value corresponding to the type being queried.
  248:         :param precision: An integer, may only be set for double or decimal128 types.
  249: 
  250:         .. versionadded:: 4.4
  251:         """
  252:         self.min = min
  253:         self.max = max
  254:         self.sparsity = sparsity
  255:         self.precision = precision
  256: 
  257:     @property
  258:     def document(self) -> dict[str, Any]:
  259:         doc = {}
  260:         for k, v in [
  261:             ("sparsity", int64.Int64(self.sparsity)),
  262:             ("precision", self.precision),
  263:             ("min", self.min),
  264:             ("max", self.max),
  265:         ]:
  266:             if v is not None:
  267:                 doc[k] = v
  268:         return doc
