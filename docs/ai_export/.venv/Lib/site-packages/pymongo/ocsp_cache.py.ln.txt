    1: # Copyright 2020-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Utilities for caching OCSP responses."""
   16: 
   17: from __future__ import annotations
   18: 
   19: from collections import namedtuple
   20: from datetime import datetime as _datetime
   21: from datetime import timezone
   22: from typing import TYPE_CHECKING, Any
   23: 
   24: from pymongo.lock import _create_lock
   25: 
   26: if TYPE_CHECKING:
   27:     from cryptography.x509.ocsp import OCSPRequest, OCSPResponse
   28: 
   29: 
   30: class _OCSPCache:
   31:     """A cache for OCSP responses."""
   32: 
   33:     CACHE_KEY_TYPE = namedtuple(  # type: ignore
   34:         "OcspResponseCacheKey",
   35:         ["hash_algorithm", "issuer_name_hash", "issuer_key_hash", "serial_number"],
   36:     )
   37: 
   38:     def __init__(self) -> None:
   39:         self._data: dict[Any, OCSPResponse] = {}
   40:         # Hold this lock when accessing _data.
   41:         self._lock = _create_lock()
   42: 
   43:     def _get_cache_key(self, ocsp_request: OCSPRequest) -> CACHE_KEY_TYPE:
   44:         return self.CACHE_KEY_TYPE(
   45:             hash_algorithm=ocsp_request.hash_algorithm.name.lower(),
   46:             issuer_name_hash=ocsp_request.issuer_name_hash,
   47:             issuer_key_hash=ocsp_request.issuer_key_hash,
   48:             serial_number=ocsp_request.serial_number,
   49:         )
   50: 
   51:     def __setitem__(self, key: OCSPRequest, value: OCSPResponse) -> None:
   52:         """Add/update a cache entry.
   53: 
   54:         'key' is of type cryptography.x509.ocsp.OCSPRequest
   55:         'value' is of type cryptography.x509.ocsp.OCSPResponse
   56: 
   57:         Validity of the OCSP response must be checked by caller.
   58:         """
   59:         with self._lock:
   60:             cache_key = self._get_cache_key(key)
   61: 
   62:             # As per the OCSP protocol, if the response's nextUpdate field is
   63:             # not set, the responder is indicating that newer revocation
   64:             # information is available all the time.
   65:             if value.next_update is None:
   66:                 self._data.pop(cache_key, None)
   67:                 return
   68: 
   69:             # Do nothing if the response is invalid.
   70:             if not (
   71:                 value.this_update
   72:                 <= _datetime.now(tz=timezone.utc).replace(tzinfo=None)
   73:                 < value.next_update
   74:             ):
   75:                 return
   76: 
   77:             # Cache new response OR update cached response if new response
   78:             # has longer validity.
   79:             cached_value = self._data.get(cache_key, None)
   80:             if cached_value is None or (
   81:                 cached_value.next_update is not None
   82:                 and cached_value.next_update < value.next_update
   83:             ):
   84:                 self._data[cache_key] = value
   85: 
   86:     def __getitem__(self, item: OCSPRequest) -> OCSPResponse:
   87:         """Get a cache entry if it exists.
   88: 
   89:         'item' is of type cryptography.x509.ocsp.OCSPRequest
   90: 
   91:         Raises KeyError if the item is not in the cache.
   92:         """
   93:         with self._lock:
   94:             cache_key = self._get_cache_key(item)
   95:             value = self._data[cache_key]
   96: 
   97:             # Return cached response if it is still valid.
   98:             assert value.this_update is not None
   99:             assert value.next_update is not None
  100:             if (
  101:                 value.this_update
  102:                 <= _datetime.now(tz=timezone.utc).replace(tzinfo=None)
  103:                 < value.next_update
  104:             ):
  105:                 return value
  106: 
  107:             self._data.pop(cache_key, None)
  108:             raise KeyError(cache_key)
