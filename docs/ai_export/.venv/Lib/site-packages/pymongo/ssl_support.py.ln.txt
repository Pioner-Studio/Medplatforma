    1: # Copyright 2014-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Support for SSL in PyMongo."""
   16: from __future__ import annotations
   17: 
   18: import warnings
   19: from typing import Optional
   20: 
   21: from pymongo.errors import ConfigurationError
   22: 
   23: HAVE_SSL = True
   24: 
   25: try:
   26:     import pymongo.pyopenssl_context as _ssl
   27: except (ImportError, AttributeError) as exc:
   28:     if isinstance(exc, AttributeError):
   29:         warnings.warn(
   30:             "Failed to use the installed version of PyOpenSSL. "
   31:             "Falling back to stdlib ssl, disabling OCSP support. "
   32:             "This is likely caused by incompatible versions "
   33:             "of PyOpenSSL < 23.2.0 and cryptography >= 42.0.0. "
   34:             "Try updating PyOpenSSL >= 23.2.0 to enable OCSP.",
   35:             UserWarning,
   36:             stacklevel=2,
   37:         )
   38:     try:
   39:         import pymongo.ssl_context as _ssl  # type: ignore[no-redef]
   40:     except ImportError:
   41:         HAVE_SSL = False
   42: 
   43: 
   44: if HAVE_SSL:
   45:     # Note: The validate* functions below deal with users passing
   46:     # CPython ssl module constants to configure certificate verification
   47:     # at a high level. This is legacy behavior, but requires us to
   48:     # import the ssl module even if we're only using it for this purpose.
   49:     import ssl as _stdlibssl  # noqa: F401
   50:     from ssl import CERT_NONE, CERT_REQUIRED
   51: 
   52:     HAS_SNI = _ssl.HAS_SNI
   53:     IPADDR_SAFE = True
   54:     SSLError = _ssl.SSLError
   55:     BLOCKING_IO_ERRORS = _ssl.BLOCKING_IO_ERRORS
   56: 
   57:     def get_ssl_context(
   58:         certfile: Optional[str],
   59:         passphrase: Optional[str],
   60:         ca_certs: Optional[str],
   61:         crlfile: Optional[str],
   62:         allow_invalid_certificates: bool,
   63:         allow_invalid_hostnames: bool,
   64:         disable_ocsp_endpoint_check: bool,
   65:     ) -> _ssl.SSLContext:
   66:         """Create and return an SSLContext object."""
   67:         verify_mode = CERT_NONE if allow_invalid_certificates else CERT_REQUIRED
   68:         ctx = _ssl.SSLContext(_ssl.PROTOCOL_SSLv23)
   69:         if verify_mode != CERT_NONE:
   70:             ctx.check_hostname = not allow_invalid_hostnames
   71:         else:
   72:             ctx.check_hostname = False
   73:         if hasattr(ctx, "check_ocsp_endpoint"):
   74:             ctx.check_ocsp_endpoint = not disable_ocsp_endpoint_check
   75:         if hasattr(ctx, "options"):
   76:             # Explicitly disable SSLv2, SSLv3 and TLS compression. Note that
   77:             # up to date versions of MongoDB 2.4 and above already disable
   78:             # SSLv2 and SSLv3, python disables SSLv2 by default in >= 2.7.7
   79:             # and >= 3.3.4 and SSLv3 in >= 3.4.3.
   80:             ctx.options |= _ssl.OP_NO_SSLv2
   81:             ctx.options |= _ssl.OP_NO_SSLv3
   82:             ctx.options |= _ssl.OP_NO_COMPRESSION
   83:             ctx.options |= _ssl.OP_NO_RENEGOTIATION
   84:         if certfile is not None:
   85:             try:
   86:                 ctx.load_cert_chain(certfile, None, passphrase)
   87:             except _ssl.SSLError as exc:
   88:                 raise ConfigurationError(f"Private key doesn't match certificate: {exc}") from None
   89:         if crlfile is not None:
   90:             if _ssl.IS_PYOPENSSL:
   91:                 raise ConfigurationError("tlsCRLFile cannot be used with PyOpenSSL")
   92:             # Match the server's behavior.
   93:             ctx.verify_flags = getattr(  # type:ignore[attr-defined]
   94:                 _ssl, "VERIFY_CRL_CHECK_LEAF", 0
   95:             )
   96:             ctx.load_verify_locations(crlfile)
   97:         if ca_certs is not None:
   98:             ctx.load_verify_locations(ca_certs)
   99:         elif verify_mode != CERT_NONE:
  100:             ctx.load_default_certs()
  101:         ctx.verify_mode = verify_mode
  102:         return ctx
  103: 
  104: else:
  105: 
  106:     class SSLError(Exception):  # type: ignore
  107:         pass
  108: 
  109:     HAS_SNI = False
  110:     IPADDR_SAFE = False
  111:     BLOCKING_IO_ERRORS = ()  # type:ignore[assignment]
  112: 
  113:     def get_ssl_context(*dummy):  # type: ignore
  114:         """No ssl module, raise ConfigurationError."""
  115:         raise ConfigurationError("The ssl module is not available.")
