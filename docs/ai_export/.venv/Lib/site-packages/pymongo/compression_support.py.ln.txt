    1: # Copyright 2018 MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: from __future__ import annotations
   15: 
   16: import warnings
   17: from typing import Any, Iterable, Optional, Union
   18: 
   19: from pymongo.hello import HelloCompat
   20: from pymongo.helpers import _SENSITIVE_COMMANDS
   21: 
   22: _SUPPORTED_COMPRESSORS = {"snappy", "zlib", "zstd"}
   23: _NO_COMPRESSION = {HelloCompat.CMD, HelloCompat.LEGACY_CMD}
   24: _NO_COMPRESSION.update(_SENSITIVE_COMMANDS)
   25: 
   26: 
   27: def _have_snappy() -> bool:
   28:     try:
   29:         import snappy  # type:ignore[import]  # noqa: F401
   30: 
   31:         return True
   32:     except ImportError:
   33:         return False
   34: 
   35: 
   36: def _have_zlib() -> bool:
   37:     try:
   38:         import zlib  # noqa: F401
   39: 
   40:         return True
   41:     except ImportError:
   42:         return False
   43: 
   44: 
   45: def _have_zstd() -> bool:
   46:     try:
   47:         import zstandard  # noqa: F401
   48: 
   49:         return True
   50:     except ImportError:
   51:         return False
   52: 
   53: 
   54: def validate_compressors(dummy: Any, value: Union[str, Iterable[str]]) -> list[str]:
   55:     try:
   56:         # `value` is string.
   57:         compressors = value.split(",")  # type: ignore[union-attr]
   58:     except AttributeError:
   59:         # `value` is an iterable.
   60:         compressors = list(value)
   61: 
   62:     for compressor in compressors[:]:
   63:         if compressor not in _SUPPORTED_COMPRESSORS:
   64:             compressors.remove(compressor)
   65:             warnings.warn(f"Unsupported compressor: {compressor}", stacklevel=2)
   66:         elif compressor == "snappy" and not _have_snappy():
   67:             compressors.remove(compressor)
   68:             warnings.warn(
   69:                 "Wire protocol compression with snappy is not available. "
   70:                 "You must install the python-snappy module for snappy support.",
   71:                 stacklevel=2,
   72:             )
   73:         elif compressor == "zlib" and not _have_zlib():
   74:             compressors.remove(compressor)
   75:             warnings.warn(
   76:                 "Wire protocol compression with zlib is not available. "
   77:                 "The zlib module is not available.",
   78:                 stacklevel=2,
   79:             )
   80:         elif compressor == "zstd" and not _have_zstd():
   81:             compressors.remove(compressor)
   82:             warnings.warn(
   83:                 "Wire protocol compression with zstandard is not available. "
   84:                 "You must install the zstandard module for zstandard support.",
   85:                 stacklevel=2,
   86:             )
   87:     return compressors
   88: 
   89: 
   90: def validate_zlib_compression_level(option: str, value: Any) -> int:
   91:     try:
   92:         level = int(value)
   93:     except Exception:
   94:         raise TypeError(f"{option} must be an integer, not {value!r}.") from None
   95:     if level < -1 or level > 9:
   96:         raise ValueError("%s must be between -1 and 9, not %d." % (option, level))
   97:     return level
   98: 
   99: 
  100: class CompressionSettings:
  101:     def __init__(self, compressors: list[str], zlib_compression_level: int):
  102:         self.compressors = compressors
  103:         self.zlib_compression_level = zlib_compression_level
  104: 
  105:     def get_compression_context(
  106:         self, compressors: Optional[list[str]]
  107:     ) -> Union[SnappyContext, ZlibContext, ZstdContext, None]:
  108:         if compressors:
  109:             chosen = compressors[0]
  110:             if chosen == "snappy":
  111:                 return SnappyContext()
  112:             elif chosen == "zlib":
  113:                 return ZlibContext(self.zlib_compression_level)
  114:             elif chosen == "zstd":
  115:                 return ZstdContext()
  116:             return None
  117:         return None
  118: 
  119: 
  120: class SnappyContext:
  121:     compressor_id = 1
  122: 
  123:     @staticmethod
  124:     def compress(data: bytes) -> bytes:
  125:         import snappy
  126: 
  127:         return snappy.compress(data)
  128: 
  129: 
  130: class ZlibContext:
  131:     compressor_id = 2
  132: 
  133:     def __init__(self, level: int):
  134:         self.level = level
  135: 
  136:     def compress(self, data: bytes) -> bytes:
  137:         import zlib
  138: 
  139:         return zlib.compress(data, self.level)
  140: 
  141: 
  142: class ZstdContext:
  143:     compressor_id = 3
  144: 
  145:     @staticmethod
  146:     def compress(data: bytes) -> bytes:
  147:         # ZstdCompressor is not thread safe.
  148:         # TODO: Use a pool?
  149:         import zstandard
  150: 
  151:         return zstandard.ZstdCompressor().compress(data)
  152: 
  153: 
  154: def decompress(data: bytes, compressor_id: int) -> bytes:
  155:     if compressor_id == SnappyContext.compressor_id:
  156:         # python-snappy doesn't support the buffer interface.
  157:         # https://github.com/andrix/python-snappy/issues/65
  158:         # This only matters when data is a memoryview since
  159:         # id(bytes(data)) == id(data) when data is a bytes.
  160:         import snappy
  161: 
  162:         return snappy.uncompress(bytes(data))
  163:     elif compressor_id == ZlibContext.compressor_id:
  164:         import zlib
  165: 
  166:         return zlib.decompress(data)
  167:     elif compressor_id == ZstdContext.compressor_id:
  168:         # ZstdDecompressor is not thread safe.
  169:         # TODO: Use a pool?
  170:         import zstandard
  171: 
  172:         return zstandard.ZstdDecompressor().decompress(data)
  173:     else:
  174:         raise ValueError("Unknown compressorId %d" % (compressor_id,))
