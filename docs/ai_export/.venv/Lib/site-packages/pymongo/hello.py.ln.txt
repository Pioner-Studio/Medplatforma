    1: # Copyright 2021-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """Helpers for the 'hello' and legacy hello commands."""
   16: from __future__ import annotations
   17: 
   18: import copy
   19: import datetime
   20: import itertools
   21: from typing import Any, Generic, Mapping, Optional
   22: 
   23: from bson.objectid import ObjectId
   24: from pymongo import common
   25: from pymongo.server_type import SERVER_TYPE
   26: from pymongo.typings import ClusterTime, _DocumentType
   27: 
   28: 
   29: class HelloCompat:
   30:     CMD = "hello"
   31:     LEGACY_CMD = "ismaster"
   32:     PRIMARY = "isWritablePrimary"
   33:     LEGACY_PRIMARY = "ismaster"
   34:     LEGACY_ERROR = "not master"
   35: 
   36: 
   37: def _get_server_type(doc: Mapping[str, Any]) -> int:
   38:     """Determine the server type from a hello response."""
   39:     if not doc.get("ok"):
   40:         return SERVER_TYPE.Unknown
   41: 
   42:     if doc.get("serviceId"):
   43:         return SERVER_TYPE.LoadBalancer
   44:     elif doc.get("isreplicaset"):
   45:         return SERVER_TYPE.RSGhost
   46:     elif doc.get("setName"):
   47:         if doc.get("hidden"):
   48:             return SERVER_TYPE.RSOther
   49:         elif doc.get(HelloCompat.PRIMARY):
   50:             return SERVER_TYPE.RSPrimary
   51:         elif doc.get(HelloCompat.LEGACY_PRIMARY):
   52:             return SERVER_TYPE.RSPrimary
   53:         elif doc.get("secondary"):
   54:             return SERVER_TYPE.RSSecondary
   55:         elif doc.get("arbiterOnly"):
   56:             return SERVER_TYPE.RSArbiter
   57:         else:
   58:             return SERVER_TYPE.RSOther
   59:     elif doc.get("msg") == "isdbgrid":
   60:         return SERVER_TYPE.Mongos
   61:     else:
   62:         return SERVER_TYPE.Standalone
   63: 
   64: 
   65: class Hello(Generic[_DocumentType]):
   66:     """Parse a hello response from the server.
   67: 
   68:     .. versionadded:: 3.12
   69:     """
   70: 
   71:     __slots__ = ("_doc", "_server_type", "_is_writable", "_is_readable", "_awaitable")
   72: 
   73:     def __init__(self, doc: _DocumentType, awaitable: bool = False) -> None:
   74:         self._server_type = _get_server_type(doc)
   75:         self._doc: _DocumentType = doc
   76:         self._is_writable = self._server_type in (
   77:             SERVER_TYPE.RSPrimary,
   78:             SERVER_TYPE.Standalone,
   79:             SERVER_TYPE.Mongos,
   80:             SERVER_TYPE.LoadBalancer,
   81:         )
   82: 
   83:         self._is_readable = self.server_type == SERVER_TYPE.RSSecondary or self._is_writable
   84:         self._awaitable = awaitable
   85: 
   86:     @property
   87:     def document(self) -> _DocumentType:
   88:         """The complete hello command response document.
   89: 
   90:         .. versionadded:: 3.4
   91:         """
   92:         return copy.copy(self._doc)
   93: 
   94:     @property
   95:     def server_type(self) -> int:
   96:         return self._server_type
   97: 
   98:     @property
   99:     def all_hosts(self) -> set[tuple[str, int]]:
  100:         """List of hosts, passives, and arbiters known to this server."""
  101:         return set(
  102:             map(
  103:                 common.clean_node,
  104:                 itertools.chain(
  105:                     self._doc.get("hosts", []),
  106:                     self._doc.get("passives", []),
  107:                     self._doc.get("arbiters", []),
  108:                 ),
  109:             )
  110:         )
  111: 
  112:     @property
  113:     def tags(self) -> Mapping[str, Any]:
  114:         """Replica set member tags or empty dict."""
  115:         return self._doc.get("tags", {})
  116: 
  117:     @property
  118:     def primary(self) -> Optional[tuple[str, int]]:
  119:         """This server's opinion about who the primary is, or None."""
  120:         if self._doc.get("primary"):
  121:             return common.partition_node(self._doc["primary"])
  122:         else:
  123:             return None
  124: 
  125:     @property
  126:     def replica_set_name(self) -> Optional[str]:
  127:         """Replica set name or None."""
  128:         return self._doc.get("setName")
  129: 
  130:     @property
  131:     def max_bson_size(self) -> int:
  132:         return self._doc.get("maxBsonObjectSize", common.MAX_BSON_SIZE)
  133: 
  134:     @property
  135:     def max_message_size(self) -> int:
  136:         return self._doc.get("maxMessageSizeBytes", 2 * self.max_bson_size)
  137: 
  138:     @property
  139:     def max_write_batch_size(self) -> int:
  140:         return self._doc.get("maxWriteBatchSize", common.MAX_WRITE_BATCH_SIZE)
  141: 
  142:     @property
  143:     def min_wire_version(self) -> int:
  144:         return self._doc.get("minWireVersion", common.MIN_WIRE_VERSION)
  145: 
  146:     @property
  147:     def max_wire_version(self) -> int:
  148:         return self._doc.get("maxWireVersion", common.MAX_WIRE_VERSION)
  149: 
  150:     @property
  151:     def set_version(self) -> Optional[int]:
  152:         return self._doc.get("setVersion")
  153: 
  154:     @property
  155:     def election_id(self) -> Optional[ObjectId]:
  156:         return self._doc.get("electionId")
  157: 
  158:     @property
  159:     def cluster_time(self) -> Optional[ClusterTime]:
  160:         return self._doc.get("$clusterTime")
  161: 
  162:     @property
  163:     def logical_session_timeout_minutes(self) -> Optional[int]:
  164:         return self._doc.get("logicalSessionTimeoutMinutes")
  165: 
  166:     @property
  167:     def is_writable(self) -> bool:
  168:         return self._is_writable
  169: 
  170:     @property
  171:     def is_readable(self) -> bool:
  172:         return self._is_readable
  173: 
  174:     @property
  175:     def me(self) -> Optional[tuple[str, int]]:
  176:         me = self._doc.get("me")
  177:         if me:
  178:             return common.clean_node(me)
  179:         return None
  180: 
  181:     @property
  182:     def last_write_date(self) -> Optional[datetime.datetime]:
  183:         return self._doc.get("lastWrite", {}).get("lastWriteDate")
  184: 
  185:     @property
  186:     def compressors(self) -> Optional[list[str]]:
  187:         return self._doc.get("compression")
  188: 
  189:     @property
  190:     def sasl_supported_mechs(self) -> list[str]:
  191:         """Supported authentication mechanisms for the current user.
  192: 
  193:         For example::
  194: 
  195:             >>> hello.sasl_supported_mechs
  196:             ["SCRAM-SHA-1", "SCRAM-SHA-256"]
  197: 
  198:         """
  199:         return self._doc.get("saslSupportedMechs", [])
  200: 
  201:     @property
  202:     def speculative_authenticate(self) -> Optional[Mapping[str, Any]]:
  203:         """The speculativeAuthenticate field."""
  204:         return self._doc.get("speculativeAuthenticate")
  205: 
  206:     @property
  207:     def topology_version(self) -> Optional[Mapping[str, Any]]:
  208:         return self._doc.get("topologyVersion")
  209: 
  210:     @property
  211:     def awaitable(self) -> bool:
  212:         return self._awaitable
  213: 
  214:     @property
  215:     def service_id(self) -> Optional[ObjectId]:
  216:         return self._doc.get("serviceId")
  217: 
  218:     @property
  219:     def hello_ok(self) -> bool:
  220:         return self._doc.get("helloOk", False)
  221: 
  222:     @property
  223:     def connection_id(self) -> Optional[int]:
  224:         return self._doc.get("connectionId")
