    1: # Copyright 2014-2016 MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Criteria to select some ServerDescriptions from a TopologyDescription."""
   16: from __future__ import annotations
   17: 
   18: from typing import TYPE_CHECKING, Any, Mapping, Optional, Sequence, TypeVar, cast
   19: 
   20: from pymongo.server_type import SERVER_TYPE
   21: 
   22: if TYPE_CHECKING:
   23:     from pymongo.server_description import ServerDescription
   24:     from pymongo.topology_description import TopologyDescription
   25: 
   26: 
   27: T = TypeVar("T")
   28: TagSet = Mapping[str, Any]
   29: TagSets = Sequence[TagSet]
   30: 
   31: 
   32: class Selection:
   33:     """Input or output of a server selector function."""
   34: 
   35:     @classmethod
   36:     def from_topology_description(cls, topology_description: TopologyDescription) -> Selection:
   37:         known_servers = topology_description.known_servers
   38:         primary = None
   39:         for sd in known_servers:
   40:             if sd.server_type == SERVER_TYPE.RSPrimary:
   41:                 primary = sd
   42:                 break
   43: 
   44:         return Selection(
   45:             topology_description,
   46:             topology_description.known_servers,
   47:             topology_description.common_wire_version,
   48:             primary,
   49:         )
   50: 
   51:     def __init__(
   52:         self,
   53:         topology_description: TopologyDescription,
   54:         server_descriptions: list[ServerDescription],
   55:         common_wire_version: Optional[int],
   56:         primary: Optional[ServerDescription],
   57:     ):
   58:         self.topology_description = topology_description
   59:         self.server_descriptions = server_descriptions
   60:         self.primary = primary
   61:         self.common_wire_version = common_wire_version
   62: 
   63:     def with_server_descriptions(self, server_descriptions: list[ServerDescription]) -> Selection:
   64:         return Selection(
   65:             self.topology_description, server_descriptions, self.common_wire_version, self.primary
   66:         )
   67: 
   68:     def secondary_with_max_last_write_date(self) -> Optional[ServerDescription]:
   69:         secondaries = secondary_server_selector(self)
   70:         if secondaries.server_descriptions:
   71:             return max(
   72:                 secondaries.server_descriptions, key=lambda sd: cast(float, sd.last_write_date)
   73:             )
   74:         return None
   75: 
   76:     @property
   77:     def primary_selection(self) -> Selection:
   78:         primaries = [self.primary] if self.primary else []
   79:         return self.with_server_descriptions(primaries)
   80: 
   81:     @property
   82:     def heartbeat_frequency(self) -> int:
   83:         return self.topology_description.heartbeat_frequency
   84: 
   85:     @property
   86:     def topology_type(self) -> int:
   87:         return self.topology_description.topology_type
   88: 
   89:     def __bool__(self) -> bool:
   90:         return bool(self.server_descriptions)
   91: 
   92:     def __getitem__(self, item: int) -> ServerDescription:
   93:         return self.server_descriptions[item]
   94: 
   95: 
   96: def any_server_selector(selection: T) -> T:
   97:     return selection
   98: 
   99: 
  100: def readable_server_selector(selection: Selection) -> Selection:
  101:     return selection.with_server_descriptions(
  102:         [s for s in selection.server_descriptions if s.is_readable]
  103:     )
  104: 
  105: 
  106: def writable_server_selector(selection: Selection) -> Selection:
  107:     return selection.with_server_descriptions(
  108:         [s for s in selection.server_descriptions if s.is_writable]
  109:     )
  110: 
  111: 
  112: def secondary_server_selector(selection: Selection) -> Selection:
  113:     return selection.with_server_descriptions(
  114:         [s for s in selection.server_descriptions if s.server_type == SERVER_TYPE.RSSecondary]
  115:     )
  116: 
  117: 
  118: def arbiter_server_selector(selection: Selection) -> Selection:
  119:     return selection.with_server_descriptions(
  120:         [s for s in selection.server_descriptions if s.server_type == SERVER_TYPE.RSArbiter]
  121:     )
  122: 
  123: 
  124: def writable_preferred_server_selector(selection: Selection) -> Selection:
  125:     """Like PrimaryPreferred but doesn't use tags or latency."""
  126:     return writable_server_selector(selection) or secondary_server_selector(selection)
  127: 
  128: 
  129: def apply_single_tag_set(tag_set: TagSet, selection: Selection) -> Selection:
  130:     """All servers matching one tag set.
  131: 
  132:     A tag set is a dict. A server matches if its tags are a superset:
  133:     A server tagged {'a': '1', 'b': '2'} matches the tag set {'a': '1'}.
  134: 
  135:     The empty tag set {} matches any server.
  136:     """
  137: 
  138:     def tags_match(server_tags: Mapping[str, Any]) -> bool:
  139:         for key, value in tag_set.items():
  140:             if key not in server_tags or server_tags[key] != value:
  141:                 return False
  142: 
  143:         return True
  144: 
  145:     return selection.with_server_descriptions(
  146:         [s for s in selection.server_descriptions if tags_match(s.tags)]
  147:     )
  148: 
  149: 
  150: def apply_tag_sets(tag_sets: TagSets, selection: Selection) -> Selection:
  151:     """All servers match a list of tag sets.
  152: 
  153:     tag_sets is a list of dicts. The empty tag set {} matches any server,
  154:     and may be provided at the end of the list as a fallback. So
  155:     [{'a': 'value'}, {}] expresses a preference for servers tagged
  156:     {'a': 'value'}, but accepts any server if none matches the first
  157:     preference.
  158:     """
  159:     for tag_set in tag_sets:
  160:         with_tag_set = apply_single_tag_set(tag_set, selection)
  161:         if with_tag_set:
  162:             return with_tag_set
  163: 
  164:     return selection.with_server_descriptions([])
  165: 
  166: 
  167: def secondary_with_tags_server_selector(tag_sets: TagSets, selection: Selection) -> Selection:
  168:     """All near-enough secondaries matching the tag sets."""
  169:     return apply_tag_sets(tag_sets, secondary_server_selector(selection))
  170: 
  171: 
  172: def member_with_tags_server_selector(tag_sets: TagSets, selection: Selection) -> Selection:
  173:     """All near-enough members matching the tag sets."""
  174:     return apply_tag_sets(tag_sets, readable_server_selector(selection))
