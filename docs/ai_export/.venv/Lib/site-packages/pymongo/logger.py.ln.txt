    1: # Copyright 2023-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: from __future__ import annotations
   15: 
   16: import enum
   17: import logging
   18: import os
   19: import warnings
   20: from typing import Any
   21: 
   22: from bson import UuidRepresentation, json_util
   23: from bson.json_util import JSONOptions, _truncate_documents
   24: from pymongo.monitoring import ConnectionCheckOutFailedReason, ConnectionClosedReason
   25: 
   26: 
   27: class _CommandStatusMessage(str, enum.Enum):
   28:     STARTED = "Command started"
   29:     SUCCEEDED = "Command succeeded"
   30:     FAILED = "Command failed"
   31: 
   32: 
   33: class _ServerSelectionStatusMessage(str, enum.Enum):
   34:     STARTED = "Server selection started"
   35:     SUCCEEDED = "Server selection succeeded"
   36:     FAILED = "Server selection failed"
   37:     WAITING = "Waiting for suitable server to become available"
   38: 
   39: 
   40: class _ConnectionStatusMessage(str, enum.Enum):
   41:     POOL_CREATED = "Connection pool created"
   42:     POOL_READY = "Connection pool ready"
   43:     POOL_CLOSED = "Connection pool closed"
   44:     POOL_CLEARED = "Connection pool cleared"
   45: 
   46:     CONN_CREATED = "Connection created"
   47:     CONN_READY = "Connection ready"
   48:     CONN_CLOSED = "Connection closed"
   49: 
   50:     CHECKOUT_STARTED = "Connection checkout started"
   51:     CHECKOUT_SUCCEEDED = "Connection checked out"
   52:     CHECKOUT_FAILED = "Connection checkout failed"
   53:     CHECKEDIN = "Connection checked in"
   54: 
   55: 
   56: _DEFAULT_DOCUMENT_LENGTH = 1000
   57: _SENSITIVE_COMMANDS = [
   58:     "authenticate",
   59:     "saslStart",
   60:     "saslContinue",
   61:     "getnonce",
   62:     "createUser",
   63:     "updateUser",
   64:     "copydbgetnonce",
   65:     "copydbsaslstart",
   66:     "copydb",
   67: ]
   68: _HELLO_COMMANDS = ["hello", "ismaster", "isMaster"]
   69: _REDACTED_FAILURE_FIELDS = ["code", "codeName", "errorLabels"]
   70: _DOCUMENT_NAMES = ["command", "reply", "failure"]
   71: _JSON_OPTIONS = JSONOptions(uuid_representation=UuidRepresentation.STANDARD)
   72: _COMMAND_LOGGER = logging.getLogger("pymongo.command")
   73: _CONNECTION_LOGGER = logging.getLogger("pymongo.connection")
   74: _SERVER_SELECTION_LOGGER = logging.getLogger("pymongo.serverSelection")
   75: _CLIENT_LOGGER = logging.getLogger("pymongo.client")
   76: _VERBOSE_CONNECTION_ERROR_REASONS = {
   77:     ConnectionClosedReason.POOL_CLOSED: "Connection pool was closed",
   78:     ConnectionCheckOutFailedReason.POOL_CLOSED: "Connection pool was closed",
   79:     ConnectionClosedReason.STALE: "Connection pool was stale",
   80:     ConnectionClosedReason.ERROR: "An error occurred while using the connection",
   81:     ConnectionCheckOutFailedReason.CONN_ERROR: "An error occurred while trying to establish a new connection",
   82:     ConnectionClosedReason.IDLE: "Connection was idle too long",
   83:     ConnectionCheckOutFailedReason.TIMEOUT: "Connection exceeded the specified timeout",
   84: }
   85: 
   86: 
   87: def _debug_log(logger: logging.Logger, **fields: Any) -> None:
   88:     logger.debug(LogMessage(**fields))
   89: 
   90: 
   91: def _verbose_connection_error_reason(reason: str) -> str:
   92:     return _VERBOSE_CONNECTION_ERROR_REASONS.get(reason, reason)
   93: 
   94: 
   95: def _info_log(logger: logging.Logger, **fields: Any) -> None:
   96:     logger.info(LogMessage(**fields))
   97: 
   98: 
   99: def _log_or_warn(logger: logging.Logger, message: str) -> None:
  100:     if logger.isEnabledFor(logging.INFO):
  101:         logger.info(message)
  102:     else:
  103:         # stacklevel=4 ensures that the warning is for the user's code.
  104:         warnings.warn(message, UserWarning, stacklevel=4)
  105: 
  106: 
  107: class LogMessage:
  108:     __slots__ = ("_kwargs", "_redacted")
  109: 
  110:     def __init__(self, **kwargs: Any):
  111:         self._kwargs = kwargs
  112:         self._redacted = False
  113: 
  114:     def __str__(self) -> str:
  115:         self._redact()
  116:         return "%s" % (
  117:             json_util.dumps(
  118:                 self._kwargs, json_options=_JSON_OPTIONS, default=lambda o: o.__repr__()
  119:             )
  120:         )
  121: 
  122:     def _is_sensitive(self, doc_name: str) -> bool:
  123:         is_speculative_authenticate = (
  124:             self._kwargs.pop("speculative_authenticate", False)
  125:             or "speculativeAuthenticate" in self._kwargs[doc_name]
  126:         )
  127:         is_sensitive_command = (
  128:             "commandName" in self._kwargs and self._kwargs["commandName"] in _SENSITIVE_COMMANDS
  129:         )
  130: 
  131:         is_sensitive_hello = (
  132:             self._kwargs["commandName"] in _HELLO_COMMANDS and is_speculative_authenticate
  133:         )
  134: 
  135:         return is_sensitive_command or is_sensitive_hello
  136: 
  137:     def _redact(self) -> None:
  138:         if self._redacted:
  139:             return
  140:         self._kwargs = {k: v for k, v in self._kwargs.items() if v is not None}
  141:         if "durationMS" in self._kwargs and hasattr(self._kwargs["durationMS"], "total_seconds"):
  142:             self._kwargs["durationMS"] = self._kwargs["durationMS"].total_seconds() * 1000
  143:         if "serviceId" in self._kwargs:
  144:             self._kwargs["serviceId"] = str(self._kwargs["serviceId"])
  145:         document_length = int(os.getenv("MONGOB_LOG_MAX_DOCUMENT_LENGTH", _DEFAULT_DOCUMENT_LENGTH))
  146:         if document_length < 0:
  147:             document_length = _DEFAULT_DOCUMENT_LENGTH
  148:         is_server_side_error = self._kwargs.pop("isServerSideError", False)
  149: 
  150:         for doc_name in _DOCUMENT_NAMES:
  151:             doc = self._kwargs.get(doc_name)
  152:             if doc:
  153:                 if doc_name == "failure" and is_server_side_error:
  154:                     doc = {k: v for k, v in doc.items() if k in _REDACTED_FAILURE_FIELDS}
  155:                 if doc_name != "failure" and self._is_sensitive(doc_name):
  156:                     doc = json_util.dumps({})
  157:                 else:
  158:                     truncated_doc = _truncate_documents(doc, document_length)[0]
  159:                     doc = json_util.dumps(
  160:                         truncated_doc,
  161:                         json_options=_JSON_OPTIONS,
  162:                         default=lambda o: o.__repr__(),
  163:                     )
  164:                 if len(doc) > document_length:
  165:                     doc = (
  166:                         doc.encode()[:document_length].decode("unicode-escape", "ignore")
  167:                     ) + "..."
  168:                 self._kwargs[doc_name] = doc
  169:         self._redacted = True
