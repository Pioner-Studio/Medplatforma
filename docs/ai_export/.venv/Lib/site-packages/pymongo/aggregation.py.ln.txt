    1: # Copyright 2019-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Perform aggregation operations on a collection or database."""
   16: from __future__ import annotations
   17: 
   18: from collections.abc import Callable, Mapping, MutableMapping
   19: from typing import TYPE_CHECKING, Any, Optional, Union
   20: 
   21: from pymongo import common
   22: from pymongo.collation import validate_collation_or_none
   23: from pymongo.errors import ConfigurationError
   24: from pymongo.read_preferences import ReadPreference, _AggWritePref
   25: 
   26: if TYPE_CHECKING:
   27:     from pymongo.client_session import ClientSession
   28:     from pymongo.collection import Collection
   29:     from pymongo.command_cursor import CommandCursor
   30:     from pymongo.database import Database
   31:     from pymongo.pool import Connection
   32:     from pymongo.read_preferences import _ServerMode
   33:     from pymongo.server import Server
   34:     from pymongo.typings import _DocumentType, _Pipeline
   35: 
   36: 
   37: class _AggregationCommand:
   38:     """The internal abstract base class for aggregation cursors.
   39: 
   40:     Should not be called directly by application developers. Use
   41:     :meth:`pymongo.collection.Collection.aggregate`, or
   42:     :meth:`pymongo.database.Database.aggregate` instead.
   43:     """
   44: 
   45:     def __init__(
   46:         self,
   47:         target: Union[Database, Collection],
   48:         cursor_class: type[CommandCursor],
   49:         pipeline: _Pipeline,
   50:         options: MutableMapping[str, Any],
   51:         explicit_session: bool,
   52:         let: Optional[Mapping[str, Any]] = None,
   53:         user_fields: Optional[MutableMapping[str, Any]] = None,
   54:         result_processor: Optional[Callable[[Mapping[str, Any], Connection], None]] = None,
   55:         comment: Any = None,
   56:     ) -> None:
   57:         if "explain" in options:
   58:             raise ConfigurationError(
   59:                 "The explain option is not supported. Use Database.command instead."
   60:             )
   61: 
   62:         self._target = target
   63: 
   64:         pipeline = common.validate_list("pipeline", pipeline)
   65:         self._pipeline = pipeline
   66:         self._performs_write = False
   67:         if pipeline and ("$out" in pipeline[-1] or "$merge" in pipeline[-1]):
   68:             self._performs_write = True
   69: 
   70:         common.validate_is_mapping("options", options)
   71:         if let is not None:
   72:             common.validate_is_mapping("let", let)
   73:             options["let"] = let
   74:         if comment is not None:
   75:             options["comment"] = comment
   76: 
   77:         self._options = options
   78: 
   79:         # This is the batchSize that will be used for setting the initial
   80:         # batchSize for the cursor, as well as the subsequent getMores.
   81:         self._batch_size = common.validate_non_negative_integer_or_none(
   82:             "batchSize", self._options.pop("batchSize", None)
   83:         )
   84: 
   85:         # If the cursor option is already specified, avoid overriding it.
   86:         self._options.setdefault("cursor", {})
   87:         # If the pipeline performs a write, we ignore the initial batchSize
   88:         # since the server doesn't return results in this case.
   89:         if self._batch_size is not None and not self._performs_write:
   90:             self._options["cursor"]["batchSize"] = self._batch_size
   91: 
   92:         self._cursor_class = cursor_class
   93:         self._explicit_session = explicit_session
   94:         self._user_fields = user_fields
   95:         self._result_processor = result_processor
   96: 
   97:         self._collation = validate_collation_or_none(options.pop("collation", None))
   98: 
   99:         self._max_await_time_ms = options.pop("maxAwaitTimeMS", None)
  100:         self._write_preference: Optional[_AggWritePref] = None
  101: 
  102:     @property
  103:     def _aggregation_target(self) -> Union[str, int]:
  104:         """The argument to pass to the aggregate command."""
  105:         raise NotImplementedError
  106: 
  107:     @property
  108:     def _cursor_namespace(self) -> str:
  109:         """The namespace in which the aggregate command is run."""
  110:         raise NotImplementedError
  111: 
  112:     def _cursor_collection(self, cursor_doc: Mapping[str, Any]) -> Collection:
  113:         """The Collection used for the aggregate command cursor."""
  114:         raise NotImplementedError
  115: 
  116:     @property
  117:     def _database(self) -> Database:
  118:         """The database against which the aggregation command is run."""
  119:         raise NotImplementedError
  120: 
  121:     def get_read_preference(
  122:         self, session: Optional[ClientSession]
  123:     ) -> Union[_AggWritePref, _ServerMode]:
  124:         if self._write_preference:
  125:             return self._write_preference
  126:         pref = self._target._read_preference_for(session)
  127:         if self._performs_write and pref != ReadPreference.PRIMARY:
  128:             self._write_preference = pref = _AggWritePref(pref)  # type: ignore[assignment]
  129:         return pref
  130: 
  131:     def get_cursor(
  132:         self,
  133:         session: Optional[ClientSession],
  134:         server: Server,
  135:         conn: Connection,
  136:         read_preference: _ServerMode,
  137:     ) -> CommandCursor[_DocumentType]:
  138:         # Serialize command.
  139:         cmd = {"aggregate": self._aggregation_target, "pipeline": self._pipeline}
  140:         cmd.update(self._options)
  141: 
  142:         # Apply this target's read concern if:
  143:         # readConcern has not been specified as a kwarg and either
  144:         # - server version is >= 4.2 or
  145:         # - server version is >= 3.2 and pipeline doesn't use $out
  146:         if ("readConcern" not in cmd) and (
  147:             not self._performs_write or (conn.max_wire_version >= 8)
  148:         ):
  149:             read_concern = self._target.read_concern
  150:         else:
  151:             read_concern = None
  152: 
  153:         # Apply this target's write concern if:
  154:         # writeConcern has not been specified as a kwarg and pipeline doesn't
  155:         # perform a write operation
  156:         if "writeConcern" not in cmd and self._performs_write:
  157:             write_concern = self._target._write_concern_for(session)
  158:         else:
  159:             write_concern = None
  160: 
  161:         # Run command.
  162:         result = conn.command(
  163:             self._database.name,
  164:             cmd,
  165:             read_preference,
  166:             self._target.codec_options,
  167:             parse_write_concern_error=True,
  168:             read_concern=read_concern,
  169:             write_concern=write_concern,
  170:             collation=self._collation,
  171:             session=session,
  172:             client=self._database.client,
  173:             user_fields=self._user_fields,
  174:         )
  175: 
  176:         if self._result_processor:
  177:             self._result_processor(result, conn)
  178: 
  179:         # Extract cursor from result or mock/fake one if necessary.
  180:         if "cursor" in result:
  181:             cursor = result["cursor"]
  182:         else:
  183:             # Unacknowledged $out/$merge write. Fake a cursor.
  184:             cursor = {
  185:                 "id": 0,
  186:                 "firstBatch": result.get("result", []),
  187:                 "ns": self._cursor_namespace,
  188:             }
  189: 
  190:         # Create and return cursor instance.
  191:         cmd_cursor = self._cursor_class(
  192:             self._cursor_collection(cursor),
  193:             cursor,
  194:             conn.address,
  195:             batch_size=self._batch_size or 0,
  196:             max_await_time_ms=self._max_await_time_ms,
  197:             session=session,
  198:             explicit_session=self._explicit_session,
  199:             comment=self._options.get("comment"),
  200:         )
  201:         cmd_cursor._maybe_pin_connection(conn)
  202:         return cmd_cursor
  203: 
  204: 
  205: class _CollectionAggregationCommand(_AggregationCommand):
  206:     _target: Collection
  207: 
  208:     @property
  209:     def _aggregation_target(self) -> str:
  210:         return self._target.name
  211: 
  212:     @property
  213:     def _cursor_namespace(self) -> str:
  214:         return self._target.full_name
  215: 
  216:     def _cursor_collection(self, cursor: Mapping[str, Any]) -> Collection:
  217:         """The Collection used for the aggregate command cursor."""
  218:         return self._target
  219: 
  220:     @property
  221:     def _database(self) -> Database:
  222:         return self._target.database
  223: 
  224: 
  225: class _CollectionRawAggregationCommand(_CollectionAggregationCommand):
  226:     def __init__(self, *args: Any, **kwargs: Any) -> None:
  227:         super().__init__(*args, **kwargs)
  228: 
  229:         # For raw-batches, we set the initial batchSize for the cursor to 0.
  230:         if not self._performs_write:
  231:             self._options["cursor"]["batchSize"] = 0
  232: 
  233: 
  234: class _DatabaseAggregationCommand(_AggregationCommand):
  235:     _target: Database
  236: 
  237:     @property
  238:     def _aggregation_target(self) -> int:
  239:         return 1
  240: 
  241:     @property
  242:     def _cursor_namespace(self) -> str:
  243:         return f"{self._target.name}.$cmd.aggregate"
  244: 
  245:     @property
  246:     def _database(self) -> Database:
  247:         return self._target
  248: 
  249:     def _cursor_collection(self, cursor: Mapping[str, Any]) -> Collection:
  250:         """The Collection used for the aggregate command cursor."""
  251:         # Collection level aggregate may not always return the "ns" field
  252:         # according to our MockupDB tests. Let's handle that case for db level
  253:         # aggregate too by defaulting to the <db>.$cmd.aggregate namespace.
  254:         _, collname = cursor.get("ns", self._cursor_namespace).split(".", 1)
  255:         return self._database[collname]
