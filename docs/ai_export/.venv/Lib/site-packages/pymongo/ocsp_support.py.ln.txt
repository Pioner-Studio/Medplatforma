    1: # Copyright 2020-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License"); you
    4: # may not use this file except in compliance with the License.  You
    5: # may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   12: # implied.  See the License for the specific language governing
   13: # permissions and limitations under the License.
   14: 
   15: """Support for requesting and verifying OCSP responses."""
   16: from __future__ import annotations
   17: 
   18: import logging as _logging
   19: import re as _re
   20: from datetime import datetime as _datetime
   21: from datetime import timezone
   22: from typing import TYPE_CHECKING, Iterable, Optional, Type, Union
   23: 
   24: from cryptography.exceptions import InvalidSignature as _InvalidSignature
   25: from cryptography.hazmat.backends import default_backend as _default_backend
   26: from cryptography.hazmat.primitives.asymmetric.dsa import DSAPublicKey as _DSAPublicKey
   27: from cryptography.hazmat.primitives.asymmetric.ec import ECDSA as _ECDSA
   28: from cryptography.hazmat.primitives.asymmetric.ec import (
   29:     EllipticCurvePublicKey as _EllipticCurvePublicKey,
   30: )
   31: from cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15 as _PKCS1v15
   32: from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey as _RSAPublicKey
   33: from cryptography.hazmat.primitives.asymmetric.x448 import (
   34:     X448PublicKey as _X448PublicKey,
   35: )
   36: from cryptography.hazmat.primitives.asymmetric.x25519 import (
   37:     X25519PublicKey as _X25519PublicKey,
   38: )
   39: from cryptography.hazmat.primitives.hashes import SHA1 as _SHA1
   40: from cryptography.hazmat.primitives.hashes import Hash as _Hash
   41: from cryptography.hazmat.primitives.serialization import Encoding as _Encoding
   42: from cryptography.hazmat.primitives.serialization import PublicFormat as _PublicFormat
   43: from cryptography.x509 import AuthorityInformationAccess as _AuthorityInformationAccess
   44: from cryptography.x509 import ExtendedKeyUsage as _ExtendedKeyUsage
   45: from cryptography.x509 import ExtensionNotFound as _ExtensionNotFound
   46: from cryptography.x509 import TLSFeature as _TLSFeature
   47: from cryptography.x509 import TLSFeatureType as _TLSFeatureType
   48: from cryptography.x509 import load_pem_x509_certificate as _load_pem_x509_certificate
   49: from cryptography.x509.ocsp import OCSPCertStatus as _OCSPCertStatus
   50: from cryptography.x509.ocsp import OCSPRequestBuilder as _OCSPRequestBuilder
   51: from cryptography.x509.ocsp import OCSPResponseStatus as _OCSPResponseStatus
   52: from cryptography.x509.ocsp import load_der_ocsp_response as _load_der_ocsp_response
   53: from cryptography.x509.oid import (
   54:     AuthorityInformationAccessOID as _AuthorityInformationAccessOID,
   55: )
   56: from cryptography.x509.oid import ExtendedKeyUsageOID as _ExtendedKeyUsageOID
   57: from requests import post as _post
   58: from requests.exceptions import RequestException as _RequestException
   59: 
   60: from pymongo import _csot
   61: 
   62: if TYPE_CHECKING:
   63:     from cryptography.hazmat.primitives.asymmetric import (
   64:         dsa,
   65:         ec,
   66:         ed448,
   67:         ed25519,
   68:         rsa,
   69:         x448,
   70:         x25519,
   71:     )
   72:     from cryptography.hazmat.primitives.asymmetric.utils import Prehashed
   73:     from cryptography.hazmat.primitives.hashes import HashAlgorithm
   74:     from cryptography.x509 import Certificate, Name
   75:     from cryptography.x509.extensions import Extension, ExtensionTypeVar
   76:     from cryptography.x509.ocsp import OCSPRequest, OCSPResponse
   77:     from OpenSSL.SSL import Connection
   78: 
   79:     from pymongo.ocsp_cache import _OCSPCache
   80:     from pymongo.pyopenssl_context import _CallbackData
   81: 
   82:     CertificateIssuerPublicKeyTypes = Union[
   83:         dsa.DSAPublicKey,
   84:         rsa.RSAPublicKey,
   85:         ec.EllipticCurvePublicKey,
   86:         ed25519.Ed25519PublicKey,
   87:         ed448.Ed448PublicKey,
   88:         x25519.X25519PublicKey,
   89:         x448.X448PublicKey,
   90:     ]
   91: 
   92: # Note: the functions in this module generally return 1 or 0. The reason
   93: # is simple. The entry point, ocsp_callback, is registered as a callback
   94: # with OpenSSL through PyOpenSSL. The callback must return 1 (success) or
   95: # 0 (failure).
   96: 
   97: _LOGGER = _logging.getLogger(__name__)
   98: 
   99: _CERT_REGEX = _re.compile(
  100:     b"-----BEGIN CERTIFICATE[^\r\n]+.+?-----END CERTIFICATE[^\r\n]+", _re.DOTALL
  101: )
  102: 
  103: 
  104: def _load_trusted_ca_certs(cafile: str) -> list[Certificate]:
  105:     """Parse the tlsCAFile into a list of certificates."""
  106:     with open(cafile, "rb") as f:
  107:         data = f.read()
  108: 
  109:     # Load all the certs in the file.
  110:     trusted_ca_certs = []
  111:     backend = _default_backend()
  112:     for cert_data in _re.findall(_CERT_REGEX, data):
  113:         trusted_ca_certs.append(_load_pem_x509_certificate(cert_data, backend))
  114:     return trusted_ca_certs
  115: 
  116: 
  117: def _get_issuer_cert(
  118:     cert: Certificate, chain: Iterable[Certificate], trusted_ca_certs: Optional[list[Certificate]]
  119: ) -> Optional[Certificate]:
  120:     issuer_name = cert.issuer
  121:     for candidate in chain:
  122:         if candidate.subject == issuer_name:
  123:             return candidate
  124: 
  125:     # Depending on the server's TLS library, the peer's cert chain may not
  126:     # include the self signed root CA. In this case we check the user
  127:     # provided tlsCAFile for the issuer.
  128:     # Remove once we use the verified peer cert chain in PYTHON-2147.
  129:     if trusted_ca_certs:
  130:         for candidate in trusted_ca_certs:
  131:             if candidate.subject == issuer_name:
  132:                 return candidate
  133:     return None
  134: 
  135: 
  136: def _verify_signature(
  137:     key: CertificateIssuerPublicKeyTypes,
  138:     signature: bytes,
  139:     algorithm: Union[Prehashed, HashAlgorithm, None],
  140:     data: bytes,
  141: ) -> int:
  142:     # See cryptography.x509.Certificate.public_key
  143:     # for the public key types.
  144:     try:
  145:         if isinstance(key, _RSAPublicKey):
  146:             key.verify(signature, data, _PKCS1v15(), algorithm)  # type: ignore[arg-type]
  147:         elif isinstance(key, _DSAPublicKey):
  148:             key.verify(signature, data, algorithm)  # type: ignore[arg-type]
  149:         elif isinstance(key, _EllipticCurvePublicKey):
  150:             key.verify(signature, data, _ECDSA(algorithm))  # type: ignore[arg-type]
  151:         elif isinstance(
  152:             key, (_X25519PublicKey, _X448PublicKey)
  153:         ):  # Curve25519 and Curve448 keys do not require verification
  154:             return 1
  155:         else:
  156:             key.verify(signature, data)
  157:     except _InvalidSignature:
  158:         return 0
  159:     return 1
  160: 
  161: 
  162: def _get_extension(
  163:     cert: Certificate, klass: Type[ExtensionTypeVar]
  164: ) -> Optional[Extension[ExtensionTypeVar]]:
  165:     try:
  166:         return cert.extensions.get_extension_for_class(klass)
  167:     except _ExtensionNotFound:
  168:         return None
  169: 
  170: 
  171: def _public_key_hash(cert: Certificate) -> bytes:
  172:     public_key = cert.public_key()
  173:     # https://tools.ietf.org/html/rfc2560#section-4.2.1
  174:     # "KeyHash ::= OCTET STRING -- SHA-1 hash of responder's public key
  175:     # (excluding the tag and length fields)"
  176:     # https://stackoverflow.com/a/46309453/600498
  177:     if isinstance(public_key, _RSAPublicKey):
  178:         pbytes = public_key.public_bytes(_Encoding.DER, _PublicFormat.PKCS1)
  179:     elif isinstance(public_key, _EllipticCurvePublicKey):
  180:         pbytes = public_key.public_bytes(_Encoding.X962, _PublicFormat.UncompressedPoint)
  181:     else:
  182:         pbytes = public_key.public_bytes(_Encoding.DER, _PublicFormat.SubjectPublicKeyInfo)
  183:     digest = _Hash(_SHA1(), backend=_default_backend())  # noqa: S303
  184:     digest.update(pbytes)
  185:     return digest.finalize()
  186: 
  187: 
  188: def _get_certs_by_key_hash(
  189:     certificates: Iterable[Certificate], issuer: Certificate, responder_key_hash: Optional[bytes]
  190: ) -> list[Certificate]:
  191:     return [
  192:         cert
  193:         for cert in certificates
  194:         if _public_key_hash(cert) == responder_key_hash and cert.issuer == issuer.subject
  195:     ]
  196: 
  197: 
  198: def _get_certs_by_name(
  199:     certificates: Iterable[Certificate], issuer: Certificate, responder_name: Optional[Name]
  200: ) -> list[Certificate]:
  201:     return [
  202:         cert
  203:         for cert in certificates
  204:         if cert.subject == responder_name and cert.issuer == issuer.subject
  205:     ]
  206: 
  207: 
  208: def _verify_response_signature(issuer: Certificate, response: OCSPResponse) -> int:
  209:     # Response object will have a responder_name or responder_key_hash
  210:     # not both.
  211:     name = response.responder_name
  212:     rkey_hash = response.responder_key_hash
  213:     ikey_hash = response.issuer_key_hash
  214:     if name is not None and name == issuer.subject or rkey_hash == ikey_hash:
  215:         _LOGGER.debug("Responder is issuer")
  216:         # Responder is the issuer
  217:         responder_cert = issuer
  218:     else:
  219:         _LOGGER.debug("Responder is a delegate")
  220:         # Responder is a delegate
  221:         # https://tools.ietf.org/html/rfc6960#section-2.6
  222:         # RFC6960, Section 3.2, Number 3
  223:         certs = response.certificates
  224:         if response.responder_name is not None:
  225:             responder_certs = _get_certs_by_name(certs, issuer, name)
  226:             _LOGGER.debug("Using responder name")
  227:         else:
  228:             responder_certs = _get_certs_by_key_hash(certs, issuer, rkey_hash)
  229:             _LOGGER.debug("Using key hash")
  230:         if not responder_certs:
  231:             _LOGGER.debug("No matching or valid responder certs.")
  232:             return 0
  233:         # XXX: Can there be more than one? If so, should we try each one
  234:         # until we find one that passes signature verification?
  235:         responder_cert = responder_certs[0]
  236: 
  237:         # RFC6960, Section 3.2, Number 4
  238:         ext = _get_extension(responder_cert, _ExtendedKeyUsage)
  239:         if not ext or _ExtendedKeyUsageOID.OCSP_SIGNING not in ext.value:
  240:             _LOGGER.debug("Delegate not authorized for OCSP signing")
  241:             return 0
  242:         if not _verify_signature(
  243:             issuer.public_key(),
  244:             responder_cert.signature,
  245:             responder_cert.signature_hash_algorithm,
  246:             responder_cert.tbs_certificate_bytes,
  247:         ):
  248:             _LOGGER.debug("Delegate signature verification failed")
  249:             return 0
  250:     # RFC6960, Section 3.2, Number 2
  251:     ret = _verify_signature(
  252:         responder_cert.public_key(),
  253:         response.signature,
  254:         response.signature_hash_algorithm,
  255:         response.tbs_response_bytes,
  256:     )
  257:     if not ret:
  258:         _LOGGER.debug("Response signature verification failed")
  259:     return ret
  260: 
  261: 
  262: def _build_ocsp_request(cert: Certificate, issuer: Certificate) -> OCSPRequest:
  263:     # https://cryptography.io/en/latest/x509/ocsp/#creating-requests
  264:     builder = _OCSPRequestBuilder()
  265:     builder = builder.add_certificate(cert, issuer, _SHA1())  # noqa: S303
  266:     return builder.build()
  267: 
  268: 
  269: def _verify_response(issuer: Certificate, response: OCSPResponse) -> int:
  270:     _LOGGER.debug("Verifying response")
  271:     # RFC6960, Section 3.2, Number 2, 3 and 4 happen here.
  272:     res = _verify_response_signature(issuer, response)
  273:     if not res:
  274:         return 0
  275: 
  276:     # Note that we are not using a "tolerance period" as discussed in
  277:     # https://tools.ietf.org/rfc/rfc5019.txt?
  278:     now = _datetime.now(tz=timezone.utc).replace(tzinfo=None)
  279:     # RFC6960, Section 3.2, Number 5
  280:     if response.this_update > now:
  281:         _LOGGER.debug("thisUpdate is in the future")
  282:         return 0
  283:     # RFC6960, Section 3.2, Number 6
  284:     if response.next_update and response.next_update < now:
  285:         _LOGGER.debug("nextUpdate is in the past")
  286:         return 0
  287:     return 1
  288: 
  289: 
  290: def _get_ocsp_response(
  291:     cert: Certificate, issuer: Certificate, uri: Union[str, bytes], ocsp_response_cache: _OCSPCache
  292: ) -> Optional[OCSPResponse]:
  293:     ocsp_request = _build_ocsp_request(cert, issuer)
  294:     try:
  295:         ocsp_response = ocsp_response_cache[ocsp_request]
  296:         _LOGGER.debug("Using cached OCSP response.")
  297:     except KeyError:
  298:         # CSOT: use the configured timeout or 5 seconds, whichever is smaller.
  299:         # Note that request's timeout works differently and does not imply an absolute
  300:         # deadline: https://requests.readthedocs.io/en/stable/user/quickstart/#timeouts
  301:         timeout = max(_csot.clamp_remaining(5), 0.001)
  302:         try:
  303:             response = _post(
  304:                 uri,
  305:                 data=ocsp_request.public_bytes(_Encoding.DER),
  306:                 headers={"Content-Type": "application/ocsp-request"},
  307:                 timeout=timeout,
  308:             )
  309:         except _RequestException as exc:
  310:             _LOGGER.debug("HTTP request failed: %s", exc)
  311:             return None
  312:         if response.status_code != 200:
  313:             _LOGGER.debug("HTTP request returned %d", response.status_code)
  314:             return None
  315:         ocsp_response = _load_der_ocsp_response(response.content)
  316:         _LOGGER.debug("OCSP response status: %r", ocsp_response.response_status)
  317:         if ocsp_response.response_status != _OCSPResponseStatus.SUCCESSFUL:
  318:             return None
  319:         # RFC6960, Section 3.2, Number 1. Only relevant if we need to
  320:         # talk to the responder directly.
  321:         # Accessing response.serial_number raises if response status is not
  322:         # SUCCESSFUL.
  323:         if ocsp_response.serial_number != ocsp_request.serial_number:
  324:             _LOGGER.debug("Response serial number does not match request")
  325:             return None
  326:         if not _verify_response(issuer, ocsp_response):
  327:             # The response failed verification.
  328:             return None
  329:         _LOGGER.debug("Caching OCSP response.")
  330:         ocsp_response_cache[ocsp_request] = ocsp_response
  331: 
  332:     return ocsp_response
  333: 
  334: 
  335: def _ocsp_callback(conn: Connection, ocsp_bytes: bytes, user_data: Optional[_CallbackData]) -> bool:
  336:     """Callback for use with OpenSSL.SSL.Context.set_ocsp_client_callback."""
  337:     # always pass in user_data but OpenSSL requires it be optional
  338:     assert user_data
  339:     pycert = conn.get_peer_certificate()
  340:     if pycert is None:
  341:         _LOGGER.debug("No peer cert?")
  342:         return False
  343:     cert = pycert.to_cryptography()
  344:     # Use the verified chain when available (pyopenssl>=20.0).
  345:     if hasattr(conn, "get_verified_chain"):
  346:         pychain = conn.get_verified_chain()
  347:         trusted_ca_certs = None
  348:     else:
  349:         pychain = conn.get_peer_cert_chain()
  350:         trusted_ca_certs = user_data.trusted_ca_certs
  351:     if not pychain:
  352:         _LOGGER.debug("No peer cert chain?")
  353:         return False
  354:     chain = [cer.to_cryptography() for cer in pychain]
  355:     issuer = _get_issuer_cert(cert, chain, trusted_ca_certs)
  356:     must_staple = False
  357:     # https://tools.ietf.org/html/rfc7633#section-4.2.3.1
  358:     ext_tls = _get_extension(cert, _TLSFeature)
  359:     if ext_tls is not None:
  360:         for feature in ext_tls.value:
  361:             if feature == _TLSFeatureType.status_request:
  362:                 _LOGGER.debug("Peer presented a must-staple cert")
  363:                 must_staple = True
  364:                 break
  365:     ocsp_response_cache = user_data.ocsp_response_cache
  366: 
  367:     # No stapled OCSP response
  368:     if ocsp_bytes == b"":
  369:         _LOGGER.debug("Peer did not staple an OCSP response")
  370:         if must_staple:
  371:             _LOGGER.debug("Must-staple cert with no stapled response, hard fail.")
  372:             return False
  373:         if not user_data.check_ocsp_endpoint:
  374:             _LOGGER.debug("OCSP endpoint checking is disabled, soft fail.")
  375:             # No stapled OCSP response, checking responder URI disabled, soft fail.
  376:             return True
  377:         # https://tools.ietf.org/html/rfc6960#section-3.1
  378:         ext_aia = _get_extension(cert, _AuthorityInformationAccess)
  379:         if ext_aia is None:
  380:             _LOGGER.debug("No authority access information, soft fail")
  381:             # No stapled OCSP response, no responder URI, soft fail.
  382:             return True
  383:         uris = [
  384:             desc.access_location.value
  385:             for desc in ext_aia.value
  386:             if desc.access_method == _AuthorityInformationAccessOID.OCSP
  387:         ]
  388:         if not uris:
  389:             _LOGGER.debug("No OCSP URI, soft fail")
  390:             # No responder URI, soft fail.
  391:             return True
  392:         if issuer is None:
  393:             _LOGGER.debug("No issuer cert?")
  394:             return False
  395:         _LOGGER.debug("Requesting OCSP data")
  396:         # When requesting data from an OCSP endpoint we only fail on
  397:         # successful, valid responses with a certificate status of REVOKED.
  398:         for uri in uris:
  399:             _LOGGER.debug("Trying %s", uri)
  400:             response = _get_ocsp_response(cert, issuer, uri, ocsp_response_cache)
  401:             if response is None:
  402:                 # The endpoint didn't respond in time, or the response was
  403:                 # unsuccessful or didn't match the request, or the response
  404:                 # failed verification.
  405:                 continue
  406:             _LOGGER.debug("OCSP cert status: %r", response.certificate_status)
  407:             if response.certificate_status == _OCSPCertStatus.GOOD:
  408:                 return True
  409:             if response.certificate_status == _OCSPCertStatus.REVOKED:
  410:                 return False
  411:         # Soft fail if we couldn't get a definitive status.
  412:         _LOGGER.debug("No definitive OCSP cert status, soft fail")
  413:         return True
  414: 
  415:     _LOGGER.debug("Peer stapled an OCSP response")
  416:     if issuer is None:
  417:         _LOGGER.debug("No issuer cert?")
  418:         return False
  419:     response = _load_der_ocsp_response(ocsp_bytes)
  420:     _LOGGER.debug("OCSP response status: %r", response.response_status)
  421:     # This happens in _request_ocsp when there is no stapled response so
  422:     # we know if we can compare serial numbers for the request and response.
  423:     if response.response_status != _OCSPResponseStatus.SUCCESSFUL:
  424:         return False
  425:     if not _verify_response(issuer, response):
  426:         return False
  427:     # Cache the verified, stapled response.
  428:     ocsp_response_cache[_build_ocsp_request(cert, issuer)] = response
  429:     _LOGGER.debug("OCSP cert status: %r", response.certificate_status)
  430:     if response.certificate_status == _OCSPCertStatus.REVOKED:
  431:         return False
  432:     return True
